16,BLOCK,-1,,<empty>,1,,1,1,,ANY
24,BLOCK,-1,,"{
    dbname_ = test::TmpDir() + ""/autocompact_test"";
    tiny_cache_ = NewLRUCache(100);
    options_.block_cache = tiny_cache_;
    DestroyDB(dbname_, options_);
    options_.create_if_missing = true;
    options_.compression = kNoCompression;
    ASSERT_OK(DB::Open(options_, dbname_, &db_));
  }",21,,20,1,,void
56,BLOCK,1,,<empty>,,,,1,,void
79,BLOCK,-1,,"{
    delete db_;
    DestroyDB(dbname_, Options());
    delete tiny_cache_;
  }",22,,30,1,,void
91,BLOCK,-1,,"{
    char buf[100];
    snprintf(buf, sizeof(buf), ""key%06d"", i);
    return std::string(buf);
  }",26,,36,2,,void
110,BLOCK,-1,,"{
    Range r(start, limit);
    uint64_t size;
    db_->GetApproximateSizes(&r, 1, &size);
    return size;
  }",57,,42,3,,void
131,BLOCK,-1,,<empty>,,,,2,,<empty>
156,BLOCK,-1,,"{
  std::string value(kValueSize, 'x');
  DBImpl* dbi = reinterpret_cast<DBImpl*>(db_);

  // Fill database
  for (int i = 0; i < kCount; i++) {
    ASSERT_OK(db_->Put(WriteOptions(), Key(i), value));
  }
  ASSERT_OK(dbi->TEST_CompactMemTable());

  // Delete everything
  for (int i = 0; i < kCount; i++) {
    ASSERT_OK(db_->Delete(WriteOptions(), Key(i)));
  }
  ASSERT_OK(dbi->TEST_CompactMemTable());

  // Get initial measurement of the space we will be reading.
  const int64_t initial_size = Size(Key(0), Key(n));
  const int64_t initial_other_size = Size(Key(n), Key(kCount));

  // Read until size drops significantly.
  std::string limit_key = Key(n);
  for (int read = 0; true; read++) {
    ASSERT_LT(read, 100) << ""Taking too long to compact"";
    Iterator* iter = db_->NewIterator(ReadOptions());
    for (iter->SeekToFirst();
         iter->Valid() && iter->key().ToString() < limit_key;
         iter->Next()) {
      // Drop data
    }
    delete iter;
    // Wait a little bit t...",38,,58,2,,void
168,BLOCK,-1,,<empty>,3,,63,1,,void
178,BLOCK,4,,"{
    ASSERT_OK(db_->Put(WriteOptions(), Key(i), value));
  }",36,,63,4,,void
180,BLOCK,1,,<empty>,,,,2,,void
205,BLOCK,1,,<empty>,,,,3,,void
222,BLOCK,-1,,<empty>,3,,69,1,,void
232,BLOCK,4,,"{
    ASSERT_OK(db_->Delete(WriteOptions(), Key(i)));
  }",36,,69,4,,void
234,BLOCK,1,,<empty>,,,,1,,void
258,BLOCK,1,,<empty>,,,,3,,void
296,BLOCK,-1,,<empty>,3,,80,1,,void
304,BLOCK,4,,"{
    ASSERT_LT(read, 100) << ""Taking too long to compact"";
    Iterator* iter = db_->NewIterator(ReadOptions());
    for (iter->SeekToFirst();
         iter->Valid() && iter->key().ToString() < limit_key;
         iter->Next()) {
      // Drop data
    }
    delete iter;
    // Wait a little bit to allow any triggered compactions to complete.
    Env::Default()->SleepForMicroseconds(1000000);
    uint64_t size = Size(Key(0), Key(n));
    fprintf(stderr, ""iter %3d => %7.3f MB [other %7.3f MB]\n"",
            read+1, size/1048576.0, Size(Key(n), Key(kCount))/1048576.0);
    if (size <= initial_size/10) {
      break;
    }
  }",36,,80,4,,void
309,BLOCK,1,,<empty>,,,,3,,void
333,BLOCK,-1,,<empty>,5,,83,1,,void
356,BLOCK,4,,"{
      // Drop data
    }",24,,85,4,,void
397,BLOCK,-1,,"{
      break;
    }",34,,94,2,,void
409,BLOCK,1,,<empty>,,,,4,,void
427,BLOCK,1,,<empty>,,,,4,,void
449,BLOCK,-1,,<empty>,,,,1,,<empty>
453,BLOCK,-1,,"TEST(AutoCompactTest, ReadAll)",1,,106,1,,void
477,BLOCK,-1,,"{
  DoReads(kCount);
}",32,,106,1,,void
484,BLOCK,-1,,<empty>,,,,1,,<empty>
488,BLOCK,-1,,"TEST(AutoCompactTest, ReadHalf)",1,,110,1,,void
512,BLOCK,-1,,"{
  DoReads(kCount/2);
}",33,,110,1,,void
522,BLOCK,-1,,"{
  return leveldb::test::RunAllTests();
}",33,,116,3,,void
552,BLOCK,-1,,<empty>,1,,1,1,,ANY
561,BLOCK,-1,,"{
  Status s;
  meta->file_size = 0;
  iter->SeekToFirst();

  std::string fname = TableFileName(dbname, meta->number);
  if (iter->Valid()) {
    WritableFile* file;
    s = env->NewWritableFile(fname, &file);
    if (!s.ok()) {
      return s;
    }

    TableBuilder* builder = new TableBuilder(options, file);
    meta->smallest.DecodeFrom(iter->key());
    for (; iter->Valid(); iter->Next()) {
      Slice key = iter->key();
      meta->largest.DecodeFrom(key);
      builder->Add(key, iter->value());
    }

    // Finish and check for builder errors
    if (s.ok()) {
      s = builder->Finish();
      if (s.ok()) {
        meta->file_size = builder->FileSize();
        assert(meta->file_size > 0);
      }
    } else {
      builder->Abandon();
    }
    delete builder;

    // Finish and check for file errors
    if (s.ok()) {
      s = file->Sync();
    }
    if (s.ok()) {
      s = file->Close();
    }
    delete file;
    file = NULL;

    if (s.ok()) {
      // Verify that the...",39,,22,7,,void
585,BLOCK,-1,,"{
    WritableFile* file;
    s = env->NewWritableFile(fname, &file);
    if (!s.ok()) {
      return s;
    }

    TableBuilder* builder = new TableBuilder(options, file);
    meta->smallest.DecodeFrom(iter->key());
    for (; iter->Valid(); iter->Next()) {
      Slice key = iter->key();
      meta->largest.DecodeFrom(key);
      builder->Add(key, iter->value());
    }

    // Finish and check for builder errors
    if (s.ok()) {
      s = builder->Finish();
      if (s.ok()) {
        meta->file_size = builder->FileSize();
        assert(meta->file_size > 0);
      }
    } else {
      builder->Abandon();
    }
    delete builder;

    // Finish and check for file errors
    if (s.ok()) {
      s = file->Sync();
    }
    if (s.ok()) {
      s = file->Close();
    }
    delete file;
    file = NULL;

    if (s.ok()) {
      // Verify that the table is usable
      Iterator* it = table_cache->NewIterator(ReadOptions(),
                                              meta->number,
   ...",22,,28,2,,void
602,BLOCK,-1,,"{
      return s;
    }",18,,31,2,,void
623,BLOCK,-1,,<empty>,5,,37,1,,void
632,BLOCK,4,,"{
      Slice key = iter->key();
      meta->largest.DecodeFrom(key);
      builder->Add(key, iter->value());
    }",41,,37,4,,void
661,BLOCK,-1,,"{
      s = builder->Finish();
      if (s.ok()) {
        meta->file_size = builder->FileSize();
        assert(meta->file_size > 0);
      }
    }",17,,44,2,,void
673,BLOCK,-1,,"{
        meta->file_size = builder->FileSize();
        assert(meta->file_size > 0);
      }",19,,46,2,,void
689,BLOCK,-1,,"{
      builder->Abandon();
    }",12,,50,1,,void
701,BLOCK,-1,,"{
      s = file->Sync();
    }",17,,56,2,,void
713,BLOCK,-1,,"{
      s = file->Close();
    }",17,,59,2,,void
730,BLOCK,-1,,"{
      // Verify that the table is usable
      Iterator* it = table_cache->NewIterator(ReadOptions(),
                                              meta->number,
                                              meta->file_size);
      s = it->status();
      delete it;
    }",17,,65,2,,void
762,BLOCK,-1,,"{
    s = iter->status();
  }",29,,76,2,,void
780,BLOCK,-1,,"{
    // Keep it
  }",38,,80,2,,void
782,BLOCK,-1,,"{
    env->DeleteFile(fname);
  }",10,,82,1,,void
798,BLOCK,-1,,<empty>,1,,1,1,,ANY
813,BLOCK,-1,,<empty>,,,,7,,<empty>
844,BLOCK,-1,,<empty>,1,,1,1,,ANY
875,BLOCK,-1,,<empty>,,,,2,,<empty>
884,BLOCK,-1,,<empty>,,,,6,,<empty>
889,BLOCK,-1,,<empty>,,,,2,,<empty>
893,BLOCK,-1,,"{
    (*destructor_)(state_);
  }",35,,69,1,,void
903,BLOCK,-1,,"{
    return (*compare_)(state_, a.data(), a.size(), b.data(), b.size());
  }",61,,73,3,,void
928,BLOCK,-1,,"{
    return (*name_)(state_);
  }",36,,77,1,,void
939,BLOCK,-1,,{ },72,,82,3,,void
944,BLOCK,-1,,{ },59,,83,2,,void
951,BLOCK,-1,,<empty>,,,,2,,<empty>
956,BLOCK,-1,,<empty>,,,,2,,<empty>
965,BLOCK,-1,,<empty>,,,,6,,<empty>
974,BLOCK,-1,,<empty>,,,,6,,<empty>
978,BLOCK,-1,,"{
    (*destructor_)(state_);
  }",37,,100,1,,void
986,BLOCK,-1,,"{
    return (*name_)(state_);
  }",36,,104,1,,void
998,BLOCK,-1,,"{
    std::vector<const char*> key_pointers(n);
    std::vector<size_t> key_sizes(n);
    for (int i = 0; i < n; i++) {
      key_pointers[i] = keys[i].data();
      key_sizes[i] = keys[i].size();
    }
    size_t len;
    char* filter = (*create_)(state_, &key_pointers[0], &key_sizes[0], n, &len);
    dst->append(filter, len);
    free(filter);
  }",79,,108,4,,void
1011,BLOCK,-1,,<empty>,5,,111,1,,void
1021,BLOCK,4,,"{
      key_pointers[i] = keys[i].data();
      key_sizes[i] = keys[i].size();
    }",33,,111,4,,void
1074,BLOCK,-1,,"{
    return (*key_match_)(state_, key.data(), key.size(),
                         filter.data(), filter.size());
  }",73,,121,3,,void
1104,BLOCK,-1,,"{
  assert(errptr != NULL);
  if (s.ok()) {
    return false;
  } else if (*errptr == NULL) {
    *errptr = strdup(s.ToString().c_str());
  } else {
    // TODO(sanjay): Merge with existing error?
    free(*errptr);
    *errptr = strdup(s.ToString().c_str());
  }
  return true;
}",55,,132,3,,void
1114,BLOCK,-1,,"{
    return false;
  }",15,,134,2,,void
1118,BLOCK,-1,,<empty>,10,,136,1,,void
1124,BLOCK,-1,,"{
    *errptr = strdup(s.ToString().c_str());
  }",31,,136,2,,void
1137,BLOCK,-1,,"{
    // TODO(sanjay): Merge with existing error?
    free(*errptr);
    *errptr = strdup(s.ToString().c_str());
  }",10,,138,1,,void
1158,BLOCK,-1,,"{
  char* result = reinterpret_cast<char*>(malloc(sizeof(char) * str.size()));
  memcpy(result, str.data(), sizeof(char) * str.size());
  return result;
}",49,,146,2,,void
1193,BLOCK,-1,,"{
  DB* db;
  if (SaveError(errptr, DB::Open(options->rep, std::string(name), &db))) {
    return NULL;
  }
  leveldb_t* result = new leveldb_t;
  result->rep = db;
  return result;
}",20,,155,4,,void
1212,BLOCK,-1,,"{
    return NULL;
  }",74,,157,2,,void
1231,BLOCK,-1,,"{
  delete db->rep;
  delete db;
}",35,,165,2,,void
1248,BLOCK,-1,,"{
  SaveError(errptr,
            db->rep->Put(options->rep, Slice(key, keylen), Slice(val, vallen)));
}",20,,175,8,,void
1274,BLOCK,-1,,"{
  SaveError(errptr, db->rep->Delete(options->rep, Slice(key, keylen)));
}",20,,184,6,,void
1296,BLOCK,-1,,"{
  SaveError(errptr, db->rep->Write(options->rep, &batch->rep));
}",20,,193,5,,void
1321,BLOCK,-1,,"{
  char* result = NULL;
  std::string tmp;
  Status s = db->rep->Get(options->rep, Slice(key, keylen), &tmp);
  if (s.ok()) {
    *vallen = tmp.size();
    result = CopyString(tmp);
  } else {
    *vallen = 0;
    if (!s.IsNotFound()) {
      SaveError(errptr, s);
    }
  }
  return result;
}",20,,202,7,,void
1349,BLOCK,-1,,"{
    *vallen = tmp.size();
    result = CopyString(tmp);
  }",15,,206,2,,void
1362,BLOCK,-1,,"{
    *vallen = 0;
    if (!s.IsNotFound()) {
      SaveError(errptr, s);
    }
  }",10,,209,1,,void
1373,BLOCK,-1,,"{
      SaveError(errptr, s);
    }",26,,211,2,,void
1384,BLOCK,-1,,"{
  leveldb_iterator_t* result = new leveldb_iterator_t;
  result->rep = db->rep->NewIterator(options->rep);
  return result;
}",43,,220,3,,void
1409,BLOCK,-1,,"{
  leveldb_snapshot_t* result = new leveldb_snapshot_t;
  result->rep = db->rep->GetSnapshot();
  return result;
}",20,,227,2,,void
1432,BLOCK,-1,,"{
  db->rep->ReleaseSnapshot(snapshot->rep);
  delete snapshot;
}",41,,235,3,,void
1449,BLOCK,-1,,"{
  std::string tmp;
  if (db->rep->GetProperty(Slice(propname), &tmp)) {
    // We use strdup() since we expect human readable output.
    return strdup(tmp.c_str());
  } else {
    return NULL;
  }
}",27,,242,3,,void
1462,BLOCK,-1,,"{
    // We use strdup() since we expect human readable output.
    return strdup(tmp.c_str());
  }",52,,244,2,,void
1470,BLOCK,-1,,"{
    return NULL;
  }",10,,247,1,,void
1483,BLOCK,-1,,"{
  Range* ranges = new Range[num_ranges];
  for (int i = 0; i < num_ranges; i++) {
    ranges[i].start = Slice(range_start_key[i], range_start_key_len[i]);
    ranges[i].limit = Slice(range_limit_key[i], range_limit_key_len[i]);
  }
  db->rep->GetApproximateSizes(ranges, num_ranges, sizes);
  delete[] ranges;
}",22,,257,8,,void
1490,BLOCK,-1,,<empty>,3,,259,1,,void
1500,BLOCK,4,,"{
    ranges[i].start = Slice(range_start_key[i], range_start_key_len[i]);
    ranges[i].limit = Slice(range_limit_key[i], range_limit_key_len[i]);
  }",40,,259,4,,void
1546,BLOCK,-1,,"{
  Slice a, b;
  db->rep->CompactRange(
      // Pass NULL Slice if corresponding ""const char*"" is NULL
      (start_key ? (a = Slice(start_key, start_key_len), &a) : NULL),
      (limit_key ? (b = Slice(limit_key, limit_key_len), &b) : NULL));
}",50,,270,6,,void
1585,BLOCK,-1,,"{
  SaveError(errptr, DestroyDB(name, options->rep));
}",20,,281,4,,void
1599,BLOCK,-1,,"{
  SaveError(errptr, RepairDB(name, options->rep));
}",20,,288,4,,void
1611,BLOCK,-1,,"{
  delete iter->rep;
  delete iter;
}",53,,292,2,,void
1622,BLOCK,-1,,"{
  return iter->rep->Valid();
}",66,,297,2,,void
1634,BLOCK,-1,,"{
  iter->rep->SeekToFirst();
}",59,,301,2,,void
1645,BLOCK,-1,,"{
  iter->rep->SeekToLast();
}",58,,305,2,,void
1658,BLOCK,-1,,"{
  iter->rep->Seek(Slice(k, klen));
}",78,,309,4,,void
1672,BLOCK,-1,,"{
  iter->rep->Next();
}",50,,313,2,,void
1683,BLOCK,-1,,"{
  iter->rep->Prev();
}",50,,317,2,,void
1695,BLOCK,-1,,"{
  Slice s = iter->rep->key();
  *klen = s.size();
  return s.data();
}",76,,321,3,,void
1722,BLOCK,-1,,"{
  Slice s = iter->rep->value();
  *vlen = s.size();
  return s.data();
}",78,,327,3,,void
1749,BLOCK,-1,,"{
  SaveError(errptr, iter->rep->status());
}",76,,333,3,,void
1761,BLOCK,-1,,"{
  return new leveldb_writebatch_t;
}",51,,337,1,,void
1769,BLOCK,-1,,"{
  delete b;
}",58,,341,2,,void
1776,BLOCK,-1,,"{
  b->rep.Clear();
}",56,,345,2,,void
1791,BLOCK,-1,,"{
  b->rep.Put(Slice(key, klen), Slice(val, vlen));
}",35,,352,6,,void
1810,BLOCK,-1,,"{
  b->rep.Delete(Slice(key, klen));
}",35,,358,4,,void
1827,BLOCK,-1,,"{
  class H : public WriteBatch::Handler {
   public:
    void* state_;
    void (*put_)(void*, const char* k, size_t klen, const char* v, size_t vlen);
    void (*deleted_)(void*, const char* k, size_t klen);
    virtual void Put(const Slice& key, const Slice& value) {
      (*put_)(state_, key.data(), key.size(), value.data(), value.size());
    }
    virtual void Delete(const Slice& key) {
      (*deleted_)(state_, key.data(), key.size());
    }
  };
  H handler;
  handler.state_ = state;
  handler.put_ = put;
  handler.deleted_ = deleted;
  b->rep.Iterate(&handler);
}",57,,366,5,,void
1855,BLOCK,-1,,"{
  return new leveldb_options_t;
}",45,,386,1,,void
1863,BLOCK,-1,,"{
  delete options;
}",58,,390,2,,void
1871,BLOCK,-1,,"{
  opt->rep.comparator = cmp;
}",32,,396,3,,void
1884,BLOCK,-1,,"{
  opt->rep.filter_policy = policy;
}",37,,402,3,,void
1897,BLOCK,-1,,"{
  opt->rep.create_if_missing = v;
}",46,,407,3,,void
1910,BLOCK,-1,,"{
  opt->rep.error_if_exists = v;
}",46,,412,3,,void
1923,BLOCK,-1,,"{
  opt->rep.paranoid_checks = v;
}",46,,417,3,,void
1936,BLOCK,-1,,"{
  opt->rep.env = (env ? env->rep : NULL);
}",74,,421,3,,void
1954,BLOCK,-1,,"{
  opt->rep.info_log = (l ? l->rep : NULL);
}",80,,425,3,,void
1972,BLOCK,-1,,"{
  opt->rep.write_buffer_size = s;
}",78,,429,3,,void
1985,BLOCK,-1,,"{
  opt->rep.max_open_files = n;
}",72,,433,3,,void
1998,BLOCK,-1,,"{
  opt->rep.block_cache = c->rep;
}",76,,437,3,,void
2013,BLOCK,-1,,"{
  opt->rep.block_size = s;
}",71,,441,3,,void
2026,BLOCK,-1,,"{
  opt->rep.block_restart_interval = n;
}",80,,445,3,,void
2039,BLOCK,-1,,"{
  opt->rep.compression = static_cast<CompressionType>(t);
}",69,,449,3,,void
2056,BLOCK,-1,,"{
  leveldb_comparator_t* result = new leveldb_comparator_t;
  result->state_ = state;
  result->destructor_ = destructor;
  result->compare_ = compare;
  result->name_ = name;
  return result;
}",33,,460,5,,void
2088,BLOCK,-1,,"{
  delete cmp;
}",60,,469,2,,void
2099,BLOCK,-1,,"{
  leveldb_filterpolicy_t* result = new leveldb_filterpolicy_t;
  result->state_ = state;
  result->destructor_ = destructor;
  result->create_ = create_filter;
  result->key_match_ = key_may_match;
  result->name_ = name;
  return result;
}",33,,485,6,,void
2136,BLOCK,-1,,"{
  delete filter;
}",67,,495,2,,void
2143,BLOCK,-1,,"{
  // Make a leveldb_filterpolicy_t, but override all of its methods so
  // they delegate to a NewBloomFilterPolicy() instead of user
  // supplied C functions.
  struct Wrapper : public leveldb_filterpolicy_t {
    const FilterPolicy* rep_;
    ~Wrapper() { delete rep_; }
    const char* Name() const { return rep_->Name(); }
    void CreateFilter(const Slice* keys, int n, std::string* dst) const {
      return rep_->CreateFilter(keys, n, dst);
    }
    bool KeyMayMatch(const Slice& key, const Slice& filter) const {
      return rep_->KeyMayMatch(key, filter);
    }
    static void DoNothing(void*) { }
  };
  Wrapper* wrapper = new Wrapper;
  wrapper->rep_ = NewBloomFilterPolicy(bits_per_key);
  wrapper->state_ = NULL;
  wrapper->destructor_ = &Wrapper::DoNothing;
  return wrapper;
}",77,,499,2,,void
2173,BLOCK,-1,,"{
  return new leveldb_readoptions_t;
}",53,,522,1,,void
2181,BLOCK,-1,,"{
  delete opt;
}",62,,526,2,,void
2189,BLOCK,-1,,"{
  opt->rep.verify_checksums = v;
}",22,,532,3,,void
2202,BLOCK,-1,,"{
  opt->rep.fill_cache = v;
}",50,,537,3,,void
2215,BLOCK,-1,,"{
  opt->rep.snapshot = (snap ? snap->rep : NULL);
}",37,,543,3,,void
2231,BLOCK,-1,,"{
  return new leveldb_writeoptions_t;
}",55,,547,1,,void
2239,BLOCK,-1,,"{
  delete opt;
}",64,,551,2,,void
2247,BLOCK,-1,,"{
  opt->rep.sync = v;
}",51,,556,3,,void
2259,BLOCK,-1,,"{
  leveldb_cache_t* c = new leveldb_cache_t;
  c->rep = NewLRUCache(capacity);
  return c;
}",60,,560,2,,void
2277,BLOCK,-1,,"{
  delete cache->rep;
  delete cache;
}",52,,566,2,,void
2287,BLOCK,-1,,"{
  leveldb_env_t* result = new leveldb_env_t;
  result->rep = Env::Default();
  result->is_default = true;
  return result;
}",45,,571,1,,void
2312,BLOCK,-1,,"{
  if (!env->is_default) delete env->rep;
  delete env;
}",46,,578,2,,void
2318,BLOCK,-1,,<empty>,25,,579,2,,void
2329,BLOCK,-1,,"{
  free(ptr);
}",30,,583,2,,void
2335,BLOCK,-1,,"{
  return kMajorVersion;
}",29,,587,1,,void
2341,BLOCK,-1,,"{
  return kMinorVersion;
}",29,,591,1,,void
2364,BLOCK,-1,,<empty>,1,,1,1,,ANY
2374,BLOCK,-1,,"{
  fprintf(stderr, ""=== Test %s\n"", name);
  phase = name;
}",42,,17,2,,void
2386,BLOCK,-1,,"{
    const char* ret = getenv(""TEST_TMPDIR"");
    if (ret == NULL || ret[0] == '\0')
        ret = ""/tmp"";
    return ret;
}",37,,22,2,,void
2402,BLOCK,-1,,<empty>,9,,25,2,,void
2414,BLOCK,-1,,"{
  if (expected == NULL && v == NULL) {
    // ok
  } else if (expected != NULL && v != NULL && n == strlen(expected) &&
             memcmp(expected, v, n) == 0) {
    // ok
    return;
  } else {
    fprintf(stderr, ""%s: expected '%s', got '%s'\n"",
            phase,
            (expected ? expected : ""(null)""),
            (v ? v : ""(null""));
    abort();
  }
}",71,,41,4,,void
2423,BLOCK,-1,,"{
    // ok
  }",38,,42,2,,void
2425,BLOCK,-1,,<empty>,10,,44,1,,void
2446,BLOCK,-1,,"{
    // ok
    return;
  }",43,,45,2,,void
2449,BLOCK,-1,,"{
    fprintf(stderr, ""%s: expected '%s', got '%s'\n"",
            phase,
            (expected ? expected : ""(null)""),
            (v ? v : ""(null""));
    abort();
  }",10,,48,1,,void
2467,BLOCK,-1,,"{
  if (*ptr) {
    free(*ptr);
    *ptr = NULL;
  }
}",30,,57,2,,void
2471,BLOCK,-1,,"{
    free(*ptr);
    *ptr = NULL;
  }",13,,58,2,,void
2486,BLOCK,-1,,"{
  char* err = NULL;
  size_t val_len;
  char* val;
  val = leveldb_get(db, options, key, strlen(key), &val_len, &err);
  CheckNoError(err);
  CheckEqual(expected, val, val_len);
  Free(&val);
}",27,,68,5,,void
2507,BLOCK,1,,<empty>,,,,5,,void
2512,BLOCK,-1,,CheckNoError(err),3,,73,2,,void
2534,BLOCK,-1,,"{
  size_t len;
  const char* str;
  str = leveldb_iter_key(iter, &len);
  CheckEqual(key, str, len);
  str = leveldb_iter_value(iter, &len);
  CheckEqual(val, str, len);
}",57,,79,4,,void
2565,BLOCK,-1,,"{
  int* state = (int*) ptr;
  CheckCondition(*state < 2);
  switch (*state) {
    case 0:
      CheckEqual(""bar"", k, klen);
      CheckEqual(""b"", v, vlen);
      break;
    case 1:
      CheckEqual(""box"", k, klen);
      CheckEqual(""c"", v, vlen);
      break;
  }
  (*state)++;
}",50,,91,6,,void
2573,BLOCK,1,,<empty>,,,,3,,void
2580,BLOCK,-1,,CheckCondition(*state < 2),3,,93,2,,void
2592,BLOCK,-1,,"{
    case 0:
      CheckEqual(""bar"", k, klen);
      CheckEqual(""b"", v, vlen);
      break;
    case 1:
      CheckEqual(""box"", k, klen);
      CheckEqual(""c"", v, vlen);
      break;
  }",19,,94,2,,void
2624,BLOCK,-1,,"{
  int* state = (int*) ptr;
  CheckCondition(*state == 2);
  CheckEqual(""bar"", k, klen);
  (*state)++;
}",61,,108,4,,void
2632,BLOCK,1,,<empty>,,,,3,,void
2639,BLOCK,-1,,CheckCondition(*state == 2),3,,110,2,,void
2659,BLOCK,-1,,{ },35,,115,2,,void
2668,BLOCK,-1,,"{
  int n = (alen < blen) ? alen : blen;
  int r = memcmp(a, b, n);
  if (r == 0) {
    if (alen < blen) r = -1;
    else if (alen > blen) r = +1;
  }
  return r;
}",51,,118,6,,void
2689,BLOCK,-1,,"{
    if (alen < blen) r = -1;
    else if (alen > blen) r = +1;
  }",15,,121,2,,void
2694,BLOCK,-1,,<empty>,22,,122,2,,void
2700,BLOCK,-1,,<empty>,10,,123,1,,void
2705,BLOCK,-1,,<empty>,27,,123,2,,void
2716,BLOCK,-1,,"{
  return ""foo"";
}",39,,128,2,,void
2727,BLOCK,-1,,{ },38,,134,2,,void
2732,BLOCK,-1,,"{
  return ""TestFilter"";
}",42,,135,2,,void
2743,BLOCK,-1,,"{
  *filter_length = 4;
  char* result = malloc(4);
  memcpy(result, ""fake"", 4);
  return result;
}",28,,142,6,,void
2767,BLOCK,-1,,"{
  CheckCondition(filter_length == 4);
  CheckCondition(memcmp(filter, ""fake"", 4) == 0);
  return fake_filter_result;
}",47,,151,6,,void
2769,BLOCK,1,,<empty>,,,,2,,void
2775,BLOCK,-1,,CheckCondition(filter_length == 4),3,,152,2,,void
2785,BLOCK,1,,<empty>,,,,2,,void
2794,BLOCK,-1,,"CheckCondition(memcmp(filter, ""fake"", 4) == 0)",3,,153,2,,void
2810,BLOCK,-1,,"{
  leveldb_t* db;
  leveldb_comparator_t* cmp;
  leveldb_cache_t* cache;
  leveldb_env_t* env;
  leveldb_options_t* options;
  leveldb_readoptions_t* roptions;
  leveldb_writeoptions_t* woptions;
  char* err = NULL;
  int run = -1;

  CheckCondition(leveldb_major_version() >= 1);
  CheckCondition(leveldb_minor_version() >= 1);

  snprintf(dbname, sizeof(dbname),
           ""%s/leveldb_c_test-%d"",
           GetTempDir(),
           ((int) geteuid()));

  StartPhase(""create_objects"");
  cmp = leveldb_comparator_create(NULL, CmpDestroy, CmpCompare, CmpName);
  env = leveldb_create_default_env();
  cache = leveldb_cache_create_lru(100000);

  options = leveldb_options_create();
  leveldb_options_set_comparator(options, cmp);
  leveldb_options_set_error_if_exists(options, 1);
  leveldb_options_set_cache(options, cache);
  leveldb_options_set_env(options, env);
  leveldb_options_set_info_log(options, NULL);
  leveldb_options_set_write_buffer_size(options, 100000);
  leveldb_options_set_...",33,,157,3,,void
2828,BLOCK,1,,<empty>,,,,2,,void
2834,BLOCK,-1,,CheckCondition(leveldb_major_version() >= 1),3,,168,2,,void
2844,BLOCK,1,,<empty>,,,,2,,void
2850,BLOCK,-1,,CheckCondition(leveldb_minor_version() >= 1),3,,169,2,,void
2955,BLOCK,1,,<empty>,,,,3,,void
2961,BLOCK,-1,,CheckCondition(err != NULL),3,,207,2,,void
2983,BLOCK,1,,<empty>,,,,3,,void
2989,BLOCK,-1,,CheckCondition(err != NULL),3,,212,2,,void
3017,BLOCK,1,,<empty>,,,,5,,void
3022,BLOCK,-1,,CheckNoError(err),3,,219,2,,void
3049,BLOCK,1,,<empty>,,,,5,,void
3054,BLOCK,-1,,CheckNoError(err),3,,224,2,,void
3096,BLOCK,64,,"{
    leveldb_writebatch_t* wb = leveldb_writebatch_create();
    leveldb_writebatch_put(wb, ""foo"", 3, ""a"", 1);
    leveldb_writebatch_clear(wb);
    leveldb_writebatch_put(wb, ""bar"", 3, ""b"", 1);
    leveldb_writebatch_put(wb, ""box"", 3, ""c"", 1);
    leveldb_writebatch_delete(wb, ""bar"", 3);
    leveldb_write(db, woptions, wb, &err);
    CheckNoError(err);
    CheckGet(db, roptions, ""foo"", ""hello"");
    CheckGet(db, roptions, ""bar"", NULL);
    CheckGet(db, roptions, ""box"", ""c"");
    int pos = 0;
    leveldb_writebatch_iterate(wb, &pos, CheckPut, CheckDel);
    CheckCondition(pos == 3);
    leveldb_writebatch_destroy(wb);
  }",3,,236,64,,void
3133,BLOCK,1,,<empty>,,,,5,,void
3138,BLOCK,-1,,CheckNoError(err),5,,244,2,,void
3173,BLOCK,1,,<empty>,,,,3,,void
3179,BLOCK,-1,,CheckCondition(pos == 3),5,,250,2,,void
3192,BLOCK,66,,"{
    leveldb_iterator_t* iter = leveldb_create_iterator(db, roptions);
    CheckCondition(!leveldb_iter_valid(iter));
    leveldb_iter_seek_to_first(iter);
    CheckCondition(leveldb_iter_valid(iter));
    CheckIter(iter, ""box"", ""c"");
    leveldb_iter_next(iter);
    CheckIter(iter, ""foo"", ""hello"");
    leveldb_iter_prev(iter);
    CheckIter(iter, ""box"", ""c"");
    leveldb_iter_prev(iter);
    CheckCondition(!leveldb_iter_valid(iter));
    leveldb_iter_seek_to_last(iter);
    CheckIter(iter, ""foo"", ""hello"");
    leveldb_iter_seek(iter, ""b"", 1);
    CheckIter(iter, ""box"", ""c"");
    leveldb_iter_get_error(iter, &err);
    CheckNoError(err);
    leveldb_iter_destroy(iter);
  }",3,,255,66,,void
3203,BLOCK,1,,<empty>,,,,4,,void
3209,BLOCK,-1,,CheckCondition(!leveldb_iter_valid(iter)),5,,257,2,,void
3223,BLOCK,1,,<empty>,,,,4,,void
3228,BLOCK,-1,,CheckCondition(leveldb_iter_valid(iter)),5,,259,2,,void
3259,BLOCK,1,,<empty>,,,,4,,void
3265,BLOCK,-1,,CheckCondition(!leveldb_iter_valid(iter)),5,,266,2,,void
3294,BLOCK,1,,<empty>,,,,5,,void
3299,BLOCK,-1,,CheckNoError(err),5,,272,2,,void
3312,BLOCK,68,,"{
    int i;
    int n = 20000;
    char keybuf[100];
    char valbuf[100];
    uint64_t sizes[2];
    const char* start[2] = { ""a"", ""k00000000000000010000"" };
    size_t start_len[2] = { 1, 21 };
    const char* limit[2] = { ""k00000000000000010000"", ""z"" };
    size_t limit_len[2] = { 21, 1 };
    leveldb_writeoptions_set_sync(woptions, 0);
    for (i = 0; i < n; i++) {
      snprintf(keybuf, sizeof(keybuf), ""k%020d"", i);
      snprintf(valbuf, sizeof(valbuf), ""v%020d"", i);
      leveldb_put(db, woptions, keybuf, strlen(keybuf), valbuf, strlen(valbuf),
                  &err);
      CheckNoError(err);
    }
    leveldb_approximate_sizes(db, 2, start, start_len, limit, limit_len, sizes);
    CheckCondition(sizes[0] > 0);
    CheckCondition(sizes[1] > 0);
  }",3,,277,68,,void
3349,BLOCK,-1,,<empty>,5,,288,1,,void
3358,BLOCK,4,,"{
      snprintf(keybuf, sizeof(keybuf), ""k%020d"", i);
      snprintf(valbuf, sizeof(valbuf), ""v%020d"", i);
      leveldb_put(db, woptions, keybuf, strlen(keybuf), valbuf, strlen(valbuf),
                  &err);
      CheckNoError(err);
    }",29,,288,4,,void
3384,BLOCK,1,,<empty>,,,,5,,void
3389,BLOCK,-1,,CheckNoError(err),7,,293,2,,void
3407,BLOCK,1,,<empty>,,,,3,,void
3415,BLOCK,-1,,CheckCondition(sizes[0] > 0),5,,296,2,,void
3425,BLOCK,1,,<empty>,,,,3,,void
3433,BLOCK,-1,,CheckCondition(sizes[1] > 0),5,,297,2,,void
3444,BLOCK,70,,"{
    char* prop = leveldb_property_value(db, ""nosuchprop"");
    CheckCondition(prop == NULL);
    prop = leveldb_property_value(db, ""leveldb.stats"");
    CheckCondition(prop != NULL);
    Free(&prop);
  }",3,,301,70,,void
3452,BLOCK,1,,<empty>,,,,3,,void
3458,BLOCK,-1,,CheckCondition(prop == NULL),5,,303,2,,void
3473,BLOCK,1,,<empty>,,,,3,,void
3479,BLOCK,-1,,CheckCondition(prop != NULL),5,,305,2,,void
3493,BLOCK,72,,"{
    const leveldb_snapshot_t* snap;
    snap = leveldb_create_snapshot(db);
    leveldb_delete(db, woptions, ""foo"", 3, &err);
    CheckNoError(err);
    leveldb_readoptions_set_snapshot(roptions, snap);
    CheckGet(db, roptions, ""foo"", ""hello"");
    leveldb_readoptions_set_snapshot(roptions, NULL);
    CheckGet(db, roptions, ""foo"", NULL);
    leveldb_release_snapshot(db, snap);
  }",3,,310,72,,void
3508,BLOCK,1,,<empty>,,,,5,,void
3513,BLOCK,-1,,CheckNoError(err),5,,314,2,,void
3543,BLOCK,74,,"{
    leveldb_close(db);
    leveldb_options_set_create_if_missing(options, 0);
    leveldb_options_set_error_if_exists(options, 0);
    leveldb_repair_db(options, dbname, &err);
    CheckNoError(err);
    db = leveldb_open(options, dbname, &err);
    CheckNoError(err);
    CheckGet(db, roptions, ""foo"", NULL);
    CheckGet(db, roptions, ""bar"", NULL);
    CheckGet(db, roptions, ""box"", ""c"");
    leveldb_options_set_create_if_missing(options, 1);
    leveldb_options_set_error_if_exists(options, 1);
  }",3,,323,74,,void
3559,BLOCK,1,,<empty>,,,,5,,void
3564,BLOCK,-1,,CheckNoError(err),5,,328,2,,void
3582,BLOCK,1,,<empty>,,,,5,,void
3587,BLOCK,-1,,CheckNoError(err),5,,330,2,,void
3620,BLOCK,-1,,<empty>,3,,339,1,,void
3629,BLOCK,4,,"{
    // First run uses custom filter, second run uses bloom filter
    CheckNoError(err);
    leveldb_filterpolicy_t* policy;
    if (run == 0) {
      policy = leveldb_filterpolicy_create(
          NULL, FilterDestroy, FilterCreate, FilterKeyMatch, FilterName);
    } else {
      policy = leveldb_filterpolicy_create_bloom(10);
    }

    // Create new database
    leveldb_close(db);
    leveldb_destroy_db(options, dbname, &err);
    leveldb_options_set_filter_policy(options, policy);
    db = leveldb_open(options, dbname, &err);
    CheckNoError(err);
    leveldb_put(db, woptions, ""foo"", 3, ""foovalue"", 8, &err);
    CheckNoError(err);
    leveldb_put(db, woptions, ""bar"", 3, ""barvalue"", 8, &err);
    CheckNoError(err);
    leveldb_compact_range(db, NULL, 0, NULL, 0);

    fake_filter_result = 1;
    CheckGet(db, roptions, ""foo"", ""foovalue"");
    CheckGet(db, roptions, ""bar"", ""barvalue"");
    if (phase == 0) {
      // Must not find value when custom filter returns false
      fake...",33,,339,4,,void
3632,BLOCK,1,,<empty>,,,,5,,void
3637,BLOCK,-1,,CheckNoError(err),5,,341,2,,void
3651,BLOCK,-1,,"{
      policy = leveldb_filterpolicy_create(
          NULL, FilterDestroy, FilterCreate, FilterKeyMatch, FilterName);
    }",19,,343,2,,void
3661,BLOCK,-1,,"{
      policy = leveldb_filterpolicy_create_bloom(10);
    }",12,,346,1,,void
3685,BLOCK,1,,<empty>,,,,5,,void
3690,BLOCK,-1,,CheckNoError(err),5,,355,2,,void
3710,BLOCK,1,,<empty>,,,,5,,void
3715,BLOCK,-1,,CheckNoError(err),5,,357,2,,void
3735,BLOCK,1,,<empty>,,,,5,,void
3740,BLOCK,-1,,CheckNoError(err),5,,359,2,,void
3772,BLOCK,-1,,"{
      // Must not find value when custom filter returns false
      fake_filter_result = 0;
      CheckGet(db, roptions, ""foo"", NULL);
      CheckGet(db, roptions, ""bar"", NULL);
      fake_filter_result = 1;

      CheckGet(db, roptions, ""foo"", ""foovalue"");
      CheckGet(db, roptions, ""bar"", ""barvalue"");
    }",21,,365,2,,void
3863,BLOCK,-1,,<empty>,1,,1,1,,ANY
3876,BLOCK,-1,,"{
    tiny_cache_ = NewLRUCache(100);
    options_.env = &env_;
    options_.block_cache = tiny_cache_;
    dbname_ = test::TmpDir() + ""/corruption_test"";
    DestroyDB(dbname_, options_);

    db_ = NULL;
    options_.create_if_missing = true;
    Reopen();
    options_.create_if_missing = false;
  }",20,,35,1,,void
3920,BLOCK,-1,,"{
     delete db_;
     DestroyDB(dbname_, Options());
     delete tiny_cache_;
  }",21,,48,1,,void
3931,BLOCK,-1,,"{
    delete db_;
    db_ = NULL;
    return DB::Open(options_, dbname_, &db_);
  }",22,,54,1,,void
3949,BLOCK,-1,,"{
    ASSERT_OK(TryReopen());
  }",17,,60,1,,void
3952,BLOCK,1,,<empty>,,,,2,,void
3968,BLOCK,-1,,"{
    delete db_;
    db_ = NULL;
    ASSERT_OK(::leveldb::RepairDB(dbname_, options_));
  }",19,,64,1,,void
3975,BLOCK,1,,<empty>,,,,1,,void
3997,BLOCK,-1,,"{
    std::string key_space, value_space;
    WriteBatch batch;
    for (int i = 0; i < n; i++) {
      //if ((i % 100) == 0) fprintf(stderr, ""@ %d of %d\n"", i, n);
      Slice key = Key(i, &key_space);
      batch.Clear();
      batch.Put(key, Value(i, &value_space));
      WriteOptions options;
      // Corrupt() doesn't work without this sync on windows; stat reports 0 for
      // the file size.
      if (i == n - 1) {
        options.sync = true;
      }
      ASSERT_OK(db_->Write(options, &batch));
    }
  }",21,,70,2,,void
4002,BLOCK,-1,,<empty>,5,,73,1,,void
4012,BLOCK,4,,"{
      //if ((i % 100) == 0) fprintf(stderr, ""@ %d of %d\n"", i, n);
      Slice key = Key(i, &key_space);
      batch.Clear();
      batch.Put(key, Value(i, &value_space));
      WriteOptions options;
      // Corrupt() doesn't work without this sync on windows; stat reports 0 for
      // the file size.
      if (i == n - 1) {
        options.sync = true;
      }
      ASSERT_OK(db_->Write(options, &batch));
    }",33,,73,4,,void
4040,BLOCK,-1,,"{
        options.sync = true;
      }",23,,81,2,,void
4047,BLOCK,1,,<empty>,,,,3,,void
4071,BLOCK,-1,,"{
    int next_expected = 0;
    int missed = 0;
    int bad_keys = 0;
    int bad_values = 0;
    int correct = 0;
    std::string value_space;
    Iterator* iter = db_->NewIterator(ReadOptions());
    for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {
      uint64_t key;
      Slice in(iter->key());
      if (in == """" || in == ""~"") {
        // Ignore boundary keys.
        continue;
      }
      if (!ConsumeDecimalNumber(&in, &key) ||
          !in.empty() ||
          key < next_expected) {
        bad_keys++;
        continue;
      }
      missed += (key - next_expected);
      next_expected = key + 1;
      if (iter->value() != Value(key, &value_space)) {
        bad_values++;
      } else {
        correct++;
      }
    }
    delete iter;

    fprintf(stderr,
            ""expected=%d..%d; got=%d; bad_keys=%d; bad_values=%d; missed=%d\n"",
            min_expected, max_expected, correct, bad_keys, bad_values, missed);
    ASSERT_LE(min_expected, correct);
    ASSERT_GE...",50,,88,3,,void
4102,BLOCK,-1,,<empty>,5,,96,1,,void
4115,BLOCK,4,,"{
      uint64_t key;
      Slice in(iter->key());
      if (in == """" || in == ""~"") {
        // Ignore boundary keys.
        continue;
      }
      if (!ConsumeDecimalNumber(&in, &key) ||
          !in.empty() ||
          key < next_expected) {
        bad_keys++;
        continue;
      }
      missed += (key - next_expected);
      next_expected = key + 1;
      if (iter->value() != Value(key, &value_space)) {
        bad_values++;
      } else {
        correct++;
      }
    }",60,,96,4,,void
4131,BLOCK,-1,,"{
        // Ignore boundary keys.
        continue;
      }",34,,99,2,,void
4150,BLOCK,-1,,"{
        bad_keys++;
        continue;
      }",32,,105,2,,void
4174,BLOCK,-1,,"{
        bad_values++;
      }",54,,111,2,,void
4178,BLOCK,-1,,"{
        correct++;
      }",14,,113,1,,void
4195,BLOCK,1,,<empty>,,,,4,,void
4212,BLOCK,1,,<empty>,,,,4,,void
4232,BLOCK,-1,,"{
    // Pick file to corrupt
    std::vector<std::string> filenames;
    ASSERT_OK(env_.GetChildren(dbname_, &filenames));
    uint64_t number;
    FileType type;
    std::string fname;
    int picked_number = -1;
    for (size_t i = 0; i < filenames.size(); i++) {
      if (ParseFileName(filenames[i], &number, &type) &&
          type == filetype &&
          int(number) > picked_number) {  // Pick latest file
        fname = dbname_ + ""/"" + filenames[i];
        picked_number = number;
      }
    }
    ASSERT_TRUE(!fname.empty()) << filetype;

    struct stat sbuf;
    if (stat(fname.c_str(), &sbuf) != 0) {
      const char* msg = strerror(errno);
      ASSERT_TRUE(false) << fname << "": "" << msg;
    }

    if (offset < 0) {
      // Relative to end of file; make it absolute
      if (-offset > sbuf.st_size) {
        offset = 0;
      } else {
        offset = sbuf.st_size + offset;
      }
    }
    if (offset > sbuf.st_size) {
      offset = sbuf.st_size;
    }
    if (offset...",69,,126,4,,void
4243,BLOCK,1,,<empty>,,,,1,,void
4271,BLOCK,-1,,<empty>,5,,134,1,,void
4284,BLOCK,4,,"{
      if (ParseFileName(filenames[i], &number, &type) &&
          type == filetype &&
          int(number) > picked_number) {  // Pick latest file
        fname = dbname_ + ""/"" + filenames[i];
        picked_number = number;
      }
    }",51,,134,4,,void
4304,BLOCK,-1,,"{  // Pick latest file
        fname = dbname_ + ""/"" + filenames[i];
        picked_number = number;
      }",40,,137,2,,void
4324,BLOCK,1,,<empty>,,,,3,,void
4354,BLOCK,-1,,"{
      const char* msg = strerror(errno);
      ASSERT_TRUE(false) << fname << "": "" << msg;
    }",42,,145,2,,void
4365,BLOCK,1,,<empty>,,,,2,,void
4386,BLOCK,-1,,"{
      // Relative to end of file; make it absolute
      if (-offset > sbuf.st_size) {
        offset = 0;
      } else {
        offset = sbuf.st_size + offset;
      }
    }",21,,150,2,,void
4394,BLOCK,-1,,"{
        offset = 0;
      }",35,,152,2,,void
4399,BLOCK,-1,,"{
        offset = sbuf.st_size + offset;
      }",14,,154,1,,void
4413,BLOCK,-1,,"{
      offset = sbuf.st_size;
    }",32,,158,2,,void
4427,BLOCK,-1,,"{
      bytes_to_corrupt = sbuf.st_size - offset;
    }",51,,161,2,,void
4453,BLOCK,1,,<empty>,,,,3,,void
4475,BLOCK,-1,,<empty>,5,,169,1,,void
4485,BLOCK,4,,"{
      contents[i + offset] ^= 0x80;
    }",48,,169,4,,void
4508,BLOCK,1,,<empty>,,,,3,,void
4533,BLOCK,-1,,"{
    std::string property;
    int result;
    if (db_->GetProperty(name, &property) &&
        sscanf(property.c_str(), ""%d"", &result) == 1) {
      return result;
    } else {
      return -1;
    }
  }",41,,176,2,,void
4555,BLOCK,-1,,"{
      return result;
    }",55,,180,2,,void
4559,BLOCK,-1,,"{
      return -1;
    }",12,,182,1,,void
4568,BLOCK,-1,,"{
    char buf[100];
    snprintf(buf, sizeof(buf), ""%016d"", i);
    storage->assign(buf, strlen(buf));
    return Slice(*storage);
  }",42,,188,3,,void
4592,BLOCK,-1,,"{
    Random r(k);
    return test::RandomString(&r, kValueSize, storage);
  }",44,,196,3,,void
4609,BLOCK,-1,,<empty>,,,,1,,<empty>
4613,BLOCK,-1,,"TEST(CorruptionTest, Recovery)",1,,202,1,,void
4637,BLOCK,-1,,"{
  Build(100);
  Check(100, 100);
  Corrupt(kLogFile, 19, 1);      // WriteBatch tag for first record
  Corrupt(kLogFile, log::kBlockSize + 1000, 1);  // Somewhere in second block
  Reopen();

  // The 64 records in the first two log blocks are completely lost.
  Check(36, 36);
}",32,,202,1,,void
4663,BLOCK,-1,,<empty>,,,,1,,<empty>
4667,BLOCK,-1,,"TEST(CorruptionTest, RecoverWriteError)",1,,213,1,,void
4691,BLOCK,-1,,"{
  env_.writable_file_error_ = true;
  Status s = TryReopen();
  ASSERT_TRUE(!s.ok());
}",41,,213,1,,void
4707,BLOCK,1,,<empty>,,,,3,,void
4729,BLOCK,-1,,<empty>,,,,1,,<empty>
4733,BLOCK,-1,,"TEST(CorruptionTest, NewFileErrorDuringWrite)",1,,219,1,,void
4757,BLOCK,-1,,"{
  // Do enough writing to force minor compaction
  env_.writable_file_error_ = true;
  const int num = 3 + (Options().write_buffer_size / kValueSize);
  std::string value_storage;
  Status s;
  for (int i = 0; s.ok() && i < num; i++) {
    WriteBatch batch;
    batch.Put(""a"", Value(100, &value_storage));
    s = db_->Write(WriteOptions(), &batch);
  }
  ASSERT_TRUE(!s.ok());
  ASSERT_GE(env_.num_writable_file_errors_, 1);
  env_.writable_file_error_ = false;
  Reopen();
}",47,,219,1,,void
4776,BLOCK,-1,,<empty>,3,,225,1,,void
4791,BLOCK,4,,"{
    WriteBatch batch;
    batch.Put(""a"", Value(100, &value_storage));
    s = db_->Write(WriteOptions(), &batch);
  }",43,,225,4,,void
4817,BLOCK,1,,<empty>,,,,3,,void
4840,BLOCK,1,,<empty>,,,,3,,void
4866,BLOCK,-1,,<empty>,,,,1,,<empty>
4870,BLOCK,-1,,"TEST(CorruptionTest, TableFile)",1,,236,1,,void
4894,BLOCK,-1,,"{
  Build(100);
  DBImpl* dbi = reinterpret_cast<DBImpl*>(db_);
  dbi->TEST_CompactMemTable();
  dbi->TEST_CompactRange(0, NULL, NULL);
  dbi->TEST_CompactRange(1, NULL, NULL);

  Corrupt(kTableFile, 100, 1);
  Check(90, 99);
}",33,,236,1,,void
4932,BLOCK,-1,,<empty>,,,,1,,<empty>
4936,BLOCK,-1,,"TEST(CorruptionTest, TableFileRepair)",1,,247,1,,void
4960,BLOCK,-1,,"{
  options_.block_size = 2 * kValueSize;  // Limit scope of corruption
  options_.paranoid_checks = true;
  Reopen();
  Build(100);
  DBImpl* dbi = reinterpret_cast<DBImpl*>(db_);
  dbi->TEST_CompactMemTable();
  dbi->TEST_CompactRange(0, NULL, NULL);
  dbi->TEST_CompactRange(1, NULL, NULL);

  Corrupt(kTableFile, 100, 1);
  RepairDB();
  Reopen();
  Check(95, 99);
}",39,,247,1,,void
5013,BLOCK,-1,,<empty>,,,,1,,<empty>
5017,BLOCK,-1,,"TEST(CorruptionTest, TableFileIndexData)",1,,263,1,,void
5041,BLOCK,-1,,"{
  Build(10000);  // Enough to build multiple Tables
  DBImpl* dbi = reinterpret_cast<DBImpl*>(db_);
  dbi->TEST_CompactMemTable();

  Corrupt(kTableFile, -2000, 500);
  Reopen();
  Check(5000, 9999);
}",42,,263,1,,void
5067,BLOCK,-1,,<empty>,,,,1,,<empty>
5071,BLOCK,-1,,"TEST(CorruptionTest, MissingDescriptor)",1,,273,1,,void
5095,BLOCK,-1,,"{
  Build(1000);
  RepairDB();
  Reopen();
  Check(1000, 1000);
}",41,,273,1,,void
5107,BLOCK,-1,,<empty>,,,,1,,<empty>
5111,BLOCK,-1,,"TEST(CorruptionTest, SequenceNumberRecovery)",1,,280,1,,void
5135,BLOCK,-1,,"{
  ASSERT_OK(db_->Put(WriteOptions(), ""foo"", ""v1""));
  ASSERT_OK(db_->Put(WriteOptions(), ""foo"", ""v2""));
  ASSERT_OK(db_->Put(WriteOptions(), ""foo"", ""v3""));
  ASSERT_OK(db_->Put(WriteOptions(), ""foo"", ""v4""));
  ASSERT_OK(db_->Put(WriteOptions(), ""foo"", ""v5""));
  RepairDB();
  Reopen();
  std::string v;
  ASSERT_OK(db_->Get(ReadOptions(), ""foo"", &v));
  ASSERT_EQ(""v5"", v);
  // Write something.  If sequence number was not recovered properly,
  // it will be hidden by an earlier write.
  ASSERT_OK(db_->Put(WriteOptions(), ""foo"", ""v6""));
  ASSERT_OK(db_->Get(ReadOptions(), ""foo"", &v));
  ASSERT_EQ(""v6"", v);
  Reopen();
  ASSERT_OK(db_->Get(ReadOptions(), ""foo"", &v));
  ASSERT_EQ(""v6"", v);
}",46,,280,1,,void
5137,BLOCK,1,,<empty>,,,,1,,void
5157,BLOCK,1,,<empty>,,,,1,,void
5177,BLOCK,1,,<empty>,,,,1,,void
5197,BLOCK,1,,<empty>,,,,1,,void
5217,BLOCK,1,,<empty>,,,,1,,void
5240,BLOCK,1,,<empty>,,,,2,,void
5263,BLOCK,1,,<empty>,,,,4,,void
5278,BLOCK,1,,<empty>,,,,1,,void
5298,BLOCK,1,,<empty>,,,,2,,void
5321,BLOCK,1,,<empty>,,,,4,,void
5337,BLOCK,1,,<empty>,,,,2,,void
5360,BLOCK,1,,<empty>,,,,4,,void
5378,BLOCK,-1,,<empty>,,,,1,,<empty>
5382,BLOCK,-1,,"TEST(CorruptionTest, CorruptedDescriptor)",1,,301,1,,void
5406,BLOCK,-1,,"{
  ASSERT_OK(db_->Put(WriteOptions(), ""foo"", ""hello""));
  DBImpl* dbi = reinterpret_cast<DBImpl*>(db_);
  dbi->TEST_CompactMemTable();
  dbi->TEST_CompactRange(0, NULL, NULL);

  Corrupt(kDescriptorFile, 0, 1000);
  Status s = TryReopen();
  ASSERT_TRUE(!s.ok());

  RepairDB();
  Reopen();
  std::string v;
  ASSERT_OK(db_->Get(ReadOptions(), ""foo"", &v));
  ASSERT_EQ(""hello"", v);
}",43,,301,1,,void
5408,BLOCK,1,,<empty>,,,,1,,void
5458,BLOCK,1,,<empty>,,,,3,,void
5480,BLOCK,1,,<empty>,,,,2,,void
5503,BLOCK,1,,<empty>,,,,4,,void
5521,BLOCK,-1,,<empty>,,,,1,,<empty>
5525,BLOCK,-1,,"TEST(CorruptionTest, CompactionInputError)",1,,318,1,,void
5549,BLOCK,-1,,"{
  Build(10);
  DBImpl* dbi = reinterpret_cast<DBImpl*>(db_);
  dbi->TEST_CompactMemTable();
  const int last = config::kMaxMemCompactLevel;
  ASSERT_EQ(1, Property(""leveldb.num-files-at-level"" + NumberToString(last)));

  Corrupt(kTableFile, 100, 1);
  Check(5, 9);

  // Force compactions by writing lots of values
  Build(10000);
  Check(10000, 10000);
}",44,,318,1,,void
5570,BLOCK,1,,<empty>,,,,3,,void
5604,BLOCK,-1,,<empty>,,,,1,,<empty>
5608,BLOCK,-1,,"TEST(CorruptionTest, CompactionInputErrorParanoid)",1,,333,1,,void
5632,BLOCK,-1,,"{
  options_.paranoid_checks = true;
  options_.write_buffer_size = 512 << 10;
  Reopen();
  DBImpl* dbi = reinterpret_cast<DBImpl*>(db_);

  // Make multiple inputs so we need to compact.
  for (int i = 0; i < 2; i++) {
    Build(10);
    dbi->TEST_CompactMemTable();
    Corrupt(kTableFile, 100, 1);
    env_.SleepForMicroseconds(100000);
  }
  dbi->CompactRange(NULL, NULL);

  // Write must fail because of corrupted table
  std::string tmp1, tmp2;
  Status s = db_->Put(WriteOptions(), Key(5, &tmp1), Value(5, &tmp2));
  ASSERT_TRUE(!s.ok()) << ""write did not fail in corrupted paranoid db"";
}",52,,333,1,,void
5653,BLOCK,-1,,<empty>,3,,340,1,,void
5663,BLOCK,4,,"{
    Build(10);
    dbi->TEST_CompactMemTable();
    Corrupt(kTableFile, 100, 1);
    env_.SleepForMicroseconds(100000);
  }",31,,340,4,,void
5710,BLOCK,1,,<empty>,,,,3,,void
5733,BLOCK,-1,,<empty>,,,,1,,<empty>
5737,BLOCK,-1,,"TEST(CorruptionTest, UnrelatedKeys)",1,,354,1,,void
5761,BLOCK,-1,,"{
  Build(10);
  DBImpl* dbi = reinterpret_cast<DBImpl*>(db_);
  dbi->TEST_CompactMemTable();
  Corrupt(kTableFile, 100, 1);

  std::string tmp1, tmp2;
  ASSERT_OK(db_->Put(WriteOptions(), Key(1000, &tmp1), Value(1000, &tmp2)));
  std::string v;
  ASSERT_OK(db_->Get(ReadOptions(), Key(1000, &tmp1), &v));
  ASSERT_EQ(Value(1000, &tmp2).ToString(), v);
  dbi->TEST_CompactMemTable();
  ASSERT_OK(db_->Get(ReadOptions(), Key(1000, &tmp1), &v));
  ASSERT_EQ(Value(1000, &tmp2).ToString(), v);
}",37,,354,1,,void
5781,BLOCK,1,,<empty>,,,,3,,void
5808,BLOCK,1,,<empty>,,,,3,,void
5833,BLOCK,1,,<empty>,,,,4,,void
5858,BLOCK,1,,<empty>,,,,3,,void
5883,BLOCK,1,,<empty>,,,,4,,void
5908,BLOCK,-1,,"{
  return leveldb::test::RunAllTests();
}",33,,372,3,,void
5952,BLOCK,-1,,<empty>,1,,1,1,,ANY
6030,BLOCK,-1,,"{
    // We use a limited amount of data over and over again and ensure
    // that it is larger than the compression window (32KB), and also
    // large enough to serve all typical value sizes we want to write.
    Random rnd(301);
    std::string piece;
    while (data_.size() < 1048576) {
      // Add a short fragment that is as compressible as specified
      // by FLAGS_compression_ratio.
      test::CompressibleString(&rnd, FLAGS_compression_ratio, 100, &piece);
      data_.append(piece);
    }
    pos_ = 0;
  }",21,,129,1,,void
6042,BLOCK,-1,,"{
      // Add a short fragment that is as compressible as specified
      // by FLAGS_compression_ratio.
      test::CompressibleString(&rnd, FLAGS_compression_ratio, 100, &piece);
      data_.append(piece);
    }",36,,135,2,,void
6065,BLOCK,-1,,"{
    if (pos_ + len > data_.size()) {
      pos_ = 0;
      assert(len < data_.size());
    }
    pos_ += len;
    return Slice(data_.data() + pos_ - len, len);
  }",30,,144,2,,void
6075,BLOCK,-1,,"{
      pos_ = 0;
      assert(len < data_.size());
    }",36,,145,2,,void
6105,BLOCK,-1,,"{
  if (msg.empty()) return;
  if (!str->empty()) {
    str->push_back(' ');
  }
  str->append(msg.data(), msg.size());
}",58,,168,3,,void
6111,BLOCK,-1,,<empty>,20,,169,2,,void
6119,BLOCK,-1,,"{
    str->push_back(' ');
  }",22,,170,2,,void
6150,BLOCK,-1,,{ Start(); },11,,189,1,,void
6155,BLOCK,-1,,"{
    next_report_ = 100;
    last_op_finish_ = start_;
    hist_.Clear();
    done_ = 0;
    bytes_ = 0;
    seconds_ = 0;
    start_ = g_env->NowMicros();
    finish_ = start_;
    message_.clear();
  }",16,,191,1,,void
6192,BLOCK,-1,,"{
    hist_.Merge(other.hist_);
    done_ += other.done_;
    bytes_ += other.bytes_;
    seconds_ += other.seconds_;
    if (other.start_ < start_) start_ = other.start_;
    if (other.finish_ > finish_) finish_ = other.finish_;

    // Just keep the messages from one thread
    if (message_.empty()) message_ = other.message_;
  }",34,,203,2,,void
6221,BLOCK,-1,,<empty>,32,,208,2,,void
6233,BLOCK,-1,,<empty>,34,,209,2,,void
6244,BLOCK,-1,,<empty>,27,,212,2,,void
6253,BLOCK,-1,,"{
    finish_ = g_env->NowMicros();
    seconds_ = (finish_ - start_) * 1e-6;
  }",15,,215,1,,void
6271,BLOCK,-1,,"{
    AppendWithSpace(&message_, msg);
  }",30,,220,2,,void
6279,BLOCK,-1,,"{
    if (FLAGS_histogram) {
      double now = g_env->NowMicros();
      double micros = now - last_op_finish_;
      hist_.Add(micros);
      if (micros > 20000) {
        fprintf(stderr, ""long op: %.1f micros%30s\r"", micros, """");
        fflush(stderr);
      }
      last_op_finish_ = now;
    }

    done_++;
    if (done_ >= next_report_) {
      if      (next_report_ < 1000)   next_report_ += 100;
      else if (next_report_ < 5000)   next_report_ += 500;
      else if (next_report_ < 10000)  next_report_ += 1000;
      else if (next_report_ < 50000)  next_report_ += 5000;
      else if (next_report_ < 100000) next_report_ += 10000;
      else if (next_report_ < 500000) next_report_ += 50000;
      else                            next_report_ += 100000;
      fprintf(stderr, ""... finished %d ops%30s\r"", done_, """");
      fflush(stderr);
    }
  }",27,,224,1,,void
6282,BLOCK,-1,,"{
      double now = g_env->NowMicros();
      double micros = now - last_op_finish_;
      hist_.Add(micros);
      if (micros > 20000) {
        fprintf(stderr, ""long op: %.1f micros%30s\r"", micros, """");
        fflush(stderr);
      }
      last_op_finish_ = now;
    }",26,,225,2,,void
6305,BLOCK,-1,,"{
        fprintf(stderr, ""long op: %.1f micros%30s\r"", micros, """");
        fflush(stderr);
      }",27,,229,2,,void
6321,BLOCK,-1,,"{
      if      (next_report_ < 1000)   next_report_ += 100;
      else if (next_report_ < 5000)   next_report_ += 500;
      else if (next_report_ < 10000)  next_report_ += 1000;
      else if (next_report_ < 50000)  next_report_ += 5000;
      else if (next_report_ < 100000) next_report_ += 10000;
      else if (next_report_ < 500000) next_report_ += 50000;
      else                            next_report_ += 100000;
      fprintf(stderr, ""... finished %d ops%30s\r"", done_, """");
      fflush(stderr);
    }",32,,237,2,,void
6326,BLOCK,-1,,<empty>,39,,238,2,,void
6331,BLOCK,-1,,<empty>,12,,239,1,,void
6336,BLOCK,-1,,<empty>,39,,239,2,,void
6341,BLOCK,-1,,<empty>,12,,240,1,,void
6346,BLOCK,-1,,<empty>,39,,240,2,,void
6351,BLOCK,-1,,<empty>,12,,241,1,,void
6356,BLOCK,-1,,<empty>,39,,241,2,,void
6361,BLOCK,-1,,<empty>,12,,242,1,,void
6366,BLOCK,-1,,<empty>,39,,242,2,,void
6371,BLOCK,-1,,<empty>,12,,243,1,,void
6376,BLOCK,-1,,<empty>,39,,243,2,,void
6381,BLOCK,-1,,<empty>,39,,244,1,,void
6395,BLOCK,-1,,"{
    bytes_ += n;
  }",28,,250,2,,void
6403,BLOCK,-1,,"{
    // Pretend at least one op was done in case we are running a benchmark
    // that does not call FinishedSingleOp().
    if (done_ < 1) done_ = 1;

    std::string extra;
    if (bytes_ > 0) {
      // Rate is computed on actual elapsed time, not the sum of per-thread
      // elapsed times.
      double elapsed = (finish_ - start_) * 1e-6;
      char rate[100];
      snprintf(rate, sizeof(rate), ""%6.1f MB/s"",
               (bytes_ / 1048576.0) / elapsed);
      extra = rate;
    }
    AppendWithSpace(&extra, message_);

    fprintf(stdout, ""%-12s : %11.3f micros/op;%s%s\n"",
            name.ToString().c_str(),
            seconds_ * 1e6 / done_,
            (extra.empty() ? """" : "" ""),
            extra.c_str());
    if (FLAGS_histogram) {
      fprintf(stdout, ""Microseconds per op:\n%s\n"", hist_.ToString().c_str());
    }
    fflush(stdout);
  }",34,,254,2,,void
6408,BLOCK,-1,,<empty>,20,,257,2,,void
6417,BLOCK,-1,,"{
      // Rate is computed on actual elapsed time, not the sum of per-thread
      // elapsed times.
      double elapsed = (finish_ - start_) * 1e-6;
      char rate[100];
      snprintf(rate, sizeof(rate), ""%6.1f MB/s"",
               (bytes_ / 1048576.0) / elapsed);
      extra = rate;
    }",21,,260,2,,void
6472,BLOCK,-1,,"{
      fprintf(stdout, ""Microseconds per op:\n%s\n"", hist_.ToString().c_str());
    }",26,,276,2,,void
6494,BLOCK,-1,,{ },27,,299,1,,void
6504,BLOCK,-1,,"{
  }",28,,311,2,,void
6518,BLOCK,-1,,"{
    const int kKeySize = 16;
    PrintEnvironment();
    fprintf(stdout, ""Keys:       %d bytes each\n"", kKeySize);
    fprintf(stdout, ""Values:     %d bytes each (%d bytes after compression)\n"",
            FLAGS_value_size,
            static_cast<int>(FLAGS_value_size * FLAGS_compression_ratio + 0.5));
    fprintf(stdout, ""Entries:    %d\n"", num_);
    fprintf(stdout, ""RawSize:    %.1f MB (estimated)\n"",
            ((static_cast<int64_t>(kKeySize + FLAGS_value_size) * num_)
             / 1048576.0));
    fprintf(stdout, ""FileSize:   %.1f MB (estimated)\n"",
            (((kKeySize + FLAGS_value_size * FLAGS_compression_ratio) * num_)
             / 1048576.0));
    PrintWarnings();
    fprintf(stdout, ""------------------------------------------------\n"");
  }",22,,329,1,,void
6574,BLOCK,-1,,"{
#if defined(__GNUC__) && !defined(__OPTIMIZE__)
    fprintf(stdout,
            ""WARNING: Optimization is disabled: benchmarks unnecessarily slow\n""
            );
#endif
#ifndef NDEBUG
    fprintf(stdout,
            ""WARNING: Assertions are enabled; benchmarks unnecessarily slow\n"");
#endif

    // See if snappy is working by attempting to compress a compressible string
    const char text[] = ""yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy"";
    std::string compressed;
    if (!port::Snappy_Compress(text, sizeof(text), &compressed)) {
      fprintf(stdout, ""WARNING: Snappy compression is not enabled\n"");
    } else if (compressed.size() >= sizeof(text)) {
      fprintf(stdout, ""WARNING: Snappy compression is not effective\n"");
    }
  }",24,,347,1,,void
6594,BLOCK,-1,,"{
      fprintf(stdout, ""WARNING: Snappy compression is not enabled\n"");
    }",66,,361,2,,void
6599,BLOCK,-1,,<empty>,12,,363,1,,void
6608,BLOCK,-1,,"{
      fprintf(stdout, ""WARNING: Snappy compression is not effective\n"");
    }",51,,363,2,,void
6615,BLOCK,-1,,"{
    fprintf(stderr, ""LevelDB:    version %d.%d\n"",
            kMajorVersion, kMinorVersion);

#if defined(__linux)
    time_t now = time(NULL);
    fprintf(stderr, ""Date:       %s"", ctime(&now));  // ctime() adds newline

    FILE* cpuinfo = fopen(""/proc/cpuinfo"", ""r"");
    if (cpuinfo != NULL) {
      char line[1000];
      int num_cpus = 0;
      std::string cpu_type;
      std::string cache_size;
      while (fgets(line, sizeof(line), cpuinfo) != NULL) {
        const char* sep = strchr(line, ':');
        if (sep == NULL) {
          continue;
        }
        Slice key = TrimSpace(Slice(line, sep - 1 - line));
        Slice val = TrimSpace(Slice(sep + 1));
        if (key == ""model name"") {
          ++num_cpus;
          cpu_type = val.ToString();
        } else if (key == ""cache size"") {
          cache_size = val.ToString();
        }
      }
      fclose(cpuinfo);
      fprintf(stderr, ""CPU:        %d * %s\n"", num_cpus, cpu_type.c_str());
      fprintf(stderr, ""CPUCache...",27,,368,1,,void
6624,BLOCK,-1,,"{
    std::vector<std::string> files;
    g_env->GetChildren(FLAGS_db, &files);
    for (size_t i = 0; i < files.size(); i++) {
      if (Slice(files[i]).starts_with(""heap-"")) {
        g_env->DeleteFile(std::string(FLAGS_db) + ""/"" + files[i]);
      }
    }
    if (!FLAGS_use_existing_db) {
      DestroyDB(FLAGS_db, Options());
    }
  }",22,,414,1,,void
6642,BLOCK,-1,,<empty>,5,,417,1,,void
6655,BLOCK,4,,"{
      if (Slice(files[i]).starts_with(""heap-"")) {
        g_env->DeleteFile(std::string(FLAGS_db) + ""/"" + files[i]);
      }
    }",47,,417,4,,void
6665,BLOCK,-1,,"{
        g_env->DeleteFile(std::string(FLAGS_db) + ""/"" + files[i]);
      }",49,,418,2,,void
6684,BLOCK,-1,,"{
      DestroyDB(FLAGS_db, Options());
    }",33,,422,2,,void
6691,BLOCK,-1,,"{
    delete db_;
    delete cache_;
    delete filter_policy_;
  }",16,,427,1,,void
6701,BLOCK,-1,,"{
    PrintHeader();
    Open();

    const char* benchmarks = FLAGS_benchmarks;
    while (benchmarks != NULL) {
      const char* sep = strchr(benchmarks, ',');
      Slice name;
      if (sep == NULL) {
        name = benchmarks;
        benchmarks = NULL;
      } else {
        name = Slice(benchmarks, sep - benchmarks);
        benchmarks = sep + 1;
      }

      // Reset parameters that may be overridden below
      num_ = FLAGS_num;
      reads_ = (FLAGS_reads < 0 ? FLAGS_num : FLAGS_reads);
      value_size_ = FLAGS_value_size;
      entries_per_batch_ = 1;
      write_options_ = WriteOptions();

      void (Benchmark::*method)(ThreadState*) = NULL;
      bool fresh_db = false;
      int num_threads = FLAGS_threads;

      if (name == Slice(""open"")) {
        method = &Benchmark::OpenBench;
        num_ /= 10000;
        if (num_ < 1) num_ = 1;
      } else if (name == Slice(""fillseq"")) {
        fresh_db = true;
        method = &Benchmark::WriteSeq;
      } else if (name ...",14,,433,1,,void
6712,BLOCK,-1,,"{
      const char* sep = strchr(benchmarks, ',');
      Slice name;
      if (sep == NULL) {
        name = benchmarks;
        benchmarks = NULL;
      } else {
        name = Slice(benchmarks, sep - benchmarks);
        benchmarks = sep + 1;
      }

      // Reset parameters that may be overridden below
      num_ = FLAGS_num;
      reads_ = (FLAGS_reads < 0 ? FLAGS_num : FLAGS_reads);
      value_size_ = FLAGS_value_size;
      entries_per_batch_ = 1;
      write_options_ = WriteOptions();

      void (Benchmark::*method)(ThreadState*) = NULL;
      bool fresh_db = false;
      int num_threads = FLAGS_threads;

      if (name == Slice(""open"")) {
        method = &Benchmark::OpenBench;
        num_ /= 10000;
        if (num_ < 1) num_ = 1;
      } else if (name == Slice(""fillseq"")) {
        fresh_db = true;
        method = &Benchmark::WriteSeq;
      } else if (name == Slice(""fillbatch"")) {
        fresh_db = true;
        entries_per_batch_ = 1000;
        method = &Benchmark...",32,,438,2,,void
6724,BLOCK,-1,,"{
        name = benchmarks;
        benchmarks = NULL;
      }",24,,441,2,,void
6732,BLOCK,-1,,"{
        name = Slice(benchmarks, sep - benchmarks);
        benchmarks = sep + 1;
      }",14,,444,1,,void
6767,BLOCK,-1,,<empty>,,,,2,,<empty>
6783,BLOCK,-1,,"{
        method = &Benchmark::OpenBench;
        num_ /= 10000;
        if (num_ < 1) num_ = 1;
      }",34,,460,2,,void
6797,BLOCK,-1,,<empty>,23,,463,2,,void
6802,BLOCK,-1,,<empty>,14,,464,1,,void
6808,BLOCK,-1,,"{
        fresh_db = true;
        method = &Benchmark::WriteSeq;
      }",44,,464,2,,void
6819,BLOCK,-1,,<empty>,14,,467,1,,void
6825,BLOCK,-1,,"{
        fresh_db = true;
        entries_per_batch_ = 1000;
        method = &Benchmark::WriteSeq;
      }",46,,467,2,,void
6839,BLOCK,-1,,<empty>,14,,471,1,,void
6845,BLOCK,-1,,"{
        fresh_db = true;
        method = &Benchmark::WriteRandom;
      }",47,,471,2,,void
6856,BLOCK,-1,,<empty>,14,,474,1,,void
6862,BLOCK,-1,,"{
        fresh_db = false;
        method = &Benchmark::WriteRandom;
      }",46,,474,2,,void
6873,BLOCK,-1,,<empty>,14,,477,1,,void
6879,BLOCK,-1,,"{
        fresh_db = true;
        num_ /= 1000;
        write_options_.sync = true;
        method = &Benchmark::WriteRandom;
      }",45,,477,2,,void
6898,BLOCK,-1,,<empty>,14,,482,1,,void
6904,BLOCK,-1,,"{
        fresh_db = true;
        num_ /= 1000;
        value_size_ = 100 * 1000;
        method = &Benchmark::WriteRandom;
      }",45,,482,2,,void
6923,BLOCK,-1,,<empty>,14,,487,1,,void
6929,BLOCK,-1,,"{
        method = &Benchmark::ReadSequential;
      }",44,,487,2,,void
6937,BLOCK,-1,,<empty>,14,,489,1,,void
6943,BLOCK,-1,,"{
        method = &Benchmark::ReadReverse;
      }",48,,489,2,,void
6951,BLOCK,-1,,<empty>,14,,491,1,,void
6957,BLOCK,-1,,"{
        method = &Benchmark::ReadRandom;
      }",47,,491,2,,void
6965,BLOCK,-1,,<empty>,14,,493,1,,void
6971,BLOCK,-1,,"{
        method = &Benchmark::ReadMissing;
      }",48,,493,2,,void
6979,BLOCK,-1,,<empty>,14,,495,1,,void
6985,BLOCK,-1,,"{
        method = &Benchmark::SeekRandom;
      }",47,,495,2,,void
6993,BLOCK,-1,,<empty>,14,,497,1,,void
6999,BLOCK,-1,,"{
        method = &Benchmark::ReadHot;
      }",44,,497,2,,void
7007,BLOCK,-1,,<empty>,14,,499,1,,void
7013,BLOCK,-1,,"{
        reads_ /= 1000;
        method = &Benchmark::ReadRandom;
      }",52,,499,2,,void
7024,BLOCK,-1,,<empty>,14,,502,1,,void
7030,BLOCK,-1,,"{
        method = &Benchmark::DeleteSeq;
      }",46,,502,2,,void
7038,BLOCK,-1,,<empty>,14,,504,1,,void
7044,BLOCK,-1,,"{
        method = &Benchmark::DeleteRandom;
      }",49,,504,2,,void
7052,BLOCK,-1,,<empty>,14,,506,1,,void
7058,BLOCK,-1,,"{
        num_threads++;  // Add extra thread for writing
        method = &Benchmark::ReadWhileWriting;
      }",53,,506,2,,void
7068,BLOCK,-1,,<empty>,14,,509,1,,void
7074,BLOCK,-1,,"{
        method = &Benchmark::Compact;
      }",44,,509,2,,void
7082,BLOCK,-1,,<empty>,14,,511,1,,void
7088,BLOCK,-1,,"{
        method = &Benchmark::Crc32c;
      }",43,,511,2,,void
7096,BLOCK,-1,,<empty>,14,,513,1,,void
7102,BLOCK,-1,,"{
        method = &Benchmark::AcquireLoad;
      }",48,,513,2,,void
7110,BLOCK,-1,,<empty>,14,,515,1,,void
7116,BLOCK,-1,,"{
        method = &Benchmark::SnappyCompress;
      }",47,,515,2,,void
7124,BLOCK,-1,,<empty>,14,,517,1,,void
7130,BLOCK,-1,,"{
        method = &Benchmark::SnappyUncompress;
      }",49,,517,2,,void
7138,BLOCK,-1,,<empty>,14,,519,1,,void
7144,BLOCK,-1,,"{
        HeapProfile();
      }",48,,519,2,,void
7147,BLOCK,-1,,<empty>,14,,521,1,,void
7153,BLOCK,-1,,"{
        PrintStats(""leveldb.stats"");
      }",42,,521,2,,void
7157,BLOCK,-1,,<empty>,14,,523,1,,void
7163,BLOCK,-1,,"{
        PrintStats(""leveldb.sstables"");
      }",45,,523,2,,void
7167,BLOCK,-1,,"{
        if (name != Slice()) {  // No error message for empty name
          fprintf(stderr, ""unknown benchmark '%s'\n"", name.ToString().c_str());
        }
      }",14,,525,1,,void
7172,BLOCK,-1,,"{  // No error message for empty name
          fprintf(stderr, ""unknown benchmark '%s'\n"", name.ToString().c_str());
        }",30,,526,2,,void
7185,BLOCK,-1,,"{
        if (FLAGS_use_existing_db) {
          fprintf(stdout, ""%-12s : skipped (--use_existing_db is true)\n"",
                  name.ToString().c_str());
          method = NULL;
        } else {
          delete db_;
          db_ = NULL;
          DestroyDB(FLAGS_db, Options());
          Open();
        }
      }",21,,531,2,,void
7188,BLOCK,-1,,"{
          fprintf(stdout, ""%-12s : skipped (--use_existing_db is true)\n"",
                  name.ToString().c_str());
          method = NULL;
        }",36,,532,2,,void
7203,BLOCK,-1,,"{
          delete db_;
          db_ = NULL;
          DestroyDB(FLAGS_db, Options());
          Open();
        }",16,,536,1,,void
7217,BLOCK,-1,,"{
        RunBenchmark(num_threads, name, method);
      }",27,,544,2,,void
7230,BLOCK,-1,,<empty>,,,,2,,<empty>
7235,BLOCK,-1,,"{
    ThreadArg* arg = reinterpret_cast<ThreadArg*>(v);
    SharedState* shared = arg->shared;
    ThreadState* thread = arg->thread;
    {
      MutexLock l(&shared->mu);
      shared->num_initialized++;
      if (shared->num_initialized >= shared->total) {
        shared->cv.SignalAll();
      }
      while (!shared->start) {
        shared->cv.Wait();
      }
    }

    thread->stats.Start();
    (arg->bm->*(arg->method))(thread);
    thread->stats.Stop();

    {
      MutexLock l(&shared->mu);
      shared->num_done++;
      if (shared->num_done >= shared->total) {
        shared->cv.SignalAll();
      }
    }
  }",35,,558,2,,void
7254,BLOCK,7,,"{
      MutexLock l(&shared->mu);
      shared->num_initialized++;
      if (shared->num_initialized >= shared->total) {
        shared->cv.SignalAll();
      }
      while (!shared->start) {
        shared->cv.Wait();
      }
    }",5,,562,7,,void
7273,BLOCK,-1,,"{
        shared->cv.SignalAll();
      }",53,,565,2,,void
7285,BLOCK,-1,,"{
        shared->cv.Wait();
      }",30,,568,2,,void
7313,BLOCK,11,,"{
      MutexLock l(&shared->mu);
      shared->num_done++;
      if (shared->num_done >= shared->total) {
        shared->cv.SignalAll();
      }
    }",5,,577,11,,void
7332,BLOCK,-1,,"{
        shared->cv.SignalAll();
      }",46,,580,2,,void
7345,BLOCK,-1,,"{
    SharedState shared;
    shared.total = n;
    shared.num_initialized = 0;
    shared.num_done = 0;
    shared.start = false;

    ThreadArg* arg = new ThreadArg[n];
    for (int i = 0; i < n; i++) {
      arg[i].bm = this;
      arg[i].method = method;
      arg[i].shared = &shared;
      arg[i].thread = new ThreadState(i);
      arg[i].thread->shared = &shared;
      g_env->StartThread(ThreadBody, &arg[i]);
    }

    shared.mu.Lock();
    while (shared.num_initialized < n) {
      shared.cv.Wait();
    }

    shared.start = true;
    shared.cv.SignalAll();
    while (shared.num_done < n) {
      shared.cv.Wait();
    }
    shared.mu.Unlock();

    for (int i = 1; i < n; i++) {
      arg[0].thread->stats.Merge(arg[i].thread->stats);
    }
    arg[0].thread->stats.Report(name);

    for (int i = 0; i < n; i++) {
      delete arg[i].thread;
    }
    delete[] arg;
  }",62,,587,4,,void
7373,BLOCK,-1,,<empty>,5,,595,1,,void
7383,BLOCK,4,,"{
      arg[i].bm = this;
      arg[i].method = method;
      arg[i].shared = &shared;
      arg[i].thread = new ThreadState(i);
      arg[i].thread->shared = &shared;
      g_env->StartThread(ThreadBody, &arg[i]);
    }",33,,595,4,,void
7446,BLOCK,-1,,"{
      shared.cv.Wait();
    }",40,,605,2,,void
7470,BLOCK,-1,,"{
      shared.cv.Wait();
    }",33,,611,2,,void
7484,BLOCK,-1,,<empty>,5,,616,1,,void
7494,BLOCK,4,,"{
      arg[0].thread->stats.Merge(arg[i].thread->stats);
    }",33,,616,4,,void
7524,BLOCK,-1,,<empty>,5,,621,1,,void
7534,BLOCK,4,,"{
      delete arg[i].thread;
    }",33,,621,4,,void
7547,BLOCK,-1,,"{
    // Checksum about 500MB of data total
    const int size = 4096;
    const char* label = ""(4K per op)"";
    std::string data(size, 'x');
    int64_t bytes = 0;
    uint32_t crc = 0;
    while (bytes < 500 * 1048576) {
      crc = crc32c::Value(data.data(), size);
      thread->stats.FinishedSingleOp();
      bytes += size;
    }
    // Print so result is not dead
    fprintf(stderr, ""... crc=0x%x\r"", static_cast<unsigned int>(crc));

    thread->stats.AddBytes(bytes);
    thread->stats.AddMessage(label);
  }",36,,627,2,,void
7574,BLOCK,-1,,"{
      crc = crc32c::Value(data.data(), size);
      thread->stats.FinishedSingleOp();
      bytes += size;
    }",35,,634,2,,void
7619,BLOCK,-1,,"{
    int dummy;
    port::AtomicPointer ap(&dummy);
    int count = 0;
    void *ptr = NULL;
    thread->stats.AddMessage(""(each op is 1000 loads)"");
    while (count < 100000) {
      for (int i = 0; i < 1000; i++) {
        ptr = ap.Acquire_Load();
      }
      count++;
      thread->stats.FinishedSingleOp();
    }
    if (ptr == NULL) exit(1); // Disable unused variable warning.
  }",41,,646,2,,void
7644,BLOCK,-1,,"{
      for (int i = 0; i < 1000; i++) {
        ptr = ap.Acquire_Load();
      }
      count++;
      thread->stats.FinishedSingleOp();
    }",28,,652,2,,void
7646,BLOCK,-1,,<empty>,7,,653,1,,void
7656,BLOCK,4,,"{
        ptr = ap.Acquire_Load();
      }",38,,653,4,,void
7675,BLOCK,-1,,<empty>,22,,659,2,,void
7682,BLOCK,-1,,"{
    RandomGenerator gen;
    Slice input = gen.Generate(Options().block_size);
    int64_t bytes = 0;
    int64_t produced = 0;
    bool ok = true;
    std::string compressed;
    while (ok && bytes < 1024 * 1048576) {  // Compress 1G
      ok = port::Snappy_Compress(input.data(), input.size(), &compressed);
      produced += compressed.size();
      bytes += input.size();
      thread->stats.FinishedSingleOp();
    }

    if (!ok) {
      thread->stats.AddMessage(""(snappy failure)"");
    } else {
      char buf[100];
      snprintf(buf, sizeof(buf), ""(output: %.1f%%)"",
               (produced * 100.0) / bytes);
      thread->stats.AddMessage(buf);
      thread->stats.AddBytes(bytes);
    }
  }",44,,662,2,,void
7715,BLOCK,-1,,"{  // Compress 1G
      ok = port::Snappy_Compress(input.data(), input.size(), &compressed);
      produced += compressed.size();
      bytes += input.size();
      thread->stats.FinishedSingleOp();
    }",42,,669,2,,void
7753,BLOCK,-1,,"{
      thread->stats.AddMessage(""(snappy failure)"");
    }",14,,676,2,,void
7762,BLOCK,-1,,"{
      char buf[100];
      snprintf(buf, sizeof(buf), ""(output: %.1f%%)"",
               (produced * 100.0) / bytes);
      thread->stats.AddMessage(buf);
      thread->stats.AddBytes(bytes);
    }",12,,678,1,,void
7792,BLOCK,-1,,"{
    RandomGenerator gen;
    Slice input = gen.Generate(Options().block_size);
    std::string compressed;
    bool ok = port::Snappy_Compress(input.data(), input.size(), &compressed);
    int64_t bytes = 0;
    char* uncompressed = new char[input.size()];
    while (ok && bytes < 1024 * 1048576) {  // Compress 1G
      ok =  port::Snappy_Uncompress(compressed.data(), compressed.size(),
                                    uncompressed);
      bytes += input.size();
      thread->stats.FinishedSingleOp();
    }
    delete[] uncompressed;

    if (!ok) {
      thread->stats.AddMessage(""(snappy failure)"");
    } else {
      thread->stats.AddBytes(bytes);
    }
  }",46,,687,2,,void
7839,BLOCK,-1,,"{  // Compress 1G
      ok =  port::Snappy_Uncompress(compressed.data(), compressed.size(),
                                    uncompressed);
      bytes += input.size();
      thread->stats.FinishedSingleOp();
    }",42,,694,2,,void
7872,BLOCK,-1,,"{
      thread->stats.AddMessage(""(snappy failure)"");
    }",14,,702,2,,void
7881,BLOCK,-1,,"{
      thread->stats.AddBytes(bytes);
    }",12,,704,1,,void
7892,BLOCK,-1,,"{
    assert(db_ == NULL);
    Options options;
    options.env = g_env;
    options.create_if_missing = !FLAGS_use_existing_db;
    options.block_cache = cache_;
    options.write_buffer_size = FLAGS_write_buffer_size;
    options.max_file_size = FLAGS_max_file_size;
    options.block_size = FLAGS_block_size;
    options.max_open_files = FLAGS_open_files;
    options.filter_policy = filter_policy_;
    options.reuse_logs = FLAGS_reuse_logs;
    Status s = DB::Open(options, FLAGS_db, &db_);
    if (!s.ok()) {
      fprintf(stderr, ""open error: %s\n"", s.ToString().c_str());
      exit(1);
    }
  }",15,,709,1,,void
7961,BLOCK,-1,,"{
      fprintf(stderr, ""open error: %s\n"", s.ToString().c_str());
      exit(1);
    }",18,,722,2,,void
7978,BLOCK,-1,,"{
    for (int i = 0; i < num_; i++) {
      delete db_;
      Open();
      thread->stats.FinishedSingleOp();
    }
  }",39,,728,2,,void
7980,BLOCK,-1,,<empty>,5,,729,1,,void
7990,BLOCK,4,,"{
      delete db_;
      Open();
      thread->stats.FinishedSingleOp();
    }",36,,729,4,,void
8004,BLOCK,-1,,"{
    DoWrite(thread, true);
  }",38,,736,2,,void
8012,BLOCK,-1,,"{
    DoWrite(thread, false);
  }",41,,740,2,,void
8021,BLOCK,-1,,"{
    if (num_ != FLAGS_num) {
      char msg[100];
      snprintf(msg, sizeof(msg), ""(%d ops)"", num_);
      thread->stats.AddMessage(msg);
    }

    RandomGenerator gen;
    WriteBatch batch;
    Status s;
    int64_t bytes = 0;
    for (int i = 0; i < num_; i += entries_per_batch_) {
      batch.Clear();
      for (int j = 0; j < entries_per_batch_; j++) {
        const int k = seq ? i+j : (thread->rand.Next() % FLAGS_num);
        char key[100];
        snprintf(key, sizeof(key), ""%016d"", k);
        batch.Put(key, gen.Generate(value_size_));
        bytes += value_size_ + strlen(key);
        thread->stats.FinishedSingleOp();
      }
      s = db_->Write(write_options_, &batch);
      if (!s.ok()) {
        fprintf(stderr, ""put error: %s\n"", s.ToString().c_str());
        exit(1);
      }
    }
    thread->stats.AddBytes(bytes);
  }",47,,744,3,,void
8026,BLOCK,-1,,"{
      char msg[100];
      snprintf(msg, sizeof(msg), ""(%d ops)"", num_);
      thread->stats.AddMessage(msg);
    }",28,,745,2,,void
8049,BLOCK,-1,,<empty>,5,,755,1,,void
8060,BLOCK,4,,"{
      batch.Clear();
      for (int j = 0; j < entries_per_batch_; j++) {
        const int k = seq ? i+j : (thread->rand.Next() % FLAGS_num);
        char key[100];
        snprintf(key, sizeof(key), ""%016d"", k);
        batch.Put(key, gen.Generate(value_size_));
        bytes += value_size_ + strlen(key);
        thread->stats.FinishedSingleOp();
      }
      s = db_->Write(write_options_, &batch);
      if (!s.ok()) {
        fprintf(stderr, ""put error: %s\n"", s.ToString().c_str());
        exit(1);
      }
    }",56,,755,4,,void
8066,BLOCK,-1,,<empty>,7,,757,1,,void
8076,BLOCK,4,,"{
        const int k = seq ? i+j : (thread->rand.Next() % FLAGS_num);
        char key[100];
        snprintf(key, sizeof(key), ""%016d"", k);
        batch.Put(key, gen.Generate(value_size_));
        bytes += value_size_ + strlen(key);
        thread->stats.FinishedSingleOp();
      }",52,,757,4,,void
8137,BLOCK,-1,,"{
        fprintf(stderr, ""put error: %s\n"", s.ToString().c_str());
        exit(1);
      }",20,,766,2,,void
8161,BLOCK,-1,,"{
    Iterator* iter = db_->NewIterator(ReadOptions());
    int i = 0;
    int64_t bytes = 0;
    for (iter->SeekToFirst(); i < reads_ && iter->Valid(); iter->Next()) {
      bytes += iter->key().size() + iter->value().size();
      thread->stats.FinishedSingleOp();
      ++i;
    }
    delete iter;
    thread->stats.AddBytes(bytes);
  }",44,,774,2,,void
8179,BLOCK,-1,,<empty>,5,,778,1,,void
8196,BLOCK,4,,"{
      bytes += iter->key().size() + iter->value().size();
      thread->stats.FinishedSingleOp();
      ++i;
    }",74,,778,4,,void
8235,BLOCK,-1,,"{
    Iterator* iter = db_->NewIterator(ReadOptions());
    int i = 0;
    int64_t bytes = 0;
    for (iter->SeekToLast(); i < reads_ && iter->Valid(); iter->Prev()) {
      bytes += iter->key().size() + iter->value().size();
      thread->stats.FinishedSingleOp();
      ++i;
    }
    delete iter;
    thread->stats.AddBytes(bytes);
  }",41,,787,2,,void
8253,BLOCK,-1,,<empty>,5,,791,1,,void
8270,BLOCK,4,,"{
      bytes += iter->key().size() + iter->value().size();
      thread->stats.FinishedSingleOp();
      ++i;
    }",73,,791,4,,void
8309,BLOCK,-1,,"{
    ReadOptions options;
    std::string value;
    int found = 0;
    for (int i = 0; i < reads_; i++) {
      char key[100];
      const int k = thread->rand.Next() % FLAGS_num;
      snprintf(key, sizeof(key), ""%016d"", k);
      if (db_->Get(options, key, &value).ok()) {
        found++;
      }
      thread->stats.FinishedSingleOp();
    }
    char msg[100];
    snprintf(msg, sizeof(msg), ""(%d of %d found)"", found, num_);
    thread->stats.AddMessage(msg);
  }",40,,800,2,,void
8317,BLOCK,-1,,<empty>,5,,804,1,,void
8327,BLOCK,4,,"{
      char key[100];
      const int k = thread->rand.Next() % FLAGS_num;
      snprintf(key, sizeof(key), ""%016d"", k);
      if (db_->Get(options, key, &value).ok()) {
        found++;
      }
      thread->stats.FinishedSingleOp();
    }",38,,804,4,,void
8358,BLOCK,-1,,"{
        found++;
      }",48,,808,2,,void
8386,BLOCK,-1,,"{
    ReadOptions options;
    std::string value;
    for (int i = 0; i < reads_; i++) {
      char key[100];
      const int k = thread->rand.Next() % FLAGS_num;
      snprintf(key, sizeof(key), ""%016d."", k);
      db_->Get(options, key, &value);
      thread->stats.FinishedSingleOp();
    }
  }",41,,818,2,,void
8390,BLOCK,-1,,<empty>,5,,821,1,,void
8400,BLOCK,4,,"{
      char key[100];
      const int k = thread->rand.Next() % FLAGS_num;
      snprintf(key, sizeof(key), ""%016d."", k);
      db_->Get(options, key, &value);
      thread->stats.FinishedSingleOp();
    }",38,,821,4,,void
8437,BLOCK,-1,,"{
    ReadOptions options;
    std::string value;
    const int range = (FLAGS_num + 99) / 100;
    for (int i = 0; i < reads_; i++) {
      char key[100];
      const int k = thread->rand.Next() % range;
      snprintf(key, sizeof(key), ""%016d"", k);
      db_->Get(options, key, &value);
      thread->stats.FinishedSingleOp();
    }
  }",37,,830,2,,void
8449,BLOCK,-1,,<empty>,5,,834,1,,void
8459,BLOCK,4,,"{
      char key[100];
      const int k = thread->rand.Next() % range;
      snprintf(key, sizeof(key), ""%016d"", k);
      db_->Get(options, key, &value);
      thread->stats.FinishedSingleOp();
    }",38,,834,4,,void
8496,BLOCK,-1,,"{
    ReadOptions options;
    int found = 0;
    for (int i = 0; i < reads_; i++) {
      Iterator* iter = db_->NewIterator(options);
      char key[100];
      const int k = thread->rand.Next() % FLAGS_num;
      snprintf(key, sizeof(key), ""%016d"", k);
      iter->Seek(key);
      if (iter->Valid() && iter->key() == key) found++;
      delete iter;
      thread->stats.FinishedSingleOp();
    }
    char msg[100];
    snprintf(msg, sizeof(msg), ""(%d of %d found)"", found, num_);
    thread->stats.AddMessage(msg);
  }",40,,843,2,,void
8503,BLOCK,-1,,<empty>,5,,846,1,,void
8513,BLOCK,4,,"{
      Iterator* iter = db_->NewIterator(options);
      char key[100];
      const int k = thread->rand.Next() % FLAGS_num;
      snprintf(key, sizeof(key), ""%016d"", k);
      iter->Seek(key);
      if (iter->Valid() && iter->key() == key) found++;
      delete iter;
      thread->stats.FinishedSingleOp();
    }",38,,846,4,,void
8557,BLOCK,-1,,<empty>,48,,852,2,,void
8588,BLOCK,-1,,"{
    RandomGenerator gen;
    WriteBatch batch;
    Status s;
    for (int i = 0; i < num_; i += entries_per_batch_) {
      batch.Clear();
      for (int j = 0; j < entries_per_batch_; j++) {
        const int k = seq ? i+j : (thread->rand.Next() % FLAGS_num);
        char key[100];
        snprintf(key, sizeof(key), ""%016d"", k);
        batch.Delete(key);
        thread->stats.FinishedSingleOp();
      }
      s = db_->Write(write_options_, &batch);
      if (!s.ok()) {
        fprintf(stderr, ""del error: %s\n"", s.ToString().c_str());
        exit(1);
      }
    }
  }",48,,861,3,,void
8593,BLOCK,-1,,<empty>,5,,865,1,,void
8604,BLOCK,4,,"{
      batch.Clear();
      for (int j = 0; j < entries_per_batch_; j++) {
        const int k = seq ? i+j : (thread->rand.Next() % FLAGS_num);
        char key[100];
        snprintf(key, sizeof(key), ""%016d"", k);
        batch.Delete(key);
        thread->stats.FinishedSingleOp();
      }
      s = db_->Write(write_options_, &batch);
      if (!s.ok()) {
        fprintf(stderr, ""del error: %s\n"", s.ToString().c_str());
        exit(1);
      }
    }",56,,865,4,,void
8610,BLOCK,-1,,<empty>,7,,867,1,,void
8620,BLOCK,4,,"{
        const int k = seq ? i+j : (thread->rand.Next() % FLAGS_num);
        char key[100];
        snprintf(key, sizeof(key), ""%016d"", k);
        batch.Delete(key);
        thread->stats.FinishedSingleOp();
      }",52,,867,4,,void
8670,BLOCK,-1,,"{
        fprintf(stderr, ""del error: %s\n"", s.ToString().c_str());
        exit(1);
      }",20,,875,2,,void
8687,BLOCK,-1,,"{
    DoDelete(thread, true);
  }",39,,882,2,,void
8695,BLOCK,-1,,"{
    DoDelete(thread, false);
  }",42,,886,2,,void
8703,BLOCK,-1,,"{
    if (thread->tid > 0) {
      ReadRandom(thread);
    } else {
      // Special thread that keeps writing until other threads are done.
      RandomGenerator gen;
      while (true) {
        {
          MutexLock l(&thread->shared->mu);
          if (thread->shared->num_done + 1 >= thread->shared->num_initialized) {
            // Other threads have finished
            break;
          }
        }

        const int k = thread->rand.Next() % FLAGS_num;
        char key[100];
        snprintf(key, sizeof(key), ""%016d"", k);
        Status s = db_->Put(write_options_, key, gen.Generate(value_size_));
        if (!s.ok()) {
          fprintf(stderr, ""put error: %s\n"", s.ToString().c_str());
          exit(1);
        }
      }

      // Do not count any of the preceding work/delay in stats.
      thread->stats.Start();
    }
  }",46,,890,2,,void
8710,BLOCK,-1,,"{
      ReadRandom(thread);
    }",26,,891,2,,void
8714,BLOCK,-1,,"{
      // Special thread that keeps writing until other threads are done.
      RandomGenerator gen;
      while (true) {
        {
          MutexLock l(&thread->shared->mu);
          if (thread->shared->num_done + 1 >= thread->shared->num_initialized) {
            // Other threads have finished
            break;
          }
        }

        const int k = thread->rand.Next() % FLAGS_num;
        char key[100];
        snprintf(key, sizeof(key), ""%016d"", k);
        Status s = db_->Put(write_options_, key, gen.Generate(value_size_));
        if (!s.ok()) {
          fprintf(stderr, ""put error: %s\n"", s.ToString().c_str());
          exit(1);
        }
      }

      // Do not count any of the preceding work/delay in stats.
      thread->stats.Start();
    }",12,,893,1,,void
8718,BLOCK,-1,,"{
        {
          MutexLock l(&thread->shared->mu);
          if (thread->shared->num_done + 1 >= thread->shared->num_initialized) {
            // Other threads have finished
            break;
          }
        }

        const int k = thread->rand.Next() % FLAGS_num;
        char key[100];
        snprintf(key, sizeof(key), ""%016d"", k);
        Status s = db_->Put(write_options_, key, gen.Generate(value_size_));
        if (!s.ok()) {
          fprintf(stderr, ""put error: %s\n"", s.ToString().c_str());
          exit(1);
        }
      }",20,,896,2,,void
8719,BLOCK,1,,"{
          MutexLock l(&thread->shared->mu);
          if (thread->shared->num_done + 1 >= thread->shared->num_initialized) {
            // Other threads have finished
            break;
          }
        }",9,,897,1,,void
8742,BLOCK,-1,,"{
            // Other threads have finished
            break;
          }",80,,899,2,,void
8782,BLOCK,-1,,"{
          fprintf(stderr, ""put error: %s\n"", s.ToString().c_str());
          exit(1);
        }",22,,909,2,,void
8805,BLOCK,-1,,"{
    db_->CompactRange(NULL, NULL);
  }",37,,920,2,,void
8816,BLOCK,-1,,"{
    std::string stats;
    if (!db_->GetProperty(key, &stats)) {
      stats = ""(failed)"";
    }
    fprintf(stdout, ""\n%s\n"", stats.c_str());
  }",36,,924,2,,void
8827,BLOCK,-1,,"{
      stats = ""(failed)"";
    }",41,,926,2,,void
8844,BLOCK,-1,,"{
    reinterpret_cast<WritableFile*>(arg)->Append(Slice(buf, n));
  }",62,,932,4,,void
8857,BLOCK,-1,,"{
    char fname[100];
    snprintf(fname, sizeof(fname), ""%s/heap-%04d"", FLAGS_db, ++heap_counter_);
    WritableFile* file;
    Status s = g_env->NewWritableFile(fname, &file);
    if (!s.ok()) {
      fprintf(stderr, ""%s\n"", s.ToString().c_str());
      return;
    }
    bool ok = port::GetHeapProfile(WriteToFile, file);
    delete file;
    if (!ok) {
      fprintf(stderr, ""heap profiling not supported\n"");
      g_env->DeleteFile(fname);
    }
  }",22,,936,1,,void
8884,BLOCK,-1,,"{
      fprintf(stderr, ""%s\n"", s.ToString().c_str());
      return;
    }",18,,941,2,,void
8910,BLOCK,-1,,"{
      fprintf(stderr, ""heap profiling not supported\n"");
      g_env->DeleteFile(fname);
    }",14,,947,2,,void
8924,BLOCK,-1,,"{
  FLAGS_write_buffer_size = leveldb::Options().write_buffer_size;
  FLAGS_max_file_size = leveldb::Options().max_file_size;
  FLAGS_block_size = leveldb::Options().block_size;
  FLAGS_open_files = leveldb::Options().max_open_files;
  std::string default_db_path;

  for (int i = 1; i < argc; i++) {
    double d;
    int n;
    char junk;
    if (leveldb::Slice(argv[i]).starts_with(""--benchmarks="")) {
      FLAGS_benchmarks = argv[i] + strlen(""--benchmarks="");
    } else if (sscanf(argv[i], ""--compression_ratio=%lf%c"", &d, &junk) == 1) {
      FLAGS_compression_ratio = d;
    } else if (sscanf(argv[i], ""--histogram=%d%c"", &n, &junk) == 1 &&
               (n == 0 || n == 1)) {
      FLAGS_histogram = n;
    } else if (sscanf(argv[i], ""--use_existing_db=%d%c"", &n, &junk) == 1 &&
               (n == 0 || n == 1)) {
      FLAGS_use_existing_db = n;
    } else if (sscanf(argv[i], ""--reuse_logs=%d%c"", &n, &junk) == 1 &&
               (n == 0 || n == 1)) {
      FLAGS_reuse_logs = n;
  ...",33,,956,3,,void
8959,BLOCK,-1,,<empty>,3,,963,1,,void
8969,BLOCK,4,,"{
    double d;
    int n;
    char junk;
    if (leveldb::Slice(argv[i]).starts_with(""--benchmarks="")) {
      FLAGS_benchmarks = argv[i] + strlen(""--benchmarks="");
    } else if (sscanf(argv[i], ""--compression_ratio=%lf%c"", &d, &junk) == 1) {
      FLAGS_compression_ratio = d;
    } else if (sscanf(argv[i], ""--histogram=%d%c"", &n, &junk) == 1 &&
               (n == 0 || n == 1)) {
      FLAGS_histogram = n;
    } else if (sscanf(argv[i], ""--use_existing_db=%d%c"", &n, &junk) == 1 &&
               (n == 0 || n == 1)) {
      FLAGS_use_existing_db = n;
    } else if (sscanf(argv[i], ""--reuse_logs=%d%c"", &n, &junk) == 1 &&
               (n == 0 || n == 1)) {
      FLAGS_reuse_logs = n;
    } else if (sscanf(argv[i], ""--num=%d%c"", &n, &junk) == 1) {
      FLAGS_num = n;
    } else if (sscanf(argv[i], ""--reads=%d%c"", &n, &junk) == 1) {
      FLAGS_reads = n;
    } else if (sscanf(argv[i], ""--threads=%d%c"", &n, &junk) == 1) {
      FLAGS_threads = n;
    } else if (sscanf(argv[i], ""--...",34,,963,4,,void
8985,BLOCK,-1,,"{
      FLAGS_benchmarks = argv[i] + strlen(""--benchmarks="");
    }",63,,967,2,,void
8995,BLOCK,-1,,<empty>,12,,969,1,,void
9008,BLOCK,-1,,"{
      FLAGS_compression_ratio = d;
    }",78,,969,2,,void
9013,BLOCK,-1,,<empty>,12,,971,1,,void
9034,BLOCK,-1,,"{
      FLAGS_histogram = n;
    }",36,,972,2,,void
9039,BLOCK,-1,,<empty>,12,,974,1,,void
9060,BLOCK,-1,,"{
      FLAGS_use_existing_db = n;
    }",36,,975,2,,void
9065,BLOCK,-1,,<empty>,12,,977,1,,void
9086,BLOCK,-1,,"{
      FLAGS_reuse_logs = n;
    }",36,,978,2,,void
9091,BLOCK,-1,,<empty>,12,,980,1,,void
9104,BLOCK,-1,,"{
      FLAGS_num = n;
    }",63,,980,2,,void
9109,BLOCK,-1,,<empty>,12,,982,1,,void
9122,BLOCK,-1,,"{
      FLAGS_reads = n;
    }",65,,982,2,,void
9127,BLOCK,-1,,<empty>,12,,984,1,,void
9140,BLOCK,-1,,"{
      FLAGS_threads = n;
    }",67,,984,2,,void
9145,BLOCK,-1,,<empty>,12,,986,1,,void
9158,BLOCK,-1,,"{
      FLAGS_value_size = n;
    }",70,,986,2,,void
9163,BLOCK,-1,,<empty>,12,,988,1,,void
9176,BLOCK,-1,,"{
      FLAGS_write_buffer_size = n;
    }",77,,988,2,,void
9181,BLOCK,-1,,<empty>,12,,990,1,,void
9194,BLOCK,-1,,"{
      FLAGS_max_file_size = n;
    }",73,,990,2,,void
9199,BLOCK,-1,,<empty>,12,,992,1,,void
9212,BLOCK,-1,,"{
      FLAGS_block_size = n;
    }",70,,992,2,,void
9217,BLOCK,-1,,<empty>,12,,994,1,,void
9230,BLOCK,-1,,"{
      FLAGS_cache_size = n;
    }",70,,994,2,,void
9235,BLOCK,-1,,<empty>,12,,996,1,,void
9248,BLOCK,-1,,"{
      FLAGS_bloom_bits = n;
    }",70,,996,2,,void
9253,BLOCK,-1,,<empty>,12,,998,1,,void
9266,BLOCK,-1,,"{
      FLAGS_open_files = n;
    }",70,,998,2,,void
9271,BLOCK,-1,,<empty>,12,,1000,1,,void
9281,BLOCK,-1,,"{
      FLAGS_db = argv[i] + 5;
    }",51,,1000,2,,void
9290,BLOCK,-1,,"{
      fprintf(stderr, ""Invalid flag '%s'\n"", argv[i]);
      exit(1);
    }",12,,1002,1,,void
9313,BLOCK,-1,,"{
      leveldb::g_env->GetTestDirectory(&default_db_path);
      default_db_path += ""/dbbench"";
      FLAGS_db = default_db_path.c_str();
  }",25,,1011,2,,void
9402,BLOCK,-1,,<empty>,1,,1,1,,ANY
9416,BLOCK,-1,,{ },45,,48,2,,void
9432,BLOCK,-1,,{ return &outputs[outputs.size()-1]; },28,,74,1,,void
9447,BLOCK,-1,,"{
  }",24,,80,2,,void
9454,BLOCK,-1,,"{
  if (static_cast<V>(*ptr) > maxvalue) *ptr = maxvalue;
  if (static_cast<V>(*ptr) < minvalue) *ptr = minvalue;
}",57,,86,4,,void
9462,BLOCK,-1,,<empty>,40,,87,2,,void
9474,BLOCK,-1,,<empty>,40,,88,2,,void
9486,BLOCK,-1,,"{
  Options result = src;
  result.comparator = icmp;
  result.filter_policy = (src.filter_policy != NULL) ? ipolicy : NULL;
  ClipToRange(&result.max_open_files,    64 + kNumNonTableCacheFiles, 50000);
  ClipToRange(&result.write_buffer_size, 64<<10,                      1<<30);
  ClipToRange(&result.max_file_size,     1<<20,                       1<<30);
  ClipToRange(&result.block_size,        1<<10,                       4<<20);
  if (result.info_log == NULL) {
    // Open a log file in the same directory as the db
    src.env->CreateDir(dbname);  // In case it does not exist
    src.env->RenameFile(InfoLogFileName(dbname), OldInfoLogFileName(dbname));
    Status s = src.env->NewLogger(InfoLogFileName(dbname), &result.info_log);
    if (!s.ok()) {
      // No place suitable for logging
      result.info_log = NULL;
    }
  }
  if (result.block_cache == NULL) {
    result.block_cache = NewLRUCache(8 << 20);
  }
  return result;
}",45,,93,5,,void
9556,BLOCK,-1,,"{
    // Open a log file in the same directory as the db
    src.env->CreateDir(dbname);  // In case it does not exist
    src.env->RenameFile(InfoLogFileName(dbname), OldInfoLogFileName(dbname));
    Status s = src.env->NewLogger(InfoLogFileName(dbname), &result.info_log);
    if (!s.ok()) {
      // No place suitable for logging
      result.info_log = NULL;
    }
  }",32,,101,2,,void
9595,BLOCK,-1,,"{
      // No place suitable for logging
      result.info_log = NULL;
    }",18,,106,2,,void
9607,BLOCK,-1,,"{
    result.block_cache = NewLRUCache(8 << 20);
  }",35,,111,2,,void
9623,BLOCK,-1,,"{
  has_imm_.Release_Store(NULL);

  // Reserve ten files or so for other uses and give the rest to TableCache.
  const int table_cache_size = options_.max_open_files - kNumNonTableCacheFiles;
  table_cache_ = new TableCache(dbname_, &options_, table_cache_size);

  versions_ = new VersionSet(dbname_, &options_, table_cache_,
                             &internal_comparator_);
}",32,,137,3,,void
9658,BLOCK,-1,,"{
  // Wait for background work to finish
  mutex_.Lock();
  shutting_down_.Release_Store(this);  // Any non-NULL value is ok
  while (bg_compaction_scheduled_) {
    bg_cv_.Wait();
  }
  mutex_.Unlock();

  if (db_lock_ != NULL) {
    env_->UnlockFile(db_lock_);
  }

  delete versions_;
  if (mem_ != NULL) mem_->Unref();
  if (imm_ != NULL) imm_->Unref();
  delete tmp_batch_;
  delete log_;
  delete logfile_;
  delete table_cache_;

  if (owns_info_log_) {
    delete options_.info_log;
  }
  if (owns_cache_) {
    delete options_.block_cache;
  }
}",19,,148,1,,void
9670,BLOCK,-1,,"{
    bg_cv_.Wait();
  }",36,,152,2,,void
9683,BLOCK,-1,,"{
    env_->UnlockFile(db_lock_);
  }",25,,157,2,,void
9695,BLOCK,-1,,<empty>,21,,162,2,,void
9704,BLOCK,-1,,<empty>,21,,163,2,,void
9719,BLOCK,-1,,"{
    delete options_.info_log;
  }",23,,169,2,,void
9726,BLOCK,-1,,"{
    delete options_.block_cache;
  }",20,,172,2,,void
9734,BLOCK,-1,,"{
  VersionEdit new_db;
  new_db.SetComparatorName(user_comparator()->Name());
  new_db.SetLogNumber(0);
  new_db.SetNextFile(2);
  new_db.SetLastSequence(0);

  const std::string manifest = DescriptorFileName(dbname_, 1);
  WritableFile* file;
  Status s = env_->NewWritableFile(manifest, &file);
  if (!s.ok()) {
    return s;
  }
  {
    log::Writer log(file);
    std::string record;
    new_db.EncodeTo(&record);
    s = log.AddRecord(record);
    if (s.ok()) {
      s = file->Close();
    }
  }
  delete file;
  if (s.ok()) {
    // Make ""CURRENT"" file that points to the new manifest file.
    s = SetCurrentFile(env_, dbname_, 1);
  } else {
    env_->DeleteFile(manifest);
  }
  return s;
}",24,,177,1,,void
9782,BLOCK,-1,,"{
    return s;
  }",16,,187,2,,void
9785,BLOCK,12,,"{
    log::Writer log(file);
    std::string record;
    new_db.EncodeTo(&record);
    s = log.AddRecord(record);
    if (s.ok()) {
      s = file->Close();
    }
  }",3,,190,12,,void
9808,BLOCK,-1,,"{
      s = file->Close();
    }",17,,195,2,,void
9822,BLOCK,-1,,"{
    // Make ""CURRENT"" file that points to the new manifest file.
    s = SetCurrentFile(env_, dbname_, 1);
  }",15,,200,2,,void
9830,BLOCK,-1,,"{
    env_->DeleteFile(manifest);
  }",10,,203,1,,void
9842,BLOCK,-1,,"{
  if (s->ok() || options_.paranoid_checks) {
    // No change needed
  } else {
    Log(options_.info_log, ""Ignoring error %s"", s->ToString().c_str());
    *s = Status::OK();
  }
}",48,,209,2,,void
9852,BLOCK,-1,,"{
    // No change needed
  }",44,,210,2,,void
9854,BLOCK,-1,,"{
    Log(options_.info_log, ""Ignoring error %s"", s->ToString().c_str());
    *s = Status::OK();
  }",10,,212,1,,void
9877,BLOCK,-1,,"{
  if (!bg_error_.ok()) {
    // After a background error, we don't know whether a new version may
    // or may not have been committed, so we cannot safely garbage collect.
    return;
  }

  // Make a set of all of the live files
  std::set<uint64_t> live = pending_outputs_;
  versions_->AddLiveFiles(&live);

  std::vector<std::string> filenames;
  env_->GetChildren(dbname_, &filenames); // Ignoring errors on purpose
  uint64_t number;
  FileType type;
  for (size_t i = 0; i < filenames.size(); i++) {
    if (ParseFileName(filenames[i], &number, &type)) {
      bool keep = true;
      switch (type) {
        case kLogFile:
          keep = ((number >= versions_->LogNumber()) ||
                  (number == versions_->PrevLogNumber()));
          break;
        case kDescriptorFile:
          // Keep my manifest file, and any newer incarnations'
          // (in case there is a race that allows other incarnations)
          keep = (number >= versions_->ManifestFileNumber());
    ...",36,,218,1,,void
9884,BLOCK,-1,,"{
    // After a background error, we don't know whether a new version may
    // or may not have been committed, so we cannot safely garbage collect.
    return;
  }",24,,219,2,,void
9920,BLOCK,-1,,<empty>,3,,233,1,,void
9933,BLOCK,4,,"{
    if (ParseFileName(filenames[i], &number, &type)) {
      bool keep = true;
      switch (type) {
        case kLogFile:
          keep = ((number >= versions_->LogNumber()) ||
                  (number == versions_->PrevLogNumber()));
          break;
        case kDescriptorFile:
          // Keep my manifest file, and any newer incarnations'
          // (in case there is a race that allows other incarnations)
          keep = (number >= versions_->ManifestFileNumber());
          break;
        case kTableFile:
          keep = (live.find(number) != live.end());
          break;
        case kTempFile:
          // Any temp files that are currently being written to must
          // be recorded in pending_outputs_, which is inserted into ""live""
          keep = (live.find(number) != live.end());
          break;
        case kCurrentFile:
        case kDBLockFile:
        case kInfoLogFile:
          keep = true;
          break;
      }

      if (!keep) {
        if (type...",49,,233,4,,void
9943,BLOCK,-1,,"{
      bool keep = true;
      switch (type) {
        case kLogFile:
          keep = ((number >= versions_->LogNumber()) ||
                  (number == versions_->PrevLogNumber()));
          break;
        case kDescriptorFile:
          // Keep my manifest file, and any newer incarnations'
          // (in case there is a race that allows other incarnations)
          keep = (number >= versions_->ManifestFileNumber());
          break;
        case kTableFile:
          keep = (live.find(number) != live.end());
          break;
        case kTempFile:
          // Any temp files that are currently being written to must
          // be recorded in pending_outputs_, which is inserted into ""live""
          keep = (live.find(number) != live.end());
          break;
        case kCurrentFile:
        case kDBLockFile:
        case kInfoLogFile:
          keep = true;
          break;
      }

      if (!keep) {
        if (type == kTableFile) {
          table_cache_->Evict(number)...",54,,234,2,,void
9950,BLOCK,-1,,"{
        case kLogFile:
          keep = ((number >= versions_->LogNumber()) ||
                  (number == versions_->PrevLogNumber()));
          break;
        case kDescriptorFile:
          // Keep my manifest file, and any newer incarnations'
          // (in case there is a race that allows other incarnations)
          keep = (number >= versions_->ManifestFileNumber());
          break;
        case kTableFile:
          keep = (live.find(number) != live.end());
          break;
        case kTempFile:
          // Any temp files that are currently being written to must
          // be recorded in pending_outputs_, which is inserted into ""live""
          keep = (live.find(number) != live.end());
          break;
        case kCurrentFile:
        case kDBLockFile:
        case kInfoLogFile:
          keep = true;
          break;
      }",21,,236,2,,void
10023,BLOCK,-1,,"{
        if (type == kTableFile) {
          table_cache_->Evict(number);
        }
        Log(options_.info_log, ""Delete type=%d #%lld\n"",
            int(type),
            static_cast<unsigned long long>(number));
        env_->DeleteFile(dbname_ + ""/"" + filenames[i]);
      }",18,,261,2,,void
10028,BLOCK,-1,,"{
          table_cache_->Evict(number);
        }",33,,262,2,,void
10061,BLOCK,-1,,"{
  mutex_.AssertHeld();

  // Ignore error from CreateDir since the creation of the DB is
  // committed only when the descriptor is created, and this directory
  // may already exist from a previous failed creation attempt.
  env_->CreateDir(dbname_);
  assert(db_lock_ == NULL);
  Status s = env_->LockFile(LockFileName(dbname_), &db_lock_);
  if (!s.ok()) {
    return s;
  }

  if (!env_->FileExists(CurrentFileName(dbname_))) {
    if (options_.create_if_missing) {
      s = NewDB();
      if (!s.ok()) {
        return s;
      }
    } else {
      return Status::InvalidArgument(
          dbname_, ""does not exist (create_if_missing is false)"");
    }
  } else {
    if (options_.error_if_exists) {
      return Status::InvalidArgument(
          dbname_, ""exists (error_if_exists is true)"");
    }
  }

  s = versions_->Recover(save_manifest);
  if (!s.ok()) {
    return s;
  }
  SequenceNumber max_sequence(0);

  // Recover from all newer log files than the ones named in the
  // de...",64,,274,3,,void
10092,BLOCK,-1,,"{
    return s;
  }",16,,283,2,,void
10103,BLOCK,-1,,"{
    if (options_.create_if_missing) {
      s = NewDB();
      if (!s.ok()) {
        return s;
      }
    } else {
      return Status::InvalidArgument(
          dbname_, ""does not exist (create_if_missing is false)"");
    }
  }",52,,287,2,,void
10108,BLOCK,-1,,"{
      s = NewDB();
      if (!s.ok()) {
        return s;
      }
    }",37,,288,2,,void
10118,BLOCK,-1,,"{
        return s;
      }",20,,290,2,,void
10122,BLOCK,-1,,"{
      return Status::InvalidArgument(
          dbname_, ""does not exist (create_if_missing is false)"");
    }",12,,293,1,,void
10131,BLOCK,-1,,"{
    if (options_.error_if_exists) {
      return Status::InvalidArgument(
          dbname_, ""exists (error_if_exists is true)"");
    }
  }",10,,297,1,,void
10136,BLOCK,-1,,"{
      return Status::InvalidArgument(
          dbname_, ""exists (error_if_exists is true)"");
    }",35,,298,2,,void
10157,BLOCK,-1,,"{
    return s;
  }",16,,305,2,,void
10201,BLOCK,-1,,"{
    return s;
  }",16,,321,2,,void
10227,BLOCK,-1,,<empty>,3,,329,1,,void
10240,BLOCK,4,,"{
    if (ParseFileName(filenames[i], &number, &type)) {
      expected.erase(number);
      if (type == kLogFile && ((number >= min_log) || (number == prev_log)))
        logs.push_back(number);
    }
  }",49,,329,4,,void
10250,BLOCK,-1,,"{
      expected.erase(number);
      if (type == kLogFile && ((number >= min_log) || (number == prev_log)))
        logs.push_back(number);
    }",54,,330,2,,void
10268,BLOCK,-1,,<empty>,9,,333,2,,void
10280,BLOCK,-1,,"{
    char buf[50];
    snprintf(buf, sizeof(buf), ""%d missing files; e.g."",
             static_cast<int>(expected.size()));
    return Status::Corruption(buf, TableFileName(dbname_, *(expected.begin())));
  }",26,,336,2,,void
10319,BLOCK,-1,,<empty>,3,,345,1,,void
10332,BLOCK,4,,"{
    s = RecoverLogFile(logs[i], (i == logs.size() - 1), save_manifest, edit,
                       &max_sequence);
    if (!s.ok()) {
      return s;
    }

    // The previous incarnation may not have written any MANIFEST
    // records after allocating this log number.  So we manually
    // update the file number allocation counter in VersionSet.
    versions_->MarkFileNumberUsed(logs[i]);
  }",44,,345,4,,void
10357,BLOCK,-1,,"{
      return s;
    }",18,,348,2,,void
10374,BLOCK,-1,,"{
    versions_->SetLastSequence(max_sequence);
  }",49,,358,2,,void
10393,BLOCK,-1,,"{
  struct LogReporter : public log::Reader::Reporter {
    Env* env;
    Logger* info_log;
    const char* fname;
    Status* status;  // NULL if options_.paranoid_checks==false
    virtual void Corruption(size_t bytes, const Status& s) {
      Log(info_log, ""%s%s: dropping %d bytes; %s"",
          (this->status == NULL ? ""(ignoring error) "" : """"),
          fname, static_cast<int>(bytes), s.ToString().c_str());
      if (this->status != NULL && this->status->ok()) *this->status = s;
    }
  };

  mutex_.AssertHeld();

  // Open the log file
  std::string fname = LogFileName(dbname_, log_number);
  SequentialFile* file;
  Status status = env_->NewSequentialFile(fname, &file);
  if (!status.ok()) {
    MaybeIgnoreError(&status);
    return status;
  }

  // Create the log reader.
  LogReporter reporter;
  reporter.env = env_;
  reporter.info_log = options_.info_log;
  reporter.fname = fname.c_str();
  reporter.status = (options_.paranoid_checks ? &status : NULL);
  // We intentional...",61,,367,6,,void
10421,BLOCK,-1,,"{
    MaybeIgnoreError(&status);
    return status;
  }",21,,387,2,,void
10499,BLOCK,-1,,"{
    if (record.size() < 12) {
      reporter.Corruption(
          record.size(), Status::Corruption(""log record too small""));
      continue;
    }
    WriteBatchInternal::SetContents(&batch, record);

    if (mem == NULL) {
      mem = new MemTable(internal_comparator_);
      mem->Ref();
    }
    status = WriteBatchInternal::InsertInto(&batch, mem);
    MaybeIgnoreError(&status);
    if (!status.ok()) {
      break;
    }
    const SequenceNumber last_seq =
        WriteBatchInternal::Sequence(&batch) +
        WriteBatchInternal::Count(&batch) - 1;
    if (last_seq > *max_sequence) {
      *max_sequence = last_seq;
    }

    if (mem->ApproximateMemoryUsage() > options_.write_buffer_size) {
      compactions++;
      *save_manifest = true;
      status = WriteLevel0Table(mem, edit, NULL);
      mem->Unref();
      mem = NULL;
      if (!status.ok()) {
        // Reflect errors immediately so that conditions like full
        // file-systems cause the DB::Open() to fail.
     ...",23,,414,2,,void
10507,BLOCK,-1,,"{
      reporter.Corruption(
          record.size(), Status::Corruption(""log record too small""));
      continue;
    }",29,,415,2,,void
10533,BLOCK,-1,,"{
      mem = new MemTable(internal_comparator_);
      mem->Ref();
    }",22,,422,2,,void
10561,BLOCK,-1,,"{
      break;
    }",23,,428,2,,void
10586,BLOCK,-1,,"{
      *max_sequence = last_seq;
    }",35,,434,2,,void
10600,BLOCK,-1,,"{
      compactions++;
      *save_manifest = true;
      status = WriteLevel0Table(mem, edit, NULL);
      mem->Unref();
      mem = NULL;
      if (!status.ok()) {
        // Reflect errors immediately so that conditions like full
        // file-systems cause the DB::Open() to fail.
        break;
      }
    }",69,,438,2,,void
10626,BLOCK,-1,,"{
        // Reflect errors immediately so that conditions like full
        // file-systems cause the DB::Open() to fail.
        break;
      }",25,,444,2,,void
10645,BLOCK,-1,,"{
    assert(logfile_ == NULL);
    assert(log_ == NULL);
    assert(mem_ == NULL);
    uint64_t lfile_size;
    if (env_->GetFileSize(fname, &lfile_size).ok() &&
        env_->NewAppendableFile(fname, &logfile_).ok()) {
      Log(options_.info_log, ""Reusing old log %s \n"", fname.c_str());
      log_ = new log::Writer(logfile_, lfile_size);
      logfile_number_ = log_number;
      if (mem != NULL) {
        mem_ = mem;
        mem = NULL;
      } else {
        // mem can be NULL if lognum exists but was empty.
        mem_ = new MemTable(internal_comparator_);
        mem_->Ref();
      }
    }
  }",75,,455,2,,void
10681,BLOCK,-1,,"{
      Log(options_.info_log, ""Reusing old log %s \n"", fname.c_str());
      log_ = new log::Writer(logfile_, lfile_size);
      logfile_number_ = log_number;
      if (mem != NULL) {
        mem_ = mem;
        mem = NULL;
      } else {
        // mem can be NULL if lognum exists but was empty.
        mem_ = new MemTable(internal_comparator_);
        mem_->Ref();
      }
    }",57,,461,2,,void
10704,BLOCK,-1,,"{
        mem_ = mem;
        mem = NULL;
      }",24,,465,2,,void
10712,BLOCK,-1,,"{
        // mem can be NULL if lognum exists but was empty.
        mem_ = new MemTable(internal_comparator_);
        mem_->Ref();
      }",14,,468,1,,void
10726,BLOCK,-1,,"{
    // mem did not get reused; compact it.
    if (status.ok()) {
      *save_manifest = true;
      status = WriteLevel0Table(mem, edit, NULL);
    }
    mem->Unref();
  }",20,,476,2,,void
10732,BLOCK,-1,,"{
      *save_manifest = true;
      status = WriteLevel0Table(mem, edit, NULL);
    }",22,,478,2,,void
10755,BLOCK,-1,,"{
  mutex_.AssertHeld();
  const uint64_t start_micros = env_->NowMicros();
  FileMetaData meta;
  meta.number = versions_->NewFileNumber();
  pending_outputs_.insert(meta.number);
  Iterator* iter = mem->NewIterator();
  Log(options_.info_log, ""Level-0 table #%llu: started"",
      (unsigned long long) meta.number);

  Status s;
  {
    mutex_.Unlock();
    s = BuildTable(dbname_, env_, options_, table_cache_, iter, &meta);
    mutex_.Lock();
  }

  Log(options_.info_log, ""Level-0 table #%llu: %lld bytes %s"",
      (unsigned long long) meta.number,
      (unsigned long long) meta.file_size,
      s.ToString().c_str());
  delete iter;
  pending_outputs_.erase(meta.number);


  // Note that if file_size is zero, the file has been deleted and
  // should not be added to the manifest.
  int level = 0;
  if (s.ok() && meta.file_size > 0) {
    const Slice min_user_key = meta.smallest.user_key();
    const Slice max_user_key = meta.largest.user_key();
    if (base != NULL) {
      level =...",48,,489,4,,void
10801,BLOCK,11,,"{
    mutex_.Unlock();
    s = BuildTable(dbname_, env_, options_, table_cache_, iter, &meta);
    mutex_.Lock();
  }",3,,500,11,,void
10866,BLOCK,-1,,"{
    const Slice min_user_key = meta.smallest.user_key();
    const Slice max_user_key = meta.largest.user_key();
    if (base != NULL) {
      level = base->PickLevelForMemTableOutput(min_user_key, max_user_key);
    }
    edit->AddFile(level, meta.number, meta.file_size,
                  meta.smallest, meta.largest);
  }",37,,517,2,,void
10889,BLOCK,-1,,"{
      level = base->PickLevelForMemTableOutput(min_user_key, max_user_key);
    }",23,,520,2,,void
10945,BLOCK,-1,,"{
  mutex_.AssertHeld();
  assert(imm_ != NULL);

  // Save the contents of the memtable as a new Table
  VersionEdit edit;
  Version* base = versions_->current();
  base->Ref();
  Status s = WriteLevel0Table(imm_, &edit, base);
  base->Unref();

  if (s.ok() && shutting_down_.Acquire_Load()) {
    s = Status::IOError(""Deleting DB during memtable compaction"");
  }

  // Replace immutable memtable with the generated Table
  if (s.ok()) {
    edit.SetPrevLogNumber(0);
    edit.SetLogNumber(logfile_number_);  // Earlier logs no longer needed
    s = versions_->LogAndApply(&edit, &mutex_);
  }

  if (s.ok()) {
    // Commit to the new state
    imm_->Unref();
    imm_ = NULL;
    has_imm_.Release_Store(NULL);
    DeleteObsoleteFiles();
  } else {
    RecordBackgroundError(s);
  }
}",32,,534,1,,void
10988,BLOCK,-1,,"{
    s = Status::IOError(""Deleting DB during memtable compaction"");
  }",48,,545,2,,void
11001,BLOCK,-1,,"{
    edit.SetPrevLogNumber(0);
    edit.SetLogNumber(logfile_number_);  // Earlier logs no longer needed
    s = versions_->LogAndApply(&edit, &mutex_);
  }",15,,550,2,,void
11027,BLOCK,-1,,"{
    // Commit to the new state
    imm_->Unref();
    imm_ = NULL;
    has_imm_.Release_Store(NULL);
    DeleteObsoleteFiles();
  }",15,,556,2,,void
11042,BLOCK,-1,,"{
    RecordBackgroundError(s);
  }",10,,562,1,,void
11050,BLOCK,-1,,"{
  int max_level_with_files = 1;
  {
    MutexLock l(&mutex_);
    Version* base = versions_->current();
    for (int level = 1; level < config::kNumLevels; level++) {
      if (base->OverlapInLevel(level, begin, end)) {
        max_level_with_files = level;
      }
    }
  }
  TEST_CompactMemTable(); // TODO(sanjay): Skip if memtable does not overlap
  for (int level = 0; level < max_level_with_files; level++) {
    TEST_CompactRange(level, begin, end);
  }
}",65,,567,3,,void
11055,BLOCK,3,,"{
    MutexLock l(&mutex_);
    Version* base = versions_->current();
    for (int level = 1; level < config::kNumLevels; level++) {
      if (base->OverlapInLevel(level, begin, end)) {
        max_level_with_files = level;
      }
    }
  }",3,,569,3,,void
11068,BLOCK,-1,,<empty>,5,,572,1,,void
11080,BLOCK,4,,"{
      if (base->OverlapInLevel(level, begin, end)) {
        max_level_with_files = level;
      }
    }",62,,572,4,,void
11089,BLOCK,-1,,"{
        max_level_with_files = level;
      }",52,,573,2,,void
11095,BLOCK,-1,,<empty>,3,,579,1,,void
11105,BLOCK,4,,"{
    TEST_CompactRange(level, begin, end);
  }",62,,579,4,,void
11116,BLOCK,-1,,"{
  assert(level >= 0);
  assert(level + 1 < config::kNumLevels);

  InternalKey begin_storage, end_storage;

  ManualCompaction manual;
  manual.level = level;
  manual.done = false;
  if (begin == NULL) {
    manual.begin = NULL;
  } else {
    begin_storage = InternalKey(*begin, kMaxSequenceNumber, kValueTypeForSeek);
    manual.begin = &begin_storage;
  }
  if (end == NULL) {
    manual.end = NULL;
  } else {
    end_storage = InternalKey(*end, 0, static_cast<ValueType>(0));
    manual.end = &end_storage;
  }

  MutexLock l(&mutex_);
  while (!manual.done && !shutting_down_.Acquire_Load() && bg_error_.ok()) {
    if (manual_compaction_ == NULL) {  // Idle
      manual_compaction_ = &manual;
      MaybeScheduleCompaction();
    } else {  // Running either my compaction or another compaction.
      bg_cv_.Wait();
    }
  }
  if (manual_compaction_ == &manual) {
    // Cancel my manual compaction since we aborted early for some reason.
    manual_compaction_ = NULL;
  }
}",80,,584,4,,void
11146,BLOCK,-1,,"{
    manual.begin = NULL;
  }",22,,593,2,,void
11153,BLOCK,-1,,"{
    begin_storage = InternalKey(*begin, kMaxSequenceNumber, kValueTypeForSeek);
    manual.begin = &begin_storage;
  }",10,,595,1,,void
11171,BLOCK,-1,,"{
    manual.end = NULL;
  }",20,,599,2,,void
11178,BLOCK,-1,,"{
    end_storage = InternalKey(*end, 0, static_cast<ValueType>(0));
    manual.end = &end_storage;
  }",10,,601,1,,void
11214,BLOCK,-1,,"{
    if (manual_compaction_ == NULL) {  // Idle
      manual_compaction_ = &manual;
      MaybeScheduleCompaction();
    } else {  // Running either my compaction or another compaction.
      bg_cv_.Wait();
    }
  }",76,,607,2,,void
11219,BLOCK,-1,,"{  // Idle
      manual_compaction_ = &manual;
      MaybeScheduleCompaction();
    }",37,,608,2,,void
11226,BLOCK,-1,,"{  // Running either my compaction or another compaction.
      bg_cv_.Wait();
    }",12,,611,1,,void
11236,BLOCK,-1,,"{
    // Cancel my manual compaction since we aborted early for some reason.
    manual_compaction_ = NULL;
  }",38,,615,2,,void
11243,BLOCK,-1,,"{
  // NULL batch means just wait for earlier writes to be done
  Status s = Write(WriteOptions(), NULL);
  if (s.ok()) {
    // Wait until the compaction completes
    MutexLock l(&mutex_);
    while (imm_ != NULL && bg_error_.ok()) {
      bg_cv_.Wait();
    }
    if (imm_ != NULL) {
      s = bg_error_;
    }
  }
  return s;
}",39,,621,1,,void
11255,BLOCK,-1,,"{
    // Wait until the compaction completes
    MutexLock l(&mutex_);
    while (imm_ != NULL && bg_error_.ok()) {
      bg_cv_.Wait();
    }
    if (imm_ != NULL) {
      s = bg_error_;
    }
  }",15,,624,2,,void
11269,BLOCK,-1,,"{
      bg_cv_.Wait();
    }",44,,627,2,,void
11278,BLOCK,-1,,"{
      s = bg_error_;
    }",23,,630,2,,void
11288,BLOCK,-1,,"{
  mutex_.AssertHeld();
  if (bg_error_.ok()) {
    bg_error_ = s;
    bg_cv_.SignalAll();
  }
}",53,,637,2,,void
11298,BLOCK,-1,,"{
    bg_error_ = s;
    bg_cv_.SignalAll();
  }",23,,639,2,,void
11309,BLOCK,-1,,"{
  mutex_.AssertHeld();
  if (bg_compaction_scheduled_) {
    // Already scheduled
  } else if (shutting_down_.Acquire_Load()) {
    // DB is being deleted; no more background compactions
  } else if (!bg_error_.ok()) {
    // Already got an error; no more changes
  } else if (imm_ == NULL &&
             manual_compaction_ == NULL &&
             !versions_->NeedsCompaction()) {
    // No work to be done
  } else {
    bg_compaction_scheduled_ = true;
    env_->Schedule(&DBImpl::BGWork, this);
  }
}",40,,645,1,,void
11316,BLOCK,-1,,"{
    // Already scheduled
  }",33,,647,2,,void
11318,BLOCK,-1,,<empty>,10,,649,1,,void
11324,BLOCK,-1,,"{
    // DB is being deleted; no more background compactions
  }",45,,649,2,,void
11326,BLOCK,-1,,<empty>,10,,651,1,,void
11333,BLOCK,-1,,"{
    // Already got an error; no more changes
  }",31,,651,2,,void
11335,BLOCK,-1,,<empty>,10,,653,1,,void
11350,BLOCK,-1,,"{
    // No work to be done
  }",45,,655,2,,void
11352,BLOCK,-1,,"{
    bg_compaction_scheduled_ = true;
    env_->Schedule(&DBImpl::BGWork, this);
  }",10,,657,1,,void
11369,BLOCK,-1,,"{
  reinterpret_cast<DBImpl*>(db)->BackgroundCall();
}",31,,663,2,,void
11379,BLOCK,-1,,"{
  MutexLock l(&mutex_);
  assert(bg_compaction_scheduled_);
  if (shutting_down_.Acquire_Load()) {
    // No more background work when shutting down.
  } else if (!bg_error_.ok()) {
    // No more background work after a background error.
  } else {
    BackgroundCompaction();
  }

  bg_compaction_scheduled_ = false;

  // Previous compaction may have produced too many files in a level,
  // so reschedule another compaction if needed.
  MaybeScheduleCompaction();
  bg_cv_.SignalAll();
}",31,,667,1,,void
11391,BLOCK,-1,,"{
    // No more background work when shutting down.
  }",38,,670,2,,void
11393,BLOCK,-1,,<empty>,10,,672,1,,void
11400,BLOCK,-1,,"{
    // No more background work after a background error.
  }",31,,672,2,,void
11402,BLOCK,-1,,"{
    BackgroundCompaction();
  }",10,,674,1,,void
11415,BLOCK,-1,,"{
  mutex_.AssertHeld();

  if (imm_ != NULL) {
    CompactMemTable();
    return;
  }

  Compaction* c;
  bool is_manual = (manual_compaction_ != NULL);
  InternalKey manual_end;
  if (is_manual) {
    ManualCompaction* m = manual_compaction_;
    c = versions_->CompactRange(m->level, m->begin, m->end);
    m->done = (c == NULL);
    if (c != NULL) {
      manual_end = c->input(0, c->num_input_files(0) - 1)->largest;
    }
    Log(options_.info_log,
        ""Manual compaction at level-%d from %s .. %s; will stop at %s\n"",
        m->level,
        (m->begin ? m->begin->DebugString().c_str() : ""(begin)""),
        (m->end ? m->end->DebugString().c_str() : ""(end)""),
        (m->done ? ""(end)"" : manual_end.DebugString().c_str()));
  } else {
    c = versions_->PickCompaction();
  }

  Status status;
  if (c == NULL) {
    // Nothing to do
  } else if (!is_manual && c->IsTrivialMove()) {
    // Move file to next level
    assert(c->num_input_files(0) == 1);
    FileMetaData* f = c->inpu...",37,,686,1,,void
11424,BLOCK,-1,,"{
    CompactMemTable();
    return;
  }",21,,689,2,,void
11437,BLOCK,-1,,"{
    ManualCompaction* m = manual_compaction_;
    c = versions_->CompactRange(m->level, m->begin, m->end);
    m->done = (c == NULL);
    if (c != NULL) {
      manual_end = c->input(0, c->num_input_files(0) - 1)->largest;
    }
    Log(options_.info_log,
        ""Manual compaction at level-%d from %s .. %s; will stop at %s\n"",
        m->level,
        (m->begin ? m->begin->DebugString().c_str() : ""(begin)""),
        (m->end ? m->end->DebugString().c_str() : ""(end)""),
        (m->done ? ""(end)"" : manual_end.DebugString().c_str()));
  }",18,,697,2,,void
11468,BLOCK,-1,,"{
      manual_end = c->input(0, c->num_input_files(0) - 1)->largest;
    }",20,,701,2,,void
11534,BLOCK,-1,,"{
    c = versions_->PickCompaction();
  }",10,,710,1,,void
11546,BLOCK,-1,,"{
    // Nothing to do
  }",18,,715,2,,void
11548,BLOCK,-1,,<empty>,10,,717,1,,void
11557,BLOCK,-1,,"{
    // Move file to next level
    assert(c->num_input_files(0) == 1);
    FileMetaData* f = c->input(0, 0);
    c->edit()->DeleteFile(c->level(), f->number);
    c->edit()->AddFile(c->level() + 1, f->number, f->file_size,
                       f->smallest, f->largest);
    status = versions_->LogAndApply(c->edit(), &mutex_);
    if (!status.ok()) {
      RecordBackgroundError(status);
    }
    VersionSet::LevelSummaryStorage tmp;
    Log(options_.info_log, ""Moved #%lld to level-%d %lld bytes %s: %s\n"",
        static_cast<unsigned long long>(f->number),
        c->level() + 1,
        static_cast<unsigned long long>(f->file_size),
        status.ToString().c_str(),
        versions_->LevelSummary(&tmp));
  }",48,,717,2,,void
11632,BLOCK,-1,,"{
      RecordBackgroundError(status);
    }",23,,725,2,,void
11671,BLOCK,-1,,"{
    CompactionState* compact = new CompactionState(c);
    status = DoCompactionWork(compact);
    if (!status.ok()) {
      RecordBackgroundError(status);
    }
    CleanupCompaction(compact);
    c->ReleaseInputs();
    DeleteObsoleteFiles();
  }",10,,735,1,,void
11688,BLOCK,-1,,"{
      RecordBackgroundError(status);
    }",23,,738,2,,void
11705,BLOCK,-1,,"{
    // Done
  }",20,,747,2,,void
11707,BLOCK,-1,,<empty>,10,,749,1,,void
11713,BLOCK,-1,,"{
    // Ignore compaction errors found during shutting down
  }",45,,749,2,,void
11715,BLOCK,-1,,"{
    Log(options_.info_log,
        ""Compaction error: %s"", status.ToString().c_str());
  }",10,,751,1,,void
11730,BLOCK,-1,,"{
    ManualCompaction* m = manual_compaction_;
    if (!status.ok()) {
      m->done = true;
    }
    if (!m->done) {
      // We only compacted part of the requested range.  Update *m
      // to the range that is left to be compacted.
      m->tmp_storage = manual_end;
      m->begin = &m->tmp_storage;
    }
    manual_compaction_ = NULL;
  }",18,,756,2,,void
11741,BLOCK,-1,,"{
      m->done = true;
    }",23,,758,2,,void
11752,BLOCK,-1,,"{
      // We only compacted part of the requested range.  Update *m
      // to the range that is left to be compacted.
      m->tmp_storage = manual_end;
      m->begin = &m->tmp_storage;
    }",19,,761,2,,void
11773,BLOCK,-1,,"{
  mutex_.AssertHeld();
  if (compact->builder != NULL) {
    // May happen if we get a shutdown call in the middle of compaction
    compact->builder->Abandon();
    delete compact->builder;
  } else {
    assert(compact->outfile == NULL);
  }
  delete compact->outfile;
  for (size_t i = 0; i < compact->outputs.size(); i++) {
    const CompactionState::Output& out = compact->outputs[i];
    pending_outputs_.erase(out.number);
  }
  delete compact;
}",58,,771,2,,void
11784,BLOCK,-1,,"{
    // May happen if we get a shutdown call in the middle of compaction
    compact->builder->Abandon();
    delete compact->builder;
  }",33,,773,2,,void
11796,BLOCK,-1,,"{
    assert(compact->outfile == NULL);
  }",10,,777,1,,void
11808,BLOCK,-1,,<empty>,3,,781,1,,void
11823,BLOCK,4,,"{
    const CompactionState::Output& out = compact->outputs[i];
    pending_outputs_.erase(out.number);
  }",56,,781,4,,void
11845,BLOCK,-1,,"{
  assert(compact != NULL);
  assert(compact->builder == NULL);
  uint64_t file_number;
  {
    mutex_.Lock();
    file_number = versions_->NewFileNumber();
    pending_outputs_.insert(file_number);
    CompactionState::Output out;
    out.number = file_number;
    out.smallest.Clear();
    out.largest.Clear();
    compact->outputs.push_back(out);
    mutex_.Unlock();
  }

  // Make the output file
  std::string fname = TableFileName(dbname_, file_number);
  Status s = env_->NewWritableFile(fname, &compact->outfile);
  if (s.ok()) {
    compact->builder = new TableBuilder(options_, compact->outfile);
  }
  return s;
}",67,,788,2,,void
11857,BLOCK,4,,"{
    mutex_.Lock();
    file_number = versions_->NewFileNumber();
    pending_outputs_.insert(file_number);
    CompactionState::Output out;
    out.number = file_number;
    out.smallest.Clear();
    out.largest.Clear();
    compact->outputs.push_back(out);
    mutex_.Unlock();
  }",3,,792,4,,void
11925,BLOCK,-1,,"{
    compact->builder = new TableBuilder(options_, compact->outfile);
  }",15,,807,2,,void
11943,BLOCK,-1,,"{
  assert(compact != NULL);
  assert(compact->outfile != NULL);
  assert(compact->builder != NULL);

  const uint64_t output_number = compact->current_output()->number;
  assert(output_number != 0);

  // Check for iterator errors
  Status s = input->status();
  const uint64_t current_entries = compact->builder->NumEntries();
  if (s.ok()) {
    s = compact->builder->Finish();
  } else {
    compact->builder->Abandon();
  }
  const uint64_t current_bytes = compact->builder->FileSize();
  compact->current_output()->file_size = current_bytes;
  compact->total_bytes += current_bytes;
  delete compact->builder;
  compact->builder = NULL;

  // Finish and check for file errors
  if (s.ok()) {
    s = compact->outfile->Sync();
  }
  if (s.ok()) {
    s = compact->outfile->Close();
  }
  delete compact->outfile;
  compact->outfile = NULL;

  if (s.ok() && current_entries > 0) {
    // Verify that the table is usable
    Iterator* iter = table_cache_->NewIterator(ReadOptions(),
           ...",60,,814,3,,void
11994,BLOCK,-1,,"{
    s = compact->builder->Finish();
  }",15,,825,2,,void
12004,BLOCK,-1,,"{
    compact->builder->Abandon();
  }",10,,827,1,,void
12047,BLOCK,-1,,"{
    s = compact->outfile->Sync();
  }",15,,837,2,,void
12061,BLOCK,-1,,"{
    s = compact->outfile->Close();
  }",15,,840,2,,void
12088,BLOCK,-1,,"{
    // Verify that the table is usable
    Iterator* iter = table_cache_->NewIterator(ReadOptions(),
                                               output_number,
                                               current_bytes);
    s = iter->status();
    delete iter;
    if (s.ok()) {
      Log(options_.info_log,
          ""Generated table #%llu@%d: %lld keys, %lld bytes"",
          (unsigned long long) output_number,
          compact->compaction->level(),
          (unsigned long long) current_entries,
          (unsigned long long) current_bytes);
    }
  }",38,,846,2,,void
12112,BLOCK,-1,,"{
      Log(options_.info_log,
          ""Generated table #%llu@%d: %lld keys, %lld bytes"",
          (unsigned long long) output_number,
          compact->compaction->level(),
          (unsigned long long) current_entries,
          (unsigned long long) current_bytes);
    }",17,,853,2,,void
12139,BLOCK,-1,,"{
  mutex_.AssertHeld();
  Log(options_.info_log,  ""Compacted %d@%d + %d@%d files => %lld bytes"",
      compact->compaction->num_input_files(0),
      compact->compaction->level(),
      compact->compaction->num_input_files(1),
      compact->compaction->level() + 1,
      static_cast<long long>(compact->total_bytes));

  // Add compaction outputs
  compact->compaction->AddInputDeletions(compact->compaction->edit());
  const int level = compact->compaction->level();
  for (size_t i = 0; i < compact->outputs.size(); i++) {
    const CompactionState::Output& out = compact->outputs[i];
    compact->compaction->edit()->AddFile(
        level + 1,
        out.number, out.file_size, out.smallest, out.largest);
  }
  return versions_->LogAndApply(compact->compaction->edit(), &mutex_);
}",67,,866,2,,void
12204,BLOCK,-1,,<empty>,3,,878,1,,void
12219,BLOCK,4,,"{
    const CompactionState::Output& out = compact->outputs[i];
    compact->compaction->edit()->AddFile(
        level + 1,
        out.number, out.file_size, out.smallest, out.largest);
  }",56,,878,4,,void
12269,BLOCK,-1,,"{
  const uint64_t start_micros = env_->NowMicros();
  int64_t imm_micros = 0;  // Micros spent doing imm_ compactions

  Log(options_.info_log,  ""Compacting %d@%d + %d@%d files"",
      compact->compaction->num_input_files(0),
      compact->compaction->level(),
      compact->compaction->num_input_files(1),
      compact->compaction->level() + 1);

  assert(versions_->NumLevelFiles(compact->compaction->level()) > 0);
  assert(compact->builder == NULL);
  assert(compact->outfile == NULL);
  if (snapshots_.empty()) {
    compact->smallest_snapshot = versions_->LastSequence();
  } else {
    compact->smallest_snapshot = snapshots_.oldest()->number_;
  }

  // Release mutex while we're actually doing the compaction work
  mutex_.Unlock();

  Iterator* input = versions_->MakeInputIterator(compact->compaction);
  input->SeekToFirst();
  Status status;
  ParsedInternalKey ikey;
  std::string current_user_key;
  bool has_current_user_key = false;
  SequenceNumber last_sequence_for_key = kM...",59,,887,2,,void
12344,BLOCK,-1,,"{
    compact->smallest_snapshot = versions_->LastSequence();
  }",27,,900,2,,void
12354,BLOCK,-1,,"{
    compact->smallest_snapshot = snapshots_.oldest()->number_;
  }",10,,902,1,,void
12395,BLOCK,-1,,<empty>,3,,916,1,,void
12406,BLOCK,4,,"{
    // Prioritize immutable compaction work
    if (has_imm_.NoBarrier_Load() != NULL) {
      const uint64_t imm_start = env_->NowMicros();
      mutex_.Lock();
      if (imm_ != NULL) {
        CompactMemTable();
        bg_cv_.SignalAll();  // Wakeup MakeRoomForWrite() if necessary
      }
      mutex_.Unlock();
      imm_micros += (env_->NowMicros() - imm_start);
    }

    Slice key = input->key();
    if (compact->compaction->ShouldStopBefore(key) &&
        compact->builder != NULL) {
      status = FinishCompactionOutputFile(compact, input);
      if (!status.ok()) {
        break;
      }
    }

    // Handle key/value, add to state, etc.
    bool drop = false;
    if (!ParseInternalKey(key, &ikey)) {
      // Do not hide error keys
      current_user_key.clear();
      has_current_user_key = false;
      last_sequence_for_key = kMaxSequenceNumber;
    } else {
      if (!has_current_user_key ||
          user_comparator()->Compare(ikey.user_key,
                         ...",62,,916,4,,void
12414,BLOCK,-1,,"{
      const uint64_t imm_start = env_->NowMicros();
      mutex_.Lock();
      if (imm_ != NULL) {
        CompactMemTable();
        bg_cv_.SignalAll();  // Wakeup MakeRoomForWrite() if necessary
      }
      mutex_.Unlock();
      imm_micros += (env_->NowMicros() - imm_start);
    }",44,,918,2,,void
12430,BLOCK,-1,,"{
        CompactMemTable();
        bg_cv_.SignalAll();  // Wakeup MakeRoomForWrite() if necessary
      }",25,,921,2,,void
12469,BLOCK,-1,,"{
      status = FinishCompactionOutputFile(compact, input);
      if (!status.ok()) {
        break;
      }
    }",35,,931,2,,void
12481,BLOCK,-1,,"{
        break;
      }",25,,933,2,,void
12493,BLOCK,-1,,"{
      // Do not hide error keys
      current_user_key.clear();
      has_current_user_key = false;
      last_sequence_for_key = kMaxSequenceNumber;
    }",40,,940,2,,void
12505,BLOCK,-1,,"{
      if (!has_current_user_key ||
          user_comparator()->Compare(ikey.user_key,
                                     Slice(current_user_key)) != 0) {
        // First occurrence of this user key
        current_user_key.assign(ikey.user_key.data(), ikey.user_key.size());
        has_current_user_key = true;
        last_sequence_for_key = kMaxSequenceNumber;
      }

      if (last_sequence_for_key <= compact->smallest_snapshot) {
        // Hidden by an newer entry for same user key
        drop = true;    // (A)
      } else if (ikey.type == kTypeDeletion &&
                 ikey.sequence <= compact->smallest_snapshot &&
                 compact->compaction->IsBaseLevelForKey(ikey.user_key)) {
        // For this user key:
        // (1) there is no data in higher levels
        // (2) data in lower levels will have larger sequence numbers
        // (3) data in layers that are being compacted here and have
        //     smaller sequence numbers will be dropped in the ne...",12,,945,1,,void
12521,BLOCK,-1,,"{
        // First occurrence of this user key
        current_user_key.assign(ikey.user_key.data(), ikey.user_key.size());
        has_current_user_key = true;
        last_sequence_for_key = kMaxSequenceNumber;
      }",69,,948,2,,void
12550,BLOCK,-1,,"{
        // Hidden by an newer entry for same user key
        drop = true;    // (A)
      }",64,,955,2,,void
12555,BLOCK,-1,,<empty>,14,,958,1,,void
12580,BLOCK,-1,,"{
        // For this user key:
        // (1) there is no data in higher levels
        // (2) data in lower levels will have larger sequence numbers
        // (3) data in layers that are being compacted here and have
        //     smaller sequence numbers will be dropped in the next
        //     few iterations of this loop (by rule (A) above).
        // Therefore this deletion marker is obsolete and can be dropped.
        drop = true;
      }",73,,960,2,,void
12592,BLOCK,-1,,"{
      // Open output file if necessary
      if (compact->builder == NULL) {
        status = OpenCompactionOutputFile(compact);
        if (!status.ok()) {
          break;
        }
      }
      if (compact->builder->NumEntries() == 0) {
        compact->current_output()->smallest.DecodeFrom(key);
      }
      compact->current_output()->largest.DecodeFrom(key);
      compact->builder->Add(key, input->value());

      // Close output file if it is big enough
      if (compact->builder->FileSize() >=
          compact->compaction->MaxOutputFileSize()) {
        status = FinishCompactionOutputFile(compact, input);
        if (!status.ok()) {
          break;
        }
      }
    }",16,,983,2,,void
12599,BLOCK,-1,,"{
        status = OpenCompactionOutputFile(compact);
        if (!status.ok()) {
          break;
        }
      }",37,,985,2,,void
12610,BLOCK,-1,,"{
          break;
        }",27,,987,2,,void
12621,BLOCK,-1,,"{
        compact->current_output()->smallest.DecodeFrom(key);
      }",48,,991,2,,void
12667,BLOCK,-1,,"{
        status = FinishCompactionOutputFile(compact, input);
        if (!status.ok()) {
          break;
        }
      }",53,,999,2,,void
12679,BLOCK,-1,,"{
          break;
        }",27,,1001,2,,void
12695,BLOCK,-1,,"{
    status = Status::IOError(""Deleting DB during compaction"");
  }",53,,1010,2,,void
12714,BLOCK,-1,,"{
    status = FinishCompactionOutputFile(compact, input);
  }",48,,1013,2,,void
12725,BLOCK,-1,,"{
    status = input->status();
  }",20,,1016,2,,void
12751,BLOCK,-1,,<empty>,3,,1024,1,,void
12761,BLOCK,4,,"{
    for (int i = 0; i < compact->compaction->num_input_files(which); i++) {
      stats.bytes_read += compact->compaction->input(which, i)->file_size;
    }
  }",43,,1024,4,,void
12763,BLOCK,-1,,<empty>,5,,1025,1,,void
12779,BLOCK,4,,"{
      stats.bytes_read += compact->compaction->input(which, i)->file_size;
    }",75,,1025,4,,void
12795,BLOCK,-1,,<empty>,3,,1029,1,,void
12810,BLOCK,4,,"{
    stats.bytes_written += compact->outputs[i].file_size;
  }",56,,1029,4,,void
12845,BLOCK,-1,,"{
    status = InstallCompactionResults(compact);
  }",20,,1036,2,,void
12856,BLOCK,-1,,"{
    RecordBackgroundError(status);
  }",21,,1039,2,,void
12884,BLOCK,-1,,"{
  IterState* state = reinterpret_cast<IterState*>(arg1);
  state->mu->Lock();
  state->mem->Unref();
  if (state->imm != NULL) state->imm->Unref();
  state->version->Unref();
  state->mu->Unlock();
  delete state;
}",58,,1056,3,,void
12909,BLOCK,-1,,<empty>,27,,1060,2,,void
12936,BLOCK,-1,,"{
  IterState* cleanup = new IterState;
  mutex_.Lock();
  *latest_snapshot = versions_->LastSequence();

  // Collect together all needed child iterators
  std::vector<Iterator*> list;
  list.push_back(mem_->NewIterator());
  mem_->Ref();
  if (imm_ != NULL) {
    list.push_back(imm_->NewIterator());
    imm_->Ref();
  }
  versions_->current()->AddIterators(options, &list);
  Iterator* internal_iter =
      NewMergingIterator(&internal_comparator_, &list[0], list.size());
  versions_->current()->Ref();

  cleanup->mu = &mutex_;
  cleanup->mem = mem_;
  cleanup->imm = imm_;
  cleanup->version = versions_->current();
  internal_iter->RegisterCleanup(CleanupIteratorState, cleanup, NULL);

  *seed = ++seed_;
  mutex_.Unlock();
  return internal_iter;
}",55,,1069,4,,void
12970,BLOCK,-1,,"{
    list.push_back(imm_->NewIterator());
    imm_->Ref();
  }",21,,1078,2,,void
13059,BLOCK,-1,,"{
  SequenceNumber ignored;
  uint32_t ignored_seed;
  return NewInternalIterator(ReadOptions(), &ignored, &ignored_seed);
}",46,,1098,1,,void
13072,BLOCK,-1,,"{
  MutexLock l(&mutex_);
  return versions_->MaxNextLevelOverlappingBytes();
}",53,,1104,1,,void
13088,BLOCK,-1,,"{
  Status s;
  MutexLock l(&mutex_);
  SequenceNumber snapshot;
  if (options.snapshot != NULL) {
    snapshot = reinterpret_cast<const SnapshotImpl*>(options.snapshot)->number_;
  } else {
    snapshot = versions_->LastSequence();
  }

  MemTable* mem = mem_;
  MemTable* imm = imm_;
  Version* current = versions_->current();
  mem->Ref();
  if (imm != NULL) imm->Ref();
  current->Ref();

  bool have_stat_update = false;
  Version::GetStats stats;

  // Unlock while reading from files and memtables
  {
    mutex_.Unlock();
    // First look in the memtable, then in the immutable memtable (if any).
    LookupKey lkey(key, snapshot);
    if (mem->Get(lkey, value, &s)) {
      // Done
    } else if (imm != NULL && imm->Get(lkey, value, &s)) {
      // Done
    } else {
      s = current->Get(options, lkey, value, &stats);
      have_stat_update = true;
    }
    mutex_.Lock();
  }

  if (have_stat_update && current->UpdateStats(stats)) {
    MaybeScheduleCompaction();
  }
  mem->Unref...",40,,1111,4,,void
13101,BLOCK,-1,,"{
    snapshot = reinterpret_cast<const SnapshotImpl*>(options.snapshot)->number_;
  }",33,,1115,2,,void
13112,BLOCK,-1,,"{
    snapshot = versions_->LastSequence();
  }",10,,1117,1,,void
13142,BLOCK,-1,,<empty>,20,,1125,2,,void
13156,BLOCK,18,,"{
    mutex_.Unlock();
    // First look in the memtable, then in the immutable memtable (if any).
    LookupKey lkey(key, snapshot);
    if (mem->Get(lkey, value, &s)) {
      // Done
    } else if (imm != NULL && imm->Get(lkey, value, &s)) {
      // Done
    } else {
      s = current->Get(options, lkey, value, &stats);
      have_stat_update = true;
    }
    mutex_.Lock();
  }",3,,1132,18,,void
13174,BLOCK,-1,,"{
      // Done
    }",36,,1136,2,,void
13176,BLOCK,-1,,<empty>,12,,1138,1,,void
13190,BLOCK,-1,,"{
      // Done
    }",58,,1138,2,,void
13192,BLOCK,-1,,"{
      s = current->Get(options, lkey, value, &stats);
      have_stat_update = true;
    }",12,,1140,1,,void
13219,BLOCK,-1,,"{
    MaybeScheduleCompaction();
  }",56,,1147,2,,void
13229,BLOCK,-1,,<empty>,20,,1151,2,,void
13244,BLOCK,-1,,"{
  SequenceNumber latest_snapshot;
  uint32_t seed;
  Iterator* iter = NewInternalIterator(options, &latest_snapshot, &seed);
  return NewDBIterator(
      this, user_comparator(), iter,
      (options.snapshot != NULL
       ? reinterpret_cast<const SnapshotImpl*>(options.snapshot)->number_
       : latest_snapshot),
      seed);
}",59,,1156,2,,void
13280,BLOCK,-1,,"{
  MutexLock l(&mutex_);
  if (versions_->current()->RecordReadSample(key)) {
    MaybeScheduleCompaction();
  }
}",42,,1168,2,,void
13294,BLOCK,-1,,"{
    MaybeScheduleCompaction();
  }",52,,1170,2,,void
13299,BLOCK,-1,,"{
  MutexLock l(&mutex_);
  return snapshots_.New(versions_->LastSequence());
}",39,,1175,1,,void
13317,BLOCK,-1,,"{
  MutexLock l(&mutex_);
  snapshots_.Delete(reinterpret_cast<const SnapshotImpl*>(s));
}",49,,1180,2,,void
13335,BLOCK,-1,,"{
  return DB::Put(o, key, val);
}",79,,1186,4,,void
13349,BLOCK,-1,,"{
  return DB::Delete(options, key);
}",70,,1190,3,,void
13362,BLOCK,-1,,"{
  Writer w(&mutex_);
  w.batch = my_batch;
  w.sync = options.sync;
  w.done = false;

  MutexLock l(&mutex_);
  writers_.push_back(&w);
  while (!w.done && &w != writers_.front()) {
    w.cv.Wait();
  }
  if (w.done) {
    return w.status;
  }

  // May temporarily unlock and wait.
  Status status = MakeRoomForWrite(my_batch == NULL);
  uint64_t last_sequence = versions_->LastSequence();
  Writer* last_writer = &w;
  if (status.ok() && my_batch != NULL) {  // NULL batch is for compactions
    WriteBatch* updates = BuildBatchGroup(&last_writer);
    WriteBatchInternal::SetSequence(updates, last_sequence + 1);
    last_sequence += WriteBatchInternal::Count(updates);

    // Add to log and apply to memtable.  We can release the lock
    // during this phase since &w is currently responsible for logging
    // and protects against concurrent loggers and concurrent writes
    // into mem_.
    {
      mutex_.Unlock();
      status = log_->AddRecord(WriteBatchInternal::Contents(updates...",73,,1194,3,,void
13407,BLOCK,-1,,"{
    w.cv.Wait();
  }",45,,1202,2,,void
13418,BLOCK,-1,,"{
    return w.status;
  }",15,,1205,2,,void
13451,BLOCK,-1,,"{  // NULL batch is for compactions
    WriteBatch* updates = BuildBatchGroup(&last_writer);
    WriteBatchInternal::SetSequence(updates, last_sequence + 1);
    last_sequence += WriteBatchInternal::Count(updates);

    // Add to log and apply to memtable.  We can release the lock
    // during this phase since &w is currently responsible for logging
    // and protects against concurrent loggers and concurrent writes
    // into mem_.
    {
      mutex_.Unlock();
      status = log_->AddRecord(WriteBatchInternal::Contents(updates));
      bool sync_error = false;
      if (status.ok() && options.sync) {
        status = logfile_->Sync();
        if (!status.ok()) {
          sync_error = true;
        }
      }
      if (status.ok()) {
        status = WriteBatchInternal::InsertInto(updates, mem_);
      }
      mutex_.Lock();
      if (sync_error) {
        // The state of the log file is indeterminate: the log record we
        // just added may or may not show up when the DB is ...",40,,1213,2,,void
13473,BLOCK,5,,"{
      mutex_.Unlock();
      status = log_->AddRecord(WriteBatchInternal::Contents(updates));
      bool sync_error = false;
      if (status.ok() && options.sync) {
        status = logfile_->Sync();
        if (!status.ok()) {
          sync_error = true;
        }
      }
      if (status.ok()) {
        status = WriteBatchInternal::InsertInto(updates, mem_);
      }
      mutex_.Lock();
      if (sync_error) {
        // The state of the log file is indeterminate: the log record we
        // just added may or may not show up when the DB is re-opened.
        // So we force the DB into a mode where all future writes fail.
        RecordBackgroundError(status);
      }
    }",5,,1222,5,,void
13502,BLOCK,-1,,"{
        status = logfile_->Sync();
        if (!status.ok()) {
          sync_error = true;
        }
      }",40,,1226,2,,void
13515,BLOCK,-1,,"{
          sync_error = true;
        }",27,,1228,2,,void
13524,BLOCK,-1,,"{
        status = WriteBatchInternal::InsertInto(updates, mem_);
      }",24,,1232,2,,void
13539,BLOCK,-1,,"{
        // The state of the log file is indeterminate: the log record we
        // just added may or may not show up when the DB is re-opened.
        // So we force the DB into a mode where all future writes fail.
        RecordBackgroundError(status);
      }",23,,1236,2,,void
13546,BLOCK,-1,,<empty>,32,,1243,2,,void
13558,BLOCK,-1,,"{
    Writer* ready = writers_.front();
    writers_.pop_front();
    if (ready != &w) {
      ready->status = status;
      ready->done = true;
      ready->cv.Signal();
    }
    if (ready == last_writer) break;
  }",16,,1248,2,,void
13575,BLOCK,-1,,"{
      ready->status = status;
      ready->done = true;
      ready->cv.Signal();
    }",22,,1251,2,,void
13596,BLOCK,-1,,<empty>,31,,1256,2,,void
13604,BLOCK,-1,,"{
    writers_.front()->cv.Signal();
  }",26,,1260,2,,void
13620,BLOCK,-1,,"{
  assert(!writers_.empty());
  Writer* first = writers_.front();
  WriteBatch* result = first->batch;
  assert(result != NULL);

  size_t size = WriteBatchInternal::ByteSize(first->batch);

  // Allow the group to grow up to a maximum size, but if the
  // original write is small, limit the growth so we do not slow
  // down the small write too much.
  size_t max_size = 1 << 20;
  if (size <= (128<<10)) {
    max_size = size + (128<<10);
  }

  *last_writer = first;
  std::deque<Writer*>::iterator iter = writers_.begin();
  ++iter;  // Advance past ""first""
  for (; iter != writers_.end(); ++iter) {
    Writer* w = *iter;
    if (w->sync && !first->sync) {
      // Do not include a sync write into a batch handled by a non-sync write.
      break;
    }

    if (w->batch != NULL) {
      size += WriteBatchInternal::ByteSize(w->batch);
      if (size > max_size) {
        // Do not make batch too big
        break;
      }

      // Append to *result
      if (result == first->batch)...",59,,1269,2,,void
13666,BLOCK,-1,,"{
    max_size = size + (128<<10);
  }",26,,1281,2,,void
13688,BLOCK,-1,,<empty>,3,,1288,1,,void
13697,BLOCK,4,,"{
    Writer* w = *iter;
    if (w->sync && !first->sync) {
      // Do not include a sync write into a batch handled by a non-sync write.
      break;
    }

    if (w->batch != NULL) {
      size += WriteBatchInternal::ByteSize(w->batch);
      if (size > max_size) {
        // Do not make batch too big
        break;
      }

      // Append to *result
      if (result == first->batch) {
        // Switch to temporary batch instead of disturbing caller's batch
        result = tmp_batch_;
        assert(WriteBatchInternal::Count(result) == 0);
        WriteBatchInternal::Append(result, first->batch);
      }
      WriteBatchInternal::Append(result, w->batch);
    }
    *last_writer = w;
  }",42,,1288,4,,void
13712,BLOCK,-1,,"{
      // Do not include a sync write into a batch handled by a non-sync write.
      break;
    }",34,,1290,2,,void
13720,BLOCK,-1,,"{
      size += WriteBatchInternal::ByteSize(w->batch);
      if (size > max_size) {
        // Do not make batch too big
        break;
      }

      // Append to *result
      if (result == first->batch) {
        // Switch to temporary batch instead of disturbing caller's batch
        result = tmp_batch_;
        assert(WriteBatchInternal::Count(result) == 0);
        WriteBatchInternal::Append(result, first->batch);
      }
      WriteBatchInternal::Append(result, w->batch);
    }",27,,1295,2,,void
13734,BLOCK,-1,,"{
        // Do not make batch too big
        break;
      }",28,,1297,2,,void
13742,BLOCK,-1,,"{
        // Switch to temporary batch instead of disturbing caller's batch
        result = tmp_batch_;
        assert(WriteBatchInternal::Count(result) == 0);
        WriteBatchInternal::Append(result, first->batch);
      }",35,,1303,2,,void
13780,BLOCK,-1,,"{
  mutex_.AssertHeld();
  assert(!writers_.empty());
  bool allow_delay = !force;
  Status s;
  while (true) {
    if (!bg_error_.ok()) {
      // Yield previous error
      s = bg_error_;
      break;
    } else if (
        allow_delay &&
        versions_->NumLevelFiles(0) >= config::kL0_SlowdownWritesTrigger) {
      // We are getting close to hitting a hard limit on the number of
      // L0 files.  Rather than delaying a single write by several
      // seconds when we hit the hard limit, start delaying each
      // individual write by 1ms to reduce latency variance.  Also,
      // this delay hands over some CPU to the compaction thread in
      // case it is sharing the same core as the writer.
      mutex_.Unlock();
      env_->SleepForMicroseconds(1000);
      allow_delay = false;  // Do not delay a single write more than once
      mutex_.Lock();
    } else if (!force &&
               (mem_->ApproximateMemoryUsage() <= options_.write_buffer_size)) {
      // There is r...",45,,1318,2,,void
13799,BLOCK,-1,,"{
    if (!bg_error_.ok()) {
      // Yield previous error
      s = bg_error_;
      break;
    } else if (
        allow_delay &&
        versions_->NumLevelFiles(0) >= config::kL0_SlowdownWritesTrigger) {
      // We are getting close to hitting a hard limit on the number of
      // L0 files.  Rather than delaying a single write by several
      // seconds when we hit the hard limit, start delaying each
      // individual write by 1ms to reduce latency variance.  Also,
      // this delay hands over some CPU to the compaction thread in
      // case it is sharing the same core as the writer.
      mutex_.Unlock();
      env_->SleepForMicroseconds(1000);
      allow_delay = false;  // Do not delay a single write more than once
      mutex_.Lock();
    } else if (!force &&
               (mem_->ApproximateMemoryUsage() <= options_.write_buffer_size)) {
      // There is room in current memtable
      break;
    } else if (imm_ != NULL) {
      // We have filled up the current mem...",16,,1323,2,,void
13806,BLOCK,-1,,"{
      // Yield previous error
      s = bg_error_;
      break;
    }",26,,1324,2,,void
13812,BLOCK,-1,,<empty>,12,,1328,1,,void
13825,BLOCK,-1,,"{
      // We are getting close to hitting a hard limit on the number of
      // L0 files.  Rather than delaying a single write by several
      // seconds when we hit the hard limit, start delaying each
      // individual write by 1ms to reduce latency variance.  Also,
      // this delay hands over some CPU to the compaction thread in
      // case it is sharing the same core as the writer.
      mutex_.Unlock();
      env_->SleepForMicroseconds(1000);
      allow_delay = false;  // Do not delay a single write more than once
      mutex_.Lock();
    }",75,,1330,2,,void
13843,BLOCK,-1,,<empty>,12,,1341,1,,void
13856,BLOCK,-1,,"{
      // There is room in current memtable
      break;
    }",80,,1342,2,,void
13859,BLOCK,-1,,<empty>,12,,1345,1,,void
13864,BLOCK,-1,,"{
      // We have filled up the current memtable, but the previous
      // one is still being compacted, so we wait.
      Log(options_.info_log, ""Current memtable full; waiting...\n"");
      bg_cv_.Wait();
    }",30,,1345,2,,void
13875,BLOCK,-1,,<empty>,12,,1350,1,,void
13886,BLOCK,-1,,"{
      // There are too many level-0 files.
      Log(options_.info_log, ""Too many L0 files; waiting...\n"");
      bg_cv_.Wait();
    }",78,,1350,2,,void
13897,BLOCK,-1,,"{
      // Attempt to switch to a new memtable and trigger compaction of old
      assert(versions_->PrevLogNumber() == 0);
      uint64_t new_log_number = versions_->NewFileNumber();
      WritableFile* lfile = NULL;
      s = env_->NewWritableFile(LogFileName(dbname_, new_log_number), &lfile);
      if (!s.ok()) {
        // Avoid chewing through file number space in a tight loop.
        versions_->ReuseFileNumber(new_log_number);
        break;
      }
      delete log_;
      delete logfile_;
      logfile_ = lfile;
      logfile_number_ = new_log_number;
      log_ = new log::Writer(lfile);
      imm_ = mem_;
      has_imm_.Release_Store(imm_);
      mem_ = new MemTable(internal_comparator_);
      mem_->Ref();
      force = false;   // Do not force another compaction if have room
      MaybeScheduleCompaction();
    }",12,,1354,1,,void
13933,BLOCK,-1,,"{
        // Avoid chewing through file number space in a tight loop.
        versions_->ReuseFileNumber(new_log_number);
        break;
      }",20,,1360,2,,void
13983,BLOCK,-1,,"{
  value->clear();

  MutexLock l(&mutex_);
  Slice in = property;
  Slice prefix(""leveldb."");
  if (!in.starts_with(prefix)) return false;
  in.remove_prefix(prefix.size());

  if (in.starts_with(""num-files-at-level"")) {
    in.remove_prefix(strlen(""num-files-at-level""));
    uint64_t level;
    bool ok = ConsumeDecimalNumber(&in, &level) && in.empty();
    if (!ok || level >= config::kNumLevels) {
      return false;
    } else {
      char buf[100];
      snprintf(buf, sizeof(buf), ""%d"",
               versions_->NumLevelFiles(static_cast<int>(level)));
      *value = buf;
      return true;
    }
  } else if (in == ""stats"") {
    char buf[200];
    snprintf(buf, sizeof(buf),
             ""                               Compactions\n""
             ""Level  Files Size(MB) Time(sec) Read(MB) Write(MB)\n""
             ""--------------------------------------------------\n""
             );
    value->append(buf);
    for (int level = 0; level < config::kNumLevels; level++) {
      int...",69,,1381,3,,void
14006,BLOCK,-1,,<empty>,32,,1387,2,,void
14023,BLOCK,-1,,"{
    in.remove_prefix(strlen(""num-files-at-level""));
    uint64_t level;
    bool ok = ConsumeDecimalNumber(&in, &level) && in.empty();
    if (!ok || level >= config::kNumLevels) {
      return false;
    } else {
      char buf[100];
      snprintf(buf, sizeof(buf), ""%d"",
               versions_->NumLevelFiles(static_cast<int>(level)));
      *value = buf;
      return true;
    }
  }",45,,1390,2,,void
14053,BLOCK,-1,,"{
      return false;
    }",45,,1394,2,,void
14057,BLOCK,-1,,"{
      char buf[100];
      snprintf(buf, sizeof(buf), ""%d"",
               versions_->NumLevelFiles(static_cast<int>(level)));
      *value = buf;
      return true;
    }",12,,1396,1,,void
14078,BLOCK,-1,,<empty>,10,,1403,1,,void
14083,BLOCK,-1,,"{
    char buf[200];
    snprintf(buf, sizeof(buf),
             ""                               Compactions\n""
             ""Level  Files Size(MB) Time(sec) Read(MB) Write(MB)\n""
             ""--------------------------------------------------\n""
             );
    value->append(buf);
    for (int level = 0; level < config::kNumLevels; level++) {
      int files = versions_->NumLevelFiles(level);
      if (stats_[level].micros > 0 || files > 0) {
        snprintf(
            buf, sizeof(buf),
            ""%3d %8d %8.0f %9.0f %8.0f %9.0f\n"",
            level,
            files,
            versions_->NumLevelBytes(level) / 1048576.0,
            stats_[level].micros / 1e6,
            stats_[level].bytes_read / 1048576.0,
            stats_[level].bytes_written / 1048576.0);
        value->append(buf);
      }
    }
    return true;
  }",29,,1403,2,,void
14096,BLOCK,-1,,<empty>,5,,1411,1,,void
14108,BLOCK,4,,"{
      int files = versions_->NumLevelFiles(level);
      if (stats_[level].micros > 0 || files > 0) {
        snprintf(
            buf, sizeof(buf),
            ""%3d %8d %8.0f %9.0f %8.0f %9.0f\n"",
            level,
            files,
            versions_->NumLevelBytes(level) / 1048576.0,
            stats_[level].micros / 1e6,
            stats_[level].bytes_read / 1048576.0,
            stats_[level].bytes_written / 1048576.0);
        value->append(buf);
      }
    }",62,,1411,4,,void
14129,BLOCK,-1,,"{
        snprintf(
            buf, sizeof(buf),
            ""%3d %8d %8.0f %9.0f %8.0f %9.0f\n"",
            level,
            files,
            versions_->NumLevelBytes(level) / 1048576.0,
            stats_[level].micros / 1e6,
            stats_[level].bytes_read / 1048576.0,
            stats_[level].bytes_written / 1048576.0);
        value->append(buf);
      }",50,,1413,2,,void
14173,BLOCK,-1,,<empty>,10,,1427,1,,void
14178,BLOCK,-1,,"{
    *value = versions_->current()->DebugString();
    return true;
  }",32,,1427,2,,void
14192,BLOCK,-1,,<empty>,10,,1430,1,,void
14197,BLOCK,-1,,"{
    size_t total_usage = options_.block_cache->TotalCharge();
    if (mem_) {
      total_usage += mem_->ApproximateMemoryUsage();
    }
    if (imm_) {
      total_usage += imm_->ApproximateMemoryUsage();
    }
    char buf[50];
    snprintf(buf, sizeof(buf), ""%llu"",
             static_cast<unsigned long long>(total_usage));
    value->append(buf);
    return true;
  }",48,,1430,2,,void
14209,BLOCK,-1,,"{
      total_usage += mem_->ApproximateMemoryUsage();
    }",15,,1432,2,,void
14218,BLOCK,-1,,"{
      total_usage += imm_->ApproximateMemoryUsage();
    }",15,,1435,2,,void
14249,BLOCK,-1,,"{
  // TODO(opt): better implementation
  Version* v;
  {
    MutexLock l(&mutex_);
    versions_->current()->Ref();
    v = versions_->current();
  }

  for (int i = 0; i < n; i++) {
    // Convert user_key into a corresponding internal key.
    InternalKey k1(range[i].start, kMaxSequenceNumber, kValueTypeForSeek);
    InternalKey k2(range[i].limit, kMaxSequenceNumber, kValueTypeForSeek);
    uint64_t start = versions_->ApproximateOffsetOf(v, k1);
    uint64_t limit = versions_->ApproximateOffsetOf(v, k2);
    sizes[i] = (limit >= start ? limit - start : 0);
  }

  {
    MutexLock l(&mutex_);
    v->Unref();
  }
}",22,,1450,4,,void
14251,BLOCK,2,,"{
    MutexLock l(&mutex_);
    versions_->current()->Ref();
    v = versions_->current();
  }",3,,1453,2,,void
14270,BLOCK,-1,,<empty>,3,,1459,1,,void
14280,BLOCK,4,,"{
    // Convert user_key into a corresponding internal key.
    InternalKey k1(range[i].start, kMaxSequenceNumber, kValueTypeForSeek);
    InternalKey k2(range[i].limit, kMaxSequenceNumber, kValueTypeForSeek);
    uint64_t start = versions_->ApproximateOffsetOf(v, k1);
    uint64_t limit = versions_->ApproximateOffsetOf(v, k2);
    sizes[i] = (limit >= start ? limit - start : 0);
  }",31,,1459,4,,void
14329,BLOCK,4,,"{
    MutexLock l(&mutex_);
    v->Unref();
  }",3,,1468,4,,void
14344,BLOCK,-1,,"{
  WriteBatch batch;
  batch.Put(key, value);
  return Write(opt, &batch);
}",79,,1476,4,,void
14362,BLOCK,-1,,"{
  WriteBatch batch;
  batch.Delete(key);
  return Write(opt, &batch);
}",62,,1482,3,,void
14377,BLOCK,-1,,{ },11,,1488,1,,void
14384,BLOCK,-1,,"{
  *dbptr = NULL;

  DBImpl* impl = new DBImpl(options, dbname);
  impl->mutex_.Lock();
  VersionEdit edit;
  // Recover handles create_if_missing, error_if_exists
  bool save_manifest = false;
  Status s = impl->Recover(&edit, &save_manifest);
  if (s.ok() && impl->mem_ == NULL) {
    // Create new log and a corresponding memtable.
    uint64_t new_log_number = impl->versions_->NewFileNumber();
    WritableFile* lfile;
    s = options.env->NewWritableFile(LogFileName(dbname, new_log_number),
                                     &lfile);
    if (s.ok()) {
      edit.SetLogNumber(new_log_number);
      impl->logfile_ = lfile;
      impl->logfile_number_ = new_log_number;
      impl->log_ = new log::Writer(lfile);
      impl->mem_ = new MemTable(impl->internal_comparator_);
      impl->mem_->Ref();
    }
  }
  if (s.ok() && save_manifest) {
    edit.SetPrevLogNumber(0);  // No older logs needed after recovery.
    edit.SetLogNumber(impl->logfile_number_);
    s = impl->versions_->Log...",29,,1491,4,,void
14429,BLOCK,-1,,"{
    // Create new log and a corresponding memtable.
    uint64_t new_log_number = impl->versions_->NewFileNumber();
    WritableFile* lfile;
    s = options.env->NewWritableFile(LogFileName(dbname, new_log_number),
                                     &lfile);
    if (s.ok()) {
      edit.SetLogNumber(new_log_number);
      impl->logfile_ = lfile;
      impl->logfile_number_ = new_log_number;
      impl->log_ = new log::Writer(lfile);
      impl->mem_ = new MemTable(impl->internal_comparator_);
      impl->mem_->Ref();
    }
  }",37,,1500,2,,void
14458,BLOCK,-1,,"{
      edit.SetLogNumber(new_log_number);
      impl->logfile_ = lfile;
      impl->logfile_number_ = new_log_number;
      impl->log_ = new log::Writer(lfile);
      impl->mem_ = new MemTable(impl->internal_comparator_);
      impl->mem_->Ref();
    }",17,,1506,2,,void
14503,BLOCK,-1,,"{
    edit.SetPrevLogNumber(0);  // No older logs needed after recovery.
    edit.SetLogNumber(impl->logfile_number_);
    s = impl->versions_->LogAndApply(&edit, &impl->mutex_);
  }",32,,1515,2,,void
14535,BLOCK,-1,,"{
    impl->DeleteObsoleteFiles();
    impl->MaybeScheduleCompaction();
  }",15,,1520,2,,void
14555,BLOCK,-1,,"{
    assert(impl->mem_ != NULL);
    *dbptr = impl;
  }",15,,1525,2,,void
14567,BLOCK,-1,,"{
    delete impl;
  }",10,,1528,1,,void
14575,BLOCK,-1,,"{
}",23,,1534,1,,void
14581,BLOCK,-1,,"{
  Env* env = options.env;
  std::vector<std::string> filenames;
  // Ignore error in case directory does not exist
  env->GetChildren(dbname, &filenames);
  if (filenames.empty()) {
    return Status::OK();
  }

  FileLock* lock;
  const std::string lockname = LockFileName(dbname);
  Status result = env->LockFile(lockname, &lock);
  if (result.ok()) {
    uint64_t number;
    FileType type;
    for (size_t i = 0; i < filenames.size(); i++) {
      if (ParseFileName(filenames[i], &number, &type) &&
          type != kDBLockFile) {  // Lock file will be deleted at end
        Status del = env->DeleteFile(dbname + ""/"" + filenames[i]);
        if (result.ok() && !del.ok()) {
          result = del;
        }
      }
    }
    env->UnlockFile(lock);  // Ignore error since state is already gone
    env->DeleteFile(lockname);
    env->DeleteDir(dbname);  // Ignore error in case dir contains other files
  }
  return result;
}",69,,1537,3,,void
14609,BLOCK,-1,,"{
    return Status::OK();
  }",26,,1542,2,,void
14636,BLOCK,-1,,"{
    uint64_t number;
    FileType type;
    for (size_t i = 0; i < filenames.size(); i++) {
      if (ParseFileName(filenames[i], &number, &type) &&
          type != kDBLockFile) {  // Lock file will be deleted at end
        Status del = env->DeleteFile(dbname + ""/"" + filenames[i]);
        if (result.ok() && !del.ok()) {
          result = del;
        }
      }
    }
    env->UnlockFile(lock);  // Ignore error since state is already gone
    env->DeleteFile(lockname);
    env->DeleteDir(dbname);  // Ignore error in case dir contains other files
  }",20,,1549,2,,void
14640,BLOCK,-1,,<empty>,5,,1552,1,,void
14653,BLOCK,4,,"{
      if (ParseFileName(filenames[i], &number, &type) &&
          type != kDBLockFile) {  // Lock file will be deleted at end
        Status del = env->DeleteFile(dbname + ""/"" + filenames[i]);
        if (result.ok() && !del.ok()) {
          result = del;
        }
      }
    }",51,,1552,4,,void
14667,BLOCK,-1,,"{  // Lock file will be deleted at end
        Status del = env->DeleteFile(dbname + ""/"" + filenames[i]);
        if (result.ok() && !del.ok()) {
          result = del;
        }
      }",32,,1554,2,,void
14693,BLOCK,-1,,"{
          result = del;
        }",39,,1556,2,,void
14738,BLOCK,-1,,<empty>,1,,1,1,,ANY
14749,BLOCK,-1,,<empty>,,,,3,,<empty>
14753,BLOCK,-1,,<empty>,,,,1,,<empty>
14760,BLOCK,-1,,<empty>,,,,4,,<empty>
14766,BLOCK,-1,,<empty>,,,,3,,<empty>
14772,BLOCK,-1,,<empty>,,,,3,,<empty>
14779,BLOCK,-1,,<empty>,,,,4,,<empty>
14784,BLOCK,-1,,<empty>,,,,2,,<empty>
14788,BLOCK,-1,,<empty>,,,,1,,<empty>
14793,BLOCK,-1,,<empty>,,,,2,,<empty>
14799,BLOCK,-1,,<empty>,,,,3,,<empty>
14806,BLOCK,-1,,<empty>,,,,4,,<empty>
14812,BLOCK,-1,,<empty>,,,,3,,<empty>
14819,BLOCK,-1,,<empty>,,,,4,,<empty>
14823,BLOCK,-1,,<empty>,,,,1,,<empty>
14827,BLOCK,-1,,<empty>,,,,1,,<empty>
14831,BLOCK,-1,,<empty>,,,,1,,<empty>
14836,BLOCK,-1,,<empty>,,,,2,,<empty>
14846,BLOCK,-1,,<empty>,,,,4,,<empty>
14850,BLOCK,-1,,<empty>,,,,1,,<empty>
14856,BLOCK,-1,,<empty>,,,,3,,<empty>
14861,BLOCK,-1,,<empty>,,,,2,,<empty>
14865,BLOCK,-1,,<empty>,,,,1,,<empty>
14869,BLOCK,-1,,<empty>,,,,1,,<empty>
14878,BLOCK,-1,,<empty>,,,,6,,<empty>
14885,BLOCK,-1,,<empty>,,,,4,,<empty>
14890,BLOCK,-1,,<empty>,,,,2,,<empty>
14895,BLOCK,-1,,<empty>,,,,2,,<empty>
14900,BLOCK,-1,,<empty>,,,,2,,<empty>
14904,BLOCK,-1,,<empty>,,,,1,,<empty>
14909,BLOCK,-1,,<empty>,,,,2,,<empty>
14913,BLOCK,-1,,<empty>,,,,1,,<empty>
14917,BLOCK,-1,,<empty>,,,,1,,<empty>
14922,BLOCK,-1,,<empty>,,,,2,,<empty>
14927,BLOCK,-1,,<empty>,,,,2,,<empty>
14932,BLOCK,-1,,<empty>,,,,2,,<empty>
14938,BLOCK,-1,,<empty>,,,,3,,<empty>
14943,BLOCK,-1,,<empty>,,,,2,,<empty>
14984,BLOCK,-1,,{ },68,,183,1,,void
14989,BLOCK,-1,,"{
      this->micros += c.micros;
      this->bytes_read += c.bytes_read;
      this->bytes_written += c.bytes_written;
    }",40,,185,2,,void
15016,BLOCK,-1,,<empty>,,,,2,,<empty>
15021,BLOCK,-1,,<empty>,,,,2,,<empty>
15025,BLOCK,-1,,"{
    return internal_comparator_.user_comparator();
  }",45,,197,1,,void
15034,BLOCK,-1,,<empty>,,,,1,,<empty>
15046,BLOCK,-1,,<empty>,,,,5,,<empty>
15073,BLOCK,-1,,<empty>,1,,1,1,,ANY
15086,BLOCK,-1,,"{
  }",40,,60,6,,void
15090,BLOCK,-1,,"{
    delete iter_;
  }",21,,62,1,,void
15096,BLOCK,-1,,{ return valid_; },30,,65,1,,void
15102,BLOCK,-1,,"{
    assert(valid_);
    return (direction_ == kForward) ? ExtractUserKey(iter_->key()) : saved_key_;
  }",29,,66,1,,void
15119,BLOCK,-1,,"{
    assert(valid_);
    return (direction_ == kForward) ? iter_->value() : saved_value_;
  }",31,,70,1,,void
15135,BLOCK,-1,,"{
    if (status_.ok()) {
      return iter_->status();
    } else {
      return status_;
    }
  }",33,,74,1,,void
15141,BLOCK,-1,,"{
      return iter_->status();
    }",23,,75,2,,void
15148,BLOCK,-1,,"{
      return status_;
    }",12,,77,1,,void
15154,BLOCK,-1,,<empty>,,,,1,,<empty>
15158,BLOCK,-1,,<empty>,,,,1,,<empty>
15163,BLOCK,-1,,<empty>,,,,2,,<empty>
15167,BLOCK,-1,,<empty>,,,,1,,<empty>
15171,BLOCK,-1,,<empty>,,,,1,,<empty>
15177,BLOCK,-1,,<empty>,,,,3,,<empty>
15181,BLOCK,-1,,<empty>,,,,1,,<empty>
15186,BLOCK,-1,,<empty>,,,,2,,<empty>
15192,BLOCK,-1,,"{
    dst->assign(k.data(), k.size());
  }",57,,93,3,,void
15208,BLOCK,-1,,"{
    if (saved_value_.capacity() > 1048576) {
      std::string empty;
      swap(empty, saved_value_);
    } else {
      saved_value_.clear();
    }
  }",33,,97,1,,void
15216,BLOCK,-1,,"{
      std::string empty;
      swap(empty, saved_value_);
    }",44,,98,2,,void
15222,BLOCK,-1,,"{
      saved_value_.clear();
    }",12,,101,1,,void
15230,BLOCK,-1,,"{
    return rnd_.Uniform(2*config::kReadBytesPeriod);
  }",26,,107,1,,void
15256,BLOCK,-1,,<empty>,,,,2,,<empty>
15261,BLOCK,-1,,<empty>,,,,2,,<empty>
15266,BLOCK,-1,,"{
  Slice k = iter_->key();
  ssize_t n = k.size() + iter_->value().size();
  bytes_counter_ -= n;
  while (bytes_counter_ < 0) {
    bytes_counter_ += RandomPeriod();
    db_->RecordReadSample(k);
  }
  if (!ParseInternalKey(k, ikey)) {
    status_ = Status::Corruption(""corrupted internal key in DBIter"");
    return false;
  } else {
    return true;
  }
}",55,,130,2,,void
15296,BLOCK,-1,,"{
    bytes_counter_ += RandomPeriod();
    db_->RecordReadSample(k);
  }",30,,134,2,,void
15310,BLOCK,-1,,"{
    status_ = Status::Corruption(""corrupted internal key in DBIter"");
    return false;
  }",35,,138,2,,void
15321,BLOCK,-1,,"{
    return true;
  }",10,,141,1,,void
15327,BLOCK,-1,,"{
  assert(valid_);

  if (direction_ == kReverse) {  // Switch directions?
    direction_ = kForward;
    // iter_ is pointing just before the entries for this->key(),
    // so advance into the range of entries for this->key() and then
    // use the normal skipping code below.
    if (!iter_->Valid()) {
      iter_->SeekToFirst();
    } else {
      iter_->Next();
    }
    if (!iter_->Valid()) {
      valid_ = false;
      saved_key_.clear();
      return;
    }
    // saved_key_ already contains the key to skip past.
  } else {
    // Store in saved_key_ the current key so we skip it below.
    SaveKey(ExtractUserKey(iter_->key()), &saved_key_);
  }

  FindNextUserEntry(true, &saved_key_);
}",21,,146,1,,void
15334,BLOCK,-1,,"{  // Switch directions?
    direction_ = kForward;
    // iter_ is pointing just before the entries for this->key(),
    // so advance into the range of entries for this->key() and then
    // use the normal skipping code below.
    if (!iter_->Valid()) {
      iter_->SeekToFirst();
    } else {
      iter_->Next();
    }
    if (!iter_->Valid()) {
      valid_ = false;
      saved_key_.clear();
      return;
    }
    // saved_key_ already contains the key to skip past.
  }",31,,149,2,,void
15344,BLOCK,-1,,"{
      iter_->SeekToFirst();
    }",26,,154,2,,void
15350,BLOCK,-1,,"{
      iter_->Next();
    }",12,,156,1,,void
15361,BLOCK,-1,,"{
      valid_ = false;
      saved_key_.clear();
      return;
    }",26,,159,2,,void
15371,BLOCK,-1,,"{
    // Store in saved_key_ the current key so we skip it below.
    SaveKey(ExtractUserKey(iter_->key()), &saved_key_);
  }",10,,165,1,,void
15389,BLOCK,-1,,"{
  // Loop until we hit an acceptable entry to yield
  assert(iter_->Valid());
  assert(direction_ == kForward);
  do {
    ParsedInternalKey ikey;
    if (ParseKey(&ikey) && ikey.sequence <= sequence_) {
      switch (ikey.type) {
        case kTypeDeletion:
          // Arrange to skip all upcoming entries for this key since
          // they are hidden by this deletion.
          SaveKey(ikey.user_key, skip);
          skipping = true;
          break;
        case kTypeValue:
          if (skipping &&
              user_comparator_->Compare(ikey.user_key, *skip) <= 0) {
            // Entry hidden
          } else {
            valid_ = true;
            saved_key_.clear();
            return;
          }
          break;
      }
    }
    iter_->Next();
  } while (iter_->Valid());
  saved_key_.clear();
  valid_ = false;
}",66,,173,3,,void
15400,BLOCK,-1,,"{
    ParsedInternalKey ikey;
    if (ParseKey(&ikey) && ikey.sequence <= sequence_) {
      switch (ikey.type) {
        case kTypeDeletion:
          // Arrange to skip all upcoming entries for this key since
          // they are hidden by this deletion.
          SaveKey(ikey.user_key, skip);
          skipping = true;
          break;
        case kTypeValue:
          if (skipping &&
              user_comparator_->Compare(ikey.user_key, *skip) <= 0) {
            // Entry hidden
          } else {
            valid_ = true;
            saved_key_.clear();
            return;
          }
          break;
      }
    }
    iter_->Next();
  }",6,,177,1,,void
15412,BLOCK,-1,,"{
      switch (ikey.type) {
        case kTypeDeletion:
          // Arrange to skip all upcoming entries for this key since
          // they are hidden by this deletion.
          SaveKey(ikey.user_key, skip);
          skipping = true;
          break;
        case kTypeValue:
          if (skipping &&
              user_comparator_->Compare(ikey.user_key, *skip) <= 0) {
            // Entry hidden
          } else {
            valid_ = true;
            saved_key_.clear();
            return;
          }
          break;
      }
    }",56,,179,2,,void
15417,BLOCK,-1,,"{
        case kTypeDeletion:
          // Arrange to skip all upcoming entries for this key since
          // they are hidden by this deletion.
          SaveKey(ikey.user_key, skip);
          skipping = true;
          break;
        case kTypeValue:
          if (skipping &&
              user_comparator_->Compare(ikey.user_key, *skip) <= 0) {
            // Entry hidden
          } else {
            valid_ = true;
            saved_key_.clear();
            return;
          }
          break;
      }",26,,180,2,,void
15445,BLOCK,-1,,"{
            // Entry hidden
          }",69,,189,2,,void
15447,BLOCK,-1,,"{
            valid_ = true;
            saved_key_.clear();
            return;
          }",18,,191,1,,void
15475,BLOCK,-1,,"{
  assert(valid_);

  if (direction_ == kForward) {  // Switch directions?
    // iter_ is pointing at the current entry.  Scan backwards until
    // the key changes so we can use the normal reverse scanning code.
    assert(iter_->Valid());  // Otherwise valid_ would have been false
    SaveKey(ExtractUserKey(iter_->key()), &saved_key_);
    while (true) {
      iter_->Prev();
      if (!iter_->Valid()) {
        valid_ = false;
        saved_key_.clear();
        ClearSavedValue();
        return;
      }
      if (user_comparator_->Compare(ExtractUserKey(iter_->key()),
                                    saved_key_) < 0) {
        break;
      }
    }
    direction_ = kReverse;
  }

  FindPrevUserEntry();
}",21,,205,1,,void
15482,BLOCK,-1,,"{  // Switch directions?
    // iter_ is pointing at the current entry.  Scan backwards until
    // the key changes so we can use the normal reverse scanning code.
    assert(iter_->Valid());  // Otherwise valid_ would have been false
    SaveKey(ExtractUserKey(iter_->key()), &saved_key_);
    while (true) {
      iter_->Prev();
      if (!iter_->Valid()) {
        valid_ = false;
        saved_key_.clear();
        ClearSavedValue();
        return;
      }
      if (user_comparator_->Compare(ExtractUserKey(iter_->key()),
                                    saved_key_) < 0) {
        break;
      }
    }
    direction_ = kReverse;
  }",31,,208,2,,void
15498,BLOCK,-1,,"{
      iter_->Prev();
      if (!iter_->Valid()) {
        valid_ = false;
        saved_key_.clear();
        ClearSavedValue();
        return;
      }
      if (user_comparator_->Compare(ExtractUserKey(iter_->key()),
                                    saved_key_) < 0) {
        break;
      }
    }",18,,213,2,,void
15509,BLOCK,-1,,"{
        valid_ = false;
        saved_key_.clear();
        ClearSavedValue();
        return;
      }",28,,215,2,,void
15532,BLOCK,-1,,"{
        break;
      }",54,,222,2,,void
15541,BLOCK,-1,,"{
  assert(direction_ == kReverse);

  ValueType value_type = kTypeDeletion;
  if (iter_->Valid()) {
    do {
      ParsedInternalKey ikey;
      if (ParseKey(&ikey) && ikey.sequence <= sequence_) {
        if ((value_type != kTypeDeletion) &&
            user_comparator_->Compare(ikey.user_key, saved_key_) < 0) {
          // We encountered a non-deleted value in entries for previous keys,
          break;
        }
        value_type = ikey.type;
        if (value_type == kTypeDeletion) {
          saved_key_.clear();
          ClearSavedValue();
        } else {
          Slice raw_value = iter_->value();
          if (saved_value_.capacity() > raw_value.size() + 1048576) {
            std::string empty;
            swap(empty, saved_value_);
          }
          SaveKey(ExtractUserKey(iter_->key()), &saved_key_);
          saved_value_.assign(raw_value.data(), raw_value.size());
        }
      }
      iter_->Prev();
    } while (iter_->Valid());
  }

  if (value_type == kTypeD...",34,,232,1,,void
15555,BLOCK,-1,,"{
    do {
      ParsedInternalKey ikey;
      if (ParseKey(&ikey) && ikey.sequence <= sequence_) {
        if ((value_type != kTypeDeletion) &&
            user_comparator_->Compare(ikey.user_key, saved_key_) < 0) {
          // We encountered a non-deleted value in entries for previous keys,
          break;
        }
        value_type = ikey.type;
        if (value_type == kTypeDeletion) {
          saved_key_.clear();
          ClearSavedValue();
        } else {
          Slice raw_value = iter_->value();
          if (saved_value_.capacity() > raw_value.size() + 1048576) {
            std::string empty;
            swap(empty, saved_value_);
          }
          SaveKey(ExtractUserKey(iter_->key()), &saved_key_);
          saved_value_.assign(raw_value.data(), raw_value.size());
        }
      }
      iter_->Prev();
    } while (iter_->Valid());
  }",23,,236,2,,void
15557,BLOCK,-1,,"{
      ParsedInternalKey ikey;
      if (ParseKey(&ikey) && ikey.sequence <= sequence_) {
        if ((value_type != kTypeDeletion) &&
            user_comparator_->Compare(ikey.user_key, saved_key_) < 0) {
          // We encountered a non-deleted value in entries for previous keys,
          break;
        }
        value_type = ikey.type;
        if (value_type == kTypeDeletion) {
          saved_key_.clear();
          ClearSavedValue();
        } else {
          Slice raw_value = iter_->value();
          if (saved_value_.capacity() > raw_value.size() + 1048576) {
            std::string empty;
            swap(empty, saved_value_);
          }
          SaveKey(ExtractUserKey(iter_->key()), &saved_key_);
          saved_value_.assign(raw_value.data(), raw_value.size());
        }
      }
      iter_->Prev();
    }",8,,237,1,,void
15569,BLOCK,-1,,"{
        if ((value_type != kTypeDeletion) &&
            user_comparator_->Compare(ikey.user_key, saved_key_) < 0) {
          // We encountered a non-deleted value in entries for previous keys,
          break;
        }
        value_type = ikey.type;
        if (value_type == kTypeDeletion) {
          saved_key_.clear();
          ClearSavedValue();
        } else {
          Slice raw_value = iter_->value();
          if (saved_value_.capacity() > raw_value.size() + 1048576) {
            std::string empty;
            swap(empty, saved_value_);
          }
          SaveKey(ExtractUserKey(iter_->key()), &saved_key_);
          saved_value_.assign(raw_value.data(), raw_value.size());
        }
      }",58,,239,2,,void
15585,BLOCK,-1,,"{
          // We encountered a non-deleted value in entries for previous keys,
          break;
        }",71,,241,2,,void
15596,BLOCK,-1,,"{
          saved_key_.clear();
          ClearSavedValue();
        }",42,,246,2,,void
15603,BLOCK,-1,,"{
          Slice raw_value = iter_->value();
          if (saved_value_.capacity() > raw_value.size() + 1048576) {
            std::string empty;
            swap(empty, saved_value_);
          }
          SaveKey(ExtractUserKey(iter_->key()), &saved_key_);
          saved_value_.assign(raw_value.data(), raw_value.size());
        }",16,,249,1,,void
15623,BLOCK,-1,,"{
            std::string empty;
            swap(empty, saved_value_);
          }",69,,251,2,,void
15660,BLOCK,-1,,"{
    // End
    valid_ = false;
    saved_key_.clear();
    ClearSavedValue();
    direction_ = kForward;
  }",36,,263,2,,void
15673,BLOCK,-1,,"{
    valid_ = true;
  }",10,,269,1,,void
15681,BLOCK,-1,,"{
  direction_ = kForward;
  ClearSavedValue();
  saved_key_.clear();
  AppendInternalKey(
      &saved_key_, ParsedInternalKey(target, sequence_, kValueTypeForSeek));
  iter_->Seek(saved_key_);
  if (iter_->Valid()) {
    FindNextUserEntry(false, &saved_key_ /* temporary storage */);
  } else {
    valid_ = false;
  }
}",40,,274,2,,void
15707,BLOCK,-1,,"{
    FindNextUserEntry(false, &saved_key_ /* temporary storage */);
  }",23,,281,2,,void
15713,BLOCK,-1,,"{
    valid_ = false;
  }",10,,283,1,,void
15720,BLOCK,-1,,"{
  direction_ = kForward;
  ClearSavedValue();
  iter_->SeekToFirst();
  if (iter_->Valid()) {
    FindNextUserEntry(false, &saved_key_ /* temporary storage */);
  } else {
    valid_ = false;
  }
}",28,,288,1,,void
15734,BLOCK,-1,,"{
    FindNextUserEntry(false, &saved_key_ /* temporary storage */);
  }",23,,292,2,,void
15740,BLOCK,-1,,"{
    valid_ = false;
  }",10,,294,1,,void
15747,BLOCK,-1,,"{
  direction_ = kReverse;
  ClearSavedValue();
  iter_->SeekToLast();
  FindPrevUserEntry();
}",27,,299,1,,void
15765,BLOCK,-1,,"{
  return new DBIter(db, user_key_comparator, internal_iter, sequence, seed);
}",20,,313,6,,void
15786,BLOCK,-1,,<empty>,1,,1,1,,ANY
15795,BLOCK,-1,,<empty>,,,,6,,<empty>
15830,BLOCK,-1,,<empty>,1,,1,1,,ANY
15835,BLOCK,-1,,"{
  std::string r;
  test::RandomString(rnd, len, &r);
  return r;
}",55,,22,3,,void
15854,BLOCK,-1,,{ },31,,34,1,,void
15858,BLOCK,-1,,"{
    IncrementBy(1);
  }",20,,35,1,,void
15865,BLOCK,-1,,"{
    MutexLock l(&mu_);
    count_ += count;
  }",31,,38,2,,void
15876,BLOCK,-1,,"{
    MutexLock l(&mu_);
    return count_;
  }",14,,42,1,,void
15886,BLOCK,-1,,"{
    MutexLock l(&mu_);
    count_ = 0;
  }",16,,46,1,,void
15898,BLOCK,-1,,"{
  Env::Default()->SleepForMicroseconds(millis * 1000);
}",36,,52,2,,void
15922,BLOCK,-1,,"{
    delay_data_sync_.Release_Store(NULL);
    data_sync_error_.Release_Store(NULL);
    no_space_.Release_Store(NULL);
    non_writable_.Release_Store(NULL);
    count_random_reads_ = false;
    manifest_sync_error_.Release_Store(NULL);
    manifest_write_error_.Release_Store(NULL);
  }",53,,81,2,,void
15961,BLOCK,-1,,"{
    class DataFile : public WritableFile {
     private:
      SpecialEnv* env_;
      WritableFile* base_;

     public:
      DataFile(SpecialEnv* env, WritableFile* base)
          : env_(env),
            base_(base) {
      }
      ~DataFile() { delete base_; }
      Status Append(const Slice& data) {
        if (env_->no_space_.Acquire_Load() != NULL) {
          // Drop writes on the floor
          return Status::OK();
        } else {
          return base_->Append(data);
        }
      }
      Status Close() { return base_->Close(); }
      Status Flush() { return base_->Flush(); }
      Status Sync() {
        if (env_->data_sync_error_.Acquire_Load() != NULL) {
          return Status::IOError(""simulated data sync error"");
        }
        while (env_->delay_data_sync_.Acquire_Load() != NULL) {
          DelayMilliseconds(100);
        }
        return base_->Sync();
      }
    };
    class ManifestFile : public WritableFile {
     private:
      SpecialEnv* env_;
 ...",66,,91,3,,void
15969,BLOCK,-1,,"{
      return Status::IOError(""simulated write error"");
    }",47,,148,2,,void
15990,BLOCK,-1,,"{
      if (strstr(f.c_str(), "".ldb"") != NULL ||
          strstr(f.c_str(), "".log"") != NULL) {
        *r = new DataFile(this, *r);
      } else if (strstr(f.c_str(), ""MANIFEST"") != NULL) {
        *r = new ManifestFile(this, *r);
      }
    }",17,,153,2,,void
16009,BLOCK,-1,,"{
        *r = new DataFile(this, *r);
      }",46,,155,2,,void
16019,BLOCK,-1,,<empty>,14,,157,1,,void
16029,BLOCK,-1,,"{
        *r = new ManifestFile(this, *r);
      }",57,,157,2,,void
16045,BLOCK,-1,,"{
    class CountingFile : public RandomAccessFile {
     private:
      RandomAccessFile* target_;
      AtomicCounter* counter_;
     public:
      CountingFile(RandomAccessFile* target, AtomicCounter* counter)
          : target_(target), counter_(counter) {
      }
      virtual ~CountingFile() { delete target_; }
      virtual Status Read(uint64_t offset, size_t n, Slice* result,
                          char* scratch) const {
        counter_->Increment();
        return target_->Read(offset, n, result, scratch);
      }
    };

    Status s = target()->NewRandomAccessFile(f, r);
    if (s.ok() && count_random_reads_) {
      *r = new CountingFile(*r, &random_read_counter_);
    }
    return s;
  }",74,,164,3,,void
16062,BLOCK,-1,,"{
      *r = new CountingFile(*r, &random_read_counter_);
    }",40,,182,2,,void
16090,BLOCK,-1,,"{
    filter_policy_ = NewBloomFilterPolicy(10);
    dbname_ = test::TmpDir() + ""/db_test"";
    DestroyDB(dbname_, Options());
    db_ = NULL;
    Reopen();
  }",51,,211,1,,void
16113,BLOCK,-1,,"{
    delete db_;
    DestroyDB(dbname_, Options());
    delete env_;
    delete filter_policy_;
  }",13,,219,1,,void
16126,BLOCK,-1,,"{
    option_config_++;
    if (option_config_ >= kEnd) {
      return false;
    } else {
      DestroyAndReopen();
      return true;
    }
  }",24,,228,1,,void
16133,BLOCK,-1,,"{
      return false;
    }",33,,230,2,,void
16137,BLOCK,-1,,"{
      DestroyAndReopen();
      return true;
    }",12,,232,1,,void
16144,BLOCK,-1,,"{
    Options options;
    options.reuse_logs = false;
    switch (option_config_) {
      case kReuse:
        options.reuse_logs = true;
        break;
      case kFilter:
        options.filter_policy = filter_policy_;
        break;
      case kUncompressed:
        options.compression = kNoCompression;
        break;
      default:
        break;
    }
    return options;
  }",28,,239,1,,void
16153,BLOCK,-1,,"{
      case kReuse:
        options.reuse_logs = true;
        break;
      case kFilter:
        options.filter_policy = filter_policy_;
        break;
      case kUncompressed:
        options.compression = kNoCompression;
        break;
      default:
        break;
    }",29,,242,2,,void
16185,BLOCK,-1,,"{
    return reinterpret_cast<DBImpl*>(db_);
  }",20,,258,1,,void
16194,BLOCK,-1,,"{
    ASSERT_OK(TryReopen(options));
  }",40,,262,2,,void
16198,BLOCK,1,,<empty>,,,,2,,void
16215,BLOCK,-1,,"{
    delete db_;
    db_ = NULL;
  }",16,,266,1,,void
16225,BLOCK,-1,,"{
    delete db_;
    db_ = NULL;
    DestroyDB(dbname_, Options());
    ASSERT_OK(TryReopen(options));
  }",50,,271,2,,void
16237,BLOCK,1,,<empty>,,,,2,,void
16255,BLOCK,-1,,"{
    delete db_;
    db_ = NULL;
    Options opts;
    if (options != NULL) {
      opts = *options;
    } else {
      opts = CurrentOptions();
      opts.create_if_missing = true;
    }
    last_options_ = opts;

    return DB::Open(opts, dbname_, &db_);
  }",38,,278,2,,void
16266,BLOCK,-1,,"{
      opts = *options;
    }",26,,282,2,,void
16272,BLOCK,-1,,"{
      opts = CurrentOptions();
      opts.create_if_missing = true;
    }",12,,284,1,,void
16298,BLOCK,-1,,"{
    return db_->Put(WriteOptions(), k, v);
  }",58,,293,3,,void
16311,BLOCK,-1,,"{
    return db_->Delete(WriteOptions(), k);
  }",39,,297,2,,void
16324,BLOCK,-1,,"{
    ReadOptions options;
    options.snapshot = snapshot;
    std::string result;
    Status s = db_->Get(options, k, &result);
    if (s.IsNotFound()) {
      result = ""NOT_FOUND"";
    } else if (!s.ok()) {
      result = s.ToString();
    }
    return result;
  }",74,,301,3,,void
16348,BLOCK,-1,,"{
      result = ""NOT_FOUND"";
    }",25,,306,2,,void
16353,BLOCK,-1,,<empty>,12,,308,1,,void
16360,BLOCK,-1,,"{
      result = s.ToString();
    }",25,,308,2,,void
16372,BLOCK,-1,,"{
    std::vector<std::string> forward;
    std::string result;
    Iterator* iter = db_->NewIterator(ReadOptions());
    for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {
      std::string s = IterStatus(iter);
      result.push_back('(');
      result.append(s);
      result.push_back(')');
      forward.push_back(s);
    }

    // Check reverse iteration results are the reverse of forward results
    size_t matched = 0;
    for (iter->SeekToLast(); iter->Valid(); iter->Prev()) {
      ASSERT_LT(matched, forward.size());
      ASSERT_EQ(IterStatus(iter), forward[forward.size() - matched - 1]);
      matched++;
    }
    ASSERT_EQ(matched, forward.size());

    delete iter;
    return result;
  }",26,,316,1,,void
16392,BLOCK,-1,,<empty>,5,,320,1,,void
16405,BLOCK,4,,"{
      std::string s = IterStatus(iter);
      result.push_back('(');
      result.append(s);
      result.push_back(')');
      forward.push_back(s);
    }",60,,320,4,,void
16436,BLOCK,-1,,<empty>,5,,330,1,,void
16449,BLOCK,4,,"{
      ASSERT_LT(matched, forward.size());
      ASSERT_EQ(IterStatus(iter), forward[forward.size() - matched - 1]);
      matched++;
    }",59,,330,4,,void
16456,BLOCK,1,,<empty>,,,,4,,void
16476,BLOCK,1,,<empty>,,,,4,,void
16508,BLOCK,1,,<empty>,,,,4,,void
16533,BLOCK,-1,,"{
    Iterator* iter = dbfull()->TEST_NewInternalIterator();
    InternalKey target(user_key, kMaxSequenceNumber, kTypeValue);
    iter->Seek(target.Encode());
    std::string result;
    if (!iter->status().ok()) {
      result = iter->status().ToString();
    } else {
      result = ""[ "";
      bool first = true;
      while (iter->Valid()) {
        ParsedInternalKey ikey;
        if (!ParseInternalKey(iter->key(), &ikey)) {
          result += ""CORRUPTED"";
        } else {
          if (last_options_.comparator->Compare(ikey.user_key, user_key) != 0) {
            break;
          }
          if (!first) {
            result += "", "";
          }
          first = false;
          switch (ikey.type) {
            case kTypeValue:
              result += iter->value().ToString();
              break;
            case kTypeDeletion:
              result += ""DEL"";
              break;
          }
        }
        iter->Next();
      }
      if (!first) {
        result += "" "";
    ...",52,,341,2,,void
16564,BLOCK,-1,,"{
      result = iter->status().ToString();
    }",31,,346,2,,void
16575,BLOCK,-1,,"{
      result = ""[ "";
      bool first = true;
      while (iter->Valid()) {
        ParsedInternalKey ikey;
        if (!ParseInternalKey(iter->key(), &ikey)) {
          result += ""CORRUPTED"";
        } else {
          if (last_options_.comparator->Compare(ikey.user_key, user_key) != 0) {
            break;
          }
          if (!first) {
            result += "", "";
          }
          first = false;
          switch (ikey.type) {
            case kTypeValue:
              result += iter->value().ToString();
              break;
            case kTypeDeletion:
              result += ""DEL"";
              break;
          }
        }
        iter->Next();
      }
      if (!first) {
        result += "" "";
      }
      result += ""]"";
    }",12,,348,1,,void
16588,BLOCK,-1,,"{
        ParsedInternalKey ikey;
        if (!ParseInternalKey(iter->key(), &ikey)) {
          result += ""CORRUPTED"";
        } else {
          if (last_options_.comparator->Compare(ikey.user_key, user_key) != 0) {
            break;
          }
          if (!first) {
            result += "", "";
          }
          first = false;
          switch (ikey.type) {
            case kTypeValue:
              result += iter->value().ToString();
              break;
            case kTypeDeletion:
              result += ""DEL"";
              break;
          }
        }
        iter->Next();
      }",29,,351,2,,void
16599,BLOCK,-1,,"{
          result += ""CORRUPTED"";
        }",52,,353,2,,void
16604,BLOCK,-1,,"{
          if (last_options_.comparator->Compare(ikey.user_key, user_key) != 0) {
            break;
          }
          if (!first) {
            result += "", "";
          }
          first = false;
          switch (ikey.type) {
            case kTypeValue:
              result += iter->value().ToString();
              break;
            case kTypeDeletion:
              result += ""DEL"";
              break;
          }
        }",16,,355,1,,void
16618,BLOCK,-1,,"{
            break;
          }",80,,356,2,,void
16623,BLOCK,-1,,"{
            result += "", "";
          }",23,,359,2,,void
16634,BLOCK,-1,,"{
            case kTypeValue:
              result += iter->value().ToString();
              break;
            case kTypeDeletion:
              result += ""DEL"";
              break;
          }",30,,363,2,,void
16660,BLOCK,-1,,"{
        result += "" "";
      }",19,,374,2,,void
16675,BLOCK,-1,,"{
    std::string property;
    ASSERT_TRUE(
        db_->GetProperty(""leveldb.num-files-at-level"" + NumberToString(level),
                         &property));
    return atoi(property.c_str());
  }",39,,383,2,,void
16678,BLOCK,1,,<empty>,,,,2,,void
16710,BLOCK,-1,,"{
    int result = 0;
    for (int level = 0; level < config::kNumLevels; level++) {
      result += NumTableFilesAtLevel(level);
    }
    return result;
  }",25,,391,1,,void
16716,BLOCK,-1,,<empty>,5,,393,1,,void
16728,BLOCK,4,,"{
      result += NumTableFilesAtLevel(level);
    }",62,,393,4,,void
16738,BLOCK,-1,,"{
    std::string result;
    int last_non_zero_offset = 0;
    for (int level = 0; level < config::kNumLevels; level++) {
      int f = NumTableFilesAtLevel(level);
      char buf[100];
      snprintf(buf, sizeof(buf), ""%s%d"", (level ? "","" : """"), f);
      result += buf;
      if (f > 0) {
        last_non_zero_offset = result.size();
      }
    }
    result.resize(last_non_zero_offset);
    return result;
  }",31,,400,1,,void
16745,BLOCK,-1,,<empty>,5,,403,1,,void
16757,BLOCK,4,,"{
      int f = NumTableFilesAtLevel(level);
      char buf[100];
      snprintf(buf, sizeof(buf), ""%s%d"", (level ? "","" : """"), f);
      result += buf;
      if (f > 0) {
        last_non_zero_offset = result.size();
      }
    }",62,,403,4,,void
16781,BLOCK,-1,,"{
        last_non_zero_offset = result.size();
      }",18,,408,2,,void
16798,BLOCK,-1,,"{
    std::vector<std::string> files;
    env_->GetChildren(dbname_, &files);
    return static_cast<int>(files.size());
  }",20,,416,1,,void
16827,BLOCK,-1,,"{
    Range r(start, limit);
    uint64_t size;
    db_->GetApproximateSizes(&r, 1, &size);
    return size;
  }",57,,422,3,,void
16849,BLOCK,-1,,"{
    db_->CompactRange(&start, &limit);
  }",56,,429,3,,void
16864,BLOCK,-1,,"{
    for (int i = 0; i < n; i++) {
      Put(small, ""begin"");
      Put(large, ""end"");
      dbfull()->TEST_CompactMemTable();
    }
  }",78,,435,4,,void
16866,BLOCK,-1,,<empty>,5,,436,1,,void
16876,BLOCK,4,,"{
      Put(small, ""begin"");
      Put(large, ""end"");
      dbfull()->TEST_CompactMemTable();
    }",33,,436,4,,void
16892,BLOCK,-1,,"{
    MakeTables(config::kNumLevels, smallest, largest);
  }",76,,445,3,,void
16903,BLOCK,-1,,"{
    fprintf(stderr, ""---\n%s:\n"", label);
    fprintf(stderr, ""maxoverlap: %lld\n"",
            static_cast<long long>(
                dbfull()->TEST_MaxNextLevelOverlappingBytes()));
    for (int level = 0; level < config::kNumLevels; level++) {
      int num = NumTableFilesAtLevel(level);
      if (num > 0) {
        fprintf(stderr, ""  level %3d : %d files\n"", level, num);
      }
    }
  }",42,,449,2,,void
16918,BLOCK,-1,,<empty>,5,,454,1,,void
16930,BLOCK,4,,"{
      int num = NumTableFilesAtLevel(level);
      if (num > 0) {
        fprintf(stderr, ""  level %3d : %d files\n"", level, num);
      }
    }",62,,454,4,,void
16940,BLOCK,-1,,"{
        fprintf(stderr, ""  level %3d : %d files\n"", level, num);
      }",20,,456,2,,void
16949,BLOCK,-1,,"{
    std::string property;
    db_->GetProperty(""leveldb.sstables"", &property);
    return property;
  }",33,,462,1,,void
16964,BLOCK,-1,,"{
    std::string result;
    if (iter->Valid()) {
      result = iter->key().ToString() + ""->"" + iter->value().ToString();
    } else {
      result = ""(invalid)"";
    }
    return result;
  }",42,,468,2,,void
16971,BLOCK,-1,,"{
      result = iter->key().ToString() + ""->"" + iter->value().ToString();
    }",24,,470,2,,void
16992,BLOCK,-1,,"{
      result = ""(invalid)"";
    }",12,,472,1,,void
17001,BLOCK,-1,,"{
    std::vector<std::string> filenames;
    ASSERT_OK(env_->GetChildren(dbname_, &filenames));
    uint64_t number;
    FileType type;
    for (size_t i = 0; i < filenames.size(); i++) {
      if (ParseFileName(filenames[i], &number, &type) && type == kTableFile) {
        ASSERT_OK(env_->DeleteFile(TableFileName(dbname_, number)));
        return true;
      }
    }
    return false;
  }",26,,478,1,,void
17012,BLOCK,1,,<empty>,,,,1,,void
17034,BLOCK,-1,,<empty>,5,,483,1,,void
17047,BLOCK,4,,"{
      if (ParseFileName(filenames[i], &number, &type) && type == kTableFile) {
        ASSERT_OK(env_->DeleteFile(TableFileName(dbname_, number)));
        return true;
      }
    }",51,,483,4,,void
17061,BLOCK,-1,,"{
        ASSERT_OK(env_->DeleteFile(TableFileName(dbname_, number)));
        return true;
      }",78,,484,2,,void
17063,BLOCK,1,,<empty>,,,,2,,void
17089,BLOCK,-1,,"{
    std::vector<std::string> filenames;
    ASSERT_OK(env_->GetChildren(dbname_, &filenames));
    uint64_t number;
    FileType type;
    int files_renamed = 0;
    for (size_t i = 0; i < filenames.size(); i++) {
      if (ParseFileName(filenames[i], &number, &type) && type == kTableFile) {
        const std::string from = TableFileName(dbname_, number);
        const std::string to = SSTTableFileName(dbname_, number);
        ASSERT_OK(env_->RenameFile(from, to));
        files_renamed++;
      }
    }
    return files_renamed;
  }",24,,493,1,,void
17100,BLOCK,1,,<empty>,,,,1,,void
17126,BLOCK,-1,,<empty>,5,,499,1,,void
17139,BLOCK,4,,"{
      if (ParseFileName(filenames[i], &number, &type) && type == kTableFile) {
        const std::string from = TableFileName(dbname_, number);
        const std::string to = SSTTableFileName(dbname_, number);
        ASSERT_OK(env_->RenameFile(from, to));
        files_renamed++;
      }
    }",51,,499,4,,void
17153,BLOCK,-1,,"{
        const std::string from = TableFileName(dbname_, number);
        const std::string to = SSTTableFileName(dbname_, number);
        ASSERT_OK(env_->RenameFile(from, to));
        files_renamed++;
      }",78,,500,2,,void
17167,BLOCK,1,,<empty>,,,,3,,void
17193,BLOCK,-1,,<empty>,,,,1,,<empty>
17197,BLOCK,-1,,"TEST(DBTest, Empty)",1,,511,1,,void
17221,BLOCK,-1,,"{
  do {
    ASSERT_TRUE(db_ != NULL);
    ASSERT_EQ(""NOT_FOUND"", Get(""foo""));
  } while (ChangeOptions());
}",21,,511,1,,void
17223,BLOCK,-1,,"{
    ASSERT_TRUE(db_ != NULL);
    ASSERT_EQ(""NOT_FOUND"", Get(""foo""));
  }",6,,512,1,,void
17225,BLOCK,1,,<empty>,,,,1,,void
17245,BLOCK,1,,<empty>,,,,3,,void
17265,BLOCK,-1,,<empty>,,,,1,,<empty>
17269,BLOCK,-1,,"TEST(DBTest, ReadWrite)",1,,518,1,,void
17293,BLOCK,-1,,"{
  do {
    ASSERT_OK(Put(""foo"", ""v1""));
    ASSERT_EQ(""v1"", Get(""foo""));
    ASSERT_OK(Put(""bar"", ""v2""));
    ASSERT_OK(Put(""foo"", ""v3""));
    ASSERT_EQ(""v3"", Get(""foo""));
    ASSERT_EQ(""v2"", Get(""bar""));
  } while (ChangeOptions());
}",25,,518,1,,void
17295,BLOCK,-1,,"{
    ASSERT_OK(Put(""foo"", ""v1""));
    ASSERT_EQ(""v1"", Get(""foo""));
    ASSERT_OK(Put(""bar"", ""v2""));
    ASSERT_OK(Put(""foo"", ""v3""));
    ASSERT_EQ(""v3"", Get(""foo""));
    ASSERT_EQ(""v2"", Get(""bar""));
  }",6,,519,1,,void
17297,BLOCK,1,,<empty>,,,,1,,void
17316,BLOCK,1,,<empty>,,,,3,,void
17332,BLOCK,1,,<empty>,,,,1,,void
17348,BLOCK,1,,<empty>,,,,1,,void
17367,BLOCK,1,,<empty>,,,,3,,void
17386,BLOCK,1,,<empty>,,,,3,,void
17406,BLOCK,-1,,<empty>,,,,1,,<empty>
17410,BLOCK,-1,,"TEST(DBTest, PutDeleteGet)",1,,529,1,,void
17434,BLOCK,-1,,"{
  do {
    ASSERT_OK(db_->Put(WriteOptions(), ""foo"", ""v1""));
    ASSERT_EQ(""v1"", Get(""foo""));
    ASSERT_OK(db_->Put(WriteOptions(), ""foo"", ""v2""));
    ASSERT_EQ(""v2"", Get(""foo""));
    ASSERT_OK(db_->Delete(WriteOptions(), ""foo""));
    ASSERT_EQ(""NOT_FOUND"", Get(""foo""));
  } while (ChangeOptions());
}",28,,529,1,,void
17436,BLOCK,-1,,"{
    ASSERT_OK(db_->Put(WriteOptions(), ""foo"", ""v1""));
    ASSERT_EQ(""v1"", Get(""foo""));
    ASSERT_OK(db_->Put(WriteOptions(), ""foo"", ""v2""));
    ASSERT_EQ(""v2"", Get(""foo""));
    ASSERT_OK(db_->Delete(WriteOptions(), ""foo""));
    ASSERT_EQ(""NOT_FOUND"", Get(""foo""));
  }",6,,530,1,,void
17438,BLOCK,1,,<empty>,,,,1,,void
17461,BLOCK,1,,<empty>,,,,3,,void
17477,BLOCK,1,,<empty>,,,,1,,void
17500,BLOCK,1,,<empty>,,,,3,,void
17516,BLOCK,1,,<empty>,,,,1,,void
17538,BLOCK,1,,<empty>,,,,3,,void
17558,BLOCK,-1,,<empty>,,,,1,,<empty>
17562,BLOCK,-1,,"TEST(DBTest, GetFromImmutableLayer)",1,,540,1,,void
17586,BLOCK,-1,,"{
  do {
    Options options = CurrentOptions();
    options.env = env_;
    options.write_buffer_size = 100000;  // Small write buffer
    Reopen(&options);

    ASSERT_OK(Put(""foo"", ""v1""));
    ASSERT_EQ(""v1"", Get(""foo""));

    env_->delay_data_sync_.Release_Store(env_);      // Block sync calls
    Put(""k1"", std::string(100000, 'x'));             // Fill memtable
    Put(""k2"", std::string(100000, 'y'));             // Trigger compaction
    ASSERT_EQ(""v1"", Get(""foo""));
    env_->delay_data_sync_.Release_Store(NULL);      // Release sync calls
  } while (ChangeOptions());
}",37,,540,1,,void
17588,BLOCK,-1,,"{
    Options options = CurrentOptions();
    options.env = env_;
    options.write_buffer_size = 100000;  // Small write buffer
    Reopen(&options);

    ASSERT_OK(Put(""foo"", ""v1""));
    ASSERT_EQ(""v1"", Get(""foo""));

    env_->delay_data_sync_.Release_Store(env_);      // Block sync calls
    Put(""k1"", std::string(100000, 'x'));             // Fill memtable
    Put(""k2"", std::string(100000, 'y'));             // Trigger compaction
    ASSERT_EQ(""v1"", Get(""foo""));
    env_->delay_data_sync_.Release_Store(NULL);      // Release sync calls
  }",6,,541,1,,void
17607,BLOCK,1,,<empty>,,,,1,,void
17626,BLOCK,1,,<empty>,,,,3,,void
17668,BLOCK,1,,<empty>,,,,3,,void
17695,BLOCK,-1,,<empty>,,,,1,,<empty>
17699,BLOCK,-1,,"TEST(DBTest, GetFromVersions)",1,,558,1,,void
17723,BLOCK,-1,,"{
  do {
    ASSERT_OK(Put(""foo"", ""v1""));
    dbfull()->TEST_CompactMemTable();
    ASSERT_EQ(""v1"", Get(""foo""));
  } while (ChangeOptions());
}",31,,558,1,,void
17725,BLOCK,-1,,"{
    ASSERT_OK(Put(""foo"", ""v1""));
    dbfull()->TEST_CompactMemTable();
    ASSERT_EQ(""v1"", Get(""foo""));
  }",6,,559,1,,void
17727,BLOCK,1,,<empty>,,,,1,,void
17750,BLOCK,1,,<empty>,,,,3,,void
17770,BLOCK,-1,,<empty>,,,,1,,<empty>
17774,BLOCK,-1,,"TEST(DBTest, GetMemUsage)",1,,566,1,,void
17798,BLOCK,-1,,"{
  do {
    ASSERT_OK(Put(""foo"", ""v1""));
    std::string val;
    ASSERT_TRUE(db_->GetProperty(""leveldb.approximate-memory-usage"", &val));
    int mem_usage = atoi(val.c_str());
    ASSERT_GT(mem_usage, 0);
    ASSERT_LT(mem_usage, 5*1024*1024);
  } while (ChangeOptions());
}",27,,566,1,,void
17800,BLOCK,-1,,"{
    ASSERT_OK(Put(""foo"", ""v1""));
    std::string val;
    ASSERT_TRUE(db_->GetProperty(""leveldb.approximate-memory-usage"", &val));
    int mem_usage = atoi(val.c_str());
    ASSERT_GT(mem_usage, 0);
    ASSERT_LT(mem_usage, 5*1024*1024);
  }",6,,567,1,,void
17802,BLOCK,1,,<empty>,,,,1,,void
17819,BLOCK,1,,<empty>,,,,2,,void
17850,BLOCK,1,,<empty>,,,,4,,void
17866,BLOCK,1,,<empty>,,,,3,,void
17889,BLOCK,-1,,<empty>,,,,1,,<empty>
17893,BLOCK,-1,,"TEST(DBTest, GetSnapshot)",1,,577,1,,void
17917,BLOCK,-1,,"{
  do {
    // Try with both a short key and a long key
    for (int i = 0; i < 2; i++) {
      std::string key = (i == 0) ? std::string(""foo"") : std::string(200, 'x');
      ASSERT_OK(Put(key, ""v1""));
      const Snapshot* s1 = db_->GetSnapshot();
      ASSERT_OK(Put(key, ""v2""));
      ASSERT_EQ(""v2"", Get(key));
      ASSERT_EQ(""v1"", Get(key, s1));
      dbfull()->TEST_CompactMemTable();
      ASSERT_EQ(""v2"", Get(key));
      ASSERT_EQ(""v1"", Get(key, s1));
      db_->ReleaseSnapshot(s1);
    }
  } while (ChangeOptions());
}",27,,577,1,,void
17919,BLOCK,-1,,"{
    // Try with both a short key and a long key
    for (int i = 0; i < 2; i++) {
      std::string key = (i == 0) ? std::string(""foo"") : std::string(200, 'x');
      ASSERT_OK(Put(key, ""v1""));
      const Snapshot* s1 = db_->GetSnapshot();
      ASSERT_OK(Put(key, ""v2""));
      ASSERT_EQ(""v2"", Get(key));
      ASSERT_EQ(""v1"", Get(key, s1));
      dbfull()->TEST_CompactMemTable();
      ASSERT_EQ(""v2"", Get(key));
      ASSERT_EQ(""v1"", Get(key, s1));
      db_->ReleaseSnapshot(s1);
    }
  }",6,,578,1,,void
17921,BLOCK,-1,,<empty>,5,,580,1,,void
17931,BLOCK,4,,"{
      std::string key = (i == 0) ? std::string(""foo"") : std::string(200, 'x');
      ASSERT_OK(Put(key, ""v1""));
      const Snapshot* s1 = db_->GetSnapshot();
      ASSERT_OK(Put(key, ""v2""));
      ASSERT_EQ(""v2"", Get(key));
      ASSERT_EQ(""v1"", Get(key, s1));
      dbfull()->TEST_CompactMemTable();
      ASSERT_EQ(""v2"", Get(key));
      ASSERT_EQ(""v1"", Get(key, s1));
      db_->ReleaseSnapshot(s1);
    }",33,,580,4,,void
17951,BLOCK,1,,<empty>,,,,2,,void
17974,BLOCK,1,,<empty>,,,,2,,void
17993,BLOCK,1,,<empty>,,,,4,,void
18010,BLOCK,1,,<empty>,,,,4,,void
18034,BLOCK,1,,<empty>,,,,4,,void
18051,BLOCK,1,,<empty>,,,,4,,void
18077,BLOCK,-1,,<empty>,,,,1,,<empty>
18081,BLOCK,-1,,"TEST(DBTest, GetLevel0Ordering)",1,,595,1,,void
18105,BLOCK,-1,,"{
  do {
    // Check that we process level-0 files in correct order.  The code
    // below generates two level-0 files where the earlier one comes
    // before the later one in the level-0 file list since the earlier
    // one has a smaller ""smallest"" key.
    ASSERT_OK(Put(""bar"", ""b""));
    ASSERT_OK(Put(""foo"", ""v1""));
    dbfull()->TEST_CompactMemTable();
    ASSERT_OK(Put(""foo"", ""v2""));
    dbfull()->TEST_CompactMemTable();
    ASSERT_EQ(""v2"", Get(""foo""));
  } while (ChangeOptions());
}",33,,595,1,,void
18107,BLOCK,-1,,"{
    // Check that we process level-0 files in correct order.  The code
    // below generates two level-0 files where the earlier one comes
    // before the later one in the level-0 file list since the earlier
    // one has a smaller ""smallest"" key.
    ASSERT_OK(Put(""bar"", ""b""));
    ASSERT_OK(Put(""foo"", ""v1""));
    dbfull()->TEST_CompactMemTable();
    ASSERT_OK(Put(""foo"", ""v2""));
    dbfull()->TEST_CompactMemTable();
    ASSERT_EQ(""v2"", Get(""foo""));
  }",6,,596,1,,void
18109,BLOCK,1,,<empty>,,,,1,,void
18125,BLOCK,1,,<empty>,,,,1,,void
18145,BLOCK,1,,<empty>,,,,1,,void
18168,BLOCK,1,,<empty>,,,,3,,void
18188,BLOCK,-1,,<empty>,,,,1,,<empty>
18192,BLOCK,-1,,"TEST(DBTest, GetOrderedByLevels)",1,,610,1,,void
18216,BLOCK,-1,,"{
  do {
    ASSERT_OK(Put(""foo"", ""v1""));
    Compact(""a"", ""z"");
    ASSERT_EQ(""v1"", Get(""foo""));
    ASSERT_OK(Put(""foo"", ""v2""));
    ASSERT_EQ(""v2"", Get(""foo""));
    dbfull()->TEST_CompactMemTable();
    ASSERT_EQ(""v2"", Get(""foo""));
  } while (ChangeOptions());
}",34,,610,1,,void
18218,BLOCK,-1,,"{
    ASSERT_OK(Put(""foo"", ""v1""));
    Compact(""a"", ""z"");
    ASSERT_EQ(""v1"", Get(""foo""));
    ASSERT_OK(Put(""foo"", ""v2""));
    ASSERT_EQ(""v2"", Get(""foo""));
    dbfull()->TEST_CompactMemTable();
    ASSERT_EQ(""v2"", Get(""foo""));
  }",6,,611,1,,void
18220,BLOCK,1,,<empty>,,,,1,,void
18242,BLOCK,1,,<empty>,,,,3,,void
18258,BLOCK,1,,<empty>,,,,1,,void
18277,BLOCK,1,,<empty>,,,,3,,void
18300,BLOCK,1,,<empty>,,,,3,,void
18320,BLOCK,-1,,<empty>,,,,1,,<empty>
18324,BLOCK,-1,,"TEST(DBTest, GetPicksCorrectFile)",1,,622,1,,void
18348,BLOCK,-1,,"{
  do {
    // Arrange to have multiple files in a non-level-0 level.
    ASSERT_OK(Put(""a"", ""va""));
    Compact(""a"", ""b"");
    ASSERT_OK(Put(""x"", ""vx""));
    Compact(""x"", ""y"");
    ASSERT_OK(Put(""f"", ""vf""));
    Compact(""f"", ""g"");
    ASSERT_EQ(""va"", Get(""a""));
    ASSERT_EQ(""vf"", Get(""f""));
    ASSERT_EQ(""vx"", Get(""x""));
  } while (ChangeOptions());
}",35,,622,1,,void
18350,BLOCK,-1,,"{
    // Arrange to have multiple files in a non-level-0 level.
    ASSERT_OK(Put(""a"", ""va""));
    Compact(""a"", ""b"");
    ASSERT_OK(Put(""x"", ""vx""));
    Compact(""x"", ""y"");
    ASSERT_OK(Put(""f"", ""vf""));
    Compact(""f"", ""g"");
    ASSERT_EQ(""va"", Get(""a""));
    ASSERT_EQ(""vf"", Get(""f""));
    ASSERT_EQ(""vx"", Get(""x""));
  }",6,,623,1,,void
18352,BLOCK,1,,<empty>,,,,1,,void
18371,BLOCK,1,,<empty>,,,,1,,void
18390,BLOCK,1,,<empty>,,,,1,,void
18412,BLOCK,1,,<empty>,,,,3,,void
18431,BLOCK,1,,<empty>,,,,3,,void
18450,BLOCK,1,,<empty>,,,,3,,void
18470,BLOCK,-1,,<empty>,,,,1,,<empty>
18474,BLOCK,-1,,"TEST(DBTest, GetEncountersEmptyLevel)",1,,637,1,,void
18498,BLOCK,-1,,"{
  do {
    // Arrange for the following to happen:
    //   * sstable A in level 0
    //   * nothing in level 1
    //   * sstable B in level 2
    // Then do enough Get() calls to arrange for an automatic compaction
    // of sstable A.  A bug would cause the compaction to be marked as
    // occurring at level 1 (instead of the correct level 0).

    // Step 1: First place sstables in levels 0 and 2
    int compaction_count = 0;
    while (NumTableFilesAtLevel(0) == 0 ||
           NumTableFilesAtLevel(2) == 0) {
      ASSERT_LE(compaction_count, 100) << ""could not fill levels 0 and 2"";
      compaction_count++;
      Put(""a"", ""begin"");
      Put(""z"", ""end"");
      dbfull()->TEST_CompactMemTable();
    }

    // Step 2: clear level 1 if necessary.
    dbfull()->TEST_CompactRange(1, NULL, NULL);
    ASSERT_EQ(NumTableFilesAtLevel(0), 1);
    ASSERT_EQ(NumTableFilesAtLevel(1), 0);
    ASSERT_EQ(NumTableFilesAtLevel(2), 1);

    // Step 3: read a bunch of times
    for (int i = 0;...",39,,637,1,,void
18500,BLOCK,-1,,"{
    // Arrange for the following to happen:
    //   * sstable A in level 0
    //   * nothing in level 1
    //   * sstable B in level 2
    // Then do enough Get() calls to arrange for an automatic compaction
    // of sstable A.  A bug would cause the compaction to be marked as
    // occurring at level 1 (instead of the correct level 0).

    // Step 1: First place sstables in levels 0 and 2
    int compaction_count = 0;
    while (NumTableFilesAtLevel(0) == 0 ||
           NumTableFilesAtLevel(2) == 0) {
      ASSERT_LE(compaction_count, 100) << ""could not fill levels 0 and 2"";
      compaction_count++;
      Put(""a"", ""begin"");
      Put(""z"", ""end"");
      dbfull()->TEST_CompactMemTable();
    }

    // Step 2: clear level 1 if necessary.
    dbfull()->TEST_CompactRange(1, NULL, NULL);
    ASSERT_EQ(NumTableFilesAtLevel(0), 1);
    ASSERT_EQ(NumTableFilesAtLevel(1), 0);
    ASSERT_EQ(NumTableFilesAtLevel(2), 1);

    // Step 3: read a bunch of times
    for (int i = 0; i < 10...",6,,638,1,,void
18515,BLOCK,-1,,"{
      ASSERT_LE(compaction_count, 100) << ""could not fill levels 0 and 2"";
      compaction_count++;
      Put(""a"", ""begin"");
      Put(""z"", ""end"");
      dbfull()->TEST_CompactMemTable();
    }",42,,650,2,,void
18520,BLOCK,1,,<empty>,,,,4,,void
18558,BLOCK,1,,<empty>,,,,3,,void
18577,BLOCK,1,,<empty>,,,,3,,void
18596,BLOCK,1,,<empty>,,,,3,,void
18612,BLOCK,-1,,<empty>,5,,665,1,,void
18622,BLOCK,4,,"{
      ASSERT_EQ(""NOT_FOUND"", Get(""missing""));
    }",36,,665,4,,void
18627,BLOCK,1,,<empty>,,,,3,,void
18648,BLOCK,1,,<empty>,,,,3,,void
18668,BLOCK,-1,,<empty>,,,,1,,<empty>
18672,BLOCK,-1,,"TEST(DBTest, IterEmpty)",1,,676,1,,void
18696,BLOCK,-1,,"{
  Iterator* iter = db_->NewIterator(ReadOptions());

  iter->SeekToFirst();
  ASSERT_EQ(IterStatus(iter), ""(invalid)"");

  iter->SeekToLast();
  ASSERT_EQ(IterStatus(iter), ""(invalid)"");

  iter->Seek(""foo"");
  ASSERT_EQ(IterStatus(iter), ""(invalid)"");

  delete iter;
}",25,,676,1,,void
18713,BLOCK,1,,<empty>,,,,4,,void
18736,BLOCK,1,,<empty>,,,,4,,void
18760,BLOCK,1,,<empty>,,,,4,,void
18781,BLOCK,-1,,<empty>,,,,1,,<empty>
18785,BLOCK,-1,,"TEST(DBTest, IterSingle)",1,,691,1,,void
18809,BLOCK,-1,,"{
  ASSERT_OK(Put(""a"", ""va""));
  Iterator* iter = db_->NewIterator(ReadOptions());

  iter->SeekToFirst();
  ASSERT_EQ(IterStatus(iter), ""a->va"");
  iter->Next();
  ASSERT_EQ(IterStatus(iter), ""(invalid)"");
  iter->SeekToFirst();
  ASSERT_EQ(IterStatus(iter), ""a->va"");
  iter->Prev();
  ASSERT_EQ(IterStatus(iter), ""(invalid)"");

  iter->SeekToLast();
  ASSERT_EQ(IterStatus(iter), ""a->va"");
  iter->Next();
  ASSERT_EQ(IterStatus(iter), ""(invalid)"");
  iter->SeekToLast();
  ASSERT_EQ(IterStatus(iter), ""a->va"");
  iter->Prev();
  ASSERT_EQ(IterStatus(iter), ""(invalid)"");

  iter->Seek("""");
  ASSERT_EQ(IterStatus(iter), ""a->va"");
  iter->Next();
  ASSERT_EQ(IterStatus(iter), ""(invalid)"");

  iter->Seek(""a"");
  ASSERT_EQ(IterStatus(iter), ""a->va"");
  iter->Next();
  ASSERT_EQ(IterStatus(iter), ""(invalid)"");

  iter->Seek(""b"");
  ASSERT_EQ(IterStatus(iter), ""(invalid)"");

  delete iter;
}",26,,691,1,,void
18811,BLOCK,1,,<empty>,,,,1,,void
18842,BLOCK,1,,<empty>,,,,4,,void
18865,BLOCK,1,,<empty>,,,,4,,void
18888,BLOCK,1,,<empty>,,,,4,,void
18911,BLOCK,1,,<empty>,,,,4,,void
18934,BLOCK,1,,<empty>,,,,4,,void
18957,BLOCK,1,,<empty>,,,,4,,void
18980,BLOCK,1,,<empty>,,,,4,,void
19003,BLOCK,1,,<empty>,,,,4,,void
19027,BLOCK,1,,<empty>,,,,4,,void
19050,BLOCK,1,,<empty>,,,,4,,void
19074,BLOCK,1,,<empty>,,,,4,,void
19097,BLOCK,1,,<empty>,,,,4,,void
19121,BLOCK,1,,<empty>,,,,4,,void
19142,BLOCK,-1,,<empty>,,,,1,,<empty>
19146,BLOCK,-1,,"TEST(DBTest, IterMulti)",1,,729,1,,void
19170,BLOCK,-1,,"{
  ASSERT_OK(Put(""a"", ""va""));
  ASSERT_OK(Put(""b"", ""vb""));
  ASSERT_OK(Put(""c"", ""vc""));
  Iterator* iter = db_->NewIterator(ReadOptions());

  iter->SeekToFirst();
  ASSERT_EQ(IterStatus(iter), ""a->va"");
  iter->Next();
  ASSERT_EQ(IterStatus(iter), ""b->vb"");
  iter->Next();
  ASSERT_EQ(IterStatus(iter), ""c->vc"");
  iter->Next();
  ASSERT_EQ(IterStatus(iter), ""(invalid)"");
  iter->SeekToFirst();
  ASSERT_EQ(IterStatus(iter), ""a->va"");
  iter->Prev();
  ASSERT_EQ(IterStatus(iter), ""(invalid)"");

  iter->SeekToLast();
  ASSERT_EQ(IterStatus(iter), ""c->vc"");
  iter->Prev();
  ASSERT_EQ(IterStatus(iter), ""b->vb"");
  iter->Prev();
  ASSERT_EQ(IterStatus(iter), ""a->va"");
  iter->Prev();
  ASSERT_EQ(IterStatus(iter), ""(invalid)"");
  iter->SeekToLast();
  ASSERT_EQ(IterStatus(iter), ""c->vc"");
  iter->Next();
  ASSERT_EQ(IterStatus(iter), ""(invalid)"");

  iter->Seek("""");
  ASSERT_EQ(IterStatus(iter), ""a->va"");
  iter->Seek(""a"");
  ASSERT_EQ(IterStatus(iter), ""a->va"");
  iter->Seek(""ax"");
  ...",25,,729,1,,void
19172,BLOCK,1,,<empty>,,,,1,,void
19188,BLOCK,1,,<empty>,,,,1,,void
19204,BLOCK,1,,<empty>,,,,1,,void
19235,BLOCK,1,,<empty>,,,,4,,void
19258,BLOCK,1,,<empty>,,,,4,,void
19281,BLOCK,1,,<empty>,,,,4,,void
19304,BLOCK,1,,<empty>,,,,4,,void
19327,BLOCK,1,,<empty>,,,,4,,void
19350,BLOCK,1,,<empty>,,,,4,,void
19373,BLOCK,1,,<empty>,,,,4,,void
19396,BLOCK,1,,<empty>,,,,4,,void
19419,BLOCK,1,,<empty>,,,,4,,void
19442,BLOCK,1,,<empty>,,,,4,,void
19465,BLOCK,1,,<empty>,,,,4,,void
19488,BLOCK,1,,<empty>,,,,4,,void
19512,BLOCK,1,,<empty>,,,,4,,void
19536,BLOCK,1,,<empty>,,,,4,,void
19560,BLOCK,1,,<empty>,,,,4,,void
19584,BLOCK,1,,<empty>,,,,4,,void
19608,BLOCK,1,,<empty>,,,,4,,void
19643,BLOCK,1,,<empty>,,,,4,,void
19678,BLOCK,1,,<empty>,,,,4,,void
19694,BLOCK,1,,<empty>,,,,1,,void
19710,BLOCK,1,,<empty>,,,,1,,void
19726,BLOCK,1,,<empty>,,,,1,,void
19742,BLOCK,1,,<empty>,,,,1,,void
19760,BLOCK,1,,<empty>,,,,2,,void
19782,BLOCK,1,,<empty>,,,,4,,void
19805,BLOCK,1,,<empty>,,,,4,,void
19828,BLOCK,1,,<empty>,,,,4,,void
19851,BLOCK,1,,<empty>,,,,4,,void
19874,BLOCK,1,,<empty>,,,,4,,void
19897,BLOCK,1,,<empty>,,,,4,,void
19920,BLOCK,1,,<empty>,,,,4,,void
19943,BLOCK,1,,<empty>,,,,4,,void
19964,BLOCK,-1,,<empty>,,,,1,,<empty>
19968,BLOCK,-1,,"TEST(DBTest, IterSmallAndLargeMix)",1,,812,1,,void
19992,BLOCK,-1,,"{
  ASSERT_OK(Put(""a"", ""va""));
  ASSERT_OK(Put(""b"", std::string(100000, 'b')));
  ASSERT_OK(Put(""c"", ""vc""));
  ASSERT_OK(Put(""d"", std::string(100000, 'd')));
  ASSERT_OK(Put(""e"", std::string(100000, 'e')));

  Iterator* iter = db_->NewIterator(ReadOptions());

  iter->SeekToFirst();
  ASSERT_EQ(IterStatus(iter), ""a->va"");
  iter->Next();
  ASSERT_EQ(IterStatus(iter), ""b->"" + std::string(100000, 'b'));
  iter->Next();
  ASSERT_EQ(IterStatus(iter), ""c->vc"");
  iter->Next();
  ASSERT_EQ(IterStatus(iter), ""d->"" + std::string(100000, 'd'));
  iter->Next();
  ASSERT_EQ(IterStatus(iter), ""e->"" + std::string(100000, 'e'));
  iter->Next();
  ASSERT_EQ(IterStatus(iter), ""(invalid)"");

  iter->SeekToLast();
  ASSERT_EQ(IterStatus(iter), ""e->"" + std::string(100000, 'e'));
  iter->Prev();
  ASSERT_EQ(IterStatus(iter), ""d->"" + std::string(100000, 'd'));
  iter->Prev();
  ASSERT_EQ(IterStatus(iter), ""c->vc"");
  iter->Prev();
  ASSERT_EQ(IterStatus(iter), ""b->"" + std::string(100000, 'b'));
  iter->...",36,,812,1,,void
19994,BLOCK,1,,<empty>,,,,1,,void
20010,BLOCK,1,,<empty>,,,,1,,void
20031,BLOCK,1,,<empty>,,,,1,,void
20047,BLOCK,1,,<empty>,,,,1,,void
20068,BLOCK,1,,<empty>,,,,1,,void
20104,BLOCK,1,,<empty>,,,,4,,void
20126,BLOCK,1,,<empty>,,,,3,,void
20156,BLOCK,1,,<empty>,,,,4,,void
20178,BLOCK,1,,<empty>,,,,3,,void
20207,BLOCK,1,,<empty>,,,,3,,void
20237,BLOCK,1,,<empty>,,,,4,,void
20259,BLOCK,1,,<empty>,,,,3,,void
20288,BLOCK,1,,<empty>,,,,3,,void
20318,BLOCK,1,,<empty>,,,,4,,void
20340,BLOCK,1,,<empty>,,,,3,,void
20370,BLOCK,1,,<empty>,,,,4,,void
20393,BLOCK,1,,<empty>,,,,4,,void
20414,BLOCK,-1,,<empty>,,,,1,,<empty>
20418,BLOCK,-1,,"TEST(DBTest, IterMultiWithDelete)",1,,850,1,,void
20442,BLOCK,-1,,"{
  do {
    ASSERT_OK(Put(""a"", ""va""));
    ASSERT_OK(Put(""b"", ""vb""));
    ASSERT_OK(Put(""c"", ""vc""));
    ASSERT_OK(Delete(""b""));
    ASSERT_EQ(""NOT_FOUND"", Get(""b""));

    Iterator* iter = db_->NewIterator(ReadOptions());
    iter->Seek(""c"");
    ASSERT_EQ(IterStatus(iter), ""c->vc"");
    iter->Prev();
    ASSERT_EQ(IterStatus(iter), ""a->va"");
    delete iter;
  } while (ChangeOptions());
}",35,,850,1,,void
20444,BLOCK,-1,,"{
    ASSERT_OK(Put(""a"", ""va""));
    ASSERT_OK(Put(""b"", ""vb""));
    ASSERT_OK(Put(""c"", ""vc""));
    ASSERT_OK(Delete(""b""));
    ASSERT_EQ(""NOT_FOUND"", Get(""b""));

    Iterator* iter = db_->NewIterator(ReadOptions());
    iter->Seek(""c"");
    ASSERT_EQ(IterStatus(iter), ""c->vc"");
    iter->Prev();
    ASSERT_EQ(IterStatus(iter), ""a->va"");
    delete iter;
  }",6,,851,1,,void
20446,BLOCK,1,,<empty>,,,,1,,void
20462,BLOCK,1,,<empty>,,,,1,,void
20478,BLOCK,1,,<empty>,,,,1,,void
20496,BLOCK,1,,<empty>,,,,2,,void
20514,BLOCK,1,,<empty>,,,,3,,void
20546,BLOCK,1,,<empty>,,,,4,,void
20569,BLOCK,1,,<empty>,,,,4,,void
20591,BLOCK,-1,,<empty>,,,,1,,<empty>
20595,BLOCK,-1,,"TEST(DBTest, Recover)",1,,867,1,,void
20619,BLOCK,-1,,"{
  do {
    ASSERT_OK(Put(""foo"", ""v1""));
    ASSERT_OK(Put(""baz"", ""v5""));

    Reopen();
    ASSERT_EQ(""v1"", Get(""foo""));

    ASSERT_EQ(""v1"", Get(""foo""));
    ASSERT_EQ(""v5"", Get(""baz""));
    ASSERT_OK(Put(""bar"", ""v2""));
    ASSERT_OK(Put(""foo"", ""v3""));

    Reopen();
    ASSERT_EQ(""v3"", Get(""foo""));
    ASSERT_OK(Put(""foo"", ""v4""));
    ASSERT_EQ(""v4"", Get(""foo""));
    ASSERT_EQ(""v2"", Get(""bar""));
    ASSERT_EQ(""v5"", Get(""baz""));
  } while (ChangeOptions());
}",23,,867,1,,void
20621,BLOCK,-1,,"{
    ASSERT_OK(Put(""foo"", ""v1""));
    ASSERT_OK(Put(""baz"", ""v5""));

    Reopen();
    ASSERT_EQ(""v1"", Get(""foo""));

    ASSERT_EQ(""v1"", Get(""foo""));
    ASSERT_EQ(""v5"", Get(""baz""));
    ASSERT_OK(Put(""bar"", ""v2""));
    ASSERT_OK(Put(""foo"", ""v3""));

    Reopen();
    ASSERT_EQ(""v3"", Get(""foo""));
    ASSERT_OK(Put(""foo"", ""v4""));
    ASSERT_EQ(""v4"", Get(""foo""));
    ASSERT_EQ(""v2"", Get(""bar""));
    ASSERT_EQ(""v5"", Get(""baz""));
  }",6,,868,1,,void
20623,BLOCK,1,,<empty>,,,,1,,void
20639,BLOCK,1,,<empty>,,,,1,,void
20659,BLOCK,1,,<empty>,,,,3,,void
20678,BLOCK,1,,<empty>,,,,3,,void
20697,BLOCK,1,,<empty>,,,,3,,void
20713,BLOCK,1,,<empty>,,,,1,,void
20729,BLOCK,1,,<empty>,,,,1,,void
20749,BLOCK,1,,<empty>,,,,3,,void
20765,BLOCK,1,,<empty>,,,,1,,void
20784,BLOCK,1,,<empty>,,,,3,,void
20803,BLOCK,1,,<empty>,,,,3,,void
20822,BLOCK,1,,<empty>,,,,3,,void
20842,BLOCK,-1,,<empty>,,,,1,,<empty>
20846,BLOCK,-1,,"TEST(DBTest, RecoveryWithEmptyLog)",1,,889,1,,void
20870,BLOCK,-1,,"{
  do {
    ASSERT_OK(Put(""foo"", ""v1""));
    ASSERT_OK(Put(""foo"", ""v2""));
    Reopen();
    Reopen();
    ASSERT_OK(Put(""foo"", ""v3""));
    Reopen();
    ASSERT_EQ(""v3"", Get(""foo""));
  } while (ChangeOptions());
}",36,,889,1,,void
20872,BLOCK,-1,,"{
    ASSERT_OK(Put(""foo"", ""v1""));
    ASSERT_OK(Put(""foo"", ""v2""));
    Reopen();
    Reopen();
    ASSERT_OK(Put(""foo"", ""v3""));
    Reopen();
    ASSERT_EQ(""v3"", Get(""foo""));
  }",6,,890,1,,void
20874,BLOCK,1,,<empty>,,,,1,,void
20890,BLOCK,1,,<empty>,,,,1,,void
20908,BLOCK,1,,<empty>,,,,1,,void
20928,BLOCK,1,,<empty>,,,,3,,void
20948,BLOCK,-1,,<empty>,,,,1,,<empty>
20952,BLOCK,-1,,"TEST(DBTest, RecoverDuringMemtableCompaction)",1,,903,1,,void
20976,BLOCK,-1,,"{
  do {
    Options options = CurrentOptions();
    options.env = env_;
    options.write_buffer_size = 1000000;
    Reopen(&options);

    // Trigger a long memtable compaction and reopen the database during it
    ASSERT_OK(Put(""foo"", ""v1""));                         // Goes to 1st log file
    ASSERT_OK(Put(""big1"", std::string(10000000, 'x')));  // Fills memtable
    ASSERT_OK(Put(""big2"", std::string(1000, 'y')));      // Triggers compaction
    ASSERT_OK(Put(""bar"", ""v2""));                         // Goes to new log file

    Reopen(&options);
    ASSERT_EQ(""v1"", Get(""foo""));
    ASSERT_EQ(""v2"", Get(""bar""));
    ASSERT_EQ(std::string(10000000, 'x'), Get(""big1""));
    ASSERT_EQ(std::string(1000, 'y'), Get(""big2""));
  } while (ChangeOptions());
}",47,,903,1,,void
20978,BLOCK,-1,,"{
    Options options = CurrentOptions();
    options.env = env_;
    options.write_buffer_size = 1000000;
    Reopen(&options);

    // Trigger a long memtable compaction and reopen the database during it
    ASSERT_OK(Put(""foo"", ""v1""));                         // Goes to 1st log file
    ASSERT_OK(Put(""big1"", std::string(10000000, 'x')));  // Fills memtable
    ASSERT_OK(Put(""big2"", std::string(1000, 'y')));      // Triggers compaction
    ASSERT_OK(Put(""bar"", ""v2""));                         // Goes to new log file

    Reopen(&options);
    ASSERT_EQ(""v1"", Get(""foo""));
    ASSERT_EQ(""v2"", Get(""bar""));
    ASSERT_EQ(std::string(10000000, 'x'), Get(""big1""));
    ASSERT_EQ(std::string(1000, 'y'), Get(""big2""));
  }",6,,904,1,,void
20997,BLOCK,1,,<empty>,,,,1,,void
21013,BLOCK,1,,<empty>,,,,1,,void
21034,BLOCK,1,,<empty>,,,,1,,void
21055,BLOCK,1,,<empty>,,,,1,,void
21077,BLOCK,1,,<empty>,,,,3,,void
21096,BLOCK,1,,<empty>,,,,3,,void
21114,BLOCK,1,,<empty>,,,,2,,void
21137,BLOCK,1,,<empty>,,,,2,,void
21162,BLOCK,-1,,"{
  char buf[100];
  snprintf(buf, sizeof(buf), ""key%06d"", i);
  return std::string(buf);
}",31,,924,2,,void
21180,BLOCK,-1,,<empty>,,,,1,,<empty>
21184,BLOCK,-1,,"TEST(DBTest, MinorCompactionsHappen)",1,,930,1,,void
21208,BLOCK,-1,,"{
  Options options = CurrentOptions();
  options.write_buffer_size = 10000;
  Reopen(&options);

  const int N = 500;

  int starting_num_tables = TotalTableFiles();
  for (int i = 0; i < N; i++) {
    ASSERT_OK(Put(Key(i), Key(i) + std::string(1000, 'v')));
  }
  int ending_num_tables = TotalTableFiles();
  ASSERT_GT(ending_num_tables, starting_num_tables);

  for (int i = 0; i < N; i++) {
    ASSERT_EQ(Key(i) + std::string(1000, 'v'), Get(Key(i)));
  }

  Reopen();

  for (int i = 0; i < N; i++) {
    ASSERT_EQ(Key(i) + std::string(1000, 'v'), Get(Key(i)));
  }
}",38,,930,1,,void
21230,BLOCK,-1,,<empty>,3,,938,1,,void
21240,BLOCK,4,,"{
    ASSERT_OK(Put(Key(i), Key(i) + std::string(1000, 'v')));
  }",31,,938,4,,void
21242,BLOCK,1,,<empty>,,,,1,,void
21273,BLOCK,1,,<empty>,,,,5,,void
21288,BLOCK,-1,,<empty>,3,,944,1,,void
21298,BLOCK,4,,"{
    ASSERT_EQ(Key(i) + std::string(1000, 'v'), Get(Key(i)));
  }",31,,944,4,,void
21303,BLOCK,1,,<empty>,,,,2,,void
21329,BLOCK,-1,,<empty>,3,,950,1,,void
21339,BLOCK,4,,"{
    ASSERT_EQ(Key(i) + std::string(1000, 'v'), Get(Key(i)));
  }",31,,950,4,,void
21344,BLOCK,1,,<empty>,,,,2,,void
21372,BLOCK,-1,,<empty>,,,,1,,<empty>
21376,BLOCK,-1,,"TEST(DBTest, RecoverWithLargeLog)",1,,955,1,,void
21400,BLOCK,-1,,"{
  {
    Options options = CurrentOptions();
    Reopen(&options);
    ASSERT_OK(Put(""big1"", std::string(200000, '1')));
    ASSERT_OK(Put(""big2"", std::string(200000, '2')));
    ASSERT_OK(Put(""small3"", std::string(10, '3')));
    ASSERT_OK(Put(""small4"", std::string(10, '4')));
    ASSERT_EQ(NumTableFilesAtLevel(0), 0);
  }

  // Make sure that if we re-open with a small write buffer size that
  // we flush table files in the middle of a large log file.
  Options options = CurrentOptions();
  options.write_buffer_size = 100000;
  Reopen(&options);
  ASSERT_EQ(NumTableFilesAtLevel(0), 3);
  ASSERT_EQ(std::string(200000, '1'), Get(""big1""));
  ASSERT_EQ(std::string(200000, '2'), Get(""big2""));
  ASSERT_EQ(std::string(10, '3'), Get(""small3""));
  ASSERT_EQ(std::string(10, '4'), Get(""small4""));
  ASSERT_GT(NumTableFilesAtLevel(0), 1);
}",35,,955,1,,void
21401,BLOCK,1,,"{
    Options options = CurrentOptions();
    Reopen(&options);
    ASSERT_OK(Put(""big1"", std::string(200000, '1')));
    ASSERT_OK(Put(""big2"", std::string(200000, '2')));
    ASSERT_OK(Put(""small3"", std::string(10, '3')));
    ASSERT_OK(Put(""small4"", std::string(10, '4')));
    ASSERT_EQ(NumTableFilesAtLevel(0), 0);
  }",3,,956,1,,void
21410,BLOCK,1,,<empty>,,,,1,,void
21431,BLOCK,1,,<empty>,,,,1,,void
21452,BLOCK,1,,<empty>,,,,1,,void
21473,BLOCK,1,,<empty>,,,,1,,void
21497,BLOCK,1,,<empty>,,,,3,,void
21528,BLOCK,1,,<empty>,,,,3,,void
21546,BLOCK,1,,<empty>,,,,2,,void
21569,BLOCK,1,,<empty>,,,,2,,void
21592,BLOCK,1,,<empty>,,,,2,,void
21615,BLOCK,1,,<empty>,,,,2,,void
21639,BLOCK,1,,<empty>,,,,3,,void
21658,BLOCK,-1,,<empty>,,,,1,,<empty>
21662,BLOCK,-1,,"TEST(DBTest, CompactionsGenerateMultipleFiles)",1,,979,1,,void
21686,BLOCK,-1,,"{
  Options options = CurrentOptions();
  options.write_buffer_size = 100000000;        // Large write buffer
  Reopen(&options);

  Random rnd(301);

  // Write 8MB (80 values, each 100K)
  ASSERT_EQ(NumTableFilesAtLevel(0), 0);
  std::vector<std::string> values;
  for (int i = 0; i < 80; i++) {
    values.push_back(RandomString(&rnd, 100000));
    ASSERT_OK(Put(Key(i), values[i]));
  }

  // Reopening moves updates to level-0
  Reopen(&options);
  dbfull()->TEST_CompactRange(0, NULL, NULL);

  ASSERT_EQ(NumTableFilesAtLevel(0), 0);
  ASSERT_GT(NumTableFilesAtLevel(1), 1);
  for (int i = 0; i < 80; i++) {
    ASSERT_EQ(Get(Key(i)), values[i]);
  }
}",48,,979,1,,void
21706,BLOCK,1,,<empty>,,,,3,,void
21731,BLOCK,-1,,<empty>,3,,989,1,,void
21741,BLOCK,4,,"{
    values.push_back(RandomString(&rnd, 100000));
    ASSERT_OK(Put(Key(i), values[i]));
  }",32,,989,4,,void
21751,BLOCK,1,,<empty>,,,,1,,void
21783,BLOCK,1,,<empty>,,,,3,,void
21802,BLOCK,1,,<empty>,,,,3,,void
21818,BLOCK,-1,,<empty>,3,,1000,1,,void
21828,BLOCK,4,,"{
    ASSERT_EQ(Get(Key(i)), values[i]);
  }",32,,1000,4,,void
21836,BLOCK,1,,<empty>,,,,3,,void
21858,BLOCK,-1,,<empty>,,,,1,,<empty>
21862,BLOCK,-1,,"TEST(DBTest, RepeatedWritesToSameKey)",1,,1005,1,,void
21886,BLOCK,-1,,"{
  Options options = CurrentOptions();
  options.env = env_;
  options.write_buffer_size = 100000;  // Small write buffer
  Reopen(&options);

  // We must have at most one file per level except for level-0,
  // which may have up to kL0_StopWritesTrigger files.
  const int kMaxFiles = config::kNumLevels + config::kL0_StopWritesTrigger;

  Random rnd(301);
  std::string value = RandomString(&rnd, 2 * options.write_buffer_size);
  for (int i = 0; i < 5 * kMaxFiles; i++) {
    Put(""key"", value);
    ASSERT_LE(TotalTableFiles(), kMaxFiles);
    fprintf(stderr, ""after %d: %d files\n"", int(i+1), TotalTableFiles());
  }
}",39,,1005,1,,void
21929,BLOCK,-1,,<empty>,3,,1017,1,,void
21941,BLOCK,4,,"{
    Put(""key"", value);
    ASSERT_LE(TotalTableFiles(), kMaxFiles);
    fprintf(stderr, ""after %d: %d files\n"", int(i+1), TotalTableFiles());
  }",43,,1017,4,,void
21948,BLOCK,1,,<empty>,,,,4,,void
21975,BLOCK,-1,,<empty>,,,,1,,<empty>
21979,BLOCK,-1,,"TEST(DBTest, SparseMerge)",1,,1024,1,,void
22003,BLOCK,-1,,"{
  Options options = CurrentOptions();
  options.compression = kNoCompression;
  Reopen(&options);

  FillLevels(""A"", ""Z"");

  // Suppose there is:
  //    small amount of data with prefix A
  //    large amount of data with prefix B
  //    small amount of data with prefix C
  // and that recent updates have made small changes to all three prefixes.
  // Check that we do not do a compaction that merges all of B in one shot.
  const std::string value(1000, 'x');
  Put(""A"", ""va"");
  // Write approximately 100MB of ""B"" values
  for (int i = 0; i < 100000; i++) {
    char key[100];
    snprintf(key, sizeof(key), ""B%010d"", i);
    Put(key, value);
  }
  Put(""C"", ""vc"");
  dbfull()->TEST_CompactMemTable();
  dbfull()->TEST_CompactRange(0, NULL, NULL);

  // Make sparse update
  Put(""A"",    ""va2"");
  Put(""B100"", ""bvalue2"");
  Put(""C"",    ""vc2"");
  dbfull()->TEST_CompactMemTable();

  // Compactions should not cause us to create a situation where
  // a file overlaps too much data at the n...",27,,1024,1,,void
22027,BLOCK,-1,,<empty>,3,,1040,1,,void
22037,BLOCK,4,,"{
    char key[100];
    snprintf(key, sizeof(key), ""B%010d"", i);
    Put(key, value);
  }",36,,1040,4,,void
22080,BLOCK,1,,<empty>,,,,2,,void
22111,BLOCK,1,,<empty>,,,,2,,void
22142,BLOCK,1,,<empty>,,,,2,,void
22167,BLOCK,-1,,"{
  bool result = (val >= low) && (val <= high);
  if (!result) {
    fprintf(stderr, ""Value %llu is not in range [%llu, %llu]\n"",
            (unsigned long long)(val),
            (unsigned long long)(low),
            (unsigned long long)(high));
  }
  return result;
}",64,,1064,4,,void
22181,BLOCK,-1,,"{
    fprintf(stderr, ""Value %llu is not in range [%llu, %llu]\n"",
            (unsigned long long)(val),
            (unsigned long long)(low),
            (unsigned long long)(high));
  }",16,,1066,2,,void
22200,BLOCK,-1,,<empty>,,,,1,,<empty>
22204,BLOCK,-1,,"TEST(DBTest, ApproximateSizes)",1,,1075,1,,void
22228,BLOCK,-1,,"{
  do {
    Options options = CurrentOptions();
    options.write_buffer_size = 100000000;        // Large write buffer
    options.compression = kNoCompression;
    DestroyAndReopen();

    ASSERT_TRUE(Between(Size("""", ""xyz""), 0, 0));
    Reopen(&options);
    ASSERT_TRUE(Between(Size("""", ""xyz""), 0, 0));

    // Write 8MB (80 values, each 100K)
    ASSERT_EQ(NumTableFilesAtLevel(0), 0);
    const int N = 80;
    static const int S1 = 100000;
    static const int S2 = 105000;  // Allow some expansion from metadata
    Random rnd(301);
    for (int i = 0; i < N; i++) {
      ASSERT_OK(Put(Key(i), RandomString(&rnd, S1)));
    }

    // 0 because GetApproximateSizes() does not account for memtable space
    ASSERT_TRUE(Between(Size("""", Key(50)), 0, 0));

    if (options.reuse_logs) {
      // Recovery will reuse memtable, and GetApproximateSizes() does not
      // account for memtable usage;
      Reopen(&options);
      ASSERT_TRUE(Between(Size("""", Key(50)), 0, 0));
      continue;...",32,,1075,1,,void
22230,BLOCK,-1,,"{
    Options options = CurrentOptions();
    options.write_buffer_size = 100000000;        // Large write buffer
    options.compression = kNoCompression;
    DestroyAndReopen();

    ASSERT_TRUE(Between(Size("""", ""xyz""), 0, 0));
    Reopen(&options);
    ASSERT_TRUE(Between(Size("""", ""xyz""), 0, 0));

    // Write 8MB (80 values, each 100K)
    ASSERT_EQ(NumTableFilesAtLevel(0), 0);
    const int N = 80;
    static const int S1 = 100000;
    static const int S2 = 105000;  // Allow some expansion from metadata
    Random rnd(301);
    for (int i = 0; i < N; i++) {
      ASSERT_OK(Put(Key(i), RandomString(&rnd, S1)));
    }

    // 0 because GetApproximateSizes() does not account for memtable space
    ASSERT_TRUE(Between(Size("""", Key(50)), 0, 0));

    if (options.reuse_logs) {
      // Recovery will reuse memtable, and GetApproximateSizes() does not
      // account for memtable usage;
      Reopen(&options);
      ASSERT_TRUE(Between(Size("""", Key(50)), 0, 0));
      continue;
    }
...",6,,1076,1,,void
22247,BLOCK,1,,<empty>,,,,1,,void
22270,BLOCK,1,,<empty>,,,,1,,void
22293,BLOCK,1,,<empty>,,,,3,,void
22324,BLOCK,-1,,<empty>,5,,1092,1,,void
22334,BLOCK,4,,"{
      ASSERT_OK(Put(Key(i), RandomString(&rnd, S1)));
    }",33,,1092,4,,void
22336,BLOCK,1,,<empty>,,,,3,,void
22356,BLOCK,1,,<empty>,,,,1,,void
22380,BLOCK,-1,,"{
      // Recovery will reuse memtable, and GetApproximateSizes() does not
      // account for memtable usage;
      Reopen(&options);
      ASSERT_TRUE(Between(Size("""", Key(50)), 0, 0));
      continue;
    }",29,,1099,2,,void
22385,BLOCK,1,,<empty>,,,,1,,void
22407,BLOCK,-1,,<empty>,5,,1108,1,,void
22417,BLOCK,4,,"{
      Reopen(&options);

      for (int compact_start = 0; compact_start < N; compact_start += 10) {
        for (int i = 0; i < N; i += 10) {
          ASSERT_TRUE(Between(Size("""", Key(i)), S1*i, S2*i));
          ASSERT_TRUE(Between(Size("""", Key(i)+"".suffix""), S1*(i+1), S2*(i+1)));
          ASSERT_TRUE(Between(Size(Key(i), Key(i+10)), S1*10, S2*10));
        }
        ASSERT_TRUE(Between(Size("""", Key(50)), S1*50, S2*50));
        ASSERT_TRUE(Between(Size("""", Key(50)+"".suffix""), S1*50, S2*50));

        std::string cstart_str = Key(compact_start);
        std::string cend_str = Key(compact_start + 9);
        Slice cstart = cstart_str;
        Slice cend = cend_str;
        dbfull()->TEST_CompactRange(0, &cstart, &cend);
      }

      ASSERT_EQ(NumTableFilesAtLevel(0), 0);
      ASSERT_GT(NumTableFilesAtLevel(1), 0);
    }",39,,1108,4,,void
22422,BLOCK,-1,,<empty>,7,,1111,1,,void
22433,BLOCK,4,,"{
        for (int i = 0; i < N; i += 10) {
          ASSERT_TRUE(Between(Size("""", Key(i)), S1*i, S2*i));
          ASSERT_TRUE(Between(Size("""", Key(i)+"".suffix""), S1*(i+1), S2*(i+1)));
          ASSERT_TRUE(Between(Size(Key(i), Key(i+10)), S1*10, S2*10));
        }
        ASSERT_TRUE(Between(Size("""", Key(50)), S1*50, S2*50));
        ASSERT_TRUE(Between(Size("""", Key(50)+"".suffix""), S1*50, S2*50));

        std::string cstart_str = Key(compact_start);
        std::string cend_str = Key(compact_start + 9);
        Slice cstart = cstart_str;
        Slice cend = cend_str;
        dbfull()->TEST_CompactRange(0, &cstart, &cend);
      }",75,,1111,4,,void
22435,BLOCK,-1,,<empty>,9,,1112,1,,void
22446,BLOCK,4,,"{
          ASSERT_TRUE(Between(Size("""", Key(i)), S1*i, S2*i));
          ASSERT_TRUE(Between(Size("""", Key(i)+"".suffix""), S1*(i+1), S2*(i+1)));
          ASSERT_TRUE(Between(Size(Key(i), Key(i+10)), S1*10, S2*10));
        }",41,,1112,4,,void
22448,BLOCK,1,,<empty>,,,,3,,void
22473,BLOCK,1,,<empty>,,,,3,,void
22504,BLOCK,1,,<empty>,,,,3,,void
22532,BLOCK,1,,<empty>,,,,3,,void
22557,BLOCK,1,,<empty>,,,,3,,void
22616,BLOCK,1,,<empty>,,,,3,,void
22635,BLOCK,1,,<empty>,,,,3,,void
22655,BLOCK,-1,,<empty>,,,,1,,<empty>
22659,BLOCK,-1,,"TEST(DBTest, ApproximateSizes_MixOfSmallAndLarge)",1,,1133,1,,void
22683,BLOCK,-1,,"{
  do {
    Options options = CurrentOptions();
    options.compression = kNoCompression;
    Reopen();

    Random rnd(301);
    std::string big1 = RandomString(&rnd, 100000);
    ASSERT_OK(Put(Key(0), RandomString(&rnd, 10000)));
    ASSERT_OK(Put(Key(1), RandomString(&rnd, 10000)));
    ASSERT_OK(Put(Key(2), big1));
    ASSERT_OK(Put(Key(3), RandomString(&rnd, 10000)));
    ASSERT_OK(Put(Key(4), big1));
    ASSERT_OK(Put(Key(5), RandomString(&rnd, 10000)));
    ASSERT_OK(Put(Key(6), RandomString(&rnd, 300000)));
    ASSERT_OK(Put(Key(7), RandomString(&rnd, 10000)));

    if (options.reuse_logs) {
      // Need to force a memtable compaction since recovery does not do so.
      ASSERT_OK(dbfull()->TEST_CompactMemTable());
    }

    // Check sizes across recovery by reopening a few times
    for (int run = 0; run < 3; run++) {
      Reopen(&options);

      ASSERT_TRUE(Between(Size("""", Key(0)), 0, 0));
      ASSERT_TRUE(Between(Size("""", Key(1)), 10000, 11000));
      ASSERT_TRUE(...",51,,1133,1,,void
22685,BLOCK,-1,,"{
    Options options = CurrentOptions();
    options.compression = kNoCompression;
    Reopen();

    Random rnd(301);
    std::string big1 = RandomString(&rnd, 100000);
    ASSERT_OK(Put(Key(0), RandomString(&rnd, 10000)));
    ASSERT_OK(Put(Key(1), RandomString(&rnd, 10000)));
    ASSERT_OK(Put(Key(2), big1));
    ASSERT_OK(Put(Key(3), RandomString(&rnd, 10000)));
    ASSERT_OK(Put(Key(4), big1));
    ASSERT_OK(Put(Key(5), RandomString(&rnd, 10000)));
    ASSERT_OK(Put(Key(6), RandomString(&rnd, 300000)));
    ASSERT_OK(Put(Key(7), RandomString(&rnd, 10000)));

    if (options.reuse_logs) {
      // Need to force a memtable compaction since recovery does not do so.
      ASSERT_OK(dbfull()->TEST_CompactMemTable());
    }

    // Check sizes across recovery by reopening a few times
    for (int run = 0; run < 3; run++) {
      Reopen(&options);

      ASSERT_TRUE(Between(Size("""", Key(0)), 0, 0));
      ASSERT_TRUE(Between(Size("""", Key(1)), 10000, 11000));
      ASSERT_TRUE(Between...",6,,1134,1,,void
22707,BLOCK,1,,<empty>,,,,2,,void
22727,BLOCK,1,,<empty>,,,,2,,void
22747,BLOCK,1,,<empty>,,,,2,,void
22764,BLOCK,1,,<empty>,,,,2,,void
22784,BLOCK,1,,<empty>,,,,2,,void
22801,BLOCK,1,,<empty>,,,,2,,void
22821,BLOCK,1,,<empty>,,,,2,,void
22841,BLOCK,1,,<empty>,,,,2,,void
22864,BLOCK,-1,,"{
      // Need to force a memtable compaction since recovery does not do so.
      ASSERT_OK(dbfull()->TEST_CompactMemTable());
    }",29,,1150,2,,void
22870,BLOCK,1,,<empty>,,,,2,,void
22887,BLOCK,-1,,<empty>,5,,1156,1,,void
22897,BLOCK,4,,"{
      Reopen(&options);

      ASSERT_TRUE(Between(Size("""", Key(0)), 0, 0));
      ASSERT_TRUE(Between(Size("""", Key(1)), 10000, 11000));
      ASSERT_TRUE(Between(Size("""", Key(2)), 20000, 21000));
      ASSERT_TRUE(Between(Size("""", Key(3)), 120000, 121000));
      ASSERT_TRUE(Between(Size("""", Key(4)), 130000, 131000));
      ASSERT_TRUE(Between(Size("""", Key(5)), 230000, 231000));
      ASSERT_TRUE(Between(Size("""", Key(6)), 240000, 241000));
      ASSERT_TRUE(Between(Size("""", Key(7)), 540000, 541000));
      ASSERT_TRUE(Between(Size("""", Key(8)), 550000, 560000));

      ASSERT_TRUE(Between(Size(Key(3), Key(5)), 110000, 111000));

      dbfull()->TEST_CompactRange(0, NULL, NULL);
    }",39,,1156,4,,void
22902,BLOCK,1,,<empty>,,,,1,,void
22923,BLOCK,1,,<empty>,,,,1,,void
22944,BLOCK,1,,<empty>,,,,1,,void
22965,BLOCK,1,,<empty>,,,,1,,void
22986,BLOCK,1,,<empty>,,,,1,,void
23007,BLOCK,1,,<empty>,,,,1,,void
23028,BLOCK,1,,<empty>,,,,1,,void
23049,BLOCK,1,,<empty>,,,,1,,void
23070,BLOCK,1,,<empty>,,,,1,,void
23091,BLOCK,1,,<empty>,,,,1,,void
23124,BLOCK,-1,,<empty>,,,,1,,<empty>
23128,BLOCK,-1,,"TEST(DBTest, IteratorPinsRef)",1,,1176,1,,void
23152,BLOCK,-1,,"{
  Put(""foo"", ""hello"");

  // Get iterator that will yield the current contents of the DB.
  Iterator* iter = db_->NewIterator(ReadOptions());

  // Write to force compactions
  Put(""foo"", ""newvalue1"");
  for (int i = 0; i < 100; i++) {
    ASSERT_OK(Put(Key(i), Key(i) + std::string(100000, 'v'))); // 100K values
  }
  Put(""foo"", ""newvalue2"");

  iter->SeekToFirst();
  ASSERT_TRUE(iter->Valid());
  ASSERT_EQ(""foo"", iter->key().ToString());
  ASSERT_EQ(""hello"", iter->value().ToString());
  iter->Next();
  ASSERT_TRUE(!iter->Valid());
  delete iter;
}",31,,1176,1,,void
23168,BLOCK,-1,,<empty>,3,,1184,1,,void
23178,BLOCK,4,,"{
    ASSERT_OK(Put(Key(i), Key(i) + std::string(100000, 'v'))); // 100K values
  }",33,,1184,4,,void
23180,BLOCK,1,,<empty>,,,,1,,void
23216,BLOCK,1,,<empty>,,,,3,,void
23242,BLOCK,1,,<empty>,,,,4,,void
23271,BLOCK,1,,<empty>,,,,4,,void
23301,BLOCK,1,,<empty>,,,,3,,void
23325,BLOCK,-1,,<empty>,,,,1,,<empty>
23329,BLOCK,-1,,"TEST(DBTest, Snapshot)",1,,1198,1,,void
23353,BLOCK,-1,,"{
  do {
    Put(""foo"", ""v1"");
    const Snapshot* s1 = db_->GetSnapshot();
    Put(""foo"", ""v2"");
    const Snapshot* s2 = db_->GetSnapshot();
    Put(""foo"", ""v3"");
    const Snapshot* s3 = db_->GetSnapshot();

    Put(""foo"", ""v4"");
    ASSERT_EQ(""v1"", Get(""foo"", s1));
    ASSERT_EQ(""v2"", Get(""foo"", s2));
    ASSERT_EQ(""v3"", Get(""foo"", s3));
    ASSERT_EQ(""v4"", Get(""foo""));

    db_->ReleaseSnapshot(s3);
    ASSERT_EQ(""v1"", Get(""foo"", s1));
    ASSERT_EQ(""v2"", Get(""foo"", s2));
    ASSERT_EQ(""v4"", Get(""foo""));

    db_->ReleaseSnapshot(s1);
    ASSERT_EQ(""v2"", Get(""foo"", s2));
    ASSERT_EQ(""v4"", Get(""foo""));

    db_->ReleaseSnapshot(s2);
    ASSERT_EQ(""v4"", Get(""foo""));
  } while (ChangeOptions());
}",24,,1198,1,,void
23355,BLOCK,-1,,"{
    Put(""foo"", ""v1"");
    const Snapshot* s1 = db_->GetSnapshot();
    Put(""foo"", ""v2"");
    const Snapshot* s2 = db_->GetSnapshot();
    Put(""foo"", ""v3"");
    const Snapshot* s3 = db_->GetSnapshot();

    Put(""foo"", ""v4"");
    ASSERT_EQ(""v1"", Get(""foo"", s1));
    ASSERT_EQ(""v2"", Get(""foo"", s2));
    ASSERT_EQ(""v3"", Get(""foo"", s3));
    ASSERT_EQ(""v4"", Get(""foo""));

    db_->ReleaseSnapshot(s3);
    ASSERT_EQ(""v1"", Get(""foo"", s1));
    ASSERT_EQ(""v2"", Get(""foo"", s2));
    ASSERT_EQ(""v4"", Get(""foo""));

    db_->ReleaseSnapshot(s1);
    ASSERT_EQ(""v2"", Get(""foo"", s2));
    ASSERT_EQ(""v4"", Get(""foo""));

    db_->ReleaseSnapshot(s2);
    ASSERT_EQ(""v4"", Get(""foo""));
  }",6,,1199,1,,void
23391,BLOCK,1,,<empty>,,,,3,,void
23409,BLOCK,1,,<empty>,,,,3,,void
23427,BLOCK,1,,<empty>,,,,3,,void
23447,BLOCK,1,,<empty>,,,,3,,void
23469,BLOCK,1,,<empty>,,,,3,,void
23487,BLOCK,1,,<empty>,,,,3,,void
23507,BLOCK,1,,<empty>,,,,3,,void
23529,BLOCK,1,,<empty>,,,,3,,void
23549,BLOCK,1,,<empty>,,,,3,,void
23573,BLOCK,1,,<empty>,,,,3,,void
23593,BLOCK,-1,,<empty>,,,,1,,<empty>
23597,BLOCK,-1,,"TEST(DBTest, HiddenValuesAreRemoved)",1,,1227,1,,void
23621,BLOCK,-1,,"{
  do {
    Random rnd(301);
    FillLevels(""a"", ""z"");

    std::string big = RandomString(&rnd, 50000);
    Put(""foo"", big);
    Put(""pastfoo"", ""v"");
    const Snapshot* snapshot = db_->GetSnapshot();
    Put(""foo"", ""tiny"");
    Put(""pastfoo2"", ""v2"");        // Advance sequence number one more

    ASSERT_OK(dbfull()->TEST_CompactMemTable());
    ASSERT_GT(NumTableFilesAtLevel(0), 0);

    ASSERT_EQ(big, Get(""foo"", snapshot));
    ASSERT_TRUE(Between(Size("""", ""pastfoo""), 50000, 60000));
    db_->ReleaseSnapshot(snapshot);
    ASSERT_EQ(AllEntriesFor(""foo""), ""[ tiny, "" + big + "" ]"");
    Slice x(""x"");
    dbfull()->TEST_CompactRange(0, NULL, &x);
    ASSERT_EQ(AllEntriesFor(""foo""), ""[ tiny ]"");
    ASSERT_EQ(NumTableFilesAtLevel(0), 0);
    ASSERT_GE(NumTableFilesAtLevel(1), 1);
    dbfull()->TEST_CompactRange(1, NULL, &x);
    ASSERT_EQ(AllEntriesFor(""foo""), ""[ tiny ]"");

    ASSERT_TRUE(Between(Size("""", ""pastfoo""), 0, 1000));
  } while (ChangeOptions());
}",38,,1227,1,,void
23623,BLOCK,-1,,"{
    Random rnd(301);
    FillLevels(""a"", ""z"");

    std::string big = RandomString(&rnd, 50000);
    Put(""foo"", big);
    Put(""pastfoo"", ""v"");
    const Snapshot* snapshot = db_->GetSnapshot();
    Put(""foo"", ""tiny"");
    Put(""pastfoo2"", ""v2"");        // Advance sequence number one more

    ASSERT_OK(dbfull()->TEST_CompactMemTable());
    ASSERT_GT(NumTableFilesAtLevel(0), 0);

    ASSERT_EQ(big, Get(""foo"", snapshot));
    ASSERT_TRUE(Between(Size("""", ""pastfoo""), 50000, 60000));
    db_->ReleaseSnapshot(snapshot);
    ASSERT_EQ(AllEntriesFor(""foo""), ""[ tiny, "" + big + "" ]"");
    Slice x(""x"");
    dbfull()->TEST_CompactRange(0, NULL, &x);
    ASSERT_EQ(AllEntriesFor(""foo""), ""[ tiny ]"");
    ASSERT_EQ(NumTableFilesAtLevel(0), 0);
    ASSERT_GE(NumTableFilesAtLevel(1), 1);
    dbfull()->TEST_CompactRange(1, NULL, &x);
    ASSERT_EQ(AllEntriesFor(""foo""), ""[ tiny ]"");

    ASSERT_TRUE(Between(Size("""", ""pastfoo""), 0, 1000));
  }",6,,1228,1,,void
23661,BLOCK,1,,<empty>,,,,2,,void
23681,BLOCK,1,,<empty>,,,,3,,void
23698,BLOCK,1,,<empty>,,,,4,,void
23715,BLOCK,1,,<empty>,,,,1,,void
23742,BLOCK,1,,<empty>,,,,3,,void
23775,BLOCK,1,,<empty>,,,,2,,void
23794,BLOCK,1,,<empty>,,,,3,,void
23813,BLOCK,1,,<empty>,,,,3,,void
23839,BLOCK,1,,<empty>,,,,2,,void
23855,BLOCK,1,,<empty>,,,,1,,void
23879,BLOCK,-1,,<empty>,,,,1,,<empty>
23883,BLOCK,-1,,"TEST(DBTest, DeletionMarkers1)",1,,1258,1,,void
23907,BLOCK,-1,,"{
  Put(""foo"", ""v1"");
  ASSERT_OK(dbfull()->TEST_CompactMemTable());
  const int last = config::kMaxMemCompactLevel;
  ASSERT_EQ(NumTableFilesAtLevel(last), 1);   // foo => v1 is now in last level

  // Place a table at level last-1 to prevent merging with preceding mutation
  Put(""a"", ""begin"");
  Put(""z"", ""end"");
  dbfull()->TEST_CompactMemTable();
  ASSERT_EQ(NumTableFilesAtLevel(last), 1);
  ASSERT_EQ(NumTableFilesAtLevel(last-1), 1);

  Delete(""foo"");
  Put(""foo"", ""v2"");
  ASSERT_EQ(AllEntriesFor(""foo""), ""[ v2, DEL, v1 ]"");
  ASSERT_OK(dbfull()->TEST_CompactMemTable());  // Moves to level last-2
  ASSERT_EQ(AllEntriesFor(""foo""), ""[ v2, DEL, v1 ]"");
  Slice z(""z"");
  dbfull()->TEST_CompactRange(last-2, NULL, &z);
  // DEL eliminated, but v1 remains because we aren't compacting that level
  // (DEL can be eliminated because v2 hides v1).
  ASSERT_EQ(AllEntriesFor(""foo""), ""[ v2, v1 ]"");
  dbfull()->TEST_CompactRange(last-1, NULL, NULL);
  // Merging last-1 w/ last, so we are the ba...",32,,1258,1,,void
23916,BLOCK,1,,<empty>,,,,2,,void
23942,BLOCK,1,,<empty>,,,,4,,void
23971,BLOCK,1,,<empty>,,,,4,,void
23988,BLOCK,1,,<empty>,,,,3,,void
24013,BLOCK,1,,<empty>,,,,2,,void
24033,BLOCK,1,,<empty>,,,,2,,void
24052,BLOCK,1,,<empty>,,,,2,,void
24083,BLOCK,1,,<empty>,,,,2,,void
24110,BLOCK,1,,<empty>,,,,2,,void
24129,BLOCK,-1,,<empty>,,,,1,,<empty>
24133,BLOCK,-1,,"TEST(DBTest, DeletionMarkers2)",1,,1287,1,,void
24157,BLOCK,-1,,"{
  Put(""foo"", ""v1"");
  ASSERT_OK(dbfull()->TEST_CompactMemTable());
  const int last = config::kMaxMemCompactLevel;
  ASSERT_EQ(NumTableFilesAtLevel(last), 1);   // foo => v1 is now in last level

  // Place a table at level last-1 to prevent merging with preceding mutation
  Put(""a"", ""begin"");
  Put(""z"", ""end"");
  dbfull()->TEST_CompactMemTable();
  ASSERT_EQ(NumTableFilesAtLevel(last), 1);
  ASSERT_EQ(NumTableFilesAtLevel(last-1), 1);

  Delete(""foo"");
  ASSERT_EQ(AllEntriesFor(""foo""), ""[ DEL, v1 ]"");
  ASSERT_OK(dbfull()->TEST_CompactMemTable());  // Moves to level last-2
  ASSERT_EQ(AllEntriesFor(""foo""), ""[ DEL, v1 ]"");
  dbfull()->TEST_CompactRange(last-2, NULL, NULL);
  // DEL kept: ""last"" file overlaps
  ASSERT_EQ(AllEntriesFor(""foo""), ""[ DEL, v1 ]"");
  dbfull()->TEST_CompactRange(last-1, NULL, NULL);
  // Merging last-1 w/ last, so we are the base level for ""foo"", so
  // DEL is removed.  (as is v1).
  ASSERT_EQ(AllEntriesFor(""foo""), ""[ ]"");
}",32,,1287,1,,void
24166,BLOCK,1,,<empty>,,,,2,,void
24192,BLOCK,1,,<empty>,,,,4,,void
24221,BLOCK,1,,<empty>,,,,4,,void
24238,BLOCK,1,,<empty>,,,,3,,void
24260,BLOCK,1,,<empty>,,,,2,,void
24280,BLOCK,1,,<empty>,,,,2,,void
24299,BLOCK,1,,<empty>,,,,2,,void
24326,BLOCK,1,,<empty>,,,,2,,void
24353,BLOCK,1,,<empty>,,,,2,,void
24372,BLOCK,-1,,<empty>,,,,1,,<empty>
24376,BLOCK,-1,,"TEST(DBTest, OverlapInLevel0)",1,,1313,1,,void
24400,BLOCK,-1,,"{
  do {
    ASSERT_EQ(config::kMaxMemCompactLevel, 2) << ""Fix test to match config"";

    // Fill levels 1 and 2 to disable the pushing of new memtables to levels > 0.
    ASSERT_OK(Put(""100"", ""v100""));
    ASSERT_OK(Put(""999"", ""v999""));
    dbfull()->TEST_CompactMemTable();
    ASSERT_OK(Delete(""100""));
    ASSERT_OK(Delete(""999""));
    dbfull()->TEST_CompactMemTable();
    ASSERT_EQ(""0,1,1"", FilesPerLevel());

    // Make files spanning the following ranges in level-0:
    //  files[0]  200 .. 900
    //  files[1]  300 .. 500
    // Note that files are sorted by smallest key.
    ASSERT_OK(Put(""300"", ""v300""));
    ASSERT_OK(Put(""500"", ""v500""));
    dbfull()->TEST_CompactMemTable();
    ASSERT_OK(Put(""200"", ""v200""));
    ASSERT_OK(Put(""600"", ""v600""));
    ASSERT_OK(Put(""900"", ""v900""));
    dbfull()->TEST_CompactMemTable();
    ASSERT_EQ(""2,1,1"", FilesPerLevel());

    // Compact away the placeholder files we created initially
    dbfull()->TEST_CompactRange(1, NULL, NULL);
    dbf...",31,,1313,1,,void
24402,BLOCK,-1,,"{
    ASSERT_EQ(config::kMaxMemCompactLevel, 2) << ""Fix test to match config"";

    // Fill levels 1 and 2 to disable the pushing of new memtables to levels > 0.
    ASSERT_OK(Put(""100"", ""v100""));
    ASSERT_OK(Put(""999"", ""v999""));
    dbfull()->TEST_CompactMemTable();
    ASSERT_OK(Delete(""100""));
    ASSERT_OK(Delete(""999""));
    dbfull()->TEST_CompactMemTable();
    ASSERT_EQ(""0,1,1"", FilesPerLevel());

    // Make files spanning the following ranges in level-0:
    //  files[0]  200 .. 900
    //  files[1]  300 .. 500
    // Note that files are sorted by smallest key.
    ASSERT_OK(Put(""300"", ""v300""));
    ASSERT_OK(Put(""500"", ""v500""));
    dbfull()->TEST_CompactMemTable();
    ASSERT_OK(Put(""200"", ""v200""));
    ASSERT_OK(Put(""600"", ""v600""));
    ASSERT_OK(Put(""900"", ""v900""));
    dbfull()->TEST_CompactMemTable();
    ASSERT_EQ(""2,1,1"", FilesPerLevel());

    // Compact away the placeholder files we created initially
    dbfull()->TEST_CompactRange(1, NULL, NULL);
    dbfull()->...",6,,1314,1,,void
24406,BLOCK,1,,<empty>,,,,2,,void
24424,BLOCK,1,,<empty>,,,,1,,void
24440,BLOCK,1,,<empty>,,,,1,,void
24462,BLOCK,1,,<empty>,,,,2,,void
24479,BLOCK,1,,<empty>,,,,2,,void
24500,BLOCK,1,,<empty>,,,,3,,void
24515,BLOCK,1,,<empty>,,,,1,,void
24531,BLOCK,1,,<empty>,,,,1,,void
24551,BLOCK,1,,<empty>,,,,1,,void
24567,BLOCK,1,,<empty>,,,,1,,void
24583,BLOCK,1,,<empty>,,,,1,,void
24605,BLOCK,1,,<empty>,,,,3,,void
24636,BLOCK,1,,<empty>,,,,3,,void
24653,BLOCK,1,,<empty>,,,,2,,void
24674,BLOCK,1,,<empty>,,,,3,,void
24692,BLOCK,1,,<empty>,,,,3,,void
24712,BLOCK,-1,,<empty>,,,,1,,<empty>
24716,BLOCK,-1,,"TEST(DBTest, L0_CompactionBug_Issue44_a)",1,,1354,1,,void
24740,BLOCK,-1,,"{
  Reopen();
  ASSERT_OK(Put(""b"", ""v""));
  Reopen();
  ASSERT_OK(Delete(""b""));
  ASSERT_OK(Delete(""a""));
  Reopen();
  ASSERT_OK(Delete(""a""));
  Reopen();
  ASSERT_OK(Put(""a"", ""v""));
  Reopen();
  Reopen();
  ASSERT_EQ(""(a->v)"", Contents());
  DelayMilliseconds(1000);  // Wait for compaction to finish
  ASSERT_EQ(""(a->v)"", Contents());
}",42,,1354,1,,void
24743,BLOCK,1,,<empty>,,,,1,,void
24762,BLOCK,1,,<empty>,,,,2,,void
24779,BLOCK,1,,<empty>,,,,2,,void
24797,BLOCK,1,,<empty>,,,,2,,void
24813,BLOCK,1,,<empty>,,,,1,,void
24833,BLOCK,1,,<empty>,,,,3,,void
24852,BLOCK,1,,<empty>,,,,3,,void
24870,BLOCK,-1,,<empty>,,,,1,,<empty>
24874,BLOCK,-1,,"TEST(DBTest, L0_CompactionBug_Issue44_b)",1,,1371,1,,void
24898,BLOCK,-1,,"{
  Reopen();
  Put("""","""");
  Reopen();
  Delete(""e"");
  Put("""","""");
  Reopen();
  Put(""c"", ""cv"");
  Reopen();
  Put("""","""");
  Reopen();
  Put("""","""");
  DelayMilliseconds(1000);  // Wait for compaction to finish
  Reopen();
  Put(""d"",""dv"");
  Reopen();
  Put("""","""");
  Reopen();
  Delete(""d"");
  Delete(""b"");
  Reopen();
  ASSERT_EQ(""(->)(c->cv)"", Contents());
  DelayMilliseconds(1000);  // Wait for compaction to finish
  ASSERT_EQ(""(->)(c->cv)"", Contents());
}",42,,1371,1,,void
24940,BLOCK,1,,<empty>,,,,3,,void
24959,BLOCK,1,,<empty>,,,,3,,void
24977,BLOCK,-1,,<empty>,,,,1,,<empty>
24981,BLOCK,-1,,"TEST(DBTest, ComparatorCheck)",1,,1397,1,,void
25005,BLOCK,-1,,"{
  class NewComparator : public Comparator {
   public:
    virtual const char* Name() const { return ""leveldb.NewComparator""; }
    virtual int Compare(const Slice& a, const Slice& b) const {
      return BytewiseComparator()->Compare(a, b);
    }
    virtual void FindShortestSeparator(std::string* s, const Slice& l) const {
      BytewiseComparator()->FindShortestSeparator(s, l);
    }
    virtual void FindShortSuccessor(std::string* key) const {
      BytewiseComparator()->FindShortSuccessor(key);
    }
  };
  NewComparator cmp;
  Options new_options = CurrentOptions();
  new_options.comparator = &cmp;
  Status s = TryReopen(&new_options);
  ASSERT_TRUE(!s.ok());
  ASSERT_TRUE(s.ToString().find(""comparator"") != std::string::npos)
      << s.ToString();
}",31,,1397,1,,void
25029,BLOCK,1,,<empty>,,,,3,,void
25049,BLOCK,1,,<empty>,,,,2,,void
25084,BLOCK,-1,,<empty>,,,,1,,<empty>
25088,BLOCK,-1,,"TEST(DBTest, CustomComparator)",1,,1420,1,,void
25112,BLOCK,-1,,"{
  class NumberComparator : public Comparator {
   public:
    virtual const char* Name() const { return ""test.NumberComparator""; }
    virtual int Compare(const Slice& a, const Slice& b) const {
      return ToNumber(a) - ToNumber(b);
    }
    virtual void FindShortestSeparator(std::string* s, const Slice& l) const {
      ToNumber(*s);     // Check format
      ToNumber(l);      // Check format
    }
    virtual void FindShortSuccessor(std::string* key) const {
      ToNumber(*key);   // Check format
    }
   private:
    static int ToNumber(const Slice& x) {
      // Check that there are no extra characters.
      ASSERT_TRUE(x.size() >= 2 && x[0] == '[' && x[x.size()-1] == ']')
          << EscapeString(x);
      int val;
      char ignored;
      ASSERT_TRUE(sscanf(x.ToString().c_str(), ""[%i]%c"", &val, &ignored) == 1)
          << EscapeString(x);
      return val;
    }
  };
  NumberComparator cmp;
  Options new_options = CurrentOptions();
  new_options.create_if_missing = t...",32,,1420,1,,void
25143,BLOCK,1,,<empty>,,,,1,,void
25159,BLOCK,1,,<empty>,,,,1,,void
25175,BLOCK,-1,,<empty>,3,,1455,1,,void
25185,BLOCK,4,,"{
    ASSERT_EQ(""ten"", Get(""[10]""));
    ASSERT_EQ(""ten"", Get(""[0xa]""));
    ASSERT_EQ(""twenty"", Get(""[20]""));
    ASSERT_EQ(""twenty"", Get(""[0x14]""));
    ASSERT_EQ(""NOT_FOUND"", Get(""[15]""));
    ASSERT_EQ(""NOT_FOUND"", Get(""[0xf]""));
    Compact(""[0]"", ""[9999]"");
  }",31,,1455,4,,void
25190,BLOCK,1,,<empty>,,,,3,,void
25209,BLOCK,1,,<empty>,,,,3,,void
25228,BLOCK,1,,<empty>,,,,3,,void
25247,BLOCK,1,,<empty>,,,,3,,void
25266,BLOCK,1,,<empty>,,,,3,,void
25285,BLOCK,1,,<empty>,,,,3,,void
25304,BLOCK,-1,,<empty>,3,,1465,1,,void
25314,BLOCK,4,,"{
    for (int i = 0; i < 1000; i++) {
      char buf[100];
      snprintf(buf, sizeof(buf), ""[%d]"", i*10);
      ASSERT_OK(Put(buf, buf));
    }
    Compact(""[0]"", ""[1000000]"");
  }",37,,1465,4,,void
25316,BLOCK,-1,,<empty>,5,,1466,1,,void
25326,BLOCK,4,,"{
      char buf[100];
      snprintf(buf, sizeof(buf), ""[%d]"", i*10);
      ASSERT_OK(Put(buf, buf));
    }",36,,1466,4,,void
25337,BLOCK,1,,<empty>,,,,3,,void
25359,BLOCK,-1,,<empty>,,,,1,,<empty>
25363,BLOCK,-1,,"TEST(DBTest, ManualCompaction)",1,,1475,1,,void
25387,BLOCK,-1,,"{
  ASSERT_EQ(config::kMaxMemCompactLevel, 2)
      << ""Need to update this test to match kMaxMemCompactLevel"";

  MakeTables(3, ""p"", ""q"");
  ASSERT_EQ(""1,1,1"", FilesPerLevel());

  // Compaction range falls before files
  Compact("""", ""c"");
  ASSERT_EQ(""1,1,1"", FilesPerLevel());

  // Compaction range falls after files
  Compact(""r"", ""z"");
  ASSERT_EQ(""1,1,1"", FilesPerLevel());

  // Compaction range overlaps files
  Compact(""p1"", ""p9"");
  ASSERT_EQ(""0,0,1"", FilesPerLevel());

  // Populate a different range
  MakeTables(3, ""c"", ""e"");
  ASSERT_EQ(""1,1,2"", FilesPerLevel());

  // Compact just the new range
  Compact(""b"", ""f"");
  ASSERT_EQ(""0,0,2"", FilesPerLevel());

  // Compact all
  MakeTables(1, ""a"", ""z"");
  ASSERT_EQ(""0,1,2"", FilesPerLevel());
  db_->CompactRange(NULL, NULL);
  ASSERT_EQ(""0,0,1"", FilesPerLevel());
}",32,,1475,1,,void
25391,BLOCK,1,,<empty>,,,,2,,void
25415,BLOCK,1,,<empty>,,,,3,,void
25435,BLOCK,1,,<empty>,,,,3,,void
25455,BLOCK,1,,<empty>,,,,3,,void
25475,BLOCK,1,,<empty>,,,,3,,void
25496,BLOCK,1,,<empty>,,,,3,,void
25516,BLOCK,1,,<empty>,,,,3,,void
25537,BLOCK,1,,<empty>,,,,3,,void
25560,BLOCK,1,,<empty>,,,,3,,void
25578,BLOCK,-1,,<empty>,,,,1,,<empty>
25582,BLOCK,-1,,"TEST(DBTest, DBOpen_Options)",1,,1509,1,,void
25606,BLOCK,-1,,"{
  std::string dbname = test::TmpDir() + ""/db_options_test"";
  DestroyDB(dbname, Options());

  // Does not exist, and create_if_missing == false: error
  DB* db = NULL;
  Options opts;
  opts.create_if_missing = false;
  Status s = DB::Open(opts, dbname, &db);
  ASSERT_TRUE(strstr(s.ToString().c_str(), ""does not exist"") != NULL);
  ASSERT_TRUE(db == NULL);

  // Does not exist, and create_if_missing == true: OK
  opts.create_if_missing = true;
  s = DB::Open(opts, dbname, &db);
  ASSERT_OK(s);
  ASSERT_TRUE(db != NULL);

  delete db;
  db = NULL;

  // Does exist, and error_if_exists == true: error
  opts.create_if_missing = false;
  opts.error_if_exists = true;
  s = DB::Open(opts, dbname, &db);
  ASSERT_TRUE(strstr(s.ToString().c_str(), ""exists"") != NULL);
  ASSERT_TRUE(db == NULL);

  // Does exist, and error_if_exists == false: OK
  opts.create_if_missing = true;
  opts.error_if_exists = false;
  s = DB::Open(opts, dbname, &db);
  ASSERT_OK(s);
  ASSERT_TRUE(db != NULL);

  de...",30,,1509,1,,void
25641,BLOCK,1,,<empty>,,,,2,,void
25666,BLOCK,1,,<empty>,,,,2,,void
25699,BLOCK,1,,<empty>,,,,3,,void
25713,BLOCK,1,,<empty>,,,,2,,void
25755,BLOCK,1,,<empty>,,,,2,,void
25780,BLOCK,1,,<empty>,,,,2,,void
25818,BLOCK,1,,<empty>,,,,3,,void
25832,BLOCK,1,,<empty>,,,,2,,void
25857,BLOCK,-1,,<empty>,,,,1,,<empty>
25861,BLOCK,-1,,"TEST(DBTest, Locking)",1,,1548,1,,void
25885,BLOCK,-1,,"{
  DB* db2 = NULL;
  Status s = DB::Open(CurrentOptions(), dbname_, &db2);
  ASSERT_TRUE(!s.ok()) << ""Locking did not prevent re-opening db"";
}",23,,1548,1,,void
25908,BLOCK,1,,<empty>,,,,3,,void
25931,BLOCK,-1,,<empty>,,,,1,,<empty>
25935,BLOCK,-1,,"TEST(DBTest, NoSpace)",1,,1555,1,,void
25959,BLOCK,-1,,"{
  Options options = CurrentOptions();
  options.env = env_;
  Reopen(&options);

  ASSERT_OK(Put(""foo"", ""v1""));
  ASSERT_EQ(""v1"", Get(""foo""));
  Compact(""a"", ""z"");
  const int num_files = CountFiles();
  env_->no_space_.Release_Store(env_);   // Force out-of-space errors
  for (int i = 0; i < 10; i++) {
    for (int level = 0; level < config::kNumLevels-1; level++) {
      dbfull()->TEST_CompactRange(level, NULL, NULL);
    }
  }
  env_->no_space_.Release_Store(NULL);
  ASSERT_LT(CountFiles(), num_files + 3);
}",23,,1555,1,,void
25973,BLOCK,1,,<empty>,,,,1,,void
25992,BLOCK,1,,<empty>,,,,3,,void
26022,BLOCK,-1,,<empty>,3,,1565,1,,void
26032,BLOCK,4,,"{
    for (int level = 0; level < config::kNumLevels-1; level++) {
      dbfull()->TEST_CompactRange(level, NULL, NULL);
    }
  }",32,,1565,4,,void
26034,BLOCK,-1,,<empty>,5,,1566,1,,void
26048,BLOCK,4,,"{
      dbfull()->TEST_CompactRange(level, NULL, NULL);
    }",64,,1566,4,,void
26065,BLOCK,1,,<empty>,,,,3,,void
26085,BLOCK,-1,,<empty>,,,,1,,<empty>
26089,BLOCK,-1,,"TEST(DBTest, NonWritableFileSystem)",1,,1574,1,,void
26113,BLOCK,-1,,"{
  Options options = CurrentOptions();
  options.write_buffer_size = 1000;
  options.env = env_;
  Reopen(&options);
  ASSERT_OK(Put(""foo"", ""v1""));
  env_->non_writable_.Release_Store(env_);  // Force errors for new files
  std::string big(100000, 'x');
  int errors = 0;
  for (int i = 0; i < 20; i++) {
    fprintf(stderr, ""iter %d; errors %d\n"", i, errors);
    if (!Put(""foo"", big).ok()) {
      errors++;
      DelayMilliseconds(100);
    }
  }
  ASSERT_GT(errors, 0);
  env_->non_writable_.Release_Store(NULL);
}",37,,1574,1,,void
26132,BLOCK,1,,<empty>,,,,1,,void
26163,BLOCK,-1,,<empty>,3,,1583,1,,void
26173,BLOCK,4,,"{
    fprintf(stderr, ""iter %d; errors %d\n"", i, errors);
    if (!Put(""foo"", big).ok()) {
      errors++;
      DelayMilliseconds(100);
    }
  }",32,,1583,4,,void
26187,BLOCK,-1,,"{
      errors++;
      DelayMilliseconds(100);
    }",32,,1585,2,,void
26195,BLOCK,1,,<empty>,,,,4,,void
26220,BLOCK,-1,,<empty>,,,,1,,<empty>
26224,BLOCK,-1,,"TEST(DBTest, WriteSyncError)",1,,1594,1,,void
26248,BLOCK,-1,,"{
  // Check that log sync errors cause the DB to disallow future writes.

  // (a) Cause log sync calls to fail
  Options options = CurrentOptions();
  options.env = env_;
  Reopen(&options);
  env_->data_sync_error_.Release_Store(env_);

  // (b) Normal write should succeed
  WriteOptions w;
  ASSERT_OK(db_->Put(w, ""k1"", ""v1""));
  ASSERT_EQ(""v1"", Get(""k1""));

  // (c) Do a sync write; should fail
  w.sync = true;
  ASSERT_TRUE(!db_->Put(w, ""k2"", ""v2"").ok());
  ASSERT_EQ(""v1"", Get(""k1""));
  ASSERT_EQ(""NOT_FOUND"", Get(""k2""));

  // (d) make sync behave normally
  env_->data_sync_error_.Release_Store(NULL);

  // (e) Do a non-sync write; should fail
  w.sync = false;
  ASSERT_TRUE(!db_->Put(w, ""k3"", ""v3"").ok());
  ASSERT_EQ(""v1"", Get(""k1""));
  ASSERT_EQ(""NOT_FOUND"", Get(""k2""));
  ASSERT_EQ(""NOT_FOUND"", Get(""k3""));
}",30,,1594,1,,void
26270,BLOCK,1,,<empty>,,,,2,,void
26293,BLOCK,1,,<empty>,,,,3,,void
26314,BLOCK,1,,<empty>,,,,2,,void
26342,BLOCK,1,,<empty>,,,,3,,void
26361,BLOCK,1,,<empty>,,,,3,,void
26389,BLOCK,1,,<empty>,,,,2,,void
26417,BLOCK,1,,<empty>,,,,3,,void
26436,BLOCK,1,,<empty>,,,,3,,void
26455,BLOCK,1,,<empty>,,,,3,,void
26474,BLOCK,-1,,<empty>,,,,1,,<empty>
26478,BLOCK,-1,,"TEST(DBTest, ManifestWriteError)",1,,1625,1,,void
26502,BLOCK,-1,,"{
  // Test for the following problem:
  // (a) Compaction produces file F
  // (b) Log record containing F is written to MANIFEST file, but Sync() fails
  // (c) GC deletes F
  // (d) After reopening DB, reads fail since deleted F is named in log record

  // We iterate twice.  In the second iteration, everything is the
  // same except the log record never makes it to the MANIFEST file.
  for (int iter = 0; iter < 2; iter++) {
    port::AtomicPointer* error_type = (iter == 0)
        ? &env_->manifest_sync_error_
        : &env_->manifest_write_error_;

    // Insert foo=>bar mapping
    Options options = CurrentOptions();
    options.env = env_;
    options.create_if_missing = true;
    options.error_if_exists = false;
    DestroyAndReopen(&options);
    ASSERT_OK(Put(""foo"", ""bar""));
    ASSERT_EQ(""bar"", Get(""foo""));

    // Memtable compaction (will succeed)
    dbfull()->TEST_CompactMemTable();
    ASSERT_EQ(""bar"", Get(""foo""));
    const int last = config::kMaxMemCompactLevel;
...",34,,1625,1,,void
26504,BLOCK,-1,,<empty>,3,,1634,1,,void
26514,BLOCK,4,,"{
    port::AtomicPointer* error_type = (iter == 0)
        ? &env_->manifest_sync_error_
        : &env_->manifest_write_error_;

    // Insert foo=>bar mapping
    Options options = CurrentOptions();
    options.env = env_;
    options.create_if_missing = true;
    options.error_if_exists = false;
    DestroyAndReopen(&options);
    ASSERT_OK(Put(""foo"", ""bar""));
    ASSERT_EQ(""bar"", Get(""foo""));

    // Memtable compaction (will succeed)
    dbfull()->TEST_CompactMemTable();
    ASSERT_EQ(""bar"", Get(""foo""));
    const int last = config::kMaxMemCompactLevel;
    ASSERT_EQ(NumTableFilesAtLevel(last), 1);   // foo=>bar is now in last level

    // Merging compaction (will fail)
    error_type->Release_Store(env_);
    dbfull()->TEST_CompactRange(last, NULL, NULL);  // Should fail
    ASSERT_EQ(""bar"", Get(""foo""));

    // Recovery: should not lose data
    error_type->Release_Store(NULL);
    Reopen(&options);
    ASSERT_EQ(""bar"", Get(""foo""));
  }",40,,1634,4,,void
26553,BLOCK,1,,<empty>,,,,1,,void
26572,BLOCK,1,,<empty>,,,,3,,void
26595,BLOCK,1,,<empty>,,,,3,,void
26620,BLOCK,1,,<empty>,,,,4,,void
26651,BLOCK,1,,<empty>,,,,3,,void
26678,BLOCK,1,,<empty>,,,,3,,void
26697,BLOCK,-1,,<empty>,,,,1,,<empty>
26701,BLOCK,-1,,"TEST(DBTest, MissingSSTFile)",1,,1666,1,,void
26725,BLOCK,-1,,"{
  ASSERT_OK(Put(""foo"", ""bar""));
  ASSERT_EQ(""bar"", Get(""foo""));

  // Dump the memtable to disk.
  dbfull()->TEST_CompactMemTable();
  ASSERT_EQ(""bar"", Get(""foo""));

  Close();
  ASSERT_TRUE(DeleteAnSSTFile());
  Options options = CurrentOptions();
  options.paranoid_checks = true;
  Status s = TryReopen(&options);
  ASSERT_TRUE(!s.ok());
  ASSERT_TRUE(s.ToString().find(""issing"") != std::string::npos)
      << s.ToString();
}",30,,1666,1,,void
26727,BLOCK,1,,<empty>,,,,1,,void
26746,BLOCK,1,,<empty>,,,,3,,void
26769,BLOCK,1,,<empty>,,,,3,,void
26787,BLOCK,1,,<empty>,,,,2,,void
26822,BLOCK,1,,<empty>,,,,3,,void
26842,BLOCK,1,,<empty>,,,,2,,void
26877,BLOCK,-1,,<empty>,,,,1,,<empty>
26881,BLOCK,-1,,"TEST(DBTest, StillReadSST)",1,,1684,1,,void
26905,BLOCK,-1,,"{
  ASSERT_OK(Put(""foo"", ""bar""));
  ASSERT_EQ(""bar"", Get(""foo""));

  // Dump the memtable to disk.
  dbfull()->TEST_CompactMemTable();
  ASSERT_EQ(""bar"", Get(""foo""));
  Close();
  ASSERT_GT(RenameLDBToSST(), 0);
  Options options = CurrentOptions();
  options.paranoid_checks = true;
  Status s = TryReopen(&options);
  ASSERT_TRUE(s.ok());
  ASSERT_EQ(""bar"", Get(""foo""));
}",28,,1684,1,,void
26907,BLOCK,1,,<empty>,,,,1,,void
26926,BLOCK,1,,<empty>,,,,3,,void
26949,BLOCK,1,,<empty>,,,,3,,void
26968,BLOCK,1,,<empty>,,,,3,,void
27002,BLOCK,1,,<empty>,,,,3,,void
27023,BLOCK,1,,<empty>,,,,3,,void
27042,BLOCK,-1,,<empty>,,,,1,,<empty>
27046,BLOCK,-1,,"TEST(DBTest, FilesDeletedAfterCompaction)",1,,1700,1,,void
27070,BLOCK,-1,,"{
  ASSERT_OK(Put(""foo"", ""v2""));
  Compact(""a"", ""z"");
  const int num_files = CountFiles();
  for (int i = 0; i < 10; i++) {
    ASSERT_OK(Put(""foo"", ""v2""));
    Compact(""a"", ""z"");
  }
  ASSERT_EQ(CountFiles(), num_files);
}",43,,1700,1,,void
27072,BLOCK,1,,<empty>,,,,1,,void
27095,BLOCK,-1,,<empty>,3,,1704,1,,void
27105,BLOCK,4,,"{
    ASSERT_OK(Put(""foo"", ""v2""));
    Compact(""a"", ""z"");
  }",32,,1704,4,,void
27107,BLOCK,1,,<empty>,,,,1,,void
27128,BLOCK,1,,<empty>,,,,4,,void
27146,BLOCK,-1,,<empty>,,,,1,,<empty>
27150,BLOCK,-1,,"TEST(DBTest, BloomFilter)",1,,1711,1,,void
27174,BLOCK,-1,,"{
  env_->count_random_reads_ = true;
  Options options = CurrentOptions();
  options.env = env_;
  options.block_cache = NewLRUCache(0);  // Prevent cache hits
  options.filter_policy = NewBloomFilterPolicy(10);
  Reopen(&options);

  // Populate multiple layers
  const int N = 10000;
  for (int i = 0; i < N; i++) {
    ASSERT_OK(Put(Key(i), Key(i)));
  }
  Compact(""a"", ""z"");
  for (int i = 0; i < N; i += 100) {
    ASSERT_OK(Put(Key(i), Key(i)));
  }
  dbfull()->TEST_CompactMemTable();

  // Prevent auto compactions triggered by seeks
  env_->delay_data_sync_.Release_Store(env_);

  // Lookup present keys.  Should rarely read from small sstable.
  env_->random_read_counter_.Reset();
  for (int i = 0; i < N; i++) {
    ASSERT_EQ(Key(i), Get(Key(i)));
  }
  int reads = env_->random_read_counter_.Read();
  fprintf(stderr, ""%d present => %d reads\n"", N, reads);
  ASSERT_GE(reads, N);
  ASSERT_LE(reads, N + 2*N/100);

  // Lookup present keys.  Should rarely read from either sstable.
 ...",27,,1711,1,,void
27209,BLOCK,-1,,<empty>,3,,1721,1,,void
27219,BLOCK,4,,"{
    ASSERT_OK(Put(Key(i), Key(i)));
  }",31,,1721,4,,void
27221,BLOCK,1,,<empty>,,,,1,,void
27242,BLOCK,-1,,<empty>,3,,1725,1,,void
27253,BLOCK,4,,"{
    ASSERT_OK(Put(Key(i), Key(i)));
  }",36,,1725,4,,void
27255,BLOCK,1,,<empty>,,,,1,,void
27290,BLOCK,-1,,<empty>,3,,1735,1,,void
27300,BLOCK,4,,"{
    ASSERT_EQ(Key(i), Get(Key(i)));
  }",31,,1735,4,,void
27307,BLOCK,1,,<empty>,,,,3,,void
27341,BLOCK,1,,<empty>,,,,5,,void
27357,BLOCK,1,,<empty>,,,,5,,void
27384,BLOCK,-1,,<empty>,3,,1745,1,,void
27394,BLOCK,4,,"{
    ASSERT_EQ(""NOT_FOUND"", Get(Key(i) + "".missing""));
  }",31,,1745,4,,void
27397,BLOCK,1,,<empty>,,,,2,,void
27430,BLOCK,1,,<empty>,,,,4,,void
27485,BLOCK,-1,,<empty>,,,,1,,<empty>
27497,BLOCK,-1,,"{
  MTThread* t = reinterpret_cast<MTThread*>(arg);
  int id = t->id;
  DB* db = t->state->test->db_;
  uintptr_t counter = 0;
  fprintf(stderr, ""... starting thread %d\n"", id);
  Random rnd(1000 + id);
  std::string value;
  char valbuf[1500];
  while (t->state->stop.Acquire_Load() == NULL) {
    t->state->counter[id].Release_Store(reinterpret_cast<void*>(counter));

    int key = rnd.Uniform(kNumKeys);
    char keybuf[20];
    snprintf(keybuf, sizeof(keybuf), ""%016d"", key);

    if (rnd.OneIn(2)) {
      // Write values of the form <key, my id, counter>.
      // We add some padding for force compactions.
      snprintf(valbuf, sizeof(valbuf), ""%d.%d.%-1000d"",
               key, id, static_cast<int>(counter));
      ASSERT_OK(db->Put(WriteOptions(), Slice(keybuf), Slice(valbuf)));
    } else {
      // Read a value and verify that it matches the pattern written above.
      Status s = db->Get(ReadOptions(), Slice(keybuf), &value);
      if (s.IsNotFound()) {
        // Key has no...",37,,1777,2,,void
27546,BLOCK,-1,,"{
    t->state->counter[id].Release_Store(reinterpret_cast<void*>(counter));

    int key = rnd.Uniform(kNumKeys);
    char keybuf[20];
    snprintf(keybuf, sizeof(keybuf), ""%016d"", key);

    if (rnd.OneIn(2)) {
      // Write values of the form <key, my id, counter>.
      // We add some padding for force compactions.
      snprintf(valbuf, sizeof(valbuf), ""%d.%d.%-1000d"",
               key, id, static_cast<int>(counter));
      ASSERT_OK(db->Put(WriteOptions(), Slice(keybuf), Slice(valbuf)));
    } else {
      // Read a value and verify that it matches the pattern written above.
      Status s = db->Get(ReadOptions(), Slice(keybuf), &value);
      if (s.IsNotFound()) {
        // Key has not yet been written
      } else {
        // Check that the writer thread counter is >= the counter in the value
        ASSERT_OK(s);
        int k, w, c;
        ASSERT_EQ(3, sscanf(value.c_str(), ""%d.%d.%d"", &k, &w, &c)) << value;
        ASSERT_EQ(k, key);
        ASSERT_GE(w, 0);
       ...",49,,1786,2,,void
27581,BLOCK,-1,,"{
      // Write values of the form <key, my id, counter>.
      // We add some padding for force compactions.
      snprintf(valbuf, sizeof(valbuf), ""%d.%d.%-1000d"",
               key, id, static_cast<int>(counter));
      ASSERT_OK(db->Put(WriteOptions(), Slice(keybuf), Slice(valbuf)));
    }",23,,1793,2,,void
27593,BLOCK,1,,<empty>,,,,4,,void
27615,BLOCK,-1,,"{
      // Read a value and verify that it matches the pattern written above.
      Status s = db->Get(ReadOptions(), Slice(keybuf), &value);
      if (s.IsNotFound()) {
        // Key has not yet been written
      } else {
        // Check that the writer thread counter is >= the counter in the value
        ASSERT_OK(s);
        int k, w, c;
        ASSERT_EQ(3, sscanf(value.c_str(), ""%d.%d.%d"", &k, &w, &c)) << value;
        ASSERT_EQ(k, key);
        ASSERT_GE(w, 0);
        ASSERT_LT(w, kNumThreads);
        ASSERT_LE(static_cast<uintptr_t>(c), reinterpret_cast<uintptr_t>(
            t->state->counter[w].Acquire_Load()));
      }
    }",12,,1799,1,,void
27633,BLOCK,-1,,"{
        // Key has not yet been written
      }",27,,1802,2,,void
27635,BLOCK,-1,,"{
        // Check that the writer thread counter is >= the counter in the value
        ASSERT_OK(s);
        int k, w, c;
        ASSERT_EQ(3, sscanf(value.c_str(), ""%d.%d.%d"", &k, &w, &c)) << value;
        ASSERT_EQ(k, key);
        ASSERT_GE(w, 0);
        ASSERT_LT(w, kNumThreads);
        ASSERT_LE(static_cast<uintptr_t>(c), reinterpret_cast<uintptr_t>(
            t->state->counter[w].Acquire_Load()));
      }",14,,1804,1,,void
27638,BLOCK,1,,<empty>,,,,3,,void
27657,BLOCK,1,,<empty>,,,,6,,void
27686,BLOCK,1,,<empty>,,,,5,,void
27703,BLOCK,1,,<empty>,,,,4,,void
27720,BLOCK,1,,<empty>,,,,5,,void
27750,BLOCK,1,,<empty>,,,,6,,void
27801,BLOCK,-1,,<empty>,,,,1,,<empty>
27805,BLOCK,-1,,"TEST(DBTest, MultiThreaded)",1,,1824,1,,void
27829,BLOCK,-1,,"{
  do {
    // Initialize state
    MTState mt;
    mt.test = this;
    mt.stop.Release_Store(0);
    for (int id = 0; id < kNumThreads; id++) {
      mt.counter[id].Release_Store(0);
      mt.thread_done[id].Release_Store(0);
    }

    // Start threads
    MTThread thread[kNumThreads];
    for (int id = 0; id < kNumThreads; id++) {
      thread[id].state = &mt;
      thread[id].id = id;
      env_->StartThread(MTThreadBody, &thread[id]);
    }

    // Let them run for a while
    DelayMilliseconds(kTestSeconds * 1000);

    // Stop the threads and wait for them to finish
    mt.stop.Release_Store(&mt);
    for (int id = 0; id < kNumThreads; id++) {
      while (mt.thread_done[id].Acquire_Load() == NULL) {
        DelayMilliseconds(100);
      }
    }
  } while (ChangeOptions());
}",29,,1824,1,,void
27831,BLOCK,-1,,"{
    // Initialize state
    MTState mt;
    mt.test = this;
    mt.stop.Release_Store(0);
    for (int id = 0; id < kNumThreads; id++) {
      mt.counter[id].Release_Store(0);
      mt.thread_done[id].Release_Store(0);
    }

    // Start threads
    MTThread thread[kNumThreads];
    for (int id = 0; id < kNumThreads; id++) {
      thread[id].state = &mt;
      thread[id].id = id;
      env_->StartThread(MTThreadBody, &thread[id]);
    }

    // Let them run for a while
    DelayMilliseconds(kTestSeconds * 1000);

    // Stop the threads and wait for them to finish
    mt.stop.Release_Store(&mt);
    for (int id = 0; id < kNumThreads; id++) {
      while (mt.thread_done[id].Acquire_Load() == NULL) {
        DelayMilliseconds(100);
      }
    }
  }",6,,1825,1,,void
27846,BLOCK,-1,,<empty>,5,,1830,1,,void
27856,BLOCK,4,,"{
      mt.counter[id].Release_Store(0);
      mt.thread_done[id].Release_Store(0);
    }",46,,1830,4,,void
27877,BLOCK,-1,,<empty>,5,,1837,1,,void
27887,BLOCK,4,,"{
      thread[id].state = &mt;
      thread[id].id = id;
      env_->StartThread(MTThreadBody, &thread[id]);
    }",46,,1837,4,,void
27925,BLOCK,-1,,<empty>,5,,1848,1,,void
27935,BLOCK,4,,"{
      while (mt.thread_done[id].Acquire_Load() == NULL) {
        DelayMilliseconds(100);
      }
    }",46,,1848,4,,void
27947,BLOCK,-1,,"{
        DelayMilliseconds(100);
      }",57,,1849,2,,void
27960,BLOCK,-1,,{ },63,,1867,2,,void
27964,BLOCK,-1,,{ },14,,1868,1,,void
27971,BLOCK,-1,,"{
    return DB::Put(o, k, v);
  }",77,,1869,4,,void
27985,BLOCK,-1,,"{
    return DB::Delete(o, key);
  }",66,,1872,3,,void
27999,BLOCK,-1,,"{
    assert(false);      // Not implemented
    return Status::NotFound(key);
  }",60,,1876,4,,void
28012,BLOCK,-1,,"{
    if (options.snapshot == NULL) {
      KVMap* saved = new KVMap;
      *saved = map_;
      return new ModelIter(saved, true);
    } else {
      const KVMap* snapshot_state =
          &(reinterpret_cast<const ModelSnapshot*>(options.snapshot)->map_);
      return new ModelIter(snapshot_state, false);
    }
  }",61,,1880,2,,void
28019,BLOCK,-1,,"{
      KVMap* saved = new KVMap;
      *saved = map_;
      return new ModelIter(saved, true);
    }",35,,1881,2,,void
28035,BLOCK,-1,,"{
      const KVMap* snapshot_state =
          &(reinterpret_cast<const ModelSnapshot*>(options.snapshot)->map_);
      return new ModelIter(snapshot_state, false);
    }",12,,1885,1,,void
28055,BLOCK,-1,,"{
    ModelSnapshot* snapshot = new ModelSnapshot;
    snapshot->map_ = map_;
    return snapshot;
  }",41,,1891,1,,void
28072,BLOCK,-1,,"{
    delete reinterpret_cast<const ModelSnapshot*>(snapshot);
  }",58,,1897,2,,void
28082,BLOCK,-1,,"{
    class Handler : public WriteBatch::Handler {
     public:
      KVMap* map_;
      virtual void Put(const Slice& key, const Slice& value) {
        (*map_)[key.ToString()] = value.ToString();
      }
      virtual void Delete(const Slice& key) {
        map_->erase(key.ToString());
      }
    };
    Handler handler;
    handler.map_ = &map_;
    return batch->Iterate(&handler);
  }",72,,1900,3,,void
28102,BLOCK,-1,,"{
    return false;
  }",71,,1916,3,,void
28111,BLOCK,-1,,"{
    for (int i = 0; i < n; i++) {
      sizes[i] = 0;
    }
  }",76,,1919,4,,void
28113,BLOCK,-1,,<empty>,5,,1920,1,,void
28123,BLOCK,4,,"{
      sizes[i] = 0;
    }",33,,1920,4,,void
28134,BLOCK,-1,,"{
  }",67,,1924,3,,void
28141,BLOCK,-1,,"{
    }",56,,1931,3,,void
28145,BLOCK,-1,,"{
      if (owned_) delete map_;
    }",18,,1933,1,,void
28148,BLOCK,-1,,<empty>,19,,1934,2,,void
28154,BLOCK,-1,,{ return iter_ != map_->end(); },32,,1936,1,,void
28165,BLOCK,-1,,{ iter_ = map_->begin(); },32,,1937,1,,void
28175,BLOCK,-1,,"{
      if (map_->empty()) {
        iter_ = map_->end();
      } else {
        iter_ = map_->find(map_->rbegin()->first);
      }
    }",31,,1938,1,,void
28181,BLOCK,-1,,"{
        iter_ = map_->end();
      }",26,,1939,2,,void
28189,BLOCK,-1,,"{
        iter_ = map_->find(map_->rbegin()->first);
      }",14,,1941,1,,void
28206,BLOCK,-1,,"{
      iter_ = map_->lower_bound(k.ToString());
    }",39,,1945,2,,void
28220,BLOCK,-1,,{ ++iter_; },25,,1948,1,,void
28226,BLOCK,-1,,{ --iter_; },25,,1949,1,,void
28232,BLOCK,-1,,{ return iter_->first; },31,,1950,1,,void
28240,BLOCK,-1,,{ return iter_->second; },33,,1951,1,,void
28248,BLOCK,-1,,{ return Status::OK(); },35,,1952,1,,void
28263,BLOCK,-1,,"{
  int len = (rnd->OneIn(3)
             ? 1                // Short sometimes to encourage collisions
             : (rnd->OneIn(100) ? rnd->Skewed(10) : rnd->Uniform(10)));
  return test::RandomKey(rnd, len);
}",43,,1962,2,,void
28305,BLOCK,-1,,"{
  ReadOptions options;
  options.snapshot = model_snap;
  Iterator* miter = model->NewIterator(options);
  options.snapshot = db_snap;
  Iterator* dbiter = db->NewIterator(options);
  bool ok = true;
  int count = 0;
  for (miter->SeekToFirst(), dbiter->SeekToFirst();
       ok && miter->Valid() && dbiter->Valid();
       miter->Next(), dbiter->Next()) {
    count++;
    if (miter->key().compare(dbiter->key()) != 0) {
      fprintf(stderr, ""step %d: Key mismatch: '%s' vs. '%s'\n"",
              step,
              EscapeString(miter->key()).c_str(),
              EscapeString(dbiter->key()).c_str());
      ok = false;
      break;
    }

    if (miter->value().compare(dbiter->value()) != 0) {
      fprintf(stderr, ""step %d: Value mismatch for key '%s': '%s' vs. '%s'\n"",
              step,
              EscapeString(miter->key()).c_str(),
              EscapeString(miter->value()).c_str(),
              EscapeString(miter->value()).c_str());
      ok = false;
    }
  }

  if (ok) ...",55,,1973,6,,void
28342,BLOCK,-1,,<empty>,3,,1981,1,,void
28372,BLOCK,4,,"{
    count++;
    if (miter->key().compare(dbiter->key()) != 0) {
      fprintf(stderr, ""step %d: Key mismatch: '%s' vs. '%s'\n"",
              step,
              EscapeString(miter->key()).c_str(),
              EscapeString(dbiter->key()).c_str());
      ok = false;
      break;
    }

    if (miter->value().compare(dbiter->value()) != 0) {
      fprintf(stderr, ""step %d: Value mismatch for key '%s': '%s' vs. '%s'\n"",
              step,
              EscapeString(miter->key()).c_str(),
              EscapeString(miter->value()).c_str(),
              EscapeString(miter->value()).c_str());
      ok = false;
    }
  }",39,,1983,4,,void
28389,BLOCK,-1,,"{
      fprintf(stderr, ""step %d: Key mismatch: '%s' vs. '%s'\n"",
              step,
              EscapeString(miter->key()).c_str(),
              EscapeString(dbiter->key()).c_str());
      ok = false;
      break;
    }",51,,1985,2,,void
28428,BLOCK,-1,,"{
      fprintf(stderr, ""step %d: Value mismatch for key '%s': '%s' vs. '%s'\n"",
              step,
              EscapeString(miter->key()).c_str(),
              EscapeString(miter->value()).c_str(),
              EscapeString(miter->value()).c_str());
      ok = false;
    }",55,,1994,2,,void
28462,BLOCK,-1,,"{
    if (miter->Valid() != dbiter->Valid()) {
      fprintf(stderr, ""step %d: Mismatch at end of iterators: %d vs. %d\n"",
              step, miter->Valid(), dbiter->Valid());
      ok = false;
    }
  }",11,,2004,2,,void
28473,BLOCK,-1,,"{
      fprintf(stderr, ""step %d: Mismatch at end of iterators: %d vs. %d\n"",
              step, miter->Valid(), dbiter->Valid());
      ok = false;
    }",44,,2005,2,,void
28504,BLOCK,-1,,<empty>,,,,1,,<empty>
28508,BLOCK,-1,,"TEST(DBTest, Randomized)",1,,2017,1,,void
28532,BLOCK,-1,,"{
  Random rnd(test::RandomSeed());
  do {
    ModelDB model(CurrentOptions());
    const int N = 10000;
    const Snapshot* model_snap = NULL;
    const Snapshot* db_snap = NULL;
    std::string k, v;
    for (int step = 0; step < N; step++) {
      if (step % 100 == 0) {
        fprintf(stderr, ""Step %d of %d\n"", step, N);
      }
      // TODO(sanjay): Test Get() works
      int p = rnd.Uniform(100);
      if (p < 45) {                               // Put
        k = RandomKey(&rnd);
        v = RandomString(&rnd,
                         rnd.OneIn(20)
                         ? 100 + rnd.Uniform(100)
                         : rnd.Uniform(8));
        ASSERT_OK(model.Put(WriteOptions(), k, v));
        ASSERT_OK(db_->Put(WriteOptions(), k, v));

      } else if (p < 90) {                        // Delete
        k = RandomKey(&rnd);
        ASSERT_OK(model.Delete(WriteOptions(), k));
        ASSERT_OK(db_->Delete(WriteOptions(), k));


      } else {                            ...",26,,2017,1,,void
28540,BLOCK,-1,,"{
    ModelDB model(CurrentOptions());
    const int N = 10000;
    const Snapshot* model_snap = NULL;
    const Snapshot* db_snap = NULL;
    std::string k, v;
    for (int step = 0; step < N; step++) {
      if (step % 100 == 0) {
        fprintf(stderr, ""Step %d of %d\n"", step, N);
      }
      // TODO(sanjay): Test Get() works
      int p = rnd.Uniform(100);
      if (p < 45) {                               // Put
        k = RandomKey(&rnd);
        v = RandomString(&rnd,
                         rnd.OneIn(20)
                         ? 100 + rnd.Uniform(100)
                         : rnd.Uniform(8));
        ASSERT_OK(model.Put(WriteOptions(), k, v));
        ASSERT_OK(db_->Put(WriteOptions(), k, v));

      } else if (p < 90) {                        // Delete
        k = RandomKey(&rnd);
        ASSERT_OK(model.Delete(WriteOptions(), k));
        ASSERT_OK(db_->Delete(WriteOptions(), k));


      } else {                                    // Multi-element batch
        Wr...",6,,2019,1,,void
28559,BLOCK,-1,,<empty>,5,,2025,1,,void
28569,BLOCK,4,,"{
      if (step % 100 == 0) {
        fprintf(stderr, ""Step %d of %d\n"", step, N);
      }
      // TODO(sanjay): Test Get() works
      int p = rnd.Uniform(100);
      if (p < 45) {                               // Put
        k = RandomKey(&rnd);
        v = RandomString(&rnd,
                         rnd.OneIn(20)
                         ? 100 + rnd.Uniform(100)
                         : rnd.Uniform(8));
        ASSERT_OK(model.Put(WriteOptions(), k, v));
        ASSERT_OK(db_->Put(WriteOptions(), k, v));

      } else if (p < 90) {                        // Delete
        k = RandomKey(&rnd);
        ASSERT_OK(model.Delete(WriteOptions(), k));
        ASSERT_OK(db_->Delete(WriteOptions(), k));


      } else {                                    // Multi-element batch
        WriteBatch b;
        const int num = rnd.Uniform(8);
        for (int i = 0; i < num; i++) {
          if (i == 0 || !rnd.OneIn(10)) {
            k = RandomKey(&rnd);
          } else {
            // P...",42,,2025,4,,void
28576,BLOCK,-1,,"{
        fprintf(stderr, ""Step %d of %d\n"", step, N);
      }",28,,2026,2,,void
28594,BLOCK,-1,,"{                               // Put
        k = RandomKey(&rnd);
        v = RandomString(&rnd,
                         rnd.OneIn(20)
                         ? 100 + rnd.Uniform(100)
                         : rnd.Uniform(8));
        ASSERT_OK(model.Put(WriteOptions(), k, v));
        ASSERT_OK(db_->Put(WriteOptions(), k, v));

      }",19,,2031,2,,void
28624,BLOCK,1,,<empty>,,,,4,,void
28644,BLOCK,1,,<empty>,,,,3,,void
28664,BLOCK,-1,,<empty>,14,,2040,1,,void
28669,BLOCK,-1,,"{                        // Delete
        k = RandomKey(&rnd);
        ASSERT_OK(model.Delete(WriteOptions(), k));
        ASSERT_OK(db_->Delete(WriteOptions(), k));


      }",26,,2040,2,,void
28676,BLOCK,1,,<empty>,,,,3,,void
28695,BLOCK,1,,<empty>,,,,2,,void
28714,BLOCK,-1,,"{                                    // Multi-element batch
        WriteBatch b;
        const int num = rnd.Uniform(8);
        for (int i = 0; i < num; i++) {
          if (i == 0 || !rnd.OneIn(10)) {
            k = RandomKey(&rnd);
          } else {
            // Periodically re-use the same key from the previous iter, so
            // we have multiple entries in the write batch for the same key
          }
          if (rnd.OneIn(2)) {
            v = RandomString(&rnd, rnd.Uniform(10));
            b.Put(k, v);
          } else {
            b.Delete(k);
          }
        }
        ASSERT_OK(model.Write(WriteOptions(), &b));
        ASSERT_OK(db_->Write(WriteOptions(), &b));
      }",14,,2046,1,,void
28725,BLOCK,-1,,<empty>,9,,2049,1,,void
28735,BLOCK,4,,"{
          if (i == 0 || !rnd.OneIn(10)) {
            k = RandomKey(&rnd);
          } else {
            // Periodically re-use the same key from the previous iter, so
            // we have multiple entries in the write batch for the same key
          }
          if (rnd.OneIn(2)) {
            v = RandomString(&rnd, rnd.Uniform(10));
            b.Put(k, v);
          } else {
            b.Delete(k);
          }
        }",39,,2049,4,,void
28747,BLOCK,-1,,"{
            k = RandomKey(&rnd);
          }",41,,2050,2,,void
28754,BLOCK,-1,,"{
            // Periodically re-use the same key from the previous iter, so
            // we have multiple entries in the write batch for the same key
          }",18,,2052,1,,void
28761,BLOCK,-1,,"{
            v = RandomString(&rnd, rnd.Uniform(10));
            b.Put(k, v);
          }",29,,2056,2,,void
28779,BLOCK,-1,,"{
            b.Delete(k);
          }",18,,2059,1,,void
28786,BLOCK,1,,<empty>,,,,3,,void
28806,BLOCK,1,,<empty>,,,,2,,void
28831,BLOCK,-1,,"{
        ASSERT_TRUE(CompareIterators(step, &model, db_, NULL, NULL));
        ASSERT_TRUE(CompareIterators(step, &model, db_, model_snap, db_snap));
        // Save a snapshot from each DB this time that we'll use next
        // time we compare things, to make sure the current state is
        // preserved with the snapshot
        if (model_snap != NULL) model.ReleaseSnapshot(model_snap);
        if (db_snap != NULL) db_->ReleaseSnapshot(db_snap);

        Reopen();
        ASSERT_TRUE(CompareIterators(step, &model, db_, NULL, NULL));

        model_snap = model.GetSnapshot();
        db_snap = db_->GetSnapshot();
      }",30,,2067,2,,void
28833,BLOCK,1,,<empty>,,,,2,,void
28854,BLOCK,1,,<empty>,,,,4,,void
28878,BLOCK,-1,,<empty>,33,,2073,2,,void
28888,BLOCK,-1,,<empty>,30,,2074,2,,void
28896,BLOCK,1,,<empty>,,,,2,,void
28932,BLOCK,-1,,<empty>,29,,2083,2,,void
28942,BLOCK,-1,,<empty>,26,,2084,2,,void
28953,BLOCK,-1,,"{
  char buf[30];
  snprintf(buf, sizeof(buf), ""%016u"", num);
  return std::string(buf);
}",39,,2088,2,,void
28972,BLOCK,-1,,"{
  std::string dbname = test::TmpDir() + ""/leveldb_test_benchmark"";
  DestroyDB(dbname, Options());

  DB* db = NULL;
  Options opts;
  opts.create_if_missing = true;
  Status s = DB::Open(opts, dbname, &db);
  ASSERT_OK(s);
  ASSERT_TRUE(db != NULL);

  delete db;
  db = NULL;

  Env* env = Env::Default();

  port::Mutex mu;
  MutexLock l(&mu);

  InternalKeyComparator cmp(BytewiseComparator());
  Options options;
  VersionSet vset(dbname, &options, NULL, &cmp);
  bool save_manifest;
  ASSERT_OK(vset.Recover(&save_manifest));
  VersionEdit vbase;
  uint64_t fnum = 1;
  for (int i = 0; i < num_base_files; i++) {
    InternalKey start(MakeKey(2*fnum), 1, kTypeValue);
    InternalKey limit(MakeKey(2*fnum+1), 1, kTypeDeletion);
    vbase.AddFile(2, fnum++, 1 /* file size */, start, limit);
  }
  ASSERT_OK(vset.LogAndApply(&vbase, &mu));

  uint64_t start_micros = env->NowMicros();

  for (int i = 0; i < iters; i++) {
    VersionEdit vedit;
    vedit.DeleteFile(2, fnum);
    InternalKe...",52,,2094,3,,void
29008,BLOCK,1,,<empty>,,,,3,,void
29022,BLOCK,1,,<empty>,,,,2,,void
29075,BLOCK,1,,<empty>,,,,4,,void
29099,BLOCK,-1,,<empty>,3,,2120,1,,void
29109,BLOCK,4,,"{
    InternalKey start(MakeKey(2*fnum), 1, kTypeValue);
    InternalKey limit(MakeKey(2*fnum+1), 1, kTypeDeletion);
    vbase.AddFile(2, fnum++, 1 /* file size */, start, limit);
  }",44,,2120,4,,void
29139,BLOCK,1,,<empty>,,,,4,,void
29167,BLOCK,-1,,<empty>,3,,2129,1,,void
29177,BLOCK,4,,"{
    VersionEdit vedit;
    vedit.DeleteFile(2, fnum);
    InternalKey start(MakeKey(2*fnum), 1, kTypeValue);
    InternalKey limit(MakeKey(2*fnum+1), 1, kTypeDeletion);
    vedit.AddFile(2, fnum++, 1 /* file size */, start, limit);
    vset.LogAndApply(&vedit, &mu);
  }",35,,2129,4,,void
29257,BLOCK,-1,,"{
  if (argc > 1 && std::string(argv[1]) == ""--benchmark"") {
    leveldb::BM_LogAndApply(1000, 1);
    leveldb::BM_LogAndApply(1000, 100);
    leveldb::BM_LogAndApply(1000, 10000);
    leveldb::BM_LogAndApply(100, 100000);
    return 0;
  }

  return leveldb::test::RunAllTests();
}",33,,2148,3,,void
29272,BLOCK,-1,,"{
    leveldb::BM_LogAndApply(1000, 1);
    leveldb::BM_LogAndApply(1000, 100);
    leveldb::BM_LogAndApply(1000, 10000);
    leveldb::BM_LogAndApply(100, 100000);
    return 0;
  }",58,,2149,2,,void
29320,BLOCK,-1,,<empty>,1,,1,1,,ANY
29325,BLOCK,-1,,"{
  assert(seq <= kMaxSequenceNumber);
  assert(t <= kValueTypeForSeek);
  return (seq << 8) | t;
}",64,,12,3,,void
29345,BLOCK,-1,,"{
  result->append(key.user_key.data(), key.user_key.size());
  PutFixed64(result, PackSequenceAndType(key.sequence, key.type));
}",75,,18,3,,void
29374,BLOCK,-1,,"{
  char buf[50];
  snprintf(buf, sizeof(buf), ""' @ %llu : %d"",
           (unsigned long long) sequence,
           int(type));
  std::string result = ""'"";
  result += EscapeString(user_key.ToString());
  result += buf;
  return result;
}",52,,23,1,,void
29406,BLOCK,-1,,"{
  std::string result;
  ParsedInternalKey parsed;
  if (ParseInternalKey(rep_, &parsed)) {
    result = parsed.DebugString();
  } else {
    result = ""(bad)"";
    result.append(EscapeString(rep_));
  }
  return result;
}",46,,34,1,,void
29414,BLOCK,-1,,"{
    result = parsed.DebugString();
  }",40,,37,2,,void
29422,BLOCK,-1,,"{
    result = ""(bad)"";
    result.append(EscapeString(rep_));
  }",10,,39,1,,void
29437,BLOCK,-1,,"{
  return ""leveldb.InternalKeyComparator"";
}",49,,46,1,,void
29445,BLOCK,-1,,"{
  // Order by:
  //    increasing user key (according to user-supplied comparator)
  //    decreasing sequence number
  //    decreasing type (though sequence# should be enough to disambiguate)
  int r = user_comparator_->Compare(ExtractUserKey(akey), ExtractUserKey(bkey));
  if (r == 0) {
    const uint64_t anum = DecodeFixed64(akey.data() + akey.size() - 8);
    const uint64_t bnum = DecodeFixed64(bkey.data() + bkey.size() - 8);
    if (anum > bnum) {
      r = -1;
    } else if (anum < bnum) {
      r = +1;
    }
  }
  return r;
}",80,,50,3,,void
29461,BLOCK,-1,,"{
    const uint64_t anum = DecodeFixed64(akey.data() + akey.size() - 8);
    const uint64_t bnum = DecodeFixed64(bkey.data() + bkey.size() - 8);
    if (anum > bnum) {
      r = -1;
    } else if (anum < bnum) {
      r = +1;
    }
  }",15,,56,2,,void
29496,BLOCK,-1,,"{
      r = -1;
    }",22,,59,2,,void
29502,BLOCK,-1,,<empty>,12,,61,1,,void
29507,BLOCK,-1,,"{
      r = +1;
    }",29,,61,2,,void
29519,BLOCK,-1,,"{
  // Attempt to shorten the user portion of the key
  Slice user_start = ExtractUserKey(*start);
  Slice user_limit = ExtractUserKey(limit);
  std::string tmp(user_start.data(), user_start.size());
  user_comparator_->FindShortestSeparator(&tmp, user_limit);
  if (tmp.size() < user_start.size() &&
      user_comparator_->Compare(user_start, tmp) < 0) {
    // User key has become shorter physically, but larger logically.
    // Tack on the earliest possible number to the shortened user key.
    PutFixed64(&tmp, PackSequenceAndType(kMaxSequenceNumber,kValueTypeForSeek));
    assert(this->Compare(*start, tmp) < 0);
    assert(this->Compare(tmp, limit) < 0);
    start->swap(tmp);
  }
}",33,,70,3,,void
29567,BLOCK,-1,,"{
    // User key has become shorter physically, but larger logically.
    // Tack on the earliest possible number to the shortened user key.
    PutFixed64(&tmp, PackSequenceAndType(kMaxSequenceNumber,kValueTypeForSeek));
    assert(this->Compare(*start, tmp) < 0);
    assert(this->Compare(tmp, limit) < 0);
    start->swap(tmp);
  }",55,,77,2,,void
29602,BLOCK,-1,,"{
  Slice user_key = ExtractUserKey(*key);
  std::string tmp(user_key.data(), user_key.size());
  user_comparator_->FindShortSuccessor(&tmp);
  if (tmp.size() < user_key.size() &&
      user_comparator_->Compare(user_key, tmp) < 0) {
    // User key has become shorter physically, but larger logically.
    // Tack on the earliest possible number to the shortened user key.
    PutFixed64(&tmp, PackSequenceAndType(kMaxSequenceNumber,kValueTypeForSeek));
    assert(this->Compare(*key, tmp) < 0);
    key->swap(tmp);
  }
}",72,,87,2,,void
29644,BLOCK,-1,,"{
    // User key has become shorter physically, but larger logically.
    // Tack on the earliest possible number to the shortened user key.
    PutFixed64(&tmp, PackSequenceAndType(kMaxSequenceNumber,kValueTypeForSeek));
    assert(this->Compare(*key, tmp) < 0);
    key->swap(tmp);
  }",53,,92,2,,void
29669,BLOCK,-1,,"{
  return user_policy_->Name();
}",48,,101,1,,void
29681,BLOCK,-1,,"{
  // We rely on the fact that the code in table.cc does not mind us
  // adjusting keys[].
  Slice* mkey = const_cast<Slice*>(keys);
  for (int i = 0; i < n; i++) {
    mkey[i] = ExtractUserKey(keys[i]);
    // TODO(sanjay): Suppress dups?
  }
  user_policy_->CreateFilter(keys, n, dst);
}",65,,106,4,,void
29689,BLOCK,-1,,<empty>,3,,110,1,,void
29699,BLOCK,4,,"{
    mkey[i] = ExtractUserKey(keys[i]);
    // TODO(sanjay): Suppress dups?
  }",31,,110,4,,void
29720,BLOCK,-1,,"{
  return user_policy_->KeyMayMatch(ExtractUserKey(key), f);
}",80,,117,3,,void
29734,BLOCK,-1,,"{
  size_t usize = user_key.size();
  size_t needed = usize + 13;  // A conservative estimate
  char* dst;
  if (needed <= sizeof(space_)) {
    dst = space_;
  } else {
    dst = new char[needed];
  }
  start_ = dst;
  dst = EncodeVarint32(dst, usize + 8);
  kstart_ = dst;
  memcpy(dst, user_key.data(), usize);
  dst += usize;
  EncodeFixed64(dst, PackSequenceAndType(s, kValueTypeForSeek));
  dst += 8;
  end_ = dst;
}",63,,121,3,,void
29754,BLOCK,-1,,"{
    dst = space_;
  }",33,,125,2,,void
29759,BLOCK,-1,,"{
    dst = new char[needed];
  }",10,,127,1,,void
29820,BLOCK,-1,,<empty>,1,,1,1,,ANY
29852,BLOCK,-1,,<empty>,,,,1,,<empty>
29879,BLOCK,-1,,{ },23,,75,1,,void
29886,BLOCK,-1,,{ },45,,77,4,,void
29890,BLOCK,-1,,<empty>,,,,1,,<empty>
29895,BLOCK,-1,,"{
  return key.user_key.size() + 8;
}",71,,82,2,,void
29910,BLOCK,-1,,<empty>,,,,3,,<empty>
29916,BLOCK,-1,,<empty>,,,,3,,<empty>
29921,BLOCK,-1,,"{
  assert(internal_key.size() >= 8);
  return Slice(internal_key.data(), internal_key.size() - 8);
}",56,,98,2,,void
29945,BLOCK,-1,,"{
  assert(internal_key.size() >= 8);
  const size_t n = internal_key.size();
  uint64_t num = DecodeFixed64(internal_key.data() + n - 8);
  unsigned char c = num & 0xff;
  return static_cast<ValueType>(c);
}",62,,103,2,,void
29988,BLOCK,-1,,{ },77,,117,2,,void
29992,BLOCK,-1,,<empty>,,,,1,,<empty>
29998,BLOCK,-1,,<empty>,,,,3,,<empty>
30004,BLOCK,-1,,<empty>,,,,3,,<empty>
30009,BLOCK,-1,,<empty>,,,,2,,<empty>
30013,BLOCK,-1,,{ return user_comparator_; },45,,125,1,,void
30021,BLOCK,-1,,<empty>,,,,3,,<empty>
30028,BLOCK,-1,,{ },74,,135,2,,void
30032,BLOCK,-1,,<empty>,,,,1,,<empty>
30039,BLOCK,-1,,<empty>,,,,4,,<empty>
30045,BLOCK,-1,,<empty>,,,,3,,<empty>
30051,BLOCK,-1,,{ },17,,148,1,,void
30058,BLOCK,-1,,"{
    AppendInternalKey(&rep_, ParsedInternalKey(user_key, s, t));
  }",69,,149,4,,void
30070,BLOCK,-1,,"{ rep_.assign(s.data(), s.size()); }",35,,153,2,,void
30086,BLOCK,-1,,"{
    assert(!rep_.empty());
    return rep_;
  }",24,,154,1,,void
30098,BLOCK,-1,,{ return ExtractUserKey(rep_); },26,,159,1,,void
30106,BLOCK,-1,,"{
    rep_.clear();
    AppendInternalKey(&rep_, p);
  }",44,,161,2,,void
30118,BLOCK,-1,,{ rep_.clear(); },16,,166,1,,void
30126,BLOCK,-1,,<empty>,,,,1,,<empty>
30132,BLOCK,-1,,"{
  return Compare(a.Encode(), b.Encode());
}",55,,172,3,,void
30148,BLOCK,-1,,"{
  const size_t n = internal_key.size();
  if (n < 8) return false;
  uint64_t num = DecodeFixed64(internal_key.data() + n - 8);
  unsigned char c = num & 0xff;
  result->sequence = num >> 8;
  result->type = static_cast<ValueType>(c);
  result->user_key = Slice(internal_key.data(), n - 8);
  return (c <= static_cast<unsigned char>(kTypeValue));
}",57,,177,3,,void
30160,BLOCK,-1,,<empty>,14,,179,2,,void
30219,BLOCK,-1,,<empty>,,,,3,,<empty>
30223,BLOCK,-1,,<empty>,,,,1,,<empty>
30227,BLOCK,-1,,"{ return Slice(start_, end_ - start_); }",30,,198,1,,void
30237,BLOCK,-1,,"{ return Slice(kstart_, end_ - kstart_); }",30,,201,1,,void
30247,BLOCK,-1,,"{ return Slice(kstart_, end_ - kstart_ - 8); }",26,,204,1,,void
30264,BLOCK,-1,,<empty>,,,,2,,<empty>
30269,BLOCK,-1,,<empty>,,,,2,,<empty>
30273,BLOCK,-1,,<empty>,,,,1,,<empty>
30279,BLOCK,-1,,"{
  if (start_ != space_) delete[] start_;
}",32,,224,1,,void
30284,BLOCK,-1,,<empty>,25,,225,2,,void
30299,BLOCK,-1,,<empty>,1,,1,1,,ANY
30305,BLOCK,-1,,"{
  std::string encoded;
  AppendInternalKey(&encoded, ParsedInternalKey(user_key, seq, vt));
  return encoded;
}",39,,13,4,,void
30321,BLOCK,-1,,"{
  std::string result = s;
  InternalKeyComparator(BytewiseComparator()).FindShortestSeparator(&result, l);
  return result;
}",72,,19,3,,void
30340,BLOCK,-1,,"{
  std::string result = s;
  InternalKeyComparator(BytewiseComparator()).FindShortSuccessor(&result);
  return result;
}",57,,25,2,,void
30360,BLOCK,-1,,"{
  std::string encoded = IKey(key, seq, vt);

  Slice in(encoded);
  ParsedInternalKey decoded("""", 0, kTypeValue);

  ASSERT_TRUE(ParseInternalKey(in, &decoded));
  ASSERT_EQ(key, decoded.user_key.ToString());
  ASSERT_EQ(seq, decoded.sequence);
  ASSERT_EQ(vt, decoded.type);

  ASSERT_TRUE(!ParseInternalKey(Slice(""bar""), &decoded));
}",35,,33,4,,void
30377,BLOCK,1,,<empty>,,,,3,,void
30402,BLOCK,1,,<empty>,,,,4,,void
30426,BLOCK,1,,<empty>,,,,4,,void
30447,BLOCK,1,,<empty>,,,,4,,void
30464,BLOCK,1,,<empty>,,,,2,,void
30488,BLOCK,-1,,<empty>,,,,1,,<empty>
30492,BLOCK,-1,,"TEST(FormatTest, InternalKey_EncodeDecode)",1,,49,1,,void
30516,BLOCK,-1,,"{
  const char* keys[] = { """", ""k"", ""hello"", ""longggggggggggggggggggggg"" };
  const uint64_t seq[] = {
    1, 2, 3,
    (1ull << 8) - 1, 1ull << 8, (1ull << 8) + 1,
    (1ull << 16) - 1, 1ull << 16, (1ull << 16) + 1,
    (1ull << 32) - 1, 1ull << 32, (1ull << 32) + 1
  };
  for (int k = 0; k < sizeof(keys) / sizeof(keys[0]); k++) {
    for (int s = 0; s < sizeof(seq) / sizeof(seq[0]); s++) {
      TestKey(keys[k], seq[s], kTypeValue);
      TestKey(""hello"", 1, kTypeDeletion);
    }
  }
}",44,,49,1,,void
30572,BLOCK,-1,,<empty>,3,,57,1,,void
30588,BLOCK,4,,"{
    for (int s = 0; s < sizeof(seq) / sizeof(seq[0]); s++) {
      TestKey(keys[k], seq[s], kTypeValue);
      TestKey(""hello"", 1, kTypeDeletion);
    }
  }",60,,57,4,,void
30590,BLOCK,-1,,<empty>,5,,58,1,,void
30606,BLOCK,4,,"{
      TestKey(keys[k], seq[s], kTypeValue);
      TestKey(""hello"", 1, kTypeDeletion);
    }",60,,58,4,,void
30623,BLOCK,-1,,<empty>,,,,1,,<empty>
30627,BLOCK,-1,,"TEST(FormatTest, InternalKeyShortSeparator)",1,,65,1,,void
30651,BLOCK,-1,,"{
  // When user keys are same
  ASSERT_EQ(IKey(""foo"", 100, kTypeValue),
            Shorten(IKey(""foo"", 100, kTypeValue),
                    IKey(""foo"", 99, kTypeValue)));
  ASSERT_EQ(IKey(""foo"", 100, kTypeValue),
            Shorten(IKey(""foo"", 100, kTypeValue),
                    IKey(""foo"", 101, kTypeValue)));
  ASSERT_EQ(IKey(""foo"", 100, kTypeValue),
            Shorten(IKey(""foo"", 100, kTypeValue),
                    IKey(""foo"", 100, kTypeValue)));
  ASSERT_EQ(IKey(""foo"", 100, kTypeValue),
            Shorten(IKey(""foo"", 100, kTypeValue),
                    IKey(""foo"", 100, kTypeDeletion)));

  // When user keys are misordered
  ASSERT_EQ(IKey(""foo"", 100, kTypeValue),
            Shorten(IKey(""foo"", 100, kTypeValue),
                    IKey(""bar"", 99, kTypeValue)));

  // When user keys are different, but correctly ordered
  ASSERT_EQ(IKey(""g"", kMaxSequenceNumber, kValueTypeForSeek),
            Shorten(IKey(""foo"", 100, kTypeValue),
                    IKey(""hello"", 200, ...",45,,65,1,,void
30653,BLOCK,1,,<empty>,,,,1,,void
30679,BLOCK,1,,<empty>,,,,1,,void
30705,BLOCK,1,,<empty>,,,,1,,void
30731,BLOCK,1,,<empty>,,,,1,,void
30757,BLOCK,1,,<empty>,,,,1,,void
30783,BLOCK,1,,<empty>,,,,1,,void
30809,BLOCK,1,,<empty>,,,,1,,void
30835,BLOCK,1,,<empty>,,,,1,,void
30864,BLOCK,-1,,<empty>,,,,1,,<empty>
30868,BLOCK,-1,,"TEST(FormatTest, InternalKeyShortestSuccessor)",1,,101,1,,void
30892,BLOCK,-1,,"{
  ASSERT_EQ(IKey(""g"", kMaxSequenceNumber, kValueTypeForSeek),
            ShortSuccessor(IKey(""foo"", 100, kTypeValue)));
  ASSERT_EQ(IKey(""\xff\xff"", 100, kTypeValue),
            ShortSuccessor(IKey(""\xff\xff"", 100, kTypeValue)));
}",48,,101,1,,void
30894,BLOCK,1,,<empty>,,,,1,,void
30916,BLOCK,1,,<empty>,,,,1,,void
30942,BLOCK,-1,,"{
  return leveldb::test::RunAllTests();
}",33,,110,3,,void
30982,BLOCK,-1,,<empty>,1,,1,1,,ANY
30988,BLOCK,-1,,"{
  size_t pos = fname.rfind('/');
  std::string basename;
  if (pos == std::string::npos) {
    basename = fname;
  } else {
    basename = std::string(fname.data() + pos + 1, fname.size() - pos - 1);
  }
  uint64_t ignored;
  return ParseFileName(basename, &ignored, type);
}",58,,23,3,,void
31006,BLOCK,-1,,"{
    basename = fname;
  }",33,,26,2,,void
31011,BLOCK,-1,,"{
    basename = std::string(fname.data() + pos + 1, fname.size() - pos - 1);
  }",10,,28,1,,void
31048,BLOCK,-1,,"{
    std::string r = ""corruption: "";
    AppendNumberTo(&r, bytes);
    r += "" bytes; "";
    r += status.ToString();
    r.push_back('\n');
    dst_->Append(r);
  }",63,,39,3,,void
31083,BLOCK,-1,,"{
  SequentialFile* file;
  Status s = env->NewSequentialFile(fname, &file);
  if (!s.ok()) {
    return s;
  }
  CorruptionReporter reporter;
  reporter.dst_ = dst;
  log::Reader reader(file, &reporter, true, 0);
  Slice record;
  std::string scratch;
  while (reader.ReadRecord(&record, &scratch)) {
    (*func)(reader.LastRecordOffset(), record, dst);
  }
  delete file;
  return Status::OK();
}",44,,52,5,,void
31101,BLOCK,-1,,"{
    return s;
  }",16,,55,2,,void
31128,BLOCK,-1,,"{
    (*func)(reader.LastRecordOffset(), record, dst);
  }",48,,63,2,,void
31152,BLOCK,-1,,"{
    std::string r = ""  put '"";
    AppendEscapedStringTo(&r, key);
    r += ""' '"";
    AppendEscapedStringTo(&r, value);
    r += ""'\n"";
    dst_->Append(r);
  }",58,,74,3,,void
31180,BLOCK,-1,,"{
    std::string r = ""  del '"";
    AppendEscapedStringTo(&r, key);
    r += ""'\n"";
    dst_->Append(r);
  }",41,,82,2,,void
31203,BLOCK,-1,,"{
  std::string r = ""--- offset "";
  AppendNumberTo(&r, pos);
  r += ""; "";
  if (record.size() < 12) {
    r += ""log record length "";
    AppendNumberTo(&r, record.size());
    r += "" is too small\n"";
    dst->Append(r);
    return;
  }
  WriteBatch batch;
  WriteBatchInternal::SetContents(&batch, record);
  r += ""sequence "";
  AppendNumberTo(&r, WriteBatchInternal::Sequence(&batch));
  r.push_back('\n');
  dst->Append(r);
  WriteBatchItemPrinter batch_item_printer;
  batch_item_printer.dst_ = dst;
  Status s = batch.Iterate(&batch_item_printer);
  if (!s.ok()) {
    dst->Append(""  error: "" + s.ToString() + ""\n"");
  }
}",78,,93,4,,void
31222,BLOCK,-1,,"{
    r += ""log record length "";
    AppendNumberTo(&r, record.size());
    r += "" is too small\n"";
    dst->Append(r);
    return;
  }",27,,97,2,,void
31293,BLOCK,-1,,"{
    dst->Append(""  error: "" + s.ToString() + ""\n"");
  }",16,,113,2,,void
31312,BLOCK,-1,,"{
  return PrintLogContents(env, fname, WriteBatchPrinter, dst);
}",71,,118,4,,void
31325,BLOCK,-1,,"{
  std::string r = ""--- offset "";
  AppendNumberTo(&r, pos);
  r += ""; "";
  VersionEdit edit;
  Status s = edit.DecodeFrom(record);
  if (!s.ok()) {
    r += s.ToString();
    r.push_back('\n');
  } else {
    r += edit.DebugString();
  }
  dst->Append(r);
}",79,,124,4,,void
31352,BLOCK,-1,,"{
    r += s.ToString();
    r.push_back('\n');
  }",16,,130,2,,void
31365,BLOCK,-1,,"{
    r += edit.DebugString();
  }",10,,133,1,,void
31383,BLOCK,-1,,"{
  return PrintLogContents(env, fname, VersionEditPrinter, dst);
}",78,,139,4,,void
31396,BLOCK,-1,,"{
  uint64_t file_size;
  RandomAccessFile* file = NULL;
  Table* table = NULL;
  Status s = env->GetFileSize(fname, &file_size);
  if (s.ok()) {
    s = env->NewRandomAccessFile(fname, &file);
  }
  if (s.ok()) {
    // We use the default comparator, which may or may not match the
    // comparator used in this database. However this should not cause
    // problems since we only use Table operations that do not require
    // any comparisons.  In particular, we do not call Seek or Prev.
    s = Table::Open(Options(), file, file_size, &table);
  }
  if (!s.ok()) {
    delete table;
    delete file;
    return s;
  }

  ReadOptions ro;
  ro.fill_cache = false;
  Iterator* iter = table->NewIterator(ro);
  std::string r;
  for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {
    r.clear();
    ParsedInternalKey key;
    if (!ParseInternalKey(iter->key(), &key)) {
      r = ""badkey '"";
      AppendEscapedStringTo(&r, iter->key());
      r += ""' => '"";
      AppendEscapedStringTo(&r...",73,,143,4,,void
31421,BLOCK,-1,,"{
    s = env->NewRandomAccessFile(fname, &file);
  }",15,,148,2,,void
31436,BLOCK,-1,,"{
    // We use the default comparator, which may or may not match the
    // comparator used in this database. However this should not cause
    // problems since we only use Table operations that do not require
    // any comparisons.  In particular, we do not call Seek or Prev.
    s = Table::Open(Options(), file, file_size, &table);
  }",15,,151,2,,void
31454,BLOCK,-1,,"{
    delete table;
    delete file;
    return s;
  }",16,,158,2,,void
31477,BLOCK,-1,,<empty>,3,,168,1,,void
31490,BLOCK,4,,"{
    r.clear();
    ParsedInternalKey key;
    if (!ParseInternalKey(iter->key(), &key)) {
      r = ""badkey '"";
      AppendEscapedStringTo(&r, iter->key());
      r += ""' => '"";
      AppendEscapedStringTo(&r, iter->value());
      r += ""'\n"";
      dst->Append(r);
    } else {
      r = ""'"";
      AppendEscapedStringTo(&r, key.user_key);
      r += ""' @ "";
      AppendNumberTo(&r, key.sequence);
      r += "" : "";
      if (key.type == kTypeDeletion) {
        r += ""del"";
      } else if (key.type == kTypeValue) {
        r += ""val"";
      } else {
        AppendNumberTo(&r, key.type);
      }
      r += "" => '"";
      AppendEscapedStringTo(&r, iter->value());
      r += ""'\n"";
      dst->Append(r);
    }
  }",58,,168,4,,void
31505,BLOCK,-1,,"{
      r = ""badkey '"";
      AppendEscapedStringTo(&r, iter->key());
      r += ""' => '"";
      AppendEscapedStringTo(&r, iter->value());
      r += ""'\n"";
      dst->Append(r);
    }",47,,171,2,,void
31535,BLOCK,-1,,"{
      r = ""'"";
      AppendEscapedStringTo(&r, key.user_key);
      r += ""' @ "";
      AppendNumberTo(&r, key.sequence);
      r += "" : "";
      if (key.type == kTypeDeletion) {
        r += ""del"";
      } else if (key.type == kTypeValue) {
        r += ""val"";
      } else {
        AppendNumberTo(&r, key.type);
      }
      r += "" => '"";
      AppendEscapedStringTo(&r, iter->value());
      r += ""'\n"";
      dst->Append(r);
    }",12,,178,1,,void
31563,BLOCK,-1,,"{
        r += ""del"";
      }",38,,184,2,,void
31568,BLOCK,-1,,<empty>,14,,186,1,,void
31575,BLOCK,-1,,"{
        r += ""val"";
      }",42,,186,2,,void
31580,BLOCK,-1,,"{
        AppendNumberTo(&r, key.type);
      }",14,,188,1,,void
31617,BLOCK,-1,,"{
    dst->Append(""iterator error: "" + s.ToString() + ""\n"");
  }",16,,198,2,,void
31647,BLOCK,-1,,"{
  FileType ftype;
  if (!GuessType(fname, &ftype)) {
    return Status::InvalidArgument(fname + "": unknown file type"");
  }
  switch (ftype) {
    case kLogFile:         return DumpLog(env, fname, dst);
    case kDescriptorFile:  return DumpDescriptor(env, fname, dst);
    case kTableFile:       return DumpTable(env, fname, dst);
    default:
      break;
  }
  return Status::InvalidArgument(fname + "": not a dump-able file type"");
}",72,,210,4,,void
31655,BLOCK,-1,,"{
    return Status::InvalidArgument(fname + "": unknown file type"");
  }",34,,212,2,,void
31666,BLOCK,-1,,"{
    case kLogFile:         return DumpLog(env, fname, dst);
    case kDescriptorFile:  return DumpDescriptor(env, fname, dst);
    case kTableFile:       return DumpTable(env, fname, dst);
    default:
      break;
  }",18,,215,2,,void
31734,BLOCK,-1,,<empty>,1,,1,1,,ANY
31752,BLOCK,-1,,"{
  size_t found = filename.find_last_of(""/\\"");
  if (found == std::string::npos) {
    return """";
  } else {
    return filename.substr(0, found);
  }
}",59,,37,2,,void
31769,BLOCK,-1,,"{
    return """";
  }",35,,39,2,,void
31773,BLOCK,-1,,"{
    return filename.substr(0, found);
  }",10,,41,1,,void
31785,BLOCK,-1,,"{
  // As this is a test it isn't required to *actually* sync this directory.
  return Status::OK();
}",40,,46,2,,void
31796,BLOCK,-1,,"{
  leveldb::Env* env = leveldb::Env::Default();

  SequentialFile* orig_file;
  Status s = env->NewSequentialFile(filename, &orig_file);
  if (!s.ok())
    return s;

  char* scratch = new char[length];
  leveldb::Slice result;
  s = orig_file->Read(length, &result, scratch);
  delete orig_file;
  if (s.ok()) {
    std::string tmp_name = GetDirName(filename) + ""/truncate.tmp"";
    WritableFile* tmp_file;
    s = env->NewWritableFile(tmp_name, &tmp_file);
    if (s.ok()) {
      s = tmp_file->Append(result);
      delete tmp_file;
      if (s.ok()) {
        s = env->RenameFile(tmp_name, filename);
      } else {
        env->DeleteFile(tmp_name);
      }
    }
  }

  delete[] scratch;

  return s;
}",63,,52,3,,void
31823,BLOCK,-1,,<empty>,5,,58,2,,void
31849,BLOCK,-1,,"{
    std::string tmp_name = GetDirName(filename) + ""/truncate.tmp"";
    WritableFile* tmp_file;
    s = env->NewWritableFile(tmp_name, &tmp_file);
    if (s.ok()) {
      s = tmp_file->Append(result);
      delete tmp_file;
      if (s.ok()) {
        s = env->RenameFile(tmp_name, filename);
      } else {
        env->DeleteFile(tmp_name);
      }
    }
  }",15,,64,2,,void
31872,BLOCK,-1,,"{
      s = tmp_file->Append(result);
      delete tmp_file;
      if (s.ok()) {
        s = env->RenameFile(tmp_name, filename);
      } else {
        env->DeleteFile(tmp_name);
      }
    }",17,,68,2,,void
31887,BLOCK,-1,,"{
        s = env->RenameFile(tmp_name, filename);
      }",19,,71,2,,void
31897,BLOCK,-1,,"{
        env->DeleteFile(tmp_name);
      }",14,,73,1,,void
31916,BLOCK,-1,,{ },32,,94,2,,void
31920,BLOCK,-1,,<empty>,73,,96,1,,void
31924,BLOCK,-1,,{ return pos_ <= 0 || pos_ == pos_at_last_sync_; },30,,98,1,,void
31936,BLOCK,-1,,<empty>,,,,1,,<empty>
31944,BLOCK,-1,,<empty>,,,,4,,<empty>
31948,BLOCK,-1,,<empty>,,,,1,,<empty>
31953,BLOCK,-1,,<empty>,,,,2,,<empty>
31957,BLOCK,-1,,<empty>,,,,1,,<empty>
31961,BLOCK,-1,,<empty>,,,,1,,<empty>
31965,BLOCK,-1,,<empty>,,,,1,,<empty>
31973,BLOCK,-1,,<empty>,,,,1,,<empty>
31978,BLOCK,-1,,<empty>,82,,129,1,,void
31982,BLOCK,-1,,{ },36,,130,1,,void
31988,BLOCK,-1,,<empty>,,,,3,,<empty>
31994,BLOCK,-1,,<empty>,,,,3,,<empty>
31999,BLOCK,-1,,<empty>,,,,2,,<empty>
32005,BLOCK,-1,,<empty>,,,,3,,<empty>
32010,BLOCK,-1,,<empty>,,,,2,,<empty>
32014,BLOCK,-1,,<empty>,,,,1,,<empty>
32018,BLOCK,-1,,<empty>,,,,1,,<empty>
32022,BLOCK,-1,,<empty>,,,,1,,<empty>
32027,BLOCK,-1,,<empty>,,,,2,,<empty>
32031,BLOCK,-1,,<empty>,,,,1,,<empty>
32036,BLOCK,-1,,<empty>,,,,2,,<empty>
32040,BLOCK,-1,,{ return filesystem_active_; },35,,149,1,,void
32047,BLOCK,-1,,{ filesystem_active_ = active; },41,,150,2,,void
32061,BLOCK,-1,,"{
  assert(f != NULL);
}",17,,165,4,,void
32069,BLOCK,-1,,"{
  if (writable_file_opened_) {
    Close();
  }
  delete target_;
}",39,,169,1,,void
32072,BLOCK,-1,,"{
    Close();
  }",30,,170,2,,void
32080,BLOCK,-1,,"{
  Status s = target_->Append(data);
  if (s.ok() && env_->IsFilesystemActive()) {
    state_.pos_ += data.size();
  }
  return s;
}",52,,176,2,,void
32099,BLOCK,-1,,"{
    state_.pos_ += data.size();
  }",45,,178,2,,void
32113,BLOCK,-1,,"{
  writable_file_opened_ = false;
  Status s = target_->Close();
  if (s.ok()) {
    env_->WritableFileClosed(state_);
  }
  return s;
}",34,,184,1,,void
32129,BLOCK,-1,,"{
    env_->WritableFileClosed(state_);
  }",15,,187,2,,void
32140,BLOCK,-1,,"{
  Status s = target_->Flush();
  if (s.ok() && env_->IsFilesystemActive()) {
    state_.pos_at_last_flush_ = state_.pos_;
  }
  return s;
}",34,,193,1,,void
32158,BLOCK,-1,,"{
    state_.pos_at_last_flush_ = state_.pos_;
  }",45,,195,2,,void
32171,BLOCK,-1,,"{
  Status s = SyncDir(GetDirName(state_.filename_));
  if (s.ok()) {
    env_->DirWasSynced();
  }
  return s;
}",39,,201,1,,void
32185,BLOCK,-1,,"{
    env_->DirWasSynced();
  }",15,,203,2,,void
32195,BLOCK,-1,,"{
  if (!env_->IsFilesystemActive()) {
    return Status::OK();
  }
  // Ensure new files referred to by the manifest are in the filesystem.
  Status s = target_->Sync();
  if (s.ok()) {
    state_.pos_at_last_sync_ = state_.pos_;
  }
  if (env_->IsFileCreatedSinceLastDirSync(state_.filename_)) {
    Status ps = SyncParent();
    if (s.ok() && !ps.ok()) {
      s = ps;
    }
  }
  return s;
}",33,,209,1,,void
32202,BLOCK,-1,,"{
    return Status::OK();
  }",36,,210,2,,void
32220,BLOCK,-1,,"{
    state_.pos_at_last_sync_ = state_.pos_;
  }",15,,215,2,,void
32236,BLOCK,-1,,"{
    Status ps = SyncParent();
    if (s.ok() && !ps.ok()) {
      s = ps;
    }
  }",62,,218,2,,void
32252,BLOCK,-1,,"{
      s = ps;
    }",29,,220,2,,void
32263,BLOCK,-1,,"{
  WritableFile* actual_writable_file;
  Status s = target()->NewWritableFile(fname, &actual_writable_file);
  if (s.ok()) {
    FileState state(fname);
    state.pos_ = 0;
    *result = new TestWritableFile(state, actual_writable_file, this);
    // NewWritableFile doesn't append to files, so if the same file is
    // opened again then it will be truncated - so forget our saved
    // state.
    UntrackFile(fname);
    MutexLock l(&mutex_);
    new_files_since_last_dir_sync_.insert(fname);
  }
  return s;
}",70,,228,3,,void
32280,BLOCK,-1,,"{
    FileState state(fname);
    state.pos_ = 0;
    *result = new TestWritableFile(state, actual_writable_file, this);
    // NewWritableFile doesn't append to files, so if the same file is
    // opened again then it will be truncated - so forget our saved
    // state.
    UntrackFile(fname);
    MutexLock l(&mutex_);
    new_files_since_last_dir_sync_.insert(fname);
  }",15,,231,2,,void
32315,BLOCK,-1,,"{
  WritableFile* actual_writable_file;
  Status s = target()->NewAppendableFile(fname, &actual_writable_file);
  if (s.ok()) {
    FileState state(fname);
    state.pos_ = 0;
    {
      MutexLock l(&mutex_);
      if (db_file_state_.count(fname) == 0) {
        new_files_since_last_dir_sync_.insert(fname);
      } else {
        state = db_file_state_[fname];
      }
    }
    *result = new TestWritableFile(state, actual_writable_file, this);
  }
  return s;
}",72,,246,3,,void
32332,BLOCK,-1,,"{
    FileState state(fname);
    state.pos_ = 0;
    {
      MutexLock l(&mutex_);
      if (db_file_state_.count(fname) == 0) {
        new_files_since_last_dir_sync_.insert(fname);
      } else {
        state = db_file_state_[fname];
      }
    }
    *result = new TestWritableFile(state, actual_writable_file, this);
  }",15,,249,2,,void
32341,BLOCK,4,,"{
      MutexLock l(&mutex_);
      if (db_file_state_.count(fname) == 0) {
        new_files_since_last_dir_sync_.insert(fname);
      } else {
        state = db_file_state_[fname];
      }
    }",5,,252,4,,void
32354,BLOCK,-1,,"{
        new_files_since_last_dir_sync_.insert(fname);
      }",45,,254,2,,void
32361,BLOCK,-1,,"{
        state = db_file_state_[fname];
      }",14,,256,1,,void
32380,BLOCK,-1,,"{
  Status s;
  MutexLock l(&mutex_);
  for (std::map<std::string, FileState>::const_iterator it =
           db_file_state_.begin();
       s.ok() && it != db_file_state_.end(); ++it) {
    const FileState& state = it->second;
    if (!state.IsFullySynced()) {
      s = state.DropUnsyncedData();
    }
  }
  return s;
}",54,,265,1,,void
32387,BLOCK,-1,,<empty>,3,,268,1,,void
32408,BLOCK,4,,"{
    const FileState& state = it->second;
    if (!state.IsFullySynced()) {
      s = state.DropUnsyncedData();
    }
  }",52,,270,4,,void
32421,BLOCK,-1,,"{
      s = state.DropUnsyncedData();
    }",33,,272,2,,void
32433,BLOCK,-1,,"{
  MutexLock l(&mutex_);
  new_files_since_last_dir_sync_.clear();
}",44,,279,1,,void
32446,BLOCK,-1,,"{
  MutexLock l(&mutex_);
  return new_files_since_last_dir_sync_.find(filename) !=
         new_files_since_last_dir_sync_.end();
}",34,,285,2,,void
32466,BLOCK,-1,,"{
  MutexLock l(&mutex_);
  db_file_state_.erase(f);
  new_files_since_last_dir_sync_.erase(f);
}",63,,291,2,,void
32485,BLOCK,-1,,"{
  Status s = EnvWrapper::DeleteFile(f);
  ASSERT_OK(s);
  if (s.ok()) {
    UntrackFile(f);
  }
  return s;
}",64,,297,2,,void
32496,BLOCK,1,,<empty>,,,,3,,void
32514,BLOCK,-1,,"{
    UntrackFile(f);
  }",15,,300,2,,void
32524,BLOCK,-1,,"{
  Status ret = EnvWrapper::RenameFile(s, t);

  if (ret.ok()) {
    MutexLock l(&mutex_);
    if (db_file_state_.find(s) != db_file_state_.end()) {
      db_file_state_[t] = db_file_state_[s];
      db_file_state_.erase(s);
    }

    if (new_files_since_last_dir_sync_.erase(s) != 0) {
      assert(new_files_since_last_dir_sync_.find(t) ==
             new_files_since_last_dir_sync_.end());
      new_files_since_last_dir_sync_.insert(t);
    }
  }

  return ret;
}",64,,307,3,,void
32539,BLOCK,-1,,"{
    MutexLock l(&mutex_);
    if (db_file_state_.find(s) != db_file_state_.end()) {
      db_file_state_[t] = db_file_state_[s];
      db_file_state_.erase(s);
    }

    if (new_files_since_last_dir_sync_.erase(s) != 0) {
      assert(new_files_since_last_dir_sync_.find(t) ==
             new_files_since_last_dir_sync_.end());
      new_files_since_last_dir_sync_.insert(t);
    }
  }",17,,310,2,,void
32555,BLOCK,-1,,"{
      db_file_state_[t] = db_file_state_[s];
      db_file_state_.erase(s);
    }",57,,312,2,,void
32576,BLOCK,-1,,"{
      assert(new_files_since_last_dir_sync_.find(t) ==
             new_files_since_last_dir_sync_.end());
      new_files_since_last_dir_sync_.insert(t);
    }",55,,317,2,,void
32598,BLOCK,-1,,"{
  // Since we are not destroying the database, the existing files
  // should keep their recorded synced/flushed state. Therefore
  // we do not reset db_file_state_ and new_files_since_last_dir_sync_.
  MutexLock l(&mutex_);
  SetFilesystemActive(true);
}",42,,327,1,,void
32608,BLOCK,-1,,"{
  // Because DeleteFile access this container make a copy to avoid deadlock
  mutex_.Lock();
  std::set<std::string> new_files(new_files_since_last_dir_sync_.begin(),
                                  new_files_since_last_dir_sync_.end());
  mutex_.Unlock();
  Status s;
  std::set<std::string>::const_iterator it;
  for (it = new_files.begin(); s.ok() && it != new_files.end(); ++it) {
    s = DeleteFile(*it);
  }
  return s;
}",68,,335,1,,void
32637,BLOCK,-1,,<empty>,3,,343,1,,void
32657,BLOCK,4,,"{
    s = DeleteFile(*it);
  }",71,,343,4,,void
32669,BLOCK,-1,,"{
  MutexLock l(&mutex_);
  db_file_state_[state.filename_] = state;
}",72,,349,2,,void
32684,BLOCK,-1,,"{
  ssize_t sync_pos = pos_at_last_sync_ == -1 ? 0 : pos_at_last_sync_;
  return Truncate(filename_, sync_pos);
}",44,,354,1,,void
32714,BLOCK,-1,,"{
    dbname_ = test::TmpDir() + ""/fault_test"";
    DestroyDB(dbname_, Options());  // Destroy any db from earlier run
    options_.reuse_logs = true;
    options_.env = env_;
    options_.paranoid_checks = true;
    options_.block_cache = tiny_cache_;
    options_.create_if_missing = true;
  }",19,,373,1,,void
32754,BLOCK,-1,,"{
    CloseDB();
    DestroyDB(dbname_, Options());
    delete tiny_cache_;
    delete env_;
  }",25,,383,1,,void
32767,BLOCK,-1,,"{
    options_.reuse_logs = reuse;
  }",30,,390,2,,void
32778,BLOCK,-1,,"{
    std::string key_space, value_space;
    WriteBatch batch;
    for (int i = start_idx; i < start_idx + num_vals; i++) {
      Slice key = Key(i, &key_space);
      batch.Clear();
      batch.Put(key, Value(i, &value_space));
      WriteOptions options;
      ASSERT_OK(db_->Write(options, &batch));
    }
  }",43,,394,3,,void
32783,BLOCK,-1,,<empty>,5,,397,1,,void
32795,BLOCK,4,,"{
      Slice key = Key(i, &key_space);
      batch.Clear();
      batch.Put(key, Value(i, &value_space));
      WriteOptions options;
      ASSERT_OK(db_->Write(options, &batch));
    }",60,,397,4,,void
32818,BLOCK,1,,<empty>,,,,3,,void
32842,BLOCK,-1,,"{
    std::string key_space, value_space;
    Slice key = Key(i, &key_space);
    Value(i, &value_space);
    ReadOptions options;
    return db_->Get(options, key, val);
  }",51,,406,3,,void
32871,BLOCK,-1,,"{
    std::string val;
    std::string value_space;
    Status s;
    for (int i = start_idx; i < start_idx + num_vals && s.ok(); i++) {
      Value(i, &value_space);
      s = ReadValue(i, &val);
      if (expected == VAL_EXPECT_NO_ERROR) {
        if (s.ok()) {
          ASSERT_EQ(value_space, val);
        }
      } else if (s.ok()) {
        fprintf(stderr, ""Expected an error at %d, but was OK\n"", i);
        s = Status::IOError(dbname_, ""Expected value error:"");
      } else {
        s = Status::OK();  // An expected error
      }
    }
    return s;
  }",53,,415,4,,void
32876,BLOCK,-1,,<empty>,5,,419,1,,void
32893,BLOCK,4,,"{
      Value(i, &value_space);
      s = ReadValue(i, &val);
      if (expected == VAL_EXPECT_NO_ERROR) {
        if (s.ok()) {
          ASSERT_EQ(value_space, val);
        }
      } else if (s.ok()) {
        fprintf(stderr, ""Expected an error at %d, but was OK\n"", i);
        s = Status::IOError(dbname_, ""Expected value error:"");
      } else {
        s = Status::OK();  // An expected error
      }
    }",70,,419,4,,void
32908,BLOCK,-1,,"{
        if (s.ok()) {
          ASSERT_EQ(value_space, val);
        }
      }",44,,422,2,,void
32914,BLOCK,-1,,"{
          ASSERT_EQ(value_space, val);
        }",21,,423,2,,void
32918,BLOCK,1,,<empty>,,,,5,,void
32933,BLOCK,-1,,<empty>,14,,426,1,,void
32939,BLOCK,-1,,"{
        fprintf(stderr, ""Expected an error at %d, but was OK\n"", i);
        s = Status::IOError(dbname_, ""Expected value error:"");
      }",26,,426,2,,void
32953,BLOCK,-1,,"{
        s = Status::OK();  // An expected error
      }",14,,429,1,,void
32967,BLOCK,-1,,"{
    char buf[100];
    snprintf(buf, sizeof(buf), ""%016d"", i);
    storage->assign(buf, strlen(buf));
    return Slice(*storage);
  }",48,,437,3,,void
32991,BLOCK,-1,,"{
    Random r(k);
    return test::RandomString(&r, kValueSize, storage);
  }",50,,445,3,,void
33007,BLOCK,-1,,"{
    delete db_;
    db_ = NULL;
    env_->ResetState();
    return DB::Open(options_, dbname_, &db_);
  }",19,,450,1,,void
33029,BLOCK,-1,,"{
    delete db_;
    db_ = NULL;
  }",18,,457,1,,void
33038,BLOCK,-1,,"{
    Iterator* iter = db_->NewIterator(ReadOptions());
    WriteOptions options;
    for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {
      ASSERT_OK(db_->Delete(WriteOptions(), iter->key()));
    }

    delete iter;
  }",24,,462,1,,void
33049,BLOCK,-1,,<empty>,5,,465,1,,void
33062,BLOCK,4,,"{
      ASSERT_OK(db_->Delete(WriteOptions(), iter->key()));
    }",60,,465,4,,void
33064,BLOCK,1,,<empty>,,,,2,,void
33091,BLOCK,-1,,"{
    switch (reset_method) {
      case RESET_DROP_UNSYNCED_DATA:
        ASSERT_OK(env_->DropUnsyncedFileData());
        break;
      case RESET_DELETE_UNSYNCED_FILES:
        ASSERT_OK(env_->DeleteFilesCreatedAfterLastDirSync());
        break;
      default:
        assert(false);
    }
  }",47,,472,2,,void
33094,BLOCK,-1,,"{
      case RESET_DROP_UNSYNCED_DATA:
        ASSERT_OK(env_->DropUnsyncedFileData());
        break;
      case RESET_DELETE_UNSYNCED_FILES:
        ASSERT_OK(env_->DeleteFilesCreatedAfterLastDirSync());
        break;
      default:
        assert(false);
    }",27,,473,2,,void
33102,BLOCK,1,,<empty>,,,,2,,void
33126,BLOCK,1,,<empty>,,,,2,,void
33151,BLOCK,-1,,"{
    DeleteAllData();
    Build(0, num_pre_sync);
    db_->CompactRange(NULL, NULL);
    Build(num_pre_sync, num_post_sync);
  }",72,,485,3,,void
33171,BLOCK,-1,,"{
    env_->SetFilesystemActive(false);
    CloseDB();
    ResetDBState(reset_method);
    ASSERT_OK(OpenDB());
    ASSERT_OK(Verify(0, num_pre_sync, FaultInjectionTest::VAL_EXPECT_NO_ERROR));
    ASSERT_OK(Verify(num_pre_sync, num_post_sync, FaultInjectionTest::VAL_EXPECT_ERROR));
  }",61,,494,4,,void
33182,BLOCK,1,,<empty>,,,,2,,void
33196,BLOCK,1,,<empty>,,,,1,,void
33215,BLOCK,1,,<empty>,,,,1,,void
33236,BLOCK,-1,,"{
  }",30,,503,1,,void
33241,BLOCK,-1,,"{
    CloseDB();
    ResetDBState(reset_method);
    ASSERT_OK(OpenDB());
  }",61,,506,2,,void
33247,BLOCK,1,,<empty>,,,,2,,void
33263,BLOCK,-1,,"{
    Random rnd(0);
    ASSERT_OK(OpenDB());
    for (size_t idx = 0; idx < kNumIterations; idx++) {
      int num_pre_sync = rnd.Uniform(kMaxNumValues);
      int num_post_sync = rnd.Uniform(kMaxNumValues);

      PartialCompactTestPreFault(num_pre_sync, num_post_sync);
      PartialCompactTestReopenWithFault(RESET_DROP_UNSYNCED_DATA,
                                        num_pre_sync,
                                        num_post_sync);

      NoWriteTestPreFault();
      NoWriteTestReopenWithFault(RESET_DROP_UNSYNCED_DATA);

      PartialCompactTestPreFault(num_pre_sync, num_post_sync);
      // No new files created so we expect all values since no files will be
      // dropped.
      PartialCompactTestReopenWithFault(RESET_DELETE_UNSYNCED_FILES,
                                        num_pre_sync + num_post_sync,
                                        0);

      NoWriteTestPreFault();
      NoWriteTestReopenWithFault(RESET_DELETE_UNSYNCED_FILES);
    }
  }",17,,512,1,,void
33269,BLOCK,1,,<empty>,,,,2,,void
33283,BLOCK,-1,,<empty>,5,,515,1,,void
33293,BLOCK,4,,"{
      int num_pre_sync = rnd.Uniform(kMaxNumValues);
      int num_post_sync = rnd.Uniform(kMaxNumValues);

      PartialCompactTestPreFault(num_pre_sync, num_post_sync);
      PartialCompactTestReopenWithFault(RESET_DROP_UNSYNCED_DATA,
                                        num_pre_sync,
                                        num_post_sync);

      NoWriteTestPreFault();
      NoWriteTestReopenWithFault(RESET_DROP_UNSYNCED_DATA);

      PartialCompactTestPreFault(num_pre_sync, num_post_sync);
      // No new files created so we expect all values since no files will be
      // dropped.
      PartialCompactTestReopenWithFault(RESET_DELETE_UNSYNCED_FILES,
                                        num_pre_sync + num_post_sync,
                                        0);

      NoWriteTestPreFault();
      NoWriteTestReopenWithFault(RESET_DELETE_UNSYNCED_FILES);
    }",55,,515,4,,void
33336,BLOCK,-1,,<empty>,,,,1,,<empty>
33340,BLOCK,-1,,"TEST(FaultInjectionTest, FaultTestNoLogReuse)",1,,540,1,,void
33364,BLOCK,-1,,"{
  ReuseLogs(false);
  DoTest();
}",47,,540,1,,void
33372,BLOCK,-1,,<empty>,,,,1,,<empty>
33376,BLOCK,-1,,"TEST(FaultInjectionTest, FaultTestWithLogReuse)",1,,545,1,,void
33400,BLOCK,-1,,"{
  ReuseLogs(true);
  DoTest();
}",49,,545,1,,void
33409,BLOCK,-1,,"{
  return leveldb::test::RunAllTests();
}",33,,552,3,,void
33435,BLOCK,-1,,<empty>,1,,1,1,,ANY
33441,BLOCK,-1,,<empty>,,,,4,,<empty>
33448,BLOCK,-1,,"{
  char buf[100];
  snprintf(buf, sizeof(buf), ""/%06llu.%s"",
           static_cast<unsigned long long>(number),
           suffix);
  return name + buf;
}",53,,19,4,,void
33468,BLOCK,-1,,"{
  assert(number > 0);
  return MakeFileName(name, number, ""log"");
}",67,,27,3,,void
33483,BLOCK,-1,,"{
  assert(number > 0);
  return MakeFileName(name, number, ""ldb"");
}",69,,32,3,,void
33498,BLOCK,-1,,"{
  assert(number > 0);
  return MakeFileName(name, number, ""sst"");
}",72,,37,3,,void
33513,BLOCK,-1,,"{
  assert(number > 0);
  char buf[100];
  snprintf(buf, sizeof(buf), ""/MANIFEST-%06llu"",
           static_cast<unsigned long long>(number));
  return dbname + buf;
}",76,,42,3,,void
33535,BLOCK,-1,,"{
  return dbname + ""/CURRENT"";
}",56,,50,2,,void
33544,BLOCK,-1,,"{
  return dbname + ""/LOCK"";
}",53,,54,2,,void
33554,BLOCK,-1,,"{
  assert(number > 0);
  return MakeFileName(dbname, number, ""dbtmp"");
}",70,,58,3,,void
33568,BLOCK,-1,,"{
  return dbname + ""/LOG"";
}",56,,63,2,,void
33577,BLOCK,-1,,"{
  return dbname + ""/LOG.old"";
}",59,,68,2,,void
33588,BLOCK,-1,,"{
  Slice rest(fname);
  if (rest == ""CURRENT"") {
    *number = 0;
    *type = kCurrentFile;
  } else if (rest == ""LOCK"") {
    *number = 0;
    *type = kDBLockFile;
  } else if (rest == ""LOG"" || rest == ""LOG.old"") {
    *number = 0;
    *type = kInfoLogFile;
  } else if (rest.starts_with(""MANIFEST-"")) {
    rest.remove_prefix(strlen(""MANIFEST-""));
    uint64_t num;
    if (!ConsumeDecimalNumber(&rest, &num)) {
      return false;
    }
    if (!rest.empty()) {
      return false;
    }
    *type = kDescriptorFile;
    *number = num;
  } else {
    // Avoid strtoull() to keep filename format independent of the
    // current locale
    uint64_t num;
    if (!ConsumeDecimalNumber(&rest, &num)) {
      return false;
    }
    Slice suffix = rest;
    if (suffix == Slice("".log"")) {
      *type = kLogFile;
    } else if (suffix == Slice("".sst"") || suffix == Slice("".ldb"")) {
      *type = kTableFile;
    } else if (suffix == Slice("".dbtmp"")) {
      *type = kTempFile;
    } else {
      ...",36,,82,4,,void
33596,BLOCK,-1,,"{
    *number = 0;
    *type = kCurrentFile;
  }",26,,84,2,,void
33606,BLOCK,-1,,<empty>,10,,87,1,,void
33611,BLOCK,-1,,"{
    *number = 0;
    *type = kDBLockFile;
  }",30,,87,2,,void
33621,BLOCK,-1,,<empty>,10,,90,1,,void
33630,BLOCK,-1,,"{
    *number = 0;
    *type = kInfoLogFile;
  }",50,,90,2,,void
33640,BLOCK,-1,,<empty>,10,,93,1,,void
33647,BLOCK,-1,,"{
    rest.remove_prefix(strlen(""MANIFEST-""));
    uint64_t num;
    if (!ConsumeDecimalNumber(&rest, &num)) {
      return false;
    }
    if (!rest.empty()) {
      return false;
    }
    *type = kDescriptorFile;
    *number = num;
  }",45,,93,2,,void
33662,BLOCK,-1,,"{
      return false;
    }",45,,96,2,,void
33671,BLOCK,-1,,"{
      return false;
    }",24,,99,2,,void
33683,BLOCK,-1,,"{
    // Avoid strtoull() to keep filename format independent of the
    // current locale
    uint64_t num;
    if (!ConsumeDecimalNumber(&rest, &num)) {
      return false;
    }
    Slice suffix = rest;
    if (suffix == Slice("".log"")) {
      *type = kLogFile;
    } else if (suffix == Slice("".sst"") || suffix == Slice("".ldb"")) {
      *type = kTableFile;
    } else if (suffix == Slice("".dbtmp"")) {
      *type = kTempFile;
    } else {
      return false;
    }
    *number = num;
  }",10,,104,1,,void
33692,BLOCK,-1,,"{
      return false;
    }",45,,108,2,,void
33704,BLOCK,-1,,"{
      *type = kLogFile;
    }",34,,112,2,,void
33710,BLOCK,-1,,<empty>,12,,114,1,,void
33721,BLOCK,-1,,"{
      *type = kTableFile;
    }",68,,114,2,,void
33727,BLOCK,-1,,<empty>,12,,116,1,,void
33733,BLOCK,-1,,"{
      *type = kTempFile;
    }",43,,116,2,,void
33739,BLOCK,-1,,"{
      return false;
    }",12,,118,1,,void
33754,BLOCK,-1,,"{
  // Remove leading ""dbname/"" and add newline to manifest file name
  std::string manifest = DescriptorFileName(dbname, descriptor_number);
  Slice contents = manifest;
  assert(contents.starts_with(dbname + ""/""));
  contents.remove_prefix(dbname.size() + 1);
  std::string tmp = TempFileName(dbname, descriptor_number);
  Status s = WriteStringToFileSync(env, contents.ToString() + ""\n"", tmp);
  if (s.ok()) {
    s = env->RenameFile(tmp, CurrentFileName(dbname));
  }
  if (!s.ok()) {
    env->DeleteFile(tmp);
  }
  return s;
}",51,,127,4,,void
33806,BLOCK,-1,,"{
    s = env->RenameFile(tmp, CurrentFileName(dbname));
  }",15,,135,2,,void
33822,BLOCK,-1,,"{
    env->DeleteFile(tmp);
  }",16,,138,2,,void
33846,BLOCK,-1,,<empty>,1,,1,1,,ANY
33860,BLOCK,-1,,<empty>,,,,3,,<empty>
33866,BLOCK,-1,,<empty>,,,,3,,<empty>
33872,BLOCK,-1,,<empty>,,,,3,,<empty>
33878,BLOCK,-1,,<empty>,,,,3,,<empty>
33883,BLOCK,-1,,<empty>,,,,2,,<empty>
33888,BLOCK,-1,,<empty>,,,,2,,<empty>
33894,BLOCK,-1,,<empty>,,,,3,,<empty>
33899,BLOCK,-1,,<empty>,,,,2,,<empty>
33904,BLOCK,-1,,<empty>,,,,2,,<empty>
33911,BLOCK,-1,,<empty>,,,,4,,<empty>
33918,BLOCK,-1,,<empty>,,,,4,,<empty>
33935,BLOCK,-1,,<empty>,1,,1,1,,ANY
33940,BLOCK,-1,,<empty>,,,,1,,<empty>
33944,BLOCK,-1,,"TEST(FileNameTest, Parse)",1,,16,1,,void
33968,BLOCK,-1,,"{
  Slice db;
  FileType type;
  uint64_t number;

  // Successful parses
  static struct {
    const char* fname;
    uint64_t number;
    FileType type;
  } cases[] = {
    { ""100.log"",            100,   kLogFile },
    { ""0.log"",              0,     kLogFile },
    { ""0.sst"",              0,     kTableFile },
    { ""0.ldb"",              0,     kTableFile },
    { ""CURRENT"",            0,     kCurrentFile },
    { ""LOCK"",               0,     kDBLockFile },
    { ""MANIFEST-2"",         2,     kDescriptorFile },
    { ""MANIFEST-7"",         7,     kDescriptorFile },
    { ""LOG"",                0,     kInfoLogFile },
    { ""LOG.old"",            0,     kInfoLogFile },
    { ""18446744073709551615.log"", 18446744073709551615ull, kLogFile },
  };
  for (int i = 0; i < sizeof(cases) / sizeof(cases[0]); i++) {
    std::string f = cases[i].fname;
    ASSERT_TRUE(ParseFileName(f, &number, &type)) << f;
    ASSERT_EQ(cases[i].type, type) << f;
    ASSERT_EQ(cases[i].number, number) << f;
  }

 ...",27,,16,1,,void
34021,BLOCK,-1,,<empty>,3,,39,1,,void
34037,BLOCK,4,,"{
    std::string f = cases[i].fname;
    ASSERT_TRUE(ParseFileName(f, &number, &type)) << f;
    ASSERT_EQ(cases[i].type, type) << f;
    ASSERT_EQ(cases[i].number, number) << f;
  }",62,,39,4,,void
34048,BLOCK,1,,<empty>,,,,4,,void
34076,BLOCK,1,,<empty>,,,,5,,void
34103,BLOCK,1,,<empty>,,,,5,,void
34149,BLOCK,-1,,<empty>,3,,71,1,,void
34165,BLOCK,4,,"{
    std::string f = errors[i];
    ASSERT_TRUE(!ParseFileName(f, &number, &type)) << f;
  }",64,,71,4,,void
34174,BLOCK,1,,<empty>,,,,4,,void
34199,BLOCK,-1,,<empty>,,,,1,,<empty>
34203,BLOCK,-1,,"TEST(FileNameTest, Construction)",1,,77,1,,void
34227,BLOCK,-1,,"{
  uint64_t number;
  FileType type;
  std::string fname;

  fname = CurrentFileName(""foo"");
  ASSERT_EQ(""foo/"", std::string(fname.data(), 4));
  ASSERT_TRUE(ParseFileName(fname.c_str() + 4, &number, &type));
  ASSERT_EQ(0, number);
  ASSERT_EQ(kCurrentFile, type);

  fname = LockFileName(""foo"");
  ASSERT_EQ(""foo/"", std::string(fname.data(), 4));
  ASSERT_TRUE(ParseFileName(fname.c_str() + 4, &number, &type));
  ASSERT_EQ(0, number);
  ASSERT_EQ(kDBLockFile, type);

  fname = LogFileName(""foo"", 192);
  ASSERT_EQ(""foo/"", std::string(fname.data(), 4));
  ASSERT_TRUE(ParseFileName(fname.c_str() + 4, &number, &type));
  ASSERT_EQ(192, number);
  ASSERT_EQ(kLogFile, type);

  fname = TableFileName(""bar"", 200);
  ASSERT_EQ(""bar/"", std::string(fname.data(), 4));
  ASSERT_TRUE(ParseFileName(fname.c_str() + 4, &number, &type));
  ASSERT_EQ(200, number);
  ASSERT_EQ(kTableFile, type);

  fname = DescriptorFileName(""bar"", 100);
  ASSERT_EQ(""bar/"", std::string(fname.data(), 4));
  ASSERT_TRUE(...",34,,77,1,,void
34237,BLOCK,1,,<empty>,,,,3,,void
34260,BLOCK,1,,<empty>,,,,4,,void
34287,BLOCK,1,,<empty>,,,,4,,void
34304,BLOCK,1,,<empty>,,,,4,,void
34324,BLOCK,1,,<empty>,,,,3,,void
34347,BLOCK,1,,<empty>,,,,4,,void
34374,BLOCK,1,,<empty>,,,,4,,void
34391,BLOCK,1,,<empty>,,,,4,,void
34412,BLOCK,1,,<empty>,,,,3,,void
34435,BLOCK,1,,<empty>,,,,4,,void
34462,BLOCK,1,,<empty>,,,,4,,void
34479,BLOCK,1,,<empty>,,,,4,,void
34500,BLOCK,1,,<empty>,,,,3,,void
34523,BLOCK,1,,<empty>,,,,4,,void
34550,BLOCK,1,,<empty>,,,,4,,void
34567,BLOCK,1,,<empty>,,,,4,,void
34588,BLOCK,1,,<empty>,,,,3,,void
34611,BLOCK,1,,<empty>,,,,4,,void
34638,BLOCK,1,,<empty>,,,,4,,void
34655,BLOCK,1,,<empty>,,,,4,,void
34676,BLOCK,1,,<empty>,,,,3,,void
34699,BLOCK,1,,<empty>,,,,4,,void
34726,BLOCK,1,,<empty>,,,,4,,void
34743,BLOCK,1,,<empty>,,,,4,,void
34762,BLOCK,-1,,"{
  return leveldb::test::RunAllTests();
}",33,,121,3,,void
34784,BLOCK,-1,,<empty>,1,,1,1,,ANY
34790,BLOCK,-1,,"{
    fwrite(data.data(), 1, data.size(), stdout);
    return Status::OK();
  }",44,,15,2,,void
34810,BLOCK,-1,,{ return Status::OK(); },26,,19,1,,void
34819,BLOCK,-1,,{ return Status::OK(); },26,,20,1,,void
34828,BLOCK,-1,,{ return Status::OK(); },25,,21,1,,void
34840,BLOCK,-1,,"{
  StdoutPrinter printer;
  bool ok = true;
  for (int i = 0; i < num; i++) {
    Status s = DumpFile(env, files[i], &printer);
    if (!s.ok()) {
      fprintf(stderr, ""%s\n"", s.ToString().c_str());
      ok = false;
    }
  }
  return ok;
}",57,,24,4,,void
34847,BLOCK,-1,,<empty>,3,,27,1,,void
34857,BLOCK,4,,"{
    Status s = DumpFile(env, files[i], &printer);
    if (!s.ok()) {
      fprintf(stderr, ""%s\n"", s.ToString().c_str());
      ok = false;
    }
  }",33,,27,4,,void
34874,BLOCK,-1,,"{
      fprintf(stderr, ""%s\n"", s.ToString().c_str());
      ok = false;
    }",18,,29,2,,void
34893,BLOCK,-1,,"{
  fprintf(
      stderr,
      ""Usage: leveldbutil command...\n""
      ""   dump files...         -- dump contents of specified files\n""
      );
}",21,,40,1,,void
34902,BLOCK,-1,,"{
  leveldb::Env* env = leveldb::Env::Default();
  bool ok = true;
  if (argc < 2) {
    Usage();
    ok = false;
  } else {
    std::string command = argv[1];
    if (command == ""dump"") {
      ok = leveldb::HandleDumpCommand(env, argv+2, argc-2);
    } else {
      Usage();
      ok = false;
    }
  }
  return (ok ? 0 : 1);
}",33,,48,3,,void
34920,BLOCK,-1,,"{
    Usage();
    ok = false;
  }",17,,51,2,,void
34926,BLOCK,-1,,"{
    std::string command = argv[1];
    if (command == ""dump"") {
      ok = leveldb::HandleDumpCommand(env, argv+2, argc-2);
    } else {
      Usage();
      ok = false;
    }
  }",10,,54,1,,void
34937,BLOCK,-1,,"{
      ok = leveldb::HandleDumpCommand(env, argv+2, argc-2);
    }",28,,56,2,,void
34952,BLOCK,-1,,"{
      Usage();
      ok = false;
    }",12,,58,1,,void
34968,BLOCK,-1,,<empty>,1,,1,1,,ANY
34978,BLOCK,-1,,<empty>,,,,1,,<empty>
35026,BLOCK,-1,,<empty>,1,,1,1,,ANY
35030,BLOCK,-1,,"{
}",31,,15,1,,void
35038,BLOCK,-1,,"{
}",38,,29,5,,void
35042,BLOCK,-1,,"{
  delete[] backing_store_;
}",19,,32,1,,void
35048,BLOCK,-1,,"{
  size_t offset_in_block = initial_offset_ % kBlockSize;
  uint64_t block_start_location = initial_offset_ - offset_in_block;

  // Don't search a block if we'd be in the trailer
  if (offset_in_block > kBlockSize - 6) {
    offset_in_block = 0;
    block_start_location += kBlockSize;
  }

  end_of_buffer_offset_ = block_start_location;

  // Skip to start of first block that can contain the initial record
  if (block_start_location > 0) {
    Status skip_status = file_->Skip(block_start_location);
    if (!skip_status.ok()) {
      ReportDrop(block_start_location, skip_status);
      return false;
    }
  }

  return true;
}",35,,36,1,,void
35067,BLOCK,-1,,"{
    offset_in_block = 0;
    block_start_location += kBlockSize;
  }",41,,41,2,,void
35081,BLOCK,-1,,"{
    Status skip_status = file_->Skip(block_start_location);
    if (!skip_status.ok()) {
      ReportDrop(block_start_location, skip_status);
      return false;
    }
  }",33,,49,2,,void
35096,BLOCK,-1,,"{
      ReportDrop(block_start_location, skip_status);
      return false;
    }",28,,51,2,,void
35109,BLOCK,-1,,"{
  if (last_record_offset_ < initial_offset_) {
    if (!SkipToInitialBlock()) {
      return false;
    }
  }

  scratch->clear();
  record->clear();
  bool in_fragmented_record = false;
  // Record offset of the logical record that we're reading
  // 0 is a dummy value to make compilers happy
  uint64_t prospective_record_offset = 0;

  Slice fragment;
  while (true) {
    const unsigned int record_type = ReadPhysicalRecord(&fragment);

    // ReadPhysicalRecord may have only had an empty trailer remaining in its
    // internal buffer. Calculate the offset of the next physical record now
    // that it has returned, properly accounting for its header size.
    uint64_t physical_record_offset =
        end_of_buffer_offset_ - buffer_.size() - kHeaderSize - fragment.size();

    if (resyncing_) {
      if (record_type == kMiddleType) {
        continue;
      } else if (record_type == kLastType) {
        resyncing_ = false;
        continue;
      } else {
        resyncing_ = fa...",62,,60,3,,void
35114,BLOCK,-1,,"{
    if (!SkipToInitialBlock()) {
      return false;
    }
  }",46,,61,2,,void
35118,BLOCK,-1,,"{
      return false;
    }",32,,62,2,,void
35140,BLOCK,-1,,"{
    const unsigned int record_type = ReadPhysicalRecord(&fragment);

    // ReadPhysicalRecord may have only had an empty trailer remaining in its
    // internal buffer. Calculate the offset of the next physical record now
    // that it has returned, properly accounting for its header size.
    uint64_t physical_record_offset =
        end_of_buffer_offset_ - buffer_.size() - kHeaderSize - fragment.size();

    if (resyncing_) {
      if (record_type == kMiddleType) {
        continue;
      } else if (record_type == kLastType) {
        resyncing_ = false;
        continue;
      } else {
        resyncing_ = false;
      }
    }

    switch (record_type) {
      case kFullType:
        if (in_fragmented_record) {
          // Handle bug in earlier versions of log::Writer where
          // it could emit an empty kFirstType record at the tail end
          // of a block followed by a kFullType or kFirstType record
          // at the beginning of the next block.
          if (s...",16,,75,2,,void
35165,BLOCK,-1,,"{
      if (record_type == kMiddleType) {
        continue;
      } else if (record_type == kLastType) {
        resyncing_ = false;
        continue;
      } else {
        resyncing_ = false;
      }
    }",21,,84,2,,void
35170,BLOCK,-1,,"{
        continue;
      }",39,,85,2,,void
35173,BLOCK,-1,,<empty>,14,,87,1,,void
35178,BLOCK,-1,,"{
        resyncing_ = false;
        continue;
      }",44,,87,2,,void
35184,BLOCK,-1,,"{
        resyncing_ = false;
      }",14,,90,1,,void
35190,BLOCK,-1,,"{
      case kFullType:
        if (in_fragmented_record) {
          // Handle bug in earlier versions of log::Writer where
          // it could emit an empty kFirstType record at the tail end
          // of a block followed by a kFullType or kFirstType record
          // at the beginning of the next block.
          if (scratch->empty()) {
            in_fragmented_record = false;
          } else {
            ReportCorruption(scratch->size(), ""partial record without end(1)"");
          }
        }
        prospective_record_offset = physical_record_offset;
        scratch->clear();
        *record = fragment;
        last_record_offset_ = prospective_record_offset;
        return true;

      case kFirstType:
        if (in_fragmented_record) {
          // Handle bug in earlier versions of log::Writer where
          // it could emit an empty kFirstType record at the tail end
          // of a block followed by a kFullType or kFirstType record
          // at the beginning o...",26,,95,2,,void
35195,BLOCK,-1,,"{
          // Handle bug in earlier versions of log::Writer where
          // it could emit an empty kFirstType record at the tail end
          // of a block followed by a kFullType or kFirstType record
          // at the beginning of the next block.
          if (scratch->empty()) {
            in_fragmented_record = false;
          } else {
            ReportCorruption(scratch->size(), ""partial record without end(1)"");
          }
        }",35,,97,2,,void
35201,BLOCK,-1,,"{
            in_fragmented_record = false;
          }",33,,102,2,,void
35206,BLOCK,-1,,"{
            ReportCorruption(scratch->size(), ""partial record without end(1)"");
          }",18,,104,1,,void
35233,BLOCK,-1,,"{
          // Handle bug in earlier versions of log::Writer where
          // it could emit an empty kFirstType record at the tail end
          // of a block followed by a kFullType or kFirstType record
          // at the beginning of the next block.
          if (scratch->empty()) {
            in_fragmented_record = false;
          } else {
            ReportCorruption(scratch->size(), ""partial record without end(2)"");
          }
        }",35,,115,2,,void
35239,BLOCK,-1,,"{
            in_fragmented_record = false;
          }",33,,120,2,,void
35244,BLOCK,-1,,"{
            ReportCorruption(scratch->size(), ""partial record without end(2)"");
          }",18,,122,1,,void
35275,BLOCK,-1,,"{
          ReportCorruption(fragment.size(),
                           ""missing start of fragmented record(1)"");
        }",36,,132,2,,void
35283,BLOCK,-1,,"{
          scratch->append(fragment.data(), fragment.size());
        }",16,,135,1,,void
35302,BLOCK,-1,,"{
          ReportCorruption(fragment.size(),
                           ""missing start of fragmented record(2)"");
        }",36,,141,2,,void
35310,BLOCK,-1,,"{
          scratch->append(fragment.data(), fragment.size());
          *record = Slice(*scratch);
          last_record_offset_ = prospective_record_offset;
          return true;
        }",16,,144,1,,void
35339,BLOCK,-1,,"{
          // This can be caused by the writer dying immediately after
          // writing a physical record but before completing the next; don't
          // treat it as a corruption, just ignore the entire logical record.
          scratch->clear();
        }",35,,153,2,,void
35350,BLOCK,-1,,"{
          ReportCorruption(scratch->size(), ""error in middle of record"");
          in_fragmented_record = false;
          scratch->clear();
        }",35,,162,2,,void
35366,BLOCK,33,,"{
        char buf[40];
        snprintf(buf, sizeof(buf), ""unknown record type %u"", record_type);
        ReportCorruption(
            (fragment.size() + (in_fragmented_record ? scratch->size() : 0)),
            buf);
        in_fragmented_record = false;
        scratch->clear();
        break;
      }",16,,169,33,,void
35401,BLOCK,-1,,"{
  return last_record_offset_;
}",37,,184,1,,void
35409,BLOCK,-1,,"{
  ReportDrop(bytes, Status::Corruption(reason));
}",67,,188,3,,void
35422,BLOCK,-1,,"{
  if (reporter_ != NULL &&
      end_of_buffer_offset_ - buffer_.size() - bytes >= initial_offset_) {
    reporter_->Corruption(static_cast<size_t>(bytes), reason);
  }
}",63,,192,3,,void
35438,BLOCK,-1,,"{
    reporter_->Corruption(static_cast<size_t>(bytes), reason);
  }",74,,194,2,,void
35451,BLOCK,-1,,"{
  while (true) {
    if (buffer_.size() < kHeaderSize) {
      if (!eof_) {
        // Last read was a full read, so this is a trailer to skip
        buffer_.clear();
        Status status = file_->Read(kBlockSize, &buffer_, backing_store_);
        end_of_buffer_offset_ += buffer_.size();
        if (!status.ok()) {
          buffer_.clear();
          ReportDrop(kBlockSize, status);
          eof_ = true;
          return kEof;
        } else if (buffer_.size() < kBlockSize) {
          eof_ = true;
        }
        continue;
      } else {
        // Note that if buffer_ is non-empty, we have a truncated header at the
        // end of the file, which can be caused by the writer crashing in the
        // middle of writing the header. Instead of considering this an error,
        // just report EOF.
        buffer_.clear();
        return kEof;
      }
    }

    // Parse the header
    const char* header = buffer_.data();
    const uint32_t a = static_cast<uint32_t>(header[4...",56,,199,2,,void
35454,BLOCK,-1,,"{
    if (buffer_.size() < kHeaderSize) {
      if (!eof_) {
        // Last read was a full read, so this is a trailer to skip
        buffer_.clear();
        Status status = file_->Read(kBlockSize, &buffer_, backing_store_);
        end_of_buffer_offset_ += buffer_.size();
        if (!status.ok()) {
          buffer_.clear();
          ReportDrop(kBlockSize, status);
          eof_ = true;
          return kEof;
        } else if (buffer_.size() < kBlockSize) {
          eof_ = true;
        }
        continue;
      } else {
        // Note that if buffer_ is non-empty, we have a truncated header at the
        // end of the file, which can be caused by the writer crashing in the
        // middle of writing the header. Instead of considering this an error,
        // just report EOF.
        buffer_.clear();
        return kEof;
      }
    }

    // Parse the header
    const char* header = buffer_.data();
    const uint32_t a = static_cast<uint32_t>(header[4]) & 0xff;
    co...",16,,200,2,,void
35462,BLOCK,-1,,"{
      if (!eof_) {
        // Last read was a full read, so this is a trailer to skip
        buffer_.clear();
        Status status = file_->Read(kBlockSize, &buffer_, backing_store_);
        end_of_buffer_offset_ += buffer_.size();
        if (!status.ok()) {
          buffer_.clear();
          ReportDrop(kBlockSize, status);
          eof_ = true;
          return kEof;
        } else if (buffer_.size() < kBlockSize) {
          eof_ = true;
        }
        continue;
      } else {
        // Note that if buffer_ is non-empty, we have a truncated header at the
        // end of the file, which can be caused by the writer crashing in the
        // middle of writing the header. Instead of considering this an error,
        // just report EOF.
        buffer_.clear();
        return kEof;
      }
    }",39,,201,2,,void
35466,BLOCK,-1,,"{
        // Last read was a full read, so this is a trailer to skip
        buffer_.clear();
        Status status = file_->Read(kBlockSize, &buffer_, backing_store_);
        end_of_buffer_offset_ += buffer_.size();
        if (!status.ok()) {
          buffer_.clear();
          ReportDrop(kBlockSize, status);
          eof_ = true;
          return kEof;
        } else if (buffer_.size() < kBlockSize) {
          eof_ = true;
        }
        continue;
      }",18,,202,2,,void
35494,BLOCK,-1,,"{
          buffer_.clear();
          ReportDrop(kBlockSize, status);
          eof_ = true;
          return kEof;
        }",27,,207,2,,void
35508,BLOCK,-1,,<empty>,16,,212,1,,void
35516,BLOCK,-1,,"{
          eof_ = true;
        }",49,,212,2,,void
35522,BLOCK,-1,,"{
        // Note that if buffer_ is non-empty, we have a truncated header at the
        // end of the file, which can be caused by the writer crashing in the
        // middle of writing the header. Instead of considering this an error,
        // just report EOF.
        buffer_.clear();
        return kEof;
      }",14,,216,1,,void
35579,BLOCK,-1,,"{
      size_t drop_size = buffer_.size();
      buffer_.clear();
      if (!eof_) {
        ReportCorruption(drop_size, ""bad record length"");
        return kBadRecord;
      }
      // If the end of the file has been reached without reading |length| bytes
      // of payload, assume the writer died in the middle of writing the record.
      // Don't report a corruption.
      return kEof;
    }",48,,232,2,,void
35594,BLOCK,-1,,"{
        ReportCorruption(drop_size, ""bad record length"");
        return kBadRecord;
      }",18,,235,2,,void
35610,BLOCK,-1,,"{
      // Skip zero length record without reporting any drops since
      // such records are produced by the mmap based writing code in
      // env_posix.cc that preallocates file regions.
      buffer_.clear();
      return kBadRecord;
    }",43,,245,2,,void
35619,BLOCK,-1,,"{
      uint32_t expected_crc = crc32c::Unmask(DecodeFixed32(header));
      uint32_t actual_crc = crc32c::Value(header + 6, 1 + length);
      if (actual_crc != expected_crc) {
        // Drop the rest of the buffer since ""length"" itself may have
        // been corrupted and if we trust it, we could find some
        // fragment of a real log record that just happens to look
        // like a valid log record.
        size_t drop_size = buffer_.size();
        buffer_.clear();
        ReportCorruption(drop_size, ""checksum mismatch"");
        return kBadRecord;
      }
    }",20,,254,2,,void
35646,BLOCK,-1,,"{
        // Drop the rest of the buffer since ""length"" itself may have
        // been corrupted and if we trust it, we could find some
        // fragment of a real log record that just happens to look
        // like a valid log record.
        size_t drop_size = buffer_.size();
        buffer_.clear();
        ReportCorruption(drop_size, ""checksum mismatch"");
        return kBadRecord;
      }",39,,257,2,,void
35683,BLOCK,-1,,"{
      result->clear();
      return kBadRecord;
    }",26,,273,2,,void
35714,BLOCK,-1,,<empty>,1,,1,1,,ANY
35721,BLOCK,-1,,<empty>,,,,1,,<empty>
35727,BLOCK,-1,,<empty>,,,,3,,<empty>
35735,BLOCK,-1,,<empty>,,,,5,,<empty>
35739,BLOCK,-1,,<empty>,,,,1,,<empty>
35745,BLOCK,-1,,<empty>,,,,3,,<empty>
35749,BLOCK,-1,,<empty>,,,,1,,<empty>
35766,BLOCK,-1,,<empty>,,,,1,,<empty>
35780,BLOCK,-1,,<empty>,,,,1,,<empty>
35785,BLOCK,-1,,<empty>,,,,2,,<empty>
35791,BLOCK,-1,,<empty>,,,,3,,<empty>
35797,BLOCK,-1,,<empty>,,,,3,,<empty>
35802,BLOCK,-1,,<empty>,,,,2,,<empty>
35807,BLOCK,-1,,<empty>,,,,2,,<empty>
35828,BLOCK,-1,,<empty>,1,,1,1,,ANY
35834,BLOCK,-1,,"{
  std::string result;
  while (result.size() < n) {
    result.append(partial_string);
  }
  result.resize(n);
  return result;
}",75,,18,3,,void
35843,BLOCK,-1,,"{
    result.append(partial_string);
  }",29,,20,2,,void
35860,BLOCK,-1,,"{
  char buf[50];
  snprintf(buf, sizeof(buf), ""%d."", n);
  return std::string(buf);
}",40,,28,2,,void
35879,BLOCK,-1,,"{
  return BigString(NumberString(i), rnd->Skewed(17));
}",59,,35,3,,void
35895,BLOCK,-1,,{ return Status::OK(); },28,,45,1,,void
35904,BLOCK,-1,,{ return Status::OK(); },28,,46,1,,void
35913,BLOCK,-1,,{ return Status::OK(); },27,,47,1,,void
35923,BLOCK,-1,,"{
      contents_.append(slice.data(), slice.size());
      return Status::OK();
    }",47,,48,2,,void
35948,BLOCK,-1,,{ },68,,59,1,,void
35955,BLOCK,-1,,"{
      ASSERT_TRUE(!returned_partial_) << ""must not Read() after eof/error"";

      if (force_error_) {
        force_error_ = false;
        returned_partial_ = true;
        return Status::Corruption(""read error"");
      }

      if (contents_.size() < n) {
        n = contents_.size();
        returned_partial_ = true;
      }
      *result = Slice(contents_.data(), n);
      contents_.remove_prefix(n);
      return Status::OK();
    }",65,,61,4,,void
35960,BLOCK,1,,<empty>,,,,2,,void
35978,BLOCK,-1,,"{
        force_error_ = false;
        returned_partial_ = true;
        return Status::Corruption(""read error"");
      }",25,,64,2,,void
35998,BLOCK,-1,,"{
        n = contents_.size();
        returned_partial_ = true;
      }",33,,70,2,,void
36031,BLOCK,-1,,"{
      if (n > contents_.size()) {
        contents_.clear();
        return Status::NotFound(""in-memory file skipped past end"");
      }

      contents_.remove_prefix(n);

      return Status::OK();
    }",37,,79,2,,void
36039,BLOCK,-1,,"{
        contents_.clear();
        return Status::NotFound(""in-memory file skipped past end"");
      }",33,,80,2,,void
36066,BLOCK,-1,,{ },43,,96,1,,void
36072,BLOCK,-1,,"{
      dropped_bytes_ += bytes;
      message_.append(status.ToString());
    }",65,,97,3,,void
36096,BLOCK,-1,,"{
  }",45,,119,1,,void
36100,BLOCK,-1,,"{
    delete writer_;
    delete reader_;
  }",14,,122,1,,void
36108,BLOCK,-1,,"{
    delete writer_;
    writer_ = new Writer(&dest_, dest_.contents_.size());
  }",26,,127,1,,void
36127,BLOCK,-1,,"{
    ASSERT_TRUE(!reading_) << ""Write() after starting to read"";
    writer_->AddRecord(Slice(msg));
  }",38,,132,2,,void
36132,BLOCK,1,,<empty>,,,,2,,void
36157,BLOCK,-1,,"{
    return dest_.contents_.size();
  }",31,,137,1,,void
36168,BLOCK,-1,,"{
    if (!reading_) {
      reading_ = true;
      source_.contents_ = Slice(dest_.contents_);
    }
    std::string scratch;
    Slice record;
    if (reader_->ReadRecord(&record, &scratch)) {
      return record.ToString();
    } else {
      return ""EOF"";
    }
  }",22,,141,1,,void
36172,BLOCK,-1,,"{
      reading_ = true;
      source_.contents_ = Slice(dest_.contents_);
    }",20,,142,2,,void
36195,BLOCK,-1,,"{
      return record.ToString();
    }",49,,148,2,,void
36202,BLOCK,-1,,"{
      return ""EOF"";
    }",12,,150,1,,void
36210,BLOCK,-1,,"{
    dest_.contents_[offset] += delta;
  }",45,,155,3,,void
36223,BLOCK,-1,,"{
    dest_.contents_[offset] = new_byte;
  }",43,,159,3,,void
36235,BLOCK,-1,,"{
    dest_.contents_.resize(dest_.contents_.size() - bytes);
  }",30,,163,2,,void
36255,BLOCK,-1,,"{
    // Compute crc of type/len/data
    uint32_t crc = crc32c::Value(&dest_.contents_[header_offset+6], 1 + len);
    crc = crc32c::Mask(crc);
    EncodeFixed32(&dest_.contents_[header_offset], crc);
  }",48,,167,3,,void
36292,BLOCK,-1,,"{
    source_.force_error_ = true;
  }",21,,174,1,,void
36301,BLOCK,-1,,"{
    return report_.dropped_bytes_;
  }",31,,178,1,,void
36309,BLOCK,-1,,"{
    return report_.message_;
  }",37,,182,1,,void
36318,BLOCK,-1,,"{
    if (report_.message_.find(msg) == std::string::npos) {
      return report_.message_;
    } else {
      return ""OK"";
    }
  }",56,,187,2,,void
36333,BLOCK,-1,,"{
      return report_.message_;
    }",58,,188,2,,void
36339,BLOCK,-1,,"{
      return ""OK"";
    }",12,,190,1,,void
36345,BLOCK,-1,,"{
    for (int i = 0; i < num_initial_offset_records_; i++) {
      std::string record(initial_offset_record_sizes_[i],
                         static_cast<char>('a' + i));
      Write(record);
    }
  }",32,,195,1,,void
36347,BLOCK,-1,,<empty>,5,,196,1,,void
36357,BLOCK,4,,"{
      std::string record(initial_offset_record_sizes_[i],
                         static_cast<char>('a' + i));
      Write(record);
    }",59,,196,4,,void
36374,BLOCK,-1,,"{
    delete reader_;
    reader_ = new Reader(&source_, &report_, true/*checksum*/, initial_offset);
  }",48,,203,2,,void
36391,BLOCK,-1,,"{
    WriteInitialOffsetLog();
    reading_ = true;
    source_.contents_ = Slice(dest_.contents_);
    Reader* offset_reader = new Reader(&source_, &report_, true/*checksum*/,
                                       WrittenBytes() + offset_past_end);
    Slice record;
    std::string scratch;
    ASSERT_TRUE(!offset_reader->ReadRecord(&record, &scratch));
    delete offset_reader;
  }",69,,208,2,,void
36420,BLOCK,1,,<empty>,,,,4,,void
36449,BLOCK,-1,,"{
    WriteInitialOffsetLog();
    reading_ = true;
    source_.contents_ = Slice(dest_.contents_);
    Reader* offset_reader = new Reader(&source_, &report_, true/*checksum*/,
                                       initial_offset);

    // Read all records from expected_record_offset through the last one.
    ASSERT_LT(expected_record_offset, num_initial_offset_records_);
    for (; expected_record_offset < num_initial_offset_records_;
         ++expected_record_offset) {
      Slice record;
      std::string scratch;
      ASSERT_TRUE(offset_reader->ReadRecord(&record, &scratch));
      ASSERT_EQ(initial_offset_record_sizes_[expected_record_offset],
                record.size());
      ASSERT_EQ(initial_offset_last_record_offsets_[expected_record_offset],
                offset_reader->LastRecordOffset());
      ASSERT_EQ((char)('a' + expected_record_offset), record.data()[0]);
    }
    delete offset_reader;
  }",61,,221,3,,void
36476,BLOCK,1,,<empty>,,,,3,,void
36491,BLOCK,-1,,<empty>,5,,230,1,,void
36497,BLOCK,4,,"{
      Slice record;
      std::string scratch;
      ASSERT_TRUE(offset_reader->ReadRecord(&record, &scratch));
      ASSERT_EQ(initial_offset_record_sizes_[expected_record_offset],
                record.size());
      ASSERT_EQ(initial_offset_last_record_offsets_[expected_record_offset],
                offset_reader->LastRecordOffset());
      ASSERT_EQ((char)('a' + expected_record_offset), record.data()[0]);
    }",36,,231,4,,void
36501,BLOCK,1,,<empty>,,,,4,,void
36530,BLOCK,1,,<empty>,,,,4,,void
36557,BLOCK,1,,<empty>,,,,4,,void
36583,BLOCK,1,,<empty>,,,,3,,void
36611,BLOCK,-1,,<empty>,,,,1,,<empty>
36704,BLOCK,-1,,<empty>,,,,1,,<empty>
36708,BLOCK,-1,,"TEST(LogTest, Empty)",1,,270,1,,void
36732,BLOCK,-1,,"{
  ASSERT_EQ(""EOF"", Read());
}",22,,270,1,,void
36736,BLOCK,1,,<empty>,,,,3,,void
36754,BLOCK,-1,,<empty>,,,,1,,<empty>
36758,BLOCK,-1,,"TEST(LogTest, ReadWrite)",1,,274,1,,void
36782,BLOCK,-1,,"{
  Write(""foo"");
  Write(""bar"");
  Write("""");
  Write(""xxxx"");
  ASSERT_EQ(""foo"", Read());
  ASSERT_EQ(""bar"", Read());
  ASSERT_EQ("""", Read());
  ASSERT_EQ(""xxxx"", Read());
  ASSERT_EQ(""EOF"", Read());
  ASSERT_EQ(""EOF"", Read());  // Make sure reads at eof work
}",26,,274,1,,void
36794,BLOCK,1,,<empty>,,,,3,,void
36811,BLOCK,1,,<empty>,,,,3,,void
36828,BLOCK,1,,<empty>,,,,3,,void
36845,BLOCK,1,,<empty>,,,,3,,void
36862,BLOCK,1,,<empty>,,,,3,,void
36879,BLOCK,1,,<empty>,,,,3,,void
36897,BLOCK,-1,,<empty>,,,,1,,<empty>
36901,BLOCK,-1,,"TEST(LogTest, ManyBlocks)",1,,287,1,,void
36925,BLOCK,-1,,"{
  for (int i = 0; i < 100000; i++) {
    Write(NumberString(i));
  }
  for (int i = 0; i < 100000; i++) {
    ASSERT_EQ(NumberString(i), Read());
  }
  ASSERT_EQ(""EOF"", Read());
}",27,,287,1,,void
36927,BLOCK,-1,,<empty>,3,,288,1,,void
36937,BLOCK,4,,"{
    Write(NumberString(i));
  }",36,,288,4,,void
36942,BLOCK,-1,,<empty>,3,,291,1,,void
36952,BLOCK,4,,"{
    ASSERT_EQ(NumberString(i), Read());
  }",36,,291,4,,void
36957,BLOCK,1,,<empty>,,,,3,,void
36975,BLOCK,1,,<empty>,,,,3,,void
36993,BLOCK,-1,,<empty>,,,,1,,<empty>
36997,BLOCK,-1,,"TEST(LogTest, Fragmentation)",1,,297,1,,void
37021,BLOCK,-1,,"{
  Write(""small"");
  Write(BigString(""medium"", 50000));
  Write(BigString(""large"", 100000));
  ASSERT_EQ(""small"", Read());
  ASSERT_EQ(BigString(""medium"", 50000), Read());
  ASSERT_EQ(BigString(""large"", 100000), Read());
  ASSERT_EQ(""EOF"", Read());
}",30,,297,1,,void
37035,BLOCK,1,,<empty>,,,,3,,void
37051,BLOCK,1,,<empty>,,,,2,,void
37069,BLOCK,1,,<empty>,,,,2,,void
37088,BLOCK,1,,<empty>,,,,3,,void
37106,BLOCK,-1,,<empty>,,,,1,,<empty>
37110,BLOCK,-1,,"TEST(LogTest, MarginalTrailer)",1,,307,1,,void
37134,BLOCK,-1,,"{
  // Make a trailer that is exactly the same length as an empty record.
  const int n = kBlockSize - 2*kHeaderSize;
  Write(BigString(""foo"", n));
  ASSERT_EQ(kBlockSize - kHeaderSize, WrittenBytes());
  Write("""");
  Write(""bar"");
  ASSERT_EQ(BigString(""foo"", n), Read());
  ASSERT_EQ("""", Read());
  ASSERT_EQ(""bar"", Read());
  ASSERT_EQ(""EOF"", Read());
}",32,,307,1,,void
37149,BLOCK,1,,<empty>,,,,2,,void
37171,BLOCK,1,,<empty>,,,,3,,void
37190,BLOCK,1,,<empty>,,,,3,,void
37207,BLOCK,1,,<empty>,,,,3,,void
37224,BLOCK,1,,<empty>,,,,3,,void
37242,BLOCK,-1,,<empty>,,,,1,,<empty>
37246,BLOCK,-1,,"TEST(LogTest, MarginalTrailer2)",1,,320,1,,void
37270,BLOCK,-1,,"{
  // Make a trailer that is exactly the same length as an empty record.
  const int n = kBlockSize - 2*kHeaderSize;
  Write(BigString(""foo"", n));
  ASSERT_EQ(kBlockSize - kHeaderSize, WrittenBytes());
  Write(""bar"");
  ASSERT_EQ(BigString(""foo"", n), Read());
  ASSERT_EQ(""bar"", Read());
  ASSERT_EQ(""EOF"", Read());
  ASSERT_EQ(0, DroppedBytes());
  ASSERT_EQ("""", ReportMessage());
}",33,,320,1,,void
37285,BLOCK,1,,<empty>,,,,2,,void
37305,BLOCK,1,,<empty>,,,,3,,void
37324,BLOCK,1,,<empty>,,,,3,,void
37341,BLOCK,1,,<empty>,,,,3,,void
37358,BLOCK,1,,<empty>,,,,3,,void
37375,BLOCK,1,,<empty>,,,,3,,void
37393,BLOCK,-1,,<empty>,,,,1,,<empty>
37397,BLOCK,-1,,"TEST(LogTest, ShortTrailer)",1,,333,1,,void
37421,BLOCK,-1,,"{
  const int n = kBlockSize - 2*kHeaderSize + 4;
  Write(BigString(""foo"", n));
  ASSERT_EQ(kBlockSize - kHeaderSize + 4, WrittenBytes());
  Write("""");
  Write(""bar"");
  ASSERT_EQ(BigString(""foo"", n), Read());
  ASSERT_EQ("""", Read());
  ASSERT_EQ(""bar"", Read());
  ASSERT_EQ(""EOF"", Read());
}",29,,333,1,,void
37438,BLOCK,1,,<empty>,,,,2,,void
37462,BLOCK,1,,<empty>,,,,3,,void
37481,BLOCK,1,,<empty>,,,,3,,void
37498,BLOCK,1,,<empty>,,,,3,,void
37515,BLOCK,1,,<empty>,,,,3,,void
37533,BLOCK,-1,,<empty>,,,,1,,<empty>
37537,BLOCK,-1,,"TEST(LogTest, AlignedEof)",1,,345,1,,void
37561,BLOCK,-1,,"{
  const int n = kBlockSize - 2*kHeaderSize + 4;
  Write(BigString(""foo"", n));
  ASSERT_EQ(kBlockSize - kHeaderSize + 4, WrittenBytes());
  ASSERT_EQ(BigString(""foo"", n), Read());
  ASSERT_EQ(""EOF"", Read());
}",27,,345,1,,void
37578,BLOCK,1,,<empty>,,,,2,,void
37598,BLOCK,1,,<empty>,,,,3,,void
37617,BLOCK,1,,<empty>,,,,3,,void
37635,BLOCK,-1,,<empty>,,,,1,,<empty>
37639,BLOCK,-1,,"TEST(LogTest, OpenForAppend)",1,,353,1,,void
37663,BLOCK,-1,,"{
  Write(""hello"");
  ReopenForAppend();
  Write(""world"");
  ASSERT_EQ(""hello"", Read());
  ASSERT_EQ(""world"", Read());
  ASSERT_EQ(""EOF"", Read());
}",30,,353,1,,void
37672,BLOCK,1,,<empty>,,,,3,,void
37689,BLOCK,1,,<empty>,,,,3,,void
37706,BLOCK,1,,<empty>,,,,3,,void
37724,BLOCK,-1,,<empty>,,,,1,,<empty>
37728,BLOCK,-1,,"TEST(LogTest, RandomRead)",1,,362,1,,void
37752,BLOCK,-1,,"{
  const int N = 500;
  Random write_rnd(301);
  for (int i = 0; i < N; i++) {
    Write(RandomSkewedString(i, &write_rnd));
  }
  Random read_rnd(301);
  for (int i = 0; i < N; i++) {
    ASSERT_EQ(RandomSkewedString(i, &read_rnd), Read());
  }
  ASSERT_EQ(""EOF"", Read());
}",27,,362,1,,void
37761,BLOCK,-1,,<empty>,3,,365,1,,void
37771,BLOCK,4,,"{
    Write(RandomSkewedString(i, &write_rnd));
  }",31,,365,4,,void
37781,BLOCK,-1,,<empty>,3,,369,1,,void
37791,BLOCK,4,,"{
    ASSERT_EQ(RandomSkewedString(i, &read_rnd), Read());
  }",31,,369,4,,void
37794,BLOCK,1,,<empty>,,,,3,,void
37814,BLOCK,1,,<empty>,,,,3,,void
37832,BLOCK,-1,,<empty>,,,,1,,<empty>
37836,BLOCK,-1,,"TEST(LogTest, ReadError)",1,,377,1,,void
37860,BLOCK,-1,,"{
  Write(""foo"");
  ForceError();
  ASSERT_EQ(""EOF"", Read());
  ASSERT_EQ(kBlockSize, DroppedBytes());
  ASSERT_EQ(""OK"", MatchError(""read error""));
}",26,,377,1,,void
37867,BLOCK,1,,<empty>,,,,3,,void
37884,BLOCK,1,,<empty>,,,,3,,void
37900,BLOCK,1,,<empty>,,,,2,,void
37919,BLOCK,-1,,<empty>,,,,1,,<empty>
37923,BLOCK,-1,,"TEST(LogTest, BadRecordType)",1,,385,1,,void
37947,BLOCK,-1,,"{
  Write(""foo"");
  // Type is stored in header[6]
  IncrementByte(6, 100);
  FixChecksum(0, 3);
  ASSERT_EQ(""EOF"", Read());
  ASSERT_EQ(3, DroppedBytes());
  ASSERT_EQ(""OK"", MatchError(""unknown record type""));
}",30,,385,1,,void
37959,BLOCK,1,,<empty>,,,,3,,void
37976,BLOCK,1,,<empty>,,,,3,,void
37992,BLOCK,1,,<empty>,,,,2,,void
38011,BLOCK,-1,,<empty>,,,,1,,<empty>
38015,BLOCK,-1,,"TEST(LogTest, TruncatedTrailingRecordIsIgnored)",1,,395,1,,void
38039,BLOCK,-1,,"{
  Write(""foo"");
  ShrinkSize(4);   // Drop all payload as well as a header byte
  ASSERT_EQ(""EOF"", Read());
  // Truncated last record is ignored, not treated as an error.
  ASSERT_EQ(0, DroppedBytes());
  ASSERT_EQ("""", ReportMessage());
}",49,,395,1,,void
38047,BLOCK,1,,<empty>,,,,3,,void
38064,BLOCK,1,,<empty>,,,,3,,void
38081,BLOCK,1,,<empty>,,,,3,,void
38099,BLOCK,-1,,<empty>,,,,1,,<empty>
38103,BLOCK,-1,,"TEST(LogTest, BadLength)",1,,404,1,,void
38127,BLOCK,-1,,"{
  const int kPayloadSize = kBlockSize - kHeaderSize;
  Write(BigString(""bar"", kPayloadSize));
  Write(""foo"");
  // Least significant size byte is stored in header[4].
  IncrementByte(4, 1);
  ASSERT_EQ(""foo"", Read());
  ASSERT_EQ(kBlockSize, DroppedBytes());
  ASSERT_EQ(""OK"", MatchError(""bad record length""));
}",26,,404,1,,void
38146,BLOCK,1,,<empty>,,,,3,,void
38163,BLOCK,1,,<empty>,,,,3,,void
38179,BLOCK,1,,<empty>,,,,2,,void
38198,BLOCK,-1,,<empty>,,,,1,,<empty>
38202,BLOCK,-1,,"TEST(LogTest, BadLengthAtEndIsIgnored)",1,,415,1,,void
38226,BLOCK,-1,,"{
  Write(""foo"");
  ShrinkSize(1);
  ASSERT_EQ(""EOF"", Read());
  ASSERT_EQ(0, DroppedBytes());
  ASSERT_EQ("""", ReportMessage());
}",40,,415,1,,void
38234,BLOCK,1,,<empty>,,,,3,,void
38251,BLOCK,1,,<empty>,,,,3,,void
38268,BLOCK,1,,<empty>,,,,3,,void
38286,BLOCK,-1,,<empty>,,,,1,,<empty>
38290,BLOCK,-1,,"TEST(LogTest, ChecksumMismatch)",1,,423,1,,void
38314,BLOCK,-1,,"{
  Write(""foo"");
  IncrementByte(0, 10);
  ASSERT_EQ(""EOF"", Read());
  ASSERT_EQ(10, DroppedBytes());
  ASSERT_EQ(""OK"", MatchError(""checksum mismatch""));
}",33,,423,1,,void
38323,BLOCK,1,,<empty>,,,,3,,void
38340,BLOCK,1,,<empty>,,,,3,,void
38356,BLOCK,1,,<empty>,,,,2,,void
38375,BLOCK,-1,,<empty>,,,,1,,<empty>
38379,BLOCK,-1,,"TEST(LogTest, UnexpectedMiddleType)",1,,431,1,,void
38403,BLOCK,-1,,"{
  Write(""foo"");
  SetByte(6, kMiddleType);
  FixChecksum(0, 3);
  ASSERT_EQ(""EOF"", Read());
  ASSERT_EQ(3, DroppedBytes());
  ASSERT_EQ(""OK"", MatchError(""missing start""));
}",37,,431,1,,void
38415,BLOCK,1,,<empty>,,,,3,,void
38432,BLOCK,1,,<empty>,,,,3,,void
38448,BLOCK,1,,<empty>,,,,2,,void
38467,BLOCK,-1,,<empty>,,,,1,,<empty>
38471,BLOCK,-1,,"TEST(LogTest, UnexpectedLastType)",1,,440,1,,void
38495,BLOCK,-1,,"{
  Write(""foo"");
  SetByte(6, kLastType);
  FixChecksum(0, 3);
  ASSERT_EQ(""EOF"", Read());
  ASSERT_EQ(3, DroppedBytes());
  ASSERT_EQ(""OK"", MatchError(""missing start""));
}",35,,440,1,,void
38507,BLOCK,1,,<empty>,,,,3,,void
38524,BLOCK,1,,<empty>,,,,3,,void
38540,BLOCK,1,,<empty>,,,,2,,void
38559,BLOCK,-1,,<empty>,,,,1,,<empty>
38563,BLOCK,-1,,"TEST(LogTest, UnexpectedFullType)",1,,449,1,,void
38587,BLOCK,-1,,"{
  Write(""foo"");
  Write(""bar"");
  SetByte(6, kFirstType);
  FixChecksum(0, 3);
  ASSERT_EQ(""bar"", Read());
  ASSERT_EQ(""EOF"", Read());
  ASSERT_EQ(3, DroppedBytes());
  ASSERT_EQ(""OK"", MatchError(""partial record without end""));
}",35,,449,1,,void
38601,BLOCK,1,,<empty>,,,,3,,void
38618,BLOCK,1,,<empty>,,,,3,,void
38635,BLOCK,1,,<empty>,,,,3,,void
38651,BLOCK,1,,<empty>,,,,2,,void
38670,BLOCK,-1,,<empty>,,,,1,,<empty>
38674,BLOCK,-1,,"TEST(LogTest, UnexpectedFirstType)",1,,460,1,,void
38698,BLOCK,-1,,"{
  Write(""foo"");
  Write(BigString(""bar"", 100000));
  SetByte(6, kFirstType);
  FixChecksum(0, 3);
  ASSERT_EQ(BigString(""bar"", 100000), Read());
  ASSERT_EQ(""EOF"", Read());
  ASSERT_EQ(3, DroppedBytes());
  ASSERT_EQ(""OK"", MatchError(""partial record without end""));
}",36,,460,1,,void
38713,BLOCK,1,,<empty>,,,,2,,void
38732,BLOCK,1,,<empty>,,,,3,,void
38749,BLOCK,1,,<empty>,,,,3,,void
38765,BLOCK,1,,<empty>,,,,2,,void
38784,BLOCK,-1,,<empty>,,,,1,,<empty>
38788,BLOCK,-1,,"TEST(LogTest, MissingLastIsIgnored)",1,,471,1,,void
38812,BLOCK,-1,,"{
  Write(BigString(""bar"", kBlockSize));
  // Remove the LAST block, including header.
  ShrinkSize(14);
  ASSERT_EQ(""EOF"", Read());
  ASSERT_EQ("""", ReportMessage());
  ASSERT_EQ(0, DroppedBytes());
}",37,,471,1,,void
38822,BLOCK,1,,<empty>,,,,3,,void
38839,BLOCK,1,,<empty>,,,,3,,void
38856,BLOCK,1,,<empty>,,,,3,,void
38874,BLOCK,-1,,<empty>,,,,1,,<empty>
38878,BLOCK,-1,,"TEST(LogTest, PartialLastIsIgnored)",1,,480,1,,void
38902,BLOCK,-1,,"{
  Write(BigString(""bar"", kBlockSize));
  // Cause a bad record length in the LAST block.
  ShrinkSize(1);
  ASSERT_EQ(""EOF"", Read());
  ASSERT_EQ("""", ReportMessage());
  ASSERT_EQ(0, DroppedBytes());
}",37,,480,1,,void
38912,BLOCK,1,,<empty>,,,,3,,void
38929,BLOCK,1,,<empty>,,,,3,,void
38946,BLOCK,1,,<empty>,,,,3,,void
38964,BLOCK,-1,,<empty>,,,,1,,<empty>
38968,BLOCK,-1,,"TEST(LogTest, SkipIntoMultiRecord)",1,,489,1,,void
38992,BLOCK,-1,,"{
  // Consider a fragmented record:
  //    first(R1), middle(R1), last(R1), first(R2)
  // If initial_offset points to a record after first(R1) but before first(R2)
  // incomplete fragment errors are not actual errors, and must be suppressed
  // until a new first or full record is encountered.
  Write(BigString(""foo"", 3*kBlockSize));
  Write(""correct"");
  StartReadingAt(kBlockSize);

  ASSERT_EQ(""correct"", Read());
  ASSERT_EQ("""", ReportMessage());
  ASSERT_EQ(0, DroppedBytes());
  ASSERT_EQ(""EOF"", Read());
}",36,,489,1,,void
39006,BLOCK,1,,<empty>,,,,3,,void
39023,BLOCK,1,,<empty>,,,,3,,void
39040,BLOCK,1,,<empty>,,,,3,,void
39057,BLOCK,1,,<empty>,,,,3,,void
39075,BLOCK,-1,,<empty>,,,,1,,<empty>
39079,BLOCK,-1,,"TEST(LogTest, ErrorJoinsRecords)",1,,505,1,,void
39103,BLOCK,-1,,"{
  // Consider two fragmented records:
  //    first(R1) last(R1) first(R2) last(R2)
  // where the middle two fragments disappear.  We do not want
  // first(R1),last(R2) to get joined and returned as a valid record.

  // Write records that span two blocks
  Write(BigString(""foo"", kBlockSize));
  Write(BigString(""bar"", kBlockSize));
  Write(""correct"");

  // Wipe the middle block
  for (int offset = kBlockSize; offset < 2*kBlockSize; offset++) {
    SetByte(offset, 'x');
  }

  ASSERT_EQ(""correct"", Read());
  ASSERT_EQ(""EOF"", Read());
  const size_t dropped = DroppedBytes();
  ASSERT_LE(dropped, 2*kBlockSize + 100);
  ASSERT_GE(dropped, 2*kBlockSize);
}",34,,505,1,,void
39115,BLOCK,-1,,<empty>,3,,517,1,,void
39127,BLOCK,4,,"{
    SetByte(offset, 'x');
  }",66,,517,4,,void
39134,BLOCK,1,,<empty>,,,,3,,void
39151,BLOCK,1,,<empty>,,,,3,,void
39171,BLOCK,1,,<empty>,,,,3,,void
39191,BLOCK,1,,<empty>,,,,3,,void
39211,BLOCK,-1,,<empty>,,,,1,,<empty>
39215,BLOCK,-1,,"TEST(LogTest, ReadStart)",1,,528,1,,void
39239,BLOCK,-1,,"{
  CheckInitialOffsetRecord(0, 0);
}",26,,528,1,,void
39247,BLOCK,-1,,<empty>,,,,1,,<empty>
39251,BLOCK,-1,,"TEST(LogTest, ReadSecondOneOff)",1,,532,1,,void
39275,BLOCK,-1,,"{
  CheckInitialOffsetRecord(1, 1);
}",33,,532,1,,void
39283,BLOCK,-1,,<empty>,,,,1,,<empty>
39287,BLOCK,-1,,"TEST(LogTest, ReadSecondTenThousand)",1,,536,1,,void
39311,BLOCK,-1,,"{
  CheckInitialOffsetRecord(10000, 1);
}",38,,536,1,,void
39319,BLOCK,-1,,<empty>,,,,1,,<empty>
39323,BLOCK,-1,,"TEST(LogTest, ReadSecondStart)",1,,540,1,,void
39347,BLOCK,-1,,"{
  CheckInitialOffsetRecord(10007, 1);
}",32,,540,1,,void
39355,BLOCK,-1,,<empty>,,,,1,,<empty>
39359,BLOCK,-1,,"TEST(LogTest, ReadThirdOneOff)",1,,544,1,,void
39383,BLOCK,-1,,"{
  CheckInitialOffsetRecord(10008, 2);
}",32,,544,1,,void
39391,BLOCK,-1,,<empty>,,,,1,,<empty>
39395,BLOCK,-1,,"TEST(LogTest, ReadThirdStart)",1,,548,1,,void
39419,BLOCK,-1,,"{
  CheckInitialOffsetRecord(20014, 2);
}",31,,548,1,,void
39427,BLOCK,-1,,<empty>,,,,1,,<empty>
39431,BLOCK,-1,,"TEST(LogTest, ReadFourthOneOff)",1,,552,1,,void
39455,BLOCK,-1,,"{
  CheckInitialOffsetRecord(20015, 3);
}",33,,552,1,,void
39463,BLOCK,-1,,<empty>,,,,1,,<empty>
39467,BLOCK,-1,,"TEST(LogTest, ReadFourthFirstBlockTrailer)",1,,556,1,,void
39491,BLOCK,-1,,"{
  CheckInitialOffsetRecord(log::kBlockSize - 4, 3);
}",44,,556,1,,void
39503,BLOCK,-1,,<empty>,,,,1,,<empty>
39507,BLOCK,-1,,"TEST(LogTest, ReadFourthMiddleBlock)",1,,560,1,,void
39531,BLOCK,-1,,"{
  CheckInitialOffsetRecord(log::kBlockSize + 1, 3);
}",38,,560,1,,void
39543,BLOCK,-1,,<empty>,,,,1,,<empty>
39547,BLOCK,-1,,"TEST(LogTest, ReadFourthLastBlock)",1,,564,1,,void
39571,BLOCK,-1,,"{
  CheckInitialOffsetRecord(2 * log::kBlockSize + 1, 3);
}",36,,564,1,,void
39585,BLOCK,-1,,<empty>,,,,1,,<empty>
39589,BLOCK,-1,,"TEST(LogTest, ReadFourthStart)",1,,568,1,,void
39613,BLOCK,-1,,"{
  CheckInitialOffsetRecord(
      2 * (kHeaderSize + 1000) + (2 * log::kBlockSize - 1000) + 3 * kHeaderSize,
      3);
}",32,,568,1,,void
39637,BLOCK,-1,,<empty>,,,,1,,<empty>
39641,BLOCK,-1,,"TEST(LogTest, ReadInitialOffsetIntoBlockPadding)",1,,574,1,,void
39665,BLOCK,-1,,"{
  CheckInitialOffsetRecord(3 * log::kBlockSize - 3, 5);
}",50,,574,1,,void
39679,BLOCK,-1,,<empty>,,,,1,,<empty>
39683,BLOCK,-1,,"TEST(LogTest, ReadEnd)",1,,578,1,,void
39707,BLOCK,-1,,"{
  CheckOffsetPastEndReturnsNoRecords(0);
}",24,,578,1,,void
39714,BLOCK,-1,,<empty>,,,,1,,<empty>
39718,BLOCK,-1,,"TEST(LogTest, ReadPastEnd)",1,,582,1,,void
39742,BLOCK,-1,,"{
  CheckOffsetPastEndReturnsNoRecords(5);
}",28,,582,1,,void
39750,BLOCK,-1,,"{
  return leveldb::test::RunAllTests();
}",33,,589,3,,void
39774,BLOCK,-1,,<empty>,1,,1,1,,ANY
39779,BLOCK,-1,,"{
  for (int i = 0; i <= kMaxRecordType; i++) {
    char t = static_cast<char>(i);
    type_crc[i] = crc32c::Value(&t, 1);
  }
}",45,,15,2,,void
39781,BLOCK,-1,,<empty>,3,,16,1,,void
39791,BLOCK,4,,"{
    char t = static_cast<char>(i);
    type_crc[i] = crc32c::Value(&t, 1);
  }",45,,16,4,,void
39813,BLOCK,-1,,"{
  InitTypeCrc(type_crc_);
}",24,,24,2,,void
39821,BLOCK,-1,,"{
  InitTypeCrc(type_crc_);
}",60,,29,3,,void
39827,BLOCK,-1,,"{
}",19,,33,1,,void
39832,BLOCK,-1,,"{
  const char* ptr = slice.data();
  size_t left = slice.size();

  // Fragment the record if necessary and emit it.  Note that if slice
  // is empty, we still want to iterate once to emit a single
  // zero-length record
  Status s;
  bool begin = true;
  do {
    const int leftover = kBlockSize - block_offset_;
    assert(leftover >= 0);
    if (leftover < kHeaderSize) {
      // Switch to a new block
      if (leftover > 0) {
        // Fill the trailer (literal below relies on kHeaderSize being 7)
        assert(kHeaderSize == 7);
        dest_->Append(Slice(""\x00\x00\x00\x00\x00\x00"", leftover));
      }
      block_offset_ = 0;
    }

    // Invariant: we never leave < kHeaderSize bytes in a block.
    assert(kBlockSize - block_offset_ - kHeaderSize >= 0);

    const size_t avail = kBlockSize - block_offset_ - kHeaderSize;
    const size_t fragment_length = (left < avail) ? left : avail;

    RecordType type;
    const bool end = (left == fragment_length);
    if (begin && e...",46,,36,2,,void
39853,BLOCK,-1,,"{
    const int leftover = kBlockSize - block_offset_;
    assert(leftover >= 0);
    if (leftover < kHeaderSize) {
      // Switch to a new block
      if (leftover > 0) {
        // Fill the trailer (literal below relies on kHeaderSize being 7)
        assert(kHeaderSize == 7);
        dest_->Append(Slice(""\x00\x00\x00\x00\x00\x00"", leftover));
      }
      block_offset_ = 0;
    }

    // Invariant: we never leave < kHeaderSize bytes in a block.
    assert(kBlockSize - block_offset_ - kHeaderSize >= 0);

    const size_t avail = kBlockSize - block_offset_ - kHeaderSize;
    const size_t fragment_length = (left < avail) ? left : avail;

    RecordType type;
    const bool end = (left == fragment_length);
    if (begin && end) {
      type = kFullType;
    } else if (begin) {
      type = kFirstType;
    } else if (end) {
      type = kLastType;
    } else {
      type = kMiddleType;
    }

    s = EmitPhysicalRecord(type, ptr, fragment_length);
    ptr += fragment_length;
    lef...",6,,45,1,,void
39868,BLOCK,-1,,"{
      // Switch to a new block
      if (leftover > 0) {
        // Fill the trailer (literal below relies on kHeaderSize being 7)
        assert(kHeaderSize == 7);
        dest_->Append(Slice(""\x00\x00\x00\x00\x00\x00"", leftover));
      }
      block_offset_ = 0;
    }",33,,48,2,,void
39873,BLOCK,-1,,"{
        // Fill the trailer (literal below relies on kHeaderSize being 7)
        assert(kHeaderSize == 7);
        dest_->Append(Slice(""\x00\x00\x00\x00\x00\x00"", leftover));
      }",25,,50,2,,void
39924,BLOCK,-1,,"{
      type = kFullType;
    }",23,,66,2,,void
39929,BLOCK,-1,,<empty>,12,,68,1,,void
39932,BLOCK,-1,,"{
      type = kFirstType;
    }",23,,68,2,,void
39937,BLOCK,-1,,<empty>,12,,70,1,,void
39940,BLOCK,-1,,"{
      type = kLastType;
    }",21,,70,2,,void
39945,BLOCK,-1,,"{
      type = kMiddleType;
    }",12,,72,1,,void
39980,BLOCK,-1,,"{
  assert(n <= 0xffff);  // Must fit in two bytes
  assert(block_offset_ + kHeaderSize + n <= kBlockSize);

  // Format the header
  char buf[kHeaderSize];
  buf[4] = static_cast<char>(n & 0xff);
  buf[5] = static_cast<char>(n >> 8);
  buf[6] = static_cast<char>(t);

  // Compute the crc of the record type and the payload.
  uint32_t crc = crc32c::Extend(type_crc_[t], ptr, n);
  crc = crc32c::Mask(crc);                 // Adjust for storage
  EncodeFixed32(buf, crc);

  // Write the header and the payload
  Status s = dest_->Append(Slice(buf, kHeaderSize));
  if (s.ok()) {
    s = dest_->Append(Slice(ptr, n));
    if (s.ok()) {
      s = dest_->Flush();
    }
  }
  block_offset_ += kHeaderSize + n;
  return s;
}",76,,84,4,,void
40056,BLOCK,-1,,"{
    s = dest_->Append(Slice(ptr, n));
    if (s.ok()) {
      s = dest_->Flush();
    }
  }",15,,101,2,,void
40071,BLOCK,-1,,"{
      s = dest_->Flush();
    }",17,,103,2,,void
40099,BLOCK,-1,,<empty>,1,,1,1,,ANY
40106,BLOCK,-1,,<empty>,,,,2,,<empty>
40112,BLOCK,-1,,<empty>,,,,3,,<empty>
40116,BLOCK,-1,,<empty>,,,,1,,<empty>
40121,BLOCK,-1,,<empty>,,,,2,,<empty>
40131,BLOCK,-1,,<empty>,,,,4,,<empty>
40136,BLOCK,-1,,<empty>,,,,2,,<empty>
40141,BLOCK,-1,,<empty>,,,,2,,<empty>
40145,BLOCK,-1,,<empty>,,,,1,,<empty>
40168,BLOCK,-1,,<empty>,1,,1,1,,ANY
40172,BLOCK,-1,,"{
  uint32_t len;
  const char* p = data;
  p = GetVarint32Ptr(p, p + 5, &len);  // +5: we assume ""p"" is not corrupted
  return Slice(p, len);
}",55,,14,2,,void
40195,BLOCK,-1,,"{
}",36,,24,2,,void
40199,BLOCK,-1,,"{
  assert(refs_ == 0);
}",23,,27,1,,void
40207,BLOCK,-1,,{ return arena_.MemoryUsage(); },43,,31,1,,void
40218,BLOCK,-1,,"{
  // Internal keys are encoded as length-prefixed strings.
  Slice a = GetLengthPrefixedSlice(aptr);
  Slice b = GetLengthPrefixedSlice(bptr);
  return comparator.Compare(a, b);
}",11,,34,3,,void
40241,BLOCK,-1,,"{
  scratch->clear();
  PutVarint32(scratch, target.size());
  scratch->append(target.data(), target.size());
  return scratch->data();
}",73,,44,3,,void
40274,BLOCK,-1,,{ },68,,53,2,,void
40278,BLOCK,-1,,{ return iter_.Valid(); },30,,55,1,,void
40288,BLOCK,-1,,"{ iter_.Seek(EncodeKey(&tmp_, k)); }",37,,56,2,,void
40300,BLOCK,-1,,{ iter_.SeekToFirst(); },30,,57,1,,void
40308,BLOCK,-1,,{ iter_.SeekToLast(); },29,,58,1,,void
40316,BLOCK,-1,,{ iter_.Next(); },23,,59,1,,void
40324,BLOCK,-1,,{ iter_.Prev(); },23,,60,1,,void
40332,BLOCK,-1,,{ return GetLengthPrefixedSlice(iter_.key()); },29,,61,1,,void
40342,BLOCK,-1,,"{
    Slice key_slice = GetLengthPrefixedSlice(iter_.key());
    return GetLengthPrefixedSlice(key_slice.data() + key_slice.size());
  }",31,,62,1,,void
40365,BLOCK,-1,,{ return Status::OK(); },33,,67,1,,void
40377,BLOCK,-1,,<empty>,,,,2,,<empty>
40382,BLOCK,-1,,<empty>,,,,2,,<empty>
40386,BLOCK,-1,,"{
  return new MemTableIterator(&table_);
}",35,,78,1,,void
40399,BLOCK,-1,,"{
  // Format of an entry is concatenation of:
  //  key_size     : varint32 of internal_key.size()
  //  key bytes    : char[internal_key.size()]
  //  value_size   : varint32 of value.size()
  //  value bytes  : char[value.size()]
  size_t key_size = key.size();
  size_t val_size = value.size();
  size_t internal_key_size = key_size + 8;
  const size_t encoded_len =
      VarintLength(internal_key_size) + internal_key_size +
      VarintLength(val_size) + val_size;
  char* buf = arena_.Allocate(encoded_len);
  char* p = EncodeVarint32(buf, internal_key_size);
  memcpy(p, key.data(), key_size);
  p += key_size;
  EncodeFixed64(p, (s << 8) | type);
  p += 8;
  p = EncodeVarint32(p, val_size);
  memcpy(p, value.data(), val_size);
  assert((p + val_size) - buf == encoded_len);
  table_.Insert(buf);
}",40,,84,5,,void
40497,BLOCK,-1,,"{
  Slice memkey = key.memtable_key();
  Table::Iterator iter(&table_);
  iter.Seek(memkey.data());
  if (iter.Valid()) {
    // entry format is:
    //    klength  varint32
    //    userkey  char[klength]
    //    tag      uint64
    //    vlength  varint32
    //    value    char[vlength]
    // Check that it belongs to same user key.  We do not check the
    // sequence number since the Seek() call above should have skipped
    // all entries with overly large sequence numbers.
    const char* entry = iter.key();
    uint32_t key_length;
    const char* key_ptr = GetVarint32Ptr(entry, entry+5, &key_length);
    if (comparator_.comparator.user_comparator()->Compare(
            Slice(key_ptr, key_length - 8),
            key.user_key()) == 0) {
      // Correct user key
      const uint64_t tag = DecodeFixed64(key_ptr + key_length - 8);
      switch (static_cast<ValueType>(tag & 0xff)) {
        case kTypeValue: {
          Slice v = GetLengthPrefixedSlice(key_ptr + key_length);...",73,,108,4,,void
40522,BLOCK,-1,,"{
    // entry format is:
    //    klength  varint32
    //    userkey  char[klength]
    //    tag      uint64
    //    vlength  varint32
    //    value    char[vlength]
    // Check that it belongs to same user key.  We do not check the
    // sequence number since the Seek() call above should have skipped
    // all entries with overly large sequence numbers.
    const char* entry = iter.key();
    uint32_t key_length;
    const char* key_ptr = GetVarint32Ptr(entry, entry+5, &key_length);
    if (comparator_.comparator.user_comparator()->Compare(
            Slice(key_ptr, key_length - 8),
            key.user_key()) == 0) {
      // Correct user key
      const uint64_t tag = DecodeFixed64(key_ptr + key_length - 8);
      switch (static_cast<ValueType>(tag & 0xff)) {
        case kTypeValue: {
          Slice v = GetLengthPrefixedSlice(key_ptr + key_length);
          value->assign(v.data(), v.size());
          return true;
        }
        case kTypeDeletion:
          *s ...",21,,112,2,,void
40562,BLOCK,-1,,"{
      // Correct user key
      const uint64_t tag = DecodeFixed64(key_ptr + key_length - 8);
      switch (static_cast<ValueType>(tag & 0xff)) {
        case kTypeValue: {
          Slice v = GetLengthPrefixedSlice(key_ptr + key_length);
          value->assign(v.data(), v.size());
          return true;
        }
        case kTypeDeletion:
          *s = Status::NotFound(Slice());
          return true;
      }
    }",35,,127,2,,void
40578,BLOCK,-1,,"{
        case kTypeValue: {
          Slice v = GetLengthPrefixedSlice(key_ptr + key_length);
          value->assign(v.data(), v.size());
          return true;
        }
        case kTypeDeletion:
          *s = Status::NotFound(Slice());
          return true;
      }",51,,130,2,,void
40581,BLOCK,3,,"{
          Slice v = GetLengthPrefixedSlice(key_ptr + key_length);
          value->assign(v.data(), v.size());
          return true;
        }",26,,131,3,,void
40633,BLOCK,-1,,<empty>,1,,1,1,,ANY
40641,BLOCK,-1,,<empty>,,,,2,,<empty>
40645,BLOCK,-1,,{ ++refs_; },14,,27,1,,void
40651,BLOCK,-1,,"{
    --refs_;
    assert(refs_ >= 0);
    if (refs_ <= 0) {
      delete this;
    }
  }",16,,30,1,,void
40662,BLOCK,-1,,"{
      delete this;
    }",21,,33,2,,void
40668,BLOCK,-1,,<empty>,,,,1,,<empty>
40672,BLOCK,-1,,<empty>,,,,1,,<empty>
40680,BLOCK,-1,,<empty>,,,,5,,<empty>
40687,BLOCK,-1,,<empty>,,,,4,,<empty>
40691,BLOCK,-1,,<empty>,,,,1,,<empty>
40698,BLOCK,-1,,{ },76,,68,2,,void
40704,BLOCK,-1,,<empty>,,,,3,,<empty>
40716,BLOCK,-1,,<empty>,,,,2,,<empty>
40721,BLOCK,-1,,<empty>,,,,2,,<empty>
40748,BLOCK,-1,,<empty>,1,,1,1,,ANY
40752,BLOCK,-1,,"{
    dbname_ = test::TmpDir() + ""/recovery_test"";
    DestroyDB(dbname_, Options());
    Open();
  }",52,,20,1,,void
40768,BLOCK,-1,,"{
    Close();
    DestroyDB(dbname_, Options());
  }",19,,26,1,,void
40776,BLOCK,-1,,{ return reinterpret_cast<DBImpl*>(db_); },26,,31,1,,void
40784,BLOCK,-1,,{ return env_; },20,,32,1,,void
40790,BLOCK,-1,,"{
    WritableFile* tmp;
    Status s = env_->NewAppendableFile(CurrentFileName(dbname_), &tmp);
    delete tmp;
    if (s.IsNotSupportedError()) {
      return false;
    } else {
      return true;
    }
  }",20,,34,1,,void
40810,BLOCK,-1,,"{
      return false;
    }",34,,38,2,,void
40814,BLOCK,-1,,"{
      return true;
    }",12,,40,1,,void
40820,BLOCK,-1,,"{
    delete db_;
    db_ = NULL;
  }",16,,45,1,,void
40830,BLOCK,-1,,"{
    Close();
    Options opts;
    if (options != NULL) {
      opts = *options;
    } else {
      opts.reuse_logs = true;  // TODO(sanjay): test both ways
      opts.create_if_missing = true;
    }
    if (opts.env == NULL) {
      opts.env = env_;
    }
    ASSERT_OK(DB::Open(opts, dbname_, &db_));
    ASSERT_EQ(1, NumLogs());
  }",38,,50,2,,void
40837,BLOCK,-1,,"{
      opts = *options;
    }",26,,53,2,,void
40843,BLOCK,-1,,"{
      opts.reuse_logs = true;  // TODO(sanjay): test both ways
      opts.create_if_missing = true;
    }",12,,55,1,,void
40860,BLOCK,-1,,"{
      opts.env = env_;
    }",27,,59,2,,void
40867,BLOCK,1,,<empty>,,,,2,,void
40890,BLOCK,1,,<empty>,,,,3,,void
40909,BLOCK,-1,,"{
    return db_->Put(WriteOptions(), k, v);
  }",58,,66,3,,void
40923,BLOCK,-1,,"{
    std::string result;
    Status s = db_->Get(ReadOptions(), k, &result);
    if (s.IsNotFound()) {
      result = ""NOT_FOUND"";
    } else if (!s.ok()) {
      result = s.ToString();
    }
    return result;
  }",74,,70,3,,void
40941,BLOCK,-1,,"{
      result = ""NOT_FOUND"";
    }",25,,73,2,,void
40946,BLOCK,-1,,<empty>,12,,75,1,,void
40953,BLOCK,-1,,"{
      result = s.ToString();
    }",25,,75,2,,void
40965,BLOCK,-1,,"{
    std::string current;
    ASSERT_OK(ReadFileToString(env_, CurrentFileName(dbname_), &current));
    size_t len = current.size();
    if (len > 0 && current[len-1] == '\n') {
      current.resize(len - 1);
    }
    return dbname_ + ""/"" + current;
  }",34,,81,1,,void
40968,BLOCK,1,,<empty>,,,,2,,void
41005,BLOCK,-1,,"{
      current.resize(len - 1);
    }",44,,85,2,,void
41023,BLOCK,-1,,"{
    return LogFileName(dbname_, number);
  }",40,,91,2,,void
41031,BLOCK,-1,,"{
    std::vector<uint64_t> logs = GetFiles(kLogFile);
    for (size_t i = 0; i < logs.size(); i++) {
      ASSERT_OK(env_->DeleteFile(LogName(logs[i]))) << LogName(logs[i]);
    }
    return logs.size();
  }",27,,95,1,,void
41043,BLOCK,-1,,<empty>,5,,97,1,,void
41056,BLOCK,4,,"{
      ASSERT_OK(env_->DeleteFile(LogName(logs[i]))) << LogName(logs[i]);
    }",46,,97,4,,void
41067,BLOCK,1,,<empty>,,,,2,,void
41099,BLOCK,-1,,"{
    return GetFiles(kLogFile)[0];
  }",27,,103,1,,void
41109,BLOCK,-1,,"{
    std::vector<std::string> filenames;
    ASSERT_OK(env_->GetChildren(dbname_, &filenames));
    std::vector<uint64_t> result;
    for (size_t i = 0; i < filenames.size(); i++) {
      uint64_t number;
      FileType type;
      if (ParseFileName(filenames[i], &number, &type) && type == t) {
        result.push_back(number);
      }
    }
    return result;
  }",46,,107,2,,void
41120,BLOCK,1,,<empty>,,,,1,,void
41147,BLOCK,-1,,<empty>,5,,111,1,,void
41160,BLOCK,4,,"{
      uint64_t number;
      FileType type;
      if (ParseFileName(filenames[i], &number, &type) && type == t) {
        result.push_back(number);
      }
    }",51,,111,4,,void
41176,BLOCK,-1,,"{
        result.push_back(number);
      }",69,,114,2,,void
41187,BLOCK,-1,,"{
    return GetFiles(kLogFile).size();
  }",17,,121,1,,void
41197,BLOCK,-1,,"{
    return GetFiles(kTableFile).size();
  }",19,,125,1,,void
41208,BLOCK,-1,,"{
    uint64_t result;
    ASSERT_OK(env_->GetFileSize(fname, &result)) << fname;
    return result;
  }",47,,129,2,,void
41212,BLOCK,1,,<empty>,,,,2,,void
41237,BLOCK,-1,,"{
    dbfull()->TEST_CompactMemTable();
  }",26,,135,1,,void
41249,BLOCK,-1,,"{
    std::string fname = LogFileName(dbname_, lognum);
    WritableFile* file;
    ASSERT_OK(env_->NewWritableFile(fname, &file));
    log::Writer writer(file);
    WriteBatch batch;
    batch.Put(key, val);
    WriteBatchInternal::SetSequence(&batch, seq);
    ASSERT_OK(writer.AddRecord(WriteBatchInternal::Contents(&batch)));
    ASSERT_OK(file->Flush());
    delete file;
  }",79,,140,5,,void
41258,BLOCK,1,,<empty>,,,,3,,void
41305,BLOCK,1,,<empty>,,,,4,,void
41332,BLOCK,1,,<empty>,,,,3,,void
41357,BLOCK,-1,,<empty>,,,,1,,<empty>
41361,BLOCK,-1,,"TEST(RecoveryTest, ManifestReused)",1,,159,1,,void
41385,BLOCK,-1,,"{
  if (!CanAppend()) {
    fprintf(stderr, ""skipping test because env does not support appending\n"");
    return;
  }
  ASSERT_OK(Put(""foo"", ""bar""));
  Close();
  std::string old_manifest = ManifestFileName();
  Open();
  ASSERT_EQ(old_manifest, ManifestFileName());
  ASSERT_EQ(""bar"", Get(""foo""));
  Open();
  ASSERT_EQ(old_manifest, ManifestFileName());
  ASSERT_EQ(""bar"", Get(""foo""));
}",36,,159,1,,void
41389,BLOCK,-1,,"{
    fprintf(stderr, ""skipping test because env does not support appending\n"");
    return;
  }",21,,160,2,,void
41395,BLOCK,1,,<empty>,,,,1,,void
41419,BLOCK,1,,<empty>,,,,4,,void
41437,BLOCK,1,,<empty>,,,,3,,void
41456,BLOCK,1,,<empty>,,,,4,,void
41474,BLOCK,1,,<empty>,,,,3,,void
41493,BLOCK,-1,,<empty>,,,,1,,<empty>
41497,BLOCK,-1,,"TEST(RecoveryTest, LargeManifestCompacted)",1,,175,1,,void
41521,BLOCK,-1,,"{
  if (!CanAppend()) {
    fprintf(stderr, ""skipping test because env does not support appending\n"");
    return;
  }
  ASSERT_OK(Put(""foo"", ""bar""));
  Close();
  std::string old_manifest = ManifestFileName();

  // Pad with zeroes to make manifest file very big.
  {
    uint64_t len = FileSize(old_manifest);
    WritableFile* file;
    ASSERT_OK(env()->NewAppendableFile(old_manifest, &file));
    std::string zeroes(3*1048576 - static_cast<size_t>(len), 0);
    ASSERT_OK(file->Append(zeroes));
    ASSERT_OK(file->Flush());
    delete file;
  }

  Open();
  std::string new_manifest = ManifestFileName();
  ASSERT_NE(old_manifest, new_manifest);
  ASSERT_GT(10000, FileSize(new_manifest));
  ASSERT_EQ(""bar"", Get(""foo""));

  Open();
  ASSERT_EQ(new_manifest, ManifestFileName());
  ASSERT_EQ(""bar"", Get(""foo""));
}",44,,175,1,,void
41525,BLOCK,-1,,"{
    fprintf(stderr, ""skipping test because env does not support appending\n"");
    return;
  }",21,,176,2,,void
41531,BLOCK,1,,<empty>,,,,1,,void
41551,BLOCK,6,,"{
    uint64_t len = FileSize(old_manifest);
    WritableFile* file;
    ASSERT_OK(env()->NewAppendableFile(old_manifest, &file));
    std::string zeroes(3*1048576 - static_cast<size_t>(len), 0);
    ASSERT_OK(file->Append(zeroes));
    ASSERT_OK(file->Flush());
    delete file;
  }",3,,185,6,,void
41559,BLOCK,1,,<empty>,,,,3,,void
41594,BLOCK,1,,<empty>,,,,4,,void
41616,BLOCK,1,,<empty>,,,,3,,void
41642,BLOCK,1,,<empty>,,,,5,,void
41660,BLOCK,1,,<empty>,,,,4,,void
41679,BLOCK,1,,<empty>,,,,3,,void
41698,BLOCK,1,,<empty>,,,,4,,void
41716,BLOCK,1,,<empty>,,,,3,,void
41735,BLOCK,-1,,<empty>,,,,1,,<empty>
41739,BLOCK,-1,,"TEST(RecoveryTest, NoLogFiles)",1,,206,1,,void
41763,BLOCK,-1,,"{
  ASSERT_OK(Put(""foo"", ""bar""));
  ASSERT_EQ(1, DeleteLogFiles());
  Open();
  ASSERT_EQ(""NOT_FOUND"", Get(""foo""));
  Open();
  ASSERT_EQ(""NOT_FOUND"", Get(""foo""));
}",32,,206,1,,void
41765,BLOCK,1,,<empty>,,,,1,,void
41783,BLOCK,1,,<empty>,,,,3,,void
41802,BLOCK,1,,<empty>,,,,3,,void
41822,BLOCK,1,,<empty>,,,,3,,void
41841,BLOCK,-1,,<empty>,,,,1,,<empty>
41845,BLOCK,-1,,"TEST(RecoveryTest, LogFileReuse)",1,,215,1,,void
41869,BLOCK,-1,,"{
  if (!CanAppend()) {
    fprintf(stderr, ""skipping test because env does not support appending\n"");
    return;
  }
  for (int i = 0; i < 2; i++) {
    ASSERT_OK(Put(""foo"", ""bar""));
    if (i == 0) {
      // Compact to ensure current log is empty
      CompactMemTable();
    }
    Close();
    ASSERT_EQ(1, NumLogs());
    uint64_t number = FirstLogFile();
    if (i == 0) {
      ASSERT_EQ(0, FileSize(LogName(number)));
    } else {
      ASSERT_LT(0, FileSize(LogName(number)));
    }
    Open();
    ASSERT_EQ(1, NumLogs());
    ASSERT_EQ(number, FirstLogFile()) << ""did not reuse log file"";
    ASSERT_EQ(""bar"", Get(""foo""));
    Open();
    ASSERT_EQ(1, NumLogs());
    ASSERT_EQ(number, FirstLogFile()) << ""did not reuse log file"";
    ASSERT_EQ(""bar"", Get(""foo""));
  }
}",34,,215,1,,void
41873,BLOCK,-1,,"{
    fprintf(stderr, ""skipping test because env does not support appending\n"");
    return;
  }",21,,216,2,,void
41879,BLOCK,-1,,<empty>,3,,220,1,,void
41889,BLOCK,4,,"{
    ASSERT_OK(Put(""foo"", ""bar""));
    if (i == 0) {
      // Compact to ensure current log is empty
      CompactMemTable();
    }
    Close();
    ASSERT_EQ(1, NumLogs());
    uint64_t number = FirstLogFile();
    if (i == 0) {
      ASSERT_EQ(0, FileSize(LogName(number)));
    } else {
      ASSERT_LT(0, FileSize(LogName(number)));
    }
    Open();
    ASSERT_EQ(1, NumLogs());
    ASSERT_EQ(number, FirstLogFile()) << ""did not reuse log file"";
    ASSERT_EQ(""bar"", Get(""foo""));
    Open();
    ASSERT_EQ(1, NumLogs());
    ASSERT_EQ(number, FirstLogFile()) << ""did not reuse log file"";
    ASSERT_EQ(""bar"", Get(""foo""));
  }",31,,220,4,,void
41891,BLOCK,1,,<empty>,,,,1,,void
41910,BLOCK,-1,,"{
      // Compact to ensure current log is empty
      CompactMemTable();
    }",17,,222,2,,void
41916,BLOCK,1,,<empty>,,,,3,,void
41938,BLOCK,-1,,"{
      ASSERT_EQ(0, FileSize(LogName(number)));
    }",17,,229,2,,void
41944,BLOCK,1,,<empty>,,,,4,,void
41961,BLOCK,-1,,"{
      ASSERT_LT(0, FileSize(LogName(number)));
    }",12,,231,1,,void
41967,BLOCK,1,,<empty>,,,,4,,void
41987,BLOCK,1,,<empty>,,,,3,,void
42005,BLOCK,1,,<empty>,,,,4,,void
42024,BLOCK,1,,<empty>,,,,3,,void
42043,BLOCK,1,,<empty>,,,,3,,void
42061,BLOCK,1,,<empty>,,,,4,,void
42080,BLOCK,1,,<empty>,,,,3,,void
42099,BLOCK,-1,,<empty>,,,,1,,<empty>
42103,BLOCK,-1,,"TEST(RecoveryTest, MultipleMemTables)",1,,245,1,,void
42127,BLOCK,-1,,"{
  // Make a large log.
  const int kNum = 1000;
  for (int i = 0; i < kNum; i++) {
    char buf[100];
    snprintf(buf, sizeof(buf), ""%050d"", i);
    ASSERT_OK(Put(buf, buf));
  }
  ASSERT_EQ(0, NumTables());
  Close();
  ASSERT_EQ(0, NumTables());
  ASSERT_EQ(1, NumLogs());
  uint64_t old_log_file = FirstLogFile();

  // Force creation of multiple memtables by reducing the write buffer size.
  Options opt;
  opt.reuse_logs = true;
  opt.write_buffer_size = (kNum*100) / 2;
  Open(&opt);
  ASSERT_LE(2, NumTables());
  ASSERT_EQ(1, NumLogs());
  ASSERT_NE(old_log_file, FirstLogFile()) << ""must not reuse log"";
  for (int i = 0; i < kNum; i++) {
    char buf[100];
    snprintf(buf, sizeof(buf), ""%050d"", i);
    ASSERT_EQ(buf, Get(buf));
  }
}",39,,245,1,,void
42133,BLOCK,-1,,<empty>,3,,248,1,,void
42143,BLOCK,4,,"{
    char buf[100];
    snprintf(buf, sizeof(buf), ""%050d"", i);
    ASSERT_OK(Put(buf, buf));
  }",34,,248,4,,void
42152,BLOCK,1,,<empty>,,,,3,,void
42170,BLOCK,1,,<empty>,,,,3,,void
42188,BLOCK,1,,<empty>,,,,3,,void
42205,BLOCK,1,,<empty>,,,,3,,void
42244,BLOCK,1,,<empty>,,,,3,,void
42261,BLOCK,1,,<empty>,,,,3,,void
42279,BLOCK,1,,<empty>,,,,4,,void
42295,BLOCK,-1,,<empty>,3,,267,1,,void
42305,BLOCK,4,,"{
    char buf[100];
    snprintf(buf, sizeof(buf), ""%050d"", i);
    ASSERT_EQ(buf, Get(buf));
  }",34,,267,4,,void
42317,BLOCK,1,,<empty>,,,,5,,void
42336,BLOCK,-1,,<empty>,,,,1,,<empty>
42340,BLOCK,-1,,"TEST(RecoveryTest, MultipleLogFiles)",1,,274,1,,void
42364,BLOCK,-1,,"{
  ASSERT_OK(Put(""foo"", ""bar""));
  Close();
  ASSERT_EQ(1, NumLogs());

  // Make a bunch of uncompacted log files.
  uint64_t old_log = FirstLogFile();
  MakeLogFile(old_log+1, 1000, ""hello"", ""world"");
  MakeLogFile(old_log+2, 1001, ""hi"", ""there"");
  MakeLogFile(old_log+3, 1002, ""foo"", ""bar2"");

  // Recover and check that all log files were processed.
  Open();
  ASSERT_LE(1, NumTables());
  ASSERT_EQ(1, NumLogs());
  uint64_t new_log = FirstLogFile();
  ASSERT_LE(old_log+3, new_log);
  ASSERT_EQ(""bar2"", Get(""foo""));
  ASSERT_EQ(""world"", Get(""hello""));
  ASSERT_EQ(""there"", Get(""hi""));

  // Test that previous recovery produced recoverable state.
  Open();
  ASSERT_LE(1, NumTables());
  ASSERT_EQ(1, NumLogs());
  if (CanAppend()) {
    ASSERT_EQ(new_log, FirstLogFile());
  }
  ASSERT_EQ(""bar2"", Get(""foo""));
  ASSERT_EQ(""world"", Get(""hello""));
  ASSERT_EQ(""there"", Get(""hi""));

  // Check that introducing an older log file does not cause it to be re-read.
  Close();
  MakeLogFile(ol...",38,,274,1,,void
42366,BLOCK,1,,<empty>,,,,1,,void
42385,BLOCK,1,,<empty>,,,,3,,void
42428,BLOCK,1,,<empty>,,,,3,,void
42445,BLOCK,1,,<empty>,,,,3,,void
42465,BLOCK,1,,<empty>,,,,4,,void
42485,BLOCK,1,,<empty>,,,,3,,void
42504,BLOCK,1,,<empty>,,,,3,,void
42523,BLOCK,1,,<empty>,,,,3,,void
42542,BLOCK,1,,<empty>,,,,3,,void
42559,BLOCK,1,,<empty>,,,,3,,void
42575,BLOCK,-1,,"{
    ASSERT_EQ(new_log, FirstLogFile());
  }",20,,299,2,,void
42579,BLOCK,1,,<empty>,,,,4,,void
42597,BLOCK,1,,<empty>,,,,3,,void
42616,BLOCK,1,,<empty>,,,,3,,void
42635,BLOCK,1,,<empty>,,,,3,,void
42662,BLOCK,1,,<empty>,,,,3,,void
42679,BLOCK,1,,<empty>,,,,3,,void
42695,BLOCK,-1,,"{
    ASSERT_EQ(new_log, FirstLogFile());
  }",20,,312,2,,void
42699,BLOCK,1,,<empty>,,,,4,,void
42717,BLOCK,1,,<empty>,,,,3,,void
42736,BLOCK,1,,<empty>,,,,3,,void
42755,BLOCK,1,,<empty>,,,,3,,void
42775,BLOCK,-1,,"{
  return leveldb::test::RunAllTests();
}",33,,322,3,,void
42815,BLOCK,-1,,<empty>,1,,1,1,,ANY
42822,BLOCK,-1,,"{
    // TableCache can be small since we expect each table to be opened once.
    table_cache_ = new TableCache(dbname_, &options_, 10);
  }",30,,55,3,,void
42834,BLOCK,-1,,"{
    delete table_cache_;
    if (owns_info_log_) {
      delete options_.info_log;
    }
    if (owns_cache_) {
      delete options_.block_cache;
    }
  }",15,,60,1,,void
42839,BLOCK,-1,,"{
      delete options_.info_log;
    }",25,,62,2,,void
42846,BLOCK,-1,,"{
      delete options_.block_cache;
    }",22,,65,2,,void
42854,BLOCK,-1,,"{
    Status status = FindFiles();
    if (status.ok()) {
      ConvertLogFilesToTables();
      ExtractMetaData();
      status = WriteDescriptor();
    }
    if (status.ok()) {
      unsigned long long bytes = 0;
      for (size_t i = 0; i < tables_.size(); i++) {
        bytes += tables_[i].meta.file_size;
      }
      Log(options_.info_log,
          ""**** Repaired leveldb %s; ""
          ""recovered %d files; %llu bytes. ""
          ""Some data may have been lost. ""
          ""****"",
          dbname_.c_str(),
          static_cast<int>(tables_.size()),
          bytes);
    }
    return status;
  }",16,,70,1,,void
42864,BLOCK,-1,,"{
      ConvertLogFilesToTables();
      ExtractMetaData();
      status = WriteDescriptor();
    }",22,,72,2,,void
42875,BLOCK,-1,,"{
      unsigned long long bytes = 0;
      for (size_t i = 0; i < tables_.size(); i++) {
        bytes += tables_[i].meta.file_size;
      }
      Log(options_.info_log,
          ""**** Repaired leveldb %s; ""
          ""recovered %d files; %llu bytes. ""
          ""Some data may have been lost. ""
          ""****"",
          dbname_.c_str(),
          static_cast<int>(tables_.size()),
          bytes);
    }",22,,77,2,,void
42881,BLOCK,-1,,<empty>,7,,79,1,,void
42894,BLOCK,4,,"{
        bytes += tables_[i].meta.file_size;
      }",51,,79,4,,void
42942,BLOCK,-1,,"{
    std::vector<std::string> filenames;
    Status status = env_->GetChildren(dbname_, &filenames);
    if (!status.ok()) {
      return status;
    }
    if (filenames.empty()) {
      return Status::IOError(dbname_, ""repair found no files"");
    }

    uint64_t number;
    FileType type;
    for (size_t i = 0; i < filenames.size(); i++) {
      if (ParseFileName(filenames[i], &number, &type)) {
        if (type == kDescriptorFile) {
          manifests_.push_back(filenames[i]);
        } else {
          if (number + 1 > next_file_number_) {
            next_file_number_ = number + 1;
          }
          if (type == kLogFile) {
            logs_.push_back(number);
          } else if (type == kTableFile) {
            table_numbers_.push_back(number);
          } else {
            // Ignore other files
          }
        }
      }
    }
    return status;
  }",22,,116,1,,void
42968,BLOCK,-1,,"{
      return status;
    }",23,,119,2,,void
42976,BLOCK,-1,,"{
      return Status::IOError(dbname_, ""repair found no files"");
    }",28,,122,2,,void
42987,BLOCK,-1,,<empty>,5,,128,1,,void
43000,BLOCK,4,,"{
      if (ParseFileName(filenames[i], &number, &type)) {
        if (type == kDescriptorFile) {
          manifests_.push_back(filenames[i]);
        } else {
          if (number + 1 > next_file_number_) {
            next_file_number_ = number + 1;
          }
          if (type == kLogFile) {
            logs_.push_back(number);
          } else if (type == kTableFile) {
            table_numbers_.push_back(number);
          } else {
            // Ignore other files
          }
        }
      }
    }",51,,128,4,,void
43010,BLOCK,-1,,"{
        if (type == kDescriptorFile) {
          manifests_.push_back(filenames[i]);
        } else {
          if (number + 1 > next_file_number_) {
            next_file_number_ = number + 1;
          }
          if (type == kLogFile) {
            logs_.push_back(number);
          } else if (type == kTableFile) {
            table_numbers_.push_back(number);
          } else {
            // Ignore other files
          }
        }
      }",56,,129,2,,void
43015,BLOCK,-1,,"{
          manifests_.push_back(filenames[i]);
        }",38,,130,2,,void
43024,BLOCK,-1,,"{
          if (number + 1 > next_file_number_) {
            next_file_number_ = number + 1;
          }
          if (type == kLogFile) {
            logs_.push_back(number);
          } else if (type == kTableFile) {
            table_numbers_.push_back(number);
          } else {
            // Ignore other files
          }
        }",16,,132,1,,void
43031,BLOCK,-1,,"{
            next_file_number_ = number + 1;
          }",47,,133,2,,void
43041,BLOCK,-1,,"{
            logs_.push_back(number);
          }",33,,136,2,,void
43048,BLOCK,-1,,<empty>,18,,138,1,,void
43053,BLOCK,-1,,"{
            table_numbers_.push_back(number);
          }",42,,138,2,,void
43060,BLOCK,-1,,"{
            // Ignore other files
          }",18,,140,1,,void
43066,BLOCK,-1,,"{
    for (size_t i = 0; i < logs_.size(); i++) {
      std::string logname = LogFileName(dbname_, logs_[i]);
      Status status = ConvertLogToTable(logs_[i]);
      if (!status.ok()) {
        Log(options_.info_log, ""Log #%llu: ignoring conversion error: %s"",
            (unsigned long long) logs_[i],
            status.ToString().c_str());
      }
      ArchiveFile(logname);
    }
  }",34,,149,1,,void
43068,BLOCK,-1,,<empty>,5,,150,1,,void
43081,BLOCK,4,,"{
      std::string logname = LogFileName(dbname_, logs_[i]);
      Status status = ConvertLogToTable(logs_[i]);
      if (!status.ok()) {
        Log(options_.info_log, ""Log #%llu: ignoring conversion error: %s"",
            (unsigned long long) logs_[i],
            status.ToString().c_str());
      }
      ArchiveFile(logname);
    }",47,,150,4,,void
43103,BLOCK,-1,,"{
        Log(options_.info_log, ""Log #%llu: ignoring conversion error: %s"",
            (unsigned long long) logs_[i],
            status.ToString().c_str());
      }",25,,153,2,,void
43127,BLOCK,-1,,"{
    struct LogReporter : public log::Reader::Reporter {
      Env* env;
      Logger* info_log;
      uint64_t lognum;
      virtual void Corruption(size_t bytes, const Status& s) {
        // We print error messages for corruption, but continue repairing.
        Log(info_log, ""Log #%llu: dropping %d bytes; %s"",
            (unsigned long long) lognum,
            static_cast<int>(bytes),
            s.ToString().c_str());
      }
    };

    // Open the log file
    std::string logname = LogFileName(dbname_, log);
    SequentialFile* lfile;
    Status status = env_->NewSequentialFile(logname, &lfile);
    if (!status.ok()) {
      return status;
    }

    // Create the log reader.
    LogReporter reporter;
    reporter.env = env_;
    reporter.info_log = options_.info_log;
    reporter.lognum = log;
    // We intentionally make log::Reader do checksumming so that
    // corruptions cause entire commits to be skipped instead of
    // propagating bad information (like overly lar...",42,,162,2,,void
43151,BLOCK,-1,,"{
      return status;
    }",23,,180,2,,void
43205,BLOCK,-1,,"{
      if (record.size() < 12) {
        reporter.Corruption(
            record.size(), Status::Corruption(""log record too small""));
        continue;
      }
      WriteBatchInternal::SetContents(&batch, record);
      status = WriteBatchInternal::InsertInto(&batch, mem);
      if (status.ok()) {
        counter += WriteBatchInternal::Count(&batch);
      } else {
        Log(options_.info_log, ""Log #%llu: ignoring %s"",
            (unsigned long long) log,
            status.ToString().c_str());
        status = Status::OK();  // Keep going with rest of file
      }
    }",50,,203,2,,void
43213,BLOCK,-1,,"{
        reporter.Corruption(
            record.size(), Status::Corruption(""log record too small""));
        continue;
      }",31,,204,2,,void
43249,BLOCK,-1,,"{
        counter += WriteBatchInternal::Count(&batch);
      }",24,,211,2,,void
43259,BLOCK,-1,,"{
        Log(options_.info_log, ""Log #%llu: ignoring %s"",
            (unsigned long long) log,
            status.ToString().c_str());
        status = Status::OK();  // Keep going with rest of file
      }",14,,213,1,,void
43321,BLOCK,-1,,"{
      if (meta.file_size > 0) {
        table_numbers_.push_back(meta.number);
      }
    }",22,,231,2,,void
43328,BLOCK,-1,,"{
        table_numbers_.push_back(meta.number);
      }",31,,232,2,,void
43362,BLOCK,-1,,"{
    for (size_t i = 0; i < table_numbers_.size(); i++) {
      ScanTable(table_numbers_[i]);
    }
  }",26,,244,1,,void
43364,BLOCK,-1,,<empty>,5,,245,1,,void
43377,BLOCK,4,,"{
      ScanTable(table_numbers_[i]);
    }",56,,245,4,,void
43386,BLOCK,-1,,"{
    // Same as compaction iterators: if paranoid_checks are on, turn
    // on checksum verification.
    ReadOptions r;
    r.verify_checksums = options_.paranoid_checks;
    return table_cache_->NewIterator(r, meta.number, meta.file_size);
  }",56,,250,2,,void
43411,BLOCK,-1,,"{
    TableInfo t;
    t.meta.number = number;
    std::string fname = TableFileName(dbname_, number);
    Status status = env_->GetFileSize(fname, &t.meta.file_size);
    if (!status.ok()) {
      // Try alternate file name.
      fname = SSTTableFileName(dbname_, number);
      Status s2 = env_->GetFileSize(fname, &t.meta.file_size);
      if (s2.ok()) {
        status = Status::OK();
      }
    }
    if (!status.ok()) {
      ArchiveFile(TableFileName(dbname_, number));
      ArchiveFile(SSTTableFileName(dbname_, number));
      Log(options_.info_log, ""Table #%llu: dropped: %s"",
          (unsigned long long) t.meta.number,
          status.ToString().c_str());
      return;
    }

    // Extract metadata by scanning through table.
    int counter = 0;
    Iterator* iter = NewTableIterator(t.meta);
    bool empty = true;
    ParsedInternalKey parsed;
    t.max_sequence = 0;
    for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {
      Slice key = iter->key();
      if (!Par...",35,,258,2,,void
43446,BLOCK,-1,,"{
      // Try alternate file name.
      fname = SSTTableFileName(dbname_, number);
      Status s2 = env_->GetFileSize(fname, &t.meta.file_size);
      if (s2.ok()) {
        status = Status::OK();
      }
    }",23,,263,2,,void
43471,BLOCK,-1,,"{
        status = Status::OK();
      }",20,,267,2,,void
43484,BLOCK,-1,,"{
      ArchiveFile(TableFileName(dbname_, number));
      ArchiveFile(SSTTableFileName(dbname_, number));
      Log(options_.info_log, ""Table #%llu: dropped: %s"",
          (unsigned long long) t.meta.number,
          status.ToString().c_str());
      return;
    }",23,,271,2,,void
43535,BLOCK,-1,,<empty>,5,,286,1,,void
43548,BLOCK,4,,"{
      Slice key = iter->key();
      if (!ParseInternalKey(key, &parsed)) {
        Log(options_.info_log, ""Table #%llu: unparsable key %s"",
            (unsigned long long) t.meta.number,
            EscapeString(key).c_str());
        continue;
      }

      counter++;
      if (empty) {
        empty = false;
        t.meta.smallest.DecodeFrom(key);
      }
      t.meta.largest.DecodeFrom(key);
      if (parsed.sequence > t.max_sequence) {
        t.max_sequence = parsed.sequence;
      }
    }",60,,286,4,,void
43562,BLOCK,-1,,"{
        Log(options_.info_log, ""Table #%llu: unparsable key %s"",
            (unsigned long long) t.meta.number,
            EscapeString(key).c_str());
        continue;
      }",44,,288,2,,void
43585,BLOCK,-1,,"{
        empty = false;
        t.meta.smallest.DecodeFrom(key);
      }",18,,296,2,,void
43615,BLOCK,-1,,"{
        t.max_sequence = parsed.sequence;
      }",45,,301,2,,void
43632,BLOCK,-1,,"{
      status = iter->status();
    }",31,,305,2,,void
43666,BLOCK,-1,,"{
      tables_.push_back(t);
    }",22,,314,2,,void
43673,BLOCK,-1,,"{
      RepairTable(fname, t);  // RepairTable archives input file.
    }",12,,316,1,,void
43682,BLOCK,-1,,"{
    // We will copy src contents to a new table and then rename the
    // new table over the source.

    // Create builder.
    std::string copy = TableFileName(dbname_, next_file_number_++);
    WritableFile* file;
    Status s = env_->NewWritableFile(copy, &file);
    if (!s.ok()) {
      return;
    }
    TableBuilder* builder = new TableBuilder(options_, file);

    // Copy data.
    Iterator* iter = NewTableIterator(t.meta);
    int counter = 0;
    for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {
      builder->Add(iter->key(), iter->value());
      counter++;
    }
    delete iter;

    ArchiveFile(src);
    if (counter == 0) {
      builder->Abandon();  // Nothing to save
    } else {
      s = builder->Finish();
      if (s.ok()) {
        t.meta.file_size = builder->FileSize();
      }
    }
    delete builder;
    builder = NULL;

    if (s.ok()) {
      s = file->Close();
    }
    delete file;
    file = NULL;

    if (counter > 0 && s.ok()) {
      std::str...",57,,321,3,,void
43707,BLOCK,-1,,"{
      return;
    }",18,,329,2,,void
43728,BLOCK,-1,,<empty>,5,,337,1,,void
43741,BLOCK,4,,"{
      builder->Add(iter->key(), iter->value());
      counter++;
    }",60,,337,4,,void
43764,BLOCK,-1,,"{
      builder->Abandon();  // Nothing to save
    }",23,,344,2,,void
43770,BLOCK,-1,,"{
      s = builder->Finish();
      if (s.ok()) {
        t.meta.file_size = builder->FileSize();
      }
    }",12,,346,1,,void
43782,BLOCK,-1,,"{
        t.meta.file_size = builder->FileSize();
      }",19,,348,2,,void
43803,BLOCK,-1,,"{
      s = file->Close();
    }",17,,355,2,,void
43824,BLOCK,-1,,"{
      std::string orig = TableFileName(dbname_, t.meta.number);
      s = env_->RenameFile(copy, orig);
      if (s.ok()) {
        Log(options_.info_log, ""Table #%llu: %d entries repaired"",
            (unsigned long long) t.meta.number, counter);
        tables_.push_back(t);
      }
    }",32,,361,2,,void
43848,BLOCK,-1,,"{
        Log(options_.info_log, ""Table #%llu: %d entries repaired"",
            (unsigned long long) t.meta.number, counter);
        tables_.push_back(t);
      }",19,,364,2,,void
43873,BLOCK,-1,,"{
      env_->DeleteFile(copy);
    }",18,,370,2,,void
43882,BLOCK,-1,,"{
    std::string tmp = TempFileName(dbname_, 1);
    WritableFile* file;
    Status status = env_->NewWritableFile(tmp, &file);
    if (!status.ok()) {
      return status;
    }

    SequenceNumber max_sequence = 0;
    for (size_t i = 0; i < tables_.size(); i++) {
      if (max_sequence < tables_[i].max_sequence) {
        max_sequence = tables_[i].max_sequence;
      }
    }

    edit_.SetComparatorName(icmp_.user_comparator()->Name());
    edit_.SetLogNumber(0);
    edit_.SetNextFile(next_file_number_);
    edit_.SetLastSequence(max_sequence);

    for (size_t i = 0; i < tables_.size(); i++) {
      // TODO(opt): separate out into multiple levels
      const TableInfo& t = tables_[i];
      edit_.AddFile(0, t.meta.number, t.meta.file_size,
                    t.meta.smallest, t.meta.largest);
    }

    //fprintf(stderr, ""NewDescriptor:\n%s\n"", edit_.DebugString().c_str());
    {
      log::Writer log(file);
      std::string record;
      edit_.EncodeTo(&record);
      status ...",28,,375,1,,void
43906,BLOCK,-1,,"{
      return status;
    }",23,,379,2,,void
43914,BLOCK,-1,,<empty>,5,,384,1,,void
43927,BLOCK,4,,"{
      if (max_sequence < tables_[i].max_sequence) {
        max_sequence = tables_[i].max_sequence;
      }
    }",49,,384,4,,void
43936,BLOCK,-1,,"{
        max_sequence = tables_[i].max_sequence;
      }",51,,385,2,,void
43971,BLOCK,-1,,<empty>,5,,395,1,,void
43984,BLOCK,4,,"{
      // TODO(opt): separate out into multiple levels
      const TableInfo& t = tables_[i];
      edit_.AddFile(0, t.meta.number, t.meta.file_size,
                    t.meta.smallest, t.meta.largest);
    }",49,,395,4,,void
44016,BLOCK,15,,"{
      log::Writer log(file);
      std::string record;
      edit_.EncodeTo(&record);
      status = log.AddRecord(record);
    }",5,,403,15,,void
44039,BLOCK,-1,,"{
      status = file->Close();
    }",22,,409,2,,void
44057,BLOCK,-1,,"{
      env_->DeleteFile(tmp);
    }",23,,415,2,,void
44064,BLOCK,-1,,"{
      // Discard older manifests
      for (size_t i = 0; i < manifests_.size(); i++) {
        ArchiveFile(dbname_ + ""/"" + manifests_[i]);
      }

      // Install new manifest
      status = env_->RenameFile(tmp, DescriptorFileName(dbname_, 1));
      if (status.ok()) {
        status = SetCurrentFile(env_, dbname_, 1);
      } else {
        env_->DeleteFile(tmp);
      }
    }",12,,417,1,,void
44066,BLOCK,-1,,<empty>,7,,419,1,,void
44079,BLOCK,4,,"{
        ArchiveFile(dbname_ + ""/"" + manifests_[i]);
      }",54,,419,4,,void
44103,BLOCK,-1,,"{
        status = SetCurrentFile(env_, dbname_, 1);
      }",24,,425,2,,void
44111,BLOCK,-1,,"{
        env_->DeleteFile(tmp);
      }",14,,427,1,,void
44123,BLOCK,-1,,"{
    // Move into another directory.  E.g., for
    //    dir/foo
    // rename to
    //    dir/lost/foo
    const char* slash = strrchr(fname.c_str(), '/');
    std::string new_dir;
    if (slash != NULL) {
      new_dir.assign(fname.data(), slash - fname.data());
    }
    new_dir.append(""/lost"");
    env_->CreateDir(new_dir);  // Ignore error
    std::string new_file = new_dir;
    new_file.append(""/"");
    new_file.append((slash == NULL) ? fname.c_str() : slash + 1);
    Status s = env_->RenameFile(fname, new_file);
    Log(options_.info_log, ""Archiving %s: %s\n"",
        fname.c_str(), s.ToString().c_str());
  }",46,,434,2,,void
44138,BLOCK,-1,,"{
      new_dir.assign(fname.data(), slash - fname.data());
    }",24,,441,2,,void
44217,BLOCK,-1,,"{
  Repairer repairer(dbname, options);
  return repairer.Run();
}",68,,456,3,,void
44243,BLOCK,-1,,<empty>,1,,1,1,,ANY
44251,BLOCK,-1,,<empty>,,,,3,,<empty>
44256,BLOCK,-1,,<empty>,,,,2,,<empty>
44261,BLOCK,-1,,<empty>,,,,2,,<empty>
44267,BLOCK,-1,,<empty>,,,,2,,<empty>
44271,BLOCK,-1,,<empty>,,,,1,,<empty>
44275,BLOCK,-1,,<empty>,,,,1,,<empty>
44279,BLOCK,-1,,<empty>,,,,1,,<empty>
44283,BLOCK,-1,,<empty>,,,,1,,<empty>
44288,BLOCK,-1,,<empty>,,,,2,,<empty>
44292,BLOCK,-1,,<empty>,,,,1,,<empty>
44296,BLOCK,-1,,<empty>,,,,1,,<empty>
44304,BLOCK,-1,,<empty>,,,,1,,<empty>
44315,BLOCK,-1,,"{
    return static_cast<int>(
        reinterpret_cast<intptr_t>(max_height_.NoBarrier_Load()));
  }",35,,110,1,,void
44331,BLOCK,-1,,<empty>,,,,3,,<empty>
44335,BLOCK,-1,,<empty>,,,,1,,<empty>
44341,BLOCK,-1,,"{ return (compare_(a, b) == 0); }",48,,120,3,,void
44353,BLOCK,-1,,<empty>,,,,3,,<empty>
44359,BLOCK,-1,,<empty>,,,,3,,<empty>
44364,BLOCK,-1,,<empty>,,,,2,,<empty>
44368,BLOCK,-1,,<empty>,,,,1,,<empty>
44373,BLOCK,-1,,<empty>,,,,2,,<empty>
44378,BLOCK,-1,,<empty>,,,,2,,<empty>
44384,BLOCK,-1,,{ },40,,148,2,,void
44390,BLOCK,-1,,"{
    assert(n >= 0);
    // Use an 'acquire load' so that we observe a fully initialized
    // version of the returned Node.
    return reinterpret_cast<Node*>(next_[n].Acquire_Load());
  }",21,,154,2,,void
44409,BLOCK,-1,,"{
    assert(n >= 0);
    // Use a 'release store' so that anybody who reads through this
    // pointer observes a fully initialized version of the inserted node.
    next_[n].Release_Store(x);
  }",32,,160,3,,void
44425,BLOCK,-1,,"{
    assert(n >= 0);
    return reinterpret_cast<Node*>(next_[n].NoBarrier_Load());
  }",31,,168,2,,void
44444,BLOCK,-1,,"{
    assert(n >= 0);
    next_[n].NoBarrier_Store(x);
  }",42,,172,3,,void
44460,BLOCK,-1,,<empty>,,,,1,,<empty>
44468,BLOCK,-1,,"{
  char* mem = arena_->AllocateAligned(
      sizeof(Node) + sizeof(port::AtomicPointer) * (height - 1));
  return new (mem) Node(key);
}",63,,184,3,,void
44494,BLOCK,-1,,"{
  list_ = list;
  node_ = NULL;
}",75,,191,2,,void
44504,BLOCK,-1,,"{
  return node_ != NULL;
}",63,,197,1,,void
44512,BLOCK,-1,,"{
  assert(Valid());
  return node_->key;
}",67,,202,1,,void
44522,BLOCK,-1,,"{
  assert(Valid());
  node_ = node_->Next(0);
}",56,,208,1,,void
44535,BLOCK,-1,,"{
  // Instead of using explicit ""prev"" links, we just search for the
  // last node that falls before key.
  assert(Valid());
  node_ = list_->FindLessThan(node_->key);
  if (node_ == list_->head_) {
    node_ = NULL;
  }
}",56,,214,1,,void
44553,BLOCK,-1,,"{
    node_ = NULL;
  }",30,,219,2,,void
44561,BLOCK,-1,,"{
  node_ = list_->FindGreaterOrEqual(target, NULL);
}",73,,225,2,,void
44573,BLOCK,-1,,"{
  node_ = list_->head_->Next(0);
}",63,,230,1,,void
44586,BLOCK,-1,,"{
  node_ = list_->FindLast();
  if (node_ == list_->head_) {
    node_ = NULL;
  }
}",62,,235,1,,void
44599,BLOCK,-1,,"{
    node_ = NULL;
  }",30,,237,2,,void
44606,BLOCK,-1,,"{
  // Increase height with probability 1 in kBranching
  static const unsigned int kBranching = 4;
  int height = 1;
  while (height < kMaxHeight && ((rnd_.Next() % kBranching) == 0)) {
    height++;
  }
  assert(height > 0);
  assert(height <= kMaxHeight);
  return height;
}",46,,243,1,,void
44628,BLOCK,-1,,"{
    height++;
  }",68,,247,2,,void
44646,BLOCK,-1,,"{
  // NULL n is considered infinite
  return (n != NULL) && (compare_(n->key, key) < 0);
}",78,,256,3,,void
44664,BLOCK,-1,,"{
  Node* x = head_;
  int level = GetMaxHeight() - 1;
  while (true) {
    Node* next = x->Next(level);
    if (KeyIsAfterNode(key, next)) {
      // Keep searching in this list
      x = next;
    } else {
      if (prev != NULL) prev[level] = x;
      if (level == 0) {
        return next;
      } else {
        // Switch to next list
        level--;
      }
    }
  }
}",11,,263,3,,void
44677,BLOCK,-1,,"{
    Node* next = x->Next(level);
    if (KeyIsAfterNode(key, next)) {
      // Keep searching in this list
      x = next;
    } else {
      if (prev != NULL) prev[level] = x;
      if (level == 0) {
        return next;
      } else {
        // Switch to next list
        level--;
      }
    }
  }",16,,266,2,,void
44690,BLOCK,-1,,"{
      // Keep searching in this list
      x = next;
    }",36,,268,2,,void
44695,BLOCK,-1,,"{
      if (prev != NULL) prev[level] = x;
      if (level == 0) {
        return next;
      } else {
        // Switch to next list
        level--;
      }
    }",12,,271,1,,void
44700,BLOCK,-1,,<empty>,25,,272,2,,void
44710,BLOCK,-1,,"{
        return next;
      }",23,,273,2,,void
44714,BLOCK,-1,,"{
        // Switch to next list
        level--;
      }",14,,275,1,,void
44721,BLOCK,-1,,"{
  Node* x = head_;
  int level = GetMaxHeight() - 1;
  while (true) {
    assert(x == head_ || compare_(x->key, key) < 0);
    Node* next = x->Next(level);
    if (next == NULL || compare_(next->key, key) >= 0) {
      if (level == 0) {
        return x;
      } else {
        // Switch to next list
        level--;
      }
    } else {
      x = next;
    }
  }
}",62,,285,2,,void
44734,BLOCK,-1,,"{
    assert(x == head_ || compare_(x->key, key) < 0);
    Node* next = x->Next(level);
    if (next == NULL || compare_(next->key, key) >= 0) {
      if (level == 0) {
        return x;
      } else {
        // Switch to next list
        level--;
      }
    } else {
      x = next;
    }
  }",16,,288,2,,void
44767,BLOCK,-1,,"{
      if (level == 0) {
        return x;
      } else {
        // Switch to next list
        level--;
      }
    }",56,,291,2,,void
44772,BLOCK,-1,,"{
        return x;
      }",23,,292,2,,void
44776,BLOCK,-1,,"{
        // Switch to next list
        level--;
      }",14,,294,1,,void
44780,BLOCK,-1,,"{
      x = next;
    }",12,,298,1,,void
44787,BLOCK,-1,,"{
  Node* x = head_;
  int level = GetMaxHeight() - 1;
  while (true) {
    Node* next = x->Next(level);
    if (next == NULL) {
      if (level == 0) {
        return x;
      } else {
        // Switch to next list
        level--;
      }
    } else {
      x = next;
    }
  }
}",11,,306,1,,void
44800,BLOCK,-1,,"{
    Node* next = x->Next(level);
    if (next == NULL) {
      if (level == 0) {
        return x;
      } else {
        // Switch to next list
        level--;
      }
    } else {
      x = next;
    }
  }",16,,309,2,,void
44813,BLOCK,-1,,"{
      if (level == 0) {
        return x;
      } else {
        // Switch to next list
        level--;
      }
    }",23,,311,2,,void
44818,BLOCK,-1,,"{
        return x;
      }",23,,312,2,,void
44822,BLOCK,-1,,"{
        // Switch to next list
        level--;
      }",14,,314,1,,void
44826,BLOCK,-1,,"{
      x = next;
    }",12,,318,1,,void
44835,BLOCK,-1,,"{
  for (int i = 0; i < kMaxHeight; i++) {
    head_->SetNext(i, NULL);
  }
}",24,,330,3,,void
44837,BLOCK,-1,,<empty>,3,,331,1,,void
44847,BLOCK,4,,"{
    head_->SetNext(i, NULL);
  }",40,,331,4,,void
44858,BLOCK,-1,,"{
  // TODO(opt): We can use a barrier-free variant of FindGreaterOrEqual()
  // here since Insert() is externally synchronized.
  Node* prev[kMaxHeight];
  Node* x = FindGreaterOrEqual(key, prev);

  // Our data structure does not allow duplicate insertion
  assert(x == NULL || !Equal(key, x->key));

  int height = RandomHeight();
  if (height > GetMaxHeight()) {
    for (int i = GetMaxHeight(); i < height; i++) {
      prev[i] = head_;
    }
    //fprintf(stderr, ""Change height from %d to %d\n"", max_height_, height);

    // It is ok to mutate max_height_ without any synchronization
    // with concurrent readers.  A concurrent reader that observes
    // the new value of max_height_ will see either the old value of
    // new level pointers from head_ (NULL), or a new value set in
    // the loop below.  In the former case the reader will
    // immediately drop to the next level since NULL sorts after all
    // keys.  In the latter case the reader will use the new node.
    max...",55,,337,2,,void
44885,BLOCK,-1,,"{
    for (int i = GetMaxHeight(); i < height; i++) {
      prev[i] = head_;
    }
    //fprintf(stderr, ""Change height from %d to %d\n"", max_height_, height);

    // It is ok to mutate max_height_ without any synchronization
    // with concurrent readers.  A concurrent reader that observes
    // the new value of max_height_ will see either the old value of
    // new level pointers from head_ (NULL), or a new value set in
    // the loop below.  In the former case the reader will
    // immediately drop to the next level since NULL sorts after all
    // keys.  In the latter case the reader will use the new node.
    max_height_.NoBarrier_Store(reinterpret_cast<void*>(height));
  }",32,,347,2,,void
44887,BLOCK,-1,,<empty>,5,,348,1,,void
44897,BLOCK,4,,"{
      prev[i] = head_;
    }",51,,348,4,,void
44916,BLOCK,-1,,<empty>,3,,364,1,,void
44926,BLOCK,4,,"{
    // NoBarrier_SetNext() suffices since we will add a barrier when
    // we publish a pointer to ""x"" in prev[i].
    x->NoBarrier_SetNext(i, prev[i]->NoBarrier_Next(i));
    prev[i]->SetNext(i, x);
  }",36,,364,4,,void
44951,BLOCK,-1,,"{
  Node* x = FindGreaterOrEqual(key, NULL);
  if (x != NULL && Equal(key, x->key)) {
    return true;
  } else {
    return false;
  }
}",63,,373,2,,void
44968,BLOCK,-1,,"{
    return true;
  }",40,,375,2,,void
44972,BLOCK,-1,,"{
    return false;
  }",10,,377,1,,void
44995,BLOCK,-1,,<empty>,1,,1,1,,ANY
45002,BLOCK,-1,,"{
    if (a < b) {
      return -1;
    } else if (a > b) {
      return +1;
    } else {
      return 0;
    }
  }",52,,18,3,,void
45007,BLOCK,-1,,"{
      return -1;
    }",16,,19,2,,void
45012,BLOCK,-1,,<empty>,12,,21,1,,void
45017,BLOCK,-1,,"{
      return +1;
    }",23,,21,2,,void
45022,BLOCK,-1,,"{
      return 0;
    }",12,,23,1,,void
45030,BLOCK,-1,,<empty>,,,,1,,<empty>
45034,BLOCK,-1,,"TEST(SkipTest, Empty)",1,,31,1,,void
45058,BLOCK,-1,,"{
  Arena arena;
  Comparator cmp;
  SkipList<Key, Comparator> list(cmp, &arena);
  ASSERT_TRUE(!list.Contains(10));

  SkipList<Key, Comparator>::Iterator iter(&list);
  ASSERT_TRUE(!iter.Valid());
  iter.SeekToFirst();
  ASSERT_TRUE(!iter.Valid());
  iter.Seek(100);
  ASSERT_TRUE(!iter.Valid());
  iter.SeekToLast();
  ASSERT_TRUE(!iter.Valid());
}",23,,31,1,,void
45073,BLOCK,1,,<empty>,,,,3,,void
45102,BLOCK,1,,<empty>,,,,3,,void
45130,BLOCK,1,,<empty>,,,,3,,void
45159,BLOCK,1,,<empty>,,,,3,,void
45187,BLOCK,1,,<empty>,,,,3,,void
45209,BLOCK,-1,,<empty>,,,,1,,<empty>
45213,BLOCK,-1,,"TEST(SkipTest, InsertAndLookup)",1,,47,1,,void
45237,BLOCK,-1,,"{
  const int N = 2000;
  const int R = 5000;
  Random rnd(1000);
  std::set<Key> keys;
  Arena arena;
  Comparator cmp;
  SkipList<Key, Comparator> list(cmp, &arena);
  for (int i = 0; i < N; i++) {
    Key key = rnd.Next() % R;
    if (keys.insert(key).second) {
      list.Insert(key);
    }
  }

  for (int i = 0; i < R; i++) {
    if (list.Contains(i)) {
      ASSERT_EQ(keys.count(i), 1);
    } else {
      ASSERT_EQ(keys.count(i), 0);
    }
  }

  // Simple iterator tests
  {
    SkipList<Key, Comparator>::Iterator iter(&list);
    ASSERT_TRUE(!iter.Valid());

    iter.Seek(0);
    ASSERT_TRUE(iter.Valid());
    ASSERT_EQ(*(keys.begin()), iter.key());

    iter.SeekToFirst();
    ASSERT_TRUE(iter.Valid());
    ASSERT_EQ(*(keys.begin()), iter.key());

    iter.SeekToLast();
    ASSERT_TRUE(iter.Valid());
    ASSERT_EQ(*(keys.rbegin()), iter.key());
  }

  // Forward iteration test
  for (int i = 0; i < R; i++) {
    SkipList<Key, Comparator>::Iterator iter(&list);
    iter.Seek(i...",33,,47,1,,void
45258,BLOCK,-1,,<empty>,3,,55,1,,void
45268,BLOCK,4,,"{
    Key key = rnd.Next() % R;
    if (keys.insert(key).second) {
      list.Insert(key);
    }
  }",31,,55,4,,void
45286,BLOCK,-1,,"{
      list.Insert(key);
    }",34,,57,2,,void
45293,BLOCK,-1,,<empty>,3,,62,1,,void
45303,BLOCK,4,,"{
    if (list.Contains(i)) {
      ASSERT_EQ(keys.count(i), 1);
    } else {
      ASSERT_EQ(keys.count(i), 0);
    }
  }",31,,62,4,,void
45310,BLOCK,-1,,"{
      ASSERT_EQ(keys.count(i), 1);
    }",27,,63,2,,void
45318,BLOCK,1,,<empty>,,,,4,,void
45337,BLOCK,-1,,"{
      ASSERT_EQ(keys.count(i), 0);
    }",12,,65,1,,void
45345,BLOCK,1,,<empty>,,,,4,,void
45363,BLOCK,14,,"{
    SkipList<Key, Comparator>::Iterator iter(&list);
    ASSERT_TRUE(!iter.Valid());

    iter.Seek(0);
    ASSERT_TRUE(iter.Valid());
    ASSERT_EQ(*(keys.begin()), iter.key());

    iter.SeekToFirst();
    ASSERT_TRUE(iter.Valid());
    ASSERT_EQ(*(keys.begin()), iter.key());

    iter.SeekToLast();
    ASSERT_TRUE(iter.Valid());
    ASSERT_EQ(*(keys.rbegin()), iter.key());
  }",3,,71,14,,void
45374,BLOCK,1,,<empty>,,,,3,,void
45402,BLOCK,1,,<empty>,,,,3,,void
45429,BLOCK,1,,<empty>,,,,5,,void
45459,BLOCK,1,,<empty>,,,,3,,void
45486,BLOCK,1,,<empty>,,,,5,,void
45516,BLOCK,1,,<empty>,,,,3,,void
45543,BLOCK,1,,<empty>,,,,5,,void
45565,BLOCK,-1,,<empty>,3,,89,1,,void
45575,BLOCK,4,,"{
    SkipList<Key, Comparator>::Iterator iter(&list);
    iter.Seek(i);

    // Compare against model iterator
    std::set<Key>::iterator model_iter = keys.lower_bound(i);
    for (int j = 0; j < 3; j++) {
      if (model_iter == keys.end()) {
        ASSERT_TRUE(!iter.Valid());
        break;
      } else {
        ASSERT_TRUE(iter.Valid());
        ASSERT_EQ(*model_iter, iter.key());
        ++model_iter;
        iter.Next();
      }
    }
  }",31,,89,4,,void
45594,BLOCK,-1,,<empty>,5,,95,1,,void
45604,BLOCK,4,,"{
      if (model_iter == keys.end()) {
        ASSERT_TRUE(!iter.Valid());
        break;
      } else {
        ASSERT_TRUE(iter.Valid());
        ASSERT_EQ(*model_iter, iter.key());
        ++model_iter;
        iter.Next();
      }
    }",33,,95,4,,void
45612,BLOCK,-1,,"{
        ASSERT_TRUE(!iter.Valid());
        break;
      }",37,,96,2,,void
45619,BLOCK,1,,<empty>,,,,3,,void
45639,BLOCK,-1,,"{
        ASSERT_TRUE(iter.Valid());
        ASSERT_EQ(*model_iter, iter.key());
        ++model_iter;
        iter.Next();
      }",14,,99,1,,void
45645,BLOCK,1,,<empty>,,,,3,,void
45669,BLOCK,1,,<empty>,,,,5,,void
45693,BLOCK,16,,"{
    SkipList<Key, Comparator>::Iterator iter(&list);
    iter.SeekToLast();

    // Compare against model iterator
    for (std::set<Key>::reverse_iterator model_iter = keys.rbegin();
         model_iter != keys.rend();
         ++model_iter) {
      ASSERT_TRUE(iter.Valid());
      ASSERT_EQ(*model_iter, iter.key());
      iter.Prev();
    }
    ASSERT_TRUE(!iter.Valid());
  }",3,,109,16,,void
45703,BLOCK,-1,,<empty>,5,,114,1,,void
45719,BLOCK,4,,"{
      ASSERT_TRUE(iter.Valid());
      ASSERT_EQ(*model_iter, iter.key());
      iter.Prev();
    }",24,,116,4,,void
45725,BLOCK,1,,<empty>,,,,3,,void
45749,BLOCK,1,,<empty>,,,,4,,void
45777,BLOCK,1,,<empty>,,,,3,,void
45801,BLOCK,-1,,{ return (key >> 40); },32,,153,2,,void
45810,BLOCK,-1,,{ return (key >> 8) & 0xffffffffu; },32,,154,2,,void
45821,BLOCK,-1,,{ return key & 0xff; },33,,155,2,,void
45831,BLOCK,-1,,"{
    uint64_t data[2] = { k, g };
    return Hash(reinterpret_cast<char*>(data), sizeof(data), 0);
  }",55,,157,3,,void
45851,BLOCK,-1,,"{
    assert(sizeof(Key) == sizeof(uint64_t));
    assert(k <= K);  // We sometimes pass K to seek to the end of the skiplist
    assert(g <= 0xffffffffu);
    return ((k << 40) | (g << 8) | (HashNumbers(k, g) & 0xff));
  }",46,,162,3,,void
45884,BLOCK,-1,,"{
    return hash(k) == (HashNumbers(key(k), gen(k)) & 0xff);
  }",33,,169,2,,void
45900,BLOCK,-1,,"{
    switch (rnd->Next() % 10) {
      case 0:
        // Seek to beginning
        return MakeKey(0, 0);
      case 1:
        // Seek to end
        return MakeKey(K, 0);
      default:
        // Seek to middle
        return MakeKey(rnd->Next() % K, 0);
    }
  }",40,,173,2,,void
45908,BLOCK,-1,,"{
      case 0:
        // Seek to beginning
        return MakeKey(0, 0);
      case 1:
        // Seek to end
        return MakeKey(K, 0);
      default:
        // Seek to middle
        return MakeKey(rnd->Next() % K, 0);
    }",31,,174,2,,void
45938,BLOCK,-1,,"{
      generation[k].Release_Store(reinterpret_cast<void*>(v));
    }",33,,190,3,,void
45952,BLOCK,-1,,"{
      return reinterpret_cast<intptr_t>(generation[k].Acquire_Load());
    }",25,,193,2,,void
45965,BLOCK,-1,,"{
      for (int k = 0; k < K; k++) {
        Set(k, 0);
      }
    }",13,,197,1,,void
45967,BLOCK,-1,,<empty>,7,,198,1,,void
45977,BLOCK,4,,"{
        Set(k, 0);
      }",35,,198,4,,void
45984,BLOCK,-1,,<empty>,,,,1,,<empty>
45993,BLOCK,-1,,{ },51,,214,1,,void
45998,BLOCK,-1,,"{
    const uint32_t k = rnd->Next() % K;
    const intptr_t g = current_.Get(k) + 1;
    const Key key = MakeKey(k, g);
    list_.Insert(key);
    current_.Set(k, g);
  }",31,,217,2,,void
46039,BLOCK,-1,,"{
    // Remember the initial committed state of the skiplist.
    State initial_state;
    for (int k = 0; k < K; k++) {
      initial_state.Set(k, current_.Get(k));
    }

    Key pos = RandomTarget(rnd);
    SkipList<Key, Comparator>::Iterator iter(&list_);
    iter.Seek(pos);
    while (true) {
      Key current;
      if (!iter.Valid()) {
        current = MakeKey(K, 0);
      } else {
        current = iter.key();
        ASSERT_TRUE(IsValidKey(current)) << current;
      }
      ASSERT_LE(pos, current) << ""should not go backwards"";

      // Verify that everything in [pos,current) was not present in
      // initial_state.
      while (pos < current) {
        ASSERT_LT(key(pos), K) << pos;

        // Note that generation 0 is never inserted, so it is ok if
        // <*,0,*> is missing.
        ASSERT_TRUE((gen(pos) == 0) ||
                    (gen(pos) > static_cast<Key>(initial_state.Get(key(pos))))
                    ) << ""key: "" << key(pos)
                      << "";...",30,,225,2,,void
46042,BLOCK,-1,,<empty>,5,,228,1,,void
46052,BLOCK,4,,"{
      initial_state.Set(k, current_.Get(k));
    }",33,,228,4,,void
46079,BLOCK,-1,,"{
      Key current;
      if (!iter.Valid()) {
        current = MakeKey(K, 0);
      } else {
        current = iter.key();
        ASSERT_TRUE(IsValidKey(current)) << current;
      }
      ASSERT_LE(pos, current) << ""should not go backwards"";

      // Verify that everything in [pos,current) was not present in
      // initial_state.
      while (pos < current) {
        ASSERT_LT(key(pos), K) << pos;

        // Note that generation 0 is never inserted, so it is ok if
        // <*,0,*> is missing.
        ASSERT_TRUE((gen(pos) == 0) ||
                    (gen(pos) > static_cast<Key>(initial_state.Get(key(pos))))
                    ) << ""key: "" << key(pos)
                      << ""; gen: "" << gen(pos)
                      << ""; initgen: ""
                      << initial_state.Get(key(pos));

        // Advance to next key in the valid key space
        if (key(pos) < key(current)) {
          pos = MakeKey(key(pos) + 1, 0);
        } else {
          pos = MakeKey(key(pos)...",18,,235,2,,void
46087,BLOCK,-1,,"{
        current = MakeKey(K, 0);
      }",26,,237,2,,void
46094,BLOCK,-1,,"{
        current = iter.key();
        ASSERT_TRUE(IsValidKey(current)) << current;
      }",14,,239,1,,void
46105,BLOCK,1,,<empty>,,,,3,,void
46125,BLOCK,1,,<empty>,,,,5,,void
46144,BLOCK,-1,,"{
        ASSERT_LT(key(pos), K) << pos;

        // Note that generation 0 is never inserted, so it is ok if
        // <*,0,*> is missing.
        ASSERT_TRUE((gen(pos) == 0) ||
                    (gen(pos) > static_cast<Key>(initial_state.Get(key(pos))))
                    ) << ""key: "" << key(pos)
                      << ""; gen: "" << gen(pos)
                      << ""; initgen: ""
                      << initial_state.Get(key(pos));

        // Advance to next key in the valid key space
        if (key(pos) < key(current)) {
          pos = MakeKey(key(pos) + 1, 0);
        } else {
          pos = MakeKey(key(pos), gen(pos) + 1);
        }
      }",29,,247,2,,void
46150,BLOCK,1,,<empty>,,,,4,,void
46173,BLOCK,1,,<empty>,,,,5,,void
46221,BLOCK,-1,,"{
          pos = MakeKey(key(pos) + 1, 0);
        }",38,,260,2,,void
46231,BLOCK,-1,,"{
          pos = MakeKey(key(pos), gen(pos) + 1);
        }",16,,262,1,,void
46247,BLOCK,-1,,"{
        break;
      }",26,,267,2,,void
46256,BLOCK,-1,,"{
        iter.Next();
        pos = MakeKey(key(pos), gen(pos) + 1);
      }",28,,271,2,,void
46271,BLOCK,-1,,"{
        Key new_target = RandomTarget(rnd);
        if (new_target > pos) {
          pos = new_target;
          iter.Seek(new_target);
        }
      }",14,,274,1,,void
46281,BLOCK,-1,,"{
          pos = new_target;
          iter.Seek(new_target);
        }",31,,276,2,,void
46293,BLOCK,-1,,<empty>,,,,1,,<empty>
46302,BLOCK,-1,,<empty>,,,,1,,<empty>
46306,BLOCK,-1,,"TEST(SkipTest, ConcurrentWithoutThreads)",1,,288,1,,void
46330,BLOCK,-1,,"{
  ConcurrentTest test;
  Random rnd(test::RandomSeed());
  for (int i = 0; i < 10000; i++) {
    test.ReadStep(&rnd);
    test.WriteStep(&rnd);
  }
}",42,,288,1,,void
46339,BLOCK,-1,,<empty>,3,,291,1,,void
46349,BLOCK,4,,"{
    test.ReadStep(&rnd);
    test.WriteStep(&rnd);
  }",35,,291,4,,void
46374,BLOCK,-1,,<empty>,25,,313,2,,void
46379,BLOCK,-1,,"{
    mu_.Lock();
    while (state_ != s) {
      state_cv_.Wait();
    }
    mu_.Unlock();
  }",28,,315,2,,void
46388,BLOCK,-1,,"{
      state_cv_.Wait();
    }",25,,317,2,,void
46401,BLOCK,-1,,"{
    mu_.Lock();
    state_ = s;
    state_cv_.Signal();
    mu_.Unlock();
  }",30,,323,2,,void
46424,BLOCK,-1,,"{
  TestState* state = reinterpret_cast<TestState*>(arg);
  Random rnd(state->seed_);
  int64_t reads = 0;
  state->Change(TestState::RUNNING);
  while (!state->quit_flag_.Acquire_Load()) {
    state->t_.ReadStep(&rnd);
    ++reads;
  }
  state->Change(TestState::DONE);
}",41,,336,2,,void
46455,BLOCK,-1,,"{
    state->t_.ReadStep(&rnd);
    ++reads;
  }",45,,341,2,,void
46477,BLOCK,-1,,"{
  const int seed = test::RandomSeed() + (run * 100);
  Random rnd(seed);
  const int N = 1000;
  const int kSize = 1000;
  for (int i = 0; i < N; i++) {
    if ((i % 100) == 0) {
      fprintf(stderr, ""Run %d of %d\n"", i, N);
    }
    TestState state(seed + 1);
    Env::Default()->Schedule(ConcurrentReader, &state);
    state.Wait(TestState::RUNNING);
    for (int i = 0; i < kSize; i++) {
      state.t_.WriteStep(&rnd);
    }
    state.quit_flag_.Release_Store(&state);  // Any non-NULL arg will do
    state.Wait(TestState::DONE);
  }
}",36,,348,2,,void
46501,BLOCK,-1,,<empty>,3,,353,1,,void
46511,BLOCK,4,,"{
    if ((i % 100) == 0) {
      fprintf(stderr, ""Run %d of %d\n"", i, N);
    }
    TestState state(seed + 1);
    Env::Default()->Schedule(ConcurrentReader, &state);
    state.Wait(TestState::RUNNING);
    for (int i = 0; i < kSize; i++) {
      state.t_.WriteStep(&rnd);
    }
    state.quit_flag_.Release_Store(&state);  // Any non-NULL arg will do
    state.Wait(TestState::DONE);
  }",31,,353,4,,void
46518,BLOCK,-1,,"{
      fprintf(stderr, ""Run %d of %d\n"", i, N);
    }",25,,354,2,,void
46547,BLOCK,-1,,<empty>,5,,360,1,,void
46557,BLOCK,4,,"{
      state.t_.WriteStep(&rnd);
    }",37,,360,4,,void
46585,BLOCK,-1,,<empty>,,,,1,,<empty>
46589,BLOCK,-1,,"TEST(SkipTest, Concurrent1)",1,,368,1,,void
46613,BLOCK,-1,,{ RunConcurrent(1); },29,,368,1,,void
46620,BLOCK,-1,,<empty>,,,,1,,<empty>
46624,BLOCK,-1,,"TEST(SkipTest, Concurrent2)",1,,369,1,,void
46648,BLOCK,-1,,{ RunConcurrent(2); },29,,369,1,,void
46655,BLOCK,-1,,<empty>,,,,1,,<empty>
46659,BLOCK,-1,,"TEST(SkipTest, Concurrent3)",1,,370,1,,void
46683,BLOCK,-1,,{ RunConcurrent(3); },29,,370,1,,void
46690,BLOCK,-1,,<empty>,,,,1,,<empty>
46694,BLOCK,-1,,"TEST(SkipTest, Concurrent4)",1,,371,1,,void
46718,BLOCK,-1,,{ RunConcurrent(4); },29,,371,1,,void
46725,BLOCK,-1,,<empty>,,,,1,,<empty>
46729,BLOCK,-1,,"TEST(SkipTest, Concurrent5)",1,,372,1,,void
46753,BLOCK,-1,,{ RunConcurrent(5); },29,,372,1,,void
46761,BLOCK,-1,,"{
  return leveldb::test::RunAllTests();
}",33,,376,3,,void
46779,BLOCK,-1,,<empty>,1,,1,1,,ANY
46790,BLOCK,-1,,"{
    list_.prev_ = &list_;
    list_.next_ = &list_;
  }",18,,33,1,,void
46806,BLOCK,-1,,{ return list_.next_ == &list_; },22,,38,1,,void
46817,BLOCK,-1,,{ assert(!empty()); return list_.next_; },32,,39,1,,void
46828,BLOCK,-1,,{ assert(!empty()); return list_.prev_; },32,,40,1,,void
46840,BLOCK,-1,,"{
    SnapshotImpl* s = new SnapshotImpl;
    s->number_ = seq;
    s->list_ = this;
    s->next_ = &list_;
    s->prev_ = list_.prev_;
    s->prev_->next_ = s;
    s->next_->prev_ = s;
    return s;
  }",47,,42,2,,void
46889,BLOCK,-1,,"{
    assert(s->list_ == this);
    s->prev_->next_ = s->next_;
    s->next_->prev_ = s->prev_;
    delete s;
  }",38,,53,2,,void
46933,BLOCK,-1,,<empty>,1,,1,1,,ANY
46941,BLOCK,-1,,"{
  TableAndFile* tf = reinterpret_cast<TableAndFile*>(value);
  delete tf->table;
  delete tf->file;
  delete tf;
}",56,,19,3,,void
46963,BLOCK,-1,,"{
  Cache* cache = reinterpret_cast<Cache*>(arg1);
  Cache::Handle* h = reinterpret_cast<Cache::Handle*>(arg2);
  cache->Release(h);
}",48,,26,3,,void
46987,BLOCK,-1,,"{
}",36,,38,4,,void
46991,BLOCK,-1,,"{
  delete cache_;
}",27,,41,1,,void
47000,BLOCK,-1,,"{
  Status s;
  char buf[sizeof(file_number)];
  EncodeFixed64(buf, file_number);
  Slice key(buf, sizeof(buf));
  *handle = cache_->Lookup(key);
  if (*handle == NULL) {
    std::string fname = TableFileName(dbname_, file_number);
    RandomAccessFile* file = NULL;
    Table* table = NULL;
    s = env_->NewRandomAccessFile(fname, &file);
    if (!s.ok()) {
      std::string old_fname = SSTTableFileName(dbname_, file_number);
      if (env_->NewRandomAccessFile(old_fname, &file).ok()) {
        s = Status::OK();
      }
    }
    if (s.ok()) {
      s = Table::Open(*options_, file, file_size, &table);
    }

    if (!s.ok()) {
      assert(table == NULL);
      delete file;
      // We do not cache error results so that if the error is transient,
      // or somebody repairs the file, we recover automatically.
    } else {
      TableAndFile* tf = new TableAndFile;
      tf->file = file;
      tf->table = table;
      *handle = cache_->Insert(key, tf, 1, &DeleteEntry);
    }
  }
  r...",54,,46,4,,void
47024,BLOCK,-1,,"{
    std::string fname = TableFileName(dbname_, file_number);
    RandomAccessFile* file = NULL;
    Table* table = NULL;
    s = env_->NewRandomAccessFile(fname, &file);
    if (!s.ok()) {
      std::string old_fname = SSTTableFileName(dbname_, file_number);
      if (env_->NewRandomAccessFile(old_fname, &file).ok()) {
        s = Status::OK();
      }
    }
    if (s.ok()) {
      s = Table::Open(*options_, file, file_size, &table);
    }

    if (!s.ok()) {
      assert(table == NULL);
      delete file;
      // We do not cache error results so that if the error is transient,
      // or somebody repairs the file, we recover automatically.
    } else {
      TableAndFile* tf = new TableAndFile;
      tf->file = file;
      tf->table = table;
      *handle = cache_->Insert(key, tf, 1, &DeleteEntry);
    }
  }",24,,52,2,,void
47054,BLOCK,-1,,"{
      std::string old_fname = SSTTableFileName(dbname_, file_number);
      if (env_->NewRandomAccessFile(old_fname, &file).ok()) {
        s = Status::OK();
      }
    }",18,,57,2,,void
47072,BLOCK,-1,,"{
        s = Status::OK();
      }",61,,59,2,,void
47084,BLOCK,-1,,"{
      s = Table::Open(*options_, file, file_size, &table);
    }",17,,63,2,,void
47103,BLOCK,-1,,"{
      assert(table == NULL);
      delete file;
      // We do not cache error results so that if the error is transient,
      // or somebody repairs the file, we recover automatically.
    }",18,,67,2,,void
47111,BLOCK,-1,,"{
      TableAndFile* tf = new TableAndFile;
      tf->file = file;
      tf->table = table;
      *handle = cache_->Insert(key, tf, 1, &DeleteEntry);
    }",12,,72,1,,void
47148,BLOCK,-1,,"{
  if (tableptr != NULL) {
    *tableptr = NULL;
  }

  Cache::Handle* handle = NULL;
  Status s = FindTable(file_number, file_size, &handle);
  if (!s.ok()) {
    return NewErrorIterator(s);
  }

  Table* table = reinterpret_cast<TableAndFile*>(cache_->Value(handle))->table;
  Iterator* result = table->NewIterator(options);
  result->RegisterCleanup(&UnrefEntry, cache_, handle);
  if (tableptr != NULL) {
    *tableptr = table;
  }
  return result;
}",53,,85,5,,void
47153,BLOCK,-1,,"{
    *tableptr = NULL;
  }",25,,86,2,,void
47176,BLOCK,-1,,"{
    return NewErrorIterator(s);
  }",16,,92,2,,void
47212,BLOCK,-1,,"{
    *tableptr = table;
  }",25,,99,2,,void
47228,BLOCK,-1,,"{
  Cache::Handle* handle = NULL;
  Status s = FindTable(file_number, file_size, &handle);
  if (s.ok()) {
    Table* t = reinterpret_cast<TableAndFile*>(cache_->Value(handle))->table;
    s = t->InternalGet(options, k, arg, saver);
    cache_->Release(handle);
  }
  return s;
}",74,,110,7,,void
47246,BLOCK,-1,,"{
    Table* t = reinterpret_cast<TableAndFile*>(cache_->Value(handle))->table;
    s = t->InternalGet(options, k, arg, saver);
    cache_->Release(handle);
  }",15,,113,2,,void
47280,BLOCK,-1,,"{
  char buf[sizeof(file_number)];
  EncodeFixed64(buf, file_number);
  cache_->Erase(Slice(buf, sizeof(buf)));
}",46,,121,2,,void
47311,BLOCK,-1,,<empty>,1,,1,1,,ANY
47319,BLOCK,-1,,<empty>,,,,4,,<empty>
47323,BLOCK,-1,,<empty>,,,,1,,<empty>
47331,BLOCK,-1,,<empty>,,,,5,,<empty>
47341,BLOCK,-1,,<empty>,,,,7,,<empty>
47346,BLOCK,-1,,<empty>,,,,2,,<empty>
47357,BLOCK,-1,,<empty>,,,,4,,<empty>
47370,BLOCK,-1,,<empty>,1,,1,1,,ANY
47382,BLOCK,-1,,<empty>,,,,1,,<empty>
47410,BLOCK,-1,,"{
  comparator_.clear();
  log_number_ = 0;
  prev_log_number_ = 0;
  last_sequence_ = 0;
  next_file_number_ = 0;
  has_comparator_ = false;
  has_log_number_ = false;
  has_prev_log_number_ = false;
  has_next_file_number_ = false;
  has_last_sequence_ = false;
  deleted_files_.clear();
  new_files_.clear();
}",27,,26,1,,void
47454,BLOCK,-1,,"{
  if (has_comparator_) {
    PutVarint32(dst, kComparator);
    PutLengthPrefixedSlice(dst, comparator_);
  }
  if (has_log_number_) {
    PutVarint32(dst, kLogNumber);
    PutVarint64(dst, log_number_);
  }
  if (has_prev_log_number_) {
    PutVarint32(dst, kPrevLogNumber);
    PutVarint64(dst, prev_log_number_);
  }
  if (has_next_file_number_) {
    PutVarint32(dst, kNextFileNumber);
    PutVarint64(dst, next_file_number_);
  }
  if (has_last_sequence_) {
    PutVarint32(dst, kLastSequence);
    PutVarint64(dst, last_sequence_);
  }

  for (size_t i = 0; i < compact_pointers_.size(); i++) {
    PutVarint32(dst, kCompactPointer);
    PutVarint32(dst, compact_pointers_[i].first);  // level
    PutLengthPrefixedSlice(dst, compact_pointers_[i].second.Encode());
  }

  for (DeletedFileSet::const_iterator iter = deleted_files_.begin();
       iter != deleted_files_.end();
       ++iter) {
    PutVarint32(dst, kDeletedFile);
    PutVarint32(dst, iter->first);   // level
    PutVarint6...",52,,41,2,,void
47457,BLOCK,-1,,"{
    PutVarint32(dst, kComparator);
    PutLengthPrefixedSlice(dst, comparator_);
  }",24,,42,2,,void
47466,BLOCK,-1,,"{
    PutVarint32(dst, kLogNumber);
    PutVarint64(dst, log_number_);
  }",24,,46,2,,void
47475,BLOCK,-1,,"{
    PutVarint32(dst, kPrevLogNumber);
    PutVarint64(dst, prev_log_number_);
  }",29,,50,2,,void
47484,BLOCK,-1,,"{
    PutVarint32(dst, kNextFileNumber);
    PutVarint64(dst, next_file_number_);
  }",30,,54,2,,void
47493,BLOCK,-1,,"{
    PutVarint32(dst, kLastSequence);
    PutVarint64(dst, last_sequence_);
  }",27,,58,2,,void
47501,BLOCK,-1,,<empty>,3,,63,1,,void
47514,BLOCK,4,,"{
    PutVarint32(dst, kCompactPointer);
    PutVarint32(dst, compact_pointers_[i].first);  // level
    PutLengthPrefixedSlice(dst, compact_pointers_[i].second.Encode());
  }",57,,63,4,,void
47536,BLOCK,-1,,<empty>,3,,69,1,,void
47552,BLOCK,4,,"{
    PutVarint32(dst, kDeletedFile);
    PutVarint32(dst, iter->first);   // level
    PutVarint64(dst, iter->second);  // file number
  }",16,,71,4,,void
47567,BLOCK,-1,,<empty>,3,,77,1,,void
47580,BLOCK,4,,"{
    const FileMetaData& f = new_files_[i].second;
    PutVarint32(dst, kNewFile);
    PutVarint32(dst, new_files_[i].first);  // level
    PutVarint64(dst, f.number);
    PutVarint64(dst, f.file_size);
    PutLengthPrefixedSlice(dst, f.smallest.Encode());
    PutLengthPrefixedSlice(dst, f.largest.Encode());
  }",50,,77,4,,void
47630,BLOCK,-1,,"{
  Slice str;
  if (GetLengthPrefixedSlice(input, &str)) {
    dst->DecodeFrom(str);
    return true;
  } else {
    return false;
  }
}",60,,88,3,,void
47637,BLOCK,-1,,"{
    dst->DecodeFrom(str);
    return true;
  }",44,,90,2,,void
47646,BLOCK,-1,,"{
    return false;
  }",10,,93,1,,void
47654,BLOCK,-1,,"{
  uint32_t v;
  if (GetVarint32(input, &v) &&
      v < config::kNumLevels) {
    *level = v;
    return true;
  } else {
    return false;
  }
}",48,,98,3,,void
47667,BLOCK,-1,,"{
    *level = v;
    return true;
  }",31,,101,2,,void
47675,BLOCK,-1,,"{
    return false;
  }",10,,104,1,,void
47682,BLOCK,-1,,"{
  Clear();
  Slice input = src;
  const char* msg = NULL;
  uint32_t tag;

  // Temporary storage for parsing
  int level;
  uint64_t number;
  FileMetaData f;
  Slice str;
  InternalKey key;

  while (msg == NULL && GetVarint32(&input, &tag)) {
    switch (tag) {
      case kComparator:
        if (GetLengthPrefixedSlice(&input, &str)) {
          comparator_ = str.ToString();
          has_comparator_ = true;
        } else {
          msg = ""comparator name"";
        }
        break;

      case kLogNumber:
        if (GetVarint64(&input, &log_number_)) {
          has_log_number_ = true;
        } else {
          msg = ""log number"";
        }
        break;

      case kPrevLogNumber:
        if (GetVarint64(&input, &prev_log_number_)) {
          has_prev_log_number_ = true;
        } else {
          msg = ""previous log number"";
        }
        break;

      case kNextFileNumber:
        if (GetVarint64(&input, &next_file_number_)) {
          has_next_file_number_ = true...",50,,109,2,,void
47708,BLOCK,-1,,"{
    switch (tag) {
      case kComparator:
        if (GetLengthPrefixedSlice(&input, &str)) {
          comparator_ = str.ToString();
          has_comparator_ = true;
        } else {
          msg = ""comparator name"";
        }
        break;

      case kLogNumber:
        if (GetVarint64(&input, &log_number_)) {
          has_log_number_ = true;
        } else {
          msg = ""log number"";
        }
        break;

      case kPrevLogNumber:
        if (GetVarint64(&input, &prev_log_number_)) {
          has_prev_log_number_ = true;
        } else {
          msg = ""previous log number"";
        }
        break;

      case kNextFileNumber:
        if (GetVarint64(&input, &next_file_number_)) {
          has_next_file_number_ = true;
        } else {
          msg = ""next file number"";
        }
        break;

      case kLastSequence:
        if (GetVarint64(&input, &last_sequence_)) {
          has_last_sequence_ = true;
        } else {
          msg = ""last sequence nu...",52,,122,2,,void
47711,BLOCK,-1,,"{
      case kComparator:
        if (GetLengthPrefixedSlice(&input, &str)) {
          comparator_ = str.ToString();
          has_comparator_ = true;
        } else {
          msg = ""comparator name"";
        }
        break;

      case kLogNumber:
        if (GetVarint64(&input, &log_number_)) {
          has_log_number_ = true;
        } else {
          msg = ""log number"";
        }
        break;

      case kPrevLogNumber:
        if (GetVarint64(&input, &prev_log_number_)) {
          has_prev_log_number_ = true;
        } else {
          msg = ""previous log number"";
        }
        break;

      case kNextFileNumber:
        if (GetVarint64(&input, &next_file_number_)) {
          has_next_file_number_ = true;
        } else {
          msg = ""next file number"";
        }
        break;

      case kLastSequence:
        if (GetVarint64(&input, &last_sequence_)) {
          has_last_sequence_ = true;
        } else {
          msg = ""last sequence number"";
        }
  ...",18,,123,2,,void
47720,BLOCK,-1,,"{
          comparator_ = str.ToString();
          has_comparator_ = true;
        }",51,,125,2,,void
47731,BLOCK,-1,,"{
          msg = ""comparator name"";
        }",16,,128,1,,void
47744,BLOCK,-1,,"{
          has_log_number_ = true;
        }",48,,134,2,,void
47749,BLOCK,-1,,"{
          msg = ""log number"";
        }",16,,136,1,,void
47762,BLOCK,-1,,"{
          has_prev_log_number_ = true;
        }",53,,142,2,,void
47767,BLOCK,-1,,"{
          msg = ""previous log number"";
        }",16,,144,1,,void
47780,BLOCK,-1,,"{
          has_next_file_number_ = true;
        }",54,,150,2,,void
47785,BLOCK,-1,,"{
          msg = ""next file number"";
        }",16,,152,1,,void
47798,BLOCK,-1,,"{
          has_last_sequence_ = true;
        }",51,,158,2,,void
47803,BLOCK,-1,,"{
          msg = ""last sequence number"";
        }",16,,160,1,,void
47822,BLOCK,-1,,"{
          compact_pointers_.push_back(std::make_pair(level, key));
        }",43,,167,2,,void
47834,BLOCK,-1,,"{
          msg = ""compaction pointer"";
        }",16,,169,1,,void
47853,BLOCK,-1,,"{
          deleted_files_.insert(std::make_pair(level, number));
        }",43,,176,2,,void
47865,BLOCK,-1,,"{
          msg = ""deleted file"";
        }",16,,178,1,,void
47910,BLOCK,-1,,"{
          new_files_.push_back(std::make_pair(level, f));
        }",49,,188,2,,void
47922,BLOCK,-1,,"{
          msg = ""new-file entry"";
        }",16,,190,1,,void
47942,BLOCK,-1,,"{
    msg = ""invalid tag"";
  }",38,,201,2,,void
47951,BLOCK,-1,,"{
    result = Status::Corruption(""VersionEdit"", msg);
  }",20,,206,2,,void
47965,BLOCK,-1,,"{
  std::string r;
  r.append(""VersionEdit {"");
  if (has_comparator_) {
    r.append(""\n  Comparator: "");
    r.append(comparator_);
  }
  if (has_log_number_) {
    r.append(""\n  LogNumber: "");
    AppendNumberTo(&r, log_number_);
  }
  if (has_prev_log_number_) {
    r.append(""\n  PrevLogNumber: "");
    AppendNumberTo(&r, prev_log_number_);
  }
  if (has_next_file_number_) {
    r.append(""\n  NextFile: "");
    AppendNumberTo(&r, next_file_number_);
  }
  if (has_last_sequence_) {
    r.append(""\n  LastSeq: "");
    AppendNumberTo(&r, last_sequence_);
  }
  for (size_t i = 0; i < compact_pointers_.size(); i++) {
    r.append(""\n  CompactPointer: "");
    AppendNumberTo(&r, compact_pointers_[i].first);
    r.append("" "");
    r.append(compact_pointers_[i].second.DebugString());
  }
  for (DeletedFileSet::const_iterator iter = deleted_files_.begin();
       iter != deleted_files_.end();
       ++iter) {
    r.append(""\n  DeleteFile: "");
    AppendNumberTo(&r, iter->first);
    r.append...",46,,212,1,,void
47974,BLOCK,-1,,"{
    r.append(""\n  Comparator: "");
    r.append(comparator_);
  }",24,,215,2,,void
47987,BLOCK,-1,,"{
    r.append(""\n  LogNumber: "");
    AppendNumberTo(&r, log_number_);
  }",24,,219,2,,void
47999,BLOCK,-1,,"{
    r.append(""\n  PrevLogNumber: "");
    AppendNumberTo(&r, prev_log_number_);
  }",29,,223,2,,void
48011,BLOCK,-1,,"{
    r.append(""\n  NextFile: "");
    AppendNumberTo(&r, next_file_number_);
  }",30,,227,2,,void
48023,BLOCK,-1,,"{
    r.append(""\n  LastSeq: "");
    AppendNumberTo(&r, last_sequence_);
  }",27,,231,2,,void
48034,BLOCK,-1,,<empty>,3,,235,1,,void
48047,BLOCK,4,,"{
    r.append(""\n  CompactPointer: "");
    AppendNumberTo(&r, compact_pointers_[i].first);
    r.append("" "");
    r.append(compact_pointers_[i].second.DebugString());
  }",57,,235,4,,void
48079,BLOCK,-1,,<empty>,3,,241,1,,void
48095,BLOCK,4,,"{
    r.append(""\n  DeleteFile: "");
    AppendNumberTo(&r, iter->first);
    r.append("" "");
    AppendNumberTo(&r, iter->second);
  }",16,,243,4,,void
48119,BLOCK,-1,,<empty>,3,,249,1,,void
48132,BLOCK,4,,"{
    const FileMetaData& f = new_files_[i].second;
    r.append(""\n  AddFile: "");
    AppendNumberTo(&r, new_files_[i].first);
    r.append("" "");
    AppendNumberTo(&r, f.number);
    r.append("" "");
    AppendNumberTo(&r, f.file_size);
    r.append("" "");
    r.append(f.smallest.DebugString());
    r.append("" .. "");
    r.append(f.largest.DebugString());
  }",50,,249,4,,void
48227,BLOCK,-1,,<empty>,1,,1,1,,ANY
48238,BLOCK,-1,,{ },66,,25,1,,void
48243,BLOCK,-1,,{ Clear(); },17,,30,1,,void
48248,BLOCK,-1,,{ },18,,31,1,,void
48252,BLOCK,-1,,<empty>,,,,1,,<empty>
48257,BLOCK,-1,,"{
    has_comparator_ = true;
    comparator_ = name.ToString();
  }",45,,35,2,,void
48271,BLOCK,-1,,"{
    has_log_number_ = true;
    log_number_ = num;
  }",35,,39,2,,void
48282,BLOCK,-1,,"{
    has_prev_log_number_ = true;
    prev_log_number_ = num;
  }",39,,43,2,,void
48293,BLOCK,-1,,"{
    has_next_file_number_ = true;
    next_file_number_ = num;
  }",34,,47,2,,void
48304,BLOCK,-1,,"{
    has_last_sequence_ = true;
    last_sequence_ = seq;
  }",44,,51,2,,void
48316,BLOCK,-1,,"{
    compact_pointers_.push_back(std::make_pair(level, key));
  }",61,,55,3,,void
48335,BLOCK,-1,,"{
    FileMetaData f;
    f.number = file;
    f.file_size = file_size;
    f.smallest = smallest;
    f.largest = largest;
    new_files_.push_back(std::make_pair(level, f));
  }",44,,65,6,,void
48372,BLOCK,-1,,"{
    deleted_files_.insert(std::make_pair(level, file));
  }",45,,75,3,,void
48387,BLOCK,-1,,<empty>,,,,2,,<empty>
48392,BLOCK,-1,,<empty>,,,,2,,<empty>
48396,BLOCK,-1,,<empty>,,,,1,,<empty>
48422,BLOCK,-1,,<empty>,1,,1,1,,ANY
48426,BLOCK,-1,,"{
  std::string encoded, encoded2;
  edit.EncodeTo(&encoded);
  VersionEdit parsed;
  Status s = parsed.DecodeFrom(encoded);
  ASSERT_TRUE(s.ok()) << s.ToString();
  parsed.EncodeTo(&encoded2);
  ASSERT_EQ(encoded, encoded2);
}",55,,10,2,,void
48450,BLOCK,1,,<empty>,,,,3,,void
48480,BLOCK,1,,<empty>,,,,5,,void
48499,BLOCK,-1,,<empty>,,,,1,,<empty>
48503,BLOCK,-1,,"TEST(VersionEditTest, EncodeDecode)",1,,22,1,,void
48527,BLOCK,-1,,"{
  static const uint64_t kBig = 1ull << 50;

  VersionEdit edit;
  for (int i = 0; i < 4; i++) {
    TestEncodeDecode(edit);
    edit.AddFile(3, kBig + 300 + i, kBig + 400 + i,
                 InternalKey(""foo"", kBig + 500 + i, kTypeValue),
                 InternalKey(""zoo"", kBig + 600 + i, kTypeDeletion));
    edit.DeleteFile(4, kBig + 700 + i);
    edit.SetCompactPointer(i, InternalKey(""x"", kBig + 900 + i, kTypeValue));
  }

  edit.SetComparatorName(""foo"");
  edit.SetLogNumber(kBig + 100);
  edit.SetNextFile(kBig + 200);
  edit.SetLastSequence(kBig + 1000);
  TestEncodeDecode(edit);
}",37,,22,1,,void
48536,BLOCK,-1,,<empty>,3,,26,1,,void
48546,BLOCK,4,,"{
    TestEncodeDecode(edit);
    edit.AddFile(3, kBig + 300 + i, kBig + 400 + i,
                 InternalKey(""foo"", kBig + 500 + i, kTypeValue),
                 InternalKey(""zoo"", kBig + 600 + i, kTypeDeletion));
    edit.DeleteFile(4, kBig + 700 + i);
    edit.SetCompactPointer(i, InternalKey(""x"", kBig + 900 + i, kTypeValue));
  }",31,,26,4,,void
48636,BLOCK,-1,,"{
  return leveldb::test::RunAllTests();
}",33,,44,3,,void
48678,BLOCK,-1,,<empty>,1,,1,1,,ANY
48682,BLOCK,-1,,"{
  return options->max_file_size;
}",51,,23,2,,void
48691,BLOCK,-1,,"{
  return 10 * TargetFileSize(options);
}",67,,29,2,,void
48701,BLOCK,-1,,"{
  return 25 * TargetFileSize(options);
}",72,,36,2,,void
48712,BLOCK,-1,,"{
  // Note: the result for level zero is not really used since we set
  // the level-0 compaction threshold based on number of files.

  // Result for both level-0 and level-1
  double result = 10. * 1048576.0;
  while (level > 1) {
    result *= 10;
    level--;
  }
  return result;
}",67,,40,3,,void
48723,BLOCK,-1,,"{
    result *= 10;
    level--;
  }",21,,46,2,,void
48736,BLOCK,-1,,"{
  // We could vary per level to reduce number of files?
  return TargetFileSize(options);
}",72,,53,3,,void
48744,BLOCK,-1,,"{
  int64_t sum = 0;
  for (size_t i = 0; i < files.size(); i++) {
    sum += files[i]->file_size;
  }
  return sum;
}",71,,58,2,,void
48750,BLOCK,-1,,<empty>,3,,60,1,,void
48763,BLOCK,4,,"{
    sum += files[i]->file_size;
  }",45,,60,4,,void
48776,BLOCK,-1,,"{
  assert(refs_ == 0);

  // Remove from linked list
  prev_->next_ = next_;
  next_->prev_ = prev_;

  // Drop references to files
  for (int level = 0; level < config::kNumLevels; level++) {
    for (size_t i = 0; i < files_[level].size(); i++) {
      FileMetaData* f = files_[level][i];
      assert(f->refs > 0);
      f->refs--;
      if (f->refs <= 0) {
        delete f;
      }
    }
  }
}",21,,66,1,,void
48792,BLOCK,-1,,<empty>,3,,74,1,,void
48804,BLOCK,4,,"{
    for (size_t i = 0; i < files_[level].size(); i++) {
      FileMetaData* f = files_[level][i];
      assert(f->refs > 0);
      f->refs--;
      if (f->refs <= 0) {
        delete f;
      }
    }
  }",60,,74,4,,void
48806,BLOCK,-1,,<empty>,5,,75,1,,void
48821,BLOCK,4,,"{
      FileMetaData* f = files_[level][i];
      assert(f->refs > 0);
      f->refs--;
      if (f->refs <= 0) {
        delete f;
      }
    }",55,,75,4,,void
48846,BLOCK,-1,,"{
        delete f;
      }",25,,79,2,,void
48855,BLOCK,-1,,"{
  uint32_t left = 0;
  uint32_t right = files.size();
  while (left < right) {
    uint32_t mid = (left + right) / 2;
    const FileMetaData* f = files[mid];
    if (icmp.InternalKeyComparator::Compare(f->largest.Encode(), key) < 0) {
      // Key at ""mid.largest"" is < ""target"".  Therefore all
      // files at or before ""mid"" are uninteresting.
      left = mid + 1;
    } else {
      // Key at ""mid.largest"" is >= ""target"".  Therefore all files
      // after ""mid"" are uninteresting.
      right = mid;
    }
  }
  return right;
}",32,,88,4,,void
48871,BLOCK,-1,,"{
    uint32_t mid = (left + right) / 2;
    const FileMetaData* f = files[mid];
    if (icmp.InternalKeyComparator::Compare(f->largest.Encode(), key) < 0) {
      // Key at ""mid.largest"" is < ""target"".  Therefore all
      // files at or before ""mid"" are uninteresting.
      left = mid + 1;
    } else {
      // Key at ""mid.largest"" is >= ""target"".  Therefore all files
      // after ""mid"" are uninteresting.
      right = mid;
    }
  }",24,,91,2,,void
48900,BLOCK,-1,,"{
      // Key at ""mid.largest"" is < ""target"".  Therefore all
      // files at or before ""mid"" are uninteresting.
      left = mid + 1;
    }",76,,94,2,,void
48907,BLOCK,-1,,"{
      // Key at ""mid.largest"" is >= ""target"".  Therefore all files
      // after ""mid"" are uninteresting.
      right = mid;
    }",12,,98,1,,void
48919,BLOCK,-1,,"{
  // NULL user_key occurs before all keys and is therefore never after *f
  return (user_key != NULL &&
          ucmp->Compare(*user_key, f->largest.user_key()) > 0);
}",69,,108,4,,void
48945,BLOCK,-1,,"{
  // NULL user_key occurs after all keys and is therefore never before *f
  return (user_key != NULL &&
          ucmp->Compare(*user_key, f->smallest.user_key()) < 0);
}",70,,115,4,,void
48973,BLOCK,-1,,"{
  const Comparator* ucmp = icmp.user_comparator();
  if (!disjoint_sorted_files) {
    // Need to check against all files
    for (size_t i = 0; i < files.size(); i++) {
      const FileMetaData* f = files[i];
      if (AfterFile(ucmp, smallest_user_key, f) ||
          BeforeFile(ucmp, largest_user_key, f)) {
        // No overlap
      } else {
        return true;  // Overlap
      }
    }
    return false;
  }

  // Binary search over file list
  uint32_t index = 0;
  if (smallest_user_key != NULL) {
    // Find the earliest possible internal key for smallest_user_key
    InternalKey small(*smallest_user_key, kMaxSequenceNumber,kValueTypeForSeek);
    index = FindFile(icmp, files, small.Encode());
  }

  if (index >= files.size()) {
    // beginning of range is after all files, so no overlap.
    return false;
  }

  return !BeforeFile(ucmp, largest_user_key, files[index]);
}",36,,126,6,,void
48984,BLOCK,-1,,"{
    // Need to check against all files
    for (size_t i = 0; i < files.size(); i++) {
      const FileMetaData* f = files[i];
      if (AfterFile(ucmp, smallest_user_key, f) ||
          BeforeFile(ucmp, largest_user_key, f)) {
        // No overlap
      } else {
        return true;  // Overlap
      }
    }
    return false;
  }",31,,128,2,,void
48986,BLOCK,-1,,<empty>,5,,130,1,,void
48999,BLOCK,4,,"{
      const FileMetaData* f = files[i];
      if (AfterFile(ucmp, smallest_user_key, f) ||
          BeforeFile(ucmp, largest_user_key, f)) {
        // No overlap
      } else {
        return true;  // Overlap
      }
    }",47,,130,4,,void
49016,BLOCK,-1,,"{
        // No overlap
      }",50,,133,2,,void
49018,BLOCK,-1,,"{
        return true;  // Overlap
      }",14,,135,1,,void
49031,BLOCK,-1,,"{
    // Find the earliest possible internal key for smallest_user_key
    InternalKey small(*smallest_user_key, kMaxSequenceNumber,kValueTypeForSeek);
    index = FindFile(icmp, files, small.Encode());
  }",34,,144,2,,void
49054,BLOCK,-1,,"{
    // beginning of range is after all files, so no overlap.
    return false;
  }",30,,150,2,,void
49071,BLOCK,-1,,"{        // Marks as invalid
  }",31,,169,3,,void
49075,BLOCK,-1,,"{
    return index_ < flist_->size();
  }",30,,171,1,,void
49087,BLOCK,-1,,"{
    index_ = FindFile(icmp_, *flist_, target);
  }",42,,174,2,,void
49098,BLOCK,-1,,{ index_ = 0; },30,,177,1,,void
49105,BLOCK,-1,,"{
    index_ = flist_->empty() ? 0 : flist_->size() - 1;
  }",29,,178,1,,void
49123,BLOCK,-1,,"{
    assert(Valid());
    index_++;
  }",23,,181,1,,void
49131,BLOCK,-1,,"{
    assert(Valid());
    if (index_ == 0) {
      index_ = flist_->size();  // Marks as invalid
    } else {
      index_--;
    }
  }",23,,185,1,,void
49138,BLOCK,-1,,"{
      index_ = flist_->size();  // Marks as invalid
    }",22,,187,2,,void
49146,BLOCK,-1,,"{
      index_--;
    }",12,,189,1,,void
49152,BLOCK,-1,,"{
    assert(Valid());
    return (*flist_)[index_]->largest.Encode();
  }",21,,193,1,,void
49168,BLOCK,-1,,"{
    assert(Valid());
    EncodeFixed64(value_buf_, (*flist_)[index_]->number);
    EncodeFixed64(value_buf_+8, (*flist_)[index_]->file_size);
    return Slice(value_buf_, sizeof(value_buf_));
  }",23,,197,1,,void
49197,BLOCK,-1,,{ return Status::OK(); },33,,203,1,,void
49210,BLOCK,-1,,<empty>,,,,1,,<empty>
49219,BLOCK,-1,,"{
  TableCache* cache = reinterpret_cast<TableCache*>(arg);
  if (file_value.size() != 16) {
    return NewErrorIterator(
        Status::Corruption(""FileReader invoked with unexpected value""));
  } else {
    return cache->NewIterator(options,
                              DecodeFixed64(file_value.data()),
                              DecodeFixed64(file_value.data() + 8));
  }
}",59,,215,4,,void
49233,BLOCK,-1,,"{
    return NewErrorIterator(
        Status::Corruption(""FileReader invoked with unexpected value""));
  }",32,,217,2,,void
49242,BLOCK,-1,,"{
    return cache->NewIterator(options,
                              DecodeFixed64(file_value.data()),
                              DecodeFixed64(file_value.data() + 8));
  }",10,,220,1,,void
49266,BLOCK,-1,,"{
  return NewTwoLevelIterator(
      new LevelFileNumIterator(vset_->icmp_, &files_[level]),
      &GetFileIterator, vset_->table_cache_, options);
}",62,,228,3,,void
49289,BLOCK,-1,,"{
  // Merge all level zero files together since they may overlap
  for (size_t i = 0; i < files_[0].size(); i++) {
    iters->push_back(
        vset_->table_cache_->NewIterator(
            options, files_[0][i]->number, files_[0][i]->file_size));
  }

  // For levels > 0, we can use a concatenating iterator that sequentially
  // walks through the non-overlapping files in the level, opening them
  // lazily.
  for (int level = 1; level < config::kNumLevels; level++) {
    if (!files_[level].empty()) {
      iters->push_back(NewConcatenatingIterator(options, level));
    }
  }
}",59,,235,3,,void
49291,BLOCK,-1,,<empty>,3,,237,1,,void
49306,BLOCK,4,,"{
    iters->push_back(
        vset_->table_cache_->NewIterator(
            options, files_[0][i]->number, files_[0][i]->file_size));
  }",49,,237,4,,void
49333,BLOCK,-1,,<empty>,3,,246,1,,void
49345,BLOCK,4,,"{
    if (!files_[level].empty()) {
      iters->push_back(NewConcatenatingIterator(options, level));
    }
  }",60,,246,4,,void
49354,BLOCK,-1,,"{
      iters->push_back(NewConcatenatingIterator(options, level));
    }",33,,247,2,,void
49379,BLOCK,-1,,"{
  Saver* s = reinterpret_cast<Saver*>(arg);
  ParsedInternalKey parsed_key;
  if (!ParseInternalKey(ikey, &parsed_key)) {
    s->state = kCorrupt;
  } else {
    if (s->ucmp->Compare(parsed_key.user_key, s->user_key) == 0) {
      s->state = (parsed_key.type == kTypeValue) ? kFound : kDeleted;
      if (s->state == kFound) {
        s->value->assign(v.data(), v.size());
      }
    }
  }
}",69,,268,4,,void
49393,BLOCK,-1,,"{
    s->state = kCorrupt;
  }",45,,271,2,,void
49400,BLOCK,-1,,"{
    if (s->ucmp->Compare(parsed_key.user_key, s->user_key) == 0) {
      s->state = (parsed_key.type == kTypeValue) ? kFound : kDeleted;
      if (s->state == kFound) {
        s->value->assign(v.data(), v.size());
      }
    }
  }",10,,273,1,,void
49416,BLOCK,-1,,"{
      s->state = (parsed_key.type == kTypeValue) ? kFound : kDeleted;
      if (s->state == kFound) {
        s->value->assign(v.data(), v.size());
      }
    }",66,,274,2,,void
49435,BLOCK,-1,,"{
        s->value->assign(v.data(), v.size());
      }",31,,276,2,,void
49455,BLOCK,-1,,"{
  return a->number > b->number;
}",59,,283,3,,void
49471,BLOCK,-1,,"{
  // TODO(sanjay): Change Version::Get() to use this function.
  const Comparator* ucmp = vset_->icmp_.user_comparator();

  // Search level-0 in order from newest to oldest.
  std::vector<FileMetaData*> tmp;
  tmp.reserve(files_[0].size());
  for (uint32_t i = 0; i < files_[0].size(); i++) {
    FileMetaData* f = files_[0][i];
    if (ucmp->Compare(user_key, f->smallest.user_key()) >= 0 &&
        ucmp->Compare(user_key, f->largest.user_key()) <= 0) {
      tmp.push_back(f);
    }
  }
  if (!tmp.empty()) {
    std::sort(tmp.begin(), tmp.end(), NewestFirst);
    for (uint32_t i = 0; i < tmp.size(); i++) {
      if (!(*func)(arg, 0, tmp[i])) {
        return;
      }
    }
  }

  // Search other levels.
  for (int level = 1; level < config::kNumLevels; level++) {
    size_t num_files = files_[level].size();
    if (num_files == 0) continue;

    // Binary search to find earliest index whose largest key >= internal_key.
    uint32_t index = FindFile(vset_->icmp_, files_[level], inte...",75,,289,5,,void
49493,BLOCK,-1,,<empty>,3,,296,1,,void
49508,BLOCK,4,,"{
    FileMetaData* f = files_[0][i];
    if (ucmp->Compare(user_key, f->smallest.user_key()) >= 0 &&
        ucmp->Compare(user_key, f->largest.user_key()) <= 0) {
      tmp.push_back(f);
    }
  }",51,,296,4,,void
49545,BLOCK,-1,,"{
      tmp.push_back(f);
    }",62,,299,2,,void
49557,BLOCK,-1,,"{
    std::sort(tmp.begin(), tmp.end(), NewestFirst);
    for (uint32_t i = 0; i < tmp.size(); i++) {
      if (!(*func)(arg, 0, tmp[i])) {
        return;
      }
    }
  }",21,,303,2,,void
49572,BLOCK,-1,,<empty>,5,,305,1,,void
49585,BLOCK,4,,"{
      if (!(*func)(arg, 0, tmp[i])) {
        return;
      }
    }",47,,305,4,,void
49596,BLOCK,-1,,"{
        return;
      }",37,,306,2,,void
49599,BLOCK,-1,,<empty>,3,,313,1,,void
49611,BLOCK,4,,"{
    size_t num_files = files_[level].size();
    if (num_files == 0) continue;

    // Binary search to find earliest index whose largest key >= internal_key.
    uint32_t index = FindFile(vset_->icmp_, files_[level], internal_key);
    if (index < num_files) {
      FileMetaData* f = files_[level][index];
      if (ucmp->Compare(user_key, f->smallest.user_key()) < 0) {
        // All of ""f"" is past any data for user_key
      } else {
        if (!(*func)(arg, level, f)) {
          return;
        }
      }
    }
  }",60,,313,4,,void
49625,BLOCK,-1,,<empty>,25,,315,2,,void
49642,BLOCK,-1,,"{
      FileMetaData* f = files_[level][index];
      if (ucmp->Compare(user_key, f->smallest.user_key()) < 0) {
        // All of ""f"" is past any data for user_key
      } else {
        if (!(*func)(arg, level, f)) {
          return;
        }
      }
    }",28,,319,2,,void
49665,BLOCK,-1,,"{
        // All of ""f"" is past any data for user_key
      }",64,,321,2,,void
49667,BLOCK,-1,,"{
        if (!(*func)(arg, level, f)) {
          return;
        }
      }",14,,323,1,,void
49676,BLOCK,-1,,"{
          return;
        }",38,,324,2,,void
49685,BLOCK,-1,,"{
  Slice ikey = k.internal_key();
  Slice user_key = k.user_key();
  const Comparator* ucmp = vset_->icmp_.user_comparator();
  Status s;

  stats->seek_file = NULL;
  stats->seek_file_level = -1;
  FileMetaData* last_file_read = NULL;
  int last_file_read_level = -1;

  // We can search level-by-level since entries never hop across
  // levels.  Therefore we are guaranteed that if we find data
  // in an smaller level, later levels are irrelevant.
  std::vector<FileMetaData*> tmp;
  FileMetaData* tmp2;
  for (int level = 0; level < config::kNumLevels; level++) {
    size_t num_files = files_[level].size();
    if (num_files == 0) continue;

    // Get the list of files to search in this level
    FileMetaData* const* files = &files_[level][0];
    if (level == 0) {
      // Level-0 files may overlap each other.  Find all files that
      // overlap user_key and process them in order from newest to oldest.
      tmp.reserve(num_files);
      for (uint32_t i = 0; i < num_files; i++)...",38,,335,5,,void
49733,BLOCK,-1,,<empty>,3,,351,1,,void
49745,BLOCK,4,,"{
    size_t num_files = files_[level].size();
    if (num_files == 0) continue;

    // Get the list of files to search in this level
    FileMetaData* const* files = &files_[level][0];
    if (level == 0) {
      // Level-0 files may overlap each other.  Find all files that
      // overlap user_key and process them in order from newest to oldest.
      tmp.reserve(num_files);
      for (uint32_t i = 0; i < num_files; i++) {
        FileMetaData* f = files[i];
        if (ucmp->Compare(user_key, f->smallest.user_key()) >= 0 &&
            ucmp->Compare(user_key, f->largest.user_key()) <= 0) {
          tmp.push_back(f);
        }
      }
      if (tmp.empty()) continue;

      std::sort(tmp.begin(), tmp.end(), NewestFirst);
      files = &tmp[0];
      num_files = tmp.size();
    } else {
      // Binary search to find earliest index whose largest key >= ikey.
      uint32_t index = FindFile(vset_->icmp_, files_[level], ikey);
      if (index >= num_files) {
        files = NULL;
...",60,,351,4,,void
49759,BLOCK,-1,,<empty>,25,,353,2,,void
49774,BLOCK,-1,,"{
      // Level-0 files may overlap each other.  Find all files that
      // overlap user_key and process them in order from newest to oldest.
      tmp.reserve(num_files);
      for (uint32_t i = 0; i < num_files; i++) {
        FileMetaData* f = files[i];
        if (ucmp->Compare(user_key, f->smallest.user_key()) >= 0 &&
            ucmp->Compare(user_key, f->largest.user_key()) <= 0) {
          tmp.push_back(f);
        }
      }
      if (tmp.empty()) continue;

      std::sort(tmp.begin(), tmp.end(), NewestFirst);
      files = &tmp[0];
      num_files = tmp.size();
    }",21,,357,2,,void
49781,BLOCK,-1,,<empty>,7,,361,1,,void
49791,BLOCK,4,,"{
        FileMetaData* f = files[i];
        if (ucmp->Compare(user_key, f->smallest.user_key()) >= 0 &&
            ucmp->Compare(user_key, f->largest.user_key()) <= 0) {
          tmp.push_back(f);
        }
      }",48,,361,4,,void
49826,BLOCK,-1,,"{
          tmp.push_back(f);
        }",66,,364,2,,void
49837,BLOCK,-1,,<empty>,24,,368,2,,void
49865,BLOCK,-1,,"{
      // Binary search to find earliest index whose largest key >= ikey.
      uint32_t index = FindFile(vset_->icmp_, files_[level], ikey);
      if (index >= num_files) {
        files = NULL;
        num_files = 0;
      } else {
        tmp2 = files[index];
        if (ucmp->Compare(user_key, tmp2->smallest.user_key()) < 0) {
          // All of ""tmp2"" is past any data for user_key
          files = NULL;
          num_files = 0;
        } else {
          files = &tmp2;
          num_files = 1;
        }
      }
    }",12,,373,1,,void
49881,BLOCK,-1,,"{
        files = NULL;
        num_files = 0;
      }",31,,376,2,,void
49889,BLOCK,-1,,"{
        tmp2 = files[index];
        if (ucmp->Compare(user_key, tmp2->smallest.user_key()) < 0) {
          // All of ""tmp2"" is past any data for user_key
          files = NULL;
          num_files = 0;
        } else {
          files = &tmp2;
          num_files = 1;
        }
      }",14,,379,1,,void
49909,BLOCK,-1,,"{
          // All of ""tmp2"" is past any data for user_key
          files = NULL;
          num_files = 0;
        }",69,,381,2,,void
49917,BLOCK,-1,,"{
          files = &tmp2;
          num_files = 1;
        }",16,,385,1,,void
49926,BLOCK,-1,,<empty>,5,,392,1,,void
49936,BLOCK,4,,"{
      if (last_file_read != NULL && stats->seek_file == NULL) {
        // We have had more than one seek for this read.  Charge the 1st file.
        stats->seek_file = last_file_read;
        stats->seek_file_level = last_file_read_level;
      }

      FileMetaData* f = files[i];
      last_file_read = f;
      last_file_read_level = level;

      Saver saver;
      saver.state = kNotFound;
      saver.ucmp = ucmp;
      saver.user_key = user_key;
      saver.value = value;
      s = vset_->table_cache_->Get(options, f->number, f->file_size,
                                   ikey, &saver, SaveValue);
      if (!s.ok()) {
        return s;
      }
      switch (saver.state) {
        case kNotFound:
          break;      // Keep searching in other files
        case kFound:
          return s;
        case kDeleted:
          s = Status::NotFound(Slice());  // Use empty error message for speed
          return s;
        case kCorrupt:
          s = Status::Corruption(""corrupte...",46,,392,4,,void
49947,BLOCK,-1,,"{
        // We have had more than one seek for this read.  Charge the 1st file.
        stats->seek_file = last_file_read;
        stats->seek_file_level = last_file_read_level;
      }",63,,393,2,,void
50016,BLOCK,-1,,"{
        return s;
      }",20,,410,2,,void
50023,BLOCK,-1,,"{
        case kNotFound:
          break;      // Keep searching in other files
        case kFound:
          return s;
        case kDeleted:
          s = Status::NotFound(Slice());  // Use empty error message for speed
          return s;
        case kCorrupt:
          s = Status::Corruption(""corrupted key for "", user_key);
          return s;
      }",28,,413,2,,void
50064,BLOCK,-1,,"{
  FileMetaData* f = stats.seek_file;
  if (f != NULL) {
    f->allowed_seeks--;
    if (f->allowed_seeks <= 0 && file_to_compact_ == NULL) {
      file_to_compact_ = f;
      file_to_compact_level_ = stats.seek_file_level;
      return true;
    }
  }
  return false;
}",50,,431,2,,void
50075,BLOCK,-1,,"{
    f->allowed_seeks--;
    if (f->allowed_seeks <= 0 && file_to_compact_ == NULL) {
      file_to_compact_ = f;
      file_to_compact_level_ = stats.seek_file_level;
      return true;
    }
  }",18,,433,2,,void
50090,BLOCK,-1,,"{
      file_to_compact_ = f;
      file_to_compact_level_ = stats.seek_file_level;
      return true;
    }",60,,435,2,,void
50107,BLOCK,-1,,"{
  ParsedInternalKey ikey;
  if (!ParseInternalKey(internal_key, &ikey)) {
    return false;
  }

  struct State {
    GetStats stats;  // Holds first matching file
    int matches;

    static bool Match(void* arg, int level, FileMetaData* f) {
      State* state = reinterpret_cast<State*>(arg);
      state->matches++;
      if (state->matches == 1) {
        // Remember first match.
        state->stats.seek_file = f;
        state->stats.seek_file_level = level;
      }
      // We can stop iterating once we have a second match.
      return state->matches < 2;
    }
  };

  State state;
  state.matches = 0;
  ForEachOverlapping(ikey.user_key, internal_key, &state, &State::Match);

  // Must have at least two matches since we want to merge across
  // files. But what if we have a single file that contains many
  // overwrites and deletions?  Should we have another mechanism for
  // finding such files?
  if (state.matches >= 2) {
    // 1MB cost is about 1 seek (see comment in B...",52,,444,2,,void
50115,BLOCK,-1,,"{
    return false;
  }",47,,446,2,,void
50141,BLOCK,-1,,"{
    // 1MB cost is about 1 seek (see comment in Builder::Apply).
    return UpdateStats(state.stats);
  }",27,,475,2,,void
50152,BLOCK,-1,,"{
  ++refs_;
}",21,,482,1,,void
50158,BLOCK,-1,,"{
  assert(this != &vset_->dummy_versions_);
  assert(refs_ >= 1);
  --refs_;
  if (refs_ == 0) {
    delete this;
  }
}",23,,486,1,,void
50176,BLOCK,-1,,"{
    delete this;
  }",19,,490,2,,void
50185,BLOCK,-1,,"{
  return SomeFileOverlapsRange(vset_->icmp_, (level > 0), files_[level],
                               smallest_user_key, largest_user_key);
}",61,,497,4,,void
50204,BLOCK,-1,,"{
  int level = 0;
  if (!OverlapInLevel(0, &smallest_user_key, &largest_user_key)) {
    // Push to next level if there is no overlap in next level,
    // and the #bytes overlapping in the level after that are limited.
    InternalKey start(smallest_user_key, kMaxSequenceNumber, kValueTypeForSeek);
    InternalKey limit(largest_user_key, 0, static_cast<ValueType>(0));
    std::vector<FileMetaData*> overlaps;
    while (level < config::kMaxMemCompactLevel) {
      if (OverlapInLevel(level + 1, &smallest_user_key, &largest_user_key)) {
        break;
      }
      if (level + 2 < config::kNumLevels) {
        // Check that file does not overlap too many grandparent bytes.
        GetOverlappingInputs(level + 2, &start, &limit, &overlaps);
        const int64_t sum = TotalFileSize(overlaps);
        if (sum > MaxGrandParentOverlapBytes(vset_->options_)) {
          break;
        }
      }
      level++;
    }
  }
  return level;
}",36,,504,3,,void
50217,BLOCK,-1,,"{
    // Push to next level if there is no overlap in next level,
    // and the #bytes overlapping in the level after that are limited.
    InternalKey start(smallest_user_key, kMaxSequenceNumber, kValueTypeForSeek);
    InternalKey limit(largest_user_key, 0, static_cast<ValueType>(0));
    std::vector<FileMetaData*> overlaps;
    while (level < config::kMaxMemCompactLevel) {
      if (OverlapInLevel(level + 1, &smallest_user_key, &largest_user_key)) {
        break;
      }
      if (level + 2 < config::kNumLevels) {
        // Check that file does not overlap too many grandparent bytes.
        GetOverlappingInputs(level + 2, &start, &limit, &overlaps);
        const int64_t sum = TotalFileSize(overlaps);
        if (sum > MaxGrandParentOverlapBytes(vset_->options_)) {
          break;
        }
      }
      level++;
    }
  }",66,,506,2,,void
50237,BLOCK,-1,,"{
      if (OverlapInLevel(level + 1, &smallest_user_key, &largest_user_key)) {
        break;
      }
      if (level + 2 < config::kNumLevels) {
        // Check that file does not overlap too many grandparent bytes.
        GetOverlappingInputs(level + 2, &start, &limit, &overlaps);
        const int64_t sum = TotalFileSize(overlaps);
        if (sum > MaxGrandParentOverlapBytes(vset_->options_)) {
          break;
        }
      }
      level++;
    }",49,,512,2,,void
50247,BLOCK,-1,,"{
        break;
      }",77,,513,2,,void
50257,BLOCK,-1,,"{
        // Check that file does not overlap too many grandparent bytes.
        GetOverlappingInputs(level + 2, &start, &limit, &overlaps);
        const int64_t sum = TotalFileSize(overlaps);
        if (sum > MaxGrandParentOverlapBytes(vset_->options_)) {
          break;
        }
      }",43,,516,2,,void
50280,BLOCK,-1,,"{
          break;
        }",64,,520,2,,void
50293,BLOCK,-1,,"{
  assert(level >= 0);
  assert(level < config::kNumLevels);
  inputs->clear();
  Slice user_begin, user_end;
  if (begin != NULL) {
    user_begin = begin->user_key();
  }
  if (end != NULL) {
    user_end = end->user_key();
  }
  const Comparator* user_cmp = vset_->icmp_.user_comparator();
  for (size_t i = 0; i < files_[level].size(); ) {
    FileMetaData* f = files_[level][i++];
    const Slice file_start = f->smallest.user_key();
    const Slice file_limit = f->largest.user_key();
    if (begin != NULL && user_cmp->Compare(file_limit, user_begin) < 0) {
      // ""f"" is completely before specified range; skip it
    } else if (end != NULL && user_cmp->Compare(file_start, user_end) > 0) {
      // ""f"" is completely after specified range; skip it
    } else {
      inputs->push_back(f);
      if (level == 0) {
        // Level-0 files may overlap each other.  So check if the newly
        // added file has expanded the range.  If so, restart search.
        if (begin != NULL && u...",41,,535,5,,void
50314,BLOCK,-1,,"{
    user_begin = begin->user_key();
  }",22,,540,2,,void
50325,BLOCK,-1,,"{
    user_end = end->user_key();
  }",20,,543,2,,void
50342,BLOCK,-1,,<empty>,3,,547,1,,void
50355,BLOCK,4,,"{
    FileMetaData* f = files_[level][i++];
    const Slice file_start = f->smallest.user_key();
    const Slice file_limit = f->largest.user_key();
    if (begin != NULL && user_cmp->Compare(file_limit, user_begin) < 0) {
      // ""f"" is completely before specified range; skip it
    } else if (end != NULL && user_cmp->Compare(file_start, user_end) > 0) {
      // ""f"" is completely after specified range; skip it
    } else {
      inputs->push_back(f);
      if (level == 0) {
        // Level-0 files may overlap each other.  So check if the newly
        // added file has expanded the range.  If so, restart search.
        if (begin != NULL && user_cmp->Compare(file_start, user_begin) < 0) {
          user_begin = file_start;
          inputs->clear();
          i = 0;
        } else if (end != NULL && user_cmp->Compare(file_limit, user_end) > 0) {
          user_end = file_limit;
          inputs->clear();
          i = 0;
        }
      }
    }
  }",50,,547,4,,void
50396,BLOCK,-1,,"{
      // ""f"" is completely before specified range; skip it
    }",73,,551,2,,void
50398,BLOCK,-1,,<empty>,12,,553,1,,void
50412,BLOCK,-1,,"{
      // ""f"" is completely after specified range; skip it
    }",76,,553,2,,void
50414,BLOCK,-1,,"{
      inputs->push_back(f);
      if (level == 0) {
        // Level-0 files may overlap each other.  So check if the newly
        // added file has expanded the range.  If so, restart search.
        if (begin != NULL && user_cmp->Compare(file_start, user_begin) < 0) {
          user_begin = file_start;
          inputs->clear();
          i = 0;
        } else if (end != NULL && user_cmp->Compare(file_limit, user_end) > 0) {
          user_end = file_limit;
          inputs->clear();
          i = 0;
        }
      }
    }",12,,555,1,,void
50424,BLOCK,-1,,"{
        // Level-0 files may overlap each other.  So check if the newly
        // added file has expanded the range.  If so, restart search.
        if (begin != NULL && user_cmp->Compare(file_start, user_begin) < 0) {
          user_begin = file_start;
          inputs->clear();
          i = 0;
        } else if (end != NULL && user_cmp->Compare(file_limit, user_end) > 0) {
          user_end = file_limit;
          inputs->clear();
          i = 0;
        }
      }",23,,557,2,,void
50438,BLOCK,-1,,"{
          user_begin = file_start;
          inputs->clear();
          i = 0;
        }",77,,560,2,,void
50450,BLOCK,-1,,<empty>,16,,564,1,,void
50464,BLOCK,-1,,"{
          user_end = file_limit;
          inputs->clear();
          i = 0;
        }",80,,564,2,,void
50478,BLOCK,-1,,"{
  std::string r;
  for (int level = 0; level < config::kNumLevels; level++) {
    // E.g.,
    //   --- level 1 ---
    //   17:123['a' .. 'd']
    //   20:43['e' .. 'g']
    r.append(""--- level "");
    AppendNumberTo(&r, level);
    r.append("" ---\n"");
    const std::vector<FileMetaData*>& files = files_[level];
    for (size_t i = 0; i < files.size(); i++) {
      r.push_back(' ');
      AppendNumberTo(&r, files[i]->number);
      r.push_back(':');
      AppendNumberTo(&r, files[i]->file_size);
      r.append(""["");
      r.append(files[i]->smallest.DebugString());
      r.append("" .. "");
      r.append(files[i]->largest.DebugString());
      r.append(""]\n"");
    }
  }
  return r;
}",42,,574,1,,void
50481,BLOCK,-1,,<empty>,3,,576,1,,void
50493,BLOCK,4,,"{
    // E.g.,
    //   --- level 1 ---
    //   17:123['a' .. 'd']
    //   20:43['e' .. 'g']
    r.append(""--- level "");
    AppendNumberTo(&r, level);
    r.append("" ---\n"");
    const std::vector<FileMetaData*>& files = files_[level];
    for (size_t i = 0; i < files.size(); i++) {
      r.push_back(' ');
      AppendNumberTo(&r, files[i]->number);
      r.push_back(':');
      AppendNumberTo(&r, files[i]->file_size);
      r.append(""["");
      r.append(files[i]->smallest.DebugString());
      r.append("" .. "");
      r.append(files[i]->largest.DebugString());
      r.append(""]\n"");
    }
  }",60,,576,4,,void
50515,BLOCK,-1,,<empty>,5,,585,1,,void
50528,BLOCK,4,,"{
      r.push_back(' ');
      AppendNumberTo(&r, files[i]->number);
      r.push_back(':');
      AppendNumberTo(&r, files[i]->file_size);
      r.append(""["");
      r.append(files[i]->smallest.DebugString());
      r.append("" .. "");
      r.append(files[i]->largest.DebugString());
      r.append(""]\n"");
    }",47,,585,4,,void
50604,BLOCK,-1,,"{
      int r = internal_comparator->Compare(f1->smallest, f2->smallest);
      if (r != 0) {
        return (r < 0);
      } else {
        // Break ties by file number
        return (f1->number < f2->number);
      }
    }",63,,609,3,,void
50622,BLOCK,-1,,"{
        return (r < 0);
      }",19,,611,2,,void
50628,BLOCK,-1,,"{
        // Break ties by file number
        return (f1->number < f2->number);
      }",14,,613,1,,void
50649,BLOCK,-1,,"{
    base_->Ref();
    BySmallestKey cmp;
    cmp.internal_comparator = &vset_->icmp_;
    for (int level = 0; level < config::kNumLevels; level++) {
      levels_[level].added_files = new FileSet(cmp);
    }
  }",21,,634,3,,void
50664,BLOCK,-1,,<empty>,5,,638,1,,void
50676,BLOCK,4,,"{
      levels_[level].added_files = new FileSet(cmp);
    }",62,,638,4,,void
50689,BLOCK,-1,,"{
    for (int level = 0; level < config::kNumLevels; level++) {
      const FileSet* added = levels_[level].added_files;
      std::vector<FileMetaData*> to_unref;
      to_unref.reserve(added->size());
      for (FileSet::const_iterator it = added->begin();
          it != added->end(); ++it) {
        to_unref.push_back(*it);
      }
      delete added;
      for (uint32_t i = 0; i < to_unref.size(); i++) {
        FileMetaData* f = to_unref[i];
        f->refs--;
        if (f->refs <= 0) {
          delete f;
        }
      }
    }
    base_->Unref();
  }",14,,643,1,,void
50691,BLOCK,-1,,<empty>,5,,644,1,,void
50703,BLOCK,4,,"{
      const FileSet* added = levels_[level].added_files;
      std::vector<FileMetaData*> to_unref;
      to_unref.reserve(added->size());
      for (FileSet::const_iterator it = added->begin();
          it != added->end(); ++it) {
        to_unref.push_back(*it);
      }
      delete added;
      for (uint32_t i = 0; i < to_unref.size(); i++) {
        FileMetaData* f = to_unref[i];
        f->refs--;
        if (f->refs <= 0) {
          delete f;
        }
      }
    }",62,,644,4,,void
50722,BLOCK,-1,,<empty>,7,,648,1,,void
50738,BLOCK,4,,"{
        to_unref.push_back(*it);
      }",37,,649,4,,void
50748,BLOCK,-1,,<empty>,7,,653,1,,void
50761,BLOCK,4,,"{
        FileMetaData* f = to_unref[i];
        f->refs--;
        if (f->refs <= 0) {
          delete f;
        }
      }",54,,653,4,,void
50778,BLOCK,-1,,"{
          delete f;
        }",27,,656,2,,void
50789,BLOCK,-1,,"{
    // Update compaction pointers
    for (size_t i = 0; i < edit->compact_pointers_.size(); i++) {
      const int level = edit->compact_pointers_[i].first;
      vset_->compact_pointer_[level] =
          edit->compact_pointers_[i].second.Encode().ToString();
    }

    // Delete files
    const VersionEdit::DeletedFileSet& del = edit->deleted_files_;
    for (VersionEdit::DeletedFileSet::const_iterator iter = del.begin();
         iter != del.end();
         ++iter) {
      const int level = iter->first;
      const uint64_t number = iter->second;
      levels_[level].deleted_files.insert(number);
    }

    // Add new files
    for (size_t i = 0; i < edit->new_files_.size(); i++) {
      const int level = edit->new_files_[i].first;
      FileMetaData* f = new FileMetaData(edit->new_files_[i].second);
      f->refs = 1;

      // We arrange to automatically compact this file after
      // a certain number of seeks.  Let's assume:
      //   (1) One seek costs 10ms
      //   (...",33,,665,2,,void
50791,BLOCK,-1,,<empty>,5,,667,1,,void
50806,BLOCK,4,,"{
      const int level = edit->compact_pointers_[i].first;
      vset_->compact_pointer_[level] =
          edit->compact_pointers_[i].second.Encode().ToString();
    }",65,,667,4,,void
50843,BLOCK,-1,,<empty>,5,,675,1,,void
50859,BLOCK,4,,"{
      const int level = iter->first;
      const uint64_t number = iter->second;
      levels_[level].deleted_files.insert(number);
    }",18,,677,4,,void
50882,BLOCK,-1,,<empty>,5,,684,1,,void
50897,BLOCK,4,,"{
      const int level = edit->new_files_[i].first;
      FileMetaData* f = new FileMetaData(edit->new_files_[i].second);
      f->refs = 1;

      // We arrange to automatically compact this file after
      // a certain number of seeks.  Let's assume:
      //   (1) One seek costs 10ms
      //   (2) Writing or reading 1MB costs 10ms (100MB/s)
      //   (3) A compaction of 1MB does 25MB of IO:
      //         1MB read from this level
      //         10-12MB read from next level (boundaries may be misaligned)
      //         10-12MB written to next level
      // This implies that 25 seeks cost the same as the compaction
      // of 1MB of data.  I.e., one seek costs approximately the
      // same as the compaction of 40KB of data.  We are a little
      // conservative and allow approximately one seek for every 16KB
      // of data before triggering a compaction.
      f->allowed_seeks = (f->file_size / 16384);
      if (f->allowed_seeks < 100) f->allowed_seeks = 100;

    ...",58,,684,4,,void
50940,BLOCK,-1,,<empty>,35,,703,2,,void
50970,BLOCK,-1,,"{
    BySmallestKey cmp;
    cmp.internal_comparator = &vset_->icmp_;
    for (int level = 0; level < config::kNumLevels; level++) {
      // Merge the set of added files with the set of pre-existing files.
      // Drop any deleted files.  Store the result in *v.
      const std::vector<FileMetaData*>& base_files = base_->files_[level];
      std::vector<FileMetaData*>::const_iterator base_iter = base_files.begin();
      std::vector<FileMetaData*>::const_iterator base_end = base_files.end();
      const FileSet* added = levels_[level].added_files;
      v->files_[level].reserve(base_files.size() + added->size());
      for (FileSet::const_iterator added_iter = added->begin();
           added_iter != added->end();
           ++added_iter) {
        // Add all smaller files listed in base_
        for (std::vector<FileMetaData*>::const_iterator bpos
                 = std::upper_bound(base_iter, base_end, *added_iter, cmp);
             base_iter != bpos;
             ++base_iter) ...",27,,711,2,,void
50981,BLOCK,-1,,<empty>,5,,714,1,,void
50993,BLOCK,4,,"{
      // Merge the set of added files with the set of pre-existing files.
      // Drop any deleted files.  Store the result in *v.
      const std::vector<FileMetaData*>& base_files = base_->files_[level];
      std::vector<FileMetaData*>::const_iterator base_iter = base_files.begin();
      std::vector<FileMetaData*>::const_iterator base_end = base_files.end();
      const FileSet* added = levels_[level].added_files;
      v->files_[level].reserve(base_files.size() + added->size());
      for (FileSet::const_iterator added_iter = added->begin();
           added_iter != added->end();
           ++added_iter) {
        // Add all smaller files listed in base_
        for (std::vector<FileMetaData*>::const_iterator bpos
                 = std::upper_bound(base_iter, base_end, *added_iter, cmp);
             base_iter != bpos;
             ++base_iter) {
          MaybeAddFile(v, level, *base_iter);
        }

        MaybeAddFile(v, level, *added_iter);
      }

      // Add remai...",62,,714,4,,void
51042,BLOCK,-1,,<empty>,7,,722,1,,void
51058,BLOCK,4,,"{
        // Add all smaller files listed in base_
        for (std::vector<FileMetaData*>::const_iterator bpos
                 = std::upper_bound(base_iter, base_end, *added_iter, cmp);
             base_iter != bpos;
             ++base_iter) {
          MaybeAddFile(v, level, *base_iter);
        }

        MaybeAddFile(v, level, *added_iter);
      }",26,,724,4,,void
51060,BLOCK,-1,,<empty>,9,,726,1,,void
51078,BLOCK,4,,"{
          MaybeAddFile(v, level, *base_iter);
        }",27,,729,4,,void
51090,BLOCK,-1,,<empty>,7,,737,1,,void
51096,BLOCK,4,,"{
        MaybeAddFile(v, level, *base_iter);
      }",50,,737,4,,void
51106,BLOCK,-1,,"{
        for (uint32_t i = 1; i < v->files_[level].size(); i++) {
          const InternalKey& prev_end = v->files_[level][i-1]->largest;
          const InternalKey& this_begin = v->files_[level][i]->smallest;
          if (vset_->icmp_.Compare(prev_end, this_begin) >= 0) {
            fprintf(stderr, ""overlapping ranges in same level %s vs. %s\n"",
                    prev_end.DebugString().c_str(),
                    this_begin.DebugString().c_str());
            abort();
          }
        }
      }",22,,743,2,,void
51108,BLOCK,-1,,<empty>,9,,744,1,,void
51125,BLOCK,4,,"{
          const InternalKey& prev_end = v->files_[level][i-1]->largest;
          const InternalKey& this_begin = v->files_[level][i]->smallest;
          if (vset_->icmp_.Compare(prev_end, this_begin) >= 0) {
            fprintf(stderr, ""overlapping ranges in same level %s vs. %s\n"",
                    prev_end.DebugString().c_str(),
                    this_begin.DebugString().c_str());
            abort();
          }
        }",64,,744,4,,void
51163,BLOCK,-1,,"{
            fprintf(stderr, ""overlapping ranges in same level %s vs. %s\n"",
                    prev_end.DebugString().c_str(),
                    this_begin.DebugString().c_str());
            abort();
          }",64,,747,2,,void
51188,BLOCK,-1,,"{
    if (levels_[level].deleted_files.count(f->number) > 0) {
      // File is deleted: do nothing
    } else {
      std::vector<FileMetaData*>* files = &v->files_[level];
      if (level > 0 && !files->empty()) {
        // Must not overlap
        assert(vset_->icmp_.Compare((*files)[files->size()-1]->largest,
                                    f->smallest) < 0);
      }
      f->refs++;
      files->push_back(f);
    }
  }",61,,759,4,,void
51203,BLOCK,-1,,"{
      // File is deleted: do nothing
    }",60,,760,2,,void
51205,BLOCK,-1,,"{
      std::vector<FileMetaData*>* files = &v->files_[level];
      if (level > 0 && !files->empty()) {
        // Must not overlap
        assert(vset_->icmp_.Compare((*files)[files->size()-1]->largest,
                                    f->smallest) < 0);
      }
      f->refs++;
      files->push_back(f);
    }",12,,762,1,,void
51225,BLOCK,-1,,"{
        // Must not overlap
        assert(vset_->icmp_.Compare((*files)[files->size()-1]->largest,
                                    f->smallest) < 0);
      }",41,,764,2,,void
51261,BLOCK,-1,,<empty>,,,,1,,<empty>
51273,BLOCK,-1,,"{
  AppendVersion(new Version(this));
}",22,,792,5,,void
51281,BLOCK,-1,,"{
  current_->Unref();
  assert(dummy_versions_.next_ == &dummy_versions_);  // List must be empty
  delete descriptor_log_;
  delete descriptor_file_;
}",27,,796,1,,void
51301,BLOCK,-1,,"{
  // Make ""v"" current
  assert(v->refs_ == 0);
  assert(v != current_);
  if (current_ != NULL) {
    current_->Unref();
  }
  current_ = v;
  v->Ref();

  // Append to linked list
  v->prev_ = dummy_versions_.prev_;
  v->next_ = &dummy_versions_;
  v->prev_->next_ = v;
  v->next_->prev_ = v;
}",44,,803,2,,void
51316,BLOCK,-1,,"{
    current_->Unref();
  }",25,,807,2,,void
51360,BLOCK,-1,,"{
  if (edit->has_log_number_) {
    assert(edit->log_number_ >= log_number_);
    assert(edit->log_number_ < next_file_number_);
  } else {
    edit->SetLogNumber(log_number_);
  }

  if (!edit->has_prev_log_number_) {
    edit->SetPrevLogNumber(prev_log_number_);
  }

  edit->SetNextFile(next_file_number_);
  edit->SetLastSequence(last_sequence_);

  Version* v = new Version(this);
  {
    Builder builder(this, current_);
    builder.Apply(edit);
    builder.SaveTo(v);
  }
  Finalize(v);

  // Initialize new descriptor log file if necessary by creating
  // a temporary file that contains a snapshot of the current version.
  std::string new_manifest_file;
  Status s;
  if (descriptor_log_ == NULL) {
    // No reason to unlock *mu here since we only hit this path in the
    // first call to LogAndApply (when opening the database).
    assert(descriptor_file_ == NULL);
    new_manifest_file = DescriptorFileName(dbname_, manifest_file_number_);
    edit->SetNextFile(next_file_number_)...",68,,820,3,,void
51365,BLOCK,-1,,"{
    assert(edit->log_number_ >= log_number_);
    assert(edit->log_number_ < next_file_number_);
  }",30,,821,2,,void
51379,BLOCK,-1,,"{
    edit->SetLogNumber(log_number_);
  }",10,,824,1,,void
51390,BLOCK,-1,,"{
    edit->SetPrevLogNumber(prev_log_number_);
  }",36,,828,2,,void
51412,BLOCK,7,,"{
    Builder builder(this, current_);
    builder.Apply(edit);
    builder.SaveTo(v);
  }",3,,836,7,,void
51435,BLOCK,-1,,"{
    // No reason to unlock *mu here since we only hit this path in the
    // first call to LogAndApply (when opening the database).
    assert(descriptor_file_ == NULL);
    new_manifest_file = DescriptorFileName(dbname_, manifest_file_number_);
    edit->SetNextFile(next_file_number_);
    s = env_->NewWritableFile(new_manifest_file, &descriptor_file_);
    if (s.ok()) {
      descriptor_log_ = new log::Writer(descriptor_file_);
      s = WriteSnapshot(descriptor_log_);
    }
  }",32,,847,2,,void
51464,BLOCK,-1,,"{
      descriptor_log_ = new log::Writer(descriptor_file_);
      s = WriteSnapshot(descriptor_log_);
    }",17,,854,2,,void
51474,BLOCK,12,,"{
    mu->Unlock();

    // Write new record to MANIFEST log
    if (s.ok()) {
      std::string record;
      edit->EncodeTo(&record);
      s = descriptor_log_->AddRecord(record);
      if (s.ok()) {
        s = descriptor_file_->Sync();
      }
      if (!s.ok()) {
        Log(options_->info_log, ""MANIFEST write: %s\n"", s.ToString().c_str());
      }
    }

    // If we just created a new descriptor file, install it by writing a
    // new CURRENT file that points to it.
    if (s.ok() && !new_manifest_file.empty()) {
      s = SetCurrentFile(env_, dbname_, manifest_file_number_);
    }

    mu->Lock();
  }",3,,861,12,,void
51484,BLOCK,-1,,"{
      std::string record;
      edit->EncodeTo(&record);
      s = descriptor_log_->AddRecord(record);
      if (s.ok()) {
        s = descriptor_file_->Sync();
      }
      if (!s.ok()) {
        Log(options_->info_log, ""MANIFEST write: %s\n"", s.ToString().c_str());
      }
    }",17,,865,2,,void
51504,BLOCK,-1,,"{
        s = descriptor_file_->Sync();
      }",19,,869,2,,void
51517,BLOCK,-1,,"{
        Log(options_->info_log, ""MANIFEST write: %s\n"", s.ToString().c_str());
      }",20,,872,2,,void
51541,BLOCK,-1,,"{
      s = SetCurrentFile(env_, dbname_, manifest_file_number_);
    }",47,,879,2,,void
51557,BLOCK,-1,,"{
    AppendVersion(v);
    log_number_ = edit->log_number_;
    prev_log_number_ = edit->prev_log_number_;
  }",15,,887,2,,void
51571,BLOCK,-1,,"{
    delete v;
    if (!new_manifest_file.empty()) {
      delete descriptor_log_;
      delete descriptor_file_;
      descriptor_log_ = NULL;
      descriptor_file_ = NULL;
      env_->DeleteFile(new_manifest_file);
    }
  }",10,,891,1,,void
51580,BLOCK,-1,,"{
      delete descriptor_log_;
      delete descriptor_file_;
      descriptor_log_ = NULL;
      descriptor_file_ = NULL;
      env_->DeleteFile(new_manifest_file);
    }",37,,893,2,,void
51602,BLOCK,-1,,"{
  struct LogReporter : public log::Reader::Reporter {
    Status* status;
    virtual void Corruption(size_t bytes, const Status& s) {
      if (this->status->ok()) *this->status = s;
    }
  };

  // Read ""CURRENT"" file, which contains a pointer to the current manifest file
  std::string current;
  Status s = ReadFileToString(env_, CurrentFileName(dbname_), &current);
  if (!s.ok()) {
    return s;
  }
  if (current.empty() || current[current.size()-1] != '\n') {
    return Status::Corruption(""CURRENT file does not end with newline"");
  }
  current.resize(current.size() - 1);

  std::string dscname = dbname_ + ""/"" + current;
  SequentialFile* file;
  s = env_->NewSequentialFile(dscname, &file);
  if (!s.ok()) {
    return s;
  }

  bool have_log_number = false;
  bool have_prev_log_number = false;
  bool have_next_file = false;
  bool have_last_sequence = false;
  uint64_t next_file = 0;
  uint64_t last_sequence = 0;
  uint64_t log_number = 0;
  uint64_t prev_log_number = 0;
  Bu...",49,,905,2,,void
51619,BLOCK,-1,,"{
    return s;
  }",16,,916,2,,void
51638,BLOCK,-1,,"{
    return Status::Corruption(""CURRENT file does not end with newline"");
  }",61,,919,2,,void
51679,BLOCK,-1,,"{
    return s;
  }",16,,927,2,,void
51718,BLOCK,30,,"{
    LogReporter reporter;
    reporter.status = &s;
    log::Reader reader(file, &reporter, true/*checksum*/, 0/*initial_offset*/);
    Slice record;
    std::string scratch;
    while (reader.ReadRecord(&record, &scratch) && s.ok()) {
      VersionEdit edit;
      s = edit.DecodeFrom(record);
      if (s.ok()) {
        if (edit.has_comparator_ &&
            edit.comparator_ != icmp_.user_comparator()->Name()) {
          s = Status::InvalidArgument(
              edit.comparator_ + "" does not match existing comparator "",
              icmp_.user_comparator()->Name());
        }
      }

      if (s.ok()) {
        builder.Apply(&edit);
      }

      if (edit.has_log_number_) {
        log_number = edit.log_number_;
        have_log_number = true;
      }

      if (edit.has_prev_log_number_) {
        prev_log_number = edit.prev_log_number_;
        have_prev_log_number = true;
      }

      if (edit.has_next_file_number_) {
        next_file = edit.next_file_number_;
       ...",3,,941,30,,void
51749,BLOCK,-1,,"{
      VersionEdit edit;
      s = edit.DecodeFrom(record);
      if (s.ok()) {
        if (edit.has_comparator_ &&
            edit.comparator_ != icmp_.user_comparator()->Name()) {
          s = Status::InvalidArgument(
              edit.comparator_ + "" does not match existing comparator "",
              icmp_.user_comparator()->Name());
        }
      }

      if (s.ok()) {
        builder.Apply(&edit);
      }

      if (edit.has_log_number_) {
        log_number = edit.log_number_;
        have_log_number = true;
      }

      if (edit.has_prev_log_number_) {
        prev_log_number = edit.prev_log_number_;
        have_prev_log_number = true;
      }

      if (edit.has_next_file_number_) {
        next_file = edit.next_file_number_;
        have_next_file = true;
      }

      if (edit.has_last_sequence_) {
        last_sequence = edit.last_sequence_;
        have_last_sequence = true;
      }
    }",60,,947,2,,void
51763,BLOCK,-1,,"{
        if (edit.has_comparator_ &&
            edit.comparator_ != icmp_.user_comparator()->Name()) {
          s = Status::InvalidArgument(
              edit.comparator_ + "" does not match existing comparator "",
              icmp_.user_comparator()->Name());
        }
      }",19,,950,2,,void
51780,BLOCK,-1,,"{
          s = Status::InvalidArgument(
              edit.comparator_ + "" does not match existing comparator "",
              icmp_.user_comparator()->Name());
        }",66,,952,2,,void
51804,BLOCK,-1,,"{
        builder.Apply(&edit);
      }",19,,959,2,,void
51815,BLOCK,-1,,"{
        log_number = edit.log_number_;
        have_log_number = true;
      }",33,,963,2,,void
51828,BLOCK,-1,,"{
        prev_log_number = edit.prev_log_number_;
        have_prev_log_number = true;
      }",38,,968,2,,void
51841,BLOCK,-1,,"{
        next_file = edit.next_file_number_;
        have_next_file = true;
      }",39,,973,2,,void
51854,BLOCK,-1,,"{
        last_sequence = edit.last_sequence_;
        have_last_sequence = true;
      }",36,,978,2,,void
51873,BLOCK,-1,,"{
    if (!have_next_file) {
      s = Status::Corruption(""no meta-nextfile entry in descriptor"");
    } else if (!have_log_number) {
      s = Status::Corruption(""no meta-lognumber entry in descriptor"");
    } else if (!have_last_sequence) {
      s = Status::Corruption(""no last-sequence-number entry in descriptor"");
    }

    if (!have_prev_log_number) {
      prev_log_number = 0;
    }

    MarkFileNumberUsed(prev_log_number);
    MarkFileNumberUsed(log_number);
  }",15,,987,2,,void
51877,BLOCK,-1,,"{
      s = Status::Corruption(""no meta-nextfile entry in descriptor"");
    }",26,,988,2,,void
51886,BLOCK,-1,,<empty>,12,,990,1,,void
51890,BLOCK,-1,,"{
      s = Status::Corruption(""no meta-lognumber entry in descriptor"");
    }",34,,990,2,,void
51899,BLOCK,-1,,<empty>,12,,992,1,,void
51903,BLOCK,-1,,"{
      s = Status::Corruption(""no last-sequence-number entry in descriptor"");
    }",37,,992,2,,void
51914,BLOCK,-1,,"{
      prev_log_number = 0;
    }",32,,996,2,,void
51927,BLOCK,-1,,"{
    Version* v = new Version(this);
    builder.SaveTo(v);
    // Install recovered version
    Finalize(v);
    AppendVersion(v);
    manifest_file_number_ = next_file;
    next_file_number_ = next_file + 1;
    last_sequence_ = last_sequence;
    log_number_ = log_number;
    prev_log_number_ = prev_log_number;

    // See if we can reuse the existing MANIFEST file.
    if (ReuseManifest(dscname, current)) {
      // No need to save new manifest
    } else {
      *save_manifest = true;
    }
  }",15,,1004,2,,void
51964,BLOCK,-1,,"{
      // No need to save new manifest
    }",42,,1017,2,,void
51966,BLOCK,-1,,"{
      *save_manifest = true;
    }",12,,1019,1,,void
51978,BLOCK,-1,,"{
  if (!options_->reuse_logs) {
    return false;
  }
  FileType manifest_type;
  uint64_t manifest_number;
  uint64_t manifest_size;
  if (!ParseFileName(dscbase, &manifest_number, &manifest_type) ||
      manifest_type != kDescriptorFile ||
      !env_->GetFileSize(dscname, &manifest_size).ok() ||
      // Make new compacted MANIFEST if old one is too big
      manifest_size >= TargetFileSize(options_)) {
    return false;
  }

  assert(descriptor_file_ == NULL);
  assert(descriptor_log_ == NULL);
  Status r = env_->NewAppendableFile(dscname, &descriptor_file_);
  if (!r.ok()) {
    Log(options_->info_log, ""Reuse MANIFEST: %s\n"", r.ToString().c_str());
    assert(descriptor_file_ == NULL);
    return false;
  }

  Log(options_->info_log, ""Reusing MANIFEST %s\n"", dscname.c_str());
  descriptor_log_ = new log::Writer(descriptor_file_, manifest_size);
  manifest_file_number_ = manifest_number;
  return true;
}",60,,1028,3,,void
51984,BLOCK,-1,,"{
    return false;
  }",30,,1029,2,,void
52019,BLOCK,-1,,"{
    return false;
  }",50,,1039,2,,void
52046,BLOCK,-1,,"{
    Log(options_->info_log, ""Reuse MANIFEST: %s\n"", r.ToString().c_str());
    assert(descriptor_file_ == NULL);
    return false;
  }",16,,1046,2,,void
52089,BLOCK,-1,,"{
  if (next_file_number_ <= number) {
    next_file_number_ = number + 1;
  }
}",54,,1058,2,,void
52094,BLOCK,-1,,"{
    next_file_number_ = number + 1;
  }",36,,1059,2,,void
52104,BLOCK,-1,,"{
  // Precomputed best level for next compaction
  int best_level = -1;
  double best_score = -1;

  for (int level = 0; level < config::kNumLevels-1; level++) {
    double score;
    if (level == 0) {
      // We treat level-0 specially by bounding the number of files
      // instead of number of bytes for two reasons:
      //
      // (1) With larger write-buffer sizes, it is nice not to do too
      // many level-0 compactions.
      //
      // (2) The files in level-0 are merged on every read and
      // therefore we wish to avoid too many files when the individual
      // file size is small (perhaps because of a small write-buffer
      // setting, or very high compression ratios, or lots of
      // overwrites/deletions).
      score = v->files_[level].size() /
          static_cast<double>(config::kL0_CompactionTrigger);
    } else {
      // Compute the ratio of current size to size limit.
      const uint64_t level_bytes = TotalFileSize(v->files_[level]);
      score ...",39,,1064,2,,void
52116,BLOCK,-1,,<empty>,3,,1069,1,,void
52130,BLOCK,4,,"{
    double score;
    if (level == 0) {
      // We treat level-0 specially by bounding the number of files
      // instead of number of bytes for two reasons:
      //
      // (1) With larger write-buffer sizes, it is nice not to do too
      // many level-0 compactions.
      //
      // (2) The files in level-0 are merged on every read and
      // therefore we wish to avoid too many files when the individual
      // file size is small (perhaps because of a small write-buffer
      // setting, or very high compression ratios, or lots of
      // overwrites/deletions).
      score = v->files_[level].size() /
          static_cast<double>(config::kL0_CompactionTrigger);
    } else {
      // Compute the ratio of current size to size limit.
      const uint64_t level_bytes = TotalFileSize(v->files_[level]);
      score =
          static_cast<double>(level_bytes) / MaxBytesForLevel(options_, level);
    }

    if (score > best_score) {
      best_level = level;
      best_score...",62,,1069,4,,void
52136,BLOCK,-1,,"{
      // We treat level-0 specially by bounding the number of files
      // instead of number of bytes for two reasons:
      //
      // (1) With larger write-buffer sizes, it is nice not to do too
      // many level-0 compactions.
      //
      // (2) The files in level-0 are merged on every read and
      // therefore we wish to avoid too many files when the individual
      // file size is small (perhaps because of a small write-buffer
      // setting, or very high compression ratios, or lots of
      // overwrites/deletions).
      score = v->files_[level].size() /
          static_cast<double>(config::kL0_CompactionTrigger);
    }",21,,1071,2,,void
52154,BLOCK,-1,,"{
      // Compute the ratio of current size to size limit.
      const uint64_t level_bytes = TotalFileSize(v->files_[level]);
      score =
          static_cast<double>(level_bytes) / MaxBytesForLevel(options_, level);
    }",12,,1085,1,,void
52177,BLOCK,-1,,"{
      best_level = level;
      best_score = score;
    }",29,,1092,2,,void
52198,BLOCK,-1,,"{
  // TODO: Break up into multiple records to reduce memory usage on recovery?

  // Save metadata
  VersionEdit edit;
  edit.SetComparatorName(icmp_.user_comparator()->Name());

  // Save compaction pointers
  for (int level = 0; level < config::kNumLevels; level++) {
    if (!compact_pointer_[level].empty()) {
      InternalKey key;
      key.DecodeFrom(compact_pointer_[level]);
      edit.SetCompactPointer(level, key);
    }
  }

  // Save files
  for (int level = 0; level < config::kNumLevels; level++) {
    const std::vector<FileMetaData*>& files = current_->files_[level];
    for (size_t i = 0; i < files.size(); i++) {
      const FileMetaData* f = files[i];
      edit.AddFile(level, f->number, f->file_size, f->smallest, f->largest);
    }
  }

  std::string record;
  edit.EncodeTo(&record);
  return log->AddRecord(record);
}",52,,1102,2,,void
52212,BLOCK,-1,,<empty>,3,,1110,1,,void
52224,BLOCK,4,,"{
    if (!compact_pointer_[level].empty()) {
      InternalKey key;
      key.DecodeFrom(compact_pointer_[level]);
      edit.SetCompactPointer(level, key);
    }
  }",60,,1110,4,,void
52233,BLOCK,-1,,"{
      InternalKey key;
      key.DecodeFrom(compact_pointer_[level]);
      edit.SetCompactPointer(level, key);
    }",43,,1111,2,,void
52249,BLOCK,-1,,<empty>,3,,1119,1,,void
52261,BLOCK,4,,"{
    const std::vector<FileMetaData*>& files = current_->files_[level];
    for (size_t i = 0; i < files.size(); i++) {
      const FileMetaData* f = files[i];
      edit.AddFile(level, f->number, f->file_size, f->smallest, f->largest);
    }
  }",60,,1119,4,,void
52271,BLOCK,-1,,<empty>,5,,1121,1,,void
52284,BLOCK,4,,"{
      const FileMetaData* f = files[i];
      edit.AddFile(level, f->number, f->file_size, f->smallest, f->largest);
    }",47,,1121,4,,void
52325,BLOCK,-1,,"{
  assert(level >= 0);
  assert(level < config::kNumLevels);
  return current_->files_[level].size();
}",48,,1132,2,,void
52349,BLOCK,-1,,"{
  // Update code if kNumLevels changes
  assert(config::kNumLevels == 7);
  snprintf(scratch->buffer, sizeof(scratch->buffer),
           ""files[ %d %d %d %d %d %d %d ]"",
           int(current_->files_[0].size()),
           int(current_->files_[1].size()),
           int(current_->files_[2].size()),
           int(current_->files_[3].size()),
           int(current_->files_[4].size()),
           int(current_->files_[5].size()),
           int(current_->files_[6].size()));
  return scratch->buffer;
}",74,,1138,2,,void
52444,BLOCK,-1,,"{
  uint64_t result = 0;
  for (int level = 0; level < config::kNumLevels; level++) {
    const std::vector<FileMetaData*>& files = v->files_[level];
    for (size_t i = 0; i < files.size(); i++) {
      if (icmp_.Compare(files[i]->largest, ikey) <= 0) {
        // Entire file is before ""ikey"", so just add the file size
        result += files[i]->file_size;
      } else if (icmp_.Compare(files[i]->smallest, ikey) > 0) {
        // Entire file is after ""ikey"", so ignore
        if (level > 0) {
          // Files other than level 0 are sorted by meta->smallest, so
          // no further files in this level will contain data for
          // ""ikey"".
          break;
        }
      } else {
        // ""ikey"" falls in the range for this table.  Add the
        // approximate offset of ""ikey"" within the table.
        Table* tableptr;
        Iterator* iter = table_cache_->NewIterator(
            ReadOptions(), files[i]->number, files[i]->file_size, &tableptr);
        if (tableptr !...",79,,1153,3,,void
52450,BLOCK,-1,,<empty>,3,,1155,1,,void
52462,BLOCK,4,,"{
    const std::vector<FileMetaData*>& files = v->files_[level];
    for (size_t i = 0; i < files.size(); i++) {
      if (icmp_.Compare(files[i]->largest, ikey) <= 0) {
        // Entire file is before ""ikey"", so just add the file size
        result += files[i]->file_size;
      } else if (icmp_.Compare(files[i]->smallest, ikey) > 0) {
        // Entire file is after ""ikey"", so ignore
        if (level > 0) {
          // Files other than level 0 are sorted by meta->smallest, so
          // no further files in this level will contain data for
          // ""ikey"".
          break;
        }
      } else {
        // ""ikey"" falls in the range for this table.  Add the
        // approximate offset of ""ikey"" within the table.
        Table* tableptr;
        Iterator* iter = table_cache_->NewIterator(
            ReadOptions(), files[i]->number, files[i]->file_size, &tableptr);
        if (tableptr != NULL) {
          result += tableptr->ApproximateOffsetOf(ikey.Encode());
        ...",60,,1155,4,,void
52472,BLOCK,-1,,<empty>,5,,1157,1,,void
52485,BLOCK,4,,"{
      if (icmp_.Compare(files[i]->largest, ikey) <= 0) {
        // Entire file is before ""ikey"", so just add the file size
        result += files[i]->file_size;
      } else if (icmp_.Compare(files[i]->smallest, ikey) > 0) {
        // Entire file is after ""ikey"", so ignore
        if (level > 0) {
          // Files other than level 0 are sorted by meta->smallest, so
          // no further files in this level will contain data for
          // ""ikey"".
          break;
        }
      } else {
        // ""ikey"" falls in the range for this table.  Add the
        // approximate offset of ""ikey"" within the table.
        Table* tableptr;
        Iterator* iter = table_cache_->NewIterator(
            ReadOptions(), files[i]->number, files[i]->file_size, &tableptr);
        if (tableptr != NULL) {
          result += tableptr->ApproximateOffsetOf(ikey.Encode());
        }
        delete iter;
      }
    }",47,,1157,4,,void
52499,BLOCK,-1,,"{
        // Entire file is before ""ikey"", so just add the file size
        result += files[i]->file_size;
      }",56,,1158,2,,void
52508,BLOCK,-1,,<empty>,14,,1161,1,,void
52522,BLOCK,-1,,"{
        // Entire file is after ""ikey"", so ignore
        if (level > 0) {
          // Files other than level 0 are sorted by meta->smallest, so
          // no further files in this level will contain data for
          // ""ikey"".
          break;
        }
      }",63,,1161,2,,void
52527,BLOCK,-1,,"{
          // Files other than level 0 are sorted by meta->smallest, so
          // no further files in this level will contain data for
          // ""ikey"".
          break;
        }",24,,1163,2,,void
52530,BLOCK,-1,,"{
        // ""ikey"" falls in the range for this table.  Add the
        // approximate offset of ""ikey"" within the table.
        Table* tableptr;
        Iterator* iter = table_cache_->NewIterator(
            ReadOptions(), files[i]->number, files[i]->file_size, &tableptr);
        if (tableptr != NULL) {
          result += tableptr->ApproximateOffsetOf(ikey.Encode());
        }
        delete iter;
      }",14,,1169,1,,void
52556,BLOCK,-1,,"{
          result += tableptr->ApproximateOffsetOf(ikey.Encode());
        }",31,,1175,2,,void
52575,BLOCK,-1,,"{
  for (Version* v = dummy_versions_.next_;
       v != &dummy_versions_;
       v = v->next_) {
    for (int level = 0; level < config::kNumLevels; level++) {
      const std::vector<FileMetaData*>& files = v->files_[level];
      for (size_t i = 0; i < files.size(); i++) {
        live->insert(files[i]->number);
      }
    }
  }
}",57,,1185,2,,void
52577,BLOCK,-1,,<empty>,3,,1186,1,,void
52593,BLOCK,4,,"{
    for (int level = 0; level < config::kNumLevels; level++) {
      const std::vector<FileMetaData*>& files = v->files_[level];
      for (size_t i = 0; i < files.size(); i++) {
        live->insert(files[i]->number);
      }
    }
  }",22,,1188,4,,void
52595,BLOCK,-1,,<empty>,5,,1189,1,,void
52607,BLOCK,4,,"{
      const std::vector<FileMetaData*>& files = v->files_[level];
      for (size_t i = 0; i < files.size(); i++) {
        live->insert(files[i]->number);
      }
    }",62,,1189,4,,void
52617,BLOCK,-1,,<empty>,7,,1191,1,,void
52630,BLOCK,4,,"{
        live->insert(files[i]->number);
      }",49,,1191,4,,void
52644,BLOCK,-1,,"{
  assert(level >= 0);
  assert(level < config::kNumLevels);
  return TotalFileSize(current_->files_[level]);
}",52,,1198,2,,void
52665,BLOCK,-1,,"{
  int64_t result = 0;
  std::vector<FileMetaData*> overlaps;
  for (int level = 1; level < config::kNumLevels - 1; level++) {
    for (size_t i = 0; i < current_->files_[level].size(); i++) {
      const FileMetaData* f = current_->files_[level][i];
      current_->GetOverlappingInputs(level+1, &f->smallest, &f->largest,
                                     &overlaps);
      const int64_t sum = TotalFileSize(overlaps);
      if (sum > result) {
        result = sum;
      }
    }
  }
  return result;
}",52,,1204,1,,void
52672,BLOCK,-1,,<empty>,3,,1207,1,,void
52686,BLOCK,4,,"{
    for (size_t i = 0; i < current_->files_[level].size(); i++) {
      const FileMetaData* f = current_->files_[level][i];
      current_->GetOverlappingInputs(level+1, &f->smallest, &f->largest,
                                     &overlaps);
      const int64_t sum = TotalFileSize(overlaps);
      if (sum > result) {
        result = sum;
      }
    }
  }",64,,1207,4,,void
52688,BLOCK,-1,,<empty>,5,,1208,1,,void
52705,BLOCK,4,,"{
      const FileMetaData* f = current_->files_[level][i];
      current_->GetOverlappingInputs(level+1, &f->smallest, &f->largest,
                                     &overlaps);
      const int64_t sum = TotalFileSize(overlaps);
      if (sum > result) {
        result = sum;
      }
    }",65,,1208,4,,void
52742,BLOCK,-1,,"{
        result = sum;
      }",25,,1213,2,,void
52754,BLOCK,-1,,"{
  assert(!inputs.empty());
  smallest->Clear();
  largest->Clear();
  for (size_t i = 0; i < inputs.size(); i++) {
    FileMetaData* f = inputs[i];
    if (i == 0) {
      *smallest = f->smallest;
      *largest = f->largest;
    } else {
      if (icmp_.Compare(f->smallest, *smallest) < 0) {
        *smallest = f->smallest;
      }
      if (icmp_.Compare(f->largest, *largest) > 0) {
        *largest = f->largest;
      }
    }
  }
}",49,,1226,4,,void
52770,BLOCK,-1,,<empty>,3,,1230,1,,void
52783,BLOCK,4,,"{
    FileMetaData* f = inputs[i];
    if (i == 0) {
      *smallest = f->smallest;
      *largest = f->largest;
    } else {
      if (icmp_.Compare(f->smallest, *smallest) < 0) {
        *smallest = f->smallest;
      }
      if (icmp_.Compare(f->largest, *largest) > 0) {
        *largest = f->largest;
      }
    }
  }",46,,1230,4,,void
52794,BLOCK,-1,,"{
      *smallest = f->smallest;
      *largest = f->largest;
    }",17,,1232,2,,void
52808,BLOCK,-1,,"{
      if (icmp_.Compare(f->smallest, *smallest) < 0) {
        *smallest = f->smallest;
      }
      if (icmp_.Compare(f->largest, *largest) > 0) {
        *largest = f->largest;
      }
    }",12,,1235,1,,void
52821,BLOCK,-1,,"{
        *smallest = f->smallest;
      }",54,,1236,2,,void
52840,BLOCK,-1,,"{
        *largest = f->largest;
      }",52,,1239,2,,void
52854,BLOCK,-1,,"{
  std::vector<FileMetaData*> all = inputs1;
  all.insert(all.end(), inputs2.begin(), inputs2.end());
  GetRange(all, smallest, largest);
}",50,,1252,5,,void
52883,BLOCK,-1,,"{
  ReadOptions options;
  options.verify_checksums = options_->paranoid_checks;
  options.fill_cache = false;

  // Level-0 files have to be merged together.  For other levels,
  // we will make a concatenating iterator per level.
  // TODO(opt): use concatenating iterator for level-0 if there is no overlap
  const int space = (c->level() == 0 ? c->inputs_[0].size() + 1 : 2);
  Iterator** list = new Iterator*[space];
  int num = 0;
  for (int which = 0; which < 2; which++) {
    if (!c->inputs_[which].empty()) {
      if (c->level() + which == 0) {
        const std::vector<FileMetaData*>& files = c->inputs_[which];
        for (size_t i = 0; i < files.size(); i++) {
          list[num++] = table_cache_->NewIterator(
              options, files[i]->number, files[i]->file_size);
        }
      } else {
        // Create concatenating iterator for the files from this level
        list[num++] = NewTwoLevelIterator(
            new Version::LevelFileNumIterator(icmp_, &c->inputs_[wh...",56,,1258,2,,void
52928,BLOCK,-1,,<empty>,3,,1269,1,,void
52938,BLOCK,4,,"{
    if (!c->inputs_[which].empty()) {
      if (c->level() + which == 0) {
        const std::vector<FileMetaData*>& files = c->inputs_[which];
        for (size_t i = 0; i < files.size(); i++) {
          list[num++] = table_cache_->NewIterator(
              options, files[i]->number, files[i]->file_size);
        }
      } else {
        // Create concatenating iterator for the files from this level
        list[num++] = NewTwoLevelIterator(
            new Version::LevelFileNumIterator(icmp_, &c->inputs_[which]),
            &GetFileIterator, table_cache_, options);
      }
    }
  }",43,,1269,4,,void
52949,BLOCK,-1,,"{
      if (c->level() + which == 0) {
        const std::vector<FileMetaData*>& files = c->inputs_[which];
        for (size_t i = 0; i < files.size(); i++) {
          list[num++] = table_cache_->NewIterator(
              options, files[i]->number, files[i]->file_size);
        }
      } else {
        // Create concatenating iterator for the files from this level
        list[num++] = NewTwoLevelIterator(
            new Version::LevelFileNumIterator(icmp_, &c->inputs_[which]),
            &GetFileIterator, table_cache_, options);
      }
    }",37,,1270,2,,void
52959,BLOCK,-1,,"{
        const std::vector<FileMetaData*>& files = c->inputs_[which];
        for (size_t i = 0; i < files.size(); i++) {
          list[num++] = table_cache_->NewIterator(
              options, files[i]->number, files[i]->file_size);
        }
      }",36,,1271,2,,void
52969,BLOCK,-1,,<empty>,9,,1273,1,,void
52982,BLOCK,4,,"{
          list[num++] = table_cache_->NewIterator(
              options, files[i]->number, files[i]->file_size);
        }",51,,1273,4,,void
53004,BLOCK,-1,,"{
        // Create concatenating iterator for the files from this level
        list[num++] = NewTwoLevelIterator(
            new Version::LevelFileNumIterator(icmp_, &c->inputs_[which]),
            &GetFileIterator, table_cache_, options);
      }",14,,1277,1,,void
53043,BLOCK,-1,,"{
  Compaction* c;
  int level;

  // We prefer compactions triggered by too much data in a level over
  // the compactions triggered by seeks.
  const bool size_compaction = (current_->compaction_score_ >= 1);
  const bool seek_compaction = (current_->file_to_compact_ != NULL);
  if (size_compaction) {
    level = current_->compaction_level_;
    assert(level >= 0);
    assert(level+1 < config::kNumLevels);
    c = new Compaction(options_, level);

    // Pick the first file that comes after compact_pointer_[level]
    for (size_t i = 0; i < current_->files_[level].size(); i++) {
      FileMetaData* f = current_->files_[level][i];
      if (compact_pointer_[level].empty() ||
          icmp_.Compare(f->largest.Encode(), compact_pointer_[level]) > 0) {
        c->inputs_[0].push_back(f);
        break;
      }
    }
    if (c->inputs_[0].empty()) {
      // Wrap-around to the beginning of the key space
      c->inputs_[0].push_back(current_->files_[level][0]);
    }
  } else if (seek...",42,,1291,1,,void
53064,BLOCK,-1,,"{
    level = current_->compaction_level_;
    assert(level >= 0);
    assert(level+1 < config::kNumLevels);
    c = new Compaction(options_, level);

    // Pick the first file that comes after compact_pointer_[level]
    for (size_t i = 0; i < current_->files_[level].size(); i++) {
      FileMetaData* f = current_->files_[level][i];
      if (compact_pointer_[level].empty() ||
          icmp_.Compare(f->largest.Encode(), compact_pointer_[level]) > 0) {
        c->inputs_[0].push_back(f);
        break;
      }
    }
    if (c->inputs_[0].empty()) {
      // Wrap-around to the beginning of the key space
      c->inputs_[0].push_back(current_->files_[level][0]);
    }
  }",24,,1299,2,,void
53089,BLOCK,-1,,<empty>,5,,1306,1,,void
53106,BLOCK,4,,"{
      FileMetaData* f = current_->files_[level][i];
      if (compact_pointer_[level].empty() ||
          icmp_.Compare(f->largest.Encode(), compact_pointer_[level]) > 0) {
        c->inputs_[0].push_back(f);
        break;
      }
    }",65,,1306,4,,void
53140,BLOCK,-1,,"{
        c->inputs_[0].push_back(f);
        break;
      }",76,,1309,2,,void
53160,BLOCK,-1,,"{
      // Wrap-around to the beginning of the key space
      c->inputs_[0].push_back(current_->files_[level][0]);
    }",32,,1314,2,,void
53177,BLOCK,-1,,<empty>,10,,1318,1,,void
53180,BLOCK,-1,,"{
    level = current_->file_to_compact_level_;
    c = new Compaction(options_, level);
    c->inputs_[0].push_back(current_->file_to_compact_);
  }",31,,1318,2,,void
53204,BLOCK,-1,,"{
    return NULL;
  }",10,,1322,1,,void
53222,BLOCK,-1,,"{
    InternalKey smallest, largest;
    GetRange(c->inputs_[0], &smallest, &largest);
    // Note that the next call will discard the file we placed in
    // c->inputs_[0] earlier and replace it with an overlapping set
    // which will include the picked file.
    current_->GetOverlappingInputs(0, &smallest, &largest, &c->inputs_[0]);
    assert(!c->inputs_[0].empty());
  }",19,,1330,2,,void
53268,BLOCK,-1,,"{
  const int level = c->level();
  InternalKey smallest, largest;
  GetRange(c->inputs_[0], &smallest, &largest);

  current_->GetOverlappingInputs(level+1, &smallest, &largest, &c->inputs_[1]);

  // Get entire range covered by compaction
  InternalKey all_start, all_limit;
  GetRange2(c->inputs_[0], c->inputs_[1], &all_start, &all_limit);

  // See if we can grow the number of inputs in ""level"" without
  // changing the number of ""level+1"" files we pick up.
  if (!c->inputs_[1].empty()) {
    std::vector<FileMetaData*> expanded0;
    current_->GetOverlappingInputs(level, &all_start, &all_limit, &expanded0);
    const int64_t inputs0_size = TotalFileSize(c->inputs_[0]);
    const int64_t inputs1_size = TotalFileSize(c->inputs_[1]);
    const int64_t expanded0_size = TotalFileSize(expanded0);
    if (expanded0.size() > c->inputs_[0].size() &&
        inputs1_size + expanded0_size <
            ExpandedCompactionByteSizeLimit(options_)) {
      InternalKey new_start, new_limit;
    ...",50,,1345,2,,void
53332,BLOCK,-1,,"{
    std::vector<FileMetaData*> expanded0;
    current_->GetOverlappingInputs(level, &all_start, &all_limit, &expanded0);
    const int64_t inputs0_size = TotalFileSize(c->inputs_[0]);
    const int64_t inputs1_size = TotalFileSize(c->inputs_[1]);
    const int64_t expanded0_size = TotalFileSize(expanded0);
    if (expanded0.size() > c->inputs_[0].size() &&
        inputs1_size + expanded0_size <
            ExpandedCompactionByteSizeLimit(options_)) {
      InternalKey new_start, new_limit;
      GetRange(expanded0, &new_start, &new_limit);
      std::vector<FileMetaData*> expanded1;
      current_->GetOverlappingInputs(level+1, &new_start, &new_limit,
                                     &expanded1);
      if (expanded1.size() == c->inputs_[1].size()) {
        Log(options_->info_log,
            ""Expanding@%d %d+%d (%ld+%ld bytes) to %d+%d (%ld+%ld bytes)\n"",
            level,
            int(c->inputs_[0].size()),
            int(c->inputs_[1].size()),
            long(inputs0...",31,,1358,2,,void
53389,BLOCK,-1,,"{
      InternalKey new_start, new_limit;
      GetRange(expanded0, &new_start, &new_limit);
      std::vector<FileMetaData*> expanded1;
      current_->GetOverlappingInputs(level+1, &new_start, &new_limit,
                                     &expanded1);
      if (expanded1.size() == c->inputs_[1].size()) {
        Log(options_->info_log,
            ""Expanding@%d %d+%d (%ld+%ld bytes) to %d+%d (%ld+%ld bytes)\n"",
            level,
            int(c->inputs_[0].size()),
            int(c->inputs_[1].size()),
            long(inputs0_size), long(inputs1_size),
            int(expanded0.size()),
            int(expanded1.size()),
            long(expanded0_size), long(inputs1_size));
        smallest = new_start;
        largest = new_limit;
        c->inputs_[0] = expanded0;
        c->inputs_[1] = expanded1;
        GetRange2(c->inputs_[0], c->inputs_[1], &all_start, &all_limit);
      }
    }",56,,1366,2,,void
53426,BLOCK,-1,,"{
        Log(options_->info_log,
            ""Expanding@%d %d+%d (%ld+%ld bytes) to %d+%d (%ld+%ld bytes)\n"",
            level,
            int(c->inputs_[0].size()),
            int(c->inputs_[1].size()),
            long(inputs0_size), long(inputs1_size),
            int(expanded0.size()),
            int(expanded1.size()),
            long(expanded0_size), long(inputs1_size));
        smallest = new_start;
        largest = new_limit;
        c->inputs_[0] = expanded0;
        c->inputs_[1] = expanded1;
        GetRange2(c->inputs_[0], c->inputs_[1], &all_start, &all_limit);
      }",53,,1372,2,,void
53520,BLOCK,-1,,"{
    current_->GetOverlappingInputs(level + 2, &all_start, &all_limit,
                                   &c->grandparents_);
  }",39,,1393,2,,void
53538,BLOCK,-1,,"{
    Log(options_->info_log, ""Compacting %d '%s' .. '%s'"",
        level,
        smallest.DebugString().c_str(),
        largest.DebugString().c_str());
  }",14,,1398,2,,void
53584,BLOCK,-1,,"{
  std::vector<FileMetaData*> inputs;
  current_->GetOverlappingInputs(level, begin, end, &inputs);
  if (inputs.empty()) {
    return NULL;
  }

  // Avoid compacting too much in one shot in case the range is large.
  // But we cannot do this for level-0 since level-0 files can overlap
  // and we must not pick one file and drop another older file if the
  // two files overlap.
  if (level > 0) {
    const uint64_t limit = MaxFileSizeForLevel(options_, level);
    uint64_t total = 0;
    for (size_t i = 0; i < inputs.size(); i++) {
      uint64_t s = inputs[i]->file_size;
      total += s;
      if (total >= limit) {
        inputs.resize(i + 1);
        break;
      }
    }
  }

  Compaction* c = new Compaction(options_, level);
  c->input_version_ = current_;
  c->input_version_->Ref();
  c->inputs_[0] = inputs;
  SetupOtherInputs(c);
  return c;
}",29,,1416,4,,void
53600,BLOCK,-1,,"{
    return NULL;
  }",23,,1419,2,,void
53607,BLOCK,-1,,"{
    const uint64_t limit = MaxFileSizeForLevel(options_, level);
    uint64_t total = 0;
    for (size_t i = 0; i < inputs.size(); i++) {
      uint64_t s = inputs[i]->file_size;
      total += s;
      if (total >= limit) {
        inputs.resize(i + 1);
        break;
      }
    }
  }",18,,1427,2,,void
53619,BLOCK,-1,,<empty>,5,,1430,1,,void
53632,BLOCK,4,,"{
      uint64_t s = inputs[i]->file_size;
      total += s;
      if (total >= limit) {
        inputs.resize(i + 1);
        break;
      }
    }",48,,1430,4,,void
53648,BLOCK,-1,,"{
        inputs.resize(i + 1);
        break;
      }",27,,1433,2,,void
53691,BLOCK,-1,,"{
  for (int i = 0; i < config::kNumLevels; i++) {
    level_ptrs_[i] = 0;
  }
}",28,,1454,3,,void
53693,BLOCK,-1,,<empty>,3,,1455,1,,void
53705,BLOCK,4,,"{
    level_ptrs_[i] = 0;
  }",48,,1455,4,,void
53714,BLOCK,-1,,"{
  if (input_version_ != NULL) {
    input_version_->Unref();
  }
}",27,,1460,1,,void
53719,BLOCK,-1,,"{
    input_version_->Unref();
  }",31,,1461,2,,void
53727,BLOCK,-1,,"{
  const VersionSet* vset = input_version_->vset_;
  // Avoid a move if there is lots of overlapping grandparent data.
  // Otherwise, the move could create a parent file that will require
  // a very expensive merge later on.
  return (num_input_files(0) == 1 && num_input_files(1) == 0 &&
          TotalFileSize(grandparents_) <=
              MaxGrandParentOverlapBytes(vset->options_));
}",40,,1466,1,,void
53756,BLOCK,-1,,"{
  for (int which = 0; which < 2; which++) {
    for (size_t i = 0; i < inputs_[which].size(); i++) {
      edit->DeleteFile(level_ + which, inputs_[which][i]->number);
    }
  }
}",55,,1476,2,,void
53758,BLOCK,-1,,<empty>,3,,1477,1,,void
53768,BLOCK,4,,"{
    for (size_t i = 0; i < inputs_[which].size(); i++) {
      edit->DeleteFile(level_ + which, inputs_[which][i]->number);
    }
  }",43,,1477,4,,void
53770,BLOCK,-1,,<empty>,5,,1478,1,,void
53785,BLOCK,4,,"{
      edit->DeleteFile(level_ + which, inputs_[which][i]->number);
    }",56,,1478,4,,void
53804,BLOCK,-1,,"{
  // Maybe use binary search to find right entry instead of linear search?
  const Comparator* user_cmp = input_version_->vset_->icmp_.user_comparator();
  for (int lvl = level_ + 2; lvl < config::kNumLevels; lvl++) {
    const std::vector<FileMetaData*>& files = input_version_->files_[lvl];
    for (; level_ptrs_[lvl] < files.size(); ) {
      FileMetaData* f = files[level_ptrs_[lvl]];
      if (user_cmp->Compare(user_key, f->largest.user_key()) <= 0) {
        // We've advanced far enough
        if (user_cmp->Compare(user_key, f->smallest.user_key()) >= 0) {
          // Key falls in this file's range, so definitely not base level
          return false;
        }
        break;
      }
      level_ptrs_[lvl]++;
    }
  }
  return true;
}",59,,1484,2,,void
53817,BLOCK,-1,,<empty>,3,,1487,1,,void
53831,BLOCK,4,,"{
    const std::vector<FileMetaData*>& files = input_version_->files_[lvl];
    for (; level_ptrs_[lvl] < files.size(); ) {
      FileMetaData* f = files[level_ptrs_[lvl]];
      if (user_cmp->Compare(user_key, f->largest.user_key()) <= 0) {
        // We've advanced far enough
        if (user_cmp->Compare(user_key, f->smallest.user_key()) >= 0) {
          // Key falls in this file's range, so definitely not base level
          return false;
        }
        break;
      }
      level_ptrs_[lvl]++;
    }
  }",63,,1487,4,,void
53841,BLOCK,-1,,<empty>,5,,1489,1,,void
53850,BLOCK,4,,"{
      FileMetaData* f = files[level_ptrs_[lvl]];
      if (user_cmp->Compare(user_key, f->largest.user_key()) <= 0) {
        // We've advanced far enough
        if (user_cmp->Compare(user_key, f->smallest.user_key()) >= 0) {
          // Key falls in this file's range, so definitely not base level
          return false;
        }
        break;
      }
      level_ptrs_[lvl]++;
    }",47,,1489,4,,void
53873,BLOCK,-1,,"{
        // We've advanced far enough
        if (user_cmp->Compare(user_key, f->smallest.user_key()) >= 0) {
          // Key falls in this file's range, so definitely not base level
          return false;
        }
        break;
      }",68,,1491,2,,void
53888,BLOCK,-1,,"{
          // Key falls in this file's range, so definitely not base level
          return false;
        }",71,,1493,2,,void
53902,BLOCK,-1,,"{
  const VersionSet* vset = input_version_->vset_;
  // Scan to find earliest grandparent file that contains key.
  const InternalKeyComparator* icmp = &vset->icmp_;
  while (grandparent_index_ < grandparents_.size() &&
      icmp->Compare(internal_key,
                    grandparents_[grandparent_index_]->largest.Encode()) > 0) {
    if (seen_key_) {
      overlapped_bytes_ += grandparents_[grandparent_index_]->file_size;
    }
    grandparent_index_++;
  }
  seen_key_ = true;

  if (overlapped_bytes_ > MaxGrandParentOverlapBytes(vset->options_)) {
    // Too much overlap for current output; start new output
    overlapped_bytes_ = 0;
    return true;
  } else {
    return false;
  }
}",62,,1505,2,,void
53939,BLOCK,-1,,"{
    if (seen_key_) {
      overlapped_bytes_ += grandparents_[grandparent_index_]->file_size;
    }
    grandparent_index_++;
  }",79,,1511,2,,void
53942,BLOCK,-1,,"{
      overlapped_bytes_ += grandparents_[grandparent_index_]->file_size;
    }",20,,1512,2,,void
53962,BLOCK,-1,,"{
    // Too much overlap for current output; start new output
    overlapped_bytes_ = 0;
    return true;
  }",71,,1519,2,,void
53969,BLOCK,-1,,"{
    return false;
  }",10,,1523,1,,void
53975,BLOCK,-1,,"{
  if (input_version_ != NULL) {
    input_version_->Unref();
    input_version_ = NULL;
  }
}",34,,1528,1,,void
53980,BLOCK,-1,,"{
    input_version_->Unref();
    input_version_ = NULL;
  }",31,,1529,2,,void
54008,BLOCK,-1,,<empty>,1,,1,1,,ANY
54024,BLOCK,-1,,<empty>,,,,4,,<empty>
54033,BLOCK,-1,,<empty>,,,,6,,<empty>
54040,BLOCK,-1,,<empty>,,,,3,,<empty>
54051,BLOCK,-1,,<empty>,,,,5,,<empty>
54056,BLOCK,-1,,<empty>,,,,2,,<empty>
54061,BLOCK,-1,,<empty>,,,,2,,<empty>
54065,BLOCK,-1,,<empty>,,,,1,,<empty>
54069,BLOCK,-1,,<empty>,,,,1,,<empty>
54077,BLOCK,-1,,<empty>,,,,5,,<empty>
54084,BLOCK,-1,,<empty>,,,,4,,<empty>
54090,BLOCK,-1,,<empty>,,,,3,,<empty>
54095,BLOCK,-1,,{ return files_[level].size(); },33,,111,2,,void
54106,BLOCK,-1,,<empty>,,,,1,,<empty>
54115,BLOCK,-1,,<empty>,,,,3,,<empty>
54123,BLOCK,-1,,<empty>,,,,5,,<empty>
54137,BLOCK,-1,,"{
  }",31,,155,2,,void
54141,BLOCK,-1,,<empty>,,,,1,,<empty>
54146,BLOCK,-1,,<empty>,,,,2,,<empty>
54151,BLOCK,-1,,<empty>,,,,2,,<empty>
54155,BLOCK,-1,,<empty>,,,,1,,<empty>
54168,BLOCK,-1,,<empty>,,,,5,,<empty>
54172,BLOCK,-1,,<empty>,,,,1,,<empty>
54178,BLOCK,-1,,<empty>,,,,3,,<empty>
54183,BLOCK,-1,,<empty>,,,,2,,<empty>
54187,BLOCK,-1,,{ return current_; },28,,185,1,,void
54193,BLOCK,-1,,{ return manifest_file_number_; },39,,188,1,,void
54199,BLOCK,-1,,{ return next_file_number_++; },28,,191,1,,void
54207,BLOCK,-1,,"{
    if (next_file_number_ == file_number + 1) {
      next_file_number_ = file_number;
    }
  }",46,,196,2,,void
54214,BLOCK,-1,,"{
      next_file_number_ = file_number;
    }",47,,197,2,,void
54222,BLOCK,-1,,<empty>,,,,2,,<empty>
54227,BLOCK,-1,,<empty>,,,,2,,<empty>
54231,BLOCK,-1,,{ return last_sequence_; },33,,209,1,,void
54238,BLOCK,-1,,"{
    assert(s >= last_sequence_);
    last_sequence_ = s;
  }",36,,212,2,,void
54250,BLOCK,-1,,<empty>,,,,2,,<empty>
54254,BLOCK,-1,,{ return log_number_; },30,,221,1,,void
54260,BLOCK,-1,,{ return prev_log_number_; },34,,225,1,,void
54266,BLOCK,-1,,<empty>,,,,1,,<empty>
54273,BLOCK,-1,,<empty>,,,,4,,<empty>
54277,BLOCK,-1,,<empty>,,,,1,,<empty>
54282,BLOCK,-1,,<empty>,,,,2,,<empty>
54286,BLOCK,-1,,"{
    Version* v = current_;
    return (v->compaction_score_ >= 1) || (v->file_to_compact_ != NULL);
  }",32,,251,1,,void
54307,BLOCK,-1,,<empty>,,,,2,,<empty>
54313,BLOCK,-1,,<empty>,,,,3,,<empty>
54319,BLOCK,-1,,<empty>,,,,1,,<empty>
54326,BLOCK,-1,,<empty>,,,,2,,<empty>
54335,BLOCK,-1,,<empty>,,,,3,,<empty>
54340,BLOCK,-1,,<empty>,,,,2,,<empty>
54347,BLOCK,-1,,<empty>,,,,4,,<empty>
54355,BLOCK,-1,,<empty>,,,,5,,<empty>
54360,BLOCK,-1,,<empty>,,,,2,,<empty>
54365,BLOCK,-1,,<empty>,,,,2,,<empty>
54370,BLOCK,-1,,<empty>,,,,2,,<empty>
54390,BLOCK,-1,,<empty>,,,,2,,<empty>
54395,BLOCK,-1,,<empty>,,,,2,,<empty>
54399,BLOCK,-1,,<empty>,,,,1,,<empty>
54408,BLOCK,-1,,<empty>,,,,1,,<empty>
54412,BLOCK,-1,,{ return level_; },21,,330,1,,void
54418,BLOCK,-1,,{ return &edit_; },23,,334,1,,void
54426,BLOCK,-1,,{ return inputs_[which].size(); },40,,337,2,,void
54439,BLOCK,-1,,{ return inputs_[which][i]; },47,,340,3,,void
54449,BLOCK,-1,,{ return max_output_file_size_; },38,,343,1,,void
54455,BLOCK,-1,,<empty>,,,,1,,<empty>
54460,BLOCK,-1,,<empty>,,,,2,,<empty>
54465,BLOCK,-1,,<empty>,,,,2,,<empty>
54470,BLOCK,-1,,<empty>,,,,2,,<empty>
54474,BLOCK,-1,,<empty>,,,,1,,<empty>
54482,BLOCK,-1,,<empty>,,,,3,,<empty>
54496,BLOCK,-1,,<empty>,,,,1,,<empty>
54517,BLOCK,-1,,<empty>,1,,1,1,,ANY
54523,BLOCK,-1,,{ },49,,17,1,,void
54527,BLOCK,-1,,"{
    for (int i = 0; i < files_.size(); i++) {
      delete files_[i];
    }
  }",19,,19,1,,void
54529,BLOCK,-1,,<empty>,5,,20,1,,void
54542,BLOCK,4,,"{
      delete files_[i];
    }",45,,20,4,,void
54554,BLOCK,-1,,"{
    FileMetaData* f = new FileMetaData;
    f->number = files_.size() + 1;
    f->smallest = InternalKey(smallest, smallest_seq, kTypeValue);
    f->largest = InternalKey(largest, largest_seq, kTypeValue);
    files_.push_back(f);
  }",46,,27,5,,void
54595,BLOCK,-1,,"{
    InternalKey target(key, 100, kTypeValue);
    InternalKeyComparator cmp(BytewiseComparator());
    return FindFile(cmp, files_, target.Encode());
  }",29,,35,2,,void
54617,BLOCK,-1,,"{
    InternalKeyComparator cmp(BytewiseComparator());
    Slice s(smallest != NULL ? smallest : """");
    Slice l(largest != NULL ? largest : """");
    return SomeFileOverlapsRange(cmp, disjoint_sorted_files_, files_,
                                 (smallest != NULL ? &s : NULL),
                                 (largest != NULL ? &l : NULL));
  }",60,,41,3,,void
54660,BLOCK,-1,,<empty>,,,,1,,<empty>
54664,BLOCK,-1,,"TEST(FindFileTest, Empty)",1,,51,1,,void
54688,BLOCK,-1,,"{
  ASSERT_EQ(0, Find(""foo""));
  ASSERT_TRUE(! Overlaps(""a"", ""z""));
  ASSERT_TRUE(! Overlaps(NULL, ""z""));
  ASSERT_TRUE(! Overlaps(""a"", NULL));
  ASSERT_TRUE(! Overlaps(NULL, NULL));
}",27,,51,1,,void
54693,BLOCK,1,,<empty>,,,,3,,void
54709,BLOCK,1,,<empty>,,,,1,,void
54727,BLOCK,1,,<empty>,,,,1,,void
54745,BLOCK,1,,<empty>,,,,1,,void
54763,BLOCK,1,,<empty>,,,,1,,void
54784,BLOCK,-1,,<empty>,,,,1,,<empty>
54788,BLOCK,-1,,"TEST(FindFileTest, Single)",1,,59,1,,void
54812,BLOCK,-1,,"{
  Add(""p"", ""q"");
  ASSERT_EQ(0, Find(""a""));
  ASSERT_EQ(0, Find(""p""));
  ASSERT_EQ(0, Find(""p1""));
  ASSERT_EQ(0, Find(""q""));
  ASSERT_EQ(1, Find(""q1""));
  ASSERT_EQ(1, Find(""z""));

  ASSERT_TRUE(! Overlaps(""a"", ""b""));
  ASSERT_TRUE(! Overlaps(""z1"", ""z2""));
  ASSERT_TRUE(Overlaps(""a"", ""p""));
  ASSERT_TRUE(Overlaps(""a"", ""q""));
  ASSERT_TRUE(Overlaps(""a"", ""z""));
  ASSERT_TRUE(Overlaps(""p"", ""p1""));
  ASSERT_TRUE(Overlaps(""p"", ""q""));
  ASSERT_TRUE(Overlaps(""p"", ""z""));
  ASSERT_TRUE(Overlaps(""p1"", ""p2""));
  ASSERT_TRUE(Overlaps(""p1"", ""z""));
  ASSERT_TRUE(Overlaps(""q"", ""q""));
  ASSERT_TRUE(Overlaps(""q"", ""q1""));

  ASSERT_TRUE(! Overlaps(NULL, ""j""));
  ASSERT_TRUE(! Overlaps(""r"", NULL));
  ASSERT_TRUE(Overlaps(NULL, ""p""));
  ASSERT_TRUE(Overlaps(NULL, ""p1""));
  ASSERT_TRUE(Overlaps(""q"", NULL));
  ASSERT_TRUE(Overlaps(NULL, NULL));
}",28,,59,1,,void
54820,BLOCK,1,,<empty>,,,,3,,void
54839,BLOCK,1,,<empty>,,,,3,,void
54858,BLOCK,1,,<empty>,,,,3,,void
54877,BLOCK,1,,<empty>,,,,3,,void
54896,BLOCK,1,,<empty>,,,,3,,void
54915,BLOCK,1,,<empty>,,,,3,,void
54931,BLOCK,1,,<empty>,,,,1,,void
54949,BLOCK,1,,<empty>,,,,1,,void
54967,BLOCK,1,,<empty>,,,,1,,void
54984,BLOCK,1,,<empty>,,,,1,,void
55001,BLOCK,1,,<empty>,,,,1,,void
55018,BLOCK,1,,<empty>,,,,1,,void
55035,BLOCK,1,,<empty>,,,,1,,void
55052,BLOCK,1,,<empty>,,,,1,,void
55069,BLOCK,1,,<empty>,,,,1,,void
55086,BLOCK,1,,<empty>,,,,1,,void
55103,BLOCK,1,,<empty>,,,,1,,void
55120,BLOCK,1,,<empty>,,,,1,,void
55137,BLOCK,1,,<empty>,,,,1,,void
55155,BLOCK,1,,<empty>,,,,1,,void
55173,BLOCK,1,,<empty>,,,,1,,void
55190,BLOCK,1,,<empty>,,,,1,,void
55207,BLOCK,1,,<empty>,,,,1,,void
55224,BLOCK,1,,<empty>,,,,1,,void
55244,BLOCK,-1,,<empty>,,,,1,,<empty>
55248,BLOCK,-1,,"TEST(FindFileTest, Multiple)",1,,90,1,,void
55272,BLOCK,-1,,"{
  Add(""150"", ""200"");
  Add(""200"", ""250"");
  Add(""300"", ""350"");
  Add(""400"", ""450"");
  ASSERT_EQ(0, Find(""100""));
  ASSERT_EQ(0, Find(""150""));
  ASSERT_EQ(0, Find(""151""));
  ASSERT_EQ(0, Find(""199""));
  ASSERT_EQ(0, Find(""200""));
  ASSERT_EQ(1, Find(""201""));
  ASSERT_EQ(1, Find(""249""));
  ASSERT_EQ(1, Find(""250""));
  ASSERT_EQ(2, Find(""251""));
  ASSERT_EQ(2, Find(""299""));
  ASSERT_EQ(2, Find(""300""));
  ASSERT_EQ(2, Find(""349""));
  ASSERT_EQ(2, Find(""350""));
  ASSERT_EQ(3, Find(""351""));
  ASSERT_EQ(3, Find(""400""));
  ASSERT_EQ(3, Find(""450""));
  ASSERT_EQ(4, Find(""451""));

  ASSERT_TRUE(! Overlaps(""100"", ""149""));
  ASSERT_TRUE(! Overlaps(""251"", ""299""));
  ASSERT_TRUE(! Overlaps(""451"", ""500""));
  ASSERT_TRUE(! Overlaps(""351"", ""399""));

  ASSERT_TRUE(Overlaps(""100"", ""150""));
  ASSERT_TRUE(Overlaps(""100"", ""200""));
  ASSERT_TRUE(Overlaps(""100"", ""300""));
  ASSERT_TRUE(Overlaps(""100"", ""400""));
  ASSERT_TRUE(Overlaps(""100"", ""500""));
  ASSERT_TRUE(Overlaps(""375"", ""400""));
  ASSERT_TRUE(Over...",30,,90,1,,void
55289,BLOCK,1,,<empty>,,,,3,,void
55308,BLOCK,1,,<empty>,,,,3,,void
55327,BLOCK,1,,<empty>,,,,3,,void
55346,BLOCK,1,,<empty>,,,,3,,void
55365,BLOCK,1,,<empty>,,,,3,,void
55384,BLOCK,1,,<empty>,,,,3,,void
55403,BLOCK,1,,<empty>,,,,3,,void
55422,BLOCK,1,,<empty>,,,,3,,void
55441,BLOCK,1,,<empty>,,,,3,,void
55460,BLOCK,1,,<empty>,,,,3,,void
55479,BLOCK,1,,<empty>,,,,3,,void
55498,BLOCK,1,,<empty>,,,,3,,void
55517,BLOCK,1,,<empty>,,,,3,,void
55536,BLOCK,1,,<empty>,,,,3,,void
55555,BLOCK,1,,<empty>,,,,3,,void
55574,BLOCK,1,,<empty>,,,,3,,void
55593,BLOCK,1,,<empty>,,,,3,,void
55609,BLOCK,1,,<empty>,,,,1,,void
55627,BLOCK,1,,<empty>,,,,1,,void
55645,BLOCK,1,,<empty>,,,,1,,void
55663,BLOCK,1,,<empty>,,,,1,,void
55681,BLOCK,1,,<empty>,,,,1,,void
55698,BLOCK,1,,<empty>,,,,1,,void
55715,BLOCK,1,,<empty>,,,,1,,void
55732,BLOCK,1,,<empty>,,,,1,,void
55749,BLOCK,1,,<empty>,,,,1,,void
55766,BLOCK,1,,<empty>,,,,1,,void
55783,BLOCK,1,,<empty>,,,,1,,void
55800,BLOCK,1,,<empty>,,,,1,,void
55820,BLOCK,-1,,<empty>,,,,1,,<empty>
55824,BLOCK,-1,,"TEST(FindFileTest, MultipleNullBoundaries)",1,,128,1,,void
55848,BLOCK,-1,,"{
  Add(""150"", ""200"");
  Add(""200"", ""250"");
  Add(""300"", ""350"");
  Add(""400"", ""450"");
  ASSERT_TRUE(! Overlaps(NULL, ""149""));
  ASSERT_TRUE(! Overlaps(""451"", NULL));
  ASSERT_TRUE(Overlaps(NULL, NULL));
  ASSERT_TRUE(Overlaps(NULL, ""150""));
  ASSERT_TRUE(Overlaps(NULL, ""199""));
  ASSERT_TRUE(Overlaps(NULL, ""200""));
  ASSERT_TRUE(Overlaps(NULL, ""201""));
  ASSERT_TRUE(Overlaps(NULL, ""400""));
  ASSERT_TRUE(Overlaps(NULL, ""800""));
  ASSERT_TRUE(Overlaps(""100"", NULL));
  ASSERT_TRUE(Overlaps(""200"", NULL));
  ASSERT_TRUE(Overlaps(""449"", NULL));
  ASSERT_TRUE(Overlaps(""450"", NULL));
}",44,,128,1,,void
55862,BLOCK,1,,<empty>,,,,1,,void
55880,BLOCK,1,,<empty>,,,,1,,void
55898,BLOCK,1,,<empty>,,,,1,,void
55915,BLOCK,1,,<empty>,,,,1,,void
55932,BLOCK,1,,<empty>,,,,1,,void
55949,BLOCK,1,,<empty>,,,,1,,void
55966,BLOCK,1,,<empty>,,,,1,,void
55983,BLOCK,1,,<empty>,,,,1,,void
56000,BLOCK,1,,<empty>,,,,1,,void
56017,BLOCK,1,,<empty>,,,,1,,void
56034,BLOCK,1,,<empty>,,,,1,,void
56051,BLOCK,1,,<empty>,,,,1,,void
56068,BLOCK,1,,<empty>,,,,1,,void
56088,BLOCK,-1,,<empty>,,,,1,,<empty>
56092,BLOCK,-1,,"TEST(FindFileTest, OverlapSequenceChecks)",1,,148,1,,void
56116,BLOCK,-1,,"{
  Add(""200"", ""200"", 5000, 3000);
  ASSERT_TRUE(! Overlaps(""199"", ""199""));
  ASSERT_TRUE(! Overlaps(""201"", ""300""));
  ASSERT_TRUE(Overlaps(""200"", ""200""));
  ASSERT_TRUE(Overlaps(""190"", ""200""));
  ASSERT_TRUE(Overlaps(""200"", ""210""));
}",43,,148,1,,void
56123,BLOCK,1,,<empty>,,,,1,,void
56141,BLOCK,1,,<empty>,,,,1,,void
56159,BLOCK,1,,<empty>,,,,1,,void
56176,BLOCK,1,,<empty>,,,,1,,void
56193,BLOCK,1,,<empty>,,,,1,,void
56213,BLOCK,-1,,<empty>,,,,1,,<empty>
56217,BLOCK,-1,,"TEST(FindFileTest, OverlappingFiles)",1,,157,1,,void
56241,BLOCK,-1,,"{
  Add(""150"", ""600"");
  Add(""400"", ""500"");
  disjoint_sorted_files_ = false;
  ASSERT_TRUE(! Overlaps(""100"", ""149""));
  ASSERT_TRUE(! Overlaps(""601"", ""700""));
  ASSERT_TRUE(Overlaps(""100"", ""150""));
  ASSERT_TRUE(Overlaps(""100"", ""200""));
  ASSERT_TRUE(Overlaps(""100"", ""300""));
  ASSERT_TRUE(Overlaps(""100"", ""400""));
  ASSERT_TRUE(Overlaps(""100"", ""500""));
  ASSERT_TRUE(Overlaps(""375"", ""400""));
  ASSERT_TRUE(Overlaps(""450"", ""450""));
  ASSERT_TRUE(Overlaps(""450"", ""500""));
  ASSERT_TRUE(Overlaps(""450"", ""700""));
  ASSERT_TRUE(Overlaps(""600"", ""700""));
}",38,,157,1,,void
56252,BLOCK,1,,<empty>,,,,1,,void
56270,BLOCK,1,,<empty>,,,,1,,void
56288,BLOCK,1,,<empty>,,,,1,,void
56305,BLOCK,1,,<empty>,,,,1,,void
56322,BLOCK,1,,<empty>,,,,1,,void
56339,BLOCK,1,,<empty>,,,,1,,void
56356,BLOCK,1,,<empty>,,,,1,,void
56373,BLOCK,1,,<empty>,,,,1,,void
56390,BLOCK,1,,<empty>,,,,1,,void
56407,BLOCK,1,,<empty>,,,,1,,void
56424,BLOCK,1,,<empty>,,,,1,,void
56441,BLOCK,1,,<empty>,,,,1,,void
56462,BLOCK,-1,,"{
  return leveldb::test::RunAllTests();
}",33,,177,3,,void
56488,BLOCK,-1,,<empty>,1,,1,1,,ANY
56495,BLOCK,-1,,"{
  Clear();
}",26,,29,1,,void
56500,BLOCK,-1,,{ },27,,33,1,,void
56504,BLOCK,-1,,{ },33,,35,1,,void
56508,BLOCK,-1,,"{
  rep_.clear();
  rep_.resize(kHeader);
}",26,,37,1,,void
56522,BLOCK,-1,,"{
  Slice input(rep_);
  if (input.size() < kHeader) {
    return Status::Corruption(""malformed WriteBatch (too small)"");
  }

  input.remove_prefix(kHeader);
  Slice key, value;
  int found = 0;
  while (!input.empty()) {
    found++;
    char tag = input[0];
    input.remove_prefix(1);
    switch (tag) {
      case kTypeValue:
        if (GetLengthPrefixedSlice(&input, &key) &&
            GetLengthPrefixedSlice(&input, &value)) {
          handler->Put(key, value);
        } else {
          return Status::Corruption(""bad WriteBatch Put"");
        }
        break;
      case kTypeDeletion:
        if (GetLengthPrefixedSlice(&input, &key)) {
          handler->Delete(key);
        } else {
          return Status::Corruption(""bad WriteBatch Delete"");
        }
        break;
      default:
        return Status::Corruption(""unknown WriteBatch tag"");
    }
  }
  if (found != WriteBatchInternal::Count(this)) {
    return Status::Corruption(""WriteBatch has wrong count"");
  } else {
 ...",52,,42,2,,void
56533,BLOCK,-1,,"{
    return Status::Corruption(""malformed WriteBatch (too small)"");
  }",31,,44,2,,void
56557,BLOCK,-1,,"{
    found++;
    char tag = input[0];
    input.remove_prefix(1);
    switch (tag) {
      case kTypeValue:
        if (GetLengthPrefixedSlice(&input, &key) &&
            GetLengthPrefixedSlice(&input, &value)) {
          handler->Put(key, value);
        } else {
          return Status::Corruption(""bad WriteBatch Put"");
        }
        break;
      case kTypeDeletion:
        if (GetLengthPrefixedSlice(&input, &key)) {
          handler->Delete(key);
        } else {
          return Status::Corruption(""bad WriteBatch Delete"");
        }
        break;
      default:
        return Status::Corruption(""unknown WriteBatch tag"");
    }
  }",26,,51,2,,void
56573,BLOCK,-1,,"{
      case kTypeValue:
        if (GetLengthPrefixedSlice(&input, &key) &&
            GetLengthPrefixedSlice(&input, &value)) {
          handler->Put(key, value);
        } else {
          return Status::Corruption(""bad WriteBatch Put"");
        }
        break;
      case kTypeDeletion:
        if (GetLengthPrefixedSlice(&input, &key)) {
          handler->Delete(key);
        } else {
          return Status::Corruption(""bad WriteBatch Delete"");
        }
        break;
      default:
        return Status::Corruption(""unknown WriteBatch tag"");
    }",18,,55,2,,void
56588,BLOCK,-1,,"{
          handler->Put(key, value);
        }",53,,58,2,,void
56596,BLOCK,-1,,"{
          return Status::Corruption(""bad WriteBatch Put"");
        }",16,,60,1,,void
56612,BLOCK,-1,,"{
          handler->Delete(key);
        }",51,,65,2,,void
56619,BLOCK,-1,,"{
          return Status::Corruption(""bad WriteBatch Delete"");
        }",16,,67,1,,void
56642,BLOCK,-1,,"{
    return Status::Corruption(""WriteBatch has wrong count"");
  }",49,,75,2,,void
56650,BLOCK,-1,,"{
    return Status::OK();
  }",10,,77,1,,void
56660,BLOCK,-1,,"{
  return DecodeFixed32(b->rep_.data() + 8);
}",52,,82,2,,void
56676,BLOCK,-1,,"{
  EncodeFixed32(&b->rep_[8], n);
}",57,,86,3,,void
56689,BLOCK,-1,,"{
  return SequenceNumber(DecodeFixed64(b->rep_.data()));
}",66,,90,2,,void
56704,BLOCK,-1,,"{
  EncodeFixed64(&b->rep_[0], seq);
}",73,,94,3,,void
56718,BLOCK,-1,,"{
  WriteBatchInternal::SetCount(this, WriteBatchInternal::Count(this) + 1);
  rep_.push_back(static_cast<char>(kTypeValue));
  PutLengthPrefixedSlice(&rep_, key);
  PutLengthPrefixedSlice(&rep_, value);
}",60,,98,3,,void
56750,BLOCK,-1,,"{
  WriteBatchInternal::SetCount(this, WriteBatchInternal::Count(this) + 1);
  rep_.push_back(static_cast<char>(kTypeDeletion));
  PutLengthPrefixedSlice(&rep_, key);
}",43,,105,2,,void
56783,BLOCK,-1,,"{
    mem_->Add(sequence_, kTypeValue, key, value);
    sequence_++;
  }",58,,117,3,,void
56798,BLOCK,-1,,"{
    mem_->Add(sequence_, kTypeDeletion, key, Slice());
    sequence_++;
  }",41,,121,2,,void
56814,BLOCK,-1,,"{
  MemTableInserter inserter;
  inserter.sequence_ = WriteBatchInternal::Sequence(b);
  inserter.mem_ = memtable;
  return b->Iterate(&inserter);
}",59,,129,3,,void
56842,BLOCK,-1,,"{
  assert(contents.size() >= kHeader);
  b->rep_.assign(contents.data(), contents.size());
}",76,,136,3,,void
56869,BLOCK,-1,,"{
  SetCount(dst, Count(dst) + Count(src));
  assert(src->rep_.size() >= kHeader);
  dst->rep_.append(src->rep_.data() + kHeader, src->rep_.size() - kHeader);
}",73,,141,3,,void
56918,BLOCK,-1,,<empty>,1,,1,1,,ANY
56924,BLOCK,-1,,<empty>,,,,2,,<empty>
56930,BLOCK,-1,,<empty>,,,,3,,<empty>
56935,BLOCK,-1,,<empty>,,,,2,,<empty>
56941,BLOCK,-1,,<empty>,,,,3,,<empty>
56946,BLOCK,-1,,"{
    return Slice(batch->rep_);
  }",50,,32,2,,void
56956,BLOCK,-1,,"{
    return batch->rep_.size();
  }",51,,36,2,,void
56969,BLOCK,-1,,<empty>,,,,3,,<empty>
56975,BLOCK,-1,,<empty>,,,,3,,<empty>
56981,BLOCK,-1,,<empty>,,,,3,,<empty>
57000,BLOCK,-1,,<empty>,1,,1,1,,ANY
57004,BLOCK,-1,,"{
  InternalKeyComparator cmp(BytewiseComparator());
  MemTable* mem = new MemTable(cmp);
  mem->Ref();
  std::string state;
  Status s = WriteBatchInternal::InsertInto(b, mem);
  int count = 0;
  Iterator* iter = mem->NewIterator();
  for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {
    ParsedInternalKey ikey;
    ASSERT_TRUE(ParseInternalKey(iter->key(), &ikey));
    switch (ikey.type) {
      case kTypeValue:
        state.append(""Put("");
        state.append(ikey.user_key.ToString());
        state.append("", "");
        state.append(iter->value().ToString());
        state.append("")"");
        count++;
        break;
      case kTypeDeletion:
        state.append(""Delete("");
        state.append(ikey.user_key.ToString());
        state.append("")"");
        count++;
        break;
    }
    state.append(""@"");
    state.append(NumberToString(ikey.sequence));
  }
  delete iter;
  if (!s.ok()) {
    state.append(""ParseError()"");
  } else if (count != WriteBatchInternal::Coun...",49,,15,2,,void
57040,BLOCK,-1,,<empty>,3,,23,1,,void
57053,BLOCK,4,,"{
    ParsedInternalKey ikey;
    ASSERT_TRUE(ParseInternalKey(iter->key(), &ikey));
    switch (ikey.type) {
      case kTypeValue:
        state.append(""Put("");
        state.append(ikey.user_key.ToString());
        state.append("", "");
        state.append(iter->value().ToString());
        state.append("")"");
        count++;
        break;
      case kTypeDeletion:
        state.append(""Delete("");
        state.append(ikey.user_key.ToString());
        state.append("")"");
        count++;
        break;
    }
    state.append(""@"");
    state.append(NumberToString(ikey.sequence));
  }",58,,23,4,,void
57056,BLOCK,1,,<empty>,,,,3,,void
57080,BLOCK,-1,,"{
      case kTypeValue:
        state.append(""Put("");
        state.append(ikey.user_key.ToString());
        state.append("", "");
        state.append(iter->value().ToString());
        state.append("")"");
        count++;
        break;
      case kTypeDeletion:
        state.append(""Delete("");
        state.append(ikey.user_key.ToString());
        state.append("")"");
        count++;
        break;
    }",24,,26,2,,void
57168,BLOCK,-1,,"{
    state.append(""ParseError()"");
  }",16,,46,2,,void
57175,BLOCK,-1,,<empty>,10,,48,1,,void
57184,BLOCK,-1,,"{
    state.append(""CountMismatch()"");
  }",53,,48,2,,void
57201,BLOCK,-1,,<empty>,,,,1,,<empty>
57205,BLOCK,-1,,"TEST(WriteBatchTest, Empty)",1,,57,1,,void
57229,BLOCK,-1,,"{
  WriteBatch batch;
  ASSERT_EQ("""", PrintContents(&batch));
  ASSERT_EQ(0, WriteBatchInternal::Count(&batch));
}",29,,57,1,,void
57236,BLOCK,1,,<empty>,,,,4,,void
57260,BLOCK,1,,<empty>,,,,4,,void
57283,BLOCK,-1,,<empty>,,,,1,,<empty>
57287,BLOCK,-1,,"TEST(WriteBatchTest, Multiple)",1,,63,1,,void
57311,BLOCK,-1,,"{
  WriteBatch batch;
  batch.Put(Slice(""foo""), Slice(""bar""));
  batch.Delete(Slice(""box""));
  batch.Put(Slice(""baz""), Slice(""boo""));
  WriteBatchInternal::SetSequence(&batch, 100);
  ASSERT_EQ(100, WriteBatchInternal::Sequence(&batch));
  ASSERT_EQ(3, WriteBatchInternal::Count(&batch));
  ASSERT_EQ(""Put(baz, boo)@102""
            ""Delete(box)@101""
            ""Put(foo, bar)@100"",
            PrintContents(&batch));
}",32,,63,1,,void
57350,BLOCK,1,,<empty>,,,,4,,void
57377,BLOCK,1,,<empty>,,,,4,,void
57400,BLOCK,1,,<empty>,,,,3,,void
57420,BLOCK,-1,,<empty>,,,,1,,<empty>
57424,BLOCK,-1,,"TEST(WriteBatchTest, Corruption)",1,,77,1,,void
57448,BLOCK,-1,,"{
  WriteBatch batch;
  batch.Put(Slice(""foo""), Slice(""bar""));
  batch.Delete(Slice(""box""));
  WriteBatchInternal::SetSequence(&batch, 200);
  Slice contents = WriteBatchInternal::Contents(&batch);
  WriteBatchInternal::SetContents(&batch,
                                  Slice(contents.data(),contents.size()-1));
  ASSERT_EQ(""Put(foo, bar)@200""
            ""ParseError()"",
            PrintContents(&batch));
}",34,,77,1,,void
57501,BLOCK,1,,<empty>,,,,3,,void
57521,BLOCK,-1,,<empty>,,,,1,,<empty>
57525,BLOCK,-1,,"TEST(WriteBatchTest, Append)",1,,90,1,,void
57549,BLOCK,-1,,"{
  WriteBatch b1, b2;
  WriteBatchInternal::SetSequence(&b1, 200);
  WriteBatchInternal::SetSequence(&b2, 300);
  WriteBatchInternal::Append(&b1, &b2);
  ASSERT_EQ("""",
            PrintContents(&b1));
  b2.Put(""a"", ""va"");
  WriteBatchInternal::Append(&b1, &b2);
  ASSERT_EQ(""Put(a, va)@200"",
            PrintContents(&b1));
  b2.Clear();
  b2.Put(""b"", ""vb"");
  WriteBatchInternal::Append(&b1, &b2);
  ASSERT_EQ(""Put(a, va)@200""
            ""Put(b, vb)@201"",
            PrintContents(&b1));
  b2.Delete(""foo"");
  WriteBatchInternal::Append(&b1, &b2);
  ASSERT_EQ(""Put(a, va)@200""
            ""Put(b, vb)@202""
            ""Put(b, vb)@201""
            ""Delete(foo)@203"",
            PrintContents(&b1));
}",30,,90,1,,void
57579,BLOCK,1,,<empty>,,,,4,,void
57613,BLOCK,1,,<empty>,,,,3,,void
57651,BLOCK,1,,<empty>,,,,3,,void
57684,BLOCK,1,,<empty>,,,,3,,void
57705,BLOCK,-1,,"{
  return leveldb::test::RunAllTests();
}",33,,118,3,,void
57731,BLOCK,-1,,<empty>,1,,1,1,,ANY
57784,BLOCK,-1,,"{
  if (status != SQLITE_OK) {
    fprintf(stderr, ""SQL error: %s\n"", err_msg);
    sqlite3_free(err_msg);
    exit(1);
  }
}",55,,82,3,,void
57789,BLOCK,-1,,"{
    fprintf(stderr, ""SQL error: %s\n"", err_msg);
    sqlite3_free(err_msg);
    exit(1);
  }",28,,83,2,,void
57802,BLOCK,-1,,"{
  if (status != SQLITE_DONE) {
    fprintf(stderr, ""SQL step error: status = %d\n"", status);
    exit(1);
  }
}",40,,91,2,,void
57807,BLOCK,-1,,"{
    fprintf(stderr, ""SQL step error: status = %d\n"", status);
    exit(1);
  }",30,,92,2,,void
57818,BLOCK,-1,,"{
  if (status != SQLITE_OK) {
    fprintf(stderr, ""sqlite3 error: status = %d\n"", status);
    exit(1);
  }
}",36,,99,2,,void
57823,BLOCK,-1,,"{
    fprintf(stderr, ""sqlite3 error: status = %d\n"", status);
    exit(1);
  }",28,,100,2,,void
57834,BLOCK,-1,,"{
  // Flush all writes to disk
  if (FLAGS_WAL_enabled) {
    sqlite3_wal_checkpoint_v2(db_, NULL, SQLITE_CHECKPOINT_FULL, NULL, NULL);
  }
}",41,,107,2,,void
57837,BLOCK,-1,,"{
    sqlite3_wal_checkpoint_v2(db_, NULL, SQLITE_CHECKPOINT_FULL, NULL, NULL);
  }",26,,109,2,,void
57852,BLOCK,-1,,"{
    // We use a limited amount of data over and over again and ensure
    // that it is larger than the compression window (32KB), and also
    // large enough to serve all typical value sizes we want to write.
    Random rnd(301);
    std::string piece;
    while (data_.size() < 1048576) {
      // Add a short fragment that is as compressible as specified
      // by FLAGS_compression_ratio.
      test::CompressibleString(&rnd, FLAGS_compression_ratio, 100, &piece);
      data_.append(piece);
    }
    pos_ = 0;
  }",21,,124,1,,void
57864,BLOCK,-1,,"{
      // Add a short fragment that is as compressible as specified
      // by FLAGS_compression_ratio.
      test::CompressibleString(&rnd, FLAGS_compression_ratio, 100, &piece);
      data_.append(piece);
    }",36,,130,2,,void
57887,BLOCK,-1,,"{
    if (pos_ + len > data_.size()) {
      pos_ = 0;
      assert(len < data_.size());
    }
    pos_ += len;
    return Slice(data_.data() + pos_ - len, len);
  }",27,,139,2,,void
57897,BLOCK,-1,,"{
      pos_ = 0;
      assert(len < data_.size());
    }",36,,140,2,,void
57926,BLOCK,-1,,"{
  int start = 0;
  while (start < s.size() && isspace(s[start])) {
    start++;
  }
  int limit = s.size();
  while (limit > start && isspace(s[limit-1])) {
    limit--;
  }
  return Slice(s.data() + start, limit - start);
}",33,,149,2,,void
57943,BLOCK,-1,,"{
    start++;
  }",49,,151,2,,void
57964,BLOCK,-1,,"{
    limit--;
  }",48,,155,2,,void
57995,BLOCK,-1,,"{
    const int kKeySize = 16;
    PrintEnvironment();
    fprintf(stdout, ""Keys:       %d bytes each\n"", kKeySize);
    fprintf(stdout, ""Values:     %d bytes each\n"", FLAGS_value_size);
    fprintf(stdout, ""Entries:    %d\n"", num_);
    fprintf(stdout, ""RawSize:    %.1f MB (estimated)\n"",
            ((static_cast<int64_t>(kKeySize + FLAGS_value_size) * num_)
             / 1048576.0));
    PrintWarnings();
    fprintf(stdout, ""------------------------------------------------\n"");
  }",22,,181,1,,void
58032,BLOCK,-1,,"{
#if defined(__GNUC__) && !defined(__OPTIMIZE__)
    fprintf(stdout,
            ""WARNING: Optimization is disabled: benchmarks unnecessarily slow\n""
            );
#endif
#ifndef NDEBUG
    fprintf(stdout,
            ""WARNING: Assertions are enabled; benchmarks unnecessarily slow\n"");
#endif
  }",24,,194,1,,void
58039,BLOCK,-1,,"{
    fprintf(stderr, ""SQLite:     version %s\n"", SQLITE_VERSION);

#if defined(__linux)
    time_t now = time(NULL);
    fprintf(stderr, ""Date:       %s"", ctime(&now));  // ctime() adds newline

    FILE* cpuinfo = fopen(""/proc/cpuinfo"", ""r"");
    if (cpuinfo != NULL) {
      char line[1000];
      int num_cpus = 0;
      std::string cpu_type;
      std::string cache_size;
      while (fgets(line, sizeof(line), cpuinfo) != NULL) {
        const char* sep = strchr(line, ':');
        if (sep == NULL) {
          continue;
        }
        Slice key = TrimSpace(Slice(line, sep - 1 - line));
        Slice val = TrimSpace(Slice(sep + 1));
        if (key == ""model name"") {
          ++num_cpus;
          cpu_type = val.ToString();
        } else if (key == ""cache size"") {
          cache_size = val.ToString();
        }
      }
      fclose(cpuinfo);
      fprintf(stderr, ""CPU:        %d * %s\n"", num_cpus, cpu_type.c_str());
      fprintf(stderr, ""CPUCache:   %s\n"", cache_size.c_str()...",27,,206,1,,void
58047,BLOCK,-1,,"{
    start_ = Env::Default()->NowMicros() * 1e-6;
    bytes_ = 0;
    message_.clear();
    last_op_finish_ = start_;
    hist_.Clear();
    done_ = 0;
    next_report_ = 100;
  }",16,,240,1,,void
58082,BLOCK,-1,,"{
    if (FLAGS_histogram) {
      double now = Env::Default()->NowMicros() * 1e-6;
      double micros = (now - last_op_finish_) * 1e6;
      hist_.Add(micros);
      if (micros > 20000) {
        fprintf(stderr, ""long op: %.1f micros%30s\r"", micros, """");
        fflush(stderr);
      }
      last_op_finish_ = now;
    }

    done_++;
    if (done_ >= next_report_) {
      if      (next_report_ < 1000)   next_report_ += 100;
      else if (next_report_ < 5000)   next_report_ += 500;
      else if (next_report_ < 10000)  next_report_ += 1000;
      else if (next_report_ < 50000)  next_report_ += 5000;
      else if (next_report_ < 100000) next_report_ += 10000;
      else if (next_report_ < 500000) next_report_ += 50000;
      else                            next_report_ += 100000;
      fprintf(stderr, ""... finished %d ops%30s\r"", done_, """");
      fflush(stderr);
    }
  }",27,,250,1,,void
58085,BLOCK,-1,,"{
      double now = Env::Default()->NowMicros() * 1e-6;
      double micros = (now - last_op_finish_) * 1e6;
      hist_.Add(micros);
      if (micros > 20000) {
        fprintf(stderr, ""long op: %.1f micros%30s\r"", micros, """");
        fflush(stderr);
      }
      last_op_finish_ = now;
    }",26,,251,2,,void
58115,BLOCK,-1,,"{
        fprintf(stderr, ""long op: %.1f micros%30s\r"", micros, """");
        fflush(stderr);
      }",27,,255,2,,void
58131,BLOCK,-1,,"{
      if      (next_report_ < 1000)   next_report_ += 100;
      else if (next_report_ < 5000)   next_report_ += 500;
      else if (next_report_ < 10000)  next_report_ += 1000;
      else if (next_report_ < 50000)  next_report_ += 5000;
      else if (next_report_ < 100000) next_report_ += 10000;
      else if (next_report_ < 500000) next_report_ += 50000;
      else                            next_report_ += 100000;
      fprintf(stderr, ""... finished %d ops%30s\r"", done_, """");
      fflush(stderr);
    }",32,,263,2,,void
58136,BLOCK,-1,,<empty>,39,,264,2,,void
58141,BLOCK,-1,,<empty>,12,,265,1,,void
58146,BLOCK,-1,,<empty>,39,,265,2,,void
58151,BLOCK,-1,,<empty>,12,,266,1,,void
58156,BLOCK,-1,,<empty>,39,,266,2,,void
58161,BLOCK,-1,,<empty>,12,,267,1,,void
58166,BLOCK,-1,,<empty>,39,,267,2,,void
58171,BLOCK,-1,,<empty>,12,,268,1,,void
58176,BLOCK,-1,,<empty>,39,,268,2,,void
58181,BLOCK,-1,,<empty>,12,,269,1,,void
58186,BLOCK,-1,,<empty>,39,,269,2,,void
58191,BLOCK,-1,,<empty>,39,,270,1,,void
58205,BLOCK,-1,,"{
    double finish = Env::Default()->NowMicros() * 1e-6;

    // Pretend at least one op was done in case we are running a benchmark
    // that does not call FinishedSingleOp().
    if (done_ < 1) done_ = 1;

    if (bytes_ > 0) {
      char rate[100];
      snprintf(rate, sizeof(rate), ""%6.1f MB/s"",
               (bytes_ / 1048576.0) / (finish - start_));
      if (!message_.empty()) {
        message_  = std::string(rate) + "" "" + message_;
      } else {
        message_ = rate;
      }
    }

    fprintf(stdout, ""%-12s : %11.3f micros/op;%s%s\n"",
            name.ToString().c_str(),
            (finish - start_) * 1e6 / done_,
            (message_.empty() ? """" : "" ""),
            message_.c_str());
    if (FLAGS_histogram) {
      fprintf(stdout, ""Microseconds per op:\n%s\n"", hist_.ToString().c_str());
    }
    fflush(stdout);
  }",32,,276,2,,void
58222,BLOCK,-1,,<empty>,20,,281,2,,void
58230,BLOCK,-1,,"{
      char rate[100];
      snprintf(rate, sizeof(rate), ""%6.1f MB/s"",
               (bytes_ / 1048576.0) / (finish - start_));
      if (!message_.empty()) {
        message_  = std::string(rate) + "" "" + message_;
      } else {
        message_ = rate;
      }
    }",21,,283,2,,void
58250,BLOCK,-1,,"{
        message_  = std::string(rate) + "" "" + message_;
      }",30,,287,2,,void
58263,BLOCK,-1,,"{
        message_ = rate;
      }",14,,289,1,,void
58297,BLOCK,-1,,"{
      fprintf(stdout, ""Microseconds per op:\n%s\n"", hist_.ToString().c_str());
    }",26,,299,2,,void
58318,BLOCK,-1,,"{
    std::vector<std::string> files;
    std::string test_dir;
    Env::Default()->GetTestDirectory(&test_dir);
    Env::Default()->GetChildren(test_dir, &files);
    if (!FLAGS_use_existing_db) {
      for (int i = 0; i < files.size(); i++) {
        if (Slice(files[i]).starts_with(""dbbench_sqlite3"")) {
          std::string file_name(test_dir);
          file_name += ""/"";
          file_name += files[i];
          Env::Default()->DeleteFile(file_name.c_str());
        }
      }
    }
  }",16,,321,1,,void
58351,BLOCK,-1,,"{
      for (int i = 0; i < files.size(); i++) {
        if (Slice(files[i]).starts_with(""dbbench_sqlite3"")) {
          std::string file_name(test_dir);
          file_name += ""/"";
          file_name += files[i];
          Env::Default()->DeleteFile(file_name.c_str());
        }
      }
    }",33,,326,2,,void
58353,BLOCK,-1,,<empty>,7,,327,1,,void
58366,BLOCK,4,,"{
        if (Slice(files[i]).starts_with(""dbbench_sqlite3"")) {
          std::string file_name(test_dir);
          file_name += ""/"";
          file_name += files[i];
          Env::Default()->DeleteFile(file_name.c_str());
        }
      }",46,,327,4,,void
58376,BLOCK,-1,,"{
          std::string file_name(test_dir);
          file_name += ""/"";
          file_name += files[i];
          Env::Default()->DeleteFile(file_name.c_str());
        }",61,,328,2,,void
58402,BLOCK,-1,,"{
    int status = sqlite3_close(db_);
    ErrorCheck(status);
  }",16,,338,1,,void
58413,BLOCK,-1,,"{
    PrintHeader();
    Open();

    const char* benchmarks = FLAGS_benchmarks;
    while (benchmarks != NULL) {
      const char* sep = strchr(benchmarks, ',');
      Slice name;
      if (sep == NULL) {
        name = benchmarks;
        benchmarks = NULL;
      } else {
        name = Slice(benchmarks, sep - benchmarks);
        benchmarks = sep + 1;
      }

      bytes_ = 0;
      Start();

      bool known = true;
      bool write_sync = false;
      if (name == Slice(""fillseq"")) {
        Write(write_sync, SEQUENTIAL, FRESH, num_, FLAGS_value_size, 1);
        WalCheckpoint(db_);
      } else if (name == Slice(""fillseqbatch"")) {
        Write(write_sync, SEQUENTIAL, FRESH, num_, FLAGS_value_size, 1000);
        WalCheckpoint(db_);
      } else if (name == Slice(""fillrandom"")) {
        Write(write_sync, RANDOM, FRESH, num_, FLAGS_value_size, 1);
        WalCheckpoint(db_);
      } else if (name == Slice(""fillrandbatch"")) {
        Write(write_sync, RANDOM, FRESH, num_, FLAGS...",14,,343,1,,void
58424,BLOCK,-1,,"{
      const char* sep = strchr(benchmarks, ',');
      Slice name;
      if (sep == NULL) {
        name = benchmarks;
        benchmarks = NULL;
      } else {
        name = Slice(benchmarks, sep - benchmarks);
        benchmarks = sep + 1;
      }

      bytes_ = 0;
      Start();

      bool known = true;
      bool write_sync = false;
      if (name == Slice(""fillseq"")) {
        Write(write_sync, SEQUENTIAL, FRESH, num_, FLAGS_value_size, 1);
        WalCheckpoint(db_);
      } else if (name == Slice(""fillseqbatch"")) {
        Write(write_sync, SEQUENTIAL, FRESH, num_, FLAGS_value_size, 1000);
        WalCheckpoint(db_);
      } else if (name == Slice(""fillrandom"")) {
        Write(write_sync, RANDOM, FRESH, num_, FLAGS_value_size, 1);
        WalCheckpoint(db_);
      } else if (name == Slice(""fillrandbatch"")) {
        Write(write_sync, RANDOM, FRESH, num_, FLAGS_value_size, 1000);
        WalCheckpoint(db_);
      } else if (name == Slice(""overwrite"")) {
        Write(wri...",32,,348,2,,void
58436,BLOCK,-1,,"{
        name = benchmarks;
        benchmarks = NULL;
      }",24,,351,2,,void
58444,BLOCK,-1,,"{
        name = Slice(benchmarks, sep - benchmarks);
        benchmarks = sep + 1;
      }",14,,354,1,,void
58474,BLOCK,-1,,"{
        Write(write_sync, SEQUENTIAL, FRESH, num_, FLAGS_value_size, 1);
        WalCheckpoint(db_);
      }",37,,364,2,,void
58485,BLOCK,-1,,<empty>,14,,367,1,,void
58491,BLOCK,-1,,"{
        Write(write_sync, SEQUENTIAL, FRESH, num_, FLAGS_value_size, 1000);
        WalCheckpoint(db_);
      }",49,,367,2,,void
58502,BLOCK,-1,,<empty>,14,,370,1,,void
58508,BLOCK,-1,,"{
        Write(write_sync, RANDOM, FRESH, num_, FLAGS_value_size, 1);
        WalCheckpoint(db_);
      }",47,,370,2,,void
58519,BLOCK,-1,,<empty>,14,,373,1,,void
58525,BLOCK,-1,,"{
        Write(write_sync, RANDOM, FRESH, num_, FLAGS_value_size, 1000);
        WalCheckpoint(db_);
      }",50,,373,2,,void
58536,BLOCK,-1,,<empty>,14,,376,1,,void
58542,BLOCK,-1,,"{
        Write(write_sync, RANDOM, EXISTING, num_, FLAGS_value_size, 1);
        WalCheckpoint(db_);
      }",46,,376,2,,void
58553,BLOCK,-1,,<empty>,14,,379,1,,void
58559,BLOCK,-1,,"{
        Write(write_sync, RANDOM, EXISTING, num_, FLAGS_value_size, 1000);
        WalCheckpoint(db_);
      }",51,,379,2,,void
58570,BLOCK,-1,,<empty>,14,,382,1,,void
58576,BLOCK,-1,,"{
        write_sync = true;
        Write(write_sync, RANDOM, FRESH, num_ / 100, FLAGS_value_size, 1);
        WalCheckpoint(db_);
      }",49,,382,2,,void
58592,BLOCK,-1,,<empty>,14,,386,1,,void
58598,BLOCK,-1,,"{
        write_sync = true;
        Write(write_sync, SEQUENTIAL, FRESH, num_ / 100, FLAGS_value_size, 1);
        WalCheckpoint(db_);
      }",48,,386,2,,void
58614,BLOCK,-1,,<empty>,14,,390,1,,void
58620,BLOCK,-1,,"{
        Write(write_sync, RANDOM, FRESH, num_ / 1000, 100 * 1000, 1);
        WalCheckpoint(db_);
      }",49,,390,2,,void
58635,BLOCK,-1,,<empty>,14,,393,1,,void
58641,BLOCK,-1,,"{
        Write(write_sync, SEQUENTIAL, FRESH, num_ / 1000, 100 * 1000, 1);
        WalCheckpoint(db_);
      }",48,,393,2,,void
58656,BLOCK,-1,,<empty>,14,,396,1,,void
58662,BLOCK,-1,,"{
        ReadSequential();
      }",44,,396,2,,void
58665,BLOCK,-1,,<empty>,14,,398,1,,void
58671,BLOCK,-1,,"{
        Read(RANDOM, 1);
      }",47,,398,2,,void
58676,BLOCK,-1,,<empty>,14,,400,1,,void
58682,BLOCK,-1,,"{
        int n = reads_;
        reads_ /= 1000;
        Read(RANDOM, 1);
        reads_ = n;
      }",49,,400,2,,void
58697,BLOCK,-1,,"{
        known = false;
        if (name != Slice()) {  // No error message for empty name
          fprintf(stderr, ""unknown benchmark '%s'\n"", name.ToString().c_str());
        }
      }",14,,405,1,,void
58705,BLOCK,-1,,"{  // No error message for empty name
          fprintf(stderr, ""unknown benchmark '%s'\n"", name.ToString().c_str());
        }",30,,407,2,,void
58718,BLOCK,-1,,"{
        Stop(name);
      }",18,,411,2,,void
58724,BLOCK,-1,,"{
    assert(db_ == NULL);

    int status;
    char file_name[100];
    char* err_msg = NULL;
    db_num_++;

    // Open database
    std::string tmp_dir;
    Env::Default()->GetTestDirectory(&tmp_dir);
    snprintf(file_name, sizeof(file_name),
             ""%s/dbbench_sqlite3-%d.db"",
             tmp_dir.c_str(),
             db_num_);
    status = sqlite3_open(file_name, &db_);
    if (status) {
      fprintf(stderr, ""open error: %s\n"", sqlite3_errmsg(db_));
      exit(1);
    }

    // Change SQLite cache size
    char cache_size[100];
    snprintf(cache_size, sizeof(cache_size), ""PRAGMA cache_size = %d"",
             FLAGS_num_pages);
    status = sqlite3_exec(db_, cache_size, NULL, NULL, &err_msg);
    ExecErrorCheck(status, err_msg);

    // FLAGS_page_size is defaulted to 1024
    if (FLAGS_page_size != 1024) {
      char page_size[100];
      snprintf(page_size, sizeof(page_size), ""PRAGMA page_size = %d"",
               FLAGS_page_size);
      status = sqlite3_exec(db_, p...",15,,417,1,,void
58765,BLOCK,-1,,"{
      fprintf(stderr, ""open error: %s\n"", sqlite3_errmsg(db_));
      exit(1);
    }",17,,433,2,,void
58796,BLOCK,-1,,"{
      char page_size[100];
      snprintf(page_size, sizeof(page_size), ""PRAGMA page_size = %d"",
               FLAGS_page_size);
      status = sqlite3_exec(db_, page_size, NULL, NULL, &err_msg);
      ExecErrorCheck(status, err_msg);
    }",34,,446,2,,void
58818,BLOCK,-1,,"{
      std::string WAL_stmt = ""PRAGMA journal_mode = WAL"";

      // LevelDB's default cache size is a combined 4 MB
      std::string WAL_checkpoint = ""PRAGMA wal_autocheckpoint = 4096"";
      status = sqlite3_exec(db_, WAL_stmt.c_str(), NULL, NULL, &err_msg);
      ExecErrorCheck(status, err_msg);
      status = sqlite3_exec(db_, WAL_checkpoint.c_str(), NULL, NULL, &err_msg);
      ExecErrorCheck(status, err_msg);
    }",28,,455,2,,void
58880,BLOCK,-1,,<empty>,5,,472,1,,void
58890,BLOCK,4,,"{
      status = sqlite3_exec(db_, stmt_array[i].c_str(), NULL, NULL, &err_msg);
      ExecErrorCheck(status, err_msg);
    }",49,,472,4,,void
58917,BLOCK,-1,,"{
    // Create new database if state == FRESH
    if (state == FRESH) {
      if (FLAGS_use_existing_db) {
        message_ = ""skipping (--use_existing_db is true)"";
        return;
      }
      sqlite3_close(db_);
      db_ = NULL;
      Open();
      Start();
    }

    if (num_entries != num_) {
      char msg[100];
      snprintf(msg, sizeof(msg), ""(%d ops)"", num_entries);
      message_ = msg;
    }

    char* err_msg = NULL;
    int status;

    sqlite3_stmt *replace_stmt, *begin_trans_stmt, *end_trans_stmt;
    std::string replace_str = ""REPLACE INTO test (key, value) VALUES (?, ?)"";
    std::string begin_trans_str = ""BEGIN TRANSACTION;"";
    std::string end_trans_str = ""END TRANSACTION;"";

    // Check for synchronous flag in options
    std::string sync_stmt = (write_sync) ? ""PRAGMA synchronous = FULL"" :
                                           ""PRAGMA synchronous = OFF"";
    status = sqlite3_exec(db_, sync_stmt.c_str(), NULL, NULL, &err_msg);
    ExecErrorCheck(status,...",70,,479,7,,void
58922,BLOCK,-1,,"{
      if (FLAGS_use_existing_db) {
        message_ = ""skipping (--use_existing_db is true)"";
        return;
      }
      sqlite3_close(db_);
      db_ = NULL;
      Open();
      Start();
    }",25,,481,2,,void
58925,BLOCK,-1,,"{
        message_ = ""skipping (--use_existing_db is true)"";
        return;
      }",34,,482,2,,void
58941,BLOCK,-1,,"{
      char msg[100];
      snprintf(msg, sizeof(msg), ""(%d ops)"", num_entries);
      message_ = msg;
    }",30,,492,2,,void
59046,BLOCK,-1,,<empty>,5,,524,1,,void
59057,BLOCK,4,,"{
      // Begin write transaction
      if (FLAGS_transaction && transaction) {
        status = sqlite3_step(begin_trans_stmt);
        StepErrorCheck(status);
        status = sqlite3_reset(begin_trans_stmt);
        ErrorCheck(status);
      }

      // Create and execute SQL statements
      for (int j = 0; j < entries_per_batch; j++) {
        const char* value = gen_.Generate(value_size).data();

        // Create values for key-value pair
        const int k = (order == SEQUENTIAL) ? i + j :
                      (rand_.Next() % num_entries);
        char key[100];
        snprintf(key, sizeof(key), ""%016d"", k);

        // Bind KV values into replace_stmt
        status = sqlite3_bind_blob(replace_stmt, 1, key, 16, SQLITE_STATIC);
        ErrorCheck(status);
        status = sqlite3_bind_blob(replace_stmt, 2, value,
                                   value_size, SQLITE_STATIC);
        ErrorCheck(status);

        // Execute replace_stmt
        bytes_ += value_size + strle...",62,,524,4,,void
59062,BLOCK,-1,,"{
        status = sqlite3_step(begin_trans_stmt);
        StepErrorCheck(status);
        status = sqlite3_reset(begin_trans_stmt);
        ErrorCheck(status);
      }",45,,526,2,,void
59076,BLOCK,-1,,<empty>,7,,534,1,,void
59086,BLOCK,4,,"{
        const char* value = gen_.Generate(value_size).data();

        // Create values for key-value pair
        const int k = (order == SEQUENTIAL) ? i + j :
                      (rand_.Next() % num_entries);
        char key[100];
        snprintf(key, sizeof(key), ""%016d"", k);

        // Bind KV values into replace_stmt
        status = sqlite3_bind_blob(replace_stmt, 1, key, 16, SQLITE_STATIC);
        ErrorCheck(status);
        status = sqlite3_bind_blob(replace_stmt, 2, value,
                                   value_size, SQLITE_STATIC);
        ErrorCheck(status);

        // Execute replace_stmt
        bytes_ += value_size + strlen(key);
        status = sqlite3_step(replace_stmt);
        StepErrorCheck(status);

        // Reset SQLite statement for another use
        status = sqlite3_clear_bindings(replace_stmt);
        ErrorCheck(status);
        status = sqlite3_reset(replace_stmt);
        ErrorCheck(status);

        FinishedSingleOp();
      }",51,,534,4,,void
59170,BLOCK,-1,,"{
        status = sqlite3_step(end_trans_stmt);
        StepErrorCheck(status);
        status = sqlite3_reset(end_trans_stmt);
        ErrorCheck(status);
      }",45,,565,2,,void
59206,BLOCK,-1,,"{
    int status;
    sqlite3_stmt *read_stmt, *begin_trans_stmt, *end_trans_stmt;

    std::string read_str = ""SELECT * FROM test WHERE key = ?"";
    std::string begin_trans_str = ""BEGIN TRANSACTION;"";
    std::string end_trans_str = ""END TRANSACTION;"";

    // Preparing sqlite3 statements
    status = sqlite3_prepare_v2(db_, begin_trans_str.c_str(), -1,
                                &begin_trans_stmt, NULL);
    ErrorCheck(status);
    status = sqlite3_prepare_v2(db_, end_trans_str.c_str(), -1,
                                &end_trans_stmt, NULL);
    ErrorCheck(status);
    status = sqlite3_prepare_v2(db_, read_str.c_str(), -1, &read_stmt, NULL);
    ErrorCheck(status);

    bool transaction = (entries_per_batch > 1);
    for (int i = 0; i < reads_; i += entries_per_batch) {
      // Begin read transaction
      if (FLAGS_transaction && transaction) {
        status = sqlite3_step(begin_trans_stmt);
        StepErrorCheck(status);
        status = sqlite3_reset(begin_trans_st...",49,,581,3,,void
59275,BLOCK,-1,,<empty>,5,,600,1,,void
59286,BLOCK,4,,"{
      // Begin read transaction
      if (FLAGS_transaction && transaction) {
        status = sqlite3_step(begin_trans_stmt);
        StepErrorCheck(status);
        status = sqlite3_reset(begin_trans_stmt);
        ErrorCheck(status);
      }

      // Create and execute SQL statements
      for (int j = 0; j < entries_per_batch; j++) {
        // Create key value
        char key[100];
        int k = (order == SEQUENTIAL) ? i + j : (rand_.Next() % reads_);
        snprintf(key, sizeof(key), ""%016d"", k);

        // Bind key value into read_stmt
        status = sqlite3_bind_blob(read_stmt, 1, key, 16, SQLITE_STATIC);
        ErrorCheck(status);

        // Execute read statement
        while ((status = sqlite3_step(read_stmt)) == SQLITE_ROW) {}
        StepErrorCheck(status);

        // Reset SQLite statement for another use
        status = sqlite3_clear_bindings(read_stmt);
        ErrorCheck(status);
        status = sqlite3_reset(read_stmt);
        ErrorCheck(status);
 ...",57,,600,4,,void
59291,BLOCK,-1,,"{
        status = sqlite3_step(begin_trans_stmt);
        StepErrorCheck(status);
        status = sqlite3_reset(begin_trans_stmt);
        ErrorCheck(status);
      }",45,,602,2,,void
59305,BLOCK,-1,,<empty>,7,,610,1,,void
59315,BLOCK,4,,"{
        // Create key value
        char key[100];
        int k = (order == SEQUENTIAL) ? i + j : (rand_.Next() % reads_);
        snprintf(key, sizeof(key), ""%016d"", k);

        // Bind key value into read_stmt
        status = sqlite3_bind_blob(read_stmt, 1, key, 16, SQLITE_STATIC);
        ErrorCheck(status);

        // Execute read statement
        while ((status = sqlite3_step(read_stmt)) == SQLITE_ROW) {}
        StepErrorCheck(status);

        // Reset SQLite statement for another use
        status = sqlite3_clear_bindings(read_stmt);
        ErrorCheck(status);
        status = sqlite3_reset(read_stmt);
        ErrorCheck(status);
        FinishedSingleOp();
      }",51,,610,4,,void
59356,BLOCK,-1,,<empty>,66,,621,2,,void
59376,BLOCK,-1,,"{
        status = sqlite3_step(end_trans_stmt);
        StepErrorCheck(status);
        status = sqlite3_reset(end_trans_stmt);
        ErrorCheck(status);
      }",45,,633,2,,void
59410,BLOCK,-1,,"{
    int status;
    sqlite3_stmt *pStmt;
    std::string read_str = ""SELECT * FROM test ORDER BY key"";

    status = sqlite3_prepare_v2(db_, read_str.c_str(), -1, &pStmt, NULL);
    ErrorCheck(status);
    for (int i = 0; i < reads_ && SQLITE_ROW == sqlite3_step(pStmt); i++) {
      bytes_ += sqlite3_column_bytes(pStmt, 1) + sqlite3_column_bytes(pStmt, 2);
      FinishedSingleOp();
    }

    status = sqlite3_finalize(pStmt);
    ErrorCheck(status);
  }",25,,649,1,,void
59433,BLOCK,-1,,<empty>,5,,656,1,,void
59448,BLOCK,4,,"{
      bytes_ += sqlite3_column_bytes(pStmt, 1) + sqlite3_column_bytes(pStmt, 2);
      FinishedSingleOp();
    }",75,,656,4,,void
59470,BLOCK,-1,,"{
  std::string default_db_path;
  for (int i = 1; i < argc; i++) {
    double d;
    int n;
    char junk;
    if (leveldb::Slice(argv[i]).starts_with(""--benchmarks="")) {
      FLAGS_benchmarks = argv[i] + strlen(""--benchmarks="");
    } else if (sscanf(argv[i], ""--histogram=%d%c"", &n, &junk) == 1 &&
               (n == 0 || n == 1)) {
      FLAGS_histogram = n;
    } else if (sscanf(argv[i], ""--compression_ratio=%lf%c"", &d, &junk) == 1) {
      FLAGS_compression_ratio = d;
    } else if (sscanf(argv[i], ""--use_existing_db=%d%c"", &n, &junk) == 1 &&
               (n == 0 || n == 1)) {
      FLAGS_use_existing_db = n;
    } else if (sscanf(argv[i], ""--num=%d%c"", &n, &junk) == 1) {
      FLAGS_num = n;
    } else if (sscanf(argv[i], ""--reads=%d%c"", &n, &junk) == 1) {
      FLAGS_reads = n;
    } else if (sscanf(argv[i], ""--value_size=%d%c"", &n, &junk) == 1) {
      FLAGS_value_size = n;
    } else if (leveldb::Slice(argv[i]) == leveldb::Slice(""--no_transaction"")) {
      FLAGS_transa...",33,,669,3,,void
59473,BLOCK,-1,,<empty>,3,,671,1,,void
59483,BLOCK,4,,"{
    double d;
    int n;
    char junk;
    if (leveldb::Slice(argv[i]).starts_with(""--benchmarks="")) {
      FLAGS_benchmarks = argv[i] + strlen(""--benchmarks="");
    } else if (sscanf(argv[i], ""--histogram=%d%c"", &n, &junk) == 1 &&
               (n == 0 || n == 1)) {
      FLAGS_histogram = n;
    } else if (sscanf(argv[i], ""--compression_ratio=%lf%c"", &d, &junk) == 1) {
      FLAGS_compression_ratio = d;
    } else if (sscanf(argv[i], ""--use_existing_db=%d%c"", &n, &junk) == 1 &&
               (n == 0 || n == 1)) {
      FLAGS_use_existing_db = n;
    } else if (sscanf(argv[i], ""--num=%d%c"", &n, &junk) == 1) {
      FLAGS_num = n;
    } else if (sscanf(argv[i], ""--reads=%d%c"", &n, &junk) == 1) {
      FLAGS_reads = n;
    } else if (sscanf(argv[i], ""--value_size=%d%c"", &n, &junk) == 1) {
      FLAGS_value_size = n;
    } else if (leveldb::Slice(argv[i]) == leveldb::Slice(""--no_transaction"")) {
      FLAGS_transaction = false;
    } else if (sscanf(argv[i], ""--page_size=%d%c"", ...",34,,671,4,,void
59499,BLOCK,-1,,"{
      FLAGS_benchmarks = argv[i] + strlen(""--benchmarks="");
    }",63,,675,2,,void
59509,BLOCK,-1,,<empty>,12,,677,1,,void
59530,BLOCK,-1,,"{
      FLAGS_histogram = n;
    }",36,,678,2,,void
59535,BLOCK,-1,,<empty>,12,,680,1,,void
59548,BLOCK,-1,,"{
      FLAGS_compression_ratio = d;
    }",78,,680,2,,void
59553,BLOCK,-1,,<empty>,12,,682,1,,void
59574,BLOCK,-1,,"{
      FLAGS_use_existing_db = n;
    }",36,,683,2,,void
59579,BLOCK,-1,,<empty>,12,,685,1,,void
59592,BLOCK,-1,,"{
      FLAGS_num = n;
    }",63,,685,2,,void
59597,BLOCK,-1,,<empty>,12,,687,1,,void
59610,BLOCK,-1,,"{
      FLAGS_reads = n;
    }",65,,687,2,,void
59615,BLOCK,-1,,<empty>,12,,689,1,,void
59628,BLOCK,-1,,"{
      FLAGS_value_size = n;
    }",70,,689,2,,void
59633,BLOCK,-1,,<empty>,12,,691,1,,void
59648,BLOCK,-1,,"{
      FLAGS_transaction = false;
    }",79,,691,2,,void
59653,BLOCK,-1,,<empty>,12,,693,1,,void
59666,BLOCK,-1,,"{
      FLAGS_page_size = n;
    }",69,,693,2,,void
59671,BLOCK,-1,,<empty>,12,,695,1,,void
59684,BLOCK,-1,,"{
      FLAGS_num_pages = n;
    }",69,,695,2,,void
59689,BLOCK,-1,,<empty>,12,,697,1,,void
59710,BLOCK,-1,,"{
      FLAGS_WAL_enabled = n;
    }",36,,698,2,,void
59715,BLOCK,-1,,<empty>,12,,700,1,,void
59725,BLOCK,-1,,"{
      FLAGS_db = argv[i] + 5;
    }",51,,700,2,,void
59734,BLOCK,-1,,"{
      fprintf(stderr, ""Invalid flag '%s'\n"", argv[i]);
      exit(1);
    }",12,,702,1,,void
59747,BLOCK,-1,,"{
      leveldb::Env::Default()->GetTestDirectory(&default_db_path);
      default_db_path += ""/dbbench"";
      FLAGS_db = default_db_path.c_str();
  }",25,,709,2,,void
59793,BLOCK,-1,,<empty>,1,,1,1,,ANY
59841,BLOCK,-1,,"{
  // Synchronize will flush writes to disk
  if (!db_->synchronize()) {
    fprintf(stderr, ""synchronize error: %s\n"", db_->error().name());
  }
}",1,,76,2,,void
59848,BLOCK,-1,,"{
    fprintf(stderr, ""synchronize error: %s\n"", db_->error().name());
  }",28,,78,2,,void
59867,BLOCK,-1,,"{
    // We use a limited amount of data over and over again and ensure
    // that it is larger than the compression window (32KB), and also
    // large enough to serve all typical value sizes we want to write.
    Random rnd(301);
    std::string piece;
    while (data_.size() < 1048576) {
      // Add a short fragment that is as compressible as specified
      // by FLAGS_compression_ratio.
      test::CompressibleString(&rnd, FLAGS_compression_ratio, 100, &piece);
      data_.append(piece);
    }
    pos_ = 0;
  }",21,,93,1,,void
59879,BLOCK,-1,,"{
      // Add a short fragment that is as compressible as specified
      // by FLAGS_compression_ratio.
      test::CompressibleString(&rnd, FLAGS_compression_ratio, 100, &piece);
      data_.append(piece);
    }",36,,99,2,,void
59902,BLOCK,-1,,"{
    if (pos_ + len > data_.size()) {
      pos_ = 0;
      assert(len < data_.size());
    }
    pos_ += len;
    return Slice(data_.data() + pos_ - len, len);
  }",27,,108,2,,void
59912,BLOCK,-1,,"{
      pos_ = 0;
      assert(len < data_.size());
    }",36,,109,2,,void
59941,BLOCK,-1,,"{
  int start = 0;
  while (start < s.size() && isspace(s[start])) {
    start++;
  }
  int limit = s.size();
  while (limit > start && isspace(s[limit-1])) {
    limit--;
  }
  return Slice(s.data() + start, limit - start);
}",33,,118,2,,void
59958,BLOCK,-1,,"{
    start++;
  }",49,,120,2,,void
59979,BLOCK,-1,,"{
    limit--;
  }",48,,124,2,,void
60011,BLOCK,-1,,"{
    const int kKeySize = 16;
    PrintEnvironment();
    fprintf(stdout, ""Keys:       %d bytes each\n"", kKeySize);
    fprintf(stdout, ""Values:     %d bytes each (%d bytes after compression)\n"",
            FLAGS_value_size,
            static_cast<int>(FLAGS_value_size * FLAGS_compression_ratio + 0.5));
    fprintf(stdout, ""Entries:    %d\n"", num_);
    fprintf(stdout, ""RawSize:    %.1f MB (estimated)\n"",
            ((static_cast<int64_t>(kKeySize + FLAGS_value_size) * num_)
             / 1048576.0));
    fprintf(stdout, ""FileSize:   %.1f MB (estimated)\n"",
            (((kKeySize + FLAGS_value_size * FLAGS_compression_ratio) * num_)
             / 1048576.0));
    PrintWarnings();
    fprintf(stdout, ""------------------------------------------------\n"");
  }",22,,151,1,,void
60067,BLOCK,-1,,"{
#if defined(__GNUC__) && !defined(__OPTIMIZE__)
    fprintf(stdout,
            ""WARNING: Optimization is disabled: benchmarks unnecessarily slow\n""
            );
#endif
#ifndef NDEBUG
    fprintf(stdout,
            ""WARNING: Assertions are enabled; benchmarks unnecessarily slow\n"");
#endif
  }",24,,169,1,,void
60074,BLOCK,-1,,"{
    fprintf(stderr, ""Kyoto Cabinet:    version %s, lib ver %d, lib rev %d\n"",
            kyotocabinet::VERSION, kyotocabinet::LIBVER, kyotocabinet::LIBREV);

#if defined(__linux)
    time_t now = time(NULL);
    fprintf(stderr, ""Date:           %s"", ctime(&now));  // ctime() adds newline

    FILE* cpuinfo = fopen(""/proc/cpuinfo"", ""r"");
    if (cpuinfo != NULL) {
      char line[1000];
      int num_cpus = 0;
      std::string cpu_type;
      std::string cache_size;
      while (fgets(line, sizeof(line), cpuinfo) != NULL) {
        const char* sep = strchr(line, ':');
        if (sep == NULL) {
          continue;
        }
        Slice key = TrimSpace(Slice(line, sep - 1 - line));
        Slice val = TrimSpace(Slice(sep + 1));
        if (key == ""model name"") {
          ++num_cpus;
          cpu_type = val.ToString();
        } else if (key == ""cache size"") {
          cache_size = val.ToString();
        }
      }
      fclose(cpuinfo);
      fprintf(stderr, ""CPU:            ...",27,,181,1,,void
60090,BLOCK,-1,,"{
    start_ = Env::Default()->NowMicros() * 1e-6;
    bytes_ = 0;
    message_.clear();
    last_op_finish_ = start_;
    hist_.Clear();
    done_ = 0;
    next_report_ = 100;
  }",16,,216,1,,void
60125,BLOCK,-1,,"{
    if (FLAGS_histogram) {
      double now = Env::Default()->NowMicros() * 1e-6;
      double micros = (now - last_op_finish_) * 1e6;
      hist_.Add(micros);
      if (micros > 20000) {
        fprintf(stderr, ""long op: %.1f micros%30s\r"", micros, """");
        fflush(stderr);
      }
      last_op_finish_ = now;
    }

    done_++;
    if (done_ >= next_report_) {
      if      (next_report_ < 1000)   next_report_ += 100;
      else if (next_report_ < 5000)   next_report_ += 500;
      else if (next_report_ < 10000)  next_report_ += 1000;
      else if (next_report_ < 50000)  next_report_ += 5000;
      else if (next_report_ < 100000) next_report_ += 10000;
      else if (next_report_ < 500000) next_report_ += 50000;
      else                            next_report_ += 100000;
      fprintf(stderr, ""... finished %d ops%30s\r"", done_, """");
      fflush(stderr);
    }
  }",27,,226,1,,void
60128,BLOCK,-1,,"{
      double now = Env::Default()->NowMicros() * 1e-6;
      double micros = (now - last_op_finish_) * 1e6;
      hist_.Add(micros);
      if (micros > 20000) {
        fprintf(stderr, ""long op: %.1f micros%30s\r"", micros, """");
        fflush(stderr);
      }
      last_op_finish_ = now;
    }",26,,227,2,,void
60158,BLOCK,-1,,"{
        fprintf(stderr, ""long op: %.1f micros%30s\r"", micros, """");
        fflush(stderr);
      }",27,,231,2,,void
60174,BLOCK,-1,,"{
      if      (next_report_ < 1000)   next_report_ += 100;
      else if (next_report_ < 5000)   next_report_ += 500;
      else if (next_report_ < 10000)  next_report_ += 1000;
      else if (next_report_ < 50000)  next_report_ += 5000;
      else if (next_report_ < 100000) next_report_ += 10000;
      else if (next_report_ < 500000) next_report_ += 50000;
      else                            next_report_ += 100000;
      fprintf(stderr, ""... finished %d ops%30s\r"", done_, """");
      fflush(stderr);
    }",32,,239,2,,void
60179,BLOCK,-1,,<empty>,39,,240,2,,void
60184,BLOCK,-1,,<empty>,12,,241,1,,void
60189,BLOCK,-1,,<empty>,39,,241,2,,void
60194,BLOCK,-1,,<empty>,12,,242,1,,void
60199,BLOCK,-1,,<empty>,39,,242,2,,void
60204,BLOCK,-1,,<empty>,12,,243,1,,void
60209,BLOCK,-1,,<empty>,39,,243,2,,void
60214,BLOCK,-1,,<empty>,12,,244,1,,void
60219,BLOCK,-1,,<empty>,39,,244,2,,void
60224,BLOCK,-1,,<empty>,12,,245,1,,void
60229,BLOCK,-1,,<empty>,39,,245,2,,void
60234,BLOCK,-1,,<empty>,39,,246,1,,void
60248,BLOCK,-1,,"{
    double finish = Env::Default()->NowMicros() * 1e-6;

    // Pretend at least one op was done in case we are running a benchmark
    // that does not call FinishedSingleOp().
    if (done_ < 1) done_ = 1;

    if (bytes_ > 0) {
      char rate[100];
      snprintf(rate, sizeof(rate), ""%6.1f MB/s"",
               (bytes_ / 1048576.0) / (finish - start_));
      if (!message_.empty()) {
        message_  = std::string(rate) + "" "" + message_;
      } else {
        message_ = rate;
      }
    }

    fprintf(stdout, ""%-12s : %11.3f micros/op;%s%s\n"",
            name.ToString().c_str(),
            (finish - start_) * 1e6 / done_,
            (message_.empty() ? """" : "" ""),
            message_.c_str());
    if (FLAGS_histogram) {
      fprintf(stdout, ""Microseconds per op:\n%s\n"", hist_.ToString().c_str());
    }
    fflush(stdout);
  }",32,,252,2,,void
60265,BLOCK,-1,,<empty>,20,,257,2,,void
60273,BLOCK,-1,,"{
      char rate[100];
      snprintf(rate, sizeof(rate), ""%6.1f MB/s"",
               (bytes_ / 1048576.0) / (finish - start_));
      if (!message_.empty()) {
        message_  = std::string(rate) + "" "" + message_;
      } else {
        message_ = rate;
      }
    }",21,,259,2,,void
60293,BLOCK,-1,,"{
        message_  = std::string(rate) + "" "" + message_;
      }",30,,263,2,,void
60306,BLOCK,-1,,"{
        message_ = rate;
      }",14,,265,1,,void
60340,BLOCK,-1,,"{
      fprintf(stdout, ""Microseconds per op:\n%s\n"", hist_.ToString().c_str());
    }",26,,275,2,,void
60361,BLOCK,-1,,"{
    std::vector<std::string> files;
    std::string test_dir;
    Env::Default()->GetTestDirectory(&test_dir);
    Env::Default()->GetChildren(test_dir.c_str(), &files);
    if (!FLAGS_use_existing_db) {
      for (int i = 0; i < files.size(); i++) {
        if (Slice(files[i]).starts_with(""dbbench_polyDB"")) {
          std::string file_name(test_dir);
          file_name += ""/"";
          file_name += files[i];
          Env::Default()->DeleteFile(file_name.c_str());
        }
      }
    }
  }",16,,296,1,,void
60397,BLOCK,-1,,"{
      for (int i = 0; i < files.size(); i++) {
        if (Slice(files[i]).starts_with(""dbbench_polyDB"")) {
          std::string file_name(test_dir);
          file_name += ""/"";
          file_name += files[i];
          Env::Default()->DeleteFile(file_name.c_str());
        }
      }
    }",33,,301,2,,void
60399,BLOCK,-1,,<empty>,7,,302,1,,void
60412,BLOCK,4,,"{
        if (Slice(files[i]).starts_with(""dbbench_polyDB"")) {
          std::string file_name(test_dir);
          file_name += ""/"";
          file_name += files[i];
          Env::Default()->DeleteFile(file_name.c_str());
        }
      }",46,,302,4,,void
60422,BLOCK,-1,,"{
          std::string file_name(test_dir);
          file_name += ""/"";
          file_name += files[i];
          Env::Default()->DeleteFile(file_name.c_str());
        }",60,,303,2,,void
60448,BLOCK,-1,,"{
    if (!db_->close()) {
      fprintf(stderr, ""close error: %s\n"", db_->error().name());
    }
  }",16,,313,1,,void
60455,BLOCK,-1,,"{
      fprintf(stderr, ""close error: %s\n"", db_->error().name());
    }",24,,314,2,,void
60469,BLOCK,-1,,"{
    PrintHeader();
    Open(false);

    const char* benchmarks = FLAGS_benchmarks;
    while (benchmarks != NULL) {
      const char* sep = strchr(benchmarks, ',');
      Slice name;
      if (sep == NULL) {
        name = benchmarks;
        benchmarks = NULL;
      } else {
        name = Slice(benchmarks, sep - benchmarks);
        benchmarks = sep + 1;
      }

      Start();

      bool known = true;
      bool write_sync = false;
      if (name == Slice(""fillseq"")) {
        Write(write_sync, SEQUENTIAL, FRESH, num_, FLAGS_value_size, 1);
        DBSynchronize(db_);
      } else if (name == Slice(""fillrandom"")) {
        Write(write_sync, RANDOM, FRESH, num_, FLAGS_value_size, 1);
        DBSynchronize(db_);
      } else if (name == Slice(""overwrite"")) {
        Write(write_sync, RANDOM, EXISTING, num_, FLAGS_value_size, 1);
        DBSynchronize(db_);
      } else if (name == Slice(""fillrandsync"")) {
        write_sync = true;
        Write(write_sync, RANDOM, FRESH, num_ ...",14,,319,1,,void
60481,BLOCK,-1,,"{
      const char* sep = strchr(benchmarks, ',');
      Slice name;
      if (sep == NULL) {
        name = benchmarks;
        benchmarks = NULL;
      } else {
        name = Slice(benchmarks, sep - benchmarks);
        benchmarks = sep + 1;
      }

      Start();

      bool known = true;
      bool write_sync = false;
      if (name == Slice(""fillseq"")) {
        Write(write_sync, SEQUENTIAL, FRESH, num_, FLAGS_value_size, 1);
        DBSynchronize(db_);
      } else if (name == Slice(""fillrandom"")) {
        Write(write_sync, RANDOM, FRESH, num_, FLAGS_value_size, 1);
        DBSynchronize(db_);
      } else if (name == Slice(""overwrite"")) {
        Write(write_sync, RANDOM, EXISTING, num_, FLAGS_value_size, 1);
        DBSynchronize(db_);
      } else if (name == Slice(""fillrandsync"")) {
        write_sync = true;
        Write(write_sync, RANDOM, FRESH, num_ / 100, FLAGS_value_size, 1);
        DBSynchronize(db_);
      } else if (name == Slice(""fillseqsync"")) {
        wri...",32,,324,2,,void
60493,BLOCK,-1,,"{
        name = benchmarks;
        benchmarks = NULL;
      }",24,,327,2,,void
60501,BLOCK,-1,,"{
        name = Slice(benchmarks, sep - benchmarks);
        benchmarks = sep + 1;
      }",14,,330,1,,void
60528,BLOCK,-1,,"{
        Write(write_sync, SEQUENTIAL, FRESH, num_, FLAGS_value_size, 1);
        DBSynchronize(db_);
      }",37,,339,2,,void
60539,BLOCK,-1,,<empty>,14,,342,1,,void
60545,BLOCK,-1,,"{
        Write(write_sync, RANDOM, FRESH, num_, FLAGS_value_size, 1);
        DBSynchronize(db_);
      }",47,,342,2,,void
60556,BLOCK,-1,,<empty>,14,,345,1,,void
60562,BLOCK,-1,,"{
        Write(write_sync, RANDOM, EXISTING, num_, FLAGS_value_size, 1);
        DBSynchronize(db_);
      }",46,,345,2,,void
60573,BLOCK,-1,,<empty>,14,,348,1,,void
60579,BLOCK,-1,,"{
        write_sync = true;
        Write(write_sync, RANDOM, FRESH, num_ / 100, FLAGS_value_size, 1);
        DBSynchronize(db_);
      }",49,,348,2,,void
60595,BLOCK,-1,,<empty>,14,,352,1,,void
60601,BLOCK,-1,,"{
        write_sync = true;
        Write(write_sync, SEQUENTIAL, FRESH, num_ / 100, FLAGS_value_size, 1);
        DBSynchronize(db_);
      }",48,,352,2,,void
60617,BLOCK,-1,,<empty>,14,,356,1,,void
60623,BLOCK,-1,,"{
        Write(write_sync, RANDOM, FRESH, num_ / 1000, 100 * 1000, 1);
        DBSynchronize(db_);
      }",49,,356,2,,void
60638,BLOCK,-1,,<empty>,14,,359,1,,void
60644,BLOCK,-1,,"{
        Write(write_sync, SEQUENTIAL, FRESH, num_ / 1000, 100 * 1000, 1);
        DBSynchronize(db_);
      }",48,,359,2,,void
60659,BLOCK,-1,,<empty>,14,,362,1,,void
60665,BLOCK,-1,,"{
        ReadSequential();
      }",44,,362,2,,void
60668,BLOCK,-1,,<empty>,14,,364,1,,void
60674,BLOCK,-1,,"{
        ReadRandom();
      }",47,,364,2,,void
60677,BLOCK,-1,,<empty>,14,,366,1,,void
60683,BLOCK,-1,,"{
        int n = reads_;
        reads_ /= 1000;
        ReadRandom();
        reads_ = n;
      }",49,,366,2,,void
60696,BLOCK,-1,,<empty>,14,,371,1,,void
60702,BLOCK,-1,,"{
        int n = reads_;
        reads_ /= 1000;
        ReadSequential();
        reads_ = n;
      }",48,,371,2,,void
60715,BLOCK,-1,,"{
        known = false;
        if (name != Slice()) {  // No error message for empty name
          fprintf(stderr, ""unknown benchmark '%s'\n"", name.ToString().c_str());
        }
      }",14,,376,1,,void
60723,BLOCK,-1,,"{  // No error message for empty name
          fprintf(stderr, ""unknown benchmark '%s'\n"", name.ToString().c_str());
        }",30,,378,2,,void
60736,BLOCK,-1,,"{
        Stop(name);
      }",18,,382,2,,void
60743,BLOCK,-1,,"{
    assert(db_ == NULL);

    // Initialize db_
    db_ = new kyotocabinet::TreeDB();
    char file_name[100];
    db_num_++;
    std::string test_dir;
    Env::Default()->GetTestDirectory(&test_dir);
    snprintf(file_name, sizeof(file_name),
             ""%s/dbbench_polyDB-%d.kct"",
             test_dir.c_str(),
             db_num_);

    // Create tuning options and open the database
    int open_options = kyotocabinet::PolyDB::OWRITER |
                       kyotocabinet::PolyDB::OCREATE;
    int tune_options = kyotocabinet::TreeDB::TSMALL |
        kyotocabinet::TreeDB::TLINEAR;
    if (FLAGS_compression) {
      tune_options |= kyotocabinet::TreeDB::TCOMPRESS;
      db_->tune_compressor(&comp_);
    }
    db_->tune_options(tune_options);
    db_->tune_page_cache(FLAGS_cache_size);
    db_->tune_page(FLAGS_page_size);
    db_->tune_map(256LL<<20);
    if (sync) {
      open_options |= kyotocabinet::PolyDB::OAUTOSYNC;
    }
    if (!db_->open(file_name, open_options)) {
    ...",26,,389,2,,void
60805,BLOCK,-1,,"{
      tune_options |= kyotocabinet::TreeDB::TCOMPRESS;
      db_->tune_compressor(&comp_);
    }",28,,408,2,,void
60843,BLOCK,-1,,"{
      open_options |= kyotocabinet::PolyDB::OAUTOSYNC;
    }",15,,416,2,,void
60859,BLOCK,-1,,"{
      fprintf(stderr, ""open error: %s\n"", db_->error().name());
    }",46,,419,2,,void
60879,BLOCK,-1,,"{
    // Create new database if state == FRESH
    if (state == FRESH) {
      if (FLAGS_use_existing_db) {
        message_ = ""skipping (--use_existing_db is true)"";
        return;
      }
      delete db_;
      db_ = NULL;
      Open(sync);
      Start();  // Do not count time taken to destroy/open
    }

    if (num_entries != num_) {
      char msg[100];
      snprintf(msg, sizeof(msg), ""(%d ops)"", num_entries);
      message_ = msg;
    }

    // Write to database
    for (int i = 0; i < num_entries; i++)
    {
      const int k = (order == SEQUENTIAL) ? i : (rand_.Next() % num_entries);
      char key[100];
      snprintf(key, sizeof(key), ""%016d"", k);
      bytes_ += value_size + strlen(key);
      std::string cpp_key = key;
      if (!db_->set(cpp_key, gen_.Generate(value_size).ToString())) {
        fprintf(stderr, ""set error: %s\n"", db_->error().name());
      }
      FinishedSingleOp();
    }
  }",70,,425,7,,void
60884,BLOCK,-1,,"{
      if (FLAGS_use_existing_db) {
        message_ = ""skipping (--use_existing_db is true)"";
        return;
      }
      delete db_;
      db_ = NULL;
      Open(sync);
      Start();  // Do not count time taken to destroy/open
    }",25,,427,2,,void
60887,BLOCK,-1,,"{
        message_ = ""skipping (--use_existing_db is true)"";
        return;
      }",34,,428,2,,void
60904,BLOCK,-1,,"{
      char msg[100];
      snprintf(msg, sizeof(msg), ""(%d ops)"", num_entries);
      message_ = msg;
    }",30,,438,2,,void
60916,BLOCK,-1,,<empty>,5,,445,1,,void
60926,BLOCK,4,,"{
      const int k = (order == SEQUENTIAL) ? i : (rand_.Next() % num_entries);
      char key[100];
      snprintf(key, sizeof(key), ""%016d"", k);
      bytes_ += value_size + strlen(key);
      std::string cpp_key = key;
      if (!db_->set(cpp_key, gen_.Generate(value_size).ToString())) {
        fprintf(stderr, ""set error: %s\n"", db_->error().name());
      }
      FinishedSingleOp();
    }",5,,446,4,,void
60973,BLOCK,-1,,"{
        fprintf(stderr, ""set error: %s\n"", db_->error().name());
      }",69,,452,2,,void
60988,BLOCK,-1,,"{
    kyotocabinet::DB::Cursor* cur = db_->cursor();
    cur->jump();
    std::string ckey, cvalue;
    while (cur->get(&ckey, &cvalue, true)) {
      bytes_ += ckey.size() + cvalue.size();
      FinishedSingleOp();
    }
    delete cur;
  }",25,,459,1,,void
61012,BLOCK,-1,,"{
      bytes_ += ckey.size() + cvalue.size();
      FinishedSingleOp();
    }",44,,463,2,,void
61030,BLOCK,-1,,"{
    std::string value;
    for (int i = 0; i < reads_; i++) {
      char key[100];
      const int k = rand_.Next() % reads_;
      snprintf(key, sizeof(key), ""%016d"", k);
      db_->get(key, &value);
      FinishedSingleOp();
    }
  }",21,,470,1,,void
61033,BLOCK,-1,,<empty>,5,,472,1,,void
61043,BLOCK,4,,"{
      char key[100];
      const int k = rand_.Next() % reads_;
      snprintf(key, sizeof(key), ""%016d"", k);
      db_->get(key, &value);
      FinishedSingleOp();
    }",38,,472,4,,void
61073,BLOCK,-1,,"{
  std::string default_db_path;
  for (int i = 1; i < argc; i++) {
    double d;
    int n;
    char junk;
    if (leveldb::Slice(argv[i]).starts_with(""--benchmarks="")) {
      FLAGS_benchmarks = argv[i] + strlen(""--benchmarks="");
    } else if (sscanf(argv[i], ""--compression_ratio=%lf%c"", &d, &junk) == 1) {
      FLAGS_compression_ratio = d;
    } else if (sscanf(argv[i], ""--histogram=%d%c"", &n, &junk) == 1 &&
               (n == 0 || n == 1)) {
      FLAGS_histogram = n;
    } else if (sscanf(argv[i], ""--num=%d%c"", &n, &junk) == 1) {
      FLAGS_num = n;
    } else if (sscanf(argv[i], ""--reads=%d%c"", &n, &junk) == 1) {
      FLAGS_reads = n;
    } else if (sscanf(argv[i], ""--value_size=%d%c"", &n, &junk) == 1) {
      FLAGS_value_size = n;
    } else if (sscanf(argv[i], ""--cache_size=%d%c"", &n, &junk) == 1) {
      FLAGS_cache_size = n;
    } else if (sscanf(argv[i], ""--page_size=%d%c"", &n, &junk) == 1) {
      FLAGS_page_size = n;
    } else if (sscanf(argv[i], ""--compression=%d...",33,,484,3,,void
61076,BLOCK,-1,,<empty>,3,,486,1,,void
61086,BLOCK,4,,"{
    double d;
    int n;
    char junk;
    if (leveldb::Slice(argv[i]).starts_with(""--benchmarks="")) {
      FLAGS_benchmarks = argv[i] + strlen(""--benchmarks="");
    } else if (sscanf(argv[i], ""--compression_ratio=%lf%c"", &d, &junk) == 1) {
      FLAGS_compression_ratio = d;
    } else if (sscanf(argv[i], ""--histogram=%d%c"", &n, &junk) == 1 &&
               (n == 0 || n == 1)) {
      FLAGS_histogram = n;
    } else if (sscanf(argv[i], ""--num=%d%c"", &n, &junk) == 1) {
      FLAGS_num = n;
    } else if (sscanf(argv[i], ""--reads=%d%c"", &n, &junk) == 1) {
      FLAGS_reads = n;
    } else if (sscanf(argv[i], ""--value_size=%d%c"", &n, &junk) == 1) {
      FLAGS_value_size = n;
    } else if (sscanf(argv[i], ""--cache_size=%d%c"", &n, &junk) == 1) {
      FLAGS_cache_size = n;
    } else if (sscanf(argv[i], ""--page_size=%d%c"", &n, &junk) == 1) {
      FLAGS_page_size = n;
    } else if (sscanf(argv[i], ""--compression=%d%c"", &n, &junk) == 1 &&
               (n == 0 || n == 1)) {
     ...",34,,486,4,,void
61102,BLOCK,-1,,"{
      FLAGS_benchmarks = argv[i] + strlen(""--benchmarks="");
    }",63,,490,2,,void
61112,BLOCK,-1,,<empty>,12,,492,1,,void
61125,BLOCK,-1,,"{
      FLAGS_compression_ratio = d;
    }",78,,492,2,,void
61130,BLOCK,-1,,<empty>,12,,494,1,,void
61151,BLOCK,-1,,"{
      FLAGS_histogram = n;
    }",36,,495,2,,void
61156,BLOCK,-1,,<empty>,12,,497,1,,void
61169,BLOCK,-1,,"{
      FLAGS_num = n;
    }",63,,497,2,,void
61174,BLOCK,-1,,<empty>,12,,499,1,,void
61187,BLOCK,-1,,"{
      FLAGS_reads = n;
    }",65,,499,2,,void
61192,BLOCK,-1,,<empty>,12,,501,1,,void
61205,BLOCK,-1,,"{
      FLAGS_value_size = n;
    }",70,,501,2,,void
61210,BLOCK,-1,,<empty>,12,,503,1,,void
61223,BLOCK,-1,,"{
      FLAGS_cache_size = n;
    }",70,,503,2,,void
61228,BLOCK,-1,,<empty>,12,,505,1,,void
61241,BLOCK,-1,,"{
      FLAGS_page_size = n;
    }",69,,505,2,,void
61246,BLOCK,-1,,<empty>,12,,507,1,,void
61267,BLOCK,-1,,"{
      FLAGS_compression = (n == 1) ? true : false;
    }",36,,508,2,,void
61277,BLOCK,-1,,<empty>,12,,510,1,,void
61287,BLOCK,-1,,"{
      FLAGS_db = argv[i] + 5;
    }",51,,510,2,,void
61296,BLOCK,-1,,"{
      fprintf(stderr, ""Invalid flag '%s'\n"", argv[i]);
      exit(1);
    }",12,,512,1,,void
61309,BLOCK,-1,,"{
      leveldb::Env::Default()->GetTestDirectory(&default_db_path);
      default_db_path += ""/dbbench"";
      FLAGS_db = default_db_path.c_str();
  }",25,,519,2,,void
61361,BLOCK,-1,,<empty>,1,,1,1,,ANY
61366,BLOCK,-1,,<empty>,36,,24,1,,void
61370,BLOCK,-1,,"{
    MutexLock lock(&refs_mutex_);
    ++refs_;
  }",14,,27,1,,void
61380,BLOCK,-1,,"{
    bool do_delete = false;

    {
      MutexLock lock(&refs_mutex_);
      --refs_;
      assert(refs_ >= 0);
      if (refs_ <= 0) {
        do_delete = true;
      }
    }

    if (do_delete) {
      delete this;
    }
  }",16,,33,1,,void
61385,BLOCK,3,,"{
      MutexLock lock(&refs_mutex_);
      --refs_;
      assert(refs_ >= 0);
      if (refs_ <= 0) {
        do_delete = true;
      }
    }",5,,36,3,,void
61400,BLOCK,-1,,"{
        do_delete = true;
      }",23,,40,2,,void
61406,BLOCK,-1,,"{
      delete this;
    }",20,,45,2,,void
61412,BLOCK,-1,,{ return size_; },25,,50,1,,void
61422,BLOCK,-1,,"{
    if (offset > size_) {
      return Status::IOError(""Offset greater than file size."");
    }
    const uint64_t available = size_ - offset;
    if (n > available) {
      n = static_cast<size_t>(available);
    }
    if (n == 0) {
      *result = Slice();
      return Status::OK();
    }

    assert(offset / kBlockSize <= SIZE_MAX);
    size_t block = static_cast<size_t>(offset / kBlockSize);
    size_t block_offset = offset % kBlockSize;

    if (n <= kBlockSize - block_offset) {
      // The requested bytes are all in the first block.
      *result = Slice(blocks_[block] + block_offset, n);
      return Status::OK();
    }

    size_t bytes_to_copy = n;
    char* dst = scratch;

    while (bytes_to_copy > 0) {
      size_t avail = kBlockSize - block_offset;
      if (avail > bytes_to_copy) {
        avail = bytes_to_copy;
      }
      memcpy(dst, blocks_[block] + block_offset, avail);

      bytes_to_copy -= avail;
      dst += avail;
      block++;
      block_offset = 0;
 ...",78,,52,5,,void
61427,BLOCK,-1,,"{
      return Status::IOError(""Offset greater than file size."");
    }",25,,53,2,,void
61444,BLOCK,-1,,"{
      n = static_cast<size_t>(available);
    }",24,,57,2,,void
61454,BLOCK,-1,,"{
      *result = Slice();
      return Status::OK();
    }",17,,60,2,,void
61490,BLOCK,-1,,"{
      // The requested bytes are all in the first block.
      *result = Slice(blocks_[block] + block_offset, n);
      return Status::OK();
    }",41,,69,2,,void
61518,BLOCK,-1,,"{
      size_t avail = kBlockSize - block_offset;
      if (avail > bytes_to_copy) {
        avail = bytes_to_copy;
      }
      memcpy(dst, blocks_[block] + block_offset, avail);

      bytes_to_copy -= avail;
      dst += avail;
      block++;
      block_offset = 0;
    }",31,,78,2,,void
61529,BLOCK,-1,,"{
        avail = bytes_to_copy;
      }",34,,80,2,,void
61567,BLOCK,-1,,"{
    const char* src = data.data();
    size_t src_len = data.size();

    while (src_len > 0) {
      size_t avail;
      size_t offset = size_ % kBlockSize;

      if (offset != 0) {
        // There is some room in the last block.
        avail = kBlockSize - offset;
      } else {
        // No room in the last block; push new one.
        blocks_.push_back(new char[kBlockSize]);
        avail = kBlockSize;
      }

      if (avail > src_len) {
        avail = src_len;
      }
      memcpy(blocks_.back() + offset, src, avail);
      src_len -= avail;
      src += avail;
      size_ += avail;
    }

    return Status::OK();
  }",36,,95,2,,void
61586,BLOCK,-1,,"{
      size_t avail;
      size_t offset = size_ % kBlockSize;

      if (offset != 0) {
        // There is some room in the last block.
        avail = kBlockSize - offset;
      } else {
        // No room in the last block; push new one.
        blocks_.push_back(new char[kBlockSize]);
        avail = kBlockSize;
      }

      if (avail > src_len) {
        avail = src_len;
      }
      memcpy(blocks_.back() + offset, src, avail);
      src_len -= avail;
      src += avail;
      size_ += avail;
    }",25,,99,2,,void
61598,BLOCK,-1,,"{
        // There is some room in the last block.
        avail = kBlockSize - offset;
      }",24,,103,2,,void
61605,BLOCK,-1,,"{
        // No room in the last block; push new one.
        blocks_.push_back(new char[kBlockSize]);
        avail = kBlockSize;
      }",14,,106,1,,void
61619,BLOCK,-1,,"{
        avail = src_len;
      }",28,,112,2,,void
61649,BLOCK,-1,,"{
    for (std::vector<char*>::iterator i = blocks_.begin(); i != blocks_.end();
         ++i) {
      delete [] *i;
    }
  }",16,,126,1,,void
61651,BLOCK,-1,,<empty>,5,,127,1,,void
61667,BLOCK,4,,"{
      delete [] *i;
    }",15,,128,4,,void
61675,BLOCK,-1,,<empty>,,,,2,,<empty>
61680,BLOCK,-1,,<empty>,,,,2,,<empty>
61690,BLOCK,-1,,<empty>,,,,1,,<empty>
61701,BLOCK,-1,,"{
    file_->Ref();
  }",71,,151,2,,void
61709,BLOCK,-1,,"{
    file_->Unref();
  }",25,,155,1,,void
61720,BLOCK,-1,,"{
    Status s = file_->Read(pos_, n, result, scratch);
    if (s.ok()) {
      pos_ += result->size();
    }
    return s;
  }",63,,159,4,,void
61737,BLOCK,-1,,"{
      pos_ += result->size();
    }",17,,161,2,,void
61750,BLOCK,-1,,"{
    if (pos_ > file_->Size()) {
      return Status::IOError(""pos_ > file_->Size()"");
    }
    const uint64_t available = file_->Size() - pos_;
    if (n > available) {
      n = available;
    }
    pos_ += n;
    return Status::OK();
  }",35,,167,2,,void
61758,BLOCK,-1,,"{
      return Status::IOError(""pos_ > file_->Size()"");
    }",31,,168,2,,void
61778,BLOCK,-1,,"{
      n = available;
    }",24,,172,2,,void
61797,BLOCK,-1,,"{
    file_->Ref();
  }",64,,186,2,,void
61805,BLOCK,-1,,"{
    file_->Unref();
  }",27,,190,1,,void
61817,BLOCK,-1,,"{
    return file_->Read(offset, n, result, scratch);
  }",44,,195,5,,void
61833,BLOCK,-1,,"{
    file_->Ref();
  }",51,,205,2,,void
61841,BLOCK,-1,,"{
    file_->Unref();
  }",23,,209,1,,void
61850,BLOCK,-1,,"{
    return file_->Append(data);
  }",44,,213,2,,void
61860,BLOCK,-1,,{ return Status::OK(); },26,,217,1,,void
61869,BLOCK,-1,,{ return Status::OK(); },26,,218,1,,void
61878,BLOCK,-1,,{ return Status::OK(); },25,,219,1,,void
61891,BLOCK,-1,,{ },53,,227,3,,void
61897,BLOCK,-1,,{ },62,,232,2,,void
61901,BLOCK,-1,,"{
    for (FileSystem::iterator i = file_map_.begin(); i != file_map_.end(); ++i){
      i->second->Unref();
    }
  }",26,,234,1,,void
61903,BLOCK,-1,,<empty>,5,,235,1,,void
61919,BLOCK,4,,"{
      i->second->Unref();
    }",80,,235,4,,void
61931,BLOCK,-1,,"{
    MutexLock lock(&mutex_);
    if (file_map_.find(fname) == file_map_.end()) {
      *result = NULL;
      return Status::IOError(fname, ""File not found"");
    }

    *result = new SequentialFileImpl(file_map_[fname]);
    return Status::OK();
  }",61,,242,3,,void
61947,BLOCK,-1,,"{
      *result = NULL;
      return Status::IOError(fname, ""File not found"");
    }",51,,244,2,,void
61977,BLOCK,-1,,"{
    MutexLock lock(&mutex_);
    if (file_map_.find(fname) == file_map_.end()) {
      *result = NULL;
      return Status::IOError(fname, ""File not found"");
    }

    *result = new RandomAccessFileImpl(file_map_[fname]);
    return Status::OK();
  }",65,,254,3,,void
61993,BLOCK,-1,,"{
      *result = NULL;
      return Status::IOError(fname, ""File not found"");
    }",51,,256,2,,void
62023,BLOCK,-1,,"{
    MutexLock lock(&mutex_);
    if (file_map_.find(fname) != file_map_.end()) {
      DeleteFileInternal(fname);
    }

    FileState* file = new FileState();
    file->Ref();
    file_map_[fname] = file;

    *result = new WritableFileImpl(file);
    return Status::OK();
  }",57,,266,3,,void
62039,BLOCK,-1,,"{
      DeleteFileInternal(fname);
    }",51,,268,2,,void
62072,BLOCK,-1,,"{
    MutexLock lock(&mutex_);
    FileState** sptr = &file_map_[fname];
    FileState* file = *sptr;
    if (file == NULL) {
      file = new FileState();
      file->Ref();
    }
    *result = new WritableFileImpl(file);
    return Status::OK();
  }",59,,281,3,,void
62093,BLOCK,-1,,"{
      file = new FileState();
      file->Ref();
    }",23,,285,2,,void
62117,BLOCK,-1,,"{
    MutexLock lock(&mutex_);
    return file_map_.find(fname) != file_map_.end();
  }",53,,293,2,,void
62138,BLOCK,-1,,"{
    MutexLock lock(&mutex_);
    result->clear();

    for (FileSystem::iterator i = file_map_.begin(); i != file_map_.end(); ++i){
      const std::string& filename = i->first;

      if (filename.size() >= dir.size() + 1 && filename[dir.size()] == '/' &&
          Slice(filename).starts_with(Slice(dir))) {
        result->push_back(filename.substr(dir.size() + 1));
      }
    }

    return Status::OK();
  }",64,,299,3,,void
62148,BLOCK,-1,,<empty>,5,,303,1,,void
62164,BLOCK,4,,"{
      const std::string& filename = i->first;

      if (filename.size() >= dir.size() + 1 && filename[dir.size()] == '/' &&
          Slice(filename).starts_with(Slice(dir))) {
        result->push_back(filename.substr(dir.size() + 1));
      }
    }",80,,303,4,,void
62200,BLOCK,-1,,"{
        result->push_back(filename.substr(dir.size() + 1));
      }",52,,307,2,,void
62224,BLOCK,-1,,"{
    if (file_map_.find(fname) == file_map_.end()) {
      return;
    }

    file_map_[fname]->Unref();
    file_map_.erase(fname);
  }",53,,315,2,,void
62236,BLOCK,-1,,"{
      return;
    }",51,,316,2,,void
62253,BLOCK,-1,,"{
    MutexLock lock(&mutex_);
    if (file_map_.find(fname) == file_map_.end()) {
      return Status::IOError(fname, ""File not found"");
    }

    DeleteFileInternal(fname);
    return Status::OK();
  }",55,,324,2,,void
62269,BLOCK,-1,,"{
      return Status::IOError(fname, ""File not found"");
    }",51,,326,2,,void
62288,BLOCK,-1,,"{
    return Status::OK();
  }",56,,334,2,,void
62298,BLOCK,-1,,"{
    return Status::OK();
  }",56,,338,2,,void
62309,BLOCK,-1,,"{
    MutexLock lock(&mutex_);
    if (file_map_.find(fname) == file_map_.end()) {
      return Status::IOError(fname, ""File not found"");
    }

    *file_size = file_map_[fname]->Size();
    return Status::OK();
  }",77,,342,3,,void
62325,BLOCK,-1,,"{
      return Status::IOError(fname, ""File not found"");
    }",51,,344,2,,void
62352,BLOCK,-1,,"{
    MutexLock lock(&mutex_);
    if (file_map_.find(src) == file_map_.end()) {
      return Status::IOError(src, ""File not found"");
    }

    DeleteFileInternal(target);
    file_map_[target] = file_map_[src];
    file_map_.erase(src);
    return Status::OK();
  }",56,,353,3,,void
62368,BLOCK,-1,,"{
      return Status::IOError(src, ""File not found"");
    }",49,,355,2,,void
62400,BLOCK,-1,,"{
    *lock = new FileLock;
    return Status::OK();
  }",70,,365,3,,void
62415,BLOCK,-1,,"{
    delete lock;
    return Status::OK();
  }",45,,370,2,,void
62427,BLOCK,-1,,"{
    *path = ""/test"";
    return Status::OK();
  }",54,,375,2,,void
62442,BLOCK,-1,,"{
    *result = new NoOpLogger;
    return Status::OK();
  }",71,,380,3,,void
62460,BLOCK,-1,,"{
  return new InMemoryEnv(base_env);
}",31,,394,2,,void
62471,BLOCK,-1,,<empty>,1,,1,1,,ANY
62476,BLOCK,-1,,<empty>,,,,2,,<empty>
62497,BLOCK,-1,,<empty>,1,,1,1,,ANY
62502,BLOCK,-1,,"{
  }",41,,21,1,,void
62506,BLOCK,-1,,"{
    delete env_;
  }",17,,23,1,,void
62513,BLOCK,-1,,<empty>,,,,1,,<empty>
62517,BLOCK,-1,,"TEST(MemEnvTest, Basics)",1,,28,1,,void
62541,BLOCK,-1,,"{
  uint64_t file_size;
  WritableFile* writable_file;
  std::vector<std::string> children;

  ASSERT_OK(env_->CreateDir(""/dir""));

  // Check that the directory is empty.
  ASSERT_TRUE(!env_->FileExists(""/dir/non_existent""));
  ASSERT_TRUE(!env_->GetFileSize(""/dir/non_existent"", &file_size).ok());
  ASSERT_OK(env_->GetChildren(""/dir"", &children));
  ASSERT_EQ(0, children.size());

  // Create a file.
  ASSERT_OK(env_->NewWritableFile(""/dir/f"", &writable_file));
  ASSERT_OK(env_->GetFileSize(""/dir/f"", &file_size));
  ASSERT_EQ(0, file_size);
  delete writable_file;

  // Check that the file exists.
  ASSERT_TRUE(env_->FileExists(""/dir/f""));
  ASSERT_OK(env_->GetFileSize(""/dir/f"", &file_size));
  ASSERT_EQ(0, file_size);
  ASSERT_OK(env_->GetChildren(""/dir"", &children));
  ASSERT_EQ(1, children.size());
  ASSERT_EQ(""f"", children[0]);

  // Write to the file.
  ASSERT_OK(env_->NewWritableFile(""/dir/f"", &writable_file));
  ASSERT_OK(writable_file->Append(""abc""));
  delete writable_file...",26,,28,1,,void
62559,BLOCK,1,,<empty>,,,,2,,void
62583,BLOCK,1,,<empty>,,,,2,,void
62603,BLOCK,1,,<empty>,,,,2,,void
62628,BLOCK,1,,<empty>,,,,1,,void
62653,BLOCK,1,,<empty>,,,,3,,void
62671,BLOCK,1,,<empty>,,,,2,,void
62691,BLOCK,1,,<empty>,,,,2,,void
62713,BLOCK,1,,<empty>,,,,4,,void
62735,BLOCK,1,,<empty>,,,,2,,void
62754,BLOCK,1,,<empty>,,,,2,,void
62776,BLOCK,1,,<empty>,,,,4,,void
62791,BLOCK,1,,<empty>,,,,1,,void
62816,BLOCK,1,,<empty>,,,,3,,void
62838,BLOCK,1,,<empty>,,,,3,,void
62855,BLOCK,1,,<empty>,,,,2,,void
62880,BLOCK,1,,<empty>,,,,3,,void
62900,BLOCK,1,,<empty>,,,,2,,void
62920,BLOCK,1,,<empty>,,,,2,,void
62942,BLOCK,1,,<empty>,,,,4,,void
62962,BLOCK,1,,<empty>,,,,3,,void
62982,BLOCK,1,,<empty>,,,,2,,void
63004,BLOCK,1,,<empty>,,,,4,,void
63019,BLOCK,1,,<empty>,,,,1,,void
63043,BLOCK,1,,<empty>,,,,1,,void
63068,BLOCK,1,,<empty>,,,,2,,void
63093,BLOCK,1,,<empty>,,,,2,,void
63112,BLOCK,1,,<empty>,,,,2,,void
63134,BLOCK,1,,<empty>,,,,4,,void
63151,BLOCK,1,,<empty>,,,,2,,void
63178,BLOCK,1,,<empty>,,,,3,,void
63194,BLOCK,1,,<empty>,,,,2,,void
63221,BLOCK,1,,<empty>,,,,3,,void
63246,BLOCK,1,,<empty>,,,,2,,void
63274,BLOCK,1,,<empty>,,,,2,,void
63298,BLOCK,1,,<empty>,,,,2,,void
63318,BLOCK,1,,<empty>,,,,1,,void
63343,BLOCK,1,,<empty>,,,,3,,void
63366,BLOCK,1,,<empty>,,,,2,,void
63387,BLOCK,-1,,<empty>,,,,1,,<empty>
63391,BLOCK,-1,,"TEST(MemEnvTest, ReadWrite)",1,,96,1,,void
63415,BLOCK,-1,,"{
  WritableFile* writable_file;
  SequentialFile* seq_file;
  RandomAccessFile* rand_file;
  Slice result;
  char scratch[100];

  ASSERT_OK(env_->CreateDir(""/dir""));

  ASSERT_OK(env_->NewWritableFile(""/dir/f"", &writable_file));
  ASSERT_OK(writable_file->Append(""hello ""));
  ASSERT_OK(writable_file->Append(""world""));
  delete writable_file;

  // Read sequentially.
  ASSERT_OK(env_->NewSequentialFile(""/dir/f"", &seq_file));
  ASSERT_OK(seq_file->Read(5, &result, scratch)); // Read ""hello"".
  ASSERT_EQ(0, result.compare(""hello""));
  ASSERT_OK(seq_file->Skip(1));
  ASSERT_OK(seq_file->Read(1000, &result, scratch)); // Read ""world"".
  ASSERT_EQ(0, result.compare(""world""));
  ASSERT_OK(seq_file->Read(1000, &result, scratch)); // Try reading past EOF.
  ASSERT_EQ(0, result.size());
  ASSERT_OK(seq_file->Skip(100)); // Try to skip past end of file.
  ASSERT_OK(seq_file->Read(1000, &result, scratch));
  ASSERT_EQ(0, result.size());
  delete seq_file;

  // Random reads.
  ASSERT_OK(env_-...",29,,96,1,,void
63427,BLOCK,1,,<empty>,,,,2,,void
63445,BLOCK,1,,<empty>,,,,2,,void
63465,BLOCK,1,,<empty>,,,,2,,void
63488,BLOCK,1,,<empty>,,,,3,,void
63508,BLOCK,1,,<empty>,,,,2,,void
63528,BLOCK,1,,<empty>,,,,4,,void
63555,BLOCK,1,,<empty>,,,,4,,void
63579,BLOCK,1,,<empty>,,,,3,,void
63597,BLOCK,1,,<empty>,,,,4,,void
63624,BLOCK,1,,<empty>,,,,4,,void
63643,BLOCK,1,,<empty>,,,,4,,void
63669,BLOCK,1,,<empty>,,,,4,,void
63692,BLOCK,1,,<empty>,,,,3,,void
63710,BLOCK,1,,<empty>,,,,4,,void
63736,BLOCK,1,,<empty>,,,,4,,void
63756,BLOCK,1,,<empty>,,,,2,,void
63776,BLOCK,1,,<empty>,,,,4,,void
63804,BLOCK,1,,<empty>,,,,4,,void
63823,BLOCK,1,,<empty>,,,,4,,void
63851,BLOCK,1,,<empty>,,,,4,,void
63870,BLOCK,1,,<empty>,,,,4,,void
63898,BLOCK,1,,<empty>,,,,4,,void
63917,BLOCK,1,,<empty>,,,,4,,void
63949,BLOCK,-1,,<empty>,,,,1,,<empty>
63953,BLOCK,-1,,"TEST(MemEnvTest, Locks)",1,,138,1,,void
63977,BLOCK,-1,,"{
  FileLock* lock;

  // These are no-ops, but we test they return success.
  ASSERT_OK(env_->LockFile(""some file"", &lock));
  ASSERT_OK(env_->UnlockFile(lock));
}",25,,138,1,,void
63980,BLOCK,1,,<empty>,,,,2,,void
64005,BLOCK,1,,<empty>,,,,3,,void
64026,BLOCK,-1,,<empty>,,,,1,,<empty>
64030,BLOCK,-1,,"TEST(MemEnvTest, Misc)",1,,146,1,,void
64054,BLOCK,-1,,"{
  std::string test_dir;
  ASSERT_OK(env_->GetTestDirectory(&test_dir));
  ASSERT_TRUE(!test_dir.empty());

  WritableFile* writable_file;
  ASSERT_OK(env_->NewWritableFile(""/a/b"", &writable_file));

  // These are no-ops, but we test they return success.
  ASSERT_OK(writable_file->Sync());
  ASSERT_OK(writable_file->Flush());
  ASSERT_OK(writable_file->Close());
  delete writable_file;
}",24,,146,1,,void
64063,BLOCK,1,,<empty>,,,,3,,void
64087,BLOCK,1,,<empty>,,,,3,,void
64107,BLOCK,1,,<empty>,,,,2,,void
64131,BLOCK,1,,<empty>,,,,3,,void
64152,BLOCK,1,,<empty>,,,,3,,void
64173,BLOCK,1,,<empty>,,,,3,,void
64195,BLOCK,-1,,<empty>,,,,1,,<empty>
64199,BLOCK,-1,,"TEST(MemEnvTest, LargeWrite)",1,,161,1,,void
64223,BLOCK,-1,,"{
  const size_t kWriteSize = 300 * 1024;
  char* scratch = new char[kWriteSize * 2];

  std::string write_data;
  for (size_t i = 0; i < kWriteSize; ++i) {
    write_data.append(1, static_cast<char>(i));
  }

  WritableFile* writable_file;
  ASSERT_OK(env_->NewWritableFile(""/dir/f"", &writable_file));
  ASSERT_OK(writable_file->Append(""foo""));
  ASSERT_OK(writable_file->Append(write_data));
  delete writable_file;

  SequentialFile* seq_file;
  Slice result;
  ASSERT_OK(env_->NewSequentialFile(""/dir/f"", &seq_file));
  ASSERT_OK(seq_file->Read(3, &result, scratch)); // Read ""foo"".
  ASSERT_EQ(0, result.compare(""foo""));

  size_t read = 0;
  std::string read_data;
  while (read < kWriteSize) {
    ASSERT_OK(seq_file->Read(kWriteSize - read, &result, scratch));
    read_data.append(result.data(), result.size());
    read += result.size();
  }
  ASSERT_TRUE(write_data == read_data);
  delete seq_file;
  delete [] scratch;
}",30,,161,1,,void
64237,BLOCK,-1,,<empty>,3,,166,1,,void
64247,BLOCK,4,,"{
    write_data.append(1, static_cast<char>(i));
  }",43,,166,4,,void
64258,BLOCK,1,,<empty>,,,,2,,void
64283,BLOCK,1,,<empty>,,,,3,,void
64306,BLOCK,1,,<empty>,,,,4,,void
64328,BLOCK,1,,<empty>,,,,2,,void
64348,BLOCK,1,,<empty>,,,,4,,void
64375,BLOCK,1,,<empty>,,,,4,,void
64402,BLOCK,-1,,"{
    ASSERT_OK(seq_file->Read(kWriteSize - read, &result, scratch));
    read_data.append(result.data(), result.size());
    read += result.size();
  }",29,,184,2,,void
64404,BLOCK,1,,<empty>,,,,6,,void
64445,BLOCK,1,,<empty>,,,,3,,void
64469,BLOCK,-1,,<empty>,,,,1,,<empty>
64473,BLOCK,-1,,"TEST(MemEnvTest, DBTest)",1,,194,1,,void
64497,BLOCK,-1,,"{
  Options options;
  options.create_if_missing = true;
  options.env = env_;
  DB* db;

  const Slice keys[] = {Slice(""aaa""), Slice(""bbb""), Slice(""ccc"")};
  const Slice vals[] = {Slice(""foo""), Slice(""bar""), Slice(""baz"")};

  ASSERT_OK(DB::Open(options, ""/dir/db"", &db));
  for (size_t i = 0; i < 3; ++i) {
    ASSERT_OK(db->Put(WriteOptions(), keys[i], vals[i]));
  }

  for (size_t i = 0; i < 3; ++i) {
    std::string res;
    ASSERT_OK(db->Get(ReadOptions(), keys[i], &res));
    ASSERT_TRUE(res == vals[i]);
  }

  Iterator* iterator = db->NewIterator(ReadOptions());
  iterator->SeekToFirst();
  for (size_t i = 0; i < 3; ++i) {
    ASSERT_TRUE(iterator->Valid());
    ASSERT_TRUE(keys[i] == iterator->key());
    ASSERT_TRUE(vals[i] == iterator->value());
    iterator->Next();
  }
  ASSERT_TRUE(!iterator->Valid());
  delete iterator;

  DBImpl* dbi = reinterpret_cast<DBImpl*>(db);
  ASSERT_OK(dbi->TEST_CompactMemTable());

  for (size_t i = 0; i < 3; ++i) {
    std::string res;
    AS...",26,,194,1,,void
64531,BLOCK,1,,<empty>,,,,3,,void
64552,BLOCK,-1,,<empty>,3,,204,1,,void
64562,BLOCK,4,,"{
    ASSERT_OK(db->Put(WriteOptions(), keys[i], vals[i]));
  }",34,,204,4,,void
64564,BLOCK,1,,<empty>,,,,4,,void
64588,BLOCK,-1,,<empty>,3,,208,1,,void
64598,BLOCK,4,,"{
    std::string res;
    ASSERT_OK(db->Get(ReadOptions(), keys[i], &res));
    ASSERT_TRUE(res == vals[i]);
  }",34,,208,4,,void
64601,BLOCK,1,,<empty>,,,,4,,void
64624,BLOCK,1,,<empty>,,,,3,,void
64655,BLOCK,-1,,<empty>,3,,216,1,,void
64665,BLOCK,4,,"{
    ASSERT_TRUE(iterator->Valid());
    ASSERT_TRUE(keys[i] == iterator->key());
    ASSERT_TRUE(vals[i] == iterator->value());
    iterator->Next();
  }",34,,216,4,,void
64671,BLOCK,1,,<empty>,,,,3,,void
64689,BLOCK,1,,<empty>,,,,3,,void
64711,BLOCK,1,,<empty>,,,,3,,void
64742,BLOCK,1,,<empty>,,,,3,,void
64773,BLOCK,1,,<empty>,,,,3,,void
64790,BLOCK,-1,,<empty>,3,,228,1,,void
64800,BLOCK,4,,"{
    std::string res;
    ASSERT_OK(db->Get(ReadOptions(), keys[i], &res));
    ASSERT_TRUE(res == vals[i]);
  }",34,,228,4,,void
64803,BLOCK,1,,<empty>,,,,4,,void
64826,BLOCK,1,,<empty>,,,,3,,void
64851,BLOCK,-1,,"{
  return leveldb::test::RunAllTests();
}",33,,239,3,,void
64871,BLOCK,-1,,<empty>,1,,1,1,,ANY
64908,BLOCK,-1,,<empty>,,,,4,,<empty>
64913,BLOCK,-1,,<empty>,,,,2,,<empty>
64924,BLOCK,-1,,<empty>,,,,8,,<empty>
64933,BLOCK,-1,,<empty>,,,,6,,<empty>
64941,BLOCK,-1,,<empty>,,,,5,,<empty>
64951,BLOCK,-1,,<empty>,,,,7,,<empty>
64957,BLOCK,-1,,<empty>,,,,3,,<empty>
64962,BLOCK,-1,,<empty>,,,,2,,<empty>
64968,BLOCK,-1,,<empty>,,,,3,,<empty>
64974,BLOCK,-1,,<empty>,,,,3,,<empty>
64985,BLOCK,-1,,<empty>,,,,8,,<empty>
64994,BLOCK,-1,,<empty>,,,,6,,<empty>
65001,BLOCK,-1,,<empty>,,,,4,,<empty>
65008,BLOCK,-1,,<empty>,,,,4,,<empty>
65013,BLOCK,-1,,<empty>,,,,2,,<empty>
65018,BLOCK,-1,,<empty>,,,,2,,<empty>
65023,BLOCK,-1,,<empty>,,,,2,,<empty>
65028,BLOCK,-1,,<empty>,,,,2,,<empty>
65035,BLOCK,-1,,<empty>,,,,4,,<empty>
65040,BLOCK,-1,,<empty>,,,,2,,<empty>
65045,BLOCK,-1,,<empty>,,,,2,,<empty>
65051,BLOCK,-1,,<empty>,,,,3,,<empty>
65057,BLOCK,-1,,<empty>,,,,3,,<empty>
65063,BLOCK,-1,,<empty>,,,,3,,<empty>
65067,BLOCK,-1,,<empty>,,,,1,,<empty>
65072,BLOCK,-1,,<empty>,,,,2,,<empty>
65077,BLOCK,-1,,<empty>,,,,2,,<empty>
65086,BLOCK,-1,,<empty>,,,,6,,<empty>
65093,BLOCK,-1,,<empty>,,,,4,,<empty>
65101,BLOCK,-1,,<empty>,,,,5,,<empty>
65105,BLOCK,-1,,<empty>,,,,1,,<empty>
65110,BLOCK,-1,,<empty>,,,,2,,<empty>
65116,BLOCK,-1,,<empty>,,,,3,,<empty>
65122,BLOCK,-1,,<empty>,,,,3,,<empty>
65128,BLOCK,-1,,<empty>,,,,3,,<empty>
65134,BLOCK,-1,,<empty>,,,,3,,<empty>
65140,BLOCK,-1,,<empty>,,,,3,,<empty>
65146,BLOCK,-1,,<empty>,,,,3,,<empty>
65152,BLOCK,-1,,<empty>,,,,3,,<empty>
65158,BLOCK,-1,,<empty>,,,,3,,<empty>
65164,BLOCK,-1,,<empty>,,,,3,,<empty>
65170,BLOCK,-1,,<empty>,,,,3,,<empty>
65176,BLOCK,-1,,<empty>,,,,3,,<empty>
65182,BLOCK,-1,,<empty>,,,,3,,<empty>
65189,BLOCK,-1,,<empty>,,,,1,,<empty>
65201,BLOCK,-1,,<empty>,,,,3,,<empty>
65209,BLOCK,-1,,<empty>,,,,5,,<empty>
65214,BLOCK,-1,,<empty>,,,,2,,<empty>
65223,BLOCK,-1,,<empty>,,,,6,,<empty>
65228,BLOCK,-1,,<empty>,,,,2,,<empty>
65233,BLOCK,-1,,<empty>,,,,2,,<empty>
65237,BLOCK,-1,,<empty>,,,,1,,<empty>
65242,BLOCK,-1,,<empty>,,,,2,,<empty>
65248,BLOCK,-1,,<empty>,,,,3,,<empty>
65254,BLOCK,-1,,<empty>,,,,3,,<empty>
65260,BLOCK,-1,,<empty>,,,,3,,<empty>
65264,BLOCK,-1,,<empty>,,,,1,,<empty>
65269,BLOCK,-1,,<empty>,,,,2,,<empty>
65275,BLOCK,-1,,<empty>,,,,3,,<empty>
65280,BLOCK,-1,,<empty>,,,,2,,<empty>
65285,BLOCK,-1,,<empty>,,,,2,,<empty>
65289,BLOCK,-1,,<empty>,,,,1,,<empty>
65294,BLOCK,-1,,<empty>,,,,2,,<empty>
65299,BLOCK,-1,,<empty>,,,,2,,<empty>
65303,BLOCK,-1,,<empty>,,,,1,,<empty>
65307,BLOCK,-1,,<empty>,,,,1,,<empty>
65318,BLOCK,-1,,<empty>,1,,1,1,,ANY
65323,BLOCK,-1,,<empty>,,,,2,,<empty>
65328,BLOCK,-1,,{ },11,,34,1,,void
65332,BLOCK,-1,,<empty>,,,,1,,<empty>
65341,BLOCK,-1,,<empty>,,,,5,,<empty>
65346,BLOCK,-1,,<empty>,,,,2,,<empty>
65351,BLOCK,-1,,<empty>,,,,2,,<empty>
65356,BLOCK,-1,,<empty>,,,,2,,<empty>
65361,BLOCK,-1,,<empty>,,,,2,,<empty>
65365,BLOCK,-1,,<empty>,,,,1,,<empty>
65369,BLOCK,-1,,<empty>,24,,89,1,,void
65373,BLOCK,-1,,<empty>,,,,1,,<empty>
65378,BLOCK,-1,,<empty>,,,,2,,<empty>
65383,BLOCK,-1,,<empty>,,,,2,,<empty>
65388,BLOCK,-1,,<empty>,,,,2,,<empty>
65395,BLOCK,-1,,<empty>,,,,2,,<empty>
65400,BLOCK,-1,,<empty>,,,,2,,<empty>
65409,BLOCK,-1,,<empty>,1,,1,1,,ANY
65414,BLOCK,-1,,<empty>,,,,1,,<empty>
65420,BLOCK,-1,,<empty>,,,,3,,<empty>
65424,BLOCK,-1,,<empty>,,,,1,,<empty>
65430,BLOCK,-1,,<empty>,,,,3,,<empty>
65435,BLOCK,-1,,<empty>,,,,2,,<empty>
65439,BLOCK,-1,,<empty>,,,,1,,<empty>
65454,BLOCK,-1,,<empty>,1,,1,1,,ANY
65470,BLOCK,-1,,<empty>,,,,1,,<empty>
65477,BLOCK,-1,,{ },11,,37,1,,void
65483,BLOCK,-1,,{ },62,,38,3,,void
65491,BLOCK,-1,,<empty>,,,,4,,<empty>
65495,BLOCK,-1,,{ },8,,55,1,,void
65499,BLOCK,-1,,<empty>,,,,1,,<empty>
65506,BLOCK,-1,,<empty>,,,,4,,<empty>
65512,BLOCK,-1,,<empty>,,,,3,,<empty>
65518,BLOCK,-1,,<empty>,,,,3,,<empty>
65525,BLOCK,-1,,<empty>,,,,4,,<empty>
65530,BLOCK,-1,,<empty>,,,,2,,<empty>
65534,BLOCK,-1,,<empty>,,,,1,,<empty>
65539,BLOCK,-1,,<empty>,,,,2,,<empty>
65545,BLOCK,-1,,<empty>,,,,3,,<empty>
65552,BLOCK,-1,,<empty>,,,,4,,<empty>
65558,BLOCK,-1,,<empty>,,,,3,,<empty>
65563,BLOCK,-1,,<empty>,,,,2,,<empty>
65568,BLOCK,-1,,<empty>,,,,2,,<empty>
65574,BLOCK,-1,,<empty>,,,,3,,<empty>
65580,BLOCK,-1,,<empty>,,,,3,,<empty>
65593,BLOCK,-1,,<empty>,1,,1,1,,ANY
65599,BLOCK,-1,,<empty>,,,,4,,<empty>
65616,BLOCK,-1,,<empty>,1,,1,1,,ANY
65626,BLOCK,-1,,{ },9,,33,1,,void
65630,BLOCK,-1,,<empty>,,,,1,,<empty>
65634,BLOCK,-1,,<empty>,,,,1,,<empty>
65640,BLOCK,-1,,<empty>,,,,3,,<empty>
65646,BLOCK,-1,,<empty>,,,,3,,<empty>
65652,BLOCK,-1,,<empty>,,,,3,,<empty>
65658,BLOCK,-1,,<empty>,,,,3,,<empty>
65663,BLOCK,-1,,<empty>,,,,2,,<empty>
65669,BLOCK,-1,,<empty>,,,,3,,<empty>
65674,BLOCK,-1,,<empty>,,,,2,,<empty>
65679,BLOCK,-1,,<empty>,,,,2,,<empty>
65684,BLOCK,-1,,<empty>,,,,2,,<empty>
65690,BLOCK,-1,,<empty>,,,,3,,<empty>
65696,BLOCK,-1,,<empty>,,,,3,,<empty>
65702,BLOCK,-1,,<empty>,,,,3,,<empty>
65707,BLOCK,-1,,<empty>,,,,2,,<empty>
65713,BLOCK,-1,,<empty>,,,,3,,<empty>
65719,BLOCK,-1,,<empty>,,,,3,,<empty>
65724,BLOCK,-1,,<empty>,,,,2,,<empty>
65730,BLOCK,-1,,<empty>,,,,3,,<empty>
65734,BLOCK,-1,,<empty>,,,,1,,<empty>
65739,BLOCK,-1,,<empty>,,,,2,,<empty>
65744,BLOCK,-1,,<empty>,,,,2,,<empty>
65749,BLOCK,-1,,<empty>,,,,2,,<empty>
65754,BLOCK,-1,,{ },20,,172,1,,void
65758,BLOCK,-1,,<empty>,,,,1,,<empty>
65765,BLOCK,-1,,<empty>,,,,4,,<empty>
65770,BLOCK,-1,,<empty>,,,,2,,<empty>
65775,BLOCK,-1,,<empty>,,,,2,,<empty>
65780,BLOCK,-1,,<empty>,,,,2,,<empty>
65785,BLOCK,-1,,{ },22,,203,1,,void
65789,BLOCK,-1,,<empty>,,,,1,,<empty>
65797,BLOCK,-1,,<empty>,,,,5,,<empty>
65802,BLOCK,-1,,<empty>,,,,2,,<empty>
65807,BLOCK,-1,,<empty>,,,,2,,<empty>
65812,BLOCK,-1,,{ },18,,229,1,,void
65816,BLOCK,-1,,<empty>,,,,1,,<empty>
65821,BLOCK,-1,,<empty>,,,,2,,<empty>
65825,BLOCK,-1,,<empty>,,,,1,,<empty>
65829,BLOCK,-1,,<empty>,,,,1,,<empty>
65833,BLOCK,-1,,<empty>,,,,1,,<empty>
65838,BLOCK,-1,,<empty>,,,,2,,<empty>
65843,BLOCK,-1,,<empty>,,,,2,,<empty>
65848,BLOCK,-1,,{ },12,,246,1,,void
65852,BLOCK,-1,,<empty>,,,,1,,<empty>
65858,BLOCK,-1,,<empty>,,,,3,,<empty>
65863,BLOCK,-1,,<empty>,,,,2,,<empty>
65868,BLOCK,-1,,<empty>,,,,2,,<empty>
65873,BLOCK,-1,,{ },14,,262,1,,void
65877,BLOCK,-1,,<empty>,,,,1,,<empty>
65882,BLOCK,-1,,<empty>,,,,2,,<empty>
65887,BLOCK,-1,,<empty>,,,,2,,<empty>
65893,BLOCK,-1,,<empty>,,,,3,,<empty>
65900,BLOCK,-1,,<empty>,,,,4,,<empty>
65907,BLOCK,-1,,<empty>,,,,4,,<empty>
65913,BLOCK,-1,,{ },44,,291,2,,void
65917,BLOCK,-1,,<empty>,,,,1,,<empty>
65921,BLOCK,-1,,{ return target_; },23,,295,1,,void
65929,BLOCK,-1,,"{
    return target_->NewSequentialFile(f, r);
  }",70,,298,3,,void
65942,BLOCK,-1,,"{
    return target_->NewRandomAccessFile(f, r);
  }",74,,301,3,,void
65955,BLOCK,-1,,"{
    return target_->NewWritableFile(f, r);
  }",66,,304,3,,void
65968,BLOCK,-1,,"{
    return target_->NewAppendableFile(f, r);
  }",68,,307,3,,void
65980,BLOCK,-1,,{ return target_->FileExists(f); },41,,310,2,,void
65992,BLOCK,-1,,"{
    return target_->GetChildren(dir, r);
  }",75,,311,3,,void
66004,BLOCK,-1,,{ return target_->DeleteFile(f); },43,,314,2,,void
66015,BLOCK,-1,,{ return target_->CreateDir(d); },42,,315,2,,void
66026,BLOCK,-1,,{ return target_->DeleteDir(d); },42,,316,2,,void
66038,BLOCK,-1,,"{
    return target_->GetFileSize(f, s);
  }",57,,317,3,,void
66051,BLOCK,-1,,"{
    return target_->RenameFile(s, t);
  }",65,,320,3,,void
66064,BLOCK,-1,,"{
    return target_->LockFile(f, l);
  }",55,,323,3,,void
66076,BLOCK,-1,,{ return target_->UnlockFile(l); },34,,326,2,,void
66088,BLOCK,-1,,"{
    return target_->Schedule(f, a);
  }",44,,327,3,,void
66101,BLOCK,-1,,"{
    return target_->StartThread(f, a);
  }",47,,330,3,,void
66113,BLOCK,-1,,"{
    return target_->GetTestDirectory(path);
  }",54,,333,2,,void
66125,BLOCK,-1,,"{
    return target_->NewLogger(fname, result);
  }",71,,336,3,,void
66136,BLOCK,-1,,"{
    return target_->NowMicros();
  }",24,,339,1,,void
66146,BLOCK,-1,,"{
    target_->SleepForMicroseconds(micros);
  }",41,,342,2,,void
66161,BLOCK,-1,,<empty>,1,,1,1,,ANY
66166,BLOCK,-1,,<empty>,,,,1,,<empty>
66170,BLOCK,-1,,<empty>,,,,1,,<empty>
66177,BLOCK,-1,,<empty>,,,,4,,<empty>
66183,BLOCK,-1,,<empty>,,,,3,,<empty>
66188,BLOCK,-1,,<empty>,,,,2,,<empty>
66199,BLOCK,-1,,<empty>,1,,1,1,,ANY
66203,BLOCK,-1,,<empty>,,,,1,,<empty>
66207,BLOCK,-1,,<empty>,,,,1,,<empty>
66211,BLOCK,-1,,<empty>,,,,1,,<empty>
66215,BLOCK,-1,,<empty>,,,,1,,<empty>
66219,BLOCK,-1,,<empty>,,,,1,,<empty>
66224,BLOCK,-1,,<empty>,,,,2,,<empty>
66228,BLOCK,-1,,<empty>,,,,1,,<empty>
66232,BLOCK,-1,,<empty>,,,,1,,<empty>
66236,BLOCK,-1,,<empty>,,,,1,,<empty>
66240,BLOCK,-1,,<empty>,,,,1,,<empty>
66244,BLOCK,-1,,<empty>,,,,1,,<empty>
66250,BLOCK,-1,,<empty>,,,,3,,<empty>
66257,BLOCK,-1,,<empty>,,,,4,,<empty>
66268,BLOCK,-1,,<empty>,,,,2,,<empty>
66273,BLOCK,-1,,<empty>,,,,2,,<empty>
66277,BLOCK,-1,,<empty>,,,,1,,<empty>
66282,BLOCK,-1,,<empty>,,,,2,,<empty>
66291,BLOCK,-1,,<empty>,1,,1,1,,ANY
66303,BLOCK,-1,,<empty>,,,,1,,<empty>
66329,BLOCK,-1,,<empty>,,,,1,,<empty>
66337,BLOCK,-1,,"{
  }",24,,182,1,,void
66343,BLOCK,-1,,"{
  }",21,,207,1,,void
66358,BLOCK,-1,,<empty>,1,,1,1,,ANY
66362,BLOCK,-1,,{ },33,,28,1,,void
66368,BLOCK,-1,,{ },55,,31,3,,void
66373,BLOCK,-1,,{ },66,,34,2,,void
66378,BLOCK,-1,,{ },53,,37,2,,void
66382,BLOCK,-1,,{ return data_; },28,,40,1,,void
66388,BLOCK,-1,,{ return size_; },23,,43,1,,void
66394,BLOCK,-1,,{ return size_ == 0; },22,,46,1,,void
66403,BLOCK,-1,,"{
    assert(n < size());
    return data_[n];
  }",35,,50,2,,void
66415,BLOCK,-1,,"{ data_ = """"; size_ = 0; }",16,,56,1,,void
66426,BLOCK,-1,,"{
    assert(n <= size());
    data_ += n;
    size_ -= n;
  }",32,,59,2,,void
66440,BLOCK,-1,,"{ return std::string(data_, size_); }",32,,66,1,,void
66452,BLOCK,-1,,<empty>,,,,2,,<empty>
66457,BLOCK,-1,,"{
    return ((size_ >= x.size_) &&
            (memcmp(data_, x.data_, x.size_) == 0));
  }",42,,75,2,,void
66482,BLOCK,-1,,"{
  return ((x.size() == y.size()) &&
          (memcmp(x.data(), y.data(), x.size()) == 0));
}",56,,87,3,,void
66514,BLOCK,-1,,"{
  return !(x == y);
}",56,,92,3,,void
66524,BLOCK,-1,,"{
  const size_t min_len = (size_ < b.size_) ? size_ : b.size_;
  int r = memcmp(data_, b.data_, min_len);
  if (r == 0) {
    if (size_ < b.size_) r = -1;
    else if (size_ > b.size_) r = +1;
  }
  return r;
}",49,,96,2,,void
66551,BLOCK,-1,,"{
    if (size_ < b.size_) r = -1;
    else if (size_ > b.size_) r = +1;
  }",15,,99,2,,void
66558,BLOCK,-1,,<empty>,26,,100,2,,void
66564,BLOCK,-1,,<empty>,10,,101,1,,void
66571,BLOCK,-1,,<empty>,31,,101,2,,void
66588,BLOCK,-1,,<empty>,1,,1,1,,ANY
66592,BLOCK,-1,,{ },27,,24,1,,void
66596,BLOCK,-1,,{ delete[] state_; },13,,25,1,,void
66603,BLOCK,-1,,<empty>,,,,2,,<empty>
66608,BLOCK,-1,,<empty>,,,,2,,<empty>
66612,BLOCK,-1,,{ return Status(); },22,,32,1,,void
66620,BLOCK,-1,,"{
    return Status(kNotFound, msg, msg2);
  }",73,,35,3,,void
66631,BLOCK,-1,,"{
    return Status(kCorruption, msg, msg2);
  }",75,,38,3,,void
66642,BLOCK,-1,,"{
    return Status(kNotSupported, msg, msg2);
  }",77,,41,3,,void
66653,BLOCK,-1,,"{
    return Status(kInvalidArgument, msg, msg2);
  }",80,,44,3,,void
66664,BLOCK,-1,,"{
    return Status(kIOError, msg, msg2);
  }",72,,47,3,,void
66673,BLOCK,-1,,{ return (state_ == NULL); },19,,52,1,,void
66681,BLOCK,-1,,{ return code() == kNotFound; },27,,55,1,,void
66689,BLOCK,-1,,{ return code() == kCorruption; },29,,58,1,,void
66697,BLOCK,-1,,{ return code() == kIOError; },26,,61,1,,void
66705,BLOCK,-1,,{ return code() == kNotSupported; },36,,64,1,,void
66713,BLOCK,-1,,{ return code() == kInvalidArgument; },34,,67,1,,void
66721,BLOCK,-1,,<empty>,,,,1,,<empty>
66733,BLOCK,-1,,<empty>,,,,1,,<empty>
66755,BLOCK,-1,,"{
    return (state_ == NULL) ? kOk : static_cast<Code>(state_[4]);
  }",21,,90,1,,void
66773,BLOCK,-1,,<empty>,,,,4,,<empty>
66778,BLOCK,-1,,<empty>,,,,2,,<empty>
66783,BLOCK,-1,,"{
  state_ = (s.state_ == NULL) ? NULL : CopyState(s.state_);
}",40,,98,2,,void
66801,BLOCK,-1,,"{
  // The following condition catches both aliasing (when this == &s),
  // and the common case where both s and *this are ok.
  if (state_ != s.state_) {
    delete[] state_;
    state_ = (s.state_ == NULL) ? NULL : CopyState(s.state_);
  }
}",48,,101,2,,void
66808,BLOCK,-1,,"{
    delete[] state_;
    state_ = (s.state_ == NULL) ? NULL : CopyState(s.state_);
  }",27,,104,2,,void
66834,BLOCK,-1,,<empty>,1,,1,1,,ANY
66849,BLOCK,-1,,<empty>,,,,5,,<empty>
66853,BLOCK,-1,,<empty>,,,,1,,<empty>
66858,BLOCK,-1,,<empty>,,,,2,,<empty>
66863,BLOCK,-1,,<empty>,,,,2,,<empty>
66870,BLOCK,-1,,{ rep_ = rep; },28,,62,2,,void
66880,BLOCK,-1,,<empty>,,,,4,,<empty>
66889,BLOCK,-1,,<empty>,,,,5,,<empty>
66894,BLOCK,-1,,<empty>,,,,2,,<empty>
66899,BLOCK,-1,,<empty>,,,,2,,<empty>
66904,BLOCK,-1,,<empty>,,,,2,,<empty>
66909,BLOCK,-1,,<empty>,,,,2,,<empty>
66922,BLOCK,-1,,<empty>,1,,1,1,,ANY
66931,BLOCK,-1,,<empty>,,,,3,,<empty>
66935,BLOCK,-1,,<empty>,,,,1,,<empty>
66940,BLOCK,-1,,<empty>,,,,2,,<empty>
66946,BLOCK,-1,,<empty>,,,,3,,<empty>
66950,BLOCK,-1,,<empty>,,,,1,,<empty>
66954,BLOCK,-1,,<empty>,,,,1,,<empty>
66958,BLOCK,-1,,<empty>,,,,1,,<empty>
66962,BLOCK,-1,,<empty>,,,,1,,<empty>
66966,BLOCK,-1,,<empty>,,,,1,,<empty>
66970,BLOCK,-1,,<empty>,,,,1,,<empty>
66974,BLOCK,-1,,{ return status().ok(); },19,,78,1,,void
66985,BLOCK,-1,,<empty>,,,,3,,<empty>
66992,BLOCK,-1,,<empty>,,,,4,,<empty>
66999,BLOCK,-1,,<empty>,,,,2,,<empty>
67004,BLOCK,-1,,<empty>,,,,2,,<empty>
67015,BLOCK,-1,,<empty>,1,,1,1,,ANY
67020,BLOCK,-1,,<empty>,,,,1,,<empty>
67024,BLOCK,-1,,<empty>,,,,1,,<empty>
67030,BLOCK,-1,,<empty>,,,,3,,<empty>
67035,BLOCK,-1,,<empty>,,,,2,,<empty>
67039,BLOCK,-1,,<empty>,,,,1,,<empty>
67044,BLOCK,-1,,<empty>,,,,1,,<empty>
67050,BLOCK,-1,,<empty>,,,,3,,<empty>
67055,BLOCK,-1,,<empty>,,,,2,,<empty>
67060,BLOCK,-1,,<empty>,,,,2,,<empty>
67081,BLOCK,-1,,<empty>,1,,1,1,,ANY
67089,BLOCK,-1,,"{
  char buf[100];
  snprintf(buf, sizeof(buf), ""my_key_%d"", i);
  return buf;
}",25,,18,2,,void
67103,BLOCK,-1,,"{
  return Key1(i) + ""_xxx"";
}",25,,24,2,,void
67114,BLOCK,-1,,<empty>,,,,1,,<empty>
67118,BLOCK,-1,,"TEST(Issue178, Test)",1,,30,1,,void
67142,BLOCK,-1,,"{
  // Get rid of any state from an old run.
  std::string dbpath = leveldb::test::TmpDir() + ""/leveldb_cbug_test"";
  DestroyDB(dbpath, leveldb::Options());

  // Open database.  Disable compression since it affects the creation
  // of layers and the code below is trying to test against a very
  // specific scenario.
  leveldb::DB* db;
  leveldb::Options db_options;
  db_options.create_if_missing = true;
  db_options.compression = leveldb::kNoCompression;
  ASSERT_OK(leveldb::DB::Open(db_options, dbpath, &db));

  // create first key range
  leveldb::WriteBatch batch;
  for (size_t i = 0; i < kNumKeys; i++) {
    batch.Put(Key1(i), ""value for range 1 key"");
  }
  ASSERT_OK(db->Write(leveldb::WriteOptions(), &batch));

  // create second key range
  batch.Clear();
  for (size_t i = 0; i < kNumKeys; i++) {
    batch.Put(Key2(i), ""value for range 2 key"");
  }
  ASSERT_OK(db->Write(leveldb::WriteOptions(), &batch));

  // delete second key range
  batch.Clear();
  for (size_t i = 0; i ...",22,,30,1,,void
67175,BLOCK,1,,<empty>,,,,4,,void
67199,BLOCK,-1,,<empty>,3,,46,1,,void
67209,BLOCK,4,,"{
    batch.Put(Key1(i), ""value for range 1 key"");
  }",41,,46,4,,void
67218,BLOCK,1,,<empty>,,,,3,,void
67245,BLOCK,-1,,<empty>,3,,53,1,,void
67255,BLOCK,4,,"{
    batch.Put(Key2(i), ""value for range 2 key"");
  }",41,,53,4,,void
67264,BLOCK,1,,<empty>,,,,3,,void
67291,BLOCK,-1,,<empty>,3,,60,1,,void
67301,BLOCK,4,,"{
    batch.Delete(Key2(i));
  }",41,,60,4,,void
67309,BLOCK,1,,<empty>,,,,3,,void
67387,BLOCK,-1,,<empty>,3,,77,1,,void
67400,BLOCK,4,,"{
    num_keys++;
  }",58,,77,4,,void
67409,BLOCK,1,,<empty>,,,,5,,void
67437,BLOCK,-1,,"{
  return leveldb::test::RunAllTests();
}",33,,90,3,,void
67455,BLOCK,-1,,<empty>,1,,1,1,,ANY
67460,BLOCK,-1,,<empty>,,,,1,,<empty>
67464,BLOCK,-1,,"TEST(Issue200, Test)",1,,16,1,,void
67488,BLOCK,-1,,"{
  // Get rid of any state from an old run.
  std::string dbpath = test::TmpDir() + ""/leveldb_issue200_test"";
  DestroyDB(dbpath, Options());

  DB *db;
  Options options;
  options.create_if_missing = true;
  ASSERT_OK(DB::Open(options, dbpath, &db));

  WriteOptions write_options;
  ASSERT_OK(db->Put(write_options, ""1"", ""b""));
  ASSERT_OK(db->Put(write_options, ""2"", ""c""));
  ASSERT_OK(db->Put(write_options, ""3"", ""d""));
  ASSERT_OK(db->Put(write_options, ""4"", ""e""));
  ASSERT_OK(db->Put(write_options, ""5"", ""f""));

  ReadOptions read_options;
  Iterator *iter = db->NewIterator(read_options);

  // Add an element that should not be reflected in the iterator.
  ASSERT_OK(db->Put(write_options, ""25"", ""cd""));

  iter->Seek(""5"");
  ASSERT_EQ(iter->key().ToString(), ""5"");
  iter->Prev();
  ASSERT_EQ(iter->key().ToString(), ""4"");
  iter->Prev();
  ASSERT_EQ(iter->key().ToString(), ""3"");
  iter->Next();
  ASSERT_EQ(iter->key().ToString(), ""4"");
  iter->Next();
  ASSERT_EQ(iter->key().ToStri...",22,,16,1,,void
67509,BLOCK,1,,<empty>,,,,4,,void
67531,BLOCK,1,,<empty>,,,,3,,void
67551,BLOCK,1,,<empty>,,,,3,,void
67571,BLOCK,1,,<empty>,,,,3,,void
67591,BLOCK,1,,<empty>,,,,3,,void
67611,BLOCK,1,,<empty>,,,,3,,void
67640,BLOCK,1,,<empty>,,,,3,,void
67673,BLOCK,1,,<empty>,,,,4,,void
67706,BLOCK,1,,<empty>,,,,4,,void
67739,BLOCK,1,,<empty>,,,,4,,void
67772,BLOCK,1,,<empty>,,,,4,,void
67805,BLOCK,1,,<empty>,,,,4,,void
67837,BLOCK,-1,,"{
  return leveldb::test::RunAllTests();
}",33,,57,3,,void
67859,BLOCK,-1,,<empty>,1,,1,1,,ANY
67872,BLOCK,-1,,<empty>,1,,1,1,,ANY
67877,BLOCK,-1,,<empty>,1,,1,1,,ANY
67886,BLOCK,-1,,<empty>,,,,1,,<empty>
67890,BLOCK,-1,,<empty>,,,,1,,<empty>
67894,BLOCK,-1,,<empty>,,,,1,,<empty>
67898,BLOCK,-1,,<empty>,,,,1,,<empty>
67902,BLOCK,-1,,<empty>,,,,1,,<empty>
67908,BLOCK,-1,,<empty>,,,,2,,<empty>
67912,BLOCK,-1,,<empty>,,,,1,,<empty>
67916,BLOCK,-1,,<empty>,,,,1,,<empty>
67920,BLOCK,-1,,<empty>,,,,1,,<empty>
67924,BLOCK,-1,,<empty>,,,,1,,<empty>
67931,BLOCK,-1,,<empty>,,,,3,,<empty>
67937,BLOCK,-1,,<empty>,,,,1,,<empty>
67942,BLOCK,-1,,{ },45,,83,2,,void
67946,BLOCK,-1,,<empty>,,,,1,,<empty>
67951,BLOCK,-1,,<empty>,,,,2,,<empty>
67955,BLOCK,-1,,<empty>,,,,1,,<empty>
67960,BLOCK,-1,,<empty>,,,,2,,<empty>
67967,BLOCK,-1,,<empty>,,,,4,,<empty>
67974,BLOCK,-1,,<empty>,,,,4,,<empty>
67981,BLOCK,-1,,<empty>,,,,4,,<empty>
67987,BLOCK,-1,,<empty>,,,,3,,<empty>
67994,BLOCK,-1,,<empty>,,,,4,,<empty>
68009,BLOCK,-1,,<empty>,1,,1,1,,ANY
68015,BLOCK,-1,,"{
  if (result != 0) {
    fprintf(stderr, ""pthread %s: %s\n"", label, strerror(result));
    abort();
  }
}",56,,14,3,,void
68020,BLOCK,-1,,"{
    fprintf(stderr, ""pthread %s: %s\n"", label, strerror(result));
    abort();
  }",20,,15,2,,void
68031,BLOCK,-1,,"{ PthreadCall(""init mutex"", pthread_mutex_init(&mu_, NULL)); }",16,,21,1,,void
68041,BLOCK,-1,,"{ PthreadCall(""destroy mutex"", pthread_mutex_destroy(&mu_)); }",17,,23,1,,void
68050,BLOCK,-1,,"{ PthreadCall(""lock"", pthread_mutex_lock(&mu_)); }",20,,25,1,,void
68059,BLOCK,-1,,"{ PthreadCall(""unlock"", pthread_mutex_unlock(&mu_)); }",22,,27,1,,void
68069,BLOCK,-1,,"{
    PthreadCall(""init cv"", pthread_cond_init(&cv_, NULL));
}",15,,30,2,,void
68079,BLOCK,-1,,"{ PthreadCall(""destroy cv"", pthread_cond_destroy(&cv_)); }",21,,34,1,,void
68088,BLOCK,-1,,"{
  PthreadCall(""wait"", pthread_cond_wait(&cv_, &mu_->mu_));
}",22,,36,1,,void
68101,BLOCK,-1,,"{
  PthreadCall(""signal"", pthread_cond_signal(&cv_));
}",24,,40,1,,void
68110,BLOCK,-1,,"{
  PthreadCall(""broadcast"", pthread_cond_broadcast(&cv_));
}",27,,44,1,,void
68121,BLOCK,-1,,"{
  PthreadCall(""once"", pthread_once(once, initializer));
}",54,,48,3,,void
68155,BLOCK,-1,,<empty>,1,,1,1,,ANY
68162,BLOCK,1,,<empty>,,,,1,,void
68169,BLOCK,-1,,<empty>,,,,1,,<empty>
68173,BLOCK,-1,,<empty>,,,,1,,<empty>
68177,BLOCK,-1,,<empty>,,,,1,,<empty>
68181,BLOCK,-1,,<empty>,,,,1,,<empty>
68185,BLOCK,-1,,{ },21,,89,1,,void
68192,BLOCK,-1,,<empty>,,,,2,,<empty>
68197,BLOCK,-1,,<empty>,,,,2,,<empty>
68203,BLOCK,-1,,<empty>,,,,2,,<empty>
68207,BLOCK,-1,,<empty>,,,,1,,<empty>
68211,BLOCK,-1,,<empty>,,,,1,,<empty>
68215,BLOCK,-1,,<empty>,,,,1,,<empty>
68219,BLOCK,-1,,<empty>,,,,1,,<empty>
68228,BLOCK,-1,,<empty>,,,,3,,<empty>
68235,BLOCK,-1,,"{
#ifdef SNAPPY
  output->resize(snappy::MaxCompressedLength(length));
  size_t outlen;
  snappy::RawCompress(input, length, &(*output)[0], &outlen);
  output->resize(outlen);
  return true;
#endif

  return false;
}",52,,117,4,,void
68244,BLOCK,-1,,"{
#ifdef SNAPPY
  return snappy::GetUncompressedLength(input, length, result);
#else
  return false;
#endif
}",58,,130,4,,void
68253,BLOCK,-1,,"{
#ifdef SNAPPY
  return snappy::RawUncompress(input, length, output);
#else
  return false;
#endif
}",45,,139,4,,void
68261,BLOCK,-1,,"{
  return false;
}",78,,147,3,,void
68270,BLOCK,-1,,<empty>,,,,4,,<empty>
68289,BLOCK,-1,,<empty>,1,,1,1,,ANY
68296,BLOCK,-1,,"{
#if !defined(LEVELDB_PLATFORM_POSIX_SSE)
  return 0;
#else
  static bool have = HaveSSE42();
  if (!have) {
    return 0;
  }

  const uint8_t *p = reinterpret_cast<const uint8_t *>(buf);
  const uint8_t *e = p + size;
  uint32_t l = crc ^ 0xffffffffu;

#define STEP1 do {                              \
    l = _mm_crc32_u8(l, *p++);                  \
} while (0)
#define STEP4 do {                              \
    l = _mm_crc32_u32(l, LE_LOAD32(p));         \
    p += 4;                                     \
} while (0)
#define STEP8 do {                              \
    l = _mm_crc32_u64(l, LE_LOAD64(p));         \
    p += 8;                                     \
} while (0)

  if (size > 16) {
    // Process unaligned bytes
    for (unsigned int i = reinterpret_cast<uintptr_t>(p) % 8; i; --i) {
      STEP1;
    }

    // _mm_crc32_u64 is only available on x64.
#if defined(_M_X64) || defined(__x86_64__)
    // Process 8 bytes at a time
    while ((e-p) >= 8) {
      STEP8;
 ...",72,,69,4,,void
68305,BLOCK,-1,,<empty>,1,,1,1,,ANY
68310,BLOCK,-1,,<empty>,1,,1,1,,ANY
68337,BLOCK,-1,,<empty>,1,,1,1,,ANY
68340,BLOCK,-1,,"{
  assert(size_ >= sizeof(uint32_t));
  return DecodeFixed32(data_ + size_ - sizeof(uint32_t));
}",44,,18,1,,void
68358,BLOCK,-1,,"{
  if (size_ < sizeof(uint32_t)) {
    size_ = 0;  // Error marker
  } else {
    size_t max_restarts_allowed = (size_-sizeof(uint32_t)) / sizeof(uint32_t);
    if (NumRestarts() > max_restarts_allowed) {
      // The size is too small for NumRestarts()
      size_ = 0;
    } else {
      restart_offset_ = size_ - (1 + NumRestarts()) * sizeof(uint32_t);
    }
  }
}",39,,26,2,,void
68364,BLOCK,-1,,"{
    size_ = 0;  // Error marker
  }",33,,27,2,,void
68369,BLOCK,-1,,"{
    size_t max_restarts_allowed = (size_-sizeof(uint32_t)) / sizeof(uint32_t);
    if (NumRestarts() > max_restarts_allowed) {
      // The size is too small for NumRestarts()
      size_ = 0;
    } else {
      restart_offset_ = size_ - (1 + NumRestarts()) * sizeof(uint32_t);
    }
  }",10,,29,1,,void
68384,BLOCK,-1,,"{
      // The size is too small for NumRestarts()
      size_ = 0;
    }",47,,31,2,,void
68389,BLOCK,-1,,"{
      restart_offset_ = size_ - (1 + NumRestarts()) * sizeof(uint32_t);
    }",12,,34,1,,void
68403,BLOCK,-1,,"{
  if (owned_) {
    delete[] data_;
  }
}",17,,40,1,,void
68406,BLOCK,-1,,"{
    delete[] data_;
  }",15,,41,2,,void
68417,BLOCK,-1,,"{
  if (limit - p < 3) return NULL;
  *shared = reinterpret_cast<const unsigned char*>(p)[0];
  *non_shared = reinterpret_cast<const unsigned char*>(p)[1];
  *value_length = reinterpret_cast<const unsigned char*>(p)[2];
  if ((*shared | *non_shared | *value_length) < 128) {
    // Fast path: all three values are encoded in one byte each
    p += 3;
  } else {
    if ((p = GetVarint32Ptr(p, limit, shared)) == NULL) return NULL;
    if ((p = GetVarint32Ptr(p, limit, non_shared)) == NULL) return NULL;
    if ((p = GetVarint32Ptr(p, limit, value_length)) == NULL) return NULL;
  }

  if (static_cast<uint32_t>(limit - p) < (*non_shared + *value_length)) {
    return NULL;
  }
  return p;
}",63,,56,6,,void
68424,BLOCK,-1,,<empty>,22,,57,2,,void
68462,BLOCK,-1,,"{
    // Fast path: all three values are encoded in one byte each
    p += 3;
  }",54,,61,2,,void
68467,BLOCK,-1,,"{
    if ((p = GetVarint32Ptr(p, limit, shared)) == NULL) return NULL;
    if ((p = GetVarint32Ptr(p, limit, non_shared)) == NULL) return NULL;
    if ((p = GetVarint32Ptr(p, limit, value_length)) == NULL) return NULL;
  }",10,,64,1,,void
68477,BLOCK,-1,,<empty>,57,,65,2,,void
68489,BLOCK,-1,,<empty>,61,,66,2,,void
68501,BLOCK,-1,,<empty>,63,,67,2,,void
68516,BLOCK,-1,,"{
    return NULL;
  }",73,,70,2,,void
68536,BLOCK,-1,,"{
    return comparator_->Compare(a, b);
  }",60,,90,3,,void
68547,BLOCK,-1,,"{
    return (value_.data() + value_.size()) - data_;
  }",43,,95,1,,void
68564,BLOCK,-1,,"{
    assert(index < num_restarts_);
    return DecodeFixed32(data_ + restarts_ + index * sizeof(uint32_t));
  }",44,,99,2,,void
68583,BLOCK,-1,,"{
    key_.clear();
    restart_index_ = index;
    // current_ will be fixed by ParseNextKey();

    // ParseNextKey() starts at the end of value_, so set value_ accordingly
    uint32_t offset = GetRestartPoint(index);
    value_ = Slice(data_ + offset, 0);
  }",43,,104,2,,void
68610,BLOCK,-1,,"{
    assert(num_restarts_ > 0);
  }",39,,124,5,,void
68618,BLOCK,-1,,{ return current_ < restarts_; },30,,128,1,,void
68626,BLOCK,-1,,{ return status_; },33,,129,1,,void
68632,BLOCK,-1,,"{
    assert(Valid());
    return key_;
  }",29,,130,1,,void
68640,BLOCK,-1,,"{
    assert(Valid());
    return value_;
  }",31,,134,1,,void
68648,BLOCK,-1,,"{
    assert(Valid());
    ParseNextKey();
  }",23,,139,1,,void
68655,BLOCK,-1,,"{
    assert(Valid());

    // Scan backwards to a restart point before current_
    const uint32_t original = current_;
    while (GetRestartPoint(restart_index_) >= original) {
      if (restart_index_ == 0) {
        // No more entries
        current_ = restarts_;
        restart_index_ = num_restarts_;
        return;
      }
      restart_index_--;
    }

    SeekToRestartPoint(restart_index_);
    do {
      // Loop until end of current entry hits the start of original entry
    } while (ParseNextKey() && NextEntryOffset() < original);
  }",23,,144,1,,void
68667,BLOCK,-1,,"{
      if (restart_index_ == 0) {
        // No more entries
        current_ = restarts_;
        restart_index_ = num_restarts_;
        return;
      }
      restart_index_--;
    }",57,,149,2,,void
68672,BLOCK,-1,,"{
        // No more entries
        current_ = restarts_;
        restart_index_ = num_restarts_;
        return;
      }",32,,150,2,,void
68685,BLOCK,-1,,"{
      // Loop until end of current entry hits the start of original entry
    }",8,,160,1,,void
68695,BLOCK,-1,,"{
    // Binary search in restart array to find the last restart point
    // with a key < target
    uint32_t left = 0;
    uint32_t right = num_restarts_ - 1;
    while (left < right) {
      uint32_t mid = (left + right + 1) / 2;
      uint32_t region_offset = GetRestartPoint(mid);
      uint32_t shared, non_shared, value_length;
      const char* key_ptr = DecodeEntry(data_ + region_offset,
                                        data_ + restarts_,
                                        &shared, &non_shared, &value_length);
      if (key_ptr == NULL || (shared != 0)) {
        CorruptionError();
        return;
      }
      Slice mid_key(key_ptr, non_shared);
      if (Compare(mid_key, target) < 0) {
        // Key at ""mid"" is smaller than ""target"".  Therefore all
        // blocks before ""mid"" are uninteresting.
        left = mid;
      } else {
        // Key at ""mid"" is >= ""target"".  Therefore all blocks at or
        // after ""mid"" are uninteresting.
        right = mid -...",42,,165,2,,void
68710,BLOCK,-1,,"{
      uint32_t mid = (left + right + 1) / 2;
      uint32_t region_offset = GetRestartPoint(mid);
      uint32_t shared, non_shared, value_length;
      const char* key_ptr = DecodeEntry(data_ + region_offset,
                                        data_ + restarts_,
                                        &shared, &non_shared, &value_length);
      if (key_ptr == NULL || (shared != 0)) {
        CorruptionError();
        return;
      }
      Slice mid_key(key_ptr, non_shared);
      if (Compare(mid_key, target) < 0) {
        // Key at ""mid"" is smaller than ""target"".  Therefore all
        // blocks before ""mid"" are uninteresting.
        left = mid;
      } else {
        // Key at ""mid"" is >= ""target"".  Therefore all blocks at or
        // after ""mid"" are uninteresting.
        right = mid - 1;
      }
    }",26,,170,2,,void
68753,BLOCK,-1,,"{
        CorruptionError();
        return;
      }",45,,177,2,,void
68766,BLOCK,-1,,"{
        // Key at ""mid"" is smaller than ""target"".  Therefore all
        // blocks before ""mid"" are uninteresting.
        left = mid;
      }",41,,182,2,,void
68771,BLOCK,-1,,"{
        // Key at ""mid"" is >= ""target"".  Therefore all blocks at or
        // after ""mid"" are uninteresting.
        right = mid - 1;
      }",14,,186,1,,void
68781,BLOCK,-1,,"{
      if (!ParseNextKey()) {
        return;
      }
      if (Compare(key_, target) >= 0) {
        return;
      }
    }",18,,195,2,,void
68785,BLOCK,-1,,"{
        return;
      }",28,,196,2,,void
68793,BLOCK,-1,,"{
        return;
      }",39,,199,2,,void
68798,BLOCK,-1,,"{
    SeekToRestartPoint(0);
    ParseNextKey();
  }",30,,205,1,,void
68805,BLOCK,-1,,"{
    SeekToRestartPoint(num_restarts_ - 1);
    while (ParseNextKey() && NextEntryOffset() < restarts_) {
      // Keep skipping
    }
  }",29,,210,1,,void
68816,BLOCK,-1,,"{
      // Keep skipping
    }",61,,212,2,,void
68820,BLOCK,-1,,"{
    current_ = restarts_;
    restart_index_ = num_restarts_;
    status_ = Status::Corruption(""bad entry in block"");
    key_.clear();
    value_.clear();
  }",26,,218,1,,void
68845,BLOCK,-1,,"{
    current_ = NextEntryOffset();
    const char* p = data_ + current_;
    const char* limit = data_ + restarts_;  // Restarts come right after data
    if (p >= limit) {
      // No more entries to return.  Mark as invalid.
      current_ = restarts_;
      restart_index_ = num_restarts_;
      return false;
    }

    // Decode next entry
    uint32_t shared, non_shared, value_length;
    p = DecodeEntry(p, limit, &shared, &non_shared, &value_length);
    if (p == NULL || key_.size() < shared) {
      CorruptionError();
      return false;
    } else {
      key_.resize(shared);
      key_.append(p, non_shared);
      value_ = Slice(p + non_shared, value_length);
      while (restart_index_ + 1 < num_restarts_ &&
             GetRestartPoint(restart_index_ + 1) < current_) {
        ++restart_index_;
      }
      return true;
    }
  }",23,,226,1,,void
68865,BLOCK,-1,,"{
      // No more entries to return.  Mark as invalid.
      current_ = restarts_;
      restart_index_ = num_restarts_;
      return false;
    }",21,,230,2,,void
68899,BLOCK,-1,,"{
      CorruptionError();
      return false;
    }",44,,240,2,,void
68904,BLOCK,-1,,"{
      key_.resize(shared);
      key_.append(p, non_shared);
      value_ = Slice(p + non_shared, value_length);
      while (restart_index_ + 1 < num_restarts_ &&
             GetRestartPoint(restart_index_ + 1) < current_) {
        ++restart_index_;
      }
      return true;
    }",12,,243,1,,void
68936,BLOCK,-1,,"{
        ++restart_index_;
      }",62,,248,2,,void
68945,BLOCK,-1,,"{
  if (size_ < sizeof(uint32_t)) {
    return NewErrorIterator(Status::Corruption(""bad block contents""));
  }
  const uint32_t num_restarts = NumRestarts();
  if (num_restarts == 0) {
    return NewEmptyIterator();
  } else {
    return new Iter(cmp, data_, restart_offset_, num_restarts);
  }
}",53,,256,2,,void
68951,BLOCK,-1,,"{
    return NewErrorIterator(Status::Corruption(""bad block contents""));
  }",33,,257,2,,void
68967,BLOCK,-1,,"{
    return NewEmptyIterator();
  }",26,,261,2,,void
68971,BLOCK,-1,,"{
    return new Iter(cmp, data_, restart_offset_, num_restarts);
  }",10,,263,1,,void
68991,BLOCK,-1,,<empty>,1,,1,1,,ANY
68998,BLOCK,-1,,<empty>,,,,2,,<empty>
69002,BLOCK,-1,,<empty>,,,,1,,<empty>
69006,BLOCK,-1,,{ return size_; },23,,24,1,,void
69013,BLOCK,-1,,<empty>,,,,2,,<empty>
69017,BLOCK,-1,,<empty>,,,,1,,<empty>
69026,BLOCK,-1,,<empty>,,,,2,,<empty>
69031,BLOCK,-1,,<empty>,,,,2,,<empty>
69051,BLOCK,-1,,<empty>,1,,1,1,,ANY
69055,BLOCK,-1,,"{
  assert(options->block_restart_interval >= 1);
  restarts_.push_back(0);       // First restart point is at offset 0
}",24,,43,2,,void
69070,BLOCK,-1,,"{
  buffer_.clear();
  restarts_.clear();
  restarts_.push_back(0);       // First restart point is at offset 0
  counter_ = 0;
  finished_ = false;
  last_key_.clear();
}",28,,48,1,,void
69097,BLOCK,-1,,"{
  return (buffer_.size() +                        // Raw data buffer
          restarts_.size() * sizeof(uint32_t) +   // Restart array
          sizeof(uint32_t));                      // Restart array length
}",50,,57,1,,void
69117,BLOCK,-1,,"{
  // Append restart array
  for (size_t i = 0; i < restarts_.size(); i++) {
    PutFixed32(&buffer_, restarts_[i]);
  }
  PutFixed32(&buffer_, restarts_.size());
  finished_ = true;
  return Slice(buffer_);
}",30,,63,1,,void
69119,BLOCK,-1,,<empty>,3,,65,1,,void
69132,BLOCK,4,,"{
    PutFixed32(&buffer_, restarts_[i]);
  }",49,,65,4,,void
69157,BLOCK,-1,,"{
  Slice last_key_piece(last_key_);
  assert(!finished_);
  assert(counter_ <= options_->block_restart_interval);
  assert(buffer_.empty() // No values yet?
         || options_->comparator->Compare(key, last_key_piece) > 0);
  size_t shared = 0;
  if (counter_ < options_->block_restart_interval) {
    // See how much sharing to do with previous string
    const size_t min_length = std::min(last_key_piece.size(), key.size());
    while ((shared < min_length) && (last_key_piece[shared] == key[shared])) {
      shared++;
    }
  } else {
    // Restart compression
    restarts_.push_back(buffer_.size());
    counter_ = 0;
  }
  const size_t non_shared = key.size() - shared;

  // Add ""<shared><non_shared><value_size>"" to buffer_
  PutVarint32(&buffer_, shared);
  PutVarint32(&buffer_, non_shared);
  PutVarint32(&buffer_, value.size());

  // Add string delta to buffer_ followed by value
  buffer_.append(key.data() + shared, non_shared);
  buffer_.append(value.data(), value.size());

...",62,,73,3,,void
69196,BLOCK,-1,,"{
    // See how much sharing to do with previous string
    const size_t min_length = std::min(last_key_piece.size(), key.size());
    while ((shared < min_length) && (last_key_piece[shared] == key[shared])) {
      shared++;
    }
  }",52,,80,2,,void
69224,BLOCK,-1,,"{
      shared++;
    }",78,,83,2,,void
69228,BLOCK,-1,,"{
    // Restart compression
    restarts_.push_back(buffer_.size());
    counter_ = 0;
  }",10,,86,1,,void
69322,BLOCK,-1,,<empty>,1,,1,1,,ANY
69328,BLOCK,-1,,<empty>,,,,2,,<empty>
69332,BLOCK,-1,,<empty>,,,,1,,<empty>
69338,BLOCK,-1,,<empty>,,,,3,,<empty>
69342,BLOCK,-1,,<empty>,,,,1,,<empty>
69346,BLOCK,-1,,<empty>,,,,1,,<empty>
69350,BLOCK,-1,,"{
    return buffer_.empty();
  }",22,,38,1,,void
69366,BLOCK,-1,,<empty>,,,,2,,<empty>
69371,BLOCK,-1,,<empty>,,,,2,,<empty>
69384,BLOCK,-1,,<empty>,1,,1,1,,ANY
69398,BLOCK,-1,,"{
}",23,,19,2,,void
69403,BLOCK,-1,,"{
  uint64_t filter_index = (block_offset / kFilterBase);
  assert(filter_index >= filter_offsets_.size());
  while (filter_index > filter_offsets_.size()) {
    GenerateFilter();
  }
}",60,,22,2,,void
69424,BLOCK,-1,,"{
    GenerateFilter();
  }",49,,25,2,,void
69430,BLOCK,-1,,"{
  Slice k = key;
  start_.push_back(keys_.size());
  keys_.append(k.data(), k.size());
}",51,,30,2,,void
69458,BLOCK,-1,,"{
  if (!start_.empty()) {
    GenerateFilter();
  }

  // Append array of per-filter offsets
  const uint32_t array_offset = result_.size();
  for (size_t i = 0; i < filter_offsets_.size(); i++) {
    PutFixed32(&result_, filter_offsets_[i]);
  }

  PutFixed32(&result_, array_offset);
  result_.push_back(kFilterBaseLg);  // Save encoding parameter in result
  return Slice(result_);
}",36,,36,1,,void
69465,BLOCK,-1,,"{
    GenerateFilter();
  }",24,,37,2,,void
69475,BLOCK,-1,,<empty>,3,,43,1,,void
69488,BLOCK,4,,"{
    PutFixed32(&result_, filter_offsets_[i]);
  }",55,,43,4,,void
69510,BLOCK,-1,,"{
  const size_t num_keys = start_.size();
  if (num_keys == 0) {
    // Fast path if there are no keys for this filter
    filter_offsets_.push_back(result_.size());
    return;
  }

  // Make list of keys from flattened key structure
  start_.push_back(keys_.size());  // Simplify length computation
  tmp_keys_.resize(num_keys);
  for (size_t i = 0; i < num_keys; i++) {
    const char* base = keys_.data() + start_[i];
    size_t length = start_[i+1] - start_[i];
    tmp_keys_[i] = Slice(base, length);
  }

  // Generate filter for current set of keys and append to result_.
  filter_offsets_.push_back(result_.size());
  policy_->CreateFilter(&tmp_keys_[0], static_cast<int>(num_keys), &result_);

  tmp_keys_.clear();
  keys_.clear();
  start_.clear();
}",43,,52,1,,void
69522,BLOCK,-1,,"{
    // Fast path if there are no keys for this filter
    filter_offsets_.push_back(result_.size());
    return;
  }",22,,54,2,,void
69546,BLOCK,-1,,<empty>,3,,63,1,,void
69556,BLOCK,4,,"{
    const char* base = keys_.data() + start_[i];
    size_t length = start_[i+1] - start_[i];
    tmp_keys_[i] = Slice(base, length);
  }",41,,63,4,,void
69625,BLOCK,-1,,"{
  size_t n = contents.size();
  if (n < 5) return;  // 1 byte for base_lg_ and 4 for start of offset array
  base_lg_ = contents[n-1];
  uint32_t last_word = DecodeFixed32(contents.data() + n - 5);
  if (last_word > n - 5) return;
  data_ = contents.data();
  offset_ = data_ + last_word;
  num_ = (n - 5 - last_word) / 4;
}",19,,84,3,,void
69637,BLOCK,-1,,<empty>,14,,86,2,,void
69664,BLOCK,-1,,<empty>,26,,89,2,,void
69691,BLOCK,-1,,"{
  uint64_t index = block_offset >> base_lg_;
  if (index < num_) {
    uint32_t start = DecodeFixed32(offset_ + index*4);
    uint32_t limit = DecodeFixed32(offset_ + index*4 + 4);
    if (start <= limit && limit <= static_cast<size_t>(offset_ - data_)) {
      Slice filter = Slice(data_ + start, limit - start);
      return policy_->KeyMayMatch(key, filter);
    } else if (start == limit) {
      // Empty filters do not match any keys
      return false;
    }
  }
  return true;  // Errors are treated as potential matches
}",78,,95,3,,void
69702,BLOCK,-1,,"{
    uint32_t start = DecodeFixed32(offset_ + index*4);
    uint32_t limit = DecodeFixed32(offset_ + index*4 + 4);
    if (start <= limit && limit <= static_cast<size_t>(offset_ - data_)) {
      Slice filter = Slice(data_ + start, limit - start);
      return policy_->KeyMayMatch(key, filter);
    } else if (start == limit) {
      // Empty filters do not match any keys
      return false;
    }
  }",21,,97,2,,void
69735,BLOCK,-1,,"{
      Slice filter = Slice(data_ + start, limit - start);
      return policy_->KeyMayMatch(key, filter);
    }",74,,100,2,,void
69754,BLOCK,-1,,<empty>,12,,103,1,,void
69759,BLOCK,-1,,"{
      // Empty filters do not match any keys
      return false;
    }",32,,103,2,,void
69782,BLOCK,-1,,<empty>,1,,1,1,,ANY
69788,BLOCK,-1,,<empty>,,,,2,,<empty>
69793,BLOCK,-1,,<empty>,,,,2,,<empty>
69798,BLOCK,-1,,<empty>,,,,2,,<empty>
69802,BLOCK,-1,,<empty>,,,,1,,<empty>
69806,BLOCK,-1,,<empty>,,,,1,,<empty>
69817,BLOCK,-1,,<empty>,,,,2,,<empty>
69822,BLOCK,-1,,<empty>,,,,2,,<empty>
69829,BLOCK,-1,,<empty>,,,,3,,<empty>
69835,BLOCK,-1,,<empty>,,,,3,,<empty>
69861,BLOCK,-1,,<empty>,1,,1,1,,ANY
69865,BLOCK,-1,,"{
    return ""TestHashFilter"";
  }",36,,19,1,,void
69874,BLOCK,-1,,"{
    for (int i = 0; i < n; i++) {
      uint32_t h = Hash(keys[i].data(), keys[i].size(), 1);
      PutFixed32(dst, h);
    }
  }",79,,23,4,,void
69876,BLOCK,-1,,<empty>,5,,24,1,,void
69886,BLOCK,4,,"{
      uint32_t h = Hash(keys[i].data(), keys[i].size(), 1);
      PutFixed32(dst, h);
    }",33,,24,4,,void
69912,BLOCK,-1,,"{
    uint32_t h = Hash(key.data(), key.size(), 1);
    for (size_t i = 0; i + 4 <= filter.size(); i += 4) {
      if (h == DecodeFixed32(filter.data() + i)) {
        return true;
      }
    }
    return false;
  }",73,,30,3,,void
69927,BLOCK,-1,,<empty>,5,,32,1,,void
69943,BLOCK,4,,"{
      if (h == DecodeFixed32(filter.data() + i)) {
        return true;
      }
    }",56,,32,4,,void
69954,BLOCK,-1,,"{
        return true;
      }",50,,33,2,,void
69965,BLOCK,-1,,<empty>,,,,1,,<empty>
69969,BLOCK,-1,,"TEST(FilterBlockTest, EmptyBuilder)",1,,46,1,,void
69993,BLOCK,-1,,"{
  FilterBlockBuilder builder(&policy_);
  Slice block = builder.Finish();
  ASSERT_EQ(""\\x00\\x00\\x00\\x00\\x0b"", EscapeString(block));
  FilterBlockReader reader(&policy_, block);
  ASSERT_TRUE(reader.KeyMayMatch(0, ""foo""));
  ASSERT_TRUE(reader.KeyMayMatch(100000, ""foo""));
}",37,,46,1,,void
70009,BLOCK,1,,<empty>,,,,4,,void
70030,BLOCK,1,,<empty>,,,,2,,void
70050,BLOCK,1,,<empty>,,,,2,,void
70073,BLOCK,-1,,<empty>,,,,1,,<empty>
70077,BLOCK,-1,,"TEST(FilterBlockTest, SingleChunk)",1,,55,1,,void
70101,BLOCK,-1,,"{
  FilterBlockBuilder builder(&policy_);
  builder.StartBlock(100);
  builder.AddKey(""foo"");
  builder.AddKey(""bar"");
  builder.AddKey(""box"");
  builder.StartBlock(200);
  builder.AddKey(""box"");
  builder.StartBlock(300);
  builder.AddKey(""hello"");
  Slice block = builder.Finish();
  FilterBlockReader reader(&policy_, block);
  ASSERT_TRUE(reader.KeyMayMatch(100, ""foo""));
  ASSERT_TRUE(reader.KeyMayMatch(100, ""bar""));
  ASSERT_TRUE(reader.KeyMayMatch(100, ""box""));
  ASSERT_TRUE(reader.KeyMayMatch(100, ""hello""));
  ASSERT_TRUE(reader.KeyMayMatch(100, ""foo""));
  ASSERT_TRUE(! reader.KeyMayMatch(100, ""missing""));
  ASSERT_TRUE(! reader.KeyMayMatch(100, ""other""));
}",36,,55,1,,void
70159,BLOCK,1,,<empty>,,,,2,,void
70179,BLOCK,1,,<empty>,,,,2,,void
70199,BLOCK,1,,<empty>,,,,2,,void
70219,BLOCK,1,,<empty>,,,,2,,void
70239,BLOCK,1,,<empty>,,,,2,,void
70259,BLOCK,1,,<empty>,,,,2,,void
70280,BLOCK,1,,<empty>,,,,2,,void
70304,BLOCK,-1,,<empty>,,,,1,,<empty>
70308,BLOCK,-1,,"TEST(FilterBlockTest, MultiChunk)",1,,76,1,,void
70332,BLOCK,-1,,"{
  FilterBlockBuilder builder(&policy_);

  // First filter
  builder.StartBlock(0);
  builder.AddKey(""foo"");
  builder.StartBlock(2000);
  builder.AddKey(""bar"");

  // Second filter
  builder.StartBlock(3100);
  builder.AddKey(""box"");

  // Third filter is empty

  // Last filter
  builder.StartBlock(9000);
  builder.AddKey(""box"");
  builder.AddKey(""hello"");

  Slice block = builder.Finish();
  FilterBlockReader reader(&policy_, block);

  // Check first filter
  ASSERT_TRUE(reader.KeyMayMatch(0, ""foo""));
  ASSERT_TRUE(reader.KeyMayMatch(2000, ""bar""));
  ASSERT_TRUE(! reader.KeyMayMatch(0, ""box""));
  ASSERT_TRUE(! reader.KeyMayMatch(0, ""hello""));

  // Check second filter
  ASSERT_TRUE(reader.KeyMayMatch(3100, ""box""));
  ASSERT_TRUE(! reader.KeyMayMatch(3100, ""foo""));
  ASSERT_TRUE(! reader.KeyMayMatch(3100, ""bar""));
  ASSERT_TRUE(! reader.KeyMayMatch(3100, ""hello""));

  // Check third filter (empty)
  ASSERT_TRUE(! reader.KeyMayMatch(4100, ""foo""));
  ASSERT_TRUE(! reader.KeyMayMa...",35,,76,1,,void
70395,BLOCK,1,,<empty>,,,,2,,void
70415,BLOCK,1,,<empty>,,,,2,,void
70435,BLOCK,1,,<empty>,,,,2,,void
70456,BLOCK,1,,<empty>,,,,2,,void
70477,BLOCK,1,,<empty>,,,,2,,void
70497,BLOCK,1,,<empty>,,,,2,,void
70518,BLOCK,1,,<empty>,,,,2,,void
70539,BLOCK,1,,<empty>,,,,2,,void
70560,BLOCK,1,,<empty>,,,,2,,void
70581,BLOCK,1,,<empty>,,,,2,,void
70602,BLOCK,1,,<empty>,,,,2,,void
70623,BLOCK,1,,<empty>,,,,2,,void
70644,BLOCK,1,,<empty>,,,,2,,void
70664,BLOCK,1,,<empty>,,,,2,,void
70684,BLOCK,1,,<empty>,,,,2,,void
70705,BLOCK,1,,<empty>,,,,2,,void
70730,BLOCK,-1,,"{
  return leveldb::test::RunAllTests();
}",33,,126,3,,void
70756,BLOCK,-1,,<empty>,1,,1,1,,ANY
70760,BLOCK,-1,,"{
  // Sanity check that all fields have been set
  assert(offset_ != ~static_cast<uint64_t>(0));
  assert(size_ != ~static_cast<uint64_t>(0));
  PutVarint64(dst, offset_);
  PutVarint64(dst, size_);
}",52,,15,2,,void
70785,BLOCK,-1,,"{
  if (GetVarint64(input, &offset_) &&
      GetVarint64(input, &size_)) {
    return Status::OK();
  } else {
    return Status::Corruption(""bad block handle"");
  }
}",46,,23,2,,void
70796,BLOCK,-1,,"{
    return Status::OK();
  }",35,,25,2,,void
70803,BLOCK,-1,,"{
    return Status::Corruption(""bad block handle"");
  }",10,,27,1,,void
70814,BLOCK,-1,,"{
  const size_t original_size = dst->size();
  metaindex_handle_.EncodeTo(dst);
  index_handle_.EncodeTo(dst);
  dst->resize(2 * BlockHandle::kMaxEncodedLength);  // Padding
  PutFixed32(dst, static_cast<uint32_t>(kTableMagicNumber & 0xffffffffu));
  PutFixed32(dst, static_cast<uint32_t>(kTableMagicNumber >> 32));
  assert(dst->size() == original_size + kEncodedLength);
  (void)original_size;  // Disable unused variable warning.
}",47,,32,2,,void
70871,BLOCK,-1,,"{
  const char* magic_ptr = input->data() + kEncodedLength - 8;
  const uint32_t magic_lo = DecodeFixed32(magic_ptr);
  const uint32_t magic_hi = DecodeFixed32(magic_ptr + 4);
  const uint64_t magic = ((static_cast<uint64_t>(magic_hi) << 32) |
                          (static_cast<uint64_t>(magic_lo)));
  if (magic != kTableMagicNumber) {
    return Status::Corruption(""not an sstable (bad magic number)"");
  }

  Status result = metaindex_handle_.DecodeFrom(input);
  if (result.ok()) {
    result = index_handle_.DecodeFrom(input);
  }
  if (result.ok()) {
    // We skip over any leftover data (just padding for now) in ""input""
    const char* end = magic_ptr + 8;
    *input = Slice(end, input->data() + input->size() - end);
  }
  return result;
}",41,,43,2,,void
70911,BLOCK,-1,,"{
    return Status::Corruption(""not an sstable (bad magic number)"");
  }",35,,49,2,,void
70931,BLOCK,-1,,"{
    result = index_handle_.DecodeFrom(input);
  }",20,,54,2,,void
70944,BLOCK,-1,,"{
    // We skip over any leftover data (just padding for now) in ""input""
    const char* end = magic_ptr + 8;
    *input = Slice(end, input->data() + input->size() - end);
  }",20,,57,2,,void
70976,BLOCK,-1,,"{
  result->data = Slice();
  result->cachable = false;
  result->heap_allocated = false;

  // Read the block contents as well as the type/crc footer.
  // See table_builder.cc for the code that built this structure.
  size_t n = static_cast<size_t>(handle.size());
  char* buf = new char[n + kBlockTrailerSize];
  Slice contents;
  Status s = file->Read(handle.offset(), n + kBlockTrailerSize, &contents, buf);
  if (!s.ok()) {
    delete[] buf;
    return s;
  }
  if (contents.size() != n + kBlockTrailerSize) {
    delete[] buf;
    return Status::Corruption(""truncated block read"");
  }

  // Check the crc of the type and the block contents
  const char* data = contents.data();    // Pointer to where Read put the data
  if (options.verify_checksums) {
    const uint32_t crc = crc32c::Unmask(DecodeFixed32(data + n + 1));
    const uint32_t actual = crc32c::Value(data, n + 1);
    if (actual != crc) {
      delete[] buf;
      s = Status::Corruption(""block checksum mismatch"");
      re...",41,,68,5,,void
71030,BLOCK,-1,,"{
    delete[] buf;
    return s;
  }",16,,79,2,,void
71044,BLOCK,-1,,"{
    delete[] buf;
    return Status::Corruption(""truncated block read"");
  }",49,,83,2,,void
71064,BLOCK,-1,,"{
    const uint32_t crc = crc32c::Unmask(DecodeFixed32(data + n + 1));
    const uint32_t actual = crc32c::Value(data, n + 1);
    if (actual != crc) {
      delete[] buf;
      s = Status::Corruption(""block checksum mismatch"");
      return s;
    }
  }",33,,90,2,,void
71093,BLOCK,-1,,"{
      delete[] buf;
      s = Status::Corruption(""block checksum mismatch"");
      return s;
    }",24,,93,2,,void
71109,BLOCK,-1,,"{
    case kNoCompression:
      if (data != buf) {
        // File implementation gave us pointer to some other data.
        // Use it directly under the assumption that it will be live
        // while the file is open.
        delete[] buf;
        result->data = Slice(data, n);
        result->heap_allocated = false;
        result->cachable = false;  // Do not double-cache
      } else {
        result->data = Slice(buf, n);
        result->heap_allocated = true;
        result->cachable = true;
      }

      // Ok
      break;
    case kSnappyCompression: {
      size_t ulength = 0;
      if (!port::Snappy_GetUncompressedLength(data, n, &ulength)) {
        delete[] buf;
        return Status::Corruption(""corrupted compressed block contents"");
      }
      char* ubuf = new char[ulength];
      if (!port::Snappy_Uncompress(data, n, ubuf)) {
        delete[] buf;
        delete[] ubuf;
        return Status::Corruption(""corrupted compressed block contents"");
      }
      del...",20,,100,2,,void
71116,BLOCK,-1,,"{
        // File implementation gave us pointer to some other data.
        // Use it directly under the assumption that it will be live
        // while the file is open.
        delete[] buf;
        result->data = Slice(data, n);
        result->heap_allocated = false;
        result->cachable = false;  // Do not double-cache
      }",24,,102,2,,void
71137,BLOCK,-1,,"{
        result->data = Slice(buf, n);
        result->heap_allocated = true;
        result->cachable = true;
      }",14,,110,1,,void
71158,BLOCK,7,,"{
      size_t ulength = 0;
      if (!port::Snappy_GetUncompressedLength(data, n, &ulength)) {
        delete[] buf;
        return Status::Corruption(""corrupted compressed block contents"");
      }
      char* ubuf = new char[ulength];
      if (!port::Snappy_Uncompress(data, n, ubuf)) {
        delete[] buf;
        delete[] ubuf;
        return Status::Corruption(""corrupted compressed block contents"");
      }
      delete[] buf;
      result->data = Slice(ubuf, ulength);
      result->heap_allocated = true;
      result->cachable = true;
      break;
    }",30,,118,7,,void
71173,BLOCK,-1,,"{
        delete[] buf;
        return Status::Corruption(""corrupted compressed block contents"");
      }",67,,120,2,,void
71196,BLOCK,-1,,"{
        delete[] buf;
        delete[] ubuf;
        return Status::Corruption(""corrupted compressed block contents"");
      }",52,,125,2,,void
71257,BLOCK,-1,,<empty>,1,,1,1,,ANY
71264,BLOCK,-1,,<empty>,,,,1,,<empty>
71268,BLOCK,-1,,{ return offset_; },27,,27,1,,void
71275,BLOCK,-1,,{ offset_ = offset; },36,,28,2,,void
71282,BLOCK,-1,,{ return size_; },25,,31,1,,void
71289,BLOCK,-1,,{ size_ = size; },32,,32,2,,void
71297,BLOCK,-1,,<empty>,,,,2,,<empty>
71302,BLOCK,-1,,<empty>,,,,2,,<empty>
71308,BLOCK,-1,,<empty>,,,,1,,<empty>
71320,BLOCK,-1,,{ },12,,49,1,,void
71324,BLOCK,-1,,{ return metaindex_handle_; },47,,52,1,,void
71331,BLOCK,-1,,{ metaindex_handle_ = h; },51,,53,2,,void
71338,BLOCK,-1,,"{
    return index_handle_;
  }",43,,56,1,,void
71345,BLOCK,-1,,"{
    index_handle_ = h;
  }",47,,59,2,,void
71353,BLOCK,-1,,<empty>,,,,2,,<empty>
71358,BLOCK,-1,,<empty>,,,,2,,<empty>
71364,BLOCK,-1,,<empty>,,,,1,,<empty>
71395,BLOCK,-1,,<empty>,,,,5,,<empty>
71399,BLOCK,-1,,"{
}",40,,103,1,,void
71408,BLOCK,-1,,<empty>,1,,1,1,,ANY
71411,BLOCK,-1,,"{
  cleanup_.function = NULL;
  cleanup_.next = NULL;
}",22,,9,1,,void
71425,BLOCK,-1,,"{
  if (cleanup_.function != NULL) {
    (*cleanup_.function)(cleanup_.arg1, cleanup_.arg2);
    for (Cleanup* c = cleanup_.next; c != NULL; ) {
      (*c->function)(c->arg1, c->arg2);
      Cleanup* next = c->next;
      delete c;
      c = next;
    }
  }
}",23,,14,1,,void
71432,BLOCK,-1,,"{
    (*cleanup_.function)(cleanup_.arg1, cleanup_.arg2);
    for (Cleanup* c = cleanup_.next; c != NULL; ) {
      (*c->function)(c->arg1, c->arg2);
      Cleanup* next = c->next;
      delete c;
      c = next;
    }
  }",34,,15,2,,void
71445,BLOCK,-1,,<empty>,5,,17,1,,void
71455,BLOCK,4,,"{
      (*c->function)(c->arg1, c->arg2);
      Cleanup* next = c->next;
      delete c;
      c = next;
    }",51,,17,4,,void
71484,BLOCK,-1,,"{
  assert(func != NULL);
  Cleanup* c;
  if (cleanup_.function == NULL) {
    c = &cleanup_;
  } else {
    c = new Cleanup;
    c->next = cleanup_.next;
    cleanup_.next = c;
  }
  c->function = func;
  c->arg1 = arg1;
  c->arg2 = arg2;
}",78,,26,4,,void
71496,BLOCK,-1,,"{
    c = &cleanup_;
  }",34,,29,2,,void
71502,BLOCK,-1,,"{
    c = new Cleanup;
    c->next = cleanup_.next;
    cleanup_.next = c;
  }",10,,31,1,,void
71540,BLOCK,-1,,{ },47,,44,2,,void
71544,BLOCK,-1,,{ return false; },30,,45,1,,void
71551,BLOCK,-1,,{ },42,,46,2,,void
71555,BLOCK,-1,,{ },30,,47,1,,void
71559,BLOCK,-1,,{ },29,,48,1,,void
71563,BLOCK,-1,,{ assert(false); },23,,49,1,,void
71569,BLOCK,-1,,{ assert(false); },23,,50,1,,void
71575,BLOCK,-1,,{ assert(false); return Slice(); },21,,51,1,,void
71583,BLOCK,-1,,{ assert(false); return Slice(); },23,,52,1,,void
71591,BLOCK,-1,,{ return status_; },33,,53,1,,void
71598,BLOCK,-1,,"{
  return new EmptyIterator(Status::OK());
}",30,,59,1,,void
71610,BLOCK,-1,,"{
  return new EmptyIterator(status);
}",50,,63,2,,void
71625,BLOCK,-1,,<empty>,1,,1,1,,ANY
71629,BLOCK,-1,,{ },49,,19,1,,void
71634,BLOCK,-1,,"{
    Set(iter);
  }",57,,20,2,,void
71640,BLOCK,-1,,{ delete iter_; },22,,23,1,,void
71646,BLOCK,-1,,{ return iter_; },26,,24,1,,void
71653,BLOCK,-1,,"{
    delete iter_;
    iter_ = iter;
    if (iter_ == NULL) {
      valid_ = false;
    } else {
      Update();
    }
  }",28,,28,2,,void
71663,BLOCK,-1,,"{
      valid_ = false;
    }",24,,31,2,,void
71668,BLOCK,-1,,"{
      Update();
    }",12,,33,1,,void
71673,BLOCK,-1,,{ return valid_; },29,,40,1,,void
71679,BLOCK,-1,,{ assert(Valid()); return key_; },29,,41,1,,void
71687,BLOCK,-1,,{ assert(Valid()); return iter_->value(); },29,,42,1,,void
71698,BLOCK,-1,,{ assert(iter_); return iter_->status(); },29,,44,1,,void
71709,BLOCK,-1,,{ assert(iter_); iter_->Next();        Update(); },29,,45,1,,void
71720,BLOCK,-1,,{ assert(iter_); iter_->Prev();        Update(); },29,,46,1,,void
71732,BLOCK,-1,,{ assert(iter_); iter_->Seek(k);       Update(); },29,,47,2,,void
71744,BLOCK,-1,,{ assert(iter_); iter_->SeekToFirst(); Update(); },29,,48,1,,void
71755,BLOCK,-1,,{ assert(iter_); iter_->SeekToLast();  Update(); },29,,49,1,,void
71766,BLOCK,-1,,"{
    valid_ = iter_->Valid();
    if (valid_) {
      key_ = iter_->key();
    }
  }",17,,52,1,,void
71775,BLOCK,-1,,"{
      key_ = iter_->key();
    }",17,,54,2,,void
71799,BLOCK,-1,,<empty>,1,,1,1,,ANY
71807,BLOCK,-1,,"{
    for (int i = 0; i < n; i++) {
      children_[i].Set(children[i]);
    }
  }",30,,21,4,,void
71809,BLOCK,-1,,<empty>,5,,22,1,,void
71819,BLOCK,4,,"{
      children_[i].Set(children[i]);
    }",33,,22,4,,void
71832,BLOCK,-1,,"{
    delete[] children_;
  }",30,,27,1,,void
71838,BLOCK,-1,,"{
    return (current_ != NULL);
  }",30,,31,1,,void
71846,BLOCK,-1,,"{
    for (int i = 0; i < n_; i++) {
      children_[i].SeekToFirst();
    }
    FindSmallest();
    direction_ = kForward;
  }",30,,35,1,,void
71848,BLOCK,-1,,<empty>,5,,36,1,,void
71858,BLOCK,4,,"{
      children_[i].SeekToFirst();
    }",34,,36,4,,void
71872,BLOCK,-1,,"{
    for (int i = 0; i < n_; i++) {
      children_[i].SeekToLast();
    }
    FindLargest();
    direction_ = kReverse;
  }",29,,43,1,,void
71874,BLOCK,-1,,<empty>,5,,44,1,,void
71884,BLOCK,4,,"{
      children_[i].SeekToLast();
    }",34,,44,4,,void
71899,BLOCK,-1,,"{
    for (int i = 0; i < n_; i++) {
      children_[i].Seek(target);
    }
    FindSmallest();
    direction_ = kForward;
  }",42,,51,2,,void
71901,BLOCK,-1,,<empty>,5,,52,1,,void
71911,BLOCK,4,,"{
      children_[i].Seek(target);
    }",34,,52,4,,void
71926,BLOCK,-1,,"{
    assert(Valid());

    // Ensure that all children are positioned after key().
    // If we are moving in the forward direction, it is already
    // true for all of the non-current_ children since current_ is
    // the smallest child and key() == current_->key().  Otherwise,
    // we explicitly position the non-current_ children.
    if (direction_ != kForward) {
      for (int i = 0; i < n_; i++) {
        IteratorWrapper* child = &children_[i];
        if (child != current_) {
          child->Seek(key());
          if (child->Valid() &&
              comparator_->Compare(key(), child->key()) == 0) {
            child->Next();
          }
        }
      }
      direction_ = kForward;
    }

    current_->Next();
    FindSmallest();
  }",23,,59,1,,void
71933,BLOCK,-1,,"{
      for (int i = 0; i < n_; i++) {
        IteratorWrapper* child = &children_[i];
        if (child != current_) {
          child->Seek(key());
          if (child->Valid() &&
              comparator_->Compare(key(), child->key()) == 0) {
            child->Next();
          }
        }
      }
      direction_ = kForward;
    }",33,,67,2,,void
71935,BLOCK,-1,,<empty>,7,,68,1,,void
71945,BLOCK,4,,"{
        IteratorWrapper* child = &children_[i];
        if (child != current_) {
          child->Seek(key());
          if (child->Valid() &&
              comparator_->Compare(key(), child->key()) == 0) {
            child->Next();
          }
        }
      }",36,,68,4,,void
71957,BLOCK,-1,,"{
          child->Seek(key());
          if (child->Valid() &&
              comparator_->Compare(key(), child->key()) == 0) {
            child->Next();
          }
        }",32,,70,2,,void
71980,BLOCK,-1,,"{
            child->Next();
          }",63,,73,2,,void
71996,BLOCK,-1,,"{
    assert(Valid());

    // Ensure that all children are positioned before key().
    // If we are moving in the reverse direction, it is already
    // true for all of the non-current_ children since current_ is
    // the largest child and key() == current_->key().  Otherwise,
    // we explicitly position the non-current_ children.
    if (direction_ != kReverse) {
      for (int i = 0; i < n_; i++) {
        IteratorWrapper* child = &children_[i];
        if (child != current_) {
          child->Seek(key());
          if (child->Valid()) {
            // Child is at first entry >= key().  Step back one to be < key()
            child->Prev();
          } else {
            // Child has no entries >= key().  Position at last entry.
            child->SeekToLast();
          }
        }
      }
      direction_ = kReverse;
    }

    current_->Prev();
    FindLargest();
  }",23,,85,1,,void
72003,BLOCK,-1,,"{
      for (int i = 0; i < n_; i++) {
        IteratorWrapper* child = &children_[i];
        if (child != current_) {
          child->Seek(key());
          if (child->Valid()) {
            // Child is at first entry >= key().  Step back one to be < key()
            child->Prev();
          } else {
            // Child has no entries >= key().  Position at last entry.
            child->SeekToLast();
          }
        }
      }
      direction_ = kReverse;
    }",33,,93,2,,void
72005,BLOCK,-1,,<empty>,7,,94,1,,void
72015,BLOCK,4,,"{
        IteratorWrapper* child = &children_[i];
        if (child != current_) {
          child->Seek(key());
          if (child->Valid()) {
            // Child is at first entry >= key().  Step back one to be < key()
            child->Prev();
          } else {
            // Child has no entries >= key().  Position at last entry.
            child->SeekToLast();
          }
        }
      }",36,,94,4,,void
72027,BLOCK,-1,,"{
          child->Seek(key());
          if (child->Valid()) {
            // Child is at first entry >= key().  Step back one to be < key()
            child->Prev();
          } else {
            // Child has no entries >= key().  Position at last entry.
            child->SeekToLast();
          }
        }",32,,96,2,,void
72038,BLOCK,-1,,"{
            // Child is at first entry >= key().  Step back one to be < key()
            child->Prev();
          }",31,,98,2,,void
72044,BLOCK,-1,,"{
            // Child has no entries >= key().  Position at last entry.
            child->SeekToLast();
          }",18,,101,1,,void
72060,BLOCK,-1,,"{
    assert(Valid());
    return current_->key();
  }",29,,114,1,,void
72071,BLOCK,-1,,"{
    assert(Valid());
    return current_->value();
  }",31,,119,1,,void
72082,BLOCK,-1,,"{
    Status status;
    for (int i = 0; i < n_; i++) {
      status = children_[i].status();
      if (!status.ok()) {
        break;
      }
    }
    return status;
  }",33,,124,1,,void
72085,BLOCK,-1,,<empty>,5,,126,1,,void
72095,BLOCK,4,,"{
      status = children_[i].status();
      if (!status.ok()) {
        break;
      }
    }",34,,126,4,,void
72110,BLOCK,-1,,"{
        break;
      }",25,,128,2,,void
72117,BLOCK,-1,,<empty>,,,,1,,<empty>
72121,BLOCK,-1,,<empty>,,,,1,,<empty>
72133,BLOCK,-1,,"{
  IteratorWrapper* smallest = NULL;
  for (int i = 0; i < n_; i++) {
    IteratorWrapper* child = &children_[i];
    if (child->Valid()) {
      if (smallest == NULL) {
        smallest = child;
      } else if (comparator_->Compare(child->key(), smallest->key()) < 0) {
        smallest = child;
      }
    }
  }
  current_ = smallest;
}",38,,155,1,,void
72139,BLOCK,-1,,<empty>,3,,157,1,,void
72149,BLOCK,4,,"{
    IteratorWrapper* child = &children_[i];
    if (child->Valid()) {
      if (smallest == NULL) {
        smallest = child;
      } else if (comparator_->Compare(child->key(), smallest->key()) < 0) {
        smallest = child;
      }
    }
  }",32,,157,4,,void
72162,BLOCK,-1,,"{
      if (smallest == NULL) {
        smallest = child;
      } else if (comparator_->Compare(child->key(), smallest->key()) < 0) {
        smallest = child;
      }
    }",25,,159,2,,void
72167,BLOCK,-1,,"{
        smallest = child;
      }",29,,160,2,,void
72172,BLOCK,-1,,<empty>,14,,162,1,,void
72188,BLOCK,-1,,"{
        smallest = child;
      }",75,,162,2,,void
72198,BLOCK,-1,,"{
  IteratorWrapper* largest = NULL;
  for (int i = n_-1; i >= 0; i--) {
    IteratorWrapper* child = &children_[i];
    if (child->Valid()) {
      if (largest == NULL) {
        largest = child;
      } else if (comparator_->Compare(child->key(), largest->key()) > 0) {
        largest = child;
      }
    }
  }
  current_ = largest;
}",37,,170,1,,void
72204,BLOCK,-1,,<empty>,3,,172,1,,void
72216,BLOCK,4,,"{
    IteratorWrapper* child = &children_[i];
    if (child->Valid()) {
      if (largest == NULL) {
        largest = child;
      } else if (comparator_->Compare(child->key(), largest->key()) > 0) {
        largest = child;
      }
    }
  }",35,,172,4,,void
72229,BLOCK,-1,,"{
      if (largest == NULL) {
        largest = child;
      } else if (comparator_->Compare(child->key(), largest->key()) > 0) {
        largest = child;
      }
    }",25,,174,2,,void
72234,BLOCK,-1,,"{
        largest = child;
      }",28,,175,2,,void
72239,BLOCK,-1,,<empty>,14,,177,1,,void
72255,BLOCK,-1,,"{
        largest = child;
      }",74,,177,2,,void
72268,BLOCK,-1,,"{
  assert(n >= 0);
  if (n == 0) {
    return NewEmptyIterator();
  } else if (n == 1) {
    return list[0];
  } else {
    return new MergingIterator(cmp, list, n);
  }
}",77,,186,4,,void
72277,BLOCK,-1,,"{
    return NewEmptyIterator();
  }",15,,188,2,,void
72281,BLOCK,-1,,<empty>,10,,190,1,,void
72286,BLOCK,-1,,"{
    return list[0];
  }",22,,190,2,,void
72292,BLOCK,-1,,"{
    return new MergingIterator(cmp, list, n);
  }",10,,192,1,,void
72305,BLOCK,-1,,<empty>,1,,1,1,,ANY
72313,BLOCK,-1,,<empty>,,,,4,,<empty>
72342,BLOCK,-1,,<empty>,1,,1,1,,ANY
72346,BLOCK,-1,,"{
    delete filter;
    delete [] filter_data;
    delete index_block;
  }",10,,21,1,,void
72368,BLOCK,-1,,"{
  *table = NULL;
  if (size < Footer::kEncodedLength) {
    return Status::Corruption(""file is too short to be an sstable"");
  }

  char footer_space[Footer::kEncodedLength];
  Slice footer_input;
  Status s = file->Read(size - Footer::kEncodedLength, Footer::kEncodedLength,
                        &footer_input, footer_space);
  if (!s.ok()) return s;

  Footer footer;
  s = footer.DecodeFrom(&footer_input);
  if (!s.ok()) return s;

  // Read the index block
  BlockContents contents;
  Block* index_block = NULL;
  if (s.ok()) {
    ReadOptions opt;
    if (options.paranoid_checks) {
      opt.verify_checksums = true;
    }
    s = ReadBlock(file, opt, footer.index_handle(), &contents);
    if (s.ok()) {
      index_block = new Block(contents);
    }
  }

  if (s.ok()) {
    // We've successfully read the footer and the index block: we're
    // ready to serve requests.
    Rep* rep = new Table::Rep;
    rep->options = options;
    rep->file = file;
    rep->metaindex_handle = fo...",35,,41,5,,void
72379,BLOCK,-1,,"{
    return Status::Corruption(""file is too short to be an sstable"");
  }",38,,43,2,,void
72412,BLOCK,-1,,<empty>,16,,51,2,,void
72430,BLOCK,-1,,<empty>,16,,55,2,,void
72443,BLOCK,-1,,"{
    ReadOptions opt;
    if (options.paranoid_checks) {
      opt.verify_checksums = true;
    }
    s = ReadBlock(file, opt, footer.index_handle(), &contents);
    if (s.ok()) {
      index_block = new Block(contents);
    }
  }",15,,60,2,,void
72449,BLOCK,-1,,"{
      opt.verify_checksums = true;
    }",34,,62,2,,void
72471,BLOCK,-1,,"{
      index_block = new Block(contents);
    }",17,,66,2,,void
72482,BLOCK,-1,,"{
    // We've successfully read the footer and the index block: we're
    // ready to serve requests.
    Rep* rep = new Table::Rep;
    rep->options = options;
    rep->file = file;
    rep->metaindex_handle = footer.metaindex_handle();
    rep->index_block = index_block;
    rep->cache_id = (options.block_cache ? options.block_cache->NewId() : 0);
    rep->filter_data = NULL;
    rep->filter = NULL;
    *table = new Table(rep);
    (*table)->ReadMeta(footer);
  }",15,,71,2,,void
72549,BLOCK,-1,,"{
    delete index_block;
  }",10,,84,1,,void
72558,BLOCK,-1,,"{
  if (rep_->options.filter_policy == NULL) {
    return;  // Do not need any metadata
  }

  // TODO(sanjay): Skip this if footer.metaindex_handle() size indicates
  // it is an empty block.
  ReadOptions opt;
  if (rep_->options.paranoid_checks) {
    opt.verify_checksums = true;
  }
  BlockContents contents;
  if (!ReadBlock(rep_->file, opt, footer.metaindex_handle(), &contents).ok()) {
    // Do not propagate errors since meta info is not needed for operation
    return;
  }
  Block* meta = new Block(contents);

  Iterator* iter = meta->NewIterator(BytewiseComparator());
  std::string key = ""filter."";
  key.append(rep_->options.filter_policy->Name());
  iter->Seek(key);
  if (iter->Valid() && iter->key() == Slice(key)) {
    ReadFilter(iter->value());
  }
  delete iter;
  delete meta;
}",44,,91,2,,void
72567,BLOCK,-1,,"{
    return;  // Do not need any metadata
  }",44,,92,2,,void
72576,BLOCK,-1,,"{
    opt.verify_checksums = true;
  }",38,,99,2,,void
72599,BLOCK,-1,,"{
    // Do not propagate errors since meta info is not needed for operation
    return;
  }",79,,103,2,,void
72649,BLOCK,-1,,"{
    ReadFilter(iter->value());
  }",51,,113,2,,void
72663,BLOCK,-1,,"{
  Slice v = filter_handle_value;
  BlockHandle filter_handle;
  if (!filter_handle.DecodeFrom(&v).ok()) {
    return;
  }

  // We might want to unify with ReadBlock() if we start
  // requiring checksum verification in Table::Open.
  ReadOptions opt;
  if (rep_->options.paranoid_checks) {
    opt.verify_checksums = true;
  }
  BlockContents block;
  if (!ReadBlock(rep_->file, opt, filter_handle, &block).ok()) {
    return;
  }
  if (block.heap_allocated) {
    rep_->filter_data = block.data.data();     // Will need to delete later
  }
  rep_->filter = new FilterBlockReader(rep_->options.filter_policy, block.data);
}",58,,120,2,,void
72680,BLOCK,-1,,"{
    return;
  }",43,,123,2,,void
72689,BLOCK,-1,,"{
    opt.verify_checksums = true;
  }",38,,130,2,,void
72709,BLOCK,-1,,"{
    return;
  }",64,,134,2,,void
72715,BLOCK,-1,,"{
    rep_->filter_data = block.data.data();     // Will need to delete later
  }",29,,137,2,,void
72743,BLOCK,-1,,"{
  delete rep_;
}",17,,143,1,,void
72751,BLOCK,-1,,"{
  delete reinterpret_cast<Block*>(arg);
}",51,,147,3,,void
72761,BLOCK,-1,,"{
  Block* block = reinterpret_cast<Block*>(value);
  delete block;
}",62,,151,3,,void
72775,BLOCK,-1,,"{
  Cache* cache = reinterpret_cast<Cache*>(arg);
  Cache::Handle* handle = reinterpret_cast<Cache::Handle*>(h);
  cache->Release(handle);
}",46,,156,3,,void
72799,BLOCK,-1,,"{
  Table* table = reinterpret_cast<Table*>(arg);
  Cache* block_cache = table->rep_->options.block_cache;
  Block* block = NULL;
  Cache::Handle* cache_handle = NULL;

  BlockHandle handle;
  Slice input = index_value;
  Status s = handle.DecodeFrom(&input);
  // We intentionally allow extra stuff in index_value so that we
  // can add more features in the future.

  if (s.ok()) {
    BlockContents contents;
    if (block_cache != NULL) {
      char cache_key_buffer[16];
      EncodeFixed64(cache_key_buffer, table->rep_->cache_id);
      EncodeFixed64(cache_key_buffer+8, handle.offset());
      Slice key(cache_key_buffer, sizeof(cache_key_buffer));
      cache_handle = block_cache->Lookup(key);
      if (cache_handle != NULL) {
        block = reinterpret_cast<Block*>(block_cache->Value(cache_handle));
      } else {
        s = ReadBlock(table->rep_->file, options, handle, &contents);
        if (s.ok()) {
          block = new Block(contents);
          if (contents.cachable && o...",56,,166,4,,void
72843,BLOCK,-1,,"{
    BlockContents contents;
    if (block_cache != NULL) {
      char cache_key_buffer[16];
      EncodeFixed64(cache_key_buffer, table->rep_->cache_id);
      EncodeFixed64(cache_key_buffer+8, handle.offset());
      Slice key(cache_key_buffer, sizeof(cache_key_buffer));
      cache_handle = block_cache->Lookup(key);
      if (cache_handle != NULL) {
        block = reinterpret_cast<Block*>(block_cache->Value(cache_handle));
      } else {
        s = ReadBlock(table->rep_->file, options, handle, &contents);
        if (s.ok()) {
          block = new Block(contents);
          if (contents.cachable && options.fill_cache) {
            cache_handle = block_cache->Insert(
                key, block, block->size(), &DeleteCachedBlock);
          }
        }
      }
    } else {
      s = ReadBlock(table->rep_->file, options, handle, &contents);
      if (s.ok()) {
        block = new Block(contents);
      }
    }
  }",15,,178,2,,void
72849,BLOCK,-1,,"{
      char cache_key_buffer[16];
      EncodeFixed64(cache_key_buffer, table->rep_->cache_id);
      EncodeFixed64(cache_key_buffer+8, handle.offset());
      Slice key(cache_key_buffer, sizeof(cache_key_buffer));
      cache_handle = block_cache->Lookup(key);
      if (cache_handle != NULL) {
        block = reinterpret_cast<Block*>(block_cache->Value(cache_handle));
      } else {
        s = ReadBlock(table->rep_->file, options, handle, &contents);
        if (s.ok()) {
          block = new Block(contents);
          if (contents.cachable && options.fill_cache) {
            cache_handle = block_cache->Insert(
                key, block, block->size(), &DeleteCachedBlock);
          }
        }
      }
    }",30,,180,2,,void
72882,BLOCK,-1,,"{
        block = reinterpret_cast<Block*>(block_cache->Value(cache_handle));
      }",33,,186,2,,void
72893,BLOCK,-1,,"{
        s = ReadBlock(table->rep_->file, options, handle, &contents);
        if (s.ok()) {
          block = new Block(contents);
          if (contents.cachable && options.fill_cache) {
            cache_handle = block_cache->Insert(
                key, block, block->size(), &DeleteCachedBlock);
          }
        }
      }",14,,188,1,,void
72911,BLOCK,-1,,"{
          block = new Block(contents);
          if (contents.cachable && options.fill_cache) {
            cache_handle = block_cache->Insert(
                key, block, block->size(), &DeleteCachedBlock);
          }
        }",21,,190,2,,void
72925,BLOCK,-1,,"{
            cache_handle = block_cache->Insert(
                key, block, block->size(), &DeleteCachedBlock);
          }",56,,192,2,,void
72941,BLOCK,-1,,"{
      s = ReadBlock(table->rep_->file, options, handle, &contents);
      if (s.ok()) {
        block = new Block(contents);
      }
    }",12,,198,1,,void
72959,BLOCK,-1,,"{
        block = new Block(contents);
      }",19,,200,2,,void
72970,BLOCK,-1,,"{
    iter = block->NewIterator(table->rep_->options.comparator);
    if (cache_handle == NULL) {
      iter->RegisterCleanup(&DeleteBlock, block, NULL);
    } else {
      iter->RegisterCleanup(&ReleaseBlock, block_cache, cache_handle);
    }
  }",22,,207,2,,void
72988,BLOCK,-1,,"{
      iter->RegisterCleanup(&DeleteBlock, block, NULL);
    }",31,,209,2,,void
72998,BLOCK,-1,,"{
      iter->RegisterCleanup(&ReleaseBlock, block_cache, cache_handle);
    }",12,,211,1,,void
73008,BLOCK,-1,,"{
    iter = NewErrorIterator(s);
  }",10,,214,1,,void
73019,BLOCK,-1,,"{
  return NewTwoLevelIterator(
      rep_->index_block->NewIterator(rep_->options.comparator),
      &Table::BlockReader, const_cast<Table*>(this), options);
}",64,,220,2,,void
73048,BLOCK,-1,,"{
  Status s;
  Iterator* iiter = rep_->index_block->NewIterator(rep_->options.comparator);
  iiter->Seek(k);
  if (iiter->Valid()) {
    Slice handle_value = iiter->value();
    FilterBlockReader* filter = rep_->filter;
    BlockHandle handle;
    if (filter != NULL &&
        handle.DecodeFrom(&handle_value).ok() &&
        !filter->KeyMayMatch(handle.offset(), k)) {
      // Not found
    } else {
      Iterator* block_iter = BlockReader(this, options, iiter->value());
      block_iter->Seek(k);
      if (block_iter->Valid()) {
        (*saver)(arg, block_iter->key(), block_iter->value());
      }
      s = block_iter->status();
      delete block_iter;
    }
  }
  if (s.ok()) {
    s = iiter->status();
  }
  delete iiter;
  return s;
}",77,,228,5,,void
73074,BLOCK,-1,,"{
    Slice handle_value = iiter->value();
    FilterBlockReader* filter = rep_->filter;
    BlockHandle handle;
    if (filter != NULL &&
        handle.DecodeFrom(&handle_value).ok() &&
        !filter->KeyMayMatch(handle.offset(), k)) {
      // Not found
    } else {
      Iterator* block_iter = BlockReader(this, options, iiter->value());
      block_iter->Seek(k);
      if (block_iter->Valid()) {
        (*saver)(arg, block_iter->key(), block_iter->value());
      }
      s = block_iter->status();
      delete block_iter;
    }
  }",23,,232,2,,void
73114,BLOCK,-1,,"{
      // Not found
    }",51,,238,2,,void
73116,BLOCK,-1,,"{
      Iterator* block_iter = BlockReader(this, options, iiter->value());
      block_iter->Seek(k);
      if (block_iter->Valid()) {
        (*saver)(arg, block_iter->key(), block_iter->value());
      }
      s = block_iter->status();
      delete block_iter;
    }",12,,240,1,,void
73137,BLOCK,-1,,"{
        (*saver)(arg, block_iter->key(), block_iter->value());
      }",32,,243,2,,void
73163,BLOCK,-1,,"{
    s = iiter->status();
  }",15,,250,2,,void
73178,BLOCK,-1,,"{
  Iterator* index_iter =
      rep_->index_block->NewIterator(rep_->options.comparator);
  index_iter->Seek(key);
  uint64_t result;
  if (index_iter->Valid()) {
    BlockHandle handle;
    Slice input = index_iter->value();
    Status s = handle.DecodeFrom(&input);
    if (s.ok()) {
      result = handle.offset();
    } else {
      // Strange: we can't decode the block handle in the index block.
      // We'll just return the offset of the metaindex block, which is
      // close to the whole file size for this case.
      result = rep_->metaindex_handle.offset();
    }
  } else {
    // key is past the last key in the file.  Approximate the offset
    // by returning the offset of the metaindex block (which is
    // right near the end of the file).
    result = rep_->metaindex_handle.offset();
  }
  delete index_iter;
  return result;
}",61,,258,2,,void
73204,BLOCK,-1,,"{
    BlockHandle handle;
    Slice input = index_iter->value();
    Status s = handle.DecodeFrom(&input);
    if (s.ok()) {
      result = handle.offset();
    } else {
      // Strange: we can't decode the block handle in the index block.
      // We'll just return the offset of the metaindex block, which is
      // close to the whole file size for this case.
      result = rep_->metaindex_handle.offset();
    }
  }",28,,263,2,,void
73227,BLOCK,-1,,"{
      result = handle.offset();
    }",17,,267,2,,void
73235,BLOCK,-1,,"{
      // Strange: we can't decode the block handle in the index block.
      // We'll just return the offset of the metaindex block, which is
      // close to the whole file size for this case.
      result = rep_->metaindex_handle.offset();
    }",12,,269,1,,void
73245,BLOCK,-1,,"{
    // key is past the last key in the file.  Approximate the offset
    // by returning the offset of the metaindex block (which is
    // right near the end of the file).
    result = rep_->metaindex_handle.offset();
  }",10,,275,1,,void
73286,BLOCK,-1,,<empty>,1,,1,1,,ANY
73306,BLOCK,-1,,"{
    index_block_options.block_restart_interval = 1;
  }",36,,58,3,,void
73317,BLOCK,-1,,"{
  if (rep_->filter_block != NULL) {
    rep_->filter_block->StartBlock(0);
  }
}",36,,64,3,,void
73324,BLOCK,-1,,"{
    rep_->filter_block->StartBlock(0);
  }",35,,65,2,,void
73335,BLOCK,-1,,"{
  assert(rep_->closed);  // Catch errors where caller forgot to call Finish()
  delete rep_->filter_block;
  delete rep_;
}",31,,70,1,,void
73350,BLOCK,-1,,"{
  // Note: if more fields are added to Options, update
  // this function to catch changes that should not be allowed to
  // change in the middle of building a Table.
  if (options.comparator != rep_->options.comparator) {
    return Status::InvalidArgument(""changing comparator while building table"");
  }

  // Note that any live BlockBuilders point to rep_->options and therefore
  // will automatically pick up the updated options.
  rep_->options = options;
  rep_->index_block_options = options;
  rep_->index_block_options.block_restart_interval = 1;
  return Status::OK();
}",60,,76,2,,void
73361,BLOCK,-1,,"{
    return Status::InvalidArgument(""changing comparator while building table"");
  }",55,,80,2,,void
73395,BLOCK,-1,,"{
  Rep* r = rep_;
  assert(!r->closed);
  if (!ok()) return;
  if (r->num_entries > 0) {
    assert(r->options.comparator->Compare(key, Slice(r->last_key)) > 0);
  }

  if (r->pending_index_entry) {
    assert(r->data_block.empty());
    r->options.comparator->FindShortestSeparator(&r->last_key, key);
    std::string handle_encoding;
    r->pending_handle.EncodeTo(&handle_encoding);
    r->index_block.Add(r->last_key, Slice(handle_encoding));
    r->pending_index_entry = false;
  }

  if (r->filter_block != NULL) {
    r->filter_block->AddKey(key);
  }

  r->last_key.assign(key.data(), key.size());
  r->num_entries++;
  r->data_block.Add(key, value);

  const size_t estimated_block_size = r->data_block.CurrentSizeEstimate();
  if (estimated_block_size >= r->options.block_size) {
    Flush();
  }
}",62,,92,3,,void
73408,BLOCK,-1,,<empty>,14,,95,2,,void
73416,BLOCK,-1,,"{
    assert(r->options.comparator->Compare(key, Slice(r->last_key)) > 0);
  }",27,,96,2,,void
73437,BLOCK,-1,,"{
    assert(r->data_block.empty());
    r->options.comparator->FindShortestSeparator(&r->last_key, key);
    std::string handle_encoding;
    r->pending_handle.EncodeTo(&handle_encoding);
    r->index_block.Add(r->last_key, Slice(handle_encoding));
    r->pending_index_entry = false;
  }",31,,100,2,,void
73489,BLOCK,-1,,"{
    r->filter_block->AddKey(key);
  }",32,,109,2,,void
73540,BLOCK,-1,,"{
    Flush();
  }",54,,118,2,,void
73545,BLOCK,-1,,"{
  Rep* r = rep_;
  assert(!r->closed);
  if (!ok()) return;
  if (r->data_block.empty()) return;
  assert(!r->pending_index_entry);
  WriteBlock(&r->data_block, &r->pending_handle);
  if (ok()) {
    r->pending_index_entry = true;
    r->status = r->file->Flush();
  }
  if (r->filter_block != NULL) {
    r->filter_block->StartBlock(r->offset);
  }
}",28,,123,1,,void
73558,BLOCK,-1,,<empty>,14,,126,2,,void
73567,BLOCK,-1,,<empty>,30,,127,2,,void
73585,BLOCK,-1,,"{
    r->pending_index_entry = true;
    r->status = r->file->Flush();
  }",13,,130,2,,void
73607,BLOCK,-1,,"{
    r->filter_block->StartBlock(r->offset);
  }",32,,134,2,,void
73622,BLOCK,-1,,"{
  // File format contains a sequence of blocks where each block has:
  //    block_data: uint8[n]
  //    type: uint8
  //    crc: uint32
  assert(ok());
  Rep* r = rep_;
  Slice raw = block->Finish();

  Slice block_contents;
  CompressionType type = r->options.compression;
  // TODO(postrelease): Support more compression options: zlib?
  switch (type) {
    case kNoCompression:
      block_contents = raw;
      break;

    case kSnappyCompression: {
      std::string* compressed = &r->compressed_output;
      if (port::Snappy_Compress(raw.data(), raw.size(), compressed) &&
          compressed->size() < raw.size() - (raw.size() / 8u)) {
        block_contents = *compressed;
      } else {
        // Snappy not supported, or compressed less than 12.5%, so just
        // store uncompressed form
        block_contents = raw;
        type = kNoCompression;
      }
      break;
    }
  }
  WriteRawBlock(block_contents, type, handle);
  r->compressed_output.clear();
  block->Reset();
}",73,,139,3,,void
73647,BLOCK,-1,,"{
    case kNoCompression:
      block_contents = raw;
      break;

    case kSnappyCompression: {
      std::string* compressed = &r->compressed_output;
      if (port::Snappy_Compress(raw.data(), raw.size(), compressed) &&
          compressed->size() < raw.size() - (raw.size() / 8u)) {
        block_contents = *compressed;
      } else {
        // Snappy not supported, or compressed less than 12.5%, so just
        // store uncompressed form
        block_contents = raw;
        type = kNoCompression;
      }
      break;
    }
  }",17,,151,2,,void
73656,BLOCK,7,,"{
      std::string* compressed = &r->compressed_output;
      if (port::Snappy_Compress(raw.data(), raw.size(), compressed) &&
          compressed->size() < raw.size() - (raw.size() / 8u)) {
        block_contents = *compressed;
      } else {
        // Snappy not supported, or compressed less than 12.5%, so just
        // store uncompressed form
        block_contents = raw;
        type = kNoCompression;
      }
      break;
    }",30,,156,7,,void
73695,BLOCK,-1,,"{
        block_contents = *compressed;
      }",64,,159,2,,void
73701,BLOCK,-1,,"{
        // Snappy not supported, or compressed less than 12.5%, so just
        // store uncompressed form
        block_contents = raw;
        type = kNoCompression;
      }",14,,161,1,,void
73729,BLOCK,-1,,"{
  Rep* r = rep_;
  handle->set_offset(r->offset);
  handle->set_size(block_contents.size());
  r->status = r->file->Append(block_contents);
  if (r->status.ok()) {
    char trailer[kBlockTrailerSize];
    trailer[0] = type;
    uint32_t crc = crc32c::Value(block_contents.data(), block_contents.size());
    crc = crc32c::Extend(crc, trailer, 1);  // Extend crc to cover block type
    EncodeFixed32(trailer+1, crc32c::Mask(crc));
    r->status = r->file->Append(Slice(trailer, kBlockTrailerSize));
    if (r->status.ok()) {
      r->offset += block_contents.size() + kBlockTrailerSize;
    }
  }
}",55,,177,4,,void
73767,BLOCK,-1,,"{
    char trailer[kBlockTrailerSize];
    trailer[0] = type;
    uint32_t crc = crc32c::Value(block_contents.data(), block_contents.size());
    crc = crc32c::Extend(crc, trailer, 1);  // Extend crc to cover block type
    EncodeFixed32(trailer+1, crc32c::Mask(crc));
    r->status = r->file->Append(Slice(trailer, kBlockTrailerSize));
    if (r->status.ok()) {
      r->offset += block_contents.size() + kBlockTrailerSize;
    }
  }",23,,182,2,,void
73827,BLOCK,-1,,"{
      r->offset += block_contents.size() + kBlockTrailerSize;
    }",25,,189,2,,void
73841,BLOCK,-1,,"{
  return rep_->status;
}",37,,195,1,,void
73849,BLOCK,-1,,"{
  Rep* r = rep_;
  Flush();
  assert(!r->closed);
  r->closed = true;

  BlockHandle filter_block_handle, metaindex_block_handle, index_block_handle;

  // Write filter block
  if (ok() && r->filter_block != NULL) {
    WriteRawBlock(r->filter_block->Finish(), kNoCompression,
                  &filter_block_handle);
  }

  // Write metaindex block
  if (ok()) {
    BlockBuilder meta_index_block(&r->options);
    if (r->filter_block != NULL) {
      // Add mapping from ""filter.Name"" to location of filter data
      std::string key = ""filter."";
      key.append(r->options.filter_policy->Name());
      std::string handle_encoding;
      filter_block_handle.EncodeTo(&handle_encoding);
      meta_index_block.Add(key, handle_encoding);
    }

    // TODO(postrelease): Add stats and other meta blocks
    WriteBlock(&meta_index_block, &metaindex_block_handle);
  }

  // Write index block
  if (ok()) {
    if (r->pending_index_entry) {
      r->options.comparator->FindShortSuccessor(&r->la...",31,,199,1,,void
73876,BLOCK,-1,,"{
    WriteRawBlock(r->filter_block->Finish(), kNoCompression,
                  &filter_block_handle);
  }",40,,208,2,,void
73889,BLOCK,-1,,"{
    BlockBuilder meta_index_block(&r->options);
    if (r->filter_block != NULL) {
      // Add mapping from ""filter.Name"" to location of filter data
      std::string key = ""filter."";
      key.append(r->options.filter_policy->Name());
      std::string handle_encoding;
      filter_block_handle.EncodeTo(&handle_encoding);
      meta_index_block.Add(key, handle_encoding);
    }

    // TODO(postrelease): Add stats and other meta blocks
    WriteBlock(&meta_index_block, &metaindex_block_handle);
  }",13,,214,2,,void
73902,BLOCK,-1,,"{
      // Add mapping from ""filter.Name"" to location of filter data
      std::string key = ""filter."";
      key.append(r->options.filter_policy->Name());
      std::string handle_encoding;
      filter_block_handle.EncodeTo(&handle_encoding);
      meta_index_block.Add(key, handle_encoding);
    }",34,,216,2,,void
73939,BLOCK,-1,,"{
    if (r->pending_index_entry) {
      r->options.comparator->FindShortSuccessor(&r->last_key);
      std::string handle_encoding;
      r->pending_handle.EncodeTo(&handle_encoding);
      r->index_block.Add(r->last_key, Slice(handle_encoding));
      r->pending_index_entry = false;
    }
    WriteBlock(&r->index_block, &index_block_handle);
  }",13,,230,2,,void
73944,BLOCK,-1,,"{
      r->options.comparator->FindShortSuccessor(&r->last_key);
      std::string handle_encoding;
      r->pending_handle.EncodeTo(&handle_encoding);
      r->index_block.Add(r->last_key, Slice(handle_encoding));
      r->pending_index_entry = false;
    }",33,,231,2,,void
73991,BLOCK,-1,,"{
    Footer footer;
    footer.set_metaindex_handle(metaindex_block_handle);
    footer.set_index_handle(index_block_handle);
    std::string footer_encoding;
    footer.EncodeTo(&footer_encoding);
    r->status = r->file->Append(footer_encoding);
    if (r->status.ok()) {
      r->offset += footer_encoding.size();
    }
  }",13,,242,2,,void
74028,BLOCK,-1,,"{
      r->offset += footer_encoding.size();
    }",25,,249,2,,void
74044,BLOCK,-1,,"{
  Rep* r = rep_;
  assert(!r->closed);
  r->closed = true;
}",30,,256,1,,void
74062,BLOCK,-1,,"{
  return rep_->num_entries;
}",43,,262,1,,void
74070,BLOCK,-1,,"{
  return rep_->offset;
}",41,,266,1,,void
74113,BLOCK,-1,,<empty>,1,,1,1,,ANY
74117,BLOCK,-1,,"{
  std::string str(key.ToString());
  std::string rev("""");
  for (std::string::reverse_iterator rit = str.rbegin();
       rit != str.rend(); ++rit) {
    rev.push_back(*rit);
  }
  return rev;
}",46,,27,2,,void
74128,BLOCK,-1,,<empty>,3,,30,1,,void
74144,BLOCK,4,,"{
    rev.push_back(*rit);
  }",34,,31,4,,void
74158,BLOCK,-1,,"{
    return ""leveldb.ReverseBytewiseComparator"";
  }",36,,40,1,,void
74166,BLOCK,-1,,"{
    return BytewiseComparator()->Compare(Reverse(a), Reverse(b));
  }",61,,44,3,,void
74181,BLOCK,-1,,"{
    std::string s = Reverse(*start);
    std::string l = Reverse(limit);
    BytewiseComparator()->FindShortestSeparator(&s, l);
    *start = Reverse(s);
  }",33,,50,3,,void
74209,BLOCK,-1,,"{
    std::string s = Reverse(*key);
    BytewiseComparator()->FindShortSuccessor(&s);
    *key = Reverse(s);
  }",59,,57,2,,void
74233,BLOCK,-1,,"{
  if (cmp == BytewiseComparator()) {
    key->push_back('\0');
  } else {
    assert(cmp == &reverse_key_comparator);
    std::string rev = Reverse(*key);
    rev.push_back('\0');
    *key = Reverse(rev);
  }
}",64,,66,3,,void
74238,BLOCK,-1,,"{
    key->push_back('\0');
  }",36,,67,2,,void
74245,BLOCK,-1,,"{
    assert(cmp == &reverse_key_comparator);
    std::string rev = Reverse(*key);
    rev.push_back('\0');
    *key = Reverse(rev);
  }",10,,69,1,,void
74273,BLOCK,-1,,{ },45,,82,1,,void
74278,BLOCK,-1,,{ },45,,83,2,,void
74284,BLOCK,-1,,"{
    return cmp->Compare(Slice(a), Slice(b)) < 0;
  }",69,,84,3,,void
74300,BLOCK,-1,,{ },17,,92,1,,void
74304,BLOCK,-1,,{ return contents_; },39,,94,1,,void
74310,BLOCK,-1,,{ return Status::OK(); },26,,96,1,,void
74319,BLOCK,-1,,{ return Status::OK(); },26,,97,1,,void
74328,BLOCK,-1,,{ return Status::OK(); },25,,98,1,,void
74338,BLOCK,-1,,"{
    contents_.append(data.data(), data.size());
    return Status::OK();
  }",44,,100,2,,void
74362,BLOCK,-1,,"{
  }",53,,113,2,,void
74366,BLOCK,-1,,{ },27,,116,1,,void
74370,BLOCK,-1,,{ return contents_.size(); },25,,118,1,,void
74383,BLOCK,-1,,"{
    if (offset > contents_.size()) {
      return Status::InvalidArgument(""invalid Read offset"");
    }
    if (offset + n > contents_.size()) {
      n = contents_.size() - offset;
    }
    memcpy(scratch, &contents_[offset], n);
    *result = Slice(scratch, n);
    return Status::OK();
  }",45,,121,5,,void
74391,BLOCK,-1,,"{
      return Status::InvalidArgument(""invalid Read offset"");
    }",36,,122,2,,void
74407,BLOCK,-1,,"{
      n = contents_.size() - offset;
    }",40,,125,2,,void
74441,BLOCK,-1,,{ },73,,143,2,,void
74445,BLOCK,-1,,{ },26,,144,1,,void
74451,BLOCK,-1,,"{
    data_[key] = value.ToString();
  }",56,,146,3,,void
74466,BLOCK,-1,,"{
    *kvmap = data_;
    keys->clear();
    for (KVMap::const_iterator it = data_.begin();
         it != data_.end();
         ++it) {
      keys->push_back(it->first);
    }
    data_.clear();
    Status s = FinishImpl(options, *kvmap);
    ASSERT_TRUE(s.ok()) << s.ToString();
  }",29,,155,4,,void
74476,BLOCK,-1,,<empty>,5,,158,1,,void
74492,BLOCK,4,,"{
      keys->push_back(it->first);
    }",16,,160,4,,void
74517,BLOCK,1,,<empty>,,,,3,,void
74543,BLOCK,-1,,<empty>,,,,3,,<empty>
74547,BLOCK,-1,,<empty>,,,,1,,<empty>
74551,BLOCK,-1,,{ return data_; },31,,173,1,,void
74557,BLOCK,-1,,{ return NULL; },26,,175,1,,void
74566,BLOCK,-1,,{ },22,,186,2,,void
74570,BLOCK,-1,,"{
    delete block_;
  }",23,,187,1,,void
74578,BLOCK,-1,,"{
    delete block_;
    block_ = NULL;
    BlockBuilder builder(&options);

    for (KVMap::const_iterator it = data.begin();
         it != data.end();
         ++it) {
      builder.Add(it->first, it->second);
    }
    // Open the block
    data_ = builder.Finish().ToString();
    BlockContents contents;
    contents.data = data_;
    contents.cachable = false;
    contents.heap_allocated = false;
    block_ = new Block(contents);
    return Status::OK();
  }",72,,190,3,,void
74589,BLOCK,-1,,<empty>,5,,195,1,,void
74605,BLOCK,4,,"{
      builder.Add(it->first, it->second);
    }",16,,197,4,,void
74654,BLOCK,-1,,"{
    return block_->NewIterator(comparator_);
  }",41,,209,1,,void
74667,BLOCK,-1,,<empty>,,,,1,,<empty>
74673,BLOCK,-1,,"{
  }",37,,225,2,,void
74677,BLOCK,-1,,"{
    Reset();
  }",23,,227,1,,void
74684,BLOCK,-1,,"{
    Reset();
    StringSink sink;
    TableBuilder builder(options, &sink);

    for (KVMap::const_iterator it = data.begin();
         it != data.end();
         ++it) {
      builder.Add(it->first, it->second);
      ASSERT_TRUE(builder.status().ok());
    }
    Status s = builder.Finish();
    ASSERT_TRUE(s.ok()) << s.ToString();

    ASSERT_EQ(sink.contents().size(), builder.FileSize());

    // Open the table
    source_ = new StringSource(sink.contents());
    Options table_options;
    table_options.comparator = options.comparator;
    return Table::Open(table_options, source_, sink.contents().size(), &table_);
  }",72,,230,3,,void
74693,BLOCK,-1,,<empty>,5,,235,1,,void
74709,BLOCK,4,,"{
      builder.Add(it->first, it->second);
      ASSERT_TRUE(builder.status().ok());
    }",16,,237,4,,void
74728,BLOCK,1,,<empty>,,,,3,,void
74761,BLOCK,1,,<empty>,,,,3,,void
74794,BLOCK,1,,<empty>,,,,5,,void
74852,BLOCK,-1,,"{
    return table_->NewIterator(ReadOptions());
  }",41,,253,1,,void
74863,BLOCK,-1,,"{
    return table_->ApproximateOffsetOf(key);
  }",56,,257,2,,void
74873,BLOCK,-1,,"{
    delete table_;
    delete source_;
    table_ = NULL;
    source_ = NULL;
  }",16,,262,1,,void
74889,BLOCK,-1,,<empty>,,,,1,,<empty>
74895,BLOCK,-1,,{ },64,,278,2,,void
74899,BLOCK,-1,,{ delete iter_; },36,,279,1,,void
74905,BLOCK,-1,,{ return iter_->Valid(); },30,,280,1,,void
74915,BLOCK,-1,,"{
    ParsedInternalKey ikey(target, kMaxSequenceNumber, kTypeValue);
    std::string encoded;
    AppendInternalKey(&encoded, ikey);
    iter_->Seek(encoded);
  }",42,,281,2,,void
74934,BLOCK,-1,,{ iter_->SeekToFirst(); },30,,287,1,,void
74942,BLOCK,-1,,{ iter_->SeekToLast(); },29,,288,1,,void
74950,BLOCK,-1,,{ iter_->Next(); },23,,289,1,,void
74958,BLOCK,-1,,{ iter_->Prev(); },23,,290,1,,void
74966,BLOCK,-1,,"{
    assert(Valid());
    ParsedInternalKey key;
    if (!ParseInternalKey(iter_->key(), &key)) {
      status_ = Status::Corruption(""malformed internal key"");
      return Slice(""corrupted key"");
    }
    return key.user_key;
  }",29,,292,1,,void
74979,BLOCK,-1,,"{
      status_ = Status::Corruption(""malformed internal key"");
      return Slice(""corrupted key"");
    }",48,,295,2,,void
74997,BLOCK,-1,,{ return iter_->value(); },31,,302,1,,void
75006,BLOCK,-1,,"{
    return status_.ok() ? iter_->status() : status_;
  }",33,,303,1,,void
75024,BLOCK,-1,,<empty>,,,,2,,<empty>
75029,BLOCK,-1,,<empty>,,,,2,,<empty>
75035,BLOCK,-1,,"{
    memtable_ = new MemTable(internal_comparator_);
    memtable_->Ref();
  }",35,,320,2,,void
75048,BLOCK,-1,,"{
    memtable_->Unref();
  }",26,,324,1,,void
75058,BLOCK,-1,,"{
    memtable_->Unref();
    memtable_ = new MemTable(internal_comparator_);
    memtable_->Ref();
    int seq = 1;
    for (KVMap::const_iterator it = data.begin();
         it != data.end();
         ++it) {
      memtable_->Add(seq, kTypeValue, it->first, it->second);
      seq++;
    }
    return Status::OK();
  }",72,,327,3,,void
75077,BLOCK,-1,,<empty>,5,,332,1,,void
75093,BLOCK,4,,"{
      memtable_->Add(seq, kTypeValue, it->first, it->second);
      seq++;
    }",16,,334,4,,void
75116,BLOCK,-1,,"{
    return new KeyConvertingIterator(memtable_->NewIterator());
  }",41,,340,1,,void
75131,BLOCK,-1,,"{
    db_ = NULL;
    NewDB();
  }",26,,353,2,,void
75139,BLOCK,-1,,"{
    delete db_;
  }",20,,357,1,,void
75147,BLOCK,-1,,"{
    delete db_;
    db_ = NULL;
    NewDB();
    for (KVMap::const_iterator it = data.begin();
         it != data.end();
         ++it) {
      WriteBatch batch;
      batch.Put(it->first, it->second);
      ASSERT_TRUE(db_->Write(WriteOptions(), &batch).ok());
    }
    return Status::OK();
  }",72,,360,3,,void
75155,BLOCK,-1,,<empty>,5,,364,1,,void
75171,BLOCK,4,,"{
      WriteBatch batch;
      batch.Put(it->first, it->second);
      ASSERT_TRUE(db_->Write(WriteOptions(), &batch).ok());
    }",16,,366,4,,void
75184,BLOCK,1,,<empty>,,,,2,,void
75215,BLOCK,-1,,"{
    return db_->NewIterator(ReadOptions());
  }",41,,373,1,,void
75225,BLOCK,-1,,{ return db_; },26,,377,1,,void
75231,BLOCK,-1,,"{
    std::string name = test::TmpDir() + ""/table_testdb"";

    Options options;
    options.comparator = comparator_;
    Status status = DestroyDB(name, options);
    ASSERT_TRUE(status.ok()) << status.ToString();

    options.create_if_missing = true;
    options.error_if_exists = true;
    options.write_buffer_size = 10000;  // Something small to force merging
    status = DB::Open(options, name, &db_);
    ASSERT_TRUE(status.ok()) << status.ToString();
  }",16,,380,1,,void
75259,BLOCK,1,,<empty>,,,,3,,void
75311,BLOCK,1,,<empty>,,,,3,,void
75425,BLOCK,-1,,{ },34,,439,1,,void
75430,BLOCK,-1,,"{
    delete constructor_;
    constructor_ = NULL;
    options_ = Options();

    options_.block_restart_interval = args.restart_interval;
    // Use shorter block size for tests to exercise block boundary
    // conditions more.
    options_.block_size = 256;
    if (args.reverse_compare) {
      options_.comparator = &reverse_key_comparator;
    }
    switch (args.type) {
      case TABLE_TEST:
        constructor_ = new TableConstructor(options_.comparator);
        break;
      case BLOCK_TEST:
        constructor_ = new BlockConstructor(options_.comparator);
        break;
      case MEMTABLE_TEST:
        constructor_ = new MemTableConstructor(options_.comparator);
        break;
      case DB_TEST:
        constructor_ = new DBConstructor(options_.comparator);
        break;
    }
  }",35,,441,2,,void
75455,BLOCK,-1,,"{
      options_.comparator = &reverse_key_comparator;
    }",31,,450,2,,void
75466,BLOCK,-1,,"{
      case TABLE_TEST:
        constructor_ = new TableConstructor(options_.comparator);
        break;
      case BLOCK_TEST:
        constructor_ = new BlockConstructor(options_.comparator);
        break;
      case MEMTABLE_TEST:
        constructor_ = new MemTableConstructor(options_.comparator);
        break;
      case DB_TEST:
        constructor_ = new DBConstructor(options_.comparator);
        break;
    }",24,,453,2,,void
75510,BLOCK,-1,,"{
    delete constructor_;
  }",14,,469,1,,void
75518,BLOCK,-1,,"{
    constructor_->Add(key, value);
  }",62,,473,3,,void
75529,BLOCK,-1,,"{
    std::vector<std::string> keys;
    KVMap data;
    constructor_->Finish(options_, &keys, &data);

    TestForwardScan(keys, data);
    TestBackwardScan(keys, data);
    TestRandomAccess(rnd, keys, data);
  }",26,,477,2,,void
75564,BLOCK,-1,,"{
    Iterator* iter = constructor_->NewIterator();
    ASSERT_TRUE(!iter->Valid());
    iter->SeekToFirst();
    for (KVMap::const_iterator model_iter = data.begin();
         model_iter != data.end();
         ++model_iter) {
      ASSERT_EQ(ToString(data, model_iter), ToString(iter));
      iter->Next();
    }
    ASSERT_TRUE(!iter->Valid());
    delete iter;
  }",43,,488,3,,void
75578,BLOCK,1,,<empty>,,,,3,,void
75601,BLOCK,-1,,<empty>,5,,492,1,,void
75617,BLOCK,4,,"{
      ASSERT_EQ(ToString(data, model_iter), ToString(iter));
      iter->Next();
    }",24,,494,4,,void
75621,BLOCK,1,,<empty>,,,,3,,void
75648,BLOCK,1,,<empty>,,,,3,,void
75673,BLOCK,-1,,"{
    Iterator* iter = constructor_->NewIterator();
    ASSERT_TRUE(!iter->Valid());
    iter->SeekToLast();
    for (KVMap::const_reverse_iterator model_iter = data.rbegin();
         model_iter != data.rend();
         ++model_iter) {
      ASSERT_EQ(ToString(data, model_iter), ToString(iter));
      iter->Prev();
    }
    ASSERT_TRUE(!iter->Valid());
    delete iter;
  }",44,,503,3,,void
75687,BLOCK,1,,<empty>,,,,3,,void
75710,BLOCK,-1,,<empty>,5,,507,1,,void
75726,BLOCK,4,,"{
      ASSERT_EQ(ToString(data, model_iter), ToString(iter));
      iter->Prev();
    }",24,,509,4,,void
75730,BLOCK,1,,<empty>,,,,3,,void
75757,BLOCK,1,,<empty>,,,,3,,void
75783,BLOCK,-1,,"{
    static const bool kVerbose = false;
    Iterator* iter = constructor_->NewIterator();
    ASSERT_TRUE(!iter->Valid());
    KVMap::const_iterator model_iter = data.begin();
    if (kVerbose) fprintf(stderr, ""---\n"");
    for (int i = 0; i < 200; i++) {
      const int toss = rnd->Uniform(5);
      switch (toss) {
        case 0: {
          if (iter->Valid()) {
            if (kVerbose) fprintf(stderr, ""Next\n"");
            iter->Next();
            ++model_iter;
            ASSERT_EQ(ToString(data, model_iter), ToString(iter));
          }
          break;
        }

        case 1: {
          if (kVerbose) fprintf(stderr, ""SeekToFirst\n"");
          iter->SeekToFirst();
          model_iter = data.begin();
          ASSERT_EQ(ToString(data, model_iter), ToString(iter));
          break;
        }

        case 2: {
          std::string key = PickRandomKey(rnd, keys);
          model_iter = data.lower_bound(key);
          if (kVerbose) fprintf(stderr, ""Seek '%s'\n"",
      ...",44,,519,4,,void
75801,BLOCK,1,,<empty>,,,,3,,void
75828,BLOCK,-1,,<empty>,19,,524,2,,void
75833,BLOCK,-1,,<empty>,5,,525,1,,void
75843,BLOCK,4,,"{
      const int toss = rnd->Uniform(5);
      switch (toss) {
        case 0: {
          if (iter->Valid()) {
            if (kVerbose) fprintf(stderr, ""Next\n"");
            iter->Next();
            ++model_iter;
            ASSERT_EQ(ToString(data, model_iter), ToString(iter));
          }
          break;
        }

        case 1: {
          if (kVerbose) fprintf(stderr, ""SeekToFirst\n"");
          iter->SeekToFirst();
          model_iter = data.begin();
          ASSERT_EQ(ToString(data, model_iter), ToString(iter));
          break;
        }

        case 2: {
          std::string key = PickRandomKey(rnd, keys);
          model_iter = data.lower_bound(key);
          if (kVerbose) fprintf(stderr, ""Seek '%s'\n"",
                                EscapeString(key).c_str());
          iter->Seek(Slice(key));
          ASSERT_EQ(ToString(data, model_iter), ToString(iter));
          break;
        }

        case 3: {
          if (iter->Valid()) {
            if (kVerbose) ...",35,,525,4,,void
75854,BLOCK,-1,,"{
        case 0: {
          if (iter->Valid()) {
            if (kVerbose) fprintf(stderr, ""Next\n"");
            iter->Next();
            ++model_iter;
            ASSERT_EQ(ToString(data, model_iter), ToString(iter));
          }
          break;
        }

        case 1: {
          if (kVerbose) fprintf(stderr, ""SeekToFirst\n"");
          iter->SeekToFirst();
          model_iter = data.begin();
          ASSERT_EQ(ToString(data, model_iter), ToString(iter));
          break;
        }

        case 2: {
          std::string key = PickRandomKey(rnd, keys);
          model_iter = data.lower_bound(key);
          if (kVerbose) fprintf(stderr, ""Seek '%s'\n"",
                                EscapeString(key).c_str());
          iter->Seek(Slice(key));
          ASSERT_EQ(ToString(data, model_iter), ToString(iter));
          break;
        }

        case 3: {
          if (iter->Valid()) {
            if (kVerbose) fprintf(stderr, ""Prev\n"");
            iter->Prev();
         ...",21,,527,2,,void
75857,BLOCK,3,,"{
          if (iter->Valid()) {
            if (kVerbose) fprintf(stderr, ""Next\n"");
            iter->Next();
            ++model_iter;
            ASSERT_EQ(ToString(data, model_iter), ToString(iter));
          }
          break;
        }",17,,528,3,,void
75863,BLOCK,-1,,"{
            if (kVerbose) fprintf(stderr, ""Next\n"");
            iter->Next();
            ++model_iter;
            ASSERT_EQ(ToString(data, model_iter), ToString(iter));
          }",30,,529,2,,void
75866,BLOCK,-1,,<empty>,27,,530,2,,void
75879,BLOCK,1,,<empty>,,,,4,,void
75899,BLOCK,6,,"{
          if (kVerbose) fprintf(stderr, ""SeekToFirst\n"");
          iter->SeekToFirst();
          model_iter = data.begin();
          ASSERT_EQ(ToString(data, model_iter), ToString(iter));
          break;
        }",17,,538,6,,void
75902,BLOCK,-1,,<empty>,25,,539,2,,void
75919,BLOCK,1,,<empty>,,,,4,,void
75939,BLOCK,9,,"{
          std::string key = PickRandomKey(rnd, keys);
          model_iter = data.lower_bound(key);
          if (kVerbose) fprintf(stderr, ""Seek '%s'\n"",
                                EscapeString(key).c_str());
          iter->Seek(Slice(key));
          ASSERT_EQ(ToString(data, model_iter), ToString(iter));
          break;
        }",17,,546,9,,void
75955,BLOCK,-1,,<empty>,25,,549,2,,void
75973,BLOCK,1,,<empty>,,,,4,,void
75993,BLOCK,12,,"{
          if (iter->Valid()) {
            if (kVerbose) fprintf(stderr, ""Prev\n"");
            iter->Prev();
            if (model_iter == data.begin()) {
              model_iter = data.end();   // Wrap around to invalid value
            } else {
              --model_iter;
            }
            ASSERT_EQ(ToString(data, model_iter), ToString(iter));
          }
          break;
        }",17,,556,12,,void
75999,BLOCK,-1,,"{
            if (kVerbose) fprintf(stderr, ""Prev\n"");
            iter->Prev();
            if (model_iter == data.begin()) {
              model_iter = data.end();   // Wrap around to invalid value
            } else {
              --model_iter;
            }
            ASSERT_EQ(ToString(data, model_iter), ToString(iter));
          }",30,,557,2,,void
76002,BLOCK,-1,,<empty>,27,,558,2,,void
76017,BLOCK,-1,,"{
              model_iter = data.end();   // Wrap around to invalid value
            }",45,,560,2,,void
76025,BLOCK,-1,,"{
              --model_iter;
            }",20,,562,1,,void
76031,BLOCK,1,,<empty>,,,,4,,void
76051,BLOCK,15,,"{
          if (kVerbose) fprintf(stderr, ""SeekToLast\n"");
          iter->SeekToLast();
          if (keys.empty()) {
            model_iter = data.end();
          } else {
            std::string last = data.rbegin()->first;
            model_iter = data.lower_bound(last);
          }
          ASSERT_EQ(ToString(data, model_iter), ToString(iter));
          break;
        }",17,,570,15,,void
76054,BLOCK,-1,,<empty>,25,,571,2,,void
76067,BLOCK,-1,,"{
            model_iter = data.end();
          }",29,,573,2,,void
76075,BLOCK,-1,,"{
            std::string last = data.rbegin()->first;
            model_iter = data.lower_bound(last);
          }",18,,575,1,,void
76095,BLOCK,1,,<empty>,,,,4,,void
76120,BLOCK,-1,,"{
    if (it == data.end()) {
      return ""END"";
    } else {
      return ""'"" + it->first + ""->"" + it->second + ""'"";
    }
  }",76,,587,3,,void
76128,BLOCK,-1,,"{
      return ""END"";
    }",27,,588,2,,void
76132,BLOCK,-1,,"{
      return ""'"" + it->first + ""->"" + it->second + ""'"";
    }",12,,590,1,,void
76152,BLOCK,-1,,"{
    if (it == data.rend()) {
      return ""END"";
    } else {
      return ""'"" + it->first + ""->"" + it->second + ""'"";
    }
  }",65,,596,3,,void
76160,BLOCK,-1,,"{
      return ""END"";
    }",28,,597,2,,void
76164,BLOCK,-1,,"{
      return ""'"" + it->first + ""->"" + it->second + ""'"";
    }",12,,599,1,,void
76183,BLOCK,-1,,"{
    if (!it->Valid()) {
      return ""END"";
    } else {
      return ""'"" + it->key().ToString() + ""->"" + it->value().ToString() + ""'"";
    }
  }",44,,604,2,,void
76190,BLOCK,-1,,"{
      return ""END"";
    }",23,,605,2,,void
76194,BLOCK,-1,,"{
      return ""'"" + it->key().ToString() + ""->"" + it->value().ToString() + ""'"";
    }",12,,607,1,,void
76222,BLOCK,-1,,"{
    if (keys.empty()) {
      return ""foo"";
    } else {
      const int index = rnd->Uniform(keys.size());
      std::string result = keys[index];
      switch (rnd->Uniform(3)) {
        case 0:
          // Return an existing key
          break;
        case 1: {
          // Attempt to return something smaller than an existing key
          if (result.size() > 0 && result[result.size()-1] > '\0') {
            result[result.size()-1]--;
          }
          break;
        }
        case 2: {
          // Return something larger than an existing key
          Increment(options_.comparator, &result);
          break;
        }
      }
      return result;
    }
  }",80,,612,3,,void
76228,BLOCK,-1,,"{
      return ""foo"";
    }",23,,613,2,,void
76232,BLOCK,-1,,"{
      const int index = rnd->Uniform(keys.size());
      std::string result = keys[index];
      switch (rnd->Uniform(3)) {
        case 0:
          // Return an existing key
          break;
        case 1: {
          // Attempt to return something smaller than an existing key
          if (result.size() > 0 && result[result.size()-1] > '\0') {
            result[result.size()-1]--;
          }
          break;
        }
        case 2: {
          // Return something larger than an existing key
          Increment(options_.comparator, &result);
          break;
        }
      }
      return result;
    }",12,,615,1,,void
76256,BLOCK,-1,,"{
        case 0:
          // Return an existing key
          break;
        case 1: {
          // Attempt to return something smaller than an existing key
          if (result.size() > 0 && result[result.size()-1] > '\0') {
            result[result.size()-1]--;
          }
          break;
        }
        case 2: {
          // Return something larger than an existing key
          Increment(options_.comparator, &result);
          break;
        }
      }",32,,618,2,,void
76262,BLOCK,6,,"{
          // Attempt to return something smaller than an existing key
          if (result.size() > 0 && result[result.size()-1] > '\0') {
            result[result.size()-1]--;
          }
          break;
        }",17,,622,6,,void
76281,BLOCK,-1,,"{
            result[result.size()-1]--;
          }",68,,624,2,,void
76294,BLOCK,9,,"{
          // Return something larger than an existing key
          Increment(options_.comparator, &result);
          break;
        }",17,,629,9,,void
76307,BLOCK,-1,,{ return constructor_->db(); },18,,640,1,,void
76319,BLOCK,-1,,<empty>,,,,1,,<empty>
76323,BLOCK,-1,,"TEST(Harness, Empty)",1,,648,1,,void
76347,BLOCK,-1,,"{
  for (int i = 0; i < kNumTestArgs; i++) {
    Init(kTestArgList[i]);
    Random rnd(test::RandomSeed() + 1);
    Test(&rnd);
  }
}",22,,648,1,,void
76349,BLOCK,-1,,<empty>,3,,649,1,,void
76359,BLOCK,4,,"{
    Init(kTestArgList[i]);
    Random rnd(test::RandomSeed() + 1);
    Test(&rnd);
  }",42,,649,4,,void
76379,BLOCK,-1,,<empty>,,,,1,,<empty>
76383,BLOCK,-1,,"TEST(Harness, ZeroRestartPointsInBlock)",1,,659,1,,void
76407,BLOCK,-1,,"{
  char data[sizeof(uint32_t)];
  memset(data, 0, sizeof(data));
  BlockContents contents;
  contents.data = Slice(data, sizeof(data));
  contents.cachable = false;
  contents.heap_allocated = false;
  Block block(contents);
  Iterator* iter = block.NewIterator(BytewiseComparator());
  iter->SeekToFirst();
  ASSERT_TRUE(!iter->Valid());
  iter->SeekToLast();
  ASSERT_TRUE(!iter->Valid());
  iter->Seek(""foo"");
  ASSERT_TRUE(!iter->Valid());
  delete iter;
}",41,,659,1,,void
76454,BLOCK,1,,<empty>,,,,3,,void
76482,BLOCK,1,,<empty>,,,,3,,void
76511,BLOCK,1,,<empty>,,,,3,,void
76535,BLOCK,-1,,<empty>,,,,1,,<empty>
76539,BLOCK,-1,,"TEST(Harness, SimpleEmptyKey)",1,,678,1,,void
76563,BLOCK,-1,,"{
  for (int i = 0; i < kNumTestArgs; i++) {
    Init(kTestArgList[i]);
    Random rnd(test::RandomSeed() + 1);
    Add("""", ""v"");
    Test(&rnd);
  }
}",31,,678,1,,void
76565,BLOCK,-1,,<empty>,3,,679,1,,void
76575,BLOCK,4,,"{
    Init(kTestArgList[i]);
    Random rnd(test::RandomSeed() + 1);
    Add("""", ""v"");
    Test(&rnd);
  }",42,,679,4,,void
76598,BLOCK,-1,,<empty>,,,,1,,<empty>
76602,BLOCK,-1,,"TEST(Harness, SimpleSingle)",1,,687,1,,void
76626,BLOCK,-1,,"{
  for (int i = 0; i < kNumTestArgs; i++) {
    Init(kTestArgList[i]);
    Random rnd(test::RandomSeed() + 2);
    Add(""abc"", ""v"");
    Test(&rnd);
  }
}",29,,687,1,,void
76628,BLOCK,-1,,<empty>,3,,688,1,,void
76638,BLOCK,4,,"{
    Init(kTestArgList[i]);
    Random rnd(test::RandomSeed() + 2);
    Add(""abc"", ""v"");
    Test(&rnd);
  }",42,,688,4,,void
76661,BLOCK,-1,,<empty>,,,,1,,<empty>
76665,BLOCK,-1,,"TEST(Harness, SimpleMulti)",1,,696,1,,void
76689,BLOCK,-1,,"{
  for (int i = 0; i < kNumTestArgs; i++) {
    Init(kTestArgList[i]);
    Random rnd(test::RandomSeed() + 3);
    Add(""abc"", ""v"");
    Add(""abcd"", ""v"");
    Add(""ac"", ""v2"");
    Test(&rnd);
  }
}",28,,696,1,,void
76691,BLOCK,-1,,<empty>,3,,697,1,,void
76701,BLOCK,4,,"{
    Init(kTestArgList[i]);
    Random rnd(test::RandomSeed() + 3);
    Add(""abc"", ""v"");
    Add(""abcd"", ""v"");
    Add(""ac"", ""v2"");
    Test(&rnd);
  }",42,,697,4,,void
76730,BLOCK,-1,,<empty>,,,,1,,<empty>
76734,BLOCK,-1,,"TEST(Harness, SimpleSpecialKey)",1,,707,1,,void
76758,BLOCK,-1,,"{
  for (int i = 0; i < kNumTestArgs; i++) {
    Init(kTestArgList[i]);
    Random rnd(test::RandomSeed() + 4);
    Add(""\xff\xff"", ""v3"");
    Test(&rnd);
  }
}",33,,707,1,,void
76760,BLOCK,-1,,<empty>,3,,708,1,,void
76770,BLOCK,4,,"{
    Init(kTestArgList[i]);
    Random rnd(test::RandomSeed() + 4);
    Add(""\xff\xff"", ""v3"");
    Test(&rnd);
  }",42,,708,4,,void
76793,BLOCK,-1,,<empty>,,,,1,,<empty>
76797,BLOCK,-1,,"TEST(Harness, Randomized)",1,,716,1,,void
76821,BLOCK,-1,,"{
  for (int i = 0; i < kNumTestArgs; i++) {
    Init(kTestArgList[i]);
    Random rnd(test::RandomSeed() + 5);
    for (int num_entries = 0; num_entries < 2000;
         num_entries += (num_entries < 50 ? 1 : 200)) {
      if ((num_entries % 10) == 0) {
        fprintf(stderr, ""case %d of %d: num_entries = %d\n"",
                (i + 1), int(kNumTestArgs), num_entries);
      }
      for (int e = 0; e < num_entries; e++) {
        std::string v;
        Add(test::RandomKey(&rnd, rnd.Skewed(4)),
            test::RandomString(&rnd, rnd.Skewed(5), &v).ToString());
      }
      Test(&rnd);
    }
  }
}",27,,716,1,,void
76823,BLOCK,-1,,<empty>,3,,717,1,,void
76833,BLOCK,4,,"{
    Init(kTestArgList[i]);
    Random rnd(test::RandomSeed() + 5);
    for (int num_entries = 0; num_entries < 2000;
         num_entries += (num_entries < 50 ? 1 : 200)) {
      if ((num_entries % 10) == 0) {
        fprintf(stderr, ""case %d of %d: num_entries = %d\n"",
                (i + 1), int(kNumTestArgs), num_entries);
      }
      for (int e = 0; e < num_entries; e++) {
        std::string v;
        Add(test::RandomKey(&rnd, rnd.Skewed(4)),
            test::RandomString(&rnd, rnd.Skewed(5), &v).ToString());
      }
      Test(&rnd);
    }
  }",42,,717,4,,void
76847,BLOCK,-1,,<empty>,5,,720,1,,void
76863,BLOCK,4,,"{
      if ((num_entries % 10) == 0) {
        fprintf(stderr, ""case %d of %d: num_entries = %d\n"",
                (i + 1), int(kNumTestArgs), num_entries);
      }
      for (int e = 0; e < num_entries; e++) {
        std::string v;
        Add(test::RandomKey(&rnd, rnd.Skewed(4)),
            test::RandomString(&rnd, rnd.Skewed(5), &v).ToString());
      }
      Test(&rnd);
    }",55,,721,4,,void
76870,BLOCK,-1,,"{
        fprintf(stderr, ""case %d of %d: num_entries = %d\n"",
                (i + 1), int(kNumTestArgs), num_entries);
      }",36,,722,2,,void
76882,BLOCK,-1,,<empty>,7,,726,1,,void
76892,BLOCK,4,,"{
        std::string v;
        Add(test::RandomKey(&rnd, rnd.Skewed(4)),
            test::RandomString(&rnd, rnd.Skewed(5), &v).ToString());
      }",45,,726,4,,void
76929,BLOCK,-1,,<empty>,,,,1,,<empty>
76933,BLOCK,-1,,"TEST(Harness, RandomizedLongDB)",1,,736,1,,void
76957,BLOCK,-1,,"{
  Random rnd(test::RandomSeed());
  TestArgs args = { DB_TEST, false, 16 };
  Init(args);
  int num_entries = 100000;
  for (int e = 0; e < num_entries; e++) {
    std::string v;
    Add(test::RandomKey(&rnd, rnd.Skewed(4)),
        test::RandomString(&rnd, rnd.Skewed(5), &v).ToString());
  }
  Test(&rnd);

  // We must have created enough data to force merging
  int files = 0;
  for (int level = 0; level < config::kNumLevels; level++) {
    std::string value;
    char name[100];
    snprintf(name, sizeof(name), ""leveldb.num-files-at-level%d"", level);
    ASSERT_TRUE(db()->GetProperty(name, &value));
    files += atoi(value.c_str());
  }
  ASSERT_GT(files, 0);
}",33,,736,1,,void
76978,BLOCK,-1,,<empty>,3,,741,1,,void
76988,BLOCK,4,,"{
    std::string v;
    Add(test::RandomKey(&rnd, rnd.Skewed(4)),
        test::RandomString(&rnd, rnd.Skewed(5), &v).ToString());
  }",41,,741,4,,void
77026,BLOCK,-1,,<empty>,3,,750,1,,void
77038,BLOCK,4,,"{
    std::string value;
    char name[100];
    snprintf(name, sizeof(name), ""leveldb.num-files-at-level%d"", level);
    ASSERT_TRUE(db()->GetProperty(name, &value));
    files += atoi(value.c_str());
  }",60,,750,4,,void
77048,BLOCK,1,,<empty>,,,,3,,void
77078,BLOCK,1,,<empty>,,,,4,,void
77097,BLOCK,-1,,<empty>,,,,1,,<empty>
77101,BLOCK,-1,,"TEST(MemTableTest, Simple)",1,,762,1,,void
77125,BLOCK,-1,,"{
  InternalKeyComparator cmp(BytewiseComparator());
  MemTable* memtable = new MemTable(cmp);
  memtable->Ref();
  WriteBatch batch;
  WriteBatchInternal::SetSequence(&batch, 100);
  batch.Put(std::string(""k1""), std::string(""v1""));
  batch.Put(std::string(""k2""), std::string(""v2""));
  batch.Put(std::string(""k3""), std::string(""v3""));
  batch.Put(std::string(""largekey""), std::string(""vlarge""));
  ASSERT_TRUE(WriteBatchInternal::InsertInto(&batch, memtable).ok());

  Iterator* iter = memtable->NewIterator();
  iter->SeekToFirst();
  while (iter->Valid()) {
    fprintf(stderr, ""key: '%s' -> '%s'\n"",
            iter->key().ToString().c_str(),
            iter->value().ToString().c_str());
    iter->Next();
  }

  delete iter;
  memtable->Unref();
}",28,,762,1,,void
77204,BLOCK,1,,<empty>,,,,3,,void
77243,BLOCK,-1,,"{
    fprintf(stderr, ""key: '%s' -> '%s'\n"",
            iter->key().ToString().c_str(),
            iter->value().ToString().c_str());
    iter->Next();
  }",25,,776,2,,void
77283,BLOCK,-1,,"{
  bool result = (val >= low) && (val <= high);
  if (!result) {
    fprintf(stderr, ""Value %llu is not in range [%llu, %llu]\n"",
            (unsigned long long)(val),
            (unsigned long long)(low),
            (unsigned long long)(high));
  }
  return result;
}",64,,787,4,,void
77297,BLOCK,-1,,"{
    fprintf(stderr, ""Value %llu is not in range [%llu, %llu]\n"",
            (unsigned long long)(val),
            (unsigned long long)(low),
            (unsigned long long)(high));
  }",16,,789,2,,void
77317,BLOCK,-1,,<empty>,,,,1,,<empty>
77321,BLOCK,-1,,"TEST(TableTest, ApproximateOffsetOfPlain)",1,,800,1,,void
77345,BLOCK,-1,,"{
  TableConstructor c(BytewiseComparator());
  c.Add(""k01"", ""hello"");
  c.Add(""k02"", ""hello2"");
  c.Add(""k03"", std::string(10000, 'x'));
  c.Add(""k04"", std::string(200000, 'x'));
  c.Add(""k05"", std::string(300000, 'x'));
  c.Add(""k06"", ""hello3"");
  c.Add(""k07"", std::string(100000, 'x'));
  std::vector<std::string> keys;
  KVMap kvmap;
  Options options;
  options.block_size = 1024;
  options.compression = kNoCompression;
  c.Finish(options, &keys, &kvmap);

  ASSERT_TRUE(Between(c.ApproximateOffsetOf(""abc""),       0,      0));
  ASSERT_TRUE(Between(c.ApproximateOffsetOf(""k01""),       0,      0));
  ASSERT_TRUE(Between(c.ApproximateOffsetOf(""k01a""),      0,      0));
  ASSERT_TRUE(Between(c.ApproximateOffsetOf(""k02""),       0,      0));
  ASSERT_TRUE(Between(c.ApproximateOffsetOf(""k03""),       0,      0));
  ASSERT_TRUE(Between(c.ApproximateOffsetOf(""k04""),   10000,  11000));
  ASSERT_TRUE(Between(c.ApproximateOffsetOf(""k04a""), 210000, 211000));
  ASSERT_TRUE(Between(c.ApproximateOf...",43,,800,1,,void
77442,BLOCK,1,,<empty>,,,,2,,void
77464,BLOCK,1,,<empty>,,,,2,,void
77486,BLOCK,1,,<empty>,,,,2,,void
77508,BLOCK,1,,<empty>,,,,2,,void
77530,BLOCK,1,,<empty>,,,,2,,void
77552,BLOCK,1,,<empty>,,,,2,,void
77574,BLOCK,1,,<empty>,,,,2,,void
77596,BLOCK,1,,<empty>,,,,2,,void
77618,BLOCK,1,,<empty>,,,,2,,void
77640,BLOCK,1,,<empty>,,,,2,,void
77662,BLOCK,1,,<empty>,,,,2,,void
77686,BLOCK,-1,,"{
  std::string out;
  Slice in = ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"";
  return port::Snappy_Compress(in.data(), in.size(), &out);
}",42,,830,1,,void
77711,BLOCK,-1,,<empty>,,,,1,,<empty>
77715,BLOCK,-1,,"TEST(TableTest, ApproximateOffsetOfCompressed)",1,,836,1,,void
77739,BLOCK,-1,,"{
  if (!SnappyCompressionSupported()) {
    fprintf(stderr, ""skipping compression tests\n"");
    return;
  }

  Random rnd(301);
  TableConstructor c(BytewiseComparator());
  std::string tmp;
  c.Add(""k01"", ""hello"");
  c.Add(""k02"", test::CompressibleString(&rnd, 0.25, 10000, &tmp));
  c.Add(""k03"", ""hello3"");
  c.Add(""k04"", test::CompressibleString(&rnd, 0.25, 10000, &tmp));
  std::vector<std::string> keys;
  KVMap kvmap;
  Options options;
  options.block_size = 1024;
  options.compression = kSnappyCompression;
  c.Finish(options, &keys, &kvmap);

  // Expected upper and lower bounds of space used by compressible strings.
  static const int kSlop = 1000;  // Compressor effectiveness varies.
  const int expected = 2500;  // 10000 * compression ratio (0.25)
  const int min_z = expected - kSlop;
  const int max_z = expected + kSlop;

  ASSERT_TRUE(Between(c.ApproximateOffsetOf(""abc""), 0, kSlop));
  ASSERT_TRUE(Between(c.ApproximateOffsetOf(""k01""), 0, kSlop));
  ASSERT_TRUE(Between(c.A...",48,,836,1,,void
77743,BLOCK,-1,,"{
    fprintf(stderr, ""skipping compression tests\n"");
    return;
  }",38,,837,2,,void
77848,BLOCK,1,,<empty>,,,,3,,void
77870,BLOCK,1,,<empty>,,,,3,,void
77892,BLOCK,1,,<empty>,,,,3,,void
77914,BLOCK,1,,<empty>,,,,4,,void
77936,BLOCK,1,,<empty>,,,,4,,void
77958,BLOCK,1,,<empty>,,,,4,,void
77988,BLOCK,-1,,"{
  return leveldb::test::RunAllTests();
}",33,,874,3,,void
78012,BLOCK,-1,,<empty>,1,,1,1,,ANY
78019,BLOCK,-1,,<empty>,,,,4,,<empty>
78028,BLOCK,-1,,<empty>,,,,5,,<empty>
78032,BLOCK,-1,,<empty>,,,,1,,<empty>
78037,BLOCK,-1,,<empty>,,,,2,,<empty>
78041,BLOCK,-1,,<empty>,,,,1,,<empty>
78045,BLOCK,-1,,<empty>,,,,1,,<empty>
78049,BLOCK,-1,,<empty>,,,,1,,<empty>
78053,BLOCK,-1,,<empty>,,,,1,,<empty>
78057,BLOCK,-1,,"{
    return data_iter_.Valid();
  }",30,,34,1,,void
78066,BLOCK,-1,,"{
    assert(Valid());
    return data_iter_.key();
  }",29,,37,1,,void
78077,BLOCK,-1,,"{
    assert(Valid());
    return data_iter_.value();
  }",31,,41,1,,void
78088,BLOCK,-1,,"{
    // It'd be nice if status() returned a const Status& instead of a Status
    if (!index_iter_.status().ok()) {
      return index_iter_.status();
    } else if (data_iter_.iter() != NULL && !data_iter_.status().ok()) {
      return data_iter_.status();
    } else {
      return status_;
    }
  }",33,,45,1,,void
78098,BLOCK,-1,,"{
      return index_iter_.status();
    }",37,,47,2,,void
78105,BLOCK,-1,,<empty>,12,,49,1,,void
78122,BLOCK,-1,,"{
      return data_iter_.status();
    }",72,,49,2,,void
78129,BLOCK,-1,,"{
      return status_;
    }",12,,51,1,,void
78136,BLOCK,-1,,"{
    if (status_.ok() && !s.ok()) status_ = s;
  }",35,,57,2,,void
78148,BLOCK,-1,,<empty>,34,,58,2,,void
78155,BLOCK,-1,,<empty>,,,,1,,<empty>
78159,BLOCK,-1,,<empty>,,,,1,,<empty>
78164,BLOCK,-1,,<empty>,,,,2,,<empty>
78168,BLOCK,-1,,<empty>,,,,1,,<empty>
78183,BLOCK,-1,,"{
}",24,,85,5,,void
78187,BLOCK,-1,,"{
}",39,,88,1,,void
78192,BLOCK,-1,,"{
  index_iter_.Seek(target);
  InitDataBlock();
  if (data_iter_.iter() != NULL) data_iter_.Seek(target);
  SkipEmptyDataBlocksForward();
}",50,,91,2,,void
78206,BLOCK,-1,,<empty>,34,,94,2,,void
78216,BLOCK,-1,,"{
  index_iter_.SeekToFirst();
  InitDataBlock();
  if (data_iter_.iter() != NULL) data_iter_.SeekToFirst();
  SkipEmptyDataBlocksForward();
}",38,,98,1,,void
78229,BLOCK,-1,,<empty>,34,,101,2,,void
78238,BLOCK,-1,,"{
  index_iter_.SeekToLast();
  InitDataBlock();
  if (data_iter_.iter() != NULL) data_iter_.SeekToLast();
  SkipEmptyDataBlocksBackward();
}",37,,105,1,,void
78251,BLOCK,-1,,<empty>,34,,108,2,,void
78260,BLOCK,-1,,"{
  assert(Valid());
  data_iter_.Next();
  SkipEmptyDataBlocksForward();
}",31,,112,1,,void
78271,BLOCK,-1,,"{
  assert(Valid());
  data_iter_.Prev();
  SkipEmptyDataBlocksBackward();
}",31,,118,1,,void
78282,BLOCK,-1,,"{
  while (data_iter_.iter() == NULL || !data_iter_.Valid()) {
    // Move to next block
    if (!index_iter_.Valid()) {
      SetDataIterator(NULL);
      return;
    }
    index_iter_.Next();
    InitDataBlock();
    if (data_iter_.iter() != NULL) data_iter_.SeekToFirst();
  }
}",53,,125,1,,void
78296,BLOCK,-1,,"{
    // Move to next block
    if (!index_iter_.Valid()) {
      SetDataIterator(NULL);
      return;
    }
    index_iter_.Next();
    InitDataBlock();
    if (data_iter_.iter() != NULL) data_iter_.SeekToFirst();
  }",60,,126,2,,void
78303,BLOCK,-1,,"{
      SetDataIterator(NULL);
      return;
    }",31,,128,2,,void
78318,BLOCK,-1,,<empty>,36,,134,2,,void
78326,BLOCK,-1,,"{
  while (data_iter_.iter() == NULL || !data_iter_.Valid()) {
    // Move to next block
    if (!index_iter_.Valid()) {
      SetDataIterator(NULL);
      return;
    }
    index_iter_.Prev();
    InitDataBlock();
    if (data_iter_.iter() != NULL) data_iter_.SeekToLast();
  }
}",54,,138,1,,void
78340,BLOCK,-1,,"{
    // Move to next block
    if (!index_iter_.Valid()) {
      SetDataIterator(NULL);
      return;
    }
    index_iter_.Prev();
    InitDataBlock();
    if (data_iter_.iter() != NULL) data_iter_.SeekToLast();
  }",60,,139,2,,void
78347,BLOCK,-1,,"{
      SetDataIterator(NULL);
      return;
    }",31,,141,2,,void
78362,BLOCK,-1,,<empty>,36,,147,2,,void
78371,BLOCK,-1,,"{
  if (data_iter_.iter() != NULL) SaveError(data_iter_.status());
  data_iter_.Set(data_iter);
}",61,,151,2,,void
78379,BLOCK,-1,,<empty>,34,,152,2,,void
78393,BLOCK,-1,,"{
  if (!index_iter_.Valid()) {
    SetDataIterator(NULL);
  } else {
    Slice handle = index_iter_.value();
    if (data_iter_.iter() != NULL && handle.compare(data_block_handle_) == 0) {
      // data_iter_ is already constructed with this iterator, so
      // no need to change anything
    } else {
      Iterator* iter = (*block_function_)(arg_, options_, handle);
      data_block_handle_.assign(handle.data(), handle.size());
      SetDataIterator(iter);
    }
  }
}",40,,156,1,,void
78400,BLOCK,-1,,"{
    SetDataIterator(NULL);
  }",29,,157,2,,void
78403,BLOCK,-1,,"{
    Slice handle = index_iter_.value();
    if (data_iter_.iter() != NULL && handle.compare(data_block_handle_) == 0) {
      // data_iter_ is already constructed with this iterator, so
      // no need to change anything
    } else {
      Iterator* iter = (*block_function_)(arg_, options_, handle);
      data_block_handle_.assign(handle.data(), handle.size());
      SetDataIterator(iter);
    }
  }",10,,159,1,,void
78426,BLOCK,-1,,"{
      // data_iter_ is already constructed with this iterator, so
      // no need to change anything
    }",79,,161,2,,void
78428,BLOCK,-1,,"{
      Iterator* iter = (*block_function_)(arg_, options_, handle);
      data_block_handle_.assign(handle.data(), handle.size());
      SetDataIterator(iter);
    }",12,,164,1,,void
78459,BLOCK,-1,,"{
  return new TwoLevelIterator(index_iter, block_function, arg, options);
}",33,,178,5,,void
78475,BLOCK,-1,,<empty>,1,,1,1,,ANY
78483,BLOCK,-1,,<empty>,,,,5,,<empty>
78494,BLOCK,-1,,<empty>,1,,1,1,,ANY
78501,BLOCK,-1,,"{
  alloc_ptr_ = NULL;  // First allocation will allocate a block
  alloc_bytes_remaining_ = 0;
}",35,,12,1,,void
78511,BLOCK,-1,,"{
  for (size_t i = 0; i < blocks_.size(); i++) {
    delete[] blocks_[i];
  }
}",17,,17,1,,void
78513,BLOCK,-1,,<empty>,3,,18,1,,void
78526,BLOCK,4,,"{
    delete[] blocks_[i];
  }",47,,18,4,,void
78535,BLOCK,-1,,"{
  if (bytes > kBlockSize / 4) {
    // Object is more than a quarter of our block size.  Allocate it separately
    // to avoid wasting too much space in leftover bytes.
    char* result = AllocateNewBlock(bytes);
    return result;
  }

  // We waste the remaining space in the current block.
  alloc_ptr_ = AllocateNewBlock(kBlockSize);
  alloc_bytes_remaining_ = kBlockSize;

  char* result = alloc_ptr_;
  alloc_ptr_ += bytes;
  alloc_bytes_remaining_ -= bytes;
  return result;
}",45,,23,2,,void
78542,BLOCK,-1,,"{
    // Object is more than a quarter of our block size.  Allocate it separately
    // to avoid wasting too much space in leftover bytes.
    char* result = AllocateNewBlock(bytes);
    return result;
  }",31,,24,2,,void
78573,BLOCK,-1,,"{
  const int align = (sizeof(void*) > 8) ? sizeof(void*) : 8;
  assert((align & (align-1)) == 0);   // Pointer size should be a power of 2
  size_t current_mod = reinterpret_cast<uintptr_t>(alloc_ptr_) & (align-1);
  size_t slop = (current_mod == 0 ? 0 : align - current_mod);
  size_t needed = bytes + slop;
  char* result;
  if (needed <= alloc_bytes_remaining_) {
    result = alloc_ptr_ + slop;
    alloc_ptr_ += needed;
    alloc_bytes_remaining_ -= needed;
  } else {
    // AllocateFallback always returned aligned memory
    result = AllocateFallback(bytes);
  }
  assert((reinterpret_cast<uintptr_t>(result) & (align-1)) == 0);
  return result;
}",44,,41,2,,void
78625,BLOCK,-1,,"{
    result = alloc_ptr_ + slop;
    alloc_ptr_ += needed;
    alloc_bytes_remaining_ -= needed;
  }",41,,48,2,,void
78638,BLOCK,-1,,"{
    // AllocateFallback always returned aligned memory
    result = AllocateFallback(bytes);
  }",10,,52,1,,void
78659,BLOCK,-1,,"{
  char* result = new char[block_bytes];
  blocks_.push_back(result);
  memory_usage_.NoBarrier_Store(
      reinterpret_cast<void*>(MemoryUsage() + block_bytes + sizeof(char*)));
  return result;
}",51,,60,2,,void
78700,BLOCK,-1,,<empty>,1,,1,1,,ANY
78704,BLOCK,-1,,<empty>,,,,1,,<empty>
78708,BLOCK,-1,,<empty>,,,,1,,<empty>
78713,BLOCK,-1,,<empty>,,,,2,,<empty>
78718,BLOCK,-1,,<empty>,,,,2,,<empty>
78722,BLOCK,-1,,"{
    return reinterpret_cast<uintptr_t>(memory_usage_.NoBarrier_Load());
  }",30,,29,1,,void
78734,BLOCK,-1,,<empty>,,,,2,,<empty>
78739,BLOCK,-1,,<empty>,,,,2,,<empty>
78748,BLOCK,-1,,<empty>,,,,2,,<empty>
78753,BLOCK,-1,,<empty>,,,,2,,<empty>
78758,BLOCK,-1,,"{
  // The semantics of what to return are a bit messy if we allow
  // 0-byte allocations, so we disallow them here (we don't need
  // them for our internal use).
  assert(bytes > 0);
  if (bytes <= alloc_bytes_remaining_) {
    char* result = alloc_ptr_;
    alloc_ptr_ += bytes;
    alloc_bytes_remaining_ -= bytes;
    return result;
  }
  return AllocateFallback(bytes);
}",44,,52,2,,void
78767,BLOCK,-1,,"{
    char* result = alloc_ptr_;
    alloc_ptr_ += bytes;
    alloc_bytes_remaining_ -= bytes;
    return result;
  }",40,,57,2,,void
78795,BLOCK,-1,,<empty>,1,,1,1,,ANY
78800,BLOCK,-1,,<empty>,,,,1,,<empty>
78804,BLOCK,-1,,"TEST(ArenaTest, Empty)",1,,14,1,,void
78828,BLOCK,-1,,"{
  Arena arena;
}",24,,14,1,,void
78834,BLOCK,-1,,<empty>,,,,1,,<empty>
78838,BLOCK,-1,,"TEST(ArenaTest, Simple)",1,,18,1,,void
78862,BLOCK,-1,,"{
  std::vector<std::pair<size_t, char*> > allocated;
  Arena arena;
  const int N = 100000;
  size_t bytes = 0;
  Random rnd(301);
  for (int i = 0; i < N; i++) {
    size_t s;
    if (i % (N / 10) == 0) {
      s = i;
    } else {
      s = rnd.OneIn(4000) ? rnd.Uniform(6000) :
          (rnd.OneIn(10) ? rnd.Uniform(100) : rnd.Uniform(20));
    }
    if (s == 0) {
      // Our arena disallows size 0 allocations.
      s = 1;
    }
    char* r;
    if (rnd.OneIn(10)) {
      r = arena.AllocateAligned(s);
    } else {
      r = arena.Allocate(s);
    }

    for (size_t b = 0; b < s; b++) {
      // Fill the ""i""th allocation with a known bit pattern
      r[b] = i % 256;
    }
    bytes += s;
    allocated.push_back(std::make_pair(s, r));
    ASSERT_GE(arena.MemoryUsage(), bytes);
    if (i > N/10) {
      ASSERT_LE(arena.MemoryUsage(), bytes * 1.10);
    }
  }
  for (size_t i = 0; i < allocated.size(); i++) {
    size_t num_bytes = allocated[i].first;
    const char* p = allocated[i...",25,,18,1,,void
78885,BLOCK,-1,,<empty>,3,,24,1,,void
78895,BLOCK,4,,"{
    size_t s;
    if (i % (N / 10) == 0) {
      s = i;
    } else {
      s = rnd.OneIn(4000) ? rnd.Uniform(6000) :
          (rnd.OneIn(10) ? rnd.Uniform(100) : rnd.Uniform(20));
    }
    if (s == 0) {
      // Our arena disallows size 0 allocations.
      s = 1;
    }
    char* r;
    if (rnd.OneIn(10)) {
      r = arena.AllocateAligned(s);
    } else {
      r = arena.Allocate(s);
    }

    for (size_t b = 0; b < s; b++) {
      // Fill the ""i""th allocation with a known bit pattern
      r[b] = i % 256;
    }
    bytes += s;
    allocated.push_back(std::make_pair(s, r));
    ASSERT_GE(arena.MemoryUsage(), bytes);
    if (i > N/10) {
      ASSERT_LE(arena.MemoryUsage(), bytes * 1.10);
    }
  }",31,,24,4,,void
78905,BLOCK,-1,,"{
      s = i;
    }",28,,26,2,,void
78910,BLOCK,-1,,"{
      s = rnd.OneIn(4000) ? rnd.Uniform(6000) :
          (rnd.OneIn(10) ? rnd.Uniform(100) : rnd.Uniform(20));
    }",12,,28,1,,void
78944,BLOCK,-1,,"{
      // Our arena disallows size 0 allocations.
      s = 1;
    }",17,,32,2,,void
78955,BLOCK,-1,,"{
      r = arena.AllocateAligned(s);
    }",24,,37,2,,void
78964,BLOCK,-1,,"{
      r = arena.Allocate(s);
    }",12,,39,1,,void
78973,BLOCK,-1,,<empty>,5,,43,1,,void
78983,BLOCK,4,,"{
      // Fill the ""i""th allocation with a known bit pattern
      r[b] = i % 256;
    }",36,,43,4,,void
79010,BLOCK,1,,<empty>,,,,5,,void
79033,BLOCK,-1,,"{
      ASSERT_LE(arena.MemoryUsage(), bytes * 1.10);
    }",19,,50,2,,void
79039,BLOCK,1,,<empty>,,,,4,,void
79059,BLOCK,-1,,<empty>,3,,54,1,,void
79072,BLOCK,4,,"{
    size_t num_bytes = allocated[i].first;
    const char* p = allocated[i].second;
    for (size_t b = 0; b < num_bytes; b++) {
      // Check the ""i""th allocation for the known bit pattern
      ASSERT_EQ(int(p[b]) & 0xff, i % 256);
    }
  }",49,,54,4,,void
79090,BLOCK,-1,,<empty>,5,,57,1,,void
79100,BLOCK,4,,"{
      // Check the ""i""th allocation for the known bit pattern
      ASSERT_EQ(int(p[b]) & 0xff, i % 256);
    }",44,,57,4,,void
79102,BLOCK,1,,<empty>,,,,2,,void
79129,BLOCK,-1,,"{
  return leveldb::test::RunAllTests();
}",33,,66,3,,void
79149,BLOCK,-1,,<empty>,1,,1,1,,ANY
79154,BLOCK,-1,,"{
  return Hash(key.data(), key.size(), 0xbc9f1d34);
}",45,,13,2,,void
79173,BLOCK,-1,,"{
    // We intentionally round down to reduce probing cost a little bit
    k_ = static_cast<size_t>(bits_per_key * 0.69);  // 0.69 =~ ln(2)
    if (k_ < 1) k_ = 1;
    if (k_ > 30) k_ = 30;
  }",37,,24,2,,void
79185,BLOCK,-1,,<empty>,17,,27,2,,void
79193,BLOCK,-1,,<empty>,18,,28,2,,void
79200,BLOCK,-1,,"{
    return ""leveldb.BuiltinBloomFilter2"";
  }",36,,31,1,,void
79209,BLOCK,-1,,"{
    // Compute bloom filter size (in both bits and bytes)
    size_t bits = n * bits_per_key_;

    // For small n, we can see a very high false positive rate.  Fix it
    // by enforcing a minimum bloom filter length.
    if (bits < 64) bits = 64;

    size_t bytes = (bits + 7) / 8;
    bits = bytes * 8;

    const size_t init_size = dst->size();
    dst->resize(init_size + bytes, 0);
    dst->push_back(static_cast<char>(k_));  // Remember # of probes in filter
    char* array = &(*dst)[init_size];
    for (int i = 0; i < n; i++) {
      // Use double-hashing to generate a sequence of hash values.
      // See analysis in [Kirsch,Mitzenmacher 2006].
      uint32_t h = BloomHash(keys[i]);
      const uint32_t delta = (h >> 17) | (h << 15);  // Rotate right 17 bits
      for (size_t j = 0; j < k_; j++) {
        const uint32_t bitpos = h % bits;
        array[bitpos/8] |= (1 << (bitpos % 8));
        h += delta;
      }
    }
  }",79,,35,4,,void
79220,BLOCK,-1,,<empty>,20,,41,2,,void
79268,BLOCK,-1,,<empty>,5,,50,1,,void
79278,BLOCK,4,,"{
      // Use double-hashing to generate a sequence of hash values.
      // See analysis in [Kirsch,Mitzenmacher 2006].
      uint32_t h = BloomHash(keys[i]);
      const uint32_t delta = (h >> 17) | (h << 15);  // Rotate right 17 bits
      for (size_t j = 0; j < k_; j++) {
        const uint32_t bitpos = h % bits;
        array[bitpos/8] |= (1 << (bitpos % 8));
        h += delta;
      }
    }",33,,50,4,,void
79297,BLOCK,-1,,<empty>,7,,55,1,,void
79307,BLOCK,4,,"{
        const uint32_t bitpos = h % bits;
        array[bitpos/8] |= (1 << (bitpos % 8));
        h += delta;
      }",39,,55,4,,void
79333,BLOCK,-1,,"{
    const size_t len = bloom_filter.size();
    if (len < 2) return false;

    const char* array = bloom_filter.data();
    const size_t bits = (len - 1) * 8;

    // Use the encoded k so that we can read filters generated by
    // bloom filters created using different parameters.
    const size_t k = array[len-1];
    if (k > 30) {
      // Reserved for potentially new encodings for short bloom filters.
      // Consider it a match.
      return true;
    }

    uint32_t h = BloomHash(key);
    const uint32_t delta = (h >> 17) | (h << 15);  // Rotate right 17 bits
    for (size_t j = 0; j < k; j++) {
      const uint32_t bitpos = h % bits;
      if ((array[bitpos/8] & (1 << (bitpos % 8))) == 0) return false;
      h += delta;
    }
    return true;
  }",79,,63,3,,void
79345,BLOCK,-1,,<empty>,18,,65,2,,void
79375,BLOCK,-1,,"{
      // Reserved for potentially new encodings for short bloom filters.
      // Consider it a match.
      return true;
    }",17,,73,2,,void
79394,BLOCK,-1,,<empty>,5,,81,1,,void
79404,BLOCK,4,,"{
      const uint32_t bitpos = h % bits;
      if ((array[bitpos/8] & (1 << (bitpos % 8))) == 0) return false;
      h += delta;
    }",36,,81,4,,void
79425,BLOCK,-1,,<empty>,57,,83,2,,void
79437,BLOCK,-1,,"{
  return new BloomFilterPolicy(bits_per_key);
}",60,,91,2,,void
79458,BLOCK,-1,,<empty>,1,,1,1,,ANY
79467,BLOCK,-1,,"{
  EncodeFixed32(buffer, i);
  return Slice(buffer, sizeof(uint32_t));
}",39,,16,3,,void
79483,BLOCK,-1,,{ },51,,28,1,,void
79487,BLOCK,-1,,"{
    delete policy_;
  }",16,,30,1,,void
79493,BLOCK,-1,,"{
    keys_.clear();
    filter_.clear();
  }",16,,34,1,,void
79506,BLOCK,-1,,"{
    keys_.push_back(s.ToString());
  }",28,,39,2,,void
79518,BLOCK,-1,,"{
    std::vector<Slice> key_slices;
    for (size_t i = 0; i < keys_.size(); i++) {
      key_slices.push_back(Slice(keys_[i]));
    }
    filter_.clear();
    policy_->CreateFilter(&key_slices[0], static_cast<int>(key_slices.size()),
                          &filter_);
    keys_.clear();
    if (kVerbose >= 2) DumpFilter();
  }",16,,43,1,,void
79521,BLOCK,-1,,<empty>,5,,45,1,,void
79534,BLOCK,4,,"{
      key_slices.push_back(Slice(keys_[i]));
    }",47,,45,4,,void
79571,BLOCK,-1,,<empty>,24,,52,2,,void
79576,BLOCK,-1,,"{
    return filter_.size();
  }",29,,55,1,,void
79585,BLOCK,-1,,"{
    fprintf(stderr, ""F("");
    for (size_t i = 0; i+1 < filter_.size(); i++) {
      const unsigned int c = static_cast<unsigned int>(filter_[i]);
      for (int j = 0; j < 8; j++) {
        fprintf(stderr, ""%c"", (c & (1 <<j)) ? '1' : '.');
      }
    }
    fprintf(stderr, "")\n"");
  }",21,,59,1,,void
79590,BLOCK,-1,,<empty>,5,,61,1,,void
79605,BLOCK,4,,"{
      const unsigned int c = static_cast<unsigned int>(filter_[i]);
      for (int j = 0; j < 8; j++) {
        fprintf(stderr, ""%c"", (c & (1 <<j)) ? '1' : '.');
      }
    }",51,,61,4,,void
79615,BLOCK,-1,,<empty>,7,,63,1,,void
79625,BLOCK,4,,"{
        fprintf(stderr, ""%c"", (c & (1 <<j)) ? '1' : '.');
      }",35,,63,4,,void
79644,BLOCK,-1,,"{
    if (!keys_.empty()) {
      Build();
    }
    return policy_->KeyMayMatch(s, filter_);
  }",32,,70,2,,void
79651,BLOCK,-1,,"{
      Build();
    }",25,,71,2,,void
79663,BLOCK,-1,,"{
    char buffer[sizeof(int)];
    int result = 0;
    for (int i = 0; i < 10000; i++) {
      if (Matches(Key(i + 1000000000, buffer))) {
        result++;
      }
    }
    return result / 10000.0;
  }",30,,77,1,,void
79670,BLOCK,-1,,<empty>,5,,80,1,,void
79680,BLOCK,4,,"{
      if (Matches(Key(i + 1000000000, buffer))) {
        result++;
      }
    }",37,,80,4,,void
79688,BLOCK,-1,,"{
        result++;
      }",49,,81,2,,void
79699,BLOCK,-1,,<empty>,,,,1,,<empty>
79703,BLOCK,-1,,"TEST(BloomTest, EmptyFilter)",1,,89,1,,void
79727,BLOCK,-1,,"{
  ASSERT_TRUE(! Matches(""hello""));
  ASSERT_TRUE(! Matches(""world""));
}",30,,89,1,,void
79732,BLOCK,1,,<empty>,,,,2,,void
79752,BLOCK,1,,<empty>,,,,2,,void
79772,BLOCK,-1,,<empty>,,,,1,,<empty>
79776,BLOCK,-1,,"TEST(BloomTest, Small)",1,,94,1,,void
79800,BLOCK,-1,,"{
  Add(""hello"");
  Add(""world"");
  ASSERT_TRUE(Matches(""hello""));
  ASSERT_TRUE(Matches(""world""));
  ASSERT_TRUE(! Matches(""x""));
  ASSERT_TRUE(! Matches(""foo""));
}",24,,94,1,,void
79808,BLOCK,1,,<empty>,,,,2,,void
79826,BLOCK,1,,<empty>,,,,2,,void
79845,BLOCK,1,,<empty>,,,,2,,void
79865,BLOCK,1,,<empty>,,,,2,,void
79885,BLOCK,-1,,"{
  if (length < 10) {
    length += 1;
  } else if (length < 100) {
    length += 10;
  } else if (length < 1000) {
    length += 100;
  } else {
    length += 1000;
  }
  return length;
}",35,,103,2,,void
79890,BLOCK,-1,,"{
    length += 1;
  }",20,,104,2,,void
79895,BLOCK,-1,,<empty>,10,,106,1,,void
79900,BLOCK,-1,,"{
    length += 10;
  }",28,,106,2,,void
79905,BLOCK,-1,,<empty>,10,,108,1,,void
79910,BLOCK,-1,,"{
    length += 100;
  }",29,,108,2,,void
79915,BLOCK,-1,,"{
    length += 1000;
  }",10,,110,1,,void
79925,BLOCK,-1,,<empty>,,,,1,,<empty>
79929,BLOCK,-1,,"TEST(BloomTest, VaryingLengths)",1,,116,1,,void
79953,BLOCK,-1,,"{
  char buffer[sizeof(int)];

  // Count number of filters that significantly exceed the false positive rate
  int mediocre_filters = 0;
  int good_filters = 0;

  for (int length = 1; length <= 10000; length = NextLength(length)) {
    Reset();
    for (int i = 0; i < length; i++) {
      Add(Key(i, buffer));
    }
    Build();

    ASSERT_LE(FilterSize(), static_cast<size_t>((length * 10 / 8) + 40))
        << length;

    // All added keys must match
    for (int i = 0; i < length; i++) {
      ASSERT_TRUE(Matches(Key(i, buffer)))
          << ""Length "" << length << ""; key "" << i;
    }

    // Check false positive rate
    double rate = FalsePositiveRate();
    if (kVerbose >= 1) {
      fprintf(stderr, ""False positives: %5.2f%% @ length = %6d ; bytes = %6d\n"",
              rate*100.0, length, static_cast<int>(FilterSize()));
    }
    ASSERT_LE(rate, 0.02);   // Must not be over 2%
    if (rate > 0.0125) mediocre_filters++;  // Allowed, but not too often
    else good_filters...",33,,116,1,,void
79964,BLOCK,-1,,<empty>,3,,123,1,,void
79976,BLOCK,4,,"{
    Reset();
    for (int i = 0; i < length; i++) {
      Add(Key(i, buffer));
    }
    Build();

    ASSERT_LE(FilterSize(), static_cast<size_t>((length * 10 / 8) + 40))
        << length;

    // All added keys must match
    for (int i = 0; i < length; i++) {
      ASSERT_TRUE(Matches(Key(i, buffer)))
          << ""Length "" << length << ""; key "" << i;
    }

    // Check false positive rate
    double rate = FalsePositiveRate();
    if (kVerbose >= 1) {
      fprintf(stderr, ""False positives: %5.2f%% @ length = %6d ; bytes = %6d\n"",
              rate*100.0, length, static_cast<int>(FilterSize()));
    }
    ASSERT_LE(rate, 0.02);   // Must not be over 2%
    if (rate > 0.0125) mediocre_filters++;  // Allowed, but not too often
    else good_filters++;
  }",70,,123,4,,void
79979,BLOCK,-1,,<empty>,5,,125,1,,void
79989,BLOCK,4,,"{
      Add(Key(i, buffer));
    }",38,,125,4,,void
79998,BLOCK,1,,<empty>,,,,2,,void
80022,BLOCK,-1,,<empty>,5,,134,1,,void
80032,BLOCK,4,,"{
      ASSERT_TRUE(Matches(Key(i, buffer)))
          << ""Length "" << length << ""; key "" << i;
    }",38,,134,4,,void
80038,BLOCK,1,,<empty>,,,,2,,void
80067,BLOCK,-1,,"{
      fprintf(stderr, ""False positives: %5.2f%% @ length = %6d ; bytes = %6d\n"",
              rate*100.0, length, static_cast<int>(FilterSize()));
    }",24,,141,2,,void
80081,BLOCK,1,,<empty>,,,,4,,void
80099,BLOCK,-1,,<empty>,24,,146,2,,void
80103,BLOCK,-1,,<empty>,10,,147,1,,void
80110,BLOCK,-1,,"{
    fprintf(stderr, ""Filters: %d good, %d mediocre\n"",
            good_filters, mediocre_filters);
  }",22,,149,2,,void
80118,BLOCK,1,,<empty>,,,,4,,void
80139,BLOCK,-1,,"{
  return leveldb::test::RunAllTests();
}",33,,160,3,,void
80167,BLOCK,-1,,<empty>,1,,1,1,,ANY
80170,BLOCK,-1,,"{
}",17,,16,1,,void
80179,BLOCK,-1,,<empty>,,,,3,,<empty>
80192,BLOCK,-1,,"{
    // For cheaper lookups, we allow a temporary Handle object
    // to store a pointer to a key in ""value"".
    if (next == this) {
      return *(reinterpret_cast<Slice*>(value));
    } else {
      return Slice(key_data, key_length);
    }
  }",21,,55,1,,void
80197,BLOCK,-1,,"{
      return *(reinterpret_cast<Slice*>(value));
    }",23,,58,2,,void
80204,BLOCK,-1,,"{
      return Slice(key_data, key_length);
    }",12,,60,1,,void
80212,BLOCK,-1,,<empty>,,,,1,,<empty>
80219,BLOCK,-1,,{ Resize(); },54,,73,1,,void
80224,BLOCK,-1,,{ delete[] list_; },18,,74,1,,void
80232,BLOCK,-1,,"{
    return *FindPointer(key, hash);
  }",54,,76,3,,void
80242,BLOCK,-1,,"{
    LRUHandle** ptr = FindPointer(h->key(), h->hash);
    LRUHandle* old = *ptr;
    h->next_hash = (old == NULL ? NULL : old->next_hash);
    *ptr = h;
    if (old == NULL) {
      ++elems_;
      if (elems_ > length_) {
        // Since each cache entry is fairly large, we aim for a small
        // average linked list length (<= 1).
        Resize();
      }
    }
    return old;
  }",35,,80,2,,void
80279,BLOCK,-1,,"{
      ++elems_;
      if (elems_ > length_) {
        // Since each cache entry is fairly large, we aim for a small
        // average linked list length (<= 1).
        Resize();
      }
    }",22,,85,2,,void
80286,BLOCK,-1,,"{
        // Since each cache entry is fairly large, we aim for a small
        // average linked list length (<= 1).
        Resize();
      }",29,,87,2,,void
80295,BLOCK,-1,,"{
    LRUHandle** ptr = FindPointer(key, hash);
    LRUHandle* result = *ptr;
    if (result != NULL) {
      *ptr = result->next_hash;
      --elems_;
    }
    return result;
  }",54,,96,3,,void
80311,BLOCK,-1,,"{
      *ptr = result->next_hash;
      --elems_;
    }",25,,99,2,,void
80330,BLOCK,-1,,"{
    LRUHandle** ptr = &list_[hash & (length_ - 1)];
    while (*ptr != NULL &&
           ((*ptr)->hash != hash || key != (*ptr)->key())) {
      ptr = &(*ptr)->next_hash;
    }
    return ptr;
  }",60,,116,3,,void
80362,BLOCK,-1,,"{
      ptr = &(*ptr)->next_hash;
    }",60,,119,2,,void
80375,BLOCK,-1,,"{
    uint32_t new_length = 4;
    while (new_length < elems_) {
      new_length *= 2;
    }
    LRUHandle** new_list = new LRUHandle*[new_length];
    memset(new_list, 0, sizeof(new_list[0]) * new_length);
    uint32_t count = 0;
    for (uint32_t i = 0; i < length_; i++) {
      LRUHandle* h = list_[i];
      while (h != NULL) {
        LRUHandle* next = h->next_hash;
        uint32_t hash = h->hash;
        LRUHandle** ptr = &new_list[hash & (new_length - 1)];
        h->next_hash = *ptr;
        *ptr = h;
        h = next;
        count++;
      }
    }
    assert(elems_ == count);
    delete[] list_;
    list_ = new_list;
    length_ = new_length;
  }",17,,125,1,,void
80384,BLOCK,-1,,"{
      new_length *= 2;
    }",33,,127,2,,void
80407,BLOCK,-1,,<empty>,5,,133,1,,void
80417,BLOCK,4,,"{
      LRUHandle* h = list_[i];
      while (h != NULL) {
        LRUHandle* next = h->next_hash;
        uint32_t hash = h->hash;
        LRUHandle** ptr = &new_list[hash & (new_length - 1)];
        h->next_hash = *ptr;
        *ptr = h;
        h = next;
        count++;
      }
    }",44,,133,4,,void
80428,BLOCK,-1,,"{
        LRUHandle* next = h->next_hash;
        uint32_t hash = h->hash;
        LRUHandle** ptr = &new_list[hash & (new_length - 1)];
        h->next_hash = *ptr;
        *ptr = h;
        h = next;
        count++;
      }",25,,135,2,,void
80483,BLOCK,-1,,<empty>,,,,1,,<empty>
80487,BLOCK,-1,,<empty>,,,,1,,<empty>
80492,BLOCK,-1,,{ capacity_ = capacity; },37,,159,2,,void
80504,BLOCK,-1,,<empty>,,,,6,,<empty>
80510,BLOCK,-1,,<empty>,,,,3,,<empty>
80515,BLOCK,-1,,<empty>,,,,2,,<empty>
80521,BLOCK,-1,,<empty>,,,,3,,<empty>
80525,BLOCK,-1,,<empty>,,,,1,,<empty>
80529,BLOCK,-1,,"{
    MutexLock l(&mutex_);
    return usage_;
  }",30,,169,1,,void
80540,BLOCK,-1,,<empty>,,,,2,,<empty>
80546,BLOCK,-1,,<empty>,,,,3,,<empty>
80551,BLOCK,-1,,<empty>,,,,2,,<empty>
80556,BLOCK,-1,,<empty>,,,,2,,<empty>
80561,BLOCK,-1,,<empty>,,,,2,,<empty>
80571,BLOCK,-1,,"{
  // Make empty circular linked lists.
  lru_.next = &lru_;
  lru_.prev = &lru_;
  in_use_.next = &in_use_;
  in_use_.prev = &in_use_;
}",17,,201,1,,void
80599,BLOCK,-1,,"{
  assert(in_use_.next == &in_use_);  // Error if caller has an unreleased handle
  for (LRUHandle* e = lru_.next; e != &lru_; ) {
    LRUHandle* next = e->next;
    assert(e->in_cache);
    e->in_cache = false;
    assert(e->refs == 1);  // Invariant of lru_ list.
    Unref(e);
    e = next;
  }
}",23,,209,1,,void
80608,BLOCK,-1,,<empty>,3,,211,1,,void
80619,BLOCK,4,,"{
    LRUHandle* next = e->next;
    assert(e->in_cache);
    e->in_cache = false;
    assert(e->refs == 1);  // Invariant of lru_ list.
    Unref(e);
    e = next;
  }",48,,211,4,,void
80650,BLOCK,-1,,"{
  if (e->refs == 1 && e->in_cache) {  // If on lru_ list, move to in_use_ list.
    LRU_Remove(e);
    LRU_Append(&in_use_, e);
  }
  e->refs++;
}",34,,221,2,,void
80661,BLOCK,-1,,"{  // If on lru_ list, move to in_use_ list.
    LRU_Remove(e);
    LRU_Append(&in_use_, e);
  }",36,,222,2,,void
80676,BLOCK,-1,,"{
  assert(e->refs > 0);
  e->refs--;
  if (e->refs == 0) { // Deallocate.
    assert(!e->in_cache);
    (*e->deleter)(e->key(), e->value);
    free(e);
  } else if (e->in_cache && e->refs == 1) {  // No longer in use; move to lru_ list.
    LRU_Remove(e);
    LRU_Append(&lru_, e);
  }
}",36,,229,2,,void
80693,BLOCK,-1,,"{ // Deallocate.
    assert(!e->in_cache);
    (*e->deleter)(e->key(), e->value);
    free(e);
  }",21,,232,2,,void
80714,BLOCK,-1,,<empty>,10,,236,1,,void
80725,BLOCK,-1,,"{  // No longer in use; move to lru_ list.
    LRU_Remove(e);
    LRU_Append(&lru_, e);
  }",43,,236,2,,void
80736,BLOCK,-1,,"{
  e->next->prev = e->prev;
  e->prev->next = e->next;
}",41,,242,2,,void
80760,BLOCK,-1,,"{
  // Make ""e"" newest entry by inserting just before *list
  e->next = list;
  e->prev = list->prev;
  e->prev->next = e;
  e->next->prev = e;
}",58,,247,3,,void
80792,BLOCK,-1,,"{
  MutexLock l(&mutex_);
  LRUHandle* e = table_.Lookup(key, hash);
  if (e != NULL) {
    Ref(e);
  }
  return reinterpret_cast<Cache::Handle*>(e);
}",66,,255,3,,void
80810,BLOCK,-1,,"{
    Ref(e);
  }",18,,258,2,,void
80821,BLOCK,-1,,"{
  MutexLock l(&mutex_);
  Unref(reinterpret_cast<LRUHandle*>(handle));
}",47,,264,2,,void
80838,BLOCK,-1,,"{
  MutexLock l(&mutex_);

  LRUHandle* e = reinterpret_cast<LRUHandle*>(
      malloc(sizeof(LRUHandle)-1 + key.size()));
  e->value = value;
  e->deleter = deleter;
  e->charge = charge;
  e->key_length = key.size();
  e->hash = hash;
  e->in_cache = false;
  e->refs = 1;  // for the returned handle.
  memcpy(e->key_data, key.data(), key.size());

  if (capacity_ > 0) {
    e->refs++;  // for the cache's reference.
    e->in_cache = true;
    LRU_Append(&in_use_, e);
    usage_ += charge;
    FinishErase(table_.Insert(e));
  } // else don't cache.  (Tests use capacity_==0 to turn off caching.)

  while (usage_ > capacity_ && lru_.next != &lru_) {
    LRUHandle* old = lru_.next;
    assert(old->refs == 1);
    bool erased = FinishErase(table_.Remove(old->key(), old->hash));
    if (!erased) {  // to avoid unused variable when compiled NDEBUG
      assert(erased);
    }
  }

  return reinterpret_cast<Cache::Handle*>(e);
}",53,,271,6,,void
80912,BLOCK,-1,,"{
    e->refs++;  // for the cache's reference.
    e->in_cache = true;
    LRU_Append(&in_use_, e);
    usage_ += charge;
    FinishErase(table_.Insert(e));
  }",22,,285,2,,void
80946,BLOCK,-1,,"{
    LRUHandle* old = lru_.next;
    assert(old->refs == 1);
    bool erased = FinishErase(table_.Remove(old->key(), old->hash));
    if (!erased) {  // to avoid unused variable when compiled NDEBUG
      assert(erased);
    }
  }",52,,293,2,,void
80977,BLOCK,-1,,"{  // to avoid unused variable when compiled NDEBUG
      assert(erased);
    }",18,,297,2,,void
80988,BLOCK,-1,,"{
  if (e != NULL) {
    assert(e->in_cache);
    LRU_Remove(e);
    e->in_cache = false;
    usage_ -= e->charge;
    Unref(e);
  }
  return e != NULL;
}",42,,307,2,,void
80993,BLOCK,-1,,"{
    assert(e->in_cache);
    LRU_Remove(e);
    e->in_cache = false;
    usage_ -= e->charge;
    Unref(e);
  }",18,,308,2,,void
81021,BLOCK,-1,,"{
  MutexLock l(&mutex_);
  FinishErase(table_.Remove(key, hash));
}",55,,318,3,,void
81036,BLOCK,-1,,"{
  MutexLock l(&mutex_);
  while (lru_.next != &lru_) {
    LRUHandle* e = lru_.next;
    assert(e->refs == 1);
    bool erased = FinishErase(table_.Remove(e->key(), e->hash));
    if (!erased) {  // to avoid unused variable when compiled NDEBUG
      assert(erased);
    }
  }
}",24,,323,1,,void
81048,BLOCK,-1,,"{
    LRUHandle* e = lru_.next;
    assert(e->refs == 1);
    bool erased = FinishErase(table_.Remove(e->key(), e->hash));
    if (!erased) {  // to avoid unused variable when compiled NDEBUG
      assert(erased);
    }
  }",30,,325,2,,void
81079,BLOCK,-1,,"{  // to avoid unused variable when compiled NDEBUG
      assert(erased);
    }",18,,329,2,,void
81100,BLOCK,-1,,"{
    return Hash(s.data(), s.size(), 0);
  }",52,,344,2,,void
81116,BLOCK,-1,,"{
    return hash >> (32 - kNumShardBits);
  }",40,,348,2,,void
81127,BLOCK,-1,,"{
    const size_t per_shard = (capacity + (kNumShards - 1)) / kNumShards;
    for (int s = 0; s < kNumShards; s++) {
      shard_[s].SetCapacity(per_shard);
    }
  }",21,,354,2,,void
81139,BLOCK,-1,,<empty>,5,,356,1,,void
81149,BLOCK,4,,"{
      shard_[s].SetCapacity(per_shard);
    }",42,,356,4,,void
81160,BLOCK,-1,,{ },30,,360,1,,void
81168,BLOCK,-1,,"{
    const uint32_t hash = HashSlice(key);
    return shard_[Shard(hash)].Insert(key, hash, value, charge, deleter);
  }",74,,362,5,,void
81191,BLOCK,-1,,"{
    const uint32_t hash = HashSlice(key);
    return shard_[Shard(hash)].Lookup(key, hash);
  }",44,,366,2,,void
81211,BLOCK,-1,,"{
    LRUHandle* h = reinterpret_cast<LRUHandle*>(handle);
    shard_[Shard(h->hash)].Release(handle);
  }",40,,370,2,,void
81232,BLOCK,-1,,"{
    const uint32_t hash = HashSlice(key);
    shard_[Shard(hash)].Erase(key, hash);
  }",40,,374,2,,void
81251,BLOCK,-1,,"{
    return reinterpret_cast<LRUHandle*>(handle)->value;
  }",39,,378,2,,void
81261,BLOCK,-1,,"{
    MutexLock l(&id_mutex_);
    return ++(last_id_);
  }",28,,381,1,,void
81272,BLOCK,-1,,"{
    for (int s = 0; s < kNumShards; s++) {
      shard_[s].Prune();
    }
  }",24,,385,1,,void
81274,BLOCK,-1,,<empty>,5,,386,1,,void
81284,BLOCK,4,,"{
      shard_[s].Prune();
    }",42,,386,4,,void
81294,BLOCK,-1,,"{
    size_t total = 0;
    for (int s = 0; s < kNumShards; s++) {
      total += shard_[s].TotalCharge();
    }
    return total;
  }",38,,390,1,,void
81300,BLOCK,-1,,<empty>,5,,392,1,,void
81310,BLOCK,4,,"{
      total += shard_[s].TotalCharge();
    }",42,,392,4,,void
81324,BLOCK,-1,,<empty>,,,,1,,<empty>
81331,BLOCK,-1,,"{
  return new ShardedLRUCache(capacity);
}",37,,401,2,,void
81350,BLOCK,-1,,<empty>,1,,1,1,,ANY
81354,BLOCK,-1,,"{
  std::string result;
  PutFixed32(&result, k);
  return result;
}",37,,14,2,,void
81366,BLOCK,-1,,"{
  assert(k.size() == 4);
  return DecodeFixed32(k.data());
}",38,,19,2,,void
81384,BLOCK,-1,,{ return reinterpret_cast<void*>(v); },39,,23,2,,void
81393,BLOCK,-1,,{ return reinterpret_cast<uintptr_t>(v); },33,,24,2,,void
81405,BLOCK,-1,,"{
    current_->deleted_keys_.push_back(DecodeKey(key));
    current_->deleted_values_.push_back(DecodeValue(v));
  }",50,,30,3,,void
81429,BLOCK,-1,,"{
    current_ = this;
  }",49,,40,1,,void
81436,BLOCK,-1,,"{
    delete cache_;
  }",16,,44,1,,void
81443,BLOCK,-1,,"{
    Cache::Handle* handle = cache_->Lookup(EncodeKey(key));
    const int r = (handle == NULL) ? -1 : DecodeValue(cache_->Value(handle));
    if (handle != NULL) {
      cache_->Release(handle);
    }
    return r;
  }",23,,48,2,,void
81472,BLOCK,-1,,"{
      cache_->Release(handle);
    }",25,,51,2,,void
81486,BLOCK,-1,,"{
    cache_->Release(cache_->Insert(EncodeKey(key), EncodeValue(value), charge,
                                   &CacheTest::Deleter));
  }",51,,57,4,,void
81510,BLOCK,-1,,"{
    return cache_->Insert(EncodeKey(key), EncodeValue(value), charge,
                          &CacheTest::Deleter);
  }",76,,62,4,,void
81529,BLOCK,-1,,"{
    cache_->Erase(EncodeKey(key));
  }",23,,67,2,,void
81539,BLOCK,-1,,<empty>,,,,1,,<empty>
81548,BLOCK,-1,,<empty>,,,,1,,<empty>
81552,BLOCK,-1,,"TEST(CacheTest, HitAndMiss)",1,,73,1,,void
81576,BLOCK,-1,,"{
  ASSERT_EQ(-1, Lookup(100));

  Insert(100, 101);
  ASSERT_EQ(101, Lookup(100));
  ASSERT_EQ(-1,  Lookup(200));
  ASSERT_EQ(-1,  Lookup(300));

  Insert(200, 201);
  ASSERT_EQ(101, Lookup(100));
  ASSERT_EQ(201, Lookup(200));
  ASSERT_EQ(-1,  Lookup(300));

  Insert(100, 102);
  ASSERT_EQ(102, Lookup(100));
  ASSERT_EQ(201, Lookup(200));
  ASSERT_EQ(-1,  Lookup(300));

  ASSERT_EQ(1, deleted_keys_.size());
  ASSERT_EQ(100, deleted_keys_[0]);
  ASSERT_EQ(101, deleted_values_[0]);
}",29,,73,1,,void
81582,BLOCK,1,,<empty>,,,,3,,void
81605,BLOCK,1,,<empty>,,,,3,,void
81625,BLOCK,1,,<empty>,,,,3,,void
81646,BLOCK,1,,<empty>,,,,3,,void
81669,BLOCK,1,,<empty>,,,,3,,void
81688,BLOCK,1,,<empty>,,,,3,,void
81708,BLOCK,1,,<empty>,,,,3,,void
81731,BLOCK,1,,<empty>,,,,3,,void
81750,BLOCK,1,,<empty>,,,,3,,void
81770,BLOCK,1,,<empty>,,,,3,,void
81792,BLOCK,1,,<empty>,,,,3,,void
81814,BLOCK,1,,<empty>,,,,3,,void
81835,BLOCK,1,,<empty>,,,,3,,void
81855,BLOCK,-1,,<empty>,,,,1,,<empty>
81859,BLOCK,-1,,"TEST(CacheTest, Erase)",1,,96,1,,void
81883,BLOCK,-1,,"{
  Erase(200);
  ASSERT_EQ(0, deleted_keys_.size());

  Insert(100, 101);
  Insert(200, 201);
  Erase(100);
  ASSERT_EQ(-1,  Lookup(100));
  ASSERT_EQ(201, Lookup(200));
  ASSERT_EQ(1, deleted_keys_.size());
  ASSERT_EQ(100, deleted_keys_[0]);
  ASSERT_EQ(101, deleted_values_[0]);

  Erase(100);
  ASSERT_EQ(-1,  Lookup(100));
  ASSERT_EQ(201, Lookup(200));
  ASSERT_EQ(1, deleted_keys_.size());
}",24,,96,1,,void
81892,BLOCK,1,,<empty>,,,,3,,void
81922,BLOCK,1,,<empty>,,,,3,,void
81942,BLOCK,1,,<empty>,,,,3,,void
81963,BLOCK,1,,<empty>,,,,3,,void
81985,BLOCK,1,,<empty>,,,,3,,void
82006,BLOCK,1,,<empty>,,,,3,,void
82029,BLOCK,1,,<empty>,,,,3,,void
82049,BLOCK,1,,<empty>,,,,3,,void
82070,BLOCK,1,,<empty>,,,,3,,void
82091,BLOCK,-1,,<empty>,,,,1,,<empty>
82095,BLOCK,-1,,"TEST(CacheTest, EntriesArePinned)",1,,115,1,,void
82119,BLOCK,-1,,"{
  Insert(100, 101);
  Cache::Handle* h1 = cache_->Lookup(EncodeKey(100));
  ASSERT_EQ(101, DecodeValue(cache_->Value(h1)));

  Insert(100, 102);
  Cache::Handle* h2 = cache_->Lookup(EncodeKey(100));
  ASSERT_EQ(102, DecodeValue(cache_->Value(h2)));
  ASSERT_EQ(0, deleted_keys_.size());

  cache_->Release(h1);
  ASSERT_EQ(1, deleted_keys_.size());
  ASSERT_EQ(100, deleted_keys_[0]);
  ASSERT_EQ(101, deleted_values_[0]);

  Erase(100);
  ASSERT_EQ(-1, Lookup(100));
  ASSERT_EQ(1, deleted_keys_.size());

  cache_->Release(h2);
  ASSERT_EQ(2, deleted_keys_.size());
  ASSERT_EQ(100, deleted_keys_[1]);
  ASSERT_EQ(102, deleted_values_[1]);
}",35,,115,1,,void
82140,BLOCK,1,,<empty>,,,,4,,void
82179,BLOCK,1,,<empty>,,,,4,,void
82204,BLOCK,1,,<empty>,,,,3,,void
82232,BLOCK,1,,<empty>,,,,3,,void
82254,BLOCK,1,,<empty>,,,,3,,void
82275,BLOCK,1,,<empty>,,,,3,,void
82298,BLOCK,1,,<empty>,,,,3,,void
82320,BLOCK,1,,<empty>,,,,3,,void
82348,BLOCK,1,,<empty>,,,,3,,void
82370,BLOCK,1,,<empty>,,,,3,,void
82391,BLOCK,1,,<empty>,,,,3,,void
82411,BLOCK,-1,,<empty>,,,,1,,<empty>
82415,BLOCK,-1,,"TEST(CacheTest, EvictionPolicy)",1,,140,1,,void
82439,BLOCK,-1,,"{
  Insert(100, 101);
  Insert(200, 201);
  Insert(300, 301);
  Cache::Handle* h = cache_->Lookup(EncodeKey(300));

  // Frequently used entry must be kept around,
  // as must things that are still in use.
  for (int i = 0; i < kCacheSize + 100; i++) {
    Insert(1000+i, 2000+i);
    ASSERT_EQ(2000+i, Lookup(1000+i));
    ASSERT_EQ(101, Lookup(100));
  }
  ASSERT_EQ(101, Lookup(100));
  ASSERT_EQ(-1, Lookup(200));
  ASSERT_EQ(301, Lookup(300));
  cache_->Release(h);
}",33,,140,1,,void
82459,BLOCK,-1,,<empty>,3,,148,1,,void
82471,BLOCK,4,,"{
    Insert(1000+i, 2000+i);
    ASSERT_EQ(2000+i, Lookup(1000+i));
    ASSERT_EQ(101, Lookup(100));
  }",46,,148,4,,void
82480,BLOCK,1,,<empty>,,,,1,,void
82503,BLOCK,1,,<empty>,,,,3,,void
82522,BLOCK,1,,<empty>,,,,3,,void
82542,BLOCK,1,,<empty>,,,,3,,void
82562,BLOCK,1,,<empty>,,,,3,,void
82586,BLOCK,-1,,<empty>,,,,1,,<empty>
82590,BLOCK,-1,,"TEST(CacheTest, UseExceedsCacheSize)",1,,159,1,,void
82614,BLOCK,-1,,"{
  // Overfill the cache, keeping handles on all inserted entries.
  std::vector<Cache::Handle*> h;
  for (int i = 0; i < kCacheSize + 100; i++) {
    h.push_back(InsertAndReturnHandle(1000+i, 2000+i));
  }

  // Check that all the entries can be found in the cache.
  for (int i = 0; i < h.size(); i++) {
    ASSERT_EQ(2000+i, Lookup(1000+i));
  }

  for (int i = 0; i < h.size(); i++) {
    cache_->Release(h[i]);
  }
}",38,,159,1,,void
82617,BLOCK,-1,,<empty>,3,,162,1,,void
82629,BLOCK,4,,"{
    h.push_back(InsertAndReturnHandle(1000+i, 2000+i));
  }",46,,162,4,,void
82642,BLOCK,-1,,<empty>,3,,167,1,,void
82655,BLOCK,4,,"{
    ASSERT_EQ(2000+i, Lookup(1000+i));
  }",38,,167,4,,void
82657,BLOCK,1,,<empty>,,,,1,,void
82677,BLOCK,-1,,<empty>,3,,171,1,,void
82690,BLOCK,4,,"{
    cache_->Release(h[i]);
  }",38,,171,4,,void
82702,BLOCK,-1,,<empty>,,,,1,,<empty>
82706,BLOCK,-1,,"TEST(CacheTest, HeavyEntries)",1,,176,1,,void
82730,BLOCK,-1,,"{
  // Add a bunch of light and heavy entries and then count the combined
  // size of items still in the cache, which must be approximately the
  // same as the total capacity.
  const int kLight = 1;
  const int kHeavy = 10;
  int added = 0;
  int index = 0;
  while (added < 2*kCacheSize) {
    const int weight = (index & 1) ? kLight : kHeavy;
    Insert(index, 1000+index, weight);
    added += weight;
    index++;
  }

  int cached_weight = 0;
  for (int i = 0; i < index; i++) {
    const int weight = (i & 1 ? kLight : kHeavy);
    int r = Lookup(i);
    if (r >= 0) {
      cached_weight += weight;
      ASSERT_EQ(1000+i, r);
    }
  }
  ASSERT_LE(cached_weight, kCacheSize + kCacheSize/10);
}",31,,176,1,,void
82753,BLOCK,-1,,"{
    const int weight = (index & 1) ? kLight : kHeavy;
    Insert(index, 1000+index, weight);
    added += weight;
    index++;
  }",32,,184,2,,void
82779,BLOCK,-1,,<empty>,3,,192,1,,void
82789,BLOCK,4,,"{
    const int weight = (i & 1 ? kLight : kHeavy);
    int r = Lookup(i);
    if (r >= 0) {
      cached_weight += weight;
      ASSERT_EQ(1000+i, r);
    }
  }",35,,192,4,,void
82808,BLOCK,-1,,"{
      cached_weight += weight;
      ASSERT_EQ(1000+i, r);
    }",17,,195,2,,void
82814,BLOCK,1,,<empty>,,,,3,,void
82832,BLOCK,1,,<empty>,,,,3,,void
82854,BLOCK,-1,,<empty>,,,,1,,<empty>
82858,BLOCK,-1,,"TEST(CacheTest, NewId)",1,,203,1,,void
82882,BLOCK,-1,,"{
  uint64_t a = cache_->NewId();
  uint64_t b = cache_->NewId();
  ASSERT_NE(a, b);
}",24,,203,1,,void
82900,BLOCK,1,,<empty>,,,,5,,void
82918,BLOCK,-1,,<empty>,,,,1,,<empty>
82922,BLOCK,-1,,"TEST(CacheTest, Prune)",1,,209,1,,void
82946,BLOCK,-1,,"{
  Insert(1, 100);
  Insert(2, 200);

  Cache::Handle* handle = cache_->Lookup(EncodeKey(1));
  ASSERT_TRUE(handle);
  cache_->Prune();
  cache_->Release(handle);

  ASSERT_EQ(100, Lookup(1));
  ASSERT_EQ(-1, Lookup(2));
}",24,,209,1,,void
82964,BLOCK,1,,<empty>,,,,3,,void
82991,BLOCK,1,,<empty>,,,,3,,void
83011,BLOCK,1,,<empty>,,,,3,,void
83032,BLOCK,-1,,"{
  return leveldb::test::RunAllTests();
}",33,,224,3,,void
83048,BLOCK,-1,,<empty>,1,,1,1,,ANY
83053,BLOCK,-1,,"{
  if (port::kLittleEndian) {
    memcpy(buf, &value, sizeof(value));
  } else {
    buf[0] = value & 0xff;
    buf[1] = (value >> 8) & 0xff;
    buf[2] = (value >> 16) & 0xff;
    buf[3] = (value >> 24) & 0xff;
  }
}",47,,9,3,,void
83058,BLOCK,-1,,"{
    memcpy(buf, &value, sizeof(value));
  }",28,,10,2,,void
83066,BLOCK,-1,,"{
    buf[0] = value & 0xff;
    buf[1] = (value >> 8) & 0xff;
    buf[2] = (value >> 16) & 0xff;
    buf[3] = (value >> 24) & 0xff;
  }",10,,12,1,,void
83106,BLOCK,-1,,"{
  if (port::kLittleEndian) {
    memcpy(buf, &value, sizeof(value));
  } else {
    buf[0] = value & 0xff;
    buf[1] = (value >> 8) & 0xff;
    buf[2] = (value >> 16) & 0xff;
    buf[3] = (value >> 24) & 0xff;
    buf[4] = (value >> 32) & 0xff;
    buf[5] = (value >> 40) & 0xff;
    buf[6] = (value >> 48) & 0xff;
    buf[7] = (value >> 56) & 0xff;
  }
}",47,,20,3,,void
83111,BLOCK,-1,,"{
    memcpy(buf, &value, sizeof(value));
  }",28,,21,2,,void
83119,BLOCK,-1,,"{
    buf[0] = value & 0xff;
    buf[1] = (value >> 8) & 0xff;
    buf[2] = (value >> 16) & 0xff;
    buf[3] = (value >> 24) & 0xff;
    buf[4] = (value >> 32) & 0xff;
    buf[5] = (value >> 40) & 0xff;
    buf[6] = (value >> 48) & 0xff;
    buf[7] = (value >> 56) & 0xff;
  }",10,,23,1,,void
83195,BLOCK,-1,,"{
  char buf[sizeof(value)];
  EncodeFixed32(buf, value);
  dst->append(buf, sizeof(buf));
}",51,,35,3,,void
83212,BLOCK,-1,,"{
  char buf[sizeof(value)];
  EncodeFixed64(buf, value);
  dst->append(buf, sizeof(buf));
}",51,,41,3,,void
83229,BLOCK,-1,,"{
  // Operate on characters as unsigneds
  unsigned char* ptr = reinterpret_cast<unsigned char*>(dst);
  static const int B = 128;
  if (v < (1<<7)) {
    *(ptr++) = v;
  } else if (v < (1<<14)) {
    *(ptr++) = v | B;
    *(ptr++) = v>>7;
  } else if (v < (1<<21)) {
    *(ptr++) = v | B;
    *(ptr++) = (v>>7) | B;
    *(ptr++) = v>>14;
  } else if (v < (1<<28)) {
    *(ptr++) = v | B;
    *(ptr++) = (v>>7) | B;
    *(ptr++) = (v>>14) | B;
    *(ptr++) = v>>21;
  } else {
    *(ptr++) = v | B;
    *(ptr++) = (v>>7) | B;
    *(ptr++) = (v>>14) | B;
    *(ptr++) = (v>>21) | B;
    *(ptr++) = v>>28;
  }
  return reinterpret_cast<char*>(ptr);
}",45,,47,3,,void
83246,BLOCK,-1,,"{
    *(ptr++) = v;
  }",19,,51,2,,void
83253,BLOCK,-1,,<empty>,10,,53,1,,void
83260,BLOCK,-1,,"{
    *(ptr++) = v | B;
    *(ptr++) = v>>7;
  }",27,,53,2,,void
83276,BLOCK,-1,,<empty>,10,,56,1,,void
83283,BLOCK,-1,,"{
    *(ptr++) = v | B;
    *(ptr++) = (v>>7) | B;
    *(ptr++) = v>>14;
  }",27,,56,2,,void
83308,BLOCK,-1,,<empty>,10,,60,1,,void
83315,BLOCK,-1,,"{
    *(ptr++) = v | B;
    *(ptr++) = (v>>7) | B;
    *(ptr++) = (v>>14) | B;
    *(ptr++) = v>>21;
  }",27,,60,2,,void
83349,BLOCK,-1,,"{
    *(ptr++) = v | B;
    *(ptr++) = (v>>7) | B;
    *(ptr++) = (v>>14) | B;
    *(ptr++) = (v>>21) | B;
    *(ptr++) = v>>28;
  }",10,,65,1,,void
83400,BLOCK,-1,,"{
  char buf[5];
  char* ptr = EncodeVarint32(buf, v);
  dst->append(buf, ptr - buf);
}",48,,75,3,,void
83421,BLOCK,-1,,"{
  static const int B = 128;
  unsigned char* ptr = reinterpret_cast<unsigned char*>(dst);
  while (v >= B) {
    *(ptr++) = (v & (B-1)) | B;
    v >>= 7;
  }
  *(ptr++) = static_cast<unsigned char>(v);
  return reinterpret_cast<char*>(ptr);
}",45,,81,3,,void
83436,BLOCK,-1,,"{
    *(ptr++) = (v & (B-1)) | B;
    v >>= 7;
  }",18,,84,2,,void
83467,BLOCK,-1,,"{
  char buf[10];
  char* ptr = EncodeVarint64(buf, v);
  dst->append(buf, ptr - buf);
}",48,,92,3,,void
83488,BLOCK,-1,,"{
  PutVarint32(dst, value.size());
  dst->append(value.data(), value.size());
}",67,,98,3,,void
83511,BLOCK,-1,,"{
  int len = 1;
  while (v >= 128) {
    v >>= 7;
    len++;
  }
  return len;
}",30,,103,2,,void
83520,BLOCK,-1,,"{
    v >>= 7;
    len++;
  }",20,,105,2,,void
83534,BLOCK,-1,,"{
  uint32_t result = 0;
  for (uint32_t shift = 0; shift <= 28 && p < limit; shift += 7) {
    uint32_t byte = *(reinterpret_cast<const unsigned char*>(p));
    p++;
    if (byte & 128) {
      // More bytes are present
      result |= ((byte & 127) << shift);
    } else {
      result |= (byte << shift);
      *value = result;
      return reinterpret_cast<const char*>(p);
    }
  }
  return NULL;
}",53,,114,4,,void
83540,BLOCK,-1,,<empty>,3,,116,1,,void
83555,BLOCK,4,,"{
    uint32_t byte = *(reinterpret_cast<const unsigned char*>(p));
    p++;
    if (byte & 128) {
      // More bytes are present
      result |= ((byte & 127) << shift);
    } else {
      result |= (byte << shift);
      *value = result;
      return reinterpret_cast<const char*>(p);
    }
  }",66,,116,4,,void
83569,BLOCK,-1,,"{
      // More bytes are present
      result |= ((byte & 127) << shift);
    }",21,,119,2,,void
83578,BLOCK,-1,,"{
      result |= (byte << shift);
      *value = result;
      return reinterpret_cast<const char*>(p);
    }",12,,122,1,,void
83599,BLOCK,-1,,"{
  const char* p = input->data();
  const char* limit = p + input->size();
  const char* q = GetVarint32Ptr(p, limit, value);
  if (q == NULL) {
    return false;
  } else {
    *input = Slice(q, limit - q);
    return true;
  }
}",49,,131,3,,void
83627,BLOCK,-1,,"{
    return false;
  }",18,,135,2,,void
83631,BLOCK,-1,,"{
    *input = Slice(q, limit - q);
    return true;
  }",10,,137,1,,void
83648,BLOCK,-1,,"{
  uint64_t result = 0;
  for (uint32_t shift = 0; shift <= 63 && p < limit; shift += 7) {
    uint64_t byte = *(reinterpret_cast<const unsigned char*>(p));
    p++;
    if (byte & 128) {
      // More bytes are present
      result |= ((byte & 127) << shift);
    } else {
      result |= (byte << shift);
      *value = result;
      return reinterpret_cast<const char*>(p);
    }
  }
  return NULL;
}",79,,143,4,,void
83654,BLOCK,-1,,<empty>,3,,145,1,,void
83669,BLOCK,4,,"{
    uint64_t byte = *(reinterpret_cast<const unsigned char*>(p));
    p++;
    if (byte & 128) {
      // More bytes are present
      result |= ((byte & 127) << shift);
    } else {
      result |= (byte << shift);
      *value = result;
      return reinterpret_cast<const char*>(p);
    }
  }",66,,145,4,,void
83683,BLOCK,-1,,"{
      // More bytes are present
      result |= ((byte & 127) << shift);
    }",21,,148,2,,void
83692,BLOCK,-1,,"{
      result |= (byte << shift);
      *value = result;
      return reinterpret_cast<const char*>(p);
    }",12,,151,1,,void
83713,BLOCK,-1,,"{
  const char* p = input->data();
  const char* limit = p + input->size();
  const char* q = GetVarint64Ptr(p, limit, value);
  if (q == NULL) {
    return false;
  } else {
    *input = Slice(q, limit - q);
    return true;
  }
}",49,,160,3,,void
83741,BLOCK,-1,,"{
    return false;
  }",18,,164,2,,void
83745,BLOCK,-1,,"{
    *input = Slice(q, limit - q);
    return true;
  }",10,,166,1,,void
83762,BLOCK,-1,,"{
  uint32_t len;
  p = GetVarint32Ptr(p, limit, &len);
  if (p == NULL) return NULL;
  if (p + len > limit) return NULL;
  *result = Slice(p, len);
  return p + len;
}",51,,173,4,,void
83775,BLOCK,-1,,<empty>,18,,176,2,,void
83784,BLOCK,-1,,<empty>,24,,177,2,,void
83802,BLOCK,-1,,"{
  uint32_t len;
  if (GetVarint32(input, &len) &&
      input->size() >= len) {
    *result = Slice(input->data(), len);
    input->remove_prefix(len);
    return true;
  } else {
    return false;
  }
}",58,,182,3,,void
83816,BLOCK,-1,,"{
    *result = Slice(input->data(), len);
    input->remove_prefix(len);
    return true;
  }",29,,185,2,,void
83834,BLOCK,-1,,"{
    return false;
  }",10,,189,1,,void
83853,BLOCK,-1,,<empty>,1,,1,1,,ANY
83858,BLOCK,-1,,<empty>,,,,3,,<empty>
83864,BLOCK,-1,,<empty>,,,,3,,<empty>
83870,BLOCK,-1,,<empty>,,,,3,,<empty>
83876,BLOCK,-1,,<empty>,,,,3,,<empty>
83882,BLOCK,-1,,<empty>,,,,3,,<empty>
83888,BLOCK,-1,,<empty>,,,,3,,<empty>
83894,BLOCK,-1,,<empty>,,,,3,,<empty>
83900,BLOCK,-1,,<empty>,,,,3,,<empty>
83907,BLOCK,-1,,<empty>,,,,4,,<empty>
83914,BLOCK,-1,,<empty>,,,,4,,<empty>
83919,BLOCK,-1,,<empty>,,,,2,,<empty>
83925,BLOCK,-1,,<empty>,,,,3,,<empty>
83931,BLOCK,-1,,<empty>,,,,3,,<empty>
83937,BLOCK,-1,,<empty>,,,,3,,<empty>
83943,BLOCK,-1,,<empty>,,,,3,,<empty>
83948,BLOCK,-1,,"{
  if (port::kLittleEndian) {
    // Load the raw bytes
    uint32_t result;
    memcpy(&result, ptr, sizeof(result));  // gcc optimizes this to a plain load
    return result;
  } else {
    return ((static_cast<uint32_t>(static_cast<unsigned char>(ptr[0])))
        | (static_cast<uint32_t>(static_cast<unsigned char>(ptr[1])) << 8)
        | (static_cast<uint32_t>(static_cast<unsigned char>(ptr[2])) << 16)
        | (static_cast<uint32_t>(static_cast<unsigned char>(ptr[3])) << 24));
  }
}",48,,58,2,,void
83953,BLOCK,-1,,"{
    // Load the raw bytes
    uint32_t result;
    memcpy(&result, ptr, sizeof(result));  // gcc optimizes this to a plain load
    return result;
  }",28,,59,2,,void
83964,BLOCK,-1,,"{
    return ((static_cast<uint32_t>(static_cast<unsigned char>(ptr[0])))
        | (static_cast<uint32_t>(static_cast<unsigned char>(ptr[1])) << 8)
        | (static_cast<uint32_t>(static_cast<unsigned char>(ptr[2])) << 16)
        | (static_cast<uint32_t>(static_cast<unsigned char>(ptr[3])) << 24));
  }",10,,64,1,,void
84007,BLOCK,-1,,"{
  if (port::kLittleEndian) {
    // Load the raw bytes
    uint64_t result;
    memcpy(&result, ptr, sizeof(result));  // gcc optimizes this to a plain load
    return result;
  } else {
    uint64_t lo = DecodeFixed32(ptr);
    uint64_t hi = DecodeFixed32(ptr + 4);
    return (hi << 32) | lo;
  }
}",48,,72,2,,void
84012,BLOCK,-1,,"{
    // Load the raw bytes
    uint64_t result;
    memcpy(&result, ptr, sizeof(result));  // gcc optimizes this to a plain load
    return result;
  }",28,,73,2,,void
84023,BLOCK,-1,,"{
    uint64_t lo = DecodeFixed32(ptr);
    uint64_t hi = DecodeFixed32(ptr + 4);
    return (hi << 32) | lo;
  }",10,,78,1,,void
84048,BLOCK,-1,,<empty>,,,,4,,<empty>
84055,BLOCK,-1,,"{
  if (p < limit) {
    uint32_t result = *(reinterpret_cast<const unsigned char*>(p));
    if ((result & 128) == 0) {
      *value = result;
      return p + 1;
    }
  }
  return GetVarint32PtrFallback(p, limit, value);
}",52,,91,4,,void
84060,BLOCK,-1,,"{
    uint32_t result = *(reinterpret_cast<const unsigned char*>(p));
    if ((result & 128) == 0) {
      *value = result;
      return p + 1;
    }
  }",18,,92,2,,void
84074,BLOCK,-1,,"{
      *value = result;
      return p + 1;
    }",30,,94,2,,void
84098,BLOCK,-1,,<empty>,1,,1,1,,ANY
84103,BLOCK,-1,,<empty>,,,,1,,<empty>
84107,BLOCK,-1,,"TEST(Coding, Fixed32)",1,,13,1,,void
84131,BLOCK,-1,,"{
  std::string s;
  for (uint32_t v = 0; v < 100000; v++) {
    PutFixed32(&s, v);
  }

  const char* p = s.data();
  for (uint32_t v = 0; v < 100000; v++) {
    uint32_t actual = DecodeFixed32(p);
    ASSERT_EQ(v, actual);
    p += sizeof(uint32_t);
  }
}",23,,13,1,,void
84134,BLOCK,-1,,<empty>,3,,15,1,,void
84144,BLOCK,4,,"{
    PutFixed32(&s, v);
  }",41,,15,4,,void
84157,BLOCK,-1,,<empty>,3,,20,1,,void
84167,BLOCK,4,,"{
    uint32_t actual = DecodeFixed32(p);
    ASSERT_EQ(v, actual);
    p += sizeof(uint32_t);
  }",41,,20,4,,void
84176,BLOCK,1,,<empty>,,,,4,,void
84198,BLOCK,-1,,<empty>,,,,1,,<empty>
84202,BLOCK,-1,,"TEST(Coding, Fixed64)",1,,27,1,,void
84226,BLOCK,-1,,"{
  std::string s;
  for (int power = 0; power <= 63; power++) {
    uint64_t v = static_cast<uint64_t>(1) << power;
    PutFixed64(&s, v - 1);
    PutFixed64(&s, v + 0);
    PutFixed64(&s, v + 1);
  }

  const char* p = s.data();
  for (int power = 0; power <= 63; power++) {
    uint64_t v = static_cast<uint64_t>(1) << power;
    uint64_t actual;
    actual = DecodeFixed64(p);
    ASSERT_EQ(v-1, actual);
    p += sizeof(uint64_t);

    actual = DecodeFixed64(p);
    ASSERT_EQ(v+0, actual);
    p += sizeof(uint64_t);

    actual = DecodeFixed64(p);
    ASSERT_EQ(v+1, actual);
    p += sizeof(uint64_t);
  }
}",23,,27,1,,void
84229,BLOCK,-1,,<empty>,3,,29,1,,void
84239,BLOCK,4,,"{
    uint64_t v = static_cast<uint64_t>(1) << power;
    PutFixed64(&s, v - 1);
    PutFixed64(&s, v + 0);
    PutFixed64(&s, v + 1);
  }",45,,29,4,,void
84274,BLOCK,-1,,<empty>,3,,37,1,,void
84284,BLOCK,4,,"{
    uint64_t v = static_cast<uint64_t>(1) << power;
    uint64_t actual;
    actual = DecodeFixed64(p);
    ASSERT_EQ(v-1, actual);
    p += sizeof(uint64_t);

    actual = DecodeFixed64(p);
    ASSERT_EQ(v+0, actual);
    p += sizeof(uint64_t);

    actual = DecodeFixed64(p);
    ASSERT_EQ(v+1, actual);
    p += sizeof(uint64_t);
  }",45,,37,4,,void
84300,BLOCK,1,,<empty>,,,,4,,void
84326,BLOCK,1,,<empty>,,,,4,,void
84352,BLOCK,1,,<empty>,,,,4,,void
84376,BLOCK,-1,,<empty>,,,,1,,<empty>
84380,BLOCK,-1,,"TEST(Coding, EncodingOutput)",1,,55,1,,void
84404,BLOCK,-1,,"{
  std::string dst;
  PutFixed32(&dst, 0x04030201);
  ASSERT_EQ(4, dst.size());
  ASSERT_EQ(0x01, static_cast<int>(dst[0]));
  ASSERT_EQ(0x02, static_cast<int>(dst[1]));
  ASSERT_EQ(0x03, static_cast<int>(dst[2]));
  ASSERT_EQ(0x04, static_cast<int>(dst[3]));

  dst.clear();
  PutFixed64(&dst, 0x0807060504030201ull);
  ASSERT_EQ(8, dst.size());
  ASSERT_EQ(0x01, static_cast<int>(dst[0]));
  ASSERT_EQ(0x02, static_cast<int>(dst[1]));
  ASSERT_EQ(0x03, static_cast<int>(dst[2]));
  ASSERT_EQ(0x04, static_cast<int>(dst[3]));
  ASSERT_EQ(0x05, static_cast<int>(dst[4]));
  ASSERT_EQ(0x06, static_cast<int>(dst[5]));
  ASSERT_EQ(0x07, static_cast<int>(dst[6]));
  ASSERT_EQ(0x08, static_cast<int>(dst[7]));
}",30,,55,1,,void
84416,BLOCK,1,,<empty>,,,,4,,void
84440,BLOCK,1,,<empty>,,,,4,,void
84465,BLOCK,1,,<empty>,,,,4,,void
84490,BLOCK,1,,<empty>,,,,4,,void
84515,BLOCK,1,,<empty>,,,,4,,void
84547,BLOCK,1,,<empty>,,,,4,,void
84571,BLOCK,1,,<empty>,,,,4,,void
84596,BLOCK,1,,<empty>,,,,4,,void
84621,BLOCK,1,,<empty>,,,,4,,void
84646,BLOCK,1,,<empty>,,,,4,,void
84671,BLOCK,1,,<empty>,,,,4,,void
84696,BLOCK,1,,<empty>,,,,4,,void
84721,BLOCK,1,,<empty>,,,,4,,void
84746,BLOCK,1,,<empty>,,,,4,,void
84768,BLOCK,-1,,<empty>,,,,1,,<empty>
84772,BLOCK,-1,,"TEST(Coding, Varint32)",1,,77,1,,void
84796,BLOCK,-1,,"{
  std::string s;
  for (uint32_t i = 0; i < (32 * 32); i++) {
    uint32_t v = (i / 32) << (i % 32);
    PutVarint32(&s, v);
  }

  const char* p = s.data();
  const char* limit = p + s.size();
  for (uint32_t i = 0; i < (32 * 32); i++) {
    uint32_t expected = (i / 32) << (i % 32);
    uint32_t actual;
    const char* start = p;
    p = GetVarint32Ptr(p, limit, &actual);
    ASSERT_TRUE(p != NULL);
    ASSERT_EQ(expected, actual);
    ASSERT_EQ(VarintLength(actual), p - start);
  }
  ASSERT_EQ(p, s.data() + s.size());
}",24,,77,1,,void
84799,BLOCK,-1,,<empty>,3,,79,1,,void
84811,BLOCK,4,,"{
    uint32_t v = (i / 32) << (i % 32);
    PutVarint32(&s, v);
  }",44,,79,4,,void
84843,BLOCK,-1,,<empty>,3,,86,1,,void
84855,BLOCK,4,,"{
    uint32_t expected = (i / 32) << (i % 32);
    uint32_t actual;
    const char* start = p;
    p = GetVarint32Ptr(p, limit, &actual);
    ASSERT_TRUE(p != NULL);
    ASSERT_EQ(expected, actual);
    ASSERT_EQ(VarintLength(actual), p - start);
  }",44,,86,4,,void
84879,BLOCK,1,,<empty>,,,,2,,void
84898,BLOCK,1,,<empty>,,,,5,,void
84915,BLOCK,1,,<empty>,,,,5,,void
84934,BLOCK,1,,<empty>,,,,5,,void
84960,BLOCK,-1,,<empty>,,,,1,,<empty>
84964,BLOCK,-1,,"TEST(Coding, Varint64)",1,,98,1,,void
84988,BLOCK,-1,,"{
  // Construct the list of values to check
  std::vector<uint64_t> values;
  // Some special values
  values.push_back(0);
  values.push_back(100);
  values.push_back(~static_cast<uint64_t>(0));
  values.push_back(~static_cast<uint64_t>(0) - 1);
  for (uint32_t k = 0; k < 64; k++) {
    // Test values near powers of two
    const uint64_t power = 1ull << k;
    values.push_back(power);
    values.push_back(power-1);
    values.push_back(power+1);
  }

  std::string s;
  for (size_t i = 0; i < values.size(); i++) {
    PutVarint64(&s, values[i]);
  }

  const char* p = s.data();
  const char* limit = p + s.size();
  for (size_t i = 0; i < values.size(); i++) {
    ASSERT_TRUE(p < limit);
    uint64_t actual;
    const char* start = p;
    p = GetVarint64Ptr(p, limit, &actual);
    ASSERT_TRUE(p != NULL);
    ASSERT_EQ(values[i], actual);
    ASSERT_EQ(VarintLength(actual), p - start);
  }
  ASSERT_EQ(p, limit);

}",24,,98,1,,void
85025,BLOCK,-1,,<empty>,3,,106,1,,void
85035,BLOCK,4,,"{
    // Test values near powers of two
    const uint64_t power = 1ull << k;
    values.push_back(power);
    values.push_back(power-1);
    values.push_back(power+1);
  }",37,,106,4,,void
85063,BLOCK,-1,,<empty>,3,,115,1,,void
85076,BLOCK,4,,"{
    PutVarint64(&s, values[i]);
  }",46,,115,4,,void
85100,BLOCK,-1,,<empty>,3,,121,1,,void
85113,BLOCK,4,,"{
    ASSERT_TRUE(p < limit);
    uint64_t actual;
    const char* start = p;
    p = GetVarint64Ptr(p, limit, &actual);
    ASSERT_TRUE(p != NULL);
    ASSERT_EQ(values[i], actual);
    ASSERT_EQ(VarintLength(actual), p - start);
  }",46,,121,4,,void
85115,BLOCK,1,,<empty>,,,,3,,void
85144,BLOCK,1,,<empty>,,,,2,,void
85165,BLOCK,1,,<empty>,,,,4,,void
85184,BLOCK,1,,<empty>,,,,5,,void
85204,BLOCK,1,,<empty>,,,,5,,void
85222,BLOCK,-1,,<empty>,,,,1,,<empty>
85226,BLOCK,-1,,"TEST(Coding, Varint32Overflow)",1,,134,1,,void
85250,BLOCK,-1,,"{
  uint32_t result;
  std::string input(""\x81\x82\x83\x84\x85\x11"");
  ASSERT_TRUE(GetVarint32Ptr(input.data(), input.data() + input.size(), &result)
              == NULL);
}",32,,134,1,,void
85256,BLOCK,1,,<empty>,,,,5,,void
85291,BLOCK,-1,,<empty>,,,,1,,<empty>
85295,BLOCK,-1,,"TEST(Coding, Varint32Truncation)",1,,141,1,,void
85319,BLOCK,-1,,"{
  uint32_t large_value = (1u << 31) + 100;
  std::string s;
  PutVarint32(&s, large_value);
  uint32_t result;
  for (size_t len = 0; len < s.size() - 1; len++) {
    ASSERT_TRUE(GetVarint32Ptr(s.data(), s.data() + len, &result) == NULL);
  }
  ASSERT_TRUE(GetVarint32Ptr(s.data(), s.data() + s.size(), &result) != NULL);
  ASSERT_EQ(large_value, result);
}",34,,141,1,,void
85335,BLOCK,-1,,<empty>,3,,146,1,,void
85350,BLOCK,4,,"{
    ASSERT_TRUE(GetVarint32Ptr(s.data(), s.data() + len, &result) == NULL);
  }",51,,146,4,,void
85352,BLOCK,1,,<empty>,,,,4,,void
85381,BLOCK,1,,<empty>,,,,5,,void
85415,BLOCK,1,,<empty>,,,,5,,void
85433,BLOCK,-1,,<empty>,,,,1,,<empty>
85437,BLOCK,-1,,"TEST(Coding, Varint64Overflow)",1,,153,1,,void
85461,BLOCK,-1,,"{
  uint64_t result;
  std::string input(""\x81\x82\x83\x84\x85\x81\x82\x83\x84\x85\x11"");
  ASSERT_TRUE(GetVarint64Ptr(input.data(), input.data() + input.size(), &result)
              == NULL);
}",32,,153,1,,void
85467,BLOCK,1,,<empty>,,,,5,,void
85502,BLOCK,-1,,<empty>,,,,1,,<empty>
85506,BLOCK,-1,,"TEST(Coding, Varint64Truncation)",1,,160,1,,void
85530,BLOCK,-1,,"{
  uint64_t large_value = (1ull << 63) + 100ull;
  std::string s;
  PutVarint64(&s, large_value);
  uint64_t result;
  for (size_t len = 0; len < s.size() - 1; len++) {
    ASSERT_TRUE(GetVarint64Ptr(s.data(), s.data() + len, &result) == NULL);
  }
  ASSERT_TRUE(GetVarint64Ptr(s.data(), s.data() + s.size(), &result) != NULL);
  ASSERT_EQ(large_value, result);
}",34,,160,1,,void
85546,BLOCK,-1,,<empty>,3,,165,1,,void
85561,BLOCK,4,,"{
    ASSERT_TRUE(GetVarint64Ptr(s.data(), s.data() + len, &result) == NULL);
  }",51,,165,4,,void
85563,BLOCK,1,,<empty>,,,,4,,void
85592,BLOCK,1,,<empty>,,,,5,,void
85626,BLOCK,1,,<empty>,,,,5,,void
85644,BLOCK,-1,,<empty>,,,,1,,<empty>
85648,BLOCK,-1,,"TEST(Coding, Strings)",1,,172,1,,void
85672,BLOCK,-1,,"{
  std::string s;
  PutLengthPrefixedSlice(&s, Slice(""""));
  PutLengthPrefixedSlice(&s, Slice(""foo""));
  PutLengthPrefixedSlice(&s, Slice(""bar""));
  PutLengthPrefixedSlice(&s, Slice(std::string(200, 'x')));

  Slice input(s);
  Slice v;
  ASSERT_TRUE(GetLengthPrefixedSlice(&input, &v));
  ASSERT_EQ("""", v.ToString());
  ASSERT_TRUE(GetLengthPrefixedSlice(&input, &v));
  ASSERT_EQ(""foo"", v.ToString());
  ASSERT_TRUE(GetLengthPrefixedSlice(&input, &v));
  ASSERT_EQ(""bar"", v.ToString());
  ASSERT_TRUE(GetLengthPrefixedSlice(&input, &v));
  ASSERT_EQ(std::string(200, 'x'), v.ToString());
  ASSERT_EQ("""", input.ToString());
}",23,,172,1,,void
85704,BLOCK,1,,<empty>,,,,3,,void
85728,BLOCK,1,,<empty>,,,,4,,void
85746,BLOCK,1,,<empty>,,,,3,,void
85770,BLOCK,1,,<empty>,,,,4,,void
85788,BLOCK,1,,<empty>,,,,3,,void
85812,BLOCK,1,,<empty>,,,,4,,void
85830,BLOCK,1,,<empty>,,,,3,,void
85853,BLOCK,1,,<empty>,,,,3,,void
85881,BLOCK,1,,<empty>,,,,4,,void
85903,BLOCK,-1,,"{
  return leveldb::test::RunAllTests();
}",33,,194,3,,void
85929,BLOCK,-1,,<empty>,1,,1,1,,ANY
85932,BLOCK,-1,,{ },27,,14,1,,void
85938,BLOCK,-1,,{ },28,,19,1,,void
85942,BLOCK,-1,,"{
    return ""leveldb.BytewiseComparator"";
  }",36,,21,1,,void
85950,BLOCK,-1,,"{
    return a.compare(b);
  }",61,,25,3,,void
85962,BLOCK,-1,,"{
    // Find length of common prefix
    size_t min_length = std::min(start->size(), limit.size());
    size_t diff_index = 0;
    while ((diff_index < min_length) &&
           ((*start)[diff_index] == limit[diff_index])) {
      diff_index++;
    }

    if (diff_index >= min_length) {
      // Do not shorten if one string is a prefix of the other
    } else {
      uint8_t diff_byte = static_cast<uint8_t>((*start)[diff_index]);
      if (diff_byte < static_cast<uint8_t>(0xff) &&
          diff_byte + 1 < static_cast<uint8_t>(limit[diff_index])) {
        (*start)[diff_index]++;
        start->resize(diff_index + 1);
        assert(Compare(*start, limit) < 0);
      }
    }
  }",33,,31,3,,void
85995,BLOCK,-1,,"{
      diff_index++;
    }",57,,36,2,,void
86002,BLOCK,-1,,"{
      // Do not shorten if one string is a prefix of the other
    }",35,,40,2,,void
86004,BLOCK,-1,,"{
      uint8_t diff_byte = static_cast<uint8_t>((*start)[diff_index]);
      if (diff_byte < static_cast<uint8_t>(0xff) &&
          diff_byte + 1 < static_cast<uint8_t>(limit[diff_index])) {
        (*start)[diff_index]++;
        start->resize(diff_index + 1);
        assert(Compare(*start, limit) < 0);
      }
    }",12,,42,1,,void
86030,BLOCK,-1,,"{
        (*start)[diff_index]++;
        start->resize(diff_index + 1);
        assert(Compare(*start, limit) < 0);
      }",68,,45,2,,void
86054,BLOCK,-1,,"{
    // Find first character that can be incremented
    size_t n = key->size();
    for (size_t i = 0; i < n; i++) {
      const uint8_t byte = (*key)[i];
      if (byte != static_cast<uint8_t>(0xff)) {
        (*key)[i] = byte + 1;
        key->resize(i+1);
        return;
      }
    }
    // *key is a run of 0xffs.  Leave it alone.
  }",59,,53,2,,void
86063,BLOCK,-1,,<empty>,5,,56,1,,void
86073,BLOCK,4,,"{
      const uint8_t byte = (*key)[i];
      if (byte != static_cast<uint8_t>(0xff)) {
        (*key)[i] = byte + 1;
        key->resize(i+1);
        return;
      }
    }",36,,56,4,,void
86087,BLOCK,-1,,"{
        (*key)[i] = byte + 1;
        key->resize(i+1);
        return;
      }",47,,58,2,,void
86112,BLOCK,-1,,"{
  bytewise = new BytewiseComparatorImpl;
}",26,,72,1,,void
86120,BLOCK,-1,,"{
  port::InitOnce(&once, InitModule);
  return bytewise;
}",40,,76,1,,void
86144,BLOCK,-1,,<empty>,1,,1,1,,ANY
87189,BLOCK,-1,,"{
  return DecodeFixed32(reinterpret_cast<const char*>(p));
}",52,,284,2,,void
87198,BLOCK,-1,,"{
  // port::AcceleretedCRC32C returns zero when unable to accelerate.
  static const char kTestCRCBuffer[] = ""TestCRCBuffer"";
  static const char kBufSize = sizeof(kTestCRCBuffer) - 1;
  static const uint32_t kTestCRCValue = 0xdcbc59fa;

  return port::AcceleratedCRC32C(0, kTestCRCBuffer, kBufSize) == kTestCRCValue;
}",35,,290,1,,void
87230,BLOCK,-1,,"{
  static bool accelerate = CanAccelerateCRC32C();
  if (accelerate) {
    return port::AcceleratedCRC32C(crc, buf, size);
  }

  const uint8_t *p = reinterpret_cast<const uint8_t *>(buf);
  const uint8_t *e = p + size;
  uint32_t l = crc ^ 0xffffffffu;

#define STEP1 do {                              \
    int c = (l & 0xff) ^ *p++;                  \
    l = table0_[c] ^ (l >> 8);                  \
} while (0)
#define STEP4 do {                              \
    uint32_t c = l ^ LE_LOAD32(p);              \
    p += 4;                                     \
    l = table3_[c & 0xff] ^                     \
        table2_[(c >> 8) & 0xff] ^              \
        table1_[(c >> 16) & 0xff] ^             \
        table0_[c >> 24];                       \
} while (0)

  // Point x at first 4-byte aligned byte in string.  This might be
  // just past the end of the string.
  const uintptr_t pval = reinterpret_cast<uintptr_t>(p);
  const uint8_t* x = reinterpret_cast<const uint8_t*>...",61,,299,4,,void
87237,BLOCK,-1,,"{
    return port::AcceleratedCRC32C(crc, buf, size);
  }",19,,301,2,,void
87286,BLOCK,-1,,"{
    // Process bytes until finished or p is 4-byte aligned
    while (p != x) {
      STEP1;
    }
  }",15,,326,2,,void
87291,BLOCK,-1,,"{
      STEP1;
    }",20,,328,2,,void
87294,BLOCK,1,,<empty>,,,,7,,void
87296,BLOCK,-1,,STEP1,7,,329,1,,void
87323,BLOCK,-1,,"{
    STEP4; STEP4; STEP4; STEP4;
  }",23,,333,2,,void
87326,BLOCK,1,,<empty>,,,,13,,void
87328,BLOCK,-1,,STEP4,5,,334,1,,void
87371,BLOCK,1,,<empty>,,,,13,,void
87373,BLOCK,-1,,STEP4,12,,334,1,,void
87416,BLOCK,1,,<empty>,,,,13,,void
87418,BLOCK,-1,,STEP4,19,,334,1,,void
87461,BLOCK,1,,<empty>,,,,13,,void
87463,BLOCK,-1,,STEP4,26,,334,1,,void
87510,BLOCK,-1,,"{
    STEP4;
  }",22,,337,2,,void
87513,BLOCK,1,,<empty>,,,,13,,void
87515,BLOCK,-1,,STEP4,5,,338,1,,void
87560,BLOCK,-1,,"{
    STEP1;
  }",18,,341,2,,void
87563,BLOCK,1,,<empty>,,,,7,,void
87565,BLOCK,-1,,STEP1,5,,342,1,,void
87600,BLOCK,-1,,<empty>,1,,1,1,,ANY
87607,BLOCK,-1,,<empty>,,,,4,,<empty>
87613,BLOCK,-1,,"{
  return Extend(0, data, n);
}",51,,20,3,,void
87627,BLOCK,-1,,"{
  // Rotate right by 15 bits and add a constant.
  return ((crc >> 15) | (crc << 17)) + kMaskDelta;
}",36,,31,2,,void
87642,BLOCK,-1,,"{
  uint32_t rot = masked_crc - kMaskDelta;
  return ((rot >> 17) | (rot << 15));
}",45,,37,2,,void
87667,BLOCK,-1,,<empty>,1,,1,1,,ANY
87673,BLOCK,-1,,<empty>,,,,1,,<empty>
87677,BLOCK,-1,,"TEST(CRC, StandardResults)",1,,13,1,,void
87701,BLOCK,-1,,"{
  // From rfc3720 section B.4.
  char buf[32];

  memset(buf, 0, sizeof(buf));
  ASSERT_EQ(0x8a9136aa, Value(buf, sizeof(buf)));

  memset(buf, 0xff, sizeof(buf));
  ASSERT_EQ(0x62a8ab43, Value(buf, sizeof(buf)));

  for (int i = 0; i < 32; i++) {
    buf[i] = i;
  }
  ASSERT_EQ(0x46dd794e, Value(buf, sizeof(buf)));

  for (int i = 0; i < 32; i++) {
    buf[i] = 31 - i;
  }
  ASSERT_EQ(0x113fdb5c, Value(buf, sizeof(buf)));

  unsigned char data[48] = {
    0x01, 0xc0, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x14, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x04, 0x00,
    0x00, 0x00, 0x00, 0x14,
    0x00, 0x00, 0x00, 0x18,
    0x28, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x02, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
  };
  ASSERT_EQ(0xd9963a56, Value(reinterpret_cast<char*>(data), sizeof(data)));
}",28,,13,1,,void
87710,BLOCK,1,,<empty>,,,,4,,void
87734,BLOCK,1,,<empty>,,,,4,,void
87752,BLOCK,-1,,<empty>,3,,23,1,,void
87762,BLOCK,4,,"{
    buf[i] = i;
  }",32,,23,4,,void
87770,BLOCK,1,,<empty>,,,,4,,void
87788,BLOCK,-1,,<empty>,3,,28,1,,void
87798,BLOCK,4,,"{
    buf[i] = 31 - i;
  }",32,,28,4,,void
87808,BLOCK,1,,<empty>,,,,4,,void
87879,BLOCK,1,,<empty>,,,,4,,void
87902,BLOCK,-1,,<empty>,,,,1,,<empty>
87906,BLOCK,-1,,"TEST(CRC, Values)",1,,50,1,,void
87930,BLOCK,-1,,"{
  ASSERT_NE(Value(""a"", 1), Value(""foo"", 3));
}",19,,50,1,,void
87932,BLOCK,1,,<empty>,,,,1,,void
87954,BLOCK,-1,,<empty>,,,,1,,<empty>
87958,BLOCK,-1,,"TEST(CRC, Extend)",1,,54,1,,void
87982,BLOCK,-1,,"{
  ASSERT_EQ(Value(""hello world"", 11),
            Extend(Value(""hello "", 6), ""world"", 5));
}",19,,54,1,,void
87984,BLOCK,1,,<empty>,,,,1,,void
88009,BLOCK,-1,,<empty>,,,,1,,<empty>
88013,BLOCK,-1,,"TEST(CRC, Mask)",1,,59,1,,void
88037,BLOCK,-1,,"{
  uint32_t crc = Value(""foo"", 3);
  ASSERT_NE(crc, Mask(crc));
  ASSERT_NE(crc, Mask(Mask(crc)));
  ASSERT_EQ(crc, Unmask(Mask(crc)));
  ASSERT_EQ(crc, Unmask(Unmask(Mask(Mask(crc)))));
}",17,,59,1,,void
88048,BLOCK,1,,<empty>,,,,5,,void
88068,BLOCK,1,,<empty>,,,,5,,void
88089,BLOCK,1,,<empty>,,,,5,,void
88112,BLOCK,1,,<empty>,,,,5,,void
88135,BLOCK,-1,,"{
  return leveldb::test::RunAllTests();
}",33,,70,3,,void
88151,BLOCK,-1,,<empty>,1,,1,1,,ANY
88154,BLOCK,-1,,"{
}",13,,9,1,,void
88160,BLOCK,-1,,"{
  return Status::NotSupported(""NewAppendableFile"", fname);
}",80,,12,3,,void
88171,BLOCK,-1,,"{
}",35,,16,1,,void
88175,BLOCK,-1,,"{
}",39,,19,1,,void
88179,BLOCK,-1,,"{
}",31,,22,1,,void
88183,BLOCK,-1,,"{
}",19,,25,1,,void
88187,BLOCK,-1,,"{
}",23,,28,1,,void
88193,BLOCK,-1,,"{
  if (info_log != NULL) {
    va_list ap;
    va_start(ap, format);
    info_log->Logv(format, ap);
    va_end(ap);
  }
}",53,,31,3,,void
88198,BLOCK,-1,,"{
    va_list ap;
    va_start(ap, format);
    info_log->Logv(format, ap);
    va_end(ap);
  }",25,,32,2,,void
88218,BLOCK,-1,,"{
  WritableFile* file;
  Status s = env->NewWritableFile(fname, &file);
  if (!s.ok()) {
    return s;
  }
  s = file->Append(data);
  if (s.ok() && should_sync) {
    s = file->Sync();
  }
  if (s.ok()) {
    s = file->Close();
  }
  delete file;  // Will auto-close if we did not close above
  if (!s.ok()) {
    env->DeleteFile(fname);
  }
  return s;
}",53,,42,5,,void
88236,BLOCK,-1,,"{
    return s;
  }",16,,45,2,,void
88253,BLOCK,-1,,"{
    s = file->Sync();
  }",30,,49,2,,void
88265,BLOCK,-1,,"{
    s = file->Close();
  }",15,,52,2,,void
88280,BLOCK,-1,,"{
    env->DeleteFile(fname);
  }",16,,56,2,,void
88294,BLOCK,-1,,"{
  return DoWriteStringToFile(env, data, fname, false);
}",52,,63,4,,void
88307,BLOCK,-1,,"{
  return DoWriteStringToFile(env, data, fname, true);
}",56,,68,4,,void
88320,BLOCK,-1,,"{
  data->clear();
  SequentialFile* file;
  Status s = env->NewSequentialFile(fname, &file);
  if (!s.ok()) {
    return s;
  }
  static const int kBufferSize = 8192;
  char* space = new char[kBufferSize];
  while (true) {
    Slice fragment;
    s = file->Read(kBufferSize, &fragment, space);
    if (!s.ok()) {
      break;
    }
    data->append(fragment.data(), fragment.size());
    if (fragment.empty()) {
      break;
    }
  }
  delete[] space;
  delete file;
  return s;
}",80,,72,4,,void
88342,BLOCK,-1,,"{
    return s;
  }",16,,76,2,,void
88356,BLOCK,-1,,"{
    Slice fragment;
    s = file->Read(kBufferSize, &fragment, space);
    if (!s.ok()) {
      break;
    }
    data->append(fragment.data(), fragment.size());
    if (fragment.empty()) {
      break;
    }
  }",16,,81,2,,void
88374,BLOCK,-1,,"{
      break;
    }",18,,84,2,,void
88393,BLOCK,-1,,"{
      break;
    }",27,,88,2,,void
88404,BLOCK,-1,,"{
}",27,,97,1,,void
88459,BLOCK,-1,,<empty>,1,,1,1,,ANY
88475,BLOCK,-1,,"{
  return Status::IOError(context, strerror(err_number));
}",67,,37,3,,void
88489,BLOCK,-1,,"{
    SetAllowed(n);
  }",23,,48,2,,void
88495,BLOCK,-1,,"{
    if (GetAllowed() <= 0) {
      return false;
    }
    MutexLock l(&mu_);
    intptr_t x = GetAllowed();
    if (x <= 0) {
      return false;
    } else {
      SetAllowed(x - 1);
      return true;
    }
  }",18,,54,1,,void
88500,BLOCK,-1,,"{
      return false;
    }",28,,55,2,,void
88515,BLOCK,-1,,"{
      return false;
    }",17,,60,2,,void
88519,BLOCK,-1,,"{
      SetAllowed(x - 1);
      return true;
    }",12,,62,1,,void
88529,BLOCK,-1,,"{
    MutexLock l(&mu_);
    SetAllowed(GetAllowed() + 1);
  }",18,,70,1,,void
88543,BLOCK,-1,,"{
    return reinterpret_cast<intptr_t>(allowed_.Acquire_Load());
  }",31,,79,1,,void
88555,BLOCK,-1,,"{
    allowed_.Release_Store(reinterpret_cast<void*>(v));
  }",31,,84,2,,void
88567,BLOCK,-1,,<empty>,,,,2,,<empty>
88572,BLOCK,-1,,<empty>,,,,2,,<empty>
88581,BLOCK,-1,,{ },36,,99,3,,void
88585,BLOCK,-1,,{ fclose(file_); },34,,100,1,,void
88594,BLOCK,-1,,"{
    Status s;
    size_t r = fread_unlocked(scratch, 1, n, file_);
    *result = Slice(scratch, r);
    if (r < n) {
      if (feof(file_)) {
        // We leave status as ok if we hit the end of the file
      } else {
        // A partial read with an error: return a non-ok status
        s = IOError(filename_, errno);
      }
    }
    return s;
  }",63,,102,4,,void
88614,BLOCK,-1,,"{
      if (feof(file_)) {
        // We leave status as ok if we hit the end of the file
      } else {
        // A partial read with an error: return a non-ok status
        s = IOError(filename_, errno);
      }
    }",16,,106,2,,void
88618,BLOCK,-1,,"{
        // We leave status as ok if we hit the end of the file
      }",24,,107,2,,void
88620,BLOCK,-1,,"{
        // A partial read with an error: return a non-ok status
        s = IOError(filename_, errno);
      }",14,,109,1,,void
88632,BLOCK,-1,,"{
    if (fseek(file_, n, SEEK_CUR)) {
      return IOError(filename_, errno);
    }
    return Status::OK();
  }",35,,117,2,,void
88638,BLOCK,-1,,"{
      return IOError(filename_, errno);
    }",36,,118,2,,void
88659,BLOCK,-1,,"{
    temporary_fd_ = !limiter->Acquire();
    if (temporary_fd_) {
      // Open file on every access.
      close(fd_);
      fd_ = -1;
    }
  }",54,,135,4,,void
88669,BLOCK,-1,,"{
      // Open file on every access.
      close(fd_);
      fd_ = -1;
    }",24,,137,2,,void
88679,BLOCK,-1,,"{
    if (!temporary_fd_) {
      close(fd_);
      limiter_->Release();
    }
  }",36,,144,1,,void
88683,BLOCK,-1,,"{
      close(fd_);
      limiter_->Release();
    }",25,,145,2,,void
88697,BLOCK,-1,,"{
    int fd = fd_;
    if (temporary_fd_) {
      fd = open(filename_.c_str(), O_RDONLY);
      if (fd < 0) {
        return IOError(filename_, errno);
      }
    }

    Status s;
    ssize_t r = pread(fd, scratch, n, static_cast<off_t>(offset));
    *result = Slice(scratch, (r < 0) ? 0 : r);
    if (r < 0) {
      // An error: return a non-ok status
      s = IOError(filename_, errno);
    }
    if (temporary_fd_) {
      // Close the temporary file descriptor opened earlier.
      close(fd);
    }
    return s;
  }",44,,152,5,,void
88704,BLOCK,-1,,"{
      fd = open(filename_.c_str(), O_RDONLY);
      if (fd < 0) {
        return IOError(filename_, errno);
      }
    }",24,,154,2,,void
88717,BLOCK,-1,,"{
        return IOError(filename_, errno);
      }",19,,156,2,,void
88748,BLOCK,-1,,"{
      // An error: return a non-ok status
      s = IOError(filename_, errno);
    }",16,,164,2,,void
88756,BLOCK,-1,,"{
      // Close the temporary file descriptor opened earlier.
      close(fd);
    }",24,,168,2,,void
88773,BLOCK,-1,,"{
  }",27,,189,5,,void
88777,BLOCK,-1,,"{
    munmap(mmapped_region_, length_);
    limiter_->Release();
  }",36,,192,1,,void
88792,BLOCK,-1,,"{
    Status s;
    if (offset + n > length_) {
      *result = Slice();
      s = IOError(filename_, EINVAL);
    } else {
      *result = Slice(reinterpret_cast<char*>(mmapped_region_) + offset, n);
    }
    return s;
  }",44,,198,5,,void
88800,BLOCK,-1,,"{
      *result = Slice();
      s = IOError(filename_, EINVAL);
    }",31,,200,2,,void
88811,BLOCK,-1,,"{
      *result = Slice(reinterpret_cast<char*>(mmapped_region_) + offset, n);
    }",12,,203,1,,void
88832,BLOCK,-1,,{ },36,,217,3,,void
88836,BLOCK,-1,,"{
    if (file_ != NULL) {
      // Ignoring any potential errors
      fclose(file_);
    }
  }",24,,219,1,,void
88841,BLOCK,-1,,"{
      // Ignoring any potential errors
      fclose(file_);
    }",24,,220,2,,void
88848,BLOCK,-1,,"{
    size_t r = fwrite_unlocked(data.data(), 1, data.size(), file_);
    if (r != data.size()) {
      return IOError(filename_, errno);
    }
    return Status::OK();
  }",44,,226,2,,void
88870,BLOCK,-1,,"{
      return IOError(filename_, errno);
    }",27,,228,2,,void
88883,BLOCK,-1,,"{
    Status result;
    if (fclose(file_) != 0) {
      result = IOError(filename_, errno);
    }
    file_ = NULL;
    return result;
  }",26,,234,1,,void
88890,BLOCK,-1,,"{
      result = IOError(filename_, errno);
    }",29,,236,2,,void
88904,BLOCK,-1,,"{
    if (fflush_unlocked(file_) != 0) {
      return IOError(filename_, errno);
    }
    return Status::OK();
  }",26,,243,1,,void
88910,BLOCK,-1,,"{
      return IOError(filename_, errno);
    }",38,,244,2,,void
88923,BLOCK,-1,,"{
    const char* f = filename_.c_str();
    const char* sep = strrchr(f, '/');
    Slice basename;
    std::string dir;
    if (sep == NULL) {
      dir = ""."";
      basename = f;
    } else {
      dir = std::string(f, sep - f);
      basename = sep + 1;
    }
    Status s;
    if (basename.starts_with(""MANIFEST"")) {
      int fd = open(dir.c_str(), O_RDONLY);
      if (fd < 0) {
        s = IOError(dir, errno);
      } else {
        if (fsync(fd) < 0) {
          s = IOError(dir, errno);
        }
        close(fd);
      }
    }
    return s;
  }",30,,250,1,,void
88943,BLOCK,-1,,"{
      dir = ""."";
      basename = f;
    }",22,,255,2,,void
88951,BLOCK,-1,,"{
      dir = std::string(f, sep - f);
      basename = sep + 1;
    }",12,,258,1,,void
88974,BLOCK,-1,,"{
      int fd = open(dir.c_str(), O_RDONLY);
      if (fd < 0) {
        s = IOError(dir, errno);
      } else {
        if (fsync(fd) < 0) {
          s = IOError(dir, errno);
        }
        close(fd);
      }
    }",43,,263,2,,void
88988,BLOCK,-1,,"{
        s = IOError(dir, errno);
      }",19,,265,2,,void
88995,BLOCK,-1,,"{
        if (fsync(fd) < 0) {
          s = IOError(dir, errno);
        }
        close(fd);
      }",14,,267,1,,void
89001,BLOCK,-1,,"{
          s = IOError(dir, errno);
        }",28,,268,2,,void
89014,BLOCK,-1,,"{
    // Ensure new files referred to by the manifest are in the filesystem.
    Status s = SyncDirIfManifest();
    if (!s.ok()) {
      return s;
    }
    if (fflush_unlocked(file_) != 0 ||
        fdatasync(fileno(file_)) != 0) {
      s = Status::IOError(filename_, strerror(errno));
    }
    return s;
  }",25,,277,1,,void
89025,BLOCK,-1,,"{
      return s;
    }",18,,280,2,,void
89039,BLOCK,-1,,"{
      s = Status::IOError(filename_, strerror(errno));
    }",40,,284,2,,void
89056,BLOCK,-1,,"{
  errno = 0;
  struct flock f;
  memset(&f, 0, sizeof(f));
  f.l_type = (lock ? F_WRLCK : F_UNLCK);
  f.l_whence = SEEK_SET;
  f.l_start = 0;
  f.l_len = 0;        // Lock/unlock entire file
  return fcntl(fd, F_SETLK, &f);
}",44,,291,3,,void
89106,BLOCK,-1,,"{
    MutexLock l(&mu_);
    return locked_files_.insert(fname).second;
  }",41,,316,2,,void
89123,BLOCK,-1,,"{
    MutexLock l(&mu_);
    locked_files_.erase(fname);
  }",41,,320,2,,void
89137,BLOCK,-1,,<empty>,,,,1,,<empty>
89141,BLOCK,-1,,"{
    char msg[] = ""Destroying Env::Default()\n"";
    fwrite(msg, 1, sizeof(msg), stderr);
    abort();
  }",23,,329,1,,void
89158,BLOCK,-1,,"{
    FILE* f = fopen(fname.c_str(), ""r"");
    if (f == NULL) {
      *result = NULL;
      return IOError(fname, errno);
    } else {
      *result = new PosixSequentialFile(fname, f);
      return Status::OK();
    }
  }",61,,336,3,,void
89172,BLOCK,-1,,"{
      *result = NULL;
      return IOError(fname, errno);
    }",20,,338,2,,void
89182,BLOCK,-1,,"{
      *result = new PosixSequentialFile(fname, f);
      return Status::OK();
    }",12,,341,1,,void
89200,BLOCK,-1,,"{
    *result = NULL;
    Status s;
    int fd = open(fname.c_str(), O_RDONLY);
    if (fd < 0) {
      s = IOError(fname, errno);
    } else if (mmap_limit_.Acquire()) {
      uint64_t size;
      s = GetFileSize(fname, &size);
      if (s.ok()) {
        void* base = mmap(NULL, size, PROT_READ, MAP_SHARED, fd, 0);
        if (base != MAP_FAILED) {
          *result = new PosixMmapReadableFile(fname, base, size, &mmap_limit_);
        } else {
          s = IOError(fname, errno);
        }
      }
      close(fd);
      if (!s.ok()) {
        mmap_limit_.Release();
      }
    } else {
      *result = new PosixRandomAccessFile(fname, fd, &fd_limit_);
    }
    return s;
  }",65,,348,3,,void
89219,BLOCK,-1,,"{
      s = IOError(fname, errno);
    }",17,,352,2,,void
89226,BLOCK,-1,,<empty>,12,,354,1,,void
89232,BLOCK,-1,,"{
      uint64_t size;
      s = GetFileSize(fname, &size);
      if (s.ok()) {
        void* base = mmap(NULL, size, PROT_READ, MAP_SHARED, fd, 0);
        if (base != MAP_FAILED) {
          *result = new PosixMmapReadableFile(fname, base, size, &mmap_limit_);
        } else {
          s = IOError(fname, errno);
        }
      }
      close(fd);
      if (!s.ok()) {
        mmap_limit_.Release();
      }
    }",39,,354,2,,void
89245,BLOCK,-1,,"{
        void* base = mmap(NULL, size, PROT_READ, MAP_SHARED, fd, 0);
        if (base != MAP_FAILED) {
          *result = new PosixMmapReadableFile(fname, base, size, &mmap_limit_);
        } else {
          s = IOError(fname, errno);
        }
      }",19,,357,2,,void
89260,BLOCK,-1,,"{
          *result = new PosixMmapReadableFile(fname, base, size, &mmap_limit_);
        }",33,,359,2,,void
89272,BLOCK,-1,,"{
          s = IOError(fname, errno);
        }",16,,361,1,,void
89286,BLOCK,-1,,"{
        mmap_limit_.Release();
      }",20,,366,2,,void
89292,BLOCK,-1,,"{
      *result = new PosixRandomAccessFile(fname, fd, &fd_limit_);
    }",12,,369,1,,void
89309,BLOCK,-1,,"{
    Status s;
    FILE* f = fopen(fname.c_str(), ""w"");
    if (f == NULL) {
      *result = NULL;
      s = IOError(fname, errno);
    } else {
      *result = new PosixWritableFile(fname, f);
    }
    return s;
  }",57,,376,3,,void
89324,BLOCK,-1,,"{
      *result = NULL;
      s = IOError(fname, errno);
    }",20,,379,2,,void
89335,BLOCK,-1,,"{
      *result = new PosixWritableFile(fname, f);
    }",12,,382,1,,void
89350,BLOCK,-1,,"{
    Status s;
    FILE* f = fopen(fname.c_str(), ""a"");
    if (f == NULL) {
      *result = NULL;
      s = IOError(fname, errno);
    } else {
      *result = new PosixWritableFile(fname, f);
    }
    return s;
  }",59,,389,3,,void
89365,BLOCK,-1,,"{
      *result = NULL;
      s = IOError(fname, errno);
    }",20,,392,2,,void
89376,BLOCK,-1,,"{
      *result = new PosixWritableFile(fname, f);
    }",12,,395,1,,void
89390,BLOCK,-1,,"{
    return access(fname.c_str(), F_OK) == 0;
  }",53,,401,2,,void
89405,BLOCK,-1,,"{
    result->clear();
    DIR* d = opendir(dir.c_str());
    if (d == NULL) {
      return IOError(dir, errno);
    }
    struct dirent* entry;
    while ((entry = readdir(d)) != NULL) {
      result->push_back(entry->d_name);
    }
    closedir(d);
    return Status::OK();
  }",64,,406,3,,void
89422,BLOCK,-1,,"{
      return IOError(dir, errno);
    }",20,,409,2,,void
89435,BLOCK,-1,,"{
      result->push_back(entry->d_name);
    }",42,,413,2,,void
89454,BLOCK,-1,,"{
    Status result;
    if (unlink(fname.c_str()) != 0) {
      result = IOError(fname, errno);
    }
    return result;
  }",55,,420,2,,void
89464,BLOCK,-1,,"{
      result = IOError(fname, errno);
    }",37,,422,2,,void
89476,BLOCK,-1,,"{
    Status result;
    if (mkdir(name.c_str(), 0755) != 0) {
      result = IOError(name, errno);
    }
    return result;
  }",53,,428,2,,void
89487,BLOCK,-1,,"{
      result = IOError(name, errno);
    }",41,,430,2,,void
89499,BLOCK,-1,,"{
    Status result;
    if (rmdir(name.c_str()) != 0) {
      result = IOError(name, errno);
    }
    return result;
  }",53,,436,2,,void
89509,BLOCK,-1,,"{
      result = IOError(name, errno);
    }",35,,438,2,,void
89522,BLOCK,-1,,"{
    Status s;
    struct stat sbuf;
    if (stat(fname.c_str(), &sbuf) != 0) {
      *size = 0;
      s = IOError(fname, errno);
    } else {
      *size = sbuf.st_size;
    }
    return s;
  }",72,,444,3,,void
89535,BLOCK,-1,,"{
      *size = 0;
      s = IOError(fname, errno);
    }",42,,447,2,,void
89546,BLOCK,-1,,"{
      *size = sbuf.st_size;
    }",12,,450,1,,void
89560,BLOCK,-1,,"{
    Status result;
    if (rename(src.c_str(), target.c_str()) != 0) {
      result = IOError(src, errno);
    }
    return result;
  }",80,,456,3,,void
89574,BLOCK,-1,,"{
      result = IOError(src, errno);
    }",51,,458,2,,void
89587,BLOCK,-1,,"{
    *lock = NULL;
    Status result;
    int fd = open(fname.c_str(), O_RDWR | O_CREAT, 0644);
    if (fd < 0) {
      result = IOError(fname, errno);
    } else if (!locks_.Insert(fname)) {
      close(fd);
      result = Status::IOError(""lock "" + fname, ""already held by process"");
    } else if (LockOrUnlock(fd, true) == -1) {
      result = IOError(""lock "" + fname, errno);
      close(fd);
      locks_.Remove(fname);
    } else {
      PosixFileLock* my_lock = new PosixFileLock;
      my_lock->fd_ = fd;
      my_lock->name_ = fname;
      *lock = my_lock;
    }
    return result;
  }",70,,464,3,,void
89609,BLOCK,-1,,"{
      result = IOError(fname, errno);
    }",17,,468,2,,void
89616,BLOCK,-1,,<empty>,12,,470,1,,void
89624,BLOCK,-1,,"{
      close(fd);
      result = Status::IOError(""lock "" + fname, ""already held by process"");
    }",39,,470,2,,void
89638,BLOCK,-1,,<empty>,12,,473,1,,void
89646,BLOCK,-1,,"{
      result = IOError(""lock "" + fname, errno);
      close(fd);
      locks_.Remove(fname);
    }",46,,473,2,,void
89662,BLOCK,-1,,"{
      PosixFileLock* my_lock = new PosixFileLock;
      my_lock->fd_ = fd;
      my_lock->name_ = fname;
      *lock = my_lock;
    }",12,,477,1,,void
89688,BLOCK,-1,,"{
    PosixFileLock* my_lock = reinterpret_cast<PosixFileLock*>(lock);
    Status result;
    if (LockOrUnlock(my_lock->fd_, false) == -1) {
      result = IOError(""unlock"", errno);
    }
    locks_.Remove(my_lock->name_);
    close(my_lock->fd_);
    delete my_lock;
    return result;
  }",45,,486,2,,void
89705,BLOCK,-1,,"{
      result = IOError(""unlock"", errno);
    }",50,,489,2,,void
89731,BLOCK,-1,,<empty>,,,,3,,<empty>
89737,BLOCK,-1,,<empty>,,,,3,,<empty>
89742,BLOCK,-1,,"{
    const char* env = getenv(""TEST_TMPDIR"");
    if (env && env[0] != '\0') {
      *result = env;
    } else {
      char buf[100];
      snprintf(buf, sizeof(buf), ""/tmp/leveldbtest-%d"", int(geteuid()));
      *result = buf;
    }
    // Directory may already exist
    CreateDir(*result);
    return Status::OK();
  }",56,,502,2,,void
89756,BLOCK,-1,,"{
      *result = env;
    }",32,,504,2,,void
89762,BLOCK,-1,,"{
      char buf[100];
      snprintf(buf, sizeof(buf), ""/tmp/leveldbtest-%d"", int(geteuid()));
      *result = buf;
    }",12,,506,1,,void
89787,BLOCK,-1,,"{
    pthread_t tid = pthread_self();
    uint64_t thread_id = 0;
    memcpy(&thread_id, &tid, std::min(sizeof(thread_id), sizeof(tid)));
    return thread_id;
  }",28,,516,1,,void
89816,BLOCK,-1,,"{
    FILE* f = fopen(fname.c_str(), ""w"");
    if (f == NULL) {
      *result = NULL;
      return IOError(fname, errno);
    } else {
      *result = new PosixLogger(f, &PosixEnv::gettid);
      return Status::OK();
    }
  }",71,,523,3,,void
89830,BLOCK,-1,,"{
      *result = NULL;
      return IOError(fname, errno);
    }",20,,525,2,,void
89840,BLOCK,-1,,"{
      *result = new PosixLogger(f, &PosixEnv::gettid);
      return Status::OK();
    }",12,,528,1,,void
89859,BLOCK,-1,,"{
    struct timeval tv;
    gettimeofday(&tv, NULL);
    return static_cast<uint64_t>(tv.tv_sec) * 1000000 + tv.tv_usec;
  }",32,,534,1,,void
89881,BLOCK,-1,,"{
    usleep(micros);
  }",49,,540,2,,void
89889,BLOCK,-1,,"{
    if (result != 0) {
      fprintf(stderr, ""pthread %s: %s\n"", label, strerror(result));
      abort();
    }
  }",51,,545,3,,void
89894,BLOCK,-1,,"{
      fprintf(stderr, ""pthread %s: %s\n"", label, strerror(result));
      abort();
    }",22,,546,2,,void
89905,BLOCK,-1,,<empty>,,,,1,,<empty>
89910,BLOCK,-1,,"{
    reinterpret_cast<PosixEnv*>(arg)->BGThread();
    return NULL;
  }",43,,554,2,,void
89929,BLOCK,-1,,<empty>,,,,2,,<empty>
89938,BLOCK,-1,,"{
  if (mmap_limit >= 0) {
    return mmap_limit;
  }
  // Up to 1000 mmaps for 64-bit binaries; none for smaller pointer sizes.
  mmap_limit = sizeof(void*) >= 8 ? 1000 : 0;
  return mmap_limit;
}",23,,575,1,,void
89943,BLOCK,-1,,"{
    return mmap_limit;
  }",24,,576,2,,void
89960,BLOCK,-1,,"{
  if (open_read_only_file_limit >= 0) {
    return open_read_only_file_limit;
  }
  struct rlimit rlim;
  if (getrlimit(RLIMIT_NOFILE, &rlim)) {
    // getrlimit failed, fallback to hard-coded default.
    open_read_only_file_limit = 50;
  } else if (rlim.rlim_cur == RLIM_INFINITY) {
    open_read_only_file_limit = std::numeric_limits<int>::max();
  } else {
    // Allow use of 20% of available file descriptors for read-only files.
    open_read_only_file_limit = rlim.rlim_cur / 5;
  }
  return open_read_only_file_limit;
}",32,,585,1,,void
89965,BLOCK,-1,,"{
    return open_read_only_file_limit;
  }",39,,586,2,,void
89974,BLOCK,-1,,"{
    // getrlimit failed, fallback to hard-coded default.
    open_read_only_file_limit = 50;
  }",40,,590,2,,void
89979,BLOCK,-1,,<empty>,10,,593,1,,void
89986,BLOCK,-1,,"{
    open_read_only_file_limit = std::numeric_limits<int>::max();
  }",46,,593,2,,void
89996,BLOCK,-1,,"{
    // Allow use of 20% of available file descriptors for read-only files.
    open_read_only_file_limit = rlim.rlim_cur / 5;
  }",10,,595,1,,void
90009,BLOCK,-1,,"{
  PthreadCall(""mutex_init"", pthread_mutex_init(&mu_, NULL));
  PthreadCall(""cvar_init"", pthread_cond_init(&bgsignal_, NULL));
}",33,,605,1,,void
90027,BLOCK,-1,,"{
  PthreadCall(""lock"", pthread_mutex_lock(&mu_));

  // Start background thread if necessary
  if (!started_bgthread_) {
    started_bgthread_ = true;
    PthreadCall(
        ""create thread"",
        pthread_create(&bgthread_, NULL,  &PosixEnv::BGThreadWrapper, this));
  }

  // If the queue is currently empty, the background thread may currently be
  // waiting.
  if (queue_.empty()) {
    PthreadCall(""signal"", pthread_cond_signal(&bgsignal_));
  }

  // Add to priority queue
  queue_.push_back(BGItem());
  queue_.back().function = function;
  queue_.back().arg = arg;

  PthreadCall(""unlock"", pthread_mutex_unlock(&mu_));
}",61,,610,3,,void
90036,BLOCK,-1,,"{
    started_bgthread_ = true;
    PthreadCall(
        ""create thread"",
        pthread_create(&bgthread_, NULL,  &PosixEnv::BGThreadWrapper, this));
  }",27,,614,2,,void
90056,BLOCK,-1,,"{
    PthreadCall(""signal"", pthread_cond_signal(&bgsignal_));
  }",23,,623,2,,void
90091,BLOCK,-1,,"{
  while (true) {
    // Wait until there is an item that is ready to run
    PthreadCall(""lock"", pthread_mutex_lock(&mu_));
    while (queue_.empty()) {
      PthreadCall(""wait"", pthread_cond_wait(&bgsignal_, &mu_));
    }

    void (*function)(void*) = queue_.front().function;
    void* arg = queue_.front().arg;
    queue_.pop_front();

    PthreadCall(""unlock"", pthread_mutex_unlock(&mu_));
    (*function)(arg);
  }
}",27,,635,1,,void
90094,BLOCK,-1,,"{
    // Wait until there is an item that is ready to run
    PthreadCall(""lock"", pthread_mutex_lock(&mu_));
    while (queue_.empty()) {
      PthreadCall(""wait"", pthread_cond_wait(&bgsignal_, &mu_));
    }

    void (*function)(void*) = queue_.front().function;
    void* arg = queue_.front().arg;
    queue_.pop_front();

    PthreadCall(""unlock"", pthread_mutex_unlock(&mu_));
    (*function)(arg);
  }",16,,636,2,,void
90105,BLOCK,-1,,"{
      PthreadCall(""wait"", pthread_cond_wait(&bgsignal_, &mu_));
    }",28,,639,2,,void
90115,BLOCK,-1,,<empty>,,,,2,,<empty>
90146,BLOCK,-1,,<empty>,,,,2,,<empty>
90152,BLOCK,-1,,"{
  StartThreadState* state = reinterpret_cast<StartThreadState*>(arg);
  state->user_function(state->arg);
  delete state;
  return NULL;
}",44,,658,2,,void
90175,BLOCK,-1,,"{
  pthread_t t;
  StartThreadState* state = new StartThreadState;
  state->user_function = function;
  state->arg = arg;
  PthreadCall(""start thread"",
              pthread_create(&t, NULL,  &StartThreadWrapper, state));
}",68,,665,3,,void
90209,BLOCK,-1,,{ default_env = new PosixEnv; },30,,678,1,,void
90218,BLOCK,-1,,"{
  assert(default_env == NULL);
  open_read_only_file_limit = limit;
}",56,,680,2,,void
90230,BLOCK,-1,,"{
  assert(default_env == NULL);
  mmap_limit = limit;
}",58,,685,2,,void
90241,BLOCK,-1,,"{
  pthread_once(&once, InitDefaultEnv);
  return default_env;
}",21,,690,1,,void
90262,BLOCK,-1,,<empty>,1,,1,1,,ANY
90279,BLOCK,-1,,{ },41,,20,1,,void
90285,BLOCK,-1,,"{
    EnvPosixTestHelper::SetReadOnlyFDLimit(read_only_file_limit);
    EnvPosixTestHelper::SetReadOnlyMMapLimit(mmap_limit);
  }",71,,22,3,,void
90300,BLOCK,-1,,<empty>,,,,1,,<empty>
90304,BLOCK,-1,,"TEST(EnvPosixTest, TestOpenOnRead)",1,,28,1,,void
90328,BLOCK,-1,,"{
  // Write some test data to a single file that will be opened |n| times.
  std::string test_dir;
  ASSERT_OK(env_->GetTestDirectory(&test_dir));
  std::string test_file = test_dir + ""/open_on_read.txt"";

  FILE* f = fopen(test_file.c_str(), ""w"");
  ASSERT_TRUE(f != NULL);
  const char kFileData[] = ""abcdefghijklmnopqrstuvwxyz"";
  fputs(kFileData, f);
  fclose(f);

  // Open test file some number above the sum of the two limits to force
  // open-on-read behavior of POSIX Env leveldb::RandomAccessFile.
  const int kNumFiles = kReadOnlyFileLimit + kMMapLimit + 5;
  leveldb::RandomAccessFile* files[kNumFiles] = {0};
  for (int i = 0; i < kNumFiles; i++) {
    ASSERT_OK(env_->NewRandomAccessFile(test_file, &files[i]));
  }
  char scratch;
  Slice read_result;
  for (int i = 0; i < kNumFiles; i++) {
    ASSERT_OK(files[i]->Read(i, 1, &read_result, &scratch));
    ASSERT_EQ(kFileData[i], read_result[0]);
  }
  for (int i = 0; i < kNumFiles; i++) {
    delete files[i];
  }
  ASSERT_OK(e...",36,,28,1,,void
90337,BLOCK,1,,<empty>,,,,3,,void
90371,BLOCK,1,,<empty>,,,,2,,void
90410,BLOCK,-1,,<empty>,3,,44,1,,void
90420,BLOCK,4,,"{
    ASSERT_OK(env_->NewRandomAccessFile(test_file, &files[i]));
  }",39,,44,4,,void
90422,BLOCK,1,,<empty>,,,,3,,void
90446,BLOCK,-1,,<empty>,3,,49,1,,void
90456,BLOCK,4,,"{
    ASSERT_OK(files[i]->Read(i, 1, &read_result, &scratch));
    ASSERT_EQ(kFileData[i], read_result[0]);
  }",39,,49,4,,void
90458,BLOCK,1,,<empty>,,,,4,,void
90489,BLOCK,1,,<empty>,,,,5,,void
90508,BLOCK,-1,,<empty>,3,,53,1,,void
90518,BLOCK,4,,"{
    delete files[i];
  }",39,,53,4,,void
90529,BLOCK,1,,<empty>,,,,3,,void
90551,BLOCK,-1,,"{
  // All tests currently run with the same read-only file limits.
  leveldb::EnvPosixTest::SetFileLimits(leveldb::kReadOnlyFileLimit,
                                       leveldb::kMMapLimit);
  return leveldb::test::RunAllTests();
}",33,,61,3,,void
90577,BLOCK,-1,,<empty>,1,,1,1,,ANY
90584,BLOCK,-1,,<empty>,,,,2,,<empty>
90589,BLOCK,-1,,<empty>,,,,2,,<empty>
90602,BLOCK,-1,,<empty>,1,,1,1,,ANY
90621,BLOCK,-1,,{ },36,,23,1,,void
90626,BLOCK,-1,,"{
  reinterpret_cast<port::AtomicPointer*>(ptr)->NoBarrier_Store(ptr);
}",32,,26,2,,void
90638,BLOCK,-1,,<empty>,,,,1,,<empty>
90642,BLOCK,-1,,"TEST(EnvTest, RunImmediately)",1,,30,1,,void
90666,BLOCK,-1,,"{
  port::AtomicPointer called (NULL);
  env_->Schedule(&SetBool, &called);
  env_->SleepForMicroseconds(kDelayMicros);
  ASSERT_TRUE(called.NoBarrier_Load() != NULL);
}",31,,30,1,,void
90684,BLOCK,1,,<empty>,,,,2,,void
90707,BLOCK,-1,,<empty>,,,,1,,<empty>
90711,BLOCK,-1,,"TEST(EnvTest, RunMany)",1,,37,1,,void
90735,BLOCK,-1,,"{
  port::AtomicPointer last_id (NULL);

  struct CB {
    port::AtomicPointer* last_id_ptr;   // Pointer to shared slot
    uintptr_t id;             // Order# for the execution of this callback

    CB(port::AtomicPointer* p, int i) : last_id_ptr(p), id(i) { }

    static void Run(void* v) {
      CB* cb = reinterpret_cast<CB*>(v);
      void* cur = cb->last_id_ptr->NoBarrier_Load();
      ASSERT_EQ(cb->id-1, reinterpret_cast<uintptr_t>(cur));
      cb->last_id_ptr->Release_Store(reinterpret_cast<void*>(cb->id));
    }
  };

  // Schedule in different order than start time
  CB cb1(&last_id, 1);
  CB cb2(&last_id, 2);
  CB cb3(&last_id, 3);
  CB cb4(&last_id, 4);
  env_->Schedule(&CB::Run, &cb1);
  env_->Schedule(&CB::Run, &cb2);
  env_->Schedule(&CB::Run, &cb3);
  env_->Schedule(&CB::Run, &cb4);

  env_->SleepForMicroseconds(kDelayMicros);
  void* cur = last_id.Acquire_Load();
  ASSERT_EQ(4, reinterpret_cast<uintptr_t>(cur));
}",24,,37,1,,void
90816,BLOCK,1,,<empty>,,,,4,,void
90840,BLOCK,-1,,"{
  State* s = reinterpret_cast<State*>(arg);
  s->mu.Lock();
  s->val += 1;
  s->num_running -= 1;
  s->mu.Unlock();
}",35,,75,2,,void
90873,BLOCK,-1,,<empty>,,,,1,,<empty>
90877,BLOCK,-1,,"TEST(EnvTest, StartThread)",1,,83,1,,void
90901,BLOCK,-1,,"{
  State state;
  state.val = 0;
  state.num_running = 3;
  for (int i = 0; i < 3; i++) {
    env_->StartThread(&ThreadBody, &state);
  }
  while (true) {
    state.mu.Lock();
    int num = state.num_running;
    state.mu.Unlock();
    if (num == 0) {
      break;
    }
    env_->SleepForMicroseconds(kDelayMicros);
  }
  ASSERT_EQ(state.val, 3);
}",28,,83,1,,void
90914,BLOCK,-1,,<empty>,3,,87,1,,void
90924,BLOCK,4,,"{
    env_->StartThread(&ThreadBody, &state);
  }",31,,87,4,,void
90935,BLOCK,-1,,"{
    state.mu.Lock();
    int num = state.num_running;
    state.mu.Unlock();
    if (num == 0) {
      break;
    }
    env_->SleepForMicroseconds(kDelayMicros);
  }",16,,90,2,,void
90958,BLOCK,-1,,"{
      break;
    }",19,,94,2,,void
90970,BLOCK,1,,<empty>,,,,4,,void
90991,BLOCK,-1,,"{
  return leveldb::test::RunAllTests();
}",33,,104,3,,void
91007,BLOCK,-1,,<empty>,1,,1,1,,ANY
91010,BLOCK,-1,,{ },31,,9,1,,void
91023,BLOCK,-1,,<empty>,1,,1,1,,ANY
91029,BLOCK,-1,,"{
  // Similar to murmur hash
  const uint32_t m = 0xc6a4a793;
  const uint32_t r = 24;
  const char* limit = data + n;
  uint32_t h = seed ^ (n * m);

  // Pick up four bytes at a time
  while (data + 4 <= limit) {
    uint32_t w = DecodeFixed32(data);
    data += 4;
    h += w;
    h *= m;
    h ^= (h >> 16);
  }

  // Pick up remaining bytes
  switch (limit - data) {
    case 3:
      h += static_cast<unsigned char>(data[2]) << 16;
      FALLTHROUGH_INTENDED;
    case 2:
      h += static_cast<unsigned char>(data[1]) << 8;
      FALLTHROUGH_INTENDED;
    case 1:
      h += static_cast<unsigned char>(data[0]);
      h *= m;
      h ^= (h >> r);
      break;
  }
  return h;
}",58,,18,4,,void
91058,BLOCK,-1,,"{
    uint32_t w = DecodeFixed32(data);
    data += 4;
    h += w;
    h *= m;
    h ^= (h >> 16);
  }",29,,26,2,,void
91082,BLOCK,-1,,"{
    case 3:
      h += static_cast<unsigned char>(data[2]) << 16;
      FALLTHROUGH_INTENDED;
    case 2:
      h += static_cast<unsigned char>(data[1]) << 8;
      FALLTHROUGH_INTENDED;
    case 1:
      h += static_cast<unsigned char>(data[0]);
      h *= m;
      h ^= (h >> r);
      break;
  }",25,,35,2,,void
91095,BLOCK,1,,<empty>,,,,1,,void
91097,BLOCK,-1,,FALLTHROUGH_INTENDED,7,,38,1,,void
91111,BLOCK,1,,<empty>,,,,1,,void
91113,BLOCK,-1,,FALLTHROUGH_INTENDED,7,,41,1,,void
91145,BLOCK,-1,,<empty>,1,,1,1,,ANY
91151,BLOCK,-1,,<empty>,,,,4,,<empty>
91162,BLOCK,-1,,<empty>,1,,1,1,,ANY
91167,BLOCK,-1,,<empty>,,,,1,,<empty>
91171,BLOCK,-1,,"TEST(HASH, SignedUnsignedIssue)",1,,12,1,,void
91195,BLOCK,-1,,"{
  const unsigned char data1[1] = {0x62};
  const unsigned char data2[2] = {0xc3, 0x97};
  const unsigned char data3[3] = {0xe2, 0x99, 0xa5};
  const unsigned char data4[4] = {0xe1, 0x80, 0xb9, 0x32};
  const unsigned char data5[48] = {
    0x01, 0xc0, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x14, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x04, 0x00,
    0x00, 0x00, 0x00, 0x14,
    0x00, 0x00, 0x00, 0x18,
    0x28, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x02, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
  };

  ASSERT_EQ(Hash(0, 0, 0xbc9f1d34), 0xbc9f1d34);
  ASSERT_EQ(
      Hash(reinterpret_cast<const char*>(data1), sizeof(data1), 0xbc9f1d34),
      0xef1345c4);
  ASSERT_EQ(
      Hash(reinterpret_cast<const char*>(data2), sizeof(data2), 0xbc9f1d34),
      0x5b663814);
  ASSERT_EQ(
      Hash(reinterpret_cast<const char*>(data3), sizeof(data3), 0xbc9f1d34),
      0x323c078f);
  ASSERT_EQ(
      Hash(reinterpret_cast<...",33,,12,1,,void
91276,BLOCK,1,,<empty>,,,,2,,void
91295,BLOCK,1,,<empty>,,,,4,,void
91317,BLOCK,1,,<empty>,,,,4,,void
91339,BLOCK,1,,<empty>,,,,4,,void
91361,BLOCK,1,,<empty>,,,,4,,void
91383,BLOCK,1,,<empty>,,,,4,,void
91408,BLOCK,-1,,"{
  return leveldb::test::RunAllTests();
}",33,,52,3,,void
91430,BLOCK,-1,,<empty>,1,,1,1,,ANY
91591,BLOCK,-1,,"{
  min_ = kBucketLimit[kNumBuckets-1];
  max_ = 0;
  num_ = 0;
  sum_ = 0;
  sum_squares_ = 0;
  for (int i = 0; i < kNumBuckets; i++) {
    buckets_[i] = 0;
  }
}",25,,33,1,,void
91612,BLOCK,-1,,<empty>,3,,39,1,,void
91622,BLOCK,4,,"{
    buckets_[i] = 0;
  }",41,,39,4,,void
91632,BLOCK,-1,,"{
  // Linear search is fast enough for our usage in db_bench
  int b = 0;
  while (b < kNumBuckets - 1 && kBucketLimit[b] <= value) {
    b++;
  }
  buckets_[b] += 1.0;
  if (min_ > value) min_ = value;
  if (max_ < value) max_ = value;
  num_++;
  sum_ += value;
  sum_squares_ += (value * value);
}",35,,44,2,,void
91649,BLOCK,-1,,"{
    b++;
  }",59,,47,2,,void
91661,BLOCK,-1,,<empty>,21,,51,2,,void
91669,BLOCK,-1,,<empty>,21,,52,2,,void
91687,BLOCK,-1,,"{
  if (other.min_ < min_) min_ = other.min_;
  if (other.max_ > max_) max_ = other.max_;
  num_ += other.num_;
  sum_ += other.sum_;
  sum_squares_ += other.sum_squares_;
  for (int b = 0; b < kNumBuckets; b++) {
    buckets_[b] += other.buckets_[b];
  }
}",47,,58,2,,void
91694,BLOCK,-1,,<empty>,26,,59,2,,void
91706,BLOCK,-1,,<empty>,26,,60,2,,void
91728,BLOCK,-1,,<empty>,3,,64,1,,void
91738,BLOCK,4,,"{
    buckets_[b] += other.buckets_[b];
  }",41,,64,4,,void
91751,BLOCK,-1,,"{
  return Percentile(50.0);
}",34,,69,1,,void
91759,BLOCK,-1,,"{
  double threshold = num_ * (p / 100.0);
  double sum = 0;
  for (int b = 0; b < kNumBuckets; b++) {
    sum += buckets_[b];
    if (sum >= threshold) {
      // Scale linearly within this bucket
      double left_point = (b == 0) ? 0 : kBucketLimit[b-1];
      double right_point = kBucketLimit[b];
      double left_sum = sum - buckets_[b];
      double right_sum = sum;
      double pos = (threshold - left_sum) / (right_sum - left_sum);
      double r = left_point + (right_point - left_point) * pos;
      if (r < min_) r = min_;
      if (r > max_) r = max_;
      return r;
    }
  }
  return max_;
}",46,,73,2,,void
91773,BLOCK,-1,,<empty>,3,,76,1,,void
91783,BLOCK,4,,"{
    sum += buckets_[b];
    if (sum >= threshold) {
      // Scale linearly within this bucket
      double left_point = (b == 0) ? 0 : kBucketLimit[b-1];
      double right_point = kBucketLimit[b];
      double left_sum = sum - buckets_[b];
      double right_sum = sum;
      double pos = (threshold - left_sum) / (right_sum - left_sum);
      double r = left_point + (right_point - left_point) * pos;
      if (r < min_) r = min_;
      if (r > max_) r = max_;
      return r;
    }
  }",41,,76,4,,void
91793,BLOCK,-1,,"{
      // Scale linearly within this bucket
      double left_point = (b == 0) ? 0 : kBucketLimit[b-1];
      double right_point = kBucketLimit[b];
      double left_sum = sum - buckets_[b];
      double right_sum = sum;
      double pos = (threshold - left_sum) / (right_sum - left_sum);
      double r = left_point + (right_point - left_point) * pos;
      if (r < min_) r = min_;
      if (r > max_) r = max_;
      return r;
    }",27,,78,2,,void
91849,BLOCK,-1,,<empty>,21,,86,2,,void
91857,BLOCK,-1,,<empty>,21,,87,2,,void
91868,BLOCK,-1,,"{
  if (num_ == 0.0) return 0;
  return sum_ / num_;
}",35,,94,1,,void
91873,BLOCK,-1,,<empty>,20,,95,2,,void
91883,BLOCK,-1,,"{
  if (num_ == 0.0) return 0;
  double variance = (sum_squares_ * num_ - sum_ * sum_) / (num_ * num_);
  return sqrt(variance);
}",45,,99,1,,void
91888,BLOCK,-1,,<empty>,20,,100,2,,void
91911,BLOCK,-1,,"{
  std::string r;
  char buf[200];
  snprintf(buf, sizeof(buf),
           ""Count: %.0f  Average: %.4f  StdDev: %.2f\n"",
           num_, Average(), StandardDeviation());
  r.append(buf);
  snprintf(buf, sizeof(buf),
           ""Min: %.4f  Median: %.4f  Max: %.4f\n"",
           (num_ == 0.0 ? 0.0 : min_), Median(), max_);
  r.append(buf);
  r.append(""------------------------------------------------------\n"");
  const double mult = 100.0 / num_;
  double sum = 0;
  for (int b = 0; b < kNumBuckets; b++) {
    if (buckets_[b] <= 0.0) continue;
    sum += buckets_[b];
    snprintf(buf, sizeof(buf),
             ""[ %7.0f, %7.0f ) %7.0f %7.3f%% %7.3f%% "",
             ((b == 0) ? 0.0 : kBucketLimit[b-1]),      // left
             kBucketLimit[b],                           // right
             buckets_[b],                               // count
             mult * buckets_[b],                        // percentage
             mult * sum);                               // cumulative perc...",41,,105,1,,void
91961,BLOCK,-1,,<empty>,3,,119,1,,void
91971,BLOCK,4,,"{
    if (buckets_[b] <= 0.0) continue;
    sum += buckets_[b];
    snprintf(buf, sizeof(buf),
             ""[ %7.0f, %7.0f ) %7.0f %7.3f%% %7.3f%% "",
             ((b == 0) ? 0.0 : kBucketLimit[b-1]),      // left
             kBucketLimit[b],                           // right
             buckets_[b],                               // count
             mult * buckets_[b],                        // percentage
             mult * sum);                               // cumulative percentage
    r.append(buf);

    // Add hash marks based on percentage; 20 marks for 100%.
    int marks = static_cast<int>(20*(buckets_[b] / num_) + 0.5);
    r.append(marks, '#');
    r.push_back('\n');
  }",41,,119,4,,void
91978,BLOCK,-1,,<empty>,29,,120,2,,void
92054,BLOCK,-1,,<empty>,1,,1,1,,ANY
92058,BLOCK,-1,,{ },15,,14,1,,void
92062,BLOCK,-1,,{ },16,,15,1,,void
92066,BLOCK,-1,,<empty>,,,,1,,<empty>
92071,BLOCK,-1,,<empty>,,,,2,,<empty>
92076,BLOCK,-1,,<empty>,,,,2,,<empty>
92080,BLOCK,-1,,<empty>,,,,1,,<empty>
92091,BLOCK,-1,,<empty>,,,,1,,<empty>
92100,BLOCK,-1,,<empty>,,,,1,,<empty>
92105,BLOCK,-1,,<empty>,,,,2,,<empty>
92109,BLOCK,-1,,<empty>,,,,1,,<empty>
92113,BLOCK,-1,,<empty>,,,,1,,<empty>
92117,BLOCK,-1,,<empty>,,,,1,,<empty>
92142,BLOCK,-1,,<empty>,1,,1,1,,ANY
92147,BLOCK,-1,,"{
  char buf[30];
  snprintf(buf, sizeof(buf), ""%llu"", (unsigned long long) num);
  str->append(buf);
}",53,,16,3,,void
92167,BLOCK,-1,,"{
  for (size_t i = 0; i < value.size(); i++) {
    char c = value[i];
    if (c >= ' ' && c <= '~') {
      str->push_back(c);
    } else {
      char buf[10];
      snprintf(buf, sizeof(buf), ""\\x%02x"",
               static_cast<unsigned int>(c) & 0xff);
      str->append(buf);
    }
  }
}",66,,22,3,,void
92169,BLOCK,-1,,<empty>,3,,23,1,,void
92182,BLOCK,4,,"{
    char c = value[i];
    if (c >= ' ' && c <= '~') {
      str->push_back(c);
    } else {
      char buf[10];
      snprintf(buf, sizeof(buf), ""\\x%02x"",
               static_cast<unsigned int>(c) & 0xff);
      str->append(buf);
    }
  }",45,,23,4,,void
92197,BLOCK,-1,,"{
      str->push_back(c);
    }",31,,25,2,,void
92204,BLOCK,-1,,"{
      char buf[10];
      snprintf(buf, sizeof(buf), ""\\x%02x"",
               static_cast<unsigned int>(c) & 0xff);
      str->append(buf);
    }",12,,27,1,,void
92225,BLOCK,-1,,"{
  std::string r;
  AppendNumberTo(&r, num);
  return r;
}",42,,36,2,,void
92237,BLOCK,-1,,"{
  std::string r;
  AppendEscapedStringTo(&r, value);
  return r;
}",46,,42,2,,void
92250,BLOCK,-1,,"{
  uint64_t v = 0;
  int digits = 0;
  while (!in->empty()) {
    char c = (*in)[0];
    if (c >= '0' && c <= '9') {
      ++digits;
      const int delta = (c - '0');
      static const uint64_t kMaxUint64 = ~static_cast<uint64_t>(0);
      if (v > kMaxUint64/10 ||
          (v == kMaxUint64/10 && delta > kMaxUint64%10)) {
        // Overflow
        return false;
      }
      v = (v * 10) + delta;
      in->remove_prefix(1);
    } else {
      break;
    }
  }
  *val = v;
  return (digits > 0);
}",53,,48,3,,void
92265,BLOCK,-1,,"{
    char c = (*in)[0];
    if (c >= '0' && c <= '9') {
      ++digits;
      const int delta = (c - '0');
      static const uint64_t kMaxUint64 = ~static_cast<uint64_t>(0);
      if (v > kMaxUint64/10 ||
          (v == kMaxUint64/10 && delta > kMaxUint64%10)) {
        // Overflow
        return false;
      }
      v = (v * 10) + delta;
      in->remove_prefix(1);
    } else {
      break;
    }
  }",24,,51,2,,void
92281,BLOCK,-1,,"{
      ++digits;
      const int delta = (c - '0');
      static const uint64_t kMaxUint64 = ~static_cast<uint64_t>(0);
      if (v > kMaxUint64/10 ||
          (v == kMaxUint64/10 && delta > kMaxUint64%10)) {
        // Overflow
        return false;
      }
      v = (v * 10) + delta;
      in->remove_prefix(1);
    }",31,,53,2,,void
92315,BLOCK,-1,,"{
        // Overflow
        return false;
      }",58,,58,2,,void
92331,BLOCK,-1,,"{
      break;
    }",12,,64,1,,void
92355,BLOCK,-1,,<empty>,1,,1,1,,ANY
92362,BLOCK,-1,,<empty>,,,,3,,<empty>
92368,BLOCK,-1,,<empty>,,,,3,,<empty>
92373,BLOCK,-1,,<empty>,,,,2,,<empty>
92378,BLOCK,-1,,<empty>,,,,2,,<empty>
92384,BLOCK,-1,,<empty>,,,,3,,<empty>
92395,BLOCK,-1,,<empty>,1,,1,1,,ANY
92400,BLOCK,-1,,"{
    this->mu_->Lock();
  }",18,,26,2,,void
92410,BLOCK,-1,,{ this->mu_->Unlock(); },34,,29,1,,void
92422,BLOCK,-1,,<empty>,,,,2,,<empty>
92427,BLOCK,-1,,<empty>,,,,2,,<empty>
92440,BLOCK,-1,,<empty>,1,,1,1,,ANY
92443,BLOCK,-1,,"{
}",27,,27,1,,void
92460,BLOCK,-1,,<empty>,1,,1,1,,ANY
92465,BLOCK,-1,,<empty>,,,,1,,<empty>
92471,BLOCK,-1,,{ },74,,24,3,,void
92475,BLOCK,-1,,"{
    fclose(file_);
  }",26,,25,1,,void
92483,BLOCK,-1,,"{
    const uint64_t thread_id = (*gettid_)();

    // We try twice: the first time with a fixed-size stack allocated buffer,
    // and the second time with a much larger dynamically allocated buffer.
    char buffer[500];
    for (int iter = 0; iter < 2; iter++) {
      char* base;
      int bufsize;
      if (iter == 0) {
        bufsize = sizeof(buffer);
        base = buffer;
      } else {
        bufsize = 30000;
        base = new char[bufsize];
      }
      char* p = base;
      char* limit = base + bufsize;

      struct timeval now_tv;
      gettimeofday(&now_tv, NULL);
      const time_t seconds = now_tv.tv_sec;
      struct tm t;
      localtime_r(&seconds, &t);
      p += snprintf(p, limit - p,
                    ""%04d/%02d/%02d-%02d:%02d:%02d.%06d %llx "",
                    t.tm_year + 1900,
                    t.tm_mon + 1,
                    t.tm_mday,
                    t.tm_hour,
                    t.tm_min,
                    t.tm_sec,
                    ...",53,,28,3,,void
92492,BLOCK,-1,,<empty>,5,,34,1,,void
92502,BLOCK,4,,"{
      char* base;
      int bufsize;
      if (iter == 0) {
        bufsize = sizeof(buffer);
        base = buffer;
      } else {
        bufsize = 30000;
        base = new char[bufsize];
      }
      char* p = base;
      char* limit = base + bufsize;

      struct timeval now_tv;
      gettimeofday(&now_tv, NULL);
      const time_t seconds = now_tv.tv_sec;
      struct tm t;
      localtime_r(&seconds, &t);
      p += snprintf(p, limit - p,
                    ""%04d/%02d/%02d-%02d:%02d:%02d.%06d %llx "",
                    t.tm_year + 1900,
                    t.tm_mon + 1,
                    t.tm_mday,
                    t.tm_hour,
                    t.tm_min,
                    t.tm_sec,
                    static_cast<int>(now_tv.tv_usec),
                    static_cast<long long unsigned int>(thread_id));

      // Print the message
      if (p < limit) {
        va_list backup_ap;
        va_copy(backup_ap, ap);
        p += vsnprintf(p, limit - p, format, backup_...",42,,34,4,,void
92509,BLOCK,-1,,"{
        bufsize = sizeof(buffer);
        base = buffer;
      }",22,,37,2,,void
92518,BLOCK,-1,,"{
        bufsize = 30000;
        base = new char[bufsize];
      }",14,,40,1,,void
92595,BLOCK,-1,,"{
        va_list backup_ap;
        va_copy(backup_ap, ap);
        p += vsnprintf(p, limit - p, format, backup_ap);
        va_end(backup_ap);
      }",22,,64,2,,void
92615,BLOCK,-1,,"{
        if (iter == 0) {
          continue;       // Try again with larger buffer
        } else {
          p = limit - 1;
        }
      }",23,,72,2,,void
92620,BLOCK,-1,,"{
          continue;       // Try again with larger buffer
        }",24,,73,2,,void
92623,BLOCK,-1,,"{
          p = limit - 1;
        }",16,,75,1,,void
92640,BLOCK,-1,,"{
        *p++ = '\n';
      }",39,,81,2,,void
92663,BLOCK,-1,,"{
        delete[] base;
      }",27,,88,2,,void
92675,BLOCK,-1,,<empty>,1,,1,1,,ANY
92681,BLOCK,-1,,"{
    // Avoid bad seeds.
    if (seed_ == 0 || seed_ == 2147483647L) {
      seed_ = 1;
    }
  }",56,,19,2,,void
92690,BLOCK,-1,,"{
      seed_ = 1;
    }",45,,21,2,,void
92697,BLOCK,-1,,"{
    static const uint32_t M = 2147483647L;   // 2^31-1
    static const uint64_t A = 16807;  // bits 14, 8, 7, 5, 2, 1, 0
    // We are computing
    //       seed_ = (seed_ * A) % M,    where M = 2^31-1
    //
    // seed_ must not be zero or M, or else all subsequent computed values
    // will be zero or M respectively.  For all other values, seed_ will end
    // up cycling through every number in [1,M-1]
    uint64_t product = seed_ * A;

    // Compute (product % M) using the fact that ((x << 31) % M) == x.
    seed_ = static_cast<uint32_t>((product >> 31) + (product & M));
    // The first reduction may overflow by 1 bit, so we may need to
    // repeat.  mod == M is not possible; using > allows the faster
    // sign-bit-based test.
    if (seed_ > M) {
      seed_ -= M;
    }
    return seed_;
  }",19,,25,1,,void
92727,BLOCK,-1,,"{
      seed_ -= M;
    }",20,,41,2,,void
92737,BLOCK,-1,,{ return Next() % n; },27,,48,2,,void
92746,BLOCK,-1,,{ return (Next() % n) == 0; },21,,52,2,,void
92757,BLOCK,-1,,"{
    return Uniform(1 << Uniform(max_log + 1));
  }",32,,57,2,,void
92778,BLOCK,-1,,<empty>,1,,1,1,,ANY
92782,BLOCK,-1,,"{
  uint32_t size;
  memcpy(&size, state, sizeof(size));
  char* result = new char[size + 5];
  memcpy(result, state, size + 5);
  return result;
}",50,,11,2,,void
92809,BLOCK,-1,,"{
  assert(code != kOk);
  const uint32_t len1 = msg.size();
  const uint32_t len2 = msg2.size();
  const uint32_t size = len1 + (len2 ? (2 + len2) : 0);
  char* result = new char[size + 5];
  memcpy(result, &size, sizeof(size));
  result[4] = static_cast<char>(code);
  memcpy(result + 5, msg.data(), len1);
  if (len2) {
    result[5 + len1] = ':';
    result[6 + len1] = ' ';
    memcpy(result + 7 + len1, msg2.data(), len2);
  }
  state_ = result;
}",64,,19,4,,void
92868,BLOCK,-1,,"{
    result[5 + len1] = ':';
    result[6 + len1] = ' ';
    memcpy(result + 7 + len1, msg2.data(), len2);
  }",13,,28,2,,void
92900,BLOCK,-1,,"{
  if (state_ == NULL) {
    return ""OK"";
  } else {
    char tmp[30];
    const char* type;
    switch (code()) {
      case kOk:
        type = ""OK"";
        break;
      case kNotFound:
        type = ""NotFound: "";
        break;
      case kCorruption:
        type = ""Corruption: "";
        break;
      case kNotSupported:
        type = ""Not implemented: "";
        break;
      case kInvalidArgument:
        type = ""Invalid argument: "";
        break;
      case kIOError:
        type = ""IO error: "";
        break;
      default:
        snprintf(tmp, sizeof(tmp), ""Unknown code(%d): "",
                 static_cast<int>(code()));
        type = tmp;
        break;
    }
    std::string result(type);
    uint32_t length;
    memcpy(&length, state_, sizeof(length));
    result.append(state_ + 5, length);
    return result;
  }
}",38,,36,1,,void
92905,BLOCK,-1,,"{
    return ""OK"";
  }",23,,37,2,,void
92909,BLOCK,-1,,"{
    char tmp[30];
    const char* type;
    switch (code()) {
      case kOk:
        type = ""OK"";
        break;
      case kNotFound:
        type = ""NotFound: "";
        break;
      case kCorruption:
        type = ""Corruption: "";
        break;
      case kNotSupported:
        type = ""Not implemented: "";
        break;
      case kInvalidArgument:
        type = ""Invalid argument: "";
        break;
      case kIOError:
        type = ""IO error: "";
        break;
      default:
        snprintf(tmp, sizeof(tmp), ""Unknown code(%d): "",
                 static_cast<int>(code()));
        type = tmp;
        break;
    }
    std::string result(type);
    uint32_t length;
    memcpy(&length, state_, sizeof(length));
    result.append(state_ + 5, length);
    return result;
  }",10,,39,1,,void
92914,BLOCK,-1,,"{
      case kOk:
        type = ""OK"";
        break;
      case kNotFound:
        type = ""NotFound: "";
        break;
      case kCorruption:
        type = ""Corruption: "";
        break;
      case kNotSupported:
        type = ""Not implemented: "";
        break;
      case kInvalidArgument:
        type = ""Invalid argument: "";
        break;
      case kIOError:
        type = ""IO error: "";
        break;
      default:
        snprintf(tmp, sizeof(tmp), ""Unknown code(%d): "",
                 static_cast<int>(code()));
        type = tmp;
        break;
    }",21,,42,2,,void
93000,BLOCK,-1,,<empty>,1,,1,1,,ANY
93008,BLOCK,-1,,<empty>,,,,1,,<empty>
93016,BLOCK,-1,,"{
  if (tests == NULL) {
    tests = new std::vector<Test>;
  }
  Test t;
  t.base = base;
  t.name = name;
  t.func = func;
  tests->push_back(t);
  return true;
}",71,,24,4,,void
93021,BLOCK,-1,,"{
    tests = new std::vector<Test>;
  }",22,,25,2,,void
93052,BLOCK,-1,,"{
  const char* matcher = getenv(""LEVELDB_TESTS"");

  int num = 0;
  if (tests != NULL) {
    for (size_t i = 0; i < tests->size(); i++) {
      const Test& t = (*tests)[i];
      if (matcher != NULL) {
        std::string name = t.base;
        name.push_back('.');
        name.append(t.name);
        if (strstr(name.c_str(), matcher) == NULL) {
          continue;
        }
      }
      fprintf(stderr, ""==== Test %s.%s\n"", t.base, t.name);
      (*t.func)();
      ++num;
    }
  }
  fprintf(stderr, ""==== PASSED %d tests\n"", num);
  return 0;
}",19,,36,1,,void
93066,BLOCK,-1,,"{
    for (size_t i = 0; i < tests->size(); i++) {
      const Test& t = (*tests)[i];
      if (matcher != NULL) {
        std::string name = t.base;
        name.push_back('.');
        name.append(t.name);
        if (strstr(name.c_str(), matcher) == NULL) {
          continue;
        }
      }
      fprintf(stderr, ""==== Test %s.%s\n"", t.base, t.name);
      (*t.func)();
      ++num;
    }
  }",22,,40,2,,void
93068,BLOCK,-1,,<empty>,5,,41,1,,void
93081,BLOCK,4,,"{
      const Test& t = (*tests)[i];
      if (matcher != NULL) {
        std::string name = t.base;
        name.push_back('.');
        name.append(t.name);
        if (strstr(name.c_str(), matcher) == NULL) {
          continue;
        }
      }
      fprintf(stderr, ""==== Test %s.%s\n"", t.base, t.name);
      (*t.func)();
      ++num;
    }",48,,41,4,,void
93093,BLOCK,-1,,"{
        std::string name = t.base;
        name.push_back('.');
        name.append(t.name);
        if (strstr(name.c_str(), matcher) == NULL) {
          continue;
        }
      }",28,,43,2,,void
93121,BLOCK,-1,,"{
          continue;
        }",52,,47,2,,void
93148,BLOCK,-1,,"{
  std::string dir;
  Status s = Env::Default()->GetTestDirectory(&dir);
  ASSERT_TRUE(s.ok()) << s.ToString();
  return dir;
}",22,,60,1,,void
93168,BLOCK,1,,<empty>,,,,3,,void
93194,BLOCK,-1,,"{
  const char* env = getenv(""TEST_RANDOM_SEED"");
  int result = (env != NULL ? atoi(env) : 301);
  if (result <= 0) {
    result = 301;
  }
  return result;
}",18,,67,1,,void
93214,BLOCK,-1,,"{
    result = 301;
  }",20,,70,2,,void
93238,BLOCK,-1,,<empty>,1,,1,1,,ANY
93242,BLOCK,-1,,<empty>,,,,1,,<empty>
93246,BLOCK,-1,,<empty>,,,,1,,<empty>
93250,BLOCK,-1,,<empty>,,,,1,,<empty>
93261,BLOCK,-1,,"{
  }",40,,51,3,,void
93265,BLOCK,-1,,"{
    if (!ok_) {
      fprintf(stderr, ""%s:%d:%s\n"", fname_, line_, ss_.str().c_str());
      exit(1);
    }
  }",13,,54,1,,void
93269,BLOCK,-1,,"{
      fprintf(stderr, ""%s:%d:%s\n"", fname_, line_, ss_.str().c_str());
      exit(1);
    }",15,,55,2,,void
93289,BLOCK,-1,,"{
    if (!b) {
      ss_ << "" Assertion failure "" << msg;
      ok_ = false;
    }
    return *this;
  }",39,,61,3,,void
93293,BLOCK,-1,,"{
      ss_ << "" Assertion failure "" << msg;
      ok_ = false;
    }",13,,62,2,,void
93309,BLOCK,-1,,"{
    if (!s.ok()) {
      ss_ << "" "" << s.ToString();
      ok_ = false;
    }
    return *this;
  }",33,,69,2,,void
93316,BLOCK,-1,,"{
      ss_ << "" "" << s.ToString();
      ok_ = false;
    }",18,,70,2,,void
93336,BLOCK,-1,,"BINARY_OP(IsEq, ==)",3,,87,3,,void
93342,BLOCK,-1,,"BINARY_OP(IsEq, ==)",3,,87,2,,void
93363,BLOCK,-1,,"BINARY_OP(IsNe, !=)",3,,88,3,,void
93369,BLOCK,-1,,"BINARY_OP(IsNe, !=)",3,,88,2,,void
93390,BLOCK,-1,,"BINARY_OP(IsGe, >=)",3,,89,3,,void
93396,BLOCK,-1,,"BINARY_OP(IsGe, >=)",3,,89,2,,void
93417,BLOCK,-1,,"BINARY_OP(IsGt, >)",3,,90,3,,void
93423,BLOCK,-1,,"BINARY_OP(IsGt, >)",3,,90,2,,void
93444,BLOCK,-1,,"BINARY_OP(IsLe, <=)",3,,91,3,,void
93450,BLOCK,-1,,"BINARY_OP(IsLe, <=)",3,,91,2,,void
93471,BLOCK,-1,,"BINARY_OP(IsLt, <)",3,,92,3,,void
93477,BLOCK,-1,,"BINARY_OP(IsLt, <)",3,,92,2,,void
93497,BLOCK,-1,,"{
    if (!ok_) {
      ss_ << "" "" << value;
    }
    return *this;
  }",38,,97,2,,void
93501,BLOCK,-1,,"{
      ss_ << "" "" << value;
    }",15,,98,2,,void
93516,BLOCK,-1,,<empty>,,,,4,,<empty>
93527,BLOCK,-1,,<empty>,1,,1,1,,ANY
93534,BLOCK,-1,,"{
  dst->resize(len);
  for (int i = 0; i < len; i++) {
    (*dst)[i] = static_cast<char>(' ' + rnd->Uniform(95));   // ' ' .. '~'
  }
  return Slice(*dst);
}",60,,12,4,,void
93541,BLOCK,-1,,<empty>,3,,14,1,,void
93551,BLOCK,4,,"{
    (*dst)[i] = static_cast<char>(' ' + rnd->Uniform(95));   // ' ' .. '~'
  }",33,,14,4,,void
93575,BLOCK,-1,,"{
  // Make sure to generate a wide variety of characters so we
  // test the boundary conditions for short-key optimizations.
  static const char kTestChars[] = {
    '\0', '\1', 'a', 'b', 'c', 'd', 'e', '\xfd', '\xfe', '\xff'
  };
  std::string result;
  for (int i = 0; i < len; i++) {
    result += kTestChars[rnd->Uniform(sizeof(kTestChars))];
  }
  return result;
}",45,,20,3,,void
93592,BLOCK,-1,,<empty>,3,,27,1,,void
93602,BLOCK,4,,"{
    result += kTestChars[rnd->Uniform(sizeof(kTestChars))];
  }",33,,27,4,,void
93622,BLOCK,-1,,"{
  int raw = static_cast<int>(len * compressed_fraction);
  if (raw < 1) raw = 1;
  std::string raw_data;
  RandomString(rnd, raw, &raw_data);

  // Duplicate the random data until we have filled ""len"" bytes
  dst->clear();
  while (dst->size() < len) {
    dst->append(raw_data);
  }
  dst->resize(len);
  return Slice(*dst);
}",63,,35,5,,void
93635,BLOCK,-1,,<empty>,16,,37,2,,void
93656,BLOCK,-1,,"{
    dst->append(raw_data);
  }",29,,43,2,,void
93683,BLOCK,-1,,<empty>,1,,1,1,,ANY
93690,BLOCK,-1,,<empty>,,,,4,,<empty>
93696,BLOCK,-1,,<empty>,,,,3,,<empty>
93704,BLOCK,-1,,<empty>,,,,5,,<empty>
93711,BLOCK,-1,,{ },45,,37,1,,void
93717,BLOCK,-1,,"{
    if (writable_file_error_) {
      ++num_writable_file_errors_;
      *result = NULL;
      return Status::IOError(fname, ""fake error"");
    }
    return target()->NewWritableFile(fname, result);
  }",57,,40,3,,void
93720,BLOCK,-1,,"{
      ++num_writable_file_errors_;
      *result = NULL;
      return Status::IOError(fname, ""fake error"");
    }",31,,41,2,,void
93746,BLOCK,-1,,"{
    if (writable_file_error_) {
      ++num_writable_file_errors_;
      *result = NULL;
      return Status::IOError(fname, ""fake error"");
    }
    return target()->NewAppendableFile(fname, result);
  }",59,,50,3,,void
93749,BLOCK,-1,,"{
      ++num_writable_file_errors_;
      *result = NULL;
      return Status::IOError(fname, ""fake error"");
    }",31,,51,2,,void
95538,BLOCK,-1,,<empty>,,,,1,,ANY
95681,BLOCK,1,,<empty>,,,,1,,ANY
95686,BLOCK,1,,<empty>,,,,1,,ANY
95690,BLOCK,1,,<empty>,,,,1,,ANY
95695,BLOCK,1,,<empty>,,,,1,,ANY
95699,BLOCK,1,,<empty>,,,,1,,ANY
95704,BLOCK,1,,<empty>,,,,1,,ANY
95708,BLOCK,1,,<empty>,,,,1,,ANY
95715,BLOCK,1,,<empty>,,,,1,,ANY
95719,BLOCK,1,,<empty>,,,,1,,ANY
95723,BLOCK,1,,<empty>,,,,1,,ANY
95726,BLOCK,1,,<empty>,,,,1,,ANY
95733,BLOCK,1,,<empty>,,,,1,,ANY
95737,BLOCK,1,,<empty>,,,,1,,ANY
95743,BLOCK,1,,<empty>,,,,1,,ANY
95747,BLOCK,1,,<empty>,,,,1,,ANY
95754,BLOCK,1,,<empty>,,,,1,,ANY
95759,BLOCK,1,,<empty>,,,,1,,ANY
95764,BLOCK,1,,<empty>,,,,1,,ANY
95769,BLOCK,1,,<empty>,,,,1,,ANY
95773,BLOCK,1,,<empty>,,,,1,,ANY
95778,BLOCK,1,,<empty>,,,,1,,ANY
95783,BLOCK,1,,<empty>,,,,1,,ANY
95787,BLOCK,1,,<empty>,,,,1,,ANY
95794,BLOCK,1,,<empty>,,,,1,,ANY
95797,BLOCK,1,,<empty>,,,,1,,ANY
95801,BLOCK,1,,<empty>,,,,1,,ANY
95805,BLOCK,1,,<empty>,,,,1,,ANY
95811,BLOCK,1,,<empty>,,,,1,,ANY
95816,BLOCK,1,,<empty>,,,,1,,ANY
95821,BLOCK,1,,<empty>,,,,1,,ANY
95826,BLOCK,1,,<empty>,,,,1,,ANY
95832,BLOCK,1,,<empty>,,,,1,,ANY
95836,BLOCK,1,,<empty>,,,,1,,ANY
95839,BLOCK,1,,<empty>,,,,1,,ANY
95843,BLOCK,1,,<empty>,,,,1,,ANY
95848,BLOCK,1,,<empty>,,,,1,,ANY
95852,BLOCK,1,,<empty>,,,,1,,ANY
95856,BLOCK,1,,<empty>,,,,1,,ANY
95860,BLOCK,1,,<empty>,,,,1,,ANY
95864,BLOCK,1,,<empty>,,,,1,,ANY
95869,BLOCK,1,,<empty>,,,,1,,ANY
95873,BLOCK,1,,<empty>,,,,1,,ANY
95881,BLOCK,1,,<empty>,,,,1,,ANY
95886,BLOCK,1,,<empty>,,,,1,,ANY
95890,BLOCK,1,,<empty>,,,,1,,ANY
95896,BLOCK,1,,<empty>,,,,1,,ANY
95901,BLOCK,1,,<empty>,,,,1,,ANY
95907,BLOCK,1,,<empty>,,,,1,,ANY
95912,BLOCK,1,,<empty>,,,,1,,ANY
95916,BLOCK,1,,<empty>,,,,1,,ANY
95923,BLOCK,1,,<empty>,,,,1,,ANY
95927,BLOCK,1,,<empty>,,,,1,,ANY
95931,BLOCK,1,,<empty>,,,,1,,ANY
95938,BLOCK,1,,<empty>,,,,1,,ANY
95942,BLOCK,1,,<empty>,,,,1,,ANY
95947,BLOCK,1,,<empty>,,,,1,,ANY
95953,BLOCK,1,,<empty>,,,,1,,ANY
95957,BLOCK,1,,<empty>,,,,1,,ANY
95961,BLOCK,1,,<empty>,,,,1,,ANY
95965,BLOCK,1,,<empty>,,,,1,,ANY
95970,BLOCK,1,,<empty>,,,,1,,ANY
95975,BLOCK,1,,<empty>,,,,1,,ANY
95982,BLOCK,1,,<empty>,,,,1,,ANY
95986,BLOCK,1,,<empty>,,,,1,,ANY
95990,BLOCK,1,,<empty>,,,,1,,ANY
95995,BLOCK,1,,<empty>,,,,1,,ANY
95999,BLOCK,1,,<empty>,,,,1,,ANY
96003,BLOCK,1,,<empty>,,,,1,,ANY
96007,BLOCK,1,,<empty>,,,,1,,ANY
96011,BLOCK,1,,<empty>,,,,1,,ANY
96015,BLOCK,1,,<empty>,,,,1,,ANY
96020,BLOCK,1,,<empty>,,,,1,,ANY
96025,BLOCK,1,,<empty>,,,,1,,ANY
96029,BLOCK,1,,<empty>,,,,1,,ANY
96038,BLOCK,1,,<empty>,,,,1,,ANY
96042,BLOCK,1,,<empty>,,,,1,,ANY
96046,BLOCK,1,,<empty>,,,,1,,ANY
96051,BLOCK,1,,<empty>,,,,1,,ANY
96055,BLOCK,1,,<empty>,,,,1,,ANY
96059,BLOCK,1,,<empty>,,,,1,,ANY
96064,BLOCK,1,,<empty>,,,,1,,ANY
96073,BLOCK,1,,<empty>,,,,1,,ANY
96078,BLOCK,1,,<empty>,,,,1,,ANY
96082,BLOCK,1,,<empty>,,,,1,,ANY
96091,BLOCK,1,,<empty>,,,,1,,ANY
96096,BLOCK,1,,<empty>,,,,1,,ANY
96101,BLOCK,1,,<empty>,,,,1,,ANY
96105,BLOCK,1,,<empty>,,,,1,,ANY
96109,BLOCK,1,,<empty>,,,,1,,ANY
96113,BLOCK,1,,<empty>,,,,1,,ANY
96119,BLOCK,1,,<empty>,,,,1,,ANY
96126,BLOCK,1,,<empty>,,,,1,,ANY
96132,BLOCK,1,,<empty>,,,,1,,ANY
96136,BLOCK,1,,<empty>,,,,1,,ANY
96141,BLOCK,1,,<empty>,,,,1,,ANY
96145,BLOCK,1,,<empty>,,,,1,,ANY
96155,BLOCK,1,,<empty>,,,,1,,ANY
96159,BLOCK,1,,<empty>,,,,1,,ANY
96163,BLOCK,1,,<empty>,,,,1,,ANY
96168,BLOCK,1,,<empty>,,,,1,,ANY
96174,BLOCK,1,,<empty>,,,,1,,ANY
96180,BLOCK,1,,<empty>,,,,1,,ANY
96186,BLOCK,1,,<empty>,,,,1,,ANY
96190,BLOCK,1,,<empty>,,,,1,,ANY
96195,BLOCK,1,,<empty>,,,,1,,ANY
96200,BLOCK,1,,<empty>,,,,1,,ANY
96204,BLOCK,1,,<empty>,,,,1,,ANY
96209,BLOCK,1,,<empty>,,,,1,,ANY
96213,BLOCK,1,,<empty>,,,,1,,ANY
96217,BLOCK,1,,<empty>,,,,1,,ANY
96221,BLOCK,1,,<empty>,,,,1,,ANY
96225,BLOCK,1,,<empty>,,,,1,,ANY
96230,BLOCK,1,,<empty>,,,,1,,ANY
96234,BLOCK,1,,<empty>,,,,1,,ANY
96247,BLOCK,1,,<empty>,,,,1,,ANY
96251,BLOCK,1,,<empty>,,,,1,,ANY
96256,BLOCK,1,,<empty>,,,,1,,ANY
96260,BLOCK,1,,<empty>,,,,1,,ANY
96266,BLOCK,1,,<empty>,,,,1,,ANY
96269,BLOCK,1,,<empty>,,,,1,,ANY
96273,BLOCK,1,,<empty>,,,,1,,ANY
96276,BLOCK,1,,<empty>,,,,1,,ANY
96280,BLOCK,1,,<empty>,,,,1,,ANY
96284,BLOCK,1,,<empty>,,,,1,,ANY
96289,BLOCK,1,,<empty>,,,,1,,ANY
96292,BLOCK,1,,<empty>,,,,1,,ANY
96295,BLOCK,1,,<empty>,,,,1,,ANY
96298,BLOCK,1,,<empty>,,,,1,,ANY
96304,BLOCK,1,,<empty>,,,,1,,ANY
96310,BLOCK,1,,<empty>,,,,1,,ANY
96315,BLOCK,1,,<empty>,,,,1,,ANY
96319,BLOCK,1,,<empty>,,,,1,,ANY
96325,BLOCK,1,,<empty>,,,,1,,ANY
96330,BLOCK,1,,<empty>,,,,1,,ANY
96336,BLOCK,1,,<empty>,,,,1,,ANY
96340,BLOCK,1,,<empty>,,,,1,,ANY
96345,BLOCK,1,,<empty>,,,,1,,ANY
96349,BLOCK,1,,<empty>,,,,1,,ANY
96354,BLOCK,1,,<empty>,,,,1,,ANY
96359,BLOCK,1,,<empty>,,,,1,,ANY
96365,BLOCK,1,,<empty>,,,,1,,ANY
96371,BLOCK,1,,<empty>,,,,1,,ANY
96377,BLOCK,1,,<empty>,,,,1,,ANY
96383,BLOCK,1,,<empty>,,,,1,,ANY
96387,BLOCK,1,,<empty>,,,,1,,ANY
96391,BLOCK,1,,<empty>,,,,1,,ANY
96395,BLOCK,1,,<empty>,,,,1,,ANY
96399,BLOCK,1,,<empty>,,,,1,,ANY
96404,BLOCK,1,,<empty>,,,,1,,ANY
96408,BLOCK,1,,<empty>,,,,1,,ANY
96414,BLOCK,1,,<empty>,,,,1,,ANY
96420,BLOCK,1,,<empty>,,,,1,,ANY
96424,BLOCK,1,,<empty>,,,,1,,ANY
96430,BLOCK,1,,<empty>,,,,1,,ANY
96434,BLOCK,1,,<empty>,,,,1,,ANY
96439,BLOCK,1,,<empty>,,,,1,,ANY
96445,BLOCK,1,,<empty>,,,,1,,ANY
96452,BLOCK,1,,<empty>,,,,1,,ANY
96458,BLOCK,1,,<empty>,,,,1,,ANY
96465,BLOCK,1,,<empty>,,,,1,,ANY
96469,BLOCK,1,,<empty>,,,,1,,ANY
96476,BLOCK,1,,<empty>,,,,1,,ANY
96480,BLOCK,1,,<empty>,,,,1,,ANY
96485,BLOCK,1,,<empty>,,,,1,,ANY
96491,BLOCK,1,,<empty>,,,,1,,ANY
96494,BLOCK,1,,<empty>,,,,1,,ANY
96498,BLOCK,1,,<empty>,,,,1,,ANY
96505,BLOCK,1,,<empty>,,,,1,,ANY
96508,BLOCK,1,,<empty>,,,,1,,ANY
96512,BLOCK,1,,<empty>,,,,1,,ANY
96518,BLOCK,1,,<empty>,,,,1,,ANY
96522,BLOCK,1,,<empty>,,,,1,,ANY
96529,BLOCK,1,,<empty>,,,,1,,ANY
96534,BLOCK,1,,<empty>,,,,1,,ANY
96540,BLOCK,1,,<empty>,,,,1,,ANY
96543,BLOCK,1,,<empty>,,,,1,,ANY
96547,BLOCK,1,,<empty>,,,,1,,ANY
96554,BLOCK,1,,<empty>,,,,1,,ANY
96558,BLOCK,1,,<empty>,,,,1,,ANY
96562,BLOCK,1,,<empty>,,,,1,,ANY
96569,BLOCK,1,,<empty>,,,,1,,ANY
96575,BLOCK,1,,<empty>,,,,1,,ANY
96580,BLOCK,1,,<empty>,,,,1,,ANY
96584,BLOCK,1,,<empty>,,,,1,,ANY
96591,BLOCK,1,,<empty>,,,,1,,ANY
96594,BLOCK,1,,<empty>,,,,1,,ANY
96598,BLOCK,1,,<empty>,,,,1,,ANY
96604,BLOCK,1,,<empty>,,,,1,,ANY
96607,BLOCK,1,,<empty>,,,,1,,ANY
96612,BLOCK,1,,<empty>,,,,1,,ANY
96616,BLOCK,1,,<empty>,,,,1,,ANY
96623,BLOCK,1,,<empty>,,,,1,,ANY
96627,BLOCK,1,,<empty>,,,,1,,ANY
96633,BLOCK,1,,<empty>,,,,1,,ANY
96636,BLOCK,1,,<empty>,,,,1,,ANY
96641,BLOCK,1,,<empty>,,,,1,,ANY
96645,BLOCK,1,,<empty>,,,,1,,ANY
96652,BLOCK,1,,<empty>,,,,1,,ANY
96656,BLOCK,1,,<empty>,,,,1,,ANY
96659,BLOCK,1,,<empty>,,,,1,,ANY
96662,BLOCK,1,,<empty>,,,,1,,ANY
96667,BLOCK,1,,<empty>,,,,1,,ANY
96671,BLOCK,1,,<empty>,,,,1,,ANY
96678,BLOCK,1,,<empty>,,,,1,,ANY
96685,BLOCK,1,,<empty>,,,,1,,ANY
96692,BLOCK,1,,<empty>,,,,1,,ANY
96699,BLOCK,1,,<empty>,,,,1,,ANY
96706,BLOCK,1,,<empty>,,,,1,,ANY
96713,BLOCK,1,,<empty>,,,,1,,ANY
96716,BLOCK,1,,<empty>,,,,1,,ANY
96719,BLOCK,1,,<empty>,,,,1,,ANY
96726,BLOCK,1,,<empty>,,,,1,,ANY
96730,BLOCK,1,,<empty>,,,,1,,ANY
96736,BLOCK,1,,<empty>,,,,1,,ANY
96743,BLOCK,1,,<empty>,,,,1,,ANY
96749,BLOCK,1,,<empty>,,,,1,,ANY
96753,BLOCK,1,,<empty>,,,,1,,ANY
96760,BLOCK,1,,<empty>,,,,1,,ANY
96767,BLOCK,1,,<empty>,,,,1,,ANY
96773,BLOCK,1,,<empty>,,,,1,,ANY
96776,BLOCK,1,,<empty>,,,,1,,ANY
96779,BLOCK,1,,<empty>,,,,1,,ANY
96782,BLOCK,1,,<empty>,,,,1,,ANY
96788,BLOCK,1,,<empty>,,,,1,,ANY
96792,BLOCK,1,,<empty>,,,,1,,ANY
96799,BLOCK,1,,<empty>,,,,1,,ANY
96803,BLOCK,1,,<empty>,,,,1,,ANY
96809,BLOCK,1,,<empty>,,,,1,,ANY
96813,BLOCK,1,,<empty>,,,,1,,ANY
96817,BLOCK,1,,<empty>,,,,1,,ANY
96823,BLOCK,1,,<empty>,,,,1,,ANY
96828,BLOCK,1,,<empty>,,,,1,,ANY
96832,BLOCK,1,,<empty>,,,,1,,ANY
96839,BLOCK,1,,<empty>,,,,1,,ANY
96842,BLOCK,1,,<empty>,,,,1,,ANY
96846,BLOCK,1,,<empty>,,,,1,,ANY
96852,BLOCK,1,,<empty>,,,,1,,ANY
96857,BLOCK,1,,<empty>,,,,1,,ANY
96862,BLOCK,1,,<empty>,,,,1,,ANY
96866,BLOCK,1,,<empty>,,,,1,,ANY
96873,BLOCK,1,,<empty>,,,,1,,ANY
96877,BLOCK,1,,<empty>,,,,1,,ANY
96883,BLOCK,1,,<empty>,,,,1,,ANY
96890,BLOCK,1,,<empty>,,,,1,,ANY
96895,BLOCK,1,,<empty>,,,,1,,ANY
96900,BLOCK,1,,<empty>,,,,1,,ANY
96907,BLOCK,1,,<empty>,,,,1,,ANY
96911,BLOCK,1,,<empty>,,,,1,,ANY
96915,BLOCK,1,,<empty>,,,,1,,ANY
96923,BLOCK,1,,<empty>,,,,1,,ANY
96927,BLOCK,1,,<empty>,,,,1,,ANY
96932,BLOCK,1,,<empty>,,,,1,,ANY
96935,BLOCK,1,,<empty>,,,,1,,ANY
96939,BLOCK,1,,<empty>,,,,1,,ANY
96943,BLOCK,1,,<empty>,,,,1,,ANY
96948,BLOCK,1,,<empty>,,,,1,,ANY
96953,BLOCK,1,,<empty>,,,,1,,ANY
96956,BLOCK,1,,<empty>,,,,1,,ANY
96959,BLOCK,1,,<empty>,,,,1,,ANY
96966,BLOCK,1,,<empty>,,,,1,,ANY
96972,BLOCK,1,,<empty>,,,,1,,ANY
96977,BLOCK,1,,<empty>,,,,1,,ANY
96980,BLOCK,1,,<empty>,,,,1,,ANY
96984,BLOCK,1,,<empty>,,,,1,,ANY
96989,BLOCK,1,,<empty>,,,,1,,ANY
96994,BLOCK,1,,<empty>,,,,1,,ANY
96997,BLOCK,1,,<empty>,,,,1,,ANY
97001,BLOCK,1,,<empty>,,,,1,,ANY
97005,BLOCK,1,,<empty>,,,,1,,ANY
97011,BLOCK,1,,<empty>,,,,1,,ANY
97015,BLOCK,1,,<empty>,,,,1,,ANY
97019,BLOCK,1,,<empty>,,,,1,,ANY
97023,BLOCK,1,,<empty>,,,,1,,ANY
97027,BLOCK,1,,<empty>,,,,1,,ANY
97032,BLOCK,1,,<empty>,,,,1,,ANY
97036,BLOCK,1,,<empty>,,,,1,,ANY
97042,BLOCK,1,,<empty>,,,,1,,ANY
97046,BLOCK,1,,<empty>,,,,1,,ANY
97050,BLOCK,1,,<empty>,,,,1,,ANY
97055,BLOCK,1,,<empty>,,,,1,,ANY
97061,BLOCK,1,,<empty>,,,,1,,ANY
97065,BLOCK,1,,<empty>,,,,1,,ANY
97070,BLOCK,1,,<empty>,,,,1,,ANY
97075,BLOCK,1,,<empty>,,,,1,,ANY
97079,BLOCK,1,,<empty>,,,,1,,ANY
97083,BLOCK,1,,<empty>,,,,1,,ANY
97087,BLOCK,1,,<empty>,,,,1,,ANY
97092,BLOCK,1,,<empty>,,,,1,,ANY
97099,BLOCK,1,,<empty>,,,,1,,ANY
97104,BLOCK,1,,<empty>,,,,1,,ANY
97109,BLOCK,1,,<empty>,,,,1,,ANY
97113,BLOCK,1,,<empty>,,,,1,,ANY
97118,BLOCK,1,,<empty>,,,,1,,ANY
97123,BLOCK,1,,<empty>,,,,1,,ANY
97126,BLOCK,1,,<empty>,,,,1,,ANY
97131,BLOCK,1,,<empty>,,,,1,,ANY
97137,BLOCK,1,,<empty>,,,,1,,ANY
97141,BLOCK,1,,<empty>,,,,1,,ANY
97146,BLOCK,1,,<empty>,,,,1,,ANY
97152,BLOCK,1,,<empty>,,,,1,,ANY
97157,BLOCK,1,,<empty>,,,,1,,ANY
97161,BLOCK,1,,<empty>,,,,1,,ANY
97167,BLOCK,1,,<empty>,,,,1,,ANY
97172,BLOCK,1,,<empty>,,,,1,,ANY
97178,BLOCK,1,,<empty>,,,,1,,ANY
97182,BLOCK,1,,<empty>,,,,1,,ANY
97186,BLOCK,1,,<empty>,,,,1,,ANY
97192,BLOCK,1,,<empty>,,,,1,,ANY
97197,BLOCK,1,,<empty>,,,,1,,ANY
97202,BLOCK,1,,<empty>,,,,1,,ANY
97206,BLOCK,1,,<empty>,,,,1,,ANY
97211,BLOCK,1,,<empty>,,,,1,,ANY
97215,BLOCK,1,,<empty>,,,,1,,ANY
97218,BLOCK,1,,<empty>,,,,1,,ANY
97223,BLOCK,1,,<empty>,,,,1,,ANY
97228,BLOCK,1,,<empty>,,,,1,,ANY
97233,BLOCK,1,,<empty>,,,,1,,ANY
97238,BLOCK,1,,<empty>,,,,1,,ANY
97242,BLOCK,1,,<empty>,,,,1,,ANY
97247,BLOCK,1,,<empty>,,,,1,,ANY
97252,BLOCK,1,,<empty>,,,,1,,ANY
97258,BLOCK,1,,<empty>,,,,1,,ANY
97266,BLOCK,1,,<empty>,,,,1,,ANY
97271,BLOCK,1,,<empty>,,,,1,,ANY
97275,BLOCK,1,,<empty>,,,,1,,ANY
97279,BLOCK,1,,<empty>,,,,1,,ANY
97283,BLOCK,1,,<empty>,,,,1,,ANY
97288,BLOCK,1,,<empty>,,,,1,,ANY
97292,BLOCK,1,,<empty>,,,,1,,ANY
97297,BLOCK,1,,<empty>,,,,1,,ANY
97301,BLOCK,1,,<empty>,,,,1,,ANY
97307,BLOCK,1,,<empty>,,,,1,,ANY
97311,BLOCK,1,,<empty>,,,,1,,ANY
97316,BLOCK,1,,<empty>,,,,1,,ANY
97320,BLOCK,1,,<empty>,,,,1,,ANY
97323,BLOCK,1,,<empty>,,,,1,,ANY
97329,BLOCK,1,,<empty>,,,,1,,ANY
97333,BLOCK,1,,<empty>,,,,1,,ANY
97338,BLOCK,1,,<empty>,,,,1,,ANY
97344,BLOCK,1,,<empty>,,,,1,,ANY
97348,BLOCK,1,,<empty>,,,,1,,ANY
97355,BLOCK,1,,<empty>,,,,1,,ANY
97363,BLOCK,1,,<empty>,,,,1,,ANY
97368,BLOCK,1,,<empty>,,,,1,,ANY
97372,BLOCK,1,,<empty>,,,,1,,ANY
97377,BLOCK,1,,<empty>,,,,1,,ANY
97382,BLOCK,1,,<empty>,,,,1,,ANY
97388,BLOCK,1,,<empty>,,,,1,,ANY
97392,BLOCK,1,,<empty>,,,,1,,ANY
97397,BLOCK,1,,<empty>,,,,1,,ANY
97403,BLOCK,1,,<empty>,,,,1,,ANY
97409,BLOCK,1,,<empty>,,,,1,,ANY
97415,BLOCK,1,,<empty>,,,,1,,ANY
97419,BLOCK,1,,<empty>,,,,1,,ANY
97425,BLOCK,1,,<empty>,,,,1,,ANY
97430,BLOCK,1,,<empty>,,,,1,,ANY
97435,BLOCK,1,,<empty>,,,,1,,ANY
97439,BLOCK,1,,<empty>,,,,1,,ANY
97445,BLOCK,1,,<empty>,,,,1,,ANY
97451,BLOCK,1,,<empty>,,,,1,,ANY
97457,BLOCK,1,,<empty>,,,,1,,ANY
97461,BLOCK,1,,<empty>,,,,1,,ANY
97466,BLOCK,1,,<empty>,,,,1,,ANY
97475,BLOCK,1,,<empty>,,,,1,,ANY
97479,BLOCK,1,,<empty>,,,,1,,ANY
97485,BLOCK,1,,<empty>,,,,1,,ANY
97494,BLOCK,1,,<empty>,,,,1,,ANY
97498,BLOCK,1,,<empty>,,,,1,,ANY
97504,BLOCK,1,,<empty>,,,,1,,ANY
97509,BLOCK,1,,<empty>,,,,1,,ANY
97515,BLOCK,1,,<empty>,,,,1,,ANY
97518,BLOCK,1,,<empty>,,,,1,,ANY
97522,BLOCK,1,,<empty>,,,,1,,ANY
97529,BLOCK,1,,<empty>,,,,1,,ANY
97532,BLOCK,1,,<empty>,,,,1,,ANY
97538,BLOCK,1,,<empty>,,,,1,,ANY
97544,BLOCK,1,,<empty>,,,,1,,ANY
97547,BLOCK,1,,<empty>,,,,1,,ANY
97551,BLOCK,1,,<empty>,,,,1,,ANY
97557,BLOCK,1,,<empty>,,,,1,,ANY
97561,BLOCK,1,,<empty>,,,,1,,ANY
97564,BLOCK,1,,<empty>,,,,1,,ANY
97567,BLOCK,1,,<empty>,,,,1,,ANY
97571,BLOCK,1,,<empty>,,,,1,,ANY
97575,BLOCK,1,,<empty>,,,,1,,ANY
97579,BLOCK,1,,<empty>,,,,1,,ANY
97583,BLOCK,1,,<empty>,,,,1,,ANY
97587,BLOCK,1,,<empty>,,,,1,,ANY
97591,BLOCK,1,,<empty>,,,,1,,ANY
97595,BLOCK,1,,<empty>,,,,1,,ANY
97599,BLOCK,1,,<empty>,,,,1,,ANY
97604,BLOCK,1,,<empty>,,,,1,,ANY
97608,BLOCK,1,,<empty>,,,,1,,ANY
97612,BLOCK,1,,<empty>,,,,1,,ANY
97616,BLOCK,1,,<empty>,,,,1,,ANY
97620,BLOCK,1,,<empty>,,,,1,,ANY
97624,BLOCK,1,,<empty>,,,,1,,ANY
97629,BLOCK,1,,<empty>,,,,1,,ANY
97634,BLOCK,1,,<empty>,,,,1,,ANY
97638,BLOCK,1,,<empty>,,,,1,,ANY
97643,BLOCK,1,,<empty>,,,,1,,ANY
97647,BLOCK,1,,<empty>,,,,1,,ANY
97652,BLOCK,1,,<empty>,,,,1,,ANY
97657,BLOCK,1,,<empty>,,,,1,,ANY
97662,BLOCK,1,,<empty>,,,,1,,ANY
97667,BLOCK,1,,<empty>,,,,1,,ANY
97672,BLOCK,1,,<empty>,,,,1,,ANY
97676,BLOCK,1,,<empty>,,,,1,,ANY
97680,BLOCK,1,,<empty>,,,,1,,ANY
97684,BLOCK,1,,<empty>,,,,1,,ANY
97690,BLOCK,1,,<empty>,,,,1,,ANY
97696,BLOCK,1,,<empty>,,,,1,,ANY
97703,BLOCK,1,,<empty>,,,,1,,ANY
97709,BLOCK,1,,<empty>,,,,1,,ANY
97713,BLOCK,1,,<empty>,,,,1,,ANY
97718,BLOCK,1,,<empty>,,,,1,,ANY
97723,BLOCK,1,,<empty>,,,,1,,ANY
97731,BLOCK,1,,<empty>,,,,1,,ANY
97736,BLOCK,1,,<empty>,,,,1,,ANY
97741,BLOCK,1,,<empty>,,,,1,,ANY
97748,BLOCK,1,,<empty>,,,,1,,ANY
97754,BLOCK,1,,<empty>,,,,1,,ANY
97758,BLOCK,1,,<empty>,,,,1,,ANY
97762,BLOCK,1,,<empty>,,,,1,,ANY
97766,BLOCK,1,,<empty>,,,,1,,ANY
97770,BLOCK,1,,<empty>,,,,1,,ANY
97776,BLOCK,1,,<empty>,,,,1,,ANY
97781,BLOCK,1,,<empty>,,,,1,,ANY
97785,BLOCK,1,,<empty>,,,,1,,ANY
97789,BLOCK,1,,<empty>,,,,1,,ANY
97795,BLOCK,1,,<empty>,,,,1,,ANY
97800,BLOCK,1,,<empty>,,,,1,,ANY
97804,BLOCK,1,,<empty>,,,,1,,ANY
97809,BLOCK,1,,<empty>,,,,1,,ANY
97814,BLOCK,1,,<empty>,,,,1,,ANY
97819,BLOCK,1,,<empty>,,,,1,,ANY
97823,BLOCK,1,,<empty>,,,,1,,ANY
97829,BLOCK,1,,<empty>,,,,1,,ANY
97835,BLOCK,1,,<empty>,,,,1,,ANY
97840,BLOCK,1,,<empty>,,,,1,,ANY
97845,BLOCK,1,,<empty>,,,,1,,ANY
97849,BLOCK,1,,<empty>,,,,1,,ANY
97853,BLOCK,1,,<empty>,,,,1,,ANY
97858,BLOCK,1,,<empty>,,,,1,,ANY
97862,BLOCK,1,,<empty>,,,,1,,ANY
97866,BLOCK,1,,<empty>,,,,1,,ANY
97870,BLOCK,1,,<empty>,,,,1,,ANY
97875,BLOCK,1,,<empty>,,,,1,,ANY
97880,BLOCK,1,,<empty>,,,,1,,ANY
97885,BLOCK,1,,<empty>,,,,1,,ANY
97888,BLOCK,1,,<empty>,,,,1,,ANY
97893,BLOCK,1,,<empty>,,,,1,,ANY
97898,BLOCK,1,,<empty>,,,,1,,ANY
97902,BLOCK,1,,<empty>,,,,1,,ANY
97905,BLOCK,1,,<empty>,,,,1,,ANY
97908,BLOCK,1,,<empty>,,,,1,,ANY
97913,BLOCK,1,,<empty>,,,,1,,ANY
97919,BLOCK,1,,<empty>,,,,1,,ANY
97923,BLOCK,1,,<empty>,,,,1,,ANY
97926,BLOCK,1,,<empty>,,,,1,,ANY
97931,BLOCK,1,,<empty>,,,,1,,ANY
97937,BLOCK,1,,<empty>,,,,1,,ANY
97940,BLOCK,1,,<empty>,,,,1,,ANY
97943,BLOCK,1,,<empty>,,,,1,,ANY
97947,BLOCK,1,,<empty>,,,,1,,ANY
97953,BLOCK,1,,<empty>,,,,1,,ANY
97956,BLOCK,1,,<empty>,,,,1,,ANY
97960,BLOCK,1,,<empty>,,,,1,,ANY
97964,BLOCK,1,,<empty>,,,,1,,ANY
97968,BLOCK,1,,<empty>,,,,1,,ANY
97972,BLOCK,1,,<empty>,,,,1,,ANY
97976,BLOCK,1,,<empty>,,,,1,,ANY
97979,BLOCK,1,,<empty>,,,,1,,ANY
97985,BLOCK,1,,<empty>,,,,1,,ANY
97989,BLOCK,1,,<empty>,,,,1,,ANY
97995,BLOCK,1,,<empty>,,,,1,,ANY
97999,BLOCK,1,,<empty>,,,,1,,ANY
98003,BLOCK,1,,<empty>,,,,1,,ANY
98008,BLOCK,1,,<empty>,,,,1,,ANY
98014,BLOCK,1,,<empty>,,,,1,,ANY
98018,BLOCK,1,,<empty>,,,,1,,ANY
98024,BLOCK,1,,<empty>,,,,1,,ANY
98029,BLOCK,1,,<empty>,,,,1,,ANY
98034,BLOCK,1,,<empty>,,,,1,,ANY
98040,BLOCK,1,,<empty>,,,,1,,ANY
98044,BLOCK,1,,<empty>,,,,1,,ANY
98051,BLOCK,1,,<empty>,,,,1,,ANY
98057,BLOCK,1,,<empty>,,,,1,,ANY
98063,BLOCK,1,,<empty>,,,,1,,ANY
98066,BLOCK,1,,<empty>,,,,1,,ANY
98070,BLOCK,1,,<empty>,,,,1,,ANY
98077,BLOCK,1,,<empty>,,,,1,,ANY
98083,BLOCK,1,,<empty>,,,,1,,ANY
98089,BLOCK,1,,<empty>,,,,1,,ANY
98095,BLOCK,1,,<empty>,,,,1,,ANY
98101,BLOCK,1,,<empty>,,,,1,,ANY
98107,BLOCK,1,,<empty>,,,,1,,ANY
98113,BLOCK,1,,<empty>,,,,1,,ANY
98116,BLOCK,1,,<empty>,,,,1,,ANY
98120,BLOCK,1,,<empty>,,,,1,,ANY
98127,BLOCK,1,,<empty>,,,,1,,ANY
98133,BLOCK,1,,<empty>,,,,1,,ANY
98139,BLOCK,1,,<empty>,,,,1,,ANY
98142,BLOCK,1,,<empty>,,,,1,,ANY
98146,BLOCK,1,,<empty>,,,,1,,ANY
98153,BLOCK,1,,<empty>,,,,1,,ANY
98156,BLOCK,1,,<empty>,,,,1,,ANY
98160,BLOCK,1,,<empty>,,,,1,,ANY
98163,BLOCK,1,,<empty>,,,,1,,ANY
98167,BLOCK,1,,<empty>,,,,1,,ANY
98174,BLOCK,1,,<empty>,,,,1,,ANY
98177,BLOCK,1,,<empty>,,,,1,,ANY
98180,BLOCK,1,,<empty>,,,,1,,ANY
98184,BLOCK,1,,<empty>,,,,1,,ANY
98191,BLOCK,1,,<empty>,,,,1,,ANY
98197,BLOCK,1,,<empty>,,,,1,,ANY
98202,BLOCK,1,,<empty>,,,,1,,ANY
98208,BLOCK,1,,<empty>,,,,1,,ANY
98214,BLOCK,1,,<empty>,,,,1,,ANY
98217,BLOCK,1,,<empty>,,,,1,,ANY
98221,BLOCK,1,,<empty>,,,,1,,ANY
98228,BLOCK,1,,<empty>,,,,1,,ANY
98234,BLOCK,1,,<empty>,,,,1,,ANY
98240,BLOCK,1,,<empty>,,,,1,,ANY
98245,BLOCK,1,,<empty>,,,,1,,ANY
98251,BLOCK,1,,<empty>,,,,1,,ANY
98257,BLOCK,1,,<empty>,,,,1,,ANY
98260,BLOCK,1,,<empty>,,,,1,,ANY
98263,BLOCK,1,,<empty>,,,,1,,ANY
98267,BLOCK,1,,<empty>,,,,1,,ANY
98274,BLOCK,1,,<empty>,,,,1,,ANY
98280,BLOCK,1,,<empty>,,,,1,,ANY
98283,BLOCK,1,,<empty>,,,,1,,ANY
98289,BLOCK,1,,<empty>,,,,1,,ANY
98292,BLOCK,1,,<empty>,,,,1,,ANY
98296,BLOCK,1,,<empty>,,,,1,,ANY
98303,BLOCK,1,,<empty>,,,,1,,ANY
98308,BLOCK,1,,<empty>,,,,1,,ANY
98311,BLOCK,1,,<empty>,,,,1,,ANY
98314,BLOCK,1,,<empty>,,,,1,,ANY
98318,BLOCK,1,,<empty>,,,,1,,ANY
98325,BLOCK,1,,<empty>,,,,1,,ANY
98331,BLOCK,1,,<empty>,,,,1,,ANY
98336,BLOCK,1,,<empty>,,,,1,,ANY
98342,BLOCK,1,,<empty>,,,,1,,ANY
98348,BLOCK,1,,<empty>,,,,1,,ANY
98354,BLOCK,1,,<empty>,,,,1,,ANY
98360,BLOCK,1,,<empty>,,,,1,,ANY
98366,BLOCK,1,,<empty>,,,,1,,ANY
98369,BLOCK,1,,<empty>,,,,1,,ANY
98373,BLOCK,1,,<empty>,,,,1,,ANY
98380,BLOCK,1,,<empty>,,,,1,,ANY
98384,BLOCK,1,,<empty>,,,,1,,ANY
98390,BLOCK,1,,<empty>,,,,1,,ANY
98393,BLOCK,1,,<empty>,,,,1,,ANY
98399,BLOCK,1,,<empty>,,,,1,,ANY
98405,BLOCK,1,,<empty>,,,,1,,ANY
98411,BLOCK,1,,<empty>,,,,1,,ANY
98417,BLOCK,1,,<empty>,,,,1,,ANY
98421,BLOCK,1,,<empty>,,,,1,,ANY
98427,BLOCK,1,,<empty>,,,,1,,ANY
98430,BLOCK,1,,<empty>,,,,1,,ANY
98434,BLOCK,1,,<empty>,,,,1,,ANY
98441,BLOCK,1,,<empty>,,,,1,,ANY
98445,BLOCK,1,,<empty>,,,,1,,ANY
98451,BLOCK,1,,<empty>,,,,1,,ANY
98455,BLOCK,1,,<empty>,,,,1,,ANY
98462,BLOCK,1,,<empty>,,,,1,,ANY
98466,BLOCK,1,,<empty>,,,,1,,ANY
98472,BLOCK,1,,<empty>,,,,1,,ANY
98476,BLOCK,1,,<empty>,,,,1,,ANY
98483,BLOCK,1,,<empty>,,,,1,,ANY
98489,BLOCK,1,,<empty>,,,,1,,ANY
98495,BLOCK,1,,<empty>,,,,1,,ANY
98499,BLOCK,1,,<empty>,,,,1,,ANY
98505,BLOCK,1,,<empty>,,,,1,,ANY
98511,BLOCK,1,,<empty>,,,,1,,ANY
98517,BLOCK,1,,<empty>,,,,1,,ANY
98523,BLOCK,1,,<empty>,,,,1,,ANY
98529,BLOCK,1,,<empty>,,,,1,,ANY
98535,BLOCK,1,,<empty>,,,,1,,ANY
98541,BLOCK,1,,<empty>,,,,1,,ANY
98545,BLOCK,1,,<empty>,,,,1,,ANY
98552,BLOCK,1,,<empty>,,,,1,,ANY
98558,BLOCK,1,,<empty>,,,,1,,ANY
98564,BLOCK,1,,<empty>,,,,1,,ANY
98570,BLOCK,1,,<empty>,,,,1,,ANY
98574,BLOCK,1,,<empty>,,,,1,,ANY
98580,BLOCK,1,,<empty>,,,,1,,ANY
98586,BLOCK,1,,<empty>,,,,1,,ANY
98592,BLOCK,1,,<empty>,,,,1,,ANY
98596,BLOCK,1,,<empty>,,,,1,,ANY
98603,BLOCK,1,,<empty>,,,,1,,ANY
98609,BLOCK,1,,<empty>,,,,1,,ANY
98613,BLOCK,1,,<empty>,,,,1,,ANY
98616,BLOCK,1,,<empty>,,,,1,,ANY
98620,BLOCK,1,,<empty>,,,,1,,ANY
98627,BLOCK,1,,<empty>,,,,1,,ANY
98633,BLOCK,1,,<empty>,,,,1,,ANY
98636,BLOCK,1,,<empty>,,,,1,,ANY
98642,BLOCK,1,,<empty>,,,,1,,ANY
98648,BLOCK,1,,<empty>,,,,1,,ANY
98654,BLOCK,1,,<empty>,,,,1,,ANY
98657,BLOCK,1,,<empty>,,,,1,,ANY
98661,BLOCK,1,,<empty>,,,,1,,ANY
98668,BLOCK,1,,<empty>,,,,1,,ANY
98671,BLOCK,1,,<empty>,,,,1,,ANY
98674,BLOCK,1,,<empty>,,,,1,,ANY
98678,BLOCK,1,,<empty>,,,,1,,ANY
98685,BLOCK,1,,<empty>,,,,1,,ANY
98688,BLOCK,1,,<empty>,,,,1,,ANY
98692,BLOCK,1,,<empty>,,,,1,,ANY
98698,BLOCK,1,,<empty>,,,,1,,ANY
98704,BLOCK,1,,<empty>,,,,1,,ANY
98710,BLOCK,1,,<empty>,,,,1,,ANY
98716,BLOCK,1,,<empty>,,,,1,,ANY
98719,BLOCK,1,,<empty>,,,,1,,ANY
98723,BLOCK,1,,<empty>,,,,1,,ANY
98730,BLOCK,1,,<empty>,,,,1,,ANY
98733,BLOCK,1,,<empty>,,,,1,,ANY
98736,BLOCK,1,,<empty>,,,,1,,ANY
98739,BLOCK,1,,<empty>,,,,1,,ANY
98745,BLOCK,1,,<empty>,,,,1,,ANY
98750,BLOCK,1,,<empty>,,,,1,,ANY
98755,BLOCK,1,,<empty>,,,,1,,ANY
98761,BLOCK,1,,<empty>,,,,1,,ANY
98765,BLOCK,1,,<empty>,,,,1,,ANY
98771,BLOCK,1,,<empty>,,,,1,,ANY
98775,BLOCK,1,,<empty>,,,,1,,ANY
98782,BLOCK,1,,<empty>,,,,1,,ANY
98785,BLOCK,1,,<empty>,,,,1,,ANY
98789,BLOCK,1,,<empty>,,,,1,,ANY
98795,BLOCK,1,,<empty>,,,,1,,ANY
98801,BLOCK,1,,<empty>,,,,1,,ANY
98807,BLOCK,1,,<empty>,,,,1,,ANY
98813,BLOCK,1,,<empty>,,,,1,,ANY
98817,BLOCK,1,,<empty>,,,,1,,ANY
98823,BLOCK,1,,<empty>,,,,1,,ANY
98829,BLOCK,1,,<empty>,,,,1,,ANY
98835,BLOCK,1,,<empty>,,,,1,,ANY
98841,BLOCK,1,,<empty>,,,,1,,ANY
98847,BLOCK,1,,<empty>,,,,1,,ANY
98853,BLOCK,1,,<empty>,,,,1,,ANY
98857,BLOCK,1,,<empty>,,,,1,,ANY
98864,BLOCK,1,,<empty>,,,,1,,ANY
98867,BLOCK,1,,<empty>,,,,1,,ANY
98871,BLOCK,1,,<empty>,,,,1,,ANY
98875,BLOCK,1,,<empty>,,,,1,,ANY
98881,BLOCK,1,,<empty>,,,,1,,ANY
98887,BLOCK,1,,<empty>,,,,1,,ANY
98890,BLOCK,1,,<empty>,,,,1,,ANY
98896,BLOCK,1,,<empty>,,,,1,,ANY
98900,BLOCK,1,,<empty>,,,,1,,ANY
98906,BLOCK,1,,<empty>,,,,1,,ANY
98910,BLOCK,1,,<empty>,,,,1,,ANY
98917,BLOCK,1,,<empty>,,,,1,,ANY
98920,BLOCK,1,,<empty>,,,,1,,ANY
98924,BLOCK,1,,<empty>,,,,1,,ANY
98927,BLOCK,1,,<empty>,,,,1,,ANY
98933,BLOCK,1,,<empty>,,,,1,,ANY
98937,BLOCK,1,,<empty>,,,,1,,ANY
98944,BLOCK,1,,<empty>,,,,1,,ANY
98947,BLOCK,1,,<empty>,,,,1,,ANY
98951,BLOCK,1,,<empty>,,,,1,,ANY
98956,BLOCK,1,,<empty>,,,,1,,ANY
98959,BLOCK,1,,<empty>,,,,1,,ANY
98963,BLOCK,1,,<empty>,,,,1,,ANY
98967,BLOCK,1,,<empty>,,,,1,,ANY
98974,BLOCK,1,,<empty>,,,,1,,ANY
98977,BLOCK,1,,<empty>,,,,1,,ANY
98980,BLOCK,1,,<empty>,,,,1,,ANY
98986,BLOCK,1,,<empty>,,,,1,,ANY
98992,BLOCK,1,,<empty>,,,,1,,ANY
98997,BLOCK,1,,<empty>,,,,1,,ANY
99001,BLOCK,1,,<empty>,,,,1,,ANY
99005,BLOCK,1,,<empty>,,,,1,,ANY
99011,BLOCK,1,,<empty>,,,,1,,ANY
99016,BLOCK,1,,<empty>,,,,1,,ANY
99022,BLOCK,1,,<empty>,,,,1,,ANY
99028,BLOCK,1,,<empty>,,,,1,,ANY
99034,BLOCK,1,,<empty>,,,,1,,ANY
99040,BLOCK,1,,<empty>,,,,1,,ANY
99046,BLOCK,1,,<empty>,,,,1,,ANY
99052,BLOCK,1,,<empty>,,,,1,,ANY
99055,BLOCK,1,,<empty>,,,,1,,ANY
99061,BLOCK,1,,<empty>,,,,1,,ANY
99064,BLOCK,1,,<empty>,,,,1,,ANY
99068,BLOCK,1,,<empty>,,,,1,,ANY
99075,BLOCK,1,,<empty>,,,,1,,ANY
99078,BLOCK,1,,<empty>,,,,1,,ANY
99082,BLOCK,1,,<empty>,,,,1,,ANY
99088,BLOCK,1,,<empty>,,,,1,,ANY
99093,BLOCK,1,,<empty>,,,,1,,ANY
99099,BLOCK,1,,<empty>,,,,1,,ANY
99105,BLOCK,1,,<empty>,,,,1,,ANY
99111,BLOCK,1,,<empty>,,,,1,,ANY
99117,BLOCK,1,,<empty>,,,,1,,ANY
99123,BLOCK,1,,<empty>,,,,1,,ANY
99129,BLOCK,1,,<empty>,,,,1,,ANY
99135,BLOCK,1,,<empty>,,,,1,,ANY
99139,BLOCK,1,,<empty>,,,,1,,ANY
99142,BLOCK,1,,<empty>,,,,1,,ANY
99148,BLOCK,1,,<empty>,,,,1,,ANY
99153,BLOCK,1,,<empty>,,,,1,,ANY
99159,BLOCK,1,,<empty>,,,,1,,ANY
99165,BLOCK,1,,<empty>,,,,1,,ANY
99171,BLOCK,1,,<empty>,,,,1,,ANY
99177,BLOCK,1,,<empty>,,,,1,,ANY
99183,BLOCK,1,,<empty>,,,,1,,ANY
99189,BLOCK,1,,<empty>,,,,1,,ANY
99195,BLOCK,1,,<empty>,,,,1,,ANY
99201,BLOCK,1,,<empty>,,,,1,,ANY
99207,BLOCK,1,,<empty>,,,,1,,ANY
99210,BLOCK,1,,<empty>,,,,1,,ANY
99214,BLOCK,1,,<empty>,,,,1,,ANY
99221,BLOCK,1,,<empty>,,,,1,,ANY
99227,BLOCK,1,,<empty>,,,,1,,ANY
99232,BLOCK,1,,<empty>,,,,1,,ANY
99236,BLOCK,1,,<empty>,,,,1,,ANY
99240,BLOCK,1,,<empty>,,,,1,,ANY
99244,BLOCK,1,,<empty>,,,,1,,ANY
99248,BLOCK,1,,<empty>,,,,1,,ANY
99252,BLOCK,1,,<empty>,,,,1,,ANY
99259,BLOCK,1,,<empty>,,,,1,,ANY
99265,BLOCK,1,,<empty>,,,,1,,ANY
99271,BLOCK,1,,<empty>,,,,1,,ANY
99277,BLOCK,1,,<empty>,,,,1,,ANY
99280,BLOCK,1,,<empty>,,,,1,,ANY
99284,BLOCK,1,,<empty>,,,,1,,ANY
99291,BLOCK,1,,<empty>,,,,1,,ANY
99294,BLOCK,1,,<empty>,,,,1,,ANY
99298,BLOCK,1,,<empty>,,,,1,,ANY
99304,BLOCK,1,,<empty>,,,,1,,ANY
99310,BLOCK,1,,<empty>,,,,1,,ANY
99316,BLOCK,1,,<empty>,,,,1,,ANY
99321,BLOCK,1,,<empty>,,,,1,,ANY
99325,BLOCK,1,,<empty>,,,,1,,ANY
99331,BLOCK,1,,<empty>,,,,1,,ANY
99335,BLOCK,1,,<empty>,,,,1,,ANY
99341,BLOCK,1,,<empty>,,,,1,,ANY
99347,BLOCK,1,,<empty>,,,,1,,ANY
99353,BLOCK,1,,<empty>,,,,1,,ANY
99356,BLOCK,1,,<empty>,,,,1,,ANY
99360,BLOCK,1,,<empty>,,,,1,,ANY
99367,BLOCK,1,,<empty>,,,,1,,ANY
99370,BLOCK,1,,<empty>,,,,1,,ANY
99374,BLOCK,1,,<empty>,,,,1,,ANY
99380,BLOCK,1,,<empty>,,,,1,,ANY
99386,BLOCK,1,,<empty>,,,,1,,ANY
99390,BLOCK,1,,<empty>,,,,1,,ANY
99396,BLOCK,1,,<empty>,,,,1,,ANY
99400,BLOCK,1,,<empty>,,,,1,,ANY
99406,BLOCK,1,,<empty>,,,,1,,ANY
99412,BLOCK,1,,<empty>,,,,1,,ANY
99416,BLOCK,1,,<empty>,,,,1,,ANY
99423,BLOCK,1,,<empty>,,,,1,,ANY
99426,BLOCK,1,,<empty>,,,,1,,ANY
99430,BLOCK,1,,<empty>,,,,1,,ANY
99434,BLOCK,1,,<empty>,,,,1,,ANY
99440,BLOCK,1,,<empty>,,,,1,,ANY
99446,BLOCK,1,,<empty>,,,,1,,ANY
99450,BLOCK,1,,<empty>,,,,1,,ANY
99457,BLOCK,1,,<empty>,,,,1,,ANY
99463,BLOCK,1,,<empty>,,,,1,,ANY
99469,BLOCK,1,,<empty>,,,,1,,ANY
99475,BLOCK,1,,<empty>,,,,1,,ANY
99478,BLOCK,1,,<empty>,,,,1,,ANY
99484,BLOCK,1,,<empty>,,,,1,,ANY
99490,BLOCK,1,,<empty>,,,,1,,ANY
99493,BLOCK,1,,<empty>,,,,1,,ANY
99499,BLOCK,1,,<empty>,,,,1,,ANY
99505,BLOCK,1,,<empty>,,,,1,,ANY
99511,BLOCK,1,,<empty>,,,,1,,ANY
99517,BLOCK,1,,<empty>,,,,1,,ANY
99523,BLOCK,1,,<empty>,,,,1,,ANY
99529,BLOCK,1,,<empty>,,,,1,,ANY
99535,BLOCK,1,,<empty>,,,,1,,ANY
99541,BLOCK,1,,<empty>,,,,1,,ANY
99547,BLOCK,1,,<empty>,,,,1,,ANY
99553,BLOCK,1,,<empty>,,,,1,,ANY
99559,BLOCK,1,,<empty>,,,,1,,ANY
99562,BLOCK,1,,<empty>,,,,1,,ANY
99566,BLOCK,1,,<empty>,,,,1,,ANY
99573,BLOCK,1,,<empty>,,,,1,,ANY
99576,BLOCK,1,,<empty>,,,,1,,ANY
99582,BLOCK,1,,<empty>,,,,1,,ANY
99588,BLOCK,1,,<empty>,,,,1,,ANY
99594,BLOCK,1,,<empty>,,,,1,,ANY
99597,BLOCK,1,,<empty>,,,,1,,ANY
99603,BLOCK,1,,<empty>,,,,1,,ANY
99607,BLOCK,1,,<empty>,,,,1,,ANY
99614,BLOCK,1,,<empty>,,,,1,,ANY
99617,BLOCK,1,,<empty>,,,,1,,ANY
99620,BLOCK,1,,<empty>,,,,1,,ANY
99626,BLOCK,1,,<empty>,,,,1,,ANY
99630,BLOCK,1,,<empty>,,,,1,,ANY
99637,BLOCK,1,,<empty>,,,,1,,ANY
99640,BLOCK,1,,<empty>,,,,1,,ANY
99644,BLOCK,1,,<empty>,,,,1,,ANY
99649,BLOCK,1,,<empty>,,,,1,,ANY
99653,BLOCK,1,,<empty>,,,,1,,ANY
99657,BLOCK,1,,<empty>,,,,1,,ANY
99664,BLOCK,1,,<empty>,,,,1,,ANY
99667,BLOCK,1,,<empty>,,,,1,,ANY
99671,BLOCK,1,,<empty>,,,,1,,ANY
99677,BLOCK,1,,<empty>,,,,1,,ANY
99683,BLOCK,1,,<empty>,,,,1,,ANY
99689,BLOCK,1,,<empty>,,,,1,,ANY
99695,BLOCK,1,,<empty>,,,,1,,ANY
99701,BLOCK,1,,<empty>,,,,1,,ANY
99707,BLOCK,1,,<empty>,,,,1,,ANY
99713,BLOCK,1,,<empty>,,,,1,,ANY
99719,BLOCK,1,,<empty>,,,,1,,ANY
99724,BLOCK,1,,<empty>,,,,1,,ANY
99730,BLOCK,1,,<empty>,,,,1,,ANY
99734,BLOCK,1,,<empty>,,,,1,,ANY
99741,BLOCK,1,,<empty>,,,,1,,ANY
99747,BLOCK,1,,<empty>,,,,1,,ANY
99750,BLOCK,1,,<empty>,,,,1,,ANY
99756,BLOCK,1,,<empty>,,,,1,,ANY
99761,BLOCK,1,,<empty>,,,,1,,ANY
99767,BLOCK,1,,<empty>,,,,1,,ANY
99773,BLOCK,1,,<empty>,,,,1,,ANY
99779,BLOCK,1,,<empty>,,,,1,,ANY
99785,BLOCK,1,,<empty>,,,,1,,ANY
99789,BLOCK,1,,<empty>,,,,1,,ANY
99796,BLOCK,1,,<empty>,,,,1,,ANY
99800,BLOCK,1,,<empty>,,,,1,,ANY
99804,BLOCK,1,,<empty>,,,,1,,ANY
99810,BLOCK,1,,<empty>,,,,1,,ANY
99816,BLOCK,1,,<empty>,,,,1,,ANY
99822,BLOCK,1,,<empty>,,,,1,,ANY
99826,BLOCK,1,,<empty>,,,,1,,ANY
99830,BLOCK,1,,<empty>,,,,1,,ANY
99834,BLOCK,1,,<empty>,,,,1,,ANY
99841,BLOCK,1,,<empty>,,,,1,,ANY
99844,BLOCK,1,,<empty>,,,,1,,ANY
99848,BLOCK,1,,<empty>,,,,1,,ANY
99855,BLOCK,1,,<empty>,,,,1,,ANY
99858,BLOCK,1,,<empty>,,,,1,,ANY
99862,BLOCK,1,,<empty>,,,,1,,ANY
99867,BLOCK,1,,<empty>,,,,1,,ANY
99870,BLOCK,1,,<empty>,,,,1,,ANY
99873,BLOCK,1,,<empty>,,,,1,,ANY
99879,BLOCK,1,,<empty>,,,,1,,ANY
99883,BLOCK,1,,<empty>,,,,1,,ANY
99890,BLOCK,1,,<empty>,,,,1,,ANY
99893,BLOCK,1,,<empty>,,,,1,,ANY
99897,BLOCK,1,,<empty>,,,,1,,ANY
99902,BLOCK,1,,<empty>,,,,1,,ANY
99908,BLOCK,1,,<empty>,,,,1,,ANY
99912,BLOCK,1,,<empty>,,,,1,,ANY
99919,BLOCK,1,,<empty>,,,,1,,ANY
99922,BLOCK,1,,<empty>,,,,1,,ANY
99926,BLOCK,1,,<empty>,,,,1,,ANY
99933,BLOCK,1,,<empty>,,,,1,,ANY
99939,BLOCK,1,,<empty>,,,,1,,ANY
99946,BLOCK,1,,<empty>,,,,1,,ANY
99952,BLOCK,1,,<empty>,,,,1,,ANY
99959,BLOCK,1,,<empty>,,,,1,,ANY
99965,BLOCK,1,,<empty>,,,,1,,ANY
99969,BLOCK,1,,<empty>,,,,1,,ANY
99976,BLOCK,1,,<empty>,,,,1,,ANY
99979,BLOCK,1,,<empty>,,,,1,,ANY
99983,BLOCK,1,,<empty>,,,,1,,ANY
99989,BLOCK,1,,<empty>,,,,1,,ANY
99995,BLOCK,1,,<empty>,,,,1,,ANY
99998,BLOCK,1,,<empty>,,,,1,,ANY
100002,BLOCK,1,,<empty>,,,,1,,ANY
100006,BLOCK,1,,<empty>,,,,1,,ANY
100010,BLOCK,1,,<empty>,,,,1,,ANY
100017,BLOCK,1,,<empty>,,,,1,,ANY
100020,BLOCK,1,,<empty>,,,,1,,ANY
100023,BLOCK,1,,<empty>,,,,1,,ANY
100026,BLOCK,1,,<empty>,,,,1,,ANY
100032,BLOCK,1,,<empty>,,,,1,,ANY
100035,BLOCK,1,,<empty>,,,,1,,ANY
100039,BLOCK,1,,<empty>,,,,1,,ANY
100044,BLOCK,1,,<empty>,,,,1,,ANY
100048,BLOCK,1,,<empty>,,,,1,,ANY
100052,BLOCK,1,,<empty>,,,,1,,ANY
100059,BLOCK,1,,<empty>,,,,1,,ANY
100062,BLOCK,1,,<empty>,,,,1,,ANY
100065,BLOCK,1,,<empty>,,,,1,,ANY
100068,BLOCK,1,,<empty>,,,,1,,ANY
100074,BLOCK,1,,<empty>,,,,1,,ANY
100077,BLOCK,1,,<empty>,,,,1,,ANY
100081,BLOCK,1,,<empty>,,,,1,,ANY
100085,BLOCK,1,,<empty>,,,,1,,ANY
100092,BLOCK,1,,<empty>,,,,1,,ANY
100097,BLOCK,1,,<empty>,,,,1,,ANY
100100,BLOCK,1,,<empty>,,,,1,,ANY
100106,BLOCK,1,,<empty>,,,,1,,ANY
100110,BLOCK,1,,<empty>,,,,1,,ANY
100117,BLOCK,1,,<empty>,,,,1,,ANY
100120,BLOCK,1,,<empty>,,,,1,,ANY
100124,BLOCK,1,,<empty>,,,,1,,ANY
100130,BLOCK,1,,<empty>,,,,1,,ANY
100135,BLOCK,1,,<empty>,,,,1,,ANY
100140,BLOCK,1,,<empty>,,,,1,,ANY
100143,BLOCK,1,,<empty>,,,,1,,ANY
100147,BLOCK,1,,<empty>,,,,1,,ANY
100151,BLOCK,1,,<empty>,,,,1,,ANY
100157,BLOCK,1,,<empty>,,,,1,,ANY
100164,BLOCK,1,,<empty>,,,,1,,ANY
100170,BLOCK,1,,<empty>,,,,1,,ANY
100176,BLOCK,1,,<empty>,,,,1,,ANY
100182,BLOCK,1,,<empty>,,,,1,,ANY
100188,BLOCK,1,,<empty>,,,,1,,ANY
100191,BLOCK,1,,<empty>,,,,1,,ANY
100195,BLOCK,1,,<empty>,,,,1,,ANY
100200,BLOCK,1,,<empty>,,,,1,,ANY
100207,BLOCK,1,,<empty>,,,,1,,ANY
100211,BLOCK,1,,<empty>,,,,1,,ANY
100217,BLOCK,1,,<empty>,,,,1,,ANY
100223,BLOCK,1,,<empty>,,,,1,,ANY
100229,BLOCK,1,,<empty>,,,,1,,ANY
100233,BLOCK,1,,<empty>,,,,1,,ANY
100237,BLOCK,1,,<empty>,,,,1,,ANY
100244,BLOCK,1,,<empty>,,,,1,,ANY
100247,BLOCK,1,,<empty>,,,,1,,ANY
100254,BLOCK,1,,<empty>,,,,1,,ANY
100260,BLOCK,1,,<empty>,,,,1,,ANY
100264,BLOCK,1,,<empty>,,,,1,,ANY
100269,BLOCK,1,,<empty>,,,,1,,ANY
100273,BLOCK,1,,<empty>,,,,1,,ANY
100278,BLOCK,1,,<empty>,,,,1,,ANY
100283,BLOCK,1,,<empty>,,,,1,,ANY
100289,BLOCK,1,,<empty>,,,,1,,ANY
100294,BLOCK,1,,<empty>,,,,1,,ANY
100298,BLOCK,1,,<empty>,,,,1,,ANY
100302,BLOCK,1,,<empty>,,,,1,,ANY
100309,BLOCK,1,,<empty>,,,,1,,ANY
100313,BLOCK,1,,<empty>,,,,1,,ANY
100317,BLOCK,1,,<empty>,,,,1,,ANY
100320,BLOCK,1,,<empty>,,,,1,,ANY
100324,BLOCK,1,,<empty>,,,,1,,ANY
100330,BLOCK,1,,<empty>,,,,1,,ANY
100337,BLOCK,1,,<empty>,,,,1,,ANY
100344,BLOCK,1,,<empty>,,,,1,,ANY
100350,BLOCK,1,,<empty>,,,,1,,ANY
100356,BLOCK,1,,<empty>,,,,1,,ANY
100362,BLOCK,1,,<empty>,,,,1,,ANY
100368,BLOCK,1,,<empty>,,,,1,,ANY
100374,BLOCK,1,,<empty>,,,,1,,ANY
100380,BLOCK,1,,<empty>,,,,1,,ANY
100386,BLOCK,1,,<empty>,,,,1,,ANY
100394,BLOCK,1,,<empty>,,,,1,,ANY
100400,BLOCK,1,,<empty>,,,,1,,ANY
100405,BLOCK,1,,<empty>,,,,1,,ANY
100408,BLOCK,1,,<empty>,,,,1,,ANY
100412,BLOCK,1,,<empty>,,,,1,,ANY
100415,BLOCK,1,,<empty>,,,,1,,ANY
100419,BLOCK,1,,<empty>,,,,1,,ANY
100422,BLOCK,1,,<empty>,,,,1,,ANY
100429,BLOCK,1,,<empty>,,,,1,,ANY
100434,BLOCK,1,,<empty>,,,,1,,ANY
100440,BLOCK,1,,<empty>,,,,1,,ANY
100446,BLOCK,1,,<empty>,,,,1,,ANY
100451,BLOCK,1,,<empty>,,,,1,,ANY
100457,BLOCK,1,,<empty>,,,,1,,ANY
100466,BLOCK,1,,<empty>,,,,1,,ANY
100472,BLOCK,1,,<empty>,,,,1,,ANY
100478,BLOCK,1,,<empty>,,,,1,,ANY
100484,BLOCK,1,,<empty>,,,,1,,ANY
100490,BLOCK,1,,<empty>,,,,1,,ANY
100495,BLOCK,1,,<empty>,,,,1,,ANY
100500,BLOCK,1,,<empty>,,,,1,,ANY
100505,BLOCK,1,,<empty>,,,,1,,ANY
100509,BLOCK,1,,<empty>,,,,1,,ANY
100513,BLOCK,1,,<empty>,,,,1,,ANY
100518,BLOCK,1,,<empty>,,,,1,,ANY
100524,BLOCK,1,,<empty>,,,,1,,ANY
100529,BLOCK,1,,<empty>,,,,1,,ANY
100536,BLOCK,1,,<empty>,,,,1,,ANY
100542,BLOCK,1,,<empty>,,,,1,,ANY
100547,BLOCK,1,,<empty>,,,,1,,ANY
100552,BLOCK,1,,<empty>,,,,1,,ANY
100557,BLOCK,1,,<empty>,,,,1,,ANY
100561,BLOCK,1,,<empty>,,,,1,,ANY
100566,BLOCK,1,,<empty>,,,,1,,ANY
100570,BLOCK,1,,<empty>,,,,1,,ANY
100576,BLOCK,1,,<empty>,,,,1,,ANY
100582,BLOCK,1,,<empty>,,,,1,,ANY
100588,BLOCK,1,,<empty>,,,,1,,ANY
100592,BLOCK,1,,<empty>,,,,1,,ANY
100598,BLOCK,1,,<empty>,,,,1,,ANY
100604,BLOCK,1,,<empty>,,,,1,,ANY
100610,BLOCK,1,,<empty>,,,,1,,ANY
100614,BLOCK,1,,<empty>,,,,1,,ANY
100621,BLOCK,1,,<empty>,,,,1,,ANY
100627,BLOCK,1,,<empty>,,,,1,,ANY
100631,BLOCK,1,,<empty>,,,,1,,ANY
100638,BLOCK,1,,<empty>,,,,1,,ANY
100644,BLOCK,1,,<empty>,,,,1,,ANY
100649,BLOCK,1,,<empty>,,,,1,,ANY
100655,BLOCK,1,,<empty>,,,,1,,ANY
100661,BLOCK,1,,<empty>,,,,1,,ANY
100667,BLOCK,1,,<empty>,,,,1,,ANY
100673,BLOCK,1,,<empty>,,,,1,,ANY
100679,BLOCK,1,,<empty>,,,,1,,ANY
100685,BLOCK,1,,<empty>,,,,1,,ANY
100691,BLOCK,1,,<empty>,,,,1,,ANY
100695,BLOCK,1,,<empty>,,,,1,,ANY
100702,BLOCK,1,,<empty>,,,,1,,ANY
100708,BLOCK,1,,<empty>,,,,1,,ANY
100712,BLOCK,1,,<empty>,,,,1,,ANY
100718,BLOCK,1,,<empty>,,,,1,,ANY
100723,BLOCK,1,,<empty>,,,,1,,ANY
100728,BLOCK,1,,<empty>,,,,1,,ANY
100735,BLOCK,1,,<empty>,,,,1,,ANY
100739,BLOCK,1,,<empty>,,,,1,,ANY
100744,BLOCK,1,,<empty>,,,,1,,ANY
100749,BLOCK,1,,<empty>,,,,1,,ANY
100756,BLOCK,1,,<empty>,,,,1,,ANY
100761,BLOCK,1,,<empty>,,,,1,,ANY
100765,BLOCK,1,,<empty>,,,,1,,ANY
100773,BLOCK,1,,<empty>,,,,1,,ANY
100778,BLOCK,1,,<empty>,,,,1,,ANY
100784,BLOCK,1,,<empty>,,,,1,,ANY
100790,BLOCK,1,,<empty>,,,,1,,ANY
100796,BLOCK,1,,<empty>,,,,1,,ANY
100801,BLOCK,1,,<empty>,,,,1,,ANY
100806,BLOCK,1,,<empty>,,,,1,,ANY
100810,BLOCK,1,,<empty>,,,,1,,ANY
100813,BLOCK,1,,<empty>,,,,1,,ANY
100817,BLOCK,1,,<empty>,,,,1,,ANY
100822,BLOCK,1,,<empty>,,,,1,,ANY
100826,BLOCK,1,,<empty>,,,,1,,ANY
100830,BLOCK,1,,<empty>,,,,1,,ANY
100834,BLOCK,1,,<empty>,,,,1,,ANY
100839,BLOCK,1,,<empty>,,,,1,,ANY
100842,BLOCK,1,,<empty>,,,,1,,ANY
100845,BLOCK,1,,<empty>,,,,1,,ANY
100849,BLOCK,1,,<empty>,,,,1,,ANY
100853,BLOCK,1,,<empty>,,,,1,,ANY
100858,BLOCK,1,,<empty>,,,,1,,ANY
100862,BLOCK,1,,<empty>,,,,1,,ANY
100866,BLOCK,1,,<empty>,,,,1,,ANY
100871,BLOCK,1,,<empty>,,,,1,,ANY
100877,BLOCK,1,,<empty>,,,,1,,ANY
100881,BLOCK,1,,<empty>,,,,1,,ANY
100886,BLOCK,1,,<empty>,,,,1,,ANY
100890,BLOCK,1,,<empty>,,,,1,,ANY
100895,BLOCK,1,,<empty>,,,,1,,ANY
100898,BLOCK,1,,<empty>,,,,1,,ANY
100903,BLOCK,1,,<empty>,,,,1,,ANY
100908,BLOCK,1,,<empty>,,,,1,,ANY
100913,BLOCK,1,,<empty>,,,,1,,ANY
100919,BLOCK,1,,<empty>,,,,1,,ANY
100923,BLOCK,1,,<empty>,,,,1,,ANY
100927,BLOCK,1,,<empty>,,,,1,,ANY
100931,BLOCK,1,,<empty>,,,,1,,ANY
100935,BLOCK,1,,<empty>,,,,1,,ANY
100938,BLOCK,1,,<empty>,,,,1,,ANY
100943,BLOCK,1,,<empty>,,,,1,,ANY
100948,BLOCK,1,,<empty>,,,,1,,ANY
100952,BLOCK,1,,<empty>,,,,1,,ANY
100955,BLOCK,1,,<empty>,,,,1,,ANY
100961,BLOCK,1,,<empty>,,,,1,,ANY
100967,BLOCK,1,,<empty>,,,,1,,ANY
100973,BLOCK,1,,<empty>,,,,1,,ANY
100979,BLOCK,1,,<empty>,,,,1,,ANY
100984,BLOCK,1,,<empty>,,,,1,,ANY
100990,BLOCK,1,,<empty>,,,,1,,ANY
100993,BLOCK,1,,<empty>,,,,1,,ANY
100997,BLOCK,1,,<empty>,,,,1,,ANY
101001,BLOCK,1,,<empty>,,,,1,,ANY
101008,BLOCK,1,,<empty>,,,,1,,ANY
101012,BLOCK,1,,<empty>,,,,1,,ANY
101015,BLOCK,1,,<empty>,,,,1,,ANY
101019,BLOCK,1,,<empty>,,,,1,,ANY
101026,BLOCK,1,,<empty>,,,,1,,ANY
101030,BLOCK,1,,<empty>,,,,1,,ANY
101033,BLOCK,1,,<empty>,,,,1,,ANY
101039,BLOCK,1,,<empty>,,,,1,,ANY
101043,BLOCK,1,,<empty>,,,,1,,ANY
101048,BLOCK,1,,<empty>,,,,1,,ANY
101054,BLOCK,1,,<empty>,,,,1,,ANY
101058,BLOCK,1,,<empty>,,,,1,,ANY
101065,BLOCK,1,,<empty>,,,,1,,ANY
101071,BLOCK,1,,<empty>,,,,1,,ANY
101077,BLOCK,1,,<empty>,,,,1,,ANY
101083,BLOCK,1,,<empty>,,,,1,,ANY
101089,BLOCK,1,,<empty>,,,,1,,ANY
101093,BLOCK,1,,<empty>,,,,1,,ANY
101100,BLOCK,1,,<empty>,,,,1,,ANY
101104,BLOCK,1,,<empty>,,,,1,,ANY
101108,BLOCK,1,,<empty>,,,,1,,ANY
101114,BLOCK,1,,<empty>,,,,1,,ANY
101120,BLOCK,1,,<empty>,,,,1,,ANY
101126,BLOCK,1,,<empty>,,,,1,,ANY
101132,BLOCK,1,,<empty>,,,,1,,ANY
101138,BLOCK,1,,<empty>,,,,1,,ANY
101142,BLOCK,1,,<empty>,,,,1,,ANY
101148,BLOCK,1,,<empty>,,,,1,,ANY
101154,BLOCK,1,,<empty>,,,,1,,ANY
101160,BLOCK,1,,<empty>,,,,1,,ANY
101166,BLOCK,1,,<empty>,,,,1,,ANY
101170,BLOCK,1,,<empty>,,,,1,,ANY
101176,BLOCK,1,,<empty>,,,,1,,ANY
101182,BLOCK,1,,<empty>,,,,1,,ANY
101189,BLOCK,1,,<empty>,,,,1,,ANY
101195,BLOCK,1,,<empty>,,,,1,,ANY
101202,BLOCK,1,,<empty>,,,,1,,ANY
101207,BLOCK,1,,<empty>,,,,1,,ANY
101212,BLOCK,1,,<empty>,,,,1,,ANY
101215,BLOCK,1,,<empty>,,,,1,,ANY
101219,BLOCK,1,,<empty>,,,,1,,ANY
101224,BLOCK,1,,<empty>,,,,1,,ANY
101229,BLOCK,1,,<empty>,,,,1,,ANY
101235,BLOCK,1,,<empty>,,,,1,,ANY
101240,BLOCK,1,,<empty>,,,,1,,ANY
101245,BLOCK,1,,<empty>,,,,1,,ANY
101249,BLOCK,1,,<empty>,,,,1,,ANY
101254,BLOCK,1,,<empty>,,,,1,,ANY
101259,BLOCK,1,,<empty>,,,,1,,ANY
101263,BLOCK,1,,<empty>,,,,1,,ANY
101269,BLOCK,1,,<empty>,,,,1,,ANY
101275,BLOCK,1,,<empty>,,,,1,,ANY
101281,BLOCK,1,,<empty>,,,,1,,ANY
101286,BLOCK,1,,<empty>,,,,1,,ANY
101291,BLOCK,1,,<empty>,,,,1,,ANY
101296,BLOCK,1,,<empty>,,,,1,,ANY
101300,BLOCK,1,,<empty>,,,,1,,ANY
101303,BLOCK,1,,<empty>,,,,1,,ANY
101306,BLOCK,1,,<empty>,,,,1,,ANY
101312,BLOCK,1,,<empty>,,,,1,,ANY
101318,BLOCK,1,,<empty>,,,,1,,ANY
101324,BLOCK,1,,<empty>,,,,1,,ANY
101328,BLOCK,1,,<empty>,,,,1,,ANY
101334,BLOCK,1,,<empty>,,,,1,,ANY
101338,BLOCK,1,,<empty>,,,,1,,ANY
101342,BLOCK,1,,<empty>,,,,1,,ANY
101348,BLOCK,1,,<empty>,,,,1,,ANY
101352,BLOCK,1,,<empty>,,,,1,,ANY
101359,BLOCK,1,,<empty>,,,,1,,ANY
101362,BLOCK,1,,<empty>,,,,1,,ANY
101368,BLOCK,1,,<empty>,,,,1,,ANY
101372,BLOCK,1,,<empty>,,,,1,,ANY
101379,BLOCK,1,,<empty>,,,,1,,ANY
101382,BLOCK,1,,<empty>,,,,1,,ANY
101388,BLOCK,1,,<empty>,,,,1,,ANY
101394,BLOCK,1,,<empty>,,,,1,,ANY
101400,BLOCK,1,,<empty>,,,,1,,ANY
101406,BLOCK,1,,<empty>,,,,1,,ANY
101410,BLOCK,1,,<empty>,,,,1,,ANY
101417,BLOCK,1,,<empty>,,,,1,,ANY
101421,BLOCK,1,,<empty>,,,,1,,ANY
101424,BLOCK,1,,<empty>,,,,1,,ANY
101430,BLOCK,1,,<empty>,,,,1,,ANY
101434,BLOCK,1,,<empty>,,,,1,,ANY
101441,BLOCK,1,,<empty>,,,,1,,ANY
101444,BLOCK,1,,<empty>,,,,1,,ANY
101450,BLOCK,1,,<empty>,,,,1,,ANY
101456,BLOCK,1,,<empty>,,,,1,,ANY
101462,BLOCK,1,,<empty>,,,,1,,ANY
101466,BLOCK,1,,<empty>,,,,1,,ANY
101473,BLOCK,1,,<empty>,,,,1,,ANY
101476,BLOCK,1,,<empty>,,,,1,,ANY
101482,BLOCK,1,,<empty>,,,,1,,ANY
101485,BLOCK,1,,<empty>,,,,1,,ANY
101491,BLOCK,1,,<empty>,,,,1,,ANY
101495,BLOCK,1,,<empty>,,,,1,,ANY
101502,BLOCK,1,,<empty>,,,,1,,ANY
101505,BLOCK,1,,<empty>,,,,1,,ANY
101508,BLOCK,1,,<empty>,,,,1,,ANY
101511,BLOCK,1,,<empty>,,,,1,,ANY
101517,BLOCK,1,,<empty>,,,,1,,ANY
101520,BLOCK,1,,<empty>,,,,1,,ANY
101526,BLOCK,1,,<empty>,,,,1,,ANY
101530,BLOCK,1,,<empty>,,,,1,,ANY
101537,BLOCK,1,,<empty>,,,,1,,ANY
101540,BLOCK,1,,<empty>,,,,1,,ANY
101546,BLOCK,1,,<empty>,,,,1,,ANY
101549,BLOCK,1,,<empty>,,,,1,,ANY
101553,BLOCK,1,,<empty>,,,,1,,ANY
101560,BLOCK,1,,<empty>,,,,1,,ANY
101563,BLOCK,1,,<empty>,,,,1,,ANY
101566,BLOCK,1,,<empty>,,,,1,,ANY
101570,BLOCK,1,,<empty>,,,,1,,ANY
101577,BLOCK,1,,<empty>,,,,1,,ANY
101580,BLOCK,1,,<empty>,,,,1,,ANY
101583,BLOCK,1,,<empty>,,,,1,,ANY
101589,BLOCK,1,,<empty>,,,,1,,ANY
101595,BLOCK,1,,<empty>,,,,1,,ANY
101599,BLOCK,1,,<empty>,,,,1,,ANY
101606,BLOCK,1,,<empty>,,,,1,,ANY
101610,BLOCK,1,,<empty>,,,,1,,ANY
101614,BLOCK,1,,<empty>,,,,1,,ANY
101619,BLOCK,1,,<empty>,,,,1,,ANY
101623,BLOCK,1,,<empty>,,,,1,,ANY
101626,BLOCK,1,,<empty>,,,,1,,ANY
101632,BLOCK,1,,<empty>,,,,1,,ANY
101636,BLOCK,1,,<empty>,,,,1,,ANY
101643,BLOCK,1,,<empty>,,,,1,,ANY
101646,BLOCK,1,,<empty>,,,,1,,ANY
101649,BLOCK,1,,<empty>,,,,1,,ANY
101652,BLOCK,1,,<empty>,,,,1,,ANY
101658,BLOCK,1,,<empty>,,,,1,,ANY
101664,BLOCK,1,,<empty>,,,,1,,ANY
101668,BLOCK,1,,<empty>,,,,1,,ANY
101672,BLOCK,1,,<empty>,,,,1,,ANY
101679,BLOCK,1,,<empty>,,,,1,,ANY
101684,BLOCK,1,,<empty>,,,,1,,ANY
101689,BLOCK,1,,<empty>,,,,1,,ANY
101692,BLOCK,1,,<empty>,,,,1,,ANY
101695,BLOCK,1,,<empty>,,,,1,,ANY
101701,BLOCK,1,,<empty>,,,,1,,ANY
101707,BLOCK,1,,<empty>,,,,1,,ANY
101711,BLOCK,1,,<empty>,,,,1,,ANY
101718,BLOCK,1,,<empty>,,,,1,,ANY
101722,BLOCK,1,,<empty>,,,,1,,ANY
101725,BLOCK,1,,<empty>,,,,1,,ANY
101728,BLOCK,1,,<empty>,,,,1,,ANY
101731,BLOCK,1,,<empty>,,,,1,,ANY
101735,BLOCK,1,,<empty>,,,,1,,ANY
101742,BLOCK,1,,<empty>,,,,1,,ANY
101747,BLOCK,1,,<empty>,,,,1,,ANY
101750,BLOCK,1,,<empty>,,,,1,,ANY
101753,BLOCK,1,,<empty>,,,,1,,ANY
101759,BLOCK,1,,<empty>,,,,1,,ANY
101763,BLOCK,1,,<empty>,,,,1,,ANY
101770,BLOCK,1,,<empty>,,,,1,,ANY
101774,BLOCK,1,,<empty>,,,,1,,ANY
101777,BLOCK,1,,<empty>,,,,1,,ANY
101780,BLOCK,1,,<empty>,,,,1,,ANY
101783,BLOCK,1,,<empty>,,,,1,,ANY
101787,BLOCK,1,,<empty>,,,,1,,ANY
101794,BLOCK,1,,<empty>,,,,1,,ANY
101799,BLOCK,1,,<empty>,,,,1,,ANY
101802,BLOCK,1,,<empty>,,,,1,,ANY
101805,BLOCK,1,,<empty>,,,,1,,ANY
101811,BLOCK,1,,<empty>,,,,1,,ANY
101817,BLOCK,1,,<empty>,,,,1,,ANY
101821,BLOCK,1,,<empty>,,,,1,,ANY
101828,BLOCK,1,,<empty>,,,,1,,ANY
101833,BLOCK,1,,<empty>,,,,1,,ANY
101838,BLOCK,1,,<empty>,,,,1,,ANY
101841,BLOCK,1,,<empty>,,,,1,,ANY
101844,BLOCK,1,,<empty>,,,,1,,ANY
101850,BLOCK,1,,<empty>,,,,1,,ANY
101854,BLOCK,1,,<empty>,,,,1,,ANY
101861,BLOCK,1,,<empty>,,,,1,,ANY
101866,BLOCK,1,,<empty>,,,,1,,ANY
101871,BLOCK,1,,<empty>,,,,1,,ANY
101874,BLOCK,1,,<empty>,,,,1,,ANY
101877,BLOCK,1,,<empty>,,,,1,,ANY
101881,BLOCK,1,,<empty>,,,,1,,ANY
101888,BLOCK,1,,<empty>,,,,1,,ANY
101893,BLOCK,1,,<empty>,,,,1,,ANY
101898,BLOCK,1,,<empty>,,,,1,,ANY
101901,BLOCK,1,,<empty>,,,,1,,ANY
101904,BLOCK,1,,<empty>,,,,1,,ANY
101910,BLOCK,1,,<empty>,,,,1,,ANY
101914,BLOCK,1,,<empty>,,,,1,,ANY
101921,BLOCK,1,,<empty>,,,,1,,ANY
101926,BLOCK,1,,<empty>,,,,1,,ANY
101931,BLOCK,1,,<empty>,,,,1,,ANY
101934,BLOCK,1,,<empty>,,,,1,,ANY
101940,BLOCK,1,,<empty>,,,,1,,ANY
101943,BLOCK,1,,<empty>,,,,1,,ANY
101947,BLOCK,1,,<empty>,,,,1,,ANY
101954,BLOCK,1,,<empty>,,,,1,,ANY
101958,BLOCK,1,,<empty>,,,,1,,ANY
101961,BLOCK,1,,<empty>,,,,1,,ANY
101964,BLOCK,1,,<empty>,,,,1,,ANY
101967,BLOCK,1,,<empty>,,,,1,,ANY
101971,BLOCK,1,,<empty>,,,,1,,ANY
101978,BLOCK,1,,<empty>,,,,1,,ANY
101982,BLOCK,1,,<empty>,,,,1,,ANY
101985,BLOCK,1,,<empty>,,,,1,,ANY
101988,BLOCK,1,,<empty>,,,,1,,ANY
101991,BLOCK,1,,<empty>,,,,1,,ANY
101995,BLOCK,1,,<empty>,,,,1,,ANY
102002,BLOCK,1,,<empty>,,,,1,,ANY
102006,BLOCK,1,,<empty>,,,,1,,ANY
102009,BLOCK,1,,<empty>,,,,1,,ANY
102015,BLOCK,1,,<empty>,,,,1,,ANY
102018,BLOCK,1,,<empty>,,,,1,,ANY
102021,BLOCK,1,,<empty>,,,,1,,ANY
102025,BLOCK,1,,<empty>,,,,1,,ANY
102032,BLOCK,1,,<empty>,,,,1,,ANY
102037,BLOCK,1,,<empty>,,,,1,,ANY
102040,BLOCK,1,,<empty>,,,,1,,ANY
102043,BLOCK,1,,<empty>,,,,1,,ANY
102049,BLOCK,1,,<empty>,,,,1,,ANY
102055,BLOCK,1,,<empty>,,,,1,,ANY
102059,BLOCK,1,,<empty>,,,,1,,ANY
102066,BLOCK,1,,<empty>,,,,1,,ANY
102071,BLOCK,1,,<empty>,,,,1,,ANY
102075,BLOCK,1,,<empty>,,,,1,,ANY
102082,BLOCK,1,,<empty>,,,,1,,ANY
102086,BLOCK,1,,<empty>,,,,1,,ANY
102093,BLOCK,1,,<empty>,,,,1,,ANY
102097,BLOCK,1,,<empty>,,,,1,,ANY
102104,BLOCK,1,,<empty>,,,,1,,ANY
102108,BLOCK,1,,<empty>,,,,1,,ANY
102115,BLOCK,1,,<empty>,,,,1,,ANY
102119,BLOCK,1,,<empty>,,,,1,,ANY
102126,BLOCK,1,,<empty>,,,,1,,ANY
102130,BLOCK,1,,<empty>,,,,1,,ANY
102137,BLOCK,1,,<empty>,,,,1,,ANY
102141,BLOCK,1,,<empty>,,,,1,,ANY
102148,BLOCK,1,,<empty>,,,,1,,ANY
102152,BLOCK,1,,<empty>,,,,1,,ANY
102159,BLOCK,1,,<empty>,,,,1,,ANY
102163,BLOCK,1,,<empty>,,,,1,,ANY
102170,BLOCK,1,,<empty>,,,,1,,ANY
102174,BLOCK,1,,<empty>,,,,1,,ANY
102181,BLOCK,1,,<empty>,,,,1,,ANY
102185,BLOCK,1,,<empty>,,,,1,,ANY
102192,BLOCK,1,,<empty>,,,,1,,ANY
102196,BLOCK,1,,<empty>,,,,1,,ANY
102203,BLOCK,1,,<empty>,,,,1,,ANY
102207,BLOCK,1,,<empty>,,,,1,,ANY
102211,BLOCK,1,,<empty>,,,,1,,ANY
102218,BLOCK,1,,<empty>,,,,1,,ANY
102222,BLOCK,1,,<empty>,,,,1,,ANY
102228,BLOCK,1,,<empty>,,,,1,,ANY
102235,BLOCK,1,,<empty>,,,,1,,ANY
102241,BLOCK,1,,<empty>,,,,1,,ANY
102245,BLOCK,1,,<empty>,,,,1,,ANY
102250,BLOCK,1,,<empty>,,,,1,,ANY
102255,BLOCK,1,,<empty>,,,,1,,ANY
102259,BLOCK,1,,<empty>,,,,1,,ANY
102263,BLOCK,1,,<empty>,,,,1,,ANY
102268,BLOCK,1,,<empty>,,,,1,,ANY
102273,BLOCK,1,,<empty>,,,,1,,ANY
102277,BLOCK,1,,<empty>,,,,1,,ANY
102281,BLOCK,1,,<empty>,,,,1,,ANY
102284,BLOCK,1,,<empty>,,,,1,,ANY
102287,BLOCK,1,,<empty>,,,,1,,ANY
102291,BLOCK,1,,<empty>,,,,1,,ANY
102298,BLOCK,1,,<empty>,,,,1,,ANY
102301,BLOCK,1,,<empty>,,,,1,,ANY
102307,BLOCK,1,,<empty>,,,,1,,ANY
102313,BLOCK,1,,<empty>,,,,1,,ANY
102317,BLOCK,1,,<empty>,,,,1,,ANY
102322,BLOCK,1,,<empty>,,,,1,,ANY
102326,BLOCK,1,,<empty>,,,,1,,ANY
102332,BLOCK,1,,<empty>,,,,1,,ANY
102335,BLOCK,1,,<empty>,,,,1,,ANY
102341,BLOCK,1,,<empty>,,,,1,,ANY
102345,BLOCK,1,,<empty>,,,,1,,ANY
102350,BLOCK,1,,<empty>,,,,1,,ANY
102355,BLOCK,1,,<empty>,,,,1,,ANY
102361,BLOCK,1,,<empty>,,,,1,,ANY
102365,BLOCK,1,,<empty>,,,,1,,ANY
102369,BLOCK,1,,<empty>,,,,1,,ANY
102376,BLOCK,1,,<empty>,,,,1,,ANY
102379,BLOCK,1,,<empty>,,,,1,,ANY
102382,BLOCK,1,,<empty>,,,,1,,ANY
102385,BLOCK,1,,<empty>,,,,1,,ANY
102388,BLOCK,1,,<empty>,,,,1,,ANY
102394,BLOCK,1,,<empty>,,,,1,,ANY
102398,BLOCK,1,,<empty>,,,,1,,ANY
102405,BLOCK,1,,<empty>,,,,1,,ANY
102408,BLOCK,1,,<empty>,,,,1,,ANY
102411,BLOCK,1,,<empty>,,,,1,,ANY
102414,BLOCK,1,,<empty>,,,,1,,ANY
102418,BLOCK,1,,<empty>,,,,1,,ANY
102424,BLOCK,1,,<empty>,,,,1,,ANY
102427,BLOCK,1,,<empty>,,,,1,,ANY
102432,BLOCK,1,,<empty>,,,,1,,ANY
102437,BLOCK,1,,<empty>,,,,1,,ANY
102440,BLOCK,1,,<empty>,,,,1,,ANY
102445,BLOCK,1,,<empty>,,,,1,,ANY
102451,BLOCK,1,,<empty>,,,,1,,ANY
102457,BLOCK,1,,<empty>,,,,1,,ANY
102463,BLOCK,1,,<empty>,,,,1,,ANY
102467,BLOCK,1,,<empty>,,,,1,,ANY
102474,BLOCK,1,,<empty>,,,,1,,ANY
102477,BLOCK,1,,<empty>,,,,1,,ANY
102483,BLOCK,1,,<empty>,,,,1,,ANY
102486,BLOCK,1,,<empty>,,,,1,,ANY
102490,BLOCK,1,,<empty>,,,,1,,ANY
102497,BLOCK,1,,<empty>,,,,1,,ANY
102500,BLOCK,1,,<empty>,,,,1,,ANY
102503,BLOCK,1,,<empty>,,,,1,,ANY
102506,BLOCK,1,,<empty>,,,,1,,ANY
102509,BLOCK,1,,<empty>,,,,1,,ANY
102512,BLOCK,1,,<empty>,,,,1,,ANY
102516,BLOCK,1,,<empty>,,,,1,,ANY
102520,BLOCK,1,,<empty>,,,,1,,ANY
102526,BLOCK,1,,<empty>,,,,1,,ANY
102532,BLOCK,1,,<empty>,,,,1,,ANY
102535,BLOCK,1,,<empty>,,,,1,,ANY
102541,BLOCK,1,,<empty>,,,,1,,ANY
102545,BLOCK,1,,<empty>,,,,1,,ANY
102552,BLOCK,1,,<empty>,,,,1,,ANY
102555,BLOCK,1,,<empty>,,,,1,,ANY
102561,BLOCK,1,,<empty>,,,,1,,ANY
102564,BLOCK,1,,<empty>,,,,1,,ANY
102567,BLOCK,1,,<empty>,,,,1,,ANY
102570,BLOCK,1,,<empty>,,,,1,,ANY
102574,BLOCK,1,,<empty>,,,,1,,ANY
102580,BLOCK,1,,<empty>,,,,1,,ANY
102586,BLOCK,1,,<empty>,,,,1,,ANY
102592,BLOCK,1,,<empty>,,,,1,,ANY
102596,BLOCK,1,,<empty>,,,,1,,ANY
102603,BLOCK,1,,<empty>,,,,1,,ANY
102606,BLOCK,1,,<empty>,,,,1,,ANY
102609,BLOCK,1,,<empty>,,,,1,,ANY
102612,BLOCK,1,,<empty>,,,,1,,ANY
102619,BLOCK,1,,<empty>,,,,1,,ANY
102622,BLOCK,1,,<empty>,,,,1,,ANY
102625,BLOCK,1,,<empty>,,,,1,,ANY
102631,BLOCK,1,,<empty>,,,,1,,ANY
102637,BLOCK,1,,<empty>,,,,1,,ANY
102643,BLOCK,1,,<empty>,,,,1,,ANY
102649,BLOCK,1,,<empty>,,,,1,,ANY
102655,BLOCK,1,,<empty>,,,,1,,ANY
102658,BLOCK,1,,<empty>,,,,1,,ANY
102664,BLOCK,1,,<empty>,,,,1,,ANY
102667,BLOCK,1,,<empty>,,,,1,,ANY
102670,BLOCK,1,,<empty>,,,,1,,ANY
102673,BLOCK,1,,<empty>,,,,1,,ANY
102676,BLOCK,1,,<empty>,,,,1,,ANY
102680,BLOCK,1,,<empty>,,,,1,,ANY
102684,BLOCK,1,,<empty>,,,,1,,ANY
102688,BLOCK,1,,<empty>,,,,1,,ANY
102692,BLOCK,1,,<empty>,,,,1,,ANY
102697,BLOCK,1,,<empty>,,,,1,,ANY
102702,BLOCK,1,,<empty>,,,,1,,ANY
102707,BLOCK,1,,<empty>,,,,1,,ANY
102712,BLOCK,1,,<empty>,,,,1,,ANY
102717,BLOCK,1,,<empty>,,,,1,,ANY
102722,BLOCK,1,,<empty>,,,,1,,ANY
102727,BLOCK,1,,<empty>,,,,1,,ANY
102731,BLOCK,1,,<empty>,,,,1,,ANY
102736,BLOCK,1,,<empty>,,,,1,,ANY
102741,BLOCK,1,,<empty>,,,,1,,ANY
102746,BLOCK,1,,<empty>,,,,1,,ANY
102749,BLOCK,1,,<empty>,,,,1,,ANY
102754,BLOCK,1,,<empty>,,,,1,,ANY
102759,BLOCK,1,,<empty>,,,,1,,ANY
102763,BLOCK,1,,<empty>,,,,1,,ANY
102766,BLOCK,1,,<empty>,,,,1,,ANY
102771,BLOCK,1,,<empty>,,,,1,,ANY
102775,BLOCK,1,,<empty>,,,,1,,ANY
102781,BLOCK,1,,<empty>,,,,1,,ANY
102786,BLOCK,1,,<empty>,,,,1,,ANY
102789,BLOCK,1,,<empty>,,,,1,,ANY
102794,BLOCK,1,,<empty>,,,,1,,ANY
102800,BLOCK,1,,<empty>,,,,1,,ANY
102805,BLOCK,1,,<empty>,,,,1,,ANY
102811,BLOCK,1,,<empty>,,,,1,,ANY
102815,BLOCK,1,,<empty>,,,,1,,ANY
102822,BLOCK,1,,<empty>,,,,1,,ANY
102827,BLOCK,1,,<empty>,,,,1,,ANY
102832,BLOCK,1,,<empty>,,,,1,,ANY
102836,BLOCK,1,,<empty>,,,,1,,ANY
102840,BLOCK,1,,<empty>,,,,1,,ANY
102847,BLOCK,1,,<empty>,,,,1,,ANY
102850,BLOCK,1,,<empty>,,,,1,,ANY
102855,BLOCK,1,,<empty>,,,,1,,ANY
102860,BLOCK,1,,<empty>,,,,1,,ANY
102865,BLOCK,1,,<empty>,,,,1,,ANY
102869,BLOCK,1,,<empty>,,,,1,,ANY
102873,BLOCK,1,,<empty>,,,,1,,ANY
102877,BLOCK,1,,<empty>,,,,1,,ANY
102881,BLOCK,1,,<empty>,,,,1,,ANY
102885,BLOCK,1,,<empty>,,,,1,,ANY
102891,BLOCK,1,,<empty>,,,,1,,ANY
102896,BLOCK,1,,<empty>,,,,1,,ANY
102902,BLOCK,1,,<empty>,,,,1,,ANY
102908,BLOCK,1,,<empty>,,,,1,,ANY
102914,BLOCK,1,,<empty>,,,,1,,ANY
102920,BLOCK,1,,<empty>,,,,1,,ANY
102926,BLOCK,1,,<empty>,,,,1,,ANY
102931,BLOCK,1,,<empty>,,,,1,,ANY
102936,BLOCK,1,,<empty>,,,,1,,ANY
102940,BLOCK,1,,<empty>,,,,1,,ANY
102947,BLOCK,1,,<empty>,,,,1,,ANY
102952,BLOCK,1,,<empty>,,,,1,,ANY
102957,BLOCK,1,,<empty>,,,,1,,ANY
102962,BLOCK,1,,<empty>,,,,1,,ANY
102967,BLOCK,1,,<empty>,,,,1,,ANY
102972,BLOCK,1,,<empty>,,,,1,,ANY
102977,BLOCK,1,,<empty>,,,,1,,ANY
102981,BLOCK,1,,<empty>,,,,1,,ANY
102988,BLOCK,1,,<empty>,,,,1,,ANY
102992,BLOCK,1,,<empty>,,,,1,,ANY
102996,BLOCK,1,,<empty>,,,,1,,ANY
103003,BLOCK,1,,<empty>,,,,1,,ANY
103007,BLOCK,1,,<empty>,,,,1,,ANY
103014,BLOCK,1,,<empty>,,,,1,,ANY
103018,BLOCK,1,,<empty>,,,,1,,ANY
103025,BLOCK,1,,<empty>,,,,1,,ANY
103029,BLOCK,1,,<empty>,,,,1,,ANY
103036,BLOCK,1,,<empty>,,,,1,,ANY
103040,BLOCK,1,,<empty>,,,,1,,ANY
103045,BLOCK,1,,<empty>,,,,1,,ANY
103051,BLOCK,1,,<empty>,,,,1,,ANY
103055,BLOCK,1,,<empty>,,,,1,,ANY
103063,BLOCK,1,,<empty>,,,,1,,ANY
103068,BLOCK,1,,<empty>,,,,1,,ANY
103073,BLOCK,1,,<empty>,,,,1,,ANY
103078,BLOCK,1,,<empty>,,,,1,,ANY
103083,BLOCK,1,,<empty>,,,,1,,ANY
103086,BLOCK,1,,<empty>,,,,1,,ANY
103091,BLOCK,1,,<empty>,,,,1,,ANY
103096,BLOCK,1,,<empty>,,,,1,,ANY
103101,BLOCK,1,,<empty>,,,,1,,ANY
103107,BLOCK,1,,<empty>,,,,1,,ANY
103113,BLOCK,1,,<empty>,,,,1,,ANY
103117,BLOCK,1,,<empty>,,,,1,,ANY
103124,BLOCK,1,,<empty>,,,,1,,ANY
103128,BLOCK,1,,<empty>,,,,1,,ANY
103134,BLOCK,1,,<empty>,,,,1,,ANY
103138,BLOCK,1,,<empty>,,,,1,,ANY
103143,BLOCK,1,,<empty>,,,,1,,ANY
103149,BLOCK,1,,<empty>,,,,1,,ANY
103155,BLOCK,1,,<empty>,,,,1,,ANY
103161,BLOCK,1,,<empty>,,,,1,,ANY
103167,BLOCK,1,,<empty>,,,,1,,ANY
103173,BLOCK,1,,<empty>,,,,1,,ANY
103176,BLOCK,1,,<empty>,,,,1,,ANY
103183,BLOCK,1,,<empty>,,,,1,,ANY
103188,BLOCK,1,,<empty>,,,,1,,ANY
103193,BLOCK,1,,<empty>,,,,1,,ANY
103197,BLOCK,1,,<empty>,,,,1,,ANY
103204,BLOCK,1,,<empty>,,,,1,,ANY
103208,BLOCK,1,,<empty>,,,,1,,ANY
103216,BLOCK,1,,<empty>,,,,1,,ANY
103222,BLOCK,1,,<empty>,,,,1,,ANY
103229,BLOCK,1,,<empty>,,,,1,,ANY
103233,BLOCK,1,,<empty>,,,,1,,ANY
103237,BLOCK,1,,<empty>,,,,1,,ANY
103245,BLOCK,1,,<empty>,,,,1,,ANY
103251,BLOCK,1,,<empty>,,,,1,,ANY
103255,BLOCK,1,,<empty>,,,,1,,ANY
103260,BLOCK,1,,<empty>,,,,1,,ANY
103265,BLOCK,1,,<empty>,,,,1,,ANY
103270,BLOCK,1,,<empty>,,,,1,,ANY
103275,BLOCK,1,,<empty>,,,,1,,ANY
103279,BLOCK,1,,<empty>,,,,1,,ANY
103283,BLOCK,1,,<empty>,,,,1,,ANY
103287,BLOCK,1,,<empty>,,,,1,,ANY
103292,BLOCK,1,,<empty>,,,,1,,ANY
103297,BLOCK,1,,<empty>,,,,1,,ANY
103302,BLOCK,1,,<empty>,,,,1,,ANY
103310,BLOCK,1,,<empty>,,,,1,,ANY
103316,BLOCK,1,,<empty>,,,,1,,ANY
103320,BLOCK,1,,<empty>,,,,1,,ANY
103327,BLOCK,1,,<empty>,,,,1,,ANY
103331,BLOCK,1,,<empty>,,,,1,,ANY
103335,BLOCK,1,,<empty>,,,,1,,ANY
103341,BLOCK,1,,<empty>,,,,1,,ANY
103346,BLOCK,1,,<empty>,,,,1,,ANY
103350,BLOCK,1,,<empty>,,,,1,,ANY
103354,BLOCK,1,,<empty>,,,,1,,ANY
103361,BLOCK,1,,<empty>,,,,1,,ANY
103365,BLOCK,1,,<empty>,,,,1,,ANY
103371,BLOCK,1,,<empty>,,,,1,,ANY
103377,BLOCK,1,,<empty>,,,,1,,ANY
103382,BLOCK,1,,<empty>,,,,1,,ANY
103388,BLOCK,1,,<empty>,,,,1,,ANY
103393,BLOCK,1,,<empty>,,,,1,,ANY
103399,BLOCK,1,,<empty>,,,,1,,ANY
103405,BLOCK,1,,<empty>,,,,1,,ANY
103409,BLOCK,1,,<empty>,,,,1,,ANY
103416,BLOCK,1,,<empty>,,,,1,,ANY
103421,BLOCK,1,,<empty>,,,,1,,ANY
103425,BLOCK,1,,<empty>,,,,1,,ANY
103431,BLOCK,1,,<empty>,,,,1,,ANY
103437,BLOCK,1,,<empty>,,,,1,,ANY
103443,BLOCK,1,,<empty>,,,,1,,ANY
103449,BLOCK,1,,<empty>,,,,1,,ANY
103455,BLOCK,1,,<empty>,,,,1,,ANY
103461,BLOCK,1,,<empty>,,,,1,,ANY
103467,BLOCK,1,,<empty>,,,,1,,ANY
103472,BLOCK,1,,<empty>,,,,1,,ANY
103478,BLOCK,1,,<empty>,,,,1,,ANY
103484,BLOCK,1,,<empty>,,,,1,,ANY
103490,BLOCK,1,,<empty>,,,,1,,ANY
103496,BLOCK,1,,<empty>,,,,1,,ANY
103502,BLOCK,1,,<empty>,,,,1,,ANY
103508,BLOCK,1,,<empty>,,,,1,,ANY
103514,BLOCK,1,,<empty>,,,,1,,ANY
103520,BLOCK,1,,<empty>,,,,1,,ANY
103526,BLOCK,1,,<empty>,,,,1,,ANY
103532,BLOCK,1,,<empty>,,,,1,,ANY
103538,BLOCK,1,,<empty>,,,,1,,ANY
103544,BLOCK,1,,<empty>,,,,1,,ANY
103550,BLOCK,1,,<empty>,,,,1,,ANY
103556,BLOCK,1,,<empty>,,,,1,,ANY
103562,BLOCK,1,,<empty>,,,,1,,ANY
103568,BLOCK,1,,<empty>,,,,1,,ANY
103574,BLOCK,1,,<empty>,,,,1,,ANY
103578,BLOCK,1,,<empty>,,,,1,,ANY
103585,BLOCK,1,,<empty>,,,,1,,ANY
103590,BLOCK,1,,<empty>,,,,1,,ANY
103594,BLOCK,1,,<empty>,,,,1,,ANY
103600,BLOCK,1,,<empty>,,,,1,,ANY
103606,BLOCK,1,,<empty>,,,,1,,ANY
103612,BLOCK,1,,<empty>,,,,1,,ANY
103618,BLOCK,1,,<empty>,,,,1,,ANY
103624,BLOCK,1,,<empty>,,,,1,,ANY
103630,BLOCK,1,,<empty>,,,,1,,ANY
103636,BLOCK,1,,<empty>,,,,1,,ANY
103642,BLOCK,1,,<empty>,,,,1,,ANY
103648,BLOCK,1,,<empty>,,,,1,,ANY
103654,BLOCK,1,,<empty>,,,,1,,ANY
103660,BLOCK,1,,<empty>,,,,1,,ANY
103666,BLOCK,1,,<empty>,,,,1,,ANY
103672,BLOCK,1,,<empty>,,,,1,,ANY
103678,BLOCK,1,,<empty>,,,,1,,ANY
103684,BLOCK,1,,<empty>,,,,1,,ANY
103690,BLOCK,1,,<empty>,,,,1,,ANY
103696,BLOCK,1,,<empty>,,,,1,,ANY
103702,BLOCK,1,,<empty>,,,,1,,ANY
103707,BLOCK,1,,<empty>,,,,1,,ANY
103713,BLOCK,1,,<empty>,,,,1,,ANY
103719,BLOCK,1,,<empty>,,,,1,,ANY
103725,BLOCK,1,,<empty>,,,,1,,ANY
103731,BLOCK,1,,<empty>,,,,1,,ANY
103737,BLOCK,1,,<empty>,,,,1,,ANY
103743,BLOCK,1,,<empty>,,,,1,,ANY
103749,BLOCK,1,,<empty>,,,,1,,ANY
103755,BLOCK,1,,<empty>,,,,1,,ANY
103761,BLOCK,1,,<empty>,,,,1,,ANY
103767,BLOCK,1,,<empty>,,,,1,,ANY
103773,BLOCK,1,,<empty>,,,,1,,ANY
103777,BLOCK,1,,<empty>,,,,1,,ANY
103784,BLOCK,1,,<empty>,,,,1,,ANY
103789,BLOCK,1,,<empty>,,,,1,,ANY
103795,BLOCK,1,,<empty>,,,,1,,ANY
103801,BLOCK,1,,<empty>,,,,1,,ANY
103807,BLOCK,1,,<empty>,,,,1,,ANY
103813,BLOCK,1,,<empty>,,,,1,,ANY
103819,BLOCK,1,,<empty>,,,,1,,ANY
103825,BLOCK,1,,<empty>,,,,1,,ANY
103831,BLOCK,1,,<empty>,,,,1,,ANY
103837,BLOCK,1,,<empty>,,,,1,,ANY
103843,BLOCK,1,,<empty>,,,,1,,ANY
103849,BLOCK,1,,<empty>,,,,1,,ANY
103855,BLOCK,1,,<empty>,,,,1,,ANY
103861,BLOCK,1,,<empty>,,,,1,,ANY
103865,BLOCK,1,,<empty>,,,,1,,ANY
103872,BLOCK,1,,<empty>,,,,1,,ANY
103878,BLOCK,1,,<empty>,,,,1,,ANY
103883,BLOCK,1,,<empty>,,,,1,,ANY
103889,BLOCK,1,,<empty>,,,,1,,ANY
103895,BLOCK,1,,<empty>,,,,1,,ANY
103901,BLOCK,1,,<empty>,,,,1,,ANY
103907,BLOCK,1,,<empty>,,,,1,,ANY
103911,BLOCK,1,,<empty>,,,,1,,ANY
103918,BLOCK,1,,<empty>,,,,1,,ANY
103923,BLOCK,1,,<empty>,,,,1,,ANY
103928,BLOCK,1,,<empty>,,,,1,,ANY
103934,BLOCK,1,,<empty>,,,,1,,ANY
103940,BLOCK,1,,<empty>,,,,1,,ANY
103946,BLOCK,1,,<empty>,,,,1,,ANY
103950,BLOCK,1,,<empty>,,,,1,,ANY
103954,BLOCK,1,,<empty>,,,,1,,ANY
103958,BLOCK,1,,<empty>,,,,1,,ANY
103965,BLOCK,1,,<empty>,,,,1,,ANY
103969,BLOCK,1,,<empty>,,,,1,,ANY
103975,BLOCK,1,,<empty>,,,,1,,ANY
103980,BLOCK,1,,<empty>,,,,1,,ANY
103984,BLOCK,1,,<empty>,,,,1,,ANY
103991,BLOCK,1,,<empty>,,,,1,,ANY
103996,BLOCK,1,,<empty>,,,,1,,ANY
104001,BLOCK,1,,<empty>,,,,1,,ANY
104007,BLOCK,1,,<empty>,,,,1,,ANY
104011,BLOCK,1,,<empty>,,,,1,,ANY
104018,BLOCK,1,,<empty>,,,,1,,ANY
104024,BLOCK,1,,<empty>,,,,1,,ANY
104028,BLOCK,1,,<empty>,,,,1,,ANY
104035,BLOCK,1,,<empty>,,,,1,,ANY
104041,BLOCK,1,,<empty>,,,,1,,ANY
104047,BLOCK,1,,<empty>,,,,1,,ANY
104053,BLOCK,1,,<empty>,,,,1,,ANY
104059,BLOCK,1,,<empty>,,,,1,,ANY
104063,BLOCK,1,,<empty>,,,,1,,ANY
104071,BLOCK,1,,<empty>,,,,1,,ANY
104075,BLOCK,1,,<empty>,,,,1,,ANY
104079,BLOCK,1,,<empty>,,,,1,,ANY
104083,BLOCK,1,,<empty>,,,,1,,ANY
104086,BLOCK,1,,<empty>,,,,1,,ANY
104095,BLOCK,1,,<empty>,,,,1,,ANY
104098,BLOCK,1,,<empty>,,,,1,,ANY
104103,BLOCK,1,,<empty>,,,,1,,ANY
104107,BLOCK,1,,<empty>,,,,1,,ANY
104112,BLOCK,1,,<empty>,,,,1,,ANY
104116,BLOCK,1,,<empty>,,,,1,,ANY
104124,BLOCK,1,,<empty>,,,,1,,ANY
104132,BLOCK,1,,<empty>,,,,1,,ANY
104136,BLOCK,1,,<empty>,,,,1,,ANY
104140,BLOCK,1,,<empty>,,,,1,,ANY
104145,BLOCK,1,,<empty>,,,,1,,ANY
104153,BLOCK,1,,<empty>,,,,1,,ANY
104157,BLOCK,1,,<empty>,,,,1,,ANY
104160,BLOCK,1,,<empty>,,,,1,,ANY
104164,BLOCK,1,,<empty>,,,,1,,ANY
104169,BLOCK,1,,<empty>,,,,1,,ANY
104173,BLOCK,1,,<empty>,,,,1,,ANY
104177,BLOCK,1,,<empty>,,,,1,,ANY
104181,BLOCK,1,,<empty>,,,,1,,ANY
104185,BLOCK,1,,<empty>,,,,1,,ANY
104190,BLOCK,1,,<empty>,,,,1,,ANY
104195,BLOCK,1,,<empty>,,,,1,,ANY
104200,BLOCK,1,,<empty>,,,,1,,ANY
104205,BLOCK,1,,<empty>,,,,1,,ANY
104210,BLOCK,1,,<empty>,,,,1,,ANY
104215,BLOCK,1,,<empty>,,,,1,,ANY
104221,BLOCK,1,,<empty>,,,,1,,ANY
104227,BLOCK,1,,<empty>,,,,1,,ANY
104231,BLOCK,1,,<empty>,,,,1,,ANY
104235,BLOCK,1,,<empty>,,,,1,,ANY
104241,BLOCK,1,,<empty>,,,,1,,ANY
104245,BLOCK,1,,<empty>,,,,1,,ANY
104249,BLOCK,1,,<empty>,,,,1,,ANY
104253,BLOCK,1,,<empty>,,,,1,,ANY
104257,BLOCK,1,,<empty>,,,,1,,ANY
104261,BLOCK,1,,<empty>,,,,1,,ANY
104268,BLOCK,1,,<empty>,,,,1,,ANY
104273,BLOCK,1,,<empty>,,,,1,,ANY
104278,BLOCK,1,,<empty>,,,,1,,ANY
104284,BLOCK,1,,<empty>,,,,1,,ANY
104290,BLOCK,1,,<empty>,,,,1,,ANY
104294,BLOCK,1,,<empty>,,,,1,,ANY
104300,BLOCK,1,,<empty>,,,,1,,ANY
104306,BLOCK,1,,<empty>,,,,1,,ANY
104312,BLOCK,1,,<empty>,,,,1,,ANY
104317,BLOCK,1,,<empty>,,,,1,,ANY
104321,BLOCK,1,,<empty>,,,,1,,ANY
104327,BLOCK,1,,<empty>,,,,1,,ANY
104332,BLOCK,1,,<empty>,,,,1,,ANY
104338,BLOCK,1,,<empty>,,,,1,,ANY
104344,BLOCK,1,,<empty>,,,,1,,ANY
104349,BLOCK,1,,<empty>,,,,1,,ANY
104355,BLOCK,1,,<empty>,,,,1,,ANY
104361,BLOCK,1,,<empty>,,,,1,,ANY
104367,BLOCK,1,,<empty>,,,,1,,ANY
104372,BLOCK,1,,<empty>,,,,1,,ANY
104377,BLOCK,1,,<empty>,,,,1,,ANY
104383,BLOCK,1,,<empty>,,,,1,,ANY
104389,BLOCK,1,,<empty>,,,,1,,ANY
104395,BLOCK,1,,<empty>,,,,1,,ANY
104401,BLOCK,1,,<empty>,,,,1,,ANY
104407,BLOCK,1,,<empty>,,,,1,,ANY
104412,BLOCK,1,,<empty>,,,,1,,ANY
104417,BLOCK,1,,<empty>,,,,1,,ANY
104422,BLOCK,1,,<empty>,,,,1,,ANY
104427,BLOCK,1,,<empty>,,,,1,,ANY
104431,BLOCK,1,,<empty>,,,,1,,ANY
104438,BLOCK,1,,<empty>,,,,1,,ANY
104443,BLOCK,1,,<empty>,,,,1,,ANY
104448,BLOCK,1,,<empty>,,,,1,,ANY
104454,BLOCK,1,,<empty>,,,,1,,ANY
104461,BLOCK,1,,<empty>,,,,1,,ANY
104466,BLOCK,1,,<empty>,,,,1,,ANY
104472,BLOCK,1,,<empty>,,,,1,,ANY
104477,BLOCK,1,,<empty>,,,,1,,ANY
104484,BLOCK,1,,<empty>,,,,1,,ANY
104489,BLOCK,1,,<empty>,,,,1,,ANY
104495,BLOCK,1,,<empty>,,,,1,,ANY
104499,BLOCK,1,,<empty>,,,,1,,ANY
104505,BLOCK,1,,<empty>,,,,1,,ANY
104510,BLOCK,1,,<empty>,,,,1,,ANY
104516,BLOCK,1,,<empty>,,,,1,,ANY
104524,BLOCK,1,,<empty>,,,,1,,ANY
104532,BLOCK,1,,<empty>,,,,1,,ANY
104540,BLOCK,1,,<empty>,,,,1,,ANY
104545,BLOCK,1,,<empty>,,,,1,,ANY
104551,BLOCK,1,,<empty>,,,,1,,ANY
104559,BLOCK,1,,<empty>,,,,1,,ANY
104563,BLOCK,1,,<empty>,,,,1,,ANY
104570,BLOCK,1,,<empty>,,,,1,,ANY
104576,BLOCK,1,,<empty>,,,,1,,ANY
104581,BLOCK,1,,<empty>,,,,1,,ANY
104585,BLOCK,1,,<empty>,,,,1,,ANY
104592,BLOCK,1,,<empty>,,,,1,,ANY
104597,BLOCK,1,,<empty>,,,,1,,ANY
104601,BLOCK,1,,<empty>,,,,1,,ANY
104607,BLOCK,1,,<empty>,,,,1,,ANY
104611,BLOCK,1,,<empty>,,,,1,,ANY
104615,BLOCK,1,,<empty>,,,,1,,ANY
104619,BLOCK,1,,<empty>,,,,1,,ANY
104623,BLOCK,1,,<empty>,,,,1,,ANY
104630,BLOCK,1,,<empty>,,,,1,,ANY
104635,BLOCK,1,,<empty>,,,,1,,ANY
104640,BLOCK,1,,<empty>,,,,1,,ANY
104647,BLOCK,1,,<empty>,,,,1,,ANY
104652,BLOCK,1,,<empty>,,,,1,,ANY
104658,BLOCK,1,,<empty>,,,,1,,ANY
104665,BLOCK,1,,<empty>,,,,1,,ANY
104671,BLOCK,1,,<empty>,,,,1,,ANY
104675,BLOCK,1,,<empty>,,,,1,,ANY
104682,BLOCK,1,,<empty>,,,,1,,ANY
104689,BLOCK,1,,<empty>,,,,1,,ANY
104696,BLOCK,1,,<empty>,,,,1,,ANY
104703,BLOCK,1,,<empty>,,,,1,,ANY
104709,BLOCK,1,,<empty>,,,,1,,ANY
104713,BLOCK,1,,<empty>,,,,1,,ANY
104717,BLOCK,1,,<empty>,,,,1,,ANY
104721,BLOCK,1,,<empty>,,,,1,,ANY
104725,BLOCK,1,,<empty>,,,,1,,ANY
104731,BLOCK,1,,<empty>,,,,1,,ANY
104734,BLOCK,1,,<empty>,,,,1,,ANY
104738,BLOCK,1,,<empty>,,,,1,,ANY
104742,BLOCK,1,,<empty>,,,,1,,ANY
104746,BLOCK,1,,<empty>,,,,1,,ANY
104753,BLOCK,1,,<empty>,,,,1,,ANY
104760,BLOCK,1,,<empty>,,,,1,,ANY
104764,BLOCK,1,,<empty>,,,,1,,ANY
104768,BLOCK,1,,<empty>,,,,1,,ANY
104773,BLOCK,1,,<empty>,,,,1,,ANY
104778,BLOCK,1,,<empty>,,,,1,,ANY
104782,BLOCK,1,,<empty>,,,,1,,ANY
104788,BLOCK,1,,<empty>,,,,1,,ANY
104792,BLOCK,1,,<empty>,,,,1,,ANY
104799,BLOCK,1,,<empty>,,,,1,,ANY
104806,BLOCK,1,,<empty>,,,,1,,ANY
104813,BLOCK,1,,<empty>,,,,1,,ANY
104820,BLOCK,1,,<empty>,,,,1,,ANY
104827,BLOCK,1,,<empty>,,,,1,,ANY
104834,BLOCK,1,,<empty>,,,,1,,ANY
104841,BLOCK,1,,<empty>,,,,1,,ANY
104848,BLOCK,1,,<empty>,,,,1,,ANY
104852,BLOCK,1,,<empty>,,,,1,,ANY
104856,BLOCK,1,,<empty>,,,,1,,ANY
104860,BLOCK,1,,<empty>,,,,1,,ANY
104865,BLOCK,1,,<empty>,,,,1,,ANY
104870,BLOCK,1,,<empty>,,,,1,,ANY
104874,BLOCK,1,,<empty>,,,,1,,ANY
104878,BLOCK,1,,<empty>,,,,1,,ANY
104882,BLOCK,1,,<empty>,,,,1,,ANY
104887,BLOCK,1,,<empty>,,,,1,,ANY
104891,BLOCK,1,,<empty>,,,,1,,ANY
104896,BLOCK,1,,<empty>,,,,1,,ANY
104900,BLOCK,1,,<empty>,,,,1,,ANY
104904,BLOCK,1,,<empty>,,,,1,,ANY
104909,BLOCK,1,,<empty>,,,,1,,ANY
104912,BLOCK,1,,<empty>,,,,1,,ANY
104915,BLOCK,1,,<empty>,,,,1,,ANY
104919,BLOCK,1,,<empty>,,,,1,,ANY
104922,BLOCK,1,,<empty>,,,,1,,ANY
104925,BLOCK,1,,<empty>,,,,1,,ANY
104929,BLOCK,1,,<empty>,,,,1,,ANY
104932,BLOCK,1,,<empty>,,,,1,,ANY
104940,BLOCK,1,,<empty>,,,,1,,ANY
104943,BLOCK,1,,<empty>,,,,1,,ANY
104948,BLOCK,1,,<empty>,,,,1,,ANY
104953,BLOCK,1,,<empty>,,,,1,,ANY
104957,BLOCK,1,,<empty>,,,,1,,ANY
104960,BLOCK,1,,<empty>,,,,1,,ANY
104965,BLOCK,1,,<empty>,,,,1,,ANY
104969,BLOCK,1,,<empty>,,,,1,,ANY
104975,BLOCK,1,,<empty>,,,,1,,ANY
104978,BLOCK,1,,<empty>,,,,1,,ANY
104982,BLOCK,1,,<empty>,,,,1,,ANY
104989,BLOCK,1,,<empty>,,,,1,,ANY
104993,BLOCK,1,,<empty>,,,,1,,ANY
104999,BLOCK,1,,<empty>,,,,1,,ANY
105005,BLOCK,1,,<empty>,,,,1,,ANY
105011,BLOCK,1,,<empty>,,,,1,,ANY
105017,BLOCK,1,,<empty>,,,,1,,ANY
105023,BLOCK,1,,<empty>,,,,1,,ANY
105027,BLOCK,1,,<empty>,,,,1,,ANY
105034,BLOCK,1,,<empty>,,,,1,,ANY
105039,BLOCK,1,,<empty>,,,,1,,ANY
105044,BLOCK,1,,<empty>,,,,1,,ANY
105050,BLOCK,1,,<empty>,,,,1,,ANY
105056,BLOCK,1,,<empty>,,,,1,,ANY
105062,BLOCK,1,,<empty>,,,,1,,ANY
105068,BLOCK,1,,<empty>,,,,1,,ANY
105074,BLOCK,1,,<empty>,,,,1,,ANY
105080,BLOCK,1,,<empty>,,,,1,,ANY
105086,BLOCK,1,,<empty>,,,,1,,ANY
105092,BLOCK,1,,<empty>,,,,1,,ANY
105098,BLOCK,1,,<empty>,,,,1,,ANY
105104,BLOCK,1,,<empty>,,,,1,,ANY
105110,BLOCK,1,,<empty>,,,,1,,ANY
105116,BLOCK,1,,<empty>,,,,1,,ANY
105120,BLOCK,1,,<empty>,,,,1,,ANY
105127,BLOCK,1,,<empty>,,,,1,,ANY
105133,BLOCK,1,,<empty>,,,,1,,ANY
105139,BLOCK,1,,<empty>,,,,1,,ANY
105145,BLOCK,1,,<empty>,,,,1,,ANY
105151,BLOCK,1,,<empty>,,,,1,,ANY
105157,BLOCK,1,,<empty>,,,,1,,ANY
105163,BLOCK,1,,<empty>,,,,1,,ANY
105169,BLOCK,1,,<empty>,,,,1,,ANY
105175,BLOCK,1,,<empty>,,,,1,,ANY
105181,BLOCK,1,,<empty>,,,,1,,ANY
105187,BLOCK,1,,<empty>,,,,1,,ANY
105193,BLOCK,1,,<empty>,,,,1,,ANY
105199,BLOCK,1,,<empty>,,,,1,,ANY
105205,BLOCK,1,,<empty>,,,,1,,ANY
105211,BLOCK,1,,<empty>,,,,1,,ANY
105217,BLOCK,1,,<empty>,,,,1,,ANY
105223,BLOCK,1,,<empty>,,,,1,,ANY
105229,BLOCK,1,,<empty>,,,,1,,ANY
105235,BLOCK,1,,<empty>,,,,1,,ANY
105241,BLOCK,1,,<empty>,,,,1,,ANY
105247,BLOCK,1,,<empty>,,,,1,,ANY
105253,BLOCK,1,,<empty>,,,,1,,ANY
105259,BLOCK,1,,<empty>,,,,1,,ANY
105265,BLOCK,1,,<empty>,,,,1,,ANY
105271,BLOCK,1,,<empty>,,,,1,,ANY
105277,BLOCK,1,,<empty>,,,,1,,ANY
105283,BLOCK,1,,<empty>,,,,1,,ANY
105289,BLOCK,1,,<empty>,,,,1,,ANY
105295,BLOCK,1,,<empty>,,,,1,,ANY
105301,BLOCK,1,,<empty>,,,,1,,ANY
105307,BLOCK,1,,<empty>,,,,1,,ANY
105311,BLOCK,1,,<empty>,,,,1,,ANY
105315,BLOCK,1,,<empty>,,,,1,,ANY
105322,BLOCK,1,,<empty>,,,,1,,ANY
105328,BLOCK,1,,<empty>,,,,1,,ANY
105334,BLOCK,1,,<empty>,,,,1,,ANY
105338,BLOCK,1,,<empty>,,,,1,,ANY
105341,BLOCK,1,,<empty>,,,,1,,ANY
105344,BLOCK,1,,<empty>,,,,1,,ANY
105347,BLOCK,1,,<empty>,,,,1,,ANY
105350,BLOCK,1,,<empty>,,,,1,,ANY
105353,BLOCK,1,,<empty>,,,,1,,ANY
105358,BLOCK,1,,<empty>,,,,1,,ANY
105365,BLOCK,1,,<empty>,,,,1,,ANY
105369,BLOCK,1,,<empty>,,,,1,,ANY
105373,BLOCK,1,,<empty>,,,,1,,ANY
105377,BLOCK,1,,<empty>,,,,1,,ANY
105382,BLOCK,1,,<empty>,,,,1,,ANY
105386,BLOCK,1,,<empty>,,,,1,,ANY
105390,BLOCK,1,,<empty>,,,,1,,ANY
105395,BLOCK,1,,<empty>,,,,1,,ANY
105399,BLOCK,1,,<empty>,,,,1,,ANY
105406,BLOCK,1,,<empty>,,,,1,,ANY
105411,BLOCK,1,,<empty>,,,,1,,ANY
105414,BLOCK,1,,<empty>,,,,1,,ANY
105419,BLOCK,1,,<empty>,,,,1,,ANY
105423,BLOCK,1,,<empty>,,,,1,,ANY
105426,BLOCK,1,,<empty>,,,,1,,ANY
105431,BLOCK,1,,<empty>,,,,1,,ANY
105437,BLOCK,1,,<empty>,,,,1,,ANY
105442,BLOCK,1,,<empty>,,,,1,,ANY
105447,BLOCK,1,,<empty>,,,,1,,ANY
105451,BLOCK,1,,<empty>,,,,1,,ANY
105456,BLOCK,1,,<empty>,,,,1,,ANY
105462,BLOCK,1,,<empty>,,,,1,,ANY
105467,BLOCK,1,,<empty>,,,,1,,ANY
105472,BLOCK,1,,<empty>,,,,1,,ANY
105477,BLOCK,1,,<empty>,,,,1,,ANY
105481,BLOCK,1,,<empty>,,,,1,,ANY
105485,BLOCK,1,,<empty>,,,,1,,ANY
105489,BLOCK,1,,<empty>,,,,1,,ANY
105494,BLOCK,1,,<empty>,,,,1,,ANY
105498,BLOCK,1,,<empty>,,,,1,,ANY
105501,BLOCK,1,,<empty>,,,,1,,ANY
105507,BLOCK,1,,<empty>,,,,1,,ANY
105511,BLOCK,1,,<empty>,,,,1,,ANY
105515,BLOCK,1,,<empty>,,,,1,,ANY
105519,BLOCK,1,,<empty>,,,,1,,ANY
105523,BLOCK,1,,<empty>,,,,1,,ANY
105527,BLOCK,1,,<empty>,,,,1,,ANY
105531,BLOCK,1,,<empty>,,,,1,,ANY
105535,BLOCK,1,,<empty>,,,,1,,ANY
105541,BLOCK,1,,<empty>,,,,1,,ANY
105544,BLOCK,1,,<empty>,,,,1,,ANY
105550,BLOCK,1,,<empty>,,,,1,,ANY
105554,BLOCK,1,,<empty>,,,,1,,ANY
105560,BLOCK,1,,<empty>,,,,1,,ANY
105565,BLOCK,1,,<empty>,,,,1,,ANY
105570,BLOCK,1,,<empty>,,,,1,,ANY
105576,BLOCK,1,,<empty>,,,,1,,ANY
105580,BLOCK,1,,<empty>,,,,1,,ANY
105586,BLOCK,1,,<empty>,,,,1,,ANY
105591,BLOCK,1,,<empty>,,,,1,,ANY
105596,BLOCK,1,,<empty>,,,,1,,ANY
105600,BLOCK,1,,<empty>,,,,1,,ANY
105604,BLOCK,1,,<empty>,,,,1,,ANY
105611,BLOCK,1,,<empty>,,,,1,,ANY
105615,BLOCK,1,,<empty>,,,,1,,ANY
105619,BLOCK,1,,<empty>,,,,1,,ANY
105623,BLOCK,1,,<empty>,,,,1,,ANY
105630,BLOCK,1,,<empty>,,,,1,,ANY
105636,BLOCK,1,,<empty>,,,,1,,ANY
105640,BLOCK,1,,<empty>,,,,1,,ANY
105645,BLOCK,1,,<empty>,,,,1,,ANY
105649,BLOCK,1,,<empty>,,,,1,,ANY
105656,BLOCK,1,,<empty>,,,,1,,ANY
105660,BLOCK,1,,<empty>,,,,1,,ANY
105664,BLOCK,1,,<empty>,,,,1,,ANY
105668,BLOCK,1,,<empty>,,,,1,,ANY
105675,BLOCK,1,,<empty>,,,,1,,ANY
105679,BLOCK,1,,<empty>,,,,1,,ANY
105683,BLOCK,1,,<empty>,,,,1,,ANY
105687,BLOCK,1,,<empty>,,,,1,,ANY
105694,BLOCK,1,,<empty>,,,,1,,ANY
105698,BLOCK,1,,<empty>,,,,1,,ANY
105702,BLOCK,1,,<empty>,,,,1,,ANY
105706,BLOCK,1,,<empty>,,,,1,,ANY
105713,BLOCK,1,,<empty>,,,,1,,ANY
105717,BLOCK,1,,<empty>,,,,1,,ANY
105721,BLOCK,1,,<empty>,,,,1,,ANY
105725,BLOCK,1,,<empty>,,,,1,,ANY
105732,BLOCK,1,,<empty>,,,,1,,ANY
105736,BLOCK,1,,<empty>,,,,1,,ANY
105741,BLOCK,1,,<empty>,,,,1,,ANY
105745,BLOCK,1,,<empty>,,,,1,,ANY
105749,BLOCK,1,,<empty>,,,,1,,ANY
105756,BLOCK,1,,<empty>,,,,1,,ANY
105760,BLOCK,1,,<empty>,,,,1,,ANY
105764,BLOCK,1,,<empty>,,,,1,,ANY
105770,BLOCK,1,,<empty>,,,,1,,ANY
105773,BLOCK,1,,<empty>,,,,1,,ANY
105779,BLOCK,1,,<empty>,,,,1,,ANY
105783,BLOCK,1,,<empty>,,,,1,,ANY
105790,BLOCK,1,,<empty>,,,,1,,ANY
105796,BLOCK,1,,<empty>,,,,1,,ANY
105800,BLOCK,1,,<empty>,,,,1,,ANY
105807,BLOCK,1,,<empty>,,,,1,,ANY
105811,BLOCK,1,,<empty>,,,,1,,ANY
105817,BLOCK,1,,<empty>,,,,1,,ANY
105824,BLOCK,1,,<empty>,,,,1,,ANY
105830,BLOCK,1,,<empty>,,,,1,,ANY
105835,BLOCK,1,,<empty>,,,,1,,ANY
105841,BLOCK,1,,<empty>,,,,1,,ANY
105846,BLOCK,1,,<empty>,,,,1,,ANY
105852,BLOCK,1,,<empty>,,,,1,,ANY
105857,BLOCK,1,,<empty>,,,,1,,ANY
105863,BLOCK,1,,<empty>,,,,1,,ANY
105868,BLOCK,1,,<empty>,,,,1,,ANY
105874,BLOCK,1,,<empty>,,,,1,,ANY
105879,BLOCK,1,,<empty>,,,,1,,ANY
105885,BLOCK,1,,<empty>,,,,1,,ANY
105890,BLOCK,1,,<empty>,,,,1,,ANY
105896,BLOCK,1,,<empty>,,,,1,,ANY
105901,BLOCK,1,,<empty>,,,,1,,ANY
105907,BLOCK,1,,<empty>,,,,1,,ANY
105912,BLOCK,1,,<empty>,,,,1,,ANY
105918,BLOCK,1,,<empty>,,,,1,,ANY
105923,BLOCK,1,,<empty>,,,,1,,ANY
105929,BLOCK,1,,<empty>,,,,1,,ANY
105934,BLOCK,1,,<empty>,,,,1,,ANY
105940,BLOCK,1,,<empty>,,,,1,,ANY
105945,BLOCK,1,,<empty>,,,,1,,ANY
105949,BLOCK,1,,<empty>,,,,1,,ANY
105956,BLOCK,1,,<empty>,,,,1,,ANY
105959,BLOCK,1,,<empty>,,,,1,,ANY
105965,BLOCK,1,,<empty>,,,,1,,ANY
105970,BLOCK,1,,<empty>,,,,1,,ANY
105976,BLOCK,1,,<empty>,,,,1,,ANY
105981,BLOCK,1,,<empty>,,,,1,,ANY
105987,BLOCK,1,,<empty>,,,,1,,ANY
105992,BLOCK,1,,<empty>,,,,1,,ANY
105998,BLOCK,1,,<empty>,,,,1,,ANY
106003,BLOCK,1,,<empty>,,,,1,,ANY
106009,BLOCK,1,,<empty>,,,,1,,ANY
106014,BLOCK,1,,<empty>,,,,1,,ANY
106020,BLOCK,1,,<empty>,,,,1,,ANY
106025,BLOCK,1,,<empty>,,,,1,,ANY
106028,BLOCK,1,,<empty>,,,,1,,ANY
106031,BLOCK,1,,<empty>,,,,1,,ANY
106034,BLOCK,1,,<empty>,,,,1,,ANY
106037,BLOCK,1,,<empty>,,,,1,,ANY
106041,BLOCK,1,,<empty>,,,,1,,ANY
106046,BLOCK,1,,<empty>,,,,1,,ANY
106053,BLOCK,1,,<empty>,,,,1,,ANY
106057,BLOCK,1,,<empty>,,,,1,,ANY
106061,BLOCK,1,,<empty>,,,,1,,ANY
106065,BLOCK,1,,<empty>,,,,1,,ANY
106069,BLOCK,1,,<empty>,,,,1,,ANY
106072,BLOCK,1,,<empty>,,,,1,,ANY
106076,BLOCK,1,,<empty>,,,,1,,ANY
106083,BLOCK,1,,<empty>,,,,1,,ANY
106087,BLOCK,1,,<empty>,,,,1,,ANY
106094,BLOCK,1,,<empty>,,,,1,,ANY
106099,BLOCK,1,,<empty>,,,,1,,ANY
106104,BLOCK,1,,<empty>,,,,1,,ANY
106108,BLOCK,1,,<empty>,,,,1,,ANY
106114,BLOCK,1,,<empty>,,,,1,,ANY
106118,BLOCK,1,,<empty>,,,,1,,ANY
106124,BLOCK,1,,<empty>,,,,1,,ANY
106130,BLOCK,1,,<empty>,,,,1,,ANY
106134,BLOCK,1,,<empty>,,,,1,,ANY
106137,BLOCK,1,,<empty>,,,,1,,ANY
106140,BLOCK,1,,<empty>,,,,1,,ANY
106144,BLOCK,1,,<empty>,,,,1,,ANY
106148,BLOCK,1,,<empty>,,,,1,,ANY
106155,BLOCK,1,,<empty>,,,,1,,ANY
106159,BLOCK,1,,<empty>,,,,1,,ANY
106165,BLOCK,1,,<empty>,,,,1,,ANY
106171,BLOCK,1,,<empty>,,,,1,,ANY
106175,BLOCK,1,,<empty>,,,,1,,ANY
106182,BLOCK,1,,<empty>,,,,1,,ANY
106186,BLOCK,1,,<empty>,,,,1,,ANY
106190,BLOCK,1,,<empty>,,,,1,,ANY
106196,BLOCK,1,,<empty>,,,,1,,ANY
106202,BLOCK,1,,<empty>,,,,1,,ANY
106208,BLOCK,1,,<empty>,,,,1,,ANY
106214,BLOCK,1,,<empty>,,,,1,,ANY
106218,BLOCK,1,,<empty>,,,,1,,ANY
106225,BLOCK,1,,<empty>,,,,1,,ANY
106229,BLOCK,1,,<empty>,,,,1,,ANY
106232,BLOCK,1,,<empty>,,,,1,,ANY
106236,BLOCK,1,,<empty>,,,,1,,ANY
106239,BLOCK,1,,<empty>,,,,1,,ANY
106242,BLOCK,1,,<empty>,,,,1,,ANY
106248,BLOCK,1,,<empty>,,,,1,,ANY
106254,BLOCK,1,,<empty>,,,,1,,ANY
106258,BLOCK,1,,<empty>,,,,1,,ANY
106261,BLOCK,1,,<empty>,,,,1,,ANY
106267,BLOCK,1,,<empty>,,,,1,,ANY
106273,BLOCK,1,,<empty>,,,,1,,ANY
106276,BLOCK,1,,<empty>,,,,1,,ANY
106281,BLOCK,1,,<empty>,,,,1,,ANY
106285,BLOCK,1,,<empty>,,,,1,,ANY
106289,BLOCK,1,,<empty>,,,,1,,ANY
106294,BLOCK,1,,<empty>,,,,1,,ANY
106300,BLOCK,1,,<empty>,,,,1,,ANY
106304,BLOCK,1,,<empty>,,,,1,,ANY
106308,BLOCK,1,,<empty>,,,,1,,ANY
106313,BLOCK,1,,<empty>,,,,1,,ANY
106318,BLOCK,1,,<empty>,,,,1,,ANY
106322,BLOCK,1,,<empty>,,,,1,,ANY
106326,BLOCK,1,,<empty>,,,,1,,ANY
106330,BLOCK,1,,<empty>,,,,1,,ANY
106334,BLOCK,1,,<empty>,,,,1,,ANY
106338,BLOCK,1,,<empty>,,,,1,,ANY
106342,BLOCK,1,,<empty>,,,,1,,ANY
106346,BLOCK,1,,<empty>,,,,1,,ANY
106350,BLOCK,1,,<empty>,,,,1,,ANY
106354,BLOCK,1,,<empty>,,,,1,,ANY
106358,BLOCK,1,,<empty>,,,,1,,ANY
106362,BLOCK,1,,<empty>,,,,1,,ANY
106366,BLOCK,1,,<empty>,,,,1,,ANY
106373,BLOCK,1,,<empty>,,,,1,,ANY
106377,BLOCK,1,,<empty>,,,,1,,ANY
106383,BLOCK,1,,<empty>,,,,1,,ANY
106388,BLOCK,1,,<empty>,,,,1,,ANY
106394,BLOCK,1,,<empty>,,,,1,,ANY
106400,BLOCK,1,,<empty>,,,,1,,ANY
106406,BLOCK,1,,<empty>,,,,1,,ANY
106412,BLOCK,1,,<empty>,,,,1,,ANY
106418,BLOCK,1,,<empty>,,,,1,,ANY
106422,BLOCK,1,,<empty>,,,,1,,ANY
106428,BLOCK,1,,<empty>,,,,1,,ANY
106434,BLOCK,1,,<empty>,,,,1,,ANY
106438,BLOCK,1,,<empty>,,,,1,,ANY
106445,BLOCK,1,,<empty>,,,,1,,ANY
106449,BLOCK,1,,<empty>,,,,1,,ANY
106453,BLOCK,1,,<empty>,,,,1,,ANY
106458,BLOCK,1,,<empty>,,,,1,,ANY
106462,BLOCK,1,,<empty>,,,,1,,ANY
106468,BLOCK,1,,<empty>,,,,1,,ANY
106472,BLOCK,1,,<empty>,,,,1,,ANY
106479,BLOCK,1,,<empty>,,,,1,,ANY
106484,BLOCK,1,,<empty>,,,,1,,ANY
106489,BLOCK,1,,<empty>,,,,1,,ANY
106494,BLOCK,1,,<empty>,,,,1,,ANY
106498,BLOCK,1,,<empty>,,,,1,,ANY
106502,BLOCK,1,,<empty>,,,,1,,ANY
106506,BLOCK,1,,<empty>,,,,1,,ANY
106512,BLOCK,1,,<empty>,,,,1,,ANY
106518,BLOCK,1,,<empty>,,,,1,,ANY
106522,BLOCK,1,,<empty>,,,,1,,ANY
106529,BLOCK,1,,<empty>,,,,1,,ANY
106534,BLOCK,1,,<empty>,,,,1,,ANY
106540,BLOCK,1,,<empty>,,,,1,,ANY
106544,BLOCK,1,,<empty>,,,,1,,ANY
106550,BLOCK,1,,<empty>,,,,1,,ANY
106556,BLOCK,1,,<empty>,,,,1,,ANY
106560,BLOCK,1,,<empty>,,,,1,,ANY
106567,BLOCK,1,,<empty>,,,,1,,ANY
106572,BLOCK,1,,<empty>,,,,1,,ANY
106576,BLOCK,1,,<empty>,,,,1,,ANY
106580,BLOCK,1,,<empty>,,,,1,,ANY
106587,BLOCK,1,,<empty>,,,,1,,ANY
106593,BLOCK,1,,<empty>,,,,1,,ANY
106597,BLOCK,1,,<empty>,,,,1,,ANY
106603,BLOCK,1,,<empty>,,,,1,,ANY
106609,BLOCK,1,,<empty>,,,,1,,ANY
106613,BLOCK,1,,<empty>,,,,1,,ANY
106620,BLOCK,1,,<empty>,,,,1,,ANY
106626,BLOCK,1,,<empty>,,,,1,,ANY
106630,BLOCK,1,,<empty>,,,,1,,ANY
106637,BLOCK,1,,<empty>,,,,1,,ANY
106642,BLOCK,1,,<empty>,,,,1,,ANY
106648,BLOCK,1,,<empty>,,,,1,,ANY
106652,BLOCK,1,,<empty>,,,,1,,ANY
106658,BLOCK,1,,<empty>,,,,1,,ANY
106664,BLOCK,1,,<empty>,,,,1,,ANY
106669,BLOCK,1,,<empty>,,,,1,,ANY
106674,BLOCK,1,,<empty>,,,,1,,ANY
106680,BLOCK,1,,<empty>,,,,1,,ANY
106686,BLOCK,1,,<empty>,,,,1,,ANY
106690,BLOCK,1,,<empty>,,,,1,,ANY
106697,BLOCK,1,,<empty>,,,,1,,ANY
106703,BLOCK,1,,<empty>,,,,1,,ANY
106707,BLOCK,1,,<empty>,,,,1,,ANY
106714,BLOCK,1,,<empty>,,,,1,,ANY
106720,BLOCK,1,,<empty>,,,,1,,ANY
106726,BLOCK,1,,<empty>,,,,1,,ANY
106732,BLOCK,1,,<empty>,,,,1,,ANY
106736,BLOCK,1,,<empty>,,,,1,,ANY
106743,BLOCK,1,,<empty>,,,,1,,ANY
106747,BLOCK,1,,<empty>,,,,1,,ANY
106753,BLOCK,1,,<empty>,,,,1,,ANY
106759,BLOCK,1,,<empty>,,,,1,,ANY
106765,BLOCK,1,,<empty>,,,,1,,ANY
106771,BLOCK,1,,<empty>,,,,1,,ANY
106775,BLOCK,1,,<empty>,,,,1,,ANY
106781,BLOCK,1,,<empty>,,,,1,,ANY
106787,BLOCK,1,,<empty>,,,,1,,ANY
106793,BLOCK,1,,<empty>,,,,1,,ANY
106799,BLOCK,1,,<empty>,,,,1,,ANY
106803,BLOCK,1,,<empty>,,,,1,,ANY
106810,BLOCK,1,,<empty>,,,,1,,ANY
106816,BLOCK,1,,<empty>,,,,1,,ANY
106822,BLOCK,1,,<empty>,,,,1,,ANY
106828,BLOCK,1,,<empty>,,,,1,,ANY
106832,BLOCK,1,,<empty>,,,,1,,ANY
106836,BLOCK,1,,<empty>,,,,1,,ANY
106843,BLOCK,1,,<empty>,,,,1,,ANY
106849,BLOCK,1,,<empty>,,,,1,,ANY
106855,BLOCK,1,,<empty>,,,,1,,ANY
106861,BLOCK,1,,<empty>,,,,1,,ANY
106865,BLOCK,1,,<empty>,,,,1,,ANY
106872,BLOCK,1,,<empty>,,,,1,,ANY
106876,BLOCK,1,,<empty>,,,,1,,ANY
106880,BLOCK,1,,<empty>,,,,1,,ANY
106887,BLOCK,1,,<empty>,,,,1,,ANY
106891,BLOCK,1,,<empty>,,,,1,,ANY
106895,BLOCK,1,,<empty>,,,,1,,ANY
106901,BLOCK,1,,<empty>,,,,1,,ANY
106905,BLOCK,1,,<empty>,,,,1,,ANY
106912,BLOCK,1,,<empty>,,,,1,,ANY
106916,BLOCK,1,,<empty>,,,,1,,ANY
106920,BLOCK,1,,<empty>,,,,1,,ANY
106927,BLOCK,1,,<empty>,,,,1,,ANY
106931,BLOCK,1,,<empty>,,,,1,,ANY
106935,BLOCK,1,,<empty>,,,,1,,ANY
106939,BLOCK,1,,<empty>,,,,1,,ANY
106946,BLOCK,1,,<empty>,,,,1,,ANY
106952,BLOCK,1,,<empty>,,,,1,,ANY
106956,BLOCK,1,,<empty>,,,,1,,ANY
106962,BLOCK,1,,<empty>,,,,1,,ANY
106966,BLOCK,1,,<empty>,,,,1,,ANY
106972,BLOCK,1,,<empty>,,,,1,,ANY
106976,BLOCK,1,,<empty>,,,,1,,ANY
106982,BLOCK,1,,<empty>,,,,1,,ANY
106986,BLOCK,1,,<empty>,,,,1,,ANY
106992,BLOCK,1,,<empty>,,,,1,,ANY
106996,BLOCK,1,,<empty>,,,,1,,ANY
107002,BLOCK,1,,<empty>,,,,1,,ANY
107008,BLOCK,1,,<empty>,,,,1,,ANY
107015,BLOCK,1,,<empty>,,,,1,,ANY
107018,BLOCK,1,,<empty>,,,,1,,ANY
107023,BLOCK,1,,<empty>,,,,1,,ANY
107026,BLOCK,1,,<empty>,,,,1,,ANY
107029,BLOCK,1,,<empty>,,,,1,,ANY
107033,BLOCK,1,,<empty>,,,,1,,ANY
107039,BLOCK,1,,<empty>,,,,1,,ANY
107043,BLOCK,1,,<empty>,,,,1,,ANY
107050,BLOCK,1,,<empty>,,,,1,,ANY
107056,BLOCK,1,,<empty>,,,,1,,ANY
107062,BLOCK,1,,<empty>,,,,1,,ANY
107068,BLOCK,1,,<empty>,,,,1,,ANY
107074,BLOCK,1,,<empty>,,,,1,,ANY
107080,BLOCK,1,,<empty>,,,,1,,ANY
107084,BLOCK,1,,<empty>,,,,1,,ANY
107091,BLOCK,1,,<empty>,,,,1,,ANY
107097,BLOCK,1,,<empty>,,,,1,,ANY
107101,BLOCK,1,,<empty>,,,,1,,ANY
107108,BLOCK,1,,<empty>,,,,1,,ANY
107114,BLOCK,1,,<empty>,,,,1,,ANY
107118,BLOCK,1,,<empty>,,,,1,,ANY
107125,BLOCK,1,,<empty>,,,,1,,ANY
107129,BLOCK,1,,<empty>,,,,1,,ANY
107135,BLOCK,1,,<empty>,,,,1,,ANY
107141,BLOCK,1,,<empty>,,,,1,,ANY
107145,BLOCK,1,,<empty>,,,,1,,ANY
107151,BLOCK,1,,<empty>,,,,1,,ANY
107157,BLOCK,1,,<empty>,,,,1,,ANY
107162,BLOCK,1,,<empty>,,,,1,,ANY
107168,BLOCK,1,,<empty>,,,,1,,ANY
107172,BLOCK,1,,<empty>,,,,1,,ANY
107179,BLOCK,1,,<empty>,,,,1,,ANY
107185,BLOCK,1,,<empty>,,,,1,,ANY
107189,BLOCK,1,,<empty>,,,,1,,ANY
107192,BLOCK,1,,<empty>,,,,1,,ANY
107196,BLOCK,1,,<empty>,,,,1,,ANY
107203,BLOCK,1,,<empty>,,,,1,,ANY
107207,BLOCK,1,,<empty>,,,,1,,ANY
107212,BLOCK,1,,<empty>,,,,1,,ANY
107218,BLOCK,1,,<empty>,,,,1,,ANY
107222,BLOCK,1,,<empty>,,,,1,,ANY
107229,BLOCK,1,,<empty>,,,,1,,ANY
107234,BLOCK,1,,<empty>,,,,1,,ANY
107241,BLOCK,1,,<empty>,,,,1,,ANY
107245,BLOCK,1,,<empty>,,,,1,,ANY
107249,BLOCK,1,,<empty>,,,,1,,ANY
107252,BLOCK,1,,<empty>,,,,1,,ANY
107256,BLOCK,1,,<empty>,,,,1,,ANY
107260,BLOCK,1,,<empty>,,,,1,,ANY
107266,BLOCK,1,,<empty>,,,,1,,ANY
107271,BLOCK,1,,<empty>,,,,1,,ANY
107276,BLOCK,1,,<empty>,,,,1,,ANY
107285,BLOCK,1,,<empty>,,,,1,,ANY
107290,BLOCK,1,,<empty>,,,,1,,ANY
107294,BLOCK,1,,<empty>,,,,1,,ANY
107298,BLOCK,1,,<empty>,,,,1,,ANY
107302,BLOCK,1,,<empty>,,,,1,,ANY
107306,BLOCK,1,,<empty>,,,,1,,ANY
107311,BLOCK,1,,<empty>,,,,1,,ANY
107315,BLOCK,1,,<empty>,,,,1,,ANY
107320,BLOCK,1,,<empty>,,,,1,,ANY
107325,BLOCK,1,,<empty>,,,,1,,ANY
107329,BLOCK,1,,<empty>,,,,1,,ANY
107332,BLOCK,1,,<empty>,,,,1,,ANY
107337,BLOCK,1,,<empty>,,,,1,,ANY
107341,BLOCK,1,,<empty>,,,,1,,ANY
107345,BLOCK,1,,<empty>,,,,1,,ANY
107350,BLOCK,1,,<empty>,,,,1,,ANY
107354,BLOCK,1,,<empty>,,,,1,,ANY
107361,BLOCK,1,,<empty>,,,,1,,ANY
107364,BLOCK,1,,<empty>,,,,1,,ANY
107369,BLOCK,1,,<empty>,,,,1,,ANY
107374,BLOCK,1,,<empty>,,,,1,,ANY
107379,BLOCK,1,,<empty>,,,,1,,ANY
107384,BLOCK,1,,<empty>,,,,1,,ANY
107388,BLOCK,1,,<empty>,,,,1,,ANY
107395,BLOCK,1,,<empty>,,,,1,,ANY
107401,BLOCK,1,,<empty>,,,,1,,ANY
107406,BLOCK,1,,<empty>,,,,1,,ANY
107412,BLOCK,1,,<empty>,,,,1,,ANY
107420,BLOCK,1,,<empty>,,,,1,,ANY
107426,BLOCK,1,,<empty>,,,,1,,ANY
107431,BLOCK,1,,<empty>,,,,1,,ANY
107435,BLOCK,1,,<empty>,,,,1,,ANY
107442,BLOCK,1,,<empty>,,,,1,,ANY
107446,BLOCK,1,,<empty>,,,,1,,ANY
107450,BLOCK,1,,<empty>,,,,1,,ANY
107454,BLOCK,1,,<empty>,,,,1,,ANY
107461,BLOCK,1,,<empty>,,,,1,,ANY
107465,BLOCK,1,,<empty>,,,,1,,ANY
107470,BLOCK,1,,<empty>,,,,1,,ANY
107475,BLOCK,1,,<empty>,,,,1,,ANY
107480,BLOCK,1,,<empty>,,,,1,,ANY
107485,BLOCK,1,,<empty>,,,,1,,ANY
107491,BLOCK,1,,<empty>,,,,1,,ANY
107495,BLOCK,1,,<empty>,,,,1,,ANY
107502,BLOCK,1,,<empty>,,,,1,,ANY
107508,BLOCK,1,,<empty>,,,,1,,ANY
107511,BLOCK,1,,<empty>,,,,1,,ANY
107515,BLOCK,1,,<empty>,,,,1,,ANY
107522,BLOCK,1,,<empty>,,,,1,,ANY
107528,BLOCK,1,,<empty>,,,,1,,ANY
107534,BLOCK,1,,<empty>,,,,1,,ANY
107540,BLOCK,1,,<empty>,,,,1,,ANY
107546,BLOCK,1,,<empty>,,,,1,,ANY
107552,BLOCK,1,,<empty>,,,,1,,ANY
107558,BLOCK,1,,<empty>,,,,1,,ANY
107562,BLOCK,1,,<empty>,,,,1,,ANY
107566,BLOCK,1,,<empty>,,,,1,,ANY
107569,BLOCK,1,,<empty>,,,,1,,ANY
107572,BLOCK,1,,<empty>,,,,1,,ANY
107575,BLOCK,1,,<empty>,,,,1,,ANY
107579,BLOCK,1,,<empty>,,,,1,,ANY
107584,BLOCK,1,,<empty>,,,,1,,ANY
107589,BLOCK,1,,<empty>,,,,1,,ANY
107596,BLOCK,1,,<empty>,,,,1,,ANY
107600,BLOCK,1,,<empty>,,,,1,,ANY
107604,BLOCK,1,,<empty>,,,,1,,ANY
107608,BLOCK,1,,<empty>,,,,1,,ANY
107611,BLOCK,1,,<empty>,,,,1,,ANY
