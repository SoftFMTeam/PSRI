14,TYPE_DECL,,db\autocompact_test.cc:<global>,NAMESPACE_BLOCK,<global>,1,db\autocompact_test.cc,db\autocompact_test.cc:<global>,,false,1,<global>,6
18,TYPE_DECL,,,,"class AutoCompactTest {
 public:
  std::string dbname_;
  Cache* tiny_cache_;
  Options options_;
  DB* db_;

  AutoCompactTest() {
    dbname_ = test::TmpDir() + ""/autocompact_test"";
    tiny_cache_ = NewLRUCache(100);
    options_.block_cache = tiny_cache_;
    DestroyDB(dbname_, options_);
    options_.create_if_missing = true;
    options_.compression = kNoCompression;
    ASSERT_OK(DB::Open(options_, dbname_, &db_));
  }

  ~AutoCompactTest() {
    delete db_;
    DestroyDB(dbname_, Options());
    delete tiny_cache_;
  }

  std::string Key(int i) {
    char buf[100];
    snprintf(buf, sizeof(buf), ""key%06d"", i);
    return std::string(buf);
  }

  uint64_t Size(const Slice& start, const Slice& limit) {
    Range r(start, limit);
    uint64_t size;
    db_->GetApproximateSizes(&r, 1, &size);
    return size;
  }

  void DoReads(int n);
}",1,db\autocompact_test.cc,leveldb.AutoCompactTest,,false,13,AutoCompactTest,1
447,TYPE_DECL,,,,_Test_ReadAll,1,db\autocompact_test.cc,leveldb._Test_ReadAll,AutoCompactTest,false,106,_Test_ReadAll,9
482,TYPE_DECL,,,,_Test_ReadHalf,1,db\autocompact_test.cc,leveldb._Test_ReadHalf,AutoCompactTest,false,110,_Test_ReadHalf,13
550,TYPE_DECL,,db\builder.cc:<global>,NAMESPACE_BLOCK,<global>,1,db\builder.cc,db\builder.cc:<global>,,false,1,<global>,9
796,TYPE_DECL,,db\builder.hpp:<global>,NAMESPACE_BLOCK,<global>,1,db\builder.hpp,db\builder.hpp:<global>,,false,1,<global>,2
800,TYPE_DECL,,,,struct Options,1,db\builder.hpp,leveldb.Options,,false,12,Options,1
801,TYPE_DECL,,,,struct FileMetaData,1,db\builder.hpp,leveldb.FileMetaData,,false,13,FileMetaData,2
802,TYPE_DECL,,,,class Env,1,db\builder.hpp,leveldb.Env,,false,15,Env,3
803,TYPE_DECL,,,,class Iterator,1,db\builder.hpp,leveldb.Iterator,,false,16,Iterator,4
804,TYPE_DECL,,,,class TableCache,1,db\builder.hpp,leveldb.TableCache,,false,17,TableCache,5
805,TYPE_DECL,,,,class VersionEdit,1,db\builder.hpp,leveldb.VersionEdit,,false,18,VersionEdit,6
842,TYPE_DECL,,db\c.cc:<global>,NAMESPACE_BLOCK,<global>,1,db\c.cc,db\c.cc:<global>,,false,1,<global>,13
845,TYPE_DECL,,,,struct leveldb_t              { DB*               rep; },1,db\c.cc,leveldb_t,,false,46,leveldb_t,1
847,TYPE_DECL,,,,struct leveldb_iterator_t     { Iterator*         rep; },1,db\c.cc,leveldb_iterator_t,,false,47,leveldb_iterator_t,2
849,TYPE_DECL,,,,struct leveldb_writebatch_t   { WriteBatch        rep; },1,db\c.cc,leveldb_writebatch_t,,false,48,leveldb_writebatch_t,3
851,TYPE_DECL,,,,struct leveldb_snapshot_t     { const Snapshot*   rep; },1,db\c.cc,leveldb_snapshot_t,,false,49,leveldb_snapshot_t,4
853,TYPE_DECL,,,,struct leveldb_readoptions_t  { ReadOptions       rep; },1,db\c.cc,leveldb_readoptions_t,,false,50,leveldb_readoptions_t,5
855,TYPE_DECL,,,,struct leveldb_writeoptions_t { WriteOptions      rep; },1,db\c.cc,leveldb_writeoptions_t,,false,51,leveldb_writeoptions_t,6
857,TYPE_DECL,,,,struct leveldb_options_t      { Options           rep; },1,db\c.cc,leveldb_options_t,,false,52,leveldb_options_t,7
859,TYPE_DECL,,,,struct leveldb_cache_t        { Cache*            rep; },1,db\c.cc,leveldb_cache_t,,false,53,leveldb_cache_t,8
861,TYPE_DECL,,,,struct leveldb_seqfile_t      { SequentialFile*   rep; },1,db\c.cc,leveldb_seqfile_t,,false,54,leveldb_seqfile_t,9
863,TYPE_DECL,,,,struct leveldb_randomfile_t   { RandomAccessFile* rep; },1,db\c.cc,leveldb_randomfile_t,,false,55,leveldb_randomfile_t,10
865,TYPE_DECL,,,,struct leveldb_writablefile_t { WritableFile*     rep; },1,db\c.cc,leveldb_writablefile_t,,false,56,leveldb_writablefile_t,11
867,TYPE_DECL,,,,struct leveldb_logger_t       { Logger*           rep; },1,db\c.cc,leveldb_logger_t,,false,57,leveldb_logger_t,12
869,TYPE_DECL,,,,struct leveldb_filelock_t     { FileLock*         rep; },1,db\c.cc,leveldb_filelock_t,,false,58,leveldb_filelock_t,13
871,TYPE_DECL,,,,"struct leveldb_comparator_t : public Comparator {
  void* state_;
  void (*destructor_)(void*);
  int (*compare_)(
      void*,
      const char* a, size_t alen,
      const char* b, size_t blen);
  const char* (*name_)(void*);

  virtual ~leveldb_comparator_t() {
    (*destructor_)(state_);
  }

  virtual int Compare(const Slice& a, const Slice& b) const {
    return (*compare_)(state_, a.data(), a.size(), b.data(), b.size());
  }

  virtual const char* Name() const {
    return (*name_)(state_);
  }

  // No-ops since the C binding does not support key shortening methods.
  virtual void FindShortestSeparator(std::string*, const Slice&) const { }
  virtual void FindShortSuccessor(std::string* key) const { }
}",1,db\c.cc,leveldb_comparator_t,Comparator,false,60,leveldb_comparator_t,14
947,TYPE_DECL,,,,"struct leveldb_filterpolicy_t : public FilterPolicy {
  void* state_;
  void (*destructor_)(void*);
  const char* (*name_)(void*);
  char* (*create_)(
      void*,
      const char* const* key_array, const size_t* key_length_array,
      int num_keys,
      size_t* filter_length);
  unsigned char (*key_match_)(
      void*,
      const char* key, size_t length,
      const char* filter, size_t filter_length);

  virtual ~leveldb_filterpolicy_t() {
    (*destructor_)(state_);
  }

  virtual const char* Name() const {
    return (*name_)(state_);
  }

  virtual void CreateFilter(const Slice* keys, int n, std::string* dst) const {
    std::vector<const char*> key_pointers(n);
    std::vector<size_t> key_sizes(n);
    for (int i = 0; i < n; i++) {
      key_pointers[i] = keys[i].data();
      key_sizes[i] = keys[i].size();
    }
    size_t len;
    char* filter = (*create_)(state_, &key_pointers[0], &key_sizes[0], n, &len);
    dst->append(filter, len);
    free(filter);
  }

  virtual ...",1,db\c.cc,leveldb_filterpolicy_t,FilterPolicy,false,86,leveldb_filterpolicy_t,15
1098,TYPE_DECL,,,,"struct leveldb_env_t {
  Env* rep;
  bool is_default;
}",1,db\c.cc,leveldb_env_t,,false,127,leveldb_env_t,16
2362,TYPE_DECL,,db\c_test.c:<global>,NAMESPACE_BLOCK,<global>,1,db\c_test.c,db\c_test.c:<global>,,false,1,<global>,8
3861,TYPE_DECL,,db\corruption_test.cc:<global>,NAMESPACE_BLOCK,<global>,1,db\corruption_test.cc,db\corruption_test.cc:<global>,,false,1,<global>,17
3869,TYPE_DECL,,,,"class CorruptionTest {
 public:
  test::ErrorEnv env_;
  std::string dbname_;
  Cache* tiny_cache_;
  Options options_;
  DB* db_;

  CorruptionTest() {
    tiny_cache_ = NewLRUCache(100);
    options_.env = &env_;
    options_.block_cache = tiny_cache_;
    dbname_ = test::TmpDir() + ""/corruption_test"";
    DestroyDB(dbname_, options_);

    db_ = NULL;
    options_.create_if_missing = true;
    Reopen();
    options_.create_if_missing = false;
  }

  ~CorruptionTest() {
     delete db_;
     DestroyDB(dbname_, Options());
     delete tiny_cache_;
  }

  Status TryReopen() {
    delete db_;
    db_ = NULL;
    return DB::Open(options_, dbname_, &db_);
  }

  void Reopen() {
    ASSERT_OK(TryReopen());
  }

  void RepairDB() {
    delete db_;
    db_ = NULL;
    ASSERT_OK(::leveldb::RepairDB(dbname_, options_));
  }

  void Build(int n) {
    std::string key_space, value_space;
    WriteBatch batch;
    for (int i = 0; i < n; i++) {
      //if ((i % 100) == 0) fprintf(stderr, ""@ %d ...",1,db\corruption_test.cc,leveldb.CorruptionTest,,false,27,CorruptionTest,3
4607,TYPE_DECL,,,,_Test_Recovery,1,db\corruption_test.cc,leveldb._Test_Recovery,CorruptionTest,false,202,_Test_Recovery,4
4661,TYPE_DECL,,,,_Test_RecoverWriteError,1,db\corruption_test.cc,leveldb._Test_RecoverWriteError,CorruptionTest,false,213,_Test_RecoverWriteError,8
4727,TYPE_DECL,,,,_Test_NewFileErrorDuringWrite,1,db\corruption_test.cc,leveldb._Test_NewFileErrorDuringWrite,CorruptionTest,false,219,_Test_NewFileErrorDuringWrite,12
4864,TYPE_DECL,,,,_Test_TableFile,1,db\corruption_test.cc,leveldb._Test_TableFile,CorruptionTest,false,236,_Test_TableFile,16
4930,TYPE_DECL,,,,_Test_TableFileRepair,1,db\corruption_test.cc,leveldb._Test_TableFileRepair,CorruptionTest,false,247,_Test_TableFileRepair,20
5011,TYPE_DECL,,,,_Test_TableFileIndexData,1,db\corruption_test.cc,leveldb._Test_TableFileIndexData,CorruptionTest,false,263,_Test_TableFileIndexData,24
5065,TYPE_DECL,,,,_Test_MissingDescriptor,1,db\corruption_test.cc,leveldb._Test_MissingDescriptor,CorruptionTest,false,273,_Test_MissingDescriptor,28
5105,TYPE_DECL,,,,_Test_SequenceNumberRecovery,1,db\corruption_test.cc,leveldb._Test_SequenceNumberRecovery,CorruptionTest,false,280,_Test_SequenceNumberRecovery,32
5376,TYPE_DECL,,,,_Test_CorruptedDescriptor,1,db\corruption_test.cc,leveldb._Test_CorruptedDescriptor,CorruptionTest,false,301,_Test_CorruptedDescriptor,36
5519,TYPE_DECL,,,,_Test_CompactionInputError,1,db\corruption_test.cc,leveldb._Test_CompactionInputError,CorruptionTest,false,318,_Test_CompactionInputError,40
5602,TYPE_DECL,,,,_Test_CompactionInputErrorParanoid,1,db\corruption_test.cc,leveldb._Test_CompactionInputErrorParanoid,CorruptionTest,false,333,_Test_CompactionInputErrorParanoid,44
5731,TYPE_DECL,,,,_Test_UnrelatedKeys,1,db\corruption_test.cc,leveldb._Test_UnrelatedKeys,CorruptionTest,false,354,_Test_UnrelatedKeys,48
5950,TYPE_DECL,,db\db_bench.cc:<global>,NAMESPACE_BLOCK,<global>,1,db\db_bench.cc,db\db_bench.cc:<global>,,false,1,<global>,16
6026,TYPE_DECL,,,,"class RandomGenerator {
 private:
  std::string data_;
  int pos_;

 public:
  RandomGenerator() {
    // We use a limited amount of data over and over again and ensure
    // that it is larger than the compression window (32KB), and also
    // large enough to serve all typical value sizes we want to write.
    Random rnd(301);
    std::string piece;
    while (data_.size() < 1048576) {
      // Add a short fragment that is as compressible as specified
      // by FLAGS_compression_ratio.
      test::CompressibleString(&rnd, FLAGS_compression_ratio, 100, &piece);
      data_.append(piece);
    }
    pos_ = 0;
  }

  Slice Generate(size_t len) {
    if (pos_ + len > data_.size()) {
      pos_ = 0;
      assert(len < data_.size());
    }
    pos_ += len;
    return Slice(data_.data() + pos_ - len, len);
  }
}",1,db\db_bench.cc,leveldb.anonymous_namespace_1.RandomGenerator,,false,123,RandomGenerator,3
6139,TYPE_DECL,,,,"class Stats {
 private:
  double start_;
  double finish_;
  double seconds_;
  int done_;
  int next_report_;
  int64_t bytes_;
  double last_op_finish_;
  Histogram hist_;
  std::string message_;

 public:
  Stats() { Start(); }

  void Start() {
    next_report_ = 100;
    last_op_finish_ = start_;
    hist_.Clear();
    done_ = 0;
    bytes_ = 0;
    seconds_ = 0;
    start_ = g_env->NowMicros();
    finish_ = start_;
    message_.clear();
  }

  void Merge(const Stats& other) {
    hist_.Merge(other.hist_);
    done_ += other.done_;
    bytes_ += other.bytes_;
    seconds_ += other.seconds_;
    if (other.start_ < start_) start_ = other.start_;
    if (other.finish_ > finish_) finish_ = other.finish_;

    // Just keep the messages from one thread
    if (message_.empty()) message_ = other.message_;
  }

  void Stop() {
    finish_ = g_env->NowMicros();
    seconds_ = (finish_ - start_) * 1e-6;
  }

  void AddMessage(Slice msg) {
    AppendWithSpace(&message_, msg);
  }

  void...",1,db\db_bench.cc,leveldb.anonymous_namespace_5.Stats,,false,176,Stats,5
6486,TYPE_DECL,,,,"struct SharedState {
  port::Mutex mu;
  port::CondVar cv;
  int total;

  // Each thread goes through the following states:
  //    (1) initializing
  //    (2) waiting for others to be initialized
  //    (3) running
  //    (4) done

  int num_initialized;
  int num_done;
  bool start;

  SharedState() : cv(&mu) { }
}",1,db\db_bench.cc,leveldb.anonymous_namespace_17.SharedState,,false,284,SharedState,6
6497,TYPE_DECL,,,,"struct ThreadState {
  int tid;             // 0..n-1 when running in n threads
  Random rand;         // Has different seeds for different threads
  Stats stats;
  SharedState* shared;

  ThreadState(int index)
      : tid(index),
        rand(1000 + index) {
  }
}",1,db\db_bench.cc,leveldb.anonymous_namespace_19.ThreadState,,false,303,ThreadState,7
6507,TYPE_DECL,,,,"class Benchmark {
 private:
  Cache* cache_;
  const FilterPolicy* filter_policy_;
  DB* db_;
  int num_;
  int value_size_;
  int entries_per_batch_;
  WriteOptions write_options_;
  int reads_;
  int heap_counter_;

  void PrintHeader() {
    const int kKeySize = 16;
    PrintEnvironment();
    fprintf(stdout, ""Keys:       %d bytes each\n"", kKeySize);
    fprintf(stdout, ""Values:     %d bytes each (%d bytes after compression)\n"",
            FLAGS_value_size,
            static_cast<int>(FLAGS_value_size * FLAGS_compression_ratio + 0.5));
    fprintf(stdout, ""Entries:    %d\n"", num_);
    fprintf(stdout, ""RawSize:    %.1f MB (estimated)\n"",
            ((static_cast<int64_t>(kKeySize + FLAGS_value_size) * num_)
             / 1048576.0));
    fprintf(stdout, ""FileSize:   %.1f MB (estimated)\n"",
            (((kKeySize + FLAGS_value_size * FLAGS_compression_ratio) * num_)
             / 1048576.0));
    PrintWarnings();
    fprintf(stdout, ""-----------------------------------------...",1,db\db_bench.cc,leveldb.Benchmark,,false,317,Benchmark,2
7224,TYPE_DECL,,,,"struct ThreadArg {
    Benchmark* bm;
    SharedState* shared;
    ThreadState* thread;
    void (Benchmark::*method)(ThreadState*);
  }",3,db\db_bench.cc,leveldb.Benchmark.ThreadArg,,false,551,ThreadArg,16
9400,TYPE_DECL,,db\db_impl.cc:<global>,NAMESPACE_BLOCK,<global>,1,db\db_impl.cc,db\db_impl.cc:<global>,,false,1,<global>,30
9408,TYPE_DECL,,,,"struct DBImpl::Writer {
  Status status;
  WriteBatch* batch;
  bool sync;
  bool done;
  port::CondVar cv;

  explicit Writer(port::Mutex* mu) : cv(mu) { }
}",1,db\db_impl.cc,leveldb.Writer,,false,41,Writer,3
9419,TYPE_DECL,,,,"struct DBImpl::CompactionState {
  Compaction* const compaction;

  // Sequence numbers < smallest_snapshot are not significant since we
  // will never have to service a snapshot below smallest_snapshot.
  // Therefore if we have seen a sequence number S <= smallest_snapshot,
  // we can drop all entries for the same key with sequence numbers < S.
  SequenceNumber smallest_snapshot;

  // Files produced by compaction
  struct Output {
    uint64_t number;
    uint64_t file_size;
    InternalKey smallest, largest;
  };
  std::vector<Output> outputs;

  // State kept for output being generated
  WritableFile* outfile;
  TableBuilder* builder;

  uint64_t total_bytes;

  Output* current_output() { return &outputs[outputs.size()-1]; }

  explicit CompactionState(Compaction* c)
      : compaction(c),
        outfile(NULL),
        builder(NULL),
        total_bytes(0) {
  }
}",1,db\db_impl.cc,leveldb.CompactionState,,false,51,CompactionState,4
9422,TYPE_DECL,,,,"struct Output {
    uint64_t number;
    uint64_t file_size;
    InternalKey smallest, largest;
  }",3,db\db_impl.cc,leveldb.CompactionState.Output,,false,61,Output,3
12876,TYPE_DECL,,,,"struct IterState {
  port::Mutex* mu;
  Version* version;
  MemTable* mem;
  MemTable* imm;
}",1,db\db_impl.cc,leveldb.anonymous_namespace_1.IterState,,false,1049,IterState,1
14736,TYPE_DECL,,db\db_impl.hpp:<global>,NAMESPACE_BLOCK,<global>,1,db\db_impl.hpp,db\db_impl.hpp:<global>,,false,1,<global>,10
14740,TYPE_DECL,,,,class MemTable,1,db\db_impl.hpp,leveldb.MemTable,,false,20,MemTable,1
14741,TYPE_DECL,,,,class TableCache,1,db\db_impl.hpp,leveldb.TableCache,,false,21,TableCache,2
14742,TYPE_DECL,,,,class Version,1,db\db_impl.hpp,leveldb.Version,,false,22,Version,3
14743,TYPE_DECL,,,,class VersionEdit,1,db\db_impl.hpp,leveldb.VersionEdit,,false,23,VersionEdit,4
14744,TYPE_DECL,,,,class VersionSet,1,db\db_impl.hpp,leveldb.VersionSet,,false,24,VersionSet,5
14745,TYPE_DECL,,,,"class DBImpl : public DB {
 public:
  DBImpl(const Options& options, const std::string& dbname);
  virtual ~DBImpl();

  // Implementations of the DB interface
  virtual Status Put(const WriteOptions&, const Slice& key, const Slice& value);
  virtual Status Delete(const WriteOptions&, const Slice& key);
  virtual Status Write(const WriteOptions& options, WriteBatch* updates);
  virtual Status Get(const ReadOptions& options,
                     const Slice& key,
                     std::string* value);
  virtual Iterator* NewIterator(const ReadOptions&);
  virtual const Snapshot* GetSnapshot();
  virtual void ReleaseSnapshot(const Snapshot* snapshot);
  virtual bool GetProperty(const Slice& property, std::string* value);
  virtual void GetApproximateSizes(const Range* range, int n, uint64_t* sizes);
  virtual void CompactRange(const Slice* begin, const Slice* end);

  // Extra methods (for testing) that are not in the public DB interface

  // Compact any files in the named level t...",1,db\db_impl.hpp,leveldb.DBImpl,DB,false,26,DBImpl,6
14839,TYPE_DECL,,,,friend class DB,3,db\db_impl.hpp,leveldb.DBImpl.DB,,false,68,DB,18
14840,TYPE_DECL,,,,struct CompactionState,3,db\db_impl.hpp,leveldb.DBImpl.CompactionState,,false,69,CompactionState,19
14841,TYPE_DECL,,,,struct Writer,3,db\db_impl.hpp,leveldb.DBImpl.Writer,,false,70,Writer,20
14970,TYPE_DECL,,,,"struct ManualCompaction {
    int level;
    bool done;
    const InternalKey* begin;   // NULL means beginning of key range
    const InternalKey* end;     // NULL means end of key range
    InternalKey tmp_storage;    // Used to keep track of compaction progress
  }",3,db\db_impl.hpp,leveldb.DBImpl.ManualCompaction,,false,162,ManualCompaction,65
14979,TYPE_DECL,,,,"struct CompactionStats {
    int64_t micros;
    int64_t bytes_read;
    int64_t bytes_written;

    CompactionStats() : micros(0), bytes_read(0), bytes_written(0) { }

    void Add(const CompactionStats& c) {
      this->micros += c.micros;
      this->bytes_read += c.bytes_read;
      this->bytes_written += c.bytes_written;
    }
  }",3,db\db_impl.hpp,leveldb.DBImpl.CompactionStats,,false,178,CompactionStats,69
15071,TYPE_DECL,,db\db_iter.cc:<global>,NAMESPACE_BLOCK,<global>,1,db\db_iter.cc,db\db_iter.cc:<global>,,false,1,<global>,11
15076,TYPE_DECL,,,,"class DBIter: public Iterator {
 public:
  // Which direction is the iterator currently moving?
  // (1) When moving forward, the internal iterator is positioned at
  //     the exact entry that yields this->key(), this->value()
  // (2) When moving backwards, the internal iterator is positioned
  //     just before all entries whose user key == this->key().
  enum Direction {
    kForward,
    kReverse
  };

  DBIter(DBImpl* db, const Comparator* cmp, Iterator* iter, SequenceNumber s,
         uint32_t seed)
      : db_(db),
        user_comparator_(cmp),
        iter_(iter),
        sequence_(s),
        direction_(kForward),
        valid_(false),
        rnd_(seed),
        bytes_counter_(RandomPeriod()) {
  }
  virtual ~DBIter() {
    delete iter_;
  }
  virtual bool Valid() const { return valid_; }
  virtual Slice key() const {
    assert(valid_);
    return (direction_ == kForward) ? ExtractUserKey(iter_->key()) : saved_key_;
  }
  virtual Slice value() const {
    assert(val...",1,db\db_iter.cc,leveldb.anonymous_namespace_1.DBIter,Iterator,false,39,DBIter,1
15077,TYPE_DECL,,,,"enum Direction {
    kForward,
    kReverse
  }",3,db\db_iter.cc,leveldb.anonymous_namespace_2.DBIter.Direction,,false,46,Direction,1
15784,TYPE_DECL,,db\db_iter.hpp:<global>,NAMESPACE_BLOCK,<global>,1,db\db_iter.hpp,db\db_iter.hpp:<global>,,false,1,<global>,4
15788,TYPE_DECL,,,,class DBImpl,1,db\db_iter.hpp,leveldb.DBImpl,,false,14,DBImpl,1
15828,TYPE_DECL,,db\db_test.cc:<global>,NAMESPACE_BLOCK,<global>,1,db\db_test.cc,db\db_test.cc:<global>,,false,1,<global>,15
15850,TYPE_DECL,,,,"class AtomicCounter {
 private:
  port::Mutex mu_;
  int count_;
 public:
  AtomicCounter() : count_(0) { }
  void Increment() {
    IncrementBy(1);
  }
  void IncrementBy(int count) {
    MutexLock l(&mu_);
    count_ += count;
  }
  int Read() {
    MutexLock l(&mu_);
    return count_;
  }
  void Reset() {
    MutexLock l(&mu_);
    count_ = 0;
  }
}",1,db\db_test.cc,leveldb.anonymous_namespace_1.AtomicCounter,,false,29,AtomicCounter,1
15911,TYPE_DECL,,,,"class SpecialEnv : public EnvWrapper {
 public:
  // sstable/log Sync() calls are blocked while this pointer is non-NULL.
  port::AtomicPointer delay_data_sync_;

  // sstable/log Sync() calls return an error.
  port::AtomicPointer data_sync_error_;

  // Simulate no-space errors while this pointer is non-NULL.
  port::AtomicPointer no_space_;

  // Simulate non-writable file system while this pointer is non-NULL
  port::AtomicPointer non_writable_;

  // Force sync of manifest files to fail while this pointer is non-NULL
  port::AtomicPointer manifest_sync_error_;

  // Force write to manifest files to fail while this pointer is non-NULL
  port::AtomicPointer manifest_write_error_;

  bool count_random_reads_;
  AtomicCounter random_read_counter_;

  explicit SpecialEnv(Env* base) : EnvWrapper(base) {
    delay_data_sync_.Release_Store(NULL);
    data_sync_error_.Release_Store(NULL);
    no_space_.Release_Store(NULL);
    non_writable_.Release_Store(NULL);
    count_random_reads_ =...",1,db\db_test.cc,leveldb.SpecialEnv,EnvWrapper,false,58,SpecialEnv,3
16076,TYPE_DECL,,,,"class DBTest {
 private:
  const FilterPolicy* filter_policy_;

  // Sequence of option configurations to try
  enum OptionConfig {
    kDefault,
    kReuse,
    kFilter,
    kUncompressed,
    kEnd
  };
  int option_config_;

 public:
  std::string dbname_;
  SpecialEnv* env_;
  DB* db_;

  Options last_options_;

  DBTest() : option_config_(kDefault),
             env_(new SpecialEnv(Env::Default())) {
    filter_policy_ = NewBloomFilterPolicy(10);
    dbname_ = test::TmpDir() + ""/db_test"";
    DestroyDB(dbname_, Options());
    db_ = NULL;
    Reopen();
  }

  ~DBTest() {
    delete db_;
    DestroyDB(dbname_, Options());
    delete env_;
    delete filter_policy_;
  }

  // Switch to a fresh database with the next option configuration to
  // test.  Return false if there are no more configurations to test.
  bool ChangeOptions() {
    option_config_++;
    if (option_config_ >= kEnd) {
      return false;
    } else {
      DestroyAndReopen();
      return true;
    }
  }

  // ...",1,db\db_test.cc,leveldb.DBTest,,false,189,DBTest,4
16078,TYPE_DECL,,,,"enum OptionConfig {
    kDefault,
    kReuse,
    kFilter,
    kUncompressed,
    kEnd
  }",3,db\db_test.cc,leveldb.DBTest.OptionConfig,,false,194,OptionConfig,2
17191,TYPE_DECL,,,,_Test_Empty,1,db\db_test.cc,leveldb._Test_Empty,DBTest,false,511,_Test_Empty,5
17263,TYPE_DECL,,,,_Test_ReadWrite,1,db\db_test.cc,leveldb._Test_ReadWrite,DBTest,false,518,_Test_ReadWrite,9
17404,TYPE_DECL,,,,_Test_PutDeleteGet,1,db\db_test.cc,leveldb._Test_PutDeleteGet,DBTest,false,529,_Test_PutDeleteGet,13
17556,TYPE_DECL,,,,_Test_GetFromImmutableLayer,1,db\db_test.cc,leveldb._Test_GetFromImmutableLayer,DBTest,false,540,_Test_GetFromImmutableLayer,17
17693,TYPE_DECL,,,,_Test_GetFromVersions,1,db\db_test.cc,leveldb._Test_GetFromVersions,DBTest,false,558,_Test_GetFromVersions,21
17768,TYPE_DECL,,,,_Test_GetMemUsage,1,db\db_test.cc,leveldb._Test_GetMemUsage,DBTest,false,566,_Test_GetMemUsage,25
17887,TYPE_DECL,,,,_Test_GetSnapshot,1,db\db_test.cc,leveldb._Test_GetSnapshot,DBTest,false,577,_Test_GetSnapshot,29
18075,TYPE_DECL,,,,_Test_GetLevel0Ordering,1,db\db_test.cc,leveldb._Test_GetLevel0Ordering,DBTest,false,595,_Test_GetLevel0Ordering,33
18186,TYPE_DECL,,,,_Test_GetOrderedByLevels,1,db\db_test.cc,leveldb._Test_GetOrderedByLevels,DBTest,false,610,_Test_GetOrderedByLevels,37
18318,TYPE_DECL,,,,_Test_GetPicksCorrectFile,1,db\db_test.cc,leveldb._Test_GetPicksCorrectFile,DBTest,false,622,_Test_GetPicksCorrectFile,41
18468,TYPE_DECL,,,,_Test_GetEncountersEmptyLevel,1,db\db_test.cc,leveldb._Test_GetEncountersEmptyLevel,DBTest,false,637,_Test_GetEncountersEmptyLevel,45
18666,TYPE_DECL,,,,_Test_IterEmpty,1,db\db_test.cc,leveldb._Test_IterEmpty,DBTest,false,676,_Test_IterEmpty,49
18779,TYPE_DECL,,,,_Test_IterSingle,1,db\db_test.cc,leveldb._Test_IterSingle,DBTest,false,691,_Test_IterSingle,53
19140,TYPE_DECL,,,,_Test_IterMulti,1,db\db_test.cc,leveldb._Test_IterMulti,DBTest,false,729,_Test_IterMulti,57
19962,TYPE_DECL,,,,_Test_IterSmallAndLargeMix,1,db\db_test.cc,leveldb._Test_IterSmallAndLargeMix,DBTest,false,812,_Test_IterSmallAndLargeMix,61
20412,TYPE_DECL,,,,_Test_IterMultiWithDelete,1,db\db_test.cc,leveldb._Test_IterMultiWithDelete,DBTest,false,850,_Test_IterMultiWithDelete,65
20589,TYPE_DECL,,,,_Test_Recover,1,db\db_test.cc,leveldb._Test_Recover,DBTest,false,867,_Test_Recover,69
20840,TYPE_DECL,,,,_Test_RecoveryWithEmptyLog,1,db\db_test.cc,leveldb._Test_RecoveryWithEmptyLog,DBTest,false,889,_Test_RecoveryWithEmptyLog,73
20946,TYPE_DECL,,,,_Test_RecoverDuringMemtableCompaction,1,db\db_test.cc,leveldb._Test_RecoverDuringMemtableCompaction,DBTest,false,903,_Test_RecoverDuringMemtableCompaction,77
21178,TYPE_DECL,,,,_Test_MinorCompactionsHappen,1,db\db_test.cc,leveldb._Test_MinorCompactionsHappen,DBTest,false,930,_Test_MinorCompactionsHappen,82
21370,TYPE_DECL,,,,_Test_RecoverWithLargeLog,1,db\db_test.cc,leveldb._Test_RecoverWithLargeLog,DBTest,false,955,_Test_RecoverWithLargeLog,86
21656,TYPE_DECL,,,,_Test_CompactionsGenerateMultipleFiles,1,db\db_test.cc,leveldb._Test_CompactionsGenerateMultipleFiles,DBTest,false,979,_Test_CompactionsGenerateMultipleFiles,90
21856,TYPE_DECL,,,,_Test_RepeatedWritesToSameKey,1,db\db_test.cc,leveldb._Test_RepeatedWritesToSameKey,DBTest,false,1005,_Test_RepeatedWritesToSameKey,94
21973,TYPE_DECL,,,,_Test_SparseMerge,1,db\db_test.cc,leveldb._Test_SparseMerge,DBTest,false,1024,_Test_SparseMerge,98
22198,TYPE_DECL,,,,_Test_ApproximateSizes,1,db\db_test.cc,leveldb._Test_ApproximateSizes,DBTest,false,1075,_Test_ApproximateSizes,103
22653,TYPE_DECL,,,,_Test_ApproximateSizes_MixOfSmallAndLarge,1,db\db_test.cc,leveldb._Test_ApproximateSizes_MixOfSmallAndLarge,DBTest,false,1133,_Test_ApproximateSizes_MixOfSmallAndLarge,107
23122,TYPE_DECL,,,,_Test_IteratorPinsRef,1,db\db_test.cc,leveldb._Test_IteratorPinsRef,DBTest,false,1176,_Test_IteratorPinsRef,111
23323,TYPE_DECL,,,,_Test_Snapshot,1,db\db_test.cc,leveldb._Test_Snapshot,DBTest,false,1198,_Test_Snapshot,115
23591,TYPE_DECL,,,,_Test_HiddenValuesAreRemoved,1,db\db_test.cc,leveldb._Test_HiddenValuesAreRemoved,DBTest,false,1227,_Test_HiddenValuesAreRemoved,119
23877,TYPE_DECL,,,,_Test_DeletionMarkers1,1,db\db_test.cc,leveldb._Test_DeletionMarkers1,DBTest,false,1258,_Test_DeletionMarkers1,123
24127,TYPE_DECL,,,,_Test_DeletionMarkers2,1,db\db_test.cc,leveldb._Test_DeletionMarkers2,DBTest,false,1287,_Test_DeletionMarkers2,127
24370,TYPE_DECL,,,,_Test_OverlapInLevel0,1,db\db_test.cc,leveldb._Test_OverlapInLevel0,DBTest,false,1313,_Test_OverlapInLevel0,131
24710,TYPE_DECL,,,,_Test_L0_CompactionBug_Issue44_a,1,db\db_test.cc,leveldb._Test_L0_CompactionBug_Issue44_a,DBTest,false,1354,_Test_L0_CompactionBug_Issue44_a,135
24868,TYPE_DECL,,,,_Test_L0_CompactionBug_Issue44_b,1,db\db_test.cc,leveldb._Test_L0_CompactionBug_Issue44_b,DBTest,false,1371,_Test_L0_CompactionBug_Issue44_b,139
24975,TYPE_DECL,,,,_Test_ComparatorCheck,1,db\db_test.cc,leveldb._Test_ComparatorCheck,DBTest,false,1397,_Test_ComparatorCheck,143
25082,TYPE_DECL,,,,_Test_CustomComparator,1,db\db_test.cc,leveldb._Test_CustomComparator,DBTest,false,1420,_Test_CustomComparator,147
25357,TYPE_DECL,,,,_Test_ManualCompaction,1,db\db_test.cc,leveldb._Test_ManualCompaction,DBTest,false,1475,_Test_ManualCompaction,151
25576,TYPE_DECL,,,,_Test_DBOpen_Options,1,db\db_test.cc,leveldb._Test_DBOpen_Options,DBTest,false,1509,_Test_DBOpen_Options,155
25855,TYPE_DECL,,,,_Test_Locking,1,db\db_test.cc,leveldb._Test_Locking,DBTest,false,1548,_Test_Locking,159
25929,TYPE_DECL,,,,_Test_NoSpace,1,db\db_test.cc,leveldb._Test_NoSpace,DBTest,false,1555,_Test_NoSpace,163
26083,TYPE_DECL,,,,_Test_NonWritableFileSystem,1,db\db_test.cc,leveldb._Test_NonWritableFileSystem,DBTest,false,1574,_Test_NonWritableFileSystem,167
26218,TYPE_DECL,,,,_Test_WriteSyncError,1,db\db_test.cc,leveldb._Test_WriteSyncError,DBTest,false,1594,_Test_WriteSyncError,171
26472,TYPE_DECL,,,,_Test_ManifestWriteError,1,db\db_test.cc,leveldb._Test_ManifestWriteError,DBTest,false,1625,_Test_ManifestWriteError,175
26695,TYPE_DECL,,,,_Test_MissingSSTFile,1,db\db_test.cc,leveldb._Test_MissingSSTFile,DBTest,false,1666,_Test_MissingSSTFile,179
26875,TYPE_DECL,,,,_Test_StillReadSST,1,db\db_test.cc,leveldb._Test_StillReadSST,DBTest,false,1684,_Test_StillReadSST,183
27040,TYPE_DECL,,,,_Test_FilesDeletedAfterCompaction,1,db\db_test.cc,leveldb._Test_FilesDeletedAfterCompaction,DBTest,false,1700,_Test_FilesDeletedAfterCompaction,187
27144,TYPE_DECL,,,,_Test_BloomFilter,1,db\db_test.cc,leveldb._Test_BloomFilter,DBTest,false,1711,_Test_BloomFilter,191
27479,TYPE_DECL,,,,"struct MTState {
  DBTest* test;
  port::AtomicPointer stop;
  port::AtomicPointer counter[kNumThreads];
  port::AtomicPointer thread_done[kNumThreads];
}",1,db\db_test.cc,leveldb.anonymous_namespace_15.MTState,,false,1765,MTState,7
27492,TYPE_DECL,,,,"struct MTThread {
  MTState* state;
  int id;
}",1,db\db_test.cc,leveldb.anonymous_namespace_16.MTThread,,false,1772,MTThread,8
27799,TYPE_DECL,,,,_Test_MultiThreaded,1,db\db_test.cc,leveldb._Test_MultiThreaded,DBTest,false,1824,_Test_MultiThreaded,196
27954,TYPE_DECL,ANY,,,"typedef std::map<std::string, std::string> KVMap;",44,db\db_test.cc,KVMap,,false,1857,KVMap,1
27955,TYPE_DECL,,,,"class ModelDB: public DB {
 public:
  class ModelSnapshot : public Snapshot {
   public:
    KVMap map_;
  };

  explicit ModelDB(const Options& options): options_(options) { }
  ~ModelDB() { }
  virtual Status Put(const WriteOptions& o, const Slice& k, const Slice& v) {
    return DB::Put(o, k, v);
  }
  virtual Status Delete(const WriteOptions& o, const Slice& key) {
    return DB::Delete(o, key);
  }
  virtual Status Get(const ReadOptions& options,
                     const Slice& key, std::string* value) {
    assert(false);      // Not implemented
    return Status::NotFound(key);
  }
  virtual Iterator* NewIterator(const ReadOptions& options) {
    if (options.snapshot == NULL) {
      KVMap* saved = new KVMap;
      *saved = map_;
      return new ModelIter(saved, true);
    } else {
      const KVMap* snapshot_state =
          &(reinterpret_cast<const ModelSnapshot*>(options.snapshot)->map_);
      return new ModelIter(snapshot_state, false);
    }
  }
  virtual const Snap...",1,db\db_test.cc,leveldb.ModelDB,DB,false,1860,ModelDB,201
27956,TYPE_DECL,,,,"class ModelSnapshot : public Snapshot {
   public:
    KVMap map_;
  }",3,db\db_test.cc,leveldb.ModelDB.ModelSnapshot,Snapshot,false,1862,ModelSnapshot,1
28137,TYPE_DECL,,,,"class ModelIter: public Iterator {
   public:
    ModelIter(const KVMap* map, bool owned)
        : map_(map), owned_(owned), iter_(map_->end()) {
    }
    ~ModelIter() {
      if (owned_) delete map_;
    }
    virtual bool Valid() const { return iter_ != map_->end(); }
    virtual void SeekToFirst() { iter_ = map_->begin(); }
    virtual void SeekToLast() {
      if (map_->empty()) {
        iter_ = map_->end();
      } else {
        iter_ = map_->find(map_->rbegin()->first);
      }
    }
    virtual void Seek(const Slice& k) {
      iter_ = map_->lower_bound(k.ToString());
    }
    virtual void Next() { ++iter_; }
    virtual void Prev() { --iter_; }
    virtual Slice key() const { return iter_->first; }
    virtual Slice value() const { return iter_->second; }
    virtual Status status() const { return Status::OK(); }
   private:
    const KVMap* const map_;
    const bool owned_;  // Do we own map_
    KVMap::const_iterator iter_;
  }",3,db\db_test.cc,leveldb.ModelDB.ModelIter,Iterator,false,1928,ModelIter,14
28502,TYPE_DECL,,,,_Test_Randomized,1,db\db_test.cc,leveldb._Test_Randomized,DBTest,false,2017,_Test_Randomized,204
29318,TYPE_DECL,,db\dbformat.cc:<global>,NAMESPACE_BLOCK,<global>,1,db\dbformat.cc,db\dbformat.cc:<global>,,false,1,<global>,5
29818,TYPE_DECL,,db\dbformat.hpp:<global>,NAMESPACE_BLOCK,<global>,1,db\dbformat.hpp,db\dbformat.hpp:<global>,,false,1,<global>,9
29847,TYPE_DECL,,,,class InternalKey,1,db\dbformat.hpp,leveldb.InternalKey,,false,46,InternalKey,2
29848,TYPE_DECL,,,,"enum ValueType {
  kTypeDeletion = 0x0,
  kTypeValue = 0x1
}",1,db\dbformat.hpp,leveldb.ValueType,,false,51,ValueType,3
29865,TYPE_DECL,ANY,,,typedef uint64_t SequenceNumber;,18,db\dbformat.hpp,SequenceNumber,,false,63,SequenceNumber,6
29874,TYPE_DECL,,,,"struct ParsedInternalKey {
  Slice user_key;
  SequenceNumber sequence;
  ValueType type;

  ParsedInternalKey() { }  // Intentionally left uninitialized (for speed)
  ParsedInternalKey(const Slice& u, const SequenceNumber& seq, ValueType t)
      : user_key(u), sequence(seq), type(t) { }
  std::string DebugString() const;
}",1,db\dbformat.hpp,leveldb.ParsedInternalKey,,false,70,ParsedInternalKey,9
29984,TYPE_DECL,,,,"class InternalKeyComparator : public Comparator {
 private:
  const Comparator* user_comparator_;
 public:
  explicit InternalKeyComparator(const Comparator* c) : user_comparator_(c) { }
  virtual const char* Name() const;
  virtual int Compare(const Slice& a, const Slice& b) const;
  virtual void FindShortestSeparator(
      std::string* start,
      const Slice& limit) const;
  virtual void FindShortSuccessor(std::string* key) const;

  const Comparator* user_comparator() const { return user_comparator_; }

  int Compare(const InternalKey& a, const InternalKey& b) const;
}",1,db\dbformat.hpp,leveldb.InternalKeyComparator,Comparator,false,113,InternalKeyComparator,15
30024,TYPE_DECL,,,,"class InternalFilterPolicy : public FilterPolicy {
 private:
  const FilterPolicy* const user_policy_;
 public:
  explicit InternalFilterPolicy(const FilterPolicy* p) : user_policy_(p) { }
  virtual const char* Name() const;
  virtual void CreateFilter(const Slice* keys, int n, std::string* dst) const;
  virtual bool KeyMayMatch(const Slice& key, const Slice& filter) const;
}",1,db\dbformat.hpp,leveldb.InternalFilterPolicy,FilterPolicy,false,131,InternalFilterPolicy,16
30048,TYPE_DECL,,,,"class InternalKey {
 private:
  std::string rep_;
 public:
  InternalKey() { }   // Leave rep_ as empty to indicate it is invalid
  InternalKey(const Slice& user_key, SequenceNumber s, ValueType t) {
    AppendInternalKey(&rep_, ParsedInternalKey(user_key, s, t));
  }

  void DecodeFrom(const Slice& s) { rep_.assign(s.data(), s.size()); }
  Slice Encode() const {
    assert(!rep_.empty());
    return rep_;
  }

  Slice user_key() const { return ExtractUserKey(rep_); }

  void SetFrom(const ParsedInternalKey& p) {
    rep_.clear();
    AppendInternalKey(&rep_, p);
  }

  void Clear() { rep_.clear(); }

  std::string DebugString() const;
}",1,db\dbformat.hpp,leveldb.InternalKey,,false,144,InternalKey,17
30215,TYPE_DECL,,,,"class LookupKey {
 public:
  // Initialize *this for looking up user_key at a snapshot with
  // the specified sequence number.
  LookupKey(const Slice& user_key, SequenceNumber sequence);

  ~LookupKey();

  // Return a key suitable for lookup in a MemTable.
  Slice memtable_key() const { return Slice(start_, end_ - start_); }

  // Return an internal key (suitable for passing to an internal iterator)
  Slice internal_key() const { return Slice(kstart_, end_ - kstart_); }

  // Return the user key
  Slice user_key() const { return Slice(kstart_, end_ - kstart_ - 8); }

 private:
  // We construct a char array of the form:
  //    klength  varint32               <-- start_
  //    userkey  char[klength]          <-- kstart_
  //    tag      uint64
  //                                    <-- end_
  // The array is a suitable MemTable key.
  // The suffix starting with ""userkey"" can be used as an InternalKey.
  const char* start_;
  const char* kstart_;
  const char* end_;
  char spac...",1,db\dbformat.hpp,leveldb.LookupKey,,false,189,LookupKey,20
30297,TYPE_DECL,,db\dbformat_test.cc:<global>,NAMESPACE_BLOCK,<global>,1,db\dbformat_test.cc,db\dbformat_test.cc:<global>,,false,1,<global>,4
30485,TYPE_DECL,,,,class FormatTest { },1,db\dbformat_test.cc,leveldb.FormatTest,,false,47,FormatTest,5
30486,TYPE_DECL,,,,_Test_InternalKey_EncodeDecode,1,db\dbformat_test.cc,leveldb._Test_InternalKey_EncodeDecode,FormatTest,false,49,_Test_InternalKey_EncodeDecode,6
30621,TYPE_DECL,,,,_Test_InternalKeyShortSeparator,1,db\dbformat_test.cc,leveldb._Test_InternalKeyShortSeparator,FormatTest,false,65,_Test_InternalKeyShortSeparator,10
30862,TYPE_DECL,,,,_Test_InternalKeyShortestSuccessor,1,db\dbformat_test.cc,leveldb._Test_InternalKeyShortestSuccessor,FormatTest,false,101,_Test_InternalKeyShortestSuccessor,14
30980,TYPE_DECL,,db\dumpfile.cc:<global>,NAMESPACE_BLOCK,<global>,1,db\dumpfile.cc,db\dumpfile.cc:<global>,,false,1,<global>,14
31043,TYPE_DECL,,,,"class CorruptionReporter : public log::Reader::Reporter {
 public:
  WritableFile* dst_;
  virtual void Corruption(size_t bytes, const Status& status) {
    std::string r = ""corruption: "";
    AppendNumberTo(&r, bytes);
    r += "" bytes; "";
    r += status.ToString();
    r.push_back('\n');
    dst_->Append(r);
  }
}",1,db\dumpfile.cc,leveldb.anonymous_namespace_2.CorruptionReporter,log.Reader.Reporter,false,36,CorruptionReporter,2
31147,TYPE_DECL,,,,"class WriteBatchItemPrinter : public WriteBatch::Handler {
 public:
  WritableFile* dst_;
  virtual void Put(const Slice& key, const Slice& value) {
    std::string r = ""  put '"";
    AppendEscapedStringTo(&r, key);
    r += ""' '"";
    AppendEscapedStringTo(&r, value);
    r += ""'\n"";
    dst_->Append(r);
  }
  virtual void Delete(const Slice& key) {
    std::string r = ""  del '"";
    AppendEscapedStringTo(&r, key);
    r += ""'\n"";
    dst_->Append(r);
  }
}",1,db\dumpfile.cc,leveldb.anonymous_namespace_5.WriteBatchItemPrinter,WriteBatch.Handler,false,71,WriteBatchItemPrinter,4
31732,TYPE_DECL,,db\fault_injection_test.cc:<global>,NAMESPACE_BLOCK,<global>,1,db\fault_injection_test.cc,db\fault_injection_test.cc:<global>,,false,1,<global>,16
31748,TYPE_DECL,,,,class FaultInjectionTestEnv,1,db\fault_injection_test.cc,leveldb.FaultInjectionTestEnv,,false,32,FaultInjectionTestEnv,7
31909,TYPE_DECL,,,,"struct FileState {
  std::string filename_;
  ssize_t pos_;
  ssize_t pos_at_last_sync_;
  ssize_t pos_at_last_flush_;

  FileState(const std::string& filename)
      : filename_(filename),
        pos_(-1),
        pos_at_last_sync_(-1),
        pos_at_last_flush_(-1) { }

  FileState() : pos_(-1), pos_at_last_sync_(-1), pos_at_last_flush_(-1) {}

  bool IsFullySynced() const { return pos_ <= 0 || pos_ == pos_at_last_sync_; }

  Status DropUnsyncedData() const;
}",1,db\fault_injection_test.cc,leveldb.anonymous_namespace_5.FileState,,false,84,FileState,4
31939,TYPE_DECL,,,,"class TestWritableFile : public WritableFile {
 public:
  TestWritableFile(const FileState& state,
                   WritableFile* f,
                   FaultInjectionTestEnv* env);
  virtual ~TestWritableFile();
  virtual Status Append(const Slice& data);
  virtual Status Close();
  virtual Status Flush();
  virtual Status Sync();

 private:
  FileState state_;
  WritableFile* target_;
  bool writable_file_opened_;
  FaultInjectionTestEnv* env_;

  Status SyncParent();
}",1,db\fault_injection_test.cc,leveldb.TestWritableFile,WritableFile,false,107,TestWritableFile,9
31976,TYPE_DECL,,,,"class FaultInjectionTestEnv : public EnvWrapper {
 public:
  FaultInjectionTestEnv() : EnvWrapper(Env::Default()), filesystem_active_(true) {}
  virtual ~FaultInjectionTestEnv() { }
  virtual Status NewWritableFile(const std::string& fname,
                                 WritableFile** result);
  virtual Status NewAppendableFile(const std::string& fname,
                                   WritableFile** result);
  virtual Status DeleteFile(const std::string& f);
  virtual Status RenameFile(const std::string& s, const std::string& t);

  void WritableFileClosed(const FileState& state);
  Status DropUnsyncedFileData();
  Status DeleteFilesCreatedAfterLastDirSync();
  void DirWasSynced();
  bool IsFileCreatedSinceLastDirSync(const std::string& filename);
  void ResetState();
  void UntrackFile(const std::string& f);
  // Setting the filesystem to inactive is the test equivalent to simulating a
  // system reset. Setting to inactive will freeze our saved filesystem state so
  // that ...",1,db\fault_injection_test.cc,leveldb.FaultInjectionTestEnv,EnvWrapper,false,127,FaultInjectionTestEnv,10
32701,TYPE_DECL,,,,"class FaultInjectionTest {
 public:
  enum ExpectedVerifResult { VAL_EXPECT_NO_ERROR, VAL_EXPECT_ERROR };
  enum ResetMethod { RESET_DROP_UNSYNCED_DATA, RESET_DELETE_UNSYNCED_FILES };

  FaultInjectionTestEnv* env_;
  std::string dbname_;
  Cache* tiny_cache_;
  Options options_;
  DB* db_;

  FaultInjectionTest()
      : env_(new FaultInjectionTestEnv),
        tiny_cache_(NewLRUCache(100)),
        db_(NULL) {
    dbname_ = test::TmpDir() + ""/fault_test"";
    DestroyDB(dbname_, Options());  // Destroy any db from earlier run
    options_.reuse_logs = true;
    options_.env = env_;
    options_.paranoid_checks = true;
    options_.block_cache = tiny_cache_;
    options_.create_if_missing = true;
  }

  ~FaultInjectionTest() {
    CloseDB();
    DestroyDB(dbname_, Options());
    delete tiny_cache_;
    delete env_;
  }

  void ReuseLogs(bool reuse) {
    options_.reuse_logs = reuse;
  }

  void Build(int start_idx, int num_vals) {
    std::string key_space, value_space;
    WriteBa...",1,db\fault_injection_test.cc,leveldb.FaultInjectionTest,,false,359,FaultInjectionTest,30
32702,TYPE_DECL,,,,"enum ExpectedVerifResult { VAL_EXPECT_NO_ERROR, VAL_EXPECT_ERROR }",3,db\fault_injection_test.cc,leveldb.FaultInjectionTest.ExpectedVerifResult,,false,361,ExpectedVerifResult,1
32705,TYPE_DECL,,,,"enum ResetMethod { RESET_DROP_UNSYNCED_DATA, RESET_DELETE_UNSYNCED_FILES }",3,db\fault_injection_test.cc,leveldb.FaultInjectionTest.ResetMethod,,false,362,ResetMethod,2
33334,TYPE_DECL,,,,_Test_FaultTestNoLogReuse,1,db\fault_injection_test.cc,leveldb._Test_FaultTestNoLogReuse,FaultInjectionTest,false,540,_Test_FaultTestNoLogReuse,31
33370,TYPE_DECL,,,,_Test_FaultTestWithLogReuse,1,db\fault_injection_test.cc,leveldb._Test_FaultTestWithLogReuse,FaultInjectionTest,false,545,_Test_FaultTestWithLogReuse,35
33433,TYPE_DECL,,db\filename.cc:<global>,NAMESPACE_BLOCK,<global>,1,db\filename.cc,db\filename.cc:<global>,,false,1,<global>,7
33844,TYPE_DECL,,db\filename.hpp:<global>,NAMESPACE_BLOCK,<global>,1,db\filename.hpp,db\filename.hpp:<global>,,false,1,<global>,6
33848,TYPE_DECL,,,,class Env,1,db\filename.hpp,leveldb.Env,,false,18,Env,1
33849,TYPE_DECL,,,,"enum FileType {
  kLogFile,
  kDBLockFile,
  kTableFile,
  kDescriptorFile,
  kCurrentFile,
  kTempFile,
  kInfoLogFile  // Either the current one, or an old one
}",1,db\filename.hpp,leveldb.FileType,,false,20,FileType,2
33933,TYPE_DECL,,db\filename_test.cc:<global>,NAMESPACE_BLOCK,<global>,1,db\filename_test.cc,db\filename_test.cc:<global>,,false,1,<global>,6
33937,TYPE_DECL,,,,class FileNameTest { },1,db\filename_test.cc,leveldb.FileNameTest,,false,14,FileNameTest,1
33938,TYPE_DECL,,,,_Test_Parse,1,db\filename_test.cc,leveldb._Test_Parse,FileNameTest,false,16,_Test_Parse,2
34197,TYPE_DECL,,,,_Test_Construction,1,db\filename_test.cc,leveldb._Test_Construction,FileNameTest,false,77,_Test_Construction,6
34782,TYPE_DECL,,db\leveldbutil.cc:<global>,NAMESPACE_BLOCK,<global>,1,db\leveldbutil.cc,db\leveldbutil.cc:<global>,,false,1,<global>,5
34787,TYPE_DECL,,,,"class StdoutPrinter : public WritableFile {
 public:
  virtual Status Append(const Slice& data) {
    fwrite(data.data(), 1, data.size(), stdout);
    return Status::OK();
  }
  virtual Status Close() { return Status::OK(); }
  virtual Status Flush() { return Status::OK(); }
  virtual Status Sync() { return Status::OK(); }
}",1,db\leveldbutil.cc,leveldb.anonymous_namespace_1.StdoutPrinter,WritableFile,false,13,StdoutPrinter,1
34966,TYPE_DECL,,db\log_format.hpp:<global>,NAMESPACE_BLOCK,<global>,1,db\log_format.hpp,db\log_format.hpp:<global>,,false,1,<global>,1
34971,TYPE_DECL,,,,"enum RecordType {
  // Zero is reserved for preallocated files
  kZeroType = 0,

  kFullType = 1,

  // For fragments
  kFirstType = 2,
  kMiddleType = 3,
  kLastType = 4
}",1,db\log_format.hpp,leveldb.log.RecordType,,false,14,RecordType,1
35024,TYPE_DECL,,db\log_reader.cc:<global>,NAMESPACE_BLOCK,<global>,1,db\log_reader.cc,db\log_reader.cc:<global>,,false,1,<global>,6
35712,TYPE_DECL,,db\log_reader.hpp:<global>,NAMESPACE_BLOCK,<global>,1,db\log_reader.hpp,db\log_reader.hpp:<global>,,false,1,<global>,5
35716,TYPE_DECL,,,,class SequentialFile,1,db\log_reader.hpp,leveldb.SequentialFile,,false,16,SequentialFile,1
35718,TYPE_DECL,,,,"class Reader {
 public:
  // Interface for reporting errors.
  class Reporter {
   public:
    virtual ~Reporter();

    // Some corruption was detected.  ""size"" is the approximate number
    // of bytes dropped due to the corruption.
    virtual void Corruption(size_t bytes, const Status& status) = 0;
  };

  // Create a reader that will return log records from ""*file"".
  // ""*file"" must remain live while this Reader is in use.
  //
  // If ""reporter"" is non-NULL, it is notified whenever some data is
  // dropped due to a detected corruption.  ""*reporter"" must remain
  // live while this Reader is in use.
  //
  // If ""checksum"" is true, verify checksums if available.
  //
  // The Reader will start reading at the first record located at physical
  // position >= initial_offset within the file.
  Reader(SequentialFile* file, Reporter* reporter, bool checksum,
         uint64_t initial_offset);

  ~Reader();

  // Read the next record into *record.  Returns true if read
  // success...",1,db\log_reader.hpp,leveldb.log.Reader,,false,20,Reader,1
35719,TYPE_DECL,,,,"class Reporter {
   public:
    virtual ~Reporter();

    // Some corruption was detected.  ""size"" is the approximate number
    // of bytes dropped due to the corruption.
    virtual void Corruption(size_t bytes, const Status& status) = 0;
  }",3,db\log_reader.hpp,leveldb.log.Reader.Reporter,,false,23,Reporter,1
35762,TYPE_DECL,,,,"enum {
    kEof = kMaxRecordType + 1,
    // Returned whenever we find an invalid physical record.
    // Currently there are three situations in which this happens:
    // * The record has an invalid CRC (ReadPhysicalRecord reports a drop)
    // * The record is a 0-length record (No drop is reported)
    // * The record is below constructor's initial_offset (No drop is reported)
    kBadRecord = kMaxRecordType + 2
  }",3,db\log_reader.hpp,leveldb.log.Reader.anonymous_enum_0,,false,82,anonymous_enum_0,16
35826,TYPE_DECL,,db\log_test.cc:<global>,NAMESPACE_BLOCK,<global>,1,db\log_test.cc,db\log_test.cc:<global>,,false,1,<global>,8
35891,TYPE_DECL,,,,"class LogTest {
 private:
  class StringDest : public WritableFile {
   public:
    std::string contents_;

    virtual Status Close() { return Status::OK(); }
    virtual Status Flush() { return Status::OK(); }
    virtual Status Sync() { return Status::OK(); }
    virtual Status Append(const Slice& slice) {
      contents_.append(slice.data(), slice.size());
      return Status::OK();
    }
  };

  class StringSource : public SequentialFile {
   public:
    Slice contents_;
    bool force_error_;
    bool returned_partial_;
    StringSource() : force_error_(false), returned_partial_(false) { }

    virtual Status Read(size_t n, Slice* result, char* scratch) {
      ASSERT_TRUE(!returned_partial_) << ""must not Read() after eof/error"";

      if (force_error_) {
        force_error_ = false;
        returned_partial_ = true;
        return Status::Corruption(""read error"");
      }

      if (contents_.size() < n) {
        n = contents_.size();
        returned_partial_ = true;
    ...",1,db\log_test.cc,leveldb.log.LogTest,,false,39,LogTest,4
35892,TYPE_DECL,,,,"class StringDest : public WritableFile {
   public:
    std::string contents_;

    virtual Status Close() { return Status::OK(); }
    virtual Status Flush() { return Status::OK(); }
    virtual Status Sync() { return Status::OK(); }
    virtual Status Append(const Slice& slice) {
      contents_.append(slice.data(), slice.size());
      return Status::OK();
    }
  }",3,db\log_test.cc,leveldb.log.LogTest.StringDest,WritableFile,false,41,StringDest,1
35943,TYPE_DECL,,,,"class StringSource : public SequentialFile {
   public:
    Slice contents_;
    bool force_error_;
    bool returned_partial_;
    StringSource() : force_error_(false), returned_partial_(false) { }

    virtual Status Read(size_t n, Slice* result, char* scratch) {
      ASSERT_TRUE(!returned_partial_) << ""must not Read() after eof/error"";

      if (force_error_) {
        force_error_ = false;
        returned_partial_ = true;
        return Status::Corruption(""read error"");
      }

      if (contents_.size() < n) {
        n = contents_.size();
        returned_partial_ = true;
      }
      *result = Slice(contents_.data(), n);
      contents_.remove_prefix(n);
      return Status::OK();
    }

    virtual Status Skip(uint64_t n) {
      if (n > contents_.size()) {
        contents_.clear();
        return Status::NotFound(""in-memory file skipped past end"");
      }

      contents_.remove_prefix(n);

      return Status::OK();
    }
  }",3,db\log_test.cc,leveldb.log.LogTest.StringSource,SequentialFile,false,54,StringSource,2
36062,TYPE_DECL,,,,"class ReportCollector : public Reader::Reporter {
   public:
    size_t dropped_bytes_;
    std::string message_;

    ReportCollector() : dropped_bytes_(0) { }
    virtual void Corruption(size_t bytes, const Status& status) {
      dropped_bytes_ += bytes;
      message_.append(status.ToString());
    }
  }",3,db\log_test.cc,leveldb.log.LogTest.ReportCollector,Reader.Reporter,false,91,ReportCollector,3
36702,TYPE_DECL,,,,_Test_Empty,1,db\log_test.cc,leveldb.log._Test_Empty,LogTest,false,270,_Test_Empty,11
36752,TYPE_DECL,,,,_Test_ReadWrite,1,db\log_test.cc,leveldb.log._Test_ReadWrite,LogTest,false,274,_Test_ReadWrite,15
36895,TYPE_DECL,,,,_Test_ManyBlocks,1,db\log_test.cc,leveldb.log._Test_ManyBlocks,LogTest,false,287,_Test_ManyBlocks,19
36991,TYPE_DECL,,,,_Test_Fragmentation,1,db\log_test.cc,leveldb.log._Test_Fragmentation,LogTest,false,297,_Test_Fragmentation,23
37104,TYPE_DECL,,,,_Test_MarginalTrailer,1,db\log_test.cc,leveldb.log._Test_MarginalTrailer,LogTest,false,307,_Test_MarginalTrailer,27
37240,TYPE_DECL,,,,_Test_MarginalTrailer2,1,db\log_test.cc,leveldb.log._Test_MarginalTrailer2,LogTest,false,320,_Test_MarginalTrailer2,31
37391,TYPE_DECL,,,,_Test_ShortTrailer,1,db\log_test.cc,leveldb.log._Test_ShortTrailer,LogTest,false,333,_Test_ShortTrailer,35
37531,TYPE_DECL,,,,_Test_AlignedEof,1,db\log_test.cc,leveldb.log._Test_AlignedEof,LogTest,false,345,_Test_AlignedEof,39
37633,TYPE_DECL,,,,_Test_OpenForAppend,1,db\log_test.cc,leveldb.log._Test_OpenForAppend,LogTest,false,353,_Test_OpenForAppend,43
37722,TYPE_DECL,,,,_Test_RandomRead,1,db\log_test.cc,leveldb.log._Test_RandomRead,LogTest,false,362,_Test_RandomRead,47
37830,TYPE_DECL,,,,_Test_ReadError,1,db\log_test.cc,leveldb.log._Test_ReadError,LogTest,false,377,_Test_ReadError,51
37917,TYPE_DECL,,,,_Test_BadRecordType,1,db\log_test.cc,leveldb.log._Test_BadRecordType,LogTest,false,385,_Test_BadRecordType,55
38009,TYPE_DECL,,,,_Test_TruncatedTrailingRecordIsIgnored,1,db\log_test.cc,leveldb.log._Test_TruncatedTrailingRecordIsIgnored,LogTest,false,395,_Test_TruncatedTrailingRecordIsIgnored,59
38097,TYPE_DECL,,,,_Test_BadLength,1,db\log_test.cc,leveldb.log._Test_BadLength,LogTest,false,404,_Test_BadLength,63
38196,TYPE_DECL,,,,_Test_BadLengthAtEndIsIgnored,1,db\log_test.cc,leveldb.log._Test_BadLengthAtEndIsIgnored,LogTest,false,415,_Test_BadLengthAtEndIsIgnored,67
38284,TYPE_DECL,,,,_Test_ChecksumMismatch,1,db\log_test.cc,leveldb.log._Test_ChecksumMismatch,LogTest,false,423,_Test_ChecksumMismatch,71
38373,TYPE_DECL,,,,_Test_UnexpectedMiddleType,1,db\log_test.cc,leveldb.log._Test_UnexpectedMiddleType,LogTest,false,431,_Test_UnexpectedMiddleType,75
38465,TYPE_DECL,,,,_Test_UnexpectedLastType,1,db\log_test.cc,leveldb.log._Test_UnexpectedLastType,LogTest,false,440,_Test_UnexpectedLastType,79
38557,TYPE_DECL,,,,_Test_UnexpectedFullType,1,db\log_test.cc,leveldb.log._Test_UnexpectedFullType,LogTest,false,449,_Test_UnexpectedFullType,83
38668,TYPE_DECL,,,,_Test_UnexpectedFirstType,1,db\log_test.cc,leveldb.log._Test_UnexpectedFirstType,LogTest,false,460,_Test_UnexpectedFirstType,87
38782,TYPE_DECL,,,,_Test_MissingLastIsIgnored,1,db\log_test.cc,leveldb.log._Test_MissingLastIsIgnored,LogTest,false,471,_Test_MissingLastIsIgnored,91
38872,TYPE_DECL,,,,_Test_PartialLastIsIgnored,1,db\log_test.cc,leveldb.log._Test_PartialLastIsIgnored,LogTest,false,480,_Test_PartialLastIsIgnored,95
38962,TYPE_DECL,,,,_Test_SkipIntoMultiRecord,1,db\log_test.cc,leveldb.log._Test_SkipIntoMultiRecord,LogTest,false,489,_Test_SkipIntoMultiRecord,99
39073,TYPE_DECL,,,,_Test_ErrorJoinsRecords,1,db\log_test.cc,leveldb.log._Test_ErrorJoinsRecords,LogTest,false,505,_Test_ErrorJoinsRecords,103
39209,TYPE_DECL,,,,_Test_ReadStart,1,db\log_test.cc,leveldb.log._Test_ReadStart,LogTest,false,528,_Test_ReadStart,107
39245,TYPE_DECL,,,,_Test_ReadSecondOneOff,1,db\log_test.cc,leveldb.log._Test_ReadSecondOneOff,LogTest,false,532,_Test_ReadSecondOneOff,111
39281,TYPE_DECL,,,,_Test_ReadSecondTenThousand,1,db\log_test.cc,leveldb.log._Test_ReadSecondTenThousand,LogTest,false,536,_Test_ReadSecondTenThousand,115
39317,TYPE_DECL,,,,_Test_ReadSecondStart,1,db\log_test.cc,leveldb.log._Test_ReadSecondStart,LogTest,false,540,_Test_ReadSecondStart,119
39353,TYPE_DECL,,,,_Test_ReadThirdOneOff,1,db\log_test.cc,leveldb.log._Test_ReadThirdOneOff,LogTest,false,544,_Test_ReadThirdOneOff,123
39389,TYPE_DECL,,,,_Test_ReadThirdStart,1,db\log_test.cc,leveldb.log._Test_ReadThirdStart,LogTest,false,548,_Test_ReadThirdStart,127
39425,TYPE_DECL,,,,_Test_ReadFourthOneOff,1,db\log_test.cc,leveldb.log._Test_ReadFourthOneOff,LogTest,false,552,_Test_ReadFourthOneOff,131
39461,TYPE_DECL,,,,_Test_ReadFourthFirstBlockTrailer,1,db\log_test.cc,leveldb.log._Test_ReadFourthFirstBlockTrailer,LogTest,false,556,_Test_ReadFourthFirstBlockTrailer,135
39501,TYPE_DECL,,,,_Test_ReadFourthMiddleBlock,1,db\log_test.cc,leveldb.log._Test_ReadFourthMiddleBlock,LogTest,false,560,_Test_ReadFourthMiddleBlock,139
39541,TYPE_DECL,,,,_Test_ReadFourthLastBlock,1,db\log_test.cc,leveldb.log._Test_ReadFourthLastBlock,LogTest,false,564,_Test_ReadFourthLastBlock,143
39583,TYPE_DECL,,,,_Test_ReadFourthStart,1,db\log_test.cc,leveldb.log._Test_ReadFourthStart,LogTest,false,568,_Test_ReadFourthStart,147
39635,TYPE_DECL,,,,_Test_ReadInitialOffsetIntoBlockPadding,1,db\log_test.cc,leveldb.log._Test_ReadInitialOffsetIntoBlockPadding,LogTest,false,574,_Test_ReadInitialOffsetIntoBlockPadding,151
39677,TYPE_DECL,,,,_Test_ReadEnd,1,db\log_test.cc,leveldb.log._Test_ReadEnd,LogTest,false,578,_Test_ReadEnd,155
39712,TYPE_DECL,,,,_Test_ReadPastEnd,1,db\log_test.cc,leveldb.log._Test_ReadPastEnd,LogTest,false,582,_Test_ReadPastEnd,159
39772,TYPE_DECL,,db\log_writer.cc:<global>,NAMESPACE_BLOCK,<global>,1,db\log_writer.cc,db\log_writer.cc:<global>,,false,1,<global>,6
40097,TYPE_DECL,,db\log_writer.hpp:<global>,NAMESPACE_BLOCK,<global>,1,db\log_writer.hpp,db\log_writer.hpp:<global>,,false,1,<global>,5
40101,TYPE_DECL,,,,class WritableFile,1,db\log_writer.hpp,leveldb.WritableFile,,false,15,WritableFile,1
40103,TYPE_DECL,,,,"class Writer {
 public:
  // Create a writer that will append data to ""*dest"".
  // ""*dest"" must be initially empty.
  // ""*dest"" must remain live while this Writer is in use.
  explicit Writer(WritableFile* dest);

  // Create a writer that will append data to ""*dest"".
  // ""*dest"" must have initial length ""dest_length"".
  // ""*dest"" must remain live while this Writer is in use.
  Writer(WritableFile* dest, uint64_t dest_length);

  ~Writer();

  Status AddRecord(const Slice& slice);

 private:
  WritableFile* dest_;
  int block_offset_;       // Current offset in block

  // crc32c values for all supported record types.  These are
  // pre-computed to reduce the overhead of computing the crc of the
  // record type stored in the header.
  uint32_t type_crc_[kMaxRecordType + 1];

  Status EmitPhysicalRecord(RecordType type, const char* ptr, size_t length);

  // No copying allowed
  Writer(const Writer&);
  void operator=(const Writer&);
}",1,db\log_writer.hpp,leveldb.log.Writer,,false,19,Writer,1
40166,TYPE_DECL,,db\memtable.cc:<global>,NAMESPACE_BLOCK,<global>,1,db\memtable.cc,db\memtable.cc:<global>,,false,1,<global>,7
40271,TYPE_DECL,,,,"class MemTableIterator: public Iterator {
 public:
  explicit MemTableIterator(MemTable::Table* table) : iter_(table) { }

  virtual bool Valid() const { return iter_.Valid(); }
  virtual void Seek(const Slice& k) { iter_.Seek(EncodeKey(&tmp_, k)); }
  virtual void SeekToFirst() { iter_.SeekToFirst(); }
  virtual void SeekToLast() { iter_.SeekToLast(); }
  virtual void Next() { iter_.Next(); }
  virtual void Prev() { iter_.Prev(); }
  virtual Slice key() const { return GetLengthPrefixedSlice(iter_.key()); }
  virtual Slice value() const {
    Slice key_slice = GetLengthPrefixedSlice(iter_.key());
    return GetLengthPrefixedSlice(key_slice.data() + key_slice.size());
  }

  virtual Status status() const { return Status::OK(); }

 private:
  MemTable::Table::Iterator iter_;
  std::string tmp_;       // For passing to EncodeKey

  // No copying allowed
  MemTableIterator(const MemTableIterator&);
  void operator=(const MemTableIterator&);
}",1,db\memtable.cc,leveldb.MemTableIterator,Iterator,false,51,MemTableIterator,7
40631,TYPE_DECL,,db\memtable.hpp:<global>,NAMESPACE_BLOCK,<global>,1,db\memtable.hpp,db\memtable.hpp:<global>,,false,1,<global>,6
40635,TYPE_DECL,,,,class InternalKeyComparator,1,db\memtable.hpp,leveldb.InternalKeyComparator,,false,16,InternalKeyComparator,1
40636,TYPE_DECL,,,,class Mutex,1,db\memtable.hpp,leveldb.Mutex,,false,17,Mutex,2
40637,TYPE_DECL,,,,class MemTableIterator,1,db\memtable.hpp,leveldb.MemTableIterator,,false,18,MemTableIterator,3
40638,TYPE_DECL,,,,"class MemTable {
 public:
  // MemTables are reference counted.  The initial reference count
  // is zero and the caller must call Ref() at least once.
  explicit MemTable(const InternalKeyComparator& comparator);

  // Increase reference count.
  void Ref() { ++refs_; }

  // Drop reference count.  Delete if no more references exist.
  void Unref() {
    --refs_;
    assert(refs_ >= 0);
    if (refs_ <= 0) {
      delete this;
    }
  }

  // Returns an estimate of the number of bytes of data in use by this
  // data structure. It is safe to call when MemTable is being modified.
  size_t ApproximateMemoryUsage();

  // Return an iterator that yields the contents of the memtable.
  //
  // The caller must ensure that the underlying MemTable remains live
  // while the returned iterator is live.  The keys returned by this
  // iterator are internal keys encoded by AppendInternalKey in the
  // db/format.{h,cc} module.
  Iterator* NewIterator();

  // Add an entry into memtable that m...",1,db\memtable.hpp,leveldb.MemTable,,false,20,MemTable,4
40694,TYPE_DECL,,,,"struct KeyComparator {
    const InternalKeyComparator comparator;
    explicit KeyComparator(const InternalKeyComparator& c) : comparator(c) { }
    int operator()(const char* a, const char* b) const;
  }",3,db\memtable.hpp,leveldb.MemTable.KeyComparator,,false,66,KeyComparator,9
40707,TYPE_DECL,,,,friend class MemTableIterator,3,db\memtable.hpp,leveldb.MemTable.MemTableIterator,,false,71,MemTableIterator,10
40708,TYPE_DECL,,,,friend class MemTableBackwardIterator,3,db\memtable.hpp,leveldb.MemTable.MemTableBackwardIterator,,false,72,MemTableBackwardIterator,11
40709,TYPE_DECL,ANY,,,"typedef SkipList<const char*, KeyComparator> Table;",48,db\memtable.hpp,Table,,false,74,Table,12
40746,TYPE_DECL,,db\recovery_test.cc:<global>,NAMESPACE_BLOCK,<global>,1,db\recovery_test.cc,db\recovery_test.cc:<global>,,false,1,<global>,11
40750,TYPE_DECL,,,,"class RecoveryTest {
 public:
  RecoveryTest() : env_(Env::Default()), db_(NULL) {
    dbname_ = test::TmpDir() + ""/recovery_test"";
    DestroyDB(dbname_, Options());
    Open();
  }

  ~RecoveryTest() {
    Close();
    DestroyDB(dbname_, Options());
  }

  DBImpl* dbfull() const { return reinterpret_cast<DBImpl*>(db_); }
  Env* env() const { return env_; }

  bool CanAppend() {
    WritableFile* tmp;
    Status s = env_->NewAppendableFile(CurrentFileName(dbname_), &tmp);
    delete tmp;
    if (s.IsNotSupportedError()) {
      return false;
    } else {
      return true;
    }
  }

  void Close() {
    delete db_;
    db_ = NULL;
  }

  void Open(Options* options = NULL) {
    Close();
    Options opts;
    if (options != NULL) {
      opts = *options;
    } else {
      opts.reuse_logs = true;  // TODO(sanjay): test both ways
      opts.create_if_missing = true;
    }
    if (opts.env == NULL) {
      opts.env = env_;
    }
    ASSERT_OK(DB::Open(opts, dbname_, &db_));
    ASSER...",1,db\recovery_test.cc,leveldb.RecoveryTest,,false,18,RecoveryTest,1
41355,TYPE_DECL,,,,_Test_ManifestReused,1,db\recovery_test.cc,leveldb._Test_ManifestReused,RecoveryTest,false,159,_Test_ManifestReused,2
41491,TYPE_DECL,,,,_Test_LargeManifestCompacted,1,db\recovery_test.cc,leveldb._Test_LargeManifestCompacted,RecoveryTest,false,175,_Test_LargeManifestCompacted,6
41733,TYPE_DECL,,,,_Test_NoLogFiles,1,db\recovery_test.cc,leveldb._Test_NoLogFiles,RecoveryTest,false,206,_Test_NoLogFiles,10
41839,TYPE_DECL,,,,_Test_LogFileReuse,1,db\recovery_test.cc,leveldb._Test_LogFileReuse,RecoveryTest,false,215,_Test_LogFileReuse,14
42097,TYPE_DECL,,,,_Test_MultipleMemTables,1,db\recovery_test.cc,leveldb._Test_MultipleMemTables,RecoveryTest,false,245,_Test_MultipleMemTables,18
42334,TYPE_DECL,,,,_Test_MultipleLogFiles,1,db\recovery_test.cc,leveldb._Test_MultipleLogFiles,RecoveryTest,false,274,_Test_MultipleLogFiles,22
42813,TYPE_DECL,,db\repair.cc:<global>,NAMESPACE_BLOCK,<global>,1,db\repair.cc,db\repair.cc:<global>,,false,1,<global>,14
42818,TYPE_DECL,,,,"class Repairer {
 public:
  Repairer(const std::string& dbname, const Options& options)
      : dbname_(dbname),
        env_(options.env),
        icmp_(options.comparator),
        ipolicy_(options.filter_policy),
        options_(SanitizeOptions(dbname, &icmp_, &ipolicy_, options)),
        owns_info_log_(options_.info_log != options.info_log),
        owns_cache_(options_.block_cache != options.block_cache),
        next_file_number_(1) {
    // TableCache can be small since we expect each table to be opened once.
    table_cache_ = new TableCache(dbname_, &options_, 10);
  }

  ~Repairer() {
    delete table_cache_;
    if (owns_info_log_) {
      delete options_.info_log;
    }
    if (owns_cache_) {
      delete options_.block_cache;
    }
  }

  Status Run() {
    Status status = FindFiles();
    if (status.ok()) {
      ConvertLogFilesToTables();
      ExtractMetaData();
      status = WriteDescriptor();
    }
    if (status.ok()) {
      unsigned long long bytes = 0;
     ...",1,db\repair.cc,leveldb.anonymous_namespace_1.Repairer,,false,45,Repairer,1
42924,TYPE_DECL,,,,"struct TableInfo {
    FileMetaData meta;
    SequenceNumber max_sequence;
  }",3,db\repair.cc,leveldb.anonymous_namespace_9.Repairer.TableInfo,,false,95,TableInfo,4
44241,TYPE_DECL,,db\skiplist.hpp:<global>,NAMESPACE_BLOCK,<global>,1,db\skiplist.hpp,db\skiplist.hpp:<global>,,false,1,<global>,6
44245,TYPE_DECL,,,,class Arena,1,db\skiplist.hpp,leveldb.Arena,,false,38,Arena,1
44246,TYPE_DECL,"leveldb.SkipList<Key,Comparator>",,,"class SkipList {
 private:
  struct Node;

 public:
  // Create a new SkipList object that will use ""cmp"" for comparing keys,
  // and will allocate memory using ""*arena"".  Objects allocated in the arena
  // must remain allocated for the lifetime of the skiplist object.
  explicit SkipList(Comparator cmp, Arena* arena);

  // Insert key into the list.
  // REQUIRES: nothing that compares equal to key is currently in the list.
  void Insert(const Key& key);

  // Returns true iff an entry that compares equal to key is in the list.
  bool Contains(const Key& key) const;

  // Iteration over the contents of a skip list
  class Iterator {
   public:
    // Initialize an iterator over the specified list.
    // The returned iterator is not valid.
    explicit Iterator(const SkipList* list);

    // Returns true iff the iterator is positioned at a valid node.
    bool Valid() const;

    // Returns the key at the current position.
    // REQUIRES: Valid()
    const Key& key() const;

   ...",1,db\skiplist.hpp,leveldb.SkipList,,false,41,SkipList,2
44247,TYPE_DECL,,,,struct Node,3,db\skiplist.hpp,leveldb.SkipList.Node,,false,43,Node,1
44264,TYPE_DECL,,,,"class Iterator {
   public:
    // Initialize an iterator over the specified list.
    // The returned iterator is not valid.
    explicit Iterator(const SkipList* list);

    // Returns true iff the iterator is positioned at a valid node.
    bool Valid() const;

    // Returns the key at the current position.
    // REQUIRES: Valid()
    const Key& key() const;

    // Advances to the next position.
    // REQUIRES: Valid()
    void Next();

    // Advances to the previous position.
    // REQUIRES: Valid()
    void Prev();

    // Advance to the first entry with a key >= target
    void Seek(const Key& target);

    // Position at the first entry in list.
    // Final state of iterator is Valid() iff list is not empty.
    void SeekToFirst();

    // Position at the last entry in list.
    // Final state of iterator is Valid() iff list is not empty.
    void SeekToLast();

   private:
    const SkipList* list_;
    Node* node_;
    // Intentionally copyable
  }",3,db\skiplist.hpp,leveldb.SkipList.Iterator,,false,59,Iterator,5
44301,TYPE_DECL,,,,enum { kMaxHeight = 12 },3,db\skiplist.hpp,leveldb.SkipList.anonymous_enum_0,,false,98,anonymous_enum_0,6
44381,TYPE_DECL,"leveldb.Node<Key,Comparator>",,,"struct SkipList<Key,Comparator>::Node {
  explicit Node(const Key& k) : key(k) { }

  Key const key;

  // Accessors/mutators for links.  Wrapped in methods so we can
  // add the appropriate barriers as necessary.
  Node* Next(int n) {
    assert(n >= 0);
    // Use an 'acquire load' so that we observe a fully initialized
    // version of the returned Node.
    return reinterpret_cast<Node*>(next_[n].Acquire_Load());
  }
  void SetNext(int n, Node* x) {
    assert(n >= 0);
    // Use a 'release store' so that anybody who reads through this
    // pointer observes a fully initialized version of the inserted node.
    next_[n].Release_Store(x);
  }

  // No-barrier variants that can be safely used in a few locations.
  Node* NoBarrier_Next(int n) {
    assert(n >= 0);
    return reinterpret_cast<Node*>(next_[n].NoBarrier_Load());
  }
  void NoBarrier_SetNext(int n, Node* x) {
    assert(n >= 0);
    next_[n].NoBarrier_Store(x);
  }

 private:
  // Array of length equal to the node h...",1,db\skiplist.hpp,leveldb.Node,,false,147,Node,3
44993,TYPE_DECL,,db\skiplist_test.cc:<global>,NAMESPACE_BLOCK,<global>,1,db\skiplist_test.cc,db\skiplist_test.cc:<global>,,false,1,<global>,8
44997,TYPE_DECL,ANY,,,typedef uint64_t Key;,18,db\skiplist_test.cc,Key,,false,15,Key,1
44998,TYPE_DECL,,,,"struct Comparator {
  int operator()(const Key& a, const Key& b) const {
    if (a < b) {
      return -1;
    } else if (a > b) {
      return +1;
    } else {
      return 0;
    }
  }
}",1,db\skiplist_test.cc,leveldb.Comparator,,false,17,Comparator,2
45027,TYPE_DECL,,,,class SkipTest { },1,db\skiplist_test.cc,leveldb.SkipTest,,false,29,SkipTest,3
45028,TYPE_DECL,,,,_Test_Empty,1,db\skiplist_test.cc,leveldb._Test_Empty,SkipTest,false,31,_Test_Empty,4
45207,TYPE_DECL,,,,_Test_InsertAndLookup,1,db\skiplist_test.cc,leveldb._Test_InsertAndLookup,SkipTest,false,47,_Test_InsertAndLookup,8
45797,TYPE_DECL,,,,"class ConcurrentTest {
 private:
  static const uint32_t K = 4;

  static uint64_t key(Key key) { return (key >> 40); }
  static uint64_t gen(Key key) { return (key >> 8) & 0xffffffffu; }
  static uint64_t hash(Key key) { return key & 0xff; }

  static uint64_t HashNumbers(uint64_t k, uint64_t g) {
    uint64_t data[2] = { k, g };
    return Hash(reinterpret_cast<char*>(data), sizeof(data), 0);
  }

  static Key MakeKey(uint64_t k, uint64_t g) {
    assert(sizeof(Key) == sizeof(uint64_t));
    assert(k <= K);  // We sometimes pass K to seek to the end of the skiplist
    assert(g <= 0xffffffffu);
    return ((k << 40) | (g << 8) | (HashNumbers(k, g) & 0xff));
  }

  static bool IsValidKey(Key k) {
    return hash(k) == (HashNumbers(key(k), gen(k)) & 0xff);
  }

  static Key RandomTarget(Random* rnd) {
    switch (rnd->Next() % 10) {
      case 0:
        // Seek to beginning
        return MakeKey(0, 0);
      case 1:
        // Seek to end
        return MakeKey(K, 0);
      defaul...",1,db\skiplist_test.cc,leveldb.ConcurrentTest,,false,149,ConcurrentTest,12
45933,TYPE_DECL,,,,"struct State {
    port::AtomicPointer generation[K];
    void Set(int k, intptr_t v) {
      generation[k].Release_Store(reinterpret_cast<void*>(v));
    }
    intptr_t Get(int k) {
      return reinterpret_cast<intptr_t>(generation[k].Acquire_Load());
    }

    State() {
      for (int k = 0; k < K; k++) {
        Set(k, 0);
      }
    }
  }",3,db\skiplist_test.cc,leveldb.ConcurrentTest.State,,false,188,State,9
46300,TYPE_DECL,,,,_Test_ConcurrentWithoutThreads,1,db\skiplist_test.cc,leveldb._Test_ConcurrentWithoutThreads,SkipTest,false,288,_Test_ConcurrentWithoutThreads,14
46364,TYPE_DECL,,,,"class TestState {
 public:
  ConcurrentTest t_;
  int seed_;
  port::AtomicPointer quit_flag_;

  enum ReaderState {
    STARTING,
    RUNNING,
    DONE
  };

  explicit TestState(int s)
      : seed_(s),
        quit_flag_(NULL),
        state_(STARTING),
        state_cv_(&mu_) {}

  void Wait(ReaderState s) {
    mu_.Lock();
    while (state_ != s) {
      state_cv_.Wait();
    }
    mu_.Unlock();
  }

  void Change(ReaderState s) {
    mu_.Lock();
    state_ = s;
    state_cv_.Signal();
    mu_.Unlock();
  }

 private:
  port::Mutex mu_;
  ReaderState state_;
  port::CondVar state_cv_;
}",1,db\skiplist_test.cc,leveldb.TestState,,false,297,TestState,18
46368,TYPE_DECL,,,,"enum ReaderState {
    STARTING,
    RUNNING,
    DONE
  }",3,db\skiplist_test.cc,leveldb.TestState.ReaderState,,false,303,ReaderState,4
46583,TYPE_DECL,,,,_Test_Concurrent1,1,db\skiplist_test.cc,leveldb._Test_Concurrent1,SkipTest,false,368,_Test_Concurrent1,21
46618,TYPE_DECL,,,,_Test_Concurrent2,1,db\skiplist_test.cc,leveldb._Test_Concurrent2,SkipTest,false,369,_Test_Concurrent2,25
46653,TYPE_DECL,,,,_Test_Concurrent3,1,db\skiplist_test.cc,leveldb._Test_Concurrent3,SkipTest,false,370,_Test_Concurrent3,29
46688,TYPE_DECL,,,,_Test_Concurrent4,1,db\skiplist_test.cc,leveldb._Test_Concurrent4,SkipTest,false,371,_Test_Concurrent4,33
46723,TYPE_DECL,,,,_Test_Concurrent5,1,db\skiplist_test.cc,leveldb._Test_Concurrent5,SkipTest,false,372,_Test_Concurrent5,37
46777,TYPE_DECL,,db\snapshot.hpp:<global>,NAMESPACE_BLOCK,<global>,1,db\snapshot.hpp,db\snapshot.hpp:<global>,,false,1,<global>,3
46781,TYPE_DECL,,,,class SnapshotList,1,db\snapshot.hpp,leveldb.SnapshotList,,false,13,SnapshotList,1
46782,TYPE_DECL,,,,"class SnapshotImpl : public Snapshot {
 public:
  SequenceNumber number_;  // const after creation

 private:
  friend class SnapshotList;

  // SnapshotImpl is kept in a doubly-linked circular list
  SnapshotImpl* prev_;
  SnapshotImpl* next_;

  SnapshotList* list_;                 // just for sanity checks
}",1,db\snapshot.hpp,leveldb.SnapshotImpl,Snapshot,false,17,SnapshotImpl,2
46784,TYPE_DECL,,,,friend class SnapshotList,3,db\snapshot.hpp,leveldb.SnapshotImpl.SnapshotList,,false,22,SnapshotList,2
46788,TYPE_DECL,,,,"class SnapshotList {
 public:
  SnapshotList() {
    list_.prev_ = &list_;
    list_.next_ = &list_;
  }

  bool empty() const { return list_.next_ == &list_; }
  SnapshotImpl* oldest() const { assert(!empty()); return list_.next_; }
  SnapshotImpl* newest() const { assert(!empty()); return list_.prev_; }

  const SnapshotImpl* New(SequenceNumber seq) {
    SnapshotImpl* s = new SnapshotImpl;
    s->number_ = seq;
    s->list_ = this;
    s->next_ = &list_;
    s->prev_ = list_.prev_;
    s->prev_->next_ = s;
    s->next_->prev_ = s;
    return s;
  }

  void Delete(const SnapshotImpl* s) {
    assert(s->list_ == this);
    s->prev_->next_ = s->next_;
    s->next_->prev_ = s->prev_;
    delete s;
  }

 private:
  // Dummy head of doubly-linked list of snapshots
  SnapshotImpl list_;
}",1,db\snapshot.hpp,leveldb.SnapshotList,,false,31,SnapshotList,3
46931,TYPE_DECL,,db\table_cache.cc:<global>,NAMESPACE_BLOCK,<global>,1,db\table_cache.cc,db\table_cache.cc:<global>,,false,1,<global>,6
46935,TYPE_DECL,,,,"struct TableAndFile {
  RandomAccessFile* file;
  Table* table;
}",1,db\table_cache.cc,leveldb.TableAndFile,,false,14,TableAndFile,1
47309,TYPE_DECL,,db\table_cache.hpp:<global>,NAMESPACE_BLOCK,<global>,1,db\table_cache.hpp,db\table_cache.hpp:<global>,,false,1,<global>,7
47313,TYPE_DECL,,,,class Env,1,db\table_cache.hpp,leveldb.Env,,false,19,Env,1
47314,TYPE_DECL,,,,"class TableCache {
 public:
  TableCache(const std::string& dbname, const Options* options, int entries);
  ~TableCache();

  // Return an iterator for the specified file number (the corresponding
  // file length must be exactly ""file_size"" bytes).  If ""tableptr"" is
  // non-NULL, also sets ""*tableptr"" to point to the Table object
  // underlying the returned iterator, or NULL if no Table object underlies
  // the returned iterator.  The returned ""*tableptr"" object is owned by
  // the cache and should not be deleted, and is valid for as long as the
  // returned iterator is live.
  Iterator* NewIterator(const ReadOptions& options,
                        uint64_t file_number,
                        uint64_t file_size,
                        Table** tableptr = NULL);

  // If a seek to internal key ""k"" in specified file finds an entry,
  // call (*handle_result)(arg, found_key, found_value).
  Status Get(const ReadOptions& options,
             uint64_t file_number,
             ...",1,db\table_cache.hpp,leveldb.TableCache,,false,21,TableCache,2
47368,TYPE_DECL,,db\version_edit.cc:<global>,NAMESPACE_BLOCK,<global>,1,db\version_edit.cc,db\version_edit.cc:<global>,,false,1,<global>,4
47372,TYPE_DECL,,,,"enum Tag {
  kComparator           = 1,
  kLogNumber            = 2,
  kNextFileNumber       = 3,
  kLastSequence         = 4,
  kCompactPointer       = 5,
  kDeletedFile          = 6,
  kNewFile              = 7,
  // 8 was used for large value refs
  kPrevLogNumber        = 9
}",1,db\version_edit.cc,leveldb.Tag,,false,14,Tag,1
48225,TYPE_DECL,,db\version_edit.hpp:<global>,NAMESPACE_BLOCK,<global>,1,db\version_edit.hpp,db\version_edit.hpp:<global>,,false,1,<global>,5
48229,TYPE_DECL,,,,class VersionSet,1,db\version_edit.hpp,leveldb.VersionSet,,false,15,VersionSet,1
48230,TYPE_DECL,,,,"struct FileMetaData {
  int refs;
  int allowed_seeks;          // Seeks allowed until compaction
  uint64_t number;
  uint64_t file_size;         // File size in bytes
  InternalKey smallest;       // Smallest internal key served by table
  InternalKey largest;        // Largest internal key served by table

  FileMetaData() : refs(0), allowed_seeks(1 << 30), file_size(0) { }
}",1,db\version_edit.hpp,leveldb.FileMetaData,,false,17,FileMetaData,2
48241,TYPE_DECL,,,,"class VersionEdit {
 public:
  VersionEdit() { Clear(); }
  ~VersionEdit() { }

  void Clear();

  void SetComparatorName(const Slice& name) {
    has_comparator_ = true;
    comparator_ = name.ToString();
  }
  void SetLogNumber(uint64_t num) {
    has_log_number_ = true;
    log_number_ = num;
  }
  void SetPrevLogNumber(uint64_t num) {
    has_prev_log_number_ = true;
    prev_log_number_ = num;
  }
  void SetNextFile(uint64_t num) {
    has_next_file_number_ = true;
    next_file_number_ = num;
  }
  void SetLastSequence(SequenceNumber seq) {
    has_last_sequence_ = true;
    last_sequence_ = seq;
  }
  void SetCompactPointer(int level, const InternalKey& key) {
    compact_pointers_.push_back(std::make_pair(level, key));
  }

  // Add the specified file at the specified number.
  // REQUIRES: This version has not been saved (see VersionSet::SaveTo)
  // REQUIRES: ""smallest"" and ""largest"" are smallest and largest keys in file
  void AddFile(int level, uint64_t file,
           ...",1,db\version_edit.hpp,leveldb.VersionEdit,,false,28,VersionEdit,3
48399,TYPE_DECL,,,,friend class VersionSet,3,db\version_edit.hpp,leveldb.VersionEdit.VersionSet,,false,85,VersionSet,15
48400,TYPE_DECL,ANY,,,"typedef std::set< std::pair<int, uint64_t> > DeletedFileSet;",48,db\version_edit.hpp,DeletedFileSet,,false,87,DeletedFileSet,16
48420,TYPE_DECL,,db\version_edit_test.cc:<global>,NAMESPACE_BLOCK,<global>,1,db\version_edit_test.cc,db\version_edit_test.cc:<global>,,false,1,<global>,3
48496,TYPE_DECL,,,,class VersionEditTest { },1,db\version_edit_test.cc,leveldb.VersionEditTest,,false,20,VersionEditTest,2
48497,TYPE_DECL,,,,_Test_EncodeDecode,1,db\version_edit_test.cc,leveldb._Test_EncodeDecode,VersionEditTest,false,22,_Test_EncodeDecode,3
48676,TYPE_DECL,,db\version_set.cc:<global>,NAMESPACE_BLOCK,<global>,1,db\version_set.cc,db\version_set.cc:<global>,,false,1,<global>,15
49067,TYPE_DECL,,,,"class Version::LevelFileNumIterator : public Iterator {
 public:
  LevelFileNumIterator(const InternalKeyComparator& icmp,
                       const std::vector<FileMetaData*>* flist)
      : icmp_(icmp),
        flist_(flist),
        index_(flist->size()) {        // Marks as invalid
  }
  virtual bool Valid() const {
    return index_ < flist_->size();
  }
  virtual void Seek(const Slice& target) {
    index_ = FindFile(icmp_, *flist_, target);
  }
  virtual void SeekToFirst() { index_ = 0; }
  virtual void SeekToLast() {
    index_ = flist_->empty() ? 0 : flist_->size() - 1;
  }
  virtual void Next() {
    assert(Valid());
    index_++;
  }
  virtual void Prev() {
    assert(Valid());
    if (index_ == 0) {
      index_ = flist_->size();  // Marks as invalid
    } else {
      index_--;
    }
  }
  Slice key() const {
    assert(Valid());
    return (*flist_)[index_]->largest.Encode();
  }
  Slice value() const {
    assert(Valid());
    EncodeFixed64(value_buf_, (*flist_)[in...",1,db\version_set.cc,leveldb.LevelFileNumIterator,Iterator,false,163,LevelFileNumIterator,12
49365,TYPE_DECL,,,,"enum SaverState {
  kNotFound,
  kFound,
  kDeleted,
  kCorrupt,
}",1,db\version_set.cc,leveldb.anonymous_namespace_1.SaverState,,false,255,SaverState,1
49370,TYPE_DECL,,,,"struct Saver {
  SaverState state;
  const Comparator* ucmp;
  Slice user_key;
  std::string* value;
}",1,db\version_set.cc,leveldb.anonymous_namespace_2.Saver,,false,261,Saver,2
50598,TYPE_DECL,,,,"class VersionSet::Builder {
 private:
  // Helper to sort by v->files_[file_number].smallest
  struct BySmallestKey {
    const InternalKeyComparator* internal_comparator;

    bool operator()(FileMetaData* f1, FileMetaData* f2) const {
      int r = internal_comparator->Compare(f1->smallest, f2->smallest);
      if (r != 0) {
        return (r < 0);
      } else {
        // Break ties by file number
        return (f1->number < f2->number);
      }
    }
  };

  typedef std::set<FileMetaData*, BySmallestKey> FileSet;
  struct LevelState {
    std::set<uint64_t> deleted_files;
    FileSet* added_files;
  };

  VersionSet* vset_;
  Version* base_;
  LevelState levels_[config::kNumLevels];

 public:
  // Initialize a builder with the files from *base and other info from *vset
  Builder(VersionSet* vset, Version* base)
      : vset_(vset),
        base_(base) {
    base_->Ref();
    BySmallestKey cmp;
    cmp.internal_comparator = &vset_->icmp_;
    for (int level = 0; level < config:...",1,db\version_set.cc,leveldb.Builder,,false,603,Builder,29
50599,TYPE_DECL,,,,"struct BySmallestKey {
    const InternalKeyComparator* internal_comparator;

    bool operator()(FileMetaData* f1, FileMetaData* f2) const {
      int r = internal_comparator->Compare(f1->smallest, f2->smallest);
      if (r != 0) {
        return (r < 0);
      } else {
        // Break ties by file number
        return (f1->number < f2->number);
      }
    }
  }",3,db\version_set.cc,leveldb.Builder.BySmallestKey,,false,606,BySmallestKey,1
50639,TYPE_DECL,ANY,,,"typedef std::set<FileMetaData*, BySmallestKey> FileSet;",50,db\version_set.cc,FileSet,,false,620,FileSet,2
50640,TYPE_DECL,,,,"struct LevelState {
    std::set<uint64_t> deleted_files;
    FileSet* added_files;
  }",3,db\version_set.cc,leveldb.Builder.LevelState,,false,621,LevelState,3
54006,TYPE_DECL,,db\version_set.hpp:<global>,NAMESPACE_BLOCK,<global>,1,db\version_set.hpp,db\version_set.hpp:<global>,,false,1,<global>,8
54011,TYPE_DECL,,,,class Writer,17,db\version_set.hpp,leveldb.log.Writer,,false,28,Writer,1
54012,TYPE_DECL,,,,class Compaction,1,db\version_set.hpp,leveldb.Compaction,,false,30,Compaction,2
54013,TYPE_DECL,,,,class Iterator,1,db\version_set.hpp,leveldb.Iterator,,false,31,Iterator,3
54014,TYPE_DECL,,,,class MemTable,1,db\version_set.hpp,leveldb.MemTable,,false,32,MemTable,4
54015,TYPE_DECL,,,,class TableBuilder,1,db\version_set.hpp,leveldb.TableBuilder,,false,33,TableBuilder,5
54016,TYPE_DECL,,,,class TableCache,1,db\version_set.hpp,leveldb.TableCache,,false,34,TableCache,6
54017,TYPE_DECL,,,,class Version,1,db\version_set.hpp,leveldb.Version,,false,35,Version,7
54018,TYPE_DECL,,,,class VersionSet,1,db\version_set.hpp,leveldb.VersionSet,,false,36,VersionSet,8
54019,TYPE_DECL,,,,class WritableFile,1,db\version_set.hpp,leveldb.WritableFile,,false,37,WritableFile,9
54036,TYPE_DECL,,,,"class Version {
 public:
  // Append to *iters a sequence of iterators that will
  // yield the contents of this Version when merged together.
  // REQUIRES: This version has been saved (see VersionSet::SaveTo)
  void AddIterators(const ReadOptions&, std::vector<Iterator*>* iters);

  // Lookup the value for key.  If found, store it in *val and
  // return OK.  Else return a non-OK status.  Fills *stats.
  // REQUIRES: lock is not held
  struct GetStats {
    FileMetaData* seek_file;
    int seek_file_level;
  };
  Status Get(const ReadOptions&, const LookupKey& key, std::string* val,
             GetStats* stats);

  // Adds ""stats"" into the current state.  Returns true if a new
  // compaction may need to be triggered, false otherwise.
  // REQUIRES: lock is held
  bool UpdateStats(const GetStats& stats);

  // Record a sample of bytes read at the specified internal key.
  // Samples are taken approximately once every config::kReadBytesPeriod
  // bytes.  Returns true if a new com...",1,db\version_set.hpp,leveldb.Version,,false,59,Version,12
54043,TYPE_DECL,,,,"struct GetStats {
    FileMetaData* seek_file;
    int seek_file_level;
  }",3,db\version_set.hpp,leveldb.Version.GetStats,,false,69,GetStats,2
54109,TYPE_DECL,,,,friend class Compaction,3,db\version_set.hpp,leveldb.Version.Compaction,,false,117,Compaction,13
54110,TYPE_DECL,,,,friend class VersionSet,3,db\version_set.hpp,leveldb.Version.VersionSet,,false,118,VersionSet,14
54111,TYPE_DECL,,,,class LevelFileNumIterator,3,db\version_set.hpp,leveldb.Version.LevelFileNumIterator,,false,120,LevelFileNumIterator,15
54162,TYPE_DECL,,,,"class VersionSet {
 public:
  VersionSet(const std::string& dbname,
             const Options* options,
             TableCache* table_cache,
             const InternalKeyComparator*);
  ~VersionSet();

  // Apply *edit to the current version to form a new descriptor that
  // is both saved to persistent state and installed as the new
  // current version.  Will release *mu while actually writing to the file.
  // REQUIRES: *mu is held on entry.
  // REQUIRES: no other thread concurrently calls LogAndApply()
  Status LogAndApply(VersionEdit* edit, port::Mutex* mu)
      EXCLUSIVE_LOCKS_REQUIRED(mu);

  // Recover the last saved descriptor from persistent storage.
  Status Recover(bool *save_manifest);

  // Return the current version.
  Version* current() const { return current_; }

  // Return the current manifest file number
  uint64_t ManifestFileNumber() const { return manifest_file_number_; }

  // Allocate and return a new file number
  uint64_t NewFileNumber() { return next...",1,db\version_set.hpp,leveldb.VersionSet,,false,165,VersionSet,13
54316,TYPE_DECL,,,,"struct LevelSummaryStorage {
    char buffer[100];
  }",3,db\version_set.hpp,leveldb.VersionSet.LevelSummaryStorage,,false,266,LevelSummaryStorage,23
54329,TYPE_DECL,,,,class Builder,3,db\version_set.hpp,leveldb.VersionSet.Builder,,false,272,Builder,25
54330,TYPE_DECL,,,,friend class Compaction,3,db\version_set.hpp,leveldb.VersionSet.Compaction,,false,274,Compaction,26
54331,TYPE_DECL,,,,friend class Version,3,db\version_set.hpp,leveldb.VersionSet.Version,,false,275,Version,27
54406,TYPE_DECL,,,,"class Compaction {
 public:
  ~Compaction();

  // Return the level that is being compacted.  Inputs from ""level""
  // and ""level+1"" will be merged to produce a set of ""level+1"" files.
  int level() const { return level_; }

  // Return the object that holds the edits to the descriptor done
  // by this compaction.
  VersionEdit* edit() { return &edit_; }

  // ""which"" must be either 0 or 1
  int num_input_files(int which) const { return inputs_[which].size(); }

  // Return the ith input file at ""level()+which"" (""which"" must be 0 or 1).
  FileMetaData* input(int which, int i) const { return inputs_[which][i]; }

  // Maximum size of files to build during this compaction.
  uint64_t MaxOutputFileSize() const { return max_output_file_size_; }

  // Is this a trivial compaction that can be implemented by just
  // moving a single input file to the next level (no merging or splitting)
  bool IsTrivialMove() const;

  // Add all inputs to this compaction as delete operations to *edit.
 ...",1,db\version_set.hpp,leveldb.Compaction,,false,324,Compaction,14
54477,TYPE_DECL,,,,friend class Version,3,db\version_set.hpp,leveldb.Compaction.Version,,false,366,Version,12
54478,TYPE_DECL,,,,friend class VersionSet,3,db\version_set.hpp,leveldb.Compaction.VersionSet,,false,367,VersionSet,13
54515,TYPE_DECL,,db\version_set_test.cc:<global>,NAMESPACE_BLOCK,<global>,1,db\version_set_test.cc,db\version_set_test.cc:<global>,,false,1,<global>,5
54519,TYPE_DECL,,,,"class FindFileTest {
 public:
  std::vector<FileMetaData*> files_;
  bool disjoint_sorted_files_;

  FindFileTest() : disjoint_sorted_files_(true) { }

  ~FindFileTest() {
    for (int i = 0; i < files_.size(); i++) {
      delete files_[i];
    }
  }

  void Add(const char* smallest, const char* largest,
           SequenceNumber smallest_seq = 100,
           SequenceNumber largest_seq = 100) {
    FileMetaData* f = new FileMetaData;
    f->number = files_.size() + 1;
    f->smallest = InternalKey(smallest, smallest_seq, kTypeValue);
    f->largest = InternalKey(largest, largest_seq, kTypeValue);
    files_.push_back(f);
  }

  int Find(const char* key) {
    InternalKey target(key, 100, kTypeValue);
    InternalKeyComparator cmp(BytewiseComparator());
    return FindFile(cmp, files_, target.Encode());
  }

  bool Overlaps(const char* smallest, const char* largest) {
    InternalKeyComparator cmp(BytewiseComparator());
    Slice s(smallest != NULL ? smallest : """");
    Slice l(lar...",1,db\version_set_test.cc,leveldb.FindFileTest,,false,12,FindFileTest,1
54658,TYPE_DECL,,,,_Test_Empty,1,db\version_set_test.cc,leveldb._Test_Empty,FindFileTest,false,51,_Test_Empty,2
54782,TYPE_DECL,,,,_Test_Single,1,db\version_set_test.cc,leveldb._Test_Single,FindFileTest,false,59,_Test_Single,6
55242,TYPE_DECL,,,,_Test_Multiple,1,db\version_set_test.cc,leveldb._Test_Multiple,FindFileTest,false,90,_Test_Multiple,10
55818,TYPE_DECL,,,,_Test_MultipleNullBoundaries,1,db\version_set_test.cc,leveldb._Test_MultipleNullBoundaries,FindFileTest,false,128,_Test_MultipleNullBoundaries,14
56086,TYPE_DECL,,,,_Test_OverlapSequenceChecks,1,db\version_set_test.cc,leveldb._Test_OverlapSequenceChecks,FindFileTest,false,148,_Test_OverlapSequenceChecks,18
56211,TYPE_DECL,,,,_Test_OverlappingFiles,1,db\version_set_test.cc,leveldb._Test_OverlappingFiles,FindFileTest,false,157,_Test_OverlappingFiles,22
56486,TYPE_DECL,,db\write_batch.cc:<global>,NAMESPACE_BLOCK,<global>,1,db\write_batch.cc,db\write_batch.cc:<global>,,false,1,<global>,7
56777,TYPE_DECL,,,,"class MemTableInserter : public WriteBatch::Handler {
 public:
  SequenceNumber sequence_;
  MemTable* mem_;

  virtual void Put(const Slice& key, const Slice& value) {
    mem_->Add(sequence_, kTypeValue, key, value);
    sequence_++;
  }
  virtual void Delete(const Slice& key) {
    mem_->Add(sequence_, kTypeDeletion, key, Slice());
    sequence_++;
  }
}",1,db\write_batch.cc,leveldb.anonymous_namespace_1.MemTableInserter,WriteBatch.Handler,false,112,MemTableInserter,1
56916,TYPE_DECL,,db\write_batch_internal.hpp:<global>,NAMESPACE_BLOCK,<global>,1,db\write_batch_internal.hpp,db\write_batch_internal.hpp:<global>,,false,1,<global>,3
56920,TYPE_DECL,,,,class MemTable,1,db\write_batch_internal.hpp,leveldb.MemTable,,false,13,MemTable,1
56921,TYPE_DECL,,,,"class WriteBatchInternal {
 public:
  // Return the number of entries in the batch.
  static int Count(const WriteBatch* batch);

  // Set the count for the number of entries in the batch.
  static void SetCount(WriteBatch* batch, int n);

  // Return the sequence number for the start of this batch.
  static SequenceNumber Sequence(const WriteBatch* batch);

  // Store the specified number as the sequence number for the start of
  // this batch.
  static void SetSequence(WriteBatch* batch, SequenceNumber seq);

  static Slice Contents(const WriteBatch* batch) {
    return Slice(batch->rep_);
  }

  static size_t ByteSize(const WriteBatch* batch) {
    return batch->rep_.size();
  }

  static void SetContents(WriteBatch* batch, const Slice& contents);

  static Status InsertInto(const WriteBatch* batch, MemTable* memtable);

  static void Append(WriteBatch* dst, const WriteBatch* src);
}",1,db\write_batch_internal.hpp,leveldb.WriteBatchInternal,,false,17,WriteBatchInternal,2
56998,TYPE_DECL,,db\write_batch_test.cc:<global>,NAMESPACE_BLOCK,<global>,1,db\write_batch_test.cc,db\write_batch_test.cc:<global>,,false,1,<global>,7
57198,TYPE_DECL,,,,class WriteBatchTest { },1,db\write_batch_test.cc,leveldb.WriteBatchTest,,false,55,WriteBatchTest,2
57199,TYPE_DECL,,,,_Test_Empty,1,db\write_batch_test.cc,leveldb._Test_Empty,WriteBatchTest,false,57,_Test_Empty,3
57281,TYPE_DECL,,,,_Test_Multiple,1,db\write_batch_test.cc,leveldb._Test_Multiple,WriteBatchTest,false,63,_Test_Multiple,7
57418,TYPE_DECL,,,,_Test_Corruption,1,db\write_batch_test.cc,leveldb._Test_Corruption,WriteBatchTest,false,77,_Test_Corruption,11
57519,TYPE_DECL,,,,_Test_Append,1,db\write_batch_test.cc,leveldb._Test_Append,WriteBatchTest,false,90,_Test_Append,15
57729,TYPE_DECL,,doc\bench\db_bench_sqlite3.cc:<global>,NAMESPACE_BLOCK,<global>,1,doc\bench\db_bench_sqlite3.cc,doc\bench\db_bench_sqlite3.cc:<global>,,false,1,<global>,7
57848,TYPE_DECL,,,,"class RandomGenerator {
 private:
  std::string data_;
  int pos_;

 public:
  RandomGenerator() {
    // We use a limited amount of data over and over again and ensure
    // that it is larger than the compression window (32KB), and also
    // large enough to serve all typical value sizes we want to write.
    Random rnd(301);
    std::string piece;
    while (data_.size() < 1048576) {
      // Add a short fragment that is as compressible as specified
      // by FLAGS_compression_ratio.
      test::CompressibleString(&rnd, FLAGS_compression_ratio, 100, &piece);
      data_.append(piece);
    }
    pos_ = 0;
  }

  Slice Generate(int len) {
    if (pos_ + len > data_.size()) {
      pos_ = 0;
      assert(len < data_.size());
    }
    pos_ += len;
    return Slice(data_.data() + pos_ - len, len);
  }
}",1,doc\bench\db_bench_sqlite3.cc,leveldb.anonymous_namespace_1.RandomGenerator,,false,118,RandomGenerator,1
57980,TYPE_DECL,,,,"class Benchmark {
 private:
  sqlite3* db_;
  int db_num_;
  int num_;
  int reads_;
  double start_;
  double last_op_finish_;
  int64_t bytes_;
  std::string message_;
  Histogram hist_;
  RandomGenerator gen_;
  Random rand_;

  // State kept for progress messages
  int done_;
  int next_report_;     // When to report next

  void PrintHeader() {
    const int kKeySize = 16;
    PrintEnvironment();
    fprintf(stdout, ""Keys:       %d bytes each\n"", kKeySize);
    fprintf(stdout, ""Values:     %d bytes each\n"", FLAGS_value_size);
    fprintf(stdout, ""Entries:    %d\n"", num_);
    fprintf(stdout, ""RawSize:    %.1f MB (estimated)\n"",
            ((static_cast<int64_t>(kKeySize + FLAGS_value_size) * num_)
             / 1048576.0));
    PrintWarnings();
    fprintf(stdout, ""------------------------------------------------\n"");
  }

  void PrintWarnings() {
#if defined(__GNUC__) && !defined(__OPTIMIZE__)
    fprintf(stdout,
            ""WARNING: Optimization is disabled: benchmarks unn...",1,doc\bench\db_bench_sqlite3.cc,leveldb.Benchmark,,false,163,Benchmark,2
58311,TYPE_DECL,,,,"enum Order {
    SEQUENTIAL,
    RANDOM
  }",3,doc\bench\db_bench_sqlite3.cc,leveldb.Benchmark.Order,,false,306,Order,20
58314,TYPE_DECL,,,,"enum DBState {
    FRESH,
    EXISTING
  }",3,doc\bench\db_bench_sqlite3.cc,leveldb.Benchmark.DBState,,false,310,DBState,21
59791,TYPE_DECL,,doc\bench\db_bench_tree_db.cc:<global>,NAMESPACE_BLOCK,<global>,1,doc\bench\db_bench_tree_db.cc,doc\bench\db_bench_tree_db.cc:<global>,,false,1,<global>,7
59863,TYPE_DECL,,,,"class RandomGenerator {
 private:
  std::string data_;
  int pos_;

 public:
  RandomGenerator() {
    // We use a limited amount of data over and over again and ensure
    // that it is larger than the compression window (32KB), and also
    // large enough to serve all typical value sizes we want to write.
    Random rnd(301);
    std::string piece;
    while (data_.size() < 1048576) {
      // Add a short fragment that is as compressible as specified
      // by FLAGS_compression_ratio.
      test::CompressibleString(&rnd, FLAGS_compression_ratio, 100, &piece);
      data_.append(piece);
    }
    pos_ = 0;
  }

  Slice Generate(int len) {
    if (pos_ + len > data_.size()) {
      pos_ = 0;
      assert(len < data_.size());
    }
    pos_ += len;
    return Slice(data_.data() + pos_ - len, len);
  }
}",1,doc\bench\db_bench_tree_db.cc,leveldb.anonymous_namespace_1.RandomGenerator,,false,87,RandomGenerator,1
59995,TYPE_DECL,,,,"class Benchmark {
 private:
  kyotocabinet::TreeDB* db_;
  int db_num_;
  int num_;
  int reads_;
  double start_;
  double last_op_finish_;
  int64_t bytes_;
  std::string message_;
  Histogram hist_;
  RandomGenerator gen_;
  Random rand_;
  kyotocabinet::LZOCompressor<kyotocabinet::LZO::RAW> comp_;

  // State kept for progress messages
  int done_;
  int next_report_;     // When to report next

  void PrintHeader() {
    const int kKeySize = 16;
    PrintEnvironment();
    fprintf(stdout, ""Keys:       %d bytes each\n"", kKeySize);
    fprintf(stdout, ""Values:     %d bytes each (%d bytes after compression)\n"",
            FLAGS_value_size,
            static_cast<int>(FLAGS_value_size * FLAGS_compression_ratio + 0.5));
    fprintf(stdout, ""Entries:    %d\n"", num_);
    fprintf(stdout, ""RawSize:    %.1f MB (estimated)\n"",
            ((static_cast<int64_t>(kKeySize + FLAGS_value_size) * num_)
             / 1048576.0));
    fprintf(stdout, ""FileSize:   %.1f MB (estimated)\n"",
    ...",1,doc\bench\db_bench_tree_db.cc,leveldb.Benchmark,,false,132,Benchmark,2
60354,TYPE_DECL,,,,"enum Order {
    SEQUENTIAL,
    RANDOM
  }",3,doc\bench\db_bench_tree_db.cc,leveldb.Benchmark.Order,,false,282,Order,21
60357,TYPE_DECL,,,,"enum DBState {
    FRESH,
    EXISTING
  }",3,doc\bench\db_bench_tree_db.cc,leveldb.Benchmark.DBState,,false,286,DBState,22
61359,TYPE_DECL,,helpers\memenv\memenv.cc:<global>,NAMESPACE_BLOCK,<global>,1,helpers\memenv\memenv.cc,helpers\memenv\memenv.cc:<global>,,false,1,<global>,10
61364,TYPE_DECL,,,,"class FileState {
 public:
  // FileStates are reference counted. The initial reference count is zero
  // and the caller must call Ref() at least once.
  FileState() : refs_(0), size_(0) {}

  // Increase the reference count.
  void Ref() {
    MutexLock lock(&refs_mutex_);
    ++refs_;
  }

  // Decrease the reference count. Delete if this is the last reference.
  void Unref() {
    bool do_delete = false;

    {
      MutexLock lock(&refs_mutex_);
      --refs_;
      assert(refs_ >= 0);
      if (refs_ <= 0) {
        do_delete = true;
      }
    }

    if (do_delete) {
      delete this;
    }
  }

  uint64_t Size() const { return size_; }

  Status Read(uint64_t offset, size_t n, Slice* result, char* scratch) const {
    if (offset > size_) {
      return Status::IOError(""Offset greater than file size."");
    }
    const uint64_t available = size_ - offset;
    if (n > available) {
      n = static_cast<size_t>(available);
    }
    if (n == 0) {
      *result = Slice();
    ...",1,helpers\memenv\memenv.cc,leveldb.anonymous_namespace_1.FileState,,false,20,FileState,1
61687,TYPE_DECL,,,,enum { kBlockSize = 8 * 1024 },3,helpers\memenv\memenv.cc,leveldb.anonymous_namespace_11.FileState.anonymous_enum_12,,false,146,anonymous_enum_12,14
61698,TYPE_DECL,,,,"class SequentialFileImpl : public SequentialFile {
 public:
  explicit SequentialFileImpl(FileState* file) : file_(file), pos_(0) {
    file_->Ref();
  }

  ~SequentialFileImpl() {
    file_->Unref();
  }

  virtual Status Read(size_t n, Slice* result, char* scratch) {
    Status s = file_->Read(pos_, n, result, scratch);
    if (s.ok()) {
      pos_ += result->size();
    }
    return s;
  }

  virtual Status Skip(uint64_t n) {
    if (pos_ > file_->Size()) {
      return Status::IOError(""pos_ > file_->Size()"");
    }
    const uint64_t available = file_->Size() - pos_;
    if (n > available) {
      n = available;
    }
    pos_ += n;
    return Status::OK();
  }

 private:
  FileState* file_;
  uint64_t pos_;
}",1,helpers\memenv\memenv.cc,leveldb.anonymous_namespace_13.SequentialFileImpl,SequentialFile,false,149,SequentialFileImpl,2
61794,TYPE_DECL,,,,"class RandomAccessFileImpl : public RandomAccessFile {
 public:
  explicit RandomAccessFileImpl(FileState* file) : file_(file) {
    file_->Ref();
  }

  ~RandomAccessFileImpl() {
    file_->Unref();
  }

  virtual Status Read(uint64_t offset, size_t n, Slice* result,
                      char* scratch) const {
    return file_->Read(offset, n, result, scratch);
  }

 private:
  FileState* file_;
}",1,helpers\memenv\memenv.cc,leveldb.anonymous_namespace_18.RandomAccessFileImpl,RandomAccessFile,false,184,RandomAccessFileImpl,3
61830,TYPE_DECL,,,,"class WritableFileImpl : public WritableFile {
 public:
  WritableFileImpl(FileState* file) : file_(file) {
    file_->Ref();
  }

  ~WritableFileImpl() {
    file_->Unref();
  }

  virtual Status Append(const Slice& data) {
    return file_->Append(data);
  }

  virtual Status Close() { return Status::OK(); }
  virtual Status Flush() { return Status::OK(); }
  virtual Status Sync() { return Status::OK(); }

 private:
  FileState* file_;
}",1,helpers\memenv\memenv.cc,leveldb.anonymous_namespace_22.WritableFileImpl,WritableFile,false,203,WritableFileImpl,4
61887,TYPE_DECL,,,,"class NoOpLogger : public Logger {
 public:
  virtual void Logv(const char* format, va_list ap) { }
}",1,helpers\memenv\memenv.cc,leveldb.anonymous_namespace_29.NoOpLogger,Logger,false,225,NoOpLogger,5
61894,TYPE_DECL,,,,"class InMemoryEnv : public EnvWrapper {
 public:
  explicit InMemoryEnv(Env* base_env) : EnvWrapper(base_env) { }

  virtual ~InMemoryEnv() {
    for (FileSystem::iterator i = file_map_.begin(); i != file_map_.end(); ++i){
      i->second->Unref();
    }
  }

  // Partial implementation of the Env interface.
  virtual Status NewSequentialFile(const std::string& fname,
                                   SequentialFile** result) {
    MutexLock lock(&mutex_);
    if (file_map_.find(fname) == file_map_.end()) {
      *result = NULL;
      return Status::IOError(fname, ""File not found"");
    }

    *result = new SequentialFileImpl(file_map_[fname]);
    return Status::OK();
  }

  virtual Status NewRandomAccessFile(const std::string& fname,
                                     RandomAccessFile** result) {
    MutexLock lock(&mutex_);
    if (file_map_.find(fname) == file_map_.end()) {
      *result = NULL;
      return Status::IOError(fname, ""File not found"");
    }

    *result = new R...",1,helpers\memenv\memenv.cc,leveldb.anonymous_namespace_31.InMemoryEnv,EnvWrapper,false,230,InMemoryEnv,6
62455,TYPE_DECL,ANY,,,"typedef std::map<std::string, FileState*> FileSystem;",45,helpers\memenv\memenv.cc,FileSystem,,false,387,FileSystem,19
62469,TYPE_DECL,,helpers\memenv\memenv.hpp:<global>,NAMESPACE_BLOCK,<global>,1,helpers\memenv\memenv.hpp,helpers\memenv\memenv.hpp:<global>,,false,1,<global>,1
62473,TYPE_DECL,,,,class Env,1,helpers\memenv\memenv.hpp,leveldb.Env,,false,10,Env,1
62495,TYPE_DECL,,helpers\memenv\memenv_test.cc:<global>,NAMESPACE_BLOCK,<global>,1,helpers\memenv\memenv_test.cc,helpers\memenv\memenv_test.cc:<global>,,false,1,<global>,8
62499,TYPE_DECL,,,,"class MemEnvTest {
 public:
  Env* env_;

  MemEnvTest()
      : env_(NewMemEnv(Env::Default())) {
  }
  ~MemEnvTest() {
    delete env_;
  }
}",1,helpers\memenv\memenv_test.cc,leveldb.MemEnvTest,,false,16,MemEnvTest,1
62511,TYPE_DECL,,,,_Test_Basics,1,helpers\memenv\memenv_test.cc,leveldb._Test_Basics,MemEnvTest,false,28,_Test_Basics,2
63385,TYPE_DECL,,,,_Test_ReadWrite,1,helpers\memenv\memenv_test.cc,leveldb._Test_ReadWrite,MemEnvTest,false,96,_Test_ReadWrite,6
63947,TYPE_DECL,,,,_Test_Locks,1,helpers\memenv\memenv_test.cc,leveldb._Test_Locks,MemEnvTest,false,138,_Test_Locks,10
64024,TYPE_DECL,,,,_Test_Misc,1,helpers\memenv\memenv_test.cc,leveldb._Test_Misc,MemEnvTest,false,146,_Test_Misc,14
64193,TYPE_DECL,,,,_Test_LargeWrite,1,helpers\memenv\memenv_test.cc,leveldb._Test_LargeWrite,MemEnvTest,false,161,_Test_LargeWrite,18
64467,TYPE_DECL,,,,_Test_DBTest,1,helpers\memenv\memenv_test.cc,leveldb._Test_DBTest,MemEnvTest,false,194,_Test_DBTest,22
64869,TYPE_DECL,,include\leveldb\c.hpp:<global>,NAMESPACE_BLOCK,<global>,1,include\leveldb\c.hpp,include\leveldb\c.hpp:<global>,,false,1,<global>,4
64872,TYPE_DECL,leveldb_t,,,typedef struct leveldb_t,1,include\leveldb\c.hpp,leveldb_t,,false,53,leveldb_t,1
64873,TYPE_DECL,leveldb_t,,,typedef struct leveldb_t               leveldb_t;,40,include\leveldb\c.hpp,leveldb_t,,false,53,leveldb_t,2
64874,TYPE_DECL,leveldb_cache_t,,,typedef struct leveldb_cache_t,1,include\leveldb\c.hpp,leveldb_cache_t,,false,54,leveldb_cache_t,3
64875,TYPE_DECL,leveldb_cache_t,,,typedef struct leveldb_cache_t         leveldb_cache_t;,40,include\leveldb\c.hpp,leveldb_cache_t,,false,54,leveldb_cache_t,4
64876,TYPE_DECL,leveldb_comparator_t,,,typedef struct leveldb_comparator_t,1,include\leveldb\c.hpp,leveldb_comparator_t,,false,55,leveldb_comparator_t,5
64877,TYPE_DECL,leveldb_comparator_t,,,typedef struct leveldb_comparator_t    leveldb_comparator_t;,40,include\leveldb\c.hpp,leveldb_comparator_t,,false,55,leveldb_comparator_t,6
64878,TYPE_DECL,leveldb_env_t,,,typedef struct leveldb_env_t,1,include\leveldb\c.hpp,leveldb_env_t,,false,56,leveldb_env_t,7
64879,TYPE_DECL,leveldb_env_t,,,typedef struct leveldb_env_t           leveldb_env_t;,40,include\leveldb\c.hpp,leveldb_env_t,,false,56,leveldb_env_t,8
64880,TYPE_DECL,leveldb_filelock_t,,,typedef struct leveldb_filelock_t,1,include\leveldb\c.hpp,leveldb_filelock_t,,false,57,leveldb_filelock_t,9
64881,TYPE_DECL,leveldb_filelock_t,,,typedef struct leveldb_filelock_t      leveldb_filelock_t;,40,include\leveldb\c.hpp,leveldb_filelock_t,,false,57,leveldb_filelock_t,10
64882,TYPE_DECL,leveldb_filterpolicy_t,,,typedef struct leveldb_filterpolicy_t,1,include\leveldb\c.hpp,leveldb_filterpolicy_t,,false,58,leveldb_filterpolicy_t,11
64883,TYPE_DECL,leveldb_filterpolicy_t,,,typedef struct leveldb_filterpolicy_t  leveldb_filterpolicy_t;,40,include\leveldb\c.hpp,leveldb_filterpolicy_t,,false,58,leveldb_filterpolicy_t,12
64884,TYPE_DECL,leveldb_iterator_t,,,typedef struct leveldb_iterator_t,1,include\leveldb\c.hpp,leveldb_iterator_t,,false,59,leveldb_iterator_t,13
64885,TYPE_DECL,leveldb_iterator_t,,,typedef struct leveldb_iterator_t      leveldb_iterator_t;,40,include\leveldb\c.hpp,leveldb_iterator_t,,false,59,leveldb_iterator_t,14
64886,TYPE_DECL,leveldb_logger_t,,,typedef struct leveldb_logger_t,1,include\leveldb\c.hpp,leveldb_logger_t,,false,60,leveldb_logger_t,15
64887,TYPE_DECL,leveldb_logger_t,,,typedef struct leveldb_logger_t        leveldb_logger_t;,40,include\leveldb\c.hpp,leveldb_logger_t,,false,60,leveldb_logger_t,16
64888,TYPE_DECL,leveldb_options_t,,,typedef struct leveldb_options_t,1,include\leveldb\c.hpp,leveldb_options_t,,false,61,leveldb_options_t,17
64889,TYPE_DECL,leveldb_options_t,,,typedef struct leveldb_options_t       leveldb_options_t;,40,include\leveldb\c.hpp,leveldb_options_t,,false,61,leveldb_options_t,18
64890,TYPE_DECL,leveldb_randomfile_t,,,typedef struct leveldb_randomfile_t,1,include\leveldb\c.hpp,leveldb_randomfile_t,,false,62,leveldb_randomfile_t,19
64891,TYPE_DECL,leveldb_randomfile_t,,,typedef struct leveldb_randomfile_t    leveldb_randomfile_t;,40,include\leveldb\c.hpp,leveldb_randomfile_t,,false,62,leveldb_randomfile_t,20
64892,TYPE_DECL,leveldb_readoptions_t,,,typedef struct leveldb_readoptions_t,1,include\leveldb\c.hpp,leveldb_readoptions_t,,false,63,leveldb_readoptions_t,21
64893,TYPE_DECL,leveldb_readoptions_t,,,typedef struct leveldb_readoptions_t   leveldb_readoptions_t;,40,include\leveldb\c.hpp,leveldb_readoptions_t,,false,63,leveldb_readoptions_t,22
64894,TYPE_DECL,leveldb_seqfile_t,,,typedef struct leveldb_seqfile_t,1,include\leveldb\c.hpp,leveldb_seqfile_t,,false,64,leveldb_seqfile_t,23
64895,TYPE_DECL,leveldb_seqfile_t,,,typedef struct leveldb_seqfile_t       leveldb_seqfile_t;,40,include\leveldb\c.hpp,leveldb_seqfile_t,,false,64,leveldb_seqfile_t,24
64896,TYPE_DECL,leveldb_snapshot_t,,,typedef struct leveldb_snapshot_t,1,include\leveldb\c.hpp,leveldb_snapshot_t,,false,65,leveldb_snapshot_t,25
64897,TYPE_DECL,leveldb_snapshot_t,,,typedef struct leveldb_snapshot_t      leveldb_snapshot_t;,40,include\leveldb\c.hpp,leveldb_snapshot_t,,false,65,leveldb_snapshot_t,26
64898,TYPE_DECL,leveldb_writablefile_t,,,typedef struct leveldb_writablefile_t,1,include\leveldb\c.hpp,leveldb_writablefile_t,,false,66,leveldb_writablefile_t,27
64899,TYPE_DECL,leveldb_writablefile_t,,,typedef struct leveldb_writablefile_t  leveldb_writablefile_t;,40,include\leveldb\c.hpp,leveldb_writablefile_t,,false,66,leveldb_writablefile_t,28
64900,TYPE_DECL,leveldb_writebatch_t,,,typedef struct leveldb_writebatch_t,1,include\leveldb\c.hpp,leveldb_writebatch_t,,false,67,leveldb_writebatch_t,29
64901,TYPE_DECL,leveldb_writebatch_t,,,typedef struct leveldb_writebatch_t    leveldb_writebatch_t;,40,include\leveldb\c.hpp,leveldb_writebatch_t,,false,67,leveldb_writebatch_t,30
64902,TYPE_DECL,leveldb_writeoptions_t,,,typedef struct leveldb_writeoptions_t,1,include\leveldb\c.hpp,leveldb_writeoptions_t,,false,68,leveldb_writeoptions_t,31
64903,TYPE_DECL,leveldb_writeoptions_t,,,typedef struct leveldb_writeoptions_t  leveldb_writeoptions_t;,40,include\leveldb\c.hpp,leveldb_writeoptions_t,,false,68,leveldb_writeoptions_t,32
65185,TYPE_DECL,,,,"enum {
  leveldb_no_compression = 0,
  leveldb_snappy_compression = 1
}",1,include\leveldb\c.hpp,anonymous_enum_0,,false,203,anonymous_enum_0,77
65316,TYPE_DECL,,include\leveldb\cache.hpp:<global>,NAMESPACE_BLOCK,<global>,1,include\leveldb\cache.hpp,include\leveldb\cache.hpp:<global>,,false,1,<global>,3
65320,TYPE_DECL,,,,class Cache,1,include\leveldb\cache.hpp,leveldb.Cache,,false,26,Cache,1
65326,TYPE_DECL,,,,"class Cache {
 public:
  Cache() { }

  // Destroys all existing entries by calling the ""deleter""
  // function that was passed to the constructor.
  virtual ~Cache();

  // Opaque handle to an entry stored in the cache.
  struct Handle { };

  // Insert a mapping from key->value into the cache and assign it
  // the specified charge against the total cache capacity.
  //
  // Returns a handle that corresponds to the mapping.  The caller
  // must call this->Release(handle) when the returned mapping is no
  // longer needed.
  //
  // When the inserted entry is no longer needed, the key and
  // value will be passed to ""deleter"".
  virtual Handle* Insert(const Slice& key, void* value, size_t charge,
                         void (*deleter)(const Slice& key, void* value)) = 0;

  // If the cache has no mapping for ""key"", returns NULL.
  //
  // Else return a handle that corresponds to the mapping.  The caller
  // must call this->Release(handle) when the returned mapping is no
  // l...",1,include\leveldb\cache.hpp,leveldb.Cache,,false,32,Cache,3
65335,TYPE_DECL,,,,struct Handle { },3,include\leveldb\cache.hpp,leveldb.Cache.Handle,,false,41,Handle,3
65391,TYPE_DECL,,,,struct Rep,3,include\leveldb\cache.hpp,leveldb.Cache.Rep,,false,100,Rep,15
65407,TYPE_DECL,,include\leveldb\comparator.hpp:<global>,NAMESPACE_BLOCK,<global>,1,include\leveldb\comparator.hpp,include\leveldb\comparator.hpp:<global>,,false,1,<global>,2
65411,TYPE_DECL,,,,class Slice,1,include\leveldb\comparator.hpp,leveldb.Slice,,false,12,Slice,1
65412,TYPE_DECL,,,,"class Comparator {
 public:
  virtual ~Comparator();

  // Three-way comparison.  Returns value:
  //   < 0 iff ""a"" < ""b"",
  //   == 0 iff ""a"" == ""b"",
  //   > 0 iff ""a"" > ""b""
  virtual int Compare(const Slice& a, const Slice& b) const = 0;

  // The name of the comparator.  Used to check for comparator
  // mismatches (i.e., a DB created with one comparator is
  // accessed using a different comparator.
  //
  // The client of this package should switch to a new name whenever
  // the comparator implementation changes in a way that will cause
  // the relative ordering of any two keys to change.
  //
  // Names starting with ""leveldb."" are reserved and should not be used
  // by any clients of this package.
  virtual const char* Name() const = 0;

  // Advanced functions: these are used to reduce the space requirements
  // for internal data structures like index blocks.

  // If *start < limit, changes *start to a short string in [start,limit).
  // Simple comparator implementatio...",1,include\leveldb\comparator.hpp,leveldb.Comparator,,false,18,Comparator,2
65452,TYPE_DECL,,include\leveldb\db.hpp:<global>,NAMESPACE_BLOCK,<global>,1,include\leveldb\db.hpp,include\leveldb\db.hpp:<global>,,false,1,<global>,5
65464,TYPE_DECL,,,,struct Options,1,include\leveldb\db.hpp,leveldb.Options,,false,19,Options,5
65465,TYPE_DECL,,,,struct ReadOptions,1,include\leveldb\db.hpp,leveldb.ReadOptions,,false,20,ReadOptions,6
65466,TYPE_DECL,,,,struct WriteOptions,1,include\leveldb\db.hpp,leveldb.WriteOptions,,false,21,WriteOptions,7
65467,TYPE_DECL,,,,class WriteBatch,1,include\leveldb\db.hpp,leveldb.WriteBatch,,false,22,WriteBatch,8
65468,TYPE_DECL,,,,"class Snapshot {
 protected:
  virtual ~Snapshot();
}",1,include\leveldb\db.hpp,leveldb.Snapshot,,false,27,Snapshot,9
65473,TYPE_DECL,,,,"struct Range {
  Slice start;          // Included in the range
  Slice limit;          // Not included in the range

  Range() { }
  Range(const Slice& s, const Slice& l) : start(s), limit(l) { }
}",1,include\leveldb\db.hpp,leveldb.Range,,false,33,Range,10
65486,TYPE_DECL,,,,"class DB {
 public:
  // Open the database with the specified ""name"".
  // Stores a pointer to a heap-allocated database in *dbptr and returns
  // OK on success.
  // Stores NULL in *dbptr and returns a non-OK status on error.
  // Caller should delete *dbptr when it is no longer needed.
  static Status Open(const Options& options,
                     const std::string& name,
                     DB** dbptr);

  DB() { }
  virtual ~DB();

  // Set the database entry for ""key"" to ""value"".  Returns OK on success,
  // and a non-OK status on error.
  // Note: consider setting options.sync = true.
  virtual Status Put(const WriteOptions& options,
                     const Slice& key,
                     const Slice& value) = 0;

  // Remove the database entry (if any) for ""key"".  Returns OK on
  // success, and a non-OK status on error.  It is not an error if ""key""
  // did not exist in the database.
  // Note: consider setting options.sync = true.
  virtual Status Delete(const Writ...",1,include\leveldb\db.hpp,leveldb.DB,,false,44,DB,11
65591,TYPE_DECL,,include\leveldb\dumpfile.hpp:<global>,NAMESPACE_BLOCK,<global>,1,include\leveldb\dumpfile.hpp,include\leveldb\dumpfile.hpp:<global>,,false,1,<global>,4
65614,TYPE_DECL,,include\leveldb\env.hpp:<global>,NAMESPACE_BLOCK,<global>,1,include\leveldb\env.hpp,include\leveldb\env.hpp:<global>,,false,1,<global>,6
65618,TYPE_DECL,,,,class FileLock,1,include\leveldb\env.hpp,leveldb.FileLock,,false,24,FileLock,1
65619,TYPE_DECL,,,,class Logger,1,include\leveldb\env.hpp,leveldb.Logger,,false,25,Logger,2
65620,TYPE_DECL,,,,class RandomAccessFile,1,include\leveldb\env.hpp,leveldb.RandomAccessFile,,false,26,RandomAccessFile,3
65621,TYPE_DECL,,,,class SequentialFile,1,include\leveldb\env.hpp,leveldb.SequentialFile,,false,27,SequentialFile,4
65622,TYPE_DECL,,,,class Slice,1,include\leveldb\env.hpp,leveldb.Slice,,false,28,Slice,5
65623,TYPE_DECL,,,,class WritableFile,1,include\leveldb\env.hpp,leveldb.WritableFile,,false,29,WritableFile,6
65624,TYPE_DECL,,,,"class Env {
 public:
  Env() { }
  virtual ~Env();

  // Return a default environment suitable for the current operating
  // system.  Sophisticated users may wish to provide their own Env
  // implementation instead of relying on this default environment.
  //
  // The result of Default() belongs to leveldb and must never be deleted.
  static Env* Default();

  // Create a brand new sequentially-readable file with the specified name.
  // On success, stores a pointer to the new file in *result and returns OK.
  // On failure stores NULL in *result and returns non-OK.  If the file does
  // not exist, returns a non-OK status.
  //
  // The returned file will only be accessed by one thread at a time.
  virtual Status NewSequentialFile(const std::string& fname,
                                   SequentialFile** result) = 0;

  // Create a brand new random access read-only file with the
  // specified name.  On success, stores a pointer to the new file in
  // *result and returns OK. ...",1,include\leveldb\env.hpp,leveldb.Env,,false,31,Env,7
65752,TYPE_DECL,,,,"class SequentialFile {
 public:
  SequentialFile() { }
  virtual ~SequentialFile();

  // Read up to ""n"" bytes from the file.  ""scratch[0..n-1]"" may be
  // written by this routine.  Sets ""*result"" to the data that was
  // read (including if fewer than ""n"" bytes were successfully read).
  // May set ""*result"" to point at data in ""scratch[0..n-1]"", so
  // ""scratch[0..n-1]"" must be live when ""*result"" is used.
  // If an error was encountered, returns a non-OK status.
  //
  // REQUIRES: External synchronization
  virtual Status Read(size_t n, Slice* result, char* scratch) = 0;

  // Skip ""n"" bytes from the file. This is guaranteed to be no
  // slower that reading the same data, but may be faster.
  //
  // If end of file is reached, skipping will stop at the end of the
  // file, and Skip will return OK.
  //
  // REQUIRES: External synchronization
  virtual Status Skip(uint64_t n) = 0;

 private:
  // No copying allowed
  SequentialFile(const SequentialFile&);
  void operator=(co...",1,include\leveldb\env.hpp,leveldb.SequentialFile,,false,170,SequentialFile,8
65783,TYPE_DECL,,,,"class RandomAccessFile {
 public:
  RandomAccessFile() { }
  virtual ~RandomAccessFile();

  // Read up to ""n"" bytes from the file starting at ""offset"".
  // ""scratch[0..n-1]"" may be written by this routine.  Sets ""*result""
  // to the data that was read (including if fewer than ""n"" bytes were
  // successfully read).  May set ""*result"" to point at data in
  // ""scratch[0..n-1]"", so ""scratch[0..n-1]"" must be live when
  // ""*result"" is used.  If an error was encountered, returns a non-OK
  // status.
  //
  // Safe for concurrent use by multiple threads.
  virtual Status Read(uint64_t offset, size_t n, Slice* result,
                      char* scratch) const = 0;

 private:
  // No copying allowed
  RandomAccessFile(const RandomAccessFile&);
  void operator=(const RandomAccessFile&);
}",1,include\leveldb\env.hpp,leveldb.RandomAccessFile,,false,201,RandomAccessFile,9
65810,TYPE_DECL,,,,"class WritableFile {
 public:
  WritableFile() { }
  virtual ~WritableFile();

  virtual Status Append(const Slice& data) = 0;
  virtual Status Close() = 0;
  virtual Status Flush() = 0;
  virtual Status Sync() = 0;

 private:
  // No copying allowed
  WritableFile(const WritableFile&);
  void operator=(const WritableFile&);
}",1,include\leveldb\env.hpp,leveldb.WritableFile,,false,227,WritableFile,10
65846,TYPE_DECL,,,,"class Logger {
 public:
  Logger() { }
  virtual ~Logger();

  // Write an entry to the log file with the specified format.
  virtual void Logv(const char* format, va_list ap) = 0;

 private:
  // No copying allowed
  Logger(const Logger&);
  void operator=(const Logger&);
}",1,include\leveldb\env.hpp,leveldb.Logger,,false,244,Logger,11
65871,TYPE_DECL,,,,"class FileLock {
 public:
  FileLock() { }
  virtual ~FileLock();
 private:
  // No copying allowed
  FileLock(const FileLock&);
  void operator=(const FileLock&);
}",1,include\leveldb\env.hpp,leveldb.FileLock,,false,260,FileLock,12
65910,TYPE_DECL,,,,"class EnvWrapper : public Env {
 public:
  // Initialize an EnvWrapper that delegates all calls to *t
  explicit EnvWrapper(Env* t) : target_(t) { }
  virtual ~EnvWrapper();

  // Return the target to which this Env forwards all calls
  Env* target() const { return target_; }

  // The following text is boilerplate that forwards all methods to target()
  Status NewSequentialFile(const std::string& f, SequentialFile** r) {
    return target_->NewSequentialFile(f, r);
  }
  Status NewRandomAccessFile(const std::string& f, RandomAccessFile** r) {
    return target_->NewRandomAccessFile(f, r);
  }
  Status NewWritableFile(const std::string& f, WritableFile** r) {
    return target_->NewWritableFile(f, r);
  }
  Status NewAppendableFile(const std::string& f, WritableFile** r) {
    return target_->NewAppendableFile(f, r);
  }
  bool FileExists(const std::string& f) { return target_->FileExists(f); }
  Status GetChildren(const std::string& dir, std::vector<std::string>* r) {
    return ta...",1,include\leveldb\env.hpp,leveldb.EnvWrapper,Env,false,288,EnvWrapper,16
66159,TYPE_DECL,,include\leveldb\filter_policy.hpp:<global>,NAMESPACE_BLOCK,<global>,1,include\leveldb\filter_policy.hpp,include\leveldb\filter_policy.hpp:<global>,,false,1,<global>,2
66163,TYPE_DECL,,,,class Slice,1,include\leveldb\filter_policy.hpp,leveldb.Slice,,false,23,Slice,1
66164,TYPE_DECL,,,,"class FilterPolicy {
 public:
  virtual ~FilterPolicy();

  // Return the name of this policy.  Note that if the filter encoding
  // changes in an incompatible way, the name returned by this method
  // must be changed.  Otherwise, old incompatible filters may be
  // passed to methods of this type.
  virtual const char* Name() const = 0;

  // keys[0,n-1] contains a list of keys (potentially with duplicates)
  // that are ordered according to the user supplied comparator.
  // Append a filter that summarizes keys[0,n-1] to *dst.
  //
  // Warning: do not change the initial contents of *dst.  Instead,
  // append the newly constructed filter to *dst.
  virtual void CreateFilter(const Slice* keys, int n, std::string* dst)
      const = 0;

  // ""filter"" contains the data appended by a preceding call to
  // CreateFilter() on this class.  This method must return true if
  // the key was in the list of keys passed to CreateFilter().
  // This method may return true or false if the key...",1,include\leveldb\filter_policy.hpp,leveldb.FilterPolicy,,false,25,FilterPolicy,2
66197,TYPE_DECL,,include\leveldb\iterator.hpp:<global>,NAMESPACE_BLOCK,<global>,1,include\leveldb\iterator.hpp,include\leveldb\iterator.hpp:<global>,,false,1,<global>,3
66201,TYPE_DECL,,,,"class Iterator {
 public:
  Iterator();
  virtual ~Iterator();

  // An iterator is either positioned at a key/value pair, or
  // not valid.  This method returns true iff the iterator is valid.
  virtual bool Valid() const = 0;

  // Position at the first key in the source.  The iterator is Valid()
  // after this call iff the source is not empty.
  virtual void SeekToFirst() = 0;

  // Position at the last key in the source.  The iterator is
  // Valid() after this call iff the source is not empty.
  virtual void SeekToLast() = 0;

  // Position at the first key in the source that is at or past target.
  // The iterator is Valid() after this call iff the source contains
  // an entry that comes at or past target.
  virtual void Seek(const Slice& target) = 0;

  // Moves to the next entry in the source.  After this call, Valid() is
  // true iff the iterator was not positioned at the last entry in the source.
  // REQUIRES: Valid()
  virtual void Next() = 0;

  // Moves to the prev...",1,include\leveldb\iterator.hpp,leveldb.Iterator,,false,23,Iterator,1
66260,TYPE_DECL,,,,"struct Cleanup {
    CleanupFunction function;
    void* arg1;
    void* arg2;
    Cleanup* next;
  }",3,include\leveldb\iterator.hpp,leveldb.Iterator.Cleanup,,false,79,Cleanup,14
66289,TYPE_DECL,,include\leveldb\options.hpp:<global>,NAMESPACE_BLOCK,<global>,1,include\leveldb\options.hpp,include\leveldb\options.hpp:<global>,,false,1,<global>,2
66293,TYPE_DECL,,,,class Cache,1,include\leveldb\options.hpp,leveldb.Cache,,false,12,Cache,1
66294,TYPE_DECL,,,,class Comparator,1,include\leveldb\options.hpp,leveldb.Comparator,,false,13,Comparator,2
66295,TYPE_DECL,,,,class Env,1,include\leveldb\options.hpp,leveldb.Env,,false,14,Env,3
66296,TYPE_DECL,,,,class FilterPolicy,1,include\leveldb\options.hpp,leveldb.FilterPolicy,,false,15,FilterPolicy,4
66297,TYPE_DECL,,,,class Logger,1,include\leveldb\options.hpp,leveldb.Logger,,false,16,Logger,5
66298,TYPE_DECL,,,,class Snapshot,1,include\leveldb\options.hpp,leveldb.Snapshot,,false,17,Snapshot,6
66299,TYPE_DECL,,,,"enum CompressionType {
  // NOTE: do not change the values of existing entries, as these are
  // part of the persistent format on disk.
  kNoCompression     = 0x0,
  kSnappyCompression = 0x1
}",1,include\leveldb\options.hpp,leveldb.CompressionType,,false,23,CompressionType,7
66312,TYPE_DECL,,,,"struct Options {
  // -------------------
  // Parameters that affect behavior

  // Comparator used to define the order of keys in the table.
  // Default: a comparator that uses lexicographic byte-wise ordering
  //
  // REQUIRES: The client must ensure that the comparator supplied
  // here has the same name and orders keys *exactly* the same as the
  // comparator provided to previous open calls on the same DB.
  const Comparator* comparator;

  // If true, the database will be created if it is missing.
  // Default: false
  bool create_if_missing;

  // If true, an error is raised if the database already exists.
  // Default: false
  bool error_if_exists;

  // If true, the implementation will do aggressive checking of the
  // data it is processing and will stop early if it detects any
  // errors.  This may have unforeseen ramifications: for example, a
  // corruption of one DB entry may cause a large number of entries to
  // become unreadable or for the entire DB to become ...",1,include\leveldb\options.hpp,leveldb.Options,,false,31,Options,8
66332,TYPE_DECL,,,,"struct ReadOptions {
  // If true, all data read from underlying storage will be
  // verified against corresponding checksums.
  // Default: false
  bool verify_checksums;

  // Should the data read for this iteration be cached in memory?
  // Callers may wish to set this field to false for bulk scans.
  // Default: true
  bool fill_cache;

  // If ""snapshot"" is non-NULL, read as of the supplied snapshot
  // (which must belong to the DB that is being read and which must
  // not have been released).  If ""snapshot"" is NULL, use an implicit
  // snapshot of the state at the beginning of this read operation.
  // Default: NULL
  const Snapshot* snapshot;

  ReadOptions()
      : verify_checksums(false),
        fill_cache(true),
        snapshot(NULL) {
  }
}",1,include\leveldb\options.hpp,leveldb.ReadOptions,,false,161,ReadOptions,9
66340,TYPE_DECL,,,,"struct WriteOptions {
  // If true, the write will be flushed from the operating system
  // buffer cache (by calling WritableFile::Sync()) before the write
  // is considered complete.  If this flag is true, writes will be
  // slower.
  //
  // If this flag is false, and the machine crashes, some recent
  // writes may be lost.  Note that if it is just the process that
  // crashes (i.e., the machine does not reboot), no writes will be
  // lost even if sync==false.
  //
  // In other words, a DB write with sync==false has similar
  // crash semantics as the ""write()"" system call.  A DB write
  // with sync==true has similar crash semantics to a ""write()""
  // system call followed by ""fsync()"".
  //
  // Default: false
  bool sync;

  WriteOptions()
      : sync(false) {
  }
}",1,include\leveldb\options.hpp,leveldb.WriteOptions,,false,187,WriteOptions,10
66356,TYPE_DECL,,include\leveldb\slice.hpp:<global>,NAMESPACE_BLOCK,<global>,1,include\leveldb\slice.hpp,include\leveldb\slice.hpp:<global>,,false,1,<global>,5
66360,TYPE_DECL,,,,"class Slice {
 public:
  // Create an empty slice.
  Slice() : data_(""""), size_(0) { }

  // Create a slice that refers to d[0,n-1].
  Slice(const char* d, size_t n) : data_(d), size_(n) { }

  // Create a slice that refers to the contents of ""s""
  Slice(const std::string& s) : data_(s.data()), size_(s.size()) { }

  // Create a slice that refers to s[0,strlen(s)-1]
  Slice(const char* s) : data_(s), size_(strlen(s)) { }

  // Return a pointer to the beginning of the referenced data
  const char* data() const { return data_; }

  // Return the length (in bytes) of the referenced data
  size_t size() const { return size_; }

  // Return true iff the length of the referenced data is zero
  bool empty() const { return size_ == 0; }

  // Return the ith byte in the referenced data.
  // REQUIRES: n < size()
  char operator[](size_t n) const {
    assert(n < size());
    return data_[n];
  }

  // Change this slice to refer to an empty array
  void clear() { data_ = """"; size_ = 0; }

  /...",1,include\leveldb\slice.hpp,leveldb.Slice,,false,25,Slice,1
66586,TYPE_DECL,,include\leveldb\status.hpp:<global>,NAMESPACE_BLOCK,<global>,1,include\leveldb\status.hpp,include\leveldb\status.hpp:<global>,,false,1,<global>,3
66590,TYPE_DECL,,,,"class Status {
 public:
  // Create a success status.
  Status() : state_(NULL) { }
  ~Status() { delete[] state_; }

  // Copy the specified status.
  Status(const Status& s);
  void operator=(const Status& s);

  // Return a success status.
  static Status OK() { return Status(); }

  // Return error status of an appropriate type.
  static Status NotFound(const Slice& msg, const Slice& msg2 = Slice()) {
    return Status(kNotFound, msg, msg2);
  }
  static Status Corruption(const Slice& msg, const Slice& msg2 = Slice()) {
    return Status(kCorruption, msg, msg2);
  }
  static Status NotSupported(const Slice& msg, const Slice& msg2 = Slice()) {
    return Status(kNotSupported, msg, msg2);
  }
  static Status InvalidArgument(const Slice& msg, const Slice& msg2 = Slice()) {
    return Status(kInvalidArgument, msg, msg2);
  }
  static Status IOError(const Slice& msg, const Slice& msg2 = Slice()) {
    return Status(kIOError, msg, msg2);
  }

  // Returns true iff the status indicates...",1,include\leveldb\status.hpp,leveldb.Status,,false,21,Status,1
66725,TYPE_DECL,,,,"enum Code {
    kOk = 0,
    kNotFound = 1,
    kCorruption = 2,
    kNotSupported = 3,
    kInvalidArgument = 4,
    kIOError = 5
  }",3,include\leveldb\status.hpp,leveldb.Status.Code,,false,81,Code,19
66832,TYPE_DECL,,include\leveldb\table.hpp:<global>,NAMESPACE_BLOCK,<global>,1,include\leveldb\table.hpp,include\leveldb\table.hpp:<global>,,false,1,<global>,3
66836,TYPE_DECL,,,,class Block,1,include\leveldb\table.hpp,leveldb.Block,,false,13,Block,1
66837,TYPE_DECL,,,,class BlockHandle,1,include\leveldb\table.hpp,leveldb.BlockHandle,,false,14,BlockHandle,2
66838,TYPE_DECL,,,,class Footer,1,include\leveldb\table.hpp,leveldb.Footer,,false,15,Footer,3
66839,TYPE_DECL,,,,struct Options,1,include\leveldb\table.hpp,leveldb.Options,,false,16,Options,4
66840,TYPE_DECL,,,,class RandomAccessFile,1,include\leveldb\table.hpp,leveldb.RandomAccessFile,,false,17,RandomAccessFile,5
66841,TYPE_DECL,,,,struct ReadOptions,1,include\leveldb\table.hpp,leveldb.ReadOptions,,false,18,ReadOptions,6
66842,TYPE_DECL,,,,class TableCache,1,include\leveldb\table.hpp,leveldb.TableCache,,false,19,TableCache,7
66843,TYPE_DECL,,,,"class Table {
 public:
  // Attempt to open the table that is stored in bytes [0..file_size)
  // of ""file"", and read the metadata entries necessary to allow
  // retrieving data from the table.
  //
  // If successful, returns ok and sets ""*table"" to the newly opened
  // table.  The client should delete ""*table"" when no longer needed.
  // If there was an error while initializing the table, sets ""*table""
  // to NULL and returns a non-ok status.  Does not take ownership of
  // ""*source"", but the client must ensure that ""source"" remains live
  // for the duration of the returned table's lifetime.
  //
  // *file must remain live while this Table is in use.
  static Status Open(const Options& options,
                     RandomAccessFile* file,
                     uint64_t file_size,
                     Table** table);

  ~Table();

  // Returns a new iterator over the table contents.
  // The result of NewIterator() is initially invalid (caller must
  // call one of the Seek me...",1,include\leveldb\table.hpp,leveldb.Table,,false,24,Table,8
66866,TYPE_DECL,,,,struct Rep,3,include\leveldb\table.hpp,leveldb.Table.Rep,,false,59,Rep,5
66883,TYPE_DECL,,,,friend class TableCache,3,include\leveldb\table.hpp,leveldb.Table.TableCache,,false,68,TableCache,9
66920,TYPE_DECL,,include\leveldb\table_builder.hpp:<global>,NAMESPACE_BLOCK,<global>,1,include\leveldb\table_builder.hpp,include\leveldb\table_builder.hpp:<global>,,false,1,<global>,4
66924,TYPE_DECL,,,,class BlockBuilder,1,include\leveldb\table_builder.hpp,leveldb.BlockBuilder,,false,22,BlockBuilder,1
66925,TYPE_DECL,,,,class BlockHandle,1,include\leveldb\table_builder.hpp,leveldb.BlockHandle,,false,23,BlockHandle,2
66926,TYPE_DECL,,,,class WritableFile,1,include\leveldb\table_builder.hpp,leveldb.WritableFile,,false,24,WritableFile,3
66927,TYPE_DECL,,,,"class TableBuilder {
 public:
  // Create a builder that will store the contents of the table it is
  // building in *file.  Does not close the file.  It is up to the
  // caller to close the file after calling Finish().
  TableBuilder(const Options& options, WritableFile* file);

  // REQUIRES: Either Finish() or Abandon() has been called.
  ~TableBuilder();

  // Change the options used by this builder.  Note: only some of the
  // option fields can be changed after construction.  If a field is
  // not allowed to change dynamically and its value in the structure
  // passed to the constructor is different from its value in the
  // structure passed to this method, this method will return an error
  // without changing any fields.
  Status ChangeOptions(const Options& options);

  // Add key,value to the table being constructed.
  // REQUIRES: key is after any previously added key according to comparator.
  // REQUIRES: Finish(), Abandon() have not been called
  void Add(const Sli...",1,include\leveldb\table_builder.hpp,leveldb.TableBuilder,,false,26,TableBuilder,4
66995,TYPE_DECL,,,,struct Rep,3,include\leveldb\table_builder.hpp,leveldb.TableBuilder.Rep,,false,82,Rep,14
67013,TYPE_DECL,,include\leveldb\write_batch.hpp:<global>,NAMESPACE_BLOCK,<global>,1,include\leveldb\write_batch.hpp,include\leveldb\write_batch.hpp:<global>,,false,1,<global>,3
67017,TYPE_DECL,,,,class Slice,1,include\leveldb\write_batch.hpp,leveldb.Slice,,false,29,Slice,1
67018,TYPE_DECL,,,,"class WriteBatch {
 public:
  WriteBatch();
  ~WriteBatch();

  // Store the mapping ""key->value"" in the database.
  void Put(const Slice& key, const Slice& value);

  // If the database contains a mapping for ""key"", erase it.  Else do nothing.
  void Delete(const Slice& key);

  // Clear all updates buffered in this batch.
  void Clear();

  // Support for iterating over the contents of a batch.
  class Handler {
   public:
    virtual ~Handler();
    virtual void Put(const Slice& key, const Slice& value) = 0;
    virtual void Delete(const Slice& key) = 0;
  };
  Status Iterate(Handler* handler) const;

 private:
  friend class WriteBatchInternal;

  std::string rep_;  // See comment in write_batch.cc for the format of rep_

  // Intentionally copyable
}",1,include\leveldb\write_batch.hpp,leveldb.WriteBatch,,false,31,WriteBatch,2
67042,TYPE_DECL,,,,"class Handler {
   public:
    virtual ~Handler();
    virtual void Put(const Slice& key, const Slice& value) = 0;
    virtual void Delete(const Slice& key) = 0;
  }",3,include\leveldb\write_batch.hpp,leveldb.WriteBatch.Handler,,false,46,Handler,6
67063,TYPE_DECL,,,,friend class WriteBatchInternal,3,include\leveldb\write_batch.hpp,leveldb.WriteBatch.WriteBatchInternal,,false,55,WriteBatchInternal,8
67079,TYPE_DECL,,issues\issue178_test.cc:<global>,NAMESPACE_BLOCK,<global>,1,issues\issue178_test.cc,issues\issue178_test.cc:<global>,,false,1,<global>,7
67111,TYPE_DECL,,,,class Issue178 { },1,issues\issue178_test.cc,anonymous_namespace_4.Issue178,,false,28,Issue178,5
67112,TYPE_DECL,,,,_Test_Test,1,issues\issue178_test.cc,anonymous_namespace_5._Test_Test,Issue178,false,30,_Test_Test,6
67453,TYPE_DECL,,issues\issue200_test.cc:<global>,NAMESPACE_BLOCK,<global>,1,issues\issue200_test.cc,issues\issue200_test.cc:<global>,,false,1,<global>,3
67457,TYPE_DECL,,,,class Issue200 { },1,issues\issue200_test.cc,leveldb.Issue200,,false,14,Issue200,1
67458,TYPE_DECL,,,,_Test_Test,1,issues\issue200_test.cc,leveldb._Test_Test,Issue200,false,16,_Test_Test,2
67857,TYPE_DECL,,port\atomic_pointer.hpp:<global>,NAMESPACE_BLOCK,<global>,1,port\atomic_pointer.hpp,port\atomic_pointer.hpp:<global>,,false,1,<global>,5
67870,TYPE_DECL,,port\port.hpp:<global>,NAMESPACE_BLOCK,<global>,1,port\port.hpp,port\port.hpp:<global>,,false,1,<global>,4
67875,TYPE_DECL,,port\port_example.hpp:<global>,NAMESPACE_BLOCK,<global>,1,port\port_example.hpp,port\port_example.hpp:<global>,,false,1,<global>,1
67884,TYPE_DECL,,,,"class Mutex {
 public:
  Mutex();
  ~Mutex();

  // Lock the mutex.  Waits until other lockers have exited.
  // Will deadlock if the mutex is already locked by this thread.
  void Lock();

  // Unlock the mutex.
  // REQUIRES: This mutex was locked by this thread.
  void Unlock();

  // Optionally crash if this thread does not hold this mutex.
  // The implementation must be fast, especially if NDEBUG is
  // defined.  The implementation is allowed to skip all checks.
  void AssertHeld();
}",1,port\port_example.hpp,leveldb.port.Mutex,,false,26,Mutex,3
67905,TYPE_DECL,,,,"class CondVar {
 public:
  explicit CondVar(Mutex* mu);
  ~CondVar();

  // Atomically release *mu and block on this condition variable until
  // either a call to SignalAll(), or a call to Signal() that picks
  // this thread to wakeup.
  // REQUIRES: this thread holds *mu
  void Wait();

  // If there are some threads waiting, wake up at least one of them.
  void Signal();

  // Wake up all waiting threads.
  void SignallAll();
}",1,port\port_example.hpp,leveldb.port.CondVar,,false,45,CondVar,4
67927,TYPE_DECL,ANY,,,typedef intptr_t OnceType;,18,port\port_example.hpp,OnceType,,false,69,OnceType,5
67934,TYPE_DECL,,,,"class AtomicPointer {
 private:
  intptr_t rep_;
 public:
  // Initialize to arbitrary value
  AtomicPointer();

  // Initialize to hold v
  explicit AtomicPointer(void* v) : rep_(v) { }

  // Read and return the stored pointer with the guarantee that no
  // later memory access (read or write) by this thread can be
  // reordered ahead of this read.
  void* Acquire_Load() const;

  // Set v as the stored pointer with the guarantee that no earlier
  // memory access (read or write) by this thread can be reordered
  // after this store.
  void Release_Store(void* v);

  // Read the stored pointer with no ordering guarantees.
  void* NoBarrier_Load() const;

  // Set va as the stored pointer with no ordering guarantees.
  void NoBarrier_Store(void* v);
}",1,port\port_example.hpp,leveldb.port.AtomicPointer,,false,75,AtomicPointer,7
68007,TYPE_DECL,,port\port_posix.cc:<global>,NAMESPACE_BLOCK,<global>,1,port\port_posix.cc,port\port_posix.cc:<global>,,false,1,<global>,5
68153,TYPE_DECL,,port\port_posix.hpp:<global>,NAMESPACE_BLOCK,<global>,1,port\port_posix.hpp,port\port_posix.hpp:<global>,,false,1,<global>,12
68166,TYPE_DECL,,,,class CondVar,1,port\port_posix.hpp,leveldb.port.CondVar,,false,80,CondVar,3
68167,TYPE_DECL,,,,"class Mutex {
 public:
  Mutex();
  ~Mutex();

  void Lock();
  void Unlock();
  void AssertHeld() { }

 private:
  friend class CondVar;
  pthread_mutex_t mu_;

  // No copying
  Mutex(const Mutex&);
  void operator=(const Mutex&);
}",1,port\port_posix.hpp,leveldb.port.Mutex,,false,82,Mutex,4
68188,TYPE_DECL,,,,friend class CondVar,3,port\port_posix.hpp,leveldb.port.Mutex.CondVar,,false,92,CondVar,6
68200,TYPE_DECL,,,,"class CondVar {
 public:
  explicit CondVar(Mutex* mu);
  ~CondVar();
  void Wait();
  void Signal();
  void SignalAll();
 private:
  pthread_cond_t cv_;
  Mutex* mu_;
}",1,port\port_posix.hpp,leveldb.port.CondVar,,false,100,CondVar,5
68224,TYPE_DECL,ANY,,,typedef pthread_once_t OnceType;,24,port\port_posix.hpp,OnceType,,false,112,OnceType,6
68287,TYPE_DECL,,port\port_posix_sse.cc:<global>,NAMESPACE_BLOCK,<global>,1,port\port_posix_sse.cc,port\port_posix_sse.cc:<global>,,false,1,<global>,7
68303,TYPE_DECL,,port\thread_annotations.hpp:<global>,NAMESPACE_BLOCK,<global>,1,port\thread_annotations.hpp,port\thread_annotations.hpp:<global>,,false,1,<global>,1
68308,TYPE_DECL,,port\win\stdint.hpp:<global>,NAMESPACE_BLOCK,<global>,1,port\win\stdint.hpp,port\win\stdint.hpp:<global>,,false,1,<global>,1
68311,TYPE_DECL,signed char,,,typedef signed char           int8_t;,31,port\win\stdint.hpp,int8_t,,false,15,int8_t,1
68312,TYPE_DECL,short int,,,typedef signed short          int16_t;,31,port\win\stdint.hpp,int16_t,,false,16,int16_t,2
68313,TYPE_DECL,int,,,typedef signed int            int32_t;,31,port\win\stdint.hpp,int32_t,,false,17,int32_t,3
68314,TYPE_DECL,long long int,,,typedef signed long long      int64_t;,31,port\win\stdint.hpp,int64_t,,false,18,int64_t,4
68315,TYPE_DECL,unsigned char,,,typedef unsigned char         uint8_t;,31,port\win\stdint.hpp,uint8_t,,false,19,uint8_t,5
68316,TYPE_DECL,unsigned shortint,,,typedef unsigned short        uint16_t;,31,port\win\stdint.hpp,uint16_t,,false,20,uint16_t,6
68317,TYPE_DECL,unsigned int,,,typedef unsigned int          uint32_t;,31,port\win\stdint.hpp,uint32_t,,false,21,uint32_t,7
68318,TYPE_DECL,unsigned longlongint,,,typedef unsigned long long    uint64_t;,31,port\win\stdint.hpp,uint64_t,,false,22,uint64_t,8
68335,TYPE_DECL,,table\block.cc:<global>,NAMESPACE_BLOCK,<global>,1,table\block.cc,table\block.cc:<global>,,false,1,<global>,8
68523,TYPE_DECL,,,,"class Block::Iter : public Iterator {
 private:
  const Comparator* const comparator_;
  const char* const data_;      // underlying block contents
  uint32_t const restarts_;     // Offset of restart array (list of fixed32)
  uint32_t const num_restarts_; // Number of uint32_t entries in restart array

  // current_ is offset in data_ of current entry.  >= restarts_ if !Valid
  uint32_t current_;
  uint32_t restart_index_;  // Index of restart block in which current_ falls
  std::string key_;
  Slice value_;
  Status status_;

  inline int Compare(const Slice& a, const Slice& b) const {
    return comparator_->Compare(a, b);
  }

  // Return the offset in data_ just past the end of the current entry.
  inline uint32_t NextEntryOffset() const {
    return (value_.data() + value_.size()) - data_;
  }

  uint32_t GetRestartPoint(uint32_t index) {
    assert(index < num_restarts_);
    return DecodeFixed32(data_ + restarts_ + index * sizeof(uint32_t));
  }

  void SeekToRestartPoint(ui...",1,table\block.cc,leveldb.Iter,Iterator,false,76,Iter,5
68989,TYPE_DECL,,table\block.hpp:<global>,NAMESPACE_BLOCK,<global>,1,table\block.hpp,table\block.hpp:<global>,,false,1,<global>,4
68993,TYPE_DECL,,,,struct BlockContents,1,table\block.hpp,leveldb.BlockContents,,false,14,BlockContents,1
68994,TYPE_DECL,,,,class Comparator,1,table\block.hpp,leveldb.Comparator,,false,15,Comparator,2
68995,TYPE_DECL,,,,"class Block {
 public:
  // Initialize the block with the specified contents.
  explicit Block(const BlockContents& contents);

  ~Block();

  size_t size() const { return size_; }
  Iterator* NewIterator(const Comparator* comparator);

 private:
  uint32_t NumRestarts() const;

  const char* data_;
  size_t size_;
  uint32_t restart_offset_;     // Offset in data_ of restart array
  bool owned_;                  // Block owns data_[]

  // No copying allowed
  Block(const Block&);
  void operator=(const Block&);

  class Iter;
}",1,table\block.hpp,leveldb.Block,,false,17,Block,3
69034,TYPE_DECL,,,,class Iter,3,table\block.hpp,leveldb.Block.Iter,,false,39,Iter,12
69049,TYPE_DECL,,table\block_builder.cc:<global>,NAMESPACE_BLOCK,<global>,1,table\block_builder.cc,table\block_builder.cc:<global>,,false,1,<global>,7
69320,TYPE_DECL,,table\block_builder.hpp:<global>,NAMESPACE_BLOCK,<global>,1,table\block_builder.hpp,table\block_builder.hpp:<global>,,false,1,<global>,4
69324,TYPE_DECL,,,,struct Options,1,table\block_builder.hpp,leveldb.Options,,false,15,Options,1
69325,TYPE_DECL,,,,"class BlockBuilder {
 public:
  explicit BlockBuilder(const Options* options);

  // Reset the contents as if the BlockBuilder was just constructed.
  void Reset();

  // REQUIRES: Finish() has not been called since the last call to Reset().
  // REQUIRES: key is larger than any previously added key
  void Add(const Slice& key, const Slice& value);

  // Finish building the block and return a slice that refers to the
  // block contents.  The returned slice will remain valid for the
  // lifetime of this builder or until Reset() is called.
  Slice Finish();

  // Returns an estimate of the current (uncompressed) size of the block
  // we are building.
  size_t CurrentSizeEstimate() const;

  // Return true iff no entries have been added since the last Reset()
  bool empty() const {
    return buffer_.empty();
  }

 private:
  const Options*        options_;
  std::string           buffer_;      // Destination buffer
  std::vector<uint32_t> restarts_;    // Restart points
  int      ...",1,table\block_builder.hpp,leveldb.BlockBuilder,,false,17,BlockBuilder,2
69382,TYPE_DECL,,table\filter_block.cc:<global>,NAMESPACE_BLOCK,<global>,1,table\filter_block.cc,table\filter_block.cc:<global>,,false,1,<global>,4
69780,TYPE_DECL,,table\filter_block.hpp:<global>,NAMESPACE_BLOCK,<global>,1,table\filter_block.hpp,table\filter_block.hpp:<global>,,false,1,<global>,7
69784,TYPE_DECL,,,,class FilterPolicy,1,table\filter_block.hpp,leveldb.FilterPolicy,,false,21,FilterPolicy,1
69785,TYPE_DECL,,,,"class FilterBlockBuilder {
 public:
  explicit FilterBlockBuilder(const FilterPolicy*);

  void StartBlock(uint64_t block_offset);
  void AddKey(const Slice& key);
  Slice Finish();

 private:
  void GenerateFilter();

  const FilterPolicy* policy_;
  std::string keys_;              // Flattened key contents
  std::vector<size_t> start_;     // Starting index in keys_ of each key
  std::string result_;            // Filter data computed so far
  std::vector<Slice> tmp_keys_;   // policy_->CreateFilter() argument
  std::vector<uint32_t> filter_offsets_;

  // No copying allowed
  FilterBlockBuilder(const FilterBlockBuilder&);
  void operator=(const FilterBlockBuilder&);
}",1,table\filter_block.hpp,leveldb.FilterBlockBuilder,,false,29,FilterBlockBuilder,2
69825,TYPE_DECL,,,,"class FilterBlockReader {
 public:
 // REQUIRES: ""contents"" and *policy must stay live while *this is live.
  FilterBlockReader(const FilterPolicy* policy, const Slice& contents);
  bool KeyMayMatch(uint64_t block_offset, const Slice& key);

 private:
  const FilterPolicy* policy_;
  const char* data_;    // Pointer to filter data (at block-start)
  const char* offset_;  // Pointer to beginning of offset array (at block-end)
  size_t num_;          // Number of entries in offset array
  size_t base_lg_;      // Encoding parameter (see kFilterBaseLg in .cc file)
}",1,table\filter_block.hpp,leveldb.FilterBlockReader,,false,52,FilterBlockReader,3
69859,TYPE_DECL,,table\filter_block_test.cc:<global>,NAMESPACE_BLOCK,<global>,1,table\filter_block_test.cc,table\filter_block_test.cc:<global>,,false,1,<global>,8
69863,TYPE_DECL,,,,"class TestHashFilter : public FilterPolicy {
 public:
  virtual const char* Name() const {
    return ""TestHashFilter"";
  }

  virtual void CreateFilter(const Slice* keys, int n, std::string* dst) const {
    for (int i = 0; i < n; i++) {
      uint32_t h = Hash(keys[i].data(), keys[i].size(), 1);
      PutFixed32(dst, h);
    }
  }

  virtual bool KeyMayMatch(const Slice& key, const Slice& filter) const {
    uint32_t h = Hash(key.data(), key.size(), 1);
    for (size_t i = 0; i + 4 <= filter.size(); i += 4) {
      if (h == DecodeFixed32(filter.data() + i)) {
        return true;
      }
    }
    return false;
  }
}",1,table\filter_block_test.cc,leveldb.TestHashFilter,FilterPolicy,false,17,TestHashFilter,1
69961,TYPE_DECL,,,,"class FilterBlockTest {
 public:
  TestHashFilter policy_;
}",1,table\filter_block_test.cc,leveldb.FilterBlockTest,,false,41,FilterBlockTest,2
69963,TYPE_DECL,,,,_Test_EmptyBuilder,1,table\filter_block_test.cc,leveldb._Test_EmptyBuilder,FilterBlockTest,false,46,_Test_EmptyBuilder,3
70071,TYPE_DECL,,,,_Test_SingleChunk,1,table\filter_block_test.cc,leveldb._Test_SingleChunk,FilterBlockTest,false,55,_Test_SingleChunk,7
70302,TYPE_DECL,,,,_Test_MultiChunk,1,table\filter_block_test.cc,leveldb._Test_MultiChunk,FilterBlockTest,false,76,_Test_MultiChunk,11
70754,TYPE_DECL,,table\format.cc:<global>,NAMESPACE_BLOCK,<global>,1,table\format.cc,table\format.cc:<global>,,false,1,<global>,7
71255,TYPE_DECL,,table\format.hpp:<global>,NAMESPACE_BLOCK,<global>,1,table\format.hpp,table\format.hpp:<global>,,false,1,<global>,6
71259,TYPE_DECL,,,,class Block,1,table\format.hpp,leveldb.Block,,false,16,Block,1
71260,TYPE_DECL,,,,class RandomAccessFile,1,table\format.hpp,leveldb.RandomAccessFile,,false,17,RandomAccessFile,2
71261,TYPE_DECL,,,,struct ReadOptions,1,table\format.hpp,leveldb.ReadOptions,,false,18,ReadOptions,3
71262,TYPE_DECL,,,,"class BlockHandle {
 public:
  BlockHandle();

  // The offset of the block in the file.
  uint64_t offset() const { return offset_; }
  void set_offset(uint64_t offset) { offset_ = offset; }

  // The size of the stored block
  uint64_t size() const { return size_; }
  void set_size(uint64_t size) { size_ = size; }

  void EncodeTo(std::string* dst) const;
  Status DecodeFrom(Slice* input);

  // Maximum encoding length of a BlockHandle
  enum { kMaxEncodedLength = 10 + 10 };

 private:
  uint64_t offset_;
  uint64_t size_;
}",1,table\format.hpp,leveldb.BlockHandle,,false,22,BlockHandle,4
71305,TYPE_DECL,,,,enum { kMaxEncodedLength = 10 + 10 },3,table\format.hpp,leveldb.BlockHandle.anonymous_enum_0,,false,38,anonymous_enum_0,8
71318,TYPE_DECL,,,,"class Footer {
 public:
  Footer() { }

  // The block handle for the metaindex block of the table
  const BlockHandle& metaindex_handle() const { return metaindex_handle_; }
  void set_metaindex_handle(const BlockHandle& h) { metaindex_handle_ = h; }

  // The block handle for the index block of the table
  const BlockHandle& index_handle() const {
    return index_handle_;
  }
  void set_index_handle(const BlockHandle& h) {
    index_handle_ = h;
  }

  void EncodeTo(std::string* dst) const;
  Status DecodeFrom(Slice* input);

  // Encoded length of a Footer.  Note that the serialization of a
  // Footer will always occupy exactly this many bytes.  It consists
  // of two block handles and a magic number.
  enum {
    kEncodedLength = 2*BlockHandle::kMaxEncodedLength + 8
  };

 private:
  BlockHandle metaindex_handle_;
  BlockHandle index_handle_;
}",1,table\format.hpp,leveldb.Footer,,false,47,Footer,5
71361,TYPE_DECL,,,,"enum {
    kEncodedLength = 2*BlockHandle::kMaxEncodedLength + 8
  }",3,table\format.hpp,leveldb.Footer.anonymous_enum_1,,false,69,anonymous_enum_1,8
71386,TYPE_DECL,,,,"struct BlockContents {
  Slice data;           // Actual contents of data
  bool cachable;        // True iff data can be cached
  bool heap_allocated;  // True iff caller should delete[] data.data()
}",1,table\format.hpp,leveldb.BlockContents,,false,86,BlockContents,10
71406,TYPE_DECL,,table\iterator.cc:<global>,NAMESPACE_BLOCK,<global>,1,table\iterator.cc,table\iterator.cc:<global>,,false,1,<global>,2
71537,TYPE_DECL,,,,"class EmptyIterator : public Iterator {
 public:
  EmptyIterator(const Status& s) : status_(s) { }
  virtual bool Valid() const { return false; }
  virtual void Seek(const Slice& target) { }
  virtual void SeekToFirst() { }
  virtual void SeekToLast() { }
  virtual void Next() { assert(false); }
  virtual void Prev() { assert(false); }
  Slice key() const { assert(false); return Slice(); }
  Slice value() const { assert(false); return Slice(); }
  virtual Status status() const { return status_; }
 private:
  Status status_;
}",1,table\iterator.cc,leveldb.anonymous_namespace_1.EmptyIterator,Iterator,false,42,EmptyIterator,1
71623,TYPE_DECL,,table\iterator_wrapper.hpp:<global>,NAMESPACE_BLOCK,<global>,1,table\iterator_wrapper.hpp,table\iterator_wrapper.hpp:<global>,,false,1,<global>,3
71627,TYPE_DECL,,,,"class IteratorWrapper {
 public:
  IteratorWrapper(): iter_(NULL), valid_(false) { }
  explicit IteratorWrapper(Iterator* iter): iter_(NULL) {
    Set(iter);
  }
  ~IteratorWrapper() { delete iter_; }
  Iterator* iter() const { return iter_; }

  // Takes ownership of ""iter"" and will delete it when destroyed, or
  // when Set() is invoked again.
  void Set(Iterator* iter) {
    delete iter_;
    iter_ = iter;
    if (iter_ == NULL) {
      valid_ = false;
    } else {
      Update();
    }
  }


  // Iterator interface methods
  bool Valid() const        { return valid_; }
  Slice key() const         { assert(Valid()); return key_; }
  Slice value() const       { assert(Valid()); return iter_->value(); }
  // Methods below require iter() != NULL
  Status status() const     { assert(iter_); return iter_->status(); }
  void Next()               { assert(iter_); iter_->Next();        Update(); }
  void Prev()               { assert(iter_); iter_->Prev();        Update(); }
  void Seek(...",1,table\iterator_wrapper.hpp,leveldb.IteratorWrapper,,false,17,IteratorWrapper,1
71797,TYPE_DECL,,table\merger.cc:<global>,NAMESPACE_BLOCK,<global>,1,table\merger.cc,table\merger.cc:<global>,,false,1,<global>,5
71802,TYPE_DECL,,,,"class MergingIterator : public Iterator {
 public:
  MergingIterator(const Comparator* comparator, Iterator** children, int n)
      : comparator_(comparator),
        children_(new IteratorWrapper[n]),
        n_(n),
        current_(NULL),
        direction_(kForward) {
    for (int i = 0; i < n; i++) {
      children_[i].Set(children[i]);
    }
  }

  virtual ~MergingIterator() {
    delete[] children_;
  }

  virtual bool Valid() const {
    return (current_ != NULL);
  }

  virtual void SeekToFirst() {
    for (int i = 0; i < n_; i++) {
      children_[i].SeekToFirst();
    }
    FindSmallest();
    direction_ = kForward;
  }

  virtual void SeekToLast() {
    for (int i = 0; i < n_; i++) {
      children_[i].SeekToLast();
    }
    FindLargest();
    direction_ = kReverse;
  }

  virtual void Seek(const Slice& target) {
    for (int i = 0; i < n_; i++) {
      children_[i].Seek(target);
    }
    FindSmallest();
    direction_ = kForward;
  }

  virtual void Next() {
    asser...",1,table\merger.cc,leveldb.anonymous_namespace_1.MergingIterator,Iterator,false,14,MergingIterator,1
72128,TYPE_DECL,,,,"enum Direction {
    kForward,
    kReverse
  }",3,table\merger.cc,leveldb.anonymous_namespace_22.MergingIterator.Direction,,false,148,Direction,18
72303,TYPE_DECL,,table\merger.hpp:<global>,NAMESPACE_BLOCK,<global>,1,table\merger.hpp,table\merger.hpp:<global>,,false,1,<global>,1
72307,TYPE_DECL,,,,class Comparator,1,table\merger.hpp,leveldb.Comparator,,false,10,Comparator,1
72308,TYPE_DECL,,,,class Iterator,1,table\merger.hpp,leveldb.Iterator,,false,11,Iterator,2
72340,TYPE_DECL,,table\table.cc:<global>,NAMESPACE_BLOCK,<global>,1,table\table.cc,table\table.cc:<global>,,false,1,<global>,12
72344,TYPE_DECL,,,,"struct Table::Rep {
  ~Rep() {
    delete filter;
    delete [] filter_data;
    delete index_block;
  }

  Options options;
  Status status;
  RandomAccessFile* file;
  uint64_t cache_id;
  FilterBlockReader* filter;
  const char* filter_data;

  BlockHandle metaindex_handle;  // Handle to metaindex_block: saved from footer
  Block* index_block;
}",1,table\table.cc,leveldb.Rep,,false,20,Rep,1
73284,TYPE_DECL,,table\table_builder.cc:<global>,NAMESPACE_BLOCK,<global>,1,table\table_builder.cc,table\table_builder.cc:<global>,,false,1,<global>,12
73288,TYPE_DECL,,,,"struct TableBuilder::Rep {
  Options options;
  Options index_block_options;
  WritableFile* file;
  uint64_t offset;
  Status status;
  BlockBuilder data_block;
  BlockBuilder index_block;
  std::string last_key;
  int64_t num_entries;
  bool closed;          // Either Finish() or Abandon() has been called.
  FilterBlockBuilder* filter_block;

  // We do not emit the index entry for a block until we have seen the
  // first key for the next data block.  This allows us to use shorter
  // keys in the index block.  For example, consider a block boundary
  // between the keys ""the quick brown fox"" and ""the who"".  We can use
  // ""the r"" as the key for the index block entry since it is >= all
  // entries in the first block and < all entries in subsequent
  // blocks.
  //
  // Invariant: r->pending_index_entry is true only if data_block is empty.
  bool pending_index_entry;
  BlockHandle pending_handle;  // Handle to add to index block

  std::string compressed_output;

  Rep(const Op...",1,table\table_builder.cc,leveldb.Rep,,false,20,Rep,1
74111,TYPE_DECL,,table\table_test.cc:<global>,NAMESPACE_BLOCK,<global>,1,table\table_test.cc,table\table_test.cc:<global>,,false,1,<global>,17
74156,TYPE_DECL,,,,"class ReverseKeyComparator : public Comparator {
 public:
  virtual const char* Name() const {
    return ""leveldb.ReverseBytewiseComparator"";
  }

  virtual int Compare(const Slice& a, const Slice& b) const {
    return BytewiseComparator()->Compare(Reverse(a), Reverse(b));
  }

  virtual void FindShortestSeparator(
      std::string* start,
      const Slice& limit) const {
    std::string s = Reverse(*start);
    std::string l = Reverse(limit);
    BytewiseComparator()->FindShortestSeparator(&s, l);
    *start = Reverse(s);
  }

  virtual void FindShortSuccessor(std::string* key) const {
    std::string s = Reverse(*key);
    BytewiseComparator()->FindShortSuccessor(&s);
    *key = Reverse(s);
  }
}",1,table\table_test.cc,leveldb.anonymous_namespace_1.ReverseKeyComparator,Comparator,false,38,ReverseKeyComparator,1
74270,TYPE_DECL,,,,"struct STLLessThan {
  const Comparator* cmp;

  STLLessThan() : cmp(BytewiseComparator()) { }
  STLLessThan(const Comparator* c) : cmp(c) { }
  bool operator()(const std::string& a, const std::string& b) const {
    return cmp->Compare(Slice(a), Slice(b)) < 0;
  }
}",1,table\table_test.cc,leveldb.anonymous_namespace_7.STLLessThan,,false,79,STLLessThan,1
74298,TYPE_DECL,,,,"class StringSink: public WritableFile {
 public:
  ~StringSink() { }

  const std::string& contents() const { return contents_; }

  virtual Status Close() { return Status::OK(); }
  virtual Status Flush() { return Status::OK(); }
  virtual Status Sync() { return Status::OK(); }

  virtual Status Append(const Slice& data) {
    contents_.append(data.data(), data.size());
    return Status::OK();
  }

 private:
  std::string contents_;
}",1,table\table_test.cc,leveldb.StringSink,WritableFile,false,90,StringSink,6
74359,TYPE_DECL,,,,"class StringSource: public RandomAccessFile {
 public:
  StringSource(const Slice& contents)
      : contents_(contents.data(), contents.size()) {
  }

  virtual ~StringSource() { }

  uint64_t Size() const { return contents_.size(); }

  virtual Status Read(uint64_t offset, size_t n, Slice* result,
                       char* scratch) const {
    if (offset > contents_.size()) {
      return Status::InvalidArgument(""invalid Read offset"");
    }
    if (offset + n > contents_.size()) {
      n = contents_.size() - offset;
    }
    memcpy(scratch, &contents_[offset], n);
    *result = Slice(scratch, n);
    return Status::OK();
  }

 private:
  std::string contents_;
}",1,table\table_test.cc,leveldb.StringSource,RandomAccessFile,false,110,StringSource,7
74437,TYPE_DECL,ANY,,,"typedef std::map<std::string, std::string, STLLessThan> KVMap;",57,table\table_test.cc,KVMap,,false,137,KVMap,8
74438,TYPE_DECL,,,,"class Constructor {
 public:
  explicit Constructor(const Comparator* cmp) : data_(STLLessThan(cmp)) { }
  virtual ~Constructor() { }

  void Add(const std::string& key, const Slice& value) {
    data_[key] = value.ToString();
  }

  // Finish constructing the data structure with all the keys that have
  // been added so far.  Returns the keys in sorted order in ""*keys""
  // and stores the key/value pairs in ""*kvmap""
  void Finish(const Options& options,
              std::vector<std::string>* keys,
              KVMap* kvmap) {
    *kvmap = data_;
    keys->clear();
    for (KVMap::const_iterator it = data_.begin();
         it != data_.end();
         ++it) {
      keys->push_back(it->first);
    }
    data_.clear();
    Status s = FinishImpl(options, *kvmap);
    ASSERT_TRUE(s.ok()) << s.ToString();
  }

  // Construct the data structure from the data in ""data""
  virtual Status FinishImpl(const Options& options, const KVMap& data) = 0;

  virtual Iterator* NewIterator() const = 0...",1,table\table_test.cc,leveldb.Constructor,,false,141,Constructor,9
74563,TYPE_DECL,,,,"class BlockConstructor: public Constructor {
 public:
  explicit BlockConstructor(const Comparator* cmp)
      : Constructor(cmp),
        comparator_(cmp),
        block_(NULL) { }
  ~BlockConstructor() {
    delete block_;
  }
  virtual Status FinishImpl(const Options& options, const KVMap& data) {
    delete block_;
    block_ = NULL;
    BlockBuilder builder(&options);

    for (KVMap::const_iterator it = data.begin();
         it != data.end();
         ++it) {
      builder.Add(it->first, it->second);
    }
    // Open the block
    data_ = builder.Finish().ToString();
    BlockContents contents;
    contents.data = data_;
    contents.cachable = false;
    contents.heap_allocated = false;
    block_ = new Block(contents);
    return Status::OK();
  }
  virtual Iterator* NewIterator() const {
    return block_->NewIterator(comparator_);
  }

 private:
  const Comparator* comparator_;
  std::string data_;
  Block* block_;

  BlockConstructor();
}",1,table\table_test.cc,leveldb.BlockConstructor,Constructor,false,181,BlockConstructor,10
74670,TYPE_DECL,,,,"class TableConstructor: public Constructor {
 public:
  TableConstructor(const Comparator* cmp)
      : Constructor(cmp),
        source_(NULL), table_(NULL) {
  }
  ~TableConstructor() {
    Reset();
  }
  virtual Status FinishImpl(const Options& options, const KVMap& data) {
    Reset();
    StringSink sink;
    TableBuilder builder(options, &sink);

    for (KVMap::const_iterator it = data.begin();
         it != data.end();
         ++it) {
      builder.Add(it->first, it->second);
      ASSERT_TRUE(builder.status().ok());
    }
    Status s = builder.Finish();
    ASSERT_TRUE(s.ok()) << s.ToString();

    ASSERT_EQ(sink.contents().size(), builder.FileSize());

    // Open the table
    source_ = new StringSource(sink.contents());
    Options table_options;
    table_options.comparator = options.comparator;
    return Table::Open(table_options, source_, sink.contents().size(), &table_);
  }

  virtual Iterator* NewIterator() const {
    return table_->NewIterator(ReadOptions());...",1,table\table_test.cc,leveldb.TableConstructor,Constructor,false,221,TableConstructor,11
74892,TYPE_DECL,,,,"class KeyConvertingIterator: public Iterator {
 public:
  explicit KeyConvertingIterator(Iterator* iter) : iter_(iter) { }
  virtual ~KeyConvertingIterator() { delete iter_; }
  virtual bool Valid() const { return iter_->Valid(); }
  virtual void Seek(const Slice& target) {
    ParsedInternalKey ikey(target, kMaxSequenceNumber, kTypeValue);
    std::string encoded;
    AppendInternalKey(&encoded, ikey);
    iter_->Seek(encoded);
  }
  virtual void SeekToFirst() { iter_->SeekToFirst(); }
  virtual void SeekToLast() { iter_->SeekToLast(); }
  virtual void Next() { iter_->Next(); }
  virtual void Prev() { iter_->Prev(); }

  virtual Slice key() const {
    assert(Valid());
    ParsedInternalKey key;
    if (!ParseInternalKey(iter_->key(), &key)) {
      status_ = Status::Corruption(""malformed internal key"");
      return Slice(""corrupted key"");
    }
    return key.user_key;
  }

  virtual Slice value() const { return iter_->value(); }
  virtual Status status() const {
    return statu...",1,table\table_test.cc,leveldb.KeyConvertingIterator,Iterator,false,276,KeyConvertingIterator,12
75032,TYPE_DECL,,,,"class MemTableConstructor: public Constructor {
 public:
  explicit MemTableConstructor(const Comparator* cmp)
      : Constructor(cmp),
        internal_comparator_(cmp) {
    memtable_ = new MemTable(internal_comparator_);
    memtable_->Ref();
  }
  ~MemTableConstructor() {
    memtable_->Unref();
  }
  virtual Status FinishImpl(const Options& options, const KVMap& data) {
    memtable_->Unref();
    memtable_ = new MemTable(internal_comparator_);
    memtable_->Ref();
    int seq = 1;
    for (KVMap::const_iterator it = data.begin();
         it != data.end();
         ++it) {
      memtable_->Add(seq, kTypeValue, it->first, it->second);
      seq++;
    }
    return Status::OK();
  }
  virtual Iterator* NewIterator() const {
    return new KeyConvertingIterator(memtable_->NewIterator());
  }

 private:
  InternalKeyComparator internal_comparator_;
  MemTable* memtable_;
}",1,table\table_test.cc,leveldb.MemTableConstructor,Constructor,false,316,MemTableConstructor,13
75128,TYPE_DECL,,,,"class DBConstructor: public Constructor {
 public:
  explicit DBConstructor(const Comparator* cmp)
      : Constructor(cmp),
        comparator_(cmp) {
    db_ = NULL;
    NewDB();
  }
  ~DBConstructor() {
    delete db_;
  }
  virtual Status FinishImpl(const Options& options, const KVMap& data) {
    delete db_;
    db_ = NULL;
    NewDB();
    for (KVMap::const_iterator it = data.begin();
         it != data.end();
         ++it) {
      WriteBatch batch;
      batch.Put(it->first, it->second);
      ASSERT_TRUE(db_->Write(WriteOptions(), &batch).ok());
    }
    return Status::OK();
  }
  virtual Iterator* NewIterator() const {
    return db_->NewIterator(ReadOptions());
  }

  virtual DB* db() const { return db_; }

 private:
  void NewDB() {
    std::string name = test::TmpDir() + ""/table_testdb"";

    Options options;
    options.comparator = comparator_;
    Status status = DestroyDB(name, options);
    ASSERT_TRUE(status.ok()) << status.ToString();

    options.create_if_mis...",1,table\table_test.cc,leveldb.DBConstructor,Constructor,false,349,DBConstructor,14
75336,TYPE_DECL,,,,"enum TestType {
  TABLE_TEST,
  BLOCK_TEST,
  MEMTABLE_TEST,
  DB_TEST
}",1,table\table_test.cc,leveldb.TestType,,false,399,TestType,15
75341,TYPE_DECL,,,,"struct TestArgs {
  TestType type;
  bool reverse_compare;
  int restart_interval;
}",1,table\table_test.cc,leveldb.TestArgs,,false,406,TestArgs,16
75423,TYPE_DECL,,,,"class Harness {
 public:
  Harness() : constructor_(NULL) { }

  void Init(const TestArgs& args) {
    delete constructor_;
    constructor_ = NULL;
    options_ = Options();

    options_.block_restart_interval = args.restart_interval;
    // Use shorter block size for tests to exercise block boundary
    // conditions more.
    options_.block_size = 256;
    if (args.reverse_compare) {
      options_.comparator = &reverse_key_comparator;
    }
    switch (args.type) {
      case TABLE_TEST:
        constructor_ = new TableConstructor(options_.comparator);
        break;
      case BLOCK_TEST:
        constructor_ = new BlockConstructor(options_.comparator);
        break;
      case MEMTABLE_TEST:
        constructor_ = new MemTableConstructor(options_.comparator);
        break;
      case DB_TEST:
        constructor_ = new DBConstructor(options_.comparator);
        break;
    }
  }

  ~Harness() {
    delete constructor_;
  }

  void Add(const std::string& key, const std::stri...",1,table\table_test.cc,leveldb.Harness,,false,437,Harness,21
76317,TYPE_DECL,,,,_Test_Empty,1,table\table_test.cc,leveldb._Test_Empty,Harness,false,648,_Test_Empty,22
76377,TYPE_DECL,,,,_Test_ZeroRestartPointsInBlock,1,table\table_test.cc,leveldb._Test_ZeroRestartPointsInBlock,Harness,false,659,_Test_ZeroRestartPointsInBlock,26
76533,TYPE_DECL,,,,_Test_SimpleEmptyKey,1,table\table_test.cc,leveldb._Test_SimpleEmptyKey,Harness,false,678,_Test_SimpleEmptyKey,30
76596,TYPE_DECL,,,,_Test_SimpleSingle,1,table\table_test.cc,leveldb._Test_SimpleSingle,Harness,false,687,_Test_SimpleSingle,34
76659,TYPE_DECL,,,,_Test_SimpleMulti,1,table\table_test.cc,leveldb._Test_SimpleMulti,Harness,false,696,_Test_SimpleMulti,38
76728,TYPE_DECL,,,,_Test_SimpleSpecialKey,1,table\table_test.cc,leveldb._Test_SimpleSpecialKey,Harness,false,707,_Test_SimpleSpecialKey,42
76791,TYPE_DECL,,,,_Test_Randomized,1,table\table_test.cc,leveldb._Test_Randomized,Harness,false,716,_Test_Randomized,46
76927,TYPE_DECL,,,,_Test_RandomizedLongDB,1,table\table_test.cc,leveldb._Test_RandomizedLongDB,Harness,false,736,_Test_RandomizedLongDB,50
77094,TYPE_DECL,,,,class MemTableTest { },1,table\table_test.cc,leveldb.MemTableTest,,false,760,MemTableTest,54
77095,TYPE_DECL,,,,_Test_Simple,1,table\table_test.cc,leveldb._Test_Simple,MemTableTest,false,762,_Test_Simple,55
77314,TYPE_DECL,,,,class TableTest { },1,table\table_test.cc,leveldb.TableTest,,false,798,TableTest,60
77315,TYPE_DECL,,,,_Test_ApproximateOffsetOfPlain,1,table\table_test.cc,leveldb._Test_ApproximateOffsetOfPlain,TableTest,false,800,_Test_ApproximateOffsetOfPlain,61
77709,TYPE_DECL,,,,_Test_ApproximateOffsetOfCompressed,1,table\table_test.cc,leveldb._Test_ApproximateOffsetOfCompressed,TableTest,false,836,_Test_ApproximateOffsetOfCompressed,66
78010,TYPE_DECL,,table\two_level_iterator.cc:<global>,NAMESPACE_BLOCK,<global>,1,table\two_level_iterator.cc,table\two_level_iterator.cc:<global>,,false,1,<global>,6
78022,TYPE_DECL,,,,"class TwoLevelIterator: public Iterator {
 public:
  TwoLevelIterator(
    Iterator* index_iter,
    BlockFunction block_function,
    void* arg,
    const ReadOptions& options);

  virtual ~TwoLevelIterator();

  virtual void Seek(const Slice& target);
  virtual void SeekToFirst();
  virtual void SeekToLast();
  virtual void Next();
  virtual void Prev();

  virtual bool Valid() const {
    return data_iter_.Valid();
  }
  virtual Slice key() const {
    assert(Valid());
    return data_iter_.key();
  }
  virtual Slice value() const {
    assert(Valid());
    return data_iter_.value();
  }
  virtual Status status() const {
    // It'd be nice if status() returned a const Status& instead of a Status
    if (!index_iter_.status().ok()) {
      return index_iter_.status();
    } else if (data_iter_.iter() != NULL && !data_iter_.status().ok()) {
      return data_iter_.status();
    } else {
      return status_;
    }
  }

 private:
  void SaveError(const Status& s) {
    if (status_....",1,table\two_level_iterator.cc,leveldb.anonymous_namespace_2.TwoLevelIterator,Iterator,false,18,TwoLevelIterator,2
78473,TYPE_DECL,,table\two_level_iterator.hpp:<global>,NAMESPACE_BLOCK,<global>,1,table\two_level_iterator.hpp,table\two_level_iterator.hpp:<global>,,false,1,<global>,2
78477,TYPE_DECL,,,,struct ReadOptions,1,table\two_level_iterator.hpp,leveldb.ReadOptions,,false,12,ReadOptions,1
78492,TYPE_DECL,,util\arena.cc:<global>,NAMESPACE_BLOCK,<global>,1,util\arena.cc,util\arena.cc:<global>,,false,1,<global>,3
78698,TYPE_DECL,,util\arena.hpp:<global>,NAMESPACE_BLOCK,<global>,1,util\arena.hpp,util\arena.hpp:<global>,,false,1,<global>,6
78702,TYPE_DECL,,,,"class Arena {
 public:
  Arena();
  ~Arena();

  // Return a pointer to a newly allocated memory block of ""bytes"" bytes.
  char* Allocate(size_t bytes);

  // Allocate memory with the normal alignment guarantees provided by malloc
  char* AllocateAligned(size_t bytes);

  // Returns an estimate of the total memory usage of data allocated
  // by the arena.
  size_t MemoryUsage() const {
    return reinterpret_cast<uintptr_t>(memory_usage_.NoBarrier_Load());
  }

 private:
  char* AllocateFallback(size_t bytes);
  char* AllocateNewBlock(size_t block_bytes);

  // Allocation state
  char* alloc_ptr_;
  size_t alloc_bytes_remaining_;

  // Array of new[] allocated memory blocks
  std::vector<char*> blocks_;

  // Total memory usage of the arena.
  port::AtomicPointer memory_usage_;

  // No copying allowed
  Arena(const Arena&);
  void operator=(const Arena&);
}",1,util\arena.hpp,leveldb.Arena,,false,16,Arena,1
78793,TYPE_DECL,,util\arena_test.cc:<global>,NAMESPACE_BLOCK,<global>,1,util\arena_test.cc,util\arena_test.cc:<global>,,false,1,<global>,4
78797,TYPE_DECL,,,,class ArenaTest { },1,util\arena_test.cc,leveldb.ArenaTest,,false,12,ArenaTest,1
78798,TYPE_DECL,,,,_Test_Empty,1,util\arena_test.cc,leveldb._Test_Empty,ArenaTest,false,14,_Test_Empty,2
78832,TYPE_DECL,,,,_Test_Simple,1,util\arena_test.cc,leveldb._Test_Simple,ArenaTest,false,18,_Test_Simple,6
79147,TYPE_DECL,,util\bloom.cc:<global>,NAMESPACE_BLOCK,<global>,1,util\bloom.cc,util\bloom.cc:<global>,,false,1,<global>,4
79168,TYPE_DECL,,,,"class BloomFilterPolicy : public FilterPolicy {
 private:
  size_t bits_per_key_;
  size_t k_;

 public:
  explicit BloomFilterPolicy(int bits_per_key)
      : bits_per_key_(bits_per_key) {
    // We intentionally round down to reduce probing cost a little bit
    k_ = static_cast<size_t>(bits_per_key * 0.69);  // 0.69 =~ ln(2)
    if (k_ < 1) k_ = 1;
    if (k_ > 30) k_ = 30;
  }

  virtual const char* Name() const {
    return ""leveldb.BuiltinBloomFilter2"";
  }

  virtual void CreateFilter(const Slice* keys, int n, std::string* dst) const {
    // Compute bloom filter size (in both bits and bytes)
    size_t bits = n * bits_per_key_;

    // For small n, we can see a very high false positive rate.  Fix it
    // by enforcing a minimum bloom filter length.
    if (bits < 64) bits = 64;

    size_t bytes = (bits + 7) / 8;
    bits = bytes * 8;

    const size_t init_size = dst->size();
    dst->resize(init_size + bytes, 0);
    dst->push_back(static_cast<char>(k_));  // Remember # o...",1,util\bloom.cc,leveldb.anonymous_namespace_2.BloomFilterPolicy,FilterPolicy,false,17,BloomFilterPolicy,2
79456,TYPE_DECL,,util\bloom_test.cc:<global>,NAMESPACE_BLOCK,<global>,1,util\bloom_test.cc,util\bloom_test.cc:<global>,,false,1,<global>,6
79478,TYPE_DECL,,,,"class BloomTest {
 private:
  const FilterPolicy* policy_;
  std::string filter_;
  std::vector<std::string> keys_;

 public:
  BloomTest() : policy_(NewBloomFilterPolicy(10)) { }

  ~BloomTest() {
    delete policy_;
  }

  void Reset() {
    keys_.clear();
    filter_.clear();
  }

  void Add(const Slice& s) {
    keys_.push_back(s.ToString());
  }

  void Build() {
    std::vector<Slice> key_slices;
    for (size_t i = 0; i < keys_.size(); i++) {
      key_slices.push_back(Slice(keys_[i]));
    }
    filter_.clear();
    policy_->CreateFilter(&key_slices[0], static_cast<int>(key_slices.size()),
                          &filter_);
    keys_.clear();
    if (kVerbose >= 2) DumpFilter();
  }

  size_t FilterSize() const {
    return filter_.size();
  }

  void DumpFilter() {
    fprintf(stderr, ""F("");
    for (size_t i = 0; i+1 < filter_.size(); i++) {
      const unsigned int c = static_cast<unsigned int>(filter_[i]);
      for (int j = 0; j < 8; j++) {
        fprintf(stderr, ""%c...",1,util\bloom_test.cc,leveldb.BloomTest,,false,21,BloomTest,4
79697,TYPE_DECL,,,,_Test_EmptyFilter,1,util\bloom_test.cc,leveldb._Test_EmptyFilter,BloomTest,false,89,_Test_EmptyFilter,5
79770,TYPE_DECL,,,,_Test_Small,1,util\bloom_test.cc,leveldb._Test_Small,BloomTest,false,94,_Test_Small,9
79923,TYPE_DECL,,,,_Test_VaryingLengths,1,util\bloom_test.cc,leveldb._Test_VaryingLengths,BloomTest,false,116,_Test_VaryingLengths,14
80165,TYPE_DECL,,util\cache.cc:<global>,NAMESPACE_BLOCK,<global>,1,util\cache.cc,util\cache.cc:<global>,,false,1,<global>,8
80174,TYPE_DECL,,,,"struct LRUHandle {
  void* value;
  void (*deleter)(const Slice&, void* value);
  LRUHandle* next_hash;
  LRUHandle* next;
  LRUHandle* prev;
  size_t charge;      // TODO(opt): Only allow uint32_t?
  size_t key_length;
  bool in_cache;      // Whether entry is in the cache.
  uint32_t refs;      // References, including cache reference, if present.
  uint32_t hash;      // Hash of key(); used for fast sharding and comparisons
  char key_data[1];   // Beginning of key

  Slice key() const {
    // For cheaper lookups, we allow a temporary Handle object
    // to store a pointer to a key in ""value"".
    if (next == this) {
      return *(reinterpret_cast<Slice*>(value));
    } else {
      return Slice(key_data, key_length);
    }
  }
}",1,util\cache.cc,leveldb.anonymous_namespace_1.LRUHandle,,false,42,LRUHandle,1
80217,TYPE_DECL,,,,"class HandleTable {
 public:
  HandleTable() : length_(0), elems_(0), list_(NULL) { Resize(); }
  ~HandleTable() { delete[] list_; }

  LRUHandle* Lookup(const Slice& key, uint32_t hash) {
    return *FindPointer(key, hash);
  }

  LRUHandle* Insert(LRUHandle* h) {
    LRUHandle** ptr = FindPointer(h->key(), h->hash);
    LRUHandle* old = *ptr;
    h->next_hash = (old == NULL ? NULL : old->next_hash);
    *ptr = h;
    if (old == NULL) {
      ++elems_;
      if (elems_ > length_) {
        // Since each cache entry is fairly large, we aim for a small
        // average linked list length (<= 1).
        Resize();
      }
    }
    return old;
  }

  LRUHandle* Remove(const Slice& key, uint32_t hash) {
    LRUHandle** ptr = FindPointer(key, hash);
    LRUHandle* result = *ptr;
    if (result != NULL) {
      *ptr = result->next_hash;
      --elems_;
    }
    return result;
  }

 private:
  // The table consists of an array of buckets where each bucket is
  // a linked list of cache...",1,util\cache.cc,leveldb.anonymous_namespace_4.HandleTable,,false,71,HandleTable,2
80481,TYPE_DECL,,,,"class LRUCache {
 public:
  LRUCache();
  ~LRUCache();

  // Separate from constructor so caller can easily make an array of LRUCache
  void SetCapacity(size_t capacity) { capacity_ = capacity; }

  // Like Cache methods, but with an extra ""hash"" parameter.
  Cache::Handle* Insert(const Slice& key, uint32_t hash,
                        void* value, size_t charge,
                        void (*deleter)(const Slice& key, void* value));
  Cache::Handle* Lookup(const Slice& key, uint32_t hash);
  void Release(Cache::Handle* handle);
  void Erase(const Slice& key, uint32_t hash);
  void Prune();
  size_t TotalCharge() const {
    MutexLock l(&mutex_);
    return usage_;
  }

 private:
  void LRU_Remove(LRUHandle* e);
  void LRU_Append(LRUHandle*list, LRUHandle* e);
  void Ref(LRUHandle* e);
  void Unref(LRUHandle* e);
  bool FinishErase(LRUHandle* e);

  // Initialized before use.
  size_t capacity_;

  // mutex_ protects the following state.
  mutable port::Mutex mutex_;
  size_t usag...",1,util\cache.cc,leveldb.anonymous_namespace_17.LRUCache,,false,153,LRUCache,3
81094,TYPE_DECL,,,,"class ShardedLRUCache : public Cache {
 private:
  LRUCache shard_[kNumShards];
  port::Mutex id_mutex_;
  uint64_t last_id_;

  static inline uint32_t HashSlice(const Slice& s) {
    return Hash(s.data(), s.size(), 0);
  }

  static uint32_t Shard(uint32_t hash) {
    return hash >> (32 - kNumShardBits);
  }

 public:
  explicit ShardedLRUCache(size_t capacity)
      : last_id_(0) {
    const size_t per_shard = (capacity + (kNumShards - 1)) / kNumShards;
    for (int s = 0; s < kNumShards; s++) {
      shard_[s].SetCapacity(per_shard);
    }
  }
  virtual ~ShardedLRUCache() { }
  virtual Handle* Insert(const Slice& key, void* value, size_t charge,
                         void (*deleter)(const Slice& key, void* value)) {
    const uint32_t hash = HashSlice(key);
    return shard_[Shard(hash)].Insert(key, hash, value, charge, deleter);
  }
  virtual Handle* Lookup(const Slice& key) {
    const uint32_t hash = HashSlice(key);
    return shard_[Shard(hash)].Lookup(key, hash);
  }
  vi...",1,util\cache.cc,leveldb.anonymous_namespace_54.ShardedLRUCache,Cache,false,338,ShardedLRUCache,20
81348,TYPE_DECL,,util\cache_test.cc:<global>,NAMESPACE_BLOCK,<global>,1,util\cache_test.cc,util\cache_test.cc:<global>,,false,1,<global>,5
81400,TYPE_DECL,,,,"class CacheTest {
 public:
  static CacheTest* current_;

  static void Deleter(const Slice& key, void* v) {
    current_->deleted_keys_.push_back(DecodeKey(key));
    current_->deleted_values_.push_back(DecodeValue(v));
  }

  static const int kCacheSize = 1000;
  std::vector<int> deleted_keys_;
  std::vector<int> deleted_values_;
  Cache* cache_;

  CacheTest() : cache_(NewLRUCache(kCacheSize)) {
    current_ = this;
  }

  ~CacheTest() {
    delete cache_;
  }

  int Lookup(int key) {
    Cache::Handle* handle = cache_->Lookup(EncodeKey(key));
    const int r = (handle == NULL) ? -1 : DecodeValue(cache_->Value(handle));
    if (handle != NULL) {
      cache_->Release(handle);
    }
    return r;
  }

  void Insert(int key, int value, int charge = 1) {
    cache_->Release(cache_->Insert(EncodeKey(key), EncodeValue(value), charge,
                                   &CacheTest::Deleter));
  }

  Cache::Handle* InsertAndReturnHandle(int key, int value, int charge = 1) {
    return ca...",1,util\cache_test.cc,leveldb.CacheTest,,false,26,CacheTest,5
81546,TYPE_DECL,,,,_Test_HitAndMiss,1,util\cache_test.cc,leveldb._Test_HitAndMiss,CacheTest,false,73,_Test_HitAndMiss,7
81853,TYPE_DECL,,,,_Test_Erase,1,util\cache_test.cc,leveldb._Test_Erase,CacheTest,false,96,_Test_Erase,11
82089,TYPE_DECL,,,,_Test_EntriesArePinned,1,util\cache_test.cc,leveldb._Test_EntriesArePinned,CacheTest,false,115,_Test_EntriesArePinned,15
82409,TYPE_DECL,,,,_Test_EvictionPolicy,1,util\cache_test.cc,leveldb._Test_EvictionPolicy,CacheTest,false,140,_Test_EvictionPolicy,19
82584,TYPE_DECL,,,,_Test_UseExceedsCacheSize,1,util\cache_test.cc,leveldb._Test_UseExceedsCacheSize,CacheTest,false,159,_Test_UseExceedsCacheSize,23
82700,TYPE_DECL,,,,_Test_HeavyEntries,1,util\cache_test.cc,leveldb._Test_HeavyEntries,CacheTest,false,176,_Test_HeavyEntries,27
82852,TYPE_DECL,,,,_Test_NewId,1,util\cache_test.cc,leveldb._Test_NewId,CacheTest,false,203,_Test_NewId,31
82916,TYPE_DECL,,,,_Test_Prune,1,util\cache_test.cc,leveldb._Test_Prune,CacheTest,false,209,_Test_Prune,35
83046,TYPE_DECL,,util\coding.cc:<global>,NAMESPACE_BLOCK,<global>,1,util\coding.cc,util\coding.cc:<global>,,false,1,<global>,2
83851,TYPE_DECL,,util\coding.hpp:<global>,NAMESPACE_BLOCK,<global>,1,util\coding.hpp,util\coding.hpp:<global>,,false,1,<global>,6
84096,TYPE_DECL,,util\coding_test.cc:<global>,NAMESPACE_BLOCK,<global>,1,util\coding_test.cc,util\coding_test.cc:<global>,,false,1,<global>,3
84100,TYPE_DECL,,,,class Coding { },1,util\coding_test.cc,leveldb.Coding,,false,11,Coding,1
84101,TYPE_DECL,,,,_Test_Fixed32,1,util\coding_test.cc,leveldb._Test_Fixed32,Coding,false,13,_Test_Fixed32,2
84196,TYPE_DECL,,,,_Test_Fixed64,1,util\coding_test.cc,leveldb._Test_Fixed64,Coding,false,27,_Test_Fixed64,6
84374,TYPE_DECL,,,,_Test_EncodingOutput,1,util\coding_test.cc,leveldb._Test_EncodingOutput,Coding,false,55,_Test_EncodingOutput,10
84766,TYPE_DECL,,,,_Test_Varint32,1,util\coding_test.cc,leveldb._Test_Varint32,Coding,false,77,_Test_Varint32,14
84958,TYPE_DECL,,,,_Test_Varint64,1,util\coding_test.cc,leveldb._Test_Varint64,Coding,false,98,_Test_Varint64,18
85220,TYPE_DECL,,,,_Test_Varint32Overflow,1,util\coding_test.cc,leveldb._Test_Varint32Overflow,Coding,false,134,_Test_Varint32Overflow,22
85289,TYPE_DECL,,,,_Test_Varint32Truncation,1,util\coding_test.cc,leveldb._Test_Varint32Truncation,Coding,false,141,_Test_Varint32Truncation,26
85431,TYPE_DECL,,,,_Test_Varint64Overflow,1,util\coding_test.cc,leveldb._Test_Varint64Overflow,Coding,false,153,_Test_Varint64Overflow,30
85500,TYPE_DECL,,,,_Test_Varint64Truncation,1,util\coding_test.cc,leveldb._Test_Varint64Truncation,Coding,false,160,_Test_Varint64Truncation,34
85642,TYPE_DECL,,,,_Test_Strings,1,util\coding_test.cc,leveldb._Test_Strings,Coding,false,172,_Test_Strings,38
85927,TYPE_DECL,,util\comparator.cc:<global>,NAMESPACE_BLOCK,<global>,1,util\comparator.cc,util\comparator.cc:<global>,,false,1,<global>,7
85936,TYPE_DECL,,,,"class BytewiseComparatorImpl : public Comparator {
 public:
  BytewiseComparatorImpl() { }

  virtual const char* Name() const {
    return ""leveldb.BytewiseComparator"";
  }

  virtual int Compare(const Slice& a, const Slice& b) const {
    return a.compare(b);
  }

  virtual void FindShortestSeparator(
      std::string* start,
      const Slice& limit) const {
    // Find length of common prefix
    size_t min_length = std::min(start->size(), limit.size());
    size_t diff_index = 0;
    while ((diff_index < min_length) &&
           ((*start)[diff_index] == limit[diff_index])) {
      diff_index++;
    }

    if (diff_index >= min_length) {
      // Do not shorten if one string is a prefix of the other
    } else {
      uint8_t diff_byte = static_cast<uint8_t>((*start)[diff_index]);
      if (diff_byte < static_cast<uint8_t>(0xff) &&
          diff_byte + 1 < static_cast<uint8_t>(limit[diff_index])) {
        (*start)[diff_index]++;
        start->resize(diff_index + 1);
       ...",1,util\comparator.cc,leveldb.anonymous_namespace_1.BytewiseComparatorImpl,Comparator,false,17,BytewiseComparatorImpl,1
86142,TYPE_DECL,,util\crc32c.cc:<global>,NAMESPACE_BLOCK,<global>,1,util\crc32c.cc,util\crc32c.cc:<global>,,false,1,<global>,5
87598,TYPE_DECL,,util\crc32c.hpp:<global>,NAMESPACE_BLOCK,<global>,1,util\crc32c.hpp,util\crc32c.hpp:<global>,,false,1,<global>,3
87665,TYPE_DECL,,util\crc32c_test.cc:<global>,NAMESPACE_BLOCK,<global>,1,util\crc32c_test.cc,util\crc32c_test.cc:<global>,,false,1,<global>,3
87670,TYPE_DECL,,,,class CRC { },1,util\crc32c_test.cc,leveldb.crc32c.CRC,,false,11,CRC,1
87671,TYPE_DECL,,,,_Test_StandardResults,1,util\crc32c_test.cc,leveldb.crc32c._Test_StandardResults,CRC,false,13,_Test_StandardResults,2
87900,TYPE_DECL,,,,_Test_Values,1,util\crc32c_test.cc,leveldb.crc32c._Test_Values,CRC,false,50,_Test_Values,6
87952,TYPE_DECL,,,,_Test_Extend,1,util\crc32c_test.cc,leveldb.crc32c._Test_Extend,CRC,false,54,_Test_Extend,10
88007,TYPE_DECL,,,,_Test_Mask,1,util\crc32c_test.cc,leveldb.crc32c._Test_Mask,CRC,false,59,_Test_Mask,14
88149,TYPE_DECL,,util\env.cc:<global>,NAMESPACE_BLOCK,<global>,1,util\env.cc,util\env.cc:<global>,,false,1,<global>,2
88457,TYPE_DECL,,util\env_posix.cc:<global>,NAMESPACE_BLOCK,<global>,1,util\env_posix.cc,util\env_posix.cc:<global>,,false,1,<global>,25
88486,TYPE_DECL,,,,"class Limiter {
 public:
  // Limit maximum number of resources to |n|.
  Limiter(intptr_t n) {
    SetAllowed(n);
  }

  // If another resource is available, acquire it and return true.
  // Else return false.
  bool Acquire() {
    if (GetAllowed() <= 0) {
      return false;
    }
    MutexLock l(&mu_);
    intptr_t x = GetAllowed();
    if (x <= 0) {
      return false;
    } else {
      SetAllowed(x - 1);
      return true;
    }
  }

  // Release a resource acquired by a previous call to Acquire() that returned
  // true.
  void Release() {
    MutexLock l(&mu_);
    SetAllowed(GetAllowed() + 1);
  }

 private:
  port::Mutex mu_;
  port::AtomicPointer allowed_;

  intptr_t GetAllowed() const {
    return reinterpret_cast<intptr_t>(allowed_.Acquire_Load());
  }

  // REQUIRES: mu_ must be held
  void SetAllowed(intptr_t v) {
    allowed_.Release_Store(reinterpret_cast<void*>(v));
  }

  Limiter(const Limiter&);
  void operator=(const Limiter&);
}",1,util\env_posix.cc,leveldb.anonymous_namespace_2.Limiter,,false,45,Limiter,6
88575,TYPE_DECL,,,,"class PosixSequentialFile: public SequentialFile {
 private:
  std::string filename_;
  FILE* file_;

 public:
  PosixSequentialFile(const std::string& fname, FILE* f)
      : filename_(fname), file_(f) { }
  virtual ~PosixSequentialFile() { fclose(file_); }

  virtual Status Read(size_t n, Slice* result, char* scratch) {
    Status s;
    size_t r = fread_unlocked(scratch, 1, n, file_);
    *result = Slice(scratch, r);
    if (r < n) {
      if (feof(file_)) {
        // We leave status as ok if we hit the end of the file
      } else {
        // A partial read with an error: return a non-ok status
        s = IOError(filename_, errno);
      }
    }
    return s;
  }

  virtual Status Skip(uint64_t n) {
    if (fseek(file_, n, SEEK_CUR)) {
      return IOError(filename_, errno);
    }
    return Status::OK();
  }
}",1,util\env_posix.cc,leveldb.anonymous_namespace_16.PosixSequentialFile,SequentialFile,false,92,PosixSequentialFile,7
88650,TYPE_DECL,,,,"class PosixRandomAccessFile: public RandomAccessFile {
 private:
  std::string filename_;
  bool temporary_fd_;  // If true, fd_ is -1 and we open on every read.
  int fd_;
  Limiter* limiter_;

 public:
  PosixRandomAccessFile(const std::string& fname, int fd, Limiter* limiter)
      : filename_(fname), fd_(fd), limiter_(limiter) {
    temporary_fd_ = !limiter->Acquire();
    if (temporary_fd_) {
      // Open file on every access.
      close(fd_);
      fd_ = -1;
    }
  }

  virtual ~PosixRandomAccessFile() {
    if (!temporary_fd_) {
      close(fd_);
      limiter_->Release();
    }
  }

  virtual Status Read(uint64_t offset, size_t n, Slice* result,
                      char* scratch) const {
    int fd = fd_;
    if (temporary_fd_) {
      fd = open(filename_.c_str(), O_RDONLY);
      if (fd < 0) {
        return IOError(filename_, errno);
      }
    }

    Status s;
    ssize_t r = pread(fd, scratch, n, static_cast<off_t>(offset));
    *result = Slice(scratch, (r < 0) ? 0...",1,util\env_posix.cc,leveldb.anonymous_namespace_21.PosixRandomAccessFile,RandomAccessFile,false,126,PosixRandomAccessFile,8
88763,TYPE_DECL,,,,"class PosixMmapReadableFile: public RandomAccessFile {
 private:
  std::string filename_;
  void* mmapped_region_;
  size_t length_;
  Limiter* limiter_;

 public:
  // base[0,length-1] contains the mmapped contents of the file.
  PosixMmapReadableFile(const std::string& fname, void* base, size_t length,
                        Limiter* limiter)
      : filename_(fname), mmapped_region_(base), length_(length),
        limiter_(limiter) {
  }

  virtual ~PosixMmapReadableFile() {
    munmap(mmapped_region_, length_);
    limiter_->Release();
  }

  virtual Status Read(uint64_t offset, size_t n, Slice* result,
                      char* scratch) const {
    Status s;
    if (offset + n > length_) {
      *result = Slice();
      s = IOError(filename_, EINVAL);
    } else {
      *result = Slice(reinterpret_cast<char*>(mmapped_region_) + offset, n);
    }
    return s;
  }
}",1,util\env_posix.cc,leveldb.anonymous_namespace_25.PosixMmapReadableFile,RandomAccessFile,false,177,PosixMmapReadableFile,9
88826,TYPE_DECL,,,,"class PosixWritableFile : public WritableFile {
 private:
  std::string filename_;
  FILE* file_;

 public:
  PosixWritableFile(const std::string& fname, FILE* f)
      : filename_(fname), file_(f) { }

  ~PosixWritableFile() {
    if (file_ != NULL) {
      // Ignoring any potential errors
      fclose(file_);
    }
  }

  virtual Status Append(const Slice& data) {
    size_t r = fwrite_unlocked(data.data(), 1, data.size(), file_);
    if (r != data.size()) {
      return IOError(filename_, errno);
    }
    return Status::OK();
  }

  virtual Status Close() {
    Status result;
    if (fclose(file_) != 0) {
      result = IOError(filename_, errno);
    }
    file_ = NULL;
    return result;
  }

  virtual Status Flush() {
    if (fflush_unlocked(file_) != 0) {
      return IOError(filename_, errno);
    }
    return Status::OK();
  }

  Status SyncDirIfManifest() {
    const char* f = filename_.c_str();
    const char* sep = strrchr(f, '/');
    Slice basename;
    std::string dir...",1,util\env_posix.cc,leveldb.anonymous_namespace_29.PosixWritableFile,WritableFile,false,210,PosixWritableFile,10
89098,TYPE_DECL,,,,"class PosixFileLock : public FileLock {
 public:
  int fd_;
  std::string name_;
}",1,util\env_posix.cc,leveldb.anonymous_namespace_39.PosixFileLock,FileLock,false,302,PosixFileLock,12
89101,TYPE_DECL,,,,"class PosixLockTable {
 private:
  port::Mutex mu_;
  std::set<std::string> locked_files_;
 public:
  bool Insert(const std::string& fname) {
    MutexLock l(&mu_);
    return locked_files_.insert(fname).second;
  }
  void Remove(const std::string& fname) {
    MutexLock l(&mu_);
    locked_files_.erase(fname);
  }
}",1,util\env_posix.cc,leveldb.anonymous_namespace_40.PosixLockTable,,false,311,PosixLockTable,13
89135,TYPE_DECL,,,,"class PosixEnv : public Env {
 public:
  PosixEnv();
  virtual ~PosixEnv() {
    char msg[] = ""Destroying Env::Default()\n"";
    fwrite(msg, 1, sizeof(msg), stderr);
    abort();
  }

  virtual Status NewSequentialFile(const std::string& fname,
                                   SequentialFile** result) {
    FILE* f = fopen(fname.c_str(), ""r"");
    if (f == NULL) {
      *result = NULL;
      return IOError(fname, errno);
    } else {
      *result = new PosixSequentialFile(fname, f);
      return Status::OK();
    }
  }

  virtual Status NewRandomAccessFile(const std::string& fname,
                                     RandomAccessFile** result) {
    *result = NULL;
    Status s;
    int fd = open(fname.c_str(), O_RDONLY);
    if (fd < 0) {
      s = IOError(fname, errno);
    } else if (mmap_limit_.Acquire()) {
      uint64_t size;
      s = GetFileSize(fname, &size);
      if (s.ok()) {
        void* base = mmap(NULL, size, PROT_READ, MAP_SHARED, fd, 0);
        if (base != MAP...",1,util\env_posix.cc,leveldb.anonymous_namespace_43.PosixEnv,Env,false,326,PosixEnv,14
89925,TYPE_DECL,,,,struct BGItem { void* arg; void (*function)(void*); },3,util\env_posix.cc,leveldb.anonymous_namespace_73.PosixEnv.BGItem,,false,565,BGItem,30
89932,TYPE_DECL,ANY,,,typedef std::deque<BGItem> BGQueue;,30,util\env_posix.cc,BGQueue,,false,566,BGQueue,31
90143,TYPE_DECL,,,,"struct StartThreadState {
  void (*user_function)(void*);
  void* arg;
}",1,util\env_posix.cc,leveldb.anonymous_namespace_83.anonymous_namespace_84.StartThreadState,,false,653,StartThreadState,1
90260,TYPE_DECL,,util\env_posix_test.cc:<global>,NAMESPACE_BLOCK,<global>,1,util\env_posix_test.cc,util\env_posix_test.cc:<global>,,false,1,<global>,5
90276,TYPE_DECL,,,,"class EnvPosixTest {
 public:
  Env* env_;
  EnvPosixTest() : env_(Env::Default()) { }

  static void SetFileLimits(int read_only_file_limit, int mmap_limit) {
    EnvPosixTestHelper::SetReadOnlyFDLimit(read_only_file_limit);
    EnvPosixTestHelper::SetReadOnlyMMapLimit(mmap_limit);
  }
}",1,util\env_posix_test.cc,leveldb.EnvPosixTest,,false,17,EnvPosixTest,7
90298,TYPE_DECL,,,,_Test_TestOpenOnRead,1,util\env_posix_test.cc,leveldb._Test_TestOpenOnRead,EnvPosixTest,false,28,_Test_TestOpenOnRead,8
90575,TYPE_DECL,,util\env_posix_test_helper.hpp:<global>,NAMESPACE_BLOCK,<global>,1,util\env_posix_test_helper.hpp,util\env_posix_test_helper.hpp:<global>,,false,1,<global>,1
90579,TYPE_DECL,,,,class EnvPosixTest,1,util\env_posix_test_helper.hpp,leveldb.EnvPosixTest,,false,10,EnvPosixTest,1
90580,TYPE_DECL,,,,"class EnvPosixTestHelper {
 private:
  friend class EnvPosixTest;

  // Set the maximum number of read-only files that will be opened.
  // Must be called before creating an Env.
  static void SetReadOnlyFDLimit(int limit);

  // Set the maximum number of read-only files that will be mapped via mmap.
  // Must be called before creating an Env.
  static void SetReadOnlyMMapLimit(int limit);
}",1,util\env_posix_test_helper.hpp,leveldb.EnvPosixTestHelper,,false,13,EnvPosixTestHelper,2
90581,TYPE_DECL,,,,friend class EnvPosixTest,3,util\env_posix_test_helper.hpp,leveldb.EnvPosixTestHelper.EnvPosixTest,,false,15,EnvPosixTest,1
90600,TYPE_DECL,,util\env_test.cc:<global>,NAMESPACE_BLOCK,<global>,1,util\env_test.cc,util\env_test.cc:<global>,,false,1,<global>,4
90616,TYPE_DECL,,,,"class EnvTest {
 private:
  port::Mutex mu_;
  std::string events_;

 public:
  Env* env_;
  EnvTest() : env_(Env::Default()) { }
}",1,util\env_test.cc,leveldb.EnvTest,,false,16,EnvTest,7
90636,TYPE_DECL,,,,_Test_RunImmediately,1,util\env_test.cc,leveldb._Test_RunImmediately,EnvTest,false,30,_Test_RunImmediately,9
90705,TYPE_DECL,,,,_Test_RunMany,1,util\env_test.cc,leveldb._Test_RunMany,EnvTest,false,37,_Test_RunMany,13
90834,TYPE_DECL,,,,"struct State {
  port::Mutex mu;
  int val;
  int num_running;
}",1,util\env_test.cc,leveldb.State,,false,69,State,17
90871,TYPE_DECL,,,,_Test_StartThread,1,util\env_test.cc,leveldb._Test_StartThread,EnvTest,false,83,_Test_StartThread,19
91005,TYPE_DECL,,util\filter_policy.cc:<global>,NAMESPACE_BLOCK,<global>,1,util\filter_policy.cc,util\filter_policy.cc:<global>,,false,1,<global>,2
91021,TYPE_DECL,,util\hash.cc:<global>,NAMESPACE_BLOCK,<global>,1,util\hash.cc,util\hash.cc:<global>,,false,1,<global>,4
91143,TYPE_DECL,,util\hash.hpp:<global>,NAMESPACE_BLOCK,<global>,1,util\hash.hpp,util\hash.hpp:<global>,,false,1,<global>,3
91160,TYPE_DECL,,util\hash_test.cc:<global>,NAMESPACE_BLOCK,<global>,1,util\hash_test.cc,util\hash_test.cc:<global>,,false,1,<global>,3
91164,TYPE_DECL,,,,class HASH { },1,util\hash_test.cc,leveldb.HASH,,false,10,HASH,1
91165,TYPE_DECL,,,,_Test_SignedUnsignedIssue,1,util\hash_test.cc,leveldb._Test_SignedUnsignedIssue,HASH,false,12,_Test_SignedUnsignedIssue,2
91428,TYPE_DECL,,util\histogram.cc:<global>,NAMESPACE_BLOCK,<global>,1,util\histogram.cc,util\histogram.cc:<global>,,false,1,<global>,5
92052,TYPE_DECL,,util\histogram.hpp:<global>,NAMESPACE_BLOCK,<global>,1,util\histogram.hpp,util\histogram.hpp:<global>,,false,1,<global>,2
92056,TYPE_DECL,,,,"class Histogram {
 public:
  Histogram() { }
  ~Histogram() { }

  void Clear();
  void Add(double value);
  void Merge(const Histogram& other);

  std::string ToString() const;

 private:
  double min_;
  double max_;
  double num_;
  double sum_;
  double sum_squares_;

  enum { kNumBuckets = 154 };
  static const double kBucketLimit[kNumBuckets];
  double buckets_[kNumBuckets];

  double Median() const;
  double Percentile(double p) const;
  double Average() const;
  double StandardDeviation() const;
}",1,util\histogram.hpp,leveldb.Histogram,,false,12,Histogram,1
92088,TYPE_DECL,,,,enum { kNumBuckets = 154 },3,util\histogram.hpp,leveldb.Histogram.anonymous_enum_0,,false,30,anonymous_enum_0,12
92140,TYPE_DECL,,util\logging.cc:<global>,NAMESPACE_BLOCK,<global>,1,util\logging.cc,util\logging.cc:<global>,,false,1,<global>,8
92353,TYPE_DECL,,util\logging.hpp:<global>,NAMESPACE_BLOCK,<global>,1,util\logging.hpp,util\logging.hpp:<global>,,false,1,<global>,5
92357,TYPE_DECL,,,,class Slice,1,util\logging.hpp,leveldb.Slice,,false,18,Slice,1
92358,TYPE_DECL,,,,class WritableFile,1,util\logging.hpp,leveldb.WritableFile,,false,19,WritableFile,2
92393,TYPE_DECL,,util\mutexlock.hpp:<global>,NAMESPACE_BLOCK,<global>,1,util\mutexlock.hpp,util\mutexlock.hpp:<global>,,false,1,<global>,3
92397,TYPE_DECL,,,,"class SCOPED_LOCKABLE MutexLock {
 public:
  explicit MutexLock(port::Mutex *mu) EXCLUSIVE_LOCK_FUNCTION(mu)
      : mu_(mu)  {
    this->mu_->Lock();
  }
  ~MutexLock() UNLOCK_FUNCTION() { this->mu_->Unlock(); }

 private:
  port::Mutex *const mu_;
  // No copying allowed
  MutexLock(const MutexLock&);
  void operator=(const MutexLock&);
}",1,util\mutexlock.hpp,leveldb.MutexLock,,false,23,MutexLock,1
92438,TYPE_DECL,,util\options.cc:<global>,NAMESPACE_BLOCK,<global>,1,util\options.cc,util\options.cc:<global>,,false,1,<global>,4
92458,TYPE_DECL,,util\posix_logger.hpp:<global>,NAMESPACE_BLOCK,<global>,1,util\posix_logger.hpp,util\posix_logger.hpp:<global>,,false,1,<global>,6
92462,TYPE_DECL,,,,"class PosixLogger : public Logger {
 private:
  FILE* file_;
  uint64_t (*gettid_)();  // Return the thread id for the current thread
 public:
  PosixLogger(FILE* f, uint64_t (*gettid)()) : file_(f), gettid_(gettid) { }
  virtual ~PosixLogger() {
    fclose(file_);
  }
  virtual void Logv(const char* format, va_list ap) {
    const uint64_t thread_id = (*gettid_)();

    // We try twice: the first time with a fixed-size stack allocated buffer,
    // and the second time with a much larger dynamically allocated buffer.
    char buffer[500];
    for (int iter = 0; iter < 2; iter++) {
      char* base;
      int bufsize;
      if (iter == 0) {
        bufsize = sizeof(buffer);
        base = buffer;
      } else {
        bufsize = 30000;
        base = new char[bufsize];
      }
      char* p = base;
      char* limit = base + bufsize;

      struct timeval now_tv;
      gettimeofday(&now_tv, NULL);
      const time_t seconds = now_tv.tv_sec;
      struct tm t;
      localtime_r(&seco...",1,util\posix_logger.hpp,leveldb.PosixLogger,Logger,false,19,PosixLogger,1
92673,TYPE_DECL,,util\random.hpp:<global>,NAMESPACE_BLOCK,<global>,1,util\random.hpp,util\random.hpp:<global>,,false,1,<global>,2
92677,TYPE_DECL,,,,"class Random {
 private:
  uint32_t seed_;
 public:
  explicit Random(uint32_t s) : seed_(s & 0x7fffffffu) {
    // Avoid bad seeds.
    if (seed_ == 0 || seed_ == 2147483647L) {
      seed_ = 1;
    }
  }
  uint32_t Next() {
    static const uint32_t M = 2147483647L;   // 2^31-1
    static const uint64_t A = 16807;  // bits 14, 8, 7, 5, 2, 1, 0
    // We are computing
    //       seed_ = (seed_ * A) % M,    where M = 2^31-1
    //
    // seed_ must not be zero or M, or else all subsequent computed values
    // will be zero or M respectively.  For all other values, seed_ will end
    // up cycling through every number in [1,M-1]
    uint64_t product = seed_ * A;

    // Compute (product % M) using the fact that ((x << 31) % M) == x.
    seed_ = static_cast<uint32_t>((product >> 31) + (product & M));
    // The first reduction may overflow by 1 bit, so we may need to
    // repeat.  mod == M is not possible; using > allows the faster
    // sign-bit-based test.
    if (seed_ > M) {...",1,util\random.hpp,leveldb.Random,,false,15,Random,1
92776,TYPE_DECL,,util\status.cc:<global>,NAMESPACE_BLOCK,<global>,1,util\status.cc,util\status.cc:<global>,,false,1,<global>,4
92998,TYPE_DECL,,util\testharness.cc:<global>,NAMESPACE_BLOCK,<global>,1,util\testharness.cc,util\testharness.cc:<global>,,false,1,<global>,6
93004,TYPE_DECL,,,,"struct Test {
  const char* base;
  const char* name;
  void (*func)();
}",1,util\testharness.cc,leveldb.test.anonymous_namespace_1.Test,,false,16,Test,1
93236,TYPE_DECL,,util\testharness.hpp:<global>,NAMESPACE_BLOCK,<global>,1,util\testharness.hpp,util\testharness.hpp:<global>,,false,1,<global>,7
93253,TYPE_DECL,,,,"class Tester {
 private:
  bool ok_;
  const char* fname_;
  int line_;
  std::stringstream ss_;

 public:
  Tester(const char* f, int l)
      : ok_(true), fname_(f), line_(l) {
  }

  ~Tester() {
    if (!ok_) {
      fprintf(stderr, ""%s:%d:%s\n"", fname_, line_, ss_.str().c_str());
      exit(1);
    }
  }

  Tester& Is(bool b, const char* msg) {
    if (!b) {
      ss_ << "" Assertion failure "" << msg;
      ok_ = false;
    }
    return *this;
  }

  Tester& IsOk(const Status& s) {
    if (!s.ok()) {
      ss_ << "" "" << s.ToString();
      ok_ = false;
    }
    return *this;
  }

#define BINARY_OP(name,op)                              \
  template <class X, class Y>                           \
  Tester& name(const X& x, const Y& y) {                \
    if (! (x op y)) {                                   \
      ss_ << "" failed: "" << x << ("" "" #op "" "") << y;    \
      ok_ = false;                                      \
    }                                                   \
...",1,util\testharness.hpp,leveldb.test.Tester,,false,42,Tester,4
93525,TYPE_DECL,,util\testutil.cc:<global>,NAMESPACE_BLOCK,<global>,1,util\testutil.cc,util\testutil.cc:<global>,,false,1,<global>,3
93681,TYPE_DECL,,util\testutil.hpp:<global>,NAMESPACE_BLOCK,<global>,1,util\testutil.hpp,util\testutil.hpp:<global>,,false,1,<global>,4
93707,TYPE_DECL,,,,"class ErrorEnv : public EnvWrapper {
 public:
  bool writable_file_error_;
  int num_writable_file_errors_;

  ErrorEnv() : EnvWrapper(Env::Default()),
               writable_file_error_(false),
               num_writable_file_errors_(0) { }

  virtual Status NewWritableFile(const std::string& fname,
                                 WritableFile** result) {
    if (writable_file_error_) {
      ++num_writable_file_errors_;
      *result = NULL;
      return Status::IOError(fname, ""fake error"");
    }
    return target()->NewWritableFile(fname, result);
  }

  virtual Status NewAppendableFile(const std::string& fname,
                                   WritableFile** result) {
    if (writable_file_error_) {
      ++num_writable_file_errors_;
      *result = NULL;
      return Status::IOError(fname, ""fake error"");
    }
    return target()->NewAppendableFile(fname, result);
  }
}",1,util\testutil.hpp,leveldb.test.ErrorEnv,EnvWrapper,false,30,ErrorEnv,4
94873,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,ANY,,<includes>,ANY,,true,,ANY,-1
94874,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,ANY*,,<includes>,ANY*,,true,,ANY*,-1
94875,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,ANY**,,<includes>,ANY**,,true,,ANY**,-1
94876,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Arena,,<includes>,Arena,,true,,Arena,-1
94877,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Arena*,,<includes>,Arena*,,true,,Arena*,-1
94878,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,ArenaTest,,<includes>,ArenaTest,,true,,ArenaTest,-1
94879,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,AtomicCounter,,<includes>,AtomicCounter,,true,,AtomicCounter,-1
94880,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,AutoCompactTest,,<includes>,AutoCompactTest,,true,,AutoCompactTest,-1
94881,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Benchmark,,<includes>,Benchmark,,true,,Benchmark,-1
94882,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Benchmark*,,<includes>,Benchmark*,,true,,Benchmark*,-1
94883,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Block,,<includes>,Block,,true,,Block,-1
94884,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Block*,,<includes>,Block*,,true,,Block*,-1
94885,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,BlockBuilder,,<includes>,BlockBuilder,,true,,BlockBuilder,-1
94886,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,BlockBuilder*,,<includes>,BlockBuilder*,,true,,BlockBuilder*,-1
94887,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,BlockConstructor,,<includes>,BlockConstructor,,true,,BlockConstructor,-1
94888,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,BlockContents,,<includes>,BlockContents,,true,,BlockContents,-1
94889,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,BlockContents*,,<includes>,BlockContents*,,true,,BlockContents*,-1
94890,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,BlockFunction,,<includes>,BlockFunction,,true,,BlockFunction,-1
94891,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,BlockHandle,,<includes>,BlockHandle,,true,,BlockHandle,-1
94892,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,BlockHandle*,,<includes>,BlockHandle*,,true,,BlockHandle*,-1
94893,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,BloomFilterPolicy,,<includes>,BloomFilterPolicy,,true,,BloomFilterPolicy,-1
94894,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,BloomTest,,<includes>,BloomTest,,true,,BloomTest,-1
94895,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Builder,,<includes>,Builder,,true,,Builder,-1
94896,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,BySmallestKey,,<includes>,BySmallestKey,,true,,BySmallestKey,-1
94897,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,BytewiseComparatorImpl,,<includes>,BytewiseComparatorImpl,,true,,BytewiseComparatorImpl,-1
94898,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,CB,,<includes>,CB,,true,,CB,-1
94899,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,CRC,,<includes>,CRC,,true,,CRC,-1
94900,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Cache,,<includes>,Cache,,true,,Cache,-1
94901,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Cache*,,<includes>,Cache*,,true,,Cache*,-1
94902,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,CacheTest,,<includes>,CacheTest,,true,,CacheTest,-1
94903,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,CacheTest*,,<includes>,CacheTest*,,true,,CacheTest*,-1
94904,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Cleanup,,<includes>,Cleanup,,true,,Cleanup,-1
94905,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Cleanup*,,<includes>,Cleanup*,,true,,Cleanup*,-1
94906,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,CleanupFunction,,<includes>,CleanupFunction,,true,,CleanupFunction,-1
94907,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Code,,<includes>,Code,,true,,Code,-1
94908,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Coding,,<includes>,Coding,,true,,Coding,-1
94909,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Compaction,,<includes>,Compaction,,true,,Compaction,-1
94910,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Compaction*,,<includes>,Compaction*,,true,,Compaction*,-1
94911,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,CompactionState,,<includes>,CompactionState,,true,,CompactionState,-1
94912,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,CompactionState*,,<includes>,CompactionState*,,true,,CompactionState*,-1
94913,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,CompactionStats,,<includes>,CompactionStats,,true,,CompactionStats,-1
94914,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Comparator,,<includes>,Comparator,,true,,Comparator,-1
94915,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Comparator*,,<includes>,Comparator*,,true,,Comparator*,-1
94916,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,CompressionType,,<includes>,CompressionType,,true,,CompressionType,-1
94917,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,ConcurrentTest,,<includes>,ConcurrentTest,,true,,ConcurrentTest,-1
94918,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,CondVar,,<includes>,CondVar,,true,,CondVar,-1
94919,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Constructor,,<includes>,Constructor,,true,,Constructor,-1
94920,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Constructor*,,<includes>,Constructor*,,true,,Constructor*,-1
94921,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,CorruptionReporter,,<includes>,CorruptionReporter,,true,,CorruptionReporter,-1
94922,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,CorruptionTest,,<includes>,CorruptionTest,,true,,CorruptionTest,-1
94923,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,CountingFile,,<includes>,CountingFile,,true,,CountingFile,-1
94924,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,DB,,<includes>,DB,,true,,DB,-1
94925,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,DB*,,<includes>,DB*,,true,,DB*,-1
94926,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,DB**,,<includes>,DB**,,true,,DB**,-1
94927,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,DBConstructor,,<includes>,DBConstructor,,true,,DBConstructor,-1
94928,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,DBImpl,,<includes>,DBImpl,,true,,DBImpl,-1
94929,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,DBImpl*,,<includes>,DBImpl*,,true,,DBImpl*,-1
94930,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,DBIter,,<includes>,DBIter,,true,,DBIter,-1
94931,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,DBState,,<includes>,DBState,,true,,DBState,-1
94932,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,DBTest,,<includes>,DBTest,,true,,DBTest,-1
94933,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,DBTest*,,<includes>,DBTest*,,true,,DBTest*,-1
94934,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,DIR*,,<includes>,DIR*,,true,,DIR*,-1
94935,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,DataFile,,<includes>,DataFile,,true,,DataFile,-1
94936,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Direction,,<includes>,Direction,,true,,Direction,-1
94937,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,EmptyIterator,,<includes>,EmptyIterator,,true,,EmptyIterator,-1
94938,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Env,,<includes>,Env,,true,,Env,-1
94939,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Env*,,<includes>,Env*,,true,,Env*,-1
94940,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,EnvPosixTest,,<includes>,EnvPosixTest,,true,,EnvPosixTest,-1
94941,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,EnvPosixTestHelper,,<includes>,EnvPosixTestHelper,,true,,EnvPosixTestHelper,-1
94942,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,EnvTest,,<includes>,EnvTest,,true,,EnvTest,-1
94943,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,EnvWrapper,,<includes>,EnvWrapper,,true,,EnvWrapper,-1
94944,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,ErrorEnv,,<includes>,ErrorEnv,,true,,ErrorEnv,-1
94945,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,ExpectedVerifResult,,<includes>,ExpectedVerifResult,,true,,ExpectedVerifResult,-1
94946,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,FILE*,,<includes>,FILE*,,true,,FILE*,-1
94947,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,FaultInjectionTest,,<includes>,FaultInjectionTest,,true,,FaultInjectionTest,-1
94948,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,FaultInjectionTestEnv,,<includes>,FaultInjectionTestEnv,,true,,FaultInjectionTestEnv,-1
94949,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,FaultInjectionTestEnv*,,<includes>,FaultInjectionTestEnv*,,true,,FaultInjectionTestEnv*,-1
94950,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,FileLock,,<includes>,FileLock,,true,,FileLock,-1
94951,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,FileLock*,,<includes>,FileLock*,,true,,FileLock*,-1
94952,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,FileLock**,,<includes>,FileLock**,,true,,FileLock**,-1
94953,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,FileMetaData,,<includes>,FileMetaData,,true,,FileMetaData,-1
94954,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,FileMetaData*,,<includes>,FileMetaData*,,true,,FileMetaData*,-1
94955,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,FileMetaData**,,<includes>,FileMetaData**,,true,,FileMetaData**,-1
94956,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,FileNameTest,,<includes>,FileNameTest,,true,,FileNameTest,-1
94957,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,FileSet*,,<includes>,FileSet*,,true,,FileSet*,-1
94958,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,FileState,,<includes>,FileState,,true,,FileState,-1
94959,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,FileState*,,<includes>,FileState*,,true,,FileState*,-1
94960,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,FileState**,,<includes>,FileState**,,true,,FileState**,-1
94961,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,FileType,,<includes>,FileType,,true,,FileType,-1
94962,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,FileType*,,<includes>,FileType*,,true,,FileType*,-1
94963,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,FilterBlockBuilder,,<includes>,FilterBlockBuilder,,true,,FilterBlockBuilder,-1
94964,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,FilterBlockBuilder*,,<includes>,FilterBlockBuilder*,,true,,FilterBlockBuilder*,-1
94965,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,FilterBlockReader,,<includes>,FilterBlockReader,,true,,FilterBlockReader,-1
94966,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,FilterBlockReader*,,<includes>,FilterBlockReader*,,true,,FilterBlockReader*,-1
94967,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,FilterBlockTest,,<includes>,FilterBlockTest,,true,,FilterBlockTest,-1
94968,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,FilterPolicy,,<includes>,FilterPolicy,,true,,FilterPolicy,-1
94969,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,FilterPolicy*,,<includes>,FilterPolicy*,,true,,FilterPolicy*,-1
94970,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,FindFileTest,,<includes>,FindFileTest,,true,,FindFileTest,-1
94971,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Footer,,<includes>,Footer,,true,,Footer,-1
94972,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,FormatTest,,<includes>,FormatTest,,true,,FormatTest,-1
94973,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,GetStats,,<includes>,GetStats,,true,,GetStats,-1
94974,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,GetStats*,,<includes>,GetStats*,,true,,GetStats*,-1
94975,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,H,,<includes>,H,,true,,H,-1
94976,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,HASH,,<includes>,HASH,,true,,HASH,-1
94977,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Handle,,<includes>,Handle,,true,,Handle,-1
94978,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Handle*,,<includes>,Handle*,,true,,Handle*,-1
94979,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,HandleTable,,<includes>,HandleTable,,true,,HandleTable,-1
94980,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Handler,,<includes>,Handler,,true,,Handler,-1
94981,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Handler*,,<includes>,Handler*,,true,,Handler*,-1
94982,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Harness,,<includes>,Harness,,true,,Harness,-1
94983,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Histogram,,<includes>,Histogram,,true,,Histogram,-1
94984,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,InMemoryEnv,,<includes>,InMemoryEnv,,true,,InMemoryEnv,-1
94985,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,InternalFilterPolicy,,<includes>,InternalFilterPolicy,,true,,InternalFilterPolicy,-1
94986,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,InternalFilterPolicy*,,<includes>,InternalFilterPolicy*,,true,,InternalFilterPolicy*,-1
94987,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,InternalKey,,<includes>,InternalKey,,true,,InternalKey,-1
94988,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,InternalKey*,,<includes>,InternalKey*,,true,,InternalKey*,-1
94989,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,InternalKeyComparator,,<includes>,InternalKeyComparator,,true,,InternalKeyComparator,-1
94990,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,InternalKeyComparator*,,<includes>,InternalKeyComparator*,,true,,InternalKeyComparator*,-1
94991,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Issue178,,<includes>,Issue178,,true,,Issue178,-1
94992,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Issue200,,<includes>,Issue200,,true,,Issue200,-1
94993,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Iter,,<includes>,Iter,,true,,Iter,-1
94994,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,IterState,,<includes>,IterState,,true,,IterState,-1
94995,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,IterState*,,<includes>,IterState*,,true,,IterState*,-1
94996,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Iterator,,<includes>,Iterator,,true,,Iterator,-1
94997,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Iterator*,,<includes>,Iterator*,,true,,Iterator*,-1
94998,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Iterator**,,<includes>,Iterator**,,true,,Iterator**,-1
94999,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,IteratorWrapper,,<includes>,IteratorWrapper,,true,,IteratorWrapper,-1
95000,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,IteratorWrapper*,,<includes>,IteratorWrapper*,,true,,IteratorWrapper*,-1
95001,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,KVMap*,,<includes>,KVMap*,,true,,KVMap*,-1
95002,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,KeyComparator,,<includes>,KeyComparator,,true,,KeyComparator,-1
95003,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,KeyConvertingIterator,,<includes>,KeyConvertingIterator,,true,,KeyConvertingIterator,-1
95004,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,LRUCache,,<includes>,LRUCache,,true,,LRUCache,-1
95005,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,LRUHandle,,<includes>,LRUHandle,,true,,LRUHandle,-1
95006,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,LRUHandle*,,<includes>,LRUHandle*,,true,,LRUHandle*,-1
95007,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,LRUHandle**,,<includes>,LRUHandle**,,true,,LRUHandle**,-1
95008,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,LevelFileNumIterator,,<includes>,LevelFileNumIterator,,true,,LevelFileNumIterator,-1
95009,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,LevelSummaryStorage*,,<includes>,LevelSummaryStorage*,,true,,LevelSummaryStorage*,-1
95010,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Limiter,,<includes>,Limiter,,true,,Limiter,-1
95011,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Limiter*,,<includes>,Limiter*,,true,,Limiter*,-1
95012,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,LogReporter,,<includes>,LogReporter,,true,,LogReporter,-1
95013,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,LogTest,,<includes>,LogTest,,true,,LogTest,-1
95014,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Logger,,<includes>,Logger,,true,,Logger,-1
95015,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Logger*,,<includes>,Logger*,,true,,Logger*,-1
95016,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Logger**,,<includes>,Logger**,,true,,Logger**,-1
95017,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,LookupKey,,<includes>,LookupKey,,true,,LookupKey,-1
95018,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,MTState,,<includes>,MTState,,true,,MTState,-1
95019,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,MTState*,,<includes>,MTState*,,true,,MTState*,-1
95020,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,MTThread*,,<includes>,MTThread*,,true,,MTThread*,-1
95021,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,ManifestFile,,<includes>,ManifestFile,,true,,ManifestFile,-1
95022,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,ManualCompaction,,<includes>,ManualCompaction,,true,,ManualCompaction,-1
95023,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,ManualCompaction*,,<includes>,ManualCompaction*,,true,,ManualCompaction*,-1
95024,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,MemEnvTest,,<includes>,MemEnvTest,,true,,MemEnvTest,-1
95025,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,MemTable,,<includes>,MemTable,,true,,MemTable,-1
95026,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,MemTable*,,<includes>,MemTable*,,true,,MemTable*,-1
95027,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,MemTableConstructor,,<includes>,MemTableConstructor,,true,,MemTableConstructor,-1
95028,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,MemTableInserter,,<includes>,MemTableInserter,,true,,MemTableInserter,-1
95029,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,MemTableIterator,,<includes>,MemTableIterator,,true,,MemTableIterator,-1
95030,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,MemTableTest,,<includes>,MemTableTest,,true,,MemTableTest,-1
95031,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,MergingIterator,,<includes>,MergingIterator,,true,,MergingIterator,-1
95032,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,ModelDB,,<includes>,ModelDB,,true,,ModelDB,-1
95033,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,ModelIter,,<includes>,ModelIter,,true,,ModelIter,-1
95034,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,ModelSnapshot,,<includes>,ModelSnapshot,,true,,ModelSnapshot,-1
95035,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,ModelSnapshot*,,<includes>,ModelSnapshot*,,true,,ModelSnapshot*,-1
95036,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Mutex,,<includes>,Mutex,,true,,Mutex,-1
95037,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Mutex*,,<includes>,Mutex*,,true,,Mutex*,-1
95038,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,MutexLock,,<includes>,MutexLock,,true,,MutexLock,-1
95039,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,NewComparator,,<includes>,NewComparator,,true,,NewComparator,-1
95040,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,NoOpLogger,,<includes>,NoOpLogger,,true,,NoOpLogger,-1
95041,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Node,,<includes>,Node,,true,,Node,-1
95042,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Node*,,<includes>,Node*,,true,,Node*,-1
95043,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Node**,,<includes>,Node**,,true,,Node**,-1
95044,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,NumberComparator,,<includes>,NumberComparator,,true,,NumberComparator,-1
95045,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,OnceType*,,<includes>,OnceType*,,true,,OnceType*,-1
95046,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Options,,<includes>,Options,,true,,Options,-1
95047,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Options*,,<includes>,Options*,,true,,Options*,-1
95048,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Order,,<includes>,Order,,true,,Order,-1
95049,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Output,,<includes>,Output,,true,,Output,-1
95050,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,ParsedInternalKey,,<includes>,ParsedInternalKey,,true,,ParsedInternalKey,-1
95051,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,ParsedInternalKey*,,<includes>,ParsedInternalKey*,,true,,ParsedInternalKey*,-1
95052,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,PolyDB,,<includes>,PolyDB,,true,,PolyDB,-1
95053,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,PosixEnv,,<includes>,PosixEnv,,true,,PosixEnv,-1
95054,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,PosixFileLock,,<includes>,PosixFileLock,,true,,PosixFileLock,-1
95055,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,PosixFileLock*,,<includes>,PosixFileLock*,,true,,PosixFileLock*,-1
95056,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,PosixLockTable,,<includes>,PosixLockTable,,true,,PosixLockTable,-1
95057,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,PosixLogger,,<includes>,PosixLogger,,true,,PosixLogger,-1
95058,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,PosixMmapReadableFile,,<includes>,PosixMmapReadableFile,,true,,PosixMmapReadableFile,-1
95059,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,PosixRandomAccessFile,,<includes>,PosixRandomAccessFile,,true,,PosixRandomAccessFile,-1
95060,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,PosixSequentialFile,,<includes>,PosixSequentialFile,,true,,PosixSequentialFile,-1
95061,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,PosixWritableFile,,<includes>,PosixWritableFile,,true,,PosixWritableFile,-1
95062,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Random,,<includes>,Random,,true,,Random,-1
95063,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Random*,,<includes>,Random*,,true,,Random*,-1
95064,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RandomAccessFile,,<includes>,RandomAccessFile,,true,,RandomAccessFile,-1
95065,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RandomAccessFile*,,<includes>,RandomAccessFile*,,true,,RandomAccessFile*,-1
95066,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RandomAccessFile**,,<includes>,RandomAccessFile**,,true,,RandomAccessFile**,-1
95067,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RandomAccessFileImpl,,<includes>,RandomAccessFileImpl,,true,,RandomAccessFileImpl,-1
95068,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RandomGenerator,,<includes>,RandomGenerator,,true,,RandomGenerator,-1
95069,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Range,,<includes>,Range,,true,,Range,-1
95070,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Range*,,<includes>,Range*,,true,,Range*,-1
95071,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,ReadOptions,,<includes>,ReadOptions,,true,,ReadOptions,-1
95072,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Reader,,<includes>,Reader,,true,,Reader,-1
95073,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Reader*,,<includes>,Reader*,,true,,Reader*,-1
95074,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Reporter,,<includes>,Reader.Reporter,,true,,Reporter,-1
95075,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,ReaderState,,<includes>,ReaderState,,true,,ReaderState,-1
95076,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RecordType,,<includes>,RecordType,,true,,RecordType,-1
95077,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RecoveryTest,,<includes>,RecoveryTest,,true,,RecoveryTest,-1
95078,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Rep,,<includes>,Rep,,true,,Rep,-1
95079,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Rep*,,<includes>,Rep*,,true,,Rep*,-1
95080,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Repairer,,<includes>,Repairer,,true,,Repairer,-1
95081,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,ReportCollector,,<includes>,ReportCollector,,true,,ReportCollector,-1
95082,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Reporter*,,<includes>,Reporter*,,true,,Reporter*,-1
95083,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,ResetMethod,,<includes>,ResetMethod,,true,,ResetMethod,-1
95084,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,ReverseKeyComparator,,<includes>,ReverseKeyComparator,,true,,ReverseKeyComparator,-1
95085,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Saver,,<includes>,Saver,,true,,Saver,-1
95086,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Saver*,,<includes>,Saver*,,true,,Saver*,-1
95087,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,SaverState,,<includes>,SaverState,,true,,SaverState,-1
95088,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,SequenceNumber*,,<includes>,SequenceNumber*,,true,,SequenceNumber*,-1
95089,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,SequentialFile,,<includes>,SequentialFile,,true,,SequentialFile,-1
95090,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,SequentialFile*,,<includes>,SequentialFile*,,true,,SequentialFile*,-1
95091,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,SequentialFile**,,<includes>,SequentialFile**,,true,,SequentialFile**,-1
95092,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,SequentialFileImpl,,<includes>,SequentialFileImpl,,true,,SequentialFileImpl,-1
95093,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,SetDataIterator,,<includes>,SetDataIterator,,true,,SetDataIterator,-1
95094,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,ShardedLRUCache,,<includes>,ShardedLRUCache,,true,,ShardedLRUCache,-1
95095,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,SharedState,,<includes>,SharedState,,true,,SharedState,-1
95096,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,SharedState*,,<includes>,SharedState*,,true,,SharedState*,-1
95097,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,SkipList,,<includes>,SkipList,,true,,SkipList,-1
95098,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,SkipList*,,<includes>,SkipList*,,true,,SkipList*,-1
95099,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,"SkipList<Key,Comparator>",,<includes>,"SkipList<Key,Comparator>",,true,,"SkipList<Key,Comparator>",-1
95100,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,SkipTest,,<includes>,SkipTest,,true,,SkipTest,-1
95101,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Slice,,<includes>,Slice,,true,,Slice,-1
95102,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Slice*,,<includes>,Slice*,,true,,Slice*,-1
95103,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Snapshot,,<includes>,Snapshot,,true,,Snapshot,-1
95104,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Snapshot*,,<includes>,Snapshot*,,true,,Snapshot*,-1
95105,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,SnapshotImpl,,<includes>,SnapshotImpl,,true,,SnapshotImpl,-1
95106,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,SnapshotImpl*,,<includes>,SnapshotImpl*,,true,,SnapshotImpl*,-1
95107,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,SnapshotList,,<includes>,SnapshotList,,true,,SnapshotList,-1
95108,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,SnapshotList*,,<includes>,SnapshotList*,,true,,SnapshotList*,-1
95109,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,SpecialEnv,,<includes>,SpecialEnv,,true,,SpecialEnv,-1
95110,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,SpecialEnv*,,<includes>,SpecialEnv*,,true,,SpecialEnv*,-1
95111,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,StartThreadState,,<includes>,StartThreadState,,true,,StartThreadState,-1
95112,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,StartThreadState*,,<includes>,StartThreadState*,,true,,StartThreadState*,-1
95113,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,State,,<includes>,State,,true,,State,-1
95114,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,State*,,<includes>,State*,,true,,State*,-1
95115,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Stats,,<includes>,Stats,,true,,Stats,-1
95116,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Status,,<includes>,Status,,true,,Status,-1
95117,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Status*,,<includes>,Status*,,true,,Status*,-1
95118,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,StdoutPrinter,,<includes>,StdoutPrinter,,true,,StdoutPrinter,-1
95119,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,StringDest,,<includes>,StringDest,,true,,StringDest,-1
95120,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,StringSink,,<includes>,StringSink,,true,,StringSink,-1
95121,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,StringSource,,<includes>,StringSource,,true,,StringSource,-1
95122,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,StringSource*,,<includes>,StringSource*,,true,,StringSource*,-1
95123,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,T*,,<includes>,T*,,true,,T*,-1
95124,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Table*,,<includes>,Table*,,true,,Table*,-1
95125,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Table**,,<includes>,Table**,,true,,Table**,-1
95126,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,TableAndFile,,<includes>,TableAndFile,,true,,TableAndFile,-1
95127,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,TableAndFile*,,<includes>,TableAndFile*,,true,,TableAndFile*,-1
95128,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,TableBuilder,,<includes>,TableBuilder,,true,,TableBuilder,-1
95129,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,TableBuilder*,,<includes>,TableBuilder*,,true,,TableBuilder*,-1
95130,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,TableCache,,<includes>,TableCache,,true,,TableCache,-1
95131,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,TableCache*,,<includes>,TableCache*,,true,,TableCache*,-1
95132,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,TableConstructor,,<includes>,TableConstructor,,true,,TableConstructor,-1
95133,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,TableInfo,,<includes>,TableInfo,,true,,TableInfo,-1
95134,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,TableTest,,<includes>,TableTest,,true,,TableTest,-1
95135,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Test,,<includes>,Test,,true,,Test,-1
95136,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,TestArgs,,<includes>,TestArgs,,true,,TestArgs,-1
95137,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,TestHashFilter,,<includes>,TestHashFilter,,true,,TestHashFilter,-1
95138,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,TestState,,<includes>,TestState,,true,,TestState,-1
95139,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,TestState*,,<includes>,TestState*,,true,,TestState*,-1
95140,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,TestType,,<includes>,TestType,,true,,TestType,-1
95141,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,TestWritableFile,,<includes>,TestWritableFile,,true,,TestWritableFile,-1
95142,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Tester,,<includes>,Tester,,true,,Tester,-1
95143,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,ThreadArg,,<includes>,ThreadArg,,true,,ThreadArg,-1
95144,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,ThreadArg*,,<includes>,ThreadArg*,,true,,ThreadArg*,-1
95145,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,ThreadState,,<includes>,ThreadState,,true,,ThreadState,-1
95146,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,ThreadState*,,<includes>,ThreadState*,,true,,ThreadState*,-1
95147,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,TreeDB,,<includes>,TreeDB,,true,,TreeDB,-1
95148,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,TwoLevelIterator,,<includes>,TwoLevelIterator,,true,,TwoLevelIterator,-1
95149,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,V,,<includes>,V,,true,,V,-1
95150,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,ValueType,,<includes>,ValueType,,true,,ValueType,-1
95151,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Version,,<includes>,Version,,true,,Version,-1
95152,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Version*,,<includes>,Version*,,true,,Version*,-1
95153,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,VersionEdit,,<includes>,VersionEdit,,true,,VersionEdit,-1
95154,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,VersionEdit*,,<includes>,VersionEdit*,,true,,VersionEdit*,-1
95155,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,VersionEditTest,,<includes>,VersionEditTest,,true,,VersionEditTest,-1
95156,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,VersionSet,,<includes>,VersionSet,,true,,VersionSet,-1
95157,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,VersionSet*,,<includes>,VersionSet*,,true,,VersionSet*,-1
95158,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Wrapper,,<includes>,Wrapper,,true,,Wrapper,-1
95159,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Wrapper*,,<includes>,Wrapper*,,true,,Wrapper*,-1
95160,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,WritableFile,,<includes>,WritableFile,,true,,WritableFile,-1
95161,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,WritableFile*,,<includes>,WritableFile*,,true,,WritableFile*,-1
95162,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,WritableFile**,,<includes>,WritableFile**,,true,,WritableFile**,-1
95163,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,WritableFileImpl,,<includes>,WritableFileImpl,,true,,WritableFileImpl,-1
95164,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,WriteBatch,,<includes>,WriteBatch,,true,,WriteBatch,-1
95165,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,WriteBatch*,,<includes>,WriteBatch*,,true,,WriteBatch*,-1
95166,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Handler,,<includes>,WriteBatch.Handler,,true,,Handler,-1
95167,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,WriteBatchInternal,,<includes>,WriteBatchInternal,,true,,WriteBatchInternal,-1
95168,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,WriteBatchItemPrinter,,<includes>,WriteBatchItemPrinter,,true,,WriteBatchItemPrinter,-1
95169,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,WriteBatchTest,,<includes>,WriteBatchTest,,true,,WriteBatchTest,-1
95170,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,WriteOptions,,<includes>,WriteOptions,,true,,WriteOptions,-1
95171,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Writer,,<includes>,Writer,,true,,Writer,-1
95172,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Writer*,,<includes>,Writer*,,true,,Writer*,-1
95173,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Writer**,,<includes>,Writer**,,true,,Writer**,-1
95174,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,X,,<includes>,X,,true,,X,-1
95175,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Y,,<includes>,Y,,true,,Y,-1
95176,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_AlignedEof,,<includes>,_Test_AlignedEof,,true,,_Test_AlignedEof,-1
95177,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_Append,,<includes>,_Test_Append,,true,,_Test_Append,-1
95178,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_ApproximateOffsetOfCompressed,,<includes>,_Test_ApproximateOffsetOfCompressed,,true,,_Test_ApproximateOffsetOfCompressed,-1
95179,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_ApproximateOffsetOfPlain,,<includes>,_Test_ApproximateOffsetOfPlain,,true,,_Test_ApproximateOffsetOfPlain,-1
95180,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_ApproximateSizes,,<includes>,_Test_ApproximateSizes,,true,,_Test_ApproximateSizes,-1
95181,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_ApproximateSizes_MixOfSmallAndLarge,,<includes>,_Test_ApproximateSizes_MixOfSmallAndLarge,,true,,_Test_ApproximateSizes_MixOfSmallAndLarge,-1
95182,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_BadLength,,<includes>,_Test_BadLength,,true,,_Test_BadLength,-1
95183,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_BadLengthAtEndIsIgnored,,<includes>,_Test_BadLengthAtEndIsIgnored,,true,,_Test_BadLengthAtEndIsIgnored,-1
95184,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_BadRecordType,,<includes>,_Test_BadRecordType,,true,,_Test_BadRecordType,-1
95185,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_Basics,,<includes>,_Test_Basics,,true,,_Test_Basics,-1
95186,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_BloomFilter,,<includes>,_Test_BloomFilter,,true,,_Test_BloomFilter,-1
95187,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_ChecksumMismatch,,<includes>,_Test_ChecksumMismatch,,true,,_Test_ChecksumMismatch,-1
95188,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_CompactionInputError,,<includes>,_Test_CompactionInputError,,true,,_Test_CompactionInputError,-1
95189,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_CompactionInputErrorParanoid,,<includes>,_Test_CompactionInputErrorParanoid,,true,,_Test_CompactionInputErrorParanoid,-1
95190,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_CompactionsGenerateMultipleFiles,,<includes>,_Test_CompactionsGenerateMultipleFiles,,true,,_Test_CompactionsGenerateMultipleFiles,-1
95191,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_ComparatorCheck,,<includes>,_Test_ComparatorCheck,,true,,_Test_ComparatorCheck,-1
95192,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_Concurrent1,,<includes>,_Test_Concurrent1,,true,,_Test_Concurrent1,-1
95193,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_Concurrent2,,<includes>,_Test_Concurrent2,,true,,_Test_Concurrent2,-1
95194,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_Concurrent3,,<includes>,_Test_Concurrent3,,true,,_Test_Concurrent3,-1
95195,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_Concurrent4,,<includes>,_Test_Concurrent4,,true,,_Test_Concurrent4,-1
95196,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_Concurrent5,,<includes>,_Test_Concurrent5,,true,,_Test_Concurrent5,-1
95197,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_ConcurrentWithoutThreads,,<includes>,_Test_ConcurrentWithoutThreads,,true,,_Test_ConcurrentWithoutThreads,-1
95198,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_Construction,,<includes>,_Test_Construction,,true,,_Test_Construction,-1
95199,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_CorruptedDescriptor,,<includes>,_Test_CorruptedDescriptor,,true,,_Test_CorruptedDescriptor,-1
95200,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_Corruption,,<includes>,_Test_Corruption,,true,,_Test_Corruption,-1
95201,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_CustomComparator,,<includes>,_Test_CustomComparator,,true,,_Test_CustomComparator,-1
95202,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_DBOpen_Options,,<includes>,_Test_DBOpen_Options,,true,,_Test_DBOpen_Options,-1
95203,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_DBTest,,<includes>,_Test_DBTest,,true,,_Test_DBTest,-1
95204,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_DeletionMarkers1,,<includes>,_Test_DeletionMarkers1,,true,,_Test_DeletionMarkers1,-1
95205,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_DeletionMarkers2,,<includes>,_Test_DeletionMarkers2,,true,,_Test_DeletionMarkers2,-1
95206,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_Empty,,<includes>,_Test_Empty,,true,,_Test_Empty,-1
95207,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_EmptyBuilder,,<includes>,_Test_EmptyBuilder,,true,,_Test_EmptyBuilder,-1
95208,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_EmptyFilter,,<includes>,_Test_EmptyFilter,,true,,_Test_EmptyFilter,-1
95209,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_EncodeDecode,,<includes>,_Test_EncodeDecode,,true,,_Test_EncodeDecode,-1
95210,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_EncodingOutput,,<includes>,_Test_EncodingOutput,,true,,_Test_EncodingOutput,-1
95211,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_EntriesArePinned,,<includes>,_Test_EntriesArePinned,,true,,_Test_EntriesArePinned,-1
95212,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_Erase,,<includes>,_Test_Erase,,true,,_Test_Erase,-1
95213,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_ErrorJoinsRecords,,<includes>,_Test_ErrorJoinsRecords,,true,,_Test_ErrorJoinsRecords,-1
95214,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_EvictionPolicy,,<includes>,_Test_EvictionPolicy,,true,,_Test_EvictionPolicy,-1
95215,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_Extend,,<includes>,_Test_Extend,,true,,_Test_Extend,-1
95216,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_FaultTestNoLogReuse,,<includes>,_Test_FaultTestNoLogReuse,,true,,_Test_FaultTestNoLogReuse,-1
95217,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_FaultTestWithLogReuse,,<includes>,_Test_FaultTestWithLogReuse,,true,,_Test_FaultTestWithLogReuse,-1
95218,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_FilesDeletedAfterCompaction,,<includes>,_Test_FilesDeletedAfterCompaction,,true,,_Test_FilesDeletedAfterCompaction,-1
95219,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_Fixed32,,<includes>,_Test_Fixed32,,true,,_Test_Fixed32,-1
95220,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_Fixed64,,<includes>,_Test_Fixed64,,true,,_Test_Fixed64,-1
95221,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_Fragmentation,,<includes>,_Test_Fragmentation,,true,,_Test_Fragmentation,-1
95222,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_GetEncountersEmptyLevel,,<includes>,_Test_GetEncountersEmptyLevel,,true,,_Test_GetEncountersEmptyLevel,-1
95223,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_GetFromImmutableLayer,,<includes>,_Test_GetFromImmutableLayer,,true,,_Test_GetFromImmutableLayer,-1
95224,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_GetFromVersions,,<includes>,_Test_GetFromVersions,,true,,_Test_GetFromVersions,-1
95225,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_GetLevel0Ordering,,<includes>,_Test_GetLevel0Ordering,,true,,_Test_GetLevel0Ordering,-1
95226,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_GetMemUsage,,<includes>,_Test_GetMemUsage,,true,,_Test_GetMemUsage,-1
95227,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_GetOrderedByLevels,,<includes>,_Test_GetOrderedByLevels,,true,,_Test_GetOrderedByLevels,-1
95228,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_GetPicksCorrectFile,,<includes>,_Test_GetPicksCorrectFile,,true,,_Test_GetPicksCorrectFile,-1
95229,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_GetSnapshot,,<includes>,_Test_GetSnapshot,,true,,_Test_GetSnapshot,-1
95230,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_HeavyEntries,,<includes>,_Test_HeavyEntries,,true,,_Test_HeavyEntries,-1
95231,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_HiddenValuesAreRemoved,,<includes>,_Test_HiddenValuesAreRemoved,,true,,_Test_HiddenValuesAreRemoved,-1
95232,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_HitAndMiss,,<includes>,_Test_HitAndMiss,,true,,_Test_HitAndMiss,-1
95233,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_InsertAndLookup,,<includes>,_Test_InsertAndLookup,,true,,_Test_InsertAndLookup,-1
95234,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_InternalKeyShortSeparator,,<includes>,_Test_InternalKeyShortSeparator,,true,,_Test_InternalKeyShortSeparator,-1
95235,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_InternalKeyShortestSuccessor,,<includes>,_Test_InternalKeyShortestSuccessor,,true,,_Test_InternalKeyShortestSuccessor,-1
95236,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_InternalKey_EncodeDecode,,<includes>,_Test_InternalKey_EncodeDecode,,true,,_Test_InternalKey_EncodeDecode,-1
95237,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_IterEmpty,,<includes>,_Test_IterEmpty,,true,,_Test_IterEmpty,-1
95238,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_IterMulti,,<includes>,_Test_IterMulti,,true,,_Test_IterMulti,-1
95239,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_IterMultiWithDelete,,<includes>,_Test_IterMultiWithDelete,,true,,_Test_IterMultiWithDelete,-1
95240,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_IterSingle,,<includes>,_Test_IterSingle,,true,,_Test_IterSingle,-1
95241,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_IterSmallAndLargeMix,,<includes>,_Test_IterSmallAndLargeMix,,true,,_Test_IterSmallAndLargeMix,-1
95242,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_IteratorPinsRef,,<includes>,_Test_IteratorPinsRef,,true,,_Test_IteratorPinsRef,-1
95243,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_L0_CompactionBug_Issue44_a,,<includes>,_Test_L0_CompactionBug_Issue44_a,,true,,_Test_L0_CompactionBug_Issue44_a,-1
95244,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_L0_CompactionBug_Issue44_b,,<includes>,_Test_L0_CompactionBug_Issue44_b,,true,,_Test_L0_CompactionBug_Issue44_b,-1
95245,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_LargeManifestCompacted,,<includes>,_Test_LargeManifestCompacted,,true,,_Test_LargeManifestCompacted,-1
95246,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_LargeWrite,,<includes>,_Test_LargeWrite,,true,,_Test_LargeWrite,-1
95247,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_Locking,,<includes>,_Test_Locking,,true,,_Test_Locking,-1
95248,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_Locks,,<includes>,_Test_Locks,,true,,_Test_Locks,-1
95249,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_LogFileReuse,,<includes>,_Test_LogFileReuse,,true,,_Test_LogFileReuse,-1
95250,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_ManifestReused,,<includes>,_Test_ManifestReused,,true,,_Test_ManifestReused,-1
95251,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_ManifestWriteError,,<includes>,_Test_ManifestWriteError,,true,,_Test_ManifestWriteError,-1
95252,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_ManualCompaction,,<includes>,_Test_ManualCompaction,,true,,_Test_ManualCompaction,-1
95253,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_ManyBlocks,,<includes>,_Test_ManyBlocks,,true,,_Test_ManyBlocks,-1
95254,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_MarginalTrailer,,<includes>,_Test_MarginalTrailer,,true,,_Test_MarginalTrailer,-1
95255,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_MarginalTrailer2,,<includes>,_Test_MarginalTrailer2,,true,,_Test_MarginalTrailer2,-1
95256,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_Mask,,<includes>,_Test_Mask,,true,,_Test_Mask,-1
95257,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_MinorCompactionsHappen,,<includes>,_Test_MinorCompactionsHappen,,true,,_Test_MinorCompactionsHappen,-1
95258,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_Misc,,<includes>,_Test_Misc,,true,,_Test_Misc,-1
95259,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_MissingDescriptor,,<includes>,_Test_MissingDescriptor,,true,,_Test_MissingDescriptor,-1
95260,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_MissingLastIsIgnored,,<includes>,_Test_MissingLastIsIgnored,,true,,_Test_MissingLastIsIgnored,-1
95261,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_MissingSSTFile,,<includes>,_Test_MissingSSTFile,,true,,_Test_MissingSSTFile,-1
95262,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_MultiChunk,,<includes>,_Test_MultiChunk,,true,,_Test_MultiChunk,-1
95263,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_MultiThreaded,,<includes>,_Test_MultiThreaded,,true,,_Test_MultiThreaded,-1
95264,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_Multiple,,<includes>,_Test_Multiple,,true,,_Test_Multiple,-1
95265,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_MultipleLogFiles,,<includes>,_Test_MultipleLogFiles,,true,,_Test_MultipleLogFiles,-1
95266,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_MultipleMemTables,,<includes>,_Test_MultipleMemTables,,true,,_Test_MultipleMemTables,-1
95267,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_MultipleNullBoundaries,,<includes>,_Test_MultipleNullBoundaries,,true,,_Test_MultipleNullBoundaries,-1
95268,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_NewFileErrorDuringWrite,,<includes>,_Test_NewFileErrorDuringWrite,,true,,_Test_NewFileErrorDuringWrite,-1
95269,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_NewId,,<includes>,_Test_NewId,,true,,_Test_NewId,-1
95270,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_NoLogFiles,,<includes>,_Test_NoLogFiles,,true,,_Test_NoLogFiles,-1
95271,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_NoSpace,,<includes>,_Test_NoSpace,,true,,_Test_NoSpace,-1
95272,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_NonWritableFileSystem,,<includes>,_Test_NonWritableFileSystem,,true,,_Test_NonWritableFileSystem,-1
95273,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_OpenForAppend,,<includes>,_Test_OpenForAppend,,true,,_Test_OpenForAppend,-1
95274,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_OverlapInLevel0,,<includes>,_Test_OverlapInLevel0,,true,,_Test_OverlapInLevel0,-1
95275,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_OverlapSequenceChecks,,<includes>,_Test_OverlapSequenceChecks,,true,,_Test_OverlapSequenceChecks,-1
95276,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_OverlappingFiles,,<includes>,_Test_OverlappingFiles,,true,,_Test_OverlappingFiles,-1
95277,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_Parse,,<includes>,_Test_Parse,,true,,_Test_Parse,-1
95278,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_PartialLastIsIgnored,,<includes>,_Test_PartialLastIsIgnored,,true,,_Test_PartialLastIsIgnored,-1
95279,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_Prune,,<includes>,_Test_Prune,,true,,_Test_Prune,-1
95280,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_PutDeleteGet,,<includes>,_Test_PutDeleteGet,,true,,_Test_PutDeleteGet,-1
95281,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_RandomRead,,<includes>,_Test_RandomRead,,true,,_Test_RandomRead,-1
95282,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_Randomized,,<includes>,_Test_Randomized,,true,,_Test_Randomized,-1
95283,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_RandomizedLongDB,,<includes>,_Test_RandomizedLongDB,,true,,_Test_RandomizedLongDB,-1
95284,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_ReadAll,,<includes>,_Test_ReadAll,,true,,_Test_ReadAll,-1
95285,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_ReadEnd,,<includes>,_Test_ReadEnd,,true,,_Test_ReadEnd,-1
95286,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_ReadError,,<includes>,_Test_ReadError,,true,,_Test_ReadError,-1
95287,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_ReadFourthFirstBlockTrailer,,<includes>,_Test_ReadFourthFirstBlockTrailer,,true,,_Test_ReadFourthFirstBlockTrailer,-1
95288,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_ReadFourthLastBlock,,<includes>,_Test_ReadFourthLastBlock,,true,,_Test_ReadFourthLastBlock,-1
95289,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_ReadFourthMiddleBlock,,<includes>,_Test_ReadFourthMiddleBlock,,true,,_Test_ReadFourthMiddleBlock,-1
95290,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_ReadFourthOneOff,,<includes>,_Test_ReadFourthOneOff,,true,,_Test_ReadFourthOneOff,-1
95291,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_ReadFourthStart,,<includes>,_Test_ReadFourthStart,,true,,_Test_ReadFourthStart,-1
95292,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_ReadHalf,,<includes>,_Test_ReadHalf,,true,,_Test_ReadHalf,-1
95293,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_ReadInitialOffsetIntoBlockPadding,,<includes>,_Test_ReadInitialOffsetIntoBlockPadding,,true,,_Test_ReadInitialOffsetIntoBlockPadding,-1
95294,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_ReadPastEnd,,<includes>,_Test_ReadPastEnd,,true,,_Test_ReadPastEnd,-1
95295,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_ReadSecondOneOff,,<includes>,_Test_ReadSecondOneOff,,true,,_Test_ReadSecondOneOff,-1
95296,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_ReadSecondStart,,<includes>,_Test_ReadSecondStart,,true,,_Test_ReadSecondStart,-1
95297,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_ReadSecondTenThousand,,<includes>,_Test_ReadSecondTenThousand,,true,,_Test_ReadSecondTenThousand,-1
95298,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_ReadStart,,<includes>,_Test_ReadStart,,true,,_Test_ReadStart,-1
95299,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_ReadThirdOneOff,,<includes>,_Test_ReadThirdOneOff,,true,,_Test_ReadThirdOneOff,-1
95300,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_ReadThirdStart,,<includes>,_Test_ReadThirdStart,,true,,_Test_ReadThirdStart,-1
95301,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_ReadWrite,,<includes>,_Test_ReadWrite,,true,,_Test_ReadWrite,-1
95302,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_Recover,,<includes>,_Test_Recover,,true,,_Test_Recover,-1
95303,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_RecoverDuringMemtableCompaction,,<includes>,_Test_RecoverDuringMemtableCompaction,,true,,_Test_RecoverDuringMemtableCompaction,-1
95304,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_RecoverWithLargeLog,,<includes>,_Test_RecoverWithLargeLog,,true,,_Test_RecoverWithLargeLog,-1
95305,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_RecoverWriteError,,<includes>,_Test_RecoverWriteError,,true,,_Test_RecoverWriteError,-1
95306,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_Recovery,,<includes>,_Test_Recovery,,true,,_Test_Recovery,-1
95307,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_RecoveryWithEmptyLog,,<includes>,_Test_RecoveryWithEmptyLog,,true,,_Test_RecoveryWithEmptyLog,-1
95308,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_RepeatedWritesToSameKey,,<includes>,_Test_RepeatedWritesToSameKey,,true,,_Test_RepeatedWritesToSameKey,-1
95309,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_RunImmediately,,<includes>,_Test_RunImmediately,,true,,_Test_RunImmediately,-1
95310,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_RunMany,,<includes>,_Test_RunMany,,true,,_Test_RunMany,-1
95311,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_SequenceNumberRecovery,,<includes>,_Test_SequenceNumberRecovery,,true,,_Test_SequenceNumberRecovery,-1
95312,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_ShortTrailer,,<includes>,_Test_ShortTrailer,,true,,_Test_ShortTrailer,-1
95313,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_SignedUnsignedIssue,,<includes>,_Test_SignedUnsignedIssue,,true,,_Test_SignedUnsignedIssue,-1
95314,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_Simple,,<includes>,_Test_Simple,,true,,_Test_Simple,-1
95315,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_SimpleEmptyKey,,<includes>,_Test_SimpleEmptyKey,,true,,_Test_SimpleEmptyKey,-1
95316,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_SimpleMulti,,<includes>,_Test_SimpleMulti,,true,,_Test_SimpleMulti,-1
95317,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_SimpleSingle,,<includes>,_Test_SimpleSingle,,true,,_Test_SimpleSingle,-1
95318,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_SimpleSpecialKey,,<includes>,_Test_SimpleSpecialKey,,true,,_Test_SimpleSpecialKey,-1
95319,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_Single,,<includes>,_Test_Single,,true,,_Test_Single,-1
95320,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_SingleChunk,,<includes>,_Test_SingleChunk,,true,,_Test_SingleChunk,-1
95321,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_SkipIntoMultiRecord,,<includes>,_Test_SkipIntoMultiRecord,,true,,_Test_SkipIntoMultiRecord,-1
95322,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_Small,,<includes>,_Test_Small,,true,,_Test_Small,-1
95323,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_Snapshot,,<includes>,_Test_Snapshot,,true,,_Test_Snapshot,-1
95324,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_SparseMerge,,<includes>,_Test_SparseMerge,,true,,_Test_SparseMerge,-1
95325,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_StandardResults,,<includes>,_Test_StandardResults,,true,,_Test_StandardResults,-1
95326,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_StartThread,,<includes>,_Test_StartThread,,true,,_Test_StartThread,-1
95327,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_StillReadSST,,<includes>,_Test_StillReadSST,,true,,_Test_StillReadSST,-1
95328,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_Strings,,<includes>,_Test_Strings,,true,,_Test_Strings,-1
95329,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_TableFile,,<includes>,_Test_TableFile,,true,,_Test_TableFile,-1
95330,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_TableFileIndexData,,<includes>,_Test_TableFileIndexData,,true,,_Test_TableFileIndexData,-1
95331,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_TableFileRepair,,<includes>,_Test_TableFileRepair,,true,,_Test_TableFileRepair,-1
95332,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_Test,,<includes>,_Test_Test,,true,,_Test_Test,-1
95333,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_TestOpenOnRead,,<includes>,_Test_TestOpenOnRead,,true,,_Test_TestOpenOnRead,-1
95334,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_TruncatedTrailingRecordIsIgnored,,<includes>,_Test_TruncatedTrailingRecordIsIgnored,,true,,_Test_TruncatedTrailingRecordIsIgnored,-1
95335,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_UnexpectedFirstType,,<includes>,_Test_UnexpectedFirstType,,true,,_Test_UnexpectedFirstType,-1
95336,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_UnexpectedFullType,,<includes>,_Test_UnexpectedFullType,,true,,_Test_UnexpectedFullType,-1
95337,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_UnexpectedLastType,,<includes>,_Test_UnexpectedLastType,,true,,_Test_UnexpectedLastType,-1
95338,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_UnexpectedMiddleType,,<includes>,_Test_UnexpectedMiddleType,,true,,_Test_UnexpectedMiddleType,-1
95339,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_UnrelatedKeys,,<includes>,_Test_UnrelatedKeys,,true,,_Test_UnrelatedKeys,-1
95340,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_UseExceedsCacheSize,,<includes>,_Test_UseExceedsCacheSize,,true,,_Test_UseExceedsCacheSize,-1
95341,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_Values,,<includes>,_Test_Values,,true,,_Test_Values,-1
95342,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_Varint32,,<includes>,_Test_Varint32,,true,,_Test_Varint32,-1
95343,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_Varint32Overflow,,<includes>,_Test_Varint32Overflow,,true,,_Test_Varint32Overflow,-1
95344,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_Varint32Truncation,,<includes>,_Test_Varint32Truncation,,true,,_Test_Varint32Truncation,-1
95345,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_Varint64,,<includes>,_Test_Varint64,,true,,_Test_Varint64,-1
95346,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_Varint64Overflow,,<includes>,_Test_Varint64Overflow,,true,,_Test_Varint64Overflow,-1
95347,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_Varint64Truncation,,<includes>,_Test_Varint64Truncation,,true,,_Test_Varint64Truncation,-1
95348,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_VaryingLengths,,<includes>,_Test_VaryingLengths,,true,,_Test_VaryingLengths,-1
95349,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_WriteSyncError,,<includes>,_Test_WriteSyncError,,true,,_Test_WriteSyncError,-1
95350,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_Test_ZeroRestartPointsInBlock,,<includes>,_Test_ZeroRestartPointsInBlock,,true,,_Test_ZeroRestartPointsInBlock,-1
95351,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,bool,,<includes>,bool,,true,,bool,-1
95352,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,"bool (char , char , void ()())",,<includes>,"bool (char , char , void ()())",,true,,"bool (char , char , void ()())",-1
95353,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,bool*,,<includes>,bool*,,true,,bool*,-1
95354,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char,,<includes>,char,,true,,char,-1
95355,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char*,,<includes>,char*,,true,,char*,-1
95356,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char**,,<includes>,char**,,true,,char**,-1
95357,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[100],,<includes>,char[100],,true,,char[100],-1
95358,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[10],,<includes>,char[10],,true,,char[10],-1
95359,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[11],,<includes>,char[11],,true,,char[11],-1
95360,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[124],,<includes>,char[124],,true,,char[124],-1
95361,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[12],,<includes>,char[12],,true,,char[12],-1
95362,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[13],,<includes>,char[13],,true,,char[13],-1
95363,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[146],,<includes>,char[146],,true,,char[146],-1
95364,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[14],,<includes>,char[14],,true,,char[14],-1
95365,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[1500],,<includes>,char[1500],,true,,char[1500],-1
95366,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[15],,<includes>,char[15],,true,,char[15],-1
95367,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[162],,<includes>,char[162],,true,,char[162],-1
95368,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[16],,<includes>,char[16],,true,,char[16],-1
95369,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[172],,<includes>,char[172],,true,,char[172],-1
95370,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[17],,<includes>,char[17],,true,,char[17],-1
95371,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[18],,<includes>,char[18],,true,,char[18],-1
95372,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[19],,<includes>,char[19],,true,,char[19],-1
95373,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[1],,<includes>,char[1],,true,,char[1],-1
95374,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[200],,<includes>,char[200],,true,,char[200],-1
95375,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[20],,<includes>,char[20],,true,,char[20],-1
95376,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[21],,<includes>,char[21],,true,,char[21],-1
95377,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[22],,<includes>,char[22],,true,,char[22],-1
95378,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[23],,<includes>,char[23],,true,,char[23],-1
95379,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[24],,<includes>,char[24],,true,,char[24],-1
95380,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[25],,<includes>,char[25],,true,,char[25],-1
95381,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[26],,<includes>,char[26],,true,,char[26],-1
95382,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[27],,<includes>,char[27],,true,,char[27],-1
95383,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[28],,<includes>,char[28],,true,,char[28],-1
95384,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[29],,<includes>,char[29],,true,,char[29],-1
95385,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[2],,<includes>,char[2],,true,,char[2],-1
95386,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[30],,<includes>,char[30],,true,,char[30],-1
95387,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[31],,<includes>,char[31],,true,,char[31],-1
95388,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[32],,<includes>,char[32],,true,,char[32],-1
95389,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[33],,<includes>,char[33],,true,,char[33],-1
95390,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[34],,<includes>,char[34],,true,,char[34],-1
95391,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[35],,<includes>,char[35],,true,,char[35],-1
95392,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[36],,<includes>,char[36],,true,,char[36],-1
95393,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[37],,<includes>,char[37],,true,,char[37],-1
95394,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[38],,<includes>,char[38],,true,,char[38],-1
95395,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[39],,<includes>,char[39],,true,,char[39],-1
95396,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[3],,<includes>,char[3],,true,,char[3],-1
95397,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[40],,<includes>,char[40],,true,,char[40],-1
95398,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[41],,<includes>,char[41],,true,,char[41],-1
95399,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[42],,<includes>,char[42],,true,,char[42],-1
95400,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[43],,<includes>,char[43],,true,,char[43],-1
95401,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[44],,<includes>,char[44],,true,,char[44],-1
95402,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[45],,<includes>,char[45],,true,,char[45],-1
95403,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[46],,<includes>,char[46],,true,,char[46],-1
95404,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[47],,<includes>,char[47],,true,,char[47],-1
95405,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[48],,<includes>,char[48],,true,,char[48],-1
95406,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[49],,<includes>,char[49],,true,,char[49],-1
95407,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[4],,<includes>,char[4],,true,,char[4],-1
95408,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[500],,<includes>,char[500],,true,,char[500],-1
95409,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[50],,<includes>,char[50],,true,,char[50],-1
95410,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[51],,<includes>,char[51],,true,,char[51],-1
95411,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[52],,<includes>,char[52],,true,,char[52],-1
95412,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[53],,<includes>,char[53],,true,,char[53],-1
95413,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[54],,<includes>,char[54],,true,,char[54],-1
95414,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[55],,<includes>,char[55],,true,,char[55],-1
95415,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[56],,<includes>,char[56],,true,,char[56],-1
95416,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[57],,<includes>,char[57],,true,,char[57],-1
95417,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[58],,<includes>,char[58],,true,,char[58],-1
95418,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[59],,<includes>,char[59],,true,,char[59],-1
95419,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[5],,<includes>,char[5],,true,,char[5],-1
95420,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[60],,<includes>,char[60],,true,,char[60],-1
95421,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[61],,<includes>,char[61],,true,,char[61],-1
95422,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[62],,<includes>,char[62],,true,,char[62],-1
95423,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[63],,<includes>,char[63],,true,,char[63],-1
95424,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[64],,<includes>,char[64],,true,,char[64],-1
95425,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[65],,<includes>,char[65],,true,,char[65],-1
95426,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[68],,<includes>,char[68],,true,,char[68],-1
95427,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[6],,<includes>,char[6],,true,,char[6],-1
95428,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[75],,<includes>,char[75],,true,,char[75],-1
95429,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[78],,<includes>,char[78],,true,,char[78],-1
95430,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[7],,<includes>,char[7],,true,,char[7],-1
95431,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[82],,<includes>,char[82],,true,,char[82],-1
95432,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[8],,<includes>,char[8],,true,,char[8],-1
95433,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[92],,<includes>,char[92],,true,,char[92],-1
95434,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[93],,<includes>,char[93],,true,,char[93],-1
95435,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[9],,<includes>,char[9],,true,,char[9],-1
95436,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[],,<includes>,char[],,true,,char[],-1
95437,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,config,,<includes>,config,,true,,config,-1
95438,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,const char*,,<includes>,const char*,,true,,const char*,-1
95439,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,crc32c,,<includes>,crc32c,,true,,crc32c,-1
95440,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,dirent*,,<includes>,dirent*,,true,,dirent*,-1
95441,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,double,,<includes>,double,,true,,double,-1
95442,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,double[154],,<includes>,double[154],,true,,double[154],-1
95443,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,explicit,,<includes>,explicit,,true,,explicit,-1
95444,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,fflush,,<includes>,fflush,,true,,fflush,-1
95445,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,flock,,<includes>,flock,,true,,flock,-1
95446,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,int,,<includes>,int,,true,,int,-1
95447,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,int (),,<includes>,int (),,true,,int (),-1
95448,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,int*,,<includes>,int*,,true,,int*,-1
95449,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,intptr_t,,<includes>,intptr_t,,true,,intptr_t,-1
95450,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,kBlockSize,,<includes>,kBlockSize,,true,,kBlockSize,-1
95451,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,kCorruption,,<includes>,kCorruption,,true,,kCorruption,-1
95452,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,kIOError,,<includes>,kIOError,,true,,kIOError,-1
95453,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,kInvalidArgument,,<includes>,kInvalidArgument,,true,,kInvalidArgument,-1
95454,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,kMaxHeight,,<includes>,kMaxHeight,,true,,kMaxHeight,-1
95455,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,kNotFound,,<includes>,kNotFound,,true,,kNotFound,-1
95456,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,kNotSupported,,<includes>,kNotSupported,,true,,kNotSupported,-1
95457,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,kyotocabinet,,<includes>,kyotocabinet,,true,,kyotocabinet,-1
95458,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,leveldb,,<includes>,leveldb,,true,,leveldb,-1
95459,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,"Node<Key,Comparator>",,<includes>,"leveldb.Node<Key,Comparator>",,true,,"Node<Key,Comparator>",-1
95460,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,"SkipList<Key,Comparator>",,<includes>,"leveldb.SkipList<Key,Comparator>",,true,,"SkipList<Key,Comparator>",-1
95461,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,leveldb_cache_t*,,<includes>,leveldb_cache_t*,,true,,leveldb_cache_t*,-1
95462,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,leveldb_comparator_t*,,<includes>,leveldb_comparator_t*,,true,,leveldb_comparator_t*,-1
95463,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,leveldb_env_t*,,<includes>,leveldb_env_t*,,true,,leveldb_env_t*,-1
95464,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,leveldb_filterpolicy_t*,,<includes>,leveldb_filterpolicy_t*,,true,,leveldb_filterpolicy_t*,-1
95465,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,leveldb_iterator_t*,,<includes>,leveldb_iterator_t*,,true,,leveldb_iterator_t*,-1
95466,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,leveldb_logger_t*,,<includes>,leveldb_logger_t*,,true,,leveldb_logger_t*,-1
95467,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,leveldb_options_t*,,<includes>,leveldb_options_t*,,true,,leveldb_options_t*,-1
95468,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,leveldb_readoptions_t*,,<includes>,leveldb_readoptions_t*,,true,,leveldb_readoptions_t*,-1
95469,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,leveldb_snapshot_t*,,<includes>,leveldb_snapshot_t*,,true,,leveldb_snapshot_t*,-1
95470,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,leveldb_t*,,<includes>,leveldb_t*,,true,,leveldb_t*,-1
95471,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,leveldb_writebatch_t*,,<includes>,leveldb_writebatch_t*,,true,,leveldb_writebatch_t*,-1
95472,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,leveldb_writeoptions_t*,,<includes>,leveldb_writeoptions_t*,,true,,leveldb_writeoptions_t*,-1
95473,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,log,,<includes>,log,,true,,log,-1
95474,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Reporter,,<includes>,log.Reader.Reporter,,true,,Reporter,-1
95475,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,long int,,<includes>,long int,,true,,long int,-1
95476,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,long long int,,<includes>,long long int,,true,,long long int,-1
95477,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,long long unsigned,,<includes>,long long unsigned,,true,,long long unsigned,-1
95478,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,numeric_limits,,<includes>,numeric_limits,,true,,numeric_limits,-1
95479,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,AtomicPointer[1],,<includes>,port.AtomicPointer[1],,true,,AtomicPointer[1],-1
95480,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,AtomicPointer[4],,<includes>,port.AtomicPointer[4],,true,,AtomicPointer[4],-1
95481,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,pthread_cond_t,,<includes>,pthread_cond_t,,true,,pthread_cond_t,-1
95482,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,pthread_mutex_t,,<includes>,pthread_mutex_t,,true,,pthread_mutex_t,-1
95483,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,pthread_once_t,,<includes>,pthread_once_t,,true,,pthread_once_t,-1
95484,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,pthread_t,,<includes>,pthread_t,,true,,pthread_t,-1
95485,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,rlimit,,<includes>,rlimit,,true,,rlimit,-1
95486,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,short int,,<includes>,short int,,true,,short int,-1
95487,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,signed char,,<includes>,signed char,,true,,signed char,-1
95488,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,size_t,,<includes>,size_t,,true,,size_t,-1
95489,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,size_t*,,<includes>,size_t*,,true,,size_t*,-1
95490,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,size_t[2],,<includes>,size_t[2],,true,,size_t[2],-1
95491,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,size_t[6],,<includes>,size_t[6],,true,,size_t[6],-1
95492,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,size_t[7],,<includes>,size_t[7],,true,,size_t[7],-1
95493,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,sqlite3*,,<includes>,sqlite3*,,true,,sqlite3*,-1
95494,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,sqlite3_stmt*,,<includes>,sqlite3_stmt*,,true,,sqlite3_stmt*,-1
95495,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,ssize_t,,<includes>,ssize_t,,true,,ssize_t,-1
95496,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,stat,,<includes>,stat,,true,,stat,-1
95497,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,static size_t[6],,<includes>,static size_t[6],,true,,static size_t[6],-1
95498,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,static uint64_t[6],,<includes>,static uint64_t[6],,true,,static uint64_t[6],-1
95499,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,static[11],,<includes>,static[11],,true,,static[11],-1
95500,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,std,,<includes>,std,,true,,std,-1
95501,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,string[2],,<includes>,std.string[2],,true,,string[2],-1
95502,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,string[7],,<includes>,std.string[7],,true,,string[7],-1
95503,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,vector<FileMetaData*>[2],,<includes>,std.vector<FileMetaData*>[2],,true,,vector<FileMetaData*>[2],-1
95504,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,vector<FileMetaData*>[7],,<includes>,std.vector<FileMetaData*>[7],,true,,vector<FileMetaData*>[7],-1
95505,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,string,,<includes>,string,,true,,string,-1
95506,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,test,,<includes>,test,,true,,test,-1
95507,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,time_t,,<includes>,time_t,,true,,time_t,-1
95508,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,timeval,,<includes>,timeval,,true,,timeval,-1
95509,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,tm,,<includes>,tm,,true,,tm,-1
95510,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,uint32_t*,,<includes>,uint32_t*,,true,,uint32_t*,-1
95511,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,uint32_t[5],,<includes>,uint32_t[5],,true,,uint32_t[5],-1
95512,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,uint64_t*,,<includes>,uint64_t*,,true,,uint64_t*,-1
95513,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,uint64_t[2],,<includes>,uint64_t[2],,true,,uint64_t[2],-1
95514,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,uint64_t[6],,<includes>,uint64_t[6],,true,,uint64_t[6],-1
95515,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,uint8_t*,,<includes>,uint8_t*,,true,,uint8_t*,-1
95516,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,uintptr_t,,<includes>,uintptr_t,,true,,uintptr_t,-1
95517,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,unsigned char,,<includes>,unsigned char,,true,,unsigned char,-1
95518,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,unsigned char*,,<includes>,unsigned char*,,true,,unsigned char*,-1
95519,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,unsigned char[1],,<includes>,unsigned char[1],,true,,unsigned char[1],-1
95520,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,unsigned char[2],,<includes>,unsigned char[2],,true,,unsigned char[2],-1
95521,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,unsigned char[3],,<includes>,unsigned char[3],,true,,unsigned char[3],-1
95522,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,unsigned char[48],,<includes>,unsigned char[48],,true,,unsigned char[48],-1
95523,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,unsigned char[4],,<includes>,unsigned char[4],,true,,unsigned char[4],-1
95524,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,unsigned int,,<includes>,unsigned int,,true,,unsigned int,-1
95525,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,unsigned longint,,<includes>,unsigned longint,,true,,unsigned longint,-1
95526,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,unsigned longlongint,,<includes>,unsigned longlongint,,true,,unsigned longlongint,-1
95527,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,unsigned shortint,,<includes>,unsigned shortint,,true,,unsigned shortint,-1
95528,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,va_list,,<includes>,va_list,,true,,va_list,-1
95529,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,vector<uint64_t>,,<includes>,vector<uint64_t>,,true,,vector<uint64_t>,-1
95530,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,virtual,,<includes>,virtual,,true,,virtual,-1
95531,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,void,,<includes>,void,,true,,void,-1
95532,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,"void (int, int)",,<includes>,"void (int, int)",,true,,"void (int, int)",-1
95533,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,void(void*),,<includes>,void(void*),,true,,void(void*),-1
95534,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,void*,,<includes>,void*,,true,,void*,-1
