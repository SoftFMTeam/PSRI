,Id,Name,NodeType,Fullname,Signature,Filename,Code,LineNumber,LineNumberEnd,ColumnNumber,ColumnNumberEnd,LineOfCode,NumberOfOperators,SetOfOperators,NumberOfOperands,SetOfOperands,FanIn,FanOut,McCabe,AccCyc,ConCf,ConDf,ConZc,ConRf,ConVal,Parma,ParmaIn,ParmaOut,RetType
0,95542,db\autocompact_test.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1,95543,db\builder.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2,95544,db\builder.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3,95545,db\c.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4,95546,db\c_test.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5,95547,db\corruption_test.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
6,95548,db\db_bench.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7,95549,db\db_impl.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8,95550,db\db_impl.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
9,95551,db\db_iter.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
10,95552,db\db_iter.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
11,95553,db\db_test.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
12,95554,db\dbformat.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
13,95555,db\dbformat.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
14,95556,db\dbformat_test.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
15,95557,db\dumpfile.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
16,95558,db\fault_injection_test.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
17,95559,db\filename.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
18,95560,db\filename.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
19,95561,db\filename_test.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
20,95562,db\leveldbutil.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
21,95563,db\log_format.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
22,95564,db\log_reader.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
23,95565,db\log_reader.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
24,95566,db\log_test.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
25,95567,db\log_writer.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
26,95568,db\log_writer.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
27,95569,db\memtable.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
28,95570,db\memtable.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
29,95571,db\recovery_test.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
30,95572,db\repair.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
31,95573,db\skiplist.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
32,95574,db\skiplist_test.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
33,95575,db\snapshot.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
34,95576,db\table_cache.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
35,95577,db\table_cache.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
36,95578,db\version_edit.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
37,95579,db\version_edit.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
38,95580,db\version_edit_test.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
39,95581,db\version_set.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
40,95582,db\version_set.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
41,95583,db\version_set_test.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
42,95584,db\write_batch.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
43,95585,db\write_batch_internal.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
44,95586,db\write_batch_test.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
45,95587,doc\bench\db_bench_sqlite3.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
46,95588,doc\bench\db_bench_tree_db.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
47,95589,helpers\memenv\memenv.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
48,95590,helpers\memenv\memenv.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
49,95591,helpers\memenv\memenv_test.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
50,95592,include\leveldb\c.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
51,95593,include\leveldb\cache.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
52,95594,include\leveldb\comparator.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
53,95595,include\leveldb\db.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
54,95596,include\leveldb\dumpfile.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
55,95597,include\leveldb\env.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
56,95598,include\leveldb\filter_policy.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
57,95599,include\leveldb\iterator.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
58,95600,include\leveldb\options.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
59,95601,include\leveldb\slice.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
60,95602,include\leveldb\status.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
61,95603,include\leveldb\table.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
62,95604,include\leveldb\table_builder.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
63,95605,include\leveldb\write_batch.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
64,95606,issues\issue178_test.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
65,95607,issues\issue200_test.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
66,95608,port\atomic_pointer.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
67,95609,port\port.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
68,95610,port\port_example.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
69,95611,port\port_posix.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
70,95612,port\port_posix.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
71,95613,port\port_posix_sse.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
72,95614,port\thread_annotations.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
73,95615,port\win\stdint.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
74,95616,table\block.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
75,95617,table\block.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
76,95618,table\block_builder.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
77,95619,table\block_builder.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
78,95620,table\filter_block.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
79,95621,table\filter_block.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
80,95622,table\filter_block_test.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
81,95623,table\format.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
82,95624,table\format.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
83,95625,table\iterator.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
84,95626,table\iterator_wrapper.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
85,95627,table\merger.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
86,95628,table\merger.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
87,95629,table\table.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
88,95630,table\table_builder.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
89,95631,table\table_test.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
90,95632,table\two_level_iterator.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
91,95633,table\two_level_iterator.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
92,95634,util\arena.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
93,95635,util\arena.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
94,95636,util\arena_test.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
95,95637,util\bloom.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
96,95638,util\bloom_test.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
97,95639,util\cache.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
98,95640,util\cache_test.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
99,95641,util\coding.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
100,95642,util\coding.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
101,95643,util\coding_test.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
102,95644,util\comparator.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
103,95645,util\crc32c.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
104,95646,util\crc32c.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
105,95647,util\crc32c_test.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
106,95648,util\env.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
107,95649,util\env_posix.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
108,95650,util\env_posix_test.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
109,95651,util\env_posix_test_helper.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
110,95652,util\env_test.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
111,95653,util\filter_policy.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
112,95654,util\hash.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
113,95655,util\hash.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
114,95656,util\hash_test.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
115,95657,util\histogram.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
116,95658,util\histogram.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
117,95659,util\logging.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
118,95660,util\logging.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
119,95661,util\mutexlock.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
120,95662,util\options.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
121,95663,util\posix_logger.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
122,95664,util\random.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
123,95665,util\status.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
124,95666,util\testharness.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
125,95667,util\testharness.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
126,95668,util\testutil.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
127,95669,util\testutil.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
128,19,dbname_,3,leveldb.AutoCompactTest.dbname_,,db\autocompact_test.cc,dbname_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
129,20,tiny_cache_,3,leveldb.AutoCompactTest.tiny_cache_,,db\autocompact_test.cc,* tiny_cache_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
130,21,options_,3,leveldb.AutoCompactTest.options_,,db\autocompact_test.cc,options_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
131,22,db_,3,leveldb.AutoCompactTest.db_,,db\autocompact_test.cc,* db_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
132,846,rep,3,leveldb_t.rep,,db\c.cc,*               rep,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
133,848,rep,3,leveldb_iterator_t.rep,,db\c.cc,*         rep,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
134,850,rep,3,leveldb_writebatch_t.rep,,db\c.cc,rep,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
135,852,rep,3,leveldb_snapshot_t.rep,,db\c.cc,*   rep,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
136,854,rep,3,leveldb_readoptions_t.rep,,db\c.cc,rep,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
137,856,rep,3,leveldb_writeoptions_t.rep,,db\c.cc,rep,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
138,858,rep,3,leveldb_options_t.rep,,db\c.cc,rep,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,16,0,1,1,0,0,,0,0,0,0,0,
139,860,rep,3,leveldb_cache_t.rep,,db\c.cc,*            rep,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
140,862,rep,3,leveldb_seqfile_t.rep,,db\c.cc,*   rep,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
141,864,rep,3,leveldb_randomfile_t.rep,,db\c.cc,* rep,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
142,866,rep,3,leveldb_writablefile_t.rep,,db\c.cc,*     rep,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
143,868,rep,3,leveldb_logger_t.rep,,db\c.cc,*           rep,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
144,870,rep,3,leveldb_filelock_t.rep,,db\c.cc,*         rep,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
145,872,state_,3,leveldb_comparator_t.state_,,db\c.cc,* state_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
146,948,state_,3,leveldb_filterpolicy_t.state_,,db\c.cc,* state_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
147,1099,rep,3,leveldb_env_t.rep,,db\c.cc,* rep,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
148,1100,is_default,3,leveldb_env_t.is_default,,db\c.cc,is_default,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
149,3870,env_,3,leveldb.CorruptionTest.env_,,db\corruption_test.cc,env_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
150,3871,dbname_,3,leveldb.CorruptionTest.dbname_,,db\corruption_test.cc,dbname_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
151,3872,tiny_cache_,3,leveldb.CorruptionTest.tiny_cache_,,db\corruption_test.cc,* tiny_cache_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
152,3873,options_,3,leveldb.CorruptionTest.options_,,db\corruption_test.cc,options_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
153,3874,db_,3,leveldb.CorruptionTest.db_,,db\corruption_test.cc,* db_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
154,6027,data_,3,leveldb.anonymous_namespace_1.RandomGenerator.data_,,db\db_bench.cc,data_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
155,6028,pos_,3,leveldb.anonymous_namespace_1.RandomGenerator.pos_,,db\db_bench.cc,pos_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
156,6140,start_,3,leveldb.anonymous_namespace_5.Stats.start_,,db\db_bench.cc,start_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
157,6141,finish_,3,leveldb.anonymous_namespace_5.Stats.finish_,,db\db_bench.cc,finish_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
158,6142,seconds_,3,leveldb.anonymous_namespace_5.Stats.seconds_,,db\db_bench.cc,seconds_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
159,6143,done_,3,leveldb.anonymous_namespace_5.Stats.done_,,db\db_bench.cc,done_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
160,6144,next_report_,3,leveldb.anonymous_namespace_5.Stats.next_report_,,db\db_bench.cc,next_report_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
161,6145,bytes_,3,leveldb.anonymous_namespace_5.Stats.bytes_,,db\db_bench.cc,bytes_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
162,6146,last_op_finish_,3,leveldb.anonymous_namespace_5.Stats.last_op_finish_,,db\db_bench.cc,last_op_finish_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
163,6147,hist_,3,leveldb.anonymous_namespace_5.Stats.hist_,,db\db_bench.cc,hist_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
164,6148,message_,3,leveldb.anonymous_namespace_5.Stats.message_,,db\db_bench.cc,message_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
165,6487,mu,3,leveldb.anonymous_namespace_17.SharedState.mu,,db\db_bench.cc,mu,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
166,6488,cv,3,leveldb.anonymous_namespace_17.SharedState.cv,,db\db_bench.cc,cv,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
167,6489,total,3,leveldb.anonymous_namespace_17.SharedState.total,,db\db_bench.cc,total,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
168,6490,num_initialized,3,leveldb.anonymous_namespace_17.SharedState.num_initialized,,db\db_bench.cc,num_initialized,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
169,6491,num_done,3,leveldb.anonymous_namespace_17.SharedState.num_done,,db\db_bench.cc,num_done,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
170,6492,start,3,leveldb.anonymous_namespace_17.SharedState.start,,db\db_bench.cc,start,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
171,6498,tid,3,leveldb.anonymous_namespace_19.ThreadState.tid,,db\db_bench.cc,tid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
172,6499,rand,3,leveldb.anonymous_namespace_19.ThreadState.rand,,db\db_bench.cc,rand,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
173,6500,stats,3,leveldb.anonymous_namespace_19.ThreadState.stats,,db\db_bench.cc,stats,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,26,0,1,1,0,0,,0,0,0,0,0,
174,6501,shared,3,leveldb.anonymous_namespace_19.ThreadState.shared,,db\db_bench.cc,* shared,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
175,6508,cache_,3,leveldb.Benchmark.cache_,,db\db_bench.cc,* cache_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
176,6509,filter_policy_,3,leveldb.Benchmark.filter_policy_,,db\db_bench.cc,* filter_policy_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
177,6510,db_,3,leveldb.Benchmark.db_,,db\db_bench.cc,* db_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
178,6511,num_,3,leveldb.Benchmark.num_,,db\db_bench.cc,num_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
179,6512,value_size_,3,leveldb.Benchmark.value_size_,,db\db_bench.cc,value_size_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
180,6513,entries_per_batch_,3,leveldb.Benchmark.entries_per_batch_,,db\db_bench.cc,entries_per_batch_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
181,6514,write_options_,3,leveldb.Benchmark.write_options_,,db\db_bench.cc,write_options_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
182,6515,reads_,3,leveldb.Benchmark.reads_,,db\db_bench.cc,reads_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
183,6516,heap_counter_,3,leveldb.Benchmark.heap_counter_,,db\db_bench.cc,heap_counter_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
184,7225,bm,3,leveldb.Benchmark.ThreadArg.bm,,db\db_bench.cc,* bm,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
185,7226,shared,3,leveldb.Benchmark.ThreadArg.shared,,db\db_bench.cc,* shared,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
186,7227,thread,3,leveldb.Benchmark.ThreadArg.thread,,db\db_bench.cc,* thread,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
187,9409,status,3,leveldb.Writer.status,,db\db_impl.cc,status,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
188,9410,batch,3,leveldb.Writer.batch,,db\db_impl.cc,* batch,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
189,9411,sync,3,leveldb.Writer.sync,,db\db_impl.cc,sync,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
190,9412,done,3,leveldb.Writer.done,,db\db_impl.cc,done,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
191,9413,cv,3,leveldb.Writer.cv,,db\db_impl.cc,cv,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
192,9420,compaction,3,leveldb.CompactionState.compaction,,db\db_impl.cc,* const compaction,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,21,0,1,1,0,0,,0,0,0,0,0,
193,9421,smallest_snapshot,3,leveldb.CompactionState.smallest_snapshot,,db\db_impl.cc,smallest_snapshot,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
194,9423,number,3,leveldb.CompactionState.Output.number,,db\db_impl.cc,number,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
195,9424,file_size,3,leveldb.CompactionState.Output.file_size,,db\db_impl.cc,file_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
196,9425,smallest,3,leveldb.CompactionState.Output.smallest,,db\db_impl.cc,smallest,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
197,9426,largest,3,leveldb.CompactionState.Output.largest,,db\db_impl.cc,largest,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
198,9427,outputs,3,leveldb.CompactionState.outputs,,db\db_impl.cc,outputs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
199,9428,outfile,3,leveldb.CompactionState.outfile,,db\db_impl.cc,* outfile,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
200,9429,builder,3,leveldb.CompactionState.builder,,db\db_impl.cc,* builder,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,18,0,1,1,0,0,,0,0,0,0,0,
201,9430,total_bytes,3,leveldb.CompactionState.total_bytes,,db\db_impl.cc,total_bytes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
202,12877,mu,3,leveldb.anonymous_namespace_1.IterState.mu,,db\db_impl.cc,* mu,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
203,12878,version,3,leveldb.anonymous_namespace_1.IterState.version,,db\db_impl.cc,* version,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
204,12879,mem,3,leveldb.anonymous_namespace_1.IterState.mem,,db\db_impl.cc,* mem,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
205,12880,imm,3,leveldb.anonymous_namespace_1.IterState.imm,,db\db_impl.cc,* imm,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
206,14946,env_,3,leveldb.DBImpl.env_,,db\db_impl.hpp,* const env_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,21,0,1,1,0,0,,0,0,0,0,0,
207,14947,internal_comparator_,3,leveldb.DBImpl.internal_comparator_,,db\db_impl.hpp,internal_comparator_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
208,14948,internal_filter_policy_,3,leveldb.DBImpl.internal_filter_policy_,,db\db_impl.hpp,internal_filter_policy_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
209,14949,options_,3,leveldb.DBImpl.options_,,db\db_impl.hpp,options_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,23,0,1,1,0,0,,0,0,0,0,0,
210,14950,owns_info_log_,3,leveldb.DBImpl.owns_info_log_,,db\db_impl.hpp,owns_info_log_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
211,14951,owns_cache_,3,leveldb.DBImpl.owns_cache_,,db\db_impl.hpp,owns_cache_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
212,14952,dbname_,3,leveldb.DBImpl.dbname_,,db\db_impl.hpp,dbname_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,14,0,1,1,0,0,,0,0,0,0,0,
213,14953,table_cache_,3,leveldb.DBImpl.table_cache_,,db\db_impl.hpp,* table_cache_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
214,14954,db_lock_,3,leveldb.DBImpl.db_lock_,,db\db_impl.hpp,* db_lock_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
215,14955,mutex_,3,leveldb.DBImpl.mutex_,,db\db_impl.hpp,mutex_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,46,0,1,1,0,0,,0,0,0,0,0,
216,14956,shutting_down_,3,leveldb.DBImpl.shutting_down_,,db\db_impl.hpp,shutting_down_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
217,14957,bg_cv_,3,leveldb.DBImpl.bg_cv_,,db\db_impl.hpp,bg_cv_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
218,14958,mem_,3,leveldb.DBImpl.mem_,,db\db_impl.hpp,* mem_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
219,14959,imm_,3,leveldb.DBImpl.imm_,,db\db_impl.hpp,* imm_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,15,0,1,1,0,0,,0,0,0,0,0,
220,14960,has_imm_,3,leveldb.DBImpl.has_imm_,,db\db_impl.hpp,has_imm_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
221,14961,logfile_,3,leveldb.DBImpl.logfile_,,db\db_impl.hpp,* logfile_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
222,14962,logfile_number_,3,leveldb.DBImpl.logfile_number_,,db\db_impl.hpp,logfile_number_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
223,14963,log_,3,leveldb.DBImpl.log_,,db\db_impl.hpp,* log_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
224,14964,seed_,3,leveldb.DBImpl.seed_,,db\db_impl.hpp,seed_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
225,14965,writers_,3,leveldb.DBImpl.writers_,,db\db_impl.hpp,writers_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
226,14966,tmp_batch_,3,leveldb.DBImpl.tmp_batch_,,db\db_impl.hpp,* tmp_batch_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
227,14967,snapshots_,3,leveldb.DBImpl.snapshots_,,db\db_impl.hpp,snapshots_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
228,14968,pending_outputs_,3,leveldb.DBImpl.pending_outputs_,,db\db_impl.hpp,pending_outputs_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
229,14969,bg_compaction_scheduled_,3,leveldb.DBImpl.bg_compaction_scheduled_,,db\db_impl.hpp,bg_compaction_scheduled_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
230,14971,level,3,leveldb.DBImpl.ManualCompaction.level,,db\db_impl.hpp,level,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
231,14972,done,3,leveldb.DBImpl.ManualCompaction.done,,db\db_impl.hpp,done,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
232,14973,begin,3,leveldb.DBImpl.ManualCompaction.begin,,db\db_impl.hpp,* begin,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
233,14974,end,3,leveldb.DBImpl.ManualCompaction.end,,db\db_impl.hpp,* end,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
234,14975,tmp_storage,3,leveldb.DBImpl.ManualCompaction.tmp_storage,,db\db_impl.hpp,tmp_storage,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
235,14976,manual_compaction_,3,leveldb.DBImpl.manual_compaction_,,db\db_impl.hpp,* manual_compaction_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
236,14977,versions_,3,leveldb.DBImpl.versions_,,db\db_impl.hpp,* versions_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,40,0,1,1,0,0,,0,0,0,0,0,
237,14978,bg_error_,3,leveldb.DBImpl.bg_error_,,db\db_impl.hpp,bg_error_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
238,14980,micros,3,leveldb.DBImpl.CompactionStats.micros,,db\db_impl.hpp,micros,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
239,14981,bytes_read,3,leveldb.DBImpl.CompactionStats.bytes_read,,db\db_impl.hpp,bytes_read,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
240,14982,bytes_written,3,leveldb.DBImpl.CompactionStats.bytes_written,,db\db_impl.hpp,bytes_written,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
241,15013,stats_,3,leveldb.DBImpl.stats_,,db\db_impl.hpp,stats_[config::kNumLevels],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
242,15078,kForward,3,leveldb.anonymous_namespace_2.DBIter.Direction.kForward,,db\db_iter.cc,kForward,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
243,15079,kReverse,3,leveldb.anonymous_namespace_2.DBIter.Direction.kReverse,,db\db_iter.cc,kReverse,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
244,15243,db_,3,leveldb.anonymous_namespace_1.DBIter.db_,,db\db_iter.cc,* db_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
245,15244,user_comparator_,3,leveldb.anonymous_namespace_1.DBIter.user_comparator_,,db\db_iter.cc,* const user_comparator_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
246,15245,iter_,3,leveldb.anonymous_namespace_1.DBIter.iter_,,db\db_iter.cc,* const iter_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
247,15246,sequence_,3,leveldb.anonymous_namespace_1.DBIter.sequence_,,db\db_iter.cc,sequence_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
248,15247,status_,3,leveldb.anonymous_namespace_1.DBIter.status_,,db\db_iter.cc,status_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
249,15248,saved_key_,3,leveldb.anonymous_namespace_1.DBIter.saved_key_,,db\db_iter.cc,saved_key_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
250,15249,saved_value_,3,leveldb.anonymous_namespace_1.DBIter.saved_value_,,db\db_iter.cc,saved_value_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
251,15250,direction_,3,leveldb.anonymous_namespace_1.DBIter.direction_,,db\db_iter.cc,direction_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
252,15251,valid_,3,leveldb.anonymous_namespace_1.DBIter.valid_,,db\db_iter.cc,valid_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
253,15252,rnd_,3,leveldb.anonymous_namespace_1.DBIter.rnd_,,db\db_iter.cc,rnd_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
254,15253,bytes_counter_,3,leveldb.anonymous_namespace_1.DBIter.bytes_counter_,,db\db_iter.cc,bytes_counter_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
255,15851,mu_,3,leveldb.anonymous_namespace_1.AtomicCounter.mu_,,db\db_test.cc,mu_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
256,15852,count_,3,leveldb.anonymous_namespace_1.AtomicCounter.count_,,db\db_test.cc,count_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
257,15912,delay_data_sync_,3,leveldb.SpecialEnv.delay_data_sync_,,db\db_test.cc,delay_data_sync_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
258,15913,data_sync_error_,3,leveldb.SpecialEnv.data_sync_error_,,db\db_test.cc,data_sync_error_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
259,15914,no_space_,3,leveldb.SpecialEnv.no_space_,,db\db_test.cc,no_space_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
260,15915,non_writable_,3,leveldb.SpecialEnv.non_writable_,,db\db_test.cc,non_writable_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
261,15916,manifest_sync_error_,3,leveldb.SpecialEnv.manifest_sync_error_,,db\db_test.cc,manifest_sync_error_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
262,15917,manifest_write_error_,3,leveldb.SpecialEnv.manifest_write_error_,,db\db_test.cc,manifest_write_error_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
263,15918,count_random_reads_,3,leveldb.SpecialEnv.count_random_reads_,,db\db_test.cc,count_random_reads_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
264,15919,random_read_counter_,3,leveldb.SpecialEnv.random_read_counter_,,db\db_test.cc,random_read_counter_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
265,16077,filter_policy_,3,leveldb.DBTest.filter_policy_,,db\db_test.cc,* filter_policy_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
266,16079,kDefault,3,leveldb.DBTest.OptionConfig.kDefault,,db\db_test.cc,kDefault,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
267,16080,kReuse,3,leveldb.DBTest.OptionConfig.kReuse,,db\db_test.cc,kReuse,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
268,16081,kFilter,3,leveldb.DBTest.OptionConfig.kFilter,,db\db_test.cc,kFilter,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
269,16082,kUncompressed,3,leveldb.DBTest.OptionConfig.kUncompressed,,db\db_test.cc,kUncompressed,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
270,16083,kEnd,3,leveldb.DBTest.OptionConfig.kEnd,,db\db_test.cc,kEnd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
271,16084,option_config_,3,leveldb.DBTest.option_config_,,db\db_test.cc,option_config_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
272,16085,dbname_,3,leveldb.DBTest.dbname_,,db\db_test.cc,dbname_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
273,16086,env_,3,leveldb.DBTest.env_,,db\db_test.cc,* env_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
274,16087,db_,3,leveldb.DBTest.db_,,db\db_test.cc,* db_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,18,0,1,1,0,0,,0,0,0,0,0,
275,16088,last_options_,3,leveldb.DBTest.last_options_,,db\db_test.cc,last_options_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
276,27480,test,3,leveldb.anonymous_namespace_15.MTState.test,,db\db_test.cc,* test,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
277,27481,stop,3,leveldb.anonymous_namespace_15.MTState.stop,,db\db_test.cc,stop,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
278,27482,counter,3,leveldb.anonymous_namespace_15.MTState.counter,,db\db_test.cc,counter[kNumThreads],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
279,27483,thread_done,3,leveldb.anonymous_namespace_15.MTState.thread_done,,db\db_test.cc,thread_done[kNumThreads],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
280,27493,state,3,leveldb.anonymous_namespace_16.MTThread.state,,db\db_test.cc,* state,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
281,27494,id,3,leveldb.anonymous_namespace_16.MTThread.id,,db\db_test.cc,id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
282,27957,map_,3,leveldb.ModelDB.ModelSnapshot.map_,,db\db_test.cc,map_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
283,28256,map_,3,leveldb.ModelDB.ModelIter.map_,,db\db_test.cc,* const map_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
284,28257,owned_,3,leveldb.ModelDB.ModelIter.owned_,,db\db_test.cc,owned_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
285,28258,iter_,3,leveldb.ModelDB.ModelIter.iter_,,db\db_test.cc,iter_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
286,28259,options_,3,leveldb.ModelDB.options_,,db\db_test.cc,options_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
287,28260,map_,3,leveldb.ModelDB.map_,,db\db_test.cc,map_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
288,29849,kTypeDeletion,3,leveldb.ValueType.kTypeDeletion,,db\dbformat.hpp,kTypeDeletion = 0x0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
289,29850,kTypeValue,3,leveldb.ValueType.kTypeValue,,db\dbformat.hpp,kTypeValue = 0x1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
290,29875,user_key,3,leveldb.ParsedInternalKey.user_key,,db\dbformat.hpp,user_key,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
291,29876,sequence,3,leveldb.ParsedInternalKey.sequence,,db\dbformat.hpp,sequence,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
292,29877,type,3,leveldb.ParsedInternalKey.type,,db\dbformat.hpp,type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
293,29985,user_comparator_,3,leveldb.InternalKeyComparator.user_comparator_,,db\dbformat.hpp,* user_comparator_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
294,30025,user_policy_,3,leveldb.InternalFilterPolicy.user_policy_,,db\dbformat.hpp,* const user_policy_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
295,30049,rep_,3,leveldb.InternalKey.rep_,,db\dbformat.hpp,rep_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
296,30258,start_,3,leveldb.LookupKey.start_,,db\dbformat.hpp,* start_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
297,30259,kstart_,3,leveldb.LookupKey.kstart_,,db\dbformat.hpp,* kstart_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
298,30260,end_,3,leveldb.LookupKey.end_,,db\dbformat.hpp,* end_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
299,30261,space_,3,leveldb.LookupKey.space_,,db\dbformat.hpp,space_[200],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
300,31044,dst_,3,leveldb.anonymous_namespace_2.CorruptionReporter.dst_,,db\dumpfile.cc,* dst_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
301,31148,dst_,3,leveldb.anonymous_namespace_5.WriteBatchItemPrinter.dst_,,db\dumpfile.cc,* dst_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
302,31910,filename_,3,leveldb.anonymous_namespace_5.FileState.filename_,,db\fault_injection_test.cc,filename_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
303,31911,pos_,3,leveldb.anonymous_namespace_5.FileState.pos_,,db\fault_injection_test.cc,pos_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
304,31912,pos_at_last_sync_,3,leveldb.anonymous_namespace_5.FileState.pos_at_last_sync_,,db\fault_injection_test.cc,pos_at_last_sync_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
305,31913,pos_at_last_flush_,3,leveldb.anonymous_namespace_5.FileState.pos_at_last_flush_,,db\fault_injection_test.cc,pos_at_last_flush_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
306,31968,state_,3,leveldb.TestWritableFile.state_,,db\fault_injection_test.cc,state_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
307,31969,target_,3,leveldb.TestWritableFile.target_,,db\fault_injection_test.cc,* target_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
308,31970,writable_file_opened_,3,leveldb.TestWritableFile.writable_file_opened_,,db\fault_injection_test.cc,writable_file_opened_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
309,31971,env_,3,leveldb.TestWritableFile.env_,,db\fault_injection_test.cc,* env_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
310,32053,mutex_,3,leveldb.FaultInjectionTestEnv.mutex_,,db\fault_injection_test.cc,mutex_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
311,32054,db_file_state_,3,leveldb.FaultInjectionTestEnv.db_file_state_,,db\fault_injection_test.cc,db_file_state_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
312,32055,new_files_since_last_dir_sync_,3,leveldb.FaultInjectionTestEnv.new_files_since_last_dir_sync_,,db\fault_injection_test.cc,new_files_since_last_dir_sync_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
313,32056,filesystem_active_,3,leveldb.FaultInjectionTestEnv.filesystem_active_,,db\fault_injection_test.cc,filesystem_active_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
314,32703,VAL_EXPECT_NO_ERROR,3,leveldb.FaultInjectionTest.ExpectedVerifResult.VAL_EXPECT_NO_ERROR,,db\fault_injection_test.cc,VAL_EXPECT_NO_ERROR,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
315,32704,VAL_EXPECT_ERROR,3,leveldb.FaultInjectionTest.ExpectedVerifResult.VAL_EXPECT_ERROR,,db\fault_injection_test.cc,VAL_EXPECT_ERROR,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
316,32706,RESET_DROP_UNSYNCED_DATA,3,leveldb.FaultInjectionTest.ResetMethod.RESET_DROP_UNSYNCED_DATA,,db\fault_injection_test.cc,RESET_DROP_UNSYNCED_DATA,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
317,32707,RESET_DELETE_UNSYNCED_FILES,3,leveldb.FaultInjectionTest.ResetMethod.RESET_DELETE_UNSYNCED_FILES,,db\fault_injection_test.cc,RESET_DELETE_UNSYNCED_FILES,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
318,32708,env_,3,leveldb.FaultInjectionTest.env_,,db\fault_injection_test.cc,* env_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
319,32709,dbname_,3,leveldb.FaultInjectionTest.dbname_,,db\fault_injection_test.cc,dbname_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
320,32710,tiny_cache_,3,leveldb.FaultInjectionTest.tiny_cache_,,db\fault_injection_test.cc,* tiny_cache_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
321,32711,options_,3,leveldb.FaultInjectionTest.options_,,db\fault_injection_test.cc,options_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
322,32712,db_,3,leveldb.FaultInjectionTest.db_,,db\fault_injection_test.cc,* db_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
323,33850,kLogFile,3,leveldb.FileType.kLogFile,,db\filename.hpp,kLogFile,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
324,33851,kDBLockFile,3,leveldb.FileType.kDBLockFile,,db\filename.hpp,kDBLockFile,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
325,33852,kTableFile,3,leveldb.FileType.kTableFile,,db\filename.hpp,kTableFile,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
326,33853,kDescriptorFile,3,leveldb.FileType.kDescriptorFile,,db\filename.hpp,kDescriptorFile,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
327,33854,kCurrentFile,3,leveldb.FileType.kCurrentFile,,db\filename.hpp,kCurrentFile,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
328,33855,kTempFile,3,leveldb.FileType.kTempFile,,db\filename.hpp,kTempFile,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
329,33856,kInfoLogFile,3,leveldb.FileType.kInfoLogFile,,db\filename.hpp,kInfoLogFile,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
330,34972,kZeroType,3,leveldb.log.RecordType.kZeroType,,db\log_format.hpp,kZeroType = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
331,34973,kFullType,3,leveldb.log.RecordType.kFullType,,db\log_format.hpp,kFullType = 1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
332,34974,kFirstType,3,leveldb.log.RecordType.kFirstType,,db\log_format.hpp,kFirstType = 2,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
333,34975,kMiddleType,3,leveldb.log.RecordType.kMiddleType,,db\log_format.hpp,kMiddleType = 3,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
334,34976,kLastType,3,leveldb.log.RecordType.kLastType,,db\log_format.hpp,kLastType = 4,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
335,35752,file_,3,leveldb.log.Reader.file_,,db\log_reader.hpp,* const file_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
336,35753,reporter_,3,leveldb.log.Reader.reporter_,,db\log_reader.hpp,* const reporter_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
337,35754,checksum_,3,leveldb.log.Reader.checksum_,,db\log_reader.hpp,checksum_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
338,35755,backing_store_,3,leveldb.log.Reader.backing_store_,,db\log_reader.hpp,* const backing_store_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
339,35756,buffer_,3,leveldb.log.Reader.buffer_,,db\log_reader.hpp,buffer_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,16,0,1,1,0,0,,0,0,0,0,0,
340,35757,eof_,3,leveldb.log.Reader.eof_,,db\log_reader.hpp,eof_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
341,35758,last_record_offset_,3,leveldb.log.Reader.last_record_offset_,,db\log_reader.hpp,last_record_offset_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
342,35759,end_of_buffer_offset_,3,leveldb.log.Reader.end_of_buffer_offset_,,db\log_reader.hpp,end_of_buffer_offset_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
343,35760,initial_offset_,3,leveldb.log.Reader.initial_offset_,,db\log_reader.hpp,initial_offset_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
344,35761,resyncing_,3,leveldb.log.Reader.resyncing_,,db\log_reader.hpp,resyncing_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
345,35763,kEof,3,leveldb.log.Reader.anonymous_enum_0.kEof,,db\log_reader.hpp,kEof = kMaxRecordType + 1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
346,35764,kBadRecord,3,leveldb.log.Reader.anonymous_enum_0.kBadRecord,,db\log_reader.hpp,kBadRecord = kMaxRecordType + 2,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
347,35893,contents_,3,leveldb.log.LogTest.StringDest.contents_,,db\log_test.cc,contents_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,14,0,1,1,0,0,,0,0,0,0,0,
348,35944,contents_,3,leveldb.log.LogTest.StringSource.contents_,,db\log_test.cc,contents_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
349,35945,force_error_,3,leveldb.log.LogTest.StringSource.force_error_,,db\log_test.cc,force_error_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
350,35946,returned_partial_,3,leveldb.log.LogTest.StringSource.returned_partial_,,db\log_test.cc,returned_partial_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
351,36063,dropped_bytes_,3,leveldb.log.LogTest.ReportCollector.dropped_bytes_,,db\log_test.cc,dropped_bytes_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
352,36064,message_,3,leveldb.log.LogTest.ReportCollector.message_,,db\log_test.cc,message_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
353,36086,dest_,3,leveldb.log.LogTest.dest_,,db\log_test.cc,dest_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
354,36087,source_,3,leveldb.log.LogTest.source_,,db\log_test.cc,source_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
355,36088,report_,3,leveldb.log.LogTest.report_,,db\log_test.cc,report_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
356,36089,reading_,3,leveldb.log.LogTest.reading_,,db\log_test.cc,reading_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
357,36090,writer_,3,leveldb.log.LogTest.writer_,,db\log_test.cc,* writer_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
358,36091,reader_,3,leveldb.log.LogTest.reader_,,db\log_test.cc,* reader_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
359,36092,initial_offset_record_sizes_,3,leveldb.log.LogTest.initial_offset_record_sizes_,,db\log_test.cc,initial_offset_record_sizes_[],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
360,36093,initial_offset_last_record_offsets_,3,leveldb.log.LogTest.initial_offset_last_record_offsets_,,db\log_test.cc,initial_offset_last_record_offsets_[],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
361,36094,num_initial_offset_records_,3,leveldb.log.LogTest.num_initial_offset_records_,,db\log_test.cc,num_initial_offset_records_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
362,40124,dest_,3,leveldb.log.Writer.dest_,,db\log_writer.hpp,* dest_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
363,40125,block_offset_,3,leveldb.log.Writer.block_offset_,,db\log_writer.hpp,block_offset_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
364,40126,type_crc_,3,leveldb.log.Writer.type_crc_,,db\log_writer.hpp,type_crc_[kMaxRecordType + 1],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
365,40373,iter_,3,leveldb.MemTableIterator.iter_,,db\memtable.cc,iter_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
366,40374,tmp_,3,leveldb.MemTableIterator.tmp_,,db\memtable.cc,tmp_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
367,40695,comparator,3,leveldb.MemTable.KeyComparator.comparator,,db\memtable.hpp,comparator,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
368,40710,comparator_,3,leveldb.MemTable.comparator_,,db\memtable.hpp,comparator_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
369,40711,refs_,3,leveldb.MemTable.refs_,,db\memtable.hpp,refs_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
370,40712,arena_,3,leveldb.MemTable.arena_,,db\memtable.hpp,arena_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
371,40713,table_,3,leveldb.MemTable.table_,,db\memtable.hpp,table_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
372,41352,dbname_,3,leveldb.RecoveryTest.dbname_,,db\recovery_test.cc,dbname_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
373,41353,env_,3,leveldb.RecoveryTest.env_,,db\recovery_test.cc,* env_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
374,41354,db_,3,leveldb.RecoveryTest.db_,,db\recovery_test.cc,* db_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
375,42925,meta,3,leveldb.anonymous_namespace_9.Repairer.TableInfo.meta,,db\repair.cc,meta,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,16,0,1,1,0,0,,0,0,0,0,0,
376,42926,max_sequence,3,leveldb.anonymous_namespace_9.Repairer.TableInfo.max_sequence,,db\repair.cc,max_sequence,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
377,42927,dbname_,3,leveldb.anonymous_namespace_1.Repairer.dbname_,,db\repair.cc,dbname_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,14,0,1,1,0,0,,0,0,0,0,0,
378,42928,env_,3,leveldb.anonymous_namespace_1.Repairer.env_,,db\repair.cc,* const env_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
379,42929,icmp_,3,leveldb.anonymous_namespace_1.Repairer.icmp_,,db\repair.cc,icmp_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
380,42930,ipolicy_,3,leveldb.anonymous_namespace_1.Repairer.ipolicy_,,db\repair.cc,ipolicy_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
381,42931,options_,3,leveldb.anonymous_namespace_1.Repairer.options_,,db\repair.cc,options_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,15,0,1,1,0,0,,0,0,0,0,0,
382,42932,owns_info_log_,3,leveldb.anonymous_namespace_1.Repairer.owns_info_log_,,db\repair.cc,owns_info_log_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
383,42933,owns_cache_,3,leveldb.anonymous_namespace_1.Repairer.owns_cache_,,db\repair.cc,owns_cache_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
384,42934,table_cache_,3,leveldb.anonymous_namespace_1.Repairer.table_cache_,,db\repair.cc,* table_cache_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
385,42935,edit_,3,leveldb.anonymous_namespace_1.Repairer.edit_,,db\repair.cc,edit_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
386,42936,manifests_,3,leveldb.anonymous_namespace_1.Repairer.manifests_,,db\repair.cc,manifests_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
387,42937,table_numbers_,3,leveldb.anonymous_namespace_1.Repairer.table_numbers_,,db\repair.cc,table_numbers_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
388,42938,logs_,3,leveldb.anonymous_namespace_1.Repairer.logs_,,db\repair.cc,logs_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
389,42939,tables_,3,leveldb.anonymous_namespace_1.Repairer.tables_,,db\repair.cc,tables_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
390,42940,next_file_number_,3,leveldb.anonymous_namespace_1.Repairer.next_file_number_,,db\repair.cc,next_file_number_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
391,44299,list_,3,leveldb.SkipList.Iterator.list_,,db\skiplist.hpp,* list_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
392,44300,node_,3,leveldb.SkipList.Iterator.node_,,db\skiplist.hpp,* node_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
393,44302,kMaxHeight,3,leveldb.SkipList.anonymous_enum_0.kMaxHeight,,db\skiplist.hpp,kMaxHeight = 12,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
394,44310,compare_,3,leveldb.SkipList.compare_,,db\skiplist.hpp,compare_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
395,44311,arena_,3,leveldb.SkipList.arena_,,db\skiplist.hpp,* const arena_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
396,44312,head_,3,leveldb.SkipList.head_,,db\skiplist.hpp,* const head_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
397,44313,max_height_,3,leveldb.SkipList.max_height_,,db\skiplist.hpp,max_height_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
398,44327,rnd_,3,leveldb.SkipList.rnd_,,db\skiplist.hpp,rnd_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
399,44387,key,3,leveldb.Node.key,,db\skiplist.hpp,key,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
400,44458,next_,3,leveldb.Node.next_,,db\skiplist.hpp,next_[1],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
401,45798,K,3,leveldb.ConcurrentTest.K,,db\skiplist_test.cc,K = 4,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
402,45934,generation,3,leveldb.ConcurrentTest.State.generation,,db\skiplist_test.cc,generation[K],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
403,45989,current_,3,leveldb.ConcurrentTest.current_,,db\skiplist_test.cc,current_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
404,45990,arena_,3,leveldb.ConcurrentTest.arena_,,db\skiplist_test.cc,arena_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
405,45991,list_,3,leveldb.ConcurrentTest.list_,,db\skiplist_test.cc,list_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
406,46365,t_,3,leveldb.TestState.t_,,db\skiplist_test.cc,t_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
407,46366,seed_,3,leveldb.TestState.seed_,,db\skiplist_test.cc,seed_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
408,46367,quit_flag_,3,leveldb.TestState.quit_flag_,,db\skiplist_test.cc,quit_flag_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
409,46369,STARTING,3,leveldb.TestState.ReaderState.STARTING,,db\skiplist_test.cc,STARTING,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
410,46370,RUNNING,3,leveldb.TestState.ReaderState.RUNNING,,db\skiplist_test.cc,RUNNING,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
411,46371,DONE,3,leveldb.TestState.ReaderState.DONE,,db\skiplist_test.cc,DONE,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
412,46419,mu_,3,leveldb.TestState.mu_,,db\skiplist_test.cc,mu_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
413,46420,state_,3,leveldb.TestState.state_,,db\skiplist_test.cc,state_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
414,46421,state_cv_,3,leveldb.TestState.state_cv_,,db\skiplist_test.cc,state_cv_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
415,46783,number_,3,leveldb.SnapshotImpl.number_,,db\snapshot.hpp,number_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
416,46785,prev_,3,leveldb.SnapshotImpl.prev_,,db\snapshot.hpp,* prev_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
417,46786,next_,3,leveldb.SnapshotImpl.next_,,db\snapshot.hpp,* next_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
418,46787,list_,3,leveldb.SnapshotImpl.list_,,db\snapshot.hpp,* list_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
419,46918,list_,3,leveldb.SnapshotList.list_,,db\snapshot.hpp,list_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
420,46936,file,3,leveldb.TableAndFile.file,,db\table_cache.cc,* file,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
421,46937,table,3,leveldb.TableAndFile.table,,db\table_cache.cc,* table,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
422,47349,env_,3,leveldb.TableCache.env_,,db\table_cache.hpp,* const env_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
423,47350,dbname_,3,leveldb.TableCache.dbname_,,db\table_cache.hpp,dbname_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
424,47351,options_,3,leveldb.TableCache.options_,,db\table_cache.hpp,* options_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
425,47352,cache_,3,leveldb.TableCache.cache_,,db\table_cache.hpp,* cache_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
426,47373,kComparator,3,leveldb.Tag.kComparator,,db\version_edit.cc,kComparator           = 1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
427,47374,kLogNumber,3,leveldb.Tag.kLogNumber,,db\version_edit.cc,kLogNumber            = 2,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
428,47375,kNextFileNumber,3,leveldb.Tag.kNextFileNumber,,db\version_edit.cc,kNextFileNumber       = 3,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
429,47376,kLastSequence,3,leveldb.Tag.kLastSequence,,db\version_edit.cc,kLastSequence         = 4,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
430,47377,kCompactPointer,3,leveldb.Tag.kCompactPointer,,db\version_edit.cc,kCompactPointer       = 5,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
431,47378,kDeletedFile,3,leveldb.Tag.kDeletedFile,,db\version_edit.cc,kDeletedFile          = 6,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
432,47379,kNewFile,3,leveldb.Tag.kNewFile,,db\version_edit.cc,kNewFile              = 7,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
433,47380,kPrevLogNumber,3,leveldb.Tag.kPrevLogNumber,,db\version_edit.cc,kPrevLogNumber        = 9,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
434,48231,refs,3,leveldb.FileMetaData.refs,,db\version_edit.hpp,refs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
435,48232,allowed_seeks,3,leveldb.FileMetaData.allowed_seeks,,db\version_edit.hpp,allowed_seeks,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
436,48233,number,3,leveldb.FileMetaData.number,,db\version_edit.hpp,number,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,23,0,1,1,0,0,,0,0,0,0,0,
437,48234,file_size,3,leveldb.FileMetaData.file_size,,db\version_edit.hpp,file_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,18,0,1,1,0,0,,0,0,0,0,0,
438,48235,smallest,3,leveldb.FileMetaData.smallest,,db\version_edit.hpp,smallest,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,19,0,1,1,0,0,,0,0,0,0,0,
439,48236,largest,3,leveldb.FileMetaData.largest,,db\version_edit.hpp,largest,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,18,0,1,1,0,0,,0,0,0,0,0,
440,48401,comparator_,3,leveldb.VersionEdit.comparator_,,db\version_edit.hpp,comparator_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
441,48402,log_number_,3,leveldb.VersionEdit.log_number_,,db\version_edit.hpp,log_number_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
442,48403,prev_log_number_,3,leveldb.VersionEdit.prev_log_number_,,db\version_edit.hpp,prev_log_number_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
443,48404,next_file_number_,3,leveldb.VersionEdit.next_file_number_,,db\version_edit.hpp,next_file_number_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
444,48405,last_sequence_,3,leveldb.VersionEdit.last_sequence_,,db\version_edit.hpp,last_sequence_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
445,48406,has_comparator_,3,leveldb.VersionEdit.has_comparator_,,db\version_edit.hpp,has_comparator_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
446,48407,has_log_number_,3,leveldb.VersionEdit.has_log_number_,,db\version_edit.hpp,has_log_number_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
447,48408,has_prev_log_number_,3,leveldb.VersionEdit.has_prev_log_number_,,db\version_edit.hpp,has_prev_log_number_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
448,48409,has_next_file_number_,3,leveldb.VersionEdit.has_next_file_number_,,db\version_edit.hpp,has_next_file_number_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
449,48410,has_last_sequence_,3,leveldb.VersionEdit.has_last_sequence_,,db\version_edit.hpp,has_last_sequence_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
450,48411,compact_pointers_,3,leveldb.VersionEdit.compact_pointers_,,db\version_edit.hpp,compact_pointers_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
451,48412,deleted_files_,3,leveldb.VersionEdit.deleted_files_,,db\version_edit.hpp,deleted_files_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
452,48413,new_files_,3,leveldb.VersionEdit.new_files_,,db\version_edit.hpp,new_files_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
453,49205,icmp_,3,leveldb.LevelFileNumIterator.icmp_,,db\version_set.cc,icmp_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
454,49206,flist_,3,leveldb.LevelFileNumIterator.flist_,,db\version_set.cc,* const flist_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
455,49207,index_,3,leveldb.LevelFileNumIterator.index_,,db\version_set.cc,index_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
456,49208,value_buf_,3,leveldb.LevelFileNumIterator.value_buf_,,db\version_set.cc,value_buf_[16],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
457,49366,kNotFound,3,leveldb.anonymous_namespace_1.SaverState.kNotFound,,db\version_set.cc,kNotFound,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
458,49367,kFound,3,leveldb.anonymous_namespace_1.SaverState.kFound,,db\version_set.cc,kFound,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
459,49368,kDeleted,3,leveldb.anonymous_namespace_1.SaverState.kDeleted,,db\version_set.cc,kDeleted,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
460,49369,kCorrupt,3,leveldb.anonymous_namespace_1.SaverState.kCorrupt,,db\version_set.cc,kCorrupt,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
461,49371,state,3,leveldb.anonymous_namespace_2.Saver.state,,db\version_set.cc,state,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
462,49372,ucmp,3,leveldb.anonymous_namespace_2.Saver.ucmp,,db\version_set.cc,* ucmp,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
463,49373,user_key,3,leveldb.anonymous_namespace_2.Saver.user_key,,db\version_set.cc,user_key,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
464,49374,value,3,leveldb.anonymous_namespace_2.Saver.value,,db\version_set.cc,* value,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
465,50600,internal_comparator,3,leveldb.Builder.BySmallestKey.internal_comparator,,db\version_set.cc,* internal_comparator,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
466,50641,deleted_files,3,leveldb.Builder.LevelState.deleted_files,,db\version_set.cc,deleted_files,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
467,50642,added_files,3,leveldb.Builder.LevelState.added_files,,db\version_set.cc,* added_files,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
468,50643,vset_,3,leveldb.Builder.vset_,,db\version_set.cc,* vset_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
469,50644,base_,3,leveldb.Builder.base_,,db\version_set.cc,* base_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
470,50645,levels_,3,leveldb.Builder.levels_,,db\version_set.cc,levels_[config::kNumLevels],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
471,54044,seek_file,3,leveldb.Version.GetStats.seek_file,,db\version_set.hpp,* seek_file,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
472,54045,seek_file_level,3,leveldb.Version.GetStats.seek_file_level,,db\version_set.hpp,seek_file_level,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
473,54126,vset_,3,leveldb.Version.vset_,,db\version_set.hpp,* vset_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
474,54127,next_,3,leveldb.Version.next_,,db\version_set.hpp,* next_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
475,54128,prev_,3,leveldb.Version.prev_,,db\version_set.hpp,* prev_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
476,54129,refs_,3,leveldb.Version.refs_,,db\version_set.hpp,refs_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
477,54130,files_,3,leveldb.Version.files_,,db\version_set.hpp,files_[config::kNumLevels],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,26,0,1,1,0,0,,0,0,0,0,0,
478,54131,file_to_compact_,3,leveldb.Version.file_to_compact_,,db\version_set.hpp,* file_to_compact_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
479,54132,file_to_compact_level_,3,leveldb.Version.file_to_compact_level_,,db\version_set.hpp,file_to_compact_level_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
480,54133,compaction_score_,3,leveldb.Version.compaction_score_,,db\version_set.hpp,compaction_score_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
481,54134,compaction_level_,3,leveldb.Version.compaction_level_,,db\version_set.hpp,compaction_level_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
482,54317,buffer,3,leveldb.VersionSet.LevelSummaryStorage.buffer,,db\version_set.hpp,buffer[100],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
483,54373,env_,3,leveldb.VersionSet.env_,,db\version_set.hpp,* const env_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
484,54374,dbname_,3,leveldb.VersionSet.dbname_,,db\version_set.hpp,dbname_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
485,54375,options_,3,leveldb.VersionSet.options_,,db\version_set.hpp,* const options_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,14,0,1,1,0,0,,0,0,0,0,0,
486,54376,table_cache_,3,leveldb.VersionSet.table_cache_,,db\version_set.hpp,* const table_cache_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
487,54377,icmp_,3,leveldb.VersionSet.icmp_,,db\version_set.hpp,icmp_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
488,54378,next_file_number_,3,leveldb.VersionSet.next_file_number_,,db\version_set.hpp,next_file_number_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
489,54379,manifest_file_number_,3,leveldb.VersionSet.manifest_file_number_,,db\version_set.hpp,manifest_file_number_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
490,54380,last_sequence_,3,leveldb.VersionSet.last_sequence_,,db\version_set.hpp,last_sequence_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
491,54381,log_number_,3,leveldb.VersionSet.log_number_,,db\version_set.hpp,log_number_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
492,54382,prev_log_number_,3,leveldb.VersionSet.prev_log_number_,,db\version_set.hpp,prev_log_number_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
493,54383,descriptor_file_,3,leveldb.VersionSet.descriptor_file_,,db\version_set.hpp,* descriptor_file_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
494,54384,descriptor_log_,3,leveldb.VersionSet.descriptor_log_,,db\version_set.hpp,* descriptor_log_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
495,54385,dummy_versions_,3,leveldb.VersionSet.dummy_versions_,,db\version_set.hpp,dummy_versions_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
496,54386,current_,3,leveldb.VersionSet.current_,,db\version_set.hpp,* current_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,36,0,1,1,0,0,,0,0,0,0,0,
497,54387,compact_pointer_,3,leveldb.VersionSet.compact_pointer_,,db\version_set.hpp,compact_pointer_[config::kNumLevels],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
498,54485,level_,3,leveldb.Compaction.level_,,db\version_set.hpp,level_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
499,54486,max_output_file_size_,3,leveldb.Compaction.max_output_file_size_,,db\version_set.hpp,max_output_file_size_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
500,54487,input_version_,3,leveldb.Compaction.input_version_,,db\version_set.hpp,* input_version_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
501,54488,edit_,3,leveldb.Compaction.edit_,,db\version_set.hpp,edit_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
502,54489,inputs_,3,leveldb.Compaction.inputs_,,db\version_set.hpp,inputs_[2],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,29,0,1,1,0,0,,0,0,0,0,0,
503,54490,grandparents_,3,leveldb.Compaction.grandparents_,,db\version_set.hpp,grandparents_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
504,54491,grandparent_index_,3,leveldb.Compaction.grandparent_index_,,db\version_set.hpp,grandparent_index_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
505,54492,seen_key_,3,leveldb.Compaction.seen_key_,,db\version_set.hpp,seen_key_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
506,54493,overlapped_bytes_,3,leveldb.Compaction.overlapped_bytes_,,db\version_set.hpp,overlapped_bytes_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
507,54494,level_ptrs_,3,leveldb.Compaction.level_ptrs_,,db\version_set.hpp,level_ptrs_[config::kNumLevels],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
508,54520,files_,3,leveldb.FindFileTest.files_,,db\version_set_test.cc,files_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
509,54521,disjoint_sorted_files_,3,leveldb.FindFileTest.disjoint_sorted_files_,,db\version_set_test.cc,disjoint_sorted_files_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
510,56778,sequence_,3,leveldb.anonymous_namespace_1.MemTableInserter.sequence_,,db\write_batch.cc,sequence_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
511,56779,mem_,3,leveldb.anonymous_namespace_1.MemTableInserter.mem_,,db\write_batch.cc,* mem_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
512,57849,data_,3,leveldb.anonymous_namespace_1.RandomGenerator.data_,,doc\bench\db_bench_sqlite3.cc,data_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
513,57850,pos_,3,leveldb.anonymous_namespace_1.RandomGenerator.pos_,,doc\bench\db_bench_sqlite3.cc,pos_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
514,57981,db_,3,leveldb.Benchmark.db_,,doc\bench\db_bench_sqlite3.cc,* db_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
515,57982,db_num_,3,leveldb.Benchmark.db_num_,,doc\bench\db_bench_sqlite3.cc,db_num_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
516,57983,num_,3,leveldb.Benchmark.num_,,doc\bench\db_bench_sqlite3.cc,num_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
517,57984,reads_,3,leveldb.Benchmark.reads_,,doc\bench\db_bench_sqlite3.cc,reads_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
518,57985,start_,3,leveldb.Benchmark.start_,,doc\bench\db_bench_sqlite3.cc,start_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
519,57986,last_op_finish_,3,leveldb.Benchmark.last_op_finish_,,doc\bench\db_bench_sqlite3.cc,last_op_finish_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
520,57987,bytes_,3,leveldb.Benchmark.bytes_,,doc\bench\db_bench_sqlite3.cc,bytes_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
521,57988,message_,3,leveldb.Benchmark.message_,,doc\bench\db_bench_sqlite3.cc,message_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
522,57989,hist_,3,leveldb.Benchmark.hist_,,doc\bench\db_bench_sqlite3.cc,hist_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
523,57990,gen_,3,leveldb.Benchmark.gen_,,doc\bench\db_bench_sqlite3.cc,gen_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
524,57991,rand_,3,leveldb.Benchmark.rand_,,doc\bench\db_bench_sqlite3.cc,rand_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
525,57992,done_,3,leveldb.Benchmark.done_,,doc\bench\db_bench_sqlite3.cc,done_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
526,57993,next_report_,3,leveldb.Benchmark.next_report_,,doc\bench\db_bench_sqlite3.cc,next_report_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
527,58312,SEQUENTIAL,3,leveldb.Benchmark.Order.SEQUENTIAL,,doc\bench\db_bench_sqlite3.cc,SEQUENTIAL,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
528,58313,RANDOM,3,leveldb.Benchmark.Order.RANDOM,,doc\bench\db_bench_sqlite3.cc,RANDOM,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
529,58315,FRESH,3,leveldb.Benchmark.DBState.FRESH,,doc\bench\db_bench_sqlite3.cc,FRESH,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
530,58316,EXISTING,3,leveldb.Benchmark.DBState.EXISTING,,doc\bench\db_bench_sqlite3.cc,EXISTING,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
531,59864,data_,3,leveldb.anonymous_namespace_1.RandomGenerator.data_,,doc\bench\db_bench_tree_db.cc,data_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
532,59865,pos_,3,leveldb.anonymous_namespace_1.RandomGenerator.pos_,,doc\bench\db_bench_tree_db.cc,pos_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
533,59996,db_,3,leveldb.Benchmark.db_,,doc\bench\db_bench_tree_db.cc,* db_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
534,59997,db_num_,3,leveldb.Benchmark.db_num_,,doc\bench\db_bench_tree_db.cc,db_num_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
535,59998,num_,3,leveldb.Benchmark.num_,,doc\bench\db_bench_tree_db.cc,num_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
536,59999,reads_,3,leveldb.Benchmark.reads_,,doc\bench\db_bench_tree_db.cc,reads_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
537,60000,start_,3,leveldb.Benchmark.start_,,doc\bench\db_bench_tree_db.cc,start_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
538,60001,last_op_finish_,3,leveldb.Benchmark.last_op_finish_,,doc\bench\db_bench_tree_db.cc,last_op_finish_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
539,60002,bytes_,3,leveldb.Benchmark.bytes_,,doc\bench\db_bench_tree_db.cc,bytes_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
540,60003,message_,3,leveldb.Benchmark.message_,,doc\bench\db_bench_tree_db.cc,message_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
541,60004,hist_,3,leveldb.Benchmark.hist_,,doc\bench\db_bench_tree_db.cc,hist_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
542,60005,gen_,3,leveldb.Benchmark.gen_,,doc\bench\db_bench_tree_db.cc,gen_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
543,60006,rand_,3,leveldb.Benchmark.rand_,,doc\bench\db_bench_tree_db.cc,rand_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
544,60007,comp_,3,leveldb.Benchmark.comp_,,doc\bench\db_bench_tree_db.cc,comp_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
545,60008,done_,3,leveldb.Benchmark.done_,,doc\bench\db_bench_tree_db.cc,done_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
546,60009,next_report_,3,leveldb.Benchmark.next_report_,,doc\bench\db_bench_tree_db.cc,next_report_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
547,60355,SEQUENTIAL,3,leveldb.Benchmark.Order.SEQUENTIAL,,doc\bench\db_bench_tree_db.cc,SEQUENTIAL,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
548,60356,RANDOM,3,leveldb.Benchmark.Order.RANDOM,,doc\bench\db_bench_tree_db.cc,RANDOM,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
549,60358,FRESH,3,leveldb.Benchmark.DBState.FRESH,,doc\bench\db_bench_tree_db.cc,FRESH,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
550,60359,EXISTING,3,leveldb.Benchmark.DBState.EXISTING,,doc\bench\db_bench_tree_db.cc,EXISTING,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
551,61683,refs_mutex_,3,leveldb.anonymous_namespace_1.FileState.refs_mutex_,,helpers\memenv\memenv.cc,refs_mutex_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
552,61684,refs_,3,leveldb.anonymous_namespace_1.FileState.refs_,,helpers\memenv\memenv.cc,refs_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
553,61685,blocks_,3,leveldb.anonymous_namespace_1.FileState.blocks_,,helpers\memenv\memenv.cc,blocks_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
554,61686,size_,3,leveldb.anonymous_namespace_1.FileState.size_,,helpers\memenv\memenv.cc,size_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
555,61688,kBlockSize,3,leveldb.anonymous_namespace_11.FileState.anonymous_enum_12.kBlockSize,,helpers\memenv\memenv.cc,kBlockSize = 8 * 1024,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
556,61792,file_,3,leveldb.anonymous_namespace_13.SequentialFileImpl.file_,,helpers\memenv\memenv.cc,* file_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
557,61793,pos_,3,leveldb.anonymous_namespace_13.SequentialFileImpl.pos_,,helpers\memenv\memenv.cc,pos_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
558,61829,file_,3,leveldb.anonymous_namespace_18.RandomAccessFileImpl.file_,,helpers\memenv\memenv.cc,* file_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
559,61886,file_,3,leveldb.anonymous_namespace_22.WritableFileImpl.file_,,helpers\memenv\memenv.cc,* file_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
560,62456,mutex_,3,leveldb.anonymous_namespace_31.InMemoryEnv.mutex_,,helpers\memenv\memenv.cc,mutex_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
561,62457,file_map_,3,leveldb.anonymous_namespace_31.InMemoryEnv.file_map_,,helpers\memenv\memenv.cc,file_map_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,30,0,1,1,0,0,,0,0,0,0,0,
562,62500,env_,3,leveldb.MemEnvTest.env_,,helpers\memenv\memenv_test.cc,* env_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
563,65186,leveldb_no_compression,3,anonymous_enum_0.leveldb_no_compression,,include\leveldb\c.hpp,leveldb_no_compression = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
564,65187,leveldb_snappy_compression,3,anonymous_enum_0.leveldb_snappy_compression,,include\leveldb\c.hpp,leveldb_snappy_compression = 1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
565,65392,rep_,3,leveldb.Cache.rep_,,include\leveldb\cache.hpp,* rep_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
566,65474,start,3,leveldb.Range.start,,include\leveldb\db.hpp,start,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
567,65475,limit,3,leveldb.Range.limit,,include\leveldb\db.hpp,limit,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
568,66154,target_,3,leveldb.EnvWrapper.target_,,include\leveldb\env.hpp,* target_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,20,0,1,1,0,0,,0,0,0,0,0,
569,66261,function,3,leveldb.Iterator.Cleanup.function,,include\leveldb\iterator.hpp,function,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
570,66262,arg1,3,leveldb.Iterator.Cleanup.arg1,,include\leveldb\iterator.hpp,* arg1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
571,66263,arg2,3,leveldb.Iterator.Cleanup.arg2,,include\leveldb\iterator.hpp,* arg2,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
572,66264,next,3,leveldb.Iterator.Cleanup.next,,include\leveldb\iterator.hpp,* next,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
573,66265,cleanup_,3,leveldb.Iterator.cleanup_,,include\leveldb\iterator.hpp,cleanup_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
574,66300,kNoCompression,3,leveldb.CompressionType.kNoCompression,,include\leveldb\options.hpp,kNoCompression     = 0x0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
575,66301,kSnappyCompression,3,leveldb.CompressionType.kSnappyCompression,,include\leveldb\options.hpp,kSnappyCompression = 0x1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
576,66313,comparator,3,leveldb.Options.comparator,,include\leveldb\options.hpp,* comparator,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
577,66314,create_if_missing,3,leveldb.Options.create_if_missing,,include\leveldb\options.hpp,create_if_missing,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
578,66315,error_if_exists,3,leveldb.Options.error_if_exists,,include\leveldb\options.hpp,error_if_exists,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
579,66316,paranoid_checks,3,leveldb.Options.paranoid_checks,,include\leveldb\options.hpp,paranoid_checks,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
580,66317,env,3,leveldb.Options.env,,include\leveldb\options.hpp,* env,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
581,66318,info_log,3,leveldb.Options.info_log,,include\leveldb\options.hpp,* info_log,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
582,66319,write_buffer_size,3,leveldb.Options.write_buffer_size,,include\leveldb\options.hpp,write_buffer_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
583,66320,max_open_files,3,leveldb.Options.max_open_files,,include\leveldb\options.hpp,max_open_files,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
584,66321,block_cache,3,leveldb.Options.block_cache,,include\leveldb\options.hpp,* block_cache,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
585,66322,block_size,3,leveldb.Options.block_size,,include\leveldb\options.hpp,block_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
586,66323,block_restart_interval,3,leveldb.Options.block_restart_interval,,include\leveldb\options.hpp,block_restart_interval,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
587,66324,max_file_size,3,leveldb.Options.max_file_size,,include\leveldb\options.hpp,max_file_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
588,66325,compression,3,leveldb.Options.compression,,include\leveldb\options.hpp,compression,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
589,66326,reuse_logs,3,leveldb.Options.reuse_logs,,include\leveldb\options.hpp,reuse_logs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
590,66327,filter_policy,3,leveldb.Options.filter_policy,,include\leveldb\options.hpp,* filter_policy,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
591,66333,verify_checksums,3,leveldb.ReadOptions.verify_checksums,,include\leveldb\options.hpp,verify_checksums,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
592,66334,fill_cache,3,leveldb.ReadOptions.fill_cache,,include\leveldb\options.hpp,fill_cache,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
593,66335,snapshot,3,leveldb.ReadOptions.snapshot,,include\leveldb\options.hpp,* snapshot,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
594,66341,sync,3,leveldb.WriteOptions.sync,,include\leveldb\options.hpp,sync,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
595,66477,data_,3,leveldb.Slice.data_,,include\leveldb\slice.hpp,* data_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
596,66478,size_,3,leveldb.Slice.size_,,include\leveldb\slice.hpp,size_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
597,66724,state_,3,leveldb.Status.state_,,include\leveldb\status.hpp,* state_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
598,66726,kOk,3,leveldb.Status.Code.kOk,,include\leveldb\status.hpp,kOk = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
599,66727,kNotFound,3,leveldb.Status.Code.kNotFound,,include\leveldb\status.hpp,kNotFound = 1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
600,66728,kCorruption,3,leveldb.Status.Code.kCorruption,,include\leveldb\status.hpp,kCorruption = 2,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
601,66729,kNotSupported,3,leveldb.Status.Code.kNotSupported,,include\leveldb\status.hpp,kNotSupported = 3,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
602,66730,kInvalidArgument,3,leveldb.Status.Code.kInvalidArgument,,include\leveldb\status.hpp,kInvalidArgument = 4,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
603,66731,kIOError,3,leveldb.Status.Code.kIOError,,include\leveldb\status.hpp,kIOError = 5,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
604,66867,rep_,3,leveldb.Table.rep_,,include\leveldb\table.hpp,* rep_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
605,66996,rep_,3,leveldb.TableBuilder.rep_,,include\leveldb\table_builder.hpp,* rep_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
606,67064,rep_,3,leveldb.WriteBatch.rep_,,include\leveldb\write_batch.hpp,rep_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,19,0,1,1,0,0,,0,0,0,0,0,
607,67935,rep_,3,leveldb.port.AtomicPointer.rep_,,port\port_example.hpp,rep_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
608,68189,mu_,3,leveldb.port.Mutex.mu_,,port\port_posix.hpp,mu_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
609,68222,cv_,3,leveldb.port.CondVar.cv_,,port\port_posix.hpp,cv_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
610,68223,mu_,3,leveldb.port.CondVar.mu_,,port\port_posix.hpp,* mu_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
611,68524,comparator_,3,leveldb.Iter.comparator_,,table\block.cc,* const comparator_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
612,68525,data_,3,leveldb.Iter.data_,,table\block.cc,* const data_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
613,68526,restarts_,3,leveldb.Iter.restarts_,,table\block.cc,restarts_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
614,68527,num_restarts_,3,leveldb.Iter.num_restarts_,,table\block.cc,num_restarts_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
615,68528,current_,3,leveldb.Iter.current_,,table\block.cc,current_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
616,68529,restart_index_,3,leveldb.Iter.restart_index_,,table\block.cc,restart_index_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
617,68530,key_,3,leveldb.Iter.key_,,table\block.cc,key_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
618,68531,value_,3,leveldb.Iter.value_,,table\block.cc,value_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
619,68532,status_,3,leveldb.Iter.status_,,table\block.cc,status_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
620,69020,data_,3,leveldb.Block.data_,,table\block.hpp,* data_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
621,69021,size_,3,leveldb.Block.size_,,table\block.hpp,size_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
622,69022,restart_offset_,3,leveldb.Block.restart_offset_,,table\block.hpp,restart_offset_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
623,69023,owned_,3,leveldb.Block.owned_,,table\block.hpp,owned_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
624,69358,options_,3,leveldb.BlockBuilder.options_,,table\block_builder.hpp,*        options_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
625,69359,buffer_,3,leveldb.BlockBuilder.buffer_,,table\block_builder.hpp,buffer_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
626,69360,restarts_,3,leveldb.BlockBuilder.restarts_,,table\block_builder.hpp,restarts_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
627,69361,counter_,3,leveldb.BlockBuilder.counter_,,table\block_builder.hpp,counter_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
628,69362,finished_,3,leveldb.BlockBuilder.finished_,,table\block_builder.hpp,finished_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
629,69363,last_key_,3,leveldb.BlockBuilder.last_key_,,table\block_builder.hpp,last_key_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
630,69809,policy_,3,leveldb.FilterBlockBuilder.policy_,,table\filter_block.hpp,* policy_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
631,69810,keys_,3,leveldb.FilterBlockBuilder.keys_,,table\filter_block.hpp,keys_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
632,69811,start_,3,leveldb.FilterBlockBuilder.start_,,table\filter_block.hpp,start_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
633,69812,result_,3,leveldb.FilterBlockBuilder.result_,,table\filter_block.hpp,result_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
634,69813,tmp_keys_,3,leveldb.FilterBlockBuilder.tmp_keys_,,table\filter_block.hpp,tmp_keys_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
635,69814,filter_offsets_,3,leveldb.FilterBlockBuilder.filter_offsets_,,table\filter_block.hpp,filter_offsets_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
636,69838,policy_,3,leveldb.FilterBlockReader.policy_,,table\filter_block.hpp,* policy_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
637,69839,data_,3,leveldb.FilterBlockReader.data_,,table\filter_block.hpp,* data_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
638,69840,offset_,3,leveldb.FilterBlockReader.offset_,,table\filter_block.hpp,* offset_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
639,69841,num_,3,leveldb.FilterBlockReader.num_,,table\filter_block.hpp,num_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
640,69842,base_lg_,3,leveldb.FilterBlockReader.base_lg_,,table\filter_block.hpp,base_lg_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
641,69962,policy_,3,leveldb.FilterBlockTest.policy_,,table\filter_block_test.cc,policy_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
642,71306,kMaxEncodedLength,3,leveldb.BlockHandle.anonymous_enum_0.kMaxEncodedLength,,table\format.hpp,kMaxEncodedLength = 10 + 10,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
643,71316,offset_,3,leveldb.BlockHandle.offset_,,table\format.hpp,offset_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
644,71317,size_,3,leveldb.BlockHandle.size_,,table\format.hpp,size_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
645,71362,kEncodedLength,3,leveldb.Footer.anonymous_enum_1.kEncodedLength,,table\format.hpp,kEncodedLength = 2*BlockHandle::kMaxEncodedLength + 8,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
646,71376,metaindex_handle_,3,leveldb.Footer.metaindex_handle_,,table\format.hpp,metaindex_handle_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
647,71377,index_handle_,3,leveldb.Footer.index_handle_,,table\format.hpp,index_handle_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
648,71387,data,3,leveldb.BlockContents.data,,table\format.hpp,data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
649,71388,cachable,3,leveldb.BlockContents.cachable,,table\format.hpp,cachable,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
650,71389,heap_allocated,3,leveldb.BlockContents.heap_allocated,,table\format.hpp,heap_allocated,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
651,71596,status_,3,leveldb.anonymous_namespace_1.EmptyIterator.status_,,table\iterator.cc,status_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
652,71784,iter_,3,leveldb.IteratorWrapper.iter_,,table\iterator_wrapper.hpp,* iter_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,20,0,1,1,0,0,,0,0,0,0,0,
653,71785,valid_,3,leveldb.IteratorWrapper.valid_,,table\iterator_wrapper.hpp,valid_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
654,71786,key_,3,leveldb.IteratorWrapper.key_,,table\iterator_wrapper.hpp,key_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
655,72124,comparator_,3,leveldb.anonymous_namespace_1.MergingIterator.comparator_,,table\merger.cc,* comparator_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
656,72125,children_,3,leveldb.anonymous_namespace_1.MergingIterator.children_,,table\merger.cc,* children_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
657,72126,n_,3,leveldb.anonymous_namespace_1.MergingIterator.n_,,table\merger.cc,n_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
658,72127,current_,3,leveldb.anonymous_namespace_1.MergingIterator.current_,,table\merger.cc,* current_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
659,72129,kForward,3,leveldb.anonymous_namespace_22.MergingIterator.Direction.kForward,,table\merger.cc,kForward,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
660,72130,kReverse,3,leveldb.anonymous_namespace_22.MergingIterator.Direction.kReverse,,table\merger.cc,kReverse,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
661,72131,direction_,3,leveldb.anonymous_namespace_1.MergingIterator.direction_,,table\merger.cc,direction_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
662,72355,options,3,leveldb.Rep.options,,table\table.cc,options,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
663,72356,status,3,leveldb.Rep.status,,table\table.cc,status,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
664,72357,file,3,leveldb.Rep.file,,table\table.cc,* file,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
665,72358,cache_id,3,leveldb.Rep.cache_id,,table\table.cc,cache_id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
666,72359,filter,3,leveldb.Rep.filter,,table\table.cc,* filter,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
667,72360,filter_data,3,leveldb.Rep.filter_data,,table\table.cc,* filter_data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
668,72361,metaindex_handle,3,leveldb.Rep.metaindex_handle,,table\table.cc,metaindex_handle,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
669,72362,index_block,3,leveldb.Rep.index_block,,table\table.cc,* index_block,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
670,73289,options,3,leveldb.Rep.options,,table\table_builder.cc,options,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
671,73290,index_block_options,3,leveldb.Rep.index_block_options,,table\table_builder.cc,index_block_options,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
672,73291,file,3,leveldb.Rep.file,,table\table_builder.cc,* file,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
673,73292,offset,3,leveldb.Rep.offset,,table\table_builder.cc,offset,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
674,73293,status,3,leveldb.Rep.status,,table\table_builder.cc,status,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
675,73294,data_block,3,leveldb.Rep.data_block,,table\table_builder.cc,data_block,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
676,73295,index_block,3,leveldb.Rep.index_block,,table\table_builder.cc,index_block,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
677,73296,last_key,3,leveldb.Rep.last_key,,table\table_builder.cc,last_key,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
678,73297,num_entries,3,leveldb.Rep.num_entries,,table\table_builder.cc,num_entries,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
679,73298,closed,3,leveldb.Rep.closed,,table\table_builder.cc,closed,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
680,73299,filter_block,3,leveldb.Rep.filter_block,,table\table_builder.cc,* filter_block,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
681,73300,pending_index_entry,3,leveldb.Rep.pending_index_entry,,table\table_builder.cc,pending_index_entry,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
682,73301,pending_handle,3,leveldb.Rep.pending_handle,,table\table_builder.cc,pending_handle,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
683,73302,compressed_output,3,leveldb.Rep.compressed_output,,table\table_builder.cc,compressed_output,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
684,74271,cmp,3,leveldb.anonymous_namespace_7.STLLessThan.cmp,,table\table_test.cc,* cmp,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
685,74358,contents_,3,leveldb.StringSink.contents_,,table\table_test.cc,contents_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
686,74436,contents_,3,leveldb.StringSource.contents_,,table\table_test.cc,contents_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
687,74562,data_,3,leveldb.Constructor.data_,,table\table_test.cc,data_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
688,74663,comparator_,3,leveldb.BlockConstructor.comparator_,,table\table_test.cc,* comparator_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
689,74664,data_,3,leveldb.BlockConstructor.data_,,table\table_test.cc,data_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
690,74665,block_,3,leveldb.BlockConstructor.block_,,table\table_test.cc,* block_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
691,74886,source_,3,leveldb.TableConstructor.source_,,table\table_test.cc,* source_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
692,74887,table_,3,leveldb.TableConstructor.table_,,table\table_test.cc,* table_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
693,75020,status_,3,leveldb.KeyConvertingIterator.status_,,table\table_test.cc,status_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
694,75021,iter_,3,leveldb.KeyConvertingIterator.iter_,,table\table_test.cc,* iter_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
695,75126,internal_comparator_,3,leveldb.MemTableConstructor.internal_comparator_,,table\table_test.cc,internal_comparator_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
696,75127,memtable_,3,leveldb.MemTableConstructor.memtable_,,table\table_test.cc,* memtable_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
697,75334,comparator_,3,leveldb.DBConstructor.comparator_,,table\table_test.cc,* comparator_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
698,75335,db_,3,leveldb.DBConstructor.db_,,table\table_test.cc,* db_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
699,75337,TABLE_TEST,3,leveldb.TestType.TABLE_TEST,,table\table_test.cc,TABLE_TEST,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
700,75338,BLOCK_TEST,3,leveldb.TestType.BLOCK_TEST,,table\table_test.cc,BLOCK_TEST,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
701,75339,MEMTABLE_TEST,3,leveldb.TestType.MEMTABLE_TEST,,table\table_test.cc,MEMTABLE_TEST,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
702,75340,DB_TEST,3,leveldb.TestType.DB_TEST,,table\table_test.cc,DB_TEST,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
703,75342,type,3,leveldb.TestArgs.type,,table\table_test.cc,type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
704,75343,reverse_compare,3,leveldb.TestArgs.reverse_compare,,table\table_test.cc,reverse_compare,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
705,75344,restart_interval,3,leveldb.TestArgs.restart_interval,,table\table_test.cc,restart_interval,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
706,76315,options_,3,leveldb.Harness.options_,,table\table_test.cc,options_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
707,76316,constructor_,3,leveldb.Harness.constructor_,,table\table_test.cc,* constructor_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
708,78171,block_function_,3,leveldb.anonymous_namespace_2.TwoLevelIterator.block_function_,,table\two_level_iterator.cc,block_function_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
709,78172,arg_,3,leveldb.anonymous_namespace_2.TwoLevelIterator.arg_,,table\two_level_iterator.cc,* arg_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
710,78173,options_,3,leveldb.anonymous_namespace_2.TwoLevelIterator.options_,,table\two_level_iterator.cc,options_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
711,78174,status_,3,leveldb.anonymous_namespace_2.TwoLevelIterator.status_,,table\two_level_iterator.cc,status_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
712,78175,index_iter_,3,leveldb.anonymous_namespace_2.TwoLevelIterator.index_iter_,,table\two_level_iterator.cc,index_iter_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
713,78176,data_iter_,3,leveldb.anonymous_namespace_2.TwoLevelIterator.data_iter_,,table\two_level_iterator.cc,data_iter_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
714,78177,data_block_handle_,3,leveldb.anonymous_namespace_2.TwoLevelIterator.data_block_handle_,,table\two_level_iterator.cc,data_block_handle_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
715,78742,alloc_ptr_,3,leveldb.Arena.alloc_ptr_,,util\arena.hpp,* alloc_ptr_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
716,78743,alloc_bytes_remaining_,3,leveldb.Arena.alloc_bytes_remaining_,,util\arena.hpp,alloc_bytes_remaining_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
717,78744,blocks_,3,leveldb.Arena.blocks_,,util\arena.hpp,blocks_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
718,78745,memory_usage_,3,leveldb.Arena.memory_usage_,,util\arena.hpp,memory_usage_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
719,79169,bits_per_key_,3,leveldb.anonymous_namespace_2.BloomFilterPolicy.bits_per_key_,,util\bloom.cc,bits_per_key_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
720,79170,k_,3,leveldb.anonymous_namespace_2.BloomFilterPolicy.k_,,util\bloom.cc,k_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
721,79479,policy_,3,leveldb.BloomTest.policy_,,util\bloom_test.cc,* policy_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
722,79480,filter_,3,leveldb.BloomTest.filter_,,util\bloom_test.cc,filter_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
723,79481,keys_,3,leveldb.BloomTest.keys_,,util\bloom_test.cc,keys_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
724,80175,value,3,leveldb.anonymous_namespace_1.LRUHandle.value,,util\cache.cc,* value,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
725,80182,next_hash,3,leveldb.anonymous_namespace_1.LRUHandle.next_hash,,util\cache.cc,* next_hash,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
726,80183,next,3,leveldb.anonymous_namespace_1.LRUHandle.next,,util\cache.cc,* next,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
727,80184,prev,3,leveldb.anonymous_namespace_1.LRUHandle.prev,,util\cache.cc,* prev,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
728,80185,charge,3,leveldb.anonymous_namespace_1.LRUHandle.charge,,util\cache.cc,charge,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
729,80186,key_length,3,leveldb.anonymous_namespace_1.LRUHandle.key_length,,util\cache.cc,key_length,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
730,80187,in_cache,3,leveldb.anonymous_namespace_1.LRUHandle.in_cache,,util\cache.cc,in_cache,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
731,80188,refs,3,leveldb.anonymous_namespace_1.LRUHandle.refs,,util\cache.cc,refs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
732,80189,hash,3,leveldb.anonymous_namespace_1.LRUHandle.hash,,util\cache.cc,hash,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
733,80190,key_data,3,leveldb.anonymous_namespace_1.LRUHandle.key_data,,util\cache.cc,key_data[1],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
734,80324,length_,3,leveldb.anonymous_namespace_4.HandleTable.length_,,util\cache.cc,length_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
735,80325,elems_,3,leveldb.anonymous_namespace_4.HandleTable.elems_,,util\cache.cc,elems_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
736,80326,list_,3,leveldb.anonymous_namespace_4.HandleTable.list_,,util\cache.cc,** list_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
737,80564,capacity_,3,leveldb.anonymous_namespace_17.LRUCache.capacity_,,util\cache.cc,capacity_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
738,80565,mutex_,3,leveldb.anonymous_namespace_17.LRUCache.mutex_,,util\cache.cc,mutex_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
739,80566,usage_,3,leveldb.anonymous_namespace_17.LRUCache.usage_,,util\cache.cc,usage_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
740,80567,lru_,3,leveldb.anonymous_namespace_17.LRUCache.lru_,,util\cache.cc,lru_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
741,80568,in_use_,3,leveldb.anonymous_namespace_17.LRUCache.in_use_,,util\cache.cc,in_use_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
742,80569,table_,3,leveldb.anonymous_namespace_17.LRUCache.table_,,util\cache.cc,table_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
743,81095,shard_,3,leveldb.anonymous_namespace_54.ShardedLRUCache.shard_,,util\cache.cc,shard_[kNumShards],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
744,81096,id_mutex_,3,leveldb.anonymous_namespace_54.ShardedLRUCache.id_mutex_,,util\cache.cc,id_mutex_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
745,81097,last_id_,3,leveldb.anonymous_namespace_54.ShardedLRUCache.last_id_,,util\cache.cc,last_id_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
746,81401,current_,3,leveldb.CacheTest.current_,,util\cache_test.cc,* current_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
747,81424,kCacheSize,3,leveldb.CacheTest.kCacheSize,,util\cache_test.cc,kCacheSize = 1000,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
748,81425,deleted_keys_,3,leveldb.CacheTest.deleted_keys_,,util\cache_test.cc,deleted_keys_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
749,81426,deleted_values_,3,leveldb.CacheTest.deleted_values_,,util\cache_test.cc,deleted_values_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
750,81427,cache_,3,leveldb.CacheTest.cache_,,util\cache_test.cc,* cache_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
751,88540,mu_,3,leveldb.anonymous_namespace_2.Limiter.mu_,,util\env_posix.cc,mu_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
752,88541,allowed_,3,leveldb.anonymous_namespace_2.Limiter.allowed_,,util\env_posix.cc,allowed_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
753,88576,filename_,3,leveldb.anonymous_namespace_16.PosixSequentialFile.filename_,,util\env_posix.cc,filename_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
754,88577,file_,3,leveldb.anonymous_namespace_16.PosixSequentialFile.file_,,util\env_posix.cc,* file_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
755,88651,filename_,3,leveldb.anonymous_namespace_21.PosixRandomAccessFile.filename_,,util\env_posix.cc,filename_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
756,88652,temporary_fd_,3,leveldb.anonymous_namespace_21.PosixRandomAccessFile.temporary_fd_,,util\env_posix.cc,temporary_fd_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
757,88653,fd_,3,leveldb.anonymous_namespace_21.PosixRandomAccessFile.fd_,,util\env_posix.cc,fd_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
758,88654,limiter_,3,leveldb.anonymous_namespace_21.PosixRandomAccessFile.limiter_,,util\env_posix.cc,* limiter_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
759,88764,filename_,3,leveldb.anonymous_namespace_25.PosixMmapReadableFile.filename_,,util\env_posix.cc,filename_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
760,88765,mmapped_region_,3,leveldb.anonymous_namespace_25.PosixMmapReadableFile.mmapped_region_,,util\env_posix.cc,* mmapped_region_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
761,88766,length_,3,leveldb.anonymous_namespace_25.PosixMmapReadableFile.length_,,util\env_posix.cc,length_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
762,88767,limiter_,3,leveldb.anonymous_namespace_25.PosixMmapReadableFile.limiter_,,util\env_posix.cc,* limiter_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
763,88827,filename_,3,leveldb.anonymous_namespace_29.PosixWritableFile.filename_,,util\env_posix.cc,filename_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
764,88828,file_,3,leveldb.anonymous_namespace_29.PosixWritableFile.file_,,util\env_posix.cc,* file_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
765,89099,fd_,3,leveldb.anonymous_namespace_39.PosixFileLock.fd_,,util\env_posix.cc,fd_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
766,89100,name_,3,leveldb.anonymous_namespace_39.PosixFileLock.name_,,util\env_posix.cc,name_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
767,89102,mu_,3,leveldb.anonymous_namespace_40.PosixLockTable.mu_,,util\env_posix.cc,mu_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
768,89103,locked_files_,3,leveldb.anonymous_namespace_40.PosixLockTable.locked_files_,,util\env_posix.cc,locked_files_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
769,89921,mu_,3,leveldb.anonymous_namespace_43.PosixEnv.mu_,,util\env_posix.cc,mu_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
770,89922,bgsignal_,3,leveldb.anonymous_namespace_43.PosixEnv.bgsignal_,,util\env_posix.cc,bgsignal_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
771,89923,bgthread_,3,leveldb.anonymous_namespace_43.PosixEnv.bgthread_,,util\env_posix.cc,bgthread_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
772,89924,started_bgthread_,3,leveldb.anonymous_namespace_43.PosixEnv.started_bgthread_,,util\env_posix.cc,started_bgthread_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
773,89926,arg,3,leveldb.anonymous_namespace_73.PosixEnv.BGItem.arg,,util\env_posix.cc,* arg,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
774,89933,queue_,3,leveldb.anonymous_namespace_43.PosixEnv.queue_,,util\env_posix.cc,queue_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
775,89934,locks_,3,leveldb.anonymous_namespace_43.PosixEnv.locks_,,util\env_posix.cc,locks_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
776,89935,mmap_limit_,3,leveldb.anonymous_namespace_43.PosixEnv.mmap_limit_,,util\env_posix.cc,mmap_limit_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
777,89936,fd_limit_,3,leveldb.anonymous_namespace_43.PosixEnv.fd_limit_,,util\env_posix.cc,fd_limit_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
778,90149,arg,3,leveldb.anonymous_namespace_83.anonymous_namespace_84.StartThreadState.arg,,util\env_posix.cc,* arg,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
779,90277,env_,3,leveldb.EnvPosixTest.env_,,util\env_posix_test.cc,* env_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
780,90617,mu_,3,leveldb.EnvTest.mu_,,util\env_test.cc,mu_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
781,90618,events_,3,leveldb.EnvTest.events_,,util\env_test.cc,events_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
782,90619,env_,3,leveldb.EnvTest.env_,,util\env_test.cc,* env_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
783,90835,mu,3,leveldb.State.mu,,util\env_test.cc,mu,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
784,90836,val,3,leveldb.State.val,,util\env_test.cc,val,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
785,90837,num_running,3,leveldb.State.num_running,,util\env_test.cc,num_running,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
786,92083,min_,3,leveldb.Histogram.min_,,util\histogram.hpp,min_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
787,92084,max_,3,leveldb.Histogram.max_,,util\histogram.hpp,max_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
788,92085,num_,3,leveldb.Histogram.num_,,util\histogram.hpp,num_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,15,0,1,1,0,0,,0,0,0,0,0,
789,92086,sum_,3,leveldb.Histogram.sum_,,util\histogram.hpp,sum_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
790,92087,sum_squares_,3,leveldb.Histogram.sum_squares_,,util\histogram.hpp,sum_squares_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
791,92089,kNumBuckets,3,leveldb.Histogram.anonymous_enum_0.kNumBuckets,,util\histogram.hpp,kNumBuckets = 154,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
792,92097,kBucketLimit,3,leveldb.Histogram.kBucketLimit,,util\histogram.hpp,kBucketLimit[kNumBuckets],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
793,92098,buckets_,3,leveldb.Histogram.buckets_,,util\histogram.hpp,buckets_[kNumBuckets],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
794,92419,mu_,3,leveldb.MutexLock.mu_,,util\mutexlock.hpp,*const mu_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
795,92463,file_,3,leveldb.PosixLogger.file_,,util\posix_logger.hpp,* file_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
796,92678,seed_,3,leveldb.Random.seed_,,util\random.hpp,seed_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
797,93005,base,3,leveldb.test.anonymous_namespace_1.Test.base,,util\testharness.cc,* base,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
798,93006,name,3,leveldb.test.anonymous_namespace_1.Test.name,,util\testharness.cc,* name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
799,93254,ok_,3,leveldb.test.Tester.ok_,,util\testharness.hpp,ok_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
800,93255,fname_,3,leveldb.test.Tester.fname_,,util\testharness.hpp,* fname_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
801,93256,line_,3,leveldb.test.Tester.line_,,util\testharness.hpp,line_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
802,93257,ss_,3,leveldb.test.Tester.ss_,,util\testharness.hpp,ss_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
803,93708,writable_file_error_,3,leveldb.test.ErrorEnv.writable_file_error_,,util\testutil.hpp,writable_file_error_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
804,93709,num_writable_file_errors_,3,leveldb.test.ErrorEnv.num_writable_file_errors_,,util\testutil.hpp,num_writable_file_errors_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
805,23,AutoCompactTest,1,leveldb.AutoCompactTest.AutoCompactTest,ANY leveldb.AutoCompactTest.AutoCompactTest (),db\autocompact_test.cc,"AutoCompactTest() {
    dbname_ = test::TmpDir() + ""/autocompact_test"";
    tiny_cache_ = NewLRUCache(100);
    options_.block_cache = tiny_cache_;
    DestroyDB(dbname_, options_);
    options_.create_if_missing = true;
    options_.compression = kNoCompression;
    ASSERT_OK(DB::Open(options_, dbname_, &db_));
  }",20.0,28.0,3.0,4.0,9.0,15,4,16,7,0,11,1,1,0,0,,0,11,0,0,0,ANY
806,78,~AutoCompactTest,1,leveldb.AutoCompactTest.~AutoCompactTest,ANY leveldb.AutoCompactTest.~AutoCompactTest (),db\autocompact_test.cc,"~AutoCompactTest() {
    delete db_;
    DestroyDB(dbname_, Options());
    delete tiny_cache_;
  }",30.0,34.0,3.0,3.0,5.0,2,1,3,3,0,3,1,1,0,0,,0,3,0,0,0,ANY
807,89,Key,1,leveldb.AutoCompactTest.Key,string leveldb.AutoCompactTest.Key (int),db\autocompact_test.cc,"std::string Key(int i) {
    char buf[100];
    snprintf(buf, sizeof(buf), ""key%06d"", i);
    return std::string(buf);
  }",36.0,40.0,3.0,3.0,5.0,2,2,5,3,0,0,1,1,0,0,,0,0,2,1,1,string
808,107,Size,1,leveldb.AutoCompactTest.Size,"uint64_t leveldb.AutoCompactTest.Size (Slice,Slice)",db\autocompact_test.cc,"uint64_t Size(const Slice& start, const Slice& limit) {
    Range r(start, limit);
    uint64_t size;
    db_->GetApproximateSizes(&r, 1, &size);
    return size;
  }",42.0,47.0,3.0,3.0,6.0,3,2,6,5,0,1,1,1,0,0,,0,1,4,2,2,uint64_t
809,129,DoReads,1,leveldb.AutoCompactTest.DoReads,void leveldb.AutoCompactTest.DoReads (int),db\autocompact_test.cc,"void AutoCompactTest::DoReads(int n) {
  std::string value(kValueSize, 'x');
  DBImpl* dbi = reinterpret_cast<DBImpl*>(db_);

  // Fill database
  for (int i = 0; i < kCount; i++) {
    ASSERT_OK(db_->Put(WriteOptions(), Key(i), value));
  }
  ASSERT_OK(dbi->TEST_CompactMemTable());

  // Delete everything
  for (int i = 0; i < kCount; i++) {
    ASSERT_OK(db_->Delete(WriteOptions(), Key(i)));
  }
  ASSERT_OK(dbi->TEST_CompactMemTable());

  // Get initial measurement of the space we will be reading.
  const int64_t initial_size = Size(Key(0), Key(n));
  const int64_t initial_other_size = Size(Key(n), Key(kCount));

  // Read until size drops significantly.
  std::string limit_key = Key(n);
  for (int read = 0; true; read++) {
    ASSERT_LT(read, 100) << ""Taking too long to compact"";
    Iterator* iter = db_->NewIterator(ReadOptions());
    for (iter->SeekToFirst();
         iter->Valid() && iter->key().ToString() < limit_key;
         iter->Next()) {
      // Drop data
    }
    de...",58.0,104.0,1.0,4.0,47.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
810,448,_Run,1,leveldb._Test_ReadAll._Run,void leveldb._Test_ReadAll._Run (),db\autocompact_test.cc,"TEST(AutoCompactTest, ReadAll) {
  DoReads(kCount);
}",106.0,108.0,1.0,30.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
811,452,_RunIt,1,leveldb._Test_ReadAll._RunIt,void leveldb._Test_ReadAll._RunIt (),db\autocompact_test.cc,"TEST(AutoCompactTest, ReadAll)",106.0,106.0,1.0,30.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
812,483,_Run,1,leveldb._Test_ReadHalf._Run,void leveldb._Test_ReadHalf._Run (),db\autocompact_test.cc,"TEST(AutoCompactTest, ReadHalf) {
  DoReads(kCount/2);
}",110.0,112.0,1.0,31.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
813,487,_RunIt,1,leveldb._Test_ReadHalf._RunIt,void leveldb._Test_ReadHalf._RunIt (),db\autocompact_test.cc,"TEST(AutoCompactTest, ReadHalf)",110.0,110.0,1.0,31.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
814,519,main,1,main,"int main (int,char**)",util\hash_test.cc,"int main(int argc, char** argv) {
  return leveldb::test::RunAllTests();
}",52.0,54.0,1.0,1.0,3.0,2,1,2,2,0,1,1,1,0,0,,0,0,4,2,2,int
815,554,BuildTable,1,leveldb.BuildTable,"Status leveldb.BuildTable (ANY,Env*,Options,TableCache*,Iterator*,FileMetaData*)",db\builder.cc,"Status BuildTable(const std::string& dbname,
                  Env* env,
                  const Options& options,
                  TableCache* table_cache,
                  Iterator* iter,
                  FileMetaData* meta) {
  Status s;
  meta->file_size = 0;
  iter->SeekToFirst();

  std::string fname = TableFileName(dbname, meta->number);
  if (iter->Valid()) {
    WritableFile* file;
    s = env->NewWritableFile(fname, &file);
    if (!s.ok()) {
      return s;
    }

    TableBuilder* builder = new TableBuilder(options, file);
    meta->smallest.DecodeFrom(iter->key());
    for (; iter->Valid(); iter->Next()) {
      Slice key = iter->key();
      meta->largest.DecodeFrom(key);
      builder->Add(key, iter->value());
    }

    // Finish and check for builder errors
    if (s.ok()) {
      s = builder->Finish();
      if (s.ok()) {
        meta->file_size = builder->FileSize();
        assert(meta->file_size > 0);
      }
    } else {
      builder->Abandon();
    }
    d...",17.0,86.0,1.0,1.0,70.0,58,9,57,14,0,9,11,19,1,0,,0,9,12,6,6,Status
816,873,destructor_,1,leveldb_comparator_t.destructor_,void leveldb_comparator_t.destructor_ (void*),db\c.cc,void (*destructor_)(void*);,62.0,62.0,8.0,28.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
817,878,compare_,1,leveldb_comparator_t.compare_,"int leveldb_comparator_t.compare_ (void*,char*,size_t,char*,size_t)",db\c.cc,"int (*compare_)(
      void*,
      const char* a, size_t alen,
      const char* b, size_t blen);",63.0,66.0,7.0,33.0,4.0,0,0,0,0,0,0,1,1,0,0,,0,0,10,5,5,int
818,887,name_,1,leveldb_comparator_t.name_,char* leveldb_comparator_t.name_ (void*),db\c.cc,const char* (*name_)(void*);,67.0,67.0,13.0,29.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,char*
819,892,~leveldb_comparator_t,1,leveldb_comparator_t.~leveldb_comparator_t,ANY leveldb_comparator_t.~leveldb_comparator_t (),db\c.cc,"virtual ~leveldb_comparator_t() {
    (*destructor_)(state_);
  }",69.0,71.0,3.0,3.0,3.0,1,1,2,2,0,1,1,1,0,0,,0,1,0,0,0,ANY
820,900,Compare,1,leveldb_comparator_t.Compare,"int leveldb_comparator_t.Compare (Slice,Slice)",db\c.cc,"virtual int Compare(const Slice& a, const Slice& b) const {
    return (*compare_)(state_, a.data(), a.size(), b.data(), b.size());
  }",73.0,75.0,3.0,3.0,3.0,5,2,6,4,0,1,1,1,0,0,,0,1,4,2,2,int
821,927,Name,1,leveldb_comparator_t.Name,const char* leveldb_comparator_t.Name (),db\c.cc,"virtual const char* Name() const {
    return (*name_)(state_);
  }",77.0,79.0,3.0,3.0,3.0,1,1,2,2,0,1,1,1,0,0,,0,1,0,0,0,const char*
822,936,FindShortestSeparator,1,leveldb_comparator_t.FindShortestSeparator,"void leveldb_comparator_t.FindShortestSeparator (ANY*,Slice)",db\c.cc,"virtual void FindShortestSeparator(std::string*, const Slice&) const { }",82.0,82.0,3.0,74.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
823,942,FindShortSuccessor,1,leveldb_comparator_t.FindShortSuccessor,void leveldb_comparator_t.FindShortSuccessor (ANY*),db\c.cc,virtual void FindShortSuccessor(std::string* key) const { },83.0,83.0,3.0,61.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
824,949,destructor_,1,leveldb_filterpolicy_t.destructor_,void leveldb_filterpolicy_t.destructor_ (void*),db\c.cc,void (*destructor_)(void*);,88.0,88.0,8.0,28.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
825,954,name_,1,leveldb_filterpolicy_t.name_,char* leveldb_filterpolicy_t.name_ (void*),db\c.cc,const char* (*name_)(void*);,89.0,89.0,13.0,29.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,char*
826,959,create_,1,leveldb_filterpolicy_t.create_,"char* leveldb_filterpolicy_t.create_ (void*,char**,size_t*,int,size_t*)",db\c.cc,"char* (*create_)(
      void*,
      const char* const* key_array, const size_t* key_length_array,
      int num_keys,
      size_t* filter_length);",90.0,94.0,7.0,28.0,5.0,0,0,0,0,0,0,1,1,0,0,,0,0,10,5,5,char*
827,968,key_match_,1,leveldb_filterpolicy_t.key_match_,"unsigned char leveldb_filterpolicy_t.key_match_ (void*,char*,size_t,char*,size_t)",db\c.cc,"unsigned char (*key_match_)(
      void*,
      const char* key, size_t length,
      const char* filter, size_t filter_length);",95.0,98.0,17.0,47.0,4.0,0,0,0,0,0,0,1,1,0,0,,0,0,10,5,5,unsigned char
828,977,~leveldb_filterpolicy_t,1,leveldb_filterpolicy_t.~leveldb_filterpolicy_t,ANY leveldb_filterpolicy_t.~leveldb_filterpolicy_t (),db\c.cc,"virtual ~leveldb_filterpolicy_t() {
    (*destructor_)(state_);
  }",100.0,102.0,3.0,3.0,3.0,1,1,2,2,0,1,1,1,0,0,,0,1,0,0,0,ANY
829,985,Name,1,leveldb_filterpolicy_t.Name,const char* leveldb_filterpolicy_t.Name (),db\c.cc,"virtual const char* Name() const {
    return (*name_)(state_);
  }",104.0,106.0,3.0,3.0,3.0,1,1,2,2,0,1,1,1,0,0,,0,1,0,0,0,const char*
830,994,CreateFilter,1,leveldb_filterpolicy_t.CreateFilter,"void leveldb_filterpolicy_t.CreateFilter (Slice*,int,ANY*)",db\c.cc,"virtual void CreateFilter(const Slice* keys, int n, std::string* dst) const {
    std::vector<const char*> key_pointers(n);
    std::vector<size_t> key_sizes(n);
    for (int i = 0; i < n; i++) {
      key_pointers[i] = keys[i].data();
      key_sizes[i] = keys[i].size();
    }
    size_t len;
    char* filter = (*create_)(state_, &key_pointers[0], &key_sizes[0], n, &len);
    dst->append(filter, len);
    free(filter);
  }",108.0,119.0,3.0,3.0,12.0,21,8,26,12,0,1,2,2,0,0,,0,1,6,3,3,void
831,1071,KeyMayMatch,1,leveldb_filterpolicy_t.KeyMayMatch,"bool leveldb_filterpolicy_t.KeyMayMatch (Slice,Slice)",db\c.cc,"virtual bool KeyMayMatch(const Slice& key, const Slice& filter) const {
    return (*key_match_)(state_, key.data(), key.size(),
                         filter.data(), filter.size());
  }",121.0,124.0,3.0,3.0,4.0,5,2,6,4,0,1,1,1,0,0,,0,1,4,2,2,bool
832,1101,SaveError,1,SaveError,"bool SaveError (char**,Status)",db\c.cc,"static bool SaveError(char** errptr, const Status& s) {
  assert(errptr != NULL);
  if (s.ok()) {
    return false;
  } else if (*errptr == NULL) {
    *errptr = strdup(s.ToString().c_str());
  } else {
    // TODO(sanjay): Merge with existing error?
    free(*errptr);
    *errptr = strdup(s.ToString().c_str());
  }
  return true;
}",132.0,144.0,1.0,1.0,13.0,2,2,3,3,7,0,2,2,0,0,,0,0,4,2,2,bool
833,1156,CopyString,1,CopyString,char* CopyString (ANY),db\c.cc,"static char* CopyString(const std::string& str) {
  char* result = reinterpret_cast<char*>(malloc(sizeof(char) * str.size()));
  memcpy(result, str.data(), sizeof(char) * str.size());
  return result;
}",146.0,150.0,1.0,1.0,5.0,9,5,8,3,1,0,1,1,0,0,,0,0,2,1,1,char*
834,1189,leveldb_open,1,leveldb_open,"leveldb_t leveldb_open (leveldb_options_t*,char*,char**)",db\c.cc,"leveldb_t* leveldb_open(
    const leveldb_options_t* options,
    const char* name,
    char** errptr) {
  DB* db;
  if (SaveError(errptr, DB::Open(options->rep, std::string(name), &db))) {
    return NULL;
  }
  leveldb_t* result = new leveldb_t;
  result->rep = db;
  return result;
}",152.0,163.0,1.0,1.0,12.0,8,5,12,9,0,3,2,2,2,1,,0,3,6,3,3,leveldb_t
835,1229,leveldb_close,1,leveldb_close,void leveldb_close (leveldb_t*),db\c.cc,"void leveldb_close(leveldb_t* db) {
  delete db->rep;
  delete db;
}",165.0,168.0,1.0,1.0,4.0,3,2,2,1,0,1,1,1,0,0,,0,1,2,1,1,void
836,1240,leveldb_put,1,leveldb_put,"void leveldb_put (leveldb_t*,leveldb_writeoptions_t*,char*,size_t,char*,size_t,char**)",db\c.cc,"void leveldb_put(
    leveldb_t* db,
    const leveldb_writeoptions_t* options,
    const char* key, size_t keylen,
    const char* val, size_t vallen,
    char** errptr) {
  SaveError(errptr,
            db->rep->Put(options->rep, Slice(key, keylen), Slice(val, vallen)));
}",170.0,178.0,1.0,1.0,9.0,3,1,7,7,0,3,1,1,0,1,,0,2,14,7,7,void
837,1268,leveldb_delete,1,leveldb_delete,"void leveldb_delete (leveldb_t*,leveldb_writeoptions_t*,char*,size_t,char**)",db\c.cc,"void leveldb_delete(
    leveldb_t* db,
    const leveldb_writeoptions_t* options,
    const char* key, size_t keylen,
    char** errptr) {
  SaveError(errptr, db->rep->Delete(options->rep, Slice(key, keylen)));
}",180.0,186.0,1.0,1.0,7.0,3,1,5,5,0,3,1,1,0,1,,0,2,10,5,5,void
838,1291,leveldb_write,1,leveldb_write,"void leveldb_write (leveldb_t*,leveldb_writeoptions_t*,leveldb_writebatch_t*,char**)",db\c.cc,"void leveldb_write(
    leveldb_t* db,
    const leveldb_writeoptions_t* options,
    leveldb_writebatch_t* batch,
    char** errptr) {
  SaveError(errptr, db->rep->Write(options->rep, &batch->rep));
}",189.0,195.0,1.0,1.0,7.0,5,2,4,4,0,4,1,1,0,1,,0,3,8,4,4,void
839,1314,leveldb_get,1,leveldb_get,"char* leveldb_get (leveldb_t*,leveldb_readoptions_t*,char*,size_t,size_t*,char**)",db\c.cc,"char* leveldb_get(
    leveldb_t* db,
    const leveldb_readoptions_t* options,
    const char* key, size_t keylen,
    size_t* vallen,
    char** errptr) {
  char* result = NULL;
  std::string tmp;
  Status s = db->rep->Get(options->rep, Slice(key, keylen), &tmp);
  if (s.ok()) {
    *vallen = tmp.size();
    result = CopyString(tmp);
  } else {
    *vallen = 0;
    if (!s.IsNotFound()) {
      SaveError(errptr, s);
    }
  }
  return result;
}",197.0,216.0,1.0,1.0,20.0,11,5,14,9,1,3,2,2,0,1,,0,3,12,6,6,char*
840,1381,leveldb_create_iterator,1,leveldb_create_iterator,"leveldb_iterator_t leveldb_create_iterator (leveldb_t*,leveldb_readoptions_t*)",db\c.cc,"leveldb_iterator_t* leveldb_create_iterator(
    leveldb_t* db,
    const leveldb_readoptions_t* options) {
  leveldb_iterator_t* result = new leveldb_iterator_t;
  result->rep = db->rep->NewIterator(options->rep);
  return result;
}",218.0,224.0,1.0,1.0,7.0,7,3,6,4,0,3,1,1,0,0,,0,3,4,2,2,leveldb_iterator_t
841,1407,leveldb_create_snapshot,1,leveldb_create_snapshot,leveldb_snapshot_t leveldb_create_snapshot (leveldb_t*),db\c.cc,"const leveldb_snapshot_t* leveldb_create_snapshot(
    leveldb_t* db) {
  leveldb_snapshot_t* result = new leveldb_snapshot_t;
  result->rep = db->rep->GetSnapshot();
  return result;
}",226.0,231.0,1.0,1.0,6.0,6,3,5,3,0,2,1,1,0,0,,0,2,2,1,1,leveldb_snapshot_t
842,1429,leveldb_release_snapshot,1,leveldb_release_snapshot,"void leveldb_release_snapshot (leveldb_t*,leveldb_snapshot_t*)",db\c.cc,"void leveldb_release_snapshot(
    leveldb_t* db,
    const leveldb_snapshot_t* snapshot) {
  db->rep->ReleaseSnapshot(snapshot->rep);
  delete snapshot;
}",233.0,238.0,1.0,1.0,6.0,4,2,3,2,0,2,1,1,0,0,,0,2,4,2,2,void
843,1446,leveldb_property_value,1,leveldb_property_value,"char* leveldb_property_value (leveldb_t*,char*)",db\c.cc,"char* leveldb_property_value(
    leveldb_t* db,
    const char* propname) {
  std::string tmp;
  if (db->rep->GetProperty(Slice(propname), &tmp)) {
    // We use strdup() since we expect human readable output.
    return strdup(tmp.c_str());
  } else {
    return NULL;
  }
}",240.0,250.0,1.0,1.0,11.0,4,3,4,3,0,1,2,2,1,0,,0,1,4,2,2,char*
844,1475,leveldb_approximate_sizes,1,leveldb_approximate_sizes,"void leveldb_approximate_sizes (leveldb_t*,int,char**,size_t*,char**,size_t*,uint64_t*)",db\c.cc,"void leveldb_approximate_sizes(
    leveldb_t* db,
    int num_ranges,
    const char* const* range_start_key, const size_t* range_start_key_len,
    const char* const* range_limit_key, const size_t* range_limit_key_len,
    uint64_t* sizes) {
  Range* ranges = new Range[num_ranges];
  for (int i = 0; i < num_ranges; i++) {
    ranges[i].start = Slice(range_start_key[i], range_start_key_len[i]);
    ranges[i].limit = Slice(range_limit_key[i], range_limit_key_len[i]);
  }
  db->rep->GetApproximateSizes(ranges, num_ranges, sizes);
  delete[] ranges;
}",252.0,265.0,1.0,1.0,14.0,17,7,22,10,0,1,2,2,0,0,,0,1,14,7,7,void
845,1540,leveldb_compact_range,1,leveldb_compact_range,"void leveldb_compact_range (leveldb_t*,char*,size_t,char*,size_t)",db\c.cc,"void leveldb_compact_range(
    leveldb_t* db,
    const char* start_key, size_t start_key_len,
    const char* limit_key, size_t limit_key_len) {
  Slice a, b;
  db->rep->CompactRange(
      // Pass NULL Slice if corresponding ""const char*"" is NULL
      (start_key ? (a = Slice(start_key, start_key_len), &a) : NULL),
      (limit_key ? (b = Slice(limit_key, limit_key_len), &b) : NULL));
}",267.0,276.0,1.0,1.0,10.0,12,6,13,8,0,1,1,1,0,0,,0,1,10,5,5,void
846,1581,leveldb_destroy_db,1,leveldb_destroy_db,"void leveldb_destroy_db (leveldb_options_t*,char*,char**)",db\c.cc,"void leveldb_destroy_db(
    const leveldb_options_t* options,
    const char* name,
    char** errptr) {
  SaveError(errptr, DestroyDB(name, options->rep));
}",278.0,283.0,1.0,1.0,6.0,1,1,3,3,0,2,1,1,0,1,,0,1,6,3,3,void
847,1595,leveldb_repair_db,1,leveldb_repair_db,"void leveldb_repair_db (leveldb_options_t*,char*,char**)",db\c.cc,"void leveldb_repair_db(
    const leveldb_options_t* options,
    const char* name,
    char** errptr) {
  SaveError(errptr, RepairDB(name, options->rep));
}",285.0,290.0,1.0,1.0,6.0,1,1,3,3,0,2,1,1,0,1,,0,1,6,3,3,void
848,1609,leveldb_iter_destroy,1,leveldb_iter_destroy,void leveldb_iter_destroy (leveldb_iterator_t*),db\c.cc,"void leveldb_iter_destroy(leveldb_iterator_t* iter) {
  delete iter->rep;
  delete iter;
}",292.0,295.0,1.0,1.0,4.0,3,2,2,1,0,1,1,1,0,0,,0,1,2,1,1,void
849,1620,leveldb_iter_valid,1,leveldb_iter_valid,unsigned char leveldb_iter_valid (leveldb_iterator_t*),db\c.cc,"unsigned char leveldb_iter_valid(const leveldb_iterator_t* iter) {
  return iter->rep->Valid();
}",297.0,299.0,1.0,1.0,3.0,2,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,unsigned char
850,1632,leveldb_iter_seek_to_first,1,leveldb_iter_seek_to_first,void leveldb_iter_seek_to_first (leveldb_iterator_t*),db\c.cc,"void leveldb_iter_seek_to_first(leveldb_iterator_t* iter) {
  iter->rep->SeekToFirst();
}",301.0,303.0,1.0,1.0,3.0,2,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,void
851,1643,leveldb_iter_seek_to_last,1,leveldb_iter_seek_to_last,void leveldb_iter_seek_to_last (leveldb_iterator_t*),db\c.cc,"void leveldb_iter_seek_to_last(leveldb_iterator_t* iter) {
  iter->rep->SeekToLast();
}",305.0,307.0,1.0,1.0,3.0,2,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,void
852,1654,leveldb_iter_seek,1,leveldb_iter_seek,"void leveldb_iter_seek (leveldb_iterator_t*,char*,size_t)",db\c.cc,"void leveldb_iter_seek(leveldb_iterator_t* iter, const char* k, size_t klen) {
  iter->rep->Seek(Slice(k, klen));
}",309.0,311.0,1.0,1.0,3.0,2,1,3,3,0,1,1,1,0,0,,0,1,6,3,3,void
853,1670,leveldb_iter_next,1,leveldb_iter_next,void leveldb_iter_next (leveldb_iterator_t*),db\c.cc,"void leveldb_iter_next(leveldb_iterator_t* iter) {
  iter->rep->Next();
}",313.0,315.0,1.0,1.0,3.0,2,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,void
854,1681,leveldb_iter_prev,1,leveldb_iter_prev,void leveldb_iter_prev (leveldb_iterator_t*),db\c.cc,"void leveldb_iter_prev(leveldb_iterator_t* iter) {
  iter->rep->Prev();
}",317.0,319.0,1.0,1.0,3.0,2,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,void
855,1692,leveldb_iter_key,1,leveldb_iter_key,"const char* leveldb_iter_key (leveldb_iterator_t*,size_t*)",db\c.cc,"const char* leveldb_iter_key(const leveldb_iterator_t* iter, size_t* klen) {
  Slice s = iter->rep->key();
  *klen = s.size();
  return s.data();
}",321.0,325.0,1.0,1.0,5.0,7,4,5,3,1,1,1,1,0,0,,0,1,4,2,2,const char*
856,1719,leveldb_iter_value,1,leveldb_iter_value,"const char* leveldb_iter_value (leveldb_iterator_t*,size_t*)",db\c.cc,"const char* leveldb_iter_value(const leveldb_iterator_t* iter, size_t* vlen) {
  Slice s = iter->rep->value();
  *vlen = s.size();
  return s.data();
}",327.0,331.0,1.0,1.0,5.0,7,4,5,3,1,1,1,1,0,0,,0,1,4,2,2,const char*
857,1746,leveldb_iter_get_error,1,leveldb_iter_get_error,"void leveldb_iter_get_error (leveldb_iterator_t*,char**)",db\c.cc,"void leveldb_iter_get_error(const leveldb_iterator_t* iter, char** errptr) {
  SaveError(errptr, iter->rep->status());
}",333.0,335.0,1.0,1.0,3.0,2,1,2,2,0,2,1,1,0,1,,0,1,4,2,2,void
858,1760,leveldb_writebatch_create,1,leveldb_writebatch_create,leveldb_writebatch_t leveldb_writebatch_create (),db\c.cc,"leveldb_writebatch_t* leveldb_writebatch_create() {
  return new leveldb_writebatch_t;
}",337.0,339.0,1.0,1.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,leveldb_writebatch_t
859,1767,leveldb_writebatch_destroy,1,leveldb_writebatch_destroy,void leveldb_writebatch_destroy (leveldb_writebatch_t*),db\c.cc,"void leveldb_writebatch_destroy(leveldb_writebatch_t* b) {
  delete b;
}",341.0,343.0,1.0,1.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,void
860,1774,leveldb_writebatch_clear,1,leveldb_writebatch_clear,void leveldb_writebatch_clear (leveldb_writebatch_t*),db\c.cc,"void leveldb_writebatch_clear(leveldb_writebatch_t* b) {
  b->rep.Clear();
}",345.0,347.0,1.0,1.0,3.0,2,2,1,1,0,1,1,1,0,0,,0,1,2,1,1,void
861,1785,leveldb_writebatch_put,1,leveldb_writebatch_put,"void leveldb_writebatch_put (leveldb_writebatch_t*,char*,size_t,char*,size_t)",db\c.cc,"void leveldb_writebatch_put(
    leveldb_writebatch_t* b,
    const char* key, size_t klen,
    const char* val, size_t vlen) {
  b->rep.Put(Slice(key, klen), Slice(val, vlen));
}",349.0,354.0,1.0,1.0,6.0,2,2,5,5,0,1,1,1,0,0,,0,1,10,5,5,void
862,1806,leveldb_writebatch_delete,1,leveldb_writebatch_delete,"void leveldb_writebatch_delete (leveldb_writebatch_t*,char*,size_t)",db\c.cc,"void leveldb_writebatch_delete(
    leveldb_writebatch_t* b,
    const char* key, size_t klen) {
  b->rep.Delete(Slice(key, klen));
}",356.0,360.0,1.0,1.0,5.0,2,2,3,3,0,1,1,1,0,0,,0,1,6,3,3,void
863,1822,leveldb_writebatch_iterate,1,leveldb_writebatch_iterate,"void leveldb_writebatch_iterate (leveldb_writebatch_t*,void*,void,void)",db\c.cc,"void leveldb_writebatch_iterate(
    leveldb_writebatch_t* b,
    void* state,
    void (*put)(void*, const char* k, size_t klen, const char* v, size_t vlen),
    void (*deleted)(void*, const char* k, size_t klen)) {
  class H : public WriteBatch::Handler {
   public:
    void* state_;
    void (*put_)(void*, const char* k, size_t klen, const char* v, size_t vlen);
    void (*deleted_)(void*, const char* k, size_t klen);
    virtual void Put(const Slice& key, const Slice& value) {
      (*put_)(state_, key.data(), key.size(), value.data(), value.size());
    }
    virtual void Delete(const Slice& key) {
      (*deleted_)(state_, key.data(), key.size());
    }
  };
  H handler;
  handler.state_ = state;
  handler.put_ = put;
  handler.deleted_ = deleted;
  b->rep.Iterate(&handler);
}",362.0,384.0,1.0,1.0,23.0,9,4,8,5,0,1,1,1,0,0,,0,1,8,4,4,void
864,1854,leveldb_options_create,1,leveldb_options_create,leveldb_options_t leveldb_options_create (),db\c.cc,"leveldb_options_t* leveldb_options_create() {
  return new leveldb_options_t;
}",386.0,388.0,1.0,1.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,leveldb_options_t
865,1861,leveldb_options_destroy,1,leveldb_options_destroy,void leveldb_options_destroy (leveldb_options_t*),db\c.cc,"void leveldb_options_destroy(leveldb_options_t* options) {
  delete options;
}",390.0,392.0,1.0,1.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,void
866,1868,leveldb_options_set_comparator,1,leveldb_options_set_comparator,"void leveldb_options_set_comparator (leveldb_options_t*,leveldb_comparator_t*)",db\c.cc,"void leveldb_options_set_comparator(
    leveldb_options_t* opt,
    leveldb_comparator_t* cmp) {
  opt->rep.comparator = cmp;
}",394.0,398.0,1.0,1.0,5.0,3,3,2,2,0,1,1,1,0,0,,0,1,4,2,2,void
867,1881,leveldb_options_set_filter_policy,1,leveldb_options_set_filter_policy,"void leveldb_options_set_filter_policy (leveldb_options_t*,leveldb_filterpolicy_t*)",db\c.cc,"void leveldb_options_set_filter_policy(
    leveldb_options_t* opt,
    leveldb_filterpolicy_t* policy) {
  opt->rep.filter_policy = policy;
}",400.0,404.0,1.0,1.0,5.0,3,3,2,2,0,1,1,1,0,0,,0,1,4,2,2,void
868,1894,leveldb_options_set_create_if_missing,1,leveldb_options_set_create_if_missing,"void leveldb_options_set_create_if_missing (leveldb_options_t*,unsigned char)",db\c.cc,"void leveldb_options_set_create_if_missing(
    leveldb_options_t* opt, unsigned char v) {
  opt->rep.create_if_missing = v;
}",406.0,409.0,1.0,1.0,4.0,3,3,2,2,0,1,1,1,0,0,,0,1,4,2,2,void
869,1907,leveldb_options_set_error_if_exists,1,leveldb_options_set_error_if_exists,"void leveldb_options_set_error_if_exists (leveldb_options_t*,unsigned char)",db\c.cc,"void leveldb_options_set_error_if_exists(
    leveldb_options_t* opt, unsigned char v) {
  opt->rep.error_if_exists = v;
}",411.0,414.0,1.0,1.0,4.0,3,3,2,2,0,1,1,1,0,0,,0,1,4,2,2,void
870,1920,leveldb_options_set_paranoid_checks,1,leveldb_options_set_paranoid_checks,"void leveldb_options_set_paranoid_checks (leveldb_options_t*,unsigned char)",db\c.cc,"void leveldb_options_set_paranoid_checks(
    leveldb_options_t* opt, unsigned char v) {
  opt->rep.paranoid_checks = v;
}",416.0,419.0,1.0,1.0,4.0,3,3,2,2,0,1,1,1,0,0,,0,1,4,2,2,void
871,1933,leveldb_options_set_env,1,leveldb_options_set_env,"void leveldb_options_set_env (leveldb_options_t*,leveldb_env_t*)",db\c.cc,"void leveldb_options_set_env(leveldb_options_t* opt, leveldb_env_t* env) {
  opt->rep.env = (env ? env->rep : NULL);
}",421.0,423.0,1.0,1.0,3.0,5,4,4,3,0,2,1,1,0,0,,0,2,4,2,2,void
872,1951,leveldb_options_set_info_log,1,leveldb_options_set_info_log,"void leveldb_options_set_info_log (leveldb_options_t*,leveldb_logger_t*)",db\c.cc,"void leveldb_options_set_info_log(leveldb_options_t* opt, leveldb_logger_t* l) {
  opt->rep.info_log = (l ? l->rep : NULL);
}",425.0,427.0,1.0,1.0,3.0,5,4,4,3,0,2,1,1,0,0,,0,2,4,2,2,void
873,1969,leveldb_options_set_write_buffer_size,1,leveldb_options_set_write_buffer_size,"void leveldb_options_set_write_buffer_size (leveldb_options_t*,size_t)",db\c.cc,"void leveldb_options_set_write_buffer_size(leveldb_options_t* opt, size_t s) {
  opt->rep.write_buffer_size = s;
}",429.0,431.0,1.0,1.0,3.0,3,3,2,2,0,1,1,1,0,0,,0,1,4,2,2,void
874,1982,leveldb_options_set_max_open_files,1,leveldb_options_set_max_open_files,"void leveldb_options_set_max_open_files (leveldb_options_t*,int)",db\c.cc,"void leveldb_options_set_max_open_files(leveldb_options_t* opt, int n) {
  opt->rep.max_open_files = n;
}",433.0,435.0,1.0,1.0,3.0,3,3,2,2,0,1,1,1,0,0,,0,1,4,2,2,void
875,1995,leveldb_options_set_cache,1,leveldb_options_set_cache,"void leveldb_options_set_cache (leveldb_options_t*,leveldb_cache_t*)",db\c.cc,"void leveldb_options_set_cache(leveldb_options_t* opt, leveldb_cache_t* c) {
  opt->rep.block_cache = c->rep;
}",437.0,439.0,1.0,1.0,3.0,4,3,2,2,0,2,1,1,0,0,,0,2,4,2,2,void
876,2010,leveldb_options_set_block_size,1,leveldb_options_set_block_size,"void leveldb_options_set_block_size (leveldb_options_t*,size_t)",db\c.cc,"void leveldb_options_set_block_size(leveldb_options_t* opt, size_t s) {
  opt->rep.block_size = s;
}",441.0,443.0,1.0,1.0,3.0,3,3,2,2,0,1,1,1,0,0,,0,1,4,2,2,void
877,2023,leveldb_options_set_block_restart_interval,1,leveldb_options_set_block_restart_interval,"void leveldb_options_set_block_restart_interval (leveldb_options_t*,int)",db\c.cc,"void leveldb_options_set_block_restart_interval(leveldb_options_t* opt, int n) {
  opt->rep.block_restart_interval = n;
}",445.0,447.0,1.0,1.0,3.0,3,3,2,2,0,1,1,1,0,0,,0,1,4,2,2,void
878,2036,leveldb_options_set_compression,1,leveldb_options_set_compression,"void leveldb_options_set_compression (leveldb_options_t*,int)",db\c.cc,"void leveldb_options_set_compression(leveldb_options_t* opt, int t) {
  opt->rep.compression = static_cast<CompressionType>(t);
}",449.0,451.0,1.0,1.0,3.0,4,4,2,2,0,1,1,1,0,0,,0,1,4,2,2,void
879,2051,leveldb_comparator_create,1,leveldb_comparator_create,"leveldb_comparator_t leveldb_comparator_create (void*,void,int,char*)",db\c.cc,"leveldb_comparator_t* leveldb_comparator_create(
    void* state,
    void (*destructor)(void*),
    int (*compare)(
        void*,
        const char* a, size_t alen,
        const char* b, size_t blen),
    const char* (*name)(void*)) {
  leveldb_comparator_t* result = new leveldb_comparator_t;
  result->state_ = state;
  result->destructor_ = destructor;
  result->compare_ = compare;
  result->name_ = name;
  return result;
}",453.0,467.0,1.0,1.0,15.0,10,3,11,6,0,1,1,1,0,0,,0,1,8,4,4,leveldb_comparator_t
880,2086,leveldb_comparator_destroy,1,leveldb_comparator_destroy,void leveldb_comparator_destroy (leveldb_comparator_t*),db\c.cc,"void leveldb_comparator_destroy(leveldb_comparator_t* cmp) {
  delete cmp;
}",469.0,471.0,1.0,1.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,void
881,2093,leveldb_filterpolicy_create,1,leveldb_filterpolicy_create,"leveldb_filterpolicy_t leveldb_filterpolicy_create (void*,void,char*,unsigned char,char*)",db\c.cc,"leveldb_filterpolicy_t* leveldb_filterpolicy_create(
    void* state,
    void (*destructor)(void*),
    char* (*create_filter)(
        void*,
        const char* const* key_array, const size_t* key_length_array,
        int num_keys,
        size_t* filter_length),
    unsigned char (*key_may_match)(
        void*,
        const char* key, size_t length,
        const char* filter, size_t filter_length),
    const char* (*name)(void*)) {
  leveldb_filterpolicy_t* result = new leveldb_filterpolicy_t;
  result->state_ = state;
  result->destructor_ = destructor;
  result->create_ = create_filter;
  result->key_match_ = key_may_match;
  result->name_ = name;
  return result;
}",473.0,493.0,1.0,1.0,21.0,12,3,13,7,0,1,1,1,0,0,,0,1,10,5,5,leveldb_filterpolicy_t
882,2134,leveldb_filterpolicy_destroy,1,leveldb_filterpolicy_destroy,void leveldb_filterpolicy_destroy (leveldb_filterpolicy_t*),db\c.cc,"void leveldb_filterpolicy_destroy(leveldb_filterpolicy_t* filter) {
  delete filter;
}",495.0,497.0,1.0,1.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,void
883,2141,leveldb_filterpolicy_create_bloom,1,leveldb_filterpolicy_create_bloom,leveldb_filterpolicy_t leveldb_filterpolicy_create_bloom (int),db\c.cc,"leveldb_filterpolicy_t* leveldb_filterpolicy_create_bloom(int bits_per_key) {
  // Make a leveldb_filterpolicy_t, but override all of its methods so
  // they delegate to a NewBloomFilterPolicy() instead of user
  // supplied C functions.
  struct Wrapper : public leveldb_filterpolicy_t {
    const FilterPolicy* rep_;
    ~Wrapper() { delete rep_; }
    const char* Name() const { return rep_->Name(); }
    void CreateFilter(const Slice* keys, int n, std::string* dst) const {
      return rep_->CreateFilter(keys, n, dst);
    }
    bool KeyMayMatch(const Slice& key, const Slice& filter) const {
      return rep_->KeyMayMatch(key, filter);
    }
    static void DoNothing(void*) { }
  };
  Wrapper* wrapper = new Wrapper;
  wrapper->rep_ = NewBloomFilterPolicy(bits_per_key);
  wrapper->state_ = NULL;
  wrapper->destructor_ = &Wrapper::DoNothing;
  return wrapper;
}",499.0,520.0,1.0,1.0,22.0,10,5,9,4,0,0,1,1,0,0,,0,0,2,1,1,leveldb_filterpolicy_t
884,2172,leveldb_readoptions_create,1,leveldb_readoptions_create,leveldb_readoptions_t leveldb_readoptions_create (),db\c.cc,"leveldb_readoptions_t* leveldb_readoptions_create() {
  return new leveldb_readoptions_t;
}",522.0,524.0,1.0,1.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,leveldb_readoptions_t
885,2179,leveldb_readoptions_destroy,1,leveldb_readoptions_destroy,void leveldb_readoptions_destroy (leveldb_readoptions_t*),db\c.cc,"void leveldb_readoptions_destroy(leveldb_readoptions_t* opt) {
  delete opt;
}",526.0,528.0,1.0,1.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,void
886,2186,leveldb_readoptions_set_verify_checksums,1,leveldb_readoptions_set_verify_checksums,"void leveldb_readoptions_set_verify_checksums (leveldb_readoptions_t*,unsigned char)",db\c.cc,"void leveldb_readoptions_set_verify_checksums(
    leveldb_readoptions_t* opt,
    unsigned char v) {
  opt->rep.verify_checksums = v;
}",530.0,534.0,1.0,1.0,5.0,3,3,2,2,0,1,1,1,0,0,,0,1,4,2,2,void
887,2199,leveldb_readoptions_set_fill_cache,1,leveldb_readoptions_set_fill_cache,"void leveldb_readoptions_set_fill_cache (leveldb_readoptions_t*,unsigned char)",db\c.cc,"void leveldb_readoptions_set_fill_cache(
    leveldb_readoptions_t* opt, unsigned char v) {
  opt->rep.fill_cache = v;
}",536.0,539.0,1.0,1.0,4.0,3,3,2,2,0,1,1,1,0,0,,0,1,4,2,2,void
888,2212,leveldb_readoptions_set_snapshot,1,leveldb_readoptions_set_snapshot,"void leveldb_readoptions_set_snapshot (leveldb_readoptions_t*,leveldb_snapshot_t*)",db\c.cc,"void leveldb_readoptions_set_snapshot(
    leveldb_readoptions_t* opt,
    const leveldb_snapshot_t* snap) {
  opt->rep.snapshot = (snap ? snap->rep : NULL);
}",541.0,545.0,1.0,1.0,5.0,5,4,4,3,0,2,1,1,0,0,,0,2,4,2,2,void
889,2230,leveldb_writeoptions_create,1,leveldb_writeoptions_create,leveldb_writeoptions_t leveldb_writeoptions_create (),db\c.cc,"leveldb_writeoptions_t* leveldb_writeoptions_create() {
  return new leveldb_writeoptions_t;
}",547.0,549.0,1.0,1.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,leveldb_writeoptions_t
890,2237,leveldb_writeoptions_destroy,1,leveldb_writeoptions_destroy,void leveldb_writeoptions_destroy (leveldb_writeoptions_t*),db\c.cc,"void leveldb_writeoptions_destroy(leveldb_writeoptions_t* opt) {
  delete opt;
}",551.0,553.0,1.0,1.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,void
891,2244,leveldb_writeoptions_set_sync,1,leveldb_writeoptions_set_sync,"void leveldb_writeoptions_set_sync (leveldb_writeoptions_t*,unsigned char)",db\c.cc,"void leveldb_writeoptions_set_sync(
    leveldb_writeoptions_t* opt, unsigned char v) {
  opt->rep.sync = v;
}",555.0,558.0,1.0,1.0,4.0,3,3,2,2,0,1,1,1,0,0,,0,1,4,2,2,void
892,2257,leveldb_cache_create_lru,1,leveldb_cache_create_lru,leveldb_cache_t leveldb_cache_create_lru (size_t),db\c.cc,"leveldb_cache_t* leveldb_cache_create_lru(size_t capacity) {
  leveldb_cache_t* c = new leveldb_cache_t;
  c->rep = NewLRUCache(capacity);
  return c;
}",560.0,564.0,1.0,1.0,5.0,4,3,5,3,0,1,1,1,0,0,,0,1,2,1,1,leveldb_cache_t
893,2275,leveldb_cache_destroy,1,leveldb_cache_destroy,void leveldb_cache_destroy (leveldb_cache_t*),db\c.cc,"void leveldb_cache_destroy(leveldb_cache_t* cache) {
  delete cache->rep;
  delete cache;
}",566.0,569.0,1.0,1.0,4.0,3,2,2,1,0,1,1,1,0,0,,0,1,2,1,1,void
894,2286,leveldb_create_default_env,1,leveldb_create_default_env,leveldb_env_t leveldb_create_default_env (),db\c.cc,"leveldb_env_t* leveldb_create_default_env() {
  leveldb_env_t* result = new leveldb_env_t;
  result->rep = Env::Default();
  result->is_default = true;
  return result;
}",571.0,576.0,1.0,1.0,6.0,7,4,6,3,0,2,1,1,0,0,,0,2,0,0,0,leveldb_env_t
895,2310,leveldb_env_destroy,1,leveldb_env_destroy,void leveldb_env_destroy (leveldb_env_t*),db\c.cc,"void leveldb_env_destroy(leveldb_env_t* env) {
  if (!env->is_default) delete env->rep;
  delete env;
}",578.0,581.0,1.0,1.0,4.0,5,3,3,1,0,2,2,2,1,0,,0,2,2,1,1,void
896,2327,leveldb_free,1,leveldb_free,void leveldb_free (void*),db\c.cc,"void leveldb_free(void* ptr) {
  free(ptr);
}",583.0,585.0,1.0,1.0,3.0,0,0,1,1,0,0,1,1,0,0,,0,0,2,1,1,void
897,2334,leveldb_major_version,1,leveldb_major_version,int leveldb_major_version (),db\c.cc,"int leveldb_major_version() {
  return kMajorVersion;
}",587.0,589.0,1.0,1.0,3.0,0,0,1,1,0,0,1,1,0,0,,0,0,0,0,0,int
898,2340,leveldb_minor_version,1,leveldb_minor_version,int leveldb_minor_version (),db\c.cc,"int leveldb_minor_version() {
  return kMinorVersion;
}",591.0,593.0,1.0,1.0,3.0,0,0,1,1,0,0,1,1,0,0,,0,0,0,0,0,int
899,2372,StartPhase,1,StartPhase,void StartPhase (char*),db\c_test.c,"static void StartPhase(const char* name) {
  fprintf(stderr, ""=== Test %s\n"", name);
  phase = name;
}",17.0,20.0,1.0,1.0,4.0,1,1,4,3,0,1,1,1,0,0,,0,1,2,1,1,void
900,2384,GetTempDir,1,GetTempDir,const char* GetTempDir (void),db\c_test.c,"static const char* GetTempDir(void) {
    const char* ret = getenv(""TEST_TMPDIR"");
    if (ret == NULL || ret[0] == '\0')
        ret = ""/tmp"";
    return ret;
}",22.0,27.0,1.0,1.0,6.0,6,4,6,2,0,0,2,2,0,0,,0,0,2,1,1,const char*
901,2410,CheckEqual,1,CheckEqual,"void CheckEqual (char*,char*,size_t)",db\c_test.c,"static void CheckEqual(const char* expected, const char* v, size_t n) {
  if (expected == NULL && v == NULL) {
    // ok
  } else if (expected != NULL && v != NULL && n == strlen(expected) &&
             memcmp(expected, v, n) == 0) {
    // ok
    return;
  } else {
    fprintf(stderr, ""%s: expected '%s', got '%s'\n"",
            phase,
            (expected ? expected : ""(null)""),
            (v ? v : ""(null""));
    abort();
  }
}",41.0,55.0,1.0,1.0,15.0,3,2,4,3,8,0,2,2,0,0,,0,0,6,3,3,void
902,2465,Free,1,Free,void Free (char**),db\c_test.c,"static void Free(char** ptr) {
  if (*ptr) {
    free(*ptr);
    *ptr = NULL;
  }
}",57.0,62.0,1.0,1.0,6.0,4,2,4,2,1,0,2,2,0,0,,0,0,2,1,1,void
903,2481,CheckGet,1,CheckGet,"void CheckGet (leveldb_t*,leveldb_readoptions_t*,char*,char*)",db\c_test.c,"static void CheckGet(
    leveldb_t* db,
    const leveldb_readoptions_t* options,
    const char* key,
    const char* expected) {
  char* err = NULL;
  size_t val_len;
  char* val;
  val = leveldb_get(db, options, key, strlen(key), &val_len, &err);
  CheckNoError(err);
  CheckEqual(expected, val, val_len);
  Free(&val);
}",64.0,76.0,1.0,2.0,13.0,6,3,19,10,0,4,1,1,0,3,,0,2,8,4,4,void
904,2530,CheckIter,1,CheckIter,"void CheckIter (leveldb_iterator_t*,char*,char*)",db\c_test.c,"static void CheckIter(leveldb_iterator_t* iter,
                      const char* key, const char* val) {
  size_t len;
  const char* str;
  str = leveldb_iter_key(iter, &len);
  CheckEqual(key, str, len);
  str = leveldb_iter_value(iter, &len);
  CheckEqual(val, str, len);
}",78.0,86.0,1.0,1.0,9.0,4,2,12,5,0,4,1,1,0,4,,0,2,6,3,3,void
905,2559,CheckPut,1,CheckPut,"void CheckPut (void*,char*,size_t,char*,size_t)",db\c_test.c,"static void CheckPut(void* ptr,
                     const char* k, size_t klen,
                     const char* v, size_t vlen) {
  int* state = (int*) ptr;
  CheckCondition(*state < 2);
  switch (*state) {
    case 0:
      CheckEqual(""bar"", k, klen);
      CheckEqual(""b"", v, vlen);
      break;
    case 1:
      CheckEqual(""box"", k, klen);
      CheckEqual(""c"", v, vlen);
      break;
  }
  (*state)++;
}",89.0,105.0,1.0,2.0,17.0,8,6,15,8,0,5,4,2,0,4,,0,1,10,5,5,void
906,2620,CheckDel,1,CheckDel,"void CheckDel (void*,char*,size_t)",db\c_test.c,"static void CheckDel(void* ptr, const char* k, size_t klen) {
  int* state = (int*) ptr;
  CheckCondition(*state == 2);
  CheckEqual(""bar"", k, klen);
  (*state)++;
}",108.0,113.0,1.0,2.0,6.0,7,6,8,6,0,2,1,1,0,1,,0,1,6,3,3,void
907,2657,CmpDestroy,1,CmpDestroy,void CmpDestroy (void*),db\c_test.c,static void CmpDestroy(void* arg) { },115.0,115.0,1.0,37.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
908,2662,CmpCompare,1,CmpCompare,"int CmpCompare (void*,char*,size_t,char*,size_t)",db\c_test.c,"static int CmpCompare(void* arg, const char* a, size_t alen,
                      const char* b, size_t blen) {
  int n = (alen < blen) ? alen : blen;
  int r = memcmp(a, b, n);
  if (r == 0) {
    if (alen < blen) r = -1;
    else if (alen > blen) r = +1;
  }
  return r;
}",117.0,126.0,1.0,1.0,10.0,8,5,14,6,0,0,3,4,0,0,,0,0,10,5,5,int
909,2714,CmpName,1,CmpName,const char* CmpName (void*),db\c_test.c,"static const char* CmpName(void* arg) {
  return ""foo"";
}",128.0,130.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,const char*
910,2725,FilterDestroy,1,FilterDestroy,void FilterDestroy (void*),db\c_test.c,static void FilterDestroy(void* arg) { },134.0,134.0,1.0,40.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
911,2730,FilterName,1,FilterName,const char* FilterName (void*),db\c_test.c,"static const char* FilterName(void* arg) {
  return ""TestFilter"";
}",135.0,137.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,const char*
912,2737,FilterCreate,1,FilterCreate,"char* FilterCreate (void*,char**,size_t*,int,size_t*)",db\c_test.c,"static char* FilterCreate(
    void* arg,
    const char* const* key_array, const size_t* key_length_array,
    int num_keys,
    size_t* filter_length) {
  *filter_length = 4;
  char* result = malloc(4);
  memcpy(result, ""fake"", 4);
  return result;
}",138.0,147.0,1.0,1.0,10.0,3,2,4,2,0,0,1,1,0,0,,0,0,10,5,5,char*
913,2761,FilterKeyMatch,1,FilterKeyMatch,"unsigned char FilterKeyMatch (void*,char*,size_t,char*,size_t)",db\c_test.c,"unsigned char FilterKeyMatch(
    void* arg,
    const char* key, size_t length,
    const char* filter, size_t filter_length) {
  CheckCondition(filter_length == 4);
  CheckCondition(memcmp(filter, ""fake"", 4) == 0);
  return fake_filter_result;
}",148.0,155.0,1.0,2.0,8.0,4,2,7,5,0,3,1,1,0,0,,0,3,10,5,5,unsigned char
914,3875,CorruptionTest,1,leveldb.CorruptionTest.CorruptionTest,ANY leveldb.CorruptionTest.CorruptionTest (),db\corruption_test.cc,"CorruptionTest() {
    tiny_cache_ = NewLRUCache(100);
    options_.env = &env_;
    options_.block_cache = tiny_cache_;
    dbname_ = test::TmpDir() + ""/corruption_test"";
    DestroyDB(dbname_, options_);

    db_ = NULL;
    options_.create_if_missing = true;
    Reopen();
    options_.create_if_missing = false;
  }",35.0,46.0,3.0,3.0,12.0,14,4,13,7,0,11,1,1,0,0,,0,11,0,0,0,ANY
915,3919,~CorruptionTest,1,leveldb.CorruptionTest.~CorruptionTest,ANY leveldb.CorruptionTest.~CorruptionTest (),db\corruption_test.cc,"~CorruptionTest() {
     delete db_;
     DestroyDB(dbname_, Options());
     delete tiny_cache_;
  }",48.0,52.0,3.0,3.0,5.0,2,1,3,3,0,3,1,1,0,0,,0,3,0,0,0,ANY
916,3930,TryReopen,1,leveldb.CorruptionTest.TryReopen,Status leveldb.CorruptionTest.TryReopen (),db\corruption_test.cc,"Status TryReopen() {
    delete db_;
    db_ = NULL;
    return DB::Open(options_, dbname_, &db_);
  }",54.0,58.0,3.0,3.0,5.0,4,4,7,5,0,5,1,1,0,0,,0,5,0,0,0,Status
917,3948,Reopen,1,leveldb.CorruptionTest.Reopen,void leveldb.CorruptionTest.Reopen (),db\corruption_test.cc,"void Reopen() {
    ASSERT_OK(TryReopen());
  }",60.0,62.0,3.0,4.0,3.0,3,1,2,1,0,0,1,1,0,0,,0,0,0,0,0,void
918,3967,RepairDB,1,leveldb.CorruptionTest.RepairDB,void leveldb.CorruptionTest.RepairDB (),db\corruption_test.cc,"void RepairDB() {
    delete db_;
    db_ = NULL;
    ASSERT_OK(::leveldb::RepairDB(dbname_, options_));
  }",64.0,68.0,3.0,4.0,5.0,6,3,8,5,0,4,1,1,0,0,,0,4,0,0,0,void
919,3995,Build,1,leveldb.CorruptionTest.Build,void leveldb.CorruptionTest.Build (int),db\corruption_test.cc,"void Build(int n) {
    std::string key_space, value_space;
    WriteBatch batch;
    for (int i = 0; i < n; i++) {
      //if ((i % 100) == 0) fprintf(stderr, ""@ %d of %d\n"", i, n);
      Slice key = Key(i, &key_space);
      batch.Clear();
      batch.Put(key, Value(i, &value_space));
      WriteOptions options;
      // Corrupt() doesn't work without this sync on windows; stat reports 0 for
      // the file size.
      if (i == n - 1) {
        options.sync = true;
      }
      ASSERT_OK(db_->Write(options, &batch));
    }
  }",70.0,86.0,3.0,6.0,17.0,16,7,19,9,0,2,3,4,0,0,,0,2,2,1,1,void
920,4068,Check,1,leveldb.CorruptionTest.Check,"void leveldb.CorruptionTest.Check (int,int)",db\corruption_test.cc,"void Check(int min_expected, int max_expected) {
    int next_expected = 0;
    int missed = 0;
    int bad_keys = 0;
    int bad_values = 0;
    int correct = 0;
    std::string value_space;
    Iterator* iter = db_->NewIterator(ReadOptions());
    for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {
      uint64_t key;
      Slice in(iter->key());
      if (in == """" || in == ""~"") {
        // Ignore boundary keys.
        continue;
      }
      if (!ConsumeDecimalNumber(&in, &key) ||
          !in.empty() ||
          key < next_expected) {
        bad_keys++;
        continue;
      }
      missed += (key - next_expected);
      next_expected = key + 1;
      if (iter->value() != Value(key, &value_space)) {
        bad_values++;
      } else {
        correct++;
      }
    }
    delete iter;

    fprintf(stderr,
            ""expected=%d..%d; got=%d; bad_keys=%d; bad_values=%d; missed=%d\n"",
            min_expected, max_expected, correct, bad_keys, bad_values, missed);
    ...",88.0,124.0,3.0,4.0,37.0,37,14,47,15,0,1,7,8,0,0,,0,1,4,2,2,void
921,4228,Corrupt,1,leveldb.CorruptionTest.Corrupt,"void leveldb.CorruptionTest.Corrupt (FileType,int,int)",db\corruption_test.cc,"void Corrupt(FileType filetype, int offset, int bytes_to_corrupt) {
    // Pick file to corrupt
    std::vector<std::string> filenames;
    ASSERT_OK(env_.GetChildren(dbname_, &filenames));
    uint64_t number;
    FileType type;
    std::string fname;
    int picked_number = -1;
    for (size_t i = 0; i < filenames.size(); i++) {
      if (ParseFileName(filenames[i], &number, &type) &&
          type == filetype &&
          int(number) > picked_number) {  // Pick latest file
        fname = dbname_ + ""/"" + filenames[i];
        picked_number = number;
      }
    }
    ASSERT_TRUE(!fname.empty()) << filetype;

    struct stat sbuf;
    if (stat(fname.c_str(), &sbuf) != 0) {
      const char* msg = strerror(errno);
      ASSERT_TRUE(false) << fname << "": "" << msg;
    }

    if (offset < 0) {
      // Relative to end of file; make it absolute
      if (-offset > sbuf.st_size) {
        offset = 0;
      } else {
        offset = sbuf.st_size + offset;
      }
    }
    if (offset >...",126.0,174.0,3.0,4.0,49.0,83,15,77,22,0,3,9,11,0,0,,0,3,6,3,3,void
922,4531,Property,1,leveldb.CorruptionTest.Property,int leveldb.CorruptionTest.Property (ANY),db\corruption_test.cc,"int Property(const std::string& name) {
    std::string property;
    int result;
    if (db_->GetProperty(name, &property) &&
        sscanf(property.c_str(), ""%d"", &result) == 1) {
      return result;
    } else {
      return -1;
    }
  }",176.0,185.0,3.0,3.0,10.0,6,5,6,4,0,1,2,2,1,0,,0,1,2,1,1,int
923,4565,Key,1,leveldb.CorruptionTest.Key,"Slice leveldb.CorruptionTest.Key (int,ANY*)",db\corruption_test.cc,"Slice Key(int i, std::string* storage) {
    char buf[100];
    snprintf(buf, sizeof(buf), ""%016d"", i);
    storage->assign(buf, strlen(buf));
    return Slice(*storage);
  }",188.0,193.0,3.0,3.0,6.0,3,3,7,3,0,0,1,1,0,0,,0,0,4,2,2,Slice
924,4589,Value,1,leveldb.CorruptionTest.Value,"Slice leveldb.CorruptionTest.Value (int,ANY*)",db\corruption_test.cc,"Slice Value(int k, std::string* storage) {
    Random r(k);
    return test::RandomString(&r, kValueSize, storage);
  }",196.0,199.0,3.0,3.0,4.0,2,2,5,5,0,0,1,1,0,0,,0,0,4,2,2,Slice
925,4608,_Run,1,leveldb._Test_Recovery._Run,void leveldb._Test_Recovery._Run (),db\corruption_test.cc,"TEST(CorruptionTest, Recovery) {
  Build(100);
  Check(100, 100);
  Corrupt(kLogFile, 19, 1);      // WriteBatch tag for first record
  Corrupt(kLogFile, log::kBlockSize + 1000, 1);  // Somewhere in second block
  Reopen();

  // The 64 records in the first two log blocks are completely lost.
  Check(36, 36);
}",202.0,211.0,1.0,30.0,10.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
926,4612,_RunIt,1,leveldb._Test_Recovery._RunIt,void leveldb._Test_Recovery._RunIt (),db\corruption_test.cc,"TEST(CorruptionTest, Recovery)",202.0,202.0,1.0,30.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
927,4662,_Run,1,leveldb._Test_RecoverWriteError._Run,void leveldb._Test_RecoverWriteError._Run (),db\corruption_test.cc,"TEST(CorruptionTest, RecoverWriteError) {
  env_.writable_file_error_ = true;
  Status s = TryReopen();
  ASSERT_TRUE(!s.ok());
}",213.0,217.0,1.0,39.0,5.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
928,4666,_RunIt,1,leveldb._Test_RecoverWriteError._RunIt,void leveldb._Test_RecoverWriteError._RunIt (),db\corruption_test.cc,"TEST(CorruptionTest, RecoverWriteError)",213.0,213.0,1.0,39.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
929,4728,_Run,1,leveldb._Test_NewFileErrorDuringWrite._Run,void leveldb._Test_NewFileErrorDuringWrite._Run (),db\corruption_test.cc,"TEST(CorruptionTest, NewFileErrorDuringWrite) {
  // Do enough writing to force minor compaction
  env_.writable_file_error_ = true;
  const int num = 3 + (Options().write_buffer_size / kValueSize);
  std::string value_storage;
  Status s;
  for (int i = 0; s.ok() && i < num; i++) {
    WriteBatch batch;
    batch.Put(""a"", Value(100, &value_storage));
    s = db_->Write(WriteOptions(), &batch);
  }
  ASSERT_TRUE(!s.ok());
  ASSERT_GE(env_.num_writable_file_errors_, 1);
  env_.writable_file_error_ = false;
  Reopen();
}",219.0,234.0,1.0,45.0,16.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
930,4732,_RunIt,1,leveldb._Test_NewFileErrorDuringWrite._RunIt,void leveldb._Test_NewFileErrorDuringWrite._RunIt (),db\corruption_test.cc,"TEST(CorruptionTest, NewFileErrorDuringWrite)",219.0,219.0,1.0,45.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
931,4865,_Run,1,leveldb._Test_TableFile._Run,void leveldb._Test_TableFile._Run (),db\corruption_test.cc,"TEST(CorruptionTest, TableFile) {
  Build(100);
  DBImpl* dbi = reinterpret_cast<DBImpl*>(db_);
  dbi->TEST_CompactMemTable();
  dbi->TEST_CompactRange(0, NULL, NULL);
  dbi->TEST_CompactRange(1, NULL, NULL);

  Corrupt(kTableFile, 100, 1);
  Check(90, 99);
}",236.0,245.0,1.0,31.0,10.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
932,4869,_RunIt,1,leveldb._Test_TableFile._RunIt,void leveldb._Test_TableFile._RunIt (),db\corruption_test.cc,"TEST(CorruptionTest, TableFile)",236.0,236.0,1.0,31.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
933,4931,_Run,1,leveldb._Test_TableFileRepair._Run,void leveldb._Test_TableFileRepair._Run (),db\corruption_test.cc,"TEST(CorruptionTest, TableFileRepair) {
  options_.block_size = 2 * kValueSize;  // Limit scope of corruption
  options_.paranoid_checks = true;
  Reopen();
  Build(100);
  DBImpl* dbi = reinterpret_cast<DBImpl*>(db_);
  dbi->TEST_CompactMemTable();
  dbi->TEST_CompactRange(0, NULL, NULL);
  dbi->TEST_CompactRange(1, NULL, NULL);

  Corrupt(kTableFile, 100, 1);
  RepairDB();
  Reopen();
  Check(95, 99);
}",247.0,261.0,1.0,37.0,15.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
934,4935,_RunIt,1,leveldb._Test_TableFileRepair._RunIt,void leveldb._Test_TableFileRepair._RunIt (),db\corruption_test.cc,"TEST(CorruptionTest, TableFileRepair)",247.0,247.0,1.0,37.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
935,5012,_Run,1,leveldb._Test_TableFileIndexData._Run,void leveldb._Test_TableFileIndexData._Run (),db\corruption_test.cc,"TEST(CorruptionTest, TableFileIndexData) {
  Build(10000);  // Enough to build multiple Tables
  DBImpl* dbi = reinterpret_cast<DBImpl*>(db_);
  dbi->TEST_CompactMemTable();

  Corrupt(kTableFile, -2000, 500);
  Reopen();
  Check(5000, 9999);
}",263.0,271.0,1.0,40.0,9.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
936,5016,_RunIt,1,leveldb._Test_TableFileIndexData._RunIt,void leveldb._Test_TableFileIndexData._RunIt (),db\corruption_test.cc,"TEST(CorruptionTest, TableFileIndexData)",263.0,263.0,1.0,40.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
937,5066,_Run,1,leveldb._Test_MissingDescriptor._Run,void leveldb._Test_MissingDescriptor._Run (),db\corruption_test.cc,"TEST(CorruptionTest, MissingDescriptor) {
  Build(1000);
  RepairDB();
  Reopen();
  Check(1000, 1000);
}",273.0,278.0,1.0,39.0,6.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
938,5070,_RunIt,1,leveldb._Test_MissingDescriptor._RunIt,void leveldb._Test_MissingDescriptor._RunIt (),db\corruption_test.cc,"TEST(CorruptionTest, MissingDescriptor)",273.0,273.0,1.0,39.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
939,5106,_Run,1,leveldb._Test_SequenceNumberRecovery._Run,void leveldb._Test_SequenceNumberRecovery._Run (),db\corruption_test.cc,"TEST(CorruptionTest, SequenceNumberRecovery) {
  ASSERT_OK(db_->Put(WriteOptions(), ""foo"", ""v1""));
  ASSERT_OK(db_->Put(WriteOptions(), ""foo"", ""v2""));
  ASSERT_OK(db_->Put(WriteOptions(), ""foo"", ""v3""));
  ASSERT_OK(db_->Put(WriteOptions(), ""foo"", ""v4""));
  ASSERT_OK(db_->Put(WriteOptions(), ""foo"", ""v5""));
  RepairDB();
  Reopen();
  std::string v;
  ASSERT_OK(db_->Get(ReadOptions(), ""foo"", &v));
  ASSERT_EQ(""v5"", v);
  // Write something.  If sequence number was not recovered properly,
  // it will be hidden by an earlier write.
  ASSERT_OK(db_->Put(WriteOptions(), ""foo"", ""v6""));
  ASSERT_OK(db_->Get(ReadOptions(), ""foo"", &v));
  ASSERT_EQ(""v6"", v);
  Reopen();
  ASSERT_OK(db_->Get(ReadOptions(), ""foo"", &v));
  ASSERT_EQ(""v6"", v);
}",280.0,299.0,1.0,44.0,20.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
940,5110,_RunIt,1,leveldb._Test_SequenceNumberRecovery._RunIt,void leveldb._Test_SequenceNumberRecovery._RunIt (),db\corruption_test.cc,"TEST(CorruptionTest, SequenceNumberRecovery)",280.0,280.0,1.0,44.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
941,5377,_Run,1,leveldb._Test_CorruptedDescriptor._Run,void leveldb._Test_CorruptedDescriptor._Run (),db\corruption_test.cc,"TEST(CorruptionTest, CorruptedDescriptor) {
  ASSERT_OK(db_->Put(WriteOptions(), ""foo"", ""hello""));
  DBImpl* dbi = reinterpret_cast<DBImpl*>(db_);
  dbi->TEST_CompactMemTable();
  dbi->TEST_CompactRange(0, NULL, NULL);

  Corrupt(kDescriptorFile, 0, 1000);
  Status s = TryReopen();
  ASSERT_TRUE(!s.ok());

  RepairDB();
  Reopen();
  std::string v;
  ASSERT_OK(db_->Get(ReadOptions(), ""foo"", &v));
  ASSERT_EQ(""hello"", v);
}",301.0,316.0,1.0,41.0,16.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
942,5381,_RunIt,1,leveldb._Test_CorruptedDescriptor._RunIt,void leveldb._Test_CorruptedDescriptor._RunIt (),db\corruption_test.cc,"TEST(CorruptionTest, CorruptedDescriptor)",301.0,301.0,1.0,41.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
943,5520,_Run,1,leveldb._Test_CompactionInputError._Run,void leveldb._Test_CompactionInputError._Run (),db\corruption_test.cc,"TEST(CorruptionTest, CompactionInputError) {
  Build(10);
  DBImpl* dbi = reinterpret_cast<DBImpl*>(db_);
  dbi->TEST_CompactMemTable();
  const int last = config::kMaxMemCompactLevel;
  ASSERT_EQ(1, Property(""leveldb.num-files-at-level"" + NumberToString(last)));

  Corrupt(kTableFile, 100, 1);
  Check(5, 9);

  // Force compactions by writing lots of values
  Build(10000);
  Check(10000, 10000);
}",318.0,331.0,1.0,42.0,14.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
944,5524,_RunIt,1,leveldb._Test_CompactionInputError._RunIt,void leveldb._Test_CompactionInputError._RunIt (),db\corruption_test.cc,"TEST(CorruptionTest, CompactionInputError)",318.0,318.0,1.0,42.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
945,5603,_Run,1,leveldb._Test_CompactionInputErrorParanoid._Run,void leveldb._Test_CompactionInputErrorParanoid._Run (),db\corruption_test.cc,"TEST(CorruptionTest, CompactionInputErrorParanoid) {
  options_.paranoid_checks = true;
  options_.write_buffer_size = 512 << 10;
  Reopen();
  DBImpl* dbi = reinterpret_cast<DBImpl*>(db_);

  // Make multiple inputs so we need to compact.
  for (int i = 0; i < 2; i++) {
    Build(10);
    dbi->TEST_CompactMemTable();
    Corrupt(kTableFile, 100, 1);
    env_.SleepForMicroseconds(100000);
  }
  dbi->CompactRange(NULL, NULL);

  // Write must fail because of corrupted table
  std::string tmp1, tmp2;
  Status s = db_->Put(WriteOptions(), Key(5, &tmp1), Value(5, &tmp2));
  ASSERT_TRUE(!s.ok()) << ""write did not fail in corrupted paranoid db"";
}",333.0,352.0,1.0,50.0,20.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
946,5607,_RunIt,1,leveldb._Test_CompactionInputErrorParanoid._RunIt,void leveldb._Test_CompactionInputErrorParanoid._RunIt (),db\corruption_test.cc,"TEST(CorruptionTest, CompactionInputErrorParanoid)",333.0,333.0,1.0,50.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
947,5732,_Run,1,leveldb._Test_UnrelatedKeys._Run,void leveldb._Test_UnrelatedKeys._Run (),db\corruption_test.cc,"TEST(CorruptionTest, UnrelatedKeys) {
  Build(10);
  DBImpl* dbi = reinterpret_cast<DBImpl*>(db_);
  dbi->TEST_CompactMemTable();
  Corrupt(kTableFile, 100, 1);

  std::string tmp1, tmp2;
  ASSERT_OK(db_->Put(WriteOptions(), Key(1000, &tmp1), Value(1000, &tmp2)));
  std::string v;
  ASSERT_OK(db_->Get(ReadOptions(), Key(1000, &tmp1), &v));
  ASSERT_EQ(Value(1000, &tmp2).ToString(), v);
  dbi->TEST_CompactMemTable();
  ASSERT_OK(db_->Get(ReadOptions(), Key(1000, &tmp1), &v));
  ASSERT_EQ(Value(1000, &tmp2).ToString(), v);
}",354.0,368.0,1.0,35.0,15.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
948,5736,_RunIt,1,leveldb._Test_UnrelatedKeys._RunIt,void leveldb._Test_UnrelatedKeys._RunIt (),db\corruption_test.cc,"TEST(CorruptionTest, UnrelatedKeys)",354.0,354.0,1.0,35.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
949,6029,RandomGenerator,1,leveldb.anonymous_namespace_2.RandomGenerator.RandomGenerator,ANY leveldb.anonymous_namespace_2.RandomGenerator.RandomGenerator (),doc\bench\db_bench_tree_db.cc,"RandomGenerator() {
    // We use a limited amount of data over and over again and ensure
    // that it is larger than the compression window (32KB), and also
    // large enough to serve all typical value sizes we want to write.
    Random rnd(301);
    std::string piece;
    while (data_.size() < 1048576) {
      // Add a short fragment that is as compressible as specified
      // by FLAGS_compression_ratio.
      test::CompressibleString(&rnd, FLAGS_compression_ratio, 100, &piece);
      data_.append(piece);
    }
    pos_ = 0;
  }",93.0,106.0,3.0,3.0,14.0,7,4,8,6,0,4,2,2,1,0,,0,4,0,0,0,ANY
950,6063,Generate,1,leveldb.anonymous_namespace_3.RandomGenerator.Generate,Slice leveldb.anonymous_namespace_3.RandomGenerator.Generate (size_t),doc\bench\db_bench_tree_db.cc,"Slice Generate(int len) {
    if (pos_ + len > data_.size()) {
      pos_ = 0;
      assert(len < data_.size());
    }
    pos_ += len;
    return Slice(data_.data() + pos_ - len, len);
  }",108.0,115.0,3.0,3.0,8.0,10,7,12,3,0,7,2,2,2,0,,0,7,2,1,1,Slice
951,6102,AppendWithSpace,1,leveldb.anonymous_namespace_4.AppendWithSpace,"void leveldb.anonymous_namespace_4.AppendWithSpace (ANY*,Slice)",db\db_bench.cc,"static void AppendWithSpace(std::string* str, Slice msg) {
  if (msg.empty()) return;
  if (!str->empty()) {
    str->push_back(' ');
  }
  str->append(msg.data(), msg.size());
}",168.0,174.0,1.0,1.0,7.0,7,3,6,2,0,0,3,3,0,0,,0,0,4,2,2,void
952,6149,Stats,1,leveldb.anonymous_namespace_6.Stats.Stats,ANY leveldb.anonymous_namespace_6.Stats.Stats (),db\db_bench.cc,Stats() { Start(); },189.0,189.0,3.0,22.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
953,6154,Start,1,leveldb.anonymous_namespace_8.Stats.Start,void leveldb.anonymous_namespace_8.Stats.Start (),db\db_bench.cc,"void Start() {
    next_report_ = 100;
    last_op_finish_ = start_;
    hist_.Clear();
    done_ = 0;
    bytes_ = 0;
    seconds_ = 0;
    start_ = g_env->NowMicros();
    finish_ = start_;
    message_.clear();
  }",191.0,201.0,3.0,3.0,11.0,10,3,12,10,0,11,1,1,0,0,,0,11,0,0,0,void
954,6190,Merge,1,leveldb.anonymous_namespace_9.Stats.Merge,void leveldb.anonymous_namespace_9.Stats.Merge (Stats),db\db_bench.cc,"void Merge(const Stats& other) {
    hist_.Merge(other.hist_);
    done_ += other.done_;
    bytes_ += other.bytes_;
    seconds_ += other.seconds_;
    if (other.start_ < start_) start_ = other.start_;
    if (other.finish_ > finish_) finish_ = other.finish_;

    // Just keep the messages from one thread
    if (message_.empty()) message_ = other.message_;
  }",203.0,213.0,3.0,3.0,11.0,19,5,19,8,0,19,4,4,5,0,,0,19,2,1,1,void
955,6252,Stop,1,leveldb.anonymous_namespace_10.Stats.Stop,void leveldb.anonymous_namespace_10.Stats.Stop (),db\db_bench.cc,"void Stop() {
    finish_ = g_env->NowMicros();
    seconds_ = (finish_ - start_) * 1e-6;
  }",215.0,218.0,3.0,3.0,4.0,5,4,5,4,0,4,1,1,0,0,,0,4,0,0,0,void
956,6269,AddMessage,1,leveldb.anonymous_namespace_11.Stats.AddMessage,void leveldb.anonymous_namespace_11.Stats.AddMessage (Slice),db\db_bench.cc,"void AddMessage(Slice msg) {
    AppendWithSpace(&message_, msg);
  }",220.0,222.0,3.0,3.0,3.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
957,6278,FinishedSingleOp,1,leveldb.anonymous_namespace_13.Stats.FinishedSingleOp,void leveldb.anonymous_namespace_13.Stats.FinishedSingleOp (),db\db_bench.cc,"void FinishedSingleOp() {
    if (FLAGS_histogram) {
      double now = g_env->NowMicros();
      double micros = now - last_op_finish_;
      hist_.Add(micros);
      if (micros > 20000) {
        fprintf(stderr, ""long op: %.1f micros%30s\r"", micros, """");
        fflush(stderr);
      }
      last_op_finish_ = now;
    }

    done_++;
    if (done_ >= next_report_) {
      if      (next_report_ < 1000)   next_report_ += 100;
      else if (next_report_ < 5000)   next_report_ += 500;
      else if (next_report_ < 10000)  next_report_ += 1000;
      else if (next_report_ < 50000)  next_report_ += 5000;
      else if (next_report_ < 100000) next_report_ += 10000;
      else if (next_report_ < 500000) next_report_ += 50000;
      else                            next_report_ += 100000;
      fprintf(stderr, ""... finished %d ops%30s\r"", done_, """");
      fflush(stderr);
    }
  }",224.0,248.0,3.0,3.0,25.0,11,9,20,9,0,10,5,7,4,0,,0,10,0,0,0,void
958,6393,AddBytes,1,leveldb.anonymous_namespace_14.Stats.AddBytes,void leveldb.anonymous_namespace_14.Stats.AddBytes (int64_t),db\db_bench.cc,"void AddBytes(int64_t n) {
    bytes_ += n;
  }",250.0,252.0,3.0,3.0,3.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
959,6401,Report,1,leveldb.anonymous_namespace_15.Stats.Report,void leveldb.anonymous_namespace_15.Stats.Report (Slice),db\db_bench.cc,"void Report(const Slice& name) {
    // Pretend at least one op was done in case we are running a benchmark
    // that does not call FinishedSingleOp().
    if (done_ < 1) done_ = 1;

    std::string extra;
    if (bytes_ > 0) {
      // Rate is computed on actual elapsed time, not the sum of per-thread
      // elapsed times.
      double elapsed = (finish_ - start_) * 1e-6;
      char rate[100];
      snprintf(rate, sizeof(rate), ""%6.1f MB/s"",
               (bytes_ / 1048576.0) / elapsed);
      extra = rate;
    }
    AppendWithSpace(&extra, message_);

    fprintf(stdout, ""%-12s : %11.3f micros/op;%s%s\n"",
            name.ToString().c_str(),
            seconds_ * 1e6 / done_,
            (extra.empty() ? """" : "" ""),
            extra.c_str());
    if (FLAGS_histogram) {
      fprintf(stdout, ""Microseconds per op:\n%s\n"", hist_.ToString().c_str());
    }
    fflush(stdout);
  }",254.0,280.0,3.0,3.0,27.0,20,10,23,13,0,11,4,4,3,0,,0,11,2,1,1,void
960,6493,SharedState,1,leveldb.anonymous_namespace_18.SharedState.SharedState,ANY leveldb.anonymous_namespace_18.SharedState.SharedState (),db\db_bench.cc,SharedState() : cv(&mu) { },299.0,299.0,3.0,29.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
961,6502,ThreadState,1,leveldb.anonymous_namespace_20.ThreadState.ThreadState,ANY leveldb.anonymous_namespace_20.ThreadState.ThreadState (int),db\db_bench.cc,"ThreadState(int index)
      : tid(index),
        rand(1000 + index) {
  }",309.0,312.0,3.0,3.0,4.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
962,6517,PrintHeader,1,leveldb.Benchmark.PrintHeader,void leveldb.Benchmark.PrintHeader (),doc\bench\db_bench_tree_db.cc,"void PrintHeader() {
    const int kKeySize = 16;
    PrintEnvironment();
    fprintf(stdout, ""Keys:       %d bytes each\n"", kKeySize);
    fprintf(stdout, ""Values:     %d bytes each (%d bytes after compression)\n"",
            FLAGS_value_size,
            static_cast<int>(FLAGS_value_size * FLAGS_compression_ratio + 0.5));
    fprintf(stdout, ""Entries:    %d\n"", num_);
    fprintf(stdout, ""RawSize:    %.1f MB (estimated)\n"",
            ((static_cast<int64_t>(kKeySize + FLAGS_value_size) * num_)
             / 1048576.0));
    fprintf(stdout, ""FileSize:   %.1f MB (estimated)\n"",
            (((kKeySize + FLAGS_value_size * FLAGS_compression_ratio) * num_)
             / 1048576.0));
    PrintWarnings();
    fprintf(stdout, ""------------------------------------------------\n"");
  }",151.0,167.0,3.0,3.0,17.0,12,5,19,5,0,9,1,1,0,0,,0,9,0,0,0,void
963,6573,PrintWarnings,1,leveldb.Benchmark.PrintWarnings,void leveldb.Benchmark.PrintWarnings (),doc\bench\db_bench_tree_db.cc,"void PrintWarnings() {
#if defined(__GNUC__) && !defined(__OPTIMIZE__)
    fprintf(stdout,
            ""WARNING: Optimization is disabled: benchmarks unnecessarily slow\n""
            );
#endif
#ifndef NDEBUG
    fprintf(stdout,
            ""WARNING: Assertions are enabled; benchmarks unnecessarily slow\n"");
#endif
  }",169.0,179.0,3.0,3.0,11.0,5,5,7,4,0,0,2,2,0,0,,0,0,0,0,0,void
964,6614,PrintEnvironment,1,leveldb.Benchmark.PrintEnvironment,void leveldb.Benchmark.PrintEnvironment (),doc\bench\db_bench_tree_db.cc,"void PrintEnvironment() {
    fprintf(stderr, ""Kyoto Cabinet:    version %s, lib ver %d, lib rev %d\n"",
            kyotocabinet::VERSION, kyotocabinet::LIBVER, kyotocabinet::LIBREV);

#if defined(__linux)
    time_t now = time(NULL);
    fprintf(stderr, ""Date:           %s"", ctime(&now));  // ctime() adds newline

    FILE* cpuinfo = fopen(""/proc/cpuinfo"", ""r"");
    if (cpuinfo != NULL) {
      char line[1000];
      int num_cpus = 0;
      std::string cpu_type;
      std::string cache_size;
      while (fgets(line, sizeof(line), cpuinfo) != NULL) {
        const char* sep = strchr(line, ':');
        if (sep == NULL) {
          continue;
        }
        Slice key = TrimSpace(Slice(line, sep - 1 - line));
        Slice val = TrimSpace(Slice(sep + 1));
        if (key == ""model name"") {
          ++num_cpus;
          cpu_type = val.ToString();
        } else if (key == ""cache size"") {
          cache_size = val.ToString();
        }
      }
      fclose(cpuinfo);
      fprintf(s...",181.0,214.0,3.0,3.0,34.0,0,0,3,3,0,0,1,1,0,0,,0,0,0,0,0,void
965,6623,Benchmark,1,leveldb.Benchmark.Benchmark,ANY leveldb.Benchmark.Benchmark (),doc\bench\db_bench_tree_db.cc,"Benchmark()
  : db_(NULL),
    num_(FLAGS_num),
    reads_(FLAGS_reads < 0 ? FLAGS_num : FLAGS_reads),
    bytes_(0),
    rand_(301) {
    std::vector<std::string> files;
    std::string test_dir;
    Env::Default()->GetTestDirectory(&test_dir);
    Env::Default()->GetChildren(test_dir.c_str(), &files);
    if (!FLAGS_use_existing_db) {
      for (int i = 0; i < files.size(); i++) {
        if (Slice(files[i]).starts_with(""dbbench_polyDB"")) {
          std::string file_name(test_dir);
          file_name += ""/"";
          file_name += files[i];
          Env::Default()->DeleteFile(file_name.c_str());
        }
      }
    }
  }",291.0,311.0,3.0,3.0,21.0,17,9,18,6,0,4,4,5,1,0,,0,4,0,0,0,ANY
966,6690,~Benchmark,1,leveldb.Benchmark.~Benchmark,ANY leveldb.Benchmark.~Benchmark (),doc\bench\db_bench_tree_db.cc,"~Benchmark() {
    if (!db_->close()) {
      fprintf(stderr, ""close error: %s\n"", db_->error().name());
    }
  }",313.0,317.0,3.0,3.0,5.0,3,1,3,3,0,1,1,1,0,0,,0,1,0,0,0,ANY
967,6700,Run,1,leveldb.Benchmark.Run,void leveldb.Benchmark.Run (),doc\bench\db_bench_tree_db.cc,"void Run() {
    PrintHeader();
    Open(false);

    const char* benchmarks = FLAGS_benchmarks;
    while (benchmarks != NULL) {
      const char* sep = strchr(benchmarks, ',');
      Slice name;
      if (sep == NULL) {
        name = benchmarks;
        benchmarks = NULL;
      } else {
        name = Slice(benchmarks, sep - benchmarks);
        benchmarks = sep + 1;
      }

      Start();

      bool known = true;
      bool write_sync = false;
      if (name == Slice(""fillseq"")) {
        Write(write_sync, SEQUENTIAL, FRESH, num_, FLAGS_value_size, 1);
        DBSynchronize(db_);
      } else if (name == Slice(""fillrandom"")) {
        Write(write_sync, RANDOM, FRESH, num_, FLAGS_value_size, 1);
        DBSynchronize(db_);
      } else if (name == Slice(""overwrite"")) {
        Write(write_sync, RANDOM, EXISTING, num_, FLAGS_value_size, 1);
        DBSynchronize(db_);
      } else if (name == Slice(""fillrandsync"")) {
        write_sync = true;
        Write(write_sync, RANDOM, F...",319.0,386.0,3.0,3.0,68.0,26,8,42,20,0,13,8,16,2,0,,0,13,0,0,0,void
968,6765,method,1,leveldb.Benchmark.Run.method,void leveldb.Benchmark.Run.method (ThreadState*),db\db_bench.cc,void (Benchmark::*method)(ThreadState*) = NULL;,456.0,456.0,12.0,52.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
969,7228,method,1,leveldb.Benchmark.ThreadArg.method,void leveldb.Benchmark.ThreadArg.method (ThreadState*),db\db_bench.cc,void (Benchmark::*method)(ThreadState*);,555.0,555.0,10.0,43.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
970,7233,ThreadBody,1,leveldb.Benchmark.ThreadBody,void leveldb.Benchmark.ThreadBody (void*),db\db_bench.cc,"static void ThreadBody(void* v) {
    ThreadArg* arg = reinterpret_cast<ThreadArg*>(v);
    SharedState* shared = arg->shared;
    ThreadState* thread = arg->thread;
    {
      MutexLock l(&shared->mu);
      shared->num_initialized++;
      if (shared->num_initialized >= shared->total) {
        shared->cv.SignalAll();
      }
      while (!shared->start) {
        shared->cv.Wait();
      }
    }

    thread->stats.Start();
    (arg->bm->*(arg->method))(thread);
    thread->stats.Stop();

    {
      MutexLock l(&shared->mu);
      shared->num_done++;
      if (shared->num_done >= shared->total) {
        shared->cv.SignalAll();
      }
    }
  }",558.0,584.0,3.0,3.0,27.0,35,8,23,4,0,17,4,4,5,0,,0,17,2,1,1,void
971,7341,RunBenchmark,1,leveldb.Benchmark.RunBenchmark,"void leveldb.Benchmark.RunBenchmark (int,Slice,void)",db\db_bench.cc,"void RunBenchmark(int n, Slice name,
                    void (Benchmark::*method)(ThreadState*)) {
    SharedState shared;
    shared.total = n;
    shared.num_initialized = 0;
    shared.num_done = 0;
    shared.start = false;

    ThreadArg* arg = new ThreadArg[n];
    for (int i = 0; i < n; i++) {
      arg[i].bm = this;
      arg[i].method = method;
      arg[i].shared = &shared;
      arg[i].thread = new ThreadState(i);
      arg[i].thread->shared = &shared;
      g_env->StartThread(ThreadBody, &arg[i]);
    }

    shared.mu.Lock();
    while (shared.num_initialized < n) {
      shared.cv.Wait();
    }

    shared.start = true;
    shared.cv.SignalAll();
    while (shared.num_done < n) {
      shared.cv.Wait();
    }
    shared.mu.Unlock();

    for (int i = 1; i < n; i++) {
      arg[0].thread->stats.Merge(arg[i].thread->stats);
    }
    arg[0].thread->stats.Report(name);

    for (int i = 0; i < n; i++) {
      delete arg[i].thread;
    }
    delete[] arg;
  }",586.0,625.0,3.0,3.0,40.0,69,8,52,9,0,12,6,6,2,0,,0,12,6,3,3,void
972,7545,Crc32c,1,leveldb.Benchmark.Crc32c,void leveldb.Benchmark.Crc32c (ThreadState*),db\db_bench.cc,"void Crc32c(ThreadState* thread) {
    // Checksum about 500MB of data total
    const int size = 4096;
    const char* label = ""(4K per op)"";
    std::string data(size, 'x');
    int64_t bytes = 0;
    uint32_t crc = 0;
    while (bytes < 500 * 1048576) {
      crc = crc32c::Value(data.data(), size);
      thread->stats.FinishedSingleOp();
      bytes += size;
    }
    // Print so result is not dead
    fprintf(stderr, ""... crc=0x%x\r"", static_cast<unsigned int>(crc));

    thread->stats.AddBytes(bytes);
    thread->stats.AddMessage(label);
  }",627.0,644.0,3.0,3.0,18.0,17,7,19,8,0,3,2,2,0,0,,0,3,2,1,1,void
973,7617,AcquireLoad,1,leveldb.Benchmark.AcquireLoad,void leveldb.Benchmark.AcquireLoad (ThreadState*),db\db_bench.cc,"void AcquireLoad(ThreadState* thread) {
    int dummy;
    port::AtomicPointer ap(&dummy);
    int count = 0;
    void *ptr = NULL;
    thread->stats.AddMessage(""(each op is 1000 loads)"");
    while (count < 100000) {
      for (int i = 0; i < 1000; i++) {
        ptr = ap.Acquire_Load();
      }
      count++;
      thread->stats.FinishedSingleOp();
    }
    if (ptr == NULL) exit(1); // Disable unused variable warning.
  }",646.0,660.0,3.0,3.0,15.0,14,7,14,7,0,2,4,5,0,0,,0,2,2,1,1,void
974,7680,SnappyCompress,1,leveldb.Benchmark.SnappyCompress,void leveldb.Benchmark.SnappyCompress (ThreadState*),db\db_bench.cc,"void SnappyCompress(ThreadState* thread) {
    RandomGenerator gen;
    Slice input = gen.Generate(Options().block_size);
    int64_t bytes = 0;
    int64_t produced = 0;
    bool ok = true;
    std::string compressed;
    while (ok && bytes < 1024 * 1048576) {  // Compress 1G
      ok = port::Snappy_Compress(input.data(), input.size(), &compressed);
      produced += compressed.size();
      bytes += input.size();
      thread->stats.FinishedSingleOp();
    }

    if (!ok) {
      thread->stats.AddMessage(""(snappy failure)"");
    } else {
      char buf[100];
      snprintf(buf, sizeof(buf), ""(output: %.1f%%)"",
               (produced * 100.0) / bytes);
      thread->stats.AddMessage(buf);
      thread->stats.AddBytes(bytes);
    }
  }",662.0,685.0,3.0,3.0,24.0,23,9,19,8,0,2,3,3,0,0,,0,2,2,1,1,void
975,7790,SnappyUncompress,1,leveldb.Benchmark.SnappyUncompress,void leveldb.Benchmark.SnappyUncompress (ThreadState*),db\db_bench.cc,"void SnappyUncompress(ThreadState* thread) {
    RandomGenerator gen;
    Slice input = gen.Generate(Options().block_size);
    std::string compressed;
    bool ok = port::Snappy_Compress(input.data(), input.size(), &compressed);
    int64_t bytes = 0;
    char* uncompressed = new char[input.size()];
    while (ok && bytes < 1024 * 1048576) {  // Compress 1G
      ok =  port::Snappy_Uncompress(compressed.data(), compressed.size(),
                                    uncompressed);
      bytes += input.size();
      thread->stats.FinishedSingleOp();
    }
    delete[] uncompressed;

    if (!ok) {
      thread->stats.AddMessage(""(snappy failure)"");
    } else {
      thread->stats.AddBytes(bytes);
    }
  }",687.0,707.0,3.0,3.0,21.0,26,11,23,9,0,2,3,3,0,0,,0,2,2,1,1,void
976,7891,Open,1,leveldb.Benchmark.Open,void leveldb.Benchmark.Open (),doc\bench\db_bench_tree_db.cc,"void Open(bool sync) {
    assert(db_ == NULL);

    // Initialize db_
    db_ = new kyotocabinet::TreeDB();
    char file_name[100];
    db_num_++;
    std::string test_dir;
    Env::Default()->GetTestDirectory(&test_dir);
    snprintf(file_name, sizeof(file_name),
             ""%s/dbbench_polyDB-%d.kct"",
             test_dir.c_str(),
             db_num_);

    // Create tuning options and open the database
    int open_options = kyotocabinet::PolyDB::OWRITER |
                       kyotocabinet::PolyDB::OCREATE;
    int tune_options = kyotocabinet::TreeDB::TSMALL |
        kyotocabinet::TreeDB::TLINEAR;
    if (FLAGS_compression) {
      tune_options |= kyotocabinet::TreeDB::TCOMPRESS;
      db_->tune_compressor(&comp_);
    }
    db_->tune_options(tune_options);
    db_->tune_page_cache(FLAGS_cache_size);
    db_->tune_page(FLAGS_page_size);
    db_->tune_map(256LL<<20);
    if (sync) {
      open_options |= kyotocabinet::PolyDB::OAUTOSYNC;
    }
    if (!db_->open(file_name, ...",389.0,422.0,5.0,3.0,34.0,27,5,28,16,0,18,2,2,0,0,,0,18,2,1,1,void
977,7976,OpenBench,1,leveldb.Benchmark.OpenBench,void leveldb.Benchmark.OpenBench (ThreadState*),db\db_bench.cc,"void OpenBench(ThreadState* thread) {
    for (int i = 0; i < num_; i++) {
      delete db_;
      Open();
      thread->stats.FinishedSingleOp();
    }
  }",728.0,734.0,3.0,3.0,7.0,5,5,5,4,0,3,2,2,1,0,,0,3,2,1,1,void
978,8002,WriteSeq,1,leveldb.Benchmark.WriteSeq,void leveldb.Benchmark.WriteSeq (ThreadState*),db\db_bench.cc,"void WriteSeq(ThreadState* thread) {
    DoWrite(thread, true);
  }",736.0,738.0,3.0,3.0,3.0,0,0,1,1,0,0,1,1,0,0,,0,0,2,1,1,void
979,8010,WriteRandom,1,leveldb.Benchmark.WriteRandom,void leveldb.Benchmark.WriteRandom (ThreadState*),db\db_bench.cc,"void WriteRandom(ThreadState* thread) {
    DoWrite(thread, false);
  }",740.0,742.0,3.0,3.0,3.0,0,0,1,1,0,0,1,1,0,0,,0,0,2,1,1,void
980,8018,DoWrite,1,leveldb.Benchmark.DoWrite,"void leveldb.Benchmark.DoWrite (ThreadState*,bool)",db\db_bench.cc,"void DoWrite(ThreadState* thread, bool seq) {
    if (num_ != FLAGS_num) {
      char msg[100];
      snprintf(msg, sizeof(msg), ""(%d ops)"", num_);
      thread->stats.AddMessage(msg);
    }

    RandomGenerator gen;
    WriteBatch batch;
    Status s;
    int64_t bytes = 0;
    for (int i = 0; i < num_; i += entries_per_batch_) {
      batch.Clear();
      for (int j = 0; j < entries_per_batch_; j++) {
        const int k = seq ? i+j : (thread->rand.Next() % FLAGS_num);
        char key[100];
        snprintf(key, sizeof(key), ""%016d"", k);
        batch.Put(key, gen.Generate(value_size_));
        bytes += value_size_ + strlen(key);
        thread->stats.FinishedSingleOp();
      }
      s = db_->Write(write_options_, &batch);
      if (!s.ok()) {
        fprintf(stderr, ""put error: %s\n"", s.ToString().c_str());
        exit(1);
      }
    }
    thread->stats.AddBytes(bytes);
  }",744.0,772.0,3.0,3.0,29.0,32,12,41,18,0,14,5,7,4,0,,0,14,4,2,2,void
981,8159,ReadSequential,1,leveldb.Benchmark.ReadSequential,void leveldb.Benchmark.ReadSequential (ThreadState*),doc\bench\db_bench_tree_db.cc,"void ReadSequential() {
    kyotocabinet::DB::Cursor* cur = db_->cursor();
    cur->jump();
    std::string ckey, cvalue;
    while (cur->get(&ckey, &cvalue, true)) {
      bytes_ += ckey.size() + cvalue.size();
      FinishedSingleOp();
    }
    delete cur;
  }",459.0,468.0,3.0,3.0,10.0,20,9,16,6,0,4,2,2,1,0,,0,4,0,0,0,void
982,8233,ReadReverse,1,leveldb.Benchmark.ReadReverse,void leveldb.Benchmark.ReadReverse (ThreadState*),db\db_bench.cc,"void ReadReverse(ThreadState* thread) {
    Iterator* iter = db_->NewIterator(ReadOptions());
    int i = 0;
    int64_t bytes = 0;
    for (iter->SeekToLast(); i < reads_ && iter->Valid(); iter->Prev()) {
      bytes += iter->key().size() + iter->value().size();
      thread->stats.FinishedSingleOp();
      ++i;
    }
    delete iter;
    thread->stats.AddBytes(bytes);
  }",787.0,798.0,3.0,3.0,12.0,20,9,16,6,0,4,2,2,1,0,,0,4,2,1,1,void
983,8307,ReadRandom,1,leveldb.Benchmark.ReadRandom,void leveldb.Benchmark.ReadRandom (ThreadState*),doc\bench\db_bench_tree_db.cc,"void ReadRandom() {
    std::string value;
    for (int i = 0; i < reads_; i++) {
      char key[100];
      const int k = rand_.Next() % reads_;
      snprintf(key, sizeof(key), ""%016d"", k);
      db_->get(key, &value);
      FinishedSingleOp();
    }
  }",470.0,479.0,3.0,3.0,10.0,17,8,22,12,0,7,3,4,2,0,,0,7,0,0,0,void
984,8384,ReadMissing,1,leveldb.Benchmark.ReadMissing,void leveldb.Benchmark.ReadMissing (ThreadState*),db\db_bench.cc,"void ReadMissing(ThreadState* thread) {
    ReadOptions options;
    std::string value;
    for (int i = 0; i < reads_; i++) {
      char key[100];
      const int k = thread->rand.Next() % FLAGS_num;
      snprintf(key, sizeof(key), ""%016d."", k);
      db_->Get(options, key, &value);
      thread->stats.FinishedSingleOp();
    }
  }",818.0,828.0,3.0,3.0,11.0,11,7,14,9,0,5,2,2,1,0,,0,5,2,1,1,void
985,8435,ReadHot,1,leveldb.Benchmark.ReadHot,void leveldb.Benchmark.ReadHot (ThreadState*),db\db_bench.cc,"void ReadHot(ThreadState* thread) {
    ReadOptions options;
    std::string value;
    const int range = (FLAGS_num + 99) / 100;
    for (int i = 0; i < reads_; i++) {
      char key[100];
      const int k = thread->rand.Next() % range;
      snprintf(key, sizeof(key), ""%016d"", k);
      db_->Get(options, key, &value);
      thread->stats.FinishedSingleOp();
    }
  }",830.0,841.0,3.0,3.0,12.0,14,9,16,10,0,5,2,2,1,0,,0,5,2,1,1,void
986,8494,SeekRandom,1,leveldb.Benchmark.SeekRandom,void leveldb.Benchmark.SeekRandom (ThreadState*),db\db_bench.cc,"void SeekRandom(ThreadState* thread) {
    ReadOptions options;
    int found = 0;
    for (int i = 0; i < reads_; i++) {
      Iterator* iter = db_->NewIterator(options);
      char key[100];
      const int k = thread->rand.Next() % FLAGS_num;
      snprintf(key, sizeof(key), ""%016d"", k);
      iter->Seek(key);
      if (iter->Valid() && iter->key() == key) found++;
      delete iter;
      thread->stats.FinishedSingleOp();
    }
    char msg[100];
    snprintf(msg, sizeof(msg), ""(%d of %d found)"", found, num_);
    thread->stats.AddMessage(msg);
  }",843.0,859.0,3.0,3.0,17.0,22,10,27,12,0,7,3,4,1,0,,0,7,2,1,1,void
987,8585,DoDelete,1,leveldb.Benchmark.DoDelete,"void leveldb.Benchmark.DoDelete (ThreadState*,bool)",db\db_bench.cc,"void DoDelete(ThreadState* thread, bool seq) {
    RandomGenerator gen;
    WriteBatch batch;
    Status s;
    for (int i = 0; i < num_; i += entries_per_batch_) {
      batch.Clear();
      for (int j = 0; j < entries_per_batch_; j++) {
        const int k = seq ? i+j : (thread->rand.Next() % FLAGS_num);
        char key[100];
        snprintf(key, sizeof(key), ""%016d"", k);
        batch.Delete(key);
        thread->stats.FinishedSingleOp();
      }
      s = db_->Write(write_options_, &batch);
      if (!s.ok()) {
        fprintf(stderr, ""del error: %s\n"", s.ToString().c_str());
        exit(1);
      }
    }
  }",861.0,880.0,3.0,3.0,20.0,22,10,26,14,0,7,4,6,2,0,,0,7,4,2,2,void
988,8685,DeleteSeq,1,leveldb.Benchmark.DeleteSeq,void leveldb.Benchmark.DeleteSeq (ThreadState*),db\db_bench.cc,"void DeleteSeq(ThreadState* thread) {
    DoDelete(thread, true);
  }",882.0,884.0,3.0,3.0,3.0,0,0,1,1,0,0,1,1,0,0,,0,0,2,1,1,void
989,8693,DeleteRandom,1,leveldb.Benchmark.DeleteRandom,void leveldb.Benchmark.DeleteRandom (ThreadState*),db\db_bench.cc,"void DeleteRandom(ThreadState* thread) {
    DoDelete(thread, false);
  }",886.0,888.0,3.0,3.0,3.0,0,0,1,1,0,0,1,1,0,0,,0,0,2,1,1,void
990,8701,ReadWhileWriting,1,leveldb.Benchmark.ReadWhileWriting,void leveldb.Benchmark.ReadWhileWriting (ThreadState*),db\db_bench.cc,"void ReadWhileWriting(ThreadState* thread) {
    if (thread->tid > 0) {
      ReadRandom(thread);
    } else {
      // Special thread that keeps writing until other threads are done.
      RandomGenerator gen;
      while (true) {
        {
          MutexLock l(&thread->shared->mu);
          if (thread->shared->num_done + 1 >= thread->shared->num_initialized) {
            // Other threads have finished
            break;
          }
        }

        const int k = thread->rand.Next() % FLAGS_num;
        char key[100];
        snprintf(key, sizeof(key), ""%016d"", k);
        Status s = db_->Put(write_options_, key, gen.Generate(value_size_));
        if (!s.ok()) {
          fprintf(stderr, ""put error: %s\n"", s.ToString().c_str());
          exit(1);
        }
      }

      // Do not count any of the preceding work/delay in stats.
      thread->stats.Start();
    }
  }",890.0,918.0,3.0,3.0,29.0,2,2,2,1,0,1,2,2,1,0,,0,1,2,1,1,void
991,8803,Compact,1,leveldb.Benchmark.Compact,void leveldb.Benchmark.Compact (ThreadState*),db\db_bench.cc,"void Compact(ThreadState* thread) {
    db_->CompactRange(NULL, NULL);
  }",920.0,922.0,3.0,3.0,3.0,1,1,3,2,0,1,1,1,0,0,,0,1,2,1,1,void
992,8814,PrintStats,1,leveldb.Benchmark.PrintStats,void leveldb.Benchmark.PrintStats (char*),db\db_bench.cc,"void PrintStats(const char* key) {
    std::string stats;
    if (!db_->GetProperty(key, &stats)) {
      stats = ""(failed)"";
    }
    fprintf(stdout, ""\n%s\n"", stats.c_str());
  }",924.0,930.0,3.0,3.0,7.0,5,5,6,4,0,1,2,2,1,0,,0,1,2,1,1,void
993,8840,WriteToFile,1,leveldb.Benchmark.WriteToFile,"void leveldb.Benchmark.WriteToFile (void*,char*,int)",db\db_bench.cc,"static void WriteToFile(void* arg, const char* buf, int n) {
    reinterpret_cast<WritableFile*>(arg)->Append(Slice(buf, n));
  }",932.0,934.0,3.0,3.0,3.0,2,2,3,3,0,0,1,1,0,0,,0,0,6,3,3,void
994,8856,HeapProfile,1,leveldb.Benchmark.HeapProfile,void leveldb.Benchmark.HeapProfile (),db\db_bench.cc,"void HeapProfile() {
    char fname[100];
    snprintf(fname, sizeof(fname), ""%s/heap-%04d"", FLAGS_db, ++heap_counter_);
    WritableFile* file;
    Status s = g_env->NewWritableFile(fname, &file);
    if (!s.ok()) {
      fprintf(stderr, ""%s\n"", s.ToString().c_str());
      return;
    }
    bool ok = port::GetHeapProfile(WriteToFile, file);
    delete file;
    if (!ok) {
      fprintf(stderr, ""heap profiling not supported\n"");
      g_env->DeleteFile(fname);
    }
  }",936.0,951.0,3.0,3.0,16.0,14,8,19,9,0,2,3,3,0,0,,0,2,0,0,0,void
995,9414,Writer,1,leveldb.Writer.Writer,ANY leveldb.Writer.Writer (ANY*),db\db_impl.cc,explicit Writer(port::Mutex* mu) : cv(mu) { },48.0,48.0,3.0,47.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
996,9431,current_output,1,leveldb.CompactionState.current_output,Output leveldb.CompactionState.current_output (),db\db_impl.cc,Output* current_output() { return &outputs[outputs.size()-1]; },74.0,74.0,3.0,65.0,1.0,4,4,2,1,0,2,1,1,0,0,,0,2,0,0,0,Output
997,9445,CompactionState,1,leveldb.CompactionState.CompactionState,ANY leveldb.CompactionState.CompactionState (Compaction*),db\db_impl.cc,"explicit CompactionState(Compaction* c)
      : compaction(c),
        outfile(NULL),
        builder(NULL),
        total_bytes(0) {
  }",76.0,81.0,3.0,3.0,6.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
998,9450,ClipToRange,1,leveldb.ClipToRange,"void leveldb.ClipToRange<T,V> (T*,V,V)",db\db_impl.cc,"static void ClipToRange(T* ptr, V minvalue, V maxvalue) {
  if (static_cast<V>(*ptr) > maxvalue) *ptr = maxvalue;
  if (static_cast<V>(*ptr) < minvalue) *ptr = minvalue;
}",86.0,89.0,1.0,1.0,4.0,10,5,8,3,0,0,3,3,0,0,,0,0,6,3,3,void
999,9481,SanitizeOptions,1,leveldb.SanitizeOptions,"Options leveldb.SanitizeOptions (ANY,InternalKeyComparator*,InternalFilterPolicy*,Options)",db\db_impl.cc,"Options SanitizeOptions(const std::string& dbname,
                        const InternalKeyComparator* icmp,
                        const InternalFilterPolicy* ipolicy,
                        const Options& src) {
  Options result = src;
  result.comparator = icmp;
  result.filter_policy = (src.filter_policy != NULL) ? ipolicy : NULL;
  ClipToRange(&result.max_open_files,    64 + kNumNonTableCacheFiles, 50000);
  ClipToRange(&result.write_buffer_size, 64<<10,                      1<<30);
  ClipToRange(&result.max_file_size,     1<<20,                       1<<30);
  ClipToRange(&result.block_size,        1<<10,                       4<<20);
  if (result.info_log == NULL) {
    // Open a log file in the same directory as the db
    src.env->CreateDir(dbname);  // In case it does not exist
    src.env->RenameFile(InfoLogFileName(dbname), OldInfoLogFileName(dbname));
    Status s = src.env->NewLogger(InfoLogFileName(dbname), &result.info_log);
    if (!s.ok()) {
      // No place su...",90.0,115.0,1.0,1.0,26.0,43,10,32,8,0,15,4,5,2,0,,0,15,8,4,4,Options
1000,9620,DBImpl,1,leveldb.DBImpl.DBImpl,"ANY leveldb.DBImpl.DBImpl (Options,ANY)",db\db_impl.cc,"DBImpl::DBImpl(const Options& raw_options, const std::string& dbname)
    : env_(raw_options.env),
      internal_comparator_(raw_options.comparator),
      internal_filter_policy_(raw_options.filter_policy),
      options_(SanitizeOptions(dbname, &internal_comparator_,
                               &internal_filter_policy_, raw_options)),
      owns_info_log_(options_.info_log != raw_options.info_log),
      owns_cache_(options_.block_cache != raw_options.block_cache),
      dbname_(dbname),
      db_lock_(NULL),
      shutting_down_(NULL),
      bg_cv_(&mutex_),
      mem_(NULL),
      imm_(NULL),
      logfile_(NULL),
      logfile_number_(0),
      log_(NULL),
      seed_(0),
      tmp_batch_(new WriteBatch),
      bg_compaction_scheduled_(false),
      manual_compaction_(NULL) {
  has_imm_.Release_Store(NULL);

  // Reserve ten files or so for other uses and give the rest to TableCache.
  const int table_cache_size = options_.max_open_files - kNumNonTableCacheFiles;
  table_ca...",117.0,146.0,1.0,1.0,30.0,11,5,16,11,0,10,1,1,0,0,,0,10,4,2,2,ANY
1001,9657,~DBImpl,1,leveldb.DBImpl.~DBImpl,ANY leveldb.DBImpl.~DBImpl (),db\db_impl.cc,"DBImpl::~DBImpl() {
  // Wait for background work to finish
  mutex_.Lock();
  shutting_down_.Release_Store(this);  // Any non-NULL value is ok
  while (bg_compaction_scheduled_) {
    bg_cv_.Wait();
  }
  mutex_.Unlock();

  if (db_lock_ != NULL) {
    env_->UnlockFile(db_lock_);
  }

  delete versions_;
  if (mem_ != NULL) mem_->Unref();
  if (imm_ != NULL) imm_->Unref();
  delete tmp_batch_;
  delete log_;
  delete logfile_;
  delete table_cache_;

  if (owns_info_log_) {
    delete options_.info_log;
  }
  if (owns_cache_) {
    delete options_.block_cache;
  }
}",148.0,175.0,1.0,1.0,28.0,19,4,24,17,0,21,7,7,6,0,,0,21,0,0,0,ANY
1002,9733,NewDB,1,leveldb.DBImpl.NewDB,Status leveldb.DBImpl.NewDB (),db\db_impl.cc,"Status DBImpl::NewDB() {
  VersionEdit new_db;
  new_db.SetComparatorName(user_comparator()->Name());
  new_db.SetLogNumber(0);
  new_db.SetNextFile(2);
  new_db.SetLastSequence(0);

  const std::string manifest = DescriptorFileName(dbname_, 1);
  WritableFile* file;
  Status s = env_->NewWritableFile(manifest, &file);
  if (!s.ok()) {
    return s;
  }
  {
    log::Writer log(file);
    std::string record;
    new_db.EncodeTo(&record);
    s = log.AddRecord(record);
    if (s.ok()) {
      s = file->Close();
    }
  }
  delete file;
  if (s.ok()) {
    // Make ""CURRENT"" file that points to the new manifest file.
    s = SetCurrentFile(env_, dbname_, 1);
  } else {
    env_->DeleteFile(manifest);
  }
  return s;
}",177.0,207.0,1.0,1.0,31.0,21,6,27,8,0,4,4,4,0,0,,0,4,0,0,0,Status
1003,9840,MaybeIgnoreError,1,leveldb.DBImpl.MaybeIgnoreError,void leveldb.DBImpl.MaybeIgnoreError (Status*),db\db_impl.cc,"void DBImpl::MaybeIgnoreError(Status* s) const {
  if (s->ok() || options_.paranoid_checks) {
    // No change needed
  } else {
    Log(options_.info_log, ""Ignoring error %s"", s->ToString().c_str());
    *s = Status::OK();
  }
}",209.0,216.0,1.0,1.0,8.0,3,3,2,2,0,1,2,2,1,0,,0,1,2,1,1,void
1004,9876,DeleteObsoleteFiles,1,leveldb.DBImpl.DeleteObsoleteFiles,void leveldb.DBImpl.DeleteObsoleteFiles (),db\db_impl.cc,"void DBImpl::DeleteObsoleteFiles() {
  if (!bg_error_.ok()) {
    // After a background error, we don't know whether a new version may
    // or may not have been committed, so we cannot safely garbage collect.
    return;
  }

  // Make a set of all of the live files
  std::set<uint64_t> live = pending_outputs_;
  versions_->AddLiveFiles(&live);

  std::vector<std::string> filenames;
  env_->GetChildren(dbname_, &filenames); // Ignoring errors on purpose
  uint64_t number;
  FileType type;
  for (size_t i = 0; i < filenames.size(); i++) {
    if (ParseFileName(filenames[i], &number, &type)) {
      bool keep = true;
      switch (type) {
        case kLogFile:
          keep = ((number >= versions_->LogNumber()) ||
                  (number == versions_->PrevLogNumber()));
          break;
        case kDescriptorFile:
          // Keep my manifest file, and any newer incarnations'
          // (in case there is a race that allows other incarnations)
          keep = (number >= ver...",218.0,272.0,1.0,1.0,55.0,49,15,58,22,0,12,12,15,1,0,,0,12,0,0,0,void
1005,10058,Recover,1,leveldb.DBImpl.Recover,"Status leveldb.DBImpl.Recover (VersionEdit*,bool*)",db\db_impl.cc,"Status DBImpl::Recover(VersionEdit* edit, bool *save_manifest) {
  mutex_.AssertHeld();

  // Ignore error from CreateDir since the creation of the DB is
  // committed only when the descriptor is created, and this directory
  // may already exist from a previous failed creation attempt.
  env_->CreateDir(dbname_);
  assert(db_lock_ == NULL);
  Status s = env_->LockFile(LockFileName(dbname_), &db_lock_);
  if (!s.ok()) {
    return s;
  }

  if (!env_->FileExists(CurrentFileName(dbname_))) {
    if (options_.create_if_missing) {
      s = NewDB();
      if (!s.ok()) {
        return s;
      }
    } else {
      return Status::InvalidArgument(
          dbname_, ""does not exist (create_if_missing is false)"");
    }
  } else {
    if (options_.error_if_exists) {
      return Status::InvalidArgument(
          dbname_, ""exists (error_if_exists is true)"");
    }
  }

  s = versions_->Recover(save_manifest);
  if (!s.ok()) {
    return s;
  }
  SequenceNumber max_sequence(0);

  // Reco...",274.0,363.0,1.0,1.0,90.0,80,16,92,24,0,21,14,21,4,0,,0,20,4,2,2,Status
1006,10387,RecoverLogFile,1,leveldb.DBImpl.RecoverLogFile,"Status leveldb.DBImpl.RecoverLogFile (uint64_t,bool,bool*,VersionEdit*,SequenceNumber*)",db\db_impl.cc,"Status DBImpl::RecoverLogFile(uint64_t log_number, bool last_log,
                              bool* save_manifest, VersionEdit* edit,
                              SequenceNumber* max_sequence) {
  struct LogReporter : public log::Reader::Reporter {
    Env* env;
    Logger* info_log;
    const char* fname;
    Status* status;  // NULL if options_.paranoid_checks==false
    virtual void Corruption(size_t bytes, const Status& s) {
      Log(info_log, ""%s%s: dropping %d bytes; %s"",
          (this->status == NULL ? ""(ignoring error) "" : """"),
          fname, static_cast<int>(bytes), s.ToString().c_str());
      if (this->status != NULL && this->status->ok()) *this->status = s;
    }
  };

  mutex_.AssertHeld();

  // Open the log file
  std::string fname = LogFileName(dbname_, log_number);
  SequentialFile* file;
  Status status = env_->NewSequentialFile(fname, &file);
  if (!status.ok()) {
    MaybeIgnoreError(&status);
    return status;
  }

  // Create the log reader.
  LogRepor...",365.0,486.0,1.0,1.0,122.0,101,18,113,31,0,22,17,25,5,1,,0,21,10,5,5,Status
1007,10751,WriteLevel0Table,1,leveldb.DBImpl.WriteLevel0Table,"Status leveldb.DBImpl.WriteLevel0Table (MemTable*,VersionEdit*,Version*)",db\db_impl.cc,"Status DBImpl::WriteLevel0Table(MemTable* mem, VersionEdit* edit,
                                Version* base) {
  mutex_.AssertHeld();
  const uint64_t start_micros = env_->NowMicros();
  FileMetaData meta;
  meta.number = versions_->NewFileNumber();
  pending_outputs_.insert(meta.number);
  Iterator* iter = mem->NewIterator();
  Log(options_.info_log, ""Level-0 table #%llu: started"",
      (unsigned long long) meta.number);

  Status s;
  {
    mutex_.Unlock();
    s = BuildTable(dbname_, env_, options_, table_cache_, iter, &meta);
    mutex_.Lock();
  }

  Log(options_.info_log, ""Level-0 table #%llu: %lld bytes %s"",
      (unsigned long long) meta.number,
      (unsigned long long) meta.file_size,
      s.ToString().c_str());
  delete iter;
  pending_outputs_.erase(meta.number);


  // Note that if file_size is zero, the file has been deleted and
  // should not be added to the manifest.
  int level = 0;
  if (s.ok() && meta.file_size > 0) {
    const Slice min_user_key = meta.s...",488.0,532.0,1.0,1.0,45.0,55,11,55,20,0,31,3,4,1,0,,0,31,6,3,3,Status
1008,10944,CompactMemTable,1,leveldb.DBImpl.CompactMemTable,void leveldb.DBImpl.CompactMemTable (),db\db_impl.cc,"void DBImpl::CompactMemTable() {
  mutex_.AssertHeld();
  assert(imm_ != NULL);

  // Save the contents of the memtable as a new Table
  VersionEdit edit;
  Version* base = versions_->current();
  base->Ref();
  Status s = WriteLevel0Table(imm_, &edit, base);
  base->Unref();

  if (s.ok() && shutting_down_.Acquire_Load()) {
    s = Status::IOError(""Deleting DB during memtable compaction"");
  }

  // Replace immutable memtable with the generated Table
  if (s.ok()) {
    edit.SetPrevLogNumber(0);
    edit.SetLogNumber(logfile_number_);  // Earlier logs no longer needed
    s = versions_->LogAndApply(&edit, &mutex_);
  }

  if (s.ok()) {
    // Commit to the new state
    imm_->Unref();
    imm_ = NULL;
    has_imm_.Release_Store(NULL);
    DeleteObsoleteFiles();
  } else {
    RecordBackgroundError(s);
  }
}",534.0,565.0,1.0,1.0,32.0,24,6,29,11,0,12,4,4,1,1,,0,12,0,0,0,void
1009,11047,CompactRange,1,leveldb.DBImpl.CompactRange,"void leveldb.DBImpl.CompactRange (Slice*,Slice*)",db\db_impl.cc,"void DBImpl::CompactRange(const Slice* begin, const Slice* end) {
  int max_level_with_files = 1;
  {
    MutexLock l(&mutex_);
    Version* base = versions_->current();
    for (int level = 1; level < config::kNumLevels; level++) {
      if (base->OverlapInLevel(level, begin, end)) {
        max_level_with_files = level;
      }
    }
  }
  TEST_CompactMemTable(); // TODO(sanjay): Skip if memtable does not overlap
  for (int level = 0; level < max_level_with_files; level++) {
    TEST_CompactRange(level, begin, end);
  }
}",567.0,582.0,1.0,1.0,16.0,11,5,19,8,0,7,4,5,3,0,,0,7,4,2,2,void
1010,11112,TEST_CompactRange,1,leveldb.DBImpl.TEST_CompactRange,"void leveldb.DBImpl.TEST_CompactRange (int,Slice*,Slice*)",db\db_impl.cc,"void DBImpl::TEST_CompactRange(int level, const Slice* begin,const Slice* end) {
  assert(level >= 0);
  assert(level + 1 < config::kNumLevels);

  InternalKey begin_storage, end_storage;

  ManualCompaction manual;
  manual.level = level;
  manual.done = false;
  if (begin == NULL) {
    manual.begin = NULL;
  } else {
    begin_storage = InternalKey(*begin, kMaxSequenceNumber, kValueTypeForSeek);
    manual.begin = &begin_storage;
  }
  if (end == NULL) {
    manual.end = NULL;
  } else {
    end_storage = InternalKey(*end, 0, static_cast<ValueType>(0));
    manual.end = &end_storage;
  }

  MutexLock l(&mutex_);
  while (!manual.done && !shutting_down_.Acquire_Load() && bg_error_.ok()) {
    if (manual_compaction_ == NULL) {  // Idle
      manual_compaction_ = &manual;
      MaybeScheduleCompaction();
    } else {  // Running either my compaction or another compaction.
      bg_cv_.Wait();
    }
  }
  if (manual_compaction_ == &manual) {
    // Cancel my manual compaction since w...",584.0,619.0,1.0,1.0,36.0,28,9,26,10,0,12,6,7,5,0,,0,12,6,3,3,void
1011,11242,TEST_CompactMemTable,1,leveldb.DBImpl.TEST_CompactMemTable,Status leveldb.DBImpl.TEST_CompactMemTable (),db\db_impl.cc,"Status DBImpl::TEST_CompactMemTable() {
  // NULL batch means just wait for earlier writes to be done
  Status s = Write(WriteOptions(), NULL);
  if (s.ok()) {
    // Wait until the compaction completes
    MutexLock l(&mutex_);
    while (imm_ != NULL && bg_error_.ok()) {
      bg_cv_.Wait();
    }
    if (imm_ != NULL) {
      s = bg_error_;
    }
  }
  return s;
}",621.0,635.0,1.0,1.0,15.0,9,5,13,6,0,6,4,6,3,0,,0,6,0,0,0,Status
1012,11286,RecordBackgroundError,1,leveldb.DBImpl.RecordBackgroundError,void leveldb.DBImpl.RecordBackgroundError (Status),db\db_impl.cc,"void DBImpl::RecordBackgroundError(const Status& s) {
  mutex_.AssertHeld();
  if (bg_error_.ok()) {
    bg_error_ = s;
    bg_cv_.SignalAll();
  }
}",637.0,643.0,1.0,1.0,7.0,4,2,5,4,0,4,2,2,1,0,,0,4,2,1,1,void
1013,11308,MaybeScheduleCompaction,1,leveldb.DBImpl.MaybeScheduleCompaction,void leveldb.DBImpl.MaybeScheduleCompaction (),db\db_impl.cc,"void DBImpl::MaybeScheduleCompaction() {
  mutex_.AssertHeld();
  if (bg_compaction_scheduled_) {
    // Already scheduled
  } else if (shutting_down_.Acquire_Load()) {
    // DB is being deleted; no more background compactions
  } else if (!bg_error_.ok()) {
    // Already got an error; no more changes
  } else if (imm_ == NULL &&
             manual_compaction_ == NULL &&
             !versions_->NeedsCompaction()) {
    // No work to be done
  } else {
    bg_compaction_scheduled_ = true;
    env_->Schedule(&DBImpl::BGWork, this);
  }
}",645.0,661.0,1.0,1.0,17.0,1,1,2,2,0,2,2,2,1,0,,0,2,0,0,0,void
1014,11367,BGWork,1,leveldb.DBImpl.BGWork,void leveldb.DBImpl.BGWork (void*),db\db_impl.cc,"void DBImpl::BGWork(void* db) {
  reinterpret_cast<DBImpl*>(db)->BackgroundCall();
}",663.0,665.0,1.0,1.0,3.0,2,2,1,1,0,0,1,1,0,0,,0,0,2,1,1,void
1015,11378,BackgroundCall,1,leveldb.DBImpl.BackgroundCall,void leveldb.DBImpl.BackgroundCall (),db\db_impl.cc,"void DBImpl::BackgroundCall() {
  MutexLock l(&mutex_);
  assert(bg_compaction_scheduled_);
  if (shutting_down_.Acquire_Load()) {
    // No more background work when shutting down.
  } else if (!bg_error_.ok()) {
    // No more background work after a background error.
  } else {
    BackgroundCompaction();
  }

  bg_compaction_scheduled_ = false;

  // Previous compaction may have produced too many files in a level,
  // so reschedule another compaction if needed.
  MaybeScheduleCompaction();
  bg_cv_.SignalAll();
}",667.0,684.0,1.0,1.0,18.0,4,3,5,4,0,5,2,2,1,0,,0,5,0,0,0,void
1016,11414,BackgroundCompaction,1,leveldb.DBImpl.BackgroundCompaction,void leveldb.DBImpl.BackgroundCompaction (),db\db_impl.cc,"void DBImpl::BackgroundCompaction() {
  mutex_.AssertHeld();

  if (imm_ != NULL) {
    CompactMemTable();
    return;
  }

  Compaction* c;
  bool is_manual = (manual_compaction_ != NULL);
  InternalKey manual_end;
  if (is_manual) {
    ManualCompaction* m = manual_compaction_;
    c = versions_->CompactRange(m->level, m->begin, m->end);
    m->done = (c == NULL);
    if (c != NULL) {
      manual_end = c->input(0, c->num_input_files(0) - 1)->largest;
    }
    Log(options_.info_log,
        ""Manual compaction at level-%d from %s .. %s; will stop at %s\n"",
        m->level,
        (m->begin ? m->begin->DebugString().c_str() : ""(begin)""),
        (m->end ? m->end->DebugString().c_str() : ""(end)""),
        (m->done ? ""(end)"" : manual_end.DebugString().c_str()));
  } else {
    c = versions_->PickCompaction();
  }

  Status status;
  if (c == NULL) {
    // Nothing to do
  } else if (!is_manual && c->IsTrivialMove()) {
    // Move file to next level
    assert(c->num_input_files(0) ...",686.0,769.0,1.0,1.0,84.0,52,10,46,11,0,23,9,12,2,0,,0,23,0,0,0,void
1017,11771,CleanupCompaction,1,leveldb.DBImpl.CleanupCompaction,void leveldb.DBImpl.CleanupCompaction (CompactionState*),db\db_impl.cc,"void DBImpl::CleanupCompaction(CompactionState* compact) {
  mutex_.AssertHeld();
  if (compact->builder != NULL) {
    // May happen if we get a shutdown call in the middle of compaction
    compact->builder->Abandon();
    delete compact->builder;
  } else {
    assert(compact->outfile == NULL);
  }
  delete compact->outfile;
  for (size_t i = 0; i < compact->outputs.size(); i++) {
    const CompactionState::Output& out = compact->outputs[i];
    pending_outputs_.erase(out.number);
  }
  delete compact;
}",771.0,786.0,1.0,1.0,16.0,19,7,15,6,0,8,3,3,2,0,,0,8,2,1,1,void
1018,11843,OpenCompactionOutputFile,1,leveldb.DBImpl.OpenCompactionOutputFile,Status leveldb.DBImpl.OpenCompactionOutputFile (CompactionState*),db\db_impl.cc,"Status DBImpl::OpenCompactionOutputFile(CompactionState* compact) {
  assert(compact != NULL);
  assert(compact->builder == NULL);
  uint64_t file_number;
  {
    mutex_.Lock();
    file_number = versions_->NewFileNumber();
    pending_outputs_.insert(file_number);
    CompactionState::Output out;
    out.number = file_number;
    out.smallest.Clear();
    out.largest.Clear();
    compact->outputs.push_back(out);
    mutex_.Unlock();
  }

  // Make the output file
  std::string fname = TableFileName(dbname_, file_number);
  Status s = env_->NewWritableFile(fname, &compact->outfile);
  if (s.ok()) {
    compact->builder = new TableBuilder(options_, compact->outfile);
  }
  return s;
}",788.0,811.0,1.0,1.0,24.0,26,7,29,13,0,12,2,2,0,0,,0,12,2,1,1,Status
1019,11940,FinishCompactionOutputFile,1,leveldb.DBImpl.FinishCompactionOutputFile,"Status leveldb.DBImpl.FinishCompactionOutputFile (CompactionState*,Iterator*)",db\db_impl.cc,"Status DBImpl::FinishCompactionOutputFile(CompactionState* compact,
                                          Iterator* input) {
  assert(compact != NULL);
  assert(compact->outfile != NULL);
  assert(compact->builder != NULL);

  const uint64_t output_number = compact->current_output()->number;
  assert(output_number != 0);

  // Check for iterator errors
  Status s = input->status();
  const uint64_t current_entries = compact->builder->NumEntries();
  if (s.ok()) {
    s = compact->builder->Finish();
  } else {
    compact->builder->Abandon();
  }
  const uint64_t current_bytes = compact->builder->FileSize();
  compact->current_output()->file_size = current_bytes;
  compact->total_bytes += current_bytes;
  delete compact->builder;
  compact->builder = NULL;

  // Finish and check for file errors
  if (s.ok()) {
    s = compact->outfile->Sync();
  }
  if (s.ok()) {
    s = compact->outfile->Close();
  }
  delete compact->outfile;
  compact->outfile = NULL;

  if (s.ok() && current_...",813.0,863.0,1.0,1.0,51.0,57,9,50,10,0,15,6,7,0,0,,0,15,4,2,2,Status
1020,12137,InstallCompactionResults,1,leveldb.DBImpl.InstallCompactionResults,Status leveldb.DBImpl.InstallCompactionResults (CompactionState*),db\db_impl.cc,"Status DBImpl::InstallCompactionResults(CompactionState* compact) {
  mutex_.AssertHeld();
  Log(options_.info_log,  ""Compacted %d@%d + %d@%d files => %lld bytes"",
      compact->compaction->num_input_files(0),
      compact->compaction->level(),
      compact->compaction->num_input_files(1),
      compact->compaction->level() + 1,
      static_cast<long long>(compact->total_bytes));

  // Add compaction outputs
  compact->compaction->AddInputDeletions(compact->compaction->edit());
  const int level = compact->compaction->level();
  for (size_t i = 0; i < compact->outputs.size(); i++) {
    const CompactionState::Output& out = compact->outputs[i];
    compact->compaction->edit()->AddFile(
        level + 1,
        out.number, out.file_size, out.smallest, out.largest);
  }
  return versions_->LogAndApply(compact->compaction->edit(), &mutex_);
}",866.0,885.0,1.0,1.0,20.0,39,8,26,7,0,16,2,2,1,0,,0,16,2,1,1,Status
1021,12267,DoCompactionWork,1,leveldb.DBImpl.DoCompactionWork,Status leveldb.DBImpl.DoCompactionWork (CompactionState*),db\db_impl.cc,"Status DBImpl::DoCompactionWork(CompactionState* compact) {
  const uint64_t start_micros = env_->NowMicros();
  int64_t imm_micros = 0;  // Micros spent doing imm_ compactions

  Log(options_.info_log,  ""Compacting %d@%d + %d@%d files"",
      compact->compaction->num_input_files(0),
      compact->compaction->level(),
      compact->compaction->num_input_files(1),
      compact->compaction->level() + 1);

  assert(versions_->NumLevelFiles(compact->compaction->level()) > 0);
  assert(compact->builder == NULL);
  assert(compact->outfile == NULL);
  if (snapshots_.empty()) {
    compact->smallest_snapshot = versions_->LastSequence();
  } else {
    compact->smallest_snapshot = snapshots_.oldest()->number_;
  }

  // Release mutex while we're actually doing the compaction work
  mutex_.Unlock();

  Iterator* input = versions_->MakeInputIterator(compact->compaction);
  input->SeekToFirst();
  Status status;
  ParsedInternalKey ikey;
  std::string current_user_key;
  bool has_current_use...",887.0,1046.0,1.0,1.0,160.0,143,16,126,29,0,47,25,43,14,1,,0,47,2,1,1,Status
1022,12881,CleanupIteratorState,1,leveldb.anonymous_namespace_2.CleanupIteratorState,"void leveldb.anonymous_namespace_2.CleanupIteratorState (void*,void*)",db\db_impl.cc,"static void CleanupIteratorState(void* arg1, void* arg2) {
  IterState* state = reinterpret_cast<IterState*>(arg1);
  state->mu->Lock();
  state->mem->Unref();
  if (state->imm != NULL) state->imm->Unref();
  state->version->Unref();
  state->mu->Unlock();
  delete state;
}",1056.0,1064.0,1.0,1.0,9.0,15,5,10,3,0,6,2,2,1,0,,0,6,4,2,2,void
1023,12932,NewInternalIterator,1,leveldb.DBImpl.NewInternalIterator,"Iterator leveldb.DBImpl.NewInternalIterator (ReadOptions,SequenceNumber*,uint32_t*)",db\db_impl.cc,"Iterator* DBImpl::NewInternalIterator(const ReadOptions& options,
                                      SequenceNumber* latest_snapshot,
                                      uint32_t* seed) {
  IterState* cleanup = new IterState;
  mutex_.Lock();
  *latest_snapshot = versions_->LastSequence();

  // Collect together all needed child iterators
  std::vector<Iterator*> list;
  list.push_back(mem_->NewIterator());
  mem_->Ref();
  if (imm_ != NULL) {
    list.push_back(imm_->NewIterator());
    imm_->Ref();
  }
  versions_->current()->AddIterators(options, &list);
  Iterator* internal_iter =
      NewMergingIterator(&internal_comparator_, &list[0], list.size());
  versions_->current()->Ref();

  cleanup->mu = &mutex_;
  cleanup->mem = mem_;
  cleanup->imm = imm_;
  cleanup->version = versions_->current();
  internal_iter->RegisterCleanup(CleanupIteratorState, cleanup, NULL);

  *seed = ++seed_;
  mutex_.Unlock();
  return internal_iter;
}",1067.0,1096.0,1.0,1.0,30.0,38,9,36,14,0,20,2,2,1,0,,0,20,6,3,3,Iterator
1024,13058,TEST_NewInternalIterator,1,leveldb.DBImpl.TEST_NewInternalIterator,Iterator leveldb.DBImpl.TEST_NewInternalIterator (),db\db_impl.cc,"Iterator* DBImpl::TEST_NewInternalIterator() {
  SequenceNumber ignored;
  uint32_t ignored_seed;
  return NewInternalIterator(ReadOptions(), &ignored, &ignored_seed);
}",1098.0,1102.0,1.0,1.0,5.0,2,1,2,2,0,0,1,1,0,0,,0,0,0,0,0,Iterator
1025,13071,TEST_MaxNextLevelOverlappingBytes,1,leveldb.DBImpl.TEST_MaxNextLevelOverlappingBytes,int64_t leveldb.DBImpl.TEST_MaxNextLevelOverlappingBytes (),db\db_impl.cc,"int64_t DBImpl::TEST_MaxNextLevelOverlappingBytes() {
  MutexLock l(&mutex_);
  return versions_->MaxNextLevelOverlappingBytes();
}",1104.0,1107.0,1.0,1.0,4.0,2,2,2,2,0,2,1,1,0,0,,0,2,0,0,0,int64_t
1026,13084,Get,1,leveldb.DBImpl.Get,"Status leveldb.DBImpl.Get (ReadOptions,Slice,ANY*)",db\db_impl.cc,"Status DBImpl::Get(const ReadOptions& options,
                   const Slice& key,
                   std::string* value) {
  Status s;
  MutexLock l(&mutex_);
  SequenceNumber snapshot;
  if (options.snapshot != NULL) {
    snapshot = reinterpret_cast<const SnapshotImpl*>(options.snapshot)->number_;
  } else {
    snapshot = versions_->LastSequence();
  }

  MemTable* mem = mem_;
  MemTable* imm = imm_;
  Version* current = versions_->current();
  mem->Ref();
  if (imm != NULL) imm->Ref();
  current->Ref();

  bool have_stat_update = false;
  Version::GetStats stats;

  // Unlock while reading from files and memtables
  {
    mutex_.Unlock();
    // First look in the memtable, then in the immutable memtable (if any).
    LookupKey lkey(key, snapshot);
    if (mem->Get(lkey, value, &s)) {
      // Done
    } else if (imm != NULL && imm->Get(lkey, value, &s)) {
      // Done
    } else {
      s = current->Get(options, lkey, value, &stats);
      have_stat_update = true;
    }
    m...",1109.0,1154.0,1.0,1.0,46.0,26,7,34,16,0,8,6,6,1,0,,0,8,6,3,3,Status
1027,13242,NewIterator,1,leveldb.DBImpl.NewIterator,Iterator leveldb.DBImpl.NewIterator (ReadOptions),db\db_impl.cc,"Iterator* DBImpl::NewIterator(const ReadOptions& options) {
  SequenceNumber latest_snapshot;
  uint32_t seed;
  Iterator* iter = NewInternalIterator(options, &latest_snapshot, &seed);
  return NewDBIterator(
      this, user_comparator(), iter,
      (options.snapshot != NULL
       ? reinterpret_cast<const SnapshotImpl*>(options.snapshot)->number_
       : latest_snapshot),
      seed);
}",1156.0,1166.0,1.0,1.0,11.0,9,7,10,5,0,2,1,1,0,0,,0,2,2,1,1,Iterator
1028,13278,RecordReadSample,1,leveldb.DBImpl.RecordReadSample,void leveldb.DBImpl.RecordReadSample (Slice),db\db_impl.cc,"void DBImpl::RecordReadSample(Slice key) {
  MutexLock l(&mutex_);
  if (versions_->current()->RecordReadSample(key)) {
    MaybeScheduleCompaction();
  }
}",1168.0,1173.0,1.0,1.0,6.0,3,2,3,3,0,2,2,2,1,0,,0,2,2,1,1,void
1029,13298,GetSnapshot,1,leveldb.DBImpl.GetSnapshot,Snapshot leveldb.DBImpl.GetSnapshot (),db\db_impl.cc,"const Snapshot* DBImpl::GetSnapshot() {
  MutexLock l(&mutex_);
  return snapshots_.New(versions_->LastSequence());
}",1175.0,1178.0,1.0,1.0,4.0,3,3,3,3,0,3,1,1,0,0,,0,3,0,0,0,Snapshot
1030,13315,ReleaseSnapshot,1,leveldb.DBImpl.ReleaseSnapshot,void leveldb.DBImpl.ReleaseSnapshot (Snapshot*),db\db_impl.cc,"void DBImpl::ReleaseSnapshot(const Snapshot* s) {
  MutexLock l(&mutex_);
  snapshots_.Delete(reinterpret_cast<const SnapshotImpl*>(s));
}",1180.0,1183.0,1.0,1.0,4.0,3,3,3,3,0,2,1,1,0,0,,0,2,2,1,1,void
1031,13331,Put,1,leveldb.DBImpl.Put,"Status leveldb.DBImpl.Put (WriteOptions,Slice,Slice)",db\db_impl.cc,"Status DBImpl::Put(const WriteOptions& o, const Slice& key, const Slice& val) {
  return DB::Put(o, key, val);
}",1186.0,1188.0,1.0,1.0,3.0,1,1,4,4,0,0,1,1,0,0,,0,0,6,3,3,Status
1032,13346,Delete,1,leveldb.DBImpl.Delete,"Status leveldb.DBImpl.Delete (WriteOptions,Slice)",db\db_impl.cc,"Status DBImpl::Delete(const WriteOptions& options, const Slice& key) {
  return DB::Delete(options, key);
}",1190.0,1192.0,1.0,1.0,3.0,1,1,3,3,0,0,1,1,0,0,,0,0,4,2,2,Status
1033,13359,Write,1,leveldb.DBImpl.Write,"Status leveldb.DBImpl.Write (WriteOptions,WriteBatch*)",db\db_impl.cc,"Status DBImpl::Write(const WriteOptions& options, WriteBatch* my_batch) {
  Writer w(&mutex_);
  w.batch = my_batch;
  w.sync = options.sync;
  w.done = false;

  MutexLock l(&mutex_);
  writers_.push_back(&w);
  while (!w.done && &w != writers_.front()) {
    w.cv.Wait();
  }
  if (w.done) {
    return w.status;
  }

  // May temporarily unlock and wait.
  Status status = MakeRoomForWrite(my_batch == NULL);
  uint64_t last_sequence = versions_->LastSequence();
  Writer* last_writer = &w;
  if (status.ok() && my_batch != NULL) {  // NULL batch is for compactions
    WriteBatch* updates = BuildBatchGroup(&last_writer);
    WriteBatchInternal::SetSequence(updates, last_sequence + 1);
    last_sequence += WriteBatchInternal::Count(updates);

    // Add to log and apply to memtable.  We can release the lock
    // during this phase since &w is currently responsible for logging
    // and protects against concurrent loggers and concurrent writes
    // into mem_.
    {
      mutex_.Unloc...",1194.0,1265.0,1.0,1.0,72.0,73,10,72,18,0,30,14,21,6,1,,0,30,4,2,2,Status
1034,13618,BuildBatchGroup,1,leveldb.DBImpl.BuildBatchGroup,WriteBatch leveldb.DBImpl.BuildBatchGroup (Writer**),db\db_impl.cc,"WriteBatch* DBImpl::BuildBatchGroup(Writer** last_writer) {
  assert(!writers_.empty());
  Writer* first = writers_.front();
  WriteBatch* result = first->batch;
  assert(result != NULL);

  size_t size = WriteBatchInternal::ByteSize(first->batch);

  // Allow the group to grow up to a maximum size, but if the
  // original write is small, limit the growth so we do not slow
  // down the small write too much.
  size_t max_size = 1 << 20;
  if (size <= (128<<10)) {
    max_size = size + (128<<10);
  }

  *last_writer = first;
  std::deque<Writer*>::iterator iter = writers_.begin();
  ++iter;  // Advance past ""first""
  for (; iter != writers_.end(); ++iter) {
    Writer* w = *iter;
    if (w->sync && !first->sync) {
      // Do not include a sync write into a batch handled by a non-sync write.
      break;
    }

    if (w->batch != NULL) {
      size += WriteBatchInternal::ByteSize(w->batch);
      if (size > max_size) {
        // Do not make batch too big
        break;
      }

  ...",1269.0,1314.0,1.0,1.0,46.0,47,14,47,11,0,18,9,13,6,2,,0,17,2,1,1,WriteBatch
1035,13778,MakeRoomForWrite,1,leveldb.DBImpl.MakeRoomForWrite,Status leveldb.DBImpl.MakeRoomForWrite (bool),db\db_impl.cc,"Status DBImpl::MakeRoomForWrite(bool force) {
  mutex_.AssertHeld();
  assert(!writers_.empty());
  bool allow_delay = !force;
  Status s;
  while (true) {
    if (!bg_error_.ok()) {
      // Yield previous error
      s = bg_error_;
      break;
    } else if (
        allow_delay &&
        versions_->NumLevelFiles(0) >= config::kL0_SlowdownWritesTrigger) {
      // We are getting close to hitting a hard limit on the number of
      // L0 files.  Rather than delaying a single write by several
      // seconds when we hit the hard limit, start delaying each
      // individual write by 1ms to reduce latency variance.  Also,
      // this delay hands over some CPU to the compaction thread in
      // case it is sharing the same core as the writer.
      mutex_.Unlock();
      env_->SleepForMicroseconds(1000);
      allow_delay = false;  // Do not delay a single write more than once
      mutex_.Lock();
    } else if (!force &&
               (mem_->ApproximateMemoryUsage() <= option...",1318.0,1379.0,1.0,1.0,62.0,8,3,8,6,0,4,4,4,1,0,,0,4,2,1,1,Status
1036,13980,GetProperty,1,leveldb.DBImpl.GetProperty,"bool leveldb.DBImpl.GetProperty (Slice,ANY*)",db\db_impl.cc,"bool DBImpl::GetProperty(const Slice& property, std::string* value) {
  value->clear();

  MutexLock l(&mutex_);
  Slice in = property;
  Slice prefix(""leveldb."");
  if (!in.starts_with(prefix)) return false;
  in.remove_prefix(prefix.size());

  if (in.starts_with(""num-files-at-level"")) {
    in.remove_prefix(strlen(""num-files-at-level""));
    uint64_t level;
    bool ok = ConsumeDecimalNumber(&in, &level) && in.empty();
    if (!ok || level >= config::kNumLevels) {
      return false;
    } else {
      char buf[100];
      snprintf(buf, sizeof(buf), ""%d"",
               versions_->NumLevelFiles(static_cast<int>(level)));
      *value = buf;
      return true;
    }
  } else if (in == ""stats"") {
    char buf[200];
    snprintf(buf, sizeof(buf),
             ""                               Compactions\n""
             ""Level  Files Size(MB) Time(sec) Read(MB) Write(MB)\n""
             ""--------------------------------------------------\n""
             );
    value->append(buf);
    ...",1381.0,1446.0,1.0,1.0,66.0,18,8,17,8,0,1,4,5,0,0,,0,1,4,2,2,bool
1037,14245,GetApproximateSizes,1,leveldb.DBImpl.GetApproximateSizes,"void leveldb.DBImpl.GetApproximateSizes (Range*,int,uint64_t*)",db\db_impl.cc,"void DBImpl::GetApproximateSizes(
    const Range* range, int n,
    uint64_t* sizes) {
  // TODO(opt): better implementation
  Version* v;
  {
    MutexLock l(&mutex_);
    versions_->current()->Ref();
    v = versions_->current();
  }

  for (int i = 0; i < n; i++) {
    // Convert user_key into a corresponding internal key.
    InternalKey k1(range[i].start, kMaxSequenceNumber, kValueTypeForSeek);
    InternalKey k2(range[i].limit, kMaxSequenceNumber, kValueTypeForSeek);
    uint64_t start = versions_->ApproximateOffsetOf(v, k1);
    uint64_t limit = versions_->ApproximateOffsetOf(v, k2);
    sizes[i] = (limit >= start ? limit - start : 0);
  }

  {
    MutexLock l(&mutex_);
    v->Unref();
  }
}",1448.0,1472.0,1.0,1.0,25.0,22,9,31,13,0,6,2,2,0,0,,0,6,6,3,3,void
1038,14340,Put,1,leveldb.DB.Put,"Status leveldb.DB.Put (WriteOptions,Slice,Slice)",db\db_impl.cc,"Status DB::Put(const WriteOptions& opt, const Slice& key, const Slice& value) {
  WriteBatch batch;
  batch.Put(key, value);
  return Write(opt, &batch);
}",1476.0,1480.0,1.0,1.0,5.0,2,2,5,4,0,0,1,1,0,0,,0,0,6,3,3,Status
1039,14359,Delete,1,leveldb.DB.Delete,"Status leveldb.DB.Delete (WriteOptions,Slice)",db\db_impl.cc,"Status DB::Delete(const WriteOptions& opt, const Slice& key) {
  WriteBatch batch;
  batch.Delete(key);
  return Write(opt, &batch);
}",1482.0,1486.0,1.0,1.0,5.0,2,2,4,3,0,0,1,1,0,0,,0,0,4,2,2,Status
1040,14376,~DB,1,leveldb.DB.~DB,ANY leveldb.DB.~DB (),db\db_impl.cc,DB::~DB() { },1488.0,1488.0,1.0,13.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
1041,14380,Open,1,leveldb.DB.Open,"Status leveldb.DB.Open (Options,ANY,DB**)",db\db_impl.cc,"Status DB::Open(const Options& options, const std::string& dbname,
                DB** dbptr) {
  *dbptr = NULL;

  DBImpl* impl = new DBImpl(options, dbname);
  impl->mutex_.Lock();
  VersionEdit edit;
  // Recover handles create_if_missing, error_if_exists
  bool save_manifest = false;
  Status s = impl->Recover(&edit, &save_manifest);
  if (s.ok() && impl->mem_ == NULL) {
    // Create new log and a corresponding memtable.
    uint64_t new_log_number = impl->versions_->NewFileNumber();
    WritableFile* lfile;
    s = options.env->NewWritableFile(LogFileName(dbname, new_log_number),
                                     &lfile);
    if (s.ok()) {
      edit.SetLogNumber(new_log_number);
      impl->logfile_ = lfile;
      impl->logfile_number_ = new_log_number;
      impl->log_ = new log::Writer(lfile);
      impl->mem_ = new MemTable(impl->internal_comparator_);
      impl->mem_->Ref();
    }
  }
  if (s.ok() && save_manifest) {
    edit.SetPrevLogNumber(0);  // No older logs ne...",1490.0,1532.0,1.0,1.0,43.0,58,9,55,13,0,15,6,7,1,0,,0,15,6,3,3,Status
1042,14574,~Snapshot,1,leveldb.Snapshot.~Snapshot,ANY leveldb.Snapshot.~Snapshot (),db\db_impl.cc,"Snapshot::~Snapshot() {
}",1534.0,1535.0,1.0,1.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
1043,14578,DestroyDB,1,leveldb.DestroyDB,"Status leveldb.DestroyDB (ANY,Options)",db\db_impl.cc,"Status DestroyDB(const std::string& dbname, const Options& options) {
  Env* env = options.env;
  std::vector<std::string> filenames;
  // Ignore error in case directory does not exist
  env->GetChildren(dbname, &filenames);
  if (filenames.empty()) {
    return Status::OK();
  }

  FileLock* lock;
  const std::string lockname = LockFileName(dbname);
  Status result = env->LockFile(lockname, &lock);
  if (result.ok()) {
    uint64_t number;
    FileType type;
    for (size_t i = 0; i < filenames.size(); i++) {
      if (ParseFileName(filenames[i], &number, &type) &&
          type != kDBLockFile) {  // Lock file will be deleted at end
        Status del = env->DeleteFile(dbname + ""/"" + filenames[i]);
        if (result.ok() && !del.ok()) {
          result = del;
        }
      }
    }
    env->UnlockFile(lock);  // Ignore error since state is already gone
    env->DeleteFile(lockname);
    env->DeleteDir(dbname);  // Ignore error in case dir contains other files
  }
  return resul...",1537.0,1566.0,1.0,1.0,30.0,36,11,42,14,0,2,6,12,0,0,,0,1,4,2,2,Status
1044,14983,CompactionStats,1,leveldb.DBImpl.CompactionStats.CompactionStats,ANY leveldb.DBImpl.CompactionStats.CompactionStats (),db\db_impl.hpp,"CompactionStats() : micros(0), bytes_read(0), bytes_written(0) { }",183.0,183.0,5.0,70.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
1045,14987,Add,1,leveldb.DBImpl.CompactionStats.Add,void leveldb.DBImpl.CompactionStats.Add (CompactionStats),db\db_impl.hpp,"void Add(const CompactionStats& c) {
      this->micros += c.micros;
      this->bytes_read += c.bytes_read;
      this->bytes_written += c.bytes_written;
    }",185.0,189.0,5.0,5.0,5.0,9,3,3,1,0,6,1,1,0,0,,0,6,2,1,1,void
1046,15019,operator =,1,leveldb.DBImpl.operator =,void leveldb.DBImpl.operator = (DBImpl),db\db_impl.hpp,void operator=(const DBImpl&);,195.0,195.0,8.0,31.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
1047,15024,user_comparator,1,leveldb.DBImpl.user_comparator,Comparator leveldb.DBImpl.user_comparator (),db\db_impl.hpp,"const Comparator* user_comparator() const {
    return internal_comparator_.user_comparator();
  }",197.0,199.0,3.0,3.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,Comparator
1048,15080,DBIter,1,leveldb.anonymous_namespace_3.DBIter.DBIter,"ANY leveldb.anonymous_namespace_3.DBIter.DBIter (DBImpl*,Comparator*,Iterator*,SequenceNumber,uint32_t)",db\db_iter.cc,"DBIter(DBImpl* db, const Comparator* cmp, Iterator* iter, SequenceNumber s,
         uint32_t seed)
      : db_(db),
        user_comparator_(cmp),
        iter_(iter),
        sequence_(s),
        direction_(kForward),
        valid_(false),
        rnd_(seed),
        bytes_counter_(RandomPeriod()) {
  }",51.0,61.0,3.0,3.0,11.0,0,0,0,0,0,0,1,1,0,0,,0,0,10,5,5,ANY
1049,15089,~DBIter,1,leveldb.anonymous_namespace_4.DBIter.~DBIter,ANY leveldb.anonymous_namespace_4.DBIter.~DBIter (),db\db_iter.cc,"virtual ~DBIter() {
    delete iter_;
  }",62.0,64.0,3.0,3.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,ANY
1050,15095,Valid,1,leveldb.anonymous_namespace_5.DBIter.Valid,bool leveldb.anonymous_namespace_5.DBIter.Valid (),db\db_iter.cc,virtual bool Valid() const { return valid_; },65.0,65.0,3.0,47.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,bool
1051,15101,key,1,leveldb.anonymous_namespace_6.DBIter.key,Slice leveldb.anonymous_namespace_6.DBIter.key (),db\db_iter.cc,"virtual Slice key() const {
    assert(valid_);
    return (direction_ == kForward) ? ExtractUserKey(iter_->key()) : saved_key_;
  }",66.0,69.0,3.0,3.0,4.0,3,3,5,5,0,5,1,1,0,0,,0,5,0,0,0,Slice
1052,15118,value,1,leveldb.anonymous_namespace_7.DBIter.value,Slice leveldb.anonymous_namespace_7.DBIter.value (),db\db_iter.cc,"virtual Slice value() const {
    assert(valid_);
    return (direction_ == kForward) ? iter_->value() : saved_value_;
  }",70.0,73.0,3.0,3.0,4.0,3,3,5,5,0,5,1,1,0,0,,0,5,0,0,0,Slice
1053,15134,status,1,leveldb.anonymous_namespace_8.DBIter.status,Status leveldb.anonymous_namespace_8.DBIter.status (),db\db_iter.cc,"virtual Status status() const {
    if (status_.ok()) {
      return iter_->status();
    } else {
      return status_;
    }
  }",74.0,80.0,3.0,3.0,7.0,2,2,2,2,0,2,2,2,1,0,,0,2,0,0,0,Status
1054,15153,Next,1,leveldb.anonymous_namespace_9.DBIter.Next,void leveldb.anonymous_namespace_9.DBIter.Next (),db\db_iter.cc,virtual void Next();,82.0,82.0,16.0,21.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1055,15157,Prev,1,leveldb.anonymous_namespace_10.DBIter.Prev,void leveldb.anonymous_namespace_10.DBIter.Prev (),db\db_iter.cc,virtual void Prev();,83.0,83.0,16.0,21.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1056,15161,Seek,1,leveldb.anonymous_namespace_11.DBIter.Seek,void leveldb.anonymous_namespace_11.DBIter.Seek (Slice),db\db_iter.cc,virtual void Seek(const Slice& target);,84.0,84.0,16.0,40.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
1057,15166,SeekToFirst,1,leveldb.anonymous_namespace_12.DBIter.SeekToFirst,void leveldb.anonymous_namespace_12.DBIter.SeekToFirst (),db\db_iter.cc,virtual void SeekToFirst();,85.0,85.0,16.0,28.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1058,15170,SeekToLast,1,leveldb.anonymous_namespace_13.DBIter.SeekToLast,void leveldb.anonymous_namespace_13.DBIter.SeekToLast (),db\db_iter.cc,virtual void SeekToLast();,86.0,86.0,16.0,27.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1059,15174,FindNextUserEntry,1,leveldb.anonymous_namespace_14.DBIter.FindNextUserEntry,"void leveldb.anonymous_namespace_14.DBIter.FindNextUserEntry (bool,ANY*)",db\db_iter.cc,"void FindNextUserEntry(bool skipping, std::string* skip);",89.0,89.0,8.0,58.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
1060,15180,FindPrevUserEntry,1,leveldb.anonymous_namespace_15.DBIter.FindPrevUserEntry,void leveldb.anonymous_namespace_15.DBIter.FindPrevUserEntry (),db\db_iter.cc,void FindPrevUserEntry();,90.0,90.0,8.0,26.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1061,15184,ParseKey,1,leveldb.anonymous_namespace_16.DBIter.ParseKey,bool leveldb.anonymous_namespace_16.DBIter.ParseKey (ParsedInternalKey*),db\db_iter.cc,bool ParseKey(ParsedInternalKey* key);,91.0,91.0,8.0,39.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,bool
1062,15189,SaveKey,1,leveldb.anonymous_namespace_17.DBIter.SaveKey,"void leveldb.anonymous_namespace_17.DBIter.SaveKey (Slice,ANY*)",db\db_iter.cc,"inline void SaveKey(const Slice& k, std::string* dst) {
    dst->assign(k.data(), k.size());
  }",93.0,95.0,3.0,3.0,3.0,3,2,3,2,0,0,1,1,0,0,,0,0,4,2,2,void
1063,15207,ClearSavedValue,1,leveldb.anonymous_namespace_18.DBIter.ClearSavedValue,void leveldb.anonymous_namespace_18.DBIter.ClearSavedValue (),db\db_iter.cc,"inline void ClearSavedValue() {
    if (saved_value_.capacity() > 1048576) {
      std::string empty;
      swap(empty, saved_value_);
    } else {
      saved_value_.clear();
    }
  }",97.0,104.0,3.0,3.0,8.0,2,2,3,2,0,2,2,2,1,0,,0,2,0,0,0,void
1064,15229,RandomPeriod,1,leveldb.anonymous_namespace_19.DBIter.RandomPeriod,ssize_t leveldb.anonymous_namespace_19.DBIter.RandomPeriod (),db\db_iter.cc,"ssize_t RandomPeriod() {
    return rnd_.Uniform(2*config::kReadBytesPeriod);
  }",107.0,109.0,3.0,3.0,3.0,3,2,2,2,0,1,1,1,0,0,,0,1,0,0,0,ssize_t
1065,15254,DBIter,1,leveldb.anonymous_namespace_20.DBIter.DBIter,ANY leveldb.anonymous_namespace_20.DBIter.DBIter (DBIter),db\db_iter.cc,DBIter(const DBIter&);,126.0,126.0,3.0,23.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
1066,15259,operator =,1,leveldb.anonymous_namespace_21.DBIter.operator =,void leveldb.anonymous_namespace_21.DBIter.operator = (DBIter),db\db_iter.cc,void operator=(const DBIter&);,127.0,127.0,8.0,31.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
1067,15264,ParseKey,1,leveldb.anonymous_namespace_22.DBIter.ParseKey,bool leveldb.anonymous_namespace_22.DBIter.ParseKey (ParsedInternalKey*),db\db_iter.cc,"inline bool DBIter::ParseKey(ParsedInternalKey* ikey) {
  Slice k = iter_->key();
  ssize_t n = k.size() + iter_->value().size();
  bytes_counter_ -= n;
  while (bytes_counter_ < 0) {
    bytes_counter_ += RandomPeriod();
    db_->RecordReadSample(k);
  }
  if (!ParseInternalKey(k, ikey)) {
    status_ = Status::Corruption(""corrupted internal key in DBIter"");
    return false;
  } else {
    return true;
  }
}",130.0,144.0,1.0,1.0,15.0,14,8,15,8,0,1,3,3,0,1,,0,1,2,1,1,bool
1068,15326,Next,1,leveldb.anonymous_namespace_24.DBIter.Next,void leveldb.anonymous_namespace_24.DBIter.Next (),db\db_iter.cc,"void DBIter::Next() {
  assert(valid_);

  if (direction_ == kReverse) {  // Switch directions?
    direction_ = kForward;
    // iter_ is pointing just before the entries for this->key(),
    // so advance into the range of entries for this->key() and then
    // use the normal skipping code below.
    if (!iter_->Valid()) {
      iter_->SeekToFirst();
    } else {
      iter_->Next();
    }
    if (!iter_->Valid()) {
      valid_ = false;
      saved_key_.clear();
      return;
    }
    // saved_key_ already contains the key to skip past.
  } else {
    // Store in saved_key_ the current key so we skip it below.
    SaveKey(ExtractUserKey(iter_->key()), &saved_key_);
  }

  FindNextUserEntry(true, &saved_key_);
}",146.0,171.0,1.0,1.0,26.0,10,6,11,6,0,0,4,6,0,0,,0,0,0,0,0,void
1069,15386,FindNextUserEntry,1,leveldb.anonymous_namespace_26.DBIter.FindNextUserEntry,"void leveldb.anonymous_namespace_26.DBIter.FindNextUserEntry (bool,ANY*)",db\db_iter.cc,"void DBIter::FindNextUserEntry(bool skipping, std::string* skip) {
  // Loop until we hit an acceptable entry to yield
  assert(iter_->Valid());
  assert(direction_ == kForward);
  do {
    ParsedInternalKey ikey;
    if (ParseKey(&ikey) && ikey.sequence <= sequence_) {
      switch (ikey.type) {
        case kTypeDeletion:
          // Arrange to skip all upcoming entries for this key since
          // they are hidden by this deletion.
          SaveKey(ikey.user_key, skip);
          skipping = true;
          break;
        case kTypeValue:
          if (skipping &&
              user_comparator_->Compare(ikey.user_key, *skip) <= 0) {
            // Entry hidden
          } else {
            valid_ = true;
            saved_key_.clear();
            return;
          }
          break;
      }
    }
    iter_->Next();
  } while (iter_->Valid());
  saved_key_.clear();
  valid_ = false;
}",173.0,203.0,1.0,1.0,31.0,18,8,20,12,0,4,7,11,3,0,,0,4,4,2,2,void
1070,15474,Prev,1,leveldb.anonymous_namespace_29.DBIter.Prev,void leveldb.anonymous_namespace_29.DBIter.Prev (),db\db_iter.cc,"void DBIter::Prev() {
  assert(valid_);

  if (direction_ == kForward) {  // Switch directions?
    // iter_ is pointing at the current entry.  Scan backwards until
    // the key changes so we can use the normal reverse scanning code.
    assert(iter_->Valid());  // Otherwise valid_ would have been false
    SaveKey(ExtractUserKey(iter_->key()), &saved_key_);
    while (true) {
      iter_->Prev();
      if (!iter_->Valid()) {
        valid_ = false;
        saved_key_.clear();
        ClearSavedValue();
        return;
      }
      if (user_comparator_->Compare(ExtractUserKey(iter_->key()),
                                    saved_key_) < 0) {
        break;
      }
    }
    direction_ = kReverse;
  }

  FindPrevUserEntry();
}",205.0,230.0,1.0,1.0,26.0,13,7,15,7,0,0,6,10,0,0,,0,0,0,0,0,void
1071,15540,FindPrevUserEntry,1,leveldb.anonymous_namespace_32.DBIter.FindPrevUserEntry,void leveldb.anonymous_namespace_32.DBIter.FindPrevUserEntry (),db\db_iter.cc,"void DBIter::FindPrevUserEntry() {
  assert(direction_ == kReverse);

  ValueType value_type = kTypeDeletion;
  if (iter_->Valid()) {
    do {
      ParsedInternalKey ikey;
      if (ParseKey(&ikey) && ikey.sequence <= sequence_) {
        if ((value_type != kTypeDeletion) &&
            user_comparator_->Compare(ikey.user_key, saved_key_) < 0) {
          // We encountered a non-deleted value in entries for previous keys,
          break;
        }
        value_type = ikey.type;
        if (value_type == kTypeDeletion) {
          saved_key_.clear();
          ClearSavedValue();
        } else {
          Slice raw_value = iter_->value();
          if (saved_value_.capacity() > raw_value.size() + 1048576) {
            std::string empty;
            swap(empty, saved_value_);
          }
          SaveKey(ExtractUserKey(iter_->key()), &saved_key_);
          saved_value_.assign(raw_value.data(), raw_value.size());
        }
      }
      iter_->Prev();
    } while (iter_->Valid())...",232.0,272.0,1.0,1.0,41.0,22,9,26,11,0,3,8,16,2,0,,0,3,0,0,0,void
1072,15679,Seek,1,leveldb.anonymous_namespace_37.DBIter.Seek,void leveldb.anonymous_namespace_37.DBIter.Seek (Slice),db\db_iter.cc,"void DBIter::Seek(const Slice& target) {
  direction_ = kForward;
  ClearSavedValue();
  saved_key_.clear();
  AppendInternalKey(
      &saved_key_, ParsedInternalKey(target, sequence_, kValueTypeForSeek));
  iter_->Seek(saved_key_);
  if (iter_->Valid()) {
    FindNextUserEntry(false, &saved_key_ /* temporary storage */);
  } else {
    valid_ = false;
  }
}",274.0,286.0,1.0,1.0,13.0,6,4,11,7,0,0,2,2,0,0,,0,0,2,1,1,void
1073,15719,SeekToFirst,1,leveldb.anonymous_namespace_40.DBIter.SeekToFirst,void leveldb.anonymous_namespace_40.DBIter.SeekToFirst (),db\db_iter.cc,"void DBIter::SeekToFirst() {
  direction_ = kForward;
  ClearSavedValue();
  iter_->SeekToFirst();
  if (iter_->Valid()) {
    FindNextUserEntry(false, &saved_key_ /* temporary storage */);
  } else {
    valid_ = false;
  }
}",288.0,297.0,1.0,1.0,10.0,4,3,5,4,0,0,2,2,0,0,,0,0,0,0,0,void
1074,15746,SeekToLast,1,leveldb.anonymous_namespace_43.DBIter.SeekToLast,void leveldb.anonymous_namespace_43.DBIter.SeekToLast (),db\db_iter.cc,"void DBIter::SeekToLast() {
  direction_ = kReverse;
  ClearSavedValue();
  iter_->SeekToLast();
  FindPrevUserEntry();
}",299.0,304.0,1.0,1.0,6.0,2,2,3,3,0,0,1,1,0,0,,0,0,0,0,0,void
1075,15759,NewDBIterator,1,leveldb.NewDBIterator,"Iterator leveldb.NewDBIterator (DBImpl*,Comparator*,Iterator*,SequenceNumber,uint32_t)",db\db_iter.cc,"Iterator* NewDBIterator(
    DBImpl* db,
    const Comparator* user_key_comparator,
    Iterator* internal_iter,
    SequenceNumber sequence,
    uint32_t seed) {
  return new DBIter(db, user_key_comparator, internal_iter, sequence, seed);
}",308.0,315.0,1.0,1.0,8.0,1,1,6,6,0,0,1,1,0,0,,0,0,10,5,5,Iterator
1076,15832,RandomString,1,leveldb.RandomString,"string leveldb.RandomString (Random*,int)",db\db_test.cc,"static std::string RandomString(Random* rnd, int len) {
  std::string r;
  test::RandomString(rnd, len, &r);
  return r;
}",22.0,26.0,1.0,1.0,5.0,2,2,5,4,0,0,1,1,0,0,,0,0,4,2,2,string
1077,15853,AtomicCounter,1,leveldb.anonymous_namespace_2.AtomicCounter.AtomicCounter,ANY leveldb.anonymous_namespace_2.AtomicCounter.AtomicCounter (),db\db_test.cc,AtomicCounter() : count_(0) { },34.0,34.0,3.0,33.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
1078,15857,Increment,1,leveldb.anonymous_namespace_3.AtomicCounter.Increment,void leveldb.anonymous_namespace_3.AtomicCounter.Increment (),db\db_test.cc,"void Increment() {
    IncrementBy(1);
  }",35.0,37.0,3.0,3.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1079,15863,IncrementBy,1,leveldb.anonymous_namespace_5.AtomicCounter.IncrementBy,void leveldb.anonymous_namespace_5.AtomicCounter.IncrementBy (int),db\db_test.cc,"void IncrementBy(int count) {
    MutexLock l(&mu_);
    count_ += count;
  }",38.0,41.0,3.0,3.0,4.0,2,2,3,3,0,2,1,1,0,0,,0,2,2,1,1,void
1080,15875,Read,1,leveldb.anonymous_namespace_6.AtomicCounter.Read,int leveldb.anonymous_namespace_6.AtomicCounter.Read (),db\db_test.cc,"int Read() {
    MutexLock l(&mu_);
    return count_;
  }",42.0,45.0,3.0,3.0,4.0,1,1,2,2,0,2,1,1,0,0,,0,2,0,0,0,int
1081,15885,Reset,1,leveldb.anonymous_namespace_7.AtomicCounter.Reset,void leveldb.anonymous_namespace_7.AtomicCounter.Reset (),db\db_test.cc,"void Reset() {
    MutexLock l(&mu_);
    count_ = 0;
  }",46.0,49.0,3.0,3.0,4.0,2,2,2,2,0,2,1,1,0,0,,0,2,0,0,0,void
1082,15896,DelayMilliseconds,1,leveldb.anonymous_namespace_8.DelayMilliseconds,void leveldb.anonymous_namespace_8.DelayMilliseconds (int),db\db_test.cc,"void DelayMilliseconds(int millis) {
  Env::Default()->SleepForMicroseconds(millis * 1000);
}",52.0,54.0,1.0,1.0,3.0,3,3,2,2,0,0,1,1,0,0,,0,0,2,1,1,void
1083,15920,SpecialEnv,1,leveldb.SpecialEnv.SpecialEnv,ANY leveldb.SpecialEnv.SpecialEnv (Env*),db\db_test.cc,"explicit SpecialEnv(Env* base) : EnvWrapper(base) {
    delay_data_sync_.Release_Store(NULL);
    data_sync_error_.Release_Store(NULL);
    no_space_.Release_Store(NULL);
    non_writable_.Release_Store(NULL);
    count_random_reads_ = false;
    manifest_sync_error_.Release_Store(NULL);
    manifest_write_error_.Release_Store(NULL);
  }",81.0,89.0,3.0,3.0,9.0,7,2,13,8,0,7,1,1,0,0,,0,7,2,1,1,ANY
1084,15958,NewWritableFile,1,leveldb.SpecialEnv.NewWritableFile,"Status leveldb.SpecialEnv.NewWritableFile (ANY,WritableFile**)",db\db_test.cc,"Status NewWritableFile(const std::string& f, WritableFile** r) {
    class DataFile : public WritableFile {
     private:
      SpecialEnv* env_;
      WritableFile* base_;

     public:
      DataFile(SpecialEnv* env, WritableFile* base)
          : env_(env),
            base_(base) {
      }
      ~DataFile() { delete base_; }
      Status Append(const Slice& data) {
        if (env_->no_space_.Acquire_Load() != NULL) {
          // Drop writes on the floor
          return Status::OK();
        } else {
          return base_->Append(data);
        }
      }
      Status Close() { return base_->Close(); }
      Status Flush() { return base_->Flush(); }
      Status Sync() {
        if (env_->data_sync_error_.Acquire_Load() != NULL) {
          return Status::IOError(""simulated data sync error"");
        }
        while (env_->delay_data_sync_.Acquire_Load() != NULL) {
          DelayMilliseconds(100);
        }
        return base_->Sync();
      }
    };
    class ManifestFile ...",91.0,162.0,3.0,3.0,72.0,15,7,15,7,0,2,4,5,1,1,,0,1,4,2,2,Status
1085,16042,NewRandomAccessFile,1,leveldb.SpecialEnv.NewRandomAccessFile,"Status leveldb.SpecialEnv.NewRandomAccessFile (ANY,RandomAccessFile**)",db\db_test.cc,"Status NewRandomAccessFile(const std::string& f, RandomAccessFile** r) {
    class CountingFile : public RandomAccessFile {
     private:
      RandomAccessFile* target_;
      AtomicCounter* counter_;
     public:
      CountingFile(RandomAccessFile* target, AtomicCounter* counter)
          : target_(target), counter_(counter) {
      }
      virtual ~CountingFile() { delete target_; }
      virtual Status Read(uint64_t offset, size_t n, Slice* result,
                          char* scratch) const {
        counter_->Increment();
        return target_->Read(offset, n, result, scratch);
      }
    };

    Status s = target()->NewRandomAccessFile(f, r);
    if (s.ok() && count_random_reads_) {
      *r = new CountingFile(*r, &random_read_counter_);
    }
    return s;
  }",164.0,186.0,3.0,3.0,23.0,9,7,10,6,0,2,2,2,1,0,,0,2,4,2,2,Status
1086,16089,DBTest,1,leveldb.DBTest.DBTest,ANY leveldb.DBTest.DBTest (),db\db_test.cc,"DBTest() : option_config_(kDefault),
             env_(new SpecialEnv(Env::Default())) {
    filter_policy_ = NewBloomFilterPolicy(10);
    dbname_ = test::TmpDir() + ""/db_test"";
    DestroyDB(dbname_, Options());
    db_ = NULL;
    Reopen();
  }",210.0,217.0,3.0,3.0,8.0,5,3,6,5,0,4,1,1,0,0,,0,4,0,0,0,ANY
1087,16112,~DBTest,1,leveldb.DBTest.~DBTest,ANY leveldb.DBTest.~DBTest (),db\db_test.cc,"~DBTest() {
    delete db_;
    DestroyDB(dbname_, Options());
    delete env_;
    delete filter_policy_;
  }",219.0,224.0,3.0,3.0,6.0,3,1,4,4,0,4,1,1,0,0,,0,4,0,0,0,ANY
1088,16125,ChangeOptions,1,leveldb.DBTest.ChangeOptions,bool leveldb.DBTest.ChangeOptions (),db\db_test.cc,"bool ChangeOptions() {
    option_config_++;
    if (option_config_ >= kEnd) {
      return false;
    } else {
      DestroyAndReopen();
      return true;
    }
  }",228.0,236.0,3.0,3.0,9.0,2,2,3,2,0,3,2,2,2,0,,0,3,0,0,0,bool
1089,16143,CurrentOptions,1,leveldb.DBTest.CurrentOptions,Options leveldb.DBTest.CurrentOptions (),db\db_test.cc,"Options CurrentOptions() {
    Options options;
    options.reuse_logs = false;
    switch (option_config_) {
      case kReuse:
        options.reuse_logs = true;
        break;
      case kFilter:
        options.filter_policy = filter_policy_;
        break;
      case kUncompressed:
        options.compression = kNoCompression;
        break;
      default:
        break;
    }
    return options;
  }",239.0,256.0,3.0,3.0,18.0,8,2,11,7,0,9,6,2,1,0,,0,9,0,0,0,Options
1090,16184,dbfull,1,leveldb.DBTest.dbfull,DBImpl leveldb.DBTest.dbfull (),db\db_test.cc,"DBImpl* dbfull() {
    return reinterpret_cast<DBImpl*>(db_);
  }",258.0,260.0,3.0,3.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,DBImpl
1091,16192,Reopen,1,leveldb.DBTest.Reopen,void leveldb.DBTest.Reopen (Options*),db\db_test.cc,"void Reopen(Options* options = NULL) {
    ASSERT_OK(TryReopen(options));
  }",262.0,264.0,3.0,4.0,3.0,3,1,4,2,0,0,1,1,0,0,,0,0,2,1,1,void
1092,16214,Close,1,leveldb.DBTest.Close,void leveldb.DBTest.Close (),db\db_test.cc,"void Close() {
    delete db_;
    db_ = NULL;
  }",266.0,269.0,3.0,3.0,4.0,2,2,3,2,0,2,1,1,0,0,,0,2,0,0,0,void
1093,16223,DestroyAndReopen,1,leveldb.DBTest.DestroyAndReopen,void leveldb.DBTest.DestroyAndReopen (Options*),db\db_test.cc,"void DestroyAndReopen(Options* options = NULL) {
    delete db_;
    db_ = NULL;
    DestroyDB(dbname_, Options());
    ASSERT_OK(TryReopen(options));
  }",271.0,276.0,3.0,4.0,6.0,5,3,8,5,0,3,1,1,0,0,,0,3,2,1,1,void
1094,16253,TryReopen,1,leveldb.DBTest.TryReopen,Status leveldb.DBTest.TryReopen (Options*),db\db_test.cc,"Status TryReopen(Options* options) {
    delete db_;
    db_ = NULL;
    Options opts;
    if (options != NULL) {
      opts = *options;
    } else {
      opts = CurrentOptions();
      opts.create_if_missing = true;
    }
    last_options_ = opts;

    return DB::Open(opts, dbname_, &db_);
  }",278.0,291.0,3.0,3.0,14.0,8,6,13,7,0,5,2,2,0,0,,0,5,2,1,1,Status
1095,16295,Put,1,leveldb.DBTest.Put,"Status leveldb.DBTest.Put (ANY,ANY)",db\db_test.cc,"Status Put(const std::string& k, const std::string& v) {
    return db_->Put(WriteOptions(), k, v);
  }",293.0,295.0,3.0,3.0,3.0,1,1,3,3,0,1,1,1,0,0,,0,1,4,2,2,Status
1096,16309,Delete,1,leveldb.DBTest.Delete,Status leveldb.DBTest.Delete (ANY),db\db_test.cc,"Status Delete(const std::string& k) {
    return db_->Delete(WriteOptions(), k);
  }",297.0,299.0,3.0,3.0,3.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,Status
1097,16321,Get,1,leveldb.DBTest.Get,"string leveldb.DBTest.Get (ANY,Snapshot*)",db\db_test.cc,"std::string Get(const std::string& k, const Snapshot* snapshot = NULL) {
    ReadOptions options;
    options.snapshot = snapshot;
    std::string result;
    Status s = db_->Get(options, k, &result);
    if (s.IsNotFound()) {
      result = ""NOT_FOUND"";
    } else if (!s.ok()) {
      result = s.ToString();
    }
    return result;
  }",301.0,312.0,3.0,3.0,12.0,7,4,10,6,0,2,2,2,0,0,,0,2,4,2,2,string
1098,16371,Contents,1,leveldb.DBTest.Contents,string leveldb.DBTest.Contents (),db\db_test.cc,"std::string Contents() {
    std::vector<std::string> forward;
    std::string result;
    Iterator* iter = db_->NewIterator(ReadOptions());
    for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {
      std::string s = IterStatus(iter);
      result.push_back('(');
      result.append(s);
      result.push_back(')');
      forward.push_back(s);
    }

    // Check reverse iteration results are the reverse of forward results
    size_t matched = 0;
    for (iter->SeekToLast(); iter->Valid(); iter->Prev()) {
      ASSERT_LT(matched, forward.size());
      ASSERT_EQ(IterStatus(iter), forward[forward.size() - matched - 1]);
      matched++;
    }
    ASSERT_EQ(matched, forward.size());

    delete iter;
    return result;
  }",316.0,339.0,3.0,6.0,24.0,35,9,40,10,0,1,3,3,0,0,,0,1,0,0,0,string
1099,16531,AllEntriesFor,1,leveldb.DBTest.AllEntriesFor,string leveldb.DBTest.AllEntriesFor (Slice),db\db_test.cc,"std::string AllEntriesFor(const Slice& user_key) {
    Iterator* iter = dbfull()->TEST_NewInternalIterator();
    InternalKey target(user_key, kMaxSequenceNumber, kTypeValue);
    iter->Seek(target.Encode());
    std::string result;
    if (!iter->status().ok()) {
      result = iter->status().ToString();
    } else {
      result = ""[ "";
      bool first = true;
      while (iter->Valid()) {
        ParsedInternalKey ikey;
        if (!ParseInternalKey(iter->key(), &ikey)) {
          result += ""CORRUPTED"";
        } else {
          if (last_options_.comparator->Compare(ikey.user_key, user_key) != 0) {
            break;
          }
          if (!first) {
            result += "", "";
          }
          first = false;
          switch (ikey.type) {
            case kTypeValue:
              result += iter->value().ToString();
              break;
            case kTypeDeletion:
              result += ""DEL"";
              break;
          }
        }
        iter->Next();
      ...",341.0,381.0,3.0,3.0,41.0,11,5,11,6,0,0,2,2,0,0,,0,0,2,1,1,string
1100,16673,NumTableFilesAtLevel,1,leveldb.DBTest.NumTableFilesAtLevel,int leveldb.DBTest.NumTableFilesAtLevel (int),db\db_test.cc,"int NumTableFilesAtLevel(int level) {
    std::string property;
    ASSERT_TRUE(
        db_->GetProperty(""leveldb.num-files-at-level"" + NumberToString(level),
                         &property));
    return atoi(property.c_str());
  }",383.0,389.0,3.0,4.0,7.0,7,4,6,4,0,1,1,1,0,0,,0,1,2,1,1,int
1101,16709,TotalTableFiles,1,leveldb.DBTest.TotalTableFiles,int leveldb.DBTest.TotalTableFiles (),db\db_test.cc,"int TotalTableFiles() {
    int result = 0;
    for (int level = 0; level < config::kNumLevels; level++) {
      result += NumTableFilesAtLevel(level);
    }
    return result;
  }",391.0,397.0,3.0,3.0,7.0,5,4,7,3,0,0,2,2,0,0,,0,0,0,0,0,int
1102,16737,FilesPerLevel,1,leveldb.DBTest.FilesPerLevel,string leveldb.DBTest.FilesPerLevel (),db\db_test.cc,"std::string FilesPerLevel() {
    std::string result;
    int last_non_zero_offset = 0;
    for (int level = 0; level < config::kNumLevels; level++) {
      int f = NumTableFilesAtLevel(level);
      char buf[100];
      snprintf(buf, sizeof(buf), ""%s%d"", (level ? "","" : """"), f);
      result += buf;
      if (f > 0) {
        last_non_zero_offset = result.size();
      }
    }
    result.resize(last_non_zero_offset);
    return result;
  }",400.0,414.0,3.0,3.0,15.0,12,7,18,6,0,0,3,4,0,0,,0,0,0,0,0,string
1103,16797,CountFiles,1,leveldb.DBTest.CountFiles,int leveldb.DBTest.CountFiles (),db\db_test.cc,"int CountFiles() {
    std::vector<std::string> files;
    env_->GetChildren(dbname_, &files);
    return static_cast<int>(files.size());
  }",416.0,420.0,3.0,3.0,5.0,8,6,7,4,0,2,1,1,0,0,,0,2,0,0,0,int
1104,16824,Size,1,leveldb.DBTest.Size,"uint64_t leveldb.DBTest.Size (Slice,Slice)",db\db_test.cc,"uint64_t Size(const Slice& start, const Slice& limit) {
    Range r(start, limit);
    uint64_t size;
    db_->GetApproximateSizes(&r, 1, &size);
    return size;
  }",422.0,427.0,3.0,3.0,6.0,3,2,6,5,0,1,1,1,0,0,,0,1,4,2,2,uint64_t
1105,16846,Compact,1,leveldb.DBTest.Compact,"void leveldb.DBTest.Compact (Slice,Slice)",db\db_test.cc,"void Compact(const Slice& start, const Slice& limit) {
    db_->CompactRange(&start, &limit);
  }",429.0,431.0,3.0,3.0,3.0,3,2,3,3,0,1,1,1,0,0,,0,1,4,2,2,void
1106,16860,MakeTables,1,leveldb.DBTest.MakeTables,"void leveldb.DBTest.MakeTables (int,ANY,ANY)",db\db_test.cc,"void MakeTables(int n, const std::string& small, const std::string& large) {
    for (int i = 0; i < n; i++) {
      Put(small, ""begin"");
      Put(large, ""end"");
      dbfull()->TEST_CompactMemTable();
    }
  }",435.0,441.0,3.0,3.0,7.0,3,3,5,4,0,0,2,2,0,0,,0,0,6,3,3,void
1107,16889,FillLevels,1,leveldb.DBTest.FillLevels,"void leveldb.DBTest.FillLevels (ANY,ANY)",db\db_test.cc,"void FillLevels(const std::string& smallest, const std::string& largest) {
    MakeTables(config::kNumLevels, smallest, largest);
  }",445.0,447.0,3.0,3.0,3.0,1,1,3,3,0,0,1,1,0,0,,0,0,4,2,2,void
1108,16901,DumpFileCounts,1,leveldb.DBTest.DumpFileCounts,void leveldb.DBTest.DumpFileCounts (char*),db\db_test.cc,"void DumpFileCounts(const char* label) {
    fprintf(stderr, ""---\n%s:\n"", label);
    fprintf(stderr, ""maxoverlap: %lld\n"",
            static_cast<long long>(
                dbfull()->TEST_MaxNextLevelOverlappingBytes()));
    for (int level = 0; level < config::kNumLevels; level++) {
      int num = NumTableFilesAtLevel(level);
      if (num > 0) {
        fprintf(stderr, ""  level %3d : %d files\n"", level, num);
      }
    }
  }",449.0,460.0,3.0,3.0,12.0,7,6,12,5,0,0,3,4,0,0,,0,0,2,1,1,void
1109,16948,DumpSSTableList,1,leveldb.DBTest.DumpSSTableList,string leveldb.DBTest.DumpSSTableList (),db\db_test.cc,"std::string DumpSSTableList() {
    std::string property;
    db_->GetProperty(""leveldb.sstables"", &property);
    return property;
  }",462.0,466.0,3.0,3.0,5.0,2,2,3,2,0,1,1,1,0,0,,0,1,0,0,0,string
1110,16962,IterStatus,1,leveldb.DBTest.IterStatus,string leveldb.DBTest.IterStatus (Iterator*),db\db_test.cc,"std::string IterStatus(Iterator* iter) {
    std::string result;
    if (iter->Valid()) {
      result = iter->key().ToString() + ""->"" + iter->value().ToString();
    } else {
      result = ""(invalid)"";
    }
    return result;
  }",468.0,476.0,3.0,3.0,9.0,8,4,5,2,0,0,2,2,0,0,,0,0,2,1,1,string
1111,17000,DeleteAnSSTFile,1,leveldb.DBTest.DeleteAnSSTFile,bool leveldb.DBTest.DeleteAnSSTFile (),db\db_test.cc,"bool DeleteAnSSTFile() {
    std::vector<std::string> filenames;
    ASSERT_OK(env_->GetChildren(dbname_, &filenames));
    uint64_t number;
    FileType type;
    for (size_t i = 0; i < filenames.size(); i++) {
      if (ParseFileName(filenames[i], &number, &type) && type == kTableFile) {
        ASSERT_OK(env_->DeleteFile(TableFileName(dbname_, number)));
        return true;
      }
    }
    return false;
  }",478.0,490.0,3.0,4.0,13.0,21,9,22,10,0,4,3,4,0,0,,0,4,0,0,0,bool
1112,17088,RenameLDBToSST,1,leveldb.DBTest.RenameLDBToSST,int leveldb.DBTest.RenameLDBToSST (),db\db_test.cc,"int RenameLDBToSST() {
    std::vector<std::string> filenames;
    ASSERT_OK(env_->GetChildren(dbname_, &filenames));
    uint64_t number;
    FileType type;
    int files_renamed = 0;
    for (size_t i = 0; i < filenames.size(); i++) {
      if (ParseFileName(filenames[i], &number, &type) && type == kTableFile) {
        const std::string from = TableFileName(dbname_, number);
        const std::string to = SSTTableFileName(dbname_, number);
        ASSERT_OK(env_->RenameFile(from, to));
        files_renamed++;
      }
    }
    return files_renamed;
  }",493.0,508.0,3.0,4.0,16.0,25,10,31,13,0,5,3,4,0,0,,0,5,0,0,0,int
1113,17192,_Run,1,leveldb._Test_Empty._Run,void leveldb._Test_Empty._Run (),util\arena_test.cc,"TEST(ArenaTest, Empty) {
  Arena arena;
}",14.0,16.0,1.0,22.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1114,17196,_RunIt,1,leveldb._Test_Empty._RunIt,void leveldb._Test_Empty._RunIt (),db\db_test.cc,"TEST(DBTest, Empty)",511.0,511.0,1.0,19.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1115,17264,_Run,1,leveldb._Test_ReadWrite._Run,void leveldb._Test_ReadWrite._Run (),helpers\memenv\memenv_test.cc,"TEST(MemEnvTest, ReadWrite) {
  WritableFile* writable_file;
  SequentialFile* seq_file;
  RandomAccessFile* rand_file;
  Slice result;
  char scratch[100];

  ASSERT_OK(env_->CreateDir(""/dir""));

  ASSERT_OK(env_->NewWritableFile(""/dir/f"", &writable_file));
  ASSERT_OK(writable_file->Append(""hello ""));
  ASSERT_OK(writable_file->Append(""world""));
  delete writable_file;

  // Read sequentially.
  ASSERT_OK(env_->NewSequentialFile(""/dir/f"", &seq_file));
  ASSERT_OK(seq_file->Read(5, &result, scratch)); // Read ""hello"".
  ASSERT_EQ(0, result.compare(""hello""));
  ASSERT_OK(seq_file->Skip(1));
  ASSERT_OK(seq_file->Read(1000, &result, scratch)); // Read ""world"".
  ASSERT_EQ(0, result.compare(""world""));
  ASSERT_OK(seq_file->Read(1000, &result, scratch)); // Try reading past EOF.
  ASSERT_EQ(0, result.size());
  ASSERT_OK(seq_file->Skip(100)); // Try to skip past end of file.
  ASSERT_OK(seq_file->Read(1000, &result, scratch));
  ASSERT_EQ(0, result.size());
  delete seq_file;

  // Ran...",96.0,136.0,1.0,27.0,41.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1116,17268,_RunIt,1,leveldb._Test_ReadWrite._RunIt,void leveldb._Test_ReadWrite._RunIt (),db\db_test.cc,"TEST(DBTest, ReadWrite)",518.0,518.0,1.0,23.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1117,17405,_Run,1,leveldb._Test_PutDeleteGet._Run,void leveldb._Test_PutDeleteGet._Run (),db\db_test.cc,"TEST(DBTest, PutDeleteGet) {
  do {
    ASSERT_OK(db_->Put(WriteOptions(), ""foo"", ""v1""));
    ASSERT_EQ(""v1"", Get(""foo""));
    ASSERT_OK(db_->Put(WriteOptions(), ""foo"", ""v2""));
    ASSERT_EQ(""v2"", Get(""foo""));
    ASSERT_OK(db_->Delete(WriteOptions(), ""foo""));
    ASSERT_EQ(""NOT_FOUND"", Get(""foo""));
  } while (ChangeOptions());
}",529.0,538.0,1.0,26.0,10.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1118,17409,_RunIt,1,leveldb._Test_PutDeleteGet._RunIt,void leveldb._Test_PutDeleteGet._RunIt (),db\db_test.cc,"TEST(DBTest, PutDeleteGet)",529.0,529.0,1.0,26.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1119,17557,_Run,1,leveldb._Test_GetFromImmutableLayer._Run,void leveldb._Test_GetFromImmutableLayer._Run (),db\db_test.cc,"TEST(DBTest, GetFromImmutableLayer) {
  do {
    Options options = CurrentOptions();
    options.env = env_;
    options.write_buffer_size = 100000;  // Small write buffer
    Reopen(&options);

    ASSERT_OK(Put(""foo"", ""v1""));
    ASSERT_EQ(""v1"", Get(""foo""));

    env_->delay_data_sync_.Release_Store(env_);      // Block sync calls
    Put(""k1"", std::string(100000, 'x'));             // Fill memtable
    Put(""k2"", std::string(100000, 'y'));             // Trigger compaction
    ASSERT_EQ(""v1"", Get(""foo""));
    env_->delay_data_sync_.Release_Store(NULL);      // Release sync calls
  } while (ChangeOptions());
}",540.0,556.0,1.0,35.0,17.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1120,17561,_RunIt,1,leveldb._Test_GetFromImmutableLayer._RunIt,void leveldb._Test_GetFromImmutableLayer._RunIt (),db\db_test.cc,"TEST(DBTest, GetFromImmutableLayer)",540.0,540.0,1.0,35.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1121,17694,_Run,1,leveldb._Test_GetFromVersions._Run,void leveldb._Test_GetFromVersions._Run (),db\db_test.cc,"TEST(DBTest, GetFromVersions) {
  do {
    ASSERT_OK(Put(""foo"", ""v1""));
    dbfull()->TEST_CompactMemTable();
    ASSERT_EQ(""v1"", Get(""foo""));
  } while (ChangeOptions());
}",558.0,564.0,1.0,29.0,7.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1122,17698,_RunIt,1,leveldb._Test_GetFromVersions._RunIt,void leveldb._Test_GetFromVersions._RunIt (),db\db_test.cc,"TEST(DBTest, GetFromVersions)",558.0,558.0,1.0,29.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1123,17769,_Run,1,leveldb._Test_GetMemUsage._Run,void leveldb._Test_GetMemUsage._Run (),db\db_test.cc,"TEST(DBTest, GetMemUsage) {
  do {
    ASSERT_OK(Put(""foo"", ""v1""));
    std::string val;
    ASSERT_TRUE(db_->GetProperty(""leveldb.approximate-memory-usage"", &val));
    int mem_usage = atoi(val.c_str());
    ASSERT_GT(mem_usage, 0);
    ASSERT_LT(mem_usage, 5*1024*1024);
  } while (ChangeOptions());
}",566.0,575.0,1.0,25.0,10.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1124,17773,_RunIt,1,leveldb._Test_GetMemUsage._RunIt,void leveldb._Test_GetMemUsage._RunIt (),db\db_test.cc,"TEST(DBTest, GetMemUsage)",566.0,566.0,1.0,25.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1125,17888,_Run,1,leveldb._Test_GetSnapshot._Run,void leveldb._Test_GetSnapshot._Run (),db\db_test.cc,"TEST(DBTest, GetSnapshot) {
  do {
    // Try with both a short key and a long key
    for (int i = 0; i < 2; i++) {
      std::string key = (i == 0) ? std::string(""foo"") : std::string(200, 'x');
      ASSERT_OK(Put(key, ""v1""));
      const Snapshot* s1 = db_->GetSnapshot();
      ASSERT_OK(Put(key, ""v2""));
      ASSERT_EQ(""v2"", Get(key));
      ASSERT_EQ(""v1"", Get(key, s1));
      dbfull()->TEST_CompactMemTable();
      ASSERT_EQ(""v2"", Get(key));
      ASSERT_EQ(""v1"", Get(key, s1));
      db_->ReleaseSnapshot(s1);
    }
  } while (ChangeOptions());
}",577.0,593.0,1.0,25.0,17.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1126,17892,_RunIt,1,leveldb._Test_GetSnapshot._RunIt,void leveldb._Test_GetSnapshot._RunIt (),db\db_test.cc,"TEST(DBTest, GetSnapshot)",577.0,577.0,1.0,25.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1127,18076,_Run,1,leveldb._Test_GetLevel0Ordering._Run,void leveldb._Test_GetLevel0Ordering._Run (),db\db_test.cc,"TEST(DBTest, GetLevel0Ordering) {
  do {
    // Check that we process level-0 files in correct order.  The code
    // below generates two level-0 files where the earlier one comes
    // before the later one in the level-0 file list since the earlier
    // one has a smaller ""smallest"" key.
    ASSERT_OK(Put(""bar"", ""b""));
    ASSERT_OK(Put(""foo"", ""v1""));
    dbfull()->TEST_CompactMemTable();
    ASSERT_OK(Put(""foo"", ""v2""));
    dbfull()->TEST_CompactMemTable();
    ASSERT_EQ(""v2"", Get(""foo""));
  } while (ChangeOptions());
}",595.0,608.0,1.0,31.0,14.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1128,18080,_RunIt,1,leveldb._Test_GetLevel0Ordering._RunIt,void leveldb._Test_GetLevel0Ordering._RunIt (),db\db_test.cc,"TEST(DBTest, GetLevel0Ordering)",595.0,595.0,1.0,31.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1129,18187,_Run,1,leveldb._Test_GetOrderedByLevels._Run,void leveldb._Test_GetOrderedByLevels._Run (),db\db_test.cc,"TEST(DBTest, GetOrderedByLevels) {
  do {
    ASSERT_OK(Put(""foo"", ""v1""));
    Compact(""a"", ""z"");
    ASSERT_EQ(""v1"", Get(""foo""));
    ASSERT_OK(Put(""foo"", ""v2""));
    ASSERT_EQ(""v2"", Get(""foo""));
    dbfull()->TEST_CompactMemTable();
    ASSERT_EQ(""v2"", Get(""foo""));
  } while (ChangeOptions());
}",610.0,620.0,1.0,32.0,11.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1130,18191,_RunIt,1,leveldb._Test_GetOrderedByLevels._RunIt,void leveldb._Test_GetOrderedByLevels._RunIt (),db\db_test.cc,"TEST(DBTest, GetOrderedByLevels)",610.0,610.0,1.0,32.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1131,18319,_Run,1,leveldb._Test_GetPicksCorrectFile._Run,void leveldb._Test_GetPicksCorrectFile._Run (),db\db_test.cc,"TEST(DBTest, GetPicksCorrectFile) {
  do {
    // Arrange to have multiple files in a non-level-0 level.
    ASSERT_OK(Put(""a"", ""va""));
    Compact(""a"", ""b"");
    ASSERT_OK(Put(""x"", ""vx""));
    Compact(""x"", ""y"");
    ASSERT_OK(Put(""f"", ""vf""));
    Compact(""f"", ""g"");
    ASSERT_EQ(""va"", Get(""a""));
    ASSERT_EQ(""vf"", Get(""f""));
    ASSERT_EQ(""vx"", Get(""x""));
  } while (ChangeOptions());
}",622.0,635.0,1.0,33.0,14.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1132,18323,_RunIt,1,leveldb._Test_GetPicksCorrectFile._RunIt,void leveldb._Test_GetPicksCorrectFile._RunIt (),db\db_test.cc,"TEST(DBTest, GetPicksCorrectFile)",622.0,622.0,1.0,33.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1133,18469,_Run,1,leveldb._Test_GetEncountersEmptyLevel._Run,void leveldb._Test_GetEncountersEmptyLevel._Run (),db\db_test.cc,"TEST(DBTest, GetEncountersEmptyLevel) {
  do {
    // Arrange for the following to happen:
    //   * sstable A in level 0
    //   * nothing in level 1
    //   * sstable B in level 2
    // Then do enough Get() calls to arrange for an automatic compaction
    // of sstable A.  A bug would cause the compaction to be marked as
    // occurring at level 1 (instead of the correct level 0).

    // Step 1: First place sstables in levels 0 and 2
    int compaction_count = 0;
    while (NumTableFilesAtLevel(0) == 0 ||
           NumTableFilesAtLevel(2) == 0) {
      ASSERT_LE(compaction_count, 100) << ""could not fill levels 0 and 2"";
      compaction_count++;
      Put(""a"", ""begin"");
      Put(""z"", ""end"");
      dbfull()->TEST_CompactMemTable();
    }

    // Step 2: clear level 1 if necessary.
    dbfull()->TEST_CompactRange(1, NULL, NULL);
    ASSERT_EQ(NumTableFilesAtLevel(0), 1);
    ASSERT_EQ(NumTableFilesAtLevel(1), 0);
    ASSERT_EQ(NumTableFilesAtLevel(2), 1);

    // Step 3: rea...",637.0,674.0,1.0,37.0,38.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1134,18473,_RunIt,1,leveldb._Test_GetEncountersEmptyLevel._RunIt,void leveldb._Test_GetEncountersEmptyLevel._RunIt (),db\db_test.cc,"TEST(DBTest, GetEncountersEmptyLevel)",637.0,637.0,1.0,37.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1135,18667,_Run,1,leveldb._Test_IterEmpty._Run,void leveldb._Test_IterEmpty._Run (),db\db_test.cc,"TEST(DBTest, IterEmpty) {
  Iterator* iter = db_->NewIterator(ReadOptions());

  iter->SeekToFirst();
  ASSERT_EQ(IterStatus(iter), ""(invalid)"");

  iter->SeekToLast();
  ASSERT_EQ(IterStatus(iter), ""(invalid)"");

  iter->Seek(""foo"");
  ASSERT_EQ(IterStatus(iter), ""(invalid)"");

  delete iter;
}",676.0,689.0,1.0,23.0,14.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1136,18671,_RunIt,1,leveldb._Test_IterEmpty._RunIt,void leveldb._Test_IterEmpty._RunIt (),db\db_test.cc,"TEST(DBTest, IterEmpty)",676.0,676.0,1.0,23.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1137,18780,_Run,1,leveldb._Test_IterSingle._Run,void leveldb._Test_IterSingle._Run (),db\db_test.cc,"TEST(DBTest, IterSingle) {
  ASSERT_OK(Put(""a"", ""va""));
  Iterator* iter = db_->NewIterator(ReadOptions());

  iter->SeekToFirst();
  ASSERT_EQ(IterStatus(iter), ""a->va"");
  iter->Next();
  ASSERT_EQ(IterStatus(iter), ""(invalid)"");
  iter->SeekToFirst();
  ASSERT_EQ(IterStatus(iter), ""a->va"");
  iter->Prev();
  ASSERT_EQ(IterStatus(iter), ""(invalid)"");

  iter->SeekToLast();
  ASSERT_EQ(IterStatus(iter), ""a->va"");
  iter->Next();
  ASSERT_EQ(IterStatus(iter), ""(invalid)"");
  iter->SeekToLast();
  ASSERT_EQ(IterStatus(iter), ""a->va"");
  iter->Prev();
  ASSERT_EQ(IterStatus(iter), ""(invalid)"");

  iter->Seek("""");
  ASSERT_EQ(IterStatus(iter), ""a->va"");
  iter->Next();
  ASSERT_EQ(IterStatus(iter), ""(invalid)"");

  iter->Seek(""a"");
  ASSERT_EQ(IterStatus(iter), ""a->va"");
  iter->Next();
  ASSERT_EQ(IterStatus(iter), ""(invalid)"");

  iter->Seek(""b"");
  ASSERT_EQ(IterStatus(iter), ""(invalid)"");

  delete iter;
}",691.0,727.0,1.0,24.0,37.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1138,18784,_RunIt,1,leveldb._Test_IterSingle._RunIt,void leveldb._Test_IterSingle._RunIt (),db\db_test.cc,"TEST(DBTest, IterSingle)",691.0,691.0,1.0,24.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1139,19141,_Run,1,leveldb._Test_IterMulti._Run,void leveldb._Test_IterMulti._Run (),db\db_test.cc,"TEST(DBTest, IterMulti) {
  ASSERT_OK(Put(""a"", ""va""));
  ASSERT_OK(Put(""b"", ""vb""));
  ASSERT_OK(Put(""c"", ""vc""));
  Iterator* iter = db_->NewIterator(ReadOptions());

  iter->SeekToFirst();
  ASSERT_EQ(IterStatus(iter), ""a->va"");
  iter->Next();
  ASSERT_EQ(IterStatus(iter), ""b->vb"");
  iter->Next();
  ASSERT_EQ(IterStatus(iter), ""c->vc"");
  iter->Next();
  ASSERT_EQ(IterStatus(iter), ""(invalid)"");
  iter->SeekToFirst();
  ASSERT_EQ(IterStatus(iter), ""a->va"");
  iter->Prev();
  ASSERT_EQ(IterStatus(iter), ""(invalid)"");

  iter->SeekToLast();
  ASSERT_EQ(IterStatus(iter), ""c->vc"");
  iter->Prev();
  ASSERT_EQ(IterStatus(iter), ""b->vb"");
  iter->Prev();
  ASSERT_EQ(IterStatus(iter), ""a->va"");
  iter->Prev();
  ASSERT_EQ(IterStatus(iter), ""(invalid)"");
  iter->SeekToLast();
  ASSERT_EQ(IterStatus(iter), ""c->vc"");
  iter->Next();
  ASSERT_EQ(IterStatus(iter), ""(invalid)"");

  iter->Seek("""");
  ASSERT_EQ(IterStatus(iter), ""a->va"");
  iter->Seek(""a"");
  ASSERT_EQ(IterStatus(iter), ""a->va"")...",729.0,810.0,1.0,23.0,82.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1140,19145,_RunIt,1,leveldb._Test_IterMulti._RunIt,void leveldb._Test_IterMulti._RunIt (),db\db_test.cc,"TEST(DBTest, IterMulti)",729.0,729.0,1.0,23.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1141,19963,_Run,1,leveldb._Test_IterSmallAndLargeMix._Run,void leveldb._Test_IterSmallAndLargeMix._Run (),db\db_test.cc,"TEST(DBTest, IterSmallAndLargeMix) {
  ASSERT_OK(Put(""a"", ""va""));
  ASSERT_OK(Put(""b"", std::string(100000, 'b')));
  ASSERT_OK(Put(""c"", ""vc""));
  ASSERT_OK(Put(""d"", std::string(100000, 'd')));
  ASSERT_OK(Put(""e"", std::string(100000, 'e')));

  Iterator* iter = db_->NewIterator(ReadOptions());

  iter->SeekToFirst();
  ASSERT_EQ(IterStatus(iter), ""a->va"");
  iter->Next();
  ASSERT_EQ(IterStatus(iter), ""b->"" + std::string(100000, 'b'));
  iter->Next();
  ASSERT_EQ(IterStatus(iter), ""c->vc"");
  iter->Next();
  ASSERT_EQ(IterStatus(iter), ""d->"" + std::string(100000, 'd'));
  iter->Next();
  ASSERT_EQ(IterStatus(iter), ""e->"" + std::string(100000, 'e'));
  iter->Next();
  ASSERT_EQ(IterStatus(iter), ""(invalid)"");

  iter->SeekToLast();
  ASSERT_EQ(IterStatus(iter), ""e->"" + std::string(100000, 'e'));
  iter->Prev();
  ASSERT_EQ(IterStatus(iter), ""d->"" + std::string(100000, 'd'));
  iter->Prev();
  ASSERT_EQ(IterStatus(iter), ""c->vc"");
  iter->Prev();
  ASSERT_EQ(IterStatus(iter), ""b->"" + ...",812.0,848.0,1.0,34.0,37.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1142,19967,_RunIt,1,leveldb._Test_IterSmallAndLargeMix._RunIt,void leveldb._Test_IterSmallAndLargeMix._RunIt (),db\db_test.cc,"TEST(DBTest, IterSmallAndLargeMix)",812.0,812.0,1.0,34.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1143,20413,_Run,1,leveldb._Test_IterMultiWithDelete._Run,void leveldb._Test_IterMultiWithDelete._Run (),db\db_test.cc,"TEST(DBTest, IterMultiWithDelete) {
  do {
    ASSERT_OK(Put(""a"", ""va""));
    ASSERT_OK(Put(""b"", ""vb""));
    ASSERT_OK(Put(""c"", ""vc""));
    ASSERT_OK(Delete(""b""));
    ASSERT_EQ(""NOT_FOUND"", Get(""b""));

    Iterator* iter = db_->NewIterator(ReadOptions());
    iter->Seek(""c"");
    ASSERT_EQ(IterStatus(iter), ""c->vc"");
    iter->Prev();
    ASSERT_EQ(IterStatus(iter), ""a->va"");
    delete iter;
  } while (ChangeOptions());
}",850.0,865.0,1.0,33.0,16.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1144,20417,_RunIt,1,leveldb._Test_IterMultiWithDelete._RunIt,void leveldb._Test_IterMultiWithDelete._RunIt (),db\db_test.cc,"TEST(DBTest, IterMultiWithDelete)",850.0,850.0,1.0,33.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1145,20590,_Run,1,leveldb._Test_Recover._Run,void leveldb._Test_Recover._Run (),db\db_test.cc,"TEST(DBTest, Recover) {
  do {
    ASSERT_OK(Put(""foo"", ""v1""));
    ASSERT_OK(Put(""baz"", ""v5""));

    Reopen();
    ASSERT_EQ(""v1"", Get(""foo""));

    ASSERT_EQ(""v1"", Get(""foo""));
    ASSERT_EQ(""v5"", Get(""baz""));
    ASSERT_OK(Put(""bar"", ""v2""));
    ASSERT_OK(Put(""foo"", ""v3""));

    Reopen();
    ASSERT_EQ(""v3"", Get(""foo""));
    ASSERT_OK(Put(""foo"", ""v4""));
    ASSERT_EQ(""v4"", Get(""foo""));
    ASSERT_EQ(""v2"", Get(""bar""));
    ASSERT_EQ(""v5"", Get(""baz""));
  } while (ChangeOptions());
}",867.0,887.0,1.0,21.0,21.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1146,20594,_RunIt,1,leveldb._Test_Recover._RunIt,void leveldb._Test_Recover._RunIt (),db\db_test.cc,"TEST(DBTest, Recover)",867.0,867.0,1.0,21.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1147,20841,_Run,1,leveldb._Test_RecoveryWithEmptyLog._Run,void leveldb._Test_RecoveryWithEmptyLog._Run (),db\db_test.cc,"TEST(DBTest, RecoveryWithEmptyLog) {
  do {
    ASSERT_OK(Put(""foo"", ""v1""));
    ASSERT_OK(Put(""foo"", ""v2""));
    Reopen();
    Reopen();
    ASSERT_OK(Put(""foo"", ""v3""));
    Reopen();
    ASSERT_EQ(""v3"", Get(""foo""));
  } while (ChangeOptions());
}",889.0,899.0,1.0,34.0,11.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1148,20845,_RunIt,1,leveldb._Test_RecoveryWithEmptyLog._RunIt,void leveldb._Test_RecoveryWithEmptyLog._RunIt (),db\db_test.cc,"TEST(DBTest, RecoveryWithEmptyLog)",889.0,889.0,1.0,34.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1149,20947,_Run,1,leveldb._Test_RecoverDuringMemtableCompaction._Run,void leveldb._Test_RecoverDuringMemtableCompaction._Run (),db\db_test.cc,"TEST(DBTest, RecoverDuringMemtableCompaction) {
  do {
    Options options = CurrentOptions();
    options.env = env_;
    options.write_buffer_size = 1000000;
    Reopen(&options);

    // Trigger a long memtable compaction and reopen the database during it
    ASSERT_OK(Put(""foo"", ""v1""));                         // Goes to 1st log file
    ASSERT_OK(Put(""big1"", std::string(10000000, 'x')));  // Fills memtable
    ASSERT_OK(Put(""big2"", std::string(1000, 'y')));      // Triggers compaction
    ASSERT_OK(Put(""bar"", ""v2""));                         // Goes to new log file

    Reopen(&options);
    ASSERT_EQ(""v1"", Get(""foo""));
    ASSERT_EQ(""v2"", Get(""bar""));
    ASSERT_EQ(std::string(10000000, 'x'), Get(""big1""));
    ASSERT_EQ(std::string(1000, 'y'), Get(""big2""));
  } while (ChangeOptions());
}",903.0,922.0,1.0,45.0,20.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1150,20951,_RunIt,1,leveldb._Test_RecoverDuringMemtableCompaction._RunIt,void leveldb._Test_RecoverDuringMemtableCompaction._RunIt (),db\db_test.cc,"TEST(DBTest, RecoverDuringMemtableCompaction)",903.0,903.0,1.0,45.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1151,21160,Key,1,leveldb.Key,string leveldb.Key (int),util\bloom_test.cc,"static Slice Key(int i, char* buffer) {
  EncodeFixed32(buffer, i);
  return Slice(buffer, sizeof(uint32_t));
}",16.0,19.0,1.0,1.0,4.0,2,2,5,3,0,0,1,1,0,0,,0,0,4,2,2,Slice
1152,21179,_Run,1,leveldb._Test_MinorCompactionsHappen._Run,void leveldb._Test_MinorCompactionsHappen._Run (),db\db_test.cc,"TEST(DBTest, MinorCompactionsHappen) {
  Options options = CurrentOptions();
  options.write_buffer_size = 10000;
  Reopen(&options);

  const int N = 500;

  int starting_num_tables = TotalTableFiles();
  for (int i = 0; i < N; i++) {
    ASSERT_OK(Put(Key(i), Key(i) + std::string(1000, 'v')));
  }
  int ending_num_tables = TotalTableFiles();
  ASSERT_GT(ending_num_tables, starting_num_tables);

  for (int i = 0; i < N; i++) {
    ASSERT_EQ(Key(i) + std::string(1000, 'v'), Get(Key(i)));
  }

  Reopen();

  for (int i = 0; i < N; i++) {
    ASSERT_EQ(Key(i) + std::string(1000, 'v'), Get(Key(i)));
  }
}",930.0,953.0,1.0,36.0,24.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1153,21183,_RunIt,1,leveldb._Test_MinorCompactionsHappen._RunIt,void leveldb._Test_MinorCompactionsHappen._RunIt (),db\db_test.cc,"TEST(DBTest, MinorCompactionsHappen)",930.0,930.0,1.0,36.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1154,21371,_Run,1,leveldb._Test_RecoverWithLargeLog._Run,void leveldb._Test_RecoverWithLargeLog._Run (),db\db_test.cc,"TEST(DBTest, RecoverWithLargeLog) {
  {
    Options options = CurrentOptions();
    Reopen(&options);
    ASSERT_OK(Put(""big1"", std::string(200000, '1')));
    ASSERT_OK(Put(""big2"", std::string(200000, '2')));
    ASSERT_OK(Put(""small3"", std::string(10, '3')));
    ASSERT_OK(Put(""small4"", std::string(10, '4')));
    ASSERT_EQ(NumTableFilesAtLevel(0), 0);
  }

  // Make sure that if we re-open with a small write buffer size that
  // we flush table files in the middle of a large log file.
  Options options = CurrentOptions();
  options.write_buffer_size = 100000;
  Reopen(&options);
  ASSERT_EQ(NumTableFilesAtLevel(0), 3);
  ASSERT_EQ(std::string(200000, '1'), Get(""big1""));
  ASSERT_EQ(std::string(200000, '2'), Get(""big2""));
  ASSERT_EQ(std::string(10, '3'), Get(""small3""));
  ASSERT_EQ(std::string(10, '4'), Get(""small4""));
  ASSERT_GT(NumTableFilesAtLevel(0), 1);
}",955.0,977.0,1.0,33.0,23.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1155,21375,_RunIt,1,leveldb._Test_RecoverWithLargeLog._RunIt,void leveldb._Test_RecoverWithLargeLog._RunIt (),db\db_test.cc,"TEST(DBTest, RecoverWithLargeLog)",955.0,955.0,1.0,33.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1156,21657,_Run,1,leveldb._Test_CompactionsGenerateMultipleFiles._Run,void leveldb._Test_CompactionsGenerateMultipleFiles._Run (),db\db_test.cc,"TEST(DBTest, CompactionsGenerateMultipleFiles) {
  Options options = CurrentOptions();
  options.write_buffer_size = 100000000;        // Large write buffer
  Reopen(&options);

  Random rnd(301);

  // Write 8MB (80 values, each 100K)
  ASSERT_EQ(NumTableFilesAtLevel(0), 0);
  std::vector<std::string> values;
  for (int i = 0; i < 80; i++) {
    values.push_back(RandomString(&rnd, 100000));
    ASSERT_OK(Put(Key(i), values[i]));
  }

  // Reopening moves updates to level-0
  Reopen(&options);
  dbfull()->TEST_CompactRange(0, NULL, NULL);

  ASSERT_EQ(NumTableFilesAtLevel(0), 0);
  ASSERT_GT(NumTableFilesAtLevel(1), 1);
  for (int i = 0; i < 80; i++) {
    ASSERT_EQ(Get(Key(i)), values[i]);
  }
}",979.0,1003.0,1.0,46.0,25.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1157,21661,_RunIt,1,leveldb._Test_CompactionsGenerateMultipleFiles._RunIt,void leveldb._Test_CompactionsGenerateMultipleFiles._RunIt (),db\db_test.cc,"TEST(DBTest, CompactionsGenerateMultipleFiles)",979.0,979.0,1.0,46.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1158,21857,_Run,1,leveldb._Test_RepeatedWritesToSameKey._Run,void leveldb._Test_RepeatedWritesToSameKey._Run (),db\db_test.cc,"TEST(DBTest, RepeatedWritesToSameKey) {
  Options options = CurrentOptions();
  options.env = env_;
  options.write_buffer_size = 100000;  // Small write buffer
  Reopen(&options);

  // We must have at most one file per level except for level-0,
  // which may have up to kL0_StopWritesTrigger files.
  const int kMaxFiles = config::kNumLevels + config::kL0_StopWritesTrigger;

  Random rnd(301);
  std::string value = RandomString(&rnd, 2 * options.write_buffer_size);
  for (int i = 0; i < 5 * kMaxFiles; i++) {
    Put(""key"", value);
    ASSERT_LE(TotalTableFiles(), kMaxFiles);
    fprintf(stderr, ""after %d: %d files\n"", int(i+1), TotalTableFiles());
  }
}",1005.0,1022.0,1.0,37.0,18.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1159,21861,_RunIt,1,leveldb._Test_RepeatedWritesToSameKey._RunIt,void leveldb._Test_RepeatedWritesToSameKey._RunIt (),db\db_test.cc,"TEST(DBTest, RepeatedWritesToSameKey)",1005.0,1005.0,1.0,37.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1160,21974,_Run,1,leveldb._Test_SparseMerge._Run,void leveldb._Test_SparseMerge._Run (),db\db_test.cc,"TEST(DBTest, SparseMerge) {
  Options options = CurrentOptions();
  options.compression = kNoCompression;
  Reopen(&options);

  FillLevels(""A"", ""Z"");

  // Suppose there is:
  //    small amount of data with prefix A
  //    large amount of data with prefix B
  //    small amount of data with prefix C
  // and that recent updates have made small changes to all three prefixes.
  // Check that we do not do a compaction that merges all of B in one shot.
  const std::string value(1000, 'x');
  Put(""A"", ""va"");
  // Write approximately 100MB of ""B"" values
  for (int i = 0; i < 100000; i++) {
    char key[100];
    snprintf(key, sizeof(key), ""B%010d"", i);
    Put(key, value);
  }
  Put(""C"", ""vc"");
  dbfull()->TEST_CompactMemTable();
  dbfull()->TEST_CompactRange(0, NULL, NULL);

  // Make sparse update
  Put(""A"",    ""va2"");
  Put(""B100"", ""bvalue2"");
  Put(""C"",    ""vc2"");
  dbfull()->TEST_CompactMemTable();

  // Compactions should not cause us to create a situation where
  // a file overl...",1024.0,1062.0,1.0,25.0,39.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1161,21978,_RunIt,1,leveldb._Test_SparseMerge._RunIt,void leveldb._Test_SparseMerge._RunIt (),db\db_test.cc,"TEST(DBTest, SparseMerge)",1024.0,1024.0,1.0,25.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1162,22163,Between,1,leveldb.Between,"bool leveldb.Between (uint64_t,uint64_t,uint64_t)",table\table_test.cc,"static bool Between(uint64_t val, uint64_t low, uint64_t high) {
  bool result = (val >= low) && (val <= high);
  if (!result) {
    fprintf(stderr, ""Value %llu is not in range [%llu, %llu]\n"",
            (unsigned long long)(val),
            (unsigned long long)(low),
            (unsigned long long)(high));
  }
  return result;
}",787.0,796.0,1.0,1.0,10.0,8,6,11,5,0,0,2,2,0,0,,0,0,6,3,3,bool
1163,22199,_Run,1,leveldb._Test_ApproximateSizes._Run,void leveldb._Test_ApproximateSizes._Run (),db\db_test.cc,"TEST(DBTest, ApproximateSizes) {
  do {
    Options options = CurrentOptions();
    options.write_buffer_size = 100000000;        // Large write buffer
    options.compression = kNoCompression;
    DestroyAndReopen();

    ASSERT_TRUE(Between(Size("""", ""xyz""), 0, 0));
    Reopen(&options);
    ASSERT_TRUE(Between(Size("""", ""xyz""), 0, 0));

    // Write 8MB (80 values, each 100K)
    ASSERT_EQ(NumTableFilesAtLevel(0), 0);
    const int N = 80;
    static const int S1 = 100000;
    static const int S2 = 105000;  // Allow some expansion from metadata
    Random rnd(301);
    for (int i = 0; i < N; i++) {
      ASSERT_OK(Put(Key(i), RandomString(&rnd, S1)));
    }

    // 0 because GetApproximateSizes() does not account for memtable space
    ASSERT_TRUE(Between(Size("""", Key(50)), 0, 0));

    if (options.reuse_logs) {
      // Recovery will reuse memtable, and GetApproximateSizes() does not
      // account for memtable usage;
      Reopen(&options);
      ASSERT_TRUE(Between(Size("""", Ke...",1075.0,1131.0,1.0,30.0,57.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1164,22203,_RunIt,1,leveldb._Test_ApproximateSizes._RunIt,void leveldb._Test_ApproximateSizes._RunIt (),db\db_test.cc,"TEST(DBTest, ApproximateSizes)",1075.0,1075.0,1.0,30.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1165,22654,_Run,1,leveldb._Test_ApproximateSizes_MixOfSmallAndLarge._Run,void leveldb._Test_ApproximateSizes_MixOfSmallAndLarge._Run (),db\db_test.cc,"TEST(DBTest, ApproximateSizes_MixOfSmallAndLarge) {
  do {
    Options options = CurrentOptions();
    options.compression = kNoCompression;
    Reopen();

    Random rnd(301);
    std::string big1 = RandomString(&rnd, 100000);
    ASSERT_OK(Put(Key(0), RandomString(&rnd, 10000)));
    ASSERT_OK(Put(Key(1), RandomString(&rnd, 10000)));
    ASSERT_OK(Put(Key(2), big1));
    ASSERT_OK(Put(Key(3), RandomString(&rnd, 10000)));
    ASSERT_OK(Put(Key(4), big1));
    ASSERT_OK(Put(Key(5), RandomString(&rnd, 10000)));
    ASSERT_OK(Put(Key(6), RandomString(&rnd, 300000)));
    ASSERT_OK(Put(Key(7), RandomString(&rnd, 10000)));

    if (options.reuse_logs) {
      // Need to force a memtable compaction since recovery does not do so.
      ASSERT_OK(dbfull()->TEST_CompactMemTable());
    }

    // Check sizes across recovery by reopening a few times
    for (int run = 0; run < 3; run++) {
      Reopen(&options);

      ASSERT_TRUE(Between(Size("""", Key(0)), 0, 0));
      ASSERT_TRUE(Between(Si...",1133.0,1174.0,1.0,49.0,42.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1166,22658,_RunIt,1,leveldb._Test_ApproximateSizes_MixOfSmallAndLarge._RunIt,void leveldb._Test_ApproximateSizes_MixOfSmallAndLarge._RunIt (),db\db_test.cc,"TEST(DBTest, ApproximateSizes_MixOfSmallAndLarge)",1133.0,1133.0,1.0,49.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1167,23123,_Run,1,leveldb._Test_IteratorPinsRef._Run,void leveldb._Test_IteratorPinsRef._Run (),db\db_test.cc,"TEST(DBTest, IteratorPinsRef) {
  Put(""foo"", ""hello"");

  // Get iterator that will yield the current contents of the DB.
  Iterator* iter = db_->NewIterator(ReadOptions());

  // Write to force compactions
  Put(""foo"", ""newvalue1"");
  for (int i = 0; i < 100; i++) {
    ASSERT_OK(Put(Key(i), Key(i) + std::string(100000, 'v'))); // 100K values
  }
  Put(""foo"", ""newvalue2"");

  iter->SeekToFirst();
  ASSERT_TRUE(iter->Valid());
  ASSERT_EQ(""foo"", iter->key().ToString());
  ASSERT_EQ(""hello"", iter->value().ToString());
  iter->Next();
  ASSERT_TRUE(!iter->Valid());
  delete iter;
}",1176.0,1196.0,1.0,29.0,21.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1168,23127,_RunIt,1,leveldb._Test_IteratorPinsRef._RunIt,void leveldb._Test_IteratorPinsRef._RunIt (),db\db_test.cc,"TEST(DBTest, IteratorPinsRef)",1176.0,1176.0,1.0,29.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1169,23324,_Run,1,leveldb._Test_Snapshot._Run,void leveldb._Test_Snapshot._Run (),db\db_test.cc,"TEST(DBTest, Snapshot) {
  do {
    Put(""foo"", ""v1"");
    const Snapshot* s1 = db_->GetSnapshot();
    Put(""foo"", ""v2"");
    const Snapshot* s2 = db_->GetSnapshot();
    Put(""foo"", ""v3"");
    const Snapshot* s3 = db_->GetSnapshot();

    Put(""foo"", ""v4"");
    ASSERT_EQ(""v1"", Get(""foo"", s1));
    ASSERT_EQ(""v2"", Get(""foo"", s2));
    ASSERT_EQ(""v3"", Get(""foo"", s3));
    ASSERT_EQ(""v4"", Get(""foo""));

    db_->ReleaseSnapshot(s3);
    ASSERT_EQ(""v1"", Get(""foo"", s1));
    ASSERT_EQ(""v2"", Get(""foo"", s2));
    ASSERT_EQ(""v4"", Get(""foo""));

    db_->ReleaseSnapshot(s1);
    ASSERT_EQ(""v2"", Get(""foo"", s2));
    ASSERT_EQ(""v4"", Get(""foo""));

    db_->ReleaseSnapshot(s2);
    ASSERT_EQ(""v4"", Get(""foo""));
  } while (ChangeOptions());
}",1198.0,1225.0,1.0,22.0,28.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1170,23328,_RunIt,1,leveldb._Test_Snapshot._RunIt,void leveldb._Test_Snapshot._RunIt (),db\db_test.cc,"TEST(DBTest, Snapshot)",1198.0,1198.0,1.0,22.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1171,23592,_Run,1,leveldb._Test_HiddenValuesAreRemoved._Run,void leveldb._Test_HiddenValuesAreRemoved._Run (),db\db_test.cc,"TEST(DBTest, HiddenValuesAreRemoved) {
  do {
    Random rnd(301);
    FillLevels(""a"", ""z"");

    std::string big = RandomString(&rnd, 50000);
    Put(""foo"", big);
    Put(""pastfoo"", ""v"");
    const Snapshot* snapshot = db_->GetSnapshot();
    Put(""foo"", ""tiny"");
    Put(""pastfoo2"", ""v2"");        // Advance sequence number one more

    ASSERT_OK(dbfull()->TEST_CompactMemTable());
    ASSERT_GT(NumTableFilesAtLevel(0), 0);

    ASSERT_EQ(big, Get(""foo"", snapshot));
    ASSERT_TRUE(Between(Size("""", ""pastfoo""), 50000, 60000));
    db_->ReleaseSnapshot(snapshot);
    ASSERT_EQ(AllEntriesFor(""foo""), ""[ tiny, "" + big + "" ]"");
    Slice x(""x"");
    dbfull()->TEST_CompactRange(0, NULL, &x);
    ASSERT_EQ(AllEntriesFor(""foo""), ""[ tiny ]"");
    ASSERT_EQ(NumTableFilesAtLevel(0), 0);
    ASSERT_GE(NumTableFilesAtLevel(1), 1);
    dbfull()->TEST_CompactRange(1, NULL, &x);
    ASSERT_EQ(AllEntriesFor(""foo""), ""[ tiny ]"");

    ASSERT_TRUE(Between(Size("""", ""pastfoo""), 0, 1000));
  } while (Change...",1227.0,1256.0,1.0,36.0,30.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1172,23596,_RunIt,1,leveldb._Test_HiddenValuesAreRemoved._RunIt,void leveldb._Test_HiddenValuesAreRemoved._RunIt (),db\db_test.cc,"TEST(DBTest, HiddenValuesAreRemoved)",1227.0,1227.0,1.0,36.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1173,23878,_Run,1,leveldb._Test_DeletionMarkers1._Run,void leveldb._Test_DeletionMarkers1._Run (),db\db_test.cc,"TEST(DBTest, DeletionMarkers1) {
  Put(""foo"", ""v1"");
  ASSERT_OK(dbfull()->TEST_CompactMemTable());
  const int last = config::kMaxMemCompactLevel;
  ASSERT_EQ(NumTableFilesAtLevel(last), 1);   // foo => v1 is now in last level

  // Place a table at level last-1 to prevent merging with preceding mutation
  Put(""a"", ""begin"");
  Put(""z"", ""end"");
  dbfull()->TEST_CompactMemTable();
  ASSERT_EQ(NumTableFilesAtLevel(last), 1);
  ASSERT_EQ(NumTableFilesAtLevel(last-1), 1);

  Delete(""foo"");
  Put(""foo"", ""v2"");
  ASSERT_EQ(AllEntriesFor(""foo""), ""[ v2, DEL, v1 ]"");
  ASSERT_OK(dbfull()->TEST_CompactMemTable());  // Moves to level last-2
  ASSERT_EQ(AllEntriesFor(""foo""), ""[ v2, DEL, v1 ]"");
  Slice z(""z"");
  dbfull()->TEST_CompactRange(last-2, NULL, &z);
  // DEL eliminated, but v1 remains because we aren't compacting that level
  // (DEL can be eliminated because v2 hides v1).
  ASSERT_EQ(AllEntriesFor(""foo""), ""[ v2, v1 ]"");
  dbfull()->TEST_CompactRange(last-1, NULL, NULL);
  // Merging l...",1258.0,1285.0,1.0,30.0,28.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1174,23882,_RunIt,1,leveldb._Test_DeletionMarkers1._RunIt,void leveldb._Test_DeletionMarkers1._RunIt (),db\db_test.cc,"TEST(DBTest, DeletionMarkers1)",1258.0,1258.0,1.0,30.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1175,24128,_Run,1,leveldb._Test_DeletionMarkers2._Run,void leveldb._Test_DeletionMarkers2._Run (),db\db_test.cc,"TEST(DBTest, DeletionMarkers2) {
  Put(""foo"", ""v1"");
  ASSERT_OK(dbfull()->TEST_CompactMemTable());
  const int last = config::kMaxMemCompactLevel;
  ASSERT_EQ(NumTableFilesAtLevel(last), 1);   // foo => v1 is now in last level

  // Place a table at level last-1 to prevent merging with preceding mutation
  Put(""a"", ""begin"");
  Put(""z"", ""end"");
  dbfull()->TEST_CompactMemTable();
  ASSERT_EQ(NumTableFilesAtLevel(last), 1);
  ASSERT_EQ(NumTableFilesAtLevel(last-1), 1);

  Delete(""foo"");
  ASSERT_EQ(AllEntriesFor(""foo""), ""[ DEL, v1 ]"");
  ASSERT_OK(dbfull()->TEST_CompactMemTable());  // Moves to level last-2
  ASSERT_EQ(AllEntriesFor(""foo""), ""[ DEL, v1 ]"");
  dbfull()->TEST_CompactRange(last-2, NULL, NULL);
  // DEL kept: ""last"" file overlaps
  ASSERT_EQ(AllEntriesFor(""foo""), ""[ DEL, v1 ]"");
  dbfull()->TEST_CompactRange(last-1, NULL, NULL);
  // Merging last-1 w/ last, so we are the base level for ""foo"", so
  // DEL is removed.  (as is v1).
  ASSERT_EQ(AllEntriesFor(""foo""), ""[ ]"");
}",1287.0,1311.0,1.0,30.0,25.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1176,24132,_RunIt,1,leveldb._Test_DeletionMarkers2._RunIt,void leveldb._Test_DeletionMarkers2._RunIt (),db\db_test.cc,"TEST(DBTest, DeletionMarkers2)",1287.0,1287.0,1.0,30.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1177,24371,_Run,1,leveldb._Test_OverlapInLevel0._Run,void leveldb._Test_OverlapInLevel0._Run (),db\db_test.cc,"TEST(DBTest, OverlapInLevel0) {
  do {
    ASSERT_EQ(config::kMaxMemCompactLevel, 2) << ""Fix test to match config"";

    // Fill levels 1 and 2 to disable the pushing of new memtables to levels > 0.
    ASSERT_OK(Put(""100"", ""v100""));
    ASSERT_OK(Put(""999"", ""v999""));
    dbfull()->TEST_CompactMemTable();
    ASSERT_OK(Delete(""100""));
    ASSERT_OK(Delete(""999""));
    dbfull()->TEST_CompactMemTable();
    ASSERT_EQ(""0,1,1"", FilesPerLevel());

    // Make files spanning the following ranges in level-0:
    //  files[0]  200 .. 900
    //  files[1]  300 .. 500
    // Note that files are sorted by smallest key.
    ASSERT_OK(Put(""300"", ""v300""));
    ASSERT_OK(Put(""500"", ""v500""));
    dbfull()->TEST_CompactMemTable();
    ASSERT_OK(Put(""200"", ""v200""));
    ASSERT_OK(Put(""600"", ""v600""));
    ASSERT_OK(Put(""900"", ""v900""));
    dbfull()->TEST_CompactMemTable();
    ASSERT_EQ(""2,1,1"", FilesPerLevel());

    // Compact away the placeholder files we created initially
    dbfull()->TEST_Compac...",1313.0,1352.0,1.0,29.0,40.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1178,24375,_RunIt,1,leveldb._Test_OverlapInLevel0._RunIt,void leveldb._Test_OverlapInLevel0._RunIt (),db\db_test.cc,"TEST(DBTest, OverlapInLevel0)",1313.0,1313.0,1.0,29.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1179,24711,_Run,1,leveldb._Test_L0_CompactionBug_Issue44_a._Run,void leveldb._Test_L0_CompactionBug_Issue44_a._Run (),db\db_test.cc,"TEST(DBTest, L0_CompactionBug_Issue44_a) {
  Reopen();
  ASSERT_OK(Put(""b"", ""v""));
  Reopen();
  ASSERT_OK(Delete(""b""));
  ASSERT_OK(Delete(""a""));
  Reopen();
  ASSERT_OK(Delete(""a""));
  Reopen();
  ASSERT_OK(Put(""a"", ""v""));
  Reopen();
  Reopen();
  ASSERT_EQ(""(a->v)"", Contents());
  DelayMilliseconds(1000);  // Wait for compaction to finish
  ASSERT_EQ(""(a->v)"", Contents());
}",1354.0,1369.0,1.0,40.0,16.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1180,24715,_RunIt,1,leveldb._Test_L0_CompactionBug_Issue44_a._RunIt,void leveldb._Test_L0_CompactionBug_Issue44_a._RunIt (),db\db_test.cc,"TEST(DBTest, L0_CompactionBug_Issue44_a)",1354.0,1354.0,1.0,40.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1181,24869,_Run,1,leveldb._Test_L0_CompactionBug_Issue44_b._Run,void leveldb._Test_L0_CompactionBug_Issue44_b._Run (),db\db_test.cc,"TEST(DBTest, L0_CompactionBug_Issue44_b) {
  Reopen();
  Put("""","""");
  Reopen();
  Delete(""e"");
  Put("""","""");
  Reopen();
  Put(""c"", ""cv"");
  Reopen();
  Put("""","""");
  Reopen();
  Put("""","""");
  DelayMilliseconds(1000);  // Wait for compaction to finish
  Reopen();
  Put(""d"",""dv"");
  Reopen();
  Put("""","""");
  Reopen();
  Delete(""d"");
  Delete(""b"");
  Reopen();
  ASSERT_EQ(""(->)(c->cv)"", Contents());
  DelayMilliseconds(1000);  // Wait for compaction to finish
  ASSERT_EQ(""(->)(c->cv)"", Contents());
}",1371.0,1395.0,1.0,40.0,25.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1182,24873,_RunIt,1,leveldb._Test_L0_CompactionBug_Issue44_b._RunIt,void leveldb._Test_L0_CompactionBug_Issue44_b._RunIt (),db\db_test.cc,"TEST(DBTest, L0_CompactionBug_Issue44_b)",1371.0,1371.0,1.0,40.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1183,24976,_Run,1,leveldb._Test_ComparatorCheck._Run,void leveldb._Test_ComparatorCheck._Run (),db\db_test.cc,"TEST(DBTest, ComparatorCheck) {
  class NewComparator : public Comparator {
   public:
    virtual const char* Name() const { return ""leveldb.NewComparator""; }
    virtual int Compare(const Slice& a, const Slice& b) const {
      return BytewiseComparator()->Compare(a, b);
    }
    virtual void FindShortestSeparator(std::string* s, const Slice& l) const {
      BytewiseComparator()->FindShortestSeparator(s, l);
    }
    virtual void FindShortSuccessor(std::string* key) const {
      BytewiseComparator()->FindShortSuccessor(key);
    }
  };
  NewComparator cmp;
  Options new_options = CurrentOptions();
  new_options.comparator = &cmp;
  Status s = TryReopen(&new_options);
  ASSERT_TRUE(!s.ok());
  ASSERT_TRUE(s.ToString().find(""comparator"") != std::string::npos)
      << s.ToString();
}",1397.0,1418.0,1.0,29.0,22.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1184,24980,_RunIt,1,leveldb._Test_ComparatorCheck._RunIt,void leveldb._Test_ComparatorCheck._RunIt (),db\db_test.cc,"TEST(DBTest, ComparatorCheck)",1397.0,1397.0,1.0,29.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1185,25083,_Run,1,leveldb._Test_CustomComparator._Run,void leveldb._Test_CustomComparator._Run (),db\db_test.cc,"TEST(DBTest, CustomComparator) {
  class NumberComparator : public Comparator {
   public:
    virtual const char* Name() const { return ""test.NumberComparator""; }
    virtual int Compare(const Slice& a, const Slice& b) const {
      return ToNumber(a) - ToNumber(b);
    }
    virtual void FindShortestSeparator(std::string* s, const Slice& l) const {
      ToNumber(*s);     // Check format
      ToNumber(l);      // Check format
    }
    virtual void FindShortSuccessor(std::string* key) const {
      ToNumber(*key);   // Check format
    }
   private:
    static int ToNumber(const Slice& x) {
      // Check that there are no extra characters.
      ASSERT_TRUE(x.size() >= 2 && x[0] == '[' && x[x.size()-1] == ']')
          << EscapeString(x);
      int val;
      char ignored;
      ASSERT_TRUE(sscanf(x.ToString().c_str(), ""[%i]%c"", &val, &ignored) == 1)
          << EscapeString(x);
      return val;
    }
  };
  NumberComparator cmp;
  Options new_options = CurrentOptions();
  ne...",1420.0,1473.0,1.0,30.0,54.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1186,25087,_RunIt,1,leveldb._Test_CustomComparator._RunIt,void leveldb._Test_CustomComparator._RunIt (),db\db_test.cc,"TEST(DBTest, CustomComparator)",1420.0,1420.0,1.0,30.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1187,25358,_Run,1,leveldb._Test_ManualCompaction._Run,void leveldb._Test_ManualCompaction._Run (),db\db_test.cc,"TEST(DBTest, ManualCompaction) {
  ASSERT_EQ(config::kMaxMemCompactLevel, 2)
      << ""Need to update this test to match kMaxMemCompactLevel"";

  MakeTables(3, ""p"", ""q"");
  ASSERT_EQ(""1,1,1"", FilesPerLevel());

  // Compaction range falls before files
  Compact("""", ""c"");
  ASSERT_EQ(""1,1,1"", FilesPerLevel());

  // Compaction range falls after files
  Compact(""r"", ""z"");
  ASSERT_EQ(""1,1,1"", FilesPerLevel());

  // Compaction range overlaps files
  Compact(""p1"", ""p9"");
  ASSERT_EQ(""0,0,1"", FilesPerLevel());

  // Populate a different range
  MakeTables(3, ""c"", ""e"");
  ASSERT_EQ(""1,1,2"", FilesPerLevel());

  // Compact just the new range
  Compact(""b"", ""f"");
  ASSERT_EQ(""0,0,2"", FilesPerLevel());

  // Compact all
  MakeTables(1, ""a"", ""z"");
  ASSERT_EQ(""0,1,2"", FilesPerLevel());
  db_->CompactRange(NULL, NULL);
  ASSERT_EQ(""0,0,1"", FilesPerLevel());
}",1475.0,1507.0,1.0,30.0,33.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1188,25362,_RunIt,1,leveldb._Test_ManualCompaction._RunIt,void leveldb._Test_ManualCompaction._RunIt (),db\db_test.cc,"TEST(DBTest, ManualCompaction)",1475.0,1475.0,1.0,30.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1189,25577,_Run,1,leveldb._Test_DBOpen_Options._Run,void leveldb._Test_DBOpen_Options._Run (),db\db_test.cc,"TEST(DBTest, DBOpen_Options) {
  std::string dbname = test::TmpDir() + ""/db_options_test"";
  DestroyDB(dbname, Options());

  // Does not exist, and create_if_missing == false: error
  DB* db = NULL;
  Options opts;
  opts.create_if_missing = false;
  Status s = DB::Open(opts, dbname, &db);
  ASSERT_TRUE(strstr(s.ToString().c_str(), ""does not exist"") != NULL);
  ASSERT_TRUE(db == NULL);

  // Does not exist, and create_if_missing == true: OK
  opts.create_if_missing = true;
  s = DB::Open(opts, dbname, &db);
  ASSERT_OK(s);
  ASSERT_TRUE(db != NULL);

  delete db;
  db = NULL;

  // Does exist, and error_if_exists == true: error
  opts.create_if_missing = false;
  opts.error_if_exists = true;
  s = DB::Open(opts, dbname, &db);
  ASSERT_TRUE(strstr(s.ToString().c_str(), ""exists"") != NULL);
  ASSERT_TRUE(db == NULL);

  // Does exist, and error_if_exists == false: OK
  opts.create_if_missing = true;
  opts.error_if_exists = false;
  s = DB::Open(opts, dbname, &db);
  ASSERT_OK(s);
  A...",1509.0,1546.0,1.0,28.0,38.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1190,25581,_RunIt,1,leveldb._Test_DBOpen_Options._RunIt,void leveldb._Test_DBOpen_Options._RunIt (),db\db_test.cc,"TEST(DBTest, DBOpen_Options)",1509.0,1509.0,1.0,28.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1191,25856,_Run,1,leveldb._Test_Locking._Run,void leveldb._Test_Locking._Run (),db\db_test.cc,"TEST(DBTest, Locking) {
  DB* db2 = NULL;
  Status s = DB::Open(CurrentOptions(), dbname_, &db2);
  ASSERT_TRUE(!s.ok()) << ""Locking did not prevent re-opening db"";
}",1548.0,1552.0,1.0,21.0,5.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1192,25860,_RunIt,1,leveldb._Test_Locking._RunIt,void leveldb._Test_Locking._RunIt (),db\db_test.cc,"TEST(DBTest, Locking)",1548.0,1548.0,1.0,21.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1193,25930,_Run,1,leveldb._Test_NoSpace._Run,void leveldb._Test_NoSpace._Run (),db\db_test.cc,"TEST(DBTest, NoSpace) {
  Options options = CurrentOptions();
  options.env = env_;
  Reopen(&options);

  ASSERT_OK(Put(""foo"", ""v1""));
  ASSERT_EQ(""v1"", Get(""foo""));
  Compact(""a"", ""z"");
  const int num_files = CountFiles();
  env_->no_space_.Release_Store(env_);   // Force out-of-space errors
  for (int i = 0; i < 10; i++) {
    for (int level = 0; level < config::kNumLevels-1; level++) {
      dbfull()->TEST_CompactRange(level, NULL, NULL);
    }
  }
  env_->no_space_.Release_Store(NULL);
  ASSERT_LT(CountFiles(), num_files + 3);
}",1555.0,1572.0,1.0,21.0,18.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1194,25934,_RunIt,1,leveldb._Test_NoSpace._RunIt,void leveldb._Test_NoSpace._RunIt (),db\db_test.cc,"TEST(DBTest, NoSpace)",1555.0,1555.0,1.0,21.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1195,26084,_Run,1,leveldb._Test_NonWritableFileSystem._Run,void leveldb._Test_NonWritableFileSystem._Run (),db\db_test.cc,"TEST(DBTest, NonWritableFileSystem) {
  Options options = CurrentOptions();
  options.write_buffer_size = 1000;
  options.env = env_;
  Reopen(&options);
  ASSERT_OK(Put(""foo"", ""v1""));
  env_->non_writable_.Release_Store(env_);  // Force errors for new files
  std::string big(100000, 'x');
  int errors = 0;
  for (int i = 0; i < 20; i++) {
    fprintf(stderr, ""iter %d; errors %d\n"", i, errors);
    if (!Put(""foo"", big).ok()) {
      errors++;
      DelayMilliseconds(100);
    }
  }
  ASSERT_GT(errors, 0);
  env_->non_writable_.Release_Store(NULL);
}",1574.0,1592.0,1.0,35.0,19.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1196,26088,_RunIt,1,leveldb._Test_NonWritableFileSystem._RunIt,void leveldb._Test_NonWritableFileSystem._RunIt (),db\db_test.cc,"TEST(DBTest, NonWritableFileSystem)",1574.0,1574.0,1.0,35.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1197,26219,_Run,1,leveldb._Test_WriteSyncError._Run,void leveldb._Test_WriteSyncError._Run (),db\db_test.cc,"TEST(DBTest, WriteSyncError) {
  // Check that log sync errors cause the DB to disallow future writes.

  // (a) Cause log sync calls to fail
  Options options = CurrentOptions();
  options.env = env_;
  Reopen(&options);
  env_->data_sync_error_.Release_Store(env_);

  // (b) Normal write should succeed
  WriteOptions w;
  ASSERT_OK(db_->Put(w, ""k1"", ""v1""));
  ASSERT_EQ(""v1"", Get(""k1""));

  // (c) Do a sync write; should fail
  w.sync = true;
  ASSERT_TRUE(!db_->Put(w, ""k2"", ""v2"").ok());
  ASSERT_EQ(""v1"", Get(""k1""));
  ASSERT_EQ(""NOT_FOUND"", Get(""k2""));

  // (d) make sync behave normally
  env_->data_sync_error_.Release_Store(NULL);

  // (e) Do a non-sync write; should fail
  w.sync = false;
  ASSERT_TRUE(!db_->Put(w, ""k3"", ""v3"").ok());
  ASSERT_EQ(""v1"", Get(""k1""));
  ASSERT_EQ(""NOT_FOUND"", Get(""k2""));
  ASSERT_EQ(""NOT_FOUND"", Get(""k3""));
}",1594.0,1623.0,1.0,28.0,30.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1198,26223,_RunIt,1,leveldb._Test_WriteSyncError._RunIt,void leveldb._Test_WriteSyncError._RunIt (),db\db_test.cc,"TEST(DBTest, WriteSyncError)",1594.0,1594.0,1.0,28.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1199,26473,_Run,1,leveldb._Test_ManifestWriteError._Run,void leveldb._Test_ManifestWriteError._Run (),db\db_test.cc,"TEST(DBTest, ManifestWriteError) {
  // Test for the following problem:
  // (a) Compaction produces file F
  // (b) Log record containing F is written to MANIFEST file, but Sync() fails
  // (c) GC deletes F
  // (d) After reopening DB, reads fail since deleted F is named in log record

  // We iterate twice.  In the second iteration, everything is the
  // same except the log record never makes it to the MANIFEST file.
  for (int iter = 0; iter < 2; iter++) {
    port::AtomicPointer* error_type = (iter == 0)
        ? &env_->manifest_sync_error_
        : &env_->manifest_write_error_;

    // Insert foo=>bar mapping
    Options options = CurrentOptions();
    options.env = env_;
    options.create_if_missing = true;
    options.error_if_exists = false;
    DestroyAndReopen(&options);
    ASSERT_OK(Put(""foo"", ""bar""));
    ASSERT_EQ(""bar"", Get(""foo""));

    // Memtable compaction (will succeed)
    dbfull()->TEST_CompactMemTable();
    ASSERT_EQ(""bar"", Get(""foo""));
    const int las...",1625.0,1664.0,1.0,32.0,40.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1200,26477,_RunIt,1,leveldb._Test_ManifestWriteError._RunIt,void leveldb._Test_ManifestWriteError._RunIt (),db\db_test.cc,"TEST(DBTest, ManifestWriteError)",1625.0,1625.0,1.0,32.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1201,26696,_Run,1,leveldb._Test_MissingSSTFile._Run,void leveldb._Test_MissingSSTFile._Run (),db\db_test.cc,"TEST(DBTest, MissingSSTFile) {
  ASSERT_OK(Put(""foo"", ""bar""));
  ASSERT_EQ(""bar"", Get(""foo""));

  // Dump the memtable to disk.
  dbfull()->TEST_CompactMemTable();
  ASSERT_EQ(""bar"", Get(""foo""));

  Close();
  ASSERT_TRUE(DeleteAnSSTFile());
  Options options = CurrentOptions();
  options.paranoid_checks = true;
  Status s = TryReopen(&options);
  ASSERT_TRUE(!s.ok());
  ASSERT_TRUE(s.ToString().find(""issing"") != std::string::npos)
      << s.ToString();
}",1666.0,1682.0,1.0,28.0,17.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1202,26700,_RunIt,1,leveldb._Test_MissingSSTFile._RunIt,void leveldb._Test_MissingSSTFile._RunIt (),db\db_test.cc,"TEST(DBTest, MissingSSTFile)",1666.0,1666.0,1.0,28.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1203,26876,_Run,1,leveldb._Test_StillReadSST._Run,void leveldb._Test_StillReadSST._Run (),db\db_test.cc,"TEST(DBTest, StillReadSST) {
  ASSERT_OK(Put(""foo"", ""bar""));
  ASSERT_EQ(""bar"", Get(""foo""));

  // Dump the memtable to disk.
  dbfull()->TEST_CompactMemTable();
  ASSERT_EQ(""bar"", Get(""foo""));
  Close();
  ASSERT_GT(RenameLDBToSST(), 0);
  Options options = CurrentOptions();
  options.paranoid_checks = true;
  Status s = TryReopen(&options);
  ASSERT_TRUE(s.ok());
  ASSERT_EQ(""bar"", Get(""foo""));
}",1684.0,1698.0,1.0,26.0,15.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1204,26880,_RunIt,1,leveldb._Test_StillReadSST._RunIt,void leveldb._Test_StillReadSST._RunIt (),db\db_test.cc,"TEST(DBTest, StillReadSST)",1684.0,1684.0,1.0,26.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1205,27041,_Run,1,leveldb._Test_FilesDeletedAfterCompaction._Run,void leveldb._Test_FilesDeletedAfterCompaction._Run (),db\db_test.cc,"TEST(DBTest, FilesDeletedAfterCompaction) {
  ASSERT_OK(Put(""foo"", ""v2""));
  Compact(""a"", ""z"");
  const int num_files = CountFiles();
  for (int i = 0; i < 10; i++) {
    ASSERT_OK(Put(""foo"", ""v2""));
    Compact(""a"", ""z"");
  }
  ASSERT_EQ(CountFiles(), num_files);
}",1700.0,1709.0,1.0,41.0,10.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1206,27045,_RunIt,1,leveldb._Test_FilesDeletedAfterCompaction._RunIt,void leveldb._Test_FilesDeletedAfterCompaction._RunIt (),db\db_test.cc,"TEST(DBTest, FilesDeletedAfterCompaction)",1700.0,1700.0,1.0,41.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1207,27145,_Run,1,leveldb._Test_BloomFilter._Run,void leveldb._Test_BloomFilter._Run (),db\db_test.cc,"TEST(DBTest, BloomFilter) {
  env_->count_random_reads_ = true;
  Options options = CurrentOptions();
  options.env = env_;
  options.block_cache = NewLRUCache(0);  // Prevent cache hits
  options.filter_policy = NewBloomFilterPolicy(10);
  Reopen(&options);

  // Populate multiple layers
  const int N = 10000;
  for (int i = 0; i < N; i++) {
    ASSERT_OK(Put(Key(i), Key(i)));
  }
  Compact(""a"", ""z"");
  for (int i = 0; i < N; i += 100) {
    ASSERT_OK(Put(Key(i), Key(i)));
  }
  dbfull()->TEST_CompactMemTable();

  // Prevent auto compactions triggered by seeks
  env_->delay_data_sync_.Release_Store(env_);

  // Lookup present keys.  Should rarely read from small sstable.
  env_->random_read_counter_.Reset();
  for (int i = 0; i < N; i++) {
    ASSERT_EQ(Key(i), Get(Key(i)));
  }
  int reads = env_->random_read_counter_.Read();
  fprintf(stderr, ""%d present => %d reads\n"", N, reads);
  ASSERT_GE(reads, N);
  ASSERT_LE(reads, N + 2*N/100);

  // Lookup present keys.  Should rarely r...",1711.0,1756.0,1.0,25.0,46.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1208,27149,_RunIt,1,leveldb._Test_BloomFilter._RunIt,void leveldb._Test_BloomFilter._RunIt (),db\db_test.cc,"TEST(DBTest, BloomFilter)",1711.0,1711.0,1.0,25.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1209,27495,MTThreadBody,1,leveldb.anonymous_namespace_17.MTThreadBody,void leveldb.anonymous_namespace_17.MTThreadBody (void*),db\db_test.cc,"static void MTThreadBody(void* arg) {
  MTThread* t = reinterpret_cast<MTThread*>(arg);
  int id = t->id;
  DB* db = t->state->test->db_;
  uintptr_t counter = 0;
  fprintf(stderr, ""... starting thread %d\n"", id);
  Random rnd(1000 + id);
  std::string value;
  char valbuf[1500];
  while (t->state->stop.Acquire_Load() == NULL) {
    t->state->counter[id].Release_Store(reinterpret_cast<void*>(counter));

    int key = rnd.Uniform(kNumKeys);
    char keybuf[20];
    snprintf(keybuf, sizeof(keybuf), ""%016d"", key);

    if (rnd.OneIn(2)) {
      // Write values of the form <key, my id, counter>.
      // We add some padding for force compactions.
      snprintf(valbuf, sizeof(valbuf), ""%d.%d.%-1000d"",
               key, id, static_cast<int>(counter));
      ASSERT_OK(db->Put(WriteOptions(), Slice(keybuf), Slice(valbuf)));
    } else {
      // Read a value and verify that it matches the pattern written above.
      Status s = db->Get(ReadOptions(), Slice(keybuf), &value);
      if (s.I...",1777.0,1820.0,1.0,6.0,44.0,35,10,39,13,0,5,3,4,1,0,,0,5,2,1,1,void
1210,27800,_Run,1,leveldb._Test_MultiThreaded._Run,void leveldb._Test_MultiThreaded._Run (),db\db_test.cc,"TEST(DBTest, MultiThreaded) {
  do {
    // Initialize state
    MTState mt;
    mt.test = this;
    mt.stop.Release_Store(0);
    for (int id = 0; id < kNumThreads; id++) {
      mt.counter[id].Release_Store(0);
      mt.thread_done[id].Release_Store(0);
    }

    // Start threads
    MTThread thread[kNumThreads];
    for (int id = 0; id < kNumThreads; id++) {
      thread[id].state = &mt;
      thread[id].id = id;
      env_->StartThread(MTThreadBody, &thread[id]);
    }

    // Let them run for a while
    DelayMilliseconds(kTestSeconds * 1000);

    // Stop the threads and wait for them to finish
    mt.stop.Release_Store(&mt);
    for (int id = 0; id < kNumThreads; id++) {
      while (mt.thread_done[id].Acquire_Load() == NULL) {
        DelayMilliseconds(100);
      }
    }
  } while (ChangeOptions());
}",1824.0,1854.0,1.0,27.0,31.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1211,27804,_RunIt,1,leveldb._Test_MultiThreaded._RunIt,void leveldb._Test_MultiThreaded._RunIt (),db\db_test.cc,"TEST(DBTest, MultiThreaded)",1824.0,1824.0,1.0,27.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1212,27958,ModelDB,1,leveldb.ModelDB.ModelDB,ANY leveldb.ModelDB.ModelDB (Options),db\db_test.cc,explicit ModelDB(const Options& options): options_(options) { },1867.0,1867.0,3.0,65.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
1213,27963,~ModelDB,1,leveldb.ModelDB.~ModelDB,ANY leveldb.ModelDB.~ModelDB (),db\db_test.cc,~ModelDB() { },1868.0,1868.0,3.0,16.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
1214,27967,Put,1,leveldb.ModelDB.Put,"Status leveldb.ModelDB.Put (WriteOptions,Slice,Slice)",db\db_test.cc,"virtual Status Put(const WriteOptions& o, const Slice& k, const Slice& v) {
    return DB::Put(o, k, v);
  }",1869.0,1871.0,3.0,3.0,3.0,1,1,4,4,0,0,1,1,0,0,,0,0,6,3,3,Status
1215,27982,Delete,1,leveldb.ModelDB.Delete,"Status leveldb.ModelDB.Delete (WriteOptions,Slice)",db\db_test.cc,"virtual Status Delete(const WriteOptions& o, const Slice& key) {
    return DB::Delete(o, key);
  }",1872.0,1874.0,3.0,3.0,3.0,1,1,3,3,0,0,1,1,0,0,,0,0,4,2,2,Status
1216,27995,Get,1,leveldb.ModelDB.Get,"Status leveldb.ModelDB.Get (ReadOptions,Slice,ANY*)",db\db_test.cc,"virtual Status Get(const ReadOptions& options,
                     const Slice& key, std::string* value) {
    assert(false);      // Not implemented
    return Status::NotFound(key);
  }",1875.0,1879.0,3.0,3.0,5.0,1,1,2,2,0,1,1,1,0,1,,0,0,6,3,3,Status
1217,28010,NewIterator,1,leveldb.ModelDB.NewIterator,Iterator leveldb.ModelDB.NewIterator (ReadOptions),db\db_test.cc,"virtual Iterator* NewIterator(const ReadOptions& options) {
    if (options.snapshot == NULL) {
      KVMap* saved = new KVMap;
      *saved = map_;
      return new ModelIter(saved, true);
    } else {
      const KVMap* snapshot_state =
          &(reinterpret_cast<const ModelSnapshot*>(options.snapshot)->map_);
      return new ModelIter(snapshot_state, false);
    }
  }",1880.0,1890.0,3.0,3.0,11.0,7,5,8,6,0,2,2,2,1,0,,0,2,2,1,1,Iterator
1218,28054,GetSnapshot,1,leveldb.ModelDB.GetSnapshot,Snapshot leveldb.ModelDB.GetSnapshot (),db\db_test.cc,"virtual const Snapshot* GetSnapshot() {
    ModelSnapshot* snapshot = new ModelSnapshot;
    snapshot->map_ = map_;
    return snapshot;
  }",1891.0,1895.0,3.0,3.0,5.0,4,3,5,3,0,2,1,1,0,0,,0,2,0,0,0,Snapshot
1219,28070,ReleaseSnapshot,1,leveldb.ModelDB.ReleaseSnapshot,void leveldb.ModelDB.ReleaseSnapshot (Snapshot*),db\db_test.cc,"virtual void ReleaseSnapshot(const Snapshot* snapshot) {
    delete reinterpret_cast<const ModelSnapshot*>(snapshot);
  }",1897.0,1899.0,3.0,3.0,3.0,2,2,1,1,0,0,1,1,0,0,,0,0,2,1,1,void
1220,28079,Write,1,leveldb.ModelDB.Write,"Status leveldb.ModelDB.Write (WriteOptions,WriteBatch*)",db\db_test.cc,"virtual Status Write(const WriteOptions& options, WriteBatch* batch) {
    class Handler : public WriteBatch::Handler {
     public:
      KVMap* map_;
      virtual void Put(const Slice& key, const Slice& value) {
        (*map_)[key.ToString()] = value.ToString();
      }
      virtual void Delete(const Slice& key) {
        map_->erase(key.ToString());
      }
    };
    Handler handler;
    handler.map_ = &map_;
    return batch->Iterate(&handler);
  }",1900.0,1914.0,3.0,3.0,15.0,5,4,4,3,0,1,1,1,0,0,,0,1,4,2,2,Status
1221,28099,GetProperty,1,leveldb.ModelDB.GetProperty,"bool leveldb.ModelDB.GetProperty (Slice,ANY*)",db\db_test.cc,"virtual bool GetProperty(const Slice& property, std::string* value) {
    return false;
  }",1916.0,1918.0,3.0,3.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,bool
1222,28107,GetApproximateSizes,1,leveldb.ModelDB.GetApproximateSizes,"void leveldb.ModelDB.GetApproximateSizes (Range*,int,uint64_t*)",db\db_test.cc,"virtual void GetApproximateSizes(const Range* r, int n, uint64_t* sizes) {
    for (int i = 0; i < n; i++) {
      sizes[i] = 0;
    }
  }",1919.0,1923.0,3.0,3.0,5.0,4,3,5,3,0,0,2,2,0,0,,0,0,6,3,3,void
1223,28131,CompactRange,1,leveldb.ModelDB.CompactRange,"void leveldb.ModelDB.CompactRange (Slice*,Slice*)",db\db_test.cc,"virtual void CompactRange(const Slice* start, const Slice* end) {
  }",1924.0,1925.0,3.0,3.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
1224,28138,ModelIter,1,leveldb.ModelDB.ModelIter.ModelIter,"ANY leveldb.ModelDB.ModelIter.ModelIter (KVMap*,bool)",db\db_test.cc,"ModelIter(const KVMap* map, bool owned)
        : map_(map), owned_(owned), iter_(map_->end()) {
    }",1930.0,1932.0,5.0,5.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,ANY
1225,28144,~ModelIter,1,leveldb.ModelDB.ModelIter.~ModelIter,ANY leveldb.ModelDB.ModelIter.~ModelIter (),db\db_test.cc,"~ModelIter() {
      if (owned_) delete map_;
    }",1933.0,1935.0,5.0,5.0,3.0,1,1,2,2,0,2,2,2,1,0,,0,2,0,0,0,ANY
1226,28153,Valid,1,leveldb.ModelDB.ModelIter.Valid,bool leveldb.ModelDB.ModelIter.Valid (),db\db_test.cc,virtual bool Valid() const { return iter_ != map_->end(); },1936.0,1936.0,5.0,63.0,1.0,2,2,2,2,0,2,1,1,0,0,,0,2,0,0,0,bool
1227,28164,SeekToFirst,1,leveldb.ModelDB.ModelIter.SeekToFirst,void leveldb.ModelDB.ModelIter.SeekToFirst (),db\db_test.cc,virtual void SeekToFirst() { iter_ = map_->begin(); },1937.0,1937.0,5.0,57.0,1.0,2,2,2,2,0,2,1,1,0,0,,0,2,0,0,0,void
1228,28174,SeekToLast,1,leveldb.ModelDB.ModelIter.SeekToLast,void leveldb.ModelDB.ModelIter.SeekToLast (),db\db_test.cc,"virtual void SeekToLast() {
      if (map_->empty()) {
        iter_ = map_->end();
      } else {
        iter_ = map_->find(map_->rbegin()->first);
      }
    }",1938.0,1944.0,5.0,5.0,7.0,3,2,3,2,0,3,2,2,1,0,,0,3,0,0,0,void
1229,28204,Seek,1,leveldb.ModelDB.ModelIter.Seek,void leveldb.ModelDB.ModelIter.Seek (Slice),db\db_test.cc,"virtual void Seek(const Slice& k) {
      iter_ = map_->lower_bound(k.ToString());
    }",1945.0,1947.0,5.0,5.0,3.0,3,3,3,3,0,2,1,1,0,0,,0,2,2,1,1,void
1230,28219,Next,1,leveldb.ModelDB.ModelIter.Next,void leveldb.ModelDB.ModelIter.Next (),db\db_test.cc,virtual void Next() { ++iter_; },1948.0,1948.0,5.0,36.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,void
1231,28225,Prev,1,leveldb.ModelDB.ModelIter.Prev,void leveldb.ModelDB.ModelIter.Prev (),db\db_test.cc,virtual void Prev() { --iter_; },1949.0,1949.0,5.0,36.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,void
1232,28231,key,1,leveldb.ModelDB.ModelIter.key,Slice leveldb.ModelDB.ModelIter.key (),db\db_test.cc,virtual Slice key() const { return iter_->first; },1950.0,1950.0,5.0,54.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,Slice
1233,28239,value,1,leveldb.ModelDB.ModelIter.value,Slice leveldb.ModelDB.ModelIter.value (),db\db_test.cc,virtual Slice value() const { return iter_->second; },1951.0,1951.0,5.0,57.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,Slice
1234,28247,status,1,leveldb.ModelDB.ModelIter.status,Status leveldb.ModelDB.ModelIter.status (),db\db_test.cc,virtual Status status() const { return Status::OK(); },1952.0,1952.0,5.0,58.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,0,0,0,0,Status
1235,28261,RandomKey,1,leveldb.RandomKey,string leveldb.RandomKey (Random*),db\db_test.cc,"static std::string RandomKey(Random* rnd) {
  int len = (rnd->OneIn(3)
             ? 1                // Short sometimes to encourage collisions
             : (rnd->OneIn(100) ? rnd->Skewed(10) : rnd->Uniform(10)));
  return test::RandomKey(rnd, len);
}",1962.0,1967.0,1.0,1.0,6.0,8,4,8,3,0,0,1,1,0,0,,0,0,2,1,1,string
1236,28299,CompareIterators,1,leveldb.CompareIterators,"bool leveldb.CompareIterators (int,DB*,DB*,Snapshot*,Snapshot*)",db\db_test.cc,"static bool CompareIterators(int step,
                             DB* model,
                             DB* db,
                             const Snapshot* model_snap,
                             const Snapshot* db_snap) {
  ReadOptions options;
  options.snapshot = model_snap;
  Iterator* miter = model->NewIterator(options);
  options.snapshot = db_snap;
  Iterator* dbiter = db->NewIterator(options);
  bool ok = true;
  int count = 0;
  for (miter->SeekToFirst(), dbiter->SeekToFirst();
       ok && miter->Valid() && dbiter->Valid();
       miter->Next(), dbiter->Next()) {
    count++;
    if (miter->key().compare(dbiter->key()) != 0) {
      fprintf(stderr, ""step %d: Key mismatch: '%s' vs. '%s'\n"",
              step,
              EscapeString(miter->key()).c_str(),
              EscapeString(dbiter->key()).c_str());
      ok = false;
      break;
    }

    if (miter->value().compare(dbiter->value()) != 0) {
      fprintf(stderr, ""step %d: Value mismatch for key '%s': '%s' ...",1969.0,2015.0,1.0,1.0,47.0,46,8,47,11,0,2,7,9,0,0,,0,2,10,5,5,bool
1237,28503,_Run,1,leveldb._Test_Randomized._Run,void leveldb._Test_Randomized._Run (),table\table_test.cc,"TEST(Harness, Randomized) {
  for (int i = 0; i < kNumTestArgs; i++) {
    Init(kTestArgList[i]);
    Random rnd(test::RandomSeed() + 5);
    for (int num_entries = 0; num_entries < 2000;
         num_entries += (num_entries < 50 ? 1 : 200)) {
      if ((num_entries % 10) == 0) {
        fprintf(stderr, ""case %d of %d: num_entries = %d\n"",
                (i + 1), int(kNumTestArgs), num_entries);
      }
      for (int e = 0; e < num_entries; e++) {
        std::string v;
        Add(test::RandomKey(&rnd, rnd.Skewed(4)),
            test::RandomString(&rnd, rnd.Skewed(5), &v).ToString());
      }
      Test(&rnd);
    }
  }
}",716.0,734.0,1.0,25.0,19.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1238,28507,_RunIt,1,leveldb._Test_Randomized._RunIt,void leveldb._Test_Randomized._RunIt (),db\db_test.cc,"TEST(DBTest, Randomized)",2017.0,2017.0,1.0,24.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1239,28951,MakeKey,1,leveldb.MakeKey,string leveldb.MakeKey (unsigned int),db\db_test.cc,"std::string MakeKey(unsigned int num) {
  char buf[30];
  snprintf(buf, sizeof(buf), ""%016u"", num);
  return std::string(buf);
}",2088.0,2092.0,1.0,1.0,5.0,2,2,5,3,0,0,1,1,0,0,,0,0,2,1,1,string
1240,28969,BM_LogAndApply,1,leveldb.BM_LogAndApply,"void leveldb.BM_LogAndApply (int,int)",db\db_test.cc,"void BM_LogAndApply(int iters, int num_base_files) {
  std::string dbname = test::TmpDir() + ""/leveldb_test_benchmark"";
  DestroyDB(dbname, Options());

  DB* db = NULL;
  Options opts;
  opts.create_if_missing = true;
  Status s = DB::Open(opts, dbname, &db);
  ASSERT_OK(s);
  ASSERT_TRUE(db != NULL);

  delete db;
  db = NULL;

  Env* env = Env::Default();

  port::Mutex mu;
  MutexLock l(&mu);

  InternalKeyComparator cmp(BytewiseComparator());
  Options options;
  VersionSet vset(dbname, &options, NULL, &cmp);
  bool save_manifest;
  ASSERT_OK(vset.Recover(&save_manifest));
  VersionEdit vbase;
  uint64_t fnum = 1;
  for (int i = 0; i < num_base_files; i++) {
    InternalKey start(MakeKey(2*fnum), 1, kTypeValue);
    InternalKey limit(MakeKey(2*fnum+1), 1, kTypeDeletion);
    vbase.AddFile(2, fnum++, 1 /* file size */, start, limit);
  }
  ASSERT_OK(vset.LogAndApply(&vbase, &mu));

  uint64_t start_micros = env->NowMicros();

  for (int i = 0; i < iters; i++) {
    VersionEdit v...",2094.0,2144.0,1.0,2.0,51.0,64,14,84,33,0,1,3,3,0,0,,0,1,4,2,2,void
1241,29322,PackSequenceAndType,1,leveldb.PackSequenceAndType,"uint64_t leveldb.PackSequenceAndType (uint64_t,ValueType)",db\dbformat.cc,"static uint64_t PackSequenceAndType(uint64_t seq, ValueType t) {
  assert(seq <= kMaxSequenceNumber);
  assert(t <= kValueTypeForSeek);
  return (seq << 8) | t;
}",12.0,16.0,1.0,1.0,5.0,4,3,6,4,0,0,1,1,0,0,,0,0,4,2,2,uint64_t
1242,29342,AppendInternalKey,1,leveldb.AppendInternalKey,"void leveldb.AppendInternalKey (ANY*,ParsedInternalKey)",db\dbformat.cc,"void AppendInternalKey(std::string* result, const ParsedInternalKey& key) {
  result->append(key.user_key.data(), key.user_key.size());
  PutFixed64(result, PackSequenceAndType(key.sequence, key.type));
}",18.0,21.0,1.0,1.0,4.0,7,2,6,2,0,4,1,1,0,0,,0,4,4,2,2,void
1243,29373,DebugString,1,leveldb.ParsedInternalKey.DebugString,string leveldb.ParsedInternalKey.DebugString (),db\dbformat.cc,"std::string ParsedInternalKey::DebugString() const {
  char buf[50];
  snprintf(buf, sizeof(buf), ""' @ %llu : %d"",
           (unsigned long long) sequence,
           int(type));
  std::string result = ""'"";
  result += EscapeString(user_key.ToString());
  result += buf;
  return result;
}",23.0,32.0,1.0,1.0,10.0,7,6,10,5,0,3,1,1,0,0,,0,3,0,0,0,string
1244,29405,DebugString,1,leveldb.InternalKey.DebugString,string leveldb.InternalKey.DebugString (),db\dbformat.cc,"std::string InternalKey::DebugString() const {
  std::string result;
  ParsedInternalKey parsed;
  if (ParseInternalKey(rep_, &parsed)) {
    result = parsed.DebugString();
  } else {
    result = ""(bad)"";
    result.append(EscapeString(rep_));
  }
  return result;
}",34.0,44.0,1.0,1.0,11.0,3,3,5,3,0,1,2,2,1,0,,0,1,0,0,0,string
1245,29436,Name,1,leveldb.InternalKeyComparator.Name,const char* leveldb.InternalKeyComparator.Name (),db\dbformat.cc,"const char* InternalKeyComparator::Name() const {
  return ""leveldb.InternalKeyComparator"";
}",46.0,48.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,const char*
1246,29442,Compare,1,leveldb.InternalKeyComparator.Compare,"int leveldb.InternalKeyComparator.Compare (Slice,Slice)",db\dbformat.hpp,"inline int InternalKeyComparator::Compare(
    const InternalKey& a, const InternalKey& b) const {
  return Compare(a.Encode(), b.Encode());
}",171.0,174.0,1.0,1.0,4.0,16,8,15,6,0,1,3,4,0,0,,0,1,4,2,2,int
1247,29516,FindShortestSeparator,1,leveldb.InternalKeyComparator.FindShortestSeparator,"void leveldb.InternalKeyComparator.FindShortestSeparator (ANY*,Slice)",db\dbformat.cc,"void InternalKeyComparator::FindShortestSeparator(
      std::string* start,
      const Slice& limit) const {
  // Attempt to shorten the user portion of the key
  Slice user_start = ExtractUserKey(*start);
  Slice user_limit = ExtractUserKey(limit);
  std::string tmp(user_start.data(), user_start.size());
  user_comparator_->FindShortestSeparator(&tmp, user_limit);
  if (tmp.size() < user_start.size() &&
      user_comparator_->Compare(user_start, tmp) < 0) {
    // User key has become shorter physically, but larger logically.
    // Tack on the earliest possible number to the shortened user key.
    PutFixed64(&tmp, PackSequenceAndType(kMaxSequenceNumber,kValueTypeForSeek));
    assert(this->Compare(*start, tmp) < 0);
    assert(this->Compare(tmp, limit) < 0);
    start->swap(tmp);
  }
}",68.0,85.0,1.0,1.0,18.0,20,7,23,8,0,2,2,2,1,0,,0,2,4,2,2,void
1248,29600,FindShortSuccessor,1,leveldb.InternalKeyComparator.FindShortSuccessor,void leveldb.InternalKeyComparator.FindShortSuccessor (ANY*),db\dbformat.cc,"void InternalKeyComparator::FindShortSuccessor(std::string* key) const {
  Slice user_key = ExtractUserKey(*key);
  std::string tmp(user_key.data(), user_key.size());
  user_comparator_->FindShortSuccessor(&tmp);
  if (tmp.size() < user_key.size() &&
      user_comparator_->Compare(user_key, tmp) < 0) {
    // User key has become shorter physically, but larger logically.
    // Tack on the earliest possible number to the shortened user key.
    PutFixed64(&tmp, PackSequenceAndType(kMaxSequenceNumber,kValueTypeForSeek));
    assert(this->Compare(*key, tmp) < 0);
    key->swap(tmp);
  }
}",87.0,99.0,1.0,1.0,13.0,17,7,18,6,0,2,2,2,1,0,,0,2,2,1,1,void
1249,29668,Name,1,leveldb.InternalFilterPolicy.Name,const char* leveldb.InternalFilterPolicy.Name (),db\dbformat.cc,"const char* InternalFilterPolicy::Name() const {
  return user_policy_->Name();
}",101.0,103.0,1.0,1.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,const char*
1250,29677,CreateFilter,1,leveldb.InternalFilterPolicy.CreateFilter,"void leveldb.InternalFilterPolicy.CreateFilter (Slice*,int,ANY*)",db\dbformat.cc,"void InternalFilterPolicy::CreateFilter(const Slice* keys, int n,
                                        std::string* dst) const {
  // We rely on the fact that the code in table.cc does not mind us
  // adjusting keys[].
  Slice* mkey = const_cast<Slice*>(keys);
  for (int i = 0; i < n; i++) {
    mkey[i] = ExtractUserKey(keys[i]);
    // TODO(sanjay): Suppress dups?
  }
  user_policy_->CreateFilter(keys, n, dst);
}",105.0,115.0,1.0,1.0,11.0,8,5,13,6,0,1,2,2,0,0,,0,1,6,3,3,void
1251,29717,KeyMayMatch,1,leveldb.InternalFilterPolicy.KeyMayMatch,"bool leveldb.InternalFilterPolicy.KeyMayMatch (Slice,Slice)",db\dbformat.cc,"bool InternalFilterPolicy::KeyMayMatch(const Slice& key, const Slice& f) const {
  return user_policy_->KeyMayMatch(ExtractUserKey(key), f);
}",117.0,119.0,1.0,1.0,3.0,1,1,3,3,0,1,1,1,0,0,,0,1,4,2,2,bool
1252,29731,LookupKey,1,leveldb.LookupKey.LookupKey,"ANY leveldb.LookupKey.LookupKey (Slice,SequenceNumber)",db\dbformat.cc,"LookupKey::LookupKey(const Slice& user_key, SequenceNumber s) {
  size_t usize = user_key.size();
  size_t needed = usize + 13;  // A conservative estimate
  char* dst;
  if (needed <= sizeof(space_)) {
    dst = space_;
  } else {
    dst = new char[needed];
  }
  start_ = dst;
  dst = EncodeVarint32(dst, usize + 8);
  kstart_ = dst;
  memcpy(dst, user_key.data(), usize);
  dst += usize;
  EncodeFixed64(dst, PackSequenceAndType(s, kValueTypeForSeek));
  dst += 8;
  end_ = dst;
}",121.0,138.0,1.0,1.0,18.0,15,6,26,10,0,5,2,2,1,0,,0,5,4,2,2,ANY
1253,29878,ParsedInternalKey,1,leveldb.ParsedInternalKey.ParsedInternalKey,ANY leveldb.ParsedInternalKey.ParsedInternalKey (),db\dbformat.hpp,"ParsedInternalKey(const Slice& u, const SequenceNumber& seq, ValueType t)
      : user_key(u), sequence(seq), type(t) { }",76.0,77.0,3.0,47.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,ANY
1254,29893,InternalKeyEncodingLength,1,leveldb.InternalKeyEncodingLength,size_t leveldb.InternalKeyEncodingLength (ParsedInternalKey),db\dbformat.hpp,"inline size_t InternalKeyEncodingLength(const ParsedInternalKey& key) {
  return key.user_key.size() + 8;
}",82.0,84.0,1.0,1.0,3.0,3,2,1,1,0,1,1,1,0,0,,0,1,2,1,1,size_t
1255,29913,ParseInternalKey,1,leveldb.ParseInternalKey,"bool leveldb.ParseInternalKey (Slice,ParsedInternalKey*)",db\dbformat.hpp,"inline bool ParseInternalKey(const Slice& internal_key,
                             ParsedInternalKey* result) {
  const size_t n = internal_key.size();
  if (n < 8) return false;
  uint64_t num = DecodeFixed64(internal_key.data() + n - 8);
  unsigned char c = num & 0xff;
  result->sequence = num >> 8;
  result->type = static_cast<ValueType>(c);
  result->user_key = Slice(internal_key.data(), n - 8);
  return (c <= static_cast<unsigned char>(kTypeValue));
}",176.0,186.0,1.0,1.0,11.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,bool
1256,29919,ExtractUserKey,1,leveldb.ExtractUserKey,Slice leveldb.ExtractUserKey (Slice),db\dbformat.hpp,"inline Slice ExtractUserKey(const Slice& internal_key) {
  assert(internal_key.size() >= 8);
  return Slice(internal_key.data(), internal_key.size() - 8);
}",98.0,101.0,1.0,1.0,4.0,5,3,3,1,0,0,1,1,0,0,,0,0,2,1,1,Slice
1257,29943,ExtractValueType,1,leveldb.ExtractValueType,ValueType leveldb.ExtractValueType (Slice),db\dbformat.hpp,"inline ValueType ExtractValueType(const Slice& internal_key) {
  assert(internal_key.size() >= 8);
  const size_t n = internal_key.size();
  uint64_t num = DecodeFixed64(internal_key.data() + n - 8);
  unsigned char c = num & 0xff;
  return static_cast<ValueType>(c);
}",103.0,109.0,1.0,1.0,7.0,11,7,9,4,0,0,1,1,0,0,,0,0,2,1,1,ValueType
1258,29986,InternalKeyComparator,1,leveldb.InternalKeyComparator.InternalKeyComparator,ANY leveldb.InternalKeyComparator.InternalKeyComparator (Comparator*),db\dbformat.hpp,explicit InternalKeyComparator(const Comparator* c) : user_comparator_(c) { },117.0,117.0,3.0,79.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
1259,30012,user_comparator,1,leveldb.InternalKeyComparator.user_comparator,Comparator leveldb.InternalKeyComparator.user_comparator (),db\dbformat.hpp,const Comparator* user_comparator() const { return user_comparator_; },125.0,125.0,3.0,72.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,Comparator
1260,30026,InternalFilterPolicy,1,leveldb.InternalFilterPolicy.InternalFilterPolicy,ANY leveldb.InternalFilterPolicy.InternalFilterPolicy (FilterPolicy*),db\dbformat.hpp,explicit InternalFilterPolicy(const FilterPolicy* p) : user_policy_(p) { },135.0,135.0,3.0,76.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
1261,30050,InternalKey,1,leveldb.InternalKey.InternalKey,ANY leveldb.InternalKey.InternalKey (),db\dbformat.hpp,"InternalKey(const Slice& user_key, SequenceNumber s, ValueType t) {
    AppendInternalKey(&rep_, ParsedInternalKey(user_key, s, t));
  }",149.0,151.0,3.0,3.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,ANY
1262,30068,DecodeFrom,1,leveldb.InternalKey.DecodeFrom,void leveldb.InternalKey.DecodeFrom (Slice),db\dbformat.hpp,"void DecodeFrom(const Slice& s) { rep_.assign(s.data(), s.size()); }",153.0,153.0,3.0,70.0,1.0,3,1,3,2,0,1,1,1,0,0,,0,1,2,1,1,void
1263,30085,Encode,1,leveldb.InternalKey.Encode,Slice leveldb.InternalKey.Encode (),db\dbformat.hpp,"Slice Encode() const {
    assert(!rep_.empty());
    return rep_;
  }",154.0,157.0,3.0,3.0,4.0,2,2,2,1,0,2,1,1,0,0,,0,2,0,0,0,Slice
1264,30097,user_key,1,leveldb.InternalKey.user_key,Slice leveldb.InternalKey.user_key (),db\dbformat.hpp,Slice user_key() const { return ExtractUserKey(rep_); },159.0,159.0,3.0,57.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,Slice
1265,30104,SetFrom,1,leveldb.InternalKey.SetFrom,void leveldb.InternalKey.SetFrom (ParsedInternalKey),db\dbformat.hpp,"void SetFrom(const ParsedInternalKey& p) {
    rep_.clear();
    AppendInternalKey(&rep_, p);
  }",161.0,164.0,3.0,3.0,4.0,2,2,3,2,0,2,1,1,0,0,,0,2,2,1,1,void
1266,30117,Clear,1,leveldb.InternalKey.Clear,void leveldb.InternalKey.Clear (),db\dbformat.hpp,void Clear() { rep_.clear(); },166.0,166.0,3.0,32.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,void
1267,30222,~LookupKey,1,leveldb.LookupKey.~LookupKey,ANY leveldb.LookupKey.~LookupKey (),db\dbformat.hpp,"inline LookupKey::~LookupKey() {
  if (start_ != space_) delete[] start_;
}",224.0,226.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
1268,30226,memtable_key,1,leveldb.LookupKey.memtable_key,Slice leveldb.LookupKey.memtable_key (),db\dbformat.hpp,"Slice memtable_key() const { return Slice(start_, end_ - start_); }",198.0,198.0,3.0,69.0,1.0,1,1,3,2,0,3,1,1,0,0,,0,3,0,0,0,Slice
1269,30236,internal_key,1,leveldb.LookupKey.internal_key,Slice leveldb.LookupKey.internal_key (),db\dbformat.hpp,"Slice internal_key() const { return Slice(kstart_, end_ - kstart_); }",201.0,201.0,3.0,71.0,1.0,1,1,3,2,0,3,1,1,0,0,,0,3,0,0,0,Slice
1270,30246,user_key,1,leveldb.LookupKey.user_key,Slice leveldb.LookupKey.user_key (),db\dbformat.hpp,"Slice user_key() const { return Slice(kstart_, end_ - kstart_ - 8); }",204.0,204.0,3.0,71.0,1.0,2,1,3,2,0,3,1,1,0,0,,0,3,0,0,0,Slice
1271,30267,operator =,1,leveldb.LookupKey.operator =,void leveldb.LookupKey.operator = (LookupKey),db\dbformat.hpp,void operator=(const LookupKey&);,221.0,221.0,8.0,34.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
1272,30301,IKey,1,leveldb.IKey,"string leveldb.IKey (ANY,uint64_t,ValueType)",db\dbformat_test.cc,"static std::string IKey(const std::string& user_key,
                        uint64_t seq,
                        ValueType vt) {
  std::string encoded;
  AppendInternalKey(&encoded, ParsedInternalKey(user_key, seq, vt));
  return encoded;
}",11.0,17.0,1.0,1.0,7.0,1,1,5,4,0,0,1,1,0,0,,0,0,6,3,3,string
1273,30318,Shorten,1,leveldb.Shorten,"string leveldb.Shorten (ANY,ANY)",db\dbformat_test.cc,"static std::string Shorten(const std::string& s, const std::string& l) {
  std::string result = s;
  InternalKeyComparator(BytewiseComparator()).FindShortestSeparator(&result, l);
  return result;
}",19.0,23.0,1.0,1.0,5.0,3,3,5,3,0,0,1,1,0,0,,0,0,4,2,2,string
1274,30338,ShortSuccessor,1,leveldb.ShortSuccessor,string leveldb.ShortSuccessor (ANY),db\dbformat_test.cc,"static std::string ShortSuccessor(const std::string& s) {
  std::string result = s;
  InternalKeyComparator(BytewiseComparator()).FindShortSuccessor(&result);
  return result;
}",25.0,29.0,1.0,1.0,5.0,3,3,4,2,0,0,1,1,0,0,,0,0,2,1,1,string
1275,30356,TestKey,1,leveldb.TestKey,"void leveldb.TestKey (ANY,uint64_t,ValueType)",db\dbformat_test.cc,"static void TestKey(const std::string& key,
                    uint64_t seq,
                    ValueType vt) {
  std::string encoded = IKey(key, seq, vt);

  Slice in(encoded);
  ParsedInternalKey decoded("""", 0, kTypeValue);

  ASSERT_TRUE(ParseInternalKey(in, &decoded));
  ASSERT_EQ(key, decoded.user_key.ToString());
  ASSERT_EQ(seq, decoded.sequence);
  ASSERT_EQ(vt, decoded.type);

  ASSERT_TRUE(!ParseInternalKey(Slice(""bar""), &decoded));
}",31.0,45.0,1.0,2.0,15.0,27,4,31,12,0,6,1,1,0,0,,0,6,6,3,3,void
1276,30487,_Run,1,leveldb._Test_InternalKey_EncodeDecode._Run,void leveldb._Test_InternalKey_EncodeDecode._Run (),db\dbformat_test.cc,"TEST(FormatTest, InternalKey_EncodeDecode) {
  const char* keys[] = { """", ""k"", ""hello"", ""longggggggggggggggggggggg"" };
  const uint64_t seq[] = {
    1, 2, 3,
    (1ull << 8) - 1, 1ull << 8, (1ull << 8) + 1,
    (1ull << 16) - 1, 1ull << 16, (1ull << 16) + 1,
    (1ull << 32) - 1, 1ull << 32, (1ull << 32) + 1
  };
  for (int k = 0; k < sizeof(keys) / sizeof(keys[0]); k++) {
    for (int s = 0; s < sizeof(seq) / sizeof(seq[0]); s++) {
      TestKey(keys[k], seq[s], kTypeValue);
      TestKey(""hello"", 1, kTypeDeletion);
    }
  }
}",49.0,63.0,1.0,42.0,15.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1277,30491,_RunIt,1,leveldb._Test_InternalKey_EncodeDecode._RunIt,void leveldb._Test_InternalKey_EncodeDecode._RunIt (),db\dbformat_test.cc,"TEST(FormatTest, InternalKey_EncodeDecode)",49.0,49.0,1.0,42.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1278,30622,_Run,1,leveldb._Test_InternalKeyShortSeparator._Run,void leveldb._Test_InternalKeyShortSeparator._Run (),db\dbformat_test.cc,"TEST(FormatTest, InternalKeyShortSeparator) {
  // When user keys are same
  ASSERT_EQ(IKey(""foo"", 100, kTypeValue),
            Shorten(IKey(""foo"", 100, kTypeValue),
                    IKey(""foo"", 99, kTypeValue)));
  ASSERT_EQ(IKey(""foo"", 100, kTypeValue),
            Shorten(IKey(""foo"", 100, kTypeValue),
                    IKey(""foo"", 101, kTypeValue)));
  ASSERT_EQ(IKey(""foo"", 100, kTypeValue),
            Shorten(IKey(""foo"", 100, kTypeValue),
                    IKey(""foo"", 100, kTypeValue)));
  ASSERT_EQ(IKey(""foo"", 100, kTypeValue),
            Shorten(IKey(""foo"", 100, kTypeValue),
                    IKey(""foo"", 100, kTypeDeletion)));

  // When user keys are misordered
  ASSERT_EQ(IKey(""foo"", 100, kTypeValue),
            Shorten(IKey(""foo"", 100, kTypeValue),
                    IKey(""bar"", 99, kTypeValue)));

  // When user keys are different, but correctly ordered
  ASSERT_EQ(IKey(""g"", kMaxSequenceNumber, kValueTypeForSeek),
            Shorten(IKey(""foo"", 100, kTypeVal...",65.0,99.0,1.0,43.0,35.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1279,30626,_RunIt,1,leveldb._Test_InternalKeyShortSeparator._RunIt,void leveldb._Test_InternalKeyShortSeparator._RunIt (),db\dbformat_test.cc,"TEST(FormatTest, InternalKeyShortSeparator)",65.0,65.0,1.0,43.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1280,30863,_Run,1,leveldb._Test_InternalKeyShortestSuccessor._Run,void leveldb._Test_InternalKeyShortestSuccessor._Run (),db\dbformat_test.cc,"TEST(FormatTest, InternalKeyShortestSuccessor) {
  ASSERT_EQ(IKey(""g"", kMaxSequenceNumber, kValueTypeForSeek),
            ShortSuccessor(IKey(""foo"", 100, kTypeValue)));
  ASSERT_EQ(IKey(""\xff\xff"", 100, kTypeValue),
            ShortSuccessor(IKey(""\xff\xff"", 100, kTypeValue)));
}",101.0,106.0,1.0,46.0,6.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1281,30867,_RunIt,1,leveldb._Test_InternalKeyShortestSuccessor._RunIt,void leveldb._Test_InternalKeyShortestSuccessor._RunIt (),db\dbformat_test.cc,"TEST(FormatTest, InternalKeyShortestSuccessor)",101.0,101.0,1.0,46.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1282,30985,GuessType,1,leveldb.anonymous_namespace_1.GuessType,"bool leveldb.anonymous_namespace_1.GuessType (ANY,FileType*)",db\dumpfile.cc,"bool GuessType(const std::string& fname, FileType* type) {
  size_t pos = fname.rfind('/');
  std::string basename;
  if (pos == std::string::npos) {
    basename = fname;
  } else {
    basename = std::string(fname.data() + pos + 1, fname.size() - pos - 1);
  }
  uint64_t ignored;
  return ParseFileName(basename, &ignored, type);
}",23.0,33.0,1.0,1.0,11.0,7,4,10,7,0,0,2,2,0,0,,0,0,4,2,2,bool
1283,31045,Corruption,1,leveldb.anonymous_namespace_3.CorruptionReporter.Corruption,"void leveldb.anonymous_namespace_3.CorruptionReporter.Corruption (size_t,Status)",db\dumpfile.cc,"virtual void Corruption(size_t bytes, const Status& status) {
    std::string r = ""corruption: "";
    AppendNumberTo(&r, bytes);
    r += "" bytes; "";
    r += status.ToString();
    r.push_back('\n');
    dst_->Append(r);
  }",39.0,46.0,3.0,3.0,8.0,7,5,9,4,0,1,1,1,0,0,,0,1,4,2,2,void
1284,31078,PrintLogContents,1,leveldb.anonymous_namespace_4.PrintLogContents,"Status leveldb.anonymous_namespace_4.PrintLogContents (Env*,ANY,void,WritableFile*)",db\dumpfile.cc,"Status PrintLogContents(Env* env, const std::string& fname,
                        void (*func)(uint64_t, Slice, WritableFile*),
                        WritableFile* dst) {
  SequentialFile* file;
  Status s = env->NewSequentialFile(fname, &file);
  if (!s.ok()) {
    return s;
  }
  CorruptionReporter reporter;
  reporter.dst_ = dst;
  log::Reader reader(file, &reporter, true, 0);
  Slice record;
  std::string scratch;
  while (reader.ReadRecord(&record, &scratch)) {
    (*func)(reader.LastRecordOffset(), record, dst);
  }
  delete file;
  return Status::OK();
}",50.0,68.0,1.0,1.0,19.0,15,7,19,11,0,2,3,3,0,0,,0,1,8,4,4,Status
1285,31149,Put,1,leveldb.anonymous_namespace_6.WriteBatchItemPrinter.Put,"void leveldb.anonymous_namespace_6.WriteBatchItemPrinter.Put (Slice,Slice)",db\dumpfile.cc,"virtual void Put(const Slice& key, const Slice& value) {
    std::string r = ""  put '"";
    AppendEscapedStringTo(&r, key);
    r += ""' '"";
    AppendEscapedStringTo(&r, value);
    r += ""'\n"";
    dst_->Append(r);
  }",74.0,81.0,3.0,3.0,8.0,6,4,9,4,0,1,1,1,0,0,,0,1,4,2,2,void
1286,31178,Delete,1,leveldb.anonymous_namespace_7.WriteBatchItemPrinter.Delete,void leveldb.anonymous_namespace_7.WriteBatchItemPrinter.Delete (Slice),db\dumpfile.cc,"virtual void Delete(const Slice& key) {
    std::string r = ""  del '"";
    AppendEscapedStringTo(&r, key);
    r += ""'\n"";
    dst_->Append(r);
  }",82.0,87.0,3.0,3.0,6.0,4,4,6,3,0,1,1,1,0,0,,0,1,2,1,1,void
1287,31199,WriteBatchPrinter,1,leveldb.anonymous_namespace_8.WriteBatchPrinter,"void leveldb.anonymous_namespace_8.WriteBatchPrinter (uint64_t,Slice,WritableFile*)",db\dumpfile.cc,"static void WriteBatchPrinter(uint64_t pos, Slice record, WritableFile* dst) {
  std::string r = ""--- offset "";
  AppendNumberTo(&r, pos);
  r += ""; "";
  if (record.size() < 12) {
    r += ""log record length "";
    AppendNumberTo(&r, record.size());
    r += "" is too small\n"";
    dst->Append(r);
    return;
  }
  WriteBatch batch;
  WriteBatchInternal::SetContents(&batch, record);
  r += ""sequence "";
  AppendNumberTo(&r, WriteBatchInternal::Sequence(&batch));
  r.push_back('\n');
  dst->Append(r);
  WriteBatchItemPrinter batch_item_printer;
  batch_item_printer.dst_ = dst;
  Status s = batch.Iterate(&batch_item_printer);
  if (!s.ok()) {
    dst->Append(""  error: "" + s.ToString() + ""\n"");
  }
}",93.0,116.0,1.0,1.0,24.0,29,8,29,8,0,1,3,3,0,0,,0,1,6,3,3,void
1288,31308,DumpLog,1,leveldb.anonymous_namespace_9.DumpLog,"Status leveldb.anonymous_namespace_9.DumpLog (Env*,ANY,WritableFile*)",db\dumpfile.cc,"Status DumpLog(Env* env, const std::string& fname, WritableFile* dst) {
  return PrintLogContents(env, fname, WriteBatchPrinter, dst);
}",118.0,120.0,1.0,1.0,3.0,0,0,3,3,0,0,1,1,0,0,,0,0,6,3,3,Status
1289,31321,VersionEditPrinter,1,leveldb.anonymous_namespace_12.VersionEditPrinter,"void leveldb.anonymous_namespace_12.VersionEditPrinter (uint64_t,Slice,WritableFile*)",db\dumpfile.cc,"static void VersionEditPrinter(uint64_t pos, Slice record, WritableFile* dst) {
  std::string r = ""--- offset "";
  AppendNumberTo(&r, pos);
  r += ""; "";
  VersionEdit edit;
  Status s = edit.DecodeFrom(record);
  if (!s.ok()) {
    r += s.ToString();
    r.push_back('\n');
  } else {
    r += edit.DebugString();
  }
  dst->Append(r);
}",124.0,137.0,1.0,1.0,14.0,11,6,13,6,0,0,2,2,0,0,,0,0,6,3,3,void
1290,31379,DumpDescriptor,1,leveldb.anonymous_namespace_13.DumpDescriptor,"Status leveldb.anonymous_namespace_13.DumpDescriptor (Env*,ANY,WritableFile*)",db\dumpfile.cc,"Status DumpDescriptor(Env* env, const std::string& fname, WritableFile* dst) {
  return PrintLogContents(env, fname, VersionEditPrinter, dst);
}",139.0,141.0,1.0,1.0,3.0,0,0,3,3,0,0,1,1,0,0,,0,0,6,3,3,Status
1291,31392,DumpTable,1,leveldb.anonymous_namespace_16.DumpTable,"Status leveldb.anonymous_namespace_16.DumpTable (Env*,ANY,WritableFile*)",db\dumpfile.cc,"Status DumpTable(Env* env, const std::string& fname, WritableFile* dst) {
  uint64_t file_size;
  RandomAccessFile* file = NULL;
  Table* table = NULL;
  Status s = env->GetFileSize(fname, &file_size);
  if (s.ok()) {
    s = env->NewRandomAccessFile(fname, &file);
  }
  if (s.ok()) {
    // We use the default comparator, which may or may not match the
    // comparator used in this database. However this should not cause
    // problems since we only use Table operations that do not require
    // any comparisons.  In particular, we do not call Seek or Prev.
    s = Table::Open(Options(), file, file_size, &table);
  }
  if (!s.ok()) {
    delete table;
    delete file;
    return s;
  }

  ReadOptions ro;
  ro.fill_cache = false;
  Iterator* iter = table->NewIterator(ro);
  std::string r;
  for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {
    r.clear();
    ParsedInternalKey key;
    if (!ParseInternalKey(iter->key(), &key)) {
      r = ""badkey '"";
      AppendEscapedString...",143.0,206.0,1.0,1.0,64.0,47,8,50,14,0,2,7,8,0,0,,0,1,6,3,3,Status
1292,31643,DumpFile,1,leveldb.DumpFile,"Status leveldb.DumpFile (Env*,ANY,WritableFile*)",db\dumpfile.cc,"Status DumpFile(Env* env, const std::string& fname, WritableFile* dst) {
  FileType ftype;
  if (!GuessType(fname, &ftype)) {
    return Status::InvalidArgument(fname + "": unknown file type"");
  }
  switch (ftype) {
    case kLogFile:         return DumpLog(env, fname, dst);
    case kDescriptorFile:  return DumpDescriptor(env, fname, dst);
    case kTableFile:       return DumpTable(env, fname, dst);
    default:
      break;
  }
  return Status::InvalidArgument(fname + "": not a dump-able file type"");
}",210.0,223.0,1.0,1.0,14.0,6,4,19,8,0,2,4,3,0,2,,0,0,6,3,3,Status
1293,31750,GetDirName,1,leveldb.anonymous_namespace_1.GetDirName,string leveldb.anonymous_namespace_1.GetDirName (ANY),db\fault_injection_test.cc,"static std::string GetDirName(const std::string filename) {
  size_t found = filename.find_last_of(""/\\"");
  if (found == std::string::npos) {
    return """";
  } else {
    return filename.substr(0, found);
  }
}",37.0,44.0,1.0,1.0,8.0,5,3,5,4,0,0,2,2,0,0,,0,0,2,1,1,string
1294,31783,SyncDir,1,leveldb.anonymous_namespace_2.SyncDir,Status leveldb.anonymous_namespace_2.SyncDir (ANY),db\fault_injection_test.cc,"Status SyncDir(const std::string& dir) {
  // As this is a test it isn't required to *actually* sync this directory.
  return Status::OK();
}",46.0,49.0,1.0,1.0,4.0,1,1,1,1,0,1,1,1,0,0,,0,0,2,1,1,Status
1295,31793,Truncate,1,leveldb.anonymous_namespace_3.Truncate,"Status leveldb.anonymous_namespace_3.Truncate (ANY,uint64_t)",db\fault_injection_test.cc,"Status Truncate(const std::string& filename, uint64_t length) {
  leveldb::Env* env = leveldb::Env::Default();

  SequentialFile* orig_file;
  Status s = env->NewSequentialFile(filename, &orig_file);
  if (!s.ok())
    return s;

  char* scratch = new char[length];
  leveldb::Slice result;
  s = orig_file->Read(length, &result, scratch);
  delete orig_file;
  if (s.ok()) {
    std::string tmp_name = GetDirName(filename) + ""/truncate.tmp"";
    WritableFile* tmp_file;
    s = env->NewWritableFile(tmp_name, &tmp_file);
    if (s.ok()) {
      s = tmp_file->Append(result);
      delete tmp_file;
      if (s.ok()) {
        s = env->RenameFile(tmp_name, filename);
      } else {
        env->DeleteFile(tmp_name);
      }
    }
  }

  delete[] scratch;

  return s;
}",52.0,82.0,1.0,1.0,31.0,28,8,36,12,0,1,5,8,0,0,,0,1,4,2,2,Status
1296,31914,FileState,1,leveldb.anonymous_namespace_6.FileState.FileState,ANY leveldb.anonymous_namespace_6.FileState.FileState (ANY),db\fault_injection_test.cc,"FileState(const std::string& filename)
      : filename_(filename),
        pos_(-1),
        pos_at_last_sync_(-1),
        pos_at_last_flush_(-1) { }",90.0,94.0,3.0,34.0,5.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
1297,31919,FileState,1,leveldb.anonymous_namespace_7.FileState.FileState,ANY leveldb.anonymous_namespace_7.FileState.FileState (),db\fault_injection_test.cc,"FileState() : pos_(-1), pos_at_last_sync_(-1), pos_at_last_flush_(-1) {}",96.0,96.0,3.0,74.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
1298,31923,IsFullySynced,1,leveldb.anonymous_namespace_8.FileState.IsFullySynced,bool leveldb.anonymous_namespace_8.FileState.IsFullySynced (),db\fault_injection_test.cc,bool IsFullySynced() const { return pos_ <= 0 || pos_ == pos_at_last_sync_; },98.0,98.0,3.0,79.0,1.0,3,3,3,2,0,3,1,1,0,0,,0,3,0,0,0,bool
1299,31935,DropUnsyncedData,1,leveldb.anonymous_namespace_9.FileState.DropUnsyncedData,Status leveldb.anonymous_namespace_9.FileState.DropUnsyncedData (),db\fault_injection_test.cc,Status DropUnsyncedData() const;,100.0,100.0,10.0,33.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,Status
1300,31940,TestWritableFile,1,leveldb.TestWritableFile.TestWritableFile,"ANY leveldb.TestWritableFile.TestWritableFile (FileState,WritableFile*,FaultInjectionTestEnv*)",db\fault_injection_test.cc,"TestWritableFile::TestWritableFile(const FileState& state,
                                   WritableFile* f,
                                   FaultInjectionTestEnv* env)
    : state_(state),
      target_(f),
      writable_file_opened_(true),
      env_(env) {
  assert(f != NULL);
}",159.0,167.0,1.0,1.0,9.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,ANY
1301,31947,~TestWritableFile,1,leveldb.TestWritableFile.~TestWritableFile,virtual leveldb.TestWritableFile.~TestWritableFile (),db\fault_injection_test.cc,"TestWritableFile::~TestWritableFile() {
  if (writable_file_opened_) {
    Close();
  }
  delete target_;
}",169.0,174.0,1.0,1.0,6.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
1302,31951,Append,1,leveldb.TestWritableFile.Append,Status leveldb.TestWritableFile.Append (Slice),db\fault_injection_test.cc,"Status TestWritableFile::Append(const Slice& data) {
  Status s = target_->Append(data);
  if (s.ok() && env_->IsFilesystemActive()) {
    state_.pos_ += data.size();
  }
  return s;
}",176.0,182.0,1.0,1.0,7.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,Status
1303,31956,Close,1,leveldb.TestWritableFile.Close,Status leveldb.TestWritableFile.Close (),db\fault_injection_test.cc,"Status TestWritableFile::Close() {
  writable_file_opened_ = false;
  Status s = target_->Close();
  if (s.ok()) {
    env_->WritableFileClosed(state_);
  }
  return s;
}",184.0,191.0,1.0,1.0,8.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,Status
1304,31960,Flush,1,leveldb.TestWritableFile.Flush,Status leveldb.TestWritableFile.Flush (),db\fault_injection_test.cc,"Status TestWritableFile::Flush() {
  Status s = target_->Flush();
  if (s.ok() && env_->IsFilesystemActive()) {
    state_.pos_at_last_flush_ = state_.pos_;
  }
  return s;
}",193.0,199.0,1.0,1.0,7.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,Status
1305,31964,Sync,1,leveldb.TestWritableFile.Sync,Status leveldb.TestWritableFile.Sync (),db\fault_injection_test.cc,"Status TestWritableFile::Sync() {
  if (!env_->IsFilesystemActive()) {
    return Status::OK();
  }
  // Ensure new files referred to by the manifest are in the filesystem.
  Status s = target_->Sync();
  if (s.ok()) {
    state_.pos_at_last_sync_ = state_.pos_;
  }
  if (env_->IsFileCreatedSinceLastDirSync(state_.filename_)) {
    Status ps = SyncParent();
    if (s.ok() && !ps.ok()) {
      s = ps;
    }
  }
  return s;
}",209.0,225.0,1.0,1.0,17.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,Status
1306,31972,SyncParent,1,leveldb.TestWritableFile.SyncParent,Status leveldb.TestWritableFile.SyncParent (),db\fault_injection_test.cc,"Status TestWritableFile::SyncParent() {
  Status s = SyncDir(GetDirName(state_.filename_));
  if (s.ok()) {
    env_->DirWasSynced();
  }
  return s;
}",201.0,207.0,1.0,1.0,7.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,Status
1307,31977,FaultInjectionTestEnv,1,leveldb.FaultInjectionTestEnv.FaultInjectionTestEnv,ANY leveldb.FaultInjectionTestEnv.FaultInjectionTestEnv (),db\fault_injection_test.cc,"FaultInjectionTestEnv() : EnvWrapper(Env::Default()), filesystem_active_(true) {}",129.0,129.0,3.0,83.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
1308,31981,~FaultInjectionTestEnv,1,leveldb.FaultInjectionTestEnv.~FaultInjectionTestEnv,ANY leveldb.FaultInjectionTestEnv.~FaultInjectionTestEnv (),db\fault_injection_test.cc,virtual ~FaultInjectionTestEnv() { },130.0,130.0,3.0,38.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
1309,31985,NewWritableFile,1,leveldb.FaultInjectionTestEnv.NewWritableFile,"Status leveldb.FaultInjectionTestEnv.NewWritableFile (ANY,WritableFile**)",db\fault_injection_test.cc,"Status FaultInjectionTestEnv::NewWritableFile(const std::string& fname,
                                              WritableFile** result) {
  WritableFile* actual_writable_file;
  Status s = target()->NewWritableFile(fname, &actual_writable_file);
  if (s.ok()) {
    FileState state(fname);
    state.pos_ = 0;
    *result = new TestWritableFile(state, actual_writable_file, this);
    // NewWritableFile doesn't append to files, so if the same file is
    // opened again then it will be truncated - so forget our saved
    // state.
    UntrackFile(fname);
    MutexLock l(&mutex_);
    new_files_since_last_dir_sync_.insert(fname);
  }
  return s;
}",227.0,243.0,1.0,1.0,17.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,Status
1310,31991,NewAppendableFile,1,leveldb.FaultInjectionTestEnv.NewAppendableFile,"Status leveldb.FaultInjectionTestEnv.NewAppendableFile (ANY,WritableFile**)",db\fault_injection_test.cc,"Status FaultInjectionTestEnv::NewAppendableFile(const std::string& fname,
                                                WritableFile** result) {
  WritableFile* actual_writable_file;
  Status s = target()->NewAppendableFile(fname, &actual_writable_file);
  if (s.ok()) {
    FileState state(fname);
    state.pos_ = 0;
    {
      MutexLock l(&mutex_);
      if (db_file_state_.count(fname) == 0) {
        new_files_since_last_dir_sync_.insert(fname);
      } else {
        state = db_file_state_[fname];
      }
    }
    *result = new TestWritableFile(state, actual_writable_file, this);
  }
  return s;
}",245.0,263.0,1.0,1.0,19.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,Status
1311,31997,DeleteFile,1,leveldb.FaultInjectionTestEnv.DeleteFile,Status leveldb.FaultInjectionTestEnv.DeleteFile (ANY),db\fault_injection_test.cc,"Status FaultInjectionTestEnv::DeleteFile(const std::string& f) {
  Status s = EnvWrapper::DeleteFile(f);
  ASSERT_OK(s);
  if (s.ok()) {
    UntrackFile(f);
  }
  return s;
}",297.0,304.0,1.0,2.0,8.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,Status
1312,32002,RenameFile,1,leveldb.FaultInjectionTestEnv.RenameFile,"Status leveldb.FaultInjectionTestEnv.RenameFile (ANY,ANY)",db\fault_injection_test.cc,"Status FaultInjectionTestEnv::RenameFile(const std::string& s,
                                         const std::string& t) {
  Status ret = EnvWrapper::RenameFile(s, t);

  if (ret.ok()) {
    MutexLock l(&mutex_);
    if (db_file_state_.find(s) != db_file_state_.end()) {
      db_file_state_[t] = db_file_state_[s];
      db_file_state_.erase(s);
    }

    if (new_files_since_last_dir_sync_.erase(s) != 0) {
      assert(new_files_since_last_dir_sync_.find(t) ==
             new_files_since_last_dir_sync_.end());
      new_files_since_last_dir_sync_.insert(t);
    }
  }

  return ret;
}",306.0,325.0,1.0,1.0,20.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,Status
1313,32008,WritableFileClosed,1,leveldb.FaultInjectionTestEnv.WritableFileClosed,void leveldb.FaultInjectionTestEnv.WritableFileClosed (FileState),db\fault_injection_test.cc,"void FaultInjectionTestEnv::WritableFileClosed(const FileState& state) {
  MutexLock l(&mutex_);
  db_file_state_[state.filename_] = state;
}",349.0,352.0,1.0,1.0,4.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
1314,32013,DropUnsyncedFileData,1,leveldb.FaultInjectionTestEnv.DropUnsyncedFileData,Status leveldb.FaultInjectionTestEnv.DropUnsyncedFileData (),db\fault_injection_test.cc,"Status FaultInjectionTestEnv::DropUnsyncedFileData() {
  Status s;
  MutexLock l(&mutex_);
  for (std::map<std::string, FileState>::const_iterator it =
           db_file_state_.begin();
       s.ok() && it != db_file_state_.end(); ++it) {
    const FileState& state = it->second;
    if (!state.IsFullySynced()) {
      s = state.DropUnsyncedData();
    }
  }
  return s;
}",265.0,277.0,1.0,1.0,13.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,Status
1315,32017,DeleteFilesCreatedAfterLastDirSync,1,leveldb.FaultInjectionTestEnv.DeleteFilesCreatedAfterLastDirSync,Status leveldb.FaultInjectionTestEnv.DeleteFilesCreatedAfterLastDirSync (),db\fault_injection_test.cc,"Status FaultInjectionTestEnv::DeleteFilesCreatedAfterLastDirSync() {
  // Because DeleteFile access this container make a copy to avoid deadlock
  mutex_.Lock();
  std::set<std::string> new_files(new_files_since_last_dir_sync_.begin(),
                                  new_files_since_last_dir_sync_.end());
  mutex_.Unlock();
  Status s;
  std::set<std::string>::const_iterator it;
  for (it = new_files.begin(); s.ok() && it != new_files.end(); ++it) {
    s = DeleteFile(*it);
  }
  return s;
}",335.0,347.0,1.0,1.0,13.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,Status
1316,32021,DirWasSynced,1,leveldb.FaultInjectionTestEnv.DirWasSynced,void leveldb.FaultInjectionTestEnv.DirWasSynced (),db\fault_injection_test.cc,"void FaultInjectionTestEnv::DirWasSynced() {
  MutexLock l(&mutex_);
  new_files_since_last_dir_sync_.clear();
}",279.0,282.0,1.0,1.0,4.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1317,32025,IsFileCreatedSinceLastDirSync,1,leveldb.FaultInjectionTestEnv.IsFileCreatedSinceLastDirSync,bool leveldb.FaultInjectionTestEnv.IsFileCreatedSinceLastDirSync (ANY),db\fault_injection_test.cc,"bool FaultInjectionTestEnv::IsFileCreatedSinceLastDirSync(
    const std::string& filename) {
  MutexLock l(&mutex_);
  return new_files_since_last_dir_sync_.find(filename) !=
         new_files_since_last_dir_sync_.end();
}",284.0,289.0,1.0,1.0,6.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,bool
1318,32030,ResetState,1,leveldb.FaultInjectionTestEnv.ResetState,void leveldb.FaultInjectionTestEnv.ResetState (),db\fault_injection_test.cc,"void FaultInjectionTestEnv::ResetState() {
  // Since we are not destroying the database, the existing files
  // should keep their recorded synced/flushed state. Therefore
  // we do not reset db_file_state_ and new_files_since_last_dir_sync_.
  MutexLock l(&mutex_);
  SetFilesystemActive(true);
}",327.0,333.0,1.0,1.0,7.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1319,32034,UntrackFile,1,leveldb.FaultInjectionTestEnv.UntrackFile,void leveldb.FaultInjectionTestEnv.UntrackFile (ANY),db\fault_injection_test.cc,"void FaultInjectionTestEnv::UntrackFile(const std::string& f) {
  MutexLock l(&mutex_);
  db_file_state_.erase(f);
  new_files_since_last_dir_sync_.erase(f);
}",291.0,295.0,1.0,1.0,5.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
1320,32039,IsFilesystemActive,1,leveldb.FaultInjectionTestEnv.IsFilesystemActive,bool leveldb.FaultInjectionTestEnv.IsFilesystemActive (),db\fault_injection_test.cc,bool IsFilesystemActive() const { return filesystem_active_; },149.0,149.0,3.0,64.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,bool
1321,32045,SetFilesystemActive,1,leveldb.FaultInjectionTestEnv.SetFilesystemActive,void leveldb.FaultInjectionTestEnv.SetFilesystemActive (bool),db\fault_injection_test.cc,void SetFilesystemActive(bool active) { filesystem_active_ = active; },150.0,150.0,3.0,72.0,1.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
1322,32683,DropUnsyncedData,1,leveldb.FileState.DropUnsyncedData,Status leveldb.FileState.DropUnsyncedData (),db\fault_injection_test.cc,"Status FileState::DropUnsyncedData() const {
  ssize_t sync_pos = pos_at_last_sync_ == -1 ? 0 : pos_at_last_sync_;
  return Truncate(filename_, sync_pos);
}",354.0,357.0,1.0,1.0,4.0,4,4,5,3,0,0,1,1,0,0,,0,0,0,0,0,Status
1323,32713,FaultInjectionTest,1,leveldb.FaultInjectionTest.FaultInjectionTest,ANY leveldb.FaultInjectionTest.FaultInjectionTest (),db\fault_injection_test.cc,"FaultInjectionTest()
      : env_(new FaultInjectionTestEnv),
        tiny_cache_(NewLRUCache(100)),
        db_(NULL) {
    dbname_ = test::TmpDir() + ""/fault_test"";
    DestroyDB(dbname_, Options());  // Destroy any db from earlier run
    options_.reuse_logs = true;
    options_.env = env_;
    options_.paranoid_checks = true;
    options_.block_cache = tiny_cache_;
    options_.create_if_missing = true;
  }",370.0,381.0,3.0,3.0,12.0,13,3,10,5,0,9,1,1,0,0,,0,9,0,0,0,ANY
1324,32753,~FaultInjectionTest,1,leveldb.FaultInjectionTest.~FaultInjectionTest,ANY leveldb.FaultInjectionTest.~FaultInjectionTest (),db\fault_injection_test.cc,"~FaultInjectionTest() {
    CloseDB();
    DestroyDB(dbname_, Options());
    delete tiny_cache_;
    delete env_;
  }",383.0,388.0,3.0,3.0,6.0,2,1,3,3,0,3,1,1,0,0,,0,3,0,0,0,ANY
1325,32765,ReuseLogs,1,leveldb.FaultInjectionTest.ReuseLogs,void leveldb.FaultInjectionTest.ReuseLogs (bool),db\fault_injection_test.cc,"void ReuseLogs(bool reuse) {
    options_.reuse_logs = reuse;
  }",390.0,392.0,3.0,3.0,3.0,2,2,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
1326,32775,Build,1,leveldb.FaultInjectionTest.Build,"void leveldb.FaultInjectionTest.Build (int,int)",db\fault_injection_test.cc,"void Build(int start_idx, int num_vals) {
    std::string key_space, value_space;
    WriteBatch batch;
    for (int i = start_idx; i < start_idx + num_vals; i++) {
      Slice key = Key(i, &key_space);
      batch.Clear();
      batch.Put(key, Value(i, &value_space));
      WriteOptions options;
      ASSERT_OK(db_->Write(options, &batch));
    }
  }",394.0,404.0,3.0,6.0,11.0,13,6,18,10,0,1,2,2,0,0,,0,1,4,2,2,void
1327,32839,ReadValue,1,leveldb.FaultInjectionTest.ReadValue,"Status leveldb.FaultInjectionTest.ReadValue (int,ANY*)",db\fault_injection_test.cc,"Status ReadValue(int i, std::string* val) const {
    std::string key_space, value_space;
    Slice key = Key(i, &key_space);
    Value(i, &value_space);
    ReadOptions options;
    return db_->Get(options, key, val);
  }",406.0,412.0,3.0,3.0,7.0,4,3,9,7,0,1,1,1,0,0,,0,1,4,2,2,Status
1328,32867,Verify,1,leveldb.FaultInjectionTest.Verify,"Status leveldb.FaultInjectionTest.Verify (int,int,ExpectedVerifResult)",db\fault_injection_test.cc,"Status Verify(int start_idx, int num_vals,
                ExpectedVerifResult expected) const {
    std::string val;
    std::string value_space;
    Status s;
    for (int i = start_idx; i < start_idx + num_vals && s.ok(); i++) {
      Value(i, &value_space);
      s = ReadValue(i, &val);
      if (expected == VAL_EXPECT_NO_ERROR) {
        if (s.ok()) {
          ASSERT_EQ(value_space, val);
        }
      } else if (s.ok()) {
        fprintf(stderr, ""Expected an error at %d, but was OK\n"", i);
        s = Status::IOError(dbname_, ""Expected value error:"");
      } else {
        s = Status::OK();  // An expected error
      }
    }
    return s;
  }",414.0,434.0,3.0,10.0,21.0,13,7,21,9,0,1,4,7,1,0,,0,1,6,3,3,Status
1329,32964,Key,1,leveldb.FaultInjectionTest.Key,"Slice leveldb.FaultInjectionTest.Key (int,ANY*)",db\fault_injection_test.cc,"Slice Key(int i, std::string* storage) const {
    char buf[100];
    snprintf(buf, sizeof(buf), ""%016d"", i);
    storage->assign(buf, strlen(buf));
    return Slice(*storage);
  }",437.0,442.0,3.0,3.0,6.0,3,3,7,3,0,0,1,1,0,0,,0,0,4,2,2,Slice
1330,32988,Value,1,leveldb.FaultInjectionTest.Value,"Slice leveldb.FaultInjectionTest.Value (int,ANY*)",db\fault_injection_test.cc,"Slice Value(int k, std::string* storage) const {
    Random r(k);
    return test::RandomString(&r, kValueSize, storage);
  }",445.0,448.0,3.0,3.0,4.0,2,2,5,5,0,0,1,1,0,0,,0,0,4,2,2,Slice
1331,33006,OpenDB,1,leveldb.FaultInjectionTest.OpenDB,Status leveldb.FaultInjectionTest.OpenDB (),db\fault_injection_test.cc,"Status OpenDB() {
    delete db_;
    db_ = NULL;
    env_->ResetState();
    return DB::Open(options_, dbname_, &db_);
  }",450.0,455.0,3.0,3.0,6.0,5,5,8,6,0,6,1,1,0,0,,0,6,0,0,0,Status
1332,33028,CloseDB,1,leveldb.FaultInjectionTest.CloseDB,void leveldb.FaultInjectionTest.CloseDB (),db\fault_injection_test.cc,"void CloseDB() {
    delete db_;
    db_ = NULL;
  }",457.0,460.0,3.0,3.0,4.0,2,2,3,2,0,2,1,1,0,0,,0,2,0,0,0,void
1333,33037,DeleteAllData,1,leveldb.FaultInjectionTest.DeleteAllData,void leveldb.FaultInjectionTest.DeleteAllData (),db\fault_injection_test.cc,"void DeleteAllData() {
    Iterator* iter = db_->NewIterator(ReadOptions());
    WriteOptions options;
    for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {
      ASSERT_OK(db_->Delete(WriteOptions(), iter->key()));
    }

    delete iter;
  }",462.0,470.0,3.0,6.0,9.0,10,4,9,3,0,2,2,2,0,0,,0,2,0,0,0,void
1334,33089,ResetDBState,1,leveldb.FaultInjectionTest.ResetDBState,void leveldb.FaultInjectionTest.ResetDBState (ResetMethod),db\fault_injection_test.cc,"void ResetDBState(ResetMethod reset_method) {
    switch (reset_method) {
      case RESET_DROP_UNSYNCED_DATA:
        ASSERT_OK(env_->DropUnsyncedFileData());
        break;
      case RESET_DELETE_UNSYNCED_FILES:
        ASSERT_OK(env_->DeleteFilesCreatedAfterLastDirSync());
        break;
      default:
        assert(false);
    }
  }",472.0,483.0,3.0,8.0,12.0,10,2,11,6,0,6,4,2,0,0,,0,6,2,1,1,void
1335,33148,PartialCompactTestPreFault,1,leveldb.FaultInjectionTest.PartialCompactTestPreFault,"void leveldb.FaultInjectionTest.PartialCompactTestPreFault (int,int)",db\fault_injection_test.cc,"void PartialCompactTestPreFault(int num_pre_sync, int num_post_sync) {
    DeleteAllData();
    Build(0, num_pre_sync);
    db_->CompactRange(NULL, NULL);
    Build(num_pre_sync, num_post_sync);
  }",485.0,490.0,3.0,3.0,6.0,1,1,6,4,0,1,1,1,0,0,,0,1,4,2,2,void
1336,33167,PartialCompactTestReopenWithFault,1,leveldb.FaultInjectionTest.PartialCompactTestReopenWithFault,"void leveldb.FaultInjectionTest.PartialCompactTestReopenWithFault (ResetMethod,int,int)",db\fault_injection_test.cc,"void PartialCompactTestReopenWithFault(ResetMethod reset_method,
                                         int num_pre_sync,
                                         int num_post_sync) {
    env_->SetFilesystemActive(false);
    CloseDB();
    ResetDBState(reset_method);
    ASSERT_OK(OpenDB());
    ASSERT_OK(Verify(0, num_pre_sync, FaultInjectionTest::VAL_EXPECT_NO_ERROR));
    ASSERT_OK(Verify(num_pre_sync, num_post_sync, FaultInjectionTest::VAL_EXPECT_ERROR));
  }",492.0,501.0,3.0,4.0,10.0,12,2,13,7,0,3,1,1,0,0,,0,3,6,3,3,void
1337,33235,NoWriteTestPreFault,1,leveldb.FaultInjectionTest.NoWriteTestPreFault,void leveldb.FaultInjectionTest.NoWriteTestPreFault (),db\fault_injection_test.cc,"void NoWriteTestPreFault() {
  }",503.0,504.0,3.0,3.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1338,33239,NoWriteTestReopenWithFault,1,leveldb.FaultInjectionTest.NoWriteTestReopenWithFault,void leveldb.FaultInjectionTest.NoWriteTestReopenWithFault (ResetMethod),db\fault_injection_test.cc,"void NoWriteTestReopenWithFault(ResetMethod reset_method) {
    CloseDB();
    ResetDBState(reset_method);
    ASSERT_OK(OpenDB());
  }",506.0,510.0,3.0,4.0,5.0,3,1,3,2,0,0,1,1,0,0,,0,0,2,1,1,void
1339,33262,DoTest,1,leveldb.FaultInjectionTest.DoTest,void leveldb.FaultInjectionTest.DoTest (),db\fault_injection_test.cc,"void DoTest() {
    Random rnd(0);
    ASSERT_OK(OpenDB());
    for (size_t idx = 0; idx < kNumIterations; idx++) {
      int num_pre_sync = rnd.Uniform(kMaxNumValues);
      int num_post_sync = rnd.Uniform(kMaxNumValues);

      PartialCompactTestPreFault(num_pre_sync, num_post_sync);
      PartialCompactTestReopenWithFault(RESET_DROP_UNSYNCED_DATA,
                                        num_pre_sync,
                                        num_post_sync);

      NoWriteTestPreFault();
      NoWriteTestReopenWithFault(RESET_DROP_UNSYNCED_DATA);

      PartialCompactTestPreFault(num_pre_sync, num_post_sync);
      // No new files created so we expect all values since no files will be
      // dropped.
      PartialCompactTestReopenWithFault(RESET_DELETE_UNSYNCED_FILES,
                                        num_pre_sync + num_post_sync,
                                        0);

      NoWriteTestPreFault();
      NoWriteTestReopenWithFault(RESET_DELETE_UNSYNCED_FILES);
    }
  }",512.0,537.0,3.0,4.0,26.0,10,4,23,9,0,4,2,2,0,0,,0,4,0,0,0,void
1340,33335,_Run,1,leveldb._Test_FaultTestNoLogReuse._Run,void leveldb._Test_FaultTestNoLogReuse._Run (),db\fault_injection_test.cc,"TEST(FaultInjectionTest, FaultTestNoLogReuse) {
  ReuseLogs(false);
  DoTest();
}",540.0,543.0,1.0,45.0,4.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1341,33339,_RunIt,1,leveldb._Test_FaultTestNoLogReuse._RunIt,void leveldb._Test_FaultTestNoLogReuse._RunIt (),db\fault_injection_test.cc,"TEST(FaultInjectionTest, FaultTestNoLogReuse)",540.0,540.0,1.0,45.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1342,33371,_Run,1,leveldb._Test_FaultTestWithLogReuse._Run,void leveldb._Test_FaultTestWithLogReuse._Run (),db\fault_injection_test.cc,"TEST(FaultInjectionTest, FaultTestWithLogReuse) {
  ReuseLogs(true);
  DoTest();
}",545.0,548.0,1.0,47.0,4.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1343,33375,_RunIt,1,leveldb._Test_FaultTestWithLogReuse._RunIt,void leveldb._Test_FaultTestWithLogReuse._RunIt (),db\fault_injection_test.cc,"TEST(FaultInjectionTest, FaultTestWithLogReuse)",545.0,545.0,1.0,47.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1344,33437,WriteStringToFileSync,1,leveldb.WriteStringToFileSync,"Status leveldb.WriteStringToFileSync (Env*,Slice,ANY)",util\env.cc,"Status WriteStringToFileSync(Env* env, const Slice& data,
                             const std::string& fname) {
  return DoWriteStringToFile(env, data, fname, true);
}",67.0,70.0,1.0,1.0,4.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,Status
1345,33444,MakeFileName,1,leveldb.MakeFileName,"string leveldb.MakeFileName (ANY,uint64_t,char*)",db\filename.cc,"static std::string MakeFileName(const std::string& name, uint64_t number,
                                const char* suffix) {
  char buf[100];
  snprintf(buf, sizeof(buf), ""/%06llu.%s"",
           static_cast<unsigned long long>(number),
           suffix);
  return name + buf;
}",18.0,25.0,1.0,1.0,8.0,3,3,6,4,0,0,1,1,0,0,,0,0,6,3,3,string
1346,33465,LogFileName,1,leveldb.LogFileName,"string leveldb.LogFileName (ANY,uint64_t)",db\filename.cc,"std::string LogFileName(const std::string& name, uint64_t number) {
  assert(number > 0);
  return MakeFileName(name, number, ""log"");
}",27.0,30.0,1.0,1.0,4.0,1,1,3,2,0,0,1,1,0,0,,0,0,4,2,2,string
1347,33480,TableFileName,1,leveldb.TableFileName,"string leveldb.TableFileName (ANY,uint64_t)",db\filename.cc,"std::string TableFileName(const std::string& name, uint64_t number) {
  assert(number > 0);
  return MakeFileName(name, number, ""ldb"");
}",32.0,35.0,1.0,1.0,4.0,1,1,3,2,0,0,1,1,0,0,,0,0,4,2,2,string
1348,33495,SSTTableFileName,1,leveldb.SSTTableFileName,"string leveldb.SSTTableFileName (ANY,uint64_t)",db\filename.cc,"std::string SSTTableFileName(const std::string& name, uint64_t number) {
  assert(number > 0);
  return MakeFileName(name, number, ""sst"");
}",37.0,40.0,1.0,1.0,4.0,1,1,3,2,0,0,1,1,0,0,,0,0,4,2,2,string
1349,33510,DescriptorFileName,1,leveldb.DescriptorFileName,"string leveldb.DescriptorFileName (ANY,uint64_t)",db\filename.cc,"std::string DescriptorFileName(const std::string& dbname, uint64_t number) {
  assert(number > 0);
  char buf[100];
  snprintf(buf, sizeof(buf), ""/MANIFEST-%06llu"",
           static_cast<unsigned long long>(number));
  return dbname + buf;
}",42.0,48.0,1.0,1.0,7.0,4,4,6,3,0,0,1,1,0,0,,0,0,4,2,2,string
1350,33533,CurrentFileName,1,leveldb.CurrentFileName,string leveldb.CurrentFileName (ANY),db\filename.cc,"std::string CurrentFileName(const std::string& dbname) {
  return dbname + ""/CURRENT"";
}",50.0,52.0,1.0,1.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,string
1351,33542,LockFileName,1,leveldb.LockFileName,string leveldb.LockFileName (ANY),db\filename.cc,"std::string LockFileName(const std::string& dbname) {
  return dbname + ""/LOCK"";
}",54.0,56.0,1.0,1.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,string
1352,33551,TempFileName,1,leveldb.TempFileName,"string leveldb.TempFileName (ANY,uint64_t)",db\filename.cc,"std::string TempFileName(const std::string& dbname, uint64_t number) {
  assert(number > 0);
  return MakeFileName(dbname, number, ""dbtmp"");
}",58.0,61.0,1.0,1.0,4.0,1,1,3,2,0,0,1,1,0,0,,0,0,4,2,2,string
1353,33566,InfoLogFileName,1,leveldb.InfoLogFileName,string leveldb.InfoLogFileName (ANY),db\filename.cc,"std::string InfoLogFileName(const std::string& dbname) {
  return dbname + ""/LOG"";
}",63.0,65.0,1.0,1.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,string
1354,33575,OldInfoLogFileName,1,leveldb.OldInfoLogFileName,string leveldb.OldInfoLogFileName (ANY),db\filename.cc,"std::string OldInfoLogFileName(const std::string& dbname) {
  return dbname + ""/LOG.old"";
}",68.0,70.0,1.0,1.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,string
1355,33584,ParseFileName,1,leveldb.ParseFileName,"bool leveldb.ParseFileName (ANY,uint64_t*,FileType*)",db\filename.cc,"bool ParseFileName(const std::string& fname,
                   uint64_t* number,
                   FileType* type) {
  Slice rest(fname);
  if (rest == ""CURRENT"") {
    *number = 0;
    *type = kCurrentFile;
  } else if (rest == ""LOCK"") {
    *number = 0;
    *type = kDBLockFile;
  } else if (rest == ""LOG"" || rest == ""LOG.old"") {
    *number = 0;
    *type = kInfoLogFile;
  } else if (rest.starts_with(""MANIFEST-"")) {
    rest.remove_prefix(strlen(""MANIFEST-""));
    uint64_t num;
    if (!ConsumeDecimalNumber(&rest, &num)) {
      return false;
    }
    if (!rest.empty()) {
      return false;
    }
    *type = kDescriptorFile;
    *number = num;
  } else {
    // Avoid strtoull() to keep filename format independent of the
    // current locale
    uint64_t num;
    if (!ConsumeDecimalNumber(&rest, &num)) {
      return false;
    }
    Slice suffix = rest;
    if (suffix == Slice("".log"")) {
      *type = kLogFile;
    } else if (suffix == Slice("".sst"") || suffix == Slice("".ldb""))...",80.0,124.0,1.0,1.0,45.0,5,3,5,5,0,0,2,2,0,0,,0,0,6,3,3,bool
1356,33750,SetCurrentFile,1,leveldb.SetCurrentFile,"Status leveldb.SetCurrentFile (Env*,ANY,uint64_t)",db\filename.cc,"Status SetCurrentFile(Env* env, const std::string& dbname,
                      uint64_t descriptor_number) {
  // Remove leading ""dbname/"" and add newline to manifest file name
  std::string manifest = DescriptorFileName(dbname, descriptor_number);
  Slice contents = manifest;
  assert(contents.starts_with(dbname + ""/""));
  contents.remove_prefix(dbname.size() + 1);
  std::string tmp = TempFileName(dbname, descriptor_number);
  Status s = WriteStringToFileSync(env, contents.ToString() + ""\n"", tmp);
  if (s.ok()) {
    s = env->RenameFile(tmp, CurrentFileName(dbname));
  }
  if (!s.ok()) {
    env->DeleteFile(tmp);
  }
  return s;
}",126.0,142.0,1.0,1.0,17.0,17,5,25,7,0,0,3,3,0,0,,0,0,6,3,3,Status
1357,33939,_Run,1,leveldb._Test_Parse._Run,void leveldb._Test_Parse._Run (),db\filename_test.cc,"TEST(FileNameTest, Parse) {
  Slice db;
  FileType type;
  uint64_t number;

  // Successful parses
  static struct {
    const char* fname;
    uint64_t number;
    FileType type;
  } cases[] = {
    { ""100.log"",            100,   kLogFile },
    { ""0.log"",              0,     kLogFile },
    { ""0.sst"",              0,     kTableFile },
    { ""0.ldb"",              0,     kTableFile },
    { ""CURRENT"",            0,     kCurrentFile },
    { ""LOCK"",               0,     kDBLockFile },
    { ""MANIFEST-2"",         2,     kDescriptorFile },
    { ""MANIFEST-7"",         7,     kDescriptorFile },
    { ""LOG"",                0,     kInfoLogFile },
    { ""LOG.old"",            0,     kInfoLogFile },
    { ""18446744073709551615.log"", 18446744073709551615ull, kLogFile },
  };
  for (int i = 0; i < sizeof(cases) / sizeof(cases[0]); i++) {
    std::string f = cases[i].fname;
    ASSERT_TRUE(ParseFileName(f, &number, &type)) << f;
    ASSERT_EQ(cases[i].type, type) << f;
    ASSERT_EQ(cases[i].nu...",16.0,75.0,1.0,25.0,60.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1358,33943,_RunIt,1,leveldb._Test_Parse._RunIt,void leveldb._Test_Parse._RunIt (),db\filename_test.cc,"TEST(FileNameTest, Parse)",16.0,16.0,1.0,25.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1359,34198,_Run,1,leveldb._Test_Construction._Run,void leveldb._Test_Construction._Run (),db\filename_test.cc,"TEST(FileNameTest, Construction) {
  uint64_t number;
  FileType type;
  std::string fname;

  fname = CurrentFileName(""foo"");
  ASSERT_EQ(""foo/"", std::string(fname.data(), 4));
  ASSERT_TRUE(ParseFileName(fname.c_str() + 4, &number, &type));
  ASSERT_EQ(0, number);
  ASSERT_EQ(kCurrentFile, type);

  fname = LockFileName(""foo"");
  ASSERT_EQ(""foo/"", std::string(fname.data(), 4));
  ASSERT_TRUE(ParseFileName(fname.c_str() + 4, &number, &type));
  ASSERT_EQ(0, number);
  ASSERT_EQ(kDBLockFile, type);

  fname = LogFileName(""foo"", 192);
  ASSERT_EQ(""foo/"", std::string(fname.data(), 4));
  ASSERT_TRUE(ParseFileName(fname.c_str() + 4, &number, &type));
  ASSERT_EQ(192, number);
  ASSERT_EQ(kLogFile, type);

  fname = TableFileName(""bar"", 200);
  ASSERT_EQ(""bar/"", std::string(fname.data(), 4));
  ASSERT_TRUE(ParseFileName(fname.c_str() + 4, &number, &type));
  ASSERT_EQ(200, number);
  ASSERT_EQ(kTableFile, type);

  fname = DescriptorFileName(""bar"", 100);
  ASSERT_EQ(""bar/"", std::string(...",77.0,117.0,1.0,32.0,41.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1360,34202,_RunIt,1,leveldb._Test_Construction._RunIt,void leveldb._Test_Construction._RunIt (),db\filename_test.cc,"TEST(FileNameTest, Construction)",77.0,77.0,1.0,32.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1361,34788,Append,1,leveldb.anonymous_namespace_2.StdoutPrinter.Append,Status leveldb.anonymous_namespace_2.StdoutPrinter.Append (Slice),db\leveldbutil.cc,"virtual Status Append(const Slice& data) {
    fwrite(data.data(), 1, data.size(), stdout);
    return Status::OK();
  }",15.0,18.0,3.0,3.0,4.0,3,1,4,3,0,1,1,1,0,0,,0,0,2,1,1,Status
1362,34809,Close,1,leveldb.anonymous_namespace_3.StdoutPrinter.Close,Status leveldb.anonymous_namespace_3.StdoutPrinter.Close (),db\leveldbutil.cc,virtual Status Close() { return Status::OK(); },19.0,19.0,3.0,49.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,0,0,0,0,Status
1363,34818,Flush,1,leveldb.anonymous_namespace_4.StdoutPrinter.Flush,Status leveldb.anonymous_namespace_4.StdoutPrinter.Flush (),db\leveldbutil.cc,virtual Status Flush() { return Status::OK(); },20.0,20.0,3.0,49.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,0,0,0,0,Status
1364,34827,Sync,1,leveldb.anonymous_namespace_5.StdoutPrinter.Sync,Status leveldb.anonymous_namespace_5.StdoutPrinter.Sync (),db\leveldbutil.cc,virtual Status Sync() { return Status::OK(); },21.0,21.0,3.0,48.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,0,0,0,0,Status
1365,34836,HandleDumpCommand,1,leveldb.anonymous_namespace_6.HandleDumpCommand,"bool leveldb.anonymous_namespace_6.HandleDumpCommand (Env*,char**,int)",db\leveldbutil.cc,"bool HandleDumpCommand(Env* env, char** files, int num) {
  StdoutPrinter printer;
  bool ok = true;
  for (int i = 0; i < num; i++) {
    Status s = DumpFile(env, files[i], &printer);
    if (!s.ok()) {
      fprintf(stderr, ""%s\n"", s.ToString().c_str());
      ok = false;
    }
  }
  return ok;
}",24.0,35.0,1.0,1.0,12.0,11,6,14,8,0,0,3,4,0,0,,0,0,6,3,3,bool
1366,34892,Usage,1,Usage,void Usage (),db\leveldbutil.cc,"static void Usage() {
  fprintf(
      stderr,
      ""Usage: leveldbutil command...\n""
      ""   dump files...         -- dump contents of specified files\n""
      );
}",40.0,46.0,1.0,1.0,7.0,0,0,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1367,35029,~Reporter,1,leveldb.log.Reader.Reporter.~Reporter,ANY leveldb.log.Reader.Reporter.~Reporter (),db\log_reader.cc,"Reader::Reporter::~Reporter() {
}",15.0,16.0,1.0,1.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
1368,35033,Reader,1,leveldb.log.Reader.Reader,"ANY leveldb.log.Reader.Reader (SequentialFile*,Reporter*,bool,uint64_t)",db\log_reader.cc,"Reader::Reader(SequentialFile* file, Reporter* reporter, bool checksum,
               uint64_t initial_offset)
    : file_(file),
      reporter_(reporter),
      checksum_(checksum),
      backing_store_(new char[kBlockSize]),
      buffer_(),
      eof_(false),
      last_record_offset_(0),
      end_of_buffer_offset_(0),
      initial_offset_(initial_offset),
      resyncing_(initial_offset > 0) {
}",18.0,30.0,1.0,1.0,13.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,ANY
1369,35041,~Reader,1,leveldb.log.Reader.~Reader,ANY leveldb.log.Reader.~Reader (),db\log_reader.cc,"Reader::~Reader() {
  delete[] backing_store_;
}",32.0,34.0,1.0,1.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,ANY
1370,35047,SkipToInitialBlock,1,leveldb.log.Reader.SkipToInitialBlock,bool leveldb.log.Reader.SkipToInitialBlock (),db\log_reader.cc,"bool Reader::SkipToInitialBlock() {
  size_t offset_in_block = initial_offset_ % kBlockSize;
  uint64_t block_start_location = initial_offset_ - offset_in_block;

  // Don't search a block if we'd be in the trailer
  if (offset_in_block > kBlockSize - 6) {
    offset_in_block = 0;
    block_start_location += kBlockSize;
  }

  end_of_buffer_offset_ = block_start_location;

  // Skip to start of first block that can contain the initial record
  if (block_start_location > 0) {
    Status skip_status = file_->Skip(block_start_location);
    if (!skip_status.ok()) {
      ReportDrop(block_start_location, skip_status);
      return false;
    }
  }

  return true;
}",36.0,58.0,1.0,1.0,23.0,14,8,20,7,0,4,4,5,0,0,,0,4,0,0,0,bool
1371,35106,ReadRecord,1,leveldb.log.Reader.ReadRecord,"bool leveldb.log.Reader.ReadRecord (Slice*,ANY*)",db\log_reader.cc,"bool Reader::ReadRecord(Slice* record, std::string* scratch) {
  if (last_record_offset_ < initial_offset_) {
    if (!SkipToInitialBlock()) {
      return false;
    }
  }

  scratch->clear();
  record->clear();
  bool in_fragmented_record = false;
  // Record offset of the logical record that we're reading
  // 0 is a dummy value to make compilers happy
  uint64_t prospective_record_offset = 0;

  Slice fragment;
  while (true) {
    const unsigned int record_type = ReadPhysicalRecord(&fragment);

    // ReadPhysicalRecord may have only had an empty trailer remaining in its
    // internal buffer. Calculate the offset of the next physical record now
    // that it has returned, properly accounting for its header size.
    uint64_t physical_record_offset =
        end_of_buffer_offset_ - buffer_.size() - kHeaderSize - fragment.size();

    if (resyncing_) {
      if (record_type == kMiddleType) {
        continue;
      } else if (record_type == kLastType) {
        resyncing_ = fa...",60.0,182.0,1.0,1.0,123.0,44,12,61,20,0,8,21,38,3,0,,0,8,4,2,2,bool
1372,35400,LastRecordOffset,1,leveldb.log.Reader.LastRecordOffset,uint64_t leveldb.log.Reader.LastRecordOffset (),db\log_reader.cc,"uint64_t Reader::LastRecordOffset() {
  return last_record_offset_;
}",184.0,186.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,uint64_t
1373,35406,ReportCorruption,1,leveldb.log.Reader.ReportCorruption,"void leveldb.log.Reader.ReportCorruption (uint64_t,char*)",db\log_reader.cc,"void Reader::ReportCorruption(uint64_t bytes, const char* reason) {
  ReportDrop(bytes, Status::Corruption(reason));
}",188.0,190.0,1.0,1.0,3.0,1,1,3,3,0,1,1,1,0,1,,0,0,4,2,2,void
1374,35419,ReportDrop,1,leveldb.log.Reader.ReportDrop,"void leveldb.log.Reader.ReportDrop (uint64_t,Status)",db\log_reader.cc,"void Reader::ReportDrop(uint64_t bytes, const Status& reason) {
  if (reporter_ != NULL &&
      end_of_buffer_offset_ - buffer_.size() - bytes >= initial_offset_) {
    reporter_->Corruption(static_cast<size_t>(bytes), reason);
  }
}",192.0,197.0,1.0,1.0,6.0,8,7,9,7,0,5,2,2,4,0,,0,5,4,2,2,void
1375,35449,ReadPhysicalRecord,1,leveldb.log.Reader.ReadPhysicalRecord,unsigned int leveldb.log.Reader.ReadPhysicalRecord (Slice*),db\log_reader.cc,"unsigned int Reader::ReadPhysicalRecord(Slice* result) {
  while (true) {
    if (buffer_.size() < kHeaderSize) {
      if (!eof_) {
        // Last read was a full read, so this is a trailer to skip
        buffer_.clear();
        Status status = file_->Read(kBlockSize, &buffer_, backing_store_);
        end_of_buffer_offset_ += buffer_.size();
        if (!status.ok()) {
          buffer_.clear();
          ReportDrop(kBlockSize, status);
          eof_ = true;
          return kEof;
        } else if (buffer_.size() < kBlockSize) {
          eof_ = true;
        }
        continue;
      } else {
        // Note that if buffer_ is non-empty, we have a truncated header at the
        // end of the file, which can be caused by the writer crashing in the
        // middle of writing the header. Instead of considering this an error,
        // just report EOF.
        buffer_.clear();
        return kEof;
      }
    }

    // Parse the header
    const char* header = buffer_.data()...",199.0,281.0,1.0,1.0,83.0,60,19,73,23,0,29,12,25,8,0,,0,29,2,1,1,unsigned int
1376,35724,Corruption,1,leveldb.log.Reader.Reporter.Corruption,"void leveldb.log.Reader.Reporter.Corruption (size_t,Status)",db\log_reader.hpp,"virtual void Corruption(size_t bytes, const Status& status) = 0;",29.0,29.0,18.0,67.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
1377,35805,operator =,1,leveldb.log.Reader.operator =,void leveldb.log.Reader.operator = (Reader),db\log_reader.hpp,void operator=(const Reader&);,107.0,107.0,8.0,31.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
1378,35831,BigString,1,leveldb.log.BigString,"string leveldb.log.BigString (ANY,size_t)",db\log_test.cc,"static std::string BigString(const std::string& partial_string, size_t n) {
  std::string result;
  while (result.size() < n) {
    result.append(partial_string);
  }
  result.resize(n);
  return result;
}",18.0,25.0,1.0,1.0,8.0,4,2,7,3,0,0,2,2,0,0,,0,0,4,2,2,string
1379,35858,NumberString,1,leveldb.log.NumberString,string leveldb.log.NumberString (int),db\log_test.cc,"static std::string NumberString(int n) {
  char buf[50];
  snprintf(buf, sizeof(buf), ""%d."", n);
  return std::string(buf);
}",28.0,32.0,1.0,1.0,5.0,2,2,5,3,0,0,1,1,0,0,,0,0,2,1,1,string
1380,35876,RandomSkewedString,1,leveldb.log.RandomSkewedString,"string leveldb.log.RandomSkewedString (int,Random*)",db\log_test.cc,"static std::string RandomSkewedString(int i, Random* rnd) {
  return BigString(NumberString(i), rnd->Skewed(17));
}",35.0,37.0,1.0,1.0,3.0,1,1,2,2,0,0,1,1,0,0,,0,0,4,2,2,string
1381,35894,Close,1,leveldb.log.LogTest.StringDest.Close,Status leveldb.log.LogTest.StringDest.Close (),db\log_test.cc,virtual Status Close() { return Status::OK(); },45.0,45.0,5.0,51.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,0,0,0,0,Status
1382,35903,Flush,1,leveldb.log.LogTest.StringDest.Flush,Status leveldb.log.LogTest.StringDest.Flush (),db\log_test.cc,virtual Status Flush() { return Status::OK(); },46.0,46.0,5.0,51.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,0,0,0,0,Status
1383,35912,Sync,1,leveldb.log.LogTest.StringDest.Sync,Status leveldb.log.LogTest.StringDest.Sync (),db\log_test.cc,virtual Status Sync() { return Status::OK(); },47.0,47.0,5.0,50.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,0,0,0,0,Status
1384,35921,Append,1,leveldb.log.LogTest.StringDest.Append,Status leveldb.log.LogTest.StringDest.Append (Slice),db\log_test.cc,"virtual Status Append(const Slice& slice) {
      contents_.append(slice.data(), slice.size());
      return Status::OK();
    }",48.0,51.0,5.0,5.0,4.0,4,1,4,3,0,2,1,1,0,0,,0,1,2,1,1,Status
1385,35947,StringSource,1,leveldb.log.LogTest.StringSource.StringSource,ANY leveldb.log.LogTest.StringSource.StringSource (),db\log_test.cc,"StringSource() : force_error_(false), returned_partial_(false) { }",59.0,59.0,5.0,70.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
1386,35951,Read,1,leveldb.log.LogTest.StringSource.Read,"Status leveldb.log.LogTest.StringSource.Read (size_t,Slice*,char*)",db\log_test.cc,"virtual Status Read(size_t n, Slice* result, char* scratch) {
      ASSERT_TRUE(!returned_partial_) << ""must not Read() after eof/error"";

      if (force_error_) {
        force_error_ = false;
        returned_partial_ = true;
        return Status::Corruption(""read error"");
      }

      if (contents_.size() < n) {
        n = contents_.size();
        returned_partial_ = true;
      }
      *result = Slice(contents_.data(), n);
      contents_.remove_prefix(n);
      return Status::OK();
    }",61.0,77.0,5.0,6.0,17.0,19,6,19,7,0,12,3,3,2,1,,0,10,6,3,3,Status
1387,36029,Skip,1,leveldb.log.LogTest.StringSource.Skip,Status leveldb.log.LogTest.StringSource.Skip (uint64_t),db\log_test.cc,"virtual Status Skip(uint64_t n) {
      if (n > contents_.size()) {
        contents_.clear();
        return Status::NotFound(""in-memory file skipped past end"");
      }

      contents_.remove_prefix(n);

      return Status::OK();
    }",79.0,88.0,5.0,5.0,10.0,6,2,7,3,0,5,2,2,1,1,,0,3,2,1,1,Status
1388,36065,ReportCollector,1,leveldb.log.LogTest.ReportCollector.ReportCollector,ANY leveldb.log.LogTest.ReportCollector.ReportCollector (),db\log_test.cc,ReportCollector() : dropped_bytes_(0) { },96.0,96.0,5.0,45.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
1389,36069,Corruption,1,leveldb.log.LogTest.ReportCollector.Corruption,"void leveldb.log.LogTest.ReportCollector.Corruption (size_t,Status)",db\log_test.cc,"virtual void Corruption(size_t bytes, const Status& status) {
      dropped_bytes_ += bytes;
      message_.append(status.ToString());
    }",97.0,100.0,5.0,5.0,4.0,3,2,4,4,0,2,1,1,0,0,,0,2,4,2,2,void
1390,36095,LogTest,1,leveldb.log.LogTest.LogTest,ANY leveldb.log.LogTest.LogTest (),db\log_test.cc,"LogTest() : reading_(false),
              writer_(new Writer(&dest_)),
              reader_(new Reader(&source_, &report_, true/*checksum*/,
                      0/*initial_offset*/)) {
  }",116.0,120.0,3.0,3.0,5.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
1391,36099,~LogTest,1,leveldb.log.LogTest.~LogTest,ANY leveldb.log.LogTest.~LogTest (),db\log_test.cc,"~LogTest() {
    delete writer_;
    delete reader_;
  }",122.0,125.0,3.0,3.0,4.0,2,1,2,2,0,2,1,1,0,0,,0,2,0,0,0,ANY
1392,36107,ReopenForAppend,1,leveldb.log.LogTest.ReopenForAppend,void leveldb.log.LogTest.ReopenForAppend (),db\log_test.cc,"void ReopenForAppend() {
    delete writer_;
    writer_ = new Writer(&dest_, dest_.contents_.size());
  }",127.0,130.0,3.0,3.0,4.0,6,5,5,3,0,5,1,1,0,0,,0,5,0,0,0,void
1393,36125,Write,1,leveldb.log.LogTest.Write,void leveldb.log.LogTest.Write (ANY),db\log_test.cc,"void Write(const std::string& msg) {
    ASSERT_TRUE(!reading_) << ""Write() after starting to read"";
    writer_->AddRecord(Slice(msg));
  }",132.0,135.0,3.0,4.0,4.0,7,4,6,4,0,3,1,1,0,0,,0,3,2,1,1,void
1394,36156,WrittenBytes,1,leveldb.log.LogTest.WrittenBytes,size_t leveldb.log.LogTest.WrittenBytes (),db\log_test.cc,"size_t WrittenBytes() const {
    return dest_.contents_.size();
  }",137.0,139.0,3.0,3.0,3.0,2,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,size_t
1395,36167,Read,1,leveldb.log.LogTest.Read,string leveldb.log.LogTest.Read (),db\log_test.cc,"std::string Read() {
    if (!reading_) {
      reading_ = true;
      source_.contents_ = Slice(dest_.contents_);
    }
    std::string scratch;
    Slice record;
    if (reader_->ReadRecord(&record, &scratch)) {
      return record.ToString();
    } else {
      return ""EOF"";
    }
  }",141.0,153.0,3.0,3.0,13.0,9,5,8,6,0,7,3,3,2,0,,0,7,0,0,0,string
1396,36207,IncrementByte,1,leveldb.log.LogTest.IncrementByte,"void leveldb.log.LogTest.IncrementByte (int,int)",db\log_test.cc,"void IncrementByte(int offset, int delta) {
    dest_.contents_[offset] += delta;
  }",155.0,157.0,3.0,3.0,3.0,3,3,3,3,0,2,1,1,0,0,,0,2,4,2,2,void
1397,36220,SetByte,1,leveldb.log.LogTest.SetByte,"void leveldb.log.LogTest.SetByte (int,char)",db\log_test.cc,"void SetByte(int offset, char new_byte) {
    dest_.contents_[offset] = new_byte;
  }",159.0,161.0,3.0,3.0,3.0,3,3,3,3,0,2,1,1,0,0,,0,2,4,2,2,void
1398,36233,ShrinkSize,1,leveldb.log.LogTest.ShrinkSize,void leveldb.log.LogTest.ShrinkSize (int),db\log_test.cc,"void ShrinkSize(int bytes) {
    dest_.contents_.resize(dest_.contents_.size() - bytes);
  }",163.0,165.0,3.0,3.0,3.0,5,2,3,2,0,4,1,1,0,0,,0,4,2,1,1,void
1399,36252,FixChecksum,1,leveldb.log.LogTest.FixChecksum,"void leveldb.log.LogTest.FixChecksum (int,int)",db\log_test.cc,"void FixChecksum(int header_offset, int len) {
    // Compute crc of type/len/data
    uint32_t crc = crc32c::Value(&dest_.contents_[header_offset+6], 1 + len);
    crc = crc32c::Mask(crc);
    EncodeFixed32(&dest_.contents_[header_offset], crc);
  }",167.0,172.0,3.0,3.0,6.0,12,5,11,5,0,4,1,1,0,0,,0,4,4,2,2,void
1400,36291,ForceError,1,leveldb.log.LogTest.ForceError,void leveldb.log.LogTest.ForceError (),db\log_test.cc,"void ForceError() {
    source_.force_error_ = true;
  }",174.0,176.0,3.0,3.0,3.0,2,2,1,1,0,2,1,1,0,0,,0,2,0,0,0,void
1401,36300,DroppedBytes,1,leveldb.log.LogTest.DroppedBytes,size_t leveldb.log.LogTest.DroppedBytes (),db\log_test.cc,"size_t DroppedBytes() const {
    return report_.dropped_bytes_;
  }",178.0,180.0,3.0,3.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,size_t
1402,36308,ReportMessage,1,leveldb.log.LogTest.ReportMessage,string leveldb.log.LogTest.ReportMessage (),db\log_test.cc,"std::string ReportMessage() const {
    return report_.message_;
  }",182.0,184.0,3.0,3.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,string
1403,36316,MatchError,1,leveldb.log.LogTest.MatchError,string leveldb.log.LogTest.MatchError (ANY),db\log_test.cc,"std::string MatchError(const std::string& msg) const {
    if (report_.message_.find(msg) == std::string::npos) {
      return report_.message_;
    } else {
      return ""OK"";
    }
  }",187.0,193.0,3.0,3.0,7.0,6,2,5,4,0,2,2,2,1,0,,0,2,2,1,1,string
1404,36344,WriteInitialOffsetLog,1,leveldb.log.LogTest.WriteInitialOffsetLog,void leveldb.log.LogTest.WriteInitialOffsetLog (),db\log_test.cc,"void WriteInitialOffsetLog() {
    for (int i = 0; i < num_initial_offset_records_; i++) {
      std::string record(initial_offset_record_sizes_[i],
                         static_cast<char>('a' + i));
      Write(record);
    }
  }",195.0,201.0,3.0,3.0,7.0,5,5,7,4,0,2,2,2,1,0,,0,2,0,0,0,void
1405,36372,StartReadingAt,1,leveldb.log.LogTest.StartReadingAt,void leveldb.log.LogTest.StartReadingAt (uint64_t),db\log_test.cc,"void StartReadingAt(uint64_t initial_offset) {
    delete reader_;
    reader_ = new Reader(&source_, &report_, true/*checksum*/, initial_offset);
  }",203.0,206.0,3.0,3.0,4.0,5,4,6,5,0,4,1,1,0,0,,0,4,2,1,1,void
1406,36389,CheckOffsetPastEndReturnsNoRecords,1,leveldb.log.LogTest.CheckOffsetPastEndReturnsNoRecords,void leveldb.log.LogTest.CheckOffsetPastEndReturnsNoRecords (uint64_t),db\log_test.cc,"void CheckOffsetPastEndReturnsNoRecords(uint64_t offset_past_end) {
    WriteInitialOffsetLog();
    reading_ = true;
    source_.contents_ = Slice(dest_.contents_);
    Reader* offset_reader = new Reader(&source_, &report_, true/*checksum*/,
                                       WrittenBytes() + offset_past_end);
    Slice record;
    std::string scratch;
    ASSERT_TRUE(!offset_reader->ReadRecord(&record, &scratch));
    delete offset_reader;
  }",208.0,218.0,3.0,4.0,11.0,17,8,14,10,0,7,1,1,0,0,,0,7,2,1,1,void
1407,36446,CheckInitialOffsetRecord,1,leveldb.log.LogTest.CheckInitialOffsetRecord,"void leveldb.log.LogTest.CheckInitialOffsetRecord (uint64_t,int)",db\log_test.cc,"void CheckInitialOffsetRecord(uint64_t initial_offset,
                                int expected_record_offset) {
    WriteInitialOffsetLog();
    reading_ = true;
    source_.contents_ = Slice(dest_.contents_);
    Reader* offset_reader = new Reader(&source_, &report_, true/*checksum*/,
                                       initial_offset);

    // Read all records from expected_record_offset through the last one.
    ASSERT_LT(expected_record_offset, num_initial_offset_records_);
    for (; expected_record_offset < num_initial_offset_records_;
         ++expected_record_offset) {
      Slice record;
      std::string scratch;
      ASSERT_TRUE(offset_reader->ReadRecord(&record, &scratch));
      ASSERT_EQ(initial_offset_record_sizes_[expected_record_offset],
                record.size());
      ASSERT_EQ(initial_offset_last_record_offsets_[expected_record_offset],
                offset_reader->LastRecordOffset());
      ASSERT_EQ((char)('a' + expected_record_offset), record....",220.0,242.0,3.0,4.0,23.0,42,10,43,18,0,14,2,2,1,0,,0,14,4,2,2,void
1408,36703,_Run,1,leveldb.log._Test_Empty._Run,void leveldb.log._Test_Empty._Run (),db\log_test.cc,"TEST(LogTest, Empty) {
  ASSERT_EQ(""EOF"", Read());
}",270.0,272.0,1.0,20.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1409,36707,_RunIt,1,leveldb.log._Test_Empty._RunIt,void leveldb.log._Test_Empty._RunIt (),db\log_test.cc,"TEST(LogTest, Empty)",270.0,270.0,1.0,20.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1410,36753,_Run,1,leveldb.log._Test_ReadWrite._Run,void leveldb.log._Test_ReadWrite._Run (),db\log_test.cc,"TEST(LogTest, ReadWrite) {
  Write(""foo"");
  Write(""bar"");
  Write("""");
  Write(""xxxx"");
  ASSERT_EQ(""foo"", Read());
  ASSERT_EQ(""bar"", Read());
  ASSERT_EQ("""", Read());
  ASSERT_EQ(""xxxx"", Read());
  ASSERT_EQ(""EOF"", Read());
  ASSERT_EQ(""EOF"", Read());  // Make sure reads at eof work
}",274.0,285.0,1.0,24.0,12.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1411,36757,_RunIt,1,leveldb.log._Test_ReadWrite._RunIt,void leveldb.log._Test_ReadWrite._RunIt (),db\log_test.cc,"TEST(LogTest, ReadWrite)",274.0,274.0,1.0,24.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1412,36896,_Run,1,leveldb.log._Test_ManyBlocks._Run,void leveldb.log._Test_ManyBlocks._Run (),db\log_test.cc,"TEST(LogTest, ManyBlocks) {
  for (int i = 0; i < 100000; i++) {
    Write(NumberString(i));
  }
  for (int i = 0; i < 100000; i++) {
    ASSERT_EQ(NumberString(i), Read());
  }
  ASSERT_EQ(""EOF"", Read());
}",287.0,295.0,1.0,25.0,9.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1413,36900,_RunIt,1,leveldb.log._Test_ManyBlocks._RunIt,void leveldb.log._Test_ManyBlocks._RunIt (),db\log_test.cc,"TEST(LogTest, ManyBlocks)",287.0,287.0,1.0,25.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1414,36992,_Run,1,leveldb.log._Test_Fragmentation._Run,void leveldb.log._Test_Fragmentation._Run (),db\log_test.cc,"TEST(LogTest, Fragmentation) {
  Write(""small"");
  Write(BigString(""medium"", 50000));
  Write(BigString(""large"", 100000));
  ASSERT_EQ(""small"", Read());
  ASSERT_EQ(BigString(""medium"", 50000), Read());
  ASSERT_EQ(BigString(""large"", 100000), Read());
  ASSERT_EQ(""EOF"", Read());
}",297.0,305.0,1.0,28.0,9.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1415,36996,_RunIt,1,leveldb.log._Test_Fragmentation._RunIt,void leveldb.log._Test_Fragmentation._RunIt (),db\log_test.cc,"TEST(LogTest, Fragmentation)",297.0,297.0,1.0,28.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1416,37105,_Run,1,leveldb.log._Test_MarginalTrailer._Run,void leveldb.log._Test_MarginalTrailer._Run (),db\log_test.cc,"TEST(LogTest, MarginalTrailer) {
  // Make a trailer that is exactly the same length as an empty record.
  const int n = kBlockSize - 2*kHeaderSize;
  Write(BigString(""foo"", n));
  ASSERT_EQ(kBlockSize - kHeaderSize, WrittenBytes());
  Write("""");
  Write(""bar"");
  ASSERT_EQ(BigString(""foo"", n), Read());
  ASSERT_EQ("""", Read());
  ASSERT_EQ(""bar"", Read());
  ASSERT_EQ(""EOF"", Read());
}",307.0,318.0,1.0,30.0,12.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1417,37109,_RunIt,1,leveldb.log._Test_MarginalTrailer._RunIt,void leveldb.log._Test_MarginalTrailer._RunIt (),db\log_test.cc,"TEST(LogTest, MarginalTrailer)",307.0,307.0,1.0,30.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1418,37241,_Run,1,leveldb.log._Test_MarginalTrailer2._Run,void leveldb.log._Test_MarginalTrailer2._Run (),db\log_test.cc,"TEST(LogTest, MarginalTrailer2) {
  // Make a trailer that is exactly the same length as an empty record.
  const int n = kBlockSize - 2*kHeaderSize;
  Write(BigString(""foo"", n));
  ASSERT_EQ(kBlockSize - kHeaderSize, WrittenBytes());
  Write(""bar"");
  ASSERT_EQ(BigString(""foo"", n), Read());
  ASSERT_EQ(""bar"", Read());
  ASSERT_EQ(""EOF"", Read());
  ASSERT_EQ(0, DroppedBytes());
  ASSERT_EQ("""", ReportMessage());
}",320.0,331.0,1.0,31.0,12.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1419,37245,_RunIt,1,leveldb.log._Test_MarginalTrailer2._RunIt,void leveldb.log._Test_MarginalTrailer2._RunIt (),db\log_test.cc,"TEST(LogTest, MarginalTrailer2)",320.0,320.0,1.0,31.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1420,37392,_Run,1,leveldb.log._Test_ShortTrailer._Run,void leveldb.log._Test_ShortTrailer._Run (),db\log_test.cc,"TEST(LogTest, ShortTrailer) {
  const int n = kBlockSize - 2*kHeaderSize + 4;
  Write(BigString(""foo"", n));
  ASSERT_EQ(kBlockSize - kHeaderSize + 4, WrittenBytes());
  Write("""");
  Write(""bar"");
  ASSERT_EQ(BigString(""foo"", n), Read());
  ASSERT_EQ("""", Read());
  ASSERT_EQ(""bar"", Read());
  ASSERT_EQ(""EOF"", Read());
}",333.0,343.0,1.0,27.0,11.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1421,37396,_RunIt,1,leveldb.log._Test_ShortTrailer._RunIt,void leveldb.log._Test_ShortTrailer._RunIt (),db\log_test.cc,"TEST(LogTest, ShortTrailer)",333.0,333.0,1.0,27.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1422,37532,_Run,1,leveldb.log._Test_AlignedEof._Run,void leveldb.log._Test_AlignedEof._Run (),db\log_test.cc,"TEST(LogTest, AlignedEof) {
  const int n = kBlockSize - 2*kHeaderSize + 4;
  Write(BigString(""foo"", n));
  ASSERT_EQ(kBlockSize - kHeaderSize + 4, WrittenBytes());
  ASSERT_EQ(BigString(""foo"", n), Read());
  ASSERT_EQ(""EOF"", Read());
}",345.0,351.0,1.0,25.0,7.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1423,37536,_RunIt,1,leveldb.log._Test_AlignedEof._RunIt,void leveldb.log._Test_AlignedEof._RunIt (),db\log_test.cc,"TEST(LogTest, AlignedEof)",345.0,345.0,1.0,25.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1424,37634,_Run,1,leveldb.log._Test_OpenForAppend._Run,void leveldb.log._Test_OpenForAppend._Run (),db\log_test.cc,"TEST(LogTest, OpenForAppend) {
  Write(""hello"");
  ReopenForAppend();
  Write(""world"");
  ASSERT_EQ(""hello"", Read());
  ASSERT_EQ(""world"", Read());
  ASSERT_EQ(""EOF"", Read());
}",353.0,360.0,1.0,28.0,8.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1425,37638,_RunIt,1,leveldb.log._Test_OpenForAppend._RunIt,void leveldb.log._Test_OpenForAppend._RunIt (),db\log_test.cc,"TEST(LogTest, OpenForAppend)",353.0,353.0,1.0,28.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1426,37723,_Run,1,leveldb.log._Test_RandomRead._Run,void leveldb.log._Test_RandomRead._Run (),db\log_test.cc,"TEST(LogTest, RandomRead) {
  const int N = 500;
  Random write_rnd(301);
  for (int i = 0; i < N; i++) {
    Write(RandomSkewedString(i, &write_rnd));
  }
  Random read_rnd(301);
  for (int i = 0; i < N; i++) {
    ASSERT_EQ(RandomSkewedString(i, &read_rnd), Read());
  }
  ASSERT_EQ(""EOF"", Read());
}",362.0,373.0,1.0,25.0,12.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1427,37727,_RunIt,1,leveldb.log._Test_RandomRead._RunIt,void leveldb.log._Test_RandomRead._RunIt (),db\log_test.cc,"TEST(LogTest, RandomRead)",362.0,362.0,1.0,25.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1428,37831,_Run,1,leveldb.log._Test_ReadError._Run,void leveldb.log._Test_ReadError._Run (),db\log_test.cc,"TEST(LogTest, ReadError) {
  Write(""foo"");
  ForceError();
  ASSERT_EQ(""EOF"", Read());
  ASSERT_EQ(kBlockSize, DroppedBytes());
  ASSERT_EQ(""OK"", MatchError(""read error""));
}",377.0,383.0,1.0,24.0,7.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1429,37835,_RunIt,1,leveldb.log._Test_ReadError._RunIt,void leveldb.log._Test_ReadError._RunIt (),db\log_test.cc,"TEST(LogTest, ReadError)",377.0,377.0,1.0,24.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1430,37918,_Run,1,leveldb.log._Test_BadRecordType._Run,void leveldb.log._Test_BadRecordType._Run (),db\log_test.cc,"TEST(LogTest, BadRecordType) {
  Write(""foo"");
  // Type is stored in header[6]
  IncrementByte(6, 100);
  FixChecksum(0, 3);
  ASSERT_EQ(""EOF"", Read());
  ASSERT_EQ(3, DroppedBytes());
  ASSERT_EQ(""OK"", MatchError(""unknown record type""));
}",385.0,393.0,1.0,28.0,9.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1431,37922,_RunIt,1,leveldb.log._Test_BadRecordType._RunIt,void leveldb.log._Test_BadRecordType._RunIt (),db\log_test.cc,"TEST(LogTest, BadRecordType)",385.0,385.0,1.0,28.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1432,38010,_Run,1,leveldb.log._Test_TruncatedTrailingRecordIsIgnored._Run,void leveldb.log._Test_TruncatedTrailingRecordIsIgnored._Run (),db\log_test.cc,"TEST(LogTest, TruncatedTrailingRecordIsIgnored) {
  Write(""foo"");
  ShrinkSize(4);   // Drop all payload as well as a header byte
  ASSERT_EQ(""EOF"", Read());
  // Truncated last record is ignored, not treated as an error.
  ASSERT_EQ(0, DroppedBytes());
  ASSERT_EQ("""", ReportMessage());
}",395.0,402.0,1.0,47.0,8.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1433,38014,_RunIt,1,leveldb.log._Test_TruncatedTrailingRecordIsIgnored._RunIt,void leveldb.log._Test_TruncatedTrailingRecordIsIgnored._RunIt (),db\log_test.cc,"TEST(LogTest, TruncatedTrailingRecordIsIgnored)",395.0,395.0,1.0,47.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1434,38098,_Run,1,leveldb.log._Test_BadLength._Run,void leveldb.log._Test_BadLength._Run (),db\log_test.cc,"TEST(LogTest, BadLength) {
  const int kPayloadSize = kBlockSize - kHeaderSize;
  Write(BigString(""bar"", kPayloadSize));
  Write(""foo"");
  // Least significant size byte is stored in header[4].
  IncrementByte(4, 1);
  ASSERT_EQ(""foo"", Read());
  ASSERT_EQ(kBlockSize, DroppedBytes());
  ASSERT_EQ(""OK"", MatchError(""bad record length""));
}",404.0,413.0,1.0,24.0,10.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1435,38102,_RunIt,1,leveldb.log._Test_BadLength._RunIt,void leveldb.log._Test_BadLength._RunIt (),db\log_test.cc,"TEST(LogTest, BadLength)",404.0,404.0,1.0,24.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1436,38197,_Run,1,leveldb.log._Test_BadLengthAtEndIsIgnored._Run,void leveldb.log._Test_BadLengthAtEndIsIgnored._Run (),db\log_test.cc,"TEST(LogTest, BadLengthAtEndIsIgnored) {
  Write(""foo"");
  ShrinkSize(1);
  ASSERT_EQ(""EOF"", Read());
  ASSERT_EQ(0, DroppedBytes());
  ASSERT_EQ("""", ReportMessage());
}",415.0,421.0,1.0,38.0,7.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1437,38201,_RunIt,1,leveldb.log._Test_BadLengthAtEndIsIgnored._RunIt,void leveldb.log._Test_BadLengthAtEndIsIgnored._RunIt (),db\log_test.cc,"TEST(LogTest, BadLengthAtEndIsIgnored)",415.0,415.0,1.0,38.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1438,38285,_Run,1,leveldb.log._Test_ChecksumMismatch._Run,void leveldb.log._Test_ChecksumMismatch._Run (),db\log_test.cc,"TEST(LogTest, ChecksumMismatch) {
  Write(""foo"");
  IncrementByte(0, 10);
  ASSERT_EQ(""EOF"", Read());
  ASSERT_EQ(10, DroppedBytes());
  ASSERT_EQ(""OK"", MatchError(""checksum mismatch""));
}",423.0,429.0,1.0,31.0,7.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1439,38289,_RunIt,1,leveldb.log._Test_ChecksumMismatch._RunIt,void leveldb.log._Test_ChecksumMismatch._RunIt (),db\log_test.cc,"TEST(LogTest, ChecksumMismatch)",423.0,423.0,1.0,31.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1440,38374,_Run,1,leveldb.log._Test_UnexpectedMiddleType._Run,void leveldb.log._Test_UnexpectedMiddleType._Run (),db\log_test.cc,"TEST(LogTest, UnexpectedMiddleType) {
  Write(""foo"");
  SetByte(6, kMiddleType);
  FixChecksum(0, 3);
  ASSERT_EQ(""EOF"", Read());
  ASSERT_EQ(3, DroppedBytes());
  ASSERT_EQ(""OK"", MatchError(""missing start""));
}",431.0,438.0,1.0,35.0,8.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1441,38378,_RunIt,1,leveldb.log._Test_UnexpectedMiddleType._RunIt,void leveldb.log._Test_UnexpectedMiddleType._RunIt (),db\log_test.cc,"TEST(LogTest, UnexpectedMiddleType)",431.0,431.0,1.0,35.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1442,38466,_Run,1,leveldb.log._Test_UnexpectedLastType._Run,void leveldb.log._Test_UnexpectedLastType._Run (),db\log_test.cc,"TEST(LogTest, UnexpectedLastType) {
  Write(""foo"");
  SetByte(6, kLastType);
  FixChecksum(0, 3);
  ASSERT_EQ(""EOF"", Read());
  ASSERT_EQ(3, DroppedBytes());
  ASSERT_EQ(""OK"", MatchError(""missing start""));
}",440.0,447.0,1.0,33.0,8.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1443,38470,_RunIt,1,leveldb.log._Test_UnexpectedLastType._RunIt,void leveldb.log._Test_UnexpectedLastType._RunIt (),db\log_test.cc,"TEST(LogTest, UnexpectedLastType)",440.0,440.0,1.0,33.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1444,38558,_Run,1,leveldb.log._Test_UnexpectedFullType._Run,void leveldb.log._Test_UnexpectedFullType._Run (),db\log_test.cc,"TEST(LogTest, UnexpectedFullType) {
  Write(""foo"");
  Write(""bar"");
  SetByte(6, kFirstType);
  FixChecksum(0, 3);
  ASSERT_EQ(""bar"", Read());
  ASSERT_EQ(""EOF"", Read());
  ASSERT_EQ(3, DroppedBytes());
  ASSERT_EQ(""OK"", MatchError(""partial record without end""));
}",449.0,458.0,1.0,33.0,10.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1445,38562,_RunIt,1,leveldb.log._Test_UnexpectedFullType._RunIt,void leveldb.log._Test_UnexpectedFullType._RunIt (),db\log_test.cc,"TEST(LogTest, UnexpectedFullType)",449.0,449.0,1.0,33.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1446,38669,_Run,1,leveldb.log._Test_UnexpectedFirstType._Run,void leveldb.log._Test_UnexpectedFirstType._Run (),db\log_test.cc,"TEST(LogTest, UnexpectedFirstType) {
  Write(""foo"");
  Write(BigString(""bar"", 100000));
  SetByte(6, kFirstType);
  FixChecksum(0, 3);
  ASSERT_EQ(BigString(""bar"", 100000), Read());
  ASSERT_EQ(""EOF"", Read());
  ASSERT_EQ(3, DroppedBytes());
  ASSERT_EQ(""OK"", MatchError(""partial record without end""));
}",460.0,469.0,1.0,34.0,10.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1447,38673,_RunIt,1,leveldb.log._Test_UnexpectedFirstType._RunIt,void leveldb.log._Test_UnexpectedFirstType._RunIt (),db\log_test.cc,"TEST(LogTest, UnexpectedFirstType)",460.0,460.0,1.0,34.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1448,38783,_Run,1,leveldb.log._Test_MissingLastIsIgnored._Run,void leveldb.log._Test_MissingLastIsIgnored._Run (),db\log_test.cc,"TEST(LogTest, MissingLastIsIgnored) {
  Write(BigString(""bar"", kBlockSize));
  // Remove the LAST block, including header.
  ShrinkSize(14);
  ASSERT_EQ(""EOF"", Read());
  ASSERT_EQ("""", ReportMessage());
  ASSERT_EQ(0, DroppedBytes());
}",471.0,478.0,1.0,35.0,8.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1449,38787,_RunIt,1,leveldb.log._Test_MissingLastIsIgnored._RunIt,void leveldb.log._Test_MissingLastIsIgnored._RunIt (),db\log_test.cc,"TEST(LogTest, MissingLastIsIgnored)",471.0,471.0,1.0,35.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1450,38873,_Run,1,leveldb.log._Test_PartialLastIsIgnored._Run,void leveldb.log._Test_PartialLastIsIgnored._Run (),db\log_test.cc,"TEST(LogTest, PartialLastIsIgnored) {
  Write(BigString(""bar"", kBlockSize));
  // Cause a bad record length in the LAST block.
  ShrinkSize(1);
  ASSERT_EQ(""EOF"", Read());
  ASSERT_EQ("""", ReportMessage());
  ASSERT_EQ(0, DroppedBytes());
}",480.0,487.0,1.0,35.0,8.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1451,38877,_RunIt,1,leveldb.log._Test_PartialLastIsIgnored._RunIt,void leveldb.log._Test_PartialLastIsIgnored._RunIt (),db\log_test.cc,"TEST(LogTest, PartialLastIsIgnored)",480.0,480.0,1.0,35.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1452,38963,_Run,1,leveldb.log._Test_SkipIntoMultiRecord._Run,void leveldb.log._Test_SkipIntoMultiRecord._Run (),db\log_test.cc,"TEST(LogTest, SkipIntoMultiRecord) {
  // Consider a fragmented record:
  //    first(R1), middle(R1), last(R1), first(R2)
  // If initial_offset points to a record after first(R1) but before first(R2)
  // incomplete fragment errors are not actual errors, and must be suppressed
  // until a new first or full record is encountered.
  Write(BigString(""foo"", 3*kBlockSize));
  Write(""correct"");
  StartReadingAt(kBlockSize);

  ASSERT_EQ(""correct"", Read());
  ASSERT_EQ("""", ReportMessage());
  ASSERT_EQ(0, DroppedBytes());
  ASSERT_EQ(""EOF"", Read());
}",489.0,503.0,1.0,34.0,15.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1453,38967,_RunIt,1,leveldb.log._Test_SkipIntoMultiRecord._RunIt,void leveldb.log._Test_SkipIntoMultiRecord._RunIt (),db\log_test.cc,"TEST(LogTest, SkipIntoMultiRecord)",489.0,489.0,1.0,34.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1454,39074,_Run,1,leveldb.log._Test_ErrorJoinsRecords._Run,void leveldb.log._Test_ErrorJoinsRecords._Run (),db\log_test.cc,"TEST(LogTest, ErrorJoinsRecords) {
  // Consider two fragmented records:
  //    first(R1) last(R1) first(R2) last(R2)
  // where the middle two fragments disappear.  We do not want
  // first(R1),last(R2) to get joined and returned as a valid record.

  // Write records that span two blocks
  Write(BigString(""foo"", kBlockSize));
  Write(BigString(""bar"", kBlockSize));
  Write(""correct"");

  // Wipe the middle block
  for (int offset = kBlockSize; offset < 2*kBlockSize; offset++) {
    SetByte(offset, 'x');
  }

  ASSERT_EQ(""correct"", Read());
  ASSERT_EQ(""EOF"", Read());
  const size_t dropped = DroppedBytes();
  ASSERT_LE(dropped, 2*kBlockSize + 100);
  ASSERT_GE(dropped, 2*kBlockSize);
}",505.0,526.0,1.0,32.0,22.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1455,39078,_RunIt,1,leveldb.log._Test_ErrorJoinsRecords._RunIt,void leveldb.log._Test_ErrorJoinsRecords._RunIt (),db\log_test.cc,"TEST(LogTest, ErrorJoinsRecords)",505.0,505.0,1.0,32.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1456,39210,_Run,1,leveldb.log._Test_ReadStart._Run,void leveldb.log._Test_ReadStart._Run (),db\log_test.cc,"TEST(LogTest, ReadStart) {
  CheckInitialOffsetRecord(0, 0);
}",528.0,530.0,1.0,24.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1457,39214,_RunIt,1,leveldb.log._Test_ReadStart._RunIt,void leveldb.log._Test_ReadStart._RunIt (),db\log_test.cc,"TEST(LogTest, ReadStart)",528.0,528.0,1.0,24.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1458,39246,_Run,1,leveldb.log._Test_ReadSecondOneOff._Run,void leveldb.log._Test_ReadSecondOneOff._Run (),db\log_test.cc,"TEST(LogTest, ReadSecondOneOff) {
  CheckInitialOffsetRecord(1, 1);
}",532.0,534.0,1.0,31.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1459,39250,_RunIt,1,leveldb.log._Test_ReadSecondOneOff._RunIt,void leveldb.log._Test_ReadSecondOneOff._RunIt (),db\log_test.cc,"TEST(LogTest, ReadSecondOneOff)",532.0,532.0,1.0,31.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1460,39282,_Run,1,leveldb.log._Test_ReadSecondTenThousand._Run,void leveldb.log._Test_ReadSecondTenThousand._Run (),db\log_test.cc,"TEST(LogTest, ReadSecondTenThousand) {
  CheckInitialOffsetRecord(10000, 1);
}",536.0,538.0,1.0,36.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1461,39286,_RunIt,1,leveldb.log._Test_ReadSecondTenThousand._RunIt,void leveldb.log._Test_ReadSecondTenThousand._RunIt (),db\log_test.cc,"TEST(LogTest, ReadSecondTenThousand)",536.0,536.0,1.0,36.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1462,39318,_Run,1,leveldb.log._Test_ReadSecondStart._Run,void leveldb.log._Test_ReadSecondStart._Run (),db\log_test.cc,"TEST(LogTest, ReadSecondStart) {
  CheckInitialOffsetRecord(10007, 1);
}",540.0,542.0,1.0,30.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1463,39322,_RunIt,1,leveldb.log._Test_ReadSecondStart._RunIt,void leveldb.log._Test_ReadSecondStart._RunIt (),db\log_test.cc,"TEST(LogTest, ReadSecondStart)",540.0,540.0,1.0,30.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1464,39354,_Run,1,leveldb.log._Test_ReadThirdOneOff._Run,void leveldb.log._Test_ReadThirdOneOff._Run (),db\log_test.cc,"TEST(LogTest, ReadThirdOneOff) {
  CheckInitialOffsetRecord(10008, 2);
}",544.0,546.0,1.0,30.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1465,39358,_RunIt,1,leveldb.log._Test_ReadThirdOneOff._RunIt,void leveldb.log._Test_ReadThirdOneOff._RunIt (),db\log_test.cc,"TEST(LogTest, ReadThirdOneOff)",544.0,544.0,1.0,30.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1466,39390,_Run,1,leveldb.log._Test_ReadThirdStart._Run,void leveldb.log._Test_ReadThirdStart._Run (),db\log_test.cc,"TEST(LogTest, ReadThirdStart) {
  CheckInitialOffsetRecord(20014, 2);
}",548.0,550.0,1.0,29.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1467,39394,_RunIt,1,leveldb.log._Test_ReadThirdStart._RunIt,void leveldb.log._Test_ReadThirdStart._RunIt (),db\log_test.cc,"TEST(LogTest, ReadThirdStart)",548.0,548.0,1.0,29.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1468,39426,_Run,1,leveldb.log._Test_ReadFourthOneOff._Run,void leveldb.log._Test_ReadFourthOneOff._Run (),db\log_test.cc,"TEST(LogTest, ReadFourthOneOff) {
  CheckInitialOffsetRecord(20015, 3);
}",552.0,554.0,1.0,31.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1469,39430,_RunIt,1,leveldb.log._Test_ReadFourthOneOff._RunIt,void leveldb.log._Test_ReadFourthOneOff._RunIt (),db\log_test.cc,"TEST(LogTest, ReadFourthOneOff)",552.0,552.0,1.0,31.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1470,39462,_Run,1,leveldb.log._Test_ReadFourthFirstBlockTrailer._Run,void leveldb.log._Test_ReadFourthFirstBlockTrailer._Run (),db\log_test.cc,"TEST(LogTest, ReadFourthFirstBlockTrailer) {
  CheckInitialOffsetRecord(log::kBlockSize - 4, 3);
}",556.0,558.0,1.0,42.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1471,39466,_RunIt,1,leveldb.log._Test_ReadFourthFirstBlockTrailer._RunIt,void leveldb.log._Test_ReadFourthFirstBlockTrailer._RunIt (),db\log_test.cc,"TEST(LogTest, ReadFourthFirstBlockTrailer)",556.0,556.0,1.0,42.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1472,39502,_Run,1,leveldb.log._Test_ReadFourthMiddleBlock._Run,void leveldb.log._Test_ReadFourthMiddleBlock._Run (),db\log_test.cc,"TEST(LogTest, ReadFourthMiddleBlock) {
  CheckInitialOffsetRecord(log::kBlockSize + 1, 3);
}",560.0,562.0,1.0,36.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1473,39506,_RunIt,1,leveldb.log._Test_ReadFourthMiddleBlock._RunIt,void leveldb.log._Test_ReadFourthMiddleBlock._RunIt (),db\log_test.cc,"TEST(LogTest, ReadFourthMiddleBlock)",560.0,560.0,1.0,36.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1474,39542,_Run,1,leveldb.log._Test_ReadFourthLastBlock._Run,void leveldb.log._Test_ReadFourthLastBlock._Run (),db\log_test.cc,"TEST(LogTest, ReadFourthLastBlock) {
  CheckInitialOffsetRecord(2 * log::kBlockSize + 1, 3);
}",564.0,566.0,1.0,34.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1475,39546,_RunIt,1,leveldb.log._Test_ReadFourthLastBlock._RunIt,void leveldb.log._Test_ReadFourthLastBlock._RunIt (),db\log_test.cc,"TEST(LogTest, ReadFourthLastBlock)",564.0,564.0,1.0,34.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1476,39584,_Run,1,leveldb.log._Test_ReadFourthStart._Run,void leveldb.log._Test_ReadFourthStart._Run (),db\log_test.cc,"TEST(LogTest, ReadFourthStart) {
  CheckInitialOffsetRecord(
      2 * (kHeaderSize + 1000) + (2 * log::kBlockSize - 1000) + 3 * kHeaderSize,
      3);
}",568.0,572.0,1.0,30.0,5.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1477,39588,_RunIt,1,leveldb.log._Test_ReadFourthStart._RunIt,void leveldb.log._Test_ReadFourthStart._RunIt (),db\log_test.cc,"TEST(LogTest, ReadFourthStart)",568.0,568.0,1.0,30.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1478,39636,_Run,1,leveldb.log._Test_ReadInitialOffsetIntoBlockPadding._Run,void leveldb.log._Test_ReadInitialOffsetIntoBlockPadding._Run (),db\log_test.cc,"TEST(LogTest, ReadInitialOffsetIntoBlockPadding) {
  CheckInitialOffsetRecord(3 * log::kBlockSize - 3, 5);
}",574.0,576.0,1.0,48.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1479,39640,_RunIt,1,leveldb.log._Test_ReadInitialOffsetIntoBlockPadding._RunIt,void leveldb.log._Test_ReadInitialOffsetIntoBlockPadding._RunIt (),db\log_test.cc,"TEST(LogTest, ReadInitialOffsetIntoBlockPadding)",574.0,574.0,1.0,48.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1480,39678,_Run,1,leveldb.log._Test_ReadEnd._Run,void leveldb.log._Test_ReadEnd._Run (),db\log_test.cc,"TEST(LogTest, ReadEnd) {
  CheckOffsetPastEndReturnsNoRecords(0);
}",578.0,580.0,1.0,22.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1481,39682,_RunIt,1,leveldb.log._Test_ReadEnd._RunIt,void leveldb.log._Test_ReadEnd._RunIt (),db\log_test.cc,"TEST(LogTest, ReadEnd)",578.0,578.0,1.0,22.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1482,39713,_Run,1,leveldb.log._Test_ReadPastEnd._Run,void leveldb.log._Test_ReadPastEnd._Run (),db\log_test.cc,"TEST(LogTest, ReadPastEnd) {
  CheckOffsetPastEndReturnsNoRecords(5);
}",582.0,584.0,1.0,26.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1483,39717,_RunIt,1,leveldb.log._Test_ReadPastEnd._RunIt,void leveldb.log._Test_ReadPastEnd._RunIt (),db\log_test.cc,"TEST(LogTest, ReadPastEnd)",582.0,582.0,1.0,26.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1484,39777,InitTypeCrc,1,leveldb.log.InitTypeCrc,void leveldb.log.InitTypeCrc (uint32_t*),db\log_writer.cc,"static void InitTypeCrc(uint32_t* type_crc) {
  for (int i = 0; i <= kMaxRecordType; i++) {
    char t = static_cast<char>(i);
    type_crc[i] = crc32c::Value(&t, 1);
  }
}",15.0,20.0,1.0,1.0,6.0,8,6,9,5,0,0,2,2,0,0,,0,0,2,1,1,void
1485,39811,Writer,1,leveldb.log.Writer.Writer,ANY leveldb.log.Writer.Writer (WritableFile*),db\log_writer.cc,"Writer::Writer(WritableFile* dest, uint64_t dest_length)
    : dest_(dest), block_offset_(dest_length % kBlockSize) {
  InitTypeCrc(type_crc_);
}",28.0,31.0,1.0,1.0,4.0,0,0,1,1,0,1,1,1,0,0,,0,1,4,2,2,ANY
1486,39826,~Writer,1,leveldb.log.Writer.~Writer,ANY leveldb.log.Writer.~Writer (),db\log_writer.cc,"Writer::~Writer() {
}",33.0,34.0,1.0,1.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
1487,39830,AddRecord,1,leveldb.log.Writer.AddRecord,Status leveldb.log.Writer.AddRecord (Slice),db\log_writer.cc,"Status Writer::AddRecord(const Slice& slice) {
  const char* ptr = slice.data();
  size_t left = slice.size();

  // Fragment the record if necessary and emit it.  Note that if slice
  // is empty, we still want to iterate once to emit a single
  // zero-length record
  Status s;
  bool begin = true;
  do {
    const int leftover = kBlockSize - block_offset_;
    assert(leftover >= 0);
    if (leftover < kHeaderSize) {
      // Switch to a new block
      if (leftover > 0) {
        // Fill the trailer (literal below relies on kHeaderSize being 7)
        assert(kHeaderSize == 7);
        dest_->Append(Slice(""\x00\x00\x00\x00\x00\x00"", leftover));
      }
      block_offset_ = 0;
    }

    // Invariant: we never leave < kHeaderSize bytes in a block.
    assert(kBlockSize - block_offset_ - kHeaderSize >= 0);

    const size_t avail = kBlockSize - block_offset_ - kHeaderSize;
    const size_t fragment_length = (left < avail) ? left : avail;

    RecordType type;
    const bool end = ...",36.0,82.0,1.0,1.0,47.0,33,12,47,15,0,5,5,9,0,0,,0,5,2,1,1,Status
1488,39976,EmitPhysicalRecord,1,leveldb.log.Writer.EmitPhysicalRecord,"Status leveldb.log.Writer.EmitPhysicalRecord (RecordType,char*,size_t)",db\log_writer.cc,"Status Writer::EmitPhysicalRecord(RecordType t, const char* ptr, size_t n) {
  assert(n <= 0xffff);  // Must fit in two bytes
  assert(block_offset_ + kHeaderSize + n <= kBlockSize);

  // Format the header
  char buf[kHeaderSize];
  buf[4] = static_cast<char>(n & 0xff);
  buf[5] = static_cast<char>(n >> 8);
  buf[6] = static_cast<char>(t);

  // Compute the crc of the record type and the payload.
  uint32_t crc = crc32c::Extend(type_crc_[t], ptr, n);
  crc = crc32c::Mask(crc);                 // Adjust for storage
  EncodeFixed32(buf, crc);

  // Write the header and the payload
  Status s = dest_->Append(Slice(buf, kHeaderSize));
  if (s.ok()) {
    s = dest_->Append(Slice(ptr, n));
    if (s.ok()) {
      s = dest_->Flush();
    }
  }
  block_offset_ += kHeaderSize + n;
  return s;
}",84.0,109.0,1.0,1.0,26.0,30,10,38,12,0,6,3,4,0,0,,0,6,6,3,3,Status
1489,40139,operator =,1,leveldb.log.Writer.operator =,void leveldb.log.Writer.operator = (Writer),db\log_writer.hpp,void operator=(const Writer&);,48.0,48.0,8.0,31.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
1490,40170,GetLengthPrefixedSlice,1,leveldb.GetLengthPrefixedSlice,Slice leveldb.GetLengthPrefixedSlice (char*),util\coding.cc,"bool GetLengthPrefixedSlice(Slice* input, Slice* result) {
  uint32_t len;
  if (GetVarint32(input, &len) &&
      input->size() >= len) {
    *result = Slice(input->data(), len);
    input->remove_prefix(len);
    return true;
  } else {
    return false;
  }
}",182.0,192.0,1.0,1.0,11.0,4,3,8,3,0,0,1,1,0,0,,0,0,4,2,2,bool
1491,40193,MemTable,1,leveldb.MemTable.MemTable,ANY leveldb.MemTable.MemTable (InternalKeyComparator),db\memtable.cc,"MemTable::MemTable(const InternalKeyComparator& cmp)
    : comparator_(cmp),
      refs_(0),
      table_(comparator_, &arena_) {
}",21.0,25.0,1.0,1.0,5.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
1492,40198,~MemTable,1,leveldb.MemTable.~MemTable,ANY leveldb.MemTable.~MemTable (),db\memtable.cc,"MemTable::~MemTable() {
  assert(refs_ == 0);
}",27.0,29.0,1.0,1.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,ANY
1493,40206,ApproximateMemoryUsage,1,leveldb.MemTable.ApproximateMemoryUsage,size_t leveldb.MemTable.ApproximateMemoryUsage (),db\memtable.cc,size_t MemTable::ApproximateMemoryUsage() { return arena_.MemoryUsage(); },31.0,31.0,1.0,74.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,size_t
1494,40215,operator (),1,leveldb.MemTable.KeyComparator.operator (),"int leveldb.MemTable.KeyComparator.operator () (char*,char*)",db\memtable.cc,"int MemTable::KeyComparator::operator()(const char* aptr, const char* bptr)
    const {
  // Internal keys are encoded as length-prefixed strings.
  Slice a = GetLengthPrefixedSlice(aptr);
  Slice b = GetLengthPrefixedSlice(bptr);
  return comparator.Compare(a, b);
}",33.0,39.0,1.0,1.0,7.0,3,2,7,5,0,0,1,1,0,0,,0,0,4,2,2,int
1495,40238,EncodeKey,1,leveldb.EncodeKey,"const char* leveldb.EncodeKey (ANY*,Slice)",util\cache_test.cc,"static std::string EncodeKey(int k) {
  std::string result;
  PutFixed32(&result, k);
  return result;
}",14.0,18.0,1.0,1.0,5.0,6,2,7,2,0,0,1,1,0,0,,0,0,2,1,1,string
1496,40272,MemTableIterator,1,leveldb.MemTableIterator.MemTableIterator,ANY leveldb.MemTableIterator.MemTableIterator (ANY*),db\memtable.cc,explicit MemTableIterator(MemTable::Table* table) : iter_(table) { },53.0,53.0,3.0,70.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
1497,40277,Valid,1,leveldb.MemTableIterator.Valid,bool leveldb.MemTableIterator.Valid (),db\memtable.cc,virtual bool Valid() const { return iter_.Valid(); },55.0,55.0,3.0,54.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,bool
1498,40286,Seek,1,leveldb.MemTableIterator.Seek,void leveldb.MemTableIterator.Seek (Slice),db\memtable.cc,"virtual void Seek(const Slice& k) { iter_.Seek(EncodeKey(&tmp_, k)); }",56.0,56.0,3.0,72.0,1.0,2,2,3,3,0,2,1,1,0,0,,0,2,2,1,1,void
1499,40299,SeekToFirst,1,leveldb.MemTableIterator.SeekToFirst,void leveldb.MemTableIterator.SeekToFirst (),db\memtable.cc,virtual void SeekToFirst() { iter_.SeekToFirst(); },57.0,57.0,3.0,53.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,void
1500,40307,SeekToLast,1,leveldb.MemTableIterator.SeekToLast,void leveldb.MemTableIterator.SeekToLast (),db\memtable.cc,virtual void SeekToLast() { iter_.SeekToLast(); },58.0,58.0,3.0,51.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,void
1501,40315,Next,1,leveldb.MemTableIterator.Next,void leveldb.MemTableIterator.Next (),db\memtable.cc,virtual void Next() { iter_.Next(); },59.0,59.0,3.0,39.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,void
1502,40323,Prev,1,leveldb.MemTableIterator.Prev,void leveldb.MemTableIterator.Prev (),db\memtable.cc,virtual void Prev() { iter_.Prev(); },60.0,60.0,3.0,39.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,void
1503,40331,key,1,leveldb.MemTableIterator.key,Slice leveldb.MemTableIterator.key (),db\memtable.cc,virtual Slice key() const { return GetLengthPrefixedSlice(iter_.key()); },61.0,61.0,3.0,75.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,Slice
1504,40341,value,1,leveldb.MemTableIterator.value,Slice leveldb.MemTableIterator.value (),db\memtable.cc,"virtual Slice value() const {
    Slice key_slice = GetLengthPrefixedSlice(iter_.key());
    return GetLengthPrefixedSlice(key_slice.data() + key_slice.size());
  }",62.0,65.0,3.0,3.0,4.0,5,3,4,2,0,1,1,1,0,0,,0,1,0,0,0,Slice
1505,40364,status,1,leveldb.MemTableIterator.status,Status leveldb.MemTableIterator.status (),db\memtable.cc,virtual Status status() const { return Status::OK(); },67.0,67.0,3.0,56.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,0,0,0,0,Status
1506,40380,operator =,1,leveldb.MemTableIterator.operator =,void leveldb.MemTableIterator.operator = (MemTableIterator),db\memtable.cc,void operator=(const MemTableIterator&);,75.0,75.0,8.0,41.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
1507,40385,NewIterator,1,leveldb.MemTable.NewIterator,Iterator leveldb.MemTable.NewIterator (),db\memtable.cc,"Iterator* MemTable::NewIterator() {
  return new MemTableIterator(&table_);
}",78.0,80.0,1.0,1.0,3.0,2,2,2,2,0,1,1,1,0,0,,0,1,0,0,0,Iterator
1508,40394,Add,1,leveldb.MemTable.Add,"void leveldb.MemTable.Add (SequenceNumber,ValueType,Slice,Slice)",db\memtable.cc,"void MemTable::Add(SequenceNumber s, ValueType type,
                   const Slice& key,
                   const Slice& value) {
  // Format of an entry is concatenation of:
  //  key_size     : varint32 of internal_key.size()
  //  key bytes    : char[internal_key.size()]
  //  value_size   : varint32 of value.size()
  //  value bytes  : char[value.size()]
  size_t key_size = key.size();
  size_t val_size = value.size();
  size_t internal_key_size = key_size + 8;
  const size_t encoded_len =
      VarintLength(internal_key_size) + internal_key_size +
      VarintLength(val_size) + val_size;
  char* buf = arena_.Allocate(encoded_len);
  char* p = EncodeVarint32(buf, internal_key_size);
  memcpy(p, key.data(), key_size);
  p += key_size;
  EncodeFixed64(p, (s << 8) | type);
  p += 8;
  p = EncodeVarint32(p, val_size);
  memcpy(p, value.data(), val_size);
  assert((p + val_size) - buf == encoded_len);
  table_.Insert(buf);
}",82.0,106.0,1.0,1.0,25.0,24,8,38,12,0,2,1,1,0,0,,0,2,8,4,4,void
1509,40493,Get,1,leveldb.MemTable.Get,"bool leveldb.MemTable.Get (LookupKey,ANY*,Status*)",db\memtable.cc,"bool MemTable::Get(const LookupKey& key, std::string* value, Status* s) {
  Slice memkey = key.memtable_key();
  Table::Iterator iter(&table_);
  iter.Seek(memkey.data());
  if (iter.Valid()) {
    // entry format is:
    //    klength  varint32
    //    userkey  char[klength]
    //    tag      uint64
    //    vlength  varint32
    //    value    char[vlength]
    // Check that it belongs to same user key.  We do not check the
    // sequence number since the Seek() call above should have skipped
    // all entries with overly large sequence numbers.
    const char* entry = iter.key();
    uint32_t key_length;
    const char* key_ptr = GetVarint32Ptr(entry, entry+5, &key_length);
    if (comparator_.comparator.user_comparator()->Compare(
            Slice(key_ptr, key_length - 8),
            key.user_key()) == 0) {
      // Correct user key
      const uint64_t tag = DecodeFixed64(key_ptr + key_length - 8);
      switch (static_cast<ValueType>(tag & 0xff)) {
        case kTypeVa...",108.0,143.0,1.0,1.0,36.0,30,10,30,15,0,4,4,7,2,1,,0,4,6,3,3,bool
1510,40644,Ref,1,leveldb.MemTable.Ref,void leveldb.MemTable.Ref (),db\memtable.hpp,void Ref() { ++refs_; },27.0,27.0,3.0,25.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,void
1511,40650,Unref,1,leveldb.MemTable.Unref,void leveldb.MemTable.Unref (),db\memtable.hpp,"void Unref() {
    --refs_;
    assert(refs_ >= 0);
    if (refs_ <= 0) {
      delete this;
    }
  }",30.0,36.0,3.0,3.0,7.0,4,4,3,1,0,3,2,2,1,0,,0,3,0,0,0,void
1512,40696,KeyComparator,1,leveldb.MemTable.KeyComparator.KeyComparator,ANY leveldb.MemTable.KeyComparator.KeyComparator (InternalKeyComparator),db\memtable.hpp,explicit KeyComparator(const InternalKeyComparator& c) : comparator(c) { },68.0,68.0,5.0,78.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
1513,40701,operator (),1,leveldb.MemTable.KeyComparator.operator (),"int leveldb.MemTable.KeyComparator.operator () (char*,char*)",db\memtable.hpp,"int operator()(const char* a, const char* b) const;",69.0,69.0,9.0,54.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
1514,40719,operator =,1,leveldb.MemTable.operator =,void leveldb.MemTable.operator = (MemTable),db\memtable.hpp,void operator=(const MemTable&);,83.0,83.0,8.0,33.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
1515,40751,RecoveryTest,1,leveldb.RecoveryTest.RecoveryTest,ANY leveldb.RecoveryTest.RecoveryTest (),db\recovery_test.cc,"RecoveryTest() : env_(Env::Default()), db_(NULL) {
    dbname_ = test::TmpDir() + ""/recovery_test"";
    DestroyDB(dbname_, Options());
    Open();
  }",20.0,24.0,3.0,3.0,5.0,3,3,3,2,0,2,1,1,0,0,,0,2,0,0,0,ANY
1516,40767,~RecoveryTest,1,leveldb.RecoveryTest.~RecoveryTest,ANY leveldb.RecoveryTest.~RecoveryTest (),db\recovery_test.cc,"~RecoveryTest() {
    Close();
    DestroyDB(dbname_, Options());
  }",26.0,29.0,3.0,3.0,4.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,ANY
1517,40775,dbfull,1,leveldb.RecoveryTest.dbfull,DBImpl leveldb.RecoveryTest.dbfull (),db\recovery_test.cc,DBImpl* dbfull() const { return reinterpret_cast<DBImpl*>(db_); },31.0,31.0,3.0,67.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,DBImpl
1518,40783,env,1,leveldb.RecoveryTest.env,Env leveldb.RecoveryTest.env (),db\recovery_test.cc,Env* env() const { return env_; },32.0,32.0,3.0,35.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,Env
1519,40789,CanAppend,1,leveldb.RecoveryTest.CanAppend,bool leveldb.RecoveryTest.CanAppend (),db\recovery_test.cc,"bool CanAppend() {
    WritableFile* tmp;
    Status s = env_->NewAppendableFile(CurrentFileName(dbname_), &tmp);
    delete tmp;
    if (s.IsNotSupportedError()) {
      return false;
    } else {
      return true;
    }
  }",34.0,43.0,3.0,3.0,10.0,5,5,6,4,0,2,2,2,0,0,,0,2,0,0,0,bool
1520,40819,Close,1,leveldb.RecoveryTest.Close,void leveldb.RecoveryTest.Close (),db\recovery_test.cc,"void Close() {
    delete db_;
    db_ = NULL;
  }",45.0,48.0,3.0,3.0,4.0,2,2,3,2,0,2,1,1,0,0,,0,2,0,0,0,void
1521,40828,Open,1,leveldb.RecoveryTest.Open,void leveldb.RecoveryTest.Open (Options*),db\recovery_test.cc,"void Open(Options* options = NULL) {
    Close();
    Options opts;
    if (options != NULL) {
      opts = *options;
    } else {
      opts.reuse_logs = true;  // TODO(sanjay): test both ways
      opts.create_if_missing = true;
    }
    if (opts.env == NULL) {
      opts.env = env_;
    }
    ASSERT_OK(DB::Open(opts, dbname_, &db_));
    ASSERT_EQ(1, NumLogs());
  }",50.0,64.0,3.0,4.0,15.0,15,6,16,8,0,5,3,3,1,0,,0,5,2,1,1,void
1522,40906,Put,1,leveldb.RecoveryTest.Put,"Status leveldb.RecoveryTest.Put (ANY,ANY)",db\recovery_test.cc,"Status Put(const std::string& k, const std::string& v) {
    return db_->Put(WriteOptions(), k, v);
  }",66.0,68.0,3.0,3.0,3.0,1,1,3,3,0,1,1,1,0,0,,0,1,4,2,2,Status
1523,40920,Get,1,leveldb.RecoveryTest.Get,"string leveldb.RecoveryTest.Get (ANY,Snapshot*)",db\recovery_test.cc,"std::string Get(const std::string& k, const Snapshot* snapshot = NULL) {
    std::string result;
    Status s = db_->Get(ReadOptions(), k, &result);
    if (s.IsNotFound()) {
      result = ""NOT_FOUND"";
    } else if (!s.ok()) {
      result = s.ToString();
    }
    return result;
  }",70.0,79.0,3.0,3.0,10.0,5,4,7,4,0,1,2,2,0,0,,0,1,4,2,2,string
1524,40964,ManifestFileName,1,leveldb.RecoveryTest.ManifestFileName,string leveldb.RecoveryTest.ManifestFileName (),db\recovery_test.cc,"std::string ManifestFileName() {
    std::string current;
    ASSERT_OK(ReadFileToString(env_, CurrentFileName(dbname_), &current));
    size_t len = current.size();
    if (len > 0 && current[len-1] == '\n') {
      current.resize(len - 1);
    }
    return dbname_ + ""/"" + current;
  }",81.0,89.0,3.0,4.0,9.0,15,9,14,5,0,3,2,2,0,0,,0,3,0,0,0,string
1525,41021,LogName,1,leveldb.RecoveryTest.LogName,string leveldb.RecoveryTest.LogName (uint64_t),db\recovery_test.cc,"std::string LogName(uint64_t number) {
    return LogFileName(dbname_, number);
  }",91.0,93.0,3.0,3.0,3.0,0,0,2,2,0,1,1,1,0,0,,0,1,2,1,1,string
1526,41030,DeleteLogFiles,1,leveldb.RecoveryTest.DeleteLogFiles,size_t leveldb.RecoveryTest.DeleteLogFiles (),db\recovery_test.cc,"size_t DeleteLogFiles() {
    std::vector<uint64_t> logs = GetFiles(kLogFile);
    for (size_t i = 0; i < logs.size(); i++) {
      ASSERT_OK(env_->DeleteFile(LogName(logs[i]))) << LogName(logs[i]);
    }
    return logs.size();
  }",95.0,101.0,3.0,6.0,7.0,17,7,18,7,0,2,2,2,0,0,,0,2,0,0,0,size_t
1527,41098,FirstLogFile,1,leveldb.RecoveryTest.FirstLogFile,uint64_t leveldb.RecoveryTest.FirstLogFile (),db\recovery_test.cc,"uint64_t FirstLogFile() {
    return GetFiles(kLogFile)[0];
  }",103.0,105.0,3.0,3.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,uint64_t
1528,41107,GetFiles,1,leveldb.RecoveryTest.GetFiles,vector<uint64_t> leveldb.RecoveryTest.GetFiles (FileType),db\recovery_test.cc,"std::vector<uint64_t> GetFiles(FileType t) {
    std::vector<std::string> filenames;
    ASSERT_OK(env_->GetChildren(dbname_, &filenames));
    std::vector<uint64_t> result;
    for (size_t i = 0; i < filenames.size(); i++) {
      uint64_t number;
      FileType type;
      if (ParseFileName(filenames[i], &number, &type) && type == t) {
        result.push_back(number);
      }
    }
    return result;
  }",107.0,119.0,3.0,4.0,13.0,21,9,23,11,0,2,3,4,0,0,,0,2,2,1,1,vector<uint64_t>
1529,41186,NumLogs,1,leveldb.RecoveryTest.NumLogs,int leveldb.RecoveryTest.NumLogs (),db\recovery_test.cc,"int NumLogs() {
    return GetFiles(kLogFile).size();
  }",121.0,123.0,3.0,3.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,int
1530,41196,NumTables,1,leveldb.RecoveryTest.NumTables,int leveldb.RecoveryTest.NumTables (),db\recovery_test.cc,"int NumTables() {
    return GetFiles(kTableFile).size();
  }",125.0,127.0,3.0,3.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,int
1531,41206,FileSize,1,leveldb.RecoveryTest.FileSize,uint64_t leveldb.RecoveryTest.FileSize (ANY),db\recovery_test.cc,"uint64_t FileSize(const std::string& fname) {
    uint64_t result;
    ASSERT_OK(env_->GetFileSize(fname, &result)) << fname;
    return result;
  }",129.0,133.0,3.0,4.0,5.0,6,4,7,4,0,1,1,1,0,0,,0,1,2,1,1,uint64_t
1532,41236,CompactMemTable,1,leveldb.RecoveryTest.CompactMemTable,void leveldb.RecoveryTest.CompactMemTable (),db\recovery_test.cc,"void CompactMemTable() {
    dbfull()->TEST_CompactMemTable();
  }",135.0,137.0,3.0,3.0,3.0,1,1,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1533,41244,MakeLogFile,1,leveldb.RecoveryTest.MakeLogFile,"void leveldb.RecoveryTest.MakeLogFile (uint64_t,SequenceNumber,Slice,Slice)",db\recovery_test.cc,"void MakeLogFile(uint64_t lognum, SequenceNumber seq, Slice key, Slice val) {
    std::string fname = LogFileName(dbname_, lognum);
    WritableFile* file;
    ASSERT_OK(env_->NewWritableFile(fname, &file));
    log::Writer writer(file);
    WriteBatch batch;
    batch.Put(key, val);
    WriteBatchInternal::SetSequence(&batch, seq);
    ASSERT_OK(writer.AddRecord(WriteBatchInternal::Contents(&batch)));
    ASSERT_OK(file->Flush());
    delete file;
  }",140.0,151.0,3.0,4.0,12.0,24,5,28,14,0,2,1,1,0,0,,0,2,8,4,4,void
1534,41356,_Run,1,leveldb._Test_ManifestReused._Run,void leveldb._Test_ManifestReused._Run (),db\recovery_test.cc,"TEST(RecoveryTest, ManifestReused) {
  if (!CanAppend()) {
    fprintf(stderr, ""skipping test because env does not support appending\n"");
    return;
  }
  ASSERT_OK(Put(""foo"", ""bar""));
  Close();
  std::string old_manifest = ManifestFileName();
  Open();
  ASSERT_EQ(old_manifest, ManifestFileName());
  ASSERT_EQ(""bar"", Get(""foo""));
  Open();
  ASSERT_EQ(old_manifest, ManifestFileName());
  ASSERT_EQ(""bar"", Get(""foo""));
}",159.0,173.0,1.0,34.0,15.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1535,41360,_RunIt,1,leveldb._Test_ManifestReused._RunIt,void leveldb._Test_ManifestReused._RunIt (),db\recovery_test.cc,"TEST(RecoveryTest, ManifestReused)",159.0,159.0,1.0,34.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1536,41492,_Run,1,leveldb._Test_LargeManifestCompacted._Run,void leveldb._Test_LargeManifestCompacted._Run (),db\recovery_test.cc,"TEST(RecoveryTest, LargeManifestCompacted) {
  if (!CanAppend()) {
    fprintf(stderr, ""skipping test because env does not support appending\n"");
    return;
  }
  ASSERT_OK(Put(""foo"", ""bar""));
  Close();
  std::string old_manifest = ManifestFileName();

  // Pad with zeroes to make manifest file very big.
  {
    uint64_t len = FileSize(old_manifest);
    WritableFile* file;
    ASSERT_OK(env()->NewAppendableFile(old_manifest, &file));
    std::string zeroes(3*1048576 - static_cast<size_t>(len), 0);
    ASSERT_OK(file->Append(zeroes));
    ASSERT_OK(file->Flush());
    delete file;
  }

  Open();
  std::string new_manifest = ManifestFileName();
  ASSERT_NE(old_manifest, new_manifest);
  ASSERT_GT(10000, FileSize(new_manifest));
  ASSERT_EQ(""bar"", Get(""foo""));

  Open();
  ASSERT_EQ(new_manifest, ManifestFileName());
  ASSERT_EQ(""bar"", Get(""foo""));
}",175.0,204.0,1.0,42.0,30.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1537,41496,_RunIt,1,leveldb._Test_LargeManifestCompacted._RunIt,void leveldb._Test_LargeManifestCompacted._RunIt (),db\recovery_test.cc,"TEST(RecoveryTest, LargeManifestCompacted)",175.0,175.0,1.0,42.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1538,41734,_Run,1,leveldb._Test_NoLogFiles._Run,void leveldb._Test_NoLogFiles._Run (),db\recovery_test.cc,"TEST(RecoveryTest, NoLogFiles) {
  ASSERT_OK(Put(""foo"", ""bar""));
  ASSERT_EQ(1, DeleteLogFiles());
  Open();
  ASSERT_EQ(""NOT_FOUND"", Get(""foo""));
  Open();
  ASSERT_EQ(""NOT_FOUND"", Get(""foo""));
}",206.0,213.0,1.0,30.0,8.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1539,41738,_RunIt,1,leveldb._Test_NoLogFiles._RunIt,void leveldb._Test_NoLogFiles._RunIt (),db\recovery_test.cc,"TEST(RecoveryTest, NoLogFiles)",206.0,206.0,1.0,30.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1540,41840,_Run,1,leveldb._Test_LogFileReuse._Run,void leveldb._Test_LogFileReuse._Run (),db\recovery_test.cc,"TEST(RecoveryTest, LogFileReuse) {
  if (!CanAppend()) {
    fprintf(stderr, ""skipping test because env does not support appending\n"");
    return;
  }
  for (int i = 0; i < 2; i++) {
    ASSERT_OK(Put(""foo"", ""bar""));
    if (i == 0) {
      // Compact to ensure current log is empty
      CompactMemTable();
    }
    Close();
    ASSERT_EQ(1, NumLogs());
    uint64_t number = FirstLogFile();
    if (i == 0) {
      ASSERT_EQ(0, FileSize(LogName(number)));
    } else {
      ASSERT_LT(0, FileSize(LogName(number)));
    }
    Open();
    ASSERT_EQ(1, NumLogs());
    ASSERT_EQ(number, FirstLogFile()) << ""did not reuse log file"";
    ASSERT_EQ(""bar"", Get(""foo""));
    Open();
    ASSERT_EQ(1, NumLogs());
    ASSERT_EQ(number, FirstLogFile()) << ""did not reuse log file"";
    ASSERT_EQ(""bar"", Get(""foo""));
  }
}",215.0,243.0,1.0,32.0,29.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1541,41844,_RunIt,1,leveldb._Test_LogFileReuse._RunIt,void leveldb._Test_LogFileReuse._RunIt (),db\recovery_test.cc,"TEST(RecoveryTest, LogFileReuse)",215.0,215.0,1.0,32.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1542,42098,_Run,1,leveldb._Test_MultipleMemTables._Run,void leveldb._Test_MultipleMemTables._Run (),db\recovery_test.cc,"TEST(RecoveryTest, MultipleMemTables) {
  // Make a large log.
  const int kNum = 1000;
  for (int i = 0; i < kNum; i++) {
    char buf[100];
    snprintf(buf, sizeof(buf), ""%050d"", i);
    ASSERT_OK(Put(buf, buf));
  }
  ASSERT_EQ(0, NumTables());
  Close();
  ASSERT_EQ(0, NumTables());
  ASSERT_EQ(1, NumLogs());
  uint64_t old_log_file = FirstLogFile();

  // Force creation of multiple memtables by reducing the write buffer size.
  Options opt;
  opt.reuse_logs = true;
  opt.write_buffer_size = (kNum*100) / 2;
  Open(&opt);
  ASSERT_LE(2, NumTables());
  ASSERT_EQ(1, NumLogs());
  ASSERT_NE(old_log_file, FirstLogFile()) << ""must not reuse log"";
  for (int i = 0; i < kNum; i++) {
    char buf[100];
    snprintf(buf, sizeof(buf), ""%050d"", i);
    ASSERT_EQ(buf, Get(buf));
  }
}",245.0,272.0,1.0,37.0,28.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1543,42102,_RunIt,1,leveldb._Test_MultipleMemTables._RunIt,void leveldb._Test_MultipleMemTables._RunIt (),db\recovery_test.cc,"TEST(RecoveryTest, MultipleMemTables)",245.0,245.0,1.0,37.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1544,42335,_Run,1,leveldb._Test_MultipleLogFiles._Run,void leveldb._Test_MultipleLogFiles._Run (),db\recovery_test.cc,"TEST(RecoveryTest, MultipleLogFiles) {
  ASSERT_OK(Put(""foo"", ""bar""));
  Close();
  ASSERT_EQ(1, NumLogs());

  // Make a bunch of uncompacted log files.
  uint64_t old_log = FirstLogFile();
  MakeLogFile(old_log+1, 1000, ""hello"", ""world"");
  MakeLogFile(old_log+2, 1001, ""hi"", ""there"");
  MakeLogFile(old_log+3, 1002, ""foo"", ""bar2"");

  // Recover and check that all log files were processed.
  Open();
  ASSERT_LE(1, NumTables());
  ASSERT_EQ(1, NumLogs());
  uint64_t new_log = FirstLogFile();
  ASSERT_LE(old_log+3, new_log);
  ASSERT_EQ(""bar2"", Get(""foo""));
  ASSERT_EQ(""world"", Get(""hello""));
  ASSERT_EQ(""there"", Get(""hi""));

  // Test that previous recovery produced recoverable state.
  Open();
  ASSERT_LE(1, NumTables());
  ASSERT_EQ(1, NumLogs());
  if (CanAppend()) {
    ASSERT_EQ(new_log, FirstLogFile());
  }
  ASSERT_EQ(""bar2"", Get(""foo""));
  ASSERT_EQ(""world"", Get(""hello""));
  ASSERT_EQ(""there"", Get(""hi""));

  // Check that introducing an older log file does not cause it to be...",274.0,318.0,1.0,36.0,45.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1545,42339,_RunIt,1,leveldb._Test_MultipleLogFiles._RunIt,void leveldb._Test_MultipleLogFiles._RunIt (),db\recovery_test.cc,"TEST(RecoveryTest, MultipleLogFiles)",274.0,274.0,1.0,36.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1546,42819,Repairer,1,leveldb.anonymous_namespace_2.Repairer.Repairer,"ANY leveldb.anonymous_namespace_2.Repairer.Repairer (ANY,Options)",db\repair.cc,"Repairer(const std::string& dbname, const Options& options)
      : dbname_(dbname),
        env_(options.env),
        icmp_(options.comparator),
        ipolicy_(options.filter_policy),
        options_(SanitizeOptions(dbname, &icmp_, &ipolicy_, options)),
        owns_info_log_(options_.info_log != options.info_log),
        owns_cache_(options_.block_cache != options.block_cache),
        next_file_number_(1) {
    // TableCache can be small since we expect each table to be opened once.
    table_cache_ = new TableCache(dbname_, &options_, 10);
  }",47.0,58.0,3.0,3.0,12.0,3,3,4,4,0,3,1,1,0,0,,0,3,4,2,2,ANY
1547,42833,~Repairer,1,leveldb.anonymous_namespace_3.Repairer.~Repairer,ANY leveldb.anonymous_namespace_3.Repairer.~Repairer (),db\repair.cc,"~Repairer() {
    delete table_cache_;
    if (owns_info_log_) {
      delete options_.info_log;
    }
    if (owns_cache_) {
      delete options_.block_cache;
    }
  }",60.0,68.0,3.0,3.0,9.0,5,2,5,4,0,5,3,3,2,0,,0,5,0,0,0,ANY
1548,42853,Run,1,leveldb.anonymous_namespace_4.Repairer.Run,Status leveldb.anonymous_namespace_4.Repairer.Run (),db\repair.cc,"Status Run() {
    Status status = FindFiles();
    if (status.ok()) {
      ConvertLogFilesToTables();
      ExtractMetaData();
      status = WriteDescriptor();
    }
    if (status.ok()) {
      unsigned long long bytes = 0;
      for (size_t i = 0; i < tables_.size(); i++) {
        bytes += tables_[i].meta.file_size;
      }
      Log(options_.info_log,
          ""**** Repaired leveldb %s; ""
          ""recovered %d files; %llu bytes. ""
          ""Some data may have been lost. ""
          ""****"",
          dbname_.c_str(),
          static_cast<int>(tables_.size()),
          bytes);
    }
    return status;
  }",70.0,92.0,3.0,3.0,23.0,16,6,16,6,0,5,4,5,1,0,,0,5,0,0,0,Status
1549,42941,FindFiles,1,leveldb.anonymous_namespace_10.Repairer.FindFiles,Status leveldb.anonymous_namespace_10.Repairer.FindFiles (),db\repair.cc,"Status FindFiles() {
    std::vector<std::string> filenames;
    Status status = env_->GetChildren(dbname_, &filenames);
    if (!status.ok()) {
      return status;
    }
    if (filenames.empty()) {
      return Status::IOError(dbname_, ""repair found no files"");
    }

    uint64_t number;
    FileType type;
    for (size_t i = 0; i < filenames.size(); i++) {
      if (ParseFileName(filenames[i], &number, &type)) {
        if (type == kDescriptorFile) {
          manifests_.push_back(filenames[i]);
        } else {
          if (number + 1 > next_file_number_) {
            next_file_number_ = number + 1;
          }
          if (type == kLogFile) {
            logs_.push_back(number);
          } else if (type == kTableFile) {
            table_numbers_.push_back(number);
          } else {
            // Ignore other files
          }
        }
      }
    }
    return status;
  }",116.0,147.0,3.0,3.0,32.0,20,9,25,11,0,5,6,9,0,1,,0,4,0,0,0,Status
1550,43065,ConvertLogFilesToTables,1,leveldb.anonymous_namespace_11.Repairer.ConvertLogFilesToTables,void leveldb.anonymous_namespace_11.Repairer.ConvertLogFilesToTables (),db\repair.cc,"void ConvertLogFilesToTables() {
    for (size_t i = 0; i < logs_.size(); i++) {
      std::string logname = LogFileName(dbname_, logs_[i]);
      Status status = ConvertLogToTable(logs_[i]);
      if (!status.ok()) {
        Log(options_.info_log, ""Log #%llu: ignoring conversion error: %s"",
            (unsigned long long) logs_[i],
            status.ToString().c_str());
      }
      ArchiveFile(logname);
    }
  }",149.0,160.0,3.0,3.0,12.0,14,6,16,6,0,6,3,4,1,0,,0,6,0,0,0,void
1551,43125,ConvertLogToTable,1,leveldb.anonymous_namespace_14.Repairer.ConvertLogToTable,Status leveldb.anonymous_namespace_14.Repairer.ConvertLogToTable (uint64_t),db\repair.cc,"Status ConvertLogToTable(uint64_t log) {
    struct LogReporter : public log::Reader::Reporter {
      Env* env;
      Logger* info_log;
      uint64_t lognum;
      virtual void Corruption(size_t bytes, const Status& s) {
        // We print error messages for corruption, but continue repairing.
        Log(info_log, ""Log #%llu: dropping %d bytes; %s"",
            (unsigned long long) lognum,
            static_cast<int>(bytes),
            s.ToString().c_str());
      }
    };

    // Open the log file
    std::string logname = LogFileName(dbname_, log);
    SequentialFile* lfile;
    Status status = env_->NewSequentialFile(logname, &lfile);
    if (!status.ok()) {
      return status;
    }

    // Create the log reader.
    LogReporter reporter;
    reporter.env = env_;
    reporter.info_log = options_.info_log;
    reporter.lognum = log;
    // We intentionally make log::Reader do checksumming so that
    // corruptions cause entire commits to be skipped instead of
    // propa...",162.0,242.0,3.0,3.0,81.0,57,12,66,24,0,17,8,10,1,1,,0,16,2,1,1,Status
1552,43361,ExtractMetaData,1,leveldb.anonymous_namespace_15.Repairer.ExtractMetaData,void leveldb.anonymous_namespace_15.Repairer.ExtractMetaData (),db\repair.cc,"void ExtractMetaData() {
    for (size_t i = 0; i < table_numbers_.size(); i++) {
      ScanTable(table_numbers_[i]);
    }
  }",244.0,248.0,3.0,3.0,5.0,4,4,5,2,0,2,2,2,1,0,,0,2,0,0,0,void
1553,43384,NewTableIterator,1,leveldb.anonymous_namespace_17.Repairer.NewTableIterator,Iterator leveldb.anonymous_namespace_17.Repairer.NewTableIterator (FileMetaData),db\repair.cc,"Iterator* NewTableIterator(const FileMetaData& meta) {
    // Same as compaction iterators: if paranoid_checks are on, turn
    // on checksum verification.
    ReadOptions r;
    r.verify_checksums = options_.paranoid_checks;
    return table_cache_->NewIterator(r, meta.number, meta.file_size);
  }",250.0,256.0,3.0,3.0,7.0,6,3,6,4,0,5,1,1,0,0,,0,5,2,1,1,Iterator
1554,43409,ScanTable,1,leveldb.anonymous_namespace_18.Repairer.ScanTable,void leveldb.anonymous_namespace_18.Repairer.ScanTable (uint64_t),db\repair.cc,"void ScanTable(uint64_t number) {
    TableInfo t;
    t.meta.number = number;
    std::string fname = TableFileName(dbname_, number);
    Status status = env_->GetFileSize(fname, &t.meta.file_size);
    if (!status.ok()) {
      // Try alternate file name.
      fname = SSTTableFileName(dbname_, number);
      Status s2 = env_->GetFileSize(fname, &t.meta.file_size);
      if (s2.ok()) {
        status = Status::OK();
      }
    }
    if (!status.ok()) {
      ArchiveFile(TableFileName(dbname_, number));
      ArchiveFile(SSTTableFileName(dbname_, number));
      Log(options_.info_log, ""Table #%llu: dropped: %s"",
          (unsigned long long) t.meta.number,
          status.ToString().c_str());
      return;
    }

    // Extract metadata by scanning through table.
    int counter = 0;
    Iterator* iter = NewTableIterator(t.meta);
    bool empty = true;
    ParsedInternalKey parsed;
    t.max_sequence = 0;
    for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {
      Slice k...",258.0,319.0,3.0,3.0,62.0,73,9,64,15,0,25,11,14,2,0,,0,25,2,1,1,void
1555,43679,RepairTable,1,leveldb.anonymous_namespace_23.Repairer.RepairTable,"void leveldb.anonymous_namespace_23.Repairer.RepairTable (ANY,TableInfo)",db\repair.cc,"void RepairTable(const std::string& src, TableInfo t) {
    // We will copy src contents to a new table and then rename the
    // new table over the source.

    // Create builder.
    std::string copy = TableFileName(dbname_, next_file_number_++);
    WritableFile* file;
    Status s = env_->NewWritableFile(copy, &file);
    if (!s.ok()) {
      return;
    }
    TableBuilder* builder = new TableBuilder(options_, file);

    // Copy data.
    Iterator* iter = NewTableIterator(t.meta);
    int counter = 0;
    for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {
      builder->Add(iter->key(), iter->value());
      counter++;
    }
    delete iter;

    ArchiveFile(src);
    if (counter == 0) {
      builder->Abandon();  // Nothing to save
    } else {
      s = builder->Finish();
      if (s.ok()) {
        t.meta.file_size = builder->FileSize();
      }
    }
    delete builder;
    builder = NULL;

    if (s.ok()) {
      s = file->Close();
    }
    delete file;
    file = ...",321.0,373.0,3.0,3.0,53.0,45,12,52,16,0,12,8,9,0,0,,0,12,4,2,2,void
1556,43881,WriteDescriptor,1,leveldb.anonymous_namespace_26.Repairer.WriteDescriptor,Status leveldb.anonymous_namespace_26.Repairer.WriteDescriptor (),db\repair.cc,"Status WriteDescriptor() {
    std::string tmp = TempFileName(dbname_, 1);
    WritableFile* file;
    Status status = env_->NewWritableFile(tmp, &file);
    if (!status.ok()) {
      return status;
    }

    SequenceNumber max_sequence = 0;
    for (size_t i = 0; i < tables_.size(); i++) {
      if (max_sequence < tables_[i].max_sequence) {
        max_sequence = tables_[i].max_sequence;
      }
    }

    edit_.SetComparatorName(icmp_.user_comparator()->Name());
    edit_.SetLogNumber(0);
    edit_.SetNextFile(next_file_number_);
    edit_.SetLastSequence(max_sequence);

    for (size_t i = 0; i < tables_.size(); i++) {
      // TODO(opt): separate out into multiple levels
      const TableInfo& t = tables_[i];
      edit_.AddFile(0, t.meta.number, t.meta.file_size,
                    t.meta.smallest, t.meta.largest);
    }

    //fprintf(stderr, ""NewDescriptor:\n%s\n"", edit_.DebugString().c_str());
    {
      log::Writer log(file);
      std::string record;
      edit_.EncodeT...",375.0,432.0,3.0,3.0,58.0,48,8,52,15,0,20,7,8,3,0,,0,20,0,0,0,Status
1557,44121,ArchiveFile,1,leveldb.anonymous_namespace_28.Repairer.ArchiveFile,void leveldb.anonymous_namespace_28.Repairer.ArchiveFile (ANY),db\repair.cc,"void ArchiveFile(const std::string& fname) {
    // Move into another directory.  E.g., for
    //    dir/foo
    // rename to
    //    dir/lost/foo
    const char* slash = strrchr(fname.c_str(), '/');
    std::string new_dir;
    if (slash != NULL) {
      new_dir.assign(fname.data(), slash - fname.data());
    }
    new_dir.append(""/lost"");
    env_->CreateDir(new_dir);  // Ignore error
    std::string new_file = new_dir;
    new_file.append(""/"");
    new_file.append((slash == NULL) ? fname.c_str() : slash + 1);
    Status s = env_->RenameFile(fname, new_file);
    Log(options_.info_log, ""Archiving %s: %s\n"",
        fname.c_str(), s.ToString().c_str());
  }",434.0,452.0,3.0,3.0,19.0,22,8,26,8,0,3,2,2,0,0,,0,3,2,1,1,void
1558,44214,RepairDB,1,leveldb.RepairDB,"Status leveldb.RepairDB (ANY,Options)",db\repair.cc,"Status RepairDB(const std::string& dbname, const Options& options) {
  Repairer repairer(dbname, options);
  return repairer.Run();
}",456.0,459.0,1.0,1.0,4.0,1,1,3,3,0,0,1,1,0,0,,0,0,4,2,2,Status
1559,44248,SkipList,1,leveldb.SkipList.SkipList,"explicit leveldb.SkipList.SkipList (Comparator,Arena*)",db\skiplist.hpp,"explicit SkipList(Comparator cmp, Arena* arena);",49.0,49.0,12.0,49.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,explicit
1560,44254,Insert,1,leveldb.SkipList.Insert,void leveldb.SkipList.Insert (Key),db\skiplist.hpp,void Insert(const Key& key);,53.0,53.0,8.0,29.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
1561,44259,Contains,1,leveldb.SkipList.Contains,bool leveldb.SkipList.Contains (Key),db\skiplist.hpp,bool Contains(const Key& key) const;,56.0,56.0,8.0,37.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,bool
1562,44265,Iterator,1,leveldb.SkipList.Iterator.Iterator,explicit leveldb.SkipList.Iterator.Iterator (SkipList*),db\skiplist.hpp,explicit Iterator(const SkipList* list);,63.0,63.0,14.0,43.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,explicit
1563,44270,Valid,1,leveldb.SkipList.Iterator.Valid,bool leveldb.SkipList.Iterator.Valid (),db\skiplist.hpp,bool Valid() const;,66.0,66.0,10.0,22.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,bool
1564,44274,key,1,leveldb.SkipList.Iterator.key,Key leveldb.SkipList.Iterator.key (),db\skiplist.hpp,const Key& key() const;,70.0,70.0,14.0,26.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,Key
1565,44278,Next,1,leveldb.SkipList.Iterator.Next,void leveldb.SkipList.Iterator.Next (),db\skiplist.hpp,void Next();,74.0,74.0,10.0,15.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1566,44282,Prev,1,leveldb.SkipList.Iterator.Prev,void leveldb.SkipList.Iterator.Prev (),db\skiplist.hpp,void Prev();,78.0,78.0,10.0,15.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1567,44286,Seek,1,leveldb.SkipList.Iterator.Seek,void leveldb.SkipList.Iterator.Seek (Key),db\skiplist.hpp,void Seek(const Key& target);,81.0,81.0,10.0,32.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
1568,44291,SeekToFirst,1,leveldb.SkipList.Iterator.SeekToFirst,void leveldb.SkipList.Iterator.SeekToFirst (),db\skiplist.hpp,void SeekToFirst();,85.0,85.0,10.0,22.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1569,44295,SeekToLast,1,leveldb.SkipList.Iterator.SeekToLast,void leveldb.SkipList.Iterator.SeekToLast (),db\skiplist.hpp,void SeekToLast();,89.0,89.0,10.0,21.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1570,44314,GetMaxHeight,1,leveldb.SkipList.GetMaxHeight,int leveldb.SkipList.GetMaxHeight (),db\skiplist.hpp,"inline int GetMaxHeight() const {
    return static_cast<int>(
        reinterpret_cast<intptr_t>(max_height_.NoBarrier_Load()));
  }",110.0,113.0,3.0,3.0,4.0,3,2,1,1,0,1,1,1,0,0,,0,1,0,0,0,int
1571,44328,NewNode,1,leveldb.SkipList.NewNode,"Node* leveldb.SkipList.NewNode (Key,int)",db\skiplist.hpp,"Node* NewNode(const Key& key, int height);",118.0,118.0,7.0,43.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,Node*
1572,44334,RandomHeight,1,leveldb.SkipList.RandomHeight,int leveldb.SkipList.RandomHeight (),db\skiplist.hpp,int RandomHeight();,119.0,119.0,7.0,20.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,int
1573,44338,Equal,1,leveldb.SkipList.Equal,"bool leveldb.SkipList.Equal (Key,Key)",db\skiplist.hpp,"bool Equal(const Key& a, const Key& b) const { return (compare_(a, b) == 0); }",120.0,120.0,3.0,80.0,1.0,1,1,2,2,0,0,1,1,0,0,,0,0,4,2,2,bool
1574,44350,KeyIsAfterNode,1,leveldb.SkipList.KeyIsAfterNode,"bool leveldb.SkipList.KeyIsAfterNode (Key,Node*)",db\skiplist.hpp,"bool KeyIsAfterNode(const Key& key, Node* n) const;",123.0,123.0,8.0,52.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,bool
1575,44356,FindGreaterOrEqual,1,leveldb.SkipList.FindGreaterOrEqual,"Node* leveldb.SkipList.FindGreaterOrEqual (Key,Node**)",db\skiplist.hpp,"Node* FindGreaterOrEqual(const Key& key, Node** prev) const;",130.0,130.0,7.0,61.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,Node*
1576,44362,FindLessThan,1,leveldb.SkipList.FindLessThan,Node* leveldb.SkipList.FindLessThan (Key),db\skiplist.hpp,Node* FindLessThan(const Key& key) const;,134.0,134.0,7.0,42.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,Node*
1577,44367,FindLast,1,leveldb.SkipList.FindLast,Node* leveldb.SkipList.FindLast (),db\skiplist.hpp,Node* FindLast() const;,138.0,138.0,7.0,24.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,Node*
1578,44376,operator =,1,leveldb.SkipList.operator =,void leveldb.SkipList.operator = (SkipList),db\skiplist.hpp,void operator=(const SkipList&);,142.0,142.0,8.0,33.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
1579,44382,Node,1,leveldb.Node.Node,ANY leveldb.Node.Node (Key),db\skiplist.hpp,explicit Node(const Key& k) : key(k) { },148.0,148.0,3.0,42.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
1580,44388,Next,1,leveldb.Node.Next,Node leveldb.Node.Next (int),db\skiplist.hpp,"Node* Next(int n) {
    assert(n >= 0);
    // Use an 'acquire load' so that we observe a fully initialized
    // version of the returned Node.
    return reinterpret_cast<Node*>(next_[n].Acquire_Load());
  }",154.0,159.0,3.0,3.0,6.0,4,4,3,2,0,1,1,1,0,0,,0,1,2,1,1,Node
1581,44406,SetNext,1,leveldb.Node.SetNext,"void leveldb.Node.SetNext (int,Node*)",db\skiplist.hpp,"void SetNext(int n, Node* x) {
    assert(n >= 0);
    // Use a 'release store' so that anybody who reads through this
    // pointer observes a fully initialized version of the inserted node.
    next_[n].Release_Store(x);
  }",160.0,165.0,3.0,3.0,6.0,3,3,4,3,0,1,1,1,0,0,,0,1,4,2,2,void
1582,44423,NoBarrier_Next,1,leveldb.Node.NoBarrier_Next,Node leveldb.Node.NoBarrier_Next (int),db\skiplist.hpp,"Node* NoBarrier_Next(int n) {
    assert(n >= 0);
    return reinterpret_cast<Node*>(next_[n].NoBarrier_Load());
  }",168.0,171.0,3.0,3.0,4.0,4,4,3,2,0,1,1,1,0,0,,0,1,2,1,1,Node
1583,44441,NoBarrier_SetNext,1,leveldb.Node.NoBarrier_SetNext,"void leveldb.Node.NoBarrier_SetNext (int,Node*)",db\skiplist.hpp,"void NoBarrier_SetNext(int n, Node* x) {
    assert(n >= 0);
    next_[n].NoBarrier_Store(x);
  }",172.0,175.0,3.0,3.0,4.0,3,3,4,3,0,1,1,1,0,0,,0,1,4,2,2,void
1584,44465,NewNode,1,"leveldb.SkipList<Key,Comparator>.NewNode","Node leveldb.SkipList<Key,Comparator>.NewNode<Key,Comparator> (Key,int)",db\skiplist.hpp,"typename SkipList<Key,Comparator>::Node*
SkipList<Key,Comparator>::NewNode(const Key& key, int height) {
  char* mem = arena_->AllocateAligned(
      sizeof(Node) + sizeof(port::AtomicPointer) * (height - 1));
  return new (mem) Node(key);
}",183.0,188.0,1.0,1.0,6.0,8,7,8,6,0,0,1,1,0,0,,0,0,4,2,2,Node
1585,44492,Iterator,1,"leveldb.SkipList<Key,Comparator>.Iterator.Iterator","ANY leveldb.SkipList<Key,Comparator>.Iterator.Iterator<Key,Comparator> (SkipList*)",db\skiplist.hpp,"inline SkipList<Key,Comparator>::Iterator::Iterator(const SkipList* list) {
  list_ = list;
  node_ = NULL;
}",191.0,194.0,1.0,1.0,4.0,2,1,4,4,0,0,1,1,0,0,,0,0,2,1,1,ANY
1586,44503,Valid,1,"leveldb.SkipList<Key,Comparator>.Iterator.Valid","bool leveldb.SkipList<Key,Comparator>.Iterator.Valid<Key,Comparator> ()",db\skiplist.hpp,"inline bool SkipList<Key,Comparator>::Iterator::Valid() const {
  return node_ != NULL;
}",197.0,199.0,1.0,1.0,3.0,1,1,2,2,0,0,1,1,0,0,,0,0,0,0,0,bool
1587,44511,key,1,"leveldb.SkipList<Key,Comparator>.Iterator.key","Key leveldb.SkipList<Key,Comparator>.Iterator.key<Key,Comparator> ()",db\skiplist.hpp,"inline const Key& SkipList<Key,Comparator>::Iterator::key() const {
  assert(Valid());
  return node_->key;
}",202.0,205.0,1.0,1.0,4.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,Key
1588,44521,Next,1,"leveldb.SkipList<Key,Comparator>.Iterator.Next","void leveldb.SkipList<Key,Comparator>.Iterator.Next<Key,Comparator> ()",db\skiplist.hpp,"inline void SkipList<Key,Comparator>::Iterator::Next() {
  assert(Valid());
  node_ = node_->Next(0);
}",208.0,211.0,1.0,1.0,4.0,2,2,2,1,0,0,1,1,0,0,,0,0,0,0,0,void
1589,44534,Prev,1,"leveldb.SkipList<Key,Comparator>.Iterator.Prev","void leveldb.SkipList<Key,Comparator>.Iterator.Prev<Key,Comparator> ()",db\skiplist.hpp,"inline void SkipList<Key,Comparator>::Iterator::Prev() {
  // Instead of using explicit ""prev"" links, we just search for the
  // last node that falls before key.
  assert(Valid());
  node_ = list_->FindLessThan(node_->key);
  if (node_ == list_->head_) {
    node_ = NULL;
  }
}",214.0,222.0,1.0,1.0,9.0,6,3,7,3,0,0,2,2,0,0,,0,0,0,0,0,void
1590,44559,Seek,1,"leveldb.SkipList<Key,Comparator>.Iterator.Seek","void leveldb.SkipList<Key,Comparator>.Iterator.Seek<Key,Comparator> (Key)",db\skiplist.hpp,"inline void SkipList<Key,Comparator>::Iterator::Seek(const Key& target) {
  node_ = list_->FindGreaterOrEqual(target, NULL);
}",225.0,227.0,1.0,1.0,3.0,2,2,4,4,0,0,1,1,0,0,,0,0,2,1,1,void
1591,44572,SeekToFirst,1,"leveldb.SkipList<Key,Comparator>.Iterator.SeekToFirst","void leveldb.SkipList<Key,Comparator>.Iterator.SeekToFirst<Key,Comparator> ()",db\skiplist.hpp,"inline void SkipList<Key,Comparator>::Iterator::SeekToFirst() {
  node_ = list_->head_->Next(0);
}",230.0,232.0,1.0,1.0,3.0,3,2,2,2,0,0,1,1,0,0,,0,0,0,0,0,void
1592,44585,SeekToLast,1,"leveldb.SkipList<Key,Comparator>.Iterator.SeekToLast","void leveldb.SkipList<Key,Comparator>.Iterator.SeekToLast<Key,Comparator> ()",db\skiplist.hpp,"inline void SkipList<Key,Comparator>::Iterator::SeekToLast() {
  node_ = list_->FindLast();
  if (node_ == list_->head_) {
    node_ = NULL;
  }
}",235.0,240.0,1.0,1.0,6.0,5,3,6,3,0,0,2,2,0,0,,0,0,0,0,0,void
1593,44605,RandomHeight,1,"leveldb.SkipList<Key,Comparator>.RandomHeight","int leveldb.SkipList<Key,Comparator>.RandomHeight<Key,Comparator> ()",db\skiplist.hpp,"int SkipList<Key,Comparator>::RandomHeight() {
  // Increase height with probability 1 in kBranching
  static const unsigned int kBranching = 4;
  int height = 1;
  while (height < kMaxHeight && ((rnd_.Next() % kBranching) == 0)) {
    height++;
  }
  assert(height > 0);
  assert(height <= kMaxHeight);
  return height;
}",243.0,253.0,1.0,1.0,11.0,10,9,11,4,0,0,2,2,0,0,,0,0,0,0,0,int
1594,44643,KeyIsAfterNode,1,"leveldb.SkipList<Key,Comparator>.KeyIsAfterNode","bool leveldb.SkipList<Key,Comparator>.KeyIsAfterNode<Key,Comparator> (Key,Node*)",db\skiplist.hpp,"bool SkipList<Key,Comparator>::KeyIsAfterNode(const Key& key, Node* n) const {
  // NULL n is considered infinite
  return (n != NULL) && (compare_(n->key, key) < 0);
}",256.0,259.0,1.0,1.0,4.0,4,4,4,3,0,1,1,1,0,0,,0,1,4,2,2,bool
1595,44661,FindGreaterOrEqual,1,"leveldb.SkipList<Key,Comparator>.FindGreaterOrEqual","Node leveldb.SkipList<Key,Comparator>.FindGreaterOrEqual<Key,Comparator> (Key,Node**)",db\skiplist.hpp,"typename SkipList<Key,Comparator>::Node* SkipList<Key,Comparator>::FindGreaterOrEqual(const Key& key, Node** prev)
    const {
  Node* x = head_;
  int level = GetMaxHeight() - 1;
  while (true) {
    Node* next = x->Next(level);
    if (KeyIsAfterNode(key, next)) {
      // Keep searching in this list
      x = next;
    } else {
      if (prev != NULL) prev[level] = x;
      if (level == 0) {
        return next;
      } else {
        // Switch to next list
        level--;
      }
    }
  }
}",262.0,281.0,1.0,1.0,20.0,6,3,10,5,0,0,3,4,0,0,,0,0,4,2,2,Node
1596,44719,FindLessThan,1,"leveldb.SkipList<Key,Comparator>.FindLessThan","Node leveldb.SkipList<Key,Comparator>.FindLessThan<Key,Comparator> (Key)",db\skiplist.hpp,"typename SkipList<Key,Comparator>::Node*
SkipList<Key,Comparator>::FindLessThan(const Key& key) const {
  Node* x = head_;
  int level = GetMaxHeight() - 1;
  while (true) {
    assert(x == head_ || compare_(x->key, key) < 0);
    Node* next = x->Next(level);
    if (next == NULL || compare_(next->key, key) >= 0) {
      if (level == 0) {
        return x;
      } else {
        // Switch to next list
        level--;
      }
    } else {
      x = next;
    }
  }
}",284.0,302.0,1.0,1.0,19.0,14,7,16,6,0,2,4,7,1,0,,0,2,2,1,1,Node
1597,44786,FindLast,1,"leveldb.SkipList<Key,Comparator>.FindLast","Node leveldb.SkipList<Key,Comparator>.FindLast<Key,Comparator> ()",db\skiplist.hpp,"typename SkipList<Key,Comparator>::Node* SkipList<Key,Comparator>::FindLast()
    const {
  Node* x = head_;
  int level = GetMaxHeight() - 1;
  while (true) {
    Node* next = x->Next(level);
    if (next == NULL) {
      if (level == 0) {
        return x;
      } else {
        // Switch to next list
        level--;
      }
    } else {
      x = next;
    }
  }
}",305.0,322.0,1.0,1.0,18.0,7,4,10,5,0,0,4,7,0,0,,0,0,0,0,0,Node
1598,44832,SkipList,1,"leveldb.SkipList<Key,Comparator>.SkipList","ANY leveldb.SkipList<Key,Comparator>.SkipList<Key,Comparator> (Comparator,Arena*)",db\skiplist.hpp,"SkipList<Key,Comparator>::SkipList(Comparator cmp, Arena* arena)
    : compare_(cmp),
      arena_(arena),
      head_(NewNode(0 /* any key will do */, kMaxHeight)),
      max_height_(reinterpret_cast<void*>(1)),
      rnd_(0xdeadbeef) {
  for (int i = 0; i < kMaxHeight; i++) {
    head_->SetNext(i, NULL);
  }
}",325.0,334.0,1.0,1.0,10.0,3,3,6,4,0,0,2,2,0,0,,0,0,4,2,2,ANY
1599,44856,Insert,1,"leveldb.SkipList<Key,Comparator>.Insert","void leveldb.SkipList<Key,Comparator>.Insert<Key,Comparator> (Key)",db\skiplist.hpp,"void SkipList<Key,Comparator>::Insert(const Key& key) {
  // TODO(opt): We can use a barrier-free variant of FindGreaterOrEqual()
  // here since Insert() is externally synchronized.
  Node* prev[kMaxHeight];
  Node* x = FindGreaterOrEqual(key, prev);

  // Our data structure does not allow duplicate insertion
  assert(x == NULL || !Equal(key, x->key));

  int height = RandomHeight();
  if (height > GetMaxHeight()) {
    for (int i = GetMaxHeight(); i < height; i++) {
      prev[i] = head_;
    }
    //fprintf(stderr, ""Change height from %d to %d\n"", max_height_, height);

    // It is ok to mutate max_height_ without any synchronization
    // with concurrent readers.  A concurrent reader that observes
    // the new value of max_height_ will see either the old value of
    // new level pointers from head_ (NULL), or a new value set in
    // the loop below.  In the former case the reader will
    // immediately drop to the next level since NULL sorts after all
    // keys.  In the...",337.0,370.0,1.0,1.0,34.0,21,10,32,8,0,1,4,5,0,0,,0,1,2,1,1,void
1600,44949,Contains,1,"leveldb.SkipList<Key,Comparator>.Contains","bool leveldb.SkipList<Key,Comparator>.Contains<Key,Comparator> (Key)",db\skiplist.hpp,"bool SkipList<Key,Comparator>::Contains(const Key& key) const {
  Node* x = FindGreaterOrEqual(key, NULL);
  if (x != NULL && Equal(key, x->key)) {
    return true;
  } else {
    return false;
  }
}",373.0,380.0,1.0,1.0,8.0,4,4,7,3,0,1,2,2,1,0,,0,1,2,1,1,bool
1601,44999,operator (),1,leveldb.Comparator.operator (),"int leveldb.Comparator.operator () (Key,Key)",db\skiplist_test.cc,"int operator()(const Key& a, const Key& b) const {
    if (a < b) {
      return -1;
    } else if (a > b) {
      return +1;
    } else {
      return 0;
    }
  }",18.0,26.0,3.0,3.0,9.0,2,2,2,2,0,0,2,2,0,0,,0,0,4,2,2,int
1602,45208,_Run,1,leveldb._Test_InsertAndLookup._Run,void leveldb._Test_InsertAndLookup._Run (),db\skiplist_test.cc,"TEST(SkipTest, InsertAndLookup) {
  const int N = 2000;
  const int R = 5000;
  Random rnd(1000);
  std::set<Key> keys;
  Arena arena;
  Comparator cmp;
  SkipList<Key, Comparator> list(cmp, &arena);
  for (int i = 0; i < N; i++) {
    Key key = rnd.Next() % R;
    if (keys.insert(key).second) {
      list.Insert(key);
    }
  }

  for (int i = 0; i < R; i++) {
    if (list.Contains(i)) {
      ASSERT_EQ(keys.count(i), 1);
    } else {
      ASSERT_EQ(keys.count(i), 0);
    }
  }

  // Simple iterator tests
  {
    SkipList<Key, Comparator>::Iterator iter(&list);
    ASSERT_TRUE(!iter.Valid());

    iter.Seek(0);
    ASSERT_TRUE(iter.Valid());
    ASSERT_EQ(*(keys.begin()), iter.key());

    iter.SeekToFirst();
    ASSERT_TRUE(iter.Valid());
    ASSERT_EQ(*(keys.begin()), iter.key());

    iter.SeekToLast();
    ASSERT_TRUE(iter.Valid());
    ASSERT_EQ(*(keys.rbegin()), iter.key());
  }

  // Forward iteration test
  for (int i = 0; i < R; i++) {
    SkipList<Key, Comparator>::Itera...",47.0,123.0,1.0,31.0,77.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1603,45212,_RunIt,1,leveldb._Test_InsertAndLookup._RunIt,void leveldb._Test_InsertAndLookup._RunIt (),db\skiplist_test.cc,"TEST(SkipTest, InsertAndLookup)",47.0,47.0,1.0,31.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1604,45799,key,1,leveldb.ConcurrentTest.key,uint64_t leveldb.ConcurrentTest.key (Key),db\skiplist_test.cc,static uint64_t key(Key key) { return (key >> 40); },153.0,153.0,3.0,54.0,1.0,1,1,1,1,10,0,1,1,0,0,,0,0,2,1,1,uint64_t
1605,45808,gen,1,leveldb.ConcurrentTest.gen,uint64_t leveldb.ConcurrentTest.gen (Key),db\skiplist_test.cc,static uint64_t gen(Key key) { return (key >> 8) & 0xffffffffu; },154.0,154.0,3.0,67.0,1.0,2,2,1,1,5,0,1,1,0,0,,0,0,2,1,1,uint64_t
1606,45819,hash,1,leveldb.ConcurrentTest.hash,uint64_t leveldb.ConcurrentTest.hash (Key),db\skiplist_test.cc,static uint64_t hash(Key key) { return key & 0xff; },155.0,155.0,3.0,54.0,1.0,1,1,1,1,1,0,1,1,0,0,,0,0,2,1,1,uint64_t
1607,45828,HashNumbers,1,leveldb.ConcurrentTest.HashNumbers,"uint64_t leveldb.ConcurrentTest.HashNumbers (uint64_t,uint64_t)",db\skiplist_test.cc,"static uint64_t HashNumbers(uint64_t k, uint64_t g) {
    uint64_t data[2] = { k, g };
    return Hash(reinterpret_cast<char*>(data), sizeof(data), 0);
  }",157.0,160.0,3.0,3.0,4.0,4,4,5,3,2,0,1,1,0,0,,0,0,4,2,2,uint64_t
1608,45848,MakeKey,1,leveldb.ConcurrentTest.MakeKey,"Key leveldb.ConcurrentTest.MakeKey (uint64_t,uint64_t)",db\skiplist_test.cc,"static Key MakeKey(uint64_t k, uint64_t g) {
    assert(sizeof(Key) == sizeof(uint64_t));
    assert(k <= K);  // We sometimes pass K to seek to the end of the skiplist
    assert(g <= 0xffffffffu);
    return ((k << 40) | (g << 8) | (HashNumbers(k, g) & 0xff));
  }",162.0,167.0,3.0,3.0,6.0,10,6,9,5,2,2,1,1,0,1,,0,1,4,2,2,Key
1609,45882,IsValidKey,1,leveldb.ConcurrentTest.IsValidKey,bool leveldb.ConcurrentTest.IsValidKey (Key),db\skiplist_test.cc,"static bool IsValidKey(Key k) {
    return hash(k) == (HashNumbers(key(k), gen(k)) & 0xff);
  }",169.0,171.0,3.0,3.0,3.0,2,2,3,1,0,4,1,1,0,4,,0,2,2,1,1,bool
1610,45898,RandomTarget,1,leveldb.ConcurrentTest.RandomTarget,Key leveldb.ConcurrentTest.RandomTarget (Random*),db\skiplist_test.cc,"static Key RandomTarget(Random* rnd) {
    switch (rnd->Next() % 10) {
      case 0:
        // Seek to beginning
        return MakeKey(0, 0);
      case 1:
        // Seek to end
        return MakeKey(K, 0);
      default:
        // Seek to middle
        return MakeKey(rnd->Next() % K, 0);
    }
  }",173.0,185.0,3.0,3.0,13.0,4,2,4,2,1,2,2,2,0,0,,0,2,2,1,1,Key
1611,45935,Set,1,leveldb.ConcurrentTest.State.Set,"void leveldb.ConcurrentTest.State.Set (int,intptr_t)",db\skiplist_test.cc,"void Set(int k, intptr_t v) {
      generation[k].Release_Store(reinterpret_cast<void*>(v));
    }",190.0,192.0,5.0,5.0,3.0,3,3,3,3,0,1,1,1,0,0,,0,1,4,2,2,void
1612,45950,Get,1,leveldb.ConcurrentTest.State.Get,intptr_t leveldb.ConcurrentTest.State.Get (int),db\skiplist_test.cc,"intptr_t Get(int k) {
      return reinterpret_cast<intptr_t>(generation[k].Acquire_Load());
    }",193.0,195.0,5.0,5.0,3.0,3,3,2,2,0,1,1,1,0,0,,0,1,2,1,1,intptr_t
1613,45964,State,1,leveldb.ConcurrentTest.State.State,ANY leveldb.ConcurrentTest.State.State (),db\skiplist_test.cc,"State() {
      for (int k = 0; k < K; k++) {
        Set(k, 0);
      }
    }",197.0,201.0,5.0,5.0,5.0,2,2,4,2,0,0,2,2,0,0,,0,0,0,0,0,ANY
1614,45992,ConcurrentTest,1,leveldb.ConcurrentTest.ConcurrentTest,ANY leveldb.ConcurrentTest.ConcurrentTest (),db\skiplist_test.cc,"ConcurrentTest() : list_(Comparator(), &arena_) { }",214.0,214.0,3.0,53.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
1615,45996,WriteStep,1,leveldb.ConcurrentTest.WriteStep,void leveldb.ConcurrentTest.WriteStep (Random*),db\skiplist_test.cc,"void WriteStep(Random* rnd) {
    const uint32_t k = rnd->Next() % K;
    const intptr_t g = current_.Get(k) + 1;
    const Key key = MakeKey(k, g);
    list_.Insert(key);
    current_.Set(k, g);
  }",217.0,223.0,3.0,3.0,7.0,9,5,14,7,0,5,1,1,0,1,,0,5,2,1,1,void
1616,46037,ReadStep,1,leveldb.ConcurrentTest.ReadStep,void leveldb.ConcurrentTest.ReadStep (Random*),db\skiplist_test.cc,"void ReadStep(Random* rnd) {
    // Remember the initial committed state of the skiplist.
    State initial_state;
    for (int k = 0; k < K; k++) {
      initial_state.Set(k, current_.Get(k));
    }

    Key pos = RandomTarget(rnd);
    SkipList<Key, Comparator>::Iterator iter(&list_);
    iter.Seek(pos);
    while (true) {
      Key current;
      if (!iter.Valid()) {
        current = MakeKey(K, 0);
      } else {
        current = iter.key();
        ASSERT_TRUE(IsValidKey(current)) << current;
      }
      ASSERT_LE(pos, current) << ""should not go backwards"";

      // Verify that everything in [pos,current) was not present in
      // initial_state.
      while (pos < current) {
        ASSERT_LT(key(pos), K) << pos;

        // Note that generation 0 is never inserted, so it is ok if
        // <*,0,*> is missing.
        ASSERT_TRUE((gen(pos) == 0) ||
                    (gen(pos) > static_cast<Key>(initial_state.Get(key(pos))))
                    ) << ""key: "" << key(pos)
...",225.0,282.0,3.0,8.0,58.0,44,13,50,12,0,21,9,14,3,15,,0,13,2,1,1,void
1617,46301,_Run,1,leveldb._Test_ConcurrentWithoutThreads._Run,void leveldb._Test_ConcurrentWithoutThreads._Run (),db\skiplist_test.cc,"TEST(SkipTest, ConcurrentWithoutThreads) {
  ConcurrentTest test;
  Random rnd(test::RandomSeed());
  for (int i = 0; i < 10000; i++) {
    test.ReadStep(&rnd);
    test.WriteStep(&rnd);
  }
}",288.0,295.0,1.0,40.0,8.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1618,46305,_RunIt,1,leveldb._Test_ConcurrentWithoutThreads._RunIt,void leveldb._Test_ConcurrentWithoutThreads._RunIt (),db\skiplist_test.cc,"TEST(SkipTest, ConcurrentWithoutThreads)",288.0,288.0,1.0,40.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1619,46372,TestState,1,leveldb.TestState.TestState,ANY leveldb.TestState.TestState (int),db\skiplist_test.cc,"explicit TestState(int s)
      : seed_(s),
        quit_flag_(NULL),
        state_(STARTING),
        state_cv_(&mu_) {}",309.0,313.0,3.0,26.0,5.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
1620,46377,Wait,1,leveldb.TestState.Wait,void leveldb.TestState.Wait (ReaderState),db\skiplist_test.cc,"void Wait(ReaderState s) {
    mu_.Lock();
    while (state_ != s) {
      state_cv_.Wait();
    }
    mu_.Unlock();
  }",315.0,321.0,3.0,3.0,7.0,4,2,5,4,0,4,2,2,1,0,,0,4,2,1,1,void
1621,46399,Change,1,leveldb.TestState.Change,void leveldb.TestState.Change (ReaderState),db\skiplist_test.cc,"void Change(ReaderState s) {
    mu_.Lock();
    state_ = s;
    state_cv_.Signal();
    mu_.Unlock();
  }",323.0,328.0,3.0,3.0,6.0,4,2,5,4,0,4,1,1,0,0,,0,4,2,1,1,void
1622,46422,ConcurrentReader,1,leveldb.ConcurrentReader,void leveldb.ConcurrentReader (void*),db\skiplist_test.cc,"static void ConcurrentReader(void* arg) {
  TestState* state = reinterpret_cast<TestState*>(arg);
  Random rnd(state->seed_);
  int64_t reads = 0;
  state->Change(TestState::RUNNING);
  while (!state->quit_flag_.Acquire_Load()) {
    state->t_.ReadStep(&rnd);
    ++reads;
  }
  state->Change(TestState::DONE);
}",336.0,346.0,1.0,1.0,11.0,15,7,12,5,0,5,2,2,1,0,,0,5,2,1,1,void
1623,46475,RunConcurrent,1,leveldb.RunConcurrent,void leveldb.RunConcurrent (int),db\skiplist_test.cc,"static void RunConcurrent(int run) {
  const int seed = test::RandomSeed() + (run * 100);
  Random rnd(seed);
  const int N = 1000;
  const int kSize = 1000;
  for (int i = 0; i < N; i++) {
    if ((i % 100) == 0) {
      fprintf(stderr, ""Run %d of %d\n"", i, N);
    }
    TestState state(seed + 1);
    Env::Default()->Schedule(ConcurrentReader, &state);
    state.Wait(TestState::RUNNING);
    for (int i = 0; i < kSize; i++) {
      state.t_.WriteStep(&rnd);
    }
    state.quit_flag_.Release_Store(&state);  // Any non-NULL arg will do
    state.Wait(TestState::DONE);
  }
}",348.0,366.0,1.0,1.0,19.0,26,9,27,11,0,4,4,6,0,0,,0,4,2,1,1,void
1624,46584,_Run,1,leveldb._Test_Concurrent1._Run,void leveldb._Test_Concurrent1._Run (),db\skiplist_test.cc,"TEST(SkipTest, Concurrent1) { RunConcurrent(1); }",368.0,368.0,1.0,27.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1625,46588,_RunIt,1,leveldb._Test_Concurrent1._RunIt,void leveldb._Test_Concurrent1._RunIt (),db\skiplist_test.cc,"TEST(SkipTest, Concurrent1)",368.0,368.0,1.0,27.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1626,46619,_Run,1,leveldb._Test_Concurrent2._Run,void leveldb._Test_Concurrent2._Run (),db\skiplist_test.cc,"TEST(SkipTest, Concurrent2) { RunConcurrent(2); }",369.0,369.0,1.0,27.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1627,46623,_RunIt,1,leveldb._Test_Concurrent2._RunIt,void leveldb._Test_Concurrent2._RunIt (),db\skiplist_test.cc,"TEST(SkipTest, Concurrent2)",369.0,369.0,1.0,27.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1628,46654,_Run,1,leveldb._Test_Concurrent3._Run,void leveldb._Test_Concurrent3._Run (),db\skiplist_test.cc,"TEST(SkipTest, Concurrent3) { RunConcurrent(3); }",370.0,370.0,1.0,27.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1629,46658,_RunIt,1,leveldb._Test_Concurrent3._RunIt,void leveldb._Test_Concurrent3._RunIt (),db\skiplist_test.cc,"TEST(SkipTest, Concurrent3)",370.0,370.0,1.0,27.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1630,46689,_Run,1,leveldb._Test_Concurrent4._Run,void leveldb._Test_Concurrent4._Run (),db\skiplist_test.cc,"TEST(SkipTest, Concurrent4) { RunConcurrent(4); }",371.0,371.0,1.0,27.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1631,46693,_RunIt,1,leveldb._Test_Concurrent4._RunIt,void leveldb._Test_Concurrent4._RunIt (),db\skiplist_test.cc,"TEST(SkipTest, Concurrent4)",371.0,371.0,1.0,27.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1632,46724,_Run,1,leveldb._Test_Concurrent5._Run,void leveldb._Test_Concurrent5._Run (),db\skiplist_test.cc,"TEST(SkipTest, Concurrent5) { RunConcurrent(5); }",372.0,372.0,1.0,27.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1633,46728,_RunIt,1,leveldb._Test_Concurrent5._RunIt,void leveldb._Test_Concurrent5._RunIt (),db\skiplist_test.cc,"TEST(SkipTest, Concurrent5)",372.0,372.0,1.0,27.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1634,46789,SnapshotList,1,leveldb.SnapshotList.SnapshotList,ANY leveldb.SnapshotList.SnapshotList (),db\snapshot.hpp,"SnapshotList() {
    list_.prev_ = &list_;
    list_.next_ = &list_;
  }",33.0,36.0,3.0,3.0,4.0,6,3,4,1,0,4,1,1,0,0,,0,4,0,0,0,ANY
1635,46805,empty,1,leveldb.SnapshotList.empty,bool leveldb.SnapshotList.empty (),db\snapshot.hpp,bool empty() const { return list_.next_ == &list_; },38.0,38.0,3.0,54.0,1.0,3,3,2,1,0,2,1,1,0,0,,0,2,0,0,0,bool
1636,46816,oldest,1,leveldb.SnapshotList.oldest,SnapshotImpl leveldb.SnapshotList.oldest (),db\snapshot.hpp,SnapshotImpl* oldest() const { assert(!empty()); return list_.next_; },39.0,39.0,3.0,72.0,1.0,2,2,1,1,0,1,1,1,0,0,,0,1,0,0,0,SnapshotImpl
1637,46827,newest,1,leveldb.SnapshotList.newest,SnapshotImpl leveldb.SnapshotList.newest (),db\snapshot.hpp,SnapshotImpl* newest() const { assert(!empty()); return list_.prev_; },40.0,40.0,3.0,72.0,1.0,2,2,1,1,0,1,1,1,0,0,,0,1,0,0,0,SnapshotImpl
1638,46838,New,1,leveldb.SnapshotList.New,SnapshotImpl leveldb.SnapshotList.New (SequenceNumber),db\snapshot.hpp,"const SnapshotImpl* New(SequenceNumber seq) {
    SnapshotImpl* s = new SnapshotImpl;
    s->number_ = seq;
    s->list_ = this;
    s->next_ = &list_;
    s->prev_ = list_.prev_;
    s->prev_->next_ = s;
    s->next_->prev_ = s;
    return s;
  }",42.0,51.0,3.0,3.0,10.0,18,5,14,4,0,8,1,1,0,0,,0,8,2,1,1,SnapshotImpl
1639,46887,Delete,1,leveldb.SnapshotList.Delete,void leveldb.SnapshotList.Delete (SnapshotImpl*),db\snapshot.hpp,"void Delete(const SnapshotImpl* s) {
    assert(s->list_ == this);
    s->prev_->next_ = s->next_;
    s->next_->prev_ = s->prev_;
    delete s;
  }",53.0,58.0,3.0,3.0,6.0,11,4,6,1,0,5,1,1,0,0,,0,5,2,1,1,void
1640,46938,DeleteEntry,1,leveldb.DeleteEntry,"void leveldb.DeleteEntry (Slice,void*)",db\table_cache.cc,"static void DeleteEntry(const Slice& key, void* value) {
  TableAndFile* tf = reinterpret_cast<TableAndFile*>(value);
  delete tf->table;
  delete tf->file;
  delete tf;
}",19.0,24.0,1.0,1.0,6.0,7,4,5,2,0,2,1,1,0,0,,0,2,4,2,2,void
1641,46960,UnrefEntry,1,leveldb.UnrefEntry,"void leveldb.UnrefEntry (void*,void*)",db\table_cache.cc,"static void UnrefEntry(void* arg1, void* arg2) {
  Cache* cache = reinterpret_cast<Cache*>(arg1);
  Cache::Handle* h = reinterpret_cast<Cache::Handle*>(arg2);
  cache->Release(h);
}",26.0,30.0,1.0,1.0,5.0,5,3,6,4,0,0,1,1,0,0,,0,0,4,2,2,void
1642,46983,TableCache,1,leveldb.TableCache.TableCache,"ANY leveldb.TableCache.TableCache (ANY,Options*,int)",db\table_cache.cc,"TableCache::TableCache(const std::string& dbname,
                       const Options* options,
                       int entries)
    : env_(options->env),
      dbname_(dbname),
      options_(options),
      cache_(NewLRUCache(entries)) {
}",32.0,39.0,1.0,1.0,8.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,ANY
1643,46990,~TableCache,1,leveldb.TableCache.~TableCache,ANY leveldb.TableCache.~TableCache (),db\table_cache.cc,"TableCache::~TableCache() {
  delete cache_;
}",41.0,43.0,1.0,1.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,ANY
1644,46996,FindTable,1,leveldb.TableCache.FindTable,"Status leveldb.TableCache.FindTable (uint64_t,uint64_t,ANY**)",db\table_cache.cc,"Status TableCache::FindTable(uint64_t file_number, uint64_t file_size,
                             Cache::Handle** handle) {
  Status s;
  char buf[sizeof(file_number)];
  EncodeFixed64(buf, file_number);
  Slice key(buf, sizeof(buf));
  *handle = cache_->Lookup(key);
  if (*handle == NULL) {
    std::string fname = TableFileName(dbname_, file_number);
    RandomAccessFile* file = NULL;
    Table* table = NULL;
    s = env_->NewRandomAccessFile(fname, &file);
    if (!s.ok()) {
      std::string old_fname = SSTTableFileName(dbname_, file_number);
      if (env_->NewRandomAccessFile(old_fname, &file).ok()) {
        s = Status::OK();
      }
    }
    if (s.ok()) {
      s = Table::Open(*options_, file, file_size, &table);
    }

    if (!s.ok()) {
      assert(table == NULL);
      delete file;
      // We do not cache error results so that if the error is transient,
      // or somebody repairs the file, we recover automatically.
    } else {
      TableAndFile* tf = new TableAndF...",45.0,80.0,1.0,1.0,36.0,29,9,41,17,0,7,6,11,1,0,,0,7,6,3,3,Status
1645,47143,NewIterator,1,leveldb.TableCache.NewIterator,"Iterator leveldb.TableCache.NewIterator (ReadOptions,uint64_t,uint64_t,Table**)",db\table_cache.cc,"Iterator* TableCache::NewIterator(const ReadOptions& options,
                                  uint64_t file_number,
                                  uint64_t file_size,
                                  Table** tableptr) {
  if (tableptr != NULL) {
    *tableptr = NULL;
  }

  Cache::Handle* handle = NULL;
  Status s = FindTable(file_number, file_size, &handle);
  if (!s.ok()) {
    return NewErrorIterator(s);
  }

  Table* table = reinterpret_cast<TableAndFile*>(cache_->Value(handle))->table;
  Iterator* result = table->NewIterator(options);
  result->RegisterCleanup(&UnrefEntry, cache_, handle);
  if (tableptr != NULL) {
    *tableptr = table;
  }
  return result;
}",82.0,103.0,1.0,1.0,22.0,19,8,26,10,0,2,4,4,0,0,,0,2,8,4,4,Iterator
1646,47221,Get,1,leveldb.TableCache.Get,"Status leveldb.TableCache.Get (ReadOptions,uint64_t,uint64_t,Slice,void*,void)",db\table_cache.cc,"Status TableCache::Get(const ReadOptions& options,
                       uint64_t file_number,
                       uint64_t file_size,
                       const Slice& k,
                       void* arg,
                       void (*saver)(void*, const Slice&, const Slice&)) {
  Cache::Handle* handle = NULL;
  Status s = FindTable(file_number, file_size, &handle);
  if (s.ok()) {
    Table* t = reinterpret_cast<TableAndFile*>(cache_->Value(handle))->table;
    s = t->InternalGet(options, k, arg, saver);
    cache_->Release(handle);
  }
  return s;
}",105.0,119.0,1.0,1.0,15.0,11,5,19,11,0,2,2,2,0,0,,0,2,12,6,6,Status
1647,47278,Evict,1,leveldb.TableCache.Evict,void leveldb.TableCache.Evict (uint64_t),db\table_cache.cc,"void TableCache::Evict(uint64_t file_number) {
  char buf[sizeof(file_number)];
  EncodeFixed64(buf, file_number);
  cache_->Erase(Slice(buf, sizeof(buf)));
}",121.0,125.0,1.0,1.0,5.0,2,2,5,3,0,1,1,1,0,0,,0,1,2,1,1,void
1648,47409,Clear,1,leveldb.VersionEdit.Clear,void leveldb.VersionEdit.Clear (),db\version_edit.cc,"void VersionEdit::Clear() {
  comparator_.clear();
  log_number_ = 0;
  prev_log_number_ = 0;
  last_sequence_ = 0;
  next_file_number_ = 0;
  has_comparator_ = false;
  has_log_number_ = false;
  has_prev_log_number_ = false;
  has_next_file_number_ = false;
  has_last_sequence_ = false;
  deleted_files_.clear();
  new_files_.clear();
}",26.0,39.0,1.0,1.0,14.0,12,2,12,12,0,12,1,1,0,0,,0,12,0,0,0,void
1649,47452,EncodeTo,1,leveldb.VersionEdit.EncodeTo,void leveldb.VersionEdit.EncodeTo (ANY*),db\version_edit.cc,"void VersionEdit::EncodeTo(std::string* dst) const {
  if (has_comparator_) {
    PutVarint32(dst, kComparator);
    PutLengthPrefixedSlice(dst, comparator_);
  }
  if (has_log_number_) {
    PutVarint32(dst, kLogNumber);
    PutVarint64(dst, log_number_);
  }
  if (has_prev_log_number_) {
    PutVarint32(dst, kPrevLogNumber);
    PutVarint64(dst, prev_log_number_);
  }
  if (has_next_file_number_) {
    PutVarint32(dst, kNextFileNumber);
    PutVarint64(dst, next_file_number_);
  }
  if (has_last_sequence_) {
    PutVarint32(dst, kLastSequence);
    PutVarint64(dst, last_sequence_);
  }

  for (size_t i = 0; i < compact_pointers_.size(); i++) {
    PutVarint32(dst, kCompactPointer);
    PutVarint32(dst, compact_pointers_[i].first);  // level
    PutLengthPrefixedSlice(dst, compact_pointers_[i].second.Encode());
  }

  for (DeletedFileSet::const_iterator iter = deleted_files_.begin();
       iter != deleted_files_.end();
       ++iter) {
    PutVarint32(dst, kDeletedFile);
    PutVa...",41.0,86.0,1.0,1.0,46.0,28,6,65,25,0,22,9,9,8,0,,0,22,2,1,1,void
1650,47627,GetInternalKey,1,leveldb.GetInternalKey,"bool leveldb.GetInternalKey (Slice*,InternalKey*)",db\version_edit.cc,"static bool GetInternalKey(Slice* input, InternalKey* dst) {
  Slice str;
  if (GetLengthPrefixedSlice(input, &str)) {
    dst->DecodeFrom(str);
    return true;
  } else {
    return false;
  }
}",88.0,96.0,1.0,1.0,9.0,2,2,4,3,0,0,2,2,0,0,,0,0,4,2,2,bool
1651,47651,GetLevel,1,leveldb.GetLevel,"bool leveldb.GetLevel (Slice*,int*)",db\version_edit.cc,"static bool GetLevel(Slice* input, int* level) {
  uint32_t v;
  if (GetVarint32(input, &v) &&
      v < config::kNumLevels) {
    *level = v;
    return true;
  } else {
    return false;
  }
}",98.0,107.0,1.0,1.0,10.0,6,6,6,4,0,0,2,2,0,0,,0,0,4,2,2,bool
1652,47680,DecodeFrom,1,leveldb.VersionEdit.DecodeFrom,Status leveldb.VersionEdit.DecodeFrom (Slice),db\version_edit.cc,"Status VersionEdit::DecodeFrom(const Slice& src) {
  Clear();
  Slice input = src;
  const char* msg = NULL;
  uint32_t tag;

  // Temporary storage for parsing
  int level;
  uint64_t number;
  FileMetaData f;
  Slice str;
  InternalKey key;

  while (msg == NULL && GetVarint32(&input, &tag)) {
    switch (tag) {
      case kComparator:
        if (GetLengthPrefixedSlice(&input, &str)) {
          comparator_ = str.ToString();
          has_comparator_ = true;
        } else {
          msg = ""comparator name"";
        }
        break;

      case kLogNumber:
        if (GetVarint64(&input, &log_number_)) {
          has_log_number_ = true;
        } else {
          msg = ""log number"";
        }
        break;

      case kPrevLogNumber:
        if (GetVarint64(&input, &prev_log_number_)) {
          has_prev_log_number_ = true;
        } else {
          msg = ""previous log number"";
        }
        break;

      case kNextFileNumber:
        if (GetVarint64(&input, &next_file_n...",109.0,210.0,1.0,1.0,102.0,66,7,75,34,0,18,22,30,8,1,,0,18,2,1,1,Status
1653,47964,DebugString,1,leveldb.VersionEdit.DebugString,string leveldb.VersionEdit.DebugString (),db\version_edit.cc,"std::string VersionEdit::DebugString() const {
  std::string r;
  r.append(""VersionEdit {"");
  if (has_comparator_) {
    r.append(""\n  Comparator: "");
    r.append(comparator_);
  }
  if (has_log_number_) {
    r.append(""\n  LogNumber: "");
    AppendNumberTo(&r, log_number_);
  }
  if (has_prev_log_number_) {
    r.append(""\n  PrevLogNumber: "");
    AppendNumberTo(&r, prev_log_number_);
  }
  if (has_next_file_number_) {
    r.append(""\n  NextFile: "");
    AppendNumberTo(&r, next_file_number_);
  }
  if (has_last_sequence_) {
    r.append(""\n  LastSeq: "");
    AppendNumberTo(&r, last_sequence_);
  }
  for (size_t i = 0; i < compact_pointers_.size(); i++) {
    r.append(""\n  CompactPointer: "");
    AppendNumberTo(&r, compact_pointers_[i].first);
    r.append("" "");
    r.append(compact_pointers_[i].second.DebugString());
  }
  for (DeletedFileSet::const_iterator iter = deleted_files_.begin();
       iter != deleted_files_.end();
       ++iter) {
    r.append(""\n  DeleteFile: "");
    ...",212.0,264.0,1.0,1.0,53.0,58,7,66,17,0,22,9,9,8,0,,0,22,0,0,0,string
1654,48237,FileMetaData,1,leveldb.FileMetaData.FileMetaData,ANY leveldb.FileMetaData.FileMetaData (),db\version_edit.hpp,"FileMetaData() : refs(0), allowed_seeks(1 << 30), file_size(0) { }",25.0,25.0,3.0,68.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
1655,48242,VersionEdit,1,leveldb.VersionEdit.VersionEdit,ANY leveldb.VersionEdit.VersionEdit (),db\version_edit.hpp,VersionEdit() { Clear(); },30.0,30.0,3.0,28.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
1656,48247,~VersionEdit,1,leveldb.VersionEdit.~VersionEdit,ANY leveldb.VersionEdit.~VersionEdit (),db\version_edit.hpp,~VersionEdit() { },31.0,31.0,3.0,20.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
1657,48255,SetComparatorName,1,leveldb.VersionEdit.SetComparatorName,void leveldb.VersionEdit.SetComparatorName (Slice),db\version_edit.hpp,"void SetComparatorName(const Slice& name) {
    has_comparator_ = true;
    comparator_ = name.ToString();
  }",35.0,38.0,3.0,3.0,4.0,3,2,3,3,0,2,1,1,0,0,,0,2,2,1,1,void
1658,48269,SetLogNumber,1,leveldb.VersionEdit.SetLogNumber,void leveldb.VersionEdit.SetLogNumber (uint64_t),db\version_edit.hpp,"void SetLogNumber(uint64_t num) {
    has_log_number_ = true;
    log_number_ = num;
  }",39.0,42.0,3.0,3.0,4.0,2,1,3,3,0,2,1,1,0,0,,0,2,2,1,1,void
1659,48280,SetPrevLogNumber,1,leveldb.VersionEdit.SetPrevLogNumber,void leveldb.VersionEdit.SetPrevLogNumber (uint64_t),db\version_edit.hpp,"void SetPrevLogNumber(uint64_t num) {
    has_prev_log_number_ = true;
    prev_log_number_ = num;
  }",43.0,46.0,3.0,3.0,4.0,2,1,3,3,0,2,1,1,0,0,,0,2,2,1,1,void
1660,48291,SetNextFile,1,leveldb.VersionEdit.SetNextFile,void leveldb.VersionEdit.SetNextFile (uint64_t),db\version_edit.hpp,"void SetNextFile(uint64_t num) {
    has_next_file_number_ = true;
    next_file_number_ = num;
  }",47.0,50.0,3.0,3.0,4.0,2,1,3,3,0,2,1,1,0,0,,0,2,2,1,1,void
1661,48302,SetLastSequence,1,leveldb.VersionEdit.SetLastSequence,void leveldb.VersionEdit.SetLastSequence (SequenceNumber),db\version_edit.hpp,"void SetLastSequence(SequenceNumber seq) {
    has_last_sequence_ = true;
    last_sequence_ = seq;
  }",51.0,54.0,3.0,3.0,4.0,2,1,3,3,0,2,1,1,0,0,,0,2,2,1,1,void
1662,48313,SetCompactPointer,1,leveldb.VersionEdit.SetCompactPointer,"void leveldb.VersionEdit.SetCompactPointer (int,InternalKey)",db\version_edit.hpp,"void SetCompactPointer(int level, const InternalKey& key) {
    compact_pointers_.push_back(std::make_pair(level, key));
  }",55.0,57.0,3.0,3.0,3.0,2,1,4,4,0,1,1,1,0,0,,0,1,4,2,2,void
1663,48329,AddFile,1,leveldb.VersionEdit.AddFile,"void leveldb.VersionEdit.AddFile (int,uint64_t,uint64_t,InternalKey,InternalKey)",db\version_edit.hpp,"void AddFile(int level, uint64_t file,
               uint64_t file_size,
               const InternalKey& smallest,
               const InternalKey& largest) {
    FileMetaData f;
    f.number = file;
    f.file_size = file_size;
    f.smallest = smallest;
    f.largest = largest;
    new_files_.push_back(std::make_pair(level, f));
  }",62.0,72.0,3.0,3.0,11.0,10,2,12,8,0,5,1,1,0,0,,0,5,10,5,5,void
1664,48369,DeleteFile,1,leveldb.VersionEdit.DeleteFile,"void leveldb.VersionEdit.DeleteFile (int,uint64_t)",db\version_edit.hpp,"void DeleteFile(int level, uint64_t file) {
    deleted_files_.insert(std::make_pair(level, file));
  }",75.0,77.0,3.0,3.0,3.0,2,1,4,4,0,1,1,1,0,0,,0,1,4,2,2,void
1665,48424,TestEncodeDecode,1,leveldb.TestEncodeDecode,void leveldb.TestEncodeDecode (VersionEdit),db\version_edit_test.cc,"static void TestEncodeDecode(const VersionEdit& edit) {
  std::string encoded, encoded2;
  edit.EncodeTo(&encoded);
  VersionEdit parsed;
  Status s = parsed.DecodeFrom(encoded);
  ASSERT_TRUE(s.ok()) << s.ToString();
  parsed.EncodeTo(&encoded2);
  ASSERT_EQ(encoded, encoded2);
}",10.0,18.0,1.0,2.0,9.0,16,4,18,7,0,0,1,1,0,0,,0,0,2,1,1,void
1666,48498,_Run,1,leveldb._Test_EncodeDecode._Run,void leveldb._Test_EncodeDecode._Run (),db\version_edit_test.cc,"TEST(VersionEditTest, EncodeDecode) {
  static const uint64_t kBig = 1ull << 50;

  VersionEdit edit;
  for (int i = 0; i < 4; i++) {
    TestEncodeDecode(edit);
    edit.AddFile(3, kBig + 300 + i, kBig + 400 + i,
                 InternalKey(""foo"", kBig + 500 + i, kTypeValue),
                 InternalKey(""zoo"", kBig + 600 + i, kTypeDeletion));
    edit.DeleteFile(4, kBig + 700 + i);
    edit.SetCompactPointer(i, InternalKey(""x"", kBig + 900 + i, kTypeValue));
  }

  edit.SetComparatorName(""foo"");
  edit.SetLogNumber(kBig + 100);
  edit.SetNextFile(kBig + 200);
  edit.SetLastSequence(kBig + 1000);
  TestEncodeDecode(edit);
}",22.0,40.0,1.0,35.0,19.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1667,48502,_RunIt,1,leveldb._Test_EncodeDecode._RunIt,void leveldb._Test_EncodeDecode._RunIt (),db\version_edit_test.cc,"TEST(VersionEditTest, EncodeDecode)",22.0,22.0,1.0,35.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1668,48680,TargetFileSize,1,leveldb.TargetFileSize,int leveldb.TargetFileSize (Options*),db\version_set.cc,"static int TargetFileSize(const Options* options) {
  return options->max_file_size;
}",23.0,25.0,1.0,1.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,int
1669,48689,MaxGrandParentOverlapBytes,1,leveldb.MaxGrandParentOverlapBytes,int64_t leveldb.MaxGrandParentOverlapBytes (Options*),db\version_set.cc,"static int64_t MaxGrandParentOverlapBytes(const Options* options) {
  return 10 * TargetFileSize(options);
}",29.0,31.0,1.0,1.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,int64_t
1670,48699,ExpandedCompactionByteSizeLimit,1,leveldb.ExpandedCompactionByteSizeLimit,int64_t leveldb.ExpandedCompactionByteSizeLimit (Options*),db\version_set.cc,"static int64_t ExpandedCompactionByteSizeLimit(const Options* options) {
  return 25 * TargetFileSize(options);
}",36.0,38.0,1.0,1.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,int64_t
1671,48709,MaxBytesForLevel,1,leveldb.MaxBytesForLevel,"double leveldb.MaxBytesForLevel (Options*,int)",db\version_set.cc,"static double MaxBytesForLevel(const Options* options, int level) {
  // Note: the result for level zero is not really used since we set
  // the level-0 compaction threshold based on number of files.

  // Result for both level-0 and level-1
  double result = 10. * 1048576.0;
  while (level > 1) {
    result *= 10;
    level--;
  }
  return result;
}",40.0,51.0,1.0,1.0,12.0,5,5,5,2,0,0,2,2,0,0,,0,0,4,2,2,double
1672,48733,MaxFileSizeForLevel,1,leveldb.MaxFileSizeForLevel,"uint64_t leveldb.MaxFileSizeForLevel (Options*,int)",db\version_set.cc,"static uint64_t MaxFileSizeForLevel(const Options* options, int level) {
  // We could vary per level to reduce number of files?
  return TargetFileSize(options);
}",53.0,56.0,1.0,1.0,4.0,0,0,1,1,0,0,1,1,0,0,,0,0,4,2,2,uint64_t
1673,48742,TotalFileSize,1,leveldb.TotalFileSize,int64_t leveldb.TotalFileSize (ANY),db\version_set.cc,"static int64_t TotalFileSize(const std::vector<FileMetaData*>& files) {
  int64_t sum = 0;
  for (size_t i = 0; i < files.size(); i++) {
    sum += files[i]->file_size;
  }
  return sum;
}",58.0,64.0,1.0,1.0,7.0,7,6,8,3,0,0,2,2,0,0,,0,0,2,1,1,int64_t
1674,48775,~Version,1,leveldb.Version.~Version,ANY leveldb.Version.~Version (),db\version_set.cc,"Version::~Version() {
  assert(refs_ == 0);

  // Remove from linked list
  prev_->next_ = next_;
  next_->prev_ = prev_;

  // Drop references to files
  for (int level = 0; level < config::kNumLevels; level++) {
    for (size_t i = 0; i < files_[level].size(); i++) {
      FileMetaData* f = files_[level][i];
      assert(f->refs > 0);
      f->refs--;
      if (f->refs <= 0) {
        delete f;
      }
    }
  }
}",66.0,84.0,1.0,1.0,19.0,22,10,20,8,0,12,4,7,2,0,,0,12,0,0,0,ANY
1675,48851,FindFile,1,leveldb.FindFile,"int leveldb.FindFile (InternalKeyComparator,ANY,Slice)",db\version_set.cc,"int FindFile(const InternalKeyComparator& icmp,
             const std::vector<FileMetaData*>& files,
             const Slice& key) {
  uint32_t left = 0;
  uint32_t right = files.size();
  while (left < right) {
    uint32_t mid = (left + right) / 2;
    const FileMetaData* f = files[mid];
    if (icmp.InternalKeyComparator::Compare(f->largest.Encode(), key) < 0) {
      // Key at ""mid.largest"" is < ""target"".  Therefore all
      // files at or before ""mid"" are uninteresting.
      left = mid + 1;
    } else {
      // Key at ""mid.largest"" is >= ""target"".  Therefore all files
      // after ""mid"" are uninteresting.
      right = mid;
    }
  }
  return right;
}",86.0,105.0,1.0,1.0,20.0,15,7,17,7,0,1,3,4,1,0,,0,1,6,3,3,int
1676,48915,AfterFile,1,leveldb.AfterFile,"bool leveldb.AfterFile (Comparator*,Slice*,FileMetaData*)",db\version_set.cc,"static bool AfterFile(const Comparator* ucmp,
                      const Slice* user_key, const FileMetaData* f) {
  // NULL user_key occurs before all keys and is therefore never after *f
  return (user_key != NULL &&
          ucmp->Compare(*user_key, f->largest.user_key()) > 0);
}",107.0,112.0,1.0,1.0,6.0,7,6,5,4,0,1,1,1,0,0,,0,1,6,3,3,bool
1677,48941,BeforeFile,1,leveldb.BeforeFile,"bool leveldb.BeforeFile (Comparator*,Slice*,FileMetaData*)",db\version_set.cc,"static bool BeforeFile(const Comparator* ucmp,
                       const Slice* user_key, const FileMetaData* f) {
  // NULL user_key occurs after all keys and is therefore never before *f
  return (user_key != NULL &&
          ucmp->Compare(*user_key, f->smallest.user_key()) < 0);
}",114.0,119.0,1.0,1.0,6.0,7,6,5,4,0,1,1,1,0,0,,0,1,6,3,3,bool
1678,48967,SomeFileOverlapsRange,1,leveldb.SomeFileOverlapsRange,"bool leveldb.SomeFileOverlapsRange (InternalKeyComparator,bool,ANY,Slice*,Slice*)",db\version_set.cc,"bool SomeFileOverlapsRange(
    const InternalKeyComparator& icmp,
    bool disjoint_sorted_files,
    const std::vector<FileMetaData*>& files,
    const Slice* smallest_user_key,
    const Slice* largest_user_key) {
  const Comparator* ucmp = icmp.user_comparator();
  if (!disjoint_sorted_files) {
    // Need to check against all files
    for (size_t i = 0; i < files.size(); i++) {
      const FileMetaData* f = files[i];
      if (AfterFile(ucmp, smallest_user_key, f) ||
          BeforeFile(ucmp, largest_user_key, f)) {
        // No overlap
      } else {
        return true;  // Overlap
      }
    }
    return false;
  }

  // Binary search over file list
  uint32_t index = 0;
  if (smallest_user_key != NULL) {
    // Find the earliest possible internal key for smallest_user_key
    InternalKey small(*smallest_user_key, kMaxSequenceNumber,kValueTypeForSeek);
    index = FindFile(icmp, files, small.Encode());
  }

  if (index >= files.size()) {
    // beginning of range is afte...",121.0,156.0,1.0,1.0,36.0,18,9,31,13,0,0,6,9,0,0,,0,0,10,5,5,bool
1679,49068,LevelFileNumIterator,1,leveldb.LevelFileNumIterator.LevelFileNumIterator,"ANY leveldb.LevelFileNumIterator.LevelFileNumIterator (InternalKeyComparator,ANY*)",db\version_set.cc,"LevelFileNumIterator(const InternalKeyComparator& icmp,
                       const std::vector<FileMetaData*>* flist)
      : icmp_(icmp),
        flist_(flist),
        index_(flist->size()) {        // Marks as invalid
  }",165.0,170.0,3.0,3.0,6.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,ANY
1680,49074,Valid,1,leveldb.LevelFileNumIterator.Valid,bool leveldb.LevelFileNumIterator.Valid (),db\version_set.cc,"virtual bool Valid() const {
    return index_ < flist_->size();
  }",171.0,173.0,3.0,3.0,3.0,2,2,2,2,0,2,1,1,0,0,,0,2,0,0,0,bool
1681,49085,Seek,1,leveldb.LevelFileNumIterator.Seek,void leveldb.LevelFileNumIterator.Seek (Slice),db\version_set.cc,"virtual void Seek(const Slice& target) {
    index_ = FindFile(icmp_, *flist_, target);
  }",174.0,176.0,3.0,3.0,3.0,2,2,4,4,0,3,1,1,0,0,,0,3,2,1,1,void
1682,49097,SeekToFirst,1,leveldb.LevelFileNumIterator.SeekToFirst,void leveldb.LevelFileNumIterator.SeekToFirst (),db\version_set.cc,virtual void SeekToFirst() { index_ = 0; },177.0,177.0,3.0,44.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,void
1683,49104,SeekToLast,1,leveldb.LevelFileNumIterator.SeekToLast,void leveldb.LevelFileNumIterator.SeekToLast (),db\version_set.cc,"virtual void SeekToLast() {
    index_ = flist_->empty() ? 0 : flist_->size() - 1;
  }",178.0,180.0,3.0,3.0,3.0,5,4,3,2,0,3,1,1,0,0,,0,3,0,0,0,void
1684,49122,Next,1,leveldb.LevelFileNumIterator.Next,void leveldb.LevelFileNumIterator.Next (),db\version_set.cc,"virtual void Next() {
    assert(Valid());
    index_++;
  }",181.0,184.0,3.0,3.0,4.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,void
1685,49130,Prev,1,leveldb.LevelFileNumIterator.Prev,void leveldb.LevelFileNumIterator.Prev (),db\version_set.cc,"virtual void Prev() {
    assert(Valid());
    if (index_ == 0) {
      index_ = flist_->size();  // Marks as invalid
    } else {
      index_--;
    }
  }",185.0,192.0,3.0,3.0,8.0,3,3,3,2,0,3,2,2,1,0,,0,3,0,0,0,void
1686,49151,key,1,leveldb.LevelFileNumIterator.key,Slice leveldb.LevelFileNumIterator.key (),db\version_set.cc,"Slice key() const {
    assert(Valid());
    return (*flist_)[index_]->largest.Encode();
  }",193.0,196.0,3.0,3.0,4.0,4,4,2,2,0,2,1,1,0,0,,0,2,0,0,0,Slice
1687,49167,value,1,leveldb.LevelFileNumIterator.value,Slice leveldb.LevelFileNumIterator.value (),db\version_set.cc,"Slice value() const {
    assert(Valid());
    EncodeFixed64(value_buf_, (*flist_)[index_]->number);
    EncodeFixed64(value_buf_+8, (*flist_)[index_]->file_size);
    return Slice(value_buf_, sizeof(value_buf_));
  }",197.0,202.0,3.0,3.0,6.0,8,5,8,3,0,8,1,1,0,0,,0,8,0,0,0,Slice
1688,49196,status,1,leveldb.LevelFileNumIterator.status,Status leveldb.LevelFileNumIterator.status (),db\version_set.cc,virtual Status status() const { return Status::OK(); },203.0,203.0,3.0,56.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,0,0,0,0,Status
1689,49215,GetFileIterator,1,leveldb.GetFileIterator,"Iterator leveldb.GetFileIterator (void*,ReadOptions,Slice)",db\version_set.cc,"static Iterator* GetFileIterator(void* arg,
                                 const ReadOptions& options,
                                 const Slice& file_value) {
  TableCache* cache = reinterpret_cast<TableCache*>(arg);
  if (file_value.size() != 16) {
    return NewErrorIterator(
        Status::Corruption(""FileReader invoked with unexpected value""));
  } else {
    return cache->NewIterator(options,
                              DecodeFixed64(file_value.data()),
                              DecodeFixed64(file_value.data() + 8));
  }
}",213.0,225.0,1.0,1.0,13.0,5,4,4,4,0,1,2,2,0,1,,0,0,6,3,3,Iterator
1690,49263,NewConcatenatingIterator,1,leveldb.Version.NewConcatenatingIterator,"Iterator leveldb.Version.NewConcatenatingIterator (ReadOptions,int)",db\version_set.cc,"Iterator* Version::NewConcatenatingIterator(const ReadOptions& options,
                                            int level) const {
  return NewTwoLevelIterator(
      new LevelFileNumIterator(vset_->icmp_, &files_[level]),
      &GetFileIterator, vset_->table_cache_, options);
}",227.0,232.0,1.0,1.0,6.0,6,4,6,5,0,3,1,1,0,0,,0,3,4,2,2,Iterator
1691,49286,AddIterators,1,leveldb.Version.AddIterators,"void leveldb.Version.AddIterators (ReadOptions,ANY*)",db\version_set.cc,"void Version::AddIterators(const ReadOptions& options,
                           std::vector<Iterator*>* iters) {
  // Merge all level zero files together since they may overlap
  for (size_t i = 0; i < files_[0].size(); i++) {
    iters->push_back(
        vset_->table_cache_->NewIterator(
            options, files_[0][i]->number, files_[0][i]->file_size));
  }

  // For levels > 0, we can use a concatenating iterator that sequentially
  // walks through the non-overlapping files in the level, opening them
  // lazily.
  for (int level = 1; level < config::kNumLevels; level++) {
    if (!files_[level].empty()) {
      iters->push_back(NewConcatenatingIterator(options, level));
    }
  }
}",234.0,251.0,1.0,1.0,18.0,20,6,18,7,0,5,4,5,2,0,,0,5,4,2,2,void
1692,49375,SaveValue,1,leveldb.SaveValue,"void leveldb.SaveValue (void*,Slice,Slice)",db\version_set.cc,"static void SaveValue(void* arg, const Slice& ikey, const Slice& v) {
  Saver* s = reinterpret_cast<Saver*>(arg);
  ParsedInternalKey parsed_key;
  if (!ParseInternalKey(ikey, &parsed_key)) {
    s->state = kCorrupt;
  } else {
    if (s->ucmp->Compare(parsed_key.user_key, s->user_key) == 0) {
      s->state = (parsed_key.type == kTypeValue) ? kFound : kDeleted;
      if (s->state == kFound) {
        s->value->assign(v.data(), v.size());
      }
    }
  }
}",268.0,281.0,1.0,1.0,14.0,6,5,6,5,0,1,2,2,0,0,,0,1,6,3,3,void
1693,49452,NewestFirst,1,leveldb.NewestFirst,"bool leveldb.NewestFirst (FileMetaData*,FileMetaData*)",db\version_set.cc,"static bool NewestFirst(FileMetaData* a, FileMetaData* b) {
  return a->number > b->number;
}",283.0,285.0,1.0,1.0,3.0,3,2,2,2,0,2,1,1,0,0,,0,2,4,2,2,bool
1694,49466,ForEachOverlapping,1,leveldb.Version.ForEachOverlapping,"void leveldb.Version.ForEachOverlapping (Slice,Slice,void*,bool)",db\version_set.cc,"void Version::ForEachOverlapping(Slice user_key, Slice internal_key,
                                 void* arg,
                                 bool (*func)(void*, int, FileMetaData*)) {
  // TODO(sanjay): Change Version::Get() to use this function.
  const Comparator* ucmp = vset_->icmp_.user_comparator();

  // Search level-0 in order from newest to oldest.
  std::vector<FileMetaData*> tmp;
  tmp.reserve(files_[0].size());
  for (uint32_t i = 0; i < files_[0].size(); i++) {
    FileMetaData* f = files_[0][i];
    if (ucmp->Compare(user_key, f->smallest.user_key()) >= 0 &&
        ucmp->Compare(user_key, f->largest.user_key()) <= 0) {
      tmp.push_back(f);
    }
  }
  if (!tmp.empty()) {
    std::sort(tmp.begin(), tmp.end(), NewestFirst);
    for (uint32_t i = 0; i < tmp.size(); i++) {
      if (!(*func)(arg, 0, tmp[i])) {
        return;
      }
    }
  }

  // Search other levels.
  for (int level = 1; level < config::kNumLevels; level++) {
    size_t num_files = files_[level...",287.0,330.0,1.0,1.0,44.0,52,11,50,15,0,11,11,18,4,0,,0,11,8,4,4,void
1695,49680,Get,1,leveldb.Version.Get,"Status leveldb.Version.Get (ReadOptions,LookupKey,ANY*,GetStats*)",db\version_set.cc,"Status Version::Get(const ReadOptions& options,
                    const LookupKey& k,
                    std::string* value,
                    GetStats* stats) {
  Slice ikey = k.internal_key();
  Slice user_key = k.user_key();
  const Comparator* ucmp = vset_->icmp_.user_comparator();
  Status s;

  stats->seek_file = NULL;
  stats->seek_file_level = -1;
  FileMetaData* last_file_read = NULL;
  int last_file_read_level = -1;

  // We can search level-by-level since entries never hop across
  // levels.  Therefore we are guaranteed that if we find data
  // in an smaller level, later levels are irrelevant.
  std::vector<FileMetaData*> tmp;
  FileMetaData* tmp2;
  for (int level = 0; level < config::kNumLevels; level++) {
    size_t num_files = files_[level].size();
    if (num_files == 0) continue;

    // Get the list of files to search in this level
    FileMetaData* const* files = &files_[level][0];
    if (level == 0) {
      // Level-0 files may overlap each other.  Find a...",332.0,429.0,1.0,1.0,98.0,87,13,96,27,0,21,14,27,4,3,,0,20,8,4,4,Status
1696,50062,UpdateStats,1,leveldb.Version.UpdateStats,bool leveldb.Version.UpdateStats (GetStats),db\version_set.cc,"bool Version::UpdateStats(const GetStats& stats) {
  FileMetaData* f = stats.seek_file;
  if (f != NULL) {
    f->allowed_seeks--;
    if (f->allowed_seeks <= 0 && file_to_compact_ == NULL) {
      file_to_compact_ = f;
      file_to_compact_level_ = stats.seek_file_level;
      return true;
    }
  }
  return false;
}",431.0,442.0,1.0,1.0,12.0,12,8,12,5,0,7,3,4,2,0,,0,7,2,1,1,bool
1697,50105,RecordReadSample,1,leveldb.Version.RecordReadSample,bool leveldb.Version.RecordReadSample (Slice),db\version_set.cc,"bool Version::RecordReadSample(Slice internal_key) {
  ParsedInternalKey ikey;
  if (!ParseInternalKey(internal_key, &ikey)) {
    return false;
  }

  struct State {
    GetStats stats;  // Holds first matching file
    int matches;

    static bool Match(void* arg, int level, FileMetaData* f) {
      State* state = reinterpret_cast<State*>(arg);
      state->matches++;
      if (state->matches == 1) {
        // Remember first match.
        state->stats.seek_file = f;
        state->stats.seek_file_level = level;
      }
      // We can stop iterating once we have a second match.
      return state->matches < 2;
    }
  };

  State state;
  state.matches = 0;
  ForEachOverlapping(ikey.user_key, internal_key, &state, &State::Match);

  // Must have at least two matches since we want to merge across
  // files. But what if we have a single file that contains many
  // overwrites and deletions?  Should we have another mechanism for
  // finding such files?
  if (state.matches >= 2) ...",444.0,480.0,1.0,1.0,37.0,11,5,9,4,0,1,3,3,0,0,,0,1,2,1,1,bool
1698,50151,Ref,1,leveldb.Version.Ref,void leveldb.Version.Ref (),db\version_set.cc,"void Version::Ref() {
  ++refs_;
}",482.0,484.0,1.0,1.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,void
1699,50157,Unref,1,leveldb.Version.Unref,void leveldb.Version.Unref (),db\version_set.cc,"void Version::Unref() {
  assert(this != &vset_->dummy_versions_);
  assert(refs_ >= 1);
  --refs_;
  if (refs_ == 0) {
    delete this;
  }
}",486.0,493.0,1.0,1.0,8.0,7,7,4,2,0,4,2,2,1,0,,0,4,0,0,0,void
1700,50181,OverlapInLevel,1,leveldb.Version.OverlapInLevel,"bool leveldb.Version.OverlapInLevel (int,Slice*,Slice*)",db\version_set.cc,"bool Version::OverlapInLevel(int level,
                             const Slice* smallest_user_key,
                             const Slice* largest_user_key) {
  return SomeFileOverlapsRange(vset_->icmp_, (level > 0), files_[level],
                               smallest_user_key, largest_user_key);
}",495.0,500.0,1.0,1.0,6.0,3,3,6,5,0,2,1,1,0,0,,0,2,6,3,3,bool
1701,50201,PickLevelForMemTableOutput,1,leveldb.Version.PickLevelForMemTableOutput,"int leveldb.Version.PickLevelForMemTableOutput (Slice,Slice)",db\version_set.cc,"int Version::PickLevelForMemTableOutput(
    const Slice& smallest_user_key,
    const Slice& largest_user_key) {
  int level = 0;
  if (!OverlapInLevel(0, &smallest_user_key, &largest_user_key)) {
    // Push to next level if there is no overlap in next level,
    // and the #bytes overlapping in the level after that are limited.
    InternalKey start(smallest_user_key, kMaxSequenceNumber, kValueTypeForSeek);
    InternalKey limit(largest_user_key, 0, static_cast<ValueType>(0));
    std::vector<FileMetaData*> overlaps;
    while (level < config::kMaxMemCompactLevel) {
      if (OverlapInLevel(level + 1, &smallest_user_key, &largest_user_key)) {
        break;
      }
      if (level + 2 < config::kNumLevels) {
        // Check that file does not overlap too many grandparent bytes.
        GetOverlappingInputs(level + 2, &start, &limit, &overlaps);
        const int64_t sum = TotalFileSize(overlaps);
        if (sum > MaxGrandParentOverlapBytes(vset_->options_)) {
          break;
 ...",502.0,528.0,1.0,1.0,27.0,21,10,24,11,0,1,8,14,1,0,,0,1,4,2,2,int
1702,50288,GetOverlappingInputs,1,leveldb.Version.GetOverlappingInputs,"void leveldb.Version.GetOverlappingInputs (int,InternalKey*,InternalKey*,ANY*)",db\version_set.cc,"void Version::GetOverlappingInputs(
    int level,
    const InternalKey* begin,
    const InternalKey* end,
    std::vector<FileMetaData*>* inputs) {
  assert(level >= 0);
  assert(level < config::kNumLevels);
  inputs->clear();
  Slice user_begin, user_end;
  if (begin != NULL) {
    user_begin = begin->user_key();
  }
  if (end != NULL) {
    user_end = end->user_key();
  }
  const Comparator* user_cmp = vset_->icmp_.user_comparator();
  for (size_t i = 0; i < files_[level].size(); ) {
    FileMetaData* f = files_[level][i++];
    const Slice file_start = f->smallest.user_key();
    const Slice file_limit = f->largest.user_key();
    if (begin != NULL && user_cmp->Compare(file_limit, user_begin) < 0) {
      // ""f"" is completely before specified range; skip it
    } else if (end != NULL && user_cmp->Compare(file_start, user_end) > 0) {
      // ""f"" is completely after specified range; skip it
    } else {
      inputs->push_back(f);
      if (level == 0) {
        // Level-0 file...",531.0,572.0,1.0,1.0,42.0,31,9,31,15,0,5,5,6,1,0,,0,5,8,4,4,void
1703,50477,DebugString,1,leveldb.Version.DebugString,string leveldb.Version.DebugString (),db\version_set.cc,"std::string Version::DebugString() const {
  std::string r;
  for (int level = 0; level < config::kNumLevels; level++) {
    // E.g.,
    //   --- level 1 ---
    //   17:123['a' .. 'd']
    //   20:43['e' .. 'g']
    r.append(""--- level "");
    AppendNumberTo(&r, level);
    r.append("" ---\n"");
    const std::vector<FileMetaData*>& files = files_[level];
    for (size_t i = 0; i < files.size(); i++) {
      r.push_back(' ');
      AppendNumberTo(&r, files[i]->number);
      r.push_back(':');
      AppendNumberTo(&r, files[i]->file_size);
      r.append(""["");
      r.append(files[i]->smallest.DebugString());
      r.append("" .. "");
      r.append(files[i]->largest.DebugString());
      r.append(""]\n"");
    }
  }
  return r;
}",574.0,598.0,1.0,1.0,25.0,30,6,31,6,0,1,3,4,0,0,,0,1,0,0,0,string
1704,50601,operator (),1,leveldb.Builder.BySmallestKey.operator (),"bool leveldb.Builder.BySmallestKey.operator () (FileMetaData*,FileMetaData*)",db\version_set.cc,"bool operator()(FileMetaData* f1, FileMetaData* f2) const {
      int r = internal_comparator->Compare(f1->smallest, f2->smallest);
      if (r != 0) {
        return (r < 0);
      } else {
        // Break ties by file number
        return (f1->number < f2->number);
      }
    }",609.0,617.0,5.0,5.0,9.0,6,4,6,4,0,2,2,2,0,0,,0,2,4,2,2,bool
1705,50646,Builder,1,leveldb.Builder.Builder,"ANY leveldb.Builder.Builder (VersionSet*,Version*)",db\version_set.cc,"Builder(VersionSet* vset, Version* base)
      : vset_(vset),
        base_(base) {
    base_->Ref();
    BySmallestKey cmp;
    cmp.internal_comparator = &vset_->icmp_;
    for (int level = 0; level < config::kNumLevels; level++) {
      levels_[level].added_files = new FileSet(cmp);
    }
  }",632.0,641.0,3.0,3.0,10.0,12,7,10,7,0,4,2,2,0,0,,0,4,4,2,2,ANY
1706,50688,~Builder,1,leveldb.Builder.~Builder,ANY leveldb.Builder.~Builder (),db\version_set.cc,"~Builder() {
    for (int level = 0; level < config::kNumLevels; level++) {
      const FileSet* added = levels_[level].added_files;
      std::vector<FileMetaData*> to_unref;
      to_unref.reserve(added->size());
      for (FileSet::const_iterator it = added->begin();
          it != added->end(); ++it) {
        to_unref.push_back(*it);
      }
      delete added;
      for (uint32_t i = 0; i < to_unref.size(); i++) {
        FileMetaData* f = to_unref[i];
        f->refs--;
        if (f->refs <= 0) {
          delete f;
        }
      }
    }
    base_->Unref();
  }",643.0,662.0,3.0,3.0,20.0,26,10,25,9,0,4,5,9,1,0,,0,4,0,0,0,ANY
1707,50787,Apply,1,leveldb.Builder.Apply,void leveldb.Builder.Apply (VersionEdit*),db\version_set.cc,"void Apply(VersionEdit* edit) {
    // Update compaction pointers
    for (size_t i = 0; i < edit->compact_pointers_.size(); i++) {
      const int level = edit->compact_pointers_[i].first;
      vset_->compact_pointer_[level] =
          edit->compact_pointers_[i].second.Encode().ToString();
    }

    // Delete files
    const VersionEdit::DeletedFileSet& del = edit->deleted_files_;
    for (VersionEdit::DeletedFileSet::const_iterator iter = del.begin();
         iter != del.end();
         ++iter) {
      const int level = iter->first;
      const uint64_t number = iter->second;
      levels_[level].deleted_files.insert(number);
    }

    // Add new files
    for (size_t i = 0; i < edit->new_files_.size(); i++) {
      const int level = edit->new_files_[i].first;
      FileMetaData* f = new FileMetaData(edit->new_files_[i].second);
      f->refs = 1;

      // We arrange to automatically compact this file after
      // a certain number of seeks.  Let's assume:
      //   (1) On...",665.0,708.0,3.0,3.0,44.0,59,8,44,10,0,17,5,6,3,0,,0,17,2,1,1,void
1708,50968,SaveTo,1,leveldb.Builder.SaveTo,void leveldb.Builder.SaveTo (Version*),db\version_set.cc,"void SaveTo(Version* v) {
    BySmallestKey cmp;
    cmp.internal_comparator = &vset_->icmp_;
    for (int level = 0; level < config::kNumLevels; level++) {
      // Merge the set of added files with the set of pre-existing files.
      // Drop any deleted files.  Store the result in *v.
      const std::vector<FileMetaData*>& base_files = base_->files_[level];
      std::vector<FileMetaData*>::const_iterator base_iter = base_files.begin();
      std::vector<FileMetaData*>::const_iterator base_end = base_files.end();
      const FileSet* added = levels_[level].added_files;
      v->files_[level].reserve(base_files.size() + added->size());
      for (FileSet::const_iterator added_iter = added->begin();
           added_iter != added->end();
           ++added_iter) {
        // Add all smaller files listed in base_
        for (std::vector<FileMetaData*>::const_iterator bpos
                 = std::upper_bound(base_iter, base_end, *added_iter, cmp);
             base_iter != bpos;
  ...",711.0,757.0,3.0,3.0,47.0,59,12,61,18,0,9,8,18,2,0,,0,9,2,1,1,void
1709,51184,MaybeAddFile,1,leveldb.Builder.MaybeAddFile,"void leveldb.Builder.MaybeAddFile (Version*,int,FileMetaData*)",db\version_set.cc,"void MaybeAddFile(Version* v, int level, FileMetaData* f) {
    if (levels_[level].deleted_files.count(f->number) > 0) {
      // File is deleted: do nothing
    } else {
      std::vector<FileMetaData*>* files = &v->files_[level];
      if (level > 0 && !files->empty()) {
        // Must not overlap
        assert(vset_->icmp_.Compare((*files)[files->size()-1]->largest,
                                    f->smallest) < 0);
      }
      f->refs++;
      files->push_back(f);
    }
  }",759.0,772.0,3.0,3.0,14.0,5,4,3,3,0,2,2,2,2,0,,0,2,6,3,3,void
1710,51268,VersionSet,1,leveldb.VersionSet.VersionSet,"ANY leveldb.VersionSet.VersionSet (ANY,Options*,TableCache*,InternalKeyComparator*)",db\version_set.cc,"VersionSet::VersionSet(const std::string& dbname,
                       const Options* options,
                       TableCache* table_cache,
                       const InternalKeyComparator* cmp)
    : env_(options->env),
      dbname_(dbname),
      options_(options),
      table_cache_(table_cache),
      icmp_(*cmp),
      next_file_number_(2),
      manifest_file_number_(0),  // Filled by Recover()
      last_sequence_(0),
      log_number_(0),
      prev_log_number_(0),
      descriptor_file_(NULL),
      descriptor_log_(NULL),
      dummy_versions_(this),
      current_(NULL) {
  AppendVersion(new Version(this));
}",775.0,794.0,1.0,1.0,20.0,1,1,1,1,0,0,1,1,0,0,,0,0,8,4,4,ANY
1711,51280,~VersionSet,1,leveldb.VersionSet.~VersionSet,ANY leveldb.VersionSet.~VersionSet (),db\version_set.cc,"VersionSet::~VersionSet() {
  current_->Unref();
  assert(dummy_versions_.next_ == &dummy_versions_);  // List must be empty
  delete descriptor_log_;
  delete descriptor_file_;
}",796.0,801.0,1.0,1.0,6.0,6,5,5,4,0,5,1,1,0,0,,0,5,0,0,0,ANY
1712,51299,AppendVersion,1,leveldb.VersionSet.AppendVersion,void leveldb.VersionSet.AppendVersion (Version*),db\version_set.cc,"void VersionSet::AppendVersion(Version* v) {
  // Make ""v"" current
  assert(v->refs_ == 0);
  assert(v != current_);
  if (current_ != NULL) {
    current_->Unref();
  }
  current_ = v;
  v->Ref();

  // Append to linked list
  v->prev_ = dummy_versions_.prev_;
  v->next_ = &dummy_versions_;
  v->prev_->next_ = v;
  v->next_->prev_ = v;
}",803.0,818.0,1.0,1.0,16.0,19,6,17,4,0,11,2,2,1,0,,0,11,2,1,1,void
1713,51357,LogAndApply,1,leveldb.VersionSet.LogAndApply,"Status leveldb.VersionSet.LogAndApply (VersionEdit*,ANY*)",db\version_set.cc,"Status VersionSet::LogAndApply(VersionEdit* edit, port::Mutex* mu) {
  if (edit->has_log_number_) {
    assert(edit->log_number_ >= log_number_);
    assert(edit->log_number_ < next_file_number_);
  } else {
    edit->SetLogNumber(log_number_);
  }

  if (!edit->has_prev_log_number_) {
    edit->SetPrevLogNumber(prev_log_number_);
  }

  edit->SetNextFile(next_file_number_);
  edit->SetLastSequence(last_sequence_);

  Version* v = new Version(this);
  {
    Builder builder(this, current_);
    builder.Apply(edit);
    builder.SaveTo(v);
  }
  Finalize(v);

  // Initialize new descriptor log file if necessary by creating
  // a temporary file that contains a snapshot of the current version.
  std::string new_manifest_file;
  Status s;
  if (descriptor_log_ == NULL) {
    // No reason to unlock *mu here since we only hit this path in the
    // first call to LogAndApply (when opening the database).
    assert(descriptor_file_ == NULL);
    new_manifest_file = DescriptorFileName(dbname...",820.0,903.0,1.0,1.0,84.0,50,10,66,21,0,30,10,13,3,0,,0,30,4,2,2,Status
1714,51600,Recover,1,leveldb.VersionSet.Recover,Status leveldb.VersionSet.Recover (bool*),db\version_set.cc,"Status VersionSet::Recover(bool *save_manifest) {
  struct LogReporter : public log::Reader::Reporter {
    Status* status;
    virtual void Corruption(size_t bytes, const Status& s) {
      if (this->status->ok()) *this->status = s;
    }
  };

  // Read ""CURRENT"" file, which contains a pointer to the current manifest file
  std::string current;
  Status s = ReadFileToString(env_, CurrentFileName(dbname_), &current);
  if (!s.ok()) {
    return s;
  }
  if (current.empty() || current[current.size()-1] != '\n') {
    return Status::Corruption(""CURRENT file does not end with newline"");
  }
  current.resize(current.size() - 1);

  std::string dscname = dbname_ + ""/"" + current;
  SequentialFile* file;
  s = env_->NewSequentialFile(dscname, &file);
  if (!s.ok()) {
    return s;
  }

  bool have_log_number = false;
  bool have_prev_log_number = false;
  bool have_next_file = false;
  bool have_last_sequence = false;
  uint64_t next_file = 0;
  uint64_t last_sequence = 0;
  uint64_t log_...",905.0,1025.0,1.0,1.0,121.0,91,13,99,31,0,26,17,28,7,3,,0,25,2,1,1,Status
1715,51975,ReuseManifest,1,leveldb.VersionSet.ReuseManifest,"bool leveldb.VersionSet.ReuseManifest (ANY,ANY)",db\version_set.cc,"bool VersionSet::ReuseManifest(const std::string& dscname,
                               const std::string& dscbase) {
  if (!options_->reuse_logs) {
    return false;
  }
  FileType manifest_type;
  uint64_t manifest_number;
  uint64_t manifest_size;
  if (!ParseFileName(dscbase, &manifest_number, &manifest_type) ||
      manifest_type != kDescriptorFile ||
      !env_->GetFileSize(dscname, &manifest_size).ok() ||
      // Make new compacted MANIFEST if old one is too big
      manifest_size >= TargetFileSize(options_)) {
    return false;
  }

  assert(descriptor_file_ == NULL);
  assert(descriptor_log_ == NULL);
  Status r = env_->NewAppendableFile(dscname, &descriptor_file_);
  if (!r.ok()) {
    Log(options_->info_log, ""Reuse MANIFEST: %s\n"", r.ToString().c_str());
    assert(descriptor_file_ == NULL);
    return false;
  }

  Log(options_->info_log, ""Reusing MANIFEST %s\n"", dscname.c_str());
  descriptor_log_ = new log::Writer(descriptor_file_, manifest_size);
  manifest_file...",1027.0,1056.0,1.0,1.0,30.0,30,10,32,14,0,13,4,4,3,0,,0,13,4,2,2,bool
1716,52087,MarkFileNumberUsed,1,leveldb.VersionSet.MarkFileNumberUsed,void leveldb.VersionSet.MarkFileNumberUsed (uint64_t),db\version_set.cc,"void VersionSet::MarkFileNumberUsed(uint64_t number) {
  if (next_file_number_ <= number) {
    next_file_number_ = number + 1;
  }
}",1058.0,1062.0,1.0,1.0,5.0,3,3,4,2,0,2,2,2,1,0,,0,2,2,1,1,void
1717,52102,Finalize,1,leveldb.VersionSet.Finalize,void leveldb.VersionSet.Finalize (Version*),db\version_set.cc,"void VersionSet::Finalize(Version* v) {
  // Precomputed best level for next compaction
  int best_level = -1;
  double best_score = -1;

  for (int level = 0; level < config::kNumLevels-1; level++) {
    double score;
    if (level == 0) {
      // We treat level-0 specially by bounding the number of files
      // instead of number of bytes for two reasons:
      //
      // (1) With larger write-buffer sizes, it is nice not to do too
      // many level-0 compactions.
      //
      // (2) The files in level-0 are merged on every read and
      // therefore we wish to avoid too many files when the individual
      // file size is small (perhaps because of a small write-buffer
      // setting, or very high compression ratios, or lots of
      // overwrites/deletions).
      score = v->files_[level].size() /
          static_cast<double>(config::kL0_CompactionTrigger);
    } else {
      // Compute the ratio of current size to size limit.
      const uint64_t level_bytes = TotalFi...",1064.0,1100.0,1.0,1.0,37.0,23,11,20,6,0,3,4,6,0,0,,0,3,2,1,1,void
1718,52196,WriteSnapshot,1,leveldb.VersionSet.WriteSnapshot,Status leveldb.VersionSet.WriteSnapshot (ANY*),db\version_set.cc,"Status VersionSet::WriteSnapshot(log::Writer* log) {
  // TODO: Break up into multiple records to reduce memory usage on recovery?

  // Save metadata
  VersionEdit edit;
  edit.SetComparatorName(icmp_.user_comparator()->Name());

  // Save compaction pointers
  for (int level = 0; level < config::kNumLevels; level++) {
    if (!compact_pointer_[level].empty()) {
      InternalKey key;
      key.DecodeFrom(compact_pointer_[level]);
      edit.SetCompactPointer(level, key);
    }
  }

  // Save files
  for (int level = 0; level < config::kNumLevels; level++) {
    const std::vector<FileMetaData*>& files = current_->files_[level];
    for (size_t i = 0; i < files.size(); i++) {
      const FileMetaData* f = files[i];
      edit.AddFile(level, f->number, f->file_size, f->smallest, f->largest);
    }
  }

  std::string record;
  edit.EncodeTo(&record);
  return log->AddRecord(record);
}",1102.0,1130.0,1.0,1.0,29.0,31,7,35,12,0,8,5,7,1,0,,0,8,2,1,1,Status
1719,52323,NumLevelFiles,1,leveldb.VersionSet.NumLevelFiles,int leveldb.VersionSet.NumLevelFiles (int),db\version_set.cc,"int VersionSet::NumLevelFiles(int level) const {
  assert(level >= 0);
  assert(level < config::kNumLevels);
  return current_->files_[level].size();
}",1132.0,1136.0,1.0,1.0,5.0,6,5,5,3,0,1,1,1,0,0,,0,1,2,1,1,int
1720,52347,LevelSummary,1,leveldb.VersionSet.LevelSummary,const char* leveldb.VersionSet.LevelSummary (LevelSummaryStorage*),db\version_set.cc,"const char* VersionSet::LevelSummary(LevelSummaryStorage* scratch) const {
  // Update code if kNumLevels changes
  assert(config::kNumLevels == 7);
  snprintf(scratch->buffer, sizeof(scratch->buffer),
           ""files[ %d %d %d %d %d %d %d ]"",
           int(current_->files_[0].size()),
           int(current_->files_[1].size()),
           int(current_->files_[2].size()),
           int(current_->files_[3].size()),
           int(current_->files_[4].size()),
           int(current_->files_[5].size()),
           int(current_->files_[6].size()));
  return scratch->buffer;
}",1138.0,1151.0,1.0,1.0,14.0,34,6,11,3,0,10,1,1,0,0,,0,10,2,1,1,const char*
1721,52441,ApproximateOffsetOf,1,leveldb.VersionSet.ApproximateOffsetOf,"uint64_t leveldb.VersionSet.ApproximateOffsetOf (Version*,InternalKey)",db\version_set.cc,"uint64_t VersionSet::ApproximateOffsetOf(Version* v, const InternalKey& ikey) {
  uint64_t result = 0;
  for (int level = 0; level < config::kNumLevels; level++) {
    const std::vector<FileMetaData*>& files = v->files_[level];
    for (size_t i = 0; i < files.size(); i++) {
      if (icmp_.Compare(files[i]->largest, ikey) <= 0) {
        // Entire file is before ""ikey"", so just add the file size
        result += files[i]->file_size;
      } else if (icmp_.Compare(files[i]->smallest, ikey) > 0) {
        // Entire file is after ""ikey"", so ignore
        if (level > 0) {
          // Files other than level 0 are sorted by meta->smallest, so
          // no further files in this level will contain data for
          // ""ikey"".
          break;
        }
      } else {
        // ""ikey"" falls in the range for this table.  Add the
        // approximate offset of ""ikey"" within the table.
        Table* tableptr;
        Iterator* iter = table_cache_->NewIterator(
            ReadOption...",1153.0,1183.0,1.0,1.0,31.0,17,7,18,8,0,2,4,7,1,0,,0,2,4,2,2,uint64_t
1722,52573,AddLiveFiles,1,leveldb.VersionSet.AddLiveFiles,void leveldb.VersionSet.AddLiveFiles (ANY*),db\version_set.cc,"void VersionSet::AddLiveFiles(std::set<uint64_t>* live) {
  for (Version* v = dummy_versions_.next_;
       v != &dummy_versions_;
       v = v->next_) {
    for (int level = 0; level < config::kNumLevels; level++) {
      const std::vector<FileMetaData*>& files = v->files_[level];
      for (size_t i = 0; i < files.size(); i++) {
        live->insert(files[i]->number);
      }
    }
  }
}",1185.0,1196.0,1.0,1.0,12.0,16,7,16,7,0,2,4,7,1,0,,0,2,2,1,1,void
1723,52642,NumLevelBytes,1,leveldb.VersionSet.NumLevelBytes,int64_t leveldb.VersionSet.NumLevelBytes (int),db\version_set.cc,"int64_t VersionSet::NumLevelBytes(int level) const {
  assert(level >= 0);
  assert(level < config::kNumLevels);
  return TotalFileSize(current_->files_[level]);
}",1198.0,1202.0,1.0,1.0,5.0,5,5,5,3,0,1,1,1,0,0,,0,1,2,1,1,int64_t
1724,52664,MaxNextLevelOverlappingBytes,1,leveldb.VersionSet.MaxNextLevelOverlappingBytes,int64_t leveldb.VersionSet.MaxNextLevelOverlappingBytes (),db\version_set.cc,"int64_t VersionSet::MaxNextLevelOverlappingBytes() {
  int64_t result = 0;
  std::vector<FileMetaData*> overlaps;
  for (int level = 1; level < config::kNumLevels - 1; level++) {
    for (size_t i = 0; i < current_->files_[level].size(); i++) {
      const FileMetaData* f = current_->files_[level][i];
      current_->GetOverlappingInputs(level+1, &f->smallest, &f->largest,
                                     &overlaps);
      const int64_t sum = TotalFileSize(overlaps);
      if (sum > result) {
        result = sum;
      }
    }
  }
  return result;
}",1204.0,1219.0,1.0,1.0,16.0,24,9,24,8,0,5,4,7,1,0,,0,5,0,0,0,int64_t
1725,52750,GetRange,1,leveldb.VersionSet.GetRange,"void leveldb.VersionSet.GetRange (ANY,InternalKey*,InternalKey*)",db\version_set.cc,"void VersionSet::GetRange(const std::vector<FileMetaData*>& inputs,
                          InternalKey* smallest,
                          InternalKey* largest) {
  assert(!inputs.empty());
  smallest->Clear();
  largest->Clear();
  for (size_t i = 0; i < inputs.size(); i++) {
    FileMetaData* f = inputs[i];
    if (i == 0) {
      *smallest = f->smallest;
      *largest = f->largest;
    } else {
      if (icmp_.Compare(f->smallest, *smallest) < 0) {
        *smallest = f->smallest;
      }
      if (icmp_.Compare(f->largest, *largest) > 0) {
        *largest = f->largest;
      }
    }
  }
}",1224.0,1244.0,1.0,1.0,21.0,16,8,14,5,0,2,3,4,0,0,,0,2,6,3,3,void
1726,52849,GetRange2,1,leveldb.VersionSet.GetRange2,"void leveldb.VersionSet.GetRange2 (ANY,ANY,InternalKey*,InternalKey*)",db\version_set.cc,"void VersionSet::GetRange2(const std::vector<FileMetaData*>& inputs1,
                           const std::vector<FileMetaData*>& inputs2,
                           InternalKey* smallest,
                           InternalKey* largest) {
  std::vector<FileMetaData*> all = inputs1;
  all.insert(all.end(), inputs2.begin(), inputs2.end());
  GetRange(all, smallest, largest);
}",1249.0,1256.0,1.0,1.0,8.0,5,2,9,5,0,0,1,1,0,0,,0,0,8,4,4,void
1727,52881,MakeInputIterator,1,leveldb.VersionSet.MakeInputIterator,Iterator leveldb.VersionSet.MakeInputIterator (Compaction*),db\version_set.cc,"Iterator* VersionSet::MakeInputIterator(Compaction* c) {
  ReadOptions options;
  options.verify_checksums = options_->paranoid_checks;
  options.fill_cache = false;

  // Level-0 files have to be merged together.  For other levels,
  // we will make a concatenating iterator per level.
  // TODO(opt): use concatenating iterator for level-0 if there is no overlap
  const int space = (c->level() == 0 ? c->inputs_[0].size() + 1 : 2);
  Iterator** list = new Iterator*[space];
  int num = 0;
  for (int which = 0; which < 2; which++) {
    if (!c->inputs_[which].empty()) {
      if (c->level() + which == 0) {
        const std::vector<FileMetaData*>& files = c->inputs_[which];
        for (size_t i = 0; i < files.size(); i++) {
          list[num++] = table_cache_->NewIterator(
              options, files[i]->number, files[i]->file_size);
        }
      } else {
        // Create concatenating iterator for the files from this level
        list[num++] = NewTwoLevelIterator(
            ...",1258.0,1289.0,1.0,1.0,32.0,43,14,37,13,0,8,5,11,1,0,,0,8,2,1,1,Iterator
1728,53042,PickCompaction,1,leveldb.VersionSet.PickCompaction,Compaction leveldb.VersionSet.PickCompaction (),db\version_set.cc,"Compaction* VersionSet::PickCompaction() {
  Compaction* c;
  int level;

  // We prefer compactions triggered by too much data in a level over
  // the compactions triggered by seeks.
  const bool size_compaction = (current_->compaction_score_ >= 1);
  const bool seek_compaction = (current_->file_to_compact_ != NULL);
  if (size_compaction) {
    level = current_->compaction_level_;
    assert(level >= 0);
    assert(level+1 < config::kNumLevels);
    c = new Compaction(options_, level);

    // Pick the first file that comes after compact_pointer_[level]
    for (size_t i = 0; i < current_->files_[level].size(); i++) {
      FileMetaData* f = current_->files_[level][i];
      if (compact_pointer_[level].empty() ||
          icmp_.Compare(f->largest.Encode(), compact_pointer_[level]) > 0) {
        c->inputs_[0].push_back(f);
        break;
      }
    }
    if (c->inputs_[0].empty()) {
      // Wrap-around to the beginning of the key space
      c->inputs_[0].push_back(current_->f...",1291.0,1343.0,1.0,1.0,53.0,62,14,49,15,0,21,7,10,6,0,,0,21,0,0,0,Compaction
1729,53266,SetupOtherInputs,1,leveldb.VersionSet.SetupOtherInputs,void leveldb.VersionSet.SetupOtherInputs (Compaction*),db\version_set.cc,"void VersionSet::SetupOtherInputs(Compaction* c) {
  const int level = c->level();
  InternalKey smallest, largest;
  GetRange(c->inputs_[0], &smallest, &largest);

  current_->GetOverlappingInputs(level+1, &smallest, &largest, &c->inputs_[1]);

  // Get entire range covered by compaction
  InternalKey all_start, all_limit;
  GetRange2(c->inputs_[0], c->inputs_[1], &all_start, &all_limit);

  // See if we can grow the number of inputs in ""level"" without
  // changing the number of ""level+1"" files we pick up.
  if (!c->inputs_[1].empty()) {
    std::vector<FileMetaData*> expanded0;
    current_->GetOverlappingInputs(level, &all_start, &all_limit, &expanded0);
    const int64_t inputs0_size = TotalFileSize(c->inputs_[0]);
    const int64_t inputs1_size = TotalFileSize(c->inputs_[1]);
    const int64_t expanded0_size = TotalFileSize(expanded0);
    if (expanded0.size() > c->inputs_[0].size() &&
        inputs1_size + expanded0_size <
            ExpandedCompactionByteSizeLimit(options_...",1345.0,1411.0,1.0,1.0,67.0,105,12,80,17,0,25,6,9,4,0,,0,25,2,1,1,void
1730,53580,CompactRange,1,leveldb.VersionSet.CompactRange,"Compaction leveldb.VersionSet.CompactRange (int,InternalKey*,InternalKey*)",db\version_set.cc,"Compaction* VersionSet::CompactRange(
    int level,
    const InternalKey* begin,
    const InternalKey* end) {
  std::vector<FileMetaData*> inputs;
  current_->GetOverlappingInputs(level, begin, end, &inputs);
  if (inputs.empty()) {
    return NULL;
  }

  // Avoid compacting too much in one shot in case the range is large.
  // But we cannot do this for level-0 since level-0 files can overlap
  // and we must not pick one file and drop another older file if the
  // two files overlap.
  if (level > 0) {
    const uint64_t limit = MaxFileSizeForLevel(options_, level);
    uint64_t total = 0;
    for (size_t i = 0; i < inputs.size(); i++) {
      uint64_t s = inputs[i]->file_size;
      total += s;
      if (total >= limit) {
        inputs.resize(i + 1);
        break;
      }
    }
  }

  Compaction* c = new Compaction(options_, level);
  c->input_version_ = current_;
  c->input_version_->Ref();
  c->inputs_[0] = inputs;
  SetupOtherInputs(c);
  return c;
}",1413.0,1446.0,1.0,1.0,34.0,25,11,35,13,0,7,6,8,0,0,,0,7,6,3,3,Compaction
1731,53688,Compaction,1,leveldb.Compaction.Compaction,"ANY leveldb.Compaction.Compaction (Options*,int)",db\version_set.cc,"Compaction::Compaction(const Options* options, int level)
    : level_(level),
      max_output_file_size_(MaxFileSizeForLevel(options, level)),
      input_version_(NULL),
      grandparent_index_(0),
      seen_key_(false),
      overlapped_bytes_(0) {
  for (int i = 0; i < config::kNumLevels; i++) {
    level_ptrs_[i] = 0;
  }
}",1448.0,1458.0,1.0,1.0,11.0,5,4,5,3,0,1,2,2,0,0,,0,1,4,2,2,ANY
1732,53713,~Compaction,1,leveldb.Compaction.~Compaction,ANY leveldb.Compaction.~Compaction (),db\version_set.cc,"Compaction::~Compaction() {
  if (input_version_ != NULL) {
    input_version_->Unref();
  }
}",1460.0,1464.0,1.0,1.0,5.0,2,2,3,2,0,2,2,2,1,0,,0,2,0,0,0,ANY
1733,53726,IsTrivialMove,1,leveldb.Compaction.IsTrivialMove,bool leveldb.Compaction.IsTrivialMove (),db\version_set.cc,"bool Compaction::IsTrivialMove() const {
  const VersionSet* vset = input_version_->vset_;
  // Avoid a move if there is lots of overlapping grandparent data.
  // Otherwise, the move could create a parent file that will require
  // a very expensive merge later on.
  return (num_input_files(0) == 1 && num_input_files(1) == 0 &&
          TotalFileSize(grandparents_) <=
              MaxGrandParentOverlapBytes(vset->options_));
}",1466.0,1474.0,1.0,1.0,9.0,8,5,4,3,0,3,1,1,0,0,,0,3,0,0,0,bool
1734,53754,AddInputDeletions,1,leveldb.Compaction.AddInputDeletions,void leveldb.Compaction.AddInputDeletions (VersionEdit*),db\version_set.cc,"void Compaction::AddInputDeletions(VersionEdit* edit) {
  for (int which = 0; which < 2; which++) {
    for (size_t i = 0; i < inputs_[which].size(); i++) {
      edit->DeleteFile(level_ + which, inputs_[which][i]->number);
    }
  }
}",1476.0,1482.0,1.0,1.0,7.0,11,6,12,5,0,3,3,4,1,0,,0,3,2,1,1,void
1735,53802,IsBaseLevelForKey,1,leveldb.Compaction.IsBaseLevelForKey,bool leveldb.Compaction.IsBaseLevelForKey (Slice),db\version_set.cc,"bool Compaction::IsBaseLevelForKey(const Slice& user_key) {
  // Maybe use binary search to find right entry instead of linear search?
  const Comparator* user_cmp = input_version_->vset_->icmp_.user_comparator();
  for (int lvl = level_ + 2; lvl < config::kNumLevels; lvl++) {
    const std::vector<FileMetaData*>& files = input_version_->files_[lvl];
    for (; level_ptrs_[lvl] < files.size(); ) {
      FileMetaData* f = files[level_ptrs_[lvl]];
      if (user_cmp->Compare(user_key, f->largest.user_key()) <= 0) {
        // We've advanced far enough
        if (user_cmp->Compare(user_key, f->smallest.user_key()) >= 0) {
          // Key falls in this file's range, so definitely not base level
          return false;
        }
        break;
      }
      level_ptrs_[lvl]++;
    }
  }
  return true;
}",1484.0,1503.0,1.0,1.0,20.0,27,9,24,9,0,8,6,11,3,0,,0,8,2,1,1,bool
1736,53900,ShouldStopBefore,1,leveldb.Compaction.ShouldStopBefore,bool leveldb.Compaction.ShouldStopBefore (Slice),db\version_set.cc,"bool Compaction::ShouldStopBefore(const Slice& internal_key) {
  const VersionSet* vset = input_version_->vset_;
  // Scan to find earliest grandparent file that contains key.
  const InternalKeyComparator* icmp = &vset->icmp_;
  while (grandparent_index_ < grandparents_.size() &&
      icmp->Compare(internal_key,
                    grandparents_[grandparent_index_]->largest.Encode()) > 0) {
    if (seen_key_) {
      overlapped_bytes_ += grandparents_[grandparent_index_]->file_size;
    }
    grandparent_index_++;
  }
  seen_key_ = true;

  if (overlapped_bytes_ > MaxGrandParentOverlapBytes(vset->options_)) {
    // Too much overlap for current output; start new output
    overlapped_bytes_ = 0;
    return true;
  } else {
    return false;
  }
}",1505.0,1526.0,1.0,1.0,22.0,21,10,19,8,0,15,4,5,7,0,,0,15,2,1,1,bool
1737,53974,ReleaseInputs,1,leveldb.Compaction.ReleaseInputs,void leveldb.Compaction.ReleaseInputs (),db\version_set.cc,"void Compaction::ReleaseInputs() {
  if (input_version_ != NULL) {
    input_version_->Unref();
    input_version_ = NULL;
  }
}",1528.0,1533.0,1.0,1.0,6.0,3,3,5,2,0,3,2,2,1,0,,0,3,0,0,0,void
1738,54093,NumFiles,1,leveldb.Version.NumFiles,int leveldb.Version.NumFiles (int),db\version_set.hpp,int NumFiles(int level) const { return files_[level].size(); },111.0,111.0,3.0,64.0,1.0,2,2,2,2,0,1,1,1,0,0,,0,1,2,1,1,int
1739,54135,Version,1,leveldb.Version.Version,ANY leveldb.Version.Version (VersionSet*),db\version_set.hpp,"explicit Version(VersionSet* vset)
      : vset_(vset), next_(this), prev_(this), refs_(0),
        file_to_compact_(NULL),
        file_to_compact_level_(-1),
        compaction_score_(-1),
        compaction_level_(-1) {
  }",150.0,156.0,3.0,3.0,7.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
1740,54149,operator =,1,leveldb.Version.operator =,void leveldb.Version.operator = (Version),db\version_set.hpp,void operator=(const Version&);,162.0,162.0,8.0,32.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
1741,54186,current,1,leveldb.VersionSet.current,Version leveldb.VersionSet.current (),db\version_set.hpp,Version* current() const { return current_; },185.0,185.0,3.0,47.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,Version
1742,54192,ManifestFileNumber,1,leveldb.VersionSet.ManifestFileNumber,uint64_t leveldb.VersionSet.ManifestFileNumber (),db\version_set.hpp,uint64_t ManifestFileNumber() const { return manifest_file_number_; },188.0,188.0,3.0,71.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,uint64_t
1743,54198,NewFileNumber,1,leveldb.VersionSet.NewFileNumber,uint64_t leveldb.VersionSet.NewFileNumber (),db\version_set.hpp,uint64_t NewFileNumber() { return next_file_number_++; },191.0,191.0,3.0,58.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,uint64_t
1744,54205,ReuseFileNumber,1,leveldb.VersionSet.ReuseFileNumber,void leveldb.VersionSet.ReuseFileNumber (uint64_t),db\version_set.hpp,"void ReuseFileNumber(uint64_t file_number) {
    if (next_file_number_ == file_number + 1) {
      next_file_number_ = file_number;
    }
  }",196.0,200.0,3.0,3.0,5.0,3,3,4,2,0,2,2,2,1,0,,0,2,2,1,1,void
1745,54230,LastSequence,1,leveldb.VersionSet.LastSequence,uint64_t leveldb.VersionSet.LastSequence (),db\version_set.hpp,uint64_t LastSequence() const { return last_sequence_; },209.0,209.0,3.0,58.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,uint64_t
1746,54236,SetLastSequence,1,leveldb.VersionSet.SetLastSequence,void leveldb.VersionSet.SetLastSequence (uint64_t),db\version_set.hpp,"void SetLastSequence(uint64_t s) {
    assert(s >= last_sequence_);
    last_sequence_ = s;
  }",212.0,215.0,3.0,3.0,4.0,2,2,4,2,0,2,1,1,0,0,,0,2,2,1,1,void
1747,54253,LogNumber,1,leveldb.VersionSet.LogNumber,uint64_t leveldb.VersionSet.LogNumber (),db\version_set.hpp,uint64_t LogNumber() const { return log_number_; },221.0,221.0,3.0,52.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,uint64_t
1748,54259,PrevLogNumber,1,leveldb.VersionSet.PrevLogNumber,uint64_t leveldb.VersionSet.PrevLogNumber (),db\version_set.hpp,uint64_t PrevLogNumber() const { return prev_log_number_; },225.0,225.0,3.0,61.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,uint64_t
1749,54285,NeedsCompaction,1,leveldb.VersionSet.NeedsCompaction,bool leveldb.VersionSet.NeedsCompaction (),db\version_set.hpp,"bool NeedsCompaction() const {
    Version* v = current_;
    return (v->compaction_score_ >= 1) || (v->file_to_compact_ != NULL);
  }",251.0,254.0,3.0,3.0,4.0,6,5,5,3,0,3,1,1,0,0,,0,3,0,0,0,bool
1750,54393,operator =,1,leveldb.VersionSet.operator =,void leveldb.VersionSet.operator = (VersionSet),db\version_set.hpp,void operator=(const VersionSet&);,320.0,320.0,8.0,35.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
1751,54411,level,1,leveldb.Compaction.level,int leveldb.Compaction.level (),db\version_set.hpp,int level() const { return level_; },330.0,330.0,3.0,38.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,int
1752,54417,edit,1,leveldb.Compaction.edit,VersionEdit leveldb.Compaction.edit (),db\version_set.hpp,VersionEdit* edit() { return &edit_; },334.0,334.0,3.0,40.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,VersionEdit
1753,54424,num_input_files,1,leveldb.Compaction.num_input_files,int leveldb.Compaction.num_input_files (int),db\version_set.hpp,int num_input_files(int which) const { return inputs_[which].size(); },337.0,337.0,3.0,72.0,1.0,2,2,2,2,0,1,1,1,0,0,,0,1,2,1,1,int
1754,54436,input,1,leveldb.Compaction.input,"FileMetaData leveldb.Compaction.input (int,int)",db\version_set.hpp,"FileMetaData* input(int which, int i) const { return inputs_[which][i]; }",340.0,340.0,3.0,75.0,1.0,2,1,3,3,0,1,1,1,0,0,,0,1,4,2,2,FileMetaData
1755,54448,MaxOutputFileSize,1,leveldb.Compaction.MaxOutputFileSize,uint64_t leveldb.Compaction.MaxOutputFileSize (),db\version_set.hpp,uint64_t MaxOutputFileSize() const { return max_output_file_size_; },343.0,343.0,3.0,70.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,uint64_t
1756,54522,FindFileTest,1,leveldb.FindFileTest.FindFileTest,ANY leveldb.FindFileTest.FindFileTest (),db\version_set_test.cc,FindFileTest() : disjoint_sorted_files_(true) { },17.0,17.0,3.0,51.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
1757,54526,~FindFileTest,1,leveldb.FindFileTest.~FindFileTest,ANY leveldb.FindFileTest.~FindFileTest (),db\version_set_test.cc,"~FindFileTest() {
    for (int i = 0; i < files_.size(); i++) {
      delete files_[i];
    }
  }",19.0,23.0,3.0,3.0,5.0,5,5,5,2,0,2,2,2,1,0,,0,2,0,0,0,ANY
1758,54549,Add,1,leveldb.FindFileTest.Add,"void leveldb.FindFileTest.Add (char*,char*,SequenceNumber,SequenceNumber)",db\version_set_test.cc,"void Add(const char* smallest, const char* largest,
           SequenceNumber smallest_seq = 100,
           SequenceNumber largest_seq = 100) {
    FileMetaData* f = new FileMetaData;
    f->number = files_.size() + 1;
    f->smallest = InternalKey(smallest, smallest_seq, kTypeValue);
    f->largest = InternalKey(largest, largest_seq, kTypeValue);
    files_.push_back(f);
  }",25.0,33.0,3.0,3.0,9.0,11,5,14,8,0,5,1,1,0,0,,0,5,8,4,4,void
1759,54593,Find,1,leveldb.FindFileTest.Find,int leveldb.FindFileTest.Find (char*),db\version_set_test.cc,"int Find(const char* key) {
    InternalKey target(key, 100, kTypeValue);
    InternalKeyComparator cmp(BytewiseComparator());
    return FindFile(cmp, files_, target.Encode());
  }",35.0,39.0,3.0,3.0,5.0,1,1,5,5,0,1,1,1,0,0,,0,1,2,1,1,int
1760,54614,Overlaps,1,leveldb.FindFileTest.Overlaps,"bool leveldb.FindFileTest.Overlaps (char*,char*)",db\version_set_test.cc,"bool Overlaps(const char* smallest, const char* largest) {
    InternalKeyComparator cmp(BytewiseComparator());
    Slice s(smallest != NULL ? smallest : """");
    Slice l(largest != NULL ? largest : """");
    return SomeFileOverlapsRange(cmp, disjoint_sorted_files_, files_,
                                 (smallest != NULL ? &s : NULL),
                                 (largest != NULL ? &l : NULL));
  }",41.0,48.0,3.0,3.0,8.0,10,3,17,8,0,2,1,1,0,0,,0,2,4,2,2,bool
1761,54783,_Run,1,leveldb._Test_Single._Run,void leveldb._Test_Single._Run (),db\version_set_test.cc,"TEST(FindFileTest, Single) {
  Add(""p"", ""q"");
  ASSERT_EQ(0, Find(""a""));
  ASSERT_EQ(0, Find(""p""));
  ASSERT_EQ(0, Find(""p1""));
  ASSERT_EQ(0, Find(""q""));
  ASSERT_EQ(1, Find(""q1""));
  ASSERT_EQ(1, Find(""z""));

  ASSERT_TRUE(! Overlaps(""a"", ""b""));
  ASSERT_TRUE(! Overlaps(""z1"", ""z2""));
  ASSERT_TRUE(Overlaps(""a"", ""p""));
  ASSERT_TRUE(Overlaps(""a"", ""q""));
  ASSERT_TRUE(Overlaps(""a"", ""z""));
  ASSERT_TRUE(Overlaps(""p"", ""p1""));
  ASSERT_TRUE(Overlaps(""p"", ""q""));
  ASSERT_TRUE(Overlaps(""p"", ""z""));
  ASSERT_TRUE(Overlaps(""p1"", ""p2""));
  ASSERT_TRUE(Overlaps(""p1"", ""z""));
  ASSERT_TRUE(Overlaps(""q"", ""q""));
  ASSERT_TRUE(Overlaps(""q"", ""q1""));

  ASSERT_TRUE(! Overlaps(NULL, ""j""));
  ASSERT_TRUE(! Overlaps(""r"", NULL));
  ASSERT_TRUE(Overlaps(NULL, ""p""));
  ASSERT_TRUE(Overlaps(NULL, ""p1""));
  ASSERT_TRUE(Overlaps(""q"", NULL));
  ASSERT_TRUE(Overlaps(NULL, NULL));
}",59.0,87.0,1.0,26.0,29.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1762,54787,_RunIt,1,leveldb._Test_Single._RunIt,void leveldb._Test_Single._RunIt (),db\version_set_test.cc,"TEST(FindFileTest, Single)",59.0,59.0,1.0,26.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1763,55243,_Run,1,leveldb._Test_Multiple._Run,void leveldb._Test_Multiple._Run (),db\write_batch_test.cc,"TEST(WriteBatchTest, Multiple) {
  WriteBatch batch;
  batch.Put(Slice(""foo""), Slice(""bar""));
  batch.Delete(Slice(""box""));
  batch.Put(Slice(""baz""), Slice(""boo""));
  WriteBatchInternal::SetSequence(&batch, 100);
  ASSERT_EQ(100, WriteBatchInternal::Sequence(&batch));
  ASSERT_EQ(3, WriteBatchInternal::Count(&batch));
  ASSERT_EQ(""Put(baz, boo)@102""
            ""Delete(box)@101""
            ""Put(foo, bar)@100"",
            PrintContents(&batch));
}",63.0,75.0,1.0,30.0,13.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1764,55247,_RunIt,1,leveldb._Test_Multiple._RunIt,void leveldb._Test_Multiple._RunIt (),db\version_set_test.cc,"TEST(FindFileTest, Multiple)",90.0,90.0,1.0,28.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1765,55819,_Run,1,leveldb._Test_MultipleNullBoundaries._Run,void leveldb._Test_MultipleNullBoundaries._Run (),db\version_set_test.cc,"TEST(FindFileTest, MultipleNullBoundaries) {
  Add(""150"", ""200"");
  Add(""200"", ""250"");
  Add(""300"", ""350"");
  Add(""400"", ""450"");
  ASSERT_TRUE(! Overlaps(NULL, ""149""));
  ASSERT_TRUE(! Overlaps(""451"", NULL));
  ASSERT_TRUE(Overlaps(NULL, NULL));
  ASSERT_TRUE(Overlaps(NULL, ""150""));
  ASSERT_TRUE(Overlaps(NULL, ""199""));
  ASSERT_TRUE(Overlaps(NULL, ""200""));
  ASSERT_TRUE(Overlaps(NULL, ""201""));
  ASSERT_TRUE(Overlaps(NULL, ""400""));
  ASSERT_TRUE(Overlaps(NULL, ""800""));
  ASSERT_TRUE(Overlaps(""100"", NULL));
  ASSERT_TRUE(Overlaps(""200"", NULL));
  ASSERT_TRUE(Overlaps(""449"", NULL));
  ASSERT_TRUE(Overlaps(""450"", NULL));
}",128.0,146.0,1.0,42.0,19.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1766,55823,_RunIt,1,leveldb._Test_MultipleNullBoundaries._RunIt,void leveldb._Test_MultipleNullBoundaries._RunIt (),db\version_set_test.cc,"TEST(FindFileTest, MultipleNullBoundaries)",128.0,128.0,1.0,42.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1767,56087,_Run,1,leveldb._Test_OverlapSequenceChecks._Run,void leveldb._Test_OverlapSequenceChecks._Run (),db\version_set_test.cc,"TEST(FindFileTest, OverlapSequenceChecks) {
  Add(""200"", ""200"", 5000, 3000);
  ASSERT_TRUE(! Overlaps(""199"", ""199""));
  ASSERT_TRUE(! Overlaps(""201"", ""300""));
  ASSERT_TRUE(Overlaps(""200"", ""200""));
  ASSERT_TRUE(Overlaps(""190"", ""200""));
  ASSERT_TRUE(Overlaps(""200"", ""210""));
}",148.0,155.0,1.0,41.0,8.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1768,56091,_RunIt,1,leveldb._Test_OverlapSequenceChecks._RunIt,void leveldb._Test_OverlapSequenceChecks._RunIt (),db\version_set_test.cc,"TEST(FindFileTest, OverlapSequenceChecks)",148.0,148.0,1.0,41.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1769,56212,_Run,1,leveldb._Test_OverlappingFiles._Run,void leveldb._Test_OverlappingFiles._Run (),db\version_set_test.cc,"TEST(FindFileTest, OverlappingFiles) {
  Add(""150"", ""600"");
  Add(""400"", ""500"");
  disjoint_sorted_files_ = false;
  ASSERT_TRUE(! Overlaps(""100"", ""149""));
  ASSERT_TRUE(! Overlaps(""601"", ""700""));
  ASSERT_TRUE(Overlaps(""100"", ""150""));
  ASSERT_TRUE(Overlaps(""100"", ""200""));
  ASSERT_TRUE(Overlaps(""100"", ""300""));
  ASSERT_TRUE(Overlaps(""100"", ""400""));
  ASSERT_TRUE(Overlaps(""100"", ""500""));
  ASSERT_TRUE(Overlaps(""375"", ""400""));
  ASSERT_TRUE(Overlaps(""450"", ""450""));
  ASSERT_TRUE(Overlaps(""450"", ""500""));
  ASSERT_TRUE(Overlaps(""450"", ""700""));
  ASSERT_TRUE(Overlaps(""600"", ""700""));
}",157.0,173.0,1.0,36.0,17.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1770,56216,_RunIt,1,leveldb._Test_OverlappingFiles._RunIt,void leveldb._Test_OverlappingFiles._RunIt (),db\version_set_test.cc,"TEST(FindFileTest, OverlappingFiles)",157.0,157.0,1.0,36.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1771,56494,WriteBatch,1,leveldb.WriteBatch.WriteBatch,ANY leveldb.WriteBatch.WriteBatch (),db\write_batch.cc,"WriteBatch::WriteBatch() {
  Clear();
}",29.0,31.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
1772,56499,~WriteBatch,1,leveldb.WriteBatch.~WriteBatch,ANY leveldb.WriteBatch.~WriteBatch (),db\write_batch.cc,WriteBatch::~WriteBatch() { },33.0,33.0,1.0,29.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
1773,56503,~Handler,1,leveldb.WriteBatch.Handler.~Handler,ANY leveldb.WriteBatch.Handler.~Handler (),db\write_batch.cc,WriteBatch::Handler::~Handler() { },35.0,35.0,1.0,35.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
1774,56507,Clear,1,leveldb.WriteBatch.Clear,void leveldb.WriteBatch.Clear (),db\write_batch.cc,"void WriteBatch::Clear() {
  rep_.clear();
  rep_.resize(kHeader);
}",37.0,40.0,1.0,1.0,4.0,2,1,3,2,0,2,1,1,0,0,,0,2,0,0,0,void
1775,56520,Iterate,1,leveldb.WriteBatch.Iterate,Status leveldb.WriteBatch.Iterate (Handler*),db\write_batch.cc,"Status WriteBatch::Iterate(Handler* handler) const {
  Slice input(rep_);
  if (input.size() < kHeader) {
    return Status::Corruption(""malformed WriteBatch (too small)"");
  }

  input.remove_prefix(kHeader);
  Slice key, value;
  int found = 0;
  while (!input.empty()) {
    found++;
    char tag = input[0];
    input.remove_prefix(1);
    switch (tag) {
      case kTypeValue:
        if (GetLengthPrefixedSlice(&input, &key) &&
            GetLengthPrefixedSlice(&input, &value)) {
          handler->Put(key, value);
        } else {
          return Status::Corruption(""bad WriteBatch Put"");
        }
        break;
      case kTypeDeletion:
        if (GetLengthPrefixedSlice(&input, &key)) {
          handler->Delete(key);
        } else {
          return Status::Corruption(""bad WriteBatch Delete"");
        }
        break;
      default:
        return Status::Corruption(""unknown WriteBatch tag"");
    }
  }
  if (found != WriteBatchInternal::Count(this)) {
    return Status::Cor...",42.0,80.0,1.0,1.0,39.0,24,10,30,12,0,4,9,12,0,3,,0,1,2,1,1,Status
1776,56658,Count,1,leveldb.WriteBatchInternal.Count,int leveldb.WriteBatchInternal.Count (WriteBatch*),db\write_batch.cc,"int WriteBatchInternal::Count(const WriteBatch* b) {
  return DecodeFixed32(b->rep_.data() + 8);
}",82.0,84.0,1.0,1.0,3.0,3,3,1,1,4,1,1,1,0,0,,0,1,2,1,1,int
1777,56673,SetCount,1,leveldb.WriteBatchInternal.SetCount,"void leveldb.WriteBatchInternal.SetCount (WriteBatch*,int)",db\write_batch.cc,"void WriteBatchInternal::SetCount(WriteBatch* b, int n) {
  EncodeFixed32(&b->rep_[8], n);
}",86.0,88.0,1.0,1.0,3.0,3,3,2,2,3,1,1,1,0,0,,0,1,4,2,2,void
1778,56687,Sequence,1,leveldb.WriteBatchInternal.Sequence,SequenceNumber leveldb.WriteBatchInternal.Sequence (WriteBatch*),db\write_batch.cc,"SequenceNumber WriteBatchInternal::Sequence(const WriteBatch* b) {
  return SequenceNumber(DecodeFixed64(b->rep_.data()));
}",90.0,92.0,1.0,1.0,3.0,2,2,1,1,1,1,1,1,0,0,,0,1,2,1,1,SequenceNumber
1779,56701,SetSequence,1,leveldb.WriteBatchInternal.SetSequence,"void leveldb.WriteBatchInternal.SetSequence (WriteBatch*,SequenceNumber)",db\write_batch.cc,"void WriteBatchInternal::SetSequence(WriteBatch* b, SequenceNumber seq) {
  EncodeFixed64(&b->rep_[0], seq);
}",94.0,96.0,1.0,1.0,3.0,3,3,2,2,0,1,1,1,0,0,,0,1,4,2,2,void
1780,56715,Put,1,leveldb.WriteBatch.Put,"void leveldb.WriteBatch.Put (Slice,Slice)",db\write_batch.cc,"void WriteBatch::Put(const Slice& key, const Slice& value) {
  WriteBatchInternal::SetCount(this, WriteBatchInternal::Count(this) + 1);
  rep_.push_back(static_cast<char>(kTypeValue));
  PutLengthPrefixedSlice(&rep_, key);
  PutLengthPrefixedSlice(&rep_, value);
}",98.0,103.0,1.0,1.0,6.0,7,4,8,5,0,5,1,1,0,2,,0,4,4,2,2,void
1781,56748,Delete,1,leveldb.WriteBatch.Delete,void leveldb.WriteBatch.Delete (Slice),db\write_batch.cc,"void WriteBatch::Delete(const Slice& key) {
  WriteBatchInternal::SetCount(this, WriteBatchInternal::Count(this) + 1);
  rep_.push_back(static_cast<char>(kTypeDeletion));
  PutLengthPrefixedSlice(&rep_, key);
}",105.0,109.0,1.0,1.0,5.0,6,4,6,4,0,4,1,1,0,2,,0,3,2,1,1,void
1782,56780,Put,1,leveldb.anonymous_namespace_2.MemTableInserter.Put,"void leveldb.anonymous_namespace_2.MemTableInserter.Put (Slice,Slice)",db\write_batch.cc,"virtual void Put(const Slice& key, const Slice& value) {
    mem_->Add(sequence_, kTypeValue, key, value);
    sequence_++;
  }",117.0,120.0,3.0,3.0,4.0,2,2,6,5,0,3,1,1,0,0,,0,3,4,2,2,void
1783,56796,Delete,1,leveldb.anonymous_namespace_3.MemTableInserter.Delete,void leveldb.anonymous_namespace_3.MemTableInserter.Delete (Slice),db\write_batch.cc,"virtual void Delete(const Slice& key) {
    mem_->Add(sequence_, kTypeDeletion, key, Slice());
    sequence_++;
  }",121.0,124.0,3.0,3.0,4.0,2,2,5,4,0,3,1,1,0,0,,0,3,2,1,1,void
1784,56811,InsertInto,1,leveldb.WriteBatchInternal.InsertInto,"Status leveldb.WriteBatchInternal.InsertInto (WriteBatch*,MemTable*)",db\write_batch.cc,"Status WriteBatchInternal::InsertInto(const WriteBatch* b,
                                      MemTable* memtable) {
  MemTableInserter inserter;
  inserter.sequence_ = WriteBatchInternal::Sequence(b);
  inserter.mem_ = memtable;
  return b->Iterate(&inserter);
}",128.0,134.0,1.0,1.0,7.0,7,4,7,4,0,3,1,1,0,1,,0,3,4,2,2,Status
1785,56839,SetContents,1,leveldb.WriteBatchInternal.SetContents,"void leveldb.WriteBatchInternal.SetContents (WriteBatch*,Slice)",db\write_batch.cc,"void WriteBatchInternal::SetContents(WriteBatch* b, const Slice& contents) {
  assert(contents.size() >= kHeader);
  b->rep_.assign(contents.data(), contents.size());
}",136.0,139.0,1.0,1.0,4.0,6,3,5,3,0,1,1,1,0,0,,0,1,4,2,2,void
1786,56866,Append,1,leveldb.WriteBatchInternal.Append,"void leveldb.WriteBatchInternal.Append (WriteBatch*,WriteBatch*)",db\write_batch.cc,"void WriteBatchInternal::Append(WriteBatch* dst, const WriteBatch* src) {
  SetCount(dst, Count(dst) + Count(src));
  assert(src->rep_.size() >= kHeader);
  dst->rep_.append(src->rep_.data() + kHeader, src->rep_.size() - kHeader);
}",141.0,145.0,1.0,1.0,5.0,12,5,10,3,0,7,1,1,0,3,,0,6,4,2,2,void
1787,56944,Contents,1,leveldb.WriteBatchInternal.Contents,Slice leveldb.WriteBatchInternal.Contents (WriteBatch*),db\write_batch_internal.hpp,"static Slice Contents(const WriteBatch* batch) {
    return Slice(batch->rep_);
  }",32.0,34.0,3.0,3.0,3.0,1,1,1,1,1,1,1,1,0,0,,0,1,2,1,1,Slice
1788,56954,ByteSize,1,leveldb.WriteBatchInternal.ByteSize,size_t leveldb.WriteBatchInternal.ByteSize (WriteBatch*),db\write_batch_internal.hpp,"static size_t ByteSize(const WriteBatch* batch) {
    return batch->rep_.size();
  }",36.0,38.0,3.0,3.0,3.0,2,2,1,1,2,1,1,1,0,0,,0,1,2,1,1,size_t
1789,57002,PrintContents,1,leveldb.PrintContents,string leveldb.PrintContents (WriteBatch*),db\write_batch_test.cc,"static std::string PrintContents(WriteBatch* b) {
  InternalKeyComparator cmp(BytewiseComparator());
  MemTable* mem = new MemTable(cmp);
  mem->Ref();
  std::string state;
  Status s = WriteBatchInternal::InsertInto(b, mem);
  int count = 0;
  Iterator* iter = mem->NewIterator();
  for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {
    ParsedInternalKey ikey;
    ASSERT_TRUE(ParseInternalKey(iter->key(), &ikey));
    switch (ikey.type) {
      case kTypeValue:
        state.append(""Put("");
        state.append(ikey.user_key.ToString());
        state.append("", "");
        state.append(iter->value().ToString());
        state.append("")"");
        count++;
        break;
      case kTypeDeletion:
        state.append(""Delete("");
        state.append(ikey.user_key.ToString());
        state.append("")"");
        count++;
        break;
    }
    state.append(""@"");
    state.append(NumberToString(ikey.sequence));
  }
  delete iter;
  if (!s.ok()) {
    state.append(""ParseError()"")...",15.0,53.0,1.0,4.0,39.0,40,8,41,13,0,4,6,5,1,0,,0,4,2,1,1,string
1790,57419,_Run,1,leveldb._Test_Corruption._Run,void leveldb._Test_Corruption._Run (),db\write_batch_test.cc,"TEST(WriteBatchTest, Corruption) {
  WriteBatch batch;
  batch.Put(Slice(""foo""), Slice(""bar""));
  batch.Delete(Slice(""box""));
  WriteBatchInternal::SetSequence(&batch, 200);
  Slice contents = WriteBatchInternal::Contents(&batch);
  WriteBatchInternal::SetContents(&batch,
                                  Slice(contents.data(),contents.size()-1));
  ASSERT_EQ(""Put(foo, bar)@200""
            ""ParseError()"",
            PrintContents(&batch));
}",77.0,88.0,1.0,32.0,12.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1791,57423,_RunIt,1,leveldb._Test_Corruption._RunIt,void leveldb._Test_Corruption._RunIt (),db\write_batch_test.cc,"TEST(WriteBatchTest, Corruption)",77.0,77.0,1.0,32.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1792,57520,_Run,1,leveldb._Test_Append._Run,void leveldb._Test_Append._Run (),db\write_batch_test.cc,"TEST(WriteBatchTest, Append) {
  WriteBatch b1, b2;
  WriteBatchInternal::SetSequence(&b1, 200);
  WriteBatchInternal::SetSequence(&b2, 300);
  WriteBatchInternal::Append(&b1, &b2);
  ASSERT_EQ("""",
            PrintContents(&b1));
  b2.Put(""a"", ""va"");
  WriteBatchInternal::Append(&b1, &b2);
  ASSERT_EQ(""Put(a, va)@200"",
            PrintContents(&b1));
  b2.Clear();
  b2.Put(""b"", ""vb"");
  WriteBatchInternal::Append(&b1, &b2);
  ASSERT_EQ(""Put(a, va)@200""
            ""Put(b, vb)@201"",
            PrintContents(&b1));
  b2.Delete(""foo"");
  WriteBatchInternal::Append(&b1, &b2);
  ASSERT_EQ(""Put(a, va)@200""
            ""Put(b, vb)@202""
            ""Put(b, vb)@201""
            ""Delete(foo)@203"",
            PrintContents(&b1));
}",90.0,114.0,1.0,28.0,25.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1793,57524,_RunIt,1,leveldb._Test_Append._RunIt,void leveldb._Test_Append._RunIt (),db\write_batch_test.cc,"TEST(WriteBatchTest, Append)",90.0,90.0,1.0,28.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1794,57781,ExecErrorCheck,1,ExecErrorCheck,"void ExecErrorCheck (int,char*)",doc\bench\db_bench_sqlite3.cc,"inline
static void ExecErrorCheck(int status, char *err_msg) {
  if (status != SQLITE_OK) {
    fprintf(stderr, ""SQL error: %s\n"", err_msg);
    sqlite3_free(err_msg);
    exit(1);
  }
}",81.0,88.0,1.0,1.0,8.0,1,1,5,4,1,0,2,2,0,0,,0,0,4,2,2,void
1795,57800,StepErrorCheck,1,StepErrorCheck,void StepErrorCheck (int),doc\bench\db_bench_sqlite3.cc,"inline
static void StepErrorCheck(int status) {
  if (status != SQLITE_DONE) {
    fprintf(stderr, ""SQL step error: status = %d\n"", status);
    exit(1);
  }
}",90.0,96.0,1.0,1.0,7.0,1,1,4,3,6,0,2,2,0,0,,0,0,2,1,1,void
1796,57816,ErrorCheck,1,ErrorCheck,void ErrorCheck (int),doc\bench\db_bench_sqlite3.cc,"inline
static void ErrorCheck(int status) {
  if (status != SQLITE_OK) {
    fprintf(stderr, ""sqlite3 error: status = %d\n"", status);
    exit(1);
  }
}",98.0,104.0,1.0,1.0,7.0,1,1,4,3,23,0,2,2,0,0,,0,0,2,1,1,void
1797,57832,WalCheckpoint,1,WalCheckpoint,void WalCheckpoint (sqlite3*),doc\bench\db_bench_sqlite3.cc,"inline
static void WalCheckpoint(sqlite3* db_) {
  // Flush all writes to disk
  if (FLAGS_WAL_enabled) {
    sqlite3_wal_checkpoint_v2(db_, NULL, SQLITE_CHECKPOINT_FULL, NULL, NULL);
  }
}",106.0,112.0,1.0,1.0,7.0,0,0,6,4,0,1,2,2,1,0,,0,1,2,1,1,void
1798,57924,TrimSpace,1,leveldb.anonymous_namespace_4.TrimSpace,Slice leveldb.anonymous_namespace_4.TrimSpace (Slice),doc\bench\db_bench_tree_db.cc,"static Slice TrimSpace(Slice s) {
  int start = 0;
  while (start < s.size() && isspace(s[start])) {
    start++;
  }
  int limit = s.size();
  while (limit > start && isspace(s[limit-1])) {
    limit--;
  }
  return Slice(s.data() + start, limit - start);
}",118.0,128.0,1.0,1.0,11.0,16,10,17,3,0,0,3,3,0,0,,0,0,2,1,1,Slice
1799,58046,Start,1,leveldb.Benchmark.Start,void leveldb.Benchmark.Start (),doc\bench\db_bench_tree_db.cc,"void Start() {
    start_ = Env::Default()->NowMicros() * 1e-6;
    bytes_ = 0;
    message_.clear();
    last_op_finish_ = start_;
    hist_.Clear();
    done_ = 0;
    next_report_ = 100;
  }",216.0,224.0,3.0,3.0,9.0,10,4,9,8,0,8,1,1,0,0,,0,8,0,0,0,void
1800,58081,FinishedSingleOp,1,leveldb.Benchmark.FinishedSingleOp,void leveldb.Benchmark.FinishedSingleOp (),doc\bench\db_bench_tree_db.cc,"void FinishedSingleOp() {
    if (FLAGS_histogram) {
      double now = Env::Default()->NowMicros() * 1e-6;
      double micros = (now - last_op_finish_) * 1e6;
      hist_.Add(micros);
      if (micros > 20000) {
        fprintf(stderr, ""long op: %.1f micros%30s\r"", micros, """");
        fflush(stderr);
      }
      last_op_finish_ = now;
    }

    done_++;
    if (done_ >= next_report_) {
      if      (next_report_ < 1000)   next_report_ += 100;
      else if (next_report_ < 5000)   next_report_ += 500;
      else if (next_report_ < 10000)  next_report_ += 1000;
      else if (next_report_ < 50000)  next_report_ += 5000;
      else if (next_report_ < 100000) next_report_ += 10000;
      else if (next_report_ < 500000) next_report_ += 50000;
      else                            next_report_ += 100000;
      fprintf(stderr, ""... finished %d ops%30s\r"", done_, """");
      fflush(stderr);
    }
  }",226.0,250.0,3.0,3.0,25.0,14,10,20,9,0,10,5,7,4,0,,0,10,0,0,0,void
1801,58203,Stop,1,leveldb.Benchmark.Stop,void leveldb.Benchmark.Stop (Slice),doc\bench\db_bench_tree_db.cc,"void Stop(const Slice& name) {
    double finish = Env::Default()->NowMicros() * 1e-6;

    // Pretend at least one op was done in case we are running a benchmark
    // that does not call FinishedSingleOp().
    if (done_ < 1) done_ = 1;

    if (bytes_ > 0) {
      char rate[100];
      snprintf(rate, sizeof(rate), ""%6.1f MB/s"",
               (bytes_ / 1048576.0) / (finish - start_));
      if (!message_.empty()) {
        message_  = std::string(rate) + "" "" + message_;
      } else {
        message_ = rate;
      }
    }

    fprintf(stdout, ""%-12s : %11.3f micros/op;%s%s\n"",
            name.ToString().c_str(),
            (finish - start_) * 1e6 / done_,
            (message_.empty() ? """" : "" ""),
            message_.c_str());
    if (FLAGS_histogram) {
      fprintf(stdout, ""Microseconds per op:\n%s\n"", hist_.ToString().c_str());
    }
    fflush(stdout);
  }",252.0,279.0,3.0,3.0,28.0,27,12,25,12,0,14,5,6,4,0,,0,14,2,1,1,void
1802,58910,Write,1,leveldb.Benchmark.Write,"void leveldb.Benchmark.Write (bool,Order,DBState,int,int,int)",doc\bench\db_bench_tree_db.cc,"void Write(bool sync, Order order, DBState state,
             int num_entries, int value_size, int entries_per_batch) {
    // Create new database if state == FRESH
    if (state == FRESH) {
      if (FLAGS_use_existing_db) {
        message_ = ""skipping (--use_existing_db is true)"";
        return;
      }
      delete db_;
      db_ = NULL;
      Open(sync);
      Start();  // Do not count time taken to destroy/open
    }

    if (num_entries != num_) {
      char msg[100];
      snprintf(msg, sizeof(msg), ""(%d ops)"", num_entries);
      message_ = msg;
    }

    // Write to database
    for (int i = 0; i < num_entries; i++)
    {
      const int k = (order == SEQUENTIAL) ? i : (rand_.Next() % num_entries);
      char key[100];
      snprintf(key, sizeof(key), ""%016d"", k);
      bytes_ += value_size + strlen(key);
      std::string cpp_key = key;
      if (!db_->set(cpp_key, gen_.Generate(value_size).ToString())) {
        fprintf(stderr, ""set error: %s\n"", db_->error().name());...",424.0,457.0,3.0,3.0,34.0,59,14,116,34,0,33,8,12,5,16,,0,17,12,6,6,void
1803,59203,Read,1,leveldb.Benchmark.Read,"void leveldb.Benchmark.Read (Order,int)",doc\bench\db_bench_sqlite3.cc,"void Read(Order order, int entries_per_batch) {
    int status;
    sqlite3_stmt *read_stmt, *begin_trans_stmt, *end_trans_stmt;

    std::string read_str = ""SELECT * FROM test WHERE key = ?"";
    std::string begin_trans_str = ""BEGIN TRANSACTION;"";
    std::string end_trans_str = ""END TRANSACTION;"";

    // Preparing sqlite3 statements
    status = sqlite3_prepare_v2(db_, begin_trans_str.c_str(), -1,
                                &begin_trans_stmt, NULL);
    ErrorCheck(status);
    status = sqlite3_prepare_v2(db_, end_trans_str.c_str(), -1,
                                &end_trans_stmt, NULL);
    ErrorCheck(status);
    status = sqlite3_prepare_v2(db_, read_str.c_str(), -1, &read_stmt, NULL);
    ErrorCheck(status);

    bool transaction = (entries_per_batch > 1);
    for (int i = 0; i < reads_; i += entries_per_batch) {
      // Begin read transaction
      if (FLAGS_transaction && transaction) {
        status = sqlite3_step(begin_trans_stmt);
        StepErrorCheck(status);...",581.0,647.0,3.0,3.0,67.0,42,12,79,22,0,23,6,11,3,14,,0,9,4,2,2,void
1804,59839,DBSynchronize,1,DBSynchronize,void DBSynchronize (ANY*),doc\bench\db_bench_tree_db.cc,"inline
static void DBSynchronize(kyotocabinet::TreeDB* db_)
{
  // Synchronize will flush writes to disk
  if (!db_->synchronize()) {
    fprintf(stderr, ""synchronize error: %s\n"", db_->error().name());
  }
}",74.0,81.0,1.0,1.0,8.0,4,3,3,2,0,0,2,2,0,0,,0,0,2,1,1,void
1805,61365,FileState,1,leveldb.anonymous_namespace_2.FileState.FileState,ANY leveldb.anonymous_namespace_2.FileState.FileState (),helpers\memenv\memenv.cc,"FileState() : refs_(0), size_(0) {}",24.0,24.0,3.0,37.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
1806,61369,Ref,1,leveldb.anonymous_namespace_3.FileState.Ref,void leveldb.anonymous_namespace_3.FileState.Ref (),helpers\memenv\memenv.cc,"void Ref() {
    MutexLock lock(&refs_mutex_);
    ++refs_;
  }",27.0,30.0,3.0,3.0,4.0,2,2,2,2,0,2,1,1,0,0,,0,2,0,0,0,void
1807,61379,Unref,1,leveldb.anonymous_namespace_4.FileState.Unref,void leveldb.anonymous_namespace_4.FileState.Unref (),helpers\memenv\memenv.cc,"void Unref() {
    bool do_delete = false;

    {
      MutexLock lock(&refs_mutex_);
      --refs_;
      assert(refs_ >= 0);
      if (refs_ <= 0) {
        do_delete = true;
      }
    }

    if (do_delete) {
      delete this;
    }
  }",33.0,48.0,3.0,3.0,16.0,7,6,7,3,0,4,3,3,1,0,,0,4,0,0,0,void
1808,61411,Size,1,leveldb.anonymous_namespace_5.FileState.Size,uint64_t leveldb.anonymous_namespace_5.FileState.Size (),helpers\memenv\memenv.cc,uint64_t Size() const { return size_; },50.0,50.0,3.0,41.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,uint64_t
1809,61417,Read,1,leveldb.anonymous_namespace_6.FileState.Read,"Status leveldb.anonymous_namespace_6.FileState.Read (uint64_t,size_t,Slice*,char*)",helpers\memenv\memenv.cc,"Status Read(uint64_t offset, size_t n, Slice* result, char* scratch) const {
    if (offset > size_) {
      return Status::IOError(""Offset greater than file size."");
    }
    const uint64_t available = size_ - offset;
    if (n > available) {
      n = static_cast<size_t>(available);
    }
    if (n == 0) {
      *result = Slice();
      return Status::OK();
    }

    assert(offset / kBlockSize <= SIZE_MAX);
    size_t block = static_cast<size_t>(offset / kBlockSize);
    size_t block_offset = offset % kBlockSize;

    if (n <= kBlockSize - block_offset) {
      // The requested bytes are all in the first block.
      *result = Slice(blocks_[block] + block_offset, n);
      return Status::OK();
    }

    size_t bytes_to_copy = n;
    char* dst = scratch;

    while (bytes_to_copy > 0) {
      size_t avail = kBlockSize - block_offset;
      if (avail > bytes_to_copy) {
        avail = bytes_to_copy;
      }
      memcpy(dst, blocks_[block] + block_offset, avail);

      bytes_to_...",52.0,93.0,3.0,3.0,42.0,41,15,58,15,0,13,7,8,2,1,,0,9,8,4,4,Status
1810,61565,Append,1,leveldb.anonymous_namespace_7.FileState.Append,Status leveldb.anonymous_namespace_7.FileState.Append (Slice),helpers\memenv\memenv.cc,"Status Append(const Slice& data) {
    const char* src = data.data();
    size_t src_len = data.size();

    while (src_len > 0) {
      size_t avail;
      size_t offset = size_ % kBlockSize;

      if (offset != 0) {
        // There is some room in the last block.
        avail = kBlockSize - offset;
      } else {
        // No room in the last block; push new one.
        blocks_.push_back(new char[kBlockSize]);
        avail = kBlockSize;
      }

      if (avail > src_len) {
        avail = src_len;
      }
      memcpy(blocks_.back() + offset, src, avail);
      src_len -= avail;
      src += avail;
      size_ += avail;
    }

    return Status::OK();
  }",95.0,122.0,3.0,3.0,28.0,18,9,27,9,0,6,4,6,0,0,,0,5,2,1,1,Status
1811,61648,~FileState,1,leveldb.anonymous_namespace_8.FileState.~FileState,ANY leveldb.anonymous_namespace_8.FileState.~FileState (),helpers\memenv\memenv.cc,"~FileState() {
    for (std::vector<char*>::iterator i = blocks_.begin(); i != blocks_.end();
         ++i) {
      delete [] *i;
    }
  }",126.0,131.0,3.0,3.0,6.0,6,5,5,2,0,2,2,2,1,0,,0,2,0,0,0,ANY
1812,61673,FileState,1,leveldb.anonymous_namespace_9.FileState.FileState,ANY leveldb.anonymous_namespace_9.FileState.FileState (FileState),helpers\memenv\memenv.cc,FileState(const FileState&);,134.0,134.0,3.0,29.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
1813,61678,operator =,1,leveldb.anonymous_namespace_10.FileState.operator =,void leveldb.anonymous_namespace_10.FileState.operator = (FileState),helpers\memenv\memenv.cc,void operator=(const FileState&);,135.0,135.0,8.0,34.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
1814,61699,SequentialFileImpl,1,leveldb.anonymous_namespace_14.SequentialFileImpl.SequentialFileImpl,ANY leveldb.anonymous_namespace_14.SequentialFileImpl.SequentialFileImpl (FileState*),helpers\memenv\memenv.cc,"explicit SequentialFileImpl(FileState* file) : file_(file), pos_(0) {
    file_->Ref();
  }",151.0,153.0,3.0,3.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,ANY
1815,61708,~SequentialFileImpl,1,leveldb.anonymous_namespace_15.SequentialFileImpl.~SequentialFileImpl,ANY leveldb.anonymous_namespace_15.SequentialFileImpl.~SequentialFileImpl (),helpers\memenv\memenv.cc,"~SequentialFileImpl() {
    file_->Unref();
  }",155.0,157.0,3.0,3.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,ANY
1816,61716,Read,1,leveldb.anonymous_namespace_16.SequentialFileImpl.Read,"Status leveldb.anonymous_namespace_16.SequentialFileImpl.Read (size_t,Slice*,char*)",helpers\memenv\memenv.cc,"virtual Status Read(size_t n, Slice* result, char* scratch) {
    Status s = file_->Read(pos_, n, result, scratch);
    if (s.ok()) {
      pos_ += result->size();
    }
    return s;
  }",159.0,165.0,3.0,3.0,7.0,5,4,10,6,0,3,2,2,0,0,,0,3,6,3,3,Status
1817,61748,Skip,1,leveldb.anonymous_namespace_17.SequentialFileImpl.Skip,Status leveldb.anonymous_namespace_17.SequentialFileImpl.Skip (uint64_t),helpers\memenv\memenv.cc,"virtual Status Skip(uint64_t n) {
    if (pos_ > file_->Size()) {
      return Status::IOError(""pos_ > file_->Size()"");
    }
    const uint64_t available = file_->Size() - pos_;
    if (n > available) {
      n = available;
    }
    pos_ += n;
    return Status::OK();
  }",167.0,177.0,3.0,3.0,11.0,10,6,13,5,0,7,3,3,2,1,,0,5,2,1,1,Status
1818,61795,RandomAccessFileImpl,1,leveldb.anonymous_namespace_19.RandomAccessFileImpl.RandomAccessFileImpl,ANY leveldb.anonymous_namespace_19.RandomAccessFileImpl.RandomAccessFileImpl (FileState*),helpers\memenv\memenv.cc,"explicit RandomAccessFileImpl(FileState* file) : file_(file) {
    file_->Ref();
  }",186.0,188.0,3.0,3.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,ANY
1819,61804,~RandomAccessFileImpl,1,leveldb.anonymous_namespace_20.RandomAccessFileImpl.~RandomAccessFileImpl,ANY leveldb.anonymous_namespace_20.RandomAccessFileImpl.~RandomAccessFileImpl (),helpers\memenv\memenv.cc,"~RandomAccessFileImpl() {
    file_->Unref();
  }",190.0,192.0,3.0,3.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,ANY
1820,61812,Read,1,leveldb.anonymous_namespace_21.RandomAccessFileImpl.Read,"Status leveldb.anonymous_namespace_21.RandomAccessFileImpl.Read (uint64_t,size_t,Slice*,char*)",helpers\memenv\memenv.cc,"virtual Status Read(uint64_t offset, size_t n, Slice* result,
                      char* scratch) const {
    return file_->Read(offset, n, result, scratch);
  }",194.0,197.0,3.0,3.0,4.0,1,1,5,5,0,1,1,1,0,0,,0,1,8,4,4,Status
1821,61831,WritableFileImpl,1,leveldb.anonymous_namespace_23.WritableFileImpl.WritableFileImpl,ANY leveldb.anonymous_namespace_23.WritableFileImpl.WritableFileImpl (FileState*),helpers\memenv\memenv.cc,"WritableFileImpl(FileState* file) : file_(file) {
    file_->Ref();
  }",205.0,207.0,3.0,3.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,ANY
1822,61840,~WritableFileImpl,1,leveldb.anonymous_namespace_24.WritableFileImpl.~WritableFileImpl,ANY leveldb.anonymous_namespace_24.WritableFileImpl.~WritableFileImpl (),helpers\memenv\memenv.cc,"~WritableFileImpl() {
    file_->Unref();
  }",209.0,211.0,3.0,3.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,ANY
1823,61848,Append,1,leveldb.anonymous_namespace_25.WritableFileImpl.Append,Status leveldb.anonymous_namespace_25.WritableFileImpl.Append (Slice),helpers\memenv\memenv.cc,"virtual Status Append(const Slice& data) {
    return file_->Append(data);
  }",213.0,215.0,3.0,3.0,3.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,Status
1824,61859,Close,1,leveldb.anonymous_namespace_26.WritableFileImpl.Close,Status leveldb.anonymous_namespace_26.WritableFileImpl.Close (),helpers\memenv\memenv.cc,virtual Status Close() { return Status::OK(); },217.0,217.0,3.0,49.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,0,0,0,0,Status
1825,61868,Flush,1,leveldb.anonymous_namespace_27.WritableFileImpl.Flush,Status leveldb.anonymous_namespace_27.WritableFileImpl.Flush (),helpers\memenv\memenv.cc,virtual Status Flush() { return Status::OK(); },218.0,218.0,3.0,49.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,0,0,0,0,Status
1826,61877,Sync,1,leveldb.anonymous_namespace_28.WritableFileImpl.Sync,Status leveldb.anonymous_namespace_28.WritableFileImpl.Sync (),helpers\memenv\memenv.cc,virtual Status Sync() { return Status::OK(); },219.0,219.0,3.0,48.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,0,0,0,0,Status
1827,61888,Logv,1,leveldb.anonymous_namespace_30.NoOpLogger.Logv,"void leveldb.anonymous_namespace_30.NoOpLogger.Logv (char*,va_list)",helpers\memenv\memenv.cc,"virtual void Logv(const char* format, va_list ap) { }",227.0,227.0,3.0,55.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
1828,61895,InMemoryEnv,1,leveldb.anonymous_namespace_32.InMemoryEnv.InMemoryEnv,ANY leveldb.anonymous_namespace_32.InMemoryEnv.InMemoryEnv (Env*),helpers\memenv\memenv.cc,explicit InMemoryEnv(Env* base_env) : EnvWrapper(base_env) { },232.0,232.0,3.0,64.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
1829,61900,~InMemoryEnv,1,leveldb.anonymous_namespace_33.InMemoryEnv.~InMemoryEnv,ANY leveldb.anonymous_namespace_33.InMemoryEnv.~InMemoryEnv (),helpers\memenv\memenv.cc,"virtual ~InMemoryEnv() {
    for (FileSystem::iterator i = file_map_.begin(); i != file_map_.end(); ++i){
      i->second->Unref();
    }
  }",234.0,238.0,3.0,3.0,5.0,6,4,5,2,0,2,2,2,1,0,,0,2,0,0,0,ANY
1830,61928,NewSequentialFile,1,leveldb.anonymous_namespace_34.InMemoryEnv.NewSequentialFile,"Status leveldb.anonymous_namespace_34.InMemoryEnv.NewSequentialFile (ANY,SequentialFile**)",helpers\memenv\memenv.cc,"virtual Status NewSequentialFile(const std::string& fname,
                                   SequentialFile** result) {
    MutexLock lock(&mutex_);
    if (file_map_.find(fname) == file_map_.end()) {
      *result = NULL;
      return Status::IOError(fname, ""File not found"");
    }

    *result = new SequentialFileImpl(file_map_[fname]);
    return Status::OK();
  }",241.0,251.0,3.0,3.0,11.0,12,7,13,7,0,6,2,2,2,1,,0,4,4,2,2,Status
1831,61974,NewRandomAccessFile,1,leveldb.anonymous_namespace_35.InMemoryEnv.NewRandomAccessFile,"Status leveldb.anonymous_namespace_35.InMemoryEnv.NewRandomAccessFile (ANY,RandomAccessFile**)",helpers\memenv\memenv.cc,"virtual Status NewRandomAccessFile(const std::string& fname,
                                     RandomAccessFile** result) {
    MutexLock lock(&mutex_);
    if (file_map_.find(fname) == file_map_.end()) {
      *result = NULL;
      return Status::IOError(fname, ""File not found"");
    }

    *result = new RandomAccessFileImpl(file_map_[fname]);
    return Status::OK();
  }",253.0,263.0,3.0,3.0,11.0,12,7,13,7,0,6,2,2,2,1,,0,4,4,2,2,Status
1832,62020,NewWritableFile,1,leveldb.anonymous_namespace_36.InMemoryEnv.NewWritableFile,"Status leveldb.anonymous_namespace_36.InMemoryEnv.NewWritableFile (ANY,WritableFile**)",helpers\memenv\memenv.cc,"virtual Status NewWritableFile(const std::string& fname,
                                 WritableFile** result) {
    MutexLock lock(&mutex_);
    if (file_map_.find(fname) != file_map_.end()) {
      DeleteFileInternal(fname);
    }

    FileState* file = new FileState();
    file->Ref();
    file_map_[fname] = file;

    *result = new WritableFileImpl(file);
    return Status::OK();
  }",265.0,278.0,3.0,3.0,14.0,13,8,15,8,0,5,2,2,2,0,,0,4,4,2,2,Status
1833,62069,NewAppendableFile,1,leveldb.anonymous_namespace_38.InMemoryEnv.NewAppendableFile,"Status leveldb.anonymous_namespace_38.InMemoryEnv.NewAppendableFile (ANY,WritableFile**)",helpers\memenv\memenv.cc,"virtual Status NewAppendableFile(const std::string& fname,
                                   WritableFile** result) {
    MutexLock lock(&mutex_);
    FileState** sptr = &file_map_[fname];
    FileState* file = *sptr;
    if (file == NULL) {
      file = new FileState();
      file->Ref();
    }
    *result = new WritableFileImpl(file);
    return Status::OK();
  }",280.0,291.0,3.0,3.0,12.0,14,8,15,10,0,3,2,2,0,0,,0,2,4,2,2,Status
1834,62115,FileExists,1,leveldb.anonymous_namespace_39.InMemoryEnv.FileExists,bool leveldb.anonymous_namespace_39.InMemoryEnv.FileExists (ANY),helpers\memenv\memenv.cc,"virtual bool FileExists(const std::string& fname) {
    MutexLock lock(&mutex_);
    return file_map_.find(fname) != file_map_.end();
  }",293.0,296.0,3.0,3.0,4.0,4,3,4,3,0,3,1,1,0,0,,0,3,2,1,1,bool
1835,62135,GetChildren,1,leveldb.anonymous_namespace_40.InMemoryEnv.GetChildren,"Status leveldb.anonymous_namespace_40.InMemoryEnv.GetChildren (ANY,ANY*)",helpers\memenv\memenv.cc,"virtual Status GetChildren(const std::string& dir,
                             std::vector<std::string>* result) {
    MutexLock lock(&mutex_);
    result->clear();

    for (FileSystem::iterator i = file_map_.begin(); i != file_map_.end(); ++i){
      const std::string& filename = i->first;

      if (filename.size() >= dir.size() + 1 && filename[dir.size()] == '/' &&
          Slice(filename).starts_with(Slice(dir))) {
        result->push_back(filename.substr(dir.size() + 1));
      }
    }

    return Status::OK();
  }",298.0,313.0,3.0,3.0,16.0,23,10,18,7,0,4,3,4,1,0,,0,3,4,2,2,Status
1836,62222,DeleteFileInternal,1,leveldb.anonymous_namespace_41.InMemoryEnv.DeleteFileInternal,void leveldb.anonymous_namespace_41.InMemoryEnv.DeleteFileInternal (ANY),helpers\memenv\memenv.cc,"void DeleteFileInternal(const std::string& fname) {
    if (file_map_.find(fname) == file_map_.end()) {
      return;
    }

    file_map_[fname]->Unref();
    file_map_.erase(fname);
  }",315.0,322.0,3.0,3.0,8.0,6,4,7,2,0,4,2,2,2,0,,0,4,2,1,1,void
1837,62251,DeleteFile,1,leveldb.anonymous_namespace_42.InMemoryEnv.DeleteFile,Status leveldb.anonymous_namespace_42.InMemoryEnv.DeleteFile (ANY),helpers\memenv\memenv.cc,"virtual Status DeleteFile(const std::string& fname) {
    MutexLock lock(&mutex_);
    if (file_map_.find(fname) == file_map_.end()) {
      return Status::IOError(fname, ""File not found"");
    }

    DeleteFileInternal(fname);
    return Status::OK();
  }",324.0,332.0,3.0,3.0,9.0,6,3,8,4,0,5,2,2,2,1,,0,3,2,1,1,Status
1838,62286,CreateDir,1,leveldb.anonymous_namespace_44.InMemoryEnv.CreateDir,Status leveldb.anonymous_namespace_44.InMemoryEnv.CreateDir (ANY),helpers\memenv\memenv.cc,"virtual Status CreateDir(const std::string& dirname) {
    return Status::OK();
  }",334.0,336.0,3.0,3.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,0,2,1,1,Status
1839,62296,DeleteDir,1,leveldb.anonymous_namespace_45.InMemoryEnv.DeleteDir,Status leveldb.anonymous_namespace_45.InMemoryEnv.DeleteDir (ANY),helpers\memenv\memenv.cc,"virtual Status DeleteDir(const std::string& dirname) {
    return Status::OK();
  }",338.0,340.0,3.0,3.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,0,2,1,1,Status
1840,62306,GetFileSize,1,leveldb.anonymous_namespace_46.InMemoryEnv.GetFileSize,"Status leveldb.anonymous_namespace_46.InMemoryEnv.GetFileSize (ANY,uint64_t*)",helpers\memenv\memenv.cc,"virtual Status GetFileSize(const std::string& fname, uint64_t* file_size) {
    MutexLock lock(&mutex_);
    if (file_map_.find(fname) == file_map_.end()) {
      return Status::IOError(fname, ""File not found"");
    }

    *file_size = file_map_[fname]->Size();
    return Status::OK();
  }",342.0,350.0,3.0,3.0,9.0,10,7,10,5,0,6,2,2,2,1,,0,4,4,2,2,Status
1841,62349,RenameFile,1,leveldb.anonymous_namespace_47.InMemoryEnv.RenameFile,"Status leveldb.anonymous_namespace_47.InMemoryEnv.RenameFile (ANY,ANY)",helpers\memenv\memenv.cc,"virtual Status RenameFile(const std::string& src,
                            const std::string& target) {
    MutexLock lock(&mutex_);
    if (file_map_.find(src) == file_map_.end()) {
      return Status::IOError(src, ""File not found"");
    }

    DeleteFileInternal(target);
    file_map_[target] = file_map_[src];
    file_map_.erase(src);
    return Status::OK();
  }",352.0,363.0,3.0,3.0,12.0,10,5,14,5,0,8,2,2,2,1,,0,6,4,2,2,Status
1842,62397,LockFile,1,leveldb.anonymous_namespace_49.InMemoryEnv.LockFile,"Status leveldb.anonymous_namespace_49.InMemoryEnv.LockFile (ANY,FileLock**)",helpers\memenv\memenv.cc,"virtual Status LockFile(const std::string& fname, FileLock** lock) {
    *lock = new FileLock;
    return Status::OK();
  }",365.0,368.0,3.0,3.0,4.0,4,4,3,3,0,1,1,1,0,0,,0,0,4,2,2,Status
1843,62413,UnlockFile,1,leveldb.anonymous_namespace_50.InMemoryEnv.UnlockFile,Status leveldb.anonymous_namespace_50.InMemoryEnv.UnlockFile (FileLock*),helpers\memenv\memenv.cc,"virtual Status UnlockFile(FileLock* lock) {
    delete lock;
    return Status::OK();
  }",370.0,373.0,3.0,3.0,4.0,2,2,2,2,0,1,1,1,0,0,,0,0,2,1,1,Status
1844,62425,GetTestDirectory,1,leveldb.anonymous_namespace_51.InMemoryEnv.GetTestDirectory,Status leveldb.anonymous_namespace_51.InMemoryEnv.GetTestDirectory (ANY*),helpers\memenv\memenv.cc,"virtual Status GetTestDirectory(std::string* path) {
    *path = ""/test"";
    return Status::OK();
  }",375.0,378.0,3.0,3.0,4.0,3,3,2,2,0,1,1,1,0,0,,0,0,2,1,1,Status
1845,62439,NewLogger,1,leveldb.anonymous_namespace_52.InMemoryEnv.NewLogger,"Status leveldb.anonymous_namespace_52.InMemoryEnv.NewLogger (ANY,Logger**)",helpers\memenv\memenv.cc,"virtual Status NewLogger(const std::string& fname, Logger** result) {
    *result = new NoOpLogger;
    return Status::OK();
  }",380.0,383.0,3.0,3.0,4.0,4,4,3,3,0,1,1,1,0,0,,0,0,4,2,2,Status
1846,62458,NewMemEnv,1,leveldb.NewMemEnv,Env leveldb.NewMemEnv (Env*),helpers\memenv\memenv.cc,"Env* NewMemEnv(Env* base_env) {
  return new InMemoryEnv(base_env);
}",394.0,396.0,1.0,1.0,3.0,1,1,2,2,0,0,1,1,0,0,,0,0,2,1,1,Env
1847,62501,MemEnvTest,1,leveldb.MemEnvTest.MemEnvTest,ANY leveldb.MemEnvTest.MemEnvTest (),helpers\memenv\memenv_test.cc,"MemEnvTest()
      : env_(NewMemEnv(Env::Default())) {
  }",20.0,22.0,3.0,3.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
1848,62505,~MemEnvTest,1,leveldb.MemEnvTest.~MemEnvTest,ANY leveldb.MemEnvTest.~MemEnvTest (),helpers\memenv\memenv_test.cc,"~MemEnvTest() {
    delete env_;
  }",23.0,25.0,3.0,3.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,ANY
1849,62512,_Run,1,leveldb._Test_Basics._Run,void leveldb._Test_Basics._Run (),helpers\memenv\memenv_test.cc,"TEST(MemEnvTest, Basics) {
  uint64_t file_size;
  WritableFile* writable_file;
  std::vector<std::string> children;

  ASSERT_OK(env_->CreateDir(""/dir""));

  // Check that the directory is empty.
  ASSERT_TRUE(!env_->FileExists(""/dir/non_existent""));
  ASSERT_TRUE(!env_->GetFileSize(""/dir/non_existent"", &file_size).ok());
  ASSERT_OK(env_->GetChildren(""/dir"", &children));
  ASSERT_EQ(0, children.size());

  // Create a file.
  ASSERT_OK(env_->NewWritableFile(""/dir/f"", &writable_file));
  ASSERT_OK(env_->GetFileSize(""/dir/f"", &file_size));
  ASSERT_EQ(0, file_size);
  delete writable_file;

  // Check that the file exists.
  ASSERT_TRUE(env_->FileExists(""/dir/f""));
  ASSERT_OK(env_->GetFileSize(""/dir/f"", &file_size));
  ASSERT_EQ(0, file_size);
  ASSERT_OK(env_->GetChildren(""/dir"", &children));
  ASSERT_EQ(1, children.size());
  ASSERT_EQ(""f"", children[0]);

  // Write to the file.
  ASSERT_OK(env_->NewWritableFile(""/dir/f"", &writable_file));
  ASSERT_OK(writable_file->Append(""abc"")...",28.0,94.0,1.0,24.0,67.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1850,62516,_RunIt,1,leveldb._Test_Basics._RunIt,void leveldb._Test_Basics._RunIt (),helpers\memenv\memenv_test.cc,"TEST(MemEnvTest, Basics)",28.0,28.0,1.0,24.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1851,63948,_Run,1,leveldb._Test_Locks._Run,void leveldb._Test_Locks._Run (),helpers\memenv\memenv_test.cc,"TEST(MemEnvTest, Locks) {
  FileLock* lock;

  // These are no-ops, but we test they return success.
  ASSERT_OK(env_->LockFile(""some file"", &lock));
  ASSERT_OK(env_->UnlockFile(lock));
}",138.0,144.0,1.0,23.0,7.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1852,63952,_RunIt,1,leveldb._Test_Locks._RunIt,void leveldb._Test_Locks._RunIt (),helpers\memenv\memenv_test.cc,"TEST(MemEnvTest, Locks)",138.0,138.0,1.0,23.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1853,64025,_Run,1,leveldb._Test_Misc._Run,void leveldb._Test_Misc._Run (),helpers\memenv\memenv_test.cc,"TEST(MemEnvTest, Misc) {
  std::string test_dir;
  ASSERT_OK(env_->GetTestDirectory(&test_dir));
  ASSERT_TRUE(!test_dir.empty());

  WritableFile* writable_file;
  ASSERT_OK(env_->NewWritableFile(""/a/b"", &writable_file));

  // These are no-ops, but we test they return success.
  ASSERT_OK(writable_file->Sync());
  ASSERT_OK(writable_file->Flush());
  ASSERT_OK(writable_file->Close());
  delete writable_file;
}",146.0,159.0,1.0,22.0,14.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1854,64029,_RunIt,1,leveldb._Test_Misc._RunIt,void leveldb._Test_Misc._RunIt (),helpers\memenv\memenv_test.cc,"TEST(MemEnvTest, Misc)",146.0,146.0,1.0,22.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1855,64194,_Run,1,leveldb._Test_LargeWrite._Run,void leveldb._Test_LargeWrite._Run (),helpers\memenv\memenv_test.cc,"TEST(MemEnvTest, LargeWrite) {
  const size_t kWriteSize = 300 * 1024;
  char* scratch = new char[kWriteSize * 2];

  std::string write_data;
  for (size_t i = 0; i < kWriteSize; ++i) {
    write_data.append(1, static_cast<char>(i));
  }

  WritableFile* writable_file;
  ASSERT_OK(env_->NewWritableFile(""/dir/f"", &writable_file));
  ASSERT_OK(writable_file->Append(""foo""));
  ASSERT_OK(writable_file->Append(write_data));
  delete writable_file;

  SequentialFile* seq_file;
  Slice result;
  ASSERT_OK(env_->NewSequentialFile(""/dir/f"", &seq_file));
  ASSERT_OK(seq_file->Read(3, &result, scratch)); // Read ""foo"".
  ASSERT_EQ(0, result.compare(""foo""));

  size_t read = 0;
  std::string read_data;
  while (read < kWriteSize) {
    ASSERT_OK(seq_file->Read(kWriteSize - read, &result, scratch));
    read_data.append(result.data(), result.size());
    read += result.size();
  }
  ASSERT_TRUE(write_data == read_data);
  delete seq_file;
  delete [] scratch;
}",161.0,192.0,1.0,28.0,32.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1856,64198,_RunIt,1,leveldb._Test_LargeWrite._RunIt,void leveldb._Test_LargeWrite._RunIt (),helpers\memenv\memenv_test.cc,"TEST(MemEnvTest, LargeWrite)",161.0,161.0,1.0,28.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1857,64468,_Run,1,leveldb._Test_DBTest._Run,void leveldb._Test_DBTest._Run (),helpers\memenv\memenv_test.cc,"TEST(MemEnvTest, DBTest) {
  Options options;
  options.create_if_missing = true;
  options.env = env_;
  DB* db;

  const Slice keys[] = {Slice(""aaa""), Slice(""bbb""), Slice(""ccc"")};
  const Slice vals[] = {Slice(""foo""), Slice(""bar""), Slice(""baz"")};

  ASSERT_OK(DB::Open(options, ""/dir/db"", &db));
  for (size_t i = 0; i < 3; ++i) {
    ASSERT_OK(db->Put(WriteOptions(), keys[i], vals[i]));
  }

  for (size_t i = 0; i < 3; ++i) {
    std::string res;
    ASSERT_OK(db->Get(ReadOptions(), keys[i], &res));
    ASSERT_TRUE(res == vals[i]);
  }

  Iterator* iterator = db->NewIterator(ReadOptions());
  iterator->SeekToFirst();
  for (size_t i = 0; i < 3; ++i) {
    ASSERT_TRUE(iterator->Valid());
    ASSERT_TRUE(keys[i] == iterator->key());
    ASSERT_TRUE(vals[i] == iterator->value());
    iterator->Next();
  }
  ASSERT_TRUE(!iterator->Valid());
  delete iterator;

  DBImpl* dbi = reinterpret_cast<DBImpl*>(db);
  ASSERT_OK(dbi->TEST_CompactMemTable());

  for (size_t i = 0; i < 3; ++i) {
  ...",194.0,235.0,1.0,24.0,42.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1858,64472,_RunIt,1,leveldb._Test_DBTest._RunIt,void leveldb._Test_DBTest._RunIt (),helpers\memenv\memenv_test.cc,"TEST(MemEnvTest, DBTest)",194.0,194.0,1.0,24.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1859,65321,NewLRUCache,1,leveldb.NewLRUCache,Cache* leveldb.NewLRUCache (size_t),util\cache.cc,"Cache* NewLRUCache(size_t capacity) {
  return new ShardedLRUCache(capacity);
}",401.0,403.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,Cache
1860,65327,Cache,1,leveldb.Cache.Cache,ANY leveldb.Cache.Cache (),include\leveldb\cache.hpp,Cache() { },34.0,34.0,3.0,13.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
1861,65331,~Cache,1,leveldb.Cache.~Cache,virtual leveldb.Cache.~Cache (),util\cache.cc,"Cache::~Cache() {
}",16.0,17.0,1.0,1.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
1862,65336,Insert,1,leveldb.Cache.Insert,"Handle* leveldb.Cache.Insert (Slice,void*,size_t,void)",include\leveldb\cache.hpp,"virtual Handle* Insert(const Slice& key, void* value, size_t charge,
                         void (*deleter)(const Slice& key, void* value)) = 0;",52.0,53.0,17.0,76.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,Handle*
1863,65344,Lookup,1,leveldb.Cache.Lookup,Handle* leveldb.Cache.Lookup (Slice),include\leveldb\cache.hpp,virtual Handle* Lookup(const Slice& key) = 0;,60.0,60.0,17.0,46.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,Handle*
1864,65349,Release,1,leveldb.Cache.Release,void leveldb.Cache.Release (Handle*),include\leveldb\cache.hpp,virtual void Release(Handle* handle) = 0;,65.0,65.0,16.0,42.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
1865,65354,Value,1,leveldb.Cache.Value,void* leveldb.Cache.Value (Handle*),include\leveldb\cache.hpp,virtual void* Value(Handle* handle) = 0;,71.0,71.0,15.0,41.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void*
1866,65359,Erase,1,leveldb.Cache.Erase,void leveldb.Cache.Erase (Slice),include\leveldb\cache.hpp,virtual void Erase(const Slice& key) = 0;,76.0,76.0,16.0,42.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
1867,65364,NewId,1,leveldb.Cache.NewId,uint64_t leveldb.Cache.NewId (),include\leveldb\cache.hpp,virtual uint64_t NewId() = 0;,82.0,82.0,20.0,30.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,uint64_t
1868,65368,Prune,1,leveldb.Cache.Prune,void leveldb.Cache.Prune (),include\leveldb\cache.hpp,virtual void Prune() {},89.0,89.0,3.0,25.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1869,65372,TotalCharge,1,leveldb.Cache.TotalCharge,size_t leveldb.Cache.TotalCharge (),include\leveldb\cache.hpp,virtual size_t TotalCharge() const = 0;,93.0,93.0,18.0,40.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,size_t
1870,65376,LRU_Remove,1,leveldb.Cache.LRU_Remove,void leveldb.Cache.LRU_Remove (Handle*),include\leveldb\cache.hpp,void LRU_Remove(Handle* e);,96.0,96.0,8.0,28.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
1871,65381,LRU_Append,1,leveldb.Cache.LRU_Append,void leveldb.Cache.LRU_Append (Handle*),include\leveldb\cache.hpp,void LRU_Append(Handle* e);,97.0,97.0,8.0,28.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
1872,65386,Unref,1,leveldb.Cache.Unref,void leveldb.Cache.Unref (Handle*),include\leveldb\cache.hpp,void Unref(Handle* e);,98.0,98.0,8.0,23.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
1873,65398,operator =,1,leveldb.Cache.operator =,void leveldb.Cache.operator = (Cache),include\leveldb\cache.hpp,void operator=(const Cache&);,105.0,105.0,8.0,30.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
1874,65413,~Comparator,1,leveldb.Comparator.~Comparator,virtual leveldb.Comparator.~Comparator (),util\comparator.cc,Comparator::~Comparator() { },14.0,14.0,1.0,29.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
1875,65417,Compare,1,leveldb.Comparator.Compare,"int leveldb.Comparator.Compare (Slice,Slice)",include\leveldb\comparator.hpp,"virtual int Compare(const Slice& a, const Slice& b) const = 0;",26.0,26.0,15.0,63.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
1876,65423,Name,1,leveldb.Comparator.Name,char* leveldb.Comparator.Name (),include\leveldb\comparator.hpp,virtual const char* Name() const = 0;,38.0,38.0,21.0,38.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,char*
1877,65427,FindShortestSeparator,1,leveldb.Comparator.FindShortestSeparator,"void leveldb.Comparator.FindShortestSeparator (ANY*,Slice)",include\leveldb\comparator.hpp,"virtual void FindShortestSeparator(
      std::string* start,
      const Slice& limit) const = 0;",46.0,48.0,16.0,35.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
1878,65433,FindShortSuccessor,1,leveldb.Comparator.FindShortSuccessor,void leveldb.Comparator.FindShortSuccessor (ANY*),include\leveldb\comparator.hpp,virtual void FindShortSuccessor(std::string* key) const = 0;,53.0,53.0,16.0,61.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
1879,65438,BytewiseComparator,1,leveldb.BytewiseComparator,Comparator* leveldb.BytewiseComparator (),util\comparator.cc,"const Comparator* BytewiseComparator() {
  port::InitOnce(&once, InitModule);
  return bytewise;
}",76.0,79.0,1.0,1.0,4.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,Comparator
1880,65476,Range,1,leveldb.Range.Range,ANY leveldb.Range.Range (),include\leveldb\db.hpp,"Range(const Slice& s, const Slice& l) : start(s), limit(l) { }",38.0,38.0,3.0,64.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,ANY
1881,65494,DB,1,leveldb.DB.DB,ANY leveldb.DB.DB (),include\leveldb\db.hpp,DB() { },55.0,55.0,3.0,10.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
1882,65515,Write,1,leveldb.DB.Write,"Status leveldb.DB.Write (WriteOptions,WriteBatch*)",include\leveldb\db.hpp,"virtual Status Write(const WriteOptions& options, WriteBatch* updates) = 0;",74.0,74.0,18.0,76.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,Status
1883,65521,Get,1,leveldb.DB.Get,"Status leveldb.DB.Get (ReadOptions,Slice,ANY*)",include\leveldb\db.hpp,"virtual Status Get(const ReadOptions& options,
                     const Slice& key, std::string* value) = 0;",83.0,84.0,18.0,62.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,Status
1884,65528,NewIterator,1,leveldb.DB.NewIterator,Iterator* leveldb.DB.NewIterator (ReadOptions),include\leveldb\db.hpp,virtual Iterator* NewIterator(const ReadOptions& options) = 0;,92.0,92.0,19.0,63.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,Iterator*
1885,65533,GetSnapshot,1,leveldb.DB.GetSnapshot,Snapshot* leveldb.DB.GetSnapshot (),include\leveldb\db.hpp,virtual const Snapshot* GetSnapshot() = 0;,98.0,98.0,25.0,43.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,Snapshot*
1886,65537,ReleaseSnapshot,1,leveldb.DB.ReleaseSnapshot,void leveldb.DB.ReleaseSnapshot (Snapshot*),include\leveldb\db.hpp,virtual void ReleaseSnapshot(const Snapshot* snapshot) = 0;,102.0,102.0,16.0,60.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
1887,65542,GetProperty,1,leveldb.DB.GetProperty,"bool leveldb.DB.GetProperty (Slice,ANY*)",include\leveldb\db.hpp,"virtual bool GetProperty(const Slice& property, std::string* value) = 0;",120.0,120.0,16.0,73.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,bool
1888,65548,GetApproximateSizes,1,leveldb.DB.GetApproximateSizes,"void leveldb.DB.GetApproximateSizes (Range*,int,uint64_t*)",include\leveldb\db.hpp,"virtual void GetApproximateSizes(const Range* range, int n,
                                   uint64_t* sizes) = 0;",130.0,131.0,16.0,55.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,void
1889,65555,CompactRange,1,leveldb.DB.CompactRange,"void leveldb.DB.CompactRange (Slice*,Slice*)",include\leveldb\db.hpp,"virtual void CompactRange(const Slice* begin, const Slice* end) = 0;",143.0,143.0,16.0,69.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
1890,65566,operator =,1,leveldb.DB.operator =,void leveldb.DB.operator = (DB),include\leveldb\db.hpp,void operator=(const DB&);,148.0,148.0,8.0,27.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
1891,65625,Env,1,leveldb.Env.Env,ANY leveldb.Env.Env (),include\leveldb\env.hpp,Env() { },33.0,33.0,3.0,11.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
1892,65629,~Env,1,leveldb.Env.~Env,virtual leveldb.Env.~Env (),util\env.cc,"Env::~Env() {
}",9.0,10.0,1.0,1.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
1893,65633,Default,1,leveldb.Env.Default,Env* leveldb.Env.Default (),util\env_posix.cc,"Env* Env::Default() {
  pthread_once(&once, InitDefaultEnv);
  return default_env;
}",690.0,693.0,1.0,1.0,4.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,Env
1894,65637,NewSequentialFile,1,leveldb.Env.NewSequentialFile,"Status leveldb.Env.NewSequentialFile (ANY,SequentialFile**)",include\leveldb\env.hpp,"virtual Status NewSequentialFile(const std::string& fname,
                                   SequentialFile** result) = 0;",49.0,50.0,18.0,63.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,Status
1895,65643,NewRandomAccessFile,1,leveldb.Env.NewRandomAccessFile,"Status leveldb.Env.NewRandomAccessFile (ANY,RandomAccessFile**)",include\leveldb\env.hpp,"virtual Status NewRandomAccessFile(const std::string& fname,
                                     RandomAccessFile** result) = 0;",59.0,60.0,18.0,67.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,Status
1896,65649,NewWritableFile,1,leveldb.Env.NewWritableFile,"Status leveldb.Env.NewWritableFile (ANY,WritableFile**)",include\leveldb\env.hpp,"virtual Status NewWritableFile(const std::string& fname,
                                 WritableFile** result) = 0;",69.0,70.0,18.0,59.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,Status
1897,65655,NewAppendableFile,1,leveldb.Env.NewAppendableFile,"Status leveldb.Env.NewAppendableFile (ANY,WritableFile**)",util\env.cc,"Status Env::NewAppendableFile(const std::string& fname, WritableFile** result) {
  return Status::NotSupported(""NewAppendableFile"", fname);
}",12.0,14.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,Status
1898,65661,FileExists,1,leveldb.Env.FileExists,bool leveldb.Env.FileExists (ANY),include\leveldb\env.hpp,virtual bool FileExists(const std::string& fname) = 0;,88.0,88.0,16.0,55.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,bool
1899,65666,GetChildren,1,leveldb.Env.GetChildren,"Status leveldb.Env.GetChildren (ANY,ANY*)",include\leveldb\env.hpp,"virtual Status GetChildren(const std::string& dir,
                             std::vector<std::string>* result) = 0;",93.0,94.0,18.0,66.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,Status
1900,65672,DeleteFile,1,leveldb.Env.DeleteFile,Status leveldb.Env.DeleteFile (ANY),include\leveldb\env.hpp,virtual Status DeleteFile(const std::string& fname) = 0;,97.0,97.0,18.0,57.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,Status
1901,65677,CreateDir,1,leveldb.Env.CreateDir,Status leveldb.Env.CreateDir (ANY),include\leveldb\env.hpp,virtual Status CreateDir(const std::string& dirname) = 0;,100.0,100.0,18.0,58.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,Status
1902,65682,DeleteDir,1,leveldb.Env.DeleteDir,Status leveldb.Env.DeleteDir (ANY),include\leveldb\env.hpp,virtual Status DeleteDir(const std::string& dirname) = 0;,103.0,103.0,18.0,58.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,Status
1903,65687,GetFileSize,1,leveldb.Env.GetFileSize,"Status leveldb.Env.GetFileSize (ANY,uint64_t*)",include\leveldb\env.hpp,"virtual Status GetFileSize(const std::string& fname, uint64_t* file_size) = 0;",106.0,106.0,18.0,79.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,Status
1904,65693,RenameFile,1,leveldb.Env.RenameFile,"Status leveldb.Env.RenameFile (ANY,ANY)",include\leveldb\env.hpp,"virtual Status RenameFile(const std::string& src,
                            const std::string& target) = 0;",109.0,110.0,18.0,58.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,Status
1905,65699,LockFile,1,leveldb.Env.LockFile,"Status leveldb.Env.LockFile (ANY,FileLock**)",include\leveldb\env.hpp,"virtual Status LockFile(const std::string& fname, FileLock** lock) = 0;",126.0,126.0,18.0,72.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,Status
1906,65705,UnlockFile,1,leveldb.Env.UnlockFile,Status leveldb.Env.UnlockFile (FileLock*),include\leveldb\env.hpp,virtual Status UnlockFile(FileLock* lock) = 0;,131.0,131.0,18.0,47.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,Status
1907,65710,Schedule,1,leveldb.Env.Schedule,"void leveldb.Env.Schedule (void,void*)",include\leveldb\env.hpp,"virtual void Schedule(
      void (*function)(void* arg),
      void* arg) = 0;",139.0,141.0,16.0,20.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
1908,65716,StartThread,1,leveldb.Env.StartThread,"void leveldb.Env.StartThread (void,void*)",include\leveldb\env.hpp,"virtual void StartThread(void (*function)(void* arg), void* arg) = 0;",145.0,145.0,16.0,70.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
1909,65722,GetTestDirectory,1,leveldb.Env.GetTestDirectory,Status leveldb.Env.GetTestDirectory (ANY*),include\leveldb\env.hpp,virtual Status GetTestDirectory(std::string* path) = 0;,151.0,151.0,18.0,56.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,Status
1910,65727,NewLogger,1,leveldb.Env.NewLogger,"Status leveldb.Env.NewLogger (ANY,Logger**)",include\leveldb\env.hpp,"virtual Status NewLogger(const std::string& fname, Logger** result) = 0;",154.0,154.0,18.0,73.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,Status
1911,65733,NowMicros,1,leveldb.Env.NowMicros,uint64_t leveldb.Env.NowMicros (),include\leveldb\env.hpp,virtual uint64_t NowMicros() = 0;,158.0,158.0,20.0,34.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,uint64_t
1912,65737,SleepForMicroseconds,1,leveldb.Env.SleepForMicroseconds,void leveldb.Env.SleepForMicroseconds (int),include\leveldb\env.hpp,virtual void SleepForMicroseconds(int micros) = 0;,161.0,161.0,16.0,51.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
1913,65747,operator =,1,leveldb.Env.operator =,void leveldb.Env.operator = (Env),include\leveldb\env.hpp,void operator=(const Env&);,166.0,166.0,8.0,28.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
1914,65753,SequentialFile,1,leveldb.SequentialFile.SequentialFile,ANY leveldb.SequentialFile.SequentialFile (),include\leveldb\env.hpp,SequentialFile() { },172.0,172.0,3.0,22.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
1915,65757,~SequentialFile,1,leveldb.SequentialFile.~SequentialFile,virtual leveldb.SequentialFile.~SequentialFile (),util\env.cc,"SequentialFile::~SequentialFile() {
}",16.0,17.0,1.0,1.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
1916,65761,Read,1,leveldb.SequentialFile.Read,"Status leveldb.SequentialFile.Read (size_t,Slice*,char*)",include\leveldb\env.hpp,"virtual Status Read(size_t n, Slice* result, char* scratch) = 0;",183.0,183.0,18.0,65.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,Status
1917,65768,Skip,1,leveldb.SequentialFile.Skip,Status leveldb.SequentialFile.Skip (uint64_t),include\leveldb\env.hpp,virtual Status Skip(uint64_t n) = 0;,192.0,192.0,18.0,37.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,Status
1918,65778,operator =,1,leveldb.SequentialFile.operator =,void leveldb.SequentialFile.operator = (SequentialFile),include\leveldb\env.hpp,void operator=(const SequentialFile&);,197.0,197.0,8.0,39.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
1919,65784,RandomAccessFile,1,leveldb.RandomAccessFile.RandomAccessFile,ANY leveldb.RandomAccessFile.RandomAccessFile (),include\leveldb\env.hpp,RandomAccessFile() { },203.0,203.0,3.0,24.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
1920,65788,~RandomAccessFile,1,leveldb.RandomAccessFile.~RandomAccessFile,virtual leveldb.RandomAccessFile.~RandomAccessFile (),util\env.cc,"RandomAccessFile::~RandomAccessFile() {
}",19.0,20.0,1.0,1.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
1921,65792,Read,1,leveldb.RandomAccessFile.Read,"Status leveldb.RandomAccessFile.Read (uint64_t,size_t,Slice*,char*)",include\leveldb\env.hpp,"virtual Status Read(uint64_t offset, size_t n, Slice* result,
                      char* scratch) const = 0;",215.0,216.0,18.0,46.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,Status
1922,65805,operator =,1,leveldb.RandomAccessFile.operator =,void leveldb.RandomAccessFile.operator = (RandomAccessFile),include\leveldb\env.hpp,void operator=(const RandomAccessFile&);,221.0,221.0,8.0,41.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
1923,65811,WritableFile,1,leveldb.WritableFile.WritableFile,ANY leveldb.WritableFile.WritableFile (),include\leveldb\env.hpp,WritableFile() { },229.0,229.0,3.0,20.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
1924,65815,~WritableFile,1,leveldb.WritableFile.~WritableFile,virtual leveldb.WritableFile.~WritableFile (),util\env.cc,"WritableFile::~WritableFile() {
}",22.0,23.0,1.0,1.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
1925,65819,Append,1,leveldb.WritableFile.Append,Status leveldb.WritableFile.Append (Slice),include\leveldb\env.hpp,virtual Status Append(const Slice& data) = 0;,232.0,232.0,18.0,46.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,Status
1926,65824,Close,1,leveldb.WritableFile.Close,Status leveldb.WritableFile.Close (),include\leveldb\env.hpp,virtual Status Close() = 0;,233.0,233.0,18.0,28.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,Status
1927,65828,Flush,1,leveldb.WritableFile.Flush,Status leveldb.WritableFile.Flush (),include\leveldb\env.hpp,virtual Status Flush() = 0;,234.0,234.0,18.0,28.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,Status
1928,65832,Sync,1,leveldb.WritableFile.Sync,Status leveldb.WritableFile.Sync (),include\leveldb\env.hpp,virtual Status Sync() = 0;,235.0,235.0,18.0,27.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,Status
1929,65841,operator =,1,leveldb.WritableFile.operator =,void leveldb.WritableFile.operator = (WritableFile),include\leveldb\env.hpp,void operator=(const WritableFile&);,240.0,240.0,8.0,37.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
1930,65847,Logger,1,leveldb.Logger.Logger,ANY leveldb.Logger.Logger (),include\leveldb\env.hpp,Logger() { },246.0,246.0,3.0,14.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
1931,65851,~Logger,1,leveldb.Logger.~Logger,virtual leveldb.Logger.~Logger (),util\env.cc,"Logger::~Logger() {
}",25.0,26.0,1.0,1.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
1932,65855,Logv,1,leveldb.Logger.Logv,"void leveldb.Logger.Logv (char*,va_list)",include\leveldb\env.hpp,"virtual void Logv(const char* format, va_list ap) = 0;",250.0,250.0,16.0,55.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
1933,65866,operator =,1,leveldb.Logger.operator =,void leveldb.Logger.operator = (Logger),include\leveldb\env.hpp,void operator=(const Logger&);,255.0,255.0,8.0,31.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
1934,65872,FileLock,1,leveldb.FileLock.FileLock,ANY leveldb.FileLock.FileLock (),include\leveldb\env.hpp,FileLock() { },262.0,262.0,3.0,16.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
1935,65876,~FileLock,1,leveldb.FileLock.~FileLock,virtual leveldb.FileLock.~FileLock (),util\env.cc,"FileLock::~FileLock() {
}",28.0,29.0,1.0,1.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
1936,65885,operator =,1,leveldb.FileLock.operator =,void leveldb.FileLock.operator = (FileLock),include\leveldb\env.hpp,void operator=(const FileLock&);,267.0,267.0,8.0,33.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
1937,65890,Log,1,leveldb.Log,"void leveldb.Log (Logger*,char*...)",util\env.cc,"void Log(Logger* info_log, const char* format, ...) {
  if (info_log != NULL) {
    va_list ap;
    va_start(ap, format);
    info_log->Logv(format, ap);
    va_end(ap);
  }
}",31.0,38.0,1.0,1.0,8.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
1938,65896,WriteStringToFile,1,leveldb.WriteStringToFile,"Status leveldb.WriteStringToFile (Env*,Slice,ANY)",util\env.cc,"Status WriteStringToFile(Env* env, const Slice& data,
                         const std::string& fname) {
  return DoWriteStringToFile(env, data, fname, false);
}",62.0,65.0,1.0,1.0,4.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,Status
1939,65903,ReadFileToString,1,leveldb.ReadFileToString,"Status leveldb.ReadFileToString (Env*,ANY,ANY*)",util\env.cc,"Status ReadFileToString(Env* env, const std::string& fname, std::string* data) {
  data->clear();
  SequentialFile* file;
  Status s = env->NewSequentialFile(fname, &file);
  if (!s.ok()) {
    return s;
  }
  static const int kBufferSize = 8192;
  char* space = new char[kBufferSize];
  while (true) {
    Slice fragment;
    s = file->Read(kBufferSize, &fragment, space);
    if (!s.ok()) {
      break;
    }
    data->append(fragment.data(), fragment.size());
    if (fragment.empty()) {
      break;
    }
  }
  delete[] space;
  delete file;
  return s;
}",72.0,95.0,1.0,1.0,24.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,Status
1940,65911,EnvWrapper,1,leveldb.EnvWrapper.EnvWrapper,ANY leveldb.EnvWrapper.EnvWrapper (Env*),include\leveldb\env.hpp,explicit EnvWrapper(Env* t) : target_(t) { },291.0,291.0,3.0,46.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
1941,65916,~EnvWrapper,1,leveldb.EnvWrapper.~EnvWrapper,virtual leveldb.EnvWrapper.~EnvWrapper (),util\env.cc,"EnvWrapper::~EnvWrapper() {
}",97.0,98.0,1.0,1.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
1942,65920,target,1,leveldb.EnvWrapper.target,Env leveldb.EnvWrapper.target (),include\leveldb\env.hpp,Env* target() const { return target_; },295.0,295.0,3.0,41.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,Env
1943,65926,NewSequentialFile,1,leveldb.EnvWrapper.NewSequentialFile,"Status leveldb.EnvWrapper.NewSequentialFile (ANY,SequentialFile**)",include\leveldb\env.hpp,"Status NewSequentialFile(const std::string& f, SequentialFile** r) {
    return target_->NewSequentialFile(f, r);
  }",298.0,300.0,3.0,3.0,3.0,1,1,3,3,0,1,1,1,0,0,,0,1,4,2,2,Status
1944,65939,NewRandomAccessFile,1,leveldb.EnvWrapper.NewRandomAccessFile,"Status leveldb.EnvWrapper.NewRandomAccessFile (ANY,RandomAccessFile**)",include\leveldb\env.hpp,"Status NewRandomAccessFile(const std::string& f, RandomAccessFile** r) {
    return target_->NewRandomAccessFile(f, r);
  }",301.0,303.0,3.0,3.0,3.0,1,1,3,3,0,1,1,1,0,0,,0,1,4,2,2,Status
1945,65952,NewWritableFile,1,leveldb.EnvWrapper.NewWritableFile,"Status leveldb.EnvWrapper.NewWritableFile (ANY,WritableFile**)",include\leveldb\env.hpp,"Status NewWritableFile(const std::string& f, WritableFile** r) {
    return target_->NewWritableFile(f, r);
  }",304.0,306.0,3.0,3.0,3.0,1,1,3,3,0,1,1,1,0,0,,0,1,4,2,2,Status
1946,65965,NewAppendableFile,1,leveldb.EnvWrapper.NewAppendableFile,"Status leveldb.EnvWrapper.NewAppendableFile (ANY,WritableFile**)",include\leveldb\env.hpp,"Status NewAppendableFile(const std::string& f, WritableFile** r) {
    return target_->NewAppendableFile(f, r);
  }",307.0,309.0,3.0,3.0,3.0,1,1,3,3,0,1,1,1,0,0,,0,1,4,2,2,Status
1947,65978,FileExists,1,leveldb.EnvWrapper.FileExists,bool leveldb.EnvWrapper.FileExists (ANY),include\leveldb\env.hpp,bool FileExists(const std::string& f) { return target_->FileExists(f); },310.0,310.0,3.0,74.0,1.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,bool
1948,65989,GetChildren,1,leveldb.EnvWrapper.GetChildren,"Status leveldb.EnvWrapper.GetChildren (ANY,ANY*)",include\leveldb\env.hpp,"Status GetChildren(const std::string& dir, std::vector<std::string>* r) {
    return target_->GetChildren(dir, r);
  }",311.0,313.0,3.0,3.0,3.0,1,1,3,3,0,1,1,1,0,0,,0,1,4,2,2,Status
1949,66002,DeleteFile,1,leveldb.EnvWrapper.DeleteFile,Status leveldb.EnvWrapper.DeleteFile (ANY),include\leveldb\env.hpp,Status DeleteFile(const std::string& f) { return target_->DeleteFile(f); },314.0,314.0,3.0,76.0,1.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,Status
1950,66013,CreateDir,1,leveldb.EnvWrapper.CreateDir,Status leveldb.EnvWrapper.CreateDir (ANY),include\leveldb\env.hpp,Status CreateDir(const std::string& d) { return target_->CreateDir(d); },315.0,315.0,3.0,74.0,1.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,Status
1951,66024,DeleteDir,1,leveldb.EnvWrapper.DeleteDir,Status leveldb.EnvWrapper.DeleteDir (ANY),include\leveldb\env.hpp,Status DeleteDir(const std::string& d) { return target_->DeleteDir(d); },316.0,316.0,3.0,74.0,1.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,Status
1952,66035,GetFileSize,1,leveldb.EnvWrapper.GetFileSize,"Status leveldb.EnvWrapper.GetFileSize (ANY,uint64_t*)",include\leveldb\env.hpp,"Status GetFileSize(const std::string& f, uint64_t* s) {
    return target_->GetFileSize(f, s);
  }",317.0,319.0,3.0,3.0,3.0,1,1,3,3,0,1,1,1,0,0,,0,1,4,2,2,Status
1953,66048,RenameFile,1,leveldb.EnvWrapper.RenameFile,"Status leveldb.EnvWrapper.RenameFile (ANY,ANY)",include\leveldb\env.hpp,"Status RenameFile(const std::string& s, const std::string& t) {
    return target_->RenameFile(s, t);
  }",320.0,322.0,3.0,3.0,3.0,1,1,3,3,0,1,1,1,0,0,,0,1,4,2,2,Status
1954,66061,LockFile,1,leveldb.EnvWrapper.LockFile,"Status leveldb.EnvWrapper.LockFile (ANY,FileLock**)",include\leveldb\env.hpp,"Status LockFile(const std::string& f, FileLock** l) {
    return target_->LockFile(f, l);
  }",323.0,325.0,3.0,3.0,3.0,1,1,3,3,0,1,1,1,0,0,,0,1,4,2,2,Status
1955,66074,UnlockFile,1,leveldb.EnvWrapper.UnlockFile,Status leveldb.EnvWrapper.UnlockFile (FileLock*),include\leveldb\env.hpp,Status UnlockFile(FileLock* l) { return target_->UnlockFile(l); },326.0,326.0,3.0,67.0,1.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,Status
1956,66085,Schedule,1,leveldb.EnvWrapper.Schedule,"void leveldb.EnvWrapper.Schedule (void,void*)",include\leveldb\env.hpp,"void Schedule(void (*f)(void*), void* a) {
    return target_->Schedule(f, a);
  }",327.0,329.0,3.0,3.0,3.0,1,1,3,3,0,1,1,1,0,0,,0,1,4,2,2,void
1957,66098,StartThread,1,leveldb.EnvWrapper.StartThread,"void leveldb.EnvWrapper.StartThread (void,void*)",include\leveldb\env.hpp,"void StartThread(void (*f)(void*), void* a) {
    return target_->StartThread(f, a);
  }",330.0,332.0,3.0,3.0,3.0,1,1,3,3,0,1,1,1,0,0,,0,1,4,2,2,void
1958,66111,GetTestDirectory,1,leveldb.EnvWrapper.GetTestDirectory,Status leveldb.EnvWrapper.GetTestDirectory (ANY*),include\leveldb\env.hpp,"virtual Status GetTestDirectory(std::string* path) {
    return target_->GetTestDirectory(path);
  }",333.0,335.0,3.0,3.0,3.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,Status
1959,66122,NewLogger,1,leveldb.EnvWrapper.NewLogger,"Status leveldb.EnvWrapper.NewLogger (ANY,Logger**)",include\leveldb\env.hpp,"virtual Status NewLogger(const std::string& fname, Logger** result) {
    return target_->NewLogger(fname, result);
  }",336.0,338.0,3.0,3.0,3.0,1,1,3,3,0,1,1,1,0,0,,0,1,4,2,2,Status
1960,66135,NowMicros,1,leveldb.EnvWrapper.NowMicros,uint64_t leveldb.EnvWrapper.NowMicros (),include\leveldb\env.hpp,"uint64_t NowMicros() {
    return target_->NowMicros();
  }",339.0,341.0,3.0,3.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,uint64_t
1961,66144,SleepForMicroseconds,1,leveldb.EnvWrapper.SleepForMicroseconds,void leveldb.EnvWrapper.SleepForMicroseconds (int),include\leveldb\env.hpp,"void SleepForMicroseconds(int micros) {
    target_->SleepForMicroseconds(micros);
  }",342.0,344.0,3.0,3.0,3.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
1962,66165,~FilterPolicy,1,leveldb.FilterPolicy.~FilterPolicy,virtual leveldb.FilterPolicy.~FilterPolicy (),util\filter_policy.cc,FilterPolicy::~FilterPolicy() { },9.0,9.0,1.0,33.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
1963,66169,Name,1,leveldb.FilterPolicy.Name,char* leveldb.FilterPolicy.Name (),include\leveldb\filter_policy.hpp,virtual const char* Name() const = 0;,33.0,33.0,21.0,38.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,char*
1964,66173,CreateFilter,1,leveldb.FilterPolicy.CreateFilter,"void leveldb.FilterPolicy.CreateFilter (Slice*,int,ANY*)",include\leveldb\filter_policy.hpp,"virtual void CreateFilter(const Slice* keys, int n, std::string* dst)
      const = 0;",41.0,42.0,16.0,15.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,void
1965,66180,KeyMayMatch,1,leveldb.FilterPolicy.KeyMayMatch,"bool leveldb.FilterPolicy.KeyMayMatch (Slice,Slice)",include\leveldb\filter_policy.hpp,"virtual bool KeyMayMatch(const Slice& key, const Slice& filter) const = 0;",49.0,49.0,16.0,75.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,bool
1966,66186,NewBloomFilterPolicy,1,leveldb.NewBloomFilterPolicy,FilterPolicy* leveldb.NewBloomFilterPolicy (int),util\bloom.cc,"const FilterPolicy* NewBloomFilterPolicy(int bits_per_key) {
  return new BloomFilterPolicy(bits_per_key);
}",91.0,93.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,FilterPolicy
1967,66202,Iterator,1,leveldb.Iterator.Iterator,ANY leveldb.Iterator.Iterator (),table\iterator.cc,"Iterator::Iterator() {
  cleanup_.function = NULL;
  cleanup_.next = NULL;
}",9.0,12.0,1.0,1.0,4.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
1968,66206,~Iterator,1,leveldb.Iterator.~Iterator,virtual leveldb.Iterator.~Iterator (),table\iterator.cc,"Iterator::~Iterator() {
  if (cleanup_.function != NULL) {
    (*cleanup_.function)(cleanup_.arg1, cleanup_.arg2);
    for (Cleanup* c = cleanup_.next; c != NULL; ) {
      (*c->function)(c->arg1, c->arg2);
      Cleanup* next = c->next;
      delete c;
      c = next;
    }
  }
}",14.0,24.0,1.0,1.0,11.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
1969,66210,Valid,1,leveldb.Iterator.Valid,bool leveldb.Iterator.Valid (),include\leveldb\iterator.hpp,virtual bool Valid() const = 0;,30.0,30.0,16.0,32.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,bool
1970,66214,SeekToFirst,1,leveldb.Iterator.SeekToFirst,void leveldb.Iterator.SeekToFirst (),include\leveldb\iterator.hpp,virtual void SeekToFirst() = 0;,34.0,34.0,16.0,32.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1971,66218,SeekToLast,1,leveldb.Iterator.SeekToLast,void leveldb.Iterator.SeekToLast (),include\leveldb\iterator.hpp,virtual void SeekToLast() = 0;,38.0,38.0,16.0,31.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1972,66222,Seek,1,leveldb.Iterator.Seek,void leveldb.Iterator.Seek (Slice),include\leveldb\iterator.hpp,virtual void Seek(const Slice& target) = 0;,43.0,43.0,16.0,44.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
1973,66227,Next,1,leveldb.Iterator.Next,void leveldb.Iterator.Next (),include\leveldb\iterator.hpp,virtual void Next() = 0;,48.0,48.0,16.0,25.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1974,66231,Prev,1,leveldb.Iterator.Prev,void leveldb.Iterator.Prev (),include\leveldb\iterator.hpp,virtual void Prev() = 0;,53.0,53.0,16.0,25.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1975,66235,key,1,leveldb.Iterator.key,Slice leveldb.Iterator.key (),include\leveldb\iterator.hpp,virtual Slice key() const = 0;,59.0,59.0,17.0,31.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,Slice
1976,66239,value,1,leveldb.Iterator.value,Slice leveldb.Iterator.value (),include\leveldb\iterator.hpp,virtual Slice value() const = 0;,65.0,65.0,17.0,33.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,Slice
1977,66243,status,1,leveldb.Iterator.status,Status leveldb.Iterator.status (),include\leveldb\iterator.hpp,virtual Status status() const = 0;,68.0,68.0,18.0,35.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,Status
1978,66247,CleanupFunction,1,leveldb.Iterator.CleanupFunction,"void leveldb.Iterator.CleanupFunction (void*,void*)",include\leveldb\iterator.hpp,"typedef void (*CleanupFunction)(void* arg1, void* arg2);",75.0,75.0,16.0,57.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
1979,66253,RegisterCleanup,1,leveldb.Iterator.RegisterCleanup,"void leveldb.Iterator.RegisterCleanup (CleanupFunction,void*,void*)",table\iterator.cc,"void Iterator::RegisterCleanup(CleanupFunction func, void* arg1, void* arg2) {
  assert(func != NULL);
  Cleanup* c;
  if (cleanup_.function == NULL) {
    c = &cleanup_;
  } else {
    c = new Cleanup;
    c->next = cleanup_.next;
    cleanup_.next = c;
  }
  c->function = func;
  c->arg1 = arg1;
  c->arg2 = arg2;
}",26.0,39.0,1.0,1.0,14.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,void
1980,66271,operator =,1,leveldb.Iterator.operator =,void leveldb.Iterator.operator = (Iterator),include\leveldb\iterator.hpp,void operator=(const Iterator&);,89.0,89.0,8.0,33.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
1981,66276,NewEmptyIterator,1,leveldb.NewEmptyIterator,Iterator* leveldb.NewEmptyIterator (),table\iterator.cc,"Iterator* NewEmptyIterator() {
  return new EmptyIterator(Status::OK());
}",59.0,61.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,Iterator
1982,66280,NewErrorIterator,1,leveldb.NewErrorIterator,Iterator* leveldb.NewErrorIterator (Status),table\iterator.cc,"Iterator* NewErrorIterator(const Status& status) {
  return new EmptyIterator(status);
}",63.0,65.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,Iterator
1983,66328,Options,1,leveldb.Options.Options,ANY leveldb.Options.Options (),util\options.cc,"Options::Options()
    : comparator(BytewiseComparator()),
      create_if_missing(false),
      error_if_exists(false),
      paranoid_checks(false),
      env(Env::Default()),
      info_log(NULL),
      write_buffer_size(4<<20),
      max_open_files(1000),
      block_cache(NULL),
      block_size(4096),
      block_restart_interval(16),
      max_file_size(2<<20),
      compression(kSnappyCompression),
      reuse_logs(false),
      filter_policy(NULL) {
}",12.0,28.0,1.0,1.0,17.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
1984,66336,ReadOptions,1,leveldb.ReadOptions.ReadOptions,ANY leveldb.ReadOptions.ReadOptions (),include\leveldb\options.hpp,"ReadOptions()
      : verify_checksums(false),
        fill_cache(true),
        snapshot(NULL) {
  }",179.0,183.0,3.0,3.0,5.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
1985,66342,WriteOptions,1,leveldb.WriteOptions.WriteOptions,ANY leveldb.WriteOptions.WriteOptions (),include\leveldb\options.hpp,"WriteOptions()
      : sync(false) {
  }",206.0,208.0,3.0,3.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
1986,66361,Slice,1,leveldb.Slice.Slice,ANY leveldb.Slice.Slice (),include\leveldb\slice.hpp,"Slice(const char* s) : data_(s), size_(strlen(s)) { }",37.0,37.0,3.0,55.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
1987,66381,data,1,leveldb.Slice.data,const char* leveldb.Slice.data (),include\leveldb\slice.hpp,const char* data() const { return data_; },40.0,40.0,3.0,44.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,const char*
1988,66387,size,1,leveldb.Slice.size,size_t leveldb.Slice.size (),include\leveldb\slice.hpp,size_t size() const { return size_; },43.0,43.0,3.0,39.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,size_t
1989,66393,empty,1,leveldb.Slice.empty,bool leveldb.Slice.empty (),include\leveldb\slice.hpp,bool empty() const { return size_ == 0; },46.0,46.0,3.0,43.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,bool
1990,66401,operator [],1,leveldb.Slice.operator [],char leveldb.Slice.operator [] (size_t),include\leveldb\slice.hpp,"char operator[](size_t n) const {
    assert(n < size());
    return data_[n];
  }",50.0,53.0,3.0,3.0,4.0,2,2,3,2,0,1,1,1,0,0,,0,1,2,1,1,char
1991,66414,clear,1,leveldb.Slice.clear,void leveldb.Slice.clear (),include\leveldb\slice.hpp,"void clear() { data_ = """"; size_ = 0; }",56.0,56.0,3.0,41.0,1.0,2,1,2,2,0,2,1,1,0,0,,0,2,0,0,0,void
1992,66424,remove_prefix,1,leveldb.Slice.remove_prefix,void leveldb.Slice.remove_prefix (size_t),include\leveldb\slice.hpp,"void remove_prefix(size_t n) {
    assert(n <= size());
    data_ += n;
    size_ -= n;
  }",59.0,63.0,3.0,3.0,5.0,3,3,5,3,0,2,1,1,0,0,,0,2,2,1,1,void
1993,66439,ToString,1,leveldb.Slice.ToString,string leveldb.Slice.ToString (),include\leveldb\slice.hpp,"std::string ToString() const { return std::string(data_, size_); }",66.0,66.0,3.0,68.0,1.0,1,1,3,3,0,2,1,1,0,0,,0,2,0,0,0,string
1994,66450,compare,1,leveldb.Slice.compare,int leveldb.Slice.compare (Slice),include\leveldb\slice.hpp,"inline int Slice::compare(const Slice& b) const {
  const size_t min_len = (size_ < b.size_) ? size_ : b.size_;
  int r = memcmp(data_, b.data_, min_len);
  if (r == 0) {
    if (size_ < b.size_) r = -1;
    else if (size_ > b.size_) r = +1;
  }
  return r;
}",96.0,104.0,1.0,1.0,9.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
1995,66455,starts_with,1,leveldb.Slice.starts_with,bool leveldb.Slice.starts_with (Slice),include\leveldb\slice.hpp,"bool starts_with(const Slice& x) const {
    return ((size_ >= x.size_) &&
            (memcmp(data_, x.data_, x.size_) == 0));
  }",75.0,78.0,3.0,3.0,4.0,6,4,5,3,0,5,1,1,0,0,,0,5,2,1,1,bool
1996,66479,operator ==,1,leveldb.operator ==,"bool leveldb.operator == (Slice,Slice)",include\leveldb\slice.hpp,"inline bool operator==(const Slice& x, const Slice& y) {
  return ((x.size() == y.size()) &&
          (memcmp(x.data(), y.data(), x.size()) == 0));
}",87.0,90.0,1.0,1.0,4.0,8,3,5,2,0,0,1,1,0,0,,0,0,4,2,2,bool
1997,66511,operator !=,1,leveldb.operator !=,"bool leveldb.operator != (Slice,Slice)",include\leveldb\slice.hpp,"inline bool operator!=(const Slice& x, const Slice& y) {
  return !(x == y);
}",92.0,94.0,1.0,1.0,3.0,2,2,2,2,0,0,1,1,0,0,,0,0,4,2,2,bool
1998,66591,Status,1,leveldb.Status.Status,ANY leveldb.Status.Status (),util\status.cc,"Status::Status(Code code, const Slice& msg, const Slice& msg2) {
  assert(code != kOk);
  const uint32_t len1 = msg.size();
  const uint32_t len2 = msg2.size();
  const uint32_t size = len1 + (len2 ? (2 + len2) : 0);
  char* result = new char[size + 5];
  memcpy(result, &size, sizeof(size));
  result[4] = static_cast<char>(code);
  memcpy(result + 5, msg.data(), len1);
  if (len2) {
    result[5 + len1] = ':';
    result[6 + len1] = ' ';
    memcpy(result + 7 + len1, msg2.data(), len2);
  }
  state_ = result;
}",19.0,34.0,1.0,1.0,16.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,ANY
1999,66595,~Status,1,leveldb.Status.~Status,ANY leveldb.Status.~Status (),include\leveldb\status.hpp,~Status() { delete[] state_; },25.0,25.0,3.0,32.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,ANY
2000,66606,operator =,1,leveldb.Status.operator =,void leveldb.Status.operator = (Status),include\leveldb\status.hpp,"inline void Status::operator=(const Status& s) {
  // The following condition catches both aliasing (when this == &s),
  // and the common case where both s and *this are ok.
  if (state_ != s.state_) {
    delete[] state_;
    state_ = (s.state_ == NULL) ? NULL : CopyState(s.state_);
  }
}",101.0,108.0,1.0,1.0,8.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
2001,66611,OK,1,leveldb.Status.OK,Status leveldb.Status.OK (),include\leveldb\status.hpp,static Status OK() { return Status(); },32.0,32.0,3.0,41.0,1.0,0,0,0,0,57,0,1,1,0,0,,0,0,0,0,0,Status
2002,66617,NotFound,1,leveldb.Status.NotFound,"Status leveldb.Status.NotFound (Slice,Slice)",include\leveldb\status.hpp,"static Status NotFound(const Slice& msg, const Slice& msg2 = Slice()) {
    return Status(kNotFound, msg, msg2);
  }",35.0,37.0,3.0,3.0,3.0,0,0,3,3,5,1,1,1,0,0,,0,1,4,2,2,Status
2003,66628,Corruption,1,leveldb.Status.Corruption,"Status leveldb.Status.Corruption (Slice,Slice)",include\leveldb\status.hpp,"static Status Corruption(const Slice& msg, const Slice& msg2 = Slice()) {
    return Status(kCorruption, msg, msg2);
  }",38.0,40.0,3.0,3.0,3.0,0,0,3,3,22,1,1,1,0,0,,0,1,4,2,2,Status
2004,66639,NotSupported,1,leveldb.Status.NotSupported,"Status leveldb.Status.NotSupported (Slice,Slice)",include\leveldb\status.hpp,"static Status NotSupported(const Slice& msg, const Slice& msg2 = Slice()) {
    return Status(kNotSupported, msg, msg2);
  }",41.0,43.0,3.0,3.0,3.0,0,0,3,3,0,1,1,1,0,0,,0,1,4,2,2,Status
2005,66650,InvalidArgument,1,leveldb.Status.InvalidArgument,"Status leveldb.Status.InvalidArgument (Slice,Slice)",include\leveldb\status.hpp,"static Status InvalidArgument(const Slice& msg, const Slice& msg2 = Slice()) {
    return Status(kInvalidArgument, msg, msg2);
  }",44.0,46.0,3.0,3.0,3.0,0,0,3,3,4,1,1,1,0,0,,0,1,4,2,2,Status
2006,66661,IOError,1,leveldb.Status.IOError,"Status leveldb.Status.IOError (Slice,Slice)",include\leveldb\status.hpp,"static Status IOError(const Slice& msg, const Slice& msg2 = Slice()) {
    return Status(kIOError, msg, msg2);
  }",47.0,49.0,3.0,3.0,3.0,0,0,3,3,13,1,1,1,0,0,,0,1,4,2,2,Status
2007,66672,ok,1,leveldb.Status.ok,bool leveldb.Status.ok (),include\leveldb\status.hpp,bool ok() const { return (state_ == NULL); },52.0,52.0,3.0,46.0,1.0,1,1,2,2,0,1,1,1,0,0,,0,1,0,0,0,bool
2008,66680,IsNotFound,1,leveldb.Status.IsNotFound,bool leveldb.Status.IsNotFound (),include\leveldb\status.hpp,bool IsNotFound() const { return code() == kNotFound; },55.0,55.0,3.0,57.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,bool
2009,66688,IsCorruption,1,leveldb.Status.IsCorruption,bool leveldb.Status.IsCorruption (),include\leveldb\status.hpp,bool IsCorruption() const { return code() == kCorruption; },58.0,58.0,3.0,61.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,bool
2010,66696,IsIOError,1,leveldb.Status.IsIOError,bool leveldb.Status.IsIOError (),include\leveldb\status.hpp,bool IsIOError() const { return code() == kIOError; },61.0,61.0,3.0,55.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,bool
2011,66704,IsNotSupportedError,1,leveldb.Status.IsNotSupportedError,bool leveldb.Status.IsNotSupportedError (),include\leveldb\status.hpp,bool IsNotSupportedError() const { return code() == kNotSupported; },64.0,64.0,3.0,70.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,bool
2012,66712,IsInvalidArgument,1,leveldb.Status.IsInvalidArgument,bool leveldb.Status.IsInvalidArgument (),include\leveldb\status.hpp,bool IsInvalidArgument() const { return code() == kInvalidArgument; },67.0,67.0,3.0,71.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,bool
2013,66720,ToString,1,leveldb.Status.ToString,ANY leveldb.Status.ToString (),util\status.cc,"std::string Status::ToString() const {
  if (state_ == NULL) {
    return ""OK"";
  } else {
    char tmp[30];
    const char* type;
    switch (code()) {
      case kOk:
        type = ""OK"";
        break;
      case kNotFound:
        type = ""NotFound: "";
        break;
      case kCorruption:
        type = ""Corruption: "";
        break;
      case kNotSupported:
        type = ""Not implemented: "";
        break;
      case kInvalidArgument:
        type = ""Invalid argument: "";
        break;
      case kIOError:
        type = ""IO error: "";
        break;
      default:
        snprintf(tmp, sizeof(tmp), ""Unknown code(%d): "",
                 static_cast<int>(code()));
        type = tmp;
        break;
    }
    std::string result(type);
    uint32_t length;
    memcpy(&length, state_, sizeof(length));
    result.append(state_ + 5, length);
    return result;
  }
}",36.0,73.0,1.0,1.0,38.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,string
2014,66754,code,1,leveldb.Status.code,Code leveldb.Status.code (),include\leveldb\status.hpp,"Code code() const {
    return (state_ == NULL) ? kOk : static_cast<Code>(state_[4]);
  }",90.0,92.0,3.0,3.0,3.0,4,4,4,3,0,3,1,1,0,0,,0,3,0,0,0,Code
2015,66776,CopyState,1,leveldb.Status.CopyState,char* leveldb.Status.CopyState (char*),util\status.cc,"const char* Status::CopyState(const char* state) {
  uint32_t size;
  memcpy(&size, state, sizeof(size));
  char* result = new char[size + 5];
  memcpy(result, state, size + 5);
  return result;
}",11.0,17.0,1.0,1.0,7.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,const char*
2016,66844,Open,1,leveldb.Table.Open,"Status leveldb.Table.Open (Options,RandomAccessFile*,uint64_t,Table**)",table\table.cc,"Status Table::Open(const Options& options,
                   RandomAccessFile* file,
                   uint64_t size,
                   Table** table) {
  *table = NULL;
  if (size < Footer::kEncodedLength) {
    return Status::Corruption(""file is too short to be an sstable"");
  }

  char footer_space[Footer::kEncodedLength];
  Slice footer_input;
  Status s = file->Read(size - Footer::kEncodedLength, Footer::kEncodedLength,
                        &footer_input, footer_space);
  if (!s.ok()) return s;

  Footer footer;
  s = footer.DecodeFrom(&footer_input);
  if (!s.ok()) return s;

  // Read the index block
  BlockContents contents;
  Block* index_block = NULL;
  if (s.ok()) {
    ReadOptions opt;
    if (options.paranoid_checks) {
      opt.verify_checksums = true;
    }
    s = ReadBlock(file, opt, footer.index_handle(), &contents);
    if (s.ok()) {
      index_block = new Block(contents);
    }
  }

  if (s.ok()) {
    // We've successfully read the footer and the index bl...",38.0,89.0,1.0,1.0,52.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,Status
2017,66852,~Table,1,leveldb.Table.~Table,ANY leveldb.Table.~Table (),table\table.cc,"Table::~Table() {
  delete rep_;
}",143.0,145.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
2018,66856,NewIterator,1,leveldb.Table.NewIterator,Iterator* leveldb.Table.NewIterator (ReadOptions),table\table.cc,"Iterator* Table::NewIterator(const ReadOptions& options) const {
  return NewTwoLevelIterator(
      rep_->index_block->NewIterator(rep_->options.comparator),
      &Table::BlockReader, const_cast<Table*>(this), options);
}",220.0,224.0,1.0,1.0,5.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,Iterator
2019,66861,ApproximateOffsetOf,1,leveldb.Table.ApproximateOffsetOf,uint64_t leveldb.Table.ApproximateOffsetOf (Slice),table\table.cc,"uint64_t Table::ApproximateOffsetOf(const Slice& key) const {
  Iterator* index_iter =
      rep_->index_block->NewIterator(rep_->options.comparator);
  index_iter->Seek(key);
  uint64_t result;
  if (index_iter->Valid()) {
    BlockHandle handle;
    Slice input = index_iter->value();
    Status s = handle.DecodeFrom(&input);
    if (s.ok()) {
      result = handle.offset();
    } else {
      // Strange: we can't decode the block handle in the index block.
      // We'll just return the offset of the metaindex block, which is
      // close to the whole file size for this case.
      result = rep_->metaindex_handle.offset();
    }
  } else {
    // key is past the last key in the file.  Approximate the offset
    // by returning the offset of the metaindex block (which is
    // right near the end of the file).
    result = rep_->metaindex_handle.offset();
  }
  delete index_iter;
  return result;
}",258.0,283.0,1.0,1.0,26.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,uint64_t
2020,66868,Table,1,leveldb.Table.Table,ANY leveldb.Table.Table (Rep*),include\leveldb\table.hpp,explicit Table(Rep* rep) { rep_ = rep; },62.0,62.0,3.0,42.0,1.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,ANY
2021,66876,BlockReader,1,leveldb.Table.BlockReader,"Iterator* leveldb.Table.BlockReader (void*,ReadOptions,Slice)",table\table.cc,"Iterator* Table::BlockReader(void* arg,
                             const ReadOptions& options,
                             const Slice& index_value) {
  Table* table = reinterpret_cast<Table*>(arg);
  Cache* block_cache = table->rep_->options.block_cache;
  Block* block = NULL;
  Cache::Handle* cache_handle = NULL;

  BlockHandle handle;
  Slice input = index_value;
  Status s = handle.DecodeFrom(&input);
  // We intentionally allow extra stuff in index_value so that we
  // can add more features in the future.

  if (s.ok()) {
    BlockContents contents;
    if (block_cache != NULL) {
      char cache_key_buffer[16];
      EncodeFixed64(cache_key_buffer, table->rep_->cache_id);
      EncodeFixed64(cache_key_buffer+8, handle.offset());
      Slice key(cache_key_buffer, sizeof(cache_key_buffer));
      cache_handle = block_cache->Lookup(key);
      if (cache_handle != NULL) {
        block = reinterpret_cast<Block*>(block_cache->Value(cache_handle));
      } else {
        s = Rea...",164.0,218.0,1.0,1.0,55.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,Iterator
2022,66884,InternalGet,1,leveldb.Table.InternalGet,"Status leveldb.Table.InternalGet (ReadOptions,Slice,void*,void)",table\table.cc,"Status Table::InternalGet(const ReadOptions& options, const Slice& k,
                          void* arg,
                          void (*saver)(void*, const Slice&, const Slice&)) {
  Status s;
  Iterator* iiter = rep_->index_block->NewIterator(rep_->options.comparator);
  iiter->Seek(k);
  if (iiter->Valid()) {
    Slice handle_value = iiter->value();
    FilterBlockReader* filter = rep_->filter;
    BlockHandle handle;
    if (filter != NULL &&
        handle.DecodeFrom(&handle_value).ok() &&
        !filter->KeyMayMatch(handle.offset(), k)) {
      // Not found
    } else {
      Iterator* block_iter = BlockReader(this, options, iiter->value());
      block_iter->Seek(k);
      if (block_iter->Valid()) {
        (*saver)(arg, block_iter->key(), block_iter->value());
      }
      s = block_iter->status();
      delete block_iter;
    }
  }
  if (s.ok()) {
    s = iiter->status();
  }
  delete iiter;
  return s;
}",226.0,255.0,1.0,1.0,30.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,Status
2023,66892,ReadMeta,1,leveldb.Table.ReadMeta,void leveldb.Table.ReadMeta (Footer),table\table.cc,"void Table::ReadMeta(const Footer& footer) {
  if (rep_->options.filter_policy == NULL) {
    return;  // Do not need any metadata
  }

  // TODO(sanjay): Skip this if footer.metaindex_handle() size indicates
  // it is an empty block.
  ReadOptions opt;
  if (rep_->options.paranoid_checks) {
    opt.verify_checksums = true;
  }
  BlockContents contents;
  if (!ReadBlock(rep_->file, opt, footer.metaindex_handle(), &contents).ok()) {
    // Do not propagate errors since meta info is not needed for operation
    return;
  }
  Block* meta = new Block(contents);

  Iterator* iter = meta->NewIterator(BytewiseComparator());
  std::string key = ""filter."";
  key.append(rep_->options.filter_policy->Name());
  iter->Seek(key);
  if (iter->Valid() && iter->key() == Slice(key)) {
    ReadFilter(iter->value());
  }
  delete iter;
  delete meta;
}",91.0,118.0,1.0,1.0,28.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
2024,66897,ReadFilter,1,leveldb.Table.ReadFilter,void leveldb.Table.ReadFilter (Slice),table\table.cc,"void Table::ReadFilter(const Slice& filter_handle_value) {
  Slice v = filter_handle_value;
  BlockHandle filter_handle;
  if (!filter_handle.DecodeFrom(&v).ok()) {
    return;
  }

  // We might want to unify with ReadBlock() if we start
  // requiring checksum verification in Table::Open.
  ReadOptions opt;
  if (rep_->options.paranoid_checks) {
    opt.verify_checksums = true;
  }
  BlockContents block;
  if (!ReadBlock(rep_->file, opt, filter_handle, &block).ok()) {
    return;
  }
  if (block.heap_allocated) {
    rep_->filter_data = block.data.data();     // Will need to delete later
  }
  rep_->filter = new FilterBlockReader(rep_->options.filter_policy, block.data);
}",120.0,141.0,1.0,1.0,22.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
2025,66907,operator =,1,leveldb.Table.operator =,void leveldb.Table.operator = (Table),include\leveldb\table.hpp,void operator=(const Table&);,80.0,80.0,8.0,30.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
2026,66928,TableBuilder,1,leveldb.TableBuilder.TableBuilder,"ANY leveldb.TableBuilder.TableBuilder (Options,WritableFile*)",table\table_builder.cc,"TableBuilder::TableBuilder(const Options& options, WritableFile* file)
    : rep_(new Rep(options, file)) {
  if (rep_->filter_block != NULL) {
    rep_->filter_block->StartBlock(0);
  }
}",63.0,68.0,1.0,1.0,6.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,ANY
2027,66934,~TableBuilder,1,leveldb.TableBuilder.~TableBuilder,ANY leveldb.TableBuilder.~TableBuilder (),table\table_builder.cc,"TableBuilder::~TableBuilder() {
  assert(rep_->closed);  // Catch errors where caller forgot to call Finish()
  delete rep_->filter_block;
  delete rep_;
}",70.0,74.0,1.0,1.0,5.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
2028,66938,ChangeOptions,1,leveldb.TableBuilder.ChangeOptions,Status leveldb.TableBuilder.ChangeOptions (Options),table\table_builder.cc,"Status TableBuilder::ChangeOptions(const Options& options) {
  // Note: if more fields are added to Options, update
  // this function to catch changes that should not be allowed to
  // change in the middle of building a Table.
  if (options.comparator != rep_->options.comparator) {
    return Status::InvalidArgument(""changing comparator while building table"");
  }

  // Note that any live BlockBuilders point to rep_->options and therefore
  // will automatically pick up the updated options.
  rep_->options = options;
  rep_->index_block_options = options;
  rep_->index_block_options.block_restart_interval = 1;
  return Status::OK();
}",76.0,90.0,1.0,1.0,15.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,Status
2029,66943,Add,1,leveldb.TableBuilder.Add,"void leveldb.TableBuilder.Add (Slice,Slice)",table\table_builder.cc,"void TableBuilder::Add(const Slice& key, const Slice& value) {
  Rep* r = rep_;
  assert(!r->closed);
  if (!ok()) return;
  if (r->num_entries > 0) {
    assert(r->options.comparator->Compare(key, Slice(r->last_key)) > 0);
  }

  if (r->pending_index_entry) {
    assert(r->data_block.empty());
    r->options.comparator->FindShortestSeparator(&r->last_key, key);
    std::string handle_encoding;
    r->pending_handle.EncodeTo(&handle_encoding);
    r->index_block.Add(r->last_key, Slice(handle_encoding));
    r->pending_index_entry = false;
  }

  if (r->filter_block != NULL) {
    r->filter_block->AddKey(key);
  }

  r->last_key.assign(key.data(), key.size());
  r->num_entries++;
  r->data_block.Add(key, value);

  const size_t estimated_block_size = r->data_block.CurrentSizeEstimate();
  if (estimated_block_size >= r->options.block_size) {
    Flush();
  }
}",92.0,121.0,1.0,1.0,30.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
2030,66949,Flush,1,leveldb.TableBuilder.Flush,void leveldb.TableBuilder.Flush (),table\table_builder.cc,"void TableBuilder::Flush() {
  Rep* r = rep_;
  assert(!r->closed);
  if (!ok()) return;
  if (r->data_block.empty()) return;
  assert(!r->pending_index_entry);
  WriteBlock(&r->data_block, &r->pending_handle);
  if (ok()) {
    r->pending_index_entry = true;
    r->status = r->file->Flush();
  }
  if (r->filter_block != NULL) {
    r->filter_block->StartBlock(r->offset);
  }
}",123.0,137.0,1.0,1.0,15.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2031,66953,status,1,leveldb.TableBuilder.status,Status leveldb.TableBuilder.status (),table\table_builder.cc,"Status TableBuilder::status() const {
  return rep_->status;
}",195.0,197.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,Status
2032,66957,Finish,1,leveldb.TableBuilder.Finish,Status leveldb.TableBuilder.Finish (),table\table_builder.cc,"Status TableBuilder::Finish() {
  Rep* r = rep_;
  Flush();
  assert(!r->closed);
  r->closed = true;

  BlockHandle filter_block_handle, metaindex_block_handle, index_block_handle;

  // Write filter block
  if (ok() && r->filter_block != NULL) {
    WriteRawBlock(r->filter_block->Finish(), kNoCompression,
                  &filter_block_handle);
  }

  // Write metaindex block
  if (ok()) {
    BlockBuilder meta_index_block(&r->options);
    if (r->filter_block != NULL) {
      // Add mapping from ""filter.Name"" to location of filter data
      std::string key = ""filter."";
      key.append(r->options.filter_policy->Name());
      std::string handle_encoding;
      filter_block_handle.EncodeTo(&handle_encoding);
      meta_index_block.Add(key, handle_encoding);
    }

    // TODO(postrelease): Add stats and other meta blocks
    WriteBlock(&meta_index_block, &metaindex_block_handle);
  }

  // Write index block
  if (ok()) {
    if (r->pending_index_entry) {
      r->options.compara...",199.0,254.0,1.0,1.0,56.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,Status
2033,66961,Abandon,1,leveldb.TableBuilder.Abandon,void leveldb.TableBuilder.Abandon (),table\table_builder.cc,"void TableBuilder::Abandon() {
  Rep* r = rep_;
  assert(!r->closed);
  r->closed = true;
}",256.0,260.0,1.0,1.0,5.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2034,66965,NumEntries,1,leveldb.TableBuilder.NumEntries,uint64_t leveldb.TableBuilder.NumEntries (),table\table_builder.cc,"uint64_t TableBuilder::NumEntries() const {
  return rep_->num_entries;
}",262.0,264.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,uint64_t
2035,66969,FileSize,1,leveldb.TableBuilder.FileSize,uint64_t leveldb.TableBuilder.FileSize (),table\table_builder.cc,"uint64_t TableBuilder::FileSize() const {
  return rep_->offset;
}",266.0,268.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,uint64_t
2036,66973,ok,1,leveldb.TableBuilder.ok,bool leveldb.TableBuilder.ok (),include\leveldb\table_builder.hpp,bool ok() const { return status().ok(); },78.0,78.0,3.0,43.0,1.0,1,1,0,0,0,0,1,1,0,0,,0,0,0,0,0,bool
2037,66982,WriteBlock,1,leveldb.TableBuilder.WriteBlock,"void leveldb.TableBuilder.WriteBlock (BlockBuilder*,BlockHandle*)",table\table_builder.cc,"void TableBuilder::WriteBlock(BlockBuilder* block, BlockHandle* handle) {
  // File format contains a sequence of blocks where each block has:
  //    block_data: uint8[n]
  //    type: uint8
  //    crc: uint32
  assert(ok());
  Rep* r = rep_;
  Slice raw = block->Finish();

  Slice block_contents;
  CompressionType type = r->options.compression;
  // TODO(postrelease): Support more compression options: zlib?
  switch (type) {
    case kNoCompression:
      block_contents = raw;
      break;

    case kSnappyCompression: {
      std::string* compressed = &r->compressed_output;
      if (port::Snappy_Compress(raw.data(), raw.size(), compressed) &&
          compressed->size() < raw.size() - (raw.size() / 8u)) {
        block_contents = *compressed;
      } else {
        // Snappy not supported, or compressed less than 12.5%, so just
        // store uncompressed form
        block_contents = raw;
        type = kNoCompression;
      }
      break;
    }
  }
  WriteRawBlock(block_co...",139.0,173.0,1.0,1.0,35.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
2038,66988,WriteRawBlock,1,leveldb.TableBuilder.WriteRawBlock,"void leveldb.TableBuilder.WriteRawBlock (Slice,CompressionType,BlockHandle*)",table\table_builder.cc,"void TableBuilder::WriteRawBlock(const Slice& block_contents,
                                 CompressionType type,
                                 BlockHandle* handle) {
  Rep* r = rep_;
  handle->set_offset(r->offset);
  handle->set_size(block_contents.size());
  r->status = r->file->Append(block_contents);
  if (r->status.ok()) {
    char trailer[kBlockTrailerSize];
    trailer[0] = type;
    uint32_t crc = crc32c::Value(block_contents.data(), block_contents.size());
    crc = crc32c::Extend(crc, trailer, 1);  // Extend crc to cover block type
    EncodeFixed32(trailer+1, crc32c::Mask(crc));
    r->status = r->file->Append(Slice(trailer, kBlockTrailerSize));
    if (r->status.ok()) {
      r->offset += block_contents.size() + kBlockTrailerSize;
    }
  }
}",175.0,193.0,1.0,1.0,19.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,void
2039,67002,operator =,1,leveldb.TableBuilder.operator =,void leveldb.TableBuilder.operator = (TableBuilder),include\leveldb\table_builder.hpp,void operator=(const TableBuilder&);,87.0,87.0,8.0,37.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
2040,67047,Put,1,leveldb.WriteBatch.Handler.Put,"void leveldb.WriteBatch.Handler.Put (Slice,Slice)",include\leveldb\write_batch.hpp,"virtual void Put(const Slice& key, const Slice& value) = 0;",49.0,49.0,18.0,62.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
2041,67053,Delete,1,leveldb.WriteBatch.Handler.Delete,void leveldb.WriteBatch.Handler.Delete (Slice),include\leveldb\write_batch.hpp,virtual void Delete(const Slice& key) = 0;,50.0,50.0,18.0,45.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
2042,67087,Key1,1,anonymous_namespace_1.Key1,string anonymous_namespace_1.Key1 (int),issues\issue178_test.cc,"std::string Key1(int i) {
  char buf[100];
  snprintf(buf, sizeof(buf), ""my_key_%d"", i);
  return buf;
}",18.0,22.0,1.0,1.0,5.0,1,1,4,2,0,0,1,1,0,0,,0,0,2,1,1,string
2043,67101,Key2,1,anonymous_namespace_2.Key2,string anonymous_namespace_2.Key2 (int),issues\issue178_test.cc,"std::string Key2(int i) {
  return Key1(i) + ""_xxx"";
}",24.0,26.0,1.0,1.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,string
2044,67113,_Run,1,anonymous_namespace_6._Test_Test._Run,void anonymous_namespace_6._Test_Test._Run (),issues\issue178_test.cc,void void ();,30.0,30.0,1.0,20.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2045,67117,_RunIt,1,anonymous_namespace_7._Test_Test._RunIt,void anonymous_namespace_7._Test_Test._RunIt (),issues\issue178_test.cc,"TEST(Issue178, Test)",30.0,30.0,1.0,20.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
2046,67141,_Run,1,anonymous_namespace_8._Test_Test._Run,void anonymous_namespace_8._Test_Test._Run (),issues\issue178_test.cc,"TEST(Issue178, Test) {
  // Get rid of any state from an old run.
  std::string dbpath = leveldb::test::TmpDir() + ""/leveldb_cbug_test"";
  DestroyDB(dbpath, leveldb::Options());

  // Open database.  Disable compression since it affects the creation
  // of layers and the code below is trying to test against a very
  // specific scenario.
  leveldb::DB* db;
  leveldb::Options db_options;
  db_options.create_if_missing = true;
  db_options.compression = leveldb::kNoCompression;
  ASSERT_OK(leveldb::DB::Open(db_options, dbpath, &db));

  // create first key range
  leveldb::WriteBatch batch;
  for (size_t i = 0; i < kNumKeys; i++) {
    batch.Put(Key1(i), ""value for range 1 key"");
  }
  ASSERT_OK(db->Write(leveldb::WriteOptions(), &batch));

  // create second key range
  batch.Clear();
  for (size_t i = 0; i < kNumKeys; i++) {
    batch.Put(Key2(i), ""value for range 2 key"");
  }
  ASSERT_OK(db->Write(leveldb::WriteOptions(), &batch));

  // delete second key range
  batch.Clear();
  ...",30.0,86.0,1.0,20.0,57.0,69,10,74,17,0,1,5,5,0,0,,0,1,0,0,0,void
2047,67459,_Run,1,leveldb._Test_Test._Run,void leveldb._Test_Test._Run (),issues\issue200_test.cc,"TEST(Issue200, Test) {
  // Get rid of any state from an old run.
  std::string dbpath = test::TmpDir() + ""/leveldb_issue200_test"";
  DestroyDB(dbpath, Options());

  DB *db;
  Options options;
  options.create_if_missing = true;
  ASSERT_OK(DB::Open(options, dbpath, &db));

  WriteOptions write_options;
  ASSERT_OK(db->Put(write_options, ""1"", ""b""));
  ASSERT_OK(db->Put(write_options, ""2"", ""c""));
  ASSERT_OK(db->Put(write_options, ""3"", ""d""));
  ASSERT_OK(db->Put(write_options, ""4"", ""e""));
  ASSERT_OK(db->Put(write_options, ""5"", ""f""));

  ReadOptions read_options;
  Iterator *iter = db->NewIterator(read_options);

  // Add an element that should not be reflected in the iterator.
  ASSERT_OK(db->Put(write_options, ""25"", ""cd""));

  iter->Seek(""5"");
  ASSERT_EQ(iter->key().ToString(), ""5"");
  iter->Prev();
  ASSERT_EQ(iter->key().ToString(), ""4"");
  iter->Prev();
  ASSERT_EQ(iter->key().ToString(), ""3"");
  iter->Next();
  ASSERT_EQ(iter->key().ToString(), ""4"");
  iter->Next();
  ASSERT_...",16.0,53.0,1.0,20.0,38.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2048,67463,_RunIt,1,leveldb._Test_Test._RunIt,void leveldb._Test_Test._RunIt (),issues\issue200_test.cc,"TEST(Issue200, Test)",16.0,16.0,1.0,20.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
2049,67885,Mutex,1,leveldb.port.Mutex.Mutex,ANY leveldb.port.Mutex.Mutex (),port\port_posix.cc,"Mutex::Mutex() { PthreadCall(""init mutex"", pthread_mutex_init(&mu_, NULL)); }",21.0,21.0,1.0,77.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
2050,67889,~Mutex,1,leveldb.port.Mutex.~Mutex,ANY leveldb.port.Mutex.~Mutex (),port\port_posix.cc,"Mutex::~Mutex() { PthreadCall(""destroy mutex"", pthread_mutex_destroy(&mu_)); }",23.0,23.0,1.0,78.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
2051,67893,Lock,1,leveldb.port.Mutex.Lock,void leveldb.port.Mutex.Lock (),port\port_posix.cc,"void Mutex::Lock() { PthreadCall(""lock"", pthread_mutex_lock(&mu_)); }",25.0,25.0,1.0,69.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2052,67897,Unlock,1,leveldb.port.Mutex.Unlock,void leveldb.port.Mutex.Unlock (),port\port_posix.cc,"void Mutex::Unlock() { PthreadCall(""unlock"", pthread_mutex_unlock(&mu_)); }",27.0,27.0,1.0,75.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2053,67901,AssertHeld,1,leveldb.port.Mutex.AssertHeld,void leveldb.port.Mutex.AssertHeld (),port\port_posix.hpp,void AssertHeld() { },89.0,89.0,3.0,23.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2054,67906,CondVar,1,leveldb.port.CondVar.CondVar,explicit leveldb.port.CondVar.CondVar (Mutex*),port\port_posix.cc,"CondVar::CondVar(Mutex* mu)
    : mu_(mu) {
    PthreadCall(""init cv"", pthread_cond_init(&cv_, NULL));
}",29.0,32.0,1.0,1.0,4.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
2055,67911,~CondVar,1,leveldb.port.CondVar.~CondVar,ANY leveldb.port.CondVar.~CondVar (),port\port_posix.cc,"CondVar::~CondVar() { PthreadCall(""destroy cv"", pthread_cond_destroy(&cv_)); }",34.0,34.0,1.0,78.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
2056,67915,Wait,1,leveldb.port.CondVar.Wait,void leveldb.port.CondVar.Wait (),port\port_posix.cc,"void CondVar::Wait() {
  PthreadCall(""wait"", pthread_cond_wait(&cv_, &mu_->mu_));
}",36.0,38.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2057,67919,Signal,1,leveldb.port.CondVar.Signal,void leveldb.port.CondVar.Signal (),port\port_posix.cc,"void CondVar::Signal() {
  PthreadCall(""signal"", pthread_cond_signal(&cv_));
}",40.0,42.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2058,67923,SignallAll,1,leveldb.port.CondVar.SignallAll,void leveldb.port.CondVar.SignallAll (),port\port_example.hpp,void SignallAll();,60.0,60.0,8.0,19.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2059,67928,InitOnce,1,leveldb.port.InitOnce,"void leveldb.port.InitOnce (ANY*,void)",port\port_posix.cc,"void InitOnce(OnceType* once, void (*initializer)()) {
  PthreadCall(""once"", pthread_once(once, initializer));
}",48.0,50.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
2060,67936,AtomicPointer,1,leveldb.port.AtomicPointer.AtomicPointer,ANY leveldb.port.AtomicPointer.AtomicPointer (),port\port_example.hpp,explicit AtomicPointer(void* v) : rep_(v) { },83.0,83.0,3.0,47.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
2061,67945,Acquire_Load,1,leveldb.port.AtomicPointer.Acquire_Load,void* leveldb.port.AtomicPointer.Acquire_Load (),port\port_example.hpp,void* Acquire_Load() const;,88.0,88.0,7.0,28.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void*
2062,67949,Release_Store,1,leveldb.port.AtomicPointer.Release_Store,void leveldb.port.AtomicPointer.Release_Store (void*),port\port_example.hpp,void Release_Store(void* v);,93.0,93.0,8.0,29.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
2063,67954,NoBarrier_Load,1,leveldb.port.AtomicPointer.NoBarrier_Load,void* leveldb.port.AtomicPointer.NoBarrier_Load (),port\port_example.hpp,void* NoBarrier_Load() const;,96.0,96.0,7.0,30.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void*
2064,67958,NoBarrier_Store,1,leveldb.port.AtomicPointer.NoBarrier_Store,void leveldb.port.AtomicPointer.NoBarrier_Store (void*),port\port_example.hpp,void NoBarrier_Store(void* v);,99.0,99.0,8.0,31.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
2065,67963,Snappy_Compress,1,leveldb.port.Snappy_Compress,"bool leveldb.port.Snappy_Compress (char*,size_t,ANY*)",port\port_posix.hpp,"inline bool Snappy_Compress(const char* input, size_t length,
                            ::std::string* output) {
#ifdef SNAPPY
  output->resize(snappy::MaxCompressedLength(length));
  size_t outlen;
  snappy::RawCompress(input, length, &(*output)[0], &outlen);
  output->resize(outlen);
  return true;
#endif

  return false;
}",116.0,127.0,1.0,1.0,12.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,bool
2066,67970,Snappy_GetUncompressedLength,1,leveldb.port.Snappy_GetUncompressedLength,"bool leveldb.port.Snappy_GetUncompressedLength (char*,size_t,size_t*)",port\port_posix.hpp,"inline bool Snappy_GetUncompressedLength(const char* input, size_t length,
                                         size_t* result) {
#ifdef SNAPPY
  return snappy::GetUncompressedLength(input, length, result);
#else
  return false;
#endif
}",129.0,136.0,1.0,1.0,8.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,bool
2067,67977,Snappy_Uncompress,1,leveldb.port.Snappy_Uncompress,"bool leveldb.port.Snappy_Uncompress (char*,size_t,char*)",port\port_posix.hpp,"inline bool Snappy_Uncompress(const char* input, size_t length,
                              char* output) {
#ifdef SNAPPY
  return snappy::RawUncompress(input, length, output);
#else
  return false;
#endif
}",138.0,145.0,1.0,1.0,8.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,bool
2068,67984,GetHeapProfile,1,leveldb.port.GetHeapProfile,"bool leveldb.port.GetHeapProfile (void,void*)",port\port_posix.hpp,"inline bool GetHeapProfile(void (*func)(void*, const char*, int), void* arg) {
  return false;
}",147.0,149.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,bool
2069,67990,AcceleratedCRC32C,1,leveldb.port.AcceleratedCRC32C,"uint32_t leveldb.port.AcceleratedCRC32C (uint32_t,char*,size_t)",port\port_posix_sse.cc,"uint32_t AcceleratedCRC32C(uint32_t crc, const char* buf, size_t size) {
#if !defined(LEVELDB_PLATFORM_POSIX_SSE)
  return 0;
#else
  static bool have = HaveSSE42();
  if (!have) {
    return 0;
  }

  const uint8_t *p = reinterpret_cast<const uint8_t *>(buf);
  const uint8_t *e = p + size;
  uint32_t l = crc ^ 0xffffffffu;

#define STEP1 do {                              \
    l = _mm_crc32_u8(l, *p++);                  \
} while (0)
#define STEP4 do {                              \
    l = _mm_crc32_u32(l, LE_LOAD32(p));         \
    p += 4;                                     \
} while (0)
#define STEP8 do {                              \
    l = _mm_crc32_u64(l, LE_LOAD64(p));         \
    p += 8;                                     \
} while (0)

  if (size > 16) {
    // Process unaligned bytes
    for (unsigned int i = reinterpret_cast<uintptr_t>(p) % 8; i; --i) {
      STEP1;
    }

    // _mm_crc32_u64 is only available on x64.
#if defined(_M_X64) || defined(__x86_64__)
 ...",69.0,126.0,1.0,1.0,58.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,uint32_t
2070,68012,PthreadCall,1,leveldb.port.PthreadCall,"void leveldb.port.PthreadCall (char*,int)",port\port_posix.cc,"static void PthreadCall(const char* label, int result) {
  if (result != 0) {
    fprintf(stderr, ""pthread %s: %s\n"", label, strerror(result));
    abort();
  }
}",14.0,19.0,1.0,1.0,6.0,1,1,4,3,0,0,2,2,0,0,,0,0,4,2,2,void
2071,68109,SignalAll,1,leveldb.port.CondVar.SignalAll,void leveldb.port.CondVar.SignalAll (),port\port_posix.cc,"void CondVar::SignalAll() {
  PthreadCall(""broadcast"", pthread_cond_broadcast(&cv_));
}",44.0,46.0,1.0,1.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,void
2072,68195,operator =,1,leveldb.port.Mutex.operator =,void leveldb.port.Mutex.operator = (Mutex),port\port_posix.hpp,void operator=(const Mutex&);,97.0,97.0,8.0,30.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
2073,68339,NumRestarts,1,leveldb.Block.NumRestarts,uint32_t leveldb.Block.NumRestarts (),table\block.cc,"inline uint32_t Block::NumRestarts() const {
  assert(size_ >= sizeof(uint32_t));
  return DecodeFixed32(data_ + size_ - sizeof(uint32_t));
}",18.0,21.0,1.0,1.0,4.0,5,4,5,3,0,3,1,1,0,0,,0,3,0,0,0,uint32_t
2074,68356,Block,1,leveldb.Block.Block,ANY leveldb.Block.Block (BlockContents),table\block.cc,"Block::Block(const BlockContents& contents)
    : data_(contents.data.data()),
      size_(contents.data.size()),
      owned_(contents.heap_allocated) {
  if (size_ < sizeof(uint32_t)) {
    size_ = 0;  // Error marker
  } else {
    size_t max_restarts_allowed = (size_-sizeof(uint32_t)) / sizeof(uint32_t);
    if (NumRestarts() > max_restarts_allowed) {
      // The size is too small for NumRestarts()
      size_ = 0;
    } else {
      restart_offset_ = size_ - (1 + NumRestarts()) * sizeof(uint32_t);
    }
  }
}",23.0,38.0,1.0,1.0,16.0,3,3,3,2,0,2,2,2,1,0,,0,2,2,1,1,ANY
2075,68402,~Block,1,leveldb.Block.~Block,ANY leveldb.Block.~Block (),table\block.cc,"Block::~Block() {
  if (owned_) {
    delete[] data_;
  }
}",40.0,44.0,1.0,1.0,5.0,1,1,2,2,0,2,2,2,1,0,,0,2,0,0,0,ANY
2076,68411,DecodeEntry,1,leveldb.DecodeEntry,"const char* leveldb.DecodeEntry (char*,char*,uint32_t*,uint32_t*,uint32_t*)",table\block.cc,"static inline const char* DecodeEntry(const char* p, const char* limit,
                                      uint32_t* shared,
                                      uint32_t* non_shared,
                                      uint32_t* value_length) {
  if (limit - p < 3) return NULL;
  *shared = reinterpret_cast<const unsigned char*>(p)[0];
  *non_shared = reinterpret_cast<const unsigned char*>(p)[1];
  *value_length = reinterpret_cast<const unsigned char*>(p)[2];
  if ((*shared | *non_shared | *value_length) < 128) {
    // Fast path: all three values are encoded in one byte each
    p += 3;
  } else {
    if ((p = GetVarint32Ptr(p, limit, shared)) == NULL) return NULL;
    if ((p = GetVarint32Ptr(p, limit, non_shared)) == NULL) return NULL;
    if ((p = GetVarint32Ptr(p, limit, value_length)) == NULL) return NULL;
  }

  if (static_cast<uint32_t>(limit - p) < (*non_shared + *value_length)) {
    return NULL;
  }
  return p;
}",53.0,74.0,1.0,1.0,22.0,27,9,19,6,0,0,4,4,0,0,,0,0,10,5,5,const char*
2077,68533,Compare,1,leveldb.Iter.Compare,"int leveldb.Iter.Compare (Slice,Slice)",table\block.cc,"inline int Compare(const Slice& a, const Slice& b) const {
    return comparator_->Compare(a, b);
  }",90.0,92.0,3.0,3.0,3.0,1,1,3,3,0,1,1,1,0,0,,0,1,4,2,2,int
2078,68546,NextEntryOffset,1,leveldb.Iter.NextEntryOffset,uint32_t leveldb.Iter.NextEntryOffset (),table\block.cc,"inline uint32_t NextEntryOffset() const {
    return (value_.data() + value_.size()) - data_;
  }",95.0,97.0,3.0,3.0,3.0,4,3,3,2,0,3,1,1,0,0,,0,3,0,0,0,uint32_t
2079,68562,GetRestartPoint,1,leveldb.Iter.GetRestartPoint,uint32_t leveldb.Iter.GetRestartPoint (uint32_t),table\block.cc,"uint32_t GetRestartPoint(uint32_t index) {
    assert(index < num_restarts_);
    return DecodeFixed32(data_ + restarts_ + index * sizeof(uint32_t));
  }",99.0,102.0,3.0,3.0,4.0,5,4,6,5,0,3,1,1,0,0,,0,3,2,1,1,uint32_t
2080,68581,SeekToRestartPoint,1,leveldb.Iter.SeekToRestartPoint,void leveldb.Iter.SeekToRestartPoint (uint32_t),table\block.cc,"void SeekToRestartPoint(uint32_t index) {
    key_.clear();
    restart_index_ = index;
    // current_ will be fixed by ParseNextKey();

    // ParseNextKey() starts at the end of value_, so set value_ accordingly
    uint32_t offset = GetRestartPoint(index);
    value_ = Slice(data_ + offset, 0);
  }",104.0,112.0,3.0,3.0,9.0,5,3,8,6,0,4,1,1,0,0,,0,4,2,1,1,void
2081,68605,Iter,1,leveldb.Iter.Iter,"ANY leveldb.Iter.Iter (Comparator*,char*,uint32_t,uint32_t)",table\block.cc,"Iter(const Comparator* comparator,
       const char* data,
       uint32_t restarts,
       uint32_t num_restarts)
      : comparator_(comparator),
        data_(data),
        restarts_(restarts),
        num_restarts_(num_restarts),
        current_(restarts_),
        restart_index_(num_restarts_) {
    assert(num_restarts_ > 0);
  }",115.0,126.0,3.0,3.0,12.0,1,1,1,1,0,1,1,1,0,0,,0,1,8,4,4,ANY
2082,68617,Valid,1,leveldb.Iter.Valid,bool leveldb.Iter.Valid (),table\block.cc,virtual bool Valid() const { return current_ < restarts_; },128.0,128.0,3.0,61.0,1.0,1,1,2,2,0,2,1,1,0,0,,0,2,0,0,0,bool
2083,68625,status,1,leveldb.Iter.status,Status leveldb.Iter.status (),table\block.cc,virtual Status status() const { return status_; },129.0,129.0,3.0,51.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,Status
2084,68631,key,1,leveldb.Iter.key,Slice leveldb.Iter.key (),table\block.cc,"virtual Slice key() const {
    assert(Valid());
    return key_;
  }",130.0,133.0,3.0,3.0,4.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,Slice
2085,68639,value,1,leveldb.Iter.value,Slice leveldb.Iter.value (),table\block.cc,"virtual Slice value() const {
    assert(Valid());
    return value_;
  }",134.0,137.0,3.0,3.0,4.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,Slice
2086,68647,Next,1,leveldb.Iter.Next,void leveldb.Iter.Next (),table\block.cc,"virtual void Next() {
    assert(Valid());
    ParseNextKey();
  }",139.0,142.0,3.0,3.0,4.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2087,68654,Prev,1,leveldb.Iter.Prev,void leveldb.Iter.Prev (),table\block.cc,"virtual void Prev() {
    assert(Valid());

    // Scan backwards to a restart point before current_
    const uint32_t original = current_;
    while (GetRestartPoint(restart_index_) >= original) {
      if (restart_index_ == 0) {
        // No more entries
        current_ = restarts_;
        restart_index_ = num_restarts_;
        return;
      }
      restart_index_--;
    }

    SeekToRestartPoint(restart_index_);
    do {
      // Loop until end of current entry hits the start of original entry
    } while (ParseNextKey() && NextEntryOffset() < original);
  }",144.0,163.0,3.0,3.0,20.0,8,6,12,5,0,9,4,5,2,0,,0,9,0,0,0,void
2088,68693,Seek,1,leveldb.Iter.Seek,void leveldb.Iter.Seek (Slice),table\block.cc,"virtual void Seek(const Slice& target) {
    // Binary search in restart array to find the last restart point
    // with a key < target
    uint32_t left = 0;
    uint32_t right = num_restarts_ - 1;
    while (left < right) {
      uint32_t mid = (left + right + 1) / 2;
      uint32_t region_offset = GetRestartPoint(mid);
      uint32_t shared, non_shared, value_length;
      const char* key_ptr = DecodeEntry(data_ + region_offset,
                                        data_ + restarts_,
                                        &shared, &non_shared, &value_length);
      if (key_ptr == NULL || (shared != 0)) {
        CorruptionError();
        return;
      }
      Slice mid_key(key_ptr, non_shared);
      if (Compare(mid_key, target) < 0) {
        // Key at ""mid"" is smaller than ""target"".  Therefore all
        // blocks before ""mid"" are uninteresting.
        left = mid;
      } else {
        // Key at ""mid"" is >= ""target"".  Therefore all blocks at or
        // after ""mid"" a...",165.0,203.0,3.0,3.0,39.0,22,11,30,15,0,5,7,11,1,0,,0,5,2,1,1,void
2089,68797,SeekToFirst,1,leveldb.Iter.SeekToFirst,void leveldb.Iter.SeekToFirst (),table\block.cc,"virtual void SeekToFirst() {
    SeekToRestartPoint(0);
    ParseNextKey();
  }",205.0,208.0,3.0,3.0,4.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2090,68804,SeekToLast,1,leveldb.Iter.SeekToLast,void leveldb.Iter.SeekToLast (),table\block.cc,"virtual void SeekToLast() {
    SeekToRestartPoint(num_restarts_ - 1);
    while (ParseNextKey() && NextEntryOffset() < restarts_) {
      // Keep skipping
    }
  }",210.0,215.0,3.0,3.0,6.0,3,3,2,2,0,2,2,2,1,0,,0,2,0,0,0,void
2091,68819,CorruptionError,1,leveldb.Iter.CorruptionError,void leveldb.Iter.CorruptionError (),table\block.cc,"void CorruptionError() {
    current_ = restarts_;
    restart_index_ = num_restarts_;
    status_ = Status::Corruption(""bad entry in block"");
    key_.clear();
    value_.clear();
  }",218.0,224.0,3.0,3.0,7.0,6,2,8,8,0,8,1,1,0,1,,0,8,0,0,0,void
2092,68844,ParseNextKey,1,leveldb.Iter.ParseNextKey,bool leveldb.Iter.ParseNextKey (),table\block.cc,"bool ParseNextKey() {
    current_ = NextEntryOffset();
    const char* p = data_ + current_;
    const char* limit = data_ + restarts_;  // Restarts come right after data
    if (p >= limit) {
      // No more entries to return.  Mark as invalid.
      current_ = restarts_;
      restart_index_ = num_restarts_;
      return false;
    }

    // Decode next entry
    uint32_t shared, non_shared, value_length;
    p = DecodeEntry(p, limit, &shared, &non_shared, &value_length);
    if (p == NULL || key_.size() < shared) {
      CorruptionError();
      return false;
    } else {
      key_.resize(shared);
      key_.append(p, non_shared);
      value_ = Slice(p + non_shared, value_length);
      while (restart_index_ + 1 < num_restarts_ &&
             GetRestartPoint(restart_index_ + 1) < current_) {
        ++restart_index_;
      }
      return true;
    }
  }",226.0,253.0,3.0,3.0,28.0,16,8,23,12,0,10,3,3,1,0,,0,10,0,0,0,bool
2093,68943,NewIterator,1,leveldb.Block.NewIterator,Iterator leveldb.Block.NewIterator (Comparator*),table\block.cc,"Iterator* Block::NewIterator(const Comparator* cmp) {
  if (size_ < sizeof(uint32_t)) {
    return NewErrorIterator(Status::Corruption(""bad block contents""));
  }
  const uint32_t num_restarts = NumRestarts();
  if (num_restarts == 0) {
    return NewEmptyIterator();
  } else {
    return new Iter(cmp, data_, restart_offset_, num_restarts);
  }
}",256.0,266.0,1.0,1.0,11.0,5,5,5,4,0,2,3,3,1,1,,0,1,2,1,1,Iterator
2094,69005,size,1,leveldb.Block.size,size_t leveldb.Block.size (),table\block.hpp,size_t size() const { return size_; },24.0,24.0,3.0,39.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,size_t
2095,69029,operator =,1,leveldb.Block.operator =,void leveldb.Block.operator = (Block),table\block.hpp,void operator=(const Block&);,37.0,37.0,8.0,30.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
2096,69053,BlockBuilder,1,leveldb.BlockBuilder.BlockBuilder,ANY leveldb.BlockBuilder.BlockBuilder (Options*),table\block_builder.cc,"BlockBuilder::BlockBuilder(const Options* options)
    : options_(options),
      restarts_(),
      counter_(0),
      finished_(false) {
  assert(options->block_restart_interval >= 1);
  restarts_.push_back(0);       // First restart point is at offset 0
}",39.0,46.0,1.0,1.0,8.0,3,3,2,2,0,2,1,1,0,0,,0,2,2,1,1,ANY
2097,69069,Reset,1,leveldb.BlockBuilder.Reset,void leveldb.BlockBuilder.Reset (),table\block_builder.cc,"void BlockBuilder::Reset() {
  buffer_.clear();
  restarts_.clear();
  restarts_.push_back(0);       // First restart point is at offset 0
  counter_ = 0;
  finished_ = false;
  last_key_.clear();
}",48.0,55.0,1.0,1.0,8.0,6,2,6,5,0,6,1,1,0,0,,0,6,0,0,0,void
2098,69096,CurrentSizeEstimate,1,leveldb.BlockBuilder.CurrentSizeEstimate,size_t leveldb.BlockBuilder.CurrentSizeEstimate (),table\block_builder.cc,"size_t BlockBuilder::CurrentSizeEstimate() const {
  return (buffer_.size() +                        // Raw data buffer
          restarts_.size() * sizeof(uint32_t) +   // Restart array
          sizeof(uint32_t));                      // Restart array length
}",57.0,61.0,1.0,1.0,5.0,7,4,4,3,0,2,1,1,0,0,,0,2,0,0,0,size_t
2099,69116,Finish,1,leveldb.BlockBuilder.Finish,Slice leveldb.BlockBuilder.Finish (),table\block_builder.cc,"Slice BlockBuilder::Finish() {
  // Append restart array
  for (size_t i = 0; i < restarts_.size(); i++) {
    PutFixed32(&buffer_, restarts_[i]);
  }
  PutFixed32(&buffer_, restarts_.size());
  finished_ = true;
  return Slice(buffer_);
}",63.0,71.0,1.0,1.0,9.0,8,5,10,4,0,7,2,2,1,0,,0,7,0,0,0,Slice
2100,69154,Add,1,leveldb.BlockBuilder.Add,"void leveldb.BlockBuilder.Add (Slice,Slice)",table\block_builder.cc,"void BlockBuilder::Add(const Slice& key, const Slice& value) {
  Slice last_key_piece(last_key_);
  assert(!finished_);
  assert(counter_ <= options_->block_restart_interval);
  assert(buffer_.empty() // No values yet?
         || options_->comparator->Compare(key, last_key_piece) > 0);
  size_t shared = 0;
  if (counter_ < options_->block_restart_interval) {
    // See how much sharing to do with previous string
    const size_t min_length = std::min(last_key_piece.size(), key.size());
    while ((shared < min_length) && (last_key_piece[shared] == key[shared])) {
      shared++;
    }
  } else {
    // Restart compression
    restarts_.push_back(buffer_.size());
    counter_ = 0;
  }
  const size_t non_shared = key.size() - shared;

  // Add ""<shared><non_shared><value_size>"" to buffer_
  PutVarint32(&buffer_, shared);
  PutVarint32(&buffer_, non_shared);
  PutVarint32(&buffer_, value.size());

  // Add string delta to buffer_ followed by value
  buffer_.append(key.data() + shared,...",73.0,107.0,1.0,1.0,35.0,40,15,47,12,0,17,3,4,2,0,,0,17,4,2,2,void
2101,69349,empty,1,leveldb.BlockBuilder.empty,bool leveldb.BlockBuilder.empty (),table\block_builder.hpp,"bool empty() const {
    return buffer_.empty();
  }",38.0,40.0,3.0,3.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,bool
2102,69369,operator =,1,leveldb.BlockBuilder.operator =,void leveldb.BlockBuilder.operator = (BlockBuilder),table\block_builder.hpp,void operator=(const BlockBuilder&);,52.0,52.0,8.0,37.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
2103,69396,FilterBlockBuilder,1,leveldb.FilterBlockBuilder.FilterBlockBuilder,ANY leveldb.FilterBlockBuilder.FilterBlockBuilder (FilterPolicy*),table\filter_block.cc,"FilterBlockBuilder::FilterBlockBuilder(const FilterPolicy* policy)
    : policy_(policy) {
}",18.0,20.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
2104,69401,StartBlock,1,leveldb.FilterBlockBuilder.StartBlock,void leveldb.FilterBlockBuilder.StartBlock (uint64_t),table\filter_block.cc,"void FilterBlockBuilder::StartBlock(uint64_t block_offset) {
  uint64_t filter_index = (block_offset / kFilterBase);
  assert(filter_index >= filter_offsets_.size());
  while (filter_index > filter_offsets_.size()) {
    GenerateFilter();
  }
}",22.0,28.0,1.0,1.0,7.0,6,5,7,4,0,2,2,2,1,0,,0,2,2,1,1,void
2105,69428,AddKey,1,leveldb.FilterBlockBuilder.AddKey,void leveldb.FilterBlockBuilder.AddKey (Slice),table\filter_block.cc,"void FilterBlockBuilder::AddKey(const Slice& key) {
  Slice k = key;
  start_.push_back(keys_.size());
  keys_.append(k.data(), k.size());
}",30.0,34.0,1.0,1.0,5.0,6,2,7,4,0,3,1,1,0,0,,0,3,2,1,1,void
2106,69457,Finish,1,leveldb.FilterBlockBuilder.Finish,Slice leveldb.FilterBlockBuilder.Finish (),table\filter_block.cc,"Slice FilterBlockBuilder::Finish() {
  if (!start_.empty()) {
    GenerateFilter();
  }

  // Append array of per-filter offsets
  const uint32_t array_offset = result_.size();
  for (size_t i = 0; i < filter_offsets_.size(); i++) {
    PutFixed32(&result_, filter_offsets_[i]);
  }

  PutFixed32(&result_, array_offset);
  result_.push_back(kFilterBaseLg);  // Save encoding parameter in result
  return Slice(result_);
}",36.0,50.0,1.0,1.0,15.0,11,6,14,6,0,8,3,3,2,0,,0,8,0,0,0,Slice
2107,69509,GenerateFilter,1,leveldb.FilterBlockBuilder.GenerateFilter,void leveldb.FilterBlockBuilder.GenerateFilter (),table\filter_block.cc,"void FilterBlockBuilder::GenerateFilter() {
  const size_t num_keys = start_.size();
  if (num_keys == 0) {
    // Fast path if there are no keys for this filter
    filter_offsets_.push_back(result_.size());
    return;
  }

  // Make list of keys from flattened key structure
  start_.push_back(keys_.size());  // Simplify length computation
  tmp_keys_.resize(num_keys);
  for (size_t i = 0; i < num_keys; i++) {
    const char* base = keys_.data() + start_[i];
    size_t length = start_[i+1] - start_[i];
    tmp_keys_[i] = Slice(base, length);
  }

  // Generate filter for current set of keys and append to result_.
  filter_offsets_.push_back(result_.size());
  policy_->CreateFilter(&tmp_keys_[0], static_cast<int>(num_keys), &result_);

  tmp_keys_.clear();
  keys_.clear();
  start_.clear();
}",52.0,76.0,1.0,1.0,25.0,31,10,34,10,0,19,3,3,0,0,,0,19,0,0,0,void
2108,69622,FilterBlockReader,1,leveldb.FilterBlockReader.FilterBlockReader,"ANY leveldb.FilterBlockReader.FilterBlockReader (FilterPolicy*,Slice)",table\filter_block.cc,"FilterBlockReader::FilterBlockReader(const FilterPolicy* policy,
                                     const Slice& contents)
    : policy_(policy),
      data_(NULL),
      offset_(NULL),
      num_(0),
      base_lg_(0) {
  size_t n = contents.size();
  if (n < 5) return;  // 1 byte for base_lg_ and 4 for start of offset array
  base_lg_ = contents[n-1];
  uint32_t last_word = DecodeFixed32(contents.data() + n - 5);
  if (last_word > n - 5) return;
  data_ = contents.data();
  offset_ = data_ + last_word;
  num_ = (n - 5 - last_word) / 4;
}",78.0,93.0,1.0,1.0,16.0,20,8,19,7,0,5,3,3,0,0,,0,5,4,2,2,ANY
2109,69688,KeyMayMatch,1,leveldb.FilterBlockReader.KeyMayMatch,"bool leveldb.FilterBlockReader.KeyMayMatch (uint64_t,Slice)",table\filter_block.cc,"bool FilterBlockReader::KeyMayMatch(uint64_t block_offset, const Slice& key) {
  uint64_t index = block_offset >> base_lg_;
  if (index < num_) {
    uint32_t start = DecodeFixed32(offset_ + index*4);
    uint32_t limit = DecodeFixed32(offset_ + index*4 + 4);
    if (start <= limit && limit <= static_cast<size_t>(offset_ - data_)) {
      Slice filter = Slice(data_ + start, limit - start);
      return policy_->KeyMayMatch(key, filter);
    } else if (start == limit) {
      // Empty filters do not match any keys
      return false;
    }
  }
  return true;  // Errors are treated as potential matches
}",95.0,109.0,1.0,1.0,15.0,19,10,24,11,0,8,3,4,3,0,,0,8,4,2,2,bool
2110,69820,operator =,1,leveldb.FilterBlockBuilder.operator =,void leveldb.FilterBlockBuilder.operator = (FilterBlockBuilder),table\filter_block.hpp,void operator=(const FilterBlockBuilder&);,49.0,49.0,8.0,43.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
2111,69864,Name,1,leveldb.TestHashFilter.Name,const char* leveldb.TestHashFilter.Name (),table\filter_block_test.cc,"virtual const char* Name() const {
    return ""TestHashFilter"";
  }",19.0,21.0,3.0,3.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,const char*
2112,69870,CreateFilter,1,leveldb.TestHashFilter.CreateFilter,"void leveldb.TestHashFilter.CreateFilter (Slice*,int,ANY*)",table\filter_block_test.cc,"virtual void CreateFilter(const Slice* keys, int n, std::string* dst) const {
    for (int i = 0; i < n; i++) {
      uint32_t h = Hash(keys[i].data(), keys[i].size(), 1);
      PutFixed32(dst, h);
    }
  }",23.0,28.0,3.0,3.0,6.0,7,4,10,5,0,0,2,2,0,0,,0,0,6,3,3,void
2113,69909,KeyMayMatch,1,leveldb.TestHashFilter.KeyMayMatch,"bool leveldb.TestHashFilter.KeyMayMatch (Slice,Slice)",table\filter_block_test.cc,"virtual bool KeyMayMatch(const Slice& key, const Slice& filter) const {
    uint32_t h = Hash(key.data(), key.size(), 1);
    for (size_t i = 0; i + 4 <= filter.size(); i += 4) {
      if (h == DecodeFixed32(filter.data() + i)) {
        return true;
      }
    }
    return false;
  }",30.0,38.0,3.0,3.0,9.0,10,5,9,4,0,0,3,4,0,0,,0,0,4,2,2,bool
2114,69964,_Run,1,leveldb._Test_EmptyBuilder._Run,void leveldb._Test_EmptyBuilder._Run (),table\filter_block_test.cc,"TEST(FilterBlockTest, EmptyBuilder) {
  FilterBlockBuilder builder(&policy_);
  Slice block = builder.Finish();
  ASSERT_EQ(""\\x00\\x00\\x00\\x00\\x0b"", EscapeString(block));
  FilterBlockReader reader(&policy_, block);
  ASSERT_TRUE(reader.KeyMayMatch(0, ""foo""));
  ASSERT_TRUE(reader.KeyMayMatch(100000, ""foo""));
}",46.0,53.0,1.0,35.0,8.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2115,69968,_RunIt,1,leveldb._Test_EmptyBuilder._RunIt,void leveldb._Test_EmptyBuilder._RunIt (),table\filter_block_test.cc,"TEST(FilterBlockTest, EmptyBuilder)",46.0,46.0,1.0,35.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
2116,70072,_Run,1,leveldb._Test_SingleChunk._Run,void leveldb._Test_SingleChunk._Run (),table\filter_block_test.cc,"TEST(FilterBlockTest, SingleChunk) {
  FilterBlockBuilder builder(&policy_);
  builder.StartBlock(100);
  builder.AddKey(""foo"");
  builder.AddKey(""bar"");
  builder.AddKey(""box"");
  builder.StartBlock(200);
  builder.AddKey(""box"");
  builder.StartBlock(300);
  builder.AddKey(""hello"");
  Slice block = builder.Finish();
  FilterBlockReader reader(&policy_, block);
  ASSERT_TRUE(reader.KeyMayMatch(100, ""foo""));
  ASSERT_TRUE(reader.KeyMayMatch(100, ""bar""));
  ASSERT_TRUE(reader.KeyMayMatch(100, ""box""));
  ASSERT_TRUE(reader.KeyMayMatch(100, ""hello""));
  ASSERT_TRUE(reader.KeyMayMatch(100, ""foo""));
  ASSERT_TRUE(! reader.KeyMayMatch(100, ""missing""));
  ASSERT_TRUE(! reader.KeyMayMatch(100, ""other""));
}",55.0,74.0,1.0,34.0,20.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2117,70076,_RunIt,1,leveldb._Test_SingleChunk._RunIt,void leveldb._Test_SingleChunk._RunIt (),table\filter_block_test.cc,"TEST(FilterBlockTest, SingleChunk)",55.0,55.0,1.0,34.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
2118,70303,_Run,1,leveldb._Test_MultiChunk._Run,void leveldb._Test_MultiChunk._Run (),table\filter_block_test.cc,"TEST(FilterBlockTest, MultiChunk) {
  FilterBlockBuilder builder(&policy_);

  // First filter
  builder.StartBlock(0);
  builder.AddKey(""foo"");
  builder.StartBlock(2000);
  builder.AddKey(""bar"");

  // Second filter
  builder.StartBlock(3100);
  builder.AddKey(""box"");

  // Third filter is empty

  // Last filter
  builder.StartBlock(9000);
  builder.AddKey(""box"");
  builder.AddKey(""hello"");

  Slice block = builder.Finish();
  FilterBlockReader reader(&policy_, block);

  // Check first filter
  ASSERT_TRUE(reader.KeyMayMatch(0, ""foo""));
  ASSERT_TRUE(reader.KeyMayMatch(2000, ""bar""));
  ASSERT_TRUE(! reader.KeyMayMatch(0, ""box""));
  ASSERT_TRUE(! reader.KeyMayMatch(0, ""hello""));

  // Check second filter
  ASSERT_TRUE(reader.KeyMayMatch(3100, ""box""));
  ASSERT_TRUE(! reader.KeyMayMatch(3100, ""foo""));
  ASSERT_TRUE(! reader.KeyMayMatch(3100, ""bar""));
  ASSERT_TRUE(! reader.KeyMayMatch(3100, ""hello""));

  // Check third filter (empty)
  ASSERT_TRUE(! reader.KeyMayMatch(4100, ""foo"")...",76.0,122.0,1.0,33.0,47.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2119,70307,_RunIt,1,leveldb._Test_MultiChunk._RunIt,void leveldb._Test_MultiChunk._RunIt (),table\filter_block_test.cc,"TEST(FilterBlockTest, MultiChunk)",76.0,76.0,1.0,33.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
2120,70758,EncodeTo,1,leveldb.BlockHandle.EncodeTo,void leveldb.BlockHandle.EncodeTo (ANY*),table\format.cc,"void BlockHandle::EncodeTo(std::string* dst) const {
  // Sanity check that all fields have been set
  assert(offset_ != ~static_cast<uint64_t>(0));
  assert(size_ != ~static_cast<uint64_t>(0));
  PutVarint64(dst, offset_);
  PutVarint64(dst, size_);
}",15.0,21.0,1.0,1.0,7.0,6,3,6,3,0,4,1,1,0,0,,0,4,2,1,1,void
2121,70783,DecodeFrom,1,leveldb.BlockHandle.DecodeFrom,Status leveldb.BlockHandle.DecodeFrom (Slice*),table\format.cc,"Status BlockHandle::DecodeFrom(Slice* input) {
  if (GetVarint64(input, &offset_) &&
      GetVarint64(input, &size_)) {
    return Status::OK();
  } else {
    return Status::Corruption(""bad block handle"");
  }
}",23.0,30.0,1.0,1.0,8.0,4,3,5,4,0,3,2,2,2,0,,0,2,2,1,1,Status
2122,70812,EncodeTo,1,leveldb.Footer.EncodeTo,void leveldb.Footer.EncodeTo (ANY*),table\format.cc,"void Footer::EncodeTo(std::string* dst) const {
  const size_t original_size = dst->size();
  metaindex_handle_.EncodeTo(dst);
  index_handle_.EncodeTo(dst);
  dst->resize(2 * BlockHandle::kMaxEncodedLength);  // Padding
  PutFixed32(dst, static_cast<uint32_t>(kTableMagicNumber & 0xffffffffu));
  PutFixed32(dst, static_cast<uint32_t>(kTableMagicNumber >> 32));
  assert(dst->size() == original_size + kEncodedLength);
  (void)original_size;  // Disable unused variable warning.
}",32.0,41.0,1.0,1.0,10.0,15,9,16,7,0,4,1,1,0,0,,0,4,2,1,1,void
2123,70869,DecodeFrom,1,leveldb.Footer.DecodeFrom,Status leveldb.Footer.DecodeFrom (Slice*),table\format.cc,"Status Footer::DecodeFrom(Slice* input) {
  const char* magic_ptr = input->data() + kEncodedLength - 8;
  const uint32_t magic_lo = DecodeFixed32(magic_ptr);
  const uint32_t magic_hi = DecodeFixed32(magic_ptr + 4);
  const uint64_t magic = ((static_cast<uint64_t>(magic_hi) << 32) |
                          (static_cast<uint64_t>(magic_lo)));
  if (magic != kTableMagicNumber) {
    return Status::Corruption(""not an sstable (bad magic number)"");
  }

  Status result = metaindex_handle_.DecodeFrom(input);
  if (result.ok()) {
    result = index_handle_.DecodeFrom(input);
  }
  if (result.ok()) {
    // We skip over any leftover data (just padding for now) in ""input""
    const char* end = magic_ptr + 8;
    *input = Slice(end, input->data() + input->size() - end);
  }
  return result;
}",43.0,63.0,1.0,1.0,21.0,28,10,29,12,0,4,4,4,0,1,,0,3,2,1,1,Status
2124,70971,ReadBlock,1,leveldb.ReadBlock,"Status leveldb.ReadBlock (RandomAccessFile*,ReadOptions,BlockHandle,BlockContents*)",table\format.cc,"Status ReadBlock(RandomAccessFile* file,
                 const ReadOptions& options,
                 const BlockHandle& handle,
                 BlockContents* result) {
  result->data = Slice();
  result->cachable = false;
  result->heap_allocated = false;

  // Read the block contents as well as the type/crc footer.
  // See table_builder.cc for the code that built this structure.
  size_t n = static_cast<size_t>(handle.size());
  char* buf = new char[n + kBlockTrailerSize];
  Slice contents;
  Status s = file->Read(handle.offset(), n + kBlockTrailerSize, &contents, buf);
  if (!s.ok()) {
    delete[] buf;
    return s;
  }
  if (contents.size() != n + kBlockTrailerSize) {
    delete[] buf;
    return Status::Corruption(""truncated block read"");
  }

  // Check the crc of the type and the block contents
  const char* data = contents.data();    // Pointer to where Read put the data
  if (options.verify_checksums) {
    const uint32_t crc = crc32c::Unmask(DecodeFixed32(data + n + 1...",65.0,142.0,1.0,1.0,78.0,70,11,76,20,0,16,11,13,1,5,,0,11,8,4,4,Status
2125,71263,BlockHandle,1,leveldb.BlockHandle.BlockHandle,ANY leveldb.BlockHandle.BlockHandle (),table\format.hpp,"inline BlockHandle::BlockHandle()
    : offset_(~static_cast<uint64_t>(0)),
      size_(~static_cast<uint64_t>(0)) {
}",101.0,104.0,1.0,1.0,4.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
2126,71267,offset,1,leveldb.BlockHandle.offset,uint64_t leveldb.BlockHandle.offset (),table\format.hpp,uint64_t offset() const { return offset_; },27.0,27.0,3.0,45.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,uint64_t
2127,71273,set_offset,1,leveldb.BlockHandle.set_offset,void leveldb.BlockHandle.set_offset (uint64_t),table\format.hpp,void set_offset(uint64_t offset) { offset_ = offset; },28.0,28.0,3.0,56.0,1.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
2128,71281,size,1,leveldb.BlockHandle.size,uint64_t leveldb.BlockHandle.size (),table\format.hpp,uint64_t size() const { return size_; },31.0,31.0,3.0,41.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,uint64_t
2129,71287,set_size,1,leveldb.BlockHandle.set_size,void leveldb.BlockHandle.set_size (uint64_t),table\format.hpp,void set_size(uint64_t size) { size_ = size; },32.0,32.0,3.0,48.0,1.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
2130,71319,Footer,1,leveldb.Footer.Footer,ANY leveldb.Footer.Footer (),table\format.hpp,Footer() { },49.0,49.0,3.0,14.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
2131,71323,metaindex_handle,1,leveldb.Footer.metaindex_handle,BlockHandle leveldb.Footer.metaindex_handle (),table\format.hpp,const BlockHandle& metaindex_handle() const { return metaindex_handle_; },52.0,52.0,3.0,75.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,BlockHandle
2132,71329,set_metaindex_handle,1,leveldb.Footer.set_metaindex_handle,void leveldb.Footer.set_metaindex_handle (BlockHandle),table\format.hpp,void set_metaindex_handle(const BlockHandle& h) { metaindex_handle_ = h; },53.0,53.0,3.0,76.0,1.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
2133,71337,index_handle,1,leveldb.Footer.index_handle,BlockHandle leveldb.Footer.index_handle (),table\format.hpp,"const BlockHandle& index_handle() const {
    return index_handle_;
  }",56.0,58.0,3.0,3.0,3.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,BlockHandle
2134,71343,set_index_handle,1,leveldb.Footer.set_index_handle,void leveldb.Footer.set_index_handle (BlockHandle),table\format.hpp,"void set_index_handle(const BlockHandle& h) {
    index_handle_ = h;
  }",59.0,61.0,3.0,3.0,3.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
2135,71538,EmptyIterator,1,leveldb.anonymous_namespace_2.EmptyIterator.EmptyIterator,ANY leveldb.anonymous_namespace_2.EmptyIterator.EmptyIterator (Status),table\iterator.cc,EmptyIterator(const Status& s) : status_(s) { },44.0,44.0,3.0,49.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
2136,71543,Valid,1,leveldb.anonymous_namespace_3.EmptyIterator.Valid,bool leveldb.anonymous_namespace_3.EmptyIterator.Valid (),table\iterator.cc,virtual bool Valid() const { return false; },45.0,45.0,3.0,46.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,bool
2137,71549,Seek,1,leveldb.anonymous_namespace_4.EmptyIterator.Seek,void leveldb.anonymous_namespace_4.EmptyIterator.Seek (Slice),table\iterator.cc,virtual void Seek(const Slice& target) { },46.0,46.0,3.0,44.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
2138,71554,SeekToFirst,1,leveldb.anonymous_namespace_5.EmptyIterator.SeekToFirst,void leveldb.anonymous_namespace_5.EmptyIterator.SeekToFirst (),table\iterator.cc,virtual void SeekToFirst() { },47.0,47.0,3.0,32.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2139,71558,SeekToLast,1,leveldb.anonymous_namespace_6.EmptyIterator.SeekToLast,void leveldb.anonymous_namespace_6.EmptyIterator.SeekToLast (),table\iterator.cc,virtual void SeekToLast() { },48.0,48.0,3.0,31.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2140,71562,Next,1,leveldb.anonymous_namespace_7.EmptyIterator.Next,void leveldb.anonymous_namespace_7.EmptyIterator.Next (),table\iterator.cc,virtual void Next() { assert(false); },49.0,49.0,3.0,40.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2141,71568,Prev,1,leveldb.anonymous_namespace_8.EmptyIterator.Prev,void leveldb.anonymous_namespace_8.EmptyIterator.Prev (),table\iterator.cc,virtual void Prev() { assert(false); },50.0,50.0,3.0,40.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2142,71574,key,1,leveldb.anonymous_namespace_9.EmptyIterator.key,Slice leveldb.anonymous_namespace_9.EmptyIterator.key (),table\iterator.cc,Slice key() const { assert(false); return Slice(); },51.0,51.0,3.0,54.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,Slice
2143,71582,value,1,leveldb.anonymous_namespace_10.EmptyIterator.value,Slice leveldb.anonymous_namespace_10.EmptyIterator.value (),table\iterator.cc,Slice value() const { assert(false); return Slice(); },52.0,52.0,3.0,56.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,Slice
2144,71590,status,1,leveldb.anonymous_namespace_11.EmptyIterator.status,Status leveldb.anonymous_namespace_11.EmptyIterator.status (),table\iterator.cc,virtual Status status() const { return status_; },53.0,53.0,3.0,51.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,Status
2145,71628,IteratorWrapper,1,leveldb.IteratorWrapper.IteratorWrapper,ANY leveldb.IteratorWrapper.IteratorWrapper (),table\iterator_wrapper.hpp,"explicit IteratorWrapper(Iterator* iter): iter_(NULL) {
    Set(iter);
  }",20.0,22.0,3.0,3.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
2146,71639,~IteratorWrapper,1,leveldb.IteratorWrapper.~IteratorWrapper,ANY leveldb.IteratorWrapper.~IteratorWrapper (),table\iterator_wrapper.hpp,~IteratorWrapper() { delete iter_; },23.0,23.0,3.0,38.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,ANY
2147,71645,iter,1,leveldb.IteratorWrapper.iter,Iterator leveldb.IteratorWrapper.iter (),table\iterator_wrapper.hpp,Iterator* iter() const { return iter_; },24.0,24.0,3.0,42.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,Iterator
2148,71651,Set,1,leveldb.IteratorWrapper.Set,void leveldb.IteratorWrapper.Set (Iterator*),table\iterator_wrapper.hpp,"void Set(Iterator* iter) {
    delete iter_;
    iter_ = iter;
    if (iter_ == NULL) {
      valid_ = false;
    } else {
      Update();
    }
  }",28.0,36.0,3.0,3.0,9.0,4,3,6,4,0,4,2,2,1,0,,0,4,2,1,1,void
2149,71672,Valid,1,leveldb.IteratorWrapper.Valid,bool leveldb.IteratorWrapper.Valid (),table\iterator_wrapper.hpp,bool Valid() const        { return valid_; },40.0,40.0,3.0,46.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,bool
2150,71678,key,1,leveldb.IteratorWrapper.key,Slice leveldb.IteratorWrapper.key (),table\iterator_wrapper.hpp,Slice key() const         { assert(Valid()); return key_; },41.0,41.0,3.0,61.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,Slice
2151,71686,value,1,leveldb.IteratorWrapper.value,Slice leveldb.IteratorWrapper.value (),table\iterator_wrapper.hpp,Slice value() const       { assert(Valid()); return iter_->value(); },42.0,42.0,3.0,71.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,Slice
2152,71697,status,1,leveldb.IteratorWrapper.status,Status leveldb.IteratorWrapper.status (),table\iterator_wrapper.hpp,Status status() const     { assert(iter_); return iter_->status(); },44.0,44.0,3.0,70.0,1.0,1,1,2,1,0,2,1,1,0,0,,0,2,0,0,0,Status
2153,71708,Next,1,leveldb.IteratorWrapper.Next,void leveldb.IteratorWrapper.Next (),table\iterator_wrapper.hpp,void Next()               { assert(iter_); iter_->Next();        Update(); },45.0,45.0,3.0,78.0,1.0,1,1,2,1,0,2,1,1,0,0,,0,2,0,0,0,void
2154,71719,Prev,1,leveldb.IteratorWrapper.Prev,void leveldb.IteratorWrapper.Prev (),table\iterator_wrapper.hpp,void Prev()               { assert(iter_); iter_->Prev();        Update(); },46.0,46.0,3.0,78.0,1.0,1,1,2,1,0,2,1,1,0,0,,0,2,0,0,0,void
2155,71730,Seek,1,leveldb.IteratorWrapper.Seek,void leveldb.IteratorWrapper.Seek (Slice),table\iterator_wrapper.hpp,void Seek(const Slice& k) { assert(iter_); iter_->Seek(k);       Update(); },47.0,47.0,3.0,78.0,1.0,1,1,3,2,0,2,1,1,0,0,,0,2,2,1,1,void
2156,71743,SeekToFirst,1,leveldb.IteratorWrapper.SeekToFirst,void leveldb.IteratorWrapper.SeekToFirst (),table\iterator_wrapper.hpp,void SeekToFirst()        { assert(iter_); iter_->SeekToFirst(); Update(); },48.0,48.0,3.0,78.0,1.0,1,1,2,1,0,2,1,1,0,0,,0,2,0,0,0,void
2157,71754,SeekToLast,1,leveldb.IteratorWrapper.SeekToLast,void leveldb.IteratorWrapper.SeekToLast (),table\iterator_wrapper.hpp,void SeekToLast()         { assert(iter_); iter_->SeekToLast();  Update(); },49.0,49.0,3.0,78.0,1.0,1,1,2,1,0,2,1,1,0,0,,0,2,0,0,0,void
2158,71765,Update,1,leveldb.IteratorWrapper.Update,void leveldb.IteratorWrapper.Update (),table\iterator_wrapper.hpp,"void Update() {
    valid_ = iter_->Valid();
    if (valid_) {
      key_ = iter_->key();
    }
  }",52.0,57.0,3.0,3.0,6.0,4,2,5,3,0,5,2,2,1,0,,0,5,0,0,0,void
2159,71803,MergingIterator,1,leveldb.anonymous_namespace_2.MergingIterator.MergingIterator,"ANY leveldb.anonymous_namespace_2.MergingIterator.MergingIterator (Comparator*,Iterator**,int)",table\merger.cc,"MergingIterator(const Comparator* comparator, Iterator** children, int n)
      : comparator_(comparator),
        children_(new IteratorWrapper[n]),
        n_(n),
        current_(NULL),
        direction_(kForward) {
    for (int i = 0; i < n; i++) {
      children_[i].Set(children[i]);
    }
  }",16.0,25.0,3.0,3.0,10.0,5,4,7,4,0,1,2,2,0,0,,0,1,6,3,3,ANY
2160,71831,~MergingIterator,1,leveldb.anonymous_namespace_3.MergingIterator.~MergingIterator,ANY leveldb.anonymous_namespace_3.MergingIterator.~MergingIterator (),table\merger.cc,"virtual ~MergingIterator() {
    delete[] children_;
  }",27.0,29.0,3.0,3.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,ANY
2161,71837,Valid,1,leveldb.anonymous_namespace_4.MergingIterator.Valid,bool leveldb.anonymous_namespace_4.MergingIterator.Valid (),table\merger.cc,"virtual bool Valid() const {
    return (current_ != NULL);
  }",31.0,33.0,3.0,3.0,3.0,1,1,2,2,0,1,1,1,0,0,,0,1,0,0,0,bool
2162,71845,SeekToFirst,1,leveldb.anonymous_namespace_5.MergingIterator.SeekToFirst,void leveldb.anonymous_namespace_5.MergingIterator.SeekToFirst (),table\merger.cc,"virtual void SeekToFirst() {
    for (int i = 0; i < n_; i++) {
      children_[i].SeekToFirst();
    }
    FindSmallest();
    direction_ = kForward;
  }",35.0,41.0,3.0,3.0,7.0,5,4,7,5,0,4,2,2,1,0,,0,4,0,0,0,void
2163,71871,SeekToLast,1,leveldb.anonymous_namespace_6.MergingIterator.SeekToLast,void leveldb.anonymous_namespace_6.MergingIterator.SeekToLast (),table\merger.cc,"virtual void SeekToLast() {
    for (int i = 0; i < n_; i++) {
      children_[i].SeekToLast();
    }
    FindLargest();
    direction_ = kReverse;
  }",43.0,49.0,3.0,3.0,7.0,5,4,7,5,0,4,2,2,1,0,,0,4,0,0,0,void
2164,71897,Seek,1,leveldb.anonymous_namespace_7.MergingIterator.Seek,void leveldb.anonymous_namespace_7.MergingIterator.Seek (Slice),table\merger.cc,"virtual void Seek(const Slice& target) {
    for (int i = 0; i < n_; i++) {
      children_[i].Seek(target);
    }
    FindSmallest();
    direction_ = kForward;
  }",51.0,57.0,3.0,3.0,7.0,5,4,8,6,0,4,2,2,1,0,,0,4,2,1,1,void
2165,71925,Next,1,leveldb.anonymous_namespace_8.MergingIterator.Next,void leveldb.anonymous_namespace_8.MergingIterator.Next (),table\merger.cc,"virtual void Next() {
    assert(Valid());

    // Ensure that all children are positioned after key().
    // If we are moving in the forward direction, it is already
    // true for all of the non-current_ children since current_ is
    // the smallest child and key() == current_->key().  Otherwise,
    // we explicitly position the non-current_ children.
    if (direction_ != kForward) {
      for (int i = 0; i < n_; i++) {
        IteratorWrapper* child = &children_[i];
        if (child != current_) {
          child->Seek(key());
          if (child->Valid() &&
              comparator_->Compare(key(), child->key()) == 0) {
            child->Next();
          }
        }
      }
      direction_ = kForward;
    }

    current_->Next();
    FindSmallest();
  }",59.0,83.0,3.0,3.0,25.0,16,8,18,8,0,9,5,11,5,0,,0,9,0,0,0,void
2166,71995,Prev,1,leveldb.anonymous_namespace_12.MergingIterator.Prev,void leveldb.anonymous_namespace_12.MergingIterator.Prev (),table\merger.cc,"virtual void Prev() {
    assert(Valid());

    // Ensure that all children are positioned before key().
    // If we are moving in the reverse direction, it is already
    // true for all of the non-current_ children since current_ is
    // the largest child and key() == current_->key().  Otherwise,
    // we explicitly position the non-current_ children.
    if (direction_ != kReverse) {
      for (int i = 0; i < n_; i++) {
        IteratorWrapper* child = &children_[i];
        if (child != current_) {
          child->Seek(key());
          if (child->Valid()) {
            // Child is at first entry >= key().  Step back one to be < key()
            child->Prev();
          } else {
            // Child has no entries >= key().  Position at last entry.
            child->SeekToLast();
          }
        }
      }
      direction_ = kReverse;
    }

    current_->Prev();
    FindLargest();
  }",85.0,112.0,3.0,3.0,28.0,12,6,16,7,0,8,5,11,4,0,,0,8,0,0,0,void
2167,72059,key,1,leveldb.anonymous_namespace_15.MergingIterator.key,Slice leveldb.anonymous_namespace_15.MergingIterator.key (),table\merger.cc,"virtual Slice key() const {
    assert(Valid());
    return current_->key();
  }",114.0,117.0,3.0,3.0,4.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,Slice
2168,72070,value,1,leveldb.anonymous_namespace_17.MergingIterator.value,Slice leveldb.anonymous_namespace_17.MergingIterator.value (),table\merger.cc,"virtual Slice value() const {
    assert(Valid());
    return current_->value();
  }",119.0,122.0,3.0,3.0,4.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,Slice
2169,72081,status,1,leveldb.anonymous_namespace_19.MergingIterator.status,Status leveldb.anonymous_namespace_19.MergingIterator.status (),table\merger.cc,"virtual Status status() const {
    Status status;
    for (int i = 0; i < n_; i++) {
      status = children_[i].status();
      if (!status.ok()) {
        break;
      }
    }
    return status;
  }",124.0,133.0,3.0,3.0,10.0,7,5,8,4,0,2,4,4,1,0,,0,2,0,0,0,Status
2170,72116,FindSmallest,1,leveldb.anonymous_namespace_20.MergingIterator.FindSmallest,void leveldb.anonymous_namespace_20.MergingIterator.FindSmallest (),table\merger.cc,void FindSmallest();,136.0,136.0,8.0,21.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2171,72120,FindLargest,1,leveldb.anonymous_namespace_21.MergingIterator.FindLargest,void leveldb.anonymous_namespace_21.MergingIterator.FindLargest (),table\merger.cc,void FindLargest();,137.0,137.0,8.0,20.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2172,72132,FindSmallest,1,leveldb.anonymous_namespace_23.MergingIterator.FindSmallest,void leveldb.anonymous_namespace_23.MergingIterator.FindSmallest (),table\merger.cc,"void MergingIterator::FindSmallest() {
  IteratorWrapper* smallest = NULL;
  for (int i = 0; i < n_; i++) {
    IteratorWrapper* child = &children_[i];
    if (child->Valid()) {
      if (smallest == NULL) {
        smallest = child;
      } else if (comparator_->Compare(child->key(), smallest->key()) < 0) {
        smallest = child;
      }
    }
  }
  current_ = smallest;
}",155.0,168.0,1.0,1.0,14.0,10,6,15,7,0,0,4,7,0,0,,0,0,0,0,0,void
2173,72197,FindLargest,1,leveldb.anonymous_namespace_24.MergingIterator.FindLargest,void leveldb.anonymous_namespace_24.MergingIterator.FindLargest (),table\merger.cc,"void MergingIterator::FindLargest() {
  IteratorWrapper* largest = NULL;
  for (int i = n_-1; i >= 0; i--) {
    IteratorWrapper* child = &children_[i];
    if (child->Valid()) {
      if (largest == NULL) {
        largest = child;
      } else if (comparator_->Compare(child->key(), largest->key()) > 0) {
        largest = child;
      }
    }
  }
  current_ = largest;
}",170.0,183.0,1.0,1.0,14.0,11,7,15,7,0,0,4,7,0,0,,0,0,0,0,0,void
2174,72264,NewMergingIterator,1,leveldb.NewMergingIterator,"Iterator leveldb.NewMergingIterator (Comparator*,Iterator**,int)",table\merger.cc,"Iterator* NewMergingIterator(const Comparator* cmp, Iterator** list, int n) {
  assert(n >= 0);
  if (n == 0) {
    return NewEmptyIterator();
  } else if (n == 1) {
    return list[0];
  } else {
    return new MergingIterator(cmp, list, n);
  }
}",186.0,195.0,1.0,1.0,10.0,2,2,2,1,0,0,2,2,0,0,,0,0,6,3,3,Iterator
2175,72345,~Rep,1,leveldb.Rep.~Rep,ANY leveldb.Rep.~Rep (),table\table.cc,"~Rep() {
    delete filter;
    delete [] filter_data;
    delete index_block;
  }",21.0,25.0,3.0,3.0,5.0,3,1,3,3,0,3,1,1,0,0,,0,3,0,0,0,ANY
2176,72748,DeleteBlock,1,leveldb.DeleteBlock,"void leveldb.DeleteBlock (void*,void*)",table\table.cc,"static void DeleteBlock(void* arg, void* ignored) {
  delete reinterpret_cast<Block*>(arg);
}",147.0,149.0,1.0,1.0,3.0,2,2,1,1,0,0,1,1,0,0,,0,0,4,2,2,void
2177,72758,DeleteCachedBlock,1,leveldb.DeleteCachedBlock,"void leveldb.DeleteCachedBlock (Slice,void*)",table\table.cc,"static void DeleteCachedBlock(const Slice& key, void* value) {
  Block* block = reinterpret_cast<Block*>(value);
  delete block;
}",151.0,154.0,1.0,1.0,4.0,3,3,3,2,0,0,1,1,0,0,,0,0,4,2,2,void
2178,72772,ReleaseBlock,1,leveldb.ReleaseBlock,"void leveldb.ReleaseBlock (void*,void*)",table\table.cc,"static void ReleaseBlock(void* arg, void* h) {
  Cache* cache = reinterpret_cast<Cache*>(arg);
  Cache::Handle* handle = reinterpret_cast<Cache::Handle*>(h);
  cache->Release(handle);
}",156.0,160.0,1.0,1.0,5.0,5,3,6,4,0,0,1,1,0,0,,0,0,4,2,2,void
2179,73303,Rep,1,leveldb.Rep.Rep,"ANY leveldb.Rep.Rep (Options,WritableFile*)",table\table_builder.cc,"Rep(const Options& opt, WritableFile* f)
      : options(opt),
        index_block_options(opt),
        file(f),
        offset(0),
        data_block(&options),
        index_block(&index_block_options),
        num_entries(0),
        closed(false),
        filter_block(opt.filter_policy == NULL ? NULL
                     : new FilterBlockBuilder(opt.filter_policy)),
        pending_index_entry(false) {
    index_block_options.block_restart_interval = 1;
  }",47.0,60.0,3.0,3.0,14.0,2,2,1,1,0,1,1,1,0,0,,0,1,4,2,2,ANY
2180,74115,Reverse,1,leveldb.Reverse,string leveldb.Reverse (Slice),table\table_test.cc,"static std::string Reverse(const Slice& key) {
  std::string str(key.ToString());
  std::string rev("""");
  for (std::string::reverse_iterator rit = str.rbegin();
       rit != str.rend(); ++rit) {
    rev.push_back(*rit);
  }
  return rev;
}",27.0,35.0,1.0,1.0,9.0,7,4,8,4,0,0,2,2,0,0,,0,0,2,1,1,string
2181,74157,Name,1,leveldb.anonymous_namespace_2.ReverseKeyComparator.Name,const char* leveldb.anonymous_namespace_2.ReverseKeyComparator.Name (),table\table_test.cc,"virtual const char* Name() const {
    return ""leveldb.ReverseBytewiseComparator"";
  }",40.0,42.0,3.0,3.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,const char*
2182,74163,Compare,1,leveldb.anonymous_namespace_3.ReverseKeyComparator.Compare,"int leveldb.anonymous_namespace_3.ReverseKeyComparator.Compare (Slice,Slice)",table\table_test.cc,"virtual int Compare(const Slice& a, const Slice& b) const {
    return BytewiseComparator()->Compare(Reverse(a), Reverse(b));
  }",44.0,46.0,3.0,3.0,3.0,1,1,2,2,0,0,1,1,0,0,,0,0,4,2,2,int
2183,74178,FindShortestSeparator,1,leveldb.anonymous_namespace_4.ReverseKeyComparator.FindShortestSeparator,"void leveldb.anonymous_namespace_4.ReverseKeyComparator.FindShortestSeparator (ANY*,Slice)",table\table_test.cc,"virtual void FindShortestSeparator(
      std::string* start,
      const Slice& limit) const {
    std::string s = Reverse(*start);
    std::string l = Reverse(limit);
    BytewiseComparator()->FindShortestSeparator(&s, l);
    *start = Reverse(s);
  }",48.0,55.0,3.0,3.0,8.0,7,4,8,4,0,0,1,1,0,0,,0,0,4,2,2,void
2184,74207,FindShortSuccessor,1,leveldb.anonymous_namespace_5.ReverseKeyComparator.FindShortSuccessor,void leveldb.anonymous_namespace_5.ReverseKeyComparator.FindShortSuccessor (ANY*),table\table_test.cc,"virtual void FindShortSuccessor(std::string* key) const {
    std::string s = Reverse(*key);
    BytewiseComparator()->FindShortSuccessor(&s);
    *key = Reverse(s);
  }",57.0,61.0,3.0,3.0,5.0,6,4,5,2,0,0,1,1,0,0,,0,0,2,1,1,void
2185,74230,Increment,1,leveldb.Increment,"void leveldb.Increment (Comparator*,ANY*)",table\table_test.cc,"static void Increment(const Comparator* cmp, std::string* key) {
  if (cmp == BytewiseComparator()) {
    key->push_back('\0');
  } else {
    assert(cmp == &reverse_key_comparator);
    std::string rev = Reverse(*key);
    rev.push_back('\0');
    *key = Reverse(rev);
  }
}",66.0,75.0,1.0,1.0,10.0,2,2,2,2,0,0,2,2,0,0,,0,0,4,2,2,void
2186,74272,STLLessThan,1,leveldb.anonymous_namespace_8.STLLessThan.STLLessThan,ANY leveldb.anonymous_namespace_8.STLLessThan.STLLessThan (),table\table_test.cc,STLLessThan() : cmp(BytewiseComparator()) { },82.0,82.0,3.0,47.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
2187,74276,STLLessThan,1,leveldb.anonymous_namespace_9.STLLessThan.STLLessThan,ANY leveldb.anonymous_namespace_9.STLLessThan.STLLessThan (Comparator*),table\table_test.cc,STLLessThan(const Comparator* c) : cmp(c) { },83.0,83.0,3.0,47.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
2188,74281,operator (),1,leveldb.anonymous_namespace_10.STLLessThan.operator (),"bool leveldb.anonymous_namespace_10.STLLessThan.operator () (ANY,ANY)",table\table_test.cc,"bool operator()(const std::string& a, const std::string& b) const {
    return cmp->Compare(Slice(a), Slice(b)) < 0;
  }",84.0,86.0,3.0,3.0,3.0,2,2,3,3,0,0,1,1,0,0,,0,0,4,2,2,bool
2189,74299,~StringSink,1,leveldb.StringSink.~StringSink,ANY leveldb.StringSink.~StringSink (),table\table_test.cc,~StringSink() { },92.0,92.0,3.0,19.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
2190,74303,contents,1,leveldb.StringSink.contents,string leveldb.StringSink.contents (),table\table_test.cc,const std::string& contents() const { return contents_; },94.0,94.0,3.0,59.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,string
2191,74309,Close,1,leveldb.StringSink.Close,Status leveldb.StringSink.Close (),table\table_test.cc,virtual Status Close() { return Status::OK(); },96.0,96.0,3.0,49.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,0,0,0,0,Status
2192,74318,Flush,1,leveldb.StringSink.Flush,Status leveldb.StringSink.Flush (),table\table_test.cc,virtual Status Flush() { return Status::OK(); },97.0,97.0,3.0,49.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,0,0,0,0,Status
2193,74327,Sync,1,leveldb.StringSink.Sync,Status leveldb.StringSink.Sync (),table\table_test.cc,virtual Status Sync() { return Status::OK(); },98.0,98.0,3.0,48.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,0,0,0,0,Status
2194,74336,Append,1,leveldb.StringSink.Append,Status leveldb.StringSink.Append (Slice),table\table_test.cc,"virtual Status Append(const Slice& data) {
    contents_.append(data.data(), data.size());
    return Status::OK();
  }",100.0,103.0,3.0,3.0,4.0,4,1,4,3,0,2,1,1,0,0,,0,1,2,1,1,Status
2195,74360,StringSource,1,leveldb.StringSource.StringSource,ANY leveldb.StringSource.StringSource (Slice),table\table_test.cc,"StringSource(const Slice& contents)
      : contents_(contents.data(), contents.size()) {
  }",112.0,114.0,3.0,3.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
2196,74365,~StringSource,1,leveldb.StringSource.~StringSource,ANY leveldb.StringSource.~StringSource (),table\table_test.cc,virtual ~StringSource() { },116.0,116.0,3.0,29.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
2197,74369,Size,1,leveldb.StringSource.Size,uint64_t leveldb.StringSource.Size (),table\table_test.cc,uint64_t Size() const { return contents_.size(); },118.0,118.0,3.0,52.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,uint64_t
2198,74378,Read,1,leveldb.StringSource.Read,"Status leveldb.StringSource.Read (uint64_t,size_t,Slice*,char*)",table\table_test.cc,"virtual Status Read(uint64_t offset, size_t n, Slice* result,
                       char* scratch) const {
    if (offset > contents_.size()) {
      return Status::InvalidArgument(""invalid Read offset"");
    }
    if (offset + n > contents_.size()) {
      n = contents_.size() - offset;
    }
    memcpy(scratch, &contents_[offset], n);
    *result = Slice(scratch, n);
    return Status::OK();
  }",120.0,131.0,3.0,3.0,12.0,14,8,17,6,0,6,3,3,2,1,,0,4,8,4,4,Status
2199,74439,Constructor,1,leveldb.Constructor.Constructor,ANY leveldb.Constructor.Constructor (Comparator*),table\table_test.cc,explicit Constructor(const Comparator* cmp) : data_(STLLessThan(cmp)) { },143.0,143.0,3.0,75.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
2200,74444,~Constructor,1,leveldb.Constructor.~Constructor,ANY leveldb.Constructor.~Constructor (),table\table_test.cc,virtual ~Constructor() { },144.0,144.0,3.0,28.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
2201,74448,Add,1,leveldb.Constructor.Add,"void leveldb.Constructor.Add (ANY,Slice)",table\table_test.cc,"void Add(const std::string& key, const Slice& value) {
    data_[key] = value.ToString();
  }",146.0,148.0,3.0,3.0,3.0,3,3,3,3,0,1,1,1,0,0,,0,1,4,2,2,void
2202,74462,Finish,1,leveldb.Constructor.Finish,"void leveldb.Constructor.Finish (Options,ANY*,KVMap*)",table\table_test.cc,"void Finish(const Options& options,
              std::vector<std::string>* keys,
              KVMap* kvmap) {
    *kvmap = data_;
    keys->clear();
    for (KVMap::const_iterator it = data_.begin();
         it != data_.end();
         ++it) {
      keys->push_back(it->first);
    }
    data_.clear();
    Status s = FinishImpl(options, *kvmap);
    ASSERT_TRUE(s.ok()) << s.ToString();
  }",153.0,166.0,3.0,4.0,14.0,19,6,18,7,0,4,2,2,1,0,,0,4,6,3,3,void
2203,74540,FinishImpl,1,leveldb.Constructor.FinishImpl,"Status leveldb.Constructor.FinishImpl (Options,KVMap)",table\table_test.cc,"virtual Status FinishImpl(const Options& options, const KVMap& data) = 0;",169.0,169.0,18.0,74.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,Status
2204,74546,NewIterator,1,leveldb.Constructor.NewIterator,Iterator* leveldb.Constructor.NewIterator (),table\table_test.cc,virtual Iterator* NewIterator() const = 0;,171.0,171.0,19.0,43.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,Iterator*
2205,74550,data,1,leveldb.Constructor.data,KVMap leveldb.Constructor.data (),table\table_test.cc,virtual const KVMap& data() { return data_; },173.0,173.0,3.0,47.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,KVMap
2206,74556,db,1,leveldb.Constructor.db,DB leveldb.Constructor.db (),table\table_test.cc,virtual DB* db() const { return NULL; },175.0,175.0,3.0,41.0,1.0,0,0,1,1,0,0,1,1,0,0,,0,0,0,0,0,DB
2207,74564,BlockConstructor,1,leveldb.BlockConstructor.BlockConstructor,ANY leveldb.BlockConstructor.BlockConstructor (Comparator*),table\table_test.cc,"explicit BlockConstructor(const Comparator* cmp)
      : Constructor(cmp),
        comparator_(cmp),
        block_(NULL) { }",183.0,186.0,3.0,24.0,4.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
2208,74569,~BlockConstructor,1,leveldb.BlockConstructor.~BlockConstructor,ANY leveldb.BlockConstructor.~BlockConstructor (),table\table_test.cc,"~BlockConstructor() {
    delete block_;
  }",187.0,189.0,3.0,3.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,ANY
2209,74575,FinishImpl,1,leveldb.BlockConstructor.FinishImpl,"Status leveldb.BlockConstructor.FinishImpl (Options,KVMap)",table\table_test.cc,"virtual Status FinishImpl(const Options& options, const KVMap& data) {
    delete block_;
    block_ = NULL;
    BlockBuilder builder(&options);

    for (KVMap::const_iterator it = data.begin();
         it != data.end();
         ++it) {
      builder.Add(it->first, it->second);
    }
    // Open the block
    data_ = builder.Finish().ToString();
    BlockContents contents;
    contents.data = data_;
    contents.cachable = false;
    contents.heap_allocated = false;
    block_ = new Block(contents);
    return Status::OK();
  }",190.0,208.0,3.0,3.0,19.0,22,7,21,10,0,9,2,2,0,0,,0,8,4,2,2,Status
2210,74653,NewIterator,1,leveldb.BlockConstructor.NewIterator,Iterator leveldb.BlockConstructor.NewIterator (),table\table_test.cc,"virtual Iterator* NewIterator() const {
    return block_->NewIterator(comparator_);
  }",209.0,211.0,3.0,3.0,3.0,1,1,2,2,0,2,1,1,0,0,,0,2,0,0,0,Iterator
2211,74671,TableConstructor,1,leveldb.TableConstructor.TableConstructor,ANY leveldb.TableConstructor.TableConstructor (Comparator*),table\table_test.cc,"TableConstructor(const Comparator* cmp)
      : Constructor(cmp),
        source_(NULL), table_(NULL) {
  }",223.0,226.0,3.0,3.0,4.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
2212,74676,~TableConstructor,1,leveldb.TableConstructor.~TableConstructor,ANY leveldb.TableConstructor.~TableConstructor (),table\table_test.cc,"~TableConstructor() {
    Reset();
  }",227.0,229.0,3.0,3.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
2213,74681,FinishImpl,1,leveldb.TableConstructor.FinishImpl,"Status leveldb.TableConstructor.FinishImpl (Options,KVMap)",table\table_test.cc,"virtual Status FinishImpl(const Options& options, const KVMap& data) {
    Reset();
    StringSink sink;
    TableBuilder builder(options, &sink);

    for (KVMap::const_iterator it = data.begin();
         it != data.end();
         ++it) {
      builder.Add(it->first, it->second);
      ASSERT_TRUE(builder.status().ok());
    }
    Status s = builder.Finish();
    ASSERT_TRUE(s.ok()) << s.ToString();

    ASSERT_EQ(sink.contents().size(), builder.FileSize());

    // Open the table
    source_ = new StringSource(sink.contents());
    Options table_options;
    table_options.comparator = options.comparator;
    return Table::Open(table_options, source_, sink.contents().size(), &table_);
  }",230.0,251.0,3.0,6.0,22.0,43,7,36,14,0,5,2,2,0,0,,0,5,4,2,2,Status
2214,74851,NewIterator,1,leveldb.TableConstructor.NewIterator,Iterator leveldb.TableConstructor.NewIterator (),table\table_test.cc,"virtual Iterator* NewIterator() const {
    return table_->NewIterator(ReadOptions());
  }",253.0,255.0,3.0,3.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,Iterator
2215,74861,ApproximateOffsetOf,1,leveldb.TableConstructor.ApproximateOffsetOf,uint64_t leveldb.TableConstructor.ApproximateOffsetOf (Slice),table\table_test.cc,"uint64_t ApproximateOffsetOf(const Slice& key) const {
    return table_->ApproximateOffsetOf(key);
  }",257.0,259.0,3.0,3.0,3.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,uint64_t
2216,74872,Reset,1,leveldb.TableConstructor.Reset,void leveldb.TableConstructor.Reset (),table\table_test.cc,"void Reset() {
    delete table_;
    delete source_;
    table_ = NULL;
    source_ = NULL;
  }",262.0,267.0,3.0,3.0,6.0,4,2,6,3,0,4,1,1,0,0,,0,4,0,0,0,void
2217,74893,KeyConvertingIterator,1,leveldb.KeyConvertingIterator.KeyConvertingIterator,ANY leveldb.KeyConvertingIterator.KeyConvertingIterator (Iterator*),table\table_test.cc,explicit KeyConvertingIterator(Iterator* iter) : iter_(iter) { },278.0,278.0,3.0,66.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
2218,74898,~KeyConvertingIterator,1,leveldb.KeyConvertingIterator.~KeyConvertingIterator,ANY leveldb.KeyConvertingIterator.~KeyConvertingIterator (),table\table_test.cc,virtual ~KeyConvertingIterator() { delete iter_; },279.0,279.0,3.0,52.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,ANY
2219,74904,Valid,1,leveldb.KeyConvertingIterator.Valid,bool leveldb.KeyConvertingIterator.Valid (),table\table_test.cc,virtual bool Valid() const { return iter_->Valid(); },280.0,280.0,3.0,55.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,bool
2220,74913,Seek,1,leveldb.KeyConvertingIterator.Seek,void leveldb.KeyConvertingIterator.Seek (Slice),table\table_test.cc,"virtual void Seek(const Slice& target) {
    ParsedInternalKey ikey(target, kMaxSequenceNumber, kTypeValue);
    std::string encoded;
    AppendInternalKey(&encoded, ikey);
    iter_->Seek(encoded);
  }",281.0,286.0,3.0,3.0,6.0,2,2,7,6,0,1,1,1,0,0,,0,1,2,1,1,void
2221,74933,SeekToFirst,1,leveldb.KeyConvertingIterator.SeekToFirst,void leveldb.KeyConvertingIterator.SeekToFirst (),table\table_test.cc,virtual void SeekToFirst() { iter_->SeekToFirst(); },287.0,287.0,3.0,54.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,void
2222,74941,SeekToLast,1,leveldb.KeyConvertingIterator.SeekToLast,void leveldb.KeyConvertingIterator.SeekToLast (),table\table_test.cc,virtual void SeekToLast() { iter_->SeekToLast(); },288.0,288.0,3.0,52.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,void
2223,74949,Next,1,leveldb.KeyConvertingIterator.Next,void leveldb.KeyConvertingIterator.Next (),table\table_test.cc,virtual void Next() { iter_->Next(); },289.0,289.0,3.0,40.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,void
2224,74957,Prev,1,leveldb.KeyConvertingIterator.Prev,void leveldb.KeyConvertingIterator.Prev (),table\table_test.cc,virtual void Prev() { iter_->Prev(); },290.0,290.0,3.0,40.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,void
2225,74965,key,1,leveldb.KeyConvertingIterator.key,Slice leveldb.KeyConvertingIterator.key (),table\table_test.cc,"virtual Slice key() const {
    assert(Valid());
    ParsedInternalKey key;
    if (!ParseInternalKey(iter_->key(), &key)) {
      status_ = Status::Corruption(""malformed internal key"");
      return Slice(""corrupted key"");
    }
    return key.user_key;
  }",292.0,300.0,3.0,3.0,9.0,6,5,5,4,0,4,2,2,1,1,,0,4,0,0,0,Slice
2226,74996,value,1,leveldb.KeyConvertingIterator.value,Slice leveldb.KeyConvertingIterator.value (),table\table_test.cc,virtual Slice value() const { return iter_->value(); },302.0,302.0,3.0,56.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,Slice
2227,75005,status,1,leveldb.KeyConvertingIterator.status,Status leveldb.KeyConvertingIterator.status (),table\table_test.cc,"virtual Status status() const {
    return status_.ok() ? iter_->status() : status_;
  }",303.0,305.0,3.0,3.0,3.0,3,3,3,2,0,3,1,1,0,0,,0,3,0,0,0,Status
2228,75027,operator =,1,leveldb.KeyConvertingIterator.operator =,void leveldb.KeyConvertingIterator.operator = (KeyConvertingIterator),table\table_test.cc,void operator=(const KeyConvertingIterator&);,313.0,313.0,8.0,46.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
2229,75033,MemTableConstructor,1,leveldb.MemTableConstructor.MemTableConstructor,ANY leveldb.MemTableConstructor.MemTableConstructor (Comparator*),table\table_test.cc,"explicit MemTableConstructor(const Comparator* cmp)
      : Constructor(cmp),
        internal_comparator_(cmp) {
    memtable_ = new MemTable(internal_comparator_);
    memtable_->Ref();
  }",318.0,323.0,3.0,3.0,6.0,3,3,4,3,0,3,1,1,0,0,,0,3,2,1,1,ANY
2230,75047,~MemTableConstructor,1,leveldb.MemTableConstructor.~MemTableConstructor,ANY leveldb.MemTableConstructor.~MemTableConstructor (),table\table_test.cc,"~MemTableConstructor() {
    memtable_->Unref();
  }",324.0,326.0,3.0,3.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,ANY
2231,75055,FinishImpl,1,leveldb.MemTableConstructor.FinishImpl,"Status leveldb.MemTableConstructor.FinishImpl (Options,KVMap)",table\table_test.cc,"virtual Status FinishImpl(const Options& options, const KVMap& data) {
    memtable_->Unref();
    memtable_ = new MemTable(internal_comparator_);
    memtable_->Ref();
    int seq = 1;
    for (KVMap::const_iterator it = data.begin();
         it != data.end();
         ++it) {
      memtable_->Add(seq, kTypeValue, it->first, it->second);
      seq++;
    }
    return Status::OK();
  }",327.0,339.0,3.0,3.0,13.0,14,6,17,8,0,6,2,2,0,0,,0,5,4,2,2,Status
2232,75115,NewIterator,1,leveldb.MemTableConstructor.NewIterator,Iterator leveldb.MemTableConstructor.NewIterator (),table\table_test.cc,"virtual Iterator* NewIterator() const {
    return new KeyConvertingIterator(memtable_->NewIterator());
  }",340.0,342.0,3.0,3.0,3.0,2,2,2,2,0,1,1,1,0,0,,0,1,0,0,0,Iterator
2233,75129,DBConstructor,1,leveldb.DBConstructor.DBConstructor,ANY leveldb.DBConstructor.DBConstructor (Comparator*),table\table_test.cc,"explicit DBConstructor(const Comparator* cmp)
      : Constructor(cmp),
        comparator_(cmp) {
    db_ = NULL;
    NewDB();
  }",351.0,356.0,3.0,3.0,6.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,ANY
2234,75138,~DBConstructor,1,leveldb.DBConstructor.~DBConstructor,ANY leveldb.DBConstructor.~DBConstructor (),table\table_test.cc,"~DBConstructor() {
    delete db_;
  }",357.0,359.0,3.0,3.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,ANY
2235,75144,FinishImpl,1,leveldb.DBConstructor.FinishImpl,"Status leveldb.DBConstructor.FinishImpl (Options,KVMap)",table\table_test.cc,"virtual Status FinishImpl(const Options& options, const KVMap& data) {
    delete db_;
    db_ = NULL;
    NewDB();
    for (KVMap::const_iterator it = data.begin();
         it != data.end();
         ++it) {
      WriteBatch batch;
      batch.Put(it->first, it->second);
      ASSERT_TRUE(db_->Write(WriteOptions(), &batch).ok());
    }
    return Status::OK();
  }",360.0,372.0,3.0,6.0,13.0,16,6,15,7,0,4,2,2,0,0,,0,3,4,2,2,Status
2236,75214,NewIterator,1,leveldb.DBConstructor.NewIterator,Iterator leveldb.DBConstructor.NewIterator (),table\table_test.cc,"virtual Iterator* NewIterator() const {
    return db_->NewIterator(ReadOptions());
  }",373.0,375.0,3.0,3.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,Iterator
2237,75224,db,1,leveldb.DBConstructor.db,DB leveldb.DBConstructor.db (),table\table_test.cc,virtual DB* db() const { return db_; },377.0,377.0,3.0,40.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,DB
2238,75230,NewDB,1,leveldb.DBConstructor.NewDB,void leveldb.DBConstructor.NewDB (),table\table_test.cc,"void NewDB() {
    std::string name = test::TmpDir() + ""/table_testdb"";

    Options options;
    options.comparator = comparator_;
    Status status = DestroyDB(name, options);
    ASSERT_TRUE(status.ok()) << status.ToString();

    options.create_if_missing = true;
    options.error_if_exists = true;
    options.write_buffer_size = 10000;  // Something small to force merging
    status = DB::Open(options, name, &db_);
    ASSERT_TRUE(status.ok()) << status.ToString();
  }",380.0,393.0,3.0,4.0,14.0,29,5,25,8,0,6,1,1,0,0,,0,6,0,0,0,void
2239,75424,Harness,1,leveldb.Harness.Harness,ANY leveldb.Harness.Harness (),table\table_test.cc,Harness() : constructor_(NULL) { },439.0,439.0,3.0,36.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
2240,75428,Init,1,leveldb.Harness.Init,void leveldb.Harness.Init (TestArgs),table\table_test.cc,"void Init(const TestArgs& args) {
    delete constructor_;
    constructor_ = NULL;
    options_ = Options();

    options_.block_restart_interval = args.restart_interval;
    // Use shorter block size for tests to exercise block boundary
    // conditions more.
    options_.block_size = 256;
    if (args.reverse_compare) {
      options_.comparator = &reverse_key_comparator;
    }
    switch (args.type) {
      case TABLE_TEST:
        constructor_ = new TableConstructor(options_.comparator);
        break;
      case BLOCK_TEST:
        constructor_ = new BlockConstructor(options_.comparator);
        break;
      case MEMTABLE_TEST:
        constructor_ = new MemTableConstructor(options_.comparator);
        break;
      case DB_TEST:
        constructor_ = new DBConstructor(options_.comparator);
        break;
    }
  }",441.0,467.0,3.0,3.0,27.0,25,5,27,13,0,17,7,3,2,0,,0,17,2,1,1,void
2241,75509,~Harness,1,leveldb.Harness.~Harness,ANY leveldb.Harness.~Harness (),table\table_test.cc,"~Harness() {
    delete constructor_;
  }",469.0,471.0,3.0,3.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,ANY
2242,75515,Add,1,leveldb.Harness.Add,"void leveldb.Harness.Add (ANY,ANY)",table\table_test.cc,"void Add(const std::string& key, const std::string& value) {
    constructor_->Add(key, value);
  }",473.0,475.0,3.0,3.0,3.0,1,1,3,3,0,1,1,1,0,0,,0,1,4,2,2,void
2243,75527,Test,1,leveldb.Harness.Test,void leveldb.Harness.Test (Random*),table\table_test.cc,"void Test(Random* rnd) {
    std::vector<std::string> keys;
    KVMap data;
    constructor_->Finish(options_, &keys, &data);

    TestForwardScan(keys, data);
    TestBackwardScan(keys, data);
    TestRandomAccess(rnd, keys, data);
  }",477.0,485.0,3.0,3.0,9.0,7,5,14,6,0,2,1,1,0,0,,0,2,2,1,1,void
2244,75561,TestForwardScan,1,leveldb.Harness.TestForwardScan,"void leveldb.Harness.TestForwardScan (ANY,KVMap)",table\table_test.cc,"void TestForwardScan(const std::vector<std::string>& keys,
                       const KVMap& data) {
    Iterator* iter = constructor_->NewIterator();
    ASSERT_TRUE(!iter->Valid());
    iter->SeekToFirst();
    for (KVMap::const_iterator model_iter = data.begin();
         model_iter != data.end();
         ++model_iter) {
      ASSERT_EQ(ToString(data, model_iter), ToString(iter));
      iter->Next();
    }
    ASSERT_TRUE(!iter->Valid());
    delete iter;
  }",487.0,500.0,3.0,4.0,14.0,26,6,23,6,0,1,2,2,0,0,,0,1,4,2,2,void
2245,75670,TestBackwardScan,1,leveldb.Harness.TestBackwardScan,"void leveldb.Harness.TestBackwardScan (ANY,KVMap)",table\table_test.cc,"void TestBackwardScan(const std::vector<std::string>& keys,
                        const KVMap& data) {
    Iterator* iter = constructor_->NewIterator();
    ASSERT_TRUE(!iter->Valid());
    iter->SeekToLast();
    for (KVMap::const_reverse_iterator model_iter = data.rbegin();
         model_iter != data.rend();
         ++model_iter) {
      ASSERT_EQ(ToString(data, model_iter), ToString(iter));
      iter->Prev();
    }
    ASSERT_TRUE(!iter->Valid());
    delete iter;
  }",502.0,515.0,3.0,4.0,14.0,26,6,23,6,0,1,2,2,0,0,,0,1,4,2,2,void
2246,75779,TestRandomAccess,1,leveldb.Harness.TestRandomAccess,"void leveldb.Harness.TestRandomAccess (Random*,ANY,KVMap)",table\table_test.cc,"void TestRandomAccess(Random* rnd,
                        const std::vector<std::string>& keys,
                        const KVMap& data) {
    static const bool kVerbose = false;
    Iterator* iter = constructor_->NewIterator();
    ASSERT_TRUE(!iter->Valid());
    KVMap::const_iterator model_iter = data.begin();
    if (kVerbose) fprintf(stderr, ""---\n"");
    for (int i = 0; i < 200; i++) {
      const int toss = rnd->Uniform(5);
      switch (toss) {
        case 0: {
          if (iter->Valid()) {
            if (kVerbose) fprintf(stderr, ""Next\n"");
            iter->Next();
            ++model_iter;
            ASSERT_EQ(ToString(data, model_iter), ToString(iter));
          }
          break;
        }

        case 1: {
          if (kVerbose) fprintf(stderr, ""SeekToFirst\n"");
          iter->SeekToFirst();
          model_iter = data.begin();
          ASSERT_EQ(ToString(data, model_iter), ToString(iter));
          break;
        }

        case 2: {
          std::string...",517.0,585.0,3.0,4.0,69.0,53,8,82,13,0,1,18,35,0,0,,0,1,6,3,3,void
2247,76117,ToString,1,leveldb.Harness.ToString,"string leveldb.Harness.ToString (KVMap,ANY)",table\table_test.cc,"std::string ToString(const Iterator* it) {
    if (!it->Valid()) {
      return ""END"";
    } else {
      return ""'"" + it->key().ToString() + ""->"" + it->value().ToString() + ""'"";
    }
  }",604.0,610.0,3.0,3.0,7.0,2,2,2,2,0,0,2,2,0,0,,0,0,2,1,1,string
2248,76219,PickRandomKey,1,leveldb.Harness.PickRandomKey,"string leveldb.Harness.PickRandomKey (Random*,ANY)",table\table_test.cc,"std::string PickRandomKey(Random* rnd, const std::vector<std::string>& keys) {
    if (keys.empty()) {
      return ""foo"";
    } else {
      const int index = rnd->Uniform(keys.size());
      std::string result = keys[index];
      switch (rnd->Uniform(3)) {
        case 0:
          // Return an existing key
          break;
        case 1: {
          // Attempt to return something smaller than an existing key
          if (result.size() > 0 && result[result.size()-1] > '\0') {
            result[result.size()-1]--;
          }
          break;
        }
        case 2: {
          // Return something larger than an existing key
          Increment(options_.comparator, &result);
          break;
        }
      }
      return result;
    }
  }",612.0,637.0,3.0,3.0,26.0,1,1,1,1,0,0,2,2,0,0,,0,0,4,2,2,string
2249,76306,db,1,leveldb.Harness.db,DB leveldb.Harness.db (),table\table_test.cc,DB* db() const { return constructor_->db(); },640.0,640.0,3.0,47.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,DB
2250,76378,_Run,1,leveldb._Test_ZeroRestartPointsInBlock._Run,void leveldb._Test_ZeroRestartPointsInBlock._Run (),table\table_test.cc,"TEST(Harness, ZeroRestartPointsInBlock) {
  char data[sizeof(uint32_t)];
  memset(data, 0, sizeof(data));
  BlockContents contents;
  contents.data = Slice(data, sizeof(data));
  contents.cachable = false;
  contents.heap_allocated = false;
  Block block(contents);
  Iterator* iter = block.NewIterator(BytewiseComparator());
  iter->SeekToFirst();
  ASSERT_TRUE(!iter->Valid());
  iter->SeekToLast();
  ASSERT_TRUE(!iter->Valid());
  iter->Seek(""foo"");
  ASSERT_TRUE(!iter->Valid());
  delete iter;
}",659.0,675.0,1.0,39.0,17.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2251,76382,_RunIt,1,leveldb._Test_ZeroRestartPointsInBlock._RunIt,void leveldb._Test_ZeroRestartPointsInBlock._RunIt (),table\table_test.cc,"TEST(Harness, ZeroRestartPointsInBlock)",659.0,659.0,1.0,39.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
2252,76534,_Run,1,leveldb._Test_SimpleEmptyKey._Run,void leveldb._Test_SimpleEmptyKey._Run (),table\table_test.cc,"TEST(Harness, SimpleEmptyKey) {
  for (int i = 0; i < kNumTestArgs; i++) {
    Init(kTestArgList[i]);
    Random rnd(test::RandomSeed() + 1);
    Add("""", ""v"");
    Test(&rnd);
  }
}",678.0,685.0,1.0,29.0,8.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2253,76538,_RunIt,1,leveldb._Test_SimpleEmptyKey._RunIt,void leveldb._Test_SimpleEmptyKey._RunIt (),table\table_test.cc,"TEST(Harness, SimpleEmptyKey)",678.0,678.0,1.0,29.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
2254,76597,_Run,1,leveldb._Test_SimpleSingle._Run,void leveldb._Test_SimpleSingle._Run (),table\table_test.cc,"TEST(Harness, SimpleSingle) {
  for (int i = 0; i < kNumTestArgs; i++) {
    Init(kTestArgList[i]);
    Random rnd(test::RandomSeed() + 2);
    Add(""abc"", ""v"");
    Test(&rnd);
  }
}",687.0,694.0,1.0,27.0,8.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2255,76601,_RunIt,1,leveldb._Test_SimpleSingle._RunIt,void leveldb._Test_SimpleSingle._RunIt (),table\table_test.cc,"TEST(Harness, SimpleSingle)",687.0,687.0,1.0,27.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
2256,76660,_Run,1,leveldb._Test_SimpleMulti._Run,void leveldb._Test_SimpleMulti._Run (),table\table_test.cc,"TEST(Harness, SimpleMulti) {
  for (int i = 0; i < kNumTestArgs; i++) {
    Init(kTestArgList[i]);
    Random rnd(test::RandomSeed() + 3);
    Add(""abc"", ""v"");
    Add(""abcd"", ""v"");
    Add(""ac"", ""v2"");
    Test(&rnd);
  }
}",696.0,705.0,1.0,26.0,10.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2257,76664,_RunIt,1,leveldb._Test_SimpleMulti._RunIt,void leveldb._Test_SimpleMulti._RunIt (),table\table_test.cc,"TEST(Harness, SimpleMulti)",696.0,696.0,1.0,26.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
2258,76729,_Run,1,leveldb._Test_SimpleSpecialKey._Run,void leveldb._Test_SimpleSpecialKey._Run (),table\table_test.cc,"TEST(Harness, SimpleSpecialKey) {
  for (int i = 0; i < kNumTestArgs; i++) {
    Init(kTestArgList[i]);
    Random rnd(test::RandomSeed() + 4);
    Add(""\xff\xff"", ""v3"");
    Test(&rnd);
  }
}",707.0,714.0,1.0,31.0,8.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2259,76733,_RunIt,1,leveldb._Test_SimpleSpecialKey._RunIt,void leveldb._Test_SimpleSpecialKey._RunIt (),table\table_test.cc,"TEST(Harness, SimpleSpecialKey)",707.0,707.0,1.0,31.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
2260,76928,_Run,1,leveldb._Test_RandomizedLongDB._Run,void leveldb._Test_RandomizedLongDB._Run (),table\table_test.cc,"TEST(Harness, RandomizedLongDB) {
  Random rnd(test::RandomSeed());
  TestArgs args = { DB_TEST, false, 16 };
  Init(args);
  int num_entries = 100000;
  for (int e = 0; e < num_entries; e++) {
    std::string v;
    Add(test::RandomKey(&rnd, rnd.Skewed(4)),
        test::RandomString(&rnd, rnd.Skewed(5), &v).ToString());
  }
  Test(&rnd);

  // We must have created enough data to force merging
  int files = 0;
  for (int level = 0; level < config::kNumLevels; level++) {
    std::string value;
    char name[100];
    snprintf(name, sizeof(name), ""leveldb.num-files-at-level%d"", level);
    ASSERT_TRUE(db()->GetProperty(name, &value));
    files += atoi(value.c_str());
  }
  ASSERT_GT(files, 0);
}",736.0,758.0,1.0,31.0,23.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2261,76932,_RunIt,1,leveldb._Test_RandomizedLongDB._RunIt,void leveldb._Test_RandomizedLongDB._RunIt (),table\table_test.cc,"TEST(Harness, RandomizedLongDB)",736.0,736.0,1.0,31.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
2262,77096,_Run,1,leveldb._Test_Simple._Run,void leveldb._Test_Simple._Run (),util\arena_test.cc,"TEST(ArenaTest, Simple) {
  std::vector<std::pair<size_t, char*> > allocated;
  Arena arena;
  const int N = 100000;
  size_t bytes = 0;
  Random rnd(301);
  for (int i = 0; i < N; i++) {
    size_t s;
    if (i % (N / 10) == 0) {
      s = i;
    } else {
      s = rnd.OneIn(4000) ? rnd.Uniform(6000) :
          (rnd.OneIn(10) ? rnd.Uniform(100) : rnd.Uniform(20));
    }
    if (s == 0) {
      // Our arena disallows size 0 allocations.
      s = 1;
    }
    char* r;
    if (rnd.OneIn(10)) {
      r = arena.AllocateAligned(s);
    } else {
      r = arena.Allocate(s);
    }

    for (size_t b = 0; b < s; b++) {
      // Fill the ""i""th allocation with a known bit pattern
      r[b] = i % 256;
    }
    bytes += s;
    allocated.push_back(std::make_pair(s, r));
    ASSERT_GE(arena.MemoryUsage(), bytes);
    if (i > N/10) {
      ASSERT_LE(arena.MemoryUsage(), bytes * 1.10);
    }
  }
  for (size_t i = 0; i < allocated.size(); i++) {
    size_t num_bytes = allocated[i].first;
    con...",18.0,62.0,1.0,23.0,45.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2263,77100,_RunIt,1,leveldb._Test_Simple._RunIt,void leveldb._Test_Simple._RunIt (),table\table_test.cc,"TEST(MemTableTest, Simple)",762.0,762.0,1.0,26.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
2264,77316,_Run,1,leveldb._Test_ApproximateOffsetOfPlain._Run,void leveldb._Test_ApproximateOffsetOfPlain._Run (),table\table_test.cc,"TEST(TableTest, ApproximateOffsetOfPlain) {
  TableConstructor c(BytewiseComparator());
  c.Add(""k01"", ""hello"");
  c.Add(""k02"", ""hello2"");
  c.Add(""k03"", std::string(10000, 'x'));
  c.Add(""k04"", std::string(200000, 'x'));
  c.Add(""k05"", std::string(300000, 'x'));
  c.Add(""k06"", ""hello3"");
  c.Add(""k07"", std::string(100000, 'x'));
  std::vector<std::string> keys;
  KVMap kvmap;
  Options options;
  options.block_size = 1024;
  options.compression = kNoCompression;
  c.Finish(options, &keys, &kvmap);

  ASSERT_TRUE(Between(c.ApproximateOffsetOf(""abc""),       0,      0));
  ASSERT_TRUE(Between(c.ApproximateOffsetOf(""k01""),       0,      0));
  ASSERT_TRUE(Between(c.ApproximateOffsetOf(""k01a""),      0,      0));
  ASSERT_TRUE(Between(c.ApproximateOffsetOf(""k02""),       0,      0));
  ASSERT_TRUE(Between(c.ApproximateOffsetOf(""k03""),       0,      0));
  ASSERT_TRUE(Between(c.ApproximateOffsetOf(""k04""),   10000,  11000));
  ASSERT_TRUE(Between(c.ApproximateOffsetOf(""k04a""), 210000, 21100...",800.0,828.0,1.0,41.0,29.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2265,77320,_RunIt,1,leveldb._Test_ApproximateOffsetOfPlain._RunIt,void leveldb._Test_ApproximateOffsetOfPlain._RunIt (),table\table_test.cc,"TEST(TableTest, ApproximateOffsetOfPlain)",800.0,800.0,1.0,41.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
2266,77685,SnappyCompressionSupported,1,leveldb.SnappyCompressionSupported,bool leveldb.SnappyCompressionSupported (),table\table_test.cc,"static bool SnappyCompressionSupported() {
  std::string out;
  Slice in = ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"";
  return port::Snappy_Compress(in.data(), in.size(), &out);
}",830.0,834.0,1.0,1.0,5.0,5,3,5,3,0,0,1,1,0,0,,0,0,0,0,0,bool
2267,77710,_Run,1,leveldb._Test_ApproximateOffsetOfCompressed._Run,void leveldb._Test_ApproximateOffsetOfCompressed._Run (),table\table_test.cc,"TEST(TableTest, ApproximateOffsetOfCompressed) {
  if (!SnappyCompressionSupported()) {
    fprintf(stderr, ""skipping compression tests\n"");
    return;
  }

  Random rnd(301);
  TableConstructor c(BytewiseComparator());
  std::string tmp;
  c.Add(""k01"", ""hello"");
  c.Add(""k02"", test::CompressibleString(&rnd, 0.25, 10000, &tmp));
  c.Add(""k03"", ""hello3"");
  c.Add(""k04"", test::CompressibleString(&rnd, 0.25, 10000, &tmp));
  std::vector<std::string> keys;
  KVMap kvmap;
  Options options;
  options.block_size = 1024;
  options.compression = kSnappyCompression;
  c.Finish(options, &keys, &kvmap);

  // Expected upper and lower bounds of space used by compressible strings.
  static const int kSlop = 1000;  // Compressor effectiveness varies.
  const int expected = 2500;  // 10000 * compression ratio (0.25)
  const int min_z = expected - kSlop;
  const int max_z = expected + kSlop;

  ASSERT_TRUE(Between(c.ApproximateOffsetOf(""abc""), 0, kSlop));
  ASSERT_TRUE(Between(c.ApproximateOffsetO...",836.0,870.0,1.0,46.0,35.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2268,77714,_RunIt,1,leveldb._Test_ApproximateOffsetOfCompressed._RunIt,void leveldb._Test_ApproximateOffsetOfCompressed._RunIt (),table\table_test.cc,"TEST(TableTest, ApproximateOffsetOfCompressed)",836.0,836.0,1.0,46.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
2269,78015,BlockFunction,1,leveldb.anonymous_namespace_1.BlockFunction,"Iterator* leveldb.anonymous_namespace_1.BlockFunction (void*,ReadOptions,Slice)",table\two_level_iterator.cc,"typedef Iterator* (*BlockFunction)(void*, const ReadOptions&, const Slice&);",16.0,16.0,17.0,75.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,Iterator*
2270,78023,TwoLevelIterator,1,leveldb.anonymous_namespace_3.TwoLevelIterator.TwoLevelIterator,"ANY leveldb.anonymous_namespace_3.TwoLevelIterator.TwoLevelIterator (Iterator*,BlockFunction,void*,ReadOptions)",table\two_level_iterator.cc,"TwoLevelIterator(
    Iterator* index_iter,
    BlockFunction block_function,
    void* arg,
    const ReadOptions& options);",20.0,24.0,3.0,31.0,5.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,ANY
2271,78031,~TwoLevelIterator,1,leveldb.anonymous_namespace_4.TwoLevelIterator.~TwoLevelIterator,virtual leveldb.anonymous_namespace_4.TwoLevelIterator.~TwoLevelIterator (),table\two_level_iterator.cc,virtual ~TwoLevelIterator();,26.0,26.0,11.0,29.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,virtual
2272,78035,Seek,1,leveldb.anonymous_namespace_5.TwoLevelIterator.Seek,void leveldb.anonymous_namespace_5.TwoLevelIterator.Seek (Slice),table\two_level_iterator.cc,virtual void Seek(const Slice& target);,28.0,28.0,16.0,40.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
2273,78040,SeekToFirst,1,leveldb.anonymous_namespace_6.TwoLevelIterator.SeekToFirst,void leveldb.anonymous_namespace_6.TwoLevelIterator.SeekToFirst (),table\two_level_iterator.cc,virtual void SeekToFirst();,29.0,29.0,16.0,28.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2274,78044,SeekToLast,1,leveldb.anonymous_namespace_7.TwoLevelIterator.SeekToLast,void leveldb.anonymous_namespace_7.TwoLevelIterator.SeekToLast (),table\two_level_iterator.cc,virtual void SeekToLast();,30.0,30.0,16.0,27.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2275,78048,Next,1,leveldb.anonymous_namespace_8.TwoLevelIterator.Next,void leveldb.anonymous_namespace_8.TwoLevelIterator.Next (),table\two_level_iterator.cc,virtual void Next();,31.0,31.0,16.0,21.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2276,78052,Prev,1,leveldb.anonymous_namespace_9.TwoLevelIterator.Prev,void leveldb.anonymous_namespace_9.TwoLevelIterator.Prev (),table\two_level_iterator.cc,virtual void Prev();,32.0,32.0,16.0,21.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2277,78056,Valid,1,leveldb.anonymous_namespace_10.TwoLevelIterator.Valid,bool leveldb.anonymous_namespace_10.TwoLevelIterator.Valid (),table\two_level_iterator.cc,"virtual bool Valid() const {
    return data_iter_.Valid();
  }",34.0,36.0,3.0,3.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,bool
2278,78065,key,1,leveldb.anonymous_namespace_11.TwoLevelIterator.key,Slice leveldb.anonymous_namespace_11.TwoLevelIterator.key (),table\two_level_iterator.cc,"virtual Slice key() const {
    assert(Valid());
    return data_iter_.key();
  }",37.0,40.0,3.0,3.0,4.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,Slice
2279,78076,value,1,leveldb.anonymous_namespace_13.TwoLevelIterator.value,Slice leveldb.anonymous_namespace_13.TwoLevelIterator.value (),table\two_level_iterator.cc,"virtual Slice value() const {
    assert(Valid());
    return data_iter_.value();
  }",41.0,44.0,3.0,3.0,4.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,Slice
2280,78087,status,1,leveldb.anonymous_namespace_15.TwoLevelIterator.status,Status leveldb.anonymous_namespace_15.TwoLevelIterator.status (),table\two_level_iterator.cc,"virtual Status status() const {
    // It'd be nice if status() returned a const Status& instead of a Status
    if (!index_iter_.status().ok()) {
      return index_iter_.status();
    } else if (data_iter_.iter() != NULL && !data_iter_.status().ok()) {
      return data_iter_.status();
    } else {
      return status_;
    }
  }",45.0,54.0,3.0,3.0,10.0,4,2,2,1,0,2,2,2,1,0,,0,2,0,0,0,Status
2281,78134,SaveError,1,leveldb.anonymous_namespace_16.TwoLevelIterator.SaveError,void leveldb.anonymous_namespace_16.TwoLevelIterator.SaveError (Status),table\two_level_iterator.cc,"void SaveError(const Status& s) {
    if (status_.ok() && !s.ok()) status_ = s;
  }",57.0,59.0,3.0,3.0,3.0,5,4,4,2,0,2,2,2,1,0,,0,2,2,1,1,void
2282,78154,SkipEmptyDataBlocksForward,1,leveldb.anonymous_namespace_17.TwoLevelIterator.SkipEmptyDataBlocksForward,void leveldb.anonymous_namespace_17.TwoLevelIterator.SkipEmptyDataBlocksForward (),table\two_level_iterator.cc,void SkipEmptyDataBlocksForward();,60.0,60.0,8.0,35.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2283,78158,SkipEmptyDataBlocksBackward,1,leveldb.anonymous_namespace_18.TwoLevelIterator.SkipEmptyDataBlocksBackward,void leveldb.anonymous_namespace_18.TwoLevelIterator.SkipEmptyDataBlocksBackward (),table\two_level_iterator.cc,void SkipEmptyDataBlocksBackward();,61.0,61.0,8.0,36.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2284,78162,SetDataIterator,1,leveldb.anonymous_namespace_19.TwoLevelIterator.SetDataIterator,void leveldb.anonymous_namespace_19.TwoLevelIterator.SetDataIterator (Iterator*),table\two_level_iterator.cc,void SetDataIterator(Iterator* data_iter);,62.0,62.0,8.0,43.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
2285,78167,InitDataBlock,1,leveldb.anonymous_namespace_20.TwoLevelIterator.InitDataBlock,void leveldb.anonymous_namespace_20.TwoLevelIterator.InitDataBlock (),table\two_level_iterator.cc,void InitDataBlock();,63.0,63.0,8.0,22.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2286,78178,TwoLevelIterator,1,leveldb.anonymous_namespace_21.TwoLevelIterator.TwoLevelIterator,"ANY leveldb.anonymous_namespace_21.TwoLevelIterator.TwoLevelIterator (Iterator*,BlockFunction,void*,ReadOptions)",table\two_level_iterator.cc,"TwoLevelIterator::TwoLevelIterator(
    Iterator* index_iter,
    BlockFunction block_function,
    void* arg,
    const ReadOptions& options)
    : block_function_(block_function),
      arg_(arg),
      options_(options),
      index_iter_(index_iter),
      data_iter_(NULL) {
}",76.0,86.0,1.0,1.0,11.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,ANY
2287,78186,~TwoLevelIterator,1,leveldb.anonymous_namespace_22.TwoLevelIterator.~TwoLevelIterator,ANY leveldb.anonymous_namespace_22.TwoLevelIterator.~TwoLevelIterator (),table\two_level_iterator.cc,"TwoLevelIterator::~TwoLevelIterator() {
}",88.0,89.0,1.0,1.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
2288,78190,Seek,1,leveldb.anonymous_namespace_23.TwoLevelIterator.Seek,void leveldb.anonymous_namespace_23.TwoLevelIterator.Seek (Slice),table\two_level_iterator.cc,"void TwoLevelIterator::Seek(const Slice& target) {
  index_iter_.Seek(target);
  InitDataBlock();
  if (data_iter_.iter() != NULL) data_iter_.Seek(target);
  SkipEmptyDataBlocksForward();
}",91.0,96.0,1.0,1.0,6.0,4,2,6,4,0,0,2,2,0,0,,0,0,2,1,1,void
2289,78215,SeekToFirst,1,leveldb.anonymous_namespace_24.TwoLevelIterator.SeekToFirst,void leveldb.anonymous_namespace_24.TwoLevelIterator.SeekToFirst (),table\two_level_iterator.cc,"void TwoLevelIterator::SeekToFirst() {
  index_iter_.SeekToFirst();
  InitDataBlock();
  if (data_iter_.iter() != NULL) data_iter_.SeekToFirst();
  SkipEmptyDataBlocksForward();
}",98.0,103.0,1.0,1.0,6.0,4,2,4,3,0,0,2,2,0,0,,0,0,0,0,0,void
2290,78237,SeekToLast,1,leveldb.anonymous_namespace_25.TwoLevelIterator.SeekToLast,void leveldb.anonymous_namespace_25.TwoLevelIterator.SeekToLast (),table\two_level_iterator.cc,"void TwoLevelIterator::SeekToLast() {
  index_iter_.SeekToLast();
  InitDataBlock();
  if (data_iter_.iter() != NULL) data_iter_.SeekToLast();
  SkipEmptyDataBlocksBackward();
}",105.0,110.0,1.0,1.0,6.0,4,2,4,3,0,0,2,2,0,0,,0,0,0,0,0,void
2291,78259,Next,1,leveldb.anonymous_namespace_26.TwoLevelIterator.Next,void leveldb.anonymous_namespace_26.TwoLevelIterator.Next (),table\two_level_iterator.cc,"void TwoLevelIterator::Next() {
  assert(Valid());
  data_iter_.Next();
  SkipEmptyDataBlocksForward();
}",112.0,116.0,1.0,1.0,5.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
2292,78270,Prev,1,leveldb.anonymous_namespace_28.TwoLevelIterator.Prev,void leveldb.anonymous_namespace_28.TwoLevelIterator.Prev (),table\two_level_iterator.cc,"void TwoLevelIterator::Prev() {
  assert(Valid());
  data_iter_.Prev();
  SkipEmptyDataBlocksBackward();
}",118.0,122.0,1.0,1.0,5.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
2293,78281,SkipEmptyDataBlocksForward,1,leveldb.anonymous_namespace_30.TwoLevelIterator.SkipEmptyDataBlocksForward,void leveldb.anonymous_namespace_30.TwoLevelIterator.SkipEmptyDataBlocksForward (),table\two_level_iterator.cc,"void TwoLevelIterator::SkipEmptyDataBlocksForward() {
  while (data_iter_.iter() == NULL || !data_iter_.Valid()) {
    // Move to next block
    if (!index_iter_.Valid()) {
      SetDataIterator(NULL);
      return;
    }
    index_iter_.Next();
    InitDataBlock();
    if (data_iter_.iter() != NULL) data_iter_.SeekToFirst();
  }
}",125.0,136.0,1.0,1.0,12.0,11,5,8,3,0,0,4,6,0,0,,0,0,0,0,0,void
2294,78325,SkipEmptyDataBlocksBackward,1,leveldb.anonymous_namespace_31.TwoLevelIterator.SkipEmptyDataBlocksBackward,void leveldb.anonymous_namespace_31.TwoLevelIterator.SkipEmptyDataBlocksBackward (),table\two_level_iterator.cc,"void TwoLevelIterator::SkipEmptyDataBlocksBackward() {
  while (data_iter_.iter() == NULL || !data_iter_.Valid()) {
    // Move to next block
    if (!index_iter_.Valid()) {
      SetDataIterator(NULL);
      return;
    }
    index_iter_.Prev();
    InitDataBlock();
    if (data_iter_.iter() != NULL) data_iter_.SeekToLast();
  }
}",138.0,149.0,1.0,1.0,12.0,11,5,8,3,0,0,4,6,0,0,,0,0,0,0,0,void
2295,78369,SetDataIterator,1,leveldb.anonymous_namespace_32.TwoLevelIterator.SetDataIterator,void leveldb.anonymous_namespace_32.TwoLevelIterator.SetDataIterator (Iterator*),table\two_level_iterator.cc,"void TwoLevelIterator::SetDataIterator(Iterator* data_iter) {
  if (data_iter_.iter() != NULL) SaveError(data_iter_.status());
  data_iter_.Set(data_iter);
}",151.0,154.0,1.0,1.0,4.0,4,2,5,3,0,0,2,2,0,0,,0,0,2,1,1,void
2296,78392,InitDataBlock,1,leveldb.anonymous_namespace_34.TwoLevelIterator.InitDataBlock,void leveldb.anonymous_namespace_34.TwoLevelIterator.InitDataBlock (),table\two_level_iterator.cc,"void TwoLevelIterator::InitDataBlock() {
  if (!index_iter_.Valid()) {
    SetDataIterator(NULL);
  } else {
    Slice handle = index_iter_.value();
    if (data_iter_.iter() != NULL && handle.compare(data_block_handle_) == 0) {
      // data_iter_ is already constructed with this iterator, so
      // no need to change anything
    } else {
      Iterator* iter = (*block_function_)(arg_, options_, handle);
      data_block_handle_.assign(handle.data(), handle.size());
      SetDataIterator(iter);
    }
  }
}",156.0,170.0,1.0,1.0,15.0,2,2,1,1,0,0,2,2,0,0,,0,0,0,0,0,void
2297,78454,NewTwoLevelIterator,1,leveldb.NewTwoLevelIterator,"Iterator leveldb.NewTwoLevelIterator (Iterator*,BlockFunction,void*,ReadOptions)",table\two_level_iterator.cc,"Iterator* NewTwoLevelIterator(
    Iterator* index_iter,
    BlockFunction block_function,
    void* arg,
    const ReadOptions& options) {
  return new TwoLevelIterator(index_iter, block_function, arg, options);
}",174.0,180.0,1.0,1.0,7.0,1,1,5,5,0,0,1,1,0,0,,0,0,8,4,4,Iterator
2298,78500,Arena,1,leveldb.Arena.Arena,ANY leveldb.Arena.Arena (),util\arena.cc,"Arena::Arena() : memory_usage_(0) {
  alloc_ptr_ = NULL;  // First allocation will allocate a block
  alloc_bytes_remaining_ = 0;
}",12.0,15.0,1.0,1.0,4.0,2,1,3,3,0,2,1,1,0,0,,0,2,0,0,0,ANY
2299,78510,~Arena,1,leveldb.Arena.~Arena,ANY leveldb.Arena.~Arena (),util\arena.cc,"Arena::~Arena() {
  for (size_t i = 0; i < blocks_.size(); i++) {
    delete[] blocks_[i];
  }
}",17.0,21.0,1.0,1.0,5.0,5,5,5,2,0,2,2,2,1,0,,0,2,0,0,0,ANY
2300,78533,AllocateFallback,1,leveldb.Arena.AllocateFallback,char* leveldb.Arena.AllocateFallback (size_t),util\arena.cc,"char* Arena::AllocateFallback(size_t bytes) {
  if (bytes > kBlockSize / 4) {
    // Object is more than a quarter of our block size.  Allocate it separately
    // to avoid wasting too much space in leftover bytes.
    char* result = AllocateNewBlock(bytes);
    return result;
  }

  // We waste the remaining space in the current block.
  alloc_ptr_ = AllocateNewBlock(kBlockSize);
  alloc_bytes_remaining_ = kBlockSize;

  char* result = alloc_ptr_;
  alloc_ptr_ += bytes;
  alloc_bytes_remaining_ -= bytes;
  return result;
}",23.0,39.0,1.0,1.0,17.0,8,5,16,5,0,5,2,2,0,0,,0,5,2,1,1,char*
2301,78571,AllocateAligned,1,leveldb.Arena.AllocateAligned,char* leveldb.Arena.AllocateAligned (size_t),util\arena.cc,"char* Arena::AllocateAligned(size_t bytes) {
  const int align = (sizeof(void*) > 8) ? sizeof(void*) : 8;
  assert((align & (align-1)) == 0);   // Pointer size should be a power of 2
  size_t current_mod = reinterpret_cast<uintptr_t>(alloc_ptr_) & (align-1);
  size_t slop = (current_mod == 0 ? 0 : align - current_mod);
  size_t needed = bytes + slop;
  char* result;
  if (needed <= alloc_bytes_remaining_) {
    result = alloc_ptr_ + slop;
    alloc_ptr_ += needed;
    alloc_bytes_remaining_ -= needed;
  } else {
    // AllocateFallback always returned aligned memory
    result = AllocateFallback(bytes);
  }
  assert((reinterpret_cast<uintptr_t>(result) & (align-1)) == 0);
  return result;
}",41.0,58.0,1.0,1.0,18.0,27,12,27,9,0,5,2,2,1,0,,0,5,2,1,1,char*
2302,78657,AllocateNewBlock,1,leveldb.Arena.AllocateNewBlock,char* leveldb.Arena.AllocateNewBlock (size_t),util\arena.cc,"char* Arena::AllocateNewBlock(size_t block_bytes) {
  char* result = new char[block_bytes];
  blocks_.push_back(result);
  memory_usage_.NoBarrier_Store(
      reinterpret_cast<void*>(MemoryUsage() + block_bytes + sizeof(char*)));
  return result;
}",60.0,66.0,1.0,1.0,7.0,8,6,8,5,0,2,1,1,0,0,,0,2,2,1,1,char*
2303,78711,Allocate,1,leveldb.Arena.Allocate,char* leveldb.Arena.Allocate (size_t),util\arena.hpp,"inline char* Arena::Allocate(size_t bytes) {
  // The semantics of what to return are a bit messy if we allow
  // 0-byte allocations, so we disallow them here (we don't need
  // them for our internal use).
  assert(bytes > 0);
  if (bytes <= alloc_bytes_remaining_) {
    char* result = alloc_ptr_;
    alloc_ptr_ += bytes;
    alloc_bytes_remaining_ -= bytes;
    return result;
  }
  return AllocateFallback(bytes);
}",52.0,64.0,1.0,1.0,13.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,char*
2304,78721,MemoryUsage,1,leveldb.Arena.MemoryUsage,size_t leveldb.Arena.MemoryUsage (),util\arena.hpp,"size_t MemoryUsage() const {
    return reinterpret_cast<uintptr_t>(memory_usage_.NoBarrier_Load());
  }",29.0,31.0,3.0,3.0,3.0,2,2,1,1,0,1,1,1,0,0,,0,1,0,0,0,size_t
2305,78751,operator =,1,leveldb.Arena.operator =,void leveldb.Arena.operator = (Arena),util\arena.hpp,void operator=(const Arena&);,49.0,49.0,8.0,30.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
2306,79152,BloomHash,1,leveldb.anonymous_namespace_1.BloomHash,uint32_t leveldb.anonymous_namespace_1.BloomHash (Slice),util\bloom.cc,"static uint32_t BloomHash(const Slice& key) {
  return Hash(key.data(), key.size(), 0xbc9f1d34);
}",13.0,15.0,1.0,1.0,3.0,2,1,2,1,0,0,1,1,0,0,,0,0,2,1,1,uint32_t
2307,79171,BloomFilterPolicy,1,leveldb.anonymous_namespace_3.BloomFilterPolicy.BloomFilterPolicy,ANY leveldb.anonymous_namespace_3.BloomFilterPolicy.BloomFilterPolicy (int),util\bloom.cc,"explicit BloomFilterPolicy(int bits_per_key)
      : bits_per_key_(bits_per_key) {
    // We intentionally round down to reduce probing cost a little bit
    k_ = static_cast<size_t>(bits_per_key * 0.69);  // 0.69 =~ ln(2)
    if (k_ < 1) k_ = 1;
    if (k_ > 30) k_ = 30;
  }",23.0,29.0,3.0,3.0,7.0,7,5,6,2,0,5,3,3,2,0,,0,5,2,1,1,ANY
2308,79199,Name,1,leveldb.anonymous_namespace_4.BloomFilterPolicy.Name,const char* leveldb.anonymous_namespace_4.BloomFilterPolicy.Name (),util\bloom.cc,"virtual const char* Name() const {
    return ""leveldb.BuiltinBloomFilter2"";
  }",31.0,33.0,3.0,3.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,const char*
2309,79205,CreateFilter,1,leveldb.anonymous_namespace_5.BloomFilterPolicy.CreateFilter,"void leveldb.anonymous_namespace_5.BloomFilterPolicy.CreateFilter (Slice*,int,ANY*)",util\bloom.cc,"virtual void CreateFilter(const Slice* keys, int n, std::string* dst) const {
    // Compute bloom filter size (in both bits and bytes)
    size_t bits = n * bits_per_key_;

    // For small n, we can see a very high false positive rate.  Fix it
    // by enforcing a minimum bloom filter length.
    if (bits < 64) bits = 64;

    size_t bytes = (bits + 7) / 8;
    bits = bytes * 8;

    const size_t init_size = dst->size();
    dst->resize(init_size + bytes, 0);
    dst->push_back(static_cast<char>(k_));  // Remember # of probes in filter
    char* array = &(*dst)[init_size];
    for (int i = 0; i < n; i++) {
      // Use double-hashing to generate a sequence of hash values.
      // See analysis in [Kirsch,Mitzenmacher 2006].
      uint32_t h = BloomHash(keys[i]);
      const uint32_t delta = (h >> 17) | (h << 15);  // Rotate right 17 bits
      for (size_t j = 0; j < k_; j++) {
        const uint32_t bitpos = h % bits;
        array[bitpos/8] |= (1 << (bitpos % 8));
        h += d...",35.0,61.0,3.0,3.0,27.0,36,15,39,14,0,3,4,5,1,0,,0,3,6,3,3,void
2310,79330,KeyMayMatch,1,leveldb.anonymous_namespace_7.BloomFilterPolicy.KeyMayMatch,"bool leveldb.anonymous_namespace_7.BloomFilterPolicy.KeyMayMatch (Slice,Slice)",util\bloom.cc,"virtual bool KeyMayMatch(const Slice& key, const Slice& bloom_filter) const {
    const size_t len = bloom_filter.size();
    if (len < 2) return false;

    const char* array = bloom_filter.data();
    const size_t bits = (len - 1) * 8;

    // Use the encoded k so that we can read filters generated by
    // bloom filters created using different parameters.
    const size_t k = array[len-1];
    if (k > 30) {
      // Reserved for potentially new encodings for short bloom filters.
      // Consider it a match.
      return true;
    }

    uint32_t h = BloomHash(key);
    const uint32_t delta = (h >> 17) | (h << 15);  // Rotate right 17 bits
    for (size_t j = 0; j < k; j++) {
      const uint32_t bitpos = h % bits;
      if ((array[bitpos/8] & (1 << (bitpos % 8))) == 0) return false;
      h += delta;
    }
    return true;
  }",63.0,87.0,3.0,3.0,25.0,28,15,27,10,0,0,5,6,0,0,,0,0,4,2,2,bool
2311,79482,BloomTest,1,leveldb.BloomTest.BloomTest,ANY leveldb.BloomTest.BloomTest (),util\bloom_test.cc,BloomTest() : policy_(NewBloomFilterPolicy(10)) { },28.0,28.0,3.0,53.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
2312,79486,~BloomTest,1,leveldb.BloomTest.~BloomTest,ANY leveldb.BloomTest.~BloomTest (),util\bloom_test.cc,"~BloomTest() {
    delete policy_;
  }",30.0,32.0,3.0,3.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,ANY
2313,79492,Reset,1,leveldb.BloomTest.Reset,void leveldb.BloomTest.Reset (),util\bloom_test.cc,"void Reset() {
    keys_.clear();
    filter_.clear();
  }",34.0,37.0,3.0,3.0,4.0,2,1,2,2,0,2,1,1,0,0,,0,2,0,0,0,void
2314,79504,Add,1,leveldb.BloomTest.Add,void leveldb.BloomTest.Add (Slice),util\bloom_test.cc,"void Add(const Slice& s) {
    keys_.push_back(s.ToString());
  }",39.0,41.0,3.0,3.0,3.0,2,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
2315,79517,Build,1,leveldb.BloomTest.Build,void leveldb.BloomTest.Build (),util\bloom_test.cc,"void Build() {
    std::vector<Slice> key_slices;
    for (size_t i = 0; i < keys_.size(); i++) {
      key_slices.push_back(Slice(keys_[i]));
    }
    filter_.clear();
    policy_->CreateFilter(&key_slices[0], static_cast<int>(key_slices.size()),
                          &filter_);
    keys_.clear();
    if (kVerbose >= 2) DumpFilter();
  }",43.0,53.0,3.0,3.0,11.0,14,8,13,6,0,6,3,3,1,0,,0,6,0,0,0,void
2316,79575,FilterSize,1,leveldb.BloomTest.FilterSize,size_t leveldb.BloomTest.FilterSize (),util\bloom_test.cc,"size_t FilterSize() const {
    return filter_.size();
  }",55.0,57.0,3.0,3.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,size_t
2317,79584,DumpFilter,1,leveldb.BloomTest.DumpFilter,void leveldb.BloomTest.DumpFilter (),util\bloom_test.cc,"void DumpFilter() {
    fprintf(stderr, ""F("");
    for (size_t i = 0; i+1 < filter_.size(); i++) {
      const unsigned int c = static_cast<unsigned int>(filter_[i]);
      for (int j = 0; j < 8; j++) {
        fprintf(stderr, ""%c"", (c & (1 <<j)) ? '1' : '.');
      }
    }
    fprintf(stderr, "")\n"");
  }",59.0,68.0,3.0,3.0,10.0,12,9,13,5,0,2,3,4,1,0,,0,2,0,0,0,void
2318,79642,Matches,1,leveldb.BloomTest.Matches,bool leveldb.BloomTest.Matches (Slice),util\bloom_test.cc,"bool Matches(const Slice& s) {
    if (!keys_.empty()) {
      Build();
    }
    return policy_->KeyMayMatch(s, filter_);
  }",70.0,75.0,3.0,3.0,6.0,3,3,4,4,0,3,2,2,1,0,,0,3,2,1,1,bool
2319,79662,FalsePositiveRate,1,leveldb.BloomTest.FalsePositiveRate,double leveldb.BloomTest.FalsePositiveRate (),util\bloom_test.cc,"double FalsePositiveRate() {
    char buffer[sizeof(int)];
    int result = 0;
    for (int i = 0; i < 10000; i++) {
      if (Matches(Key(i + 1000000000, buffer))) {
        result++;
      }
    }
    return result / 10000.0;
  }",77.0,86.0,3.0,3.0,10.0,6,5,7,3,0,0,3,4,0,0,,0,0,0,0,0,double
2320,79698,_Run,1,leveldb._Test_EmptyFilter._Run,void leveldb._Test_EmptyFilter._Run (),util\bloom_test.cc,"TEST(BloomTest, EmptyFilter) {
  ASSERT_TRUE(! Matches(""hello""));
  ASSERT_TRUE(! Matches(""world""));
}",89.0,92.0,1.0,28.0,4.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2321,79702,_RunIt,1,leveldb._Test_EmptyFilter._RunIt,void leveldb._Test_EmptyFilter._RunIt (),util\bloom_test.cc,"TEST(BloomTest, EmptyFilter)",89.0,89.0,1.0,28.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
2322,79771,_Run,1,leveldb._Test_Small._Run,void leveldb._Test_Small._Run (),util\bloom_test.cc,"TEST(BloomTest, Small) {
  Add(""hello"");
  Add(""world"");
  ASSERT_TRUE(Matches(""hello""));
  ASSERT_TRUE(Matches(""world""));
  ASSERT_TRUE(! Matches(""x""));
  ASSERT_TRUE(! Matches(""foo""));
}",94.0,101.0,1.0,22.0,8.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2323,79775,_RunIt,1,leveldb._Test_Small._RunIt,void leveldb._Test_Small._RunIt (),util\bloom_test.cc,"TEST(BloomTest, Small)",94.0,94.0,1.0,22.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
2324,79883,NextLength,1,leveldb.NextLength,int leveldb.NextLength (int),util\bloom_test.cc,"static int NextLength(int length) {
  if (length < 10) {
    length += 1;
  } else if (length < 100) {
    length += 10;
  } else if (length < 1000) {
    length += 100;
  } else {
    length += 1000;
  }
  return length;
}",103.0,114.0,1.0,1.0,12.0,2,2,3,1,0,0,2,2,0,0,,0,0,2,1,1,int
2325,79924,_Run,1,leveldb._Test_VaryingLengths._Run,void leveldb._Test_VaryingLengths._Run (),util\bloom_test.cc,"TEST(BloomTest, VaryingLengths) {
  char buffer[sizeof(int)];

  // Count number of filters that significantly exceed the false positive rate
  int mediocre_filters = 0;
  int good_filters = 0;

  for (int length = 1; length <= 10000; length = NextLength(length)) {
    Reset();
    for (int i = 0; i < length; i++) {
      Add(Key(i, buffer));
    }
    Build();

    ASSERT_LE(FilterSize(), static_cast<size_t>((length * 10 / 8) + 40))
        << length;

    // All added keys must match
    for (int i = 0; i < length; i++) {
      ASSERT_TRUE(Matches(Key(i, buffer)))
          << ""Length "" << length << ""; key "" << i;
    }

    // Check false positive rate
    double rate = FalsePositiveRate();
    if (kVerbose >= 1) {
      fprintf(stderr, ""False positives: %5.2f%% @ length = %6d ; bytes = %6d\n"",
              rate*100.0, length, static_cast<int>(FilterSize()));
    }
    ASSERT_LE(rate, 0.02);   // Must not be over 2%
    if (rate > 0.0125) mediocre_filters++;  // Allowed, but not...",116.0,154.0,1.0,31.0,39.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2326,79928,_RunIt,1,leveldb._Test_VaryingLengths._RunIt,void leveldb._Test_VaryingLengths._RunIt (),util\bloom_test.cc,"TEST(BloomTest, VaryingLengths)",116.0,116.0,1.0,31.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
2327,80176,deleter,1,leveldb.anonymous_namespace_2.LRUHandle.deleter,"void leveldb.anonymous_namespace_2.LRUHandle.deleter (Slice,void*)",util\cache.cc,"void (*deleter)(const Slice&, void* value);",44.0,44.0,8.0,44.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
2328,80191,key,1,leveldb.anonymous_namespace_3.LRUHandle.key,Slice leveldb.anonymous_namespace_3.LRUHandle.key (),util\cache.cc,"Slice key() const {
    // For cheaper lookups, we allow a temporary Handle object
    // to store a pointer to a key in ""value"".
    if (next == this) {
      return *(reinterpret_cast<Slice*>(value));
    } else {
      return Slice(key_data, key_length);
    }
  }",55.0,63.0,3.0,3.0,9.0,3,3,2,2,0,2,2,2,1,0,,0,2,0,0,0,Slice
2329,80218,HandleTable,1,leveldb.anonymous_namespace_5.HandleTable.HandleTable,ANY leveldb.anonymous_namespace_5.HandleTable.HandleTable (),util\cache.cc,"HandleTable() : length_(0), elems_(0), list_(NULL) { Resize(); }",73.0,73.0,3.0,66.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
2330,80223,~HandleTable,1,leveldb.anonymous_namespace_7.HandleTable.~HandleTable,ANY leveldb.anonymous_namespace_7.HandleTable.~HandleTable (),util\cache.cc,~HandleTable() { delete[] list_; },74.0,74.0,3.0,36.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,ANY
2331,80229,Lookup,1,leveldb.anonymous_namespace_8.HandleTable.Lookup,"LRUHandle leveldb.anonymous_namespace_8.HandleTable.Lookup (Slice,uint32_t)",util\cache.cc,"LRUHandle* Lookup(const Slice& key, uint32_t hash) {
    return *FindPointer(key, hash);
  }",76.0,78.0,3.0,3.0,3.0,1,1,2,2,0,0,1,1,0,0,,0,0,4,2,2,LRUHandle
2332,80240,Insert,1,leveldb.anonymous_namespace_10.HandleTable.Insert,LRUHandle leveldb.anonymous_namespace_10.HandleTable.Insert (LRUHandle*),util\cache.cc,"LRUHandle* Insert(LRUHandle* h) {
    LRUHandle** ptr = FindPointer(h->key(), h->hash);
    LRUHandle* old = *ptr;
    h->next_hash = (old == NULL ? NULL : old->next_hash);
    *ptr = h;
    if (old == NULL) {
      ++elems_;
      if (elems_ > length_) {
        // Since each cache entry is fairly large, we aim for a small
        // average linked list length (<= 1).
        Resize();
      }
    }
    return old;
  }",80.0,94.0,3.0,3.0,15.0,15,7,18,6,0,6,3,4,2,0,,0,6,2,1,1,LRUHandle
2333,80292,Remove,1,leveldb.anonymous_namespace_13.HandleTable.Remove,"LRUHandle leveldb.anonymous_namespace_13.HandleTable.Remove (Slice,uint32_t)",util\cache.cc,"LRUHandle* Remove(const Slice& key, uint32_t hash) {
    LRUHandle** ptr = FindPointer(key, hash);
    LRUHandle* result = *ptr;
    if (result != NULL) {
      *ptr = result->next_hash;
      --elems_;
    }
    return result;
  }",96.0,104.0,3.0,3.0,9.0,8,5,11,6,0,2,2,2,0,0,,0,2,4,2,2,LRUHandle
2334,80327,FindPointer,1,leveldb.anonymous_namespace_15.HandleTable.FindPointer,"LRUHandle leveldb.anonymous_namespace_15.HandleTable.FindPointer (Slice,uint32_t)",util\cache.cc,"LRUHandle** FindPointer(const Slice& key, uint32_t hash) {
    LRUHandle** ptr = &list_[hash & (length_ - 1)];
    while (*ptr != NULL &&
           ((*ptr)->hash != hash || key != (*ptr)->key())) {
      ptr = &(*ptr)->next_hash;
    }
    return ptr;
  }",116.0,123.0,3.0,3.0,8.0,19,10,13,6,0,2,2,2,0,0,,0,2,4,2,2,LRUHandle
2335,80374,Resize,1,leveldb.anonymous_namespace_16.HandleTable.Resize,void leveldb.anonymous_namespace_16.HandleTable.Resize (),util\cache.cc,"void Resize() {
    uint32_t new_length = 4;
    while (new_length < elems_) {
      new_length *= 2;
    }
    LRUHandle** new_list = new LRUHandle*[new_length];
    memset(new_list, 0, sizeof(new_list[0]) * new_length);
    uint32_t count = 0;
    for (uint32_t i = 0; i < length_; i++) {
      LRUHandle* h = list_[i];
      while (h != NULL) {
        LRUHandle* next = h->next_hash;
        uint32_t hash = h->hash;
        LRUHandle** ptr = &new_list[hash & (new_length - 1)];
        h->next_hash = *ptr;
        *ptr = h;
        h = next;
        count++;
      }
    }
    assert(elems_ == count);
    delete[] list_;
    list_ = new_list;
    length_ = new_length;
  }",125.0,149.0,3.0,3.0,25.0,34,16,40,13,0,10,4,5,2,0,,0,10,0,0,0,void
2336,80482,LRUCache,1,leveldb.anonymous_namespace_18.LRUCache.LRUCache,ANY leveldb.anonymous_namespace_18.LRUCache.LRUCache (),util\cache.cc,LRUCache();,155.0,155.0,3.0,12.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
2337,80486,~LRUCache,1,leveldb.anonymous_namespace_19.LRUCache.~LRUCache,ANY leveldb.anonymous_namespace_19.LRUCache.~LRUCache (),util\cache.cc,~LRUCache();,156.0,156.0,3.0,13.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
2338,80490,SetCapacity,1,leveldb.anonymous_namespace_20.LRUCache.SetCapacity,void leveldb.anonymous_namespace_20.LRUCache.SetCapacity (size_t),util\cache.cc,void SetCapacity(size_t capacity) { capacity_ = capacity; },159.0,159.0,3.0,61.0,1.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
2339,80498,Insert,1,leveldb.anonymous_namespace_21.LRUCache.Insert,"ANY* leveldb.anonymous_namespace_21.LRUCache.Insert (Slice,uint32_t,void*,size_t,void)",util\cache.cc,"Cache::Handle* Insert(const Slice& key, uint32_t hash,
                        void* value, size_t charge,
                        void (*deleter)(const Slice& key, void* value));",162.0,164.0,16.0,71.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,10,5,5,ANY*
2340,80507,Lookup,1,leveldb.anonymous_namespace_22.LRUCache.Lookup,"ANY* leveldb.anonymous_namespace_22.LRUCache.Lookup (Slice,uint32_t)",util\cache.cc,"Cache::Handle* Lookup(const Slice& key, uint32_t hash);",165.0,165.0,16.0,56.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,ANY*
2341,80513,Release,1,leveldb.anonymous_namespace_23.LRUCache.Release,void leveldb.anonymous_namespace_23.LRUCache.Release (ANY*),util\cache.cc,void Release(Cache::Handle* handle);,166.0,166.0,8.0,37.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
2342,80518,Erase,1,leveldb.anonymous_namespace_24.LRUCache.Erase,"void leveldb.anonymous_namespace_24.LRUCache.Erase (Slice,uint32_t)",util\cache.cc,"void Erase(const Slice& key, uint32_t hash);",167.0,167.0,8.0,45.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
2343,80524,Prune,1,leveldb.anonymous_namespace_25.LRUCache.Prune,void leveldb.anonymous_namespace_25.LRUCache.Prune (),util\cache.cc,void Prune();,168.0,168.0,8.0,14.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2344,80528,TotalCharge,1,leveldb.anonymous_namespace_26.LRUCache.TotalCharge,size_t leveldb.anonymous_namespace_26.LRUCache.TotalCharge (),util\cache.cc,"size_t TotalCharge() const {
    MutexLock l(&mutex_);
    return usage_;
  }",169.0,172.0,3.0,3.0,4.0,1,1,2,2,0,2,1,1,0,0,,0,2,0,0,0,size_t
2345,80538,LRU_Remove,1,leveldb.anonymous_namespace_27.LRUCache.LRU_Remove,void leveldb.anonymous_namespace_27.LRUCache.LRU_Remove (LRUHandle*),util\cache.cc,void LRU_Remove(LRUHandle* e);,175.0,175.0,8.0,31.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
2346,80543,LRU_Append,1,leveldb.anonymous_namespace_28.LRUCache.LRU_Append,"void leveldb.anonymous_namespace_28.LRUCache.LRU_Append (LRUHandle*,LRUHandle*)",util\cache.cc,"void LRU_Append(LRUHandle*list, LRUHandle* e);",176.0,176.0,8.0,47.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
2347,80549,Ref,1,leveldb.anonymous_namespace_29.LRUCache.Ref,void leveldb.anonymous_namespace_29.LRUCache.Ref (LRUHandle*),util\cache.cc,void Ref(LRUHandle* e);,177.0,177.0,8.0,24.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
2348,80554,Unref,1,leveldb.anonymous_namespace_30.LRUCache.Unref,void leveldb.anonymous_namespace_30.LRUCache.Unref (LRUHandle*),util\cache.cc,void Unref(LRUHandle* e);,178.0,178.0,8.0,26.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
2349,80559,FinishErase,1,leveldb.anonymous_namespace_31.LRUCache.FinishErase,bool leveldb.anonymous_namespace_31.LRUCache.FinishErase (LRUHandle*),util\cache.cc,bool FinishErase(LRUHandle* e);,179.0,179.0,8.0,32.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,bool
2350,80570,LRUCache,1,leveldb.anonymous_namespace_32.LRUCache.LRUCache,ANY leveldb.anonymous_namespace_32.LRUCache.LRUCache (),util\cache.cc,"LRUCache::LRUCache()
    : usage_(0) {
  // Make empty circular linked lists.
  lru_.next = &lru_;
  lru_.prev = &lru_;
  in_use_.next = &in_use_;
  in_use_.prev = &in_use_;
}",200.0,207.0,1.0,1.0,8.0,12,3,8,2,0,0,1,1,0,0,,0,0,0,0,0,ANY
2351,80598,~LRUCache,1,leveldb.anonymous_namespace_33.LRUCache.~LRUCache,ANY leveldb.anonymous_namespace_33.LRUCache.~LRUCache (),util\cache.cc,"LRUCache::~LRUCache() {
  assert(in_use_.next == &in_use_);  // Error if caller has an unreleased handle
  for (LRUHandle* e = lru_.next; e != &lru_; ) {
    LRUHandle* next = e->next;
    assert(e->in_cache);
    e->in_cache = false;
    assert(e->refs == 1);  // Invariant of lru_ list.
    Unref(e);
    e = next;
  }
}",209.0,219.0,1.0,1.0,11.0,15,6,14,4,0,0,2,2,0,0,,0,0,0,0,0,ANY
2352,80648,Ref,1,leveldb.anonymous_namespace_35.LRUCache.Ref,void leveldb.anonymous_namespace_35.LRUCache.Ref (LRUHandle*),util\cache.cc,"void LRUCache::Ref(LRUHandle* e) {
  if (e->refs == 1 && e->in_cache) {  // If on lru_ list, move to in_use_ list.
    LRU_Remove(e);
    LRU_Append(&in_use_, e);
  }
  e->refs++;
}",221.0,227.0,1.0,1.0,7.0,7,5,6,2,0,3,2,2,2,0,,0,3,2,1,1,void
2353,80674,Unref,1,leveldb.anonymous_namespace_36.LRUCache.Unref,void leveldb.anonymous_namespace_36.LRUCache.Unref (LRUHandle*),util\cache.cc,"void LRUCache::Unref(LRUHandle* e) {
  assert(e->refs > 0);
  e->refs--;
  if (e->refs == 0) { // Deallocate.
    assert(!e->in_cache);
    (*e->deleter)(e->key(), e->value);
    free(e);
  } else if (e->in_cache && e->refs == 1) {  // No longer in use; move to lru_ list.
    LRU_Remove(e);
    LRU_Append(&lru_, e);
  }
}",229.0,240.0,1.0,1.0,12.0,12,6,8,1,0,5,2,2,1,0,,0,5,2,1,1,void
2354,80734,LRU_Remove,1,leveldb.anonymous_namespace_37.LRUCache.LRU_Remove,void leveldb.anonymous_namespace_37.LRUCache.LRU_Remove (LRUHandle*),util\cache.cc,"void LRUCache::LRU_Remove(LRUHandle* e) {
  e->next->prev = e->prev;
  e->prev->next = e->next;
}",242.0,245.0,1.0,1.0,4.0,8,2,4,1,0,4,1,1,0,0,,0,4,2,1,1,void
2355,80757,LRU_Append,1,leveldb.anonymous_namespace_38.LRUCache.LRU_Append,"void leveldb.anonymous_namespace_38.LRUCache.LRU_Append (LRUHandle*,LRUHandle*)",util\cache.cc,"void LRUCache::LRU_Append(LRUHandle* list, LRUHandle* e) {
  // Make ""e"" newest entry by inserting just before *list
  e->next = list;
  e->prev = list->prev;
  e->prev->next = e;
  e->next->prev = e;
}",247.0,253.0,1.0,1.0,7.0,11,2,8,2,0,5,1,1,0,0,,0,5,4,2,2,void
2356,80789,Lookup,1,leveldb.anonymous_namespace_39.LRUCache.Lookup,"Handle leveldb.anonymous_namespace_39.LRUCache.Lookup (Slice,uint32_t)",util\cache.cc,"Cache::Handle* LRUCache::Lookup(const Slice& key, uint32_t hash) {
  MutexLock l(&mutex_);
  LRUHandle* e = table_.Lookup(key, hash);
  if (e != NULL) {
    Ref(e);
  }
  return reinterpret_cast<Cache::Handle*>(e);
}",255.0,262.0,1.0,1.0,8.0,5,5,9,6,0,0,2,2,0,0,,0,0,4,2,2,Handle
2357,80819,Release,1,leveldb.anonymous_namespace_41.LRUCache.Release,void leveldb.anonymous_namespace_41.LRUCache.Release (ANY*),util\cache.cc,"void LRUCache::Release(Cache::Handle* handle) {
  MutexLock l(&mutex_);
  Unref(reinterpret_cast<LRUHandle*>(handle));
}",264.0,267.0,1.0,1.0,4.0,2,2,2,2,0,0,1,1,0,0,,0,0,2,1,1,void
2358,80832,Insert,1,leveldb.anonymous_namespace_43.LRUCache.Insert,"Handle leveldb.anonymous_namespace_43.LRUCache.Insert (Slice,uint32_t,void*,size_t,void)",util\cache.cc,"Cache::Handle* LRUCache::Insert(
    const Slice& key, uint32_t hash, void* value, size_t charge,
    void (*deleter)(const Slice& key, void* value)) {
  MutexLock l(&mutex_);

  LRUHandle* e = reinterpret_cast<LRUHandle*>(
      malloc(sizeof(LRUHandle)-1 + key.size()));
  e->value = value;
  e->deleter = deleter;
  e->charge = charge;
  e->key_length = key.size();
  e->hash = hash;
  e->in_cache = false;
  e->refs = 1;  // for the returned handle.
  memcpy(e->key_data, key.data(), key.size());

  if (capacity_ > 0) {
    e->refs++;  // for the cache's reference.
    e->in_cache = true;
    LRU_Append(&in_use_, e);
    usage_ += charge;
    FinishErase(table_.Insert(e));
  } // else don't cache.  (Tests use capacity_==0 to turn off caching.)

  while (usage_ > capacity_ && lru_.next != &lru_) {
    LRUHandle* old = lru_.next;
    assert(old->refs == 1);
    bool erased = FinishErase(table_.Remove(old->key(), old->hash));
    if (!erased) {  // to avoid unused variable when compiled...",269.0,303.0,1.0,1.0,35.0,48,15,42,15,0,11,4,5,0,0,,0,11,10,5,5,Handle
2359,80986,FinishErase,1,leveldb.anonymous_namespace_47.LRUCache.FinishErase,bool leveldb.anonymous_namespace_47.LRUCache.FinishErase (LRUHandle*),util\cache.cc,"bool LRUCache::FinishErase(LRUHandle* e) {
  if (e != NULL) {
    assert(e->in_cache);
    LRU_Remove(e);
    e->in_cache = false;
    usage_ -= e->charge;
    Unref(e);
  }
  return e != NULL;
}",307.0,316.0,1.0,1.0,10.0,7,4,10,3,0,3,2,2,0,0,,0,3,2,1,1,bool
2360,81018,Erase,1,leveldb.anonymous_namespace_50.LRUCache.Erase,"void leveldb.anonymous_namespace_50.LRUCache.Erase (Slice,uint32_t)",util\cache.cc,"void LRUCache::Erase(const Slice& key, uint32_t hash) {
  MutexLock l(&mutex_);
  FinishErase(table_.Remove(key, hash));
}",318.0,321.0,1.0,1.0,4.0,2,2,4,4,0,0,1,1,0,0,,0,0,4,2,2,void
2361,81035,Prune,1,leveldb.anonymous_namespace_52.LRUCache.Prune,void leveldb.anonymous_namespace_52.LRUCache.Prune (),util\cache.cc,"void LRUCache::Prune() {
  MutexLock l(&mutex_);
  while (lru_.next != &lru_) {
    LRUHandle* e = lru_.next;
    assert(e->refs == 1);
    bool erased = FinishErase(table_.Remove(e->key(), e->hash));
    if (!erased) {  // to avoid unused variable when compiled NDEBUG
      assert(erased);
    }
  }
}",323.0,333.0,1.0,1.0,11.0,13,7,12,5,0,2,3,4,0,0,,0,2,0,0,0,void
2362,81098,HashSlice,1,leveldb.anonymous_namespace_55.ShardedLRUCache.HashSlice,uint32_t leveldb.anonymous_namespace_55.ShardedLRUCache.HashSlice (Slice),util\cache.cc,"static inline uint32_t HashSlice(const Slice& s) {
    return Hash(s.data(), s.size(), 0);
  }",344.0,346.0,3.0,3.0,3.0,2,1,2,1,0,0,1,1,0,0,,0,0,2,1,1,uint32_t
2363,81114,Shard,1,leveldb.anonymous_namespace_56.ShardedLRUCache.Shard,uint32_t leveldb.anonymous_namespace_56.ShardedLRUCache.Shard (uint32_t),util\cache.cc,"static uint32_t Shard(uint32_t hash) {
    return hash >> (32 - kNumShardBits);
  }",348.0,350.0,3.0,3.0,3.0,2,2,2,2,0,0,1,1,0,0,,0,0,2,1,1,uint32_t
2364,81125,ShardedLRUCache,1,leveldb.anonymous_namespace_57.ShardedLRUCache.ShardedLRUCache,ANY leveldb.anonymous_namespace_57.ShardedLRUCache.ShardedLRUCache (size_t),util\cache.cc,"explicit ShardedLRUCache(size_t capacity)
      : last_id_(0) {
    const size_t per_shard = (capacity + (kNumShards - 1)) / kNumShards;
    for (int s = 0; s < kNumShards; s++) {
      shard_[s].SetCapacity(per_shard);
    }
  }",353.0,359.0,3.0,3.0,7.0,8,7,10,5,0,1,2,2,0,0,,0,1,2,1,1,ANY
2365,81159,~ShardedLRUCache,1,leveldb.anonymous_namespace_58.ShardedLRUCache.~ShardedLRUCache,ANY leveldb.anonymous_namespace_58.ShardedLRUCache.~ShardedLRUCache (),util\cache.cc,virtual ~ShardedLRUCache() { },360.0,360.0,3.0,32.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
2366,81163,Insert,1,leveldb.anonymous_namespace_59.ShardedLRUCache.Insert,"Handle leveldb.anonymous_namespace_59.ShardedLRUCache.Insert (Slice,void*,size_t,void)",util\cache.cc,"virtual Handle* Insert(const Slice& key, void* value, size_t charge,
                         void (*deleter)(const Slice& key, void* value)) {
    const uint32_t hash = HashSlice(key);
    return shard_[Shard(hash)].Insert(key, hash, value, charge, deleter);
  }",361.0,365.0,3.0,3.0,5.0,3,3,9,6,0,1,1,1,0,0,,0,1,8,4,4,Handle
2367,81189,Lookup,1,leveldb.anonymous_namespace_64.ShardedLRUCache.Lookup,Handle leveldb.anonymous_namespace_64.ShardedLRUCache.Lookup (Slice),util\cache.cc,"virtual Handle* Lookup(const Slice& key) {
    const uint32_t hash = HashSlice(key);
    return shard_[Shard(hash)].Lookup(key, hash);
  }",366.0,369.0,3.0,3.0,4.0,3,3,6,3,0,1,1,1,0,0,,0,1,2,1,1,Handle
2368,81209,Release,1,leveldb.anonymous_namespace_69.ShardedLRUCache.Release,void leveldb.anonymous_namespace_69.ShardedLRUCache.Release (Handle*),util\cache.cc,"virtual void Release(Handle* handle) {
    LRUHandle* h = reinterpret_cast<LRUHandle*>(handle);
    shard_[Shard(h->hash)].Release(handle);
  }",370.0,373.0,3.0,3.0,4.0,5,5,5,3,0,2,1,1,0,0,,0,2,2,1,1,void
2369,81230,Erase,1,leveldb.anonymous_namespace_72.ShardedLRUCache.Erase,void leveldb.anonymous_namespace_72.ShardedLRUCache.Erase (Slice),util\cache.cc,"virtual void Erase(const Slice& key) {
    const uint32_t hash = HashSlice(key);
    shard_[Shard(hash)].Erase(key, hash);
  }",374.0,377.0,3.0,3.0,4.0,3,3,6,3,0,1,1,1,0,0,,0,1,2,1,1,void
2370,81249,Value,1,leveldb.anonymous_namespace_77.ShardedLRUCache.Value,void* leveldb.anonymous_namespace_77.ShardedLRUCache.Value (Handle*),util\cache.cc,"virtual void* Value(Handle* handle) {
    return reinterpret_cast<LRUHandle*>(handle)->value;
  }",378.0,380.0,3.0,3.0,3.0,2,2,1,1,0,0,1,1,0,0,,0,0,2,1,1,void*
2371,81260,NewId,1,leveldb.anonymous_namespace_78.ShardedLRUCache.NewId,uint64_t leveldb.anonymous_namespace_78.ShardedLRUCache.NewId (),util\cache.cc,"virtual uint64_t NewId() {
    MutexLock l(&id_mutex_);
    return ++(last_id_);
  }",381.0,384.0,3.0,3.0,4.0,2,2,2,2,0,2,1,1,0,0,,0,2,0,0,0,uint64_t
2372,81271,Prune,1,leveldb.anonymous_namespace_79.ShardedLRUCache.Prune,void leveldb.anonymous_namespace_79.ShardedLRUCache.Prune (),util\cache.cc,"virtual void Prune() {
    for (int s = 0; s < kNumShards; s++) {
      shard_[s].Prune();
    }
  }",385.0,389.0,3.0,3.0,5.0,4,4,5,3,0,1,2,2,0,0,,0,1,0,0,0,void
2373,81293,TotalCharge,1,leveldb.anonymous_namespace_80.ShardedLRUCache.TotalCharge,size_t leveldb.anonymous_namespace_80.ShardedLRUCache.TotalCharge (),util\cache.cc,"virtual size_t TotalCharge() const {
    size_t total = 0;
    for (int s = 0; s < kNumShards; s++) {
      total += shard_[s].TotalCharge();
    }
    return total;
  }",390.0,396.0,3.0,3.0,7.0,6,5,8,4,0,1,2,2,0,0,,0,1,0,0,0,size_t
2374,81364,DecodeKey,1,leveldb.DecodeKey,int leveldb.DecodeKey (Slice),util\cache_test.cc,"static int DecodeKey(const Slice& k) {
  assert(k.size() == 4);
  return DecodeFixed32(k.data());
}",19.0,22.0,1.0,1.0,4.0,3,2,2,1,0,0,1,1,0,0,,0,0,2,1,1,int
2375,81382,EncodeValue,1,leveldb.EncodeValue,void* leveldb.EncodeValue (uintptr_t),util\cache_test.cc,static void* EncodeValue(uintptr_t v) { return reinterpret_cast<void*>(v); },23.0,23.0,1.0,76.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,void*
2376,81391,DecodeValue,1,leveldb.DecodeValue,int leveldb.DecodeValue (void*),util\cache_test.cc,static int DecodeValue(void* v) { return reinterpret_cast<uintptr_t>(v); },24.0,24.0,1.0,74.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,int
2377,81402,Deleter,1,leveldb.CacheTest.Deleter,"void leveldb.CacheTest.Deleter (Slice,void*)",util\cache_test.cc,"static void Deleter(const Slice& key, void* v) {
    current_->deleted_keys_.push_back(DecodeKey(key));
    current_->deleted_values_.push_back(DecodeValue(v));
  }",30.0,33.0,3.0,3.0,4.0,4,2,4,3,0,2,1,1,0,0,,0,2,4,2,2,void
2378,81428,CacheTest,1,leveldb.CacheTest.CacheTest,ANY leveldb.CacheTest.CacheTest (),util\cache_test.cc,"CacheTest() : cache_(NewLRUCache(kCacheSize)) {
    current_ = this;
  }",40.0,42.0,3.0,3.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,ANY
2379,81435,~CacheTest,1,leveldb.CacheTest.~CacheTest,ANY leveldb.CacheTest.~CacheTest (),util\cache_test.cc,"~CacheTest() {
    delete cache_;
  }",44.0,46.0,3.0,3.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,ANY
2380,81441,Lookup,1,leveldb.CacheTest.Lookup,int leveldb.CacheTest.Lookup (int),util\cache_test.cc,"int Lookup(int key) {
    Cache::Handle* handle = cache_->Lookup(EncodeKey(key));
    const int r = (handle == NULL) ? -1 : DecodeValue(cache_->Value(handle));
    if (handle != NULL) {
      cache_->Release(handle);
    }
    return r;
  }",48.0,55.0,3.0,3.0,8.0,9,6,13,5,0,3,2,2,0,0,,0,3,2,1,1,int
2381,81482,Insert,1,leveldb.CacheTest.Insert,"void leveldb.CacheTest.Insert (int,int,int)",util\cache_test.cc,"void Insert(int key, int value, int charge = 1) {
    cache_->Release(cache_->Insert(EncodeKey(key), EncodeValue(value), charge,
                                   &CacheTest::Deleter));
  }",57.0,60.0,3.0,3.0,4.0,4,3,6,5,0,2,1,1,0,0,,0,2,6,3,3,void
2382,81506,InsertAndReturnHandle,1,leveldb.CacheTest.InsertAndReturnHandle,"Handle leveldb.CacheTest.InsertAndReturnHandle (int,int,int)",util\cache_test.cc,"Cache::Handle* InsertAndReturnHandle(int key, int value, int charge = 1) {
    return cache_->Insert(EncodeKey(key), EncodeValue(value), charge,
                          &CacheTest::Deleter);
  }",62.0,65.0,3.0,3.0,4.0,3,3,5,5,0,1,1,1,0,0,,0,1,6,3,3,Handle
2383,81527,Erase,1,leveldb.CacheTest.Erase,void leveldb.CacheTest.Erase (int),util\cache_test.cc,"void Erase(int key) {
    cache_->Erase(EncodeKey(key));
  }",67.0,69.0,3.0,3.0,3.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
2384,81547,_Run,1,leveldb._Test_HitAndMiss._Run,void leveldb._Test_HitAndMiss._Run (),util\cache_test.cc,"TEST(CacheTest, HitAndMiss) {
  ASSERT_EQ(-1, Lookup(100));

  Insert(100, 101);
  ASSERT_EQ(101, Lookup(100));
  ASSERT_EQ(-1,  Lookup(200));
  ASSERT_EQ(-1,  Lookup(300));

  Insert(200, 201);
  ASSERT_EQ(101, Lookup(100));
  ASSERT_EQ(201, Lookup(200));
  ASSERT_EQ(-1,  Lookup(300));

  Insert(100, 102);
  ASSERT_EQ(102, Lookup(100));
  ASSERT_EQ(201, Lookup(200));
  ASSERT_EQ(-1,  Lookup(300));

  ASSERT_EQ(1, deleted_keys_.size());
  ASSERT_EQ(100, deleted_keys_[0]);
  ASSERT_EQ(101, deleted_values_[0]);
}",73.0,94.0,1.0,27.0,22.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2385,81551,_RunIt,1,leveldb._Test_HitAndMiss._RunIt,void leveldb._Test_HitAndMiss._RunIt (),util\cache_test.cc,"TEST(CacheTest, HitAndMiss)",73.0,73.0,1.0,27.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
2386,81854,_Run,1,leveldb._Test_Erase._Run,void leveldb._Test_Erase._Run (),util\cache_test.cc,"TEST(CacheTest, Erase) {
  Erase(200);
  ASSERT_EQ(0, deleted_keys_.size());

  Insert(100, 101);
  Insert(200, 201);
  Erase(100);
  ASSERT_EQ(-1,  Lookup(100));
  ASSERT_EQ(201, Lookup(200));
  ASSERT_EQ(1, deleted_keys_.size());
  ASSERT_EQ(100, deleted_keys_[0]);
  ASSERT_EQ(101, deleted_values_[0]);

  Erase(100);
  ASSERT_EQ(-1,  Lookup(100));
  ASSERT_EQ(201, Lookup(200));
  ASSERT_EQ(1, deleted_keys_.size());
}",96.0,113.0,1.0,22.0,18.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2387,81858,_RunIt,1,leveldb._Test_Erase._RunIt,void leveldb._Test_Erase._RunIt (),util\cache_test.cc,"TEST(CacheTest, Erase)",96.0,96.0,1.0,22.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
2388,82090,_Run,1,leveldb._Test_EntriesArePinned._Run,void leveldb._Test_EntriesArePinned._Run (),util\cache_test.cc,"TEST(CacheTest, EntriesArePinned) {
  Insert(100, 101);
  Cache::Handle* h1 = cache_->Lookup(EncodeKey(100));
  ASSERT_EQ(101, DecodeValue(cache_->Value(h1)));

  Insert(100, 102);
  Cache::Handle* h2 = cache_->Lookup(EncodeKey(100));
  ASSERT_EQ(102, DecodeValue(cache_->Value(h2)));
  ASSERT_EQ(0, deleted_keys_.size());

  cache_->Release(h1);
  ASSERT_EQ(1, deleted_keys_.size());
  ASSERT_EQ(100, deleted_keys_[0]);
  ASSERT_EQ(101, deleted_values_[0]);

  Erase(100);
  ASSERT_EQ(-1, Lookup(100));
  ASSERT_EQ(1, deleted_keys_.size());

  cache_->Release(h2);
  ASSERT_EQ(2, deleted_keys_.size());
  ASSERT_EQ(100, deleted_keys_[1]);
  ASSERT_EQ(102, deleted_values_[1]);
}",115.0,138.0,1.0,33.0,24.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2389,82094,_RunIt,1,leveldb._Test_EntriesArePinned._RunIt,void leveldb._Test_EntriesArePinned._RunIt (),util\cache_test.cc,"TEST(CacheTest, EntriesArePinned)",115.0,115.0,1.0,33.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
2390,82410,_Run,1,leveldb._Test_EvictionPolicy._Run,void leveldb._Test_EvictionPolicy._Run (),util\cache_test.cc,"TEST(CacheTest, EvictionPolicy) {
  Insert(100, 101);
  Insert(200, 201);
  Insert(300, 301);
  Cache::Handle* h = cache_->Lookup(EncodeKey(300));

  // Frequently used entry must be kept around,
  // as must things that are still in use.
  for (int i = 0; i < kCacheSize + 100; i++) {
    Insert(1000+i, 2000+i);
    ASSERT_EQ(2000+i, Lookup(1000+i));
    ASSERT_EQ(101, Lookup(100));
  }
  ASSERT_EQ(101, Lookup(100));
  ASSERT_EQ(-1, Lookup(200));
  ASSERT_EQ(301, Lookup(300));
  cache_->Release(h);
}",140.0,157.0,1.0,31.0,18.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2391,82414,_RunIt,1,leveldb._Test_EvictionPolicy._RunIt,void leveldb._Test_EvictionPolicy._RunIt (),util\cache_test.cc,"TEST(CacheTest, EvictionPolicy)",140.0,140.0,1.0,31.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
2392,82585,_Run,1,leveldb._Test_UseExceedsCacheSize._Run,void leveldb._Test_UseExceedsCacheSize._Run (),util\cache_test.cc,"TEST(CacheTest, UseExceedsCacheSize) {
  // Overfill the cache, keeping handles on all inserted entries.
  std::vector<Cache::Handle*> h;
  for (int i = 0; i < kCacheSize + 100; i++) {
    h.push_back(InsertAndReturnHandle(1000+i, 2000+i));
  }

  // Check that all the entries can be found in the cache.
  for (int i = 0; i < h.size(); i++) {
    ASSERT_EQ(2000+i, Lookup(1000+i));
  }

  for (int i = 0; i < h.size(); i++) {
    cache_->Release(h[i]);
  }
}",159.0,174.0,1.0,36.0,16.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2393,82589,_RunIt,1,leveldb._Test_UseExceedsCacheSize._RunIt,void leveldb._Test_UseExceedsCacheSize._RunIt (),util\cache_test.cc,"TEST(CacheTest, UseExceedsCacheSize)",159.0,159.0,1.0,36.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
2394,82701,_Run,1,leveldb._Test_HeavyEntries._Run,void leveldb._Test_HeavyEntries._Run (),util\cache_test.cc,"TEST(CacheTest, HeavyEntries) {
  // Add a bunch of light and heavy entries and then count the combined
  // size of items still in the cache, which must be approximately the
  // same as the total capacity.
  const int kLight = 1;
  const int kHeavy = 10;
  int added = 0;
  int index = 0;
  while (added < 2*kCacheSize) {
    const int weight = (index & 1) ? kLight : kHeavy;
    Insert(index, 1000+index, weight);
    added += weight;
    index++;
  }

  int cached_weight = 0;
  for (int i = 0; i < index; i++) {
    const int weight = (i & 1 ? kLight : kHeavy);
    int r = Lookup(i);
    if (r >= 0) {
      cached_weight += weight;
      ASSERT_EQ(1000+i, r);
    }
  }
  ASSERT_LE(cached_weight, kCacheSize + kCacheSize/10);
}",176.0,201.0,1.0,29.0,26.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2395,82705,_RunIt,1,leveldb._Test_HeavyEntries._RunIt,void leveldb._Test_HeavyEntries._RunIt (),util\cache_test.cc,"TEST(CacheTest, HeavyEntries)",176.0,176.0,1.0,29.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
2396,82853,_Run,1,leveldb._Test_NewId._Run,void leveldb._Test_NewId._Run (),util\cache_test.cc,"TEST(CacheTest, NewId) {
  uint64_t a = cache_->NewId();
  uint64_t b = cache_->NewId();
  ASSERT_NE(a, b);
}",203.0,207.0,1.0,22.0,5.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2397,82857,_RunIt,1,leveldb._Test_NewId._RunIt,void leveldb._Test_NewId._RunIt (),util\cache_test.cc,"TEST(CacheTest, NewId)",203.0,203.0,1.0,22.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
2398,82917,_Run,1,leveldb._Test_Prune._Run,void leveldb._Test_Prune._Run (),util\cache_test.cc,"TEST(CacheTest, Prune) {
  Insert(1, 100);
  Insert(2, 200);

  Cache::Handle* handle = cache_->Lookup(EncodeKey(1));
  ASSERT_TRUE(handle);
  cache_->Prune();
  cache_->Release(handle);

  ASSERT_EQ(100, Lookup(1));
  ASSERT_EQ(-1, Lookup(2));
}",209.0,220.0,1.0,22.0,12.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2399,82921,_RunIt,1,leveldb._Test_Prune._RunIt,void leveldb._Test_Prune._RunIt (),util\cache_test.cc,"TEST(CacheTest, Prune)",209.0,209.0,1.0,22.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
2400,83050,EncodeFixed32,1,leveldb.EncodeFixed32,"void leveldb.EncodeFixed32 (char*,uint32_t)",util\coding.cc,"void EncodeFixed32(char* buf, uint32_t value) {
  if (port::kLittleEndian) {
    memcpy(buf, &value, sizeof(value));
  } else {
    buf[0] = value & 0xff;
    buf[1] = (value >> 8) & 0xff;
    buf[2] = (value >> 16) & 0xff;
    buf[3] = (value >> 24) & 0xff;
  }
}",9.0,18.0,1.0,1.0,10.0,3,3,4,3,0,0,2,2,0,0,,0,0,4,2,2,void
2401,83103,EncodeFixed64,1,leveldb.EncodeFixed64,"void leveldb.EncodeFixed64 (char*,uint64_t)",util\coding.cc,"void EncodeFixed64(char* buf, uint64_t value) {
  if (port::kLittleEndian) {
    memcpy(buf, &value, sizeof(value));
  } else {
    buf[0] = value & 0xff;
    buf[1] = (value >> 8) & 0xff;
    buf[2] = (value >> 16) & 0xff;
    buf[3] = (value >> 24) & 0xff;
    buf[4] = (value >> 32) & 0xff;
    buf[5] = (value >> 40) & 0xff;
    buf[6] = (value >> 48) & 0xff;
    buf[7] = (value >> 56) & 0xff;
  }
}",20.0,33.0,1.0,1.0,14.0,3,3,4,3,0,0,2,2,0,0,,0,0,4,2,2,void
2402,83192,PutFixed32,1,leveldb.PutFixed32,"void leveldb.PutFixed32 (ANY*,uint32_t)",util\coding.cc,"void PutFixed32(std::string* dst, uint32_t value) {
  char buf[sizeof(value)];
  EncodeFixed32(buf, value);
  dst->append(buf, sizeof(buf));
}",35.0,39.0,1.0,1.0,5.0,2,2,5,3,0,0,1,1,0,0,,0,0,4,2,2,void
2403,83209,PutFixed64,1,leveldb.PutFixed64,"void leveldb.PutFixed64 (ANY*,uint64_t)",util\coding.cc,"void PutFixed64(std::string* dst, uint64_t value) {
  char buf[sizeof(value)];
  EncodeFixed64(buf, value);
  dst->append(buf, sizeof(buf));
}",41.0,45.0,1.0,1.0,5.0,2,2,5,3,0,0,1,1,0,0,,0,0,4,2,2,void
2404,83226,EncodeVarint32,1,leveldb.EncodeVarint32,"char* leveldb.EncodeVarint32 (char*,uint32_t)",util\coding.cc,"char* EncodeVarint32(char* dst, uint32_t v) {
  // Operate on characters as unsigneds
  unsigned char* ptr = reinterpret_cast<unsigned char*>(dst);
  static const int B = 128;
  if (v < (1<<7)) {
    *(ptr++) = v;
  } else if (v < (1<<14)) {
    *(ptr++) = v | B;
    *(ptr++) = v>>7;
  } else if (v < (1<<21)) {
    *(ptr++) = v | B;
    *(ptr++) = (v>>7) | B;
    *(ptr++) = v>>14;
  } else if (v < (1<<28)) {
    *(ptr++) = v | B;
    *(ptr++) = (v>>7) | B;
    *(ptr++) = (v>>14) | B;
    *(ptr++) = v>>21;
  } else {
    *(ptr++) = v | B;
    *(ptr++) = (v>>7) | B;
    *(ptr++) = (v>>14) | B;
    *(ptr++) = (v>>21) | B;
    *(ptr++) = v>>28;
  }
  return reinterpret_cast<char*>(ptr);
}",47.0,73.0,1.0,1.0,27.0,9,6,7,4,0,0,2,2,0,0,,0,0,4,2,2,char*
2405,83397,PutVarint32,1,leveldb.PutVarint32,"void leveldb.PutVarint32 (ANY*,uint32_t)",util\coding.cc,"void PutVarint32(std::string* dst, uint32_t v) {
  char buf[5];
  char* ptr = EncodeVarint32(buf, v);
  dst->append(buf, ptr - buf);
}",75.0,79.0,1.0,1.0,5.0,3,3,7,4,0,0,1,1,0,0,,0,0,4,2,2,void
2406,83418,EncodeVarint64,1,leveldb.EncodeVarint64,"char* leveldb.EncodeVarint64 (char*,uint64_t)",util\coding.cc,"char* EncodeVarint64(char* dst, uint64_t v) {
  static const int B = 128;
  unsigned char* ptr = reinterpret_cast<unsigned char*>(dst);
  while (v >= B) {
    *(ptr++) = (v & (B-1)) | B;
    v >>= 7;
  }
  *(ptr++) = static_cast<unsigned char>(v);
  return reinterpret_cast<char*>(ptr);
}",81.0,90.0,1.0,1.0,10.0,15,8,13,4,0,0,2,2,0,0,,0,0,4,2,2,char*
2407,83464,PutVarint64,1,leveldb.PutVarint64,"void leveldb.PutVarint64 (ANY*,uint64_t)",util\coding.cc,"void PutVarint64(std::string* dst, uint64_t v) {
  char buf[10];
  char* ptr = EncodeVarint64(buf, v);
  dst->append(buf, ptr - buf);
}",92.0,96.0,1.0,1.0,5.0,3,3,7,4,0,0,1,1,0,0,,0,0,4,2,2,void
2408,83485,PutLengthPrefixedSlice,1,leveldb.PutLengthPrefixedSlice,"void leveldb.PutLengthPrefixedSlice (ANY*,Slice)",util\coding.cc,"void PutLengthPrefixedSlice(std::string* dst, const Slice& value) {
  PutVarint32(dst, value.size());
  dst->append(value.data(), value.size());
}",98.0,101.0,1.0,1.0,4.0,4,2,5,2,0,0,1,1,0,0,,0,0,4,2,2,void
2409,83509,VarintLength,1,leveldb.VarintLength,int leveldb.VarintLength (uint64_t),util\coding.cc,"int VarintLength(uint64_t v) {
  int len = 1;
  while (v >= 128) {
    v >>= 7;
    len++;
  }
  return len;
}",103.0,110.0,1.0,1.0,8.0,3,3,5,2,0,0,2,2,0,0,,0,0,2,1,1,int
2410,83530,GetVarint32PtrFallback,1,leveldb.GetVarint32PtrFallback,"const char* leveldb.GetVarint32PtrFallback (char*,char*,uint32_t*)",util\coding.cc,"const char* GetVarint32PtrFallback(const char* p,
                                   const char* limit,
                                   uint32_t* value) {
  uint32_t result = 0;
  for (uint32_t shift = 0; shift <= 28 && p < limit; shift += 7) {
    uint32_t byte = *(reinterpret_cast<const unsigned char*>(p));
    p++;
    if (byte & 128) {
      // More bytes are present
      result |= ((byte & 127) << shift);
    } else {
      result |= (byte << shift);
      *value = result;
      return reinterpret_cast<const char*>(p);
    }
  }
  return NULL;
}",112.0,129.0,1.0,1.0,18.0,12,9,13,6,0,0,3,4,0,0,,0,0,6,3,3,const char*
2411,83596,GetVarint32,1,leveldb.GetVarint32,"bool leveldb.GetVarint32 (Slice*,uint32_t*)",util\coding.cc,"bool GetVarint32(Slice* input, uint32_t* value) {
  const char* p = input->data();
  const char* limit = p + input->size();
  const char* q = GetVarint32Ptr(p, limit, value);
  if (q == NULL) {
    return false;
  } else {
    *input = Slice(q, limit - q);
    return true;
  }
}",131.0,141.0,1.0,1.0,11.0,7,4,11,6,0,0,2,2,0,0,,0,0,4,2,2,bool
2412,83644,GetVarint64Ptr,1,leveldb.GetVarint64Ptr,"const char* leveldb.GetVarint64Ptr (char*,char*,uint64_t*)",util\coding.cc,"const char* GetVarint64Ptr(const char* p, const char* limit, uint64_t* value) {
  uint64_t result = 0;
  for (uint32_t shift = 0; shift <= 63 && p < limit; shift += 7) {
    uint64_t byte = *(reinterpret_cast<const unsigned char*>(p));
    p++;
    if (byte & 128) {
      // More bytes are present
      result |= ((byte & 127) << shift);
    } else {
      result |= (byte << shift);
      *value = result;
      return reinterpret_cast<const char*>(p);
    }
  }
  return NULL;
}",143.0,158.0,1.0,1.0,16.0,12,9,13,6,0,0,3,4,0,0,,0,0,6,3,3,const char*
2413,83710,GetVarint64,1,leveldb.GetVarint64,"bool leveldb.GetVarint64 (Slice*,uint64_t*)",util\coding.cc,"bool GetVarint64(Slice* input, uint64_t* value) {
  const char* p = input->data();
  const char* limit = p + input->size();
  const char* q = GetVarint64Ptr(p, limit, value);
  if (q == NULL) {
    return false;
  } else {
    *input = Slice(q, limit - q);
    return true;
  }
}",160.0,170.0,1.0,1.0,11.0,7,4,11,6,0,0,2,2,0,0,,0,0,4,2,2,bool
2414,83903,GetVarint32Ptr,1,leveldb.GetVarint32Ptr,"char* leveldb.GetVarint32Ptr (char*,char*,uint32_t*)",util\coding.hpp,"inline const char* GetVarint32Ptr(const char* p,
                                  const char* limit,
                                  uint32_t* value) {
  if (p < limit) {
    uint32_t result = *(reinterpret_cast<const unsigned char*>(p));
    if ((result & 128) == 0) {
      *value = result;
      return p + 1;
    }
  }
  return GetVarint32PtrFallback(p, limit, value);
}",89.0,100.0,1.0,1.0,12.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,const char*
2415,83946,DecodeFixed32,1,leveldb.DecodeFixed32,uint32_t leveldb.DecodeFixed32 (char*),util\coding.hpp,"inline uint32_t DecodeFixed32(const char* ptr) {
  if (port::kLittleEndian) {
    // Load the raw bytes
    uint32_t result;
    memcpy(&result, ptr, sizeof(result));  // gcc optimizes this to a plain load
    return result;
  } else {
    return ((static_cast<uint32_t>(static_cast<unsigned char>(ptr[0])))
        | (static_cast<uint32_t>(static_cast<unsigned char>(ptr[1])) << 8)
        | (static_cast<uint32_t>(static_cast<unsigned char>(ptr[2])) << 16)
        | (static_cast<uint32_t>(static_cast<unsigned char>(ptr[3])) << 24));
  }
}",58.0,70.0,1.0,1.0,13.0,3,3,5,3,0,0,2,2,0,0,,0,0,2,1,1,uint32_t
2416,84005,DecodeFixed64,1,leveldb.DecodeFixed64,uint64_t leveldb.DecodeFixed64 (char*),util\coding.hpp,"inline uint64_t DecodeFixed64(const char* ptr) {
  if (port::kLittleEndian) {
    // Load the raw bytes
    uint64_t result;
    memcpy(&result, ptr, sizeof(result));  // gcc optimizes this to a plain load
    return result;
  } else {
    uint64_t lo = DecodeFixed32(ptr);
    uint64_t hi = DecodeFixed32(ptr + 4);
    return (hi << 32) | lo;
  }
}",72.0,83.0,1.0,1.0,12.0,3,3,5,3,0,0,2,2,0,0,,0,0,2,1,1,uint64_t
2417,84102,_Run,1,leveldb._Test_Fixed32._Run,void leveldb._Test_Fixed32._Run (),util\coding_test.cc,"TEST(Coding, Fixed32) {
  std::string s;
  for (uint32_t v = 0; v < 100000; v++) {
    PutFixed32(&s, v);
  }

  const char* p = s.data();
  for (uint32_t v = 0; v < 100000; v++) {
    uint32_t actual = DecodeFixed32(p);
    ASSERT_EQ(v, actual);
    p += sizeof(uint32_t);
  }
}",13.0,25.0,1.0,21.0,13.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2418,84106,_RunIt,1,leveldb._Test_Fixed32._RunIt,void leveldb._Test_Fixed32._RunIt (),util\coding_test.cc,"TEST(Coding, Fixed32)",13.0,13.0,1.0,21.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
2419,84197,_Run,1,leveldb._Test_Fixed64._Run,void leveldb._Test_Fixed64._Run (),util\coding_test.cc,"TEST(Coding, Fixed64) {
  std::string s;
  for (int power = 0; power <= 63; power++) {
    uint64_t v = static_cast<uint64_t>(1) << power;
    PutFixed64(&s, v - 1);
    PutFixed64(&s, v + 0);
    PutFixed64(&s, v + 1);
  }

  const char* p = s.data();
  for (int power = 0; power <= 63; power++) {
    uint64_t v = static_cast<uint64_t>(1) << power;
    uint64_t actual;
    actual = DecodeFixed64(p);
    ASSERT_EQ(v-1, actual);
    p += sizeof(uint64_t);

    actual = DecodeFixed64(p);
    ASSERT_EQ(v+0, actual);
    p += sizeof(uint64_t);

    actual = DecodeFixed64(p);
    ASSERT_EQ(v+1, actual);
    p += sizeof(uint64_t);
  }
}",27.0,52.0,1.0,21.0,26.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2420,84201,_RunIt,1,leveldb._Test_Fixed64._RunIt,void leveldb._Test_Fixed64._RunIt (),util\coding_test.cc,"TEST(Coding, Fixed64)",27.0,27.0,1.0,21.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
2421,84375,_Run,1,leveldb._Test_EncodingOutput._Run,void leveldb._Test_EncodingOutput._Run (),util\coding_test.cc,"TEST(Coding, EncodingOutput) {
  std::string dst;
  PutFixed32(&dst, 0x04030201);
  ASSERT_EQ(4, dst.size());
  ASSERT_EQ(0x01, static_cast<int>(dst[0]));
  ASSERT_EQ(0x02, static_cast<int>(dst[1]));
  ASSERT_EQ(0x03, static_cast<int>(dst[2]));
  ASSERT_EQ(0x04, static_cast<int>(dst[3]));

  dst.clear();
  PutFixed64(&dst, 0x0807060504030201ull);
  ASSERT_EQ(8, dst.size());
  ASSERT_EQ(0x01, static_cast<int>(dst[0]));
  ASSERT_EQ(0x02, static_cast<int>(dst[1]));
  ASSERT_EQ(0x03, static_cast<int>(dst[2]));
  ASSERT_EQ(0x04, static_cast<int>(dst[3]));
  ASSERT_EQ(0x05, static_cast<int>(dst[4]));
  ASSERT_EQ(0x06, static_cast<int>(dst[5]));
  ASSERT_EQ(0x07, static_cast<int>(dst[6]));
  ASSERT_EQ(0x08, static_cast<int>(dst[7]));
}",55.0,75.0,1.0,28.0,21.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2422,84379,_RunIt,1,leveldb._Test_EncodingOutput._RunIt,void leveldb._Test_EncodingOutput._RunIt (),util\coding_test.cc,"TEST(Coding, EncodingOutput)",55.0,55.0,1.0,28.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
2423,84767,_Run,1,leveldb._Test_Varint32._Run,void leveldb._Test_Varint32._Run (),util\coding_test.cc,"TEST(Coding, Varint32) {
  std::string s;
  for (uint32_t i = 0; i < (32 * 32); i++) {
    uint32_t v = (i / 32) << (i % 32);
    PutVarint32(&s, v);
  }

  const char* p = s.data();
  const char* limit = p + s.size();
  for (uint32_t i = 0; i < (32 * 32); i++) {
    uint32_t expected = (i / 32) << (i % 32);
    uint32_t actual;
    const char* start = p;
    p = GetVarint32Ptr(p, limit, &actual);
    ASSERT_TRUE(p != NULL);
    ASSERT_EQ(expected, actual);
    ASSERT_EQ(VarintLength(actual), p - start);
  }
  ASSERT_EQ(p, s.data() + s.size());
}",77.0,96.0,1.0,22.0,20.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2424,84771,_RunIt,1,leveldb._Test_Varint32._RunIt,void leveldb._Test_Varint32._RunIt (),util\coding_test.cc,"TEST(Coding, Varint32)",77.0,77.0,1.0,22.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
2425,84959,_Run,1,leveldb._Test_Varint64._Run,void leveldb._Test_Varint64._Run (),util\coding_test.cc,"TEST(Coding, Varint64) {
  // Construct the list of values to check
  std::vector<uint64_t> values;
  // Some special values
  values.push_back(0);
  values.push_back(100);
  values.push_back(~static_cast<uint64_t>(0));
  values.push_back(~static_cast<uint64_t>(0) - 1);
  for (uint32_t k = 0; k < 64; k++) {
    // Test values near powers of two
    const uint64_t power = 1ull << k;
    values.push_back(power);
    values.push_back(power-1);
    values.push_back(power+1);
  }

  std::string s;
  for (size_t i = 0; i < values.size(); i++) {
    PutVarint64(&s, values[i]);
  }

  const char* p = s.data();
  const char* limit = p + s.size();
  for (size_t i = 0; i < values.size(); i++) {
    ASSERT_TRUE(p < limit);
    uint64_t actual;
    const char* start = p;
    p = GetVarint64Ptr(p, limit, &actual);
    ASSERT_TRUE(p != NULL);
    ASSERT_EQ(values[i], actual);
    ASSERT_EQ(VarintLength(actual), p - start);
  }
  ASSERT_EQ(p, limit);

}",98.0,132.0,1.0,22.0,35.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2426,84963,_RunIt,1,leveldb._Test_Varint64._RunIt,void leveldb._Test_Varint64._RunIt (),util\coding_test.cc,"TEST(Coding, Varint64)",98.0,98.0,1.0,22.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
2427,85221,_Run,1,leveldb._Test_Varint32Overflow._Run,void leveldb._Test_Varint32Overflow._Run (),util\coding_test.cc,"TEST(Coding, Varint32Overflow) {
  uint32_t result;
  std::string input(""\x81\x82\x83\x84\x85\x11"");
  ASSERT_TRUE(GetVarint32Ptr(input.data(), input.data() + input.size(), &result)
              == NULL);
}",134.0,139.0,1.0,30.0,6.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2428,85225,_RunIt,1,leveldb._Test_Varint32Overflow._RunIt,void leveldb._Test_Varint32Overflow._RunIt (),util\coding_test.cc,"TEST(Coding, Varint32Overflow)",134.0,134.0,1.0,30.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
2429,85290,_Run,1,leveldb._Test_Varint32Truncation._Run,void leveldb._Test_Varint32Truncation._Run (),util\coding_test.cc,"TEST(Coding, Varint32Truncation) {
  uint32_t large_value = (1u << 31) + 100;
  std::string s;
  PutVarint32(&s, large_value);
  uint32_t result;
  for (size_t len = 0; len < s.size() - 1; len++) {
    ASSERT_TRUE(GetVarint32Ptr(s.data(), s.data() + len, &result) == NULL);
  }
  ASSERT_TRUE(GetVarint32Ptr(s.data(), s.data() + s.size(), &result) != NULL);
  ASSERT_EQ(large_value, result);
}",141.0,151.0,1.0,32.0,11.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2430,85294,_RunIt,1,leveldb._Test_Varint32Truncation._RunIt,void leveldb._Test_Varint32Truncation._RunIt (),util\coding_test.cc,"TEST(Coding, Varint32Truncation)",141.0,141.0,1.0,32.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
2431,85432,_Run,1,leveldb._Test_Varint64Overflow._Run,void leveldb._Test_Varint64Overflow._Run (),util\coding_test.cc,"TEST(Coding, Varint64Overflow) {
  uint64_t result;
  std::string input(""\x81\x82\x83\x84\x85\x81\x82\x83\x84\x85\x11"");
  ASSERT_TRUE(GetVarint64Ptr(input.data(), input.data() + input.size(), &result)
              == NULL);
}",153.0,158.0,1.0,30.0,6.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2432,85436,_RunIt,1,leveldb._Test_Varint64Overflow._RunIt,void leveldb._Test_Varint64Overflow._RunIt (),util\coding_test.cc,"TEST(Coding, Varint64Overflow)",153.0,153.0,1.0,30.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
2433,85501,_Run,1,leveldb._Test_Varint64Truncation._Run,void leveldb._Test_Varint64Truncation._Run (),util\coding_test.cc,"TEST(Coding, Varint64Truncation) {
  uint64_t large_value = (1ull << 63) + 100ull;
  std::string s;
  PutVarint64(&s, large_value);
  uint64_t result;
  for (size_t len = 0; len < s.size() - 1; len++) {
    ASSERT_TRUE(GetVarint64Ptr(s.data(), s.data() + len, &result) == NULL);
  }
  ASSERT_TRUE(GetVarint64Ptr(s.data(), s.data() + s.size(), &result) != NULL);
  ASSERT_EQ(large_value, result);
}",160.0,170.0,1.0,32.0,11.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2434,85505,_RunIt,1,leveldb._Test_Varint64Truncation._RunIt,void leveldb._Test_Varint64Truncation._RunIt (),util\coding_test.cc,"TEST(Coding, Varint64Truncation)",160.0,160.0,1.0,32.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
2435,85643,_Run,1,leveldb._Test_Strings._Run,void leveldb._Test_Strings._Run (),util\coding_test.cc,"TEST(Coding, Strings) {
  std::string s;
  PutLengthPrefixedSlice(&s, Slice(""""));
  PutLengthPrefixedSlice(&s, Slice(""foo""));
  PutLengthPrefixedSlice(&s, Slice(""bar""));
  PutLengthPrefixedSlice(&s, Slice(std::string(200, 'x')));

  Slice input(s);
  Slice v;
  ASSERT_TRUE(GetLengthPrefixedSlice(&input, &v));
  ASSERT_EQ("""", v.ToString());
  ASSERT_TRUE(GetLengthPrefixedSlice(&input, &v));
  ASSERT_EQ(""foo"", v.ToString());
  ASSERT_TRUE(GetLengthPrefixedSlice(&input, &v));
  ASSERT_EQ(""bar"", v.ToString());
  ASSERT_TRUE(GetLengthPrefixedSlice(&input, &v));
  ASSERT_EQ(std::string(200, 'x'), v.ToString());
  ASSERT_EQ("""", input.ToString());
}",172.0,190.0,1.0,21.0,19.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2436,85647,_RunIt,1,leveldb._Test_Strings._RunIt,void leveldb._Test_Strings._RunIt (),util\coding_test.cc,"TEST(Coding, Strings)",172.0,172.0,1.0,21.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
2437,85937,BytewiseComparatorImpl,1,leveldb.anonymous_namespace_2.BytewiseComparatorImpl.BytewiseComparatorImpl,ANY leveldb.anonymous_namespace_2.BytewiseComparatorImpl.BytewiseComparatorImpl (),util\comparator.cc,BytewiseComparatorImpl() { },19.0,19.0,3.0,30.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
2438,85941,Name,1,leveldb.anonymous_namespace_3.BytewiseComparatorImpl.Name,const char* leveldb.anonymous_namespace_3.BytewiseComparatorImpl.Name (),util\comparator.cc,"virtual const char* Name() const {
    return ""leveldb.BytewiseComparator"";
  }",21.0,23.0,3.0,3.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,const char*
2439,85947,Compare,1,leveldb.anonymous_namespace_4.BytewiseComparatorImpl.Compare,"int leveldb.anonymous_namespace_4.BytewiseComparatorImpl.Compare (Slice,Slice)",util\comparator.cc,"virtual int Compare(const Slice& a, const Slice& b) const {
    return a.compare(b);
  }",25.0,27.0,3.0,3.0,3.0,1,1,2,2,0,0,1,1,0,0,,0,0,4,2,2,int
2440,85959,FindShortestSeparator,1,leveldb.anonymous_namespace_5.BytewiseComparatorImpl.FindShortestSeparator,"void leveldb.anonymous_namespace_5.BytewiseComparatorImpl.FindShortestSeparator (ANY*,Slice)",util\comparator.cc,"virtual void FindShortestSeparator(
      std::string* start,
      const Slice& limit) const {
    // Find length of common prefix
    size_t min_length = std::min(start->size(), limit.size());
    size_t diff_index = 0;
    while ((diff_index < min_length) &&
           ((*start)[diff_index] == limit[diff_index])) {
      diff_index++;
    }

    if (diff_index >= min_length) {
      // Do not shorten if one string is a prefix of the other
    } else {
      uint8_t diff_byte = static_cast<uint8_t>((*start)[diff_index]);
      if (diff_byte < static_cast<uint8_t>(0xff) &&
          diff_byte + 1 < static_cast<uint8_t>(limit[diff_index])) {
        (*start)[diff_index]++;
        start->resize(diff_index + 1);
        assert(Compare(*start, limit) < 0);
      }
    }
  }",29.0,51.0,3.0,3.0,23.0,13,10,14,5,0,0,3,3,0,0,,0,0,4,2,2,void
2441,86052,FindShortSuccessor,1,leveldb.anonymous_namespace_7.BytewiseComparatorImpl.FindShortSuccessor,void leveldb.anonymous_namespace_7.BytewiseComparatorImpl.FindShortSuccessor (ANY*),util\comparator.cc,"virtual void FindShortSuccessor(std::string* key) const {
    // Find first character that can be incremented
    size_t n = key->size();
    for (size_t i = 0; i < n; i++) {
      const uint8_t byte = (*key)[i];
      if (byte != static_cast<uint8_t>(0xff)) {
        (*key)[i] = byte + 1;
        key->resize(i+1);
        return;
      }
    }
    // *key is a run of 0xffs.  Leave it alone.
  }",53.0,65.0,3.0,3.0,13.0,15,8,14,4,0,0,3,4,0,0,,0,0,2,1,1,void
2442,86111,InitModule,1,leveldb.InitModule,void leveldb.InitModule (),util\comparator.cc,"static void InitModule() {
  bytewise = new BytewiseComparatorImpl;
}",72.0,74.0,1.0,1.0,3.0,2,2,2,2,0,0,1,1,0,0,,0,0,0,0,0,void
2443,87187,LE_LOAD32,1,leveldb.crc32c.LE_LOAD32,uint32_t leveldb.crc32c.LE_LOAD32 (uint8_t*),util\crc32c.cc,"static inline uint32_t LE_LOAD32(const uint8_t *p) {
  return DecodeFixed32(reinterpret_cast<const char*>(p));
}",284.0,286.0,1.0,1.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,uint32_t
2444,87197,CanAccelerateCRC32C,1,leveldb.crc32c.CanAccelerateCRC32C,bool leveldb.crc32c.CanAccelerateCRC32C (),util\crc32c.cc,"static bool CanAccelerateCRC32C() {
  // port::AcceleretedCRC32C returns zero when unable to accelerate.
  static const char kTestCRCBuffer[] = ""TestCRCBuffer"";
  static const char kBufSize = sizeof(kTestCRCBuffer) - 1;
  static const uint32_t kTestCRCValue = 0xdcbc59fa;

  return port::AcceleratedCRC32C(0, kTestCRCBuffer, kBufSize) == kTestCRCValue;
}",290.0,297.0,1.0,1.0,8.0,7,5,8,4,0,0,1,1,0,0,,0,0,0,0,0,bool
2445,87226,Extend,1,leveldb.crc32c.Extend,"uint32_t leveldb.crc32c.Extend (uint32_t,char*,size_t)",util\crc32c.cc,"uint32_t Extend(uint32_t crc, const char* buf, size_t size) {
  static bool accelerate = CanAccelerateCRC32C();
  if (accelerate) {
    return port::AcceleratedCRC32C(crc, buf, size);
  }

  const uint8_t *p = reinterpret_cast<const uint8_t *>(buf);
  const uint8_t *e = p + size;
  uint32_t l = crc ^ 0xffffffffu;

#define STEP1 do {                              \
    int c = (l & 0xff) ^ *p++;                  \
    l = table0_[c] ^ (l >> 8);                  \
} while (0)
#define STEP4 do {                              \
    uint32_t c = l ^ LE_LOAD32(p);              \
    p += 4;                                     \
    l = table3_[c & 0xff] ^                     \
        table2_[(c >> 8) & 0xff] ^              \
        table1_[(c >> 16) & 0xff] ^             \
        table0_[c >> 24];                       \
} while (0)

  // Point x at first 4-byte aligned byte in string.  This might be
  // just past the end of the string.
  const uintptr_t pval = reinterpret_cast<uintptr_...",299.0,347.0,1.0,6.0,49.0,126,16,107,17,0,0,7,8,0,0,,0,0,6,3,3,uint32_t
2446,87610,Value,1,leveldb.crc32c.Value,"uint32_t leveldb.crc32c.Value (char*,size_t)",util\crc32c.hpp,"inline uint32_t Value(const char* data, size_t n) {
  return Extend(0, data, n);
}",20.0,22.0,1.0,1.0,3.0,0,0,2,2,0,0,1,1,0,0,,0,0,4,2,2,uint32_t
2447,87625,Mask,1,leveldb.crc32c.Mask,uint32_t leveldb.crc32c.Mask (uint32_t),util\crc32c.hpp,"inline uint32_t Mask(uint32_t crc) {
  // Rotate right by 15 bits and add a constant.
  return ((crc >> 15) | (crc << 17)) + kMaskDelta;
}",31.0,34.0,1.0,1.0,4.0,4,4,3,2,0,0,1,1,0,0,,0,0,2,1,1,uint32_t
2448,87640,Unmask,1,leveldb.crc32c.Unmask,uint32_t leveldb.crc32c.Unmask (uint32_t),util\crc32c.hpp,"inline uint32_t Unmask(uint32_t masked_crc) {
  uint32_t rot = masked_crc - kMaskDelta;
  return ((rot >> 17) | (rot << 15));
}",37.0,40.0,1.0,1.0,4.0,5,5,5,3,0,0,1,1,0,0,,0,0,2,1,1,uint32_t
2449,87672,_Run,1,leveldb.crc32c._Test_StandardResults._Run,void leveldb.crc32c._Test_StandardResults._Run (),util\crc32c_test.cc,"TEST(CRC, StandardResults) {
  // From rfc3720 section B.4.
  char buf[32];

  memset(buf, 0, sizeof(buf));
  ASSERT_EQ(0x8a9136aa, Value(buf, sizeof(buf)));

  memset(buf, 0xff, sizeof(buf));
  ASSERT_EQ(0x62a8ab43, Value(buf, sizeof(buf)));

  for (int i = 0; i < 32; i++) {
    buf[i] = i;
  }
  ASSERT_EQ(0x46dd794e, Value(buf, sizeof(buf)));

  for (int i = 0; i < 32; i++) {
    buf[i] = 31 - i;
  }
  ASSERT_EQ(0x113fdb5c, Value(buf, sizeof(buf)));

  unsigned char data[48] = {
    0x01, 0xc0, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x14, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x04, 0x00,
    0x00, 0x00, 0x00, 0x14,
    0x00, 0x00, 0x00, 0x18,
    0x28, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x02, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
  };
  ASSERT_EQ(0xd9963a56, Value(reinterpret_cast<char*>(data), sizeof(data)));
}",13.0,48.0,1.0,26.0,36.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2450,87676,_RunIt,1,leveldb.crc32c._Test_StandardResults._RunIt,void leveldb.crc32c._Test_StandardResults._RunIt (),util\crc32c_test.cc,"TEST(CRC, StandardResults)",13.0,13.0,1.0,26.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
2451,87901,_Run,1,leveldb.crc32c._Test_Values._Run,void leveldb.crc32c._Test_Values._Run (),util\crc32c_test.cc,"TEST(CRC, Values) {
  ASSERT_NE(Value(""a"", 1), Value(""foo"", 3));
}",50.0,52.0,1.0,17.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2452,87905,_RunIt,1,leveldb.crc32c._Test_Values._RunIt,void leveldb.crc32c._Test_Values._RunIt (),util\crc32c_test.cc,"TEST(CRC, Values)",50.0,50.0,1.0,17.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
2453,87953,_Run,1,leveldb.crc32c._Test_Extend._Run,void leveldb.crc32c._Test_Extend._Run (),util\crc32c_test.cc,"TEST(CRC, Extend) {
  ASSERT_EQ(Value(""hello world"", 11),
            Extend(Value(""hello "", 6), ""world"", 5));
}",54.0,57.0,1.0,17.0,4.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2454,87957,_RunIt,1,leveldb.crc32c._Test_Extend._RunIt,void leveldb.crc32c._Test_Extend._RunIt (),util\crc32c_test.cc,"TEST(CRC, Extend)",54.0,54.0,1.0,17.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
2455,88008,_Run,1,leveldb.crc32c._Test_Mask._Run,void leveldb.crc32c._Test_Mask._Run (),util\crc32c_test.cc,"TEST(CRC, Mask) {
  uint32_t crc = Value(""foo"", 3);
  ASSERT_NE(crc, Mask(crc));
  ASSERT_NE(crc, Mask(Mask(crc)));
  ASSERT_EQ(crc, Unmask(Mask(crc)));
  ASSERT_EQ(crc, Unmask(Unmask(Mask(Mask(crc)))));
}",59.0,65.0,1.0,15.0,7.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2456,88012,_RunIt,1,leveldb.crc32c._Test_Mask._RunIt,void leveldb.crc32c._Test_Mask._RunIt (),util\crc32c_test.cc,"TEST(CRC, Mask)",59.0,59.0,1.0,15.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
2457,88213,DoWriteStringToFile,1,leveldb.DoWriteStringToFile,"Status leveldb.DoWriteStringToFile (Env*,Slice,ANY,bool)",util\env.cc,"static Status DoWriteStringToFile(Env* env, const Slice& data,
                                  const std::string& fname,
                                  bool should_sync) {
  WritableFile* file;
  Status s = env->NewWritableFile(fname, &file);
  if (!s.ok()) {
    return s;
  }
  s = file->Append(data);
  if (s.ok() && should_sync) {
    s = file->Sync();
  }
  if (s.ok()) {
    s = file->Close();
  }
  delete file;  // Will auto-close if we did not close above
  if (!s.ok()) {
    env->DeleteFile(fname);
  }
  return s;
}",40.0,60.0,1.0,1.0,21.0,18,7,21,6,0,0,5,5,0,0,,0,0,8,4,4,Status
2458,88472,IOError,1,leveldb.anonymous_namespace_1.IOError,"Status leveldb.anonymous_namespace_1.IOError (ANY,int)",util\env_posix.cc,"static Status IOError(const std::string& context, int err_number) {
  return Status::IOError(context, strerror(err_number));
}",37.0,39.0,1.0,1.0,3.0,1,1,3,3,0,0,1,1,0,0,,0,0,4,2,2,Status
2459,88487,Limiter,1,leveldb.anonymous_namespace_3.Limiter.Limiter,ANY leveldb.anonymous_namespace_3.Limiter.Limiter (intptr_t),util\env_posix.cc,"Limiter(intptr_t n) {
    SetAllowed(n);
  }",48.0,50.0,3.0,3.0,3.0,0,0,1,1,0,0,1,1,0,0,,0,0,2,1,1,ANY
2460,88494,Acquire,1,leveldb.anonymous_namespace_5.Limiter.Acquire,bool leveldb.anonymous_namespace_5.Limiter.Acquire (),util\env_posix.cc,"bool Acquire() {
    if (GetAllowed() <= 0) {
      return false;
    }
    MutexLock l(&mu_);
    intptr_t x = GetAllowed();
    if (x <= 0) {
      return false;
    } else {
      SetAllowed(x - 1);
      return true;
    }
  }",54.0,66.0,3.0,3.0,13.0,4,3,3,2,0,1,3,3,0,0,,0,1,0,0,0,bool
2461,88528,Release,1,leveldb.anonymous_namespace_9.Limiter.Release,void leveldb.anonymous_namespace_9.Limiter.Release (),util\env_posix.cc,"void Release() {
    MutexLock l(&mu_);
    SetAllowed(GetAllowed() + 1);
  }",70.0,73.0,3.0,3.0,4.0,2,2,1,1,0,1,1,1,0,0,,0,1,0,0,0,void
2462,88542,GetAllowed,1,leveldb.anonymous_namespace_12.Limiter.GetAllowed,intptr_t leveldb.anonymous_namespace_12.Limiter.GetAllowed (),util\env_posix.cc,"intptr_t GetAllowed() const {
    return reinterpret_cast<intptr_t>(allowed_.Acquire_Load());
  }",79.0,81.0,3.0,3.0,3.0,2,2,1,1,0,1,1,1,0,0,,0,1,0,0,0,intptr_t
2463,88553,SetAllowed,1,leveldb.anonymous_namespace_13.Limiter.SetAllowed,void leveldb.anonymous_namespace_13.Limiter.SetAllowed (intptr_t),util\env_posix.cc,"void SetAllowed(intptr_t v) {
    allowed_.Release_Store(reinterpret_cast<void*>(v));
  }",84.0,86.0,3.0,3.0,3.0,2,2,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
2464,88565,Limiter,1,leveldb.anonymous_namespace_14.Limiter.Limiter,ANY leveldb.anonymous_namespace_14.Limiter.Limiter (Limiter),util\env_posix.cc,Limiter(const Limiter&);,88.0,88.0,3.0,25.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
2465,88570,operator =,1,leveldb.anonymous_namespace_15.Limiter.operator =,void leveldb.anonymous_namespace_15.Limiter.operator = (Limiter),util\env_posix.cc,void operator=(const Limiter&);,89.0,89.0,8.0,32.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
2466,88578,PosixSequentialFile,1,leveldb.anonymous_namespace_17.PosixSequentialFile.PosixSequentialFile,"ANY leveldb.anonymous_namespace_17.PosixSequentialFile.PosixSequentialFile (ANY,FILE*)",util\env_posix.cc,"PosixSequentialFile(const std::string& fname, FILE* f)
      : filename_(fname), file_(f) { }",98.0,99.0,3.0,38.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,ANY
2467,88584,~PosixSequentialFile,1,leveldb.anonymous_namespace_18.PosixSequentialFile.~PosixSequentialFile,ANY leveldb.anonymous_namespace_18.PosixSequentialFile.~PosixSequentialFile (),util\env_posix.cc,virtual ~PosixSequentialFile() { fclose(file_); },100.0,100.0,3.0,51.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,ANY
2468,88590,Read,1,leveldb.anonymous_namespace_19.PosixSequentialFile.Read,"Status leveldb.anonymous_namespace_19.PosixSequentialFile.Read (size_t,Slice*,char*)",util\env_posix.cc,"virtual Status Read(size_t n, Slice* result, char* scratch) {
    Status s;
    size_t r = fread_unlocked(scratch, 1, n, file_);
    *result = Slice(scratch, r);
    if (r < n) {
      if (feof(file_)) {
        // We leave status as ok if we hit the end of the file
      } else {
        // A partial read with an error: return a non-ok status
        s = IOError(filename_, errno);
      }
    }
    return s;
  }",102.0,115.0,3.0,3.0,14.0,4,3,11,6,0,2,3,4,1,0,,0,2,6,3,3,Status
2469,88630,Skip,1,leveldb.anonymous_namespace_20.PosixSequentialFile.Skip,Status leveldb.anonymous_namespace_20.PosixSequentialFile.Skip (uint64_t),util\env_posix.cc,"virtual Status Skip(uint64_t n) {
    if (fseek(file_, n, SEEK_CUR)) {
      return IOError(filename_, errno);
    }
    return Status::OK();
  }",117.0,122.0,3.0,3.0,6.0,1,1,6,6,0,3,2,2,1,0,,0,2,2,1,1,Status
2470,88655,PosixRandomAccessFile,1,leveldb.anonymous_namespace_22.PosixRandomAccessFile.PosixRandomAccessFile,"ANY leveldb.anonymous_namespace_22.PosixRandomAccessFile.PosixRandomAccessFile (ANY,int,Limiter*)",util\env_posix.cc,"PosixRandomAccessFile(const std::string& fname, int fd, Limiter* limiter)
      : filename_(fname), fd_(fd), limiter_(limiter) {
    temporary_fd_ = !limiter->Acquire();
    if (temporary_fd_) {
      // Open file on every access.
      close(fd_);
      fd_ = -1;
    }
  }",134.0,142.0,3.0,3.0,9.0,5,4,5,3,0,4,2,2,1,0,,0,4,6,3,3,ANY
2471,88678,~PosixRandomAccessFile,1,leveldb.anonymous_namespace_23.PosixRandomAccessFile.~PosixRandomAccessFile,ANY leveldb.anonymous_namespace_23.PosixRandomAccessFile.~PosixRandomAccessFile (),util\env_posix.cc,"virtual ~PosixRandomAccessFile() {
    if (!temporary_fd_) {
      close(fd_);
      limiter_->Release();
    }
  }",144.0,149.0,3.0,3.0,6.0,2,2,3,3,0,3,2,2,1,0,,0,3,0,0,0,ANY
2472,88692,Read,1,leveldb.anonymous_namespace_24.PosixRandomAccessFile.Read,"Status leveldb.anonymous_namespace_24.PosixRandomAccessFile.Read (uint64_t,size_t,Slice*,char*)",util\env_posix.cc,"virtual Status Read(uint64_t offset, size_t n, Slice* result,
                      char* scratch) const {
    int fd = fd_;
    if (temporary_fd_) {
      fd = open(filename_.c_str(), O_RDONLY);
      if (fd < 0) {
        return IOError(filename_, errno);
      }
    }

    Status s;
    ssize_t r = pread(fd, scratch, n, static_cast<off_t>(offset));
    *result = Slice(scratch, (r < 0) ? 0 : r);
    if (r < 0) {
      // An error: return a non-ok status
      s = IOError(filename_, errno);
    }
    if (temporary_fd_) {
      // Close the temporary file descriptor opened earlier.
      close(fd);
    }
    return s;
  }",151.0,173.0,3.0,3.0,23.0,12,6,25,12,0,6,5,6,2,0,,0,6,8,4,4,Status
2473,88768,PosixMmapReadableFile,1,leveldb.anonymous_namespace_26.PosixMmapReadableFile.PosixMmapReadableFile,"ANY leveldb.anonymous_namespace_26.PosixMmapReadableFile.PosixMmapReadableFile (ANY,void*,size_t,Limiter*)",util\env_posix.cc,"PosixMmapReadableFile(const std::string& fname, void* base, size_t length,
                        Limiter* limiter)
      : filename_(fname), mmapped_region_(base), length_(length),
        limiter_(limiter) {
  }",186.0,190.0,3.0,3.0,5.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,ANY
2474,88776,~PosixMmapReadableFile,1,leveldb.anonymous_namespace_27.PosixMmapReadableFile.~PosixMmapReadableFile,ANY leveldb.anonymous_namespace_27.PosixMmapReadableFile.~PosixMmapReadableFile (),util\env_posix.cc,"virtual ~PosixMmapReadableFile() {
    munmap(mmapped_region_, length_);
    limiter_->Release();
  }",192.0,195.0,3.0,3.0,4.0,1,1,3,3,0,3,1,1,0,0,,0,3,0,0,0,ANY
2475,88787,Read,1,leveldb.anonymous_namespace_28.PosixMmapReadableFile.Read,"Status leveldb.anonymous_namespace_28.PosixMmapReadableFile.Read (uint64_t,size_t,Slice*,char*)",util\env_posix.cc,"virtual Status Read(uint64_t offset, size_t n, Slice* result,
                      char* scratch) const {
    Status s;
    if (offset + n > length_) {
      *result = Slice();
      s = IOError(filename_, EINVAL);
    } else {
      *result = Slice(reinterpret_cast<char*>(mmapped_region_) + offset, n);
    }
    return s;
  }",197.0,207.0,3.0,3.0,11.0,5,4,8,7,0,2,2,2,1,0,,0,2,8,4,4,Status
2476,88829,PosixWritableFile,1,leveldb.anonymous_namespace_30.PosixWritableFile.PosixWritableFile,"ANY leveldb.anonymous_namespace_30.PosixWritableFile.PosixWritableFile (ANY,FILE*)",util\env_posix.cc,"PosixWritableFile(const std::string& fname, FILE* f)
      : filename_(fname), file_(f) { }",216.0,217.0,3.0,38.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,ANY
2477,88835,~PosixWritableFile,1,leveldb.anonymous_namespace_31.PosixWritableFile.~PosixWritableFile,ANY leveldb.anonymous_namespace_31.PosixWritableFile.~PosixWritableFile (),util\env_posix.cc,"~PosixWritableFile() {
    if (file_ != NULL) {
      // Ignoring any potential errors
      fclose(file_);
    }
  }",219.0,224.0,3.0,3.0,6.0,1,1,3,2,0,2,2,2,1,0,,0,2,0,0,0,ANY
2478,88846,Append,1,leveldb.anonymous_namespace_32.PosixWritableFile.Append,Status leveldb.anonymous_namespace_32.PosixWritableFile.Append (Slice),util\env_posix.cc,"virtual Status Append(const Slice& data) {
    size_t r = fwrite_unlocked(data.data(), 1, data.size(), file_);
    if (r != data.size()) {
      return IOError(filename_, errno);
    }
    return Status::OK();
  }",226.0,232.0,3.0,3.0,7.0,6,3,9,6,0,3,2,2,0,0,,0,2,2,1,1,Status
2479,88882,Close,1,leveldb.anonymous_namespace_33.PosixWritableFile.Close,Status leveldb.anonymous_namespace_33.PosixWritableFile.Close (),util\env_posix.cc,"virtual Status Close() {
    Status result;
    if (fclose(file_) != 0) {
      result = IOError(filename_, errno);
    }
    file_ = NULL;
    return result;
  }",234.0,241.0,3.0,3.0,8.0,3,2,7,5,0,3,2,2,1,0,,0,3,0,0,0,Status
2480,88903,Flush,1,leveldb.anonymous_namespace_34.PosixWritableFile.Flush,Status leveldb.anonymous_namespace_34.PosixWritableFile.Flush (),util\env_posix.cc,"virtual Status Flush() {
    if (fflush_unlocked(file_) != 0) {
      return IOError(filename_, errno);
    }
    return Status::OK();
  }",243.0,248.0,3.0,3.0,6.0,2,2,4,4,0,3,2,2,1,0,,0,2,0,0,0,Status
2481,88922,SyncDirIfManifest,1,leveldb.anonymous_namespace_35.PosixWritableFile.SyncDirIfManifest,Status leveldb.anonymous_namespace_35.PosixWritableFile.SyncDirIfManifest (),util\env_posix.cc,"Status SyncDirIfManifest() {
    const char* f = filename_.c_str();
    const char* sep = strrchr(f, '/');
    Slice basename;
    std::string dir;
    if (sep == NULL) {
      dir = ""."";
      basename = f;
    } else {
      dir = std::string(f, sep - f);
      basename = sep + 1;
    }
    Status s;
    if (basename.starts_with(""MANIFEST"")) {
      int fd = open(dir.c_str(), O_RDONLY);
      if (fd < 0) {
        s = IOError(dir, errno);
      } else {
        if (fsync(fd) < 0) {
          s = IOError(dir, errno);
        }
        close(fd);
      }
    }
    return s;
  }",250.0,275.0,3.0,3.0,26.0,11,4,18,10,0,1,4,5,0,0,,0,1,0,0,0,Status
2482,89013,Sync,1,leveldb.anonymous_namespace_36.PosixWritableFile.Sync,Status leveldb.anonymous_namespace_36.PosixWritableFile.Sync (),util\env_posix.cc,"virtual Status Sync() {
    // Ensure new files referred to by the manifest are in the filesystem.
    Status s = SyncDirIfManifest();
    if (!s.ok()) {
      return s;
    }
    if (fflush_unlocked(file_) != 0 ||
        fdatasync(fileno(file_)) != 0) {
      s = Status::IOError(filename_, strerror(errno));
    }
    return s;
  }",277.0,288.0,3.0,3.0,12.0,8,5,10,5,0,3,3,3,2,0,,0,3,0,0,0,Status
2483,89053,LockOrUnlock,1,leveldb.anonymous_namespace_38.LockOrUnlock,"int leveldb.anonymous_namespace_38.LockOrUnlock (int,bool)",util\env_posix.cc,"static int LockOrUnlock(int fd, bool lock) {
  errno = 0;
  struct flock f;
  memset(&f, 0, sizeof(f));
  f.l_type = (lock ? F_WRLCK : F_UNLCK);
  f.l_whence = SEEK_SET;
  f.l_start = 0;
  f.l_len = 0;        // Lock/unlock entire file
  return fcntl(fd, F_SETLK, &f);
}",291.0,300.0,1.0,1.0,10.0,13,5,14,8,0,0,1,1,0,0,,0,0,4,2,2,int
2484,89104,Insert,1,leveldb.anonymous_namespace_41.PosixLockTable.Insert,bool leveldb.anonymous_namespace_41.PosixLockTable.Insert (ANY),util\env_posix.cc,"bool Insert(const std::string& fname) {
    MutexLock l(&mu_);
    return locked_files_.insert(fname).second;
  }",316.0,319.0,3.0,3.0,4.0,3,2,3,3,0,2,1,1,0,0,,0,2,2,1,1,bool
2485,89121,Remove,1,leveldb.anonymous_namespace_42.PosixLockTable.Remove,void leveldb.anonymous_namespace_42.PosixLockTable.Remove (ANY),util\env_posix.cc,"void Remove(const std::string& fname) {
    MutexLock l(&mu_);
    locked_files_.erase(fname);
  }",320.0,323.0,3.0,3.0,4.0,2,2,3,3,0,2,1,1,0,0,,0,2,2,1,1,void
2486,89136,PosixEnv,1,leveldb.anonymous_namespace_44.PosixEnv.PosixEnv,ANY leveldb.anonymous_namespace_44.PosixEnv.PosixEnv (),util\env_posix.cc,PosixEnv();,328.0,328.0,3.0,12.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
2487,89140,~PosixEnv,1,leveldb.anonymous_namespace_45.PosixEnv.~PosixEnv,ANY leveldb.anonymous_namespace_45.PosixEnv.~PosixEnv (),util\env_posix.cc,"virtual ~PosixEnv() {
    char msg[] = ""Destroying Env::Default()\n"";
    fwrite(msg, 1, sizeof(msg), stderr);
    abort();
  }",329.0,333.0,3.0,3.0,5.0,2,2,4,2,0,0,1,1,0,0,,0,0,0,0,0,ANY
2488,89155,NewSequentialFile,1,leveldb.anonymous_namespace_46.PosixEnv.NewSequentialFile,"Status leveldb.anonymous_namespace_46.PosixEnv.NewSequentialFile (ANY,SequentialFile**)",util\env_posix.cc,"virtual Status NewSequentialFile(const std::string& fname,
                                   SequentialFile** result) {
    FILE* f = fopen(fname.c_str(), ""r"");
    if (f == NULL) {
      *result = NULL;
      return IOError(fname, errno);
    } else {
      *result = new PosixSequentialFile(fname, f);
      return Status::OK();
    }
  }",335.0,345.0,3.0,3.0,11.0,5,4,8,5,0,0,2,2,0,0,,0,0,4,2,2,Status
2489,89197,NewRandomAccessFile,1,leveldb.anonymous_namespace_47.PosixEnv.NewRandomAccessFile,"Status leveldb.anonymous_namespace_47.PosixEnv.NewRandomAccessFile (ANY,RandomAccessFile**)",util\env_posix.cc,"virtual Status NewRandomAccessFile(const std::string& fname,
                                     RandomAccessFile** result) {
    *result = NULL;
    Status s;
    int fd = open(fname.c_str(), O_RDONLY);
    if (fd < 0) {
      s = IOError(fname, errno);
    } else if (mmap_limit_.Acquire()) {
      uint64_t size;
      s = GetFileSize(fname, &size);
      if (s.ok()) {
        void* base = mmap(NULL, size, PROT_READ, MAP_SHARED, fd, 0);
        if (base != MAP_FAILED) {
          *result = new PosixMmapReadableFile(fname, base, size, &mmap_limit_);
        } else {
          s = IOError(fname, errno);
        }
      }
      close(fd);
      if (!s.ok()) {
        mmap_limit_.Release();
      }
    } else {
      *result = new PosixRandomAccessFile(fname, fd, &fd_limit_);
    }
    return s;
  }",347.0,373.0,3.0,3.0,27.0,6,4,10,7,0,0,2,2,0,0,,0,0,4,2,2,Status
2490,89306,NewWritableFile,1,leveldb.anonymous_namespace_49.PosixEnv.NewWritableFile,"Status leveldb.anonymous_namespace_49.PosixEnv.NewWritableFile (ANY,WritableFile**)",util\env_posix.cc,"virtual Status NewWritableFile(const std::string& fname,
                                 WritableFile** result) {
    Status s;
    FILE* f = fopen(fname.c_str(), ""w"");
    if (f == NULL) {
      *result = NULL;
      s = IOError(fname, errno);
    } else {
      *result = new PosixWritableFile(fname, f);
    }
    return s;
  }",375.0,386.0,3.0,3.0,12.0,6,4,10,6,0,0,2,2,0,0,,0,0,4,2,2,Status
2491,89347,NewAppendableFile,1,leveldb.anonymous_namespace_50.PosixEnv.NewAppendableFile,"Status leveldb.anonymous_namespace_50.PosixEnv.NewAppendableFile (ANY,WritableFile**)",util\env_posix.cc,"virtual Status NewAppendableFile(const std::string& fname,
                                   WritableFile** result) {
    Status s;
    FILE* f = fopen(fname.c_str(), ""a"");
    if (f == NULL) {
      *result = NULL;
      s = IOError(fname, errno);
    } else {
      *result = new PosixWritableFile(fname, f);
    }
    return s;
  }",388.0,399.0,3.0,3.0,12.0,6,4,10,6,0,0,2,2,0,0,,0,0,4,2,2,Status
2492,89388,FileExists,1,leveldb.anonymous_namespace_51.PosixEnv.FileExists,bool leveldb.anonymous_namespace_51.PosixEnv.FileExists (ANY),util\env_posix.cc,"virtual bool FileExists(const std::string& fname) {
    return access(fname.c_str(), F_OK) == 0;
  }",401.0,403.0,3.0,3.0,3.0,2,2,2,2,0,0,1,1,0,0,,0,0,2,1,1,bool
2493,89402,GetChildren,1,leveldb.anonymous_namespace_52.PosixEnv.GetChildren,"Status leveldb.anonymous_namespace_52.PosixEnv.GetChildren (ANY,ANY*)",util\env_posix.cc,"virtual Status GetChildren(const std::string& dir,
                             std::vector<std::string>* result) {
    result->clear();
    DIR* d = opendir(dir.c_str());
    if (d == NULL) {
      return IOError(dir, errno);
    }
    struct dirent* entry;
    while ((entry = readdir(d)) != NULL) {
      result->push_back(entry->d_name);
    }
    closedir(d);
    return Status::OK();
  }",405.0,418.0,3.0,3.0,14.0,9,5,14,7,0,1,3,3,0,0,,0,0,4,2,2,Status
2494,89452,DeleteFile,1,leveldb.anonymous_namespace_53.PosixEnv.DeleteFile,Status leveldb.anonymous_namespace_53.PosixEnv.DeleteFile (ANY),util\env_posix.cc,"virtual Status DeleteFile(const std::string& fname) {
    Status result;
    if (unlink(fname.c_str()) != 0) {
      result = IOError(fname, errno);
    }
    return result;
  }",420.0,426.0,3.0,3.0,7.0,3,3,5,3,0,0,2,2,0,0,,0,0,2,1,1,Status
2495,89474,CreateDir,1,leveldb.anonymous_namespace_54.PosixEnv.CreateDir,Status leveldb.anonymous_namespace_54.PosixEnv.CreateDir (ANY),util\env_posix.cc,"virtual Status CreateDir(const std::string& name) {
    Status result;
    if (mkdir(name.c_str(), 0755) != 0) {
      result = IOError(name, errno);
    }
    return result;
  }",428.0,434.0,3.0,3.0,7.0,3,3,5,3,0,0,2,2,0,0,,0,0,2,1,1,Status
2496,89497,DeleteDir,1,leveldb.anonymous_namespace_55.PosixEnv.DeleteDir,Status leveldb.anonymous_namespace_55.PosixEnv.DeleteDir (ANY),util\env_posix.cc,"virtual Status DeleteDir(const std::string& name) {
    Status result;
    if (rmdir(name.c_str()) != 0) {
      result = IOError(name, errno);
    }
    return result;
  }",436.0,442.0,3.0,3.0,7.0,3,3,5,3,0,0,2,2,0,0,,0,0,2,1,1,Status
2497,89519,GetFileSize,1,leveldb.anonymous_namespace_56.PosixEnv.GetFileSize,"Status leveldb.anonymous_namespace_56.PosixEnv.GetFileSize (ANY,uint64_t*)",util\env_posix.cc,"virtual Status GetFileSize(const std::string& fname, uint64_t* size) {
    Status s;
    struct stat sbuf;
    if (stat(fname.c_str(), &sbuf) != 0) {
      *size = 0;
      s = IOError(fname, errno);
    } else {
      *size = sbuf.st_size;
    }
    return s;
  }",444.0,454.0,3.0,3.0,11.0,6,5,7,5,0,0,2,2,0,0,,0,0,4,2,2,Status
2498,89557,RenameFile,1,leveldb.anonymous_namespace_57.PosixEnv.RenameFile,"Status leveldb.anonymous_namespace_57.PosixEnv.RenameFile (ANY,ANY)",util\env_posix.cc,"virtual Status RenameFile(const std::string& src, const std::string& target) {
    Status result;
    if (rename(src.c_str(), target.c_str()) != 0) {
      result = IOError(src, errno);
    }
    return result;
  }",456.0,462.0,3.0,3.0,7.0,4,3,6,4,0,0,2,2,0,0,,0,0,4,2,2,Status
2499,89584,LockFile,1,leveldb.anonymous_namespace_58.PosixEnv.LockFile,"Status leveldb.anonymous_namespace_58.PosixEnv.LockFile (ANY,FileLock**)",util\env_posix.cc,"virtual Status LockFile(const std::string& fname, FileLock** lock) {
    *lock = NULL;
    Status result;
    int fd = open(fname.c_str(), O_RDWR | O_CREAT, 0644);
    if (fd < 0) {
      result = IOError(fname, errno);
    } else if (!locks_.Insert(fname)) {
      close(fd);
      result = Status::IOError(""lock "" + fname, ""already held by process"");
    } else if (LockOrUnlock(fd, true) == -1) {
      result = IOError(""lock "" + fname, errno);
      close(fd);
      locks_.Remove(fname);
    } else {
      PosixFileLock* my_lock = new PosixFileLock;
      my_lock->fd_ = fd;
      my_lock->name_ = fname;
      *lock = my_lock;
    }
    return result;
  }",464.0,484.0,3.0,3.0,21.0,7,5,11,8,0,0,2,2,0,0,,0,0,4,2,2,Status
2500,89686,UnlockFile,1,leveldb.anonymous_namespace_60.PosixEnv.UnlockFile,Status leveldb.anonymous_namespace_60.PosixEnv.UnlockFile (FileLock*),util\env_posix.cc,"virtual Status UnlockFile(FileLock* lock) {
    PosixFileLock* my_lock = reinterpret_cast<PosixFileLock*>(lock);
    Status result;
    if (LockOrUnlock(my_lock->fd_, false) == -1) {
      result = IOError(""unlock"", errno);
    }
    locks_.Remove(my_lock->name_);
    close(my_lock->fd_);
    delete my_lock;
    return result;
  }",486.0,496.0,3.0,3.0,11.0,10,7,10,5,0,4,2,2,1,0,,0,4,2,1,1,Status
2501,89728,Schedule,1,leveldb.anonymous_namespace_62.PosixEnv.Schedule,"void leveldb.anonymous_namespace_62.PosixEnv.Schedule (void,void*)",util\env_posix.cc,"virtual void Schedule(void (*function)(void*), void* arg);",498.0,498.0,16.0,59.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
2502,89734,StartThread,1,leveldb.anonymous_namespace_63.PosixEnv.StartThread,"void leveldb.anonymous_namespace_63.PosixEnv.StartThread (void,void*)",util\env_posix.cc,"virtual void StartThread(void (*function)(void* arg), void* arg);",500.0,500.0,16.0,66.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
2503,89740,GetTestDirectory,1,leveldb.anonymous_namespace_64.PosixEnv.GetTestDirectory,Status leveldb.anonymous_namespace_64.PosixEnv.GetTestDirectory (ANY*),util\env_posix.cc,"virtual Status GetTestDirectory(std::string* result) {
    const char* env = getenv(""TEST_TMPDIR"");
    if (env && env[0] != '\0') {
      *result = env;
    } else {
      char buf[100];
      snprintf(buf, sizeof(buf), ""/tmp/leveldbtest-%d"", int(geteuid()));
      *result = buf;
    }
    // Directory may already exist
    CreateDir(*result);
    return Status::OK();
  }",502.0,514.0,3.0,3.0,13.0,8,6,7,3,0,1,2,2,0,0,,0,0,2,1,1,Status
2504,89786,gettid,1,leveldb.anonymous_namespace_66.PosixEnv.gettid,uint64_t leveldb.anonymous_namespace_66.PosixEnv.gettid (),util\env_posix.cc,"static uint64_t gettid() {
    pthread_t tid = pthread_self();
    uint64_t thread_id = 0;
    memcpy(&thread_id, &tid, std::min(sizeof(thread_id), sizeof(tid)));
    return thread_id;
  }",516.0,521.0,3.0,3.0,6.0,7,4,8,3,0,0,1,1,0,0,,0,0,0,0,0,uint64_t
2505,89813,NewLogger,1,leveldb.anonymous_namespace_67.PosixEnv.NewLogger,"Status leveldb.anonymous_namespace_67.PosixEnv.NewLogger (ANY,Logger**)",util\env_posix.cc,"virtual Status NewLogger(const std::string& fname, Logger** result) {
    FILE* f = fopen(fname.c_str(), ""w"");
    if (f == NULL) {
      *result = NULL;
      return IOError(fname, errno);
    } else {
      *result = new PosixLogger(f, &PosixEnv::gettid);
      return Status::OK();
    }
  }",523.0,532.0,3.0,3.0,10.0,5,4,8,5,0,0,2,2,0,0,,0,0,4,2,2,Status
2506,89858,NowMicros,1,leveldb.anonymous_namespace_68.PosixEnv.NowMicros,uint64_t leveldb.anonymous_namespace_68.PosixEnv.NowMicros (),util\env_posix.cc,"virtual uint64_t NowMicros() {
    struct timeval tv;
    gettimeofday(&tv, NULL);
    return static_cast<uint64_t>(tv.tv_sec) * 1000000 + tv.tv_usec;
  }",534.0,538.0,3.0,3.0,5.0,6,5,4,2,0,0,1,1,0,0,,0,0,0,0,0,uint64_t
2507,89879,SleepForMicroseconds,1,leveldb.anonymous_namespace_69.PosixEnv.SleepForMicroseconds,void leveldb.anonymous_namespace_69.PosixEnv.SleepForMicroseconds (int),util\env_posix.cc,"virtual void SleepForMicroseconds(int micros) {
    usleep(micros);
  }",540.0,542.0,3.0,3.0,3.0,0,0,1,1,0,0,1,1,0,0,,0,0,2,1,1,void
2508,89886,PthreadCall,1,leveldb.anonymous_namespace_70.PosixEnv.PthreadCall,"void leveldb.anonymous_namespace_70.PosixEnv.PthreadCall (char*,int)",util\env_posix.cc,"void PthreadCall(const char* label, int result) {
    if (result != 0) {
      fprintf(stderr, ""pthread %s: %s\n"", label, strerror(result));
      abort();
    }
  }",545.0,550.0,3.0,3.0,6.0,1,1,4,3,0,0,2,2,0,0,,0,0,4,2,2,void
2509,89904,BGThread,1,leveldb.anonymous_namespace_71.PosixEnv.BGThread,void leveldb.anonymous_namespace_71.PosixEnv.BGThread (),util\env_posix.cc,void BGThread();,553.0,553.0,8.0,17.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2510,89908,BGThreadWrapper,1,leveldb.anonymous_namespace_72.PosixEnv.BGThreadWrapper,void* leveldb.anonymous_namespace_72.PosixEnv.BGThreadWrapper (void*),util\env_posix.cc,"static void* BGThreadWrapper(void* arg) {
    reinterpret_cast<PosixEnv*>(arg)->BGThread();
    return NULL;
  }",554.0,557.0,3.0,3.0,4.0,2,2,2,2,0,0,1,1,0,0,,0,0,2,1,1,void*
2511,89927,function,1,leveldb.anonymous_namespace_74.PosixEnv.BGItem.function,void leveldb.anonymous_namespace_74.PosixEnv.BGItem.function (void*),util\env_posix.cc,void (*function)(void*);,565.0,565.0,35.0,52.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
2512,89937,MaxMmaps,1,leveldb.anonymous_namespace_75.MaxMmaps,int leveldb.anonymous_namespace_75.MaxMmaps (),util\env_posix.cc,"static int MaxMmaps() {
  if (mmap_limit >= 0) {
    return mmap_limit;
  }
  // Up to 1000 mmaps for 64-bit binaries; none for smaller pointer sizes.
  mmap_limit = sizeof(void*) >= 8 ? 1000 : 0;
  return mmap_limit;
}",575.0,582.0,1.0,1.0,8.0,5,4,5,2,0,0,2,2,0,0,,0,0,0,0,0,int
2513,89959,MaxOpenFiles,1,leveldb.anonymous_namespace_76.MaxOpenFiles,intptr_t leveldb.anonymous_namespace_76.MaxOpenFiles (),util\env_posix.cc,"static intptr_t MaxOpenFiles() {
  if (open_read_only_file_limit >= 0) {
    return open_read_only_file_limit;
  }
  struct rlimit rlim;
  if (getrlimit(RLIMIT_NOFILE, &rlim)) {
    // getrlimit failed, fallback to hard-coded default.
    open_read_only_file_limit = 50;
  } else if (rlim.rlim_cur == RLIM_INFINITY) {
    open_read_only_file_limit = std::numeric_limits<int>::max();
  } else {
    // Allow use of 20% of available file descriptors for read-only files.
    open_read_only_file_limit = rlim.rlim_cur / 5;
  }
  return open_read_only_file_limit;
}",585.0,600.0,1.0,1.0,16.0,3,3,6,3,0,0,3,3,0,0,,0,0,0,0,0,intptr_t
2514,90008,PosixEnv,1,leveldb.anonymous_namespace_77.PosixEnv.PosixEnv,ANY leveldb.anonymous_namespace_77.PosixEnv.PosixEnv (),util\env_posix.cc,"PosixEnv::PosixEnv()
    : started_bgthread_(false),
      mmap_limit_(MaxMmaps()),
      fd_limit_(MaxOpenFiles()) {
  PthreadCall(""mutex_init"", pthread_mutex_init(&mu_, NULL));
  PthreadCall(""cvar_init"", pthread_cond_init(&bgsignal_, NULL));
}",602.0,608.0,1.0,1.0,7.0,2,1,4,3,0,0,1,1,0,0,,0,0,0,0,0,ANY
2515,90024,Schedule,1,leveldb.anonymous_namespace_78.PosixEnv.Schedule,"void leveldb.anonymous_namespace_78.PosixEnv.Schedule (void,void*)",util\env_posix.cc,"void PosixEnv::Schedule(void (*function)(void*), void* arg) {
  PthreadCall(""lock"", pthread_mutex_lock(&mu_));

  // Start background thread if necessary
  if (!started_bgthread_) {
    started_bgthread_ = true;
    PthreadCall(
        ""create thread"",
        pthread_create(&bgthread_, NULL,  &PosixEnv::BGThreadWrapper, this));
  }

  // If the queue is currently empty, the background thread may currently be
  // waiting.
  if (queue_.empty()) {
    PthreadCall(""signal"", pthread_cond_signal(&bgsignal_));
  }

  // Add to priority queue
  queue_.push_back(BGItem());
  queue_.back().function = function;
  queue_.back().arg = arg;

  PthreadCall(""unlock"", pthread_mutex_unlock(&mu_));
}",610.0,633.0,1.0,1.0,24.0,16,4,14,9,0,0,3,3,0,0,,0,0,4,2,2,void
2516,90090,BGThread,1,leveldb.anonymous_namespace_79.PosixEnv.BGThread,void leveldb.anonymous_namespace_79.PosixEnv.BGThread (),util\env_posix.cc,"void PosixEnv::BGThread() {
  while (true) {
    // Wait until there is an item that is ready to run
    PthreadCall(""lock"", pthread_mutex_lock(&mu_));
    while (queue_.empty()) {
      PthreadCall(""wait"", pthread_cond_wait(&bgsignal_, &mu_));
    }

    void (*function)(void*) = queue_.front().function;
    void* arg = queue_.front().arg;
    queue_.pop_front();

    PthreadCall(""unlock"", pthread_mutex_unlock(&mu_));
    (*function)(arg);
  }
}",635.0,650.0,1.0,1.0,16.0,10,4,10,5,0,0,3,4,0,0,,0,0,0,0,0,void
2517,90113,function,1,leveldb.anonymous_namespace_80.PosixEnv.BGThread.function,void leveldb.anonymous_namespace_80.PosixEnv.BGThread.function (void*),util\env_posix.cc,void (*function)(void*) = queue_.front().function;,643.0,643.0,10.0,53.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
2518,90144,user_function,1,leveldb.anonymous_namespace_85.anonymous_namespace_86.StartThreadState.user_function,void leveldb.anonymous_namespace_85.anonymous_namespace_86.StartThreadState.user_function (void*),util\env_posix.cc,void (*user_function)(void*);,654.0,654.0,8.0,30.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
2519,90150,StartThreadWrapper,1,leveldb.anonymous_namespace_87.StartThreadWrapper,void* leveldb.anonymous_namespace_87.StartThreadWrapper (void*),util\env_posix.cc,"static void* StartThreadWrapper(void* arg) {
  StartThreadState* state = reinterpret_cast<StartThreadState*>(arg);
  state->user_function(state->arg);
  delete state;
  return NULL;
}",658.0,663.0,1.0,1.0,6.0,5,4,6,3,0,1,1,1,0,0,,0,1,2,1,1,void*
2520,90172,StartThread,1,leveldb.anonymous_namespace_88.PosixEnv.StartThread,"void leveldb.anonymous_namespace_88.PosixEnv.StartThread (void,void*)",util\env_posix.cc,"void PosixEnv::StartThread(void (*function)(void* arg), void* arg) {
  pthread_t t;
  StartThreadState* state = new StartThreadState;
  state->user_function = function;
  state->arg = arg;
  PthreadCall(""start thread"",
              pthread_create(&t, NULL,  &StartThreadWrapper, state));
}",665.0,672.0,1.0,1.0,8.0,8,4,9,6,0,1,1,1,0,0,,0,1,4,2,2,void
2521,90208,InitDefaultEnv,1,leveldb.InitDefaultEnv,void leveldb.InitDefaultEnv (),util\env_posix.cc,static void InitDefaultEnv() { default_env = new PosixEnv; },678.0,678.0,1.0,60.0,1.0,2,2,2,2,0,0,1,1,0,0,,0,0,0,0,0,void
2522,90216,SetReadOnlyFDLimit,1,leveldb.EnvPosixTestHelper.SetReadOnlyFDLimit,void leveldb.EnvPosixTestHelper.SetReadOnlyFDLimit (int),util\env_posix.cc,"void EnvPosixTestHelper::SetReadOnlyFDLimit(int limit) {
  assert(default_env == NULL);
  open_read_only_file_limit = limit;
}",680.0,683.0,1.0,1.0,4.0,2,2,4,4,0,0,1,1,0,0,,0,0,2,1,1,void
2523,90228,SetReadOnlyMMapLimit,1,leveldb.EnvPosixTestHelper.SetReadOnlyMMapLimit,void leveldb.EnvPosixTestHelper.SetReadOnlyMMapLimit (int),util\env_posix.cc,"void EnvPosixTestHelper::SetReadOnlyMMapLimit(int limit) {
  assert(default_env == NULL);
  mmap_limit = limit;
}",685.0,688.0,1.0,1.0,4.0,2,2,4,4,0,0,1,1,0,0,,0,0,2,1,1,void
2524,90278,EnvPosixTest,1,leveldb.EnvPosixTest.EnvPosixTest,ANY leveldb.EnvPosixTest.EnvPosixTest (),util\env_posix_test.cc,EnvPosixTest() : env_(Env::Default()) { },20.0,20.0,3.0,43.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
2525,90282,SetFileLimits,1,leveldb.EnvPosixTest.SetFileLimits,"void leveldb.EnvPosixTest.SetFileLimits (int,int)",util\env_posix_test.cc,"static void SetFileLimits(int read_only_file_limit, int mmap_limit) {
    EnvPosixTestHelper::SetReadOnlyFDLimit(read_only_file_limit);
    EnvPosixTestHelper::SetReadOnlyMMapLimit(mmap_limit);
  }",22.0,25.0,3.0,3.0,4.0,2,1,4,3,0,0,1,1,0,0,,0,0,4,2,2,void
2526,90299,_Run,1,leveldb._Test_TestOpenOnRead._Run,void leveldb._Test_TestOpenOnRead._Run (),util\env_posix_test.cc,"TEST(EnvPosixTest, TestOpenOnRead) {
  // Write some test data to a single file that will be opened |n| times.
  std::string test_dir;
  ASSERT_OK(env_->GetTestDirectory(&test_dir));
  std::string test_file = test_dir + ""/open_on_read.txt"";

  FILE* f = fopen(test_file.c_str(), ""w"");
  ASSERT_TRUE(f != NULL);
  const char kFileData[] = ""abcdefghijklmnopqrstuvwxyz"";
  fputs(kFileData, f);
  fclose(f);

  // Open test file some number above the sum of the two limits to force
  // open-on-read behavior of POSIX Env leveldb::RandomAccessFile.
  const int kNumFiles = kReadOnlyFileLimit + kMMapLimit + 5;
  leveldb::RandomAccessFile* files[kNumFiles] = {0};
  for (int i = 0; i < kNumFiles; i++) {
    ASSERT_OK(env_->NewRandomAccessFile(test_file, &files[i]));
  }
  char scratch;
  Slice read_result;
  for (int i = 0; i < kNumFiles; i++) {
    ASSERT_OK(files[i]->Read(i, 1, &read_result, &scratch));
    ASSERT_EQ(kFileData[i], read_result[0]);
  }
  for (int i = 0; i < kNumFiles; i++) {
   ...",28.0,57.0,1.0,34.0,30.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2527,90303,_RunIt,1,leveldb._Test_TestOpenOnRead._RunIt,void leveldb._Test_TestOpenOnRead._RunIt (),util\env_posix_test.cc,"TEST(EnvPosixTest, TestOpenOnRead)",28.0,28.0,1.0,34.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
2528,90620,EnvTest,1,leveldb.EnvTest.EnvTest,ANY leveldb.EnvTest.EnvTest (),util\env_test.cc,EnvTest() : env_(Env::Default()) { },23.0,23.0,3.0,38.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
2529,90624,SetBool,1,leveldb.SetBool,void leveldb.SetBool (void*),util\env_test.cc,"static void SetBool(void* ptr) {
  reinterpret_cast<port::AtomicPointer*>(ptr)->NoBarrier_Store(ptr);
}",26.0,28.0,1.0,1.0,3.0,2,2,2,1,0,0,1,1,0,0,,0,0,2,1,1,void
2530,90637,_Run,1,leveldb._Test_RunImmediately._Run,void leveldb._Test_RunImmediately._Run (),util\env_test.cc,"TEST(EnvTest, RunImmediately) {
  port::AtomicPointer called (NULL);
  env_->Schedule(&SetBool, &called);
  env_->SleepForMicroseconds(kDelayMicros);
  ASSERT_TRUE(called.NoBarrier_Load() != NULL);
}",30.0,35.0,1.0,29.0,6.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2531,90641,_RunIt,1,leveldb._Test_RunImmediately._RunIt,void leveldb._Test_RunImmediately._RunIt (),util\env_test.cc,"TEST(EnvTest, RunImmediately)",30.0,30.0,1.0,29.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
2532,90706,_Run,1,leveldb._Test_RunMany._Run,void leveldb._Test_RunMany._Run (),util\env_test.cc,"TEST(EnvTest, RunMany) {
  port::AtomicPointer last_id (NULL);

  struct CB {
    port::AtomicPointer* last_id_ptr;   // Pointer to shared slot
    uintptr_t id;             // Order# for the execution of this callback

    CB(port::AtomicPointer* p, int i) : last_id_ptr(p), id(i) { }

    static void Run(void* v) {
      CB* cb = reinterpret_cast<CB*>(v);
      void* cur = cb->last_id_ptr->NoBarrier_Load();
      ASSERT_EQ(cb->id-1, reinterpret_cast<uintptr_t>(cur));
      cb->last_id_ptr->Release_Store(reinterpret_cast<void*>(cb->id));
    }
  };

  // Schedule in different order than start time
  CB cb1(&last_id, 1);
  CB cb2(&last_id, 2);
  CB cb3(&last_id, 3);
  CB cb4(&last_id, 4);
  env_->Schedule(&CB::Run, &cb1);
  env_->Schedule(&CB::Run, &cb2);
  env_->Schedule(&CB::Run, &cb3);
  env_->Schedule(&CB::Run, &cb4);

  env_->SleepForMicroseconds(kDelayMicros);
  void* cur = last_id.Acquire_Load();
  ASSERT_EQ(4, reinterpret_cast<uintptr_t>(cur));
}",37.0,67.0,1.0,22.0,31.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2533,90710,_RunIt,1,leveldb._Test_RunMany._RunIt,void leveldb._Test_RunMany._RunIt (),util\env_test.cc,"TEST(EnvTest, RunMany)",37.0,37.0,1.0,22.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
2534,90838,ThreadBody,1,leveldb.ThreadBody,void leveldb.ThreadBody (void*),util\env_test.cc,"static void ThreadBody(void* arg) {
  State* s = reinterpret_cast<State*>(arg);
  s->mu.Lock();
  s->val += 1;
  s->num_running -= 1;
  s->mu.Unlock();
}",75.0,81.0,1.0,1.0,7.0,10,6,6,2,0,4,1,1,0,0,,0,4,2,1,1,void
2535,90872,_Run,1,leveldb._Test_StartThread._Run,void leveldb._Test_StartThread._Run (),util\env_test.cc,"TEST(EnvTest, StartThread) {
  State state;
  state.val = 0;
  state.num_running = 3;
  for (int i = 0; i < 3; i++) {
    env_->StartThread(&ThreadBody, &state);
  }
  while (true) {
    state.mu.Lock();
    int num = state.num_running;
    state.mu.Unlock();
    if (num == 0) {
      break;
    }
    env_->SleepForMicroseconds(kDelayMicros);
  }
  ASSERT_EQ(state.val, 3);
}",83.0,100.0,1.0,26.0,18.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2536,90876,_RunIt,1,leveldb._Test_StartThread._RunIt,void leveldb._Test_StartThread._RunIt (),util\env_test.cc,"TEST(EnvTest, StartThread)",83.0,83.0,1.0,26.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
2537,91025,Hash,1,leveldb.Hash,"uint32_t leveldb.Hash (char*,size_t,uint32_t)",util\hash.cc,"uint32_t Hash(const char* data, size_t n, uint32_t seed) {
  // Similar to murmur hash
  const uint32_t m = 0xc6a4a793;
  const uint32_t r = 24;
  const char* limit = data + n;
  uint32_t h = seed ^ (n * m);

  // Pick up four bytes at a time
  while (data + 4 <= limit) {
    uint32_t w = DecodeFixed32(data);
    data += 4;
    h += w;
    h *= m;
    h ^= (h >> 16);
  }

  // Pick up remaining bytes
  switch (limit - data) {
    case 3:
      h += static_cast<unsigned char>(data[2]) << 16;
      FALLTHROUGH_INTENDED;
    case 2:
      h += static_cast<unsigned char>(data[1]) << 8;
      FALLTHROUGH_INTENDED;
    case 1:
      h += static_cast<unsigned char>(data[0]);
      h *= m;
      h ^= (h >> r);
      break;
  }
  return h;
}",18.0,49.0,1.0,6.0,32.0,28,12,34,8,0,0,4,3,0,0,,0,0,6,3,3,uint32_t
2538,91166,_Run,1,leveldb._Test_SignedUnsignedIssue._Run,void leveldb._Test_SignedUnsignedIssue._Run (),util\hash_test.cc,"TEST(HASH, SignedUnsignedIssue) {
  const unsigned char data1[1] = {0x62};
  const unsigned char data2[2] = {0xc3, 0x97};
  const unsigned char data3[3] = {0xe2, 0x99, 0xa5};
  const unsigned char data4[4] = {0xe1, 0x80, 0xb9, 0x32};
  const unsigned char data5[48] = {
    0x01, 0xc0, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x14, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x04, 0x00,
    0x00, 0x00, 0x00, 0x14,
    0x00, 0x00, 0x00, 0x18,
    0x28, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x02, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
  };

  ASSERT_EQ(Hash(0, 0, 0xbc9f1d34), 0xbc9f1d34);
  ASSERT_EQ(
      Hash(reinterpret_cast<const char*>(data1), sizeof(data1), 0xbc9f1d34),
      0xef1345c4);
  ASSERT_EQ(
      Hash(reinterpret_cast<const char*>(data2), sizeof(data2), 0xbc9f1d34),
      0x5b663814);
  ASSERT_EQ(
      Hash(reinterpret_cast<const char*>(data3), sizeof(data3), 0xbc9f1d34),
      0x323c078f);
  ASSERT_...",12.0,48.0,1.0,31.0,37.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2539,91170,_RunIt,1,leveldb._Test_SignedUnsignedIssue._RunIt,void leveldb._Test_SignedUnsignedIssue._RunIt (),util\hash_test.cc,"TEST(HASH, SignedUnsignedIssue)",12.0,12.0,1.0,31.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
2540,91590,Clear,1,leveldb.Histogram.Clear,void leveldb.Histogram.Clear (),util\histogram.cc,"void Histogram::Clear() {
  min_ = kBucketLimit[kNumBuckets-1];
  max_ = 0;
  num_ = 0;
  sum_ = 0;
  sum_squares_ = 0;
  for (int i = 0; i < kNumBuckets; i++) {
    buckets_[i] = 0;
  }
}",33.0,42.0,1.0,1.0,10.0,11,4,12,9,0,8,2,2,1,0,,0,8,0,0,0,void
2541,91630,Add,1,leveldb.Histogram.Add,void leveldb.Histogram.Add (double),util\histogram.cc,"void Histogram::Add(double value) {
  // Linear search is fast enough for our usage in db_bench
  int b = 0;
  while (b < kNumBuckets - 1 && kBucketLimit[b] <= value) {
    b++;
  }
  buckets_[b] += 1.0;
  if (min_ > value) min_ = value;
  if (max_ < value) max_ = value;
  num_++;
  sum_ += value;
  sum_squares_ += (value * value);
}",44.0,56.0,1.0,1.0,13.0,17,10,23,10,0,9,4,4,3,0,,0,9,2,1,1,void
2542,91685,Merge,1,leveldb.Histogram.Merge,void leveldb.Histogram.Merge (Histogram),util\histogram.cc,"void Histogram::Merge(const Histogram& other) {
  if (other.min_ < min_) min_ = other.min_;
  if (other.max_ > max_) max_ = other.max_;
  num_ += other.num_;
  sum_ += other.sum_;
  sum_squares_ += other.sum_squares_;
  for (int b = 0; b < kNumBuckets; b++) {
    buckets_[b] += other.buckets_[b];
  }
}",58.0,67.0,1.0,1.0,10.0,20,6,21,9,0,17,4,4,5,0,,0,17,2,1,1,void
2543,91750,Median,1,leveldb.Histogram.Median,double leveldb.Histogram.Median (),util\histogram.cc,"double Histogram::Median() const {
  return Percentile(50.0);
}",69.0,71.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,double
2544,91757,Percentile,1,leveldb.Histogram.Percentile,double leveldb.Histogram.Percentile (double),util\histogram.cc,"double Histogram::Percentile(double p) const {
  double threshold = num_ * (p / 100.0);
  double sum = 0;
  for (int b = 0; b < kNumBuckets; b++) {
    sum += buckets_[b];
    if (sum >= threshold) {
      // Scale linearly within this bucket
      double left_point = (b == 0) ? 0 : kBucketLimit[b-1];
      double right_point = kBucketLimit[b];
      double left_sum = sum - buckets_[b];
      double right_sum = sum;
      double pos = (threshold - left_sum) / (right_sum - left_sum);
      double r = left_point + (right_point - left_point) * pos;
      if (r < min_) r = min_;
      if (r > max_) r = max_;
      return r;
    }
  }
  return max_;
}",73.0,92.0,1.0,1.0,20.0,32,12,45,16,0,9,5,10,3,0,,0,9,2,1,1,double
2545,91867,Average,1,leveldb.Histogram.Average,double leveldb.Histogram.Average (),util\histogram.cc,"double Histogram::Average() const {
  if (num_ == 0.0) return 0;
  return sum_ / num_;
}",94.0,97.0,1.0,1.0,4.0,2,2,3,2,0,3,2,2,1,0,,0,3,0,0,0,double
2546,91882,StandardDeviation,1,leveldb.Histogram.StandardDeviation,double leveldb.Histogram.StandardDeviation (),util\histogram.cc,"double Histogram::StandardDeviation() const {
  if (num_ == 0.0) return 0;
  double variance = (sum_squares_ * num_ - sum_ * sum_) / (num_ * num_);
  return sqrt(variance);
}",99.0,103.0,1.0,1.0,5.0,7,5,9,4,0,7,2,2,1,0,,0,7,0,0,0,double
2547,91910,ToString,1,leveldb.Histogram.ToString,string leveldb.Histogram.ToString (),util\histogram.cc,"std::string Histogram::ToString() const {
  std::string r;
  char buf[200];
  snprintf(buf, sizeof(buf),
           ""Count: %.0f  Average: %.4f  StdDev: %.2f\n"",
           num_, Average(), StandardDeviation());
  r.append(buf);
  snprintf(buf, sizeof(buf),
           ""Min: %.4f  Median: %.4f  Max: %.4f\n"",
           (num_ == 0.0 ? 0.0 : min_), Median(), max_);
  r.append(buf);
  r.append(""------------------------------------------------------\n"");
  const double mult = 100.0 / num_;
  double sum = 0;
  for (int b = 0; b < kNumBuckets; b++) {
    if (buckets_[b] <= 0.0) continue;
    sum += buckets_[b];
    snprintf(buf, sizeof(buf),
             ""[ %7.0f, %7.0f ) %7.0f %7.3f%% %7.3f%% "",
             ((b == 0) ? 0.0 : kBucketLimit[b-1]),      // left
             kBucketLimit[b],                           // right
             buckets_[b],                               // count
             mult * buckets_[b],                        // percentage
             mult * sum);         ...",105.0,137.0,1.0,1.0,33.0,35,14,48,12,0,12,4,4,2,0,,0,12,0,0,0,string
2548,92057,Histogram,1,leveldb.Histogram.Histogram,ANY leveldb.Histogram.Histogram (),util\histogram.hpp,Histogram() { },14.0,14.0,3.0,17.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
2549,92061,~Histogram,1,leveldb.Histogram.~Histogram,ANY leveldb.Histogram.~Histogram (),util\histogram.hpp,~Histogram() { },15.0,15.0,3.0,18.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
2550,92144,AppendNumberTo,1,leveldb.AppendNumberTo,"void leveldb.AppendNumberTo (ANY*,uint64_t)",util\logging.cc,"void AppendNumberTo(std::string* str, uint64_t num) {
  char buf[30];
  snprintf(buf, sizeof(buf), ""%llu"", (unsigned long long) num);
  str->append(buf);
}",16.0,20.0,1.0,1.0,5.0,3,3,5,3,0,0,1,1,0,0,,0,0,4,2,2,void
2551,92164,AppendEscapedStringTo,1,leveldb.AppendEscapedStringTo,"void leveldb.AppendEscapedStringTo (ANY*,Slice)",util\logging.cc,"void AppendEscapedStringTo(std::string* str, const Slice& value) {
  for (size_t i = 0; i < value.size(); i++) {
    char c = value[i];
    if (c >= ' ' && c <= '~') {
      str->push_back(c);
    } else {
      char buf[10];
      snprintf(buf, sizeof(buf), ""\\x%02x"",
               static_cast<unsigned int>(c) & 0xff);
      str->append(buf);
    }
  }
}",22.0,34.0,1.0,1.0,13.0,9,8,10,4,0,0,3,4,0,0,,0,0,4,2,2,void
2552,92223,NumberToString,1,leveldb.NumberToString,string leveldb.NumberToString (uint64_t),util\logging.cc,"std::string NumberToString(uint64_t num) {
  std::string r;
  AppendNumberTo(&r, num);
  return r;
}",36.0,40.0,1.0,1.0,5.0,1,1,3,2,0,0,1,1,0,0,,0,0,2,1,1,string
2553,92235,EscapeString,1,leveldb.EscapeString,string leveldb.EscapeString (Slice),util\logging.cc,"std::string EscapeString(const Slice& value) {
  std::string r;
  AppendEscapedStringTo(&r, value);
  return r;
}",42.0,46.0,1.0,1.0,5.0,1,1,3,2,0,0,1,1,0,0,,0,0,2,1,1,string
2554,92247,ConsumeDecimalNumber,1,leveldb.ConsumeDecimalNumber,"bool leveldb.ConsumeDecimalNumber (Slice*,uint64_t*)",util\logging.cc,"bool ConsumeDecimalNumber(Slice* in, uint64_t* val) {
  uint64_t v = 0;
  int digits = 0;
  while (!in->empty()) {
    char c = (*in)[0];
    if (c >= '0' && c <= '9') {
      ++digits;
      const int delta = (c - '0');
      static const uint64_t kMaxUint64 = ~static_cast<uint64_t>(0);
      if (v > kMaxUint64/10 ||
          (v == kMaxUint64/10 && delta > kMaxUint64%10)) {
        // Overflow
        return false;
      }
      v = (v * 10) + delta;
      in->remove_prefix(1);
    } else {
      break;
    }
  }
  *val = v;
  return (digits > 0);
}",48.0,70.0,1.0,1.0,23.0,31,19,24,7,0,0,4,7,0,0,,0,0,4,2,2,bool
2555,92398,MutexLock,1,leveldb.MutexLock.MutexLock,ANY leveldb.MutexLock.MutexLock (ANY*),util\mutexlock.hpp,"explicit MutexLock(port::Mutex *mu) EXCLUSIVE_LOCK_FUNCTION(mu)
      : mu_(mu)  {
    this->mu_->Lock();
  }",25.0,28.0,3.0,38.0,4.0,2,1,0,0,0,1,1,1,0,0,,0,1,2,1,1,ANY
2556,92409,~MutexLock,1,leveldb.MutexLock.~MutexLock,ANY leveldb.MutexLock.~MutexLock (),util\mutexlock.hpp,~MutexLock() UNLOCK_FUNCTION() { this->mu_->Unlock(); },29.0,29.0,3.0,15.0,1.0,2,1,0,0,0,1,1,1,0,0,,0,1,0,0,0,ANY
2557,92425,operator =,1,leveldb.MutexLock.operator =,void leveldb.MutexLock.operator = (MutexLock),util\mutexlock.hpp,void operator=(const MutexLock&);,35.0,35.0,8.0,34.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
2558,92464,gettid_,1,leveldb.PosixLogger.gettid_,uint64_t leveldb.PosixLogger.gettid_ (),util\posix_logger.hpp,uint64_t (*gettid_)();,22.0,22.0,12.0,23.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,uint64_t
2559,92468,PosixLogger,1,leveldb.PosixLogger.PosixLogger,"ANY leveldb.PosixLogger.PosixLogger (FILE*,uint64_t)",util\posix_logger.hpp,"PosixLogger(FILE* f, uint64_t (*gettid)()) : file_(f), gettid_(gettid) { }",24.0,24.0,3.0,76.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,ANY
2560,92474,~PosixLogger,1,leveldb.PosixLogger.~PosixLogger,ANY leveldb.PosixLogger.~PosixLogger (),util\posix_logger.hpp,"virtual ~PosixLogger() {
    fclose(file_);
  }",25.0,27.0,3.0,3.0,3.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,ANY
2561,92480,Logv,1,leveldb.PosixLogger.Logv,"void leveldb.PosixLogger.Logv (char*,va_list)",util\posix_logger.hpp,"virtual void Logv(const char* format, va_list ap) {
    const uint64_t thread_id = (*gettid_)();

    // We try twice: the first time with a fixed-size stack allocated buffer,
    // and the second time with a much larger dynamically allocated buffer.
    char buffer[500];
    for (int iter = 0; iter < 2; iter++) {
      char* base;
      int bufsize;
      if (iter == 0) {
        bufsize = sizeof(buffer);
        base = buffer;
      } else {
        bufsize = 30000;
        base = new char[bufsize];
      }
      char* p = base;
      char* limit = base + bufsize;

      struct timeval now_tv;
      gettimeofday(&now_tv, NULL);
      const time_t seconds = now_tv.tv_sec;
      struct tm t;
      localtime_r(&seconds, &t);
      p += snprintf(p, limit - p,
                    ""%04d/%02d/%02d-%02d:%02d:%02d.%06d %llx "",
                    t.tm_year + 1900,
                    t.tm_mon + 1,
                    t.tm_mday,
                    t.tm_hour,
                    t.tm_min,
...",28.0,93.0,3.0,3.0,66.0,46,19,60,16,0,2,10,15,0,0,,0,2,4,2,2,void
2562,92679,Random,1,leveldb.Random.Random,ANY leveldb.Random.Random (uint32_t),util\random.hpp,"explicit Random(uint32_t s) : seed_(s & 0x7fffffffu) {
    // Avoid bad seeds.
    if (seed_ == 0 || seed_ == 2147483647L) {
      seed_ = 1;
    }
  }",19.0,24.0,3.0,3.0,6.0,4,3,3,1,0,3,2,2,2,0,,0,3,2,1,1,ANY
2563,92696,Next,1,leveldb.Random.Next,uint32_t leveldb.Random.Next (),util\random.hpp,"uint32_t Next() {
    static const uint32_t M = 2147483647L;   // 2^31-1
    static const uint64_t A = 16807;  // bits 14, 8, 7, 5, 2, 1, 0
    // We are computing
    //       seed_ = (seed_ * A) % M,    where M = 2^31-1
    //
    // seed_ must not be zero or M, or else all subsequent computed values
    // will be zero or M respectively.  For all other values, seed_ will end
    // up cycling through every number in [1,M-1]
    uint64_t product = seed_ * A;

    // Compute (product % M) using the fact that ((x << 31) % M) == x.
    seed_ = static_cast<uint32_t>((product >> 31) + (product & M));
    // The first reduction may overflow by 1 bit, so we may need to
    // repeat.  mod == M is not possible; using > allows the faster
    // sign-bit-based test.
    if (seed_ > M) {
      seed_ -= M;
    }
    return seed_;
  }",25.0,45.0,3.0,3.0,21.0,11,8,14,4,0,5,2,2,1,0,,0,5,0,0,0,uint32_t
2564,92735,Uniform,1,leveldb.Random.Uniform,uint32_t leveldb.Random.Uniform (int),util\random.hpp,uint32_t Uniform(int n) { return Next() % n; },48.0,48.0,3.0,48.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,uint32_t
2565,92744,OneIn,1,leveldb.Random.OneIn,bool leveldb.Random.OneIn (int),util\random.hpp,bool OneIn(int n) { return (Next() % n) == 0; },52.0,52.0,3.0,49.0,1.0,2,2,1,1,0,0,1,1,0,0,,0,0,2,1,1,bool
2566,92755,Skewed,1,leveldb.Random.Skewed,uint32_t leveldb.Random.Skewed (int),util\random.hpp,"uint32_t Skewed(int max_log) {
    return Uniform(1 << Uniform(max_log + 1));
  }",57.0,59.0,3.0,3.0,3.0,2,2,1,1,0,0,1,1,0,0,,0,0,2,1,1,uint32_t
2567,93007,func,1,leveldb.test.anonymous_namespace_2.Test.func,void leveldb.test.anonymous_namespace_2.Test.func (),util\testharness.cc,void (*func)();,19.0,19.0,8.0,16.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2568,93012,RegisterTest,1,leveldb.test.RegisterTest,"bool leveldb.test.RegisterTest (char*,char*,void)",util\testharness.cc,"bool RegisterTest(const char* base, const char* name, void (*func)()) {
  if (tests == NULL) {
    tests = new std::vector<Test>;
  }
  Test t;
  t.base = base;
  t.name = name;
  t.func = func;
  tests->push_back(t);
  return true;
}",24.0,34.0,1.0,1.0,11.0,10,5,12,7,0,2,2,2,0,0,,0,2,6,3,3,bool
2569,93051,RunAllTests,1,leveldb.test.RunAllTests,int leveldb.test.RunAllTests (),util\testharness.cc,"int RunAllTests() {
  const char* matcher = getenv(""LEVELDB_TESTS"");

  int num = 0;
  if (tests != NULL) {
    for (size_t i = 0; i < tests->size(); i++) {
      const Test& t = (*tests)[i];
      if (matcher != NULL) {
        std::string name = t.base;
        name.push_back('.');
        name.append(t.name);
        if (strstr(name.c_str(), matcher) == NULL) {
          continue;
        }
      }
      fprintf(stderr, ""==== Test %s.%s\n"", t.base, t.name);
      (*t.func)();
      ++num;
    }
  }
  fprintf(stderr, ""==== PASSED %d tests\n"", num);
  return 0;
}",36.0,58.0,1.0,1.0,23.0,22,9,27,8,1,4,6,11,0,0,,0,4,0,0,0,int
2570,93147,TmpDir,1,leveldb.test.TmpDir,string leveldb.test.TmpDir (),util\testharness.cc,"std::string TmpDir() {
  std::string dir;
  Status s = Env::Default()->GetTestDirectory(&dir);
  ASSERT_TRUE(s.ok()) << s.ToString();
  return dir;
}",60.0,65.0,1.0,2.0,6.0,11,5,9,4,1,0,1,1,0,0,,0,0,0,0,0,string
2571,93193,RandomSeed,1,leveldb.test.RandomSeed,int leveldb.test.RandomSeed (),util\testharness.cc,"int RandomSeed() {
  const char* env = getenv(""TEST_RANDOM_SEED"");
  int result = (env != NULL ? atoi(env) : 301);
  if (result <= 0) {
    result = 301;
  }
  return result;
}",67.0,74.0,1.0,1.0,8.0,6,4,8,3,0,0,2,2,0,0,,0,0,0,0,0,int
2572,93258,Tester,1,leveldb.test.Tester.Tester,"ANY leveldb.test.Tester.Tester (char*,int)",util\testharness.hpp,"Tester(const char* f, int l)
      : ok_(true), fname_(f), line_(l) {
  }",50.0,52.0,3.0,3.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,ANY
2573,93264,~Tester,1,leveldb.test.Tester.~Tester,ANY leveldb.test.Tester.~Tester (),util\testharness.hpp,"~Tester() {
    if (!ok_) {
      fprintf(stderr, ""%s:%d:%s\n"", fname_, line_, ss_.str().c_str());
      exit(1);
    }
  }",54.0,59.0,3.0,3.0,6.0,3,2,5,5,0,4,2,2,1,0,,0,4,0,0,0,ANY
2574,93286,Is,1,leveldb.test.Tester.Is,"Tester leveldb.test.Tester.Is (bool,char*)",util\testharness.hpp,"Tester& Is(bool b, const char* msg) {
    if (!b) {
      ss_ << "" Assertion failure "" << msg;
      ok_ = false;
    }
    return *this;
  }",61.0,67.0,3.0,3.0,7.0,5,4,4,4,0,2,2,2,0,0,,0,2,4,2,2,Tester
2575,93307,IsOk,1,leveldb.test.Tester.IsOk,Tester leveldb.test.Tester.IsOk (Status),util\testharness.hpp,"Tester& IsOk(const Status& s) {
    if (!s.ok()) {
      ss_ << "" "" << s.ToString();
      ok_ = false;
    }
    return *this;
  }",69.0,75.0,3.0,3.0,7.0,7,5,4,3,0,2,2,2,0,0,,0,2,2,1,1,Tester
2576,93333,IsEq,1,leveldb.test.Tester.IsEq,"Tester leveldb.test.Tester.IsEq<X,Y> (X,Y)",util\testharness.hpp,"BINARY_OP(IsEq, ==)",87.0,87.0,3.0,21.0,1.0,8,5,6,4,0,2,2,2,0,0,,0,2,4,2,2,Tester
2577,93360,IsNe,1,leveldb.test.Tester.IsNe,"Tester leveldb.test.Tester.IsNe<X,Y> (X,Y)",util\testharness.hpp,"BINARY_OP(IsNe, !=)",88.0,88.0,3.0,21.0,1.0,8,5,6,4,0,2,2,2,0,0,,0,2,4,2,2,Tester
2578,93387,IsGe,1,leveldb.test.Tester.IsGe,"Tester leveldb.test.Tester.IsGe<X,Y> (X,Y)",util\testharness.hpp,"BINARY_OP(IsGe, >=)",89.0,89.0,3.0,21.0,1.0,8,5,6,4,0,2,2,2,0,0,,0,2,4,2,2,Tester
2579,93414,IsGt,1,leveldb.test.Tester.IsGt,"Tester leveldb.test.Tester.IsGt<X,Y> (X,Y)",util\testharness.hpp,"BINARY_OP(IsGt, >)",90.0,90.0,3.0,20.0,1.0,8,5,6,4,0,2,2,2,0,0,,0,2,4,2,2,Tester
2580,93441,IsLe,1,leveldb.test.Tester.IsLe,"Tester leveldb.test.Tester.IsLe<X,Y> (X,Y)",util\testharness.hpp,"BINARY_OP(IsLe, <=)",91.0,91.0,3.0,21.0,1.0,8,5,6,4,0,2,2,2,0,0,,0,2,4,2,2,Tester
2581,93468,IsLt,1,leveldb.test.Tester.IsLt,"Tester leveldb.test.Tester.IsLt<X,Y> (X,Y)",util\testharness.hpp,"BINARY_OP(IsLt, <)",92.0,92.0,3.0,20.0,1.0,8,5,6,4,0,2,2,2,0,0,,0,2,4,2,2,Tester
2582,93495,operator <<,1,leveldb.test.Tester.operator <<,Tester leveldb.test.Tester.operator <<<V> (V),util\testharness.hpp,"Tester& operator<<(const V& value) {
    if (!ok_) {
      ss_ << "" "" << value;
    }
    return *this;
  }",97.0,102.0,3.0,3.0,6.0,4,3,3,3,0,2,2,2,1,0,,0,2,2,1,1,Tester
2583,93530,RandomString,1,leveldb.test.RandomString,"Slice leveldb.test.RandomString (Random*,int,ANY*)",util\testutil.cc,"Slice RandomString(Random* rnd, int len, std::string* dst) {
  dst->resize(len);
  for (int i = 0; i < len; i++) {
    (*dst)[i] = static_cast<char>(' ' + rnd->Uniform(95));   // ' ' .. '~'
  }
  return Slice(*dst);
}",12.0,18.0,1.0,1.0,7.0,10,7,9,4,0,0,2,2,0,0,,0,0,6,3,3,Slice
2584,93572,RandomKey,1,leveldb.test.RandomKey,"string leveldb.test.RandomKey (Random*,int)",util\testutil.cc,"std::string RandomKey(Random* rnd, int len) {
  // Make sure to generate a wide variety of characters so we
  // test the boundary conditions for short-key optimizations.
  static const char kTestChars[] = {
    '\0', '\1', 'a', 'b', 'c', 'd', 'e', '\xfd', '\xfe', '\xff'
  };
  std::string result;
  for (int i = 0; i < len; i++) {
    result += kTestChars[rnd->Uniform(sizeof(kTestChars))];
  }
  return result;
}",20.0,31.0,1.0,1.0,12.0,8,7,9,5,0,0,2,2,0,0,,0,0,4,2,2,string
2585,93617,CompressibleString,1,leveldb.test.CompressibleString,"Slice leveldb.test.CompressibleString (Random*,double,size_t,ANY*)",util\testutil.cc,"extern Slice CompressibleString(Random* rnd, double compressed_fraction,
                                size_t len, std::string* dst) {
  int raw = static_cast<int>(len * compressed_fraction);
  if (raw < 1) raw = 1;
  std::string raw_data;
  RandomString(rnd, raw, &raw_data);

  // Duplicate the random data until we have filled ""len"" bytes
  dst->clear();
  while (dst->size() < len) {
    dst->append(raw_data);
  }
  dst->resize(len);
  return Slice(*dst);
}",34.0,48.0,1.0,1.0,15.0,12,7,16,6,0,0,3,3,0,0,,0,0,8,4,4,Slice
2586,93710,ErrorEnv,1,leveldb.test.ErrorEnv.ErrorEnv,ANY leveldb.test.ErrorEnv.ErrorEnv (),util\testutil.hpp,"ErrorEnv() : EnvWrapper(Env::Default()),
               writable_file_error_(false),
               num_writable_file_errors_(0) { }",35.0,37.0,3.0,47.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
2587,93714,NewWritableFile,1,leveldb.test.ErrorEnv.NewWritableFile,"Status leveldb.test.ErrorEnv.NewWritableFile (ANY,WritableFile**)",util\testutil.hpp,"virtual Status NewWritableFile(const std::string& fname,
                                 WritableFile** result) {
    if (writable_file_error_) {
      ++num_writable_file_errors_;
      *result = NULL;
      return Status::IOError(fname, ""fake error"");
    }
    return target()->NewWritableFile(fname, result);
  }",39.0,47.0,3.0,3.0,9.0,5,5,8,6,0,3,2,2,1,1,,0,2,4,2,2,Status
2588,93743,NewAppendableFile,1,leveldb.test.ErrorEnv.NewAppendableFile,"Status leveldb.test.ErrorEnv.NewAppendableFile (ANY,WritableFile**)",util\testutil.hpp,"virtual Status NewAppendableFile(const std::string& fname,
                                   WritableFile** result) {
    if (writable_file_error_) {
      ++num_writable_file_errors_;
      *result = NULL;
      return Status::IOError(fname, ""fake error"");
    }
    return target()->NewAppendableFile(fname, result);
  }",49.0,57.0,3.0,3.0,9.0,5,5,8,6,0,3,2,2,1,1,,0,2,4,2,2,Status
2589,18,AutoCompactTest,4,leveldb.AutoCompactTest,,db\autocompact_test.cc,"class AutoCompactTest {
 public:
  std::string dbname_;
  Cache* tiny_cache_;
  Options options_;
  DB* db_;

  AutoCompactTest() {
    dbname_ = test::TmpDir() + ""/autocompact_test"";
    tiny_cache_ = NewLRUCache(100);
    options_.block_cache = tiny_cache_;
    DestroyDB(dbname_, options_);
    options_.create_if_missing = true;
    options_.compression = kNoCompression;
    ASSERT_OK(DB::Open(options_, dbname_, &db_));
  }

  ~AutoCompactTest() {
    delete db_;
    DestroyDB(dbname_, Options());
    delete tiny_cache_;
  }

  std::string Key(int i) {
    char buf[100];
    snprintf(buf, sizeof(buf), ""key%06d"", i);
    return std::string(buf);
  }

  uint64_t Size(const Slice& start, const Slice& limit) {
    Range r(start, limit);
    uint64_t size;
    db_->GetApproximateSizes(&r, 1, &size);
    return size;
  }

  void DoReads(int n);
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2590,447,_Test_ReadAll,4,leveldb._Test_ReadAll,,db\autocompact_test.cc,_Test_ReadAll,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2591,482,_Test_ReadHalf,4,leveldb._Test_ReadHalf,,db\autocompact_test.cc,_Test_ReadHalf,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2592,800,Options,4,leveldb.Options,,db\builder.hpp,struct Options,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2593,801,FileMetaData,4,leveldb.FileMetaData,,db\builder.hpp,struct FileMetaData,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2594,802,Env,4,leveldb.Env,,db\builder.hpp,class Env,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2595,803,Iterator,4,leveldb.Iterator,,db\builder.hpp,class Iterator,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2596,804,TableCache,4,leveldb.TableCache,,db\builder.hpp,class TableCache,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2597,805,VersionEdit,4,leveldb.VersionEdit,,db\builder.hpp,class VersionEdit,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2598,845,leveldb_t,4,leveldb_t,,db\c.cc,struct leveldb_t              { DB*               rep; },-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2599,847,leveldb_iterator_t,4,leveldb_iterator_t,,db\c.cc,struct leveldb_iterator_t     { Iterator*         rep; },-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2600,849,leveldb_writebatch_t,4,leveldb_writebatch_t,,db\c.cc,struct leveldb_writebatch_t   { WriteBatch        rep; },-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2601,851,leveldb_snapshot_t,4,leveldb_snapshot_t,,db\c.cc,struct leveldb_snapshot_t     { const Snapshot*   rep; },-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2602,853,leveldb_readoptions_t,4,leveldb_readoptions_t,,db\c.cc,struct leveldb_readoptions_t  { ReadOptions       rep; },-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2603,855,leveldb_writeoptions_t,4,leveldb_writeoptions_t,,db\c.cc,struct leveldb_writeoptions_t { WriteOptions      rep; },-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2604,857,leveldb_options_t,4,leveldb_options_t,,db\c.cc,struct leveldb_options_t      { Options           rep; },-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2605,859,leveldb_cache_t,4,leveldb_cache_t,,db\c.cc,struct leveldb_cache_t        { Cache*            rep; },-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2606,861,leveldb_seqfile_t,4,leveldb_seqfile_t,,db\c.cc,struct leveldb_seqfile_t      { SequentialFile*   rep; },-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2607,863,leveldb_randomfile_t,4,leveldb_randomfile_t,,db\c.cc,struct leveldb_randomfile_t   { RandomAccessFile* rep; },-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2608,865,leveldb_writablefile_t,4,leveldb_writablefile_t,,db\c.cc,struct leveldb_writablefile_t { WritableFile*     rep; },-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2609,867,leveldb_logger_t,4,leveldb_logger_t,,db\c.cc,struct leveldb_logger_t       { Logger*           rep; },-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2610,869,leveldb_filelock_t,4,leveldb_filelock_t,,db\c.cc,struct leveldb_filelock_t     { FileLock*         rep; },-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2611,871,leveldb_comparator_t,4,leveldb_comparator_t,,db\c.cc,"struct leveldb_comparator_t : public Comparator {
  void* state_;
  void (*destructor_)(void*);
  int (*compare_)(
      void*,
      const char* a, size_t alen,
      const char* b, size_t blen);
  const char* (*name_)(void*);

  virtual ~leveldb_comparator_t() {
    (*destructor_)(state_);
  }

  virtual int Compare(const Slice& a, const Slice& b) const {
    return (*compare_)(state_, a.data(), a.size(), b.data(), b.size());
  }

  virtual const char* Name() const {
    return (*name_)(state_);
  }

  // No-ops since the C binding does not support key shortening methods.
  virtual void FindShortestSeparator(std::string*, const Slice&) const { }
  virtual void FindShortSuccessor(std::string* key) const { }
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2612,947,leveldb_filterpolicy_t,4,leveldb_filterpolicy_t,,db\c.cc,"struct leveldb_filterpolicy_t : public FilterPolicy {
  void* state_;
  void (*destructor_)(void*);
  const char* (*name_)(void*);
  char* (*create_)(
      void*,
      const char* const* key_array, const size_t* key_length_array,
      int num_keys,
      size_t* filter_length);
  unsigned char (*key_match_)(
      void*,
      const char* key, size_t length,
      const char* filter, size_t filter_length);

  virtual ~leveldb_filterpolicy_t() {
    (*destructor_)(state_);
  }

  virtual const char* Name() const {
    return (*name_)(state_);
  }

  virtual void CreateFilter(const Slice* keys, int n, std::string* dst) const {
    std::vector<const char*> key_pointers(n);
    std::vector<size_t> key_sizes(n);
    for (int i = 0; i < n; i++) {
      key_pointers[i] = keys[i].data();
      key_sizes[i] = keys[i].size();
    }
    size_t len;
    char* filter = (*create_)(state_, &key_pointers[0], &key_sizes[0], n, &len);
    dst->append(filter, len);
    free(filter);
  }

  virtual ...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2613,1098,leveldb_env_t,4,leveldb_env_t,,db\c.cc,"struct leveldb_env_t {
  Env* rep;
  bool is_default;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2614,3869,CorruptionTest,4,leveldb.CorruptionTest,,db\corruption_test.cc,"class CorruptionTest {
 public:
  test::ErrorEnv env_;
  std::string dbname_;
  Cache* tiny_cache_;
  Options options_;
  DB* db_;

  CorruptionTest() {
    tiny_cache_ = NewLRUCache(100);
    options_.env = &env_;
    options_.block_cache = tiny_cache_;
    dbname_ = test::TmpDir() + ""/corruption_test"";
    DestroyDB(dbname_, options_);

    db_ = NULL;
    options_.create_if_missing = true;
    Reopen();
    options_.create_if_missing = false;
  }

  ~CorruptionTest() {
     delete db_;
     DestroyDB(dbname_, Options());
     delete tiny_cache_;
  }

  Status TryReopen() {
    delete db_;
    db_ = NULL;
    return DB::Open(options_, dbname_, &db_);
  }

  void Reopen() {
    ASSERT_OK(TryReopen());
  }

  void RepairDB() {
    delete db_;
    db_ = NULL;
    ASSERT_OK(::leveldb::RepairDB(dbname_, options_));
  }

  void Build(int n) {
    std::string key_space, value_space;
    WriteBatch batch;
    for (int i = 0; i < n; i++) {
      //if ((i % 100) == 0) fprintf(stderr, ""@ %d ...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2615,4607,_Test_Recovery,4,leveldb._Test_Recovery,,db\corruption_test.cc,_Test_Recovery,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2616,4661,_Test_RecoverWriteError,4,leveldb._Test_RecoverWriteError,,db\corruption_test.cc,_Test_RecoverWriteError,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2617,4727,_Test_NewFileErrorDuringWrite,4,leveldb._Test_NewFileErrorDuringWrite,,db\corruption_test.cc,_Test_NewFileErrorDuringWrite,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2618,4864,_Test_TableFile,4,leveldb._Test_TableFile,,db\corruption_test.cc,_Test_TableFile,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2619,4930,_Test_TableFileRepair,4,leveldb._Test_TableFileRepair,,db\corruption_test.cc,_Test_TableFileRepair,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2620,5011,_Test_TableFileIndexData,4,leveldb._Test_TableFileIndexData,,db\corruption_test.cc,_Test_TableFileIndexData,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2621,5065,_Test_MissingDescriptor,4,leveldb._Test_MissingDescriptor,,db\corruption_test.cc,_Test_MissingDescriptor,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2622,5105,_Test_SequenceNumberRecovery,4,leveldb._Test_SequenceNumberRecovery,,db\corruption_test.cc,_Test_SequenceNumberRecovery,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2623,5376,_Test_CorruptedDescriptor,4,leveldb._Test_CorruptedDescriptor,,db\corruption_test.cc,_Test_CorruptedDescriptor,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2624,5519,_Test_CompactionInputError,4,leveldb._Test_CompactionInputError,,db\corruption_test.cc,_Test_CompactionInputError,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2625,5602,_Test_CompactionInputErrorParanoid,4,leveldb._Test_CompactionInputErrorParanoid,,db\corruption_test.cc,_Test_CompactionInputErrorParanoid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2626,5731,_Test_UnrelatedKeys,4,leveldb._Test_UnrelatedKeys,,db\corruption_test.cc,_Test_UnrelatedKeys,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2627,6026,RandomGenerator,4,leveldb.anonymous_namespace_1.RandomGenerator,,db\db_bench.cc,"class RandomGenerator {
 private:
  std::string data_;
  int pos_;

 public:
  RandomGenerator() {
    // We use a limited amount of data over and over again and ensure
    // that it is larger than the compression window (32KB), and also
    // large enough to serve all typical value sizes we want to write.
    Random rnd(301);
    std::string piece;
    while (data_.size() < 1048576) {
      // Add a short fragment that is as compressible as specified
      // by FLAGS_compression_ratio.
      test::CompressibleString(&rnd, FLAGS_compression_ratio, 100, &piece);
      data_.append(piece);
    }
    pos_ = 0;
  }

  Slice Generate(size_t len) {
    if (pos_ + len > data_.size()) {
      pos_ = 0;
      assert(len < data_.size());
    }
    pos_ += len;
    return Slice(data_.data() + pos_ - len, len);
  }
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2628,6139,Stats,4,leveldb.anonymous_namespace_5.Stats,,db\db_bench.cc,"class Stats {
 private:
  double start_;
  double finish_;
  double seconds_;
  int done_;
  int next_report_;
  int64_t bytes_;
  double last_op_finish_;
  Histogram hist_;
  std::string message_;

 public:
  Stats() { Start(); }

  void Start() {
    next_report_ = 100;
    last_op_finish_ = start_;
    hist_.Clear();
    done_ = 0;
    bytes_ = 0;
    seconds_ = 0;
    start_ = g_env->NowMicros();
    finish_ = start_;
    message_.clear();
  }

  void Merge(const Stats& other) {
    hist_.Merge(other.hist_);
    done_ += other.done_;
    bytes_ += other.bytes_;
    seconds_ += other.seconds_;
    if (other.start_ < start_) start_ = other.start_;
    if (other.finish_ > finish_) finish_ = other.finish_;

    // Just keep the messages from one thread
    if (message_.empty()) message_ = other.message_;
  }

  void Stop() {
    finish_ = g_env->NowMicros();
    seconds_ = (finish_ - start_) * 1e-6;
  }

  void AddMessage(Slice msg) {
    AppendWithSpace(&message_, msg);
  }

  void...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2629,6486,SharedState,4,leveldb.anonymous_namespace_17.SharedState,,db\db_bench.cc,"struct SharedState {
  port::Mutex mu;
  port::CondVar cv;
  int total;

  // Each thread goes through the following states:
  //    (1) initializing
  //    (2) waiting for others to be initialized
  //    (3) running
  //    (4) done

  int num_initialized;
  int num_done;
  bool start;

  SharedState() : cv(&mu) { }
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2630,6497,ThreadState,4,leveldb.anonymous_namespace_19.ThreadState,,db\db_bench.cc,"struct ThreadState {
  int tid;             // 0..n-1 when running in n threads
  Random rand;         // Has different seeds for different threads
  Stats stats;
  SharedState* shared;

  ThreadState(int index)
      : tid(index),
        rand(1000 + index) {
  }
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2631,6507,Benchmark,4,leveldb.Benchmark,,db\db_bench.cc,"class Benchmark {
 private:
  Cache* cache_;
  const FilterPolicy* filter_policy_;
  DB* db_;
  int num_;
  int value_size_;
  int entries_per_batch_;
  WriteOptions write_options_;
  int reads_;
  int heap_counter_;

  void PrintHeader() {
    const int kKeySize = 16;
    PrintEnvironment();
    fprintf(stdout, ""Keys:       %d bytes each\n"", kKeySize);
    fprintf(stdout, ""Values:     %d bytes each (%d bytes after compression)\n"",
            FLAGS_value_size,
            static_cast<int>(FLAGS_value_size * FLAGS_compression_ratio + 0.5));
    fprintf(stdout, ""Entries:    %d\n"", num_);
    fprintf(stdout, ""RawSize:    %.1f MB (estimated)\n"",
            ((static_cast<int64_t>(kKeySize + FLAGS_value_size) * num_)
             / 1048576.0));
    fprintf(stdout, ""FileSize:   %.1f MB (estimated)\n"",
            (((kKeySize + FLAGS_value_size * FLAGS_compression_ratio) * num_)
             / 1048576.0));
    PrintWarnings();
    fprintf(stdout, ""-----------------------------------------...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2632,7224,ThreadArg,4,leveldb.Benchmark.ThreadArg,,db\db_bench.cc,"struct ThreadArg {
    Benchmark* bm;
    SharedState* shared;
    ThreadState* thread;
    void (Benchmark::*method)(ThreadState*);
  }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2633,9408,Writer,4,leveldb.Writer,,db\db_impl.cc,"struct DBImpl::Writer {
  Status status;
  WriteBatch* batch;
  bool sync;
  bool done;
  port::CondVar cv;

  explicit Writer(port::Mutex* mu) : cv(mu) { }
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2634,9419,CompactionState,4,leveldb.CompactionState,,db\db_impl.cc,"struct DBImpl::CompactionState {
  Compaction* const compaction;

  // Sequence numbers < smallest_snapshot are not significant since we
  // will never have to service a snapshot below smallest_snapshot.
  // Therefore if we have seen a sequence number S <= smallest_snapshot,
  // we can drop all entries for the same key with sequence numbers < S.
  SequenceNumber smallest_snapshot;

  // Files produced by compaction
  struct Output {
    uint64_t number;
    uint64_t file_size;
    InternalKey smallest, largest;
  };
  std::vector<Output> outputs;

  // State kept for output being generated
  WritableFile* outfile;
  TableBuilder* builder;

  uint64_t total_bytes;

  Output* current_output() { return &outputs[outputs.size()-1]; }

  explicit CompactionState(Compaction* c)
      : compaction(c),
        outfile(NULL),
        builder(NULL),
        total_bytes(0) {
  }
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2635,9422,Output,4,leveldb.CompactionState.Output,,db\db_impl.cc,"struct Output {
    uint64_t number;
    uint64_t file_size;
    InternalKey smallest, largest;
  }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2636,12876,IterState,4,leveldb.anonymous_namespace_1.IterState,,db\db_impl.cc,"struct IterState {
  port::Mutex* mu;
  Version* version;
  MemTable* mem;
  MemTable* imm;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2637,14740,MemTable,4,leveldb.MemTable,,db\db_impl.hpp,class MemTable,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2638,14741,TableCache,4,leveldb.TableCache,,db\db_impl.hpp,class TableCache,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2639,14742,Version,4,leveldb.Version,,db\db_impl.hpp,class Version,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2640,14743,VersionEdit,4,leveldb.VersionEdit,,db\db_impl.hpp,class VersionEdit,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2641,14744,VersionSet,4,leveldb.VersionSet,,db\db_impl.hpp,class VersionSet,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2642,14745,DBImpl,4,leveldb.DBImpl,,db\db_impl.hpp,"class DBImpl : public DB {
 public:
  DBImpl(const Options& options, const std::string& dbname);
  virtual ~DBImpl();

  // Implementations of the DB interface
  virtual Status Put(const WriteOptions&, const Slice& key, const Slice& value);
  virtual Status Delete(const WriteOptions&, const Slice& key);
  virtual Status Write(const WriteOptions& options, WriteBatch* updates);
  virtual Status Get(const ReadOptions& options,
                     const Slice& key,
                     std::string* value);
  virtual Iterator* NewIterator(const ReadOptions&);
  virtual const Snapshot* GetSnapshot();
  virtual void ReleaseSnapshot(const Snapshot* snapshot);
  virtual bool GetProperty(const Slice& property, std::string* value);
  virtual void GetApproximateSizes(const Range* range, int n, uint64_t* sizes);
  virtual void CompactRange(const Slice* begin, const Slice* end);

  // Extra methods (for testing) that are not in the public DB interface

  // Compact any files in the named level t...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2643,14839,DB,4,leveldb.DBImpl.DB,,db\db_impl.hpp,friend class DB,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2644,14840,CompactionState,4,leveldb.DBImpl.CompactionState,,db\db_impl.hpp,struct CompactionState,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2645,14841,Writer,4,leveldb.DBImpl.Writer,,db\db_impl.hpp,struct Writer,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2646,14970,ManualCompaction,4,leveldb.DBImpl.ManualCompaction,,db\db_impl.hpp,"struct ManualCompaction {
    int level;
    bool done;
    const InternalKey* begin;   // NULL means beginning of key range
    const InternalKey* end;     // NULL means end of key range
    InternalKey tmp_storage;    // Used to keep track of compaction progress
  }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2647,14979,CompactionStats,4,leveldb.DBImpl.CompactionStats,,db\db_impl.hpp,"struct CompactionStats {
    int64_t micros;
    int64_t bytes_read;
    int64_t bytes_written;

    CompactionStats() : micros(0), bytes_read(0), bytes_written(0) { }

    void Add(const CompactionStats& c) {
      this->micros += c.micros;
      this->bytes_read += c.bytes_read;
      this->bytes_written += c.bytes_written;
    }
  }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2648,15076,DBIter,4,leveldb.anonymous_namespace_1.DBIter,,db\db_iter.cc,"class DBIter: public Iterator {
 public:
  // Which direction is the iterator currently moving?
  // (1) When moving forward, the internal iterator is positioned at
  //     the exact entry that yields this->key(), this->value()
  // (2) When moving backwards, the internal iterator is positioned
  //     just before all entries whose user key == this->key().
  enum Direction {
    kForward,
    kReverse
  };

  DBIter(DBImpl* db, const Comparator* cmp, Iterator* iter, SequenceNumber s,
         uint32_t seed)
      : db_(db),
        user_comparator_(cmp),
        iter_(iter),
        sequence_(s),
        direction_(kForward),
        valid_(false),
        rnd_(seed),
        bytes_counter_(RandomPeriod()) {
  }
  virtual ~DBIter() {
    delete iter_;
  }
  virtual bool Valid() const { return valid_; }
  virtual Slice key() const {
    assert(valid_);
    return (direction_ == kForward) ? ExtractUserKey(iter_->key()) : saved_key_;
  }
  virtual Slice value() const {
    assert(val...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2649,15077,Direction,4,leveldb.anonymous_namespace_2.DBIter.Direction,,db\db_iter.cc,"enum Direction {
    kForward,
    kReverse
  }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2650,15788,DBImpl,4,leveldb.DBImpl,,db\db_iter.hpp,class DBImpl,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2651,15850,AtomicCounter,4,leveldb.anonymous_namespace_1.AtomicCounter,,db\db_test.cc,"class AtomicCounter {
 private:
  port::Mutex mu_;
  int count_;
 public:
  AtomicCounter() : count_(0) { }
  void Increment() {
    IncrementBy(1);
  }
  void IncrementBy(int count) {
    MutexLock l(&mu_);
    count_ += count;
  }
  int Read() {
    MutexLock l(&mu_);
    return count_;
  }
  void Reset() {
    MutexLock l(&mu_);
    count_ = 0;
  }
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2652,15911,SpecialEnv,4,leveldb.SpecialEnv,,db\db_test.cc,"class SpecialEnv : public EnvWrapper {
 public:
  // sstable/log Sync() calls are blocked while this pointer is non-NULL.
  port::AtomicPointer delay_data_sync_;

  // sstable/log Sync() calls return an error.
  port::AtomicPointer data_sync_error_;

  // Simulate no-space errors while this pointer is non-NULL.
  port::AtomicPointer no_space_;

  // Simulate non-writable file system while this pointer is non-NULL
  port::AtomicPointer non_writable_;

  // Force sync of manifest files to fail while this pointer is non-NULL
  port::AtomicPointer manifest_sync_error_;

  // Force write to manifest files to fail while this pointer is non-NULL
  port::AtomicPointer manifest_write_error_;

  bool count_random_reads_;
  AtomicCounter random_read_counter_;

  explicit SpecialEnv(Env* base) : EnvWrapper(base) {
    delay_data_sync_.Release_Store(NULL);
    data_sync_error_.Release_Store(NULL);
    no_space_.Release_Store(NULL);
    non_writable_.Release_Store(NULL);
    count_random_reads_ =...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2653,16076,DBTest,4,leveldb.DBTest,,db\db_test.cc,"class DBTest {
 private:
  const FilterPolicy* filter_policy_;

  // Sequence of option configurations to try
  enum OptionConfig {
    kDefault,
    kReuse,
    kFilter,
    kUncompressed,
    kEnd
  };
  int option_config_;

 public:
  std::string dbname_;
  SpecialEnv* env_;
  DB* db_;

  Options last_options_;

  DBTest() : option_config_(kDefault),
             env_(new SpecialEnv(Env::Default())) {
    filter_policy_ = NewBloomFilterPolicy(10);
    dbname_ = test::TmpDir() + ""/db_test"";
    DestroyDB(dbname_, Options());
    db_ = NULL;
    Reopen();
  }

  ~DBTest() {
    delete db_;
    DestroyDB(dbname_, Options());
    delete env_;
    delete filter_policy_;
  }

  // Switch to a fresh database with the next option configuration to
  // test.  Return false if there are no more configurations to test.
  bool ChangeOptions() {
    option_config_++;
    if (option_config_ >= kEnd) {
      return false;
    } else {
      DestroyAndReopen();
      return true;
    }
  }

  // ...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2654,16078,OptionConfig,4,leveldb.DBTest.OptionConfig,,db\db_test.cc,"enum OptionConfig {
    kDefault,
    kReuse,
    kFilter,
    kUncompressed,
    kEnd
  }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2655,17191,_Test_Empty,4,leveldb._Test_Empty,,db\db_test.cc,_Test_Empty,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2656,17263,_Test_ReadWrite,4,leveldb._Test_ReadWrite,,db\db_test.cc,_Test_ReadWrite,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2657,17404,_Test_PutDeleteGet,4,leveldb._Test_PutDeleteGet,,db\db_test.cc,_Test_PutDeleteGet,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2658,17556,_Test_GetFromImmutableLayer,4,leveldb._Test_GetFromImmutableLayer,,db\db_test.cc,_Test_GetFromImmutableLayer,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2659,17693,_Test_GetFromVersions,4,leveldb._Test_GetFromVersions,,db\db_test.cc,_Test_GetFromVersions,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2660,17768,_Test_GetMemUsage,4,leveldb._Test_GetMemUsage,,db\db_test.cc,_Test_GetMemUsage,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2661,17887,_Test_GetSnapshot,4,leveldb._Test_GetSnapshot,,db\db_test.cc,_Test_GetSnapshot,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2662,18075,_Test_GetLevel0Ordering,4,leveldb._Test_GetLevel0Ordering,,db\db_test.cc,_Test_GetLevel0Ordering,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2663,18186,_Test_GetOrderedByLevels,4,leveldb._Test_GetOrderedByLevels,,db\db_test.cc,_Test_GetOrderedByLevels,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2664,18318,_Test_GetPicksCorrectFile,4,leveldb._Test_GetPicksCorrectFile,,db\db_test.cc,_Test_GetPicksCorrectFile,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2665,18468,_Test_GetEncountersEmptyLevel,4,leveldb._Test_GetEncountersEmptyLevel,,db\db_test.cc,_Test_GetEncountersEmptyLevel,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2666,18666,_Test_IterEmpty,4,leveldb._Test_IterEmpty,,db\db_test.cc,_Test_IterEmpty,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2667,18779,_Test_IterSingle,4,leveldb._Test_IterSingle,,db\db_test.cc,_Test_IterSingle,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2668,19140,_Test_IterMulti,4,leveldb._Test_IterMulti,,db\db_test.cc,_Test_IterMulti,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2669,19962,_Test_IterSmallAndLargeMix,4,leveldb._Test_IterSmallAndLargeMix,,db\db_test.cc,_Test_IterSmallAndLargeMix,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2670,20412,_Test_IterMultiWithDelete,4,leveldb._Test_IterMultiWithDelete,,db\db_test.cc,_Test_IterMultiWithDelete,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2671,20589,_Test_Recover,4,leveldb._Test_Recover,,db\db_test.cc,_Test_Recover,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2672,20840,_Test_RecoveryWithEmptyLog,4,leveldb._Test_RecoveryWithEmptyLog,,db\db_test.cc,_Test_RecoveryWithEmptyLog,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2673,20946,_Test_RecoverDuringMemtableCompaction,4,leveldb._Test_RecoverDuringMemtableCompaction,,db\db_test.cc,_Test_RecoverDuringMemtableCompaction,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2674,21178,_Test_MinorCompactionsHappen,4,leveldb._Test_MinorCompactionsHappen,,db\db_test.cc,_Test_MinorCompactionsHappen,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2675,21370,_Test_RecoverWithLargeLog,4,leveldb._Test_RecoverWithLargeLog,,db\db_test.cc,_Test_RecoverWithLargeLog,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2676,21656,_Test_CompactionsGenerateMultipleFiles,4,leveldb._Test_CompactionsGenerateMultipleFiles,,db\db_test.cc,_Test_CompactionsGenerateMultipleFiles,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2677,21856,_Test_RepeatedWritesToSameKey,4,leveldb._Test_RepeatedWritesToSameKey,,db\db_test.cc,_Test_RepeatedWritesToSameKey,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2678,21973,_Test_SparseMerge,4,leveldb._Test_SparseMerge,,db\db_test.cc,_Test_SparseMerge,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2679,22198,_Test_ApproximateSizes,4,leveldb._Test_ApproximateSizes,,db\db_test.cc,_Test_ApproximateSizes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2680,22653,_Test_ApproximateSizes_MixOfSmallAndLarge,4,leveldb._Test_ApproximateSizes_MixOfSmallAndLarge,,db\db_test.cc,_Test_ApproximateSizes_MixOfSmallAndLarge,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2681,23122,_Test_IteratorPinsRef,4,leveldb._Test_IteratorPinsRef,,db\db_test.cc,_Test_IteratorPinsRef,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2682,23323,_Test_Snapshot,4,leveldb._Test_Snapshot,,db\db_test.cc,_Test_Snapshot,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2683,23591,_Test_HiddenValuesAreRemoved,4,leveldb._Test_HiddenValuesAreRemoved,,db\db_test.cc,_Test_HiddenValuesAreRemoved,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2684,23877,_Test_DeletionMarkers1,4,leveldb._Test_DeletionMarkers1,,db\db_test.cc,_Test_DeletionMarkers1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2685,24127,_Test_DeletionMarkers2,4,leveldb._Test_DeletionMarkers2,,db\db_test.cc,_Test_DeletionMarkers2,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2686,24370,_Test_OverlapInLevel0,4,leveldb._Test_OverlapInLevel0,,db\db_test.cc,_Test_OverlapInLevel0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2687,24710,_Test_L0_CompactionBug_Issue44_a,4,leveldb._Test_L0_CompactionBug_Issue44_a,,db\db_test.cc,_Test_L0_CompactionBug_Issue44_a,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2688,24868,_Test_L0_CompactionBug_Issue44_b,4,leveldb._Test_L0_CompactionBug_Issue44_b,,db\db_test.cc,_Test_L0_CompactionBug_Issue44_b,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2689,24975,_Test_ComparatorCheck,4,leveldb._Test_ComparatorCheck,,db\db_test.cc,_Test_ComparatorCheck,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2690,25082,_Test_CustomComparator,4,leveldb._Test_CustomComparator,,db\db_test.cc,_Test_CustomComparator,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2691,25357,_Test_ManualCompaction,4,leveldb._Test_ManualCompaction,,db\db_test.cc,_Test_ManualCompaction,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2692,25576,_Test_DBOpen_Options,4,leveldb._Test_DBOpen_Options,,db\db_test.cc,_Test_DBOpen_Options,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2693,25855,_Test_Locking,4,leveldb._Test_Locking,,db\db_test.cc,_Test_Locking,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2694,25929,_Test_NoSpace,4,leveldb._Test_NoSpace,,db\db_test.cc,_Test_NoSpace,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2695,26083,_Test_NonWritableFileSystem,4,leveldb._Test_NonWritableFileSystem,,db\db_test.cc,_Test_NonWritableFileSystem,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2696,26218,_Test_WriteSyncError,4,leveldb._Test_WriteSyncError,,db\db_test.cc,_Test_WriteSyncError,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2697,26472,_Test_ManifestWriteError,4,leveldb._Test_ManifestWriteError,,db\db_test.cc,_Test_ManifestWriteError,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2698,26695,_Test_MissingSSTFile,4,leveldb._Test_MissingSSTFile,,db\db_test.cc,_Test_MissingSSTFile,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2699,26875,_Test_StillReadSST,4,leveldb._Test_StillReadSST,,db\db_test.cc,_Test_StillReadSST,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2700,27040,_Test_FilesDeletedAfterCompaction,4,leveldb._Test_FilesDeletedAfterCompaction,,db\db_test.cc,_Test_FilesDeletedAfterCompaction,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2701,27144,_Test_BloomFilter,4,leveldb._Test_BloomFilter,,db\db_test.cc,_Test_BloomFilter,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2702,27479,MTState,4,leveldb.anonymous_namespace_15.MTState,,db\db_test.cc,"struct MTState {
  DBTest* test;
  port::AtomicPointer stop;
  port::AtomicPointer counter[kNumThreads];
  port::AtomicPointer thread_done[kNumThreads];
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2703,27492,MTThread,4,leveldb.anonymous_namespace_16.MTThread,,db\db_test.cc,"struct MTThread {
  MTState* state;
  int id;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2704,27799,_Test_MultiThreaded,4,leveldb._Test_MultiThreaded,,db\db_test.cc,_Test_MultiThreaded,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2705,27954,KVMap,4,KVMap,,db\db_test.cc,"typedef std::map<std::string, std::string> KVMap;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2706,27955,ModelDB,4,leveldb.ModelDB,,db\db_test.cc,"class ModelDB: public DB {
 public:
  class ModelSnapshot : public Snapshot {
   public:
    KVMap map_;
  };

  explicit ModelDB(const Options& options): options_(options) { }
  ~ModelDB() { }
  virtual Status Put(const WriteOptions& o, const Slice& k, const Slice& v) {
    return DB::Put(o, k, v);
  }
  virtual Status Delete(const WriteOptions& o, const Slice& key) {
    return DB::Delete(o, key);
  }
  virtual Status Get(const ReadOptions& options,
                     const Slice& key, std::string* value) {
    assert(false);      // Not implemented
    return Status::NotFound(key);
  }
  virtual Iterator* NewIterator(const ReadOptions& options) {
    if (options.snapshot == NULL) {
      KVMap* saved = new KVMap;
      *saved = map_;
      return new ModelIter(saved, true);
    } else {
      const KVMap* snapshot_state =
          &(reinterpret_cast<const ModelSnapshot*>(options.snapshot)->map_);
      return new ModelIter(snapshot_state, false);
    }
  }
  virtual const Snap...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2707,27956,ModelSnapshot,4,leveldb.ModelDB.ModelSnapshot,,db\db_test.cc,"class ModelSnapshot : public Snapshot {
   public:
    KVMap map_;
  }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2708,28137,ModelIter,4,leveldb.ModelDB.ModelIter,,db\db_test.cc,"class ModelIter: public Iterator {
   public:
    ModelIter(const KVMap* map, bool owned)
        : map_(map), owned_(owned), iter_(map_->end()) {
    }
    ~ModelIter() {
      if (owned_) delete map_;
    }
    virtual bool Valid() const { return iter_ != map_->end(); }
    virtual void SeekToFirst() { iter_ = map_->begin(); }
    virtual void SeekToLast() {
      if (map_->empty()) {
        iter_ = map_->end();
      } else {
        iter_ = map_->find(map_->rbegin()->first);
      }
    }
    virtual void Seek(const Slice& k) {
      iter_ = map_->lower_bound(k.ToString());
    }
    virtual void Next() { ++iter_; }
    virtual void Prev() { --iter_; }
    virtual Slice key() const { return iter_->first; }
    virtual Slice value() const { return iter_->second; }
    virtual Status status() const { return Status::OK(); }
   private:
    const KVMap* const map_;
    const bool owned_;  // Do we own map_
    KVMap::const_iterator iter_;
  }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2709,28502,_Test_Randomized,4,leveldb._Test_Randomized,,db\db_test.cc,_Test_Randomized,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2710,29847,InternalKey,4,leveldb.InternalKey,,db\dbformat.hpp,class InternalKey,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2711,29848,ValueType,4,leveldb.ValueType,,db\dbformat.hpp,"enum ValueType {
  kTypeDeletion = 0x0,
  kTypeValue = 0x1
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2712,29865,SequenceNumber,4,SequenceNumber,,db\dbformat.hpp,typedef uint64_t SequenceNumber;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2713,29874,ParsedInternalKey,4,leveldb.ParsedInternalKey,,db\dbformat.hpp,"struct ParsedInternalKey {
  Slice user_key;
  SequenceNumber sequence;
  ValueType type;

  ParsedInternalKey() { }  // Intentionally left uninitialized (for speed)
  ParsedInternalKey(const Slice& u, const SequenceNumber& seq, ValueType t)
      : user_key(u), sequence(seq), type(t) { }
  std::string DebugString() const;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2714,29984,InternalKeyComparator,4,leveldb.InternalKeyComparator,,db\dbformat.hpp,"class InternalKeyComparator : public Comparator {
 private:
  const Comparator* user_comparator_;
 public:
  explicit InternalKeyComparator(const Comparator* c) : user_comparator_(c) { }
  virtual const char* Name() const;
  virtual int Compare(const Slice& a, const Slice& b) const;
  virtual void FindShortestSeparator(
      std::string* start,
      const Slice& limit) const;
  virtual void FindShortSuccessor(std::string* key) const;

  const Comparator* user_comparator() const { return user_comparator_; }

  int Compare(const InternalKey& a, const InternalKey& b) const;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2715,30024,InternalFilterPolicy,4,leveldb.InternalFilterPolicy,,db\dbformat.hpp,"class InternalFilterPolicy : public FilterPolicy {
 private:
  const FilterPolicy* const user_policy_;
 public:
  explicit InternalFilterPolicy(const FilterPolicy* p) : user_policy_(p) { }
  virtual const char* Name() const;
  virtual void CreateFilter(const Slice* keys, int n, std::string* dst) const;
  virtual bool KeyMayMatch(const Slice& key, const Slice& filter) const;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2716,30048,InternalKey,4,leveldb.InternalKey,,db\dbformat.hpp,"class InternalKey {
 private:
  std::string rep_;
 public:
  InternalKey() { }   // Leave rep_ as empty to indicate it is invalid
  InternalKey(const Slice& user_key, SequenceNumber s, ValueType t) {
    AppendInternalKey(&rep_, ParsedInternalKey(user_key, s, t));
  }

  void DecodeFrom(const Slice& s) { rep_.assign(s.data(), s.size()); }
  Slice Encode() const {
    assert(!rep_.empty());
    return rep_;
  }

  Slice user_key() const { return ExtractUserKey(rep_); }

  void SetFrom(const ParsedInternalKey& p) {
    rep_.clear();
    AppendInternalKey(&rep_, p);
  }

  void Clear() { rep_.clear(); }

  std::string DebugString() const;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2717,30215,LookupKey,4,leveldb.LookupKey,,db\dbformat.hpp,"class LookupKey {
 public:
  // Initialize *this for looking up user_key at a snapshot with
  // the specified sequence number.
  LookupKey(const Slice& user_key, SequenceNumber sequence);

  ~LookupKey();

  // Return a key suitable for lookup in a MemTable.
  Slice memtable_key() const { return Slice(start_, end_ - start_); }

  // Return an internal key (suitable for passing to an internal iterator)
  Slice internal_key() const { return Slice(kstart_, end_ - kstart_); }

  // Return the user key
  Slice user_key() const { return Slice(kstart_, end_ - kstart_ - 8); }

 private:
  // We construct a char array of the form:
  //    klength  varint32               <-- start_
  //    userkey  char[klength]          <-- kstart_
  //    tag      uint64
  //                                    <-- end_
  // The array is a suitable MemTable key.
  // The suffix starting with ""userkey"" can be used as an InternalKey.
  const char* start_;
  const char* kstart_;
  const char* end_;
  char spac...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2718,30485,FormatTest,4,leveldb.FormatTest,,db\dbformat_test.cc,class FormatTest { },-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2719,30486,_Test_InternalKey_EncodeDecode,4,leveldb._Test_InternalKey_EncodeDecode,,db\dbformat_test.cc,_Test_InternalKey_EncodeDecode,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2720,30621,_Test_InternalKeyShortSeparator,4,leveldb._Test_InternalKeyShortSeparator,,db\dbformat_test.cc,_Test_InternalKeyShortSeparator,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2721,30862,_Test_InternalKeyShortestSuccessor,4,leveldb._Test_InternalKeyShortestSuccessor,,db\dbformat_test.cc,_Test_InternalKeyShortestSuccessor,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2722,31043,CorruptionReporter,4,leveldb.anonymous_namespace_2.CorruptionReporter,,db\dumpfile.cc,"class CorruptionReporter : public log::Reader::Reporter {
 public:
  WritableFile* dst_;
  virtual void Corruption(size_t bytes, const Status& status) {
    std::string r = ""corruption: "";
    AppendNumberTo(&r, bytes);
    r += "" bytes; "";
    r += status.ToString();
    r.push_back('\n');
    dst_->Append(r);
  }
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2723,31147,WriteBatchItemPrinter,4,leveldb.anonymous_namespace_5.WriteBatchItemPrinter,,db\dumpfile.cc,"class WriteBatchItemPrinter : public WriteBatch::Handler {
 public:
  WritableFile* dst_;
  virtual void Put(const Slice& key, const Slice& value) {
    std::string r = ""  put '"";
    AppendEscapedStringTo(&r, key);
    r += ""' '"";
    AppendEscapedStringTo(&r, value);
    r += ""'\n"";
    dst_->Append(r);
  }
  virtual void Delete(const Slice& key) {
    std::string r = ""  del '"";
    AppendEscapedStringTo(&r, key);
    r += ""'\n"";
    dst_->Append(r);
  }
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2724,31748,FaultInjectionTestEnv,4,leveldb.FaultInjectionTestEnv,,db\fault_injection_test.cc,class FaultInjectionTestEnv,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2725,31909,FileState,4,leveldb.anonymous_namespace_5.FileState,,db\fault_injection_test.cc,"struct FileState {
  std::string filename_;
  ssize_t pos_;
  ssize_t pos_at_last_sync_;
  ssize_t pos_at_last_flush_;

  FileState(const std::string& filename)
      : filename_(filename),
        pos_(-1),
        pos_at_last_sync_(-1),
        pos_at_last_flush_(-1) { }

  FileState() : pos_(-1), pos_at_last_sync_(-1), pos_at_last_flush_(-1) {}

  bool IsFullySynced() const { return pos_ <= 0 || pos_ == pos_at_last_sync_; }

  Status DropUnsyncedData() const;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2726,31939,TestWritableFile,4,leveldb.TestWritableFile,,db\fault_injection_test.cc,"class TestWritableFile : public WritableFile {
 public:
  TestWritableFile(const FileState& state,
                   WritableFile* f,
                   FaultInjectionTestEnv* env);
  virtual ~TestWritableFile();
  virtual Status Append(const Slice& data);
  virtual Status Close();
  virtual Status Flush();
  virtual Status Sync();

 private:
  FileState state_;
  WritableFile* target_;
  bool writable_file_opened_;
  FaultInjectionTestEnv* env_;

  Status SyncParent();
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2727,31976,FaultInjectionTestEnv,4,leveldb.FaultInjectionTestEnv,,db\fault_injection_test.cc,"class FaultInjectionTestEnv : public EnvWrapper {
 public:
  FaultInjectionTestEnv() : EnvWrapper(Env::Default()), filesystem_active_(true) {}
  virtual ~FaultInjectionTestEnv() { }
  virtual Status NewWritableFile(const std::string& fname,
                                 WritableFile** result);
  virtual Status NewAppendableFile(const std::string& fname,
                                   WritableFile** result);
  virtual Status DeleteFile(const std::string& f);
  virtual Status RenameFile(const std::string& s, const std::string& t);

  void WritableFileClosed(const FileState& state);
  Status DropUnsyncedFileData();
  Status DeleteFilesCreatedAfterLastDirSync();
  void DirWasSynced();
  bool IsFileCreatedSinceLastDirSync(const std::string& filename);
  void ResetState();
  void UntrackFile(const std::string& f);
  // Setting the filesystem to inactive is the test equivalent to simulating a
  // system reset. Setting to inactive will freeze our saved filesystem state so
  // that ...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2728,32701,FaultInjectionTest,4,leveldb.FaultInjectionTest,,db\fault_injection_test.cc,"class FaultInjectionTest {
 public:
  enum ExpectedVerifResult { VAL_EXPECT_NO_ERROR, VAL_EXPECT_ERROR };
  enum ResetMethod { RESET_DROP_UNSYNCED_DATA, RESET_DELETE_UNSYNCED_FILES };

  FaultInjectionTestEnv* env_;
  std::string dbname_;
  Cache* tiny_cache_;
  Options options_;
  DB* db_;

  FaultInjectionTest()
      : env_(new FaultInjectionTestEnv),
        tiny_cache_(NewLRUCache(100)),
        db_(NULL) {
    dbname_ = test::TmpDir() + ""/fault_test"";
    DestroyDB(dbname_, Options());  // Destroy any db from earlier run
    options_.reuse_logs = true;
    options_.env = env_;
    options_.paranoid_checks = true;
    options_.block_cache = tiny_cache_;
    options_.create_if_missing = true;
  }

  ~FaultInjectionTest() {
    CloseDB();
    DestroyDB(dbname_, Options());
    delete tiny_cache_;
    delete env_;
  }

  void ReuseLogs(bool reuse) {
    options_.reuse_logs = reuse;
  }

  void Build(int start_idx, int num_vals) {
    std::string key_space, value_space;
    WriteBa...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2729,32702,ExpectedVerifResult,4,leveldb.FaultInjectionTest.ExpectedVerifResult,,db\fault_injection_test.cc,"enum ExpectedVerifResult { VAL_EXPECT_NO_ERROR, VAL_EXPECT_ERROR }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2730,32705,ResetMethod,4,leveldb.FaultInjectionTest.ResetMethod,,db\fault_injection_test.cc,"enum ResetMethod { RESET_DROP_UNSYNCED_DATA, RESET_DELETE_UNSYNCED_FILES }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2731,33334,_Test_FaultTestNoLogReuse,4,leveldb._Test_FaultTestNoLogReuse,,db\fault_injection_test.cc,_Test_FaultTestNoLogReuse,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2732,33370,_Test_FaultTestWithLogReuse,4,leveldb._Test_FaultTestWithLogReuse,,db\fault_injection_test.cc,_Test_FaultTestWithLogReuse,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2733,33848,Env,4,leveldb.Env,,db\filename.hpp,class Env,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2734,33849,FileType,4,leveldb.FileType,,db\filename.hpp,"enum FileType {
  kLogFile,
  kDBLockFile,
  kTableFile,
  kDescriptorFile,
  kCurrentFile,
  kTempFile,
  kInfoLogFile  // Either the current one, or an old one
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2735,33937,FileNameTest,4,leveldb.FileNameTest,,db\filename_test.cc,class FileNameTest { },-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2736,33938,_Test_Parse,4,leveldb._Test_Parse,,db\filename_test.cc,_Test_Parse,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2737,34197,_Test_Construction,4,leveldb._Test_Construction,,db\filename_test.cc,_Test_Construction,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2738,34787,StdoutPrinter,4,leveldb.anonymous_namespace_1.StdoutPrinter,,db\leveldbutil.cc,"class StdoutPrinter : public WritableFile {
 public:
  virtual Status Append(const Slice& data) {
    fwrite(data.data(), 1, data.size(), stdout);
    return Status::OK();
  }
  virtual Status Close() { return Status::OK(); }
  virtual Status Flush() { return Status::OK(); }
  virtual Status Sync() { return Status::OK(); }
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2739,34971,RecordType,4,leveldb.log.RecordType,,db\log_format.hpp,"enum RecordType {
  // Zero is reserved for preallocated files
  kZeroType = 0,

  kFullType = 1,

  // For fragments
  kFirstType = 2,
  kMiddleType = 3,
  kLastType = 4
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2740,35716,SequentialFile,4,leveldb.SequentialFile,,db\log_reader.hpp,class SequentialFile,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2741,35718,Reader,4,leveldb.log.Reader,,db\log_reader.hpp,"class Reader {
 public:
  // Interface for reporting errors.
  class Reporter {
   public:
    virtual ~Reporter();

    // Some corruption was detected.  ""size"" is the approximate number
    // of bytes dropped due to the corruption.
    virtual void Corruption(size_t bytes, const Status& status) = 0;
  };

  // Create a reader that will return log records from ""*file"".
  // ""*file"" must remain live while this Reader is in use.
  //
  // If ""reporter"" is non-NULL, it is notified whenever some data is
  // dropped due to a detected corruption.  ""*reporter"" must remain
  // live while this Reader is in use.
  //
  // If ""checksum"" is true, verify checksums if available.
  //
  // The Reader will start reading at the first record located at physical
  // position >= initial_offset within the file.
  Reader(SequentialFile* file, Reporter* reporter, bool checksum,
         uint64_t initial_offset);

  ~Reader();

  // Read the next record into *record.  Returns true if read
  // success...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2742,35719,Reporter,4,leveldb.log.Reader.Reporter,,db\log_reader.hpp,"class Reporter {
   public:
    virtual ~Reporter();

    // Some corruption was detected.  ""size"" is the approximate number
    // of bytes dropped due to the corruption.
    virtual void Corruption(size_t bytes, const Status& status) = 0;
  }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2743,35762,anonymous_enum_0,4,leveldb.log.Reader.anonymous_enum_0,,db\log_reader.hpp,"enum {
    kEof = kMaxRecordType + 1,
    // Returned whenever we find an invalid physical record.
    // Currently there are three situations in which this happens:
    // * The record has an invalid CRC (ReadPhysicalRecord reports a drop)
    // * The record is a 0-length record (No drop is reported)
    // * The record is below constructor's initial_offset (No drop is reported)
    kBadRecord = kMaxRecordType + 2
  }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2744,35891,LogTest,4,leveldb.log.LogTest,,db\log_test.cc,"class LogTest {
 private:
  class StringDest : public WritableFile {
   public:
    std::string contents_;

    virtual Status Close() { return Status::OK(); }
    virtual Status Flush() { return Status::OK(); }
    virtual Status Sync() { return Status::OK(); }
    virtual Status Append(const Slice& slice) {
      contents_.append(slice.data(), slice.size());
      return Status::OK();
    }
  };

  class StringSource : public SequentialFile {
   public:
    Slice contents_;
    bool force_error_;
    bool returned_partial_;
    StringSource() : force_error_(false), returned_partial_(false) { }

    virtual Status Read(size_t n, Slice* result, char* scratch) {
      ASSERT_TRUE(!returned_partial_) << ""must not Read() after eof/error"";

      if (force_error_) {
        force_error_ = false;
        returned_partial_ = true;
        return Status::Corruption(""read error"");
      }

      if (contents_.size() < n) {
        n = contents_.size();
        returned_partial_ = true;
    ...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2745,35892,StringDest,4,leveldb.log.LogTest.StringDest,,db\log_test.cc,"class StringDest : public WritableFile {
   public:
    std::string contents_;

    virtual Status Close() { return Status::OK(); }
    virtual Status Flush() { return Status::OK(); }
    virtual Status Sync() { return Status::OK(); }
    virtual Status Append(const Slice& slice) {
      contents_.append(slice.data(), slice.size());
      return Status::OK();
    }
  }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2746,35943,StringSource,4,leveldb.log.LogTest.StringSource,,db\log_test.cc,"class StringSource : public SequentialFile {
   public:
    Slice contents_;
    bool force_error_;
    bool returned_partial_;
    StringSource() : force_error_(false), returned_partial_(false) { }

    virtual Status Read(size_t n, Slice* result, char* scratch) {
      ASSERT_TRUE(!returned_partial_) << ""must not Read() after eof/error"";

      if (force_error_) {
        force_error_ = false;
        returned_partial_ = true;
        return Status::Corruption(""read error"");
      }

      if (contents_.size() < n) {
        n = contents_.size();
        returned_partial_ = true;
      }
      *result = Slice(contents_.data(), n);
      contents_.remove_prefix(n);
      return Status::OK();
    }

    virtual Status Skip(uint64_t n) {
      if (n > contents_.size()) {
        contents_.clear();
        return Status::NotFound(""in-memory file skipped past end"");
      }

      contents_.remove_prefix(n);

      return Status::OK();
    }
  }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2747,36062,ReportCollector,4,leveldb.log.LogTest.ReportCollector,,db\log_test.cc,"class ReportCollector : public Reader::Reporter {
   public:
    size_t dropped_bytes_;
    std::string message_;

    ReportCollector() : dropped_bytes_(0) { }
    virtual void Corruption(size_t bytes, const Status& status) {
      dropped_bytes_ += bytes;
      message_.append(status.ToString());
    }
  }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2748,36702,_Test_Empty,4,leveldb.log._Test_Empty,,db\log_test.cc,_Test_Empty,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2749,36752,_Test_ReadWrite,4,leveldb.log._Test_ReadWrite,,db\log_test.cc,_Test_ReadWrite,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2750,36895,_Test_ManyBlocks,4,leveldb.log._Test_ManyBlocks,,db\log_test.cc,_Test_ManyBlocks,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2751,36991,_Test_Fragmentation,4,leveldb.log._Test_Fragmentation,,db\log_test.cc,_Test_Fragmentation,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2752,37104,_Test_MarginalTrailer,4,leveldb.log._Test_MarginalTrailer,,db\log_test.cc,_Test_MarginalTrailer,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2753,37240,_Test_MarginalTrailer2,4,leveldb.log._Test_MarginalTrailer2,,db\log_test.cc,_Test_MarginalTrailer2,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2754,37391,_Test_ShortTrailer,4,leveldb.log._Test_ShortTrailer,,db\log_test.cc,_Test_ShortTrailer,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2755,37531,_Test_AlignedEof,4,leveldb.log._Test_AlignedEof,,db\log_test.cc,_Test_AlignedEof,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2756,37633,_Test_OpenForAppend,4,leveldb.log._Test_OpenForAppend,,db\log_test.cc,_Test_OpenForAppend,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2757,37722,_Test_RandomRead,4,leveldb.log._Test_RandomRead,,db\log_test.cc,_Test_RandomRead,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2758,37830,_Test_ReadError,4,leveldb.log._Test_ReadError,,db\log_test.cc,_Test_ReadError,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2759,37917,_Test_BadRecordType,4,leveldb.log._Test_BadRecordType,,db\log_test.cc,_Test_BadRecordType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2760,38009,_Test_TruncatedTrailingRecordIsIgnored,4,leveldb.log._Test_TruncatedTrailingRecordIsIgnored,,db\log_test.cc,_Test_TruncatedTrailingRecordIsIgnored,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2761,38097,_Test_BadLength,4,leveldb.log._Test_BadLength,,db\log_test.cc,_Test_BadLength,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2762,38196,_Test_BadLengthAtEndIsIgnored,4,leveldb.log._Test_BadLengthAtEndIsIgnored,,db\log_test.cc,_Test_BadLengthAtEndIsIgnored,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2763,38284,_Test_ChecksumMismatch,4,leveldb.log._Test_ChecksumMismatch,,db\log_test.cc,_Test_ChecksumMismatch,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2764,38373,_Test_UnexpectedMiddleType,4,leveldb.log._Test_UnexpectedMiddleType,,db\log_test.cc,_Test_UnexpectedMiddleType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2765,38465,_Test_UnexpectedLastType,4,leveldb.log._Test_UnexpectedLastType,,db\log_test.cc,_Test_UnexpectedLastType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2766,38557,_Test_UnexpectedFullType,4,leveldb.log._Test_UnexpectedFullType,,db\log_test.cc,_Test_UnexpectedFullType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2767,38668,_Test_UnexpectedFirstType,4,leveldb.log._Test_UnexpectedFirstType,,db\log_test.cc,_Test_UnexpectedFirstType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2768,38782,_Test_MissingLastIsIgnored,4,leveldb.log._Test_MissingLastIsIgnored,,db\log_test.cc,_Test_MissingLastIsIgnored,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2769,38872,_Test_PartialLastIsIgnored,4,leveldb.log._Test_PartialLastIsIgnored,,db\log_test.cc,_Test_PartialLastIsIgnored,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2770,38962,_Test_SkipIntoMultiRecord,4,leveldb.log._Test_SkipIntoMultiRecord,,db\log_test.cc,_Test_SkipIntoMultiRecord,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2771,39073,_Test_ErrorJoinsRecords,4,leveldb.log._Test_ErrorJoinsRecords,,db\log_test.cc,_Test_ErrorJoinsRecords,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2772,39209,_Test_ReadStart,4,leveldb.log._Test_ReadStart,,db\log_test.cc,_Test_ReadStart,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2773,39245,_Test_ReadSecondOneOff,4,leveldb.log._Test_ReadSecondOneOff,,db\log_test.cc,_Test_ReadSecondOneOff,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2774,39281,_Test_ReadSecondTenThousand,4,leveldb.log._Test_ReadSecondTenThousand,,db\log_test.cc,_Test_ReadSecondTenThousand,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2775,39317,_Test_ReadSecondStart,4,leveldb.log._Test_ReadSecondStart,,db\log_test.cc,_Test_ReadSecondStart,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2776,39353,_Test_ReadThirdOneOff,4,leveldb.log._Test_ReadThirdOneOff,,db\log_test.cc,_Test_ReadThirdOneOff,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2777,39389,_Test_ReadThirdStart,4,leveldb.log._Test_ReadThirdStart,,db\log_test.cc,_Test_ReadThirdStart,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2778,39425,_Test_ReadFourthOneOff,4,leveldb.log._Test_ReadFourthOneOff,,db\log_test.cc,_Test_ReadFourthOneOff,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2779,39461,_Test_ReadFourthFirstBlockTrailer,4,leveldb.log._Test_ReadFourthFirstBlockTrailer,,db\log_test.cc,_Test_ReadFourthFirstBlockTrailer,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2780,39501,_Test_ReadFourthMiddleBlock,4,leveldb.log._Test_ReadFourthMiddleBlock,,db\log_test.cc,_Test_ReadFourthMiddleBlock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2781,39541,_Test_ReadFourthLastBlock,4,leveldb.log._Test_ReadFourthLastBlock,,db\log_test.cc,_Test_ReadFourthLastBlock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2782,39583,_Test_ReadFourthStart,4,leveldb.log._Test_ReadFourthStart,,db\log_test.cc,_Test_ReadFourthStart,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2783,39635,_Test_ReadInitialOffsetIntoBlockPadding,4,leveldb.log._Test_ReadInitialOffsetIntoBlockPadding,,db\log_test.cc,_Test_ReadInitialOffsetIntoBlockPadding,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2784,39677,_Test_ReadEnd,4,leveldb.log._Test_ReadEnd,,db\log_test.cc,_Test_ReadEnd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2785,39712,_Test_ReadPastEnd,4,leveldb.log._Test_ReadPastEnd,,db\log_test.cc,_Test_ReadPastEnd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2786,40101,WritableFile,4,leveldb.WritableFile,,db\log_writer.hpp,class WritableFile,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2787,40103,Writer,4,leveldb.log.Writer,,db\log_writer.hpp,"class Writer {
 public:
  // Create a writer that will append data to ""*dest"".
  // ""*dest"" must be initially empty.
  // ""*dest"" must remain live while this Writer is in use.
  explicit Writer(WritableFile* dest);

  // Create a writer that will append data to ""*dest"".
  // ""*dest"" must have initial length ""dest_length"".
  // ""*dest"" must remain live while this Writer is in use.
  Writer(WritableFile* dest, uint64_t dest_length);

  ~Writer();

  Status AddRecord(const Slice& slice);

 private:
  WritableFile* dest_;
  int block_offset_;       // Current offset in block

  // crc32c values for all supported record types.  These are
  // pre-computed to reduce the overhead of computing the crc of the
  // record type stored in the header.
  uint32_t type_crc_[kMaxRecordType + 1];

  Status EmitPhysicalRecord(RecordType type, const char* ptr, size_t length);

  // No copying allowed
  Writer(const Writer&);
  void operator=(const Writer&);
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2788,40271,MemTableIterator,4,leveldb.MemTableIterator,,db\memtable.cc,"class MemTableIterator: public Iterator {
 public:
  explicit MemTableIterator(MemTable::Table* table) : iter_(table) { }

  virtual bool Valid() const { return iter_.Valid(); }
  virtual void Seek(const Slice& k) { iter_.Seek(EncodeKey(&tmp_, k)); }
  virtual void SeekToFirst() { iter_.SeekToFirst(); }
  virtual void SeekToLast() { iter_.SeekToLast(); }
  virtual void Next() { iter_.Next(); }
  virtual void Prev() { iter_.Prev(); }
  virtual Slice key() const { return GetLengthPrefixedSlice(iter_.key()); }
  virtual Slice value() const {
    Slice key_slice = GetLengthPrefixedSlice(iter_.key());
    return GetLengthPrefixedSlice(key_slice.data() + key_slice.size());
  }

  virtual Status status() const { return Status::OK(); }

 private:
  MemTable::Table::Iterator iter_;
  std::string tmp_;       // For passing to EncodeKey

  // No copying allowed
  MemTableIterator(const MemTableIterator&);
  void operator=(const MemTableIterator&);
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2789,40635,InternalKeyComparator,4,leveldb.InternalKeyComparator,,db\memtable.hpp,class InternalKeyComparator,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2790,40636,Mutex,4,leveldb.Mutex,,db\memtable.hpp,class Mutex,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2791,40637,MemTableIterator,4,leveldb.MemTableIterator,,db\memtable.hpp,class MemTableIterator,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2792,40638,MemTable,4,leveldb.MemTable,,db\memtable.hpp,"class MemTable {
 public:
  // MemTables are reference counted.  The initial reference count
  // is zero and the caller must call Ref() at least once.
  explicit MemTable(const InternalKeyComparator& comparator);

  // Increase reference count.
  void Ref() { ++refs_; }

  // Drop reference count.  Delete if no more references exist.
  void Unref() {
    --refs_;
    assert(refs_ >= 0);
    if (refs_ <= 0) {
      delete this;
    }
  }

  // Returns an estimate of the number of bytes of data in use by this
  // data structure. It is safe to call when MemTable is being modified.
  size_t ApproximateMemoryUsage();

  // Return an iterator that yields the contents of the memtable.
  //
  // The caller must ensure that the underlying MemTable remains live
  // while the returned iterator is live.  The keys returned by this
  // iterator are internal keys encoded by AppendInternalKey in the
  // db/format.{h,cc} module.
  Iterator* NewIterator();

  // Add an entry into memtable that m...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2793,40694,KeyComparator,4,leveldb.MemTable.KeyComparator,,db\memtable.hpp,"struct KeyComparator {
    const InternalKeyComparator comparator;
    explicit KeyComparator(const InternalKeyComparator& c) : comparator(c) { }
    int operator()(const char* a, const char* b) const;
  }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2794,40707,MemTableIterator,4,leveldb.MemTable.MemTableIterator,,db\memtable.hpp,friend class MemTableIterator,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2795,40708,MemTableBackwardIterator,4,leveldb.MemTable.MemTableBackwardIterator,,db\memtable.hpp,friend class MemTableBackwardIterator,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2796,40709,Table,4,Table,,db\memtable.hpp,"typedef SkipList<const char*, KeyComparator> Table;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2797,40750,RecoveryTest,4,leveldb.RecoveryTest,,db\recovery_test.cc,"class RecoveryTest {
 public:
  RecoveryTest() : env_(Env::Default()), db_(NULL) {
    dbname_ = test::TmpDir() + ""/recovery_test"";
    DestroyDB(dbname_, Options());
    Open();
  }

  ~RecoveryTest() {
    Close();
    DestroyDB(dbname_, Options());
  }

  DBImpl* dbfull() const { return reinterpret_cast<DBImpl*>(db_); }
  Env* env() const { return env_; }

  bool CanAppend() {
    WritableFile* tmp;
    Status s = env_->NewAppendableFile(CurrentFileName(dbname_), &tmp);
    delete tmp;
    if (s.IsNotSupportedError()) {
      return false;
    } else {
      return true;
    }
  }

  void Close() {
    delete db_;
    db_ = NULL;
  }

  void Open(Options* options = NULL) {
    Close();
    Options opts;
    if (options != NULL) {
      opts = *options;
    } else {
      opts.reuse_logs = true;  // TODO(sanjay): test both ways
      opts.create_if_missing = true;
    }
    if (opts.env == NULL) {
      opts.env = env_;
    }
    ASSERT_OK(DB::Open(opts, dbname_, &db_));
    ASSER...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2798,41355,_Test_ManifestReused,4,leveldb._Test_ManifestReused,,db\recovery_test.cc,_Test_ManifestReused,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2799,41491,_Test_LargeManifestCompacted,4,leveldb._Test_LargeManifestCompacted,,db\recovery_test.cc,_Test_LargeManifestCompacted,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2800,41733,_Test_NoLogFiles,4,leveldb._Test_NoLogFiles,,db\recovery_test.cc,_Test_NoLogFiles,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2801,41839,_Test_LogFileReuse,4,leveldb._Test_LogFileReuse,,db\recovery_test.cc,_Test_LogFileReuse,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2802,42097,_Test_MultipleMemTables,4,leveldb._Test_MultipleMemTables,,db\recovery_test.cc,_Test_MultipleMemTables,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2803,42334,_Test_MultipleLogFiles,4,leveldb._Test_MultipleLogFiles,,db\recovery_test.cc,_Test_MultipleLogFiles,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2804,42818,Repairer,4,leveldb.anonymous_namespace_1.Repairer,,db\repair.cc,"class Repairer {
 public:
  Repairer(const std::string& dbname, const Options& options)
      : dbname_(dbname),
        env_(options.env),
        icmp_(options.comparator),
        ipolicy_(options.filter_policy),
        options_(SanitizeOptions(dbname, &icmp_, &ipolicy_, options)),
        owns_info_log_(options_.info_log != options.info_log),
        owns_cache_(options_.block_cache != options.block_cache),
        next_file_number_(1) {
    // TableCache can be small since we expect each table to be opened once.
    table_cache_ = new TableCache(dbname_, &options_, 10);
  }

  ~Repairer() {
    delete table_cache_;
    if (owns_info_log_) {
      delete options_.info_log;
    }
    if (owns_cache_) {
      delete options_.block_cache;
    }
  }

  Status Run() {
    Status status = FindFiles();
    if (status.ok()) {
      ConvertLogFilesToTables();
      ExtractMetaData();
      status = WriteDescriptor();
    }
    if (status.ok()) {
      unsigned long long bytes = 0;
     ...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2805,42924,TableInfo,4,leveldb.anonymous_namespace_9.Repairer.TableInfo,,db\repair.cc,"struct TableInfo {
    FileMetaData meta;
    SequenceNumber max_sequence;
  }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2806,44245,Arena,4,leveldb.Arena,,db\skiplist.hpp,class Arena,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2807,44246,SkipList,4,leveldb.SkipList,,db\skiplist.hpp,"class SkipList {
 private:
  struct Node;

 public:
  // Create a new SkipList object that will use ""cmp"" for comparing keys,
  // and will allocate memory using ""*arena"".  Objects allocated in the arena
  // must remain allocated for the lifetime of the skiplist object.
  explicit SkipList(Comparator cmp, Arena* arena);

  // Insert key into the list.
  // REQUIRES: nothing that compares equal to key is currently in the list.
  void Insert(const Key& key);

  // Returns true iff an entry that compares equal to key is in the list.
  bool Contains(const Key& key) const;

  // Iteration over the contents of a skip list
  class Iterator {
   public:
    // Initialize an iterator over the specified list.
    // The returned iterator is not valid.
    explicit Iterator(const SkipList* list);

    // Returns true iff the iterator is positioned at a valid node.
    bool Valid() const;

    // Returns the key at the current position.
    // REQUIRES: Valid()
    const Key& key() const;

   ...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2808,44247,Node,4,leveldb.SkipList.Node,,db\skiplist.hpp,struct Node,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2809,44264,Iterator,4,leveldb.SkipList.Iterator,,db\skiplist.hpp,"class Iterator {
   public:
    // Initialize an iterator over the specified list.
    // The returned iterator is not valid.
    explicit Iterator(const SkipList* list);

    // Returns true iff the iterator is positioned at a valid node.
    bool Valid() const;

    // Returns the key at the current position.
    // REQUIRES: Valid()
    const Key& key() const;

    // Advances to the next position.
    // REQUIRES: Valid()
    void Next();

    // Advances to the previous position.
    // REQUIRES: Valid()
    void Prev();

    // Advance to the first entry with a key >= target
    void Seek(const Key& target);

    // Position at the first entry in list.
    // Final state of iterator is Valid() iff list is not empty.
    void SeekToFirst();

    // Position at the last entry in list.
    // Final state of iterator is Valid() iff list is not empty.
    void SeekToLast();

   private:
    const SkipList* list_;
    Node* node_;
    // Intentionally copyable
  }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2810,44301,anonymous_enum_0,4,leveldb.SkipList.anonymous_enum_0,,db\skiplist.hpp,enum { kMaxHeight = 12 },-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2811,44381,Node,4,leveldb.Node,,db\skiplist.hpp,"struct SkipList<Key,Comparator>::Node {
  explicit Node(const Key& k) : key(k) { }

  Key const key;

  // Accessors/mutators for links.  Wrapped in methods so we can
  // add the appropriate barriers as necessary.
  Node* Next(int n) {
    assert(n >= 0);
    // Use an 'acquire load' so that we observe a fully initialized
    // version of the returned Node.
    return reinterpret_cast<Node*>(next_[n].Acquire_Load());
  }
  void SetNext(int n, Node* x) {
    assert(n >= 0);
    // Use a 'release store' so that anybody who reads through this
    // pointer observes a fully initialized version of the inserted node.
    next_[n].Release_Store(x);
  }

  // No-barrier variants that can be safely used in a few locations.
  Node* NoBarrier_Next(int n) {
    assert(n >= 0);
    return reinterpret_cast<Node*>(next_[n].NoBarrier_Load());
  }
  void NoBarrier_SetNext(int n, Node* x) {
    assert(n >= 0);
    next_[n].NoBarrier_Store(x);
  }

 private:
  // Array of length equal to the node h...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2812,44997,Key,4,Key,,db\skiplist_test.cc,typedef uint64_t Key;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2813,44998,Comparator,4,leveldb.Comparator,,db\skiplist_test.cc,"struct Comparator {
  int operator()(const Key& a, const Key& b) const {
    if (a < b) {
      return -1;
    } else if (a > b) {
      return +1;
    } else {
      return 0;
    }
  }
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2814,45027,SkipTest,4,leveldb.SkipTest,,db\skiplist_test.cc,class SkipTest { },-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2815,45028,_Test_Empty,4,leveldb._Test_Empty,,db\skiplist_test.cc,_Test_Empty,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2816,45207,_Test_InsertAndLookup,4,leveldb._Test_InsertAndLookup,,db\skiplist_test.cc,_Test_InsertAndLookup,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2817,45797,ConcurrentTest,4,leveldb.ConcurrentTest,,db\skiplist_test.cc,"class ConcurrentTest {
 private:
  static const uint32_t K = 4;

  static uint64_t key(Key key) { return (key >> 40); }
  static uint64_t gen(Key key) { return (key >> 8) & 0xffffffffu; }
  static uint64_t hash(Key key) { return key & 0xff; }

  static uint64_t HashNumbers(uint64_t k, uint64_t g) {
    uint64_t data[2] = { k, g };
    return Hash(reinterpret_cast<char*>(data), sizeof(data), 0);
  }

  static Key MakeKey(uint64_t k, uint64_t g) {
    assert(sizeof(Key) == sizeof(uint64_t));
    assert(k <= K);  // We sometimes pass K to seek to the end of the skiplist
    assert(g <= 0xffffffffu);
    return ((k << 40) | (g << 8) | (HashNumbers(k, g) & 0xff));
  }

  static bool IsValidKey(Key k) {
    return hash(k) == (HashNumbers(key(k), gen(k)) & 0xff);
  }

  static Key RandomTarget(Random* rnd) {
    switch (rnd->Next() % 10) {
      case 0:
        // Seek to beginning
        return MakeKey(0, 0);
      case 1:
        // Seek to end
        return MakeKey(K, 0);
      defaul...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2818,45933,State,4,leveldb.ConcurrentTest.State,,db\skiplist_test.cc,"struct State {
    port::AtomicPointer generation[K];
    void Set(int k, intptr_t v) {
      generation[k].Release_Store(reinterpret_cast<void*>(v));
    }
    intptr_t Get(int k) {
      return reinterpret_cast<intptr_t>(generation[k].Acquire_Load());
    }

    State() {
      for (int k = 0; k < K; k++) {
        Set(k, 0);
      }
    }
  }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2819,46300,_Test_ConcurrentWithoutThreads,4,leveldb._Test_ConcurrentWithoutThreads,,db\skiplist_test.cc,_Test_ConcurrentWithoutThreads,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2820,46364,TestState,4,leveldb.TestState,,db\skiplist_test.cc,"class TestState {
 public:
  ConcurrentTest t_;
  int seed_;
  port::AtomicPointer quit_flag_;

  enum ReaderState {
    STARTING,
    RUNNING,
    DONE
  };

  explicit TestState(int s)
      : seed_(s),
        quit_flag_(NULL),
        state_(STARTING),
        state_cv_(&mu_) {}

  void Wait(ReaderState s) {
    mu_.Lock();
    while (state_ != s) {
      state_cv_.Wait();
    }
    mu_.Unlock();
  }

  void Change(ReaderState s) {
    mu_.Lock();
    state_ = s;
    state_cv_.Signal();
    mu_.Unlock();
  }

 private:
  port::Mutex mu_;
  ReaderState state_;
  port::CondVar state_cv_;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2821,46368,ReaderState,4,leveldb.TestState.ReaderState,,db\skiplist_test.cc,"enum ReaderState {
    STARTING,
    RUNNING,
    DONE
  }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2822,46583,_Test_Concurrent1,4,leveldb._Test_Concurrent1,,db\skiplist_test.cc,_Test_Concurrent1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2823,46618,_Test_Concurrent2,4,leveldb._Test_Concurrent2,,db\skiplist_test.cc,_Test_Concurrent2,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2824,46653,_Test_Concurrent3,4,leveldb._Test_Concurrent3,,db\skiplist_test.cc,_Test_Concurrent3,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2825,46688,_Test_Concurrent4,4,leveldb._Test_Concurrent4,,db\skiplist_test.cc,_Test_Concurrent4,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2826,46723,_Test_Concurrent5,4,leveldb._Test_Concurrent5,,db\skiplist_test.cc,_Test_Concurrent5,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2827,46781,SnapshotList,4,leveldb.SnapshotList,,db\snapshot.hpp,class SnapshotList,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2828,46782,SnapshotImpl,4,leveldb.SnapshotImpl,,db\snapshot.hpp,"class SnapshotImpl : public Snapshot {
 public:
  SequenceNumber number_;  // const after creation

 private:
  friend class SnapshotList;

  // SnapshotImpl is kept in a doubly-linked circular list
  SnapshotImpl* prev_;
  SnapshotImpl* next_;

  SnapshotList* list_;                 // just for sanity checks
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2829,46784,SnapshotList,4,leveldb.SnapshotImpl.SnapshotList,,db\snapshot.hpp,friend class SnapshotList,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2830,46788,SnapshotList,4,leveldb.SnapshotList,,db\snapshot.hpp,"class SnapshotList {
 public:
  SnapshotList() {
    list_.prev_ = &list_;
    list_.next_ = &list_;
  }

  bool empty() const { return list_.next_ == &list_; }
  SnapshotImpl* oldest() const { assert(!empty()); return list_.next_; }
  SnapshotImpl* newest() const { assert(!empty()); return list_.prev_; }

  const SnapshotImpl* New(SequenceNumber seq) {
    SnapshotImpl* s = new SnapshotImpl;
    s->number_ = seq;
    s->list_ = this;
    s->next_ = &list_;
    s->prev_ = list_.prev_;
    s->prev_->next_ = s;
    s->next_->prev_ = s;
    return s;
  }

  void Delete(const SnapshotImpl* s) {
    assert(s->list_ == this);
    s->prev_->next_ = s->next_;
    s->next_->prev_ = s->prev_;
    delete s;
  }

 private:
  // Dummy head of doubly-linked list of snapshots
  SnapshotImpl list_;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2831,46935,TableAndFile,4,leveldb.TableAndFile,,db\table_cache.cc,"struct TableAndFile {
  RandomAccessFile* file;
  Table* table;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2832,47313,Env,4,leveldb.Env,,db\table_cache.hpp,class Env,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2833,47314,TableCache,4,leveldb.TableCache,,db\table_cache.hpp,"class TableCache {
 public:
  TableCache(const std::string& dbname, const Options* options, int entries);
  ~TableCache();

  // Return an iterator for the specified file number (the corresponding
  // file length must be exactly ""file_size"" bytes).  If ""tableptr"" is
  // non-NULL, also sets ""*tableptr"" to point to the Table object
  // underlying the returned iterator, or NULL if no Table object underlies
  // the returned iterator.  The returned ""*tableptr"" object is owned by
  // the cache and should not be deleted, and is valid for as long as the
  // returned iterator is live.
  Iterator* NewIterator(const ReadOptions& options,
                        uint64_t file_number,
                        uint64_t file_size,
                        Table** tableptr = NULL);

  // If a seek to internal key ""k"" in specified file finds an entry,
  // call (*handle_result)(arg, found_key, found_value).
  Status Get(const ReadOptions& options,
             uint64_t file_number,
             ...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2834,47372,Tag,4,leveldb.Tag,,db\version_edit.cc,"enum Tag {
  kComparator           = 1,
  kLogNumber            = 2,
  kNextFileNumber       = 3,
  kLastSequence         = 4,
  kCompactPointer       = 5,
  kDeletedFile          = 6,
  kNewFile              = 7,
  // 8 was used for large value refs
  kPrevLogNumber        = 9
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2835,48229,VersionSet,4,leveldb.VersionSet,,db\version_edit.hpp,class VersionSet,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2836,48230,FileMetaData,4,leveldb.FileMetaData,,db\version_edit.hpp,"struct FileMetaData {
  int refs;
  int allowed_seeks;          // Seeks allowed until compaction
  uint64_t number;
  uint64_t file_size;         // File size in bytes
  InternalKey smallest;       // Smallest internal key served by table
  InternalKey largest;        // Largest internal key served by table

  FileMetaData() : refs(0), allowed_seeks(1 << 30), file_size(0) { }
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2837,48241,VersionEdit,4,leveldb.VersionEdit,,db\version_edit.hpp,"class VersionEdit {
 public:
  VersionEdit() { Clear(); }
  ~VersionEdit() { }

  void Clear();

  void SetComparatorName(const Slice& name) {
    has_comparator_ = true;
    comparator_ = name.ToString();
  }
  void SetLogNumber(uint64_t num) {
    has_log_number_ = true;
    log_number_ = num;
  }
  void SetPrevLogNumber(uint64_t num) {
    has_prev_log_number_ = true;
    prev_log_number_ = num;
  }
  void SetNextFile(uint64_t num) {
    has_next_file_number_ = true;
    next_file_number_ = num;
  }
  void SetLastSequence(SequenceNumber seq) {
    has_last_sequence_ = true;
    last_sequence_ = seq;
  }
  void SetCompactPointer(int level, const InternalKey& key) {
    compact_pointers_.push_back(std::make_pair(level, key));
  }

  // Add the specified file at the specified number.
  // REQUIRES: This version has not been saved (see VersionSet::SaveTo)
  // REQUIRES: ""smallest"" and ""largest"" are smallest and largest keys in file
  void AddFile(int level, uint64_t file,
           ...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2838,48399,VersionSet,4,leveldb.VersionEdit.VersionSet,,db\version_edit.hpp,friend class VersionSet,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2839,48400,DeletedFileSet,4,DeletedFileSet,,db\version_edit.hpp,"typedef std::set< std::pair<int, uint64_t> > DeletedFileSet;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2840,48496,VersionEditTest,4,leveldb.VersionEditTest,,db\version_edit_test.cc,class VersionEditTest { },-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2841,48497,_Test_EncodeDecode,4,leveldb._Test_EncodeDecode,,db\version_edit_test.cc,_Test_EncodeDecode,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2842,49067,LevelFileNumIterator,4,leveldb.LevelFileNumIterator,,db\version_set.cc,"class Version::LevelFileNumIterator : public Iterator {
 public:
  LevelFileNumIterator(const InternalKeyComparator& icmp,
                       const std::vector<FileMetaData*>* flist)
      : icmp_(icmp),
        flist_(flist),
        index_(flist->size()) {        // Marks as invalid
  }
  virtual bool Valid() const {
    return index_ < flist_->size();
  }
  virtual void Seek(const Slice& target) {
    index_ = FindFile(icmp_, *flist_, target);
  }
  virtual void SeekToFirst() { index_ = 0; }
  virtual void SeekToLast() {
    index_ = flist_->empty() ? 0 : flist_->size() - 1;
  }
  virtual void Next() {
    assert(Valid());
    index_++;
  }
  virtual void Prev() {
    assert(Valid());
    if (index_ == 0) {
      index_ = flist_->size();  // Marks as invalid
    } else {
      index_--;
    }
  }
  Slice key() const {
    assert(Valid());
    return (*flist_)[index_]->largest.Encode();
  }
  Slice value() const {
    assert(Valid());
    EncodeFixed64(value_buf_, (*flist_)[in...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2843,49365,SaverState,4,leveldb.anonymous_namespace_1.SaverState,,db\version_set.cc,"enum SaverState {
  kNotFound,
  kFound,
  kDeleted,
  kCorrupt,
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2844,49370,Saver,4,leveldb.anonymous_namespace_2.Saver,,db\version_set.cc,"struct Saver {
  SaverState state;
  const Comparator* ucmp;
  Slice user_key;
  std::string* value;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2845,50598,Builder,4,leveldb.Builder,,db\version_set.cc,"class VersionSet::Builder {
 private:
  // Helper to sort by v->files_[file_number].smallest
  struct BySmallestKey {
    const InternalKeyComparator* internal_comparator;

    bool operator()(FileMetaData* f1, FileMetaData* f2) const {
      int r = internal_comparator->Compare(f1->smallest, f2->smallest);
      if (r != 0) {
        return (r < 0);
      } else {
        // Break ties by file number
        return (f1->number < f2->number);
      }
    }
  };

  typedef std::set<FileMetaData*, BySmallestKey> FileSet;
  struct LevelState {
    std::set<uint64_t> deleted_files;
    FileSet* added_files;
  };

  VersionSet* vset_;
  Version* base_;
  LevelState levels_[config::kNumLevels];

 public:
  // Initialize a builder with the files from *base and other info from *vset
  Builder(VersionSet* vset, Version* base)
      : vset_(vset),
        base_(base) {
    base_->Ref();
    BySmallestKey cmp;
    cmp.internal_comparator = &vset_->icmp_;
    for (int level = 0; level < config:...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2846,50599,BySmallestKey,4,leveldb.Builder.BySmallestKey,,db\version_set.cc,"struct BySmallestKey {
    const InternalKeyComparator* internal_comparator;

    bool operator()(FileMetaData* f1, FileMetaData* f2) const {
      int r = internal_comparator->Compare(f1->smallest, f2->smallest);
      if (r != 0) {
        return (r < 0);
      } else {
        // Break ties by file number
        return (f1->number < f2->number);
      }
    }
  }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2847,50639,FileSet,4,FileSet,,db\version_set.cc,"typedef std::set<FileMetaData*, BySmallestKey> FileSet;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2848,50640,LevelState,4,leveldb.Builder.LevelState,,db\version_set.cc,"struct LevelState {
    std::set<uint64_t> deleted_files;
    FileSet* added_files;
  }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2849,54011,Writer,4,leveldb.log.Writer,,db\version_set.hpp,class Writer,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2850,54012,Compaction,4,leveldb.Compaction,,db\version_set.hpp,class Compaction,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2851,54013,Iterator,4,leveldb.Iterator,,db\version_set.hpp,class Iterator,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2852,54014,MemTable,4,leveldb.MemTable,,db\version_set.hpp,class MemTable,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2853,54015,TableBuilder,4,leveldb.TableBuilder,,db\version_set.hpp,class TableBuilder,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2854,54016,TableCache,4,leveldb.TableCache,,db\version_set.hpp,class TableCache,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2855,54017,Version,4,leveldb.Version,,db\version_set.hpp,class Version,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2856,54018,VersionSet,4,leveldb.VersionSet,,db\version_set.hpp,class VersionSet,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2857,54019,WritableFile,4,leveldb.WritableFile,,db\version_set.hpp,class WritableFile,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2858,54036,Version,4,leveldb.Version,,db\version_set.hpp,"class Version {
 public:
  // Append to *iters a sequence of iterators that will
  // yield the contents of this Version when merged together.
  // REQUIRES: This version has been saved (see VersionSet::SaveTo)
  void AddIterators(const ReadOptions&, std::vector<Iterator*>* iters);

  // Lookup the value for key.  If found, store it in *val and
  // return OK.  Else return a non-OK status.  Fills *stats.
  // REQUIRES: lock is not held
  struct GetStats {
    FileMetaData* seek_file;
    int seek_file_level;
  };
  Status Get(const ReadOptions&, const LookupKey& key, std::string* val,
             GetStats* stats);

  // Adds ""stats"" into the current state.  Returns true if a new
  // compaction may need to be triggered, false otherwise.
  // REQUIRES: lock is held
  bool UpdateStats(const GetStats& stats);

  // Record a sample of bytes read at the specified internal key.
  // Samples are taken approximately once every config::kReadBytesPeriod
  // bytes.  Returns true if a new com...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2859,54043,GetStats,4,leveldb.Version.GetStats,,db\version_set.hpp,"struct GetStats {
    FileMetaData* seek_file;
    int seek_file_level;
  }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2860,54109,Compaction,4,leveldb.Version.Compaction,,db\version_set.hpp,friend class Compaction,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2861,54110,VersionSet,4,leveldb.Version.VersionSet,,db\version_set.hpp,friend class VersionSet,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2862,54111,LevelFileNumIterator,4,leveldb.Version.LevelFileNumIterator,,db\version_set.hpp,class LevelFileNumIterator,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2863,54162,VersionSet,4,leveldb.VersionSet,,db\version_set.hpp,"class VersionSet {
 public:
  VersionSet(const std::string& dbname,
             const Options* options,
             TableCache* table_cache,
             const InternalKeyComparator*);
  ~VersionSet();

  // Apply *edit to the current version to form a new descriptor that
  // is both saved to persistent state and installed as the new
  // current version.  Will release *mu while actually writing to the file.
  // REQUIRES: *mu is held on entry.
  // REQUIRES: no other thread concurrently calls LogAndApply()
  Status LogAndApply(VersionEdit* edit, port::Mutex* mu)
      EXCLUSIVE_LOCKS_REQUIRED(mu);

  // Recover the last saved descriptor from persistent storage.
  Status Recover(bool *save_manifest);

  // Return the current version.
  Version* current() const { return current_; }

  // Return the current manifest file number
  uint64_t ManifestFileNumber() const { return manifest_file_number_; }

  // Allocate and return a new file number
  uint64_t NewFileNumber() { return next...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2864,54316,LevelSummaryStorage,4,leveldb.VersionSet.LevelSummaryStorage,,db\version_set.hpp,"struct LevelSummaryStorage {
    char buffer[100];
  }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2865,54329,Builder,4,leveldb.VersionSet.Builder,,db\version_set.hpp,class Builder,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2866,54330,Compaction,4,leveldb.VersionSet.Compaction,,db\version_set.hpp,friend class Compaction,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2867,54331,Version,4,leveldb.VersionSet.Version,,db\version_set.hpp,friend class Version,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2868,54406,Compaction,4,leveldb.Compaction,,db\version_set.hpp,"class Compaction {
 public:
  ~Compaction();

  // Return the level that is being compacted.  Inputs from ""level""
  // and ""level+1"" will be merged to produce a set of ""level+1"" files.
  int level() const { return level_; }

  // Return the object that holds the edits to the descriptor done
  // by this compaction.
  VersionEdit* edit() { return &edit_; }

  // ""which"" must be either 0 or 1
  int num_input_files(int which) const { return inputs_[which].size(); }

  // Return the ith input file at ""level()+which"" (""which"" must be 0 or 1).
  FileMetaData* input(int which, int i) const { return inputs_[which][i]; }

  // Maximum size of files to build during this compaction.
  uint64_t MaxOutputFileSize() const { return max_output_file_size_; }

  // Is this a trivial compaction that can be implemented by just
  // moving a single input file to the next level (no merging or splitting)
  bool IsTrivialMove() const;

  // Add all inputs to this compaction as delete operations to *edit.
 ...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2869,54477,Version,4,leveldb.Compaction.Version,,db\version_set.hpp,friend class Version,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2870,54478,VersionSet,4,leveldb.Compaction.VersionSet,,db\version_set.hpp,friend class VersionSet,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2871,54519,FindFileTest,4,leveldb.FindFileTest,,db\version_set_test.cc,"class FindFileTest {
 public:
  std::vector<FileMetaData*> files_;
  bool disjoint_sorted_files_;

  FindFileTest() : disjoint_sorted_files_(true) { }

  ~FindFileTest() {
    for (int i = 0; i < files_.size(); i++) {
      delete files_[i];
    }
  }

  void Add(const char* smallest, const char* largest,
           SequenceNumber smallest_seq = 100,
           SequenceNumber largest_seq = 100) {
    FileMetaData* f = new FileMetaData;
    f->number = files_.size() + 1;
    f->smallest = InternalKey(smallest, smallest_seq, kTypeValue);
    f->largest = InternalKey(largest, largest_seq, kTypeValue);
    files_.push_back(f);
  }

  int Find(const char* key) {
    InternalKey target(key, 100, kTypeValue);
    InternalKeyComparator cmp(BytewiseComparator());
    return FindFile(cmp, files_, target.Encode());
  }

  bool Overlaps(const char* smallest, const char* largest) {
    InternalKeyComparator cmp(BytewiseComparator());
    Slice s(smallest != NULL ? smallest : """");
    Slice l(lar...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2872,54658,_Test_Empty,4,leveldb._Test_Empty,,db\version_set_test.cc,_Test_Empty,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2873,54782,_Test_Single,4,leveldb._Test_Single,,db\version_set_test.cc,_Test_Single,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2874,55242,_Test_Multiple,4,leveldb._Test_Multiple,,db\version_set_test.cc,_Test_Multiple,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2875,55818,_Test_MultipleNullBoundaries,4,leveldb._Test_MultipleNullBoundaries,,db\version_set_test.cc,_Test_MultipleNullBoundaries,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2876,56086,_Test_OverlapSequenceChecks,4,leveldb._Test_OverlapSequenceChecks,,db\version_set_test.cc,_Test_OverlapSequenceChecks,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2877,56211,_Test_OverlappingFiles,4,leveldb._Test_OverlappingFiles,,db\version_set_test.cc,_Test_OverlappingFiles,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2878,56777,MemTableInserter,4,leveldb.anonymous_namespace_1.MemTableInserter,,db\write_batch.cc,"class MemTableInserter : public WriteBatch::Handler {
 public:
  SequenceNumber sequence_;
  MemTable* mem_;

  virtual void Put(const Slice& key, const Slice& value) {
    mem_->Add(sequence_, kTypeValue, key, value);
    sequence_++;
  }
  virtual void Delete(const Slice& key) {
    mem_->Add(sequence_, kTypeDeletion, key, Slice());
    sequence_++;
  }
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2879,56920,MemTable,4,leveldb.MemTable,,db\write_batch_internal.hpp,class MemTable,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2880,56921,WriteBatchInternal,4,leveldb.WriteBatchInternal,,db\write_batch_internal.hpp,"class WriteBatchInternal {
 public:
  // Return the number of entries in the batch.
  static int Count(const WriteBatch* batch);

  // Set the count for the number of entries in the batch.
  static void SetCount(WriteBatch* batch, int n);

  // Return the sequence number for the start of this batch.
  static SequenceNumber Sequence(const WriteBatch* batch);

  // Store the specified number as the sequence number for the start of
  // this batch.
  static void SetSequence(WriteBatch* batch, SequenceNumber seq);

  static Slice Contents(const WriteBatch* batch) {
    return Slice(batch->rep_);
  }

  static size_t ByteSize(const WriteBatch* batch) {
    return batch->rep_.size();
  }

  static void SetContents(WriteBatch* batch, const Slice& contents);

  static Status InsertInto(const WriteBatch* batch, MemTable* memtable);

  static void Append(WriteBatch* dst, const WriteBatch* src);
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2881,57198,WriteBatchTest,4,leveldb.WriteBatchTest,,db\write_batch_test.cc,class WriteBatchTest { },-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2882,57199,_Test_Empty,4,leveldb._Test_Empty,,db\write_batch_test.cc,_Test_Empty,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2883,57281,_Test_Multiple,4,leveldb._Test_Multiple,,db\write_batch_test.cc,_Test_Multiple,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2884,57418,_Test_Corruption,4,leveldb._Test_Corruption,,db\write_batch_test.cc,_Test_Corruption,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2885,57519,_Test_Append,4,leveldb._Test_Append,,db\write_batch_test.cc,_Test_Append,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2886,57848,RandomGenerator,4,leveldb.anonymous_namespace_1.RandomGenerator,,doc\bench\db_bench_sqlite3.cc,"class RandomGenerator {
 private:
  std::string data_;
  int pos_;

 public:
  RandomGenerator() {
    // We use a limited amount of data over and over again and ensure
    // that it is larger than the compression window (32KB), and also
    // large enough to serve all typical value sizes we want to write.
    Random rnd(301);
    std::string piece;
    while (data_.size() < 1048576) {
      // Add a short fragment that is as compressible as specified
      // by FLAGS_compression_ratio.
      test::CompressibleString(&rnd, FLAGS_compression_ratio, 100, &piece);
      data_.append(piece);
    }
    pos_ = 0;
  }

  Slice Generate(int len) {
    if (pos_ + len > data_.size()) {
      pos_ = 0;
      assert(len < data_.size());
    }
    pos_ += len;
    return Slice(data_.data() + pos_ - len, len);
  }
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2887,57980,Benchmark,4,leveldb.Benchmark,,doc\bench\db_bench_sqlite3.cc,"class Benchmark {
 private:
  sqlite3* db_;
  int db_num_;
  int num_;
  int reads_;
  double start_;
  double last_op_finish_;
  int64_t bytes_;
  std::string message_;
  Histogram hist_;
  RandomGenerator gen_;
  Random rand_;

  // State kept for progress messages
  int done_;
  int next_report_;     // When to report next

  void PrintHeader() {
    const int kKeySize = 16;
    PrintEnvironment();
    fprintf(stdout, ""Keys:       %d bytes each\n"", kKeySize);
    fprintf(stdout, ""Values:     %d bytes each\n"", FLAGS_value_size);
    fprintf(stdout, ""Entries:    %d\n"", num_);
    fprintf(stdout, ""RawSize:    %.1f MB (estimated)\n"",
            ((static_cast<int64_t>(kKeySize + FLAGS_value_size) * num_)
             / 1048576.0));
    PrintWarnings();
    fprintf(stdout, ""------------------------------------------------\n"");
  }

  void PrintWarnings() {
#if defined(__GNUC__) && !defined(__OPTIMIZE__)
    fprintf(stdout,
            ""WARNING: Optimization is disabled: benchmarks unn...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2888,58311,Order,4,leveldb.Benchmark.Order,,doc\bench\db_bench_sqlite3.cc,"enum Order {
    SEQUENTIAL,
    RANDOM
  }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2889,58314,DBState,4,leveldb.Benchmark.DBState,,doc\bench\db_bench_sqlite3.cc,"enum DBState {
    FRESH,
    EXISTING
  }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2890,59863,RandomGenerator,4,leveldb.anonymous_namespace_1.RandomGenerator,,doc\bench\db_bench_tree_db.cc,"class RandomGenerator {
 private:
  std::string data_;
  int pos_;

 public:
  RandomGenerator() {
    // We use a limited amount of data over and over again and ensure
    // that it is larger than the compression window (32KB), and also
    // large enough to serve all typical value sizes we want to write.
    Random rnd(301);
    std::string piece;
    while (data_.size() < 1048576) {
      // Add a short fragment that is as compressible as specified
      // by FLAGS_compression_ratio.
      test::CompressibleString(&rnd, FLAGS_compression_ratio, 100, &piece);
      data_.append(piece);
    }
    pos_ = 0;
  }

  Slice Generate(int len) {
    if (pos_ + len > data_.size()) {
      pos_ = 0;
      assert(len < data_.size());
    }
    pos_ += len;
    return Slice(data_.data() + pos_ - len, len);
  }
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2891,59995,Benchmark,4,leveldb.Benchmark,,doc\bench\db_bench_tree_db.cc,"class Benchmark {
 private:
  kyotocabinet::TreeDB* db_;
  int db_num_;
  int num_;
  int reads_;
  double start_;
  double last_op_finish_;
  int64_t bytes_;
  std::string message_;
  Histogram hist_;
  RandomGenerator gen_;
  Random rand_;
  kyotocabinet::LZOCompressor<kyotocabinet::LZO::RAW> comp_;

  // State kept for progress messages
  int done_;
  int next_report_;     // When to report next

  void PrintHeader() {
    const int kKeySize = 16;
    PrintEnvironment();
    fprintf(stdout, ""Keys:       %d bytes each\n"", kKeySize);
    fprintf(stdout, ""Values:     %d bytes each (%d bytes after compression)\n"",
            FLAGS_value_size,
            static_cast<int>(FLAGS_value_size * FLAGS_compression_ratio + 0.5));
    fprintf(stdout, ""Entries:    %d\n"", num_);
    fprintf(stdout, ""RawSize:    %.1f MB (estimated)\n"",
            ((static_cast<int64_t>(kKeySize + FLAGS_value_size) * num_)
             / 1048576.0));
    fprintf(stdout, ""FileSize:   %.1f MB (estimated)\n"",
    ...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2892,60354,Order,4,leveldb.Benchmark.Order,,doc\bench\db_bench_tree_db.cc,"enum Order {
    SEQUENTIAL,
    RANDOM
  }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2893,60357,DBState,4,leveldb.Benchmark.DBState,,doc\bench\db_bench_tree_db.cc,"enum DBState {
    FRESH,
    EXISTING
  }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2894,61364,FileState,4,leveldb.anonymous_namespace_1.FileState,,helpers\memenv\memenv.cc,"class FileState {
 public:
  // FileStates are reference counted. The initial reference count is zero
  // and the caller must call Ref() at least once.
  FileState() : refs_(0), size_(0) {}

  // Increase the reference count.
  void Ref() {
    MutexLock lock(&refs_mutex_);
    ++refs_;
  }

  // Decrease the reference count. Delete if this is the last reference.
  void Unref() {
    bool do_delete = false;

    {
      MutexLock lock(&refs_mutex_);
      --refs_;
      assert(refs_ >= 0);
      if (refs_ <= 0) {
        do_delete = true;
      }
    }

    if (do_delete) {
      delete this;
    }
  }

  uint64_t Size() const { return size_; }

  Status Read(uint64_t offset, size_t n, Slice* result, char* scratch) const {
    if (offset > size_) {
      return Status::IOError(""Offset greater than file size."");
    }
    const uint64_t available = size_ - offset;
    if (n > available) {
      n = static_cast<size_t>(available);
    }
    if (n == 0) {
      *result = Slice();
    ...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2895,61687,anonymous_enum_12,4,leveldb.anonymous_namespace_11.FileState.anonymous_enum_12,,helpers\memenv\memenv.cc,enum { kBlockSize = 8 * 1024 },-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2896,61698,SequentialFileImpl,4,leveldb.anonymous_namespace_13.SequentialFileImpl,,helpers\memenv\memenv.cc,"class SequentialFileImpl : public SequentialFile {
 public:
  explicit SequentialFileImpl(FileState* file) : file_(file), pos_(0) {
    file_->Ref();
  }

  ~SequentialFileImpl() {
    file_->Unref();
  }

  virtual Status Read(size_t n, Slice* result, char* scratch) {
    Status s = file_->Read(pos_, n, result, scratch);
    if (s.ok()) {
      pos_ += result->size();
    }
    return s;
  }

  virtual Status Skip(uint64_t n) {
    if (pos_ > file_->Size()) {
      return Status::IOError(""pos_ > file_->Size()"");
    }
    const uint64_t available = file_->Size() - pos_;
    if (n > available) {
      n = available;
    }
    pos_ += n;
    return Status::OK();
  }

 private:
  FileState* file_;
  uint64_t pos_;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2897,61794,RandomAccessFileImpl,4,leveldb.anonymous_namespace_18.RandomAccessFileImpl,,helpers\memenv\memenv.cc,"class RandomAccessFileImpl : public RandomAccessFile {
 public:
  explicit RandomAccessFileImpl(FileState* file) : file_(file) {
    file_->Ref();
  }

  ~RandomAccessFileImpl() {
    file_->Unref();
  }

  virtual Status Read(uint64_t offset, size_t n, Slice* result,
                      char* scratch) const {
    return file_->Read(offset, n, result, scratch);
  }

 private:
  FileState* file_;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2898,61830,WritableFileImpl,4,leveldb.anonymous_namespace_22.WritableFileImpl,,helpers\memenv\memenv.cc,"class WritableFileImpl : public WritableFile {
 public:
  WritableFileImpl(FileState* file) : file_(file) {
    file_->Ref();
  }

  ~WritableFileImpl() {
    file_->Unref();
  }

  virtual Status Append(const Slice& data) {
    return file_->Append(data);
  }

  virtual Status Close() { return Status::OK(); }
  virtual Status Flush() { return Status::OK(); }
  virtual Status Sync() { return Status::OK(); }

 private:
  FileState* file_;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2899,61887,NoOpLogger,4,leveldb.anonymous_namespace_29.NoOpLogger,,helpers\memenv\memenv.cc,"class NoOpLogger : public Logger {
 public:
  virtual void Logv(const char* format, va_list ap) { }
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2900,61894,InMemoryEnv,4,leveldb.anonymous_namespace_31.InMemoryEnv,,helpers\memenv\memenv.cc,"class InMemoryEnv : public EnvWrapper {
 public:
  explicit InMemoryEnv(Env* base_env) : EnvWrapper(base_env) { }

  virtual ~InMemoryEnv() {
    for (FileSystem::iterator i = file_map_.begin(); i != file_map_.end(); ++i){
      i->second->Unref();
    }
  }

  // Partial implementation of the Env interface.
  virtual Status NewSequentialFile(const std::string& fname,
                                   SequentialFile** result) {
    MutexLock lock(&mutex_);
    if (file_map_.find(fname) == file_map_.end()) {
      *result = NULL;
      return Status::IOError(fname, ""File not found"");
    }

    *result = new SequentialFileImpl(file_map_[fname]);
    return Status::OK();
  }

  virtual Status NewRandomAccessFile(const std::string& fname,
                                     RandomAccessFile** result) {
    MutexLock lock(&mutex_);
    if (file_map_.find(fname) == file_map_.end()) {
      *result = NULL;
      return Status::IOError(fname, ""File not found"");
    }

    *result = new R...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2901,62455,FileSystem,4,FileSystem,,helpers\memenv\memenv.cc,"typedef std::map<std::string, FileState*> FileSystem;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2902,62473,Env,4,leveldb.Env,,helpers\memenv\memenv.hpp,class Env,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2903,62499,MemEnvTest,4,leveldb.MemEnvTest,,helpers\memenv\memenv_test.cc,"class MemEnvTest {
 public:
  Env* env_;

  MemEnvTest()
      : env_(NewMemEnv(Env::Default())) {
  }
  ~MemEnvTest() {
    delete env_;
  }
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2904,62511,_Test_Basics,4,leveldb._Test_Basics,,helpers\memenv\memenv_test.cc,_Test_Basics,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2905,63385,_Test_ReadWrite,4,leveldb._Test_ReadWrite,,helpers\memenv\memenv_test.cc,_Test_ReadWrite,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2906,63947,_Test_Locks,4,leveldb._Test_Locks,,helpers\memenv\memenv_test.cc,_Test_Locks,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2907,64024,_Test_Misc,4,leveldb._Test_Misc,,helpers\memenv\memenv_test.cc,_Test_Misc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2908,64193,_Test_LargeWrite,4,leveldb._Test_LargeWrite,,helpers\memenv\memenv_test.cc,_Test_LargeWrite,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2909,64467,_Test_DBTest,4,leveldb._Test_DBTest,,helpers\memenv\memenv_test.cc,_Test_DBTest,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2910,64872,leveldb_t,4,leveldb_t,,include\leveldb\c.hpp,typedef struct leveldb_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2911,64873,leveldb_t,4,leveldb_t,,include\leveldb\c.hpp,typedef struct leveldb_t               leveldb_t;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2912,64874,leveldb_cache_t,4,leveldb_cache_t,,include\leveldb\c.hpp,typedef struct leveldb_cache_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2913,64875,leveldb_cache_t,4,leveldb_cache_t,,include\leveldb\c.hpp,typedef struct leveldb_cache_t         leveldb_cache_t;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2914,64876,leveldb_comparator_t,4,leveldb_comparator_t,,include\leveldb\c.hpp,typedef struct leveldb_comparator_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2915,64877,leveldb_comparator_t,4,leveldb_comparator_t,,include\leveldb\c.hpp,typedef struct leveldb_comparator_t    leveldb_comparator_t;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2916,64878,leveldb_env_t,4,leveldb_env_t,,include\leveldb\c.hpp,typedef struct leveldb_env_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2917,64879,leveldb_env_t,4,leveldb_env_t,,include\leveldb\c.hpp,typedef struct leveldb_env_t           leveldb_env_t;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2918,64880,leveldb_filelock_t,4,leveldb_filelock_t,,include\leveldb\c.hpp,typedef struct leveldb_filelock_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2919,64881,leveldb_filelock_t,4,leveldb_filelock_t,,include\leveldb\c.hpp,typedef struct leveldb_filelock_t      leveldb_filelock_t;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2920,64882,leveldb_filterpolicy_t,4,leveldb_filterpolicy_t,,include\leveldb\c.hpp,typedef struct leveldb_filterpolicy_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2921,64883,leveldb_filterpolicy_t,4,leveldb_filterpolicy_t,,include\leveldb\c.hpp,typedef struct leveldb_filterpolicy_t  leveldb_filterpolicy_t;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2922,64884,leveldb_iterator_t,4,leveldb_iterator_t,,include\leveldb\c.hpp,typedef struct leveldb_iterator_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2923,64885,leveldb_iterator_t,4,leveldb_iterator_t,,include\leveldb\c.hpp,typedef struct leveldb_iterator_t      leveldb_iterator_t;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2924,64886,leveldb_logger_t,4,leveldb_logger_t,,include\leveldb\c.hpp,typedef struct leveldb_logger_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2925,64887,leveldb_logger_t,4,leveldb_logger_t,,include\leveldb\c.hpp,typedef struct leveldb_logger_t        leveldb_logger_t;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2926,64888,leveldb_options_t,4,leveldb_options_t,,include\leveldb\c.hpp,typedef struct leveldb_options_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2927,64889,leveldb_options_t,4,leveldb_options_t,,include\leveldb\c.hpp,typedef struct leveldb_options_t       leveldb_options_t;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2928,64890,leveldb_randomfile_t,4,leveldb_randomfile_t,,include\leveldb\c.hpp,typedef struct leveldb_randomfile_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2929,64891,leveldb_randomfile_t,4,leveldb_randomfile_t,,include\leveldb\c.hpp,typedef struct leveldb_randomfile_t    leveldb_randomfile_t;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2930,64892,leveldb_readoptions_t,4,leveldb_readoptions_t,,include\leveldb\c.hpp,typedef struct leveldb_readoptions_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2931,64893,leveldb_readoptions_t,4,leveldb_readoptions_t,,include\leveldb\c.hpp,typedef struct leveldb_readoptions_t   leveldb_readoptions_t;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2932,64894,leveldb_seqfile_t,4,leveldb_seqfile_t,,include\leveldb\c.hpp,typedef struct leveldb_seqfile_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2933,64895,leveldb_seqfile_t,4,leveldb_seqfile_t,,include\leveldb\c.hpp,typedef struct leveldb_seqfile_t       leveldb_seqfile_t;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2934,64896,leveldb_snapshot_t,4,leveldb_snapshot_t,,include\leveldb\c.hpp,typedef struct leveldb_snapshot_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2935,64897,leveldb_snapshot_t,4,leveldb_snapshot_t,,include\leveldb\c.hpp,typedef struct leveldb_snapshot_t      leveldb_snapshot_t;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2936,64898,leveldb_writablefile_t,4,leveldb_writablefile_t,,include\leveldb\c.hpp,typedef struct leveldb_writablefile_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2937,64899,leveldb_writablefile_t,4,leveldb_writablefile_t,,include\leveldb\c.hpp,typedef struct leveldb_writablefile_t  leveldb_writablefile_t;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2938,64900,leveldb_writebatch_t,4,leveldb_writebatch_t,,include\leveldb\c.hpp,typedef struct leveldb_writebatch_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2939,64901,leveldb_writebatch_t,4,leveldb_writebatch_t,,include\leveldb\c.hpp,typedef struct leveldb_writebatch_t    leveldb_writebatch_t;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2940,64902,leveldb_writeoptions_t,4,leveldb_writeoptions_t,,include\leveldb\c.hpp,typedef struct leveldb_writeoptions_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2941,64903,leveldb_writeoptions_t,4,leveldb_writeoptions_t,,include\leveldb\c.hpp,typedef struct leveldb_writeoptions_t  leveldb_writeoptions_t;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2942,65185,anonymous_enum_0,4,anonymous_enum_0,,include\leveldb\c.hpp,"enum {
  leveldb_no_compression = 0,
  leveldb_snappy_compression = 1
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2943,65320,Cache,4,leveldb.Cache,,include\leveldb\cache.hpp,class Cache,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2944,65326,Cache,4,leveldb.Cache,,include\leveldb\cache.hpp,"class Cache {
 public:
  Cache() { }

  // Destroys all existing entries by calling the ""deleter""
  // function that was passed to the constructor.
  virtual ~Cache();

  // Opaque handle to an entry stored in the cache.
  struct Handle { };

  // Insert a mapping from key->value into the cache and assign it
  // the specified charge against the total cache capacity.
  //
  // Returns a handle that corresponds to the mapping.  The caller
  // must call this->Release(handle) when the returned mapping is no
  // longer needed.
  //
  // When the inserted entry is no longer needed, the key and
  // value will be passed to ""deleter"".
  virtual Handle* Insert(const Slice& key, void* value, size_t charge,
                         void (*deleter)(const Slice& key, void* value)) = 0;

  // If the cache has no mapping for ""key"", returns NULL.
  //
  // Else return a handle that corresponds to the mapping.  The caller
  // must call this->Release(handle) when the returned mapping is no
  // l...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2945,65335,Handle,4,leveldb.Cache.Handle,,include\leveldb\cache.hpp,struct Handle { },-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2946,65391,Rep,4,leveldb.Cache.Rep,,include\leveldb\cache.hpp,struct Rep,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2947,65411,Slice,4,leveldb.Slice,,include\leveldb\comparator.hpp,class Slice,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2948,65412,Comparator,4,leveldb.Comparator,,include\leveldb\comparator.hpp,"class Comparator {
 public:
  virtual ~Comparator();

  // Three-way comparison.  Returns value:
  //   < 0 iff ""a"" < ""b"",
  //   == 0 iff ""a"" == ""b"",
  //   > 0 iff ""a"" > ""b""
  virtual int Compare(const Slice& a, const Slice& b) const = 0;

  // The name of the comparator.  Used to check for comparator
  // mismatches (i.e., a DB created with one comparator is
  // accessed using a different comparator.
  //
  // The client of this package should switch to a new name whenever
  // the comparator implementation changes in a way that will cause
  // the relative ordering of any two keys to change.
  //
  // Names starting with ""leveldb."" are reserved and should not be used
  // by any clients of this package.
  virtual const char* Name() const = 0;

  // Advanced functions: these are used to reduce the space requirements
  // for internal data structures like index blocks.

  // If *start < limit, changes *start to a short string in [start,limit).
  // Simple comparator implementatio...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2949,65464,Options,4,leveldb.Options,,include\leveldb\db.hpp,struct Options,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2950,65465,ReadOptions,4,leveldb.ReadOptions,,include\leveldb\db.hpp,struct ReadOptions,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2951,65466,WriteOptions,4,leveldb.WriteOptions,,include\leveldb\db.hpp,struct WriteOptions,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2952,65467,WriteBatch,4,leveldb.WriteBatch,,include\leveldb\db.hpp,class WriteBatch,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2953,65468,Snapshot,4,leveldb.Snapshot,,include\leveldb\db.hpp,"class Snapshot {
 protected:
  virtual ~Snapshot();
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2954,65473,Range,4,leveldb.Range,,include\leveldb\db.hpp,"struct Range {
  Slice start;          // Included in the range
  Slice limit;          // Not included in the range

  Range() { }
  Range(const Slice& s, const Slice& l) : start(s), limit(l) { }
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2955,65486,DB,4,leveldb.DB,,include\leveldb\db.hpp,"class DB {
 public:
  // Open the database with the specified ""name"".
  // Stores a pointer to a heap-allocated database in *dbptr and returns
  // OK on success.
  // Stores NULL in *dbptr and returns a non-OK status on error.
  // Caller should delete *dbptr when it is no longer needed.
  static Status Open(const Options& options,
                     const std::string& name,
                     DB** dbptr);

  DB() { }
  virtual ~DB();

  // Set the database entry for ""key"" to ""value"".  Returns OK on success,
  // and a non-OK status on error.
  // Note: consider setting options.sync = true.
  virtual Status Put(const WriteOptions& options,
                     const Slice& key,
                     const Slice& value) = 0;

  // Remove the database entry (if any) for ""key"".  Returns OK on
  // success, and a non-OK status on error.  It is not an error if ""key""
  // did not exist in the database.
  // Note: consider setting options.sync = true.
  virtual Status Delete(const Writ...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2956,65618,FileLock,4,leveldb.FileLock,,include\leveldb\env.hpp,class FileLock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2957,65619,Logger,4,leveldb.Logger,,include\leveldb\env.hpp,class Logger,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2958,65620,RandomAccessFile,4,leveldb.RandomAccessFile,,include\leveldb\env.hpp,class RandomAccessFile,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2959,65621,SequentialFile,4,leveldb.SequentialFile,,include\leveldb\env.hpp,class SequentialFile,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2960,65622,Slice,4,leveldb.Slice,,include\leveldb\env.hpp,class Slice,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2961,65623,WritableFile,4,leveldb.WritableFile,,include\leveldb\env.hpp,class WritableFile,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2962,65624,Env,4,leveldb.Env,,include\leveldb\env.hpp,"class Env {
 public:
  Env() { }
  virtual ~Env();

  // Return a default environment suitable for the current operating
  // system.  Sophisticated users may wish to provide their own Env
  // implementation instead of relying on this default environment.
  //
  // The result of Default() belongs to leveldb and must never be deleted.
  static Env* Default();

  // Create a brand new sequentially-readable file with the specified name.
  // On success, stores a pointer to the new file in *result and returns OK.
  // On failure stores NULL in *result and returns non-OK.  If the file does
  // not exist, returns a non-OK status.
  //
  // The returned file will only be accessed by one thread at a time.
  virtual Status NewSequentialFile(const std::string& fname,
                                   SequentialFile** result) = 0;

  // Create a brand new random access read-only file with the
  // specified name.  On success, stores a pointer to the new file in
  // *result and returns OK. ...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2963,65752,SequentialFile,4,leveldb.SequentialFile,,include\leveldb\env.hpp,"class SequentialFile {
 public:
  SequentialFile() { }
  virtual ~SequentialFile();

  // Read up to ""n"" bytes from the file.  ""scratch[0..n-1]"" may be
  // written by this routine.  Sets ""*result"" to the data that was
  // read (including if fewer than ""n"" bytes were successfully read).
  // May set ""*result"" to point at data in ""scratch[0..n-1]"", so
  // ""scratch[0..n-1]"" must be live when ""*result"" is used.
  // If an error was encountered, returns a non-OK status.
  //
  // REQUIRES: External synchronization
  virtual Status Read(size_t n, Slice* result, char* scratch) = 0;

  // Skip ""n"" bytes from the file. This is guaranteed to be no
  // slower that reading the same data, but may be faster.
  //
  // If end of file is reached, skipping will stop at the end of the
  // file, and Skip will return OK.
  //
  // REQUIRES: External synchronization
  virtual Status Skip(uint64_t n) = 0;

 private:
  // No copying allowed
  SequentialFile(const SequentialFile&);
  void operator=(co...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2964,65783,RandomAccessFile,4,leveldb.RandomAccessFile,,include\leveldb\env.hpp,"class RandomAccessFile {
 public:
  RandomAccessFile() { }
  virtual ~RandomAccessFile();

  // Read up to ""n"" bytes from the file starting at ""offset"".
  // ""scratch[0..n-1]"" may be written by this routine.  Sets ""*result""
  // to the data that was read (including if fewer than ""n"" bytes were
  // successfully read).  May set ""*result"" to point at data in
  // ""scratch[0..n-1]"", so ""scratch[0..n-1]"" must be live when
  // ""*result"" is used.  If an error was encountered, returns a non-OK
  // status.
  //
  // Safe for concurrent use by multiple threads.
  virtual Status Read(uint64_t offset, size_t n, Slice* result,
                      char* scratch) const = 0;

 private:
  // No copying allowed
  RandomAccessFile(const RandomAccessFile&);
  void operator=(const RandomAccessFile&);
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2965,65810,WritableFile,4,leveldb.WritableFile,,include\leveldb\env.hpp,"class WritableFile {
 public:
  WritableFile() { }
  virtual ~WritableFile();

  virtual Status Append(const Slice& data) = 0;
  virtual Status Close() = 0;
  virtual Status Flush() = 0;
  virtual Status Sync() = 0;

 private:
  // No copying allowed
  WritableFile(const WritableFile&);
  void operator=(const WritableFile&);
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2966,65846,Logger,4,leveldb.Logger,,include\leveldb\env.hpp,"class Logger {
 public:
  Logger() { }
  virtual ~Logger();

  // Write an entry to the log file with the specified format.
  virtual void Logv(const char* format, va_list ap) = 0;

 private:
  // No copying allowed
  Logger(const Logger&);
  void operator=(const Logger&);
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2967,65871,FileLock,4,leveldb.FileLock,,include\leveldb\env.hpp,"class FileLock {
 public:
  FileLock() { }
  virtual ~FileLock();
 private:
  // No copying allowed
  FileLock(const FileLock&);
  void operator=(const FileLock&);
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2968,65910,EnvWrapper,4,leveldb.EnvWrapper,,include\leveldb\env.hpp,"class EnvWrapper : public Env {
 public:
  // Initialize an EnvWrapper that delegates all calls to *t
  explicit EnvWrapper(Env* t) : target_(t) { }
  virtual ~EnvWrapper();

  // Return the target to which this Env forwards all calls
  Env* target() const { return target_; }

  // The following text is boilerplate that forwards all methods to target()
  Status NewSequentialFile(const std::string& f, SequentialFile** r) {
    return target_->NewSequentialFile(f, r);
  }
  Status NewRandomAccessFile(const std::string& f, RandomAccessFile** r) {
    return target_->NewRandomAccessFile(f, r);
  }
  Status NewWritableFile(const std::string& f, WritableFile** r) {
    return target_->NewWritableFile(f, r);
  }
  Status NewAppendableFile(const std::string& f, WritableFile** r) {
    return target_->NewAppendableFile(f, r);
  }
  bool FileExists(const std::string& f) { return target_->FileExists(f); }
  Status GetChildren(const std::string& dir, std::vector<std::string>* r) {
    return ta...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2969,66163,Slice,4,leveldb.Slice,,include\leveldb\filter_policy.hpp,class Slice,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2970,66164,FilterPolicy,4,leveldb.FilterPolicy,,include\leveldb\filter_policy.hpp,"class FilterPolicy {
 public:
  virtual ~FilterPolicy();

  // Return the name of this policy.  Note that if the filter encoding
  // changes in an incompatible way, the name returned by this method
  // must be changed.  Otherwise, old incompatible filters may be
  // passed to methods of this type.
  virtual const char* Name() const = 0;

  // keys[0,n-1] contains a list of keys (potentially with duplicates)
  // that are ordered according to the user supplied comparator.
  // Append a filter that summarizes keys[0,n-1] to *dst.
  //
  // Warning: do not change the initial contents of *dst.  Instead,
  // append the newly constructed filter to *dst.
  virtual void CreateFilter(const Slice* keys, int n, std::string* dst)
      const = 0;

  // ""filter"" contains the data appended by a preceding call to
  // CreateFilter() on this class.  This method must return true if
  // the key was in the list of keys passed to CreateFilter().
  // This method may return true or false if the key...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2971,66201,Iterator,4,leveldb.Iterator,,include\leveldb\iterator.hpp,"class Iterator {
 public:
  Iterator();
  virtual ~Iterator();

  // An iterator is either positioned at a key/value pair, or
  // not valid.  This method returns true iff the iterator is valid.
  virtual bool Valid() const = 0;

  // Position at the first key in the source.  The iterator is Valid()
  // after this call iff the source is not empty.
  virtual void SeekToFirst() = 0;

  // Position at the last key in the source.  The iterator is
  // Valid() after this call iff the source is not empty.
  virtual void SeekToLast() = 0;

  // Position at the first key in the source that is at or past target.
  // The iterator is Valid() after this call iff the source contains
  // an entry that comes at or past target.
  virtual void Seek(const Slice& target) = 0;

  // Moves to the next entry in the source.  After this call, Valid() is
  // true iff the iterator was not positioned at the last entry in the source.
  // REQUIRES: Valid()
  virtual void Next() = 0;

  // Moves to the prev...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2972,66260,Cleanup,4,leveldb.Iterator.Cleanup,,include\leveldb\iterator.hpp,"struct Cleanup {
    CleanupFunction function;
    void* arg1;
    void* arg2;
    Cleanup* next;
  }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2973,66293,Cache,4,leveldb.Cache,,include\leveldb\options.hpp,class Cache,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2974,66294,Comparator,4,leveldb.Comparator,,include\leveldb\options.hpp,class Comparator,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2975,66295,Env,4,leveldb.Env,,include\leveldb\options.hpp,class Env,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2976,66296,FilterPolicy,4,leveldb.FilterPolicy,,include\leveldb\options.hpp,class FilterPolicy,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2977,66297,Logger,4,leveldb.Logger,,include\leveldb\options.hpp,class Logger,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2978,66298,Snapshot,4,leveldb.Snapshot,,include\leveldb\options.hpp,class Snapshot,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2979,66299,CompressionType,4,leveldb.CompressionType,,include\leveldb\options.hpp,"enum CompressionType {
  // NOTE: do not change the values of existing entries, as these are
  // part of the persistent format on disk.
  kNoCompression     = 0x0,
  kSnappyCompression = 0x1
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2980,66312,Options,4,leveldb.Options,,include\leveldb\options.hpp,"struct Options {
  // -------------------
  // Parameters that affect behavior

  // Comparator used to define the order of keys in the table.
  // Default: a comparator that uses lexicographic byte-wise ordering
  //
  // REQUIRES: The client must ensure that the comparator supplied
  // here has the same name and orders keys *exactly* the same as the
  // comparator provided to previous open calls on the same DB.
  const Comparator* comparator;

  // If true, the database will be created if it is missing.
  // Default: false
  bool create_if_missing;

  // If true, an error is raised if the database already exists.
  // Default: false
  bool error_if_exists;

  // If true, the implementation will do aggressive checking of the
  // data it is processing and will stop early if it detects any
  // errors.  This may have unforeseen ramifications: for example, a
  // corruption of one DB entry may cause a large number of entries to
  // become unreadable or for the entire DB to become ...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2981,66332,ReadOptions,4,leveldb.ReadOptions,,include\leveldb\options.hpp,"struct ReadOptions {
  // If true, all data read from underlying storage will be
  // verified against corresponding checksums.
  // Default: false
  bool verify_checksums;

  // Should the data read for this iteration be cached in memory?
  // Callers may wish to set this field to false for bulk scans.
  // Default: true
  bool fill_cache;

  // If ""snapshot"" is non-NULL, read as of the supplied snapshot
  // (which must belong to the DB that is being read and which must
  // not have been released).  If ""snapshot"" is NULL, use an implicit
  // snapshot of the state at the beginning of this read operation.
  // Default: NULL
  const Snapshot* snapshot;

  ReadOptions()
      : verify_checksums(false),
        fill_cache(true),
        snapshot(NULL) {
  }
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2982,66340,WriteOptions,4,leveldb.WriteOptions,,include\leveldb\options.hpp,"struct WriteOptions {
  // If true, the write will be flushed from the operating system
  // buffer cache (by calling WritableFile::Sync()) before the write
  // is considered complete.  If this flag is true, writes will be
  // slower.
  //
  // If this flag is false, and the machine crashes, some recent
  // writes may be lost.  Note that if it is just the process that
  // crashes (i.e., the machine does not reboot), no writes will be
  // lost even if sync==false.
  //
  // In other words, a DB write with sync==false has similar
  // crash semantics as the ""write()"" system call.  A DB write
  // with sync==true has similar crash semantics to a ""write()""
  // system call followed by ""fsync()"".
  //
  // Default: false
  bool sync;

  WriteOptions()
      : sync(false) {
  }
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2983,66360,Slice,4,leveldb.Slice,,include\leveldb\slice.hpp,"class Slice {
 public:
  // Create an empty slice.
  Slice() : data_(""""), size_(0) { }

  // Create a slice that refers to d[0,n-1].
  Slice(const char* d, size_t n) : data_(d), size_(n) { }

  // Create a slice that refers to the contents of ""s""
  Slice(const std::string& s) : data_(s.data()), size_(s.size()) { }

  // Create a slice that refers to s[0,strlen(s)-1]
  Slice(const char* s) : data_(s), size_(strlen(s)) { }

  // Return a pointer to the beginning of the referenced data
  const char* data() const { return data_; }

  // Return the length (in bytes) of the referenced data
  size_t size() const { return size_; }

  // Return true iff the length of the referenced data is zero
  bool empty() const { return size_ == 0; }

  // Return the ith byte in the referenced data.
  // REQUIRES: n < size()
  char operator[](size_t n) const {
    assert(n < size());
    return data_[n];
  }

  // Change this slice to refer to an empty array
  void clear() { data_ = """"; size_ = 0; }

  /...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2984,66590,Status,4,leveldb.Status,,include\leveldb\status.hpp,"class Status {
 public:
  // Create a success status.
  Status() : state_(NULL) { }
  ~Status() { delete[] state_; }

  // Copy the specified status.
  Status(const Status& s);
  void operator=(const Status& s);

  // Return a success status.
  static Status OK() { return Status(); }

  // Return error status of an appropriate type.
  static Status NotFound(const Slice& msg, const Slice& msg2 = Slice()) {
    return Status(kNotFound, msg, msg2);
  }
  static Status Corruption(const Slice& msg, const Slice& msg2 = Slice()) {
    return Status(kCorruption, msg, msg2);
  }
  static Status NotSupported(const Slice& msg, const Slice& msg2 = Slice()) {
    return Status(kNotSupported, msg, msg2);
  }
  static Status InvalidArgument(const Slice& msg, const Slice& msg2 = Slice()) {
    return Status(kInvalidArgument, msg, msg2);
  }
  static Status IOError(const Slice& msg, const Slice& msg2 = Slice()) {
    return Status(kIOError, msg, msg2);
  }

  // Returns true iff the status indicates...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2985,66725,Code,4,leveldb.Status.Code,,include\leveldb\status.hpp,"enum Code {
    kOk = 0,
    kNotFound = 1,
    kCorruption = 2,
    kNotSupported = 3,
    kInvalidArgument = 4,
    kIOError = 5
  }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2986,66836,Block,4,leveldb.Block,,include\leveldb\table.hpp,class Block,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2987,66837,BlockHandle,4,leveldb.BlockHandle,,include\leveldb\table.hpp,class BlockHandle,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2988,66838,Footer,4,leveldb.Footer,,include\leveldb\table.hpp,class Footer,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2989,66839,Options,4,leveldb.Options,,include\leveldb\table.hpp,struct Options,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2990,66840,RandomAccessFile,4,leveldb.RandomAccessFile,,include\leveldb\table.hpp,class RandomAccessFile,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2991,66841,ReadOptions,4,leveldb.ReadOptions,,include\leveldb\table.hpp,struct ReadOptions,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2992,66842,TableCache,4,leveldb.TableCache,,include\leveldb\table.hpp,class TableCache,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2993,66843,Table,4,leveldb.Table,,include\leveldb\table.hpp,"class Table {
 public:
  // Attempt to open the table that is stored in bytes [0..file_size)
  // of ""file"", and read the metadata entries necessary to allow
  // retrieving data from the table.
  //
  // If successful, returns ok and sets ""*table"" to the newly opened
  // table.  The client should delete ""*table"" when no longer needed.
  // If there was an error while initializing the table, sets ""*table""
  // to NULL and returns a non-ok status.  Does not take ownership of
  // ""*source"", but the client must ensure that ""source"" remains live
  // for the duration of the returned table's lifetime.
  //
  // *file must remain live while this Table is in use.
  static Status Open(const Options& options,
                     RandomAccessFile* file,
                     uint64_t file_size,
                     Table** table);

  ~Table();

  // Returns a new iterator over the table contents.
  // The result of NewIterator() is initially invalid (caller must
  // call one of the Seek me...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2994,66866,Rep,4,leveldb.Table.Rep,,include\leveldb\table.hpp,struct Rep,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2995,66883,TableCache,4,leveldb.Table.TableCache,,include\leveldb\table.hpp,friend class TableCache,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2996,66924,BlockBuilder,4,leveldb.BlockBuilder,,include\leveldb\table_builder.hpp,class BlockBuilder,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2997,66925,BlockHandle,4,leveldb.BlockHandle,,include\leveldb\table_builder.hpp,class BlockHandle,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2998,66926,WritableFile,4,leveldb.WritableFile,,include\leveldb\table_builder.hpp,class WritableFile,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2999,66927,TableBuilder,4,leveldb.TableBuilder,,include\leveldb\table_builder.hpp,"class TableBuilder {
 public:
  // Create a builder that will store the contents of the table it is
  // building in *file.  Does not close the file.  It is up to the
  // caller to close the file after calling Finish().
  TableBuilder(const Options& options, WritableFile* file);

  // REQUIRES: Either Finish() or Abandon() has been called.
  ~TableBuilder();

  // Change the options used by this builder.  Note: only some of the
  // option fields can be changed after construction.  If a field is
  // not allowed to change dynamically and its value in the structure
  // passed to the constructor is different from its value in the
  // structure passed to this method, this method will return an error
  // without changing any fields.
  Status ChangeOptions(const Options& options);

  // Add key,value to the table being constructed.
  // REQUIRES: key is after any previously added key according to comparator.
  // REQUIRES: Finish(), Abandon() have not been called
  void Add(const Sli...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3000,66995,Rep,4,leveldb.TableBuilder.Rep,,include\leveldb\table_builder.hpp,struct Rep,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3001,67017,Slice,4,leveldb.Slice,,include\leveldb\write_batch.hpp,class Slice,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3002,67018,WriteBatch,4,leveldb.WriteBatch,,include\leveldb\write_batch.hpp,"class WriteBatch {
 public:
  WriteBatch();
  ~WriteBatch();

  // Store the mapping ""key->value"" in the database.
  void Put(const Slice& key, const Slice& value);

  // If the database contains a mapping for ""key"", erase it.  Else do nothing.
  void Delete(const Slice& key);

  // Clear all updates buffered in this batch.
  void Clear();

  // Support for iterating over the contents of a batch.
  class Handler {
   public:
    virtual ~Handler();
    virtual void Put(const Slice& key, const Slice& value) = 0;
    virtual void Delete(const Slice& key) = 0;
  };
  Status Iterate(Handler* handler) const;

 private:
  friend class WriteBatchInternal;

  std::string rep_;  // See comment in write_batch.cc for the format of rep_

  // Intentionally copyable
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3003,67042,Handler,4,leveldb.WriteBatch.Handler,,include\leveldb\write_batch.hpp,"class Handler {
   public:
    virtual ~Handler();
    virtual void Put(const Slice& key, const Slice& value) = 0;
    virtual void Delete(const Slice& key) = 0;
  }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3004,67063,WriteBatchInternal,4,leveldb.WriteBatch.WriteBatchInternal,,include\leveldb\write_batch.hpp,friend class WriteBatchInternal,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3005,67111,Issue178,4,anonymous_namespace_4.Issue178,,issues\issue178_test.cc,class Issue178 { },-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3006,67112,_Test_Test,4,anonymous_namespace_5._Test_Test,,issues\issue178_test.cc,_Test_Test,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3007,67457,Issue200,4,leveldb.Issue200,,issues\issue200_test.cc,class Issue200 { },-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3008,67458,_Test_Test,4,leveldb._Test_Test,,issues\issue200_test.cc,_Test_Test,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3009,67884,Mutex,4,leveldb.port.Mutex,,port\port_example.hpp,"class Mutex {
 public:
  Mutex();
  ~Mutex();

  // Lock the mutex.  Waits until other lockers have exited.
  // Will deadlock if the mutex is already locked by this thread.
  void Lock();

  // Unlock the mutex.
  // REQUIRES: This mutex was locked by this thread.
  void Unlock();

  // Optionally crash if this thread does not hold this mutex.
  // The implementation must be fast, especially if NDEBUG is
  // defined.  The implementation is allowed to skip all checks.
  void AssertHeld();
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3010,67905,CondVar,4,leveldb.port.CondVar,,port\port_example.hpp,"class CondVar {
 public:
  explicit CondVar(Mutex* mu);
  ~CondVar();

  // Atomically release *mu and block on this condition variable until
  // either a call to SignalAll(), or a call to Signal() that picks
  // this thread to wakeup.
  // REQUIRES: this thread holds *mu
  void Wait();

  // If there are some threads waiting, wake up at least one of them.
  void Signal();

  // Wake up all waiting threads.
  void SignallAll();
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3011,67927,OnceType,4,OnceType,,port\port_example.hpp,typedef intptr_t OnceType;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3012,67934,AtomicPointer,4,leveldb.port.AtomicPointer,,port\port_example.hpp,"class AtomicPointer {
 private:
  intptr_t rep_;
 public:
  // Initialize to arbitrary value
  AtomicPointer();

  // Initialize to hold v
  explicit AtomicPointer(void* v) : rep_(v) { }

  // Read and return the stored pointer with the guarantee that no
  // later memory access (read or write) by this thread can be
  // reordered ahead of this read.
  void* Acquire_Load() const;

  // Set v as the stored pointer with the guarantee that no earlier
  // memory access (read or write) by this thread can be reordered
  // after this store.
  void Release_Store(void* v);

  // Read the stored pointer with no ordering guarantees.
  void* NoBarrier_Load() const;

  // Set va as the stored pointer with no ordering guarantees.
  void NoBarrier_Store(void* v);
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3013,68166,CondVar,4,leveldb.port.CondVar,,port\port_posix.hpp,class CondVar,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3014,68167,Mutex,4,leveldb.port.Mutex,,port\port_posix.hpp,"class Mutex {
 public:
  Mutex();
  ~Mutex();

  void Lock();
  void Unlock();
  void AssertHeld() { }

 private:
  friend class CondVar;
  pthread_mutex_t mu_;

  // No copying
  Mutex(const Mutex&);
  void operator=(const Mutex&);
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3015,68188,CondVar,4,leveldb.port.Mutex.CondVar,,port\port_posix.hpp,friend class CondVar,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3016,68200,CondVar,4,leveldb.port.CondVar,,port\port_posix.hpp,"class CondVar {
 public:
  explicit CondVar(Mutex* mu);
  ~CondVar();
  void Wait();
  void Signal();
  void SignalAll();
 private:
  pthread_cond_t cv_;
  Mutex* mu_;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3017,68224,OnceType,4,OnceType,,port\port_posix.hpp,typedef pthread_once_t OnceType;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3018,68311,int8_t,4,int8_t,,port\win\stdint.hpp,typedef signed char           int8_t;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3019,68312,int16_t,4,int16_t,,port\win\stdint.hpp,typedef signed short          int16_t;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3020,68313,int32_t,4,int32_t,,port\win\stdint.hpp,typedef signed int            int32_t;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3021,68314,int64_t,4,int64_t,,port\win\stdint.hpp,typedef signed long long      int64_t;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3022,68315,uint8_t,4,uint8_t,,port\win\stdint.hpp,typedef unsigned char         uint8_t;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3023,68316,uint16_t,4,uint16_t,,port\win\stdint.hpp,typedef unsigned short        uint16_t;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3024,68317,uint32_t,4,uint32_t,,port\win\stdint.hpp,typedef unsigned int          uint32_t;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3025,68318,uint64_t,4,uint64_t,,port\win\stdint.hpp,typedef unsigned long long    uint64_t;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3026,68523,Iter,4,leveldb.Iter,,table\block.cc,"class Block::Iter : public Iterator {
 private:
  const Comparator* const comparator_;
  const char* const data_;      // underlying block contents
  uint32_t const restarts_;     // Offset of restart array (list of fixed32)
  uint32_t const num_restarts_; // Number of uint32_t entries in restart array

  // current_ is offset in data_ of current entry.  >= restarts_ if !Valid
  uint32_t current_;
  uint32_t restart_index_;  // Index of restart block in which current_ falls
  std::string key_;
  Slice value_;
  Status status_;

  inline int Compare(const Slice& a, const Slice& b) const {
    return comparator_->Compare(a, b);
  }

  // Return the offset in data_ just past the end of the current entry.
  inline uint32_t NextEntryOffset() const {
    return (value_.data() + value_.size()) - data_;
  }

  uint32_t GetRestartPoint(uint32_t index) {
    assert(index < num_restarts_);
    return DecodeFixed32(data_ + restarts_ + index * sizeof(uint32_t));
  }

  void SeekToRestartPoint(ui...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3027,68993,BlockContents,4,leveldb.BlockContents,,table\block.hpp,struct BlockContents,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3028,68994,Comparator,4,leveldb.Comparator,,table\block.hpp,class Comparator,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3029,68995,Block,4,leveldb.Block,,table\block.hpp,"class Block {
 public:
  // Initialize the block with the specified contents.
  explicit Block(const BlockContents& contents);

  ~Block();

  size_t size() const { return size_; }
  Iterator* NewIterator(const Comparator* comparator);

 private:
  uint32_t NumRestarts() const;

  const char* data_;
  size_t size_;
  uint32_t restart_offset_;     // Offset in data_ of restart array
  bool owned_;                  // Block owns data_[]

  // No copying allowed
  Block(const Block&);
  void operator=(const Block&);

  class Iter;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3030,69034,Iter,4,leveldb.Block.Iter,,table\block.hpp,class Iter,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3031,69324,Options,4,leveldb.Options,,table\block_builder.hpp,struct Options,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3032,69325,BlockBuilder,4,leveldb.BlockBuilder,,table\block_builder.hpp,"class BlockBuilder {
 public:
  explicit BlockBuilder(const Options* options);

  // Reset the contents as if the BlockBuilder was just constructed.
  void Reset();

  // REQUIRES: Finish() has not been called since the last call to Reset().
  // REQUIRES: key is larger than any previously added key
  void Add(const Slice& key, const Slice& value);

  // Finish building the block and return a slice that refers to the
  // block contents.  The returned slice will remain valid for the
  // lifetime of this builder or until Reset() is called.
  Slice Finish();

  // Returns an estimate of the current (uncompressed) size of the block
  // we are building.
  size_t CurrentSizeEstimate() const;

  // Return true iff no entries have been added since the last Reset()
  bool empty() const {
    return buffer_.empty();
  }

 private:
  const Options*        options_;
  std::string           buffer_;      // Destination buffer
  std::vector<uint32_t> restarts_;    // Restart points
  int      ...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3033,69784,FilterPolicy,4,leveldb.FilterPolicy,,table\filter_block.hpp,class FilterPolicy,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3034,69785,FilterBlockBuilder,4,leveldb.FilterBlockBuilder,,table\filter_block.hpp,"class FilterBlockBuilder {
 public:
  explicit FilterBlockBuilder(const FilterPolicy*);

  void StartBlock(uint64_t block_offset);
  void AddKey(const Slice& key);
  Slice Finish();

 private:
  void GenerateFilter();

  const FilterPolicy* policy_;
  std::string keys_;              // Flattened key contents
  std::vector<size_t> start_;     // Starting index in keys_ of each key
  std::string result_;            // Filter data computed so far
  std::vector<Slice> tmp_keys_;   // policy_->CreateFilter() argument
  std::vector<uint32_t> filter_offsets_;

  // No copying allowed
  FilterBlockBuilder(const FilterBlockBuilder&);
  void operator=(const FilterBlockBuilder&);
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3035,69825,FilterBlockReader,4,leveldb.FilterBlockReader,,table\filter_block.hpp,"class FilterBlockReader {
 public:
 // REQUIRES: ""contents"" and *policy must stay live while *this is live.
  FilterBlockReader(const FilterPolicy* policy, const Slice& contents);
  bool KeyMayMatch(uint64_t block_offset, const Slice& key);

 private:
  const FilterPolicy* policy_;
  const char* data_;    // Pointer to filter data (at block-start)
  const char* offset_;  // Pointer to beginning of offset array (at block-end)
  size_t num_;          // Number of entries in offset array
  size_t base_lg_;      // Encoding parameter (see kFilterBaseLg in .cc file)
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3036,69863,TestHashFilter,4,leveldb.TestHashFilter,,table\filter_block_test.cc,"class TestHashFilter : public FilterPolicy {
 public:
  virtual const char* Name() const {
    return ""TestHashFilter"";
  }

  virtual void CreateFilter(const Slice* keys, int n, std::string* dst) const {
    for (int i = 0; i < n; i++) {
      uint32_t h = Hash(keys[i].data(), keys[i].size(), 1);
      PutFixed32(dst, h);
    }
  }

  virtual bool KeyMayMatch(const Slice& key, const Slice& filter) const {
    uint32_t h = Hash(key.data(), key.size(), 1);
    for (size_t i = 0; i + 4 <= filter.size(); i += 4) {
      if (h == DecodeFixed32(filter.data() + i)) {
        return true;
      }
    }
    return false;
  }
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3037,69961,FilterBlockTest,4,leveldb.FilterBlockTest,,table\filter_block_test.cc,"class FilterBlockTest {
 public:
  TestHashFilter policy_;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3038,69963,_Test_EmptyBuilder,4,leveldb._Test_EmptyBuilder,,table\filter_block_test.cc,_Test_EmptyBuilder,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3039,70071,_Test_SingleChunk,4,leveldb._Test_SingleChunk,,table\filter_block_test.cc,_Test_SingleChunk,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3040,70302,_Test_MultiChunk,4,leveldb._Test_MultiChunk,,table\filter_block_test.cc,_Test_MultiChunk,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3041,71259,Block,4,leveldb.Block,,table\format.hpp,class Block,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3042,71260,RandomAccessFile,4,leveldb.RandomAccessFile,,table\format.hpp,class RandomAccessFile,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3043,71261,ReadOptions,4,leveldb.ReadOptions,,table\format.hpp,struct ReadOptions,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3044,71262,BlockHandle,4,leveldb.BlockHandle,,table\format.hpp,"class BlockHandle {
 public:
  BlockHandle();

  // The offset of the block in the file.
  uint64_t offset() const { return offset_; }
  void set_offset(uint64_t offset) { offset_ = offset; }

  // The size of the stored block
  uint64_t size() const { return size_; }
  void set_size(uint64_t size) { size_ = size; }

  void EncodeTo(std::string* dst) const;
  Status DecodeFrom(Slice* input);

  // Maximum encoding length of a BlockHandle
  enum { kMaxEncodedLength = 10 + 10 };

 private:
  uint64_t offset_;
  uint64_t size_;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3045,71305,anonymous_enum_0,4,leveldb.BlockHandle.anonymous_enum_0,,table\format.hpp,enum { kMaxEncodedLength = 10 + 10 },-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3046,71318,Footer,4,leveldb.Footer,,table\format.hpp,"class Footer {
 public:
  Footer() { }

  // The block handle for the metaindex block of the table
  const BlockHandle& metaindex_handle() const { return metaindex_handle_; }
  void set_metaindex_handle(const BlockHandle& h) { metaindex_handle_ = h; }

  // The block handle for the index block of the table
  const BlockHandle& index_handle() const {
    return index_handle_;
  }
  void set_index_handle(const BlockHandle& h) {
    index_handle_ = h;
  }

  void EncodeTo(std::string* dst) const;
  Status DecodeFrom(Slice* input);

  // Encoded length of a Footer.  Note that the serialization of a
  // Footer will always occupy exactly this many bytes.  It consists
  // of two block handles and a magic number.
  enum {
    kEncodedLength = 2*BlockHandle::kMaxEncodedLength + 8
  };

 private:
  BlockHandle metaindex_handle_;
  BlockHandle index_handle_;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3047,71361,anonymous_enum_1,4,leveldb.Footer.anonymous_enum_1,,table\format.hpp,"enum {
    kEncodedLength = 2*BlockHandle::kMaxEncodedLength + 8
  }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3048,71386,BlockContents,4,leveldb.BlockContents,,table\format.hpp,"struct BlockContents {
  Slice data;           // Actual contents of data
  bool cachable;        // True iff data can be cached
  bool heap_allocated;  // True iff caller should delete[] data.data()
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3049,71537,EmptyIterator,4,leveldb.anonymous_namespace_1.EmptyIterator,,table\iterator.cc,"class EmptyIterator : public Iterator {
 public:
  EmptyIterator(const Status& s) : status_(s) { }
  virtual bool Valid() const { return false; }
  virtual void Seek(const Slice& target) { }
  virtual void SeekToFirst() { }
  virtual void SeekToLast() { }
  virtual void Next() { assert(false); }
  virtual void Prev() { assert(false); }
  Slice key() const { assert(false); return Slice(); }
  Slice value() const { assert(false); return Slice(); }
  virtual Status status() const { return status_; }
 private:
  Status status_;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3050,71627,IteratorWrapper,4,leveldb.IteratorWrapper,,table\iterator_wrapper.hpp,"class IteratorWrapper {
 public:
  IteratorWrapper(): iter_(NULL), valid_(false) { }
  explicit IteratorWrapper(Iterator* iter): iter_(NULL) {
    Set(iter);
  }
  ~IteratorWrapper() { delete iter_; }
  Iterator* iter() const { return iter_; }

  // Takes ownership of ""iter"" and will delete it when destroyed, or
  // when Set() is invoked again.
  void Set(Iterator* iter) {
    delete iter_;
    iter_ = iter;
    if (iter_ == NULL) {
      valid_ = false;
    } else {
      Update();
    }
  }


  // Iterator interface methods
  bool Valid() const        { return valid_; }
  Slice key() const         { assert(Valid()); return key_; }
  Slice value() const       { assert(Valid()); return iter_->value(); }
  // Methods below require iter() != NULL
  Status status() const     { assert(iter_); return iter_->status(); }
  void Next()               { assert(iter_); iter_->Next();        Update(); }
  void Prev()               { assert(iter_); iter_->Prev();        Update(); }
  void Seek(...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3051,71802,MergingIterator,4,leveldb.anonymous_namespace_1.MergingIterator,,table\merger.cc,"class MergingIterator : public Iterator {
 public:
  MergingIterator(const Comparator* comparator, Iterator** children, int n)
      : comparator_(comparator),
        children_(new IteratorWrapper[n]),
        n_(n),
        current_(NULL),
        direction_(kForward) {
    for (int i = 0; i < n; i++) {
      children_[i].Set(children[i]);
    }
  }

  virtual ~MergingIterator() {
    delete[] children_;
  }

  virtual bool Valid() const {
    return (current_ != NULL);
  }

  virtual void SeekToFirst() {
    for (int i = 0; i < n_; i++) {
      children_[i].SeekToFirst();
    }
    FindSmallest();
    direction_ = kForward;
  }

  virtual void SeekToLast() {
    for (int i = 0; i < n_; i++) {
      children_[i].SeekToLast();
    }
    FindLargest();
    direction_ = kReverse;
  }

  virtual void Seek(const Slice& target) {
    for (int i = 0; i < n_; i++) {
      children_[i].Seek(target);
    }
    FindSmallest();
    direction_ = kForward;
  }

  virtual void Next() {
    asser...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3052,72128,Direction,4,leveldb.anonymous_namespace_22.MergingIterator.Direction,,table\merger.cc,"enum Direction {
    kForward,
    kReverse
  }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3053,72307,Comparator,4,leveldb.Comparator,,table\merger.hpp,class Comparator,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3054,72308,Iterator,4,leveldb.Iterator,,table\merger.hpp,class Iterator,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3055,72344,Rep,4,leveldb.Rep,,table\table.cc,"struct Table::Rep {
  ~Rep() {
    delete filter;
    delete [] filter_data;
    delete index_block;
  }

  Options options;
  Status status;
  RandomAccessFile* file;
  uint64_t cache_id;
  FilterBlockReader* filter;
  const char* filter_data;

  BlockHandle metaindex_handle;  // Handle to metaindex_block: saved from footer
  Block* index_block;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3056,73288,Rep,4,leveldb.Rep,,table\table_builder.cc,"struct TableBuilder::Rep {
  Options options;
  Options index_block_options;
  WritableFile* file;
  uint64_t offset;
  Status status;
  BlockBuilder data_block;
  BlockBuilder index_block;
  std::string last_key;
  int64_t num_entries;
  bool closed;          // Either Finish() or Abandon() has been called.
  FilterBlockBuilder* filter_block;

  // We do not emit the index entry for a block until we have seen the
  // first key for the next data block.  This allows us to use shorter
  // keys in the index block.  For example, consider a block boundary
  // between the keys ""the quick brown fox"" and ""the who"".  We can use
  // ""the r"" as the key for the index block entry since it is >= all
  // entries in the first block and < all entries in subsequent
  // blocks.
  //
  // Invariant: r->pending_index_entry is true only if data_block is empty.
  bool pending_index_entry;
  BlockHandle pending_handle;  // Handle to add to index block

  std::string compressed_output;

  Rep(const Op...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3057,74156,ReverseKeyComparator,4,leveldb.anonymous_namespace_1.ReverseKeyComparator,,table\table_test.cc,"class ReverseKeyComparator : public Comparator {
 public:
  virtual const char* Name() const {
    return ""leveldb.ReverseBytewiseComparator"";
  }

  virtual int Compare(const Slice& a, const Slice& b) const {
    return BytewiseComparator()->Compare(Reverse(a), Reverse(b));
  }

  virtual void FindShortestSeparator(
      std::string* start,
      const Slice& limit) const {
    std::string s = Reverse(*start);
    std::string l = Reverse(limit);
    BytewiseComparator()->FindShortestSeparator(&s, l);
    *start = Reverse(s);
  }

  virtual void FindShortSuccessor(std::string* key) const {
    std::string s = Reverse(*key);
    BytewiseComparator()->FindShortSuccessor(&s);
    *key = Reverse(s);
  }
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3058,74270,STLLessThan,4,leveldb.anonymous_namespace_7.STLLessThan,,table\table_test.cc,"struct STLLessThan {
  const Comparator* cmp;

  STLLessThan() : cmp(BytewiseComparator()) { }
  STLLessThan(const Comparator* c) : cmp(c) { }
  bool operator()(const std::string& a, const std::string& b) const {
    return cmp->Compare(Slice(a), Slice(b)) < 0;
  }
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3059,74298,StringSink,4,leveldb.StringSink,,table\table_test.cc,"class StringSink: public WritableFile {
 public:
  ~StringSink() { }

  const std::string& contents() const { return contents_; }

  virtual Status Close() { return Status::OK(); }
  virtual Status Flush() { return Status::OK(); }
  virtual Status Sync() { return Status::OK(); }

  virtual Status Append(const Slice& data) {
    contents_.append(data.data(), data.size());
    return Status::OK();
  }

 private:
  std::string contents_;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3060,74359,StringSource,4,leveldb.StringSource,,table\table_test.cc,"class StringSource: public RandomAccessFile {
 public:
  StringSource(const Slice& contents)
      : contents_(contents.data(), contents.size()) {
  }

  virtual ~StringSource() { }

  uint64_t Size() const { return contents_.size(); }

  virtual Status Read(uint64_t offset, size_t n, Slice* result,
                       char* scratch) const {
    if (offset > contents_.size()) {
      return Status::InvalidArgument(""invalid Read offset"");
    }
    if (offset + n > contents_.size()) {
      n = contents_.size() - offset;
    }
    memcpy(scratch, &contents_[offset], n);
    *result = Slice(scratch, n);
    return Status::OK();
  }

 private:
  std::string contents_;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3061,74437,KVMap,4,KVMap,,table\table_test.cc,"typedef std::map<std::string, std::string, STLLessThan> KVMap;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3062,74438,Constructor,4,leveldb.Constructor,,table\table_test.cc,"class Constructor {
 public:
  explicit Constructor(const Comparator* cmp) : data_(STLLessThan(cmp)) { }
  virtual ~Constructor() { }

  void Add(const std::string& key, const Slice& value) {
    data_[key] = value.ToString();
  }

  // Finish constructing the data structure with all the keys that have
  // been added so far.  Returns the keys in sorted order in ""*keys""
  // and stores the key/value pairs in ""*kvmap""
  void Finish(const Options& options,
              std::vector<std::string>* keys,
              KVMap* kvmap) {
    *kvmap = data_;
    keys->clear();
    for (KVMap::const_iterator it = data_.begin();
         it != data_.end();
         ++it) {
      keys->push_back(it->first);
    }
    data_.clear();
    Status s = FinishImpl(options, *kvmap);
    ASSERT_TRUE(s.ok()) << s.ToString();
  }

  // Construct the data structure from the data in ""data""
  virtual Status FinishImpl(const Options& options, const KVMap& data) = 0;

  virtual Iterator* NewIterator() const = 0...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3063,74563,BlockConstructor,4,leveldb.BlockConstructor,,table\table_test.cc,"class BlockConstructor: public Constructor {
 public:
  explicit BlockConstructor(const Comparator* cmp)
      : Constructor(cmp),
        comparator_(cmp),
        block_(NULL) { }
  ~BlockConstructor() {
    delete block_;
  }
  virtual Status FinishImpl(const Options& options, const KVMap& data) {
    delete block_;
    block_ = NULL;
    BlockBuilder builder(&options);

    for (KVMap::const_iterator it = data.begin();
         it != data.end();
         ++it) {
      builder.Add(it->first, it->second);
    }
    // Open the block
    data_ = builder.Finish().ToString();
    BlockContents contents;
    contents.data = data_;
    contents.cachable = false;
    contents.heap_allocated = false;
    block_ = new Block(contents);
    return Status::OK();
  }
  virtual Iterator* NewIterator() const {
    return block_->NewIterator(comparator_);
  }

 private:
  const Comparator* comparator_;
  std::string data_;
  Block* block_;

  BlockConstructor();
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3064,74670,TableConstructor,4,leveldb.TableConstructor,,table\table_test.cc,"class TableConstructor: public Constructor {
 public:
  TableConstructor(const Comparator* cmp)
      : Constructor(cmp),
        source_(NULL), table_(NULL) {
  }
  ~TableConstructor() {
    Reset();
  }
  virtual Status FinishImpl(const Options& options, const KVMap& data) {
    Reset();
    StringSink sink;
    TableBuilder builder(options, &sink);

    for (KVMap::const_iterator it = data.begin();
         it != data.end();
         ++it) {
      builder.Add(it->first, it->second);
      ASSERT_TRUE(builder.status().ok());
    }
    Status s = builder.Finish();
    ASSERT_TRUE(s.ok()) << s.ToString();

    ASSERT_EQ(sink.contents().size(), builder.FileSize());

    // Open the table
    source_ = new StringSource(sink.contents());
    Options table_options;
    table_options.comparator = options.comparator;
    return Table::Open(table_options, source_, sink.contents().size(), &table_);
  }

  virtual Iterator* NewIterator() const {
    return table_->NewIterator(ReadOptions());...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3065,74892,KeyConvertingIterator,4,leveldb.KeyConvertingIterator,,table\table_test.cc,"class KeyConvertingIterator: public Iterator {
 public:
  explicit KeyConvertingIterator(Iterator* iter) : iter_(iter) { }
  virtual ~KeyConvertingIterator() { delete iter_; }
  virtual bool Valid() const { return iter_->Valid(); }
  virtual void Seek(const Slice& target) {
    ParsedInternalKey ikey(target, kMaxSequenceNumber, kTypeValue);
    std::string encoded;
    AppendInternalKey(&encoded, ikey);
    iter_->Seek(encoded);
  }
  virtual void SeekToFirst() { iter_->SeekToFirst(); }
  virtual void SeekToLast() { iter_->SeekToLast(); }
  virtual void Next() { iter_->Next(); }
  virtual void Prev() { iter_->Prev(); }

  virtual Slice key() const {
    assert(Valid());
    ParsedInternalKey key;
    if (!ParseInternalKey(iter_->key(), &key)) {
      status_ = Status::Corruption(""malformed internal key"");
      return Slice(""corrupted key"");
    }
    return key.user_key;
  }

  virtual Slice value() const { return iter_->value(); }
  virtual Status status() const {
    return statu...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3066,75032,MemTableConstructor,4,leveldb.MemTableConstructor,,table\table_test.cc,"class MemTableConstructor: public Constructor {
 public:
  explicit MemTableConstructor(const Comparator* cmp)
      : Constructor(cmp),
        internal_comparator_(cmp) {
    memtable_ = new MemTable(internal_comparator_);
    memtable_->Ref();
  }
  ~MemTableConstructor() {
    memtable_->Unref();
  }
  virtual Status FinishImpl(const Options& options, const KVMap& data) {
    memtable_->Unref();
    memtable_ = new MemTable(internal_comparator_);
    memtable_->Ref();
    int seq = 1;
    for (KVMap::const_iterator it = data.begin();
         it != data.end();
         ++it) {
      memtable_->Add(seq, kTypeValue, it->first, it->second);
      seq++;
    }
    return Status::OK();
  }
  virtual Iterator* NewIterator() const {
    return new KeyConvertingIterator(memtable_->NewIterator());
  }

 private:
  InternalKeyComparator internal_comparator_;
  MemTable* memtable_;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3067,75128,DBConstructor,4,leveldb.DBConstructor,,table\table_test.cc,"class DBConstructor: public Constructor {
 public:
  explicit DBConstructor(const Comparator* cmp)
      : Constructor(cmp),
        comparator_(cmp) {
    db_ = NULL;
    NewDB();
  }
  ~DBConstructor() {
    delete db_;
  }
  virtual Status FinishImpl(const Options& options, const KVMap& data) {
    delete db_;
    db_ = NULL;
    NewDB();
    for (KVMap::const_iterator it = data.begin();
         it != data.end();
         ++it) {
      WriteBatch batch;
      batch.Put(it->first, it->second);
      ASSERT_TRUE(db_->Write(WriteOptions(), &batch).ok());
    }
    return Status::OK();
  }
  virtual Iterator* NewIterator() const {
    return db_->NewIterator(ReadOptions());
  }

  virtual DB* db() const { return db_; }

 private:
  void NewDB() {
    std::string name = test::TmpDir() + ""/table_testdb"";

    Options options;
    options.comparator = comparator_;
    Status status = DestroyDB(name, options);
    ASSERT_TRUE(status.ok()) << status.ToString();

    options.create_if_mis...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3068,75336,TestType,4,leveldb.TestType,,table\table_test.cc,"enum TestType {
  TABLE_TEST,
  BLOCK_TEST,
  MEMTABLE_TEST,
  DB_TEST
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3069,75341,TestArgs,4,leveldb.TestArgs,,table\table_test.cc,"struct TestArgs {
  TestType type;
  bool reverse_compare;
  int restart_interval;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3070,75423,Harness,4,leveldb.Harness,,table\table_test.cc,"class Harness {
 public:
  Harness() : constructor_(NULL) { }

  void Init(const TestArgs& args) {
    delete constructor_;
    constructor_ = NULL;
    options_ = Options();

    options_.block_restart_interval = args.restart_interval;
    // Use shorter block size for tests to exercise block boundary
    // conditions more.
    options_.block_size = 256;
    if (args.reverse_compare) {
      options_.comparator = &reverse_key_comparator;
    }
    switch (args.type) {
      case TABLE_TEST:
        constructor_ = new TableConstructor(options_.comparator);
        break;
      case BLOCK_TEST:
        constructor_ = new BlockConstructor(options_.comparator);
        break;
      case MEMTABLE_TEST:
        constructor_ = new MemTableConstructor(options_.comparator);
        break;
      case DB_TEST:
        constructor_ = new DBConstructor(options_.comparator);
        break;
    }
  }

  ~Harness() {
    delete constructor_;
  }

  void Add(const std::string& key, const std::stri...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3071,76317,_Test_Empty,4,leveldb._Test_Empty,,table\table_test.cc,_Test_Empty,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3072,76377,_Test_ZeroRestartPointsInBlock,4,leveldb._Test_ZeroRestartPointsInBlock,,table\table_test.cc,_Test_ZeroRestartPointsInBlock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3073,76533,_Test_SimpleEmptyKey,4,leveldb._Test_SimpleEmptyKey,,table\table_test.cc,_Test_SimpleEmptyKey,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3074,76596,_Test_SimpleSingle,4,leveldb._Test_SimpleSingle,,table\table_test.cc,_Test_SimpleSingle,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3075,76659,_Test_SimpleMulti,4,leveldb._Test_SimpleMulti,,table\table_test.cc,_Test_SimpleMulti,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3076,76728,_Test_SimpleSpecialKey,4,leveldb._Test_SimpleSpecialKey,,table\table_test.cc,_Test_SimpleSpecialKey,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3077,76791,_Test_Randomized,4,leveldb._Test_Randomized,,table\table_test.cc,_Test_Randomized,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3078,76927,_Test_RandomizedLongDB,4,leveldb._Test_RandomizedLongDB,,table\table_test.cc,_Test_RandomizedLongDB,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3079,77094,MemTableTest,4,leveldb.MemTableTest,,table\table_test.cc,class MemTableTest { },-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3080,77095,_Test_Simple,4,leveldb._Test_Simple,,table\table_test.cc,_Test_Simple,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3081,77314,TableTest,4,leveldb.TableTest,,table\table_test.cc,class TableTest { },-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3082,77315,_Test_ApproximateOffsetOfPlain,4,leveldb._Test_ApproximateOffsetOfPlain,,table\table_test.cc,_Test_ApproximateOffsetOfPlain,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3083,77709,_Test_ApproximateOffsetOfCompressed,4,leveldb._Test_ApproximateOffsetOfCompressed,,table\table_test.cc,_Test_ApproximateOffsetOfCompressed,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3084,78022,TwoLevelIterator,4,leveldb.anonymous_namespace_2.TwoLevelIterator,,table\two_level_iterator.cc,"class TwoLevelIterator: public Iterator {
 public:
  TwoLevelIterator(
    Iterator* index_iter,
    BlockFunction block_function,
    void* arg,
    const ReadOptions& options);

  virtual ~TwoLevelIterator();

  virtual void Seek(const Slice& target);
  virtual void SeekToFirst();
  virtual void SeekToLast();
  virtual void Next();
  virtual void Prev();

  virtual bool Valid() const {
    return data_iter_.Valid();
  }
  virtual Slice key() const {
    assert(Valid());
    return data_iter_.key();
  }
  virtual Slice value() const {
    assert(Valid());
    return data_iter_.value();
  }
  virtual Status status() const {
    // It'd be nice if status() returned a const Status& instead of a Status
    if (!index_iter_.status().ok()) {
      return index_iter_.status();
    } else if (data_iter_.iter() != NULL && !data_iter_.status().ok()) {
      return data_iter_.status();
    } else {
      return status_;
    }
  }

 private:
  void SaveError(const Status& s) {
    if (status_....",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3085,78477,ReadOptions,4,leveldb.ReadOptions,,table\two_level_iterator.hpp,struct ReadOptions,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3086,78702,Arena,4,leveldb.Arena,,util\arena.hpp,"class Arena {
 public:
  Arena();
  ~Arena();

  // Return a pointer to a newly allocated memory block of ""bytes"" bytes.
  char* Allocate(size_t bytes);

  // Allocate memory with the normal alignment guarantees provided by malloc
  char* AllocateAligned(size_t bytes);

  // Returns an estimate of the total memory usage of data allocated
  // by the arena.
  size_t MemoryUsage() const {
    return reinterpret_cast<uintptr_t>(memory_usage_.NoBarrier_Load());
  }

 private:
  char* AllocateFallback(size_t bytes);
  char* AllocateNewBlock(size_t block_bytes);

  // Allocation state
  char* alloc_ptr_;
  size_t alloc_bytes_remaining_;

  // Array of new[] allocated memory blocks
  std::vector<char*> blocks_;

  // Total memory usage of the arena.
  port::AtomicPointer memory_usage_;

  // No copying allowed
  Arena(const Arena&);
  void operator=(const Arena&);
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3087,78797,ArenaTest,4,leveldb.ArenaTest,,util\arena_test.cc,class ArenaTest { },-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3088,78798,_Test_Empty,4,leveldb._Test_Empty,,util\arena_test.cc,_Test_Empty,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3089,78832,_Test_Simple,4,leveldb._Test_Simple,,util\arena_test.cc,_Test_Simple,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3090,79168,BloomFilterPolicy,4,leveldb.anonymous_namespace_2.BloomFilterPolicy,,util\bloom.cc,"class BloomFilterPolicy : public FilterPolicy {
 private:
  size_t bits_per_key_;
  size_t k_;

 public:
  explicit BloomFilterPolicy(int bits_per_key)
      : bits_per_key_(bits_per_key) {
    // We intentionally round down to reduce probing cost a little bit
    k_ = static_cast<size_t>(bits_per_key * 0.69);  // 0.69 =~ ln(2)
    if (k_ < 1) k_ = 1;
    if (k_ > 30) k_ = 30;
  }

  virtual const char* Name() const {
    return ""leveldb.BuiltinBloomFilter2"";
  }

  virtual void CreateFilter(const Slice* keys, int n, std::string* dst) const {
    // Compute bloom filter size (in both bits and bytes)
    size_t bits = n * bits_per_key_;

    // For small n, we can see a very high false positive rate.  Fix it
    // by enforcing a minimum bloom filter length.
    if (bits < 64) bits = 64;

    size_t bytes = (bits + 7) / 8;
    bits = bytes * 8;

    const size_t init_size = dst->size();
    dst->resize(init_size + bytes, 0);
    dst->push_back(static_cast<char>(k_));  // Remember # o...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3091,79478,BloomTest,4,leveldb.BloomTest,,util\bloom_test.cc,"class BloomTest {
 private:
  const FilterPolicy* policy_;
  std::string filter_;
  std::vector<std::string> keys_;

 public:
  BloomTest() : policy_(NewBloomFilterPolicy(10)) { }

  ~BloomTest() {
    delete policy_;
  }

  void Reset() {
    keys_.clear();
    filter_.clear();
  }

  void Add(const Slice& s) {
    keys_.push_back(s.ToString());
  }

  void Build() {
    std::vector<Slice> key_slices;
    for (size_t i = 0; i < keys_.size(); i++) {
      key_slices.push_back(Slice(keys_[i]));
    }
    filter_.clear();
    policy_->CreateFilter(&key_slices[0], static_cast<int>(key_slices.size()),
                          &filter_);
    keys_.clear();
    if (kVerbose >= 2) DumpFilter();
  }

  size_t FilterSize() const {
    return filter_.size();
  }

  void DumpFilter() {
    fprintf(stderr, ""F("");
    for (size_t i = 0; i+1 < filter_.size(); i++) {
      const unsigned int c = static_cast<unsigned int>(filter_[i]);
      for (int j = 0; j < 8; j++) {
        fprintf(stderr, ""%c...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3092,79697,_Test_EmptyFilter,4,leveldb._Test_EmptyFilter,,util\bloom_test.cc,_Test_EmptyFilter,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3093,79770,_Test_Small,4,leveldb._Test_Small,,util\bloom_test.cc,_Test_Small,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3094,79923,_Test_VaryingLengths,4,leveldb._Test_VaryingLengths,,util\bloom_test.cc,_Test_VaryingLengths,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3095,80174,LRUHandle,4,leveldb.anonymous_namespace_1.LRUHandle,,util\cache.cc,"struct LRUHandle {
  void* value;
  void (*deleter)(const Slice&, void* value);
  LRUHandle* next_hash;
  LRUHandle* next;
  LRUHandle* prev;
  size_t charge;      // TODO(opt): Only allow uint32_t?
  size_t key_length;
  bool in_cache;      // Whether entry is in the cache.
  uint32_t refs;      // References, including cache reference, if present.
  uint32_t hash;      // Hash of key(); used for fast sharding and comparisons
  char key_data[1];   // Beginning of key

  Slice key() const {
    // For cheaper lookups, we allow a temporary Handle object
    // to store a pointer to a key in ""value"".
    if (next == this) {
      return *(reinterpret_cast<Slice*>(value));
    } else {
      return Slice(key_data, key_length);
    }
  }
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3096,80217,HandleTable,4,leveldb.anonymous_namespace_4.HandleTable,,util\cache.cc,"class HandleTable {
 public:
  HandleTable() : length_(0), elems_(0), list_(NULL) { Resize(); }
  ~HandleTable() { delete[] list_; }

  LRUHandle* Lookup(const Slice& key, uint32_t hash) {
    return *FindPointer(key, hash);
  }

  LRUHandle* Insert(LRUHandle* h) {
    LRUHandle** ptr = FindPointer(h->key(), h->hash);
    LRUHandle* old = *ptr;
    h->next_hash = (old == NULL ? NULL : old->next_hash);
    *ptr = h;
    if (old == NULL) {
      ++elems_;
      if (elems_ > length_) {
        // Since each cache entry is fairly large, we aim for a small
        // average linked list length (<= 1).
        Resize();
      }
    }
    return old;
  }

  LRUHandle* Remove(const Slice& key, uint32_t hash) {
    LRUHandle** ptr = FindPointer(key, hash);
    LRUHandle* result = *ptr;
    if (result != NULL) {
      *ptr = result->next_hash;
      --elems_;
    }
    return result;
  }

 private:
  // The table consists of an array of buckets where each bucket is
  // a linked list of cache...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3097,80481,LRUCache,4,leveldb.anonymous_namespace_17.LRUCache,,util\cache.cc,"class LRUCache {
 public:
  LRUCache();
  ~LRUCache();

  // Separate from constructor so caller can easily make an array of LRUCache
  void SetCapacity(size_t capacity) { capacity_ = capacity; }

  // Like Cache methods, but with an extra ""hash"" parameter.
  Cache::Handle* Insert(const Slice& key, uint32_t hash,
                        void* value, size_t charge,
                        void (*deleter)(const Slice& key, void* value));
  Cache::Handle* Lookup(const Slice& key, uint32_t hash);
  void Release(Cache::Handle* handle);
  void Erase(const Slice& key, uint32_t hash);
  void Prune();
  size_t TotalCharge() const {
    MutexLock l(&mutex_);
    return usage_;
  }

 private:
  void LRU_Remove(LRUHandle* e);
  void LRU_Append(LRUHandle*list, LRUHandle* e);
  void Ref(LRUHandle* e);
  void Unref(LRUHandle* e);
  bool FinishErase(LRUHandle* e);

  // Initialized before use.
  size_t capacity_;

  // mutex_ protects the following state.
  mutable port::Mutex mutex_;
  size_t usag...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3098,81094,ShardedLRUCache,4,leveldb.anonymous_namespace_54.ShardedLRUCache,,util\cache.cc,"class ShardedLRUCache : public Cache {
 private:
  LRUCache shard_[kNumShards];
  port::Mutex id_mutex_;
  uint64_t last_id_;

  static inline uint32_t HashSlice(const Slice& s) {
    return Hash(s.data(), s.size(), 0);
  }

  static uint32_t Shard(uint32_t hash) {
    return hash >> (32 - kNumShardBits);
  }

 public:
  explicit ShardedLRUCache(size_t capacity)
      : last_id_(0) {
    const size_t per_shard = (capacity + (kNumShards - 1)) / kNumShards;
    for (int s = 0; s < kNumShards; s++) {
      shard_[s].SetCapacity(per_shard);
    }
  }
  virtual ~ShardedLRUCache() { }
  virtual Handle* Insert(const Slice& key, void* value, size_t charge,
                         void (*deleter)(const Slice& key, void* value)) {
    const uint32_t hash = HashSlice(key);
    return shard_[Shard(hash)].Insert(key, hash, value, charge, deleter);
  }
  virtual Handle* Lookup(const Slice& key) {
    const uint32_t hash = HashSlice(key);
    return shard_[Shard(hash)].Lookup(key, hash);
  }
  vi...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3099,81400,CacheTest,4,leveldb.CacheTest,,util\cache_test.cc,"class CacheTest {
 public:
  static CacheTest* current_;

  static void Deleter(const Slice& key, void* v) {
    current_->deleted_keys_.push_back(DecodeKey(key));
    current_->deleted_values_.push_back(DecodeValue(v));
  }

  static const int kCacheSize = 1000;
  std::vector<int> deleted_keys_;
  std::vector<int> deleted_values_;
  Cache* cache_;

  CacheTest() : cache_(NewLRUCache(kCacheSize)) {
    current_ = this;
  }

  ~CacheTest() {
    delete cache_;
  }

  int Lookup(int key) {
    Cache::Handle* handle = cache_->Lookup(EncodeKey(key));
    const int r = (handle == NULL) ? -1 : DecodeValue(cache_->Value(handle));
    if (handle != NULL) {
      cache_->Release(handle);
    }
    return r;
  }

  void Insert(int key, int value, int charge = 1) {
    cache_->Release(cache_->Insert(EncodeKey(key), EncodeValue(value), charge,
                                   &CacheTest::Deleter));
  }

  Cache::Handle* InsertAndReturnHandle(int key, int value, int charge = 1) {
    return ca...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3100,81546,_Test_HitAndMiss,4,leveldb._Test_HitAndMiss,,util\cache_test.cc,_Test_HitAndMiss,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3101,81853,_Test_Erase,4,leveldb._Test_Erase,,util\cache_test.cc,_Test_Erase,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3102,82089,_Test_EntriesArePinned,4,leveldb._Test_EntriesArePinned,,util\cache_test.cc,_Test_EntriesArePinned,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3103,82409,_Test_EvictionPolicy,4,leveldb._Test_EvictionPolicy,,util\cache_test.cc,_Test_EvictionPolicy,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3104,82584,_Test_UseExceedsCacheSize,4,leveldb._Test_UseExceedsCacheSize,,util\cache_test.cc,_Test_UseExceedsCacheSize,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3105,82700,_Test_HeavyEntries,4,leveldb._Test_HeavyEntries,,util\cache_test.cc,_Test_HeavyEntries,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3106,82852,_Test_NewId,4,leveldb._Test_NewId,,util\cache_test.cc,_Test_NewId,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3107,82916,_Test_Prune,4,leveldb._Test_Prune,,util\cache_test.cc,_Test_Prune,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3108,84100,Coding,4,leveldb.Coding,,util\coding_test.cc,class Coding { },-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3109,84101,_Test_Fixed32,4,leveldb._Test_Fixed32,,util\coding_test.cc,_Test_Fixed32,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3110,84196,_Test_Fixed64,4,leveldb._Test_Fixed64,,util\coding_test.cc,_Test_Fixed64,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3111,84374,_Test_EncodingOutput,4,leveldb._Test_EncodingOutput,,util\coding_test.cc,_Test_EncodingOutput,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3112,84766,_Test_Varint32,4,leveldb._Test_Varint32,,util\coding_test.cc,_Test_Varint32,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3113,84958,_Test_Varint64,4,leveldb._Test_Varint64,,util\coding_test.cc,_Test_Varint64,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3114,85220,_Test_Varint32Overflow,4,leveldb._Test_Varint32Overflow,,util\coding_test.cc,_Test_Varint32Overflow,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3115,85289,_Test_Varint32Truncation,4,leveldb._Test_Varint32Truncation,,util\coding_test.cc,_Test_Varint32Truncation,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3116,85431,_Test_Varint64Overflow,4,leveldb._Test_Varint64Overflow,,util\coding_test.cc,_Test_Varint64Overflow,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3117,85500,_Test_Varint64Truncation,4,leveldb._Test_Varint64Truncation,,util\coding_test.cc,_Test_Varint64Truncation,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3118,85642,_Test_Strings,4,leveldb._Test_Strings,,util\coding_test.cc,_Test_Strings,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3119,85936,BytewiseComparatorImpl,4,leveldb.anonymous_namespace_1.BytewiseComparatorImpl,,util\comparator.cc,"class BytewiseComparatorImpl : public Comparator {
 public:
  BytewiseComparatorImpl() { }

  virtual const char* Name() const {
    return ""leveldb.BytewiseComparator"";
  }

  virtual int Compare(const Slice& a, const Slice& b) const {
    return a.compare(b);
  }

  virtual void FindShortestSeparator(
      std::string* start,
      const Slice& limit) const {
    // Find length of common prefix
    size_t min_length = std::min(start->size(), limit.size());
    size_t diff_index = 0;
    while ((diff_index < min_length) &&
           ((*start)[diff_index] == limit[diff_index])) {
      diff_index++;
    }

    if (diff_index >= min_length) {
      // Do not shorten if one string is a prefix of the other
    } else {
      uint8_t diff_byte = static_cast<uint8_t>((*start)[diff_index]);
      if (diff_byte < static_cast<uint8_t>(0xff) &&
          diff_byte + 1 < static_cast<uint8_t>(limit[diff_index])) {
        (*start)[diff_index]++;
        start->resize(diff_index + 1);
       ...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3120,87670,CRC,4,leveldb.crc32c.CRC,,util\crc32c_test.cc,class CRC { },-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3121,87671,_Test_StandardResults,4,leveldb.crc32c._Test_StandardResults,,util\crc32c_test.cc,_Test_StandardResults,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3122,87900,_Test_Values,4,leveldb.crc32c._Test_Values,,util\crc32c_test.cc,_Test_Values,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3123,87952,_Test_Extend,4,leveldb.crc32c._Test_Extend,,util\crc32c_test.cc,_Test_Extend,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3124,88007,_Test_Mask,4,leveldb.crc32c._Test_Mask,,util\crc32c_test.cc,_Test_Mask,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3125,88486,Limiter,4,leveldb.anonymous_namespace_2.Limiter,,util\env_posix.cc,"class Limiter {
 public:
  // Limit maximum number of resources to |n|.
  Limiter(intptr_t n) {
    SetAllowed(n);
  }

  // If another resource is available, acquire it and return true.
  // Else return false.
  bool Acquire() {
    if (GetAllowed() <= 0) {
      return false;
    }
    MutexLock l(&mu_);
    intptr_t x = GetAllowed();
    if (x <= 0) {
      return false;
    } else {
      SetAllowed(x - 1);
      return true;
    }
  }

  // Release a resource acquired by a previous call to Acquire() that returned
  // true.
  void Release() {
    MutexLock l(&mu_);
    SetAllowed(GetAllowed() + 1);
  }

 private:
  port::Mutex mu_;
  port::AtomicPointer allowed_;

  intptr_t GetAllowed() const {
    return reinterpret_cast<intptr_t>(allowed_.Acquire_Load());
  }

  // REQUIRES: mu_ must be held
  void SetAllowed(intptr_t v) {
    allowed_.Release_Store(reinterpret_cast<void*>(v));
  }

  Limiter(const Limiter&);
  void operator=(const Limiter&);
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3126,88575,PosixSequentialFile,4,leveldb.anonymous_namespace_16.PosixSequentialFile,,util\env_posix.cc,"class PosixSequentialFile: public SequentialFile {
 private:
  std::string filename_;
  FILE* file_;

 public:
  PosixSequentialFile(const std::string& fname, FILE* f)
      : filename_(fname), file_(f) { }
  virtual ~PosixSequentialFile() { fclose(file_); }

  virtual Status Read(size_t n, Slice* result, char* scratch) {
    Status s;
    size_t r = fread_unlocked(scratch, 1, n, file_);
    *result = Slice(scratch, r);
    if (r < n) {
      if (feof(file_)) {
        // We leave status as ok if we hit the end of the file
      } else {
        // A partial read with an error: return a non-ok status
        s = IOError(filename_, errno);
      }
    }
    return s;
  }

  virtual Status Skip(uint64_t n) {
    if (fseek(file_, n, SEEK_CUR)) {
      return IOError(filename_, errno);
    }
    return Status::OK();
  }
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3127,88650,PosixRandomAccessFile,4,leveldb.anonymous_namespace_21.PosixRandomAccessFile,,util\env_posix.cc,"class PosixRandomAccessFile: public RandomAccessFile {
 private:
  std::string filename_;
  bool temporary_fd_;  // If true, fd_ is -1 and we open on every read.
  int fd_;
  Limiter* limiter_;

 public:
  PosixRandomAccessFile(const std::string& fname, int fd, Limiter* limiter)
      : filename_(fname), fd_(fd), limiter_(limiter) {
    temporary_fd_ = !limiter->Acquire();
    if (temporary_fd_) {
      // Open file on every access.
      close(fd_);
      fd_ = -1;
    }
  }

  virtual ~PosixRandomAccessFile() {
    if (!temporary_fd_) {
      close(fd_);
      limiter_->Release();
    }
  }

  virtual Status Read(uint64_t offset, size_t n, Slice* result,
                      char* scratch) const {
    int fd = fd_;
    if (temporary_fd_) {
      fd = open(filename_.c_str(), O_RDONLY);
      if (fd < 0) {
        return IOError(filename_, errno);
      }
    }

    Status s;
    ssize_t r = pread(fd, scratch, n, static_cast<off_t>(offset));
    *result = Slice(scratch, (r < 0) ? 0...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3128,88763,PosixMmapReadableFile,4,leveldb.anonymous_namespace_25.PosixMmapReadableFile,,util\env_posix.cc,"class PosixMmapReadableFile: public RandomAccessFile {
 private:
  std::string filename_;
  void* mmapped_region_;
  size_t length_;
  Limiter* limiter_;

 public:
  // base[0,length-1] contains the mmapped contents of the file.
  PosixMmapReadableFile(const std::string& fname, void* base, size_t length,
                        Limiter* limiter)
      : filename_(fname), mmapped_region_(base), length_(length),
        limiter_(limiter) {
  }

  virtual ~PosixMmapReadableFile() {
    munmap(mmapped_region_, length_);
    limiter_->Release();
  }

  virtual Status Read(uint64_t offset, size_t n, Slice* result,
                      char* scratch) const {
    Status s;
    if (offset + n > length_) {
      *result = Slice();
      s = IOError(filename_, EINVAL);
    } else {
      *result = Slice(reinterpret_cast<char*>(mmapped_region_) + offset, n);
    }
    return s;
  }
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3129,88826,PosixWritableFile,4,leveldb.anonymous_namespace_29.PosixWritableFile,,util\env_posix.cc,"class PosixWritableFile : public WritableFile {
 private:
  std::string filename_;
  FILE* file_;

 public:
  PosixWritableFile(const std::string& fname, FILE* f)
      : filename_(fname), file_(f) { }

  ~PosixWritableFile() {
    if (file_ != NULL) {
      // Ignoring any potential errors
      fclose(file_);
    }
  }

  virtual Status Append(const Slice& data) {
    size_t r = fwrite_unlocked(data.data(), 1, data.size(), file_);
    if (r != data.size()) {
      return IOError(filename_, errno);
    }
    return Status::OK();
  }

  virtual Status Close() {
    Status result;
    if (fclose(file_) != 0) {
      result = IOError(filename_, errno);
    }
    file_ = NULL;
    return result;
  }

  virtual Status Flush() {
    if (fflush_unlocked(file_) != 0) {
      return IOError(filename_, errno);
    }
    return Status::OK();
  }

  Status SyncDirIfManifest() {
    const char* f = filename_.c_str();
    const char* sep = strrchr(f, '/');
    Slice basename;
    std::string dir...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3130,89098,PosixFileLock,4,leveldb.anonymous_namespace_39.PosixFileLock,,util\env_posix.cc,"class PosixFileLock : public FileLock {
 public:
  int fd_;
  std::string name_;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3131,89101,PosixLockTable,4,leveldb.anonymous_namespace_40.PosixLockTable,,util\env_posix.cc,"class PosixLockTable {
 private:
  port::Mutex mu_;
  std::set<std::string> locked_files_;
 public:
  bool Insert(const std::string& fname) {
    MutexLock l(&mu_);
    return locked_files_.insert(fname).second;
  }
  void Remove(const std::string& fname) {
    MutexLock l(&mu_);
    locked_files_.erase(fname);
  }
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3132,89135,PosixEnv,4,leveldb.anonymous_namespace_43.PosixEnv,,util\env_posix.cc,"class PosixEnv : public Env {
 public:
  PosixEnv();
  virtual ~PosixEnv() {
    char msg[] = ""Destroying Env::Default()\n"";
    fwrite(msg, 1, sizeof(msg), stderr);
    abort();
  }

  virtual Status NewSequentialFile(const std::string& fname,
                                   SequentialFile** result) {
    FILE* f = fopen(fname.c_str(), ""r"");
    if (f == NULL) {
      *result = NULL;
      return IOError(fname, errno);
    } else {
      *result = new PosixSequentialFile(fname, f);
      return Status::OK();
    }
  }

  virtual Status NewRandomAccessFile(const std::string& fname,
                                     RandomAccessFile** result) {
    *result = NULL;
    Status s;
    int fd = open(fname.c_str(), O_RDONLY);
    if (fd < 0) {
      s = IOError(fname, errno);
    } else if (mmap_limit_.Acquire()) {
      uint64_t size;
      s = GetFileSize(fname, &size);
      if (s.ok()) {
        void* base = mmap(NULL, size, PROT_READ, MAP_SHARED, fd, 0);
        if (base != MAP...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3133,89925,BGItem,4,leveldb.anonymous_namespace_73.PosixEnv.BGItem,,util\env_posix.cc,struct BGItem { void* arg; void (*function)(void*); },-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3134,89932,BGQueue,4,BGQueue,,util\env_posix.cc,typedef std::deque<BGItem> BGQueue;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3135,90143,StartThreadState,4,leveldb.anonymous_namespace_83.anonymous_namespace_84.StartThreadState,,util\env_posix.cc,"struct StartThreadState {
  void (*user_function)(void*);
  void* arg;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3136,90276,EnvPosixTest,4,leveldb.EnvPosixTest,,util\env_posix_test.cc,"class EnvPosixTest {
 public:
  Env* env_;
  EnvPosixTest() : env_(Env::Default()) { }

  static void SetFileLimits(int read_only_file_limit, int mmap_limit) {
    EnvPosixTestHelper::SetReadOnlyFDLimit(read_only_file_limit);
    EnvPosixTestHelper::SetReadOnlyMMapLimit(mmap_limit);
  }
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3137,90298,_Test_TestOpenOnRead,4,leveldb._Test_TestOpenOnRead,,util\env_posix_test.cc,_Test_TestOpenOnRead,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3138,90579,EnvPosixTest,4,leveldb.EnvPosixTest,,util\env_posix_test_helper.hpp,class EnvPosixTest,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3139,90580,EnvPosixTestHelper,4,leveldb.EnvPosixTestHelper,,util\env_posix_test_helper.hpp,"class EnvPosixTestHelper {
 private:
  friend class EnvPosixTest;

  // Set the maximum number of read-only files that will be opened.
  // Must be called before creating an Env.
  static void SetReadOnlyFDLimit(int limit);

  // Set the maximum number of read-only files that will be mapped via mmap.
  // Must be called before creating an Env.
  static void SetReadOnlyMMapLimit(int limit);
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3140,90581,EnvPosixTest,4,leveldb.EnvPosixTestHelper.EnvPosixTest,,util\env_posix_test_helper.hpp,friend class EnvPosixTest,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3141,90616,EnvTest,4,leveldb.EnvTest,,util\env_test.cc,"class EnvTest {
 private:
  port::Mutex mu_;
  std::string events_;

 public:
  Env* env_;
  EnvTest() : env_(Env::Default()) { }
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3142,90636,_Test_RunImmediately,4,leveldb._Test_RunImmediately,,util\env_test.cc,_Test_RunImmediately,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3143,90705,_Test_RunMany,4,leveldb._Test_RunMany,,util\env_test.cc,_Test_RunMany,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3144,90834,State,4,leveldb.State,,util\env_test.cc,"struct State {
  port::Mutex mu;
  int val;
  int num_running;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3145,90871,_Test_StartThread,4,leveldb._Test_StartThread,,util\env_test.cc,_Test_StartThread,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3146,91164,HASH,4,leveldb.HASH,,util\hash_test.cc,class HASH { },-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3147,91165,_Test_SignedUnsignedIssue,4,leveldb._Test_SignedUnsignedIssue,,util\hash_test.cc,_Test_SignedUnsignedIssue,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3148,92056,Histogram,4,leveldb.Histogram,,util\histogram.hpp,"class Histogram {
 public:
  Histogram() { }
  ~Histogram() { }

  void Clear();
  void Add(double value);
  void Merge(const Histogram& other);

  std::string ToString() const;

 private:
  double min_;
  double max_;
  double num_;
  double sum_;
  double sum_squares_;

  enum { kNumBuckets = 154 };
  static const double kBucketLimit[kNumBuckets];
  double buckets_[kNumBuckets];

  double Median() const;
  double Percentile(double p) const;
  double Average() const;
  double StandardDeviation() const;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3149,92088,anonymous_enum_0,4,leveldb.Histogram.anonymous_enum_0,,util\histogram.hpp,enum { kNumBuckets = 154 },-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3150,92357,Slice,4,leveldb.Slice,,util\logging.hpp,class Slice,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3151,92358,WritableFile,4,leveldb.WritableFile,,util\logging.hpp,class WritableFile,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3152,92397,MutexLock,4,leveldb.MutexLock,,util\mutexlock.hpp,"class SCOPED_LOCKABLE MutexLock {
 public:
  explicit MutexLock(port::Mutex *mu) EXCLUSIVE_LOCK_FUNCTION(mu)
      : mu_(mu)  {
    this->mu_->Lock();
  }
  ~MutexLock() UNLOCK_FUNCTION() { this->mu_->Unlock(); }

 private:
  port::Mutex *const mu_;
  // No copying allowed
  MutexLock(const MutexLock&);
  void operator=(const MutexLock&);
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3153,92462,PosixLogger,4,leveldb.PosixLogger,,util\posix_logger.hpp,"class PosixLogger : public Logger {
 private:
  FILE* file_;
  uint64_t (*gettid_)();  // Return the thread id for the current thread
 public:
  PosixLogger(FILE* f, uint64_t (*gettid)()) : file_(f), gettid_(gettid) { }
  virtual ~PosixLogger() {
    fclose(file_);
  }
  virtual void Logv(const char* format, va_list ap) {
    const uint64_t thread_id = (*gettid_)();

    // We try twice: the first time with a fixed-size stack allocated buffer,
    // and the second time with a much larger dynamically allocated buffer.
    char buffer[500];
    for (int iter = 0; iter < 2; iter++) {
      char* base;
      int bufsize;
      if (iter == 0) {
        bufsize = sizeof(buffer);
        base = buffer;
      } else {
        bufsize = 30000;
        base = new char[bufsize];
      }
      char* p = base;
      char* limit = base + bufsize;

      struct timeval now_tv;
      gettimeofday(&now_tv, NULL);
      const time_t seconds = now_tv.tv_sec;
      struct tm t;
      localtime_r(&seco...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3154,92677,Random,4,leveldb.Random,,util\random.hpp,"class Random {
 private:
  uint32_t seed_;
 public:
  explicit Random(uint32_t s) : seed_(s & 0x7fffffffu) {
    // Avoid bad seeds.
    if (seed_ == 0 || seed_ == 2147483647L) {
      seed_ = 1;
    }
  }
  uint32_t Next() {
    static const uint32_t M = 2147483647L;   // 2^31-1
    static const uint64_t A = 16807;  // bits 14, 8, 7, 5, 2, 1, 0
    // We are computing
    //       seed_ = (seed_ * A) % M,    where M = 2^31-1
    //
    // seed_ must not be zero or M, or else all subsequent computed values
    // will be zero or M respectively.  For all other values, seed_ will end
    // up cycling through every number in [1,M-1]
    uint64_t product = seed_ * A;

    // Compute (product % M) using the fact that ((x << 31) % M) == x.
    seed_ = static_cast<uint32_t>((product >> 31) + (product & M));
    // The first reduction may overflow by 1 bit, so we may need to
    // repeat.  mod == M is not possible; using > allows the faster
    // sign-bit-based test.
    if (seed_ > M) {...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3155,93004,Test,4,leveldb.test.anonymous_namespace_1.Test,,util\testharness.cc,"struct Test {
  const char* base;
  const char* name;
  void (*func)();
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3156,93253,Tester,4,leveldb.test.Tester,,util\testharness.hpp,"class Tester {
 private:
  bool ok_;
  const char* fname_;
  int line_;
  std::stringstream ss_;

 public:
  Tester(const char* f, int l)
      : ok_(true), fname_(f), line_(l) {
  }

  ~Tester() {
    if (!ok_) {
      fprintf(stderr, ""%s:%d:%s\n"", fname_, line_, ss_.str().c_str());
      exit(1);
    }
  }

  Tester& Is(bool b, const char* msg) {
    if (!b) {
      ss_ << "" Assertion failure "" << msg;
      ok_ = false;
    }
    return *this;
  }

  Tester& IsOk(const Status& s) {
    if (!s.ok()) {
      ss_ << "" "" << s.ToString();
      ok_ = false;
    }
    return *this;
  }

#define BINARY_OP(name,op)                              \
  template <class X, class Y>                           \
  Tester& name(const X& x, const Y& y) {                \
    if (! (x op y)) {                                   \
      ss_ << "" failed: "" << x << ("" "" #op "" "") << y;    \
      ok_ = false;                                      \
    }                                                   \
...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3157,93707,ErrorEnv,4,leveldb.test.ErrorEnv,,util\testutil.hpp,"class ErrorEnv : public EnvWrapper {
 public:
  bool writable_file_error_;
  int num_writable_file_errors_;

  ErrorEnv() : EnvWrapper(Env::Default()),
               writable_file_error_(false),
               num_writable_file_errors_(0) { }

  virtual Status NewWritableFile(const std::string& fname,
                                 WritableFile** result) {
    if (writable_file_error_) {
      ++num_writable_file_errors_;
      *result = NULL;
      return Status::IOError(fname, ""fake error"");
    }
    return target()->NewWritableFile(fname, result);
  }

  virtual Status NewAppendableFile(const std::string& fname,
                                   WritableFile** result) {
    if (writable_file_error_) {
      ++num_writable_file_errors_;
      *result = NULL;
      return Status::IOError(fname, ""fake error"");
    }
    return target()->NewAppendableFile(fname, result);
  }
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3158,2365,phase,2,db\c_test.c.phase,,db\c_test.c,const char* phase,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
3159,2369,dbname,2,db\c_test.c.dbname,,db\c_test.c,char[200] dbname,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3160,2721,fake_filter_result,2,db\c_test.c.fake_filter_result,,db\c_test.c,static unsigned char fake_filter_result,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
3161,5953,FLAGS_benchmarks,2,db\db_bench.cc.FLAGS_benchmarks,,db\db_bench.cc,static const char* FLAGS_benchmarks,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
3162,5957,FLAGS_num,2,db\db_bench.cc.FLAGS_num,,db\db_bench.cc,static int FLAGS_num,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
3163,5961,FLAGS_reads,2,db\db_bench.cc.FLAGS_reads,,db\db_bench.cc,static int FLAGS_reads,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
3164,5966,FLAGS_threads,2,db\db_bench.cc.FLAGS_threads,,db\db_bench.cc,static int FLAGS_threads,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
3165,5970,FLAGS_value_size,2,db\db_bench.cc.FLAGS_value_size,,db\db_bench.cc,static int FLAGS_value_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
3166,5974,FLAGS_compression_ratio,2,db\db_bench.cc.FLAGS_compression_ratio,,db\db_bench.cc,static double FLAGS_compression_ratio,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
3167,5978,FLAGS_histogram,2,db\db_bench.cc.FLAGS_histogram,,db\db_bench.cc,static bool FLAGS_histogram,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
3168,5982,FLAGS_write_buffer_size,2,db\db_bench.cc.FLAGS_write_buffer_size,,db\db_bench.cc,static int FLAGS_write_buffer_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
3169,5986,FLAGS_max_file_size,2,db\db_bench.cc.FLAGS_max_file_size,,db\db_bench.cc,static int FLAGS_max_file_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
3170,5990,FLAGS_block_size,2,db\db_bench.cc.FLAGS_block_size,,db\db_bench.cc,static int FLAGS_block_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
3171,5994,FLAGS_cache_size,2,db\db_bench.cc.FLAGS_cache_size,,db\db_bench.cc,static int FLAGS_cache_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3172,5999,FLAGS_open_files,2,db\db_bench.cc.FLAGS_open_files,,db\db_bench.cc,static int FLAGS_open_files,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
3173,6003,FLAGS_bloom_bits,2,db\db_bench.cc.FLAGS_bloom_bits,,db\db_bench.cc,static int FLAGS_bloom_bits,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3174,6008,FLAGS_use_existing_db,2,db\db_bench.cc.FLAGS_use_existing_db,,db\db_bench.cc,static bool FLAGS_use_existing_db,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
3175,6012,FLAGS_reuse_logs,2,db\db_bench.cc.FLAGS_reuse_logs,,db\db_bench.cc,static bool FLAGS_reuse_logs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
3176,6016,FLAGS_db,2,db\db_bench.cc.FLAGS_db,,db\db_bench.cc,static const char* FLAGS_db,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
3177,57732,FLAGS_benchmarks,2,doc\bench\db_bench_sqlite3.cc.FLAGS_benchmarks,,doc\bench\db_bench_sqlite3.cc,static const char* FLAGS_benchmarks,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3178,57736,FLAGS_num,2,doc\bench\db_bench_sqlite3.cc.FLAGS_num,,doc\bench\db_bench_sqlite3.cc,static int FLAGS_num,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3179,57740,FLAGS_reads,2,doc\bench\db_bench_sqlite3.cc.FLAGS_reads,,doc\bench\db_bench_sqlite3.cc,static int FLAGS_reads,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3180,57745,FLAGS_value_size,2,doc\bench\db_bench_sqlite3.cc.FLAGS_value_size,,doc\bench\db_bench_sqlite3.cc,static int FLAGS_value_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3181,57749,FLAGS_histogram,2,doc\bench\db_bench_sqlite3.cc.FLAGS_histogram,,doc\bench\db_bench_sqlite3.cc,static bool FLAGS_histogram,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
3182,57753,FLAGS_compression_ratio,2,doc\bench\db_bench_sqlite3.cc.FLAGS_compression_ratio,,doc\bench\db_bench_sqlite3.cc,static double FLAGS_compression_ratio,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3183,57757,FLAGS_page_size,2,doc\bench\db_bench_sqlite3.cc.FLAGS_page_size,,doc\bench\db_bench_sqlite3.cc,static int FLAGS_page_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3184,57761,FLAGS_num_pages,2,doc\bench\db_bench_sqlite3.cc.FLAGS_num_pages,,doc\bench\db_bench_sqlite3.cc,static int FLAGS_num_pages,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3185,57765,FLAGS_use_existing_db,2,doc\bench\db_bench_sqlite3.cc.FLAGS_use_existing_db,,doc\bench\db_bench_sqlite3.cc,static bool FLAGS_use_existing_db,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
3186,57769,FLAGS_transaction,2,doc\bench\db_bench_sqlite3.cc.FLAGS_transaction,,doc\bench\db_bench_sqlite3.cc,static bool FLAGS_transaction,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
3187,57773,FLAGS_WAL_enabled,2,doc\bench\db_bench_sqlite3.cc.FLAGS_WAL_enabled,,doc\bench\db_bench_sqlite3.cc,static bool FLAGS_WAL_enabled,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
3188,57777,FLAGS_db,2,doc\bench\db_bench_sqlite3.cc.FLAGS_db,,doc\bench\db_bench_sqlite3.cc,static const char* FLAGS_db,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3189,59794,FLAGS_benchmarks,2,doc\bench\db_bench_tree_db.cc.FLAGS_benchmarks,,doc\bench\db_bench_tree_db.cc,static const char* FLAGS_benchmarks,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3190,59798,FLAGS_num,2,doc\bench\db_bench_tree_db.cc.FLAGS_num,,doc\bench\db_bench_tree_db.cc,static int FLAGS_num,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3191,59802,FLAGS_reads,2,doc\bench\db_bench_tree_db.cc.FLAGS_reads,,doc\bench\db_bench_tree_db.cc,static int FLAGS_reads,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3192,59807,FLAGS_value_size,2,doc\bench\db_bench_tree_db.cc.FLAGS_value_size,,doc\bench\db_bench_tree_db.cc,static int FLAGS_value_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3193,59811,FLAGS_compression_ratio,2,doc\bench\db_bench_tree_db.cc.FLAGS_compression_ratio,,doc\bench\db_bench_tree_db.cc,static double FLAGS_compression_ratio,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3194,59815,FLAGS_histogram,2,doc\bench\db_bench_tree_db.cc.FLAGS_histogram,,doc\bench\db_bench_tree_db.cc,static bool FLAGS_histogram,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3195,59819,FLAGS_cache_size,2,doc\bench\db_bench_tree_db.cc.FLAGS_cache_size,,doc\bench\db_bench_tree_db.cc,static int FLAGS_cache_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3196,59823,FLAGS_page_size,2,doc\bench\db_bench_tree_db.cc.FLAGS_page_size,,doc\bench\db_bench_tree_db.cc,static int FLAGS_page_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3197,59827,FLAGS_use_existing_db,2,doc\bench\db_bench_tree_db.cc.FLAGS_use_existing_db,,doc\bench\db_bench_tree_db.cc,static bool FLAGS_use_existing_db,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3198,59831,FLAGS_compression,2,doc\bench\db_bench_tree_db.cc.FLAGS_compression,,doc\bench\db_bench_tree_db.cc,static bool FLAGS_compression,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3199,59835,FLAGS_db,2,doc\bench\db_bench_tree_db.cc.FLAGS_db,,doc\bench\db_bench_tree_db.cc,static const char* FLAGS_db,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
