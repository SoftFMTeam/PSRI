31,METHOD,assoc.c:<global>,TYPE_DECL,<global>,1,1,assoc.c,assoc.c:<global>,,false,1,360,<global>,,,1,
63,METHOD,assoc.c:<global>,TYPE_DECL,"void assoc_init(const int hashtable_init) {
    if (hashtable_init) {
        hashpower = hashtable_init;
    }
    primary_hashtable = calloc(hashsize(hashpower), sizeof(void *));
    if (! primary_hashtable) {
        fprintf(stderr, ""Failed to init hashtable.\n"");
        exit(EXIT_FAILURE);
    }
    STATS_LOCK();
    stats_state.hash_power_level = hashpower;
    stats_state.hash_bytes = hashsize(hashpower) * sizeof(void *);
    STATS_UNLOCK();
}",1,31,assoc.c,assoc_init,,false,55,68,assoc_init,,,15,void assoc_init (int)
118,METHOD,assoc.c:<global>,TYPE_DECL,"item *assoc_find(const char *key, const size_t nkey, const uint32_t hv) {
    item *it;
    uint64_t oldbucket;

    if (expanding &&
        (oldbucket = (hv & hashmask(hashpower - 1))) >= expand_bucket)
    {
        it = old_hashtable[oldbucket];
    } else {
        it = primary_hashtable[hv & hashmask(hashpower)];
    }

    item *ret = NULL;
    int depth = 0;
    while (it) {
        if ((nkey == it->nkey) && (memcmp(key, ITEM_key(it), nkey) == 0)) {
            ret = it;
            break;
        }
        it = it->h_next;
        ++depth;
    }
    MEMCACHED_ASSOC_FIND(key, nkey, depth);
    return ret;
}",1,27,assoc.c,assoc_find,,false,70,94,assoc_find,,,16,"item assoc_find (char*,size_t,uint32_t)"
227,METHOD,assoc.c:<global>,TYPE_DECL,"static item** _hashitem_before (const char *key, const size_t nkey, const uint32_t hv) {
    item **pos;
    uint64_t oldbucket;

    if (expanding &&
        (oldbucket = (hv & hashmask(hashpower - 1))) >= expand_bucket)
    {
        pos = &old_hashtable[oldbucket];
    } else {
        pos = &primary_hashtable[hv & hashmask(hashpower)];
    }

    while (*pos && ((nkey != (*pos)->nkey) || memcmp(key, ITEM_key(*pos), nkey))) {
        pos = &(*pos)->h_next;
    }
    return pos;
}",1,27,assoc.c,_hashitem_before,,false,99,115,_hashitem_before,,,17,"item _hashitem_before (char*,size_t,uint32_t)"
328,METHOD,assoc.c:<global>,TYPE_DECL,"static void assoc_expand(void) {
    old_hashtable = primary_hashtable;

    primary_hashtable = calloc(hashsize(hashpower + 1), sizeof(void *));
    if (primary_hashtable) {
        if (settings.verbose > 1)
            fprintf(stderr, ""Hash table expansion starting\n"");
        hashpower++;
        expanding = true;
        expand_bucket = 0;
        STATS_LOCK();
        stats_state.hash_power_level = hashpower;
        stats_state.hash_bytes += hashsize(hashpower) * sizeof(void *);
        stats_state.hash_is_expanding = true;
        STATS_UNLOCK();
    } else {
        primary_hashtable = old_hashtable;
        /* Bad news, but we can keep running. */
    }
}",1,31,assoc.c,assoc_expand,,false,118,137,assoc_expand,,,18,void assoc_expand (void)
403,METHOD,assoc.c:<global>,TYPE_DECL,"void assoc_start_expand(uint64_t curr_items) {
    if (pthread_mutex_trylock(&maintenance_lock) == 0) {
        if (curr_items > (hashsize(hashpower) * 3) / 2 && hashpower < HASHPOWER_MAX) {
            pthread_cond_signal(&maintenance_cond);
        }
        pthread_mutex_unlock(&maintenance_lock);
    }
}",1,26,assoc.c,assoc_start_expand,,false,139,146,assoc_start_expand,,,19,void assoc_start_expand (uint64_t)
443,METHOD,assoc.c:<global>,TYPE_DECL,"int assoc_insert(item *it, const uint32_t hv) {
    uint64_t oldbucket;

//    assert(assoc_find(ITEM_key(it), it->nkey) == 0);  /* shouldn't have duplicately named things defined */

    if (expanding &&
        (oldbucket = (hv & hashmask(hashpower - 1))) >= expand_bucket)
    {
        it->h_next = old_hashtable[oldbucket];
        old_hashtable[oldbucket] = it;
    } else {
        it->h_next = primary_hashtable[hv & hashmask(hashpower)];
        primary_hashtable[hv & hashmask(hashpower)] = it;
    }

    MEMCACHED_ASSOC_INSERT(ITEM_key(it), it->nkey);
    return 1;
}",1,27,assoc.c,assoc_insert,,false,149,166,assoc_insert,,,20,"int assoc_insert (item*,uint32_t)"
521,METHOD,assoc.c:<global>,TYPE_DECL,"void assoc_delete(const char *key, const size_t nkey, const uint32_t hv) {
    item **before = _hashitem_before(key, nkey, hv);

    if (*before) {
        item *nxt;
        /* The DTrace probe cannot be triggered as the last instruction
         * due to possible tail-optimization by the compiler
         */
        MEMCACHED_ASSOC_DELETE(key, nkey);
        nxt = (*before)->h_next;
        (*before)->h_next = 0;   /* probably pointless, but whatever. */
        *before = nxt;
        return;
    }
    /* Note:  we never actually get here.  the callers don't delete things
       they can't find. */
    assert(*before != 0);
}",1,8,assoc.c,assoc_delete,,false,168,185,assoc_delete,,,21,"void assoc_delete (char*,size_t,uint32_t)"
572,METHOD,assoc.c:<global>,TYPE_DECL,"static void *assoc_maintenance_thread(void *arg) {

    mutex_lock(&maintenance_lock);
    while (do_run_maintenance_thread) {
        int ii = 0;

        /* There is only one expansion thread, so no need to global lock. */
        for (ii = 0; ii < hash_bulk_move && expanding; ++ii) {
            item *it, *next;
            uint64_t bucket;
            void *item_lock = NULL;

            /* bucket = hv & hashmask(hashpower) =>the bucket of hash table
             * is the lowest N bits of the hv, and the bucket of item_locks is
             *  also the lowest M bits of hv, and N is greater than M.
             *  So we can process expanding with only one item_lock. cool! */
            if ((item_lock = item_trylock(expand_bucket))) {
                    for (it = old_hashtable[expand_bucket]; NULL != it; it = next) {
                        next = it->h_next;
                        bucket = hash(ITEM_key(it), it->nkey) & hashmask(hashpower);
                        it->h_next =...",1,4,assoc.c,assoc_maintenance_thread,,false,193,260,assoc_maintenance_thread,,,26,void* assoc_maintenance_thread (void*)
783,METHOD,assoc.c:<global>,TYPE_DECL,"int start_assoc_maintenance_thread() {
    int ret;
    char *env = getenv(""MEMCACHED_HASH_BULK_MOVE"");
    if (env != NULL) {
        hash_bulk_move = atoi(env);
        if (hash_bulk_move == 0) {
            hash_bulk_move = DEFAULT_HASH_BULK_MOVE;
        }
    }

    if ((ret = pthread_create(&maintenance_tid, NULL,
                              assoc_maintenance_thread, NULL)) != 0) {
        fprintf(stderr, ""Can't create thread: %s\n"", strerror(ret));
        return -1;
    }
    return 0;
}",1,29,assoc.c,start_assoc_maintenance_thread,,false,264,280,start_assoc_maintenance_thread,,,28,int start_assoc_maintenance_thread ()
834,METHOD,assoc.c:<global>,TYPE_DECL,"void stop_assoc_maintenance_thread() {
    mutex_lock(&maintenance_lock);
    do_run_maintenance_thread = 0;
    pthread_cond_signal(&maintenance_cond);
    mutex_unlock(&maintenance_lock);

    /* Wait for the maintenance thread to stop */
    pthread_join(maintenance_tid, NULL);
}",1,4,assoc.c,stop_assoc_maintenance_thread,,false,282,290,stop_assoc_maintenance_thread,,,29,void stop_assoc_maintenance_thread ()
866,METHOD,assoc.c:<global>,TYPE_DECL,"void *assoc_get_iterator(void) {
    struct assoc_iterator *iter = calloc(1, sizeof(struct assoc_iterator));
    if (iter == NULL) {
        return NULL;
    }
    // this will hang the caller while a hash table expansion is running.
    mutex_lock(&maintenance_lock);
    return iter;
}",1,4,assoc.c,assoc_get_iterator,,false,299,307,assoc_get_iterator,,,31,void* assoc_get_iterator (void)
894,METHOD,assoc.c:<global>,TYPE_DECL,"bool assoc_iterate(void *iterp, item **it) {
    struct assoc_iterator *iter = (struct assoc_iterator *) iterp;
    *it = NULL;
    // - if locked bucket and next, update next and return
    if (iter->bucket_locked) {
        if (iter->next != NULL) {
            iter->it = iter->next;
            iter->next = iter->it->h_next;
            *it = iter->it;
        } else {
            // unlock previous bucket, if any
            item_unlock(iter->bucket);
            // iterate the bucket post since it starts at 0.
            iter->bucket++;
            iter->bucket_locked = false;
            *it = NULL;
        }
        return true;
    }

    // - loop until we hit the end or find something.
    if (iter->bucket != hashsize(hashpower)) {
        // - lock next bucket
        item_lock(iter->bucket);
        iter->bucket_locked = true;
        // - only check the primary hash table since expand is blocked.
        iter->it = primary_hashtable[iter->bucket];
        if (iter->it ...",1,24,assoc.c,assoc_iterate,,false,309,351,assoc_iterate,,,32,"bool assoc_iterate (void*,item**)"
1040,METHOD,assoc.c:<global>,TYPE_DECL,"void assoc_iterate_final(void *iterp) {
    struct assoc_iterator *iter = (struct assoc_iterator *) iterp;
    if (iter->bucket_locked) {
        item_unlock(iter->bucket);
    }
    mutex_unlock(&maintenance_lock);
    free(iter);
}",1,4,assoc.c,assoc_iterate_final,,false,353,360,assoc_iterate_final,,,33,void assoc_iterate_final (void*)
1072,METHOD,assoc.h:<global>,TYPE_DECL,<global>,1,40,assoc.h,assoc.h:<global>,,false,1,16,<global>,,,1,
1074,METHOD,assoc.h:<global>,TYPE_DECL,void assoc_init(const int hashpower_init);,6,41,assoc.h,assoc_init,,false,2,2,assoc_init,,,1,void assoc_init (int)
1079,METHOD,assoc.h:<global>,TYPE_DECL,"item *assoc_find(const char *key, const size_t nkey, const uint32_t hv);",6,71,assoc.h,assoc_find,,false,3,3,assoc_find,,,2,"item* assoc_find (char*,size_t,uint32_t)"
1086,METHOD,assoc.h:<global>,TYPE_DECL,"int assoc_insert(item *item, const uint32_t hv);",5,47,assoc.h,assoc_insert,,false,4,4,assoc_insert,,,3,"int assoc_insert (item*,uint32_t)"
1092,METHOD,assoc.h:<global>,TYPE_DECL,"void assoc_delete(const char *key, const size_t nkey, const uint32_t hv);",6,72,assoc.h,assoc_delete,,false,5,5,assoc_delete,,,4,"void assoc_delete (char*,size_t,uint32_t)"
1099,METHOD,assoc.h:<global>,TYPE_DECL,void do_assoc_move_next_bucket(void);,6,36,assoc.h,do_assoc_move_next_bucket,,false,6,6,do_assoc_move_next_bucket,,,5,void do_assoc_move_next_bucket (void)
1104,METHOD,assoc.h:<global>,TYPE_DECL,int start_assoc_maintenance_thread(void);,5,40,assoc.h,start_assoc_maintenance_thread,,false,7,7,start_assoc_maintenance_thread,,,6,int start_assoc_maintenance_thread (void)
1109,METHOD,assoc.h:<global>,TYPE_DECL,void stop_assoc_maintenance_thread(void);,6,40,assoc.h,stop_assoc_maintenance_thread,,false,8,8,stop_assoc_maintenance_thread,,,7,void stop_assoc_maintenance_thread (void)
1114,METHOD,assoc.h:<global>,TYPE_DECL,void assoc_start_expand(uint64_t curr_items);,6,44,assoc.h,assoc_start_expand,,false,9,9,assoc_start_expand,,,8,void assoc_start_expand (uint64_t)
1119,METHOD,assoc.h:<global>,TYPE_DECL,void *assoc_get_iterator(void);,6,30,assoc.h,assoc_get_iterator,,false,11,11,assoc_get_iterator,,,9,void* assoc_get_iterator (void)
1124,METHOD,assoc.h:<global>,TYPE_DECL,"bool assoc_iterate(void *iterp, item **it);",6,42,assoc.h,assoc_iterate,,false,12,12,assoc_iterate,,,10,"bool assoc_iterate (void*,item**)"
1130,METHOD,assoc.h:<global>,TYPE_DECL,void assoc_iterate_final(void *iterp);,6,37,assoc.h,assoc_iterate_final,,false,13,13,assoc_iterate_final,,,11,void assoc_iterate_final (void*)
1160,METHOD,authfile.c:<global>,TYPE_DECL,<global>,1,1,authfile.c,authfile.c:<global>,,false,1,126,<global>,,,1,
1181,METHOD,authfile.c:<global>,TYPE_DECL,"enum authfile_ret authfile_load(const char *file) {
    struct stat sb;
    char *auth_data = NULL;
    auth_t auth_entries[MAX_ENTRIES];

    FILE *pwfile = fopen(file, ""r"");
    if (pwfile == NULL) {
        return AUTHFILE_OPENFAIL;
    } else if (fstat(fileno(pwfile), &sb)) {
        fclose(pwfile);
        return AUTHFILE_STATFAIL;
    }

    auth_data = calloc(1, sb.st_size + 1);

    char *auth_cur = auth_data;
    char *auth_end = auth_data + sb.st_size;
    auth_t *entry_cur = auth_entries;
    int used = 0;

    while ((fgets(auth_cur, auth_end - auth_cur < MAX_ENTRY_LEN ? auth_end - auth_cur : MAX_ENTRY_LEN, pwfile)) != NULL) {
        int x;
        int found = 0;

        for (x = 0; x < MAX_ENTRY_LEN; x++) {
            if (!found) {
                if (auth_cur[x] == '\0') {
                    // The username is malformed - this is either the end of the file or a null byte.
                    break;
                } else if (auth_cur[x] == ':') {
                  ...",1,24,authfile.c,authfile_load,,false,31,109,authfile_load,,,9,enum authfile_ret authfile_load (char*)
1421,METHOD,authfile.c:<global>,TYPE_DECL,"int authfile_check(const char *user, const char *pass) {
    size_t ulen = strlen(user);
    size_t plen = strlen(pass);

    for (int x = 0; x < entry_cnt; x++) {
        auth_t *e = &main_auth_entries[x];
        if (ulen == e->ulen && plen == e->plen &&
            safe_memcmp(user, e->user, e->ulen) &&
            safe_memcmp(pass, e->pass, e->plen)) {
            return 1;
        }
    }

    return 0;
}",1,1,authfile.c,authfile_check,,false,112,126,authfile_check,,,10,"int authfile_check (char*,char*)"
1494,METHOD,authfile.h:<global>,TYPE_DECL,<global>,1,23,authfile.h,authfile.h:<global>,,false,1,16,<global>,,,1,
1502,METHOD,<empty>,<empty>,<empty>,1,,authfile.h,authfile_ret:<clinit>,,false,4,,<clinit>,,,6,
1511,METHOD,authfile.h:<global>,TYPE_DECL,"int authfile_check(const char *user, const char *pass);",5,54,authfile.h,authfile_check,,false,14,14,authfile_check,,,4,"int authfile_check (char*,char*)"
1524,METHOD,base64.c:<global>,TYPE_DECL,<global>,1,20,base64.c,base64.c:<global>,,false,1,205,<global>,,,1,
1790,METHOD,base64.c:<global>,TYPE_DECL,"size_t base64_encode(const unsigned char *src, size_t len,
                  unsigned char *out, size_t out_len)
{
    unsigned char *pos;
    const unsigned char *end, *in;
    size_t olen;

    olen = len * 4 / 3 + 4; /* 3-byte blocks to 4-byte */
    olen += olen / 72; /* line feeds */
    olen++; /* nul termination */
    if (olen < len) {
        return 0; /* integer overflow */
    }
    if (olen > out_len) {
        return 0; /* not enough space in output buffer */
    }
    if (out == NULL) {
        return 0;
    }

    end = src + len;
    in = src;
    pos = out;
    while (end - in >= 3) {
        *pos++ = base64_table[in[0] >> 2];
        *pos++ = base64_table[((in[0] & 0x03) << 4) | (in[1] >> 4)];
        *pos++ = base64_table[((in[1] & 0x0f) << 2) | (in[2] >> 6)];
        *pos++ = base64_table[in[2] & 0x3f];
        in += 3;
    }

    if (end - in) {
        *pos++ = base64_table[in[0] >> 2];
        if (end - in == 1) {
            *pos++ = base64_table[(in[0] & 0x0...",1,1,base64.c,base64_encode,,false,93,139,base64_encode,,,5,"size_t base64_encode (unsigned char*,size_t,unsigned char*,size_t)"
2008,METHOD,base64.c:<global>,TYPE_DECL,"size_t base64_decode(const unsigned char *src, size_t len,
                  unsigned char *out, size_t out_len)
{
    unsigned char *pos, block[4], tmp;
    size_t i, count, olen;
    int pad = 0;

    count = 0;
    for (i = 0; i < len; i++) {
        if (dtable[src[i]] != 0x80)
            count++;
    }

    if (count == 0 || count % 4)
        return 0;

    olen = count / 4 * 3;
    if (olen > out_len) {
        return 0;
    }
    pos = out;
    if (out == NULL) {
        return 0;
    }

    count = 0;
    for (i = 0; i < len; i++) {
        tmp = dtable[src[i]];
        if (tmp == 0x80)
            continue;

        if (src[i] == '=')
            pad++;
        block[count] = tmp;
        count++;
        if (count == 4) {
            *pos++ = (block[0] << 2) | (block[1] >> 4);
            *pos++ = (block[1] << 4) | (block[2] >> 2);
            *pos++ = (block[2] << 6) | block[3];
            count = 0;
            if (pad) {
                if (pad == 1)
                 ...",1,1,base64.c,base64_decode,,false,150,205,base64_decode,,,6,"size_t base64_decode (unsigned char*,size_t,unsigned char*,size_t)"
2212,METHOD,base64.h:<global>,TYPE_DECL,<global>,1,21,base64.h,base64.h:<global>,,false,1,17,<global>,,,1,
2214,METHOD,base64.h:<global>,TYPE_DECL,"size_t base64_encode(const unsigned char *src, size_t len,
                  unsigned char *out, size_t out_len);",8,53,base64.h,base64_encode,,false,12,13,base64_encode,,,1,"size_t base64_encode (unsigned char*,size_t,unsigned char*,size_t)"
2222,METHOD,base64.h:<global>,TYPE_DECL,"size_t base64_decode(const unsigned char *src, size_t len,
                  unsigned char *out, size_t out_len);",8,53,base64.h,base64_decode,,false,14,15,base64_decode,,,2,"size_t base64_decode (unsigned char*,size_t,unsigned char*,size_t)"
2241,METHOD,bipbuffer.c:<global>,TYPE_DECL,<global>,1,1,bipbuffer.c,bipbuffer.c:<global>,,false,1,180,<global>,,,1,
2243,METHOD,bipbuffer.c:<global>,TYPE_DECL,"static size_t bipbuf_sizeof(const unsigned int size)
{
    return sizeof(bipbuf_t) + size;
}",1,1,bipbuffer.c,bipbuf_sizeof,,false,18,21,bipbuf_sizeof,,,1,size_t bipbuf_sizeof (unsigned int)
2253,METHOD,bipbuffer.c:<global>,TYPE_DECL,"int bipbuf_unused(const bipbuf_t* me)
{
    if (1 == me->b_inuse)
        /* distance between region B and region A */
        return me->a_start - me->b_end;
    else
        return me->size - me->a_end;
}",1,1,bipbuffer.c,bipbuf_unused,,false,23,30,bipbuf_unused,,,2,int bipbuf_unused (bipbuf_t*)
2283,METHOD,bipbuffer.c:<global>,TYPE_DECL,"int bipbuf_size(const bipbuf_t* me)
{
    return me->size;
}",1,1,bipbuffer.c,bipbuf_size,,false,32,35,bipbuf_size,,,3,int bipbuf_size (bipbuf_t*)
2292,METHOD,bipbuffer.c:<global>,TYPE_DECL,"int bipbuf_used(const bipbuf_t* me)
{
    return (me->a_end - me->a_start) + me->b_end;
}",1,1,bipbuffer.c,bipbuf_used,,false,37,40,bipbuf_used,,,4,int bipbuf_used (bipbuf_t*)
2309,METHOD,bipbuffer.c:<global>,TYPE_DECL,"void bipbuf_init(bipbuf_t* me, const unsigned int size)
{
    me->a_start = me->a_end = me->b_end = 0;
    me->size = size;
    me->b_inuse = 0;
}",1,1,bipbuffer.c,bipbuf_init,,false,42,47,bipbuf_init,,,5,"void bipbuf_init (bipbuf_t*,unsigned int)"
2338,METHOD,bipbuffer.c:<global>,TYPE_DECL,"bipbuf_t *bipbuf_new(const unsigned int size)
{
    bipbuf_t *me = malloc(bipbuf_sizeof(size));
    if (!me)
        return NULL;
    bipbuf_init(me, size);
    return me;
}",1,1,bipbuffer.c,bipbuf_new,,false,49,56,bipbuf_new,,,6,bipbuf_t bipbuf_new (unsigned int)
2360,METHOD,bipbuffer.c:<global>,TYPE_DECL,"void bipbuf_free(bipbuf_t* me)
{
    free(me);
}",1,1,bipbuffer.c,bipbuf_free,,false,58,61,bipbuf_free,,,7,void bipbuf_free (bipbuf_t*)
2367,METHOD,bipbuffer.c:<global>,TYPE_DECL,"int bipbuf_is_empty(const bipbuf_t* me)
{
    return me->a_start == me->a_end;
}",1,1,bipbuffer.c,bipbuf_is_empty,,false,63,66,bipbuf_is_empty,,,8,int bipbuf_is_empty (bipbuf_t*)
2380,METHOD,bipbuffer.c:<global>,TYPE_DECL,"static void __check_for_switch_to_b(bipbuf_t* me)
{
    if (me->size - me->a_end < me->a_start - me->b_end)
        me->b_inuse = 1;
}",1,1,bipbuffer.c,__check_for_switch_to_b,,false,70,74,__check_for_switch_to_b,,,9,void __check_for_switch_to_b (bipbuf_t*)
2407,METHOD,bipbuffer.c:<global>,TYPE_DECL,"unsigned char *bipbuf_request(bipbuf_t* me, const int size)
{
    if (bipbuf_unused(me) < size)
        return 0;
    if (1 == me->b_inuse)
    {
        return (unsigned char *)me->data + me->b_end;
    }
    else
    {
        return (unsigned char *)me->data + me->a_end;
    }
}",1,1,bipbuffer.c,bipbuf_request,,false,77,89,bipbuf_request,,,10,"unsigned char* bipbuf_request (bipbuf_t*,int)"
2450,METHOD,bipbuffer.c:<global>,TYPE_DECL,"int bipbuf_push(bipbuf_t* me, const int size)
{
    if (bipbuf_unused(me) < size)
        return 0;

    if (1 == me->b_inuse)
    {
        me->b_end += size;
    }
    else
    {
        me->a_end += size;
    }

    __check_for_switch_to_b(me);
    return size;
}",1,1,bipbuffer.c,bipbuf_push,,false,91,107,bipbuf_push,,,11,"int bipbuf_push (bipbuf_t*,int)"
2487,METHOD,bipbuffer.c:<global>,TYPE_DECL,"int bipbuf_offer(bipbuf_t* me, const unsigned char *data, const int size)
{
    /* not enough space */
    if (bipbuf_unused(me) < size)
        return 0;

    if (1 == me->b_inuse)
    {
        memcpy(me->data + me->b_end, data, size);
        me->b_end += size;
    }
    else
    {
        memcpy(me->data + me->a_end, data, size);
        me->a_end += size;
    }

    __check_for_switch_to_b(me);
    return size;
}",1,1,bipbuffer.c,bipbuf_offer,,false,109,128,bipbuf_offer,,,12,"int bipbuf_offer (bipbuf_t*,unsigned char*,int)"
2545,METHOD,bipbuffer.c:<global>,TYPE_DECL,"unsigned char *bipbuf_peek(const bipbuf_t* me, const unsigned int size)
{
    /* make sure we can actually peek at this data */
    if (me->size < me->a_start + size)
        return NULL;

    if (bipbuf_is_empty(me))
        return NULL;

    return (unsigned char *)me->data + me->a_start;
}",1,1,bipbuffer.c,bipbuf_peek,,false,130,140,bipbuf_peek,,,13,"unsigned char* bipbuf_peek (bipbuf_t*,unsigned int)"
2580,METHOD,bipbuffer.c:<global>,TYPE_DECL,"unsigned char *bipbuf_peek_all(const bipbuf_t* me, unsigned int *size)
{
    if (bipbuf_is_empty(me))
        return NULL;

    *size = me->a_end - me->a_start;
    return (unsigned char*)me->data + me->a_start;
}",1,1,bipbuffer.c,bipbuf_peek_all,,false,142,149,bipbuf_peek_all,,,14,"unsigned char* bipbuf_peek_all (bipbuf_t*,unsigned int*)"
2612,METHOD,bipbuffer.c:<global>,TYPE_DECL,"unsigned char *bipbuf_poll(bipbuf_t* me, const unsigned int size)
{
    if (bipbuf_is_empty(me))
        return NULL;

    /* make sure we can actually poll this data */
    if (me->size < me->a_start + size)
        return NULL;

    void *end = me->data + me->a_start;
    me->a_start += size;

    /* we seem to be empty.. */
    if (me->a_start == me->a_end)
    {
        /* replace a with region b */
        if (1 == me->b_inuse)
        {
            me->a_start = 0;
            me->a_end = me->b_end;
            me->b_end = me->b_inuse = 0;
        }
        else
            /* safely move cursor back to the start because we are empty */
            me->a_start = me->a_end = 0;
    }

    __check_for_switch_to_b(me);
    return end;
}",1,1,bipbuffer.c,bipbuf_poll,,false,151,180,bipbuf_poll,,,15,"unsigned char* bipbuf_poll (bipbuf_t*,unsigned int)"
2707,METHOD,bipbuffer.h:<global>,TYPE_DECL,<global>,1,24,bipbuffer.h,bipbuffer.h:<global>,,false,1,87,<global>,,,1,
2716,METHOD,<empty>,<empty>,<empty>,1,,bipbuffer.h,bipbuf_t:<clinit>,,false,4,,<clinit>,,,7,
2722,METHOD,bipbuffer.h:<global>,TYPE_DECL,bipbuf_t *bipbuf_new(const unsigned int size);,10,45,bipbuffer.h,bipbuf_new,,false,26,26,bipbuf_new,,,3,bipbuf_t* bipbuf_new (unsigned int)
2727,METHOD,bipbuffer.h:<global>,TYPE_DECL,"void bipbuf_init(bipbuf_t* me, const unsigned int size);",6,55,bipbuffer.h,bipbuf_init,,false,34,34,bipbuf_init,,,4,"void bipbuf_init (bipbuf_t*,unsigned int)"
2733,METHOD,bipbuffer.h:<global>,TYPE_DECL,void bipbuf_free(bipbuf_t *me);,6,30,bipbuffer.h,bipbuf_free,,false,38,38,bipbuf_free,,,5,void bipbuf_free (bipbuf_t*)
2738,METHOD,bipbuffer.h:<global>,TYPE_DECL,"unsigned char *bipbuf_request(bipbuf_t* me, const int size);",15,59,bipbuffer.h,bipbuf_request,,false,41,41,bipbuf_request,,,6,"unsigned char* bipbuf_request (bipbuf_t*,int)"
2744,METHOD,bipbuffer.h:<global>,TYPE_DECL,"int bipbuf_push(bipbuf_t* me, const int size);",5,45,bipbuffer.h,bipbuf_push,,false,42,42,bipbuf_push,,,7,"int bipbuf_push (bipbuf_t*,int)"
2750,METHOD,bipbuffer.h:<global>,TYPE_DECL,"int bipbuf_offer(bipbuf_t *me, const unsigned char *data, const int size);",5,73,bipbuffer.h,bipbuf_offer,,false,48,48,bipbuf_offer,,,8,"int bipbuf_offer (bipbuf_t*,unsigned char*,int)"
2757,METHOD,bipbuffer.h:<global>,TYPE_DECL,"unsigned char *bipbuf_peek(const bipbuf_t* me, const unsigned int len);",15,70,bipbuffer.h,bipbuf_peek,,false,55,55,bipbuf_peek,,,9,"unsigned char* bipbuf_peek (bipbuf_t*,unsigned int)"
2763,METHOD,bipbuffer.h:<global>,TYPE_DECL,"unsigned char *bipbuf_peek_all(const bipbuf_t* me, unsigned int *len);",15,69,bipbuffer.h,bipbuf_peek_all,,false,62,62,bipbuf_peek_all,,,10,"unsigned char* bipbuf_peek_all (bipbuf_t*,unsigned int*)"
2769,METHOD,bipbuffer.h:<global>,TYPE_DECL,"unsigned char *bipbuf_poll(bipbuf_t* me, const unsigned int size);",15,65,bipbuffer.h,bipbuf_poll,,false,69,69,bipbuf_poll,,,11,"unsigned char* bipbuf_poll (bipbuf_t*,unsigned int)"
2775,METHOD,bipbuffer.h:<global>,TYPE_DECL,int bipbuf_size(const bipbuf_t* me);,5,35,bipbuffer.h,bipbuf_size,,false,73,73,bipbuf_size,,,12,int bipbuf_size (bipbuf_t*)
2780,METHOD,bipbuffer.h:<global>,TYPE_DECL,int bipbuf_is_empty(const bipbuf_t* me);,5,39,bipbuffer.h,bipbuf_is_empty,,false,77,77,bipbuf_is_empty,,,13,int bipbuf_is_empty (bipbuf_t*)
2785,METHOD,bipbuffer.h:<global>,TYPE_DECL,int bipbuf_used(const bipbuf_t* cb);,5,35,bipbuffer.h,bipbuf_used,,false,81,81,bipbuf_used,,,14,int bipbuf_used (bipbuf_t*)
2790,METHOD,bipbuffer.h:<global>,TYPE_DECL,int bipbuf_unused(const bipbuf_t* me);,5,37,bipbuffer.h,bipbuf_unused,,false,85,85,bipbuf_unused,,,15,int bipbuf_unused (bipbuf_t*)
2810,METHOD,cache.c:<global>,TYPE_DECL,<global>,1,1,cache.c,cache.c:<global>,,false,1,139,<global>,,,1,
2820,METHOD,cache.c:<global>,TYPE_DECL,"cache_t* cache_create(const char *name, size_t bufsize, size_t align) {
    cache_t* ret = calloc(1, sizeof(cache_t));
    char* nm = strdup(name);
    if (ret == NULL || nm == NULL ||
        pthread_mutex_init(&ret->mutex, NULL) == -1) {
        free(ret);
        free(nm);
        return NULL;
    }

    ret->name = nm;
    STAILQ_INIT(&ret->head);

#ifndef NDEBUG
    ret->bufsize = bufsize + 2 * sizeof(redzone_pattern);
#else
    ret->bufsize = bufsize;
#endif
    assert(ret->bufsize >= sizeof(struct cache_free_s));

    return ret;
}",1,4,cache.c,cache_create,,false,18,39,cache_create,,,5,"cache_t cache_create (char*,size_t,size_t)"
2919,METHOD,cache.c:<global>,TYPE_DECL,"void cache_set_limit(cache_t *cache, int limit) {
    pthread_mutex_lock(&cache->mutex);
    cache->limit = limit;
    pthread_mutex_unlock(&cache->mutex);
}",1,1,cache.c,cache_set_limit,,false,41,45,cache_set_limit,,,6,"void cache_set_limit (cache_t*,int)"
2940,METHOD,cache.c:<global>,TYPE_DECL,"static inline void* get_object(void *ptr) {
#ifndef NDEBUG
    uint64_t *pre = ptr;
    return pre + 1;
#else
    return ptr;
#endif
}",1,1,cache.c,get_object,,false,47,54,get_object,,,7,void* get_object (void*)
2953,METHOD,cache.c:<global>,TYPE_DECL,"void cache_destroy(cache_t *cache) {
    while (!STAILQ_EMPTY(&cache->head)) {
        struct cache_free_s *o = STAILQ_FIRST(&cache->head);
        STAILQ_REMOVE_HEAD(&cache->head, c_next);
        free(o);
    }
    free(cache->name);
    pthread_mutex_destroy(&cache->mutex);
    free(cache);
}",1,12,cache.c,cache_destroy,,false,56,65,cache_destroy,,,8,void cache_destroy (cache_t*)
3047,METHOD,cache.c:<global>,TYPE_DECL,"void* cache_alloc(cache_t *cache) {
    void *ret;
    pthread_mutex_lock(&cache->mutex);
    ret = do_cache_alloc(cache);
    pthread_mutex_unlock(&cache->mutex);
    return ret;
}",1,1,cache.c,cache_alloc,,false,67,73,cache_alloc,,,9,void* cache_alloc (cache_t*)
3069,METHOD,cache.c:<global>,TYPE_DECL,"void* do_cache_alloc(cache_t *cache) {
    void *ret;
    void *object;
    if (cache->freecurr > 0) {
        ret = STAILQ_FIRST(&cache->head);
        STAILQ_REMOVE_HEAD(&cache->head, c_next);
        object = get_object(ret);
        cache->freecurr--;
    } else if (cache->limit == 0 || cache->total < cache->limit) {
        object = ret = malloc(cache->bufsize);
        if (ret != NULL) {
            object = get_object(ret);

            cache->total++;
        }
    } else {
        object = NULL;
    }

#ifndef NDEBUG
    if (object != NULL) {
        /* add a simple form of buffer-check */
        uint64_t *pre = ret;
        *pre = redzone_pattern;
        ret = pre+1;
        memcpy(((char*)ret) + cache->bufsize - (2 * sizeof(redzone_pattern)),
               &redzone_pattern, sizeof(redzone_pattern));
    }
#endif

    return object;
}",1,14,cache.c,do_cache_alloc,,false,75,106,do_cache_alloc,,,10,void* do_cache_alloc (cache_t*)
3229,METHOD,cache.c:<global>,TYPE_DECL,"void cache_free(cache_t *cache, void *ptr) {
    pthread_mutex_lock(&cache->mutex);
    do_cache_free(cache, ptr);
    pthread_mutex_unlock(&cache->mutex);
}",1,1,cache.c,cache_free,,false,108,112,cache_free,,,11,"void cache_free (cache_t*,void*)"
3248,METHOD,cache.c:<global>,TYPE_DECL,"void do_cache_free(cache_t *cache, void *ptr) {
#ifndef NDEBUG
    /* validate redzone... */
    if (memcmp(((char*)ptr) + cache->bufsize - (2 * sizeof(redzone_pattern)),
               &redzone_pattern, sizeof(redzone_pattern)) != 0) {
        raise(SIGABRT);
        cache_error = 1;
        return;
    }
    uint64_t *pre = ptr;
    --pre;
    if (*pre != redzone_pattern) {
        raise(SIGABRT);
        cache_error = -1;
        return;
    }
    ptr = pre;
#endif
    if (cache->limit != 0 && cache->limit < cache->total) {
        free(ptr);
        cache->total--;
    } else {
        STAILQ_INSERT_HEAD(&cache->head, (struct cache_free_s *)ptr, c_next);
        cache->freecurr++;
    }
}",1,8,cache.c,do_cache_free,,false,114,139,do_cache_free,,,12,"void do_cache_free (cache_t*,void*)"
3389,METHOD,cache.h:<global>,TYPE_DECL,<global>,1,21,cache.h,cache.h:<global>,,false,1,99,<global>,,,1,
3412,METHOD,cache.h:<global>,TYPE_DECL,"cache_t* cache_create(const char* name, size_t bufsize, size_t align);",8,69,cache.h,cache_create,,false,59,59,cache_create,,,5,"cache_t* cache_create (char*,size_t,size_t)"
3419,METHOD,cache.h:<global>,TYPE_DECL,void cache_destroy(cache_t* handle);,6,35,cache.h,cache_destroy,,false,70,70,cache_destroy,,,6,void cache_destroy (cache_t*)
3424,METHOD,cache.h:<global>,TYPE_DECL,void* cache_alloc(cache_t* handle);,5,34,cache.h,cache_alloc,,false,78,78,cache_alloc,,,7,void* cache_alloc (cache_t*)
3429,METHOD,cache.h:<global>,TYPE_DECL,void* do_cache_alloc(cache_t* handle);,5,37,cache.h,do_cache_alloc,,false,79,79,do_cache_alloc,,,8,void* do_cache_alloc (cache_t*)
3434,METHOD,cache.h:<global>,TYPE_DECL,"void cache_free(cache_t* handle, void* ptr);",6,43,cache.h,cache_free,,false,89,89,cache_free,,,9,"void cache_free (cache_t*,void*)"
3440,METHOD,cache.h:<global>,TYPE_DECL,"void do_cache_free(cache_t* handle, void* ptr);",6,46,cache.h,do_cache_free,,false,90,90,do_cache_free,,,10,"void do_cache_free (cache_t*,void*)"
3446,METHOD,cache.h:<global>,TYPE_DECL,"void cache_set_limit(cache_t* handle, int limit);",6,48,cache.h,cache_set_limit,,false,97,97,cache_set_limit,,,11,"void cache_set_limit (cache_t*,int)"
3487,METHOD,crawler.c:<global>,TYPE_DECL,<global>,1,78,crawler.c,crawler.c:<global>,,false,1,780,<global>,,,1,
3497,METHOD,crawler.c:<global>,TYPE_DECL,"typedef void (*crawler_eval_func)(crawler_module_t *cm, item *it, uint32_t hv, int slab_cls);",14,92,crawler.c,crawler_eval_func,,false,36,36,crawler_eval_func,,,5,"void crawler_eval_func (crawler_module_t*,item*,uint32_t,int)"
3505,METHOD,crawler.c:<global>,TYPE_DECL,"typedef int (*crawler_init_func)(crawler_module_t *cm, void *data);",13,66,crawler.c,crawler_init_func,,false,37,37,crawler_init_func,,,6,"int crawler_init_func (crawler_module_t*,void*)"
3511,METHOD,crawler.c:<global>,TYPE_DECL,typedef void (*crawler_deinit_func)(crawler_module_t *cm);,14,57,crawler.c,crawler_deinit_func,,false,38,38,crawler_deinit_func,,,7,void crawler_deinit_func (crawler_module_t*)
3516,METHOD,crawler.c:<global>,TYPE_DECL,"typedef void (*crawler_doneclass_func)(crawler_module_t *cm, int slab_cls);",14,74,crawler.c,crawler_doneclass_func,,false,39,39,crawler_doneclass_func,,,8,"void crawler_doneclass_func (crawler_module_t*,int)"
3522,METHOD,crawler.c:<global>,TYPE_DECL,typedef void (*crawler_finalize_func)(crawler_module_t *cm);,14,59,crawler.c,crawler_finalize_func,,false,40,40,crawler_finalize_func,,,9,void crawler_finalize_func (crawler_module_t*)
3539,METHOD,crawler.c:<global>,TYPE_DECL,"static int crawler_expired_init(crawler_module_t *cm, void *data);",12,65,crawler.c,crawler_expired_init,,false,57,57,crawler_expired_init,,,13,"int crawler_expired_init (crawler_module_t*,void*)"
3545,METHOD,crawler.c:<global>,TYPE_DECL,"static void crawler_expired_doneclass(crawler_module_t *cm, int slab_cls);",13,73,crawler.c,crawler_expired_doneclass,,false,58,58,crawler_expired_doneclass,,,14,"void crawler_expired_doneclass (crawler_module_t*,int)"
3551,METHOD,crawler.c:<global>,TYPE_DECL,static void crawler_expired_finalize(crawler_module_t *cm);,13,58,crawler.c,crawler_expired_finalize,,false,59,59,crawler_expired_finalize,,,15,void crawler_expired_finalize (crawler_module_t*)
3556,METHOD,crawler.c:<global>,TYPE_DECL,"static void crawler_expired_eval(crawler_module_t *cm, item *search, uint32_t hv, int i);",13,88,crawler.c,crawler_expired_eval,,false,60,60,crawler_expired_eval,,,16,"void crawler_expired_eval (crawler_module_t*,item*,uint32_t,int)"
3592,METHOD,crawler.c:<global>,TYPE_DECL,"static void crawler_metadump_eval(crawler_module_t *cm, item *search, uint32_t hv, int i);",13,89,crawler.c,crawler_metadump_eval,,false,71,71,crawler_metadump_eval,,,19,"void crawler_metadump_eval (crawler_module_t*,item*,uint32_t,int)"
3600,METHOD,crawler.c:<global>,TYPE_DECL,static void crawler_metadump_finalize(crawler_module_t *cm);,13,59,crawler.c,crawler_metadump_finalize,,false,72,72,crawler_metadump_finalize,,,20,void crawler_metadump_finalize (crawler_module_t*)
3643,METHOD,crawler.c:<global>,TYPE_DECL,static int lru_crawler_client_getbuf(crawler_client_t *c);,12,57,crawler.c,lru_crawler_client_getbuf,,false,89,89,lru_crawler_client_getbuf,,,25,int lru_crawler_client_getbuf (crawler_client_t*)
3676,METHOD,crawler.c:<global>,TYPE_DECL,"static void lru_crawler_close_client(crawler_client_t *c) {
    //fprintf(stderr, ""CRAWLER: Closing client\n"");
    sidethread_conn_close(c->c);
    c->c = NULL;
    c->cbuf = NULL;
    bipbuf_free(c->buf);
    c->buf = NULL;
}",1,1,crawler.c,lru_crawler_close_client,,false,112,119,lru_crawler_close_client,,,41,void lru_crawler_close_client (crawler_client_t*)
3704,METHOD,crawler.c:<global>,TYPE_DECL,"static void lru_crawler_release_client(crawler_client_t *c) {
    //fprintf(stderr, ""CRAWLER: Closing client\n"");
    redispatch_conn(c->c);
    c->c = NULL;
    c->cbuf = NULL;
    bipbuf_free(c->buf);
    c->buf = NULL;
}",1,1,crawler.c,lru_crawler_release_client,,false,121,128,lru_crawler_release_client,,,42,void lru_crawler_release_client (crawler_client_t*)
3732,METHOD,crawler.c:<global>,TYPE_DECL,"static int crawler_expired_init(crawler_module_t *cm, void *data) {
    struct crawler_expired_data *d;
    if (data != NULL) {
        d = data;
        d->is_external = true;
        cm->data = data;
    } else {
        // allocate data.
        d = calloc(1, sizeof(struct crawler_expired_data));
        if (d == NULL) {
            return -1;
        }
        // init lock.
        pthread_mutex_init(&d->lock, NULL);
        d->is_external = false;
        d->start_time = current_time;

        cm->data = d;
    }
    pthread_mutex_lock(&d->lock);
    memset(&d->crawlerstats, 0, sizeof(crawlerstats_t) * POWER_LARGEST);
    for (int x = 0; x < POWER_LARGEST; x++) {
        d->crawlerstats[x].start_time = current_time;
        d->crawlerstats[x].run_complete = false;
    }
    pthread_mutex_unlock(&d->lock);
    return 0;
}",1,57,crawler.c,crawler_expired_init,,false,130,157,crawler_expired_init,,,43,"int crawler_expired_init (crawler_module_t*,void*)"
3850,METHOD,crawler.c:<global>,TYPE_DECL,"static void crawler_expired_doneclass(crawler_module_t *cm, int slab_cls) {
    struct crawler_expired_data *d = (struct crawler_expired_data *) cm->data;
    pthread_mutex_lock(&d->lock);
    d->crawlerstats[slab_cls].end_time = current_time;
    d->crawlerstats[slab_cls].run_complete = true;
    pthread_mutex_unlock(&d->lock);
}",1,1,crawler.c,crawler_expired_doneclass,,false,159,165,crawler_expired_doneclass,,,44,"void crawler_expired_doneclass (crawler_module_t*,int)"
3892,METHOD,crawler.c:<global>,TYPE_DECL,"static void crawler_expired_finalize(crawler_module_t *cm) {
    struct crawler_expired_data *d = (struct crawler_expired_data *) cm->data;
    pthread_mutex_lock(&d->lock);
    d->end_time = current_time;
    d->crawl_complete = true;
    pthread_mutex_unlock(&d->lock);

    if (!d->is_external) {
        free(d);
    }
}",1,1,crawler.c,crawler_expired_finalize,,false,167,177,crawler_expired_finalize,,,45,void crawler_expired_finalize (crawler_module_t*)
3933,METHOD,crawler.c:<global>,TYPE_DECL,"static void crawler_expired_eval(crawler_module_t *cm, item *search, uint32_t hv, int i) {
    struct crawler_expired_data *d = (struct crawler_expired_data *) cm->data;
    pthread_mutex_lock(&d->lock);
    crawlerstats_t *s = &d->crawlerstats[i];
    int is_flushed = item_is_flushed(search);
#ifdef EXTSTORE
    bool is_valid = true;
    if (search->it_flags & ITEM_HDR) {
        is_valid = storage_validate_item(storage, search);
    }
#endif
    if ((search->exptime != 0 && search->exptime < current_time)
        || is_flushed
#ifdef EXTSTORE
        || !is_valid
#endif
        ) {
        crawlers[i].reclaimed++;
        s->reclaimed++;

        if (settings.verbose > 1) {
            int ii;
            char *key = ITEM_key(search);
            fprintf(stderr, ""LRU crawler found an expired item (flags: %d, slab: %d): "",
                search->it_flags, search->slabs_clsid);
            for (ii = 0; ii < search->nkey; ++ii) {
                fprintf(stderr, ""%c"", key[ii]);
     ...",1,24,crawler.c,crawler_expired_eval,,false,182,236,crawler_expired_eval,,,46,"void crawler_expired_eval (crawler_module_t*,item*,uint32_t,int)"
4150,METHOD,crawler.c:<global>,TYPE_DECL,"static void crawler_metadump_eval(crawler_module_t *cm, item *it, uint32_t hv, int i) {
    //int slab_id = CLEAR_LRU(i);
    char keybuf[KEY_MAX_URI_ENCODED_LENGTH];
    int is_flushed = item_is_flushed(it);
    /* Ignore expired content. */
    if ((it->exptime != 0 && it->exptime < current_time)
        || is_flushed) {
        refcount_decr(it);
        return;
    }
    // TODO: uriencode directly into the buffer.
    uriencode(ITEM_key(it), keybuf, it->nkey, KEY_MAX_URI_ENCODED_LENGTH);
    int total = snprintf(cm->c.cbuf, 4096,
            ""key=%s exp=%ld la=%llu cas=%llu fetch=%s cls=%u size=%lu\n"",
            keybuf,
            (it->exptime == 0) ? -1 : (long)(it->exptime + process_started),
            (unsigned long long)(it->time + process_started),
            (unsigned long long)ITEM_get_cas(it),
            (it->it_flags & ITEM_FETCHED) ? ""yes"" : ""no"",
            ITEM_clsid(it),
            (unsigned long) ITEM_ntotal(it));
    refcount_decr(it);
    // TODO: some ...",1,16,crawler.c,crawler_metadump_eval,,false,238,266,crawler_metadump_eval,,,47,"void crawler_metadump_eval (crawler_module_t*,item*,uint32_t,int)"
4357,METHOD,crawler.c:<global>,TYPE_DECL,"static void crawler_metadump_finalize(crawler_module_t *cm) {
    if (cm->c.c != NULL) {
        // Ensure space for final message.
        lru_crawler_client_getbuf(&cm->c);
        memcpy(cm->c.cbuf, ""END\r\n"", 5);
        bipbuf_push(cm->c.buf, 5);
    }
}",1,1,crawler.c,crawler_metadump_finalize,,false,268,275,crawler_metadump_finalize,,,48,void crawler_metadump_finalize (crawler_module_t*)
4391,METHOD,crawler.c:<global>,TYPE_DECL,"static int lru_crawler_poll(crawler_client_t *c) {
    unsigned char *data;
    unsigned int data_size = 0;
    struct pollfd to_poll[1];
    to_poll[0].fd = c->sfd;
    to_poll[0].events = POLLOUT;

    int ret = poll(to_poll, 1, 1000);

    if (ret < 0) {
        // fatal.
        return -1;
    }

    if (ret == 0) return 0;

    if (to_poll[0].revents & POLLIN) {
        char buf[1];
        int res = ((conn*)c->c)->read(c->c, buf, 1);
        if (res == 0 || (res == -1 && (errno != EAGAIN && errno != EWOULDBLOCK))) {
            lru_crawler_close_client(c);
            return -1;
        }
    }
    if ((data = bipbuf_peek_all(c->buf, &data_size)) != NULL) {
        if (to_poll[0].revents & (POLLHUP|POLLERR)) {
            lru_crawler_close_client(c);
            return -1;
        } else if (to_poll[0].revents & POLLOUT) {
            int total = ((conn*)c->c)->write(c->c, data, data_size);
            if (total == -1) {
                if (errno != EAGAIN && errno != EWOULDBL...",1,1,crawler.c,lru_crawler_poll,,false,277,321,lru_crawler_poll,,,49,int lru_crawler_poll (crawler_client_t*)
4585,METHOD,crawler.c:<global>,TYPE_DECL,"static int lru_crawler_client_getbuf(crawler_client_t *c) {
    void *buf = NULL;
    if (c->c == NULL) return -1;
    /* not enough space. */
    while ((buf = bipbuf_request(c->buf, LRU_CRAWLER_WRITEBUF)) == NULL) {
        // TODO: max loops before closing.
        int ret = lru_crawler_poll(c);
        if (ret < 0) return ret;
    }

    c->cbuf = buf;
    return 0;
}",1,41,crawler.c,lru_crawler_client_getbuf,,false,327,339,lru_crawler_client_getbuf,,,50,int lru_crawler_client_getbuf (crawler_client_t*)
4636,METHOD,crawler.c:<global>,TYPE_DECL,"static void lru_crawler_class_done(int i) {
    crawlers[i].it_flags = 0;
    crawler_count--;
    do_item_unlinktail_q((item *)&crawlers[i]);
    do_item_stats_add_crawl(i, crawlers[i].reclaimed,
            crawlers[i].unfetched, crawlers[i].checked);
    pthread_mutex_unlock(&lru_locks[i]);
    if (active_crawler_mod.mod->doneclass != NULL)
        active_crawler_mod.mod->doneclass(&active_crawler_mod, i);
}",1,1,crawler.c,lru_crawler_class_done,,false,341,350,lru_crawler_class_done,,,51,void lru_crawler_class_done (int)
4697,METHOD,crawler.c:<global>,TYPE_DECL,"static void item_crawl_hash(void) {
    // get iterator from assoc. can hang for a long time.
    // - blocks hash expansion
    void *iter = assoc_get_iterator();
    int crawls_persleep = settings.crawls_persleep;
    item *it = NULL;

    // loop while iterator returns something
    // - iterator func handles bucket-walking
    // - iterator returns with bucket locked.
    while (assoc_iterate(iter, &it)) {
        // if iterator returns true but no item, we're inbetween buckets and
        // can do sleep or cleanup work without holding a lock.
        if (it == NULL) {
            // - sleep bits from orig loop
            if (crawls_persleep-- <= 0 && settings.lru_crawler_sleep) {
                pthread_mutex_unlock(&lru_crawler_lock);
                usleep(settings.lru_crawler_sleep);
                pthread_mutex_lock(&lru_crawler_lock);
                crawls_persleep = settings.crawls_persleep;
            } else if (!settings.lru_crawler_sleep) {
                // TODO...",1,12,crawler.c,item_crawl_hash,,false,352,406,item_crawl_hash,,,52,void item_crawl_hash (void)
4833,METHOD,crawler.c:<global>,TYPE_DECL,"static void *item_crawler_thread(void *arg) {
    int i;
    int crawls_persleep = settings.crawls_persleep;

    pthread_mutex_lock(&lru_crawler_lock);
    pthread_cond_signal(&lru_crawler_cond);
    settings.lru_crawler = true;
    if (settings.verbose > 2)
        fprintf(stderr, ""Starting LRU crawler background thread\n"");
    while (do_run_lru_crawler_thread) {
    pthread_cond_wait(&lru_crawler_cond, &lru_crawler_lock);

    if (crawler_count == -1) {
        item_crawl_hash();
        crawler_count = 0;
    } else {
    while (crawler_count) {
        item *search = NULL;
        void *hold_lock = NULL;

        for (i = POWER_SMALLEST; i < LARGEST_ID; i++) {
            if (crawlers[i].it_flags != 1) {
                continue;
            }

            /* Get memory from bipbuf, if client has no space, flush. */
            if (active_crawler_mod.c.c != NULL) {
                int ret = lru_crawler_client_getbuf(&active_crawler_mod.c);
                if (ret != 0) {
     ...",1,17,crawler.c,item_crawler_thread,,false,408,526,item_crawler_thread,,,53,void* item_crawler_thread (void*)
5264,METHOD,crawler.c:<global>,TYPE_DECL,"int stop_item_crawler_thread(bool wait) {
    int ret;
    pthread_mutex_lock(&lru_crawler_lock);
    if (do_run_lru_crawler_thread == 0) {
        pthread_mutex_unlock(&lru_crawler_lock);
        return 0;
    }
    do_run_lru_crawler_thread = 0;
    pthread_cond_signal(&lru_crawler_cond);
    pthread_mutex_unlock(&lru_crawler_lock);
    if (wait && (ret = pthread_join(item_crawler_tid, NULL)) != 0) {
        fprintf(stderr, ""Failed to stop LRU crawler thread: %s\n"", strerror(ret));
        return -1;
    }
    return 0;
}",1,1,crawler.c,stop_item_crawler_thread,,false,530,545,stop_item_crawler_thread,,,55,int stop_item_crawler_thread (bool)
5313,METHOD,crawler.c:<global>,TYPE_DECL,"int start_item_crawler_thread(void) {
    int ret;

    if (settings.lru_crawler)
        return -1;
    pthread_mutex_lock(&lru_crawler_lock);
    do_run_lru_crawler_thread = 1;
    if ((ret = pthread_create(&item_crawler_tid, NULL,
        item_crawler_thread, NULL)) != 0) {
        fprintf(stderr, ""Can't create LRU crawler thread: %s\n"",
            strerror(ret));
        pthread_mutex_unlock(&lru_crawler_lock);
        return -1;
    }
    /* Avoid returning until the crawler has actually started */
    pthread_cond_wait(&lru_crawler_cond, &lru_crawler_lock);
    pthread_mutex_unlock(&lru_crawler_lock);

    return 0;
}",1,1,crawler.c,start_item_crawler_thread,,false,558,577,start_item_crawler_thread,,,56,int start_item_crawler_thread (void)
5366,METHOD,crawler.c:<global>,TYPE_DECL,"static int do_lru_crawler_start(uint32_t id, uint32_t remaining) {
    uint32_t sid = id;
    int starts = 0;

    pthread_mutex_lock(&lru_locks[sid]);
    if (crawlers[sid].it_flags == 0) {
        if (settings.verbose > 2)
            fprintf(stderr, ""Kicking LRU crawler off for LRU %u\n"", sid);
        crawlers[sid].nbytes = 0;
        crawlers[sid].nkey = 0;
        crawlers[sid].it_flags = 1; /* For a crawler, this means enabled. */
        crawlers[sid].next = 0;
        crawlers[sid].prev = 0;
        crawlers[sid].time = 0;
        if (remaining == LRU_CRAWLER_CAP_REMAINING) {
            remaining = do_get_lru_size(sid);
        }
        /* Values for remaining:
         * remaining = 0
         * - scan all elements, until a NULL is reached
         * - if empty, NULL is reached right away
         * remaining = n + 1
         * - first n elements are parsed (or until a NULL is reached)
         */
        if (remaining) remaining++;
        crawlers[sid].remaining = rema...",1,25,crawler.c,do_lru_crawler_start,,false,582,618,do_lru_crawler_start,,,57,"int do_lru_crawler_start (uint32_t,uint32_t)"
5517,METHOD,crawler.c:<global>,TYPE_DECL,"static int lru_crawler_set_client(crawler_module_t *cm, void *c, const int sfd) {
    crawler_client_t *crawlc = &cm->c;
    if (crawlc->c != NULL) {
        return -1;
    }
    crawlc->c = c;
    crawlc->sfd = sfd;

    crawlc->buf = bipbuf_new(1024 * 128);
    if (crawlc->buf == NULL) {
        return -2;
    }
    return 0;
}",1,1,crawler.c,lru_crawler_set_client,,false,620,633,lru_crawler_set_client,,,58,"int lru_crawler_set_client (crawler_module_t*,void*,int)"
5571,METHOD,crawler.c:<global>,TYPE_DECL,"int lru_crawler_start(uint8_t *ids, uint32_t remaining,
                             const enum crawler_run_type type, void *data,
                             void *c, const int sfd) {
    int starts = 0;
    bool is_running;
    static rel_time_t block_ae_until = 0;
    pthread_mutex_lock(&lru_crawler_lock);
    STATS_LOCK();
    is_running = stats_state.lru_crawler_running;
    STATS_UNLOCK();
    if (do_run_lru_crawler_thread == 0) {
        pthread_mutex_unlock(&lru_crawler_lock);
        return -2;
    }

    if (is_running &&
            !(type == CRAWLER_AUTOEXPIRE && active_crawler_type == CRAWLER_AUTOEXPIRE)) {
        pthread_mutex_unlock(&lru_crawler_lock);
        block_ae_until = current_time + 60;
        return -1;
    }

    if (type == CRAWLER_AUTOEXPIRE && block_ae_until > current_time) {
        pthread_mutex_unlock(&lru_crawler_lock);
        return -1;
    }

    /* hash table walk only supported with metadump for now. */
    if (type != CRAWLER_METADUMP && ids...",1,23,crawler.c,lru_crawler_start,,false,635,711,lru_crawler_start,,,59,"int lru_crawler_start (uint8_t*,uint32_t,crawler_run_type,void*,void*,int)"
5801,METHOD,crawler.c:<global>,TYPE_DECL,"enum crawler_result_type lru_crawler_crawl(char *slabs, const enum crawler_run_type type,
        void *c, const int sfd, unsigned int remaining) {
    char *b = NULL;
    uint32_t sid = 0;
    int starts = 0;
    uint8_t tocrawl[POWER_LARGEST];
    bool hash_crawl = false;

    /* FIXME: I added this while debugging. Don't think it's needed? */
    memset(tocrawl, 0, sizeof(uint8_t) * POWER_LARGEST);
    if (strcmp(slabs, ""all"") == 0) {
        for (sid = 0; sid < POWER_LARGEST; sid++) {
            tocrawl[sid] = 1;
        }
    } else if (strcmp(slabs, ""hash"") == 0) {
        hash_crawl = true;
    } else {
        for (char *p = strtok_r(slabs, "","", &b);
             p != NULL;
             p = strtok_r(NULL, "","", &b)) {

            if (!safe_strtoul(p, &sid) || sid < POWER_SMALLEST
                    || sid >= MAX_NUMBER_OF_SLAB_CLASSES) {
                return CRAWLER_BADCLASS;
            }
            tocrawl[sid | TEMP_LRU] = 1;
            tocrawl[sid | HOT_LRU] = 1;
 ...",1,20,crawler.c,lru_crawler_crawl,,false,716,758,lru_crawler_crawl,,,60,"enum crawler_result_type lru_crawler_crawl (char*,crawler_run_type,void*,int,unsigned int)"
5996,METHOD,crawler.c:<global>,TYPE_DECL,"void lru_crawler_pause(void) {
    pthread_mutex_lock(&lru_crawler_lock);
}",1,1,crawler.c,lru_crawler_pause,,false,761,763,lru_crawler_pause,,,61,void lru_crawler_pause (void)
6004,METHOD,crawler.c:<global>,TYPE_DECL,"void lru_crawler_resume(void) {
    pthread_mutex_unlock(&lru_crawler_lock);
}",1,1,crawler.c,lru_crawler_resume,,false,765,767,lru_crawler_resume,,,62,void lru_crawler_resume (void)
6012,METHOD,crawler.c:<global>,TYPE_DECL,"int init_lru_crawler(void *arg) {
    if (lru_crawler_initialized == 0) {
#ifdef EXTSTORE
        storage = arg;
#endif
        active_crawler_mod.c.c = NULL;
        active_crawler_mod.mod = NULL;
        active_crawler_mod.data = NULL;
        lru_crawler_initialized = 1;
    }
    return 0;
}",1,1,crawler.c,init_lru_crawler,,false,769,780,init_lru_crawler,,,63,int init_lru_crawler (void*)
6047,METHOD,crawler.h:<global>,TYPE_DECL,<global>,1,6,crawler.h,crawler.h:<global>,,false,1,43,<global>,,,1,
6058,METHOD,<empty>,<empty>,<empty>,1,,crawler.h,crawlerstats_t:<clinit>,,false,6,,<clinit>,,,9,
6072,METHOD,<empty>,<empty>,<empty>,1,,crawler.h,crawler_expired_data:<clinit>,,false,17,,<clinit>,,,7,
6084,METHOD,<empty>,<empty>,<empty>,1,,crawler.h,crawler_result_type:<clinit>,,false,27,,<clinit>,,,6,
6091,METHOD,crawler.h:<global>,TYPE_DECL,int start_item_crawler_thread(void);,5,35,crawler.h,start_item_crawler_thread,,false,30,30,start_item_crawler_thread,,,5,int start_item_crawler_thread (void)
6096,METHOD,crawler.h:<global>,TYPE_DECL,int stop_item_crawler_thread(bool wait);,5,39,crawler.h,stop_item_crawler_thread,,false,33,33,stop_item_crawler_thread,,,6,int stop_item_crawler_thread (bool)
6101,METHOD,crawler.h:<global>,TYPE_DECL,int init_lru_crawler(void *arg);,5,31,crawler.h,init_lru_crawler,,false,34,34,init_lru_crawler,,,7,int init_lru_crawler (void*)
6108,METHOD,crawler.h:<global>,TYPE_DECL,"int lru_crawler_start(uint8_t *ids, uint32_t remaining,
                             const enum crawler_run_type type, void *data,
                             void *c, const int sfd);",5,52,crawler.h,lru_crawler_start,,false,37,39,lru_crawler_start,,,10,"int lru_crawler_start (uint8_t*,uint32_t,crawler_run_type,void*,void*,int)"
6118,METHOD,crawler.h:<global>,TYPE_DECL,void lru_crawler_pause(void);,6,28,crawler.h,lru_crawler_pause,,false,40,40,lru_crawler_pause,,,11,void lru_crawler_pause (void)
6123,METHOD,crawler.h:<global>,TYPE_DECL,void lru_crawler_resume(void);,6,29,crawler.h,lru_crawler_resume,,false,41,41,lru_crawler_resume,,,12,void lru_crawler_resume (void)
6139,METHOD,crc32c.c:<global>,TYPE_DECL,<global>,1,21,crc32c.c,crc32c.c:<global>,,false,1,512,<global>,,,1,
6142,METHOD,crc32c.c:<global>,TYPE_DECL,"uint32_t crc32c_sw_little(uint32_t crc, void const *buf, size_t len);",10,68,crc32c.c,crc32c_sw_little,,false,51,51,crc32c_sw_little,,,2,"uint32_t crc32c_sw_little (uint32_t,void*,size_t)"
6149,METHOD,crc32c.c:<global>,TYPE_DECL,"uint32_t crc32c_sw_big(uint32_t crc, void const *buf, size_t len);",10,65,crc32c.c,crc32c_sw_big,,false,52,52,crc32c_sw_big,,,3,"uint32_t crc32c_sw_big (uint32_t,void*,size_t)"
6156,METHOD,crc32c.c:<global>,TYPE_DECL,"void crc32c_init(void) {
    crc32c = crc32c_sw;
}",1,1,crc32c.c,crc32c_init,,false,359,361,crc32c_init,,,4,void crc32c_init (void)
6172,METHOD,crc32c.c:<global>,TYPE_DECL,"static void crc32c_init_sw_little(void) {
    for (unsigned n = 0; n < 256; n++) {
        uint32_t crc = n;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc32c_table_little[0][n] = crc;
    }
    for (unsigned n = 0; n < 256; n++) {
        uint32_t crc = crc32c_table_little[0][n];
        for (unsigned k = 1; k < 8; k++) {
            crc = crc32c_table_little[0][crc & 0xff] ^ (crc >> 8);
            crc32c_table_little[k][n] = crc;
        }
    }
}",1,37,crc32c.c,crc32c_init_sw_little,,false,368,388,crc32c_init_sw_little,,,9,void crc32c_init_sw_little (void)
6380,METHOD,crc32c.c:<global>,TYPE_DECL,"uint32_t crc32c_sw_little(uint32_t crc, void const *buf, size_t len) {
    unsigned char const *next = buf;

    pthread_once(&crc32c_once_little, crc32c_init_sw_little);
    crc = ~crc;
    while (len && ((uintptr_t)next & 7) != 0) {
        crc = crc32c_table_little[0][(crc ^ *next++) & 0xff] ^ (crc >> 8);
        len--;
    }
    if (len >= 8) {
        uint64_t crcw = crc;
        do {
            crcw ^= *(uint64_t const *)next;
            crcw = crc32c_table_little[7][crcw & 0xff] ^
                   crc32c_table_little[6][(crcw >> 8) & 0xff] ^
                   crc32c_table_little[5][(crcw >> 16) & 0xff] ^
                   crc32c_table_little[4][(crcw >> 24) & 0xff] ^
                   crc32c_table_little[3][(crcw >> 32) & 0xff] ^
                   crc32c_table_little[2][(crcw >> 40) & 0xff] ^
                   crc32c_table_little[1][(crcw >> 48) & 0xff] ^
                   crc32c_table_little[0][crcw >> 56];
            next += 8;
            len -= 8;
        } whi...",1,1,crc32c.c,crc32c_sw_little,,false,392,423,crc32c_sw_little,,,10,"uint32_t crc32c_sw_little (uint32_t,void*,size_t)"
6560,METHOD,crc32c.c:<global>,TYPE_DECL,"static inline uint64_t swap(uint64_t x) {
    x = ((x << 8) & 0xff00ff00ff00ff00) | ((x >> 8) & 0xff00ff00ff00ff);
    x = ((x << 16) & 0xffff0000ffff0000) | ((x >> 16) & 0xffff0000ffff);
    return (x << 32) | (x >> 32);
}",1,1,crc32c.c,swap,,false,430,434,swap,,,11,uint64_t swap (uint64_t)
6610,METHOD,crc32c.c:<global>,TYPE_DECL,"static void crc32c_init_sw_big(void) {
    for (unsigned n = 0; n < 256; n++) {
        uint32_t crc = n;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc32c_table_big_byte[n] = crc;
    }
    for (unsigned n = 0; n < 256; n++) {
        uint32_t crc = crc32c_table_big_byte[n];
        crc32c_table_big[0][n] = swap(crc);
        for (unsigned k = 1; k < 8; k++) {
            crc = crc32c_table_big_byte[crc & 0xff] ^ (crc >> 8);
            crc32c_table_big[k][n] = swap(crc);
        }
    }
}",1,37,crc32c.c,crc32c_init_sw_big,,false,441,462,crc32c_init_sw_big,,,18,void crc32c_init_sw_big (void)
6821,METHOD,crc32c.c:<global>,TYPE_DECL,"uint32_t crc32c_sw_big(uint32_t crc, void const *buf, size_t len) {
    unsigned char const *next = buf;

    pthread_once(&crc32c_once_big, crc32c_init_sw_big);
    crc = ~crc;
    while (len && ((uintptr_t)next & 7) != 0) {
        crc = crc32c_table_big_byte[(crc ^ *next++) & 0xff] ^ (crc >> 8);
        len--;
    }
    if (len >= 8) {
        uint64_t crcw = swap(crc);
        do {
            crcw ^= *(uint64_t const *)next;
            crcw = crc32c_table_big[0][crcw & 0xff] ^
                   crc32c_table_big[1][(crcw >> 8) & 0xff] ^
                   crc32c_table_big[2][(crcw >> 16) & 0xff] ^
                   crc32c_table_big[3][(crcw >> 24) & 0xff] ^
                   crc32c_table_big[4][(crcw >> 32) & 0xff] ^
                   crc32c_table_big[5][(crcw >> 40) & 0xff] ^
                   crc32c_table_big[6][(crcw >> 48) & 0xff] ^
                   crc32c_table_big[7][(crcw >> 56)];
            next += 8;
            len -= 8;
        } while (len >= 8);
        crc...",1,1,crc32c.c,crc32c_sw_big,,false,466,497,crc32c_sw_big,,,19,"uint32_t crc32c_sw_big (uint32_t,void*,size_t)"
6999,METHOD,crc32c.c:<global>,TYPE_DECL,"uint32_t crc32c_sw(uint32_t crc, void const *buf, size_t len) {
    static int const little = 1;
    if (*(char const *)&little)
        return crc32c_sw_little(crc, buf, len);
    else
        return crc32c_sw_big(crc, buf, len);
}",1,1,crc32c.c,crc32c_sw,,false,506,512,crc32c_sw,,,20,"uint32_t crc32c_sw (uint32_t,void*,size_t)"
7034,METHOD,crc32c.h:<global>,TYPE_DECL,<global>,1,24,crc32c.h,crc32c.h:<global>,,false,1,23,<global>,,,1,
7036,METHOD,crc32c.h:<global>,TYPE_DECL,"typedef uint32_t (*crc_func)(uint32_t crc, const void *buf, size_t len);",18,71,crc32c.h,crc_func,,false,15,15,crc_func,,,1,"uint32_t crc_func (uint32_t,void*,size_t)"
7044,METHOD,crc32c.h:<global>,TYPE_DECL,void crc32c_init(void);,6,22,crc32c.h,crc32c_init,,false,18,18,crc32c_init,,,3,void crc32c_init (void)
7049,METHOD,crc32c.h:<global>,TYPE_DECL,"uint32_t crc32c_sw(uint32_t crc, void const *buf, size_t len);",10,61,crc32c.h,crc32c_sw,,false,21,21,crc32c_sw,,,4,"uint32_t crc32c_sw (uint32_t,void*,size_t)"
7069,METHOD,daemon.c:<global>,TYPE_DECL,<global>,1,1,daemon.c,daemon.c:<global>,,false,1,91,<global>,,,1,
7071,METHOD,daemon.c:<global>,TYPE_DECL,"int daemonize(int nochdir, int noclose)
{
    int fd;

    switch (fork()) {
    case -1:
        return (-1);
    case 0:
        break;
    default:
        _exit(EXIT_SUCCESS);
    }

    if (setsid() == -1)
        return (-1);

    if (nochdir == 0) {
        if(chdir(""/"") != 0) {
            perror(""chdir"");
            return (-1);
        }
    }

    if (noclose == 0 && (fd = open(""/dev/null"", O_RDWR, 0)) != -1) {
        if(dup2(fd, STDIN_FILENO) < 0) {
            perror(""dup2 stdin"");
            goto err_cleanup;
        }
        if(dup2(fd, STDOUT_FILENO) < 0) {
            perror(""dup2 stdout"");
            goto err_cleanup;
        }
        if(dup2(fd, STDERR_FILENO) < 0) {
            perror(""dup2 stderr"");
            goto err_cleanup;
        }

        if(close(fd) < 0) {
            perror(""close"");
            return (-1);
        }
    }
    return (0);

    err_cleanup:
        close(fd);
        return (-1);
}",1,1,daemon.c,daemonize,,false,44,91,daemonize,,,1,"int daemonize (int,int)"
7195,METHOD,darwin_priv.c:<global>,TYPE_DECL,<global>,1,21,darwin_priv.c,darwin_priv.c:<global>,,false,1,28,<global>,,,1,
7232,METHOD,extstore.c:<global>,TYPE_DECL,<global>,1,20,extstore.c,extstore.c:<global>,,false,1,994,<global>,,,1,
7302,METHOD,extstore.c:<global>,TYPE_DECL,"static _store_wbuf *wbuf_new(size_t size) {
    _store_wbuf *b = calloc(1, sizeof(_store_wbuf));
    if (b == NULL)
        return NULL;
    b->buf = calloc(size, sizeof(char));
    if (b->buf == NULL) {
        free(b);
        return NULL;
    }
    b->buf_pos = b->buf;
    b->free = size;
    b->size = size;
    return b;
}",1,1,extstore.c,wbuf_new,,false,115,128,wbuf_new,,,12,_store_wbuf wbuf_new (size_t)
7359,METHOD,extstore.c:<global>,TYPE_DECL,"static store_io_thread *_get_io_thread(store_engine *e) {
    int tid = -1;
    long long int low = LLONG_MAX;
    pthread_mutex_lock(&e->mutex);
    // find smallest queue. ignoring lock since being wrong isn't fatal.
    // TODO: if average queue depth can be quickly tracked, can break as soon
    // as we see a thread that's less than average, and start from last_io_thread
    for (int x = 0; x < e->io_threadcount; x++) {
        if (e->io_threads[x].depth == 0) {
            tid = x;
            break;
        } else if (e->io_threads[x].depth < low) {
                tid = x;
            low = e->io_threads[x].depth;
        }
    }
    pthread_mutex_unlock(&e->mutex);

    return &e->io_threads[tid];
}",1,1,extstore.c,_get_io_thread,,false,130,149,_get_io_thread,,,13,store_io_thread _get_io_thread (store_engine*)
7444,METHOD,extstore.c:<global>,TYPE_DECL,"static uint64_t _next_version(store_engine *e) {
    return e->version++;
}",1,1,extstore.c,_next_version,,false,151,153,_next_version,,,14,uint64_t _next_version (store_engine*)
7454,METHOD,extstore.c:<global>,TYPE_DECL,static void *extstore_io_thread(void *arg);,13,42,extstore.c,extstore_io_thread,,false,155,155,extstore_io_thread,,,15,void* extstore_io_thread (void*)
7459,METHOD,extstore.c:<global>,TYPE_DECL,static void *extstore_maint_thread(void *arg);,13,45,extstore.c,extstore_maint_thread,,false,156,156,extstore_maint_thread,,,16,void* extstore_maint_thread (void*)
7464,METHOD,extstore.c:<global>,TYPE_DECL,"void extstore_get_stats(void *ptr, struct extstore_stats *st) {
    store_engine *e = (store_engine *)ptr;
    STAT_L(e);
    memcpy(st, &e->stats, sizeof(struct extstore_stats));
    STAT_UL(e);

    // grab pages_free/pages_used
    pthread_mutex_lock(&e->mutex);
    st->pages_free = e->page_free;
    st->pages_used = e->page_count - e->page_free;
    pthread_mutex_unlock(&e->mutex);
    st->io_queue = 0;
    for (int x = 0; x < e->io_threadcount; x++) {
        pthread_mutex_lock(&e->io_threads[x].mutex);
        st->io_queue += e->io_threads[x].depth;
        pthread_mutex_unlock(&e->io_threads[x].mutex);
    }
    // calculate bytes_fragmented.
    // note that open and yet-filled pages count against fragmentation.
    st->bytes_fragmented = st->pages_used * e->page_size -
        st->bytes_used;
}",1,4,extstore.c,extstore_get_stats,,false,159,180,extstore_get_stats,,,17,"void extstore_get_stats (void*,extstore_stats*)"
7591,METHOD,extstore.c:<global>,TYPE_DECL,"void extstore_get_page_data(void *ptr, struct extstore_stats *st) {
    store_engine *e = (store_engine *)ptr;
    STAT_L(e);
    memcpy(st->page_data, e->stats.page_data,
            sizeof(struct extstore_page_data) * e->page_count);
    STAT_UL(e);
}",1,4,extstore.c,extstore_get_page_data,,false,182,188,extstore_get_page_data,,,18,"void extstore_get_page_data (void*,extstore_stats*)"
7634,METHOD,extstore.c:<global>,TYPE_DECL,"const char *extstore_err(enum extstore_res res) {
    const char *rv = ""unknown error"";
    switch (res) {
        case EXTSTORE_INIT_BAD_WBUF_SIZE:
            rv = ""page_size must be divisible by wbuf_size"";
            break;
        case EXTSTORE_INIT_NEED_MORE_WBUF:
            rv = ""wbuf_count must be >= page_buckets"";
            break;
        case EXTSTORE_INIT_NEED_MORE_BUCKETS:
            rv = ""page_buckets must be > 0"";
            break;
        case EXTSTORE_INIT_PAGE_WBUF_ALIGNMENT:
            rv = ""page_size and wbuf_size must be divisible by 1024*1024*2"";
            break;
        case EXTSTORE_INIT_TOO_MANY_PAGES:
            rv = ""page_count must total to < 65536. Increase page_size or lower path sizes"";
            break;
        case EXTSTORE_INIT_OOM:
            rv = ""failed calloc for engine"";
            break;
        case EXTSTORE_INIT_OPEN_FAIL:
            rv = ""failed to open file"";
            break;
        case EXTSTORE_INIT_THREAD_FAIL:
         ...",1,1,extstore.c,extstore_err,,false,190,218,extstore_err,,,19,const char* extstore_err (extstore_res)
7693,METHOD,extstore.c:<global>,TYPE_DECL,"void *extstore_init(struct extstore_conf_file *fh, struct extstore_conf *cf,
        enum extstore_res *res) {
    int i;
    struct extstore_conf_file *f = NULL;
    pthread_t thread;

    if (cf->page_size % cf->wbuf_size != 0) {
        *res = EXTSTORE_INIT_BAD_WBUF_SIZE;
        return NULL;
    }
    // Should ensure at least one write buffer per potential page
    if (cf->page_buckets > cf->wbuf_count) {
        *res = EXTSTORE_INIT_NEED_MORE_WBUF;
        return NULL;
    }
    if (cf->page_buckets < 1) {
        *res = EXTSTORE_INIT_NEED_MORE_BUCKETS;
        return NULL;
    }

    // TODO: More intelligence around alignment of flash erasure block sizes
    if (cf->page_size % (1024 * 1024 * 2) != 0 ||
        cf->wbuf_size % (1024 * 1024 * 2) != 0) {
        *res = EXTSTORE_INIT_PAGE_WBUF_ALIGNMENT;
        return NULL;
    }

    store_engine *e = calloc(1, sizeof(store_engine));
    if (e == NULL) {
        *res = EXTSTORE_INIT_OOM;
        return NULL;
    }

    e->pag...",1,1,extstore.c,extstore_init,,false,221,394,extstore_init,,,20,"void* extstore_init (extstore_conf_file*,extstore_conf*,extstore_res*)"
8422,METHOD,extstore.c:<global>,TYPE_DECL,"void extstore_run_maint(void *ptr) {
    store_engine *e = (store_engine *)ptr;
    pthread_cond_signal(&e->maint_thread->cond);
}",1,1,extstore.c,extstore_run_maint,,false,396,399,extstore_run_maint,,,21,void extstore_run_maint (void*)
8440,METHOD,extstore.c:<global>,TYPE_DECL,"static store_page *_allocate_page(store_engine *e, unsigned int bucket,
        unsigned int free_bucket) {
    assert(!e->page_buckets[bucket] || e->page_buckets[bucket]->allocated == e->page_size);
    store_page *tmp = NULL;
    // if a specific free bucket was requested, check there first
    if (free_bucket != 0 && e->free_page_buckets[free_bucket] != NULL) {
        assert(e->page_free > 0);
        tmp = e->free_page_buckets[free_bucket];
        e->free_page_buckets[free_bucket] = tmp->next;
    }
    // failing that, try the global list.
    if (tmp == NULL && e->page_freelist != NULL) {
        tmp = e->page_freelist;
        e->page_freelist = tmp->next;
    }
    E_DEBUG(""EXTSTORE: allocating new page\n"");
    // page_freelist can be empty if the only free pages are specialized and
    // we didn't just request one.
    if (e->page_free > 0 && tmp != NULL) {
        tmp->next = e->page_buckets[bucket];
        e->page_buckets[bucket] = tmp;
        tmp->active = true;
  ...",1,4,extstore.c,_allocate_page,,false,402,436,_allocate_page,,,22,"store_page _allocate_page (store_engine*,unsigned int,unsigned int)"
8615,METHOD,extstore.c:<global>,TYPE_DECL,"static void _allocate_wbuf(store_engine *e, store_page *p) {
    _store_wbuf *wbuf = NULL;
    assert(!p->wbuf);
    pthread_mutex_lock(&e->mutex);
    if (e->wbuf_stack) {
        wbuf = e->wbuf_stack;
        e->wbuf_stack = wbuf->next;
        wbuf->next = 0;
    }
    pthread_mutex_unlock(&e->mutex);
    if (wbuf) {
        wbuf->offset = p->allocated;
        p->allocated += wbuf->size;
        wbuf->free = wbuf->size;
        wbuf->buf_pos = wbuf->buf;
        wbuf->full = false;
        wbuf->flushed = false;

        p->wbuf = wbuf;
    }
}",1,1,extstore.c,_allocate_wbuf,,false,439,459,_allocate_wbuf,,,23,"void _allocate_wbuf (store_engine*,store_page*)"
8708,METHOD,extstore.c:<global>,TYPE_DECL,"static void _wbuf_cb(void *ep, obj_io *io, int ret) {
    store_engine *e = (store_engine *)ep;
    store_page *p = &e->pages[io->page_id];
    _store_wbuf *w = (_store_wbuf *) io->data;

    // TODO: Examine return code. Not entirely sure how to handle errors.
    // Naive first-pass should probably cause the page to close/free.
    w->flushed = true;
    pthread_mutex_lock(&p->mutex);
    assert(p->wbuf != NULL && p->wbuf == w);
    assert(p->written == w->offset);
    p->written += w->size;
    p->wbuf = NULL;

    if (p->written == e->page_size)
        p->active = false;

    // return the wbuf
    pthread_mutex_lock(&e->mutex);
    w->next = e->wbuf_stack;
    e->wbuf_stack = w;
    // also return the IO we just used.
    io->next = e->io_stack;
    e->io_stack = io;
    pthread_mutex_unlock(&e->mutex);
    pthread_mutex_unlock(&p->mutex);
}",1,1,extstore.c,_wbuf_cb,,false,467,493,_wbuf_cb,,,24,"void _wbuf_cb (void*,obj_io*,int)"
8835,METHOD,extstore.c:<global>,TYPE_DECL,"static void _submit_wbuf(store_engine *e, store_page *p) {
    _store_wbuf *w;
    pthread_mutex_lock(&e->mutex);
    obj_io *io = e->io_stack;
    e->io_stack = io->next;
    pthread_mutex_unlock(&e->mutex);
    w = p->wbuf;

    // zero out the end of the wbuf to allow blind readback of data.
    memset(w->buf + (w->size - w->free), 0, w->free);

    io->next = NULL;
    io->mode = OBJ_IO_WRITE;
    io->page_id = p->id;
    io->data = w;
    io->offset = w->offset;
    io->len = w->size;
    io->buf = w->buf;
    io->cb = _wbuf_cb;

    extstore_submit(e, io);
}",1,1,extstore.c,_submit_wbuf,,false,498,519,_submit_wbuf,,,25,"void _submit_wbuf (store_engine*,store_page*)"
8937,METHOD,extstore.c:<global>,TYPE_DECL,"int extstore_write_request(void *ptr, unsigned int bucket,
        unsigned int free_bucket, obj_io *io) {
    store_engine *e = (store_engine *)ptr;
    store_page *p;
    int ret = -1;
    if (bucket >= e->page_bucketcount)
        return ret;

    pthread_mutex_lock(&e->mutex);
    p = e->page_buckets[bucket];
    if (!p) {
        p = _allocate_page(e, bucket, free_bucket);
    }
    pthread_mutex_unlock(&e->mutex);
    if (!p)
        return ret;

    pthread_mutex_lock(&p->mutex);

    // FIXME: can't null out page_buckets!!!
    // page is full, clear bucket and retry later.
    if (!p->active ||
            ((!p->wbuf || p->wbuf->full) && p->allocated >= e->page_size)) {
        pthread_mutex_unlock(&p->mutex);
        pthread_mutex_lock(&e->mutex);
        _allocate_page(e, bucket, free_bucket);
        pthread_mutex_unlock(&e->mutex);
        return ret;
    }

    // if io won't fit, submit IO for wbuf and find new one.
    if (p->wbuf && p->wbuf->free < io->len && !p->wb...",1,1,extstore.c,extstore_write_request,,false,530,581,extstore_write_request,,,26,"int extstore_write_request (void*,unsigned int,unsigned int,obj_io*)"
9146,METHOD,extstore.c:<global>,TYPE_DECL,"void extstore_write(void *ptr, obj_io *io) {
    store_engine *e = (store_engine *)ptr;
    store_page *p = &e->pages[io->page_id];

    io->offset = p->wbuf->offset + (p->wbuf->size - p->wbuf->free);
    io->page_version = p->version;
    p->wbuf->buf_pos += io->len;
    p->wbuf->free -= io->len;
    p->bytes_used += io->len;
    p->obj_count++;
    STAT_L(e);
    e->stats.bytes_written += io->len;
    e->stats.bytes_used += io->len;
    e->stats.objects_written++;
    e->stats.objects_used++;
    STAT_UL(e);

    pthread_mutex_unlock(&p->mutex);
}",1,4,extstore.c,extstore_write,,false,586,604,extstore_write,,,27,"void extstore_write (void*,obj_io*)"
9277,METHOD,extstore.c:<global>,TYPE_DECL,"int extstore_submit(void *ptr, obj_io *io) {
    store_engine *e = (store_engine *)ptr;

    unsigned int depth = 0;
    obj_io *tio = io;
    obj_io *tail = NULL;
    while (tio != NULL) {
        tail = tio; // keep updating potential tail.
        depth++;
        tio = tio->next;
    }

    store_io_thread *t = _get_io_thread(e);
    pthread_mutex_lock(&t->mutex);

    t->depth += depth;
    if (t->queue == NULL) {
        t->queue = io;
        t->queue_tail = tail;
    } else {
        // Have to put the *io stack at the end of current queue.
        assert(tail->next == NULL);
        assert(t->queue_tail->next == NULL);
        t->queue_tail->next = io;
        t->queue_tail = tail;
    }

    pthread_mutex_unlock(&t->mutex);

    //pthread_mutex_lock(&t->mutex);
    pthread_cond_signal(&t->cond);
    //pthread_mutex_unlock(&t->mutex);
    return 0;
}",1,1,extstore.c,extstore_submit,,false,611,644,extstore_submit,,,28,"int extstore_submit (void*,obj_io*)"
9388,METHOD,extstore.c:<global>,TYPE_DECL,"int extstore_delete(void *ptr, unsigned int page_id, uint64_t page_version,
        unsigned int count, unsigned int bytes) {
    store_engine *e = (store_engine *)ptr;
    // FIXME: validate page_id in bounds
    store_page *p = &e->pages[page_id];
    int ret = 0;

    pthread_mutex_lock(&p->mutex);
    if (!p->closed && p->version == page_version) {
        if (p->bytes_used >= bytes) {
            p->bytes_used -= bytes;
        } else {
            p->bytes_used = 0;
        }

        if (p->obj_count >= count) {
            p->obj_count -= count;
        } else {
            p->obj_count = 0; // caller has bad accounting?
        }
        STAT_L(e);
        e->stats.bytes_used -= bytes;
        e->stats.objects_used -= count;
        STAT_UL(e);

        if (p->obj_count == 0) {
            extstore_run_maint(e);
        }
    } else {
        ret = -1;
    }
    pthread_mutex_unlock(&p->mutex);
    return ret;
}",1,8,extstore.c,extstore_delete,,false,649,682,extstore_delete,,,29,"int extstore_delete (void*,unsigned int,uint64_t,unsigned int,unsigned int)"
9523,METHOD,extstore.c:<global>,TYPE_DECL,"int extstore_check(void *ptr, unsigned int page_id, uint64_t page_version) {
    store_engine *e = (store_engine *)ptr;
    store_page *p = &e->pages[page_id];
    int ret = 0;

    pthread_mutex_lock(&p->mutex);
    if (p->version != page_version)
        ret = -1;
    pthread_mutex_unlock(&p->mutex);
    return ret;
}",1,1,extstore.c,extstore_check,,false,684,694,extstore_check,,,30,"int extstore_check (void*,unsigned int,uint64_t)"
9572,METHOD,extstore.c:<global>,TYPE_DECL,"void extstore_close_page(void *ptr, unsigned int page_id, uint64_t page_version) {
    store_engine *e = (store_engine *)ptr;
    store_page *p = &e->pages[page_id];

    pthread_mutex_lock(&p->mutex);
    if (!p->closed && p->version == page_version) {
        p->closed = true;
        extstore_run_maint(e);
    }
    pthread_mutex_unlock(&p->mutex);
}",1,1,extstore.c,extstore_close_page,,false,697,707,extstore_close_page,,,31,"void extstore_close_page (void*,unsigned int,uint64_t)"
9623,METHOD,extstore.c:<global>,TYPE_DECL,"static inline int _read_from_wbuf(store_page *p, obj_io *io) {
    _store_wbuf *wbuf = p->wbuf;
    assert(wbuf != NULL);
    assert(io->offset < p->written + wbuf->size);
    if (io->iov == NULL) {
        memcpy(io->buf, wbuf->buf + (io->offset - wbuf->offset), io->len);
    } else {
        int x;
        unsigned int off = io->offset - wbuf->offset;
        // need to loop fill iovecs
        for (x = 0; x < io->iovcnt; x++) {
            struct iovec *iov = &io->iov[x];
            memcpy(iov->iov_base, wbuf->buf + off, iov->iov_len);
            off += iov->iov_len;
        }
    }
    return io->len;
}",1,1,extstore.c,_read_from_wbuf,,false,715,732,_read_from_wbuf,,,32,"int _read_from_wbuf (store_page*,obj_io*)"
9732,METHOD,extstore.c:<global>,TYPE_DECL,"static void *extstore_io_thread(void *arg) {
    store_io_thread *me = (store_io_thread *)arg;
    store_engine *e = me->e;
    while (1) {
        obj_io *io_stack = NULL;
        pthread_mutex_lock(&me->mutex);
        if (me->queue == NULL) {
            pthread_cond_wait(&me->cond, &me->mutex);
        }

        // Pull and disconnect a batch from the queue
        // Chew small batches from the queue so the IO thread picker can keep
        // the IO queue depth even, instead of piling on threads one at a time
        // as they gobble a queue.
        if (me->queue != NULL) {
            int i;
            obj_io *end = NULL;
            io_stack = me->queue;
            end = io_stack;
            for (i = 1; i < e->io_depth; i++) {
                if (end->next) {
                    end = end->next;
                } else {
                    me->queue_tail = end->next;
                    break;
                }
            }
            me->depth -= i;
            me->...",1,24,extstore.c,extstore_io_thread,,false,739,849,extstore_io_thread,,,33,void* extstore_io_thread (void*)
10102,METHOD,extstore.c:<global>,TYPE_DECL,"static void _free_page(store_engine *e, store_page *p) {
    store_page *tmp = NULL;
    store_page *prev = NULL;
    E_DEBUG(""EXTSTORE: freeing page %u\n"", p->id);
    STAT_L(e);
    e->stats.objects_used -= p->obj_count;
    e->stats.bytes_used -= p->bytes_used;
    e->stats.page_reclaims++;
    STAT_UL(e);
    pthread_mutex_lock(&e->mutex);
    // unlink page from bucket list
    tmp = e->page_buckets[p->bucket];
    while (tmp) {
        if (tmp == p) {
            if (prev) {
                prev->next = tmp->next;
            } else {
                e->page_buckets[p->bucket] = tmp->next;
            }
            tmp->next = NULL;
            break;
        }
        prev = tmp;
        tmp = tmp->next;
    }
    // reset most values
    p->version = 0;
    p->obj_count = 0;
    p->bytes_used = 0;
    p->allocated = 0;
    p->written = 0;
    p->bucket = 0;
    p->active = false;
    p->closed = false;
    p->free = true;
    // add to page stack
    // TODO: free_page_bucke...",1,4,extstore.c,_free_page,,false,852,898,_free_page,,,34,"void _free_page (store_engine*,store_page*)"
10310,METHOD,extstore.c:<global>,TYPE_DECL,"static void *extstore_maint_thread(void *arg) {
    store_maint_thread *me = (store_maint_thread *)arg;
    store_engine *e = me->e;
    struct extstore_page_data *pd =
        calloc(e->page_count, sizeof(struct extstore_page_data));
    pthread_mutex_lock(&me->mutex);
    while (1) {
        int i;
        bool do_evict = false;
        unsigned int low_page = 0;
        uint64_t low_version = ULLONG_MAX;

        pthread_cond_wait(&me->cond, &me->mutex);
        pthread_mutex_lock(&e->mutex);
        // default freelist requires at least one page free.
        // specialized freelists fall back to default once full.
        if (e->page_free == 0 || e->page_freelist == NULL) {
            do_evict = true;
        }
        pthread_mutex_unlock(&e->mutex);
        memset(pd, 0, sizeof(struct extstore_page_data) * e->page_count);

        for (i = 0; i < e->page_count; i++) {
            store_page *p = &e->pages[i];
            pthread_mutex_lock(&p->mutex);
            pd[p->id].f...",1,12,extstore.c,extstore_maint_thread,,false,913,994,extstore_maint_thread,,,35,void* extstore_maint_thread (void*)
10669,METHOD,extstore.h:<global>,TYPE_DECL,<global>,1,6,extstore.h,extstore.h:<global>,,false,1,122,<global>,,,1,
10717,METHOD,<empty>,<empty>,<empty>,1,,extstore.h,obj_io_mode:<clinit>,,false,65,,<clinit>,,,3,
10726,METHOD,extstore.h:<global>,TYPE_DECL,"typedef void (*obj_io_cb)(void *e, obj_io *io, int ret);",14,55,extstore.h,obj_io_cb,,false,71,71,obj_io_cb,,,8,"void obj_io_cb (void*,obj_io*,int)"
10757,METHOD,<empty>,<empty>,<empty>,1,,extstore.h,extstore_res:<clinit>,,false,92,,<clinit>,,,9,
10764,METHOD,extstore.h:<global>,TYPE_DECL,const char *extstore_err(enum extstore_res res);,12,47,extstore.h,extstore_err,,false,103,103,extstore_err,,,11,char* extstore_err (extstore_res)
10769,METHOD,extstore.h:<global>,TYPE_DECL,"void *extstore_init(struct extstore_conf_file *fh, struct extstore_conf *cf, enum extstore_res *res);",6,100,extstore.h,extstore_init,,false,104,104,extstore_init,,,12,"void* extstore_init (extstore_conf_file*,extstore_conf*,extstore_res*)"
10776,METHOD,extstore.h:<global>,TYPE_DECL,"int extstore_write_request(void *ptr, unsigned int bucket, unsigned int free_bucket, obj_io *io);",5,96,extstore.h,extstore_write_request,,false,105,105,extstore_write_request,,,13,"int extstore_write_request (void*,unsigned int,unsigned int,obj_io*)"
10784,METHOD,extstore.h:<global>,TYPE_DECL,"void extstore_write(void *ptr, obj_io *io);",6,42,extstore.h,extstore_write,,false,106,106,extstore_write,,,14,"void extstore_write (void*,obj_io*)"
10790,METHOD,extstore.h:<global>,TYPE_DECL,"int extstore_submit(void *ptr, obj_io *io);",5,42,extstore.h,extstore_submit,,false,107,107,extstore_submit,,,15,"int extstore_submit (void*,obj_io*)"
10796,METHOD,extstore.h:<global>,TYPE_DECL,"int extstore_check(void *ptr, unsigned int page_id, uint64_t page_version);",5,74,extstore.h,extstore_check,,false,112,112,extstore_check,,,16,"int extstore_check (void*,unsigned int,uint64_t)"
10803,METHOD,extstore.h:<global>,TYPE_DECL,"int extstore_delete(void *ptr, unsigned int page_id, uint64_t page_version, unsigned int count, unsigned int bytes);",5,115,extstore.h,extstore_delete,,false,113,113,extstore_delete,,,17,"int extstore_delete (void*,unsigned int,uint64_t,unsigned int,unsigned int)"
10812,METHOD,extstore.h:<global>,TYPE_DECL,"void extstore_get_stats(void *ptr, struct extstore_stats *st);",6,61,extstore.h,extstore_get_stats,,false,114,114,extstore_get_stats,,,18,"void extstore_get_stats (void*,extstore_stats*)"
10818,METHOD,extstore.h:<global>,TYPE_DECL,"void extstore_get_page_data(void *ptr, struct extstore_stats *st);",6,65,extstore.h,extstore_get_page_data,,false,118,118,extstore_get_page_data,,,19,"void extstore_get_page_data (void*,extstore_stats*)"
10824,METHOD,extstore.h:<global>,TYPE_DECL,void extstore_run_maint(void *ptr);,6,34,extstore.h,extstore_run_maint,,false,119,119,extstore_run_maint,,,20,void extstore_run_maint (void*)
10829,METHOD,extstore.h:<global>,TYPE_DECL,"void extstore_close_page(void *ptr, unsigned int page_id, uint64_t page_version);",6,80,extstore.h,extstore_close_page,,false,120,120,extstore_close_page,,,21,"void extstore_close_page (void*,unsigned int,uint64_t)"
10853,METHOD,freebsd_priv.c:<global>,TYPE_DECL,<global>,1,20,freebsd_priv.c,freebsd_priv.c:<global>,,false,1,49,<global>,,,1,
10862,METHOD,globals.c:<global>,TYPE_DECL,<global>,1,1,memcached.h,globals.c:<global>,,false,1,26,<global>,,,1,
10885,METHOD,hash.c:<global>,TYPE_DECL,<global>,1,1,hash.c,hash.c:<global>,,false,1,33,<global>,,,1,
10888,METHOD,hash.c:<global>,TYPE_DECL,"static uint32_t XXH3_hash(const void *key, size_t length) {
    return (uint32_t)XXH3_64bits(key, length);
}",1,21,hash.c,XXH3_hash,,false,11,13,XXH3_hash,,,2,"uint32_t XXH3_hash (void*,size_t)"
10902,METHOD,hash.c:<global>,TYPE_DECL,"int hash_init(enum hashfunc_type type) {
    switch(type) {
        case JENKINS_HASH:
            hash = jenkins_hash;
            settings.hash_algorithm = ""jenkins"";
            break;
        case MURMUR3_HASH:
            hash = MurmurHash3_x86_32;
            settings.hash_algorithm = ""murmur3"";
            break;
        case XXH3_HASH:
            hash = XXH3_hash;
            settings.hash_algorithm = ""xxh3"";
            break;
        default:
            return -1;
    }
    return 0;
}",1,1,hash.c,hash_init,,false,15,33,hash_init,,,3,int hash_init (hashfunc_type)
10952,METHOD,hash.h:<global>,TYPE_DECL,<global>,1,23,hash.h,hash.h:<global>,,false,1,13,<global>,,,1,
10954,METHOD,hash.h:<global>,TYPE_DECL,"typedef uint32_t (*hash_func)(const void *key, size_t length);",18,61,hash.h,hash_func,,false,4,4,hash_func,,,1,"uint32_t hash_func (void*,size_t)"
10965,METHOD,<empty>,<empty>,<empty>,1,,hash.h,hashfunc_type:<clinit>,,false,7,,<clinit>,,,4,
10972,METHOD,hash.h:<global>,TYPE_DECL,int hash_init(enum hashfunc_type type);,5,38,hash.h,hash_init,,false,11,11,hash_init,,,4,int hash_init (hashfunc_type)
11018,METHOD,items.c:<global>,TYPE_DECL,<global>,1,78,items.c,items.c:<global>,,false,1,1849,<global>,,,1,
11020,METHOD,items.c:<global>,TYPE_DECL,static void item_link_q(item *it);,13,33,items.c,item_link_q,,false,25,25,item_link_q,,,1,void item_link_q (item*)
11025,METHOD,items.c:<global>,TYPE_DECL,static void item_unlink_q(item *it);,13,35,items.c,item_unlink_q,,false,26,26,item_unlink_q,,,2,void item_unlink_q (item*)
11130,METHOD,items.c:<global>,TYPE_DECL,"void item_stats_reset(void) {
    int i;
    for (i = 0; i < LARGEST_ID; i++) {
        pthread_mutex_lock(&lru_locks[i]);
        memset(&itemstats[i], 0, sizeof(itemstats_t));
        pthread_mutex_unlock(&lru_locks[i]);
    }
}",1,20,items.c,item_stats_reset,,false,71,78,item_stats_reset,,,35,void item_stats_reset (void)
11167,METHOD,items.c:<global>,TYPE_DECL,"void do_item_stats_add_crawl(const int i, const uint64_t reclaimed,
        const uint64_t unfetched, const uint64_t checked) {
    itemstats[i].crawler_reclaimed += reclaimed;
    itemstats[i].expired_unfetched += unfetched;
    itemstats[i].crawler_items_checked += checked;
}",1,1,items.c,do_item_stats_add_crawl,,false,81,86,do_item_stats_add_crawl,,,36,"void do_item_stats_add_crawl (int,uint64_t,uint64_t,uint64_t)"
11221,METHOD,items.c:<global>,TYPE_DECL,"static bool lru_bump_async(lru_bump_buf *b, item *it, uint32_t hv);",13,66,items.c,lru_bump_async,,false,107,107,lru_bump_async,,,47,"bool lru_bump_async (lru_bump_buf*,item*,uint32_t)"
11228,METHOD,items.c:<global>,TYPE_DECL,static uint64_t lru_total_bumps_dropped(void);,17,45,items.c,lru_total_bumps_dropped,,false,108,108,lru_total_bumps_dropped,,,48,uint64_t lru_total_bumps_dropped (void)
11233,METHOD,items.c:<global>,TYPE_DECL,"uint64_t get_cas_id(void) {
    pthread_mutex_lock(&cas_id_lock);
    uint64_t next_id = ++cas_id;
    pthread_mutex_unlock(&cas_id_lock);
    return next_id;
}",1,1,items.c,get_cas_id,,false,112,117,get_cas_id,,,49,uint64_t get_cas_id (void)
11251,METHOD,items.c:<global>,TYPE_DECL,"void set_cas_id(uint64_t new_cas) {
    pthread_mutex_lock(&cas_id_lock);
    cas_id = new_cas;
    pthread_mutex_unlock(&cas_id_lock);
}",1,1,items.c,set_cas_id,,false,119,123,set_cas_id,,,50,void set_cas_id (uint64_t)
11265,METHOD,items.c:<global>,TYPE_DECL,"int item_is_flushed(item *it) {
    rel_time_t oldest_live = settings.oldest_live;
    uint64_t cas = ITEM_get_cas(it);
    uint64_t oldest_cas = settings.oldest_cas;
    if (oldest_live == 0 || oldest_live > current_time)
        return 0;
    if ((it->time <= oldest_live)
            || (oldest_cas != 0 && cas != 0 && cas < oldest_cas)) {
        return 1;
    }
    return 0;
}",1,19,items.c,item_is_flushed,,false,125,136,item_is_flushed,,,51,int item_is_flushed (item*)
11336,METHOD,items.c:<global>,TYPE_DECL,"unsigned int do_get_lru_size(uint32_t id) {
    return sizes[id];
}",1,1,items.c,do_get_lru_size,,false,139,141,do_get_lru_size,,,52,unsigned int do_get_lru_size (uint32_t)
11345,METHOD,items.c:<global>,TYPE_DECL,"static size_t item_make_header(const uint8_t nkey, const unsigned int flags, const int nbytes,
                     char *suffix, uint8_t *nsuffix) {
    if (flags == 0) {
        *nsuffix = 0;
    } else {
        *nsuffix = sizeof(flags);
    }
    return sizeof(item) + nkey + *nsuffix + nbytes;
}",1,1,items.c,item_make_header,,false,165,173,item_make_header,,,53,"size_t item_make_header (uint8_t,unsigned int,int,char*,uint8_t*)"
11380,METHOD,items.c:<global>,TYPE_DECL,"item *do_item_alloc_pull(const size_t ntotal, const unsigned int id) {
    item *it = NULL;
    int i;
    /* If no memory is available, attempt a direct LRU juggle/eviction */
    /* This is a race in order to simplify lru_pull_tail; in cases where
     * locked items are on the tail, you want them to fall out and cause
     * occasional OOM's, rather than internally work around them.
     * This also gives one fewer code path for slab alloc/free
     */
    for (i = 0; i < 10; i++) {
        /* Try to reclaim memory first */
        if (!settings.lru_segmented) {
            lru_pull_tail(id, COLD_LRU, 0, 0, 0, NULL);
        }
        it = slabs_alloc(ntotal, id, 0);

        if (it == NULL) {
            // We send '0' in for ""total_bytes"" as this routine is always
            // pulling to evict, or forcing HOT -> COLD migration.
            // As of this writing, total_bytes isn't at all used with COLD_LRU.
            if (lru_pull_tail(id, COLD_LRU, 0, LRU_PULL_EVICT, 0, NULL...",1,30,items.c,do_item_alloc_pull,,false,175,214,do_item_alloc_pull,,,54,"item do_item_alloc_pull (size_t,unsigned int)"
11487,METHOD,items.c:<global>,TYPE_DECL,"item_chunk *do_item_alloc_chunk(item_chunk *ch, const size_t bytes_remain) {
    // TODO: Should be a cleaner way of finding real size with slabber calls
    size_t size = bytes_remain + sizeof(item_chunk);
    if (size > settings.slab_chunk_size_max)
        size = settings.slab_chunk_size_max;
    unsigned int id = slabs_clsid(size);

    item_chunk *nch = (item_chunk *) do_item_alloc_pull(size, id);
    if (nch == NULL) {
        // The final chunk in a large item will attempt to be a more
        // appropriately sized chunk to minimize memory overhead. However, if
        // there's no memory available in the lower slab classes we fail the
        // SET. In these cases as a fallback we ensure we attempt to evict a
        // max-size item and reuse a large chunk.
        if (size == settings.slab_chunk_size_max) {
            return NULL;
        } else {
            size = settings.slab_chunk_size_max;
            id = slabs_clsid(size);
            nch = (item_chunk *) do_it...",1,21,items.c,do_item_alloc_chunk,,false,221,260,do_item_alloc_chunk,,,55,"item_chunk do_item_alloc_chunk (item_chunk*,size_t)"
11615,METHOD,items.c:<global>,TYPE_DECL,"item *do_item_alloc(char *key, const size_t nkey, const unsigned int flags,
                    const rel_time_t exptime, const int nbytes) {
    uint8_t nsuffix;
    item *it = NULL;
    char suffix[40];
    // Avoid potential underflows.
    if (nbytes < 2)
        return 0;

    size_t ntotal = item_make_header(nkey + 1, flags, nbytes, suffix, &nsuffix);
    if (settings.use_cas) {
        ntotal += sizeof(uint64_t);
    }

    unsigned int id = slabs_clsid(ntotal);
    unsigned int hdr_id = 0;
    if (id == 0)
        return 0;

    /* This is a large item. Allocate a header object now, lazily allocate
     *  chunks while reading the upload.
     */
    if (ntotal > settings.slab_chunk_size_max) {
        /* We still link this item into the LRU for the larger slab class, but
         * we're pulling a header from an entirely different slab class. The
         * free routines handle large items specifically.
         */
        int htotal = nkey + 1 + nsuffix + sizeof(item) + si...",1,28,items.c,do_item_alloc,,false,262,361,do_item_alloc,,,56,"item do_item_alloc (char*,size_t,unsigned int,rel_time_t,int)"
12006,METHOD,items.c:<global>,TYPE_DECL,"void item_free(item *it) {
    size_t ntotal = ITEM_ntotal(it);
    unsigned int clsid;
    assert((it->it_flags & ITEM_LINKED) == 0);
    assert(it != heads[it->slabs_clsid]);
    assert(it != tails[it->slabs_clsid]);
    assert(it->refcount == 0);

    /* so slab size changer can tell later if item is already free or not */
    clsid = ITEM_clsid(it);
    DEBUG_REFCNT(it, 'F');
    slabs_free(it, ntotal, clsid);
}",1,20,items.c,item_free,,false,363,375,item_free,,,57,void item_free (item*)
12103,METHOD,items.c:<global>,TYPE_DECL,"bool item_size_ok(const size_t nkey, const int flags, const int nbytes) {
    char prefix[40];
    uint8_t nsuffix;
    if (nbytes < 2)
        return false;

    size_t ntotal = item_make_header(nkey + 1, flags, nbytes,
                                     prefix, &nsuffix);
    if (settings.use_cas) {
        ntotal += sizeof(uint64_t);
    }

    return slabs_clsid(ntotal) != 0;
}",1,1,items.c,item_size_ok,,false,381,394,item_size_ok,,,58,"bool item_size_ok (size_t,int,int)"
12145,METHOD,items.c:<global>,TYPE_DECL,"void do_item_link_fixup(item *it) {
    item **head, **tail;
    int ntotal = ITEM_ntotal(it);
    uint32_t hv = hash(ITEM_key(it), it->nkey);
    assoc_insert(it, hv);

    head = &heads[it->slabs_clsid];
    tail = &tails[it->slabs_clsid];
    if (it->prev == 0 && *head == 0) *head = it;
    if (it->next == 0 && *tail == 0) *tail = it;
    sizes[it->slabs_clsid]++;
    sizes_bytes[it->slabs_clsid] += ntotal;

    STATS_LOCK();
    stats_state.curr_bytes += ntotal;
    stats_state.curr_items += 1;
    stats.total_items += 1;
    STATS_UNLOCK();

    item_stats_sizes_add(it);

    return;
}",1,17,items.c,do_item_link_fixup,,false,397,419,do_item_link_fixup,,,59,void do_item_link_fixup (item*)
12300,METHOD,items.c:<global>,TYPE_DECL,"static void do_item_link_q(item *it) { /* item is the new head */
    item **head, **tail;
    assert((it->it_flags & ITEM_SLABBED) == 0);

    head = &heads[it->slabs_clsid];
    tail = &tails[it->slabs_clsid];
    assert(it != *head);
    assert((*head && *tail) || (*head == 0 && *tail == 0));
    it->prev = 0;
    it->next = *head;
    if (it->next) it->next->prev = it;
    *head = it;
    if (*tail == 0) *tail = it;
    sizes[it->slabs_clsid]++;
#ifdef EXTSTORE
    if (it->it_flags & ITEM_HDR) {
        sizes_bytes[it->slabs_clsid] += (ITEM_ntotal(it) - it->nbytes) + sizeof(item_hdr);
    } else {
        sizes_bytes[it->slabs_clsid] += ITEM_ntotal(it);
    }
#else
    sizes_bytes[it->slabs_clsid] += ITEM_ntotal(it);
#endif

    return;
}",1,27,items.c,do_item_link_q,,false,421,446,do_item_link_q,,,60,void do_item_link_q (item*)
12439,METHOD,items.c:<global>,TYPE_DECL,"static void item_link_q(item *it) {
    pthread_mutex_lock(&lru_locks[it->slabs_clsid]);
    do_item_link_q(it);
    pthread_mutex_unlock(&lru_locks[it->slabs_clsid]);
}",1,1,items.c,item_link_q,,false,448,452,item_link_q,,,61,void item_link_q (item*)
12460,METHOD,items.c:<global>,TYPE_DECL,"static void item_link_q_warm(item *it) {
    pthread_mutex_lock(&lru_locks[it->slabs_clsid]);
    do_item_link_q(it);
    itemstats[it->slabs_clsid].moves_to_warm++;
    pthread_mutex_unlock(&lru_locks[it->slabs_clsid]);
}",1,1,items.c,item_link_q_warm,,false,454,459,item_link_q_warm,,,62,void item_link_q_warm (item*)
12489,METHOD,items.c:<global>,TYPE_DECL,"static void do_item_unlink_q(item *it) {
    item **head, **tail;
    head = &heads[it->slabs_clsid];
    tail = &tails[it->slabs_clsid];

    if (*head == it) {
        assert(it->prev == 0);
        *head = it->next;
    }
    if (*tail == it) {
        assert(it->next == 0);
        *tail = it->prev;
    }
    assert(it->next != it);
    assert(it->prev != it);

    if (it->next) it->next->prev = it->prev;
    if (it->prev) it->prev->next = it->next;
    sizes[it->slabs_clsid]--;
#ifdef EXTSTORE
    if (it->it_flags & ITEM_HDR) {
        sizes_bytes[it->slabs_clsid] -= (ITEM_ntotal(it) - it->nbytes) + sizeof(item_hdr);
    } else {
        sizes_bytes[it->slabs_clsid] -= ITEM_ntotal(it);
    }
#else
    sizes_bytes[it->slabs_clsid] -= ITEM_ntotal(it);
#endif

    return;
}",1,36,items.c,do_item_unlink_q,,false,461,491,do_item_unlink_q,,,63,void do_item_unlink_q (item*)
12636,METHOD,items.c:<global>,TYPE_DECL,"static void item_unlink_q(item *it) {
    pthread_mutex_lock(&lru_locks[it->slabs_clsid]);
    do_item_unlink_q(it);
    pthread_mutex_unlock(&lru_locks[it->slabs_clsid]);
}",1,1,items.c,item_unlink_q,,false,493,497,item_unlink_q,,,64,void item_unlink_q (item*)
12657,METHOD,items.c:<global>,TYPE_DECL,"int do_item_link(item *it, const uint32_t hv) {
    MEMCACHED_ITEM_LINK(ITEM_key(it), it->nkey, it->nbytes);
    assert((it->it_flags & (ITEM_LINKED|ITEM_SLABBED)) == 0);
    it->it_flags |= ITEM_LINKED;
    it->time = current_time;

    STATS_LOCK();
    stats_state.curr_bytes += ITEM_ntotal(it);
    stats_state.curr_items += 1;
    stats.total_items += 1;
    STATS_UNLOCK();

    /* Allocate a new CAS ID on link. */
    ITEM_set_cas(it, (settings.use_cas) ? get_cas_id() : 0);
    assoc_insert(it, hv);
    item_link_q(it);
    refcount_incr(it);
    item_stats_sizes_add(it);

    return 1;
}",1,4,items.c,do_item_link,,false,499,519,do_item_link,,,65,"int do_item_link (item*,uint32_t)"
12778,METHOD,items.c:<global>,TYPE_DECL,"void do_item_unlink(item *it, const uint32_t hv) {
    MEMCACHED_ITEM_UNLINK(ITEM_key(it), it->nkey, it->nbytes);
    if ((it->it_flags & ITEM_LINKED) != 0) {
        it->it_flags &= ~ITEM_LINKED;
        STATS_LOCK();
        stats_state.curr_bytes -= ITEM_ntotal(it);
        stats_state.curr_items -= 1;
        STATS_UNLOCK();
        item_stats_sizes_remove(it);
        assoc_delete(ITEM_key(it), it->nkey, hv);
        item_unlink_q(it);
        do_item_remove(it);
    }
}",1,4,items.c,do_item_unlink,,false,521,534,do_item_unlink,,,66,"void do_item_unlink (item*,uint32_t)"
12879,METHOD,items.c:<global>,TYPE_DECL,"void do_item_unlink_nolock(item *it, const uint32_t hv) {
    MEMCACHED_ITEM_UNLINK(ITEM_key(it), it->nkey, it->nbytes);
    if ((it->it_flags & ITEM_LINKED) != 0) {
        it->it_flags &= ~ITEM_LINKED;
        STATS_LOCK();
        stats_state.curr_bytes -= ITEM_ntotal(it);
        stats_state.curr_items -= 1;
        STATS_UNLOCK();
        item_stats_sizes_remove(it);
        assoc_delete(ITEM_key(it), it->nkey, hv);
        do_item_unlink_q(it);
        do_item_remove(it);
    }
}",1,4,items.c,do_item_unlink_nolock,,false,537,550,do_item_unlink_nolock,,,67,"void do_item_unlink_nolock (item*,uint32_t)"
12980,METHOD,items.c:<global>,TYPE_DECL,"void do_item_remove(item *it) {
    MEMCACHED_ITEM_REMOVE(ITEM_key(it), it->nkey, it->nbytes);
    assert((it->it_flags & ITEM_SLABBED) == 0);
    assert(it->refcount > 0);

    if (refcount_decr(it) == 0) {
        item_free(it);
    }
}",1,4,items.c,do_item_remove,,false,552,560,do_item_remove,,,68,void do_item_remove (item*)
13014,METHOD,items.c:<global>,TYPE_DECL,"void do_item_update(item *it) {
    MEMCACHED_ITEM_UPDATE(ITEM_key(it), it->nkey, it->nbytes);

    /* Hits to COLD_LRU immediately move to WARM. */
    if (settings.lru_segmented) {
        assert((it->it_flags & ITEM_SLABBED) == 0);
        if ((it->it_flags & ITEM_LINKED) != 0) {
            if (ITEM_lruid(it) == COLD_LRU && (it->it_flags & ITEM_ACTIVE)) {
                it->time = current_time;
                item_unlink_q(it);
                it->slabs_clsid = ITEM_clsid(it);
                it->slabs_clsid |= WARM_LRU;
                it->it_flags &= ~ITEM_ACTIVE;
                item_link_q_warm(it);
            } else {
                it->time = current_time;
            }
        }
    } else if (it->time < current_time - ITEM_UPDATE_INTERVAL) {
        assert((it->it_flags & ITEM_SLABBED) == 0);

        if ((it->it_flags & ITEM_LINKED) != 0) {
            it->time = current_time;
            item_unlink_q(it);
            item_link_q(it);
        }
    }
}",1,4,items.c,do_item_update,,false,563,590,do_item_update,,,69,void do_item_update (item*)
13158,METHOD,items.c:<global>,TYPE_DECL,"int do_item_replace(item *it, item *new_it, const uint32_t hv) {
    MEMCACHED_ITEM_REPLACE(ITEM_key(it), it->nkey, it->nbytes,
                           ITEM_key(new_it), new_it->nkey, new_it->nbytes);
    assert((it->it_flags & ITEM_SLABBED) == 0);

    do_item_unlink(it, hv);
    return do_item_link(new_it, hv);
}",1,4,items.c,do_item_replace,,false,592,599,do_item_replace,,,70,"int do_item_replace (item*,item*,uint32_t)"
13182,METHOD,items.c:<global>,TYPE_DECL,"char *item_cachedump(const unsigned int slabs_clsid, const unsigned int limit, unsigned int *bytes) {
    unsigned int memlimit = 2 * 1024 * 1024;   /* 2MB max response size */
    char *buffer;
    unsigned int bufcurr;
    item *it;
    unsigned int len;
    unsigned int shown = 0;
    char key_temp[KEY_MAX_LENGTH + 1];
    char temp[512];
    unsigned int id = slabs_clsid;
    id |= COLD_LRU;

    pthread_mutex_lock(&lru_locks[id]);
    it = heads[id];

    buffer = malloc((size_t)memlimit);
    if (buffer == 0) {
        pthread_mutex_unlock(&lru_locks[id]);
        return NULL;
    }
    bufcurr = 0;

    while (it != NULL && (limit == 0 || shown < limit)) {
        assert(it->nkey <= KEY_MAX_LENGTH);
        // protect from printing binary keys.
        if ((it->nbytes == 0 && it->nkey == 0) || (it->it_flags & ITEM_KEY_BINARY)) {
            it = it->next;
            continue;
        }
        /* Copy the key since it may not be null-terminated in the struct */
        strnc...",1,18,items.c,item_cachedump,,false,608,658,item_cachedump,,,71,"char* item_cachedump (unsigned int,unsigned int,unsigned int*)"
13399,METHOD,items.c:<global>,TYPE_DECL,"void fill_item_stats_automove(item_stats_automove *am) {
    int n;
    for (n = 0; n < MAX_NUMBER_OF_SLAB_CLASSES; n++) {
        item_stats_automove *cur = &am[n];

        // outofmemory records into HOT
        int i = n | HOT_LRU;
        pthread_mutex_lock(&lru_locks[i]);
        cur->outofmemory = itemstats[i].outofmemory;
        pthread_mutex_unlock(&lru_locks[i]);

        // evictions and tail age are from COLD
        i = n | COLD_LRU;
        pthread_mutex_lock(&lru_locks[i]);
        cur->evicted = itemstats[i].evicted;
        if (!tails[i]) {
            cur->age = 0;
        } else if (tails[i]->nbytes == 0 && tails[i]->nkey == 0 && tails[i]->it_flags == 1) {
            /* it's a crawler, check previous entry */
            if (tails[i]->prev) {
               cur->age = current_time - tails[i]->prev->time;
            } else {
               cur->age = 0;
            }
        } else {
            cur->age = current_time - tails[i]->time;
        }
        pthread...",1,20,items.c,fill_item_stats_automove,,false,663,692,fill_item_stats_automove,,,72,void fill_item_stats_automove (item_stats_automove*)
13558,METHOD,items.c:<global>,TYPE_DECL,"void item_stats_totals(ADD_STAT add_stats, void *c) {
    itemstats_t totals;
    memset(&totals, 0, sizeof(itemstats_t));
    int n;
    for (n = 0; n < MAX_NUMBER_OF_SLAB_CLASSES; n++) {
        int x;
        int i;
        for (x = 0; x < 4; x++) {
            i = n | lru_type_map[x];
            pthread_mutex_lock(&lru_locks[i]);
            totals.expired_unfetched += itemstats[i].expired_unfetched;
            totals.evicted_unfetched += itemstats[i].evicted_unfetched;
            totals.evicted_active += itemstats[i].evicted_active;
            totals.evicted += itemstats[i].evicted;
            totals.reclaimed += itemstats[i].reclaimed;
            totals.crawler_reclaimed += itemstats[i].crawler_reclaimed;
            totals.crawler_items_checked += itemstats[i].crawler_items_checked;
            totals.lrutail_reflocked += itemstats[i].lrutail_reflocked;
            totals.moves_to_cold += itemstats[i].moves_to_cold;
            totals.moves_to_warm += itemstats[i].moves...",1,20,items.c,item_stats_totals,,false,694,749,item_stats_totals,,,73,"void item_stats_totals (ADD_STAT,void*)"
13915,METHOD,items.c:<global>,TYPE_DECL,"void item_stats(ADD_STAT add_stats, void *c) {
    struct thread_stats thread_stats;
    threadlocal_stats_aggregate(&thread_stats);
    itemstats_t totals;
    int n;
    for (n = 0; n < MAX_NUMBER_OF_SLAB_CLASSES; n++) {
        memset(&totals, 0, sizeof(itemstats_t));
        int x;
        int i;
        unsigned int size = 0;
        unsigned int age  = 0;
        unsigned int age_hot = 0;
        unsigned int age_warm = 0;
        unsigned int lru_size_map[4];
        const char *fmt = ""items:%d:%s"";
        char key_str[STAT_KEY_LEN];
        char val_str[STAT_VAL_LEN];
        int klen = 0, vlen = 0;
        for (x = 0; x < 4; x++) {
            i = n | lru_type_map[x];
            pthread_mutex_lock(&lru_locks[i]);
            totals.evicted += itemstats[i].evicted;
            totals.evicted_nonzero += itemstats[i].evicted_nonzero;
            totals.outofmemory += itemstats[i].outofmemory;
            totals.tailrepairs += itemstats[i].tailrepairs;
            totals.recl...",1,20,items.c,item_stats,,false,751,882,item_stats,,,74,"void item_stats (ADD_STAT,void*)"
15194,METHOD,items.c:<global>,TYPE_DECL,"bool item_stats_sizes_status(void) {
    bool ret = false;
    mutex_lock(&stats_sizes_lock);
    if (stats_sizes_hist != NULL)
        ret = true;
    mutex_unlock(&stats_sizes_lock);
    return ret;
}",1,4,items.c,item_stats_sizes_status,,false,884,891,item_stats_sizes_status,,,75,bool item_stats_sizes_status (void)
15227,METHOD,items.c:<global>,TYPE_DECL,"void item_stats_sizes_init(void) {
    if (stats_sizes_hist != NULL)
        return;
    stats_sizes_buckets = settings.item_size_max / 32 + 1;
    stats_sizes_hist = calloc(stats_sizes_buckets, sizeof(int));
    stats_sizes_cas_min = (settings.use_cas) ? get_cas_id() : 0;
}",1,1,items.c,item_stats_sizes_init,,false,893,899,item_stats_sizes_init,,,76,void item_stats_sizes_init (void)
15261,METHOD,items.c:<global>,TYPE_DECL,"void item_stats_sizes_enable(ADD_STAT add_stats, void *c) {
    mutex_lock(&stats_sizes_lock);
    if (!settings.use_cas) {
        APPEND_STAT(""sizes_status"", ""error"", """");
        APPEND_STAT(""sizes_error"", ""cas_support_disabled"", """");
    } else if (stats_sizes_hist == NULL) {
        item_stats_sizes_init();
        if (stats_sizes_hist != NULL) {
            APPEND_STAT(""sizes_status"", ""enabled"", """");
        } else {
            APPEND_STAT(""sizes_status"", ""error"", """");
            APPEND_STAT(""sizes_error"", ""no_memory"", """");
        }
    } else {
        APPEND_STAT(""sizes_status"", ""enabled"", """");
    }
    mutex_unlock(&stats_sizes_lock);
}",1,4,items.c,item_stats_sizes_enable,,false,901,918,item_stats_sizes_enable,,,77,"void item_stats_sizes_enable (ADD_STAT,void*)"
15370,METHOD,items.c:<global>,TYPE_DECL,"void item_stats_sizes_disable(ADD_STAT add_stats, void *c) {
    mutex_lock(&stats_sizes_lock);
    if (stats_sizes_hist != NULL) {
        free(stats_sizes_hist);
        stats_sizes_hist = NULL;
    }
    APPEND_STAT(""sizes_status"", ""disabled"", """");
    mutex_unlock(&stats_sizes_lock);
}",1,4,items.c,item_stats_sizes_disable,,false,920,928,item_stats_sizes_disable,,,78,"void item_stats_sizes_disable (ADD_STAT,void*)"
15411,METHOD,items.c:<global>,TYPE_DECL,"void item_stats_sizes_add(item *it) {
    if (stats_sizes_hist == NULL || stats_sizes_cas_min > ITEM_get_cas(it))
        return;
    int ntotal = ITEM_ntotal(it);
    int bucket = ntotal / 32;
    if ((ntotal % 32) != 0) bucket++;
    if (bucket < stats_sizes_buckets) stats_sizes_hist[bucket]++;
}",1,58,items.c,item_stats_sizes_add,,false,930,937,item_stats_sizes_add,,,79,void item_stats_sizes_add (item*)
15504,METHOD,items.c:<global>,TYPE_DECL,"void item_stats_sizes_remove(item *it) {
    if (stats_sizes_hist == NULL || stats_sizes_cas_min > ITEM_get_cas(it))
        return;
    int ntotal = ITEM_ntotal(it);
    int bucket = ntotal / 32;
    if ((ntotal % 32) != 0) bucket++;
    if (bucket < stats_sizes_buckets) stats_sizes_hist[bucket]--;
}",1,58,items.c,item_stats_sizes_remove,,false,942,949,item_stats_sizes_remove,,,80,void item_stats_sizes_remove (item*)
15597,METHOD,items.c:<global>,TYPE_DECL,"void item_stats_sizes(ADD_STAT add_stats, void *c) {
    mutex_lock(&stats_sizes_lock);

    if (stats_sizes_hist != NULL) {
        int i;
        for (i = 0; i < stats_sizes_buckets; i++) {
            if (stats_sizes_hist[i] != 0) {
                char key[12];
                snprintf(key, sizeof(key), ""%d"", i * 32);
                APPEND_STAT(key, ""%u"", stats_sizes_hist[i]);
            }
        }
    } else {
        APPEND_STAT(""sizes_status"", ""disabled"", """");
    }

    add_stats(NULL, 0, NULL, 0, c);
    mutex_unlock(&stats_sizes_lock);
}",1,4,items.c,item_stats_sizes,,false,957,975,item_stats_sizes,,,81,"void item_stats_sizes (ADD_STAT,void*)"
15684,METHOD,items.c:<global>,TYPE_DECL,"item *do_item_get(const char *key, const size_t nkey, const uint32_t hv, conn *c, const bool do_update) {
    item *it = assoc_find(key, nkey, hv);
    if (it != NULL) {
        refcount_incr(it);
        /* Optimization for slab reassignment. prevents popular items from
         * jamming in busy wait. Can only do this here to satisfy lock order
         * of item_lock, slabs_lock. */
        /* This was made unsafe by removal of the cache_lock:
         * slab_rebalance_signal and slab_rebal.* are modified in a separate
         * thread under slabs_lock. If slab_rebalance_signal = 1, slab_start =
         * NULL (0), but slab_end is still equal to some value, this would end
         * up unlinking every item fetched.
         * This is either an acceptable loss, or if slab_rebalance_signal is
         * true, slab_start/slab_end should be put behind the slabs_lock.
         * Which would cause a huge potential slowdown.
         * Could also use a specific lock for slab_rebal.* a...",1,8,items.c,do_item_get,,false,978,1058,do_item_get,,,82,"item do_item_get (char*,size_t,uint32_t,conn*,bool)"
15971,METHOD,items.c:<global>,TYPE_DECL,"void do_item_bump(conn *c, item *it, const uint32_t hv) {
    /* We update the hit markers only during fetches.
     * An item needs to be hit twice overall to be considered
     * ACTIVE, but only needs a single hit to maintain activity
     * afterward.
     * FETCHED tells if an item has ever been active.
     */
    if (settings.lru_segmented) {
        if ((it->it_flags & ITEM_ACTIVE) == 0) {
            if ((it->it_flags & ITEM_FETCHED) == 0) {
                it->it_flags |= ITEM_FETCHED;
            } else {
                it->it_flags |= ITEM_ACTIVE;
                if (ITEM_lruid(it) != COLD_LRU) {
                    it->time = current_time; // only need to bump time.
                } else if (!lru_bump_async(c->thread->lru_bump_buf, it, hv)) {
                    // add flag before async bump to avoid race.
                    it->it_flags &= ~ITEM_ACTIVE;
                }
            }
        }
    } else {
        it->it_flags |= ITEM_FETCHED;
        do_item_updat...",1,28,items.c,do_item_bump,,false,1063,1088,do_item_bump,,,83,"void do_item_bump (conn*,item*,uint32_t)"
16074,METHOD,items.c:<global>,TYPE_DECL,"item *do_item_touch(const char *key, size_t nkey, uint32_t exptime,
                    const uint32_t hv, conn *c) {
    item *it = do_item_get(key, nkey, hv, c, DO_UPDATE);
    if (it != NULL) {
        it->exptime = exptime;
    }
    return it;
}",1,45,items.c,do_item_touch,,false,1090,1097,do_item_touch,,,84,"item do_item_touch (char*,size_t,uint32_t,uint32_t,conn*)"
16106,METHOD,items.c:<global>,TYPE_DECL,"int lru_pull_tail(const int orig_id, const int cur_lru,
        const uint64_t total_bytes, const uint8_t flags, const rel_time_t max_age,
        struct lru_pull_tail_return *ret_it) {
    item *it = NULL;
    int id = orig_id;
    int removed = 0;
    if (id == 0)
        return 0;

    int tries = 5;
    item *search;
    item *next_it;
    void *hold_lock = NULL;
    unsigned int move_to_lru = 0;
    uint64_t limit = 0;

    id |= cur_lru;
    pthread_mutex_lock(&lru_locks[id]);
    search = tails[id];
    /* We walk up *only* for locked items, and if bottom is expired. */
    for (; tries > 0 && search != NULL; tries--, search=next_it) {
        /* we might relink search mid-loop, so search->prev isn't reliable */
        next_it = search->prev;
        if (search->nbytes == 0 && search->nkey == 0 && search->it_flags == 1) {
            /* We are a crawler, ignore it. */
            if (flags & LRU_PULL_CRAWL_BLOCKS) {
                pthread_mutex_unlock(&lru_locks[id]);
     ...",1,24,items.c,lru_pull_tail,,false,1103,1277,lru_pull_tail,,,85,"int lru_pull_tail (int,int,uint64_t,uint8_t,rel_time_t,lru_pull_tail_return*)"
16753,METHOD,items.c:<global>,TYPE_DECL,"static void lru_bump_buf_link_q(lru_bump_buf *b) {
    pthread_mutex_lock(&bump_buf_lock);
    assert(b != bump_buf_head);

    b->prev = 0;
    b->next = bump_buf_head;
    if (b->next) b->next->prev = b;
    bump_buf_head = b;
    if (bump_buf_tail == 0) bump_buf_tail = b;
    pthread_mutex_unlock(&bump_buf_lock);
    return;
}",1,1,items.c,lru_bump_buf_link_q,,false,1281,1292,lru_bump_buf_link_q,,,86,void lru_bump_buf_link_q (lru_bump_buf*)
16802,METHOD,items.c:<global>,TYPE_DECL,"void *item_lru_bump_buf_create(void) {
    lru_bump_buf *b = calloc(1, sizeof(lru_bump_buf));
    if (b == NULL) {
        return NULL;
    }

    b->buf = bipbuf_new(sizeof(lru_bump_entry) * LRU_BUMP_BUF_SIZE);
    if (b->buf == NULL) {
        free(b);
        return NULL;
    }

    pthread_mutex_init(&b->mutex, NULL);

    lru_bump_buf_link_q(b);
    return b;
}",1,49,items.c,item_lru_bump_buf_create,,false,1294,1310,item_lru_bump_buf_create,,,87,void* item_lru_bump_buf_create (void)
16853,METHOD,items.c:<global>,TYPE_DECL,"static bool lru_bump_async(lru_bump_buf *b, item *it, uint32_t hv) {
    bool ret = true;
    refcount_incr(it);
    pthread_mutex_lock(&b->mutex);
    lru_bump_entry *be = (lru_bump_entry *) bipbuf_request(b->buf, sizeof(lru_bump_entry));
    if (be != NULL) {
        be->it = it;
        be->hv = hv;
        if (bipbuf_push(b->buf, sizeof(lru_bump_entry)) == 0) {
            ret = false;
            b->dropped++;
        }
    } else {
        ret = false;
        b->dropped++;
    }
    if (!ret) {
        refcount_decr(it);
    }
    pthread_mutex_unlock(&b->mutex);
    return ret;
}",1,4,items.c,lru_bump_async,,false,1312,1333,lru_bump_async,,,88,"bool lru_bump_async (lru_bump_buf*,item*,uint32_t)"
16946,METHOD,items.c:<global>,TYPE_DECL,"static bool lru_maintainer_bumps(void) {
    lru_bump_buf *b;
    lru_bump_entry *be;
    unsigned int size;
    unsigned int todo;
    bool bumped = false;
    pthread_mutex_lock(&bump_buf_lock);
    for (b = bump_buf_head; b != NULL; b=b->next) {
        pthread_mutex_lock(&b->mutex);
        be = (lru_bump_entry *) bipbuf_peek_all(b->buf, &size);
        pthread_mutex_unlock(&b->mutex);

        if (be == NULL) {
            continue;
        }
        todo = size;
        bumped = true;

        while (todo) {
            item_lock(be->hv);
            do_item_update(be->it);
            do_item_remove(be->it);
            item_unlock(be->hv);
            be++;
            todo -= sizeof(lru_bump_entry);
        }

        pthread_mutex_lock(&b->mutex);
        be = (lru_bump_entry *) bipbuf_poll(b->buf, size);
        pthread_mutex_unlock(&b->mutex);
    }
    pthread_mutex_unlock(&bump_buf_lock);
    return bumped;
}",1,1,items.c,lru_maintainer_bumps,,false,1341,1374,lru_maintainer_bumps,,,89,bool lru_maintainer_bumps (void)
17057,METHOD,items.c:<global>,TYPE_DECL,"static uint64_t lru_total_bumps_dropped(void) {
    uint64_t total = 0;
    lru_bump_buf *b;
    pthread_mutex_lock(&bump_buf_lock);
    for (b = bump_buf_head; b != NULL; b=b->next) {
        pthread_mutex_lock(&b->mutex);
        total += b->dropped;
        pthread_mutex_unlock(&b->mutex);
    }
    pthread_mutex_unlock(&bump_buf_lock);
    return total;
}",1,1,items.c,lru_total_bumps_dropped,,false,1376,1387,lru_total_bumps_dropped,,,90,uint64_t lru_total_bumps_dropped (void)
17104,METHOD,items.c:<global>,TYPE_DECL,"static int lru_maintainer_juggle(const int slabs_clsid) {
    int i;
    int did_moves = 0;
    uint64_t total_bytes = 0;
    unsigned int chunks_perslab = 0;
    //unsigned int chunks_free = 0;
    /* TODO: if free_chunks below high watermark, increase aggressiveness */
    slabs_available_chunks(slabs_clsid, NULL,
            &chunks_perslab);
    if (settings.temp_lru) {
        /* Only looking for reclaims. Run before we size the LRU. */
        for (i = 0; i < 500; i++) {
            if (lru_pull_tail(slabs_clsid, TEMP_LRU, 0, 0, 0, NULL) <= 0) {
                break;
            } else {
                did_moves++;
            }
        }
    }

    rel_time_t cold_age = 0;
    rel_time_t hot_age = 0;
    rel_time_t warm_age = 0;
    /* If LRU is in flat mode, force items to drain into COLD via max age of 0 */
    if (settings.lru_segmented) {
        pthread_mutex_lock(&lru_locks[slabs_clsid|COLD_LRU]);
        if (tails[slabs_clsid|COLD_LRU]) {
            cold_age = curre...",1,43,items.c,lru_maintainer_juggle,,false,1397,1458,lru_maintainer_juggle,,,91,int lru_maintainer_juggle (int)
17365,METHOD,items.c:<global>,TYPE_DECL,"static void lru_maintainer_crawler_check(struct crawler_expired_data *cdata, logger *l) {
    int i;
    static rel_time_t next_crawls[POWER_LARGEST];
    static rel_time_t next_crawl_wait[POWER_LARGEST];
    uint8_t todo[POWER_LARGEST];
    memset(todo, 0, sizeof(uint8_t) * POWER_LARGEST);
    bool do_run = false;
    unsigned int tocrawl_limit = 0;

    // TODO: If not segmented LRU, skip non-cold
    for (i = POWER_SMALLEST; i < POWER_LARGEST; i++) {
        crawlerstats_t *s = &cdata->crawlerstats[i];
        /* We've not successfully kicked off a crawl yet. */
        if (s->run_complete) {
            char *lru_name = ""na"";
            pthread_mutex_lock(&cdata->lock);
            int x;
            /* Should we crawl again? */
            uint64_t possible_reclaims = s->seen - s->noexp;
            uint64_t available_reclaims = 0;
            /* Need to think we can free at least 1% of the items before
             * crawling. */
            /* FIXME: Configurable? */
       ...",1,34,items.c,lru_maintainer_crawler_check,,false,1474,1566,lru_maintainer_crawler_check,,,92,"void lru_maintainer_crawler_check (crawler_expired_data*,logger*)"
17763,METHOD,items.c:<global>,TYPE_DECL,"static void *lru_maintainer_thread(void *arg) {
    slab_automove_reg_t *sam = &slab_automove_default;
#ifdef EXTSTORE
    void *storage = arg;
    if (storage != NULL)
        sam = &slab_automove_extstore;
#endif
    int i;
    useconds_t to_sleep = MIN_LRU_MAINTAINER_SLEEP;
    useconds_t last_sleep = MIN_LRU_MAINTAINER_SLEEP;
    rel_time_t last_crawler_check = 0;
    rel_time_t last_automove_check = 0;
    useconds_t next_juggles[MAX_NUMBER_OF_SLAB_CLASSES] = {0};
    useconds_t backoff_juggles[MAX_NUMBER_OF_SLAB_CLASSES] = {0};
    struct crawler_expired_data *cdata =
        calloc(1, sizeof(struct crawler_expired_data));
    if (cdata == NULL) {
        fprintf(stderr, ""Failed to allocate crawler data for LRU maintainer thread\n"");
        abort();
    }
    pthread_mutex_init(&cdata->lock, NULL);
    cdata->crawl_complete = true; // kick off the crawler.
    logger *l = logger_create();
    if (l == NULL) {
        fprintf(stderr, ""Failed to allocate logger for LRU maintain...",1,26,items.c,lru_maintainer_thread,,false,1585,1704,lru_maintainer_thread,,,96,void* lru_maintainer_thread (void*)
18224,METHOD,items.c:<global>,TYPE_DECL,"int stop_lru_maintainer_thread(void) {
    int ret;
    pthread_mutex_lock(&lru_maintainer_lock);
    /* LRU thread is a sleep loop, will die on its own */
    do_run_lru_maintainer_thread = 0;
    pthread_mutex_unlock(&lru_maintainer_lock);
    if ((ret = pthread_join(lru_maintainer_tid, NULL)) != 0) {
        fprintf(stderr, ""Failed to stop LRU maintainer thread: %s\n"", strerror(ret));
        return -1;
    }
    settings.lru_maintainer_thread = false;
    return 0;
}",1,1,items.c,stop_lru_maintainer_thread,,false,1706,1718,stop_lru_maintainer_thread,,,97,int stop_lru_maintainer_thread (void)
18263,METHOD,items.c:<global>,TYPE_DECL,"int start_lru_maintainer_thread(void *arg) {
    int ret;

    pthread_mutex_lock(&lru_maintainer_lock);
    do_run_lru_maintainer_thread = 1;
    settings.lru_maintainer_thread = true;
    if ((ret = pthread_create(&lru_maintainer_tid, NULL,
        lru_maintainer_thread, arg)) != 0) {
        fprintf(stderr, ""Can't create LRU maintainer thread: %s\n"",
            strerror(ret));
        pthread_mutex_unlock(&lru_maintainer_lock);
        return -1;
    }
    pthread_mutex_unlock(&lru_maintainer_lock);

    return 0;
}",1,1,items.c,start_lru_maintainer_thread,,false,1720,1736,start_lru_maintainer_thread,,,98,int start_lru_maintainer_thread (void*)
18308,METHOD,items.c:<global>,TYPE_DECL,"void lru_maintainer_pause(void) {
    pthread_mutex_lock(&lru_maintainer_lock);
}",1,1,items.c,lru_maintainer_pause,,false,1739,1741,lru_maintainer_pause,,,99,void lru_maintainer_pause (void)
18316,METHOD,items.c:<global>,TYPE_DECL,"void lru_maintainer_resume(void) {
    pthread_mutex_unlock(&lru_maintainer_lock);
}",1,1,items.c,lru_maintainer_resume,,false,1743,1745,lru_maintainer_resume,,,100,void lru_maintainer_resume (void)
18324,METHOD,items.c:<global>,TYPE_DECL,"int init_lru_maintainer(void) {
    lru_maintainer_initialized = 1;
    return 0;
}",1,1,items.c,init_lru_maintainer,,false,1747,1750,init_lru_maintainer,,,101,int init_lru_maintainer (void)
18334,METHOD,items.c:<global>,TYPE_DECL,"void do_item_linktail_q(item *it) { /* item is the new tail */
    item **head, **tail;
    assert(it->it_flags == 1);
    assert(it->nbytes == 0);

    head = &heads[it->slabs_clsid];
    tail = &tails[it->slabs_clsid];
    //assert(*tail != 0);
    assert(it != *tail);
    assert((*head && *tail) || (*head == 0 && *tail == 0));
    it->prev = *tail;
    it->next = 0;
    if (it->prev) {
        assert(it->prev->next == 0);
        it->prev->next = it;
    }
    *tail = it;
    if (*head == 0) *head = it;
    return;
}",1,1,items.c,do_item_linktail_q,,false,1753,1772,do_item_linktail_q,,,102,void do_item_linktail_q (item*)
18436,METHOD,items.c:<global>,TYPE_DECL,"void do_item_unlinktail_q(item *it) {
    item **head, **tail;
    head = &heads[it->slabs_clsid];
    tail = &tails[it->slabs_clsid];

    if (*head == it) {
        assert(it->prev == 0);
        *head = it->next;
    }
    if (*tail == it) {
        assert(it->next == 0);
        *tail = it->prev;
    }
    assert(it->next != it);
    assert(it->prev != it);

    if (it->next) it->next->prev = it->prev;
    if (it->prev) it->prev->next = it->next;
    return;
}",1,1,items.c,do_item_unlinktail_q,,false,1774,1793,do_item_unlinktail_q,,,103,void do_item_unlinktail_q (item*)
18536,METHOD,items.c:<global>,TYPE_DECL,"item *do_item_crawl_q(item *it) {
    item **head, **tail;
    assert(it->it_flags == 1);
    assert(it->nbytes == 0);
    head = &heads[it->slabs_clsid];
    tail = &tails[it->slabs_clsid];

    /* We've hit the head, pop off */
    if (it->prev == 0) {
        assert(*head == it);
        if (it->next) {
            *head = it->next;
            assert(it->next->prev == it);
            it->next->prev = 0;
        }
        return NULL; /* Done */
    }

    /* Swing ourselves in front of the next item */
    /* NB: If there is a prev, we can't be the head */
    assert(it->prev != it);
    if (it->prev) {
        if (*head == it->prev) {
            /* Prev was the head, now we're the head */
            *head = it;
        }
        if (*tail == it) {
            /* We are the tail, now they are the tail */
            *tail = it->prev;
        }
        assert(it->next != it);
        if (it->next) {
            assert(it->prev->next == it);
            it->prev->next = it->nex...",1,1,items.c,do_item_crawl_q,,false,1797,1849,do_item_crawl_q,,,104,item do_item_crawl_q (item*)
18746,METHOD,items.h:<global>,TYPE_DECL,<global>,1,32,items.h,items.h:<global>,,false,1,86,<global>,,,1,
18748,METHOD,items.h:<global>,TYPE_DECL,uint64_t get_cas_id(void);,10,25,items.h,get_cas_id,,false,10,10,get_cas_id,,,1,uint64_t get_cas_id (void)
18753,METHOD,items.h:<global>,TYPE_DECL,void set_cas_id(uint64_t new_cas);,6,33,items.h,set_cas_id,,false,11,11,set_cas_id,,,2,void set_cas_id (uint64_t)
18758,METHOD,items.h:<global>,TYPE_DECL,"item *do_item_alloc(char *key, const size_t nkey, const unsigned int flags, const rel_time_t exptime, const int nbytes);",6,119,items.h,do_item_alloc,,false,14,14,do_item_alloc,,,3,"item* do_item_alloc (char*,size_t,unsigned int,rel_time_t,int)"
18767,METHOD,items.h:<global>,TYPE_DECL,"item_chunk *do_item_alloc_chunk(item_chunk *ch, const size_t bytes_remain);",12,74,items.h,do_item_alloc_chunk,,false,15,15,do_item_alloc_chunk,,,4,"item_chunk* do_item_alloc_chunk (item_chunk*,size_t)"
18773,METHOD,items.h:<global>,TYPE_DECL,"item *do_item_alloc_pull(const size_t ntotal, const unsigned int id);",6,68,items.h,do_item_alloc_pull,,false,16,16,do_item_alloc_pull,,,5,"item* do_item_alloc_pull (size_t,unsigned int)"
18779,METHOD,items.h:<global>,TYPE_DECL,void item_free(item *it);,6,24,items.h,item_free,,false,17,17,item_free,,,6,void item_free (item*)
18784,METHOD,items.h:<global>,TYPE_DECL,"bool item_size_ok(const size_t nkey, const int flags, const int nbytes);",6,71,items.h,item_size_ok,,false,18,18,item_size_ok,,,7,"bool item_size_ok (size_t,int,int)"
18791,METHOD,items.h:<global>,TYPE_DECL,"int  do_item_link(item *it, const uint32_t hv);",6,46,items.h,do_item_link,,false,20,20,do_item_link,,,8,"int do_item_link (item*,uint32_t)"
18797,METHOD,items.h:<global>,TYPE_DECL,"void do_item_unlink(item *it, const uint32_t hv);",6,48,items.h,do_item_unlink,,false,21,21,do_item_unlink,,,9,"void do_item_unlink (item*,uint32_t)"
18803,METHOD,items.h:<global>,TYPE_DECL,"void do_item_unlink_nolock(item *it, const uint32_t hv);",6,55,items.h,do_item_unlink_nolock,,false,22,22,do_item_unlink_nolock,,,10,"void do_item_unlink_nolock (item*,uint32_t)"
18809,METHOD,items.h:<global>,TYPE_DECL,void do_item_remove(item *it);,6,29,items.h,do_item_remove,,false,23,23,do_item_remove,,,11,void do_item_remove (item*)
18814,METHOD,items.h:<global>,TYPE_DECL,void do_item_update(item *it);,6,29,items.h,do_item_update,,false,24,24,do_item_update,,,12,void do_item_update (item*)
18819,METHOD,items.h:<global>,TYPE_DECL,void do_item_update_nolock(item *it);,6,36,items.h,do_item_update_nolock,,false,25,25,do_item_update_nolock,,,13,void do_item_update_nolock (item*)
18824,METHOD,items.h:<global>,TYPE_DECL,"int  do_item_replace(item *it, item *new_it, const uint32_t hv);",6,63,items.h,do_item_replace,,false,26,26,do_item_replace,,,14,"int do_item_replace (item*,item*,uint32_t)"
18831,METHOD,items.h:<global>,TYPE_DECL,void do_item_link_fixup(item *it);,6,33,items.h,do_item_link_fixup,,false,27,27,do_item_link_fixup,,,15,void do_item_link_fixup (item*)
18836,METHOD,items.h:<global>,TYPE_DECL,int item_is_flushed(item *it);,5,29,items.h,item_is_flushed,,false,29,29,item_is_flushed,,,16,int item_is_flushed (item*)
18841,METHOD,items.h:<global>,TYPE_DECL,unsigned int do_get_lru_size(uint32_t id);,14,41,items.h,do_get_lru_size,,false,30,30,do_get_lru_size,,,17,unsigned int do_get_lru_size (uint32_t)
18846,METHOD,items.h:<global>,TYPE_DECL,void do_item_linktail_q(item *it);,6,33,items.h,do_item_linktail_q,,false,32,32,do_item_linktail_q,,,18,void do_item_linktail_q (item*)
18851,METHOD,items.h:<global>,TYPE_DECL,void do_item_unlinktail_q(item *it);,6,35,items.h,do_item_unlinktail_q,,false,33,33,do_item_unlinktail_q,,,19,void do_item_unlinktail_q (item*)
18856,METHOD,items.h:<global>,TYPE_DECL,item *do_item_crawl_q(item *it);,6,31,items.h,do_item_crawl_q,,false,34,34,do_item_crawl_q,,,20,item* do_item_crawl_q (item*)
18861,METHOD,items.h:<global>,TYPE_DECL,void *item_lru_bump_buf_create(void);,6,36,items.h,item_lru_bump_buf_create,,false,36,36,item_lru_bump_buf_create,,,21,void* item_lru_bump_buf_create (void)
18869,METHOD,items.h:<global>,TYPE_DECL,"int lru_pull_tail(const int orig_id, const int cur_lru,
        const uint64_t total_bytes, const uint8_t flags, const rel_time_t max_age,
        struct lru_pull_tail_return *ret_it);",5,44,items.h,lru_pull_tail,,false,47,49,lru_pull_tail,,,23,"int lru_pull_tail (int,int,uint64_t,uint8_t,rel_time_t,lru_pull_tail_return*)"
18879,METHOD,items.h:<global>,TYPE_DECL,"char *item_cachedump(const unsigned int slabs_clsid, const unsigned int limit, unsigned int *bytes);",6,99,items.h,item_cachedump,,false,52,52,item_cachedump,,,24,"char* item_cachedump (unsigned int,unsigned int,unsigned int*)"
18886,METHOD,items.h:<global>,TYPE_DECL,"void item_stats(ADD_STAT add_stats, void *c);",6,44,items.h,item_stats,,false,53,53,item_stats,,,25,"void item_stats (ADD_STAT,void*)"
18892,METHOD,items.h:<global>,TYPE_DECL,"void do_item_stats_add_crawl(const int i, const uint64_t reclaimed,
        const uint64_t unfetched, const uint64_t checked);",6,57,items.h,do_item_stats_add_crawl,,false,54,55,do_item_stats_add_crawl,,,26,"void do_item_stats_add_crawl (int,uint64_t,uint64_t,uint64_t)"
18900,METHOD,items.h:<global>,TYPE_DECL,"void item_stats_totals(ADD_STAT add_stats, void *c);",6,51,items.h,item_stats_totals,,false,56,56,item_stats_totals,,,27,"void item_stats_totals (ADD_STAT,void*)"
18906,METHOD,items.h:<global>,TYPE_DECL,"void item_stats_sizes(ADD_STAT add_stats, void *c);",6,50,items.h,item_stats_sizes,,false,58,58,item_stats_sizes,,,28,"void item_stats_sizes (ADD_STAT,void*)"
18912,METHOD,items.h:<global>,TYPE_DECL,void item_stats_sizes_init(void);,6,32,items.h,item_stats_sizes_init,,false,59,59,item_stats_sizes_init,,,29,void item_stats_sizes_init (void)
18917,METHOD,items.h:<global>,TYPE_DECL,"void item_stats_sizes_enable(ADD_STAT add_stats, void *c);",6,57,items.h,item_stats_sizes_enable,,false,60,60,item_stats_sizes_enable,,,30,"void item_stats_sizes_enable (ADD_STAT,void*)"
18923,METHOD,items.h:<global>,TYPE_DECL,"void item_stats_sizes_disable(ADD_STAT add_stats, void *c);",6,58,items.h,item_stats_sizes_disable,,false,61,61,item_stats_sizes_disable,,,31,"void item_stats_sizes_disable (ADD_STAT,void*)"
18929,METHOD,items.h:<global>,TYPE_DECL,void item_stats_sizes_add(item *it);,6,35,items.h,item_stats_sizes_add,,false,62,62,item_stats_sizes_add,,,32,void item_stats_sizes_add (item*)
18934,METHOD,items.h:<global>,TYPE_DECL,void item_stats_sizes_remove(item *it);,6,38,items.h,item_stats_sizes_remove,,false,63,63,item_stats_sizes_remove,,,33,void item_stats_sizes_remove (item*)
18939,METHOD,items.h:<global>,TYPE_DECL,bool item_stats_sizes_status(void);,6,34,items.h,item_stats_sizes_status,,false,64,64,item_stats_sizes_status,,,34,bool item_stats_sizes_status (void)
18949,METHOD,items.h:<global>,TYPE_DECL,void fill_item_stats_automove(item_stats_automove *am);,6,54,items.h,fill_item_stats_automove,,false,72,72,fill_item_stats_automove,,,37,void fill_item_stats_automove (item_stats_automove*)
18954,METHOD,items.h:<global>,TYPE_DECL,"item *do_item_get(const char *key, const size_t nkey, const uint32_t hv, conn *c, const bool do_update);",6,103,items.h,do_item_get,,false,74,74,do_item_get,,,38,"item* do_item_get (char*,size_t,uint32_t,conn*,bool)"
18963,METHOD,items.h:<global>,TYPE_DECL,"item *do_item_touch(const char *key, const size_t nkey, uint32_t exptime, const uint32_t hv, conn *c);",6,101,items.h,do_item_touch,,false,75,75,do_item_touch,,,39,"item* do_item_touch (char*,size_t,uint32_t,uint32_t,conn*)"
18972,METHOD,items.h:<global>,TYPE_DECL,"void do_item_bump(conn *c, item *it, const uint32_t hv);",6,55,items.h,do_item_bump,,false,76,76,do_item_bump,,,40,"void do_item_bump (conn*,item*,uint32_t)"
18979,METHOD,items.h:<global>,TYPE_DECL,void item_stats_reset(void);,6,27,items.h,item_stats_reset,,false,77,77,item_stats_reset,,,41,void item_stats_reset (void)
18987,METHOD,items.h:<global>,TYPE_DECL,int start_lru_maintainer_thread(void *arg);,5,42,items.h,start_lru_maintainer_thread,,false,80,80,start_lru_maintainer_thread,,,44,int start_lru_maintainer_thread (void*)
18992,METHOD,items.h:<global>,TYPE_DECL,int stop_lru_maintainer_thread(void);,5,36,items.h,stop_lru_maintainer_thread,,false,81,81,stop_lru_maintainer_thread,,,45,int stop_lru_maintainer_thread (void)
18997,METHOD,items.h:<global>,TYPE_DECL,int init_lru_maintainer(void);,5,29,items.h,init_lru_maintainer,,false,82,82,init_lru_maintainer,,,46,int init_lru_maintainer (void)
19002,METHOD,items.h:<global>,TYPE_DECL,void lru_maintainer_pause(void);,6,31,items.h,lru_maintainer_pause,,false,83,83,lru_maintainer_pause,,,47,void lru_maintainer_pause (void)
19007,METHOD,items.h:<global>,TYPE_DECL,void lru_maintainer_resume(void);,6,32,items.h,lru_maintainer_resume,,false,84,84,lru_maintainer_resume,,,48,void lru_maintainer_resume (void)
19012,METHOD,items.h:<global>,TYPE_DECL,void *lru_bump_buf_create(void);,6,31,items.h,lru_bump_buf_create,,false,86,86,lru_bump_buf_create,,,49,void* lru_bump_buf_create (void)
19024,METHOD,itoa_ljust.c:<global>,TYPE_DECL,<global>,1,1,itoa_ljust.c,itoa_ljust.c:<global>,,false,1,149,<global>,,,1,
19030,METHOD,itoa_ljust.c:<global>,TYPE_DECL,"static inline char* out2(const int d, char* p) {
    memcpy(p, &((uint16_t *)lut)[d], 2);
    return p + 2;
}",1,1,itoa_ljust.c,out2,,false,73,76,out2,,,3,"char* out2 (int,char*)"
19049,METHOD,itoa_ljust.c:<global>,TYPE_DECL,"static inline char* out1(const char in, char* p) {
    memcpy(p, &in, 1);
    return p + 1;
}",1,1,itoa_ljust.c,out1,,false,78,81,out1,,,4,"char* out1 (char,char*)"
19064,METHOD,itoa_ljust.c:<global>,TYPE_DECL,"static inline int digits( uint32_t u, unsigned k, int* d, char** p, int n ) {
    if (u < k*10) {
        *d = u / k;
        *p = out1('0'+*d, *p);
        --n;
    }
    return n;
}",1,1,itoa_ljust.c,digits,,false,83,90,digits,,,5,"int digits (uint32_t,unsigned,int*,char**,int)"
19100,METHOD,itoa_ljust.c:<global>,TYPE_DECL,"static inline char* itoa(uint32_t u, char* p, int d, int n) {
    switch(n) {
    case 10: d  = u / 100000000; p = out2( d, p );
    case  9: u -= d * 100000000;
    case  8: d  = u /   1000000; p = out2( d, p );
    case  7: u -= d *   1000000;
    case  6: d  = u /     10000; p = out2( d, p );
    case  5: u -= d *     10000;
    case  4: d  = u /       100; p = out2( d, p );
    case  3: u -= d *       100;
    case  2: d  = u /         1; p = out2( d, p );
    case  1: ;
    }
    *p = '\0';
    return p;
}",1,1,itoa_ljust.c,itoa,,false,92,107,itoa,,,6,"char* itoa (uint32_t,char*,int,int)"
19207,METHOD,itoa_ljust.c:<global>,TYPE_DECL,"char* itoa_u32(uint32_t u, char* p) {
    int d = 0,n;
         if (u >=100000000) n = digits(u, 100000000, &d, &p, 10);
    else if (u <       100) n = digits(u,         1, &d, &p,  2);
    else if (u <     10000) n = digits(u,       100, &d, &p,  4);
    else if (u <   1000000) n = digits(u,     10000, &d, &p,  6);
    else                    n = digits(u,   1000000, &d, &p,  8);
    return itoa( u, p, d, n );
}",1,1,itoa_ljust.c,itoa_u32,,false,109,117,itoa_u32,,,7,"char* itoa_u32 (uint32_t,char*)"
19302,METHOD,itoa_ljust.c:<global>,TYPE_DECL,"char* itoa_32(int32_t i, char* p) {
    uint32_t u = i;
    if (i < 0) {
        *p++ = '-';
        u = -u;
    }
    return itoa_u32(u, p);
}",1,1,itoa_ljust.c,itoa_32,,false,119,126,itoa_32,,,8,"char* itoa_32 (int32_t,char*)"
19330,METHOD,itoa_ljust.c:<global>,TYPE_DECL,"char* itoa_u64(uint64_t u, char* p) {
    int d;

    uint32_t lower = (uint32_t)u;
    if (lower == u) return itoa_u32(lower, p);

    uint64_t upper = u / 1000000000;
    p = itoa_u64(upper, p);
    lower = u - (upper * 1000000000);
    d = lower / 100000000;
    p = out1('0'+d,p);
    return itoa( lower, p, d, 9 );
}",1,1,itoa_ljust.c,itoa_u64,,false,128,140,itoa_u64,,,9,"char* itoa_u64 (uint64_t,char*)"
19388,METHOD,itoa_ljust.c:<global>,TYPE_DECL,"char* itoa_64(int64_t i, char* p) {
    uint64_t u = i;
    if (i < 0) {
        *p++ = '-';
        u = -u;
    }
    return itoa_u64(u, p);
}",1,1,itoa_ljust.c,itoa_64,,false,142,149,itoa_64,,,10,"char* itoa_64 (int64_t,char*)"
19421,METHOD,itoa_ljust.h:<global>,TYPE_DECL,<global>,1,22,itoa_ljust.h,itoa_ljust.h:<global>,,false,1,28,<global>,,,1,
19423,METHOD,itoa_ljust.h:<global>,TYPE_DECL,"char* itoa_u32(uint32_t u, char* buffer);",5,40,itoa_ljust.h,itoa_u32,,false,23,23,itoa_u32,,,1,"char* itoa_u32 (uint32_t,char*)"
19429,METHOD,itoa_ljust.h:<global>,TYPE_DECL,"char* itoa_32( int32_t i, char* buffer);",5,39,itoa_ljust.h,itoa_32,,false,24,24,itoa_32,,,2,"char* itoa_32 (int32_t,char*)"
19435,METHOD,itoa_ljust.h:<global>,TYPE_DECL,"char* itoa_u64(uint64_t u, char* buffer);",5,40,itoa_ljust.h,itoa_u64,,false,25,25,itoa_u64,,,3,"char* itoa_u64 (uint64_t,char*)"
19441,METHOD,itoa_ljust.h:<global>,TYPE_DECL,"char* itoa_64( int64_t i, char* buffer);",5,39,itoa_ljust.h,itoa_64,,false,26,26,itoa_64,,,4,"char* itoa_64 (int64_t,char*)"
19454,METHOD,jenkins_hash.c:<global>,TYPE_DECL,<global>,1,4,jenkins_hash.c,jenkins_hash.c:<global>,,false,1,431,<global>,,,1,
19459,METHOD,jenkins_hash.h:<global>,TYPE_DECL,<global>,1,31,jenkins_hash.h,jenkins_hash.h:<global>,,false,1,14,<global>,,,1,
19461,METHOD,jenkins_hash.h:<global>,TYPE_DECL,"uint32_t jenkins_hash(const void *key, size_t length);",10,53,jenkins_hash.h,jenkins_hash,,false,8,8,jenkins_hash,,,1,"uint32_t jenkins_hash (void*,size_t)"
19488,METHOD,linux_priv.c:<global>,TYPE_DECL,<global>,1,20,linux_priv.c,linux_priv.c:<global>,,false,1,215,<global>,,,1,
19491,METHOD,linux_priv.c:<global>,TYPE_DECL,"static void handle_syssig(int signum, siginfo_t *si, void *thread_context) {
#if defined(si_syscall)
    int syscall_no = si->si_syscall;
#else
    // If system has no support for si_syscal, the information may not be
    // precise.
    int syscall_no = si->si_value.sival_int;
#endif

    // Replace the characters in the kill message with the syscall number. We
    // can't safely printf (even write is not really valid, but we're crashing
    // anyway).

    kill_msg[39] = (syscall_no / 100) % 10 + '0';
    kill_msg[40] = (syscall_no / 10) % 10 + '0';
    kill_msg[41] = syscall_no % 10 + '0';
    if (write(2, kill_msg, strlen(kill_msg)) == -1) {
        // An error occurred, but we can't do anything about it here. This check
        // is mostly to avoid the ""ignoring return value of 'write'"" error on
        // distributions with broken gcc (no ""ignore via cast to void"" support).
    }

    // We can't use the nice exit() version because it causes at_exit handlers
    // to be lo...",1,1,linux_priv.c,handle_syssig,,false,17,43,handle_syssig,,,2,"void handle_syssig (int,siginfo_t*,void*)"
19590,METHOD,logger.c:<global>,TYPE_DECL,<global>,1,1,logger.c,logger.c:<global>,,false,1,1005,<global>,,,1,
19633,METHOD,logger.c:<global>,TYPE_DECL,"static int logger_thread_poll_watchers(int force_poll, int watcher);",12,67,logger.c,logger_thread_poll_watchers,,false,50,50,logger_thread_poll_watchers,,,24,"int logger_thread_poll_watchers (int,int)"
19639,METHOD,logger.c:<global>,TYPE_DECL,"static void _logger_log_text(logentry *e, const entry_details *d, const void *entry, va_list ap) {
    int reqlen = d->reqlen;
    int total = vsnprintf((char *) e->data, reqlen, d->format, ap);
    if (total <= 0) {
        fprintf(stderr, ""LOGGER: Failed to vsnprintf a text entry: (total) %d\n"", total);
    }
    e->size = total + 1; // null byte
}",1,1,logger.c,_logger_log_text,,false,54,61,_logger_log_text,,,25,"void _logger_log_text (logentry*,entry_details*,void*,va_list)"
19683,METHOD,logger.c:<global>,TYPE_DECL,"static void _logger_log_evictions(logentry *e, const entry_details *d, const void *entry, va_list ap) {
    item *it = (item *)entry;
    struct logentry_eviction *le = (struct logentry_eviction *) e->data;

    le->exptime = (it->exptime > 0) ? (long long int)(it->exptime - current_time) : (long long int) -1;
    le->latime = current_time - it->time;
    le->it_flags = it->it_flags;
    le->nkey = it->nkey;
    le->nbytes = it->nbytes;
    le->clsid = ITEM_clsid(it);
    memcpy(le->key, ITEM_key(it), it->nkey);
    e->size = sizeof(struct logentry_eviction) + le->nkey;
}",1,16,logger.c,_logger_log_evictions,,false,63,75,_logger_log_evictions,,,26,"void _logger_log_evictions (logentry*,entry_details*,void*,va_list)"
19807,METHOD,logger.c:<global>,TYPE_DECL,"static void _logger_log_item_get(logentry *e, const entry_details *d, const void *entry, va_list ap) {
    int was_found = va_arg(ap, int);
    char *key = va_arg(ap, char *);
    int nkey = va_arg(ap, int);
    int nbytes = va_arg(ap, int);
    uint8_t clsid = va_arg(ap, int);
    int sfd = va_arg(ap, int);

    struct logentry_item_get *le = (struct logentry_item_get *) e->data;
    le->was_found = was_found;
    le->nkey = nkey;
    le->nbytes = nbytes;
    le->clsid = clsid;
    memcpy(le->key, key, nkey);
    le->sfd = sfd;
    e->size = sizeof(struct logentry_item_get) + nkey;
}",1,1,logger.c,_logger_log_item_get,,false,96,112,_logger_log_item_get,,,27,"void _logger_log_item_get (logentry*,entry_details*,void*,va_list)"
19870,METHOD,logger.c:<global>,TYPE_DECL,"static void _logger_log_item_store(logentry *e, const entry_details *d, const void *entry, va_list ap) {
    enum store_item_type status = va_arg(ap, enum store_item_type);
    int comm = va_arg(ap, int);
    char *key = va_arg(ap, char *);
    int nkey = va_arg(ap, int);
    int nbytes = va_arg(ap, int);
    rel_time_t ttl = va_arg(ap, rel_time_t);
    uint8_t clsid = va_arg(ap, int);
    int sfd = va_arg(ap, int);

    struct logentry_item_store *le = (struct logentry_item_store *) e->data;
    le->status = status;
    le->cmd = comm;
    le->nkey = nkey;
    le->nbytes = nbytes;
    le->clsid = clsid;
    if (ttl != 0) {
        le->ttl = ttl - current_time;
    } else {
        le->ttl = 0;
    }
    memcpy(le->key, key, nkey);
    le->sfd = sfd;
    e->size = sizeof(struct logentry_item_store) + nkey;
}",1,1,logger.c,_logger_log_item_store,,false,114,138,_logger_log_item_store,,,28,"void _logger_log_item_store (logentry*,entry_details*,void*,va_list)"
19965,METHOD,logger.c:<global>,TYPE_DECL,"static void _logger_log_conn_event(logentry *e, const entry_details *d, const void *entry, va_list ap) {
    struct sockaddr_in6 *addr = va_arg(ap, struct sockaddr_in6 *);
    socklen_t addrlen = va_arg(ap, socklen_t);
    enum network_transport transport = va_arg(ap, enum network_transport);
    enum close_reasons reason = va_arg(ap, enum close_reasons);
    int sfd = va_arg(ap, int);

    struct logentry_conn_event *le = (struct logentry_conn_event *) e->data;

    memcpy(&le->addr, addr, addrlen);
    le->sfd = sfd;
    le->transport = transport;
    le->reason = reason;
    e->size = sizeof(struct logentry_conn_event);
}",1,1,logger.c,_logger_log_conn_event,,false,140,154,_logger_log_conn_event,,,29,"void _logger_log_conn_event (logentry*,entry_details*,void*,va_list)"
20022,METHOD,logger.c:<global>,TYPE_DECL,"static int _logger_util_addr_endpoint(struct sockaddr_in6 *addr, char *rip,
        size_t riplen, unsigned short *rport) {
    memset(rip, 0, riplen);

    switch (addr->sin6_family) {
        case AF_INET:
            inet_ntop(AF_INET, &((struct sockaddr_in *) addr)->sin_addr,
                    rip, riplen - 1);
            *rport = ntohs(((struct sockaddr_in *) addr)->sin_port);
            break;
        case AF_INET6:
            inet_ntop(AF_INET6, &((struct sockaddr_in6 *) addr)->sin6_addr,
                    rip, riplen - 1);
            *rport = ntohs(((struct sockaddr_in6 *) addr)->sin6_port);
            break;
#ifndef DISABLE_UNIX_SOCKET
        // Connections on Unix socket transports have c->request_addr zeroed out.
        case AF_UNSPEC:
        case AF_UNIX:
            strncpy(rip, ""unix"", strlen(""unix"") + 1);
            *rport = 0;
            break;
#endif // #ifndef DISABLE_UNIX_SOCKET
    }

    return 0;
}",1,1,logger.c,_logger_util_addr_endpoint,,false,160,186,_logger_util_addr_endpoint,,,30,"int _logger_util_addr_endpoint (sockaddr_in6*,char*,size_t,short unsigned*)"
20105,METHOD,logger.c:<global>,TYPE_DECL,"static int _logger_parse_text(logentry *e, char *scratch) {
    return snprintf(scratch, LOGGER_PARSE_SCRATCH, ""ts=%d.%d gid=%llu %s\n"",
            (int)e->tv.tv_sec, (int)e->tv.tv_usec,
            (unsigned long long) e->gid, (char *) e->data);
}",1,29,logger.c,_logger_parse_text,,false,195,199,_logger_parse_text,,,31,"int _logger_parse_text (logentry*,char*)"
20142,METHOD,logger.c:<global>,TYPE_DECL,"static int _logger_parse_ise(logentry *e, char *scratch) {
    int total;
    const char *cmd = ""na"";
    char keybuf[KEY_MAX_URI_ENCODED_LENGTH];
    struct logentry_item_store *le = (struct logentry_item_store *) e->data;
    const char * const status_map[] = {
        ""not_stored"", ""stored"", ""exists"", ""not_found"", ""too_large"", ""no_memory"" };
    const char * const cmd_map[] = {
        ""null"", ""add"", ""set"", ""replace"", ""append"", ""prepend"", ""cas"" };

    if (le->cmd <= 6)
        cmd = cmd_map[le->cmd];

    uriencode(le->key, keybuf, le->nkey, KEY_MAX_URI_ENCODED_LENGTH);
    total = snprintf(scratch, LOGGER_PARSE_SCRATCH,
            ""ts=%d.%d gid=%llu type=item_store key=%s status=%s cmd=%s ttl=%u clsid=%u cfd=%d size=%d\n"",
            (int)e->tv.tv_sec, (int)e->tv.tv_usec, (unsigned long long) e->gid,
            keybuf, status_map[le->status], cmd, le->ttl, le->clsid, le->sfd,
            le->nbytes > 0 ? le->nbytes - 2 : 0); // CLRF
    return total;
}",1,16,logger.c,_logger_parse_ise,,false,201,221,_logger_parse_ise,,,32,"int _logger_parse_ise (logentry*,char*)"
20269,METHOD,logger.c:<global>,TYPE_DECL,"static int _logger_parse_ige(logentry *e, char *scratch) {
    int total;
    struct logentry_item_get *le = (struct logentry_item_get *) e->data;
    char keybuf[KEY_MAX_URI_ENCODED_LENGTH];
    const char * const was_found_map[] = {
        ""not_found"", ""found"", ""flushed"", ""expired"" };

    uriencode(le->key, keybuf, le->nkey, KEY_MAX_URI_ENCODED_LENGTH);
    total = snprintf(scratch, LOGGER_PARSE_SCRATCH,
            ""ts=%d.%d gid=%llu type=item_get key=%s status=%s clsid=%u cfd=%d size=%d\n"",
            (int)e->tv.tv_sec, (int)e->tv.tv_usec, (unsigned long long) e->gid,
            keybuf, was_found_map[le->was_found], le->clsid, le->sfd,
            le->nbytes > 0 ? le->nbytes - 2 : 0); // CLRF
    return total;
}",1,16,logger.c,_logger_parse_ige,,false,223,237,_logger_parse_ige,,,33,"int _logger_parse_ige (logentry*,char*)"
20361,METHOD,logger.c:<global>,TYPE_DECL,"static int _logger_parse_ee(logentry *e, char *scratch) {
    int total;
    char keybuf[KEY_MAX_URI_ENCODED_LENGTH];
    struct logentry_eviction *le = (struct logentry_eviction *) e->data;
    uriencode(le->key, keybuf, le->nkey, KEY_MAX_URI_ENCODED_LENGTH);
    total = snprintf(scratch, LOGGER_PARSE_SCRATCH,
            ""ts=%d.%d gid=%llu type=eviction key=%s fetch=%s ttl=%lld la=%d clsid=%u size=%d\n"",
            (int)e->tv.tv_sec, (int)e->tv.tv_usec, (unsigned long long) e->gid,
            keybuf, (le->it_flags & ITEM_FETCHED) ? ""yes"" : ""no"",
            (long long int)le->exptime, le->latime, le->clsid,
            le->nbytes > 0 ? le->nbytes - 2 : 0); // CLRF

    return total;
}",1,16,logger.c,_logger_parse_ee,,false,239,252,_logger_parse_ee,,,34,"int _logger_parse_ee (logentry*,char*)"
20455,METHOD,logger.c:<global>,TYPE_DECL,"static int _logger_parse_cne(logentry *e, char *scratch) {
    int total;
    unsigned short rport;
    char rip[64];
    struct logentry_conn_event *le = (struct logentry_conn_event *) e->data;
    const char * const transport_map[] = { ""local"", ""tcp"", ""udp"" };

    _logger_util_addr_endpoint(&le->addr, rip, sizeof(rip), &rport);

    total = snprintf(scratch, LOGGER_PARSE_SCRATCH,
            ""ts=%d.%d gid=%llu type=conn_new rip=%s rport=%hu transport=%s cfd=%d\n"",
            (int) e->tv.tv_sec, (int) e->tv.tv_usec, (unsigned long long) e->gid,
            rip, rport, transport_map[le->transport], le->sfd);

    return total;
}",1,30,logger.c,_logger_parse_cne,,false,270,285,_logger_parse_cne,,,35,"int _logger_parse_cne (logentry*,char*)"
20528,METHOD,logger.c:<global>,TYPE_DECL,"static int _logger_parse_cce(logentry *e, char *scratch) {
    int total;
    unsigned short rport;
    char rip[64];
    struct logentry_conn_event *le = (struct logentry_conn_event *) e->data;
    const char * const transport_map[] = { ""local"", ""tcp"", ""udp"" };
    const char * const reason_map[] = { ""error"", ""normal"", ""idle_timeout"", ""shutdown"" };

    _logger_util_addr_endpoint(&le->addr, rip, sizeof(rip), &rport);

    total = snprintf(scratch, LOGGER_PARSE_SCRATCH,
            ""ts=%d.%d gid=%llu type=conn_close rip=%s rport=%hu transport=%s reason=%s cfd=%d\n"",
            (int) e->tv.tv_sec, (int) e->tv.tv_usec, (unsigned long long) e->gid,
            rip, rport, transport_map[le->transport],
            reason_map[le->reason], le->sfd);

    return total;
}",1,30,logger.c,_logger_parse_cce,,false,287,304,_logger_parse_cce,,,36,"int _logger_parse_cce (logentry*,char*)"
20726,METHOD,logger.c:<global>,TYPE_DECL,"uint64_t logger_get_gid(void) {
#ifdef HAVE_GCC_64ATOMICS
    return __sync_add_and_fetch(&logger_gid, 1);
#elif defined(__sun)
    return atomic_inc_64_nv(&logger_gid);
#else
    mutex_lock(&logger_atomics_mutex);
    uint64_t res = ++logger_gid;
    mutex_unlock(&logger_atomics_mutex);
    return res;
#endif
}",1,4,logger.c,logger_get_gid,,false,431,442,logger_get_gid,,,41,uint64_t logger_get_gid (void)
20752,METHOD,logger.c:<global>,TYPE_DECL,"void logger_set_gid(uint64_t gid) {
#ifdef HAVE_GCC_64ATOMICS
    __sync_add_and_fetch(&logger_gid, gid);
#elif defined(__sun)
    atomic_add_64(&logger_gid);
#else
    mutex_lock(&logger_atomics_mutex);
    logger_gid = gid;
    mutex_unlock(&logger_atomics_mutex);
#endif
}",1,4,logger.c,logger_set_gid,,false,444,454,logger_set_gid,,,42,void logger_set_gid (uint64_t)
20774,METHOD,logger.c:<global>,TYPE_DECL,"static void logger_link_q(logger *l) {
    pthread_mutex_lock(&logger_stack_lock);
    assert(l != logger_stack_head);

    l->prev = 0;
    l->next = logger_stack_head;
    if (l->next) l->next->prev = l;
    logger_stack_head = l;
    if (logger_stack_tail == 0) logger_stack_tail = l;
    logger_count++;
    pthread_mutex_unlock(&logger_stack_lock);
    return;
}",1,1,logger.c,logger_link_q,,false,460,472,logger_link_q,,,43,void logger_link_q (logger*)
20825,METHOD,logger.c:<global>,TYPE_DECL,"static void logger_set_flags(void) {
    logger *l = NULL;
    int x = 0;
    uint16_t f = 0; /* logger eflags */

    for (x = 0; x < WATCHER_LIMIT; x++) {
        logger_watcher *w = watchers[x];
        if (w == NULL)
            continue;

        f |= w->eflags;
    }
    for (l = logger_stack_head; l != NULL; l=l->next) {
        pthread_mutex_lock(&l->mutex);
        l->eflags = f;
        pthread_mutex_unlock(&l->mutex);
    }
    return;
}",1,20,logger.c,logger_set_flags,,false,498,516,logger_set_flags,,,44,void logger_set_flags (void)
20902,METHOD,logger.c:<global>,TYPE_DECL,"static enum logger_parse_entry_ret logger_thread_parse_entry(logentry *e, struct logger_stats *ls,
        char *scratch, int *scratch_len) {
    int total = 0;
    const entry_details *d = &default_entries[e->event];
    assert(d->parse_cb != NULL);
    total = d->parse_cb(e, scratch);

    if (total >= LOGGER_PARSE_SCRATCH || total <= 0) {
        L_DEBUG(""LOGGER: Failed to flatten log entry!\n"");
        return LOGGER_PARSE_ENTRY_FAILED;
    } else {
        *scratch_len = total;
    }

    return LOGGER_PARSE_ENTRY_OK;
}",1,17,logger.c,logger_thread_parse_entry,,false,519,534,logger_thread_parse_entry,,,45,"enum logger_parse_entry_ret logger_thread_parse_entry (logentry*,logger_stats*,char*,int*)"
20958,METHOD,logger.c:<global>,TYPE_DECL,"static void logger_thread_write_entry(logentry *e, struct logger_stats *ls,
        char *scratch, int scratch_len) {
    int x, total;
    /* Write the line into available watchers with matching flags */
    for (x = 0; x < WATCHER_LIMIT; x++) {
        logger_watcher *w = watchers[x];
        char *skip_scr = NULL;
        if (w == NULL || (e->eflags & w->eflags) == 0 || (e->gid < w->min_gid))
            continue;

         /* Avoid poll()'ing constantly when buffer is full by resetting a
         * flag periodically.
         */
        while (!w->failed_flush &&
                (skip_scr = (char *) bipbuf_request(w->buf, scratch_len + 128)) == NULL) {
            if (logger_thread_poll_watchers(0, x) <= 0) {
                L_DEBUG(""LOGGER: Watcher had no free space for line of size (%d)\n"", scratch_len + 128);
                w->failed_flush = true;
            }
        }

        if (w->failed_flush) {
            L_DEBUG(""LOGGER: Fast skipped for watcher [%d] due to failed_...",1,20,logger.c,logger_thread_write_entry,,false,537,580,logger_thread_write_entry,,,46,"void logger_thread_write_entry (logentry*,logger_stats*,char*,int)"
21119,METHOD,logger.c:<global>,TYPE_DECL,"static void logger_thread_close_watcher(logger_watcher *w) {
    L_DEBUG(""LOGGER: Closing dead watcher\n"");
    watchers[w->id] = NULL;
    sidethread_conn_close(w->c);
    watcher_count--;
    bipbuf_free(w->buf);
    free(w);
    logger_set_flags();
}",1,4,logger.c,logger_thread_close_watcher,,false,587,595,logger_thread_close_watcher,,,47,void logger_thread_close_watcher (logger_watcher*)
21144,METHOD,logger.c:<global>,TYPE_DECL,"static int logger_thread_read(logger *l, struct logger_stats *ls) {
    unsigned int size;
    unsigned int pos = 0;
    unsigned char *data;
    char scratch[LOGGER_PARSE_SCRATCH];
    logentry *e;
    pthread_mutex_lock(&l->mutex);
    data = bipbuf_peek_all(l->buf, &size);
    pthread_mutex_unlock(&l->mutex);

    if (data == NULL) {
        return 0;
    }
    L_DEBUG(""LOGGER: Got %d bytes from bipbuffer\n"", size);

    /* parse buffer */
    while (pos < size && watcher_count > 0) {
        enum logger_parse_entry_ret ret;
        int scratch_len = 0;
        e = (logentry *) (data + pos);
        ret = logger_thread_parse_entry(e, ls, scratch, &scratch_len);
        if (ret != LOGGER_PARSE_ENTRY_OK) {
            /* TODO: stats counter */
            fprintf(stderr, ""LOGGER: Failed to parse log entry\n"");
        } else {
            logger_thread_write_entry(e, ls, scratch, scratch_len);
        }
        pos += sizeof(logentry) + e->size + e->pad;
    }
    assert(pos <= siz...",1,17,logger.c,logger_thread_read,,false,600,643,logger_thread_read,,,48,"int logger_thread_read (logger*,logger_stats*)"
21296,METHOD,logger.c:<global>,TYPE_DECL,"static int logger_thread_poll_watchers(int force_poll, int watcher) {
    int x;
    int nfd = 0;
    unsigned char *data;
    unsigned int data_size = 0;
    int flushed = 0;

    for (x = 0; x < WATCHER_LIMIT; x++) {
        logger_watcher *w = watchers[x];
        if (w == NULL || (watcher != WATCHER_ALL && x != watcher))
            continue;

        data = bipbuf_peek_all(w->buf, &data_size);
        if (data != NULL) {
            watchers_pollfds[nfd].fd = w->sfd;
            watchers_pollfds[nfd].events = POLLOUT;
            nfd++;
        } else if (force_poll) {
            watchers_pollfds[nfd].fd = w->sfd;
            watchers_pollfds[nfd].events = POLLIN;
            nfd++;
        }
        /* This gets set after a call to poll, and should be used to gate on
         * calling poll again.
         */
        w->failed_flush = false;
    }

    if (nfd == 0)
        return 0;

    //L_DEBUG(""LOGGER: calling poll() [data_size: %d]\n"", data_size);
    int ret = poll(wat...",1,20,logger.c,logger_thread_poll_watchers,,false,656,750,logger_thread_poll_watchers,,,49,"int logger_thread_poll_watchers (int,int)"
21639,METHOD,logger.c:<global>,TYPE_DECL,"static void logger_thread_flush_stats(struct logger_stats *ls) {
    STATS_LOCK();
    stats.log_worker_dropped  += ls->worker_dropped;
    stats.log_worker_written  += ls->worker_written;
    stats.log_watcher_skipped += ls->watcher_skipped;
    stats.log_watcher_sent    += ls->watcher_sent;
    stats_state.log_watchers   = ls->watcher_count;
    STATS_UNLOCK();
}",1,1,logger.c,logger_thread_flush_stats,,false,752,760,logger_thread_flush_stats,,,50,void logger_thread_flush_stats (logger_stats*)
21681,METHOD,logger.c:<global>,TYPE_DECL,"static void *logger_thread(void *arg) {
    useconds_t to_sleep = MIN_LOGGER_SLEEP;
    L_DEBUG(""LOGGER: Starting logger thread\n"");
    // TODO: If we ever have item references in the logger code, will need to
    // ensure everything is dequeued before stopping the thread.
    while (do_run_logger_thread) {
        int found_logs = 0;
        logger *l;
        struct logger_stats ls;
        memset(&ls, 0, sizeof(struct logger_stats));

        /* only sleep if we're *above* the minimum */
        if (to_sleep > MIN_LOGGER_SLEEP)
            usleep(to_sleep);

        /* Call function to iterate each logger. */
        pthread_mutex_lock(&logger_stack_lock);
        if (watcher_count == 0) {
            // Not bothering to loop on the condition here since it's fine to
            // walk through with zero watchers.
            pthread_cond_wait(&logger_stack_cond, &logger_stack_lock);
        }
        for (l = logger_stack_head; l != NULL; l=l->next) {
            /* lock logger...",1,26,logger.c,logger_thread,,false,766,815,logger_thread,,,51,void* logger_thread (void*)
21813,METHOD,logger.c:<global>,TYPE_DECL,"static int start_logger_thread(void) {
    int ret;
    do_run_logger_thread = 1;
    if ((ret = pthread_create(&logger_tid, NULL,
                              logger_thread, NULL)) != 0) {
        fprintf(stderr, ""Can't start logger thread: %s\n"", strerror(ret));
        return -1;
    }
    return 0;
}",1,1,logger.c,start_logger_thread,,false,817,826,start_logger_thread,,,52,int start_logger_thread (void)
21844,METHOD,logger.c:<global>,TYPE_DECL,"static int stop_logger_thread(void) {
    // Guarantees that the logger thread is waiting on 'logger_stack_cond'
    // before we signal it.
    pthread_mutex_lock(&logger_stack_lock);
    do_run_logger_thread = 0;
    pthread_cond_signal(&logger_stack_cond);
    pthread_mutex_unlock(&logger_stack_lock);
    pthread_join(logger_tid, NULL);
    return 0;
}",1,1,logger.c,stop_logger_thread,,false,828,837,stop_logger_thread,,,53,int stop_logger_thread (void)
21866,METHOD,logger.c:<global>,TYPE_DECL,"void logger_init(void) {
    /* TODO: auto destructor when threads exit */
    /* TODO: error handling */

    /* init stack for iterating loggers */
    logger_stack_head = 0;
    logger_stack_tail = 0;
    pthread_key_create(&logger_key, NULL);

    if (start_logger_thread() != 0) {
        abort();
    }

    /* This is what adding a STDERR watcher looks like. should replace old
     * ""verbose"" settings. */
    //logger_add_watcher(NULL, 0);
    return;
}",1,1,logger.c,logger_init,,false,844,861,logger_init,,,54,void logger_init (void)
21888,METHOD,logger.c:<global>,TYPE_DECL,"void logger_stop(void) {
    stop_logger_thread();
}",1,1,logger.c,logger_stop,,false,863,865,logger_stop,,,55,void logger_stop (void)
21894,METHOD,logger.c:<global>,TYPE_DECL,"logger *logger_create(void) {
    L_DEBUG(""LOGGER: Creating and linking new logger instance\n"");
    logger *l = calloc(1, sizeof(logger));
    if (l == NULL) {
        return NULL;
    }

    l->buf = bipbuf_new(settings.logger_buf_size);
    if (l->buf == NULL) {
        free(l);
        return NULL;
    }

    l->entry_map = default_entries;

    pthread_mutex_init(&l->mutex, NULL);
    pthread_setspecific(logger_key, l);

    /* add to list of loggers */
    logger_link_q(l);
    return l;
}",1,4,logger.c,logger_create,,false,870,891,logger_create,,,56,logger logger_create (void)
21950,METHOD,logger.c:<global>,TYPE_DECL,"enum logger_ret_type logger_log(logger *l, const enum log_entry_type event, const void *entry, ...) {
    bipbuf_t *buf = l->buf;
    bool nospace = false;
    va_list ap;
    logentry *e;

    const entry_details *d = &l->entry_map[event];
    int reqlen = d->reqlen;

    pthread_mutex_lock(&l->mutex);
    /* Request a maximum length of data to write to */
    e = (logentry *) bipbuf_request(buf, (sizeof(logentry) + reqlen));
    if (e == NULL) {
        pthread_mutex_unlock(&l->mutex);
        l->dropped++;
        return LOGGER_RET_NOSPACE;
    }
    e->event = event;
    e->pad = 0;
    e->gid = logger_get_gid();
    /* TODO: Could pass this down as an argument now that we're using
     * LOGGER_LOG() macro.
     */
    e->eflags = d->eflags;
    /* Noting time isn't optional. A feature may be added to avoid rendering
     * time and/or gid to a logger.
     */
    gettimeofday(&e->tv, NULL);

    va_start(ap, entry);
    d->log_cb(e, d, entry, ap);
    va_end(ap);

#ifdef NEED_...",1,4,logger.c,logger_log,,false,897,954,logger_log,,,57,"enum logger_ret_type logger_log (logger*,log_entry_type,void*...)"
22100,METHOD,logger.c:<global>,TYPE_DECL,"enum logger_add_watcher_ret logger_add_watcher(void *c, const int sfd, uint16_t f) {
    int x;
    logger_watcher *w = NULL;
    pthread_mutex_lock(&logger_stack_lock);
    if (watcher_count >= WATCHER_LIMIT) {
        pthread_mutex_unlock(&logger_stack_lock);
        return LOGGER_ADD_WATCHER_TOO_MANY;
    }

    for (x = 0; x < WATCHER_LIMIT-1; x++) {
        if (watchers[x] == NULL)
            break;
    }

    w = calloc(1, sizeof(logger_watcher));
    if (w == NULL) {
        pthread_mutex_unlock(&logger_stack_lock);
        return LOGGER_ADD_WATCHER_FAILED;
    }
    w->c = c;
    w->sfd = sfd;
    if (sfd == 0 && c == NULL) {
        w->t = LOGGER_WATCHER_STDERR;
    } else {
        w->t = LOGGER_WATCHER_CLIENT;
    }
    w->id = x;
    w->eflags = f;
    w->min_gid = logger_get_gid();
    w->buf = bipbuf_new(settings.logger_watcher_buf_size);
    if (w->buf == NULL) {
        free(w);
        pthread_mutex_unlock(&logger_stack_lock);
        return LOGGER_ADD_WATCHER_FAIL...",1,25,logger.c,logger_add_watcher,,false,960,1005,logger_add_watcher,,,58,"enum logger_add_watcher_ret logger_add_watcher (void*,int,uint16_t)"
22263,METHOD,logger.h:<global>,TYPE_DECL,<global>,1,1,logger.h,logger.h:<global>,,false,1,230,<global>,,,1,
22275,METHOD,<empty>,<empty>,<empty>,1,,logger.h,log_entry_type:<clinit>,,false,16,,<clinit>,,,9,
22286,METHOD,<empty>,<empty>,<empty>,1,,logger.h,logger_ret_type:<clinit>,,false,44,,<clinit>,,,4,
22297,METHOD,<empty>,<empty>,<empty>,1,,logger.h,logger_parse_entry_ret:<clinit>,,false,50,,<clinit>,,,4,
22308,METHOD,logger.h:<global>,TYPE_DECL,"typedef void (*entry_log_cb)(logentry *e, const entry_details *d, const void *entry, va_list ap);",14,96,logger.h,entry_log_cb,,false,59,59,entry_log_cb,,,9,"void entry_log_cb (logentry*,entry_details*,void*,va_list)"
22316,METHOD,logger.h:<global>,TYPE_DECL,"typedef int (*entry_parse_cb)(logentry *e, char *scratch);",13,57,logger.h,entry_parse_cb,,false,60,60,entry_parse_cb,,,10,"int entry_parse_cb (logentry*,char*)"
22336,METHOD,<empty>,<empty>,<empty>,1,,logger.h,logentry_eviction:<clinit>,,false,71,,<clinit>,,,8,
22348,METHOD,<empty>,<empty>,<empty>,1,,logger.h,logentry_item_get:<clinit>,,false,91,,<clinit>,,,7,
22362,METHOD,<empty>,<empty>,<empty>,1,,logger.h,logentry_item_store:<clinit>,,false,100,,<clinit>,,,9,
22385,METHOD,<empty>,<empty>,<empty>,1,,logger.h,_logentry:<clinit>,,false,135,,<clinit>,,,11,
22408,METHOD,<empty>,<empty>,<empty>,1,,logger.h,logger_watcher_type:<clinit>,,false,173,,<clinit>,,,3,
22437,METHOD,logger.h:<global>,TYPE_DECL,void logger_init(void);,6,22,logger.h,logger_init,,false,203,203,logger_init,,,24,void logger_init (void)
22442,METHOD,logger.h:<global>,TYPE_DECL,void logger_stop(void);,6,22,logger.h,logger_stop,,false,204,204,logger_stop,,,25,void logger_stop (void)
22447,METHOD,logger.h:<global>,TYPE_DECL,logger *logger_create(void);,8,27,logger.h,logger_create,,false,205,205,logger_create,,,26,logger* logger_create (void)
22458,METHOD,<empty>,<empty>,<empty>,1,,logger.h,logger_add_watcher_ret:<clinit>,,false,218,,<clinit>,,,4,
22467,METHOD,logger.h:<global>,TYPE_DECL,uint64_t logger_get_gid(void);,10,29,logger.h,logger_get_gid,,false,227,227,logger_get_gid,,,32,uint64_t logger_get_gid (void)
22472,METHOD,logger.h:<global>,TYPE_DECL,void logger_set_gid(uint64_t gid);,6,33,logger.h,logger_set_gid,,false,228,228,logger_set_gid,,,33,void logger_set_gid (uint64_t)
22484,METHOD,md5.c:<global>,TYPE_DECL,<global>,1,1,md5.c,md5.c:<global>,,false,1,381,<global>,,,1,
22486,METHOD,md5.c:<global>,TYPE_DECL,"static void
md5_process(md5_state_t *pms, const md5_byte_t *data /*[64]*/)
{
    md5_word_t
	a = pms->abcd[0], b = pms->abcd[1],
	c = pms->abcd[2], d = pms->abcd[3];
    md5_word_t t;
#if BYTE_ORDER > 0
    /* Define storage only for big-endian CPUs. */
    md5_word_t X[16];
#else
    /* Define storage for little-endian or both types of CPUs. */
    md5_word_t xbuf[16];
    const md5_word_t *X;
#endif

    {
#if BYTE_ORDER == 0
	/*
	 * Determine dynamically whether this is a big-endian or
	 * little-endian machine, since we can use a more efficient
	 * algorithm on the latter.
	 */
	static const int w = 1;

	if (*((const md5_byte_t *)&w)) /* dynamic little-endian */
#endif
#if BYTE_ORDER <= 0		/* little-endian */
	{
	    /*
	     * On little-endian machines, we can process properly aligned
	     * data without copying it.
	     */
	    if (!((data - (const md5_byte_t *)0) & 3)) {
		/* data are properly aligned */
		X = (const md5_word_t *)data;
	    } else {
		/* not aligned */
		me...",1,4,md5.c,md5_process,,false,131,310,md5_process,,,1,"void md5_process (md5_state_t*,md5_byte_t*)"
25213,METHOD,md5.c:<global>,TYPE_DECL,"void
md5_init(md5_state_t *pms)
{
    pms->count[0] = pms->count[1] = 0;
    pms->abcd[0] = 0x67452301;
    pms->abcd[1] = /*0xefcdab89*/ T_MASK ^ 0x10325476;
    pms->abcd[2] = /*0x98badcfe*/ T_MASK ^ 0x67452301;
    pms->abcd[3] = 0x10325476;
}",1,34,md5.c,md5_init,,false,312,320,md5_init,,,2,void md5_init (md5_state_t*)
25273,METHOD,md5.c:<global>,TYPE_DECL,"void
md5_append(md5_state_t *pms, const md5_byte_t *data, int nbytes)
{
    const md5_byte_t *p = data;
    int left = nbytes;
    int offset = (pms->count[0] >> 3) & 63;
    md5_word_t nbits = (md5_word_t)(nbytes << 3);

    if (nbytes <= 0)
	return;

    /* Update the message length. */
    pms->count[1] += nbytes >> 29;
    pms->count[0] += nbits;
    if (pms->count[0] < nbits)
	pms->count[1]++;

    /* Process an initial partial block. */
    if (offset) {
	int copy = (offset + nbytes > 64 ? 64 - offset : nbytes);

	memcpy(pms->buf + offset, p, copy);
	if (offset + copy < 64)
	    return;
	p += copy;
	left -= copy;
	md5_process(pms, pms->buf);
    }

    /* Process full blocks. */
    for (; left >= 64; p += 64, left -= 64)
	md5_process(pms, p);

    /* Process a final partial block. */
    if (left)
	memcpy(pms->buf, p, left);
}",1,1,md5.c,md5_append,,false,322,358,md5_append,,,3,"void md5_append (md5_state_t*,md5_byte_t*,int)"
25412,METHOD,md5.c:<global>,TYPE_DECL,"void
md5_finish(md5_state_t *pms, md5_byte_t digest[16])
{
    static const md5_byte_t pad[64] = {
	0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    };
    md5_byte_t data[8];
    int i;

    /* Save the length before padding. */
    for (i = 0; i < 8; ++i)
	data[i] = (md5_byte_t)(pms->count[i >> 2] >> ((i & 3) << 3));
    /* Pad to 56 bytes mod 64. */
    md5_append(pms, pad, ((55 - (pms->count[0] >> 3)) & 63) + 1);
    /* Append the length. */
    md5_append(pms, data, 8);
    for (i = 0; i < 16; ++i)
	digest[i] = (md5_byte_t)(pms->abcd[i >> 2] >> ((i & 3) << 3));
}",1,1,md5.c,md5_finish,,false,360,381,md5_finish,,,4,"void md5_finish (md5_state_t*,md5_byte_t[16])"
25569,METHOD,md5.h:<global>,TYPE_DECL,<global>,1,25,md5.h,md5.h:<global>,,false,1,101,<global>,,,1,
25577,METHOD,<empty>,<empty>,<empty>,1,,md5.h,md5_state_s:<clinit>,,false,67,,<clinit>,,,4,
25588,METHOD,md5.h:<global>,TYPE_DECL,void md5_init(md5_state_t *pms);,6,31,md5.h,md5_init,,false,83,83,md5_init,,,5,void md5_init (md5_state_t*)
25593,METHOD,md5.h:<global>,TYPE_DECL,"void md5_append(md5_state_t *pms, const md5_byte_t *data, int nbytes);",6,69,md5.h,md5_append,,false,89,89,md5_append,,,6,"void md5_append (md5_state_t*,md5_byte_t*,int)"
25600,METHOD,md5.h:<global>,TYPE_DECL,"void md5_finish(md5_state_t *pms, md5_byte_t digest[16]);",6,56,md5.h,md5_finish,,false,95,95,md5_finish,,,7,"void md5_finish (md5_state_t*,md5_byte_t[16])"
25673,METHOD,memcached.c:<global>,TYPE_DECL,<global>,1,4,memcached.c,memcached.c:<global>,,false,1,6295,<global>,,,1,
25675,METHOD,memcached.c:<global>,TYPE_DECL,static void drive_machine(conn *c);,13,34,memcached.c,drive_machine,,false,68,68,drive_machine,,,1,void drive_machine (conn*)
25680,METHOD,memcached.c:<global>,TYPE_DECL,static int new_socket(struct addrinfo *ai);,12,42,memcached.c,new_socket,,false,69,69,new_socket,,,2,int new_socket (addrinfo*)
25685,METHOD,memcached.c:<global>,TYPE_DECL,"static ssize_t tcp_read(conn *arg, void *buf, size_t count);",16,59,memcached.c,tcp_read,,false,70,70,tcp_read,,,3,"ssize_t tcp_read (conn*,void*,size_t)"
25692,METHOD,memcached.c:<global>,TYPE_DECL,"static ssize_t tcp_sendmsg(conn *arg, struct msghdr *msg, int flags);",16,68,memcached.c,tcp_sendmsg,,false,71,71,tcp_sendmsg,,,4,"ssize_t tcp_sendmsg (conn*,msghdr*,int)"
25699,METHOD,memcached.c:<global>,TYPE_DECL,"static ssize_t tcp_write(conn *arg, void *buf, size_t count);",16,60,memcached.c,tcp_write,,false,72,72,tcp_write,,,5,"ssize_t tcp_write (conn*,void*,size_t)"
25711,METHOD,memcached.c:<global>,TYPE_DECL,static int try_read_command_negotiate(conn *c);,12,46,memcached.c,try_read_command_negotiate,,false,81,81,try_read_command_negotiate,,,7,int try_read_command_negotiate (conn*)
25716,METHOD,memcached.c:<global>,TYPE_DECL,static int try_read_command_udp(conn *c);,12,40,memcached.c,try_read_command_udp,,false,82,82,try_read_command_udp,,,8,int try_read_command_udp (conn*)
25725,METHOD,memcached.c:<global>,TYPE_DECL,static int start_conn_timeout_thread();,12,38,memcached.c,start_conn_timeout_thread,,false,87,87,start_conn_timeout_thread,,,13,int start_conn_timeout_thread ()
25729,METHOD,memcached.c:<global>,TYPE_DECL,static void stats_init(void);,13,28,memcached.c,stats_init,,false,90,90,stats_init,,,14,void stats_init (void)
25734,METHOD,memcached.c:<global>,TYPE_DECL,"static void conn_to_str(const conn *c, char *addr, char *svr_addr);",13,66,memcached.c,conn_to_str,,false,91,91,conn_to_str,,,15,"void conn_to_str (conn*,char*,char*)"
25741,METHOD,memcached.c:<global>,TYPE_DECL,static void settings_init(void);,13,31,memcached.c,settings_init,,false,94,94,settings_init,,,16,void settings_init (void)
25746,METHOD,memcached.c:<global>,TYPE_DECL,"static void event_handler(const evutil_socket_t fd, const short which, void *arg);",13,81,memcached.c,event_handler,,false,97,97,event_handler,,,17,"void event_handler (evutil_socket_t,short,void*)"
25753,METHOD,memcached.c:<global>,TYPE_DECL,static void conn_close(conn *c);,13,31,memcached.c,conn_close,,false,98,98,conn_close,,,18,void conn_close (conn*)
25758,METHOD,memcached.c:<global>,TYPE_DECL,static void conn_init(void);,13,27,memcached.c,conn_init,,false,99,99,conn_init,,,19,void conn_init (void)
25763,METHOD,memcached.c:<global>,TYPE_DECL,"static bool update_event(conn *c, const int new_flags);",13,54,memcached.c,update_event,,false,100,100,update_event,,,20,"bool update_event (conn*,int)"
25769,METHOD,memcached.c:<global>,TYPE_DECL,static void complete_nread(conn *c);,13,35,memcached.c,complete_nread,,false,101,101,complete_nread,,,21,void complete_nread (conn*)
25774,METHOD,memcached.c:<global>,TYPE_DECL,static void conn_free(conn *c);,13,30,memcached.c,conn_free,,false,103,103,conn_free,,,22,void conn_free (conn*)
25802,METHOD,memcached.c:<global>,TYPE_DECL,"ssize_t tcp_read(conn *c, void *buf, size_t count) {
    assert (c != NULL);
    return read(c->sfd, buf, count);
}",1,1,memcached.c,tcp_read,,false,133,136,tcp_read,,,40,"ssize_t tcp_read (conn*,void*,size_t)"
25820,METHOD,memcached.c:<global>,TYPE_DECL,"ssize_t tcp_sendmsg(conn *c, struct msghdr *msg, int flags) {
    assert (c != NULL);
    return sendmsg(c->sfd, msg, flags);
}",1,1,memcached.c,tcp_sendmsg,,false,138,141,tcp_sendmsg,,,41,"ssize_t tcp_sendmsg (conn*,msghdr*,int)"
25838,METHOD,memcached.c:<global>,TYPE_DECL,"ssize_t tcp_write(conn *c, void *buf, size_t count) {
    assert (c != NULL);
    return write(c->sfd, buf, count);
}",1,1,memcached.c,tcp_write,,false,143,146,tcp_write,,,42,"ssize_t tcp_write (conn*,void*,size_t)"
25868,METHOD,memcached.c:<global>,TYPE_DECL,"static void maxconns_handler(const evutil_socket_t fd, const short which, void *arg) {
    struct timeval t = {.tv_sec = 0, .tv_usec = 10000};

    if (fd == -42 || allow_new_conns == false) {
        /* reschedule in 10ms if we need to keep polling */
        evtimer_set(&maxconnsevent, maxconns_handler, 0);
        event_base_set(main_base, &maxconnsevent);
        evtimer_add(&maxconnsevent, &t);
    } else {
        evtimer_del(&maxconnsevent);
        accept_new_conns(true);
    }
}",1,1,memcached.c,maxconns_handler,,false,158,170,maxconns_handler,,,51,"void maxconns_handler (evutil_socket_t,short,void*)"
25918,METHOD,memcached.c:<global>,TYPE_DECL,"rel_time_t realtime(const time_t exptime) {
    /* no. of seconds in 30 days - largest possible delta exptime */

    if (exptime == 0) return 0; /* 0 means never expire */

    if (exptime > REALTIME_MAXDELTA) {
        /* if item expiration is at/before the server started, give it an
           expiration time of 1 second after the server started.
           (because 0 means don't expire).  without this, we'd
           underflow and wrap around to some large value way in the
           future, effectively making items expiring in the past
           really expiring never */
        if (exptime <= process_started)
            return (rel_time_t)1;
        return (rel_time_t)(exptime - process_started);
    } else {
        return (rel_time_t)(exptime + current_time);
    }
}",1,18,memcached.c,realtime,,false,177,195,realtime,,,52,rel_time_t realtime (time_t)
25966,METHOD,memcached.c:<global>,TYPE_DECL,"static void stats_init(void) {
    memset(&stats, 0, sizeof(struct stats));
    memset(&stats_state, 0, sizeof(struct stats_state));
    stats_state.accepting_conns = true; /* assuming we start in this state. */

    /* make the time we started always be 2 seconds before we really
       did, so time(0) - time.started is never zero.  if so, things
       like 'settings.oldest_live' which act as booleans as well as
       values are now false in boolean context... */
    process_started = time(0) - ITEM_UPDATE_INTERVAL - 2;
    stats_prefix_init(settings.prefix_delimiter);
}",1,32,memcached.c,stats_init,,false,197,208,stats_init,,,53,void stats_init (void)
26002,METHOD,memcached.c:<global>,TYPE_DECL,"void stats_reset(void) {
    STATS_LOCK();
    memset(&stats, 0, sizeof(struct stats));
    stats_prefix_clear();
    STATS_UNLOCK();
    threadlocal_stats_reset();
    item_stats_reset();
}",1,1,memcached.c,stats_reset,,false,210,217,stats_reset,,,54,void stats_reset (void)
26018,METHOD,memcached.c:<global>,TYPE_DECL,"static void settings_init(void) {
    settings.use_cas = true;
    settings.access = 0700;
    settings.port = 11211;
    settings.udpport = 0;
#ifdef TLS
    settings.ssl_enabled = false;
    settings.ssl_ctx = NULL;
    settings.ssl_chain_cert = NULL;
    settings.ssl_key = NULL;
    settings.ssl_verify_mode = SSL_VERIFY_NONE;
    settings.ssl_keyformat = SSL_FILETYPE_PEM;
    settings.ssl_ciphers = NULL;
    settings.ssl_ca_cert = NULL;
    settings.ssl_last_cert_refresh_time = current_time;
    settings.ssl_wbuf_size = 16 * 1024; // default is 16KB (SSL max frame size is 17KB)
    settings.ssl_session_cache = false;
    settings.ssl_kernel_tls = false;
    settings.ssl_min_version = TLS1_2_VERSION;
#endif
    /* By default this string should be NULL for getaddrinfo() */
    settings.inter = NULL;
    settings.maxbytes = 64 * 1024 * 1024; /* default is 64MB */
    settings.maxconns = 1024;         /* to limit connections-related memory to about 5MB */
    settings.verbose = 0;
  ...",1,32,memcached.c,settings_init,,false,219,298,settings_init,,,55,void settings_init (void)
26336,METHOD,memcached.c:<global>,TYPE_DECL,"static void *conn_timeout_thread(void *arg) {
    int i;
    conn *c;
    rel_time_t oldest_last_cmd;
    int sleep_time;
    int sleep_slice = max_fds / CONNS_PER_SLICE;
    if (sleep_slice == 0)
        sleep_slice = CONNS_PER_SLICE;

    useconds_t timeslice = 1000000 / sleep_slice;

    mutex_lock(&conn_timeout_lock);
    while(do_run_conn_timeout_thread) {
        if (settings.verbose > 2)
            fprintf(stderr, ""idle timeout thread at top of connection list\n"");

        oldest_last_cmd = current_time;

        for (i = 0; i < max_fds; i++) {
            if ((i % CONNS_PER_SLICE) == 0) {
                if (settings.verbose > 2)
                    fprintf(stderr, ""idle timeout thread sleeping for %ulus\n"",
                        (unsigned int)timeslice);
                usleep(timeslice);
            }

            if (!conns[i])
                continue;

            c = conns[i];

            if (!IS_TCP(c->transport))
                continue;

            if (c->sta...",1,32,memcached.c,conn_timeout_thread,,false,309,375,conn_timeout_thread,,,63,void* conn_timeout_thread (void*)
26560,METHOD,memcached.c:<global>,TYPE_DECL,"static int start_conn_timeout_thread() {
    int ret;

    if (settings.idle_timeout == 0)
        return -1;

    do_run_conn_timeout_thread = 1;
    if ((ret = pthread_create(&conn_timeout_tid, NULL,
        conn_timeout_thread, NULL)) != 0) {
        fprintf(stderr, ""Can't create idle connection timeout thread: %s\n"",
            strerror(ret));
        return -1;
    }

    return 0;
}",1,1,memcached.c,start_conn_timeout_thread,,false,377,392,start_conn_timeout_thread,,,64,int start_conn_timeout_thread ()
26600,METHOD,memcached.c:<global>,TYPE_DECL,"int stop_conn_timeout_thread(void) {
    if (!do_run_conn_timeout_thread)
        return -1;
    mutex_lock(&conn_timeout_lock);
    do_run_conn_timeout_thread = 0;
    pthread_cond_signal(&conn_timeout_cond);
    mutex_unlock(&conn_timeout_lock);
    pthread_join(conn_timeout_tid, NULL);
    return 0;
}",1,4,memcached.c,stop_conn_timeout_thread,,false,394,403,stop_conn_timeout_thread,,,65,int stop_conn_timeout_thread (void)
26637,METHOD,memcached.c:<global>,TYPE_DECL,"static void rbuf_release(conn *c) {
    if (c->rbuf != NULL && c->rbytes == 0 && !IS_UDP(c->transport)) {
        if (c->rbuf_malloced) {
            free(c->rbuf);
            c->rbuf_malloced = false;
        } else {
            do_cache_free(c->thread->rbuf_cache, c->rbuf);
        }
        c->rsize = 0;
        c->rbuf = NULL;
        c->rcurr = NULL;
    }
}",1,46,memcached.c,rbuf_release,,false,408,420,rbuf_release,,,66,void rbuf_release (conn*)
26707,METHOD,memcached.c:<global>,TYPE_DECL,"static bool rbuf_alloc(conn *c) {
    if (c->rbuf == NULL) {
        c->rbuf = do_cache_alloc(c->thread->rbuf_cache);
        if (!c->rbuf) {
            THR_STATS_LOCK(c);
            c->thread->stats.read_buf_oom++;
            THR_STATS_UNLOCK(c);
            return false;
        }
        c->rsize = READ_BUFFER_SIZE;
        c->rcurr = c->rbuf;
    }
    return true;
}",1,12,memcached.c,rbuf_alloc,,false,422,435,rbuf_alloc,,,67,bool rbuf_alloc (conn*)
26785,METHOD,memcached.c:<global>,TYPE_DECL,"bool rbuf_switch_to_malloc(conn *c) {
    // Might as well start with x2 and work from there.
    size_t size = c->rsize * 2;
    char *tmp = malloc(size);
    if (!tmp)
        return false;

    memcpy(tmp, c->rcurr, c->rbytes);
    do_cache_free(c->thread->rbuf_cache, c->rbuf);

    c->rcurr = c->rbuf = tmp;
    c->rsize = size;
    c->rbuf_malloced = true;
    return true;
}",1,1,memcached.c,rbuf_switch_to_malloc,,false,440,454,rbuf_switch_to_malloc,,,68,bool rbuf_switch_to_malloc (conn*)
26847,METHOD,memcached.c:<global>,TYPE_DECL,"static void conn_init(void) {
    /* We're unlikely to see an FD much higher than maxconns. */
    int next_fd = dup(1);
    if (next_fd < 0) {
        perror(""Failed to duplicate file descriptor\n"");
        exit(1);
    }
    int headroom = 10;      /* account for extra unexpected open FDs */
    struct rlimit rl;

    max_fds = settings.maxconns + headroom + next_fd;

    /* But if possible, get the actual highest FD we can possibly ever see. */
    if (getrlimit(RLIMIT_NOFILE, &rl) == 0) {
        max_fds = rl.rlim_max;
    } else {
        fprintf(stderr, ""Failed to query maximum file descriptor; ""
                        ""falling back to maxconns\n"");
    }

    close(next_fd);

    if ((conns = calloc(max_fds, sizeof(conn *))) == NULL) {
        fprintf(stderr, ""Failed to allocate connection structures\n"");
        /* This is unrecoverable so bail out early. */
        exit(1);
    }
}",1,1,memcached.c,conn_init,,false,466,493,conn_init,,,69,void conn_init (void)
26915,METHOD,memcached.c:<global>,TYPE_DECL,"static const char *prot_text(enum protocol prot) {
    char *rv = ""unknown"";
    switch(prot) {
        case ascii_prot:
            rv = ""ascii"";
            break;
        case binary_prot:
            rv = ""binary"";
            break;
        case negotiating_prot:
            rv = ""auto-negotiate"";
            break;
#ifdef PROXY
        case proxy_prot:
            rv = ""proxy"";
            break;
#endif
    }
    return rv;
}",1,1,memcached.c,prot_text,,false,495,514,prot_text,,,70,const char* prot_text (protocol)
26947,METHOD,memcached.c:<global>,TYPE_DECL,"void conn_close_idle(conn *c) {
    if (settings.idle_timeout > 0 &&
        (current_time - c->last_cmd_time) > settings.idle_timeout) {
        if (c->state != conn_new_cmd && c->state != conn_read) {
            if (settings.verbose > 1)
                fprintf(stderr,
                    ""fd %d wants to timeout, but isn't in read state"", c->sfd);
            return;
        }

        if (settings.verbose > 1)
            fprintf(stderr, ""Closing idle fd %d\n"", c->sfd);

        pthread_mutex_lock(&c->thread->stats.mutex);
        c->thread->stats.idle_kicks++;
        pthread_mutex_unlock(&c->thread->stats.mutex);

        c->close_reason = IDLE_TIMEOUT_CLOSE;

        conn_set_state(c, conn_closing);
        drive_machine(c);
    }
}",1,1,memcached.c,conn_close_idle,,false,516,538,conn_close_idle,,,71,void conn_close_idle (conn*)
27045,METHOD,memcached.c:<global>,TYPE_DECL,"void conn_worker_readd(conn *c) {
    if (c->state == conn_io_queue) {
        c->io_queues_submitted--;
        // If we're still waiting for other queues to return, don't re-add the
        // connection yet.
        if (c->io_queues_submitted != 0) {
            return;
        }
    }
    c->ev_flags = EV_READ | EV_PERSIST;
    event_set(&c->event, c->sfd, c->ev_flags, event_handler, (void *)c);
    event_base_set(c->thread->base, &c->event);

    // TODO: call conn_cleanup/fail/etc
    if (event_add(&c->event, 0) == -1) {
        perror(""event_add"");
    }

    // side thread wanted us to close immediately.
    if (c->state == conn_closing) {
        drive_machine(c);
        return;
    } else if (c->state == conn_io_queue) {
        // machine will know how to return based on secondary state.
        drive_machine(c);
    } else {
        conn_set_state(c, conn_new_cmd);
    }
}",1,1,memcached.c,conn_worker_readd,,false,541,569,conn_worker_readd,,,72,void conn_worker_readd (conn*)
27140,METHOD,memcached.c:<global>,TYPE_DECL,"void thread_io_queue_add(LIBEVENT_THREAD *t, int type, void *ctx, io_queue_stack_cb cb, io_queue_stack_cb com_cb, io_queue_cb ret_cb, io_queue_cb fin_cb) {
    io_queue_cb_t *q = t->io_queues;
    while (q->type != IO_QUEUE_NONE) {
        q++;
    }
    q->type = type;
    q->ctx = ctx;
    q->submit_cb = cb;
    q->complete_cb = com_cb;
    q->finalize_cb = fin_cb;
    q->return_cb   = ret_cb;
    return;
}",1,22,memcached.c,thread_io_queue_add,,false,571,583,thread_io_queue_add,,,73,"void thread_io_queue_add (LIBEVENT_THREAD*,int,void*,io_queue_stack_cb,io_queue_stack_cb,io_queue_cb,io_queue_cb)"
27199,METHOD,memcached.c:<global>,TYPE_DECL,"void conn_io_queue_setup(conn *c) {
    io_queue_cb_t *qcb = c->thread->io_queues;
    io_queue_t *q = c->io_queues;
    while (qcb->type != IO_QUEUE_NONE) {
        q->type = qcb->type;
        q->ctx = qcb->ctx;
        q->stack_ctx = NULL;
        q->count = 0;
        qcb++;
        q++;
    }
}",1,24,memcached.c,conn_io_queue_setup,,false,585,596,conn_io_queue_setup,,,74,void conn_io_queue_setup (conn*)
27255,METHOD,memcached.c:<global>,TYPE_DECL,"static void conn_io_queue_reset(conn *c) {
    for (io_queue_t *q = c->io_queues; q->type != IO_QUEUE_NONE; q++) {
        assert(q->count == 0);
        q->stack_ctx = NULL;
    }
}",1,50,memcached.c,conn_io_queue_reset,,false,599,604,conn_io_queue_reset,,,75,void conn_io_queue_reset (conn*)
27289,METHOD,memcached.c:<global>,TYPE_DECL,"io_queue_cb_t *thread_io_queue_get(LIBEVENT_THREAD *t, int type) {
    io_queue_cb_t *q = t->io_queues;
    while (q->type != IO_QUEUE_NONE) {
        if (q->type == type) {
            return q;
        }
        q++;
    }
    return NULL;
}",1,22,memcached.c,thread_io_queue_get,,false,606,615,thread_io_queue_get,,,76,"io_queue_cb_t thread_io_queue_get (LIBEVENT_THREAD*,int)"
27323,METHOD,memcached.c:<global>,TYPE_DECL,"io_queue_t *conn_io_queue_get(conn *c, int type) {
    io_queue_t *q = c->io_queues;
    while (q->type != IO_QUEUE_NONE) {
        if (q->type == type) {
            return q;
        }
        q++;
    }
    return NULL;
}",1,22,memcached.c,conn_io_queue_get,,false,617,626,conn_io_queue_get,,,77,"io_queue_t conn_io_queue_get (conn*,int)"
27357,METHOD,memcached.c:<global>,TYPE_DECL,"static void conn_io_queue_complete(conn *c) {
    io_queue_t *q = c->io_queues;
    io_queue_cb_t *qcb = c->thread->io_queues;
    while (q->type != IO_QUEUE_NONE) {
        if (q->stack_ctx) {
            qcb->complete_cb(q);
        }
        qcb++;
        q++;
    }
}",1,22,memcached.c,conn_io_queue_complete,,false,631,641,conn_io_queue_complete,,,78,void conn_io_queue_complete (conn*)
27399,METHOD,memcached.c:<global>,TYPE_DECL,"void conn_io_queue_return(io_pending_t *io) {
    io_queue_cb_t *q = thread_io_queue_get(io->thread, io->io_queue_type);
    q->return_cb(io);
    return;
}",1,1,memcached.c,conn_io_queue_return,,false,644,648,conn_io_queue_return,,,79,void conn_io_queue_return (io_pending_t*)
27420,METHOD,memcached.c:<global>,TYPE_DECL,"conn *conn_new(const int sfd, enum conn_states init_state,
                const int event_flags,
                const int read_buffer_size, enum network_transport transport,
                struct event_base *base, void *ssl, uint64_t conntag,
                enum protocol bproto) {
    conn *c;

    assert(sfd >= 0 && sfd < max_fds);
    c = conns[sfd];

    if (NULL == c) {
        if (!(c = (conn *)calloc(1, sizeof(conn)))) {
            STATS_LOCK();
            stats.malloc_fails++;
            STATS_UNLOCK();
            fprintf(stderr, ""Failed to allocate connection object\n"");
            return NULL;
        }
        MEMCACHED_CONN_CREATE(c);
        c->read = NULL;
        c->sendmsg = NULL;
        c->write = NULL;
        c->rbuf = NULL;

        c->rsize = read_buffer_size;

        // UDP connections use a persistent static buffer.
        if (c->rsize) {
            c->rbuf = (char *)malloc((size_t)c->rsize);
        }

        if (c->rsize && c->rbuf == NULL) {
  ...",1,8,memcached.c,conn_new,,false,650,840,conn_new,,,80,"conn conn_new (int,conn_states,int,int,network_transport,event_base*,void*,uint64_t,protocol)"
27998,METHOD,memcached.c:<global>,TYPE_DECL,"void conn_release_items(conn *c) {
    assert(c != NULL);

    if (c->item) {
        if (c->item_malloced) {
            free(c->item);
            c->item_malloced = false;
        } else {
            item_remove(c->item);
        }
        c->item = 0;
    }

    // Cull any unsent responses.
    if (c->resp_head) {
        mc_resp *resp = c->resp_head;
        // r_f() handles the chain maintenance.
        while (resp) {
            // temporary by default. hide behind a debug flag in the future:
            // double free detection. Transmit loops can drop out early, but
            // here we could infinite loop.
            if (resp->free) {
                fprintf(stderr, ""ERROR: double free detected during conn_release_items(): [%d] [%s]\n"",
                        c->sfd, c->protocol == binary_prot ? ""binary"" : ""ascii"");
                // Since this is a critical failure, just leak the memory.
                // If these errors are seen, an abort() can be used instead.
...",1,1,memcached.c,conn_release_items,,false,842,876,conn_release_items,,,81,void conn_release_items (conn*)
28088,METHOD,memcached.c:<global>,TYPE_DECL,"static void conn_cleanup(conn *c) {
    assert(c != NULL);

    conn_release_items(c);
#ifdef PROXY
    if (c->proxy_coro_ref) {
        proxy_cleanup_conn(c);
    }
#endif
    if (c->sasl_conn) {
        assert(settings.sasl);
        sasl_dispose(&c->sasl_conn);
        c->sasl_conn = NULL;
    }

    if (IS_UDP(c->transport)) {
        conn_set_state(c, conn_read);
    }
}",1,8,memcached.c,conn_cleanup,,false,878,896,conn_cleanup,,,82,void conn_cleanup (conn*)
28130,METHOD,memcached.c:<global>,TYPE_DECL,"void conn_free(conn *c) {
    if (c) {
        assert(c != NULL);
        assert(c->sfd >= 0 && c->sfd < max_fds);

        MEMCACHED_CONN_DESTROY(c);
        conns[c->sfd] = NULL;
        if (c->rbuf)
            free(c->rbuf);
#ifdef TLS
        if (c->ssl_wbuf)
            c->ssl_wbuf = NULL;
#endif

        free(c);
    }
}",1,8,memcached.c,conn_free,,false,901,917,conn_free,,,83,void conn_free (conn*)
28172,METHOD,memcached.c:<global>,TYPE_DECL,"static void conn_close(conn *c) {
    assert(c != NULL);

    if (c->thread) {
        LOGGER_LOG(c->thread->l, LOG_CONNEVENTS, LOGGER_CONNECTION_CLOSE, NULL,
                &c->request_addr, c->request_addr_size, c->transport,
                c->close_reason, c->sfd);
    }

    /* delete the event, the socket and the conn */
    event_del(&c->event);

    if (settings.verbose > 1)
        fprintf(stderr, ""<%d connection closed.\n"", c->sfd);

    conn_cleanup(c);

    // force release of read buffer.
    if (c->thread) {
        c->rbytes = 0;
        rbuf_release(c);
    }

    MEMCACHED_CONN_RELEASE(c->sfd);
    conn_set_state(c, conn_closed);
#ifdef TLS
    if (c->ssl) {
        SSL_shutdown(c->ssl);
        SSL_free(c->ssl);
    }
#endif
    close(c->sfd);
    c->close_reason = 0;
    pthread_mutex_lock(&conn_lock);
    allow_new_conns = true;
    pthread_mutex_unlock(&conn_lock);

    STATS_LOCK();
    stats_state.curr_conns--;
    STATS_UNLOCK();

    return;
}",1,8,memcached.c,conn_close,,false,919,961,conn_close,,,84,void conn_close (conn*)
28310,METHOD,memcached.c:<global>,TYPE_DECL,"void conn_close_all(void) {
    int i;
    for (i = 0; i < max_fds; i++) {
        if (conns[i] && conns[i]->state != conn_closed) {
            conn_close(conns[i]);
        }
    }
}",1,1,memcached.c,conn_close_all,,false,966,973,conn_close_all,,,85,void conn_close_all (void)
28344,METHOD,memcached.c:<global>,TYPE_DECL,"static const char *state_text(enum conn_states state) {
    const char* const statenames[] = { ""conn_listening"",
                                       ""conn_new_cmd"",
                                       ""conn_waiting"",
                                       ""conn_read"",
                                       ""conn_parse_cmd"",
                                       ""conn_write"",
                                       ""conn_nread"",
                                       ""conn_swallow"",
                                       ""conn_closing"",
                                       ""conn_mwrite"",
                                       ""conn_closed"",
                                       ""conn_watch"",
                                       ""conn_io_queue"" };
    return statenames[state];
}",1,1,memcached.c,state_text,,false,978,993,state_text,,,86,const char* state_text (conn_states)
28370,METHOD,memcached.c:<global>,TYPE_DECL,"void conn_set_state(conn *c, enum conn_states state) {
    assert(c != NULL);
    assert(state >= conn_listening && state < conn_max_state);

    if (state != c->state) {
        if (settings.verbose > 2) {
            fprintf(stderr, ""%d: going from %s to %s\n"",
                    c->sfd, state_text(c->state),
                    state_text(state));
        }

        if (state == conn_write || state == conn_mwrite) {
            MEMCACHED_PROCESS_COMMAND_END(c->sfd, c->resp->wbuf, c->resp->wbytes);
        }
        c->state = state;
    }
}",1,12,memcached.c,conn_set_state,,false,1000,1016,conn_set_state,,,87,"void conn_set_state (conn*,conn_states)"
28428,METHOD,memcached.c:<global>,TYPE_DECL,"void resp_reset(mc_resp *resp) {
    if (resp->item) {
        item_remove(resp->item);
        resp->item = NULL;
    }
    if (resp->write_and_free) {
        free(resp->write_and_free);
        resp->write_and_free = NULL;
    }
    resp->wbytes = 0;
    resp->tosend = 0;
    resp->iovcnt = 0;
    resp->chunked_data_iov = 0;
    resp->chunked_total = 0;
    resp->skip = false;
}",1,1,memcached.c,resp_reset,,false,1021,1036,resp_reset,,,88,void resp_reset (mc_resp*)
28491,METHOD,memcached.c:<global>,TYPE_DECL,"void resp_add_iov(mc_resp *resp, const void *buf, int len) {
    assert(resp->iovcnt < MC_RESP_IOVCOUNT);
    int x = resp->iovcnt;
    resp->iov[x].iov_base = (void *)buf;
    resp->iov[x].iov_len = len;
    resp->iovcnt++;
    resp->tosend += len;
}",1,26,memcached.c,resp_add_iov,,false,1038,1045,resp_add_iov,,,89,"void resp_add_iov (mc_resp*,void*,int)"
28541,METHOD,memcached.c:<global>,TYPE_DECL,"void resp_add_chunked_iov(mc_resp *resp, const void *buf, int len) {
    resp->chunked_data_iov = resp->iovcnt;
    resp->chunked_total = len;
    resp_add_iov(resp, buf, len);
}",1,1,memcached.c,resp_add_chunked_iov,,false,1050,1054,resp_add_chunked_iov,,,90,"void resp_add_chunked_iov (mc_resp*,void*,int)"
28564,METHOD,memcached.c:<global>,TYPE_DECL,"static mc_resp* resp_allocate(conn *c) {
    LIBEVENT_THREAD *th = c->thread;
    mc_resp *resp = NULL;
    mc_resp_bundle *b = th->open_bundle;

    if (b != NULL) {
        for (int i = 0; i < MAX_RESP_PER_BUNDLE; i++) {
            // loop around starting from the most likely to be free
            int x = (i + b->next_check) % MAX_RESP_PER_BUNDLE;
            if (b->r[x].free) {
                resp = &b->r[x];
                b->next_check = x+1;
                break;
            }
        }

        if (resp != NULL) {
            b->refcount++;
            resp->free = false;
            if (b->refcount == MAX_RESP_PER_BUNDLE) {
                assert(b->prev == NULL);
                // We only allocate off the head. Assign new head.
                th->open_bundle = b->next;
                // Remove ourselves from the list.
                if (b->next) {
                    b->next->prev = 0;
                    b->next = 0;
                }
            }
        }
    }...",1,28,memcached.c,resp_allocate,,false,1061,1117,resp_allocate,,,91,mc_resp resp_allocate (conn*)
28849,METHOD,memcached.c:<global>,TYPE_DECL,"static void resp_free(conn *c, mc_resp *resp) {
    LIBEVENT_THREAD *th = c->thread;
    mc_resp_bundle *b = resp->bundle;

    resp->free = true;
    b->refcount--;
    if (b->refcount == 0) {
        if (b == th->open_bundle && b->next == 0) {
            // This is the final bundle. Just hold and reuse to skip init loop
            assert(b->prev == 0);
            b->next_check = 0;
        } else {
            // Assert that we're either in the list or at the head.
            assert((b->next || b->prev) || b == th->open_bundle);

            // unlink from list.
            mc_resp_bundle **head = &th->open_bundle;
            if (*head == b) *head = b->next;
            // Not tracking the tail.
            assert(b->next != b && b->prev != b);

            if (b->next) b->next->prev = b->prev;
            if (b->prev) b->prev->next = b->next;

            // Now completely done with this buffer.
            do_cache_free(th->rbuf_cache, b);
            THR_STATS_LOCK(c);
   ...",1,12,memcached.c,resp_free,,false,1119,1163,resp_free,,,92,"void resp_free (conn*,mc_resp*)"
29075,METHOD,memcached.c:<global>,TYPE_DECL,"bool resp_start(conn *c) {
    mc_resp *resp = resp_allocate(c);
    if (!resp) {
        THR_STATS_LOCK(c);
        c->thread->stats.response_obj_oom++;
        THR_STATS_UNLOCK(c);
        return false;
    }
    // handling the stats counters here to simplify testing
    THR_STATS_LOCK(c);
    c->thread->stats.response_obj_count++;
    THR_STATS_UNLOCK(c);
    // Skip zeroing the bundle pointer at the start.
    // TODO: this line is here temporarily to make the code easy to disable.
    // when it's more mature, move the memset into resp_allocate() and have it
    // set the bundle pointer on allocate so this line isn't as complex.
    memset((char *)resp + sizeof(mc_resp_bundle*), 0, sizeof(*resp) - sizeof(mc_resp_bundle*));
    // TODO: this next line works. memset _does_ show up significantly under
    // perf reports due to zeroing out the entire resp->wbuf. before swapping
    // the lines more validation work should be done to ensure wbuf's aren't
    // accidentally reuse...",1,8,memcached.c,resp_start,,false,1165,1203,resp_start,,,93,bool resp_start (conn*)
29246,METHOD,memcached.c:<global>,TYPE_DECL,"mc_resp* resp_finish(conn *c, mc_resp *resp) {
    mc_resp *next = resp->next;
    if (resp->item) {
        // TODO: cache hash value in resp obj?
        item_remove(resp->item);
        resp->item = NULL;
    }
    if (resp->write_and_free) {
        free(resp->write_and_free);
    }
    if (resp->io_pending) {
        // If we had a pending IO, tell it to internally clean up then return
        // the main object back to our thread cache.
        io_queue_cb_t *qcb = thread_io_queue_get(c->thread, resp->io_pending->io_queue_type);
        qcb->finalize_cb(resp->io_pending);
        do_cache_free(c->thread->io_cache, resp->io_pending);
        resp->io_pending = NULL;
    }
    if (c->resp_head == resp) {
        c->resp_head = next;
    }
    if (c->resp == resp) {
        c->resp = NULL;
    }
    resp_free(c, resp);
    THR_STATS_LOCK(c);
    c->thread->stats.response_obj_count--;
    THR_STATS_UNLOCK(c);
    return next;
}",1,4,memcached.c,resp_finish,,false,1206,1235,resp_finish,,,94,"mc_resp resp_finish (conn*,mc_resp*)"
29380,METHOD,memcached.c:<global>,TYPE_DECL,"bool resp_has_stack(conn *c) {
    return c->resp_head->next != NULL ? true : false;
}",1,1,memcached.c,resp_has_stack,,false,1238,1240,resp_has_stack,,,95,bool resp_has_stack (conn*)
29396,METHOD,memcached.c:<global>,TYPE_DECL,"void out_string(conn *c, const char *str) {
    size_t len;
    assert(c != NULL);
    mc_resp *resp = c->resp;

    // if response was original filled with something, but we're now writing
    // out an error or similar, have to reset the object first.
    // TODO: since this is often redundant with allocation, how many callers
    // are actually requiring it be reset? Can we fast test by just looking at
    // tosend and reset if nonzero?
    resp_reset(resp);

    if (c->noreply) {
        // TODO: just invalidate the response since nothing's been attempted
        // to send yet?
        resp->skip = true;
        if (settings.verbose > 1)
            fprintf(stderr, "">%d NOREPLY %s\n"", c->sfd, str);
        conn_set_state(c, conn_new_cmd);
        return;
    }

    if (settings.verbose > 1)
        fprintf(stderr, "">%d %s\n"", c->sfd, str);

    // Fill response object with static string.

    len = strlen(str);
    if ((len + 2) > WRITE_BUFFER_SIZE) {
        /* ought to be a...",1,20,memcached.c,out_string,,false,1242,1282,out_string,,,96,"void out_string (conn*,char*)"
29503,METHOD,memcached.c:<global>,TYPE_DECL,"void out_errstring(conn *c, const char *str) {
    c->noreply = false;
    out_string(c, str);
}",1,1,memcached.c,out_errstring,,false,1286,1289,out_errstring,,,97,"void out_errstring (conn*,char*)"
29517,METHOD,memcached.c:<global>,TYPE_DECL,"void out_of_memory(conn *c, char *ascii_error) {
    const static char error_prefix[] = ""SERVER_ERROR "";
    const static int error_prefix_len = sizeof(error_prefix) - 1;

    if (c->protocol == binary_prot) {
        /* Strip off the generic error prefix; it's irrelevant in binary */
        if (!strncmp(ascii_error, error_prefix, error_prefix_len)) {
            ascii_error += error_prefix_len;
        }
        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, ascii_error, 0);
    } else {
        out_string(c, ascii_error);
    }
}",1,1,memcached.c,out_of_memory,,false,1295,1308,out_of_memory,,,98,"void out_of_memory (conn*,char*)"
29561,METHOD,memcached.c:<global>,TYPE_DECL,"static void append_bin_stats(const char *key, const uint16_t klen,
                             const char *val, const uint32_t vlen,
                             conn *c) {
    char *buf = c->stats.buffer + c->stats.offset;
    uint32_t bodylen = klen + vlen;
    protocol_binary_response_header header = {
        .response.magic = (uint8_t)PROTOCOL_BINARY_RES,
        .response.opcode = PROTOCOL_BINARY_CMD_STAT,
        .response.keylen = (uint16_t)htons(klen),
        .response.datatype = (uint8_t)PROTOCOL_BINARY_RAW_BYTES,
        .response.bodylen = htonl(bodylen),
        .response.opaque = c->opaque
    };

    memcpy(buf, header.bytes, sizeof(header.response));
    buf += sizeof(header.response);

    if (klen > 0) {
        memcpy(buf, key, klen);
        buf += klen;

        if (vlen > 0) {
            memcpy(buf, val, vlen);
        }
    }

    c->stats.offset += sizeof(header.response) + bodylen;
}",1,1,memcached.c,append_bin_stats,,false,1310,1337,append_bin_stats,,,99,"void append_bin_stats (char*,uint16_t,char*,uint32_t,conn*)"
29704,METHOD,memcached.c:<global>,TYPE_DECL,"static void append_ascii_stats(const char *key, const uint16_t klen,
                               const char *val, const uint32_t vlen,
                               conn *c) {
    char *pos = c->stats.buffer + c->stats.offset;
    uint32_t nbytes = 0;
    int remaining = c->stats.size - c->stats.offset;
    int room = remaining - 1;

    if (klen == 0 && vlen == 0) {
        nbytes = snprintf(pos, room, ""END\r\n"");
    } else if (vlen == 0) {
        nbytes = snprintf(pos, room, ""STAT %s\r\n"", key);
    } else {
        nbytes = snprintf(pos, room, ""STAT %s %s\r\n"", key, val);
    }

    c->stats.offset += nbytes;
}",1,1,memcached.c,append_ascii_stats,,false,1339,1356,append_ascii_stats,,,100,"void append_ascii_stats (char*,uint16_t,char*,uint32_t,conn*)"
29797,METHOD,memcached.c:<global>,TYPE_DECL,"static bool grow_stats_buf(conn *c, size_t needed) {
    size_t nsize = c->stats.size;
    size_t available = nsize - c->stats.offset;
    bool rv = true;

    /* Special case: No buffer -- need to allocate fresh */
    if (c->stats.buffer == NULL) {
        nsize = 1024;
        available = c->stats.size = c->stats.offset = 0;
    }

    while (needed > available) {
        assert(nsize > 0);
        nsize = nsize << 1;
        available = nsize - c->stats.offset;
    }

    if (nsize != c->stats.size) {
        char *ptr = realloc(c->stats.buffer, nsize);
        if (ptr) {
            c->stats.buffer = ptr;
            c->stats.size = nsize;
        } else {
            STATS_LOCK();
            stats.malloc_fails++;
            STATS_UNLOCK();
            rv = false;
        }
    }

    return rv;
}",1,1,memcached.c,grow_stats_buf,,false,1358,1389,grow_stats_buf,,,101,"bool grow_stats_buf (conn*,size_t)"
29924,METHOD,memcached.c:<global>,TYPE_DECL,"void append_stats(const char *key, const uint16_t klen,
                  const char *val, const uint32_t vlen,
                  const void *cookie)
{
    /* value without a key is invalid */
    if (klen == 0 && vlen > 0) {
        return;
    }

    conn *c = (conn*)cookie;

    if (c->protocol == binary_prot) {
        size_t needed = vlen + klen + sizeof(protocol_binary_response_header);
        if (!grow_stats_buf(c, needed)) {
            return;
        }
        append_bin_stats(key, klen, val, vlen, c);
    } else {
        size_t needed = vlen + klen + 10; // 10 == ""STAT = \r\n""
        if (!grow_stats_buf(c, needed)) {
            return;
        }
        append_ascii_stats(key, klen, val, vlen, c);
    }

    assert(c->stats.offset <= c->stats.size);
}",1,1,memcached.c,append_stats,,false,1391,1417,append_stats,,,102,"void append_stats (char*,uint16_t,char*,uint32_t,void*)"
30013,METHOD,memcached.c:<global>,TYPE_DECL,"static void reset_cmd_handler(conn *c) {
    c->cmd = -1;
    c->substate = bin_no_state;
    if (c->item != NULL) {
        // TODO: Any other way to get here?
        // SASL auth was mistakenly using it. Nothing else should?
        if (c->item_malloced) {
            free(c->item);
            c->item_malloced = false;
        } else {
            item_remove(c->item);
        }
        c->item = NULL;
    }
    if (c->rbytes > 0) {
        conn_set_state(c, conn_parse_cmd);
    } else if (c->resp_head) {
        conn_set_state(c, conn_mwrite);
    } else {
        conn_set_state(c, conn_waiting);
    }
}",1,1,memcached.c,reset_cmd_handler,,false,1419,1440,reset_cmd_handler,,,103,void reset_cmd_handler (conn*)
30086,METHOD,memcached.c:<global>,TYPE_DECL,"static void complete_nread(conn *c) {
    assert(c != NULL);
#ifdef PROXY
    assert(c->protocol == ascii_prot
           || c->protocol == binary_prot
           || c->protocol == proxy_prot);
#else
    assert(c->protocol == ascii_prot
           || c->protocol == binary_prot);
#endif
    if (c->protocol == ascii_prot) {
        complete_nread_ascii(c);
    } else if (c->protocol == binary_prot) {
        complete_nread_binary(c);
#ifdef PROXY
    } else if (c->protocol == proxy_prot) {
        complete_nread_proxy(c);
#endif
    }
}",1,1,memcached.c,complete_nread,,false,1442,1461,complete_nread,,,104,void complete_nread (conn*)
30127,METHOD,memcached.c:<global>,TYPE_DECL,"static int _store_item_copy_chunks(item *d_it, item *s_it, const int len) {
    item_chunk *dch = (item_chunk *) ITEM_schunk(d_it);
    /* Advance dch until we find free space */
    while (dch->size == dch->used) {
        if (dch->next) {
            dch = dch->next;
        } else {
            break;
        }
    }

    if (s_it->it_flags & ITEM_CHUNKED) {
        int remain = len;
        item_chunk *sch = (item_chunk *) ITEM_schunk(s_it);
        int copied = 0;
        /* Fills dch's to capacity, not straight copy sch in case data is
         * being added or removed (ie append/prepend)
         */
        while (sch && dch && remain) {
            assert(dch->used <= dch->size);
            int todo = (dch->size - dch->used < sch->used - copied)
                ? dch->size - dch->used : sch->used - copied;
            if (remain < todo)
                todo = remain;
            memcpy(dch->data + dch->used, sch->data + copied, todo);
            dch->used += todo;
        ...",1,37,memcached.c,_store_item_copy_chunks,,false,1465,1533,_store_item_copy_chunks,,,105,"int _store_item_copy_chunks (item*,item*,int)"
30523,METHOD,memcached.c:<global>,TYPE_DECL,"static int _store_item_copy_data(int comm, item *old_it, item *new_it, item *add_it) {
    if (comm == NREAD_APPEND) {
        if (new_it->it_flags & ITEM_CHUNKED) {
            if (_store_item_copy_chunks(new_it, old_it, old_it->nbytes - 2) == -1 ||
                _store_item_copy_chunks(new_it, add_it, add_it->nbytes) == -1) {
                return -1;
            }
        } else {
            memcpy(ITEM_data(new_it), ITEM_data(old_it), old_it->nbytes);
            memcpy(ITEM_data(new_it) + old_it->nbytes - 2 /* CRLF */, ITEM_data(add_it), add_it->nbytes);
        }
    } else {
        /* NREAD_PREPEND */
        if (new_it->it_flags & ITEM_CHUNKED) {
            if (_store_item_copy_chunks(new_it, add_it, add_it->nbytes - 2) == -1 ||
                _store_item_copy_chunks(new_it, old_it, old_it->nbytes) == -1) {
                return -1;
            }
        } else {
            memcpy(ITEM_data(new_it), ITEM_data(add_it), add_it->nbytes);
            memcpy(ITEM_data(ne...",1,16,memcached.c,_store_item_copy_data,,false,1535,1559,_store_item_copy_data,,,106,"int _store_item_copy_data (int,item*,item*,item*)"
30924,METHOD,memcached.c:<global>,TYPE_DECL,"enum store_item_type do_store_item(item *it, int comm, conn *c, const uint32_t hv) {
    char *key = ITEM_key(it);
    item *old_it = do_item_get(key, it->nkey, hv, c, DONT_UPDATE);
    enum store_item_type stored = NOT_STORED;

    enum cas_result { CAS_NONE, CAS_MATCH, CAS_BADVAL, CAS_STALE, CAS_MISS };

    item *new_it = NULL;
    uint32_t flags;

    /* Do the CAS test up front so we can apply to all store modes */
    enum cas_result cas_res = CAS_NONE;

    bool do_store = false;
    if (old_it != NULL) {
        // Most of the CAS work requires something to compare to.
        uint64_t it_cas = ITEM_get_cas(it);
        uint64_t old_cas = ITEM_get_cas(old_it);
        if (it_cas == 0) {
            cas_res = CAS_NONE;
        } else if (it_cas == old_cas) {
            cas_res = CAS_MATCH;
        } else if (c->set_stale && it_cas < old_cas) {
            cas_res = CAS_STALE;
        } else {
            cas_res = CAS_BADVAL;
        }

        switch (comm) {
            ca...",1,16,memcached.c,do_store_item,,false,1567,1726,do_store_item,,,107,"enum store_item_type do_store_item (item*,int,conn*,uint32_t)"
31654,METHOD,memcached.c:<global>,TYPE_DECL,"void write_and_free(conn *c, char *buf, int bytes) {
    if (buf) {
        mc_resp *resp = c->resp;
        resp->write_and_free = buf;
        resp_add_iov(resp, buf, bytes);
        conn_set_state(c, conn_new_cmd);
    } else {
        out_of_memory(c, ""SERVER_ERROR out of memory writing stats"");
    }
}",1,1,memcached.c,write_and_free,,false,1729,1738,write_and_free,,,108,"void write_and_free (conn*,char*,int)"
31687,METHOD,memcached.c:<global>,TYPE_DECL,"void append_stat(const char *name, ADD_STAT add_stats, conn *c,
                 const char *fmt, ...) {
    char val_str[STAT_VAL_LEN];
    int vlen;
    va_list ap;

    assert(name);
    assert(add_stats);
    assert(c);
    assert(fmt);

    va_start(ap, fmt);
    vlen = vsnprintf(val_str, sizeof(val_str) - 1, fmt, ap);
    va_end(ap);

    add_stats(name, strlen(name), val_str, vlen, c);
}",1,17,memcached.c,append_stat,,false,1740,1756,append_stat,,,109,"void append_stat (char*,ADD_STAT,conn*,char*...)"
31728,METHOD,memcached.c:<global>,TYPE_DECL,"void server_stats(ADD_STAT add_stats, conn *c) {
    pid_t pid = getpid();
    rel_time_t now = current_time;

    struct thread_stats thread_stats;
    threadlocal_stats_aggregate(&thread_stats);
    struct slab_stats slab_stats;
    slab_stats_aggregate(&thread_stats, &slab_stats);
#ifndef WIN32
    struct rusage usage;
    getrusage(RUSAGE_SELF, &usage);
#endif /* !WIN32 */

    STATS_LOCK();

    APPEND_STAT(""pid"", ""%lu"", (long)pid);
    APPEND_STAT(""uptime"", ""%u"", now - ITEM_UPDATE_INTERVAL);
    APPEND_STAT(""time"", ""%ld"", now + (long)process_started);
    APPEND_STAT(""version"", ""%s"", VERSION);
    APPEND_STAT(""libevent"", ""%s"", event_get_version());
    APPEND_STAT(""pointer_size"", ""%d"", (int)(8 * sizeof(void *)));

#ifndef WIN32
    append_stat(""rusage_user"", add_stats, c, ""%ld.%06ld"",
                (long)usage.ru_utime.tv_sec,
                (long)usage.ru_utime.tv_usec);
    append_stat(""rusage_system"", add_stats, c, ""%ld.%06ld"",
                (long)usage.ru_stime.tv_sec...",1,4,memcached.c,server_stats,,false,1759,1903,server_stats,,,110,"void server_stats (ADD_STAT,conn*)"
32872,METHOD,memcached.c:<global>,TYPE_DECL,"void process_stat_settings(ADD_STAT add_stats, void *c) {
    assert(add_stats);
    APPEND_STAT(""maxbytes"", ""%llu"", (unsigned long long)settings.maxbytes);
    APPEND_STAT(""maxconns"", ""%d"", settings.maxconns);
    APPEND_STAT(""tcpport"", ""%d"", settings.port);
    APPEND_STAT(""udpport"", ""%d"", settings.udpport);
    APPEND_STAT(""inter"", ""%s"", settings.inter ? settings.inter : ""NULL"");
    APPEND_STAT(""verbosity"", ""%d"", settings.verbose);
    APPEND_STAT(""oldest"", ""%lu"", (unsigned long)settings.oldest_live);
    APPEND_STAT(""evictions"", ""%s"", settings.evict_to_free ? ""on"" : ""off"");
    APPEND_STAT(""domain_socket"", ""%s"",
                settings.socketpath ? settings.socketpath : ""NULL"");
    APPEND_STAT(""umask"", ""%o"", settings.access);
    APPEND_STAT(""shutdown_command"", ""%s"",
                settings.shutdown_command ? ""yes"" : ""no"");
    APPEND_STAT(""growth_factor"", ""%.2f"", settings.factor);
    APPEND_STAT(""chunk_size"", ""%d"", settings.chunk_size);
    APPEND_STAT(""num_threads"", ""%d"",...",1,4,memcached.c,process_stat_settings,,false,1905,1998,process_stat_settings,,,111,"void process_stat_settings (ADD_STAT,void*)"
33689,METHOD,memcached.c:<global>,TYPE_DECL,"static int nz_strcmp(int nzlength, const char *nz, const char *z) {
    int zlength=strlen(z);
    return (zlength == nzlength) && (strncmp(nz, z, zlength) == 0) ? 0 : -1;
}",1,1,memcached.c,nz_strcmp,,false,2000,2003,nz_strcmp,,,112,"int nz_strcmp (int,char*,char*)"
33716,METHOD,memcached.c:<global>,TYPE_DECL,"bool get_stats(const char *stat_type, int nkey, ADD_STAT add_stats, void *c) {
    bool ret = true;

    if (add_stats != NULL) {
        if (!stat_type) {
            /* prepare general statistics for the engine */
            STATS_LOCK();
            APPEND_STAT(""bytes"", ""%llu"", (unsigned long long)stats_state.curr_bytes);
            APPEND_STAT(""curr_items"", ""%llu"", (unsigned long long)stats_state.curr_items);
            APPEND_STAT(""total_items"", ""%llu"", (unsigned long long)stats.total_items);
            STATS_UNLOCK();
            APPEND_STAT(""slab_global_page_pool"", ""%u"", global_page_pool_size(NULL));
            item_stats_totals(add_stats, c);
        } else if (nz_strcmp(nkey, stat_type, ""items"") == 0) {
            item_stats(add_stats, c);
        } else if (nz_strcmp(nkey, stat_type, ""slabs"") == 0) {
            slabs_stats(add_stats, c);
        } else if (nz_strcmp(nkey, stat_type, ""sizes"") == 0) {
            item_stats_sizes(add_stats, c);
        } else if (nz_s...",1,12,memcached.c,get_stats,,false,2005,2036,get_stats,,,113,"bool get_stats (char*,int,ADD_STAT,void*)"
33874,METHOD,memcached.c:<global>,TYPE_DECL,"static inline void get_conn_text(const conn *c, const int af,
                char* addr, struct sockaddr *sock_addr) {
    char addr_text[MAXPATHLEN];
    addr_text[0] = '\0';
    const char *protoname = ""?"";
    unsigned short port = 0;

    switch (af) {
        case AF_INET:
            (void) inet_ntop(af,
                    &((struct sockaddr_in *)sock_addr)->sin_addr,
                    addr_text,
                    sizeof(addr_text) - 1);
            port = ntohs(((struct sockaddr_in *)sock_addr)->sin_port);
            protoname = IS_UDP(c->transport) ? ""udp"" : ""tcp"";
            break;

        case AF_INET6:
            addr_text[0] = '[';
            addr_text[1] = '\0';
            if (inet_ntop(af,
                    &((struct sockaddr_in6 *)sock_addr)->sin6_addr,
                    addr_text + 1,
                    sizeof(addr_text) - 2)) {
                strncat(addr_text, ""]"", 2);
            }
            port = ntohs(((struct sockaddr_in6 *)sock_addr)->sin6...",1,24,memcached.c,get_conn_text,,false,2038,2112,get_conn_text,,,114,"void get_conn_text (conn*,int,char*,sockaddr*)"
34072,METHOD,memcached.c:<global>,TYPE_DECL,"static void conn_to_str(const conn *c, char *addr, char *svr_addr) {
    if (!c) {
        memcpy(addr, ""<null>"", 6);
    } else if (c->state == conn_closed) {
        memcpy(addr, ""<closed>"", 8);
    } else {
        struct sockaddr_in6 local_addr;
        struct sockaddr *sock_addr = (void *)&c->request_addr;

        /* For listen ports and idle UDP ports, show listen address */
        if (c->state == conn_listening ||
                (IS_UDP(c->transport) &&
                 c->state == conn_read)) {
            socklen_t local_addr_len = sizeof(local_addr);

            if (getsockname(c->sfd,
                        (struct sockaddr *)&local_addr,
                        &local_addr_len) == 0) {
                sock_addr = (struct sockaddr *)&local_addr;
            }
        }
        get_conn_text(c, sock_addr->sa_family, addr, sock_addr);

        if (c->state != conn_listening && !(IS_UDP(c->transport) &&
                 c->state == conn_read)) {
            struct socka...",1,17,memcached.c,conn_to_str,,false,2114,2145,conn_to_str,,,115,"void conn_to_str (conn*,char*,char*)"
34219,METHOD,memcached.c:<global>,TYPE_DECL,"void process_stats_conns(ADD_STAT add_stats, void *c) {
    int i;
    char key_str[STAT_KEY_LEN];
    char val_str[STAT_VAL_LEN];
    size_t extras_len = sizeof("":unix:"") + sizeof(""65535"");
    char addr[MAXPATHLEN + extras_len];
    char svr_addr[MAXPATHLEN + extras_len];
    memset(addr, 0, sizeof(addr));
    memset(svr_addr, 0, sizeof(svr_addr));
    int klen = 0, vlen = 0;

    assert(add_stats);

    for (i = 0; i < max_fds; i++) {
        if (conns[i]) {
            /* This is safe to do unlocked because conns are never freed; the
             * worst that'll happen will be a minor inconsistency in the
             * output -- not worth the complexity of the locking that'd be
             * required to prevent it.
             */
            if (IS_UDP(conns[i]->transport)) {
                APPEND_NUM_STAT(i, ""UDP"", ""%s"", ""UDP"");
            }
            if (conns[i]->state != conn_closed) {
                conn_to_str(conns[i], addr, svr_addr);

                APPEND_NUM_...",1,17,memcached.c,process_stats_conns,,false,2147,2185,process_stats_conns,,,116,"void process_stats_conns (ADD_STAT,void*)"
34475,METHOD,memcached.c:<global>,TYPE_DECL,"item* limited_get(char *key, size_t nkey, conn *c, uint32_t exptime, bool should_touch, bool do_update, bool *overflow) {
    item *it;
    if (should_touch) {
        it = item_touch(key, nkey, exptime, c);
    } else {
        it = item_get(key, nkey, c, do_update);
    }
    if (it && it->refcount > IT_REFCOUNT_LIMIT) {
        item_remove(it);
        it = NULL;
        *overflow = true;
    } else {
        *overflow = false;
    }
    return it;
}",1,29,memcached.c,limited_get,,false,2188,2203,limited_get,,,117,"item limited_get (char*,size_t,conn*,uint32_t,bool,bool,bool*)"
34534,METHOD,memcached.c:<global>,TYPE_DECL,"item* limited_get_locked(char *key, size_t nkey, conn *c, bool do_update, uint32_t *hv, bool *overflow) {
    item *it;
    it = item_get_locked(key, nkey, c, do_update, hv);
    if (it && it->refcount > IT_REFCOUNT_LIMIT) {
        do_item_remove(it);
        it = NULL;
        item_unlock(*hv);
        *overflow = true;
    } else {
        *overflow = false;
    }
    return it;
}",1,29,memcached.c,limited_get_locked,,false,2209,2221,limited_get_locked,,,118,"item limited_get_locked (char*,size_t,conn*,bool,uint32_t*,bool*)"
34584,METHOD,memcached.c:<global>,TYPE_DECL,"enum delta_result_type do_add_delta(conn *c, const char *key, const size_t nkey,
                                    const bool incr, const int64_t delta,
                                    char *buf, uint64_t *cas,
                                    const uint32_t hv,
                                    item **it_ret) {
    char *ptr;
    uint64_t value;
    int res;
    item *it;

    it = do_item_get(key, nkey, hv, c, DONT_UPDATE);
    if (!it) {
        return DELTA_ITEM_NOT_FOUND;
    }

    /* Can't delta zero byte values. 2-byte are the ""\r\n"" */
    /* Also can't delta for chunked items. Too large to be a number */
#ifdef EXTSTORE
    if (it->nbytes <= 2 || (it->it_flags & (ITEM_CHUNKED|ITEM_HDR)) != 0) {
#else
    if (it->nbytes <= 2 || (it->it_flags & (ITEM_CHUNKED)) != 0) {
#endif
        do_item_remove(it);
        return NON_NUMERIC;
    }

    if (cas != NULL && *cas != 0 && ITEM_get_cas(it) != *cas) {
        do_item_remove(it);
        return DELTA_ITEM_CAS_MISMATC...",1,39,memcached.c,do_add_delta,,false,2234,2345,do_add_delta,,,119,"enum delta_result_type do_add_delta (conn*,char*,size_t,bool,int64_t,char*,uint64_t*,uint32_t,item**)"
35216,METHOD,memcached.c:<global>,TYPE_DECL,"static int try_read_command_negotiate(conn *c) {
    assert(c != NULL);
    assert(c->protocol == negotiating_prot);
    assert(c->rcurr <= (c->rbuf + c->rsize));
    assert(c->rbytes > 0);

    if ((unsigned char)c->rbuf[0] == (unsigned char)PROTOCOL_BINARY_REQ) {
        c->protocol = binary_prot;
        c->try_read_command = try_read_command_binary;
    } else {
        // authentication doesn't work with negotiated protocol.
        c->protocol = ascii_prot;
        c->try_read_command = try_read_command_ascii;
    }

    if (settings.verbose > 1) {
        fprintf(stderr, ""%d: Client using the %s protocol\n"", c->sfd,
                prot_text(c->protocol));
    }

    return c->try_read_command(c);
}",1,1,memcached.c,try_read_command_negotiate,,false,2347,2368,try_read_command_negotiate,,,120,int try_read_command_negotiate (conn*)
35307,METHOD,memcached.c:<global>,TYPE_DECL,"static int try_read_command_udp(conn *c) {
    assert(c != NULL);
    assert(c->rcurr <= (c->rbuf + c->rsize));
    assert(c->rbytes > 0);

    if ((unsigned char)c->rbuf[0] == (unsigned char)PROTOCOL_BINARY_REQ) {
        c->protocol = binary_prot;
        return try_read_command_binary(c);
    } else {
        c->protocol = ascii_prot;
        return try_read_command_ascii(c);
    }
}",1,1,memcached.c,try_read_command_udp,,false,2370,2382,try_read_command_udp,,,121,int try_read_command_udp (conn*)
35365,METHOD,memcached.c:<global>,TYPE_DECL,"static enum try_read_result try_read_udp(conn *c) {
    int res;

    assert(c != NULL);

    c->request_addr_size = sizeof(c->request_addr);
    res = recvfrom(c->sfd, c->rbuf, c->rsize,
                   0, (struct sockaddr *)&c->request_addr,
                   &c->request_addr_size);
    if (res > 8) {
        unsigned char *buf = (unsigned char *)c->rbuf;
        pthread_mutex_lock(&c->thread->stats.mutex);
        c->thread->stats.bytes_read += res;
        pthread_mutex_unlock(&c->thread->stats.mutex);

        /* Beginning of UDP packet is the request ID; save it. */
        c->request_id = buf[0] * 256 + buf[1];

        /* If this is a multi-packet request, drop it. */
        if (buf[4] != 0 || buf[5] != 1) {
            return READ_NO_DATA_RECEIVED;
        }

        /* Don't care about any of the rest of the header. */
        res -= 8;
        memmove(c->rbuf, c->rbuf + 8, res);

        c->rbytes = res;
        c->rcurr = c->rbuf;
        return READ_DATA_RECEIVED;
...",1,1,memcached.c,try_read_udp,,false,2387,2419,try_read_udp,,,122,enum try_read_result try_read_udp (conn*)
35503,METHOD,memcached.c:<global>,TYPE_DECL,"static enum try_read_result try_read_network(conn *c) {
    enum try_read_result gotdata = READ_NO_DATA_RECEIVED;
    int res;
    int num_allocs = 0;
    assert(c != NULL);

    if (c->rcurr != c->rbuf) {
        if (c->rbytes != 0) /* otherwise there's nothing to copy */
            memmove(c->rbuf, c->rcurr, c->rbytes);
        c->rcurr = c->rbuf;
    }

    while (1) {
        // TODO: move to rbuf_* func?
        if (c->rbytes >= c->rsize && c->rbuf_malloced) {
            if (num_allocs == 4) {
                return gotdata;
            }
            ++num_allocs;
            char *new_rbuf = realloc(c->rbuf, c->rsize * 2);
            if (!new_rbuf) {
                STATS_LOCK();
                stats.malloc_fails++;
                STATS_UNLOCK();
                if (settings.verbose > 0) {
                    fprintf(stderr, ""Couldn't realloc input buffer\n"");
                }
                c->rbytes = 0; /* ignore what we read */
                out_of_memory(c, ""SERV...",1,1,memcached.c,try_read_network,,false,2433,2496,try_read_network,,,123,enum try_read_result try_read_network (conn*)
35750,METHOD,memcached.c:<global>,TYPE_DECL,"static bool update_event(conn *c, const int new_flags) {
    assert(c != NULL);

    struct event_base *base = c->event.ev_base;
    if (c->ev_flags == new_flags)
        return true;
    if (event_del(&c->event) == -1) return false;
    event_set(&c->event, c->sfd, new_flags, event_handler, (void *)c);
    event_base_set(base, &c->event);
    c->ev_flags = new_flags;
    if (event_add(&c->event, 0) == -1) return false;
    return true;
}",1,1,memcached.c,update_event,,false,2498,2510,update_event,,,124,"bool update_event (conn*,int)"
35828,METHOD,memcached.c:<global>,TYPE_DECL,"void do_accept_new_conns(const bool do_accept) {
    conn *next;

    for (next = listen_conn; next; next = next->next) {
        if (do_accept) {
            update_event(next, EV_READ | EV_PERSIST);
            if (listen(next->sfd, settings.backlog) != 0) {
                perror(""listen"");
            }
        }
        else {
            update_event(next, 0);
            if (listen(next->sfd, 0) != 0) {
                perror(""listen"");
            }
        }
    }

    if (do_accept) {
        struct timeval maxconns_exited;
        uint64_t elapsed_us;
        gettimeofday(&maxconns_exited,NULL);
        STATS_LOCK();
        elapsed_us =
            (maxconns_exited.tv_sec - stats.maxconns_entered.tv_sec) * 1000000
            + (maxconns_exited.tv_usec - stats.maxconns_entered.tv_usec);
        stats.time_in_listen_disabled_us += elapsed_us;
        stats_state.accepting_conns = true;
        STATS_UNLOCK();
    } else {
        STATS_LOCK();
        stats_state.acceptin...",1,1,memcached.c,do_accept_new_conns,,false,2515,2553,do_accept_new_conns,,,125,void do_accept_new_conns (bool)
35954,METHOD,memcached.c:<global>,TYPE_DECL,"static int _transmit_pre(conn *c, struct iovec *iovs, int iovused, bool one_resp) {
    mc_resp *resp = c->resp_head;
    while (resp && iovused + resp->iovcnt < IOV_MAX-1) {
        if (resp->skip) {
            // Don't actually unchain the resp obj here since it's singly-linked.
            // Just let the post function handle it linearly.
            resp = resp->next;
            continue;
        }
        if (resp->chunked_data_iov) {
            // Handle chunked items specially.
            // They spend much more time in send so we can be a bit wasteful
            // in rebuilding iovecs for them.
            item_chunk *ch = (item_chunk *)ITEM_schunk((item *)resp->iov[resp->chunked_data_iov].iov_base);
            int x;
            for (x = 0; x < resp->iovcnt; x++) {
                // This iov is tracking how far we've copied so far.
                if (x == resp->chunked_data_iov) {
                    int done = resp->chunked_total - resp->iov[x].iov_len;
          ...",1,43,memcached.c,_transmit_pre,,false,2557,2620,_transmit_pre,,,126,"int _transmit_pre (conn*,iovec*,int,bool)"
36294,METHOD,memcached.c:<global>,TYPE_DECL,"static void _transmit_post(conn *c, ssize_t res) {
    // We've written some of the data. Remove the completed
    // responses from the list of pending writes.
    mc_resp *resp = c->resp_head;
    while (resp) {
        int x;
        if (resp->skip) {
            resp = resp_finish(c, resp);
            continue;
        }

        // fastpath check. all small responses should cut here.
        if (res >= resp->tosend) {
            res -= resp->tosend;
            resp = resp_finish(c, resp);
            continue;
        }

        // it's fine to re-check iov's that were zeroed out before.
        for (x = 0; x < resp->iovcnt; x++) {
            struct iovec *iov = &resp->iov[x];
            if (res >= iov->iov_len) {
                resp->tosend -= iov->iov_len;
                res -= iov->iov_len;
                iov->iov_len = 0;
            } else {
                // Dumb special case for chunked items. Currently tracking
                // where to inject the chunked ite...",1,1,memcached.c,_transmit_post,,false,2626,2674,_transmit_post,,,127,"void _transmit_post (conn*,ssize_t)"
36439,METHOD,memcached.c:<global>,TYPE_DECL,"static enum transmit_result transmit(conn *c) {
    assert(c != NULL);
    struct iovec iovs[IOV_MAX];
    struct msghdr msg;
    int iovused = 0;

    // init the msg.
    memset(&msg, 0, sizeof(struct msghdr));
    msg.msg_iov = iovs;

    iovused = _transmit_pre(c, iovs, iovused, TRANSMIT_ALL_RESP);
    if (iovused == 0) {
        // Avoid the syscall if we're only handling a noreply.
        // Return the response object.
        _transmit_post(c, 0);
        return TRANSMIT_COMPLETE;
    }

    // Alright, send.
    ssize_t res;
    msg.msg_iovlen = iovused;
    res = c->sendmsg(c, &msg, 0);
    if (res >= 0) {
        pthread_mutex_lock(&c->thread->stats.mutex);
        c->thread->stats.bytes_written += res;
        pthread_mutex_unlock(&c->thread->stats.mutex);

        // Decrement any partial IOV's and complete any finished resp's.
        _transmit_post(c, res);

        if (c->resp_head) {
            return TRANSMIT_INCOMPLETE;
        } else {
            return TRANSMI...",1,46,memcached.c,transmit,,false,2685,2738,transmit,,,128,enum transmit_result transmit (conn*)
36599,METHOD,memcached.c:<global>,TYPE_DECL,"static void build_udp_header(unsigned char *hdr, mc_resp *resp) {
    // We need to communicate the total number of packets
    // If this isn't set, it's the first time this response is building a udp
    // header, so ""tosend"" must be static.
    if (!resp->udp_total) {
        uint32_t total;
        total = resp->tosend / UDP_DATA_SIZE;
        if (resp->tosend % UDP_DATA_SIZE)
            total++;
        // The spec doesn't really say what we should do here. It's _probably_
        // better to bail out?
        if (total > USHRT_MAX) {
            total = USHRT_MAX;
        }
        resp->udp_total = total;
    }

    // TODO: why wasn't this hto*'s and casts?
    // this ends up sending UDP hdr data specifically in host byte order.
    *hdr++ = resp->request_id / 256;
    *hdr++ = resp->request_id % 256;
    *hdr++ = resp->udp_sequence / 256;
    *hdr++ = resp->udp_sequence % 256;
    *hdr++ = resp->udp_total / 256;
    *hdr++ = resp->udp_total % 256;
    *hdr++ = 0;
    *h...",1,31,memcached.c,build_udp_header,,false,2740,2768,build_udp_header,,,129,"void build_udp_header (unsigned char*,mc_resp*)"
36713,METHOD,memcached.c:<global>,TYPE_DECL,"static enum transmit_result transmit_udp(conn *c) {
    assert(c != NULL);
    struct iovec iovs[IOV_MAX];
    struct msghdr msg;
    mc_resp *resp;
    int iovused = 0;
    unsigned char udp_hdr[UDP_HEADER_SIZE];

    // We only send one UDP packet per call (ugh), so we can only operate on a
    // single response at a time.
    resp = c->resp_head;

    if (!resp) {
        return TRANSMIT_COMPLETE;
    }

    if (resp->skip) {
        resp = resp_finish(c, resp);
        return TRANSMIT_INCOMPLETE;
    }

    // clear the message and initialize it.
    memset(&msg, 0, sizeof(struct msghdr));
    msg.msg_iov = iovs;

    // the UDP source to return to.
    msg.msg_name = &resp->request_addr;
    msg.msg_namelen = resp->request_addr_size;

    // First IOV is the custom UDP header.
    iovs[0].iov_base = (void *)udp_hdr;
    iovs[0].iov_len = UDP_HEADER_SIZE;
    build_udp_header(udp_hdr, resp);
    iovused++;

    // Fill the IOV's the standard way.
    // TODO: might get a small ...",1,26,memcached.c,transmit_udp,,false,2782,2877,transmit_udp,,,130,enum transmit_result transmit_udp (conn*)
36989,METHOD,memcached.c:<global>,TYPE_DECL,"static int read_into_chunked_item(conn *c) {
    int total = 0;
    int res;
    assert(c->rcurr != c->ritem);

    while (c->rlbytes > 0) {
        item_chunk *ch = (item_chunk *)c->ritem;
        if (ch->size == ch->used) {
            // FIXME: ch->next is currently always 0. remove this?
            if (ch->next) {
                c->ritem = (char *) ch->next;
            } else {
                /* Allocate next chunk. Binary protocol needs 2b for \r\n */
                c->ritem = (char *) do_item_alloc_chunk(ch, c->rlbytes +
                       ((c->protocol == binary_prot) ? 2 : 0));
                if (!c->ritem) {
                    // We failed an allocation. Let caller handle cleanup.
                    total = -2;
                    break;
                }
                // ritem has new chunk, restart the loop.
                continue;
                //assert(c->rlbytes == 0);
            }
        }

        int unused = ch->size - ch->used;
        /* first...",1,1,memcached.c,read_into_chunked_item,,false,2884,2961,read_into_chunked_item,,,131,int read_into_chunked_item (conn*)
37310,METHOD,memcached.c:<global>,TYPE_DECL,"static void drive_machine(conn *c) {
    bool stop = false;
    int sfd;
    socklen_t addrlen;
    struct sockaddr_storage addr;
    int nreqs = settings.reqs_per_event;
    int res;
    const char *str;
#ifdef HAVE_ACCEPT4
    static int  use_accept4 = 1;
#else
    static int  use_accept4 = 0;
#endif

    assert(c != NULL);

    while (!stop) {

        switch(c->state) {
        case conn_listening:
            addrlen = sizeof(addr);
#ifdef HAVE_ACCEPT4
            if (use_accept4) {
                sfd = accept4(c->sfd, (struct sockaddr *)&addr, &addrlen, SOCK_NONBLOCK);
            } else {
                sfd = accept(c->sfd, (struct sockaddr *)&addr, &addrlen);
            }
#else
            sfd = accept(c->sfd, (struct sockaddr *)&addr, &addrlen);
#endif
            if (sfd == -1) {
                if (use_accept4 && errno == ENOSYS) {
                    use_accept4 = 0;
                    continue;
                }
                perror(use_accept4 ? ""accept4()"" : ""ac...",1,37,memcached.c,drive_machine,,false,2963,3390,drive_machine,,,132,void drive_machine (conn*)
38423,METHOD,memcached.c:<global>,TYPE_DECL,"void event_handler(const evutil_socket_t fd, const short which, void *arg) {
    conn *c;

    c = (conn *)arg;
    assert(c != NULL);

    c->which = which;

    /* sanity */
    if (fd != c->sfd) {
        if (settings.verbose > 0)
            fprintf(stderr, ""Catastrophic: event fd doesn't match conn fd!\n"");
        conn_close(c);
        return;
    }

    drive_machine(c);

    /* wait for next event */
    return;
}",1,1,memcached.c,event_handler,,false,3392,3412,event_handler,,,133,"void event_handler (evutil_socket_t,short,void*)"
38468,METHOD,memcached.c:<global>,TYPE_DECL,"static int new_socket(struct addrinfo *ai) {
    int sfd;
    int flags;

    if ((sfd = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol)) == -1) {
        return -1;
    }

    if ((flags = fcntl(sfd, F_GETFL, 0)) < 0 ||
        fcntl(sfd, F_SETFL, flags | O_NONBLOCK) < 0) {
        perror(""setting O_NONBLOCK"");
        close(sfd);
        return -1;
    }
    return sfd;
}",1,1,memcached.c,new_socket,,false,3414,3429,new_socket,,,134,int new_socket (addrinfo*)
38523,METHOD,memcached.c:<global>,TYPE_DECL,"static void maximize_sndbuf(const int sfd) {
    socklen_t intsize = sizeof(int);
    int last_good = 0;
    int min, max, avg;
    int old_size;

    /* Start with the default size. */
#ifdef _WIN32
    if (getsockopt((SOCKET)sfd, SOL_SOCKET, SO_SNDBUF, (char *)&old_size, &intsize) != 0) {
#else
    if (getsockopt(sfd, SOL_SOCKET, SO_SNDBUF, &old_size, &intsize) != 0) {
#endif /* #ifdef _WIN32 */
        if (settings.verbose > 0)
            perror(""getsockopt(SO_SNDBUF)"");
        return;
    }

    /* Binary-search for the real maximum. */
    min = old_size;
    max = MAX_SENDBUF_SIZE;

    while (min <= max) {
        avg = ((unsigned int)(min + max)) / 2;
        if (setsockopt(sfd, SOL_SOCKET, SO_SNDBUF, (void *)&avg, intsize) == 0) {
            last_good = avg;
            min = avg + 1;
        } else {
            max = avg - 1;
        }
    }

    if (settings.verbose > 1)
        fprintf(stderr, ""<%d send buffer was %d, now %d\n"", sfd, old_size, last_good);
}",1,10,memcached.c,maximize_sndbuf,,false,3435,3468,maximize_sndbuf,,,135,void maximize_sndbuf (int)
38630,METHOD,memcached.c:<global>,TYPE_DECL,"static int server_socket(const char *interface,
                         int port,
                         enum network_transport transport,
                         FILE *portnumber_file, bool ssl_enabled,
                         uint64_t conntag,
                         enum protocol bproto) {
    int sfd;
    struct linger ling = {0, 0};
    struct addrinfo *ai;
    struct addrinfo *next;
    struct addrinfo hints = { .ai_flags = AI_PASSIVE,
                              .ai_family = AF_UNSPEC };
    char port_buf[NI_MAXSERV];
    int error;
    int success = 0;
    int flags =1;

    hints.ai_socktype = IS_UDP(transport) ? SOCK_DGRAM : SOCK_STREAM;

    if (port == -1) {
        port = 0;
    }
    snprintf(port_buf, sizeof(port_buf), ""%d"", port);
    error= getaddrinfo(interface, port_buf, &hints, &ai);
    if (error != 0) {
        if (error != EAI_SYSTEM)
          fprintf(stderr, ""getaddrinfo(): %s\n"", gai_strerror(error));
        else
          perror(""getaddrinfo()"");
...",1,24,memcached.c,server_socket,,false,3479,3656,server_socket,,,136,"int server_socket (char*,int,network_transport,FILE*,bool,uint64_t,protocol)"
39120,METHOD,memcached.c:<global>,TYPE_DECL,"static int server_sockets(int port, enum network_transport transport,
                          FILE *portnumber_file) {
    bool ssl_enabled = false;
    uint64_t conntag = 0;

#ifdef TLS
    const char *notls = ""notls"";
    ssl_enabled = settings.ssl_enabled;
#endif

    if (settings.inter == NULL) {
        return server_socket(settings.inter, port, transport, portnumber_file, ssl_enabled, conntag, settings.binding_protocol);
    } else {
        // tokenize them and bind to each one of them..
        char *b;
        int ret = 0;
        char *list = strdup(settings.inter);

        if (list == NULL) {
            fprintf(stderr, ""Failed to allocate memory for parsing server interface string\n"");
            return 1;
        }
        // If we encounter any failure, preserve the first errno for the caller.
        int errno_save = 0;
        for (char *p = strtok_r(list, "";,"", &b);
            p != NULL;
            p = strtok_r(NULL, "";,"", &b)) {
            int the_port = por...",1,1,memcached.c,server_sockets,,false,3658,3816,server_sockets,,,137,"int server_sockets (int,network_transport,FILE*)"
39550,METHOD,memcached.c:<global>,TYPE_DECL,"static int new_socket_unix(void) {
    int sfd;
    int flags;

    if ((sfd = socket(AF_UNIX, SOCK_STREAM, 0)) == -1) {
        perror(""socket()"");
        return -1;
    }

    if ((flags = fcntl(sfd, F_GETFL, 0)) < 0 ||
        fcntl(sfd, F_SETFL, flags | O_NONBLOCK) < 0) {
        perror(""setting O_NONBLOCK"");
        close(sfd);
        return -1;
    }
    return sfd;
}",1,1,memcached.c,new_socket_unix,,false,3819,3835,new_socket_unix,,,138,int new_socket_unix (void)
39601,METHOD,memcached.c:<global>,TYPE_DECL,"static int server_socket_unix(const char *path, int access_mask) {
    int sfd;
    struct linger ling = {0, 0};
    struct sockaddr_un addr;
    struct stat tstat;
    int flags =1;
    int old_umask;

    if (!path) {
        return 1;
    }

    if ((sfd = new_socket_unix()) == -1) {
        return 1;
    }

    /*
     * Clean up a previous socket file if we left it around
     */
    if (lstat(path, &tstat) == 0) {
        if (S_ISSOCK(tstat.st_mode))
            unlink(path);
    }

    setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void *)&flags, sizeof(flags));
    setsockopt(sfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flags, sizeof(flags));
    setsockopt(sfd, SOL_SOCKET, SO_LINGER, (void *)&ling, sizeof(ling));

    /*
     * the memset call clears nonstandard fields in some implementations
     * that otherwise mess things up.
     */
    memset(&addr, 0, sizeof(addr));

    addr.sun_family = AF_UNIX;
    strncpy(addr.sun_path, path, sizeof(addr.sun_path) - 1);
    assert(strcmp(...",1,1,memcached.c,server_socket_unix,,false,3837,3895,server_socket_unix,,,139,"int server_socket_unix (char*,int)"
39788,METHOD,memcached.c:<global>,TYPE_DECL,"static void clock_handler(const evutil_socket_t fd, const short which, void *arg) {
    struct timeval t = {.tv_sec = 1, .tv_usec = 0};
    static bool initialized = false;

    if (initialized) {
        /* only delete the event if it's actually there. */
        evtimer_del(&clockevent);
    } else {
        initialized = true;
    }

    // While we're here, check for hash table expansion.
    // This function should be quick to avoid delaying the timer.
    assoc_start_expand(stats_state.curr_items);
    // also, if HUP'ed we need to do some maintenance.
    // for now that's just the authfile reload.
    if (settings.sig_hup) {
        settings.sig_hup = false;

        authfile_load(settings.auth_file);
#ifdef PROXY
        if (settings.proxy_ctx) {
            proxy_start_reload(settings.proxy_ctx);
        }
#endif
    }

    evtimer_set(&clockevent, clock_handler, 0);
    event_base_set(main_base, &clockevent);
    evtimer_add(&clockevent, &t);

#ifdef MEMCACHED_DEBUG
    i...",1,1,memcached.c,clock_handler,,false,3923,3980,clock_handler,,,143,"void clock_handler (evutil_socket_t,short,void*)"
39869,METHOD,memcached.c:<global>,TYPE_DECL,"static const char* flag_enabled_disabled(bool flag) {
    return (flag ? ""enabled"" : ""disabled"");
}",1,1,memcached.c,flag_enabled_disabled,,false,3982,3984,flag_enabled_disabled,,,144,const char* flag_enabled_disabled (bool)
39879,METHOD,memcached.c:<global>,TYPE_DECL,"static void verify_default(const char* param, bool condition) {
    if (!condition) {
        printf(""Default value of [%s] has changed.""
            "" Modify the help text and default value check.\n"", param);
        exit(EXIT_FAILURE);
    }
}",1,1,memcached.c,verify_default,,false,3986,3992,verify_default,,,145,"void verify_default (char*,bool)"
39894,METHOD,memcached.c:<global>,TYPE_DECL,"static void usage(void) {
    printf(PACKAGE "" "" VERSION ""\n"");
    printf(""-p, --port=<num>          TCP port to listen on (default: %d)\n""
           ""-U, --udp-port=<num>      UDP port to listen on (default: %d, off)\n"",
           settings.port, settings.udpport);
#ifndef DISABLE_UNIX_SOCKET
    printf(""-s, --unix-socket=<file>  UNIX socket to listen on (disables network support)\n"");
    printf(""-a, --unix-mask=<mask>    access mask for UNIX socket, in octal (default: %o)\n"",
            settings.access);
#endif /* #ifndef DISABLE_UNIX_SOCKET */
    printf(""-A, --enable-shutdown     enable ascii \""shutdown\"" command\n"");
    printf(""-l, --listen=<addr>       interface to listen on (default: INADDR_ANY)\n"");
#ifdef TLS
    printf(""                          if TLS/SSL is enabled, 'notls' prefix can be used to\n""
           ""                          disable for specific listeners (-l notls:<ip>:<port>) \n"");
#endif
    printf(""-d, --daemon              run as a daemon\n""
        ...",1,46,memcached.c,usage,,false,3994,4187,usage,,,146,void usage (void)
40109,METHOD,memcached.c:<global>,TYPE_DECL,"static void usage_license(void) {
    printf(PACKAGE "" "" VERSION ""\n\n"");
    printf(
    ""Copyright (c) 2003, Danga Interactive, Inc. <http://www.danga.com/>\n""
    ""All rights reserved.\n""
    ""\n""
    ""Redistribution and use in source and binary forms, with or without\n""
    ""modification, are permitted provided that the following conditions are\n""
    ""met:\n""
    ""\n""
    ""    * Redistributions of source code must retain the above copyright\n""
    ""notice, this list of conditions and the following disclaimer.\n""
    ""\n""
    ""    * Redistributions in binary form must reproduce the above\n""
    ""copyright notice, this list of conditions and the following disclaimer\n""
    ""in the documentation and/or other materials provided with the\n""
    ""distribution.\n""
    ""\n""
    ""    * Neither the name of the Danga Interactive nor the names of its\n""
    ""contributors may be used to endorse or promote products derived from\n""
    ""this software without specific prior written permission....",1,1,memcached.c,usage_license,,false,4189,4258,usage_license,,,147,void usage_license (void)
40118,METHOD,memcached.c:<global>,TYPE_DECL,"static void save_pid(const char *pid_file) {
    FILE *fp;
    if (access(pid_file, F_OK) == 0) {
        if ((fp = fopen(pid_file, ""r"")) != NULL) {
            char buffer[1024];
            if (fgets(buffer, sizeof(buffer), fp) != NULL) {
                unsigned int pid;
                if (safe_strtoul(buffer, &pid) && kill((pid_t)pid, 0) == 0) {
                    fprintf(stderr, ""WARNING: The pid file contained the following (running) pid: %u\n"", pid);
                }
            }
            fclose(fp);
        }
    }

    /* Create the pid file first with a temporary name, then
     * atomically move the file to the real name to avoid a race with
     * another process opening the file to read the pid, but finding
     * it empty.
     */
    char tmp_pid_file[1024];
    snprintf(tmp_pid_file, sizeof(tmp_pid_file), ""%s.tmp"", pid_file);

    if ((fp = fopen(tmp_pid_file, ""w"")) == NULL) {
        vperror(""Could not open the pid file %s for writing"", tmp_pid_file);
       ...",1,1,memcached.c,save_pid,,false,4260,4297,save_pid,,,148,void save_pid (char*)
40218,METHOD,memcached.c:<global>,TYPE_DECL,"static void remove_pidfile(const char *pid_file) {
  if (pid_file == NULL)
      return;

  if (unlink(pid_file) != 0) {
      vperror(""Could not remove the pid file %s"", pid_file);
  }

}",1,1,memcached.c,remove_pidfile,,false,4299,4307,remove_pidfile,,,149,void remove_pidfile (char*)
40238,METHOD,memcached.c:<global>,TYPE_DECL,"static void sig_handler(const int sig) {
    stop_main_loop = EXIT_NORMALLY;
    printf(""Signal handled: %s.\n"", strsignal(sig));
}",1,1,memcached.c,sig_handler,,false,4309,4312,sig_handler,,,150,void sig_handler (int)
40250,METHOD,memcached.c:<global>,TYPE_DECL,"static void sighup_handler(const int sig) {
    settings.sig_hup = true;
}",1,1,memcached.c,sighup_handler,,false,4314,4316,sighup_handler,,,151,void sighup_handler (int)
40260,METHOD,memcached.c:<global>,TYPE_DECL,"static void sig_usrhandler(const int sig) {
    printf(""Graceful shutdown signal handled: %s.\n"", strsignal(sig));
    stop_main_loop = GRACE_STOP;
}",1,1,memcached.c,sig_usrhandler,,false,4318,4321,sig_usrhandler,,,152,void sig_usrhandler (int)
40272,METHOD,memcached.c:<global>,TYPE_DECL,"static int enable_large_pages(void) {
#if defined(HAVE_GETPAGESIZES) && defined(HAVE_MEMCNTL)
    int ret = -1;
    size_t sizes[32];
    int avail = getpagesizes(sizes, 32);
    if (avail != -1) {
        size_t max = sizes[0];
        struct memcntl_mha arg = {0};
        int ii;

        for (ii = 1; ii < avail; ++ii) {
            if (max < sizes[ii]) {
                max = sizes[ii];
            }
        }

        arg.mha_flags   = 0;
        arg.mha_pagesize = max;
        arg.mha_cmd = MHA_MAPSIZE_BSSBRK;

        if (memcntl(0, 0, MC_HAT_ADVISE, (caddr_t)&arg, 0, 0) == -1) {
            fprintf(stderr, ""Failed to set large pages: %s\n"",
                    strerror(errno));
            fprintf(stderr, ""Will use default page size\n"");
        } else {
            ret = 0;
        }
    } else {
        fprintf(stderr, ""Failed to get supported pagesizes: %s\n"",
                strerror(errno));
        fprintf(stderr, ""Will use default page size\n"");
    }

    return ret;
...",1,1,memcached.c,enable_large_pages,,false,4327,4414,enable_large_pages,,,153,int enable_large_pages (void)
40280,METHOD,memcached.c:<global>,TYPE_DECL,"static bool sanitycheck(void) {
    /* One of our biggest problems is old and bogus libevents */
    const char *ever = event_get_version();
    if (ever != NULL) {
        if (strncmp(ever, ""1."", 2) == 0) {
            fprintf(stderr, ""You are using libevent %s.\nPlease upgrade to 2.x""
                        "" or newer\n"", event_get_version());
            return false;
        }
    }

    return true;
}",1,1,memcached.c,sanitycheck,,false,4420,4432,sanitycheck,,,154,bool sanitycheck (void)
40310,METHOD,memcached.c:<global>,TYPE_DECL,"static bool _parse_slab_sizes(char *s, uint32_t *slab_sizes) {
    char *b = NULL;
    uint32_t size = 0;
    int i = 0;
    uint32_t last_size = 0;

    if (strlen(s) < 1)
        return false;

    for (char *p = strtok_r(s, ""-"", &b);
         p != NULL;
         p = strtok_r(NULL, ""-"", &b)) {
        if (!safe_strtoul(p, &size) || size < settings.chunk_size
             || size > settings.slab_chunk_size_max) {
            fprintf(stderr, ""slab size %u is out of valid range\n"", size);
            return false;
        }
        if (last_size >= size) {
            fprintf(stderr, ""slab size %u cannot be lower than or equal to a previous class size\n"", size);
            return false;
        }
        if (size <= last_size + CHUNK_ALIGN_BYTES) {
            fprintf(stderr, ""slab size %u must be at least %d bytes larger than previous class\n"",
                    size, CHUNK_ALIGN_BYTES);
            return false;
        }
        slab_sizes[i++] = size;
        last_size = size;...",1,32,memcached.c,_parse_slab_sizes,,false,4434,4470,_parse_slab_sizes,,,155,"bool _parse_slab_sizes (char*,uint32_t*)"
40454,METHOD,memcached.c:<global>,TYPE_DECL,"static int _mc_meta_save_cb(const char *tag, void *ctx, void *data) {
    struct _mc_meta_data *meta = (struct _mc_meta_data *)data;

    // Settings to remember.
    // TODO: should get a version of version which is numeric, else
    // comparisons for compat reasons are difficult.
    // it may be possible to punt on this for now; since we can test for the
    // absence of another key... such as the new numeric version.
    //restart_set_kv(ctx, ""version"", ""%s"", VERSION);
    // We hold the original factor or subopts _string_
    // it can be directly compared without roundtripping through floats or
    // serializing/deserializing the long options list.
    restart_set_kv(ctx, ""slab_config"", ""%s"", meta->slab_config);
    restart_set_kv(ctx, ""maxbytes"", ""%llu"", (unsigned long long) settings.maxbytes);
    restart_set_kv(ctx, ""chunk_size"", ""%d"", settings.chunk_size);
    restart_set_kv(ctx, ""item_size_max"", ""%d"", settings.item_size_max);
    restart_set_kv(ctx, ""slab_chunk_size_ma...",1,1,memcached.c,_mc_meta_save_cb,,false,4487,4539,_mc_meta_save_cb,,,157,"int _mc_meta_save_cb (char*,void*,void*)"
40600,METHOD,memcached.c:<global>,TYPE_DECL,"static int _mc_meta_load_cb(const char *tag, void *ctx, void *data) {
    struct _mc_meta_data *meta = (struct _mc_meta_data *)data;
    char *key;
    char *val;
    int reuse_mmap = 0;
    meta->process_started = 0;
    meta->time_delta = 0;
    meta->current_time = 0;
    int lines_seen = 0;

    // TODO: not sure this is any better than just doing an if/else tree with
    // strcmp's...
    enum {
        R_MMAP_OLDBASE = 0,
        R_MAXBYTES,
        R_CHUNK_SIZE,
        R_ITEM_SIZE_MAX,
        R_SLAB_CHUNK_SIZE_MAX,
        R_SLAB_PAGE_SIZE,
        R_SLAB_CONFIG,
        R_USE_CAS,
        R_SLAB_REASSIGN,
        R_CURRENT_CAS,
        R_OLDEST_CAS,
        R_OLDEST_LIVE,
        R_LOGGER_GID,
        R_CURRENT_TIME,
        R_STOP_TIME,
        R_PROCESS_STARTED,
        R_HASHPOWER,
    };

    const char *opts[] = {
        [R_MMAP_OLDBASE] = ""mmap_oldbase"",
        [R_MAXBYTES] = ""maxbytes"",
        [R_CHUNK_SIZE] = ""chunk_size"",
        [R_ITEM_SIZE_MAX] = ""item_size...",1,21,memcached.c,_mc_meta_load_cb,,false,4551,4760,_mc_meta_load_cb,,,158,"int _mc_meta_load_cb (char*,void*,void*)"
41195,METHOD,memcached.c:<global>,TYPE_DECL,"int main (int argc, char **argv) {
    int c;
    bool lock_memory = false;
    bool do_daemonize = false;
    bool preallocate = false;
    int maxcore = 0;
    char *username = NULL;
    char *pid_file = NULL;
    struct passwd *pw;
    struct rlimit rlim;
    char *buf;
    char unit = '\0';
    int size_max = 0;
    int retval = EXIT_SUCCESS;
    bool protocol_specified = false;
    bool tcp_specified = false;
    bool udp_specified = false;
    bool start_lru_maintainer = true;
    bool start_lru_crawler = true;
    bool start_assoc_maint = true;
    enum hashfunc_type hash_type = MURMUR3_HASH;
    uint32_t tocrawl;
    uint32_t slab_sizes[MAX_NUMBER_OF_SLAB_CLASSES];
    bool use_slab_sizes = false;
    char *slab_sizes_unparsed = NULL;
    bool slab_chunk_size_changed = false;
    // struct for restart code. Initialized up here so we can curry
    // important settings to save or validate.
    struct _mc_meta_data *meta = malloc(sizeof(struct _mc_meta_data));
    meta->slab_c...",1,24,memcached.c,main,,false,4762,6295,main,,,159,"int main (int,char**)"
44158,METHOD,memcached.h:<global>,TYPE_DECL,<global>,1,1,memcached.h,memcached.h:<global>,,false,1,1060,<global>,,,1,
44160,METHOD,memcached.h:<global>,TYPE_DECL,"typedef void (*ADD_STAT)(const char *key, const uint16_t klen,
                         const char *val, const uint32_t vlen,
                         const void *cookie);",14,44,memcached.h,ADD_STAT,,false,189,191,ADD_STAT,,,1,"void ADD_STAT (char*,uint16_t,char*,uint32_t,void*)"
44201,METHOD,<empty>,<empty>,<empty>,1,,memcached.h,protocol:<clinit>,,false,231,,<clinit>,,,4,
44217,METHOD,<empty>,<empty>,<empty>,1,,memcached.h,pause_thread_types:<clinit>,,false,246,,<clinit>,,,5,
44240,METHOD,<empty>,<empty>,<empty>,1,,memcached.h,store_item_type:<clinit>,,false,276,,<clinit>,,,7,
44296,METHOD,<empty>,<empty>,<empty>,1,,memcached.h,thread_stats:<clinit>,,false,356,,<clinit>,,,34,
44471,METHOD,<empty>,<empty>,<empty>,1,,memcached.h,_stritem:<clinit>,,false,575,,<clinit>,,,16,
44481,METHOD,<empty>,<empty>,<empty>,1,,memcached.h,crawler_run_type:<clinit>,,false,601,,<clinit>,,,4,
44522,METHOD,<empty>,<empty>,<empty>,1,,memcached.h,_strchunk:<clinit>,,false,623,,<clinit>,,,15,
44532,METHOD,memcached.h:<global>,TYPE_DECL,typedef void (*io_queue_stack_cb)(io_queue_t *q);,14,48,memcached.h,io_queue_stack_cb,,false,670,670,io_queue_stack_cb,,,34,void io_queue_stack_cb (io_queue_t*)
44537,METHOD,memcached.h:<global>,TYPE_DECL,typedef void (*io_queue_cb)(io_pending_t *pending);,14,50,memcached.h,io_queue_cb,,false,671,671,io_queue_cb,,,35,void io_queue_cb (io_pending_t*)
44584,METHOD,<empty>,<empty>,<empty>,1,,memcached.h,LIBEVENT_THREAD:<clinit>,,false,704,,<clinit>,,,27,
44618,METHOD,<empty>,<empty>,<empty>,1,,memcached.h,_mc_resp:<clinit>,,false,743,,<clinit>,,,23,
44639,METHOD,<empty>,<empty>,<empty>,1,,memcached.h,_mc_resp_bundle:<clinit>,,false,773,,<clinit>,,,8,
44652,METHOD,<empty>,<empty>,<empty>,1,,memcached.h,_io_pending_t:<clinit>,,false,783,,<clinit>,,,6,
44718,METHOD,conn,TYPE_DECL,int (*try_read_command)(conn *c);,9,36,memcached.h,conn.try_read_command,,false,872,872,try_read_command,,,57,int conn.try_read_command (conn*)
44723,METHOD,conn,TYPE_DECL,"ssize_t (*read)(conn  *c, void *buf, size_t count);",13,54,memcached.h,conn.read,,false,873,873,read,,,58,"ssize_t conn.read (conn*,void*,size_t)"
44730,METHOD,conn,TYPE_DECL,"ssize_t (*sendmsg)(conn *c, struct msghdr *msg, int flags);",13,62,memcached.h,conn.sendmsg,,false,874,874,sendmsg,,,59,"ssize_t conn.sendmsg (conn*,msghdr*,int)"
44737,METHOD,conn,TYPE_DECL,"ssize_t (*write)(conn *c, void *buf, size_t count);",13,54,memcached.h,conn.write,,false,875,875,write,,,60,"ssize_t conn.write (conn*,void*,size_t)"
44744,METHOD,<empty>,<empty>,<empty>,1,,memcached.h,conn:<clinit>,,false,794,,<clinit>,,,61,
44772,METHOD,memcached.h:<global>,TYPE_DECL,void do_accept_new_conns(const bool do_accept);,6,46,memcached.h,do_accept_new_conns,,false,916,916,do_accept_new_conns,,,56,void do_accept_new_conns (bool)
44781,METHOD,memcached.h:<global>,TYPE_DECL,"void thread_io_queue_add(LIBEVENT_THREAD *t, int type, void *ctx, io_queue_stack_cb cb, io_queue_stack_cb com_cb, io_queue_cb ret_cb, io_queue_cb fin_cb);",6,153,memcached.h,thread_io_queue_add,,false,923,923,thread_io_queue_add,,,61,"void thread_io_queue_add (LIBEVENT_THREAD*,int,void*,io_queue_stack_cb,io_queue_stack_cb,io_queue_cb,io_queue_cb)"
44792,METHOD,memcached.h:<global>,TYPE_DECL,void conn_io_queue_setup(conn *c);,6,33,memcached.h,conn_io_queue_setup,,false,924,924,conn_io_queue_setup,,,62,void conn_io_queue_setup (conn*)
44797,METHOD,memcached.h:<global>,TYPE_DECL,"io_queue_t *conn_io_queue_get(conn *c, int type);",12,48,memcached.h,conn_io_queue_get,,false,925,925,conn_io_queue_get,,,63,"io_queue_t* conn_io_queue_get (conn*,int)"
44803,METHOD,memcached.h:<global>,TYPE_DECL,"io_queue_cb_t *thread_io_queue_get(LIBEVENT_THREAD *t, int type);",15,64,memcached.h,thread_io_queue_get,,false,926,926,thread_io_queue_get,,,64,"io_queue_cb_t* thread_io_queue_get (LIBEVENT_THREAD*,int)"
44809,METHOD,memcached.h:<global>,TYPE_DECL,void conn_io_queue_return(io_pending_t *io);,6,43,memcached.h,conn_io_queue_return,,false,927,927,conn_io_queue_return,,,65,void conn_io_queue_return (io_pending_t*)
44814,METHOD,memcached.h:<global>,TYPE_DECL,"conn *conn_new(const int sfd, const enum conn_states init_state, const int event_flags, const int read_buffer_size,
    enum network_transport transport, struct event_base *base, void *ssl, uint64_t conntag, enum protocol bproto);",6,113,memcached.h,conn_new,,false,928,929,conn_new,,,66,"conn* conn_new (int,conn_states,int,int,network_transport,event_base*,void*,uint64_t,protocol)"
44827,METHOD,memcached.h:<global>,TYPE_DECL,void conn_worker_readd(conn *c);,6,31,memcached.h,conn_worker_readd,,false,931,931,conn_worker_readd,,,67,void conn_worker_readd (conn*)
44832,METHOD,memcached.h:<global>,TYPE_DECL,"extern int daemonize(int nochdir, int noclose);",12,46,memcached.h,daemonize,,false,932,932,daemonize,,,68,"int daemonize (int,int)"
44838,METHOD,memcached.h:<global>,TYPE_DECL,"void memcached_thread_init(int nthreads, void *arg);",6,51,memcached.h,memcached_thread_init,,false,952,952,memcached_thread_init,,,69,"void memcached_thread_init (int,void*)"
44844,METHOD,memcached.h:<global>,TYPE_DECL,void redispatch_conn(conn *c);,6,29,memcached.h,redispatch_conn,,false,953,953,redispatch_conn,,,70,void redispatch_conn (conn*)
44849,METHOD,memcached.h:<global>,TYPE_DECL,void timeout_conn(conn *c);,6,26,memcached.h,timeout_conn,,false,954,954,timeout_conn,,,71,void timeout_conn (conn*)
44854,METHOD,memcached.h:<global>,TYPE_DECL,void return_io_pending(io_pending_t *io);,6,40,memcached.h,return_io_pending,,false,958,958,return_io_pending,,,72,void return_io_pending (io_pending_t*)
44859,METHOD,memcached.h:<global>,TYPE_DECL,"void dispatch_conn_new(int sfd, enum conn_states init_state, int event_flags, int read_buffer_size,
    enum network_transport transport, void *ssl, uint64_t conntag, enum protocol bproto);",6,88,memcached.h,dispatch_conn_new,,false,959,960,dispatch_conn_new,,,73,"void dispatch_conn_new (int,conn_states,int,int,network_transport,void*,uint64_t,protocol)"
44871,METHOD,memcached.h:<global>,TYPE_DECL,void sidethread_conn_close(conn *c);,6,35,memcached.h,sidethread_conn_close,,false,961,961,sidethread_conn_close,,,74,void sidethread_conn_close (conn*)
44878,METHOD,memcached.h:<global>,TYPE_DECL,void accept_new_conns(const bool do_accept);,6,43,memcached.h,accept_new_conns,,false,968,968,accept_new_conns,,,77,void accept_new_conns (bool)
44883,METHOD,memcached.h:<global>,TYPE_DECL,void  conn_close_idle(conn *c);,7,30,memcached.h,conn_close_idle,,false,969,969,conn_close_idle,,,78,void conn_close_idle (conn*)
44888,METHOD,memcached.h:<global>,TYPE_DECL,void  conn_close_all(void);,7,26,memcached.h,conn_close_all,,false,970,970,conn_close_all,,,79,void conn_close_all (void)
44893,METHOD,memcached.h:<global>,TYPE_DECL,"item *item_alloc(char *key, size_t nkey, int flags, rel_time_t exptime, int nbytes);",6,83,memcached.h,item_alloc,,false,971,971,item_alloc,,,80,"item* item_alloc (char*,size_t,int,rel_time_t,int)"
44902,METHOD,memcached.h:<global>,TYPE_DECL,"item *item_get(const char *key, const size_t nkey, conn *c, const bool do_update);",6,81,memcached.h,item_get,,false,974,974,item_get,,,81,"item* item_get (char*,size_t,conn*,bool)"
44910,METHOD,memcached.h:<global>,TYPE_DECL,"item *item_get_locked(const char *key, const size_t nkey, conn *c, const bool do_update, uint32_t *hv);",6,102,memcached.h,item_get_locked,,false,975,975,item_get_locked,,,82,"item* item_get_locked (char*,size_t,conn*,bool,uint32_t*)"
44919,METHOD,memcached.h:<global>,TYPE_DECL,"item *item_touch(const char *key, const size_t nkey, uint32_t exptime, conn *c);",6,79,memcached.h,item_touch,,false,976,976,item_touch,,,83,"item* item_touch (char*,size_t,uint32_t,conn*)"
44927,METHOD,memcached.h:<global>,TYPE_DECL,int   item_link(item *it);,7,25,memcached.h,item_link,,false,977,977,item_link,,,84,int item_link (item*)
44932,METHOD,memcached.h:<global>,TYPE_DECL,void  item_remove(item *it);,7,27,memcached.h,item_remove,,false,978,978,item_remove,,,85,void item_remove (item*)
44937,METHOD,memcached.h:<global>,TYPE_DECL,"int   item_replace(item *it, item *new_it, const uint32_t hv);",7,61,memcached.h,item_replace,,false,979,979,item_replace,,,86,"int item_replace (item*,item*,uint32_t)"
44944,METHOD,memcached.h:<global>,TYPE_DECL,void  item_unlink(item *it);,7,27,memcached.h,item_unlink,,false,980,980,item_unlink,,,87,void item_unlink (item*)
44949,METHOD,memcached.h:<global>,TYPE_DECL,void item_lock(uint32_t hv);,6,27,memcached.h,item_lock,,false,982,982,item_lock,,,88,void item_lock (uint32_t)
44954,METHOD,memcached.h:<global>,TYPE_DECL,void *item_trylock(uint32_t hv);,6,31,memcached.h,item_trylock,,false,983,983,item_trylock,,,89,void* item_trylock (uint32_t)
44959,METHOD,memcached.h:<global>,TYPE_DECL,void item_trylock_unlock(void *arg);,6,35,memcached.h,item_trylock_unlock,,false,984,984,item_trylock_unlock,,,90,void item_trylock_unlock (void*)
44964,METHOD,memcached.h:<global>,TYPE_DECL,void item_unlock(uint32_t hv);,6,29,memcached.h,item_unlock,,false,985,985,item_unlock,,,91,void item_unlock (uint32_t)
44969,METHOD,memcached.h:<global>,TYPE_DECL,void pause_threads(enum pause_thread_types type);,6,48,memcached.h,pause_threads,,false,986,986,pause_threads,,,92,void pause_threads (pause_thread_types)
44974,METHOD,memcached.h:<global>,TYPE_DECL,void stop_threads(void);,6,23,memcached.h,stop_threads,,false,987,987,stop_threads,,,93,void stop_threads (void)
44979,METHOD,memcached.h:<global>,TYPE_DECL,int stop_conn_timeout_thread(void);,5,34,memcached.h,stop_conn_timeout_thread,,false,988,988,stop_conn_timeout_thread,,,94,int stop_conn_timeout_thread (void)
44984,METHOD,memcached.h:<global>,TYPE_DECL,void STATS_LOCK(void);,6,21,memcached.h,STATS_LOCK,,false,991,991,STATS_LOCK,,,95,void STATS_LOCK (void)
44989,METHOD,memcached.h:<global>,TYPE_DECL,void STATS_UNLOCK(void);,6,23,memcached.h,STATS_UNLOCK,,false,992,992,STATS_UNLOCK,,,96,void STATS_UNLOCK (void)
44994,METHOD,memcached.h:<global>,TYPE_DECL,void threadlocal_stats_reset(void);,6,34,memcached.h,threadlocal_stats_reset,,false,995,995,threadlocal_stats_reset,,,97,void threadlocal_stats_reset (void)
44999,METHOD,memcached.h:<global>,TYPE_DECL,void threadlocal_stats_aggregate(struct thread_stats *stats);,6,60,memcached.h,threadlocal_stats_aggregate,,false,996,996,threadlocal_stats_aggregate,,,98,void threadlocal_stats_aggregate (thread_stats*)
45004,METHOD,memcached.h:<global>,TYPE_DECL,"void slab_stats_aggregate(struct thread_stats *stats, struct slab_stats *out);",6,77,memcached.h,slab_stats_aggregate,,false,997,997,slab_stats_aggregate,,,99,"void slab_stats_aggregate (thread_stats*,slab_stats*)"
45010,METHOD,memcached.h:<global>,TYPE_DECL,LIBEVENT_THREAD *get_worker_thread(int id);,17,42,memcached.h,get_worker_thread,,false,998,998,get_worker_thread,,,100,LIBEVENT_THREAD* get_worker_thread (int)
45015,METHOD,memcached.h:<global>,TYPE_DECL,"void append_stat(const char *name, ADD_STAT add_stats, conn *c,
                 const char *fmt, ...);",6,38,memcached.h,append_stat,,false,1001,1002,append_stat,,,101,"void append_stat (char*,ADD_STAT,conn*,char*...)"
45025,METHOD,memcached.h:<global>,TYPE_DECL,"void out_string(conn *c, const char *str);",6,41,memcached.h,out_string,,false,1007,1007,out_string,,,104,"void out_string (conn*,char*)"
45031,METHOD,memcached.h:<global>,TYPE_DECL,rel_time_t realtime(const time_t exptime);,12,41,memcached.h,realtime,,false,1014,1014,realtime,,,105,rel_time_t realtime (time_t)
45036,METHOD,memcached.h:<global>,TYPE_DECL,"item* limited_get(char *key, size_t nkey, conn *c, uint32_t exptime, bool should_touch, bool do_update, bool *overflow);",5,119,memcached.h,limited_get,,false,1015,1015,limited_get,,,106,"item* limited_get (char*,size_t,conn*,uint32_t,bool,bool,bool*)"
45047,METHOD,memcached.h:<global>,TYPE_DECL,"item* limited_get_locked(char *key, size_t nkey, conn *c, bool do_update, uint32_t *hv, bool *overflow);",5,103,memcached.h,limited_get_locked,,false,1016,1016,limited_get_locked,,,107,"item* limited_get_locked (char*,size_t,conn*,bool,uint32_t*,bool*)"
45057,METHOD,memcached.h:<global>,TYPE_DECL,void resp_reset(mc_resp *resp);,6,30,memcached.h,resp_reset,,false,1018,1018,resp_reset,,,108,void resp_reset (mc_resp*)
45062,METHOD,memcached.h:<global>,TYPE_DECL,"void resp_add_iov(mc_resp *resp, const void *buf, int len);",6,58,memcached.h,resp_add_iov,,false,1019,1019,resp_add_iov,,,109,"void resp_add_iov (mc_resp*,void*,int)"
45069,METHOD,memcached.h:<global>,TYPE_DECL,"void resp_add_chunked_iov(mc_resp *resp, const void *buf, int len);",6,66,memcached.h,resp_add_chunked_iov,,false,1020,1020,resp_add_chunked_iov,,,110,"void resp_add_chunked_iov (mc_resp*,void*,int)"
45076,METHOD,memcached.h:<global>,TYPE_DECL,bool resp_start(conn *c);,6,24,memcached.h,resp_start,,false,1021,1021,resp_start,,,111,bool resp_start (conn*)
45081,METHOD,memcached.h:<global>,TYPE_DECL,"mc_resp* resp_finish(conn *c, mc_resp *resp);",8,44,memcached.h,resp_finish,,false,1022,1022,resp_finish,,,112,"mc_resp* resp_finish (conn*,mc_resp*)"
45087,METHOD,memcached.h:<global>,TYPE_DECL,bool resp_has_stack(conn *c);,6,28,memcached.h,resp_has_stack,,false,1023,1023,resp_has_stack,,,113,bool resp_has_stack (conn*)
45092,METHOD,memcached.h:<global>,TYPE_DECL,bool rbuf_switch_to_malloc(conn *c);,6,35,memcached.h,rbuf_switch_to_malloc,,false,1024,1024,rbuf_switch_to_malloc,,,114,bool rbuf_switch_to_malloc (conn*)
45097,METHOD,memcached.h:<global>,TYPE_DECL,void conn_release_items(conn *c);,6,32,memcached.h,conn_release_items,,false,1025,1025,conn_release_items,,,115,void conn_release_items (conn*)
45102,METHOD,memcached.h:<global>,TYPE_DECL,"void conn_set_state(conn *c, enum conn_states state);",6,52,memcached.h,conn_set_state,,false,1026,1026,conn_set_state,,,116,"void conn_set_state (conn*,conn_states)"
45108,METHOD,memcached.h:<global>,TYPE_DECL,"void out_of_memory(conn *c, char *ascii_error);",6,46,memcached.h,out_of_memory,,false,1027,1027,out_of_memory,,,117,"void out_of_memory (conn*,char*)"
45114,METHOD,memcached.h:<global>,TYPE_DECL,"void out_errstring(conn *c, const char *str);",6,44,memcached.h,out_errstring,,false,1028,1028,out_errstring,,,118,"void out_errstring (conn*,char*)"
45120,METHOD,memcached.h:<global>,TYPE_DECL,"void write_and_free(conn *c, char *buf, int bytes);",6,50,memcached.h,write_and_free,,false,1029,1029,write_and_free,,,119,"void write_and_free (conn*,char*,int)"
45127,METHOD,memcached.h:<global>,TYPE_DECL,"void server_stats(ADD_STAT add_stats, conn *c);",6,46,memcached.h,server_stats,,false,1030,1030,server_stats,,,120,"void server_stats (ADD_STAT,conn*)"
45133,METHOD,memcached.h:<global>,TYPE_DECL,"void append_stats(const char *key, const uint16_t klen,
                  const char *val, const uint32_t vlen,
                  const void *cookie);",6,37,memcached.h,append_stats,,false,1031,1033,append_stats,,,121,"void append_stats (char*,uint16_t,char*,uint32_t,void*)"
45142,METHOD,memcached.h:<global>,TYPE_DECL,"bool get_stats(const char *stat_type, int nkey, ADD_STAT add_stats, void *c);",6,76,memcached.h,get_stats,,false,1035,1035,get_stats,,,122,"bool get_stats (char*,int,ADD_STAT,void*)"
45150,METHOD,memcached.h:<global>,TYPE_DECL,void stats_reset(void);,6,22,memcached.h,stats_reset,,false,1036,1036,stats_reset,,,123,void stats_reset (void)
45155,METHOD,memcached.h:<global>,TYPE_DECL,"void process_stat_settings(ADD_STAT add_stats, void *c);",6,55,memcached.h,process_stat_settings,,false,1037,1037,process_stat_settings,,,124,"void process_stat_settings (ADD_STAT,void*)"
45161,METHOD,memcached.h:<global>,TYPE_DECL,"void process_stats_conns(ADD_STAT add_stats, void *c);",6,53,memcached.h,process_stats_conns,,false,1038,1038,process_stats_conns,,,125,"void process_stats_conns (ADD_STAT,void*)"
45174,METHOD,murmur3_hash.c:<global>,TYPE_DECL,<global>,1,1,murmur3_hash.c,murmur3_hash.c:<global>,,false,1,123,<global>,,,1,
45176,METHOD,murmur3_hash.c:<global>,TYPE_DECL,"static inline uint32_t rotl32 ( uint32_t x, int8_t r )
{
  return (x << r) | (x >> (32 - r));
}",1,1,murmur3_hash.c,rotl32,,false,33,36,rotl32,,,1,"uint32_t rotl32 (uint32_t,int8_t)"
45192,METHOD,murmur3_hash.c:<global>,TYPE_DECL,"static FORCE_INLINE uint32_t getblock32 ( const uint32_t * p, int i )
{
  return p[i];
}",1,7,murmur3_hash.c,getblock32,,false,48,51,getblock32,,,2,"uint32_t getblock32 (uint32_t*,int)"
45202,METHOD,murmur3_hash.c:<global>,TYPE_DECL,"static FORCE_INLINE uint32_t fmix32 ( uint32_t h )
{
  h ^= h >> 16;
  h *= 0x85ebca6b;
  h ^= h >> 13;
  h *= 0xc2b2ae35;
  h ^= h >> 16;

  return h;
}",1,7,murmur3_hash.c,fmix32,,false,56,65,fmix32,,,3,uint32_t fmix32 (uint32_t)
45230,METHOD,murmur3_hash.c:<global>,TYPE_DECL,"uint32_t MurmurHash3_x86_32 ( const void * key, size_t length)
{
  const uint8_t * data = (const uint8_t*)key;
  const int nblocks = length / 4;

  uint32_t h1 = 0;

  uint32_t c1 = 0xcc9e2d51;
  uint32_t c2 = 0x1b873593;

  //----------
  // body

  const uint32_t * blocks = (const uint32_t *)(data + nblocks*4);

  for(int i = -nblocks; i; i++)
  {
    uint32_t k1 = getblock32(blocks,i);

    k1 *= c1;
    k1 = ROTL32(k1,15);
    k1 *= c2;

    h1 ^= k1;
    h1 = ROTL32(h1,13);
    h1 = h1*5+0xe6546b64;
  }

  //----------
  // tail

  const uint8_t * tail = (const uint8_t*)(data + nblocks*4);

  uint32_t k1 = 0;

  switch(length & 3)
  {
  case 3: k1 ^= tail[2] << 16;
  case 2: k1 ^= tail[1] << 8;
  case 1: k1 ^= tail[0];
          k1 *= c1; k1 = ROTL32(k1,15); k1 *= c2; h1 ^= k1;
  };

  //----------
  // finalization

  h1 ^= length;

  h1 = fmix32(h1);

  //*(uint32_t*)out = h1;
  return h1;
}",1,9,murmur3_hash.c,MurmurHash3_x86_32,,false,71,123,MurmurHash3_x86_32,,,4,"uint32_t MurmurHash3_x86_32 (void*,size_t)"
45399,METHOD,murmur3_hash.h:<global>,TYPE_DECL,<global>,1,23,murmur3_hash.h,murmur3_hash.h:<global>,,false,1,19,<global>,,,1,
45401,METHOD,murmur3_hash.h:<global>,TYPE_DECL,"uint32_t MurmurHash3_x86_32(const void *key, size_t length);",10,59,murmur3_hash.h,MurmurHash3_x86_32,,false,15,15,MurmurHash3_x86_32,,,1,"uint32_t MurmurHash3_x86_32 (void*,size_t)"
45422,METHOD,openbsd_priv.c:<global>,TYPE_DECL,<global>,1,20,openbsd_priv.c,openbsd_priv.c:<global>,,false,1,32,<global>,,,1,
45441,METHOD,proto_bin.c:<global>,TYPE_DECL,<global>,1,1,proto_bin.c,proto_bin.c:<global>,,false,1,1329,<global>,,,1,
45443,METHOD,proto_bin.c:<global>,TYPE_DECL,"static void process_bin_flush(conn *c, char *extbuf);",13,52,proto_bin.c,process_bin_flush,,false,17,17,process_bin_flush,,,1,"void process_bin_flush (conn*,char*)"
45449,METHOD,proto_bin.c:<global>,TYPE_DECL,static void process_bin_append_prepend(conn *c);,13,47,proto_bin.c,process_bin_append_prepend,,false,18,18,process_bin_append_prepend,,,2,void process_bin_append_prepend (conn*)
45454,METHOD,proto_bin.c:<global>,TYPE_DECL,"static void process_bin_update(conn *c, char *extbuf);",13,53,proto_bin.c,process_bin_update,,false,19,19,process_bin_update,,,3,"void process_bin_update (conn*,char*)"
45460,METHOD,proto_bin.c:<global>,TYPE_DECL,"static void process_bin_get_or_touch(conn *c, char *extbuf);",13,59,proto_bin.c,process_bin_get_or_touch,,false,20,20,process_bin_get_or_touch,,,4,"void process_bin_get_or_touch (conn*,char*)"
45466,METHOD,proto_bin.c:<global>,TYPE_DECL,static void process_bin_delete(conn *c);,13,39,proto_bin.c,process_bin_delete,,false,21,21,process_bin_delete,,,5,void process_bin_delete (conn*)
45471,METHOD,proto_bin.c:<global>,TYPE_DECL,"static void complete_incr_bin(conn *c, char *extbuf);",13,52,proto_bin.c,complete_incr_bin,,false,22,22,complete_incr_bin,,,6,"void complete_incr_bin (conn*,char*)"
45477,METHOD,proto_bin.c:<global>,TYPE_DECL,static void process_bin_stat(conn *c);,13,37,proto_bin.c,process_bin_stat,,false,23,23,process_bin_stat,,,7,void process_bin_stat (conn*)
45482,METHOD,proto_bin.c:<global>,TYPE_DECL,static void process_bin_sasl_auth(conn *c);,13,42,proto_bin.c,process_bin_sasl_auth,,false,24,24,process_bin_sasl_auth,,,8,void process_bin_sasl_auth (conn*)
45487,METHOD,proto_bin.c:<global>,TYPE_DECL,"static void dispatch_bin_command(conn *c, char *extbuf);",13,55,proto_bin.c,dispatch_bin_command,,false,25,25,dispatch_bin_command,,,9,"void dispatch_bin_command (conn*,char*)"
45493,METHOD,proto_bin.c:<global>,TYPE_DECL,static void complete_update_bin(conn *c);,13,40,proto_bin.c,complete_update_bin,,false,26,26,complete_update_bin,,,10,void complete_update_bin (conn*)
45498,METHOD,proto_bin.c:<global>,TYPE_DECL,static void process_bin_complete_sasl_auth(conn *c);,13,51,proto_bin.c,process_bin_complete_sasl_auth,,false,27,27,process_bin_complete_sasl_auth,,,11,void process_bin_complete_sasl_auth (conn*)
45503,METHOD,proto_bin.c:<global>,TYPE_DECL,"static void write_bin_miss_response(conn *c, char *key, size_t nkey);",13,68,proto_bin.c,write_bin_miss_response,,false,29,29,write_bin_miss_response,,,12,"void write_bin_miss_response (conn*,char*,size_t)"
45510,METHOD,proto_bin.c:<global>,TYPE_DECL,"void complete_nread_binary(conn *c) {
    assert(c != NULL);
    assert(c->cmd >= 0);

    switch(c->substate) {
    case bin_read_set_value:
        complete_update_bin(c);
        break;
    case bin_reading_sasl_auth_data:
        process_bin_complete_sasl_auth(c);
        if (c->item) {
            do_item_remove(c->item);
            c->item = NULL;
        }
        break;
    default:
        fprintf(stderr, ""Not handling substate %d\n"", c->substate);
        assert(0);
    }
}",1,1,proto_bin.c,complete_nread_binary,,false,31,50,complete_nread_binary,,,13,void complete_nread_binary (conn*)
45563,METHOD,proto_bin.c:<global>,TYPE_DECL,"int try_read_command_binary(conn *c) {
    /* Do we have the complete packet header? */
    if (c->rbytes < sizeof(c->binary_header)) {
        /* need more data! */
        return 0;
    } else {
        memcpy(&c->binary_header, c->rcurr, sizeof(c->binary_header));
        protocol_binary_request_header* req;
        req = &c->binary_header;

        if (settings.verbose > 1) {
            /* Dump the packet before we convert it to host order */
            int ii;
            fprintf(stderr, ""<%d Read binary protocol data:"", c->sfd);
            for (ii = 0; ii < sizeof(req->bytes); ++ii) {
                if (ii % 4 == 0) {
                    fprintf(stderr, ""\n<%d   "", c->sfd);
                }
                fprintf(stderr, "" 0x%02x"", req->bytes[ii]);
            }
            fprintf(stderr, ""\n"");
        }

        c->binary_header = *req;
        c->binary_header.request.keylen = ntohs(req->request.keylen);
        c->binary_header.request.bodylen = ntohl(req->request.b...",1,47,proto_bin.c,try_read_command_binary,,false,52,126,try_read_command_binary,,,14,int try_read_command_binary (conn*)
45878,METHOD,proto_bin.c:<global>,TYPE_DECL,"static char* binary_get_key(conn *c) {
    return c->rcurr - (c->binary_header.request.keylen);
}",1,1,proto_bin.c,binary_get_key,,false,131,133,binary_get_key,,,15,char* binary_get_key (conn*)
45895,METHOD,proto_bin.c:<global>,TYPE_DECL,"static void add_bin_header(conn *c, uint16_t err, uint8_t hdr_len, uint16_t key_len, uint32_t body_len) {
    protocol_binary_response_header* header;
    mc_resp *resp = c->resp;

    assert(c);

    resp_reset(resp);

    header = (protocol_binary_response_header *)resp->wbuf;

    header->response.magic = (uint8_t)PROTOCOL_BINARY_RES;
    header->response.opcode = c->binary_header.request.opcode;
    header->response.keylen = (uint16_t)htons(key_len);

    header->response.extlen = (uint8_t)hdr_len;
    header->response.datatype = (uint8_t)PROTOCOL_BINARY_RAW_BYTES;
    header->response.status = (uint16_t)htons(err);

    header->response.bodylen = htonl(body_len);
    header->response.opaque = c->opaque;
    header->response.cas = htonll(c->cas);

    if (settings.verbose > 1) {
        int ii;
        fprintf(stderr, "">%d Writing bin response:"", c->sfd);
        for (ii = 0; ii < sizeof(header->bytes); ++ii) {
            if (ii % 4 == 0) {
                fprintf(stderr, ""\n>%...",1,1,proto_bin.c,add_bin_header,,false,135,171,add_bin_header,,,16,"void add_bin_header (conn*,uint16_t,uint8_t,uint16_t,uint32_t)"
46077,METHOD,proto_bin.c:<global>,TYPE_DECL,"void write_bin_error(conn *c, protocol_binary_response_status err,
                            const char *errstr, int swallow) {
    size_t len;

    if (!errstr) {
        switch (err) {
        case PROTOCOL_BINARY_RESPONSE_ENOMEM:
            errstr = ""Out of memory"";
            break;
        case PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND:
            errstr = ""Unknown command"";
            break;
        case PROTOCOL_BINARY_RESPONSE_KEY_ENOENT:
            errstr = ""Not found"";
            break;
        case PROTOCOL_BINARY_RESPONSE_EINVAL:
            errstr = ""Invalid arguments"";
            break;
        case PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS:
            errstr = ""Data exists for key."";
            break;
        case PROTOCOL_BINARY_RESPONSE_E2BIG:
            errstr = ""Too large."";
            break;
        case PROTOCOL_BINARY_RESPONSE_DELTA_BADVAL:
            errstr = ""Non-numeric server-side value for incr or decr"";
            break;
        case PROTOCOL_BIN...",1,1,proto_bin.c,write_bin_error,,false,179,234,write_bin_error,,,17,"void write_bin_error (conn*,protocol_binary_response_status,char*,int)"
46213,METHOD,proto_bin.c:<global>,TYPE_DECL,"static void handle_binary_protocol_error(conn *c) {
    write_bin_error(c, PROTOCOL_BINARY_RESPONSE_EINVAL, NULL, 0);
    if (settings.verbose) {
        fprintf(stderr, ""Protocol error (opcode %02x), close connection %d\n"",
                c->binary_header.request.opcode, c->sfd);
    }
    c->close_after_write = true;
}",1,1,proto_bin.c,handle_binary_protocol_error,,false,237,244,handle_binary_protocol_error,,,18,void handle_binary_protocol_error (conn*)
46246,METHOD,proto_bin.c:<global>,TYPE_DECL,"static void write_bin_response(conn *c, void *d, int hlen, int keylen, int dlen) {
    if (!c->noreply || c->cmd == PROTOCOL_BINARY_CMD_GET ||
        c->cmd == PROTOCOL_BINARY_CMD_GETK) {
        add_bin_header(c, 0, hlen, keylen, dlen);
        mc_resp *resp = c->resp;
        if (dlen > 0) {
            resp_add_iov(resp, d, dlen);
        }
    }

    conn_set_state(c, conn_new_cmd);
}",1,1,proto_bin.c,write_bin_response,,false,247,258,write_bin_response,,,19,"void write_bin_response (conn*,void*,int,int,int)"
46297,METHOD,proto_bin.c:<global>,TYPE_DECL,"static void complete_incr_bin(conn *c, char *extbuf) {
    item *it;
    char *key;
    size_t nkey;
    /* Weird magic in add_delta forces me to pad here */
    char tmpbuf[INCR_MAX_STORAGE_LEN];
    uint64_t cas = 0;

    assert(c != NULL);
    protocol_binary_response_incr* rsp = (protocol_binary_response_incr*)c->resp->wbuf;
    protocol_binary_request_incr* req = (void *)extbuf;

    //assert(c->wsize >= sizeof(*rsp));

    /* fix byteorder in the request */
    req->message.body.delta = ntohll(req->message.body.delta);
    req->message.body.initial = ntohll(req->message.body.initial);
    req->message.body.expiration = ntohl(req->message.body.expiration);
    key = binary_get_key(c);
    nkey = c->binary_header.request.keylen;

    if (settings.verbose > 1) {
        int i;
        fprintf(stderr, ""incr "");

        for (i = 0; i < nkey; i++) {
            fprintf(stderr, ""%c"", key[i]);
        }
        fprintf(stderr, "" %lld, %llu, %d\n"",
                (long long)req->mess...",1,16,proto_bin.c,complete_incr_bin,,false,260,357,complete_incr_bin,,,20,"void complete_incr_bin (conn*,char*)"
46814,METHOD,proto_bin.c:<global>,TYPE_DECL,"static void complete_update_bin(conn *c) {
    protocol_binary_response_status eno = PROTOCOL_BINARY_RESPONSE_EINVAL;
    enum store_item_type ret = NOT_STORED;
    assert(c != NULL);

    item *it = c->item;
    pthread_mutex_lock(&c->thread->stats.mutex);
    c->thread->stats.slab_stats[ITEM_clsid(it)].set_cmds++;
    pthread_mutex_unlock(&c->thread->stats.mutex);

    /* We don't actually receive the trailing two characters in the bin
     * protocol, so we're going to just set them here */
    if ((it->it_flags & ITEM_CHUNKED) == 0) {
        *(ITEM_data(it) + it->nbytes - 2) = '\r';
        *(ITEM_data(it) + it->nbytes - 1) = '\n';
    } else {
        assert(c->ritem);
        item_chunk *ch = (item_chunk *) c->ritem;
        if (ch->size == ch->used)
            ch = ch->next;
        assert(ch->size - ch->used >= 2);
        ch->data[ch->used] = '\r';
        ch->data[ch->used + 1] = '\n';
        ch->used += 2;
    }

    ret = store_item(it, c->cmd, c);

#ifdef ENABLE_DTRA...",1,32,proto_bin.c,complete_update_bin,,false,359,439,complete_update_bin,,,21,void complete_update_bin (conn*)
47126,METHOD,proto_bin.c:<global>,TYPE_DECL,"static void write_bin_miss_response(conn *c, char *key, size_t nkey) {
    if (nkey) {
        add_bin_header(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT,
                0, nkey, nkey);
        char *ofs = c->resp->wbuf + sizeof(protocol_binary_response_header);
        memcpy(ofs, key, nkey);
        resp_add_iov(c->resp, ofs, nkey);
        conn_set_state(c, conn_new_cmd);
    } else {
        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT,
                        NULL, 0);
    }
}",1,1,proto_bin.c,write_bin_miss_response,,false,441,453,write_bin_miss_response,,,22,"void write_bin_miss_response (conn*,char*,size_t)"
47173,METHOD,proto_bin.c:<global>,TYPE_DECL,"static void process_bin_get_or_touch(conn *c, char *extbuf) {
    item *it;

    protocol_binary_response_get* rsp = (protocol_binary_response_get*)c->resp->wbuf;
    char* key = binary_get_key(c);
    size_t nkey = c->binary_header.request.keylen;
    int should_touch = (c->cmd == PROTOCOL_BINARY_CMD_TOUCH ||
                        c->cmd == PROTOCOL_BINARY_CMD_GAT ||
                        c->cmd == PROTOCOL_BINARY_CMD_GATK);
    int should_return_key = (c->cmd == PROTOCOL_BINARY_CMD_GETK ||
                             c->cmd == PROTOCOL_BINARY_CMD_GATK);
    int should_return_value = (c->cmd != PROTOCOL_BINARY_CMD_TOUCH);
    bool failed = false;

    if (settings.verbose > 1) {
        fprintf(stderr, ""<%d %s "", c->sfd, should_touch ? ""TOUCH"" : ""GET"");
        if (fwrite(key, 1, nkey, stderr)) {}
        fputc('\n', stderr);
    }

    if (should_touch) {
        protocol_binary_request_touch *t = (void *)extbuf;
        time_t exptime = ntohl(t->message.body.expiration);

  ...",1,36,proto_bin.c,process_bin_get_or_touch,,false,455,603,process_bin_get_or_touch,,,23,"void process_bin_get_or_touch (conn*,char*)"
47791,METHOD,proto_bin.c:<global>,TYPE_DECL,"static void process_bin_stat(conn *c) {
    char *subcommand = binary_get_key(c);
    size_t nkey = c->binary_header.request.keylen;

    if (settings.verbose > 1) {
        int ii;
        fprintf(stderr, ""<%d STATS "", c->sfd);
        for (ii = 0; ii < nkey; ++ii) {
            fprintf(stderr, ""%c"", subcommand[ii]);
        }
        fprintf(stderr, ""\n"");
    }

    if (nkey == 0) {
        /* request all statistics */
        server_stats(&append_stats, c);
        (void)get_stats(NULL, 0, &append_stats, c);
    } else if (strncmp(subcommand, ""reset"", 5) == 0) {
        stats_reset();
    } else if (strncmp(subcommand, ""settings"", 8) == 0) {
        process_stat_settings(&append_stats, c);
    } else if (strncmp(subcommand, ""detail"", 6) == 0) {
        char *subcmd_pos = subcommand + 6;
        if (strncmp(subcmd_pos, "" dump"", 5) == 0) {
            int len;
            char *dump_buf = stats_prefix_dump(&len);
            if (dump_buf == NULL || len <= 0) {
                out_...",1,1,proto_bin.c,process_bin_stat,,false,605,671,process_bin_stat,,,24,void process_bin_stat (conn*)
48077,METHOD,proto_bin.c:<global>,TYPE_DECL,"static void init_sasl_conn(conn *c) {
    assert(c);
    /* should something else be returned? */
    if (!settings.sasl)
        return;

    c->authenticated = false;

    if (!c->sasl_conn) {
        int result=sasl_server_new(""memcached"",
                                   NULL,
                                   my_sasl_hostname[0] ? my_sasl_hostname : NULL,
                                   NULL, NULL,
                                   NULL, 0, &c->sasl_conn);
        if (result != SASL_OK) {
            if (settings.verbose) {
                fprintf(stderr, ""Failed to initialize SASL conn.\n"");
            }
            c->sasl_conn = NULL;
        }
    }
}",1,19,proto_bin.c,init_sasl_conn,,false,673,694,init_sasl_conn,,,25,void init_sasl_conn (conn*)
48128,METHOD,proto_bin.c:<global>,TYPE_DECL,"static void bin_list_sasl_mechs(conn *c) {
    // Guard against a disabled SASL.
    if (!settings.sasl) {
        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND, NULL,
                        c->binary_header.request.bodylen
                        - c->binary_header.request.keylen);
        return;
    }

    init_sasl_conn(c);
    const char *result_string = NULL;
    unsigned int string_length = 0;
    int result=sasl_listmech(c->sasl_conn, NULL,
                             """",   /* What to prepend the string with */
                             "" "",  /* What to separate mechanisms with */
                             """",   /* What to append to the string */
                             &result_string, &string_length,
                             NULL);
    if (result != SASL_OK) {
        /* Perhaps there's a better error for this... */
        if (settings.verbose) {
            fprintf(stderr, ""Failed to list SASL mechanisms.\n"");
        }
        write_bin_err...",1,15,proto_bin.c,bin_list_sasl_mechs,,false,696,723,bin_list_sasl_mechs,,,26,void bin_list_sasl_mechs (conn*)
48204,METHOD,proto_bin.c:<global>,TYPE_DECL,"static void process_bin_sasl_auth(conn *c) {
    // Guard for handling disabled SASL on the server.
    if (!settings.sasl) {
        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND, NULL,
                        c->binary_header.request.bodylen
                        - c->binary_header.request.keylen);
        return;
    }

    assert(c->binary_header.request.extlen == 0);

    int nkey = c->binary_header.request.keylen;
    int vlen = c->binary_header.request.bodylen - nkey;

    if (nkey > MAX_SASL_MECH_LEN) {
        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_EINVAL, NULL, vlen);
        conn_set_state(c, conn_swallow);
        return;
    }

    char *key = binary_get_key(c);
    assert(key);

    item *it = item_alloc(key, nkey, 0, 0, vlen+2);

    /* Can't use a chunked item for SASL authentication. */
    if (it == 0 || (it->it_flags & ITEM_CHUNKED)) {
        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, NULL, vlen);
        conn_set_state(c, conn_swall...",1,15,proto_bin.c,process_bin_sasl_auth,,false,725,765,process_bin_sasl_auth,,,27,void process_bin_sasl_auth (conn*)
48385,METHOD,proto_bin.c:<global>,TYPE_DECL,"static void process_bin_complete_sasl_auth(conn *c) {
    assert(settings.sasl);
    const char *out = NULL;
    unsigned int outlen = 0;

    assert(c->item);
    init_sasl_conn(c);

    int nkey = c->binary_header.request.keylen;
    int vlen = c->binary_header.request.bodylen - nkey;

    if (nkey > ((item*) c->item)->nkey) {
        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_EINVAL, NULL, vlen);
        conn_set_state(c, conn_swallow);
        return;
    }

    char mech[nkey+1];
    memcpy(mech, ITEM_key((item*)c->item), nkey);
    mech[nkey] = 0x00;

    if (settings.verbose)
        fprintf(stderr, ""mech:  ``%s'' with %d bytes of data\n"", mech, vlen);

    const char *challenge = vlen == 0 ? NULL : ITEM_data((item*) c->item);

    if (vlen > ((item*) c->item)->nbytes) {
        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_EINVAL, NULL, vlen);
        conn_set_state(c, conn_swallow);
        return;
    }

    int result=-1;

    switch (c->cmd) {
    case PROTOCOL_BINARY_CMD...",1,17,proto_bin.c,process_bin_complete_sasl_auth,,false,767,860,process_bin_complete_sasl_auth,,,28,void process_bin_complete_sasl_auth (conn*)
48779,METHOD,proto_bin.c:<global>,TYPE_DECL,"static bool authenticated(conn *c) {
    assert(settings.sasl);
    bool rv = false;

    switch (c->cmd) {
    case PROTOCOL_BINARY_CMD_SASL_LIST_MECHS: /* FALLTHROUGH */
    case PROTOCOL_BINARY_CMD_SASL_AUTH:       /* FALLTHROUGH */
    case PROTOCOL_BINARY_CMD_SASL_STEP:       /* FALLTHROUGH */
    case PROTOCOL_BINARY_CMD_VERSION:         /* FALLTHROUGH */
        rv = true;
        break;
    default:
        rv = c->authenticated;
    }

    if (settings.verbose > 1) {
        fprintf(stderr, ""authenticated() in cmd 0x%02x is %s\n"",
                c->cmd, rv ? ""true"" : ""false"");
    }

    return rv;
}",1,1,proto_bin.c,authenticated,,false,862,883,authenticated,,,29,bool authenticated (conn*)
48834,METHOD,proto_bin.c:<global>,TYPE_DECL,"static void dispatch_bin_command(conn *c, char *extbuf) {
    int protocol_error = 0;

    uint8_t extlen = c->binary_header.request.extlen;
    uint16_t keylen = c->binary_header.request.keylen;
    uint32_t bodylen = c->binary_header.request.bodylen;

    if (keylen > bodylen || keylen + extlen > bodylen) {
        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND, NULL, 0);
        c->close_after_write = true;
        return;
    }

    if (settings.sasl && !authenticated(c)) {
        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_AUTH_ERROR, NULL, 0);
        c->close_after_write = true;
        return;
    }

    MEMCACHED_PROCESS_COMMAND_START(c->sfd, c->rcurr, c->rbytes);
    c->noreply = true;

    /* binprot supports 16bit keys, but internals are still 8bit */
    if (keylen > KEY_MAX_LENGTH) {
        handle_binary_protocol_error(c);
        return;
    }

    switch (c->cmd) {
    case PROTOCOL_BINARY_CMD_SETQ:
        c->cmd = PROTOCOL_BINARY_CMD_SET;
        bre...",1,4,proto_bin.c,dispatch_bin_command,,false,885,1076,dispatch_bin_command,,,30,"void dispatch_bin_command (conn*,char*)"
49415,METHOD,proto_bin.c:<global>,TYPE_DECL,"static void process_bin_update(conn *c, char *extbuf) {
    char *key;
    int nkey;
    int vlen;
    item *it;
    protocol_binary_request_set* req = (void *)extbuf;

    assert(c != NULL);

    key = binary_get_key(c);
    nkey = c->binary_header.request.keylen;

    /* fix byteorder in the request */
    req->message.body.flags = ntohl(req->message.body.flags);
    req->message.body.expiration = ntohl(req->message.body.expiration);

    vlen = c->binary_header.request.bodylen - (nkey + c->binary_header.request.extlen);

    if (settings.verbose > 1) {
        int ii;
        if (c->cmd == PROTOCOL_BINARY_CMD_ADD) {
            fprintf(stderr, ""<%d ADD "", c->sfd);
        } else if (c->cmd == PROTOCOL_BINARY_CMD_SET) {
            fprintf(stderr, ""<%d SET "", c->sfd);
        } else {
            fprintf(stderr, ""<%d REPLACE "", c->sfd);
        }
        for (ii = 0; ii < nkey; ++ii) {
            fprintf(stderr, ""%c"", key[ii]);
        }

        fprintf(stderr, "" Value len is %d...",1,8,proto_bin.c,process_bin_update,,false,1078,1185,process_bin_update,,,31,"void process_bin_update (conn*,char*)"
49890,METHOD,proto_bin.c:<global>,TYPE_DECL,"static void process_bin_append_prepend(conn *c) {
    char *key;
    int nkey;
    int vlen;
    item *it;

    assert(c != NULL);

    key = binary_get_key(c);
    nkey = c->binary_header.request.keylen;
    vlen = c->binary_header.request.bodylen - nkey;

    if (settings.verbose > 1) {
        fprintf(stderr, ""Value len is %d\n"", vlen);
    }

    if (settings.detail_enabled) {
        stats_prefix_record_set(key, nkey);
    }

    it = item_alloc(key, nkey, 0, 0, vlen+2);

    if (it == 0) {
        if (! item_size_ok(nkey, 0, vlen + 2)) {
            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_E2BIG, NULL, vlen);
        } else {
            out_of_memory(c, ""SERVER_ERROR Out of memory allocating item"");
            /* OOM calls eat the swallow value. Add here. */
            c->sbytes = vlen;
        }
        /* swallow the data line */
        conn_set_state(c, conn_swallow);
        return;
    }

    ITEM_set_cas(it, c->binary_header.request.cas);

    switch (c->cmd) {
  ...",1,4,proto_bin.c,process_bin_append_prepend,,false,1187,1248,process_bin_append_prepend,,,32,void process_bin_append_prepend (conn*)
50104,METHOD,proto_bin.c:<global>,TYPE_DECL,"static void process_bin_flush(conn *c, char *extbuf) {
    time_t exptime = 0;
    protocol_binary_request_flush* req = (void *)extbuf;
    rel_time_t new_oldest = 0;

    if (!settings.flush_enabled) {
      // flush_all is not allowed but we log it on stats
      write_bin_error(c, PROTOCOL_BINARY_RESPONSE_AUTH_ERROR, NULL, 0);
      return;
    }

    if (c->binary_header.request.extlen == sizeof(req->message.body)) {
        exptime = ntohl(req->message.body.expiration);
    }

    if (exptime > 0) {
        new_oldest = realtime(exptime);
    } else {
        new_oldest = current_time;
    }
    if (settings.use_cas) {
        settings.oldest_live = new_oldest - 1;
        if (settings.oldest_live <= current_time)
            settings.oldest_cas = get_cas_id();
    } else {
        settings.oldest_live = new_oldest;
    }

    pthread_mutex_lock(&c->thread->stats.mutex);
    c->thread->stats.flush_cmds++;
    pthread_mutex_unlock(&c->thread->stats.mutex);

    write_bin_respons...",1,1,proto_bin.c,process_bin_flush,,false,1250,1283,process_bin_flush,,,33,"void process_bin_flush (conn*,char*)"
50239,METHOD,proto_bin.c:<global>,TYPE_DECL,"static void process_bin_delete(conn *c) {
    item *it;
    uint32_t hv;

    assert(c != NULL);
    char* key = binary_get_key(c);
    size_t nkey = c->binary_header.request.keylen;

    if (settings.verbose > 1) {
        int ii;
        fprintf(stderr, ""Deleting "");
        for (ii = 0; ii < nkey; ++ii) {
            fprintf(stderr, ""%c"", key[ii]);
        }
        fprintf(stderr, ""\n"");
    }

    if (settings.detail_enabled) {
        stats_prefix_record_delete(key, nkey);
    }

    it = item_get_locked(key, nkey, c, DONT_UPDATE, &hv);
    if (it) {
        uint64_t cas = c->binary_header.request.cas;
        if (cas == 0 || cas == ITEM_get_cas(it)) {
            MEMCACHED_COMMAND_DELETE(c->sfd, ITEM_key(it), it->nkey);
            pthread_mutex_lock(&c->thread->stats.mutex);
            c->thread->stats.slab_stats[ITEM_clsid(it)].delete_hits++;
            pthread_mutex_unlock(&c->thread->stats.mutex);
            do_item_unlink(it, hv);
            STORAGE_delete(c->thread-...",1,39,proto_bin.c,process_bin_delete,,false,1285,1328,process_bin_delete,,,34,void process_bin_delete (conn*)
50449,METHOD,proto_bin.h:<global>,TYPE_DECL,<global>,1,6,proto_bin.h,proto_bin.h:<global>,,false,1,10,<global>,,,1,
50451,METHOD,proto_bin.h:<global>,TYPE_DECL,int try_read_command_binary(conn *c);,5,36,proto_bin.h,try_read_command_binary,,false,5,5,try_read_command_binary,,,1,int try_read_command_binary (conn*)
50456,METHOD,proto_bin.h:<global>,TYPE_DECL,void complete_nread_binary(conn *c);,6,35,proto_bin.h,complete_nread_binary,,false,6,6,complete_nread_binary,,,2,void complete_nread_binary (conn*)
50461,METHOD,proto_bin.h:<global>,TYPE_DECL,"void write_bin_error(conn *c, protocol_binary_response_status err,
                            const char *errstr, int swallow);",6,60,proto_bin.h,write_bin_error,,false,7,8,write_bin_error,,,3,"void write_bin_error (conn*,protocol_binary_response_status,char*,int)"
50474,METHOD,proto_proxy.c:<global>,TYPE_DECL,<global>,1,1,proto_proxy.c,proto_proxy.c:<global>,,false,1,921,<global>,,,1,
50476,METHOD,proto_proxy.c:<global>,TYPE_DECL,"static void proxy_process_command(conn *c, char *command, size_t cmdlen, bool multiget);",13,87,proto_proxy.c,proxy_process_command,,false,15,15,proxy_process_command,,,1,"void proxy_process_command (conn*,char*,size_t,bool)"
50484,METHOD,proto_proxy.c:<global>,TYPE_DECL,"static void mcp_queue_io(conn *c, mc_resp *resp, int coro_ref, lua_State *Lc);",13,77,proto_proxy.c,mcp_queue_io,,false,16,16,mcp_queue_io,,,2,"void mcp_queue_io (conn*,mc_resp*,int,lua_State*)"
50492,METHOD,proto_proxy.c:<global>,TYPE_DECL,"static void proxy_out_errstring(mc_resp *resp, const char *str);",13,63,proto_proxy.c,proxy_out_errstring,,false,17,17,proxy_out_errstring,,,3,"void proxy_out_errstring (mc_resp*,char*)"
50498,METHOD,proto_proxy.c:<global>,TYPE_DECL,"void proxy_stats(ADD_STAT add_stats, conn *c) {
    if (!settings.proxy_enabled) {
       return;
    }
    proxy_ctx_t *ctx = settings.proxy_ctx;
    STAT_L(ctx);

    APPEND_STAT(""proxy_config_reloads"", ""%llu"", (unsigned long long)ctx->global_stats.config_reloads);
    APPEND_STAT(""proxy_config_reload_fails"", ""%llu"", (unsigned long long)ctx->global_stats.config_reload_fails);
    APPEND_STAT(""proxy_backend_total"", ""%llu"", (unsigned long long)ctx->global_stats.backend_total);
    APPEND_STAT(""proxy_backend_marked_bad"", ""%llu"", (unsigned long long)ctx->global_stats.backend_marked_bad);
    APPEND_STAT(""proxy_backend_failed"", ""%llu"", (unsigned long long)ctx->global_stats.backend_failed);
    STAT_UL(ctx);
}",1,4,proto_proxy.c,proxy_stats,,false,24,37,proxy_stats,,,4,"void proxy_stats (ADD_STAT,conn*)"
50613,METHOD,proto_proxy.c:<global>,TYPE_DECL,"void process_proxy_stats(ADD_STAT add_stats, conn *c) {
    char key_str[STAT_KEY_LEN];
    struct proxy_int_stats istats = {0};

    if (!settings.proxy_enabled) {
        return;
    }
    proxy_ctx_t *ctx = settings.proxy_ctx;
    STAT_L(ctx);

    // prepare aggregated counters.
    struct proxy_user_stats *us = &ctx->user_stats;
    uint64_t counters[us->num_stats];
    memset(counters, 0, sizeof(counters));

    // aggregate worker thread counters.
    for (int x = 0; x < settings.num_threads; x++) {
        LIBEVENT_THREAD *t = get_worker_thread(x);
        struct proxy_user_stats *tus = t->proxy_user_stats;
        struct proxy_int_stats *is = t->proxy_int_stats;
        WSTAT_L(t);
        for (int i = 0; i < CMD_FINAL; i++) {
            istats.counters[i] += is->counters[i];
        }
        if (tus && tus->num_stats >= us->num_stats) {
            for (int i = 0; i < us->num_stats; i++) {
                counters[i] += tus->counters[i];
            }
        }
        W...",1,17,proto_proxy.c,process_proxy_stats,,false,39,99,process_proxy_stats,,,5,"void process_proxy_stats (ADD_STAT,conn*)"
51136,METHOD,proto_proxy.c:<global>,TYPE_DECL,"void proxy_init(bool use_uring) {
    proxy_ctx_t *ctx = calloc(1, sizeof(proxy_ctx_t));
    settings.proxy_ctx = ctx;
    ctx->use_uring = use_uring;

    pthread_mutex_init(&ctx->config_lock, NULL);
    pthread_cond_init(&ctx->config_cond, NULL);
    pthread_mutex_init(&ctx->worker_lock, NULL);
    pthread_cond_init(&ctx->worker_cond, NULL);
    pthread_mutex_init(&ctx->manager_lock, NULL);
    pthread_cond_init(&ctx->manager_cond, NULL);
    pthread_mutex_init(&ctx->stats_lock, NULL);

    // FIXME (v2): default defines.
    ctx->tunables.tcp_keepalive = false;
    ctx->tunables.backend_failure_limit = 3;
    ctx->tunables.connect.tv_sec = 5;
    ctx->tunables.retry.tv_sec = 3;
    ctx->tunables.read.tv_sec = 3;
#ifdef HAVE_LIBURING
    ctx->tunables.connect_ur.tv_sec = 5;
    ctx->tunables.retry_ur.tv_sec = 3;
    ctx->tunables.read_ur.tv_sec = 3;
#endif // HAVE_LIBURING

    STAILQ_INIT(&ctx->manager_head);
    lua_State *L = luaL_newstate();
    ctx->proxy_state = L;
    luaL_...",1,4,proto_proxy.c,proxy_init,,false,103,182,proxy_init,,,6,void proxy_init (bool)
51413,METHOD,proto_proxy.c:<global>,TYPE_DECL,"void proxy_thread_init(LIBEVENT_THREAD *thr) {
    // Create the hook table.
    thr->proxy_hooks = calloc(CMD_SIZE, sizeof(struct proxy_hook));
    if (thr->proxy_hooks == NULL) {
        fprintf(stderr, ""Failed to allocate proxy hooks\n"");
        exit(EXIT_FAILURE);
    }
    thr->proxy_int_stats = calloc(1, sizeof(struct proxy_int_stats));
    if (thr->proxy_int_stats == NULL) {
        fprintf(stderr, ""Failed to allocate proxy thread stats\n"");
        exit(EXIT_FAILURE);
    }

    // Initialize the lua state.
    lua_State *L = luaL_newstate();
    thr->L = L;
    luaL_openlibs(L);
    proxy_register_libs(thr, L);
    // TODO: srand on time? do we need to bother?
    for (int x = 0; x < 3; x++) {
        thr->proxy_rng[x] = rand();
    }

    // kick off the configuration.
    if (proxy_thread_loadconf(thr) != 0) {
        exit(EXIT_FAILURE);
    }
}",1,1,proto_proxy.c,proxy_thread_init,,false,185,212,proxy_thread_init,,,7,void proxy_thread_init (LIBEVENT_THREAD*)
51499,METHOD,proto_proxy.c:<global>,TYPE_DECL,"void proxy_submit_cb(io_queue_t *q) {
    proxy_event_thread_t *e = ((proxy_ctx_t *)q->ctx)->proxy_threads;
    io_pending_proxy_t *p = q->stack_ctx;
    io_head_t head;
    STAILQ_INIT(&head);

    // NOTE: responses get returned in the correct order no matter what, since
    // mc_resp's are linked.
    // we just need to ensure stuff is parsed off the backend in the correct
    // order.
    // So we can do with a single list here, but we need to repair the list as
    // responses are parsed. (in the req_remaining-- section)
    // TODO (v2):
    // - except we can't do that because the deferred IO stack isn't
    // compatible with queue.h.
    // So for now we build the secondary list with an STAILQ, which
    // can be transplanted/etc.
    while (p) {
        // insert into tail so head is oldest request.
        STAILQ_INSERT_TAIL(&head, p, io_next);
        if (p->is_await) {
            // need to not count await objects multiple times.
            if (p->await_first) {
 ...",1,4,proto_proxy.c,proxy_submit_cb,,false,215,274,proxy_submit_cb,,,8,void proxy_submit_cb (io_queue_t*)
51697,METHOD,proto_proxy.c:<global>,TYPE_DECL,"void proxy_complete_cb(io_queue_t *q) {
    // empty/unused.
}",1,1,proto_proxy.c,proxy_complete_cb,,false,276,278,proxy_complete_cb,,,9,void proxy_complete_cb (io_queue_t*)
51702,METHOD,proto_proxy.c:<global>,TYPE_DECL,"void proxy_return_cb(io_pending_t *pending) {
    io_pending_proxy_t *p = (io_pending_proxy_t *)pending;
    if (p->is_await) {
        mcplib_await_return(p);
    } else {
        lua_State *Lc = p->coro;

        // in order to resume we need to remove the objects that were
        // originally returned
        // what's currently on the top of the stack is what we want to keep.
        lua_rotate(Lc, 1, 1);
        // We kept the original results from the yield so lua would not
        // collect them in the meantime. We can drop those now.
        lua_settop(Lc, 1);

        // p can be freed/changed from the call below, so fetch the queue now.
        io_queue_t *q = conn_io_queue_get(p->c, p->io_queue_type);
        conn *c = p->c;
        proxy_run_coroutine(Lc, p->resp, p, c);

        q->count--;
        if (q->count == 0) {
            // call re-add directly since we're already in the worker thread.
            conn_worker_readd(c);
        }
    }
}",1,1,proto_proxy.c,proxy_return_cb,,false,282,308,proxy_return_cb,,,10,void proxy_return_cb (io_pending_t*)
51771,METHOD,proto_proxy.c:<global>,TYPE_DECL,"void proxy_finalize_cb(io_pending_t *pending) {
    io_pending_proxy_t *p = (io_pending_proxy_t *)pending;

    // release our coroutine reference.
    // TODO (v2): coroutines are reusable in lua 5.4. we can stack this onto a freelist
    // after a lua_resetthread(Lc) call.
    if (p->coro_ref) {
        // Note: lua registry is the same for main thread or a coroutine.
        luaL_unref(p->coro, LUA_REGISTRYINDEX, p->coro_ref);
    }
    return;
}",1,1,proto_proxy.c,proxy_finalize_cb,,false,313,324,proxy_finalize_cb,,,11,void proxy_finalize_cb (io_pending_t*)
51796,METHOD,proto_proxy.c:<global>,TYPE_DECL,"int try_read_command_proxy(conn *c) {
    char *el, *cont;

    if (c->rbytes == 0)
        return 0;

    el = memchr(c->rcurr, '\n', c->rbytes);
    if (!el) {
        if (c->rbytes > 1024) {
            /*
             * We didn't have a '\n' in the first k. This _has_ to be a
             * large multiget, if not we should just nuke the connection.
             */
            char *ptr = c->rcurr;
            while (*ptr == ' ') { /* ignore leading whitespaces */
                ++ptr;
            }

            if (ptr - c->rcurr > 100 ||
                (strncmp(ptr, ""get "", 4) && strncmp(ptr, ""gets "", 5))) {

                conn_set_state(c, conn_closing);
                return 1;
            }

            // ASCII multigets are unbound, so our fixed size rbuf may not
            // work for this particular workload... For backcompat we'll use a
            // malloc/realloc/free routine just for this.
            if (!c->rbuf_malloced) {
                if (!rbuf_switch_t...",1,56,proto_proxy.c,try_read_command_proxy,,false,326,378,try_read_command_proxy,,,12,int try_read_command_proxy (conn*)
51950,METHOD,proto_proxy.c:<global>,TYPE_DECL,"void proxy_cleanup_conn(conn *c) {
    assert(c->proxy_coro_ref != 0);
    LIBEVENT_THREAD *thr = c->thread;
    lua_State *L = thr->L;
    luaL_unref(L, LUA_REGISTRYINDEX, c->proxy_coro_ref);
    c->proxy_coro_ref = 0;
    WSTAT_DECR(c, proxy_req_active, 1);
}",1,4,proto_proxy.c,proxy_cleanup_conn,,false,382,389,proxy_cleanup_conn,,,13,void proxy_cleanup_conn (conn*)
52015,METHOD,proto_proxy.c:<global>,TYPE_DECL,"void complete_nread_proxy(conn *c) {
    assert(c != NULL);

    LIBEVENT_THREAD *thr = c->thread;
    lua_State *L = thr->L;

    if (c->proxy_coro_ref == 0) {
        complete_nread_ascii(c);
        return;
    }

    conn_set_state(c, conn_new_cmd);

    // Grab our coroutine.
    lua_rawgeti(L, LUA_REGISTRYINDEX, c->proxy_coro_ref);
    luaL_unref(L, LUA_REGISTRYINDEX, c->proxy_coro_ref);
    lua_State *Lc = lua_tothread(L, -1);
    mcp_request_t *rq = luaL_checkudata(Lc, -1, ""mcp.request"");

    // validate the data chunk.
    if (strncmp((char *)c->item + rq->pr.vlen - 2, ""\r\n"", 2) != 0) {
        lua_settop(L, 0); // clear anything remaining on the main thread.
        // FIXME (v2): need to set noreply false if mset_res, but that's kind
        // of a weird hack to begin with. Evaluate how to best do that here.
        out_string(c, ""CLIENT_ERROR bad data chunk"");
        return;
    }

    // We move ownership of the c->item buffer from the connection to the
    // reque...",1,1,proto_proxy.c,complete_nread_proxy,,false,392,433,complete_nread_proxy,,,14,void complete_nread_proxy (conn*)
52138,METHOD,proto_proxy.c:<global>,TYPE_DECL,"void proxy_lua_error(lua_State *L, const char *s) {
    lua_pushstring(L, s);
    lua_error(L);
}",1,1,proto_proxy.c,proxy_lua_error,,false,438,441,proxy_lua_error,,,15,"void proxy_lua_error (lua_State*,char*)"
52149,METHOD,proto_proxy.c:<global>,TYPE_DECL,"void proxy_lua_ferror(lua_State *L, const char *fmt, ...) {
    va_list ap;
    va_start(ap, fmt);
    lua_pushfstring(L, fmt, ap);
    va_end(ap);
    lua_error(L);
}",1,1,proto_proxy.c,proxy_lua_ferror,,false,443,449,proxy_lua_ferror,,,16,"void proxy_lua_ferror (lua_State*,char*...)"
52167,METHOD,proto_proxy.c:<global>,TYPE_DECL,"static void proxy_out_errstring(mc_resp *resp, const char *str) {
    size_t len;
    const static char error_prefix[] = ""SERVER_ERROR "";
    const static int error_prefix_len = sizeof(error_prefix) - 1;

    assert(resp != NULL);

    resp_reset(resp);
    // avoid noreply since we're throwing important errors.

    // Fill response object with static string.
    len = strlen(str);
    if ((len + error_prefix_len + 2) > WRITE_BUFFER_SIZE) {
        /* ought to be always enough. just fail for simplicity */
        str = ""SERVER_ERROR output line too long"";
        len = strlen(str);
    }

    char *w = resp->wbuf;
    memcpy(w, error_prefix, error_prefix_len);
    w += error_prefix_len;

    memcpy(w, str, len);
    w += len;

    memcpy(w, ""\r\n"", 2);
    resp_add_iov(resp, resp->wbuf, len + error_prefix_len + 2);
    return;
}",1,39,proto_proxy.c,proxy_out_errstring,,false,452,480,proxy_out_errstring,,,17,"void proxy_out_errstring (mc_resp*,char*)"
52248,METHOD,proto_proxy.c:<global>,TYPE_DECL,"static void _set_noreply_mode(mc_resp *resp, mcp_resp_t *r) {
    switch (r->mode) {
        case RESP_MODE_NORMAL:
            break;
        case RESP_MODE_NOREPLY:
            // ascii noreply only threw egregious errors to client
            if (r->status == MCMC_OK) {
                resp->skip = true;
            }
            break;
        case RESP_MODE_METAQUIET:
            if (r->resp.code == MCMC_CODE_MISS) {
                resp->skip = true;
            } else if (r->cmd != CMD_MG && r->resp.code == MCMC_CODE_OK) {
                // FIXME (v2): mcmc's parser needs to help us out a bit more
                // here.
                // This is a broken case in the protocol though; quiet mode
                // ignores HD for mutations but not get.
                resp->skip = true;
            }
            break;
        default:
            assert(1 == 0);
    }
}",1,29,proto_proxy.c,_set_noreply_mode,,false,486,510,_set_noreply_mode,,,18,"void _set_noreply_mode (mc_resp*,mcp_resp_t*)"
52327,METHOD,proto_proxy.c:<global>,TYPE_DECL,"int proxy_run_coroutine(lua_State *Lc, mc_resp *resp, io_pending_proxy_t *p, conn *c) {
    int nresults = 0;
    int cores = lua_resume(Lc, NULL, 1, &nresults);
    size_t rlen = 0;

    if (cores == LUA_OK) {
        WSTAT_DECR(c, proxy_req_active, 1);
        int type = lua_type(Lc, 1);
        if (type == LUA_TUSERDATA) {
            mcp_resp_t *r = luaL_checkudata(Lc, 1, ""mcp.response"");
            _set_noreply_mode(resp, r);
            if (r->buf) {
                // response set from C.
                // FIXME (v2): write_and_free() ? it's a bit wrong for here.
                resp->write_and_free = r->buf;
                resp_add_iov(resp, r->buf, r->blen);
                r->buf = NULL;
            } else if (lua_getiuservalue(Lc, 1, 1) != LUA_TNIL) {
                // uservalue slot 1 is pre-created, so we get TNIL instead of
                // TNONE when nothing was set into it.
                const char *s = lua_tolstring(Lc, -1, &rlen);
                size_t l =...",1,8,proto_proxy.c,proxy_run_coroutine,,false,523,617,proxy_run_coroutine,,,19,"int proxy_run_coroutine (lua_State*,mc_resp*,io_pending_proxy_t*,conn*)"
52764,METHOD,proto_proxy.c:<global>,TYPE_DECL,"static void proxy_process_command(conn *c, char *command, size_t cmdlen, bool multiget) {
    assert(c != NULL);
    LIBEVENT_THREAD *thr = c->thread;
    struct proxy_hook *hooks = thr->proxy_hooks;
    lua_State *L = thr->L;
    mcp_parser_t pr = {0};

    // Avoid doing resp_start() here, instead do it a bit later or as-needed.
    // This allows us to hop over to the internal text protocol parser, which
    // also calls resp_start().
    // Tighter integration later should obviate the need for this, it is not a
    // permanent solution.
    int ret = process_request(&pr, command, cmdlen);
    if (ret != 0) {
        WSTAT_INCR(c, proxy_conn_errors, 1);
        if (!resp_start(c)) {
            conn_set_state(c, conn_closing);
            return;
        }
        proxy_out_errstring(c->resp, ""parsing request"");
        if (ret == -2) {
            // Kill connection on more critical parse failure.
            conn_set_state(c, conn_closing);
        }
        return;
    }

  ...",1,8,proto_proxy.c,proxy_process_command,,false,619,803,proxy_process_command,,,20,"void proxy_process_command (conn*,char*,size_t,bool)"
53389,METHOD,proto_proxy.c:<global>,TYPE_DECL,"static void mcp_queue_io(conn *c, mc_resp *resp, int coro_ref, lua_State *Lc) {
    io_queue_t *q = conn_io_queue_get(c, IO_QUEUE_PROXY);

    // stack: request, hash selector. latter just to hold a reference.

    mcp_request_t *rq = luaL_checkudata(Lc, -1, ""mcp.request"");
    mcp_backend_t *be = rq->be;

    // Then we push a response object, which we'll re-use later.
    // reserve one uservalue for a lua-supplied response.
    mcp_resp_t *r = lua_newuserdatauv(Lc, sizeof(mcp_resp_t), 1);
    // FIXME (v2): is this memset still necessary? I was using it for
    // debugging.
    memset(r, 0, sizeof(mcp_resp_t));
    r->buf = NULL;
    r->blen = 0;
    // Set noreply mode.
    // TODO (v2): the response ""inherits"" the request's noreply mode, which isn't
    // strictly correct; we should inherit based on the request that spawned
    // the coroutine but the structure doesn't allow that yet.
    // Should also be able to settle this exact mode from the parser so we
    // don't hav...",1,41,proto_proxy.c,mcp_queue_io,,false,809,894,mcp_queue_io,,,21,"void mcp_queue_io (conn*,mc_resp*,int,lua_State*)"
53714,METHOD,proto_proxy.c:<global>,TYPE_DECL,"__attribute__((unused)) void dump_stack(lua_State *L) {
    int top = lua_gettop(L);
    int i = 1;
    fprintf(stderr, ""--TOP OF STACK [%d]\n"", top);
    for (; i < top + 1; i++) {
        int type = lua_type(L, i);
        // lets find the metatable of this userdata to identify it.
        if (lua_getmetatable(L, i) != 0) {
            lua_pushstring(L, ""__name"");
            if (lua_rawget(L, -2) != LUA_TNIL) {
                fprintf(stderr, ""--|%d| [%s] (%s)\n"", i, lua_typename(L, type), lua_tostring(L, -1));
                lua_pop(L, 2);
                continue;
            }
            lua_pop(L, 2);
        }
        if (type == LUA_TSTRING) {
            fprintf(stderr, ""--|%d| [%s] | %s\n"", i, lua_typename(L, type), lua_tostring(L, i));
        } else {
            fprintf(stderr, ""--|%d| [%s]\n"", i, lua_typename(L, type));
        }
    }
    fprintf(stderr, ""-----------------\n"");
}",1,1,proto_proxy.c,dump_stack,,false,897,920,dump_stack,,,22,void dump_stack (lua_State*)
53814,METHOD,proto_proxy.h:<global>,TYPE_DECL,<global>,1,6,proto_proxy.h,proto_proxy.h:<global>,,false,1,27,<global>,,,1,
53816,METHOD,proto_proxy.h:<global>,TYPE_DECL,"void proxy_stats(ADD_STAT add_stats, conn *c);",6,45,proto_proxy.h,proxy_stats,,false,4,4,proxy_stats,,,1,"void proxy_stats (ADD_STAT,conn*)"
53822,METHOD,proto_proxy.h:<global>,TYPE_DECL,"void process_proxy_stats(ADD_STAT add_stats, conn *c);",6,53,proto_proxy.h,process_proxy_stats,,false,5,5,process_proxy_stats,,,2,"void process_proxy_stats (ADD_STAT,conn*)"
53828,METHOD,proto_proxy.h:<global>,TYPE_DECL,int try_read_command_proxy(conn *c);,5,35,proto_proxy.h,try_read_command_proxy,,false,8,8,try_read_command_proxy,,,3,int try_read_command_proxy (conn*)
53833,METHOD,proto_proxy.h:<global>,TYPE_DECL,void complete_nread_proxy(conn *c);,6,34,proto_proxy.h,complete_nread_proxy,,false,9,9,complete_nread_proxy,,,4,void complete_nread_proxy (conn*)
53838,METHOD,proto_proxy.h:<global>,TYPE_DECL,void proxy_cleanup_conn(conn *c);,6,32,proto_proxy.h,proxy_cleanup_conn,,false,10,10,proxy_cleanup_conn,,,5,void proxy_cleanup_conn (conn*)
53843,METHOD,proto_proxy.h:<global>,TYPE_DECL,void proxy_thread_init(LIBEVENT_THREAD *thr);,6,44,proto_proxy.h,proxy_thread_init,,false,11,11,proxy_thread_init,,,6,void proxy_thread_init (LIBEVENT_THREAD*)
53848,METHOD,proto_proxy.h:<global>,TYPE_DECL,void proxy_init(bool proxy_uring);,6,33,proto_proxy.h,proxy_init,,false,12,12,proxy_init,,,7,void proxy_init (bool)
53853,METHOD,proto_proxy.h:<global>,TYPE_DECL,void proxy_start_reload(void *arg);,6,34,proto_proxy.h,proxy_start_reload,,false,15,15,proxy_start_reload,,,8,void proxy_start_reload (void*)
53858,METHOD,proto_proxy.h:<global>,TYPE_DECL,int proxy_load_config(void *arg);,5,32,proto_proxy.h,proxy_load_config,,false,16,16,proxy_load_config,,,9,int proxy_load_config (void*)
53863,METHOD,proto_proxy.h:<global>,TYPE_DECL,"void proxy_worker_reload(void *arg, LIBEVENT_THREAD *thr);",6,57,proto_proxy.h,proxy_worker_reload,,false,17,17,proxy_worker_reload,,,10,"void proxy_worker_reload (void*,LIBEVENT_THREAD*)"
53869,METHOD,proto_proxy.h:<global>,TYPE_DECL,void proxy_submit_cb(io_queue_t *q);,6,35,proto_proxy.h,proxy_submit_cb,,false,19,19,proxy_submit_cb,,,11,void proxy_submit_cb (io_queue_t*)
53874,METHOD,proto_proxy.h:<global>,TYPE_DECL,void proxy_complete_cb(io_queue_t *q);,6,37,proto_proxy.h,proxy_complete_cb,,false,20,20,proxy_complete_cb,,,12,void proxy_complete_cb (io_queue_t*)
53879,METHOD,proto_proxy.h:<global>,TYPE_DECL,void proxy_return_cb(io_pending_t *pending);,6,43,proto_proxy.h,proxy_return_cb,,false,21,21,proxy_return_cb,,,13,void proxy_return_cb (io_pending_t*)
53884,METHOD,proto_proxy.h:<global>,TYPE_DECL,void proxy_finalize_cb(io_pending_t *pending);,6,45,proto_proxy.h,proxy_finalize_cb,,false,22,22,proxy_finalize_cb,,,14,void proxy_finalize_cb (io_pending_t*)
53889,METHOD,proto_proxy.h:<global>,TYPE_DECL,"int proxy_register_libs(LIBEVENT_THREAD *t, void *ctx);",5,54,proto_proxy.h,proxy_register_libs,,false,25,25,proxy_register_libs,,,15,"int proxy_register_libs (LIBEVENT_THREAD*,void*)"
53916,METHOD,proto_text.c:<global>,TYPE_DECL,<global>,1,1,proto_text.c,proto_text.c:<global>,,false,1,2929,<global>,,,1,
53922,METHOD,proto_text.c:<global>,TYPE_DECL,"static void _finalize_mset(conn *c, enum store_item_type ret) {
    mc_resp *resp = c->resp;
    item *it = c->item;
    conn_set_state(c, conn_new_cmd);

    // information about the response line has been stashed in wbuf.
    char *p = resp->wbuf + resp->wbytes;
    char *end = p; // end of the stashed data portion.

    switch (ret) {
    case STORED:
      if (settings.meta_response_old) {
          memcpy(p, ""OK"", 2);
      } else {
          memcpy(p, ""HD"", 2);
      }
      // Only place noreply is used for meta cmds is a nominal response.
      if (c->noreply) {
          resp->skip = true;
      }
      break;
    case EXISTS:
      memcpy(p, ""EX"", 2);
      break;
    case NOT_FOUND:
      memcpy(p, ""NF"", 2);
      break;
    case NOT_STORED:
      memcpy(p, ""NS"", 2);
      break;
    default:
      c->noreply = false;
      out_string(c, ""SERVER_ERROR Unhandled storage type."");
      return;
    }
    p += 2;

    for (char *fp = resp->wbuf; fp < end; fp++) {
        swit...",1,16,proto_text.c,_finalize_mset,,false,54,122,_finalize_mset,,,3,"void _finalize_mset (conn*,store_item_type)"
54224,METHOD,proto_text.c:<global>,TYPE_DECL,"void complete_nread_ascii(conn *c) {
    assert(c != NULL);

    item *it = c->item;
    int comm = c->cmd;
    enum store_item_type ret;
    bool is_valid = false;

    pthread_mutex_lock(&c->thread->stats.mutex);
    c->thread->stats.slab_stats[ITEM_clsid(it)].set_cmds++;
    pthread_mutex_unlock(&c->thread->stats.mutex);

    if ((it->it_flags & ITEM_CHUNKED) == 0) {
        if (strncmp(ITEM_data(it) + it->nbytes - 2, ""\r\n"", 2) == 0) {
            is_valid = true;
        }
    } else {
        char buf[2];
        /* should point to the final item chunk */
        item_chunk *ch = (item_chunk *) c->ritem;
        assert(ch->used != 0);
        /* :( We need to look at the last two bytes. This could span two
         * chunks.
         */
        if (ch->used > 1) {
            buf[0] = ch->data[ch->used - 2];
            buf[1] = ch->data[ch->used - 1];
        } else {
            assert(ch->prev);
            assert(ch->used == 1);
            buf[0] = ch->prev->data[ch->prev...",1,32,proto_text.c,complete_nread_ascii,,false,128,234,complete_nread_ascii,,,4,void complete_nread_ascii (conn*)
54546,METHOD,proto_text.c:<global>,TYPE_DECL,"static size_t tokenize_command(char *command, token_t *tokens, const size_t max_tokens) {
    char *s, *e;
    size_t ntokens = 0;
    assert(command != NULL && tokens != NULL && max_tokens > 1);
    size_t len = strlen(command);
    unsigned int i = 0;

    s = e = command;
    for (i = 0; i < len; i++) {
        if (*e == ' ') {
            if (s != e) {
                tokens[ntokens].value = s;
                tokens[ntokens].length = e - s;
                ntokens++;
                *e = '\0';
                if (ntokens == max_tokens - 1) {
                    e++;
                    s = e; /* so we don't add an extra token */
                    break;
                }
            }
            s = e + 1;
        }
        e++;
    }

    if (s != e) {
        tokens[ntokens].value = s;
        tokens[ntokens].length = e - s;
        ntokens++;
    }

    /*
     * If we scanned the whole string, the terminal value pointer is null,
     * otherwise it is the first unprocess...",1,1,proto_text.c,tokenize_command,,false,283,324,tokenize_command,,,5,"size_t tokenize_command (char*,token_t*,size_t)"
54696,METHOD,proto_text.c:<global>,TYPE_DECL,"int try_read_command_asciiauth(conn *c) {
    token_t tokens[MAX_TOKENS];
    size_t ntokens;
    char *cont = NULL;

    // TODO: move to another function.
    if (!c->sasl_started) {
        char *el;
        uint32_t size = 0;

        // impossible for the auth command to be this short.
        if (c->rbytes < 2)
            return 0;

        el = memchr(c->rcurr, '\n', c->rbytes);

        // If no newline after 1k, getting junk data, close out.
        if (!el) {
            if (c->rbytes > 2048) {
                conn_set_state(c, conn_closing);
                return 1;
            }
            return 0;
        }

        // Looking for: ""set foo 0 0 N\r\nuser pass\r\n""
        // key, flags, and ttl are ignored. N is used to see if we have the rest.

        // so tokenize doesn't walk past into the value.
        // it's fine to leave the \r in, as strtoul will stop at it.
        *el = '\0';

        ntokens = tokenize_command(c->rcurr, tokens, MAX_TOKENS);
        // ...",1,19,proto_text.c,try_read_command_asciiauth,,false,326,436,try_read_command_asciiauth,,,6,int try_read_command_asciiauth (conn*)
55041,METHOD,proto_text.c:<global>,TYPE_DECL,"int try_read_command_ascii(conn *c) {
    char *el, *cont;

    if (c->rbytes == 0)
        return 0;

    el = memchr(c->rcurr, '\n', c->rbytes);
    if (!el) {
        if (c->rbytes > 2048) {
            /*
             * We didn't have a '\n' in the first few k. This _has_ to be a
             * large multiget, if not we should just nuke the connection.
             */
            char *ptr = c->rcurr;
            while (*ptr == ' ') { /* ignore leading whitespaces */
                ++ptr;
            }

            if (ptr - c->rcurr > 100 ||
                (strncmp(ptr, ""get "", 4) && strncmp(ptr, ""gets "", 5))) {

                conn_set_state(c, conn_closing);
                return 1;
            }

            // ASCII multigets are unbound, so our fixed size rbuf may not
            // work for this particular workload... For backcompat we'll use a
            // malloc/realloc/free routine just for this.
            if (!c->rbuf_malloced) {
                if (!rbuf_swit...",1,1,proto_text.c,try_read_command_ascii,,false,438,493,try_read_command_ascii,,,7,int try_read_command_ascii (conn*)
55209,METHOD,proto_text.c:<global>,TYPE_DECL,"static inline bool set_noreply_maybe(conn *c, token_t *tokens, size_t ntokens)
{
    int noreply_index = ntokens - 2;

    /*
      NOTE: this function is not the first place where we are going to
      send the reply.  We could send it instead from process_command()
      if the request line has wrong number of tokens.  However parsing
      malformed line for ""noreply"" option is not reliable anyway, so
      it can't be helped.
    */
    if (tokens[noreply_index].value
        && strcmp(tokens[noreply_index].value, ""noreply"") == 0) {
        c->noreply = true;
    }
    return c->noreply;
}",1,1,proto_text.c,set_noreply_maybe,,false,496,512,set_noreply_maybe,,,8,"bool set_noreply_maybe (conn*,token_t*,size_t)"
55248,METHOD,proto_text.c:<global>,TYPE_DECL,"static inline int make_ascii_get_suffix(char *suffix, item *it, bool return_cas, int nbytes) {
    char *p = suffix;
    *p = ' ';
    p++;
    if (FLAGS_SIZE(it) == 0) {
        *p = '0';
        p++;
    } else {
        p = itoa_u32(*((uint32_t *) ITEM_suffix(it)), p);
    }
    *p = ' ';
    p = itoa_u32(nbytes-2, p+1);

    if (return_cas) {
        *p = ' ';
        p = itoa_u64(ITEM_get_cas(it), p+1);
    }

    *p = '\r';
    *(p+1) = '\n';
    *(p+2) = '\0';
    return (p - suffix) + 2;
}",1,8,proto_text.c,make_ascii_get_suffix,,false,515,537,make_ascii_get_suffix,,,9,"int make_ascii_get_suffix (char*,item*,bool,int)"
55387,METHOD,proto_text.c:<global>,TYPE_DECL,"static inline void process_get_command(conn *c, token_t *tokens, size_t ntokens, bool return_cas, bool should_touch) {
    char *key;
    size_t nkey;
    item *it;
    token_t *key_token = &tokens[KEY_TOKEN];
    int32_t exptime_int = 0;
    rel_time_t exptime = 0;
    bool fail_length = false;
    assert(c != NULL);
    mc_resp *resp = c->resp;

    if (should_touch) {
        // For get and touch commands, use first token as exptime
        if (!safe_strtol(tokens[1].value, &exptime_int)) {
            out_string(c, ""CLIENT_ERROR invalid exptime argument"");
            return;
        }
        key_token++;
        exptime = realtime(EXPTIME_TO_POSITIVE_TIME(exptime_int));
    }

    do {
        while(key_token->length != 0) {
            bool overflow; // not used here.
            key = key_token->value;
            nkey = key_token->length;

            if (nkey > KEY_MAX_LENGTH) {
                fail_length = true;
                goto stop;
            }

            it = ...",1,33,proto_text.c,process_get_command,,false,540,713,process_get_command,,,10,"void process_get_command (conn*,token_t*,size_t,bool,bool)"
55937,METHOD,proto_text.c:<global>,TYPE_DECL,"inline static void process_stats_detail(conn *c, const char *command) {
    assert(c != NULL);

    if (strcmp(command, ""on"") == 0) {
        settings.detail_enabled = 1;
        out_string(c, ""OK"");
    }
    else if (strcmp(command, ""off"") == 0) {
        settings.detail_enabled = 0;
        out_string(c, ""OK"");
    }
    else if (strcmp(command, ""dump"") == 0) {
        int len;
        char *stats = stats_prefix_dump(&len);
        write_and_free(c, stats, len);
    }
    else {
        out_string(c, ""CLIENT_ERROR usage: stats detail on|off|dump"");
    }
}",1,1,proto_text.c,process_stats_detail,,false,715,734,process_stats_detail,,,11,"void process_stats_detail (conn*,char*)"
56004,METHOD,proto_text.c:<global>,TYPE_DECL,"static void process_stat(conn *c, token_t *tokens, const size_t ntokens) {
    const char *subcommand = tokens[SUBCOMMAND_TOKEN].value;
    assert(c != NULL);

    if (ntokens < 2) {
        out_string(c, ""CLIENT_ERROR bad command line"");
        return;
    }

    if (ntokens == 2) {
        server_stats(&append_stats, c);
        (void)get_stats(NULL, 0, &append_stats, c);
    } else if (strcmp(subcommand, ""reset"") == 0) {
        stats_reset();
        out_string(c, ""RESET"");
        return;
    } else if (strcmp(subcommand, ""detail"") == 0) {
        /* NOTE: how to tackle detail with binary? */
        if (ntokens < 4)
            process_stats_detail(c, """");  /* outputs the error message */
        else
            process_stats_detail(c, tokens[2].value);
        /* Output already generated */
        return;
    } else if (strcmp(subcommand, ""settings"") == 0) {
        process_stat_settings(&append_stats, c);
    } else if (strcmp(subcommand, ""cachedump"") == 0) {
        char...",1,36,proto_text.c,process_stat,,false,736,825,process_stat,,,12,"void process_stat (conn*,token_t*,size_t)"
56292,METHOD,proto_text.c:<global>,TYPE_DECL,"static void process_meta_command(conn *c, token_t *tokens, const size_t ntokens) {
    assert(c != NULL);

    if (ntokens < 3 || tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {
        out_string(c, ""CLIENT_ERROR bad command line format"");
        return;
    }

    char *key = tokens[KEY_TOKEN].value;
    size_t nkey = tokens[KEY_TOKEN].length;

    if (ntokens >= 4 && tokens[2].length == 1 && tokens[2].value[0] == 'b') {
        size_t ret = base64_decode((unsigned char *)key, nkey,
                    (unsigned char *)key, nkey);
        if (ret == 0) {
            // failed to decode.
            out_string(c, ""CLIENT_ERROR bad command line format"");
            return;
        }
        nkey = ret;
    }

    bool overflow; // not used here.
    item *it = limited_get(key, nkey, c, 0, false, DONT_UPDATE, &overflow);
    if (it) {
        mc_resp *resp = c->resp;
        size_t total = 0;
        size_t ret;
        // similar to out_string().
        memcpy(resp->wbuf, ""ME "", 3);...",1,30,proto_text.c,process_meta_command,,false,828,890,process_meta_command,,,13,"void process_meta_command (conn*,token_t*,size_t)"
56708,METHOD,proto_text.c:<global>,TYPE_DECL,"static int _meta_flag_preparse(token_t *tokens, const size_t start,
        struct _meta_flags *of, char **errstr) {
    unsigned int i;
    size_t ret;
    int32_t tmp_int;
    uint8_t seen[127] = {0};
    // Start just past the key token. Look at first character of each token.
    for (i = start; tokens[i].length != 0; i++) {
        uint8_t o = (uint8_t)tokens[i].value[0];
        // zero out repeat flags so we don't over-parse for return data.
        if (o >= 127 || seen[o] != 0) {
            *errstr = ""CLIENT_ERROR duplicate flag"";
            return -1;
        }
        seen[o] = 1;
        switch (o) {
            // base64 decode the key in-place, as the binary should always be
            // shorter and the conversion code buffers bytes.
            case 'b':
                ret = base64_decode((unsigned char *)tokens[KEY_TOKEN].value, tokens[KEY_TOKEN].length,
                            (unsigned char *)tokens[KEY_TOKEN].value, tokens[KEY_TOKEN].length);
              ...",1,60,proto_text.c,_meta_flag_preparse,,false,918,1049,_meta_flag_preparse,,,15,"int _meta_flag_preparse (token_t*,size_t,_meta_flags*,char**)"
57247,METHOD,proto_text.c:<global>,TYPE_DECL,"static void process_mget_command(conn *c, token_t *tokens, const size_t ntokens) {
    char *key;
    size_t nkey;
    item *it;
    unsigned int i = 0;
    struct _meta_flags of = {0}; // option bitflags.
    uint32_t hv; // cached hash value for unlocking an item.
    bool failed = false;
    bool item_created = false;
    bool won_token = false;
    bool ttl_set = false;
    char *errstr = ""CLIENT_ERROR bad command line format"";
    assert(c != NULL);
    mc_resp *resp = c->resp;
    char *p = resp->wbuf;

    WANT_TOKENS_MIN(ntokens, 3);

    // FIXME: do we move this check to after preparse?
    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {
        out_errstring(c, ""CLIENT_ERROR bad command line format"");
        return;
    }

    // NOTE: final token has length == 0.
    // KEY_TOKEN == 1. 0 is command.

    if (ntokens == 3) {
        // TODO: any way to fix this?
        out_errstring(c, ""CLIENT_ERROR bad command line format"");
        return;
    } else if (ntokens > MF...",1,4,proto_text.c,process_mget_command,,false,1051,1352,process_mget_command,,,16,"void process_mget_command (conn*,token_t*,size_t)"
58436,METHOD,proto_text.c:<global>,TYPE_DECL,"static void process_mset_command(conn *c, token_t *tokens, const size_t ntokens) {
    char *key;
    size_t nkey;
    item *it;
    int i;
    short comm = NREAD_SET;
    struct _meta_flags of = {0}; // option bitflags.
    char *errstr = ""CLIENT_ERROR bad command line format"";
    uint32_t hv; // cached hash value.
    int vlen = 0; // value from data line.
    assert(c != NULL);
    mc_resp *resp = c->resp;
    char *p = resp->wbuf;

    WANT_TOKENS_MIN(ntokens, 3);

    // TODO: most of this is identical to mget.
    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {
        out_errstring(c, ""CLIENT_ERROR bad command line format"");
        return;
    }

    if (ntokens == 3) {
        out_errstring(c, ""CLIENT_ERROR bad command line format"");
        return;
    }

    if (ntokens > MFLAG_MAX_OPT_LENGTH) {
        out_errstring(c, ""CLIENT_ERROR options flags too long"");
        return;
    }

    // We note tokens into the front of the write buffer, so we can create the
    // fin...",1,17,proto_text.c,process_mset_command,,false,1354,1551,process_mset_command,,,17,"void process_mset_command (conn*,token_t*,size_t)"
59125,METHOD,proto_text.c:<global>,TYPE_DECL,"static void process_mdelete_command(conn *c, token_t *tokens, const size_t ntokens) {
    char *key;
    size_t nkey;
    item *it = NULL;
    int i;
    uint32_t hv;
    struct _meta_flags of = {0}; // option bitflags.
    char *errstr = ""CLIENT_ERROR bad command line format"";
    assert(c != NULL);
    mc_resp *resp = c->resp;
    // reserve 3 bytes for status code
    char *p = resp->wbuf + 3;

    WANT_TOKENS_MIN(ntokens, 3);

    // TODO: most of this is identical to mget.
    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {
        out_string(c, ""CLIENT_ERROR bad command line format"");
        return;
    }

    if (ntokens > MFLAG_MAX_OPT_LENGTH) {
        out_string(c, ""CLIENT_ERROR options flags too long"");
        return;
    }

    // scrubs duplicated options and sets flags for how to load the item.
    // we pass in the first token that should be a flag.
    // FIXME: not using the preparse errstr?
    if (_meta_flag_preparse(tokens, 2, &of, &errstr) != 0) {
        out...",1,4,proto_text.c,process_mdelete_command,,false,1553,1683,process_mdelete_command,,,18,"void process_mdelete_command (conn*,token_t*,size_t)"
59708,METHOD,proto_text.c:<global>,TYPE_DECL,"static void process_marithmetic_command(conn *c, token_t *tokens, const size_t ntokens) {
    char *key;
    size_t nkey;
    int i;
    struct _meta_flags of = {0}; // option bitflags.
    char *errstr = ""CLIENT_ERROR bad command line format"";
    assert(c != NULL);
    mc_resp *resp = c->resp;
    // no reservation (like del/set) since we post-process the status line.
    char *p = resp->wbuf;

    // If no argument supplied, incr or decr by one.
    of.delta = 1;
    of.initial = 0; // redundant, for clarity.
    bool incr = true; // default mode is to increment.
    bool locked = false;
    uint32_t hv = 0;
    item *it = NULL; // item returned by do_add_delta.

    WANT_TOKENS_MIN(ntokens, 3);

    // TODO: most of this is identical to mget.
    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {
        out_string(c, ""CLIENT_ERROR bad command line format"");
        return;
    }

    if (ntokens > MFLAG_MAX_OPT_LENGTH) {
        out_string(c, ""CLIENT_ERROR options flags too long""...",1,4,proto_text.c,process_marithmetic_command,,false,1685,1915,process_marithmetic_command,,,19,"void process_marithmetic_command (conn*,token_t*,size_t)"
60679,METHOD,proto_text.c:<global>,TYPE_DECL,"static void process_update_command(conn *c, token_t *tokens, const size_t ntokens, int comm, bool handle_cas) {
    char *key;
    size_t nkey;
    unsigned int flags;
    int32_t exptime_int = 0;
    rel_time_t exptime = 0;
    int vlen;
    uint64_t req_cas_id=0;
    item *it;

    assert(c != NULL);

    set_noreply_maybe(c, tokens, ntokens);

    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {
        out_string(c, ""CLIENT_ERROR bad command line format"");
        return;
    }

    key = tokens[KEY_TOKEN].value;
    nkey = tokens[KEY_TOKEN].length;

    if (! (safe_strtoul(tokens[2].value, (uint32_t *)&flags)
           && safe_strtol(tokens[3].value, &exptime_int)
           && safe_strtol(tokens[4].value, (int32_t *)&vlen))) {
        out_string(c, ""CLIENT_ERROR bad command line format"");
        return;
    }

    exptime = realtime(EXPTIME_TO_POSITIVE_TIME(exptime_int));

    // does cas value exist?
    if (handle_cas) {
        if (!safe_strtoull(tokens[5].value, &req_cas...",1,15,proto_text.c,process_update_command,,false,1918,2018,process_update_command,,,20,"void process_update_command (conn*,token_t*,size_t,int,bool)"
61102,METHOD,proto_text.c:<global>,TYPE_DECL,"static void process_touch_command(conn *c, token_t *tokens, const size_t ntokens) {
    char *key;
    size_t nkey;
    int32_t exptime_int = 0;
    rel_time_t exptime = 0;
    item *it;

    assert(c != NULL);

    set_noreply_maybe(c, tokens, ntokens);

    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {
        out_string(c, ""CLIENT_ERROR bad command line format"");
        return;
    }

    key = tokens[KEY_TOKEN].value;
    nkey = tokens[KEY_TOKEN].length;

    if (!safe_strtol(tokens[2].value, &exptime_int)) {
        out_string(c, ""CLIENT_ERROR invalid exptime argument"");
        return;
    }

    exptime = realtime(EXPTIME_TO_POSITIVE_TIME(exptime_int));
    it = item_touch(key, nkey, exptime, c);
    if (it) {
        pthread_mutex_lock(&c->thread->stats.mutex);
        c->thread->stats.touch_cmds++;
        c->thread->stats.slab_stats[ITEM_clsid(it)].touch_hits++;
        pthread_mutex_unlock(&c->thread->stats.mutex);

        out_string(c, ""TOUCHED"");
        item_remov...",1,15,proto_text.c,process_touch_command,,false,2020,2062,process_touch_command,,,21,"void process_touch_command (conn*,token_t*,size_t)"
61300,METHOD,proto_text.c:<global>,TYPE_DECL,"static void process_arithmetic_command(conn *c, token_t *tokens, const size_t ntokens, const bool incr) {
    char temp[INCR_MAX_STORAGE_LEN];
    uint64_t delta;
    char *key;
    size_t nkey;

    assert(c != NULL);

    set_noreply_maybe(c, tokens, ntokens);

    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {
        out_string(c, ""CLIENT_ERROR bad command line format"");
        return;
    }

    key = tokens[KEY_TOKEN].value;
    nkey = tokens[KEY_TOKEN].length;

    if (!safe_strtoull(tokens[2].value, &delta)) {
        out_string(c, ""CLIENT_ERROR invalid numeric delta argument"");
        return;
    }

    switch(add_delta(c, key, nkey, incr, delta, temp, NULL)) {
    case OK:
        out_string(c, temp);
        break;
    case NON_NUMERIC:
        out_string(c, ""CLIENT_ERROR cannot increment or decrement non-numeric value"");
        break;
    case EOM:
        out_of_memory(c, ""SERVER_ERROR out of memory"");
        break;
    case DELTA_ITEM_NOT_FOUND:
        pthread_m...",1,14,proto_text.c,process_arithmetic_command,,false,2064,2111,process_arithmetic_command,,,22,"void process_arithmetic_command (conn*,token_t*,size_t,bool)"
61446,METHOD,proto_text.c:<global>,TYPE_DECL,"static void process_delete_command(conn *c, token_t *tokens, const size_t ntokens) {
    char *key;
    size_t nkey;
    item *it;
    uint32_t hv;

    assert(c != NULL);

    if (ntokens > 3) {
        bool hold_is_zero = strcmp(tokens[KEY_TOKEN+1].value, ""0"") == 0;
        bool sets_noreply = set_noreply_maybe(c, tokens, ntokens);
        bool valid = (ntokens == 4 && (hold_is_zero || sets_noreply))
            || (ntokens == 5 && hold_is_zero && sets_noreply);
        if (!valid) {
            out_string(c, ""CLIENT_ERROR bad command line format.  ""
                       ""Usage: delete <key> [noreply]"");
            return;
        }
    }


    key = tokens[KEY_TOKEN].value;
    nkey = tokens[KEY_TOKEN].length;

    if(nkey > KEY_MAX_LENGTH) {
        out_string(c, ""CLIENT_ERROR bad command line format"");
        return;
    }

    if (settings.detail_enabled) {
        stats_prefix_record_delete(key, nkey);
    }

    it = item_get_locked(key, nkey, c, DONT_UPDATE, &hv);
    i...",1,42,proto_text.c,process_delete_command,,false,2114,2167,process_delete_command,,,23,"void process_delete_command (conn*,token_t*,size_t)"
61647,METHOD,proto_text.c:<global>,TYPE_DECL,"static void process_verbosity_command(conn *c, token_t *tokens, const size_t ntokens) {
    unsigned int level;

    assert(c != NULL);

    set_noreply_maybe(c, tokens, ntokens);

    if (!safe_strtoul(tokens[1].value, (uint32_t*)&level)) {
        out_string(c, ""CLIENT_ERROR bad command line format"");
        return;
    }
    settings.verbose = level > MAX_VERBOSITY_LEVEL ? MAX_VERBOSITY_LEVEL : level;
    out_string(c, ""OK"");
    return;
}",1,31,proto_text.c,process_verbosity_command,,false,2169,2183,process_verbosity_command,,,24,"void process_verbosity_command (conn*,token_t*,size_t)"
61698,METHOD,proto_text.c:<global>,TYPE_DECL,"static void process_slabs_automove_command(conn *c, token_t *tokens, const size_t ntokens) {
    unsigned int level;
    double ratio;

    assert(c != NULL);

    set_noreply_maybe(c, tokens, ntokens);

    if (strcmp(tokens[2].value, ""ratio"") == 0) {
        if (ntokens < 5 || !safe_strtod(tokens[3].value, &ratio)) {
            out_string(c, ""ERROR"");
            return;
        }
        settings.slab_automove_ratio = ratio;
    } else {
        if (!safe_strtoul(tokens[2].value, (uint32_t*)&level)) {
            out_string(c, ""CLIENT_ERROR bad command line format"");
            return;
        }
        if (level == 0) {
            settings.slab_automove = 0;
        } else if (level == 1 || level == 2) {
            settings.slab_automove = level;
        } else {
            out_string(c, ""ERROR"");
            return;
        }
    }
    out_string(c, ""OK"");
    return;
}",1,1,proto_text.c,process_slabs_automove_command,,false,2231,2261,process_slabs_automove_command,,,25,"void process_slabs_automove_command (conn*,token_t*,size_t)"
61805,METHOD,proto_text.c:<global>,TYPE_DECL,"static void process_watch_command(conn *c, token_t *tokens, const size_t ntokens) {
    uint16_t f = 0;
    int x;
    assert(c != NULL);

    set_noreply_maybe(c, tokens, ntokens);
    if (!settings.watch_enabled) {
        out_string(c, ""CLIENT_ERROR watch commands not allowed"");
        return;
    }

    if (resp_has_stack(c)) {
        out_string(c, ""ERROR cannot pipeline other commands before watch"");
        return;
    }

    if (ntokens > 2) {
        for (x = COMMAND_TOKEN + 1; x < ntokens - 1; x++) {
            if ((strcmp(tokens[x].value, ""rawcmds"") == 0)) {
                f |= LOG_RAWCMDS;
            } else if ((strcmp(tokens[x].value, ""evictions"") == 0)) {
                f |= LOG_EVICTIONS;
            } else if ((strcmp(tokens[x].value, ""fetchers"") == 0)) {
                f |= LOG_FETCHERS;
            } else if ((strcmp(tokens[x].value, ""mutations"") == 0)) {
                f |= LOG_MUTATIONS;
            } else if ((strcmp(tokens[x].value, ""sysevents"") == 0)) {...",1,17,proto_text.c,process_watch_command,,false,2264,2321,process_watch_command,,,26,"void process_watch_command (conn*,token_t*,size_t)"
62089,METHOD,proto_text.c:<global>,TYPE_DECL,"static void process_memlimit_command(conn *c, token_t *tokens, const size_t ntokens) {
    uint32_t memlimit;
    assert(c != NULL);

    set_noreply_maybe(c, tokens, ntokens);

    if (!safe_strtoul(tokens[1].value, &memlimit)) {
        out_string(c, ""ERROR"");
    } else {
        if (memlimit < 8) {
            out_string(c, ""MEMLIMIT_TOO_SMALL cannot set maxbytes to less than 8m"");
        } else {
            if (memlimit > 1000000000) {
                out_string(c, ""MEMLIMIT_ADJUST_FAILED input value is megabytes not bytes"");
            } else if (slabs_adjust_mem_limit((size_t) memlimit * 1024 * 1024)) {
                if (settings.verbose > 0) {
                    fprintf(stderr, ""maxbytes adjusted to %llum\n"", (unsigned long long)memlimit);
                }

                out_string(c, ""OK"");
            } else {
                out_string(c, ""MEMLIMIT_ADJUST_FAILED out of bounds or unable to adjust"");
            }
        }
    }
}",1,1,proto_text.c,process_memlimit_command,,false,2323,2348,process_memlimit_command,,,27,"void process_memlimit_command (conn*,token_t*,size_t)"
62172,METHOD,proto_text.c:<global>,TYPE_DECL,"static void process_lru_command(conn *c, token_t *tokens, const size_t ntokens) {
    uint32_t pct_hot;
    uint32_t pct_warm;
    double hot_factor;
    int32_t ttl;
    double factor;

    set_noreply_maybe(c, tokens, ntokens);

    if (strcmp(tokens[1].value, ""tune"") == 0 && ntokens >= 7) {
        if (!safe_strtoul(tokens[2].value, &pct_hot) ||
            !safe_strtoul(tokens[3].value, &pct_warm) ||
            !safe_strtod(tokens[4].value, &hot_factor) ||
            !safe_strtod(tokens[5].value, &factor)) {
            out_string(c, ""ERROR"");
        } else {
            if (pct_hot + pct_warm > 80) {
                out_string(c, ""ERROR hot and warm pcts must not exceed 80"");
            } else if (factor <= 0 || hot_factor <= 0) {
                out_string(c, ""ERROR hot/warm age factors must be greater than 0"");
            } else {
                settings.hot_lru_pct = pct_hot;
                settings.warm_lru_pct = pct_warm;
                settings.hot_max_factor = ho...",1,1,proto_text.c,process_lru_command,,false,2350,2405,process_lru_command,,,28,"void process_lru_command (conn*,token_t*,size_t)"
62431,METHOD,proto_text.c:<global>,TYPE_DECL,"static void process_flush_all_command(conn *c, token_t *tokens, const size_t ntokens) {
    int32_t exptime = 0;
    rel_time_t new_oldest = 0;

    set_noreply_maybe(c, tokens, ntokens);

    pthread_mutex_lock(&c->thread->stats.mutex);
    c->thread->stats.flush_cmds++;
    pthread_mutex_unlock(&c->thread->stats.mutex);

    if (!settings.flush_enabled) {
        // flush_all is not allowed but we log it on stats
        out_string(c, ""CLIENT_ERROR flush_all not allowed"");
        return;
    }

    if (ntokens != (c->noreply ? 3 : 2)) {
        if (!safe_strtol(tokens[1].value, &exptime)) {
            out_string(c, ""CLIENT_ERROR invalid exptime argument"");
            return;
        }
    }

    /*
      If exptime is zero realtime() would return zero too, and
      realtime(exptime) - 1 would overflow to the max unsigned
      value.  So we process exptime == 0 the same way we do when
      no delay is given at all.
    */
    if (exptime > 0) {
        new_oldest = realtime(e...",1,1,proto_text.c,process_flush_all_command,,false,2467,2510,process_flush_all_command,,,29,"void process_flush_all_command (conn*,token_t*,size_t)"
62559,METHOD,proto_text.c:<global>,TYPE_DECL,"static void process_version_command(conn *c) {
    out_string(c, ""VERSION "" VERSION);
}",1,1,proto_text.c,process_version_command,,false,2512,2514,process_version_command,,,30,void process_version_command (conn*)
62565,METHOD,proto_text.c:<global>,TYPE_DECL,"static void process_quit_command(conn *c) {
    conn_set_state(c, conn_mwrite);
    c->close_after_write = true;
    c->close_reason = NORMAL_CLOSE;
}",1,1,proto_text.c,process_quit_command,,false,2516,2520,process_quit_command,,,31,void process_quit_command (conn*)
62583,METHOD,proto_text.c:<global>,TYPE_DECL,"static void process_shutdown_command(conn *c, token_t *tokens, const size_t ntokens) {
    if (!settings.shutdown_command) {
        out_string(c, ""ERROR: shutdown not enabled"");
        return;
    }

    if (ntokens == 2) {
        c->close_reason = SHUTDOWN_CLOSE;
        conn_set_state(c, conn_closing);
        raise(SIGINT);
    } else if (ntokens == 3 && strcmp(tokens[SUBCOMMAND_TOKEN].value, ""graceful"") == 0) {
        c->close_reason = SHUTDOWN_CLOSE;
        conn_set_state(c, conn_closing);
        raise(SIGUSR1);
    } else {
        out_string(c, ""CLIENT_ERROR invalid shutdown mode"");
    }
}",1,45,proto_text.c,process_shutdown_command,,false,2522,2539,process_shutdown_command,,,32,"void process_shutdown_command (conn*,token_t*,size_t)"
62649,METHOD,proto_text.c:<global>,TYPE_DECL,"static void process_slabs_command(conn *c, token_t *tokens, const size_t ntokens) {
    if (ntokens == 5 && strcmp(tokens[COMMAND_TOKEN + 1].value, ""reassign"") == 0) {
        int src, dst, rv;

        if (settings.slab_reassign == false) {
            out_string(c, ""CLIENT_ERROR slab reassignment disabled"");
            return;
        }

        if (! (safe_strtol(tokens[2].value, (int32_t*)&src)
               && safe_strtol(tokens[3].value, (int32_t*)&dst))) {
            out_string(c, ""CLIENT_ERROR bad command line format"");
            return;
        }

        rv = slabs_reassign(src, dst);
        switch (rv) {
        case REASSIGN_OK:
            out_string(c, ""OK"");
            break;
        case REASSIGN_RUNNING:
            out_string(c, ""BUSY currently processing reassign request"");
            break;
        case REASSIGN_BADCLASS:
            out_string(c, ""BADCLASS invalid src or dst class id"");
            break;
        case REASSIGN_NOSPARE:
            out_st...",1,38,proto_text.c,process_slabs_command,,false,2541,2581,process_slabs_command,,,33,"void process_slabs_command (conn*,token_t*,size_t)"
62786,METHOD,proto_text.c:<global>,TYPE_DECL,"static void process_lru_crawler_command(conn *c, token_t *tokens, const size_t ntokens) {
    if (ntokens == 4 && strcmp(tokens[COMMAND_TOKEN + 1].value, ""crawl"") == 0) {
        int rv;
        if (settings.lru_crawler == false) {
            out_string(c, ""CLIENT_ERROR lru crawler disabled"");
            return;
        }

        rv = lru_crawler_crawl(tokens[2].value, CRAWLER_EXPIRED, NULL, 0,
                settings.lru_crawler_tocrawl);
        switch(rv) {
        case CRAWLER_OK:
            out_string(c, ""OK"");
            break;
        case CRAWLER_RUNNING:
            out_string(c, ""BUSY currently processing crawler request"");
            break;
        case CRAWLER_BADCLASS:
            out_string(c, ""BADCLASS invalid class id"");
            break;
        case CRAWLER_NOTSTARTED:
            out_string(c, ""NOTSTARTED no items to crawl"");
            break;
        case CRAWLER_ERROR:
            out_string(c, ""ERROR an unknown error happened"");
            break;
    ...",1,38,proto_text.c,process_lru_crawler_command,,false,2583,2694,process_lru_crawler_command,,,34,"void process_lru_crawler_command (conn*,token_t*,size_t)"
63159,METHOD,proto_text.c:<global>,TYPE_DECL,"void process_command_ascii(conn *c, char *command) {

    token_t tokens[MAX_TOKENS];
    size_t ntokens;
    int comm;

    assert(c != NULL);

    MEMCACHED_PROCESS_COMMAND_START(c->sfd, c->rcurr, c->rbytes);

    if (settings.verbose > 1)
        fprintf(stderr, ""<%d %s\n"", c->sfd, command);

    /*
     * for commands set/add/replace, we build an item and read the data
     * directly into it, then continue in nread_complete().
     */

    // Prep the response object for this query.
    if (!resp_start(c)) {
        conn_set_state(c, conn_closing);
        return;
    }

    ntokens = tokenize_command(command, tokens, MAX_TOKENS);
    // All commands need a minimum of two tokens: cmd and NULL finalizer
    // There are also no valid commands shorter than two bytes.
    if (ntokens < 2 || tokens[COMMAND_TOKEN].length < 2) {
        out_string(c, ""ERROR"");
        return;
    }

    // Meta commands are all 2-char in length.
    char first = tokens[COMMAND_TOKEN].value[0];
    if...",1,19,proto_text.c,process_command_ascii,,false,2716,2928,process_command_ascii,,,35,"void process_command_ascii (conn*,char*)"
64238,METHOD,proto_text.h:<global>,TYPE_DECL,<global>,1,6,proto_text.h,proto_text.h:<global>,,false,1,10,<global>,,,1,
64240,METHOD,proto_text.h:<global>,TYPE_DECL,void complete_nread_ascii(conn *c);,6,34,proto_text.h,complete_nread_ascii,,false,5,5,complete_nread_ascii,,,1,void complete_nread_ascii (conn*)
64245,METHOD,proto_text.h:<global>,TYPE_DECL,int try_read_command_asciiauth(conn *c);,5,39,proto_text.h,try_read_command_asciiauth,,false,6,6,try_read_command_asciiauth,,,2,int try_read_command_asciiauth (conn*)
64250,METHOD,proto_text.h:<global>,TYPE_DECL,int try_read_command_ascii(conn *c);,5,35,proto_text.h,try_read_command_ascii,,false,7,7,try_read_command_ascii,,,3,int try_read_command_ascii (conn*)
64255,METHOD,proto_text.h:<global>,TYPE_DECL,"void process_command_ascii(conn *c, char *command);",6,50,proto_text.h,process_command_ascii,,false,8,8,process_command_ascii,,,4,"void process_command_ascii (conn*,char*)"
64264,METHOD,protocol_binary.h:<global>,TYPE_DECL,<global>,1,30,protocol_binary.h,protocol_binary.h:<global>,,false,1,470,<global>,,,1,
64269,METHOD,<empty>,<empty>,<empty>,5,,protocol_binary.h,protocol_binary_magic:<clinit>,,false,53,,<clinit>,,,3,
64292,METHOD,<empty>,<empty>,<empty>,5,,protocol_binary.h,protocol_binary_response_status:<clinit>,,false,62,,<clinit>,,,12,
64379,METHOD,<empty>,<empty>,<empty>,5,,protocol_binary.h,protocol_binary_command:<clinit>,,false,80,,<clinit>,,,49,
64530,METHOD,<empty>,<empty>,<empty>,5,,protocol_binary.h,protocol_binary_datatypes:<clinit>,,false,143,,<clinit>,,,2,
64551,METHOD,<empty>,<empty>,<empty>,5,,protocol_binary.h,protocol_binary_request_header:<clinit>,,false,151,,<clinit>,,,4,
64571,METHOD,<empty>,<empty>,<empty>,5,,protocol_binary.h,protocol_binary_response_header:<clinit>,,false,170,,<clinit>,,,4,
64583,METHOD,<empty>,<empty>,<empty>,5,,protocol_binary.h,protocol_binary_request_no_extras:<clinit>,,false,188,,<clinit>,,,4,
64596,METHOD,<empty>,<empty>,<empty>,5,,protocol_binary.h,protocol_binary_response_no_extras:<clinit>,,false,198,,<clinit>,,,4,
64616,METHOD,<empty>,<empty>,<empty>,5,,protocol_binary.h,protocol_binary_response_get:<clinit>,,false,219,,<clinit>,,,4,
64639,METHOD,<empty>,<empty>,<empty>,5,,protocol_binary.h,protocol_binary_request_flush:<clinit>,,false,251,,<clinit>,,,4,
64659,METHOD,<empty>,<empty>,<empty>,5,,protocol_binary.h,protocol_binary_request_set:<clinit>,,false,271,,<clinit>,,,4,
64686,METHOD,<empty>,<empty>,<empty>,5,,protocol_binary.h,protocol_binary_request_incr:<clinit>,,false,309,,<clinit>,,,4,
64705,METHOD,<empty>,<empty>,<empty>,5,,protocol_binary.h,protocol_binary_response_incr:<clinit>,,false,327,,<clinit>,,,4,
64734,METHOD,<empty>,<empty>,<empty>,5,,protocol_binary.h,protocol_binary_request_touch:<clinit>,,false,392,,<clinit>,,,4,
64753,METHOD,<empty>,<empty>,<empty>,5,,protocol_binary.h,protocol_binary_request_gat:<clinit>,,false,410,,<clinit>,,,4,
64781,METHOD,<empty>,<empty>,<empty>,5,,protocol_binary.h,protocol_binary_request_rangeop:<clinit>,,false,440,,<clinit>,,,4,
64841,METHOD,proxy.h:<global>,TYPE_DECL,<global>,1,1,proxy.h,proxy.h:<global>,,false,1,485,<global>,,,1,
64883,METHOD,<empty>,<empty>,<empty>,1,,proxy.h,proxy_defines:<clinit>,,false,120,,<clinit>,,,40,
64894,METHOD,<empty>,<empty>,<empty>,1,,proxy.h,proxy_cmd_types:<clinit>,,false,132,,<clinit>,,,4,
64908,METHOD,<empty>,<empty>,<empty>,1,,proxy.h,proxy_be_failures:<clinit>,,false,138,,<clinit>,,,7,
64921,METHOD,<empty>,<empty>,<empty>,1,,proxy.h,proxy_int_stats:<clinit>,,false,163,,<clinit>,,,2,
64994,METHOD,proxy.h:<global>,TYPE_DECL,"typedef uint64_t (*key_hash_func)(const void *key, size_t len, uint64_t seed);",18,77,proxy.h,key_hash_func,,false,234,234,key_hash_func,,,18,"uint64_t key_hash_func (void*,size_t,uint64_t)"
65003,METHOD,proxy.h:<global>,TYPE_DECL,"typedef const char *(*key_hash_filter_func)(const char *conf, const char *key, size_t klen, size_t *newlen);",20,107,proxy.h,key_hash_filter_func,,false,238,238,key_hash_filter_func,,,20,"char* key_hash_filter_func (char*,char*,size_t,size_t*)"
65011,METHOD,proxy.h:<global>,TYPE_DECL,"typedef uint32_t (*hash_selector_func)(uint64_t hash, void *ctx);",18,64,proxy.h,hash_selector_func,,false,239,239,hash_selector_func,,,21,"uint32_t hash_selector_func (uint64_t,void*)"
65026,METHOD,<empty>,<empty>,<empty>,1,,proxy.h,mcp_backend_states:<clinit>,,false,245,,<clinit>,,,6,
65059,METHOD,<empty>,<empty>,<empty>,1,,proxy.h,mcp_parser_s:<clinit>,,false,265,,<clinit>,,,16,
65076,METHOD,<empty>,<empty>,<empty>,1,,proxy.h,mcp_request_s:<clinit>,,false,287,,<clinit>,,,9,
65116,METHOD,<empty>,<empty>,<empty>,1,,proxy.h,mcp_backend_s:<clinit>,,false,308,,<clinit>,,,27,
65170,METHOD,<empty>,<empty>,<empty>,1,,proxy.h,mcp_resp_mode:<clinit>,,false,362,,<clinit>,,,4,
65188,METHOD,<empty>,<empty>,<empty>,1,,proxy.h,mcp_resp_t:<clinit>,,false,369,,<clinit>,,,11,
65230,METHOD,<empty>,<empty>,<empty>,1,,proxy.h,_io_pending_proxy_t:<clinit>,,false,383,,<clinit>,,,23,
65260,METHOD,<empty>,<empty>,<empty>,1,,proxy.h,mcp_pool_s:<clinit>,,false,416,,<clinit>,,,16,
65274,METHOD,proxy.h:<global>,TYPE_DECL,void proxy_init_evthread_events(proxy_event_thread_t *t);,6,56,proxy.h,proxy_init_evthread_events,,false,437,437,proxy_init_evthread_events,,,50,void proxy_init_evthread_events (proxy_event_thread_t*)
65279,METHOD,proxy.h:<global>,TYPE_DECL,void *proxy_event_thread(void *arg);,6,35,proxy.h,proxy_event_thread,,false,438,438,proxy_event_thread,,,51,void* proxy_event_thread (void*)
65289,METHOD,<empty>,<empty>,<empty>,1,,proxy.h,mcp_await_e:<clinit>,,false,441,,<clinit>,,,5,
65296,METHOD,proxy.h:<global>,TYPE_DECL,int mcplib_await(lua_State *L);,5,30,proxy.h,mcplib_await,,false,447,447,mcplib_await,,,53,int mcplib_await (lua_State*)
65301,METHOD,proxy.h:<global>,TYPE_DECL,"int mcplib_await_run(conn *c, mc_resp *resp, lua_State *L, int coro_ref);",5,72,proxy.h,mcplib_await_run,,false,448,448,mcplib_await_run,,,54,"int mcplib_await_run (conn*,mc_resp*,lua_State*,int)"
65309,METHOD,proxy.h:<global>,TYPE_DECL,int mcplib_await_return(io_pending_proxy_t *p);,5,46,proxy.h,mcplib_await_return,,false,449,449,mcplib_await_return,,,55,int mcplib_await_return (io_pending_proxy_t*)
65314,METHOD,proxy.h:<global>,TYPE_DECL,int mcplib_add_stat(lua_State *L);,5,33,proxy.h,mcplib_add_stat,,false,452,452,mcplib_add_stat,,,56,int mcplib_add_stat (lua_State*)
65319,METHOD,proxy.h:<global>,TYPE_DECL,int mcplib_stat(lua_State *L);,5,29,proxy.h,mcplib_stat,,false,453,453,mcplib_stat,,,57,int mcplib_stat (lua_State*)
65324,METHOD,proxy.h:<global>,TYPE_DECL,size_t _process_request_next_key(mcp_parser_t *pr);,8,50,proxy.h,_process_request_next_key,,false,454,454,_process_request_next_key,,,58,size_t _process_request_next_key (mcp_parser_t*)
65329,METHOD,proxy.h:<global>,TYPE_DECL,"int process_request(mcp_parser_t *pr, const char *command, size_t cmdlen);",5,73,proxy.h,process_request,,false,455,455,process_request,,,59,"int process_request (mcp_parser_t*,char*,size_t)"
65336,METHOD,proxy.h:<global>,TYPE_DECL,"mcp_request_t *mcp_new_request(lua_State *L, mcp_parser_t *pr, const char *command, size_t cmdlen);",15,98,proxy.h,mcp_new_request,,false,456,456,mcp_new_request,,,60,"mcp_request_t* mcp_new_request (lua_State*,mcp_parser_t*,char*,size_t)"
65344,METHOD,proxy.h:<global>,TYPE_DECL,int mcplib_request(lua_State *L);,5,32,proxy.h,mcplib_request,,false,459,459,mcplib_request,,,61,int mcplib_request (lua_State*)
65349,METHOD,proxy.h:<global>,TYPE_DECL,int mcplib_request_command(lua_State *L);,5,40,proxy.h,mcplib_request_command,,false,460,460,mcplib_request_command,,,62,int mcplib_request_command (lua_State*)
65354,METHOD,proxy.h:<global>,TYPE_DECL,int mcplib_request_key(lua_State *L);,5,36,proxy.h,mcplib_request_key,,false,461,461,mcplib_request_key,,,63,int mcplib_request_key (lua_State*)
65359,METHOD,proxy.h:<global>,TYPE_DECL,int mcplib_request_ltrimkey(lua_State *L);,5,41,proxy.h,mcplib_request_ltrimkey,,false,462,462,mcplib_request_ltrimkey,,,64,int mcplib_request_ltrimkey (lua_State*)
65364,METHOD,proxy.h:<global>,TYPE_DECL,int mcplib_request_rtrimkey(lua_State *L);,5,41,proxy.h,mcplib_request_rtrimkey,,false,463,463,mcplib_request_rtrimkey,,,65,int mcplib_request_rtrimkey (lua_State*)
65369,METHOD,proxy.h:<global>,TYPE_DECL,int mcplib_request_token(lua_State *L);,5,38,proxy.h,mcplib_request_token,,false,464,464,mcplib_request_token,,,66,int mcplib_request_token (lua_State*)
65374,METHOD,proxy.h:<global>,TYPE_DECL,int mcplib_request_ntokens(lua_State *L);,5,40,proxy.h,mcplib_request_ntokens,,false,465,465,mcplib_request_ntokens,,,67,int mcplib_request_ntokens (lua_State*)
65379,METHOD,proxy.h:<global>,TYPE_DECL,int mcplib_request_has_flag(lua_State *L);,5,41,proxy.h,mcplib_request_has_flag,,false,466,466,mcplib_request_has_flag,,,68,int mcplib_request_has_flag (lua_State*)
65384,METHOD,proxy.h:<global>,TYPE_DECL,int mcplib_request_flag_token(lua_State *L);,5,43,proxy.h,mcplib_request_flag_token,,false,467,467,mcplib_request_flag_token,,,69,int mcplib_request_flag_token (lua_State*)
65389,METHOD,proxy.h:<global>,TYPE_DECL,int mcplib_request_gc(lua_State *L);,5,35,proxy.h,mcplib_request_gc,,false,468,468,mcplib_request_gc,,,70,int mcplib_request_gc (lua_State*)
65394,METHOD,proxy.h:<global>,TYPE_DECL,int mcplib_open_dist_jump_hash(lua_State *L);,5,44,proxy.h,mcplib_open_dist_jump_hash,,false,470,470,mcplib_open_dist_jump_hash,,,71,int mcplib_open_dist_jump_hash (lua_State*)
65399,METHOD,proxy.h:<global>,TYPE_DECL,int mcplib_open_dist_ring_hash(lua_State *L);,5,44,proxy.h,mcplib_open_dist_ring_hash,,false,471,471,mcplib_open_dist_ring_hash,,,72,int mcplib_open_dist_ring_hash (lua_State*)
65404,METHOD,proxy.h:<global>,TYPE_DECL,"int proxy_run_coroutine(lua_State *Lc, mc_resp *resp, io_pending_proxy_t *p, conn *c);",5,85,proxy.h,proxy_run_coroutine,,false,473,473,proxy_run_coroutine,,,73,"int proxy_run_coroutine (lua_State*,mc_resp*,io_pending_proxy_t*,conn*)"
65412,METHOD,proxy.h:<global>,TYPE_DECL,"mcp_backend_t *mcplib_pool_proxy_call_helper(lua_State *L, mcp_pool_t *p, const char *key, size_t len);",15,102,proxy.h,mcplib_pool_proxy_call_helper,,false,474,474,mcplib_pool_proxy_call_helper,,,74,"mcp_backend_t* mcplib_pool_proxy_call_helper (lua_State*,mcp_pool_t*,char*,size_t)"
65420,METHOD,proxy.h:<global>,TYPE_DECL,"void mcp_request_attach(lua_State *L, mcp_request_t *rq, io_pending_proxy_t *p);",6,79,proxy.h,mcp_request_attach,,false,475,475,mcp_request_attach,,,75,"void mcp_request_attach (lua_State*,mcp_request_t*,io_pending_proxy_t*)"
65427,METHOD,proxy.h:<global>,TYPE_DECL,"void proxy_lua_error(lua_State *L, const char *s);",6,49,proxy.h,proxy_lua_error,,false,476,476,proxy_lua_error,,,76,"void proxy_lua_error (lua_State*,char*)"
65433,METHOD,proxy.h:<global>,TYPE_DECL,"void proxy_lua_ferror(lua_State *L, const char *fmt, ...);",6,57,proxy.h,proxy_lua_ferror,,false,477,477,proxy_lua_ferror,,,77,"void proxy_lua_ferror (lua_State*,char*...)"
65439,METHOD,proxy.h:<global>,TYPE_DECL,int _start_proxy_config_threads(proxy_ctx_t *ctx);,5,49,proxy.h,_start_proxy_config_threads,,false,478,478,_start_proxy_config_threads,,,78,int _start_proxy_config_threads (proxy_ctx_t*)
65444,METHOD,proxy.h:<global>,TYPE_DECL,int proxy_thread_loadconf(LIBEVENT_THREAD *thr);,5,47,proxy.h,proxy_thread_loadconf,,false,479,479,proxy_thread_loadconf,,,79,int proxy_thread_loadconf (LIBEVENT_THREAD*)
65449,METHOD,proxy.h:<global>,TYPE_DECL,int mcplib_open_hash_xxhash(lua_State *L);,5,41,proxy.h,mcplib_open_hash_xxhash,,false,482,482,mcplib_open_hash_xxhash,,,80,int mcplib_open_hash_xxhash (lua_State*)
65454,METHOD,proxy.h:<global>,TYPE_DECL,__attribute__((unused)) void dump_stack(lua_State *L);,30,53,proxy.h,dump_stack,,false,484,484,dump_stack,,,81,void dump_stack (lua_State*)
65464,METHOD,proxy_await.c:<global>,TYPE_DECL,<global>,1,1,proxy_await.c,proxy_await.c:<global>,,false,1,366,<global>,,,1,
65479,METHOD,proxy_await.c:<global>,TYPE_DECL,"int mcplib_await(lua_State *L) {
    mcp_request_t *rq = luaL_checkudata(L, 1, ""mcp.request"");
    luaL_checktype(L, 2, LUA_TTABLE);
    int n = 0; // length of table of pools
    int wait_for = 0; // 0 means wait for all responses
    enum mcp_await_e type = AWAIT_GOOD;

    lua_pushnil(L); // init table key
    while (lua_next(L, 2) != 0) {
        luaL_checkudata(L, -1, ""mcp.pool_proxy"");
        lua_pop(L, 1); // remove value, keep key.
        n++;
    }

    if (n <= 0) {
        proxy_lua_error(L, ""mcp.await arguments must have at least one pool"");
    }

    if (lua_isnumber(L, 4)) {
        type = lua_tointeger(L, 4);
        lua_pop(L, 1);
        switch (type) {
            case AWAIT_GOOD:
            case AWAIT_ANY:
            case AWAIT_OK:
            case AWAIT_FIRST:
                break;
            default:
                proxy_lua_error(L, ""invalid type argument tp mcp.await"");
        }
    }

    if (lua_isnumber(L, 3)) {
        wait_for = lua_tointeger(L, ...",1,4,proxy_await.c,mcplib_await,,false,26,91,mcplib_await,,,3,int mcplib_await (lua_State*)
65651,METHOD,proxy_await.c:<global>,TYPE_DECL,"static void mcp_queue_await_io(conn *c, lua_State *Lc, mcp_request_t *rq, int await_ref, bool await_first) {
    io_queue_t *q = conn_io_queue_get(c, IO_QUEUE_PROXY);

    mcp_backend_t *be = rq->be;

    // Then we push a response object, which we'll re-use later.
    // reserve one uservalue for a lua-supplied response.
    mcp_resp_t *r = lua_newuserdatauv(Lc, sizeof(mcp_resp_t), 1);
    memset(r, 0, sizeof(mcp_resp_t));
    // Set noreply mode.
    // TODO (v2): the response ""inherits"" the request's noreply mode, which isn't
    // strictly correct; we should inherit based on the request that spawned
    // the coroutine but the structure doesn't allow that yet.
    // Should also be able to settle this exact mode from the parser so we
    // don't have to re-branch here.
    if (rq->pr.noreply) {
        if (rq->pr.cmd_type == CMD_TYPE_META) {
            r->mode = RESP_MODE_METAQUIET;
            for (int x = 2; x < rq->pr.ntokens; x++) {
                if (rq->request[rq->pr...",1,41,proxy_await.c,mcp_queue_await_io,,false,93,176,mcp_queue_await_io,,,4,"void mcp_queue_await_io (conn*,lua_State*,mcp_request_t*,int,bool)"
65974,METHOD,proxy_await.c:<global>,TYPE_DECL,"int mcplib_await_run(conn *c, mc_resp *resp, lua_State *L, int coro_ref) {
    P_DEBUG(""%s: start\n"", __func__);
    mcp_await_t *aw = lua_touserdata(L, -1);
    int await_ref = luaL_ref(L, LUA_REGISTRYINDEX); // await is popped.
    assert(aw != NULL);
    lua_rawgeti(L, LUA_REGISTRYINDEX, aw->argtable_ref); // -> 1
    //dump_stack(L);
    mcp_request_t *rq = aw->rq;
    aw->coro_ref = coro_ref;

    // create result table
    lua_newtable(L); // -> 2
    aw->restable_ref = luaL_ref(L, LUA_REGISTRYINDEX); // pop the result table

    // prepare the request key
    const char *key = MCP_PARSER_KEY(rq->pr);
    size_t len = rq->pr.klen;
    int n = 0;
    bool await_first = true;
    // loop arg table and run each hash selector
    lua_pushnil(L); // -> 3
    while (lua_next(L, 1) != 0) {
        P_DEBUG(""%s: top of loop\n"", __func__);
        // (key, -2), (val, -1)
        mcp_pool_proxy_t *pp = luaL_testudata(L, -1, ""mcp.pool_proxy"");
        if (pp == NULL) {
            proxy_l...",1,4,proxy_await.c,mcplib_await_run,,false,182,231,mcplib_await_run,,,5,"int mcplib_await_run (conn*,mc_resp*,lua_State*,int)"
66131,METHOD,proxy_await.c:<global>,TYPE_DECL,"int mcplib_await_return(io_pending_proxy_t *p) {
    mcp_await_t *aw;
    lua_State *L = p->thread->L; // use the main VM coroutine for work
    bool cleanup = false;
    bool valid = false; // is response valid to add to the result table.
    bool completing = false;

    // TODO (v2): just push the await ptr into *p?
    lua_rawgeti(L, LUA_REGISTRYINDEX, p->await_ref);
    aw = lua_touserdata(L, -1);
    lua_pop(L, 1); // remove AW object from stack
    assert(aw != NULL);
    P_DEBUG(""%s: start [pending: %d]\n"", __func__, aw->pending);
    //dump_stack(L);

    aw->pending--;
    assert(aw->pending >= 0);
    // Await not yet satisfied.
    // If wait_for != 0 check for response success
    // if success and wait_for is *now* 0, we complete.
    // add successful response to response table
    // Also, if no wait_for, add response to response table
    // TODO (v2): for GOOD or OK cases, it might be better to return the
    // last object as valid if there are otherwise zero vali...",1,4,proxy_await.c,mcplib_await_return,,false,238,366,mcplib_await_return,,,6,int mcplib_await_return (io_pending_proxy_t*)
66468,METHOD,proxy_config.c:<global>,TYPE_DECL,<global>,1,1,proxy_config.c,proxy_config.c:<global>,,false,1,423,<global>,,,1,
66474,METHOD,proxy_config.c:<global>,TYPE_DECL,"static int _dump_helper(lua_State *L, const void *p, size_t sz, void *ud) {
    (void)L;
    struct _dumpbuf *db = ud;
    if (db->used + sz > db->size) {
        db->size *= 2;
        char *nb = realloc(db->buf, db->size);
        if (nb == NULL) {
            return -1;
        }
        db->buf = nb;
    }
    memcpy(db->buf + db->used, (const char *)p, sz);
    db->used += sz;
    return 0;
}",1,1,proxy_config.c,_dump_helper,,false,13,27,_dump_helper,,,2,"int _dump_helper (lua_State*,void*,size_t,void*)"
66547,METHOD,proxy_config.c:<global>,TYPE_DECL,"static const char * _load_helper(lua_State *L, void *data, size_t *size) {
    (void)L;
    struct _dumpbuf *db = data;
    if (db->used == 0) {
        *size = 0;
        return NULL;
    }
    *size = db->used;
    db->used = 0;
    return db->buf;
}",1,1,proxy_config.c,_load_helper,,false,29,39,_load_helper,,,3,"const char* _load_helper (lua_State*,void*,size_t*)"
66589,METHOD,proxy_config.c:<global>,TYPE_DECL,"void proxy_start_reload(void *arg) {
    proxy_ctx_t *ctx = arg;
    if (pthread_mutex_trylock(&ctx->config_lock) == 0) {
        pthread_cond_signal(&ctx->config_cond);
        pthread_mutex_unlock(&ctx->config_lock);
    }
}",1,1,proxy_config.c,proxy_start_reload,,false,41,47,proxy_start_reload,,,4,void proxy_start_reload (void*)
66617,METHOD,proxy_config.c:<global>,TYPE_DECL,"static void *_proxy_manager_thread(void *arg) {
    proxy_ctx_t *ctx = arg;
    pool_head_t head;

    pthread_mutex_lock(&ctx->manager_lock);
    while (1) {
        STAILQ_INIT(&head);
        while (STAILQ_EMPTY(&ctx->manager_head)) {
            pthread_cond_wait(&ctx->manager_cond, &ctx->manager_lock);
        }

        // pull dealloc queue into local queue.
        STAILQ_CONCAT(&head, &ctx->manager_head);
        pthread_mutex_unlock(&ctx->manager_lock);

        // Config lock is required for using config VM.
        pthread_mutex_lock(&ctx->config_lock);
        lua_State *L = ctx->proxy_state;
        mcp_pool_t *p;
        STAILQ_FOREACH(p, &head, next) {
            // we let the pool object _gc() handle backend references.

            luaL_unref(L, LUA_REGISTRYINDEX, p->phc_ref);
            // need to... unref self.
            // NOTE: double check if we really need to self-reference.
            // this is a backup here to ensure the external refcounts hit zero
  ...",1,8,proxy_config.c,_proxy_manager_thread,,false,50,87,_proxy_manager_thread,,,5,void* _proxy_manager_thread (void*)
66816,METHOD,proxy_config.c:<global>,TYPE_DECL,"static void *_proxy_config_thread(void *arg) {
    proxy_ctx_t *ctx = arg;

    logger_create();
    pthread_mutex_lock(&ctx->config_lock);
    while (1) {
        pthread_cond_wait(&ctx->config_cond, &ctx->config_lock);
        LOGGER_LOG(NULL, LOG_PROXYEVENTS, LOGGER_PROXY_CONFIG, NULL, ""start"");
        STAT_INCR(ctx, config_reloads, 1);
        lua_State *L = ctx->proxy_state;
        lua_settop(L, 0); // clear off any crud that could have been left on the stack.

        // The main stages of config reload are:
        // - load and execute the config file
        // - run mcp_config_pools()
        // - for each worker:
        //   - copy and execute new lua code
        //   - copy selector table
        //   - run mcp_config_routes()

        if (proxy_load_config(ctx) != 0) {
            // Failed to load. log and wait for a retry.
            STAT_INCR(ctx, config_reload_fails, 1);
            LOGGER_LOG(NULL, LOG_PROXYEVENTS, LOGGER_PROXY_CONFIG, NULL, ""failed"");
       ...",1,8,proxy_config.c,_proxy_config_thread,,false,100,157,_proxy_config_thread,,,6,void* _proxy_config_thread (void*)
67134,METHOD,proxy_config.c:<global>,TYPE_DECL,"int _start_proxy_config_threads(proxy_ctx_t *ctx) {
    int ret;

    pthread_mutex_lock(&ctx->config_lock);
    if ((ret = pthread_create(&ctx->config_tid, NULL,
                    _proxy_config_thread, ctx)) != 0) {
        fprintf(stderr, ""Failed to start proxy configuration thread: %s\n"",
                strerror(ret));
        pthread_mutex_unlock(&ctx->config_lock);
        return -1;
    }
    pthread_mutex_unlock(&ctx->config_lock);

    pthread_mutex_lock(&ctx->manager_lock);
    if ((ret = pthread_create(&ctx->manager_tid, NULL,
                    _proxy_manager_thread, ctx)) != 0) {
        fprintf(stderr, ""Failed to start proxy configuration thread: %s\n"",
                strerror(ret));
        pthread_mutex_unlock(&ctx->manager_lock);
        return -1;
    }
    pthread_mutex_unlock(&ctx->manager_lock);

    return 0;
}",1,1,proxy_config.c,_start_proxy_config_threads,,false,159,183,_start_proxy_config_threads,,,7,int _start_proxy_config_threads (proxy_ctx_t*)
67216,METHOD,proxy_config.c:<global>,TYPE_DECL,"int proxy_load_config(void *arg) {
    proxy_ctx_t *ctx = arg;
    lua_State *L = ctx->proxy_state;
    int res = luaL_loadfile(L, settings.proxy_startfile);
    if (res != LUA_OK) {
        fprintf(stderr, ""ERROR: Failed to load proxy_startfile: %s\n"", lua_tostring(L, -1));
        return -1;
    }
    // LUA_OK, LUA_ERRSYNTAX, LUA_ERRMEM, LUA_ERRFILE

    // Now we need to dump the compiled code into bytecode.
    // This will then get loaded into worker threads.
    struct _dumpbuf *db = malloc(sizeof(struct _dumpbuf));
    db->size = 16384;
    db->used = 0;
    db->buf = malloc(db->size);
    lua_dump(L, _dump_helper, db, 0);
    // 0 means no error.
    ctx->proxy_code = db;

    // now we complete the data load by calling the function.
    res = lua_pcall(L, 0, LUA_MULTRET, 0);
    if (res != LUA_OK) {
        fprintf(stderr, ""ERROR: Failed to load data into lua config state: %s\n"", lua_tostring(L, -1));
        exit(EXIT_FAILURE);
    }

    // call the mcp_config_pools func...",1,1,proxy_config.c,proxy_load_config,,false,185,227,proxy_load_config,,,8,int proxy_load_config (void*)
67345,METHOD,proxy_config.c:<global>,TYPE_DECL,"static int _copy_pool(lua_State *from, lua_State *to) {
    // from, -3 should have he userdata.
    mcp_pool_t *p = luaL_checkudata(from, -3, ""mcp.pool"");
    size_t size = sizeof(mcp_pool_proxy_t);
    mcp_pool_proxy_t *pp = lua_newuserdatauv(to, size, 0);
    luaL_setmetatable(to, ""mcp.pool_proxy"");

    pp->main = p;
    pthread_mutex_lock(&p->lock);
    p->refcount++;
    pthread_mutex_unlock(&p->lock);
    return 0;
}",1,1,proxy_config.c,_copy_pool,,false,229,241,_copy_pool,,,9,"int _copy_pool (lua_State*,lua_State*)"
67395,METHOD,proxy_config.c:<global>,TYPE_DECL,"static void _copy_config_table(lua_State *from, lua_State *to);",13,62,proxy_config.c,_copy_config_table,,false,243,243,_copy_config_table,,,10,"void _copy_config_table (lua_State*,lua_State*)"
67401,METHOD,proxy_config.c:<global>,TYPE_DECL,"static void _copy_config_table(lua_State *from, lua_State *to) {
    int type = lua_type(from, -1);
    bool found = false;
    luaL_checkstack(from, 4, ""configuration error: table recursion too deep"");
    luaL_checkstack(to, 4, ""configuration error: table recursion too deep"");
    switch (type) {
        case LUA_TNIL:
            lua_pushnil(to);
            break;
        case LUA_TUSERDATA:
            // see dump_stack() - check if it's something we handle.
            if (lua_getmetatable(from, -1) != 0) {
                lua_pushstring(from, ""__name"");
                if (lua_rawget(from, -2) != LUA_TNIL) {
                    const char *name = lua_tostring(from, -1);
                    if (strcmp(name, ""mcp.pool"") == 0) {
                        _copy_pool(from, to);
                        found = true;
                    }
                }
                lua_pop(from, 2);
            }
            if (!found) {
                proxy_lua_ferror(from, ""unhandled userda...",1,1,proxy_config.c,_copy_config_table,,false,246,329,_copy_config_table,,,11,"void _copy_config_table (lua_State*,lua_State*)"
67622,METHOD,proxy_config.c:<global>,TYPE_DECL,"void proxy_worker_reload(void *arg, LIBEVENT_THREAD *thr) {
    proxy_ctx_t *ctx = arg;
    pthread_mutex_lock(&ctx->worker_lock);
    if (proxy_thread_loadconf(thr) != 0) {
        ctx->worker_failed = true;
    }
    ctx->worker_done = true;
    pthread_cond_signal(&ctx->worker_cond);
    pthread_mutex_unlock(&ctx->worker_lock);
}",1,1,proxy_config.c,proxy_worker_reload,,false,333,342,proxy_worker_reload,,,12,"void proxy_worker_reload (void*,LIBEVENT_THREAD*)"
67663,METHOD,proxy_config.c:<global>,TYPE_DECL,"int proxy_thread_loadconf(LIBEVENT_THREAD *thr) {
    lua_State *L = thr->L;
    // load the precompiled config function.
    proxy_ctx_t *ctx = settings.proxy_ctx;
    struct _dumpbuf *db = ctx->proxy_code;
    struct _dumpbuf db2; // copy because the helper modifies it.
    memcpy(&db2, db, sizeof(struct _dumpbuf));

    lua_load(L, _load_helper, &db2, ""config"", NULL);
    // LUA_OK + all errs from loadfile except LUA_ERRFILE.
    //dump_stack(L);
    // - pcall the func (which should load it)
    int res = lua_pcall(L, 0, LUA_MULTRET, 0);
    if (res != LUA_OK) {
        // FIXME (v2): don't exit here!
        fprintf(stderr, ""Failed to load data into worker thread\n"");
        return -1;
    }

    lua_getglobal(L, ""mcp_config_routes"");
    // create deepcopy of argument to pass into mcp_config_routes.
    // FIXME (v2): to avoid lua SIGABRT'ing on errors we need to protect the call
    // normal pattern:
    // lua_pushcfunction(L, &_copy_config_table);
    // lua_pushlightuser...",1,4,proxy_config.c,proxy_thread_loadconf,,false,346,422,proxy_thread_loadconf,,,13,int proxy_thread_loadconf (LIBEVENT_THREAD*)
67875,METHOD,proxy_jump_hash.c:<global>,TYPE_DECL,<global>,1,1,proxy_jump_hash.c,proxy_jump_hash.c:<global>,,false,1,51,<global>,,,1,
67882,METHOD,proxy_jump_hash.c:<global>,TYPE_DECL,"static uint32_t mcplib_dist_jump_hash_get_server(uint64_t hash, void *ctx) {
    mcplib_jump_hash_t *jh = ctx;

    int64_t b = -1, j = 0;
    while (j < jh->buckets) {
        b = j;
        hash = hash * 2862933555777941757ULL + 1;
        j = (b + 1) * ((double)(1LL << 31) / (double)((hash >> 33) + 1));
    }
    return b;
}",1,1,proxy_jump_hash.c,mcplib_dist_jump_hash_get_server,,false,10,20,mcplib_dist_jump_hash_get_server,,,3,"uint32_t mcplib_dist_jump_hash_get_server (uint64_t,void*)"
67939,METHOD,proxy_jump_hash.c:<global>,TYPE_DECL,"static int mcplib_dist_jump_hash_new(lua_State *L) {
    luaL_checktype(L, 1, LUA_TTABLE);
    lua_Unsigned buckets = lua_rawlen(L, 1);

    mcplib_jump_hash_t *jh = lua_newuserdatauv(L, sizeof(mcplib_jump_hash_t), 0);

    // don't need to loop through the table at all, just need its length.
    // could optimize startup time by adding hints to the module for how to
    // format pool (ie; just a total count or the full table)
    jh->buckets = buckets;
    jh->phc.ctx = jh;
    jh->phc.selector_func = mcplib_dist_jump_hash_get_server;

    lua_pushlightuserdata(L, &jh->phc);

    // - return [UD, lightuserdata]
    return 2;
}",1,1,proxy_jump_hash.c,mcplib_dist_jump_hash_new,,false,23,40,mcplib_dist_jump_hash_new,,,4,int mcplib_dist_jump_hash_new (lua_State*)
67989,METHOD,proxy_jump_hash.c:<global>,TYPE_DECL,"int mcplib_open_dist_jump_hash(lua_State *L) {
    const struct luaL_Reg jump_f[] = {
        {""new"", mcplib_dist_jump_hash_new},
        {NULL, NULL},
    };

    luaL_newlib(L, jump_f);

    return 1;
}",1,1,proxy_jump_hash.c,mcplib_open_dist_jump_hash,,false,42,51,mcplib_open_dist_jump_hash,,,5,int mcplib_open_dist_jump_hash (lua_State*)
68014,METHOD,proxy_lua.c:<global>,TYPE_DECL,<global>,1,1,proxy_lua.c,proxy_lua.c:<global>,,false,1,996,<global>,,,1,
68016,METHOD,proxy_lua.c:<global>,TYPE_DECL,"static int mcplib_response_ok(lua_State *L) {
    mcp_resp_t *r = luaL_checkudata(L, -1, ""mcp.response"");

    if (r->status == MCMC_OK) {
        lua_pushboolean(L, 1);
    } else {
        lua_pushboolean(L, 0);
    }

    return 1;
}",1,21,proxy_lua.c,mcplib_response_ok,,false,11,21,mcplib_response_ok,,,1,int mcplib_response_ok (lua_State*)
68048,METHOD,proxy_lua.c:<global>,TYPE_DECL,"static int mcplib_response_hit(lua_State *L) {
    mcp_resp_t *r = luaL_checkudata(L, -1, ""mcp.response"");

    if (r->status == MCMC_OK && r->resp.code != MCMC_CODE_MISS) {
        lua_pushboolean(L, 1);
    } else {
        lua_pushboolean(L, 0);
    }

    return 1;
}",1,21,proxy_lua.c,mcplib_response_hit,,false,23,33,mcplib_response_hit,,,2,int mcplib_response_hit (lua_State*)
68090,METHOD,proxy_lua.c:<global>,TYPE_DECL,"static int mcplib_response_vlen(lua_State *L) {
    mcp_resp_t *r = luaL_checkudata(L, -1, ""mcp.response"");

    // We do remove the ""\r\n"" from the value length, so if you're actually
    // processing the value nothing breaks.
    if (r->resp.vlen >= 2) {
        lua_pushinteger(L, r->resp.vlen-2);
    } else {
        lua_pushinteger(L, 0);
    }

    return 1;
}",1,1,proxy_lua.c,mcplib_response_vlen,,false,38,50,mcplib_response_vlen,,,3,int mcplib_response_vlen (lua_State*)
68128,METHOD,proxy_lua.c:<global>,TYPE_DECL,"static int mcplib_response_code(lua_State *L) {
    mcp_resp_t *r = luaL_checkudata(L, -1, ""mcp.response"");

    lua_pushinteger(L, r->resp.code);

    return 1;
}",1,1,proxy_lua.c,mcplib_response_code,,false,53,59,mcplib_response_code,,,4,int mcplib_response_code (lua_State*)
68150,METHOD,proxy_lua.c:<global>,TYPE_DECL,"static int mcplib_response_line(lua_State *L) {
    mcp_resp_t *r = luaL_checkudata(L, -1, ""mcp.response"");

    if (r->resp.rline != NULL) {
        lua_pushlstring(L, r->resp.rline, r->resp.rlen);
    } else {
        lua_pushnil(L);
    }

    return 1;
}",1,1,proxy_lua.c,mcplib_response_line,,false,62,72,mcplib_response_line,,,5,int mcplib_response_line (lua_State*)
68190,METHOD,proxy_lua.c:<global>,TYPE_DECL,"static int mcplib_response_gc(lua_State *L) {
    mcp_resp_t *r = luaL_checkudata(L, -1, ""mcp.response"");

    // On error/similar we might be holding the read buffer.
    // If the buf is handed off to mc_resp for return, this pointer is NULL
    if (r->buf != NULL) {
        free(r->buf);
    }

    return 0;
}",1,1,proxy_lua.c,mcplib_response_gc,,false,74,84,mcplib_response_gc,,,6,int mcplib_response_gc (lua_State*)
68216,METHOD,proxy_lua.c:<global>,TYPE_DECL,"static int mcplib_backend_gc(lua_State *L) {
    mcp_backend_t *be = luaL_checkudata(L, -1, ""mcp.backend"");

    assert(STAILQ_EMPTY(&be->io_head));

    mcmc_disconnect(be->client);
    free(be->client);

    // FIXME (v2): upvalue for global ctx.
    proxy_ctx_t *ctx = settings.proxy_ctx;
    STAT_DECR(ctx, backend_total, 1);

    return 0;
}",1,11,proxy_lua.c,mcplib_backend_gc,,false,93,106,mcplib_backend_gc,,,7,int mcplib_backend_gc (lua_State*)
68281,METHOD,proxy_lua.c:<global>,TYPE_DECL,"static int mcplib_backend(lua_State *L) {
    luaL_checkstring(L, -3); // label for indexing backends.
    size_t nlen = 0;
    const char *name = luaL_checklstring(L, -2, &nlen);
    const char *port = luaL_checkstring(L, -1);
    // FIXME (v2): upvalue for global ctx.
    proxy_ctx_t *ctx = settings.proxy_ctx;

    if (nlen > MAX_NAMELEN-1) {
        proxy_lua_error(L, ""backend name too long"");
        return 0;
    }

    // first check our reference table to compare.
    lua_pushvalue(L, 1);
    int ret = lua_gettable(L, lua_upvalueindex(MCP_BACKEND_UPVALUE));
    if (ret != LUA_TNIL) {
        mcp_backend_t *be_orig = luaL_checkudata(L, -1, ""mcp.backend"");
        if (strncmp(be_orig->name, name, MAX_NAMELEN) == 0
                && strncmp(be_orig->port, port, MAX_PORTLEN) == 0) {
            // backend is the same, return it.
            return 1;
        } else {
            // backend not the same, pop from stack and make new one.
            lua_pop(L, 1);
        }
    } ...",1,15,proxy_lua.c,mcplib_backend,,false,108,214,mcplib_backend,,,8,int mcplib_backend (lua_State*)
68689,METHOD,proxy_lua.c:<global>,TYPE_DECL,"static int mcplib_pool_gc(lua_State *L) {
    mcp_pool_t *p = luaL_checkudata(L, -1, ""mcp.pool"");
    assert(p->refcount == 0);
    pthread_mutex_destroy(&p->lock);

    for (int x = 0; x < p->pool_size; x++) {
        if (p->pool[x].ref) {
            luaL_unref(L, LUA_REGISTRYINDEX, p->pool[x].ref);
        }
    }

    return 0;
}",1,1,proxy_lua.c,mcplib_pool_gc,,false,216,228,mcplib_pool_gc,,,9,int mcplib_pool_gc (lua_State*)
68748,METHOD,proxy_lua.c:<global>,TYPE_DECL,"static const char *mcp_key_hash_filter_stop(const char *conf, const char *key, size_t klen, size_t *newlen) {
    char temp[KEY_MAX_LENGTH+1];
    *newlen = klen;
    if (klen > KEY_MAX_LENGTH) {
        // Hedging against potential bugs.
        return key;
    }

    memcpy(temp, key, klen);
    temp[klen+1] = '\0';

    // TODO (v2): memmem would avoid the temp key and memcpy here, but it's
    // not technically portable. An easy improvement would be to detect
    // memmem() in `configure` and only use strstr/copy as a fallback.
    // Since keys are short it's unlikely this would be a major performance
    // win.
    char *found = strstr(temp, conf);

    if (found) {
        *newlen = found - temp;
    }

    // hash stop can't change where keys start.
    return key;
}",1,14,proxy_lua.c,mcp_key_hash_filter_stop,,false,233,257,mcp_key_hash_filter_stop,,,10,"const char* mcp_key_hash_filter_stop (char*,char*,size_t,size_t*)"
68798,METHOD,proxy_lua.c:<global>,TYPE_DECL,"static const char *mcp_key_hash_filter_tag(const char *conf, const char *key, size_t klen, size_t *newlen) {
    *newlen = klen;

    const char *t1 = memchr(key, conf[0], klen);
    if (t1) {
        size_t remain = klen - (t1 - key);
        // must be at least one character inbetween the tags to hash.
        if (remain > 1) {
            const char *t2 = memchr(t1, conf[1], remain);

            if (t2) {
                *newlen = t2 - t1 - 1;
                return t1+1;
            }
        }
    }

    return key;
}",1,1,proxy_lua.c,mcp_key_hash_filter_tag,,false,262,280,mcp_key_hash_filter_tag,,,11,"const char* mcp_key_hash_filter_tag (char*,char*,size_t,size_t*)"
68861,METHOD,proxy_lua.c:<global>,TYPE_DECL,"static void _mcplib_pool_dist(lua_State *L, mcp_pool_t *p) {
    luaL_checktype(L, -1, LUA_TTABLE);
    if (lua_getfield(L, -1, ""new"") != LUA_TFUNCTION) {
        proxy_lua_error(L, ""key distribution object missing 'new' function"");
        return;
    }

    // - now create the copy pool table
    lua_createtable(L, p->pool_size, 0); // give the new pool table a sizing hint.
    for (int x = 1; x <= p->pool_size; x++) {
        mcp_backend_t *be = p->pool[x-1].be;
        lua_createtable(L, 0, 4);
        // stack = [p, h, f, optN, newpool, backend]
        // the key should be fine for id? maybe don't need to duplicate
        // this?
        lua_pushinteger(L, x);
        lua_setfield(L, -2, ""id"");
        // we don't use the hostname for ketama hashing
        // so passing ip for hostname is fine
        lua_pushstring(L, be->name);
        lua_setfield(L, -2, ""addr"");
        lua_pushstring(L, be->port);
        lua_setfield(L, -2, ""port"");

        // set the backend table i...",1,1,proxy_lua.c,_mcplib_pool_dist,,false,282,336,_mcplib_pool_dist,,,12,"void _mcplib_pool_dist (lua_State*,mcp_pool_t*)"
69009,METHOD,proxy_lua.c:<global>,TYPE_DECL,"static int mcplib_pool(lua_State *L) {
    int argc = lua_gettop(L);
    luaL_checktype(L, 1, LUA_TTABLE);
    int n = luaL_len(L, 1); // get length of array table

    size_t plen = sizeof(mcp_pool_t) + sizeof(mcp_pool_be_t) * n;
    mcp_pool_t *p = lua_newuserdatauv(L, plen, 0);
    // Zero the memory before use, so we can realibly use __gc to clean up
    memset(p, 0, plen);
    p->pool_size = n;
    // TODO (v2): Nicer if this is fetched from mcp.default_key_hash
    p->key_hasher = XXH3_64bits_withSeed;
    pthread_mutex_init(&p->lock, NULL);
    p->ctx = settings.proxy_ctx; // TODO (v2): store ctx in upvalue.

    luaL_setmetatable(L, ""mcp.pool"");

    lua_pushvalue(L, -1); // dupe self for reference.
    p->self_ref = luaL_ref(L, LUA_REGISTRYINDEX);

    // remember lua arrays are 1 indexed.
    for (int x = 1; x <= n; x++) {
        mcp_pool_be_t *s = &p->pool[x-1];
        lua_geti(L, 1, x); // get next server into the stack.
        // If we bail here, the pool _gc() shoul...",1,20,proxy_lua.c,mcplib_pool,,false,339,455,mcplib_pool,,,13,int mcplib_pool (lua_State*)
69408,METHOD,proxy_lua.c:<global>,TYPE_DECL,"static int mcplib_pool_proxy_gc(lua_State *L) {
    mcp_pool_proxy_t *pp = luaL_checkudata(L, -1, ""mcp.pool_proxy"");
    mcp_pool_t *p = pp->main;
    pthread_mutex_lock(&p->lock);
    p->refcount--;
    if (p->refcount == 0) {
        proxy_ctx_t *ctx = p->ctx;
        pthread_mutex_lock(&ctx->manager_lock);
        STAILQ_INSERT_TAIL(&ctx->manager_head, p, next);
        pthread_cond_signal(&ctx->manager_cond);
        pthread_mutex_unlock(&ctx->manager_lock);
    }
    pthread_mutex_unlock(&p->lock);

    return 0;
}",1,8,proxy_lua.c,mcplib_pool_proxy_gc,,false,457,472,mcplib_pool_proxy_gc,,,14,int mcplib_pool_proxy_gc (lua_State*)
69510,METHOD,proxy_lua.c:<global>,TYPE_DECL,"mcp_backend_t *mcplib_pool_proxy_call_helper(lua_State *L, mcp_pool_t *p, const char *key, size_t len) {
    if (p->key_filter) {
        key = p->key_filter(p->key_filter_conf, key, len, &len);
        P_DEBUG(""%s: filtered key for hashing (%.*s)\n"", __func__, (int)len, key);
    }
    uint64_t hash = p->key_hasher(key, len, p->hash_seed);
    uint32_t lookup = p->phc.selector_func(hash, p->phc.ctx);

    assert(p->phc.ctx != NULL);
    // attach the backend to the request object.
    // the lua modules should ""think"" in 1 based indexes, so we need to
    // subtract one here.
    if (lookup >= p->pool_size) {
        proxy_lua_error(L, ""key dist hasher tried to use out of bounds index"");
    }

    return p->pool[lookup].be;
}",1,8,proxy_lua.c,mcplib_pool_proxy_call_helper,,false,474,491,mcplib_pool_proxy_call_helper,,,15,"mcp_backend_t mcplib_pool_proxy_call_helper (lua_State*,mcp_pool_t*,char*,size_t)"
69589,METHOD,proxy_lua.c:<global>,TYPE_DECL,"static int mcplib_pool_proxy_call(lua_State *L) {
    // internal args are the hash selector (self)
    mcp_pool_proxy_t *pp = luaL_checkudata(L, -2, ""mcp.pool_proxy"");
    mcp_pool_t *p = pp->main;
    // then request object.
    mcp_request_t *rq = luaL_checkudata(L, -1, ""mcp.request"");

    // we have a fast path to the key/length.
    if (!rq->pr.keytoken) {
        proxy_lua_error(L, ""cannot route commands without key"");
        return 0;
    }
    const char *key = MCP_PARSER_KEY(rq->pr);
    size_t len = rq->pr.klen;
    rq->be = mcplib_pool_proxy_call_helper(L, p, key, len);

    // now yield request, pool up.
    return lua_yield(L, 2);
}",1,22,proxy_lua.c,mcplib_pool_proxy_call,,false,495,513,mcplib_pool_proxy_call,,,16,int mcplib_pool_proxy_call (lua_State*)
69676,METHOD,proxy_lua.c:<global>,TYPE_DECL,"static int mcplib_tcp_keepalive(lua_State *L) {
    luaL_checktype(L, -1, LUA_TBOOLEAN);
    int state = lua_toboolean(L, -1);
    proxy_ctx_t *ctx = settings.proxy_ctx; // FIXME (v2): get global ctx reference in thread/upvalue.

    STAT_L(ctx);
    ctx->tunables.tcp_keepalive = state;
    STAT_UL(ctx);

    return 0;
}",1,4,proxy_lua.c,mcplib_tcp_keepalive,,false,515,525,mcplib_tcp_keepalive,,,17,int mcplib_tcp_keepalive (lua_State*)
69724,METHOD,proxy_lua.c:<global>,TYPE_DECL,"static int mcplib_backend_failure_limit(lua_State *L) {
    int limit = luaL_checkinteger(L, -1);
    proxy_ctx_t *ctx = settings.proxy_ctx; // FIXME (v2): get global ctx reference in thread/upvalue.

    if (limit < 0) {
        proxy_lua_error(L, ""backend_failure_limit must be >= 0"");
        return 0;
    }

    STAT_L(ctx);
    ctx->tunables.backend_failure_limit = limit;
    STAT_UL(ctx);

    return 0;
}",1,4,proxy_lua.c,mcplib_backend_failure_limit,,false,527,541,mcplib_backend_failure_limit,,,18,int mcplib_backend_failure_limit (lua_State*)
69777,METHOD,proxy_lua.c:<global>,TYPE_DECL,"static int mcplib_backend_connect_timeout(lua_State *L) {
    lua_Number secondsf = luaL_checknumber(L, -1);
    lua_Integer secondsi = (lua_Integer) secondsf;
    lua_Number subseconds = secondsf - secondsi;
    proxy_ctx_t *ctx = settings.proxy_ctx; // FIXME (v2): get global ctx reference in thread/upvalue.

    STAT_L(ctx);
    ctx->tunables.connect.tv_sec = secondsi;
    ctx->tunables.connect.tv_usec = MICROSECONDS(subseconds);
#ifdef HAVE_LIBURING
    ctx->tunables.connect_ur.tv_sec = secondsi;
    ctx->tunables.connect_ur.tv_nsec = NANOSECONDS(subseconds);
#endif
    STAT_UL(ctx);

    return 0;
}",1,4,proxy_lua.c,mcplib_backend_connect_timeout,,false,547,563,mcplib_backend_connect_timeout,,,19,int mcplib_backend_connect_timeout (lua_State*)
69850,METHOD,proxy_lua.c:<global>,TYPE_DECL,"static int mcplib_backend_retry_timeout(lua_State *L) {
    lua_Number secondsf = luaL_checknumber(L, -1);
    lua_Integer secondsi = (lua_Integer) secondsf;
    lua_Number subseconds = secondsf - secondsi;
    proxy_ctx_t *ctx = settings.proxy_ctx; // FIXME (v2): get global ctx reference in thread/upvalue.

    STAT_L(ctx);
    ctx->tunables.retry.tv_sec = secondsi;
    ctx->tunables.retry.tv_usec = MICROSECONDS(subseconds);
#ifdef HAVE_LIBURING
    ctx->tunables.retry_ur.tv_sec = secondsi;
    ctx->tunables.retry_ur.tv_nsec = NANOSECONDS(subseconds);
#endif
    STAT_UL(ctx);

    return 0;
}",1,4,proxy_lua.c,mcplib_backend_retry_timeout,,false,565,581,mcplib_backend_retry_timeout,,,20,int mcplib_backend_retry_timeout (lua_State*)
69923,METHOD,proxy_lua.c:<global>,TYPE_DECL,"static int mcplib_backend_read_timeout(lua_State *L) {
    lua_Number secondsf = luaL_checknumber(L, -1);
    lua_Integer secondsi = (lua_Integer) secondsf;
    lua_Number subseconds = secondsf - secondsi;
    proxy_ctx_t *ctx = settings.proxy_ctx; // FIXME (v2): get global ctx reference in thread/upvalue.

    STAT_L(ctx);
    ctx->tunables.read.tv_sec = secondsi;
    ctx->tunables.read.tv_usec = MICROSECONDS(subseconds);
#ifdef HAVE_LIBURING
    ctx->tunables.read_ur.tv_sec = secondsi;
    ctx->tunables.read_ur.tv_nsec = NANOSECONDS(subseconds);
#endif
    STAT_UL(ctx);

    return 0;
}",1,4,proxy_lua.c,mcplib_backend_read_timeout,,false,583,599,mcplib_backend_read_timeout,,,21,int mcplib_backend_read_timeout (lua_State*)
69996,METHOD,proxy_lua.c:<global>,TYPE_DECL,"static int mcplib_attach(lua_State *L) {
    // Pull the original worker thread out of the shared mcplib upvalue.
    LIBEVENT_THREAD *t = lua_touserdata(L, lua_upvalueindex(MCP_THREAD_UPVALUE));

    int hook = luaL_checkinteger(L, 1);
    // pushvalue to dupe func and etc.
    // can leave original func on stack afterward because it'll get cleared.
    int loop_end = 0;
    int loop_start = 1;
    if (hook == CMD_ANY) {
        // if CMD_ANY we need individually set loop 1 to CMD_SIZE.
        loop_end = CMD_SIZE;
    } else if (hook == CMD_ANY_STORAGE) {
        // if CMD_ANY_STORAGE we only override get/set/etc.
        loop_end = CMD_END_STORAGE;
    } else {
        loop_start = hook;
        loop_end = hook + 1;
    }

    if (lua_isfunction(L, 2)) {
        struct proxy_hook *hooks = t->proxy_hooks;
        uint64_t tag = 0; // listener socket tag

        if (lua_isstring(L, 3)) {
            size_t len;
            const char *stag = lua_tolstring(L, 3, &len);
            ...",1,60,proxy_lua.c,mcplib_attach,,false,603,710,mcplib_attach,,,22,int mcplib_attach (lua_State*)
70341,METHOD,proxy_lua.c:<global>,TYPE_DECL,"static int mcplib_log(lua_State *L) {
    LIBEVENT_THREAD *t = lua_touserdata(L, lua_upvalueindex(MCP_THREAD_UPVALUE));
    const char *msg = luaL_checkstring(L, -1);
    LOGGER_LOG(t->l, LOG_PROXYUSER, LOGGER_PROXY_USER, NULL, msg);
    return 0;
}",1,60,proxy_lua.c,mcplib_log,,false,714,719,mcplib_log,,,23,int mcplib_log (lua_State*)
70407,METHOD,proxy_lua.c:<global>,TYPE_DECL,"static int mcplib_log_req(lua_State *L) {
    LIBEVENT_THREAD *t = lua_touserdata(L, lua_upvalueindex(MCP_THREAD_UPVALUE));
    logger *l = t->l;
    // Not using the LOGGER_LOG macro so we can avoid as much overhead as
    // possible when logging is disabled.
    if (! (l->eflags & LOG_PROXYREQS)) {
        return 0;
    }
    int rtype = 0;
    int rcode = 0;
    int rstatus = 0;
    char *rname = NULL;
    char *rport = NULL;

    mcp_request_t *rq = luaL_checkudata(L, 1, ""mcp.request"");
    int type = lua_type(L, 2);
    if (type == LUA_TUSERDATA) {
        mcp_resp_t *rs = luaL_checkudata(L, 2, ""mcp.response"");
        rtype = rs->resp.type;
        rcode = rs->resp.code;
        rstatus = rs->status;
        rname = rs->be_name;
        rport = rs->be_port;
    }
    size_t dlen = 0;
    const char *detail = luaL_optlstring(L, 3, NULL, &dlen);

    struct timeval end;
    gettimeofday(&end, NULL);
    long elapsed = (end.tv_sec - rq->start.tv_sec) * 1000000 + (end.tv_usec - r...",1,60,proxy_lua.c,mcplib_log_req,,false,722,756,mcplib_log_req,,,24,int mcplib_log_req (lua_State*)
70581,METHOD,proxy_lua.c:<global>,TYPE_DECL,"static inline uint32_t _rotl(const uint32_t x, int k) {
    return (x << k) | (x >> (32 - k));
}",1,1,proxy_lua.c,_rotl,,false,758,760,_rotl,,,25,"uint32_t _rotl (uint32_t,int)"
70597,METHOD,proxy_lua.c:<global>,TYPE_DECL,"static uint32_t _nextrand(uint32_t *s) {
    const uint32_t result = _rotl(s[0] + s[3], 7) + s[0];

    const uint32_t t = s[1] << 9;

    s[2] ^= s[0];
    s[3] ^= s[1];
    s[1] ^= s[2];
    s[0] ^= s[3];

    s[2] ^= t;

    s[3] = _rotl(s[3], 11);

    return result;
}",1,1,proxy_lua.c,_nextrand,,false,763,778,_nextrand,,,26,uint32_t _nextrand (uint32_t*)
70670,METHOD,proxy_lua.c:<global>,TYPE_DECL,"static int mcplib_log_reqsample(lua_State *L) {
    LIBEVENT_THREAD *t = lua_touserdata(L, lua_upvalueindex(MCP_THREAD_UPVALUE));
    logger *l = t->l;
    // Not using the LOGGER_LOG macro so we can avoid as much overhead as
    // possible when logging is disabled.
    if (! (l->eflags & LOG_PROXYREQS)) {
        return 0;
    }
    int rtype = 0;
    int rcode = 0;
    int rstatus = 0;
    char *rname = NULL;
    char *rport = NULL;

    int ms = luaL_checkinteger(L, 1);
    int rate = luaL_checkinteger(L, 2);
    int allerr = lua_toboolean(L, 3);
    mcp_request_t *rq = luaL_checkudata(L, 4, ""mcp.request"");
    int type = lua_type(L, 5);
    if (type == LUA_TUSERDATA) {
        mcp_resp_t *rs = luaL_checkudata(L, 5, ""mcp.response"");
        rtype = rs->resp.type;
        rcode = rs->resp.code;
        rstatus = rs->status;
        rname = rs->be_name;
        rport = rs->be_port;
    }
    size_t dlen = 0;
    const char *detail = luaL_optlstring(L, 6, NULL, &dlen);

    struct ...",1,60,proxy_lua.c,mcplib_log_reqsample,,false,782,835,mcplib_log_reqsample,,,27,int mcplib_log_reqsample (lua_State*)
70927,METHOD,proxy_lua.c:<global>,TYPE_DECL,"static void proxy_register_defines(lua_State *L) {
#define X(x) \
    lua_pushinteger(L, x); \
    lua_setfield(L, -2, #x);

    X(MCMC_CODE_STORED);
    X(MCMC_CODE_EXISTS);
    X(MCMC_CODE_DELETED);
    X(MCMC_CODE_TOUCHED);
    X(MCMC_CODE_VERSION);
    X(MCMC_CODE_NOT_FOUND);
    X(MCMC_CODE_NOT_STORED);
    X(MCMC_CODE_OK);
    X(MCMC_CODE_NOP);
    X(MCMC_CODE_MISS);
    X(P_OK);
    X(CMD_ANY);
    X(CMD_ANY_STORAGE);
    X(AWAIT_GOOD);
    X(AWAIT_ANY);
    X(AWAIT_OK);
    X(AWAIT_FIRST);
    CMD_FIELDS
#undef X
}",1,4,proxy_lua.c,proxy_register_defines,,false,842,866,proxy_register_defines,,,28,void proxy_register_defines (lua_State*)
71383,METHOD,proxy_lua.c:<global>,TYPE_DECL,"int proxy_register_libs(LIBEVENT_THREAD *t, void *ctx) {
    lua_State *L = ctx;

    const struct luaL_Reg mcplib_backend_m[] = {
        {""set"", NULL},
        {""__gc"", mcplib_backend_gc},
        {NULL, NULL}
    };

    const struct luaL_Reg mcplib_request_m[] = {
        {""command"", mcplib_request_command},
        {""key"", mcplib_request_key},
        {""ltrimkey"", mcplib_request_ltrimkey},
        {""rtrimkey"", mcplib_request_rtrimkey},
        {""token"", mcplib_request_token},
        {""ntokens"", mcplib_request_ntokens},
        {""has_flag"", mcplib_request_has_flag},
        {""flag_token"", mcplib_request_flag_token},
        {""__tostring"", NULL},
        {""__gc"", mcplib_request_gc},
        {NULL, NULL}
    };

    const struct luaL_Reg mcplib_response_m[] = {
        {""ok"", mcplib_response_ok},
        {""hit"", mcplib_response_hit},
        {""vlen"", mcplib_response_vlen},
        {""code"", mcplib_response_code},
        {""line"", mcplib_response_line},
        {""__gc"", mcplib_resp...",1,1,proxy_lua.c,proxy_register_libs,,false,869,996,proxy_register_libs,,,29,"int proxy_register_libs (LIBEVENT_THREAD*,void*)"
71701,METHOD,proxy_network.c:<global>,TYPE_DECL,<global>,1,1,proxy_network.c,proxy_network.c:<global>,,false,1,1112,<global>,,,1,
71703,METHOD,proxy_network.c:<global>,TYPE_DECL,"static void proxy_backend_handler(const int fd, const short which, void *arg);",13,77,proxy_network.c,proxy_backend_handler,,false,6,6,proxy_backend_handler,,,1,"void proxy_backend_handler (int,short,void*)"
71710,METHOD,proxy_network.c:<global>,TYPE_DECL,"static void proxy_event_handler(evutil_socket_t fd, short which, void *arg);",13,75,proxy_network.c,proxy_event_handler,,false,7,7,proxy_event_handler,,,2,"void proxy_event_handler (evutil_socket_t,short,void*)"
71717,METHOD,proxy_network.c:<global>,TYPE_DECL,"static void proxy_event_updater(evutil_socket_t fd, short which, void *arg);",13,75,proxy_network.c,proxy_event_updater,,false,8,8,proxy_event_updater,,,3,"void proxy_event_updater (evutil_socket_t,short,void*)"
71724,METHOD,proxy_network.c:<global>,TYPE_DECL,static int _flush_pending_write(mcp_backend_t *be);,12,50,proxy_network.c,_flush_pending_write,,false,9,9,_flush_pending_write,,,4,int _flush_pending_write (mcp_backend_t*)
71729,METHOD,proxy_network.c:<global>,TYPE_DECL,"static int _reset_bad_backend(mcp_backend_t *be, enum proxy_be_failures err);",12,76,proxy_network.c,_reset_bad_backend,,false,10,10,_reset_bad_backend,,,5,"int _reset_bad_backend (mcp_backend_t*,proxy_be_failures)"
71735,METHOD,proxy_network.c:<global>,TYPE_DECL,"static void _set_event(mcp_backend_t *be, struct event_base *base, int flags, struct timeval t, event_callback_fn callback);",13,123,proxy_network.c,_set_event,,false,11,11,_set_event,,,6,"void _set_event (mcp_backend_t*,event_base*,int,timeval,event_callback_fn)"
71744,METHOD,proxy_network.c:<global>,TYPE_DECL,static int proxy_backend_drive_machine(mcp_backend_t *be);,12,57,proxy_network.c,proxy_backend_drive_machine,,false,12,12,proxy_backend_drive_machine,,,7,int proxy_backend_drive_machine (mcp_backend_t*)
71749,METHOD,proxy_network.c:<global>,TYPE_DECL,"static int _proxy_event_handler_dequeue(proxy_event_thread_t *t) {
    io_head_t head;

    STAILQ_INIT(&head);
    STAILQ_INIT(&t->be_head);

    // Pull the entire stack of inbound into local queue.
    pthread_mutex_lock(&t->mutex);
    STAILQ_CONCAT(&head, &t->io_head_in);
    pthread_mutex_unlock(&t->mutex);

    int io_count = 0;
    int be_count = 0;
    while (!STAILQ_EMPTY(&head)) {
        io_pending_proxy_t *io = STAILQ_FIRST(&head);
        io->flushed = false;
        mcp_backend_t *be = io->backend;
        // So the backend can retrieve its event base.
        be->event_thread = t;

        // _no_ mutex on backends. they are owned by the event thread.
        STAILQ_REMOVE_HEAD(&head, io_next);
        // paranoia about moving items between lists.
        io->io_next.stqe_next = NULL;

        if (be->bad) {
            P_DEBUG(""%s: fast failing request to bad backend\n"", __func__);
            io->client_resp->status = MCMC_ERR;
            return_io_pending((io_pen...",1,4,proxy_network.c,_proxy_event_handler_dequeue,,false,14,58,_proxy_event_handler_dequeue,,,8,int _proxy_event_handler_dequeue (proxy_event_thread_t*)
72104,METHOD,proxy_network.c:<global>,TYPE_DECL,"static void proxy_event_updater(evutil_socket_t fd, short which, void *arg) {
    proxy_event_thread_t *t = arg;
    proxy_ctx_t *ctx = t->ctx;

    // TODO (v2): double check how much of this boilerplate is still necessary?
    // reschedule the clock event.
    evtimer_del(&t->clock_event);

    evtimer_set(&t->clock_event, proxy_event_updater, t);
    event_base_set(t->base, &t->clock_event);
    struct timeval rate = {.tv_sec = 3, .tv_usec = 0};
    evtimer_add(&t->clock_event, &rate);

    // we reuse the ""global stats"" lock since it's hardly ever used.
    STAT_L(ctx);
    memcpy(&t->tunables, &ctx->tunables, sizeof(t->tunables));
    STAT_UL(ctx);
}",1,4,proxy_network.c,proxy_event_updater,,false,386,403,proxy_event_updater,,,9,"void proxy_event_updater (evutil_socket_t,short,void*)"
72189,METHOD,proxy_network.c:<global>,TYPE_DECL,"static void proxy_event_handler(evutil_socket_t fd, short which, void *arg) {
    proxy_event_thread_t *t = arg;

#ifdef USE_EVENTFD
    uint64_t u;
    if (read(fd, &u, sizeof(uint64_t)) != sizeof(uint64_t)) {
        // Temporary error or wasn't actually ready to read somehow.
        return;
    }
#else
    char buf[1];
    // TODO (v2): This is a lot more fatal than it should be. can it fail? can
    // it blow up the server?
    // TODO (v2): a cross-platform method of speeding this up would be nice. With
    // event fds we can queue N events and wakeup once here.
    // If we're pulling one byte out of the pipe at a time here it'll just
    // wake us up too often.
    // If the pipe is O_NONBLOCK then maybe just a larger read would work?
    if (read(fd, buf, 1) != 1) {
        P_DEBUG(""%s: pipe read failed\n"", __func__);
        return;
    }
#endif

    if (_proxy_event_handler_dequeue(t) == 0) {
        //P_DEBUG(""%s: no IO's to complete\n"", __func__);
        return;
   ...",1,8,proxy_network.c,proxy_event_handler,,false,406,458,proxy_event_handler,,,10,"void proxy_event_handler (evutil_socket_t,short,void*)"
72309,METHOD,proxy_network.c:<global>,TYPE_DECL,"void *proxy_event_thread(void *arg) {
    proxy_event_thread_t *t = arg;

    logger_create(); // TODO (v2): add logger ptr to structure
    event_base_loop(t->base, 0);
    event_base_free(t->base);

    // TODO (v2): join bt threads, free array.

    return NULL;
}",1,1,proxy_network.c,proxy_event_thread,,false,460,470,proxy_event_thread,,,11,void* proxy_event_thread (void*)
72330,METHOD,proxy_network.c:<global>,TYPE_DECL,"static void _set_event(mcp_backend_t *be, struct event_base *base, int flags, struct timeval t, event_callback_fn callback) {
    // FIXME (v2): chicken and egg.
    // can't check if pending if the structure is was calloc'ed (sigh)
    // don't want to double test here. should be able to event_assign but
    // not add anything during initialization, but need the owner thread's
    // event base.
    int pending = 0;
    if (event_initialized(&be->event)) {
        pending = event_pending(&be->event, EV_READ|EV_WRITE|EV_TIMEOUT, NULL);
    }
    if ((pending & (EV_READ|EV_WRITE|EV_TIMEOUT)) != 0) {
            event_del(&be->event); // replace existing event.
    }

    // if we can't write, we could be connecting.
    // TODO (v2): always check for READ in case some commands were sent
    // successfully? The flags could be tracked on *be and reset in the
    // handler, perhaps?
    event_assign(&be->event, base, mcmc_fd(be->client),
            flags, callback, be);
    event_ad...",1,1,proxy_network.c,_set_event,,false,473,494,_set_event,,,12,"void _set_event (mcp_backend_t*,event_base*,int,timeval,event_callback_fn)"
72399,METHOD,proxy_network.c:<global>,TYPE_DECL,"static int proxy_backend_drive_machine(mcp_backend_t *be) {
    bool stop = false;
    io_pending_proxy_t *p = NULL;
    int flags = 0;

    p = STAILQ_FIRST(&be->io_head);
    if (p == NULL) {
        // got a read event, but nothing was queued.
        // probably means a disconnect event.
        // TODO (v2): could probably confirm this by attempting to read the
        // socket, getsockopt, or something else simply for logging or
        // statistical purposes.
        // In this case we know it's going to be a close so error.
        flags = -1;
        P_DEBUG(""%s: read event but nothing in IO queue\n"", __func__);
        return flags;
    }

    while (!stop) {
        mcp_resp_t *r;
        int res = 1;

    switch(be->state) {
        case mcp_backend_read:
            assert(p != NULL);
            // FIXME: remove the _read state?
            be->state = mcp_backend_parse;
            break;
        case mcp_backend_parse:
            r = p->client_resp;
            r-...",1,8,proxy_network.c,proxy_backend_drive_machine,,false,505,756,proxy_backend_drive_machine,,,13,int proxy_backend_drive_machine (mcp_backend_t*)
73215,METHOD,proxy_network.c:<global>,TYPE_DECL,"static void proxy_backend_retry_handler(const int fd, const short which, void *arg) {
    mcp_backend_t *be = arg;
    assert(which & EV_TIMEOUT);
    struct timeval tmp_time = be->event_thread->tunables.retry;
    _set_event(be, be->event_thread->base, EV_WRITE|EV_TIMEOUT, tmp_time, proxy_backend_handler);
}",1,1,proxy_network.c,proxy_backend_retry_handler,,false,759,764,proxy_backend_retry_handler,,,14,"void proxy_backend_retry_handler (int,short,void*)"
73252,METHOD,proxy_network.c:<global>,TYPE_DECL,"static void _backend_failed(mcp_backend_t *be) {
    struct timeval tmp_time = be->event_thread->tunables.retry;
    if (++be->failed_count > be->event_thread->tunables.backend_failure_limit) {
        P_DEBUG(""%s: marking backend as bad\n"", __func__);
        be->bad = true;
       _set_event(be, be->event_thread->base, EV_TIMEOUT, tmp_time, proxy_backend_retry_handler);
        STAT_INCR(be->event_thread->ctx, backend_marked_bad, 1);
    } else {
        STAT_INCR(be->event_thread->ctx, backend_failed, 1);
        _set_event(be, be->event_thread->base, EV_WRITE|EV_TIMEOUT, tmp_time, proxy_backend_handler);
    }
}",1,8,proxy_network.c,_backend_failed,,false,779,790,_backend_failed,,,15,void _backend_failed (mcp_backend_t*)
73413,METHOD,proxy_network.c:<global>,TYPE_DECL,"static int _reset_bad_backend(mcp_backend_t *be, enum proxy_be_failures err) {
    io_pending_proxy_t *io = NULL;
    // Can't use STAILQ_FOREACH() since return_io_pending() free's the current
    // io. STAILQ_FOREACH_SAFE maybe?
    while (!STAILQ_EMPTY(&be->io_head)) {
        io = STAILQ_FIRST(&be->io_head);
        STAILQ_REMOVE_HEAD(&be->io_head, io_next);
        // TODO (v2): Unsure if this is the best way of surfacing errors to lua,
        // but will do for V1.
        io->client_resp->status = MCMC_ERR;
        be->depth--;
        return_io_pending((io_pending_t *)io);
    }

    STAILQ_INIT(&be->io_head);

    // reset buffer to blank state.
    be->rbufused = 0;
    mcmc_disconnect(be->client);
    int status = mcmc_connect(be->client, be->name, be->port, be->connect_flags);
    if (status == MCMC_CONNECTED) {
        // TODO (v2): unexpected but lets let it be here.
        be->connecting = false;
        be->can_write = true;
    } else if (status == MCMC_CONNECTING...",1,12,proxy_network.c,_reset_bad_backend,,false,810,852,_reset_bad_backend,,,18,"int _reset_bad_backend (mcp_backend_t*,proxy_be_failures)"
73667,METHOD,proxy_network.c:<global>,TYPE_DECL,"static int _prep_pending_write(mcp_backend_t *be, unsigned int *tosend) {
    struct iovec *iovs = be->write_iovs;
    io_pending_proxy_t *io = NULL;
    int iovused = 0;
    STAILQ_FOREACH(io, &be->io_head, io_next) {
        if (io->flushed)
            continue;

        if (io->iovcnt + iovused > BE_IOV_MAX) {
            // Signal to caller that we need to keep writing, if writeable.
            // FIXME (v2): can certainly refactor this to loop instead of waiting
            // for a writeable event.
            *tosend += 1;
            break;
        }

        memcpy(&iovs[iovused], io->iov, sizeof(struct iovec)*io->iovcnt);
        iovused += io->iovcnt;
        *tosend += io->iovbytes;
    }
    return iovused;
}",1,4,proxy_network.c,_prep_pending_write,,false,854,875,_prep_pending_write,,,19,"int _prep_pending_write (mcp_backend_t*,unsigned int*)"
73755,METHOD,proxy_network.c:<global>,TYPE_DECL,"static int _flush_pending_write(mcp_backend_t *be) {
    int flags = 0;
    unsigned int tosend = 0;
    int iovcnt = _prep_pending_write(be, &tosend);

    ssize_t sent = writev(mcmc_fd(be->client), be->write_iovs, iovcnt);
    if (sent > 0) {
        io_pending_proxy_t *io = NULL;
        if (sent < tosend) {
            flags |= EV_WRITE;
        }

        STAILQ_FOREACH(io, &be->io_head, io_next) {
            bool flushed = true;
            if (io->flushed)
                continue;

            if (sent >= io->iovbytes) {
                // short circuit for common case.
                sent -= io->iovbytes;
            } else {
                io->iovbytes -= sent;
                for (int x = 0; x < io->iovcnt; x++) {
                    struct iovec *iov = &io->iov[x];
                    if (sent >= iov->iov_len) {
                        sent -= iov->iov_len;
                        iov->iov_len = 0;
                    } else {
                        iov->iov_len -= s...",1,8,proxy_network.c,_flush_pending_write,,false,877,933,_flush_pending_write,,,20,int _flush_pending_write (mcp_backend_t*)
73970,METHOD,proxy_network.c:<global>,TYPE_DECL,"static void proxy_backend_handler(const int fd, const short which, void *arg) {
    mcp_backend_t *be = arg;
    int flags = EV_TIMEOUT;
    struct timeval tmp_time = be->event_thread->tunables.read;

    if (which & EV_TIMEOUT) {
        P_DEBUG(""%s: timeout received, killing backend queue\n"", __func__);
        _reset_bad_backend(be, P_BE_FAIL_TIMEOUT);
        _backend_failed(be);
        return;
    }

    if (which & EV_WRITE) {
        be->can_write = true;
        // TODO (v2): move connect routine to its own function?
        // - hard to do right now because we can't (easily?) edit libevent
        // events.
        if (be->connecting) {
            int err = 0;
            // We were connecting, now ensure we're properly connected.
            if (mcmc_check_nonblock_connect(be->client, &err) != MCMC_OK) {
                // kick the bad backend, clear the queue, retry later.
                // FIXME (v2): if a connect fails, anything currently in the queue
              ...",1,8,proxy_network.c,proxy_backend_handler,,false,938,1016,proxy_backend_handler,,,21,"void proxy_backend_handler (int,short,void*)"
74193,METHOD,proxy_network.c:<global>,TYPE_DECL,"void proxy_init_evthread_events(proxy_event_thread_t *t) {
#ifdef HAVE_LIBURING
    bool use_uring = t->ctx->use_uring;
    struct io_uring_params p = {0};
    assert(t->event_fd); // uring only exists where eventfd also does.

    // Setup the CQSIZE to be much larger than SQ size, since backpressure
    // issues can cause us to block on SQ submissions and as a network server,
    // stuff happens.

    if (use_uring) {
        p.flags = IORING_SETUP_CQSIZE;
        p.cq_entries = PRING_QUEUE_CQ_ENTRIES;
        int ret = io_uring_queue_init_params(PRING_QUEUE_SQ_ENTRIES, &t->ring, &p);
        if (ret) {
            perror(""io_uring_queue_init_params"");
            exit(1);
        }
        if (!(p.features & IORING_FEAT_NODROP)) {
            fprintf(stderr, ""uring: kernel missing IORING_FEAT_NODROP, using libevent\n"");
            use_uring = false;
        }
        if (!(p.features & IORING_FEAT_SINGLE_MMAP)) {
            fprintf(stderr, ""uring: kernel missing IORING_FEAT_S...",1,1,proxy_network.c,proxy_init_evthread_events,,false,1020,1111,proxy_init_evthread_events,,,22,void proxy_init_evthread_events (proxy_event_thread_t*)
74300,METHOD,proxy_request.c:<global>,TYPE_DECL,<global>,1,1,proxy_request.c,proxy_request.c:<global>,,false,1,812,<global>,,,1,
74302,METHOD,proxy_request.c:<global>,TYPE_DECL,"static int _process_tokenize(mcp_parser_t *pr, const size_t max) {
    const char *s = pr->request;
    int len = pr->reqlen - 2;

    // since multigets can be huge, we can't purely judge reqlen against this
    // limit, but we also can't index past it since the tokens are shorts.
    if (len > PARSER_MAXLEN) {
        len = PARSER_MAXLEN;
    }
    const char *end = s + len;
    int curtoken = 0;

    int state = 0;
    while (s != end) {
        switch (state) {
            case 0:
                // scanning for first non-space to find a token.
                if (*s != ' ') {
                    pr->tokens[curtoken] = s - pr->request;
                    if (++curtoken == max) {
                        s++;
                        state = 2;
                        break;
                    }
                    state = 1;
                }
                s++;
                break;
            case 1:
                // advance over a token
                if (*s != ' ') {
...",1,14,proxy_request.c,_process_tokenize,,false,10,65,_process_tokenize,,,1,"int _process_tokenize (mcp_parser_t*,size_t)"
74444,METHOD,proxy_request.c:<global>,TYPE_DECL,"static int _process_token_len(mcp_parser_t *pr, size_t token) {
    const char *s = pr->request + pr->tokens[token];
    const char *e = pr->request + pr->tokens[token+1];
    // start of next token is after any space delimiters, so back those out.
    while (*(e-1) == ' ') {
        e--;
    }
    return e - s;
}",1,1,proxy_request.c,_process_token_len,,false,67,75,_process_token_len,,,2,"int _process_token_len (mcp_parser_t*,size_t)"
74490,METHOD,proxy_request.c:<global>,TYPE_DECL,"static int _process_request_key(mcp_parser_t *pr) {
    pr->klen = _process_token_len(pr, pr->keytoken);
    // advance the parser in case of multikey.
    pr->parsed = pr->tokens[pr->keytoken] + pr->klen + 1;

    if (pr->request[pr->parsed-1] == ' ') {
        P_DEBUG(""%s: request_key found extra space\n"", __func__);
        pr->has_space = true;
    } else {
        pr->has_space = false;
    }
    return 0;
}",1,8,proxy_request.c,_process_request_key,,false,77,89,_process_request_key,,,3,int _process_request_key (mcp_parser_t*)
74548,METHOD,proxy_request.c:<global>,TYPE_DECL,"size_t _process_request_next_key(mcp_parser_t *pr) {
    const char *cur = pr->request + pr->parsed;
    int remain = pr->reqlen - pr->parsed - 2;

    // chew off any leading whitespace.
    while (remain) {
        if (*cur == ' ') {
            remain--;
            cur++;
            pr->parsed++;
        } else {
            break;
        }
    }

    const char *s = memchr(cur, ' ', remain);
    if (s != NULL) {
        pr->klen = s - cur;
        pr->parsed += s - cur;
    } else {
        pr->klen = remain;
        pr->parsed += remain;
    }

    return cur - pr->request;
}",1,1,proxy_request.c,_process_request_next_key,,false,94,119,_process_request_next_key,,,4,size_t _process_request_next_key (mcp_parser_t*)
74639,METHOD,proxy_request.c:<global>,TYPE_DECL,"static int _process_request_metaflags(mcp_parser_t *pr, int token) {
    if (pr->ntokens <= token) {
        pr->t.meta.flags = 0; // no flags found.
        return 0;
    }
    const char *cur = pr->request + pr->tokens[token];
    const char *end = pr->request + pr->reqlen - 2;

    // We blindly convert flags into bits, since the range of possible
    // flags is deliberately < 64.
    int state = 0;
    while (cur != end) {
        switch (state) {
            case 0:
                if (*cur == ' ') {
                    cur++;
                } else {
                    if (*cur < 65 || *cur > 122) {
                        return -1;
                    }
                    P_DEBUG(""%s: setting meta flag: %d\n"", __func__, *cur - 65);
                    pr->t.meta.flags |= (uint64_t)1 << (*cur - 65);
                    state = 1;
                }
                break;
            case 1:
                if (*cur != ' ') {
                    cur++;
                } else...",1,20,proxy_request.c,_process_request_metaflags,,false,123,166,_process_request_metaflags,,,5,"int _process_request_metaflags (mcp_parser_t*,int)"
74783,METHOD,proxy_request.c:<global>,TYPE_DECL,"static int _process_request_meta(mcp_parser_t *pr) {
    _process_tokenize(pr, PARSER_MAX_TOKENS);
    if (pr->ntokens < 2) {
        P_DEBUG(""%s: not enough tokens for meta command: %d\n"", __func__, pr->ntokens);
        return -1;
    }
    pr->keytoken = 1;
    _process_request_key(pr);

    // pass the first flag token.
    return _process_request_metaflags(pr, 2);
}",1,26,proxy_request.c,_process_request_meta,,false,169,180,_process_request_meta,,,6,int _process_request_meta (mcp_parser_t*)
74814,METHOD,proxy_request.c:<global>,TYPE_DECL,"static int _process_request_mset(mcp_parser_t *pr) {
    _process_tokenize(pr, PARSER_MAX_TOKENS);
    if (pr->ntokens < 3) {
        P_DEBUG(""%s: not enough tokens for meta set command: %d\n"", __func__, pr->ntokens);
        return -1;
    }
    pr->keytoken = 1;
    _process_request_key(pr);

    const char *cur = pr->request + pr->tokens[2];

    errno = 0;
    char *n = NULL;
    int vlen = strtol(cur, &n, 10);
    if ((errno == ERANGE) || (cur == n)) {
        return -1;
    }

    if (vlen < 0 || vlen > (INT_MAX - 2)) {
       return -1;
    }
    vlen += 2;

    pr->vlen = vlen;

    // pass the first flag token
    return _process_request_metaflags(pr, 3);
}",1,26,proxy_request.c,_process_request_mset,,false,183,210,_process_request_mset,,,7,int _process_request_mset (mcp_parser_t*)
74906,METHOD,proxy_request.c:<global>,TYPE_DECL,"static int _process_request_gat(mcp_parser_t *pr) {
    _process_tokenize(pr, 3);
    if (pr->ntokens < 3) {
        P_DEBUG(""%s: not enough tokens for GAT: %d\n"", __func__, pr->ntokens);
        return -1;
    }

    pr->keytoken = 2;
    _process_request_key(pr);
    return 0;
}",1,8,proxy_request.c,_process_request_gat,,false,213,223,_process_request_gat,,,8,int _process_request_gat (mcp_parser_t*)
74933,METHOD,proxy_request.c:<global>,TYPE_DECL,"static int _process_request_noreply(mcp_parser_t *pr) {
    if (pr->tokens[pr->ntokens] - pr->tokens[pr->ntokens-1] >= NOREPLYLEN
            && strncmp(NOREPLYSTR, pr->request + pr->tokens[pr->ntokens-1], NOREPLYLEN) == 0) {
        pr->noreply = true;
    }
    return 0;
}",1,63,proxy_request.c,_process_request_noreply,,false,229,235,_process_request_noreply,,,9,int _process_request_noreply (mcp_parser_t*)
74997,METHOD,proxy_request.c:<global>,TYPE_DECL,"static int _process_request_storage(mcp_parser_t *pr, size_t max) {
    _process_tokenize(pr, max);
    if (pr->ntokens < 5) {
        P_DEBUG(""%s: not enough tokens to storage command: %d\n"", __func__, pr->ntokens);
        return -1;
    }
    pr->keytoken = 1;
    _process_request_key(pr);

    errno = 0;
    char *n = NULL;
    const char *cur = pr->request + pr->tokens[4];

    int vlen = strtol(cur, &n, 10);
    if ((errno == ERANGE) || (cur == n)) {
        return -1;
    }

    if (vlen < 0 || vlen > (INT_MAX - 2)) {
       return -1;
    }
    vlen += 2;

    pr->vlen = vlen;

    return _process_request_noreply(pr);
}",1,8,proxy_request.c,_process_request_storage,,false,240,266,_process_request_storage,,,10,"int _process_request_storage (mcp_parser_t*,size_t)"
75087,METHOD,proxy_request.c:<global>,TYPE_DECL,"static int _process_request_simple(mcp_parser_t *pr, const size_t max) {
    _process_tokenize(pr, max);
    pr->keytoken = 1; // second token is usually the key... stupid GAT.

    _process_request_key(pr);
    return _process_request_noreply(pr);
}",1,1,proxy_request.c,_process_request_simple,,false,269,275,_process_request_simple,,,11,"int _process_request_simple (mcp_parser_t*,size_t)"
75106,METHOD,proxy_request.c:<global>,TYPE_DECL,"int process_request(mcp_parser_t *pr, const char *command, size_t cmdlen) {
    // we want to ""parse in place"" as much as possible, which allows us to
    // forward an unmodified request without having to rebuild it.

    const char *cm = command;
    size_t cl = 0;
    // min command length is 2, plus the ""\r\n""
    if (cmdlen < 4) {
        return -1;
    }

    const char *s = memchr(command, ' ', cmdlen-2);
    if (s != NULL) {
        cl = s - command;
    } else {
        cl = cmdlen - 2;
    }
    pr->keytoken = 0;
    pr->has_space = false;
    pr->parsed = cl + 1;
    pr->request = command;
    pr->reqlen = cmdlen;
    int token_max = PARSER_MAX_TOKENS;

    int cmd = -1;
    int type = CMD_TYPE_GENERIC;
    int ret = 0;

    switch (cl) {
        case 0:
        case 1:
            // falls through with cmd as -1. should error.
            break;
        case 2:
            if (cm[0] == 'm') {
                type = CMD_TYPE_META;
                switch (cm[1]) {
        ...",1,20,proxy_request.c,process_request,,false,282,438,process_request,,,12,"int process_request (mcp_parser_t*,char*,size_t)"
75693,METHOD,proxy_request.c:<global>,TYPE_DECL,"mcp_request_t *mcp_new_request(lua_State *L, mcp_parser_t *pr, const char *command, size_t cmdlen) {
    // reserving an upvalue for key.
    mcp_request_t *rq = lua_newuserdatauv(L, sizeof(mcp_request_t) + MCP_REQUEST_MAXLEN * 2 + KEY_MAX_LENGTH, 1);
    // TODO (v2): memset only the non-data part? as the rest gets memcpy'd
    // over.
    memset(rq, 0, sizeof(mcp_request_t));
    memcpy(&rq->pr, pr, sizeof(*pr));

    memcpy(rq->request, command, cmdlen);
    rq->pr.request = rq->request;
    rq->pr.reqlen = cmdlen;
    gettimeofday(&rq->start, NULL);

    luaL_getmetatable(L, ""mcp.request"");
    lua_setmetatable(L, -2);

    // at this point we should know if we have to bounce through _nread to
    // get item data or not.
    return rq;
}",1,69,proxy_request.c,mcp_new_request,,false,441,460,mcp_new_request,,,13,"mcp_request_t mcp_new_request (lua_State*,mcp_parser_t*,char*,size_t)"
75772,METHOD,proxy_request.c:<global>,TYPE_DECL,"void mcp_request_attach(lua_State *L, mcp_request_t *rq, io_pending_proxy_t *p) {
    mcp_parser_t *pr = &rq->pr;
    char *r = (char *) pr->request;
    size_t len = pr->reqlen;

    // one or more of the tokens were changed
    if (rq->was_modified) {
        assert(rq->tokent_ref);
        // option table to top of stack.
        lua_rawgeti(L, LUA_REGISTRYINDEX, rq->tokent_ref);

        // space was reserved in case of modification.
        char *nr = rq->request + MCP_REQUEST_MAXLEN;
        r = nr;
        char *or = NULL;

        for (int x = 0; x < pr->ntokens; x++) {
            const char *newtok = NULL;
            size_t newlen = 0;
            if (x != 0 && x != pr->keytoken) {
                int type = lua_rawgeti(L, -1, x+1);
                if (type != LUA_TNIL) {
                    newtok = lua_tolstring(L, -1, &newlen);
                    memcpy(nr, newtok, newlen);
                    nr += newlen;
                }
                lua_pop(L, 1);
            ...",1,33,proxy_request.c,mcp_request_attach,,false,467,533,mcp_request_attach,,,14,"void mcp_request_attach (lua_State*,mcp_request_t*,io_pending_proxy_t*)"
76040,METHOD,proxy_request.c:<global>,TYPE_DECL,"int mcplib_request(lua_State *L) {
    size_t len = 0;
    size_t vlen = 0;
    mcp_parser_t pr = {0};
    const char *cmd = luaL_checklstring(L, 1, &len);
    const char *val = NULL;
    int type = lua_type(L, 2);
    if (type == LUA_TSTRING) {
        val = luaL_optlstring(L, 2, NULL, &vlen);
        if (vlen < 2 || memcmp(val+vlen-2, ""\r\n"", 2) != 0) {
            proxy_lua_error(L, ""value passed to mcp.request must end with \\r\\n"");
        }
    } else if (type == LUA_TUSERDATA) {
        // vlen for requests and responses include the ""\r\n"" already.
        mcp_resp_t *r = luaL_testudata(L, 2, ""mcp.response"");
        if (r != NULL) {
            if (r->resp.value) {
                val = r->resp.value;
                vlen = r->resp.vlen_read; // paranoia, so we can't overread into memory.
            }
        } else {
            mcp_request_t *rq = luaL_testudata(L, 2, ""mcp.request"");
            if (rq->pr.vbuf) {
                val = rq->pr.vbuf;
                vlen =...",1,1,proxy_request.c,mcplib_request,,false,537,591,mcplib_request,,,15,int mcplib_request (lua_State*)
76249,METHOD,proxy_request.c:<global>,TYPE_DECL,"int mcplib_request_key(lua_State *L) {
    mcp_request_t *rq = luaL_checkudata(L, -1, ""mcp.request"");
    lua_pushlstring(L, MCP_PARSER_KEY(rq->pr), rq->pr.klen);
    return 1;
}",1,23,proxy_request.c,mcplib_request_key,,false,593,597,mcplib_request_key,,,16,int mcplib_request_key (lua_State*)
76294,METHOD,proxy_request.c:<global>,TYPE_DECL,"int mcplib_request_ltrimkey(lua_State *L) {
    mcp_request_t *rq = luaL_checkudata(L, -2, ""mcp.request"");
    int totrim = luaL_checkinteger(L, -1);
    char *key = (char *) MCP_PARSER_KEY(rq->pr);

    if (totrim > rq->pr.klen) {
        proxy_lua_error(L, ""ltrimkey cannot zero out key"");
        return 0;
    } else {
        memset(key, ' ', totrim);
        rq->pr.klen -= totrim;
        rq->pr.tokens[rq->pr.keytoken] += totrim;
    }
    return 1;
}",1,25,proxy_request.c,mcplib_request_ltrimkey,,false,604,618,mcplib_request_ltrimkey,,,17,int mcplib_request_ltrimkey (lua_State*)
76384,METHOD,proxy_request.c:<global>,TYPE_DECL,"int mcplib_request_rtrimkey(lua_State *L) {
    mcp_request_t *rq = luaL_checkudata(L, -2, ""mcp.request"");
    int totrim = luaL_checkinteger(L, -1);
    char *key = (char *) MCP_PARSER_KEY(rq->pr);

    if (totrim > rq->pr.klen) {
        proxy_lua_error(L, ""rtrimkey cannot zero out key"");
        return 0;
    } else {
        memset(key + (rq->pr.klen - totrim), ' ', totrim);
        rq->pr.klen -= totrim;
        // don't need to change the key token.
    }
    return 1;
}",1,25,proxy_request.c,mcplib_request_rtrimkey,,false,620,634,mcplib_request_rtrimkey,,,18,int mcplib_request_rtrimkey (lua_State*)
76469,METHOD,proxy_request.c:<global>,TYPE_DECL,"int mcplib_request_token(lua_State *L) {
    mcp_request_t *rq = luaL_checkudata(L, 1, ""mcp.request"");
    int argc = lua_gettop(L);

    if (argc == 1) {
        lua_pushnil(L);
        return 1;
    }

    int token = luaL_checkinteger(L, 2);

    if (token < 1 || token > rq->pr.ntokens) {
        // maybe an error?
        lua_pushnil(L);
        return 1;
    }

    // we hold overwritten or parsed tokens in a lua table.
    if (rq->tokent_ref == 0) {
        // create a presized table that can hold our tokens.
        lua_createtable(L, rq->pr.ntokens, 0);
        // duplicate value to set back
        lua_pushvalue(L, -1);
        rq->tokent_ref = luaL_ref(L, LUA_REGISTRYINDEX);
    } else {
        lua_rawgeti(L, LUA_REGISTRYINDEX, rq->tokent_ref);
    }
    // top of stack should be token table.

    size_t vlen = 0;
    if (argc > 2) {
        // overwriting a token.
        luaL_checklstring(L, 3, &vlen);
        lua_pushvalue(L, 3); // copy to top of stack
        lua_raw...",1,12,proxy_request.c,mcplib_request_token,,false,637,695,mcplib_request_token,,,19,int mcplib_request_token (lua_State*)
76640,METHOD,proxy_request.c:<global>,TYPE_DECL,"int mcplib_request_ntokens(lua_State *L) {
    mcp_request_t *rq = luaL_checkudata(L, 1, ""mcp.request"");
    lua_pushinteger(L, rq->pr.ntokens);
    return 1;
}",1,1,proxy_request.c,mcplib_request_ntokens,,false,697,701,mcplib_request_ntokens,,,20,int mcplib_request_ntokens (lua_State*)
76661,METHOD,proxy_request.c:<global>,TYPE_DECL,"int mcplib_request_command(lua_State *L) {
    mcp_request_t *rq = luaL_checkudata(L, -1, ""mcp.request"");
    lua_pushinteger(L, rq->pr.command);
    return 1;
}",1,1,proxy_request.c,mcplib_request_command,,false,703,707,mcplib_request_command,,,21,int mcplib_request_command (lua_State*)
76683,METHOD,proxy_request.c:<global>,TYPE_DECL,"int mcplib_request_has_flag(lua_State *L) {
    mcp_request_t *rq = luaL_checkudata(L, 1, ""mcp.request"");
    size_t len = 0;
    const char *flagstr = luaL_checklstring(L, 2, &len);
    if (len != 1) {
        proxy_lua_error(L, ""has_flag(): meta flag must be a single character"");
        return 0;
    }
    if (flagstr[0] < 65 || flagstr[0] > 122) {
        proxy_lua_error(L, ""has_flag(): invalid flag, must be A-Z,a-z"");
        return 0;
    }
    uint64_t flagbit = (uint64_t)1 << (flagstr[0] - 65);
    if (rq->pr.t.meta.flags & flagbit) {
        lua_pushboolean(L, 1);
    } else {
        lua_pushboolean(L, 0);
    }

    return 1;
}",1,1,proxy_request.c,mcplib_request_has_flag,,false,709,729,mcplib_request_has_flag,,,22,int mcplib_request_has_flag (lua_State*)
76770,METHOD,proxy_request.c:<global>,TYPE_DECL,"int mcplib_request_flag_token(lua_State *L) {
    mcp_request_t *rq = luaL_checkudata(L, 1, ""mcp.request"");
    size_t len = 0;
    const char *flagstr = luaL_checklstring(L, 2, &len);
    bool replace = false;
    if (len != 1) {
        proxy_lua_error(L, ""has_flag(): meta flag must be a single character"");
        return 0;
    }
    if (flagstr[0] < 65 || flagstr[0] > 122) {
        proxy_lua_error(L, ""has_flag(): invalid flag, must be A-Z,a-z"");
        return 0;
    }
    if (lua_isstring(L, 3)) {
        // overwriting a flag/token with the third argument.
        // NOTE: semi duplicated from mcplib_request_token()
        if (rq->tokent_ref == 0) {
            // create a presized table that can hold our tokens.
            lua_createtable(L, rq->pr.ntokens, 0);
            rq->tokent_ref = luaL_ref(L, LUA_REGISTRYINDEX);
        }
        replace = true;
    }
    uint64_t flagbit = (uint64_t)1 << (flagstr[0] - 65);

    int ret = 1;
    if (rq->pr.t.meta.flags & flagbit) ...",1,1,proxy_request.c,mcplib_request_flag_token,,false,733,792,mcplib_request_flag_token,,,23,int mcplib_request_flag_token (lua_State*)
76995,METHOD,proxy_request.c:<global>,TYPE_DECL,"int mcplib_request_gc(lua_State *L) {
    mcp_request_t *rq = luaL_checkudata(L, -1, ""mcp.request"");
    // During nread c->item is the malloc'ed buffer. not yet put into
    // rq->buf - this gets freed because we've also set c->item_malloced if
    // the connection closes before finishing nread.
    if (rq->pr.vbuf != NULL) {
        free(rq->pr.vbuf);
    }

    if (rq->tokent_ref != 0) {
        luaL_unref(L, LUA_REGISTRYINDEX, rq->tokent_ref);
    }
    return 0;
}",1,1,proxy_request.c,mcplib_request_gc,,false,794,807,mcplib_request_gc,,,24,int mcplib_request_gc (lua_State*)
77045,METHOD,proxy_ring_hash.c:<global>,TYPE_DECL,<global>,1,1,proxy_ring_hash.c,proxy_ring_hash.c:<global>,,false,1,369,<global>,,,1,
77056,METHOD,<empty>,<empty>,<empty>,1,,proxy_ring_hash.c,ketama_t:<clinit>,,false,42,,<clinit>,,,5,
77062,METHOD,proxy_ring_hash.c:<global>,TYPE_DECL,"static uint64_t ketama_key_hasher(const void *key, size_t len, uint64_t seed);",17,77,proxy_ring_hash.c,ketama_key_hasher,,false,48,48,ketama_key_hasher,,,5,"uint64_t ketama_key_hasher (void*,size_t,uint64_t)"
77075,METHOD,proxy_ring_hash.c:<global>,TYPE_DECL,"static void ketama_md5_digest( char* inString, unsigned char md5pword[16] )
{
    md5_state_t md5state;

    md5_init( &md5state );
    md5_append( &md5state, (unsigned char *)inString, strlen( inString ) );
    md5_finish( &md5state, md5pword );
}",1,1,proxy_ring_hash.c,ketama_md5_digest,,false,54,61,ketama_md5_digest,,,9,"void ketama_md5_digest (char*,unsigned char[16])"
77097,METHOD,proxy_ring_hash.c:<global>,TYPE_DECL,"static int ketama_compare(const void *p1, const void *p2) {
    const cpoint *a = p1;
    const cpoint *b = p2;

    return (a->point < b->point) ? -1 : ((a->point > b->point) ? 1 : 0);
}",1,1,proxy_ring_hash.c,ketama_compare,,false,63,68,ketama_compare,,,10,"int ketama_compare (void*,void*)"
77132,METHOD,proxy_ring_hash.c:<global>,TYPE_DECL,"static uint64_t ketama_key_hasher(const void *key, size_t len, uint64_t seed) {
    // NOTE: seed is ignored!
    // embedding the md5 bits since key is specified with a length here.
    md5_state_t md5state;
    unsigned char digest[16];

    md5_init(&md5state);
    md5_append(&md5state, (unsigned char *)key, len);
    md5_finish(&md5state, digest);

    // mix the hash down (from ketama_hashi)
    unsigned int h = (unsigned int)(( digest[3] << 24 )
                        | ( digest[2] << 16 )
                        | ( digest[1] <<  8 )
                        |   digest[0] );
    return h;
}",1,1,proxy_ring_hash.c,ketama_key_hasher,,false,70,86,ketama_key_hasher,,,11,"uint64_t ketama_key_hasher (void*,size_t,uint64_t)"
77183,METHOD,proxy_ring_hash.c:<global>,TYPE_DECL,"static uint32_t ketama_get_server(uint64_t hash, void *ctx) {
    ketama_t *kt = (ketama_t *)ctx;
    unsigned int h = hash;
    int highp = kt->total_buckets;
    int lowp = 0, midp;
    unsigned int midval, midval1;

    // divide and conquer array search to find server with next biggest
    // point after what this key hashes to
    while ( 1 )
    {
        midp = (int)( ( lowp+highp ) / 2 );

        if ( midp == kt->total_buckets )
            return kt->continuum[0].id-1; // if at the end, roll back to zeroth

        midval = kt->continuum[midp].point;
        midval1 = midp == 0 ? 0 : kt->continuum[midp-1].point;

        if ( h <= midval && h > midval1 )
            return kt->continuum[midp].id-1;

        if ( midval < h )
            lowp = midp + 1;
        else
            highp = midp - 1;

        if ( lowp > highp )
            return kt->continuum[0].id-1;
    }
}",1,1,proxy_ring_hash.c,ketama_get_server,,false,89,119,ketama_get_server,,,12,"uint32_t ketama_get_server (uint64_t,void*)"
77317,METHOD,proxy_ring_hash.c:<global>,TYPE_DECL,"static void _add_server_default(ketama_t *kt, size_t hashstring_size, const char **parts,
        lua_Integer bucket_size, lua_Integer id, unsigned int *cont) {
    char *hashstring = malloc(hashstring_size);

    for (int k = 0; k < bucket_size; k++) {
        size_t len = snprintf(hashstring, hashstring_size, ""%s:%s-%d"", parts[0], parts[1], k);
        kt->continuum[*cont].point = (unsigned int) XXH3_64bits(hashstring, len);
        kt->continuum[*cont].id = id;
    }

    free(hashstring);
}",1,52,proxy_ring_hash.c,_add_server_default,,false,130,141,_add_server_default,,,13,"void _add_server_default (ketama_t*,size_t,char**,lua_Integer,lua_Integer,unsigned int*)"
77386,METHOD,proxy_ring_hash.c:<global>,TYPE_DECL,"static void _add_server_ketama(ketama_t *kt, size_t hashstring_size, const char **parts,
        lua_Integer bucket_size, lua_Integer id, unsigned int *cont) {
    char *hashstring = malloc(hashstring_size);

    for (int k = 0; k < bucket_size / 4; k++) {
        unsigned char digest[16];

        // - create hashing string for ketama
        snprintf(hashstring, hashstring_size, ""%s:%s-%d"", parts[0], parts[1], k);

        // - md5() hash it
        // mostly from ketama.c
        ketama_md5_digest(hashstring, digest);

        /* Use successive 4-bytes from hash as numbers
         * for the points on the circle: */
        for(int h = 0; h < 4; h++ )
        {
            kt->continuum[*cont].point = ( digest[3+h*4] << 24 )
                                  | ( digest[2+h*4] << 16 )
                                  | ( digest[1+h*4] <<  8 )
                                  |   digest[h*4];
            kt->continuum[*cont].id = id;
            (*cont)++;
        }

    }

    f...",1,1,proxy_ring_hash.c,_add_server_ketama,,false,143,172,_add_server_ketama,,,14,"void _add_server_ketama (ketama_t*,size_t,char**,lua_Integer,lua_Integer,unsigned int*)"
77501,METHOD,proxy_ring_hash.c:<global>,TYPE_DECL,"static void _add_server_twemproxy(ketama_t *kt, size_t hashstring_size, const char **parts,
        lua_Integer bucket_size, lua_Integer id, unsigned int *cont) {
    char *hashstring = malloc(hashstring_size);

    for (int k = 0; k < bucket_size / 4; k++) {
        unsigned char digest[16];

        // - create hashing string for ketama
        if (strcmp(parts[1], ""11211"") == 0) {
            // twemproxy sources libmemcached as removing the default port
            // from the string if found.
            snprintf(hashstring, hashstring_size, ""%s-%d"", parts[0], k);
        } else {
            snprintf(hashstring, hashstring_size, ""%s:%s-%d"", parts[0], parts[1], k);
        }

        // - md5() hash it
        // mostly from ketama.c
        ketama_md5_digest(hashstring, digest);

        /* Use successive 4-bytes from hash as numbers
         * for the points on the circle: */
        for(int h = 0; h < 4; h++ )
        {
            kt->continuum[*cont].point = ( digest[3+h*4...",1,1,proxy_ring_hash.c,_add_server_twemproxy,,false,174,209,_add_server_twemproxy,,,15,"void _add_server_twemproxy (ketama_t*,size_t,char**,lua_Integer,lua_Integer,unsigned int*)"
77635,METHOD,proxy_ring_hash.c:<global>,TYPE_DECL,"static void _add_server_evcache(ketama_t *kt, size_t hashstring_size, const char **parts,
        lua_Integer bucket_size, lua_Integer id, unsigned int *cont) {
    char *hashstring = malloc(hashstring_size);

    for (int k = 0; k < bucket_size / 4; k++) {
        unsigned char digest[16];

        // - create hashing string for ketama
        snprintf(hashstring, hashstring_size, ""%s/%s:%s-%d"", parts[0], parts[0], parts[1], k);
        // - md5() hash it
        // mostly from ketama.c
        ketama_md5_digest(hashstring, digest);

        /* Use successive 4-bytes from hash as numbers
         * for the points on the circle: */
        for(int h = 0; h < 4; h++ )
        {
            kt->continuum[*cont].point = ( digest[3+h*4] << 24 )
                                  | ( digest[2+h*4] << 16 )
                                  | ( digest[1+h*4] <<  8 )
                                  |   digest[h*4];
            kt->continuum[*cont].id = id;
            (*cont)++;
        }
...",1,1,proxy_ring_hash.c,_add_server_evcache,,false,211,239,_add_server_evcache,,,16,"void _add_server_evcache (ketama_t*,size_t,char**,lua_Integer,lua_Integer,unsigned int*)"
77753,METHOD,proxy_ring_hash.c:<global>,TYPE_DECL,"static int ketama_new(lua_State *L) {
    lua_Integer bucket_size = DEFAULT_BUCKET_SIZE;
    const char *parts[PARTS];
    size_t partlens[PARTS];
    int makemode = 0;

    // check for UA_TTABLE at 1
    luaL_checktype(L, 1, LUA_TTABLE);
    // get number of servers in pool.
    // NOTE: rawlen skips metatable redirection. if we care; lua_len instead.
    lua_Unsigned total = lua_rawlen(L, 1);

    // check for optional input
    int argc = lua_gettop(L);
    if (argc > 1) {
        luaL_checktype(L, 2, LUA_TTABLE);
        if (lua_getfield(L, 2, ""omode"") != LUA_TNIL) {
            luaL_checktype(L, -1, LUA_TSTRING);
            const char *mode = lua_tostring(L, -1);
            if (strcmp(mode, ""default"") == 0) {
                makemode = MODE_DEFAULT;
            } else if (strcmp(mode, ""ketama"") == 0) {
                makemode = MODE_KETAMA;
            } else if (strcmp(mode, ""twemproxy"") == 0) {
                makemode = MODE_TWEMPROXY;
            } else if (strcmp(mode,...",1,30,proxy_ring_hash.c,ketama_new,,false,243,356,ketama_new,,,17,int ketama_new (lua_State*)
78128,METHOD,proxy_ring_hash.c:<global>,TYPE_DECL,"int mcplib_open_dist_ring_hash(lua_State *L) {
    const struct luaL_Reg ketama_f[] = {
        {""new"", ketama_new},
        {NULL, NULL},
    };

    luaL_newlib(L, ketama_f);
    lua_pushlightuserdata(L, &ketama_key_hash);
    lua_setfield(L, -2, ""hash"");

    return 1;
}",1,1,proxy_ring_hash.c,mcplib_open_dist_ring_hash,,false,358,369,mcplib_open_dist_ring_hash,,,18,int mcplib_open_dist_ring_hash (lua_State*)
78162,METHOD,proxy_ustats.c:<global>,TYPE_DECL,<global>,1,1,proxy_ustats.c,proxy_ustats.c:<global>,,false,1,99,<global>,,,1,
78164,METHOD,proxy_ustats.c:<global>,TYPE_DECL,"int mcplib_add_stat(lua_State *L) {
    LIBEVENT_THREAD *t = lua_touserdata(L, lua_upvalueindex(MCP_THREAD_UPVALUE));
    if (t != NULL) {
        proxy_lua_error(L, ""add_stat must be called from config_pools"");
        return 0;
    }
    int idx = luaL_checkinteger(L, -2);
    const char *name = luaL_checkstring(L, -1);

    if (idx < 1) {
        proxy_lua_error(L, ""stat index must be 1 or higher"");
        return 0;
    }
    // max user counters? 1024? some weird number.
    if (idx > 1024) {
        proxy_lua_error(L, ""stat index must be 1024 or less"");
        return 0;
    }
    // max name length? avoids errors if something huge gets thrown in.
    if (strlen(name) > STAT_KEY_LEN - 6) {
        // we prepend ""user_"" to the output. + null byte.
        proxy_lua_ferror(L, ""stat name too long: %s\n"", name);
        return 0;
    }
    // restrict characters, at least no spaces/newlines.
    for (int x = 0; x < strlen(name); x++) {
        if (isspace(name[x])) {
            p...",1,60,proxy_ustats.c,mcplib_add_stat,,false,7,70,mcplib_add_stat,,,1,int mcplib_add_stat (lua_State*)
78376,METHOD,proxy_ustats.c:<global>,TYPE_DECL,"int mcplib_stat(lua_State *L) {
    LIBEVENT_THREAD *t = lua_touserdata(L, lua_upvalueindex(MCP_THREAD_UPVALUE));
    if (t == NULL) {
        proxy_lua_error(L, ""stat must be called from router handlers"");
        return 0;
    }

    struct proxy_user_stats *tus = t->proxy_user_stats;
    if (tus == NULL) {
        proxy_lua_error(L, ""no stats counters initialized"");
        return 0;
    }

    int idx = luaL_checkinteger(L, -2);
    int change = luaL_checkinteger(L, -1);

    if (idx < 1 || idx > tus->num_stats) {
        proxy_lua_error(L, ""stat index out of range"");
        return 0;
    }

    idx--; // actual array is 0 indexed.
    WSTAT_L(t);
    tus->counters[idx] += change;
    WSTAT_UL(t);

    return 0;
}",1,60,proxy_ustats.c,mcplib_stat,,false,72,99,mcplib_stat,,,2,int mcplib_stat (lua_State*)
78482,METHOD,proxy_xxhash.c:<global>,TYPE_DECL,<global>,1,1,proxy_xxhash.c,proxy_xxhash.c:<global>,,false,1,12,<global>,,,1,
78492,METHOD,proxy_xxhash.c:<global>,TYPE_DECL,"int mcplib_open_hash_xxhash(lua_State *L) {
    lua_pushlightuserdata(L, &mcplib_hash_xxhash);
    return 1;
}",1,1,proxy_xxhash.c,mcplib_open_hash_xxhash,,false,9,12,mcplib_open_hash_xxhash,,,4,int mcplib_open_hash_xxhash (lua_State*)
78506,METHOD,queue.h:<global>,TYPE_DECL,<global>,1,27,queue.h,queue.h:<global>,,false,1,870,<global>,,,1,
78529,METHOD,restart.c:<global>,TYPE_DECL,<global>,1,1,memcached.h,restart.c:<global>,,false,1,443,<global>,,,1,
78540,METHOD,<empty>,<empty>,<empty>,1,,restart.c,_restart_data_cb:<clinit>,,false,15,,<clinit>,,,7,
78568,METHOD,restart.c:<global>,TYPE_DECL,"void restart_register(const char *tag, restart_check_cb ccb, restart_save_cb scb, void *data) {
    restart_data_cb *cb = calloc(1, sizeof(restart_data_cb));
    if (cb == NULL) {
        fprintf(stderr, ""[restart] failed to allocate callback register\n"");
        abort();
    }

    // Handle first time call initialization inline so we don't need separate
    // API call.
    if (cb_stack == NULL) {
        cb_stack = cb;
    } else {
        // Ensure we fire the callbacks in registration order.
        // Someday I'll get a queue.h overhaul.
        restart_data_cb *finder = cb_stack;
        while (finder->next != NULL) {
            finder = finder->next;
        }
        finder->next = cb;
    }

    safe_strcpy(cb->tag, tag, RESTART_TAG_MAXLEN);
    cb->data = data;
    cb->ccb = *ccb;
    cb->scb = *scb;
}",1,30,restart.c,restart_register,,false,33,58,restart_register,,,14,"void restart_register (char*,restart_check_cb,restart_save_cb,void*)"
78654,METHOD,restart.c:<global>,TYPE_DECL,"static int restart_check(const char *file) {
    // metadata is kept in a separate file.
    size_t flen = strlen(file);
    const char *ext = "".meta"";
    char *metafile = calloc(1, flen + strlen(ext) + 1);
    if (metafile == NULL) {
        // probably in a really bad position if we hit here, so don't start.
        fprintf(stderr, ""[restart] failed to allocate memory for restart check\n"");
        abort();
    }
    memcpy(metafile, file, flen);
    memcpy(metafile+flen, ext, strlen(ext));

    FILE *f = fopen(metafile, ""r"");
    if (f == NULL) {
        fprintf(stderr, ""[restart] no metadata save file, starting with a clean cache\n"");
        free(metafile);
        return -1;
    }

    restart_cb_ctx ctx;

    ctx.f = f;
    ctx.cb = NULL;
    ctx.line = NULL;
    ctx.done = false;
    if (restart_get_kv(&ctx, NULL, NULL) != RESTART_DONE) {
        // First line must be a tag, so read it in and set up the proper
        // callback here.
        fprintf(stderr, ""[restart] cor...",1,1,restart.c,restart_check,,false,72,134,restart_check,,,17,int restart_check (char*)
78827,METHOD,restart.c:<global>,TYPE_DECL,"enum restart_get_kv_ret restart_get_kv(void *ctx, char **key, char **val) {
    char *line = NULL;
    size_t len = 0;
    restart_data_cb *cb = NULL;
    restart_cb_ctx *c = (restart_cb_ctx *) ctx;
    // free previous line.
    // we could just pass it into getline, but it can randomly realloc so we'd
    // have to re-assign it into the structure anyway.
    if (c->line != NULL) {
        free(c->line);
        c->line = NULL;
    }

    if (getline(&line, &len, c->f) != -1) {
        // First char is an indicator:
        // T for TAG, changing the callback we use.
        // K for key/value, to ship to the active callback.
        char *p = line;
        while (*p != '\n') {
            p++;
        }
        *p = '\0';

        if (line[0] == 'T') {
            cb = cb_stack;
            while (cb != NULL) {
                // NOTE: len is allocated size, not line len. need to chomp \n
                if (strcmp(cb->tag, line+1) == 0) {
                    break;
             ...",1,1,restart.c,restart_get_kv,,false,141,211,restart_get_kv,,,18,"enum restart_get_kv_ret restart_get_kv (void*,char**,char**)"
79026,METHOD,restart.c:<global>,TYPE_DECL,"static int restart_save(const char *file) {
    // metadata is kept in a separate file.
    // FIXME: function.
    size_t flen = strlen(file);
    const char *ext = "".meta"";
    size_t extlen = strlen(ext);
    char *metafile = calloc(1, flen + extlen + 1);
    if (metafile == NULL) {
        fprintf(stderr, ""[restart] failed to allocate memory during metadata save\n"");
        return -1;
    }
    memcpy(metafile, file, flen);
    memcpy(metafile+flen, ext, extlen);

    // restrictive permissions for the metadata file.
    // TODO: also for the mmap file eh? :P
    mode_t oldmask = umask(~(S_IRUSR | S_IWUSR));
    FILE *f = fopen(metafile, ""w"");
    umask(oldmask);
    if (f == NULL) {
        // FIXME: correct error handling.
        free(metafile);
        perror(""failed to write metadata file"");
        return -1;
    }

    restart_data_cb *cb = cb_stack;
    restart_cb_ctx ctx;
    ctx.f = f;
    while (cb != NULL) {
        // Plugins/engines in the metadata file are separa...",1,1,restart.c,restart_save,,false,217,262,restart_save,,,19,int restart_save (char*)
79159,METHOD,restart.c:<global>,TYPE_DECL,"void restart_set_kv(void *ctx, const char *key, const char *fmt, ...) {
    va_list ap;
    restart_cb_ctx *c = (restart_cb_ctx *) ctx;
    char valbuf[SET_VAL_MAX];

    va_start(ap, fmt);
    int vlen = vsnprintf(valbuf, SET_VAL_MAX-1, fmt, ap);
    va_end(ap);
    // This is heavy handed. We need to protect against corrupt data as much
    // as possible. The buffer is large and these values are currently small,
    // it will take a significant mistake to land here.
    if (vlen >= SET_VAL_MAX) {
        fprintf(stderr, ""[restart] fatal error while saving metadata state, value too long for: %s %s"",
                key, valbuf);
        abort();
    }

    fprintf(c->f, ""K%s %s\n"", key, valbuf);
    // TODO: update crc32c
}",1,16,restart.c,restart_set_kv,,false,268,287,restart_set_kv,,,20,"void restart_set_kv (void*,char*,char*...)"
79211,METHOD,restart.c:<global>,TYPE_DECL,"static long _find_pagesize(void) {
#if defined(HAVE_SYSCONF) && defined(_SC_PAGESIZE)
    return sysconf(_SC_PAGESIZE);
#else
    // A good guess.
    return 4096;
#endif
}",1,1,restart.c,_find_pagesize,,false,289,296,_find_pagesize,,,21,long _find_pagesize (void)
79218,METHOD,restart.c:<global>,TYPE_DECL,"bool restart_mmap_open(const size_t limit, const char *file, void **mem_base) {
    bool reuse_mmap = true;

    long pagesize = _find_pagesize();
    memory_file = strdup(file);
    mmap_fd = open(file, O_RDWR|O_CREAT, S_IRWXU);
    if (mmap_fd == -1) {
        perror(""failed to open file for mmap"");
        abort();
    }
    if (ftruncate(mmap_fd, limit) != 0) {
        perror(""ftruncate failed"");
        abort();
    }
    /* Allocate everything in a big chunk with malloc */
    if (limit % pagesize) {
        // This is a sanity check; shouldn't ever be possible since we
        // increase memory by whole megabytes.
        fprintf(stderr, ""[restart] memory limit not divisible evenly by pagesize (please report bug)\n"");
        abort();
    }
    mmap_base = mmap(NULL, limit, PROT_READ|PROT_WRITE, MAP_SHARED, mmap_fd, 0);
    if (mmap_base == MAP_FAILED) {
        perror(""failed to mmap, aborting"");
        abort();
    }
    // Set the limit before calling check_mmap, so we c...",1,1,restart.c,restart_mmap_open,,false,298,332,restart_mmap_open,,,22,"bool restart_mmap_open (size_t,char*,void**)"
79310,METHOD,restart.c:<global>,TYPE_DECL,"void restart_mmap_close(void) {
    msync(mmap_base, slabmem_limit, MS_SYNC);

    if (restart_save(memory_file) != 0) {
        fprintf(stderr, ""[restart] failed to save metadata"");
    }

    if (munmap(mmap_base, slabmem_limit) != 0) {
        perror(""[restart] failed to munmap shared memory"");
    } else if (close(mmap_fd) != 0) {
        perror(""[restart] failed to close shared memory fd"");
    }

    free(memory_file);
}",1,1,restart.c,restart_mmap_close,,false,335,349,restart_mmap_close,,,23,void restart_mmap_close (void)
79349,METHOD,restart.c:<global>,TYPE_DECL,"unsigned int restart_fixup(void *orig_addr) {
    struct timeval tv;
    uint64_t checked = 0;
    const unsigned int page_size = settings.slab_page_size;
    unsigned int page_remain = page_size;

    gettimeofday(&tv, NULL);
    if (settings.verbose > 0) {
        fprintf(stderr, ""[restart] original memory base: [%p] new base: [%p]\n"", orig_addr, mmap_base);
        fprintf(stderr, ""[restart] recovery start [%d.%d]\n"", (int)tv.tv_sec, (int)tv.tv_usec);
    }

    // since chunks don't align with pages, we have to also track page size.
    while (checked < slabmem_limit) {
        //fprintf(stderr, ""checked: %lu\n"", checked);
        item *it = (item *)((char *)mmap_base + checked);

        int size = slabs_fixup((char *)mmap_base + checked,
                checked % settings.slab_page_size);
        //fprintf(stderr, ""id: %d, size: %d remain: %u\n"", it->slabs_clsid, size, page_remain);
        // slabber gobbled an entire page, skip and move on.
        if (size == -1) {
        ...",1,27,restart.c,restart_fixup,,false,354,443,restart_fixup,,,24,unsigned int restart_fixup (void*)
79759,METHOD,restart.h:<global>,TYPE_DECL,<global>,1,6,restart.h,restart.h:<global>,,false,1,28,<global>,,,1,
79767,METHOD,<empty>,<empty>,<empty>,1,,restart.h,restart_get_kv_ret:<clinit>,,false,13,,<clinit>,,,5,
79774,METHOD,restart.h:<global>,TYPE_DECL,"typedef int (*restart_check_cb)(const char *tag, void *ctx, void *data);",13,71,restart.h,restart_check_cb,,false,17,17,restart_check_cb,,,3,"int restart_check_cb (char*,void*,void*)"
79781,METHOD,restart.h:<global>,TYPE_DECL,"typedef int (*restart_save_cb)(const char *tag, void *ctx, void *data);",13,70,restart.h,restart_save_cb,,false,18,18,restart_save_cb,,,4,"int restart_save_cb (char*,void*,void*)"
79788,METHOD,restart.h:<global>,TYPE_DECL,"void restart_register(const char *tag, restart_check_cb ccb, restart_save_cb scb, void *data);",6,93,restart.h,restart_register,,false,19,19,restart_register,,,5,"void restart_register (char*,restart_check_cb,restart_save_cb,void*)"
79796,METHOD,restart.h:<global>,TYPE_DECL,"void restart_set_kv(void *ctx, const char *key, const char *fmt, ...);",6,69,restart.h,restart_set_kv,,false,21,21,restart_set_kv,,,6,"void restart_set_kv (void*,char*,char*...)"
79805,METHOD,restart.h:<global>,TYPE_DECL,"bool restart_mmap_open(const size_t limit, const char *file, void **mem_base);",6,77,restart.h,restart_mmap_open,,false,24,24,restart_mmap_open,,,9,"bool restart_mmap_open (size_t,char*,void**)"
79812,METHOD,restart.h:<global>,TYPE_DECL,void restart_mmap_close(void);,6,29,restart.h,restart_mmap_close,,false,25,25,restart_mmap_close,,,10,void restart_mmap_close (void)
79817,METHOD,restart.h:<global>,TYPE_DECL,unsigned int restart_fixup(void *old_base);,14,42,restart.h,restart_fixup,,false,26,26,restart_fixup,,,11,unsigned int restart_fixup (void*)
79835,METHOD,sasl_defs.c:<global>,TYPE_DECL,<global>,1,78,sasl_defs.c,sasl_defs.c:<global>,,false,1,223,<global>,,,1,
79840,METHOD,sasl_defs.c:<global>,TYPE_DECL,typedef int (*sasl_callback_ft)(void);,13,37,sasl_defs.c,sasl_callback_ft,,false,39,39,sasl_callback_ft,,,3,int sasl_callback_ft (void)
79845,METHOD,sasl_defs.c:<global>,TYPE_DECL,"static int sasl_log(void *context, int level, const char *message)
{
    bool log = true;

    switch (level) {
    case SASL_LOG_NONE:
        log = false;
        break;
    case SASL_LOG_PASS:
    case SASL_LOG_TRACE:
    case SASL_LOG_DEBUG:
    case SASL_LOG_NOTE:
        if (settings.verbose < 2) {
            log = false;
        }
        break;
    case SASL_LOG_WARN:
    case SASL_LOG_FAIL:
        if (settings.verbose < 1) {
            log = false;
        }
        break;
    default:
        /* This is an error */
        ;
    }

    if (log) {
        fprintf(stderr, ""SASL (severity %d): %s\n"", level, message);
    }

    return SASL_OK;
}",1,11,sasl_defs.c,sasl_log,,false,141,173,sasl_log,,,4,"int sasl_log (void*,int,char*)"
79933,METHOD,sasl_defs.h:<global>,TYPE_DECL,<global>,1,24,sasl_defs.h,sasl_defs.h:<global>,,false,1,31,<global>,,,1,
79943,METHOD,sizes.c:<global>,TYPE_DECL,<global>,1,1,sizes.c,sizes.c:<global>,,false,1,35,<global>,,,1,
79945,METHOD,sizes.c:<global>,TYPE_DECL,"static void display(const char *name, size_t size) {
    printf(""%s\t%d\n"", name, (int)size);
}",1,1,sizes.c,display,,false,5,7,display,,,1,"void display (char*,size_t)"
79957,METHOD,sizes.c:<global>,TYPE_DECL,"int main(int argc, char **argv) {

    display(""Slab Stats"", sizeof(struct slab_stats));
    display(""Thread stats"",
            sizeof(struct thread_stats)
            - (200 * sizeof(struct slab_stats)));
    display(""Global stats"", sizeof(struct stats));
    display(""Settings"", sizeof(struct settings));
    display(""Item (no cas)"", sizeof(item));
    display(""Item (cas)"", sizeof(item) + sizeof(uint64_t));
#ifdef EXTSTORE
    display(""extstore header"", sizeof(item_hdr));
#endif
    display(""Libevent thread"",
            sizeof(LIBEVENT_THREAD) - sizeof(struct thread_stats));
    display(""Connection"", sizeof(conn));
    display(""Response object"", sizeof(mc_resp));
    display(""Response bundle"", sizeof(mc_resp_bundle));
    display(""Response objects per bundle"", MAX_RESP_PER_BUNDLE);

    printf(""----------------------------------------\n"");

    display(""libevent thread cumulative"", sizeof(LIBEVENT_THREAD));
    display(""Thread stats cumulative\t"", sizeof(struct thread_stats));

  ...",1,43,sizes.c,main,,false,9,35,main,,,2,"int main (int,char**)"
80048,METHOD,slab_automove.c:<global>,TYPE_DECL,<global>,1,78,slab_automove.c,slab_automove.c:<global>,,false,1,169,<global>,,,1,
80065,METHOD,<empty>,<empty>,<empty>,1,,slab_automove.c,slab_automove:<clinit>,,false,23,,<clinit>,,,10,
80094,METHOD,slab_automove.c:<global>,TYPE_DECL,"void *slab_automove_init(struct settings *settings) {
    uint32_t window_size = settings->slab_automove_window;
    double max_age_ratio = settings->slab_automove_ratio;
    slab_automove *a = calloc(1, sizeof(slab_automove));
    if (a == NULL)
        return NULL;
    a->window_data = calloc(window_size * MAX_NUMBER_OF_SLAB_CLASSES, sizeof(struct window_data));
    a->window_size = window_size;
    a->max_age_ratio = max_age_ratio;
    if (a->window_data == NULL) {
        free(a);
        return NULL;
    }

    // do a dry run to fill the before structs
    fill_item_stats_automove(a->iam_before);
    fill_slab_stats_automove(a->sam_before);

    return (void *)a;
}",1,42,slab_automove.c,slab_automove_init,,false,34,53,slab_automove_init,,,4,void* slab_automove_init (settings*)
80172,METHOD,slab_automove.c:<global>,TYPE_DECL,"void slab_automove_free(void *arg) {
    slab_automove *a = (slab_automove *)arg;
    free(a->window_data);
    free(a);
}",1,1,slab_automove.c,slab_automove_free,,false,55,59,slab_automove_free,,,5,void slab_automove_free (void*)
80189,METHOD,slab_automove.c:<global>,TYPE_DECL,"static void window_sum(struct window_data *wd, struct window_data *w, uint32_t size) {
    int x;
    for (x = 0; x < size; x++) {
        struct window_data *d = &wd[x];
        w->age += d->age;
        w->dirty += d->dirty;
        w->evicted_ratio += d->evicted_ratio;
        w->evicted_seen += d->evicted_seen;
    }
}",1,1,slab_automove.c,window_sum,,false,61,70,window_sum,,,6,"void window_sum (window_data*,window_data*,uint32_t)"
80243,METHOD,slab_automove.c:<global>,TYPE_DECL,"void slab_automove_run(void *arg, int *src, int *dst) {
    slab_automove *a = (slab_automove *)arg;
    int n;
    struct window_data w_sum;
    int oldest = -1;
    uint64_t oldest_age = 0;
    int youngest = -1;
    uint64_t youngest_age = ~0;
    bool youngest_evicting = false;
    *src = -1;
    *dst = -1;

    // fill after structs
    fill_item_stats_automove(a->iam_after);
    fill_slab_stats_automove(a->sam_after);
    // Loop once to get total_evicted for this window.
    uint64_t evicted_total = 0;
    for (n = POWER_SMALLEST; n < MAX_NUMBER_OF_SLAB_CLASSES; n++) {
        evicted_total += a->iam_after[n].evicted - a->iam_before[n].evicted;
    }
    a->window_cur++;

    // iterate slabs
    for (n = POWER_SMALLEST; n < MAX_NUMBER_OF_SLAB_CLASSES; n++) {
        int w_offset = n * a->window_size;
        struct window_data *wd = &a->window_data[w_offset + (a->window_cur % a->window_size)];
        memset(wd, 0, sizeof(struct window_data));

        // if page delta, or e...",1,13,slab_automove.c,slab_automove_run,,false,74,169,slab_automove_run,,,7,"void slab_automove_run (void*,int*,int*)"
80696,METHOD,slab_automove.h:<global>,TYPE_DECL,<global>,1,6,slab_automove.h,slab_automove.h:<global>,,false,1,19,<global>,,,1,
80698,METHOD,slab_automove.h:<global>,TYPE_DECL,void *slab_automove_init(struct settings *settings);,6,51,slab_automove.h,slab_automove_init,,false,5,5,slab_automove_init,,,1,void* slab_automove_init (settings*)
80703,METHOD,slab_automove.h:<global>,TYPE_DECL,void slab_automove_free(void *arg);,6,34,slab_automove.h,slab_automove_free,,false,6,6,slab_automove_free,,,2,void slab_automove_free (void*)
80708,METHOD,slab_automove.h:<global>,TYPE_DECL,"void slab_automove_run(void *arg, int *src, int *dst);",6,53,slab_automove.h,slab_automove_run,,false,7,7,slab_automove_run,,,3,"void slab_automove_run (void*,int*,int*)"
80715,METHOD,slab_automove.h:<global>,TYPE_DECL,typedef void *(*slab_automove_init_func)(struct settings *settings);,14,67,slab_automove.h,slab_automove_init_func,,false,9,9,slab_automove_init_func,,,4,void* slab_automove_init_func (settings*)
80720,METHOD,slab_automove.h:<global>,TYPE_DECL,typedef void (*slab_automove_free_func)(void *arg);,14,50,slab_automove.h,slab_automove_free_func,,false,10,10,slab_automove_free_func,,,5,void slab_automove_free_func (void*)
80725,METHOD,slab_automove.h:<global>,TYPE_DECL,"typedef void (*slab_automove_run_func)(void *arg, int *src, int *dst);",14,69,slab_automove.h,slab_automove_run_func,,false,11,11,slab_automove_run_func,,,6,"void slab_automove_run_func (void*,int*,int*)"
80748,METHOD,slab_automove_extstore.c:<global>,TYPE_DECL,<global>,1,78,slab_automove_extstore.c,slab_automove_extstore.c:<global>,,false,1,228,<global>,,,1,
80772,METHOD,<empty>,<empty>,<empty>,1,,slab_automove_extstore.c,slab_automove:<clinit>,,false,25,,<clinit>,,,16,
80801,METHOD,slab_automove_extstore.c:<global>,TYPE_DECL,"void *slab_automove_extstore_init(struct settings *settings) {
    uint32_t window_size = settings->slab_automove_window;
    double max_age_ratio = settings->slab_automove_ratio;
    slab_automove *a = calloc(1, sizeof(slab_automove));
    if (a == NULL)
        return NULL;
    a->window_data = calloc(window_size * MAX_NUMBER_OF_SLAB_CLASSES, sizeof(struct window_data));
    a->window_size = window_size;
    a->max_age_ratio = max_age_ratio;
    a->free_ratio = settings->slab_automove_freeratio;
    a->item_size = settings->ext_item_size;
    a->settings = settings;
    a->pool_filled_once = false;
    if (a->window_data == NULL) {
        if (a->window_data)
            free(a->window_data);
        free(a);
        return NULL;
    }

    // do a dry run to fill the before structs
    fill_item_stats_automove(a->iam_before);
    fill_slab_stats_automove(a->sam_before);

    return (void *)a;
}",1,42,slab_automove_extstore.c,slab_automove_extstore_init,,false,41,66,slab_automove_extstore_init,,,4,void* slab_automove_extstore_init (settings*)
80912,METHOD,slab_automove_extstore.c:<global>,TYPE_DECL,"void slab_automove_extstore_free(void *arg) {
    slab_automove *a = (slab_automove *)arg;
    free(a->window_data);
    free(a);
}",1,1,slab_automove_extstore.c,slab_automove_extstore_free,,false,68,72,slab_automove_extstore_free,,,5,void slab_automove_extstore_free (void*)
80929,METHOD,slab_automove_extstore.c:<global>,TYPE_DECL,"static void window_sum(struct window_data *wd, struct window_data *w,
        uint32_t size) {
    for (int x = 0; x < size; x++) {
        struct window_data *d = &wd[x];
        w->age += d->age;
        w->dirty += d->dirty;
        w->evicted += d->evicted;
        w->excess_free += d->excess_free;
        w->relaxed += d->relaxed;
    }
}",1,1,slab_automove_extstore.c,window_sum,,false,74,84,window_sum,,,6,"void window_sum (window_data*,window_data*,uint32_t)"
80990,METHOD,slab_automove_extstore.c:<global>,TYPE_DECL,"static int global_pool_check(slab_automove *a) {
    bool mem_limit_reached;
    unsigned int free = a->global_pool_watermark;
    unsigned int count = global_page_pool_size(&mem_limit_reached);
    if (!mem_limit_reached)
        return 0;
    if (count < free) {
        a->pool_filled_once = true;
        return 1;
    } else {
        a->pool_filled_once = true;
    }
    return 0;
}",1,1,slab_automove_extstore.c,global_pool_check,,false,86,99,global_pool_check,,,7,int global_pool_check (slab_automove*)
81035,METHOD,slab_automove_extstore.c:<global>,TYPE_DECL,"static void memcheck(slab_automove *a) {
    unsigned int total_pages = 0;

    // FIXME: is there a cached counter for total pages alloced?
    // technically we only really need to do this once as the pages are
    // prefilled and ratio isn't a runtime change.
    for (int n = 1; n < MAX_NUMBER_OF_SLAB_CLASSES; n++) {
        slab_stats_automove *sam = &a->sam_after[n];
        total_pages += sam->total_pages;
    }
    // always update what remains in the global page pool
    total_pages += a->sam_after[0].total_pages;
    a->global_pool_watermark = total_pages * a->free_ratio;
    if (a->global_pool_watermark < 2)
        a->global_pool_watermark = 2;
    settings.ext_global_pool_min = a->global_pool_watermark;
}",1,24,slab_automove_extstore.c,memcheck,,false,110,126,memcheck,,,8,void memcheck (slab_automove*)
81111,METHOD,slab_automove_extstore.c:<global>,TYPE_DECL,"static struct window_data *get_window_data(slab_automove *a, int class) {
    int w_offset = class * a->window_size;
    return &a->window_data[w_offset + (a->window_cur % a->window_size)];
}",1,1,slab_automove_extstore.c,get_window_data,,false,128,131,get_window_data,,,9,"struct window_data get_window_data (slab_automove*,int)"
81140,METHOD,slab_automove_extstore.c:<global>,TYPE_DECL,"void slab_automove_extstore_run(void *arg, int *src, int *dst) {
    slab_automove *a = (slab_automove *)arg;
    int n;
    struct window_data w_sum;
    int oldest = -1;
    uint64_t oldest_age = 0;
    bool too_free = false;
    *src = -1;
    *dst = -1;

    int global_low = global_pool_check(a);
    // fill after structs
    fill_item_stats_automove(a->iam_after);
    fill_slab_stats_automove(a->sam_after);
    a->window_cur++;

    memcheck(a);

    // iterate slabs
    for (n = POWER_SMALLEST; n < MAX_NUMBER_OF_SLAB_CLASSES; n++) {
        bool small_slab = a->sam_before[n].chunk_size < a->item_size
            ? true : false;
        struct window_data *wd = get_window_data(a, n);
        int w_offset = n * a->window_size;
        memset(wd, 0, sizeof(struct window_data));
        unsigned int free_target = a->sam_after[n].chunks_per_page * MIN_PAGES_FREE;

        // if page delta, oom, or evicted delta, mark window dirty
        // classes marked dirty cannot donate memory...",1,13,slab_automove_extstore.c,slab_automove_extstore_run,,false,133,228,slab_automove_extstore_run,,,10,"void slab_automove_extstore_run (void*,int*,int*)"
81548,METHOD,slab_automove_extstore.h:<global>,TYPE_DECL,<global>,1,6,slab_automove_extstore.h,slab_automove_extstore.h:<global>,,false,1,8,<global>,,,1,
81550,METHOD,slab_automove_extstore.h:<global>,TYPE_DECL,void *slab_automove_extstore_init(struct settings *settings);,6,60,slab_automove_extstore.h,slab_automove_extstore_init,,false,4,4,slab_automove_extstore_init,,,1,void* slab_automove_extstore_init (settings*)
81555,METHOD,slab_automove_extstore.h:<global>,TYPE_DECL,void slab_automove_extstore_free(void *arg);,6,43,slab_automove_extstore.h,slab_automove_extstore_free,,false,5,5,slab_automove_extstore_free,,,2,void slab_automove_extstore_free (void*)
81560,METHOD,slab_automove_extstore.h:<global>,TYPE_DECL,"void slab_automove_extstore_run(void *arg, int *src, int *dst);",6,62,slab_automove_extstore.h,slab_automove_extstore_run,,false,6,6,slab_automove_extstore_run,,,3,"void slab_automove_extstore_run (void*,int*,int*)"
81600,METHOD,slabs.c:<global>,TYPE_DECL,<global>,1,4,slabs.c,slabs.c:<global>,,false,1,1342,<global>,,,1,
81651,METHOD,slabs.c:<global>,TYPE_DECL,static int grow_slab_list (const unsigned int id);,12,49,slabs.c,grow_slab_list,,false,65,65,grow_slab_list,,,22,int grow_slab_list (unsigned int)
81656,METHOD,slabs.c:<global>,TYPE_DECL,static int do_slabs_newslab(const unsigned int id);,12,50,slabs.c,do_slabs_newslab,,false,66,66,do_slabs_newslab,,,23,int do_slabs_newslab (unsigned int)
81661,METHOD,slabs.c:<global>,TYPE_DECL,static void *memory_allocate(size_t size);,13,41,slabs.c,memory_allocate,,false,67,67,memory_allocate,,,24,void* memory_allocate (size_t)
81666,METHOD,slabs.c:<global>,TYPE_DECL,"static void do_slabs_free(void *ptr, const size_t size, unsigned int id);",13,72,slabs.c,do_slabs_free,,false,68,68,do_slabs_free,,,25,"void do_slabs_free (void*,size_t,unsigned int)"
81673,METHOD,slabs.c:<global>,TYPE_DECL,static void slabs_preallocate (const unsigned int maxslabs);,13,59,slabs.c,slabs_preallocate,,false,76,76,slabs_preallocate,,,26,void slabs_preallocate (unsigned int)
81678,METHOD,slabs.c:<global>,TYPE_DECL,"unsigned int slabs_clsid(const size_t size) {
    int res = POWER_SMALLEST;

    if (size == 0 || size > settings.item_size_max)
        return 0;
    while (size > slabclass[res].size)
        if (res++ == power_largest)     /* won't fit in the biggest slab */
            return power_largest;
    return res;
}",1,14,slabs.c,slabs_clsid,,false,90,99,slabs_clsid,,,27,unsigned int slabs_clsid (size_t)
81720,METHOD,slabs.c:<global>,TYPE_DECL,"unsigned int slabs_size(const int clsid) {
    return slabclass[clsid].size;
}",1,1,slabs.c,slabs_size,,false,101,103,slabs_size,,,28,unsigned int slabs_size (int)
81731,METHOD,slabs.c:<global>,TYPE_DECL,"static void * alloc_large_chunk(const size_t limit)
{
    void *ptr = NULL;
#if defined(__linux__) && defined(MADV_HUGEPAGE)
    size_t pagesize = 0;
    FILE *fp;
    int ret;

    /* Get the size of huge pages */
    fp = fopen(""/proc/meminfo"", ""r"");
    if (fp != NULL) {
        char buf[64];

        while ((fgets(buf, sizeof(buf), fp)))
            if (!strncmp(buf, ""Hugepagesize:"", 13)) {
                ret = sscanf(buf + 13, ""%zu\n"", &pagesize);

                /* meminfo huge page size is in KiBs */
                pagesize <<= 10;
            }
        fclose(fp);
    }

    if (!pagesize) {
        fprintf(stderr, ""Failed to get supported huge page size\n"");
        return NULL;
    }

    if (settings.verbose > 1)
        fprintf(stderr, ""huge page size: %zu\n"", pagesize);

    /* This works because glibc simply uses mmap when the alignment is
     * above a certain limit. */
    ret = posix_memalign(&ptr, pagesize, limit);
    if (ret != 0) {
        fprintf(stderr, ""F...",1,1,slabs.c,alloc_large_chunk,,false,108,164,alloc_large_chunk,,,29,void* alloc_large_chunk (size_t)
81746,METHOD,slabs.c:<global>,TYPE_DECL,"unsigned int slabs_fixup(char *chunk, const int border) {
    slabclass_t *p;
    item *it = (item *)chunk;
    int id = ITEM_clsid(it);

    // memory isn't used yet. shunt to global pool.
    // (which must be 0)
    if (id == 0) {
        //assert(border == 0);
        p = &slabclass[0];
        grow_slab_list(0);
        p->slab_list[p->slabs++] = (char*)chunk;
        return -1;
    }
    p = &slabclass[id];

    // if we're on a page border, add the slab to slab class
    if (border == 0) {
        grow_slab_list(id);
        p->slab_list[p->slabs++] = chunk;
    }

    // increase free count if ITEM_SLABBED
    if (it->it_flags == ITEM_SLABBED) {
        // if ITEM_SLABBED re-stack on freelist.
        // don't have to run pointer fixups.
        it->prev = 0;
        it->next = p->slots;
        if (it->next) it->next->prev = it;
        p->slots = it;

        p->sl_curr++;
        //fprintf(stderr, ""replacing into freelist\n"");
    }

    return p->size;
}",1,13,slabs.c,slabs_fixup,,false,166,202,slabs_fixup,,,30,"unsigned int slabs_fixup (char*,int)"
81870,METHOD,slabs.c:<global>,TYPE_DECL,"void slabs_init(const size_t limit, const double factor, const bool prealloc, const uint32_t *slab_sizes, void *mem_base_external, bool reuse_mem) {
    int i = POWER_SMALLEST - 1;
    unsigned int size = sizeof(item) + settings.chunk_size;

    /* Some platforms use runtime transparent hugepages. If for any reason
     * the initial allocation fails, the required settings do not persist
     * for remaining allocations. As such it makes little sense to do slab
     * preallocation. */
    bool __attribute__ ((unused)) do_slab_prealloc = false;

    mem_limit = limit;

    if (prealloc && mem_base_external == NULL) {
        mem_base = alloc_large_chunk(mem_limit);
        if (mem_base) {
            do_slab_prealloc = true;
            mem_current = mem_base;
            mem_avail = mem_limit;
        } else {
            fprintf(stderr, ""Warning: Failed to allocate requested memory in""
                    "" one large chunk.\nWill allocate in smaller chunks\n"");
        }
    } els...",1,12,slabs.c,slabs_init,,false,208,296,slabs_init,,,31,"void slabs_init (size_t,double,bool,uint32_t*,void*,bool)"
82166,METHOD,slabs.c:<global>,TYPE_DECL,"void slabs_prefill_global(void) {
    void *ptr;
    slabclass_t *p = &slabclass[0];
    int len = settings.slab_page_size;

    while (mem_malloced < mem_limit
            && (ptr = memory_allocate(len)) != NULL) {
        grow_slab_list(0);
        // Ensure the front header is zero'd to avoid confusing restart code.
        // It's probably good enough to cast it and just zero slabs_clsid, but
        // this is extra paranoid.
        memset(ptr, 0, sizeof(item));
        p->slab_list[p->slabs++] = ptr;
    }
    mem_limit_reached = true;
}",1,1,slabs.c,slabs_prefill_global,,false,298,313,slabs_prefill_global,,,32,void slabs_prefill_global (void)
82217,METHOD,slabs.c:<global>,TYPE_DECL,"static void slabs_preallocate (const unsigned int maxslabs) {
    int i;
    unsigned int prealloc = 0;

    /* pre-allocate a 1MB slab in every size class so people don't get
       confused by non-intuitive ""SERVER_ERROR out of memory""
       messages.  this is the most common question on the mailing
       list.  if you really don't want this, you can rebuild without
       these three lines.  */

    for (i = POWER_SMALLEST; i < MAX_NUMBER_OF_SLAB_CLASSES; i++) {
        if (++prealloc > maxslabs)
            break;
        if (do_slabs_newslab(i) == 0) {
            fprintf(stderr, ""Error while preallocating slab memory!\n""
                ""If using -L or other prealloc options, max memory must be ""
                ""at least %d megabytes.\n"", power_largest);
            exit(1);
        }
    }
}",1,13,slabs.c,slabs_preallocate,,false,315,335,slabs_preallocate,,,33,void slabs_preallocate (unsigned int)
82263,METHOD,slabs.c:<global>,TYPE_DECL,"static int grow_slab_list (const unsigned int id) {
    slabclass_t *p = &slabclass[id];
    if (p->slabs == p->list_size) {
        size_t new_size =  (p->list_size != 0) ? p->list_size * 2 : 16;
        void *new_list = realloc(p->slab_list, new_size * sizeof(void *));
        if (new_list == 0) return 0;
        p->list_size = new_size;
        p->slab_list = new_list;
    }
    return 1;
}",1,1,slabs.c,grow_slab_list,,false,337,347,grow_slab_list,,,34,int grow_slab_list (unsigned int)
82329,METHOD,slabs.c:<global>,TYPE_DECL,"static void split_slab_page_into_freelist(char *ptr, const unsigned int id) {
    slabclass_t *p = &slabclass[id];
    int x;
    for (x = 0; x < p->perslab; x++) {
        do_slabs_free(ptr, 0, id);
        ptr += p->size;
    }
}",1,1,slabs.c,split_slab_page_into_freelist,,false,349,356,split_slab_page_into_freelist,,,35,"void split_slab_page_into_freelist (char*,unsigned int)"
82365,METHOD,slabs.c:<global>,TYPE_DECL,"static void *get_page_from_global_pool(void) {
    slabclass_t *p = &slabclass[SLAB_GLOBAL_PAGE_POOL];
    if (p->slabs < 1) {
        return NULL;
    }
    char *ret = p->slab_list[p->slabs - 1];
    p->slabs--;
    return ret;
}",1,32,slabs.c,get_page_from_global_pool,,false,359,367,get_page_from_global_pool,,,36,void* get_page_from_global_pool (void)
82406,METHOD,slabs.c:<global>,TYPE_DECL,"static int do_slabs_newslab(const unsigned int id) {
    slabclass_t *p = &slabclass[id];
    slabclass_t *g = &slabclass[SLAB_GLOBAL_PAGE_POOL];
    int len = (settings.slab_reassign || settings.slab_chunk_size_max != settings.slab_page_size)
        ? settings.slab_page_size
        : p->size * p->perslab;
    char *ptr;

    if ((mem_limit && mem_malloced + len > mem_limit && p->slabs > 0
         && g->slabs == 0)) {
        mem_limit_reached = true;
        MEMCACHED_SLABS_SLABCLASS_ALLOCATE_FAILED(id);
        return 0;
    }

    if ((grow_slab_list(id) == 0) ||
        (((ptr = get_page_from_global_pool()) == NULL) &&
        ((ptr = memory_allocate((size_t)len)) == 0))) {

        MEMCACHED_SLABS_SLABCLASS_ALLOCATE_FAILED(id);
        return 0;
    }

    // Always wipe the memory at this stage: in restart mode the mmap memory
    // could be unused, yet still full of data. Better for usability if we're
    // wiping memory as it's being pulled out of the global pool instea...",1,32,slabs.c,do_slabs_newslab,,false,369,403,do_slabs_newslab,,,37,int do_slabs_newslab (unsigned int)
82523,METHOD,slabs.c:<global>,TYPE_DECL,"static void *do_slabs_alloc(const size_t size, unsigned int id,
        unsigned int flags) {
    slabclass_t *p;
    void *ret = NULL;
    item *it = NULL;

    if (id < POWER_SMALLEST || id > power_largest) {
        MEMCACHED_SLABS_ALLOCATE_FAILED(size, 0);
        return NULL;
    }
    p = &slabclass[id];
    assert(p->sl_curr == 0 || (((item *)p->slots)->it_flags & ITEM_SLABBED));

    assert(size <= p->size);
    /* fail unless we have space at the end of a recently allocated page,
       we have something on our freelist, or we could allocate a new page */
    if (p->sl_curr == 0 && flags != SLABS_ALLOC_NO_NEWPAGE) {
        do_slabs_newslab(id);
    }

    if (p->sl_curr != 0) {
        /* return off our freelist */
        it = (item *)p->slots;
        p->slots = it->next;
        if (it->next) it->next->prev = 0;
        /* Kill flag and initialize refcount here for lock safety in slab
         * mover's freeness detection. */
        it->it_flags &= ~ITEM_SLABBED;
     ...",1,13,slabs.c,do_slabs_alloc,,false,406,448,do_slabs_alloc,,,38,"void* do_slabs_alloc (size_t,unsigned int,unsigned int)"
82664,METHOD,slabs.c:<global>,TYPE_DECL,"static void do_slabs_free_chunked(item *it, const size_t size) {
    item_chunk *chunk = (item_chunk *) ITEM_schunk(it);
    slabclass_t *p;

    it->it_flags = ITEM_SLABBED;
    // FIXME: refresh on how this works?
    //it->slabs_clsid = 0;
    it->prev = 0;
    // header object's original classid is stored in chunk.
    p = &slabclass[chunk->orig_clsid];
    // original class id needs to be set on free memory.
    it->slabs_clsid = chunk->orig_clsid;
    if (chunk->next) {
        chunk = chunk->next;
        chunk->prev = 0;
    } else {
        // header with no attached chunk
        chunk = NULL;
    }

    // return the header object.
    // TODO: This is in three places, here and in do_slabs_free().
    it->prev = 0;
    it->next = p->slots;
    if (it->next) it->next->prev = it;
    p->slots = it;
    p->sl_curr++;

    item_chunk *next_chunk;
    while (chunk) {
        assert(chunk->it_flags == ITEM_CHUNK);
        chunk->it_flags = ITEM_SLABBED;
        p = &slabclass[c...",1,39,slabs.c,do_slabs_free_chunked,,false,450,495,do_slabs_free_chunked,,,39,"void do_slabs_free_chunked (item*,size_t)"
82860,METHOD,slabs.c:<global>,TYPE_DECL,"static void do_slabs_free(void *ptr, const size_t size, unsigned int id) {
    slabclass_t *p;
    item *it;

    assert(id >= POWER_SMALLEST && id <= power_largest);
    if (id < POWER_SMALLEST || id > power_largest)
        return;

    MEMCACHED_SLABS_FREE(size, id, ptr);
    p = &slabclass[id];

    it = (item *)ptr;
    if ((it->it_flags & ITEM_CHUNKED) == 0) {
        it->it_flags = ITEM_SLABBED;
        it->slabs_clsid = id;
        it->prev = 0;
        it->next = p->slots;
        if (it->next) it->next->prev = it;
        p->slots = it;

        p->sl_curr++;
    } else {
        do_slabs_free_chunked(it, size);
    }
    return;
}",1,17,slabs.c,do_slabs_free,,false,498,523,do_slabs_free,,,40,"void do_slabs_free (void*,size_t,unsigned int)"
82964,METHOD,slabs.c:<global>,TYPE_DECL,"void fill_slab_stats_automove(slab_stats_automove *am) {
    int n;
    pthread_mutex_lock(&slabs_lock);
    for (n = 0; n < MAX_NUMBER_OF_SLAB_CLASSES; n++) {
        slabclass_t *p = &slabclass[n];
        slab_stats_automove *cur = &am[n];
        cur->chunks_per_page = p->perslab;
        cur->free_chunks = p->sl_curr;
        cur->total_pages = p->slabs;
        cur->chunk_size = p->size;
    }
    pthread_mutex_unlock(&slabs_lock);
}",1,20,slabs.c,fill_slab_stats_automove,,false,528,540,fill_slab_stats_automove,,,41,void fill_slab_stats_automove (slab_stats_automove*)
83033,METHOD,slabs.c:<global>,TYPE_DECL,"unsigned int global_page_pool_size(bool *mem_flag) {
    unsigned int ret = 0;
    pthread_mutex_lock(&slabs_lock);
    if (mem_flag != NULL)
        *mem_flag = mem_malloced >= mem_limit ? true : false;
    ret = slabclass[SLAB_GLOBAL_PAGE_POOL].slabs;
    pthread_mutex_unlock(&slabs_lock);
    return ret;
}",1,20,slabs.c,global_page_pool_size,,false,545,553,global_page_pool_size,,,42,unsigned int global_page_pool_size (bool*)
83073,METHOD,slabs.c:<global>,TYPE_DECL,"static void do_slabs_stats(ADD_STAT add_stats, void *c) {
    int i, total;
    /* Get the per-thread stats which contain some interesting aggregates */
    struct thread_stats thread_stats;
    threadlocal_stats_aggregate(&thread_stats);

    total = 0;
    for(i = POWER_SMALLEST; i <= power_largest; i++) {
        slabclass_t *p = &slabclass[i];
        if (p->slabs != 0) {
            uint32_t perslab, slabs;
            slabs = p->slabs;
            perslab = p->perslab;

            char key_str[STAT_KEY_LEN];
            char val_str[STAT_VAL_LEN];
            int klen = 0, vlen = 0;

            APPEND_NUM_STAT(i, ""chunk_size"", ""%u"", p->size);
            APPEND_NUM_STAT(i, ""chunks_per_page"", ""%u"", perslab);
            APPEND_NUM_STAT(i, ""total_pages"", ""%u"", slabs);
            APPEND_NUM_STAT(i, ""total_chunks"", ""%u"", slabs * perslab);
            APPEND_NUM_STAT(i, ""used_chunks"", ""%u"",
                            slabs*perslab - p->sl_curr);
            APPEND_NUM_STAT(i, ""...",1,12,slabs.c,do_slabs_stats,,false,556,608,do_slabs_stats,,,43,"void do_slabs_stats (ADD_STAT,void*)"
83619,METHOD,slabs.c:<global>,TYPE_DECL,"static void *memory_allocate(size_t size) {
    void *ret;

    if (mem_base == NULL) {
        /* We are not using a preallocated large memory chunk */
        ret = malloc(size);
    } else {
        ret = mem_current;

        if (size > mem_avail) {
            return NULL;
        }

        /* mem_current pointer _must_ be aligned!!! */
        if (size % CHUNK_ALIGN_BYTES) {
            size += CHUNK_ALIGN_BYTES - (size % CHUNK_ALIGN_BYTES);
        }

        mem_current = ((char*)mem_current) + size;
        if (size < mem_avail) {
            mem_avail -= size;
        } else {
            mem_avail = 0;
        }
    }
    mem_malloced += size;

    return ret;
}",1,19,slabs.c,memory_allocate,,false,610,638,memory_allocate,,,44,void* memory_allocate (size_t)
83689,METHOD,slabs.c:<global>,TYPE_DECL,"static void memory_release() {
    void *p = NULL;
    if (mem_base != NULL)
        return;

    if (!settings.slab_reassign)
        return;

    while (mem_malloced > mem_limit &&
            (p = get_page_from_global_pool()) != NULL) {
        free(p);
        mem_malloced -= settings.slab_page_size;
    }
}",1,1,slabs.c,memory_release,,false,641,654,memory_release,,,45,void memory_release ()
83728,METHOD,slabs.c:<global>,TYPE_DECL,"void *slabs_alloc(size_t size, unsigned int id,
        unsigned int flags) {
    void *ret;

    pthread_mutex_lock(&slabs_lock);
    ret = do_slabs_alloc(size, id, flags);
    pthread_mutex_unlock(&slabs_lock);
    return ret;
}",1,1,slabs.c,slabs_alloc,,false,656,664,slabs_alloc,,,46,"void* slabs_alloc (size_t,unsigned int,unsigned int)"
83750,METHOD,slabs.c:<global>,TYPE_DECL,"void slabs_free(void *ptr, size_t size, unsigned int id) {
    pthread_mutex_lock(&slabs_lock);
    do_slabs_free(ptr, size, id);
    pthread_mutex_unlock(&slabs_lock);
}",1,1,slabs.c,slabs_free,,false,666,670,slabs_free,,,47,"void slabs_free (void*,size_t,unsigned int)"
83767,METHOD,slabs.c:<global>,TYPE_DECL,"void slabs_stats(ADD_STAT add_stats, void *c) {
    pthread_mutex_lock(&slabs_lock);
    do_slabs_stats(add_stats, c);
    pthread_mutex_unlock(&slabs_lock);
}",1,1,slabs.c,slabs_stats,,false,672,676,slabs_stats,,,48,"void slabs_stats (ADD_STAT,void*)"
83782,METHOD,slabs.c:<global>,TYPE_DECL,"static bool do_slabs_adjust_mem_limit(size_t new_mem_limit) {
    /* Cannot adjust memory limit at runtime if prealloc'ed */
    if (mem_base != NULL)
        return false;
    settings.maxbytes = new_mem_limit;
    mem_limit = new_mem_limit;
    mem_limit_reached = false; /* Will reset on next alloc */
    memory_release(); /* free what might already be in the global pool */
    return true;
}",1,1,slabs.c,do_slabs_adjust_mem_limit,,false,678,687,do_slabs_adjust_mem_limit,,,49,bool do_slabs_adjust_mem_limit (size_t)
83808,METHOD,slabs.c:<global>,TYPE_DECL,"bool slabs_adjust_mem_limit(size_t new_mem_limit) {
    bool ret;
    pthread_mutex_lock(&slabs_lock);
    ret = do_slabs_adjust_mem_limit(new_mem_limit);
    pthread_mutex_unlock(&slabs_lock);
    return ret;
}",1,1,slabs.c,slabs_adjust_mem_limit,,false,689,695,slabs_adjust_mem_limit,,,50,bool slabs_adjust_mem_limit (size_t)
83826,METHOD,slabs.c:<global>,TYPE_DECL,"unsigned int slabs_available_chunks(const unsigned int id, bool *mem_flag,
        unsigned int *chunks_perslab) {
    unsigned int ret;
    slabclass_t *p;

    pthread_mutex_lock(&slabs_lock);
    p = &slabclass[id];
    ret = p->sl_curr;
    if (mem_flag != NULL)
        *mem_flag = mem_malloced >= mem_limit ? true : false;
    if (chunks_perslab != NULL)
        *chunks_perslab = p->perslab;
    pthread_mutex_unlock(&slabs_lock);
    return ret;
}",1,1,slabs.c,slabs_available_chunks,,false,697,711,slabs_available_chunks,,,51,"unsigned int slabs_available_chunks (unsigned int,bool*,unsigned int*)"
83879,METHOD,slabs.c:<global>,TYPE_DECL,"void slabs_mlock(void) {
    pthread_mutex_lock(&slabs_lock);
}",1,1,slabs.c,slabs_mlock,,false,719,721,slabs_mlock,,,52,void slabs_mlock (void)
83887,METHOD,slabs.c:<global>,TYPE_DECL,"void slabs_munlock(void) {
    pthread_mutex_unlock(&slabs_lock);
}",1,1,slabs.c,slabs_munlock,,false,723,725,slabs_munlock,,,53,void slabs_munlock (void)
83903,METHOD,slabs.c:<global>,TYPE_DECL,"static int slab_rebalance_start(void) {
    slabclass_t *s_cls;
    int no_go = 0;

    pthread_mutex_lock(&slabs_lock);

    if (slab_rebal.s_clsid < SLAB_GLOBAL_PAGE_POOL ||
        slab_rebal.s_clsid > power_largest  ||
        slab_rebal.d_clsid < SLAB_GLOBAL_PAGE_POOL ||
        slab_rebal.d_clsid > power_largest  ||
        slab_rebal.s_clsid == slab_rebal.d_clsid)
        no_go = -2;

    s_cls = &slabclass[slab_rebal.s_clsid];

    if (!grow_slab_list(slab_rebal.d_clsid)) {
        no_go = -1;
    }

    if (s_cls->slabs < 2)
        no_go = -3;

    if (no_go != 0) {
        pthread_mutex_unlock(&slabs_lock);
        return no_go; /* Should use a wrapper function... */
    }

    /* Always kill the first available slab page as it is most likely to
     * contain the oldest items
     */
    slab_rebal.slab_start = s_cls->slab_list[0];
    slab_rebal.slab_end   = (char *)slab_rebal.slab_start +
        (s_cls->size * s_cls->perslab);
    slab_rebal.slab_pos   = slab_rebal.sl...",1,29,slabs.c,slab_rebalance_start,,false,730,786,slab_rebalance_start,,,58,int slab_rebalance_start (void)
84086,METHOD,slabs.c:<global>,TYPE_DECL,"static void *slab_rebalance_alloc(const size_t size, unsigned int id) {
    slabclass_t *s_cls;
    s_cls = &slabclass[slab_rebal.s_clsid];
    int x;
    item *new_it = NULL;

    for (x = 0; x < s_cls->perslab; x++) {
        new_it = do_slabs_alloc(size, id, SLABS_ALLOC_NO_NEWPAGE);
        /* check that memory isn't within the range to clear */
        if (new_it == NULL) {
            break;
        }
        if ((void *)new_it >= slab_rebal.slab_start
            && (void *)new_it < slab_rebal.slab_end) {
            /* Pulled something we intend to free. Mark it as freed since
             * we've already done the work of unlinking it from the freelist.
             */
            new_it->refcount = 0;
            new_it->it_flags = ITEM_SLABBED|ITEM_FETCHED;
#ifdef DEBUG_SLAB_MOVER
            memcpy(ITEM_key(new_it), ""deadbeef"", 8);
#endif
            new_it = NULL;
            slab_rebal.inline_reclaim++;
        } else {
            break;
        }
    }
    return new_i...",1,42,slabs.c,slab_rebalance_alloc,,false,789,818,slab_rebalance_alloc,,,59,"void* slab_rebalance_alloc (size_t,unsigned int)"
84178,METHOD,slabs.c:<global>,TYPE_DECL,"static void slab_rebalance_cut_free(slabclass_t *s_cls, item *it) {
    /* Ensure this was on the freelist and nothing else. */
    assert(it->it_flags == ITEM_SLABBED);
    if (s_cls->slots == it) {
        s_cls->slots = it->next;
    }
    if (it->next) it->next->prev = it->prev;
    if (it->prev) it->prev->next = it->next;
    s_cls->sl_curr--;
}",1,27,slabs.c,slab_rebalance_cut_free,,false,822,831,slab_rebalance_cut_free,,,60,"void slab_rebalance_cut_free (slabclass_t*,item*)"
84244,METHOD,<empty>,<empty>,<empty>,1,,slabs.c,move_status:<clinit>,,false,833,,<clinit>,,,6,
84251,METHOD,slabs.c:<global>,TYPE_DECL,"static int slab_rebalance_move(void) {
    slabclass_t *s_cls;
    int was_busy = 0;
    int refcount = 0;
    uint32_t hv;
    void *hold_lock;
    enum move_status status = MOVE_PASS;

    s_cls = &slabclass[slab_rebal.s_clsid];
    // the offset to check if completed or not
    int offset = ((char*)slab_rebal.slab_pos-(char*)slab_rebal.slab_start)/(s_cls->size);

    // skip acquiring the slabs lock for items we've already fully processed.
    if (slab_rebal.completed[offset] == 0) {
        pthread_mutex_lock(&slabs_lock);
        hv = 0;
        hold_lock = NULL;
        item *it = slab_rebal.slab_pos;

        item_chunk *ch = NULL;
        status = MOVE_PASS;

        if (it->it_flags & ITEM_CHUNK) {
            /* This chunk is a chained part of a larger item. */
            ch = (item_chunk *) it;
            /* Instead, we use the head chunk to find the item and effectively
             * lock the entire structure. If a chunk has ITEM_CHUNK flag, its
             * head ca...",1,27,slabs.c,slab_rebalance_move,,false,856,1107,slab_rebalance_move,,,62,int slab_rebalance_move (void)
85117,METHOD,slabs.c:<global>,TYPE_DECL,"static void slab_rebalance_finish(void) {
    slabclass_t *s_cls;
    slabclass_t *d_cls;
    int x;
    uint32_t rescues;
    uint32_t evictions_nomem;
    uint32_t inline_reclaim;
    uint32_t chunk_rescues;
    uint32_t busy_deletes;

    pthread_mutex_lock(&slabs_lock);

    s_cls = &slabclass[slab_rebal.s_clsid];
    d_cls = &slabclass[slab_rebal.d_clsid];

#ifdef DEBUG_SLAB_MOVER
    /* If the algorithm is broken, live items can sneak in. */
    slab_rebal.slab_pos = slab_rebal.slab_start;
    while (1) {
        item *it = slab_rebal.slab_pos;
        assert(it->it_flags == (ITEM_SLABBED|ITEM_FETCHED));
        assert(memcmp(ITEM_key(it), ""deadbeef"", 8) == 0);
        it->it_flags = ITEM_SLABBED|ITEM_FETCHED;
        slab_rebal.slab_pos = (char *)slab_rebal.slab_pos + s_cls->size;
        if (slab_rebal.slab_pos >= slab_rebal.slab_end)
            break;
    }
#endif

    /* At this point the stolen slab is completely clear.
     * We always kill the ""first""/""oldest"" slab pag...",1,29,slabs.c,slab_rebalance_finish,,false,1109,1197,slab_rebalance_finish,,,63,void slab_rebalance_finish (void)
85380,METHOD,slabs.c:<global>,TYPE_DECL,"static void *slab_rebalance_thread(void *arg) {
    int was_busy = 0;
    int backoff_timer = 1;
    int backoff_max = 1000;
    /* So we first pass into cond_wait with the mutex held */
    mutex_lock(&slabs_rebalance_lock);

    /* Must finish moving page before stopping */
    while (slab_rebalance_signal || do_run_slab_rebalance_thread) {
        if (slab_rebalance_signal == 1) {
            if (slab_rebalance_start() < 0) {
                /* Handle errors with more specificity as required. */
                slab_rebalance_signal = 0;
            }

            was_busy = 0;
        } else if (slab_rebalance_signal && slab_rebal.slab_start != NULL) {
            was_busy = slab_rebalance_move();
        }

        if (slab_rebal.done) {
            slab_rebalance_finish();
        } else if (was_busy) {
            /* Stuck waiting for some items to unlock, so slow down a bit
             * to give them a chance to free up */
            usleep(backoff_timer);
            back...",1,4,slabs.c,slab_rebalance_thread,,false,1202,1242,slab_rebalance_thread,,,64,void* slab_rebalance_thread (void*)
85484,METHOD,slabs.c:<global>,TYPE_DECL,"static int slabs_reassign_pick_any(int dst) {
    static int cur = POWER_SMALLEST - 1;
    int tries = power_largest - POWER_SMALLEST + 1;
    for (; tries > 0; tries--) {
        cur++;
        if (cur > power_largest)
            cur = POWER_SMALLEST;
        if (cur == dst)
            continue;
        if (slabclass[cur].slabs > 1) {
            return cur;
        }
    }
    return -1;
}",1,21,slabs.c,slabs_reassign_pick_any,,false,1248,1262,slabs_reassign_pick_any,,,65,int slabs_reassign_pick_any (int)
85547,METHOD,slabs.c:<global>,TYPE_DECL,"static enum reassign_result_type do_slabs_reassign(int src, int dst) {
    bool nospare = false;
    if (slab_rebalance_signal != 0)
        return REASSIGN_RUNNING;

    if (src == dst)
        return REASSIGN_SRC_DST_SAME;

    /* Special indicator to choose ourselves. */
    if (src == -1) {
        src = slabs_reassign_pick_any(dst);
        /* TODO: If we end up back at -1, return a new error type */
    }

    if (src < SLAB_GLOBAL_PAGE_POOL || src > power_largest ||
        dst < SLAB_GLOBAL_PAGE_POOL || dst > power_largest)
        return REASSIGN_BADCLASS;

    pthread_mutex_lock(&slabs_lock);
    if (slabclass[src].slabs < 2)
        nospare = true;
    pthread_mutex_unlock(&slabs_lock);
    if (nospare)
        return REASSIGN_NOSPARE;

    slab_rebal.s_clsid = src;
    slab_rebal.d_clsid = dst;

    slab_rebalance_signal = 1;
    pthread_cond_signal(&slab_rebalance_cond);

    return REASSIGN_OK;
}",1,14,slabs.c,do_slabs_reassign,,false,1264,1296,do_slabs_reassign,,,66,"enum reassign_result_type do_slabs_reassign (int,int)"
85645,METHOD,slabs.c:<global>,TYPE_DECL,"enum reassign_result_type slabs_reassign(int src, int dst) {
    enum reassign_result_type ret;
    if (pthread_mutex_trylock(&slabs_rebalance_lock) != 0) {
        return REASSIGN_RUNNING;
    }
    ret = do_slabs_reassign(src, dst);
    pthread_mutex_unlock(&slabs_rebalance_lock);
    return ret;
}",1,1,slabs.c,slabs_reassign,,false,1298,1306,slabs_reassign,,,67,"enum reassign_result_type slabs_reassign (int,int)"
85671,METHOD,slabs.c:<global>,TYPE_DECL,"void slabs_rebalancer_pause(void) {
    pthread_mutex_lock(&slabs_rebalance_lock);
}",1,1,slabs.c,slabs_rebalancer_pause,,false,1309,1311,slabs_rebalancer_pause,,,68,void slabs_rebalancer_pause (void)
85679,METHOD,slabs.c:<global>,TYPE_DECL,"void slabs_rebalancer_resume(void) {
    pthread_mutex_unlock(&slabs_rebalance_lock);
}",1,1,slabs.c,slabs_rebalancer_resume,,false,1313,1315,slabs_rebalancer_resume,,,69,void slabs_rebalancer_resume (void)
85688,METHOD,slabs.c:<global>,TYPE_DECL,"int start_slab_maintenance_thread(void) {
    int ret;
    slab_rebalance_signal = 0;
    slab_rebal.slab_start = NULL;

    if ((ret = pthread_create(&rebalance_tid, NULL,
                              slab_rebalance_thread, NULL)) != 0) {
        fprintf(stderr, ""Can't create rebal thread: %s\n"", strerror(ret));
        return -1;
    }
    return 0;
}",1,1,slabs.c,start_slab_maintenance_thread,,false,1319,1330,start_slab_maintenance_thread,,,71,int start_slab_maintenance_thread (void)
85724,METHOD,slabs.c:<global>,TYPE_DECL,"void stop_slab_maintenance_thread(void) {
    mutex_lock(&slabs_rebalance_lock);
    do_run_slab_rebalance_thread = 0;
    pthread_cond_signal(&slab_rebalance_cond);
    pthread_mutex_unlock(&slabs_rebalance_lock);

    /* Wait for the maintenance thread to stop */
    pthread_join(rebalance_tid, NULL);
}",1,4,slabs.c,stop_slab_maintenance_thread,,false,1334,1342,stop_slab_maintenance_thread,,,72,void stop_slab_maintenance_thread (void)
85751,METHOD,slabs.h:<global>,TYPE_DECL,<global>,1,6,slabs.h,slabs.h:<global>,,false,1,72,<global>,,,1,
85753,METHOD,slabs.h:<global>,TYPE_DECL,"void slabs_init(const size_t limit, const double factor, const bool prealloc, const uint32_t *slab_sizes, void *mem_base_external, bool reuse_mem);",6,146,slabs.h,slabs_init,,false,11,11,slabs_init,,,1,"void slabs_init (size_t,double,bool,uint32_t*,void*,bool)"
85763,METHOD,slabs.h:<global>,TYPE_DECL,void slabs_prefill_global(void);,6,31,slabs.h,slabs_prefill_global,,false,14,14,slabs_prefill_global,,,2,void slabs_prefill_global (void)
85768,METHOD,slabs.h:<global>,TYPE_DECL,unsigned int slabs_clsid(const size_t size);,14,43,slabs.h,slabs_clsid,,false,21,21,slabs_clsid,,,3,unsigned int slabs_clsid (size_t)
85773,METHOD,slabs.h:<global>,TYPE_DECL,unsigned int slabs_size(const int clsid);,14,40,slabs.h,slabs_size,,false,22,22,slabs_size,,,4,unsigned int slabs_size (int)
85778,METHOD,slabs.h:<global>,TYPE_DECL,"void *slabs_alloc(const size_t size, unsigned int id, unsigned int flags);",6,73,slabs.h,slabs_alloc,,false,26,26,slabs_alloc,,,5,"void* slabs_alloc (size_t,unsigned int,unsigned int)"
85785,METHOD,slabs.h:<global>,TYPE_DECL,"void slabs_free(void *ptr, size_t size, unsigned int id);",6,56,slabs.h,slabs_free,,false,29,29,slabs_free,,,6,"void slabs_free (void*,size_t,unsigned int)"
85792,METHOD,slabs.h:<global>,TYPE_DECL,bool slabs_adjust_mem_limit(size_t new_mem_limit);,6,49,slabs.h,slabs_adjust_mem_limit,,false,32,32,slabs_adjust_mem_limit,,,7,bool slabs_adjust_mem_limit (size_t)
85803,METHOD,slabs.h:<global>,TYPE_DECL,void fill_slab_stats_automove(slab_stats_automove *am);,6,54,slabs.h,fill_slab_stats_automove,,false,40,40,fill_slab_stats_automove,,,10,void fill_slab_stats_automove (slab_stats_automove*)
85808,METHOD,slabs.h:<global>,TYPE_DECL,unsigned int global_page_pool_size(bool *mem_flag);,14,50,slabs.h,global_page_pool_size,,false,41,41,global_page_pool_size,,,11,unsigned int global_page_pool_size (bool*)
85813,METHOD,slabs.h:<global>,TYPE_DECL,"void slabs_stats(ADD_STAT add_stats, void *c);",6,45,slabs.h,slabs_stats,,false,44,44,slabs_stats,,,12,"void slabs_stats (ADD_STAT,void*)"
85819,METHOD,slabs.h:<global>,TYPE_DECL,"unsigned int slabs_available_chunks(unsigned int id, bool *mem_flag, unsigned int *chunks_perslab);",14,98,slabs.h,slabs_available_chunks,,false,47,47,slabs_available_chunks,,,13,"unsigned int slabs_available_chunks (unsigned int,bool*,unsigned int*)"
85826,METHOD,slabs.h:<global>,TYPE_DECL,void slabs_mlock(void);,6,22,slabs.h,slabs_mlock,,false,49,49,slabs_mlock,,,14,void slabs_mlock (void)
85831,METHOD,slabs.h:<global>,TYPE_DECL,void slabs_munlock(void);,6,24,slabs.h,slabs_munlock,,false,50,50,slabs_munlock,,,15,void slabs_munlock (void)
85836,METHOD,slabs.h:<global>,TYPE_DECL,int start_slab_maintenance_thread(void);,5,39,slabs.h,start_slab_maintenance_thread,,false,52,52,start_slab_maintenance_thread,,,16,int start_slab_maintenance_thread (void)
85841,METHOD,slabs.h:<global>,TYPE_DECL,void stop_slab_maintenance_thread(void);,6,39,slabs.h,stop_slab_maintenance_thread,,false,53,53,stop_slab_maintenance_thread,,,17,void stop_slab_maintenance_thread (void)
85852,METHOD,<empty>,<empty>,<empty>,1,,slabs.h,reassign_result_type:<clinit>,,false,55,,<clinit>,,,6,
85861,METHOD,slabs.h:<global>,TYPE_DECL,void slabs_rebalancer_pause(void);,6,33,slabs.h,slabs_rebalancer_pause,,false,62,62,slabs_rebalancer_pause,,,21,void slabs_rebalancer_pause (void)
85866,METHOD,slabs.h:<global>,TYPE_DECL,void slabs_rebalancer_resume(void);,6,34,slabs.h,slabs_rebalancer_resume,,false,63,63,slabs_rebalancer_resume,,,22,void slabs_rebalancer_resume (void)
85871,METHOD,slabs.h:<global>,TYPE_DECL,"unsigned int slabs_fixup(char *chunk, const int border);",14,55,slabs.h,slabs_fixup,,false,70,70,slabs_fixup,,,23,"unsigned int slabs_fixup (char*,int)"
85888,METHOD,solaris_priv.c:<global>,TYPE_DECL,<global>,1,19,solaris_priv.c,solaris_priv.c:<global>,,false,1,48,<global>,,,1,
85905,METHOD,stats_prefix.c:<global>,TYPE_DECL,<global>,1,49,stats_prefix.c,stats_prefix.c:<global>,,false,1,171,<global>,,,1,
85921,METHOD,stats_prefix.c:<global>,TYPE_DECL,"void stats_prefix_init(char delimiter) {
    prefix_delimiter = delimiter;
    memset(prefix_stats, 0, sizeof(prefix_stats));
}",1,1,stats_prefix.c,stats_prefix_init,,false,16,19,stats_prefix_init,,,8,void stats_prefix_init (char)
85934,METHOD,stats_prefix.c:<global>,TYPE_DECL,"void stats_prefix_clear(void) {
    int i;

    for (i = 0; i < PREFIX_HASH_SIZE; i++) {
        PREFIX_STATS *cur, *next;
        for (cur = prefix_stats[i]; cur != NULL; cur = next) {
            next = cur->next;
            free(cur->prefix);
            free(cur);
        }
        prefix_stats[i] = NULL;
    }
    num_prefixes = 0;
    total_prefix_size = 0;
}",1,20,stats_prefix.c,stats_prefix_clear,,false,21,35,stats_prefix_clear,,,9,void stats_prefix_clear (void)
85991,METHOD,stats_prefix.c:<global>,TYPE_DECL,"PREFIX_STATS *stats_prefix_find(const char *key, const size_t nkey) {
    PREFIX_STATS *pfs;
    uint32_t hashval;
    size_t length;
    bool bailout = true;

    assert(key != NULL);

    for (length = 0; length < nkey && key[length] != '\0'; length++) {
        if (key[length] == prefix_delimiter) {
            bailout = false;
            break;
        }
    }

    if (bailout) {
        return NULL;
    }

    hashval = hash(key, length) % PREFIX_HASH_SIZE;

    for (pfs = prefix_stats[hashval]; NULL != pfs; pfs = pfs->next) {
        if (strncmp(pfs->prefix, key, length) == 0)
            return pfs;
    }

    pfs = calloc(sizeof(PREFIX_STATS), 1);
    if (NULL == pfs) {
        perror(""Can't allocate space for stats structure: calloc"");
        return NULL;
    }

    pfs->prefix = malloc(length + 1);
    if (NULL == pfs->prefix) {
        perror(""Can't allocate space for copy of prefix: malloc"");
        free(pfs);
        return NULL;
    }

    strncpy(pfs->prefix, key, ...",1,34,stats_prefix.c,stats_prefix_find,,false,37,87,stats_prefix_find,,,10,"PREFIX_STATS stats_prefix_find (char*,size_t)"
86151,METHOD,stats_prefix.c:<global>,TYPE_DECL,"void stats_prefix_record_get(const char *key, const size_t nkey, const bool is_hit) {
    PREFIX_STATS *pfs;

    STATS_LOCK();
    pfs = stats_prefix_find(key, nkey);
    if (NULL != pfs) {
        pfs->num_gets++;
        if (is_hit) {
            pfs->num_hits++;
        }
    }
    STATS_UNLOCK();
}",1,1,stats_prefix.c,stats_prefix_record_get,,false,89,101,stats_prefix_record_get,,,11,"void stats_prefix_record_get (char*,size_t,bool)"
86182,METHOD,stats_prefix.c:<global>,TYPE_DECL,"void stats_prefix_record_delete(const char *key, const size_t nkey) {
    PREFIX_STATS *pfs;

    STATS_LOCK();
    pfs = stats_prefix_find(key, nkey);
    if (NULL != pfs) {
        pfs->num_deletes++;
    }
    STATS_UNLOCK();
}",1,1,stats_prefix.c,stats_prefix_record_delete,,false,103,112,stats_prefix_record_delete,,,12,"void stats_prefix_record_delete (char*,size_t)"
86205,METHOD,stats_prefix.c:<global>,TYPE_DECL,"void stats_prefix_record_set(const char *key, const size_t nkey) {
    PREFIX_STATS *pfs;

    STATS_LOCK();
    pfs = stats_prefix_find(key, nkey);
    if (NULL != pfs) {
        pfs->num_sets++;
    }
    STATS_UNLOCK();
}",1,1,stats_prefix.c,stats_prefix_record_set,,false,114,123,stats_prefix_record_set,,,13,"void stats_prefix_record_set (char*,size_t)"
86228,METHOD,stats_prefix.c:<global>,TYPE_DECL,"char *stats_prefix_dump(int *length) {
    const char *format = ""PREFIX %s get %llu hit %llu set %llu del %llu\r\n"";
    PREFIX_STATS *pfs;
    char *buf;
    int i, pos;
    size_t size = 0, written = 0;
#ifndef NDEBUG
    size_t total_written = 0;
#endif
    /*
     * Figure out how big the buffer needs to be. This is the sum of the
     * lengths of the prefixes themselves, plus the size of one copy of
     * the per-prefix output with 20-digit values for all the counts,
     * plus space for the ""END"" at the end.
     */
    STATS_LOCK();
    size = strlen(format) + total_prefix_size +
           num_prefixes * (strlen(format) - 2 /* %s */
                           + 4 * (20 - 4)) /* %llu replaced by 20-digit num */
                           + sizeof(""END\r\n"");
    buf = malloc(size);
    if (NULL == buf) {
        perror(""Can't allocate stats response: malloc"");
        STATS_UNLOCK();
        return NULL;
    }

    pos = 0;
    for (i = 0; i < PREFIX_HASH_SIZE; i++) {
    ...",1,20,stats_prefix.c,stats_prefix_dump,,false,125,171,stats_prefix_dump,,,14,char* stats_prefix_dump (int*)
86375,METHOD,stats_prefix.h:<global>,TYPE_DECL,<global>,1,6,stats_prefix.h,stats_prefix.h:<global>,,false,1,59,<global>,,,1,
86377,METHOD,stats_prefix.h:<global>,TYPE_DECL,void stats_prefix_init(char prefix_delimiter);,6,45,stats_prefix.h,stats_prefix_init,,false,17,17,stats_prefix_init,,,1,void stats_prefix_init (char)
86382,METHOD,stats_prefix.h:<global>,TYPE_DECL,void stats_prefix_clear(void);,6,29,stats_prefix.h,stats_prefix_clear,,false,22,22,stats_prefix_clear,,,2,void stats_prefix_clear (void)
86387,METHOD,stats_prefix.h:<global>,TYPE_DECL,"void stats_prefix_record_get(const char *key, const size_t nkey, const bool is_hit);",6,83,stats_prefix.h,stats_prefix_record_get,,false,25,25,stats_prefix_record_get,,,3,"void stats_prefix_record_get (char*,size_t,bool)"
86394,METHOD,stats_prefix.h:<global>,TYPE_DECL,"void stats_prefix_record_delete(const char *key, const size_t nkey);",6,67,stats_prefix.h,stats_prefix_record_delete,,false,28,28,stats_prefix_record_delete,,,4,"void stats_prefix_record_delete (char*,size_t)"
86400,METHOD,stats_prefix.h:<global>,TYPE_DECL,"void stats_prefix_record_set(const char *key, const size_t nkey);",6,64,stats_prefix.h,stats_prefix_record_set,,false,31,31,stats_prefix_record_set,,,5,"void stats_prefix_record_set (char*,size_t)"
86406,METHOD,stats_prefix.h:<global>,TYPE_DECL,char *stats_prefix_dump(int *length);,6,36,stats_prefix.h,stats_prefix_dump,,false,37,37,stats_prefix_dump,,,6,char* stats_prefix_dump (int*)
86421,METHOD,stats_prefix.h:<global>,TYPE_DECL,"PREFIX_STATS *stats_prefix_find(const char *key, const size_t nkey);",14,67,stats_prefix.h,stats_prefix_find,,false,57,57,stats_prefix_find,,,10,"PREFIX_STATS* stats_prefix_find (char*,size_t)"
86448,METHOD,storage.c:<global>,TYPE_DECL,<global>,1,78,storage.c,storage.c:<global>,,false,1,1399,<global>,,,1,
86453,METHOD,storage.h:<global>,TYPE_DECL,<global>,1,6,storage.h,storage.h:<global>,,false,1,43,<global>,,,1,
86455,METHOD,storage.h:<global>,TYPE_DECL,"void storage_delete(void *e, item *it);",6,38,storage.h,storage_delete,,false,4,4,storage_delete,,,1,"void storage_delete (void*,item*)"
86461,METHOD,storage.h:<global>,TYPE_DECL,"void storage_stats(ADD_STAT add_stats, conn *c);",6,47,storage.h,storage_stats,,false,15,15,storage_stats,,,2,"void storage_stats (ADD_STAT,conn*)"
86467,METHOD,storage.h:<global>,TYPE_DECL,"void process_extstore_stats(ADD_STAT add_stats, conn *c);",6,56,storage.h,process_extstore_stats,,false,16,16,process_extstore_stats,,,3,"void process_extstore_stats (ADD_STAT,conn*)"
86473,METHOD,storage.h:<global>,TYPE_DECL,"bool storage_validate_item(void *e, item *it);",6,45,storage.h,storage_validate_item,,false,17,17,storage_validate_item,,,4,"bool storage_validate_item (void*,item*)"
86479,METHOD,storage.h:<global>,TYPE_DECL,"int storage_get_item(conn *c, item *it, mc_resp *resp);",5,54,storage.h,storage_get_item,,false,18,18,storage_get_item,,,5,"int storage_get_item (conn*,item*,mc_resp*)"
86486,METHOD,storage.h:<global>,TYPE_DECL,void storage_submit_cb(io_queue_t *q);,6,37,storage.h,storage_submit_cb,,false,21,21,storage_submit_cb,,,6,void storage_submit_cb (io_queue_t*)
86491,METHOD,storage.h:<global>,TYPE_DECL,void storage_complete_cb(io_queue_t *q);,6,39,storage.h,storage_complete_cb,,false,22,22,storage_complete_cb,,,7,void storage_complete_cb (io_queue_t*)
86496,METHOD,storage.h:<global>,TYPE_DECL,void storage_finalize_cb(io_pending_t *pending);,6,47,storage.h,storage_finalize_cb,,false,23,23,storage_finalize_cb,,,8,void storage_finalize_cb (io_pending_t*)
86501,METHOD,storage.h:<global>,TYPE_DECL,int start_storage_write_thread(void *arg);,5,41,storage.h,start_storage_write_thread,,false,26,26,start_storage_write_thread,,,9,int start_storage_write_thread (void*)
86506,METHOD,storage.h:<global>,TYPE_DECL,void storage_write_pause(void);,6,30,storage.h,storage_write_pause,,false,27,27,storage_write_pause,,,10,void storage_write_pause (void)
86511,METHOD,storage.h:<global>,TYPE_DECL,void storage_write_resume(void);,6,31,storage.h,storage_write_resume,,false,28,28,storage_write_resume,,,11,void storage_write_resume (void)
86516,METHOD,storage.h:<global>,TYPE_DECL,int start_storage_compact_thread(void *arg);,5,43,storage.h,start_storage_compact_thread,,false,29,29,start_storage_compact_thread,,,12,int start_storage_compact_thread (void*)
86521,METHOD,storage.h:<global>,TYPE_DECL,void storage_compact_pause(void);,6,32,storage.h,storage_compact_pause,,false,30,30,storage_compact_pause,,,13,void storage_compact_pause (void)
86526,METHOD,storage.h:<global>,TYPE_DECL,void storage_compact_resume(void);,6,33,storage.h,storage_compact_resume,,false,31,31,storage_compact_resume,,,14,void storage_compact_resume (void)
86533,METHOD,storage.h:<global>,TYPE_DECL,void *storage_init_config(struct settings *s);,6,45,storage.h,storage_init_config,,false,35,35,storage_init_config,,,17,void* storage_init_config (settings*)
86538,METHOD,storage.h:<global>,TYPE_DECL,"int storage_read_config(void *conf, char **subopt);",5,50,storage.h,storage_read_config,,false,36,36,storage_read_config,,,18,"int storage_read_config (void*,char**)"
86544,METHOD,storage.h:<global>,TYPE_DECL,int storage_check_config(void *conf);,5,36,storage.h,storage_check_config,,false,37,37,storage_check_config,,,19,int storage_check_config (void*)
86549,METHOD,storage.h:<global>,TYPE_DECL,void *storage_init(void *conf);,6,30,storage.h,storage_init,,false,38,38,storage_init,,,20,void* storage_init (void*)
86609,METHOD,testapp.c:<global>,TYPE_DECL,<global>,1,20,testapp.c,testapp.c:<global>,,false,1,2360,<global>,,,1,
86619,METHOD,conn,TYPE_DECL,"ssize_t (*read)(struct conn  *c, void *buf, size_t count);",13,61,testapp.c,conn.read,,false,43,43,read,,,4,"ssize_t conn.read (conn*,void*,size_t)"
86626,METHOD,conn,TYPE_DECL,"ssize_t (*write)(struct conn *c, const void *buf, size_t count);",13,67,testapp.c,conn.write,,false,44,44,write,,,5,"ssize_t conn.write (conn*,void*,size_t)"
86634,METHOD,testapp.c:<global>,TYPE_DECL,"static ssize_t tcp_read(struct conn *c, void *buf, size_t count);",16,64,testapp.c,tcp_read,,false,49,49,tcp_read,,,4,"ssize_t tcp_read (conn*,void*,size_t)"
86641,METHOD,testapp.c:<global>,TYPE_DECL,"static ssize_t tcp_write(struct conn *c, const void *buf, size_t count);",16,71,testapp.c,tcp_write,,false,50,50,tcp_write,,,5,"ssize_t tcp_write (conn*,void*,size_t)"
86648,METHOD,testapp.c:<global>,TYPE_DECL,"ssize_t tcp_read(struct conn *c, void *buf, size_t count) {
    assert(c != NULL);
    return read(c->sock, buf, count);
}",1,1,testapp.c,tcp_read,,false,56,59,tcp_read,,,6,"ssize_t tcp_read (conn*,void*,size_t)"
86666,METHOD,testapp.c:<global>,TYPE_DECL,"ssize_t tcp_write(struct conn *c, const void *buf, size_t count) {
    assert(c != NULL);
    return write(c->sock, buf, count);
}",1,1,testapp.c,tcp_write,,false,61,64,tcp_write,,,7,"ssize_t tcp_write (conn*,void*,size_t)"
86699,METHOD,testapp.c:<global>,TYPE_DECL,"static void close_conn() {
    if (con == NULL) return;
#ifdef TLS
    if (con->ssl) {
        SSL_shutdown(con->ssl);
        SSL_free(con->ssl);
    }
    if (con->ssl_ctx)
        SSL_CTX_free(con->ssl_ctx);
#endif
    if (con->sock > 0) close(con->sock);
    free(con);
    con = NULL;
}",1,1,testapp.c,close_conn,,false,83,96,close_conn,,,17,void close_conn ()
86725,METHOD,testapp.c:<global>,TYPE_DECL,"static enum test_return cache_create_test(void)
{
    cache_t *cache = cache_create(""test"", sizeof(uint32_t), sizeof(char*));
    assert(cache != NULL);
    cache_destroy(cache);
    return TEST_PASS;
}",1,1,testapp.c,cache_create_test,,false,98,104,cache_create_test,,,18,enum test_return cache_create_test (void)
86747,METHOD,testapp.c:<global>,TYPE_DECL,"static enum test_return cache_reuse_test(void)
{
    int ii;
    cache_t *cache = cache_create(""test"", sizeof(uint32_t), sizeof(char*));
    if (cache == NULL) {
        return TEST_FAIL;
    }
    char *ptr = cache_alloc(cache);
    cache_free(cache, ptr);
    for (ii = 0; ii < 100; ++ii) {
        char *p = cache_alloc(cache);
        assert(p == ptr);
        cache_free(cache, ptr);
    }
    cache_destroy(cache);
    return TEST_PASS;
}",1,1,testapp.c,cache_reuse_test,,false,106,122,cache_reuse_test,,,19,enum test_return cache_reuse_test (void)
86804,METHOD,testapp.c:<global>,TYPE_DECL,"static enum test_return cache_bulkalloc(size_t datasize)
{
    cache_t *cache = cache_create(""test"", datasize, sizeof(char*));
    if (cache == NULL) {
        return TEST_FAIL;
    }
#define ITERATIONS 1024
    void *ptr[ITERATIONS];

    for (int ii = 0; ii < ITERATIONS; ++ii) {
        ptr[ii] = cache_alloc(cache);
        assert(ptr[ii] != 0);
        memset(ptr[ii], 0xff, datasize);
    }

    for (int ii = 0; ii < ITERATIONS; ++ii) {
        cache_free(cache, ptr[ii]);
    }

#undef ITERATIONS
    cache_destroy(cache);
    return TEST_PASS;
}",1,14,testapp.c,cache_bulkalloc,,false,125,147,cache_bulkalloc,,,20,enum test_return cache_bulkalloc (size_t)
86880,METHOD,testapp.c:<global>,TYPE_DECL,"static enum test_return test_issue_161(void)
{
    enum test_return ret = cache_bulkalloc(1);
    if (ret == TEST_PASS) {
        ret = cache_bulkalloc(512);
    }

    return ret;
}",1,1,testapp.c,test_issue_161,,false,149,157,test_issue_161,,,21,enum test_return test_issue_161 (void)
86901,METHOD,testapp.c:<global>,TYPE_DECL,"static enum test_return cache_redzone_test(void)
{
#ifndef HAVE_UMEM_H
    cache_t *cache = cache_create(""test"", sizeof(uint32_t), sizeof(char*));

    if (cache == NULL) {
        return TEST_FAIL;
    }
    /* Ignore SIGABRT */
    struct sigaction old_action;
    struct sigaction action = { .sa_handler = SIG_IGN, .sa_flags = 0};
    sigemptyset(&action.sa_mask);
    sigaction(SIGABRT, &action, &old_action);

    /* check memory debug.. */
    char *p = cache_alloc(cache);
    char old = *(p - 1);
    *(p - 1) = 0;
    cache_free(cache, p);
    assert(cache_error == -1);
    *(p - 1) = old;

    p[sizeof(uint32_t)] = 0;
    cache_free(cache, p);
    assert(cache_error == 1);

    /* restore signal handler */
    sigaction(SIGABRT, &old_action, NULL);

    cache_destroy(cache);

    return TEST_PASS;
#else
    return TEST_SKIP;
#endif
}",1,1,testapp.c,cache_redzone_test,,false,159,194,cache_redzone_test,,,22,enum test_return cache_redzone_test (void)
87000,METHOD,testapp.c:<global>,TYPE_DECL,"static enum test_return cache_limit_revised_downward_test(void)
{
    int limit = 10, allocated_num = limit + 1, i;
    char ** alloc_objs = calloc(allocated_num, sizeof(char *));

    cache_t *cache = cache_create(""test"", sizeof(uint32_t), sizeof(char*));
    assert(cache != NULL);

    /* cache->limit is 0 and we can allocate limit+1 items */
    for (i = 0; i < allocated_num; i++) {
        alloc_objs[i] = cache_alloc(cache);
        assert(alloc_objs[i] != NULL);
    }
    assert(cache->total == allocated_num);

    /* revised downward cache->limit */
    cache_set_limit(cache, limit);

    /* If we free one item, the cache->total should decreased by one*/
    cache_free(cache, alloc_objs[0]);

    assert(cache->total == allocated_num-1);
    cache_destroy(cache);

    free(alloc_objs);

    return TEST_PASS;
}",1,1,testapp.c,cache_limit_revised_downward_test,,false,196,223,cache_limit_revised_downward_test,,,23,enum test_return cache_limit_revised_downward_test (void)
87087,METHOD,testapp.c:<global>,TYPE_DECL,"static enum test_return test_stats_prefix_find(void) {
    PREFIX_STATS *pfs1, *pfs2;

    stats_prefix_clear();
    pfs1 = stats_prefix_find(""abc"", 3);
    assert(pfs1 == NULL);
    pfs1 = stats_prefix_find(""abc|"", 4);
    assert(pfs1 == NULL);

    pfs1 = stats_prefix_find(""abc:"", 4);
    assert(pfs1 != NULL);
    assert(0ULL == (pfs1->num_gets + pfs1->num_sets + pfs1->num_deletes + pfs1->num_hits));
    pfs2 = stats_prefix_find(""abc:"", 4);
    assert(pfs1 == pfs2);
    pfs2 = stats_prefix_find(""abc:d"", 5);
    assert(pfs1 == pfs2);
    pfs2 = stats_prefix_find(""xyz123:"", 6);
    assert(pfs1 != pfs2);
    pfs2 = stats_prefix_find(""ab:"", 3);
    assert(pfs1 != pfs2);
    return TEST_PASS;
}",1,1,testapp.c,test_stats_prefix_find,,false,225,246,test_stats_prefix_find,,,24,enum test_return test_stats_prefix_find (void)
87178,METHOD,testapp.c:<global>,TYPE_DECL,"static enum test_return test_stats_prefix_record_get(void) {
    PREFIX_STATS *pfs;
    stats_prefix_clear();

    stats_prefix_record_get(""abc:123"", 7, false);
    pfs = stats_prefix_find(""abc:123"", 7);
    if (pfs == NULL) {
        return TEST_FAIL;
    }
    assert(1 == pfs->num_gets);
    assert(0 == pfs->num_hits);
    stats_prefix_record_get(""abc:456"", 7, false);
    assert(2 == pfs->num_gets);
    assert(0 == pfs->num_hits);
    stats_prefix_record_get(""abc:456"", 7, true);
    assert(3 == pfs->num_gets);
    assert(1 == pfs->num_hits);
    stats_prefix_record_get(""def:"", 4, true);
    assert(3 == pfs->num_gets);
    assert(1 == pfs->num_hits);
    return TEST_PASS;
}",1,1,testapp.c,test_stats_prefix_record_get,,false,248,269,test_stats_prefix_record_get,,,25,enum test_return test_stats_prefix_record_get (void)
87263,METHOD,testapp.c:<global>,TYPE_DECL,"static enum test_return test_stats_prefix_record_delete(void) {
    PREFIX_STATS *pfs;
    stats_prefix_clear();

    stats_prefix_record_delete(""abc:123"", 7);
    pfs = stats_prefix_find(""abc:123"", 7);
    if (pfs == NULL) {
        return TEST_FAIL;
    }
    assert(0 == pfs->num_gets);
    assert(0 == pfs->num_hits);
    assert(1 == pfs->num_deletes);
    assert(0 == pfs->num_sets);
    stats_prefix_record_delete(""def:"", 4);
    assert(1 == pfs->num_deletes);
    return TEST_PASS;
}",1,1,testapp.c,test_stats_prefix_record_delete,,false,271,287,test_stats_prefix_record_delete,,,26,enum test_return test_stats_prefix_record_delete (void)
87320,METHOD,testapp.c:<global>,TYPE_DECL,"static enum test_return test_stats_prefix_record_set(void) {
    PREFIX_STATS *pfs;
    stats_prefix_clear();

    stats_prefix_record_set(""abc:123"", 7);
    pfs = stats_prefix_find(""abc:123"", 7);
    if (pfs == NULL) {
        return TEST_FAIL;
    }
    assert(0 == pfs->num_gets);
    assert(0 == pfs->num_hits);
    assert(0 == pfs->num_deletes);
    assert(1 == pfs->num_sets);
    stats_prefix_record_delete(""def:"", 4);
    assert(1 == pfs->num_sets);
    return TEST_PASS;
}",1,1,testapp.c,test_stats_prefix_record_set,,false,289,305,test_stats_prefix_record_set,,,27,enum test_return test_stats_prefix_record_set (void)
87377,METHOD,testapp.c:<global>,TYPE_DECL,"static enum test_return test_stats_prefix_dump(void) {
    int hashval = hash(""abc"", 3) % PREFIX_HASH_SIZE;
    char tmp[500];
    char *buf;
    const char *expected;
    int keynum;
    int length;

    stats_prefix_clear();

    assert(strcmp(""END\r\n"", (buf = stats_prefix_dump(&length))) == 0);
    assert(5 == length);
    stats_prefix_record_set(""abc:123"", 7);
    free(buf);
    expected = ""PREFIX abc get 0 hit 0 set 1 del 0\r\nEND\r\n"";
    assert(strcmp(expected, (buf = stats_prefix_dump(&length))) == 0);
    assert(strlen(expected) == length);
    stats_prefix_record_get(""abc:123"", 7, false);
    free(buf);
    expected = ""PREFIX abc get 1 hit 0 set 1 del 0\r\nEND\r\n"";
    assert(strcmp(expected, (buf = stats_prefix_dump(&length))) == 0);
    assert(strlen(expected) == length);
    stats_prefix_record_get(""abc:123"", 7, true);
    free(buf);
    expected = ""PREFIX abc get 2 hit 1 set 1 del 0\r\nEND\r\n"";
    assert(strcmp(expected, (buf = stats_prefix_dump(&length))) == 0);
...",1,35,testapp.c,test_stats_prefix_dump,,false,307,374,test_stats_prefix_dump,,,28,enum test_return test_stats_prefix_dump (void)
87625,METHOD,testapp.c:<global>,TYPE_DECL,"static enum test_return test_safe_strtoul(void) {
    uint32_t val;
    assert(safe_strtoul(""123"", &val));
    assert(val == 123);
    assert(safe_strtoul(""+123"", &val));
    assert(val == 123);
    assert(!safe_strtoul("""", &val));  // empty
    assert(!safe_strtoul(""123BOGUS"", &val));  // non-numeric
    assert(!safe_strtoul("" issue221"", &val));  // non-numeric
    /* Not sure what it does, but this works with ICC :/
       assert(!safe_strtoul(""92837498237498237498029383"", &val)); // out of range
    */

    // extremes:
    assert(safe_strtoul(""4294967295"", &val)); // 2**32 - 1
    assert(val == 4294967295L);
    /* This actually works on 64-bit ubuntu
       assert(!safe_strtoul(""4294967296"", &val)); // 2**32
    */
    assert(!safe_strtoul(""-1"", &val));  // negative
    return TEST_PASS;
}",1,1,testapp.c,test_safe_strtoul,,false,376,397,test_safe_strtoul,,,29,enum test_return test_safe_strtoul (void)
87684,METHOD,testapp.c:<global>,TYPE_DECL,"static enum test_return test_safe_strtoull(void) {
    uint64_t val;
    assert(safe_strtoull(""123"", &val));
    assert(val == 123);
    assert(safe_strtoull(""+123"", &val));
    assert(val == 123);
    assert(!safe_strtoull("""", &val));  // empty
    assert(!safe_strtoull(""123BOGUS"", &val));  // non-numeric
    assert(!safe_strtoull(""92837498237498237498029383"", &val)); // out of range
    assert(!safe_strtoull("" issue221"", &val));  // non-numeric

    // extremes:
    assert(safe_strtoull(""18446744073709551615"", &val)); // 2**64 - 1
    assert(val == 18446744073709551615ULL);
    assert(!safe_strtoull(""18446744073709551616"", &val)); // 2**64
    assert(!safe_strtoull(""-1"", &val));  // negative
    return TEST_PASS;
}",1,1,testapp.c,test_safe_strtoull,,false,400,417,test_safe_strtoull,,,30,enum test_return test_safe_strtoull (void)
87755,METHOD,testapp.c:<global>,TYPE_DECL,"static enum test_return test_safe_strtoll(void) {
    int64_t val;
    assert(safe_strtoll(""123"", &val));
    assert(val == 123);
    assert(safe_strtoll(""+123"", &val));
    assert(val == 123);
    assert(safe_strtoll(""-123"", &val));
    assert(val == -123);
    assert(!safe_strtoll("""", &val));  // empty
    assert(!safe_strtoll(""123BOGUS"", &val));  // non-numeric
    assert(!safe_strtoll(""92837498237498237498029383"", &val)); // out of range
    assert(!safe_strtoll("" issue221"", &val));  // non-numeric

    // extremes:
    assert(!safe_strtoll(""18446744073709551615"", &val)); // 2**64 - 1
    assert(safe_strtoll(""9223372036854775807"", &val)); // 2**63 - 1
    assert(val == 9223372036854775807LL);
    /*
      assert(safe_strtoll(""-9223372036854775808"", &val)); // -2**63
      assert(val == -9223372036854775808LL);
    */
    assert(!safe_strtoll(""-9223372036854775809"", &val)); // -2**63 - 1

    // We'll allow space to terminate the string.  And leading space.
    assert(safe_strtol...",1,1,testapp.c,test_safe_strtoll,,false,419,446,test_safe_strtoll,,,31,enum test_return test_safe_strtoll (void)
87845,METHOD,testapp.c:<global>,TYPE_DECL,"static enum test_return test_safe_strtol(void) {
    int32_t val;
    assert(safe_strtol(""123"", &val));
    assert(val == 123);
    assert(safe_strtol(""+123"", &val));
    assert(val == 123);
    assert(safe_strtol(""-123"", &val));
    assert(val == -123);
    assert(!safe_strtol("""", &val));  // empty
    assert(!safe_strtol(""123BOGUS"", &val));  // non-numeric
    assert(!safe_strtol(""92837498237498237498029383"", &val)); // out of range
    assert(!safe_strtol("" issue221"", &val));  // non-numeric

    // extremes:
    /* This actually works on 64-bit ubuntu
       assert(!safe_strtol(""2147483648"", &val)); // (expt 2.0 31.0)
    */
    assert(safe_strtol(""2147483647"", &val)); // (- (expt 2.0 31) 1)
    assert(val == 2147483647L);
    /* This actually works on 64-bit ubuntu
       assert(!safe_strtol(""-2147483649"", &val)); // (- (expt -2.0 31) 1)
    */

    // We'll allow space to terminate the string.  And leading space.
    assert(safe_strtol("" 123 foo"", &val));
    assert(val == 123...",1,1,testapp.c,test_safe_strtol,,false,448,475,test_safe_strtol,,,32,enum test_return test_safe_strtol (void)
87923,METHOD,testapp.c:<global>,TYPE_DECL,"static pid_t start_server(in_port_t *port_out, bool daemon, int timeout) {
    char environment[80];
    snprintf(environment, sizeof(environment),
             ""MEMCACHED_PORT_FILENAME=/tmp/ports.%lu"", (long)getpid());
    char *filename= environment + strlen(""MEMCACHED_PORT_FILENAME="");
    char pid_file[80];
    snprintf(pid_file, sizeof(pid_file), ""/tmp/pid.%lu"", (long)getpid());

    remove(filename);
    remove(pid_file);

#ifdef __sun
    /* I want to name the corefiles differently so that they don't
       overwrite each other
    */
    char coreadm[128];
    snprintf(coreadm, sizeof(coreadm),
             ""coreadm -p core.%%f.%%p %lu"", (unsigned long)getpid());
    system(coreadm);
#endif

    pid_t pid = fork();
    assert(pid != -1);
    if (pid == 0) {
        /* Child */
        char *argv[24];
        int arg = 0;
        char tmo[24];
        snprintf(tmo, sizeof(tmo), ""%u"", timeout);

        putenv(environment);
#ifdef __sun
        putenv(""LD_PRELOAD=watchmalloc.s...",1,1,testapp.c,start_server,,false,486,622,start_server,,,33,"pid_t start_server (in_port_t*,bool,int)"
88267,METHOD,testapp.c:<global>,TYPE_DECL,"static enum test_return test_issue_44(void) {
    in_port_t port;
    pid_t pid = start_server(&port, true, 600);
    assert(kill(pid, SIGHUP) == 0);
    sleep(1);
    assert(kill(pid, SIGTERM) == 0);

    return TEST_PASS;
}",1,1,testapp.c,test_issue_44,,false,624,632,test_issue_44,,,34,enum test_return test_issue_44 (void)
88297,METHOD,testapp.c:<global>,TYPE_DECL,"static struct addrinfo *lookuphost(const char *hostname, in_port_t port)
{
    struct addrinfo *ai = 0;
    struct addrinfo hints = { .ai_family = AF_UNSPEC,
                              .ai_protocol = IPPROTO_TCP,
                              .ai_socktype = SOCK_STREAM };
    char service[NI_MAXSERV];
    int error;

    (void)snprintf(service, NI_MAXSERV, ""%d"", port);
    if ((error = getaddrinfo(hostname, service, &hints, &ai)) != 0) {
       if (error != EAI_SYSTEM) {
          fprintf(stderr, ""getaddrinfo(): %s\n"", gai_strerror(error));
       } else {
          perror(""getaddrinfo()"");
       }
    }

    return ai;
}",1,1,testapp.c,lookuphost,,false,634,653,lookuphost,,,35,"struct addrinfo lookuphost (char*,in_port_t)"
88361,METHOD,testapp.c:<global>,TYPE_DECL,"static struct conn *connect_server(const char *hostname, in_port_t port,
                            bool nonblock, const bool ssl)
{
    struct conn *c;
    if (!(c = (struct conn *)calloc(1, sizeof(struct conn)))) {
        fprintf(stderr, ""Failed to allocate the client connection: %s\n"",
                strerror(errno));
        return NULL;
    }

    struct addrinfo *ai = lookuphost(hostname, port);
    int sock = -1;
    if (ai != NULL) {
       if ((sock = socket(ai->ai_family, ai->ai_socktype,
                          ai->ai_protocol)) != -1) {
          if (connect(sock, ai->ai_addr, ai->ai_addrlen) == -1) {
             fprintf(stderr, ""Failed to connect socket: %s\n"",
                     strerror(errno));
             close(sock);
             sock = -1;
          } else if (nonblock) {
              int flags = fcntl(sock, F_GETFL, 0);
              if (flags < 0 || fcntl(sock, F_SETFL, flags | O_NONBLOCK) < 0) {
                  fprintf(stderr, ""Failed to enable nonb...",1,1,testapp.c,connect_server,,false,655,727,connect_server,,,36,"struct conn connect_server (char*,in_port_t,bool,bool)"
88509,METHOD,testapp.c:<global>,TYPE_DECL,"static enum test_return test_vperror(void) {
    int rv = 0;
    int oldstderr = dup(STDERR_FILENO);
    assert(oldstderr >= 0);
    char tmpl[sizeof(TMP_TEMPLATE)+1];
    strncpy(tmpl, TMP_TEMPLATE, sizeof(TMP_TEMPLATE)+1);

    int newfile = mkstemp(tmpl);
    assert(newfile > 0);
    rv = dup2(newfile, STDERR_FILENO);
    assert(rv == STDERR_FILENO);
    rv = close(newfile);
    assert(rv == 0);

    errno = EIO;
    vperror(""Old McDonald had a farm.  %s"", ""EI EIO"");

    /* Restore stderr */
    rv = dup2(oldstderr, STDERR_FILENO);
    assert(rv == STDERR_FILENO);


    /* Go read the file */
    char buf[80] = { 0 };
    FILE *efile = fopen(tmpl, ""r"");
    assert(efile);
    char *prv = fgets(buf, sizeof(buf), efile);
    assert(prv);
    fclose(efile);

    unlink(tmpl);

    char expected[80] = { 0 };
    snprintf(expected, sizeof(expected),
             ""Old McDonald had a farm.  EI EIO: %s\n"", strerror(EIO));

    /*
    fprintf(stderr,
            ""\nExpected:  ``%s''""
   ...",1,21,testapp.c,test_vperror,,false,729,772,test_vperror,,,37,enum test_return test_vperror (void)
88628,METHOD,testapp.c:<global>,TYPE_DECL,"static void send_ascii_command(const char *buf) {
    off_t offset = 0;
    const char* ptr = buf;
    size_t len = strlen(buf);

    do {
        ssize_t nw = con->write((void*)con, ptr + offset, len - offset);
        if (nw == -1) {
            if (errno != EINTR) {
                fprintf(stderr, ""Failed to write: %s\n"", strerror(errno));
                abort();
            }
        } else {
            offset += nw;
        }
    } while (offset < len);
}",1,1,testapp.c,send_ascii_command,,false,774,790,send_ascii_command,,,38,void send_ascii_command (char*)
88689,METHOD,testapp.c:<global>,TYPE_DECL,"static void read_ascii_response(char *buffer, size_t size) {
    off_t offset = 0;
    bool need_more = true;
    do {
        ssize_t nr = con->read(con, buffer + offset, 1);
        if (nr == -1) {
            if (errno != EINTR) {
                fprintf(stderr, ""Failed to read: %s\n"", strerror(errno));
                abort();
            }
        } else {
            assert(nr == 1);
            if (buffer[offset] == '\n') {
                need_more = false;
                buffer[offset + 1] = '\0';
            }
            offset += nr;
            assert(offset + 1 < size);
        }
    } while (need_more);
}",1,1,testapp.c,read_ascii_response,,false,798,818,read_ascii_response,,,39,"void read_ascii_response (char*,size_t)"
88767,METHOD,testapp.c:<global>,TYPE_DECL,"static enum test_return test_issue_92(void) {
    char buffer[1024];

    close_conn();
    con = connect_server(""127.0.0.1"", port, false, enable_ssl);
    assert(con);

    send_ascii_command(""stats cachedump 1 0 0\r\n"");

    read_ascii_response(buffer, sizeof(buffer));
    assert(strncmp(buffer, ""END"", strlen(""END"")) == 0);

    send_ascii_command(""stats cachedump 200 0 0\r\n"");
    read_ascii_response(buffer, sizeof(buffer));
    assert(strncmp(buffer, ""CLIENT_ERROR"", strlen(""CLIENT_ERROR"")) == 0);

    close_conn();
    con = connect_server(""127.0.0.1"", port, false, enable_ssl);
    assert(con);
    return TEST_PASS;
}",1,1,testapp.c,test_issue_92,,false,820,840,test_issue_92,,,40,enum test_return test_issue_92 (void)
88823,METHOD,testapp.c:<global>,TYPE_DECL,"static enum test_return test_crc32c(void) {
    uint32_t crc_hw, crc_sw;

    char buffer[256];
    for (int x = 0; x < 256; x++)
        buffer[x] = x;

    /* Compare hardware to software implementation */
    crc_hw = crc32c(0, buffer, 256);
    crc_sw = crc32c_sw(0, buffer, 256);
    assert(crc_hw == 0x9c44184b);
    assert(crc_sw == 0x9c44184b);

    /* Test that passing a CRC in also works */
    crc_hw = crc32c(crc_hw, buffer, 256);
    crc_sw = crc32c_sw(crc_sw, buffer, 256);
    assert(crc_hw == 0xae10ee5a);
    assert(crc_sw == 0xae10ee5a);

    /* Test odd offsets/sizes */
    crc_hw = crc32c(crc_hw, buffer + 1, 256 - 2);
    crc_sw = crc32c_sw(crc_sw, buffer + 1, 256 - 2);
    assert(crc_hw == 0xed37b906);
    assert(crc_sw == 0xed37b906);

    return TEST_PASS;
}",1,1,testapp.c,test_crc32c,,false,842,868,test_crc32c,,,41,enum test_return test_crc32c (void)
88917,METHOD,testapp.c:<global>,TYPE_DECL,"static enum test_return test_issue_102(void) {
    char buffer[4096];
    memset(buffer, ' ', sizeof(buffer));
    buffer[sizeof(buffer) - 1] = '\0';

    close_conn();
    con = connect_server(""127.0.0.1"", port, false, enable_ssl);
    assert(con);

    send_ascii_command(buffer);
    /* verify that the server closed the connection */
    assert(con->read(con, buffer, sizeof(buffer)) == 0);

    close_conn();
    con = connect_server(""127.0.0.1"", port, false, enable_ssl);
    assert(con);

    snprintf(buffer, sizeof(buffer), ""gets "");
    size_t offset = 5;
    while (offset < 4000) {
        offset += snprintf(buffer + offset, sizeof(buffer) - offset,
                           ""%010u "", (unsigned int)offset);
    }

    send_ascii_command(buffer);
    usleep(250);

    send_ascii_command(""\r\n"");
    char rsp[80];
    read_ascii_response(rsp, sizeof(rsp));
    assert(strncmp(rsp, ""END"", strlen(""END"")) == 0);
    buffer[3]= ' ';
    send_ascii_command(buffer);
    usleep(250);
  ...",1,1,testapp.c,test_issue_102,,false,870,921,test_issue_102,,,42,enum test_return test_issue_102 (void)
89096,METHOD,testapp.c:<global>,TYPE_DECL,"static enum test_return start_memcached_server(void) {
    server_pid = start_server(&port, false, 600);
    close_conn();
    con = connect_server(""127.0.0.1"", port, false, enable_ssl);
    assert(con);
    return TEST_PASS;
}",1,1,testapp.c,start_memcached_server,,false,923,929,start_memcached_server,,,43,enum test_return start_memcached_server (void)
89120,METHOD,testapp.c:<global>,TYPE_DECL,"static enum test_return stop_memcached_server(void) {
    close_conn();
    if (server_pid != -1) {
        assert(kill(server_pid, SIGTERM) == 0);
    }

    return TEST_PASS;
}",1,1,testapp.c,stop_memcached_server,,false,931,938,stop_memcached_server,,,44,enum test_return stop_memcached_server (void)
89140,METHOD,testapp.c:<global>,TYPE_DECL,"static enum test_return shutdown_memcached_server(void) {
    char buffer[1024];

    close_conn();
    con = connect_server(""127.0.0.1"", port, false, enable_ssl);
    assert(con);

    send_ascii_command(""shutdown\r\n"");
    /* verify that the server closed the connection */
    assert(con->read(con, buffer, sizeof(buffer)) == 0);

    close_conn();

    /* We set server_pid to -1 so that we don't later call kill() */
    if (kill(server_pid, 0) == 0) {
        server_pid = -1;
    }

    return TEST_PASS;
}",1,1,testapp.c,shutdown_memcached_server,,false,940,959,shutdown_memcached_server,,,45,enum test_return shutdown_memcached_server (void)
89183,METHOD,testapp.c:<global>,TYPE_DECL,"static void safe_send(const void* buf, size_t len, bool hickup)
{
    off_t offset = 0;
    const char* ptr = buf;
#ifdef MESSAGE_DEBUG
    uint8_t val = *ptr;
    assert(val == (uint8_t)0x80);
    fprintf(stderr, ""About to send %lu bytes:"", (unsigned long)len);
    for (int ii = 0; ii < len; ++ii) {
        if (ii % 4 == 0) {
            fprintf(stderr, ""\n   "");
        }
        val = *(ptr + ii);
        fprintf(stderr, "" 0x%02x"", val);
    }
    fprintf(stderr, ""\n"");
    usleep(500);
#endif

    do {
        size_t num_bytes = len - offset;
        if (hickup) {
            if (num_bytes > 1024) {
                num_bytes = (rand() % 1023) + 1;
            }
        }
        ssize_t nw = con->write(con, ptr + offset, num_bytes);
        if (nw == -1) {
            if (errno != EINTR) {
                fprintf(stderr, ""Failed to write: %s\n"", strerror(errno));
                abort();
            }
        } else {
            if (hickup) {
                usleep(100);
      ...",1,1,testapp.c,safe_send,,false,961,1000,safe_send,,,46,"void safe_send (void*,size_t,bool)"
89263,METHOD,testapp.c:<global>,TYPE_DECL,"static bool safe_recv(void *buf, size_t len) {
    if (len == 0) {
        return true;
    }
    off_t offset = 0;
    do {
        ssize_t nr = con->read(con, ((char*)buf) + offset, len - offset);
        if (nr == -1) {
            if (errno != EINTR) {
                fprintf(stderr, ""Failed to read: %s\n"", strerror(errno));
                abort();
            }
        } else {
            if (nr == 0 && allow_closed_read) {
                return false;
            }
            assert(nr != 0);
            offset += nr;
        }
    } while (offset < len);

    return true;
}",1,1,testapp.c,safe_recv,,false,1002,1024,safe_recv,,,47,"bool safe_recv (void*,size_t)"
89338,METHOD,testapp.c:<global>,TYPE_DECL,"static bool safe_recv_packet(void *buf, size_t size) {
    protocol_binary_response_no_extras *response = buf;
    assert(size > sizeof(*response));
    if (!safe_recv(response, sizeof(*response))) {
        return false;
    }
    response->message.header.response.keylen = ntohs(response->message.header.response.keylen);
    response->message.header.response.status = ntohs(response->message.header.response.status);
    response->message.header.response.bodylen = ntohl(response->message.header.response.bodylen);

    size_t len = sizeof(*response);

    char *ptr = buf;
    ptr += len;
    if (!safe_recv(ptr, response->message.header.response.bodylen)) {
        return false;
    }

#ifdef MESSAGE_DEBUG
    usleep(500);
    ptr = buf;
    len += response->message.header.response.bodylen;
    uint8_t val = *ptr;
    assert(val == (uint8_t)0x81);
    fprintf(stderr, ""Received %lu bytes:"", (unsigned long)len);
    for (int ii = 0; ii < len; ++ii) {
        if (ii % 4 == 0) {
          ...",1,1,testapp.c,safe_recv_packet,,false,1026,1061,safe_recv_packet,,,48,"bool safe_recv_packet (void*,size_t)"
89455,METHOD,testapp.c:<global>,TYPE_DECL,"static off_t storage_command(char*buf,
                             size_t bufsz,
                             uint8_t cmd,
                             const void* key,
                             size_t keylen,
                             const void* dta,
                             size_t dtalen,
                             uint32_t flags,
                             uint32_t exp) {
    /* all of the storage commands use the same command layout */
    protocol_binary_request_set *request = (void*)buf;
    assert(bufsz > sizeof(*request) + keylen + dtalen);

    memset(request, 0, sizeof(*request));
    request->message.header.request.magic = PROTOCOL_BINARY_REQ;
    request->message.header.request.opcode = cmd;
    request->message.header.request.keylen = htons(keylen);
    request->message.header.request.extlen = 8;
    request->message.header.request.bodylen = htonl(keylen + 8 + dtalen);
    request->message.header.request.opaque = 0xdeadbeef;
    request->message.body.fla...",1,1,testapp.c,storage_command,,false,1063,1094,storage_command,,,49,"off_t storage_command (char*,size_t,uint8_t,void*,size_t,void*,size_t,uint32_t,uint32_t)"
89612,METHOD,testapp.c:<global>,TYPE_DECL,"static off_t ext_command(char* buf,
                         size_t bufsz,
                         uint8_t cmd,
                         const void* ext,
                         size_t extlen,
                         const void* key,
                         size_t keylen,
                         const void* dta,
                         size_t dtalen) {
    protocol_binary_request_no_extras *request = (void*)buf;
    assert(bufsz > sizeof(*request) + extlen + keylen + dtalen);

    memset(request, 0, sizeof(*request));
    request->message.header.request.magic = PROTOCOL_BINARY_REQ;
    request->message.header.request.opcode = cmd;
    request->message.header.request.extlen = extlen;
    request->message.header.request.keylen = htons(keylen);
    request->message.header.request.bodylen = htonl(extlen + keylen + dtalen);
    request->message.header.request.opaque = 0xdeadbeef;

    off_t ext_offset = sizeof(protocol_binary_request_no_extras);
    off_t key_offset = ext_offset + ...",1,1,testapp.c,ext_command,,false,1096,1131,ext_command,,,50,"off_t ext_command (char*,size_t,uint8_t,void*,size_t,void*,size_t,void*,size_t)"
89781,METHOD,testapp.c:<global>,TYPE_DECL,"static off_t raw_command(char* buf,
                         size_t bufsz,
                         uint8_t cmd,
                         const void* key,
                         size_t keylen,
                         const void* dta,
                         size_t dtalen) {
    /* all of the storage commands use the same command layout */
    return ext_command(buf, bufsz, cmd, NULL, 0, key, keylen, dta, dtalen);
}",1,1,testapp.c,raw_command,,false,1133,1142,raw_command,,,51,"off_t raw_command (char*,size_t,uint8_t,void*,size_t,void*,size_t)"
89803,METHOD,testapp.c:<global>,TYPE_DECL,"static off_t flush_command(char* buf, size_t bufsz, uint8_t cmd, uint32_t exptime, bool use_extra) {
    protocol_binary_request_flush *request = (void*)buf;
    assert(bufsz > sizeof(*request));

    memset(request, 0, sizeof(*request));
    request->message.header.request.magic = PROTOCOL_BINARY_REQ;
    request->message.header.request.opcode = cmd;

    off_t size = sizeof(protocol_binary_request_no_extras);
    if (use_extra) {
        request->message.header.request.extlen = 4;
        request->message.body.expiration = htonl(exptime);
        request->message.header.request.bodylen = htonl(4);
        size += 4;
    }

    request->message.header.request.opaque = 0xdeadbeef;

    return size;
}",1,1,testapp.c,flush_command,,false,1144,1163,flush_command,,,52,"off_t flush_command (char*,size_t,uint8_t,uint32_t,bool)"
89909,METHOD,testapp.c:<global>,TYPE_DECL,"static off_t touch_command(char* buf,
                           size_t bufsz,
                           uint8_t cmd,
                           const void* key,
                           size_t keylen,
                           uint32_t exptime) {
    protocol_binary_request_touch *request = (void*)buf;
    assert(bufsz > sizeof(*request));

    memset(request, 0, sizeof(*request));
    request->message.header.request.magic = PROTOCOL_BINARY_REQ;
    request->message.header.request.opcode = cmd;

    request->message.header.request.keylen = htons(keylen);
    request->message.header.request.extlen = 4;
    request->message.body.expiration = htonl(exptime);
    request->message.header.request.bodylen = htonl(keylen + 4);

    request->message.header.request.opaque = 0xdeadbeef;

    off_t key_offset = sizeof(protocol_binary_request_no_extras) + 4;

    memcpy(buf + key_offset, key, keylen);
    return sizeof(protocol_binary_request_no_extras) + 4 + keylen;
}",1,1,testapp.c,touch_command,,false,1166,1190,touch_command,,,53,"off_t touch_command (char*,size_t,uint8_t,void*,size_t,uint32_t)"
90037,METHOD,testapp.c:<global>,TYPE_DECL,"static off_t arithmetic_command(char* buf,
                                size_t bufsz,
                                uint8_t cmd,
                                const void* key,
                                size_t keylen,
                                uint64_t delta,
                                uint64_t initial,
                                uint32_t exp) {
    protocol_binary_request_incr *request = (void*)buf;
    assert(bufsz > sizeof(*request) + keylen);

    memset(request, 0, sizeof(*request));
    request->message.header.request.magic = PROTOCOL_BINARY_REQ;
    request->message.header.request.opcode = cmd;
    request->message.header.request.keylen = htons(keylen);
    request->message.header.request.extlen = 20;
    request->message.header.request.bodylen = htonl(keylen + 20);
    request->message.header.request.opaque = 0xdeadbeef;
    request->message.body.delta = htonll(delta);
    request->message.body.initial = htonll(initial);
    request->message.body....",1,1,testapp.c,arithmetic_command,,false,1192,1218,arithmetic_command,,,54,"off_t arithmetic_command (char*,size_t,uint8_t,void*,size_t,uint64_t,uint64_t,uint32_t)"
90186,METHOD,testapp.c:<global>,TYPE_DECL,"static void validate_response_header(protocol_binary_response_no_extras *response,
                                     uint8_t cmd, uint16_t status)
{
    assert(response->message.header.response.magic == PROTOCOL_BINARY_RES);
    assert(response->message.header.response.opcode == cmd);
    assert(response->message.header.response.datatype == PROTOCOL_BINARY_RAW_BYTES);
    assert(response->message.header.response.status == status);
    assert(response->message.header.response.opaque == 0xdeadbeef);

    if (status == PROTOCOL_BINARY_RESPONSE_SUCCESS) {
        switch (cmd) {
        case PROTOCOL_BINARY_CMD_ADDQ:
        case PROTOCOL_BINARY_CMD_APPENDQ:
        case PROTOCOL_BINARY_CMD_DECREMENTQ:
        case PROTOCOL_BINARY_CMD_DELETEQ:
        case PROTOCOL_BINARY_CMD_FLUSHQ:
        case PROTOCOL_BINARY_CMD_INCREMENTQ:
        case PROTOCOL_BINARY_CMD_PREPENDQ:
        case PROTOCOL_BINARY_CMD_QUITQ:
        case PROTOCOL_BINARY_CMD_REPLACEQ:
        case PROTOCOL_BINARY_CMD_...",1,1,testapp.c,validate_response_header,,false,1220,1318,validate_response_header,,,55,"void validate_response_header (protocol_binary_response_no_extras*,uint8_t,uint16_t)"
90676,METHOD,testapp.c:<global>,TYPE_DECL,"static enum test_return test_binary_noop(void) {
    union {
        protocol_binary_request_no_extras request;
        protocol_binary_response_no_extras response;
        char bytes[1024];
    } buffer;

    size_t len = raw_command(buffer.bytes, sizeof(buffer.bytes),
                             PROTOCOL_BINARY_CMD_NOOP,
                             NULL, 0, NULL, 0);

    safe_send(buffer.bytes, len, false);
    safe_recv_packet(buffer.bytes, sizeof(buffer.bytes));
    validate_response_header(&buffer.response, PROTOCOL_BINARY_CMD_NOOP,
                             PROTOCOL_BINARY_RESPONSE_SUCCESS);

    return TEST_PASS;
}",1,1,testapp.c,test_binary_noop,,false,1320,1337,test_binary_noop,,,56,enum test_return test_binary_noop (void)
90721,METHOD,testapp.c:<global>,TYPE_DECL,"static enum test_return test_binary_quit_impl(uint8_t cmd) {
    union {
        protocol_binary_request_no_extras request;
        protocol_binary_response_no_extras response;
        char bytes[1024];
    } buffer;
    size_t len = raw_command(buffer.bytes, sizeof(buffer.bytes),
                             cmd, NULL, 0, NULL, 0);

    safe_send(buffer.bytes, len, false);
    if (cmd == PROTOCOL_BINARY_CMD_QUIT) {
        safe_recv_packet(buffer.bytes, sizeof(buffer.bytes));
        validate_response_header(&buffer.response, PROTOCOL_BINARY_CMD_QUIT,
                                 PROTOCOL_BINARY_RESPONSE_SUCCESS);
    }

    /* Socket should be closed now, read should return 0 */
    assert(con->read(con, buffer.bytes, sizeof(buffer.bytes)) == 0);
    close_conn();
    con = connect_server(""127.0.0.1"", port, false, enable_ssl);
    assert(con);

    return TEST_PASS;
}",1,1,testapp.c,test_binary_quit_impl,,false,1339,1362,test_binary_quit_impl,,,57,enum test_return test_binary_quit_impl (uint8_t)
90796,METHOD,testapp.c:<global>,TYPE_DECL,"static enum test_return test_binary_quit(void) {
    return test_binary_quit_impl(PROTOCOL_BINARY_CMD_QUIT);
}",1,1,testapp.c,test_binary_quit,,false,1364,1366,test_binary_quit,,,58,enum test_return test_binary_quit (void)
90804,METHOD,testapp.c:<global>,TYPE_DECL,"static enum test_return test_binary_quitq(void) {
    return test_binary_quit_impl(PROTOCOL_BINARY_CMD_QUITQ);
}",1,1,testapp.c,test_binary_quitq,,false,1368,1370,test_binary_quitq,,,59,enum test_return test_binary_quitq (void)
90812,METHOD,testapp.c:<global>,TYPE_DECL,"static enum test_return test_binary_set_impl(const char *key, uint8_t cmd) {
    union {
        protocol_binary_request_no_extras request;
        protocol_binary_response_no_extras response;
        char bytes[1024];
    } send, receive;
    uint64_t value = 0xdeadbeefdeadcafe;
    size_t len = storage_command(send.bytes, sizeof(send.bytes), cmd,
                                 key, strlen(key), &value, sizeof(value),
                                 0, 0);

    /* Set should work over and over again */
    int ii;
    for (ii = 0; ii < 10; ++ii) {
        safe_send(send.bytes, len, false);
        if (cmd == PROTOCOL_BINARY_CMD_SET) {
            safe_recv_packet(receive.bytes, sizeof(receive.bytes));
            validate_response_header(&receive.response, cmd,
                                     PROTOCOL_BINARY_RESPONSE_SUCCESS);
        }
    }

    if (cmd == PROTOCOL_BINARY_CMD_SETQ) {
        return test_binary_noop();
    }

    send.request.message.header.request.cas = r...",1,1,testapp.c,test_binary_set_impl,,false,1372,1410,test_binary_set_impl,,,60,"enum test_return test_binary_set_impl (char*,uint8_t)"
90969,METHOD,testapp.c:<global>,TYPE_DECL,"static enum test_return test_binary_set(void) {
    return test_binary_set_impl(""test_binary_set"", PROTOCOL_BINARY_CMD_SET);
}",1,1,testapp.c,test_binary_set,,false,1412,1414,test_binary_set,,,61,enum test_return test_binary_set (void)
90978,METHOD,testapp.c:<global>,TYPE_DECL,"static enum test_return test_binary_setq(void) {
    return test_binary_set_impl(""test_binary_setq"", PROTOCOL_BINARY_CMD_SETQ);
}",1,1,testapp.c,test_binary_setq,,false,1416,1418,test_binary_setq,,,62,enum test_return test_binary_setq (void)
90987,METHOD,testapp.c:<global>,TYPE_DECL,"static enum test_return test_binary_add_impl(const char *key, uint8_t cmd) {
    uint64_t value = 0xdeadbeefdeadcafe;
    union {
        protocol_binary_request_no_extras request;
        protocol_binary_response_no_extras response;
        char bytes[1024];
    } send, receive;
    size_t len = storage_command(send.bytes, sizeof(send.bytes), cmd, key,
                                 strlen(key), &value, sizeof(value),
                                 0, 0);

    /* Add should only work the first time */
    int ii;
    for (ii = 0; ii < 10; ++ii) {
        safe_send(send.bytes, len, false);
        if (ii == 0) {
            if (cmd == PROTOCOL_BINARY_CMD_ADD) {
                safe_recv_packet(receive.bytes, sizeof(receive.bytes));
                validate_response_header(&receive.response, cmd,
                                         PROTOCOL_BINARY_RESPONSE_SUCCESS);
            }
        } else {
            safe_recv_packet(receive.bytes, sizeof(receive.bytes));
           ...",1,1,testapp.c,test_binary_add_impl,,false,1421,1450,test_binary_add_impl,,,63,"enum test_return test_binary_add_impl (char*,uint8_t)"
91082,METHOD,testapp.c:<global>,TYPE_DECL,"static enum test_return test_binary_add(void) {
    return test_binary_add_impl(""test_binary_add"", PROTOCOL_BINARY_CMD_ADD);
}",1,1,testapp.c,test_binary_add,,false,1452,1454,test_binary_add,,,64,enum test_return test_binary_add (void)
91091,METHOD,testapp.c:<global>,TYPE_DECL,"static enum test_return test_binary_addq(void) {
    return test_binary_add_impl(""test_binary_addq"", PROTOCOL_BINARY_CMD_ADDQ);
}",1,1,testapp.c,test_binary_addq,,false,1456,1458,test_binary_addq,,,65,enum test_return test_binary_addq (void)
91100,METHOD,testapp.c:<global>,TYPE_DECL,"static enum test_return test_binary_replace_impl(const char* key, uint8_t cmd) {
    uint64_t value = 0xdeadbeefdeadcafe;
    union {
        protocol_binary_request_no_extras request;
        protocol_binary_response_no_extras response;
        char bytes[1024];
    } send, receive;
    size_t len = storage_command(send.bytes, sizeof(send.bytes), cmd,
                                 key, strlen(key), &value, sizeof(value),
                                 0, 0);
    safe_send(send.bytes, len, false);
    safe_recv_packet(receive.bytes, sizeof(receive.bytes));
    validate_response_header(&receive.response, cmd,
                             PROTOCOL_BINARY_RESPONSE_KEY_ENOENT);
    len = storage_command(send.bytes, sizeof(send.bytes),
                          PROTOCOL_BINARY_CMD_ADD,
                          key, strlen(key), &value, sizeof(value), 0, 0);
    safe_send(send.bytes, len, false);
    safe_recv_packet(receive.bytes, sizeof(receive.bytes));
    validate_response_heade...",1,1,testapp.c,test_binary_replace_impl,,false,1460,1500,test_binary_replace_impl,,,66,"enum test_return test_binary_replace_impl (char*,uint8_t)"
91261,METHOD,testapp.c:<global>,TYPE_DECL,"static enum test_return test_binary_replace(void) {
    return test_binary_replace_impl(""test_binary_replace"",
                                    PROTOCOL_BINARY_CMD_REPLACE);
}",1,1,testapp.c,test_binary_replace,,false,1502,1505,test_binary_replace,,,67,enum test_return test_binary_replace (void)
91270,METHOD,testapp.c:<global>,TYPE_DECL,"static enum test_return test_binary_replaceq(void) {
    return test_binary_replace_impl(""test_binary_replaceq"",
                                    PROTOCOL_BINARY_CMD_REPLACEQ);
}",1,1,testapp.c,test_binary_replaceq,,false,1507,1510,test_binary_replaceq,,,68,enum test_return test_binary_replaceq (void)
91279,METHOD,testapp.c:<global>,TYPE_DECL,"static enum test_return test_binary_delete_impl(const char *key, uint8_t cmd) {
    union {
        protocol_binary_request_no_extras request;
        protocol_binary_response_no_extras response;
        char bytes[1024];
    } send, receive;
    size_t len = raw_command(send.bytes, sizeof(send.bytes), cmd,
                             key, strlen(key), NULL, 0);

    safe_send(send.bytes, len, false);
    safe_recv_packet(receive.bytes, sizeof(receive.bytes));
    validate_response_header(&receive.response, cmd,
                             PROTOCOL_BINARY_RESPONSE_KEY_ENOENT);
    len = storage_command(send.bytes, sizeof(send.bytes),
                          PROTOCOL_BINARY_CMD_ADD,
                          key, strlen(key), NULL, 0, 0, 0);
    safe_send(send.bytes, len, false);
    safe_recv_packet(receive.bytes, sizeof(receive.bytes));
    validate_response_header(&receive.response, PROTOCOL_BINARY_CMD_ADD,
                             PROTOCOL_BINARY_RESPONSE_SUCCESS);

    l...",1,1,testapp.c,test_binary_delete_impl,,false,1512,1549,test_binary_delete_impl,,,69,"enum test_return test_binary_delete_impl (char*,uint8_t)"
91429,METHOD,testapp.c:<global>,TYPE_DECL,"static enum test_return test_binary_delete(void) {
    return test_binary_delete_impl(""test_binary_delete"",
                                   PROTOCOL_BINARY_CMD_DELETE);
}",1,1,testapp.c,test_binary_delete,,false,1551,1554,test_binary_delete,,,70,enum test_return test_binary_delete (void)
91438,METHOD,testapp.c:<global>,TYPE_DECL,"static enum test_return test_binary_deleteq(void) {
    return test_binary_delete_impl(""test_binary_deleteq"",
                                   PROTOCOL_BINARY_CMD_DELETEQ);
}",1,1,testapp.c,test_binary_deleteq,,false,1556,1559,test_binary_deleteq,,,71,enum test_return test_binary_deleteq (void)
91447,METHOD,testapp.c:<global>,TYPE_DECL,"static enum test_return test_binary_get_impl(const char *key, uint8_t cmd) {
    union {
        protocol_binary_request_no_extras request;
        protocol_binary_response_no_extras response;
        char bytes[1024];
    } send, receive;

    uint32_t expiration = htonl(3600);
    size_t extlen = 0;
    if (cmd == PROTOCOL_BINARY_CMD_GAT || cmd == PROTOCOL_BINARY_CMD_GATK)
        extlen = sizeof(expiration);

    size_t len = ext_command(send.bytes, sizeof(send.bytes), cmd,
                             extlen ? &expiration : NULL, extlen,
                             key, strlen(key), NULL, 0);

    safe_send(send.bytes, len, false);
    safe_recv_packet(receive.bytes, sizeof(receive.bytes));
    validate_response_header(&receive.response, cmd,
                             PROTOCOL_BINARY_RESPONSE_KEY_ENOENT);

    len = storage_command(send.bytes, sizeof(send.bytes),
                          PROTOCOL_BINARY_CMD_ADD,
                          key, strlen(key), NULL, 0,
         ...",1,1,testapp.c,test_binary_get_impl,,false,1561,1614,test_binary_get_impl,,,72,"enum test_return test_binary_get_impl (char*,uint8_t)"
91646,METHOD,testapp.c:<global>,TYPE_DECL,"static enum test_return test_binary_get(void) {
    return test_binary_get_impl(""test_binary_get"", PROTOCOL_BINARY_CMD_GET);
}",1,1,testapp.c,test_binary_get,,false,1616,1618,test_binary_get,,,73,enum test_return test_binary_get (void)
91655,METHOD,testapp.c:<global>,TYPE_DECL,"static enum test_return test_binary_getk(void) {
    return test_binary_get_impl(""test_binary_getk"", PROTOCOL_BINARY_CMD_GETK);
}",1,1,testapp.c,test_binary_getk,,false,1620,1622,test_binary_getk,,,74,enum test_return test_binary_getk (void)
91664,METHOD,testapp.c:<global>,TYPE_DECL,"static enum test_return test_binary_gat(void) {
    return test_binary_get_impl(""test_binary_gat"", PROTOCOL_BINARY_CMD_GAT);
}",1,1,testapp.c,test_binary_gat,,false,1624,1626,test_binary_gat,,,75,enum test_return test_binary_gat (void)
91673,METHOD,testapp.c:<global>,TYPE_DECL,"static enum test_return test_binary_gatk(void) {
    return test_binary_get_impl(""test_binary_gatk"", PROTOCOL_BINARY_CMD_GATK);
}",1,1,testapp.c,test_binary_gatk,,false,1628,1630,test_binary_gatk,,,76,enum test_return test_binary_gatk (void)
91682,METHOD,testapp.c:<global>,TYPE_DECL,"static enum test_return test_binary_getq_impl(const char *key, uint8_t cmd) {
    const char *missing = ""test_binary_getq_missing"";
    union {
        protocol_binary_request_no_extras request;
        protocol_binary_response_no_extras response;
        char bytes[1024];
    } send, temp, receive;

    uint32_t expiration = htonl(3600);
    size_t extlen = 0;
    if (cmd == PROTOCOL_BINARY_CMD_GATQ || cmd == PROTOCOL_BINARY_CMD_GATKQ)
        extlen = sizeof(expiration);

    size_t len = storage_command(send.bytes, sizeof(send.bytes),
                                 PROTOCOL_BINARY_CMD_ADD,
                                 key, strlen(key), NULL, 0,
                                 0, 0);
    size_t len2 = ext_command(temp.bytes, sizeof(temp.bytes), cmd,
                              extlen ? &expiration : NULL, extlen,
                              missing, strlen(missing), NULL, 0);
    /* I need to change the first opaque so that I can separate the two
     * return packets *...",1,1,testapp.c,test_binary_getq_impl,,false,1632,1674,test_binary_getq_impl,,,77,"enum test_return test_binary_getq_impl (char*,uint8_t)"
91858,METHOD,testapp.c:<global>,TYPE_DECL,"static enum test_return test_binary_getq(void) {
    return test_binary_getq_impl(""test_binary_getq"", PROTOCOL_BINARY_CMD_GETQ);
}",1,1,testapp.c,test_binary_getq,,false,1676,1678,test_binary_getq,,,78,enum test_return test_binary_getq (void)
91867,METHOD,testapp.c:<global>,TYPE_DECL,"static enum test_return test_binary_getkq(void) {
    return test_binary_getq_impl(""test_binary_getkq"", PROTOCOL_BINARY_CMD_GETKQ);
}",1,1,testapp.c,test_binary_getkq,,false,1680,1682,test_binary_getkq,,,79,enum test_return test_binary_getkq (void)
91876,METHOD,testapp.c:<global>,TYPE_DECL,"static enum test_return test_binary_gatq(void) {
    return test_binary_getq_impl(""test_binary_gatq"", PROTOCOL_BINARY_CMD_GATQ);
}",1,1,testapp.c,test_binary_gatq,,false,1684,1686,test_binary_gatq,,,80,enum test_return test_binary_gatq (void)
91885,METHOD,testapp.c:<global>,TYPE_DECL,"static enum test_return test_binary_gatkq(void) {
    return test_binary_getq_impl(""test_binary_gatkq"", PROTOCOL_BINARY_CMD_GATKQ);
}",1,1,testapp.c,test_binary_gatkq,,false,1688,1690,test_binary_gatkq,,,81,enum test_return test_binary_gatkq (void)
91894,METHOD,testapp.c:<global>,TYPE_DECL,"static enum test_return test_binary_incr_impl(const char* key, uint8_t cmd) {
    union {
        protocol_binary_request_no_extras request;
        protocol_binary_response_no_extras response_header;
        protocol_binary_response_incr response;
        char bytes[1024];
    } send, receive;
    size_t len = arithmetic_command(send.bytes, sizeof(send.bytes), cmd,
                                    key, strlen(key), 1, 0, 0);

    int ii;
    for (ii = 0; ii < 10; ++ii) {
        safe_send(send.bytes, len, false);
        if (cmd == PROTOCOL_BINARY_CMD_INCREMENT) {
            safe_recv_packet(receive.bytes, sizeof(receive.bytes));
            validate_response_header(&receive.response_header, cmd,
                                     PROTOCOL_BINARY_RESPONSE_SUCCESS);
            assert(ntohll(receive.response.message.body.value) == ii);
        }
    }

    if (cmd == PROTOCOL_BINARY_CMD_INCREMENTQ) {
        test_binary_noop();
    }
    return TEST_PASS;
}",1,1,testapp.c,test_binary_incr_impl,,false,1692,1717,test_binary_incr_impl,,,82,"enum test_return test_binary_incr_impl (char*,uint8_t)"
91979,METHOD,testapp.c:<global>,TYPE_DECL,"static enum test_return test_binary_incr(void) {
    return test_binary_incr_impl(""test_binary_incr"",
                                 PROTOCOL_BINARY_CMD_INCREMENT);
}",1,1,testapp.c,test_binary_incr,,false,1719,1722,test_binary_incr,,,83,enum test_return test_binary_incr (void)
91988,METHOD,testapp.c:<global>,TYPE_DECL,"static enum test_return test_binary_incrq(void) {
    return test_binary_incr_impl(""test_binary_incrq"",
                                 PROTOCOL_BINARY_CMD_INCREMENTQ);
}",1,1,testapp.c,test_binary_incrq,,false,1724,1727,test_binary_incrq,,,84,enum test_return test_binary_incrq (void)
91997,METHOD,testapp.c:<global>,TYPE_DECL,"static enum test_return test_binary_decr_impl(const char* key, uint8_t cmd) {
    union {
        protocol_binary_request_no_extras request;
        protocol_binary_response_no_extras response_header;
        protocol_binary_response_decr response;
        char bytes[1024];
    } send, receive;
    size_t len = arithmetic_command(send.bytes, sizeof(send.bytes), cmd,
                                    key, strlen(key), 1, 9, 0);

    int ii;
    for (ii = 9; ii >= 0; --ii) {
        safe_send(send.bytes, len, false);
        if (cmd == PROTOCOL_BINARY_CMD_DECREMENT) {
            safe_recv_packet(receive.bytes, sizeof(receive.bytes));
            validate_response_header(&receive.response_header, cmd,
                                     PROTOCOL_BINARY_RESPONSE_SUCCESS);
            assert(ntohll(receive.response.message.body.value) == ii);
        }
    }

    /* decr on 0 should not wrap */
    safe_send(send.bytes, len, false);
    if (cmd == PROTOCOL_BINARY_CMD_DECREMENT) {
   ...",1,1,testapp.c,test_binary_decr_impl,,false,1729,1762,test_binary_decr_impl,,,85,"enum test_return test_binary_decr_impl (char*,uint8_t)"
92118,METHOD,testapp.c:<global>,TYPE_DECL,"static enum test_return test_binary_decr(void) {
    return test_binary_decr_impl(""test_binary_decr"",
                                 PROTOCOL_BINARY_CMD_DECREMENT);
}",1,1,testapp.c,test_binary_decr,,false,1764,1767,test_binary_decr,,,86,enum test_return test_binary_decr (void)
92127,METHOD,testapp.c:<global>,TYPE_DECL,"static enum test_return test_binary_decrq(void) {
    return test_binary_decr_impl(""test_binary_decrq"",
                                 PROTOCOL_BINARY_CMD_DECREMENTQ);
}",1,1,testapp.c,test_binary_decrq,,false,1769,1772,test_binary_decrq,,,87,enum test_return test_binary_decrq (void)
92136,METHOD,testapp.c:<global>,TYPE_DECL,"static enum test_return test_binary_version(void) {
    union {
        protocol_binary_request_no_extras request;
        protocol_binary_response_no_extras response;
        char bytes[1024];
    } buffer;

    size_t len = raw_command(buffer.bytes, sizeof(buffer.bytes),
                             PROTOCOL_BINARY_CMD_VERSION,
                             NULL, 0, NULL, 0);

    safe_send(buffer.bytes, len, false);
    safe_recv_packet(buffer.bytes, sizeof(buffer.bytes));
    validate_response_header(&buffer.response, PROTOCOL_BINARY_CMD_VERSION,
                             PROTOCOL_BINARY_RESPONSE_SUCCESS);

    return TEST_PASS;
}",1,1,testapp.c,test_binary_version,,false,1774,1791,test_binary_version,,,88,enum test_return test_binary_version (void)
92181,METHOD,testapp.c:<global>,TYPE_DECL,"static enum test_return test_binary_flush_impl(const char *key, uint8_t cmd) {
    union {
        protocol_binary_request_no_extras request;
        protocol_binary_response_no_extras response;
        char bytes[1024];
    } send, receive;

    size_t len = storage_command(send.bytes, sizeof(send.bytes),
                                 PROTOCOL_BINARY_CMD_ADD,
                                 key, strlen(key), NULL, 0, 0, 0);
    safe_send(send.bytes, len, false);
    safe_recv_packet(receive.bytes, sizeof(receive.bytes));
    validate_response_header(&receive.response, PROTOCOL_BINARY_CMD_ADD,
                             PROTOCOL_BINARY_RESPONSE_SUCCESS);

    len = flush_command(send.bytes, sizeof(send.bytes), cmd, 2, true);
    safe_send(send.bytes, len, false);
    if (cmd == PROTOCOL_BINARY_CMD_FLUSH) {
        safe_recv_packet(receive.bytes, sizeof(receive.bytes));
        validate_response_header(&receive.response, cmd,
                                 PROTOCOL_BINARY_RES...",1,1,testapp.c,test_binary_flush_impl,,false,1793,1857,test_binary_flush_impl,,,89,"enum test_return test_binary_flush_impl (char*,uint8_t)"
92459,METHOD,testapp.c:<global>,TYPE_DECL,"static enum test_return test_binary_flush(void) {
    return test_binary_flush_impl(""test_binary_flush"",
                                  PROTOCOL_BINARY_CMD_FLUSH);
}",1,1,testapp.c,test_binary_flush,,false,1859,1862,test_binary_flush,,,90,enum test_return test_binary_flush (void)
92468,METHOD,testapp.c:<global>,TYPE_DECL,"static enum test_return test_binary_flushq(void) {
    return test_binary_flush_impl(""test_binary_flushq"",
                                  PROTOCOL_BINARY_CMD_FLUSHQ);
}",1,1,testapp.c,test_binary_flushq,,false,1864,1867,test_binary_flushq,,,91,enum test_return test_binary_flushq (void)
92477,METHOD,testapp.c:<global>,TYPE_DECL,"static enum test_return test_binary_concat_impl(const char *key, uint8_t cmd) {
    union {
        protocol_binary_request_no_extras request;
        protocol_binary_response_no_extras response;
        char bytes[1024];
    } send, receive;
    const char *value = ""world"";

    size_t len = raw_command(send.bytes, sizeof(send.bytes), cmd,
                              key, strlen(key), value, strlen(value));


    safe_send(send.bytes, len, false);
    safe_recv_packet(receive.bytes, sizeof(receive.bytes));
    validate_response_header(&receive.response, cmd,
                             PROTOCOL_BINARY_RESPONSE_NOT_STORED);

    len = storage_command(send.bytes, sizeof(send.bytes),
                          PROTOCOL_BINARY_CMD_ADD,
                          key, strlen(key), value, strlen(value), 0, 0);
    safe_send(send.bytes, len, false);
    safe_recv_packet(receive.bytes, sizeof(receive.bytes));
    validate_response_header(&receive.response, PROTOCOL_BINARY_CMD_ADD,
       ...",1,1,testapp.c,test_binary_concat_impl,,false,1869,1933,test_binary_concat_impl,,,92,"enum test_return test_binary_concat_impl (char*,uint8_t)"
92776,METHOD,testapp.c:<global>,TYPE_DECL,"static enum test_return test_binary_append(void) {
    return test_binary_concat_impl(""test_binary_append"",
                                   PROTOCOL_BINARY_CMD_APPEND);
}",1,1,testapp.c,test_binary_append,,false,1935,1938,test_binary_append,,,93,enum test_return test_binary_append (void)
92785,METHOD,testapp.c:<global>,TYPE_DECL,"static enum test_return test_binary_prepend(void) {
    return test_binary_concat_impl(""test_binary_prepend"",
                                   PROTOCOL_BINARY_CMD_PREPEND);
}",1,1,testapp.c,test_binary_prepend,,false,1940,1943,test_binary_prepend,,,94,enum test_return test_binary_prepend (void)
92794,METHOD,testapp.c:<global>,TYPE_DECL,"static enum test_return test_binary_appendq(void) {
    return test_binary_concat_impl(""test_binary_appendq"",
                                   PROTOCOL_BINARY_CMD_APPENDQ);
}",1,1,testapp.c,test_binary_appendq,,false,1945,1948,test_binary_appendq,,,95,enum test_return test_binary_appendq (void)
92803,METHOD,testapp.c:<global>,TYPE_DECL,"static enum test_return test_binary_prependq(void) {
    return test_binary_concat_impl(""test_binary_prependq"",
                                   PROTOCOL_BINARY_CMD_PREPENDQ);
}",1,1,testapp.c,test_binary_prependq,,false,1950,1953,test_binary_prependq,,,96,enum test_return test_binary_prependq (void)
92812,METHOD,testapp.c:<global>,TYPE_DECL,"static enum test_return test_binary_stat(void) {
    union {
        protocol_binary_request_no_extras request;
        protocol_binary_response_no_extras response;
        char bytes[1024];
    } buffer;

    size_t len = raw_command(buffer.bytes, sizeof(buffer.bytes),
                             PROTOCOL_BINARY_CMD_STAT,
                             NULL, 0, NULL, 0);

    safe_send(buffer.bytes, len, false);
    do {
        safe_recv_packet(buffer.bytes, sizeof(buffer.bytes));
        validate_response_header(&buffer.response, PROTOCOL_BINARY_CMD_STAT,
                                 PROTOCOL_BINARY_RESPONSE_SUCCESS);
    } while (buffer.response.message.header.response.keylen != 0);

    return TEST_PASS;
}",1,1,testapp.c,test_binary_stat,,false,1955,1974,test_binary_stat,,,97,enum test_return test_binary_stat (void)
92872,METHOD,testapp.c:<global>,TYPE_DECL,"static enum test_return test_binary_illegal(void) {
    uint8_t cmd = 0x25;
    while (cmd != 0x00) {
        union {
            protocol_binary_request_no_extras request;
            protocol_binary_response_no_extras response;
            char bytes[1024];
        } buffer;
        size_t len = raw_command(buffer.bytes, sizeof(buffer.bytes),
                                 cmd, NULL, 0, NULL, 0);
        safe_send(buffer.bytes, len, false);
        safe_recv_packet(buffer.bytes, sizeof(buffer.bytes));
        validate_response_header(&buffer.response, cmd,
                                 PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND);
        ++cmd;
    }

    return TEST_PASS;
}",1,1,testapp.c,test_binary_illegal,,false,1976,1994,test_binary_illegal,,,98,enum test_return test_binary_illegal (void)
92929,METHOD,testapp.c:<global>,TYPE_DECL,"static void *binary_hickup_recv_verification_thread(void *arg) {
    protocol_binary_response_no_extras *response = malloc(65*1024);
    if (response != NULL) {
        while (safe_recv_packet(response, 65*1024)) {
            /* Just validate the packet format */
            validate_response_header(response,
                                     response->message.header.response.opcode,
                                     response->message.header.response.status);
        }
        free(response);
    }
    hickup_thread_running = false;
    allow_closed_read = false;
    return NULL;
}",1,1,testapp.c,binary_hickup_recv_verification_thread,,false,1998,2012,binary_hickup_recv_verification_thread,,,100,void* binary_hickup_recv_verification_thread (void*)
92983,METHOD,testapp.c:<global>,TYPE_DECL,"static enum test_return test_binary_pipeline_hickup_chunk(void *buffer, size_t buffersize) {
    off_t offset = 0;
    char *key[256] = { NULL };
    uint64_t value = 0xfeedfacedeadbeef;

    while (hickup_thread_running &&
           offset + sizeof(protocol_binary_request_no_extras) < buffersize) {
        union {
            protocol_binary_request_no_extras request;
            char bytes[65 * 1024];
        } command;
        uint8_t cmd = (uint8_t)(rand() & 0xff);
        size_t len;
        size_t keylen = (rand() % 250) + 1;

        switch (cmd) {
        case PROTOCOL_BINARY_CMD_ADD:
        case PROTOCOL_BINARY_CMD_ADDQ:
        case PROTOCOL_BINARY_CMD_REPLACE:
        case PROTOCOL_BINARY_CMD_REPLACEQ:
        case PROTOCOL_BINARY_CMD_SET:
        case PROTOCOL_BINARY_CMD_SETQ:
            len = storage_command(command.bytes, sizeof(command.bytes), cmd,
                                  key, keylen , &value, sizeof(value),
                                  0, 0);
      ...",1,1,testapp.c,test_binary_pipeline_hickup_chunk,,false,2014,2120,test_binary_pipeline_hickup_chunk,,,101,"enum test_return test_binary_pipeline_hickup_chunk (void*,size_t)"
93316,METHOD,testapp.c:<global>,TYPE_DECL,"static enum test_return test_binary_pipeline_hickup(void)
{
    size_t buffersize = 65 * 1024;
    void *buffer = malloc(buffersize);
    int ii;

    pthread_t tid;
    int ret;
    allow_closed_read = true;
    hickup_thread_running = true;
    if ((ret = pthread_create(&tid, NULL,
                              binary_hickup_recv_verification_thread, NULL)) != 0) {
        fprintf(stderr, ""Can't create thread: %s\n"", strerror(ret));
        free(buffer);
        return TEST_FAIL;
    }

    /* Allow the thread to start */
    usleep(250);

    srand((int)time(NULL));
    for (ii = 0; ii < 2; ++ii) {
        test_binary_pipeline_hickup_chunk(buffer, buffersize);
    }

    /* send quitq to shut down the read thread ;-) */
    size_t len = raw_command(buffer, buffersize, PROTOCOL_BINARY_CMD_QUITQ,
                             NULL, 0, NULL, 0);
    safe_send(buffer, len, false);

    pthread_join(tid, NULL);
    free(buffer);
    return TEST_PASS;
}",1,1,testapp.c,test_binary_pipeline_hickup,,false,2122,2155,test_binary_pipeline_hickup,,,102,enum test_return test_binary_pipeline_hickup (void)
93405,METHOD,testapp.c:<global>,TYPE_DECL,"static enum test_return test_issue_101(void) {
    enum { max = 2 };
    enum test_return ret = TEST_PASS;
    struct conn *conns[max];
    int ii = 0;
    pid_t child = 0;

    if (getenv(""SKIP_TEST_101"") != NULL) {
        return TEST_SKIP;
    }

    const char *command = ""stats\r\nstats\r\nstats\r\nstats\r\nstats\r\n"";
    size_t cmdlen = strlen(command);

    server_pid = start_server(&port, false, 1000);

    for (ii = 0; ii < max; ++ii) {
        conns[ii] = NULL;
        conns[ii] = connect_server(""127.0.0.1"", port, true, enable_ssl);
        assert(conns[ii]);
        assert(conns[ii]->sock > 0);
    }

    /* Send command on the connection until it blocks */
    for (ii = 0; ii < max; ++ii) {
        bool more = true;
        do {
            ssize_t err = conns[ii]->write(conns[ii], command, cmdlen);
            if (err == -1) {
                switch (errno) {
                case EINTR:
                    break;
                case ENOMEM:
                case EWOULDB...",1,1,testapp.c,test_issue_101,,false,2158,2240,test_issue_101,,,103,enum test_return test_issue_101 (void)
93835,METHOD,testapp.c:<global>,TYPE_DECL,void STATS_LOCK(void);,6,21,testapp.c,STATS_LOCK,,false,2310,2310,STATS_LOCK,,,110,void STATS_LOCK (void)
93840,METHOD,testapp.c:<global>,TYPE_DECL,void STATS_UNLOCK(void);,6,23,testapp.c,STATS_UNLOCK,,false,2311,2311,STATS_UNLOCK,,,111,void STATS_UNLOCK (void)
93845,METHOD,testapp.c:<global>,TYPE_DECL,"void STATS_LOCK(void)
{}",1,2,testapp.c,STATS_LOCK,,false,2312,2313,STATS_LOCK,,,112,void STATS_LOCK (void)
93850,METHOD,testapp.c:<global>,TYPE_DECL,"void STATS_UNLOCK(void)
{}",1,2,testapp.c,STATS_UNLOCK,,false,2314,2315,STATS_UNLOCK,,,113,void STATS_UNLOCK (void)
93855,METHOD,testapp.c:<global>,TYPE_DECL,"int main(int argc, char **argv)
{
    int exitcode = 0;
    int ii = 0, num_cases = 0;
#ifdef TLS
    if (getenv(""SSL_TEST"") != NULL) {
        SSLeay_add_ssl_algorithms();
        SSL_load_error_strings();
        enable_ssl = true;
    }
#endif
    /* Initialized directly instead of using hash_init to avoid pulling in
       the definition of settings struct from memcached.h */
    hash = jenkins_hash;
    stats_prefix_init(':');

    crc32c_init();

    for (num_cases = 0; testcases[num_cases].description; num_cases++) {
        /* Just counting */
    }

    printf(""1..%d\n"", num_cases);

    for (ii = 0; testcases[ii].description != NULL; ++ii) {
        fflush(stdout);
#ifndef DEBUG
        /* the test program shouldn't run longer than 10 minutes... */
        alarm(600);
#endif
        enum test_return ret = testcases[ii].function();
        if (ret == TEST_SKIP) {
            fprintf(stdout, ""ok # SKIP %d - %s\n"", ii + 1, testcases[ii].description);
        } else if (ret ==...",1,1,testapp.c,main,,false,2317,2360,main,,,114,"int main (int,char**)"
94006,METHOD,thread.c:<global>,TYPE_DECL,<global>,1,4,thread.c,thread.c:<global>,,false,1,1096,<global>,,,1,
94076,METHOD,thread.c:<global>,TYPE_DECL,"static void notify_worker(LIBEVENT_THREAD *t, CQ_ITEM *item);",13,60,thread.c,notify_worker,,false,106,106,notify_worker,,,25,"void notify_worker (LIBEVENT_THREAD*,CQ_ITEM*)"
94082,METHOD,thread.c:<global>,TYPE_DECL,"static void notify_worker_fd(LIBEVENT_THREAD *t, int sfd, enum conn_queue_item_modes mode);",13,90,thread.c,notify_worker_fd,,false,107,107,notify_worker_fd,,,26,"void notify_worker_fd (LIBEVENT_THREAD*,int,conn_queue_item_modes)"
94089,METHOD,thread.c:<global>,TYPE_DECL,static CQ_ITEM *cqi_new(CQ *cq);,16,31,thread.c,cqi_new,,false,108,108,cqi_new,,,27,CQ_ITEM* cqi_new (CQ*)
94094,METHOD,thread.c:<global>,TYPE_DECL,"static void cq_push(CQ *cq, CQ_ITEM *item);",13,42,thread.c,cq_push,,false,109,109,cq_push,,,28,"void cq_push (CQ*,CQ_ITEM*)"
94100,METHOD,thread.c:<global>,TYPE_DECL,"static void thread_libevent_process(evutil_socket_t fd, short which, void *arg);",13,79,thread.c,thread_libevent_process,,false,111,111,thread_libevent_process,,,29,"void thread_libevent_process (evutil_socket_t,short,void*)"
94107,METHOD,thread.c:<global>,TYPE_DECL,"void item_lock(uint32_t hv) {
    mutex_lock(&item_locks[hv & hashmask(item_lock_hashpower)]);
}",1,4,thread.c,item_lock,,false,121,123,item_lock,,,30,void item_lock (uint32_t)
94127,METHOD,thread.c:<global>,TYPE_DECL,"void *item_trylock(uint32_t hv) {
    pthread_mutex_t *lock = &item_locks[hv & hashmask(item_lock_hashpower)];
    if (pthread_mutex_trylock(lock) == 0) {
        return lock;
    }
    return NULL;
}",1,45,thread.c,item_trylock,,false,125,131,item_trylock,,,31,void* item_trylock (uint32_t)
94160,METHOD,thread.c:<global>,TYPE_DECL,"void item_trylock_unlock(void *lock) {
    mutex_unlock((pthread_mutex_t *) lock);
}",1,4,thread.c,item_trylock_unlock,,false,133,135,item_trylock_unlock,,,32,void item_trylock_unlock (void*)
94171,METHOD,thread.c:<global>,TYPE_DECL,"void item_unlock(uint32_t hv) {
    mutex_unlock(&item_locks[hv & hashmask(item_lock_hashpower)]);
}",1,4,thread.c,item_unlock,,false,137,139,item_unlock,,,33,void item_unlock (uint32_t)
94191,METHOD,thread.c:<global>,TYPE_DECL,"static void wait_for_thread_registration(int nthreads) {
    while (init_count < nthreads) {
        pthread_cond_wait(&init_cond, &init_lock);
    }
}",1,1,thread.c,wait_for_thread_registration,,false,141,145,wait_for_thread_registration,,,34,void wait_for_thread_registration (int)
94206,METHOD,thread.c:<global>,TYPE_DECL,"static void register_thread_initialized(void) {
    pthread_mutex_lock(&init_lock);
    init_count++;
    pthread_cond_signal(&init_cond);
    pthread_mutex_unlock(&init_lock);
    /* Force worker threads to pile up if someone wants us to */
    pthread_mutex_lock(&worker_hang_lock);
    pthread_mutex_unlock(&worker_hang_lock);
}",1,1,thread.c,register_thread_initialized,,false,147,155,register_thread_initialized,,,35,void register_thread_initialized (void)
94228,METHOD,thread.c:<global>,TYPE_DECL,"void pause_threads(enum pause_thread_types type) {
    int i;
    bool pause_workers = false;

    switch (type) {
        case PAUSE_ALL_THREADS:
            slabs_rebalancer_pause();
            lru_maintainer_pause();
            lru_crawler_pause();
#ifdef EXTSTORE
            storage_compact_pause();
            storage_write_pause();
#endif
        case PAUSE_WORKER_THREADS:
            pause_workers = true;
            pthread_mutex_lock(&worker_hang_lock);
            break;
        case RESUME_ALL_THREADS:
            slabs_rebalancer_resume();
            lru_maintainer_resume();
            lru_crawler_resume();
#ifdef EXTSTORE
            storage_compact_resume();
            storage_write_resume();
#endif
        case RESUME_WORKER_THREADS:
            pthread_mutex_unlock(&worker_hang_lock);
            break;
        default:
            fprintf(stderr, ""Unknown lock type: %d\n"", type);
            assert(1 == 0);
            break;
    }

    /* Only send a message i...",1,1,thread.c,pause_threads,,false,158,204,pause_threads,,,36,void pause_threads (pause_thread_types)
94314,METHOD,thread.c:<global>,TYPE_DECL,"void stop_threads(void) {
    int i;

    // assoc can call pause_threads(), so we have to stop it first.
    stop_assoc_maintenance_thread();
    if (settings.verbose > 0)
        fprintf(stderr, ""stopped assoc\n"");

    if (settings.verbose > 0)
        fprintf(stderr, ""asking workers to stop\n"");

    pthread_mutex_lock(&worker_hang_lock);
    pthread_mutex_lock(&init_lock);
    init_count = 0;
    for (i = 0; i < settings.num_threads; i++) {
        notify_worker_fd(&threads[i], 0, queue_stop);
    }
    wait_for_thread_registration(settings.num_threads);
    pthread_mutex_unlock(&init_lock);

    // All of the workers are hung but haven't done cleanup yet.

    if (settings.verbose > 0)
        fprintf(stderr, ""asking background threads to stop\n"");

    // stop each side thread.
    // TODO: Verify these all work if the threads are already stopped
    stop_item_crawler_thread(CRAWLER_WAIT);
    if (settings.verbose > 0)
        fprintf(stderr, ""stopped lru crawler\n"");
    if ...",1,29,thread.c,stop_threads,,false,210,272,stop_threads,,,37,void stop_threads (void)
94509,METHOD,thread.c:<global>,TYPE_DECL,"static void cq_init(CQ *cq) {
    pthread_mutex_init(&cq->lock, NULL);
    STAILQ_INIT(&cq->head);
    cq->cache = cache_create(""cq"", sizeof(CQ_ITEM), sizeof(char *));
    if (cq->cache == NULL) {
        fprintf(stderr, ""Failed to create connection queue cache\n"");
        exit(EXIT_FAILURE);
    }
}",1,4,thread.c,cq_init,,false,277,285,cq_init,,,38,void cq_init (CQ*)
94573,METHOD,thread.c:<global>,TYPE_DECL,"static CQ_ITEM *cq_pop(CQ *cq) {
    CQ_ITEM *item;

    pthread_mutex_lock(&cq->lock);
    item = STAILQ_FIRST(&cq->head);
    if (item != NULL) {
        STAILQ_REMOVE_HEAD(&cq->head, i_next);
    }
    pthread_mutex_unlock(&cq->lock);

    return item;
}",1,11,thread.c,cq_pop,,false,292,303,cq_pop,,,39,CQ_ITEM cq_pop (CQ*)
94654,METHOD,thread.c:<global>,TYPE_DECL,"static void cq_push(CQ *cq, CQ_ITEM *item) {
    pthread_mutex_lock(&cq->lock);
    STAILQ_INSERT_TAIL(&cq->head, item, i_next);
    pthread_mutex_unlock(&cq->lock);
}",1,4,thread.c,cq_push,,false,308,312,cq_push,,,40,"void cq_push (CQ*,CQ_ITEM*)"
94709,METHOD,thread.c:<global>,TYPE_DECL,"static CQ_ITEM *cqi_new(CQ *cq) {
    CQ_ITEM *item = cache_alloc(cq->cache);
    if (item == NULL) {
        STATS_LOCK();
        stats.malloc_fails++;
        STATS_UNLOCK();
    }
    return item;
}",1,1,thread.c,cqi_new,,false,317,325,cqi_new,,,41,CQ_ITEM cqi_new (CQ*)
94734,METHOD,thread.c:<global>,TYPE_DECL,"static void cqi_free(CQ *cq, CQ_ITEM *item) {
    cache_free(cq->cache, item);
}",1,1,thread.c,cqi_free,,false,330,332,cqi_free,,,42,"void cqi_free (CQ*,CQ_ITEM*)"
94745,METHOD,thread.c:<global>,TYPE_DECL,"static void notify_worker(LIBEVENT_THREAD *t, CQ_ITEM *item) {
    cq_push(t->ev_queue, item);
#ifdef HAVE_EVENTFD
    uint64_t u = 1;
    if (write(t->notify_event_fd, &u, sizeof(uint64_t)) != sizeof(uint64_t)) {
        perror(""failed writing to worker eventfd"");
        /* TODO: This is a fatal problem. Can it ever happen temporarily? */
    }
#else
    char buf[1] = ""c"";
    if (write(t->notify_send_fd, buf, 1) != 1) {
        perror(""Failed writing to notify pipe"");
        /* TODO: This is a fatal problem. Can it ever happen temporarily? */
    }
#endif
}",1,1,thread.c,notify_worker,,false,340,355,notify_worker,,,43,"void notify_worker (LIBEVENT_THREAD*,CQ_ITEM*)"
94772,METHOD,thread.c:<global>,TYPE_DECL,"static void notify_worker_fd(LIBEVENT_THREAD *t, int sfd, enum conn_queue_item_modes mode) {
    CQ_ITEM *item;
    while ( (item = cqi_new(t->ev_queue)) == NULL ) {
        // NOTE: most callers of this function cannot fail, but mallocs in
        // theory can fail. Small mallocs essentially never do without also
        // killing the process. Syscalls can also fail but the original code
        // never handled this either.
        // As a compromise, I'm leaving this note and this loop: This alloc
        // cannot fail, but pre-allocating the data is too much code in an
        // area I want to keep more lean. If this CQ business becomes a more
        // generic queue I'll reconsider.
    }

    item->mode = mode;
    item->sfd = sfd;
    notify_worker(t, item);
}",1,1,thread.c,notify_worker_fd,,false,358,374,notify_worker_fd,,,44,"void notify_worker_fd (LIBEVENT_THREAD*,int,conn_queue_item_modes)"
94803,METHOD,thread.c:<global>,TYPE_DECL,"static void create_worker(void *(*func)(void *), void *arg) {
    pthread_attr_t  attr;
    int             ret;

    pthread_attr_init(&attr);

    if ((ret = pthread_create(&((LIBEVENT_THREAD*)arg)->thread_id, &attr, func, arg)) != 0) {
        fprintf(stderr, ""Can't create thread: %s\n"",
                strerror(ret));
        exit(1);
    }
}",1,1,thread.c,create_worker,,false,379,390,create_worker,,,45,"void create_worker (void*,void*)"
94838,METHOD,thread.c:<global>,TYPE_DECL,"void accept_new_conns(const bool do_accept) {
    pthread_mutex_lock(&conn_lock);
    do_accept_new_conns(do_accept);
    pthread_mutex_unlock(&conn_lock);
}",1,1,thread.c,accept_new_conns,,false,395,399,accept_new_conns,,,46,void accept_new_conns (bool)
94851,METHOD,thread.c:<global>,TYPE_DECL,"static void setup_thread(LIBEVENT_THREAD *me) {
#if defined(LIBEVENT_VERSION_NUMBER) && LIBEVENT_VERSION_NUMBER >= 0x02000101
    struct event_config *ev_config;
    ev_config = event_config_new();
    event_config_set_flag(ev_config, EVENT_BASE_FLAG_NOLOCK);
    me->base = event_base_new_with_config(ev_config);
    event_config_free(ev_config);
#else
    me->base = event_init();
#endif

    if (! me->base) {
        fprintf(stderr, ""Can't allocate event base\n"");
        exit(1);
    }

    /* Listen for notifications from other threads */
#ifdef HAVE_EVENTFD
    event_set(&me->notify_event, me->notify_event_fd,
              EV_READ | EV_PERSIST, thread_libevent_process, me);
#else
    event_set(&me->notify_event, me->notify_receive_fd,
              EV_READ | EV_PERSIST, thread_libevent_process, me);
#endif
    event_base_set(me->base, &me->notify_event);

    if (event_add(&me->notify_event, 0) == -1) {
        fprintf(stderr, ""Can't monitor libevent notify pipe\n"");
        exi...",1,42,thread.c,setup_thread,,false,405,497,setup_thread,,,47,void setup_thread (LIBEVENT_THREAD*)
95041,METHOD,thread.c:<global>,TYPE_DECL,"static void *worker_libevent(void *arg) {
    LIBEVENT_THREAD *me = arg;

    /* Any per-thread setup can happen here; memcached_thread_init() will block until
     * all threads have finished initializing.
     */
    me->l = logger_create();
    me->lru_bump_buf = item_lru_bump_buf_create();
    if (me->l == NULL || me->lru_bump_buf == NULL) {
        abort();
    }

    if (settings.drop_privileges) {
        drop_worker_privileges();
    }

    register_thread_initialized();

    event_base_loop(me->base, 0);

    // same mechanism used to watch for all threads exiting.
    register_thread_initialized();

    event_base_free(me->base);
    return NULL;
}",1,8,thread.c,worker_libevent,,false,502,527,worker_libevent,,,48,void* worker_libevent (void*)
95092,METHOD,thread.c:<global>,TYPE_DECL,"static void thread_libevent_process(evutil_socket_t fd, short which, void *arg) {
    LIBEVENT_THREAD *me = arg;
    CQ_ITEM *item;
    conn *c;
    uint64_t ev_count = 0; // max number of events to loop through this run.
#ifdef HAVE_EVENTFD
    // NOTE: unlike pipe we aren't limiting the number of events per read.
    // However we do limit the number of queue pulls to what the count was at
    // the time of this function firing.
    if (read(fd, &ev_count, sizeof(uint64_t)) != sizeof(uint64_t)) {
        if (settings.verbose > 0)
            fprintf(stderr, ""Can't read from libevent pipe\n"");
        return;
    }
#else
    char buf[MAX_PIPE_EVENTS];

    ev_count = read(fd, buf, MAX_PIPE_EVENTS);
    if (ev_count == 0) {
        if (settings.verbose > 0)
            fprintf(stderr, ""Can't read from libevent pipe\n"");
        return;
    }
#endif

    for (int x = 0; x < ev_count; x++) {
        item = cq_pop(me->ev_queue);
        if (item == NULL) {
            return;
        ...",1,13,thread.c,thread_libevent_process,,false,537,630,thread_libevent_process,,,49,"void thread_libevent_process (evutil_socket_t,short,void*)"
95288,METHOD,thread.c:<global>,TYPE_DECL,"LIBEVENT_THREAD *get_worker_thread(int id) {
    return &threads[id];
}",1,1,thread.c,get_worker_thread,,false,634,636,get_worker_thread,,,50,LIBEVENT_THREAD get_worker_thread (int)
95308,METHOD,thread.c:<global>,TYPE_DECL,"static LIBEVENT_THREAD *select_thread_round_robin(void)
{
    int tid = (last_thread + 1) % settings.num_threads;

    last_thread = tid;

    return threads + tid;
}",1,1,thread.c,select_thread_round_robin,,false,644,651,select_thread_round_robin,,,55,LIBEVENT_THREAD select_thread_round_robin (void)
95330,METHOD,thread.c:<global>,TYPE_DECL,"static void reset_threads_napi_id(void)
{
    LIBEVENT_THREAD *thread;
    int i;

    for (i = 0; i < settings.num_threads; i++) {
         thread = threads + i;
         thread->napi_id = 0;
    }

    last_thread_by_napi_id = -1;
}",1,1,thread.c,reset_threads_napi_id,,false,653,664,reset_threads_napi_id,,,56,void reset_threads_napi_id (void)
95364,METHOD,thread.c:<global>,TYPE_DECL,"static LIBEVENT_THREAD *select_thread_by_napi_id(int sfd)
{
    LIBEVENT_THREAD *thread;
    int napi_id, err, i;
    socklen_t len;
    int tid = -1;

    len = sizeof(socklen_t);
    err = getsockopt(sfd, SOL_SOCKET, SO_INCOMING_NAPI_ID, &napi_id, &len);
    if ((err == -1) || (napi_id == 0)) {
        STATS_LOCK();
        stats.round_robin_fallback++;
        STATS_UNLOCK();
        return select_thread_round_robin();
    }

select:
    for (i = 0; i < settings.num_threads; i++) {
         thread = threads + i;
         if (last_thread_by_napi_id < i) {
             thread->napi_id = napi_id;
             last_thread_by_napi_id = i;
             tid = i;
             break;
         }
         if (thread->napi_id == napi_id) {
             tid = i;
             break;
         }
    }

    if (tid == -1) {
        STATS_LOCK();
        stats.unexpected_napi_ids++;
        STATS_UNLOCK();
        reset_threads_napi_id();
        goto select;
    }

    return threads + tid;
}",1,38,thread.c,select_thread_by_napi_id,,false,670,710,select_thread_by_napi_id,,,57,LIBEVENT_THREAD select_thread_by_napi_id (int)
95478,METHOD,thread.c:<global>,TYPE_DECL,"void dispatch_conn_new(int sfd, enum conn_states init_state, int event_flags,
                       int read_buffer_size, enum network_transport transport, void *ssl,
                       uint64_t conntag, enum protocol bproto) {
    CQ_ITEM *item = NULL;
    LIBEVENT_THREAD *thread;

    if (!settings.num_napi_ids)
        thread = select_thread_round_robin();
    else
        thread = select_thread_by_napi_id(sfd);

    item = cqi_new(thread->ev_queue);
    if (item == NULL) {
        close(sfd);
        /* given that malloc failed this may also fail, but let's try */
        fprintf(stderr, ""Failed to allocate memory for connection object\n"");
        return;
    }

    item->sfd = sfd;
    item->init_state = init_state;
    item->event_flags = event_flags;
    item->read_buffer_size = read_buffer_size;
    item->transport = transport;
    item->mode = queue_new_conn;
    item->ssl = ssl;
    item->conntag = conntag;
    item->bproto = bproto;

    MEMCACHED_CONN_DISPATCH(sfd,...",1,4,thread.c,dispatch_conn_new,,false,717,748,dispatch_conn_new,,,58,"void dispatch_conn_new (int,conn_states,int,int,network_transport,void*,uint64_t,protocol)"
95575,METHOD,thread.c:<global>,TYPE_DECL,"void redispatch_conn(conn *c) {
    notify_worker_fd(c->thread, c->sfd, queue_redispatch);
}",1,1,thread.c,redispatch_conn,,false,754,756,redispatch_conn,,,59,void redispatch_conn (conn*)
95588,METHOD,thread.c:<global>,TYPE_DECL,"void timeout_conn(conn *c) {
    notify_worker_fd(c->thread, c->sfd, queue_timeout);
}",1,1,thread.c,timeout_conn,,false,758,760,timeout_conn,,,60,void timeout_conn (conn*)
95601,METHOD,thread.c:<global>,TYPE_DECL,"void return_io_pending(io_pending_t *io) {
    CQ_ITEM *item = cqi_new(io->thread->ev_queue);
    if (item == NULL) {
        // TODO: how can we avoid this?
        // In the main case I just loop, since a malloc failure here for a
        // tiny object that's generally in a fixed size queue is going to
        // implode shortly.
        return;
    }

    item->mode = queue_return_io;
    item->io = io;

    notify_worker(io->thread, item);
}",1,1,thread.c,return_io_pending,,false,767,781,return_io_pending,,,61,void return_io_pending (io_pending_t*)
95636,METHOD,thread.c:<global>,TYPE_DECL,"void sidethread_conn_close(conn *c) {
    if (settings.verbose > 1)
        fprintf(stderr, ""<%d connection closing from side thread.\n"", c->sfd);

    c->state = conn_closing;
    // redispatch will see closing flag and properly close connection.
    redispatch_conn(c);
    return;
}",1,1,thread.c,sidethread_conn_close,,false,784,792,sidethread_conn_close,,,62,void sidethread_conn_close (conn*)
95662,METHOD,thread.c:<global>,TYPE_DECL,"item *item_alloc(char *key, size_t nkey, int flags, rel_time_t exptime, int nbytes) {
    item *it;
    /* do_item_alloc handles its own locks */
    it = do_item_alloc(key, nkey, flags, exptime, nbytes);
    return it;
}",1,1,thread.c,item_alloc,,false,799,804,item_alloc,,,63,"item item_alloc (char*,size_t,int,rel_time_t,int)"
95682,METHOD,thread.c:<global>,TYPE_DECL,"item *item_get(const char *key, const size_t nkey, conn *c, const bool do_update) {
    item *it;
    uint32_t hv;
    hv = hash(key, nkey);
    item_lock(hv);
    it = do_item_get(key, nkey, hv, c, do_update);
    item_unlock(hv);
    return it;
}",1,1,thread.c,item_get,,false,810,818,item_get,,,64,"item item_get (char*,size_t,conn*,bool)"
95711,METHOD,thread.c:<global>,TYPE_DECL,"item *item_get_locked(const char *key, const size_t nkey, conn *c, const bool do_update, uint32_t *hv) {
    item *it;
    *hv = hash(key, nkey);
    item_lock(*hv);
    it = do_item_get(key, nkey, *hv, c, do_update);
    return it;
}",1,1,thread.c,item_get_locked,,false,823,829,item_get_locked,,,65,"item item_get_locked (char*,size_t,conn*,bool,uint32_t*)"
95741,METHOD,thread.c:<global>,TYPE_DECL,"item *item_touch(const char *key, size_t nkey, uint32_t exptime, conn *c) {
    item *it;
    uint32_t hv;
    hv = hash(key, nkey);
    item_lock(hv);
    it = do_item_touch(key, nkey, exptime, hv, c);
    item_unlock(hv);
    return it;
}",1,1,thread.c,item_touch,,false,831,839,item_touch,,,66,"item item_touch (char*,size_t,uint32_t,conn*)"
95770,METHOD,thread.c:<global>,TYPE_DECL,"int item_link(item *item) {
    int ret;
    uint32_t hv;

    hv = hash(ITEM_key(item), item->nkey);
    item_lock(hv);
    ret = do_item_link(item, hv);
    item_unlock(hv);
    return ret;
}",1,14,thread.c,item_link,,false,844,853,item_link,,,67,int item_link (item*)
95813,METHOD,thread.c:<global>,TYPE_DECL,"void item_remove(item *item) {
    uint32_t hv;
    hv = hash(ITEM_key(item), item->nkey);

    item_lock(hv);
    do_item_remove(item);
    item_unlock(hv);
}",1,14,thread.c,item_remove,,false,859,866,item_remove,,,68,void item_remove (item*)
95850,METHOD,thread.c:<global>,TYPE_DECL,"int item_replace(item *old_it, item *new_it, const uint32_t hv) {
    return do_item_replace(old_it, new_it, hv);
}",1,1,thread.c,item_replace,,false,873,875,item_replace,,,69,"int item_replace (item*,item*,uint32_t)"
95862,METHOD,thread.c:<global>,TYPE_DECL,"void item_unlink(item *item) {
    uint32_t hv;
    hv = hash(ITEM_key(item), item->nkey);
    item_lock(hv);
    do_item_unlink(item, hv);
    item_unlock(hv);
}",1,14,thread.c,item_unlink,,false,880,886,item_unlink,,,70,void item_unlink (item*)
95900,METHOD,thread.c:<global>,TYPE_DECL,"enum delta_result_type add_delta(conn *c, const char *key,
                                 const size_t nkey, bool incr,
                                 const int64_t delta, char *buf,
                                 uint64_t *cas) {
    enum delta_result_type ret;
    uint32_t hv;

    hv = hash(key, nkey);
    item_lock(hv);
    ret = do_add_delta(c, key, nkey, incr, delta, buf, cas, hv, NULL);
    item_unlock(hv);
    return ret;
}",1,1,thread.c,add_delta,,false,891,903,add_delta,,,71,"enum delta_result_type add_delta (conn*,char*,size_t,bool,int64_t,char*,uint64_t*)"
95936,METHOD,thread.c:<global>,TYPE_DECL,"enum store_item_type store_item(item *item, int comm, conn* c) {
    enum store_item_type ret;
    uint32_t hv;

    hv = hash(ITEM_key(item), item->nkey);
    item_lock(hv);
    ret = do_store_item(item, comm, c, hv);
    item_unlock(hv);
    return ret;
}",1,14,thread.c,store_item,,false,908,917,store_item,,,72,"enum store_item_type store_item (item*,int,conn*)"
95983,METHOD,thread.c:<global>,TYPE_DECL,"void STATS_LOCK() {
    pthread_mutex_lock(&stats_lock);
}",1,1,thread.c,STATS_LOCK,,false,921,923,STATS_LOCK,,,73,void STATS_LOCK ()
95990,METHOD,thread.c:<global>,TYPE_DECL,"void STATS_UNLOCK() {
    pthread_mutex_unlock(&stats_lock);
}",1,1,thread.c,STATS_UNLOCK,,false,925,927,STATS_UNLOCK,,,74,void STATS_UNLOCK ()
95997,METHOD,thread.c:<global>,TYPE_DECL,"void threadlocal_stats_reset(void) {
    int ii;
    for (ii = 0; ii < settings.num_threads; ++ii) {
        pthread_mutex_lock(&threads[ii].stats.mutex);
#define X(name) threads[ii].stats.name = 0;
        THREAD_STATS_FIELDS
#ifdef EXTSTORE
        EXTSTORE_THREAD_STATS_FIELDS
#endif
#ifdef PROXY
        PROXY_THREAD_STATS_FIELDS
#endif
#undef X

        memset(&threads[ii].stats.slab_stats, 0,
                sizeof(threads[ii].stats.slab_stats));
        memset(&threads[ii].stats.lru_hits, 0,
                sizeof(uint64_t) * POWER_LARGEST);

        pthread_mutex_unlock(&threads[ii].stats.mutex);
    }
}",1,8,thread.c,threadlocal_stats_reset,,false,929,950,threadlocal_stats_reset,,,75,void threadlocal_stats_reset (void)
96286,METHOD,thread.c:<global>,TYPE_DECL,"void threadlocal_stats_aggregate(struct thread_stats *stats) {
    int ii, sid;

    /* The struct has a mutex, but we can safely set the whole thing
     * to zero since it is unused when aggregating. */
    memset(stats, 0, sizeof(*stats));

    for (ii = 0; ii < settings.num_threads; ++ii) {
        pthread_mutex_lock(&threads[ii].stats.mutex);
#define X(name) stats->name += threads[ii].stats.name;
        THREAD_STATS_FIELDS
#ifdef EXTSTORE
        EXTSTORE_THREAD_STATS_FIELDS
#endif
#ifdef PROXY
        PROXY_THREAD_STATS_FIELDS
#endif
#undef X

        for (sid = 0; sid < MAX_NUMBER_OF_SLAB_CLASSES; sid++) {
#define X(name) stats->slab_stats[sid].name += \
            threads[ii].stats.slab_stats[sid].name;
            SLAB_STATS_FIELDS
#undef X
        }

        for (sid = 0; sid < POWER_LARGEST; sid++) {
            stats->lru_hits[sid] +=
                threads[ii].stats.lru_hits[sid];
            stats->slab_stats[CLEAR_LRU(sid)].get_hits +=
                threads[ii].s...",1,8,thread.c,threadlocal_stats_aggregate,,false,952,990,threadlocal_stats_aggregate,,,76,void threadlocal_stats_aggregate (thread_stats*)
96859,METHOD,thread.c:<global>,TYPE_DECL,"void slab_stats_aggregate(struct thread_stats *stats, struct slab_stats *out) {
    int sid;

    memset(out, 0, sizeof(*out));

    for (sid = 0; sid < MAX_NUMBER_OF_SLAB_CLASSES; sid++) {
#define X(name) out->name += stats->slab_stats[sid].name;
        SLAB_STATS_FIELDS
#undef X
    }
}",1,24,thread.c,slab_stats_aggregate,,false,992,1002,slab_stats_aggregate,,,77,"void slab_stats_aggregate (thread_stats*,slab_stats*)"
96977,METHOD,thread.c:<global>,TYPE_DECL,"void memcached_thread_init(int nthreads, void *arg) {
    int         i;
    int         power;

    for (i = 0; i < POWER_LARGEST; i++) {
        pthread_mutex_init(&lru_locks[i], NULL);
    }
    pthread_mutex_init(&worker_hang_lock, NULL);

    pthread_mutex_init(&init_lock, NULL);
    pthread_cond_init(&init_cond, NULL);

    /* Want a wide lock table, but don't waste memory */
    if (nthreads < 3) {
        power = 10;
    } else if (nthreads < 4) {
        power = 11;
    } else if (nthreads < 5) {
        power = 12;
    } else if (nthreads <= 10) {
        power = 13;
    } else if (nthreads <= 20) {
        power = 14;
    } else {
        /* 32k buckets. just under the hashpower default. */
        power = 15;
    }

    if (power >= hashpower) {
        fprintf(stderr, ""Hash table power size (%d) cannot be equal to or less than item lock table (%d)\n"", hashpower, power);
        fprintf(stderr, ""Item lock table grows with `-t N` (worker threadcount)\n"");
        fprintf(...",1,20,thread.c,memcached_thread_init,,false,1009,1096,memcached_thread_init,,,78,"void memcached_thread_init (int,void*)"
97237,METHOD,timedrun.c:<global>,TYPE_DECL,<global>,1,1,timedrun.c,timedrun.c:<global>,,false,1,111,<global>,,,1,
97243,METHOD,timedrun.c:<global>,TYPE_DECL,"static void signal_handler(int which)
{
    caught_sig = which;
}",1,1,timedrun.c,signal_handler,,false,13,16,signal_handler,,,3,void signal_handler (int)
97251,METHOD,timedrun.c:<global>,TYPE_DECL,"static int wait_for_process(pid_t pid)
{
    int rv = EX_SOFTWARE;
    int status = 0;
    int i = 0;
    struct sigaction sig_handler;

    memset(&sig_handler, 0, sizeof(struct sigaction));
    sig_handler.sa_handler = signal_handler;
    sig_handler.sa_flags = 0;

    sigaction(SIGALRM, &sig_handler, NULL);
    sigaction(SIGHUP, &sig_handler, NULL);
    sigaction(SIGINT, &sig_handler, NULL);
    sigaction(SIGUSR1, &sig_handler, NULL);
    sigaction(SIGTERM, &sig_handler, NULL);
    sigaction(SIGPIPE, &sig_handler, NULL);

    /* Loop forever waiting for the process to quit */
    for (i = 0; ;i++) {
        pid_t p = waitpid(pid, &status, 0);
        if (p == pid) {
            /* child exited.  Let's get out of here */
            rv = WIFEXITED(status) ?
                WEXITSTATUS(status) :
                (0x80 | WTERMSIG(status));
            break;
        } else {
            int sig = 0;
            switch (i) {
            case 0:
                /* On the first iteratio...",1,1,timedrun.c,wait_for_process,,false,18,71,wait_for_process,,,4,int wait_for_process (pid_t)
97400,METHOD,timedrun.c:<global>,TYPE_DECL,"static int spawn_and_wait(char **argv)
{
    int rv = EX_SOFTWARE;
    pid_t pid = fork();

    switch (pid) {
    case -1:
        perror(""fork"");
        rv = EX_OSERR;
        break; /* NOTREACHED */
    case 0:
        execvp(argv[0], argv);
        perror(""exec"");
        rv = EX_SOFTWARE;
        break; /* NOTREACHED */
    default:
        rv = wait_for_process(pid);
    }
    return rv;
}",1,1,timedrun.c,spawn_and_wait,,false,73,92,spawn_and_wait,,,5,int spawn_and_wait (char**)
97445,METHOD,timedrun.c:<global>,TYPE_DECL,"static void usage(void) {
    fprintf(stderr, ""./timedrun <naptime in sec> args...\n"");
    exit(-1);
}",1,1,timedrun.c,usage,,false,94,97,usage,,,6,void usage (void)
97456,METHOD,timedrun.c:<global>,TYPE_DECL,"int main(int argc, char **argv)
{
    int naptime = 0;
    if (argc < 3)
        usage();

    naptime = atoi(argv[1]);
    assert(naptime > 0 && naptime < 1800);

    alarm(naptime);

    return spawn_and_wait(argv+2);
}",1,1,timedrun.c,main,,false,99,111,main,,,7,"int main (int,char**)"
97508,METHOD,tls.c:<global>,TYPE_DECL,<global>,1,1,memcached.h,tls.c:<global>,,false,1,288,<global>,,,1,
97513,METHOD,tls.h:<global>,TYPE_DECL,<global>,1,6,tls.h,tls.h:<global>,,false,1,20,<global>,,,1,
97515,METHOD,tls.h:<global>,TYPE_DECL,void SSL_LOCK(void);,6,19,tls.h,SSL_LOCK,,false,8,8,SSL_LOCK,,,1,void SSL_LOCK (void)
97520,METHOD,tls.h:<global>,TYPE_DECL,void SSL_UNLOCK(void);,6,21,tls.h,SSL_UNLOCK,,false,9,9,SSL_UNLOCK,,,2,void SSL_UNLOCK (void)
97525,METHOD,tls.h:<global>,TYPE_DECL,"ssize_t ssl_read(conn *c, void *buf, size_t count);",9,50,tls.h,ssl_read,,false,10,10,ssl_read,,,3,"ssize_t ssl_read (conn*,void*,size_t)"
97532,METHOD,tls.h:<global>,TYPE_DECL,"ssize_t ssl_sendmsg(conn *c, struct msghdr *msg, int flags);",9,59,tls.h,ssl_sendmsg,,false,11,11,ssl_sendmsg,,,4,"ssize_t ssl_sendmsg (conn*,msghdr*,int)"
97539,METHOD,tls.h:<global>,TYPE_DECL,"ssize_t ssl_write(conn *c, void *buf, size_t count);",9,51,tls.h,ssl_write,,false,12,12,ssl_write,,,5,"ssize_t ssl_write (conn*,void*,size_t)"
97546,METHOD,tls.h:<global>,TYPE_DECL,int ssl_init(void);,5,18,tls.h,ssl_init,,false,14,14,ssl_init,,,6,int ssl_init (void)
97551,METHOD,tls.h:<global>,TYPE_DECL,bool refresh_certs(char **errmsg);,6,33,tls.h,refresh_certs,,false,15,15,refresh_certs,,,7,bool refresh_certs (char**)
97556,METHOD,tls.h:<global>,TYPE_DECL,"void ssl_callback(const SSL *s, int where, int ret);",6,51,tls.h,ssl_callback,,false,16,16,ssl_callback,,,8,"void ssl_callback (SSL*,int,int)"
97563,METHOD,tls.h:<global>,TYPE_DECL,"int ssl_new_session_callback(SSL *s, SSL_SESSION *sess);",5,55,tls.h,ssl_new_session_callback,,false,17,17,ssl_new_session_callback,,,9,"int ssl_new_session_callback (SSL*,SSL_SESSION*)"
97569,METHOD,tls.h:<global>,TYPE_DECL,const char *ssl_proto_text(int version);,12,39,tls.h,ssl_proto_text,,false,18,18,ssl_proto_text,,,10,char* ssl_proto_text (int)
97579,METHOD,trace.h:<global>,TYPE_DECL,<global>,1,6,trace.h,trace.h:<global>,,false,1,71,<global>,,,1,
97600,METHOD,util.c:<global>,TYPE_DECL,<global>,1,1,util.c,util.c:<global>,,false,1,264,<global>,,,1,
97608,METHOD,util.c:<global>,TYPE_DECL,"void uriencode_init(void) {
    int x;
    char *str = uriencode_str;
    for (x = 0; x < 256; x++) {
        if (isalnum(x) || x == '-' || x == '.' || x == '_' || x == '~') {
            uriencode_map[x] = NULL;
        } else {
            snprintf(str, 4, ""%%%02hhX"", (unsigned char)x);
            uriencode_map[x] = str;
            str += 3; /* lobbing off the \0 is fine */
        }
    }
}",1,1,util.c,uriencode_init,,false,14,26,uriencode_init,,,5,void uriencode_init (void)
97671,METHOD,util.c:<global>,TYPE_DECL,"bool uriencode(const char *src, char *dst, const size_t srclen, const size_t dstlen) {
    int x;
    size_t d = 0;
    for (x = 0; x < srclen; x++) {
        if (d + 4 > dstlen)
            return false;
        if (uriencode_map[(unsigned char) src[x]] != NULL) {
            memcpy(&dst[d], uriencode_map[(unsigned char) src[x]], 3);
            d += 3;
        } else {
            dst[d] = src[x];
            d++;
        }
    }
    dst[d] = '\0';
    return true;
}",1,1,util.c,uriencode,,false,28,44,uriencode,,,6,"bool uriencode (char*,char*,size_t,size_t)"
97749,METHOD,util.c:<global>,TYPE_DECL,"bool safe_strtoull(const char *str, uint64_t *out) {
    assert(out != NULL);
    errno = 0;
    *out = 0;
    char *endptr;
    unsigned long long ull = strtoull(str, &endptr, 10);
    if ((errno == ERANGE) || (str == endptr)) {
        return false;
    }

    if (xisspace(*endptr) || (*endptr == '\0' && endptr != str)) {
        if ((long long) ull < 0) {
            /* only check for negative signs in the uncommon case when
             * the unsigned number is so big that it's negative as a
             * signed number. */
            if (strchr(str, '-') != NULL) {
                return false;
            }
        }
        *out = ull;
        return true;
    }
    return false;
}",1,8,util.c,safe_strtoull,,false,49,72,safe_strtoull,,,7,"bool safe_strtoull (char*,uint64_t*)"
97830,METHOD,util.c:<global>,TYPE_DECL,"bool safe_strtoull_hex(const char *str, uint64_t *out) {
    assert(out != NULL);
    errno = 0;
    *out = 0;
    char *endptr;
    unsigned long long ull = strtoull(str, &endptr, 16);
    if ((errno == ERANGE) || (str == endptr)) {
        return false;
    }

    if (xisspace(*endptr) || (*endptr == '\0' && endptr != str)) {
        if ((long long) ull < 0) {
            /* only check for negative signs in the uncommon case when
             * the unsigned number is so big that it's negative as a
             * signed number. */
            if (strchr(str, '-') != NULL) {
                return false;
            }
        }
        *out = ull;
        return true;
    }
    return false;
}",1,8,util.c,safe_strtoull_hex,,false,79,102,safe_strtoull_hex,,,8,"bool safe_strtoull_hex (char*,uint64_t*)"
97911,METHOD,util.c:<global>,TYPE_DECL,"bool safe_strtoll(const char *str, int64_t *out) {
    assert(out != NULL);
    errno = 0;
    *out = 0;
    char *endptr;
    long long ll = strtoll(str, &endptr, 10);
    if ((errno == ERANGE) || (str == endptr)) {
        return false;
    }

    if (xisspace(*endptr) || (*endptr == '\0' && endptr != str)) {
        *out = ll;
        return true;
    }
    return false;
}",1,8,util.c,safe_strtoll,,false,104,119,safe_strtoll,,,9,"bool safe_strtoll (char*,int64_t*)"
97976,METHOD,util.c:<global>,TYPE_DECL,"bool safe_strtoul(const char *str, uint32_t *out) {
    char *endptr = NULL;
    unsigned long l = 0;
    assert(out);
    assert(str);
    *out = 0;
    errno = 0;

    l = strtoul(str, &endptr, 10);
    if ((errno == ERANGE) || (str == endptr)) {
        return false;
    }

    if (xisspace(*endptr) || (*endptr == '\0' && endptr != str)) {
        if ((long) l < 0) {
            /* only check for negative signs in the uncommon case when
             * the unsigned number is so big that it's negative as a
             * signed number. */
            if (strchr(str, '-') != NULL) {
                return false;
            }
        }
        *out = l;
        return true;
    }

    return false;
}",1,8,util.c,safe_strtoul,,false,121,148,safe_strtoul,,,10,"bool safe_strtoul (char*,uint32_t*)"
98063,METHOD,util.c:<global>,TYPE_DECL,"bool safe_strtol(const char *str, int32_t *out) {
    assert(out != NULL);
    errno = 0;
    *out = 0;
    char *endptr;
    long l = strtol(str, &endptr, 10);
    if ((errno == ERANGE) || (str == endptr)) {
        return false;
    }

    if (xisspace(*endptr) || (*endptr == '\0' && endptr != str)) {
        *out = l;
        return true;
    }
    return false;
}",1,8,util.c,safe_strtol,,false,150,165,safe_strtol,,,11,"bool safe_strtol (char*,int32_t*)"
98128,METHOD,util.c:<global>,TYPE_DECL,"bool safe_strtod(const char *str, double *out) {
    assert(out != NULL);
    errno = 0;
    *out = 0;
    char *endptr;
    double d = strtod(str, &endptr);
    if ((errno == ERANGE) || (str == endptr)) {
        return false;
    }

    if (xisspace(*endptr) || (*endptr == '\0' && endptr != str)) {
        *out = d;
        return true;
    }
    return false;
}",1,8,util.c,safe_strtod,,false,167,182,safe_strtod,,,12,"bool safe_strtod (char*,double*)"
98192,METHOD,util.c:<global>,TYPE_DECL,"bool safe_strcpy(char *dst, const char *src, const size_t dstmax) {
   size_t x;

   for (x = 0; x < dstmax - 1 && src[x] != '\0'; x++) {
        dst[x] = src[x];
   }

   dst[x] = '\0';

   if (src[x] == '\0') {
       return true;
   } else {
       return false;
   }
}",1,1,util.c,safe_strcpy,,false,190,204,safe_strcpy,,,13,"bool safe_strcpy (char*,char*,size_t)"
98244,METHOD,util.c:<global>,TYPE_DECL,"bool safe_memcmp(const void *a, const void *b, size_t len) {
    const volatile unsigned char *ua = (const volatile unsigned char *)a;
    const volatile unsigned char *ub = (const volatile unsigned char *)b;
    int delta = 0;
    size_t x;

    for (x = 0; x < len; x++) {
        delta |= ua[x] ^ ub[x];
    }

    if (delta == 0) {
        return true;
    } else {
        return false;
    }
}",1,1,util.c,safe_memcmp,,false,206,221,safe_memcmp,,,14,"bool safe_memcmp (void*,void*,size_t)"
98299,METHOD,util.c:<global>,TYPE_DECL,"void vperror(const char *fmt, ...) {
    int old_errno = errno;
    char buf[1024];
    va_list ap;

    va_start(ap, fmt);
    if (vsnprintf(buf, sizeof(buf), fmt, ap) == -1) {
        buf[sizeof(buf) - 1] = '\0';
    }
    va_end(ap);

    errno = old_errno;

    perror(buf);
}",1,1,util.c,vperror,,false,223,237,vperror,,,15,void vperror (char*...)
98339,METHOD,util.c:<global>,TYPE_DECL,"static uint64_t mc_swap64(uint64_t in) {
#ifdef ENDIAN_LITTLE
    /* Little endian, flip the bytes around until someone makes a faster/better
    * way to do this. */
    int64_t rv = 0;
    int i = 0;
     for(i = 0; i<8; i++) {
        rv = (rv << 8) | (in & 0xff);
        in >>= 8;
     }
    return rv;
#else
    /* big-endian machines don't need byte swapping */
    return in;
#endif
}",1,1,util.c,mc_swap64,,false,240,255,mc_swap64,,,16,uint64_t mc_swap64 (uint64_t)
98346,METHOD,util.c:<global>,TYPE_DECL,"uint64_t ntohll(uint64_t val) {
   return mc_swap64(val);
}",1,1,util.c,ntohll,,false,257,259,ntohll,,,17,uint64_t ntohll (uint64_t)
98354,METHOD,util.c:<global>,TYPE_DECL,"uint64_t htonll(uint64_t val) {
   return mc_swap64(val);
}",1,1,util.c,htonll,,false,261,263,htonll,,,18,uint64_t htonll (uint64_t)
98367,METHOD,util.h:<global>,TYPE_DECL,<global>,1,4,util.h,util.h:<global>,,false,1,43,<global>,,,1,
98369,METHOD,util.h:<global>,TYPE_DECL,void uriencode_init(void);,6,25,util.h,uriencode_init,,false,4,4,uriencode_init,,,1,void uriencode_init (void)
98374,METHOD,util.h:<global>,TYPE_DECL,"bool uriencode(const char *src, char *dst, const size_t srclen, const size_t dstlen);",6,84,util.h,uriencode,,false,5,5,uriencode,,,2,"bool uriencode (char*,char*,size_t,size_t)"
98382,METHOD,util.h:<global>,TYPE_DECL,"bool safe_strtoull(const char *str, uint64_t *out);",6,50,util.h,safe_strtoull,,false,16,16,safe_strtoull,,,3,"bool safe_strtoull (char*,uint64_t*)"
98388,METHOD,util.h:<global>,TYPE_DECL,"bool safe_strtoull_hex(const char *str, uint64_t *out);",6,54,util.h,safe_strtoull_hex,,false,17,17,safe_strtoull_hex,,,4,"bool safe_strtoull_hex (char*,uint64_t*)"
98394,METHOD,util.h:<global>,TYPE_DECL,"bool safe_strtoll(const char *str, int64_t *out);",6,48,util.h,safe_strtoll,,false,18,18,safe_strtoll,,,5,"bool safe_strtoll (char*,int64_t*)"
98400,METHOD,util.h:<global>,TYPE_DECL,"bool safe_strtoul(const char *str, uint32_t *out);",6,49,util.h,safe_strtoul,,false,19,19,safe_strtoul,,,6,"bool safe_strtoul (char*,uint32_t*)"
98406,METHOD,util.h:<global>,TYPE_DECL,"bool safe_strtol(const char *str, int32_t *out);",6,47,util.h,safe_strtol,,false,20,20,safe_strtol,,,7,"bool safe_strtol (char*,int32_t*)"
98412,METHOD,util.h:<global>,TYPE_DECL,"bool safe_strtod(const char *str, double *out);",6,46,util.h,safe_strtod,,false,21,21,safe_strtod,,,8,"bool safe_strtod (char*,double*)"
98418,METHOD,util.h:<global>,TYPE_DECL,"bool safe_strcpy(char *dst, const char *src, const size_t dstmax);",6,65,util.h,safe_strcpy,,false,22,22,safe_strcpy,,,9,"bool safe_strcpy (char*,char*,size_t)"
98425,METHOD,util.h:<global>,TYPE_DECL,"bool safe_memcmp(const void *a, const void *b, size_t len);",6,58,util.h,safe_memcmp,,false,23,23,safe_memcmp,,,10,"bool safe_memcmp (void*,void*,size_t)"
98432,METHOD,util.h:<global>,TYPE_DECL,extern uint64_t htonll(uint64_t);,17,32,util.h,htonll,,false,26,26,htonll,,,11,uint64_t htonll (ANY)
98437,METHOD,util.h:<global>,TYPE_DECL,extern uint64_t ntohll(uint64_t);,17,32,util.h,ntohll,,false,27,27,ntohll,,,12,uint64_t ntohll (ANY)
98442,METHOD,util.h:<global>,TYPE_DECL,"void vperror(const char *fmt, ...)
    __gcc_attribute__ ((format (printf, 1, 2)));",6,34,util.h,vperror,,false,42,42,vperror,,,13,void vperror (char*...)
98472,METHOD,vendor\mcmc\example.c:<global>,TYPE_DECL,<global>,1,1,vendor\mcmc\example.c,vendor\mcmc\example.c:<global>,,false,1,292,<global>,,,1,
98474,METHOD,vendor\mcmc\example.c:<global>,TYPE_DECL,"static void show_response_buffer(void *c, char *rbuf, size_t bufsize) {
    int status;
    mcmc_resp_t resp;
    char *val = NULL;

    do {
        int bread = recv(mcmc_fd(c), rbuf, bufsize, 0);

        // need to know how far to advance the buffer.
        // resp->reslen + resp->vlen_read works, but feels awkward.
        status = mcmc_parse_buf(c, rbuf, bread, &resp);
    } while (status == MCMC_WANT_READ);

    if (status != MCMC_OK) {
        printf(""bad response\n"");
    }

    // now we need to read the value back.
    // resp.reslen + resp.vlen is the total length.
    // resp.reslen + resp.vlen_read is how much of the buffer was used.
    // resp.vlen_read vs resp.vlen is how much was read vs how much still
    // needs to be read from the socket.
    if (resp.vlen != resp.vlen_read) {
        // malloc and recv the rest.
        // can/should add convenience functions for this?
        val = malloc(resp.vlen);
        memcpy(val, resp.value, resp.vlen_read);
        si...",1,23,vendor\mcmc\example.c,show_response_buffer,,false,16,56,show_response_buffer,,,1,"void show_response_buffer (void*,char*,size_t)"
98588,METHOD,vendor\mcmc\example.c:<global>,TYPE_DECL,"void buffer_mode(void) {
    void *c = malloc(mcmc_size(MCMC_OPTION_BLANK));
    size_t bufsize = mcmc_min_buffer_size(MCMC_OPTION_BLANK) * 2;
    char *rbuf = malloc(bufsize);

    int status = mcmc_connect(c, ""127.0.0.1"", ""11211"", MCMC_OPTION_BLANK);

    char *requests[5] = {""get foo\r\n"",
        ""get foob\r\n"",
        ""mg foo s t v\r\n"",
        ""mg doof s t v Omoo k\r\n"",
        """"};

    for (int x = 0; strlen(requests[x]) != 0; x++) {
        status = mcmc_send_request(c, requests[x], strlen(requests[x]), 1);

        if (status != MCMC_OK) {
            fprintf(stderr, ""Failed to send request to memcached\n"");
            return;
        }

        // Regardless of what command we sent, this should print out the response.
        show_response_buffer(c, rbuf, bufsize);
    }

}",1,31,vendor\mcmc\example.c,buffer_mode,,false,145,170,buffer_mode,,,2,void buffer_mode (void)
98676,METHOD,vendor\mcmc\example.c:<global>,TYPE_DECL,"int main (int argc, char *agv[]) {
    // TODO: detect if C is pre-C11?
    printf(""C version: %ld\n"", __STDC_VERSION__);

    if (signal(SIGPIPE, SIG_IGN) == SIG_ERR) {
        perror(""signal"");
        exit(1);
    }
/*
    void *c = malloc(mcmc_size(MCMC_OPTION_BLANK));
    // we only ""need"" the minimum buf size.
    // buffers large enough to fit return values result in fewer syscalls.
    size_t bufsize = mcmc_min_buffer_size(MCMC_OPTION_BLANK) * 2;
    // buffers are also generally agnostic to clients. The buffer must be
    // held and re-used when required by the API. When the buffer is empty,
    // it may be released to a pool or reused with other connections.
    char *rbuf = malloc(bufsize);

    int status;

    // API is blocking by default.
    status = mcmc_connect(c, ""127.0.0.1"", ""11211"", MCMC_OPTION_BLANK);

    if (status != MCMC_CONNECTED) {
        // TODO: mc_strerr(c);
        fprintf(stderr, ""Failed to connect to memcached\n"");
        return -1;
    }

    c...",1,31,vendor\mcmc\example.c,main,,false,172,292,main,,,3,"int main (int,char[]*)"
98728,METHOD,vendor\mcmc\mcmc.c:<global>,TYPE_DECL,<global>,1,1,vendor\mcmc\mcmc.c,vendor\mcmc\mcmc.c:<global>,,false,1,669,<global>,,,1,
98743,METHOD,vendor\mcmc\mcmc.c:<global>,TYPE_DECL,"static int _mcmc_parse_value_line(mcmc_ctx_t *ctx, mcmc_resp_t *r) {
    char *buf = ctx->buffer_head;
    // we know that ""VALUE "" has matched, so skip that.
    char *p = buf+6;
    size_t l = ctx->buffer_request_len;

    // <key> <flags> <bytes> [<cas unique>]
    char *key = p;
    int keylen;
    p = memchr(p, ' ', l - 6);
    if (p == NULL) {
        // FIXME: these should return MCMC_ERR and set the internal parse
        // error code.
        return MCMC_PARSE_ERROR;
    }

    keylen = p - key;

    // convert flags into something useful.
    // FIXME: do we need to prevent overruns in strtoul?
    // we know for sure the line will eventually end in a \n.
    char *n = NULL;
    errno = 0;
    uint32_t flags = strtoul(p, &n, 10);
    if ((errno == ERANGE) || (p == n) || (*n != ' ')) {
        return MCMC_PARSE_ERROR;
    }
    p = n;

    errno = 0;
    uint32_t bytes = strtoul(p, &n, 10);
    if ((errno == ERANGE) || (p == n)) {
        return MCMC_PARSE_ERROR;
    }
   ...",1,15,vendor\mcmc\mcmc.c,_mcmc_parse_value_line,,false,54,120,_mcmc_parse_value_line,,,3,"int _mcmc_parse_value_line (mcmc_ctx_t*,mcmc_resp_t*)"
98970,METHOD,vendor\mcmc\mcmc.c:<global>,TYPE_DECL,"static int _mcmc_parse_response(mcmc_ctx_t *ctx, mcmc_resp_t *r) {
    char *buf = ctx->buffer_head;
    char *cur = buf;
    size_t l = ctx->buffer_request_len;
    int rlen; // response code length.
    int more = 0;
    r->reslen = ctx->buffer_request_len;
    r->type = MCMC_RESP_GENERIC;

    // walk until the \r\n
    while (l-- > 2) {
        if (*cur == ' ') {
            more = 1;
            break;
        }
        cur++;
    }
    rlen = cur - buf;

    // incr/decr returns a number with no code :(
    // not checking length first since buf must have at least one char to
    // enter this function.
    if (buf[0] >= '0' && buf[0] <= '9') {
        // TODO: parse it as a number on request.
        // TODO: validate whole thing as digits here?
        ctx->status_flags |= FLAG_BUF_IS_NUMERIC;
        r->type = MCMC_RESP_NUMERIC;
        return MCMC_OK;
    }

    if (rlen < 2) {
        ctx->error = MCMC_PARSE_ERROR_SHORT;
        return MCMC_ERR;
    }

    int rv = MCMC_O...",1,14,vendor\mcmc\mcmc.c,_mcmc_parse_response,,false,125,321,_mcmc_parse_response,,,4,"int _mcmc_parse_response (mcmc_ctx_t*,mcmc_resp_t*)"
99598,METHOD,vendor\mcmc\mcmc.c:<global>,TYPE_DECL,"int mcmc_fd(void *c) {
    mcmc_ctx_t *ctx = (mcmc_ctx_t *)c;
    return ctx->fd;
}",1,1,vendor\mcmc\mcmc.c,mcmc_fd,,false,325,328,mcmc_fd,,,5,int mcmc_fd (void*)
99613,METHOD,vendor\mcmc\mcmc.c:<global>,TYPE_DECL,"size_t mcmc_size(int options) {
    return sizeof(mcmc_ctx_t);
}",1,1,vendor\mcmc\mcmc.c,mcmc_size,,false,330,332,mcmc_size,,,6,size_t mcmc_size (int)
99621,METHOD,vendor\mcmc\mcmc.c:<global>,TYPE_DECL,"size_t mcmc_min_buffer_size(int options) {
    return MIN_BUFFER_SIZE;
}",1,11,vendor\mcmc\mcmc.c,mcmc_min_buffer_size,,false,337,339,mcmc_min_buffer_size,,,7,size_t mcmc_min_buffer_size (int)
99630,METHOD,vendor\mcmc\mcmc.c:<global>,TYPE_DECL,"int mcmc_parse_buf(void *c, char *buf, size_t read, mcmc_resp_t *r) {
    mcmc_ctx_t *ctx = c;
    char *el;

    el = memchr(buf, '\n', read);
    if (el == NULL) {
        return MCMC_WANT_READ;
    }

    memset(r, 0, sizeof(*r));

    // Consume through the newline, note where the value would start if exists
    r->value = el+1;

    ctx->buffer_used = read;
    // FIXME: the server must be stricter in what it sends back. should always
    // have a \r. check for it and fail?
    ctx->buffer_request_len = r->value - buf;
    // leave the \r\n in the line end cache.
    ctx->buffer_head = buf;

    return _mcmc_parse_response(ctx, r);
}",1,15,vendor\mcmc\mcmc.c,mcmc_parse_buf,,false,347,369,mcmc_parse_buf,,,8,"int mcmc_parse_buf (void*,char*,size_t,mcmc_resp_t*)"
99694,METHOD,vendor\mcmc\mcmc.c:<global>,TYPE_DECL,"int mcmc_check_nonblock_connect(void *c, int *err) {
    mcmc_ctx_t *ctx = (mcmc_ctx_t *)c;
    socklen_t errsize = sizeof(*err);
    if (getsockopt(ctx->fd, SOL_SOCKET, SO_ERROR, err, &errsize) == 0) {
        if (*err == 0) {
            return MCMC_OK;
        }
    } else {
        // getsockopt failed. still need to pass up the error.
        *err = errno;
    }

    return MCMC_ERR;
}",1,19,vendor\mcmc\mcmc.c,mcmc_check_nonblock_connect,,false,376,389,mcmc_check_nonblock_connect,,,9,"int mcmc_check_nonblock_connect (void*,int*)"
99746,METHOD,vendor\mcmc\mcmc.c:<global>,TYPE_DECL,"int mcmc_connect(void *c, char *host, char *port, int options) {
    mcmc_ctx_t *ctx = (mcmc_ctx_t *)c;

    int s;
    int sock;
    int res = MCMC_CONNECTED;
    struct addrinfo hints;
    struct addrinfo *ai;
    struct addrinfo *next;

    // Since our cx memory was likely malloc'ed, ensure we start clear.
    memset(ctx, 0, sizeof(mcmc_ctx_t));
    memset(&hints, 0, sizeof(hints));
    hints.ai_family = AF_INET;
    hints.ai_socktype = SOCK_STREAM;

    s = getaddrinfo(host, port, &hints, &ai);

    if (s != 0) {
        hints.ai_family = AF_INET6;
        s = getaddrinfo(host, port, &hints, &ai);
        if (s != 0) {
            // TODO: gai_strerror(s)
            ctx->gai_status = s;
            res = MCMC_ERR;
            goto end;
        }
    }

    for (next = ai; next != NULL; next = next->ai_next) {
        sock = socket(next->ai_family, next->ai_socktype,
                next->ai_protocol);
        if (sock == -1)
            continue;

        if (options & MCMC_OP...",1,14,vendor\mcmc\mcmc.c,mcmc_connect,,false,397,483,mcmc_connect,,,10,"int mcmc_connect (void*,char*,char*,int)"
100018,METHOD,vendor\mcmc\mcmc.c:<global>,TYPE_DECL,"int mcmc_send_request(void *c, const char *request, int len, int count) {
    mcmc_ctx_t *ctx = (mcmc_ctx_t *)c;

    // adjust our send buffer by how much has already been sent.
    const char *r = request + ctx->sent_bytes_partial;
    int l = len - ctx->sent_bytes_partial;
    int sent = send(ctx->fd, r, l, 0);
    if (sent == -1) {
        // implicitly handle nonblock mode.
        if (errno == EAGAIN || errno == EWOULDBLOCK) {
            return MCMC_WANT_WRITE;
        } else {
            return MCMC_ERR;
        }
    }

    if (sent < len) {
        // can happen anytime, but mostly in nonblocking mode.
        ctx->sent_bytes_partial += sent;
        return MCMC_WANT_WRITE;
    } else {
        ctx->sent_bytes_partial = 0;
    }

    return MCMC_OK;
}",1,19,vendor\mcmc\mcmc.c,mcmc_send_request,,false,488,513,mcmc_send_request,,,11,"int mcmc_send_request (void*,char*,int,int)"
100109,METHOD,vendor\mcmc\mcmc.c:<global>,TYPE_DECL,"int mcmc_request_writev(void *c, const struct iovec *iov, int iovcnt, ssize_t *sent, int count) {
    mcmc_ctx_t *ctx = (mcmc_ctx_t *)c;
    // need to track sent vs tosend to know when to update counters.
    ssize_t tosend = 0;
    for (int i = 0; i < iovcnt; i++) {
        tosend += iov[i].iov_len;
    }

    *sent = writev(ctx->fd, iov, iovcnt);
    if (*sent == -1) {
        // implicitly handle nonblock mode.
        if (errno == EAGAIN || errno == EWOULDBLOCK) {
            return MCMC_WANT_WRITE;
        } else {
            return MCMC_ERR;
        }
    }

    if (*sent < tosend) {
        // can happen anytime, but mostly in nonblocking mode.
        return MCMC_WANT_WRITE;
    }

    return MCMC_OK;
}",1,19,vendor\mcmc\mcmc.c,mcmc_request_writev,,false,518,542,mcmc_request_writev,,,12,"int mcmc_request_writev (void*,iovec*,int,ssize_t*,int)"
100197,METHOD,vendor\mcmc\mcmc.c:<global>,TYPE_DECL,"void mcmc_get_error(void *c, char *code, size_t clen, char *msg, size_t mlen) {
    code[0] = '\0';
    msg[0] = '\0';
}",1,1,vendor\mcmc\mcmc.c,mcmc_get_error,,false,609,612,mcmc_get_error,,,13,"void mcmc_get_error (void*,char*,size_t,char*,size_t)"
100216,METHOD,vendor\mcmc\mcmc.c:<global>,TYPE_DECL,"int mcmc_disconnect(void *c) {
    mcmc_ctx_t *ctx = (mcmc_ctx_t *)c;

    // FIXME: I forget if 0 can be valid.
    if (ctx->fd != 0) {
        close(ctx->fd);
        return MCMC_OK;
    } else {
        return MCMC_NOT_CONNECTED;
    }
}",1,15,vendor\mcmc\mcmc.c,mcmc_disconnect,,false,659,669,mcmc_disconnect,,,14,int mcmc_disconnect (void*)
100251,METHOD,vendor\mcmc\mcmc.h:<global>,TYPE_DECL,<global>,1,6,vendor\mcmc\mcmc.h,vendor\mcmc\mcmc.h:<global>,,false,1,89,<global>,,,1,
100273,METHOD,vendor\mcmc\mcmc.h:<global>,TYPE_DECL,int mcmc_fd(void *c);,5,20,vendor\mcmc\mcmc.h,mcmc_fd,,false,76,76,mcmc_fd,,,3,int mcmc_fd (void*)
100278,METHOD,vendor\mcmc\mcmc.h:<global>,TYPE_DECL,size_t mcmc_size(int options);,8,29,vendor\mcmc\mcmc.h,mcmc_size,,false,77,77,mcmc_size,,,4,size_t mcmc_size (int)
100283,METHOD,vendor\mcmc\mcmc.h:<global>,TYPE_DECL,size_t mcmc_min_buffer_size(int options);,8,40,vendor\mcmc\mcmc.h,mcmc_min_buffer_size,,false,78,78,mcmc_min_buffer_size,,,5,size_t mcmc_min_buffer_size (int)
100288,METHOD,vendor\mcmc\mcmc.h:<global>,TYPE_DECL,"int mcmc_parse_buf(void *c, char *buf, size_t read, mcmc_resp_t *r);",5,67,vendor\mcmc\mcmc.h,mcmc_parse_buf,,false,79,79,mcmc_parse_buf,,,6,"int mcmc_parse_buf (void*,char*,size_t,mcmc_resp_t*)"
100296,METHOD,vendor\mcmc\mcmc.h:<global>,TYPE_DECL,"int mcmc_connect(void *c, char *host, char *port, int options);",5,62,vendor\mcmc\mcmc.h,mcmc_connect,,false,80,80,mcmc_connect,,,7,"int mcmc_connect (void*,char*,char*,int)"
100304,METHOD,vendor\mcmc\mcmc.h:<global>,TYPE_DECL,"int mcmc_check_nonblock_connect(void *c, int *err);",5,50,vendor\mcmc\mcmc.h,mcmc_check_nonblock_connect,,false,81,81,mcmc_check_nonblock_connect,,,8,"int mcmc_check_nonblock_connect (void*,int*)"
100310,METHOD,vendor\mcmc\mcmc.h:<global>,TYPE_DECL,"int mcmc_send_request(void *c, const char *request, int len, int count);",5,71,vendor\mcmc\mcmc.h,mcmc_send_request,,false,82,82,mcmc_send_request,,,9,"int mcmc_send_request (void*,char*,int,int)"
100318,METHOD,vendor\mcmc\mcmc.h:<global>,TYPE_DECL,"int mcmc_request_writev(void *c, const struct iovec *iov, int iovcnt, ssize_t *sent, int count);",5,95,vendor\mcmc\mcmc.h,mcmc_request_writev,,false,83,83,mcmc_request_writev,,,10,"int mcmc_request_writev (void*,iovec*,int,ssize_t*,int)"
100327,METHOD,vendor\mcmc\mcmc.h:<global>,TYPE_DECL,int mcmc_disconnect(void *c);,5,28,vendor\mcmc\mcmc.h,mcmc_disconnect,,false,86,86,mcmc_disconnect,,,11,int mcmc_disconnect (void*)
100332,METHOD,vendor\mcmc\mcmc.h:<global>,TYPE_DECL,"void mcmc_get_error(void *c, char *code, size_t clen, char *msg, size_t mlen);",6,77,vendor\mcmc\mcmc.h,mcmc_get_error,,false,87,87,mcmc_get_error,,,12,"void mcmc_get_error (void*,char*,size_t,char*,size_t)"
100384,METHOD,xxhash.h:<global>,TYPE_DECL,<global>,1,4,xxhash.h,xxhash.h:<global>,,false,1,5325,<global>,,,1,
100386,METHOD,xxhash.h:<global>,TYPE_DECL,unsigned XXH_versionNumber (void);,25,48,xxhash.h,XXH_versionNumber,,false,280,280,XXH_versionNumber,,,1,unsigned XXH_versionNumber (void)
100394,METHOD,<empty>,<empty>,<empty>,1,,xxhash.h,XXH_errorcode:<clinit>,,false,287,,<clinit>,,,3,
100403,METHOD,xxhash.h:<global>,TYPE_DECL,"XXH32_hash_t XXH32 (const void* input, size_t length, XXH32_hash_t seed);",29,87,xxhash.h,XXH32,,false,358,358,XXH32,,,5,"XXH32_hash_t XXH32 (void*,size_t,XXH32_hash_t)"
100412,METHOD,xxhash.h:<global>,TYPE_DECL,XXH32_state_t* XXH32_createState(void);,29,53,xxhash.h,XXH32_createState,,false,424,424,XXH32_createState,,,8,XXH32_state_t* XXH32_createState (void)
100417,METHOD,xxhash.h:<global>,TYPE_DECL,XXH_errorcode  XXH32_freeState(XXH32_state_t* statePtr);,31,70,xxhash.h,XXH32_freeState,,false,432,432,XXH32_freeState,,,9,XXH_errorcode XXH32_freeState (XXH32_state_t*)
100422,METHOD,xxhash.h:<global>,TYPE_DECL,"void XXH32_copyState(XXH32_state_t* dst_state, const XXH32_state_t* src_state);",21,93,xxhash.h,XXH32_copyState,,false,441,441,XXH32_copyState,,,10,"void XXH32_copyState (XXH32_state_t*,XXH32_state_t*)"
100428,METHOD,xxhash.h:<global>,TYPE_DECL,"XXH_errorcode XXH32_reset  (XXH32_state_t* statePtr, XXH32_hash_t seed);",30,86,xxhash.h,XXH32_reset,,false,456,456,XXH32_reset,,,11,"XXH_errorcode XXH32_reset (XXH32_state_t*,XXH32_hash_t)"
100434,METHOD,xxhash.h:<global>,TYPE_DECL,"XXH_errorcode XXH32_update (XXH32_state_t* statePtr, const void* input, size_t length);",30,101,xxhash.h,XXH32_update,,false,476,476,XXH32_update,,,12,"XXH_errorcode XXH32_update (XXH32_state_t*,void*,size_t)"
100441,METHOD,xxhash.h:<global>,TYPE_DECL,XXH32_hash_t  XXH32_digest (const XXH32_state_t* statePtr);,30,73,xxhash.h,XXH32_digest,,false,492,492,XXH32_digest,,,13,XXH32_hash_t XXH32_digest (XXH32_state_t*)
100448,METHOD,<empty>,<empty>,<empty>,1,,xxhash.h,XXH32_canonical_t:<clinit>,,false,518,,<clinit>,,,2,
100455,METHOD,xxhash.h:<global>,TYPE_DECL,"void XXH32_canonicalFromHash(XXH32_canonical_t* dst, XXH32_hash_t hash);",21,86,xxhash.h,XXH32_canonicalFromHash,,false,531,531,XXH32_canonicalFromHash,,,16,"void XXH32_canonicalFromHash (XXH32_canonical_t*,XXH32_hash_t)"
100461,METHOD,xxhash.h:<global>,TYPE_DECL,XXH32_hash_t XXH32_hashFromCanonical(const XXH32_canonical_t* src);,29,81,xxhash.h,XXH32_hashFromCanonical,,false,543,543,XXH32_hashFromCanonical,,,17,XXH32_hash_t XXH32_hashFromCanonical (XXH32_canonical_t*)
100467,METHOD,xxhash.h:<global>,TYPE_DECL,"XXH64_hash_t XXH64(const void* input, size_t length, XXH64_hash_t seed);",29,86,xxhash.h,XXH64,,false,617,617,XXH64,,,19,"XXH64_hash_t XXH64 (void*,size_t,XXH64_hash_t)"
100476,METHOD,xxhash.h:<global>,TYPE_DECL,XXH64_state_t* XXH64_createState(void);,29,53,xxhash.h,XXH64_createState,,false,626,626,XXH64_createState,,,22,XXH64_state_t* XXH64_createState (void)
100481,METHOD,xxhash.h:<global>,TYPE_DECL,XXH_errorcode  XXH64_freeState(XXH64_state_t* statePtr);,31,70,xxhash.h,XXH64_freeState,,false,627,627,XXH64_freeState,,,23,XXH_errorcode XXH64_freeState (XXH64_state_t*)
100486,METHOD,xxhash.h:<global>,TYPE_DECL,"void XXH64_copyState(XXH64_state_t* dst_state, const XXH64_state_t* src_state);",21,93,xxhash.h,XXH64_copyState,,false,628,628,XXH64_copyState,,,24,"void XXH64_copyState (XXH64_state_t*,XXH64_state_t*)"
100492,METHOD,xxhash.h:<global>,TYPE_DECL,"XXH_errorcode XXH64_reset  (XXH64_state_t* statePtr, XXH64_hash_t seed);",30,86,xxhash.h,XXH64_reset,,false,630,630,XXH64_reset,,,25,"XXH_errorcode XXH64_reset (XXH64_state_t*,XXH64_hash_t)"
100498,METHOD,xxhash.h:<global>,TYPE_DECL,"XXH_errorcode XXH64_update (XXH64_state_t* statePtr, const void* input, size_t length);",30,101,xxhash.h,XXH64_update,,false,631,631,XXH64_update,,,26,"XXH_errorcode XXH64_update (XXH64_state_t*,void*,size_t)"
100505,METHOD,xxhash.h:<global>,TYPE_DECL,XXH64_hash_t  XXH64_digest (const XXH64_state_t* statePtr);,30,73,xxhash.h,XXH64_digest,,false,632,632,XXH64_digest,,,27,XXH64_hash_t XXH64_digest (XXH64_state_t*)
100512,METHOD,<empty>,<empty>,<empty>,1,,xxhash.h,XXH64_canonical_t:<clinit>,,false,635,,<clinit>,,,2,
100520,METHOD,xxhash.h:<global>,TYPE_DECL,"void XXH64_canonicalFromHash(XXH64_canonical_t* dst, XXH64_hash_t hash);",21,86,xxhash.h,XXH64_canonicalFromHash,,false,636,636,XXH64_canonicalFromHash,,,30,"void XXH64_canonicalFromHash (XXH64_canonical_t*,XXH64_hash_t)"
100526,METHOD,xxhash.h:<global>,TYPE_DECL,XXH64_hash_t XXH64_hashFromCanonical(const XXH64_canonical_t* src);,29,81,xxhash.h,XXH64_hashFromCanonical,,false,637,637,XXH64_hashFromCanonical,,,31,XXH64_hash_t XXH64_hashFromCanonical (XXH64_canonical_t*)
100531,METHOD,xxhash.h:<global>,TYPE_DECL,"XXH64_hash_t XXH3_64bits(const void* data, size_t len);",29,69,xxhash.h,XXH3_64bits,,false,691,691,XXH3_64bits,,,32,"XXH64_hash_t XXH3_64bits (void*,size_t)"
100537,METHOD,xxhash.h:<global>,TYPE_DECL,"XXH64_hash_t XXH3_64bits_withSeed(const void* data, size_t len, XXH64_hash_t seed);",29,97,xxhash.h,XXH3_64bits_withSeed,,false,700,700,XXH3_64bits_withSeed,,,33,"XXH64_hash_t XXH3_64bits_withSeed (void*,size_t,XXH64_hash_t)"
100544,METHOD,xxhash.h:<global>,TYPE_DECL,"XXH64_hash_t XXH3_64bits_withSecret(const void* data, size_t len, const void* secret, size_t secretSize);",29,119,xxhash.h,XXH3_64bits_withSecret,,false,724,724,XXH3_64bits_withSecret,,,34,"XXH64_hash_t XXH3_64bits_withSecret (void*,size_t,void*,size_t)"
100554,METHOD,xxhash.h:<global>,TYPE_DECL,XXH3_state_t* XXH3_createState(void);,28,51,xxhash.h,XXH3_createState,,false,741,741,XXH3_createState,,,37,XXH3_state_t* XXH3_createState (void)
100559,METHOD,xxhash.h:<global>,TYPE_DECL,XXH_errorcode XXH3_freeState(XXH3_state_t* statePtr);,30,67,xxhash.h,XXH3_freeState,,false,742,742,XXH3_freeState,,,38,XXH_errorcode XXH3_freeState (XXH3_state_t*)
100564,METHOD,xxhash.h:<global>,TYPE_DECL,"void XXH3_copyState(XXH3_state_t* dst_state, const XXH3_state_t* src_state);",21,90,xxhash.h,XXH3_copyState,,false,743,743,XXH3_copyState,,,39,"void XXH3_copyState (XXH3_state_t*,XXH3_state_t*)"
100570,METHOD,xxhash.h:<global>,TYPE_DECL,XXH_errorcode XXH3_64bits_reset(XXH3_state_t* statePtr);,30,70,xxhash.h,XXH3_64bits_reset,,false,750,750,XXH3_64bits_reset,,,40,XXH_errorcode XXH3_64bits_reset (XXH3_state_t*)
100575,METHOD,xxhash.h:<global>,TYPE_DECL,"XXH_errorcode XXH3_64bits_reset_withSeed(XXH3_state_t* statePtr, XXH64_hash_t seed);",30,98,xxhash.h,XXH3_64bits_reset_withSeed,,false,756,756,XXH3_64bits_reset_withSeed,,,41,"XXH_errorcode XXH3_64bits_reset_withSeed (XXH3_state_t*,XXH64_hash_t)"
100581,METHOD,xxhash.h:<global>,TYPE_DECL,"XXH_errorcode XXH3_64bits_reset_withSecret(XXH3_state_t* statePtr, const void* secret, size_t secretSize);",30,120,xxhash.h,XXH3_64bits_reset_withSecret,,false,766,766,XXH3_64bits_reset_withSecret,,,42,"XXH_errorcode XXH3_64bits_reset_withSecret (XXH3_state_t*,void*,size_t)"
100588,METHOD,xxhash.h:<global>,TYPE_DECL,"XXH_errorcode XXH3_64bits_update (XXH3_state_t* statePtr, const void* input, size_t length);",30,106,xxhash.h,XXH3_64bits_update,,false,768,768,XXH3_64bits_update,,,43,"XXH_errorcode XXH3_64bits_update (XXH3_state_t*,void*,size_t)"
100595,METHOD,xxhash.h:<global>,TYPE_DECL,XXH64_hash_t  XXH3_64bits_digest (const XXH3_state_t* statePtr);,30,78,xxhash.h,XXH3_64bits_digest,,false,769,769,XXH3_64bits_digest,,,44,XXH64_hash_t XXH3_64bits_digest (XXH3_state_t*)
100604,METHOD,xxhash.h:<global>,TYPE_DECL,"XXH128_hash_t XXH3_128bits(const void* data, size_t len);",30,71,xxhash.h,XXH3_128bits,,false,790,790,XXH3_128bits,,,47,"XXH128_hash_t XXH3_128bits (void*,size_t)"
100610,METHOD,xxhash.h:<global>,TYPE_DECL,"XXH128_hash_t XXH3_128bits_withSeed(const void* data, size_t len, XXH64_hash_t seed);",30,99,xxhash.h,XXH3_128bits_withSeed,,false,791,791,XXH3_128bits_withSeed,,,48,"XXH128_hash_t XXH3_128bits_withSeed (void*,size_t,XXH64_hash_t)"
100617,METHOD,xxhash.h:<global>,TYPE_DECL,"XXH128_hash_t XXH3_128bits_withSecret(const void* data, size_t len, const void* secret, size_t secretSize);",30,121,xxhash.h,XXH3_128bits_withSecret,,false,792,792,XXH3_128bits_withSecret,,,49,"XXH128_hash_t XXH3_128bits_withSecret (void*,size_t,void*,size_t)"
100625,METHOD,xxhash.h:<global>,TYPE_DECL,XXH_errorcode XXH3_128bits_reset(XXH3_state_t* statePtr);,30,71,xxhash.h,XXH3_128bits_reset,,false,807,807,XXH3_128bits_reset,,,50,XXH_errorcode XXH3_128bits_reset (XXH3_state_t*)
100630,METHOD,xxhash.h:<global>,TYPE_DECL,"XXH_errorcode XXH3_128bits_reset_withSeed(XXH3_state_t* statePtr, XXH64_hash_t seed);",30,99,xxhash.h,XXH3_128bits_reset_withSeed,,false,808,808,XXH3_128bits_reset_withSeed,,,51,"XXH_errorcode XXH3_128bits_reset_withSeed (XXH3_state_t*,XXH64_hash_t)"
100636,METHOD,xxhash.h:<global>,TYPE_DECL,"XXH_errorcode XXH3_128bits_reset_withSecret(XXH3_state_t* statePtr, const void* secret, size_t secretSize);",30,121,xxhash.h,XXH3_128bits_reset_withSecret,,false,809,809,XXH3_128bits_reset_withSecret,,,52,"XXH_errorcode XXH3_128bits_reset_withSecret (XXH3_state_t*,void*,size_t)"
100643,METHOD,xxhash.h:<global>,TYPE_DECL,"XXH_errorcode XXH3_128bits_update (XXH3_state_t* statePtr, const void* input, size_t length);",30,107,xxhash.h,XXH3_128bits_update,,false,811,811,XXH3_128bits_update,,,53,"XXH_errorcode XXH3_128bits_update (XXH3_state_t*,void*,size_t)"
100650,METHOD,xxhash.h:<global>,TYPE_DECL,XXH128_hash_t XXH3_128bits_digest (const XXH3_state_t* statePtr);,30,79,xxhash.h,XXH3_128bits_digest,,false,812,812,XXH3_128bits_digest,,,54,XXH128_hash_t XXH3_128bits_digest (XXH3_state_t*)
100655,METHOD,xxhash.h:<global>,TYPE_DECL,"int XXH128_isEqual(XXH128_hash_t h1, XXH128_hash_t h2);",20,69,xxhash.h,XXH128_isEqual,,false,822,822,XXH128_isEqual,,,55,"int XXH128_isEqual (XXH128_hash_t,XXH128_hash_t)"
100661,METHOD,xxhash.h:<global>,TYPE_DECL,"int XXH128_cmp(const void* h128_1, const void* h128_2);",20,69,xxhash.h,XXH128_cmp,,false,833,833,XXH128_cmp,,,56,"int XXH128_cmp (void*,void*)"
100669,METHOD,<empty>,<empty>,<empty>,1,,xxhash.h,XXH128_canonical_t:<clinit>,,false,837,,<clinit>,,,2,
100677,METHOD,xxhash.h:<global>,TYPE_DECL,"void XXH128_canonicalFromHash(XXH128_canonical_t* dst, XXH128_hash_t hash);",21,89,xxhash.h,XXH128_canonicalFromHash,,false,838,838,XXH128_canonicalFromHash,,,59,"void XXH128_canonicalFromHash (XXH128_canonical_t*,XXH128_hash_t)"
100683,METHOD,xxhash.h:<global>,TYPE_DECL,XXH128_hash_t XXH128_hashFromCanonical(const XXH128_canonical_t* src);,30,84,xxhash.h,XXH128_hashFromCanonical,,false,839,839,XXH128_hashFromCanonical,,,60,XXH128_hash_t XXH128_hashFromCanonical (XXH128_canonical_t*)
102040,METHOD,<includes>:<global>,NAMESPACE_BLOCK,<global>,,,<includes>,<includes>:<global>,,false,1,,<global>,,,1,
102130,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.assignment,,true,,,<operator>.assignment,,,0,
102135,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memcached.h,memcached.h:89:89:HASHPOWER_DEFAULT:0,,true,89,89,HASHPOWER_DEFAULT,,,0,
102138,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,calloc,,true,,,calloc,,,0,
102143,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,assoc.c,assoc.c:34:34:hashsize:1,,true,34,34,hashsize,,,0,
102147,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.shiftLeft,,true,,,<operator>.shiftLeft,,,0,
102152,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.cast,,true,,,<operator>.cast,,,0,
102157,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.sizeOf,,true,,,<operator>.sizeOf,,,0,
102161,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.logicalNot,,true,,,<operator>.logicalNot,,,0,
102165,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fprintf,,true,,,fprintf,,,0,
102170,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,exit,,true,,,exit,,,0,
102174,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.fieldAccess,,true,,,<operator>.fieldAccess,,,0,
102179,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.multiplication,,true,,,<operator>.multiplication,,,0,
102184,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.logicalAnd,,true,,,<operator>.logicalAnd,,,0,
102189,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.greaterEqualsThan,,true,,,<operator>.greaterEqualsThan,,,0,
102194,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.and,,true,,,<operator>.and,,,0,
102199,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,assoc.c,assoc.c:35:35:hashmask:1,,true,35,35,hashmask,,,0,
102203,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.subtraction,,true,,,<operator>.subtraction,,,0,
102208,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.indirectIndexAccess,,true,,,<operator>.indirectIndexAccess,,,0,
102213,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.equals,,true,,,<operator>.equals,,,0,
102218,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.indirectFieldAccess,,true,,,<operator>.indirectFieldAccess,,,0,
102223,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,memcmp,,true,,,memcmp,,,0,
102229,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memcached.h,memcached.h:133:134:ITEM_key:1,,true,133,134,ITEM_key,,,0,
102233,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.addition,,true,,,<operator>.addition,,,0,
102238,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.addressOf,,true,,,<operator>.addressOf,,,0,
102242,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.conditional,,true,,,<operator>.conditional,,,0,
102248,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.preIncrement,,true,,,<operator>.preIncrement,,,0,
102252,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.indirection,,true,,,<operator>.indirection,,,0,
102256,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.logicalOr,,true,,,<operator>.logicalOr,,,0,
102261,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.notEquals,,true,,,<operator>.notEquals,,,0,
102266,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.greaterThan,,true,,,<operator>.greaterThan,,,0,
102271,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.postIncrement,,true,,,<operator>.postIncrement,,,0,
102275,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.assignmentPlus,,true,,,<operator>.assignmentPlus,,,0,
102280,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_mutex_trylock,,true,,,pthread_mutex_trylock,,,0,
102284,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.division,,true,,,<operator>.division,,,0,
102289,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.lessThan,,true,,,<operator>.lessThan,,,0,
102294,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memcached.h,memcached.h:90:90:HASHPOWER_MAX:0,,true,90,90,HASHPOWER_MAX,,,0,
102297,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_cond_signal,,true,,,pthread_cond_signal,,,0,
102301,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_mutex_unlock,,true,,,pthread_mutex_unlock,,,0,
102305,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,assert,,true,,,assert,,,0,
102309,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,assoc.c,assoc.c:190:190:DEFAULT_HASH_BULK_MOVE:0,,true,190,190,DEFAULT_HASH_BULK_MOVE,,,0,
102312,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memcached.h,memcached.h:934:934:mutex_lock:1,,true,934,934,mutex_lock,,,0,
102315,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_mutex_lock,,true,,,pthread_mutex_lock,,,0,
102319,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,hash,,true,,,hash,,,0,
102324,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,free,,true,,,free,,,0,
102328,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.assignmentMinus,,true,,,<operator>.assignmentMinus,,,0,
102333,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,usleep,,true,,,usleep,,,0,
102337,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_cond_wait,,true,,,pthread_cond_wait,,,0,
102342,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memcached.h,memcached.h:935:935:mutex_unlock:1,,true,935,935,mutex_unlock,,,0,
102345,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getenv,,true,,,getenv,,,0,
102349,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,atoi,,true,,,atoi,,,0,
102353,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_create,,true,,,pthread_create,,,0,
102360,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strerror,,true,,,strerror,,,0,
102364,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.minus,,true,,,<operator>.minus,,,0,
102368,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_join,,true,,,pthread_join,,,0,
102373,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.arrayInitializer,,true,,,<operator>.arrayInitializer,,,0,
102377,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,authfile.c,authfile.c:18:18:MAX_ENTRIES:0,,true,18,18,MAX_ENTRIES,,,0,
102380,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fopen,,true,,,fopen,,,0,
102385,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fstat,,true,,,fstat,,,0,
102390,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fileno,,true,,,fileno,,,0,
102394,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fclose,,true,,,fclose,,,0,
102398,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fgets,,true,,,fgets,,,0,
102404,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,authfile.c,authfile.c:16:16:MAX_ENTRY_LEN:0,,true,16,16,MAX_ENTRY_LEN,,,0,
102407,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,memcpy,,true,,,memcpy,,,0,
102413,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strlen,,true,,,strlen,,,0,
102417,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.arithmeticShiftRight,,true,,,<operator>.arithmeticShiftRight,,,0,
102422,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.or,,true,,,<operator>.or,,,0,
102427,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.modulo,,true,,,<operator>.modulo,,,0,
102432,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.postDecrement,,true,,,<operator>.postDecrement,,,0,
102436,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,malloc,,true,,,malloc,,,0,
102440,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strdup,,true,,,strdup,,,0,
102444,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_mutex_init,,true,,,pthread_mutex_init,,,0,
102449,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,queue.h,queue.h:371:374:STAILQ_INIT:1,,true,371,374,STAILQ_INIT,,,0,
102453,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,queue.h,queue.h:347:347:STAILQ_EMPTY:1,,true,347,347,STAILQ_EMPTY,,,0,
102457,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,queue.h,queue.h:349:349:STAILQ_FIRST:1,,true,349,349,STAILQ_FIRST,,,0,
102461,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,queue.h,queue.h:421:425:STAILQ_REMOVE_HEAD:2,,true,421,425,STAILQ_REMOVE_HEAD,,,0,
102465,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_mutex_destroy,,true,,,pthread_mutex_destroy,,,0,
102469,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,raise,,true,,,raise,,,0,
102473,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.preDecrement,,true,,,<operator>.preDecrement,,,0,
102477,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,queue.h,queue.h:382:386:STAILQ_INSERT_HEAD:3,,true,382,386,STAILQ_INSERT_HEAD,,,0,
102481,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,crawler.c,crawler.c:25:25:LARGEST_ID:0,,true,25,25,LARGEST_ID,,,0,
102484,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,memset,,true,,,memset,,,0,
102490,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memcached.h,memcached.h:113:113:POWER_LARGEST:0,,true,113,113,POWER_LARGEST,,,0,
102493,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memcached.h,memcached.h:553:553:ITEM_FETCHED:0,,true,553,553,ITEM_FETCHED,,,0,
102496,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memcached.h,memcached.h:990:990:refcount_decr:1,,true,990,990,refcount_decr,,,0,
102500,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.lessEqualsThan,,true,,,<operator>.lessEqualsThan,,,0,
102505,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memcached.h,memcached.h:71:71:KEY_MAX_URI_ENCODED_LENGTH:0,,true,71,71,KEY_MAX_URI_ENCODED_LENGTH,,,0,
102508,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,snprintf,,true,,,snprintf,,,0,
102515,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memcached.h,memcached.h:124:125:ITEM_get_cas:1,,true,124,125,ITEM_get_cas,,,0,
102519,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memcached.h,memcached.h:148:148:ITEM_clsid:1,,true,148,148,ITEM_clsid,,,0,
102523,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.not,,true,,,<operator>.not,,,0,
102527,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memcached.h,memcached.h:143:146:ITEM_ntotal:1,,true,143,146,ITEM_ntotal,,,0,
102531,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,crawler.c,crawler.c:110:110:LRU_CRAWLER_WRITEBUF:0,,true,110,110,LRU_CRAWLER_WRITEBUF,,,0,
102534,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,poll,,true,,,poll,,,0,
102540,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,anonymous_type_0.doneclass,,true,,,doneclass,,,0,
102546,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memcached.h,memcached.h:989:989:refcount_incr:1,,true,989,989,refcount_incr,,,0,
102550,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,anonymous_type_1.eval,,true,,,eval,,,0,
102558,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memcached.h,memcached.h:112:112:POWER_SMALLEST:0,,true,112,112,POWER_SMALLEST,,,0,
102561,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,anonymous_type_2.eval,,true,,,eval,,,0,
102569,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,anonymous_type_3.finalize,,true,,,finalize,,,0,
102574,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,crawler.h,crawler.h:4:4:LRU_CRAWLER_CAP_REMAINING:0,,true,4,4,LRU_CRAWLER_CAP_REMAINING,,,0,
102577,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,anonymous_type_4.init,,true,,,init,,,0,
102583,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strcmp,,true,,,strcmp,,,0,
102588,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strtok_r,,true,,,strtok_r,,,0,
102594,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memcached.h,memcached.h:117:117:MAX_NUMBER_OF_SLAB_CLASSES:0,,true,117,117,MAX_NUMBER_OF_SLAB_CLASSES,,,0,
102597,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,items.h,items.h:4:4:TEMP_LRU:0,,true,4,4,TEMP_LRU,,,0,
102600,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,items.h,items.h:1:1:HOT_LRU:0,,true,1,1,HOT_LRU,,,0,
102603,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,items.h,items.h:2:2:WARM_LRU:0,,true,2,2,WARM_LRU,,,0,
102606,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,items.h,items.h:3:3:COLD_LRU:0,,true,3,3,COLD_LRU,,,0,
102609,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.xor,,true,,,<operator>.xor,,,0,
102614,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,crc32c.c,crc32c.c:49:49:POLY:0,,true,49,49,POLY,,,0,
102617,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_once,,true,,,pthread_once,,,0,
102622,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operators>.assignmentXor,,true,,,<operators>.assignmentXor,,,0,
102627,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fork,,true,,,fork,,,0,
102630,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_exit,,true,,,_exit,,,0,
102634,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,setsid,,true,,,setsid,,,0,
102637,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,chdir,,true,,,chdir,,,0,
102641,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,perror,,true,,,perror,,,0,
102645,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,open,,true,,,open,,,0,
102651,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,dup2,,true,,,dup2,,,0,
102656,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,close,,true,,,close,,,0,
102660,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,extstore.c,extstore.c:31:31:STAT_L:1,,true,31,31,STAT_L,,,0,
102664,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,extstore.c,extstore.c:32:32:STAT_UL:1,,true,32,32,STAT_UL,,,0,
102668,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fcntl,,true,,,fcntl,,,0,
102674,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ftruncate,,true,,,ftruncate,,,0,
102679,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_cond_init,,true,,,pthread_cond_init,,,0,
102684,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,extstore.c,extstore.c:33:37:STAT_INCR:3,,true,33,37,STAT_INCR,,,0,
102689,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lseek,,true,,,lseek,,,0,
102695,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,read,,true,,,read,,,0,
102701,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,readv,,true,,,readv,,,0,
102707,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pwrite,,true,,,pwrite,,,0,
102714,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_obj_io.cb,,true,,,cb,,,0,
102721,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,xxhash.h,xxhash.h:235:235:XXH3_64bits:0,,true,235,235,XXH3_64bits,,,0,
102724,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,XXH_INLINE_XXH3_64bits,,true,,,XXH_INLINE_XXH3_64bits,,,0,
102729,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,items.c,items.c:30:30:LARGEST_ID:0,,true,30,30,LARGEST_ID,,,0,
102732,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,items.h,items.h:38:38:LRU_PULL_EVICT:0,,true,38,38,LRU_PULL_EVICT,,,0,
102735,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operators>.assignmentOr,,true,,,<operators>.assignmentOr,,,0,
102740,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memcached.h,memcached.h:558:558:ITEM_CHUNK:0,,true,558,558,ITEM_CHUNK,,,0,
102743,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memcached.h,memcached.h:557:557:ITEM_CHUNKED:0,,true,557,557,ITEM_CHUNKED,,,0,
102746,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,items.c,items.c:151:151:DEBUG_REFCNT:2,,true,151,151,DEBUG_REFCNT,,,0,
102749,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memcached.h,memcached.h:547:547:ITEM_CAS:0,,true,547,547,ITEM_CAS,,,0,
102752,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memcached.h,memcached.h:562:562:ITEM_CFLAGS:0,,true,562,562,ITEM_CFLAGS,,,0,
102755,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memcached.h,memcached.h:136:137:ITEM_suffix:1,,true,136,137,ITEM_suffix,,,0,
102759,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memcached.h,memcached.h:649:651:ITEM_schunk:1,,true,649,651,ITEM_schunk,,,0,
102763,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memcached.h,memcached.h:546:546:ITEM_LINKED:0,,true,546,546,ITEM_LINKED,,,0,
102766,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memcached.h,memcached.h:550:550:ITEM_SLABBED:0,,true,550,550,ITEM_SLABBED,,,0,
102769,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memcached.h,memcached.h:127:131:ITEM_set_cas:2,,true,127,131,ITEM_set_cas,,,0,
102774,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operators>.assignmentAnd,,true,,,<operators>.assignmentAnd,,,0,
102779,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memcached.h,memcached.h:149:149:ITEM_lruid:1,,true,149,149,ITEM_lruid,,,0,
102783,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memcached.h,memcached.h:555:555:ITEM_ACTIVE:0,,true,555,555,ITEM_ACTIVE,,,0,
102786,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memcached.h,memcached.h:97:97:ITEM_UPDATE_INTERVAL:0,,true,97,97,ITEM_UPDATE_INTERVAL,,,0,
102789,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memcached.h,memcached.h:68:68:KEY_MAX_LENGTH:0,,true,68,68,KEY_MAX_LENGTH,,,0,
102792,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memcached.h,memcached.h:570:570:ITEM_KEY_BINARY:0,,true,570,570,ITEM_KEY_BINARY,,,0,
102795,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strncpy,,true,,,strncpy,,,0,
102801,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memcached.h,memcached.h:155:156:APPEND_STAT:3,,true,155,156,APPEND_STAT,,,0,
102806,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memcached.h,memcached.h:160:163:APPEND_NUM_FMT_STAT:5,,true,160,163,APPEND_NUM_FMT_STAT,,,0,
102812,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,add_stats,,true,,,add_stats,,,0,
102820,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,logger.h,logger.h:207:214:LOGGER_LOG:4,,true,207,214,LOGGER_LOG,,,0,
102825,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_getspecific,,true,,,pthread_getspecific,,,0,
102829,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memcached.h,memcached.h:972:972:DO_UPDATE:0,,true,972,972,DO_UPDATE,,,0,
102832,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.expressionList,,true,,,<operator>.expressionList,,,0,
102837,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,items.h,items.h:39:39:LRU_PULL_CRAWL_BLOCKS:0,,true,39,39,LRU_PULL_CRAWL_BLOCKS,,,0,
102840,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,items.h,items.h:40:40:LRU_PULL_RETURN_ITEM:0,,true,40,40,LRU_PULL_RETURN_ITEM,,,0,
102843,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,items.c,items.c:105:105:LRU_BUMP_BUF_SIZE:0,,true,105,105,LRU_BUMP_BUF_SIZE,,,0,
102846,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,items.c,items.c:1461:1461:MAX_MAINTCRAWL_WAIT:0,,true,1461,1461,MAX_MAINTCRAWL_WAIT,,,0,
102849,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,items.h,items.h:7:7:GET_LRU:1,,true,7,7,GET_LRU,,,0,
102853,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,items.c,items.c:1583:1583:MIN_LRU_MAINTAINER_SLEEP:0,,true,1583,1583,MIN_LRU_MAINTAINER_SLEEP,,,0,
102856,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,abort,,true,,,abort,,,0,
102859,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,anonymous_type_0.init,,true,,,init,,,0,
102864,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,items.c,items.c:1582:1582:MAX_LRU_MAINTAINER_SLEEP:0,,true,1582,1582,MAX_LRU_MAINTAINER_SLEEP,,,0,
102867,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.assignmentDivision,,true,,,<operator>.assignmentDivision,,,0,
102872,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,anonymous_type_1.free,,true,,,free,,,0,
102877,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,anonymous_type_2.init,,true,,,init,,,0,
102882,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,anonymous_type_3.run,,true,,,run,,,0,
102889,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,anonymous_type_4.free,,true,,,free,,,0,
102894,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,write,,true,,,write,,,0,
102900,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vsnprintf,,true,,,vsnprintf,,,0,
102907,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,va_arg,,true,,,va_arg,,,0,
102912,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,inet_ntop,,true,,,inet_ntop,,,0,
102919,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ntohs,,true,,,ntohs,,,0,
102923,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,logger.c,logger.c:193:193:LOGGER_PARSE_SCRATCH:0,,true,193,193,LOGGER_PARSE_SCRATCH,,,0,
102926,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,logger.h,logger.h:154:154:LOG_RAWCMDS:0,,true,154,154,LOG_RAWCMDS,,,0,
102929,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,logger.h,logger.h:152:152:LOG_EVICTIONS:0,,true,152,152,LOG_EVICTIONS,,,0,
102932,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,logger.h,logger.h:148:148:LOG_FETCHERS:0,,true,148,148,LOG_FETCHERS,,,0,
102935,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,logger.h,logger.h:149:149:LOG_MUTATIONS:0,,true,149,149,LOG_MUTATIONS,,,0,
102938,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,logger.h,logger.h:147:147:LOG_SYSEVENTS:0,,true,147,147,LOG_SYSEVENTS,,,0,
102941,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,logger.h,logger.h:151:151:LOG_CONNEVENTS:0,,true,151,151,LOG_CONNEVENTS,,,0,
102944,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,logger.c,logger.c:44:44:WATCHER_LIMIT:0,,true,44,44,WATCHER_LIMIT,,,0,
102947,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_entry_details.parse_cb,,true,,,parse_cb,,,0,
102953,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,logger.c,logger.c:49:49:WATCHER_ALL:0,,true,49,49,WATCHER_ALL,,,0,
102956,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fwrite,,true,,,fwrite,,,0,
102963,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,logger.c,logger.c:763:763:MIN_LOGGER_SLEEP:0,,true,763,763,MIN_LOGGER_SLEEP,,,0,
102966,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,logger.c,logger.c:762:762:MAX_LOGGER_SLEEP:0,,true,762,762,MAX_LOGGER_SLEEP,,,0,
102969,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_key_create,,true,,,pthread_key_create,,,0,
102974,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_setspecific,,true,,,pthread_setspecific,,,0,
102979,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,gettimeofday,,true,,,gettimeofday,,,0,
102984,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,va_start,,true,,,va_start,,,0,
102989,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_entry_details.log_cb,,true,,,log_cb,,,0,
102997,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,va_end,,true,,,va_end,,,0,
103001,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,md5.c,md5.c:203:205:SET:7,,true,203,205,SET,,,0,
103009,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,md5.c,md5.c:229:231:SET:7,,true,229,231,SET,,,0,
103017,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,md5.c,md5.c:255:257:SET:7,,true,255,257,SET,,,0,
103025,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,md5.c,md5.c:281:283:SET:7,,true,281,283,SET,,,0,
103033,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,md5.c,md5.c:64:64:T_MASK:0,,true,64,64,T_MASK,,,0,
103036,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sendmsg,,true,,,sendmsg,,,0,
103042,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,evtimer_set,,true,,,evtimer_set,,,0,
103048,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,event_base_set,,true,,,event_base_set,,,0,
103053,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,evtimer_add,,true,,,evtimer_add,,,0,
103058,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,evtimer_del,,true,,,evtimer_del,,,0,
103062,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memcached.h,memcached.h:1008:1008:REALTIME_MAXDELTA:0,,true,1008,1008,REALTIME_MAXDELTA,,,0,
103065,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,time,,true,,,time,,,0,
103069,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memcached.h,memcached.h:121:121:TAIL_REPAIR_TIME_DEFAULT:0,,true,121,121,TAIL_REPAIR_TIME_DEFAULT,,,0,
103072,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,logger.h,logger.h:9:9:LOGGER_WATCHER_BUF_SIZE:0,,true,9,9,LOGGER_WATCHER_BUF_SIZE,,,0,
103075,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,logger.h,logger.h:8:8:LOGGER_BUF_SIZE:0,,true,8,8,LOGGER_BUF_SIZE,,,0,
103078,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memcached.c,memcached.c:308:308:CONNS_PER_SLICE:0,,true,308,308,CONNS_PER_SLICE,,,0,
103081,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memcached.h,memcached.h:266:266:IS_TCP:1,,true,266,266,IS_TCP,,,0,
103085,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_cond_timedwait,,true,,,pthread_cond_timedwait,,,0,
103091,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memcached.h,memcached.h:267:267:IS_UDP:1,,true,267,267,IS_UDP,,,0,
103095,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memcached.h,memcached.h:993:993:THR_STATS_LOCK:1,,true,993,993,THR_STATS_LOCK,,,0,
103099,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memcached.h,memcached.h:994:994:THR_STATS_UNLOCK:1,,true,994,994,THR_STATS_UNLOCK,,,0,
103103,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memcached.h,memcached.h:77:77:READ_BUFFER_SIZE:0,,true,77,77,READ_BUFFER_SIZE,,,0,
103106,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,dup,,true,,,dup,,,0,
103110,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getrlimit,,true,,,getrlimit,,,0,
103115,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,event_set,,true,,,event_set,,,0,
103123,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,event_add,,true,,,event_add,,,0,
103128,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memcached.h,memcached.h:664:664:IO_QUEUE_NONE:0,,true,664,664,IO_QUEUE_NONE,,,0,
103131,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,io_queue_cb_s.complete_cb,,true,,,complete_cb,,,0,
103136,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,io_queue_cb_s.return_cb,,true,,,return_cb,,,0,
103141,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getpeername,,true,,,getpeername,,,0,
103147,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sasl_defs.h,sasl_defs.h:19:19:sasl_dispose:1,,true,19,19,sasl_dispose,,,0,
103150,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,event_del,,true,,,event_del,,,0,
103154,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memcached.h,memcached.h:742:742:MC_RESP_IOVCOUNT:0,,true,742,742,MC_RESP_IOVCOUNT,,,0,
103157,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memcached.h,memcached.h:772:772:MAX_RESP_PER_BUNDLE:0,,true,772,772,MAX_RESP_PER_BUNDLE,,,0,
103160,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,io_queue_cb_s.finalize_cb,,true,,,finalize_cb,,,0,
103165,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memcached.h,memcached.h:76:76:WRITE_BUFFER_SIZE:0,,true,76,76,WRITE_BUFFER_SIZE,,,0,
103168,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strncmp,,true,,,strncmp,,,0,
103174,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,htons,,true,,,htons,,,0,
103178,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,htonl,,true,,,htonl,,,0,
103182,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,realloc,,true,,,realloc,,,0,
103187,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memcached.h,memcached.h:139:141:ITEM_data:1,,true,139,141,ITEM_data,,,0,
103191,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memcached.h,memcached.h:272:272:NREAD_APPEND:0,,true,272,272,NREAD_APPEND,,,0,
103194,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memcached.h,memcached.h:973:973:DONT_UPDATE:0,,true,973,973,DONT_UPDATE,,,0,
103197,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memcached.h,memcached.h:269:269:NREAD_ADD:0,,true,269,269,NREAD_ADD,,,0,
103200,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memcached.h,memcached.h:274:274:NREAD_CAS:0,,true,274,274,NREAD_CAS,,,0,
103203,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memcached.h,memcached.h:568:568:ITEM_STALE:0,,true,568,568,ITEM_STALE,,,0,
103206,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memcached.h,memcached.h:564:564:ITEM_TOKEN_SENT:0,,true,564,564,ITEM_TOKEN_SENT,,,0,
103209,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memcached.h,memcached.h:273:273:NREAD_PREPEND:0,,true,273,273,NREAD_PREPEND,,,0,
103212,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memcached.h,memcached.h:170:176:FLAGS_CONV:2,,true,170,176,FLAGS_CONV,,,0,
103217,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memcached.h,memcached.h:271:271:NREAD_REPLACE:0,,true,271,271,NREAD_REPLACE,,,0,
103220,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memcached.h,memcached.h:270:270:NREAD_SET:0,,true,270,270,NREAD_SET,,,0,
103223,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getpid,,true,,,getpid,,,0,
103226,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getrusage,,true,,,getrusage,,,0,
103231,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,event_get_version,,true,,,event_get_version,,,0,
103234,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strncat,,true,,,strncat,,,0,
103240,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getsockname,,true,,,getsockname,,,0,
103246,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memcached.h,memcached.h:166:167:APPEND_NUM_STAT:4,,true,166,167,APPEND_NUM_STAT,,,0,
103251,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memcached.c,memcached.c:2187:2187:IT_REFCOUNT_LIMIT:0,,true,2187,2187,IT_REFCOUNT_LIMIT,,,0,
103254,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,recvfrom,,true,,,recvfrom,,,0,
103263,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,memmove,,true,,,memmove,,,0,
103269,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.assignmentMultiplication,,true,,,<operator>.assignmentMultiplication,,,0,
103274,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,listen,,true,,,listen,,,0,
103279,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memcached.c,memcached.c:2556:2556:TRANSMIT_ALL_RESP:0,,true,2556,2556,TRANSMIT_ALL_RESP,,,0,
103282,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memcached.h,memcached.h:82:82:UDP_DATA_SIZE:0,,true,82,82,UDP_DATA_SIZE,,,0,
103285,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memcached.h,memcached.h:81:81:UDP_HEADER_SIZE:0,,true,81,81,UDP_HEADER_SIZE,,,0,
103288,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memcached.c,memcached.c:2555:2555:TRANSMIT_ONE_RESP:0,,true,2555,2555,TRANSMIT_ONE_RESP,,,0,
103291,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memcached.h,memcached.h:80:80:UDP_MAX_PAYLOAD_SIZE:0,,true,80,80,UDP_MAX_PAYLOAD_SIZE,,,0,
103294,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,accept,,true,,,accept,,,0,
103300,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memcached.h,memcached.h:78:78:READ_BUFFER_CACHED:0,,true,78,78,READ_BUFFER_CACHED,,,0,
103303,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,io_queue_cb_s.submit_cb,,true,,,submit_cb,,,0,
103308,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,socket,,true,,,socket,,,0,
103314,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getsockopt,,true,,,getsockopt,,,0,
103322,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memcached.h,memcached.h:83:83:MAX_SENDBUF_SIZE:0,,true,83,83,MAX_SENDBUF_SIZE,,,0,
103325,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,setsockopt,,true,,,setsockopt,,,0,
103333,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getaddrinfo,,true,,,getaddrinfo,,,0,
103340,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,gai_strerror,,true,,,gai_strerror,,,0,
103344,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memcached.h,memcached.h:64:64:SO_INCOMING_NAPI_ID:0,,true,64,64,SO_INCOMING_NAPI_ID,,,0,
103347,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,bind,,true,,,bind,,,0,
103353,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,freeaddrinfo,,true,,,freeaddrinfo,,,0,
103357,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memcached.h,memcached.h:79:79:UDP_READ_BUFFER_SIZE:0,,true,79,79,UDP_READ_BUFFER_SIZE,,,0,
103360,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strchr,,true,,,strchr,,,0,
103365,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lstat,,true,,,lstat,,,0,
103370,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,S_ISSOCK,,true,,,S_ISSOCK,,,0,
103374,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,unlink,,true,,,unlink,,,0,
103378,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,umask,,true,,,umask,,,0,
103382,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,printf,,true,,,printf,,,0,
103387,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memcached.h,memcached.h:102:102:ITEM_SIZE_MAX_LOWER_LIMIT:0,,true,102,102,ITEM_SIZE_MAX_LOWER_LIMIT,,,0,
103390,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memcached.h,memcached.h:103:103:ITEM_SIZE_MAX_UPPER_LIMIT:0,,true,103,103,ITEM_SIZE_MAX_UPPER_LIMIT,,,0,
103393,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,access,,true,,,access,,,0,
103398,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,kill,,true,,,kill,,,0,
103403,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,rename,,true,,,rename,,,0,
103408,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strsignal,,true,,,strsignal,,,0,
103412,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memcached.h,memcached.h:115:115:CHUNK_ALIGN_BYTES:0,,true,115,115,CHUNK_ALIGN_BYTES,,,0,
103415,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memcached.c,memcached.c:4546:4546:RESTART_REQUIRED_META:0,,true,4546,4546,RESTART_REQUIRED_META,,,0,
103418,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,signal,,true,,,signal,,,0,
103423,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,setbuf,,true,,,setbuf,,,0,
103428,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getopt,,true,,,getopt,,,0,
103434,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strtol,,true,,,strtol,,,0,
103440,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strstr,,true,,,strstr,,,0,
103445,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,atof,,true,,,atof,,,0,
103449,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getsubopt,,true,,,getsubopt,,,0,
103455,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,setrlimit,,true,,,setrlimit,,,0,
103460,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getuid,,true,,,getuid,,,0,
103463,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,geteuid,,true,,,geteuid,,,0,
103466,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getpwnam,,true,,,getpwnam,,,0,
103470,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,setgroups,,true,,,setgroups,,,0,
103475,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,setgid,,true,,,setgid,,,0,
103479,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,setuid,,true,,,setuid,,,0,
103483,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sasl_defs.h,sasl_defs.h:18:18:init_sasl:0,,true,18,18,init_sasl,,,0,
103486,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,event_init,,true,,,event_init,,,0,
103489,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,event_base_loop,,true,,,event_base_loop,,,0,
103494,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,event_base_free,,true,,,event_base_free,,,0,
103498,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memcached.h,memcached.h:662:662:IO_QUEUE_COUNT:0,,true,662,662,IO_QUEUE_COUNT,,,0,
103501,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,murmur3_hash.c,murmur3_hash.c:38:38:ROTL32:2,,true,38,38,ROTL32,,,0,
103506,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ntohl,,true,,,ntohl,,,0,
103510,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memcached.h,memcached.h:86:86:BIN_MAX_EXTLEN:0,,true,86,86,BIN_MAX_EXTLEN,,,0,
103513,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strtoull,,true,,,strtoull,,,0,
103519,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memcached.h,memcached.h:74:74:INCR_MAX_STORAGE_LEN:0,,true,74,74,INCR_MAX_STORAGE_LEN,,,0,
103522,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fputc,,true,,,fputc,,,0,
103527,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sasl_defs.h,sasl_defs.h:20:20:sasl_server_new:8,,true,20,20,sasl_server_new,,,0,
103530,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sasl_defs.h,sasl_defs.h:26:26:SASL_OK:0,,true,26,26,SASL_OK,,,0,
103533,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sasl_defs.h,sasl_defs.h:21:21:sasl_listmech:8,,true,21,21,sasl_listmech,,,0,
103536,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sasl_defs.h,sasl_defs.h:5:5:MAX_SASL_MECH_LEN:0,,true,5,5,MAX_SASL_MECH_LEN,,,0,
103539,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sasl_defs.h,sasl_defs.h:22:22:sasl_server_start:6,,true,22,22,sasl_server_start,,,0,
103542,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sasl_defs.h,sasl_defs.h:27:27:SASL_CONTINUE:0,,true,27,27,SASL_CONTINUE,,,0,
103545,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sasl_defs.h,sasl_defs.h:23:23:sasl_server_step:5,,true,23,23,sasl_server_step,,,0,
103548,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,proxy.h,proxy.h:55:55:STAT_L:1,,true,55,55,STAT_L,,,0,
103552,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,proxy.h,proxy.h:56:56:STAT_UL:1,,true,56,56,STAT_UL,,,0,
103556,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,proxy.h,proxy.h:43:43:WSTAT_L:1,,true,43,43,WSTAT_L,,,0,
103560,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,proxy.h,proxy.h:44:44:WSTAT_UL:1,,true,44,44,WSTAT_UL,,,0,
103564,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memcached.h,memcached.h:151:151:STAT_KEY_LEN:0,,true,151,151,STAT_KEY_LEN,,,0,
103567,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,luaL_newstate,,true,,,luaL_newstate,,,0,
103570,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,luaL_openlibs,,true,,,luaL_openlibs,,,0,
103574,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pipe,,true,,,pipe,,,0,
103578,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,rand,,true,,,rand,,,0,
103581,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,queue.h,queue.h:388:392:STAILQ_INSERT_TAIL:3,,true,388,392,STAILQ_INSERT_TAIL,,,0,
103586,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,queue.h,queue.h:339:345:STAILQ_CONCAT:2,,true,339,345,STAILQ_CONCAT,,,0,
103591,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_rotate,,true,,,lua_rotate,,,0,
103597,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_settop,,true,,,lua_settop,,,0,
103602,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,luaL_unref,,true,,,luaL_unref,,,0,
103608,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,memchr,,true,,,memchr,,,0,
103614,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,proto_proxy.c,proto_proxy.c:14:14:PROCESS_NORMAL:0,,true,14,14,PROCESS_NORMAL,,,0,
103617,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,proxy.h,proxy.h:50:54:WSTAT_DECR:3,,true,50,54,WSTAT_DECR,,,0,
103622,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_rawgeti,,true,,,lua_rawgeti,,,0,
103628,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_tothread,,true,,,lua_tothread,,,0,
103633,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,luaL_checkudata,,true,,,luaL_checkudata,,,0,
103639,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_pushstring,,true,,,lua_pushstring,,,0,
103644,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_error,,true,,,lua_error,,,0,
103648,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_pushfstring,,true,,,lua_pushfstring,,,0,
103654,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,vendor\mcmc\mcmc.h,vendor\mcmc\mcmc.h:4:4:MCMC_OK:0,,true,4,4,MCMC_OK,,,0,
103657,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,vendor\mcmc\mcmc.h,vendor\mcmc\mcmc.h:26:26:MCMC_CODE_MISS:0,,true,26,26,MCMC_CODE_MISS,,,0,
103660,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,vendor\mcmc\mcmc.h,vendor\mcmc\mcmc.h:22:22:MCMC_CODE_OK:0,,true,22,22,MCMC_CODE_OK,,,0,
103663,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_resume,,true,,,lua_resume,,,0,
103670,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_type,,true,,,lua_type,,,0,
103675,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_getiuservalue,,true,,,lua_getiuservalue,,,0,
103681,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_tolstring,,true,,,lua_tolstring,,,0,
103687,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_pop,,true,,,lua_pop,,,0,
103692,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,luaL_ref,,true,,,luaL_ref,,,0,
103697,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_tostring,,true,,,lua_tostring,,,0,
103702,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,proxy.h,proxy.h:45:49:WSTAT_INCR:3,,true,45,49,WSTAT_INCR,,,0,
103707,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,proto_proxy.c,proto_proxy.c:13:13:PROCESS_MULTIGET:0,,true,13,13,PROCESS_MULTIGET,,,0,
103710,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,proxy.h,proxy.h:75:75:ENDSTR:0,,true,75,75,ENDSTR,,,0,
103713,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,proxy.h,proxy.h:76:76:ENDLEN:0,,true,76,76,ENDLEN,,,0,
103716,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,proxy.h,proxy.h:73:73:MCP_REQUEST_MAXLEN:0,,true,73,73,MCP_REQUEST_MAXLEN,,,0,
103719,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_newthread,,true,,,lua_newthread,,,0,
103723,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memcached.h,memcached.h:666:666:IO_QUEUE_PROXY:0,,true,666,666,IO_QUEUE_PROXY,,,0,
103726,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_newuserdatauv,,true,,,lua_newuserdatauv,,,0,
103732,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,luaL_getmetatable,,true,,,luaL_getmetatable,,,0,
103737,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_setmetatable,,true,,,lua_setmetatable,,,0,
103742,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,proxy.h,proxy.h:298:298:MAX_NAMELEN:0,,true,298,298,MAX_NAMELEN,,,0,
103745,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,proxy.h,proxy.h:299:299:MAX_PORTLEN:0,,true,299,299,MAX_PORTLEN,,,0,
103748,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_gettop,,true,,,lua_gettop,,,0,
103752,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_getmetatable,,true,,,lua_getmetatable,,,0,
103757,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_rawget,,true,,,lua_rawget,,,0,
103762,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_typename,,true,,,lua_typename,,,0,
103767,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,proto_text.c,proto_text.c:21:24:META_SPACE:1,,true,21,24,META_SPACE,,,0,
103771,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,proto_text.c,proto_text.c:36:47:META_KEY:4,,true,36,47,META_KEY,,,0,
103778,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,proto_text.c,proto_text.c:26:30:META_CHAR:2,,true,26,30,META_CHAR,,,0,
103783,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,proto_text.c,proto_text.c:240:240:MAX_TOKENS:0,,true,240,240,MAX_TOKENS,,,0,
103786,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memcached.h,memcached.h:178:178:FLAGS_SIZE:1,,true,178,178,FLAGS_SIZE,,,0,
103790,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,proto_text.c,proto_text.c:238:238:KEY_TOKEN:0,,true,238,238,KEY_TOKEN,,,0,
103793,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memcached.h,memcached.h:1012:1013:EXPTIME_TO_POSITIVE_TIME:1,,true,1012,1013,EXPTIME_TO_POSITIVE_TIME,,,0,
103797,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,proto_text.c,proto_text.c:237:237:SUBCOMMAND_TOKEN:0,,true,237,237,SUBCOMMAND_TOKEN,,,0,
103800,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,proto_text.c,proto_text.c:258:264:WANT_TOKENS_MIN:2,,true,258,264,WANT_TOKENS_MIN,,,0,
103805,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,proto_text.c,proto_text.c:892:892:MFLAG_MAX_OPT_LENGTH:0,,true,892,892,MFLAG_MAX_OPT_LENGTH,,,0,
103808,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,proto_text.c,proto_text.c:893:893:MFLAG_MAX_OPAQUE_LENGTH:0,,true,893,893,MFLAG_MAX_OPAQUE_LENGTH,,,0,
103811,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memcached.h,memcached.h:430:430:MAX_VERBOSITY_LEVEL:0,,true,430,430,MAX_VERBOSITY_LEVEL,,,0,
103814,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,proto_text.c,proto_text.c:236:236:COMMAND_TOKEN:0,,true,236,236,COMMAND_TOKEN,,,0,
103817,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,logger.h,logger.h:155:155:LOG_PROXYREQS:0,,true,155,155,LOG_PROXYREQS,,,0,
103820,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,logger.h,logger.h:156:156:LOG_PROXYEVENTS:0,,true,156,156,LOG_PROXYEVENTS,,,0,
103823,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,logger.h,logger.h:157:157:LOG_PROXYUSER:0,,true,157,157,LOG_PROXYUSER,,,0,
103826,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,crawler.h,crawler.h:32:32:CRAWLER_NOWAIT:0,,true,32,32,CRAWLER_NOWAIT,,,0,
103829,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,proto_text.c,proto_text.c:250:256:WANT_TOKENS_OR:3,,true,250,256,WANT_TOKENS_OR,,,0,
103835,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,proto_text.c,proto_text.c:242:248:WANT_TOKENS:3,,true,242,248,WANT_TOKENS,,,0,
103841,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,proxy.h,proxy.h:257:257:PARSER_MAX_TOKENS:0,,true,257,257,PARSER_MAX_TOKENS,,,0,
103844,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,proxy.h,proxy.h:306:306:BE_IOV_MAX:0,,true,306,306,BE_IOV_MAX,,,0,
103847,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,proxy.h,proxy.h:414:414:KEY_HASH_FILTER_MAX:0,,true,414,414,KEY_HASH_FILTER_MAX,,,0,
103850,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,luaL_checktype,,true,,,luaL_checktype,,,0,
103856,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_pushnil,,true,,,lua_pushnil,,,0,
103860,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_next,,true,,,lua_next,,,0,
103865,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_isnumber,,true,,,lua_isnumber,,,0,
103870,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_tointeger,,true,,,lua_tointeger,,,0,
103875,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_yield,,true,,,lua_yield,,,0,
103880,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_touserdata,,true,,,lua_touserdata,,,0,
103885,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_newtable,,true,,,lua_newtable,,,0,
103889,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,proxy.h,proxy.h:284:284:MCP_PARSER_KEY:1,,true,284,284,MCP_PARSER_KEY,,,0,
103893,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,luaL_testudata,,true,,,luaL_testudata,,,0,
103899,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_rawseti,,true,,,lua_rawseti,,,0,
103905,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_rawlen,,true,,,lua_rawlen,,,0,
103910,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,queue.h,queue.h:351:354:STAILQ_FOREACH:3,,true,351,354,STAILQ_FOREACH,,,0,
103915,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,proxy.h,proxy.h:57:61:STAT_INCR:3,,true,57,61,STAT_INCR,,,0,
103920,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,proxy_reload_notify,,true,,,proxy_reload_notify,,,0,
103924,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,luaL_loadfile,,true,,,luaL_loadfile,,,0,
103929,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_dump,,true,,,lua_dump,,,0,
103936,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_pcall,,true,,,lua_pcall,,,0,
103943,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_getglobal,,true,,,lua_getglobal,,,0,
103948,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_isnil,,true,,,lua_isnil,,,0,
103953,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,luaL_setmetatable,,true,,,luaL_setmetatable,,,0,
103958,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,luaL_checkstack,,true,,,luaL_checkstack,,,0,
103964,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_isinteger,,true,,,lua_isinteger,,,0,
103969,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_pushinteger,,true,,,lua_pushinteger,,,0,
103974,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_pushnumber,,true,,,lua_pushnumber,,,0,
103979,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_tonumber,,true,,,lua_tonumber,,,0,
103984,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_pushlstring,,true,,,lua_pushlstring,,,0,
103990,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_pushboolean,,true,,,lua_pushboolean,,,0,
103995,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_toboolean,,true,,,lua_toboolean,,,0,
104000,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_absindex,,true,,,lua_absindex,,,0,
104005,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_settable,,true,,,lua_settable,,,0,
104010,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_load,,true,,,lua_load,,,0,
104018,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_pushlightuserdata,,true,,,lua_pushlightuserdata,,,0,
104023,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,luaL_newlib,,true,,,luaL_newlib,,,0,
104028,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,proxy.h,proxy.h:63:67:STAT_DECR:3,,true,63,67,STAT_DECR,,,0,
104033,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,luaL_checkstring,,true,,,luaL_checkstring,,,0,
104038,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,luaL_checklstring,,true,,,luaL_checklstring,,,0,
104044,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_pushvalue,,true,,,lua_pushvalue,,,0,
104049,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_gettable,,true,,,lua_gettable,,,0,
104054,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_upvalueindex,,true,,,lua_upvalueindex,,,0,
104058,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,proxy.h,proxy.h:80:80:MCP_BACKEND_UPVALUE:0,,true,80,80,MCP_BACKEND_UPVALUE,,,0,
104061,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,vendor\mcmc\mcmc.h,vendor\mcmc\mcmc.h:38:38:MCMC_OPTION_BLANK:0,,true,38,38,MCMC_OPTION_BLANK,,,0,
104064,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,vendor\mcmc\mcmc.h,vendor\mcmc\mcmc.h:39:39:MCMC_OPTION_NONBLOCK:0,,true,39,39,MCMC_OPTION_NONBLOCK,,,0,
104067,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,vendor\mcmc\mcmc.h,vendor\mcmc\mcmc.h:40:40:MCMC_OPTION_TCP_KEEPALIVE:0,,true,40,40,MCMC_OPTION_TCP_KEEPALIVE,,,0,
104070,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,vendor\mcmc\mcmc.h,vendor\mcmc\mcmc.h:7:7:MCMC_CONNECTED:0,,true,7,7,MCMC_CONNECTED,,,0,
104073,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,vendor\mcmc\mcmc.h,vendor\mcmc\mcmc.h:8:8:MCMC_CONNECTING:0,,true,8,8,MCMC_CONNECTING,,,0,
104076,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_getfield,,true,,,lua_getfield,,,0,
104082,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_createtable,,true,,,lua_createtable,,,0,
104088,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_setfield,,true,,,lua_setfield,,,0,
104094,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,luaL_len,,true,,,luaL_len,,,0,
104099,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,xxhash.h,xxhash.h:237:237:XXH3_64bits_withSeed:0,,true,237,237,XXH3_64bits_withSeed,,,0,
104102,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_geti,,true,,,lua_geti,,,0,
104108,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,mcp_pool_s.key_filter,,true,,,key_filter,,,0,
104116,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,mcp_pool_s.key_hasher,,true,,,key_hasher,,,0,
104123,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,proxy_hash_caller.selector_func,,true,,,selector_func,,,0,
104129,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,luaL_checkinteger,,true,,,luaL_checkinteger,,,0,
104134,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,luaL_checknumber,,true,,,luaL_checknumber,,,0,
104139,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,proxy_lua.c,proxy_lua.c:545:545:MICROSECONDS:1,,true,545,545,MICROSECONDS,,,0,
104143,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,proxy.h,proxy.h:78:78:MCP_THREAD_UPVALUE:0,,true,78,78,MCP_THREAD_UPVALUE,,,0,
104146,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_isfunction,,true,,,lua_isfunction,,,0,
104151,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_isstring,,true,,,lua_isstring,,,0,
104156,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,luaL_optlstring,,true,,,luaL_optlstring,,,0,
104163,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,proxy_lua.c,proxy_lua.c:843:845:X:1,,true,843,845,X,,,0,
104167,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,proxy.h,proxy.h:83:117:CMD_FIELDS:0,,true,83,117,CMD_FIELDS,,,0,
104170,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,luaL_newmetatable,,true,,,luaL_newmetatable,,,0,
104175,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,luaL_setfuncs,,true,,,luaL_setfuncs,,,0,
104181,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,luaL_newlibtable,,true,,,luaL_newlibtable,,,0,
104186,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_setglobal,,true,,,lua_setglobal,,,0,
104191,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,vendor\mcmc\mcmc.h,vendor\mcmc\mcmc.h:5:5:MCMC_ERR:0,,true,5,5,MCMC_ERR,,,0,
104194,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,event_initialized,,true,,,event_initialized,,,0,
104198,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,event_pending,,true,,,event_pending,,,0,
104204,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,event_assign,,true,,,event_assign,,,0,
104213,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,vendor\mcmc\mcmc.h,vendor\mcmc\mcmc.h:10:10:MCMC_WANT_READ:0,,true,10,10,MCMC_WANT_READ,,,0,
104216,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,vendor\mcmc\mcmc.h,vendor\mcmc\mcmc.h:30:30:MCMC_RESP_GET:0,,true,30,30,MCMC_RESP_GET,,,0,
104219,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,vendor\mcmc\mcmc.h,vendor\mcmc\mcmc.h:34:34:MCMC_RESP_END:0,,true,34,34,MCMC_RESP_END,,,0,
104222,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,vendor\mcmc\mcmc.h,vendor\mcmc\mcmc.h:31:31:MCMC_RESP_META:0,,true,31,31,MCMC_RESP_META,,,0,
104225,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,vendor\mcmc\mcmc.h,vendor\mcmc\mcmc.h:33:33:MCMC_RESP_GENERIC:0,,true,33,33,MCMC_RESP_GENERIC,,,0,
104228,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,vendor\mcmc\mcmc.h,vendor\mcmc\mcmc.h:36:36:MCMC_RESP_NUMERIC:0,,true,36,36,MCMC_RESP_NUMERIC,,,0,
104231,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,writev,,true,,,writev,,,0,
104237,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,recv,,true,,,recv,,,0,
104244,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,event_config_new,,true,,,event_config_new,,,0,
104247,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,event_config_set_flag,,true,,,event_config_set_flag,,,0,
104252,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,event_base_new_with_config,,true,,,event_base_new_with_config,,,0,
104256,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,event_config_free,,true,,,event_config_free,,,0,
104260,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,proxy_request.c,proxy_request.c:5:5:PARSER_MAXLEN:0,,true,5,5,PARSER_MAXLEN,,,0,
104263,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,proxy_request.c,proxy_request.c:226:226:NOREPLYLEN:0,,true,226,226,NOREPLYLEN,,,0,
104266,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,proxy_request.c,proxy_request.c:225:225:NOREPLYSTR:0,,true,225,225,NOREPLYSTR,,,0,
104269,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,proxy_ring_hash.c,proxy_ring_hash.c:35:35:DEFAULT_BUCKET_SIZE:0,,true,35,35,DEFAULT_BUCKET_SIZE,,,0,
104272,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,proxy_ring_hash.c,proxy_ring_hash.c:123:123:MODE_DEFAULT:0,,true,123,123,MODE_DEFAULT,,,0,
104275,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,proxy_ring_hash.c,proxy_ring_hash.c:124:124:MODE_KETAMA:0,,true,124,124,MODE_KETAMA,,,0,
104278,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,proxy_ring_hash.c,proxy_ring_hash.c:125:125:MODE_TWEMPROXY:0,,true,125,125,MODE_TWEMPROXY,,,0,
104281,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,proxy_ring_hash.c,proxy_ring_hash.c:126:126:MODE_EVCACHE:0,,true,126,126,MODE_EVCACHE,,,0,
104284,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_tointegerx,,true,,,lua_tointegerx,,,0,
104290,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,proxy_ring_hash.c,proxy_ring_hash.c:241:241:PARTS:0,,true,241,241,PARTS,,,0,
104293,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,qsort,,true,,,qsort,,,0,
104300,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,isspace,,true,,,isspace,,,0,
104304,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,restart.h,restart.h:4:4:RESTART_TAG_MAXLEN:0,,true,4,4,RESTART_TAG_MAXLEN,,,0,
104307,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_restart_data_cb.ccb,,true,,,ccb,,,0,
104314,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getline,,true,,,getline,,,0,
104320,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_restart_data_cb.scb,,true,,,scb,,,0,
104327,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,restart.c,restart.c:267:267:SET_VAL_MAX:0,,true,267,267,SET_VAL_MAX,,,0,
104330,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,mmap,,true,,,mmap,,,0,
104339,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,msync,,true,,,msync,,,0,
104345,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,munmap,,true,,,munmap,,,0,
104350,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,slab_automove.c,slab_automove.c:14:14:MIN_PAGES_FOR_RECLAIM:0,,true,14,14,MIN_PAGES_FOR_RECLAIM,,,0,
104353,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,slab_automove.c,slab_automove.c:13:13:MIN_PAGES_FOR_SOURCE:0,,true,13,13,MIN_PAGES_FOR_SOURCE,,,0,
104356,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,slab_automove_extstore.c,slab_automove_extstore.c:15:15:MIN_PAGES_FREE:0,,true,15,15,MIN_PAGES_FREE,,,0,
104359,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,slab_automove_extstore.c,slab_automove_extstore.c:14:14:MIN_PAGES_FOR_RECLAIM:0,,true,14,14,MIN_PAGES_FOR_RECLAIM,,,0,
104362,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,slab_automove_extstore.c,slab_automove_extstore.c:13:13:MIN_PAGES_FOR_SOURCE:0,,true,13,13,MIN_PAGES_FOR_SOURCE,,,0,
104365,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memcached.h,memcached.h:114:114:SLAB_GLOBAL_PAGE_POOL:0,,true,114,114,SLAB_GLOBAL_PAGE_POOL,,,0,
104368,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,slabs.h,slabs.h:25:25:SLABS_ALLOC_NO_NEWPAGE:0,,true,25,25,SLABS_ALLOC_NO_NEWPAGE,,,0,
104371,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,slabs.c,slabs.c:837:837:SLAB_MOVE_MAX_LOOPS:0,,true,837,837,SLAB_MOVE_MAX_LOOPS,,,0,
104374,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,stats_prefix.h,stats_prefix.h:40:40:PREFIX_HASH_SIZE:0,,true,40,40,PREFIX_HASH_SIZE,,,0,
104377,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,testapp.c,testapp.c:131:131:ITERATIONS:0,,true,131,131,ITERATIONS,,,0,
104380,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sigemptyset,,true,,,sigemptyset,,,0,
104384,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sigaction,,true,,,sigaction,,,0,
104390,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,remove,,true,,,remove,,,0,
104394,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,putenv,,true,,,putenv,,,0,
104398,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,execv,,true,,,execv,,,0,
104403,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sleep,,true,,,sleep,,,0,
104407,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,connect,,true,,,connect,,,0,
104413,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,testapp.c,testapp.c:33:33:TMP_TEMPLATE:0,,true,33,33,TMP_TEMPLATE,,,0,
104416,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,mkstemp,,true,,,mkstemp,,,0,
104420,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,crc32c,,true,,,crc32c,,,0,
104426,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uint8_t,,true,,,uint8_t,,,0,
104430,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,srand,,true,,,srand,,,0,
104434,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,waitpid,,true,,,waitpid,,,0,
104440,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fflush,,true,,,fflush,,,0,
104444,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,alarm,,true,,,alarm,,,0,
104448,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,testcase.function,,true,,,function,,,0,
104452,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,thread.c,thread.c:91:91:hashmask:1,,true,91,91,hashmask,,,0,
104456,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,crawler.h,crawler.h:31:31:CRAWLER_WAIT:0,,true,31,31,CRAWLER_WAIT,,,0,
104459,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_attr_init,,true,,,pthread_attr_init,,,0,
104463,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,thread.c,thread.c:536:536:MAX_PIPE_EVENTS:0,,true,536,536,MAX_PIPE_EVENTS,,,0,
104466,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,event_base_loopexit,,true,,,event_base_loopexit,,,0,
104471,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memcached.h,memcached.h:309:333:THREAD_STATS_FIELDS:0,,true,309,333,THREAD_STATS_FIELDS,,,0,
104474,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memcached.h,memcached.h:292:300:SLAB_STATS_FIELDS:0,,true,292,300,SLAB_STATS_FIELDS,,,0,
104477,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,items.h,items.h:6:6:CLEAR_LRU:1,,true,6,6,CLEAR_LRU,,,0,
104481,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,thread.c,thread.c:90:90:hashsize:1,,true,90,90,hashsize,,,0,
104485,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WIFEXITED,,true,,,WIFEXITED,,,0,
104489,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WEXITSTATUS,,true,,,WEXITSTATUS,,,0,
104493,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WTERMSIG,,true,,,WTERMSIG,,,0,
104497,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,execvp,,true,,,execvp,,,0,
104502,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,isalnum,,true,,,isalnum,,,0,
104506,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,util.c,util.c:47:47:xisspace:1,,true,47,47,xisspace,,,0,
104510,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strtoll,,true,,,strtoll,,,0,
104516,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strtoul,,true,,,strtoul,,,0,
104522,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strtod,,true,,,strtod,,,0,
104527,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,vendor\mcmc\example.c,vendor\mcmc\example.c:-1:-1:__STDC_VERSION__:0,,true,-1,-1,__STDC_VERSION__,,,0,
104530,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,vendor\mcmc\mcmc.h,vendor\mcmc\mcmc.h:25:25:MCMC_PARSE_ERROR:0,,true,25,25,MCMC_PARSE_ERROR,,,0,
104533,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,vendor\mcmc\mcmc.c,vendor\mcmc\mcmc.c:32:32:STATE_GET_RESP:0,,true,32,32,STATE_GET_RESP,,,0,
104536,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,vendor\mcmc\mcmc.c,vendor\mcmc\mcmc.c:28:28:FLAG_BUF_IS_NUMERIC:0,,true,28,28,FLAG_BUF_IS_NUMERIC,,,0,
104539,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,vendor\mcmc\mcmc.h,vendor\mcmc\mcmc.h:24:24:MCMC_PARSE_ERROR_SHORT:0,,true,24,24,MCMC_PARSE_ERROR_SHORT,,,0,
104542,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,vendor\mcmc\mcmc.h,vendor\mcmc\mcmc.h:16:16:MCMC_CODE_EXISTS:0,,true,16,16,MCMC_CODE_EXISTS,,,0,
104545,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,vendor\mcmc\mcmc.h,vendor\mcmc\mcmc.h:23:23:MCMC_CODE_NOP:0,,true,23,23,MCMC_CODE_NOP,,,0,
104548,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,vendor\mcmc\mcmc.h,vendor\mcmc\mcmc.h:20:20:MCMC_CODE_NOT_FOUND:0,,true,20,20,MCMC_CODE_NOT_FOUND,,,0,
104551,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,vendor\mcmc\mcmc.h,vendor\mcmc\mcmc.h:21:21:MCMC_CODE_NOT_STORED:0,,true,21,21,MCMC_CODE_NOT_STORED,,,0,
104554,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,vendor\mcmc\mcmc.c,vendor\mcmc\mcmc.c:31:31:STATE_DEFAULT:0,,true,31,31,STATE_DEFAULT,,,0,
104557,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,vendor\mcmc\mcmc.h,vendor\mcmc\mcmc.h:32:32:MCMC_RESP_STAT:0,,true,32,32,MCMC_RESP_STAT,,,0,
104560,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,vendor\mcmc\mcmc.c,vendor\mcmc\mcmc.c:33:33:STATE_STAT_RESP:0,,true,33,33,STATE_STAT_RESP,,,0,
104563,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,vendor\mcmc\mcmc.h,vendor\mcmc\mcmc.h:15:15:MCMC_CODE_STORED:0,,true,15,15,MCMC_CODE_STORED,,,0,
104566,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,vendor\mcmc\mcmc.h,vendor\mcmc\mcmc.h:17:17:MCMC_CODE_DELETED:0,,true,17,17,MCMC_CODE_DELETED,,,0,
104569,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,vendor\mcmc\mcmc.h,vendor\mcmc\mcmc.h:18:18:MCMC_CODE_TOUCHED:0,,true,18,18,MCMC_CODE_TOUCHED,,,0,
104572,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,vendor\mcmc\mcmc.h,vendor\mcmc\mcmc.h:19:19:MCMC_CODE_VERSION:0,,true,19,19,MCMC_CODE_VERSION,,,0,
104575,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,vendor\mcmc\mcmc.h,vendor\mcmc\mcmc.h:35:35:MCMC_RESP_VERSION:0,,true,35,35,MCMC_RESP_VERSION,,,0,
104578,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,vendor\mcmc\mcmc.c,vendor\mcmc\mcmc.c:27:27:FLAG_BUF_IS_ERROR:0,,true,27,27,FLAG_BUF_IS_ERROR,,,0,
104581,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,vendor\mcmc\mcmc.c,vendor\mcmc\mcmc.c:25:25:MIN_BUFFER_SIZE:0,,true,25,25,MIN_BUFFER_SIZE,,,0,
104584,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,send,,true,,,send,,,0,
104591,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,vendor\mcmc\mcmc.h,vendor\mcmc\mcmc.h:9:9:MCMC_WANT_WRITE:0,,true,9,9,MCMC_WANT_WRITE,,,0,
104594,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,vendor\mcmc\mcmc.h,vendor\mcmc\mcmc.h:6:6:MCMC_NOT_CONNECTED:0,,true,6,6,MCMC_NOT_CONNECTED,,,0,
