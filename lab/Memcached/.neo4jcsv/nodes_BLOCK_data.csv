32,BLOCK,-1,,<empty>,1,,1,1,,ANY
45,BLOCK,1,,<empty>,,,,1,,void
65,BLOCK,-1,,"{
    if (hashtable_init) {
        hashpower = hashtable_init;
    }
    primary_hashtable = calloc(hashsize(hashpower), sizeof(void *));
    if (! primary_hashtable) {
        fprintf(stderr, ""Failed to init hashtable.\n"");
        exit(EXIT_FAILURE);
    }
    STATS_LOCK();
    stats_state.hash_power_level = hashpower;
    stats_state.hash_bytes = hashsize(hashpower) * sizeof(void *);
    STATS_UNLOCK();
}",43,,55,2,,void
68,BLOCK,-1,,"{
        hashpower = hashtable_init;
    }",25,,56,2,,void
77,BLOCK,1,,<empty>,,,,3,,void
88,BLOCK,-1,,"{
        fprintf(stderr, ""Failed to init hashtable.\n"");
        exit(EXIT_FAILURE);
    }",30,,60,2,,void
107,BLOCK,1,,<empty>,,,,3,,void
122,BLOCK,-1,,"{
    item *it;
    uint64_t oldbucket;

    if (expanding &&
        (oldbucket = (hv & hashmask(hashpower - 1))) >= expand_bucket)
    {
        it = old_hashtable[oldbucket];
    } else {
        it = primary_hashtable[hv & hashmask(hashpower)];
    }

    item *ret = NULL;
    int depth = 0;
    while (it) {
        if ((nkey == it->nkey) && (memcmp(key, ITEM_key(it), nkey) == 0)) {
            ret = it;
            break;
        }
        it = it->h_next;
        ++depth;
    }
    MEMCACHED_ASSOC_FIND(key, nkey, depth);
    return ret;
}",73,,70,4,,void
134,BLOCK,1,,<empty>,,,,2,,void
145,BLOCK,-1,,"{
        it = old_hashtable[oldbucket];
    }",5,,76,2,,void
152,BLOCK,-1,,"{
        it = primary_hashtable[hv & hashmask(hashpower)];
    }",12,,78,1,,void
161,BLOCK,1,,<empty>,,,,3,,void
179,BLOCK,-1,,"{
        if ((nkey == it->nkey) && (memcmp(key, ITEM_key(it), nkey) == 0)) {
            ret = it;
            break;
        }
        it = it->h_next;
        ++depth;
    }",16,,84,2,,void
192,BLOCK,1,,<empty>,,,,4,,void
211,BLOCK,-1,,"{
            ret = it;
            break;
        }",75,,85,2,,void
231,BLOCK,-1,,"{
    item **pos;
    uint64_t oldbucket;

    if (expanding &&
        (oldbucket = (hv & hashmask(hashpower - 1))) >= expand_bucket)
    {
        pos = &old_hashtable[oldbucket];
    } else {
        pos = &primary_hashtable[hv & hashmask(hashpower)];
    }

    while (*pos && ((nkey != (*pos)->nkey) || memcmp(key, ITEM_key(*pos), nkey))) {
        pos = &(*pos)->h_next;
    }
    return pos;
}",88,,99,4,,void
243,BLOCK,1,,<empty>,,,,2,,void
254,BLOCK,-1,,"{
        pos = &old_hashtable[oldbucket];
    }",5,,105,2,,void
262,BLOCK,-1,,"{
        pos = &primary_hashtable[hv & hashmask(hashpower)];
    }",12,,107,1,,void
272,BLOCK,1,,<empty>,,,,3,,void
296,BLOCK,1,,<empty>,,,,4,,void
316,BLOCK,-1,,"{
        pos = &(*pos)->h_next;
    }",83,,111,2,,void
330,BLOCK,-1,,"{
    old_hashtable = primary_hashtable;

    primary_hashtable = calloc(hashsize(hashpower + 1), sizeof(void *));
    if (primary_hashtable) {
        if (settings.verbose > 1)
            fprintf(stderr, ""Hash table expansion starting\n"");
        hashpower++;
        expanding = true;
        expand_bucket = 0;
        STATS_LOCK();
        stats_state.hash_power_level = hashpower;
        stats_state.hash_bytes += hashsize(hashpower) * sizeof(void *);
        stats_state.hash_is_expanding = true;
        STATS_UNLOCK();
    } else {
        primary_hashtable = old_hashtable;
        /* Bad news, but we can keep running. */
    }
}",32,,118,2,,void
338,BLOCK,1,,<empty>,,,,2,,void
350,BLOCK,-1,,"{
        if (settings.verbose > 1)
            fprintf(stderr, ""Hash table expansion starting\n"");
        hashpower++;
        expanding = true;
        expand_bucket = 0;
        STATS_LOCK();
        stats_state.hash_power_level = hashpower;
        stats_state.hash_bytes += hashsize(hashpower) * sizeof(void *);
        stats_state.hash_is_expanding = true;
        STATS_UNLOCK();
    }",28,,122,2,,void
357,BLOCK,-1,,<empty>,13,,124,2,,void
382,BLOCK,1,,<empty>,,,,3,,void
397,BLOCK,-1,,"{
        primary_hashtable = old_hashtable;
        /* Bad news, but we can keep running. */
    }",12,,133,1,,void
405,BLOCK,-1,,"{
    if (pthread_mutex_trylock(&maintenance_lock) == 0) {
        if (curr_items > (hashsize(hashpower) * 3) / 2 && hashpower < HASHPOWER_MAX) {
            pthread_cond_signal(&maintenance_cond);
        }
        pthread_mutex_unlock(&maintenance_lock);
    }
}",46,,139,2,,void
412,BLOCK,-1,,"{
        if (curr_items > (hashsize(hashpower) * 3) / 2 && hashpower < HASHPOWER_MAX) {
            pthread_cond_signal(&maintenance_cond);
        }
        pthread_mutex_unlock(&maintenance_lock);
    }",56,,140,2,,void
421,BLOCK,1,,<empty>,,,,3,,void
432,BLOCK,1,,<empty>,,,,1,,void
434,BLOCK,-1,,"{
            pthread_cond_signal(&maintenance_cond);
        }",86,,141,2,,void
446,BLOCK,-1,,"{
    uint64_t oldbucket;

//    assert(assoc_find(ITEM_key(it), it->nkey) == 0);  /* shouldn't have duplicately named things defined */

    if (expanding &&
        (oldbucket = (hv & hashmask(hashpower - 1))) >= expand_bucket)
    {
        it->h_next = old_hashtable[oldbucket];
        old_hashtable[oldbucket] = it;
    } else {
        it->h_next = primary_hashtable[hv & hashmask(hashpower)];
        primary_hashtable[hv & hashmask(hashpower)] = it;
    }

    MEMCACHED_ASSOC_INSERT(ITEM_key(it), it->nkey);
    return 1;
}",47,,149,3,,void
457,BLOCK,1,,<empty>,,,,2,,void
468,BLOCK,-1,,"{
        it->h_next = old_hashtable[oldbucket];
        old_hashtable[oldbucket] = it;
    }",5,,156,2,,void
482,BLOCK,-1,,"{
        it->h_next = primary_hashtable[hv & hashmask(hashpower)];
        primary_hashtable[hv & hashmask(hashpower)] = it;
    }",12,,159,1,,void
493,BLOCK,1,,<empty>,,,,3,,void
508,BLOCK,1,,<empty>,,,,3,,void
525,BLOCK,-1,,"{
    item **before = _hashitem_before(key, nkey, hv);

    if (*before) {
        item *nxt;
        /* The DTrace probe cannot be triggered as the last instruction
         * due to possible tail-optimization by the compiler
         */
        MEMCACHED_ASSOC_DELETE(key, nkey);
        nxt = (*before)->h_next;
        (*before)->h_next = 0;   /* probably pointless, but whatever. */
        *before = nxt;
        return;
    }
    /* Note:  we never actually get here.  the callers don't delete things
       they can't find. */
    assert(*before != 0);
}",74,,168,4,,void
536,BLOCK,-1,,"{
        item *nxt;
        /* The DTrace probe cannot be triggered as the last instruction
         * due to possible tail-optimization by the compiler
         */
        MEMCACHED_ASSOC_DELETE(key, nkey);
        nxt = (*before)->h_next;
        (*before)->h_next = 0;   /* probably pointless, but whatever. */
        *before = nxt;
        return;
    }",18,,171,2,,void
570,BLOCK,1,,<empty>,,,,1,,void
574,BLOCK,-1,,"{

    mutex_lock(&maintenance_lock);
    while (do_run_maintenance_thread) {
        int ii = 0;

        /* There is only one expansion thread, so no need to global lock. */
        for (ii = 0; ii < hash_bulk_move && expanding; ++ii) {
            item *it, *next;
            uint64_t bucket;
            void *item_lock = NULL;

            /* bucket = hv & hashmask(hashpower) =>the bucket of hash table
             * is the lowest N bits of the hv, and the bucket of item_locks is
             *  also the lowest M bits of hv, and N is greater than M.
             *  So we can process expanding with only one item_lock. cool! */
            if ((item_lock = item_trylock(expand_bucket))) {
                    for (it = old_hashtable[expand_bucket]; NULL != it; it = next) {
                        next = it->h_next;
                        bucket = hash(ITEM_key(it), it->nkey) & hashmask(hashpower);
                        it->h_next = primary_hashtable[bucket];
                     ...",50,,193,2,,void
578,BLOCK,1,,<empty>,,,,3,,void
584,BLOCK,-1,,"{
        int ii = 0;

        /* There is only one expansion thread, so no need to global lock. */
        for (ii = 0; ii < hash_bulk_move && expanding; ++ii) {
            item *it, *next;
            uint64_t bucket;
            void *item_lock = NULL;

            /* bucket = hv & hashmask(hashpower) =>the bucket of hash table
             * is the lowest N bits of the hv, and the bucket of item_locks is
             *  also the lowest M bits of hv, and N is greater than M.
             *  So we can process expanding with only one item_lock. cool! */
            if ((item_lock = item_trylock(expand_bucket))) {
                    for (it = old_hashtable[expand_bucket]; NULL != it; it = next) {
                        next = it->h_next;
                        bucket = hash(ITEM_key(it), it->nkey) & hashmask(hashpower);
                        it->h_next = primary_hashtable[bucket];
                        primary_hashtable[bucket] = it;
                    }

                  ...",39,,196,2,,void
590,BLOCK,-1,,<empty>,9,,200,1,,void
601,BLOCK,4,,"{
            item *it, *next;
            uint64_t bucket;
            void *item_lock = NULL;

            /* bucket = hv & hashmask(hashpower) =>the bucket of hash table
             * is the lowest N bits of the hv, and the bucket of item_locks is
             *  also the lowest M bits of hv, and N is greater than M.
             *  So we can process expanding with only one item_lock. cool! */
            if ((item_lock = item_trylock(expand_bucket))) {
                    for (it = old_hashtable[expand_bucket]; NULL != it; it = next) {
                        next = it->h_next;
                        bucket = hash(ITEM_key(it), it->nkey) & hashmask(hashpower);
                        it->h_next = primary_hashtable[bucket];
                        primary_hashtable[bucket] = it;
                    }

                    old_hashtable[expand_bucket] = NULL;

                    expand_bucket++;
                    if (expand_bucket == hashsize(hashpower - 1)) {
                ...",62,,200,4,,void
614,BLOCK,-1,,"{
                    for (it = old_hashtable[expand_bucket]; NULL != it; it = next) {
                        next = it->h_next;
                        bucket = hash(ITEM_key(it), it->nkey) & hashmask(hashpower);
                        it->h_next = primary_hashtable[bucket];
                        primary_hashtable[bucket] = it;
                    }

                    old_hashtable[expand_bucket] = NULL;

                    expand_bucket++;
                    if (expand_bucket == hashsize(hashpower - 1)) {
                        expanding = false;
                        free(old_hashtable);
                        STATS_LOCK();
                        stats_state.hash_bytes -= hashsize(hashpower - 1) * sizeof(void *);
                        stats_state.hash_is_expanding = false;
                        STATS_UNLOCK();
                        if (settings.verbose > 1)
                            fprintf(stderr, ""Hash table expansion done\n"");
                    }

      ...",60,,209,2,,void
616,BLOCK,-1,,<empty>,21,,210,1,,void
628,BLOCK,4,,"{
                        next = it->h_next;
                        bucket = hash(ITEM_key(it), it->nkey) & hashmask(hashpower);
                        it->h_next = primary_hashtable[bucket];
                        primary_hashtable[bucket] = it;
                    }",84,,210,4,,void
640,BLOCK,1,,<empty>,,,,4,,void
662,BLOCK,1,,<empty>,,,,3,,void
693,BLOCK,1,,<empty>,,,,2,,void
701,BLOCK,-1,,"{
                        expanding = false;
                        free(old_hashtable);
                        STATS_LOCK();
                        stats_state.hash_bytes -= hashsize(hashpower - 1) * sizeof(void *);
                        stats_state.hash_is_expanding = false;
                        STATS_UNLOCK();
                        if (settings.verbose > 1)
                            fprintf(stderr, ""Hash table expansion done\n"");
                    }",67,,220,2,,void
714,BLOCK,1,,<empty>,,,,2,,void
736,BLOCK,-1,,<empty>,29,,228,2,,void
741,BLOCK,-1,,"{
                usleep(10*1000);
            }",20,,231,1,,void
748,BLOCK,-1,,"{
                item_trylock_unlock(item_lock);
                item_lock = NULL;
            }",28,,235,2,,void
757,BLOCK,-1,,"{
            /* We are done expanding.. just wait for next invocation */
            pthread_cond_wait(&maintenance_cond, &maintenance_lock);
            /* assoc_expand() swaps out the hash table entirely, so we need
             * all threads to not hold any references related to the hash
             * table while this happens.
             * This is instead of a more complex, possibly slower algorithm to
             * allow dynamic hash table expansion without causing significant
             * wait times.
             */
            if (do_run_maintenance_thread) {
                pause_threads(PAUSE_ALL_THREADS);
                assoc_expand();
                pause_threads(RESUME_ALL_THREADS);
            }
        }",25,,241,2,,void
765,BLOCK,-1,,"{
                pause_threads(PAUSE_ALL_THREADS);
                assoc_expand();
                pause_threads(RESUME_ALL_THREADS);
            }",44,,251,2,,void
774,BLOCK,1,,<empty>,,,,3,,void
784,BLOCK,-1,,"{
    int ret;
    char *env = getenv(""MEMCACHED_HASH_BULK_MOVE"");
    if (env != NULL) {
        hash_bulk_move = atoi(env);
        if (hash_bulk_move == 0) {
            hash_bulk_move = DEFAULT_HASH_BULK_MOVE;
        }
    }

    if ((ret = pthread_create(&maintenance_tid, NULL,
                              assoc_maintenance_thread, NULL)) != 0) {
        fprintf(stderr, ""Can't create thread: %s\n"", strerror(ret));
        return -1;
    }
    return 0;
}",38,,264,1,,void
795,BLOCK,-1,,"{
        hash_bulk_move = atoi(env);
        if (hash_bulk_move == 0) {
            hash_bulk_move = DEFAULT_HASH_BULK_MOVE;
        }
    }",22,,267,2,,void
804,BLOCK,-1,,"{
            hash_bulk_move = DEFAULT_HASH_BULK_MOVE;
        }",34,,269,2,,void
808,BLOCK,1,,<empty>,,,,1,,void
821,BLOCK,-1,,"{
        fprintf(stderr, ""Can't create thread: %s\n"", strerror(ret));
        return -1;
    }",70,,275,2,,void
835,BLOCK,-1,,"{
    mutex_lock(&maintenance_lock);
    do_run_maintenance_thread = 0;
    pthread_cond_signal(&maintenance_cond);
    mutex_unlock(&maintenance_lock);

    /* Wait for the maintenance thread to stop */
    pthread_join(maintenance_tid, NULL);
}",38,,282,1,,void
839,BLOCK,1,,<empty>,,,,3,,void
852,BLOCK,1,,<empty>,,,,3,,void
868,BLOCK,-1,,"{
    struct assoc_iterator *iter = calloc(1, sizeof(struct assoc_iterator));
    if (iter == NULL) {
        return NULL;
    }
    // this will hang the caller while a hash table expansion is running.
    mutex_lock(&maintenance_lock);
    return iter;
}",32,,299,2,,void
880,BLOCK,-1,,"{
        return NULL;
    }",23,,301,2,,void
886,BLOCK,1,,<empty>,,,,3,,void
897,BLOCK,-1,,"{
    struct assoc_iterator *iter = (struct assoc_iterator *) iterp;
    *it = NULL;
    // - if locked bucket and next, update next and return
    if (iter->bucket_locked) {
        if (iter->next != NULL) {
            iter->it = iter->next;
            iter->next = iter->it->h_next;
            *it = iter->it;
        } else {
            // unlock previous bucket, if any
            item_unlock(iter->bucket);
            // iterate the bucket post since it starts at 0.
            iter->bucket++;
            iter->bucket_locked = false;
            *it = NULL;
        }
        return true;
    }

    // - loop until we hit the end or find something.
    if (iter->bucket != hashsize(hashpower)) {
        // - lock next bucket
        item_lock(iter->bucket);
        iter->bucket_locked = true;
        // - only check the primary hash table since expand is blocked.
        iter->it = primary_hashtable[iter->bucket];
        if (iter->it != NULL) {
            // - set it, next an...",44,,309,3,,void
912,BLOCK,-1,,"{
        if (iter->next != NULL) {
            iter->it = iter->next;
            iter->next = iter->it->h_next;
            *it = iter->it;
        } else {
            // unlock previous bucket, if any
            item_unlock(iter->bucket);
            // iterate the bucket post since it starts at 0.
            iter->bucket++;
            iter->bucket_locked = false;
            *it = NULL;
        }
        return true;
    }",30,,313,2,,void
919,BLOCK,-1,,"{
            iter->it = iter->next;
            iter->next = iter->it->h_next;
            *it = iter->it;
        }",33,,314,2,,void
943,BLOCK,-1,,"{
            // unlock previous bucket, if any
            item_unlock(iter->bucket);
            // iterate the bucket post since it starts at 0.
            iter->bucket++;
            iter->bucket_locked = false;
            *it = NULL;
        }",16,,318,1,,void
970,BLOCK,1,,<empty>,,,,3,,void
976,BLOCK,-1,,"{
        // - lock next bucket
        item_lock(iter->bucket);
        iter->bucket_locked = true;
        // - only check the primary hash table since expand is blocked.
        iter->it = primary_hashtable[iter->bucket];
        if (iter->it != NULL) {
            // - set it, next and return
            iter->next = iter->it->h_next;
            *it = iter->it;
        } else {
            // - nothing found in this bucket, try next.
            item_unlock(iter->bucket);
            iter->bucket_locked = false;
            iter->bucket++;
        }
    }",46,,330,2,,void
1001,BLOCK,-1,,"{
            // - set it, next and return
            iter->next = iter->it->h_next;
            *it = iter->it;
        }",31,,336,2,,void
1018,BLOCK,-1,,"{
            // - nothing found in this bucket, try next.
            item_unlock(iter->bucket);
            iter->bucket_locked = false;
            iter->bucket++;
        }",16,,340,1,,void
1033,BLOCK,-1,,"{
        return false;
    }",12,,346,1,,void
1042,BLOCK,-1,,"{
    struct assoc_iterator *iter = (struct assoc_iterator *) iterp;
    if (iter->bucket_locked) {
        item_unlock(iter->bucket);
    }
    mutex_unlock(&maintenance_lock);
    free(iter);
}",39,,353,2,,void
1053,BLOCK,-1,,"{
        item_unlock(iter->bucket);
    }",30,,355,2,,void
1061,BLOCK,1,,<empty>,,,,3,,void
1073,BLOCK,-1,,<empty>,1,,1,1,,ANY
1076,BLOCK,-1,,<empty>,,,,2,,<empty>
1083,BLOCK,-1,,<empty>,,,,4,,<empty>
1089,BLOCK,-1,,<empty>,,,,3,,<empty>
1096,BLOCK,-1,,<empty>,,,,4,,<empty>
1101,BLOCK,-1,,<empty>,,,,2,,<empty>
1106,BLOCK,-1,,<empty>,,,,2,,<empty>
1111,BLOCK,-1,,<empty>,,,,2,,<empty>
1116,BLOCK,-1,,<empty>,,,,2,,<empty>
1121,BLOCK,-1,,<empty>,,,,2,,<empty>
1127,BLOCK,-1,,<empty>,,,,3,,<empty>
1132,BLOCK,-1,,<empty>,,,,2,,<empty>
1161,BLOCK,-1,,<empty>,1,,1,1,,ANY
1171,BLOCK,1,,<empty>,,,,1,,void
1183,BLOCK,-1,,"{
    struct stat sb;
    char *auth_data = NULL;
    auth_t auth_entries[MAX_ENTRIES];

    FILE *pwfile = fopen(file, ""r"");
    if (pwfile == NULL) {
        return AUTHFILE_OPENFAIL;
    } else if (fstat(fileno(pwfile), &sb)) {
        fclose(pwfile);
        return AUTHFILE_STATFAIL;
    }

    auth_data = calloc(1, sb.st_size + 1);

    char *auth_cur = auth_data;
    char *auth_end = auth_data + sb.st_size;
    auth_t *entry_cur = auth_entries;
    int used = 0;

    while ((fgets(auth_cur, auth_end - auth_cur < MAX_ENTRY_LEN ? auth_end - auth_cur : MAX_ENTRY_LEN, pwfile)) != NULL) {
        int x;
        int found = 0;

        for (x = 0; x < MAX_ENTRY_LEN; x++) {
            if (!found) {
                if (auth_cur[x] == '\0') {
                    // The username is malformed - this is either the end of the file or a null byte.
                    break;
                } else if (auth_cur[x] == ':') {
                    entry_cur->user = auth_cur;
                    ...",51,,31,2,,void
1200,BLOCK,-1,,"{
        return AUTHFILE_OPENFAIL;
    }",25,,37,2,,void
1204,BLOCK,-1,,<empty>,12,,39,1,,void
1211,BLOCK,-1,,"{
        fclose(pwfile);
        return AUTHFILE_STATFAIL;
    }",44,,39,2,,void
1255,BLOCK,1,,<empty>,,,,1,,void
1261,BLOCK,1,,<empty>,,,,1,,void
1265,BLOCK,-1,,"{
        int x;
        int found = 0;

        for (x = 0; x < MAX_ENTRY_LEN; x++) {
            if (!found) {
                if (auth_cur[x] == '\0') {
                    // The username is malformed - this is either the end of the file or a null byte.
                    break;
                } else if (auth_cur[x] == ':') {
                    entry_cur->user = auth_cur;
                    entry_cur->ulen = x;
                    entry_cur->pass = &auth_cur[x+1];
                    found = 1;
                }
            } else {
                // Find end of password.
                if (auth_cur[x] == '\n' ||
                    auth_cur[x] == '\r' ||
                    auth_cur[x] == '\0') {
                    entry_cur->plen = x - (entry_cur->ulen + 1);
                    break;
                }
            }
        }

        // malformed line.
        if (!found) {
            (void)fclose(pwfile);
            free(auth_data);
            return AUTHFILE_MALFO...",122,,51,2,,void
1272,BLOCK,-1,,<empty>,9,,55,1,,void
1279,BLOCK,1,,<empty>,,,,1,,void
1283,BLOCK,4,,"{
            if (!found) {
                if (auth_cur[x] == '\0') {
                    // The username is malformed - this is either the end of the file or a null byte.
                    break;
                } else if (auth_cur[x] == ':') {
                    entry_cur->user = auth_cur;
                    entry_cur->ulen = x;
                    entry_cur->pass = &auth_cur[x+1];
                    found = 1;
                }
            } else {
                // Find end of password.
                if (auth_cur[x] == '\n' ||
                    auth_cur[x] == '\r' ||
                    auth_cur[x] == '\0') {
                    entry_cur->plen = x - (entry_cur->ulen + 1);
                    break;
                }
            }
        }",45,,55,4,,void
1287,BLOCK,-1,,"{
                if (auth_cur[x] == '\0') {
                    // The username is malformed - this is either the end of the file or a null byte.
                    break;
                } else if (auth_cur[x] == ':') {
                    entry_cur->user = auth_cur;
                    entry_cur->ulen = x;
                    entry_cur->pass = &auth_cur[x+1];
                    found = 1;
                }
            }",25,,56,2,,void
1294,BLOCK,-1,,"{
                    // The username is malformed - this is either the end of the file or a null byte.
                    break;
                }",42,,57,2,,void
1297,BLOCK,-1,,<empty>,24,,60,1,,void
1304,BLOCK,-1,,"{
                    entry_cur->user = auth_cur;
                    entry_cur->ulen = x;
                    entry_cur->pass = &auth_cur[x+1];
                    found = 1;
                }",48,,60,2,,void
1329,BLOCK,-1,,"{
                // Find end of password.
                if (auth_cur[x] == '\n' ||
                    auth_cur[x] == '\r' ||
                    auth_cur[x] == '\0') {
                    entry_cur->plen = x - (entry_cur->ulen + 1);
                    break;
                }
            }",20,,66,1,,void
1348,BLOCK,-1,,"{
                    entry_cur->plen = x - (entry_cur->ulen + 1);
                    break;
                }",42,,70,2,,void
1364,BLOCK,-1,,"{
            (void)fclose(pwfile);
            free(auth_data);
            return AUTHFILE_MALFORMED;
        }",21,,78,2,,void
1378,BLOCK,1,,<empty>,,,,1,,void
1380,BLOCK,-1,,"{
            break;
        }",36,,85,2,,void
1388,BLOCK,-1,,<empty>,13,,90,2,,void
1399,BLOCK,-1,,"{
        free(main_auth_data);
    }",33,,98,2,,void
1424,BLOCK,-1,,"{
    size_t ulen = strlen(user);
    size_t plen = strlen(pass);

    for (int x = 0; x < entry_cnt; x++) {
        auth_t *e = &main_auth_entries[x];
        if (ulen == e->ulen && plen == e->plen &&
            safe_memcmp(user, e->user, e->ulen) &&
            safe_memcmp(pass, e->pass, e->plen)) {
            return 1;
        }
    }

    return 0;
}",56,,112,3,,void
1436,BLOCK,-1,,<empty>,5,,116,1,,void
1446,BLOCK,4,,"{
        auth_t *e = &main_auth_entries[x];
        if (ulen == e->ulen && plen == e->plen &&
            safe_memcmp(user, e->user, e->ulen) &&
            safe_memcmp(pass, e->pass, e->plen)) {
            return 1;
        }
    }",41,,116,4,,void
1484,BLOCK,-1,,"{
            return 1;
        }",50,,120,2,,void
1495,BLOCK,-1,,<empty>,1,,1,1,,ANY
1503,BLOCK,-1,,<empty>,,,,1,,<empty>
1514,BLOCK,-1,,<empty>,,,,3,,<empty>
1525,BLOCK,-1,,<empty>,1,,1,1,,ANY
1795,BLOCK,-1,,"{
    unsigned char *pos;
    const unsigned char *end, *in;
    size_t olen;

    olen = len * 4 / 3 + 4; /* 3-byte blocks to 4-byte */
    olen += olen / 72; /* line feeds */
    olen++; /* nul termination */
    if (olen < len) {
        return 0; /* integer overflow */
    }
    if (olen > out_len) {
        return 0; /* not enough space in output buffer */
    }
    if (out == NULL) {
        return 0;
    }

    end = src + len;
    in = src;
    pos = out;
    while (end - in >= 3) {
        *pos++ = base64_table[in[0] >> 2];
        *pos++ = base64_table[((in[0] & 0x03) << 4) | (in[1] >> 4)];
        *pos++ = base64_table[((in[1] & 0x0f) << 2) | (in[2] >> 6)];
        *pos++ = base64_table[in[2] & 0x3f];
        in += 3;
    }

    if (end - in) {
        *pos++ = base64_table[in[0] >> 2];
        if (end - in == 1) {
            *pos++ = base64_table[(in[0] & 0x03) << 4];
            *pos++ = '=';
        } else {
            *pos++ = base64_table[((in[0] & 0x03) << 4) |
  ...",1,,95,5,,void
1820,BLOCK,-1,,"{
        return 0; /* integer overflow */
    }",21,,103,2,,void
1827,BLOCK,-1,,"{
        return 0; /* not enough space in output buffer */
    }",25,,106,2,,void
1834,BLOCK,-1,,"{
        return 0;
    }",22,,109,2,,void
1854,BLOCK,-1,,"{
        *pos++ = base64_table[in[0] >> 2];
        *pos++ = base64_table[((in[0] & 0x03) << 4) | (in[1] >> 4)];
        *pos++ = base64_table[((in[1] & 0x0f) << 2) | (in[2] >> 6)];
        *pos++ = base64_table[in[2] & 0x3f];
        in += 3;
    }",27,,116,2,,void
1922,BLOCK,-1,,"{
        *pos++ = base64_table[in[0] >> 2];
        if (end - in == 1) {
            *pos++ = base64_table[(in[0] & 0x03) << 4];
            *pos++ = '=';
        } else {
            *pos++ = base64_table[((in[0] & 0x03) << 4) |
                          (in[1] >> 4)];
            *pos++ = base64_table[(in[1] & 0x0f) << 2];
        }
        *pos++ = '=';
    }",19,,124,2,,void
1940,BLOCK,-1,,"{
            *pos++ = base64_table[(in[0] & 0x03) << 4];
            *pos++ = '=';
        }",28,,126,2,,void
1960,BLOCK,-1,,"{
            *pos++ = base64_table[((in[0] & 0x03) << 4) |
                          (in[1] >> 4)];
            *pos++ = base64_table[(in[1] & 0x0f) << 2];
        }",16,,129,1,,void
2013,BLOCK,-1,,"{
    unsigned char *pos, block[4], tmp;
    size_t i, count, olen;
    int pad = 0;

    count = 0;
    for (i = 0; i < len; i++) {
        if (dtable[src[i]] != 0x80)
            count++;
    }

    if (count == 0 || count % 4)
        return 0;

    olen = count / 4 * 3;
    if (olen > out_len) {
        return 0;
    }
    pos = out;
    if (out == NULL) {
        return 0;
    }

    count = 0;
    for (i = 0; i < len; i++) {
        tmp = dtable[src[i]];
        if (tmp == 0x80)
            continue;

        if (src[i] == '=')
            pad++;
        block[count] = tmp;
        count++;
        if (count == 4) {
            *pos++ = (block[0] << 2) | (block[1] >> 4);
            *pos++ = (block[1] << 4) | (block[2] >> 2);
            *pos++ = (block[2] << 6) | block[3];
            count = 0;
            if (pad) {
                if (pad == 1)
                    pos--;
                else if (pad == 2)
                    pos -= 2;
                else {
               ...",1,,152,5,,void
2028,BLOCK,-1,,<empty>,5,,158,1,,void
2037,BLOCK,4,,"{
        if (dtable[src[i]] != 0x80)
            count++;
    }",31,,158,4,,void
2046,BLOCK,-1,,<empty>,13,,160,2,,void
2057,BLOCK,-1,,<empty>,9,,164,2,,void
2071,BLOCK,-1,,"{
        return 0;
    }",25,,167,2,,void
2081,BLOCK,-1,,"{
        return 0;
    }",22,,171,2,,void
2088,BLOCK,-1,,<empty>,5,,176,1,,void
2097,BLOCK,4,,"{
        tmp = dtable[src[i]];
        if (tmp == 0x80)
            continue;

        if (src[i] == '=')
            pad++;
        block[count] = tmp;
        count++;
        if (count == 4) {
            *pos++ = (block[0] << 2) | (block[1] >> 4);
            *pos++ = (block[1] << 4) | (block[2] >> 2);
            *pos++ = (block[2] << 6) | block[3];
            count = 0;
            if (pad) {
                if (pad == 1)
                    pos--;
                else if (pad == 2)
                    pos -= 2;
                else {
                    /* Invalid padding */
                    return 0;
                }
                break;
            }
        }
    }",31,,176,4,,void
2109,BLOCK,-1,,<empty>,13,,179,2,,void
2117,BLOCK,-1,,<empty>,13,,182,2,,void
2131,BLOCK,-1,,"{
            *pos++ = (block[0] << 2) | (block[1] >> 4);
            *pos++ = (block[1] << 4) | (block[2] >> 2);
            *pos++ = (block[2] << 6) | block[3];
            count = 0;
            if (pad) {
                if (pad == 1)
                    pos--;
                else if (pad == 2)
                    pos -= 2;
                else {
                    /* Invalid padding */
                    return 0;
                }
                break;
            }
        }",25,,185,2,,void
2180,BLOCK,-1,,"{
                if (pad == 1)
                    pos--;
                else if (pad == 2)
                    pos -= 2;
                else {
                    /* Invalid padding */
                    return 0;
                }
                break;
            }",22,,190,2,,void
2185,BLOCK,-1,,<empty>,21,,192,2,,void
2189,BLOCK,-1,,<empty>,22,,193,1,,void
2194,BLOCK,-1,,<empty>,21,,194,2,,void
2199,BLOCK,-1,,"{
                    /* Invalid padding */
                    return 0;
                }",22,,195,1,,void
2213,BLOCK,-1,,<empty>,1,,1,1,,ANY
2219,BLOCK,-1,,<empty>,,,,5,,<empty>
2227,BLOCK,-1,,<empty>,,,,5,,<empty>
2242,BLOCK,-1,,<empty>,1,,1,1,,ANY
2245,BLOCK,-1,,"{
    return sizeof(bipbuf_t) + size;
}",1,,19,2,,void
2255,BLOCK,-1,,"{
    if (1 == me->b_inuse)
        /* distance between region B and region A */
        return me->a_start - me->b_end;
    else
        return me->size - me->a_end;
}",1,,24,2,,void
2262,BLOCK,-1,,<empty>,9,,27,2,,void
2272,BLOCK,-1,,<empty>,9,,29,1,,void
2285,BLOCK,-1,,"{
    return me->size;
}",1,,33,2,,void
2294,BLOCK,-1,,"{
    return (me->a_end - me->a_start) + me->b_end;
}",1,,38,2,,void
2312,BLOCK,-1,,"{
    me->a_start = me->a_end = me->b_end = 0;
    me->size = size;
    me->b_inuse = 0;
}",1,,43,3,,void
2340,BLOCK,-1,,"{
    bipbuf_t *me = malloc(bipbuf_sizeof(size));
    if (!me)
        return NULL;
    bipbuf_init(me, size);
    return me;
}",1,,50,2,,void
2350,BLOCK,-1,,<empty>,9,,53,2,,void
2362,BLOCK,-1,,"{
    free(me);
}",1,,59,2,,void
2369,BLOCK,-1,,"{
    return me->a_start == me->a_end;
}",1,,64,2,,void
2382,BLOCK,-1,,"{
    if (me->size - me->a_end < me->a_start - me->b_end)
        me->b_inuse = 1;
}",1,,71,2,,void
2399,BLOCK,-1,,<empty>,9,,73,2,,void
2410,BLOCK,-1,,"{
    if (bipbuf_unused(me) < size)
        return 0;
    if (1 == me->b_inuse)
    {
        return (unsigned char *)me->data + me->b_end;
    }
    else
    {
        return (unsigned char *)me->data + me->a_end;
    }
}",1,,78,3,,void
2416,BLOCK,-1,,<empty>,9,,80,2,,void
2425,BLOCK,-1,,"{
        return (unsigned char *)me->data + me->b_end;
    }",5,,82,2,,void
2437,BLOCK,-1,,"{
        return (unsigned char *)me->data + me->a_end;
    }",5,,86,1,,void
2453,BLOCK,-1,,"{
    if (bipbuf_unused(me) < size)
        return 0;

    if (1 == me->b_inuse)
    {
        me->b_end += size;
    }
    else
    {
        me->a_end += size;
    }

    __check_for_switch_to_b(me);
    return size;
}",1,,92,3,,void
2459,BLOCK,-1,,<empty>,9,,94,2,,void
2468,BLOCK,-1,,"{
        me->b_end += size;
    }",5,,97,2,,void
2475,BLOCK,-1,,"{
        me->a_end += size;
    }",5,,101,1,,void
2491,BLOCK,-1,,"{
    /* not enough space */
    if (bipbuf_unused(me) < size)
        return 0;

    if (1 == me->b_inuse)
    {
        memcpy(me->data + me->b_end, data, size);
        me->b_end += size;
    }
    else
    {
        memcpy(me->data + me->a_end, data, size);
        me->a_end += size;
    }

    __check_for_switch_to_b(me);
    return size;
}",1,,110,4,,void
2497,BLOCK,-1,,<empty>,9,,113,2,,void
2506,BLOCK,-1,,"{
        memcpy(me->data + me->b_end, data, size);
        me->b_end += size;
    }",5,,116,2,,void
2523,BLOCK,-1,,"{
        memcpy(me->data + me->a_end, data, size);
        me->a_end += size;
    }",5,,121,1,,void
2548,BLOCK,-1,,"{
    /* make sure we can actually peek at this data */
    if (me->size < me->a_start + size)
        return NULL;

    if (bipbuf_is_empty(me))
        return NULL;

    return (unsigned char *)me->data + me->a_start;
}",1,,131,3,,void
2559,BLOCK,-1,,<empty>,9,,134,2,,void
2565,BLOCK,-1,,<empty>,9,,137,2,,void
2583,BLOCK,-1,,"{
    if (bipbuf_is_empty(me))
        return NULL;

    *size = me->a_end - me->a_start;
    return (unsigned char*)me->data + me->a_start;
}",1,,143,3,,void
2587,BLOCK,-1,,<empty>,9,,145,2,,void
2615,BLOCK,-1,,"{
    if (bipbuf_is_empty(me))
        return NULL;

    /* make sure we can actually poll this data */
    if (me->size < me->a_start + size)
        return NULL;

    void *end = me->data + me->a_start;
    me->a_start += size;

    /* we seem to be empty.. */
    if (me->a_start == me->a_end)
    {
        /* replace a with region b */
        if (1 == me->b_inuse)
        {
            me->a_start = 0;
            me->a_end = me->b_end;
            me->b_end = me->b_inuse = 0;
        }
        else
            /* safely move cursor back to the start because we are empty */
            me->a_start = me->a_end = 0;
    }

    __check_for_switch_to_b(me);
    return end;
}",1,,152,3,,void
2619,BLOCK,-1,,<empty>,9,,154,2,,void
2632,BLOCK,-1,,<empty>,9,,158,2,,void
2658,BLOCK,-1,,"{
        /* replace a with region b */
        if (1 == me->b_inuse)
        {
            me->a_start = 0;
            me->a_end = me->b_end;
            me->b_end = me->b_inuse = 0;
        }
        else
            /* safely move cursor back to the start because we are empty */
            me->a_start = me->a_end = 0;
    }",5,,165,2,,void
2665,BLOCK,-1,,"{
            me->a_start = 0;
            me->a_end = me->b_end;
            me->b_end = me->b_inuse = 0;
        }",9,,168,2,,void
2688,BLOCK,-1,,<empty>,13,,175,1,,void
2708,BLOCK,-1,,<empty>,1,,1,1,,ANY
2717,BLOCK,-1,,<empty>,,,,1,,<empty>
2724,BLOCK,-1,,<empty>,,,,2,,<empty>
2730,BLOCK,-1,,<empty>,,,,3,,<empty>
2735,BLOCK,-1,,<empty>,,,,2,,<empty>
2741,BLOCK,-1,,<empty>,,,,3,,<empty>
2747,BLOCK,-1,,<empty>,,,,3,,<empty>
2754,BLOCK,-1,,<empty>,,,,4,,<empty>
2760,BLOCK,-1,,<empty>,,,,3,,<empty>
2766,BLOCK,-1,,<empty>,,,,3,,<empty>
2772,BLOCK,-1,,<empty>,,,,3,,<empty>
2777,BLOCK,-1,,<empty>,,,,2,,<empty>
2782,BLOCK,-1,,<empty>,,,,2,,<empty>
2787,BLOCK,-1,,<empty>,,,,2,,<empty>
2792,BLOCK,-1,,<empty>,,,,2,,<empty>
2811,BLOCK,-1,,<empty>,1,,1,1,,ANY
2824,BLOCK,-1,,"{
    cache_t* ret = calloc(1, sizeof(cache_t));
    char* nm = strdup(name);
    if (ret == NULL || nm == NULL ||
        pthread_mutex_init(&ret->mutex, NULL) == -1) {
        free(ret);
        free(nm);
        return NULL;
    }

    ret->name = nm;
    STAILQ_INIT(&ret->head);

#ifndef NDEBUG
    ret->bufsize = bufsize + 2 * sizeof(redzone_pattern);
#else
    ret->bufsize = bufsize;
#endif
    assert(ret->bufsize >= sizeof(struct cache_free_s));

    return ret;
}",71,,18,4,,void
2855,BLOCK,-1,,"{
        free(ret);
        free(nm);
        return NULL;
    }",54,,22,2,,void
2872,BLOCK,1,,<empty>,,,,5,,void
2874,BLOCK,-1,,STAILQ_INIT(&ret->head),5,,29,1,,void
2922,BLOCK,-1,,"{
    pthread_mutex_lock(&cache->mutex);
    cache->limit = limit;
    pthread_mutex_unlock(&cache->mutex);
}",49,,41,3,,void
2942,BLOCK,-1,,"{
#ifndef NDEBUG
    uint64_t *pre = ptr;
    return pre + 1;
#else
    return ptr;
#endif
}",43,,47,2,,void
2955,BLOCK,-1,,"{
    while (!STAILQ_EMPTY(&cache->head)) {
        struct cache_free_s *o = STAILQ_FIRST(&cache->head);
        STAILQ_REMOVE_HEAD(&cache->head, c_next);
        free(o);
    }
    free(cache->name);
    pthread_mutex_destroy(&cache->mutex);
    free(cache);
}",36,,56,2,,void
2963,BLOCK,1,,<empty>,,,,2,,void
2972,BLOCK,-1,,"{
        struct cache_free_s *o = STAILQ_FIRST(&cache->head);
        STAILQ_REMOVE_HEAD(&cache->head, c_next);
        free(o);
    }",41,,57,2,,void
2981,BLOCK,1,,<empty>,,,,2,,void
2993,BLOCK,1,,<empty>,,,,2,,void
2995,BLOCK,-1,,"STAILQ_REMOVE_HEAD(&cache->head, c_next)",9,,59,1,,void
3016,BLOCK,-1,,<empty>,9,,59,2,,void
3049,BLOCK,-1,,"{
    void *ret;
    pthread_mutex_lock(&cache->mutex);
    ret = do_cache_alloc(cache);
    pthread_mutex_unlock(&cache->mutex);
    return ret;
}",35,,67,2,,void
3071,BLOCK,-1,,"{
    void *ret;
    void *object;
    if (cache->freecurr > 0) {
        ret = STAILQ_FIRST(&cache->head);
        STAILQ_REMOVE_HEAD(&cache->head, c_next);
        object = get_object(ret);
        cache->freecurr--;
    } else if (cache->limit == 0 || cache->total < cache->limit) {
        object = ret = malloc(cache->bufsize);
        if (ret != NULL) {
            object = get_object(ret);

            cache->total++;
        }
    } else {
        object = NULL;
    }

#ifndef NDEBUG
    if (object != NULL) {
        /* add a simple form of buffer-check */
        uint64_t *pre = ret;
        *pre = redzone_pattern;
        ret = pre+1;
        memcpy(((char*)ret) + cache->bufsize - (2 * sizeof(redzone_pattern)),
               &redzone_pattern, sizeof(redzone_pattern));
    }
#endif

    return object;
}",38,,75,2,,void
3080,BLOCK,-1,,"{
        ret = STAILQ_FIRST(&cache->head);
        STAILQ_REMOVE_HEAD(&cache->head, c_next);
        object = get_object(ret);
        cache->freecurr--;
    }",30,,78,2,,void
3088,BLOCK,1,,<empty>,,,,2,,void
3100,BLOCK,1,,<empty>,,,,2,,void
3102,BLOCK,-1,,"STAILQ_REMOVE_HEAD(&cache->head, c_next)",9,,80,1,,void
3123,BLOCK,-1,,<empty>,9,,80,2,,void
3148,BLOCK,-1,,<empty>,12,,83,1,,void
3163,BLOCK,-1,,"{
        object = ret = malloc(cache->bufsize);
        if (ret != NULL) {
            object = get_object(ret);

            cache->total++;
        }
    }",66,,83,2,,void
3176,BLOCK,-1,,"{
            object = get_object(ret);

            cache->total++;
        }",26,,85,2,,void
3186,BLOCK,-1,,"{
        object = NULL;
    }",12,,90,1,,void
3194,BLOCK,-1,,"{
        /* add a simple form of buffer-check */
        uint64_t *pre = ret;
        *pre = redzone_pattern;
        ret = pre+1;
        memcpy(((char*)ret) + cache->bufsize - (2 * sizeof(redzone_pattern)),
               &redzone_pattern, sizeof(redzone_pattern));
    }",25,,95,2,,void
3232,BLOCK,-1,,"{
    pthread_mutex_lock(&cache->mutex);
    do_cache_free(cache, ptr);
    pthread_mutex_unlock(&cache->mutex);
}",44,,108,3,,void
3251,BLOCK,-1,,"{
#ifndef NDEBUG
    /* validate redzone... */
    if (memcmp(((char*)ptr) + cache->bufsize - (2 * sizeof(redzone_pattern)),
               &redzone_pattern, sizeof(redzone_pattern)) != 0) {
        raise(SIGABRT);
        cache_error = 1;
        return;
    }
    uint64_t *pre = ptr;
    --pre;
    if (*pre != redzone_pattern) {
        raise(SIGABRT);
        cache_error = -1;
        return;
    }
    ptr = pre;
#endif
    if (cache->limit != 0 && cache->limit < cache->total) {
        free(ptr);
        cache->total--;
    } else {
        STAILQ_INSERT_HEAD(&cache->head, (struct cache_free_s *)ptr, c_next);
        cache->freecurr++;
    }
}",47,,114,3,,void
3272,BLOCK,-1,,"{
        raise(SIGABRT);
        cache_error = 1;
        return;
    }",65,,118,2,,void
3290,BLOCK,-1,,"{
        raise(SIGABRT);
        cache_error = -1;
        return;
    }",34,,125,2,,void
3315,BLOCK,-1,,"{
        free(ptr);
        cache->total--;
    }",59,,132,2,,void
3323,BLOCK,-1,,"{
        STAILQ_INSERT_HEAD(&cache->head, (struct cache_free_s *)ptr, c_next);
        cache->freecurr++;
    }",12,,135,1,,void
3329,BLOCK,1,,<empty>,,,,2,,void
3331,BLOCK,-1,,"STAILQ_INSERT_HEAD(&cache->head, (struct cache_free_s *)ptr, c_next)",9,,136,1,,void
3349,BLOCK,-1,,<empty>,9,,136,2,,void
3390,BLOCK,-1,,<empty>,1,,1,1,,ANY
3416,BLOCK,-1,,<empty>,,,,4,,<empty>
3421,BLOCK,-1,,<empty>,,,,2,,<empty>
3426,BLOCK,-1,,<empty>,,,,2,,<empty>
3431,BLOCK,-1,,<empty>,,,,2,,<empty>
3437,BLOCK,-1,,<empty>,,,,3,,<empty>
3443,BLOCK,-1,,<empty>,,,,3,,<empty>
3449,BLOCK,-1,,<empty>,,,,3,,<empty>
3488,BLOCK,-1,,<empty>,1,,1,1,,ANY
3502,BLOCK,-1,,<empty>,,,,5,,<empty>
3508,BLOCK,-1,,<empty>,,,,3,,<empty>
3513,BLOCK,-1,,<empty>,,,,2,,<empty>
3519,BLOCK,-1,,<empty>,,,,3,,<empty>
3524,BLOCK,-1,,<empty>,,,,2,,<empty>
3542,BLOCK,-1,,<empty>,,,,3,,<empty>
3548,BLOCK,-1,,<empty>,,,,3,,<empty>
3553,BLOCK,-1,,<empty>,,,,2,,<empty>
3561,BLOCK,-1,,<empty>,,,,5,,<empty>
3568,BLOCK,1,,<empty>,5,,63,1,,void
3572,BLOCK,2,,<empty>,5,,64,2,,void
3576,BLOCK,3,,<empty>,5,,65,3,,void
3580,BLOCK,4,,<empty>,5,,66,4,,void
3584,BLOCK,5,,<empty>,5,,67,5,,void
3588,BLOCK,6,,<empty>,5,,68,6,,void
3597,BLOCK,-1,,<empty>,,,,5,,<empty>
3602,BLOCK,-1,,<empty>,,,,2,,<empty>
3609,BLOCK,1,,<empty>,5,,75,1,,void
3613,BLOCK,2,,<empty>,5,,76,2,,void
3617,BLOCK,3,,<empty>,5,,77,3,,void
3621,BLOCK,4,,<empty>,5,,78,4,,void
3625,BLOCK,5,,<empty>,5,,79,5,,void
3629,BLOCK,6,,<empty>,5,,80,6,,void
3645,BLOCK,-1,,<empty>,,,,2,,<empty>
3654,BLOCK,1,,<empty>,,,,1,,void
3678,BLOCK,-1,,"{
    //fprintf(stderr, ""CRAWLER: Closing client\n"");
    sidethread_conn_close(c->c);
    c->c = NULL;
    c->cbuf = NULL;
    bipbuf_free(c->buf);
    c->buf = NULL;
}",59,,112,2,,void
3706,BLOCK,-1,,"{
    //fprintf(stderr, ""CRAWLER: Closing client\n"");
    redispatch_conn(c->c);
    c->c = NULL;
    c->cbuf = NULL;
    bipbuf_free(c->buf);
    c->buf = NULL;
}",61,,121,2,,void
3735,BLOCK,-1,,"{
    struct crawler_expired_data *d;
    if (data != NULL) {
        d = data;
        d->is_external = true;
        cm->data = data;
    } else {
        // allocate data.
        d = calloc(1, sizeof(struct crawler_expired_data));
        if (d == NULL) {
            return -1;
        }
        // init lock.
        pthread_mutex_init(&d->lock, NULL);
        d->is_external = false;
        d->start_time = current_time;

        cm->data = d;
    }
    pthread_mutex_lock(&d->lock);
    memset(&d->crawlerstats, 0, sizeof(crawlerstats_t) * POWER_LARGEST);
    for (int x = 0; x < POWER_LARGEST; x++) {
        d->crawlerstats[x].start_time = current_time;
        d->crawlerstats[x].run_complete = false;
    }
    pthread_mutex_unlock(&d->lock);
    return 0;
}",67,,130,3,,void
3741,BLOCK,-1,,"{
        d = data;
        d->is_external = true;
        cm->data = data;
    }",23,,132,2,,void
3756,BLOCK,-1,,"{
        // allocate data.
        d = calloc(1, sizeof(struct crawler_expired_data));
        if (d == NULL) {
            return -1;
        }
        // init lock.
        pthread_mutex_init(&d->lock, NULL);
        d->is_external = false;
        d->start_time = current_time;

        cm->data = d;
    }",12,,136,1,,void
3767,BLOCK,-1,,"{
            return -1;
        }",24,,139,2,,void
3807,BLOCK,1,,<empty>,,,,1,,void
3810,BLOCK,-1,,<empty>,5,,151,1,,void
3818,BLOCK,1,,<empty>,,,,1,,void
3822,BLOCK,4,,"{
        d->crawlerstats[x].start_time = current_time;
        d->crawlerstats[x].run_complete = false;
    }",45,,151,4,,void
3853,BLOCK,-1,,"{
    struct crawler_expired_data *d = (struct crawler_expired_data *) cm->data;
    pthread_mutex_lock(&d->lock);
    d->crawlerstats[slab_cls].end_time = current_time;
    d->crawlerstats[slab_cls].run_complete = true;
    pthread_mutex_unlock(&d->lock);
}",75,,159,3,,void
3894,BLOCK,-1,,"{
    struct crawler_expired_data *d = (struct crawler_expired_data *) cm->data;
    pthread_mutex_lock(&d->lock);
    d->end_time = current_time;
    d->crawl_complete = true;
    pthread_mutex_unlock(&d->lock);

    if (!d->is_external) {
        free(d);
    }
}",60,,167,2,,void
3928,BLOCK,-1,,"{
        free(d);
    }",26,,174,2,,void
3938,BLOCK,-1,,"{
    struct crawler_expired_data *d = (struct crawler_expired_data *) cm->data;
    pthread_mutex_lock(&d->lock);
    crawlerstats_t *s = &d->crawlerstats[i];
    int is_flushed = item_is_flushed(search);
#ifdef EXTSTORE
    bool is_valid = true;
    if (search->it_flags & ITEM_HDR) {
        is_valid = storage_validate_item(storage, search);
    }
#endif
    if ((search->exptime != 0 && search->exptime < current_time)
        || is_flushed
#ifdef EXTSTORE
        || !is_valid
#endif
        ) {
        crawlers[i].reclaimed++;
        s->reclaimed++;

        if (settings.verbose > 1) {
            int ii;
            char *key = ITEM_key(search);
            fprintf(stderr, ""LRU crawler found an expired item (flags: %d, slab: %d): "",
                search->it_flags, search->slabs_clsid);
            for (ii = 0; ii < search->nkey; ++ii) {
                fprintf(stderr, ""%c"", key[ii]);
            }
            fprintf(stderr, ""\n"");
        }
        if ((search->it_flags & ITE...",90,,182,5,,void
3980,BLOCK,-1,,"{
        crawlers[i].reclaimed++;
        s->reclaimed++;

        if (settings.verbose > 1) {
            int ii;
            char *key = ITEM_key(search);
            fprintf(stderr, ""LRU crawler found an expired item (flags: %d, slab: %d): "",
                search->it_flags, search->slabs_clsid);
            for (ii = 0; ii < search->nkey; ++ii) {
                fprintf(stderr, ""%c"", key[ii]);
            }
            fprintf(stderr, ""\n"");
        }
        if ((search->it_flags & ITEM_FETCHED) == 0 && !is_flushed) {
            crawlers[i].unfetched++;
        }
#ifdef EXTSTORE
        STORAGE_delete(storage, search);
#endif
        do_item_unlink_nolock(search, hv);
        do_item_remove(search);
    }",11,,198,2,,void
3997,BLOCK,-1,,"{
            int ii;
            char *key = ITEM_key(search);
            fprintf(stderr, ""LRU crawler found an expired item (flags: %d, slab: %d): "",
                search->it_flags, search->slabs_clsid);
            for (ii = 0; ii < search->nkey; ++ii) {
                fprintf(stderr, ""%c"", key[ii]);
            }
            fprintf(stderr, ""\n"");
        }",35,,202,2,,void
4004,BLOCK,1,,<empty>,,,,2,,void
4031,BLOCK,-1,,<empty>,13,,207,1,,void
4042,BLOCK,4,,"{
                fprintf(stderr, ""%c"", key[ii]);
            }",51,,207,4,,void
4060,BLOCK,1,,<empty>,,,,1,,void
4065,BLOCK,-1,,"{
            crawlers[i].unfetched++;
        }",68,,212,2,,void
4078,BLOCK,-1,,"{
        s->seen++;
        refcount_decr(search);
        if (search->exptime == 0) {
            s->noexp++;
        } else if (search->exptime - current_time > 3599) {
            s->ttl_hourplus++;
        } else {
            rel_time_t ttl_remain = search->exptime - current_time;
            int bucket = ttl_remain / 60;
            if (bucket <= 60) {
                s->histo[bucket]++;
            }
        }
    }",12,,220,1,,void
4085,BLOCK,1,,<empty>,,,,2,,void
4096,BLOCK,-1,,"{
            s->noexp++;
        }",35,,223,2,,void
4102,BLOCK,-1,,<empty>,16,,225,1,,void
4111,BLOCK,-1,,"{
            s->ttl_hourplus++;
        }",59,,225,2,,void
4117,BLOCK,-1,,"{
            rel_time_t ttl_remain = search->exptime - current_time;
            int bucket = ttl_remain / 60;
            if (bucket <= 60) {
                s->histo[bucket]++;
            }
        }",16,,227,1,,void
4136,BLOCK,-1,,"{
                s->histo[bucket]++;
            }",31,,230,2,,void
4155,BLOCK,-1,,"{
    //int slab_id = CLEAR_LRU(i);
    char keybuf[KEY_MAX_URI_ENCODED_LENGTH];
    int is_flushed = item_is_flushed(it);
    /* Ignore expired content. */
    if ((it->exptime != 0 && it->exptime < current_time)
        || is_flushed) {
        refcount_decr(it);
        return;
    }
    // TODO: uriencode directly into the buffer.
    uriencode(ITEM_key(it), keybuf, it->nkey, KEY_MAX_URI_ENCODED_LENGTH);
    int total = snprintf(cm->c.cbuf, 4096,
            ""key=%s exp=%ld la=%llu cas=%llu fetch=%s cls=%u size=%lu\n"",
            keybuf,
            (it->exptime == 0) ? -1 : (long)(it->exptime + process_started),
            (unsigned long long)(it->time + process_started),
            (unsigned long long)ITEM_get_cas(it),
            (it->it_flags & ITEM_FETCHED) ? ""yes"" : ""no"",
            ITEM_clsid(it),
            (unsigned long) ITEM_ntotal(it));
    refcount_decr(it);
    // TODO: some way of tracking the errors. these are very unlikely though.
    if (total >= LRU_CRAWL...",87,,238,5,,void
4176,BLOCK,-1,,"{
        refcount_decr(it);
        return;
    }",24,,244,2,,void
4179,BLOCK,1,,<empty>,,,,2,,void
4188,BLOCK,1,,<empty>,,,,2,,void
4210,BLOCK,1,,<empty>,,,,1,,void
4254,BLOCK,1,,<empty>,,,,2,,void
4275,BLOCK,1,,<empty>,,,,1,,void
4281,BLOCK,1,,<empty>,,,,2,,void
4294,BLOCK,1,,<empty>,,,,2,,void
4329,BLOCK,1,,<empty>,,,,2,,void
4340,BLOCK,1,,<empty>,,,,1,,void
4346,BLOCK,-1,,"{
        /* Failed to write, don't push it. */
        return;
    }",58,,261,2,,void
4359,BLOCK,-1,,"{
    if (cm->c.c != NULL) {
        // Ensure space for final message.
        lru_crawler_client_getbuf(&cm->c);
        memcpy(cm->c.cbuf, ""END\r\n"", 5);
        bipbuf_push(cm->c.buf, 5);
    }
}",61,,268,2,,void
4368,BLOCK,-1,,"{
        // Ensure space for final message.
        lru_crawler_client_getbuf(&cm->c);
        memcpy(cm->c.cbuf, ""END\r\n"", 5);
        bipbuf_push(cm->c.buf, 5);
    }",26,,269,2,,void
4393,BLOCK,-1,,"{
    unsigned char *data;
    unsigned int data_size = 0;
    struct pollfd to_poll[1];
    to_poll[0].fd = c->sfd;
    to_poll[0].events = POLLOUT;

    int ret = poll(to_poll, 1, 1000);

    if (ret < 0) {
        // fatal.
        return -1;
    }

    if (ret == 0) return 0;

    if (to_poll[0].revents & POLLIN) {
        char buf[1];
        int res = ((conn*)c->c)->read(c->c, buf, 1);
        if (res == 0 || (res == -1 && (errno != EAGAIN && errno != EWOULDBLOCK))) {
            lru_crawler_close_client(c);
            return -1;
        }
    }
    if ((data = bipbuf_peek_all(c->buf, &data_size)) != NULL) {
        if (to_poll[0].revents & (POLLHUP|POLLERR)) {
            lru_crawler_close_client(c);
            return -1;
        } else if (to_poll[0].revents & POLLOUT) {
            int total = ((conn*)c->c)->write(c->c, data, data_size);
            if (total == -1) {
                if (errno != EAGAIN && errno != EWOULDBLOCK) {
                    lru_crawler_close_clie...",50,,277,2,,void
4427,BLOCK,-1,,"{
        // fatal.
        return -1;
    }",18,,286,2,,void
4435,BLOCK,-1,,<empty>,19,,291,2,,void
4446,BLOCK,-1,,"{
        char buf[1];
        int res = ((conn*)c->c)->read(c->c, buf, 1);
        if (res == 0 || (res == -1 && (errno != EAGAIN && errno != EWOULDBLOCK))) {
            lru_crawler_close_client(c);
            return -1;
        }
    }",38,,293,2,,void
4481,BLOCK,-1,,"{
            lru_crawler_close_client(c);
            return -1;
        }",83,,296,2,,void
4498,BLOCK,-1,,"{
        if (to_poll[0].revents & (POLLHUP|POLLERR)) {
            lru_crawler_close_client(c);
            return -1;
        } else if (to_poll[0].revents & POLLOUT) {
            int total = ((conn*)c->c)->write(c->c, data, data_size);
            if (total == -1) {
                if (errno != EAGAIN && errno != EWOULDBLOCK) {
                    lru_crawler_close_client(c);
                    return -1;
                }
            } else if (total == 0) {
                lru_crawler_close_client(c);
                return -1;
            } else {
                bipbuf_poll(c->buf, total);
            }
        }
    }",63,,301,2,,void
4509,BLOCK,-1,,"{
            lru_crawler_close_client(c);
            return -1;
        }",53,,302,2,,void
4516,BLOCK,-1,,<empty>,16,,305,1,,void
4525,BLOCK,-1,,"{
            int total = ((conn*)c->c)->write(c->c, data, data_size);
            if (total == -1) {
                if (errno != EAGAIN && errno != EWOULDBLOCK) {
                    lru_crawler_close_client(c);
                    return -1;
                }
            } else if (total == 0) {
                lru_crawler_close_client(c);
                return -1;
            } else {
                bipbuf_poll(c->buf, total);
            }
        }",50,,305,2,,void
4547,BLOCK,-1,,"{
                if (errno != EAGAIN && errno != EWOULDBLOCK) {
                    lru_crawler_close_client(c);
                    return -1;
                }
            }",30,,307,2,,void
4556,BLOCK,-1,,"{
                    lru_crawler_close_client(c);
                    return -1;
                }",62,,308,2,,void
4563,BLOCK,-1,,<empty>,20,,312,1,,void
4568,BLOCK,-1,,"{
                lru_crawler_close_client(c);
                return -1;
            }",36,,312,2,,void
4575,BLOCK,-1,,"{
                bipbuf_poll(c->buf, total);
            }",20,,315,1,,void
4587,BLOCK,-1,,"{
    void *buf = NULL;
    if (c->c == NULL) return -1;
    /* not enough space. */
    while ((buf = bipbuf_request(c->buf, LRU_CRAWLER_WRITEBUF)) == NULL) {
        // TODO: max loops before closing.
        int ret = lru_crawler_poll(c);
        if (ret < 0) return ret;
    }

    c->cbuf = buf;
    return 0;
}",59,,327,2,,void
4598,BLOCK,-1,,<empty>,23,,329,2,,void
4611,BLOCK,1,,<empty>,,,,1,,void
4614,BLOCK,-1,,"{
        // TODO: max loops before closing.
        int ret = lru_crawler_poll(c);
        if (ret < 0) return ret;
    }",74,,331,2,,void
4624,BLOCK,-1,,<empty>,22,,334,2,,void
4638,BLOCK,-1,,"{
    crawlers[i].it_flags = 0;
    crawler_count--;
    do_item_unlinktail_q((item *)&crawlers[i]);
    do_item_stats_add_crawl(i, crawlers[i].reclaimed,
            crawlers[i].unfetched, crawlers[i].checked);
    pthread_mutex_unlock(&lru_locks[i]);
    if (active_crawler_mod.mod->doneclass != NULL)
        active_crawler_mod.mod->doneclass(&active_crawler_mod, i);
}",43,,341,2,,void
4685,BLOCK,-1,,<empty>,9,,349,2,,void
4699,BLOCK,-1,,"{
    // get iterator from assoc. can hang for a long time.
    // - blocks hash expansion
    void *iter = assoc_get_iterator();
    int crawls_persleep = settings.crawls_persleep;
    item *it = NULL;

    // loop while iterator returns something
    // - iterator func handles bucket-walking
    // - iterator returns with bucket locked.
    while (assoc_iterate(iter, &it)) {
        // if iterator returns true but no item, we're inbetween buckets and
        // can do sleep or cleanup work without holding a lock.
        if (it == NULL) {
            // - sleep bits from orig loop
            if (crawls_persleep-- <= 0 && settings.lru_crawler_sleep) {
                pthread_mutex_unlock(&lru_crawler_lock);
                usleep(settings.lru_crawler_sleep);
                pthread_mutex_lock(&lru_crawler_lock);
                crawls_persleep = settings.crawls_persleep;
            } else if (!settings.lru_crawler_sleep) {
                // TODO: only cycle lock every N?
       ...",35,,352,2,,void
4719,BLOCK,-1,,"{
        // if iterator returns true but no item, we're inbetween buckets and
        // can do sleep or cleanup work without holding a lock.
        if (it == NULL) {
            // - sleep bits from orig loop
            if (crawls_persleep-- <= 0 && settings.lru_crawler_sleep) {
                pthread_mutex_unlock(&lru_crawler_lock);
                usleep(settings.lru_crawler_sleep);
                pthread_mutex_lock(&lru_crawler_lock);
                crawls_persleep = settings.crawls_persleep;
            } else if (!settings.lru_crawler_sleep) {
                // TODO: only cycle lock every N?
                pthread_mutex_unlock(&lru_crawler_lock);
                pthread_mutex_lock(&lru_crawler_lock);
            }
            continue;
        }

        /* Get memory from bipbuf, if client has no space, flush. */
        if (active_crawler_mod.c.c != NULL) {
            int ret = lru_crawler_client_getbuf(&active_crawler_mod.c);
            if (ret != 0) {
           ...",38,,362,2,,void
4724,BLOCK,-1,,"{
            // - sleep bits from orig loop
            if (crawls_persleep-- <= 0 && settings.lru_crawler_sleep) {
                pthread_mutex_unlock(&lru_crawler_lock);
                usleep(settings.lru_crawler_sleep);
                pthread_mutex_lock(&lru_crawler_lock);
                crawls_persleep = settings.crawls_persleep;
            } else if (!settings.lru_crawler_sleep) {
                // TODO: only cycle lock every N?
                pthread_mutex_unlock(&lru_crawler_lock);
                pthread_mutex_lock(&lru_crawler_lock);
            }
            continue;
        }",25,,365,2,,void
4734,BLOCK,-1,,"{
                pthread_mutex_unlock(&lru_crawler_lock);
                usleep(settings.lru_crawler_sleep);
                pthread_mutex_lock(&lru_crawler_lock);
                crawls_persleep = settings.crawls_persleep;
            }",71,,367,2,,void
4751,BLOCK,-1,,<empty>,20,,372,1,,void
4757,BLOCK,-1,,"{
                // TODO: only cycle lock every N?
                pthread_mutex_unlock(&lru_crawler_lock);
                pthread_mutex_lock(&lru_crawler_lock);
            }",53,,372,2,,void
4773,BLOCK,-1,,"{
            int ret = lru_crawler_client_getbuf(&active_crawler_mod.c);
            if (ret != 0) {
                // fail out and finalize.
                break;
            }
        }",45,,381,2,,void
4786,BLOCK,-1,,"{
                // fail out and finalize.
                break;
            }",27,,383,2,,void
4789,BLOCK,-1,,<empty>,16,,387,1,,void
4796,BLOCK,-1,,"{
            // fail out and finalize.
            break;
        }",58,,387,2,,void
4802,BLOCK,1,,<empty>,,,,3,,void
4808,BLOCK,-1,,"{
            refcount_decr(it);
            continue;
        }",36,,393,2,,void
4811,BLOCK,1,,<empty>,,,,3,,void
4835,BLOCK,-1,,"{
    int i;
    int crawls_persleep = settings.crawls_persleep;

    pthread_mutex_lock(&lru_crawler_lock);
    pthread_cond_signal(&lru_crawler_cond);
    settings.lru_crawler = true;
    if (settings.verbose > 2)
        fprintf(stderr, ""Starting LRU crawler background thread\n"");
    while (do_run_lru_crawler_thread) {
    pthread_cond_wait(&lru_crawler_cond, &lru_crawler_lock);

    if (crawler_count == -1) {
        item_crawl_hash();
        crawler_count = 0;
    } else {
    while (crawler_count) {
        item *search = NULL;
        void *hold_lock = NULL;

        for (i = POWER_SMALLEST; i < LARGEST_ID; i++) {
            if (crawlers[i].it_flags != 1) {
                continue;
            }

            /* Get memory from bipbuf, if client has no space, flush. */
            if (active_crawler_mod.c.c != NULL) {
                int ret = lru_crawler_client_getbuf(&active_crawler_mod.c);
                if (ret != 0) {
                    lru_crawler_class_done(i);
  ...",45,,408,2,,void
4860,BLOCK,-1,,<empty>,9,,416,2,,void
4866,BLOCK,-1,,"{
    pthread_cond_wait(&lru_crawler_cond, &lru_crawler_lock);

    if (crawler_count == -1) {
        item_crawl_hash();
        crawler_count = 0;
    } else {
    while (crawler_count) {
        item *search = NULL;
        void *hold_lock = NULL;

        for (i = POWER_SMALLEST; i < LARGEST_ID; i++) {
            if (crawlers[i].it_flags != 1) {
                continue;
            }

            /* Get memory from bipbuf, if client has no space, flush. */
            if (active_crawler_mod.c.c != NULL) {
                int ret = lru_crawler_client_getbuf(&active_crawler_mod.c);
                if (ret != 0) {
                    lru_crawler_class_done(i);
                    continue;
                }
            } else if (active_crawler_mod.mod->needs_client) {
                lru_crawler_class_done(i);
                continue;
            }
            pthread_mutex_lock(&lru_locks[i]);
            search = do_item_crawl_q((item *)&crawlers[i]);
            if (search =...",39,,417,2,,void
4877,BLOCK,-1,,"{
        item_crawl_hash();
        crawler_count = 0;
    }",30,,420,2,,void
4883,BLOCK,-1,,"{
    while (crawler_count) {
        item *search = NULL;
        void *hold_lock = NULL;

        for (i = POWER_SMALLEST; i < LARGEST_ID; i++) {
            if (crawlers[i].it_flags != 1) {
                continue;
            }

            /* Get memory from bipbuf, if client has no space, flush. */
            if (active_crawler_mod.c.c != NULL) {
                int ret = lru_crawler_client_getbuf(&active_crawler_mod.c);
                if (ret != 0) {
                    lru_crawler_class_done(i);
                    continue;
                }
            } else if (active_crawler_mod.mod->needs_client) {
                lru_crawler_class_done(i);
                continue;
            }
            pthread_mutex_lock(&lru_locks[i]);
            search = do_item_crawl_q((item *)&crawlers[i]);
            if (search == NULL ||
                (crawlers[i].remaining && --crawlers[i].remaining < 1)) {
                if (settings.verbose > 2)
                    fprintf(stderr...",12,,423,1,,void
4886,BLOCK,-1,,"{
        item *search = NULL;
        void *hold_lock = NULL;

        for (i = POWER_SMALLEST; i < LARGEST_ID; i++) {
            if (crawlers[i].it_flags != 1) {
                continue;
            }

            /* Get memory from bipbuf, if client has no space, flush. */
            if (active_crawler_mod.c.c != NULL) {
                int ret = lru_crawler_client_getbuf(&active_crawler_mod.c);
                if (ret != 0) {
                    lru_crawler_class_done(i);
                    continue;
                }
            } else if (active_crawler_mod.mod->needs_client) {
                lru_crawler_class_done(i);
                continue;
            }
            pthread_mutex_lock(&lru_locks[i]);
            search = do_item_crawl_q((item *)&crawlers[i]);
            if (search == NULL ||
                (crawlers[i].remaining && --crawlers[i].remaining < 1)) {
                if (settings.verbose > 2)
                    fprintf(stderr, ""Nothing left to crawl for...",27,,424,2,,void
4896,BLOCK,-1,,<empty>,9,,428,1,,void
4900,BLOCK,1,,<empty>,,,,1,,void
4905,BLOCK,1,,<empty>,,,,1,,void
4909,BLOCK,4,,"{
            if (crawlers[i].it_flags != 1) {
                continue;
            }

            /* Get memory from bipbuf, if client has no space, flush. */
            if (active_crawler_mod.c.c != NULL) {
                int ret = lru_crawler_client_getbuf(&active_crawler_mod.c);
                if (ret != 0) {
                    lru_crawler_class_done(i);
                    continue;
                }
            } else if (active_crawler_mod.mod->needs_client) {
                lru_crawler_class_done(i);
                continue;
            }
            pthread_mutex_lock(&lru_locks[i]);
            search = do_item_crawl_q((item *)&crawlers[i]);
            if (search == NULL ||
                (crawlers[i].remaining && --crawlers[i].remaining < 1)) {
                if (settings.verbose > 2)
                    fprintf(stderr, ""Nothing left to crawl for %d\n"", i);
                lru_crawler_class_done(i);
                continue;
            }
            uint32_t hv...",55,,428,4,,void
4918,BLOCK,-1,,"{
                continue;
            }",44,,429,2,,void
4928,BLOCK,-1,,"{
                int ret = lru_crawler_client_getbuf(&active_crawler_mod.c);
                if (ret != 0) {
                    lru_crawler_class_done(i);
                    continue;
                }
            }",49,,434,2,,void
4941,BLOCK,-1,,"{
                    lru_crawler_class_done(i);
                    continue;
                }",31,,436,2,,void
4946,BLOCK,-1,,<empty>,20,,440,1,,void
4953,BLOCK,-1,,"{
                lru_crawler_class_done(i);
                continue;
            }",62,,440,2,,void
4990,BLOCK,-1,,"{
                if (settings.verbose > 2)
                    fprintf(stderr, ""Nothing left to crawl for %d\n"", i);
                lru_crawler_class_done(i);
                continue;
            }",73,,447,2,,void
4997,BLOCK,-1,,<empty>,21,,449,2,,void
5011,BLOCK,1,,<empty>,,,,4,,void
5038,BLOCK,-1,,"{
                pthread_mutex_unlock(&lru_locks[i]);
                continue;
            }",57,,457,2,,void
5049,BLOCK,1,,<empty>,,,,3,,void
5055,BLOCK,-1,,"{
                refcount_decr(search);
                if (hold_lock)
                    item_trylock_unlock(hold_lock);
                pthread_mutex_unlock(&lru_locks[i]);
                continue;
            }",45,,462,2,,void
5058,BLOCK,1,,<empty>,,,,3,,void
5065,BLOCK,-1,,<empty>,21,,465,2,,void
5087,BLOCK,-1,,"{
                pthread_mutex_unlock(&lru_locks[i]);
            }",54,,474,2,,void
5106,BLOCK,-1,,<empty>,17,,481,2,,void
5115,BLOCK,-1,,"{
                pthread_mutex_unlock(&lru_locks[i]);
            }",53,,482,2,,void
5130,BLOCK,-1,,"{
                pthread_mutex_unlock(&lru_crawler_lock);
                usleep(settings.lru_crawler_sleep);
                pthread_mutex_lock(&lru_crawler_lock);
                crawls_persleep = settings.crawls_persleep;
            }",71,,486,2,,void
5147,BLOCK,-1,,<empty>,20,,491,1,,void
5153,BLOCK,-1,,"{
                // TODO: only cycle lock every N?
                pthread_mutex_unlock(&lru_crawler_lock);
                pthread_mutex_lock(&lru_crawler_lock);
            }",53,,491,2,,void
5166,BLOCK,-1,,"{
        if (active_crawler_mod.mod->finalize != NULL)
            active_crawler_mod.mod->finalize(&active_crawler_mod);
        while (active_crawler_mod.c.c != NULL && bipbuf_used(active_crawler_mod.c.buf)) {
            lru_crawler_poll(&active_crawler_mod.c);
        }
        // Double checking in case the client closed during the poll
        if (active_crawler_mod.c.c != NULL) {
            lru_crawler_release_client(&active_crawler_mod.c);
        }
        active_crawler_mod.mod = NULL;
    }",41,,500,2,,void
5175,BLOCK,-1,,<empty>,13,,502,2,,void
5199,BLOCK,-1,,"{
            lru_crawler_poll(&active_crawler_mod.c);
        }",89,,503,2,,void
5213,BLOCK,-1,,"{
            lru_crawler_release_client(&active_crawler_mod.c);
        }",45,,507,2,,void
5230,BLOCK,-1,,<empty>,9,,514,2,,void
5250,BLOCK,-1,,<empty>,9,,522,2,,void
5266,BLOCK,-1,,"{
    int ret;
    pthread_mutex_lock(&lru_crawler_lock);
    if (do_run_lru_crawler_thread == 0) {
        pthread_mutex_unlock(&lru_crawler_lock);
        return 0;
    }
    do_run_lru_crawler_thread = 0;
    pthread_cond_signal(&lru_crawler_cond);
    pthread_mutex_unlock(&lru_crawler_lock);
    if (wait && (ret = pthread_join(item_crawler_tid, NULL)) != 0) {
        fprintf(stderr, ""Failed to stop LRU crawler thread: %s\n"", strerror(ret));
        return -1;
    }
    return 0;
}",41,,530,2,,void
5275,BLOCK,-1,,"{
        pthread_mutex_unlock(&lru_crawler_lock);
        return 0;
    }",41,,533,2,,void
5300,BLOCK,-1,,"{
        fprintf(stderr, ""Failed to stop LRU crawler thread: %s\n"", strerror(ret));
        return -1;
    }",68,,540,2,,void
5315,BLOCK,-1,,"{
    int ret;

    if (settings.lru_crawler)
        return -1;
    pthread_mutex_lock(&lru_crawler_lock);
    do_run_lru_crawler_thread = 1;
    if ((ret = pthread_create(&item_crawler_tid, NULL,
        item_crawler_thread, NULL)) != 0) {
        fprintf(stderr, ""Can't create LRU crawler thread: %s\n"",
            strerror(ret));
        pthread_mutex_unlock(&lru_crawler_lock);
        return -1;
    }
    /* Avoid returning until the crawler has actually started */
    pthread_cond_wait(&lru_crawler_cond, &lru_crawler_lock);
    pthread_mutex_unlock(&lru_crawler_lock);

    return 0;
}",37,,558,2,,void
5321,BLOCK,-1,,<empty>,9,,562,2,,void
5342,BLOCK,-1,,"{
        fprintf(stderr, ""Can't create LRU crawler thread: %s\n"",
            strerror(ret));
        pthread_mutex_unlock(&lru_crawler_lock);
        return -1;
    }",43,,566,2,,void
5369,BLOCK,-1,,"{
    uint32_t sid = id;
    int starts = 0;

    pthread_mutex_lock(&lru_locks[sid]);
    if (crawlers[sid].it_flags == 0) {
        if (settings.verbose > 2)
            fprintf(stderr, ""Kicking LRU crawler off for LRU %u\n"", sid);
        crawlers[sid].nbytes = 0;
        crawlers[sid].nkey = 0;
        crawlers[sid].it_flags = 1; /* For a crawler, this means enabled. */
        crawlers[sid].next = 0;
        crawlers[sid].prev = 0;
        crawlers[sid].time = 0;
        if (remaining == LRU_CRAWLER_CAP_REMAINING) {
            remaining = do_get_lru_size(sid);
        }
        /* Values for remaining:
         * remaining = 0
         * - scan all elements, until a NULL is reached
         * - if empty, NULL is reached right away
         * remaining = n + 1
         * - first n elements are parsed (or until a NULL is reached)
         */
        if (remaining) remaining++;
        crawlers[sid].remaining = remaining;
        crawlers[sid].slabs_clsid = sid;
        crawlers[...",66,,582,3,,void
5391,BLOCK,-1,,"{
        if (settings.verbose > 2)
            fprintf(stderr, ""Kicking LRU crawler off for LRU %u\n"", sid);
        crawlers[sid].nbytes = 0;
        crawlers[sid].nkey = 0;
        crawlers[sid].it_flags = 1; /* For a crawler, this means enabled. */
        crawlers[sid].next = 0;
        crawlers[sid].prev = 0;
        crawlers[sid].time = 0;
        if (remaining == LRU_CRAWLER_CAP_REMAINING) {
            remaining = do_get_lru_size(sid);
        }
        /* Values for remaining:
         * remaining = 0
         * - scan all elements, until a NULL is reached
         * - if empty, NULL is reached right away
         * remaining = n + 1
         * - first n elements are parsed (or until a NULL is reached)
         */
        if (remaining) remaining++;
        crawlers[sid].remaining = remaining;
        crawlers[sid].slabs_clsid = sid;
        crawlers[sid].reclaimed = 0;
        crawlers[sid].unfetched = 0;
        crawlers[sid].checked = 0;
        do_item_linktail_q((item...",38,,587,2,,void
5398,BLOCK,-1,,<empty>,13,,589,2,,void
5449,BLOCK,1,,<empty>,,,,1,,void
5452,BLOCK,-1,,"{
            remaining = do_get_lru_size(sid);
        }",53,,596,2,,void
5459,BLOCK,-1,,<empty>,24,,606,2,,void
5521,BLOCK,-1,,"{
    crawler_client_t *crawlc = &cm->c;
    if (crawlc->c != NULL) {
        return -1;
    }
    crawlc->c = c;
    crawlc->sfd = sfd;

    crawlc->buf = bipbuf_new(1024 * 128);
    if (crawlc->buf == NULL) {
        return -2;
    }
    return 0;
}",81,,620,4,,void
5535,BLOCK,-1,,"{
        return -1;
    }",28,,622,2,,void
5563,BLOCK,-1,,"{
        return -2;
    }",30,,629,2,,void
5578,BLOCK,-1,,"{
    int starts = 0;
    bool is_running;
    static rel_time_t block_ae_until = 0;
    pthread_mutex_lock(&lru_crawler_lock);
    STATS_LOCK();
    is_running = stats_state.lru_crawler_running;
    STATS_UNLOCK();
    if (do_run_lru_crawler_thread == 0) {
        pthread_mutex_unlock(&lru_crawler_lock);
        return -2;
    }

    if (is_running &&
            !(type == CRAWLER_AUTOEXPIRE && active_crawler_type == CRAWLER_AUTOEXPIRE)) {
        pthread_mutex_unlock(&lru_crawler_lock);
        block_ae_until = current_time + 60;
        return -1;
    }

    if (type == CRAWLER_AUTOEXPIRE && block_ae_until > current_time) {
        pthread_mutex_unlock(&lru_crawler_lock);
        return -1;
    }

    /* hash table walk only supported with metadump for now. */
    if (type != CRAWLER_METADUMP && ids == NULL) {
        pthread_mutex_unlock(&lru_crawler_lock);
        return -2;
    }

    /* Configure the module */
    if (!is_running) {
        assert(crawler_mod_regs[type] != NU...",54,,637,7,,void
5602,BLOCK,-1,,"{
        pthread_mutex_unlock(&lru_crawler_lock);
        return -2;
    }",41,,645,2,,void
5620,BLOCK,-1,,"{
        pthread_mutex_unlock(&lru_crawler_lock);
        block_ae_until = current_time + 60;
        return -1;
    }",89,,651,2,,void
5640,BLOCK,-1,,"{
        pthread_mutex_unlock(&lru_crawler_lock);
        return -1;
    }",70,,657,2,,void
5655,BLOCK,-1,,"{
        pthread_mutex_unlock(&lru_crawler_lock);
        return -2;
    }",50,,663,2,,void
5665,BLOCK,-1,,"{
        assert(crawler_mod_regs[type] != NULL);
        active_crawler_mod.mod = crawler_mod_regs[type];
        active_crawler_type = type;
        if (active_crawler_mod.mod->init != NULL) {
            active_crawler_mod.mod->init(&active_crawler_mod, data);
        }
        if (active_crawler_mod.mod->needs_client) {
            if (c == NULL || sfd == 0) {
                pthread_mutex_unlock(&lru_crawler_lock);
                return -2;
            }
            if (lru_crawler_set_client(&active_crawler_mod, c, sfd) != 0) {
                pthread_mutex_unlock(&lru_crawler_lock);
                return -2;
            }
        }
    }",22,,669,2,,void
5690,BLOCK,-1,,"{
            active_crawler_mod.mod->init(&active_crawler_mod, data);
        }",51,,673,2,,void
5706,BLOCK,-1,,"{
            if (c == NULL || sfd == 0) {
                pthread_mutex_unlock(&lru_crawler_lock);
                return -2;
            }
            if (lru_crawler_set_client(&active_crawler_mod, c, sfd) != 0) {
                pthread_mutex_unlock(&lru_crawler_lock);
                return -2;
            }
        }",51,,676,2,,void
5715,BLOCK,-1,,"{
                pthread_mutex_unlock(&lru_crawler_lock);
                return -2;
            }",40,,677,2,,void
5730,BLOCK,-1,,"{
                pthread_mutex_unlock(&lru_crawler_lock);
                return -2;
            }",75,,681,2,,void
5741,BLOCK,-1,,"{
        /* NULL ids means to walk the hash table instead. */
        starts = 1;
        /* FIXME: hack to signal hash mode to the crawler thread.
         * Something more clear would be nice.
         */
        crawler_count = -1;
    }",22,,688,2,,void
5750,BLOCK,-1,,"{
        /* we allow the autocrawler to restart sub-LRU's before completion */
        for (int sid = POWER_SMALLEST; sid < POWER_LARGEST; sid++) {
            if (ids[sid])
                starts += do_lru_crawler_start(sid, remaining);
        }
    }",12,,695,1,,void
5752,BLOCK,-1,,<empty>,9,,697,1,,void
5757,BLOCK,1,,<empty>,,,,1,,void
5762,BLOCK,1,,<empty>,,,,1,,void
5766,BLOCK,4,,"{
            if (ids[sid])
                starts += do_lru_crawler_start(sid, remaining);
        }",68,,697,4,,void
5771,BLOCK,-1,,<empty>,17,,699,2,,void
5779,BLOCK,-1,,"{
        STATS_LOCK();
        stats_state.lru_crawler_running = true;
        stats.lru_crawler_starts++;
        STATS_UNLOCK();
        pthread_cond_signal(&lru_crawler_cond);
    }",17,,702,2,,void
5807,BLOCK,-1,,"{
    char *b = NULL;
    uint32_t sid = 0;
    int starts = 0;
    uint8_t tocrawl[POWER_LARGEST];
    bool hash_crawl = false;

    /* FIXME: I added this while debugging. Don't think it's needed? */
    memset(tocrawl, 0, sizeof(uint8_t) * POWER_LARGEST);
    if (strcmp(slabs, ""all"") == 0) {
        for (sid = 0; sid < POWER_LARGEST; sid++) {
            tocrawl[sid] = 1;
        }
    } else if (strcmp(slabs, ""hash"") == 0) {
        hash_crawl = true;
    } else {
        for (char *p = strtok_r(slabs, "","", &b);
             p != NULL;
             p = strtok_r(NULL, "","", &b)) {

            if (!safe_strtoul(p, &sid) || sid < POWER_SMALLEST
                    || sid >= MAX_NUMBER_OF_SLAB_CLASSES) {
                return CRAWLER_BADCLASS;
            }
            tocrawl[sid | TEMP_LRU] = 1;
            tocrawl[sid | HOT_LRU] = 1;
            tocrawl[sid | WARM_LRU] = 1;
            tocrawl[sid | COLD_LRU] = 1;
        }
    }

    starts = lru_crawler_start(hash_crawl ? NULL...",57,,717,6,,void
5832,BLOCK,1,,<empty>,,,,1,,void
5840,BLOCK,-1,,"{
        for (sid = 0; sid < POWER_LARGEST; sid++) {
            tocrawl[sid] = 1;
        }
    }",36,,726,2,,void
5842,BLOCK,-1,,<empty>,9,,727,1,,void
5849,BLOCK,1,,<empty>,,,,1,,void
5853,BLOCK,4,,"{
            tocrawl[sid] = 1;
        }",51,,727,4,,void
5860,BLOCK,-1,,<empty>,12,,730,1,,void
5867,BLOCK,-1,,"{
        hash_crawl = true;
    }",44,,730,2,,void
5872,BLOCK,-1,,"{
        for (char *p = strtok_r(slabs, "","", &b);
             p != NULL;
             p = strtok_r(NULL, "","", &b)) {

            if (!safe_strtoul(p, &sid) || sid < POWER_SMALLEST
                    || sid >= MAX_NUMBER_OF_SLAB_CLASSES) {
                return CRAWLER_BADCLASS;
            }
            tocrawl[sid | TEMP_LRU] = 1;
            tocrawl[sid | HOT_LRU] = 1;
            tocrawl[sid | WARM_LRU] = 1;
            tocrawl[sid | COLD_LRU] = 1;
        }
    }",12,,732,1,,void
5874,BLOCK,-1,,<empty>,9,,733,1,,void
5893,BLOCK,4,,"{

            if (!safe_strtoul(p, &sid) || sid < POWER_SMALLEST
                    || sid >= MAX_NUMBER_OF_SLAB_CLASSES) {
                return CRAWLER_BADCLASS;
            }
            tocrawl[sid | TEMP_LRU] = 1;
            tocrawl[sid | HOT_LRU] = 1;
            tocrawl[sid | WARM_LRU] = 1;
            tocrawl[sid | COLD_LRU] = 1;
        }",43,,735,4,,void
5905,BLOCK,1,,<empty>,,,,1,,void
5910,BLOCK,1,,<empty>,,,,1,,void
5914,BLOCK,-1,,"{
                return CRAWLER_BADCLASS;
            }",59,,738,2,,void
5923,BLOCK,1,,<empty>,,,,1,,void
5932,BLOCK,1,,<empty>,,,,1,,void
5941,BLOCK,1,,<empty>,,,,1,,void
5950,BLOCK,1,,<empty>,,,,1,,void
5970,BLOCK,-1,,"{
        return CRAWLER_RUNNING;
    }",23,,749,2,,void
5974,BLOCK,-1,,<empty>,12,,751,1,,void
5980,BLOCK,-1,,"{
        return CRAWLER_ERROR; /* FIXME: not very helpful. */
    }",30,,751,2,,void
5984,BLOCK,-1,,<empty>,12,,753,1,,void
5987,BLOCK,-1,,"{
        return CRAWLER_OK;
    }",24,,753,2,,void
5991,BLOCK,-1,,"{
        return CRAWLER_NOTSTARTED;
    }",12,,755,1,,void
5998,BLOCK,-1,,"{
    pthread_mutex_lock(&lru_crawler_lock);
}",30,,761,2,,void
6006,BLOCK,-1,,"{
    pthread_mutex_unlock(&lru_crawler_lock);
}",31,,765,2,,void
6014,BLOCK,-1,,"{
    if (lru_crawler_initialized == 0) {
#ifdef EXTSTORE
        storage = arg;
#endif
        active_crawler_mod.c.c = NULL;
        active_crawler_mod.mod = NULL;
        active_crawler_mod.data = NULL;
        lru_crawler_initialized = 1;
    }
    return 0;
}",33,,769,2,,void
6019,BLOCK,-1,,"{
#ifdef EXTSTORE
        storage = arg;
#endif
        active_crawler_mod.c.c = NULL;
        active_crawler_mod.mod = NULL;
        active_crawler_mod.data = NULL;
        lru_crawler_initialized = 1;
    }",39,,770,2,,void
6048,BLOCK,-1,,<empty>,1,,1,1,,ANY
6059,BLOCK,-1,,<empty>,,,,1,,<empty>
6073,BLOCK,-1,,<empty>,,,,1,,<empty>
6085,BLOCK,-1,,<empty>,,,,1,,<empty>
6093,BLOCK,-1,,<empty>,,,,2,,<empty>
6098,BLOCK,-1,,<empty>,,,,2,,<empty>
6103,BLOCK,-1,,<empty>,,,,2,,<empty>
6115,BLOCK,-1,,<empty>,,,,7,,<empty>
6120,BLOCK,-1,,<empty>,,,,2,,<empty>
6125,BLOCK,-1,,<empty>,,,,2,,<empty>
6140,BLOCK,-1,,<empty>,1,,1,1,,ANY
6146,BLOCK,-1,,<empty>,,,,4,,<empty>
6153,BLOCK,-1,,<empty>,,,,4,,<empty>
6158,BLOCK,-1,,"{
    crc32c = crc32c_sw;
}",24,,359,2,,void
6174,BLOCK,-1,,"{
    for (unsigned n = 0; n < 256; n++) {
        uint32_t crc = n;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc32c_table_little[0][n] = crc;
    }
    for (unsigned n = 0; n < 256; n++) {
        uint32_t crc = crc32c_table_little[0][n];
        for (unsigned k = 1; k < 8; k++) {
            crc = crc32c_table_little[0][crc & 0xff] ^ (crc >> 8);
            crc32c_table_little[k][n] = crc;
        }
    }
}",41,,368,2,,void
6176,BLOCK,-1,,<empty>,5,,369,1,,void
6186,BLOCK,4,,"{
        uint32_t crc = n;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc32c_table_little[0][n] = crc;
    }",40,,369,4,,void
6202,BLOCK,1,,<empty>,,,,1,,void
6218,BLOCK,1,,<empty>,,,,1,,void
6234,BLOCK,1,,<empty>,,,,1,,void
6250,BLOCK,1,,<empty>,,,,1,,void
6266,BLOCK,1,,<empty>,,,,1,,void
6282,BLOCK,1,,<empty>,,,,1,,void
6298,BLOCK,1,,<empty>,,,,1,,void
6314,BLOCK,1,,<empty>,,,,1,,void
6327,BLOCK,-1,,<empty>,5,,381,1,,void
6337,BLOCK,4,,"{
        uint32_t crc = crc32c_table_little[0][n];
        for (unsigned k = 1; k < 8; k++) {
            crc = crc32c_table_little[0][crc & 0xff] ^ (crc >> 8);
            crc32c_table_little[k][n] = crc;
        }
    }",40,,381,4,,void
6347,BLOCK,-1,,<empty>,9,,383,1,,void
6357,BLOCK,4,,"{
            crc = crc32c_table_little[0][crc & 0xff] ^ (crc >> 8);
            crc32c_table_little[k][n] = crc;
        }",42,,383,4,,void
6384,BLOCK,-1,,"{
    unsigned char const *next = buf;

    pthread_once(&crc32c_once_little, crc32c_init_sw_little);
    crc = ~crc;
    while (len && ((uintptr_t)next & 7) != 0) {
        crc = crc32c_table_little[0][(crc ^ *next++) & 0xff] ^ (crc >> 8);
        len--;
    }
    if (len >= 8) {
        uint64_t crcw = crc;
        do {
            crcw ^= *(uint64_t const *)next;
            crcw = crc32c_table_little[7][crcw & 0xff] ^
                   crc32c_table_little[6][(crcw >> 8) & 0xff] ^
                   crc32c_table_little[5][(crcw >> 16) & 0xff] ^
                   crc32c_table_little[4][(crcw >> 24) & 0xff] ^
                   crc32c_table_little[3][(crcw >> 32) & 0xff] ^
                   crc32c_table_little[2][(crcw >> 40) & 0xff] ^
                   crc32c_table_little[1][(crcw >> 48) & 0xff] ^
                   crc32c_table_little[0][crcw >> 56];
            next += 8;
            len -= 8;
        } while (len >= 8);
        crc = crcw;
    }
    while (len) {
        cr...",70,,392,4,,void
6407,BLOCK,-1,,"{
        crc = crc32c_table_little[0][(crc ^ *next++) & 0xff] ^ (crc >> 8);
        len--;
    }",47,,397,2,,void
6431,BLOCK,-1,,"{
        uint64_t crcw = crc;
        do {
            crcw ^= *(uint64_t const *)next;
            crcw = crc32c_table_little[7][crcw & 0xff] ^
                   crc32c_table_little[6][(crcw >> 8) & 0xff] ^
                   crc32c_table_little[5][(crcw >> 16) & 0xff] ^
                   crc32c_table_little[4][(crcw >> 24) & 0xff] ^
                   crc32c_table_little[3][(crcw >> 32) & 0xff] ^
                   crc32c_table_little[2][(crcw >> 40) & 0xff] ^
                   crc32c_table_little[1][(crcw >> 48) & 0xff] ^
                   crc32c_table_little[0][crcw >> 56];
            next += 8;
            len -= 8;
        } while (len >= 8);
        crc = crcw;
    }",19,,401,2,,void
6437,BLOCK,-1,,"{
            crcw ^= *(uint64_t const *)next;
            crcw = crc32c_table_little[7][crcw & 0xff] ^
                   crc32c_table_little[6][(crcw >> 8) & 0xff] ^
                   crc32c_table_little[5][(crcw >> 16) & 0xff] ^
                   crc32c_table_little[4][(crcw >> 24) & 0xff] ^
                   crc32c_table_little[3][(crcw >> 32) & 0xff] ^
                   crc32c_table_little[2][(crcw >> 40) & 0xff] ^
                   crc32c_table_little[1][(crcw >> 48) & 0xff] ^
                   crc32c_table_little[0][crcw >> 56];
            next += 8;
            len -= 8;
        }",12,,403,1,,void
6535,BLOCK,-1,,"{
        crc = crc32c_table_little[0][(crc ^ *next++) & 0xff] ^ (crc >> 8);
        len--;
    }",17,,418,2,,void
6562,BLOCK,-1,,"{
    x = ((x << 8) & 0xff00ff00ff00ff00) | ((x >> 8) & 0xff00ff00ff00ff);
    x = ((x << 16) & 0xffff0000ffff0000) | ((x >> 16) & 0xffff0000ffff);
    return (x << 32) | (x >> 32);
}",41,,430,2,,void
6612,BLOCK,-1,,"{
    for (unsigned n = 0; n < 256; n++) {
        uint32_t crc = n;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc32c_table_big_byte[n] = crc;
    }
    for (unsigned n = 0; n < 256; n++) {
        uint32_t crc = crc32c_table_big_byte[n];
        crc32c_table_big[0][n] = swap(crc);
        for (unsigned k = 1; k < 8; k++) {
            crc = crc32c_table_big_byte[crc & 0xff] ^ (crc >> 8);
            crc32c_table_big[k][n] = swap(crc);
        }
    }
}",38,,441,2,,void
6614,BLOCK,-1,,<empty>,5,,442,1,,void
6624,BLOCK,4,,"{
        uint32_t crc = n;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc32c_table_big_byte[n] = crc;
    }",40,,442,4,,void
6640,BLOCK,1,,<empty>,,,,1,,void
6656,BLOCK,1,,<empty>,,,,1,,void
6672,BLOCK,1,,<empty>,,,,1,,void
6688,BLOCK,1,,<empty>,,,,1,,void
6704,BLOCK,1,,<empty>,,,,1,,void
6720,BLOCK,1,,<empty>,,,,1,,void
6736,BLOCK,1,,<empty>,,,,1,,void
6752,BLOCK,1,,<empty>,,,,1,,void
6763,BLOCK,-1,,<empty>,5,,454,1,,void
6773,BLOCK,4,,"{
        uint32_t crc = crc32c_table_big_byte[n];
        crc32c_table_big[0][n] = swap(crc);
        for (unsigned k = 1; k < 8; k++) {
            crc = crc32c_table_big_byte[crc & 0xff] ^ (crc >> 8);
            crc32c_table_big[k][n] = swap(crc);
        }
    }",40,,454,4,,void
6789,BLOCK,-1,,<empty>,9,,457,1,,void
6799,BLOCK,4,,"{
            crc = crc32c_table_big_byte[crc & 0xff] ^ (crc >> 8);
            crc32c_table_big[k][n] = swap(crc);
        }",42,,457,4,,void
6825,BLOCK,-1,,"{
    unsigned char const *next = buf;

    pthread_once(&crc32c_once_big, crc32c_init_sw_big);
    crc = ~crc;
    while (len && ((uintptr_t)next & 7) != 0) {
        crc = crc32c_table_big_byte[(crc ^ *next++) & 0xff] ^ (crc >> 8);
        len--;
    }
    if (len >= 8) {
        uint64_t crcw = swap(crc);
        do {
            crcw ^= *(uint64_t const *)next;
            crcw = crc32c_table_big[0][crcw & 0xff] ^
                   crc32c_table_big[1][(crcw >> 8) & 0xff] ^
                   crc32c_table_big[2][(crcw >> 16) & 0xff] ^
                   crc32c_table_big[3][(crcw >> 24) & 0xff] ^
                   crc32c_table_big[4][(crcw >> 32) & 0xff] ^
                   crc32c_table_big[5][(crcw >> 40) & 0xff] ^
                   crc32c_table_big[6][(crcw >> 48) & 0xff] ^
                   crc32c_table_big[7][(crcw >> 56)];
            next += 8;
            len -= 8;
        } while (len >= 8);
        crc = swap(crcw);
    }
    while (len) {
        crc = crc32c_table_...",67,,466,4,,void
6848,BLOCK,-1,,"{
        crc = crc32c_table_big_byte[(crc ^ *next++) & 0xff] ^ (crc >> 8);
        len--;
    }",47,,471,2,,void
6870,BLOCK,-1,,"{
        uint64_t crcw = swap(crc);
        do {
            crcw ^= *(uint64_t const *)next;
            crcw = crc32c_table_big[0][crcw & 0xff] ^
                   crc32c_table_big[1][(crcw >> 8) & 0xff] ^
                   crc32c_table_big[2][(crcw >> 16) & 0xff] ^
                   crc32c_table_big[3][(crcw >> 24) & 0xff] ^
                   crc32c_table_big[4][(crcw >> 32) & 0xff] ^
                   crc32c_table_big[5][(crcw >> 40) & 0xff] ^
                   crc32c_table_big[6][(crcw >> 48) & 0xff] ^
                   crc32c_table_big[7][(crcw >> 56)];
            next += 8;
            len -= 8;
        } while (len >= 8);
        crc = swap(crcw);
    }",19,,475,2,,void
6877,BLOCK,-1,,"{
            crcw ^= *(uint64_t const *)next;
            crcw = crc32c_table_big[0][crcw & 0xff] ^
                   crc32c_table_big[1][(crcw >> 8) & 0xff] ^
                   crc32c_table_big[2][(crcw >> 16) & 0xff] ^
                   crc32c_table_big[3][(crcw >> 24) & 0xff] ^
                   crc32c_table_big[4][(crcw >> 32) & 0xff] ^
                   crc32c_table_big[5][(crcw >> 40) & 0xff] ^
                   crc32c_table_big[6][(crcw >> 48) & 0xff] ^
                   crc32c_table_big[7][(crcw >> 56)];
            next += 8;
            len -= 8;
        }",12,,477,1,,void
6976,BLOCK,-1,,"{
        crc = crc32c_table_big_byte[(crc ^ *next++) & 0xff] ^ (crc >> 8);
        len--;
    }",17,,492,2,,void
7003,BLOCK,-1,,"{
    static int const little = 1;
    if (*(char const *)&little)
        return crc32c_sw_little(crc, buf, len);
    else
        return crc32c_sw_big(crc, buf, len);
}",63,,506,4,,void
7014,BLOCK,-1,,<empty>,9,,509,2,,void
7021,BLOCK,-1,,<empty>,9,,511,1,,void
7035,BLOCK,-1,,<empty>,1,,1,1,,ANY
7040,BLOCK,-1,,<empty>,,,,4,,<empty>
7046,BLOCK,-1,,<empty>,,,,2,,<empty>
7053,BLOCK,-1,,<empty>,,,,4,,<empty>
7070,BLOCK,-1,,<empty>,1,,1,1,,ANY
7074,BLOCK,-1,,"{
    int fd;

    switch (fork()) {
    case -1:
        return (-1);
    case 0:
        break;
    default:
        _exit(EXIT_SUCCESS);
    }

    if (setsid() == -1)
        return (-1);

    if (nochdir == 0) {
        if(chdir(""/"") != 0) {
            perror(""chdir"");
            return (-1);
        }
    }

    if (noclose == 0 && (fd = open(""/dev/null"", O_RDWR, 0)) != -1) {
        if(dup2(fd, STDIN_FILENO) < 0) {
            perror(""dup2 stdin"");
            goto err_cleanup;
        }
        if(dup2(fd, STDOUT_FILENO) < 0) {
            perror(""dup2 stdout"");
            goto err_cleanup;
        }
        if(dup2(fd, STDERR_FILENO) < 0) {
            perror(""dup2 stderr"");
            goto err_cleanup;
        }

        if(close(fd) < 0) {
            perror(""close"");
            return (-1);
        }
    }
    return (0);

    err_cleanup:
        close(fd);
        return (-1);
}",1,,45,3,,void
7078,BLOCK,-1,,"{
    case -1:
        return (-1);
    case 0:
        break;
    default:
        _exit(EXIT_SUCCESS);
    }",21,,48,2,,void
7096,BLOCK,-1,,<empty>,9,,58,2,,void
7104,BLOCK,-1,,"{
        if(chdir(""/"") != 0) {
            perror(""chdir"");
            return (-1);
        }
    }",23,,60,2,,void
7110,BLOCK,-1,,"{
            perror(""chdir"");
            return (-1);
        }",29,,61,2,,void
7130,BLOCK,-1,,"{
        if(dup2(fd, STDIN_FILENO) < 0) {
            perror(""dup2 stdin"");
            goto err_cleanup;
        }
        if(dup2(fd, STDOUT_FILENO) < 0) {
            perror(""dup2 stdout"");
            goto err_cleanup;
        }
        if(dup2(fd, STDERR_FILENO) < 0) {
            perror(""dup2 stderr"");
            goto err_cleanup;
        }

        if(close(fd) < 0) {
            perror(""close"");
            return (-1);
        }
    }",68,,67,2,,void
7137,BLOCK,-1,,"{
            perror(""dup2 stdin"");
            goto err_cleanup;
        }",40,,68,2,,void
7147,BLOCK,-1,,"{
            perror(""dup2 stdout"");
            goto err_cleanup;
        }",41,,72,2,,void
7157,BLOCK,-1,,"{
            perror(""dup2 stderr"");
            goto err_cleanup;
        }",41,,76,2,,void
7166,BLOCK,-1,,"{
            perror(""close"");
            return (-1);
        }",27,,81,2,,void
7196,BLOCK,-1,,<empty>,1,,1,1,,ANY
7233,BLOCK,-1,,<empty>,1,,1,1,,ANY
7304,BLOCK,-1,,"{
    _store_wbuf *b = calloc(1, sizeof(_store_wbuf));
    if (b == NULL)
        return NULL;
    b->buf = calloc(size, sizeof(char));
    if (b->buf == NULL) {
        free(b);
        return NULL;
    }
    b->buf_pos = b->buf;
    b->free = size;
    b->size = size;
    return b;
}",43,,115,2,,void
7316,BLOCK,-1,,<empty>,9,,118,2,,void
7333,BLOCK,-1,,"{
        free(b);
        return NULL;
    }",25,,120,2,,void
7361,BLOCK,-1,,"{
    int tid = -1;
    long long int low = LLONG_MAX;
    pthread_mutex_lock(&e->mutex);
    // find smallest queue. ignoring lock since being wrong isn't fatal.
    // TODO: if average queue depth can be quickly tracked, can break as soon
    // as we see a thread that's less than average, and start from last_io_thread
    for (int x = 0; x < e->io_threadcount; x++) {
        if (e->io_threads[x].depth == 0) {
            tid = x;
            break;
        } else if (e->io_threads[x].depth < low) {
                tid = x;
            low = e->io_threads[x].depth;
        }
    }
    pthread_mutex_unlock(&e->mutex);

    return &e->io_threads[tid];
}",57,,130,2,,void
7377,BLOCK,-1,,<empty>,5,,137,1,,void
7389,BLOCK,4,,"{
        if (e->io_threads[x].depth == 0) {
            tid = x;
            break;
        } else if (e->io_threads[x].depth < low) {
                tid = x;
            low = e->io_threads[x].depth;
        }
    }",49,,137,4,,void
7400,BLOCK,-1,,"{
            tid = x;
            break;
        }",42,,138,2,,void
7406,BLOCK,-1,,<empty>,16,,141,1,,void
7417,BLOCK,-1,,"{
                tid = x;
            low = e->io_threads[x].depth;
        }",50,,141,2,,void
7446,BLOCK,-1,,"{
    return e->version++;
}",48,,151,2,,void
7456,BLOCK,-1,,<empty>,,,,2,,<empty>
7461,BLOCK,-1,,<empty>,,,,2,,<empty>
7467,BLOCK,-1,,"{
    store_engine *e = (store_engine *)ptr;
    STAT_L(e);
    memcpy(st, &e->stats, sizeof(struct extstore_stats));
    STAT_UL(e);

    // grab pages_free/pages_used
    pthread_mutex_lock(&e->mutex);
    st->pages_free = e->page_free;
    st->pages_used = e->page_count - e->page_free;
    pthread_mutex_unlock(&e->mutex);
    st->io_queue = 0;
    for (int x = 0; x < e->io_threadcount; x++) {
        pthread_mutex_lock(&e->io_threads[x].mutex);
        st->io_queue += e->io_threads[x].depth;
        pthread_mutex_unlock(&e->io_threads[x].mutex);
    }
    // calculate bytes_fragmented.
    // note that open and yet-filled pages count against fragmentation.
    st->bytes_fragmented = st->pages_used * e->page_size -
        st->bytes_used;
}",63,,159,3,,void
7476,BLOCK,1,,<empty>,,,,3,,void
7492,BLOCK,1,,<empty>,,,,3,,void
7532,BLOCK,-1,,<empty>,5,,171,1,,void
7544,BLOCK,4,,"{
        pthread_mutex_lock(&e->io_threads[x].mutex);
        st->io_queue += e->io_threads[x].depth;
        pthread_mutex_unlock(&e->io_threads[x].mutex);
    }",49,,171,4,,void
7594,BLOCK,-1,,"{
    store_engine *e = (store_engine *)ptr;
    STAT_L(e);
    memcpy(st->page_data, e->stats.page_data,
            sizeof(struct extstore_page_data) * e->page_count);
    STAT_UL(e);
}",67,,182,3,,void
7603,BLOCK,1,,<empty>,,,,3,,void
7626,BLOCK,1,,<empty>,,,,3,,void
7636,BLOCK,-1,,"{
    const char *rv = ""unknown error"";
    switch (res) {
        case EXTSTORE_INIT_BAD_WBUF_SIZE:
            rv = ""page_size must be divisible by wbuf_size"";
            break;
        case EXTSTORE_INIT_NEED_MORE_WBUF:
            rv = ""wbuf_count must be >= page_buckets"";
            break;
        case EXTSTORE_INIT_NEED_MORE_BUCKETS:
            rv = ""page_buckets must be > 0"";
            break;
        case EXTSTORE_INIT_PAGE_WBUF_ALIGNMENT:
            rv = ""page_size and wbuf_size must be divisible by 1024*1024*2"";
            break;
        case EXTSTORE_INIT_TOO_MANY_PAGES:
            rv = ""page_count must total to < 65536. Increase page_size or lower path sizes"";
            break;
        case EXTSTORE_INIT_OOM:
            rv = ""failed calloc for engine"";
            break;
        case EXTSTORE_INIT_OPEN_FAIL:
            rv = ""failed to open file"";
            break;
        case EXTSTORE_INIT_THREAD_FAIL:
            break;
    }
    return rv;
}",49,,190,2,,void
7643,BLOCK,-1,,"{
        case EXTSTORE_INIT_BAD_WBUF_SIZE:
            rv = ""page_size must be divisible by wbuf_size"";
            break;
        case EXTSTORE_INIT_NEED_MORE_WBUF:
            rv = ""wbuf_count must be >= page_buckets"";
            break;
        case EXTSTORE_INIT_NEED_MORE_BUCKETS:
            rv = ""page_buckets must be > 0"";
            break;
        case EXTSTORE_INIT_PAGE_WBUF_ALIGNMENT:
            rv = ""page_size and wbuf_size must be divisible by 1024*1024*2"";
            break;
        case EXTSTORE_INIT_TOO_MANY_PAGES:
            rv = ""page_count must total to < 65536. Increase page_size or lower path sizes"";
            break;
        case EXTSTORE_INIT_OOM:
            rv = ""failed calloc for engine"";
            break;
        case EXTSTORE_INIT_OPEN_FAIL:
            rv = ""failed to open file"";
            break;
        case EXTSTORE_INIT_THREAD_FAIL:
            break;
    }",18,,192,2,,void
7697,BLOCK,-1,,"{
    int i;
    struct extstore_conf_file *f = NULL;
    pthread_t thread;

    if (cf->page_size % cf->wbuf_size != 0) {
        *res = EXTSTORE_INIT_BAD_WBUF_SIZE;
        return NULL;
    }
    // Should ensure at least one write buffer per potential page
    if (cf->page_buckets > cf->wbuf_count) {
        *res = EXTSTORE_INIT_NEED_MORE_WBUF;
        return NULL;
    }
    if (cf->page_buckets < 1) {
        *res = EXTSTORE_INIT_NEED_MORE_BUCKETS;
        return NULL;
    }

    // TODO: More intelligence around alignment of flash erasure block sizes
    if (cf->page_size % (1024 * 1024 * 2) != 0 ||
        cf->wbuf_size % (1024 * 1024 * 2) != 0) {
        *res = EXTSTORE_INIT_PAGE_WBUF_ALIGNMENT;
        return NULL;
    }

    store_engine *e = calloc(1, sizeof(store_engine));
    if (e == NULL) {
        *res = EXTSTORE_INIT_OOM;
        return NULL;
    }

    e->page_size = cf->page_size;
    uint64_t temp_page_count = 0;
    for (f = fh; f != NULL; f = f->next) {
        ...",33,,222,4,,void
7714,BLOCK,-1,,"{
        *res = EXTSTORE_INIT_BAD_WBUF_SIZE;
        return NULL;
    }",45,,227,2,,void
7729,BLOCK,-1,,"{
        *res = EXTSTORE_INIT_NEED_MORE_WBUF;
        return NULL;
    }",44,,232,2,,void
7742,BLOCK,-1,,"{
        *res = EXTSTORE_INIT_NEED_MORE_BUCKETS;
        return NULL;
    }",31,,236,2,,void
7773,BLOCK,-1,,"{
        *res = EXTSTORE_INIT_PAGE_WBUF_ALIGNMENT;
        return NULL;
    }",49,,243,2,,void
7791,BLOCK,-1,,"{
        *res = EXTSTORE_INIT_OOM;
        return NULL;
    }",20,,249,2,,void
7810,BLOCK,-1,,<empty>,5,,256,1,,void
7822,BLOCK,4,,"{
        f->fd = open(f->file, O_RDWR | O_CREAT, 0644);
        if (f->fd < 0) {
            *res = EXTSTORE_INIT_OPEN_FAIL;
#ifdef EXTSTORE_DEBUG
            perror(""extstore open"");
#endif
            free(e);
            return NULL;
        }
        // use an fcntl lock to help avoid double starting.
        struct flock lock;
        lock.l_type = F_WRLCK;
        lock.l_start = 0;
        lock.l_whence = SEEK_SET;
        lock.l_len = 0;
        if (fcntl(f->fd, F_SETLK, &lock) < 0) {
            *res = EXTSTORE_INIT_OPEN_FAIL;
            free(e);
            return NULL;
        }
        if (ftruncate(f->fd, 0) < 0) {
            *res = EXTSTORE_INIT_OPEN_FAIL;
            free(e);
            return NULL;
        }

        temp_page_count += f->page_count;
        f->offset = 0;
    }",42,,256,4,,void
7841,BLOCK,-1,,"{
            *res = EXTSTORE_INIT_OPEN_FAIL;
#ifdef EXTSTORE_DEBUG
            perror(""extstore open"");
#endif
            free(e);
            return NULL;
        }",24,,258,2,,void
7881,BLOCK,-1,,"{
            *res = EXTSTORE_INIT_OPEN_FAIL;
            free(e);
            return NULL;
        }",47,,272,2,,void
7898,BLOCK,-1,,"{
            *res = EXTSTORE_INIT_OPEN_FAIL;
            free(e);
            return NULL;
        }",38,,277,2,,void
7921,BLOCK,-1,,"{
        *res = EXTSTORE_INIT_TOO_MANY_PAGES;
        free(e);
        return NULL;
    }",40,,287,2,,void
7951,BLOCK,-1,,"{
        *res = EXTSTORE_INIT_OOM;
        // FIXME: loop-close. make error label
        free(e);
        return NULL;
    }",27,,295,2,,void
7964,BLOCK,-1,,<empty>,5,,304,1,,void
7975,BLOCK,4,,"{
        // find next device with available pages
        while (1) {
            // restart the loop
            if (f == NULL || f->next == NULL) {
                f = fh;
            } else {
                f = f->next;
            }
            if (f->page_count) {
                f->page_count--;
                break;
            }
        }
        pthread_mutex_init(&e->pages[i].mutex, NULL);
        e->pages[i].id = i;
        e->pages[i].fd = f->fd;
        e->pages[i].free_bucket = f->free_bucket;
        e->pages[i].offset = f->offset;
        e->pages[i].free = true;
        f->offset += e->page_size;
    }",41,,304,4,,void
7978,BLOCK,-1,,"{
            // restart the loop
            if (f == NULL || f->next == NULL) {
                f = fh;
            } else {
                f = f->next;
            }
            if (f->page_count) {
                f->page_count--;
                break;
            }
        }",19,,306,2,,void
7989,BLOCK,-1,,"{
                f = fh;
            }",47,,308,2,,void
7994,BLOCK,-1,,"{
                f = f->next;
            }",20,,310,1,,void
8004,BLOCK,-1,,"{
                f->page_count--;
                break;
            }",32,,313,2,,void
8096,BLOCK,-1,,<empty>,5,,331,1,,void
8109,BLOCK,4,,"{
        e->page_free++;
        if (e->pages[i].free_bucket == 0) {
            e->pages[i].next = e->page_freelist;
            e->page_freelist = &e->pages[i];
        } else {
            int fb = e->pages[i].free_bucket;
            e->pages[i].next = e->free_page_buckets[fb];
            e->free_page_buckets[fb] = &e->pages[i];
        }
    }",43,,331,4,,void
8124,BLOCK,-1,,"{
            e->pages[i].next = e->page_freelist;
            e->page_freelist = &e->pages[i];
        }",43,,333,2,,void
8147,BLOCK,-1,,"{
            int fb = e->pages[i].free_bucket;
            e->pages[i].next = e->free_page_buckets[fb];
            e->free_page_buckets[fb] = &e->pages[i];
        }",16,,336,1,,void
8236,BLOCK,-1,,<empty>,5,,358,1,,void
8247,BLOCK,4,,"{
        _store_wbuf *w = wbuf_new(cf->wbuf_size);
        obj_io *io = calloc(1, sizeof(obj_io));
        /* TODO: on error, loop again and free stack. */
        w->next = e->wbuf_stack;
        e->wbuf_stack = w;
        io->next = e->io_stack;
        e->io_stack = io;
    }",42,,358,4,,void
8316,BLOCK,-1,,<empty>,5,,375,1,,void
8327,BLOCK,4,,"{
        pthread_mutex_init(&e->io_threads[i].mutex, NULL);
        pthread_cond_init(&e->io_threads[i].cond, NULL);
        e->io_threads[i].e = e;
        // FIXME: error handling
        pthread_create(&thread, NULL, extstore_io_thread, &e->io_threads[i]);
    }",46,,375,4,,void
8424,BLOCK,-1,,"{
    store_engine *e = (store_engine *)ptr;
    pthread_cond_signal(&e->maint_thread->cond);
}",36,,396,2,,void
8444,BLOCK,-1,,"{
    assert(!e->page_buckets[bucket] || e->page_buckets[bucket]->allocated == e->page_size);
    store_page *tmp = NULL;
    // if a specific free bucket was requested, check there first
    if (free_bucket != 0 && e->free_page_buckets[free_bucket] != NULL) {
        assert(e->page_free > 0);
        tmp = e->free_page_buckets[free_bucket];
        e->free_page_buckets[free_bucket] = tmp->next;
    }
    // failing that, try the global list.
    if (tmp == NULL && e->page_freelist != NULL) {
        tmp = e->page_freelist;
        e->page_freelist = tmp->next;
    }
    E_DEBUG(""EXTSTORE: allocating new page\n"");
    // page_freelist can be empty if the only free pages are specialized and
    // we didn't just request one.
    if (e->page_free > 0 && tmp != NULL) {
        tmp->next = e->page_buckets[bucket];
        e->page_buckets[bucket] = tmp;
        tmp->active = true;
        tmp->free = false;
        tmp->closed = false;
        tmp->version = _next_version(e);
        tmp...",35,,403,4,,void
8480,BLOCK,-1,,"{
        assert(e->page_free > 0);
        tmp = e->free_page_buckets[free_bucket];
        e->free_page_buckets[free_bucket] = tmp->next;
    }",72,,407,2,,void
8513,BLOCK,-1,,"{
        tmp = e->page_freelist;
        e->page_freelist = tmp->next;
    }",50,,413,2,,void
8536,BLOCK,-1,,"{
        tmp->next = e->page_buckets[bucket];
        e->page_buckets[bucket] = tmp;
        tmp->active = true;
        tmp->free = false;
        tmp->closed = false;
        tmp->version = _next_version(e);
        tmp->bucket = bucket;
        e->page_free--;
        STAT_INCR(e, page_allocs, 1);
    }",42,,420,2,,void
8586,BLOCK,1,,"STAT_INCR(e, page_allocs, 1)",9,,429,9,,void
8605,BLOCK,-1,,"{
        extstore_run_maint(e);
    }",12,,430,1,,void
8610,BLOCK,-1,,<empty>,52,,434,2,,void
8618,BLOCK,-1,,"{
    _store_wbuf *wbuf = NULL;
    assert(!p->wbuf);
    pthread_mutex_lock(&e->mutex);
    if (e->wbuf_stack) {
        wbuf = e->wbuf_stack;
        e->wbuf_stack = wbuf->next;
        wbuf->next = 0;
    }
    pthread_mutex_unlock(&e->mutex);
    if (wbuf) {
        wbuf->offset = p->allocated;
        p->allocated += wbuf->size;
        wbuf->free = wbuf->size;
        wbuf->buf_pos = wbuf->buf;
        wbuf->full = false;
        wbuf->flushed = false;

        p->wbuf = wbuf;
    }
}",60,,439,3,,void
8637,BLOCK,-1,,"{
        wbuf = e->wbuf_stack;
        e->wbuf_stack = wbuf->next;
        wbuf->next = 0;
    }",24,,443,2,,void
8662,BLOCK,-1,,"{
        wbuf->offset = p->allocated;
        p->allocated += wbuf->size;
        wbuf->free = wbuf->size;
        wbuf->buf_pos = wbuf->buf;
        wbuf->full = false;
        wbuf->flushed = false;

        p->wbuf = wbuf;
    }",15,,449,2,,void
8712,BLOCK,-1,,"{
    store_engine *e = (store_engine *)ep;
    store_page *p = &e->pages[io->page_id];
    _store_wbuf *w = (_store_wbuf *) io->data;

    // TODO: Examine return code. Not entirely sure how to handle errors.
    // Naive first-pass should probably cause the page to close/free.
    w->flushed = true;
    pthread_mutex_lock(&p->mutex);
    assert(p->wbuf != NULL && p->wbuf == w);
    assert(p->written == w->offset);
    p->written += w->size;
    p->wbuf = NULL;

    if (p->written == e->page_size)
        p->active = false;

    // return the wbuf
    pthread_mutex_lock(&e->mutex);
    w->next = e->wbuf_stack;
    e->wbuf_stack = w;
    // also return the IO we just used.
    io->next = e->io_stack;
    e->io_stack = io;
    pthread_mutex_unlock(&e->mutex);
    pthread_mutex_unlock(&p->mutex);
}",53,,467,4,,void
8788,BLOCK,-1,,<empty>,9,,482,2,,void
8838,BLOCK,-1,,"{
    _store_wbuf *w;
    pthread_mutex_lock(&e->mutex);
    obj_io *io = e->io_stack;
    e->io_stack = io->next;
    pthread_mutex_unlock(&e->mutex);
    w = p->wbuf;

    // zero out the end of the wbuf to allow blind readback of data.
    memset(w->buf + (w->size - w->free), 0, w->free);

    io->next = NULL;
    io->mode = OBJ_IO_WRITE;
    io->page_id = p->id;
    io->data = w;
    io->offset = w->offset;
    io->len = w->size;
    io->buf = w->buf;
    io->cb = _wbuf_cb;

    extstore_submit(e, io);
}",58,,498,3,,void
8942,BLOCK,-1,,"{
    store_engine *e = (store_engine *)ptr;
    store_page *p;
    int ret = -1;
    if (bucket >= e->page_bucketcount)
        return ret;

    pthread_mutex_lock(&e->mutex);
    p = e->page_buckets[bucket];
    if (!p) {
        p = _allocate_page(e, bucket, free_bucket);
    }
    pthread_mutex_unlock(&e->mutex);
    if (!p)
        return ret;

    pthread_mutex_lock(&p->mutex);

    // FIXME: can't null out page_buckets!!!
    // page is full, clear bucket and retry later.
    if (!p->active ||
            ((!p->wbuf || p->wbuf->full) && p->allocated >= e->page_size)) {
        pthread_mutex_unlock(&p->mutex);
        pthread_mutex_lock(&e->mutex);
        _allocate_page(e, bucket, free_bucket);
        pthread_mutex_unlock(&e->mutex);
        return ret;
    }

    // if io won't fit, submit IO for wbuf and find new one.
    if (p->wbuf && p->wbuf->free < io->len && !p->wbuf->full) {
        _submit_wbuf(e, p);
        p->wbuf->full = true;
    }

    if (!p->wbuf && p->alloc...",47,,531,5,,void
8961,BLOCK,-1,,<empty>,9,,536,2,,void
8979,BLOCK,-1,,"{
        p = _allocate_page(e, bucket, free_bucket);
    }",13,,540,2,,void
8994,BLOCK,-1,,<empty>,9,,545,2,,void
9026,BLOCK,-1,,"{
        pthread_mutex_unlock(&p->mutex);
        pthread_mutex_lock(&e->mutex);
        _allocate_page(e, bucket, free_bucket);
        pthread_mutex_unlock(&e->mutex);
        return ret;
    }",76,,552,2,,void
9069,BLOCK,-1,,"{
        _submit_wbuf(e, p);
        p->wbuf->full = true;
    }",63,,561,2,,void
9093,BLOCK,-1,,"{
        _allocate_wbuf(e, p);
    }",50,,566,2,,void
9118,BLOCK,-1,,"{
        io->buf = p->wbuf->buf_pos;
        io->page_id = p->id;
        return 0;
    }",64,,572,2,,void
9149,BLOCK,-1,,"{
    store_engine *e = (store_engine *)ptr;
    store_page *p = &e->pages[io->page_id];

    io->offset = p->wbuf->offset + (p->wbuf->size - p->wbuf->free);
    io->page_version = p->version;
    p->wbuf->buf_pos += io->len;
    p->wbuf->free -= io->len;
    p->bytes_used += io->len;
    p->obj_count++;
    STAT_L(e);
    e->stats.bytes_written += io->len;
    e->stats.bytes_used += io->len;
    e->stats.objects_written++;
    e->stats.objects_used++;
    STAT_UL(e);

    pthread_mutex_unlock(&p->mutex);
}",44,,586,3,,void
9226,BLOCK,1,,<empty>,,,,3,,void
9264,BLOCK,1,,<empty>,,,,3,,void
9280,BLOCK,-1,,"{
    store_engine *e = (store_engine *)ptr;

    unsigned int depth = 0;
    obj_io *tio = io;
    obj_io *tail = NULL;
    while (tio != NULL) {
        tail = tio; // keep updating potential tail.
        depth++;
        tio = tio->next;
    }

    store_io_thread *t = _get_io_thread(e);
    pthread_mutex_lock(&t->mutex);

    t->depth += depth;
    if (t->queue == NULL) {
        t->queue = io;
        t->queue_tail = tail;
    } else {
        // Have to put the *io stack at the end of current queue.
        assert(tail->next == NULL);
        assert(t->queue_tail->next == NULL);
        t->queue_tail->next = io;
        t->queue_tail = tail;
    }

    pthread_mutex_unlock(&t->mutex);

    //pthread_mutex_lock(&t->mutex);
    pthread_cond_signal(&t->cond);
    //pthread_mutex_unlock(&t->mutex);
    return 0;
}",44,,611,3,,void
9303,BLOCK,-1,,"{
        tail = tio; // keep updating potential tail.
        depth++;
        tio = tio->next;
    }",25,,617,2,,void
9335,BLOCK,-1,,"{
        t->queue = io;
        t->queue_tail = tail;
    }",27,,627,2,,void
9347,BLOCK,-1,,"{
        // Have to put the *io stack at the end of current queue.
        assert(tail->next == NULL);
        assert(t->queue_tail->next == NULL);
        t->queue_tail->next = io;
        t->queue_tail = tail;
    }",12,,630,1,,void
9394,BLOCK,-1,,"{
    store_engine *e = (store_engine *)ptr;
    // FIXME: validate page_id in bounds
    store_page *p = &e->pages[page_id];
    int ret = 0;

    pthread_mutex_lock(&p->mutex);
    if (!p->closed && p->version == page_version) {
        if (p->bytes_used >= bytes) {
            p->bytes_used -= bytes;
        } else {
            p->bytes_used = 0;
        }

        if (p->obj_count >= count) {
            p->obj_count -= count;
        } else {
            p->obj_count = 0; // caller has bad accounting?
        }
        STAT_L(e);
        e->stats.bytes_used -= bytes;
        e->stats.objects_used -= count;
        STAT_UL(e);

        if (p->obj_count == 0) {
            extstore_run_maint(e);
        }
    } else {
        ret = -1;
    }
    pthread_mutex_unlock(&p->mutex);
    return ret;
}",49,,650,6,,void
9430,BLOCK,-1,,"{
        if (p->bytes_used >= bytes) {
            p->bytes_used -= bytes;
        } else {
            p->bytes_used = 0;
        }

        if (p->obj_count >= count) {
            p->obj_count -= count;
        } else {
            p->obj_count = 0; // caller has bad accounting?
        }
        STAT_L(e);
        e->stats.bytes_used -= bytes;
        e->stats.objects_used -= count;
        STAT_UL(e);

        if (p->obj_count == 0) {
            extstore_run_maint(e);
        }
    }",51,,657,2,,void
9437,BLOCK,-1,,"{
            p->bytes_used -= bytes;
        }",37,,658,2,,void
9444,BLOCK,-1,,"{
            p->bytes_used = 0;
        }",16,,660,1,,void
9456,BLOCK,-1,,"{
            p->obj_count -= count;
        }",36,,664,2,,void
9463,BLOCK,-1,,"{
            p->obj_count = 0; // caller has bad accounting?
        }",16,,666,1,,void
9471,BLOCK,1,,<empty>,,,,3,,void
9493,BLOCK,1,,<empty>,,,,3,,void
9505,BLOCK,-1,,"{
            extstore_run_maint(e);
        }",32,,674,2,,void
9509,BLOCK,-1,,"{
        ret = -1;
    }",12,,677,1,,void
9527,BLOCK,-1,,"{
    store_engine *e = (store_engine *)ptr;
    store_page *p = &e->pages[page_id];
    int ret = 0;

    pthread_mutex_lock(&p->mutex);
    if (p->version != page_version)
        ret = -1;
    pthread_mutex_unlock(&p->mutex);
    return ret;
}",76,,684,4,,void
9558,BLOCK,-1,,<empty>,9,,691,2,,void
9576,BLOCK,-1,,"{
    store_engine *e = (store_engine *)ptr;
    store_page *p = &e->pages[page_id];

    pthread_mutex_lock(&p->mutex);
    if (!p->closed && p->version == page_version) {
        p->closed = true;
        extstore_run_maint(e);
    }
    pthread_mutex_unlock(&p->mutex);
}",82,,697,4,,void
9608,BLOCK,-1,,"{
        p->closed = true;
        extstore_run_maint(e);
    }",51,,702,2,,void
9626,BLOCK,-1,,"{
    _store_wbuf *wbuf = p->wbuf;
    assert(wbuf != NULL);
    assert(io->offset < p->written + wbuf->size);
    if (io->iov == NULL) {
        memcpy(io->buf, wbuf->buf + (io->offset - wbuf->offset), io->len);
    } else {
        int x;
        unsigned int off = io->offset - wbuf->offset;
        // need to loop fill iovecs
        for (x = 0; x < io->iovcnt; x++) {
            struct iovec *iov = &io->iov[x];
            memcpy(iov->iov_base, wbuf->buf + off, iov->iov_len);
            off += iov->iov_len;
        }
    }
    return io->len;
}",62,,715,3,,void
9655,BLOCK,-1,,"{
        memcpy(io->buf, wbuf->buf + (io->offset - wbuf->offset), io->len);
    }",26,,719,2,,void
9675,BLOCK,-1,,"{
        int x;
        unsigned int off = io->offset - wbuf->offset;
        // need to loop fill iovecs
        for (x = 0; x < io->iovcnt; x++) {
            struct iovec *iov = &io->iov[x];
            memcpy(iov->iov_base, wbuf->buf + off, iov->iov_len);
            off += iov->iov_len;
        }
    }",12,,721,1,,void
9688,BLOCK,-1,,<empty>,9,,725,1,,void
9699,BLOCK,4,,"{
            struct iovec *iov = &io->iov[x];
            memcpy(iov->iov_base, wbuf->buf + off, iov->iov_len);
            off += iov->iov_len;
        }",42,,725,4,,void
9734,BLOCK,-1,,"{
    store_io_thread *me = (store_io_thread *)arg;
    store_engine *e = me->e;
    while (1) {
        obj_io *io_stack = NULL;
        pthread_mutex_lock(&me->mutex);
        if (me->queue == NULL) {
            pthread_cond_wait(&me->cond, &me->mutex);
        }

        // Pull and disconnect a batch from the queue
        // Chew small batches from the queue so the IO thread picker can keep
        // the IO queue depth even, instead of piling on threads one at a time
        // as they gobble a queue.
        if (me->queue != NULL) {
            int i;
            obj_io *end = NULL;
            io_stack = me->queue;
            end = io_stack;
            for (i = 1; i < e->io_depth; i++) {
                if (end->next) {
                    end = end->next;
                } else {
                    me->queue_tail = end->next;
                    break;
                }
            }
            me->depth -= i;
            me->queue = end->next;
            end->next = ...",44,,739,2,,void
9749,BLOCK,-1,,"{
        obj_io *io_stack = NULL;
        pthread_mutex_lock(&me->mutex);
        if (me->queue == NULL) {
            pthread_cond_wait(&me->cond, &me->mutex);
        }

        // Pull and disconnect a batch from the queue
        // Chew small batches from the queue so the IO thread picker can keep
        // the IO queue depth even, instead of piling on threads one at a time
        // as they gobble a queue.
        if (me->queue != NULL) {
            int i;
            obj_io *end = NULL;
            io_stack = me->queue;
            end = io_stack;
            for (i = 1; i < e->io_depth; i++) {
                if (end->next) {
                    end = end->next;
                } else {
                    me->queue_tail = end->next;
                    break;
                }
            }
            me->depth -= i;
            me->queue = end->next;
            end->next = NULL;
        }
        pthread_mutex_unlock(&me->mutex);

        obj_io *cur_io = io_stack;
 ...",15,,742,2,,void
9765,BLOCK,-1,,"{
            pthread_cond_wait(&me->cond, &me->mutex);
        }",32,,745,2,,void
9781,BLOCK,-1,,"{
            int i;
            obj_io *end = NULL;
            io_stack = me->queue;
            end = io_stack;
            for (i = 1; i < e->io_depth; i++) {
                if (end->next) {
                    end = end->next;
                } else {
                    me->queue_tail = end->next;
                    break;
                }
            }
            me->depth -= i;
            me->queue = end->next;
            end->next = NULL;
        }",32,,753,2,,void
9796,BLOCK,-1,,<empty>,13,,758,1,,void
9807,BLOCK,4,,"{
                if (end->next) {
                    end = end->next;
                } else {
                    me->queue_tail = end->next;
                    break;
                }
            }",47,,758,4,,void
9812,BLOCK,-1,,"{
                    end = end->next;
                }",32,,759,2,,void
9819,BLOCK,-1,,"{
                    me->queue_tail = end->next;
                    break;
                }",24,,761,1,,void
9856,BLOCK,-1,,"{
            // We need to note next before the callback in case the obj_io
            // gets reused.
            obj_io *next = cur_io->next;
            int ret = 0;
            int do_op = 1;
            store_page *p = &e->pages[cur_io->page_id];
            // TODO: loop if not enough bytes were read/written.
            switch (cur_io->mode) {
                case OBJ_IO_READ:
                    // Page is currently open. deal if read is past the end.
                    pthread_mutex_lock(&p->mutex);
                    if (!p->free && !p->closed && p->version == cur_io->page_version) {
                        if (p->active && cur_io->offset >= p->written) {
                            ret = _read_from_wbuf(p, cur_io);
                            do_op = 0;
                        } else {
                            p->refcount++;
                        }
                        STAT_L(e);
                        e->stats.bytes_read += cur_io->len;
                     ...",24,,773,2,,void
9886,BLOCK,-1,,"{
                case OBJ_IO_READ:
                    // Page is currently open. deal if read is past the end.
                    pthread_mutex_lock(&p->mutex);
                    if (!p->free && !p->closed && p->version == cur_io->page_version) {
                        if (p->active && cur_io->offset >= p->written) {
                            ret = _read_from_wbuf(p, cur_io);
                            do_op = 0;
                        } else {
                            p->refcount++;
                        }
                        STAT_L(e);
                        e->stats.bytes_read += cur_io->len;
                        e->stats.objects_read++;
                        STAT_UL(e);
                    } else {
                        do_op = 0;
                        ret = -2; // TODO: enum in IO for status?
                    }
                    pthread_mutex_unlock(&p->mutex);
                    if (do_op) {
#if !defined(HAVE_PREAD) || !defined(HAVE_PREADV)
 ...",35,,781,2,,void
9912,BLOCK,-1,,"{
                        if (p->active && cur_io->offset >= p->written) {
                            ret = _read_from_wbuf(p, cur_io);
                            do_op = 0;
                        } else {
                            p->refcount++;
                        }
                        STAT_L(e);
                        e->stats.bytes_read += cur_io->len;
                        e->stats.objects_read++;
                        STAT_UL(e);
                    }",87,,785,2,,void
9925,BLOCK,-1,,"{
                            ret = _read_from_wbuf(p, cur_io);
                            do_op = 0;
                        }",72,,786,2,,void
9935,BLOCK,-1,,"{
                            p->refcount++;
                        }",32,,789,1,,void
9942,BLOCK,1,,<empty>,,,,3,,void
9965,BLOCK,1,,<empty>,,,,3,,void
9972,BLOCK,-1,,"{
                        do_op = 0;
                        ret = -2; // TODO: enum in IO for status?
                    }",28,,796,1,,void
9987,BLOCK,-1,,"{
#if !defined(HAVE_PREAD) || !defined(HAVE_PREADV)
                        // TODO: lseek offset is natively 64-bit on OS X, but
                        // perhaps not on all platforms? Else use lseek64()
                        ret = lseek(p->fd, p->offset + cur_io->offset, SEEK_SET);
                        if (ret >= 0) {
                            if (cur_io->iov == NULL) {
                                ret = read(p->fd, cur_io->buf, cur_io->len);
                            } else {
                                ret = readv(p->fd, cur_io->iov, cur_io->iovcnt);
                            }
                        }
#else
                        if (cur_io->iov == NULL) {
                            ret = pread(p->fd, cur_io->buf, cur_io->len, p->offset + cur_io->offset);
                        } else {
                            ret = preadv(p->fd, cur_io->iov, cur_io->iovcnt, p->offset + cur_io->offset);
                        }
#endif
                    }",32,,801,2,,void
10006,BLOCK,-1,,"{
                            if (cur_io->iov == NULL) {
                                ret = read(p->fd, cur_io->buf, cur_io->len);
                            } else {
                                ret = readv(p->fd, cur_io->iov, cur_io->iovcnt);
                            }
                        }",39,,806,2,,void
10013,BLOCK,-1,,"{
                                ret = read(p->fd, cur_io->buf, cur_io->len);
                            }",54,,807,2,,void
10027,BLOCK,-1,,"{
                                ret = readv(p->fd, cur_io->iov, cur_io->iovcnt);
                            }",36,,809,1,,void
10070,BLOCK,-1,,"{
                E_DEBUG(""read returned nothing\n"");
            }",27,,829,2,,void
10080,BLOCK,-1,,"{
                pthread_mutex_lock(&p->mutex);
                p->refcount--;
                pthread_mutex_unlock(&p->mutex);
            }",24,,839,2,,void
10105,BLOCK,-1,,"{
    store_page *tmp = NULL;
    store_page *prev = NULL;
    E_DEBUG(""EXTSTORE: freeing page %u\n"", p->id);
    STAT_L(e);
    e->stats.objects_used -= p->obj_count;
    e->stats.bytes_used -= p->bytes_used;
    e->stats.page_reclaims++;
    STAT_UL(e);
    pthread_mutex_lock(&e->mutex);
    // unlink page from bucket list
    tmp = e->page_buckets[p->bucket];
    while (tmp) {
        if (tmp == p) {
            if (prev) {
                prev->next = tmp->next;
            } else {
                e->page_buckets[p->bucket] = tmp->next;
            }
            tmp->next = NULL;
            break;
        }
        prev = tmp;
        tmp = tmp->next;
    }
    // reset most values
    p->version = 0;
    p->obj_count = 0;
    p->bytes_used = 0;
    p->allocated = 0;
    p->written = 0;
    p->bucket = 0;
    p->active = false;
    p->closed = false;
    p->free = true;
    // add to page stack
    // TODO: free_page_buckets first class and remove redundancy?
    if (p->free_b...",56,,852,3,,void
10116,BLOCK,1,,<empty>,,,,2,,void
10148,BLOCK,1,,<empty>,,,,2,,void
10170,BLOCK,-1,,"{
        if (tmp == p) {
            if (prev) {
                prev->next = tmp->next;
            } else {
                e->page_buckets[p->bucket] = tmp->next;
            }
            tmp->next = NULL;
            break;
        }
        prev = tmp;
        tmp = tmp->next;
    }",17,,864,2,,void
10175,BLOCK,-1,,"{
            if (prev) {
                prev->next = tmp->next;
            } else {
                e->page_buckets[p->bucket] = tmp->next;
            }
            tmp->next = NULL;
            break;
        }",23,,865,2,,void
10178,BLOCK,-1,,"{
                prev->next = tmp->next;
            }",23,,866,2,,void
10187,BLOCK,-1,,"{
                e->page_buckets[p->bucket] = tmp->next;
            }",20,,868,1,,void
10264,BLOCK,-1,,"{
        p->next = e->free_page_buckets[p->free_bucket];
        e->free_page_buckets[p->free_bucket] = p;
    }",30,,889,2,,void
10286,BLOCK,-1,,"{
        p->next = e->page_freelist;
        e->page_freelist = p;
    }",12,,892,1,,void
10312,BLOCK,-1,,"{
    store_maint_thread *me = (store_maint_thread *)arg;
    store_engine *e = me->e;
    struct extstore_page_data *pd =
        calloc(e->page_count, sizeof(struct extstore_page_data));
    pthread_mutex_lock(&me->mutex);
    while (1) {
        int i;
        bool do_evict = false;
        unsigned int low_page = 0;
        uint64_t low_version = ULLONG_MAX;

        pthread_cond_wait(&me->cond, &me->mutex);
        pthread_mutex_lock(&e->mutex);
        // default freelist requires at least one page free.
        // specialized freelists fall back to default once full.
        if (e->page_free == 0 || e->page_freelist == NULL) {
            do_evict = true;
        }
        pthread_mutex_unlock(&e->mutex);
        memset(pd, 0, sizeof(struct extstore_page_data) * e->page_count);

        for (i = 0; i < e->page_count; i++) {
            store_page *p = &e->pages[i];
            pthread_mutex_lock(&p->mutex);
            pd[p->id].free_bucket = p->free_bucket;
            if (p...",47,,913,2,,void
10341,BLOCK,-1,,"{
        int i;
        bool do_evict = false;
        unsigned int low_page = 0;
        uint64_t low_version = ULLONG_MAX;

        pthread_cond_wait(&me->cond, &me->mutex);
        pthread_mutex_lock(&e->mutex);
        // default freelist requires at least one page free.
        // specialized freelists fall back to default once full.
        if (e->page_free == 0 || e->page_freelist == NULL) {
            do_evict = true;
        }
        pthread_mutex_unlock(&e->mutex);
        memset(pd, 0, sizeof(struct extstore_page_data) * e->page_count);

        for (i = 0; i < e->page_count; i++) {
            store_page *p = &e->pages[i];
            pthread_mutex_lock(&p->mutex);
            pd[p->id].free_bucket = p->free_bucket;
            if (p->active || p->free) {
                pthread_mutex_unlock(&p->mutex);
                continue;
            }
            if (p->obj_count > 0 && !p->closed) {
                pd[p->id].version = p->version;
                pd[p->id].byt...",15,,919,2,,void
10381,BLOCK,-1,,"{
            do_evict = true;
        }",60,,929,2,,void
10400,BLOCK,-1,,<empty>,9,,935,1,,void
10411,BLOCK,4,,"{
            store_page *p = &e->pages[i];
            pthread_mutex_lock(&p->mutex);
            pd[p->id].free_bucket = p->free_bucket;
            if (p->active || p->free) {
                pthread_mutex_unlock(&p->mutex);
                continue;
            }
            if (p->obj_count > 0 && !p->closed) {
                pd[p->id].version = p->version;
                pd[p->id].bytes_used = p->bytes_used;
                pd[p->id].bucket = p->bucket;
                // low_version/low_page are only used in the eviction
                // scenario. when we evict, it's only to fill the default page
                // bucket again.
                // TODO: experiment with allowing evicting up to a single page
                // for any specific free bucket. this is *probably* required
                // since it could cause a load bias on default-only devices?
                if (p->free_bucket == 0 && p->version < low_version) {
                    low_version = p->version;...",45,,935,4,,void
10445,BLOCK,-1,,"{
                pthread_mutex_unlock(&p->mutex);
                continue;
            }",39,,939,2,,void
10463,BLOCK,-1,,"{
                pd[p->id].version = p->version;
                pd[p->id].bytes_used = p->bytes_used;
                pd[p->id].bucket = p->bucket;
                // low_version/low_page are only used in the eviction
                // scenario. when we evict, it's only to fill the default page
                // bucket again.
                // TODO: experiment with allowing evicting up to a single page
                // for any specific free bucket. this is *probably* required
                // since it could cause a load bias on default-only devices?
                if (p->free_bucket == 0 && p->version < low_version) {
                    low_version = p->version;
                    low_page = i;
                }
            }",49,,943,2,,void
10509,BLOCK,-1,,"{
                    low_version = p->version;
                    low_page = i;
                }",70,,953,2,,void
10534,BLOCK,-1,,"{
                _free_page(e, p);
                // Found a page to free, no longer need to evict.
                do_evict = false;
            }",71,,958,2,,void
10552,BLOCK,-1,,"{
            store_page *p = &e->pages[low_page];
            E_DEBUG(""EXTSTORE: evicting page [%d] [v: %llu]\n"",
                    p->id, (unsigned long long) p->version);
            pthread_mutex_lock(&p->mutex);
            if (!p->closed) {
                p->closed = true;
                STAT_L(e);
                e->stats.page_evictions++;
                e->stats.objects_evicted += p->obj_count;
                e->stats.bytes_evicted += p->bytes_used;
                STAT_UL(e);
                if (p->refcount == 0) {
                    _free_page(e, p);
                }
            }
            pthread_mutex_unlock(&p->mutex);
        }",52,,966,2,,void
10572,BLOCK,-1,,"{
                p->closed = true;
                STAT_L(e);
                e->stats.page_evictions++;
                e->stats.objects_evicted += p->obj_count;
                e->stats.bytes_evicted += p->bytes_used;
                STAT_UL(e);
                if (p->refcount == 0) {
                    _free_page(e, p);
                }
            }",29,,971,2,,void
10580,BLOCK,1,,<empty>,,,,3,,void
10612,BLOCK,1,,<empty>,,,,3,,void
10624,BLOCK,-1,,"{
                    _free_page(e, p);
                }",39,,978,2,,void
10635,BLOCK,1,,<empty>,,,,3,,void
10656,BLOCK,1,,<empty>,,,,3,,void
10670,BLOCK,-1,,<empty>,1,,1,1,,ANY
10718,BLOCK,-1,,<empty>,,,,1,,<empty>
10730,BLOCK,-1,,<empty>,,,,4,,<empty>
10758,BLOCK,-1,,<empty>,,,,1,,<empty>
10766,BLOCK,-1,,<empty>,,,,2,,<empty>
10773,BLOCK,-1,,<empty>,,,,4,,<empty>
10781,BLOCK,-1,,<empty>,,,,5,,<empty>
10787,BLOCK,-1,,<empty>,,,,3,,<empty>
10793,BLOCK,-1,,<empty>,,,,3,,<empty>
10800,BLOCK,-1,,<empty>,,,,4,,<empty>
10809,BLOCK,-1,,<empty>,,,,6,,<empty>
10815,BLOCK,-1,,<empty>,,,,3,,<empty>
10821,BLOCK,-1,,<empty>,,,,3,,<empty>
10826,BLOCK,-1,,<empty>,,,,2,,<empty>
10833,BLOCK,-1,,<empty>,,,,4,,<empty>
10854,BLOCK,-1,,<empty>,1,,1,1,,ANY
10863,BLOCK,-1,,<empty>,1,,1,1,,ANY
10886,BLOCK,-1,,<empty>,1,,1,1,,ANY
10891,BLOCK,-1,,"{
    return (uint32_t)XXH3_64bits(key, length);
}",59,,11,3,,void
10896,BLOCK,1,,<empty>,,,,1,,void
10904,BLOCK,-1,,"{
    switch(type) {
        case JENKINS_HASH:
            hash = jenkins_hash;
            settings.hash_algorithm = ""jenkins"";
            break;
        case MURMUR3_HASH:
            hash = MurmurHash3_x86_32;
            settings.hash_algorithm = ""murmur3"";
            break;
        case XXH3_HASH:
            hash = XXH3_hash;
            settings.hash_algorithm = ""xxh3"";
            break;
        default:
            return -1;
    }
    return 0;
}",40,,15,2,,void
10907,BLOCK,-1,,"{
        case JENKINS_HASH:
            hash = jenkins_hash;
            settings.hash_algorithm = ""jenkins"";
            break;
        case MURMUR3_HASH:
            hash = MurmurHash3_x86_32;
            settings.hash_algorithm = ""murmur3"";
            break;
        case XXH3_HASH:
            hash = XXH3_hash;
            settings.hash_algorithm = ""xxh3"";
            break;
        default:
            return -1;
    }",18,,16,2,,void
10953,BLOCK,-1,,<empty>,1,,1,1,,ANY
10957,BLOCK,-1,,<empty>,,,,3,,<empty>
10966,BLOCK,-1,,<empty>,,,,1,,<empty>
10974,BLOCK,-1,,<empty>,,,,2,,<empty>
11019,BLOCK,-1,,<empty>,1,,1,1,,ANY
11022,BLOCK,-1,,<empty>,,,,2,,<empty>
11027,BLOCK,-1,,<empty>,,,,2,,<empty>
11035,BLOCK,1,,<empty>,,,,1,,void
11038,BLOCK,1,,<empty>,,,,1,,void
11041,BLOCK,1,,<empty>,,,,1,,void
11044,BLOCK,1,,<empty>,,,,1,,void
11072,BLOCK,1,,<empty>,,,,1,,void
11077,BLOCK,1,,<empty>,,,,1,,void
11082,BLOCK,1,,<empty>,,,,1,,void
11087,BLOCK,1,,<empty>,,,,1,,void
11092,BLOCK,1,,<empty>,,,,1,,void
11132,BLOCK,-1,,"{
    int i;
    for (i = 0; i < LARGEST_ID; i++) {
        pthread_mutex_lock(&lru_locks[i]);
        memset(&itemstats[i], 0, sizeof(itemstats_t));
        pthread_mutex_unlock(&lru_locks[i]);
    }
}",29,,71,2,,void
11135,BLOCK,-1,,<empty>,5,,73,1,,void
11142,BLOCK,1,,<empty>,,,,1,,void
11146,BLOCK,4,,"{
        pthread_mutex_lock(&lru_locks[i]);
        memset(&itemstats[i], 0, sizeof(itemstats_t));
        pthread_mutex_unlock(&lru_locks[i]);
    }",38,,73,4,,void
11172,BLOCK,-1,,"{
    itemstats[i].crawler_reclaimed += reclaimed;
    itemstats[i].expired_unfetched += unfetched;
    itemstats[i].crawler_items_checked += checked;
}",59,,82,5,,void
11225,BLOCK,-1,,<empty>,,,,4,,<empty>
11230,BLOCK,-1,,<empty>,,,,2,,<empty>
11235,BLOCK,-1,,"{
    pthread_mutex_lock(&cas_id_lock);
    uint64_t next_id = ++cas_id;
    pthread_mutex_unlock(&cas_id_lock);
    return next_id;
}",27,,112,2,,void
11253,BLOCK,-1,,"{
    pthread_mutex_lock(&cas_id_lock);
    cas_id = new_cas;
    pthread_mutex_unlock(&cas_id_lock);
}",35,,119,2,,void
11267,BLOCK,-1,,"{
    rel_time_t oldest_live = settings.oldest_live;
    uint64_t cas = ITEM_get_cas(it);
    uint64_t oldest_cas = settings.oldest_cas;
    if (oldest_live == 0 || oldest_live > current_time)
        return 0;
    if ((it->time <= oldest_live)
            || (oldest_cas != 0 && cas != 0 && cas < oldest_cas)) {
        return 1;
    }
    return 0;
}",31,,125,2,,void
11279,BLOCK,1,,<empty>,,,,2,,void
11308,BLOCK,-1,,<empty>,9,,130,2,,void
11329,BLOCK,-1,,"{
        return 1;
    }",67,,132,2,,void
11338,BLOCK,-1,,"{
    return sizes[id];
}",43,,139,2,,void
11351,BLOCK,-1,,"{
    if (flags == 0) {
        *nsuffix = 0;
    } else {
        *nsuffix = sizeof(flags);
    }
    return sizeof(item) + nkey + *nsuffix + nbytes;
}",54,,166,6,,void
11356,BLOCK,-1,,"{
        *nsuffix = 0;
    }",21,,167,2,,void
11362,BLOCK,-1,,"{
        *nsuffix = sizeof(flags);
    }",12,,169,1,,void
11383,BLOCK,-1,,"{
    item *it = NULL;
    int i;
    /* If no memory is available, attempt a direct LRU juggle/eviction */
    /* This is a race in order to simplify lru_pull_tail; in cases where
     * locked items are on the tail, you want them to fall out and cause
     * occasional OOM's, rather than internally work around them.
     * This also gives one fewer code path for slab alloc/free
     */
    for (i = 0; i < 10; i++) {
        /* Try to reclaim memory first */
        if (!settings.lru_segmented) {
            lru_pull_tail(id, COLD_LRU, 0, 0, 0, NULL);
        }
        it = slabs_alloc(ntotal, id, 0);

        if (it == NULL) {
            // We send '0' in for ""total_bytes"" as this routine is always
            // pulling to evict, or forcing HOT -> COLD migration.
            // As of this writing, total_bytes isn't at all used with COLD_LRU.
            if (lru_pull_tail(id, COLD_LRU, 0, LRU_PULL_EVICT, 0, NULL) <= 0) {
                if (settings.lru_segmented) {
             ...",70,,175,3,,void
11390,BLOCK,-1,,<empty>,5,,184,1,,void
11399,BLOCK,4,,"{
        /* Try to reclaim memory first */
        if (!settings.lru_segmented) {
            lru_pull_tail(id, COLD_LRU, 0, 0, 0, NULL);
        }
        it = slabs_alloc(ntotal, id, 0);

        if (it == NULL) {
            // We send '0' in for ""total_bytes"" as this routine is always
            // pulling to evict, or forcing HOT -> COLD migration.
            // As of this writing, total_bytes isn't at all used with COLD_LRU.
            if (lru_pull_tail(id, COLD_LRU, 0, LRU_PULL_EVICT, 0, NULL) <= 0) {
                if (settings.lru_segmented) {
                    lru_pull_tail(id, HOT_LRU, 0, 0, 0, NULL);
                } else {
                    break;
                }
            }
        } else {
            break;
        }
    }",30,,184,4,,void
11405,BLOCK,-1,,"{
            lru_pull_tail(id, COLD_LRU, 0, 0, 0, NULL);
        }",38,,186,2,,void
11409,BLOCK,1,,<empty>,,,,1,,void
11425,BLOCK,-1,,"{
            // We send '0' in for ""total_bytes"" as this routine is always
            // pulling to evict, or forcing HOT -> COLD migration.
            // As of this writing, total_bytes isn't at all used with COLD_LRU.
            if (lru_pull_tail(id, COLD_LRU, 0, LRU_PULL_EVICT, 0, NULL) <= 0) {
                if (settings.lru_segmented) {
                    lru_pull_tail(id, HOT_LRU, 0, 0, 0, NULL);
                } else {
                    break;
                }
            }
        }",25,,191,2,,void
11431,BLOCK,1,,<empty>,,,,1,,void
11435,BLOCK,1,,<empty>,,,,1,,void
11440,BLOCK,-1,,"{
                if (settings.lru_segmented) {
                    lru_pull_tail(id, HOT_LRU, 0, 0, 0, NULL);
                } else {
                    break;
                }
            }",79,,195,2,,void
11445,BLOCK,-1,,"{
                    lru_pull_tail(id, HOT_LRU, 0, 0, 0, NULL);
                }",45,,196,2,,void
11449,BLOCK,1,,<empty>,,,,1,,void
11456,BLOCK,-1,,"{
                    break;
                }",24,,198,1,,void
11459,BLOCK,-1,,"{
            break;
        }",16,,202,1,,void
11465,BLOCK,-1,,"{
        pthread_mutex_lock(&lru_locks[id]);
        itemstats[id].direct_reclaims += i;
        pthread_mutex_unlock(&lru_locks[id]);
    }",16,,207,2,,void
11490,BLOCK,-1,,"{
    // TODO: Should be a cleaner way of finding real size with slabber calls
    size_t size = bytes_remain + sizeof(item_chunk);
    if (size > settings.slab_chunk_size_max)
        size = settings.slab_chunk_size_max;
    unsigned int id = slabs_clsid(size);

    item_chunk *nch = (item_chunk *) do_item_alloc_pull(size, id);
    if (nch == NULL) {
        // The final chunk in a large item will attempt to be a more
        // appropriately sized chunk to minimize memory overhead. However, if
        // there's no memory available in the lower slab classes we fail the
        // SET. In these cases as a fallback we ensure we attempt to evict a
        // max-size item and reuse a large chunk.
        if (size == settings.slab_chunk_size_max) {
            return NULL;
        } else {
            size = settings.slab_chunk_size_max;
            id = slabs_clsid(size);
            nch = (item_chunk *) do_item_alloc_pull(size, id);

            if (nch == NULL)
                retu...",76,,221,3,,void
11504,BLOCK,-1,,<empty>,9,,225,2,,void
11527,BLOCK,-1,,"{
        // The final chunk in a large item will attempt to be a more
        // appropriately sized chunk to minimize memory overhead. However, if
        // there's no memory available in the lower slab classes we fail the
        // SET. In these cases as a fallback we ensure we attempt to evict a
        // max-size item and reuse a large chunk.
        if (size == settings.slab_chunk_size_max) {
            return NULL;
        } else {
            size = settings.slab_chunk_size_max;
            id = slabs_clsid(size);
            nch = (item_chunk *) do_item_alloc_pull(size, id);

            if (nch == NULL)
                return NULL;
        }
    }",22,,229,2,,void
11534,BLOCK,-1,,"{
            return NULL;
        }",51,,235,2,,void
11538,BLOCK,-1,,"{
            size = settings.slab_chunk_size_max;
            id = slabs_clsid(size);
            nch = (item_chunk *) do_item_alloc_pull(size, id);

            if (nch == NULL)
                return NULL;
        }",16,,237,1,,void
11559,BLOCK,-1,,<empty>,17,,243,2,,void
11608,BLOCK,1,,<empty>,,,,1,,void
11621,BLOCK,-1,,"{
    uint8_t nsuffix;
    item *it = NULL;
    char suffix[40];
    // Avoid potential underflows.
    if (nbytes < 2)
        return 0;

    size_t ntotal = item_make_header(nkey + 1, flags, nbytes, suffix, &nsuffix);
    if (settings.use_cas) {
        ntotal += sizeof(uint64_t);
    }

    unsigned int id = slabs_clsid(ntotal);
    unsigned int hdr_id = 0;
    if (id == 0)
        return 0;

    /* This is a large item. Allocate a header object now, lazily allocate
     *  chunks while reading the upload.
     */
    if (ntotal > settings.slab_chunk_size_max) {
        /* We still link this item into the LRU for the larger slab class, but
         * we're pulling a header from an entirely different slab class. The
         * free routines handle large items specifically.
         */
        int htotal = nkey + 1 + nsuffix + sizeof(item) + sizeof(item_chunk);
        if (settings.use_cas) {
            htotal += sizeof(uint64_t);
        }
#ifdef NEED_ALIGN
        // header chun...",65,,263,6,,void
11632,BLOCK,-1,,<empty>,9,,269,2,,void
11651,BLOCK,-1,,"{
        ntotal += sizeof(uint64_t);
    }",27,,272,2,,void
11669,BLOCK,-1,,<empty>,9,,279,2,,void
11678,BLOCK,-1,,"{
        /* We still link this item into the LRU for the larger slab class, but
         * we're pulling a header from an entirely different slab class. The
         * free routines handle large items specifically.
         */
        int htotal = nkey + 1 + nsuffix + sizeof(item) + sizeof(item_chunk);
        if (settings.use_cas) {
            htotal += sizeof(uint64_t);
        }
#ifdef NEED_ALIGN
        // header chunk needs to be padded on some systems
        int remain = htotal % 8;
        if (remain != 0) {
            htotal += 8 - remain;
        }
#endif
        hdr_id = slabs_clsid(htotal);
        it = do_item_alloc_pull(htotal, hdr_id);
        /* setting ITEM_CHUNKED is fine here because we aren't LINKED yet. */
        if (it != NULL)
            it->it_flags |= ITEM_CHUNKED;
    }",48,,284,2,,void
11697,BLOCK,-1,,"{
            htotal += sizeof(uint64_t);
        }",31,,290,2,,void
11715,BLOCK,-1,,<empty>,13,,304,2,,void
11721,BLOCK,1,,<empty>,,,,1,,void
11724,BLOCK,-1,,"{
        it = do_item_alloc_pull(ntotal, id);
    }",12,,305,1,,void
11734,BLOCK,-1,,"{
        pthread_mutex_lock(&lru_locks[id]);
        itemstats[id].outofmemory++;
        pthread_mutex_unlock(&lru_locks[id]);
        return NULL;
    }",21,,309,2,,void
11765,BLOCK,1,,<empty>,,,,1,,void
11788,BLOCK,-1,,"{
        id |= TEMP_LRU;
    }",63,,326,2,,void
11792,BLOCK,1,,<empty>,,,,1,,void
11795,BLOCK,-1,,<empty>,12,,328,1,,void
11800,BLOCK,-1,,"{
        id |= HOT_LRU;
    }",40,,328,2,,void
11804,BLOCK,1,,<empty>,,,,1,,void
11807,BLOCK,-1,,"{
        /* There is only COLD in compat-mode */
        id |= COLD_LRU;
    }",12,,330,1,,void
11811,BLOCK,1,,<empty>,,,,1,,void
11819,BLOCK,1,,<empty>,,,,1,,void
11831,BLOCK,1,,<empty>,,,,1,,void
11843,BLOCK,1,,<empty>,,,,1,,void
11859,BLOCK,1,,<empty>,,,,4,,void
11887,BLOCK,-1,,"{
        memcpy(ITEM_suffix(it), &flags, sizeof(flags));
    }",22,,343,2,,void
11891,BLOCK,1,,<empty>,,,,5,,void
11924,BLOCK,1,,<empty>,,,,1,,void
11926,BLOCK,-1,,"{
        item_chunk *chunk = (item_chunk *) ITEM_schunk(it);

        chunk->next = 0;
        chunk->prev = 0;
        chunk->used = 0;
        chunk->size = 0;
        chunk->head = it;
        chunk->orig_clsid = hdr_id;
    }",38,,348,2,,void
11934,BLOCK,1,,<empty>,,,,6,,void
12008,BLOCK,-1,,"{
    size_t ntotal = ITEM_ntotal(it);
    unsigned int clsid;
    assert((it->it_flags & ITEM_LINKED) == 0);
    assert(it != heads[it->slabs_clsid]);
    assert(it != tails[it->slabs_clsid]);
    assert(it->refcount == 0);

    /* so slab size changer can tell later if item is already free or not */
    clsid = ITEM_clsid(it);
    DEBUG_REFCNT(it, 'F');
    slabs_free(it, ntotal, clsid);
}",26,,363,2,,void
12014,BLOCK,1,,<empty>,,,,2,,void
12055,BLOCK,1,,<empty>,,,,1,,void
12084,BLOCK,1,,<empty>,,,,2,,void
12094,BLOCK,1,,<empty>,,,,1,,void
12107,BLOCK,-1,,"{
    char prefix[40];
    uint8_t nsuffix;
    if (nbytes < 2)
        return false;

    size_t ntotal = item_make_header(nkey + 1, flags, nbytes,
                                     prefix, &nsuffix);
    if (settings.use_cas) {
        ntotal += sizeof(uint64_t);
    }

    return slabs_clsid(ntotal) != 0;
}",73,,381,4,,void
12114,BLOCK,-1,,<empty>,9,,385,2,,void
12133,BLOCK,-1,,"{
        ntotal += sizeof(uint64_t);
    }",27,,389,2,,void
12147,BLOCK,-1,,"{
    item **head, **tail;
    int ntotal = ITEM_ntotal(it);
    uint32_t hv = hash(ITEM_key(it), it->nkey);
    assoc_insert(it, hv);

    head = &heads[it->slabs_clsid];
    tail = &tails[it->slabs_clsid];
    if (it->prev == 0 && *head == 0) *head = it;
    if (it->next == 0 && *tail == 0) *tail = it;
    sizes[it->slabs_clsid]++;
    sizes_bytes[it->slabs_clsid] += ntotal;

    STATS_LOCK();
    stats_state.curr_bytes += ntotal;
    stats_state.curr_items += 1;
    stats.total_items += 1;
    STATS_UNLOCK();

    item_stats_sizes_add(it);

    return;
}",35,,397,2,,void
12155,BLOCK,1,,<empty>,,,,2,,void
12194,BLOCK,1,,<empty>,,,,2,,void
12244,BLOCK,-1,,<empty>,38,,405,2,,void
12260,BLOCK,-1,,<empty>,38,,406,2,,void
12302,BLOCK,-1,,"{ /* item is the new head */
    item **head, **tail;
    assert((it->it_flags & ITEM_SLABBED) == 0);

    head = &heads[it->slabs_clsid];
    tail = &tails[it->slabs_clsid];
    assert(it != *head);
    assert((*head && *tail) || (*head == 0 && *tail == 0));
    it->prev = 0;
    it->next = *head;
    if (it->next) it->next->prev = it;
    *head = it;
    if (*tail == 0) *tail = it;
    sizes[it->slabs_clsid]++;
#ifdef EXTSTORE
    if (it->it_flags & ITEM_HDR) {
        sizes_bytes[it->slabs_clsid] += (ITEM_ntotal(it) - it->nbytes) + sizeof(item_hdr);
    } else {
        sizes_bytes[it->slabs_clsid] += ITEM_ntotal(it);
    }
#else
    sizes_bytes[it->slabs_clsid] += ITEM_ntotal(it);
#endif

    return;
}",38,,421,2,,void
12312,BLOCK,1,,<empty>,,,,1,,void
12367,BLOCK,-1,,<empty>,19,,431,2,,void
12384,BLOCK,-1,,<empty>,21,,433,2,,void
12403,BLOCK,1,,<empty>,,,,2,,void
12441,BLOCK,-1,,"{
    pthread_mutex_lock(&lru_locks[it->slabs_clsid]);
    do_item_link_q(it);
    pthread_mutex_unlock(&lru_locks[it->slabs_clsid]);
}",35,,448,2,,void
12462,BLOCK,-1,,"{
    pthread_mutex_lock(&lru_locks[it->slabs_clsid]);
    do_item_link_q(it);
    itemstats[it->slabs_clsid].moves_to_warm++;
    pthread_mutex_unlock(&lru_locks[it->slabs_clsid]);
}",40,,454,2,,void
12491,BLOCK,-1,,"{
    item **head, **tail;
    head = &heads[it->slabs_clsid];
    tail = &tails[it->slabs_clsid];

    if (*head == it) {
        assert(it->prev == 0);
        *head = it->next;
    }
    if (*tail == it) {
        assert(it->next == 0);
        *tail = it->prev;
    }
    assert(it->next != it);
    assert(it->prev != it);

    if (it->next) it->next->prev = it->prev;
    if (it->prev) it->prev->next = it->next;
    sizes[it->slabs_clsid]--;
#ifdef EXTSTORE
    if (it->it_flags & ITEM_HDR) {
        sizes_bytes[it->slabs_clsid] -= (ITEM_ntotal(it) - it->nbytes) + sizeof(item_hdr);
    } else {
        sizes_bytes[it->slabs_clsid] -= ITEM_ntotal(it);
    }
#else
    sizes_bytes[it->slabs_clsid] -= ITEM_ntotal(it);
#endif

    return;
}",40,,461,2,,void
12515,BLOCK,-1,,"{
        assert(it->prev == 0);
        *head = it->next;
    }",22,,466,2,,void
12533,BLOCK,-1,,"{
        assert(it->next == 0);
        *tail = it->prev;
    }",22,,470,2,,void
12562,BLOCK,-1,,<empty>,19,,477,2,,void
12576,BLOCK,-1,,<empty>,19,,478,2,,void
12600,BLOCK,1,,<empty>,,,,2,,void
12638,BLOCK,-1,,"{
    pthread_mutex_lock(&lru_locks[it->slabs_clsid]);
    do_item_unlink_q(it);
    pthread_mutex_unlock(&lru_locks[it->slabs_clsid]);
}",37,,493,2,,void
12660,BLOCK,-1,,"{
    MEMCACHED_ITEM_LINK(ITEM_key(it), it->nkey, it->nbytes);
    assert((it->it_flags & (ITEM_LINKED|ITEM_SLABBED)) == 0);
    it->it_flags |= ITEM_LINKED;
    it->time = current_time;

    STATS_LOCK();
    stats_state.curr_bytes += ITEM_ntotal(it);
    stats_state.curr_items += 1;
    stats.total_items += 1;
    STATS_UNLOCK();

    /* Allocate a new CAS ID on link. */
    ITEM_set_cas(it, (settings.use_cas) ? get_cas_id() : 0);
    assoc_insert(it, hv);
    item_link_q(it);
    refcount_incr(it);
    item_stats_sizes_add(it);

    return 1;
}",47,,499,3,,void
12669,BLOCK,1,,<empty>,,,,1,,void
12672,BLOCK,1,,<empty>,,,,1,,void
12680,BLOCK,1,,<empty>,,,,1,,void
12694,BLOCK,1,,<empty>,,,,2,,void
12740,BLOCK,1,,"ITEM_set_cas(it, (settings.use_cas) ? get_cas_id() : 0)",5,,512,9,,void
12747,BLOCK,-1,,"ITEM_set_cas(it, (settings.use_cas) ? get_cas_id() : 0)",5,,512,2,,void
12767,BLOCK,1,,<empty>,,,,2,,void
12781,BLOCK,-1,,"{
    MEMCACHED_ITEM_UNLINK(ITEM_key(it), it->nkey, it->nbytes);
    if ((it->it_flags & ITEM_LINKED) != 0) {
        it->it_flags &= ~ITEM_LINKED;
        STATS_LOCK();
        stats_state.curr_bytes -= ITEM_ntotal(it);
        stats_state.curr_items -= 1;
        STATS_UNLOCK();
        item_stats_sizes_remove(it);
        assoc_delete(ITEM_key(it), it->nkey, hv);
        item_unlink_q(it);
        do_item_remove(it);
    }
}",50,,521,3,,void
12789,BLOCK,1,,<empty>,,,,1,,void
12792,BLOCK,-1,,"{
        it->it_flags &= ~ITEM_LINKED;
        STATS_LOCK();
        stats_state.curr_bytes -= ITEM_ntotal(it);
        stats_state.curr_items -= 1;
        STATS_UNLOCK();
        item_stats_sizes_remove(it);
        assoc_delete(ITEM_key(it), it->nkey, hv);
        item_unlink_q(it);
        do_item_remove(it);
    }",44,,523,2,,void
12799,BLOCK,1,,<empty>,,,,1,,void
12808,BLOCK,1,,<empty>,,,,2,,void
12852,BLOCK,1,,<empty>,,,,2,,void
12882,BLOCK,-1,,"{
    MEMCACHED_ITEM_UNLINK(ITEM_key(it), it->nkey, it->nbytes);
    if ((it->it_flags & ITEM_LINKED) != 0) {
        it->it_flags &= ~ITEM_LINKED;
        STATS_LOCK();
        stats_state.curr_bytes -= ITEM_ntotal(it);
        stats_state.curr_items -= 1;
        STATS_UNLOCK();
        item_stats_sizes_remove(it);
        assoc_delete(ITEM_key(it), it->nkey, hv);
        do_item_unlink_q(it);
        do_item_remove(it);
    }
}",57,,537,3,,void
12890,BLOCK,1,,<empty>,,,,1,,void
12893,BLOCK,-1,,"{
        it->it_flags &= ~ITEM_LINKED;
        STATS_LOCK();
        stats_state.curr_bytes -= ITEM_ntotal(it);
        stats_state.curr_items -= 1;
        STATS_UNLOCK();
        item_stats_sizes_remove(it);
        assoc_delete(ITEM_key(it), it->nkey, hv);
        do_item_unlink_q(it);
        do_item_remove(it);
    }",44,,539,2,,void
12900,BLOCK,1,,<empty>,,,,1,,void
12909,BLOCK,1,,<empty>,,,,2,,void
12953,BLOCK,1,,<empty>,,,,2,,void
12982,BLOCK,-1,,"{
    MEMCACHED_ITEM_REMOVE(ITEM_key(it), it->nkey, it->nbytes);
    assert((it->it_flags & ITEM_SLABBED) == 0);
    assert(it->refcount > 0);

    if (refcount_decr(it) == 0) {
        item_free(it);
    }
}",31,,552,2,,void
12990,BLOCK,1,,<empty>,,,,1,,void
13003,BLOCK,1,,<empty>,,,,2,,void
13009,BLOCK,-1,,"{
        item_free(it);
    }",33,,557,2,,void
13016,BLOCK,-1,,"{
    MEMCACHED_ITEM_UPDATE(ITEM_key(it), it->nkey, it->nbytes);

    /* Hits to COLD_LRU immediately move to WARM. */
    if (settings.lru_segmented) {
        assert((it->it_flags & ITEM_SLABBED) == 0);
        if ((it->it_flags & ITEM_LINKED) != 0) {
            if (ITEM_lruid(it) == COLD_LRU && (it->it_flags & ITEM_ACTIVE)) {
                it->time = current_time;
                item_unlink_q(it);
                it->slabs_clsid = ITEM_clsid(it);
                it->slabs_clsid |= WARM_LRU;
                it->it_flags &= ~ITEM_ACTIVE;
                item_link_q_warm(it);
            } else {
                it->time = current_time;
            }
        }
    } else if (it->time < current_time - ITEM_UPDATE_INTERVAL) {
        assert((it->it_flags & ITEM_SLABBED) == 0);

        if ((it->it_flags & ITEM_LINKED) != 0) {
            it->time = current_time;
            item_unlink_q(it);
            item_link_q(it);
        }
    }
}",31,,563,2,,void
13021,BLOCK,-1,,"{
        assert((it->it_flags & ITEM_SLABBED) == 0);
        if ((it->it_flags & ITEM_LINKED) != 0) {
            if (ITEM_lruid(it) == COLD_LRU && (it->it_flags & ITEM_ACTIVE)) {
                it->time = current_time;
                item_unlink_q(it);
                it->slabs_clsid = ITEM_clsid(it);
                it->slabs_clsid |= WARM_LRU;
                it->it_flags &= ~ITEM_ACTIVE;
                item_link_q_warm(it);
            } else {
                it->time = current_time;
            }
        }
    }",33,,567,2,,void
13029,BLOCK,1,,<empty>,,,,1,,void
13039,BLOCK,1,,<empty>,,,,1,,void
13042,BLOCK,-1,,"{
            if (ITEM_lruid(it) == COLD_LRU && (it->it_flags & ITEM_ACTIVE)) {
                it->time = current_time;
                item_unlink_q(it);
                it->slabs_clsid = ITEM_clsid(it);
                it->slabs_clsid |= WARM_LRU;
                it->it_flags &= ~ITEM_ACTIVE;
                item_link_q_warm(it);
            } else {
                it->time = current_time;
            }
        }",48,,569,2,,void
13048,BLOCK,1,,<empty>,,,,2,,void
13057,BLOCK,1,,<empty>,,,,1,,void
13064,BLOCK,1,,<empty>,,,,1,,void
13066,BLOCK,-1,,"{
                it->time = current_time;
                item_unlink_q(it);
                it->slabs_clsid = ITEM_clsid(it);
                it->slabs_clsid |= WARM_LRU;
                it->it_flags &= ~ITEM_ACTIVE;
                item_link_q_warm(it);
            }",77,,570,2,,void
13080,BLOCK,1,,<empty>,,,,2,,void
13094,BLOCK,1,,<empty>,,,,1,,void
13102,BLOCK,1,,<empty>,,,,1,,void
13107,BLOCK,-1,,"{
                it->time = current_time;
            }",20,,577,1,,void
13114,BLOCK,-1,,<empty>,12,,581,1,,void
13123,BLOCK,1,,<empty>,,,,1,,void
13125,BLOCK,-1,,"{
        assert((it->it_flags & ITEM_SLABBED) == 0);

        if ((it->it_flags & ITEM_LINKED) != 0) {
            it->time = current_time;
            item_unlink_q(it);
            item_link_q(it);
        }
    }",64,,581,2,,void
13133,BLOCK,1,,<empty>,,,,1,,void
13143,BLOCK,1,,<empty>,,,,1,,void
13146,BLOCK,-1,,"{
            it->time = current_time;
            item_unlink_q(it);
            item_link_q(it);
        }",48,,584,2,,void
13162,BLOCK,-1,,"{
    MEMCACHED_ITEM_REPLACE(ITEM_key(it), it->nkey, it->nbytes,
                           ITEM_key(new_it), new_it->nkey, new_it->nbytes);
    assert((it->it_flags & ITEM_SLABBED) == 0);

    do_item_unlink(it, hv);
    return do_item_link(new_it, hv);
}",64,,592,4,,void
13170,BLOCK,1,,<empty>,,,,1,,void
13186,BLOCK,-1,,"{
    unsigned int memlimit = 2 * 1024 * 1024;   /* 2MB max response size */
    char *buffer;
    unsigned int bufcurr;
    item *it;
    unsigned int len;
    unsigned int shown = 0;
    char key_temp[KEY_MAX_LENGTH + 1];
    char temp[512];
    unsigned int id = slabs_clsid;
    id |= COLD_LRU;

    pthread_mutex_lock(&lru_locks[id]);
    it = heads[id];

    buffer = malloc((size_t)memlimit);
    if (buffer == 0) {
        pthread_mutex_unlock(&lru_locks[id]);
        return NULL;
    }
    bufcurr = 0;

    while (it != NULL && (limit == 0 || shown < limit)) {
        assert(it->nkey <= KEY_MAX_LENGTH);
        // protect from printing binary keys.
        if ((it->nbytes == 0 && it->nkey == 0) || (it->it_flags & ITEM_KEY_BINARY)) {
            it = it->next;
            continue;
        }
        /* Copy the key since it may not be null-terminated in the struct */
        strncpy(key_temp, ITEM_key(it), it->nkey);
        key_temp[it->nkey] = 0x00; /* terminate */
        len...",101,,608,4,,void
13212,BLOCK,1,,<empty>,,,,1,,void
13234,BLOCK,-1,,"{
        pthread_mutex_unlock(&lru_locks[id]);
        return NULL;
    }",22,,624,2,,void
13257,BLOCK,-1,,"{
        assert(it->nkey <= KEY_MAX_LENGTH);
        // protect from printing binary keys.
        if ((it->nbytes == 0 && it->nkey == 0) || (it->it_flags & ITEM_KEY_BINARY)) {
            it = it->next;
            continue;
        }
        /* Copy the key since it may not be null-terminated in the struct */
        strncpy(key_temp, ITEM_key(it), it->nkey);
        key_temp[it->nkey] = 0x00; /* terminate */
        len = snprintf(temp, sizeof(temp), ""ITEM %s [%d b; %llu s]\r\n"",
                       key_temp, it->nbytes - 2,
                       it->exptime == 0 ? 0 :
                       (unsigned long long)it->exptime + process_started);
        if (bufcurr + len + 6 > memlimit)  /* 6 is END\r\n\0 */
            break;
        memcpy(buffer + bufcurr, temp, len);
        bufcurr += len;
        shown++;
        it = it->next;
    }",57,,630,2,,void
13264,BLOCK,1,,<empty>,,,,1,,void
13284,BLOCK,1,,<empty>,,,,1,,void
13286,BLOCK,-1,,"{
            it = it->next;
            continue;
        }",85,,633,2,,void
13297,BLOCK,1,,<empty>,,,,4,,void
13359,BLOCK,-1,,<empty>,13,,645,2,,void
13401,BLOCK,-1,,"{
    int n;
    for (n = 0; n < MAX_NUMBER_OF_SLAB_CLASSES; n++) {
        item_stats_automove *cur = &am[n];

        // outofmemory records into HOT
        int i = n | HOT_LRU;
        pthread_mutex_lock(&lru_locks[i]);
        cur->outofmemory = itemstats[i].outofmemory;
        pthread_mutex_unlock(&lru_locks[i]);

        // evictions and tail age are from COLD
        i = n | COLD_LRU;
        pthread_mutex_lock(&lru_locks[i]);
        cur->evicted = itemstats[i].evicted;
        if (!tails[i]) {
            cur->age = 0;
        } else if (tails[i]->nbytes == 0 && tails[i]->nkey == 0 && tails[i]->it_flags == 1) {
            /* it's a crawler, check previous entry */
            if (tails[i]->prev) {
               cur->age = current_time - tails[i]->prev->time;
            } else {
               cur->age = 0;
            }
        } else {
            cur->age = current_time - tails[i]->time;
        }
        pthread_mutex_unlock(&lru_locks[i]);
     }
}",56,,663,2,,void
13404,BLOCK,-1,,<empty>,5,,665,1,,void
13411,BLOCK,1,,<empty>,,,,1,,void
13417,BLOCK,4,,"{
        item_stats_automove *cur = &am[n];

        // outofmemory records into HOT
        int i = n | HOT_LRU;
        pthread_mutex_lock(&lru_locks[i]);
        cur->outofmemory = itemstats[i].outofmemory;
        pthread_mutex_unlock(&lru_locks[i]);

        // evictions and tail age are from COLD
        i = n | COLD_LRU;
        pthread_mutex_lock(&lru_locks[i]);
        cur->evicted = itemstats[i].evicted;
        if (!tails[i]) {
            cur->age = 0;
        } else if (tails[i]->nbytes == 0 && tails[i]->nkey == 0 && tails[i]->it_flags == 1) {
            /* it's a crawler, check previous entry */
            if (tails[i]->prev) {
               cur->age = current_time - tails[i]->prev->time;
            } else {
               cur->age = 0;
            }
        } else {
            cur->age = current_time - tails[i]->time;
        }
        pthread_mutex_unlock(&lru_locks[i]);
     }",54,,665,4,,void
13431,BLOCK,1,,<empty>,,,,1,,void
13457,BLOCK,1,,<empty>,,,,1,,void
13478,BLOCK,-1,,"{
            cur->age = 0;
        }",24,,678,2,,void
13485,BLOCK,-1,,<empty>,16,,680,1,,void
13510,BLOCK,-1,,"{
            /* it's a crawler, check previous entry */
            if (tails[i]->prev) {
               cur->age = current_time - tails[i]->prev->time;
            } else {
               cur->age = 0;
            }
        }",93,,680,2,,void
13517,BLOCK,-1,,"{
               cur->age = current_time - tails[i]->prev->time;
            }",33,,682,2,,void
13532,BLOCK,-1,,"{
               cur->age = 0;
            }",20,,684,1,,void
13539,BLOCK,-1,,"{
            cur->age = current_time - tails[i]->time;
        }",16,,687,1,,void
13561,BLOCK,-1,,"{
    itemstats_t totals;
    memset(&totals, 0, sizeof(itemstats_t));
    int n;
    for (n = 0; n < MAX_NUMBER_OF_SLAB_CLASSES; n++) {
        int x;
        int i;
        for (x = 0; x < 4; x++) {
            i = n | lru_type_map[x];
            pthread_mutex_lock(&lru_locks[i]);
            totals.expired_unfetched += itemstats[i].expired_unfetched;
            totals.evicted_unfetched += itemstats[i].evicted_unfetched;
            totals.evicted_active += itemstats[i].evicted_active;
            totals.evicted += itemstats[i].evicted;
            totals.reclaimed += itemstats[i].reclaimed;
            totals.crawler_reclaimed += itemstats[i].crawler_reclaimed;
            totals.crawler_items_checked += itemstats[i].crawler_items_checked;
            totals.lrutail_reflocked += itemstats[i].lrutail_reflocked;
            totals.moves_to_cold += itemstats[i].moves_to_cold;
            totals.moves_to_warm += itemstats[i].moves_to_warm;
            totals.moves_within_lru += ite...",53,,694,3,,void
13571,BLOCK,-1,,<empty>,5,,698,1,,void
13578,BLOCK,1,,<empty>,,,,1,,void
13584,BLOCK,4,,"{
        int x;
        int i;
        for (x = 0; x < 4; x++) {
            i = n | lru_type_map[x];
            pthread_mutex_lock(&lru_locks[i]);
            totals.expired_unfetched += itemstats[i].expired_unfetched;
            totals.evicted_unfetched += itemstats[i].evicted_unfetched;
            totals.evicted_active += itemstats[i].evicted_active;
            totals.evicted += itemstats[i].evicted;
            totals.reclaimed += itemstats[i].reclaimed;
            totals.crawler_reclaimed += itemstats[i].crawler_reclaimed;
            totals.crawler_items_checked += itemstats[i].crawler_items_checked;
            totals.lrutail_reflocked += itemstats[i].lrutail_reflocked;
            totals.moves_to_cold += itemstats[i].moves_to_cold;
            totals.moves_to_warm += itemstats[i].moves_to_warm;
            totals.moves_within_lru += itemstats[i].moves_within_lru;
            totals.direct_reclaims += itemstats[i].direct_reclaims;
            pthread_mutex_unlock(&lru_l...",54,,698,4,,void
13588,BLOCK,-1,,<empty>,9,,701,1,,void
13597,BLOCK,4,,"{
            i = n | lru_type_map[x];
            pthread_mutex_lock(&lru_locks[i]);
            totals.expired_unfetched += itemstats[i].expired_unfetched;
            totals.evicted_unfetched += itemstats[i].evicted_unfetched;
            totals.evicted_active += itemstats[i].evicted_active;
            totals.evicted += itemstats[i].evicted;
            totals.reclaimed += itemstats[i].reclaimed;
            totals.crawler_reclaimed += itemstats[i].crawler_reclaimed;
            totals.crawler_items_checked += itemstats[i].crawler_items_checked;
            totals.lrutail_reflocked += itemstats[i].lrutail_reflocked;
            totals.moves_to_cold += itemstats[i].moves_to_cold;
            totals.moves_to_warm += itemstats[i].moves_to_warm;
            totals.moves_within_lru += itemstats[i].moves_within_lru;
            totals.direct_reclaims += itemstats[i].direct_reclaims;
            pthread_mutex_unlock(&lru_locks[i]);
        }",33,,701,4,,void
13726,BLOCK,1,,<empty>,,,,4,,void
13740,BLOCK,1,,<empty>,,,,4,,void
13755,BLOCK,-1,,"{
        APPEND_STAT(""evicted_active"", ""%llu"",
                    (unsigned long long)totals.evicted_active);
    }",41,,723,2,,void
13759,BLOCK,1,,<empty>,,,,4,,void
13773,BLOCK,1,,<empty>,,,,4,,void
13787,BLOCK,1,,<empty>,,,,4,,void
13801,BLOCK,1,,<empty>,,,,4,,void
13815,BLOCK,1,,<empty>,,,,4,,void
13829,BLOCK,1,,<empty>,,,,4,,void
13844,BLOCK,-1,,"{
        APPEND_STAT(""moves_to_cold"", ""%llu"",
                    (unsigned long long)totals.moves_to_cold);
        APPEND_STAT(""moves_to_warm"", ""%llu"",
                    (unsigned long long)totals.moves_to_warm);
        APPEND_STAT(""moves_within_lru"", ""%llu"",
                    (unsigned long long)totals.moves_within_lru);
        APPEND_STAT(""direct_reclaims"", ""%llu"",
                    (unsigned long long)totals.direct_reclaims);
        APPEND_STAT(""lru_bumps_dropped"", ""%llu"",
                    (unsigned long long)lru_total_bumps_dropped());
    }",41,,737,2,,void
13848,BLOCK,1,,<empty>,,,,4,,void
13862,BLOCK,1,,<empty>,,,,4,,void
13876,BLOCK,1,,<empty>,,,,4,,void
13890,BLOCK,1,,<empty>,,,,4,,void
13904,BLOCK,1,,<empty>,,,,3,,void
13918,BLOCK,-1,,"{
    struct thread_stats thread_stats;
    threadlocal_stats_aggregate(&thread_stats);
    itemstats_t totals;
    int n;
    for (n = 0; n < MAX_NUMBER_OF_SLAB_CLASSES; n++) {
        memset(&totals, 0, sizeof(itemstats_t));
        int x;
        int i;
        unsigned int size = 0;
        unsigned int age  = 0;
        unsigned int age_hot = 0;
        unsigned int age_warm = 0;
        unsigned int lru_size_map[4];
        const char *fmt = ""items:%d:%s"";
        char key_str[STAT_KEY_LEN];
        char val_str[STAT_VAL_LEN];
        int klen = 0, vlen = 0;
        for (x = 0; x < 4; x++) {
            i = n | lru_type_map[x];
            pthread_mutex_lock(&lru_locks[i]);
            totals.evicted += itemstats[i].evicted;
            totals.evicted_nonzero += itemstats[i].evicted_nonzero;
            totals.outofmemory += itemstats[i].outofmemory;
            totals.tailrepairs += itemstats[i].tailrepairs;
            totals.reclaimed += itemstats[i].reclaimed;
            ...",46,,751,3,,void
13926,BLOCK,-1,,<empty>,5,,756,1,,void
13933,BLOCK,1,,<empty>,,,,1,,void
13939,BLOCK,4,,"{
        memset(&totals, 0, sizeof(itemstats_t));
        int x;
        int i;
        unsigned int size = 0;
        unsigned int age  = 0;
        unsigned int age_hot = 0;
        unsigned int age_warm = 0;
        unsigned int lru_size_map[4];
        const char *fmt = ""items:%d:%s"";
        char key_str[STAT_KEY_LEN];
        char val_str[STAT_VAL_LEN];
        int klen = 0, vlen = 0;
        for (x = 0; x < 4; x++) {
            i = n | lru_type_map[x];
            pthread_mutex_lock(&lru_locks[i]);
            totals.evicted += itemstats[i].evicted;
            totals.evicted_nonzero += itemstats[i].evicted_nonzero;
            totals.outofmemory += itemstats[i].outofmemory;
            totals.tailrepairs += itemstats[i].tailrepairs;
            totals.reclaimed += itemstats[i].reclaimed;
            totals.expired_unfetched += itemstats[i].expired_unfetched;
            totals.evicted_unfetched += itemstats[i].evicted_unfetched;
            totals.evicted_active += itemsta...",54,,756,4,,void
13980,BLOCK,-1,,<empty>,9,,769,1,,void
13989,BLOCK,4,,"{
            i = n | lru_type_map[x];
            pthread_mutex_lock(&lru_locks[i]);
            totals.evicted += itemstats[i].evicted;
            totals.evicted_nonzero += itemstats[i].evicted_nonzero;
            totals.outofmemory += itemstats[i].outofmemory;
            totals.tailrepairs += itemstats[i].tailrepairs;
            totals.reclaimed += itemstats[i].reclaimed;
            totals.expired_unfetched += itemstats[i].expired_unfetched;
            totals.evicted_unfetched += itemstats[i].evicted_unfetched;
            totals.evicted_active += itemstats[i].evicted_active;
            totals.crawler_reclaimed += itemstats[i].crawler_reclaimed;
            totals.crawler_items_checked += itemstats[i].crawler_items_checked;
            totals.lrutail_reflocked += itemstats[i].lrutail_reflocked;
            totals.moves_to_cold += itemstats[i].moves_to_cold;
            totals.moves_to_warm += itemstats[i].moves_to_warm;
            totals.moves_within_lru += itemstats[i].m...",33,,769,4,,void
14163,BLOCK,1,,<empty>,,,,1,,void
14170,BLOCK,-1,,"{
                age = current_time - tails[i]->time;
            }",66,,790,2,,void
14181,BLOCK,-1,,<empty>,20,,792,1,,void
14189,BLOCK,1,,<empty>,,,,1,,void
14196,BLOCK,-1,,"{
                age_hot = current_time - tails[i]->time;
            }",72,,792,2,,void
14207,BLOCK,-1,,<empty>,20,,794,1,,void
14215,BLOCK,1,,<empty>,,,,1,,void
14222,BLOCK,-1,,"{
                age_warm = current_time - tails[i]->time;
            }",73,,794,2,,void
14238,BLOCK,1,,<empty>,,,,1,,void
14240,BLOCK,-1,,<empty>,17,,798,2,,void
14254,BLOCK,-1,,"{
                case HOT_LRU:
                    totals.hits_to_hot = thread_stats.lru_hits[i];
                    break;
                case WARM_LRU:
                    totals.hits_to_warm = thread_stats.lru_hits[i];
                    break;
                case COLD_LRU:
                    totals.hits_to_cold = thread_stats.lru_hits[i];
                    break;
                case TEMP_LRU:
                    totals.hits_to_temp = thread_stats.lru_hits[i];
                    break;
            }",38,,799,2,,void
14257,BLOCK,1,,<empty>,,,,1,,void
14271,BLOCK,1,,<empty>,,,,1,,void
14285,BLOCK,1,,<empty>,,,,1,,void
14299,BLOCK,1,,<empty>,,,,1,,void
14320,BLOCK,-1,,<empty>,13,,816,2,,void
14326,BLOCK,1,,<empty>,,,,8,,void
14352,BLOCK,-1,,"{
            APPEND_NUM_FMT_STAT(fmt, n, ""number_hot"", ""%u"", lru_size_map[0]);
            APPEND_NUM_FMT_STAT(fmt, n, ""number_warm"", ""%u"", lru_size_map[1]);
            APPEND_NUM_FMT_STAT(fmt, n, ""number_cold"", ""%u"", lru_size_map[2]);
            if (settings.temp_lru) {
                APPEND_NUM_FMT_STAT(fmt, n, ""number_temp"", ""%u"", lru_size_map[3]);
            }
            APPEND_NUM_FMT_STAT(fmt, n, ""age_hot"", ""%u"", age_hot);
            APPEND_NUM_FMT_STAT(fmt, n, ""age_warm"", ""%u"", age_warm);
        }",45,,818,2,,void
14357,BLOCK,1,,<empty>,,,,8,,void
14385,BLOCK,1,,<empty>,,,,8,,void
14413,BLOCK,1,,<empty>,,,,8,,void
14441,BLOCK,-1,,"{
                APPEND_NUM_FMT_STAT(fmt, n, ""number_temp"", ""%u"", lru_size_map[3]);
            }",36,,822,2,,void
14446,BLOCK,1,,<empty>,,,,8,,void
14474,BLOCK,1,,<empty>,,,,8,,void
14500,BLOCK,1,,<empty>,,,,8,,void
14526,BLOCK,1,,<empty>,,,,8,,void
14552,BLOCK,1,,<empty>,,,,8,,void
14582,BLOCK,1,,<empty>,,,,8,,void
14612,BLOCK,1,,<empty>,,,,8,,void
14642,BLOCK,1,,<empty>,,,,8,,void
14670,BLOCK,1,,<empty>,,,,8,,void
14700,BLOCK,1,,<empty>,,,,8,,void
14730,BLOCK,1,,<empty>,,,,8,,void
14760,BLOCK,1,,<empty>,,,,8,,void
14790,BLOCK,1,,<empty>,,,,8,,void
14820,BLOCK,-1,,"{
            APPEND_NUM_FMT_STAT(fmt, n, ""evicted_active"",
                                ""%llu"", (unsigned long long)totals.evicted_active);
        }",45,,846,2,,void
14825,BLOCK,1,,<empty>,,,,8,,void
14855,BLOCK,1,,<empty>,,,,8,,void
14885,BLOCK,1,,<empty>,,,,8,,void
14915,BLOCK,1,,<empty>,,,,8,,void
14945,BLOCK,-1,,"{
            APPEND_NUM_FMT_STAT(fmt, n, ""moves_to_cold"",
                                ""%llu"", (unsigned long long)totals.moves_to_cold);
            APPEND_NUM_FMT_STAT(fmt, n, ""moves_to_warm"",
                                ""%llu"", (unsigned long long)totals.moves_to_warm);
            APPEND_NUM_FMT_STAT(fmt, n, ""moves_within_lru"",
                                ""%llu"", (unsigned long long)totals.moves_within_lru);
            APPEND_NUM_FMT_STAT(fmt, n, ""direct_reclaims"",
                                ""%llu"", (unsigned long long)totals.direct_reclaims);
            APPEND_NUM_FMT_STAT(fmt, n, ""hits_to_hot"",
                                ""%llu"", (unsigned long long)totals.hits_to_hot);

            APPEND_NUM_FMT_STAT(fmt, n, ""hits_to_warm"",
                                ""%llu"", (unsigned long long)totals.hits_to_warm);

            APPEND_NUM_FMT_STAT(fmt, n, ""hits_to_cold"",
                                ""%llu"", (unsigned long long)totals.hits_to_cold);

          ...",45,,856,2,,void
14950,BLOCK,1,,<empty>,,,,8,,void
14980,BLOCK,1,,<empty>,,,,8,,void
15010,BLOCK,1,,<empty>,,,,8,,void
15040,BLOCK,1,,<empty>,,,,8,,void
15070,BLOCK,1,,<empty>,,,,8,,void
15100,BLOCK,1,,<empty>,,,,8,,void
15130,BLOCK,1,,<empty>,,,,8,,void
15160,BLOCK,1,,<empty>,,,,8,,void
15196,BLOCK,-1,,"{
    bool ret = false;
    mutex_lock(&stats_sizes_lock);
    if (stats_sizes_hist != NULL)
        ret = true;
    mutex_unlock(&stats_sizes_lock);
    return ret;
}",36,,884,2,,void
15204,BLOCK,1,,<empty>,,,,3,,void
15212,BLOCK,-1,,<empty>,9,,888,2,,void
15219,BLOCK,1,,<empty>,,,,3,,void
15229,BLOCK,-1,,"{
    if (stats_sizes_hist != NULL)
        return;
    stats_sizes_buckets = settings.item_size_max / 32 + 1;
    stats_sizes_hist = calloc(stats_sizes_buckets, sizeof(int));
    stats_sizes_cas_min = (settings.use_cas) ? get_cas_id() : 0;
}",34,,893,2,,void
15234,BLOCK,-1,,<empty>,9,,895,2,,void
15264,BLOCK,-1,,"{
    mutex_lock(&stats_sizes_lock);
    if (!settings.use_cas) {
        APPEND_STAT(""sizes_status"", ""error"", """");
        APPEND_STAT(""sizes_error"", ""cas_support_disabled"", """");
    } else if (stats_sizes_hist == NULL) {
        item_stats_sizes_init();
        if (stats_sizes_hist != NULL) {
            APPEND_STAT(""sizes_status"", ""enabled"", """");
        } else {
            APPEND_STAT(""sizes_status"", ""error"", """");
            APPEND_STAT(""sizes_error"", ""no_memory"", """");
        }
    } else {
        APPEND_STAT(""sizes_status"", ""enabled"", """");
    }
    mutex_unlock(&stats_sizes_lock);
}",59,,901,3,,void
15268,BLOCK,1,,<empty>,,,,3,,void
15277,BLOCK,-1,,"{
        APPEND_STAT(""sizes_status"", ""error"", """");
        APPEND_STAT(""sizes_error"", ""cas_support_disabled"", """");
    }",28,,903,2,,void
15282,BLOCK,1,,<empty>,,,,4,,void
15293,BLOCK,1,,<empty>,,,,4,,void
15301,BLOCK,-1,,<empty>,12,,906,1,,void
15306,BLOCK,-1,,"{
        item_stats_sizes_init();
        if (stats_sizes_hist != NULL) {
            APPEND_STAT(""sizes_status"", ""enabled"", """");
        } else {
            APPEND_STAT(""sizes_status"", ""error"", """");
            APPEND_STAT(""sizes_error"", ""no_memory"", """");
        }
    }",42,,906,2,,void
15312,BLOCK,-1,,"{
            APPEND_STAT(""sizes_status"", ""enabled"", """");
        }",39,,908,2,,void
15317,BLOCK,1,,<empty>,,,,4,,void
15325,BLOCK,-1,,"{
            APPEND_STAT(""sizes_status"", ""error"", """");
            APPEND_STAT(""sizes_error"", ""no_memory"", """");
        }",16,,910,1,,void
15330,BLOCK,1,,<empty>,,,,4,,void
15341,BLOCK,1,,<empty>,,,,4,,void
15349,BLOCK,-1,,"{
        APPEND_STAT(""sizes_status"", ""enabled"", """");
    }",12,,914,1,,void
15354,BLOCK,1,,<empty>,,,,4,,void
15364,BLOCK,1,,<empty>,,,,3,,void
15373,BLOCK,-1,,"{
    mutex_lock(&stats_sizes_lock);
    if (stats_sizes_hist != NULL) {
        free(stats_sizes_hist);
        stats_sizes_hist = NULL;
    }
    APPEND_STAT(""sizes_status"", ""disabled"", """");
    mutex_unlock(&stats_sizes_lock);
}",60,,920,3,,void
15377,BLOCK,1,,<empty>,,,,3,,void
15385,BLOCK,-1,,"{
        free(stats_sizes_hist);
        stats_sizes_hist = NULL;
    }",35,,922,2,,void
15395,BLOCK,1,,<empty>,,,,4,,void
15405,BLOCK,1,,<empty>,,,,3,,void
15413,BLOCK,-1,,"{
    if (stats_sizes_hist == NULL || stats_sizes_cas_min > ITEM_get_cas(it))
        return;
    int ntotal = ITEM_ntotal(it);
    int bucket = ntotal / 32;
    if ((ntotal % 32) != 0) bucket++;
    if (bucket < stats_sizes_buckets) stats_sizes_hist[bucket]++;
}",37,,930,2,,void
15423,BLOCK,1,,<empty>,,,,2,,void
15438,BLOCK,-1,,<empty>,9,,932,2,,void
15445,BLOCK,1,,<empty>,,,,2,,void
15490,BLOCK,-1,,<empty>,29,,935,2,,void
15497,BLOCK,-1,,<empty>,39,,936,2,,void
15506,BLOCK,-1,,"{
    if (stats_sizes_hist == NULL || stats_sizes_cas_min > ITEM_get_cas(it))
        return;
    int ntotal = ITEM_ntotal(it);
    int bucket = ntotal / 32;
    if ((ntotal % 32) != 0) bucket++;
    if (bucket < stats_sizes_buckets) stats_sizes_hist[bucket]--;
}",40,,942,2,,void
15516,BLOCK,1,,<empty>,,,,2,,void
15531,BLOCK,-1,,<empty>,9,,944,2,,void
15538,BLOCK,1,,<empty>,,,,2,,void
15583,BLOCK,-1,,<empty>,29,,947,2,,void
15590,BLOCK,-1,,<empty>,39,,948,2,,void
15600,BLOCK,-1,,"{
    mutex_lock(&stats_sizes_lock);

    if (stats_sizes_hist != NULL) {
        int i;
        for (i = 0; i < stats_sizes_buckets; i++) {
            if (stats_sizes_hist[i] != 0) {
                char key[12];
                snprintf(key, sizeof(key), ""%d"", i * 32);
                APPEND_STAT(key, ""%u"", stats_sizes_hist[i]);
            }
        }
    } else {
        APPEND_STAT(""sizes_status"", ""disabled"", """");
    }

    add_stats(NULL, 0, NULL, 0, c);
    mutex_unlock(&stats_sizes_lock);
}",52,,957,3,,void
15604,BLOCK,1,,<empty>,,,,3,,void
15612,BLOCK,-1,,"{
        int i;
        for (i = 0; i < stats_sizes_buckets; i++) {
            if (stats_sizes_hist[i] != 0) {
                char key[12];
                snprintf(key, sizeof(key), ""%d"", i * 32);
                APPEND_STAT(key, ""%u"", stats_sizes_hist[i]);
            }
        }
    }",35,,960,2,,void
15615,BLOCK,-1,,<empty>,9,,962,1,,void
15624,BLOCK,4,,"{
            if (stats_sizes_hist[i] != 0) {
                char key[12];
                snprintf(key, sizeof(key), ""%d"", i * 32);
                APPEND_STAT(key, ""%u"", stats_sizes_hist[i]);
            }
        }",51,,962,4,,void
15631,BLOCK,-1,,"{
                char key[12];
                snprintf(key, sizeof(key), ""%d"", i * 32);
                APPEND_STAT(key, ""%u"", stats_sizes_hist[i]);
            }",43,,963,2,,void
15647,BLOCK,1,,<empty>,,,,7,,void
15657,BLOCK,-1,,"{
        APPEND_STAT(""sizes_status"", ""disabled"", """");
    }",12,,969,1,,void
15662,BLOCK,1,,<empty>,,,,4,,void
15678,BLOCK,1,,<empty>,,,,3,,void
15690,BLOCK,-1,,"{
    item *it = assoc_find(key, nkey, hv);
    if (it != NULL) {
        refcount_incr(it);
        /* Optimization for slab reassignment. prevents popular items from
         * jamming in busy wait. Can only do this here to satisfy lock order
         * of item_lock, slabs_lock. */
        /* This was made unsafe by removal of the cache_lock:
         * slab_rebalance_signal and slab_rebal.* are modified in a separate
         * thread under slabs_lock. If slab_rebalance_signal = 1, slab_start =
         * NULL (0), but slab_end is still equal to some value, this would end
         * up unlinking every item fetched.
         * This is either an acceptable loss, or if slab_rebalance_signal is
         * true, slab_start/slab_end should be put behind the slabs_lock.
         * Which would cause a huge potential slowdown.
         * Could also use a specific lock for slab_rebal.* and
         * slab_rebalance_signal (shorter lock?)
         */
        /*if (slab_rebalance_signal &&
 ...",105,,978,6,,void
15702,BLOCK,-1,,"{
        refcount_incr(it);
        /* Optimization for slab reassignment. prevents popular items from
         * jamming in busy wait. Can only do this here to satisfy lock order
         * of item_lock, slabs_lock. */
        /* This was made unsafe by removal of the cache_lock:
         * slab_rebalance_signal and slab_rebal.* are modified in a separate
         * thread under slabs_lock. If slab_rebalance_signal = 1, slab_start =
         * NULL (0), but slab_end is still equal to some value, this would end
         * up unlinking every item fetched.
         * This is either an acceptable loss, or if slab_rebalance_signal is
         * true, slab_start/slab_end should be put behind the slabs_lock.
         * Which would cause a huge potential slowdown.
         * Could also use a specific lock for slab_rebal.* and
         * slab_rebalance_signal (shorter lock?)
         */
        /*if (slab_rebalance_signal &&
            ((void *)it >= slab_rebal.slab_start && (void *)it < ...",21,,980,2,,void
15705,BLOCK,1,,<empty>,,,,3,,void
15720,BLOCK,-1,,"{
        int ii;
        if (it == NULL) {
            fprintf(stderr, ""> NOT FOUND "");
        } else {
            fprintf(stderr, ""> FOUND KEY "");
        }
        for (ii = 0; ii < nkey; ++ii) {
            fprintf(stderr, ""%c"", key[ii]);
        }
    }",31,,1005,2,,void
15726,BLOCK,-1,,"{
            fprintf(stderr, ""> NOT FOUND "");
        }",25,,1007,2,,void
15731,BLOCK,-1,,"{
            fprintf(stderr, ""> FOUND KEY "");
        }",16,,1009,1,,void
15736,BLOCK,-1,,<empty>,9,,1012,1,,void
15745,BLOCK,4,,"{
            fprintf(stderr, ""%c"", key[ii]);
        }",39,,1012,4,,void
15756,BLOCK,-1,,"{
        was_found = 1;
        if (item_is_flushed(it)) {
            do_item_unlink(it, hv);
            STORAGE_delete(c->thread->storage, it);
            do_item_remove(it);
            it = NULL;
            pthread_mutex_lock(&c->thread->stats.mutex);
            c->thread->stats.get_flushed++;
            pthread_mutex_unlock(&c->thread->stats.mutex);
            if (settings.verbose > 2) {
                fprintf(stderr, "" -nuked by flush"");
            }
            was_found = 2;
        } else if (it->exptime != 0 && it->exptime <= current_time) {
            do_item_unlink(it, hv);
            STORAGE_delete(c->thread->storage, it);
            do_item_remove(it);
            it = NULL;
            pthread_mutex_lock(&c->thread->stats.mutex);
            c->thread->stats.get_expired++;
            pthread_mutex_unlock(&c->thread->stats.mutex);
            if (settings.verbose > 2) {
                fprintf(stderr, "" -nuked by expire"");
            }
            was_fou...",21,,1017,2,,void
15763,BLOCK,-1,,"{
            do_item_unlink(it, hv);
            STORAGE_delete(c->thread->storage, it);
            do_item_remove(it);
            it = NULL;
            pthread_mutex_lock(&c->thread->stats.mutex);
            c->thread->stats.get_flushed++;
            pthread_mutex_unlock(&c->thread->stats.mutex);
            if (settings.verbose > 2) {
                fprintf(stderr, "" -nuked by flush"");
            }
            was_found = 2;
        }",34,,1019,2,,void
15804,BLOCK,-1,,"{
                fprintf(stderr, "" -nuked by flush"");
            }",39,,1027,2,,void
15812,BLOCK,-1,,<empty>,16,,1031,1,,void
15825,BLOCK,-1,,"{
            do_item_unlink(it, hv);
            STORAGE_delete(c->thread->storage, it);
            do_item_remove(it);
            it = NULL;
            pthread_mutex_lock(&c->thread->stats.mutex);
            c->thread->stats.get_expired++;
            pthread_mutex_unlock(&c->thread->stats.mutex);
            if (settings.verbose > 2) {
                fprintf(stderr, "" -nuked by expire"");
            }
            was_found = 3;
        }",69,,1031,2,,void
15866,BLOCK,-1,,"{
                fprintf(stderr, "" -nuked by expire"");
            }",39,,1039,2,,void
15874,BLOCK,-1,,"{
            if (do_update) {
                do_item_bump(c, it, hv);
            }
            DEBUG_REFCNT(it, '+');
        }",16,,1043,1,,void
15877,BLOCK,-1,,"{
                do_item_bump(c, it, hv);
            }",28,,1044,2,,void
15883,BLOCK,1,,<empty>,,,,1,,void
15892,BLOCK,-1,,<empty>,9,,1052,2,,void
15904,BLOCK,1,,<empty>,,,,11,,void
15906,BLOCK,-1,,"LOGGER_LOG(c->thread->l, LOG_FETCHERS, LOGGER_ITEM_GET, NULL, was_found, key,
               nkey, (it) ? it->nbytes : 0, (it) ? ITEM_clsid(it) : 0, c->sfd)",5,,1054,1,,void
15923,BLOCK,-1,,<empty>,5,,1054,2,,void
15938,BLOCK,-1,,<empty>,5,,1054,2,,void
15975,BLOCK,-1,,"{
    /* We update the hit markers only during fetches.
     * An item needs to be hit twice overall to be considered
     * ACTIVE, but only needs a single hit to maintain activity
     * afterward.
     * FETCHED tells if an item has ever been active.
     */
    if (settings.lru_segmented) {
        if ((it->it_flags & ITEM_ACTIVE) == 0) {
            if ((it->it_flags & ITEM_FETCHED) == 0) {
                it->it_flags |= ITEM_FETCHED;
            } else {
                it->it_flags |= ITEM_ACTIVE;
                if (ITEM_lruid(it) != COLD_LRU) {
                    it->time = current_time; // only need to bump time.
                } else if (!lru_bump_async(c->thread->lru_bump_buf, it, hv)) {
                    // add flag before async bump to avoid race.
                    it->it_flags &= ~ITEM_ACTIVE;
                }
            }
        }
    } else {
        it->it_flags |= ITEM_FETCHED;
        do_item_update(it);
    }
}",57,,1063,4,,void
15980,BLOCK,-1,,"{
        if ((it->it_flags & ITEM_ACTIVE) == 0) {
            if ((it->it_flags & ITEM_FETCHED) == 0) {
                it->it_flags |= ITEM_FETCHED;
            } else {
                it->it_flags |= ITEM_ACTIVE;
                if (ITEM_lruid(it) != COLD_LRU) {
                    it->time = current_time; // only need to bump time.
                } else if (!lru_bump_async(c->thread->lru_bump_buf, it, hv)) {
                    // add flag before async bump to avoid race.
                    it->it_flags &= ~ITEM_ACTIVE;
                }
            }
        }
    }",33,,1070,2,,void
15988,BLOCK,1,,<empty>,,,,1,,void
15991,BLOCK,-1,,"{
            if ((it->it_flags & ITEM_FETCHED) == 0) {
                it->it_flags |= ITEM_FETCHED;
            } else {
                it->it_flags |= ITEM_ACTIVE;
                if (ITEM_lruid(it) != COLD_LRU) {
                    it->time = current_time; // only need to bump time.
                } else if (!lru_bump_async(c->thread->lru_bump_buf, it, hv)) {
                    // add flag before async bump to avoid race.
                    it->it_flags &= ~ITEM_ACTIVE;
                }
            }
        }",48,,1071,2,,void
15999,BLOCK,1,,<empty>,,,,1,,void
16002,BLOCK,-1,,"{
                it->it_flags |= ITEM_FETCHED;
            }",53,,1072,2,,void
16008,BLOCK,1,,<empty>,,,,1,,void
16011,BLOCK,-1,,"{
                it->it_flags |= ITEM_ACTIVE;
                if (ITEM_lruid(it) != COLD_LRU) {
                    it->time = current_time; // only need to bump time.
                } else if (!lru_bump_async(c->thread->lru_bump_buf, it, hv)) {
                    // add flag before async bump to avoid race.
                    it->it_flags &= ~ITEM_ACTIVE;
                }
            }",20,,1074,1,,void
16017,BLOCK,1,,<empty>,,,,1,,void
16023,BLOCK,1,,<empty>,,,,2,,void
16032,BLOCK,1,,<empty>,,,,1,,void
16034,BLOCK,-1,,"{
                    it->time = current_time; // only need to bump time.
                }",49,,1076,2,,void
16041,BLOCK,-1,,<empty>,24,,1078,1,,void
16052,BLOCK,-1,,"{
                    // add flag before async bump to avoid race.
                    it->it_flags &= ~ITEM_ACTIVE;
                }",78,,1078,2,,void
16059,BLOCK,1,,<empty>,,,,1,,void
16062,BLOCK,-1,,"{
        it->it_flags |= ITEM_FETCHED;
        do_item_update(it);
    }",12,,1084,1,,void
16068,BLOCK,1,,<empty>,,,,1,,void
16080,BLOCK,-1,,"{
    item *it = do_item_get(key, nkey, hv, c, DO_UPDATE);
    if (it != NULL) {
        it->exptime = exptime;
    }
    return it;
}",49,,1091,6,,void
16090,BLOCK,1,,<empty>,,,,1,,void
16096,BLOCK,-1,,"{
        it->exptime = exptime;
    }",21,,1093,2,,void
16113,BLOCK,-1,,"{
    item *it = NULL;
    int id = orig_id;
    int removed = 0;
    if (id == 0)
        return 0;

    int tries = 5;
    item *search;
    item *next_it;
    void *hold_lock = NULL;
    unsigned int move_to_lru = 0;
    uint64_t limit = 0;

    id |= cur_lru;
    pthread_mutex_lock(&lru_locks[id]);
    search = tails[id];
    /* We walk up *only* for locked items, and if bottom is expired. */
    for (; tries > 0 && search != NULL; tries--, search=next_it) {
        /* we might relink search mid-loop, so search->prev isn't reliable */
        next_it = search->prev;
        if (search->nbytes == 0 && search->nkey == 0 && search->it_flags == 1) {
            /* We are a crawler, ignore it. */
            if (flags & LRU_PULL_CRAWL_BLOCKS) {
                pthread_mutex_unlock(&lru_locks[id]);
                return 0;
            }
            tries++;
            continue;
        }
        uint32_t hv = hash(ITEM_key(search), search->nkey);
        /* Attempt to hash item lock...",46,,1105,7,,void
16130,BLOCK,-1,,<empty>,9,,1110,2,,void
16165,BLOCK,-1,,<empty>,5,,1123,1,,void
16179,BLOCK,4,,"{
        /* we might relink search mid-loop, so search->prev isn't reliable */
        next_it = search->prev;
        if (search->nbytes == 0 && search->nkey == 0 && search->it_flags == 1) {
            /* We are a crawler, ignore it. */
            if (flags & LRU_PULL_CRAWL_BLOCKS) {
                pthread_mutex_unlock(&lru_locks[id]);
                return 0;
            }
            tries++;
            continue;
        }
        uint32_t hv = hash(ITEM_key(search), search->nkey);
        /* Attempt to hash item lock the ""search"" item. If locked, no
         * other callers can incr the refcount. Also skip ourselves. */
        if ((hold_lock = item_trylock(hv)) == NULL)
            continue;
        /* Now see if the item is refcount locked */
        if (refcount_incr(search) != 2) {
            /* Note pathological case with ref'ed items in tail.
             * Can still unlink the item, but it won't be reusable yet */
            itemstats[id].lrutail_reflocked++;
    ...",66,,1123,4,,void
16203,BLOCK,-1,,"{
            /* We are a crawler, ignore it. */
            if (flags & LRU_PULL_CRAWL_BLOCKS) {
                pthread_mutex_unlock(&lru_locks[id]);
                return 0;
            }
            tries++;
            continue;
        }",80,,1126,2,,void
16208,BLOCK,1,,<empty>,,,,1,,void
16210,BLOCK,-1,,"{
                pthread_mutex_unlock(&lru_locks[id]);
                return 0;
            }",48,,1128,2,,void
16227,BLOCK,1,,<empty>,,,,4,,void
16254,BLOCK,-1,,<empty>,13,,1139,2,,void
16260,BLOCK,1,,<empty>,,,,3,,void
16266,BLOCK,-1,,"{
            /* Note pathological case with ref'ed items in tail.
             * Can still unlink the item, but it won't be reusable yet */
            itemstats[id].lrutail_reflocked++;
            /* In case of refcount leaks, enable for quick workaround. */
            /* WARNING: This can cause terrible corruption */
            if (settings.tail_repair_time &&
                    search->time + settings.tail_repair_time < current_time) {
                itemstats[id].tailrepairs++;
                search->refcount = 1;
                /* This will call item_remove -> item_free since refcnt is 1 */
                STORAGE_delete(ext_storage, search);
                do_item_unlink_nolock(search, hv);
                item_trylock_unlock(hold_lock);
                continue;
            }
        }",41,,1141,2,,void
16287,BLOCK,-1,,"{
                itemstats[id].tailrepairs++;
                search->refcount = 1;
                /* This will call item_remove -> item_free since refcnt is 1 */
                STORAGE_delete(ext_storage, search);
                do_item_unlink_nolock(search, hv);
                item_trylock_unlock(hold_lock);
                continue;
            }",78,,1148,2,,void
16320,BLOCK,-1,,"{
            itemstats[id].reclaimed++;
            if ((search->it_flags & ITEM_FETCHED) == 0) {
                itemstats[id].expired_unfetched++;
            }
            /* refcnt 2 -> 1 */
            do_item_unlink_nolock(search, hv);
            STORAGE_delete(ext_storage, search);
            /* refcnt 1 -> 0 -> item_free */
            do_item_remove(search);
            item_trylock_unlock(hold_lock);
            removed++;

            /* If all we're finding are expired, can keep going */
            continue;
        }",41,,1161,2,,void
16334,BLOCK,1,,<empty>,,,,1,,void
16337,BLOCK,-1,,"{
                itemstats[id].expired_unfetched++;
            }",57,,1163,2,,void
16356,BLOCK,-1,,"{
            case HOT_LRU:
                limit = total_bytes * settings.hot_lru_pct / 100;
            case WARM_LRU:
                if (limit == 0)
                    limit = total_bytes * settings.warm_lru_pct / 100;
                /* Rescue ACTIVE items aggressively */
                if ((search->it_flags & ITEM_ACTIVE) != 0) {
                    search->it_flags &= ~ITEM_ACTIVE;
                    removed++;
                    if (cur_lru == WARM_LRU) {
                        itemstats[id].moves_within_lru++;
                        do_item_unlink_q(search);
                        do_item_link_q(search);
                        do_item_remove(search);
                        item_trylock_unlock(hold_lock);
                    } else {
                        /* Active HOT_LRU items flow to WARM */
                        itemstats[id].moves_to_warm++;
                        move_to_lru = WARM_LRU;
                        do_item_unlink_q(search);
                   ...",26,,1181,2,,void
16359,BLOCK,1,,<empty>,,,,1,,void
16372,BLOCK,1,,<empty>,,,,1,,void
16378,BLOCK,-1,,<empty>,21,,1186,2,,void
16395,BLOCK,1,,<empty>,,,,1,,void
16398,BLOCK,-1,,"{
                    search->it_flags &= ~ITEM_ACTIVE;
                    removed++;
                    if (cur_lru == WARM_LRU) {
                        itemstats[id].moves_within_lru++;
                        do_item_unlink_q(search);
                        do_item_link_q(search);
                        do_item_remove(search);
                        item_trylock_unlock(hold_lock);
                    } else {
                        /* Active HOT_LRU items flow to WARM */
                        itemstats[id].moves_to_warm++;
                        move_to_lru = WARM_LRU;
                        do_item_unlink_q(search);
                        it = search;
                    }
                }",60,,1188,2,,void
16405,BLOCK,1,,<empty>,,,,1,,void
16413,BLOCK,1,,<empty>,,,,1,,void
16415,BLOCK,-1,,"{
                        itemstats[id].moves_within_lru++;
                        do_item_unlink_q(search);
                        do_item_link_q(search);
                        do_item_remove(search);
                        item_trylock_unlock(hold_lock);
                    }",46,,1191,2,,void
16431,BLOCK,-1,,"{
                        /* Active HOT_LRU items flow to WARM */
                        itemstats[id].moves_to_warm++;
                        move_to_lru = WARM_LRU;
                        do_item_unlink_q(search);
                        it = search;
                    }",28,,1197,1,,void
16441,BLOCK,1,,<empty>,,,,1,,void
16449,BLOCK,-1,,<empty>,24,,1204,1,,void
16464,BLOCK,-1,,"{
                    itemstats[id].moves_to_cold++;
                    move_to_lru = COLD_LRU;
                    do_item_unlink_q(search);
                    it = search;
                    removed++;
                    break;
                }",67,,1205,2,,void
16474,BLOCK,1,,<empty>,,,,1,,void
16485,BLOCK,-1,,"{
                    /* Don't want to move to COLD, not active, bail out */
                    it = search;
                }",24,,1212,1,,void
16492,BLOCK,1,,<empty>,,,,1,,void
16501,BLOCK,1,,<empty>,,,,1,,void
16503,BLOCK,-1,,"{
                    if (settings.evict_to_free == 0) {
                        /* Don't think we need a counter for this. It'll OOM.  */
                        break;
                    }
                    itemstats[id].evicted++;
                    itemstats[id].evicted_time = current_time - search->time;
                    if (search->exptime != 0)
                        itemstats[id].evicted_nonzero++;
                    if ((search->it_flags & ITEM_FETCHED) == 0) {
                        itemstats[id].evicted_unfetched++;
                    }
                    if ((search->it_flags & ITEM_ACTIVE)) {
                        itemstats[id].evicted_active++;
                    }
                    LOGGER_LOG(NULL, LOG_EVICTIONS, LOGGER_EVICTION, search);
                    STORAGE_delete(ext_storage, search);
                    do_item_unlink_nolock(search, hv);
                    removed++;
                    if (settings.slab_automove == 2) {
                  ...",45,,1219,2,,void
16510,BLOCK,-1,,"{
                        /* Don't think we need a counter for this. It'll OOM.  */
                        break;
                    }",54,,1220,2,,void
16535,BLOCK,-1,,<empty>,25,,1227,2,,void
16549,BLOCK,1,,<empty>,,,,1,,void
16552,BLOCK,-1,,"{
                        itemstats[id].evicted_unfetched++;
                    }",65,,1228,2,,void
16565,BLOCK,1,,<empty>,,,,1,,void
16567,BLOCK,-1,,"{
                        itemstats[id].evicted_active++;
                    }",59,,1231,2,,void
16579,BLOCK,1,,<empty>,,,,8,,void
16581,BLOCK,-1,,"LOGGER_LOG(NULL, LOG_EVICTIONS, LOGGER_EVICTION, search)",21,,1234,1,,void
16590,BLOCK,-1,,<empty>,21,,1234,2,,void
16605,BLOCK,-1,,<empty>,21,,1234,2,,void
16622,BLOCK,-1,,"{
                        slabs_reassign(-1, orig_id);
                    }",54,,1238,2,,void
16628,BLOCK,-1,,<empty>,24,,1241,1,,void
16633,BLOCK,1,,<empty>,,,,1,,void
16635,BLOCK,-1,,"{
                    /* Keep a reference to this item and return it. */
                    ret_it->it = it;
                    ret_it->hv = hv;
                }",58,,1241,2,,void
16647,BLOCK,-1,,<empty>,24,,1245,1,,void
16656,BLOCK,1,,<empty>,,,,1,,void
16662,BLOCK,-1,,"{
                    itemstats[id].moves_to_warm++;
                    search->it_flags &= ~ITEM_ACTIVE;
                    move_to_lru = WARM_LRU;
                    do_item_unlink_q(search);
                    removed++;
                }",52,,1246,2,,void
16675,BLOCK,1,,<empty>,,,,1,,void
16680,BLOCK,1,,<empty>,,,,1,,void
16689,BLOCK,1,,<empty>,,,,1,,void
16699,BLOCK,-1,,<empty>,13,,1259,2,,void
16710,BLOCK,-1,,"{
        if (move_to_lru) {
            it->slabs_clsid = ITEM_clsid(it);
            it->slabs_clsid |= move_to_lru;
            item_link_q(it);
        }
        if ((flags & LRU_PULL_RETURN_ITEM) == 0) {
            do_item_remove(it);
            item_trylock_unlock(hold_lock);
        }
    }",21,,1264,2,,void
16713,BLOCK,-1,,"{
            it->slabs_clsid = ITEM_clsid(it);
            it->slabs_clsid |= move_to_lru;
            item_link_q(it);
        }",26,,1265,2,,void
16720,BLOCK,1,,<empty>,,,,3,,void
16741,BLOCK,1,,<empty>,,,,1,,void
16744,BLOCK,-1,,"{
            do_item_remove(it);
            item_trylock_unlock(hold_lock);
        }",50,,1270,2,,void
16755,BLOCK,-1,,"{
    pthread_mutex_lock(&bump_buf_lock);
    assert(b != bump_buf_head);

    b->prev = 0;
    b->next = bump_buf_head;
    if (b->next) b->next->prev = b;
    bump_buf_head = b;
    if (bump_buf_tail == 0) bump_buf_tail = b;
    pthread_mutex_unlock(&bump_buf_lock);
    return;
}",50,,1281,2,,void
16777,BLOCK,-1,,<empty>,18,,1287,2,,void
16792,BLOCK,-1,,<empty>,29,,1289,2,,void
16804,BLOCK,-1,,"{
    lru_bump_buf *b = calloc(1, sizeof(lru_bump_buf));
    if (b == NULL) {
        return NULL;
    }

    b->buf = bipbuf_new(sizeof(lru_bump_entry) * LRU_BUMP_BUF_SIZE);
    if (b->buf == NULL) {
        free(b);
        return NULL;
    }

    pthread_mutex_init(&b->mutex, NULL);

    lru_bump_buf_link_q(b);
    return b;
}",38,,1294,2,,void
16816,BLOCK,-1,,"{
        return NULL;
    }",20,,1296,2,,void
16828,BLOCK,1,,<empty>,,,,1,,void
16836,BLOCK,-1,,"{
        free(b);
        return NULL;
    }",25,,1301,2,,void
16857,BLOCK,-1,,"{
    bool ret = true;
    refcount_incr(it);
    pthread_mutex_lock(&b->mutex);
    lru_bump_entry *be = (lru_bump_entry *) bipbuf_request(b->buf, sizeof(lru_bump_entry));
    if (be != NULL) {
        be->it = it;
        be->hv = hv;
        if (bipbuf_push(b->buf, sizeof(lru_bump_entry)) == 0) {
            ret = false;
            b->dropped++;
        }
    } else {
        ret = false;
        b->dropped++;
    }
    if (!ret) {
        refcount_decr(it);
    }
    pthread_mutex_unlock(&b->mutex);
    return ret;
}",68,,1312,4,,void
16864,BLOCK,1,,<empty>,,,,2,,void
16889,BLOCK,-1,,"{
        be->it = it;
        be->hv = hv;
        if (bipbuf_push(b->buf, sizeof(lru_bump_entry)) == 0) {
            ret = false;
            b->dropped++;
        }
    }",21,,1317,2,,void
16909,BLOCK,-1,,"{
            ret = false;
            b->dropped++;
        }",63,,1320,2,,void
16918,BLOCK,-1,,"{
        ret = false;
        b->dropped++;
    }",12,,1324,1,,void
16929,BLOCK,-1,,"{
        refcount_decr(it);
    }",15,,1328,2,,void
16932,BLOCK,1,,<empty>,,,,2,,void
16948,BLOCK,-1,,"{
    lru_bump_buf *b;
    lru_bump_entry *be;
    unsigned int size;
    unsigned int todo;
    bool bumped = false;
    pthread_mutex_lock(&bump_buf_lock);
    for (b = bump_buf_head; b != NULL; b=b->next) {
        pthread_mutex_lock(&b->mutex);
        be = (lru_bump_entry *) bipbuf_peek_all(b->buf, &size);
        pthread_mutex_unlock(&b->mutex);

        if (be == NULL) {
            continue;
        }
        todo = size;
        bumped = true;

        while (todo) {
            item_lock(be->hv);
            do_item_update(be->it);
            do_item_remove(be->it);
            item_unlock(be->hv);
            be++;
            todo -= sizeof(lru_bump_entry);
        }

        pthread_mutex_lock(&b->mutex);
        be = (lru_bump_entry *) bipbuf_poll(b->buf, size);
        pthread_mutex_unlock(&b->mutex);
    }
    pthread_mutex_unlock(&bump_buf_lock);
    return bumped;
}",40,,1341,2,,void
16961,BLOCK,-1,,<empty>,5,,1348,1,,void
16973,BLOCK,4,,"{
        pthread_mutex_lock(&b->mutex);
        be = (lru_bump_entry *) bipbuf_peek_all(b->buf, &size);
        pthread_mutex_unlock(&b->mutex);

        if (be == NULL) {
            continue;
        }
        todo = size;
        bumped = true;

        while (todo) {
            item_lock(be->hv);
            do_item_update(be->it);
            do_item_remove(be->it);
            item_unlock(be->hv);
            be++;
            todo -= sizeof(lru_bump_entry);
        }

        pthread_mutex_lock(&b->mutex);
        be = (lru_bump_entry *) bipbuf_poll(b->buf, size);
        pthread_mutex_unlock(&b->mutex);
    }",51,,1348,4,,void
16998,BLOCK,-1,,"{
            continue;
        }",25,,1353,2,,void
17008,BLOCK,-1,,"{
            item_lock(be->hv);
            do_item_update(be->it);
            do_item_remove(be->it);
            item_unlock(be->hv);
            be++;
            todo -= sizeof(lru_bump_entry);
        }",22,,1359,2,,void
17059,BLOCK,-1,,"{
    uint64_t total = 0;
    lru_bump_buf *b;
    pthread_mutex_lock(&bump_buf_lock);
    for (b = bump_buf_head; b != NULL; b=b->next) {
        pthread_mutex_lock(&b->mutex);
        total += b->dropped;
        pthread_mutex_unlock(&b->mutex);
    }
    pthread_mutex_unlock(&bump_buf_lock);
    return total;
}",47,,1376,2,,void
17069,BLOCK,-1,,<empty>,5,,1380,1,,void
17081,BLOCK,4,,"{
        pthread_mutex_lock(&b->mutex);
        total += b->dropped;
        pthread_mutex_unlock(&b->mutex);
    }",51,,1380,4,,void
17106,BLOCK,-1,,"{
    int i;
    int did_moves = 0;
    uint64_t total_bytes = 0;
    unsigned int chunks_perslab = 0;
    //unsigned int chunks_free = 0;
    /* TODO: if free_chunks below high watermark, increase aggressiveness */
    slabs_available_chunks(slabs_clsid, NULL,
            &chunks_perslab);
    if (settings.temp_lru) {
        /* Only looking for reclaims. Run before we size the LRU. */
        for (i = 0; i < 500; i++) {
            if (lru_pull_tail(slabs_clsid, TEMP_LRU, 0, 0, 0, NULL) <= 0) {
                break;
            } else {
                did_moves++;
            }
        }
    }

    rel_time_t cold_age = 0;
    rel_time_t hot_age = 0;
    rel_time_t warm_age = 0;
    /* If LRU is in flat mode, force items to drain into COLD via max age of 0 */
    if (settings.lru_segmented) {
        pthread_mutex_lock(&lru_locks[slabs_clsid|COLD_LRU]);
        if (tails[slabs_clsid|COLD_LRU]) {
            cold_age = current_time - tails[slabs_clsid|COLD_LRU]->time;
        }
 ...",57,,1397,2,,void
17129,BLOCK,-1,,"{
        /* Only looking for reclaims. Run before we size the LRU. */
        for (i = 0; i < 500; i++) {
            if (lru_pull_tail(slabs_clsid, TEMP_LRU, 0, 0, 0, NULL) <= 0) {
                break;
            } else {
                did_moves++;
            }
        }
    }",28,,1406,2,,void
17131,BLOCK,-1,,<empty>,9,,1408,1,,void
17140,BLOCK,4,,"{
            if (lru_pull_tail(slabs_clsid, TEMP_LRU, 0, 0, 0, NULL) <= 0) {
                break;
            } else {
                did_moves++;
            }
        }",35,,1408,4,,void
17146,BLOCK,1,,<empty>,,,,1,,void
17153,BLOCK,-1,,"{
                break;
            }",75,,1409,2,,void
17156,BLOCK,-1,,"{
                did_moves++;
            }",20,,1411,1,,void
17175,BLOCK,-1,,"{
        pthread_mutex_lock(&lru_locks[slabs_clsid|COLD_LRU]);
        if (tails[slabs_clsid|COLD_LRU]) {
            cold_age = current_time - tails[slabs_clsid|COLD_LRU]->time;
        }
        // Also build up total_bytes for the classes.
        total_bytes += sizes_bytes[slabs_clsid|COLD_LRU];
        pthread_mutex_unlock(&lru_locks[slabs_clsid|COLD_LRU]);

        hot_age = cold_age * settings.hot_max_factor;
        warm_age = cold_age * settings.warm_max_factor;

        // total_bytes doesn't have to be exact. cache it for the juggles.
        pthread_mutex_lock(&lru_locks[slabs_clsid|HOT_LRU]);
        total_bytes += sizes_bytes[slabs_clsid|HOT_LRU];
        pthread_mutex_unlock(&lru_locks[slabs_clsid|HOT_LRU]);

        pthread_mutex_lock(&lru_locks[slabs_clsid|WARM_LRU]);
        total_bytes += sizes_bytes[slabs_clsid|WARM_LRU];
        pthread_mutex_unlock(&lru_locks[slabs_clsid|WARM_LRU]);
    }",33,,1421,2,,void
17183,BLOCK,1,,<empty>,,,,1,,void
17191,BLOCK,1,,<empty>,,,,1,,void
17193,BLOCK,-1,,"{
            cold_age = current_time - tails[slabs_clsid|COLD_LRU]->time;
        }",42,,1423,2,,void
17204,BLOCK,1,,<empty>,,,,1,,void
17214,BLOCK,1,,<empty>,,,,1,,void
17223,BLOCK,1,,<empty>,,,,1,,void
17246,BLOCK,1,,<empty>,,,,1,,void
17255,BLOCK,1,,<empty>,,,,1,,void
17264,BLOCK,1,,<empty>,,,,1,,void
17273,BLOCK,1,,<empty>,,,,1,,void
17282,BLOCK,1,,<empty>,,,,1,,void
17291,BLOCK,1,,<empty>,,,,1,,void
17294,BLOCK,-1,,<empty>,5,,1444,1,,void
17303,BLOCK,4,,"{
        int do_more = 0;
        if (lru_pull_tail(slabs_clsid, HOT_LRU, total_bytes, LRU_PULL_CRAWL_BLOCKS, hot_age, NULL) ||
            lru_pull_tail(slabs_clsid, WARM_LRU, total_bytes, LRU_PULL_CRAWL_BLOCKS, warm_age, NULL)) {
            do_more++;
        }
        if (settings.lru_segmented) {
            do_more += lru_pull_tail(slabs_clsid, COLD_LRU, total_bytes, LRU_PULL_CRAWL_BLOCKS, 0, NULL);
        }
        if (do_more == 0)
            break;
        did_moves++;
    }",31,,1444,4,,void
17313,BLOCK,1,,<empty>,,,,1,,void
17317,BLOCK,1,,<empty>,,,,1,,void
17324,BLOCK,1,,<empty>,,,,1,,void
17328,BLOCK,1,,<empty>,,,,1,,void
17332,BLOCK,-1,,"{
            do_more++;
        }",103,,1447,2,,void
17339,BLOCK,-1,,"{
            do_more += lru_pull_tail(slabs_clsid, COLD_LRU, total_bytes, LRU_PULL_CRAWL_BLOCKS, 0, NULL);
        }",37,,1450,2,,void
17345,BLOCK,1,,<empty>,,,,1,,void
17349,BLOCK,1,,<empty>,,,,1,,void
17357,BLOCK,-1,,<empty>,13,,1454,2,,void
17368,BLOCK,-1,,"{
    int i;
    static rel_time_t next_crawls[POWER_LARGEST];
    static rel_time_t next_crawl_wait[POWER_LARGEST];
    uint8_t todo[POWER_LARGEST];
    memset(todo, 0, sizeof(uint8_t) * POWER_LARGEST);
    bool do_run = false;
    unsigned int tocrawl_limit = 0;

    // TODO: If not segmented LRU, skip non-cold
    for (i = POWER_SMALLEST; i < POWER_LARGEST; i++) {
        crawlerstats_t *s = &cdata->crawlerstats[i];
        /* We've not successfully kicked off a crawl yet. */
        if (s->run_complete) {
            char *lru_name = ""na"";
            pthread_mutex_lock(&cdata->lock);
            int x;
            /* Should we crawl again? */
            uint64_t possible_reclaims = s->seen - s->noexp;
            uint64_t available_reclaims = 0;
            /* Need to think we can free at least 1% of the items before
             * crawling. */
            /* FIXME: Configurable? */
            uint64_t low_watermark = (possible_reclaims / 100) + 1;
            rel_time_t sinc...",89,,1474,3,,void
17380,BLOCK,1,,<empty>,,,,1,,void
17391,BLOCK,-1,,<empty>,5,,1484,1,,void
17395,BLOCK,1,,<empty>,,,,1,,void
17400,BLOCK,1,,<empty>,,,,1,,void
17404,BLOCK,4,,"{
        crawlerstats_t *s = &cdata->crawlerstats[i];
        /* We've not successfully kicked off a crawl yet. */
        if (s->run_complete) {
            char *lru_name = ""na"";
            pthread_mutex_lock(&cdata->lock);
            int x;
            /* Should we crawl again? */
            uint64_t possible_reclaims = s->seen - s->noexp;
            uint64_t available_reclaims = 0;
            /* Need to think we can free at least 1% of the items before
             * crawling. */
            /* FIXME: Configurable? */
            uint64_t low_watermark = (possible_reclaims / 100) + 1;
            rel_time_t since_run = current_time - s->end_time;
            /* Don't bother if the payoff is too low. */
            for (x = 0; x < 60; x++) {
                available_reclaims += s->histo[x];
                if (available_reclaims > low_watermark) {
                    if (next_crawl_wait[i] < (x * 60)) {
                        next_crawl_wait[i] += 60;
                    ...",54,,1484,4,,void
17418,BLOCK,-1,,"{
            char *lru_name = ""na"";
            pthread_mutex_lock(&cdata->lock);
            int x;
            /* Should we crawl again? */
            uint64_t possible_reclaims = s->seen - s->noexp;
            uint64_t available_reclaims = 0;
            /* Need to think we can free at least 1% of the items before
             * crawling. */
            /* FIXME: Configurable? */
            uint64_t low_watermark = (possible_reclaims / 100) + 1;
            rel_time_t since_run = current_time - s->end_time;
            /* Don't bother if the payoff is too low. */
            for (x = 0; x < 60; x++) {
                available_reclaims += s->histo[x];
                if (available_reclaims > low_watermark) {
                    if (next_crawl_wait[i] < (x * 60)) {
                        next_crawl_wait[i] += 60;
                    } else if (next_crawl_wait[i] >= 60) {
                        next_crawl_wait[i] -= 60;
                    }
                    break;
       ...",30,,1487,2,,void
17460,BLOCK,-1,,<empty>,13,,1500,1,,void
17469,BLOCK,4,,"{
                available_reclaims += s->histo[x];
                if (available_reclaims > low_watermark) {
                    if (next_crawl_wait[i] < (x * 60)) {
                        next_crawl_wait[i] += 60;
                    } else if (next_crawl_wait[i] >= 60) {
                        next_crawl_wait[i] -= 60;
                    }
                    break;
                }
            }",38,,1500,4,,void
17481,BLOCK,-1,,"{
                    if (next_crawl_wait[i] < (x * 60)) {
                        next_crawl_wait[i] += 60;
                    } else if (next_crawl_wait[i] >= 60) {
                        next_crawl_wait[i] -= 60;
                    }
                    break;
                }",57,,1502,2,,void
17490,BLOCK,-1,,"{
                        next_crawl_wait[i] += 60;
                    }",56,,1503,2,,void
17497,BLOCK,-1,,<empty>,28,,1505,1,,void
17504,BLOCK,-1,,"{
                        next_crawl_wait[i] -= 60;
                    }",58,,1505,2,,void
17515,BLOCK,-1,,"{
                next_crawl_wait[i] += 60;
            }",42,,1512,2,,void
17527,BLOCK,1,,<empty>,,,,1,,void
17531,BLOCK,-1,,"{
                next_crawl_wait[i] = MAX_MAINTCRAWL_WAIT;
            }",59,,1516,2,,void
17537,BLOCK,1,,<empty>,,,,1,,void
17555,BLOCK,1,,<empty>,,,,3,,void
17561,BLOCK,-1,,"{
                case HOT_LRU:
                    lru_name = ""hot"";
                    break;
                case WARM_LRU:
                    lru_name = ""warm"";
                    break;
                case COLD_LRU:
                    lru_name = ""cold"";
                    break;
                case TEMP_LRU:
                    lru_name = ""temp"";
                    break;
            }",33,,1521,2,,void
17564,BLOCK,1,,<empty>,,,,1,,void
17572,BLOCK,1,,<empty>,,,,1,,void
17580,BLOCK,1,,<empty>,,,,1,,void
17588,BLOCK,1,,<empty>,,,,1,,void
17598,BLOCK,1,,<empty>,,,,17,,void
17600,BLOCK,-1,,"LOGGER_LOG(l, LOG_SYSEVENTS, LOGGER_CRAWLER_STATUS, NULL,
                    CLEAR_LRU(i),
                    lru_name,
                    (unsigned long long)low_watermark,
                    (unsigned long long)available_reclaims,
                    (unsigned int)since_run,
                    next_crawls[i] - current_time,
                    s->end_time - s->start_time,
                    s->seen,
                    s->reclaimed)",13,,1535,1,,void
17609,BLOCK,-1,,<empty>,13,,1535,2,,void
17624,BLOCK,-1,,<empty>,13,,1535,2,,void
17680,BLOCK,-1,,"{
            pthread_mutex_lock(&lru_locks[i]);
            if (sizes[i] > tocrawl_limit) {
                tocrawl_limit = sizes[i];
            }
            pthread_mutex_unlock(&lru_locks[i]);
            todo[i] = 1;
            do_run = true;
            next_crawls[i] = current_time + 5; // minimum retry wait.
        }",44,,1549,2,,void
17692,BLOCK,-1,,"{
                tocrawl_limit = sizes[i];
            }",43,,1551,2,,void
17720,BLOCK,-1,,"{
        if (settings.lru_crawler_tocrawl && settings.lru_crawler_tocrawl < tocrawl_limit) {
            tocrawl_limit = settings.lru_crawler_tocrawl;
        }
        lru_crawler_start(todo, tocrawl_limit, CRAWLER_AUTOEXPIRE, cdata, NULL, 0);
    }",17,,1560,2,,void
17731,BLOCK,-1,,"{
            tocrawl_limit = settings.lru_crawler_tocrawl;
        }",91,,1561,2,,void
17750,BLOCK,1,,<empty>,5,,1569,1,,void
17754,BLOCK,2,,<empty>,5,,1570,2,,void
17758,BLOCK,3,,<empty>,5,,1571,3,,void
17765,BLOCK,-1,,"{
    slab_automove_reg_t *sam = &slab_automove_default;
#ifdef EXTSTORE
    void *storage = arg;
    if (storage != NULL)
        sam = &slab_automove_extstore;
#endif
    int i;
    useconds_t to_sleep = MIN_LRU_MAINTAINER_SLEEP;
    useconds_t last_sleep = MIN_LRU_MAINTAINER_SLEEP;
    rel_time_t last_crawler_check = 0;
    rel_time_t last_automove_check = 0;
    useconds_t next_juggles[MAX_NUMBER_OF_SLAB_CLASSES] = {0};
    useconds_t backoff_juggles[MAX_NUMBER_OF_SLAB_CLASSES] = {0};
    struct crawler_expired_data *cdata =
        calloc(1, sizeof(struct crawler_expired_data));
    if (cdata == NULL) {
        fprintf(stderr, ""Failed to allocate crawler data for LRU maintainer thread\n"");
        abort();
    }
    pthread_mutex_init(&cdata->lock, NULL);
    cdata->crawl_complete = true; // kick off the crawler.
    logger *l = logger_create();
    if (l == NULL) {
        fprintf(stderr, ""Failed to allocate logger for LRU maintainer thread\n"");
        abort();
    }

    dou...",47,,1585,2,,void
17776,BLOCK,1,,<empty>,,,,1,,void
17782,BLOCK,1,,<empty>,,,,1,,void
17813,BLOCK,-1,,"{
        fprintf(stderr, ""Failed to allocate crawler data for LRU maintainer thread\n"");
        abort();
    }",24,,1601,2,,void
17837,BLOCK,-1,,"{
        fprintf(stderr, ""Failed to allocate logger for LRU maintainer thread\n"");
        abort();
    }",20,,1608,2,,void
17866,BLOCK,-1,,<empty>,9,,1618,2,,void
17872,BLOCK,-1,,"{
        pthread_mutex_unlock(&lru_maintainer_lock);
        if (to_sleep)
            usleep(to_sleep);
        pthread_mutex_lock(&lru_maintainer_lock);
        /* A sleep of zero counts as a minimum of a 1ms wait */
        last_sleep = to_sleep > 1000 ? to_sleep : 1000;
        to_sleep = MAX_LRU_MAINTAINER_SLEEP;

        STATS_LOCK();
        stats.lru_maintainer_juggles++;
        STATS_UNLOCK();

        /* Each slab class gets its own sleep to avoid hammering locks */
        for (i = POWER_SMALLEST; i < MAX_NUMBER_OF_SLAB_CLASSES; i++) {
            next_juggles[i] = next_juggles[i] > last_sleep ? next_juggles[i] - last_sleep : 0;

            if (next_juggles[i] > 0) {
                // Sleep the thread just for the minimum amount (or not at all)
                if (next_juggles[i] < to_sleep)
                    to_sleep = next_juggles[i];
                continue;
            }

            int did_moves = lru_maintainer_juggle(i);
            if (did_moves == 0) {
  ...",42,,1619,2,,void
17878,BLOCK,-1,,<empty>,13,,1622,2,,void
17895,BLOCK,1,,<empty>,,,,1,,void
17904,BLOCK,-1,,<empty>,9,,1633,1,,void
17908,BLOCK,1,,<empty>,,,,1,,void
17913,BLOCK,1,,<empty>,,,,1,,void
17919,BLOCK,4,,"{
            next_juggles[i] = next_juggles[i] > last_sleep ? next_juggles[i] - last_sleep : 0;

            if (next_juggles[i] > 0) {
                // Sleep the thread just for the minimum amount (or not at all)
                if (next_juggles[i] < to_sleep)
                    to_sleep = next_juggles[i];
                continue;
            }

            int did_moves = lru_maintainer_juggle(i);
            if (did_moves == 0) {
                if (backoff_juggles[i] != 0) {
                    backoff_juggles[i] += backoff_juggles[i] / 8;
                } else {
                    backoff_juggles[i] = MIN_LRU_MAINTAINER_SLEEP;
                }
                if (backoff_juggles[i] > MAX_LRU_MAINTAINER_SLEEP)
                    backoff_juggles[i] = MAX_LRU_MAINTAINER_SLEEP;
            } else if (backoff_juggles[i] > 0) {
                backoff_juggles[i] /= 2;
                if (backoff_juggles[i] < MIN_LRU_MAINTAINER_SLEEP) {
                    backoff_juggles[i] ...",71,,1633,4,,void
17942,BLOCK,-1,,"{
                // Sleep the thread just for the minimum amount (or not at all)
                if (next_juggles[i] < to_sleep)
                    to_sleep = next_juggles[i];
                continue;
            }",38,,1636,2,,void
17949,BLOCK,-1,,<empty>,21,,1639,2,,void
17965,BLOCK,-1,,"{
                if (backoff_juggles[i] != 0) {
                    backoff_juggles[i] += backoff_juggles[i] / 8;
                } else {
                    backoff_juggles[i] = MIN_LRU_MAINTAINER_SLEEP;
                }
                if (backoff_juggles[i] > MAX_LRU_MAINTAINER_SLEEP)
                    backoff_juggles[i] = MAX_LRU_MAINTAINER_SLEEP;
            }",33,,1644,2,,void
17972,BLOCK,-1,,"{
                    backoff_juggles[i] += backoff_juggles[i] / 8;
                }",46,,1645,2,,void
17983,BLOCK,-1,,"{
                    backoff_juggles[i] = MIN_LRU_MAINTAINER_SLEEP;
                }",24,,1647,1,,void
17989,BLOCK,1,,<empty>,,,,1,,void
17997,BLOCK,1,,<empty>,,,,1,,void
17999,BLOCK,-1,,<empty>,21,,1651,2,,void
18005,BLOCK,1,,<empty>,,,,1,,void
18008,BLOCK,-1,,<empty>,20,,1652,1,,void
18015,BLOCK,-1,,"{
                backoff_juggles[i] /= 2;
                if (backoff_juggles[i] < MIN_LRU_MAINTAINER_SLEEP) {
                    backoff_juggles[i] = 0;
                }
            }",48,,1652,2,,void
18027,BLOCK,1,,<empty>,,,,1,,void
18029,BLOCK,-1,,"{
                    backoff_juggles[i] = 0;
                }",68,,1654,2,,void
18048,BLOCK,-1,,<empty>,17,,1660,2,,void
18064,BLOCK,-1,,"{
            to_sleep = 1000;
        }",82,,1664,2,,void
18076,BLOCK,-1,,"{
            lru_maintainer_crawler_check(cdata, l);
            last_crawler_check = current_time;
        }",73,,1669,2,,void
18093,BLOCK,-1,,"{
            if (last_ratio != settings.slab_automove_ratio) {
                sam->free(am);
                am = sam->init(&settings);
                last_ratio = settings.slab_automove_ratio;
            }
            int src, dst;
            sam->run(am, &src, &dst);
            if (src != -1 && dst != -1) {
                slabs_reassign(src, dst);
                LOGGER_LOG(l, LOG_SYSEVENTS, LOGGER_SLAB_MOVE, NULL,
                        src, dst);
            }
            // dst == 0 means reclaim to global pool, be more aggressive
            if (dst != 0) {
                last_automove_check = current_time;
            } else if (dst == 0) {
                // also ensure we minimize the thread sleep
                to_sleep = 1000;
            }
        }",81,,1674,2,,void
18100,BLOCK,-1,,"{
                sam->free(am);
                am = sam->init(&settings);
                last_ratio = settings.slab_automove_ratio;
            }",61,,1675,2,,void
18140,BLOCK,-1,,"{
                slabs_reassign(src, dst);
                LOGGER_LOG(l, LOG_SYSEVENTS, LOGGER_SLAB_MOVE, NULL,
                        src, dst);
            }",41,,1682,2,,void
18148,BLOCK,1,,<empty>,,,,10,,void
18150,BLOCK,-1,,"LOGGER_LOG(l, LOG_SYSEVENTS, LOGGER_SLAB_MOVE, NULL,
                        src, dst)",17,,1684,1,,void
18159,BLOCK,-1,,<empty>,17,,1684,2,,void
18174,BLOCK,-1,,<empty>,17,,1684,2,,void
18186,BLOCK,-1,,"{
                last_automove_check = current_time;
            }",27,,1688,2,,void
18191,BLOCK,-1,,<empty>,20,,1690,1,,void
18196,BLOCK,-1,,"{
                // also ensure we minimize the thread sleep
                to_sleep = 1000;
            }",34,,1690,2,,void
18216,BLOCK,-1,,<empty>,9,,1701,2,,void
18226,BLOCK,-1,,"{
    int ret;
    pthread_mutex_lock(&lru_maintainer_lock);
    /* LRU thread is a sleep loop, will die on its own */
    do_run_lru_maintainer_thread = 0;
    pthread_mutex_unlock(&lru_maintainer_lock);
    if ((ret = pthread_join(lru_maintainer_tid, NULL)) != 0) {
        fprintf(stderr, ""Failed to stop LRU maintainer thread: %s\n"", strerror(ret));
        return -1;
    }
    settings.lru_maintainer_thread = false;
    return 0;
}",38,,1706,2,,void
18245,BLOCK,-1,,"{
        fprintf(stderr, ""Failed to stop LRU maintainer thread: %s\n"", strerror(ret));
        return -1;
    }",62,,1712,2,,void
18265,BLOCK,-1,,"{
    int ret;

    pthread_mutex_lock(&lru_maintainer_lock);
    do_run_lru_maintainer_thread = 1;
    settings.lru_maintainer_thread = true;
    if ((ret = pthread_create(&lru_maintainer_tid, NULL,
        lru_maintainer_thread, arg)) != 0) {
        fprintf(stderr, ""Can't create LRU maintainer thread: %s\n"",
            strerror(ret));
        pthread_mutex_unlock(&lru_maintainer_lock);
        return -1;
    }
    pthread_mutex_unlock(&lru_maintainer_lock);

    return 0;
}",44,,1720,2,,void
18289,BLOCK,-1,,"{
        fprintf(stderr, ""Can't create LRU maintainer thread: %s\n"",
            strerror(ret));
        pthread_mutex_unlock(&lru_maintainer_lock);
        return -1;
    }",44,,1727,2,,void
18310,BLOCK,-1,,"{
    pthread_mutex_lock(&lru_maintainer_lock);
}",33,,1739,2,,void
18318,BLOCK,-1,,"{
    pthread_mutex_unlock(&lru_maintainer_lock);
}",34,,1743,2,,void
18326,BLOCK,-1,,"{
    lru_maintainer_initialized = 1;
    return 0;
}",31,,1747,2,,void
18336,BLOCK,-1,,"{ /* item is the new tail */
    item **head, **tail;
    assert(it->it_flags == 1);
    assert(it->nbytes == 0);

    head = &heads[it->slabs_clsid];
    tail = &tails[it->slabs_clsid];
    //assert(*tail != 0);
    assert(it != *tail);
    assert((*head && *tail) || (*head == 0 && *tail == 0));
    it->prev = *tail;
    it->next = 0;
    if (it->prev) {
        assert(it->prev->next == 0);
        it->prev->next = it;
    }
    *tail = it;
    if (*head == 0) *head = it;
    return;
}",35,,1753,2,,void
18403,BLOCK,-1,,"{
        assert(it->prev->next == 0);
        it->prev->next = it;
    }",19,,1765,2,,void
18428,BLOCK,-1,,<empty>,21,,1770,2,,void
18438,BLOCK,-1,,"{
    item **head, **tail;
    head = &heads[it->slabs_clsid];
    tail = &tails[it->slabs_clsid];

    if (*head == it) {
        assert(it->prev == 0);
        *head = it->next;
    }
    if (*tail == it) {
        assert(it->next == 0);
        *tail = it->prev;
    }
    assert(it->next != it);
    assert(it->prev != it);

    if (it->next) it->next->prev = it->prev;
    if (it->prev) it->prev->next = it->next;
    return;
}",37,,1774,2,,void
18462,BLOCK,-1,,"{
        assert(it->prev == 0);
        *head = it->next;
    }",22,,1779,2,,void
18480,BLOCK,-1,,"{
        assert(it->next == 0);
        *tail = it->prev;
    }",22,,1783,2,,void
18509,BLOCK,-1,,<empty>,19,,1790,2,,void
18523,BLOCK,-1,,<empty>,19,,1791,2,,void
18538,BLOCK,-1,,"{
    item **head, **tail;
    assert(it->it_flags == 1);
    assert(it->nbytes == 0);
    head = &heads[it->slabs_clsid];
    tail = &tails[it->slabs_clsid];

    /* We've hit the head, pop off */
    if (it->prev == 0) {
        assert(*head == it);
        if (it->next) {
            *head = it->next;
            assert(it->next->prev == it);
            it->next->prev = 0;
        }
        return NULL; /* Done */
    }

    /* Swing ourselves in front of the next item */
    /* NB: If there is a prev, we can't be the head */
    assert(it->prev != it);
    if (it->prev) {
        if (*head == it->prev) {
            /* Prev was the head, now we're the head */
            *head = it;
        }
        if (*tail == it) {
            /* We are the tail, now they are the tail */
            *tail = it->prev;
        }
        assert(it->next != it);
        if (it->next) {
            assert(it->prev->next == it);
            it->prev->next = it->next;
            it->next->prev = ...",33,,1797,2,,void
18575,BLOCK,-1,,"{
        assert(*head == it);
        if (it->next) {
            *head = it->next;
            assert(it->next->prev == it);
            it->next->prev = 0;
        }
        return NULL; /* Done */
    }",24,,1805,2,,void
18585,BLOCK,-1,,"{
            *head = it->next;
            assert(it->next->prev == it);
            it->next->prev = 0;
        }",23,,1807,2,,void
18619,BLOCK,-1,,"{
        if (*head == it->prev) {
            /* Prev was the head, now we're the head */
            *head = it;
        }
        if (*tail == it) {
            /* We are the tail, now they are the tail */
            *tail = it->prev;
        }
        assert(it->next != it);
        if (it->next) {
            assert(it->prev->next == it);
            it->prev->next = it->next;
            it->next->prev = it->prev;
        } else {
            /* Tail. Move this above? */
            it->prev->next = 0;
        }
        /* prev->prev's next is it->prev */
        it->next = it->prev;
        it->prev = it->next->prev;
        it->next->prev = it;
        /* New it->prev now, if we're not at the head. */
        if (it->prev) {
            it->prev->next = it;
        }
    }",19,,1818,2,,void
18627,BLOCK,-1,,"{
            /* Prev was the head, now we're the head */
            *head = it;
        }",32,,1819,2,,void
18637,BLOCK,-1,,"{
            /* We are the tail, now they are the tail */
            *tail = it->prev;
        }",26,,1823,2,,void
18654,BLOCK,-1,,"{
            assert(it->prev->next == it);
            it->prev->next = it->next;
            it->next->prev = it->prev;
        }",23,,1828,2,,void
18682,BLOCK,-1,,"{
            /* Tail. Move this above? */
            it->prev->next = 0;
        }",16,,1832,1,,void
18717,BLOCK,-1,,"{
            it->prev->next = it;
        }",23,,1841,2,,void
18747,BLOCK,-1,,<empty>,1,,1,1,,ANY
18750,BLOCK,-1,,<empty>,,,,2,,<empty>
18755,BLOCK,-1,,<empty>,,,,2,,<empty>
18764,BLOCK,-1,,<empty>,,,,6,,<empty>
18770,BLOCK,-1,,<empty>,,,,3,,<empty>
18776,BLOCK,-1,,<empty>,,,,3,,<empty>
18781,BLOCK,-1,,<empty>,,,,2,,<empty>
18788,BLOCK,-1,,<empty>,,,,4,,<empty>
18794,BLOCK,-1,,<empty>,,,,3,,<empty>
18800,BLOCK,-1,,<empty>,,,,3,,<empty>
18806,BLOCK,-1,,<empty>,,,,3,,<empty>
18811,BLOCK,-1,,<empty>,,,,2,,<empty>
18816,BLOCK,-1,,<empty>,,,,2,,<empty>
18821,BLOCK,-1,,<empty>,,,,2,,<empty>
18828,BLOCK,-1,,<empty>,,,,4,,<empty>
18833,BLOCK,-1,,<empty>,,,,2,,<empty>
18838,BLOCK,-1,,<empty>,,,,2,,<empty>
18843,BLOCK,-1,,<empty>,,,,2,,<empty>
18848,BLOCK,-1,,<empty>,,,,2,,<empty>
18853,BLOCK,-1,,<empty>,,,,2,,<empty>
18858,BLOCK,-1,,<empty>,,,,2,,<empty>
18863,BLOCK,-1,,<empty>,,,,2,,<empty>
18876,BLOCK,-1,,<empty>,,,,7,,<empty>
18883,BLOCK,-1,,<empty>,,,,4,,<empty>
18889,BLOCK,-1,,<empty>,,,,3,,<empty>
18897,BLOCK,-1,,<empty>,,,,5,,<empty>
18903,BLOCK,-1,,<empty>,,,,3,,<empty>
18909,BLOCK,-1,,<empty>,,,,3,,<empty>
18914,BLOCK,-1,,<empty>,,,,2,,<empty>
18920,BLOCK,-1,,<empty>,,,,3,,<empty>
18926,BLOCK,-1,,<empty>,,,,3,,<empty>
18931,BLOCK,-1,,<empty>,,,,2,,<empty>
18936,BLOCK,-1,,<empty>,,,,2,,<empty>
18941,BLOCK,-1,,<empty>,,,,2,,<empty>
18951,BLOCK,-1,,<empty>,,,,2,,<empty>
18960,BLOCK,-1,,<empty>,,,,6,,<empty>
18969,BLOCK,-1,,<empty>,,,,6,,<empty>
18976,BLOCK,-1,,<empty>,,,,4,,<empty>
18981,BLOCK,-1,,<empty>,,,,2,,<empty>
18989,BLOCK,-1,,<empty>,,,,2,,<empty>
18994,BLOCK,-1,,<empty>,,,,2,,<empty>
18999,BLOCK,-1,,<empty>,,,,2,,<empty>
19004,BLOCK,-1,,<empty>,,,,2,,<empty>
19009,BLOCK,-1,,<empty>,,,,2,,<empty>
19014,BLOCK,-1,,<empty>,,,,2,,<empty>
19025,BLOCK,-1,,<empty>,1,,1,1,,ANY
19033,BLOCK,-1,,"{
    memcpy(p, &((uint16_t *)lut)[d], 2);
    return p + 2;
}",48,,73,3,,void
19052,BLOCK,-1,,"{
    memcpy(p, &in, 1);
    return p + 1;
}",50,,78,3,,void
19070,BLOCK,-1,,"{
    if (u < k*10) {
        *d = u / k;
        *p = out1('0'+*d, *p);
        --n;
    }
    return n;
}",77,,83,6,,void
19077,BLOCK,-1,,"{
        *d = u / k;
        *p = out1('0'+*d, *p);
        --n;
    }",19,,84,2,,void
19105,BLOCK,-1,,"{
    switch(n) {
    case 10: d  = u / 100000000; p = out2( d, p );
    case  9: u -= d * 100000000;
    case  8: d  = u /   1000000; p = out2( d, p );
    case  7: u -= d *   1000000;
    case  6: d  = u /     10000; p = out2( d, p );
    case  5: u -= d *     10000;
    case  4: d  = u /       100; p = out2( d, p );
    case  3: u -= d *       100;
    case  2: d  = u /         1; p = out2( d, p );
    case  1: ;
    }
    *p = '\0';
    return p;
}",61,,92,5,,void
19108,BLOCK,-1,,"{
    case 10: d  = u / 100000000; p = out2( d, p );
    case  9: u -= d * 100000000;
    case  8: d  = u /   1000000; p = out2( d, p );
    case  7: u -= d *   1000000;
    case  6: d  = u /     10000; p = out2( d, p );
    case  5: u -= d *     10000;
    case  4: d  = u /       100; p = out2( d, p );
    case  3: u -= d *       100;
    case  2: d  = u /         1; p = out2( d, p );
    case  1: ;
    }",15,,93,2,,void
19210,BLOCK,-1,,"{
    int d = 0,n;
         if (u >=100000000) n = digits(u, 100000000, &d, &p, 10);
    else if (u <       100) n = digits(u,         1, &d, &p,  2);
    else if (u <     10000) n = digits(u,       100, &d, &p,  4);
    else if (u <   1000000) n = digits(u,     10000, &d, &p,  6);
    else                    n = digits(u,   1000000, &d, &p,  8);
    return itoa( u, p, d, n );
}",37,,109,3,,void
19220,BLOCK,-1,,<empty>,29,,111,2,,void
19232,BLOCK,-1,,<empty>,10,,112,1,,void
19237,BLOCK,-1,,<empty>,29,,112,2,,void
19249,BLOCK,-1,,<empty>,10,,113,1,,void
19254,BLOCK,-1,,<empty>,29,,113,2,,void
19266,BLOCK,-1,,<empty>,10,,114,1,,void
19271,BLOCK,-1,,<empty>,29,,114,2,,void
19283,BLOCK,-1,,<empty>,29,,115,1,,void
19305,BLOCK,-1,,"{
    uint32_t u = i;
    if (i < 0) {
        *p++ = '-';
        u = -u;
    }
    return itoa_u32(u, p);
}",35,,119,3,,void
19314,BLOCK,-1,,"{
        *p++ = '-';
        u = -u;
    }",16,,121,2,,void
19333,BLOCK,-1,,"{
    int d;

    uint32_t lower = (uint32_t)u;
    if (lower == u) return itoa_u32(lower, p);

    uint64_t upper = u / 1000000000;
    p = itoa_u64(upper, p);
    lower = u - (upper * 1000000000);
    d = lower / 100000000;
    p = out1('0'+d,p);
    return itoa( lower, p, d, 9 );
}",37,,128,3,,void
19345,BLOCK,-1,,<empty>,21,,132,2,,void
19391,BLOCK,-1,,"{
    uint64_t u = i;
    if (i < 0) {
        *p++ = '-';
        u = -u;
    }
    return itoa_u64(u, p);
}",35,,142,3,,void
19400,BLOCK,-1,,"{
        *p++ = '-';
        u = -u;
    }",16,,144,2,,void
19422,BLOCK,-1,,<empty>,1,,1,1,,ANY
19426,BLOCK,-1,,<empty>,,,,3,,<empty>
19432,BLOCK,-1,,<empty>,,,,3,,<empty>
19438,BLOCK,-1,,<empty>,,,,3,,<empty>
19444,BLOCK,-1,,<empty>,,,,3,,<empty>
19455,BLOCK,-1,,<empty>,1,,1,1,,ANY
19460,BLOCK,-1,,<empty>,1,,1,1,,ANY
19464,BLOCK,-1,,<empty>,,,,3,,<empty>
19489,BLOCK,-1,,<empty>,1,,1,1,,ANY
19495,BLOCK,-1,,"{
#if defined(si_syscall)
    int syscall_no = si->si_syscall;
#else
    // If system has no support for si_syscal, the information may not be
    // precise.
    int syscall_no = si->si_value.sival_int;
#endif

    // Replace the characters in the kill message with the syscall number. We
    // can't safely printf (even write is not really valid, but we're crashing
    // anyway).

    kill_msg[39] = (syscall_no / 100) % 10 + '0';
    kill_msg[40] = (syscall_no / 10) % 10 + '0';
    kill_msg[41] = syscall_no % 10 + '0';
    if (write(2, kill_msg, strlen(kill_msg)) == -1) {
        // An error occurred, but we can't do anything about it here. This check
        // is mostly to avoid the ""ignoring return value of 'write'"" error on
        // distributions with broken gcc (no ""ignore via cast to void"" support).
    }

    // We can't use the nice exit() version because it causes at_exit handlers
    // to be looked up and run. We can't take any locks while handling the
    // signal, ...",76,,17,4,,void
19544,BLOCK,-1,,"{
        // An error occurred, but we can't do anything about it here. This check
        // is mostly to avoid the ""ignoring return value of 'write'"" error on
        // distributions with broken gcc (no ""ignore via cast to void"" support).
    }",53,,33,2,,void
19554,BLOCK,1,,<empty>,5,,46,1,,void
19558,BLOCK,2,,<empty>,5,,47,2,,void
19591,BLOCK,-1,,<empty>,1,,1,1,,ANY
19636,BLOCK,-1,,<empty>,,,,3,,<empty>
19644,BLOCK,-1,,"{
    int reqlen = d->reqlen;
    int total = vsnprintf((char *) e->data, reqlen, d->format, ap);
    if (total <= 0) {
        fprintf(stderr, ""LOGGER: Failed to vsnprintf a text entry: (total) %d\n"", total);
    }
    e->size = total + 1; // null byte
}",98,,54,5,,void
19669,BLOCK,-1,,"{
        fprintf(stderr, ""LOGGER: Failed to vsnprintf a text entry: (total) %d\n"", total);
    }",21,,57,2,,void
19688,BLOCK,-1,,"{
    item *it = (item *)entry;
    struct logentry_eviction *le = (struct logentry_eviction *) e->data;

    le->exptime = (it->exptime > 0) ? (long long int)(it->exptime - current_time) : (long long int) -1;
    le->latime = current_time - it->time;
    le->it_flags = it->it_flags;
    le->nkey = it->nkey;
    le->nbytes = it->nbytes;
    le->clsid = ITEM_clsid(it);
    memcpy(le->key, ITEM_key(it), it->nkey);
    e->size = sizeof(struct logentry_eviction) + le->nkey;
}",103,,63,5,,void
19760,BLOCK,1,,<empty>,,,,3,,void
19775,BLOCK,1,,<empty>,,,,4,,void
19812,BLOCK,-1,,"{
    int was_found = va_arg(ap, int);
    char *key = va_arg(ap, char *);
    int nkey = va_arg(ap, int);
    int nbytes = va_arg(ap, int);
    uint8_t clsid = va_arg(ap, int);
    int sfd = va_arg(ap, int);

    struct logentry_item_get *le = (struct logentry_item_get *) e->data;
    le->was_found = was_found;
    le->nkey = nkey;
    le->nbytes = nbytes;
    le->clsid = clsid;
    memcpy(le->key, key, nkey);
    le->sfd = sfd;
    e->size = sizeof(struct logentry_item_get) + nkey;
}",102,,96,5,,void
19875,BLOCK,-1,,"{
    enum store_item_type status = va_arg(ap, enum store_item_type);
    int comm = va_arg(ap, int);
    char *key = va_arg(ap, char *);
    int nkey = va_arg(ap, int);
    int nbytes = va_arg(ap, int);
    rel_time_t ttl = va_arg(ap, rel_time_t);
    uint8_t clsid = va_arg(ap, int);
    int sfd = va_arg(ap, int);

    struct logentry_item_store *le = (struct logentry_item_store *) e->data;
    le->status = status;
    le->cmd = comm;
    le->nkey = nkey;
    le->nbytes = nbytes;
    le->clsid = clsid;
    if (ttl != 0) {
        le->ttl = ttl - current_time;
    } else {
        le->ttl = 0;
    }
    memcpy(le->key, key, nkey);
    le->sfd = sfd;
    e->size = sizeof(struct logentry_item_store) + nkey;
}",104,,114,5,,void
19929,BLOCK,-1,,"{
        le->ttl = ttl - current_time;
    }",19,,130,2,,void
19938,BLOCK,-1,,"{
        le->ttl = 0;
    }",12,,132,1,,void
19970,BLOCK,-1,,"{
    struct sockaddr_in6 *addr = va_arg(ap, struct sockaddr_in6 *);
    socklen_t addrlen = va_arg(ap, socklen_t);
    enum network_transport transport = va_arg(ap, enum network_transport);
    enum close_reasons reason = va_arg(ap, enum close_reasons);
    int sfd = va_arg(ap, int);

    struct logentry_conn_event *le = (struct logentry_conn_event *) e->data;

    memcpy(&le->addr, addr, addrlen);
    le->sfd = sfd;
    le->transport = transport;
    le->reason = reason;
    e->size = sizeof(struct logentry_conn_event);
}",104,,140,5,,void
20027,BLOCK,-1,,"{
    memset(rip, 0, riplen);

    switch (addr->sin6_family) {
        case AF_INET:
            inet_ntop(AF_INET, &((struct sockaddr_in *) addr)->sin_addr,
                    rip, riplen - 1);
            *rport = ntohs(((struct sockaddr_in *) addr)->sin_port);
            break;
        case AF_INET6:
            inet_ntop(AF_INET6, &((struct sockaddr_in6 *) addr)->sin6_addr,
                    rip, riplen - 1);
            *rport = ntohs(((struct sockaddr_in6 *) addr)->sin6_port);
            break;
#ifndef DISABLE_UNIX_SOCKET
        // Connections on Unix socket transports have c->request_addr zeroed out.
        case AF_UNSPEC:
        case AF_UNIX:
            strncpy(rip, ""unix"", strlen(""unix"") + 1);
            *rport = 0;
            break;
#endif // #ifndef DISABLE_UNIX_SOCKET
    }

    return 0;
}",47,,161,5,,void
20036,BLOCK,-1,,"{
        case AF_INET:
            inet_ntop(AF_INET, &((struct sockaddr_in *) addr)->sin_addr,
                    rip, riplen - 1);
            *rport = ntohs(((struct sockaddr_in *) addr)->sin_port);
            break;
        case AF_INET6:
            inet_ntop(AF_INET6, &((struct sockaddr_in6 *) addr)->sin6_addr,
                    rip, riplen - 1);
            *rport = ntohs(((struct sockaddr_in6 *) addr)->sin6_port);
            break;
#ifndef DISABLE_UNIX_SOCKET
        // Connections on Unix socket transports have c->request_addr zeroed out.
        case AF_UNSPEC:
        case AF_UNIX:
            strncpy(rip, ""unix"", strlen(""unix"") + 1);
            *rport = 0;
            break;
#endif // #ifndef DISABLE_UNIX_SOCKET
    }",32,,164,2,,void
20108,BLOCK,-1,,"{
    return snprintf(scratch, LOGGER_PARSE_SCRATCH, ""ts=%d.%d gid=%llu %s\n"",
            (int)e->tv.tv_sec, (int)e->tv.tv_usec,
            (unsigned long long) e->gid, (char *) e->data);
}",59,,195,3,,void
20113,BLOCK,1,,<empty>,,,,1,,void
20145,BLOCK,-1,,"{
    int total;
    const char *cmd = ""na"";
    char keybuf[KEY_MAX_URI_ENCODED_LENGTH];
    struct logentry_item_store *le = (struct logentry_item_store *) e->data;
    const char * const status_map[] = {
        ""not_stored"", ""stored"", ""exists"", ""not_found"", ""too_large"", ""no_memory"" };
    const char * const cmd_map[] = {
        ""null"", ""add"", ""set"", ""replace"", ""append"", ""prepend"", ""cas"" };

    if (le->cmd <= 6)
        cmd = cmd_map[le->cmd];

    uriencode(le->key, keybuf, le->nkey, KEY_MAX_URI_ENCODED_LENGTH);
    total = snprintf(scratch, LOGGER_PARSE_SCRATCH,
            ""ts=%d.%d gid=%llu type=item_store key=%s status=%s cmd=%s ttl=%u clsid=%u cfd=%d size=%d\n"",
            (int)e->tv.tv_sec, (int)e->tv.tv_usec, (unsigned long long) e->gid,
            keybuf, status_map[le->status], cmd, le->ttl, le->clsid, le->sfd,
            le->nbytes > 0 ? le->nbytes - 2 : 0); // CLRF
    return total;
}",58,,201,3,,void
20187,BLOCK,-1,,<empty>,9,,212,2,,void
20204,BLOCK,1,,<empty>,,,,1,,void
20215,BLOCK,1,,<empty>,,,,1,,void
20272,BLOCK,-1,,"{
    int total;
    struct logentry_item_get *le = (struct logentry_item_get *) e->data;
    char keybuf[KEY_MAX_URI_ENCODED_LENGTH];
    const char * const was_found_map[] = {
        ""not_found"", ""found"", ""flushed"", ""expired"" };

    uriencode(le->key, keybuf, le->nkey, KEY_MAX_URI_ENCODED_LENGTH);
    total = snprintf(scratch, LOGGER_PARSE_SCRATCH,
            ""ts=%d.%d gid=%llu type=item_get key=%s status=%s clsid=%u cfd=%d size=%d\n"",
            (int)e->tv.tv_sec, (int)e->tv.tv_usec, (unsigned long long) e->gid,
            keybuf, was_found_map[le->was_found], le->clsid, le->sfd,
            le->nbytes > 0 ? le->nbytes - 2 : 0); // CLRF
    return total;
}",58,,223,3,,void
20300,BLOCK,1,,<empty>,,,,1,,void
20311,BLOCK,1,,<empty>,,,,1,,void
20364,BLOCK,-1,,"{
    int total;
    char keybuf[KEY_MAX_URI_ENCODED_LENGTH];
    struct logentry_eviction *le = (struct logentry_eviction *) e->data;
    uriencode(le->key, keybuf, le->nkey, KEY_MAX_URI_ENCODED_LENGTH);
    total = snprintf(scratch, LOGGER_PARSE_SCRATCH,
            ""ts=%d.%d gid=%llu type=eviction key=%s fetch=%s ttl=%lld la=%d clsid=%u size=%d\n"",
            (int)e->tv.tv_sec, (int)e->tv.tv_usec, (unsigned long long) e->gid,
            keybuf, (le->it_flags & ITEM_FETCHED) ? ""yes"" : ""no"",
            (long long int)le->exptime, le->latime, le->clsid,
            le->nbytes > 0 ? le->nbytes - 2 : 0); // CLRF

    return total;
}",57,,239,3,,void
20384,BLOCK,1,,<empty>,,,,1,,void
20395,BLOCK,1,,<empty>,,,,1,,void
20424,BLOCK,1,,<empty>,,,,1,,void
20458,BLOCK,-1,,"{
    int total;
    unsigned short rport;
    char rip[64];
    struct logentry_conn_event *le = (struct logentry_conn_event *) e->data;
    const char * const transport_map[] = { ""local"", ""tcp"", ""udp"" };

    _logger_util_addr_endpoint(&le->addr, rip, sizeof(rip), &rport);

    total = snprintf(scratch, LOGGER_PARSE_SCRATCH,
            ""ts=%d.%d gid=%llu type=conn_new rip=%s rport=%hu transport=%s cfd=%d\n"",
            (int) e->tv.tv_sec, (int) e->tv.tv_usec, (unsigned long long) e->gid,
            rip, rport, transport_map[le->transport], le->sfd);

    return total;
}",58,,270,3,,void
20492,BLOCK,1,,<empty>,,,,1,,void
20531,BLOCK,-1,,"{
    int total;
    unsigned short rport;
    char rip[64];
    struct logentry_conn_event *le = (struct logentry_conn_event *) e->data;
    const char * const transport_map[] = { ""local"", ""tcp"", ""udp"" };
    const char * const reason_map[] = { ""error"", ""normal"", ""idle_timeout"", ""shutdown"" };

    _logger_util_addr_endpoint(&le->addr, rip, sizeof(rip), &rport);

    total = snprintf(scratch, LOGGER_PARSE_SCRATCH,
            ""ts=%d.%d gid=%llu type=conn_close rip=%s rport=%hu transport=%s reason=%s cfd=%d\n"",
            (int) e->tv.tv_sec, (int) e->tv.tv_usec, (unsigned long long) e->gid,
            rip, rport, transport_map[le->transport],
            reason_map[le->reason], le->sfd);

    return total;
}",58,,287,3,,void
20573,BLOCK,1,,<empty>,,,,1,,void
20618,BLOCK,1,,<empty>,5,,373,1,,void
20624,BLOCK,1,,<empty>,,,,1,,void
20631,BLOCK,2,,<empty>,5,,374,2,,void
20637,BLOCK,1,,<empty>,,,,1,,void
20644,BLOCK,3,,<empty>,5,,375,3,,void
20650,BLOCK,1,,<empty>,,,,1,,void
20657,BLOCK,4,,<empty>,5,,376,4,,void
20663,BLOCK,1,,<empty>,,,,1,,void
20670,BLOCK,5,,<empty>,5,,377,5,,void
20676,BLOCK,1,,<empty>,,,,1,,void
20683,BLOCK,6,,<empty>,5,,380,6,,void
20689,BLOCK,1,,<empty>,,,,1,,void
20696,BLOCK,7,,<empty>,5,,383,7,,void
20702,BLOCK,1,,<empty>,,,,1,,void
20709,BLOCK,8,,<empty>,5,,384,8,,void
20715,BLOCK,1,,<empty>,,,,1,,void
20728,BLOCK,-1,,"{
#ifdef HAVE_GCC_64ATOMICS
    return __sync_add_and_fetch(&logger_gid, 1);
#elif defined(__sun)
    return atomic_inc_64_nv(&logger_gid);
#else
    mutex_lock(&logger_atomics_mutex);
    uint64_t res = ++logger_gid;
    mutex_unlock(&logger_atomics_mutex);
    return res;
#endif
}",31,,431,2,,void
20732,BLOCK,1,,<empty>,,,,3,,void
20744,BLOCK,1,,<empty>,,,,3,,void
20754,BLOCK,-1,,"{
#ifdef HAVE_GCC_64ATOMICS
    __sync_add_and_fetch(&logger_gid, gid);
#elif defined(__sun)
    atomic_add_64(&logger_gid);
#else
    mutex_lock(&logger_atomics_mutex);
    logger_gid = gid;
    mutex_unlock(&logger_atomics_mutex);
#endif
}",35,,444,2,,void
20758,BLOCK,1,,<empty>,,,,3,,void
20768,BLOCK,1,,<empty>,,,,3,,void
20776,BLOCK,-1,,"{
    pthread_mutex_lock(&logger_stack_lock);
    assert(l != logger_stack_head);

    l->prev = 0;
    l->next = logger_stack_head;
    if (l->next) l->next->prev = l;
    logger_stack_head = l;
    if (logger_stack_tail == 0) logger_stack_tail = l;
    logger_count++;
    pthread_mutex_unlock(&logger_stack_lock);
    return;
}",38,,460,2,,void
20798,BLOCK,-1,,<empty>,18,,466,2,,void
20813,BLOCK,-1,,<empty>,33,,468,2,,void
20827,BLOCK,-1,,"{
    logger *l = NULL;
    int x = 0;
    uint16_t f = 0; /* logger eflags */

    for (x = 0; x < WATCHER_LIMIT; x++) {
        logger_watcher *w = watchers[x];
        if (w == NULL)
            continue;

        f |= w->eflags;
    }
    for (l = logger_stack_head; l != NULL; l=l->next) {
        pthread_mutex_lock(&l->mutex);
        l->eflags = f;
        pthread_mutex_unlock(&l->mutex);
    }
    return;
}",36,,498,2,,void
20841,BLOCK,-1,,<empty>,5,,503,1,,void
20848,BLOCK,1,,<empty>,,,,1,,void
20852,BLOCK,4,,"{
        logger_watcher *w = watchers[x];
        if (w == NULL)
            continue;

        f |= w->eflags;
    }",41,,503,4,,void
20863,BLOCK,-1,,<empty>,13,,506,2,,void
20871,BLOCK,-1,,<empty>,5,,510,1,,void
20883,BLOCK,4,,"{
        pthread_mutex_lock(&l->mutex);
        l->eflags = f;
        pthread_mutex_unlock(&l->mutex);
    }",55,,510,4,,void
20907,BLOCK,-1,,"{
    int total = 0;
    const entry_details *d = &default_entries[e->event];
    assert(d->parse_cb != NULL);
    total = d->parse_cb(e, scratch);

    if (total >= LOGGER_PARSE_SCRATCH || total <= 0) {
        L_DEBUG(""LOGGER: Failed to flatten log entry!\n"");
        return LOGGER_PARSE_ENTRY_FAILED;
    } else {
        *scratch_len = total;
    }

    return LOGGER_PARSE_ENTRY_OK;
}",42,,520,5,,void
20940,BLOCK,1,,<empty>,,,,1,,void
20945,BLOCK,-1,,"{
        L_DEBUG(""LOGGER: Failed to flatten log entry!\n"");
        return LOGGER_PARSE_ENTRY_FAILED;
    }",54,,526,2,,void
20949,BLOCK,-1,,"{
        *scratch_len = total;
    }",12,,529,1,,void
20963,BLOCK,-1,,"{
    int x, total;
    /* Write the line into available watchers with matching flags */
    for (x = 0; x < WATCHER_LIMIT; x++) {
        logger_watcher *w = watchers[x];
        char *skip_scr = NULL;
        if (w == NULL || (e->eflags & w->eflags) == 0 || (e->gid < w->min_gid))
            continue;

         /* Avoid poll()'ing constantly when buffer is full by resetting a
         * flag periodically.
         */
        while (!w->failed_flush &&
                (skip_scr = (char *) bipbuf_request(w->buf, scratch_len + 128)) == NULL) {
            if (logger_thread_poll_watchers(0, x) <= 0) {
                L_DEBUG(""LOGGER: Watcher had no free space for line of size (%d)\n"", scratch_len + 128);
                w->failed_flush = true;
            }
        }

        if (w->failed_flush) {
            L_DEBUG(""LOGGER: Fast skipped for watcher [%d] due to failed_flush\n"", w->sfd);
            w->skipped++;
            ls->watcher_skipped++;
            continue;
        }

   ...",41,,538,5,,void
20967,BLOCK,-1,,<empty>,5,,541,1,,void
20974,BLOCK,1,,<empty>,,,,1,,void
20978,BLOCK,4,,"{
        logger_watcher *w = watchers[x];
        char *skip_scr = NULL;
        if (w == NULL || (e->eflags & w->eflags) == 0 || (e->gid < w->min_gid))
            continue;

         /* Avoid poll()'ing constantly when buffer is full by resetting a
         * flag periodically.
         */
        while (!w->failed_flush &&
                (skip_scr = (char *) bipbuf_request(w->buf, scratch_len + 128)) == NULL) {
            if (logger_thread_poll_watchers(0, x) <= 0) {
                L_DEBUG(""LOGGER: Watcher had no free space for line of size (%d)\n"", scratch_len + 128);
                w->failed_flush = true;
            }
        }

        if (w->failed_flush) {
            L_DEBUG(""LOGGER: Fast skipped for watcher [%d] due to failed_flush\n"", w->sfd);
            w->skipped++;
            ls->watcher_skipped++;
            continue;
        }

        if (w->skipped > 0) {
            total = snprintf(skip_scr, 128, ""skipped=%llu\n"", (unsigned long long) w->skipped);
      ...",41,,541,4,,void
21011,BLOCK,-1,,<empty>,13,,545,2,,void
21032,BLOCK,-1,,"{
            if (logger_thread_poll_watchers(0, x) <= 0) {
                L_DEBUG(""LOGGER: Watcher had no free space for line of size (%d)\n"", scratch_len + 128);
                w->failed_flush = true;
            }
        }",90,,551,2,,void
21039,BLOCK,-1,,"{
                L_DEBUG(""LOGGER: Watcher had no free space for line of size (%d)\n"", scratch_len + 128);
                w->failed_flush = true;
            }",57,,552,2,,void
21049,BLOCK,-1,,"{
            L_DEBUG(""LOGGER: Fast skipped for watcher [%d] due to failed_flush\n"", w->sfd);
            w->skipped++;
            ls->watcher_skipped++;
            continue;
        }",30,,558,2,,void
21065,BLOCK,-1,,"{
            total = snprintf(skip_scr, 128, ""skipped=%llu\n"", (unsigned long long) w->skipped);
            if (total >= 128 || total <= 0) {
                L_DEBUG(""LOGGER: Failed to flatten skipped message into watcher [%d]\n"", w->sfd);
                w->skipped++;
                ls->watcher_skipped++;
                continue;
            }
            bipbuf_push(w->buf, total);
            w->skipped = 0;
        }",29,,565,2,,void
21085,BLOCK,-1,,"{
                L_DEBUG(""LOGGER: Failed to flatten skipped message into watcher [%d]\n"", w->sfd);
                w->skipped++;
                ls->watcher_skipped++;
                continue;
            }",45,,567,2,,void
21121,BLOCK,-1,,"{
    L_DEBUG(""LOGGER: Closing dead watcher\n"");
    watchers[w->id] = NULL;
    sidethread_conn_close(w->c);
    watcher_count--;
    bipbuf_free(w->buf);
    free(w);
    logger_set_flags();
}",60,,587,2,,void
21147,BLOCK,-1,,"{
    unsigned int size;
    unsigned int pos = 0;
    unsigned char *data;
    char scratch[LOGGER_PARSE_SCRATCH];
    logentry *e;
    pthread_mutex_lock(&l->mutex);
    data = bipbuf_peek_all(l->buf, &size);
    pthread_mutex_unlock(&l->mutex);

    if (data == NULL) {
        return 0;
    }
    L_DEBUG(""LOGGER: Got %d bytes from bipbuffer\n"", size);

    /* parse buffer */
    while (pos < size && watcher_count > 0) {
        enum logger_parse_entry_ret ret;
        int scratch_len = 0;
        e = (logentry *) (data + pos);
        ret = logger_thread_parse_entry(e, ls, scratch, &scratch_len);
        if (ret != LOGGER_PARSE_ENTRY_OK) {
            /* TODO: stats counter */
            fprintf(stderr, ""LOGGER: Failed to parse log entry\n"");
        } else {
            logger_thread_write_entry(e, ls, scratch, scratch_len);
        }
        pos += sizeof(logentry) + e->size + e->pad;
    }
    assert(pos <= size);

    pthread_mutex_lock(&l->mutex);
    data = bipbuf_poll(l->...",67,,600,3,,void
21178,BLOCK,-1,,"{
        return 0;
    }",23,,610,2,,void
21189,BLOCK,-1,,"{
        enum logger_parse_entry_ret ret;
        int scratch_len = 0;
        e = (logentry *) (data + pos);
        ret = logger_thread_parse_entry(e, ls, scratch, &scratch_len);
        if (ret != LOGGER_PARSE_ENTRY_OK) {
            /* TODO: stats counter */
            fprintf(stderr, ""LOGGER: Failed to parse log entry\n"");
        } else {
            logger_thread_write_entry(e, ls, scratch, scratch_len);
        }
        pos += sizeof(logentry) + e->size + e->pad;
    }",45,,616,2,,void
21214,BLOCK,-1,,"{
            /* TODO: stats counter */
            fprintf(stderr, ""LOGGER: Failed to parse log entry\n"");
        }",43,,621,2,,void
21219,BLOCK,-1,,"{
            logger_thread_write_entry(e, ls, scratch, scratch_len);
        }",16,,624,1,,void
21286,BLOCK,-1,,"{
        fprintf(stderr, ""LOGGER: unexpectedly couldn't advance buf pointer\n"");
        assert(0);
    }",23,,638,2,,void
21299,BLOCK,-1,,"{
    int x;
    int nfd = 0;
    unsigned char *data;
    unsigned int data_size = 0;
    int flushed = 0;

    for (x = 0; x < WATCHER_LIMIT; x++) {
        logger_watcher *w = watchers[x];
        if (w == NULL || (watcher != WATCHER_ALL && x != watcher))
            continue;

        data = bipbuf_peek_all(w->buf, &data_size);
        if (data != NULL) {
            watchers_pollfds[nfd].fd = w->sfd;
            watchers_pollfds[nfd].events = POLLOUT;
            nfd++;
        } else if (force_poll) {
            watchers_pollfds[nfd].fd = w->sfd;
            watchers_pollfds[nfd].events = POLLIN;
            nfd++;
        }
        /* This gets set after a call to poll, and should be used to gate on
         * calling poll again.
         */
        w->failed_flush = false;
    }

    if (nfd == 0)
        return 0;

    //L_DEBUG(""LOGGER: calling poll() [data_size: %d]\n"", data_size);
    int ret = poll(watchers_pollfds, nfd, 0);

    if (ret < 0) {
        perror(""somethin...",69,,656,3,,void
21315,BLOCK,-1,,<empty>,5,,663,1,,void
21322,BLOCK,1,,<empty>,,,,1,,void
21326,BLOCK,4,,"{
        logger_watcher *w = watchers[x];
        if (w == NULL || (watcher != WATCHER_ALL && x != watcher))
            continue;

        data = bipbuf_peek_all(w->buf, &data_size);
        if (data != NULL) {
            watchers_pollfds[nfd].fd = w->sfd;
            watchers_pollfds[nfd].events = POLLOUT;
            nfd++;
        } else if (force_poll) {
            watchers_pollfds[nfd].fd = w->sfd;
            watchers_pollfds[nfd].events = POLLIN;
            nfd++;
        }
        /* This gets set after a call to poll, and should be used to gate on
         * calling poll again.
         */
        w->failed_flush = false;
    }",41,,663,4,,void
21342,BLOCK,1,,<empty>,,,,1,,void
21348,BLOCK,-1,,<empty>,13,,666,2,,void
21362,BLOCK,-1,,"{
            watchers_pollfds[nfd].fd = w->sfd;
            watchers_pollfds[nfd].events = POLLOUT;
            nfd++;
        }",27,,669,2,,void
21382,BLOCK,-1,,<empty>,16,,673,1,,void
21385,BLOCK,-1,,"{
            watchers_pollfds[nfd].fd = w->sfd;
            watchers_pollfds[nfd].events = POLLIN;
            nfd++;
        }",32,,673,2,,void
21413,BLOCK,-1,,<empty>,9,,685,2,,void
21427,BLOCK,-1,,"{
        perror(""something failed with logger thread watcher fd polling"");
        return -1;
    }",18,,690,2,,void
21437,BLOCK,-1,,<empty>,5,,696,1,,void
21444,BLOCK,1,,<empty>,,,,1,,void
21448,BLOCK,4,,"{
        logger_watcher *w = watchers[x];
        if (w == NULL || (watcher != WATCHER_ALL && x != watcher))
            continue;

        data_size = 0;
        /* Early detection of a disconnect. Otherwise we have to wait until
         * the next write
         */
        if (watchers_pollfds[nfd].revents & POLLIN) {
            char buf[1];
            int res = ((conn*)w->c)->read(w->c, buf, 1);
            if (res == 0 || (res == -1 && (errno != EAGAIN && errno != EWOULDBLOCK))) {
                L_DEBUG(""LOGGER: watcher closed remotely\n"");
                logger_thread_close_watcher(w);
                nfd++;
                continue;
            }
        }
        if ((data = bipbuf_peek_all(w->buf, &data_size)) != NULL) {
            if (watchers_pollfds[nfd].revents & (POLLHUP|POLLERR)) {
                L_DEBUG(""LOGGER: watcher closed during poll() call\n"");
                logger_thread_close_watcher(w);
            } else if (watchers_pollfds[nfd].revents & POLLOUT)...",41,,696,4,,void
21464,BLOCK,1,,<empty>,,,,1,,void
21470,BLOCK,-1,,<empty>,13,,699,2,,void
21483,BLOCK,-1,,"{
            char buf[1];
            int res = ((conn*)w->c)->read(w->c, buf, 1);
            if (res == 0 || (res == -1 && (errno != EAGAIN && errno != EWOULDBLOCK))) {
                L_DEBUG(""LOGGER: watcher closed remotely\n"");
                logger_thread_close_watcher(w);
                nfd++;
                continue;
            }
        }",53,,705,2,,void
21518,BLOCK,-1,,"{
                L_DEBUG(""LOGGER: watcher closed remotely\n"");
                logger_thread_close_watcher(w);
                nfd++;
                continue;
            }",87,,708,2,,void
21535,BLOCK,-1,,"{
            if (watchers_pollfds[nfd].revents & (POLLHUP|POLLERR)) {
                L_DEBUG(""LOGGER: watcher closed during poll() call\n"");
                logger_thread_close_watcher(w);
            } else if (watchers_pollfds[nfd].revents & POLLOUT) {
                int total = 0;

                /* We can write a bit. */
                switch (w->t) {
                    case LOGGER_WATCHER_STDERR:
                        total = fwrite(data, 1, data_size, stderr);
                        break;
                    case LOGGER_WATCHER_CLIENT:
                        total = ((conn*)w->c)->write(w->c, data, data_size);
                        break;
                }

                L_DEBUG(""LOGGER: poll() wrote %d to %d (data_size: %d) (bipbuf_used: %d)\n"", total, w->sfd,
                        data_size, bipbuf_used(w->buf));
                if (total == -1) {
                    if (errno != EAGAIN && errno != EWOULDBLOCK) {
                        logger_thread_close_w...",67,,715,2,,void
21546,BLOCK,-1,,"{
                L_DEBUG(""LOGGER: watcher closed during poll() call\n"");
                logger_thread_close_watcher(w);
            }",68,,716,2,,void
21550,BLOCK,-1,,<empty>,20,,719,1,,void
21559,BLOCK,-1,,"{
                int total = 0;

                /* We can write a bit. */
                switch (w->t) {
                    case LOGGER_WATCHER_STDERR:
                        total = fwrite(data, 1, data_size, stderr);
                        break;
                    case LOGGER_WATCHER_CLIENT:
                        total = ((conn*)w->c)->write(w->c, data, data_size);
                        break;
                }

                L_DEBUG(""LOGGER: poll() wrote %d to %d (data_size: %d) (bipbuf_used: %d)\n"", total, w->sfd,
                        data_size, bipbuf_used(w->buf));
                if (total == -1) {
                    if (errno != EAGAIN && errno != EWOULDBLOCK) {
                        logger_thread_close_watcher(w);
                    }
                    L_DEBUG(""LOGGER: watcher hit EAGAIN\n"");
                } else if (total == 0) {
                    logger_thread_close_watcher(w);
                } else {
                    bipbuf_poll(w->buf, tot...",65,,719,2,,void
21568,BLOCK,-1,,"{
                    case LOGGER_WATCHER_STDERR:
                        total = fwrite(data, 1, data_size, stderr);
                        break;
                    case LOGGER_WATCHER_CLIENT:
                        total = ((conn*)w->c)->write(w->c, data, data_size);
                        break;
                }",31,,723,2,,void
21602,BLOCK,-1,,"{
                    if (errno != EAGAIN && errno != EWOULDBLOCK) {
                        logger_thread_close_watcher(w);
                    }
                    L_DEBUG(""LOGGER: watcher hit EAGAIN\n"");
                }",34,,734,2,,void
21611,BLOCK,-1,,"{
                        logger_thread_close_watcher(w);
                    }",66,,735,2,,void
21615,BLOCK,-1,,<empty>,24,,739,1,,void
21620,BLOCK,-1,,"{
                    logger_thread_close_watcher(w);
                }",40,,739,2,,void
21624,BLOCK,-1,,"{
                    bipbuf_poll(w->buf, total);
                    flushed += total;
                }",24,,741,1,,void
21641,BLOCK,-1,,"{
    STATS_LOCK();
    stats.log_worker_dropped  += ls->worker_dropped;
    stats.log_worker_written  += ls->worker_written;
    stats.log_watcher_skipped += ls->watcher_skipped;
    stats.log_watcher_sent    += ls->watcher_sent;
    stats_state.log_watchers   = ls->watcher_count;
    STATS_UNLOCK();
}",64,,752,2,,void
21683,BLOCK,-1,,"{
    useconds_t to_sleep = MIN_LOGGER_SLEEP;
    L_DEBUG(""LOGGER: Starting logger thread\n"");
    // TODO: If we ever have item references in the logger code, will need to
    // ensure everything is dequeued before stopping the thread.
    while (do_run_logger_thread) {
        int found_logs = 0;
        logger *l;
        struct logger_stats ls;
        memset(&ls, 0, sizeof(struct logger_stats));

        /* only sleep if we're *above* the minimum */
        if (to_sleep > MIN_LOGGER_SLEEP)
            usleep(to_sleep);

        /* Call function to iterate each logger. */
        pthread_mutex_lock(&logger_stack_lock);
        if (watcher_count == 0) {
            // Not bothering to loop on the condition here since it's fine to
            // walk through with zero watchers.
            pthread_cond_wait(&logger_stack_cond, &logger_stack_lock);
        }
        for (l = logger_stack_head; l != NULL; l=l->next) {
            /* lock logger, call function to manipulate it */
  ...",39,,766,2,,void
21688,BLOCK,1,,<empty>,,,,1,,void
21692,BLOCK,-1,,"{
        int found_logs = 0;
        logger *l;
        struct logger_stats ls;
        memset(&ls, 0, sizeof(struct logger_stats));

        /* only sleep if we're *above* the minimum */
        if (to_sleep > MIN_LOGGER_SLEEP)
            usleep(to_sleep);

        /* Call function to iterate each logger. */
        pthread_mutex_lock(&logger_stack_lock);
        if (watcher_count == 0) {
            // Not bothering to loop on the condition here since it's fine to
            // walk through with zero watchers.
            pthread_cond_wait(&logger_stack_cond, &logger_stack_lock);
        }
        for (l = logger_stack_head; l != NULL; l=l->next) {
            /* lock logger, call function to manipulate it */
            found_logs += logger_thread_read(l, &ls);
        }

        logger_thread_poll_watchers(1, WATCHER_ALL);

        /* capture the current count within mutual exclusion of the lock */
        ls.watcher_count = watcher_count;

        pthread_mutex_unlock(&logge...",34,,771,2,,void
21709,BLOCK,1,,<empty>,,,,1,,void
21711,BLOCK,-1,,<empty>,13,,779,2,,void
21721,BLOCK,-1,,"{
            // Not bothering to loop on the condition here since it's fine to
            // walk through with zero watchers.
            pthread_cond_wait(&logger_stack_cond, &logger_stack_lock);
        }",33,,783,2,,void
21728,BLOCK,-1,,<empty>,9,,788,1,,void
21740,BLOCK,4,,"{
            /* lock logger, call function to manipulate it */
            found_logs += logger_thread_read(l, &ls);
        }",59,,788,4,,void
21750,BLOCK,1,,<empty>,,,,1,,void
21764,BLOCK,-1,,"{
            if (to_sleep < MAX_LOGGER_SLEEP)
                to_sleep += to_sleep / 8;
            if (to_sleep > MAX_LOGGER_SLEEP)
                to_sleep = MAX_LOGGER_SLEEP;
        }",26,,801,2,,void
21769,BLOCK,1,,<empty>,,,,1,,void
21771,BLOCK,-1,,<empty>,17,,803,2,,void
21781,BLOCK,1,,<empty>,,,,1,,void
21783,BLOCK,-1,,<empty>,17,,805,2,,void
21787,BLOCK,1,,<empty>,,,,1,,void
21790,BLOCK,-1,,"{
            to_sleep /= 2;
            if (to_sleep < MIN_LOGGER_SLEEP)
                to_sleep = MIN_LOGGER_SLEEP;
        }",16,,806,1,,void
21798,BLOCK,1,,<empty>,,,,1,,void
21800,BLOCK,-1,,<empty>,17,,809,2,,void
21804,BLOCK,1,,<empty>,,,,1,,void
21815,BLOCK,-1,,"{
    int ret;
    do_run_logger_thread = 1;
    if ((ret = pthread_create(&logger_tid, NULL,
                              logger_thread, NULL)) != 0) {
        fprintf(stderr, ""Can't start logger thread: %s\n"", strerror(ret));
        return -1;
    }
    return 0;
}",38,,817,2,,void
21831,BLOCK,-1,,"{
        fprintf(stderr, ""Can't start logger thread: %s\n"", strerror(ret));
        return -1;
    }",59,,821,2,,void
21846,BLOCK,-1,,"{
    // Guarantees that the logger thread is waiting on 'logger_stack_cond'
    // before we signal it.
    pthread_mutex_lock(&logger_stack_lock);
    do_run_logger_thread = 0;
    pthread_cond_signal(&logger_stack_cond);
    pthread_mutex_unlock(&logger_stack_lock);
    pthread_join(logger_tid, NULL);
    return 0;
}",37,,828,2,,void
21868,BLOCK,-1,,"{
    /* TODO: auto destructor when threads exit */
    /* TODO: error handling */

    /* init stack for iterating loggers */
    logger_stack_head = 0;
    logger_stack_tail = 0;
    pthread_key_create(&logger_key, NULL);

    if (start_logger_thread() != 0) {
        abort();
    }

    /* This is what adding a STDERR watcher looks like. should replace old
     * ""verbose"" settings. */
    //logger_add_watcher(NULL, 0);
    return;
}",24,,844,2,,void
21883,BLOCK,-1,,"{
        abort();
    }",37,,853,2,,void
21890,BLOCK,-1,,"{
    stop_logger_thread();
}",24,,863,2,,void
21896,BLOCK,-1,,"{
    L_DEBUG(""LOGGER: Creating and linking new logger instance\n"");
    logger *l = calloc(1, sizeof(logger));
    if (l == NULL) {
        return NULL;
    }

    l->buf = bipbuf_new(settings.logger_buf_size);
    if (l->buf == NULL) {
        free(l);
        return NULL;
    }

    l->entry_map = default_entries;

    pthread_mutex_init(&l->mutex, NULL);
    pthread_setspecific(logger_key, l);

    /* add to list of loggers */
    logger_link_q(l);
    return l;
}",29,,870,2,,void
21908,BLOCK,-1,,"{
        return NULL;
    }",20,,873,2,,void
21925,BLOCK,-1,,"{
        free(l);
        return NULL;
    }",25,,878,2,,void
21954,BLOCK,-1,,"{
    bipbuf_t *buf = l->buf;
    bool nospace = false;
    va_list ap;
    logentry *e;

    const entry_details *d = &l->entry_map[event];
    int reqlen = d->reqlen;

    pthread_mutex_lock(&l->mutex);
    /* Request a maximum length of data to write to */
    e = (logentry *) bipbuf_request(buf, (sizeof(logentry) + reqlen));
    if (e == NULL) {
        pthread_mutex_unlock(&l->mutex);
        l->dropped++;
        return LOGGER_RET_NOSPACE;
    }
    e->event = event;
    e->pad = 0;
    e->gid = logger_get_gid();
    /* TODO: Could pass this down as an argument now that we're using
     * LOGGER_LOG() macro.
     */
    e->eflags = d->eflags;
    /* Noting time isn't optional. A feature may be added to avoid rendering
     * time and/or gid to a logger.
     */
    gettimeofday(&e->tv, NULL);

    va_start(ap, entry);
    d->log_cb(e, d, entry, ap);
    va_end(ap);

#ifdef NEED_ALIGN
    /* Need to ensure *next* request is aligned. */
    if (sizeof(logentry) + e->size % 8 != ...",101,,897,4,,void
22001,BLOCK,-1,,"{
        pthread_mutex_unlock(&l->mutex);
        l->dropped++;
        return LOGGER_RET_NOSPACE;
    }",20,,909,2,,void
22069,BLOCK,-1,,"{
        fprintf(stderr, ""LOGGER: Failed to bipbuf push a text entry\n"");
        pthread_mutex_unlock(&l->mutex);
        return LOGGER_RET_ERR;
    }",71,,938,2,,void
22091,BLOCK,-1,,"{
        return LOGGER_RET_NOSPACE;
    }",18,,949,2,,void
22095,BLOCK,-1,,"{
        return LOGGER_RET_OK;
    }",12,,951,1,,void
22104,BLOCK,-1,,"{
    int x;
    logger_watcher *w = NULL;
    pthread_mutex_lock(&logger_stack_lock);
    if (watcher_count >= WATCHER_LIMIT) {
        pthread_mutex_unlock(&logger_stack_lock);
        return LOGGER_ADD_WATCHER_TOO_MANY;
    }

    for (x = 0; x < WATCHER_LIMIT-1; x++) {
        if (watchers[x] == NULL)
            break;
    }

    w = calloc(1, sizeof(logger_watcher));
    if (w == NULL) {
        pthread_mutex_unlock(&logger_stack_lock);
        return LOGGER_ADD_WATCHER_FAILED;
    }
    w->c = c;
    w->sfd = sfd;
    if (sfd == 0 && c == NULL) {
        w->t = LOGGER_WATCHER_STDERR;
    } else {
        w->t = LOGGER_WATCHER_CLIENT;
    }
    w->id = x;
    w->eflags = f;
    w->min_gid = logger_get_gid();
    w->buf = bipbuf_new(settings.logger_watcher_buf_size);
    if (w->buf == NULL) {
        free(w);
        pthread_mutex_unlock(&logger_stack_lock);
        return LOGGER_ADD_WATCHER_FAILED;
    }
    bipbuf_offer(w->buf, (unsigned char *) ""OK\r\n"", 4);

    watchers[x]...",84,,960,4,,void
22117,BLOCK,1,,<empty>,,,,1,,void
22119,BLOCK,-1,,"{
        pthread_mutex_unlock(&logger_stack_lock);
        return LOGGER_ADD_WATCHER_TOO_MANY;
    }",41,,964,2,,void
22126,BLOCK,-1,,<empty>,5,,969,1,,void
22134,BLOCK,1,,<empty>,,,,1,,void
22139,BLOCK,4,,"{
        if (watchers[x] == NULL)
            break;
    }",43,,969,4,,void
22146,BLOCK,-1,,<empty>,13,,971,2,,void
22158,BLOCK,-1,,"{
        pthread_mutex_unlock(&logger_stack_lock);
        return LOGGER_ADD_WATCHER_FAILED;
    }",20,,975,2,,void
22182,BLOCK,-1,,"{
        w->t = LOGGER_WATCHER_STDERR;
    }",32,,981,2,,void
22189,BLOCK,-1,,"{
        w->t = LOGGER_WATCHER_CLIENT;
    }",12,,983,1,,void
22224,BLOCK,-1,,"{
        free(w);
        pthread_mutex_unlock(&logger_stack_lock);
        return LOGGER_ADD_WATCHER_FAILED;
    }",25,,990,2,,void
22264,BLOCK,-1,,<empty>,1,,1,1,,ANY
22276,BLOCK,-1,,<empty>,,,,1,,<empty>
22287,BLOCK,-1,,<empty>,,,,1,,<empty>
22298,BLOCK,-1,,<empty>,,,,1,,<empty>
22313,BLOCK,-1,,<empty>,,,,5,,<empty>
22319,BLOCK,-1,,<empty>,,,,3,,<empty>
22337,BLOCK,-1,,<empty>,,,,1,,<empty>
22349,BLOCK,-1,,<empty>,,,,1,,<empty>
22363,BLOCK,-1,,<empty>,,,,1,,<empty>
22386,BLOCK,-1,,<empty>,,,,1,,<empty>
22409,BLOCK,-1,,<empty>,,,,1,,<empty>
22439,BLOCK,-1,,<empty>,,,,2,,<empty>
22444,BLOCK,-1,,<empty>,,,,2,,<empty>
22449,BLOCK,-1,,<empty>,,,,2,,<empty>
22459,BLOCK,-1,,<empty>,,,,1,,<empty>
22469,BLOCK,-1,,<empty>,,,,2,,<empty>
22474,BLOCK,-1,,<empty>,,,,2,,<empty>
22485,BLOCK,-1,,<empty>,1,,1,1,,ANY
22489,BLOCK,-1,,"{
    md5_word_t
	a = pms->abcd[0], b = pms->abcd[1],
	c = pms->abcd[2], d = pms->abcd[3];
    md5_word_t t;
#if BYTE_ORDER > 0
    /* Define storage only for big-endian CPUs. */
    md5_word_t X[16];
#else
    /* Define storage for little-endian or both types of CPUs. */
    md5_word_t xbuf[16];
    const md5_word_t *X;
#endif

    {
#if BYTE_ORDER == 0
	/*
	 * Determine dynamically whether this is a big-endian or
	 * little-endian machine, since we can use a more efficient
	 * algorithm on the latter.
	 */
	static const int w = 1;

	if (*((const md5_byte_t *)&w)) /* dynamic little-endian */
#endif
#if BYTE_ORDER <= 0		/* little-endian */
	{
	    /*
	     * On little-endian machines, we can process properly aligned
	     * data without copying it.
	     */
	    if (!((data - (const md5_byte_t *)0) & 3)) {
		/* data are properly aligned */
		X = (const md5_word_t *)data;
	    } else {
		/* not aligned */
		memcpy(xbuf, data, 64);
		X = xbuf;
	    }
	}
#endif
#if BYTE_ORDER == 0
	els...",1,,133,3,,void
22525,BLOCK,12,,"{
#if BYTE_ORDER == 0
	/*
	 * Determine dynamically whether this is a big-endian or
	 * little-endian machine, since we can use a more efficient
	 * algorithm on the latter.
	 */
	static const int w = 1;

	if (*((const md5_byte_t *)&w)) /* dynamic little-endian */
#endif
#if BYTE_ORDER <= 0		/* little-endian */
	{
	    /*
	     * On little-endian machines, we can process properly aligned
	     * data without copying it.
	     */
	    if (!((data - (const md5_byte_t *)0) & 3)) {
		/* data are properly aligned */
		X = (const md5_word_t *)data;
	    } else {
		/* not aligned */
		memcpy(xbuf, data, 64);
		X = xbuf;
	    }
	}
#endif
#if BYTE_ORDER == 0
	else			/* dynamic big-endian */
#endif
#if BYTE_ORDER >= 0		/* big-endian */
	{
	    /*
	     * On big-endian machines, we must arrange the bytes in the
	     * right order.
	     */
	    const md5_byte_t *xp = data;
	    int i;

#  if BYTE_ORDER == 0
	    X = xbuf;		/* (dynamic only) */
#  else
#    define xbuf X		/* (static only) */
#...",5,,147,12,,void
22536,BLOCK,-1,,"{
	    /*
	     * On little-endian machines, we can process properly aligned
	     * data without copying it.
	     */
	    if (!((data - (const md5_byte_t *)0) & 3)) {
		/* data are properly aligned */
		X = (const md5_word_t *)data;
	    } else {
		/* not aligned */
		memcpy(xbuf, data, 64);
		X = xbuf;
	    }
	}",2,,159,2,,void
22546,BLOCK,-1,,"{
		/* data are properly aligned */
		X = (const md5_word_t *)data;
	    }",49,,164,2,,void
22553,BLOCK,-1,,"{
		/* not aligned */
		memcpy(xbuf, data, 64);
		X = xbuf;
	    }",13,,167,1,,void
22562,BLOCK,-1,,"{
	    /*
	     * On big-endian machines, we must arrange the bytes in the
	     * right order.
	     */
	    const md5_byte_t *xp = data;
	    int i;

#  if BYTE_ORDER == 0
	    X = xbuf;		/* (dynamic only) */
#  else
#    define xbuf X		/* (static only) */
#  endif
	    for (i = 0; i < 16; ++i, xp += 4)
		xbuf[i] = xp[0] + (xp[1] << 8) + (xp[2] << 16) + (xp[3] << 24);
	}",2,,178,1,,void
22572,BLOCK,-1,,<empty>,6,,191,1,,void
22616,BLOCK,1,,<empty>,,,,13,,void
22659,BLOCK,1,,<empty>,,,,13,,void
22702,BLOCK,1,,<empty>,,,,13,,void
22740,BLOCK,1,,<empty>,,,,13,,void
22783,BLOCK,1,,<empty>,,,,13,,void
22826,BLOCK,1,,<empty>,,,,13,,void
22864,BLOCK,1,,<empty>,,,,13,,void
22907,BLOCK,1,,<empty>,,,,13,,void
22950,BLOCK,1,,<empty>,,,,13,,void
22988,BLOCK,1,,<empty>,,,,13,,void
23031,BLOCK,1,,<empty>,,,,13,,void
23074,BLOCK,1,,<empty>,,,,13,,void
23117,BLOCK,1,,<empty>,,,,13,,void
23155,BLOCK,1,,<empty>,,,,13,,void
23198,BLOCK,1,,<empty>,,,,13,,void
23241,BLOCK,1,,<empty>,,,,13,,void
23279,BLOCK,1,,<empty>,,,,13,,void
23322,BLOCK,1,,<empty>,,,,13,,void
23365,BLOCK,1,,<empty>,,,,13,,void
23403,BLOCK,1,,<empty>,,,,13,,void
23447,BLOCK,1,,<empty>,,,,14,,void
23490,BLOCK,1,,<empty>,,,,13,,void
23528,BLOCK,1,,<empty>,,,,13,,void
23571,BLOCK,1,,<empty>,,,,13,,void
23614,BLOCK,1,,<empty>,,,,13,,void
23652,BLOCK,1,,<empty>,,,,13,,void
23695,BLOCK,1,,<empty>,,,,13,,void
23738,BLOCK,1,,<empty>,,,,13,,void
23776,BLOCK,1,,<empty>,,,,13,,void
23819,BLOCK,1,,<empty>,,,,13,,void
23862,BLOCK,1,,<empty>,,,,13,,void
23900,BLOCK,1,,<empty>,,,,13,,void
23943,BLOCK,1,,<empty>,,,,12,,void
23983,BLOCK,1,,<empty>,,,,12,,void
24023,BLOCK,1,,<empty>,,,,12,,void
24058,BLOCK,1,,<empty>,,,,12,,void
24098,BLOCK,1,,<empty>,,,,12,,void
24138,BLOCK,1,,<empty>,,,,12,,void
24173,BLOCK,1,,<empty>,,,,12,,void
24213,BLOCK,1,,<empty>,,,,12,,void
24253,BLOCK,1,,<empty>,,,,12,,void
24288,BLOCK,1,,<empty>,,,,12,,void
24328,BLOCK,1,,<empty>,,,,12,,void
24368,BLOCK,1,,<empty>,,,,12,,void
24403,BLOCK,1,,<empty>,,,,12,,void
24443,BLOCK,1,,<empty>,,,,12,,void
24483,BLOCK,1,,<empty>,,,,12,,void
24518,BLOCK,1,,<empty>,,,,12,,void
24558,BLOCK,1,,<empty>,,,,12,,void
24599,BLOCK,1,,<empty>,,,,12,,void
24635,BLOCK,1,,<empty>,,,,12,,void
24676,BLOCK,1,,<empty>,,,,12,,void
24717,BLOCK,1,,<empty>,,,,12,,void
24753,BLOCK,1,,<empty>,,,,12,,void
24794,BLOCK,1,,<empty>,,,,12,,void
24835,BLOCK,1,,<empty>,,,,12,,void
24876,BLOCK,1,,<empty>,,,,12,,void
24912,BLOCK,1,,<empty>,,,,12,,void
24953,BLOCK,1,,<empty>,,,,12,,void
24994,BLOCK,1,,<empty>,,,,12,,void
25030,BLOCK,1,,<empty>,,,,12,,void
25071,BLOCK,1,,<empty>,,,,12,,void
25112,BLOCK,1,,<empty>,,,,12,,void
25148,BLOCK,1,,<empty>,,,,12,,void
25215,BLOCK,-1,,"{
    pms->count[0] = pms->count[1] = 0;
    pms->abcd[0] = 0x67452301;
    pms->abcd[1] = /*0xefcdab89*/ T_MASK ^ 0x10325476;
    pms->abcd[2] = /*0x98badcfe*/ T_MASK ^ 0x67452301;
    pms->abcd[3] = 0x10325476;
}",1,,314,2,,void
25244,BLOCK,1,,<empty>,,,,1,,void
25258,BLOCK,1,,<empty>,,,,1,,void
25277,BLOCK,-1,,"{
    const md5_byte_t *p = data;
    int left = nbytes;
    int offset = (pms->count[0] >> 3) & 63;
    md5_word_t nbits = (md5_word_t)(nbytes << 3);

    if (nbytes <= 0)
	return;

    /* Update the message length. */
    pms->count[1] += nbytes >> 29;
    pms->count[0] += nbits;
    if (pms->count[0] < nbits)
	pms->count[1]++;

    /* Process an initial partial block. */
    if (offset) {
	int copy = (offset + nbytes > 64 ? 64 - offset : nbytes);

	memcpy(pms->buf + offset, p, copy);
	if (offset + copy < 64)
	    return;
	p += copy;
	left -= copy;
	md5_process(pms, pms->buf);
    }

    /* Process full blocks. */
    for (; left >= 64; p += 64, left -= 64)
	md5_process(pms, p);

    /* Process a final partial block. */
    if (left)
	memcpy(pms->buf, p, left);
}",1,,324,4,,void
25310,BLOCK,-1,,<empty>,2,,331,2,,void
25336,BLOCK,-1,,<empty>,2,,337,2,,void
25345,BLOCK,-1,,"{
	int copy = (offset + nbytes > 64 ? 64 - offset : nbytes);

	memcpy(pms->buf + offset, p, copy);
	if (offset + copy < 64)
	    return;
	p += copy;
	left -= copy;
	md5_process(pms, pms->buf);
    }",17,,340,2,,void
25373,BLOCK,-1,,<empty>,6,,345,2,,void
25387,BLOCK,-1,,<empty>,5,,352,1,,void
25403,BLOCK,-1,,<empty>,2,,357,2,,void
25415,BLOCK,-1,,"{
    static const md5_byte_t pad[64] = {
	0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    };
    md5_byte_t data[8];
    int i;

    /* Save the length before padding. */
    for (i = 0; i < 8; ++i)
	data[i] = (md5_byte_t)(pms->count[i >> 2] >> ((i & 3) << 3));
    /* Pad to 56 bytes mod 64. */
    md5_append(pms, pad, ((55 - (pms->count[0] >> 3)) & 63) + 1);
    /* Append the length. */
    md5_append(pms, data, 8);
    for (i = 0; i < 16; ++i)
	digest[i] = (md5_byte_t)(pms->abcd[i >> 2] >> ((i & 3) << 3));
}",1,,362,3,,void
25487,BLOCK,-1,,<empty>,5,,373,1,,void
25536,BLOCK,-1,,<empty>,5,,379,1,,void
25570,BLOCK,-1,,<empty>,1,,1,1,,ANY
25578,BLOCK,-1,,<empty>,,,,1,,<empty>
25590,BLOCK,-1,,<empty>,,,,2,,<empty>
25597,BLOCK,-1,,<empty>,,,,4,,<empty>
25603,BLOCK,-1,,<empty>,,,,3,,<empty>
25674,BLOCK,-1,,<empty>,1,,1,1,,ANY
25677,BLOCK,-1,,<empty>,,,,2,,<empty>
25682,BLOCK,-1,,<empty>,,,,2,,<empty>
25689,BLOCK,-1,,<empty>,,,,4,,<empty>
25696,BLOCK,-1,,<empty>,,,,4,,<empty>
25703,BLOCK,-1,,<empty>,,,,4,,<empty>
25713,BLOCK,-1,,<empty>,,,,2,,<empty>
25718,BLOCK,-1,,<empty>,,,,2,,<empty>
25726,BLOCK,-1,,<empty>,,,,1,,<empty>
25731,BLOCK,-1,,<empty>,,,,2,,<empty>
25738,BLOCK,-1,,<empty>,,,,4,,<empty>
25743,BLOCK,-1,,<empty>,,,,2,,<empty>
25750,BLOCK,-1,,<empty>,,,,4,,<empty>
25755,BLOCK,-1,,<empty>,,,,2,,<empty>
25760,BLOCK,-1,,<empty>,,,,2,,<empty>
25766,BLOCK,-1,,<empty>,,,,3,,<empty>
25771,BLOCK,-1,,<empty>,,,,2,,<empty>
25776,BLOCK,-1,,<empty>,,,,2,,<empty>
25806,BLOCK,-1,,"{
    assert (c != NULL);
    return read(c->sfd, buf, count);
}",52,,133,4,,void
25824,BLOCK,-1,,"{
    assert (c != NULL);
    return sendmsg(c->sfd, msg, flags);
}",61,,138,4,,void
25842,BLOCK,-1,,"{
    assert (c != NULL);
    return write(c->sfd, buf, count);
}",53,,143,4,,void
25872,BLOCK,-1,,"{
    struct timeval t = {.tv_sec = 0, .tv_usec = 10000};

    if (fd == -42 || allow_new_conns == false) {
        /* reschedule in 10ms if we need to keep polling */
        evtimer_set(&maxconnsevent, maxconns_handler, 0);
        event_base_set(main_base, &maxconnsevent);
        evtimer_add(&maxconnsevent, &t);
    } else {
        evtimer_del(&maxconnsevent);
        accept_new_conns(true);
    }
}",86,,158,4,,void
25877,BLOCK,1,,<empty>,25,,159,1,,void
25881,BLOCK,2,,<empty>,38,,159,2,,void
25894,BLOCK,-1,,"{
        /* reschedule in 10ms if we need to keep polling */
        evtimer_set(&maxconnsevent, maxconns_handler, 0);
        event_base_set(main_base, &maxconnsevent);
        evtimer_add(&maxconnsevent, &t);
    }",48,,161,2,,void
25910,BLOCK,-1,,"{
        evtimer_del(&maxconnsevent);
        accept_new_conns(true);
    }",12,,166,1,,void
25920,BLOCK,-1,,"{
    /* no. of seconds in 30 days - largest possible delta exptime */

    if (exptime == 0) return 0; /* 0 means never expire */

    if (exptime > REALTIME_MAXDELTA) {
        /* if item expiration is at/before the server started, give it an
           expiration time of 1 second after the server started.
           (because 0 means don't expire).  without this, we'd
           underflow and wrap around to some large value way in the
           future, effectively making items expiring in the past
           really expiring never */
        if (exptime <= process_started)
            return (rel_time_t)1;
        return (rel_time_t)(exptime - process_started);
    } else {
        return (rel_time_t)(exptime + current_time);
    }
}",43,,177,2,,void
25925,BLOCK,-1,,<empty>,23,,180,2,,void
25932,BLOCK,1,,<empty>,,,,1,,void
25940,BLOCK,-1,,"{
        /* if item expiration is at/before the server started, give it an
           expiration time of 1 second after the server started.
           (because 0 means don't expire).  without this, we'd
           underflow and wrap around to some large value way in the
           future, effectively making items expiring in the past
           really expiring never */
        if (exptime <= process_started)
            return (rel_time_t)1;
        return (rel_time_t)(exptime - process_started);
    }",38,,182,2,,void
25945,BLOCK,-1,,<empty>,13,,190,2,,void
25957,BLOCK,-1,,"{
        return (rel_time_t)(exptime + current_time);
    }",12,,192,1,,void
25968,BLOCK,-1,,"{
    memset(&stats, 0, sizeof(struct stats));
    memset(&stats_state, 0, sizeof(struct stats_state));
    stats_state.accepting_conns = true; /* assuming we start in this state. */

    /* make the time we started always be 2 seconds before we really
       did, so time(0) - time.started is never zero.  if so, things
       like 'settings.oldest_live' which act as booleans as well as
       values are now false in boolean context... */
    process_started = time(0) - ITEM_UPDATE_INTERVAL - 2;
    stats_prefix_init(settings.prefix_delimiter);
}",30,,197,2,,void
25993,BLOCK,1,,<empty>,,,,1,,void
26004,BLOCK,-1,,"{
    STATS_LOCK();
    memset(&stats, 0, sizeof(struct stats));
    stats_prefix_clear();
    STATS_UNLOCK();
    threadlocal_stats_reset();
    item_stats_reset();
}",24,,210,2,,void
26020,BLOCK,-1,,"{
    settings.use_cas = true;
    settings.access = 0700;
    settings.port = 11211;
    settings.udpport = 0;
#ifdef TLS
    settings.ssl_enabled = false;
    settings.ssl_ctx = NULL;
    settings.ssl_chain_cert = NULL;
    settings.ssl_key = NULL;
    settings.ssl_verify_mode = SSL_VERIFY_NONE;
    settings.ssl_keyformat = SSL_FILETYPE_PEM;
    settings.ssl_ciphers = NULL;
    settings.ssl_ca_cert = NULL;
    settings.ssl_last_cert_refresh_time = current_time;
    settings.ssl_wbuf_size = 16 * 1024; // default is 16KB (SSL max frame size is 17KB)
    settings.ssl_session_cache = false;
    settings.ssl_kernel_tls = false;
    settings.ssl_min_version = TLS1_2_VERSION;
#endif
    /* By default this string should be NULL for getaddrinfo() */
    settings.inter = NULL;
    settings.maxbytes = 64 * 1024 * 1024; /* default is 64MB */
    settings.maxconns = 1024;         /* to limit connections-related memory to about 5MB */
    settings.verbose = 0;
    settings.oldest_live = 0;
    ...",33,,219,2,,void
26263,BLOCK,1,,<empty>,,,,1,,void
26285,BLOCK,1,,<empty>,,,,1,,void
26294,BLOCK,1,,<empty>,,,,1,,void
26338,BLOCK,-1,,"{
    int i;
    conn *c;
    rel_time_t oldest_last_cmd;
    int sleep_time;
    int sleep_slice = max_fds / CONNS_PER_SLICE;
    if (sleep_slice == 0)
        sleep_slice = CONNS_PER_SLICE;

    useconds_t timeslice = 1000000 / sleep_slice;

    mutex_lock(&conn_timeout_lock);
    while(do_run_conn_timeout_thread) {
        if (settings.verbose > 2)
            fprintf(stderr, ""idle timeout thread at top of connection list\n"");

        oldest_last_cmd = current_time;

        for (i = 0; i < max_fds; i++) {
            if ((i % CONNS_PER_SLICE) == 0) {
                if (settings.verbose > 2)
                    fprintf(stderr, ""idle timeout thread sleeping for %ulus\n"",
                        (unsigned int)timeslice);
                usleep(timeslice);
            }

            if (!conns[i])
                continue;

            c = conns[i];

            if (!IS_TCP(c->transport))
                continue;

            if (c->state != conn_new_cmd && c->state != conn_read)...",45,,309,2,,void
26349,BLOCK,1,,<empty>,,,,1,,void
26355,BLOCK,-1,,<empty>,9,,316,2,,void
26359,BLOCK,1,,<empty>,,,,1,,void
26370,BLOCK,1,,<empty>,,,,3,,void
26376,BLOCK,-1,,"{
        if (settings.verbose > 2)
            fprintf(stderr, ""idle timeout thread at top of connection list\n"");

        oldest_last_cmd = current_time;

        for (i = 0; i < max_fds; i++) {
            if ((i % CONNS_PER_SLICE) == 0) {
                if (settings.verbose > 2)
                    fprintf(stderr, ""idle timeout thread sleeping for %ulus\n"",
                        (unsigned int)timeslice);
                usleep(timeslice);
            }

            if (!conns[i])
                continue;

            c = conns[i];

            if (!IS_TCP(c->transport))
                continue;

            if (c->state != conn_new_cmd && c->state != conn_read)
                continue;

            if ((current_time - c->last_cmd_time) > settings.idle_timeout) {
                timeout_conn(c);
            } else {
                if (c->last_cmd_time < oldest_last_cmd)
                    oldest_last_cmd = c->last_cmd_time;
            }
        }

        /* This is the...",39,,321,2,,void
26383,BLOCK,-1,,<empty>,13,,323,2,,void
26391,BLOCK,-1,,<empty>,9,,327,1,,void
26400,BLOCK,4,,"{
            if ((i % CONNS_PER_SLICE) == 0) {
                if (settings.verbose > 2)
                    fprintf(stderr, ""idle timeout thread sleeping for %ulus\n"",
                        (unsigned int)timeslice);
                usleep(timeslice);
            }

            if (!conns[i])
                continue;

            c = conns[i];

            if (!IS_TCP(c->transport))
                continue;

            if (c->state != conn_new_cmd && c->state != conn_read)
                continue;

            if ((current_time - c->last_cmd_time) > settings.idle_timeout) {
                timeout_conn(c);
            } else {
                if (c->last_cmd_time < oldest_last_cmd)
                    oldest_last_cmd = c->last_cmd_time;
            }
        }",39,,327,4,,void
26406,BLOCK,1,,<empty>,,,,1,,void
26409,BLOCK,-1,,"{
                if (settings.verbose > 2)
                    fprintf(stderr, ""idle timeout thread sleeping for %ulus\n"",
                        (unsigned int)timeslice);
                usleep(timeslice);
            }",45,,328,2,,void
26416,BLOCK,-1,,<empty>,21,,330,2,,void
26430,BLOCK,-1,,<empty>,17,,336,2,,void
26443,BLOCK,1,,<empty>,,,,3,,void
26449,BLOCK,-1,,<empty>,17,,341,2,,void
26463,BLOCK,-1,,<empty>,17,,344,2,,void
26475,BLOCK,-1,,"{
                timeout_conn(c);
            }",76,,346,2,,void
26479,BLOCK,-1,,"{
                if (c->last_cmd_time < oldest_last_cmd)
                    oldest_last_cmd = c->last_cmd_time;
            }",20,,348,1,,void
26486,BLOCK,-1,,<empty>,21,,350,2,,void
26507,BLOCK,-1,,<empty>,13,,357,2,,void
26517,BLOCK,-1,,<empty>,13,,360,2,,void
26552,BLOCK,1,,<empty>,,,,3,,void
26561,BLOCK,-1,,"{
    int ret;

    if (settings.idle_timeout == 0)
        return -1;

    do_run_conn_timeout_thread = 1;
    if ((ret = pthread_create(&conn_timeout_tid, NULL,
        conn_timeout_thread, NULL)) != 0) {
        fprintf(stderr, ""Can't create idle connection timeout thread: %s\n"",
            strerror(ret));
        return -1;
    }

    return 0;
}",40,,377,1,,void
26569,BLOCK,-1,,<empty>,9,,381,2,,void
26587,BLOCK,-1,,"{
        fprintf(stderr, ""Can't create idle connection timeout thread: %s\n"",
            strerror(ret));
        return -1;
    }",43,,385,2,,void
26602,BLOCK,-1,,"{
    if (!do_run_conn_timeout_thread)
        return -1;
    mutex_lock(&conn_timeout_lock);
    do_run_conn_timeout_thread = 0;
    pthread_cond_signal(&conn_timeout_cond);
    mutex_unlock(&conn_timeout_lock);
    pthread_join(conn_timeout_tid, NULL);
    return 0;
}",36,,394,2,,void
26606,BLOCK,-1,,<empty>,9,,396,2,,void
26613,BLOCK,1,,<empty>,,,,3,,void
26626,BLOCK,1,,<empty>,,,,3,,void
26639,BLOCK,-1,,"{
    if (c->rbuf != NULL && c->rbytes == 0 && !IS_UDP(c->transport)) {
        if (c->rbuf_malloced) {
            free(c->rbuf);
            c->rbuf_malloced = false;
        } else {
            do_cache_free(c->thread->rbuf_cache, c->rbuf);
        }
        c->rsize = 0;
        c->rbuf = NULL;
        c->rcurr = NULL;
    }
}",35,,408,2,,void
26658,BLOCK,1,,<empty>,,,,2,,void
26664,BLOCK,-1,,"{
        if (c->rbuf_malloced) {
            free(c->rbuf);
            c->rbuf_malloced = false;
        } else {
            do_cache_free(c->thread->rbuf_cache, c->rbuf);
        }
        c->rsize = 0;
        c->rbuf = NULL;
        c->rcurr = NULL;
    }",69,,409,2,,void
26669,BLOCK,-1,,"{
            free(c->rbuf);
            c->rbuf_malloced = false;
        }",31,,410,2,,void
26680,BLOCK,-1,,"{
            do_cache_free(c->thread->rbuf_cache, c->rbuf);
        }",16,,413,1,,void
26709,BLOCK,-1,,"{
    if (c->rbuf == NULL) {
        c->rbuf = do_cache_alloc(c->thread->rbuf_cache);
        if (!c->rbuf) {
            THR_STATS_LOCK(c);
            c->thread->stats.read_buf_oom++;
            THR_STATS_UNLOCK(c);
            return false;
        }
        c->rsize = READ_BUFFER_SIZE;
        c->rcurr = c->rbuf;
    }
    return true;
}",33,,422,2,,void
26716,BLOCK,-1,,"{
        c->rbuf = do_cache_alloc(c->thread->rbuf_cache);
        if (!c->rbuf) {
            THR_STATS_LOCK(c);
            c->thread->stats.read_buf_oom++;
            THR_STATS_UNLOCK(c);
            return false;
        }
        c->rsize = READ_BUFFER_SIZE;
        c->rcurr = c->rbuf;
    }",26,,423,2,,void
26732,BLOCK,-1,,"{
            THR_STATS_LOCK(c);
            c->thread->stats.read_buf_oom++;
            THR_STATS_UNLOCK(c);
            return false;
        }",23,,425,2,,void
26735,BLOCK,1,,<empty>,,,,2,,void
26755,BLOCK,1,,<empty>,,,,2,,void
26772,BLOCK,1,,<empty>,,,,1,,void
26787,BLOCK,-1,,"{
    // Might as well start with x2 and work from there.
    size_t size = c->rsize * 2;
    char *tmp = malloc(size);
    if (!tmp)
        return false;

    memcpy(tmp, c->rcurr, c->rbytes);
    do_cache_free(c->thread->rbuf_cache, c->rbuf);

    c->rcurr = c->rbuf = tmp;
    c->rsize = size;
    c->rbuf_malloced = true;
    return true;
}",37,,440,2,,void
26804,BLOCK,-1,,<empty>,9,,445,2,,void
26849,BLOCK,-1,,"{
    /* We're unlikely to see an FD much higher than maxconns. */
    int next_fd = dup(1);
    if (next_fd < 0) {
        perror(""Failed to duplicate file descriptor\n"");
        exit(1);
    }
    int headroom = 10;      /* account for extra unexpected open FDs */
    struct rlimit rl;

    max_fds = settings.maxconns + headroom + next_fd;

    /* But if possible, get the actual highest FD we can possibly ever see. */
    if (getrlimit(RLIMIT_NOFILE, &rl) == 0) {
        max_fds = rl.rlim_max;
    } else {
        fprintf(stderr, ""Failed to query maximum file descriptor; ""
                        ""falling back to maxconns\n"");
    }

    close(next_fd);

    if ((conns = calloc(max_fds, sizeof(conn *))) == NULL) {
        fprintf(stderr, ""Failed to allocate connection structures\n"");
        /* This is unrecoverable so bail out early. */
        exit(1);
    }
}",29,,466,2,,void
26859,BLOCK,-1,,"{
        perror(""Failed to duplicate file descriptor\n"");
        exit(1);
    }",22,,469,2,,void
26885,BLOCK,-1,,"{
        max_fds = rl.rlim_max;
    }",45,,479,2,,void
26892,BLOCK,-1,,"{
        fprintf(stderr, ""Failed to query maximum file descriptor; ""
                        ""falling back to maxconns\n"");
    }",12,,481,1,,void
26907,BLOCK,-1,,"{
        fprintf(stderr, ""Failed to allocate connection structures\n"");
        /* This is unrecoverable so bail out early. */
        exit(1);
    }",60,,488,2,,void
26917,BLOCK,-1,,"{
    char *rv = ""unknown"";
    switch(prot) {
        case ascii_prot:
            rv = ""ascii"";
            break;
        case binary_prot:
            rv = ""binary"";
            break;
        case negotiating_prot:
            rv = ""auto-negotiate"";
            break;
#ifdef PROXY
        case proxy_prot:
            rv = ""proxy"";
            break;
#endif
    }
    return rv;
}",50,,495,2,,void
26924,BLOCK,-1,,"{
        case ascii_prot:
            rv = ""ascii"";
            break;
        case binary_prot:
            rv = ""binary"";
            break;
        case negotiating_prot:
            rv = ""auto-negotiate"";
            break;
#ifdef PROXY
        case proxy_prot:
            rv = ""proxy"";
            break;
#endif
    }",18,,497,2,,void
26949,BLOCK,-1,,"{
    if (settings.idle_timeout > 0 &&
        (current_time - c->last_cmd_time) > settings.idle_timeout) {
        if (c->state != conn_new_cmd && c->state != conn_read) {
            if (settings.verbose > 1)
                fprintf(stderr,
                    ""fd %d wants to timeout, but isn't in read state"", c->sfd);
            return;
        }

        if (settings.verbose > 1)
            fprintf(stderr, ""Closing idle fd %d\n"", c->sfd);

        pthread_mutex_lock(&c->thread->stats.mutex);
        c->thread->stats.idle_kicks++;
        pthread_mutex_unlock(&c->thread->stats.mutex);

        c->close_reason = IDLE_TIMEOUT_CLOSE;

        conn_set_state(c, conn_closing);
        drive_machine(c);
    }
}",31,,516,2,,void
26966,BLOCK,-1,,"{
        if (c->state != conn_new_cmd && c->state != conn_read) {
            if (settings.verbose > 1)
                fprintf(stderr,
                    ""fd %d wants to timeout, but isn't in read state"", c->sfd);
            return;
        }

        if (settings.verbose > 1)
            fprintf(stderr, ""Closing idle fd %d\n"", c->sfd);

        pthread_mutex_lock(&c->thread->stats.mutex);
        c->thread->stats.idle_kicks++;
        pthread_mutex_unlock(&c->thread->stats.mutex);

        c->close_reason = IDLE_TIMEOUT_CLOSE;

        conn_set_state(c, conn_closing);
        drive_machine(c);
    }",68,,518,2,,void
26979,BLOCK,-1,,"{
            if (settings.verbose > 1)
                fprintf(stderr,
                    ""fd %d wants to timeout, but isn't in read state"", c->sfd);
            return;
        }",64,,519,2,,void
26986,BLOCK,-1,,<empty>,17,,521,2,,void
27000,BLOCK,-1,,<empty>,13,,527,2,,void
27047,BLOCK,-1,,"{
    if (c->state == conn_io_queue) {
        c->io_queues_submitted--;
        // If we're still waiting for other queues to return, don't re-add the
        // connection yet.
        if (c->io_queues_submitted != 0) {
            return;
        }
    }
    c->ev_flags = EV_READ | EV_PERSIST;
    event_set(&c->event, c->sfd, c->ev_flags, event_handler, (void *)c);
    event_base_set(c->thread->base, &c->event);

    // TODO: call conn_cleanup/fail/etc
    if (event_add(&c->event, 0) == -1) {
        perror(""event_add"");
    }

    // side thread wanted us to close immediately.
    if (c->state == conn_closing) {
        drive_machine(c);
        return;
    } else if (c->state == conn_io_queue) {
        // machine will know how to return based on secondary state.
        drive_machine(c);
    } else {
        conn_set_state(c, conn_new_cmd);
    }
}",33,,541,2,,void
27054,BLOCK,-1,,"{
        c->io_queues_submitted--;
        // If we're still waiting for other queues to return, don't re-add the
        // connection yet.
        if (c->io_queues_submitted != 0) {
            return;
        }
    }",36,,542,2,,void
27065,BLOCK,-1,,"{
            return;
        }",42,,546,2,,void
27109,BLOCK,-1,,"{
        perror(""event_add"");
    }",40,,555,2,,void
27118,BLOCK,-1,,"{
        drive_machine(c);
        return;
    }",35,,560,2,,void
27123,BLOCK,-1,,<empty>,12,,563,1,,void
27130,BLOCK,-1,,"{
        // machine will know how to return based on secondary state.
        drive_machine(c);
    }",43,,563,2,,void
27134,BLOCK,-1,,"{
        conn_set_state(c, conn_new_cmd);
    }",12,,566,1,,void
27148,BLOCK,-1,,"{
    io_queue_cb_t *q = t->io_queues;
    while (q->type != IO_QUEUE_NONE) {
        q++;
    }
    q->type = type;
    q->ctx = ctx;
    q->submit_cb = cb;
    q->complete_cb = com_cb;
    q->finalize_cb = fin_cb;
    q->return_cb   = ret_cb;
    return;
}",155,,571,8,,void
27161,BLOCK,1,,<empty>,,,,1,,void
27163,BLOCK,-1,,"{
        q++;
    }",38,,573,2,,void
27201,BLOCK,-1,,"{
    io_queue_cb_t *qcb = c->thread->io_queues;
    io_queue_t *q = c->io_queues;
    while (qcb->type != IO_QUEUE_NONE) {
        q->type = qcb->type;
        q->ctx = qcb->ctx;
        q->stack_ctx = NULL;
        q->count = 0;
        qcb++;
        q++;
    }
}",35,,585,2,,void
27222,BLOCK,1,,<empty>,,,,1,,void
27224,BLOCK,-1,,"{
        q->type = qcb->type;
        q->ctx = qcb->ctx;
        q->stack_ctx = NULL;
        q->count = 0;
        qcb++;
        q++;
    }",40,,588,2,,void
27257,BLOCK,-1,,"{
    for (io_queue_t *q = c->io_queues; q->type != IO_QUEUE_NONE; q++) {
        assert(q->count == 0);
        q->stack_ctx = NULL;
    }
}",42,,599,2,,void
27259,BLOCK,-1,,<empty>,5,,600,1,,void
27271,BLOCK,1,,<empty>,,,,1,,void
27275,BLOCK,4,,"{
        assert(q->count == 0);
        q->stack_ctx = NULL;
    }",71,,600,4,,void
27292,BLOCK,-1,,"{
    io_queue_cb_t *q = t->io_queues;
    while (q->type != IO_QUEUE_NONE) {
        if (q->type == type) {
            return q;
        }
        q++;
    }
    return NULL;
}",66,,606,3,,void
27305,BLOCK,1,,<empty>,,,,1,,void
27307,BLOCK,-1,,"{
        if (q->type == type) {
            return q;
        }
        q++;
    }",38,,608,2,,void
27314,BLOCK,-1,,"{
            return q;
        }",30,,609,2,,void
27326,BLOCK,-1,,"{
    io_queue_t *q = c->io_queues;
    while (q->type != IO_QUEUE_NONE) {
        if (q->type == type) {
            return q;
        }
        q++;
    }
    return NULL;
}",50,,617,3,,void
27339,BLOCK,1,,<empty>,,,,1,,void
27341,BLOCK,-1,,"{
        if (q->type == type) {
            return q;
        }
        q++;
    }",38,,619,2,,void
27348,BLOCK,-1,,"{
            return q;
        }",30,,620,2,,void
27359,BLOCK,-1,,"{
    io_queue_t *q = c->io_queues;
    io_queue_cb_t *qcb = c->thread->io_queues;
    while (q->type != IO_QUEUE_NONE) {
        if (q->stack_ctx) {
            qcb->complete_cb(q);
        }
        qcb++;
        q++;
    }
}",45,,631,2,,void
27380,BLOCK,1,,<empty>,,,,1,,void
27382,BLOCK,-1,,"{
        if (q->stack_ctx) {
            qcb->complete_cb(q);
        }
        qcb++;
        q++;
    }",38,,634,2,,void
27387,BLOCK,-1,,"{
            qcb->complete_cb(q);
        }",27,,635,2,,void
27401,BLOCK,-1,,"{
    io_queue_cb_t *q = thread_io_queue_get(io->thread, io->io_queue_type);
    q->return_cb(io);
    return;
}",45,,644,2,,void
27430,BLOCK,-1,,"{
    conn *c;

    assert(sfd >= 0 && sfd < max_fds);
    c = conns[sfd];

    if (NULL == c) {
        if (!(c = (conn *)calloc(1, sizeof(conn)))) {
            STATS_LOCK();
            stats.malloc_fails++;
            STATS_UNLOCK();
            fprintf(stderr, ""Failed to allocate connection object\n"");
            return NULL;
        }
        MEMCACHED_CONN_CREATE(c);
        c->read = NULL;
        c->sendmsg = NULL;
        c->write = NULL;
        c->rbuf = NULL;

        c->rsize = read_buffer_size;

        // UDP connections use a persistent static buffer.
        if (c->rsize) {
            c->rbuf = (char *)malloc((size_t)c->rsize);
        }

        if (c->rsize && c->rbuf == NULL) {
            conn_free(c);
            STATS_LOCK();
            stats.malloc_fails++;
            STATS_UNLOCK();
            fprintf(stderr, ""Failed to allocate buffers for connection\n"");
            return NULL;
        }


        STATS_LOCK();
        stats_state.conn_structs++;
 ...",39,,654,10,,void
27449,BLOCK,-1,,"{
        if (!(c = (conn *)calloc(1, sizeof(conn)))) {
            STATS_LOCK();
            stats.malloc_fails++;
            STATS_UNLOCK();
            fprintf(stderr, ""Failed to allocate connection object\n"");
            return NULL;
        }
        MEMCACHED_CONN_CREATE(c);
        c->read = NULL;
        c->sendmsg = NULL;
        c->write = NULL;
        c->rbuf = NULL;

        c->rsize = read_buffer_size;

        // UDP connections use a persistent static buffer.
        if (c->rsize) {
            c->rbuf = (char *)malloc((size_t)c->rsize);
        }

        if (c->rsize && c->rbuf == NULL) {
            conn_free(c);
            STATS_LOCK();
            stats.malloc_fails++;
            STATS_UNLOCK();
            fprintf(stderr, ""Failed to allocate buffers for connection\n"");
            return NULL;
        }


        STATS_LOCK();
        stats_state.conn_structs++;
        STATS_UNLOCK();

        c->sfd = sfd;
        conns[sfd] = c;
    }",20,,660,2,,void
27460,BLOCK,-1,,"{
            STATS_LOCK();
            stats.malloc_fails++;
            STATS_UNLOCK();
            fprintf(stderr, ""Failed to allocate connection object\n"");
            return NULL;
        }",53,,661,2,,void
27501,BLOCK,-1,,"{
            c->rbuf = (char *)malloc((size_t)c->rsize);
        }",23,,677,2,,void
27524,BLOCK,-1,,"{
            conn_free(c);
            STATS_LOCK();
            stats.malloc_fails++;
            STATS_UNLOCK();
            fprintf(stderr, ""Failed to allocate buffers for connection\n"");
            return NULL;
        }",42,,681,2,,void
27574,BLOCK,-1,,"{
        c->request_addr_size = sizeof(c->request_addr);
    }",31,,706,2,,void
27584,BLOCK,-1,,"{
        c->request_addr_size = 0;
    }",12,,708,1,,void
27598,BLOCK,-1,,"{
        if (getpeername(sfd, (struct sockaddr *) &c->request_addr,
                        &c->request_addr_size)) {
            perror(""getpeername"");
            memset(&c->request_addr, 0, sizeof(c->request_addr));
        }
    }",67,,712,2,,void
27612,BLOCK,-1,,"{
            perror(""getpeername"");
            memset(&c->request_addr, 0, sizeof(c->request_addr));
        }",49,,714,2,,void
27629,BLOCK,-1,,"{
        LOGGER_LOG(NULL, LOG_CONNEVENTS, LOGGER_CONNECTION_NEW, NULL,
                &c->request_addr, c->request_addr_size, c->transport, 0, sfd);
    }",37,,720,2,,void
27634,BLOCK,1,,<empty>,,,,9,,void
27636,BLOCK,-1,,"LOGGER_LOG(NULL, LOG_CONNEVENTS, LOGGER_CONNECTION_NEW, NULL,
                &c->request_addr, c->request_addr_size, c->transport, 0, sfd)",9,,721,1,,void
27645,BLOCK,-1,,<empty>,9,,721,2,,void
27660,BLOCK,-1,,<empty>,9,,721,2,,void
27684,BLOCK,-1,,"{
        if (init_state == conn_listening) {
            fprintf(stderr, ""<%d server listening (%s)\n"", sfd,
                prot_text(c->protocol));
        } else if (IS_UDP(transport)) {
            fprintf(stderr, ""<%d server listening (udp)\n"", sfd);
        } else if (c->protocol == negotiating_prot) {
            fprintf(stderr, ""<%d new auto-negotiating client connection\n"",
                    sfd);
        } else if (c->protocol == ascii_prot) {
            fprintf(stderr, ""<%d new ascii client connection.\n"", sfd);
        } else if (c->protocol == binary_prot) {
            fprintf(stderr, ""<%d new binary client connection.\n"", sfd);
#ifdef PROXY
        } else if (c->protocol == proxy_prot) {
            fprintf(stderr, ""<%d new proxy client connection.\n"", sfd);
#endif
        } else {
            fprintf(stderr, ""<%d new unknown (%d) client connection\n"",
                sfd, c->protocol);
            assert(false);
        }
    }",31,,725,2,,void
27689,BLOCK,-1,,"{
            fprintf(stderr, ""<%d server listening (%s)\n"", sfd,
                prot_text(c->protocol));
        }",43,,726,2,,void
27699,BLOCK,-1,,<empty>,16,,729,1,,void
27703,BLOCK,1,,<empty>,,,,2,,void
27707,BLOCK,-1,,"{
            fprintf(stderr, ""<%d server listening (udp)\n"", sfd);
        }",39,,729,2,,void
27713,BLOCK,-1,,<empty>,16,,731,1,,void
27720,BLOCK,-1,,"{
            fprintf(stderr, ""<%d new auto-negotiating client connection\n"",
                    sfd);
        }",53,,731,2,,void
27726,BLOCK,-1,,<empty>,16,,734,1,,void
27733,BLOCK,-1,,"{
            fprintf(stderr, ""<%d new ascii client connection.\n"", sfd);
        }",47,,734,2,,void
27739,BLOCK,-1,,<empty>,16,,736,1,,void
27746,BLOCK,-1,,"{
            fprintf(stderr, ""<%d new binary client connection.\n"", sfd);
#ifdef PROXY
        } else if (c->protocol == proxy_prot) {
            fprintf(stderr, ""<%d new proxy client connection.\n"", sfd);
#endif
        }",48,,736,2,,void
27752,BLOCK,-1,,"{
            fprintf(stderr, ""<%d new unknown (%d) client connection\n"",
                sfd, c->protocol);
            assert(false);
        }",16,,742,1,,void
27858,BLOCK,30,,"{
        c->read = tcp_read;
        c->sendmsg = tcp_sendmsg;
        c->write = tcp_write;
    }",5,,788,30,,void
27877,BLOCK,1,,<empty>,,,,2,,void
27881,BLOCK,-1,,"{
        c->try_read_command = try_read_command_udp;
    }",28,,794,2,,void
27888,BLOCK,-1,,"{
        switch (c->protocol) {
            case ascii_prot:
                if (settings.auth_file == NULL) {
                    c->authenticated = true;
                    c->try_read_command = try_read_command_ascii;
                } else {
                    c->authenticated = false;
                    c->try_read_command = try_read_command_asciiauth;
                }
                break;
            case binary_prot:
                // binprot handles its own authentication via SASL parsing.
                c->authenticated = false;
                c->try_read_command = try_read_command_binary;
                break;
            case negotiating_prot:
                c->try_read_command = try_read_command_negotiate;
                break;
#ifdef PROXY
            case proxy_prot:
                c->try_read_command = try_read_command_proxy;
                break;
#endif
        }
    }",12,,796,1,,void
27893,BLOCK,-1,,"{
            case ascii_prot:
                if (settings.auth_file == NULL) {
                    c->authenticated = true;
                    c->try_read_command = try_read_command_ascii;
                } else {
                    c->authenticated = false;
                    c->try_read_command = try_read_command_asciiauth;
                }
                break;
            case binary_prot:
                // binprot handles its own authentication via SASL parsing.
                c->authenticated = false;
                c->try_read_command = try_read_command_binary;
                break;
            case negotiating_prot:
                c->try_read_command = try_read_command_negotiate;
                break;
#ifdef PROXY
            case proxy_prot:
                c->try_read_command = try_read_command_proxy;
                break;
#endif
        }",30,,797,2,,void
27902,BLOCK,-1,,"{
                    c->authenticated = true;
                    c->try_read_command = try_read_command_ascii;
                }",49,,799,2,,void
27914,BLOCK,-1,,"{
                    c->authenticated = false;
                    c->try_read_command = try_read_command_asciiauth;
                }",24,,802,1,,void
27979,BLOCK,-1,,"{
        perror(""event_add"");
        return NULL;
    }",40,,827,2,,void
28000,BLOCK,-1,,"{
    assert(c != NULL);

    if (c->item) {
        if (c->item_malloced) {
            free(c->item);
            c->item_malloced = false;
        } else {
            item_remove(c->item);
        }
        c->item = 0;
    }

    // Cull any unsent responses.
    if (c->resp_head) {
        mc_resp *resp = c->resp_head;
        // r_f() handles the chain maintenance.
        while (resp) {
            // temporary by default. hide behind a debug flag in the future:
            // double free detection. Transmit loops can drop out early, but
            // here we could infinite loop.
            if (resp->free) {
                fprintf(stderr, ""ERROR: double free detected during conn_release_items(): [%d] [%s]\n"",
                        c->sfd, c->protocol == binary_prot ? ""binary"" : ""ascii"");
                // Since this is a critical failure, just leak the memory.
                // If these errors are seen, an abort() can be used instead.
                c->resp_head = NU...",34,,842,2,,void
28009,BLOCK,-1,,"{
        if (c->item_malloced) {
            free(c->item);
            c->item_malloced = false;
        } else {
            item_remove(c->item);
        }
        c->item = 0;
    }",18,,845,2,,void
28014,BLOCK,-1,,"{
            free(c->item);
            c->item_malloced = false;
        }",31,,846,2,,void
28025,BLOCK,-1,,"{
            item_remove(c->item);
        }",16,,849,1,,void
28039,BLOCK,-1,,"{
        mc_resp *resp = c->resp_head;
        // r_f() handles the chain maintenance.
        while (resp) {
            // temporary by default. hide behind a debug flag in the future:
            // double free detection. Transmit loops can drop out early, but
            // here we could infinite loop.
            if (resp->free) {
                fprintf(stderr, ""ERROR: double free detected during conn_release_items(): [%d] [%s]\n"",
                        c->sfd, c->protocol == binary_prot ? ""binary"" : ""ascii"");
                // Since this is a critical failure, just leak the memory.
                // If these errors are seen, an abort() can be used instead.
                c->resp_head = NULL;
                c->resp = NULL;
                break;
            }
            resp = resp_finish(c, resp);
        }
        conn_io_queue_reset(c);
    }",23,,856,2,,void
28048,BLOCK,-1,,"{
            // temporary by default. hide behind a debug flag in the future:
            // double free detection. Transmit loops can drop out early, but
            // here we could infinite loop.
            if (resp->free) {
                fprintf(stderr, ""ERROR: double free detected during conn_release_items(): [%d] [%s]\n"",
                        c->sfd, c->protocol == binary_prot ? ""binary"" : ""ascii"");
                // Since this is a critical failure, just leak the memory.
                // If these errors are seen, an abort() can be used instead.
                c->resp_head = NULL;
                c->resp = NULL;
                break;
            }
            resp = resp_finish(c, resp);
        }",22,,859,2,,void
28053,BLOCK,-1,,"{
                fprintf(stderr, ""ERROR: double free detected during conn_release_items(): [%d] [%s]\n"",
                        c->sfd, c->protocol == binary_prot ? ""binary"" : ""ascii"");
                // Since this is a critical failure, just leak the memory.
                // If these errors are seen, an abort() can be used instead.
                c->resp_head = NULL;
                c->resp = NULL;
                break;
            }",29,,863,2,,void
28090,BLOCK,-1,,"{
    assert(c != NULL);

    conn_release_items(c);
#ifdef PROXY
    if (c->proxy_coro_ref) {
        proxy_cleanup_conn(c);
    }
#endif
    if (c->sasl_conn) {
        assert(settings.sasl);
        sasl_dispose(&c->sasl_conn);
        c->sasl_conn = NULL;
    }

    if (IS_UDP(c->transport)) {
        conn_set_state(c, conn_read);
    }
}",35,,878,2,,void
28101,BLOCK,-1,,"{
        assert(settings.sasl);
        sasl_dispose(&c->sasl_conn);
        c->sasl_conn = NULL;
    }",23,,887,2,,void
28107,BLOCK,1,,sasl_dispose(&c->sasl_conn),9,,889,2,,void
28118,BLOCK,1,,<empty>,,,,2,,void
28124,BLOCK,-1,,"{
        conn_set_state(c, conn_read);
    }",31,,893,2,,void
28132,BLOCK,-1,,"{
    if (c) {
        assert(c != NULL);
        assert(c->sfd >= 0 && c->sfd < max_fds);

        MEMCACHED_CONN_DESTROY(c);
        conns[c->sfd] = NULL;
        if (c->rbuf)
            free(c->rbuf);
#ifdef TLS
        if (c->ssl_wbuf)
            c->ssl_wbuf = NULL;
#endif

        free(c);
    }
}",25,,901,2,,void
28135,BLOCK,-1,,"{
        assert(c != NULL);
        assert(c->sfd >= 0 && c->sfd < max_fds);

        MEMCACHED_CONN_DESTROY(c);
        conns[c->sfd] = NULL;
        if (c->rbuf)
            free(c->rbuf);
#ifdef TLS
        if (c->ssl_wbuf)
            c->ssl_wbuf = NULL;
#endif

        free(c);
    }",12,,902,2,,void
28163,BLOCK,-1,,<empty>,13,,909,2,,void
28174,BLOCK,-1,,"{
    assert(c != NULL);

    if (c->thread) {
        LOGGER_LOG(c->thread->l, LOG_CONNEVENTS, LOGGER_CONNECTION_CLOSE, NULL,
                &c->request_addr, c->request_addr_size, c->transport,
                c->close_reason, c->sfd);
    }

    /* delete the event, the socket and the conn */
    event_del(&c->event);

    if (settings.verbose > 1)
        fprintf(stderr, ""<%d connection closed.\n"", c->sfd);

    conn_cleanup(c);

    // force release of read buffer.
    if (c->thread) {
        c->rbytes = 0;
        rbuf_release(c);
    }

    MEMCACHED_CONN_RELEASE(c->sfd);
    conn_set_state(c, conn_closed);
#ifdef TLS
    if (c->ssl) {
        SSL_shutdown(c->ssl);
        SSL_free(c->ssl);
    }
#endif
    close(c->sfd);
    c->close_reason = 0;
    pthread_mutex_lock(&conn_lock);
    allow_new_conns = true;
    pthread_mutex_unlock(&conn_lock);

    STATS_LOCK();
    stats_state.curr_conns--;
    STATS_UNLOCK();

    return;
}",33,,919,2,,void
28183,BLOCK,-1,,"{
        LOGGER_LOG(c->thread->l, LOG_CONNEVENTS, LOGGER_CONNECTION_CLOSE, NULL,
                &c->request_addr, c->request_addr_size, c->transport,
                c->close_reason, c->sfd);
    }",20,,922,2,,void
28192,BLOCK,1,,<empty>,,,,6,,void
28194,BLOCK,-1,,"LOGGER_LOG(c->thread->l, LOG_CONNEVENTS, LOGGER_CONNECTION_CLOSE, NULL,
                &c->request_addr, c->request_addr_size, c->transport,
                c->close_reason, c->sfd)",9,,923,1,,void
28211,BLOCK,-1,,<empty>,9,,923,2,,void
28226,BLOCK,-1,,<empty>,9,,923,2,,void
28259,BLOCK,-1,,<empty>,9,,932,2,,void
28272,BLOCK,-1,,"{
        c->rbytes = 0;
        rbuf_release(c);
    }",20,,937,2,,void
28312,BLOCK,-1,,"{
    int i;
    for (i = 0; i < max_fds; i++) {
        if (conns[i] && conns[i]->state != conn_closed) {
            conn_close(conns[i]);
        }
    }
}",27,,966,2,,void
28315,BLOCK,-1,,<empty>,5,,968,1,,void
28324,BLOCK,4,,"{
        if (conns[i] && conns[i]->state != conn_closed) {
            conn_close(conns[i]);
        }
    }",35,,968,4,,void
28337,BLOCK,-1,,"{
            conn_close(conns[i]);
        }",57,,969,2,,void
28346,BLOCK,-1,,"{
    const char* const statenames[] = { ""conn_listening"",
                                       ""conn_new_cmd"",
                                       ""conn_waiting"",
                                       ""conn_read"",
                                       ""conn_parse_cmd"",
                                       ""conn_write"",
                                       ""conn_nread"",
                                       ""conn_swallow"",
                                       ""conn_closing"",
                                       ""conn_mwrite"",
                                       ""conn_closed"",
                                       ""conn_watch"",
                                       ""conn_io_queue"" };
    return statenames[state];
}",55,,978,2,,void
28373,BLOCK,-1,,"{
    assert(c != NULL);
    assert(state >= conn_listening && state < conn_max_state);

    if (state != c->state) {
        if (settings.verbose > 2) {
            fprintf(stderr, ""%d: going from %s to %s\n"",
                    c->sfd, state_text(c->state),
                    state_text(state));
        }

        if (state == conn_write || state == conn_mwrite) {
            MEMCACHED_PROCESS_COMMAND_END(c->sfd, c->resp->wbuf, c->resp->wbytes);
        }
        c->state = state;
    }
}",54,,1000,3,,void
28392,BLOCK,-1,,"{
        if (settings.verbose > 2) {
            fprintf(stderr, ""%d: going from %s to %s\n"",
                    c->sfd, state_text(c->state),
                    state_text(state));
        }

        if (state == conn_write || state == conn_mwrite) {
            MEMCACHED_PROCESS_COMMAND_END(c->sfd, c->resp->wbuf, c->resp->wbytes);
        }
        c->state = state;
    }",28,,1004,2,,void
28399,BLOCK,-1,,"{
            fprintf(stderr, ""%d: going from %s to %s\n"",
                    c->sfd, state_text(c->state),
                    state_text(state));
        }",35,,1005,2,,void
28420,BLOCK,-1,,"{
            MEMCACHED_PROCESS_COMMAND_END(c->sfd, c->resp->wbuf, c->resp->wbytes);
        }",58,,1011,2,,void
28430,BLOCK,-1,,"{
    if (resp->item) {
        item_remove(resp->item);
        resp->item = NULL;
    }
    if (resp->write_and_free) {
        free(resp->write_and_free);
        resp->write_and_free = NULL;
    }
    resp->wbytes = 0;
    resp->tosend = 0;
    resp->iovcnt = 0;
    resp->chunked_data_iov = 0;
    resp->chunked_total = 0;
    resp->skip = false;
}",32,,1021,2,,void
28435,BLOCK,-1,,"{
        item_remove(resp->item);
        resp->item = NULL;
    }",21,,1022,2,,void
28449,BLOCK,-1,,"{
        free(resp->write_and_free);
        resp->write_and_free = NULL;
    }",31,,1026,2,,void
28495,BLOCK,-1,,"{
    assert(resp->iovcnt < MC_RESP_IOVCOUNT);
    int x = resp->iovcnt;
    resp->iov[x].iov_base = (void *)buf;
    resp->iov[x].iov_len = len;
    resp->iovcnt++;
    resp->tosend += len;
}",60,,1038,4,,void
28502,BLOCK,1,,<empty>,,,,1,,void
28545,BLOCK,-1,,"{
    resp->chunked_data_iov = resp->iovcnt;
    resp->chunked_total = len;
    resp_add_iov(resp, buf, len);
}",68,,1050,4,,void
28566,BLOCK,-1,,"{
    LIBEVENT_THREAD *th = c->thread;
    mc_resp *resp = NULL;
    mc_resp_bundle *b = th->open_bundle;

    if (b != NULL) {
        for (int i = 0; i < MAX_RESP_PER_BUNDLE; i++) {
            // loop around starting from the most likely to be free
            int x = (i + b->next_check) % MAX_RESP_PER_BUNDLE;
            if (b->r[x].free) {
                resp = &b->r[x];
                b->next_check = x+1;
                break;
            }
        }

        if (resp != NULL) {
            b->refcount++;
            resp->free = false;
            if (b->refcount == MAX_RESP_PER_BUNDLE) {
                assert(b->prev == NULL);
                // We only allocate off the head. Assign new head.
                th->open_bundle = b->next;
                // Remove ourselves from the list.
                if (b->next) {
                    b->next->prev = 0;
                    b->next = 0;
                }
            }
        }
    }

    if (resp == NULL) {
        asser...",40,,1061,2,,void
28587,BLOCK,-1,,"{
        for (int i = 0; i < MAX_RESP_PER_BUNDLE; i++) {
            // loop around starting from the most likely to be free
            int x = (i + b->next_check) % MAX_RESP_PER_BUNDLE;
            if (b->r[x].free) {
                resp = &b->r[x];
                b->next_check = x+1;
                break;
            }
        }

        if (resp != NULL) {
            b->refcount++;
            resp->free = false;
            if (b->refcount == MAX_RESP_PER_BUNDLE) {
                assert(b->prev == NULL);
                // We only allocate off the head. Assign new head.
                th->open_bundle = b->next;
                // Remove ourselves from the list.
                if (b->next) {
                    b->next->prev = 0;
                    b->next = 0;
                }
            }
        }
    }",20,,1066,2,,void
28589,BLOCK,-1,,<empty>,9,,1067,1,,void
28597,BLOCK,1,,<empty>,,,,1,,void
28607,BLOCK,4,,"{
            // loop around starting from the most likely to be free
            int x = (i + b->next_check) % MAX_RESP_PER_BUNDLE;
            if (b->r[x].free) {
                resp = &b->r[x];
                b->next_check = x+1;
                break;
            }
        }",55,,1067,4,,void
28618,BLOCK,1,,<empty>,,,,1,,void
28634,BLOCK,-1,,"{
                resp = &b->r[x];
                b->next_check = x+1;
                break;
            }",31,,1070,2,,void
28655,BLOCK,-1,,"{
            b->refcount++;
            resp->free = false;
            if (b->refcount == MAX_RESP_PER_BUNDLE) {
                assert(b->prev == NULL);
                // We only allocate off the head. Assign new head.
                th->open_bundle = b->next;
                // Remove ourselves from the list.
                if (b->next) {
                    b->next->prev = 0;
                    b->next = 0;
                }
            }
        }",27,,1077,2,,void
28671,BLOCK,1,,<empty>,,,,1,,void
28679,BLOCK,-1,,"{
                assert(b->prev == NULL);
                // We only allocate off the head. Assign new head.
                th->open_bundle = b->next;
                // Remove ourselves from the list.
                if (b->next) {
                    b->next->prev = 0;
                    b->next = 0;
                }
            }",53,,1080,2,,void
28697,BLOCK,-1,,"{
                    b->next->prev = 0;
                    b->next = 0;
                }",30,,1085,2,,void
28714,BLOCK,-1,,"{
        assert(th->open_bundle == NULL);
        b = do_cache_alloc(th->rbuf_cache);
        if (b) {
            THR_STATS_LOCK(c);
            c->thread->stats.response_obj_bytes += READ_BUFFER_SIZE;
            THR_STATS_UNLOCK(c);
            b->next_check = 1;
            b->refcount = 1;
            for (int i = 0; i < MAX_RESP_PER_BUNDLE; i++) {
                b->r[i].bundle = b;
                b->r[i].free = true;
            }
            b->next = 0;
            b->prev = 0;
            th->open_bundle = b;
            resp = &b->r[0];
            resp->free = false;
        } else {
            return NULL;
        }
    }",23,,1093,2,,void
28729,BLOCK,-1,,"{
            THR_STATS_LOCK(c);
            c->thread->stats.response_obj_bytes += READ_BUFFER_SIZE;
            THR_STATS_UNLOCK(c);
            b->next_check = 1;
            b->refcount = 1;
            for (int i = 0; i < MAX_RESP_PER_BUNDLE; i++) {
                b->r[i].bundle = b;
                b->r[i].free = true;
            }
            b->next = 0;
            b->prev = 0;
            th->open_bundle = b;
            resp = &b->r[0];
            resp->free = false;
        }",16,,1096,2,,void
28732,BLOCK,1,,<empty>,,,,2,,void
28751,BLOCK,1,,<empty>,,,,1,,void
28755,BLOCK,1,,<empty>,,,,2,,void
28776,BLOCK,-1,,<empty>,13,,1102,1,,void
28784,BLOCK,1,,<empty>,,,,1,,void
28794,BLOCK,4,,"{
                b->r[i].bundle = b;
                b->r[i].free = true;
            }",59,,1102,4,,void
28842,BLOCK,-1,,"{
            return NULL;
        }",16,,1111,1,,void
28852,BLOCK,-1,,"{
    LIBEVENT_THREAD *th = c->thread;
    mc_resp_bundle *b = resp->bundle;

    resp->free = true;
    b->refcount--;
    if (b->refcount == 0) {
        if (b == th->open_bundle && b->next == 0) {
            // This is the final bundle. Just hold and reuse to skip init loop
            assert(b->prev == 0);
            b->next_check = 0;
        } else {
            // Assert that we're either in the list or at the head.
            assert((b->next || b->prev) || b == th->open_bundle);

            // unlink from list.
            mc_resp_bundle **head = &th->open_bundle;
            if (*head == b) *head = b->next;
            // Not tracking the tail.
            assert(b->next != b && b->prev != b);

            if (b->next) b->next->prev = b->prev;
            if (b->prev) b->prev->next = b->next;

            // Now completely done with this buffer.
            do_cache_free(th->rbuf_cache, b);
            THR_STATS_LOCK(c);
            c->thread->stats.response_obj_bytes -...",47,,1119,3,,void
28880,BLOCK,-1,,"{
        if (b == th->open_bundle && b->next == 0) {
            // This is the final bundle. Just hold and reuse to skip init loop
            assert(b->prev == 0);
            b->next_check = 0;
        } else {
            // Assert that we're either in the list or at the head.
            assert((b->next || b->prev) || b == th->open_bundle);

            // unlink from list.
            mc_resp_bundle **head = &th->open_bundle;
            if (*head == b) *head = b->next;
            // Not tracking the tail.
            assert(b->next != b && b->prev != b);

            if (b->next) b->next->prev = b->prev;
            if (b->prev) b->prev->next = b->next;

            // Now completely done with this buffer.
            do_cache_free(th->rbuf_cache, b);
            THR_STATS_LOCK(c);
            c->thread->stats.response_obj_bytes -= READ_BUFFER_SIZE;
            THR_STATS_UNLOCK(c);
        }
    }",27,,1125,2,,void
28893,BLOCK,-1,,"{
            // This is the final bundle. Just hold and reuse to skip init loop
            assert(b->prev == 0);
            b->next_check = 0;
        }",51,,1126,2,,void
28906,BLOCK,-1,,"{
            // Assert that we're either in the list or at the head.
            assert((b->next || b->prev) || b == th->open_bundle);

            // unlink from list.
            mc_resp_bundle **head = &th->open_bundle;
            if (*head == b) *head = b->next;
            // Not tracking the tail.
            assert(b->next != b && b->prev != b);

            if (b->next) b->next->prev = b->prev;
            if (b->prev) b->prev->next = b->next;

            // Now completely done with this buffer.
            do_cache_free(th->rbuf_cache, b);
            THR_STATS_LOCK(c);
            c->thread->stats.response_obj_bytes -= READ_BUFFER_SIZE;
            THR_STATS_UNLOCK(c);
        }",16,,1130,1,,void
28933,BLOCK,-1,,<empty>,29,,1136,2,,void
28956,BLOCK,-1,,<empty>,26,,1140,2,,void
28970,BLOCK,-1,,<empty>,26,,1141,2,,void
28987,BLOCK,1,,<empty>,,,,2,,void
29006,BLOCK,1,,<empty>,,,,1,,void
29010,BLOCK,1,,<empty>,,,,2,,void
29021,BLOCK,-1,,"{
        mc_resp_bundle **head = &th->open_bundle;
        // NOTE: since we're not tracking tail, latest free ends up in head.
        if (b == th->open_bundle || (b->prev || b->next)) {
            // If we're already linked, leave it in place to save CPU.
        } else {
            // Non-zero refcount, need to link into the freelist.
            b->prev = 0;
            b->next = *head;
            if (b->next) b->next->prev = b;
            *head = b;
        }

    }",12,,1149,1,,void
29043,BLOCK,-1,,"{
            // If we're already linked, leave it in place to save CPU.
        }",59,,1152,2,,void
29045,BLOCK,-1,,"{
            // Non-zero refcount, need to link into the freelist.
            b->prev = 0;
            b->next = *head;
            if (b->next) b->next->prev = b;
            *head = b;
        }",16,,1154,1,,void
29061,BLOCK,-1,,<empty>,26,,1158,2,,void
29077,BLOCK,-1,,"{
    mc_resp *resp = resp_allocate(c);
    if (!resp) {
        THR_STATS_LOCK(c);
        c->thread->stats.response_obj_oom++;
        THR_STATS_UNLOCK(c);
        return false;
    }
    // handling the stats counters here to simplify testing
    THR_STATS_LOCK(c);
    c->thread->stats.response_obj_count++;
    THR_STATS_UNLOCK(c);
    // Skip zeroing the bundle pointer at the start.
    // TODO: this line is here temporarily to make the code easy to disable.
    // when it's more mature, move the memset into resp_allocate() and have it
    // set the bundle pointer on allocate so this line isn't as complex.
    memset((char *)resp + sizeof(mc_resp_bundle*), 0, sizeof(*resp) - sizeof(mc_resp_bundle*));
    // TODO: this next line works. memset _does_ show up significantly under
    // perf reports due to zeroing out the entire resp->wbuf. before swapping
    // the lines more validation work should be done to ensure wbuf's aren't
    // accidentally reused without being written t...",26,,1165,2,,void
29086,BLOCK,-1,,"{
        THR_STATS_LOCK(c);
        c->thread->stats.response_obj_oom++;
        THR_STATS_UNLOCK(c);
        return false;
    }",16,,1167,2,,void
29089,BLOCK,1,,<empty>,,,,2,,void
29109,BLOCK,1,,<empty>,,,,2,,void
29123,BLOCK,1,,<empty>,,,,2,,void
29143,BLOCK,1,,<empty>,,,,2,,void
29172,BLOCK,-1,,"{
        c->resp_head = resp;
    }",24,,1187,2,,void
29183,BLOCK,-1,,"{
        c->resp = resp;
    }",19,,1190,2,,void
29190,BLOCK,-1,,"{
        c->resp->next = resp;
        c->resp = resp;
    }",12,,1192,1,,void
29208,BLOCK,1,,<empty>,,,,2,,void
29214,BLOCK,-1,,"{
        // need to hold on to some data for async responses.
        c->resp->request_id = c->request_id;
        c->resp->request_addr = c->request_addr;
        c->resp->request_addr_size = c->request_addr_size;
    }",31,,1196,2,,void
29249,BLOCK,-1,,"{
    mc_resp *next = resp->next;
    if (resp->item) {
        // TODO: cache hash value in resp obj?
        item_remove(resp->item);
        resp->item = NULL;
    }
    if (resp->write_and_free) {
        free(resp->write_and_free);
    }
    if (resp->io_pending) {
        // If we had a pending IO, tell it to internally clean up then return
        // the main object back to our thread cache.
        io_queue_cb_t *qcb = thread_io_queue_get(c->thread, resp->io_pending->io_queue_type);
        qcb->finalize_cb(resp->io_pending);
        do_cache_free(c->thread->io_cache, resp->io_pending);
        resp->io_pending = NULL;
    }
    if (c->resp_head == resp) {
        c->resp_head = next;
    }
    if (c->resp == resp) {
        c->resp = NULL;
    }
    resp_free(c, resp);
    THR_STATS_LOCK(c);
    c->thread->stats.response_obj_count--;
    THR_STATS_UNLOCK(c);
    return next;
}",46,,1206,3,,void
29260,BLOCK,-1,,"{
        // TODO: cache hash value in resp obj?
        item_remove(resp->item);
        resp->item = NULL;
    }",21,,1208,2,,void
29274,BLOCK,-1,,"{
        free(resp->write_and_free);
    }",31,,1213,2,,void
29283,BLOCK,-1,,"{
        // If we had a pending IO, tell it to internally clean up then return
        // the main object back to our thread cache.
        io_queue_cb_t *qcb = thread_io_queue_get(c->thread, resp->io_pending->io_queue_type);
        qcb->finalize_cb(resp->io_pending);
        do_cache_free(c->thread->io_cache, resp->io_pending);
        resp->io_pending = NULL;
    }",27,,1216,2,,void
29323,BLOCK,-1,,"{
        c->resp_head = next;
    }",31,,1224,2,,void
29335,BLOCK,-1,,"{
        c->resp = NULL;
    }",26,,1227,2,,void
29346,BLOCK,1,,<empty>,,,,2,,void
29366,BLOCK,1,,<empty>,,,,2,,void
29382,BLOCK,-1,,"{
    return c->resp_head->next != NULL ? true : false;
}",30,,1238,2,,void
29399,BLOCK,-1,,"{
    size_t len;
    assert(c != NULL);
    mc_resp *resp = c->resp;

    // if response was original filled with something, but we're now writing
    // out an error or similar, have to reset the object first.
    // TODO: since this is often redundant with allocation, how many callers
    // are actually requiring it be reset? Can we fast test by just looking at
    // tosend and reset if nonzero?
    resp_reset(resp);

    if (c->noreply) {
        // TODO: just invalidate the response since nothing's been attempted
        // to send yet?
        resp->skip = true;
        if (settings.verbose > 1)
            fprintf(stderr, "">%d NOREPLY %s\n"", c->sfd, str);
        conn_set_state(c, conn_new_cmd);
        return;
    }

    if (settings.verbose > 1)
        fprintf(stderr, "">%d %s\n"", c->sfd, str);

    // Fill response object with static string.

    len = strlen(str);
    if ((len + 2) > WRITE_BUFFER_SIZE) {
        /* ought to be always enough. just fail for simplicity */
...",43,,1242,3,,void
29417,BLOCK,-1,,"{
        // TODO: just invalidate the response since nothing's been attempted
        // to send yet?
        resp->skip = true;
        if (settings.verbose > 1)
            fprintf(stderr, "">%d NOREPLY %s\n"", c->sfd, str);
        conn_set_state(c, conn_new_cmd);
        return;
    }",21,,1254,2,,void
29429,BLOCK,-1,,<empty>,13,,1259,2,,void
29447,BLOCK,-1,,<empty>,9,,1265,2,,void
29465,BLOCK,1,,<empty>,,,,1,,void
29467,BLOCK,-1,,"{
        /* ought to be always enough. just fail for simplicity */
        str = ""SERVER_ERROR output line too long"";
        len = strlen(str);
    }",40,,1270,2,,void
29506,BLOCK,-1,,"{
    c->noreply = false;
    out_string(c, str);
}",46,,1286,3,,void
29520,BLOCK,-1,,"{
    const static char error_prefix[] = ""SERVER_ERROR "";
    const static int error_prefix_len = sizeof(error_prefix) - 1;

    if (c->protocol == binary_prot) {
        /* Strip off the generic error prefix; it's irrelevant in binary */
        if (!strncmp(ascii_error, error_prefix, error_prefix_len)) {
            ascii_error += error_prefix_len;
        }
        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, ascii_error, 0);
    } else {
        out_string(c, ascii_error);
    }
}",48,,1295,3,,void
29538,BLOCK,-1,,"{
        /* Strip off the generic error prefix; it's irrelevant in binary */
        if (!strncmp(ascii_error, error_prefix, error_prefix_len)) {
            ascii_error += error_prefix_len;
        }
        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, ascii_error, 0);
    }",37,,1299,2,,void
29545,BLOCK,-1,,"{
            ascii_error += error_prefix_len;
        }",68,,1301,2,,void
29555,BLOCK,-1,,"{
        out_string(c, ascii_error);
    }",12,,1305,1,,void
29567,BLOCK,-1,,"{
    char *buf = c->stats.buffer + c->stats.offset;
    uint32_t bodylen = klen + vlen;
    protocol_binary_response_header header = {
        .response.magic = (uint8_t)PROTOCOL_BINARY_RES,
        .response.opcode = PROTOCOL_BINARY_CMD_STAT,
        .response.keylen = (uint16_t)htons(klen),
        .response.datatype = (uint8_t)PROTOCOL_BINARY_RAW_BYTES,
        .response.bodylen = htonl(bodylen),
        .response.opaque = c->opaque
    };

    memcpy(buf, header.bytes, sizeof(header.response));
    buf += sizeof(header.response);

    if (klen > 0) {
        memcpy(buf, key, klen);
        buf += klen;

        if (vlen > 0) {
            memcpy(buf, val, vlen);
        }
    }

    c->stats.offset += sizeof(header.response) + bodylen;
}",39,,1312,6,,void
29592,BLOCK,1,,<empty>,9,,1316,1,,void
29603,BLOCK,2,,<empty>,9,,1317,2,,void
29610,BLOCK,3,,<empty>,9,,1318,3,,void
29623,BLOCK,4,,<empty>,9,,1319,4,,void
29634,BLOCK,5,,<empty>,9,,1320,5,,void
29643,BLOCK,6,,<empty>,9,,1321,6,,void
29673,BLOCK,-1,,"{
        memcpy(buf, key, klen);
        buf += klen;

        if (vlen > 0) {
            memcpy(buf, val, vlen);
        }
    }",19,,1327,2,,void
29685,BLOCK,-1,,"{
            memcpy(buf, val, vlen);
        }",23,,1331,2,,void
29710,BLOCK,-1,,"{
    char *pos = c->stats.buffer + c->stats.offset;
    uint32_t nbytes = 0;
    int remaining = c->stats.size - c->stats.offset;
    int room = remaining - 1;

    if (klen == 0 && vlen == 0) {
        nbytes = snprintf(pos, room, ""END\r\n"");
    } else if (vlen == 0) {
        nbytes = snprintf(pos, room, ""STAT %s\r\n"", key);
    } else {
        nbytes = snprintf(pos, room, ""STAT %s %s\r\n"", key, val);
    }

    c->stats.offset += nbytes;
}",41,,1341,6,,void
29757,BLOCK,-1,,"{
        nbytes = snprintf(pos, room, ""END\r\n"");
    }",33,,1347,2,,void
29765,BLOCK,-1,,<empty>,12,,1349,1,,void
29770,BLOCK,-1,,"{
        nbytes = snprintf(pos, room, ""STAT %s\r\n"", key);
    }",27,,1349,2,,void
29779,BLOCK,-1,,"{
        nbytes = snprintf(pos, room, ""STAT %s %s\r\n"", key, val);
    }",12,,1351,1,,void
29800,BLOCK,-1,,"{
    size_t nsize = c->stats.size;
    size_t available = nsize - c->stats.offset;
    bool rv = true;

    /* Special case: No buffer -- need to allocate fresh */
    if (c->stats.buffer == NULL) {
        nsize = 1024;
        available = c->stats.size = c->stats.offset = 0;
    }

    while (needed > available) {
        assert(nsize > 0);
        nsize = nsize << 1;
        available = nsize - c->stats.offset;
    }

    if (nsize != c->stats.size) {
        char *ptr = realloc(c->stats.buffer, nsize);
        if (ptr) {
            c->stats.buffer = ptr;
            c->stats.size = nsize;
        } else {
            STATS_LOCK();
            stats.malloc_fails++;
            STATS_UNLOCK();
            rv = false;
        }
    }

    return rv;
}",52,,1358,3,,void
29831,BLOCK,-1,,"{
        nsize = 1024;
        available = c->stats.size = c->stats.offset = 0;
    }",34,,1364,2,,void
29854,BLOCK,-1,,"{
        assert(nsize > 0);
        nsize = nsize << 1;
        available = nsize - c->stats.offset;
    }",32,,1369,2,,void
29881,BLOCK,-1,,"{
        char *ptr = realloc(c->stats.buffer, nsize);
        if (ptr) {
            c->stats.buffer = ptr;
            c->stats.size = nsize;
        } else {
            STATS_LOCK();
            stats.malloc_fails++;
            STATS_UNLOCK();
            rv = false;
        }
    }",33,,1375,2,,void
29894,BLOCK,-1,,"{
            c->stats.buffer = ptr;
            c->stats.size = nsize;
        }",18,,1377,2,,void
29910,BLOCK,-1,,"{
            STATS_LOCK();
            stats.malloc_fails++;
            STATS_UNLOCK();
            rv = false;
        }",16,,1380,1,,void
29930,BLOCK,-1,,"{
    /* value without a key is invalid */
    if (klen == 0 && vlen > 0) {
        return;
    }

    conn *c = (conn*)cookie;

    if (c->protocol == binary_prot) {
        size_t needed = vlen + klen + sizeof(protocol_binary_response_header);
        if (!grow_stats_buf(c, needed)) {
            return;
        }
        append_bin_stats(key, klen, val, vlen, c);
    } else {
        size_t needed = vlen + klen + 10; // 10 == ""STAT = \r\n""
        if (!grow_stats_buf(c, needed)) {
            return;
        }
        append_ascii_stats(key, klen, val, vlen, c);
    }

    assert(c->stats.offset <= c->stats.size);
}",1,,1394,6,,void
29939,BLOCK,-1,,"{
        return;
    }",32,,1396,2,,void
29953,BLOCK,-1,,"{
        size_t needed = vlen + klen + sizeof(protocol_binary_response_header);
        if (!grow_stats_buf(c, needed)) {
            return;
        }
        append_bin_stats(key, klen, val, vlen, c);
    }",37,,1402,2,,void
29968,BLOCK,-1,,"{
            return;
        }",41,,1404,2,,void
29977,BLOCK,-1,,"{
        size_t needed = vlen + klen + 10; // 10 == ""STAT = \r\n""
        if (!grow_stats_buf(c, needed)) {
            return;
        }
        append_ascii_stats(key, klen, val, vlen, c);
    }",12,,1408,1,,void
29991,BLOCK,-1,,"{
            return;
        }",41,,1410,2,,void
30015,BLOCK,-1,,"{
    c->cmd = -1;
    c->substate = bin_no_state;
    if (c->item != NULL) {
        // TODO: Any other way to get here?
        // SASL auth was mistakenly using it. Nothing else should?
        if (c->item_malloced) {
            free(c->item);
            c->item_malloced = false;
        } else {
            item_remove(c->item);
        }
        c->item = NULL;
    }
    if (c->rbytes > 0) {
        conn_set_state(c, conn_parse_cmd);
    } else if (c->resp_head) {
        conn_set_state(c, conn_mwrite);
    } else {
        conn_set_state(c, conn_waiting);
    }
}",40,,1419,2,,void
30033,BLOCK,-1,,"{
        // TODO: Any other way to get here?
        // SASL auth was mistakenly using it. Nothing else should?
        if (c->item_malloced) {
            free(c->item);
            c->item_malloced = false;
        } else {
            item_remove(c->item);
        }
        c->item = NULL;
    }",26,,1422,2,,void
30038,BLOCK,-1,,"{
            free(c->item);
            c->item_malloced = false;
        }",31,,1425,2,,void
30049,BLOCK,-1,,"{
            item_remove(c->item);
        }",16,,1428,1,,void
30065,BLOCK,-1,,"{
        conn_set_state(c, conn_parse_cmd);
    }",24,,1433,2,,void
30070,BLOCK,-1,,<empty>,12,,1435,1,,void
30075,BLOCK,-1,,"{
        conn_set_state(c, conn_mwrite);
    }",30,,1435,2,,void
30080,BLOCK,-1,,"{
        conn_set_state(c, conn_waiting);
    }",12,,1437,1,,void
30088,BLOCK,-1,,"{
    assert(c != NULL);
#ifdef PROXY
    assert(c->protocol == ascii_prot
           || c->protocol == binary_prot
           || c->protocol == proxy_prot);
#else
    assert(c->protocol == ascii_prot
           || c->protocol == binary_prot);
#endif
    if (c->protocol == ascii_prot) {
        complete_nread_ascii(c);
    } else if (c->protocol == binary_prot) {
        complete_nread_binary(c);
#ifdef PROXY
    } else if (c->protocol == proxy_prot) {
        complete_nread_proxy(c);
#endif
    }
}",37,,1442,2,,void
30111,BLOCK,-1,,"{
        complete_nread_ascii(c);
    }",36,,1452,2,,void
30115,BLOCK,-1,,<empty>,12,,1454,1,,void
30122,BLOCK,-1,,"{
        complete_nread_binary(c);
#ifdef PROXY
    } else if (c->protocol == proxy_prot) {
        complete_nread_proxy(c);
#endif
    }",44,,1454,2,,void
30131,BLOCK,-1,,"{
    item_chunk *dch = (item_chunk *) ITEM_schunk(d_it);
    /* Advance dch until we find free space */
    while (dch->size == dch->used) {
        if (dch->next) {
            dch = dch->next;
        } else {
            break;
        }
    }

    if (s_it->it_flags & ITEM_CHUNKED) {
        int remain = len;
        item_chunk *sch = (item_chunk *) ITEM_schunk(s_it);
        int copied = 0;
        /* Fills dch's to capacity, not straight copy sch in case data is
         * being added or removed (ie append/prepend)
         */
        while (sch && dch && remain) {
            assert(dch->used <= dch->size);
            int todo = (dch->size - dch->used < sch->used - copied)
                ? dch->size - dch->used : sch->used - copied;
            if (remain < todo)
                todo = remain;
            memcpy(dch->data + dch->used, sch->data + copied, todo);
            dch->used += todo;
            copied += todo;
            remain -= todo;
            assert(dch->us...",75,,1465,4,,void
30139,BLOCK,1,,<empty>,,,,2,,void
30180,BLOCK,-1,,"{
        if (dch->next) {
            dch = dch->next;
        } else {
            break;
        }
    }",36,,1468,2,,void
30185,BLOCK,-1,,"{
            dch = dch->next;
        }",24,,1469,2,,void
30192,BLOCK,-1,,"{
            break;
        }",16,,1471,1,,void
30200,BLOCK,1,,<empty>,,,,1,,void
30202,BLOCK,-1,,"{
        int remain = len;
        item_chunk *sch = (item_chunk *) ITEM_schunk(s_it);
        int copied = 0;
        /* Fills dch's to capacity, not straight copy sch in case data is
         * being added or removed (ie append/prepend)
         */
        while (sch && dch && remain) {
            assert(dch->used <= dch->size);
            int todo = (dch->size - dch->used < sch->used - copied)
                ? dch->size - dch->used : sch->used - copied;
            if (remain < todo)
                todo = remain;
            memcpy(dch->data + dch->used, sch->data + copied, todo);
            dch->used += todo;
            copied += todo;
            remain -= todo;
            assert(dch->used <= dch->size);
            if (dch->size == dch->used) {
                item_chunk *tch = do_item_alloc_chunk(dch, remain);
                if (tch) {
                    dch = tch;
                } else {
                    return -1;
                }
            }
            as...",40,,1476,2,,void
30214,BLOCK,1,,<empty>,,,,2,,void
30257,BLOCK,-1,,"{
            assert(dch->used <= dch->size);
            int todo = (dch->size - dch->used < sch->used - copied)
                ? dch->size - dch->used : sch->used - copied;
            if (remain < todo)
                todo = remain;
            memcpy(dch->data + dch->used, sch->data + copied, todo);
            dch->used += todo;
            copied += todo;
            remain -= todo;
            assert(dch->used <= dch->size);
            if (dch->size == dch->used) {
                item_chunk *tch = do_item_alloc_chunk(dch, remain);
                if (tch) {
                    dch = tch;
                } else {
                    return -1;
                }
            }
            assert(copied <= sch->used);
            if (copied == sch->used) {
                copied = 0;
                sch = sch->next;
            }
        }",38,,1483,2,,void
30299,BLOCK,-1,,<empty>,17,,1488,2,,void
30344,BLOCK,-1,,"{
                item_chunk *tch = do_item_alloc_chunk(dch, remain);
                if (tch) {
                    dch = tch;
                } else {
                    return -1;
                }
            }",41,,1494,2,,void
30353,BLOCK,-1,,"{
                    dch = tch;
                }",26,,1496,2,,void
30358,BLOCK,-1,,"{
                    return -1;
                }",24,,1498,1,,void
30374,BLOCK,-1,,"{
                copied = 0;
                sch = sch->next;
            }",38,,1503,2,,void
30388,BLOCK,-1,,"{
        int done = 0;
        /* Fill dch's via a non-chunked item. */
        while (len > done && dch) {
            int todo = (dch->size - dch->used < len - done)
                ? dch->size - dch->used : len - done;
            //assert(dch->size - dch->used != 0);
            memcpy(dch->data + dch->used, ITEM_data(s_it) + done, todo);
            done += todo;
            dch->used += todo;
            assert(dch->used <= dch->size);
            if (dch->size == dch->used) {
                item_chunk *tch = do_item_alloc_chunk(dch, len - done);
                if (tch) {
                    dch = tch;
                } else {
                    return -1;
                }
            }
        }
        assert(len == done);
    }",12,,1510,1,,void
30399,BLOCK,-1,,"{
            int todo = (dch->size - dch->used < len - done)
                ? dch->size - dch->used : len - done;
            //assert(dch->size - dch->used != 0);
            memcpy(dch->data + dch->used, ITEM_data(s_it) + done, todo);
            done += todo;
            dch->used += todo;
            assert(dch->used <= dch->size);
            if (dch->size == dch->used) {
                item_chunk *tch = do_item_alloc_chunk(dch, len - done);
                if (tch) {
                    dch = tch;
                } else {
                    return -1;
                }
            }
        }",35,,1513,2,,void
30436,BLOCK,1,,<empty>,,,,2,,void
30495,BLOCK,-1,,"{
                item_chunk *tch = do_item_alloc_chunk(dch, len - done);
                if (tch) {
                    dch = tch;
                } else {
                    return -1;
                }
            }",41,,1521,2,,void
30506,BLOCK,-1,,"{
                    dch = tch;
                }",26,,1523,2,,void
30511,BLOCK,-1,,"{
                    return -1;
                }",24,,1525,1,,void
30528,BLOCK,-1,,"{
    if (comm == NREAD_APPEND) {
        if (new_it->it_flags & ITEM_CHUNKED) {
            if (_store_item_copy_chunks(new_it, old_it, old_it->nbytes - 2) == -1 ||
                _store_item_copy_chunks(new_it, add_it, add_it->nbytes) == -1) {
                return -1;
            }
        } else {
            memcpy(ITEM_data(new_it), ITEM_data(old_it), old_it->nbytes);
            memcpy(ITEM_data(new_it) + old_it->nbytes - 2 /* CRLF */, ITEM_data(add_it), add_it->nbytes);
        }
    } else {
        /* NREAD_PREPEND */
        if (new_it->it_flags & ITEM_CHUNKED) {
            if (_store_item_copy_chunks(new_it, add_it, add_it->nbytes - 2) == -1 ||
                _store_item_copy_chunks(new_it, old_it, old_it->nbytes) == -1) {
                return -1;
            }
        } else {
            memcpy(ITEM_data(new_it), ITEM_data(add_it), add_it->nbytes);
            memcpy(ITEM_data(new_it) + add_it->nbytes - 2 /* CRLF */, ITEM_data(old_it), old_it->nbytes);
        }
...",86,,1535,5,,void
30533,BLOCK,1,,<empty>,,,,1,,void
30535,BLOCK,-1,,"{
        if (new_it->it_flags & ITEM_CHUNKED) {
            if (_store_item_copy_chunks(new_it, old_it, old_it->nbytes - 2) == -1 ||
                _store_item_copy_chunks(new_it, add_it, add_it->nbytes) == -1) {
                return -1;
            }
        } else {
            memcpy(ITEM_data(new_it), ITEM_data(old_it), old_it->nbytes);
            memcpy(ITEM_data(new_it) + old_it->nbytes - 2 /* CRLF */, ITEM_data(add_it), add_it->nbytes);
        }
    }",31,,1536,2,,void
30542,BLOCK,1,,<empty>,,,,1,,void
30544,BLOCK,-1,,"{
            if (_store_item_copy_chunks(new_it, old_it, old_it->nbytes - 2) == -1 ||
                _store_item_copy_chunks(new_it, add_it, add_it->nbytes) == -1) {
                return -1;
            }
        }",46,,1537,2,,void
30567,BLOCK,-1,,"{
                return -1;
            }",80,,1539,2,,void
30572,BLOCK,-1,,"{
            memcpy(ITEM_data(new_it), ITEM_data(old_it), old_it->nbytes);
            memcpy(ITEM_data(new_it) + old_it->nbytes - 2 /* CRLF */, ITEM_data(add_it), add_it->nbytes);
        }",16,,1542,1,,void
30576,BLOCK,1,,<empty>,,,,2,,void
30611,BLOCK,1,,<empty>,,,,2,,void
30652,BLOCK,1,,<empty>,,,,2,,void
30691,BLOCK,1,,<empty>,,,,2,,void
30728,BLOCK,-1,,"{
        /* NREAD_PREPEND */
        if (new_it->it_flags & ITEM_CHUNKED) {
            if (_store_item_copy_chunks(new_it, add_it, add_it->nbytes - 2) == -1 ||
                _store_item_copy_chunks(new_it, old_it, old_it->nbytes) == -1) {
                return -1;
            }
        } else {
            memcpy(ITEM_data(new_it), ITEM_data(add_it), add_it->nbytes);
            memcpy(ITEM_data(new_it) + add_it->nbytes - 2 /* CRLF */, ITEM_data(old_it), old_it->nbytes);
        }
    }",12,,1546,1,,void
30735,BLOCK,1,,<empty>,,,,1,,void
30737,BLOCK,-1,,"{
            if (_store_item_copy_chunks(new_it, add_it, add_it->nbytes - 2) == -1 ||
                _store_item_copy_chunks(new_it, old_it, old_it->nbytes) == -1) {
                return -1;
            }
        }",46,,1548,2,,void
30760,BLOCK,-1,,"{
                return -1;
            }",80,,1550,2,,void
30765,BLOCK,-1,,"{
            memcpy(ITEM_data(new_it), ITEM_data(add_it), add_it->nbytes);
            memcpy(ITEM_data(new_it) + add_it->nbytes - 2 /* CRLF */, ITEM_data(old_it), old_it->nbytes);
        }",16,,1553,1,,void
30769,BLOCK,1,,<empty>,,,,2,,void
30804,BLOCK,1,,<empty>,,,,2,,void
30845,BLOCK,1,,<empty>,,,,2,,void
30884,BLOCK,1,,<empty>,,,,2,,void
30929,BLOCK,-1,,"{
    char *key = ITEM_key(it);
    item *old_it = do_item_get(key, it->nkey, hv, c, DONT_UPDATE);
    enum store_item_type stored = NOT_STORED;

    enum cas_result { CAS_NONE, CAS_MATCH, CAS_BADVAL, CAS_STALE, CAS_MISS };

    item *new_it = NULL;
    uint32_t flags;

    /* Do the CAS test up front so we can apply to all store modes */
    enum cas_result cas_res = CAS_NONE;

    bool do_store = false;
    if (old_it != NULL) {
        // Most of the CAS work requires something to compare to.
        uint64_t it_cas = ITEM_get_cas(it);
        uint64_t old_cas = ITEM_get_cas(old_it);
        if (it_cas == 0) {
            cas_res = CAS_NONE;
        } else if (it_cas == old_cas) {
            cas_res = CAS_MATCH;
        } else if (c->set_stale && it_cas < old_cas) {
            cas_res = CAS_STALE;
        } else {
            cas_res = CAS_BADVAL;
        }

        switch (comm) {
            case NREAD_ADD:
                /* add only adds a nonexistent item, but promote to h...",84,,1567,5,,void
30935,BLOCK,1,,<empty>,,,,2,,void
30963,BLOCK,1,,<empty>,,,,1,,void
30986,BLOCK,-1,,"{
        // Most of the CAS work requires something to compare to.
        uint64_t it_cas = ITEM_get_cas(it);
        uint64_t old_cas = ITEM_get_cas(old_it);
        if (it_cas == 0) {
            cas_res = CAS_NONE;
        } else if (it_cas == old_cas) {
            cas_res = CAS_MATCH;
        } else if (c->set_stale && it_cas < old_cas) {
            cas_res = CAS_STALE;
        } else {
            cas_res = CAS_BADVAL;
        }

        switch (comm) {
            case NREAD_ADD:
                /* add only adds a nonexistent item, but promote to head of LRU */
                do_item_update(old_it);
                break;
            case NREAD_CAS:
                if (cas_res == CAS_MATCH) {
                    // cas validates
                    // it and old_it may belong to different classes.
                    // I'm updating the stats for the one that's getting pushed out
                    pthread_mutex_lock(&c->thread->stats.mutex);
                    c->threa...",25,,1581,2,,void
30992,BLOCK,1,,<empty>,,,,2,,void
31012,BLOCK,1,,<empty>,,,,4,,void
31031,BLOCK,-1,,"{
            cas_res = CAS_NONE;
        }",26,,1585,2,,void
31036,BLOCK,-1,,<empty>,16,,1587,1,,void
31041,BLOCK,-1,,"{
            cas_res = CAS_MATCH;
        }",39,,1587,2,,void
31046,BLOCK,-1,,<empty>,16,,1589,1,,void
31055,BLOCK,-1,,"{
            cas_res = CAS_STALE;
        }",54,,1589,2,,void
31060,BLOCK,-1,,"{
            cas_res = CAS_BADVAL;
        }",16,,1591,1,,void
31066,BLOCK,-1,,"{
            case NREAD_ADD:
                /* add only adds a nonexistent item, but promote to head of LRU */
                do_item_update(old_it);
                break;
            case NREAD_CAS:
                if (cas_res == CAS_MATCH) {
                    // cas validates
                    // it and old_it may belong to different classes.
                    // I'm updating the stats for the one that's getting pushed out
                    pthread_mutex_lock(&c->thread->stats.mutex);
                    c->thread->stats.slab_stats[ITEM_clsid(old_it)].cas_hits++;
                    pthread_mutex_unlock(&c->thread->stats.mutex);
                    do_store = true;
                } else if (cas_res == CAS_STALE) {
                    // if we're allowed to set a stale value, CAS must be lower than
                    // the current item's CAS.
                    // This replaces the value, but should preserve TTL, and stale
                    // item marker bit + to...",23,,1595,2,,void
31069,BLOCK,1,,<empty>,,,,1,,void
31076,BLOCK,1,,<empty>,,,,1,,void
31082,BLOCK,-1,,"{
                    // cas validates
                    // it and old_it may belong to different classes.
                    // I'm updating the stats for the one that's getting pushed out
                    pthread_mutex_lock(&c->thread->stats.mutex);
                    c->thread->stats.slab_stats[ITEM_clsid(old_it)].cas_hits++;
                    pthread_mutex_unlock(&c->thread->stats.mutex);
                    do_store = true;
                }",43,,1601,2,,void
31104,BLOCK,1,,<empty>,,,,3,,void
31127,BLOCK,-1,,<empty>,24,,1609,1,,void
31132,BLOCK,-1,,"{
                    // if we're allowed to set a stale value, CAS must be lower than
                    // the current item's CAS.
                    // This replaces the value, but should preserve TTL, and stale
                    // item marker bit + token sent if exists.
                    it->exptime = old_it->exptime;
                    it->it_flags |= ITEM_STALE;
                    if (old_it->it_flags & ITEM_TOKEN_SENT) {
                        it->it_flags |= ITEM_TOKEN_SENT;
                    }

                    pthread_mutex_lock(&c->thread->stats.mutex);
                    c->thread->stats.slab_stats[ITEM_clsid(old_it)].cas_hits++;
                    pthread_mutex_unlock(&c->thread->stats.mutex);
                    do_store = true;
                }",50,,1609,2,,void
31145,BLOCK,1,,<empty>,,,,1,,void
31153,BLOCK,1,,<empty>,,,,1,,void
31155,BLOCK,-1,,"{
                        it->it_flags |= ITEM_TOKEN_SENT;
                    }",61,,1616,2,,void
31161,BLOCK,1,,<empty>,,,,1,,void
31184,BLOCK,1,,<empty>,,,,3,,void
31207,BLOCK,-1,,"{
                    // NONE or BADVAL are the same for CAS cmd
                    pthread_mutex_lock(&c->thread->stats.mutex);
                    c->thread->stats.slab_stats[ITEM_clsid(old_it)].cas_badval++;
                    pthread_mutex_unlock(&c->thread->stats.mutex);

                    if (settings.verbose > 1) {
                        fprintf(stderr, ""CAS:  failure: expected %llu, got %llu\n"",
                                (unsigned long long)ITEM_get_cas(old_it),
                                (unsigned long long)ITEM_get_cas(it));
                    }
                    stored = EXISTS;
                }",24,,1624,1,,void
31229,BLOCK,1,,<empty>,,,,3,,void
31254,BLOCK,-1,,"{
                        fprintf(stderr, ""CAS:  failure: expected %llu, got %llu\n"",
                                (unsigned long long)ITEM_get_cas(old_it),
                                (unsigned long long)ITEM_get_cas(it));
                    }",47,,1630,2,,void
31262,BLOCK,1,,<empty>,,,,4,,void
31281,BLOCK,1,,<empty>,,,,2,,void
31302,BLOCK,1,,<empty>,,,,1,,void
31306,BLOCK,1,,<empty>,,,,1,,void
31316,BLOCK,-1,,"{
                    stored = EXISTS;
                    break;
                }",66,,1640,2,,void
31324,BLOCK,1,,"FLAGS_CONV(old_it, flags)",17,,1652,14,,void
31331,BLOCK,-1,,"FLAGS_CONV(old_it, flags)",17,,1652,2,,void
31360,BLOCK,-1,,"FLAGS_CONV(old_it, flags)",17,,1652,1,,void
31388,BLOCK,-1,,<empty>,21,,1657,2,,void
31399,BLOCK,-1,,"{
                    // failed data copy
                    break;
                }",76,,1659,2,,void
31402,BLOCK,-1,,"{
                    // refcount of new_it is 1 here. will end up 2 after link.
                    // it's original ref is managed outside of this function
                    it = new_it;
                    do_store = true;
                }",24,,1662,1,,void
31412,BLOCK,1,,<empty>,,,,1,,void
31416,BLOCK,1,,<empty>,,,,1,,void
31424,BLOCK,-1,,"{
            STORAGE_delete(c->thread->storage, old_it);
            item_replace(old_it, it, hv);
            stored = STORED;
        }",23,,1675,2,,void
31438,BLOCK,-1,,"{
            // append/prepend end up with an extra reference for new_it.
            do_item_remove(new_it);
        }",29,,1682,2,,void
31442,BLOCK,-1,,"{
        /* No pre-existing item to replace or compare to. */
        if (ITEM_get_cas(it) != 0) {
            /* Asked for a CAS match but nothing to compare it to. */
            cas_res = CAS_MISS;
        }

        switch (comm) {
            case NREAD_ADD:
            case NREAD_SET:
                do_store = true;
                break;
            case NREAD_CAS:
                // LRU expired
                stored = NOT_FOUND;
                pthread_mutex_lock(&c->thread->stats.mutex);
                c->thread->stats.cas_misses++;
                pthread_mutex_unlock(&c->thread->stats.mutex);
                break;
            case NREAD_REPLACE:
            case NREAD_APPEND:
            case NREAD_PREPEND:
                /* Requires an existing item. */
                break;
        }

        if (do_store) {
            do_item_link(it, hv);
            stored = STORED;
        }
    }",12,,1686,1,,void
31447,BLOCK,1,,<empty>,,,,2,,void
31463,BLOCK,-1,,"{
            /* Asked for a CAS match but nothing to compare it to. */
            cas_res = CAS_MISS;
        }",36,,1688,2,,void
31469,BLOCK,-1,,"{
            case NREAD_ADD:
            case NREAD_SET:
                do_store = true;
                break;
            case NREAD_CAS:
                // LRU expired
                stored = NOT_FOUND;
                pthread_mutex_lock(&c->thread->stats.mutex);
                c->thread->stats.cas_misses++;
                pthread_mutex_unlock(&c->thread->stats.mutex);
                break;
            case NREAD_REPLACE:
            case NREAD_APPEND:
            case NREAD_PREPEND:
                /* Requires an existing item. */
                break;
        }",23,,1693,2,,void
31472,BLOCK,1,,<empty>,,,,1,,void
31476,BLOCK,1,,<empty>,,,,1,,void
31484,BLOCK,1,,<empty>,,,,1,,void
31518,BLOCK,1,,<empty>,,,,1,,void
31522,BLOCK,1,,<empty>,,,,1,,void
31526,BLOCK,1,,<empty>,,,,1,,void
31531,BLOCK,-1,,"{
            do_item_link(it, hv);
            stored = STORED;
        }",23,,1712,2,,void
31542,BLOCK,-1,,"{
        c->cas = ITEM_get_cas(it);
    }",27,,1718,2,,void
31549,BLOCK,1,,<empty>,,,,2,,void
31572,BLOCK,1,,<empty>,,,,7,,void
31574,BLOCK,-1,,"LOGGER_LOG(c->thread->l, LOG_MUTATIONS, LOGGER_ITEM_STORE, NULL,
            stored, comm, ITEM_key(it), it->nkey, it->nbytes, it->exptime,
            ITEM_clsid(it), c->sfd)",5,,1721,1,,void
31591,BLOCK,-1,,<empty>,5,,1721,2,,void
31606,BLOCK,-1,,<empty>,5,,1721,2,,void
31658,BLOCK,-1,,"{
    if (buf) {
        mc_resp *resp = c->resp;
        resp->write_and_free = buf;
        resp_add_iov(resp, buf, bytes);
        conn_set_state(c, conn_new_cmd);
    } else {
        out_of_memory(c, ""SERVER_ERROR out of memory writing stats"");
    }
}",52,,1729,4,,void
31661,BLOCK,-1,,"{
        mc_resp *resp = c->resp;
        resp->write_and_free = buf;
        resp_add_iov(resp, buf, bytes);
        conn_set_state(c, conn_new_cmd);
    }",14,,1730,2,,void
31681,BLOCK,-1,,"{
        out_of_memory(c, ""SERVER_ERROR out of memory writing stats"");
    }",12,,1735,1,,void
31692,BLOCK,-1,,"{
    char val_str[STAT_VAL_LEN];
    int vlen;
    va_list ap;

    assert(name);
    assert(add_stats);
    assert(c);
    assert(fmt);

    va_start(ap, fmt);
    vlen = vsnprintf(val_str, sizeof(val_str) - 1, fmt, ap);
    va_end(ap);

    add_stats(name, strlen(name), val_str, vlen, c);
}",40,,1741,5,,void
31731,BLOCK,-1,,"{
    pid_t pid = getpid();
    rel_time_t now = current_time;

    struct thread_stats thread_stats;
    threadlocal_stats_aggregate(&thread_stats);
    struct slab_stats slab_stats;
    slab_stats_aggregate(&thread_stats, &slab_stats);
#ifndef WIN32
    struct rusage usage;
    getrusage(RUSAGE_SELF, &usage);
#endif /* !WIN32 */

    STATS_LOCK();

    APPEND_STAT(""pid"", ""%lu"", (long)pid);
    APPEND_STAT(""uptime"", ""%u"", now - ITEM_UPDATE_INTERVAL);
    APPEND_STAT(""time"", ""%ld"", now + (long)process_started);
    APPEND_STAT(""version"", ""%s"", VERSION);
    APPEND_STAT(""libevent"", ""%s"", event_get_version());
    APPEND_STAT(""pointer_size"", ""%d"", (int)(8 * sizeof(void *)));

#ifndef WIN32
    append_stat(""rusage_user"", add_stats, c, ""%ld.%06ld"",
                (long)usage.ru_utime.tv_sec,
                (long)usage.ru_utime.tv_usec);
    append_stat(""rusage_system"", add_stats, c, ""%ld.%06ld"",
                (long)usage.ru_stime.tv_sec,
                (long)usage.ru_stime.tv_usec)...",48,,1759,3,,void
31762,BLOCK,1,,<empty>,,,,5,,void
31774,BLOCK,1,,<empty>,,,,4,,void
31786,BLOCK,1,,<empty>,,,,5,,void
31801,BLOCK,1,,<empty>,,,,4,,void
31812,BLOCK,1,,<empty>,,,,4,,void
31822,BLOCK,1,,<empty>,,,,3,,void
31878,BLOCK,1,,<empty>,,,,5,,void
31890,BLOCK,1,,<empty>,,,,4,,void
31906,BLOCK,1,,<empty>,,,,4,,void
31921,BLOCK,-1,,"{
        APPEND_STAT(""rejected_connections"", ""%llu"", (unsigned long long)stats.rejected_conns);
    }",33,,1793,2,,void
31925,BLOCK,1,,<empty>,,,,4,,void
31942,BLOCK,1,,<empty>,,,,5,,void
31954,BLOCK,1,,<empty>,,,,4,,void
31968,BLOCK,1,,<empty>,,,,4,,void
31982,BLOCK,1,,<empty>,,,,4,,void
31996,BLOCK,1,,<empty>,,,,4,,void
32010,BLOCK,1,,<empty>,,,,4,,void
32024,BLOCK,1,,<empty>,,,,4,,void
32038,BLOCK,1,,<empty>,,,,4,,void
32055,BLOCK,1,,<empty>,,,,5,,void
32067,BLOCK,1,,<empty>,,,,4,,void
32081,BLOCK,1,,<empty>,,,,4,,void
32095,BLOCK,1,,<empty>,,,,4,,void
32109,BLOCK,1,,<empty>,,,,4,,void
32123,BLOCK,1,,<empty>,,,,4,,void
32137,BLOCK,1,,<empty>,,,,4,,void
32151,BLOCK,1,,<empty>,,,,4,,void
32165,BLOCK,1,,<empty>,,,,4,,void
32179,BLOCK,1,,<empty>,,,,4,,void
32193,BLOCK,1,,<empty>,,,,4,,void
32207,BLOCK,1,,<empty>,,,,4,,void
32221,BLOCK,1,,<empty>,,,,4,,void
32235,BLOCK,1,,<empty>,,,,4,,void
32249,BLOCK,1,,<empty>,,,,4,,void
32263,BLOCK,1,,<empty>,,,,4,,void
32277,BLOCK,1,,<empty>,,,,4,,void
32291,BLOCK,1,,<empty>,,,,4,,void
32305,BLOCK,1,,<empty>,,,,4,,void
32319,BLOCK,1,,<empty>,,,,4,,void
32333,BLOCK,1,,<empty>,,,,4,,void
32347,BLOCK,1,,<empty>,,,,4,,void
32361,BLOCK,1,,<empty>,,,,4,,void
32375,BLOCK,1,,<empty>,,,,4,,void
32389,BLOCK,1,,<empty>,,,,4,,void
32404,BLOCK,-1,,"{
        APPEND_STAT(""idle_kicks"", ""%llu"", (unsigned long long)thread_stats.idle_kicks);
    }",32,,1847,2,,void
32408,BLOCK,1,,<empty>,,,,4,,void
32422,BLOCK,1,,<empty>,,,,4,,void
32436,BLOCK,1,,<empty>,,,,4,,void
32450,BLOCK,1,,<empty>,,,,4,,void
32467,BLOCK,1,,<empty>,,,,5,,void
32479,BLOCK,1,,<empty>,,,,4,,void
32496,BLOCK,1,,<empty>,,,,5,,void
32511,BLOCK,1,,<empty>,,,,5,,void
32523,BLOCK,1,,<empty>,,,,4,,void
32540,BLOCK,1,,<empty>,,,,5,,void
32552,BLOCK,1,,<empty>,,,,4,,void
32569,BLOCK,1,,<empty>,,,,5,,void
32582,BLOCK,-1,,"{
        APPEND_STAT(""slab_reassign_rescues"", ""%llu"", stats.slab_reassign_rescues);
        APPEND_STAT(""slab_reassign_chunk_rescues"", ""%llu"", stats.slab_reassign_chunk_rescues);
        APPEND_STAT(""slab_reassign_evictions_nomem"", ""%llu"", stats.slab_reassign_evictions_nomem);
        APPEND_STAT(""slab_reassign_inline_reclaim"", ""%llu"", stats.slab_reassign_inline_reclaim);
        APPEND_STAT(""slab_reassign_busy_items"", ""%llu"", stats.slab_reassign_busy_items);
        APPEND_STAT(""slab_reassign_busy_deletes"", ""%llu"", stats.slab_reassign_busy_deletes);
        APPEND_STAT(""slab_reassign_running"", ""%u"", stats_state.slab_reassign_running);
        APPEND_STAT(""slabs_moved"", ""%llu"", stats.slabs_moved);
    }",33,,1861,2,,void
32589,BLOCK,1,,<empty>,,,,5,,void
32604,BLOCK,1,,<empty>,,,,5,,void
32619,BLOCK,1,,<empty>,,,,5,,void
32634,BLOCK,1,,<empty>,,,,5,,void
32649,BLOCK,1,,<empty>,,,,5,,void
32664,BLOCK,1,,<empty>,,,,5,,void
32679,BLOCK,1,,<empty>,,,,5,,void
32694,BLOCK,1,,<empty>,,,,5,,void
32707,BLOCK,-1,,"{
        APPEND_STAT(""lru_crawler_running"", ""%u"", stats_state.lru_crawler_running);
        APPEND_STAT(""lru_crawler_starts"", ""%u"", stats.lru_crawler_starts);
    }",31,,1871,2,,void
32714,BLOCK,1,,<empty>,,,,5,,void
32729,BLOCK,1,,<empty>,,,,5,,void
32742,BLOCK,-1,,"{
        APPEND_STAT(""lru_maintainer_juggles"", ""%llu"", (unsigned long long)stats.lru_maintainer_juggles);
    }",41,,1875,2,,void
32746,BLOCK,1,,<empty>,,,,4,,void
32760,BLOCK,1,,<empty>,,,,4,,void
32774,BLOCK,1,,<empty>,,,,4,,void
32788,BLOCK,1,,<empty>,,,,4,,void
32802,BLOCK,1,,<empty>,,,,4,,void
32816,BLOCK,1,,<empty>,,,,4,,void
32830,BLOCK,1,,<empty>,,,,4,,void
32845,BLOCK,1,,<empty>,,,,4,,void
32859,BLOCK,1,,<empty>,,,,4,,void
32875,BLOCK,-1,,"{
    assert(add_stats);
    APPEND_STAT(""maxbytes"", ""%llu"", (unsigned long long)settings.maxbytes);
    APPEND_STAT(""maxconns"", ""%d"", settings.maxconns);
    APPEND_STAT(""tcpport"", ""%d"", settings.port);
    APPEND_STAT(""udpport"", ""%d"", settings.udpport);
    APPEND_STAT(""inter"", ""%s"", settings.inter ? settings.inter : ""NULL"");
    APPEND_STAT(""verbosity"", ""%d"", settings.verbose);
    APPEND_STAT(""oldest"", ""%lu"", (unsigned long)settings.oldest_live);
    APPEND_STAT(""evictions"", ""%s"", settings.evict_to_free ? ""on"" : ""off"");
    APPEND_STAT(""domain_socket"", ""%s"",
                settings.socketpath ? settings.socketpath : ""NULL"");
    APPEND_STAT(""umask"", ""%o"", settings.access);
    APPEND_STAT(""shutdown_command"", ""%s"",
                settings.shutdown_command ? ""yes"" : ""no"");
    APPEND_STAT(""growth_factor"", ""%.2f"", settings.factor);
    APPEND_STAT(""chunk_size"", ""%d"", settings.chunk_size);
    APPEND_STAT(""num_threads"", ""%d"", settings.num_threads);
    APPEND_STAT(""num_threads_per...",57,,1905,3,,void
32881,BLOCK,1,,<empty>,,,,4,,void
32898,BLOCK,1,,<empty>,,,,5,,void
32913,BLOCK,1,,<empty>,,,,5,,void
32928,BLOCK,1,,<empty>,,,,5,,void
32940,BLOCK,1,,<empty>,,,,5,,void
32960,BLOCK,1,,<empty>,,,,5,,void
32972,BLOCK,1,,<empty>,,,,4,,void
32986,BLOCK,1,,<empty>,,,,4,,void
33001,BLOCK,1,,<empty>,,,,5,,void
33021,BLOCK,1,,<empty>,,,,5,,void
33033,BLOCK,1,,<empty>,,,,4,,void
33051,BLOCK,1,,<empty>,,,,5,,void
33066,BLOCK,1,,<empty>,,,,5,,void
33081,BLOCK,1,,<empty>,,,,5,,void
33096,BLOCK,1,,<empty>,,,,5,,void
33111,BLOCK,1,,<empty>,,,,5,,void
33123,BLOCK,1,,<empty>,,,,4,,void
33141,BLOCK,1,,<empty>,,,,5,,void
33153,BLOCK,1,,<empty>,,,,4,,void
33171,BLOCK,1,,<empty>,,,,5,,void
33187,BLOCK,1,,<empty>,,,,5,,void
33200,BLOCK,1,,<empty>,,,,4,,void
33215,BLOCK,1,,<empty>,,,,5,,void
33235,BLOCK,1,,<empty>,,,,5,,void
33247,BLOCK,1,,<empty>,,,,4,,void
33265,BLOCK,1,,<empty>,,,,5,,void
33277,BLOCK,1,,<empty>,,,,4,,void
33295,BLOCK,1,,<empty>,,,,5,,void
33310,BLOCK,1,,<empty>,,,,5,,void
33325,BLOCK,1,,<empty>,,,,5,,void
33340,BLOCK,1,,<empty>,,,,5,,void
33352,BLOCK,1,,<empty>,,,,4,,void
33370,BLOCK,1,,<empty>,,,,5,,void
33382,BLOCK,1,,<empty>,,,,4,,void
33399,BLOCK,1,,<empty>,,,,5,,void
33411,BLOCK,1,,<empty>,,,,4,,void
33426,BLOCK,1,,<empty>,,,,4,,void
33444,BLOCK,1,,<empty>,,,,5,,void
33456,BLOCK,1,,<empty>,,,,4,,void
33471,BLOCK,1,,<empty>,,,,4,,void
33489,BLOCK,1,,<empty>,,,,5,,void
33504,BLOCK,1,,<empty>,,,,5,,void
33519,BLOCK,1,,<empty>,,,,5,,void
33534,BLOCK,1,,<empty>,,,,5,,void
33546,BLOCK,1,,<empty>,,,,4,,void
33564,BLOCK,1,,<empty>,,,,5,,void
33579,BLOCK,1,,<empty>,,,,5,,void
33594,BLOCK,1,,<empty>,,,,5,,void
33609,BLOCK,1,,<empty>,,,,5,,void
33624,BLOCK,1,,<empty>,,,,5,,void
33636,BLOCK,1,,<empty>,,,,3,,void
33650,BLOCK,1,,<empty>,,,,4,,void
33663,BLOCK,1,,<empty>,,,,5,,void
33678,BLOCK,1,,<empty>,,,,5,,void
33693,BLOCK,-1,,"{
    int zlength=strlen(z);
    return (zlength == nzlength) && (strncmp(nz, z, zlength) == 0) ? 0 : -1;
}",67,,2000,4,,void
33721,BLOCK,-1,,"{
    bool ret = true;

    if (add_stats != NULL) {
        if (!stat_type) {
            /* prepare general statistics for the engine */
            STATS_LOCK();
            APPEND_STAT(""bytes"", ""%llu"", (unsigned long long)stats_state.curr_bytes);
            APPEND_STAT(""curr_items"", ""%llu"", (unsigned long long)stats_state.curr_items);
            APPEND_STAT(""total_items"", ""%llu"", (unsigned long long)stats.total_items);
            STATS_UNLOCK();
            APPEND_STAT(""slab_global_page_pool"", ""%u"", global_page_pool_size(NULL));
            item_stats_totals(add_stats, c);
        } else if (nz_strcmp(nkey, stat_type, ""items"") == 0) {
            item_stats(add_stats, c);
        } else if (nz_strcmp(nkey, stat_type, ""slabs"") == 0) {
            slabs_stats(add_stats, c);
        } else if (nz_strcmp(nkey, stat_type, ""sizes"") == 0) {
            item_stats_sizes(add_stats, c);
        } else if (nz_strcmp(nkey, stat_type, ""sizes_enable"") == 0) {
            item_stats_sizes_e...",78,,2005,5,,void
33730,BLOCK,-1,,"{
        if (!stat_type) {
            /* prepare general statistics for the engine */
            STATS_LOCK();
            APPEND_STAT(""bytes"", ""%llu"", (unsigned long long)stats_state.curr_bytes);
            APPEND_STAT(""curr_items"", ""%llu"", (unsigned long long)stats_state.curr_items);
            APPEND_STAT(""total_items"", ""%llu"", (unsigned long long)stats.total_items);
            STATS_UNLOCK();
            APPEND_STAT(""slab_global_page_pool"", ""%u"", global_page_pool_size(NULL));
            item_stats_totals(add_stats, c);
        } else if (nz_strcmp(nkey, stat_type, ""items"") == 0) {
            item_stats(add_stats, c);
        } else if (nz_strcmp(nkey, stat_type, ""slabs"") == 0) {
            slabs_stats(add_stats, c);
        } else if (nz_strcmp(nkey, stat_type, ""sizes"") == 0) {
            item_stats_sizes(add_stats, c);
        } else if (nz_strcmp(nkey, stat_type, ""sizes_enable"") == 0) {
            item_stats_sizes_enable(add_stats, c);
        } else if (nz_strcmp(n...",28,,2008,2,,void
33734,BLOCK,-1,,"{
            /* prepare general statistics for the engine */
            STATS_LOCK();
            APPEND_STAT(""bytes"", ""%llu"", (unsigned long long)stats_state.curr_bytes);
            APPEND_STAT(""curr_items"", ""%llu"", (unsigned long long)stats_state.curr_items);
            APPEND_STAT(""total_items"", ""%llu"", (unsigned long long)stats.total_items);
            STATS_UNLOCK();
            APPEND_STAT(""slab_global_page_pool"", ""%u"", global_page_pool_size(NULL));
            item_stats_totals(add_stats, c);
        }",25,,2009,2,,void
33739,BLOCK,1,,<empty>,,,,4,,void
33753,BLOCK,1,,<empty>,,,,4,,void
33767,BLOCK,1,,<empty>,,,,4,,void
33784,BLOCK,1,,<empty>,,,,4,,void
33796,BLOCK,-1,,<empty>,16,,2018,1,,void
33804,BLOCK,-1,,"{
            item_stats(add_stats, c);
        }",62,,2018,2,,void
33809,BLOCK,-1,,<empty>,16,,2020,1,,void
33817,BLOCK,-1,,"{
            slabs_stats(add_stats, c);
        }",62,,2020,2,,void
33822,BLOCK,-1,,<empty>,16,,2022,1,,void
33830,BLOCK,-1,,"{
            item_stats_sizes(add_stats, c);
        }",62,,2022,2,,void
33835,BLOCK,-1,,<empty>,16,,2024,1,,void
33843,BLOCK,-1,,"{
            item_stats_sizes_enable(add_stats, c);
        }",69,,2024,2,,void
33848,BLOCK,-1,,<empty>,16,,2026,1,,void
33856,BLOCK,-1,,"{
            item_stats_sizes_disable(add_stats, c);
        }",70,,2026,2,,void
33861,BLOCK,-1,,"{
            ret = false;
        }",16,,2028,1,,void
33866,BLOCK,-1,,"{
        ret = false;
    }",12,,2031,1,,void
33879,BLOCK,-1,,"{
    char addr_text[MAXPATHLEN];
    addr_text[0] = '\0';
    const char *protoname = ""?"";
    unsigned short port = 0;

    switch (af) {
        case AF_INET:
            (void) inet_ntop(af,
                    &((struct sockaddr_in *)sock_addr)->sin_addr,
                    addr_text,
                    sizeof(addr_text) - 1);
            port = ntohs(((struct sockaddr_in *)sock_addr)->sin_port);
            protoname = IS_UDP(c->transport) ? ""udp"" : ""tcp"";
            break;

        case AF_INET6:
            addr_text[0] = '[';
            addr_text[1] = '\0';
            if (inet_ntop(af,
                    &((struct sockaddr_in6 *)sock_addr)->sin6_addr,
                    addr_text + 1,
                    sizeof(addr_text) - 2)) {
                strncat(addr_text, ""]"", 2);
            }
            port = ntohs(((struct sockaddr_in6 *)sock_addr)->sin6_port);
            protoname = IS_UDP(c->transport) ? ""udp6"" : ""tcp6"";
            break;

#ifndef DISABLE_UNIX_SOCKE...",57,,2039,5,,void
33896,BLOCK,-1,,"{
        case AF_INET:
            (void) inet_ntop(af,
                    &((struct sockaddr_in *)sock_addr)->sin_addr,
                    addr_text,
                    sizeof(addr_text) - 1);
            port = ntohs(((struct sockaddr_in *)sock_addr)->sin_port);
            protoname = IS_UDP(c->transport) ? ""udp"" : ""tcp"";
            break;

        case AF_INET6:
            addr_text[0] = '[';
            addr_text[1] = '\0';
            if (inet_ntop(af,
                    &((struct sockaddr_in6 *)sock_addr)->sin6_addr,
                    addr_text + 1,
                    sizeof(addr_text) - 2)) {
                strncat(addr_text, ""]"", 2);
            }
            port = ntohs(((struct sockaddr_in6 *)sock_addr)->sin6_port);
            protoname = IS_UDP(c->transport) ? ""udp6"" : ""tcp6"";
            break;

#ifndef DISABLE_UNIX_SOCKET
        case AF_UNIX:
        {
            size_t pathlen = 0;
            // this strncpy call originally could piss off an address
  ...",17,,2045,2,,void
33928,BLOCK,1,,<empty>,,,,2,,void
33966,BLOCK,-1,,"{
                strncat(addr_text, ""]"", 2);
            }",45,,2061,2,,void
33985,BLOCK,1,,<empty>,,,,2,,void
33997,BLOCK,17,,"{
            size_t pathlen = 0;
            // this strncpy call originally could piss off an address
            // sanitizer; we supplied the size of the dest buf as a limiter,
            // but optimized versions of strncpy could read past the end of
            // *src while looking for a null terminator. Since buf and
            // sun_path here are both on the stack they could even overlap,
            // which is ""undefined"". In all OSS versions of strncpy I could
            // find this has no effect; it'll still only copy until the first null
            // terminator is found. Thus it's possible to get the OS to
            // examine past the end of sun_path but it's unclear to me if this
            // can cause any actual problem.
            //
            // We need a safe_strncpy util function but I'll punt on figuring
            // that out for now.
            pathlen = sizeof(((struct sockaddr_un *)sock_addr)->sun_path);
            if (MAXPATHLEN <= pathlen...",9,,2070,17,,void
34014,BLOCK,-1,,"{
                pathlen = MAXPATHLEN - 1;
            }",40,,2086,2,,void
34042,BLOCK,-1,,"{
        /* Most likely this is a connected UNIX-domain client which
         * has no peer socket address, but there's no portable way
         * to tell for sure.
         */
        snprintf(addr_text, MAXPATHLEN, ""<AF %d>"", af);
    }",32,,2099,2,,void
34050,BLOCK,-1,,"{
        snprintf(addr, MAXPATHLEN + 11, ""%s:%s:%u"", protoname, addr_text, port);
    }",15,,2107,2,,void
34061,BLOCK,-1,,"{
        snprintf(addr, MAXPATHLEN + 11, ""%s:%s"", protoname, addr_text);
    }",12,,2109,1,,void
34076,BLOCK,-1,,"{
    if (!c) {
        memcpy(addr, ""<null>"", 6);
    } else if (c->state == conn_closed) {
        memcpy(addr, ""<closed>"", 8);
    } else {
        struct sockaddr_in6 local_addr;
        struct sockaddr *sock_addr = (void *)&c->request_addr;

        /* For listen ports and idle UDP ports, show listen address */
        if (c->state == conn_listening ||
                (IS_UDP(c->transport) &&
                 c->state == conn_read)) {
            socklen_t local_addr_len = sizeof(local_addr);

            if (getsockname(c->sfd,
                        (struct sockaddr *)&local_addr,
                        &local_addr_len) == 0) {
                sock_addr = (struct sockaddr *)&local_addr;
            }
        }
        get_conn_text(c, sock_addr->sa_family, addr, sock_addr);

        if (c->state != conn_listening && !(IS_UDP(c->transport) &&
                 c->state == conn_read)) {
            struct sockaddr_storage svr_sock_addr;
            socklen_t svr_addr_len = siz...",68,,2114,4,,void
34080,BLOCK,-1,,"{
        memcpy(addr, ""<null>"", 6);
    }",13,,2115,2,,void
34086,BLOCK,-1,,<empty>,12,,2117,1,,void
34093,BLOCK,-1,,"{
        memcpy(addr, ""<closed>"", 8);
    }",41,,2117,2,,void
34099,BLOCK,-1,,"{
        struct sockaddr_in6 local_addr;
        struct sockaddr *sock_addr = (void *)&c->request_addr;

        /* For listen ports and idle UDP ports, show listen address */
        if (c->state == conn_listening ||
                (IS_UDP(c->transport) &&
                 c->state == conn_read)) {
            socklen_t local_addr_len = sizeof(local_addr);

            if (getsockname(c->sfd,
                        (struct sockaddr *)&local_addr,
                        &local_addr_len) == 0) {
                sock_addr = (struct sockaddr *)&local_addr;
            }
        }
        get_conn_text(c, sock_addr->sa_family, addr, sock_addr);

        if (c->state != conn_listening && !(IS_UDP(c->transport) &&
                 c->state == conn_read)) {
            struct sockaddr_storage svr_sock_addr;
            socklen_t svr_addr_len = sizeof(svr_sock_addr);
            getsockname(c->sfd, (struct sockaddr *)&svr_sock_addr, &svr_addr_len);
            get_conn_text(c, svr_sock_...",12,,2119,1,,void
34122,BLOCK,1,,<empty>,,,,2,,void
34133,BLOCK,-1,,"{
            socklen_t local_addr_len = sizeof(local_addr);

            if (getsockname(c->sfd,
                        (struct sockaddr *)&local_addr,
                        &local_addr_len) == 0) {
                sock_addr = (struct sockaddr *)&local_addr;
            }
        }",42,,2126,2,,void
34152,BLOCK,-1,,"{
                sock_addr = (struct sockaddr *)&local_addr;
            }",48,,2131,2,,void
34179,BLOCK,1,,<empty>,,,,2,,void
34190,BLOCK,-1,,"{
            struct sockaddr_storage svr_sock_addr;
            socklen_t svr_addr_len = sizeof(svr_sock_addr);
            getsockname(c->sfd, (struct sockaddr *)&svr_sock_addr, &svr_addr_len);
            get_conn_text(c, svr_sock_addr.ss_family, svr_addr, (struct sockaddr *)&svr_sock_addr);
        }",42,,2138,2,,void
34222,BLOCK,-1,,"{
    int i;
    char key_str[STAT_KEY_LEN];
    char val_str[STAT_VAL_LEN];
    size_t extras_len = sizeof("":unix:"") + sizeof(""65535"");
    char addr[MAXPATHLEN + extras_len];
    char svr_addr[MAXPATHLEN + extras_len];
    memset(addr, 0, sizeof(addr));
    memset(svr_addr, 0, sizeof(svr_addr));
    int klen = 0, vlen = 0;

    assert(add_stats);

    for (i = 0; i < max_fds; i++) {
        if (conns[i]) {
            /* This is safe to do unlocked because conns are never freed; the
             * worst that'll happen will be a minor inconsistency in the
             * output -- not worth the complexity of the locking that'd be
             * required to prevent it.
             */
            if (IS_UDP(conns[i]->transport)) {
                APPEND_NUM_STAT(i, ""UDP"", ""%s"", ""UDP"");
            }
            if (conns[i]->state != conn_closed) {
                conn_to_str(conns[i], addr, svr_addr);

                APPEND_NUM_STAT(i, ""addr"", ""%s"", addr);
                if (conns...",55,,2147,3,,void
34257,BLOCK,-1,,<empty>,5,,2160,1,,void
34266,BLOCK,4,,"{
        if (conns[i]) {
            /* This is safe to do unlocked because conns are never freed; the
             * worst that'll happen will be a minor inconsistency in the
             * output -- not worth the complexity of the locking that'd be
             * required to prevent it.
             */
            if (IS_UDP(conns[i]->transport)) {
                APPEND_NUM_STAT(i, ""UDP"", ""%s"", ""UDP"");
            }
            if (conns[i]->state != conn_closed) {
                conn_to_str(conns[i], addr, svr_addr);

                APPEND_NUM_STAT(i, ""addr"", ""%s"", addr);
                if (conns[i]->state != conn_listening &&
                    !(IS_UDP(conns[i]->transport) && conns[i]->state == conn_read)) {
                    APPEND_NUM_STAT(i, ""listen_addr"", ""%s"", svr_addr);
                }
                APPEND_NUM_STAT(i, ""state"", ""%s"",
                        state_text(conns[i]->state));
                APPEND_NUM_STAT(i, ""secs_since_last_cmd"", ""%d"",
           ...",35,,2160,4,,void
34271,BLOCK,-1,,"{
            /* This is safe to do unlocked because conns are never freed; the
             * worst that'll happen will be a minor inconsistency in the
             * output -- not worth the complexity of the locking that'd be
             * required to prevent it.
             */
            if (IS_UDP(conns[i]->transport)) {
                APPEND_NUM_STAT(i, ""UDP"", ""%s"", ""UDP"");
            }
            if (conns[i]->state != conn_closed) {
                conn_to_str(conns[i], addr, svr_addr);

                APPEND_NUM_STAT(i, ""addr"", ""%s"", addr);
                if (conns[i]->state != conn_listening &&
                    !(IS_UDP(conns[i]->transport) && conns[i]->state == conn_read)) {
                    APPEND_NUM_STAT(i, ""listen_addr"", ""%s"", svr_addr);
                }
                APPEND_NUM_STAT(i, ""state"", ""%s"",
                        state_text(conns[i]->state));
                APPEND_NUM_STAT(i, ""secs_since_last_cmd"", ""%d"",
                        current_tim...",23,,2161,2,,void
34279,BLOCK,1,,<empty>,,,,4,,void
34287,BLOCK,-1,,"{
                APPEND_NUM_STAT(i, ""UDP"", ""%s"", ""UDP"");
            }",46,,2167,2,,void
34292,BLOCK,1,,<empty>,,,,7,,void
34322,BLOCK,-1,,"{
                conn_to_str(conns[i], addr, svr_addr);

                APPEND_NUM_STAT(i, ""addr"", ""%s"", addr);
                if (conns[i]->state != conn_listening &&
                    !(IS_UDP(conns[i]->transport) && conns[i]->state == conn_read)) {
                    APPEND_NUM_STAT(i, ""listen_addr"", ""%s"", svr_addr);
                }
                APPEND_NUM_STAT(i, ""state"", ""%s"",
                        state_text(conns[i]->state));
                APPEND_NUM_STAT(i, ""secs_since_last_cmd"", ""%d"",
                        current_time - conns[i]->last_cmd_time);
            }",49,,2170,2,,void
34332,BLOCK,1,,<empty>,,,,6,,void
34371,BLOCK,1,,<empty>,,,,4,,void
34386,BLOCK,-1,,"{
                    APPEND_NUM_STAT(i, ""listen_addr"", ""%s"", svr_addr);
                }",85,,2175,2,,void
34390,BLOCK,1,,<empty>,,,,6,,void
34415,BLOCK,1,,<empty>,,,,6,,void
34445,BLOCK,1,,<empty>,,,,6,,void
34483,BLOCK,-1,,"{
    item *it;
    if (should_touch) {
        it = item_touch(key, nkey, exptime, c);
    } else {
        it = item_get(key, nkey, c, do_update);
    }
    if (it && it->refcount > IT_REFCOUNT_LIMIT) {
        item_remove(it);
        it = NULL;
        *overflow = true;
    } else {
        *overflow = false;
    }
    return it;
}",121,,2188,8,,void
34487,BLOCK,-1,,"{
        it = item_touch(key, nkey, exptime, c);
    }",23,,2190,2,,void
34496,BLOCK,-1,,"{
        it = item_get(key, nkey, c, do_update);
    }",12,,2192,1,,void
34512,BLOCK,1,,<empty>,,,,1,,void
34514,BLOCK,-1,,"{
        item_remove(it);
        it = NULL;
        *overflow = true;
    }",49,,2195,2,,void
34525,BLOCK,-1,,"{
        *overflow = false;
    }",12,,2199,1,,void
34541,BLOCK,-1,,"{
    item *it;
    it = item_get_locked(key, nkey, c, do_update, hv);
    if (it && it->refcount > IT_REFCOUNT_LIMIT) {
        do_item_remove(it);
        it = NULL;
        item_unlock(*hv);
        *overflow = true;
    } else {
        *overflow = false;
    }
    return it;
}",105,,2209,7,,void
34559,BLOCK,1,,<empty>,,,,1,,void
34561,BLOCK,-1,,"{
        do_item_remove(it);
        it = NULL;
        item_unlock(*hv);
        *overflow = true;
    }",49,,2212,2,,void
34575,BLOCK,-1,,"{
        *overflow = false;
    }",12,,2217,1,,void
34594,BLOCK,-1,,"{
    char *ptr;
    uint64_t value;
    int res;
    item *it;

    it = do_item_get(key, nkey, hv, c, DONT_UPDATE);
    if (!it) {
        return DELTA_ITEM_NOT_FOUND;
    }

    /* Can't delta zero byte values. 2-byte are the ""\r\n"" */
    /* Also can't delta for chunked items. Too large to be a number */
#ifdef EXTSTORE
    if (it->nbytes <= 2 || (it->it_flags & (ITEM_CHUNKED|ITEM_HDR)) != 0) {
#else
    if (it->nbytes <= 2 || (it->it_flags & (ITEM_CHUNKED)) != 0) {
#endif
        do_item_remove(it);
        return NON_NUMERIC;
    }

    if (cas != NULL && *cas != 0 && ITEM_get_cas(it) != *cas) {
        do_item_remove(it);
        return DELTA_ITEM_CAS_MISMATCH;
    }

    ptr = ITEM_data(it);

    if (!safe_strtoull(ptr, &value)) {
        do_item_remove(it);
        return NON_NUMERIC;
    }

    if (incr) {
        value += delta;
        MEMCACHED_COMMAND_INCR(c->sfd, ITEM_key(it), it->nkey, value);
    } else {
        if(delta > value) {
            value = 0;
        } ...",52,,2238,10,,void
34607,BLOCK,1,,<empty>,,,,1,,void
34612,BLOCK,-1,,"{
        return DELTA_ITEM_NOT_FOUND;
    }",14,,2245,2,,void
34628,BLOCK,1,,<empty>,,,,1,,void
34631,BLOCK,-1,,"{
#endif
        do_item_remove(it);
        return NON_NUMERIC;
    }",66,,2254,2,,void
34649,BLOCK,1,,<empty>,,,,4,,void
34666,BLOCK,-1,,"{
        do_item_remove(it);
        return DELTA_ITEM_CAS_MISMATCH;
    }",63,,2260,2,,void
34675,BLOCK,1,,<empty>,,,,6,,void
34714,BLOCK,-1,,"{
        do_item_remove(it);
        return NON_NUMERIC;
    }",38,,2267,2,,void
34721,BLOCK,-1,,"{
        value += delta;
        MEMCACHED_COMMAND_INCR(c->sfd, ITEM_key(it), it->nkey, value);
    }",15,,2272,2,,void
34726,BLOCK,-1,,"{
        if(delta > value) {
            value = 0;
        } else {
            value -= delta;
        }
        MEMCACHED_COMMAND_DECR(c->sfd, ITEM_key(it), it->nkey, value);
    }",12,,2275,1,,void
34731,BLOCK,-1,,"{
            value = 0;
        }",27,,2276,2,,void
34736,BLOCK,-1,,"{
            value -= delta;
        }",16,,2278,1,,void
34751,BLOCK,-1,,"{
        c->thread->stats.slab_stats[ITEM_clsid(it)].incr_hits++;
    }",15,,2285,2,,void
34764,BLOCK,1,,<empty>,,,,3,,void
34775,BLOCK,-1,,"{
        c->thread->stats.slab_stats[ITEM_clsid(it)].decr_hits++;
    }",12,,2287,1,,void
34788,BLOCK,1,,<empty>,,,,3,,void
34828,BLOCK,-1,,"{ /* replace in-place */
        /* When changing the value without replacing the item, we
           need to update the CAS on the existing item. */
        /* We also need to fiddle it in the sizes tracker in case the tracking
         * was enabled at runtime, since it relies on the CAS value to know
         * whether to remove an item or not. */
        item_stats_sizes_remove(it);
        ITEM_set_cas(it, (settings.use_cas) ? get_cas_id() : 0);
        item_stats_sizes_add(it);
        memcpy(ITEM_data(it), buf, res);
        memset(ITEM_data(it) + res, ' ', it->nbytes - res - 2);
        do_item_update(it);
    }",53,,2297,2,,void
34833,BLOCK,1,,"ITEM_set_cas(it, (settings.use_cas) ? get_cas_id() : 0)",9,,2304,2,,void
34840,BLOCK,-1,,"ITEM_set_cas(it, (settings.use_cas) ? get_cas_id() : 0)",9,,2304,2,,void
34858,BLOCK,1,,<empty>,,,,6,,void
34897,BLOCK,1,,<empty>,,,,6,,void
34942,BLOCK,-1,,<empty>,12,,2309,1,,void
34949,BLOCK,-1,,"{
        item *new_it;
        uint32_t flags;
        FLAGS_CONV(it, flags);
        new_it = do_item_alloc(ITEM_key(it), it->nkey, flags, it->exptime, res + 2);
        if (new_it == 0) {
            do_item_remove(it);
            return EOM;
        }
        memcpy(ITEM_data(new_it), buf, res);
        memcpy(ITEM_data(new_it) + res, ""\r\n"", 2);
        item_replace(it, new_it, hv);
        // Overwrite the older item's CAS with our new CAS since we're
        // returning the CAS of the old item below.
        ITEM_set_cas(it, (settings.use_cas) ? ITEM_get_cas(new_it) : 0);
        do_item_remove(new_it);       /* release our reference */
    }",34,,2309,2,,void
34955,BLOCK,1,,"FLAGS_CONV(it, flags)",9,,2312,3,,void
34962,BLOCK,-1,,"FLAGS_CONV(it, flags)",9,,2312,2,,void
34991,BLOCK,-1,,"FLAGS_CONV(it, flags)",9,,2312,1,,void
35000,BLOCK,1,,<empty>,,,,4,,void
35031,BLOCK,-1,,"{
            do_item_remove(it);
            return EOM;
        }",26,,2314,2,,void
35039,BLOCK,1,,<empty>,,,,6,,void
35078,BLOCK,1,,<empty>,,,,6,,void
35120,BLOCK,1,,"ITEM_set_cas(it, (settings.use_cas) ? ITEM_get_cas(new_it) : 0)",9,,2323,9,,void
35127,BLOCK,-1,,"ITEM_set_cas(it, (settings.use_cas) ? ITEM_get_cas(new_it) : 0)",9,,2323,2,,void
35156,BLOCK,-1,,"{
        /* Should never get here. This means we somehow fetched an unlinked
         * item. TODO: Add a counter? */
        if (settings.verbose) {
            fprintf(stderr, ""Tried to do incr/decr on invalid item\n"");
        }
        if (it->refcount == 1)
            do_item_remove(it);
        return DELTA_ITEM_NOT_FOUND;
    }",12,,2325,1,,void
35161,BLOCK,-1,,"{
            fprintf(stderr, ""Tried to do incr/decr on invalid item\n"");
        }",31,,2328,2,,void
35171,BLOCK,-1,,<empty>,13,,2332,2,,void
35178,BLOCK,-1,,"{
        *cas = ITEM_get_cas(it);    /* swap the incoming CAS value */
    }",14,,2336,2,,void
35184,BLOCK,1,,<empty>,,,,4,,void
35203,BLOCK,-1,,"{
        *it_ret = it;
    }",25,,2339,2,,void
35209,BLOCK,-1,,"{
        do_item_remove(it);         /* release our reference */
    }",12,,2341,1,,void
35218,BLOCK,-1,,"{
    assert(c != NULL);
    assert(c->protocol == negotiating_prot);
    assert(c->rcurr <= (c->rbuf + c->rsize));
    assert(c->rbytes > 0);

    if ((unsigned char)c->rbuf[0] == (unsigned char)PROTOCOL_BINARY_REQ) {
        c->protocol = binary_prot;
        c->try_read_command = try_read_command_binary;
    } else {
        // authentication doesn't work with negotiated protocol.
        c->protocol = ascii_prot;
        c->try_read_command = try_read_command_ascii;
    }

    if (settings.verbose > 1) {
        fprintf(stderr, ""%d: Client using the %s protocol\n"", c->sfd,
                prot_text(c->protocol));
    }

    return c->try_read_command(c);
}",48,,2347,2,,void
35259,BLOCK,-1,,"{
        c->protocol = binary_prot;
        c->try_read_command = try_read_command_binary;
    }",74,,2353,2,,void
35271,BLOCK,-1,,"{
        // authentication doesn't work with negotiated protocol.
        c->protocol = ascii_prot;
        c->try_read_command = try_read_command_ascii;
    }",12,,2356,1,,void
35288,BLOCK,-1,,"{
        fprintf(stderr, ""%d: Client using the %s protocol\n"", c->sfd,
                prot_text(c->protocol));
    }",31,,2362,2,,void
35309,BLOCK,-1,,"{
    assert(c != NULL);
    assert(c->rcurr <= (c->rbuf + c->rsize));
    assert(c->rbytes > 0);

    if ((unsigned char)c->rbuf[0] == (unsigned char)PROTOCOL_BINARY_REQ) {
        c->protocol = binary_prot;
        return try_read_command_binary(c);
    } else {
        c->protocol = ascii_prot;
        return try_read_command_ascii(c);
    }
}",42,,2370,2,,void
35344,BLOCK,-1,,"{
        c->protocol = binary_prot;
        return try_read_command_binary(c);
    }",74,,2375,2,,void
35354,BLOCK,-1,,"{
        c->protocol = ascii_prot;
        return try_read_command_ascii(c);
    }",12,,2378,1,,void
35367,BLOCK,-1,,"{
    int res;

    assert(c != NULL);

    c->request_addr_size = sizeof(c->request_addr);
    res = recvfrom(c->sfd, c->rbuf, c->rsize,
                   0, (struct sockaddr *)&c->request_addr,
                   &c->request_addr_size);
    if (res > 8) {
        unsigned char *buf = (unsigned char *)c->rbuf;
        pthread_mutex_lock(&c->thread->stats.mutex);
        c->thread->stats.bytes_read += res;
        pthread_mutex_unlock(&c->thread->stats.mutex);

        /* Beginning of UDP packet is the request ID; save it. */
        c->request_id = buf[0] * 256 + buf[1];

        /* If this is a multi-packet request, drop it. */
        if (buf[4] != 0 || buf[5] != 1) {
            return READ_NO_DATA_RECEIVED;
        }

        /* Don't care about any of the rest of the header. */
        res -= 8;
        memmove(c->rbuf, c->rbuf + 8, res);

        c->rbytes = res;
        c->rcurr = c->rbuf;
        return READ_DATA_RECEIVED;
    }
    return READ_NO_DATA_RECEIVED;
}",51,,2387,2,,void
35408,BLOCK,-1,,"{
        unsigned char *buf = (unsigned char *)c->rbuf;
        pthread_mutex_lock(&c->thread->stats.mutex);
        c->thread->stats.bytes_read += res;
        pthread_mutex_unlock(&c->thread->stats.mutex);

        /* Beginning of UDP packet is the request ID; save it. */
        c->request_id = buf[0] * 256 + buf[1];

        /* If this is a multi-packet request, drop it. */
        if (buf[4] != 0 || buf[5] != 1) {
            return READ_NO_DATA_RECEIVED;
        }

        /* Don't care about any of the rest of the header. */
        res -= 8;
        memmove(c->rbuf, c->rbuf + 8, res);

        c->rbytes = res;
        c->rcurr = c->rbuf;
        return READ_DATA_RECEIVED;
    }",18,,2396,2,,void
35469,BLOCK,-1,,"{
            return READ_NO_DATA_RECEIVED;
        }",41,,2406,2,,void
35505,BLOCK,-1,,"{
    enum try_read_result gotdata = READ_NO_DATA_RECEIVED;
    int res;
    int num_allocs = 0;
    assert(c != NULL);

    if (c->rcurr != c->rbuf) {
        if (c->rbytes != 0) /* otherwise there's nothing to copy */
            memmove(c->rbuf, c->rcurr, c->rbytes);
        c->rcurr = c->rbuf;
    }

    while (1) {
        // TODO: move to rbuf_* func?
        if (c->rbytes >= c->rsize && c->rbuf_malloced) {
            if (num_allocs == 4) {
                return gotdata;
            }
            ++num_allocs;
            char *new_rbuf = realloc(c->rbuf, c->rsize * 2);
            if (!new_rbuf) {
                STATS_LOCK();
                stats.malloc_fails++;
                STATS_UNLOCK();
                if (settings.verbose > 0) {
                    fprintf(stderr, ""Couldn't realloc input buffer\n"");
                }
                c->rbytes = 0; /* ignore what we read */
                out_of_memory(c, ""SERVER_ERROR out of memory reading request"");
            ...",55,,2433,2,,void
35527,BLOCK,-1,,"{
        if (c->rbytes != 0) /* otherwise there's nothing to copy */
            memmove(c->rbuf, c->rcurr, c->rbytes);
        c->rcurr = c->rbuf;
    }",30,,2439,2,,void
35534,BLOCK,-1,,<empty>,13,,2441,2,,void
35554,BLOCK,-1,,"{
        // TODO: move to rbuf_* func?
        if (c->rbytes >= c->rsize && c->rbuf_malloced) {
            if (num_allocs == 4) {
                return gotdata;
            }
            ++num_allocs;
            char *new_rbuf = realloc(c->rbuf, c->rsize * 2);
            if (!new_rbuf) {
                STATS_LOCK();
                stats.malloc_fails++;
                STATS_UNLOCK();
                if (settings.verbose > 0) {
                    fprintf(stderr, ""Couldn't realloc input buffer\n"");
                }
                c->rbytes = 0; /* ignore what we read */
                out_of_memory(c, ""SERVER_ERROR out of memory reading request"");
                c->close_after_write = true;
                return READ_MEMORY_ERROR;
            }
            c->rcurr = c->rbuf = new_rbuf;
            c->rsize *= 2;
        }

        int avail = c->rsize - c->rbytes;
        res = c->read(c, c->rbuf + c->rbytes, avail);
        if (res > 0) {
            pthread_mutex_lock(...",15,,2445,2,,void
35567,BLOCK,-1,,"{
            if (num_allocs == 4) {
                return gotdata;
            }
            ++num_allocs;
            char *new_rbuf = realloc(c->rbuf, c->rsize * 2);
            if (!new_rbuf) {
                STATS_LOCK();
                stats.malloc_fails++;
                STATS_UNLOCK();
                if (settings.verbose > 0) {
                    fprintf(stderr, ""Couldn't realloc input buffer\n"");
                }
                c->rbytes = 0; /* ignore what we read */
                out_of_memory(c, ""SERVER_ERROR out of memory reading request"");
                c->close_after_write = true;
                return READ_MEMORY_ERROR;
            }
            c->rcurr = c->rbuf = new_rbuf;
            c->rsize *= 2;
        }",56,,2447,2,,void
35572,BLOCK,-1,,"{
                return gotdata;
            }",34,,2448,2,,void
35592,BLOCK,-1,,"{
                STATS_LOCK();
                stats.malloc_fails++;
                STATS_UNLOCK();
                if (settings.verbose > 0) {
                    fprintf(stderr, ""Couldn't realloc input buffer\n"");
                }
                c->rbytes = 0; /* ignore what we read */
                out_of_memory(c, ""SERVER_ERROR out of memory reading request"");
                c->close_after_write = true;
                return READ_MEMORY_ERROR;
            }",28,,2453,2,,void
35605,BLOCK,-1,,"{
                    fprintf(stderr, ""Couldn't realloc input buffer\n"");
                }",43,,2457,2,,void
35667,BLOCK,-1,,"{
            pthread_mutex_lock(&c->thread->stats.mutex);
            c->thread->stats.bytes_read += res;
            pthread_mutex_unlock(&c->thread->stats.mutex);
            gotdata = READ_DATA_RECEIVED;
            c->rbytes += res;
            if (res == avail && c->rbuf_malloced) {
                // Resize rbuf and try a few times if huge ascii multiget.
                continue;
            } else {
                break;
            }
        }",22,,2471,2,,void
35711,BLOCK,-1,,"{
                // Resize rbuf and try a few times if huge ascii multiget.
                continue;
            }",51,,2477,2,,void
35714,BLOCK,-1,,"{
                break;
            }",20,,2480,1,,void
35720,BLOCK,-1,,"{
            c->close_reason = NORMAL_CLOSE;
            return READ_ERROR;
        }",23,,2484,2,,void
35733,BLOCK,-1,,"{
            if (errno == EAGAIN || errno == EWOULDBLOCK) {
                break;
            }
            return READ_ERROR;
        }",24,,2488,2,,void
35742,BLOCK,-1,,"{
                break;
            }",58,,2489,2,,void
35753,BLOCK,-1,,"{
    assert(c != NULL);

    struct event_base *base = c->event.ev_base;
    if (c->ev_flags == new_flags)
        return true;
    if (event_del(&c->event) == -1) return false;
    event_set(&c->event, c->sfd, new_flags, event_handler, (void *)c);
    event_base_set(base, &c->event);
    c->ev_flags = new_flags;
    if (event_add(&c->event, 0) == -1) return false;
    return true;
}",56,,2498,3,,void
35772,BLOCK,-1,,<empty>,9,,2503,2,,void
35784,BLOCK,-1,,<empty>,37,,2504,2,,void
35821,BLOCK,-1,,<empty>,40,,2508,2,,void
35830,BLOCK,-1,,"{
    conn *next;

    for (next = listen_conn; next; next = next->next) {
        if (do_accept) {
            update_event(next, EV_READ | EV_PERSIST);
            if (listen(next->sfd, settings.backlog) != 0) {
                perror(""listen"");
            }
        }
        else {
            update_event(next, 0);
            if (listen(next->sfd, 0) != 0) {
                perror(""listen"");
            }
        }
    }

    if (do_accept) {
        struct timeval maxconns_exited;
        uint64_t elapsed_us;
        gettimeofday(&maxconns_exited,NULL);
        STATS_LOCK();
        elapsed_us =
            (maxconns_exited.tv_sec - stats.maxconns_entered.tv_sec) * 1000000
            + (maxconns_exited.tv_usec - stats.maxconns_entered.tv_usec);
        stats.time_in_listen_disabled_us += elapsed_us;
        stats_state.accepting_conns = true;
        STATS_UNLOCK();
    } else {
        STATS_LOCK();
        stats_state.accepting_conns = false;
        gettimeofday(&stats.ma...",48,,2515,2,,void
35833,BLOCK,-1,,<empty>,5,,2518,1,,void
35843,BLOCK,4,,"{
        if (do_accept) {
            update_event(next, EV_READ | EV_PERSIST);
            if (listen(next->sfd, settings.backlog) != 0) {
                perror(""listen"");
            }
        }
        else {
            update_event(next, 0);
            if (listen(next->sfd, 0) != 0) {
                perror(""listen"");
            }
        }
    }",55,,2518,4,,void
35846,BLOCK,-1,,"{
            update_event(next, EV_READ | EV_PERSIST);
            if (listen(next->sfd, settings.backlog) != 0) {
                perror(""listen"");
            }
        }",24,,2519,2,,void
35862,BLOCK,-1,,"{
                perror(""listen"");
            }",59,,2521,2,,void
35866,BLOCK,-1,,"{
            update_event(next, 0);
            if (listen(next->sfd, 0) != 0) {
                perror(""listen"");
            }
        }",14,,2525,1,,void
35878,BLOCK,-1,,"{
                perror(""listen"");
            }",44,,2527,2,,void
35883,BLOCK,-1,,"{
        struct timeval maxconns_exited;
        uint64_t elapsed_us;
        gettimeofday(&maxconns_exited,NULL);
        STATS_LOCK();
        elapsed_us =
            (maxconns_exited.tv_sec - stats.maxconns_entered.tv_sec) * 1000000
            + (maxconns_exited.tv_usec - stats.maxconns_entered.tv_usec);
        stats.time_in_listen_disabled_us += elapsed_us;
        stats_state.accepting_conns = true;
        STATS_UNLOCK();
    }",20,,2533,2,,void
35926,BLOCK,-1,,"{
        STATS_LOCK();
        stats_state.accepting_conns = false;
        gettimeofday(&stats.maxconns_entered,NULL);
        stats.listen_disabled_num++;
        STATS_UNLOCK();
        allow_new_conns = false;
        maxconns_handler(-42, 0, 0);
    }",12,,2544,1,,void
35959,BLOCK,-1,,"{
    mc_resp *resp = c->resp_head;
    while (resp && iovused + resp->iovcnt < IOV_MAX-1) {
        if (resp->skip) {
            // Don't actually unchain the resp obj here since it's singly-linked.
            // Just let the post function handle it linearly.
            resp = resp->next;
            continue;
        }
        if (resp->chunked_data_iov) {
            // Handle chunked items specially.
            // They spend much more time in send so we can be a bit wasteful
            // in rebuilding iovecs for them.
            item_chunk *ch = (item_chunk *)ITEM_schunk((item *)resp->iov[resp->chunked_data_iov].iov_base);
            int x;
            for (x = 0; x < resp->iovcnt; x++) {
                // This iov is tracking how far we've copied so far.
                if (x == resp->chunked_data_iov) {
                    int done = resp->chunked_total - resp->iov[x].iov_len;
                    // Start from the len to allow binprot to cut the \r\n
                 ...",83,,2557,5,,void
35978,BLOCK,-1,,"{
        if (resp->skip) {
            // Don't actually unchain the resp obj here since it's singly-linked.
            // Just let the post function handle it linearly.
            resp = resp->next;
            continue;
        }
        if (resp->chunked_data_iov) {
            // Handle chunked items specially.
            // They spend much more time in send so we can be a bit wasteful
            // in rebuilding iovecs for them.
            item_chunk *ch = (item_chunk *)ITEM_schunk((item *)resp->iov[resp->chunked_data_iov].iov_base);
            int x;
            for (x = 0; x < resp->iovcnt; x++) {
                // This iov is tracking how far we've copied so far.
                if (x == resp->chunked_data_iov) {
                    int done = resp->chunked_total - resp->iov[x].iov_len;
                    // Start from the len to allow binprot to cut the \r\n
                    int todo = resp->iov[x].iov_len;
                    while (ch && todo > 0 && iovused < ...",56,,2559,2,,void
35983,BLOCK,-1,,"{
            // Don't actually unchain the resp obj here since it's singly-linked.
            // Just let the post function handle it linearly.
            resp = resp->next;
            continue;
        }",25,,2560,2,,void
35994,BLOCK,-1,,"{
            // Handle chunked items specially.
            // They spend much more time in send so we can be a bit wasteful
            // in rebuilding iovecs for them.
            item_chunk *ch = (item_chunk *)ITEM_schunk((item *)resp->iov[resp->chunked_data_iov].iov_base);
            int x;
            for (x = 0; x < resp->iovcnt; x++) {
                // This iov is tracking how far we've copied so far.
                if (x == resp->chunked_data_iov) {
                    int done = resp->chunked_total - resp->iov[x].iov_len;
                    // Start from the len to allow binprot to cut the \r\n
                    int todo = resp->iov[x].iov_len;
                    while (ch && todo > 0 && iovused < IOV_MAX-1) {
                        int skip = 0;
                        if (!ch->used) {
                            ch = ch->next;
                            continue;
                        }
                        // Skip parts we've already sent.
              ...",37,,2566,2,,void
36001,BLOCK,1,,<empty>,,,,9,,void
36076,BLOCK,-1,,<empty>,13,,2572,1,,void
36087,BLOCK,4,,"{
                // This iov is tracking how far we've copied so far.
                if (x == resp->chunked_data_iov) {
                    int done = resp->chunked_total - resp->iov[x].iov_len;
                    // Start from the len to allow binprot to cut the \r\n
                    int todo = resp->iov[x].iov_len;
                    while (ch && todo > 0 && iovused < IOV_MAX-1) {
                        int skip = 0;
                        if (!ch->used) {
                            ch = ch->next;
                            continue;
                        }
                        // Skip parts we've already sent.
                        if (done >= ch->used) {
                            done -= ch->used;
                            ch = ch->next;
                            continue;
                        } else if (done) {
                            skip = done;
                            done = 0;
                        }
                        iovs[iovused]...",48,,2572,4,,void
36094,BLOCK,-1,,"{
                    int done = resp->chunked_total - resp->iov[x].iov_len;
                    // Start from the len to allow binprot to cut the \r\n
                    int todo = resp->iov[x].iov_len;
                    while (ch && todo > 0 && iovused < IOV_MAX-1) {
                        int skip = 0;
                        if (!ch->used) {
                            ch = ch->next;
                            continue;
                        }
                        // Skip parts we've already sent.
                        if (done >= ch->used) {
                            done -= ch->used;
                            ch = ch->next;
                            continue;
                        } else if (done) {
                            skip = done;
                            done = 0;
                        }
                        iovs[iovused].iov_base = ch->data + skip;
                        // Stupid binary protocol makes this go negative.
                 ...",50,,2574,2,,void
36131,BLOCK,-1,,"{
                        int skip = 0;
                        if (!ch->used) {
                            ch = ch->next;
                            continue;
                        }
                        // Skip parts we've already sent.
                        if (done >= ch->used) {
                            done -= ch->used;
                            ch = ch->next;
                            continue;
                        } else if (done) {
                            skip = done;
                            done = 0;
                        }
                        iovs[iovused].iov_base = ch->data + skip;
                        // Stupid binary protocol makes this go negative.
                        iovs[iovused].iov_len = ch->used - skip > todo ? todo : ch->used - skip;
                        iovused++;
                        todo -= ch->used - skip;
                        ch = ch->next;
                    }",67,,2578,2,,void
36141,BLOCK,-1,,"{
                            ch = ch->next;
                            continue;
                        }",40,,2580,2,,void
36154,BLOCK,-1,,"{
                            done -= ch->used;
                            ch = ch->next;
                            continue;
                        }",47,,2585,2,,void
36167,BLOCK,-1,,<empty>,32,,2589,1,,void
36170,BLOCK,-1,,"{
                            skip = done;
                            done = 0;
                        }",42,,2589,2,,void
36223,BLOCK,-1,,"{
                    iovs[iovused].iov_base = resp->iov[x].iov_base;
                    iovs[iovused].iov_len = resp->iov[x].iov_len;
                    iovused++;
                }",24,,2600,1,,void
36258,BLOCK,-1,,<empty>,21,,2606,2,,void
36261,BLOCK,-1,,"{
            memcpy(&iovs[iovused], resp->iov, sizeof(struct iovec)*resp->iovcnt);
            iovused += resp->iovcnt;
        }",16,,2608,1,,void
36288,BLOCK,-1,,<empty>,13,,2617,2,,void
36297,BLOCK,-1,,"{
    // We've written some of the data. Remove the completed
    // responses from the list of pending writes.
    mc_resp *resp = c->resp_head;
    while (resp) {
        int x;
        if (resp->skip) {
            resp = resp_finish(c, resp);
            continue;
        }

        // fastpath check. all small responses should cut here.
        if (res >= resp->tosend) {
            res -= resp->tosend;
            resp = resp_finish(c, resp);
            continue;
        }

        // it's fine to re-check iov's that were zeroed out before.
        for (x = 0; x < resp->iovcnt; x++) {
            struct iovec *iov = &resp->iov[x];
            if (res >= iov->iov_len) {
                resp->tosend -= iov->iov_len;
                res -= iov->iov_len;
                iov->iov_len = 0;
            } else {
                // Dumb special case for chunked items. Currently tracking
                // where to inject the chunked item via iov_base.
                // Extra not-grea...",50,,2626,3,,void
36306,BLOCK,-1,,"{
        int x;
        if (resp->skip) {
            resp = resp_finish(c, resp);
            continue;
        }

        // fastpath check. all small responses should cut here.
        if (res >= resp->tosend) {
            res -= resp->tosend;
            resp = resp_finish(c, resp);
            continue;
        }

        // it's fine to re-check iov's that were zeroed out before.
        for (x = 0; x < resp->iovcnt; x++) {
            struct iovec *iov = &resp->iov[x];
            if (res >= iov->iov_len) {
                resp->tosend -= iov->iov_len;
                res -= iov->iov_len;
                iov->iov_len = 0;
            } else {
                // Dumb special case for chunked items. Currently tracking
                // where to inject the chunked item via iov_base.
                // Extra not-great since chunked items can't be the first
                // index, so we have to check for non-zero c_d_iov first.
                if (!resp->chunked_data_iov || x...",18,,2630,2,,void
36312,BLOCK,-1,,"{
            resp = resp_finish(c, resp);
            continue;
        }",25,,2632,2,,void
36325,BLOCK,-1,,"{
            res -= resp->tosend;
            resp = resp_finish(c, resp);
            continue;
        }",34,,2638,2,,void
36338,BLOCK,-1,,<empty>,9,,2645,1,,void
36349,BLOCK,4,,"{
            struct iovec *iov = &resp->iov[x];
            if (res >= iov->iov_len) {
                resp->tosend -= iov->iov_len;
                res -= iov->iov_len;
                iov->iov_len = 0;
            } else {
                // Dumb special case for chunked items. Currently tracking
                // where to inject the chunked item via iov_base.
                // Extra not-great since chunked items can't be the first
                // index, so we have to check for non-zero c_d_iov first.
                if (!resp->chunked_data_iov || x != resp->chunked_data_iov) {
                    iov->iov_base = (char *)iov->iov_base + res;
                }
                iov->iov_len -= res;
                resp->tosend -= res;
                res = 0;
                break;
            }
        }",44,,2645,4,,void
36365,BLOCK,-1,,"{
                resp->tosend -= iov->iov_len;
                res -= iov->iov_len;
                iov->iov_len = 0;
            }",38,,2647,2,,void
36384,BLOCK,-1,,"{
                // Dumb special case for chunked items. Currently tracking
                // where to inject the chunked item via iov_base.
                // Extra not-great since chunked items can't be the first
                // index, so we have to check for non-zero c_d_iov first.
                if (!resp->chunked_data_iov || x != resp->chunked_data_iov) {
                    iov->iov_base = (char *)iov->iov_base + res;
                }
                iov->iov_len -= res;
                resp->tosend -= res;
                res = 0;
                break;
            }",20,,2651,1,,void
36396,BLOCK,-1,,"{
                    iov->iov_base = (char *)iov->iov_base + res;
                }",77,,2656,2,,void
36428,BLOCK,-1,,"{
            resp = resp_finish(c, resp);
        }",32,,2667,2,,void
36435,BLOCK,-1,,"{
            // Jammed up here. This is the new head.
            break;
        }",16,,2669,1,,void
36441,BLOCK,-1,,"{
    assert(c != NULL);
    struct iovec iovs[IOV_MAX];
    struct msghdr msg;
    int iovused = 0;

    // init the msg.
    memset(&msg, 0, sizeof(struct msghdr));
    msg.msg_iov = iovs;

    iovused = _transmit_pre(c, iovs, iovused, TRANSMIT_ALL_RESP);
    if (iovused == 0) {
        // Avoid the syscall if we're only handling a noreply.
        // Return the response object.
        _transmit_post(c, 0);
        return TRANSMIT_COMPLETE;
    }

    // Alright, send.
    ssize_t res;
    msg.msg_iovlen = iovused;
    res = c->sendmsg(c, &msg, 0);
    if (res >= 0) {
        pthread_mutex_lock(&c->thread->stats.mutex);
        c->thread->stats.bytes_written += res;
        pthread_mutex_unlock(&c->thread->stats.mutex);

        // Decrement any partial IOV's and complete any finished resp's.
        _transmit_post(c, res);

        if (c->resp_head) {
            return TRANSMIT_INCOMPLETE;
        } else {
            return TRANSMIT_COMPLETE;
        }
    }

    if (res == -1...",47,,2685,2,,void
36470,BLOCK,1,,<empty>,,,,1,,void
36476,BLOCK,-1,,"{
        // Avoid the syscall if we're only handling a noreply.
        // Return the response object.
        _transmit_post(c, 0);
        return TRANSMIT_COMPLETE;
    }",23,,2696,2,,void
36502,BLOCK,-1,,"{
        pthread_mutex_lock(&c->thread->stats.mutex);
        c->thread->stats.bytes_written += res;
        pthread_mutex_unlock(&c->thread->stats.mutex);

        // Decrement any partial IOV's and complete any finished resp's.
        _transmit_post(c, res);

        if (c->resp_head) {
            return TRANSMIT_INCOMPLETE;
        } else {
            return TRANSMIT_COMPLETE;
        }
    }",19,,2707,2,,void
36537,BLOCK,-1,,"{
            return TRANSMIT_INCOMPLETE;
        }",27,,2715,2,,void
36541,BLOCK,-1,,"{
            return TRANSMIT_COMPLETE;
        }",16,,2717,1,,void
36557,BLOCK,-1,,"{
        if (!update_event(c, EV_WRITE | EV_PERSIST)) {
            if (settings.verbose > 0)
                fprintf(stderr, ""Couldn't update event\n"");
            conn_set_state(c, conn_closing);
            return TRANSMIT_HARD_ERROR;
        }
        return TRANSMIT_SOFT_ERROR;
    }",65,,2722,2,,void
36565,BLOCK,-1,,"{
            if (settings.verbose > 0)
                fprintf(stderr, ""Couldn't update event\n"");
            conn_set_state(c, conn_closing);
            return TRANSMIT_HARD_ERROR;
        }",54,,2723,2,,void
36572,BLOCK,-1,,<empty>,17,,2725,2,,void
36589,BLOCK,-1,,<empty>,9,,2734,2,,void
36602,BLOCK,-1,,"{
    // We need to communicate the total number of packets
    // If this isn't set, it's the first time this response is building a udp
    // header, so ""tosend"" must be static.
    if (!resp->udp_total) {
        uint32_t total;
        total = resp->tosend / UDP_DATA_SIZE;
        if (resp->tosend % UDP_DATA_SIZE)
            total++;
        // The spec doesn't really say what we should do here. It's _probably_
        // better to bail out?
        if (total > USHRT_MAX) {
            total = USHRT_MAX;
        }
        resp->udp_total = total;
    }

    // TODO: why wasn't this hto*'s and casts?
    // this ends up sending UDP hdr data specifically in host byte order.
    *hdr++ = resp->request_id / 256;
    *hdr++ = resp->request_id % 256;
    *hdr++ = resp->udp_sequence / 256;
    *hdr++ = resp->udp_sequence % 256;
    *hdr++ = resp->udp_total / 256;
    *hdr++ = resp->udp_total % 256;
    *hdr++ = 0;
    *hdr++ = 0;
    resp->udp_sequence++;
}",65,,2740,3,,void
36608,BLOCK,-1,,"{
        uint32_t total;
        total = resp->tosend / UDP_DATA_SIZE;
        if (resp->tosend % UDP_DATA_SIZE)
            total++;
        // The spec doesn't really say what we should do here. It's _probably_
        // better to bail out?
        if (total > USHRT_MAX) {
            total = USHRT_MAX;
        }
        resp->udp_total = total;
    }",27,,2744,2,,void
36617,BLOCK,1,,<empty>,,,,1,,void
36625,BLOCK,1,,<empty>,,,,1,,void
36627,BLOCK,-1,,<empty>,13,,2748,2,,void
36634,BLOCK,-1,,"{
            total = USHRT_MAX;
        }",32,,2751,2,,void
36715,BLOCK,-1,,"{
    assert(c != NULL);
    struct iovec iovs[IOV_MAX];
    struct msghdr msg;
    mc_resp *resp;
    int iovused = 0;
    unsigned char udp_hdr[UDP_HEADER_SIZE];

    // We only send one UDP packet per call (ugh), so we can only operate on a
    // single response at a time.
    resp = c->resp_head;

    if (!resp) {
        return TRANSMIT_COMPLETE;
    }

    if (resp->skip) {
        resp = resp_finish(c, resp);
        return TRANSMIT_INCOMPLETE;
    }

    // clear the message and initialize it.
    memset(&msg, 0, sizeof(struct msghdr));
    msg.msg_iov = iovs;

    // the UDP source to return to.
    msg.msg_name = &resp->request_addr;
    msg.msg_namelen = resp->request_addr_size;

    // First IOV is the custom UDP header.
    iovs[0].iov_base = (void *)udp_hdr;
    iovs[0].iov_len = UDP_HEADER_SIZE;
    build_udp_header(udp_hdr, resp);
    iovused++;

    // Fill the IOV's the standard way.
    // TODO: might get a small speedup if we let it break early with a length
   ...",51,,2782,2,,void
36736,BLOCK,-1,,"{
        return TRANSMIT_COMPLETE;
    }",16,,2794,2,,void
36743,BLOCK,-1,,"{
        resp = resp_finish(c, resp);
        return TRANSMIT_INCOMPLETE;
    }",21,,2798,2,,void
36793,BLOCK,1,,<empty>,,,,1,,void
36807,BLOCK,1,,<empty>,,,,1,,void
36809,BLOCK,20,,"{
        int x = 0;
        int len = 0;
        for (x = 0; x < iovused; x++) {
            if (len + iovs[x].iov_len >= UDP_MAX_PAYLOAD_SIZE) {
                iovs[x].iov_len = UDP_MAX_PAYLOAD_SIZE - len;
                x++;
                break;
            } else {
                len += iovs[x].iov_len;
            }
        }
        iovused = x;
    }",5,,2824,20,,void
36819,BLOCK,-1,,<empty>,9,,2827,1,,void
36828,BLOCK,4,,"{
            if (len + iovs[x].iov_len >= UDP_MAX_PAYLOAD_SIZE) {
                iovs[x].iov_len = UDP_MAX_PAYLOAD_SIZE - len;
                x++;
                break;
            } else {
                len += iovs[x].iov_len;
            }
        }",39,,2827,4,,void
36839,BLOCK,1,,<empty>,,,,1,,void
36841,BLOCK,-1,,"{
                iovs[x].iov_len = UDP_MAX_PAYLOAD_SIZE - len;
                x++;
                break;
            }",64,,2828,2,,void
36850,BLOCK,1,,<empty>,,,,1,,void
36857,BLOCK,-1,,"{
                len += iovs[x].iov_len;
            }",20,,2832,1,,void
36887,BLOCK,-1,,"{
        pthread_mutex_lock(&c->thread->stats.mutex);
        c->thread->stats.bytes_written += res;
        pthread_mutex_unlock(&c->thread->stats.mutex);

        // Ignore the header size from forwarding the IOV's
        res -= UDP_HEADER_SIZE;

        // Decrement any partial IOV's and complete any finished resp's.
        _transmit_post(c, res);

        if (c->resp_head) {
            return TRANSMIT_INCOMPLETE;
        } else {
            return TRANSMIT_COMPLETE;
        }
    }",19,,2843,2,,void
36918,BLOCK,1,,<empty>,,,,1,,void
36927,BLOCK,-1,,"{
            return TRANSMIT_INCOMPLETE;
        }",27,,2854,2,,void
36931,BLOCK,-1,,"{
            return TRANSMIT_COMPLETE;
        }",16,,2856,1,,void
36947,BLOCK,-1,,"{
        if (!update_event(c, EV_WRITE | EV_PERSIST)) {
            if (settings.verbose > 0)
                fprintf(stderr, ""Couldn't update event\n"");
            conn_set_state(c, conn_closing);
            return TRANSMIT_HARD_ERROR;
        }
        return TRANSMIT_SOFT_ERROR;
    }",65,,2861,2,,void
36955,BLOCK,-1,,"{
            if (settings.verbose > 0)
                fprintf(stderr, ""Couldn't update event\n"");
            conn_set_state(c, conn_closing);
            return TRANSMIT_HARD_ERROR;
        }",54,,2862,2,,void
36962,BLOCK,-1,,<empty>,17,,2864,2,,void
36979,BLOCK,-1,,<empty>,9,,2873,2,,void
36991,BLOCK,-1,,"{
    int total = 0;
    int res;
    assert(c->rcurr != c->ritem);

    while (c->rlbytes > 0) {
        item_chunk *ch = (item_chunk *)c->ritem;
        if (ch->size == ch->used) {
            // FIXME: ch->next is currently always 0. remove this?
            if (ch->next) {
                c->ritem = (char *) ch->next;
            } else {
                /* Allocate next chunk. Binary protocol needs 2b for \r\n */
                c->ritem = (char *) do_item_alloc_chunk(ch, c->rlbytes +
                       ((c->protocol == binary_prot) ? 2 : 0));
                if (!c->ritem) {
                    // We failed an allocation. Let caller handle cleanup.
                    total = -2;
                    break;
                }
                // ritem has new chunk, restart the loop.
                continue;
                //assert(c->rlbytes == 0);
            }
        }

        int unused = ch->size - ch->used;
        /* first check if we have leftovers in the conn_rea...",44,,2884,2,,void
37011,BLOCK,-1,,"{
        item_chunk *ch = (item_chunk *)c->ritem;
        if (ch->size == ch->used) {
            // FIXME: ch->next is currently always 0. remove this?
            if (ch->next) {
                c->ritem = (char *) ch->next;
            } else {
                /* Allocate next chunk. Binary protocol needs 2b for \r\n */
                c->ritem = (char *) do_item_alloc_chunk(ch, c->rlbytes +
                       ((c->protocol == binary_prot) ? 2 : 0));
                if (!c->ritem) {
                    // We failed an allocation. Let caller handle cleanup.
                    total = -2;
                    break;
                }
                // ritem has new chunk, restart the loop.
                continue;
                //assert(c->rlbytes == 0);
            }
        }

        int unused = ch->size - ch->used;
        /* first check if we have leftovers in the conn_read buffer */
        if (c->rbytes > 0) {
            total = 0;
            int tocopy = c->rbyt...",28,,2889,2,,void
37028,BLOCK,-1,,"{
            // FIXME: ch->next is currently always 0. remove this?
            if (ch->next) {
                c->ritem = (char *) ch->next;
            } else {
                /* Allocate next chunk. Binary protocol needs 2b for \r\n */
                c->ritem = (char *) do_item_alloc_chunk(ch, c->rlbytes +
                       ((c->protocol == binary_prot) ? 2 : 0));
                if (!c->ritem) {
                    // We failed an allocation. Let caller handle cleanup.
                    total = -2;
                    break;
                }
                // ritem has new chunk, restart the loop.
                continue;
                //assert(c->rlbytes == 0);
            }
        }",35,,2891,2,,void
37033,BLOCK,-1,,"{
                c->ritem = (char *) ch->next;
            }",27,,2893,2,,void
37044,BLOCK,-1,,"{
                /* Allocate next chunk. Binary protocol needs 2b for \r\n */
                c->ritem = (char *) do_item_alloc_chunk(ch, c->rlbytes +
                       ((c->protocol == binary_prot) ? 2 : 0));
                if (!c->ritem) {
                    // We failed an allocation. Let caller handle cleanup.
                    total = -2;
                    break;
                }
                // ritem has new chunk, restart the loop.
                continue;
                //assert(c->rlbytes == 0);
            }",20,,2895,1,,void
37070,BLOCK,-1,,"{
                    // We failed an allocation. Let caller handle cleanup.
                    total = -2;
                    break;
                }",32,,2899,2,,void
37093,BLOCK,-1,,"{
            total = 0;
            int tocopy = c->rbytes > c->rlbytes ? c->rlbytes : c->rbytes;
            tocopy = tocopy > unused ? unused : tocopy;
            if (c->ritem != c->rcurr) {
                memmove(ch->data + ch->used, c->rcurr, tocopy);
            }
            total += tocopy;
            c->rlbytes -= tocopy;
            c->rcurr += tocopy;
            c->rbytes -= tocopy;
            ch->used += tocopy;
            if (c->rlbytes == 0) {
                break;
            }
        }",28,,2912,2,,void
37130,BLOCK,-1,,"{
                memmove(ch->data + ch->used, c->rcurr, tocopy);
            }",39,,2916,2,,void
37172,BLOCK,-1,,"{
                break;
            }",34,,2924,2,,void
37175,BLOCK,-1,,"{
            /*  now try reading from the socket */
            res = c->read(c, ch->data + ch->used,
                    (unused > c->rlbytes ? c->rlbytes : unused));
            if (res > 0) {
                pthread_mutex_lock(&c->thread->stats.mutex);
                c->thread->stats.bytes_read += res;
                pthread_mutex_unlock(&c->thread->stats.mutex);
                ch->used += res;
                total += res;
                c->rlbytes -= res;
            } else {
                /* Reset total to the latest result so caller can handle it */
                total = res;
                break;
            }
        }",16,,2927,1,,void
37204,BLOCK,-1,,"{
                pthread_mutex_lock(&c->thread->stats.mutex);
                c->thread->stats.bytes_read += res;
                pthread_mutex_unlock(&c->thread->stats.mutex);
                ch->used += res;
                total += res;
                c->rlbytes -= res;
            }",26,,2931,2,,void
37246,BLOCK,-1,,"{
                /* Reset total to the latest result so caller can handle it */
                total = res;
                break;
            }",20,,2938,1,,void
37267,BLOCK,-1,,"{
        item_chunk *ch = (item_chunk *)c->ritem;
        if (ch->size - ch->used < 2) {
            c->ritem = (char *) do_item_alloc_chunk(ch, 2);
            if (!c->ritem) {
                total = -2;
            }
        }
    }",70,,2951,2,,void
37286,BLOCK,-1,,"{
            c->ritem = (char *) do_item_alloc_chunk(ch, 2);
            if (!c->ritem) {
                total = -2;
            }
        }",38,,2953,2,,void
37301,BLOCK,-1,,"{
                total = -2;
            }",28,,2955,2,,void
37312,BLOCK,-1,,"{
    bool stop = false;
    int sfd;
    socklen_t addrlen;
    struct sockaddr_storage addr;
    int nreqs = settings.reqs_per_event;
    int res;
    const char *str;
#ifdef HAVE_ACCEPT4
    static int  use_accept4 = 1;
#else
    static int  use_accept4 = 0;
#endif

    assert(c != NULL);

    while (!stop) {

        switch(c->state) {
        case conn_listening:
            addrlen = sizeof(addr);
#ifdef HAVE_ACCEPT4
            if (use_accept4) {
                sfd = accept4(c->sfd, (struct sockaddr *)&addr, &addrlen, SOCK_NONBLOCK);
            } else {
                sfd = accept(c->sfd, (struct sockaddr *)&addr, &addrlen);
            }
#else
            sfd = accept(c->sfd, (struct sockaddr *)&addr, &addrlen);
#endif
            if (sfd == -1) {
                if (use_accept4 && errno == ENOSYS) {
                    use_accept4 = 0;
                    continue;
                }
                perror(use_accept4 ? ""accept4()"" : ""accept()"");
                if (errno...",36,,2963,2,,void
37339,BLOCK,-1,,"{

        switch(c->state) {
        case conn_listening:
            addrlen = sizeof(addr);
#ifdef HAVE_ACCEPT4
            if (use_accept4) {
                sfd = accept4(c->sfd, (struct sockaddr *)&addr, &addrlen, SOCK_NONBLOCK);
            } else {
                sfd = accept(c->sfd, (struct sockaddr *)&addr, &addrlen);
            }
#else
            sfd = accept(c->sfd, (struct sockaddr *)&addr, &addrlen);
#endif
            if (sfd == -1) {
                if (use_accept4 && errno == ENOSYS) {
                    use_accept4 = 0;
                    continue;
                }
                perror(use_accept4 ? ""accept4()"" : ""accept()"");
                if (errno == EAGAIN || errno == EWOULDBLOCK) {
                    /* these are transient, so don't log anything */
                    stop = true;
                } else if (errno == EMFILE) {
                    if (settings.verbose > 0)
                        fprintf(stderr, ""Too many open connections\n"");
        ...",19,,2979,2,,void
37344,BLOCK,-1,,"{
        case conn_listening:
            addrlen = sizeof(addr);
#ifdef HAVE_ACCEPT4
            if (use_accept4) {
                sfd = accept4(c->sfd, (struct sockaddr *)&addr, &addrlen, SOCK_NONBLOCK);
            } else {
                sfd = accept(c->sfd, (struct sockaddr *)&addr, &addrlen);
            }
#else
            sfd = accept(c->sfd, (struct sockaddr *)&addr, &addrlen);
#endif
            if (sfd == -1) {
                if (use_accept4 && errno == ENOSYS) {
                    use_accept4 = 0;
                    continue;
                }
                perror(use_accept4 ? ""accept4()"" : ""accept()"");
                if (errno == EAGAIN || errno == EWOULDBLOCK) {
                    /* these are transient, so don't log anything */
                    stop = true;
                } else if (errno == EMFILE) {
                    if (settings.verbose > 0)
                        fprintf(stderr, ""Too many open connections\n"");
                    accept_new_conns...",26,,2981,2,,void
37368,BLOCK,-1,,"{
                if (use_accept4 && errno == ENOSYS) {
                    use_accept4 = 0;
                    continue;
                }
                perror(use_accept4 ? ""accept4()"" : ""accept()"");
                if (errno == EAGAIN || errno == EWOULDBLOCK) {
                    /* these are transient, so don't log anything */
                    stop = true;
                } else if (errno == EMFILE) {
                    if (settings.verbose > 0)
                        fprintf(stderr, ""Too many open connections\n"");
                    accept_new_conns(false);
                    stop = true;
                } else {
                    perror(""accept()"");
                    stop = true;
                }
                break;
            }",28,,2993,2,,void
37375,BLOCK,-1,,"{
                    use_accept4 = 0;
                    continue;
                }",53,,2994,2,,void
37393,BLOCK,-1,,"{
                    /* these are transient, so don't log anything */
                    stop = true;
                }",62,,2999,2,,void
37398,BLOCK,-1,,<empty>,24,,3002,1,,void
37403,BLOCK,-1,,"{
                    if (settings.verbose > 0)
                        fprintf(stderr, ""Too many open connections\n"");
                    accept_new_conns(false);
                    stop = true;
                }",45,,3002,2,,void
37410,BLOCK,-1,,<empty>,25,,3004,2,,void
37420,BLOCK,-1,,"{
                    perror(""accept()"");
                    stop = true;
                }",24,,3007,1,,void
37430,BLOCK,-1,,"{
                if (fcntl(sfd, F_SETFL, fcntl(sfd, F_GETFL) | O_NONBLOCK) < 0) {
                    perror(""setting O_NONBLOCK"");
                    close(sfd);
                    break;
                }
            }",31,,3013,2,,void
37442,BLOCK,-1,,"{
                    perror(""setting O_NONBLOCK"");
                    close(sfd);
                    break;
                }",80,,3014,2,,void
37453,BLOCK,-1,,"{
                reject = sfd >= settings.maxconns - 1;
                if (reject) {
                    STATS_LOCK();
                    stats.rejected_conns++;
                    STATS_UNLOCK();
                }
            }",41,,3022,2,,void
37465,BLOCK,-1,,"{
                    STATS_LOCK();
                    stats.rejected_conns++;
                    STATS_UNLOCK();
                }",29,,3024,2,,void
37473,BLOCK,-1,,"{
                reject = false;
            }",20,,3029,1,,void
37479,BLOCK,-1,,"{
                str = ""ERROR Too many open connections\r\n"";
                res = write(sfd, str, strlen(str));
                close(sfd);
            }",25,,3033,2,,void
37493,BLOCK,-1,,"{
                void *ssl_v = NULL;
#ifdef TLS
                SSL *ssl = NULL;
                if (c->ssl_enabled) {
                    assert(IS_TCP(c->transport) && settings.ssl_enabled);

                    if (settings.ssl_ctx == NULL) {
                        if (settings.verbose) {
                            fprintf(stderr, ""SSL context is not initialized\n"");
                        }
                        close(sfd);
                        break;
                    }
                    SSL_LOCK();
                    ssl = SSL_new(settings.ssl_ctx);
                    SSL_UNLOCK();
                    if (ssl == NULL) {
                        if (settings.verbose) {
                            fprintf(stderr, ""Failed to created the SSL object\n"");
                        }
                        close(sfd);
                        break;
                    }
                    SSL_set_fd(ssl, sfd);
                    int ret = SSL_accept(ssl);
             ...",20,,3037,1,,void
37505,BLOCK,1,,<empty>,,,,1,,void
37532,BLOCK,-1,,"{
                if (settings.verbose > 0)
                    fprintf(stderr, ""Couldn't update event\n"");
                conn_set_state(c, conn_closing);
                break;
            }",57,,3090,2,,void
37539,BLOCK,-1,,<empty>,21,,3092,2,,void
37562,BLOCK,1,,<empty>,,,,2,,void
37568,BLOCK,-1,,"{
                // Assign a read buffer if necessary.
                if (!rbuf_alloc(c)) {
                    // TODO: Some way to allow for temporary failures.
                    conn_set_state(c, conn_closing);
                    break;
                }
                res = try_read_network(c);
            }",40,,3102,2,,void
37573,BLOCK,-1,,"{
                    // TODO: Some way to allow for temporary failures.
                    conn_set_state(c, conn_closing);
                    break;
                }",37,,3104,2,,void
37583,BLOCK,-1,,"{
                // UDP connections always have a static buffer.
                res = try_read_udp(c);
            }",20,,3110,1,,void
37590,BLOCK,-1,,"{
            case READ_NO_DATA_RECEIVED:
                conn_set_state(c, conn_waiting);
                break;
            case READ_DATA_RECEIVED:
                conn_set_state(c, conn_parse_cmd);
                break;
            case READ_ERROR:
                conn_set_state(c, conn_closing);
                break;
            case READ_MEMORY_ERROR: /* Failed to allocate more memory */
                /* State already set by try_read_network */
                break;
            }",26,,3115,2,,void
37628,BLOCK,-1,,"{
                /* we need more data! */
                if (c->resp_head) {
                    // Buffered responses waiting, flush in the meantime.
                    conn_set_state(c, conn_mwrite);
                } else {
                    conn_set_state(c, conn_waiting);
                }
            }",46,,3133,2,,void
37633,BLOCK,-1,,"{
                    // Buffered responses waiting, flush in the meantime.
                    conn_set_state(c, conn_mwrite);
                }",35,,3135,2,,void
37638,BLOCK,-1,,"{
                    conn_set_state(c, conn_waiting);
                }",24,,3138,1,,void
37651,BLOCK,-1,,"{
                reset_cmd_handler(c);
            }",29,,3150,2,,void
37655,BLOCK,-1,,<empty>,20,,3152,1,,void
37660,BLOCK,-1,,"{
                // flush response pipe on yield.
                conn_set_state(c, conn_mwrite);
            }",38,,3152,2,,void
37665,BLOCK,-1,,"{
                pthread_mutex_lock(&c->thread->stats.mutex);
                c->thread->stats.conn_yields++;
                pthread_mutex_unlock(&c->thread->stats.mutex);
                if (c->rbytes > 0) {
                    /* We have already read in data into the input buffer,
                       so libevent will most likely not signal read events
                       on the socket (unless more data is available. As a
                       hack we should just put in a request to write data,
                       because that should be possible ;-)
                    */
                    if (!update_event(c, EV_WRITE | EV_PERSIST)) {
                        if (settings.verbose > 0)
                            fprintf(stderr, ""Couldn't update event\n"");
                        conn_set_state(c, conn_closing);
                        break;
                    }
                }
                stop = true;
            }",20,,3155,1,,void
37698,BLOCK,-1,,"{
                    /* We have already read in data into the input buffer,
                       so libevent will most likely not signal read events
                       on the socket (unless more data is available. As a
                       hack we should just put in a request to write data,
                       because that should be possible ;-)
                    */
                    if (!update_event(c, EV_WRITE | EV_PERSIST)) {
                        if (settings.verbose > 0)
                            fprintf(stderr, ""Couldn't update event\n"");
                        conn_set_state(c, conn_closing);
                        break;
                    }
                }",36,,3159,2,,void
37706,BLOCK,-1,,"{
                        if (settings.verbose > 0)
                            fprintf(stderr, ""Couldn't update event\n"");
                        conn_set_state(c, conn_closing);
                        break;
                    }",66,,3166,2,,void
37713,BLOCK,-1,,<empty>,29,,3168,2,,void
37733,BLOCK,-1,,"{
                complete_nread(c);
                break;
            }",34,,3178,2,,void
37743,BLOCK,-1,,"{
                if (settings.verbose) {
                    fprintf(stderr, ""Invalid rlbytes to read: len %d\n"", c->rlbytes);
                }
                conn_set_state(c, conn_closing);
                break;
            }",33,,3184,2,,void
37748,BLOCK,-1,,"{
                    fprintf(stderr, ""Invalid rlbytes to read: len %d\n"", c->rlbytes);
                }",39,,3185,2,,void
37774,BLOCK,1,,<empty>,,,,1,,void
37777,BLOCK,-1,,"{
                /* first check if we have leftovers in the conn_read buffer */
                if (c->rbytes > 0) {
                    int tocopy = c->rbytes > c->rlbytes ? c->rlbytes : c->rbytes;
                    memmove(c->ritem, c->rcurr, tocopy);
                    c->ritem += tocopy;
                    c->rlbytes -= tocopy;
                    c->rcurr += tocopy;
                    c->rbytes -= tocopy;
                    if (c->rlbytes == 0) {
                        break;
                    }
                }

                /*  now try reading from the socket */
                res = c->read(c, c->ritem, c->rlbytes);
                if (res > 0) {
                    pthread_mutex_lock(&c->thread->stats.mutex);
                    c->thread->stats.bytes_read += res;
                    pthread_mutex_unlock(&c->thread->stats.mutex);
                    if (c->rcurr == c->ritem) {
                        c->rcurr += res;
                    }
                    c...",91,,3192,2,,void
37784,BLOCK,-1,,"{
                    int tocopy = c->rbytes > c->rlbytes ? c->rlbytes : c->rbytes;
                    memmove(c->ritem, c->rcurr, tocopy);
                    c->ritem += tocopy;
                    c->rlbytes -= tocopy;
                    c->rcurr += tocopy;
                    c->rbytes -= tocopy;
                    if (c->rlbytes == 0) {
                        break;
                    }
                }",36,,3194,2,,void
37836,BLOCK,-1,,"{
                        break;
                    }",42,,3201,2,,void
37855,BLOCK,-1,,"{
                    pthread_mutex_lock(&c->thread->stats.mutex);
                    c->thread->stats.bytes_read += res;
                    pthread_mutex_unlock(&c->thread->stats.mutex);
                    if (c->rcurr == c->ritem) {
                        c->rcurr += res;
                    }
                    c->ritem += res;
                    c->rlbytes -= res;
                    break;
                }",30,,3208,2,,void
37891,BLOCK,-1,,"{
                        c->rcurr += res;
                    }",47,,3212,2,,void
37909,BLOCK,-1,,"{
                res = read_into_chunked_item(c);
                if (res > 0)
                    break;
            }",20,,3219,1,,void
37918,BLOCK,-1,,<empty>,21,,3222,2,,void
37924,BLOCK,-1,,"{ /* end of stream */
                c->close_reason = NORMAL_CLOSE;
                conn_set_state(c, conn_closing);
                break;
            }",27,,3225,2,,void
37947,BLOCK,-1,,"{
                if (!update_event(c, EV_READ | EV_PERSIST)) {
                    if (settings.verbose > 0)
                        fprintf(stderr, ""Couldn't update event\n"");
                    conn_set_state(c, conn_closing);
                    break;
                }
                stop = true;
                break;
            }",73,,3231,2,,void
37955,BLOCK,-1,,"{
                    if (settings.verbose > 0)
                        fprintf(stderr, ""Couldn't update event\n"");
                    conn_set_state(c, conn_closing);
                    break;
                }",61,,3232,2,,void
37962,BLOCK,-1,,<empty>,25,,3234,2,,void
37979,BLOCK,-1,,"{
                out_of_memory(c, ""SERVER_ERROR Out of memory during read"");
                c->sbytes = c->rlbytes;
                conn_set_state(c, conn_swallow);
                // Ensure this flag gets cleared. It gets killed on conn_new()
                // so any conn_closing is fine, calling complete_nread is
                // fine. This swallow semms to be the only other case.
                c->set_stale = false;
                c->mset_res = false;
                break;
            }",28,,3243,2,,void
38010,BLOCK,-1,,"{
                fprintf(stderr, ""Failed to read, and not due to blocking:\n""
                        ""errno: %d %s \n""
                        ""rcurr=%p ritem=%p rbuf=%p rlbytes=%d rsize=%d\n"",
                        errno, strerror(errno),
                        (void *)c->rcurr, (void *)c->ritem, (void *)c->rbuf,
                        (int)c->rlbytes, (int)c->rsize);
            }",39,,3255,2,,void
38054,BLOCK,-1,,"{
                conn_set_state(c, conn_new_cmd);
                break;
            }",33,,3268,2,,void
38065,BLOCK,-1,,"{
                int tocopy = c->rbytes > c->sbytes ? c->sbytes : c->rbytes;
                c->sbytes -= tocopy;
                c->rcurr += tocopy;
                c->rbytes -= tocopy;
                break;
            }",32,,3274,2,,void
38127,BLOCK,-1,,"{
                pthread_mutex_lock(&c->thread->stats.mutex);
                c->thread->stats.bytes_read += res;
                pthread_mutex_unlock(&c->thread->stats.mutex);
                c->sbytes -= res;
                break;
            }",26,,3284,2,,void
38165,BLOCK,-1,,"{ /* end of stream */
                c->close_reason = NORMAL_CLOSE;
                conn_set_state(c, conn_closing);
                break;
            }",27,,3291,2,,void
38188,BLOCK,-1,,"{
                if (!update_event(c, EV_READ | EV_PERSIST)) {
                    if (settings.verbose > 0)
                        fprintf(stderr, ""Couldn't update event\n"");
                    conn_set_state(c, conn_closing);
                    break;
                }
                stop = true;
                break;
            }",73,,3296,2,,void
38196,BLOCK,-1,,"{
                    if (settings.verbose > 0)
                        fprintf(stderr, ""Couldn't update event\n"");
                    conn_set_state(c, conn_closing);
                    break;
                }",61,,3297,2,,void
38203,BLOCK,-1,,<empty>,25,,3299,2,,void
38221,BLOCK,-1,,<empty>,17,,3308,2,,void
38240,BLOCK,-1,,<empty>,13,,3320,1,,void
38252,BLOCK,1,,<empty>,,,,1,,void
38256,BLOCK,4,,"{
                if (q->stack_ctx != NULL) {
                    io_queue_cb_t *qcb = thread_io_queue_get(c->thread, q->type);
                    qcb->submit_cb(q);
                    c->io_queues_submitted++;
                }
            }",79,,3320,4,,void
38263,BLOCK,-1,,"{
                    io_queue_cb_t *qcb = thread_io_queue_get(c->thread, q->type);
                    qcb->submit_cb(q);
                    c->io_queues_submitted++;
                }",43,,3321,2,,void
38289,BLOCK,-1,,"{
                conn_set_state(c, conn_io_queue);
                event_del(&c->event);

                stop = true;
                break;
            }",46,,3327,2,,void
38309,BLOCK,1,,<empty>,,,,2,,void
38319,BLOCK,-1,,"{
            case TRANSMIT_COMPLETE:
                if (c->state == conn_mwrite) {
                    // Free up IO wraps and any half-uploaded items.
                    conn_release_items(c);
                    conn_set_state(c, conn_new_cmd);
                    if (c->close_after_write) {
                        conn_set_state(c, conn_closing);
                    }
                } else {
                    if (settings.verbose > 0)
                        fprintf(stderr, ""Unexpected state %d\n"", c->state);
                    conn_set_state(c, conn_closing);
                }
                break;

            case TRANSMIT_INCOMPLETE:
            case TRANSMIT_HARD_ERROR:
                break;                   /* Continue in state machine. */

            case TRANSMIT_SOFT_ERROR:
                stop = true;
                break;
            }",76,,3335,2,,void
38328,BLOCK,-1,,"{
                    // Free up IO wraps and any half-uploaded items.
                    conn_release_items(c);
                    conn_set_state(c, conn_new_cmd);
                    if (c->close_after_write) {
                        conn_set_state(c, conn_closing);
                    }
                }",46,,3337,2,,void
38338,BLOCK,-1,,"{
                        conn_set_state(c, conn_closing);
                    }",47,,3341,2,,void
38343,BLOCK,-1,,"{
                    if (settings.verbose > 0)
                        fprintf(stderr, ""Unexpected state %d\n"", c->state);
                    conn_set_state(c, conn_closing);
                }",24,,3344,1,,void
38350,BLOCK,-1,,<empty>,25,,3346,2,,void
38380,BLOCK,1,,<empty>,,,,2,,void
38386,BLOCK,-1,,<empty>,17,,3363,2,,void
38390,BLOCK,-1,,<empty>,17,,3365,1,,void
38427,BLOCK,-1,,"{
    conn *c;

    c = (conn *)arg;
    assert(c != NULL);

    c->which = which;

    /* sanity */
    if (fd != c->sfd) {
        if (settings.verbose > 0)
            fprintf(stderr, ""Catastrophic: event fd doesn't match conn fd!\n"");
        conn_close(c);
        return;
    }

    drive_machine(c);

    /* wait for next event */
    return;
}",76,,3392,4,,void
38449,BLOCK,-1,,"{
        if (settings.verbose > 0)
            fprintf(stderr, ""Catastrophic: event fd doesn't match conn fd!\n"");
        conn_close(c);
        return;
    }",23,,3401,2,,void
38456,BLOCK,-1,,<empty>,13,,3403,2,,void
38470,BLOCK,-1,,"{
    int sfd;
    int flags;

    if ((sfd = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol)) == -1) {
        return -1;
    }

    if ((flags = fcntl(sfd, F_GETFL, 0)) < 0 ||
        fcntl(sfd, F_SETFL, flags | O_NONBLOCK) < 0) {
        perror(""setting O_NONBLOCK"");
        close(sfd);
        return -1;
    }
    return sfd;
}",44,,3414,2,,void
38489,BLOCK,-1,,"{
        return -1;
    }",80,,3418,2,,void
38511,BLOCK,-1,,"{
        perror(""setting O_NONBLOCK"");
        close(sfd);
        return -1;
    }",54,,3423,2,,void
38525,BLOCK,-1,,"{
    socklen_t intsize = sizeof(int);
    int last_good = 0;
    int min, max, avg;
    int old_size;

    /* Start with the default size. */
#ifdef _WIN32
    if (getsockopt((SOCKET)sfd, SOL_SOCKET, SO_SNDBUF, (char *)&old_size, &intsize) != 0) {
#else
    if (getsockopt(sfd, SOL_SOCKET, SO_SNDBUF, &old_size, &intsize) != 0) {
#endif /* #ifdef _WIN32 */
        if (settings.verbose > 0)
            perror(""getsockopt(SO_SNDBUF)"");
        return;
    }

    /* Binary-search for the real maximum. */
    min = old_size;
    max = MAX_SENDBUF_SIZE;

    while (min <= max) {
        avg = ((unsigned int)(min + max)) / 2;
        if (setsockopt(sfd, SOL_SOCKET, SO_SNDBUF, (void *)&avg, intsize) == 0) {
            last_good = avg;
            min = avg + 1;
        } else {
            max = avg - 1;
        }
    }

    if (settings.verbose > 1)
        fprintf(stderr, ""<%d send buffer was %d, now %d\n"", sfd, old_size, last_good);
}",44,,3435,2,,void
38550,BLOCK,-1,,"{
#endif /* #ifdef _WIN32 */
        if (settings.verbose > 0)
            perror(""getsockopt(SO_SNDBUF)"");
        return;
    }",75,,3445,2,,void
38557,BLOCK,-1,,<empty>,13,,3448,2,,void
38567,BLOCK,1,,<empty>,,,,1,,void
38577,BLOCK,-1,,"{
        avg = ((unsigned int)(min + max)) / 2;
        if (setsockopt(sfd, SOL_SOCKET, SO_SNDBUF, (void *)&avg, intsize) == 0) {
            last_good = avg;
            min = avg + 1;
        } else {
            max = avg - 1;
        }
    }",24,,3456,2,,void
38599,BLOCK,-1,,"{
            last_good = avg;
            min = avg + 1;
        }",81,,3458,2,,void
38609,BLOCK,-1,,"{
            max = avg - 1;
        }",16,,3461,1,,void
38621,BLOCK,-1,,<empty>,9,,3467,2,,void
38638,BLOCK,-1,,"{
    int sfd;
    struct linger ling = {0, 0};
    struct addrinfo *ai;
    struct addrinfo *next;
    struct addrinfo hints = { .ai_flags = AI_PASSIVE,
                              .ai_family = AF_UNSPEC };
    char port_buf[NI_MAXSERV];
    int error;
    int success = 0;
    int flags =1;

    hints.ai_socktype = IS_UDP(transport) ? SOCK_DGRAM : SOCK_STREAM;

    if (port == -1) {
        port = 0;
    }
    snprintf(port_buf, sizeof(port_buf), ""%d"", port);
    error= getaddrinfo(interface, port_buf, &hints, &ai);
    if (error != 0) {
        if (error != EAI_SYSTEM)
          fprintf(stderr, ""getaddrinfo(): %s\n"", gai_strerror(error));
        else
          perror(""getaddrinfo()"");
        return 1;
    }

    for (next= ai; next; next= next->ai_next) {
        conn *listen_conn_add;
        if ((sfd = new_socket(next)) == -1) {
            /* getaddrinfo can return ""junk"" addresses,
             * we make sure at least one works before erroring.
             */
            ...",48,,3484,8,,void
38652,BLOCK,1,,<empty>,31,,3489,1,,void
38656,BLOCK,2,,<empty>,31,,3490,2,,void
38676,BLOCK,1,,<empty>,,,,2,,void
38688,BLOCK,-1,,"{
        port = 0;
    }",21,,3498,2,,void
38711,BLOCK,-1,,"{
        if (error != EAI_SYSTEM)
          fprintf(stderr, ""getaddrinfo(): %s\n"", gai_strerror(error));
        else
          perror(""getaddrinfo()"");
        return 1;
    }",21,,3503,2,,void
38716,BLOCK,-1,,<empty>,11,,3505,2,,void
38723,BLOCK,-1,,<empty>,11,,3507,1,,void
38729,BLOCK,-1,,<empty>,5,,3511,1,,void
38739,BLOCK,4,,"{
        conn *listen_conn_add;
        if ((sfd = new_socket(next)) == -1) {
            /* getaddrinfo can return ""junk"" addresses,
             * we make sure at least one works before erroring.
             */
            if (errno == EMFILE) {
                /* ...unless we're out of fds */
                perror(""server_socket"");
                exit(EX_OSERR);
            }
            continue;
        }

        if (settings.num_napi_ids) {
            socklen_t len = sizeof(socklen_t);
            int napi_id;
            error = getsockopt(sfd, SOL_SOCKET, SO_INCOMING_NAPI_ID, &napi_id, &len);
            if (error != 0) {
                fprintf(stderr, ""-N <num_napi_ids> option not supported\n"");
                exit(EXIT_FAILURE);
            }
        }

#ifdef IPV6_V6ONLY
        if (next->ai_family == AF_INET6) {
            error = setsockopt(sfd, IPPROTO_IPV6, IPV6_V6ONLY, (char *) &flags, sizeof(flags));
            if (error != 0) {
                perror(""set...",47,,3511,4,,void
38749,BLOCK,-1,,"{
            /* getaddrinfo can return ""junk"" addresses,
             * we make sure at least one works before erroring.
             */
            if (errno == EMFILE) {
                /* ...unless we're out of fds */
                perror(""server_socket"");
                exit(EX_OSERR);
            }
            continue;
        }",45,,3513,2,,void
38754,BLOCK,-1,,"{
                /* ...unless we're out of fds */
                perror(""server_socket"");
                exit(EX_OSERR);
            }",34,,3517,2,,void
38764,BLOCK,-1,,"{
            socklen_t len = sizeof(socklen_t);
            int napi_id;
            error = getsockopt(sfd, SOL_SOCKET, SO_INCOMING_NAPI_ID, &napi_id, &len);
            if (error != 0) {
                fprintf(stderr, ""-N <num_napi_ids> option not supported\n"");
                exit(EXIT_FAILURE);
            }
        }",36,,3525,2,,void
38777,BLOCK,1,,<empty>,,,,1,,void
38787,BLOCK,-1,,"{
                fprintf(stderr, ""-N <num_napi_ids> option not supported\n"");
                exit(EXIT_FAILURE);
            }",29,,3529,2,,void
38806,BLOCK,1,,<empty>,,,,2,,void
38810,BLOCK,-1,,"{
            maximize_sndbuf(sfd);
        }",32,,3554,2,,void
38814,BLOCK,-1,,"{
            error = setsockopt(sfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flags, sizeof(flags));
            if (error != 0)
                perror(""setsockopt"");

            error = setsockopt(sfd, SOL_SOCKET, SO_LINGER, (void *)&ling, sizeof(ling));
            if (error != 0)
                perror(""setsockopt"");

            error = setsockopt(sfd, IPPROTO_TCP, TCP_NODELAY, (void *)&flags, sizeof(flags));
            if (error != 0)
                perror(""setsockopt"");
        }",16,,3556,1,,void
38831,BLOCK,-1,,<empty>,17,,3559,2,,void
38850,BLOCK,-1,,<empty>,17,,3563,2,,void
38869,BLOCK,-1,,<empty>,17,,3567,2,,void
38884,BLOCK,-1,,"{
            if (errno != EADDRINUSE) {
                perror(""bind()"");
                close(sfd);
                freeaddrinfo(ai);
                return 1;
            }
            close(sfd);
            continue;
        }",63,,3570,2,,void
38889,BLOCK,-1,,"{
                perror(""bind()"");
                close(sfd);
                freeaddrinfo(ai);
                return 1;
            }",38,,3571,2,,void
38902,BLOCK,-1,,"{
            success++;
            if (!IS_UDP(transport) && listen(sfd, settings.backlog) == -1) {
                perror(""listen()"");
                close(sfd);
                freeaddrinfo(ai);
                return 1;
            }
            if (portnumber_file != NULL &&
                (next->ai_addr->sa_family == AF_INET ||
                 next->ai_addr->sa_family == AF_INET6)) {
                union {
                    struct sockaddr_in in;
                    struct sockaddr_in6 in6;
                } my_sockaddr;
                socklen_t len = sizeof(my_sockaddr);
                if (getsockname(sfd, (struct sockaddr*)&my_sockaddr, &len)==0) {
                    if (next->ai_addr->sa_family == AF_INET) {
                        fprintf(portnumber_file, ""%s INET: %u\n"",
                                IS_UDP(transport) ? ""UDP"" : ""TCP"",
                                ntohs(my_sockaddr.in.sin_port));
                    } else {
                        fprintf(p...",16,,3579,1,,void
38910,BLOCK,1,,<empty>,,,,2,,void
38922,BLOCK,-1,,"{
                perror(""listen()"");
                close(sfd);
                freeaddrinfo(ai);
                return 1;
            }",76,,3581,2,,void
38951,BLOCK,-1,,"{
                union {
                    struct sockaddr_in in;
                    struct sockaddr_in6 in6;
                } my_sockaddr;
                socklen_t len = sizeof(my_sockaddr);
                if (getsockname(sfd, (struct sockaddr*)&my_sockaddr, &len)==0) {
                    if (next->ai_addr->sa_family == AF_INET) {
                        fprintf(portnumber_file, ""%s INET: %u\n"",
                                IS_UDP(transport) ? ""UDP"" : ""TCP"",
                                ntohs(my_sockaddr.in.sin_port));
                    } else {
                        fprintf(portnumber_file, ""%s INET6: %u\n"",
                                IS_UDP(transport) ? ""UDP"" : ""TCP"",
                                ntohs(my_sockaddr.in6.sin6_port));
                    }
                }
            }",57,,3589,2,,void
38969,BLOCK,-1,,"{
                    if (next->ai_addr->sa_family == AF_INET) {
                        fprintf(portnumber_file, ""%s INET: %u\n"",
                                IS_UDP(transport) ? ""UDP"" : ""TCP"",
                                ntohs(my_sockaddr.in.sin_port));
                    } else {
                        fprintf(portnumber_file, ""%s INET6: %u\n"",
                                IS_UDP(transport) ? ""UDP"" : ""TCP"",
                                ntohs(my_sockaddr.in6.sin6_port));
                    }
                }",80,,3595,2,,void
38978,BLOCK,-1,,"{
                        fprintf(portnumber_file, ""%s INET: %u\n"",
                                IS_UDP(transport) ? ""UDP"" : ""TCP"",
                                ntohs(my_sockaddr.in.sin_port));
                    }",62,,3596,2,,void
38984,BLOCK,1,,<empty>,,,,2,,void
38998,BLOCK,-1,,"{
                        fprintf(portnumber_file, ""%s INET6: %u\n"",
                                IS_UDP(transport) ? ""UDP"" : ""TCP"",
                                ntohs(my_sockaddr.in6.sin6_port));
                    }",28,,3600,1,,void
39004,BLOCK,1,,<empty>,,,,2,,void
39020,BLOCK,1,,<empty>,,,,2,,void
39024,BLOCK,-1,,"{
            int c;

            for (c = 0; c < settings.num_threads_per_udp; c++) {
                /* Allocate one UDP file descriptor per worker thread;
                 * this allows ""stats conns"" to separately list multiple
                 * parallel UDP requests in progress.
                 *
                 * The dispatch code round-robins new connection requests
                 * among threads, so this is guaranteed to assign one
                 * FD to each thread.
                 */
                int per_thread_fd;
                if (c == 0) {
                    per_thread_fd = sfd;
                } else {
                    per_thread_fd = dup(sfd);
                    if (per_thread_fd < 0) {
                        perror(""Failed to duplicate file descriptor"");
                        exit(EXIT_FAILURE);
                    }
                }
                dispatch_conn_new(per_thread_fd, conn_read,
                                  EV_READ | EV_PERSIST...",32,,3609,2,,void
39027,BLOCK,-1,,<empty>,13,,3612,1,,void
39038,BLOCK,4,,"{
                /* Allocate one UDP file descriptor per worker thread;
                 * this allows ""stats conns"" to separately list multiple
                 * parallel UDP requests in progress.
                 *
                 * The dispatch code round-robins new connection requests
                 * among threads, so this is guaranteed to assign one
                 * FD to each thread.
                 */
                int per_thread_fd;
                if (c == 0) {
                    per_thread_fd = sfd;
                } else {
                    per_thread_fd = dup(sfd);
                    if (per_thread_fd < 0) {
                        perror(""Failed to duplicate file descriptor"");
                        exit(EXIT_FAILURE);
                    }
                }
                dispatch_conn_new(per_thread_fd, conn_read,
                                  EV_READ | EV_PERSIST,
                                  UDP_READ_BUFFER_SIZE, transport, NULL, conntag, b...",64,,3612,4,,void
39044,BLOCK,-1,,"{
                    per_thread_fd = sfd;
                }",29,,3622,2,,void
39049,BLOCK,-1,,"{
                    per_thread_fd = dup(sfd);
                    if (per_thread_fd < 0) {
                        perror(""Failed to duplicate file descriptor"");
                        exit(EXIT_FAILURE);
                    }
                }",24,,3624,1,,void
39058,BLOCK,-1,,"{
                        perror(""Failed to duplicate file descriptor"");
                        exit(EXIT_FAILURE);
                    }",44,,3626,2,,void
39070,BLOCK,1,,<empty>,,,,1,,void
39077,BLOCK,-1,,"{
            if (!(listen_conn_add = conn_new(sfd, conn_listening,
                                             EV_READ | EV_PERSIST, 1,
                                             transport, main_base, NULL, conntag, bproto))) {
                fprintf(stderr, ""failed to create listening connection\n"");
                exit(EXIT_FAILURE);
            }
#ifdef TLS
            listen_conn_add->ssl_enabled = ssl_enabled;
#else
            assert(ssl_enabled == false);
#endif
            listen_conn_add->next = listen_conn;
            listen_conn = listen_conn_add;
        }",16,,3635,1,,void
39094,BLOCK,-1,,"{
                fprintf(stderr, ""failed to create listening connection\n"");
                exit(EXIT_FAILURE);
            }",93,,3638,2,,void
39124,BLOCK,-1,,"{
    bool ssl_enabled = false;
    uint64_t conntag = 0;

#ifdef TLS
    const char *notls = ""notls"";
    ssl_enabled = settings.ssl_enabled;
#endif

    if (settings.inter == NULL) {
        return server_socket(settings.inter, port, transport, portnumber_file, ssl_enabled, conntag, settings.binding_protocol);
    } else {
        // tokenize them and bind to each one of them..
        char *b;
        int ret = 0;
        char *list = strdup(settings.inter);

        if (list == NULL) {
            fprintf(stderr, ""Failed to allocate memory for parsing server interface string\n"");
            return 1;
        }
        // If we encounter any failure, preserve the first errno for the caller.
        int errno_save = 0;
        for (char *p = strtok_r(list, "";,"", &b);
            p != NULL;
            p = strtok_r(NULL, "";,"", &b)) {
            int the_port = port;
#ifdef TLS
            ssl_enabled = settings.ssl_enabled;
            // ""notls"" option is valid only when memcache...",50,,3659,4,,void
39139,BLOCK,-1,,"{
        return server_socket(settings.inter, port, transport, portnumber_file, ssl_enabled, conntag, settings.binding_protocol);
    }",33,,3668,2,,void
39154,BLOCK,-1,,"{
        // tokenize them and bind to each one of them..
        char *b;
        int ret = 0;
        char *list = strdup(settings.inter);

        if (list == NULL) {
            fprintf(stderr, ""Failed to allocate memory for parsing server interface string\n"");
            return 1;
        }
        // If we encounter any failure, preserve the first errno for the caller.
        int errno_save = 0;
        for (char *p = strtok_r(list, "";,"", &b);
            p != NULL;
            p = strtok_r(NULL, "";,"", &b)) {
            int the_port = port;
#ifdef TLS
            ssl_enabled = settings.ssl_enabled;
            // ""notls"" option is valid only when memcached is run with SSL enabled.
            if (strncmp(p, notls, strlen(notls)) == 0) {
                if (!settings.ssl_enabled) {
                    fprintf(stderr, ""'notls' option is valid only when SSL is enabled\n"");
                    free(list);
                    return 1;
                }
                ssl_enabl...",12,,3670,1,,void
39171,BLOCK,-1,,"{
            fprintf(stderr, ""Failed to allocate memory for parsing server interface string\n"");
            return 1;
        }",27,,3676,2,,void
39182,BLOCK,-1,,<empty>,9,,3682,1,,void
39201,BLOCK,4,,"{
            int the_port = port;
#ifdef TLS
            ssl_enabled = settings.ssl_enabled;
            // ""notls"" option is valid only when memcached is run with SSL enabled.
            if (strncmp(p, notls, strlen(notls)) == 0) {
                if (!settings.ssl_enabled) {
                    fprintf(stderr, ""'notls' option is valid only when SSL is enabled\n"");
                    free(list);
                    return 1;
                }
                ssl_enabled = false;
                p += strlen(notls) + 1;
            }
#endif

            // Allow forcing the protocol of this listener.
            const char *protostr = ""proto"";
            enum protocol bproto = settings.binding_protocol;
            if (strncmp(p, protostr, strlen(protostr)) == 0) {
                p += strlen(protostr);
                if (*p == '[') {
                    char *e = strchr(p, ']');
                    if (e == NULL) {
                        fprintf(stderr, ""Invalid protocol spec:...",43,,3684,4,,void
39224,BLOCK,-1,,"{
                p += strlen(protostr);
                if (*p == '[') {
                    char *e = strchr(p, ']');
                    if (e == NULL) {
                        fprintf(stderr, ""Invalid protocol spec: \""%s\""\n"", p);
                        free(list);
                        return 1;
                    }
                    char *st = ++p; // skip '[';
                    *e = '\0';
                    size_t len = e - st;
                    p = ++e; // skip ']'
                    p++; // skip an assumed ':'

                    if (strncmp(st, ""ascii"", len) == 0) {
                        bproto = ascii_prot;
                    } else if (strncmp(st, ""binary"", len) == 0) {
                        bproto = binary_prot;
                    } else if (strncmp(st, ""negotiating"", len) == 0) {
                        bproto = negotiating_prot;
                    } else if (strncmp(st, ""proxy"", len) == 0) {
#ifdef PROXY
                        if (settings.proxy_...",62,,3703,2,,void
39234,BLOCK,-1,,"{
                    char *e = strchr(p, ']');
                    if (e == NULL) {
                        fprintf(stderr, ""Invalid protocol spec: \""%s\""\n"", p);
                        free(list);
                        return 1;
                    }
                    char *st = ++p; // skip '[';
                    *e = '\0';
                    size_t len = e - st;
                    p = ++e; // skip ']'
                    p++; // skip an assumed ':'

                    if (strncmp(st, ""ascii"", len) == 0) {
                        bproto = ascii_prot;
                    } else if (strncmp(st, ""binary"", len) == 0) {
                        bproto = binary_prot;
                    } else if (strncmp(st, ""negotiating"", len) == 0) {
                        bproto = negotiating_prot;
                    } else if (strncmp(st, ""proxy"", len) == 0) {
#ifdef PROXY
                        if (settings.proxy_enabled) {
                            bproto = proxy_prot;
            ...",32,,3705,2,,void
39245,BLOCK,-1,,"{
                        fprintf(stderr, ""Invalid protocol spec: \""%s\""\n"", p);
                        free(list);
                        return 1;
                    }",36,,3707,2,,void
39282,BLOCK,-1,,"{
                        bproto = ascii_prot;
                    }",57,,3718,2,,void
39287,BLOCK,-1,,<empty>,28,,3720,1,,void
39295,BLOCK,-1,,"{
                        bproto = binary_prot;
                    }",65,,3720,2,,void
39300,BLOCK,-1,,<empty>,28,,3722,1,,void
39308,BLOCK,-1,,"{
                        bproto = negotiating_prot;
                    }",70,,3722,2,,void
39313,BLOCK,-1,,<empty>,28,,3724,1,,void
39321,BLOCK,-1,,"{
#ifdef PROXY
                        if (settings.proxy_enabled) {
                            bproto = proxy_prot;
                        } else {
                            fprintf(stderr, ""Proxy must be enabled to use: \""%s\""\n"", list);
                            free(list);
                            return 1;
                        }
#else
                        fprintf(stderr, ""Server not built with proxy: \""%s\""\n"", list);
                        free(list);
                        return 1;
#endif
                    }",64,,3724,2,,void
39342,BLOCK,-1,,"{
                p += strlen(tagstr);
                if (*p == '[') {
                    char *e = strchr(p, ']');
                    if (e == NULL) {
                        fprintf(stderr, ""Invalid tag in socket config: \""%s\""\n"", p);
                        free(list);
                        return 1;
                    }
                    char *st = ++p; // skip '['
                    *e = '\0';
                    size_t len = e - st;
                    p = ++e; // skip ']'
                    p++; // skip an assumed ':'

                    // validate the tag and copy it in.
                    if (len > 8 || len < 1) {
                        fprintf(stderr, ""Listener tags must be between 1 and 8 characters: \""%s\""\n"", st);
                        free(list);
                        return 1;
                    }

                    // C programmers love turning string comparisons into
                    // integer comparisons.
                    memcpy(&connta...",58,,3743,2,,void
39352,BLOCK,-1,,"{
                    char *e = strchr(p, ']');
                    if (e == NULL) {
                        fprintf(stderr, ""Invalid tag in socket config: \""%s\""\n"", p);
                        free(list);
                        return 1;
                    }
                    char *st = ++p; // skip '['
                    *e = '\0';
                    size_t len = e - st;
                    p = ++e; // skip ']'
                    p++; // skip an assumed ':'

                    // validate the tag and copy it in.
                    if (len > 8 || len < 1) {
                        fprintf(stderr, ""Listener tags must be between 1 and 8 characters: \""%s\""\n"", st);
                        free(list);
                        return 1;
                    }

                    // C programmers love turning string comparisons into
                    // integer comparisons.
                    memcpy(&conntag, st, len);
                }",32,,3745,2,,void
39363,BLOCK,-1,,"{
                        fprintf(stderr, ""Invalid tag in socket config: \""%s\""\n"", p);
                        free(list);
                        return 1;
                    }",36,,3747,2,,void
39401,BLOCK,-1,,"{
                        fprintf(stderr, ""Listener tags must be between 1 and 8 characters: \""%s\""\n"", st);
                        free(list);
                        return 1;
                    }",45,,3759,2,,void
39424,BLOCK,-1,,"{
                // expecting it to be an IPv6 address enclosed in []
                // i.e. RFC3986 style recommended by RFC5952
                char *e = strchr(p, ']');
                if (e == NULL) {
                    fprintf(stderr, ""Invalid IPV6 address: \""%s\"""", p);
                    free(list);
                    return 1;
                }
                h = ++p; // skip the opening '['
                *e = '\0';
                p = ++e; // skip the closing ']'
            }",28,,3772,2,,void
39435,BLOCK,-1,,"{
                    fprintf(stderr, ""Invalid IPV6 address: \""%s\"""", p);
                    free(list);
                    return 1;
                }",32,,3776,2,,void
39466,BLOCK,-1,,"{
                // If no more semicolons - attempt to treat as port number.
                // Otherwise the only valid option is an unenclosed IPv6 without port, until
                // of course there was an RFC3986 IPv6 address previously specified -
                // in such a case there is no good option, will just send it to fail as port number.
                if (strchr(s + 1, ':') == NULL || h != NULL) {
                    *s = '\0';
                    ++s;
                    if (!safe_strtol(s, &the_port)) {
                        fprintf(stderr, ""Invalid port number: \""%s\""\n"", s);
                        free(list);
                        return 1;
                    }
                }
            }",28,,3787,2,,void
39479,BLOCK,-1,,"{
                    *s = '\0';
                    ++s;
                    if (!safe_strtol(s, &the_port)) {
                        fprintf(stderr, ""Invalid port number: \""%s\""\n"", s);
                        free(list);
                        return 1;
                    }
                }",62,,3792,2,,void
39492,BLOCK,-1,,"{
                        fprintf(stderr, ""Invalid port number: \""%s\""\n"", s);
                        free(list);
                        return 1;
                    }",53,,3795,2,,void
39505,BLOCK,-1,,<empty>,17,,3804,2,,void
39515,BLOCK,-1,,"{
                p = NULL;
            }",38,,3806,2,,void
39537,BLOCK,-1,,<empty>,46,,3810,2,,void
39552,BLOCK,-1,,"{
    int sfd;
    int flags;

    if ((sfd = socket(AF_UNIX, SOCK_STREAM, 0)) == -1) {
        perror(""socket()"");
        return -1;
    }

    if ((flags = fcntl(sfd, F_GETFL, 0)) < 0 ||
        fcntl(sfd, F_SETFL, flags | O_NONBLOCK) < 0) {
        perror(""setting O_NONBLOCK"");
        close(sfd);
        return -1;
    }
    return sfd;
}",34,,3819,2,,void
39565,BLOCK,-1,,"{
        perror(""socket()"");
        return -1;
    }",56,,3823,2,,void
39589,BLOCK,-1,,"{
        perror(""setting O_NONBLOCK"");
        close(sfd);
        return -1;
    }",54,,3829,2,,void
39604,BLOCK,-1,,"{
    int sfd;
    struct linger ling = {0, 0};
    struct sockaddr_un addr;
    struct stat tstat;
    int flags =1;
    int old_umask;

    if (!path) {
        return 1;
    }

    if ((sfd = new_socket_unix()) == -1) {
        return 1;
    }

    /*
     * Clean up a previous socket file if we left it around
     */
    if (lstat(path, &tstat) == 0) {
        if (S_ISSOCK(tstat.st_mode))
            unlink(path);
    }

    setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void *)&flags, sizeof(flags));
    setsockopt(sfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flags, sizeof(flags));
    setsockopt(sfd, SOL_SOCKET, SO_LINGER, (void *)&ling, sizeof(ling));

    /*
     * the memset call clears nonstandard fields in some implementations
     * that otherwise mess things up.
     */
    memset(&addr, 0, sizeof(addr));

    addr.sun_family = AF_UNIX;
    strncpy(addr.sun_path, path, sizeof(addr.sun_path) - 1);
    assert(strcmp(addr.sun_path, path) == 0);
    old_umask = umask( ~(access_mask&...",66,,3837,3,,void
39622,BLOCK,-1,,"{
        return 1;
    }",16,,3845,2,,void
39632,BLOCK,-1,,"{
        return 1;
    }",42,,3849,2,,void
39642,BLOCK,-1,,"{
        if (S_ISSOCK(tstat.st_mode))
            unlink(path);
    }",35,,3856,2,,void
39648,BLOCK,-1,,<empty>,13,,3858,2,,void
39730,BLOCK,-1,,"{
        perror(""bind()"");
        close(sfd);
        umask(old_umask);
        return 1;
    }",66,,3875,2,,void
39750,BLOCK,-1,,"{
        perror(""listen()"");
        close(sfd);
        return 1;
    }",46,,3882,2,,void
39775,BLOCK,-1,,"{
        fprintf(stderr, ""failed to create listening connection\n"");
        exit(EXIT_FAILURE);
    }",100,,3889,2,,void
39792,BLOCK,-1,,"{
    struct timeval t = {.tv_sec = 1, .tv_usec = 0};
    static bool initialized = false;

    if (initialized) {
        /* only delete the event if it's actually there. */
        evtimer_del(&clockevent);
    } else {
        initialized = true;
    }

    // While we're here, check for hash table expansion.
    // This function should be quick to avoid delaying the timer.
    assoc_start_expand(stats_state.curr_items);
    // also, if HUP'ed we need to do some maintenance.
    // for now that's just the authfile reload.
    if (settings.sig_hup) {
        settings.sig_hup = false;

        authfile_load(settings.auth_file);
#ifdef PROXY
        if (settings.proxy_ctx) {
            proxy_start_reload(settings.proxy_ctx);
        }
#endif
    }

    evtimer_set(&clockevent, clock_handler, 0);
    event_base_set(main_base, &clockevent);
    evtimer_add(&clockevent, &t);

#ifdef MEMCACHED_DEBUG
    if (is_paused) return;
#endif

#if defined(HAVE_CLOCK_GETTIME) && defined(CLOCK_MON...",83,,3923,4,,void
39797,BLOCK,1,,<empty>,25,,3924,1,,void
39801,BLOCK,2,,<empty>,38,,3924,2,,void
39811,BLOCK,-1,,"{
        /* only delete the event if it's actually there. */
        evtimer_del(&clockevent);
    }",22,,3927,2,,void
39816,BLOCK,-1,,"{
        initialized = true;
    }",12,,3930,1,,void
39828,BLOCK,-1,,"{
        settings.sig_hup = false;

        authfile_load(settings.auth_file);
#ifdef PROXY
        if (settings.proxy_ctx) {
            proxy_start_reload(settings.proxy_ctx);
        }
#endif
    }",27,,3939,2,,void
39852,BLOCK,11,,"{
        struct timeval tv;
        gettimeofday(&tv, NULL);
#ifdef MEMCACHED_DEBUG
        current_time = (rel_time_t) (tv.tv_sec - process_started + delta);
#else
        current_time = (rel_time_t) (tv.tv_sec - process_started);
#endif
    }",5,,3971,11,,void
39871,BLOCK,-1,,"{
    return (flag ? ""enabled"" : ""disabled"");
}",53,,3982,2,,void
39882,BLOCK,-1,,"{
    if (!condition) {
        printf(""Default value of [%s] has changed.""
            "" Modify the help text and default value check.\n"", param);
        exit(EXIT_FAILURE);
    }
}",63,,3986,3,,void
39886,BLOCK,-1,,"{
        printf(""Default value of [%s] has changed.""
            "" Modify the help text and default value check.\n"", param);
        exit(EXIT_FAILURE);
    }",21,,3987,2,,void
39896,BLOCK,-1,,"{
    printf(PACKAGE "" "" VERSION ""\n"");
    printf(""-p, --port=<num>          TCP port to listen on (default: %d)\n""
           ""-U, --udp-port=<num>      UDP port to listen on (default: %d, off)\n"",
           settings.port, settings.udpport);
#ifndef DISABLE_UNIX_SOCKET
    printf(""-s, --unix-socket=<file>  UNIX socket to listen on (disables network support)\n"");
    printf(""-a, --unix-mask=<mask>    access mask for UNIX socket, in octal (default: %o)\n"",
            settings.access);
#endif /* #ifndef DISABLE_UNIX_SOCKET */
    printf(""-A, --enable-shutdown     enable ascii \""shutdown\"" command\n"");
    printf(""-l, --listen=<addr>       interface to listen on (default: INADDR_ANY)\n"");
#ifdef TLS
    printf(""                          if TLS/SSL is enabled, 'notls' prefix can be used to\n""
           ""                          disable for specific listeners (-l notls:<ip>:<port>) \n"");
#endif
    printf(""-d, --daemon              run as a daemon\n""
           ""-r, --enable-coredum...",25,,3994,2,,void
39985,BLOCK,1,,<empty>,,,,1,,void
39992,BLOCK,1,,<empty>,,,,1,,void
40088,BLOCK,1,,<empty>,,,,1,,void
40111,BLOCK,-1,,"{
    printf(PACKAGE "" "" VERSION ""\n\n"");
    printf(
    ""Copyright (c) 2003, Danga Interactive, Inc. <http://www.danga.com/>\n""
    ""All rights reserved.\n""
    ""\n""
    ""Redistribution and use in source and binary forms, with or without\n""
    ""modification, are permitted provided that the following conditions are\n""
    ""met:\n""
    ""\n""
    ""    * Redistributions of source code must retain the above copyright\n""
    ""notice, this list of conditions and the following disclaimer.\n""
    ""\n""
    ""    * Redistributions in binary form must reproduce the above\n""
    ""copyright notice, this list of conditions and the following disclaimer\n""
    ""in the documentation and/or other materials provided with the\n""
    ""distribution.\n""
    ""\n""
    ""    * Neither the name of the Danga Interactive nor the names of its\n""
    ""contributors may be used to endorse or promote products derived from\n""
    ""this software without specific prior written permission.\n""
    ""\n""
    ""THIS SOFTWARE ...",33,,4189,2,,void
40120,BLOCK,-1,,"{
    FILE *fp;
    if (access(pid_file, F_OK) == 0) {
        if ((fp = fopen(pid_file, ""r"")) != NULL) {
            char buffer[1024];
            if (fgets(buffer, sizeof(buffer), fp) != NULL) {
                unsigned int pid;
                if (safe_strtoul(buffer, &pid) && kill((pid_t)pid, 0) == 0) {
                    fprintf(stderr, ""WARNING: The pid file contained the following (running) pid: %u\n"", pid);
                }
            }
            fclose(fp);
        }
    }

    /* Create the pid file first with a temporary name, then
     * atomically move the file to the real name to avoid a race with
     * another process opening the file to read the pid, but finding
     * it empty.
     */
    char tmp_pid_file[1024];
    snprintf(tmp_pid_file, sizeof(tmp_pid_file), ""%s.tmp"", pid_file);

    if ((fp = fopen(tmp_pid_file, ""w"")) == NULL) {
        vperror(""Could not open the pid file %s for writing"", tmp_pid_file);
        return;
    }

    fprintf(fp,""%ld\n"", (lo...",44,,4260,2,,void
40128,BLOCK,-1,,"{
        if ((fp = fopen(pid_file, ""r"")) != NULL) {
            char buffer[1024];
            if (fgets(buffer, sizeof(buffer), fp) != NULL) {
                unsigned int pid;
                if (safe_strtoul(buffer, &pid) && kill((pid_t)pid, 0) == 0) {
                    fprintf(stderr, ""WARNING: The pid file contained the following (running) pid: %u\n"", pid);
                }
            }
            fclose(fp);
        }
    }",38,,4262,2,,void
40137,BLOCK,-1,,"{
            char buffer[1024];
            if (fgets(buffer, sizeof(buffer), fp) != NULL) {
                unsigned int pid;
                if (safe_strtoul(buffer, &pid) && kill((pid_t)pid, 0) == 0) {
                    fprintf(stderr, ""WARNING: The pid file contained the following (running) pid: %u\n"", pid);
                }
            }
            fclose(fp);
        }",50,,4263,2,,void
40147,BLOCK,-1,,"{
                unsigned int pid;
                if (safe_strtoul(buffer, &pid) && kill((pid_t)pid, 0) == 0) {
                    fprintf(stderr, ""WARNING: The pid file contained the following (running) pid: %u\n"", pid);
                }
            }",60,,4265,2,,void
40162,BLOCK,-1,,"{
                    fprintf(stderr, ""WARNING: The pid file contained the following (running) pid: %u\n"", pid);
                }",77,,4267,2,,void
40184,BLOCK,-1,,"{
        vperror(""Could not open the pid file %s for writing"", tmp_pid_file);
        return;
    }",50,,4283,2,,void
40201,BLOCK,-1,,"{
        vperror(""Could not close the pid file %s"", tmp_pid_file);
    }",27,,4289,2,,void
40211,BLOCK,-1,,"{
        vperror(""Could not rename the pid file from %s to %s"",
                tmp_pid_file, pid_file);
    }",46,,4293,2,,void
40220,BLOCK,-1,,"{
  if (pid_file == NULL)
      return;

  if (unlink(pid_file) != 0) {
      vperror(""Could not remove the pid file %s"", pid_file);
  }

}",50,,4299,2,,void
40225,BLOCK,-1,,<empty>,7,,4301,2,,void
40232,BLOCK,-1,,"{
      vperror(""Could not remove the pid file %s"", pid_file);
  }",30,,4303,2,,void
40240,BLOCK,-1,,"{
    stop_main_loop = EXIT_NORMALLY;
    printf(""Signal handled: %s.\n"", strsignal(sig));
}",40,,4309,2,,void
40252,BLOCK,-1,,"{
    settings.sig_hup = true;
}",43,,4314,2,,void
40262,BLOCK,-1,,"{
    printf(""Graceful shutdown signal handled: %s.\n"", strsignal(sig));
    stop_main_loop = GRACE_STOP;
}",43,,4318,2,,void
40274,BLOCK,-1,,"{
#if defined(HAVE_GETPAGESIZES) && defined(HAVE_MEMCNTL)
    int ret = -1;
    size_t sizes[32];
    int avail = getpagesizes(sizes, 32);
    if (avail != -1) {
        size_t max = sizes[0];
        struct memcntl_mha arg = {0};
        int ii;

        for (ii = 1; ii < avail; ++ii) {
            if (max < sizes[ii]) {
                max = sizes[ii];
            }
        }

        arg.mha_flags   = 0;
        arg.mha_pagesize = max;
        arg.mha_cmd = MHA_MAPSIZE_BSSBRK;

        if (memcntl(0, 0, MC_HAT_ADVISE, (caddr_t)&arg, 0, 0) == -1) {
            fprintf(stderr, ""Failed to set large pages: %s\n"",
                    strerror(errno));
            fprintf(stderr, ""Will use default page size\n"");
        } else {
            ret = 0;
        }
    } else {
        fprintf(stderr, ""Failed to get supported pagesizes: %s\n"",
                strerror(errno));
        fprintf(stderr, ""Will use default page size\n"");
    }

    return ret;
#elif defined(__linux__) && defined(...",37,,4327,2,,void
40282,BLOCK,-1,,"{
    /* One of our biggest problems is old and bogus libevents */
    const char *ever = event_get_version();
    if (ever != NULL) {
        if (strncmp(ever, ""1."", 2) == 0) {
            fprintf(stderr, ""You are using libevent %s.\nPlease upgrade to 2.x""
                        "" or newer\n"", event_get_version());
            return false;
        }
    }

    return true;
}",31,,4420,2,,void
40291,BLOCK,-1,,"{
        if (strncmp(ever, ""1."", 2) == 0) {
            fprintf(stderr, ""You are using libevent %s.\nPlease upgrade to 2.x""
                        "" or newer\n"", event_get_version());
            return false;
        }
    }",23,,4423,2,,void
40299,BLOCK,-1,,"{
            fprintf(stderr, ""You are using libevent %s.\nPlease upgrade to 2.x""
                        "" or newer\n"", event_get_version());
            return false;
        }",42,,4424,2,,void
40313,BLOCK,-1,,"{
    char *b = NULL;
    uint32_t size = 0;
    int i = 0;
    uint32_t last_size = 0;

    if (strlen(s) < 1)
        return false;

    for (char *p = strtok_r(s, ""-"", &b);
         p != NULL;
         p = strtok_r(NULL, ""-"", &b)) {
        if (!safe_strtoul(p, &size) || size < settings.chunk_size
             || size > settings.slab_chunk_size_max) {
            fprintf(stderr, ""slab size %u is out of valid range\n"", size);
            return false;
        }
        if (last_size >= size) {
            fprintf(stderr, ""slab size %u cannot be lower than or equal to a previous class size\n"", size);
            return false;
        }
        if (size <= last_size + CHUNK_ALIGN_BYTES) {
            fprintf(stderr, ""slab size %u must be at least %d bytes larger than previous class\n"",
                    size, CHUNK_ALIGN_BYTES);
            return false;
        }
        slab_sizes[i++] = size;
        last_size = size;
        if (i >= MAX_NUMBER_OF_SLAB_CLASSES-1) {
           ...",62,,4434,3,,void
40335,BLOCK,-1,,<empty>,9,,4441,2,,void
40339,BLOCK,-1,,<empty>,5,,4443,1,,void
40358,BLOCK,4,,"{
        if (!safe_strtoul(p, &size) || size < settings.chunk_size
             || size > settings.slab_chunk_size_max) {
            fprintf(stderr, ""slab size %u is out of valid range\n"", size);
            return false;
        }
        if (last_size >= size) {
            fprintf(stderr, ""slab size %u cannot be lower than or equal to a previous class size\n"", size);
            return false;
        }
        if (size <= last_size + CHUNK_ALIGN_BYTES) {
            fprintf(stderr, ""slab size %u must be at least %d bytes larger than previous class\n"",
                    size, CHUNK_ALIGN_BYTES);
            return false;
        }
        slab_sizes[i++] = size;
        last_size = size;
        if (i >= MAX_NUMBER_OF_SLAB_CLASSES-1) {
            fprintf(stderr, ""too many slab classes specified\n"");
            return false;
        }
    }",39,,4445,4,,void
40377,BLOCK,-1,,"{
            fprintf(stderr, ""slab size %u is out of valid range\n"", size);
            return false;
        }",54,,4447,2,,void
40388,BLOCK,-1,,"{
            fprintf(stderr, ""slab size %u cannot be lower than or equal to a previous class size\n"", size);
            return false;
        }",32,,4451,2,,void
40401,BLOCK,1,,<empty>,,,,1,,void
40403,BLOCK,-1,,"{
            fprintf(stderr, ""slab size %u must be at least %d bytes larger than previous class\n"",
                    size, CHUNK_ALIGN_BYTES);
            return false;
        }",52,,4455,2,,void
40409,BLOCK,1,,<empty>,,,,1,,void
40427,BLOCK,1,,<empty>,,,,1,,void
40432,BLOCK,-1,,"{
            fprintf(stderr, ""too many slab classes specified\n"");
            return false;
        }",48,,4462,2,,void
40458,BLOCK,-1,,"{
    struct _mc_meta_data *meta = (struct _mc_meta_data *)data;

    // Settings to remember.
    // TODO: should get a version of version which is numeric, else
    // comparisons for compat reasons are difficult.
    // it may be possible to punt on this for now; since we can test for the
    // absence of another key... such as the new numeric version.
    //restart_set_kv(ctx, ""version"", ""%s"", VERSION);
    // We hold the original factor or subopts _string_
    // it can be directly compared without roundtripping through floats or
    // serializing/deserializing the long options list.
    restart_set_kv(ctx, ""slab_config"", ""%s"", meta->slab_config);
    restart_set_kv(ctx, ""maxbytes"", ""%llu"", (unsigned long long) settings.maxbytes);
    restart_set_kv(ctx, ""chunk_size"", ""%d"", settings.chunk_size);
    restart_set_kv(ctx, ""item_size_max"", ""%d"", settings.item_size_max);
    restart_set_kv(ctx, ""slab_chunk_size_max"", ""%d"", settings.slab_chunk_size_max);
    restart_set_kv(ctx, ""sl...",69,,4487,4,,void
40541,BLOCK,13,,"{
        struct timeval tv;
        gettimeofday(&tv, NULL);
        restart_set_kv(ctx, ""stop_time"", ""%lu"", tv.tv_sec);
    }",5,,4519,13,,void
40604,BLOCK,-1,,"{
    struct _mc_meta_data *meta = (struct _mc_meta_data *)data;
    char *key;
    char *val;
    int reuse_mmap = 0;
    meta->process_started = 0;
    meta->time_delta = 0;
    meta->current_time = 0;
    int lines_seen = 0;

    // TODO: not sure this is any better than just doing an if/else tree with
    // strcmp's...
    enum {
        R_MMAP_OLDBASE = 0,
        R_MAXBYTES,
        R_CHUNK_SIZE,
        R_ITEM_SIZE_MAX,
        R_SLAB_CHUNK_SIZE_MAX,
        R_SLAB_PAGE_SIZE,
        R_SLAB_CONFIG,
        R_USE_CAS,
        R_SLAB_REASSIGN,
        R_CURRENT_CAS,
        R_OLDEST_CAS,
        R_OLDEST_LIVE,
        R_LOGGER_GID,
        R_CURRENT_TIME,
        R_STOP_TIME,
        R_PROCESS_STARTED,
        R_HASHPOWER,
    };

    const char *opts[] = {
        [R_MMAP_OLDBASE] = ""mmap_oldbase"",
        [R_MAXBYTES] = ""maxbytes"",
        [R_CHUNK_SIZE] = ""chunk_size"",
        [R_ITEM_SIZE_MAX] = ""item_size_max"",
        [R_SLAB_CHUNK_SIZE_MAX] = ""slab_chunk_size_max"",
    ...",69,,4551,4,,void
40640,BLOCK,1,,<empty>,9,,4584,1,,void
40644,BLOCK,2,,<empty>,9,,4585,2,,void
40648,BLOCK,3,,<empty>,9,,4586,3,,void
40652,BLOCK,4,,<empty>,9,,4587,4,,void
40656,BLOCK,5,,<empty>,9,,4588,5,,void
40660,BLOCK,6,,<empty>,9,,4589,6,,void
40664,BLOCK,7,,<empty>,9,,4590,7,,void
40668,BLOCK,8,,<empty>,9,,4591,8,,void
40672,BLOCK,9,,<empty>,9,,4592,9,,void
40676,BLOCK,10,,<empty>,9,,4593,10,,void
40680,BLOCK,11,,<empty>,9,,4594,11,,void
40684,BLOCK,12,,<empty>,9,,4595,12,,void
40688,BLOCK,13,,<empty>,9,,4596,13,,void
40692,BLOCK,14,,<empty>,9,,4597,14,,void
40696,BLOCK,15,,<empty>,9,,4598,15,,void
40700,BLOCK,16,,<empty>,9,,4599,16,,void
40704,BLOCK,17,,<empty>,9,,4600,17,,void
40718,BLOCK,-1,,"{
        int type = 0;
        int32_t val_int = 0;
        uint32_t val_uint = 0;
        int64_t bigval_int = 0;
        uint64_t bigval_uint = 0;

        while (opts[type] != NULL && strcmp(key, opts[type]) != 0) {
            type++;
        }
        if (opts[type] == NULL) {
            fprintf(stderr, ""[restart] unknown/unhandled key: %s\n"", key);
            continue;
        }
        lines_seen++;

        // helper for any boolean checkers.
        bool val_bool = false;
        bool is_bool = true;
        if (strcmp(val, ""false"") == 0) {
            val_bool = false;
        } else if (strcmp(val, ""true"") == 0) {
            val_bool = true;
        } else {
            is_bool = false;
        }

        switch (type) {
        case R_MMAP_OLDBASE:
            if (!safe_strtoull_hex(val, &meta->old_base)) {
                fprintf(stderr, ""[restart] failed to parse %s: %s\n"", key, val);
                reuse_mmap = -1;
            }
            break;
        case R_...",59,,4604,2,,void
40753,BLOCK,-1,,"{
            type++;
        }",68,,4611,2,,void
40762,BLOCK,-1,,"{
            fprintf(stderr, ""[restart] unknown/unhandled key: %s\n"", key);
            continue;
        }",33,,4614,2,,void
40784,BLOCK,-1,,"{
            val_bool = false;
        }",40,,4623,2,,void
40789,BLOCK,-1,,<empty>,16,,4625,1,,void
40796,BLOCK,-1,,"{
            val_bool = true;
        }",46,,4625,2,,void
40801,BLOCK,-1,,"{
            is_bool = false;
        }",16,,4627,1,,void
40807,BLOCK,-1,,"{
        case R_MMAP_OLDBASE:
            if (!safe_strtoull_hex(val, &meta->old_base)) {
                fprintf(stderr, ""[restart] failed to parse %s: %s\n"", key, val);
                reuse_mmap = -1;
            }
            break;
        case R_MAXBYTES:
            if (!safe_strtoll(val, &bigval_int) || settings.maxbytes != bigval_int) {
                reuse_mmap = -1;
            }
            break;
        case R_CHUNK_SIZE:
            if (!safe_strtol(val, &val_int) || settings.chunk_size != val_int) {
                reuse_mmap = -1;
            }
            break;
        case R_ITEM_SIZE_MAX:
            if (!safe_strtol(val, &val_int) || settings.item_size_max != val_int) {
                reuse_mmap = -1;
            }
            break;
        case R_SLAB_CHUNK_SIZE_MAX:
            if (!safe_strtol(val, &val_int) || settings.slab_chunk_size_max != val_int) {
                reuse_mmap = -1;
            }
            break;
        case R_SLAB_PAGE_SIZE:
     ...",23,,4631,2,,void
40818,BLOCK,-1,,"{
                fprintf(stderr, ""[restart] failed to parse %s: %s\n"", key, val);
                reuse_mmap = -1;
            }",59,,4633,2,,void
40843,BLOCK,-1,,"{
                reuse_mmap = -1;
            }",85,,4639,2,,void
40863,BLOCK,-1,,"{
                reuse_mmap = -1;
            }",80,,4644,2,,void
40883,BLOCK,-1,,"{
                reuse_mmap = -1;
            }",83,,4649,2,,void
40903,BLOCK,-1,,"{
                reuse_mmap = -1;
            }",89,,4654,2,,void
40923,BLOCK,-1,,"{
                reuse_mmap = -1;
            }",84,,4659,2,,void
40939,BLOCK,-1,,"{
                reuse_mmap = -1;
            }",54,,4664,2,,void
40956,BLOCK,-1,,"{
                reuse_mmap = -1;
            }",59,,4669,2,,void
40973,BLOCK,-1,,"{
                reuse_mmap = -1;
            }",65,,4674,2,,void
40987,BLOCK,-1,,"{
                reuse_mmap = -1;
            }",52,,4680,2,,void
40993,BLOCK,-1,,"{
                set_cas_id(bigval_uint);
            }",20,,4682,1,,void
41005,BLOCK,-1,,"{
                reuse_mmap = -1;
            }",52,,4687,2,,void
41011,BLOCK,-1,,"{
                settings.oldest_cas = bigval_uint;
            }",20,,4689,1,,void
41026,BLOCK,-1,,"{
                reuse_mmap = -1;
            }",48,,4694,2,,void
41032,BLOCK,-1,,"{
                settings.oldest_live = val_uint;
            }",20,,4696,1,,void
41047,BLOCK,-1,,"{
                reuse_mmap = -1;
            }",52,,4701,2,,void
41053,BLOCK,-1,,"{
                logger_set_gid(bigval_uint);
            }",20,,4703,1,,void
41065,BLOCK,-1,,"{
                reuse_mmap = -1;
            }",52,,4708,2,,void
41071,BLOCK,-1,,"{
                meta->process_started = bigval_uint;
            }",20,,4710,1,,void
41086,BLOCK,-1,,"{
                reuse_mmap = -1;
            }",48,,4715,2,,void
41092,BLOCK,-1,,"{
                meta->current_time = val_uint;
            }",20,,4717,1,,void
41107,BLOCK,-1,,"{
                reuse_mmap = -1;
            }",50,,4722,2,,void
41113,BLOCK,-1,,"{
                struct timeval t;
                gettimeofday(&t, NULL);
                meta->time_delta = t.tv_sec - bigval_int;
                // clock has done something crazy.
                // there are _lots_ of ways the clock can go wrong here, but
                // this is a safe sanity check since there's nothing else we
                // can realistically do.
                if (meta->time_delta <= 0) {
                    reuse_mmap = -1;
                }
            }",20,,4724,1,,void
41134,BLOCK,-1,,"{
                    reuse_mmap = -1;
                }",44,,4732,2,,void
41148,BLOCK,-1,,"{
                reuse_mmap = -1;
            }",48,,4738,2,,void
41154,BLOCK,-1,,"{
                settings.hashpower_init = val_uint;
            }",20,,4740,1,,void
41170,BLOCK,-1,,"{
            fprintf(stderr, ""[restart] restart incompatible due to setting for [%s] [old value: %s]\n"", key, val);
            break;
        }",30,,4748,2,,void
41181,BLOCK,1,,<empty>,,,,1,,void
41183,BLOCK,-1,,"{
        fprintf(stderr, ""[restart] missing some metadata lines\n"");
        reuse_mmap = -1;
    }",45,,4754,2,,void
41198,BLOCK,-1,,"{
    int c;
    bool lock_memory = false;
    bool do_daemonize = false;
    bool preallocate = false;
    int maxcore = 0;
    char *username = NULL;
    char *pid_file = NULL;
    struct passwd *pw;
    struct rlimit rlim;
    char *buf;
    char unit = '\0';
    int size_max = 0;
    int retval = EXIT_SUCCESS;
    bool protocol_specified = false;
    bool tcp_specified = false;
    bool udp_specified = false;
    bool start_lru_maintainer = true;
    bool start_lru_crawler = true;
    bool start_assoc_maint = true;
    enum hashfunc_type hash_type = MURMUR3_HASH;
    uint32_t tocrawl;
    uint32_t slab_sizes[MAX_NUMBER_OF_SLAB_CLASSES];
    bool use_slab_sizes = false;
    char *slab_sizes_unparsed = NULL;
    bool slab_chunk_size_changed = false;
    // struct for restart code. Initialized up here so we can curry
    // important settings to save or validate.
    struct _mc_meta_data *meta = malloc(sizeof(struct _mc_meta_data));
    meta->slab_config = NULL;
    char *subopts, ...",34,,4762,3,,void
41299,BLOCK,1,,<empty>,9,,4858,1,,void
41303,BLOCK,2,,<empty>,9,,4859,2,,void
41307,BLOCK,3,,<empty>,9,,4860,3,,void
41311,BLOCK,4,,<empty>,9,,4861,4,,void
41315,BLOCK,5,,<empty>,9,,4862,5,,void
41319,BLOCK,6,,<empty>,9,,4863,6,,void
41323,BLOCK,7,,<empty>,9,,4864,7,,void
41327,BLOCK,8,,<empty>,9,,4865,8,,void
41331,BLOCK,9,,<empty>,9,,4866,9,,void
41335,BLOCK,10,,<empty>,9,,4867,10,,void
41339,BLOCK,11,,<empty>,9,,4868,11,,void
41343,BLOCK,12,,<empty>,9,,4869,12,,void
41347,BLOCK,13,,<empty>,9,,4870,13,,void
41351,BLOCK,14,,<empty>,9,,4871,14,,void
41355,BLOCK,15,,<empty>,9,,4872,15,,void
41359,BLOCK,16,,<empty>,9,,4873,16,,void
41363,BLOCK,17,,<empty>,9,,4874,17,,void
41367,BLOCK,18,,<empty>,9,,4875,18,,void
41371,BLOCK,19,,<empty>,9,,4876,19,,void
41375,BLOCK,20,,<empty>,9,,4877,20,,void
41379,BLOCK,21,,<empty>,9,,4878,21,,void
41383,BLOCK,22,,<empty>,9,,4879,22,,void
41387,BLOCK,23,,<empty>,9,,4880,23,,void
41391,BLOCK,24,,<empty>,9,,4881,24,,void
41395,BLOCK,25,,<empty>,9,,4882,25,,void
41399,BLOCK,26,,<empty>,9,,4883,26,,void
41403,BLOCK,27,,<empty>,9,,4884,27,,void
41407,BLOCK,28,,<empty>,9,,4885,28,,void
41411,BLOCK,29,,<empty>,9,,4886,29,,void
41415,BLOCK,30,,<empty>,9,,4887,30,,void
41419,BLOCK,31,,<empty>,9,,4888,31,,void
41423,BLOCK,32,,<empty>,9,,4889,32,,void
41427,BLOCK,33,,<empty>,9,,4890,33,,void
41431,BLOCK,34,,<empty>,9,,4891,34,,void
41435,BLOCK,35,,<empty>,9,,4892,35,,void
41439,BLOCK,36,,<empty>,9,,4893,36,,void
41443,BLOCK,37,,<empty>,9,,4894,37,,void
41447,BLOCK,38,,<empty>,9,,4895,38,,void
41451,BLOCK,39,,<empty>,9,,4896,39,,void
41459,BLOCK,-1,,"{
        free(meta);
        return EX_OSERR;
    }",25,,4922,2,,void
41500,BLOCK,-1,,"{
#endif
        switch (c) {
        case 'A':
            /* enables ""shutdown"" command */
            settings.shutdown_command = true;
            break;
        case 'Z':
            /* enable secure communication*/
#ifdef TLS
            settings.ssl_enabled = true;
#else
            fprintf(stderr, ""This server is not built with TLS support.\n"");
            exit(EX_USAGE);
#endif
            break;
        case 'a':
#ifndef DISABLE_UNIX_SOCKET
            /* access for unix domain socket, as octal mask (like chmod)*/
            settings.access= strtol(optarg,NULL,8);
#else
            fprintf(stderr, ""This server is not built with unix socket support.\n"");
            exit(EX_USAGE);
#endif /* #ifndef DISABLE_UNIX_SOCKET */
            break;
        case 'U':
            settings.udpport = atoi(optarg);
            udp_specified = true;
            break;
        case 'p':
            settings.port = atoi(optarg);
            tcp_specified = true;
            break;
      ...",55,,5035,2,,void
41503,BLOCK,-1,,"{
        case 'A':
            /* enables ""shutdown"" command */
            settings.shutdown_command = true;
            break;
        case 'Z':
            /* enable secure communication*/
#ifdef TLS
            settings.ssl_enabled = true;
#else
            fprintf(stderr, ""This server is not built with TLS support.\n"");
            exit(EX_USAGE);
#endif
            break;
        case 'a':
#ifndef DISABLE_UNIX_SOCKET
            /* access for unix domain socket, as octal mask (like chmod)*/
            settings.access= strtol(optarg,NULL,8);
#else
            fprintf(stderr, ""This server is not built with unix socket support.\n"");
            exit(EX_USAGE);
#endif /* #ifndef DISABLE_UNIX_SOCKET */
            break;
        case 'U':
            settings.udpport = atoi(optarg);
            udp_specified = true;
            break;
        case 'p':
            settings.port = atoi(optarg);
            tcp_specified = true;
            break;
        case 's':
#ifndef DISABLE_...",20,,5037,2,,void
41600,BLOCK,-1,,"{
                fprintf(stderr, ""Maximum connections must be greater than 0\n"");
                return 1;
            }",41,,5084,2,,void
41643,BLOCK,-1,,"{
                if (strstr(settings.inter, optarg) != NULL) {
                    break;
                }
                size_t len = strlen(settings.inter) + strlen(optarg) + 2;
                char *p = malloc(len);
                if (p == NULL) {
                    fprintf(stderr, ""Failed to allocate memory\n"");
                    return 1;
                }
                snprintf(p, len, ""%s,%s"", settings.inter, optarg);
                free(settings.inter);
                settings.inter = p;
            }",41,,5105,2,,void
41652,BLOCK,-1,,"{
                    break;
                }",61,,5106,2,,void
41675,BLOCK,-1,,"{
                    fprintf(stderr, ""Failed to allocate memory\n"");
                    return 1;
                }",32,,5111,2,,void
41699,BLOCK,-1,,"{
                settings.inter= strdup(optarg);
            }",20,,5118,1,,void
41733,BLOCK,-1,,"{
                fprintf(stderr, ""Number of requests per event must be greater than 0\n"");
                return 1;
            }",47,,5130,2,,void
41774,BLOCK,-1,,"{
                fprintf(stderr, ""Factor must be greater than 1\n"");
                return 1;
            }",41,,5146,2,,void
41801,BLOCK,-1,,"{
                fprintf(stderr, ""Chunk size must be greater than 0\n"");
                return 1;
            }",43,,5154,2,,void
41822,BLOCK,-1,,"{
                fprintf(stderr, ""Number of threads must be greater than 0\n"");
                return 1;
            }",44,,5161,2,,void
41834,BLOCK,-1,,"{
                fprintf(stderr, ""WARNING: Setting a high number of worker""
                                ""threads is not recommended.\n""
                                "" Set this value to the number of cores in""
                                "" your machine or less.\n"");
            }",44,,5169,2,,void
41849,BLOCK,-1,,"{
                fprintf(stderr, ""No delimiter specified\n"");
                return 1;
            }",42,,5177,2,,void
41874,BLOCK,-1,,"{
                preallocate = true;
            }",44,,5185,2,,void
41879,BLOCK,-1,,"{
                fprintf(stderr, ""Cannot enable large pages on this system\n""
                    ""(There is no support as of this version)\n"");
                return 1;
            }",20,,5187,1,,void
41914,BLOCK,-1,,"{
                settings.binding_protocol = negotiating_prot;
            }",46,,5201,2,,void
41921,BLOCK,-1,,<empty>,20,,5203,1,,void
41928,BLOCK,-1,,"{
                settings.binding_protocol = binary_prot;
            }",55,,5203,2,,void
41935,BLOCK,-1,,<empty>,20,,5205,1,,void
41942,BLOCK,-1,,"{
                settings.binding_protocol = ascii_prot;
            }",54,,5205,2,,void
41949,BLOCK,-1,,"{
                fprintf(stderr, ""Invalid value for binding protocol: %s\n""
                        "" -- should be one of auto, binary, or ascii\n"", optarg);
                exit(EX_USAGE);
            }",20,,5207,1,,void
41987,BLOCK,-1,,"{
                buf[strlen(buf)-1] = '\0';
                size_max = atoi(buf);
                if (unit == 'k' || unit == 'K')
                    size_max *= 1024;
                if (unit == 'm' || unit == 'M')
                    size_max *= 1024 * 1024;
                settings.item_size_max = size_max;
            }",45,,5217,2,,void
42008,BLOCK,-1,,<empty>,21,,5221,2,,void
42020,BLOCK,-1,,<empty>,21,,5223,2,,void
42032,BLOCK,-1,,"{
                settings.item_size_max = atoi(buf);
            }",20,,5225,1,,void
42102,BLOCK,-1,,"{
                fprintf(stderr, ""Maximum number of NAPI IDs must be greater than 0\n"");
                return 1;
            }",45,,5252,2,,void
42122,BLOCK,-1,,"{
            // BSD getsubopt (at least) has undefined behavior on -1, so
            // if we want to retry the getsubopt call in submodules we
            // need an extra layer of string copies.
            char *subopts_temp_o = NULL;
            char *subopts_temp = subopts_temp_o = strdup(subopts);

            switch (getsubopt(&subopts, subopts_tokens, &subopts_value)) {
            case MAXCONNS_FAST:
                settings.maxconns_fast = true;
                break;
            case HASHPOWER_INIT:
                if (subopts_value == NULL) {
                    fprintf(stderr, ""Missing numeric argument for hashpower\n"");
                    return 1;
                }
                settings.hashpower_init = atoi(subopts_value);
                if (settings.hashpower_init < 12) {
                    fprintf(stderr, ""Initial hashtable multiplier of %d is too low\n"",
                        settings.hashpower_init);
                    return 1;
                } else ...",38,,5260,2,,void
42141,BLOCK,-1,,"{
            case MAXCONNS_FAST:
                settings.maxconns_fast = true;
                break;
            case HASHPOWER_INIT:
                if (subopts_value == NULL) {
                    fprintf(stderr, ""Missing numeric argument for hashpower\n"");
                    return 1;
                }
                settings.hashpower_init = atoi(subopts_value);
                if (settings.hashpower_init < 12) {
                    fprintf(stderr, ""Initial hashtable multiplier of %d is too low\n"",
                        settings.hashpower_init);
                    return 1;
                } else if (settings.hashpower_init > 32) {
                    fprintf(stderr, ""Initial hashtable multiplier of %d is too high\n""
                        ""Choose a value based on \""STAT hash_power_level\"" from a running instance\n"",
                        settings.hashpower_init);
                    return 1;
                }
                break;
            case NO_HASHEXPAND:
  ...",74,,5267,2,,void
42156,BLOCK,-1,,"{
                    fprintf(stderr, ""Missing numeric argument for hashpower\n"");
                    return 1;
                }",44,,5272,2,,void
42174,BLOCK,-1,,"{
                    fprintf(stderr, ""Initial hashtable multiplier of %d is too low\n"",
                        settings.hashpower_init);
                    return 1;
                }",51,,5277,2,,void
42184,BLOCK,-1,,<empty>,24,,5281,1,,void
42191,BLOCK,-1,,"{
                    fprintf(stderr, ""Initial hashtable multiplier of %d is too high\n""
                        ""Choose a value based on \""STAT hash_power_level\"" from a running instance\n"",
                        settings.hashpower_init);
                    return 1;
                }",58,,5281,2,,void
42221,BLOCK,-1,,"{
                    settings.slab_automove = 1;
                    break;
                }",44,,5295,2,,void
42246,BLOCK,-1,,"{
                    fprintf(stderr, ""slab_automove must be between 0 and 2\n"");
                    return 1;
                }",79,,5300,2,,void
42259,BLOCK,-1,,"{
                    fprintf(stderr, ""Missing slab_automove_ratio argument\n"");
                    return 1;
                }",44,,5306,2,,void
42283,BLOCK,-1,,"{
                    fprintf(stderr, ""slab_automove_ratio must be > 0 and < 1\n"");
                    return 1;
                }",92,,5311,2,,void
42296,BLOCK,-1,,"{
                    fprintf(stderr, ""Missing slab_automove_window argument\n"");
                    return 1;
                }",44,,5317,2,,void
42314,BLOCK,-1,,"{
                    fprintf(stderr, ""slab_automove_window must be > 2\n"");
                    return 1;
                }",56,,5322,2,,void
42327,BLOCK,-1,,"{
                    fprintf(stderr, ""Missing numeric argument for tail_repair_time\n"");
                    return 1;
                }",44,,5328,2,,void
42345,BLOCK,-1,,"{
                    fprintf(stderr, ""Cannot set tail_repair_time to less than 10 seconds\n"");
                    return 1;
                }",53,,5333,2,,void
42358,BLOCK,-1,,"{
                    fprintf(stderr, ""Missing hash_algorithm argument\n"");
                    return 1;
                }",44,,5339,2,,void
42370,BLOCK,-1,,"{
                    hash_type = JENKINS_HASH;
                }",60,,5343,2,,void
42375,BLOCK,-1,,<empty>,24,,5345,1,,void
42382,BLOCK,-1,,"{
                    hash_type = MURMUR3_HASH;
                }",67,,5345,2,,void
42387,BLOCK,-1,,<empty>,24,,5347,1,,void
42394,BLOCK,-1,,"{
                    hash_type = XXH3_HASH;
                }",64,,5347,2,,void
42399,BLOCK,-1,,"{
                    fprintf(stderr, ""Unknown hash_algorithm option (jenkins, murmur3, xxh3)\n"");
                    return 1;
                }",24,,5349,1,,void
42418,BLOCK,-1,,"{
                    fprintf(stderr, ""Missing lru_crawler_sleep value\n"");
                    return 1;
                }",44,,5358,2,,void
42442,BLOCK,-1,,"{
                    fprintf(stderr, ""LRU crawler sleep must be between 0 and 1 second\n"");
                    return 1;
                }",93,,5363,2,,void
42455,BLOCK,-1,,"{
                    fprintf(stderr, ""Missing lru_crawler_tocrawl value\n"");
                    return 1;
                }",44,,5369,2,,void
42467,BLOCK,-1,,"{
                    fprintf(stderr, ""lru_crawler_tocrawl takes a numeric 32bit value\n"");
                    return 1;
                }",61,,5373,2,,void
42496,BLOCK,-1,,"{
                    fprintf(stderr, ""Missing hot_lru_pct argument\n"");
                    return 1;
                }",44,,5384,2,,void
42520,BLOCK,-1,,"{
                    fprintf(stderr, ""hot_lru_pct must be > 1 and < 80\n"");
                    return 1;
                }",77,,5389,2,,void
42533,BLOCK,-1,,"{
                    fprintf(stderr, ""Missing warm_lru_pct argument\n"");
                    return 1;
                }",44,,5395,2,,void
42557,BLOCK,-1,,"{
                    fprintf(stderr, ""warm_lru_pct must be > 1 and < 80\n"");
                    return 1;
                }",79,,5400,2,,void
42570,BLOCK,-1,,"{
                    fprintf(stderr, ""Missing hot_max_factor argument\n"");
                    return 1;
                }",44,,5406,2,,void
42588,BLOCK,-1,,"{
                    fprintf(stderr, ""hot_max_factor must be > 0\n"");
                    return 1;
                }",51,,5411,2,,void
42601,BLOCK,-1,,"{
                    fprintf(stderr, ""Missing warm_max_factor argument\n"");
                    return 1;
                }",44,,5417,2,,void
42619,BLOCK,-1,,"{
                    fprintf(stderr, ""warm_max_factor must be > 0\n"");
                    return 1;
                }",52,,5422,2,,void
42632,BLOCK,-1,,"{
                    fprintf(stderr, ""Missing temporary_ttl argument\n"");
                    return 1;
                }",44,,5428,2,,void
42656,BLOCK,-1,,"{
                    fprintf(stderr, ""Missing numeric argument for idle_timeout\n"");
                    return 1;
                }",44,,5436,2,,void
42675,BLOCK,-1,,"{
                    fprintf(stderr, ""Missing watcher_logbuf_size argument\n"");
                    return 1;
                }",44,,5443,2,,void
42689,BLOCK,-1,,"{
                    fprintf(stderr, ""could not parse argument to watcher_logbuf_size\n"");
                    return 1;
                }",86,,5447,2,,void
42707,BLOCK,-1,,"{
                    fprintf(stderr, ""Missing worker_logbuf_size argument\n"");
                    return 1;
                }",44,,5454,2,,void
42721,BLOCK,-1,,"{
                    fprintf(stderr, ""could not parse argument to worker_logbuf_size\n"");
                    return 1;
                }",78,,5458,2,,void
42745,BLOCK,-1,,"{
                    fprintf(stderr, ""Missing slab_chunk_max argument\n"");
                }",44,,5467,2,,void
42757,BLOCK,-1,,"{
                    fprintf(stderr, ""could not parse argument to slab_chunk_max\n"");
                }",81,,5470,2,,void
42847,BLOCK,-1,,"{
                    settings.slab_chunk_size_max = settings.slab_page_size;
                }",47,,5630,2,,void
42913,BLOCK,-1,,"{
                    fprintf(stderr, ""Missing read_buf_mem_limit argument\n"");
                    return 1;
                }",44,,5652,2,,void
42927,BLOCK,-1,,"{
                    fprintf(stderr, ""could not parse argument to read_buf_mem_limit\n"");
                    return 1;
                }",81,,5656,2,,void
42949,BLOCK,-1,,"{
                free(subopts_temp_o);
            }",33,,5702,2,,void
42970,BLOCK,-1,,"{
        fprintf(stderr, ""Number of napi_ids(%d) cannot be greater than number of threads(%d)\n"",
                settings.num_napi_ids, settings.num_threads);
        exit(EX_USAGE);
    }",55,,5715,2,,void
42988,BLOCK,1,,<empty>,,,,1,,void
42990,BLOCK,-1,,"{
        fprintf(stderr, ""Item max size cannot be less than 1024 bytes.\n"");
        exit(EX_USAGE);
    }",61,,5721,2,,void
43006,BLOCK,-1,,"{
        fprintf(stderr, ""Cannot set item size limit higher than 1/2 of memory max.\n"");
        exit(EX_USAGE);
    }",59,,5725,2,,void
43018,BLOCK,1,,<empty>,,,,1,,void
43024,BLOCK,-1,,"{
        fprintf(stderr, ""Cannot set item size limit higher than a gigabyte.\n"");
        exit(EX_USAGE);
    }",63,,5729,2,,void
43038,BLOCK,-1,,"{
        if (!slab_chunk_size_changed) {
            // Ideal new default is 16k, but needs stitching.
            settings.slab_chunk_size_max = settings.slab_page_size / 2;
        }
    }",47,,5733,2,,void
43042,BLOCK,-1,,"{
            // Ideal new default is 16k, but needs stitching.
            settings.slab_chunk_size_max = settings.slab_page_size / 2;
        }",39,,5734,2,,void
43060,BLOCK,-1,,"{
        fprintf(stderr, ""slab_chunk_max (bytes: %d) cannot be larger than -I (item_size_max %d)\n"",
                settings.slab_chunk_size_max, settings.item_size_max);
        exit(EX_USAGE);
    }",64,,5740,2,,void
43082,BLOCK,-1,,"{
        fprintf(stderr, ""-I (item_size_max: %d) must be evenly divisible by slab_chunk_max (bytes: %d)\n"",
                settings.item_size_max, settings.slab_chunk_size_max);
        exit(EX_USAGE);
    }",69,,5746,2,,void
43104,BLOCK,-1,,"{
        fprintf(stderr, ""slab_chunk_max (bytes: %d) must divide evenly into %d (slab_page_size)\n"",
                settings.slab_chunk_size_max, settings.slab_page_size);
        exit(EX_USAGE);
    }",70,,5752,2,,void
43120,BLOCK,-1,,"{
        // want the unedited string for restart code.
        char *temp = strdup(slab_sizes_unparsed);
        if (_parse_slab_sizes(slab_sizes_unparsed, slab_sizes)) {
            use_slab_sizes = true;
            if (meta->slab_config) {
                free(meta->slab_config);
            }
            meta->slab_config = temp;
        } else {
            exit(EX_USAGE);
        }
    }",38,,5773,2,,void
43130,BLOCK,-1,,"{
            use_slab_sizes = true;
            if (meta->slab_config) {
                free(meta->slab_config);
            }
            meta->slab_config = temp;
        }",65,,5776,2,,void
43138,BLOCK,-1,,"{
                free(meta->slab_config);
            }",36,,5778,2,,void
43149,BLOCK,-1,,"{
            exit(EX_USAGE);
        }",16,,5782,1,,void
43153,BLOCK,-1,,<empty>,12,,5785,1,,void
43159,BLOCK,-1,,"{
        // using the default factor.
        meta->slab_config = ""1.25"";
    }",36,,5785,2,,void
43175,BLOCK,-1,,"{
        fprintf(stderr, ""hot_lru_pct + warm_lru_pct cannot be more than 80%% combined\n"");
        exit(EX_USAGE);
    }",60,,5790,2,,void
43188,BLOCK,-1,,"{
        fprintf(stderr, ""temporary_ttl requires lru_maintainer to be enabled\n"");
        exit(EX_USAGE);
    }",53,,5795,2,,void
43199,BLOCK,-1,,"{
        fprintf(stderr, ""Failed to initialize hash_algorithm!\n"");
        exit(EX_USAGE);
    }",36,,5800,2,,void
43217,BLOCK,-1,,"{
        settings.num_threads_per_udp = 1;
    }",64,,5809,2,,void
43224,BLOCK,-1,,"{
        settings.num_threads_per_udp = settings.num_threads;
    }",12,,5811,1,,void
43236,BLOCK,-1,,"{
        if (!protocol_specified) {
            settings.binding_protocol = binary_prot;
        } else {
            if (settings.binding_protocol != binary_prot) {
                fprintf(stderr, ""ERROR: You cannot allow the ASCII protocol while using SASL.\n"");
                exit(EX_USAGE);
            }
        }

        if (settings.udpport) {
            fprintf(stderr, ""ERROR: Cannot enable UDP while using binary SASL authentication.\n"");
            exit(EX_USAGE);
        }
    }",24,,5815,2,,void
43240,BLOCK,-1,,"{
            settings.binding_protocol = binary_prot;
        }",34,,5816,2,,void
43247,BLOCK,-1,,"{
            if (settings.binding_protocol != binary_prot) {
                fprintf(stderr, ""ERROR: You cannot allow the ASCII protocol while using SASL.\n"");
                exit(EX_USAGE);
            }
        }",16,,5818,1,,void
43254,BLOCK,-1,,"{
                fprintf(stderr, ""ERROR: You cannot allow the ASCII protocol while using SASL.\n"");
                exit(EX_USAGE);
            }",59,,5819,2,,void
43264,BLOCK,-1,,"{
            fprintf(stderr, ""ERROR: Cannot enable UDP while using binary SASL authentication.\n"");
            exit(EX_USAGE);
        }",31,,5825,2,,void
43274,BLOCK,-1,,"{
        if (!protocol_specified) {
            settings.binding_protocol = ascii_prot;
        } else {
            if (settings.binding_protocol != ascii_prot) {
                fprintf(stderr, ""ERROR: You cannot allow the BINARY protocol while using ascii authentication tokens.\n"");
                exit(EX_USAGE);
            }
        }
    }",29,,5831,2,,void
43278,BLOCK,-1,,"{
            settings.binding_protocol = ascii_prot;
        }",34,,5832,2,,void
43285,BLOCK,-1,,"{
            if (settings.binding_protocol != ascii_prot) {
                fprintf(stderr, ""ERROR: You cannot allow the BINARY protocol while using ascii authentication tokens.\n"");
                exit(EX_USAGE);
            }
        }",16,,5834,1,,void
43292,BLOCK,-1,,"{
                fprintf(stderr, ""ERROR: You cannot allow the BINARY protocol while using ascii authentication tokens.\n"");
                exit(EX_USAGE);
            }",58,,5835,2,,void
43309,BLOCK,-1,,"{
        settings.port = settings.udpport;
    }",67,,5842,2,,void
43323,BLOCK,-1,,"{
        fprintf(stderr, ""ERROR: Invalid port number %d.\n"", settings.port);
        exit(EX_USAGE);
    }",32,,5846,2,,void
43336,BLOCK,-1,,"{
        struct rlimit rlim_new;
        /*
         * First try raising to infinity; if that fails, try bringing
         * the soft limit to the hard.
         */
        if (getrlimit(RLIMIT_CORE, &rlim) == 0) {
            rlim_new.rlim_cur = rlim_new.rlim_max = RLIM_INFINITY;
            if (setrlimit(RLIMIT_CORE, &rlim_new)!= 0) {
                /* failed. try raising just to the old max */
                rlim_new.rlim_cur = rlim_new.rlim_max = rlim.rlim_max;
                (void)setrlimit(RLIMIT_CORE, &rlim_new);
            }
        }
        /*
         * getrlimit again to see what we ended up with. Only fail if
         * the soft limit ends up 0, because then no core files will be
         * created at all.
         */

        if ((getrlimit(RLIMIT_CORE, &rlim) != 0) || rlim.rlim_cur == 0) {
            fprintf(stderr, ""failed to ensure corefile creation\n"");
            exit(EX_OSERR);
        }
    }",23,,5869,2,,void
43345,BLOCK,-1,,"{
            rlim_new.rlim_cur = rlim_new.rlim_max = RLIM_INFINITY;
            if (setrlimit(RLIMIT_CORE, &rlim_new)!= 0) {
                /* failed. try raising just to the old max */
                rlim_new.rlim_cur = rlim_new.rlim_max = rlim.rlim_max;
                (void)setrlimit(RLIMIT_CORE, &rlim_new);
            }
        }",49,,5875,2,,void
43362,BLOCK,-1,,"{
                /* failed. try raising just to the old max */
                rlim_new.rlim_cur = rlim_new.rlim_max = rlim.rlim_max;
                (void)setrlimit(RLIMIT_CORE, &rlim_new);
            }",56,,5877,2,,void
43393,BLOCK,-1,,"{
            fprintf(stderr, ""failed to ensure corefile creation\n"");
            exit(EX_OSERR);
        }",73,,5889,2,,void
43406,BLOCK,-1,,"{
        fprintf(stderr, ""failed to getrlimit number of files\n"");
        exit(EX_OSERR);
    }",47,,5900,2,,void
43413,BLOCK,-1,,"{
        rlim.rlim_cur = settings.maxconns;
        rlim.rlim_max = settings.maxconns;
        if (setrlimit(RLIMIT_NOFILE, &rlim) != 0) {
#ifndef MEMCACHED_DEBUG
            fprintf(stderr, ""failed to set rlimit for open files. Try starting as root or requesting smaller maxconns value.\n"");
            exit(EX_OSERR);
#endif
        }
    }",12,,5903,1,,void
43435,BLOCK,-1,,"{
#ifndef MEMCACHED_DEBUG
            fprintf(stderr, ""failed to set rlimit for open files. Try starting as root or requesting smaller maxconns value.\n"");
            exit(EX_OSERR);
#endif
        }",51,,5906,2,,void
43449,BLOCK,-1,,"{
        if (username == 0 || *username == '\0') {
            fprintf(stderr, ""can't run as root without the -u switch\n"");
            exit(EX_USAGE);
        }
        if ((pw = getpwnam(username)) == 0) {
            fprintf(stderr, ""can't find the user %s to switch to\n"", username);
            exit(EX_NOUSER);
        }
        if (setgroups(0, NULL) < 0) {
            /* setgroups may fail with EPERM, indicating we are already in a
             * minimally-privileged state. In that case we continue. For all
             * other failure codes we exit.
             *
             * Note that errno is stored here because fprintf may change it.
             */
            bool should_exit = errno != EPERM;
            fprintf(stderr, ""failed to drop supplementary groups: %s\n"",
                    strerror(errno));
            if (should_exit) {
                exit(EX_OSERR);
            }
        }
        if (setgid(pw->pw_gid) < 0 || setuid(pw->pw_uid) < 0) {
            fpr...",42,,5915,2,,void
43459,BLOCK,-1,,"{
            fprintf(stderr, ""can't run as root without the -u switch\n"");
            exit(EX_USAGE);
        }",49,,5916,2,,void
43472,BLOCK,-1,,"{
            fprintf(stderr, ""can't find the user %s to switch to\n"", username);
            exit(EX_NOUSER);
        }",45,,5920,2,,void
43485,BLOCK,-1,,"{
            /* setgroups may fail with EPERM, indicating we are already in a
             * minimally-privileged state. In that case we continue. For all
             * other failure codes we exit.
             *
             * Note that errno is stored here because fprintf may change it.
             */
            bool should_exit = errno != EPERM;
            fprintf(stderr, ""failed to drop supplementary groups: %s\n"",
                    strerror(errno));
            if (should_exit) {
                exit(EX_OSERR);
            }
        }",37,,5924,2,,void
43499,BLOCK,-1,,"{
                exit(EX_OSERR);
            }",30,,5934,2,,void
43516,BLOCK,-1,,"{
            fprintf(stderr, ""failed to assume identity of user %s\n"", username);
            exit(EX_OSERR);
        }",63,,5938,2,,void
43527,BLOCK,-1,,"{
        init_sasl();
    }",24,,5945,2,,void
43529,BLOCK,1,,init_sasl(),9,,5946,1,,void
43532,BLOCK,-1,,"{
        if (signal(SIGHUP, SIG_IGN) == SIG_ERR) {
            perror(""Failed to ignore SIGHUP"");
        }
        if (daemonize(maxcore, settings.verbose) == -1) {
            fprintf(stderr, ""failed to daemon() in order to daemonize\n"");
            exit(EXIT_FAILURE);
        }
    }",23,,5951,2,,void
43539,BLOCK,-1,,"{
            perror(""Failed to ignore SIGHUP"");
        }",49,,5952,2,,void
43551,BLOCK,-1,,"{
            fprintf(stderr, ""failed to daemon() in order to daemonize\n"");
            exit(EXIT_FAILURE);
        }",57,,5955,2,,void
43559,BLOCK,-1,,"{
#ifdef HAVE_MLOCKALL
        int res = mlockall(MCL_CURRENT | MCL_FUTURE);
        if (res != 0) {
            fprintf(stderr, ""warning: -k invalid, mlockall() failed: %s\n"",
                    strerror(errno));
        }
#else
        fprintf(stderr, ""warning: -k invalid, mlockall() not supported on this platform.  proceeding without.\n"");
#endif
    }",22,,5962,2,,void
43570,BLOCK,-1,,"{
        if (settings.udpport) {
            fprintf(stderr, ""Cannot use UDP with ascii authentication enabled (-U 0 to disable)\n"");
            exit(EX_USAGE);
        }

        switch (authfile_load(settings.auth_file)) {
            case AUTHFILE_STATFAIL:
                vperror(""Could not stat authfile [%s], error %s"", settings.auth_file
                                                            , strerror(errno));
                exit(EXIT_FAILURE);
                break;
            case AUTHFILE_OPENFAIL:
                vperror(""Could not open authfile [%s] for reading, error %s"", settings.auth_file
                                                                           , strerror(errno));
                exit(EXIT_FAILURE);
                break;
            case AUTHFILE_OOM:
                fprintf(stderr, ""Out of memory reading password file: %s"", settings.auth_file);
                exit(EXIT_FAILURE);
                break;
            case AUTHFILE_MALFORMED:
...",29,,5988,2,,void
43575,BLOCK,-1,,"{
            fprintf(stderr, ""Cannot use UDP with ascii authentication enabled (-U 0 to disable)\n"");
            exit(EX_USAGE);
        }",31,,5989,2,,void
43586,BLOCK,-1,,"{
            case AUTHFILE_STATFAIL:
                vperror(""Could not stat authfile [%s], error %s"", settings.auth_file
                                                            , strerror(errno));
                exit(EXIT_FAILURE);
                break;
            case AUTHFILE_OPENFAIL:
                vperror(""Could not open authfile [%s] for reading, error %s"", settings.auth_file
                                                                           , strerror(errno));
                exit(EXIT_FAILURE);
                break;
            case AUTHFILE_OOM:
                fprintf(stderr, ""Out of memory reading password file: %s"", settings.auth_file);
                exit(EXIT_FAILURE);
                break;
            case AUTHFILE_MALFORMED:
                fprintf(stderr, ""Authfile [%s] has a malformed entry. Should be 'user:password'"", settings.auth_file);
                exit(EXIT_FAILURE);
                break;
            case AUTHFILE_OK:
                b...",52,,5994,2,,void
43657,BLOCK,-1,,"{
        preallocate = true;
        // Easier to manage memory if we prefill the global pool when reusing.
        prefill = true;
        restart_register(""main"", _mc_meta_load_cb, _mc_meta_save_cb, meta);
        reuse_mem = restart_mmap_open(settings.maxbytes,
                        settings.memory_file,
                        &mem_base);
        // The ""save"" callback gets called when we're closing out the mmap,
        // but we don't know what the mmap_base is until after we call open.
        // So we pass the struct above but have to fill it in here so the
        // data's available during the save routine.
        meta->mmap_base = mem_base;
        // Also, the callbacks for load() run before _open returns, so we
        // should have the old base in 'meta' as of here.
    }",39,,6025,2,,void
43707,BLOCK,-1,,"{
        setup_privilege_violations_handler();
    }",35,,6066,2,,void
43710,BLOCK,-1,,<empty>,9,,6071,2,,void
43720,BLOCK,-1,,"{
        mc_ptr_t old_base = meta->old_base;
        assert(old_base == meta->old_base);

        // should've pulled in process_started from meta file.
        process_started = meta->process_started;
        // TODO: must be a more canonical way of serializing/deserializing
        // pointers? passing through uint64_t should work, and we're not
        // annotating the pointer with anything, but it's still slightly
        // insane.
        restart_fixup((void *)old_base);
    }",52,,6073,2,,void
43748,BLOCK,-1,,"{
        perror(""failed to ignore SIGPIPE; sigaction"");
        exit(EX_OSERR);
    }",46,,6089,2,,void
43767,BLOCK,-1,,"{
        exit(EXIT_FAILURE);
    }",70,,6111,2,,void
43776,BLOCK,-1,,"{
        fprintf(stderr, ""Failed to enable LRU crawler thread\n"");
        exit(EXIT_FAILURE);
    }",64,,6114,2,,void
43789,BLOCK,-1,,"{
#endif
        fprintf(stderr, ""Failed to enable LRU maintainer thread\n"");
        free(meta);
        return 1;
    }",73,,6130,2,,void
43806,BLOCK,-1,,"{
        exit(EXIT_FAILURE);
    }",48,,6138,2,,void
43818,BLOCK,-1,,"{
        exit(EXIT_FAILURE);
    }",69,,6142,2,,void
43831,BLOCK,-1,,"{
        errno = 0;
        if (server_socket_unix(settings.socketpath,settings.access)) {
            vperror(""failed to listen on UNIX socket: %s"", settings.socketpath);
            exit(EX_OSERR);
        }
    }",38,,6169,2,,void
43843,BLOCK,-1,,"{
            vperror(""failed to listen on UNIX socket: %s"", settings.socketpath);
            exit(EX_OSERR);
        }",70,,6171,2,,void
43857,BLOCK,-1,,"{
        const char *portnumber_filename = getenv(""MEMCACHED_PORT_FILENAME"");
        char *temp_portnumber_filename = NULL;
        size_t len;
        FILE *portnumber_file = NULL;

        if (portnumber_filename != NULL) {
            len = strlen(portnumber_filename)+4+1;
            temp_portnumber_filename = malloc(len);
            snprintf(temp_portnumber_filename,
                     len,
                     ""%s.lck"", portnumber_filename);

            portnumber_file = fopen(temp_portnumber_filename, ""a"");
            if (portnumber_file == NULL) {
                fprintf(stderr, ""Failed to open \""%s\"": %s\n"",
                        temp_portnumber_filename, strerror(errno));
            }
        }

        errno = 0;
        if (settings.port && server_sockets(settings.port, tcp_transport,
                                           portnumber_file)) {
            if (settings.inter == NULL) {
                vperror(""failed to listen on TCP port %d"", settings.port);...",38,,6178,2,,void
43876,BLOCK,-1,,"{
            len = strlen(portnumber_filename)+4+1;
            temp_portnumber_filename = malloc(len);
            snprintf(temp_portnumber_filename,
                     len,
                     ""%s.lck"", portnumber_filename);

            portnumber_file = fopen(temp_portnumber_filename, ""a"");
            if (portnumber_file == NULL) {
                fprintf(stderr, ""Failed to open \""%s\"": %s\n"",
                        temp_portnumber_filename, strerror(errno));
            }
        }",42,,6184,2,,void
43903,BLOCK,-1,,"{
                fprintf(stderr, ""Failed to open \""%s\"": %s\n"",
                        temp_portnumber_filename, strerror(errno));
            }",42,,6192,2,,void
43924,BLOCK,-1,,"{
            if (settings.inter == NULL) {
                vperror(""failed to listen on TCP port %d"", settings.port);
            } else {
                vperror(""failed to listen on one of interface(s) %s"", settings.inter);
            }
            exit(EX_OSERR);
        }",62,,6200,2,,void
43931,BLOCK,-1,,"{
                vperror(""failed to listen on TCP port %d"", settings.port);
            }",41,,6201,2,,void
43938,BLOCK,-1,,"{
                vperror(""failed to listen on one of interface(s) %s"", settings.inter);
            }",20,,6203,1,,void
43960,BLOCK,-1,,"{
            if (settings.inter == NULL) {
                vperror(""failed to listen on UDP port %d"", settings.udpport);
            } else {
                vperror(""failed to listen on one of interface(s) %s"", settings.inter);
            }
            exit(EX_OSERR);
        }",65,,6219,2,,void
43967,BLOCK,-1,,"{
                vperror(""failed to listen on UDP port %d"", settings.udpport);
            }",41,,6220,2,,void
43974,BLOCK,-1,,"{
                vperror(""failed to listen on one of interface(s) %s"", settings.inter);
            }",20,,6222,1,,void
43984,BLOCK,-1,,"{
            fclose(portnumber_file);
            rename(temp_portnumber_filename, portnumber_filename);
        }",30,,6228,2,,void
43992,BLOCK,-1,,<empty>,13,,6233,2,,void
44011,BLOCK,-1,,"{
        fprintf(stderr, ""Maxconns setting is too low, use -c to increase.\n"");
        exit(EXIT_FAILURE);
    }",85,,6240,2,,void
44021,BLOCK,-1,,"{
        save_pid(pid_file);
    }",27,,6245,2,,void
44028,BLOCK,-1,,"{
        drop_privileges();
    }",35,,6250,2,,void
44033,BLOCK,-1,,"{
        if (event_base_loop(main_base, EVLOOP_ONCE) != 0) {
            retval = EXIT_FAILURE;
            break;
        }
    }",29,,6258,2,,void
44040,BLOCK,-1,,"{
            retval = EXIT_FAILURE;
            break;
        }",59,,6259,2,,void
44047,BLOCK,-1,,"{
        case GRACE_STOP:
            fprintf(stderr, ""Gracefully stopping\n"");
        break;
        case EXIT_NORMALLY:
            // Don't need to print anything to STDERR for a normal shutdown.
        break;
        default:
            fprintf(stderr, ""Exiting on error\n"");
        break;
    }",29,,6265,2,,void
44073,BLOCK,-1,,"{
        restart_mmap_close();
    }",71,,6278,2,,void
44077,BLOCK,-1,,<empty>,9,,6284,2,,void
44084,BLOCK,-1,,<empty>,7,,6287,2,,void
44159,BLOCK,-1,,<empty>,1,,1,1,,ANY
44166,BLOCK,-1,,<empty>,,,,6,,<empty>
44202,BLOCK,-1,,<empty>,,,,1,,<empty>
44218,BLOCK,-1,,<empty>,,,,1,,<empty>
44241,BLOCK,-1,,<empty>,,,,1,,<empty>
44297,BLOCK,-1,,<empty>,,,,1,,<empty>
44300,BLOCK,1,,<empty>,,,,1,,void
44306,BLOCK,1,,<empty>,,,,1,,void
44472,BLOCK,-1,,<empty>,,,,1,,<empty>
44482,BLOCK,-1,,<empty>,,,,1,,<empty>
44523,BLOCK,-1,,<empty>,,,,1,,<empty>
44534,BLOCK,-1,,<empty>,,,,2,,<empty>
44539,BLOCK,-1,,<empty>,,,,2,,<empty>
44585,BLOCK,-1,,<empty>,,,,1,,<empty>
44588,BLOCK,1,,<empty>,,,,1,,void
44619,BLOCK,-1,,<empty>,,,,1,,<empty>
44622,BLOCK,1,,<empty>,,,,1,,void
44626,BLOCK,1,,<empty>,,,,1,,void
44640,BLOCK,-1,,<empty>,,,,1,,<empty>
44653,BLOCK,-1,,<empty>,,,,1,,<empty>
44720,BLOCK,-1,,<empty>,,,,2,,<empty>
44727,BLOCK,-1,,<empty>,,,,4,,<empty>
44734,BLOCK,-1,,<empty>,,,,4,,<empty>
44741,BLOCK,-1,,<empty>,,,,4,,<empty>
44745,BLOCK,-1,,<empty>,,,,1,,<empty>
44748,BLOCK,1,,<empty>,,,,1,,void
44774,BLOCK,-1,,<empty>,,,,2,,<empty>
44789,BLOCK,-1,,<empty>,,,,8,,<empty>
44794,BLOCK,-1,,<empty>,,,,2,,<empty>
44800,BLOCK,-1,,<empty>,,,,3,,<empty>
44806,BLOCK,-1,,<empty>,,,,3,,<empty>
44811,BLOCK,-1,,<empty>,,,,2,,<empty>
44824,BLOCK,-1,,<empty>,,,,10,,<empty>
44829,BLOCK,-1,,<empty>,,,,2,,<empty>
44835,BLOCK,-1,,<empty>,,,,3,,<empty>
44841,BLOCK,-1,,<empty>,,,,3,,<empty>
44846,BLOCK,-1,,<empty>,,,,2,,<empty>
44851,BLOCK,-1,,<empty>,,,,2,,<empty>
44856,BLOCK,-1,,<empty>,,,,2,,<empty>
44868,BLOCK,-1,,<empty>,,,,9,,<empty>
44873,BLOCK,-1,,<empty>,,,,2,,<empty>
44880,BLOCK,-1,,<empty>,,,,2,,<empty>
44885,BLOCK,-1,,<empty>,,,,2,,<empty>
44890,BLOCK,-1,,<empty>,,,,2,,<empty>
44899,BLOCK,-1,,<empty>,,,,6,,<empty>
44907,BLOCK,-1,,<empty>,,,,5,,<empty>
44916,BLOCK,-1,,<empty>,,,,6,,<empty>
44924,BLOCK,-1,,<empty>,,,,5,,<empty>
44929,BLOCK,-1,,<empty>,,,,2,,<empty>
44934,BLOCK,-1,,<empty>,,,,2,,<empty>
44941,BLOCK,-1,,<empty>,,,,4,,<empty>
44946,BLOCK,-1,,<empty>,,,,2,,<empty>
44951,BLOCK,-1,,<empty>,,,,2,,<empty>
44956,BLOCK,-1,,<empty>,,,,2,,<empty>
44961,BLOCK,-1,,<empty>,,,,2,,<empty>
44966,BLOCK,-1,,<empty>,,,,2,,<empty>
44971,BLOCK,-1,,<empty>,,,,2,,<empty>
44976,BLOCK,-1,,<empty>,,,,2,,<empty>
44981,BLOCK,-1,,<empty>,,,,2,,<empty>
44986,BLOCK,-1,,<empty>,,,,2,,<empty>
44991,BLOCK,-1,,<empty>,,,,2,,<empty>
44996,BLOCK,-1,,<empty>,,,,2,,<empty>
45001,BLOCK,-1,,<empty>,,,,2,,<empty>
45007,BLOCK,-1,,<empty>,,,,3,,<empty>
45012,BLOCK,-1,,<empty>,,,,2,,<empty>
45020,BLOCK,-1,,<empty>,,,,5,,<empty>
45028,BLOCK,-1,,<empty>,,,,3,,<empty>
45033,BLOCK,-1,,<empty>,,,,2,,<empty>
45044,BLOCK,-1,,<empty>,,,,8,,<empty>
45054,BLOCK,-1,,<empty>,,,,7,,<empty>
45059,BLOCK,-1,,<empty>,,,,2,,<empty>
45066,BLOCK,-1,,<empty>,,,,4,,<empty>
45073,BLOCK,-1,,<empty>,,,,4,,<empty>
45078,BLOCK,-1,,<empty>,,,,2,,<empty>
45084,BLOCK,-1,,<empty>,,,,3,,<empty>
45089,BLOCK,-1,,<empty>,,,,2,,<empty>
45094,BLOCK,-1,,<empty>,,,,2,,<empty>
45099,BLOCK,-1,,<empty>,,,,2,,<empty>
45105,BLOCK,-1,,<empty>,,,,3,,<empty>
45111,BLOCK,-1,,<empty>,,,,3,,<empty>
45117,BLOCK,-1,,<empty>,,,,3,,<empty>
45124,BLOCK,-1,,<empty>,,,,4,,<empty>
45130,BLOCK,-1,,<empty>,,,,3,,<empty>
45139,BLOCK,-1,,<empty>,,,,6,,<empty>
45147,BLOCK,-1,,<empty>,,,,5,,<empty>
45152,BLOCK,-1,,<empty>,,,,2,,<empty>
45158,BLOCK,-1,,<empty>,,,,3,,<empty>
45164,BLOCK,-1,,<empty>,,,,3,,<empty>
45175,BLOCK,-1,,<empty>,1,,1,1,,ANY
45179,BLOCK,-1,,"{
  return (x << r) | (x >> (32 - r));
}",1,,34,3,,void
45195,BLOCK,-1,,"{
  return p[i];
}",1,,49,3,,void
45204,BLOCK,-1,,"{
  h ^= h >> 16;
  h *= 0x85ebca6b;
  h ^= h >> 13;
  h *= 0xc2b2ae35;
  h ^= h >> 16;

  return h;
}",1,,57,2,,void
45233,BLOCK,-1,,"{
  const uint8_t * data = (const uint8_t*)key;
  const int nblocks = length / 4;

  uint32_t h1 = 0;

  uint32_t c1 = 0xcc9e2d51;
  uint32_t c2 = 0x1b873593;

  //----------
  // body

  const uint32_t * blocks = (const uint32_t *)(data + nblocks*4);

  for(int i = -nblocks; i; i++)
  {
    uint32_t k1 = getblock32(blocks,i);

    k1 *= c1;
    k1 = ROTL32(k1,15);
    k1 *= c2;

    h1 ^= k1;
    h1 = ROTL32(h1,13);
    h1 = h1*5+0xe6546b64;
  }

  //----------
  // tail

  const uint8_t * tail = (const uint8_t*)(data + nblocks*4);

  uint32_t k1 = 0;

  switch(length & 3)
  {
  case 3: k1 ^= tail[2] << 16;
  case 2: k1 ^= tail[1] << 8;
  case 1: k1 ^= tail[0];
          k1 *= c1; k1 = ROTL32(k1,15); k1 *= c2; h1 ^= k1;
  };

  //----------
  // finalization

  h1 ^= length;

  h1 = fmix32(h1);

  //*(uint32_t*)out = h1;
  return h1;
}",1,,72,3,,void
45269,BLOCK,-1,,<empty>,3,,86,1,,void
45278,BLOCK,4,,"{
    uint32_t k1 = getblock32(blocks,i);

    k1 *= c1;
    k1 = ROTL32(k1,15);
    k1 *= c2;

    h1 ^= k1;
    h1 = ROTL32(h1,13);
    h1 = h1*5+0xe6546b64;
  }",3,,87,4,,void
45293,BLOCK,1,,<empty>,,,,4,,void
45308,BLOCK,1,,<empty>,,,,4,,void
45337,BLOCK,-1,,"{
  case 3: k1 ^= tail[2] << 16;
  case 2: k1 ^= tail[1] << 8;
  case 1: k1 ^= tail[0];
          k1 *= c1; k1 = ROTL32(k1,15); k1 *= c2; h1 ^= k1;
  }",3,,107,2,,void
45371,BLOCK,1,,<empty>,,,,4,,void
45400,BLOCK,-1,,<empty>,1,,1,1,,ANY
45404,BLOCK,-1,,<empty>,,,,3,,<empty>
45423,BLOCK,-1,,<empty>,1,,1,1,,ANY
45442,BLOCK,-1,,<empty>,1,,1,1,,ANY
45446,BLOCK,-1,,<empty>,,,,3,,<empty>
45451,BLOCK,-1,,<empty>,,,,2,,<empty>
45457,BLOCK,-1,,<empty>,,,,3,,<empty>
45463,BLOCK,-1,,<empty>,,,,3,,<empty>
45468,BLOCK,-1,,<empty>,,,,2,,<empty>
45474,BLOCK,-1,,<empty>,,,,3,,<empty>
45479,BLOCK,-1,,<empty>,,,,2,,<empty>
45484,BLOCK,-1,,<empty>,,,,2,,<empty>
45490,BLOCK,-1,,<empty>,,,,3,,<empty>
45495,BLOCK,-1,,<empty>,,,,2,,<empty>
45500,BLOCK,-1,,<empty>,,,,2,,<empty>
45507,BLOCK,-1,,<empty>,,,,4,,<empty>
45512,BLOCK,-1,,"{
    assert(c != NULL);
    assert(c->cmd >= 0);

    switch(c->substate) {
    case bin_read_set_value:
        complete_update_bin(c);
        break;
    case bin_reading_sasl_auth_data:
        process_bin_complete_sasl_auth(c);
        if (c->item) {
            do_item_remove(c->item);
            c->item = NULL;
        }
        break;
    default:
        fprintf(stderr, ""Not handling substate %d\n"", c->substate);
        assert(0);
    }
}",37,,31,2,,void
45527,BLOCK,-1,,"{
    case bin_read_set_value:
        complete_update_bin(c);
        break;
    case bin_reading_sasl_auth_data:
        process_bin_complete_sasl_auth(c);
        if (c->item) {
            do_item_remove(c->item);
            c->item = NULL;
        }
        break;
    default:
        fprintf(stderr, ""Not handling substate %d\n"", c->substate);
        assert(0);
    }",25,,35,2,,void
45541,BLOCK,-1,,"{
            do_item_remove(c->item);
            c->item = NULL;
        }",22,,41,2,,void
45565,BLOCK,-1,,"{
    /* Do we have the complete packet header? */
    if (c->rbytes < sizeof(c->binary_header)) {
        /* need more data! */
        return 0;
    } else {
        memcpy(&c->binary_header, c->rcurr, sizeof(c->binary_header));
        protocol_binary_request_header* req;
        req = &c->binary_header;

        if (settings.verbose > 1) {
            /* Dump the packet before we convert it to host order */
            int ii;
            fprintf(stderr, ""<%d Read binary protocol data:"", c->sfd);
            for (ii = 0; ii < sizeof(req->bytes); ++ii) {
                if (ii % 4 == 0) {
                    fprintf(stderr, ""\n<%d   "", c->sfd);
                }
                fprintf(stderr, "" 0x%02x"", req->bytes[ii]);
            }
            fprintf(stderr, ""\n"");
        }

        c->binary_header = *req;
        c->binary_header.request.keylen = ntohs(req->request.keylen);
        c->binary_header.request.bodylen = ntohl(req->request.bodylen);
        c->binary_header.req...",38,,52,2,,void
45575,BLOCK,-1,,"{
        /* need more data! */
        return 0;
    }",47,,54,2,,void
45579,BLOCK,-1,,"{
        memcpy(&c->binary_header, c->rcurr, sizeof(c->binary_header));
        protocol_binary_request_header* req;
        req = &c->binary_header;

        if (settings.verbose > 1) {
            /* Dump the packet before we convert it to host order */
            int ii;
            fprintf(stderr, ""<%d Read binary protocol data:"", c->sfd);
            for (ii = 0; ii < sizeof(req->bytes); ++ii) {
                if (ii % 4 == 0) {
                    fprintf(stderr, ""\n<%d   "", c->sfd);
                }
                fprintf(stderr, "" 0x%02x"", req->bytes[ii]);
            }
            fprintf(stderr, ""\n"");
        }

        c->binary_header = *req;
        c->binary_header.request.keylen = ntohs(req->request.keylen);
        c->binary_header.request.bodylen = ntohl(req->request.bodylen);
        c->binary_header.request.cas = ntohll(req->request.cas);

        if (c->binary_header.request.magic != PROTOCOL_BINARY_REQ) {
            if (settings.verbose) {
               ...",12,,57,1,,void
45605,BLOCK,-1,,"{
            /* Dump the packet before we convert it to host order */
            int ii;
            fprintf(stderr, ""<%d Read binary protocol data:"", c->sfd);
            for (ii = 0; ii < sizeof(req->bytes); ++ii) {
                if (ii % 4 == 0) {
                    fprintf(stderr, ""\n<%d   "", c->sfd);
                }
                fprintf(stderr, "" 0x%02x"", req->bytes[ii]);
            }
            fprintf(stderr, ""\n"");
        }",35,,62,2,,void
45614,BLOCK,-1,,<empty>,13,,66,1,,void
45626,BLOCK,4,,"{
                if (ii % 4 == 0) {
                    fprintf(stderr, ""\n<%d   "", c->sfd);
                }
                fprintf(stderr, "" 0x%02x"", req->bytes[ii]);
            }",57,,66,4,,void
45633,BLOCK,-1,,"{
                    fprintf(stderr, ""\n<%d   "", c->sfd);
                }",34,,67,2,,void
45709,BLOCK,-1,,"{
            if (settings.verbose) {
                fprintf(stderr, ""Invalid magic:  %x\n"",
                        c->binary_header.request.magic);
            }
            conn_set_state(c, conn_closing);
            return -1;
        }",68,,80,2,,void
45714,BLOCK,-1,,"{
                fprintf(stderr, ""Invalid magic:  %x\n"",
                        c->binary_header.request.magic);
            }",35,,81,2,,void
45764,BLOCK,-1,,"{
            // Still need more bytes. Let try_read_network() realign the
            // read-buffer and fetch more data as necessary.
            return 0;
        }",69,,91,2,,void
45771,BLOCK,-1,,"{
            conn_set_state(c, conn_closing);
            return -1;
        }",29,,97,2,,void
45841,BLOCK,1,,<empty>,,,,1,,void
45844,BLOCK,1,,<empty>,,,,1,,void
45880,BLOCK,-1,,"{
    return c->rcurr - (c->binary_header.request.keylen);
}",38,,131,2,,void
45901,BLOCK,-1,,"{
    protocol_binary_response_header* header;
    mc_resp *resp = c->resp;

    assert(c);

    resp_reset(resp);

    header = (protocol_binary_response_header *)resp->wbuf;

    header->response.magic = (uint8_t)PROTOCOL_BINARY_RES;
    header->response.opcode = c->binary_header.request.opcode;
    header->response.keylen = (uint16_t)htons(key_len);

    header->response.extlen = (uint8_t)hdr_len;
    header->response.datatype = (uint8_t)PROTOCOL_BINARY_RAW_BYTES;
    header->response.status = (uint16_t)htons(err);

    header->response.bodylen = htonl(body_len);
    header->response.opaque = c->opaque;
    header->response.cas = htonll(c->cas);

    if (settings.verbose > 1) {
        int ii;
        fprintf(stderr, "">%d Writing bin response:"", c->sfd);
        for (ii = 0; ii < sizeof(header->bytes); ++ii) {
            if (ii % 4 == 0) {
                fprintf(stderr, ""\n>%d  "", c->sfd);
            }
            fprintf(stderr, "" 0x%02x"", header->bytes[ii]);
        }
      ...",105,,135,6,,void
46013,BLOCK,-1,,"{
        int ii;
        fprintf(stderr, "">%d Writing bin response:"", c->sfd);
        for (ii = 0; ii < sizeof(header->bytes); ++ii) {
            if (ii % 4 == 0) {
                fprintf(stderr, ""\n>%d  "", c->sfd);
            }
            fprintf(stderr, "" 0x%02x"", header->bytes[ii]);
        }
        fprintf(stderr, ""\n"");
    }",31,,157,2,,void
46022,BLOCK,-1,,<empty>,9,,160,1,,void
46034,BLOCK,4,,"{
            if (ii % 4 == 0) {
                fprintf(stderr, ""\n>%d  "", c->sfd);
            }
            fprintf(stderr, "" 0x%02x"", header->bytes[ii]);
        }",56,,160,4,,void
46041,BLOCK,-1,,"{
                fprintf(stderr, ""\n>%d  "", c->sfd);
            }",30,,161,2,,void
46082,BLOCK,-1,,"{
    size_t len;

    if (!errstr) {
        switch (err) {
        case PROTOCOL_BINARY_RESPONSE_ENOMEM:
            errstr = ""Out of memory"";
            break;
        case PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND:
            errstr = ""Unknown command"";
            break;
        case PROTOCOL_BINARY_RESPONSE_KEY_ENOENT:
            errstr = ""Not found"";
            break;
        case PROTOCOL_BINARY_RESPONSE_EINVAL:
            errstr = ""Invalid arguments"";
            break;
        case PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS:
            errstr = ""Data exists for key."";
            break;
        case PROTOCOL_BINARY_RESPONSE_E2BIG:
            errstr = ""Too large."";
            break;
        case PROTOCOL_BINARY_RESPONSE_DELTA_BADVAL:
            errstr = ""Non-numeric server-side value for incr or decr"";
            break;
        case PROTOCOL_BINARY_RESPONSE_NOT_STORED:
            errstr = ""Not stored."";
            break;
        case PROTOCOL_BINARY_RESPONSE_AUTH_ERROR...",62,,180,5,,void
46087,BLOCK,-1,,"{
        switch (err) {
        case PROTOCOL_BINARY_RESPONSE_ENOMEM:
            errstr = ""Out of memory"";
            break;
        case PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND:
            errstr = ""Unknown command"";
            break;
        case PROTOCOL_BINARY_RESPONSE_KEY_ENOENT:
            errstr = ""Not found"";
            break;
        case PROTOCOL_BINARY_RESPONSE_EINVAL:
            errstr = ""Invalid arguments"";
            break;
        case PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS:
            errstr = ""Data exists for key."";
            break;
        case PROTOCOL_BINARY_RESPONSE_E2BIG:
            errstr = ""Too large."";
            break;
        case PROTOCOL_BINARY_RESPONSE_DELTA_BADVAL:
            errstr = ""Non-numeric server-side value for incr or decr"";
            break;
        case PROTOCOL_BINARY_RESPONSE_NOT_STORED:
            errstr = ""Not stored."";
            break;
        case PROTOCOL_BINARY_RESPONSE_AUTH_ERROR:
            errstr = ""Auth failure...",18,,183,2,,void
46090,BLOCK,-1,,"{
        case PROTOCOL_BINARY_RESPONSE_ENOMEM:
            errstr = ""Out of memory"";
            break;
        case PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND:
            errstr = ""Unknown command"";
            break;
        case PROTOCOL_BINARY_RESPONSE_KEY_ENOENT:
            errstr = ""Not found"";
            break;
        case PROTOCOL_BINARY_RESPONSE_EINVAL:
            errstr = ""Invalid arguments"";
            break;
        case PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS:
            errstr = ""Data exists for key."";
            break;
        case PROTOCOL_BINARY_RESPONSE_E2BIG:
            errstr = ""Too large."";
            break;
        case PROTOCOL_BINARY_RESPONSE_DELTA_BADVAL:
            errstr = ""Non-numeric server-side value for incr or decr"";
            break;
        case PROTOCOL_BINARY_RESPONSE_NOT_STORED:
            errstr = ""Not stored."";
            break;
        case PROTOCOL_BINARY_RESPONSE_AUTH_ERROR:
            errstr = ""Auth failure."";
            break;
...",22,,184,2,,void
46164,BLOCK,-1,,"{
        fprintf(stderr, "">%d Writing an error: %s\n"", c->sfd, errstr);
    }",31,,219,2,,void
46186,BLOCK,-1,,"{
        resp_add_iov(c->resp, errstr, len);
    }",18,,225,2,,void
46197,BLOCK,-1,,"{
        c->sbytes = swallow;
        conn_set_state(c, conn_swallow);
    }",22,,228,2,,void
46207,BLOCK,-1,,"{
        conn_set_state(c, conn_mwrite);
    }",12,,231,1,,void
46215,BLOCK,-1,,"{
    write_bin_error(c, PROTOCOL_BINARY_RESPONSE_EINVAL, NULL, 0);
    if (settings.verbose) {
        fprintf(stderr, ""Protocol error (opcode %02x), close connection %d\n"",
                c->binary_header.request.opcode, c->sfd);
    }
    c->close_after_write = true;
}",51,,237,2,,void
46225,BLOCK,-1,,"{
        fprintf(stderr, ""Protocol error (opcode %02x), close connection %d\n"",
                c->binary_header.request.opcode, c->sfd);
    }",27,,239,2,,void
46252,BLOCK,-1,,"{
    if (!c->noreply || c->cmd == PROTOCOL_BINARY_CMD_GET ||
        c->cmd == PROTOCOL_BINARY_CMD_GETK) {
        add_bin_header(c, 0, hlen, keylen, dlen);
        mc_resp *resp = c->resp;
        if (dlen > 0) {
            resp_add_iov(resp, d, dlen);
        }
    }

    conn_set_state(c, conn_new_cmd);
}",82,,247,6,,void
46270,BLOCK,-1,,"{
        add_bin_header(c, 0, hlen, keylen, dlen);
        mc_resp *resp = c->resp;
        if (dlen > 0) {
            resp_add_iov(resp, d, dlen);
        }
    }",45,,249,2,,void
46287,BLOCK,-1,,"{
            resp_add_iov(resp, d, dlen);
        }",23,,252,2,,void
46300,BLOCK,-1,,"{
    item *it;
    char *key;
    size_t nkey;
    /* Weird magic in add_delta forces me to pad here */
    char tmpbuf[INCR_MAX_STORAGE_LEN];
    uint64_t cas = 0;

    assert(c != NULL);
    protocol_binary_response_incr* rsp = (protocol_binary_response_incr*)c->resp->wbuf;
    protocol_binary_request_incr* req = (void *)extbuf;

    //assert(c->wsize >= sizeof(*rsp));

    /* fix byteorder in the request */
    req->message.body.delta = ntohll(req->message.body.delta);
    req->message.body.initial = ntohll(req->message.body.initial);
    req->message.body.expiration = ntohl(req->message.body.expiration);
    key = binary_get_key(c);
    nkey = c->binary_header.request.keylen;

    if (settings.verbose > 1) {
        int i;
        fprintf(stderr, ""incr "");

        for (i = 0; i < nkey; i++) {
            fprintf(stderr, ""%c"", key[i]);
        }
        fprintf(stderr, "" %lld, %llu, %d\n"",
                (long long)req->message.body.delta,
                (long long)req->messa...",54,,260,3,,void
46396,BLOCK,-1,,"{
        int i;
        fprintf(stderr, ""incr "");

        for (i = 0; i < nkey; i++) {
            fprintf(stderr, ""%c"", key[i]);
        }
        fprintf(stderr, "" %lld, %llu, %d\n"",
                (long long)req->message.body.delta,
                (long long)req->message.body.initial,
                req->message.body.expiration);
    }",31,,281,2,,void
46402,BLOCK,-1,,<empty>,9,,285,1,,void
46411,BLOCK,4,,"{
            fprintf(stderr, ""%c"", key[i]);
        }",36,,285,4,,void
46456,BLOCK,-1,,"{
        cas = c->binary_header.request.cas;
    }",44,,294,2,,void
46486,BLOCK,-1,,"{
    case OK:
        rsp->message.body.value = htonll(strtoull(tmpbuf, NULL, 10));
        if (cas) {
            c->cas = cas;
        }
        write_bin_response(c, &rsp->message.body, 0, 0,
                           sizeof(rsp->message.body.value));
        break;
    case NON_NUMERIC:
        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_DELTA_BADVAL, NULL, 0);
        break;
    case EOM:
        out_of_memory(c, ""SERVER_ERROR Out of memory incrementing value"");
        break;
    case DELTA_ITEM_NOT_FOUND:
        if (req->message.body.expiration != 0xffffffff) {
            /* Save some room for the response */
            rsp->message.body.value = htonll(req->message.body.initial);

            snprintf(tmpbuf, INCR_MAX_STORAGE_LEN, ""%llu"",
                (unsigned long long)req->message.body.initial);
            int res = strlen(tmpbuf);
            it = item_alloc(key, nkey, 0, realtime(req->message.body.expiration),
                            res + 2);

            i...",29,,299,2,,void
46504,BLOCK,-1,,"{
            c->cas = cas;
        }",18,,302,2,,void
46555,BLOCK,-1,,"{
            /* Save some room for the response */
            rsp->message.body.value = htonll(req->message.body.initial);

            snprintf(tmpbuf, INCR_MAX_STORAGE_LEN, ""%llu"",
                (unsigned long long)req->message.body.initial);
            int res = strlen(tmpbuf);
            it = item_alloc(key, nkey, 0, realtime(req->message.body.expiration),
                            res + 2);

            if (it != NULL) {
                memcpy(ITEM_data(it), tmpbuf, res);
                memcpy(ITEM_data(it) + res, ""\r\n"", 2);

                if (store_item(it, NREAD_ADD, c)) {
                    c->cas = ITEM_get_cas(it);
                    write_bin_response(c, &rsp->message.body, 0, 0, sizeof(rsp->message.body.value));
                } else {
                    write_bin_error(c, PROTOCOL_BINARY_RESPONSE_NOT_STORED,
                                    NULL, 0);
                }
                item_remove(it);         /* release our reference */
            } e...",57,,315,2,,void
46575,BLOCK,1,,<empty>,,,,1,,void
46613,BLOCK,-1,,"{
                memcpy(ITEM_data(it), tmpbuf, res);
                memcpy(ITEM_data(it) + res, ""\r\n"", 2);

                if (store_item(it, NREAD_ADD, c)) {
                    c->cas = ITEM_get_cas(it);
                    write_bin_response(c, &rsp->message.body, 0, 0, sizeof(rsp->message.body.value));
                } else {
                    write_bin_error(c, PROTOCOL_BINARY_RESPONSE_NOT_STORED,
                                    NULL, 0);
                }
                item_remove(it);         /* release our reference */
            }",29,,325,2,,void
46617,BLOCK,1,,<empty>,,,,6,,void
46656,BLOCK,1,,<empty>,,,,6,,void
46696,BLOCK,1,,<empty>,,,,1,,void
46699,BLOCK,-1,,"{
                    c->cas = ITEM_get_cas(it);
                    write_bin_response(c, &rsp->message.body, 0, 0, sizeof(rsp->message.body.value));
                }",51,,329,2,,void
46706,BLOCK,1,,<empty>,,,,4,,void
46740,BLOCK,-1,,"{
                    write_bin_error(c, PROTOCOL_BINARY_RESPONSE_NOT_STORED,
                                    NULL, 0);
                }",24,,332,1,,void
46749,BLOCK,-1,,"{
                out_of_memory(c,
                        ""SERVER_ERROR Out of memory allocating new item"");
            }",20,,337,1,,void
46754,BLOCK,-1,,"{
            pthread_mutex_lock(&c->thread->stats.mutex);
            if (c->cmd == PROTOCOL_BINARY_CMD_INCREMENT) {
                c->thread->stats.incr_misses++;
            } else {
                c->thread->stats.decr_misses++;
            }
            pthread_mutex_unlock(&c->thread->stats.mutex);

            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, NULL, 0);
        }",16,,341,1,,void
46770,BLOCK,-1,,"{
                c->thread->stats.incr_misses++;
            }",58,,343,2,,void
46780,BLOCK,-1,,"{
                c->thread->stats.decr_misses++;
            }",20,,345,1,,void
46816,BLOCK,-1,,"{
    protocol_binary_response_status eno = PROTOCOL_BINARY_RESPONSE_EINVAL;
    enum store_item_type ret = NOT_STORED;
    assert(c != NULL);

    item *it = c->item;
    pthread_mutex_lock(&c->thread->stats.mutex);
    c->thread->stats.slab_stats[ITEM_clsid(it)].set_cmds++;
    pthread_mutex_unlock(&c->thread->stats.mutex);

    /* We don't actually receive the trailing two characters in the bin
     * protocol, so we're going to just set them here */
    if ((it->it_flags & ITEM_CHUNKED) == 0) {
        *(ITEM_data(it) + it->nbytes - 2) = '\r';
        *(ITEM_data(it) + it->nbytes - 1) = '\n';
    } else {
        assert(c->ritem);
        item_chunk *ch = (item_chunk *) c->ritem;
        if (ch->size == ch->used)
            ch = ch->next;
        assert(ch->size - ch->used >= 2);
        ch->data[ch->used] = '\r';
        ch->data[ch->used + 1] = '\n';
        ch->used += 2;
    }

    ret = store_item(it, c->cmd, c);

#ifdef ENABLE_DTRACE
    uint64_t cas = ITEM_get_cas(it);
 ...",42,,359,2,,void
46856,BLOCK,1,,<empty>,,,,3,,void
46882,BLOCK,1,,<empty>,,,,1,,void
46885,BLOCK,-1,,"{
        *(ITEM_data(it) + it->nbytes - 2) = '\r';
        *(ITEM_data(it) + it->nbytes - 1) = '\n';
    }",45,,371,2,,void
46892,BLOCK,1,,<empty>,,,,6,,void
46936,BLOCK,1,,<empty>,,,,6,,void
46975,BLOCK,-1,,"{
        assert(c->ritem);
        item_chunk *ch = (item_chunk *) c->ritem;
        if (ch->size == ch->used)
            ch = ch->next;
        assert(ch->size - ch->used >= 2);
        ch->data[ch->used] = '\r';
        ch->data[ch->used + 1] = '\n';
        ch->used += 2;
    }",12,,374,1,,void
46996,BLOCK,-1,,<empty>,13,,378,2,,void
47047,BLOCK,-1,,"{
    case STORED:
        /* Stored */
        write_bin_response(c, NULL, 0, 0, 0);
        break;
    case EXISTS:
        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS, NULL, 0);
        break;
    case NOT_FOUND:
        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, NULL, 0);
        break;
    case NOT_STORED:
    case TOO_LARGE:
    case NO_MEMORY:
        if (c->cmd == NREAD_ADD) {
            eno = PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS;
        } else if(c->cmd == NREAD_REPLACE) {
            eno = PROTOCOL_BINARY_RESPONSE_KEY_ENOENT;
        } else {
            eno = PROTOCOL_BINARY_RESPONSE_NOT_STORED;
        }
        write_bin_error(c, eno, NULL, 0);
    }",18,,413,2,,void
47085,BLOCK,1,,<empty>,,,,1,,void
47087,BLOCK,-1,,"{
            eno = PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS;
        }",34,,427,2,,void
47092,BLOCK,-1,,<empty>,16,,429,1,,void
47099,BLOCK,1,,<empty>,,,,1,,void
47101,BLOCK,-1,,"{
            eno = PROTOCOL_BINARY_RESPONSE_KEY_ENOENT;
        }",44,,429,2,,void
47106,BLOCK,-1,,"{
            eno = PROTOCOL_BINARY_RESPONSE_NOT_STORED;
        }",16,,431,1,,void
47130,BLOCK,-1,,"{
    if (nkey) {
        add_bin_header(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT,
                0, nkey, nkey);
        char *ofs = c->resp->wbuf + sizeof(protocol_binary_response_header);
        memcpy(ofs, key, nkey);
        resp_add_iov(c->resp, ofs, nkey);
        conn_set_state(c, conn_new_cmd);
    } else {
        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT,
                        NULL, 0);
    }
}",70,,441,4,,void
47133,BLOCK,-1,,"{
        add_bin_header(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT,
                0, nkey, nkey);
        char *ofs = c->resp->wbuf + sizeof(protocol_binary_response_header);
        memcpy(ofs, key, nkey);
        resp_add_iov(c->resp, ofs, nkey);
        conn_set_state(c, conn_new_cmd);
    }",15,,442,2,,void
47165,BLOCK,-1,,"{
        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT,
                        NULL, 0);
    }",12,,449,1,,void
47176,BLOCK,-1,,"{
    item *it;

    protocol_binary_response_get* rsp = (protocol_binary_response_get*)c->resp->wbuf;
    char* key = binary_get_key(c);
    size_t nkey = c->binary_header.request.keylen;
    int should_touch = (c->cmd == PROTOCOL_BINARY_CMD_TOUCH ||
                        c->cmd == PROTOCOL_BINARY_CMD_GAT ||
                        c->cmd == PROTOCOL_BINARY_CMD_GATK);
    int should_return_key = (c->cmd == PROTOCOL_BINARY_CMD_GETK ||
                             c->cmd == PROTOCOL_BINARY_CMD_GATK);
    int should_return_value = (c->cmd != PROTOCOL_BINARY_CMD_TOUCH);
    bool failed = false;

    if (settings.verbose > 1) {
        fprintf(stderr, ""<%d %s "", c->sfd, should_touch ? ""TOUCH"" : ""GET"");
        if (fwrite(key, 1, nkey, stderr)) {}
        fputc('\n', stderr);
    }

    if (should_touch) {
        protocol_binary_request_touch *t = (void *)extbuf;
        time_t exptime = ntohl(t->message.body.expiration);

        it = item_touch(key, nkey, realtime(exptime), c);
    ...",61,,455,3,,void
47255,BLOCK,-1,,"{
        fprintf(stderr, ""<%d %s "", c->sfd, should_touch ? ""TOUCH"" : ""GET"");
        if (fwrite(key, 1, nkey, stderr)) {}
        fputc('\n', stderr);
    }",31,,469,2,,void
47272,BLOCK,-1,,<empty>,43,,471,2,,void
47278,BLOCK,-1,,"{
        protocol_binary_request_touch *t = (void *)extbuf;
        time_t exptime = ntohl(t->message.body.expiration);

        it = item_touch(key, nkey, realtime(exptime), c);
    }",23,,475,2,,void
47305,BLOCK,-1,,"{
        it = item_get(key, nkey, c, DO_UPDATE);
    }",12,,480,1,,void
47313,BLOCK,1,,<empty>,,,,1,,void
47317,BLOCK,-1,,"{
        /* the length has two unnecessary bytes (""\r\n"") */
        uint16_t keylen = 0;
        uint32_t bodylen = sizeof(rsp->message.body) + (it->nbytes - 2);

        pthread_mutex_lock(&c->thread->stats.mutex);
        if (should_touch) {
            c->thread->stats.touch_cmds++;
            c->thread->stats.slab_stats[ITEM_clsid(it)].touch_hits++;
        } else {
            c->thread->stats.get_cmds++;
            c->thread->stats.lru_hits[it->slabs_clsid]++;
        }
        pthread_mutex_unlock(&c->thread->stats.mutex);

        if (should_touch) {
            MEMCACHED_COMMAND_TOUCH(c->sfd, ITEM_key(it), it->nkey,
                                    it->nbytes, ITEM_get_cas(it));
        } else {
            MEMCACHED_COMMAND_GET(c->sfd, ITEM_key(it), it->nkey,
                                  it->nbytes, ITEM_get_cas(it));
        }

        if (c->cmd == PROTOCOL_BINARY_CMD_TOUCH) {
            bodylen -= it->nbytes - 2;
        } else if (should_return_key) {
    ...",13,,484,2,,void
47348,BLOCK,-1,,"{
            c->thread->stats.touch_cmds++;
            c->thread->stats.slab_stats[ITEM_clsid(it)].touch_hits++;
        }",27,,490,2,,void
47369,BLOCK,1,,<empty>,,,,3,,void
47380,BLOCK,-1,,"{
            c->thread->stats.get_cmds++;
            c->thread->stats.lru_hits[it->slabs_clsid]++;
        }",16,,493,1,,void
47412,BLOCK,-1,,"{
            MEMCACHED_COMMAND_TOUCH(c->sfd, ITEM_key(it), it->nkey,
                                    it->nbytes, ITEM_get_cas(it));
        }",27,,499,2,,void
47414,BLOCK,-1,,"{
            MEMCACHED_COMMAND_GET(c->sfd, ITEM_key(it), it->nkey,
                                  it->nbytes, ITEM_get_cas(it));
        }",16,,502,1,,void
47421,BLOCK,-1,,"{
            bodylen -= it->nbytes - 2;
        }",50,,507,2,,void
47430,BLOCK,-1,,<empty>,16,,509,1,,void
47433,BLOCK,-1,,"{
            bodylen += nkey;
            keylen = nkey;
        }",39,,509,2,,void
47464,BLOCK,1,,<empty>,,,,4,,void
47488,BLOCK,1,,"FLAGS_CONV(it, rsp->message.body.flags)",9,,518,12,,void
47495,BLOCK,-1,,"FLAGS_CONV(it, rsp->message.body.flags)",9,,518,2,,void
47530,BLOCK,-1,,"FLAGS_CONV(it, rsp->message.body.flags)",9,,518,1,,void
47574,BLOCK,-1,,"{
            resp_add_iov(c->resp, ITEM_key(it), nkey);
        }",32,,522,2,,void
47581,BLOCK,1,,<empty>,,,,4,,void
47601,BLOCK,-1,,"{
            /* Add the data minus the CRLF */
#ifdef EXTSTORE
            if (it->it_flags & ITEM_HDR) {
                if (storage_get_item(c, it, c->resp) != 0) {
                    pthread_mutex_lock(&c->thread->stats.mutex);
                    c->thread->stats.get_oom_extstore++;
                    pthread_mutex_unlock(&c->thread->stats.mutex);

                    failed = true;
                }
            } else if ((it->it_flags & ITEM_CHUNKED) == 0) {
                resp_add_iov(c->resp, ITEM_data(it), it->nbytes - 2);
            } else {
                // Allow transmit handler to find the item and expand iov's
                resp_add_chunked_iov(c->resp, it, it->nbytes - 2);
            }
#else
            if ((it->it_flags & ITEM_CHUNKED) == 0) {
                resp_add_iov(c->resp, ITEM_data(it), it->nbytes - 2);
            } else {
                resp_add_chunked_iov(c->resp, it, it->nbytes - 2);
            }
#endif
        }",34,,526,2,,void
47609,BLOCK,1,,<empty>,,,,1,,void
47612,BLOCK,-1,,"{
                resp_add_iov(c->resp, ITEM_data(it), it->nbytes - 2);
            }",53,,544,2,,void
47619,BLOCK,1,,<empty>,,,,6,,void
47658,BLOCK,-1,,"{
                resp_add_chunked_iov(c->resp, it, it->nbytes - 2);
            }",20,,546,1,,void
47672,BLOCK,-1,,"{
            conn_set_state(c, conn_new_cmd);
            /* Remember this command so we can garbage collect it later */
#ifdef EXTSTORE
            if ((it->it_flags & ITEM_HDR) != 0 && should_return_value) {
                // Only have extstore clean if header and returning value.
                c->resp->item = NULL;
            } else {
                c->resp->item = it;
            }
#else
            c->resp->item = it;
#endif
        }",22,,552,2,,void
47684,BLOCK,-1,,"{
            item_remove(it);
        }",16,,565,1,,void
47688,BLOCK,-1,,"{
        failed = true;
    }",12,,568,1,,void
47694,BLOCK,-1,,"{
        pthread_mutex_lock(&c->thread->stats.mutex);
        if (should_touch) {
            c->thread->stats.touch_cmds++;
            c->thread->stats.touch_misses++;
        } else {
            c->thread->stats.get_cmds++;
            c->thread->stats.get_misses++;
        }
        pthread_mutex_unlock(&c->thread->stats.mutex);

        if (should_touch) {
            MEMCACHED_COMMAND_TOUCH(c->sfd, key, nkey, -1, 0);
        } else {
            MEMCACHED_COMMAND_GET(c->sfd, key, nkey, -1, 0);
        }

        if (c->noreply) {
            conn_set_state(c, conn_new_cmd);
        } else {
            if (should_return_key) {
                write_bin_miss_response(c, key, nkey);
            } else {
                write_bin_miss_response(c, NULL, 0);
            }
        }
    }",17,,572,2,,void
47706,BLOCK,-1,,"{
            c->thread->stats.touch_cmds++;
            c->thread->stats.touch_misses++;
        }",27,,574,2,,void
47724,BLOCK,-1,,"{
            c->thread->stats.get_cmds++;
            c->thread->stats.get_misses++;
        }",16,,577,1,,void
47752,BLOCK,-1,,"{
            MEMCACHED_COMMAND_TOUCH(c->sfd, key, nkey, -1, 0);
        }",27,,583,2,,void
47754,BLOCK,-1,,"{
            MEMCACHED_COMMAND_GET(c->sfd, key, nkey, -1, 0);
        }",16,,585,1,,void
47759,BLOCK,-1,,"{
            conn_set_state(c, conn_new_cmd);
        }",25,,589,2,,void
47764,BLOCK,-1,,"{
            if (should_return_key) {
                write_bin_miss_response(c, key, nkey);
            } else {
                write_bin_miss_response(c, NULL, 0);
            }
        }",16,,591,1,,void
47767,BLOCK,-1,,"{
                write_bin_miss_response(c, key, nkey);
            }",36,,592,2,,void
47773,BLOCK,-1,,"{
                write_bin_miss_response(c, NULL, 0);
            }",20,,594,1,,void
47782,BLOCK,-1,,"{
        stats_prefix_record_get(key, nkey, NULL != it);
    }",34,,600,2,,void
47793,BLOCK,-1,,"{
    char *subcommand = binary_get_key(c);
    size_t nkey = c->binary_header.request.keylen;

    if (settings.verbose > 1) {
        int ii;
        fprintf(stderr, ""<%d STATS "", c->sfd);
        for (ii = 0; ii < nkey; ++ii) {
            fprintf(stderr, ""%c"", subcommand[ii]);
        }
        fprintf(stderr, ""\n"");
    }

    if (nkey == 0) {
        /* request all statistics */
        server_stats(&append_stats, c);
        (void)get_stats(NULL, 0, &append_stats, c);
    } else if (strncmp(subcommand, ""reset"", 5) == 0) {
        stats_reset();
    } else if (strncmp(subcommand, ""settings"", 8) == 0) {
        process_stat_settings(&append_stats, c);
    } else if (strncmp(subcommand, ""detail"", 6) == 0) {
        char *subcmd_pos = subcommand + 6;
        if (strncmp(subcmd_pos, "" dump"", 5) == 0) {
            int len;
            char *dump_buf = stats_prefix_dump(&len);
            if (dump_buf == NULL || len <= 0) {
                out_of_memory(c, ""SERVER_ERROR Out of memo...",39,,605,2,,void
47815,BLOCK,-1,,"{
        int ii;
        fprintf(stderr, ""<%d STATS "", c->sfd);
        for (ii = 0; ii < nkey; ++ii) {
            fprintf(stderr, ""%c"", subcommand[ii]);
        }
        fprintf(stderr, ""\n"");
    }",31,,609,2,,void
47824,BLOCK,-1,,<empty>,9,,612,1,,void
47833,BLOCK,4,,"{
            fprintf(stderr, ""%c"", subcommand[ii]);
        }",39,,612,4,,void
47847,BLOCK,-1,,"{
        /* request all statistics */
        server_stats(&append_stats, c);
        (void)get_stats(NULL, 0, &append_stats, c);
    }",20,,618,2,,void
47861,BLOCK,-1,,<empty>,12,,622,1,,void
47869,BLOCK,-1,,"{
        stats_reset();
    }",54,,622,2,,void
47872,BLOCK,-1,,<empty>,12,,624,1,,void
47880,BLOCK,-1,,"{
        process_stat_settings(&append_stats, c);
    }",57,,624,2,,void
47886,BLOCK,-1,,<empty>,12,,626,1,,void
47894,BLOCK,-1,,"{
        char *subcmd_pos = subcommand + 6;
        if (strncmp(subcmd_pos, "" dump"", 5) == 0) {
            int len;
            char *dump_buf = stats_prefix_dump(&len);
            if (dump_buf == NULL || len <= 0) {
                out_of_memory(c, ""SERVER_ERROR Out of memory generating stats"");
                if (dump_buf != NULL)
                    free(dump_buf);
                return;
            } else {
                append_stats(""detailed"", strlen(""detailed""), dump_buf, len, c);
                free(dump_buf);
            }
        } else if (strncmp(subcmd_pos, "" on"", 3) == 0) {
            settings.detail_enabled = 1;
        } else if (strncmp(subcmd_pos, "" off"", 4) == 0) {
            settings.detail_enabled = 0;
        } else {
            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, NULL, 0);
            return;
        }
    }",55,,626,2,,void
47908,BLOCK,-1,,"{
            int len;
            char *dump_buf = stats_prefix_dump(&len);
            if (dump_buf == NULL || len <= 0) {
                out_of_memory(c, ""SERVER_ERROR Out of memory generating stats"");
                if (dump_buf != NULL)
                    free(dump_buf);
                return;
            } else {
                append_stats(""detailed"", strlen(""detailed""), dump_buf, len, c);
                free(dump_buf);
            }
        }",51,,628,2,,void
47924,BLOCK,-1,,"{
                out_of_memory(c, ""SERVER_ERROR Out of memory generating stats"");
                if (dump_buf != NULL)
                    free(dump_buf);
                return;
            }",47,,631,2,,void
47932,BLOCK,-1,,<empty>,21,,634,2,,void
47937,BLOCK,-1,,"{
                append_stats(""detailed"", strlen(""detailed""), dump_buf, len, c);
                free(dump_buf);
            }",20,,636,1,,void
47948,BLOCK,-1,,<empty>,16,,640,1,,void
47956,BLOCK,-1,,"{
            settings.detail_enabled = 1;
        }",56,,640,2,,void
47963,BLOCK,-1,,<empty>,16,,642,1,,void
47971,BLOCK,-1,,"{
            settings.detail_enabled = 0;
        }",57,,642,2,,void
47978,BLOCK,-1,,"{
            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, NULL, 0);
            return;
        }",16,,644,1,,void
47986,BLOCK,-1,,"{
        if (get_stats(subcommand, nkey, &append_stats, c)) {
            if (c->stats.buffer == NULL) {
                out_of_memory(c, ""SERVER_ERROR Out of memory generating stats"");
            } else {
                write_and_free(c, c->stats.buffer, c->stats.offset);
                c->stats.buffer = NULL;
            }
        } else {
            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, NULL, 0);
        }

        return;
    }",12,,648,1,,void
47994,BLOCK,-1,,"{
            if (c->stats.buffer == NULL) {
                out_of_memory(c, ""SERVER_ERROR Out of memory generating stats"");
            } else {
                write_and_free(c, c->stats.buffer, c->stats.offset);
                c->stats.buffer = NULL;
            }
        }",60,,649,2,,void
48003,BLOCK,-1,,"{
                out_of_memory(c, ""SERVER_ERROR Out of memory generating stats"");
            }",42,,650,2,,void
48008,BLOCK,-1,,"{
                write_and_free(c, c->stats.buffer, c->stats.offset);
                c->stats.buffer = NULL;
            }",20,,652,1,,void
48029,BLOCK,-1,,"{
            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, NULL, 0);
        }",16,,656,1,,void
48050,BLOCK,-1,,"{
        out_of_memory(c, ""SERVER_ERROR Out of memory preparing to send stats"");
    }",34,,665,2,,void
48055,BLOCK,-1,,"{
        write_and_free(c, c->stats.buffer, c->stats.offset);
        c->stats.buffer = NULL;
    }",12,,667,1,,void
48079,BLOCK,-1,,"{
    assert(c);
    /* should something else be returned? */
    if (!settings.sasl)
        return;

    c->authenticated = false;

    if (!c->sasl_conn) {
        int result=sasl_server_new(""memcached"",
                                   NULL,
                                   my_sasl_hostname[0] ? my_sasl_hostname : NULL,
                                   NULL, NULL,
                                   NULL, 0, &c->sasl_conn);
        if (result != SASL_OK) {
            if (settings.verbose) {
                fprintf(stderr, ""Failed to initialize SASL conn.\n"");
            }
            c->sasl_conn = NULL;
        }
    }
}",37,,673,2,,void
48087,BLOCK,-1,,<empty>,9,,677,2,,void
48099,BLOCK,-1,,"{
        int result=sasl_server_new(""memcached"",
                                   NULL,
                                   my_sasl_hostname[0] ? my_sasl_hostname : NULL,
                                   NULL, NULL,
                                   NULL, 0, &c->sasl_conn);
        if (result != SASL_OK) {
            if (settings.verbose) {
                fprintf(stderr, ""Failed to initialize SASL conn.\n"");
            }
            c->sasl_conn = NULL;
        }
    }",24,,681,2,,void
48104,BLOCK,1,,<empty>,,,,1,,void
48110,BLOCK,1,,<empty>,,,,1,,void
48112,BLOCK,-1,,"{
            if (settings.verbose) {
                fprintf(stderr, ""Failed to initialize SASL conn.\n"");
            }
            c->sasl_conn = NULL;
        }",32,,687,2,,void
48117,BLOCK,-1,,"{
                fprintf(stderr, ""Failed to initialize SASL conn.\n"");
            }",35,,688,2,,void
48130,BLOCK,-1,,"{
    // Guard against a disabled SASL.
    if (!settings.sasl) {
        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND, NULL,
                        c->binary_header.request.bodylen
                        - c->binary_header.request.keylen);
        return;
    }

    init_sasl_conn(c);
    const char *result_string = NULL;
    unsigned int string_length = 0;
    int result=sasl_listmech(c->sasl_conn, NULL,
                             """",   /* What to prepend the string with */
                             "" "",  /* What to separate mechanisms with */
                             """",   /* What to append to the string */
                             &result_string, &string_length,
                             NULL);
    if (result != SASL_OK) {
        /* Perhaps there's a better error for this... */
        if (settings.verbose) {
            fprintf(stderr, ""Failed to list SASL mechanisms.\n"");
        }
        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_AUTH_ERROR...",42,,696,2,,void
48136,BLOCK,-1,,"{
        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND, NULL,
                        c->binary_header.request.bodylen
                        - c->binary_header.request.keylen);
        return;
    }",25,,698,2,,void
48171,BLOCK,1,,<empty>,,,,1,,void
48177,BLOCK,1,,<empty>,,,,1,,void
48179,BLOCK,-1,,"{
        /* Perhaps there's a better error for this... */
        if (settings.verbose) {
            fprintf(stderr, ""Failed to list SASL mechanisms.\n"");
        }
        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_AUTH_ERROR, NULL, 0);
        return;
    }",28,,714,2,,void
48184,BLOCK,-1,,"{
            fprintf(stderr, ""Failed to list SASL mechanisms.\n"");
        }",31,,716,2,,void
48206,BLOCK,-1,,"{
    // Guard for handling disabled SASL on the server.
    if (!settings.sasl) {
        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND, NULL,
                        c->binary_header.request.bodylen
                        - c->binary_header.request.keylen);
        return;
    }

    assert(c->binary_header.request.extlen == 0);

    int nkey = c->binary_header.request.keylen;
    int vlen = c->binary_header.request.bodylen - nkey;

    if (nkey > MAX_SASL_MECH_LEN) {
        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_EINVAL, NULL, vlen);
        conn_set_state(c, conn_swallow);
        return;
    }

    char *key = binary_get_key(c);
    assert(key);

    item *it = item_alloc(key, nkey, 0, 0, vlen+2);

    /* Can't use a chunked item for SASL authentication. */
    if (it == 0 || (it->it_flags & ITEM_CHUNKED)) {
        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, NULL, vlen);
        conn_set_state(c, conn_swallow);
        if (it) {
            do_item_...",44,,725,2,,void
48212,BLOCK,-1,,"{
        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND, NULL,
                        c->binary_header.request.bodylen
                        - c->binary_header.request.keylen);
        return;
    }",25,,727,2,,void
48269,BLOCK,1,,<empty>,,,,1,,void
48271,BLOCK,-1,,"{
        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_EINVAL, NULL, vlen);
        conn_set_state(c, conn_swallow);
        return;
    }",35,,739,2,,void
48309,BLOCK,1,,<empty>,,,,1,,void
48311,BLOCK,-1,,"{
        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, NULL, vlen);
        conn_set_state(c, conn_swallow);
        if (it) {
            do_item_remove(it);
        }
        return;
    }",51,,751,2,,void
48322,BLOCK,-1,,"{
            do_item_remove(it);
        }",17,,754,2,,void
48337,BLOCK,1,,<empty>,,,,6,,void
48387,BLOCK,-1,,"{
    assert(settings.sasl);
    const char *out = NULL;
    unsigned int outlen = 0;

    assert(c->item);
    init_sasl_conn(c);

    int nkey = c->binary_header.request.keylen;
    int vlen = c->binary_header.request.bodylen - nkey;

    if (nkey > ((item*) c->item)->nkey) {
        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_EINVAL, NULL, vlen);
        conn_set_state(c, conn_swallow);
        return;
    }

    char mech[nkey+1];
    memcpy(mech, ITEM_key((item*)c->item), nkey);
    mech[nkey] = 0x00;

    if (settings.verbose)
        fprintf(stderr, ""mech:  ``%s'' with %d bytes of data\n"", mech, vlen);

    const char *challenge = vlen == 0 ? NULL : ITEM_data((item*) c->item);

    if (vlen > ((item*) c->item)->nbytes) {
        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_EINVAL, NULL, vlen);
        conn_set_state(c, conn_swallow);
        return;
    }

    int result=-1;

    switch (c->cmd) {
    case PROTOCOL_BINARY_CMD_SASL_AUTH:
        result = sasl_server_start(c->sa...",53,,767,2,,void
48438,BLOCK,-1,,"{
        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_EINVAL, NULL, vlen);
        conn_set_state(c, conn_swallow);
        return;
    }",41,,778,2,,void
48452,BLOCK,1,,<empty>,,,,1,,void
48487,BLOCK,-1,,<empty>,9,,789,2,,void
48502,BLOCK,1,,<empty>,,,,1,,void
48561,BLOCK,-1,,"{
        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_EINVAL, NULL, vlen);
        conn_set_state(c, conn_swallow);
        return;
    }",43,,793,2,,void
48580,BLOCK,-1,,"{
    case PROTOCOL_BINARY_CMD_SASL_AUTH:
        result = sasl_server_start(c->sasl_conn, mech,
                                   challenge, vlen,
                                   &out, &outlen);
        c->sasl_started = (result == SASL_OK || result == SASL_CONTINUE);
        break;
    case PROTOCOL_BINARY_CMD_SASL_STEP:
        if (!c->sasl_started) {
            if (settings.verbose) {
                fprintf(stderr, ""%d: SASL_STEP called but sasl_server_start ""
                        ""not called for this connection!\n"", c->sfd);
            }
            break;
        }
        result = sasl_server_step(c->sasl_conn,
                                  challenge, vlen,
                                  &out, &outlen);
        break;
    default:
        assert(false); /* CMD should be one of the above */
        /* This code is pretty much impossible, but makes the compiler
           happier */
        if (settings.verbose) {
            fprintf(stderr, ""Unhandled command ...",21,,801,2,,void
48586,BLOCK,1,,<empty>,,,,1,,void
48596,BLOCK,1,,<empty>,,,,1,,void
48601,BLOCK,1,,<empty>,,,,1,,void
48612,BLOCK,-1,,"{
            if (settings.verbose) {
                fprintf(stderr, ""%d: SASL_STEP called but sasl_server_start ""
                        ""not called for this connection!\n"", c->sfd);
            }
            break;
        }",31,,809,2,,void
48617,BLOCK,-1,,"{
                fprintf(stderr, ""%d: SASL_STEP called but sasl_server_start ""
                        ""not called for this connection!\n"", c->sfd);
            }",35,,810,2,,void
48628,BLOCK,1,,<empty>,,,,1,,void
48638,BLOCK,-1,,"{
            fprintf(stderr, ""Unhandled command %d with challenge %s\n"",
                    c->cmd, challenge);
        }",31,,824,2,,void
48651,BLOCK,-1,,"{
        fprintf(stderr, ""sasl result code:  %d\n"", result);
    }",27,,831,2,,void
48658,BLOCK,-1,,"{
    case SASL_OK:
        c->authenticated = true;
        write_bin_response(c, ""Authenticated"", 0, 0, strlen(""Authenticated""));
        pthread_mutex_lock(&c->thread->stats.mutex);
        c->thread->stats.auth_cmds++;
        pthread_mutex_unlock(&c->thread->stats.mutex);
        break;
    case SASL_CONTINUE:
        add_bin_header(c, PROTOCOL_BINARY_RESPONSE_AUTH_CONTINUE, 0, 0, outlen);
        if (outlen > 0) {
            resp_add_iov(c->resp, out, outlen);
        }
        // Immediately flush our write.
        conn_set_state(c, conn_mwrite);
        break;
    default:
        if (settings.verbose)
            fprintf(stderr, ""Unknown sasl response:  %d\n"", result);
        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_AUTH_ERROR, NULL, 0);
        pthread_mutex_lock(&c->thread->stats.mutex);
        c->thread->stats.auth_cmds++;
        c->thread->stats.auth_errors++;
        pthread_mutex_unlock(&c->thread->stats.mutex);
    }",20,,835,2,,void
48661,BLOCK,1,,<empty>,,,,1,,void
48704,BLOCK,1,,<empty>,,,,1,,void
48717,BLOCK,-1,,"{
            resp_add_iov(c->resp, out, outlen);
        }",25,,845,2,,void
48733,BLOCK,-1,,<empty>,13,,853,2,,void
48781,BLOCK,-1,,"{
    assert(settings.sasl);
    bool rv = false;

    switch (c->cmd) {
    case PROTOCOL_BINARY_CMD_SASL_LIST_MECHS: /* FALLTHROUGH */
    case PROTOCOL_BINARY_CMD_SASL_AUTH:       /* FALLTHROUGH */
    case PROTOCOL_BINARY_CMD_SASL_STEP:       /* FALLTHROUGH */
    case PROTOCOL_BINARY_CMD_VERSION:         /* FALLTHROUGH */
        rv = true;
        break;
    default:
        rv = c->authenticated;
    }

    if (settings.verbose > 1) {
        fprintf(stderr, ""authenticated() in cmd 0x%02x is %s\n"",
                c->cmd, rv ? ""true"" : ""false"");
    }

    return rv;
}",36,,862,2,,void
48794,BLOCK,-1,,"{
    case PROTOCOL_BINARY_CMD_SASL_LIST_MECHS: /* FALLTHROUGH */
    case PROTOCOL_BINARY_CMD_SASL_AUTH:       /* FALLTHROUGH */
    case PROTOCOL_BINARY_CMD_SASL_STEP:       /* FALLTHROUGH */
    case PROTOCOL_BINARY_CMD_VERSION:         /* FALLTHROUGH */
        rv = true;
        break;
    default:
        rv = c->authenticated;
    }",21,,866,2,,void
48819,BLOCK,-1,,"{
        fprintf(stderr, ""authenticated() in cmd 0x%02x is %s\n"",
                c->cmd, rv ? ""true"" : ""false"");
    }",31,,877,2,,void
48837,BLOCK,-1,,"{
    int protocol_error = 0;

    uint8_t extlen = c->binary_header.request.extlen;
    uint16_t keylen = c->binary_header.request.keylen;
    uint32_t bodylen = c->binary_header.request.bodylen;

    if (keylen > bodylen || keylen + extlen > bodylen) {
        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND, NULL, 0);
        c->close_after_write = true;
        return;
    }

    if (settings.sasl && !authenticated(c)) {
        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_AUTH_ERROR, NULL, 0);
        c->close_after_write = true;
        return;
    }

    MEMCACHED_PROCESS_COMMAND_START(c->sfd, c->rcurr, c->rbytes);
    c->noreply = true;

    /* binprot supports 16bit keys, but internals are still 8bit */
    if (keylen > KEY_MAX_LENGTH) {
        handle_binary_protocol_error(c);
        return;
    }

    switch (c->cmd) {
    case PROTOCOL_BINARY_CMD_SETQ:
        c->cmd = PROTOCOL_BINARY_CMD_SET;
        break;
    case PROTOCOL_BINARY_CMD_ADDQ:
        c->cmd = ...",57,,885,3,,void
48882,BLOCK,-1,,"{
        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND, NULL, 0);
        c->close_after_write = true;
        return;
    }",56,,892,2,,void
48902,BLOCK,-1,,"{
        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_AUTH_ERROR, NULL, 0);
        c->close_after_write = true;
        return;
    }",45,,898,2,,void
48923,BLOCK,1,,<empty>,,,,1,,void
48925,BLOCK,-1,,"{
        handle_binary_protocol_error(c);
        return;
    }",34,,908,2,,void
48933,BLOCK,-1,,"{
    case PROTOCOL_BINARY_CMD_SETQ:
        c->cmd = PROTOCOL_BINARY_CMD_SET;
        break;
    case PROTOCOL_BINARY_CMD_ADDQ:
        c->cmd = PROTOCOL_BINARY_CMD_ADD;
        break;
    case PROTOCOL_BINARY_CMD_REPLACEQ:
        c->cmd = PROTOCOL_BINARY_CMD_REPLACE;
        break;
    case PROTOCOL_BINARY_CMD_DELETEQ:
        c->cmd = PROTOCOL_BINARY_CMD_DELETE;
        break;
    case PROTOCOL_BINARY_CMD_INCREMENTQ:
        c->cmd = PROTOCOL_BINARY_CMD_INCREMENT;
        break;
    case PROTOCOL_BINARY_CMD_DECREMENTQ:
        c->cmd = PROTOCOL_BINARY_CMD_DECREMENT;
        break;
    case PROTOCOL_BINARY_CMD_QUITQ:
        c->cmd = PROTOCOL_BINARY_CMD_QUIT;
        break;
    case PROTOCOL_BINARY_CMD_FLUSHQ:
        c->cmd = PROTOCOL_BINARY_CMD_FLUSH;
        break;
    case PROTOCOL_BINARY_CMD_APPENDQ:
        c->cmd = PROTOCOL_BINARY_CMD_APPEND;
        break;
    case PROTOCOL_BINARY_CMD_PREPENDQ:
        c->cmd = PROTOCOL_BINARY_CMD_PREPEND;
        break;
    case PROTOCOL...",21,,913,2,,void
49056,BLOCK,-1,,"{
        case PROTOCOL_BINARY_CMD_VERSION:
            if (extlen == 0 && keylen == 0 && bodylen == 0) {
                write_bin_response(c, VERSION, 0, 0, strlen(VERSION));
            } else {
                protocol_error = 1;
            }
            break;
        case PROTOCOL_BINARY_CMD_FLUSH:
            if (keylen == 0 && bodylen == extlen && (extlen == 0 || extlen == 4)) {
                process_bin_flush(c, extbuf);
            } else {
                protocol_error = 1;
            }
            break;
        case PROTOCOL_BINARY_CMD_NOOP:
            if (extlen == 0 && keylen == 0 && bodylen == 0) {
                write_bin_response(c, NULL, 0, 0, 0);
                // NOOP forces pipeline flush.
                conn_set_state(c, conn_mwrite);
            } else {
                protocol_error = 1;
            }
            break;
        case PROTOCOL_BINARY_CMD_SET: /* FALLTHROUGH */
        case PROTOCOL_BINARY_CMD_ADD: /* FALLTHROUGH */
        case PROTO...",21,,960,2,,void
49071,BLOCK,-1,,"{
                write_bin_response(c, VERSION, 0, 0, strlen(VERSION));
            }",61,,962,2,,void
49080,BLOCK,-1,,"{
                protocol_error = 1;
            }",20,,964,1,,void
49103,BLOCK,-1,,"{
                process_bin_flush(c, extbuf);
            }",83,,969,2,,void
49108,BLOCK,-1,,"{
                protocol_error = 1;
            }",20,,971,1,,void
49127,BLOCK,-1,,"{
                write_bin_response(c, NULL, 0, 0, 0);
                // NOOP forces pipeline flush.
                conn_set_state(c, conn_mwrite);
            }",61,,976,2,,void
49138,BLOCK,-1,,"{
                protocol_error = 1;
            }",20,,980,1,,void
49163,BLOCK,-1,,"{
                process_bin_update(c, extbuf);
            }",72,,987,2,,void
49168,BLOCK,-1,,"{
                protocol_error = 1;
            }",20,,989,1,,void
49193,BLOCK,-1,,"{
                process_bin_get_or_touch(c, extbuf);
            }",65,,997,2,,void
49198,BLOCK,-1,,"{
                protocol_error = 1;
            }",20,,999,1,,void
49217,BLOCK,-1,,"{
                process_bin_delete(c);
            }",65,,1004,2,,void
49221,BLOCK,-1,,"{
                protocol_error = 1;
            }",20,,1006,1,,void
49244,BLOCK,-1,,"{
                complete_incr_bin(c, extbuf);
            }",77,,1012,2,,void
49249,BLOCK,-1,,"{
                protocol_error = 1;
            }",20,,1014,1,,void
49266,BLOCK,-1,,"{
                process_bin_append_prepend(c);
            }",44,,1020,2,,void
49270,BLOCK,-1,,"{
                protocol_error = 1;
            }",20,,1022,1,,void
49281,BLOCK,-1,,"{
                process_bin_stat(c);
            }",30,,1027,2,,void
49285,BLOCK,-1,,"{
                protocol_error = 1;
            }",20,,1029,1,,void
49304,BLOCK,-1,,"{
                write_bin_response(c, NULL, 0, 0, 0);
                conn_set_state(c, conn_mwrite);
                c->close_after_write = true;
                c->close_reason = NORMAL_CLOSE;
            }",61,,1034,2,,void
49325,BLOCK,-1,,"{
                protocol_error = 1;
            }",20,,1039,1,,void
49344,BLOCK,-1,,"{
                bin_list_sasl_mechs(c);
            }",61,,1044,2,,void
49348,BLOCK,-1,,"{
                protocol_error = 1;
            }",20,,1046,1,,void
49365,BLOCK,-1,,"{
                process_bin_sasl_auth(c);
            }",45,,1052,2,,void
49369,BLOCK,-1,,"{
                protocol_error = 1;
            }",20,,1054,1,,void
49392,BLOCK,-1,,"{
                process_bin_get_or_touch(c, extbuf);
            }",45,,1063,2,,void
49397,BLOCK,-1,,"{
                protocol_error = 1;
            }",20,,1065,1,,void
49410,BLOCK,-1,,<empty>,9,,1075,2,,void
49418,BLOCK,-1,,"{
    char *key;
    int nkey;
    int vlen;
    item *it;
    protocol_binary_request_set* req = (void *)extbuf;

    assert(c != NULL);

    key = binary_get_key(c);
    nkey = c->binary_header.request.keylen;

    /* fix byteorder in the request */
    req->message.body.flags = ntohl(req->message.body.flags);
    req->message.body.expiration = ntohl(req->message.body.expiration);

    vlen = c->binary_header.request.bodylen - (nkey + c->binary_header.request.extlen);

    if (settings.verbose > 1) {
        int ii;
        if (c->cmd == PROTOCOL_BINARY_CMD_ADD) {
            fprintf(stderr, ""<%d ADD "", c->sfd);
        } else if (c->cmd == PROTOCOL_BINARY_CMD_SET) {
            fprintf(stderr, ""<%d SET "", c->sfd);
        } else {
            fprintf(stderr, ""<%d REPLACE "", c->sfd);
        }
        for (ii = 0; ii < nkey; ++ii) {
            fprintf(stderr, ""%c"", key[ii]);
        }

        fprintf(stderr, "" Value len is %d"", vlen);
        fprintf(stderr, ""\n"");
    }

    if...",55,,1078,3,,void
49503,BLOCK,-1,,"{
        int ii;
        if (c->cmd == PROTOCOL_BINARY_CMD_ADD) {
            fprintf(stderr, ""<%d ADD "", c->sfd);
        } else if (c->cmd == PROTOCOL_BINARY_CMD_SET) {
            fprintf(stderr, ""<%d SET "", c->sfd);
        } else {
            fprintf(stderr, ""<%d REPLACE "", c->sfd);
        }
        for (ii = 0; ii < nkey; ++ii) {
            fprintf(stderr, ""%c"", key[ii]);
        }

        fprintf(stderr, "" Value len is %d"", vlen);
        fprintf(stderr, ""\n"");
    }",31,,1096,2,,void
49511,BLOCK,-1,,"{
            fprintf(stderr, ""<%d ADD "", c->sfd);
        }",48,,1098,2,,void
49519,BLOCK,-1,,<empty>,16,,1100,1,,void
49526,BLOCK,-1,,"{
            fprintf(stderr, ""<%d SET "", c->sfd);
        }",55,,1100,2,,void
49534,BLOCK,-1,,"{
            fprintf(stderr, ""<%d REPLACE "", c->sfd);
        }",16,,1102,1,,void
49542,BLOCK,-1,,<empty>,9,,1105,1,,void
49551,BLOCK,4,,"{
            fprintf(stderr, ""%c"", key[ii]);
        }",39,,1105,4,,void
49569,BLOCK,-1,,"{
        stats_prefix_record_set(key, nkey);
    }",34,,1113,2,,void
49600,BLOCK,-1,,"{
        enum store_item_type status;
        if (! item_size_ok(nkey, req->message.body.flags, vlen + 2)) {
            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_E2BIG, NULL, vlen);
            status = TOO_LARGE;
        } else {
            out_of_memory(c, ""SERVER_ERROR Out of memory allocating item"");
            /* This error generating method eats the swallow value. Add here. */
            c->sbytes = vlen;
            status = NO_MEMORY;
        }
        /* FIXME: losing c->cmd since it's translated below. refactor? */
        LOGGER_LOG(c->thread->l, LOG_MUTATIONS, LOGGER_ITEM_STORE,
                NULL, status, 0, key, nkey, req->message.body.expiration,
                ITEM_clsid(it), c->sfd);

        /* Avoid stale data persisting in cache because we failed alloc.
         * Unacceptable for SET. Anywhere else too? */
        if (c->cmd == PROTOCOL_BINARY_CMD_SET) {
            it = item_get(key, nkey, c, DONT_UPDATE);
            if (it) {
                item_un...",18,,1120,2,,void
49616,BLOCK,-1,,"{
            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_E2BIG, NULL, vlen);
            status = TOO_LARGE;
        }",70,,1122,2,,void
49626,BLOCK,-1,,"{
            out_of_memory(c, ""SERVER_ERROR Out of memory allocating item"");
            /* This error generating method eats the swallow value. Add here. */
            c->sbytes = vlen;
            status = NO_MEMORY;
        }",16,,1125,1,,void
49646,BLOCK,1,,<empty>,,,,11,,void
49648,BLOCK,-1,,"LOGGER_LOG(c->thread->l, LOG_MUTATIONS, LOGGER_ITEM_STORE,
                NULL, status, 0, key, nkey, req->message.body.expiration,
                ITEM_clsid(it), c->sfd)",9,,1132,1,,void
49665,BLOCK,-1,,<empty>,9,,1132,2,,void
49680,BLOCK,-1,,<empty>,9,,1132,2,,void
49714,BLOCK,-1,,"{
            it = item_get(key, nkey, c, DONT_UPDATE);
            if (it) {
                item_unlink(it);
                STORAGE_delete(c->thread->storage, it);
                item_remove(it);
            }
        }",48,,1138,2,,void
49722,BLOCK,1,,<empty>,,,,1,,void
49726,BLOCK,-1,,"{
                item_unlink(it);
                STORAGE_delete(c->thread->storage, it);
                item_remove(it);
            }",21,,1140,2,,void
49744,BLOCK,1,,"ITEM_set_cas(it, c->binary_header.request.cas)",5,,1152,17,,void
49751,BLOCK,-1,,"ITEM_set_cas(it, c->binary_header.request.cas)",5,,1152,2,,void
49769,BLOCK,-1,,"{
        case PROTOCOL_BINARY_CMD_ADD:
            c->cmd = NREAD_ADD;
            break;
        case PROTOCOL_BINARY_CMD_SET:
            c->cmd = NREAD_SET;
            break;
        case PROTOCOL_BINARY_CMD_REPLACE:
            c->cmd = NREAD_REPLACE;
            break;
        default:
            assert(0);
    }",21,,1154,2,,void
49777,BLOCK,1,,<empty>,,,,1,,void
49787,BLOCK,1,,<empty>,,,,1,,void
49797,BLOCK,1,,<empty>,,,,1,,void
49807,BLOCK,1,,<empty>,,,,4,,void
49823,BLOCK,-1,,"{
        c->cmd = NREAD_CAS;
    }",32,,1168,2,,void
49829,BLOCK,1,,<empty>,,,,1,,void
49842,BLOCK,1,,<empty>,,,,6,,void
49892,BLOCK,-1,,"{
    char *key;
    int nkey;
    int vlen;
    item *it;

    assert(c != NULL);

    key = binary_get_key(c);
    nkey = c->binary_header.request.keylen;
    vlen = c->binary_header.request.bodylen - nkey;

    if (settings.verbose > 1) {
        fprintf(stderr, ""Value len is %d\n"", vlen);
    }

    if (settings.detail_enabled) {
        stats_prefix_record_set(key, nkey);
    }

    it = item_alloc(key, nkey, 0, 0, vlen+2);

    if (it == 0) {
        if (! item_size_ok(nkey, 0, vlen + 2)) {
            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_E2BIG, NULL, vlen);
        } else {
            out_of_memory(c, ""SERVER_ERROR Out of memory allocating item"");
            /* OOM calls eat the swallow value. Add here. */
            c->sbytes = vlen;
        }
        /* swallow the data line */
        conn_set_state(c, conn_swallow);
        return;
    }

    ITEM_set_cas(it, c->binary_header.request.cas);

    switch (c->cmd) {
        case PROTOCOL_BINARY_CMD_APPEND:
         ...",49,,1187,2,,void
49931,BLOCK,-1,,"{
        fprintf(stderr, ""Value len is %d\n"", vlen);
    }",31,,1199,2,,void
49940,BLOCK,-1,,"{
        stats_prefix_record_set(key, nkey);
    }",34,,1203,2,,void
49958,BLOCK,-1,,"{
        if (! item_size_ok(nkey, 0, vlen + 2)) {
            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_E2BIG, NULL, vlen);
        } else {
            out_of_memory(c, ""SERVER_ERROR Out of memory allocating item"");
            /* OOM calls eat the swallow value. Add here. */
            c->sbytes = vlen;
        }
        /* swallow the data line */
        conn_set_state(c, conn_swallow);
        return;
    }",18,,1209,2,,void
49967,BLOCK,-1,,"{
            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_E2BIG, NULL, vlen);
        }",48,,1210,2,,void
49974,BLOCK,-1,,"{
            out_of_memory(c, ""SERVER_ERROR Out of memory allocating item"");
            /* OOM calls eat the swallow value. Add here. */
            c->sbytes = vlen;
        }",16,,1212,1,,void
49996,BLOCK,1,,"ITEM_set_cas(it, c->binary_header.request.cas)",5,,1222,13,,void
50003,BLOCK,-1,,"ITEM_set_cas(it, c->binary_header.request.cas)",5,,1222,2,,void
50021,BLOCK,-1,,"{
        case PROTOCOL_BINARY_CMD_APPEND:
            c->cmd = NREAD_APPEND;
            break;
        case PROTOCOL_BINARY_CMD_PREPEND:
            c->cmd = NREAD_PREPEND;
            break;
        default:
            assert(0);
    }",21,,1224,2,,void
50029,BLOCK,1,,<empty>,,,,1,,void
50039,BLOCK,1,,<empty>,,,,1,,void
50056,BLOCK,1,,<empty>,,,,6,,void
50107,BLOCK,-1,,"{
    time_t exptime = 0;
    protocol_binary_request_flush* req = (void *)extbuf;
    rel_time_t new_oldest = 0;

    if (!settings.flush_enabled) {
      // flush_all is not allowed but we log it on stats
      write_bin_error(c, PROTOCOL_BINARY_RESPONSE_AUTH_ERROR, NULL, 0);
      return;
    }

    if (c->binary_header.request.extlen == sizeof(req->message.body)) {
        exptime = ntohl(req->message.body.expiration);
    }

    if (exptime > 0) {
        new_oldest = realtime(exptime);
    } else {
        new_oldest = current_time;
    }
    if (settings.use_cas) {
        settings.oldest_live = new_oldest - 1;
        if (settings.oldest_live <= current_time)
            settings.oldest_cas = get_cas_id();
    } else {
        settings.oldest_live = new_oldest;
    }

    pthread_mutex_lock(&c->thread->stats.mutex);
    c->thread->stats.flush_cmds++;
    pthread_mutex_unlock(&c->thread->stats.mutex);

    write_bin_response(c, NULL, 0, 0, 0);
}",54,,1250,3,,void
50127,BLOCK,-1,,"{
      // flush_all is not allowed but we log it on stats
      write_bin_error(c, PROTOCOL_BINARY_RESPONSE_AUTH_ERROR, NULL, 0);
      return;
    }",34,,1255,2,,void
50149,BLOCK,-1,,"{
        exptime = ntohl(req->message.body.expiration);
    }",71,,1261,2,,void
50164,BLOCK,-1,,"{
        new_oldest = realtime(exptime);
    }",22,,1265,2,,void
50170,BLOCK,-1,,"{
        new_oldest = current_time;
    }",12,,1267,1,,void
50178,BLOCK,-1,,"{
        settings.oldest_live = new_oldest - 1;
        if (settings.oldest_live <= current_time)
            settings.oldest_cas = get_cas_id();
    }",27,,1270,2,,void
50192,BLOCK,-1,,<empty>,13,,1273,2,,void
50199,BLOCK,-1,,"{
        settings.oldest_live = new_oldest;
    }",12,,1274,1,,void
50241,BLOCK,-1,,"{
    item *it;
    uint32_t hv;

    assert(c != NULL);
    char* key = binary_get_key(c);
    size_t nkey = c->binary_header.request.keylen;

    if (settings.verbose > 1) {
        int ii;
        fprintf(stderr, ""Deleting "");
        for (ii = 0; ii < nkey; ++ii) {
            fprintf(stderr, ""%c"", key[ii]);
        }
        fprintf(stderr, ""\n"");
    }

    if (settings.detail_enabled) {
        stats_prefix_record_delete(key, nkey);
    }

    it = item_get_locked(key, nkey, c, DONT_UPDATE, &hv);
    if (it) {
        uint64_t cas = c->binary_header.request.cas;
        if (cas == 0 || cas == ITEM_get_cas(it)) {
            MEMCACHED_COMMAND_DELETE(c->sfd, ITEM_key(it), it->nkey);
            pthread_mutex_lock(&c->thread->stats.mutex);
            c->thread->stats.slab_stats[ITEM_clsid(it)].delete_hits++;
            pthread_mutex_unlock(&c->thread->stats.mutex);
            do_item_unlink(it, hv);
            STORAGE_delete(c->thread->storage, it);
            write_bin_res...",41,,1285,2,,void
50269,BLOCK,-1,,"{
        int ii;
        fprintf(stderr, ""Deleting "");
        for (ii = 0; ii < nkey; ++ii) {
            fprintf(stderr, ""%c"", key[ii]);
        }
        fprintf(stderr, ""\n"");
    }",31,,1293,2,,void
50275,BLOCK,-1,,<empty>,9,,1296,1,,void
50284,BLOCK,4,,"{
            fprintf(stderr, ""%c"", key[ii]);
        }",39,,1296,4,,void
50298,BLOCK,-1,,"{
        stats_prefix_record_delete(key, nkey);
    }",34,,1302,2,,void
50309,BLOCK,1,,<empty>,,,,1,,void
50315,BLOCK,-1,,"{
        uint64_t cas = c->binary_header.request.cas;
        if (cas == 0 || cas == ITEM_get_cas(it)) {
            MEMCACHED_COMMAND_DELETE(c->sfd, ITEM_key(it), it->nkey);
            pthread_mutex_lock(&c->thread->stats.mutex);
            c->thread->stats.slab_stats[ITEM_clsid(it)].delete_hits++;
            pthread_mutex_unlock(&c->thread->stats.mutex);
            do_item_unlink(it, hv);
            STORAGE_delete(c->thread->storage, it);
            write_bin_response(c, NULL, 0, 0, 0);
        } else {
            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS, NULL, 0);
        }
        do_item_remove(it);      /* release our reference */
    }",13,,1307,2,,void
50335,BLOCK,1,,<empty>,,,,4,,void
50350,BLOCK,-1,,"{
            MEMCACHED_COMMAND_DELETE(c->sfd, ITEM_key(it), it->nkey);
            pthread_mutex_lock(&c->thread->stats.mutex);
            c->thread->stats.slab_stats[ITEM_clsid(it)].delete_hits++;
            pthread_mutex_unlock(&c->thread->stats.mutex);
            do_item_unlink(it, hv);
            STORAGE_delete(c->thread->storage, it);
            write_bin_response(c, NULL, 0, 0, 0);
        }",50,,1309,2,,void
50372,BLOCK,1,,<empty>,,,,3,,void
50401,BLOCK,-1,,"{
            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS, NULL, 0);
        }",16,,1317,1,,void
50410,BLOCK,-1,,"{
        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, NULL, 0);
        pthread_mutex_lock(&c->thread->stats.mutex);
        c->thread->stats.delete_misses++;
        pthread_mutex_unlock(&c->thread->stats.mutex);
    }",12,,1321,1,,void
50450,BLOCK,-1,,<empty>,1,,1,1,,ANY
50453,BLOCK,-1,,<empty>,,,,2,,<empty>
50458,BLOCK,-1,,<empty>,,,,2,,<empty>
50466,BLOCK,-1,,<empty>,,,,5,,<empty>
50475,BLOCK,-1,,<empty>,1,,1,1,,ANY
50481,BLOCK,-1,,<empty>,,,,5,,<empty>
50489,BLOCK,-1,,<empty>,,,,5,,<empty>
50495,BLOCK,-1,,<empty>,,,,3,,<empty>
50501,BLOCK,-1,,"{
    if (!settings.proxy_enabled) {
       return;
    }
    proxy_ctx_t *ctx = settings.proxy_ctx;
    STAT_L(ctx);

    APPEND_STAT(""proxy_config_reloads"", ""%llu"", (unsigned long long)ctx->global_stats.config_reloads);
    APPEND_STAT(""proxy_config_reload_fails"", ""%llu"", (unsigned long long)ctx->global_stats.config_reload_fails);
    APPEND_STAT(""proxy_backend_total"", ""%llu"", (unsigned long long)ctx->global_stats.backend_total);
    APPEND_STAT(""proxy_backend_marked_bad"", ""%llu"", (unsigned long long)ctx->global_stats.backend_marked_bad);
    APPEND_STAT(""proxy_backend_failed"", ""%llu"", (unsigned long long)ctx->global_stats.backend_failed);
    STAT_UL(ctx);
}",47,,24,3,,void
50507,BLOCK,-1,,"{
       return;
    }",34,,25,2,,void
50517,BLOCK,1,,<empty>,,,,3,,void
50526,BLOCK,1,,<empty>,,,,4,,void
50542,BLOCK,1,,<empty>,,,,4,,void
50558,BLOCK,1,,<empty>,,,,4,,void
50574,BLOCK,1,,<empty>,,,,4,,void
50590,BLOCK,1,,<empty>,,,,4,,void
50605,BLOCK,1,,<empty>,,,,3,,void
50616,BLOCK,-1,,"{
    char key_str[STAT_KEY_LEN];
    struct proxy_int_stats istats = {0};

    if (!settings.proxy_enabled) {
        return;
    }
    proxy_ctx_t *ctx = settings.proxy_ctx;
    STAT_L(ctx);

    // prepare aggregated counters.
    struct proxy_user_stats *us = &ctx->user_stats;
    uint64_t counters[us->num_stats];
    memset(counters, 0, sizeof(counters));

    // aggregate worker thread counters.
    for (int x = 0; x < settings.num_threads; x++) {
        LIBEVENT_THREAD *t = get_worker_thread(x);
        struct proxy_user_stats *tus = t->proxy_user_stats;
        struct proxy_int_stats *is = t->proxy_int_stats;
        WSTAT_L(t);
        for (int i = 0; i < CMD_FINAL; i++) {
            istats.counters[i] += is->counters[i];
        }
        if (tus && tus->num_stats >= us->num_stats) {
            for (int i = 0; i < us->num_stats; i++) {
                counters[i] += tus->counters[i];
            }
        }
        WSTAT_UL(t);
    }

    // return all of the user gener...",55,,39,3,,void
50628,BLOCK,-1,,"{
        return;
    }",34,,43,2,,void
50638,BLOCK,1,,<empty>,,,,3,,void
50658,BLOCK,-1,,<empty>,5,,55,1,,void
50670,BLOCK,4,,"{
        LIBEVENT_THREAD *t = get_worker_thread(x);
        struct proxy_user_stats *tus = t->proxy_user_stats;
        struct proxy_int_stats *is = t->proxy_int_stats;
        WSTAT_L(t);
        for (int i = 0; i < CMD_FINAL; i++) {
            istats.counters[i] += is->counters[i];
        }
        if (tus && tus->num_stats >= us->num_stats) {
            for (int i = 0; i < us->num_stats; i++) {
                counters[i] += tus->counters[i];
            }
        }
        WSTAT_UL(t);
    }",52,,55,4,,void
50690,BLOCK,1,,<empty>,,,,3,,void
50699,BLOCK,-1,,<empty>,9,,60,1,,void
50709,BLOCK,4,,"{
            istats.counters[i] += is->counters[i];
        }",45,,60,4,,void
50731,BLOCK,-1,,"{
            for (int i = 0; i < us->num_stats; i++) {
                counters[i] += tus->counters[i];
            }
        }",53,,63,2,,void
50733,BLOCK,-1,,<empty>,13,,64,1,,void
50745,BLOCK,4,,"{
                counters[i] += tus->counters[i];
            }",53,,64,4,,void
50757,BLOCK,1,,<empty>,,,,3,,void
50766,BLOCK,-1,,<empty>,5,,72,1,,void
50778,BLOCK,4,,"{
        snprintf(key_str, STAT_KEY_LEN-1, ""user_%s"", us->names[x]);
        APPEND_STAT(key_str, ""%llu"", (unsigned long long)counters[x]);
    }",45,,72,4,,void
50783,BLOCK,1,,<empty>,,,,1,,void
50795,BLOCK,1,,<empty>,,,,5,,void
50808,BLOCK,1,,<empty>,,,,3,,void
50817,BLOCK,1,,<empty>,,,,4,,void
50833,BLOCK,1,,<empty>,,,,4,,void
50849,BLOCK,1,,<empty>,,,,4,,void
50865,BLOCK,1,,<empty>,,,,4,,void
50881,BLOCK,1,,<empty>,,,,4,,void
50897,BLOCK,1,,<empty>,,,,4,,void
50913,BLOCK,1,,<empty>,,,,4,,void
50929,BLOCK,1,,<empty>,,,,4,,void
50945,BLOCK,1,,<empty>,,,,4,,void
50961,BLOCK,1,,<empty>,,,,4,,void
50977,BLOCK,1,,<empty>,,,,4,,void
50993,BLOCK,1,,<empty>,,,,4,,void
51009,BLOCK,1,,<empty>,,,,4,,void
51025,BLOCK,1,,<empty>,,,,4,,void
51041,BLOCK,1,,<empty>,,,,4,,void
51057,BLOCK,1,,<empty>,,,,4,,void
51073,BLOCK,1,,<empty>,,,,4,,void
51089,BLOCK,1,,<empty>,,,,4,,void
51105,BLOCK,1,,<empty>,,,,4,,void
51121,BLOCK,1,,<empty>,,,,4,,void
51138,BLOCK,-1,,"{
    proxy_ctx_t *ctx = calloc(1, sizeof(proxy_ctx_t));
    settings.proxy_ctx = ctx;
    ctx->use_uring = use_uring;

    pthread_mutex_init(&ctx->config_lock, NULL);
    pthread_cond_init(&ctx->config_cond, NULL);
    pthread_mutex_init(&ctx->worker_lock, NULL);
    pthread_cond_init(&ctx->worker_cond, NULL);
    pthread_mutex_init(&ctx->manager_lock, NULL);
    pthread_cond_init(&ctx->manager_cond, NULL);
    pthread_mutex_init(&ctx->stats_lock, NULL);

    // FIXME (v2): default defines.
    ctx->tunables.tcp_keepalive = false;
    ctx->tunables.backend_failure_limit = 3;
    ctx->tunables.connect.tv_sec = 5;
    ctx->tunables.retry.tv_sec = 3;
    ctx->tunables.read.tv_sec = 3;
#ifdef HAVE_LIBURING
    ctx->tunables.connect_ur.tv_sec = 5;
    ctx->tunables.retry_ur.tv_sec = 3;
    ctx->tunables.read_ur.tv_sec = 3;
#endif // HAVE_LIBURING

    STAILQ_INIT(&ctx->manager_head);
    lua_State *L = luaL_newstate();
    ctx->proxy_state = L;
    luaL_openlibs(L);
    // NOTE: might ...",33,,103,2,,void
51244,BLOCK,1,,<empty>,,,,5,,void
51246,BLOCK,-1,,STAILQ_INIT(&ctx->manager_head),5,,128,1,,void
51297,BLOCK,-1,,<empty>,5,,142,1,,void
51307,BLOCK,4,,"{
        proxy_event_thread_t *t = &threads[i];
        t->ctx = ctx;
#ifdef USE_EVENTFD
        t->event_fd = eventfd(0, EFD_NONBLOCK);
        if (t->event_fd == -1) {
            perror(""failed to create backend notify eventfd"");
            exit(1);
        }
#else
        int fds[2];
        if (pipe(fds)) {
            perror(""can't create proxy backend notify pipe"");
            exit(1);
        }

        t->notify_receive_fd = fds[0];
        t->notify_send_fd = fds[1];
#endif
        proxy_init_evthread_events(t);

        // incoming request queue.
        STAILQ_INIT(&t->io_head_in);
        pthread_mutex_init(&t->mutex, NULL);
        pthread_cond_init(&t->cond, NULL);

        memcpy(&t->tunables, &ctx->tunables, sizeof(t->tunables));

#ifdef HAVE_LIBURING
        if (t->use_uring) {
            pthread_create(&t->thread_id, NULL, proxy_event_thread_ur, t);
        } else {
            pthread_create(&t->thread_id, NULL, proxy_event_thread, t);
        }
#else
       ...",33,,142,4,,void
51324,BLOCK,-1,,"{
            perror(""can't create proxy backend notify pipe"");
            exit(1);
        }",24,,153,2,,void
51350,BLOCK,1,,<empty>,,,,5,,void
51352,BLOCK,-1,,STAILQ_INIT(&t->io_head_in),9,,164,1,,void
51415,BLOCK,-1,,"{
    // Create the hook table.
    thr->proxy_hooks = calloc(CMD_SIZE, sizeof(struct proxy_hook));
    if (thr->proxy_hooks == NULL) {
        fprintf(stderr, ""Failed to allocate proxy hooks\n"");
        exit(EXIT_FAILURE);
    }
    thr->proxy_int_stats = calloc(1, sizeof(struct proxy_int_stats));
    if (thr->proxy_int_stats == NULL) {
        fprintf(stderr, ""Failed to allocate proxy thread stats\n"");
        exit(EXIT_FAILURE);
    }

    // Initialize the lua state.
    lua_State *L = luaL_newstate();
    thr->L = L;
    luaL_openlibs(L);
    proxy_register_libs(thr, L);
    // TODO: srand on time? do we need to bother?
    for (int x = 0; x < 3; x++) {
        thr->proxy_rng[x] = rand();
    }

    // kick off the configuration.
    if (proxy_thread_loadconf(thr) != 0) {
        exit(EXIT_FAILURE);
    }
}",46,,185,2,,void
51430,BLOCK,-1,,"{
        fprintf(stderr, ""Failed to allocate proxy hooks\n"");
        exit(EXIT_FAILURE);
    }",35,,188,2,,void
51450,BLOCK,-1,,"{
        fprintf(stderr, ""Failed to allocate proxy thread stats\n"");
        exit(EXIT_FAILURE);
    }",39,,193,2,,void
51471,BLOCK,-1,,<empty>,5,,204,1,,void
51481,BLOCK,4,,"{
        thr->proxy_rng[x] = rand();
    }",33,,204,4,,void
51494,BLOCK,-1,,"{
        exit(EXIT_FAILURE);
    }",42,,209,2,,void
51501,BLOCK,-1,,"{
    proxy_event_thread_t *e = ((proxy_ctx_t *)q->ctx)->proxy_threads;
    io_pending_proxy_t *p = q->stack_ctx;
    io_head_t head;
    STAILQ_INIT(&head);

    // NOTE: responses get returned in the correct order no matter what, since
    // mc_resp's are linked.
    // we just need to ensure stuff is parsed off the backend in the correct
    // order.
    // So we can do with a single list here, but we need to repair the list as
    // responses are parsed. (in the req_remaining-- section)
    // TODO (v2):
    // - except we can't do that because the deferred IO stack isn't
    // compatible with queue.h.
    // So for now we build the secondary list with an STAILQ, which
    // can be transplanted/etc.
    while (p) {
        // insert into tail so head is oldest request.
        STAILQ_INSERT_TAIL(&head, p, io_next);
        if (p->is_await) {
            // need to not count await objects multiple times.
            if (p->await_first) {
                q->count++;
         ...",37,,215,2,,void
51522,BLOCK,1,,<empty>,,,,5,,void
51524,BLOCK,-1,,STAILQ_INIT(&head),5,,219,1,,void
51544,BLOCK,-1,,"{
        // insert into tail so head is oldest request.
        STAILQ_INSERT_TAIL(&head, p, io_next);
        if (p->is_await) {
            // need to not count await objects multiple times.
            if (p->await_first) {
                q->count++;
            }
            // funny workaround: awaiting IOP's don't count toward
            // resuming a connection, only the completion of the await
            // condition.
        } else {
            q->count++;
        }

        p = p->next;
    }",15,,232,2,,void
51549,BLOCK,1,,<empty>,,,,8,,void
51551,BLOCK,-1,,"STAILQ_INSERT_TAIL(&head, p, io_next)",9,,234,1,,void
51582,BLOCK,-1,,"{
            // need to not count await objects multiple times.
            if (p->await_first) {
                q->count++;
            }
            // funny workaround: awaiting IOP's don't count toward
            // resuming a connection, only the completion of the await
            // condition.
        }",26,,235,2,,void
51587,BLOCK,-1,,"{
                q->count++;
            }",33,,237,2,,void
51593,BLOCK,-1,,"{
            q->count++;
        }",16,,243,1,,void
51620,BLOCK,1,,<empty>,,,,11,,void
51622,BLOCK,-1,,"STAILQ_CONCAT(&e->io_head_in, &head)",5,,255,1,,void
51631,BLOCK,-1,,"STAILQ_CONCAT(&e->io_head_in, &head)",5,,255,2,,void
51656,BLOCK,-1,,"STAILQ_CONCAT(&e->io_head_in, &head)",5,,255,1,,void
51689,BLOCK,-1,,"{
        assert(1 == 0);
    }",48,,268,2,,void
51699,BLOCK,-1,,"{
    // empty/unused.
}",39,,276,2,,void
51704,BLOCK,-1,,"{
    io_pending_proxy_t *p = (io_pending_proxy_t *)pending;
    if (p->is_await) {
        mcplib_await_return(p);
    } else {
        lua_State *Lc = p->coro;

        // in order to resume we need to remove the objects that were
        // originally returned
        // what's currently on the top of the stack is what we want to keep.
        lua_rotate(Lc, 1, 1);
        // We kept the original results from the yield so lua would not
        // collect them in the meantime. We can drop those now.
        lua_settop(Lc, 1);

        // p can be freed/changed from the call below, so fetch the queue now.
        io_queue_t *q = conn_io_queue_get(p->c, p->io_queue_type);
        conn *c = p->c;
        proxy_run_coroutine(Lc, p->resp, p, c);

        q->count--;
        if (q->count == 0) {
            // call re-add directly since we're already in the worker thread.
            conn_worker_readd(c);
        }
    }
}",45,,282,2,,void
51715,BLOCK,-1,,"{
        mcplib_await_return(p);
    }",22,,284,2,,void
51719,BLOCK,-1,,"{
        lua_State *Lc = p->coro;

        // in order to resume we need to remove the objects that were
        // originally returned
        // what's currently on the top of the stack is what we want to keep.
        lua_rotate(Lc, 1, 1);
        // We kept the original results from the yield so lua would not
        // collect them in the meantime. We can drop those now.
        lua_settop(Lc, 1);

        // p can be freed/changed from the call below, so fetch the queue now.
        io_queue_t *q = conn_io_queue_get(p->c, p->io_queue_type);
        conn *c = p->c;
        proxy_run_coroutine(Lc, p->resp, p, c);

        q->count--;
        if (q->count == 0) {
            // call re-add directly since we're already in the worker thread.
            conn_worker_readd(c);
        }
    }",12,,286,1,,void
51766,BLOCK,-1,,"{
            // call re-add directly since we're already in the worker thread.
            conn_worker_readd(c);
        }",28,,303,2,,void
51773,BLOCK,-1,,"{
    io_pending_proxy_t *p = (io_pending_proxy_t *)pending;

    // release our coroutine reference.
    // TODO (v2): coroutines are reusable in lua 5.4. we can stack this onto a freelist
    // after a lua_resetthread(Lc) call.
    if (p->coro_ref) {
        // Note: lua registry is the same for main thread or a coroutine.
        luaL_unref(p->coro, LUA_REGISTRYINDEX, p->coro_ref);
    }
    return;
}",47,,313,2,,void
51784,BLOCK,-1,,"{
        // Note: lua registry is the same for main thread or a coroutine.
        luaL_unref(p->coro, LUA_REGISTRYINDEX, p->coro_ref);
    }",22,,319,2,,void
51798,BLOCK,-1,,"{
    char *el, *cont;

    if (c->rbytes == 0)
        return 0;

    el = memchr(c->rcurr, '\n', c->rbytes);
    if (!el) {
        if (c->rbytes > 1024) {
            /*
             * We didn't have a '\n' in the first k. This _has_ to be a
             * large multiget, if not we should just nuke the connection.
             */
            char *ptr = c->rcurr;
            while (*ptr == ' ') { /* ignore leading whitespaces */
                ++ptr;
            }

            if (ptr - c->rcurr > 100 ||
                (strncmp(ptr, ""get "", 4) && strncmp(ptr, ""gets "", 5))) {

                conn_set_state(c, conn_closing);
                return 1;
            }

            // ASCII multigets are unbound, so our fixed size rbuf may not
            // work for this particular workload... For backcompat we'll use a
            // malloc/realloc/free routine just for this.
            if (!c->rbuf_malloced) {
                if (!rbuf_switch_to_malloc(c)) {
                    c...",37,,326,2,,void
51807,BLOCK,-1,,<empty>,9,,330,2,,void
51823,BLOCK,-1,,"{
        if (c->rbytes > 1024) {
            /*
             * We didn't have a '\n' in the first k. This _has_ to be a
             * large multiget, if not we should just nuke the connection.
             */
            char *ptr = c->rcurr;
            while (*ptr == ' ') { /* ignore leading whitespaces */
                ++ptr;
            }

            if (ptr - c->rcurr > 100 ||
                (strncmp(ptr, ""get "", 4) && strncmp(ptr, ""gets "", 5))) {

                conn_set_state(c, conn_closing);
                return 1;
            }

            // ASCII multigets are unbound, so our fixed size rbuf may not
            // work for this particular workload... For backcompat we'll use a
            // malloc/realloc/free routine just for this.
            if (!c->rbuf_malloced) {
                if (!rbuf_switch_to_malloc(c)) {
                    conn_set_state(c, conn_closing);
                    return 1;
                }
            }
        }

        return 0;
 ...",14,,333,2,,void
51830,BLOCK,-1,,"{
            /*
             * We didn't have a '\n' in the first k. This _has_ to be a
             * large multiget, if not we should just nuke the connection.
             */
            char *ptr = c->rcurr;
            while (*ptr == ' ') { /* ignore leading whitespaces */
                ++ptr;
            }

            if (ptr - c->rcurr > 100 ||
                (strncmp(ptr, ""get "", 4) && strncmp(ptr, ""gets "", 5))) {

                conn_set_state(c, conn_closing);
                return 1;
            }

            // ASCII multigets are unbound, so our fixed size rbuf may not
            // work for this particular workload... For backcompat we'll use a
            // malloc/realloc/free routine just for this.
            if (!c->rbuf_malloced) {
                if (!rbuf_switch_to_malloc(c)) {
                    conn_set_state(c, conn_closing);
                    return 1;
                }
            }
        }",31,,334,2,,void
51842,BLOCK,-1,,"{ /* ignore leading whitespaces */
                ++ptr;
            }",33,,340,2,,void
51863,BLOCK,-1,,"{

                conn_set_state(c, conn_closing);
                return 1;
            }",72,,345,2,,void
51874,BLOCK,-1,,"{
                if (!rbuf_switch_to_malloc(c)) {
                    conn_set_state(c, conn_closing);
                    return 1;
                }
            }",36,,354,2,,void
51879,BLOCK,-1,,"{
                    conn_set_state(c, conn_closing);
                    return 1;
                }",48,,355,2,,void
51918,BLOCK,1,,<empty>,,,,1,,void
51952,BLOCK,-1,,"{
    assert(c->proxy_coro_ref != 0);
    LIBEVENT_THREAD *thr = c->thread;
    lua_State *L = thr->L;
    luaL_unref(L, LUA_REGISTRYINDEX, c->proxy_coro_ref);
    c->proxy_coro_ref = 0;
    WSTAT_DECR(c, proxy_req_active, 1);
}",34,,382,2,,void
51985,BLOCK,1,,"WSTAT_DECR(c, proxy_req_active, 1)",5,,388,8,,void
52017,BLOCK,-1,,"{
    assert(c != NULL);

    LIBEVENT_THREAD *thr = c->thread;
    lua_State *L = thr->L;

    if (c->proxy_coro_ref == 0) {
        complete_nread_ascii(c);
        return;
    }

    conn_set_state(c, conn_new_cmd);

    // Grab our coroutine.
    lua_rawgeti(L, LUA_REGISTRYINDEX, c->proxy_coro_ref);
    luaL_unref(L, LUA_REGISTRYINDEX, c->proxy_coro_ref);
    lua_State *Lc = lua_tothread(L, -1);
    mcp_request_t *rq = luaL_checkudata(Lc, -1, ""mcp.request"");

    // validate the data chunk.
    if (strncmp((char *)c->item + rq->pr.vlen - 2, ""\r\n"", 2) != 0) {
        lua_settop(L, 0); // clear anything remaining on the main thread.
        // FIXME (v2): need to set noreply false if mset_res, but that's kind
        // of a weird hack to begin with. Evaluate how to best do that here.
        out_string(c, ""CLIENT_ERROR bad data chunk"");
        return;
    }

    // We move ownership of the c->item buffer from the connection to the
    // request object here. Else we can double ...",36,,392,2,,void
52040,BLOCK,-1,,"{
        complete_nread_ascii(c);
        return;
    }",33,,398,2,,void
52093,BLOCK,-1,,"{
        lua_settop(L, 0); // clear anything remaining on the main thread.
        // FIXME (v2): need to set noreply false if mset_res, but that's kind
        // of a weird hack to begin with. Evaluate how to best do that here.
        out_string(c, ""CLIENT_ERROR bad data chunk"");
        return;
    }",69,,412,2,,void
52141,BLOCK,-1,,"{
    lua_pushstring(L, s);
    lua_error(L);
}",51,,438,3,,void
52152,BLOCK,-1,,"{
    va_list ap;
    va_start(ap, fmt);
    lua_pushfstring(L, fmt, ap);
    va_end(ap);
    lua_error(L);
}",59,,443,3,,void
52170,BLOCK,-1,,"{
    size_t len;
    const static char error_prefix[] = ""SERVER_ERROR "";
    const static int error_prefix_len = sizeof(error_prefix) - 1;

    assert(resp != NULL);

    resp_reset(resp);
    // avoid noreply since we're throwing important errors.

    // Fill response object with static string.
    len = strlen(str);
    if ((len + error_prefix_len + 2) > WRITE_BUFFER_SIZE) {
        /* ought to be always enough. just fail for simplicity */
        str = ""SERVER_ERROR output line too long"";
        len = strlen(str);
    }

    char *w = resp->wbuf;
    memcpy(w, error_prefix, error_prefix_len);
    w += error_prefix_len;

    memcpy(w, str, len);
    w += len;

    memcpy(w, ""\r\n"", 2);
    resp_add_iov(resp, resp->wbuf, len + error_prefix_len + 2);
    return;
}",65,,452,3,,void
52201,BLOCK,1,,<empty>,,,,1,,void
52203,BLOCK,-1,,"{
        /* ought to be always enough. just fail for simplicity */
        str = ""SERVER_ERROR output line too long"";
        len = strlen(str);
    }",59,,464,2,,void
52251,BLOCK,-1,,"{
    switch (r->mode) {
        case RESP_MODE_NORMAL:
            break;
        case RESP_MODE_NOREPLY:
            // ascii noreply only threw egregious errors to client
            if (r->status == MCMC_OK) {
                resp->skip = true;
            }
            break;
        case RESP_MODE_METAQUIET:
            if (r->resp.code == MCMC_CODE_MISS) {
                resp->skip = true;
            } else if (r->cmd != CMD_MG && r->resp.code == MCMC_CODE_OK) {
                // FIXME (v2): mcmc's parser needs to help us out a bit more
                // here.
                // This is a broken case in the protocol though; quiet mode
                // ignores HD for mutations but not get.
                resp->skip = true;
            }
            break;
        default:
            assert(1 == 0);
    }
}",61,,486,3,,void
52256,BLOCK,-1,,"{
        case RESP_MODE_NORMAL:
            break;
        case RESP_MODE_NOREPLY:
            // ascii noreply only threw egregious errors to client
            if (r->status == MCMC_OK) {
                resp->skip = true;
            }
            break;
        case RESP_MODE_METAQUIET:
            if (r->resp.code == MCMC_CODE_MISS) {
                resp->skip = true;
            } else if (r->cmd != CMD_MG && r->resp.code == MCMC_CODE_OK) {
                // FIXME (v2): mcmc's parser needs to help us out a bit more
                // here.
                // This is a broken case in the protocol though; quiet mode
                // ignores HD for mutations but not get.
                resp->skip = true;
            }
            break;
        default:
            assert(1 == 0);
    }",22,,487,2,,void
52268,BLOCK,1,,<empty>,,,,1,,void
52270,BLOCK,-1,,"{
                resp->skip = true;
            }",39,,492,2,,void
52287,BLOCK,1,,<empty>,,,,1,,void
52289,BLOCK,-1,,"{
                resp->skip = true;
            }",49,,497,2,,void
52296,BLOCK,-1,,<empty>,20,,499,1,,void
52311,BLOCK,1,,<empty>,,,,1,,void
52313,BLOCK,-1,,"{
                // FIXME (v2): mcmc's parser needs to help us out a bit more
                // here.
                // This is a broken case in the protocol though; quiet mode
                // ignores HD for mutations but not get.
                resp->skip = true;
            }",74,,499,2,,void
52332,BLOCK,-1,,"{
    int nresults = 0;
    int cores = lua_resume(Lc, NULL, 1, &nresults);
    size_t rlen = 0;

    if (cores == LUA_OK) {
        WSTAT_DECR(c, proxy_req_active, 1);
        int type = lua_type(Lc, 1);
        if (type == LUA_TUSERDATA) {
            mcp_resp_t *r = luaL_checkudata(Lc, 1, ""mcp.response"");
            _set_noreply_mode(resp, r);
            if (r->buf) {
                // response set from C.
                // FIXME (v2): write_and_free() ? it's a bit wrong for here.
                resp->write_and_free = r->buf;
                resp_add_iov(resp, r->buf, r->blen);
                r->buf = NULL;
            } else if (lua_getiuservalue(Lc, 1, 1) != LUA_TNIL) {
                // uservalue slot 1 is pre-created, so we get TNIL instead of
                // TNONE when nothing was set into it.
                const char *s = lua_tolstring(Lc, -1, &rlen);
                size_t l = rlen > WRITE_BUFFER_SIZE ? WRITE_BUFFER_SIZE : rlen;
                memcpy(resp->wbu...",87,,523,5,,void
52354,BLOCK,-1,,"{
        WSTAT_DECR(c, proxy_req_active, 1);
        int type = lua_type(Lc, 1);
        if (type == LUA_TUSERDATA) {
            mcp_resp_t *r = luaL_checkudata(Lc, 1, ""mcp.response"");
            _set_noreply_mode(resp, r);
            if (r->buf) {
                // response set from C.
                // FIXME (v2): write_and_free() ? it's a bit wrong for here.
                resp->write_and_free = r->buf;
                resp_add_iov(resp, r->buf, r->blen);
                r->buf = NULL;
            } else if (lua_getiuservalue(Lc, 1, 1) != LUA_TNIL) {
                // uservalue slot 1 is pre-created, so we get TNIL instead of
                // TNONE when nothing was set into it.
                const char *s = lua_tolstring(Lc, -1, &rlen);
                size_t l = rlen > WRITE_BUFFER_SIZE ? WRITE_BUFFER_SIZE : rlen;
                memcpy(resp->wbuf, s, l);
                resp_add_iov(resp, resp->wbuf, l);
                lua_pop(Lc, 1);
            } else if (r->stat...",26,,528,2,,void
52358,BLOCK,1,,"WSTAT_DECR(c, proxy_req_active, 1)",9,,529,1,,void
52396,BLOCK,-1,,"{
            mcp_resp_t *r = luaL_checkudata(Lc, 1, ""mcp.response"");
            _set_noreply_mode(resp, r);
            if (r->buf) {
                // response set from C.
                // FIXME (v2): write_and_free() ? it's a bit wrong for here.
                resp->write_and_free = r->buf;
                resp_add_iov(resp, r->buf, r->blen);
                r->buf = NULL;
            } else if (lua_getiuservalue(Lc, 1, 1) != LUA_TNIL) {
                // uservalue slot 1 is pre-created, so we get TNIL instead of
                // TNONE when nothing was set into it.
                const char *s = lua_tolstring(Lc, -1, &rlen);
                size_t l = rlen > WRITE_BUFFER_SIZE ? WRITE_BUFFER_SIZE : rlen;
                memcpy(resp->wbuf, s, l);
                resp_add_iov(resp, resp->wbuf, l);
                lua_pop(Lc, 1);
            } else if (r->status != MCMC_OK) {
                proxy_out_errstring(resp, ""backend failure"");
            } else {
                /...",36,,531,2,,void
52411,BLOCK,-1,,"{
                // response set from C.
                // FIXME (v2): write_and_free() ? it's a bit wrong for here.
                resp->write_and_free = r->buf;
                resp_add_iov(resp, r->buf, r->blen);
                r->buf = NULL;
            }",25,,534,2,,void
52433,BLOCK,-1,,<empty>,20,,540,1,,void
52441,BLOCK,-1,,"{
                // uservalue slot 1 is pre-created, so we get TNIL instead of
                // TNONE when nothing was set into it.
                const char *s = lua_tolstring(Lc, -1, &rlen);
                size_t l = rlen > WRITE_BUFFER_SIZE ? WRITE_BUFFER_SIZE : rlen;
                memcpy(resp->wbuf, s, l);
                resp_add_iov(resp, resp->wbuf, l);
                lua_pop(Lc, 1);
            }",65,,540,2,,void
52458,BLOCK,1,,<empty>,,,,1,,void
52461,BLOCK,1,,<empty>,,,,1,,void
52480,BLOCK,-1,,<empty>,20,,548,1,,void
52487,BLOCK,1,,<empty>,,,,1,,void
52489,BLOCK,-1,,"{
                proxy_out_errstring(resp, ""backend failure"");
            }",46,,548,2,,void
52494,BLOCK,-1,,"{
                // Empty response: used for ascii multiget emulation.
            }",20,,550,1,,void
52496,BLOCK,-1,,<empty>,16,,553,1,,void
52501,BLOCK,-1,,"{
            // response is a raw string from lua.
            const char *s = lua_tolstring(Lc, 1, &rlen);
            size_t l = rlen > WRITE_BUFFER_SIZE ? WRITE_BUFFER_SIZE : rlen;
            memcpy(resp->wbuf, s, l);
            resp_add_iov(resp, resp->wbuf, l);
            lua_pop(Lc, 1);
        }",41,,553,2,,void
52517,BLOCK,1,,<empty>,,,,1,,void
52520,BLOCK,1,,<empty>,,,,1,,void
52539,BLOCK,-1,,"{
            proxy_out_errstring(resp, ""bad response"");
        }",16,,560,1,,void
52544,BLOCK,-1,,<empty>,12,,563,1,,void
52549,BLOCK,-1,,"{
        if (nresults == 1) {
            // TODO (v2): try harder to validate; but we have so few yield cases
            // that I'm going to shortcut this here. A single yielded result
            // means it's probably an await(), so attempt to process this.
            if (p != NULL) {
                int coro_ref = p->coro_ref;
                mc_resp *resp = p->resp;
                assert((void *)p == (void *)resp->io_pending);
                resp->io_pending = NULL;
                c = p->c;
                do_cache_free(c->thread->io_cache, p);
                mcplib_await_run(c, resp, Lc, coro_ref);
            } else {
                // coroutine object sitting on the _main_ VM right now, so we grab
                // the reference from there, which also pops it.
                int coro_ref = luaL_ref(c->thread->L, LUA_REGISTRYINDEX);
                mcplib_await_run(c, c->resp, Lc, coro_ref);
            }
        } else {
            // need to remove and free the ...",36,,563,2,,void
52554,BLOCK,-1,,"{
            // TODO (v2): try harder to validate; but we have so few yield cases
            // that I'm going to shortcut this here. A single yielded result
            // means it's probably an await(), so attempt to process this.
            if (p != NULL) {
                int coro_ref = p->coro_ref;
                mc_resp *resp = p->resp;
                assert((void *)p == (void *)resp->io_pending);
                resp->io_pending = NULL;
                c = p->c;
                do_cache_free(c->thread->io_cache, p);
                mcplib_await_run(c, resp, Lc, coro_ref);
            } else {
                // coroutine object sitting on the _main_ VM right now, so we grab
                // the reference from there, which also pops it.
                int coro_ref = luaL_ref(c->thread->L, LUA_REGISTRYINDEX);
                mcplib_await_run(c, c->resp, Lc, coro_ref);
            }
        }",28,,564,2,,void
52559,BLOCK,-1,,"{
                int coro_ref = p->coro_ref;
                mc_resp *resp = p->resp;
                assert((void *)p == (void *)resp->io_pending);
                resp->io_pending = NULL;
                c = p->c;
                do_cache_free(c->thread->io_cache, p);
                mcplib_await_run(c, resp, Lc, coro_ref);
            }",28,,568,2,,void
52605,BLOCK,-1,,"{
                // coroutine object sitting on the _main_ VM right now, so we grab
                // the reference from there, which also pops it.
                int coro_ref = luaL_ref(c->thread->L, LUA_REGISTRYINDEX);
                mcplib_await_run(c, c->resp, Lc, coro_ref);
            }",20,,576,1,,void
52624,BLOCK,-1,,"{
            // need to remove and free the io_pending, since c->resp owns it.
            // so we call mcp_queue_io() again and let it override the
            // mc_resp's io_pending object.

            int coro_ref = 0;
            mc_resp *resp;
            if (p != NULL) {
                coro_ref = p->coro_ref;
                resp = p->resp;
                c = p->c;
                do_cache_free(p->c->thread->io_cache, p);
                // *p is now dead.
            } else {
                // yielding from a top level call to the coroutine,
                // so we need to grab a reference to the coroutine thread.
                // TODO (v2): make this more explicit?
                // we only need to get the reference here, and error conditions
                // should instead drop it, but now it's not obvious to users that
                // we're reaching back into the main thread's stack.
                assert(c != NULL);
                coro_ref = luaL_ref(c->...",16,,582,1,,void
52634,BLOCK,-1,,"{
                coro_ref = p->coro_ref;
                resp = p->resp;
                c = p->c;
                do_cache_free(p->c->thread->io_cache, p);
                // *p is now dead.
            }",28,,589,2,,void
52660,BLOCK,-1,,"{
                // yielding from a top level call to the coroutine,
                // so we need to grab a reference to the coroutine thread.
                // TODO (v2): make this more explicit?
                // we only need to get the reference here, and error conditions
                // should instead drop it, but now it's not obvious to users that
                // we're reaching back into the main thread's stack.
                assert(c != NULL);
                coro_ref = luaL_ref(c->thread->L, LUA_REGISTRYINDEX);
                resp = c->resp;
            }",20,,595,1,,void
52685,BLOCK,-1,,"{
        WSTAT_DECR(c, proxy_req_active, 1);
        P_DEBUG(""%s: Failed to run coroutine: %s\n"", __func__, lua_tostring(Lc, -1));
        LOGGER_LOG(NULL, LOG_PROXYEVENTS, LOGGER_PROXY_ERROR, NULL, lua_tostring(Lc, -1));
        proxy_out_errstring(resp, ""lua failure"");
    }",12,,609,1,,void
52689,BLOCK,1,,"WSTAT_DECR(c, proxy_req_active, 1)",9,,610,1,,void
52721,BLOCK,1,,<empty>,,,,6,,void
52723,BLOCK,-1,,"LOGGER_LOG(NULL, LOG_PROXYEVENTS, LOGGER_PROXY_ERROR, NULL, lua_tostring(Lc, -1))",9,,612,1,,void
52732,BLOCK,-1,,<empty>,9,,612,2,,void
52747,BLOCK,-1,,<empty>,9,,612,2,,void
52769,BLOCK,-1,,"{
    assert(c != NULL);
    LIBEVENT_THREAD *thr = c->thread;
    struct proxy_hook *hooks = thr->proxy_hooks;
    lua_State *L = thr->L;
    mcp_parser_t pr = {0};

    // Avoid doing resp_start() here, instead do it a bit later or as-needed.
    // This allows us to hop over to the internal text protocol parser, which
    // also calls resp_start().
    // Tighter integration later should obviate the need for this, it is not a
    // permanent solution.
    int ret = process_request(&pr, command, cmdlen);
    if (ret != 0) {
        WSTAT_INCR(c, proxy_conn_errors, 1);
        if (!resp_start(c)) {
            conn_set_state(c, conn_closing);
            return;
        }
        proxy_out_errstring(c->resp, ""parsing request"");
        if (ret == -2) {
            // Kill connection on more critical parse failure.
            conn_set_state(c, conn_closing);
        }
        return;
    }

    struct proxy_hook *hook = &hooks[pr.command];
    int hook_ref = hook->lua_ref;
    //...",89,,619,5,,void
52809,BLOCK,-1,,"{
        WSTAT_INCR(c, proxy_conn_errors, 1);
        if (!resp_start(c)) {
            conn_set_state(c, conn_closing);
            return;
        }
        proxy_out_errstring(c->resp, ""parsing request"");
        if (ret == -2) {
            // Kill connection on more critical parse failure.
            conn_set_state(c, conn_closing);
        }
        return;
    }",19,,632,2,,void
52813,BLOCK,1,,"WSTAT_INCR(c, proxy_conn_errors, 1)",9,,633,1,,void
52845,BLOCK,-1,,"{
            conn_set_state(c, conn_closing);
            return;
        }",29,,634,2,,void
52860,BLOCK,-1,,"{
            // Kill connection on more critical parse failure.
            conn_set_state(c, conn_closing);
        }",24,,639,2,,void
52888,BLOCK,-1,,"{
        struct proxy_hook_tagged *pht = hook->tagged;
        while (pht->lua_ref) {
            if (c->tag == pht->tag) {
                hook_ref = pht->lua_ref;
                break;
            }
            pht++;
        }
    }",33,,651,2,,void
52899,BLOCK,-1,,"{
            if (c->tag == pht->tag) {
                hook_ref = pht->lua_ref;
                break;
            }
            pht++;
        }",30,,653,2,,void
52908,BLOCK,-1,,"{
                hook_ref = pht->lua_ref;
                break;
            }",37,,654,2,,void
52920,BLOCK,-1,,"{
        // need to pass our command string into the internal handler.
        // to minimize the code change, this means allowing it to tokenize the
        // full command. The proxy's indirect parser should be built out to
        // become common code for both proxy and ascii handlers.
        // For now this means we have to null-terminate the command string,
        // then call into text protocol handler.
        // FIXME (v2): use a ptr or something; don't like this code.
        if (cmdlen > 1 && command[cmdlen-2] == '\r') {
            command[cmdlen-2] = '\0';
        } else {
            command[cmdlen-1] = '\0';
        }
        // lets nread_proxy know we're in ascii mode.
        c->proxy_coro_ref = 0;
        process_command_ascii(c, command);
        return;
    }",20,,662,2,,void
52933,BLOCK,-1,,"{
            command[cmdlen-2] = '\0';
        }",54,,670,2,,void
52942,BLOCK,-1,,"{
            command[cmdlen-1] = '\0';
        }",16,,672,1,,void
52972,BLOCK,-1,,"{
        uint32_t keyoff = pr.tokens[pr.keytoken];
        while (pr.klen != 0) {
            char temp[KEY_MAX_LENGTH + 30];
            char *cur = temp;
            // Core daemon can abort the entire command if one key is bad, but
            // we cannot from the proxy. Instead we have to inject errors into
            // the stream. This should, thankfully, be rare at least.
            if (pr.klen > KEY_MAX_LENGTH) {
                if (!resp_start(c)) {
                    conn_set_state(c, conn_closing);
                    return;
                }
                proxy_out_errstring(c->resp, ""key too long"");
            } else {
                // copy original request up until the original key token.
                memcpy(cur, pr.request, pr.tokens[pr.keytoken]);
                cur += pr.tokens[pr.keytoken];

                // now copy in our ""current"" key.
                memcpy(cur, &pr.request[keyoff], pr.klen);
                cur += pr.klen;

                mem...",67,,687,2,,void
52989,BLOCK,-1,,"{
            char temp[KEY_MAX_LENGTH + 30];
            char *cur = temp;
            // Core daemon can abort the entire command if one key is bad, but
            // we cannot from the proxy. Instead we have to inject errors into
            // the stream. This should, thankfully, be rare at least.
            if (pr.klen > KEY_MAX_LENGTH) {
                if (!resp_start(c)) {
                    conn_set_state(c, conn_closing);
                    return;
                }
                proxy_out_errstring(c->resp, ""key too long"");
            } else {
                // copy original request up until the original key token.
                memcpy(cur, pr.request, pr.tokens[pr.keytoken]);
                cur += pr.tokens[pr.keytoken];

                // now copy in our ""current"" key.
                memcpy(cur, &pr.request[keyoff], pr.klen);
                cur += pr.klen;

                memcpy(cur, ""\r\n"", 2);
                cur += 2;

                *cur = '\0';
    ...",30,,689,2,,void
53001,BLOCK,1,,<empty>,,,,1,,void
53003,BLOCK,-1,,"{
                if (!resp_start(c)) {
                    conn_set_state(c, conn_closing);
                    return;
                }
                proxy_out_errstring(c->resp, ""key too long"");
            }",43,,695,2,,void
53008,BLOCK,-1,,"{
                    conn_set_state(c, conn_closing);
                    return;
                }",37,,696,2,,void
53019,BLOCK,-1,,"{
                // copy original request up until the original key token.
                memcpy(cur, pr.request, pr.tokens[pr.keytoken]);
                cur += pr.tokens[pr.keytoken];

                // now copy in our ""current"" key.
                memcpy(cur, &pr.request[keyoff], pr.klen);
                cur += pr.klen;

                memcpy(cur, ""\r\n"", 2);
                cur += 2;

                *cur = '\0';
                P_DEBUG(""%s: new multiget sub request: %s [%u/%u]\n"", __func__, temp, keyoff, pr.klen);
                proxy_process_command(c, temp, cur - temp, PROCESS_MULTIGET);
            }",20,,701,1,,void
53075,BLOCK,1,,<empty>,,,,1,,void
53086,BLOCK,-1,,"{
            conn_set_state(c, conn_closing);
            return;
        }",29,,722,2,,void
53098,BLOCK,1,,<empty>,,,,1,,void
53101,BLOCK,1,,<empty>,,,,1,,void
53116,BLOCK,1,,<empty>,,,,1,,void
53126,BLOCK,1,,<empty>,,,,1,,void
53130,BLOCK,-1,,"{
        WSTAT_INCR(c, proxy_conn_errors, 1);
        if (!resp_start(c)) {
            conn_set_state(c, conn_closing);
            return;
        }
        proxy_out_errstring(c->resp, ""request too long"");
        conn_set_state(c, conn_closing);
        return;
    }",39,,739,2,,void
53134,BLOCK,1,,"WSTAT_INCR(c, proxy_conn_errors, 1)",9,,740,1,,void
53166,BLOCK,-1,,"{
            conn_set_state(c, conn_closing);
            return;
        }",29,,741,2,,void
53184,BLOCK,-1,,"{
        conn_set_state(c, conn_closing);
        return;
    }",25,,750,2,,void
53201,BLOCK,1,,<empty>,,,,2,,void
53239,BLOCK,1,,<empty>,,,,2,,void
53273,BLOCK,-1,,"{
        rq->ascii_multiget = true;
    }",19,,774,2,,void
53287,BLOCK,-1,,"{
        // relying on temporary malloc's not succumbing as poorly to
        // fragmentation.
        c->item = malloc(rq->pr.vlen);
        if (c->item == NULL) {
            lua_settop(L, 0);
            proxy_out_errstring(c->resp, ""out of memory"");
            WSTAT_DECR(c, proxy_req_active, 1);
            return;
        }
        c->item_malloced = true;
        c->ritem = c->item;
        c->rlbytes = rq->pr.vlen;
        c->proxy_coro_ref = luaL_ref(L, LUA_REGISTRYINDEX); // pops coroutine.

        conn_set_state(c, conn_nread);
        return;
    }",27,,781,2,,void
53304,BLOCK,-1,,"{
            lua_settop(L, 0);
            proxy_out_errstring(c->resp, ""out of memory"");
            WSTAT_DECR(c, proxy_req_active, 1);
            return;
        }",30,,785,2,,void
53316,BLOCK,1,,"WSTAT_DECR(c, proxy_req_active, 1)",13,,788,3,,void
53394,BLOCK,-1,,"{
    io_queue_t *q = conn_io_queue_get(c, IO_QUEUE_PROXY);

    // stack: request, hash selector. latter just to hold a reference.

    mcp_request_t *rq = luaL_checkudata(Lc, -1, ""mcp.request"");
    mcp_backend_t *be = rq->be;

    // Then we push a response object, which we'll re-use later.
    // reserve one uservalue for a lua-supplied response.
    mcp_resp_t *r = lua_newuserdatauv(Lc, sizeof(mcp_resp_t), 1);
    // FIXME (v2): is this memset still necessary? I was using it for
    // debugging.
    memset(r, 0, sizeof(mcp_resp_t));
    r->buf = NULL;
    r->blen = 0;
    // Set noreply mode.
    // TODO (v2): the response ""inherits"" the request's noreply mode, which isn't
    // strictly correct; we should inherit based on the request that spawned
    // the coroutine but the structure doesn't allow that yet.
    // Should also be able to settle this exact mode from the parser so we
    // don't have to re-branch here.
    if (rq->pr.noreply) {
        if (rq->pr.cmd_type == ...",79,,809,5,,void
53401,BLOCK,1,,<empty>,,,,1,,void
53446,BLOCK,-1,,"{
        if (rq->pr.cmd_type == CMD_TYPE_META) {
            r->mode = RESP_MODE_METAQUIET;
            for (int x = 2; x < rq->pr.ntokens; x++) {
                if (rq->request[rq->pr.tokens[x]] == 'q') {
                    rq->request[rq->pr.tokens[x]] = ' ';
                }
            }
        } else {
            r->mode = RESP_MODE_NOREPLY;
            rq->request[rq->pr.reqlen - 3] = 'Y';
        }
    }",25,,831,2,,void
53455,BLOCK,-1,,"{
            r->mode = RESP_MODE_METAQUIET;
            for (int x = 2; x < rq->pr.ntokens; x++) {
                if (rq->request[rq->pr.tokens[x]] == 'q') {
                    rq->request[rq->pr.tokens[x]] = ' ';
                }
            }
        }",47,,832,2,,void
53462,BLOCK,-1,,<empty>,13,,834,1,,void
53476,BLOCK,4,,"{
                if (rq->request[rq->pr.tokens[x]] == 'q') {
                    rq->request[rq->pr.tokens[x]] = ' ';
                }
            }",54,,834,4,,void
53491,BLOCK,-1,,"{
                    rq->request[rq->pr.tokens[x]] = ' ';
                }",59,,835,2,,void
53506,BLOCK,-1,,"{
            r->mode = RESP_MODE_NOREPLY;
            rq->request[rq->pr.reqlen - 3] = 'Y';
        }",16,,839,1,,void
53526,BLOCK,-1,,"{
        r->mode = RESP_MODE_NORMAL;
    }",12,,843,1,,void
53561,BLOCK,-1,,"{
        WSTAT_INCR(c, proxy_conn_oom, 1);
        proxy_lua_error(Lc, ""out of memory allocating from IO cache"");
        return;
    }",20,,853,2,,void
53565,BLOCK,1,,"WSTAT_INCR(c, proxy_conn_oom, 1)",9,,854,1,,void
53613,BLOCK,1,,<empty>,,,,1,,void
53680,BLOCK,1,,<empty>,,,,1,,void
53692,BLOCK,1,,<empty>,,,,1,,void
53716,BLOCK,-1,,"{
    int top = lua_gettop(L);
    int i = 1;
    fprintf(stderr, ""--TOP OF STACK [%d]\n"", top);
    for (; i < top + 1; i++) {
        int type = lua_type(L, i);
        // lets find the metatable of this userdata to identify it.
        if (lua_getmetatable(L, i) != 0) {
            lua_pushstring(L, ""__name"");
            if (lua_rawget(L, -2) != LUA_TNIL) {
                fprintf(stderr, ""--|%d| [%s] (%s)\n"", i, lua_typename(L, type), lua_tostring(L, -1));
                lua_pop(L, 2);
                continue;
            }
            lua_pop(L, 2);
        }
        if (type == LUA_TSTRING) {
            fprintf(stderr, ""--|%d| [%s] | %s\n"", i, lua_typename(L, type), lua_tostring(L, i));
        } else {
            fprintf(stderr, ""--|%d| [%s]\n"", i, lua_typename(L, type));
        }
    }
    fprintf(stderr, ""-----------------\n"");
}",55,,897,2,,void
53731,BLOCK,-1,,<empty>,5,,901,1,,void
53739,BLOCK,4,,"{
        int type = lua_type(L, i);
        // lets find the metatable of this userdata to identify it.
        if (lua_getmetatable(L, i) != 0) {
            lua_pushstring(L, ""__name"");
            if (lua_rawget(L, -2) != LUA_TNIL) {
                fprintf(stderr, ""--|%d| [%s] (%s)\n"", i, lua_typename(L, type), lua_tostring(L, -1));
                lua_pop(L, 2);
                continue;
            }
            lua_pop(L, 2);
        }
        if (type == LUA_TSTRING) {
            fprintf(stderr, ""--|%d| [%s] | %s\n"", i, lua_typename(L, type), lua_tostring(L, i));
        } else {
            fprintf(stderr, ""--|%d| [%s]\n"", i, lua_typename(L, type));
        }
    }",30,,901,4,,void
53752,BLOCK,-1,,"{
            lua_pushstring(L, ""__name"");
            if (lua_rawget(L, -2) != LUA_TNIL) {
                fprintf(stderr, ""--|%d| [%s] (%s)\n"", i, lua_typename(L, type), lua_tostring(L, -1));
                lua_pop(L, 2);
                continue;
            }
            lua_pop(L, 2);
        }",42,,904,2,,void
53763,BLOCK,-1,,"{
                fprintf(stderr, ""--|%d| [%s] (%s)\n"", i, lua_typename(L, type), lua_tostring(L, -1));
                lua_pop(L, 2);
                continue;
            }",48,,906,2,,void
53786,BLOCK,-1,,"{
            fprintf(stderr, ""--|%d| [%s] | %s\n"", i, lua_typename(L, type), lua_tostring(L, i));
        }",34,,913,2,,void
53798,BLOCK,-1,,"{
            fprintf(stderr, ""--|%d| [%s]\n"", i, lua_typename(L, type));
        }",16,,915,1,,void
53815,BLOCK,-1,,<empty>,1,,1,1,,ANY
53819,BLOCK,-1,,<empty>,,,,3,,<empty>
53825,BLOCK,-1,,<empty>,,,,3,,<empty>
53830,BLOCK,-1,,<empty>,,,,2,,<empty>
53835,BLOCK,-1,,<empty>,,,,2,,<empty>
53840,BLOCK,-1,,<empty>,,,,2,,<empty>
53845,BLOCK,-1,,<empty>,,,,2,,<empty>
53850,BLOCK,-1,,<empty>,,,,2,,<empty>
53855,BLOCK,-1,,<empty>,,,,2,,<empty>
53860,BLOCK,-1,,<empty>,,,,2,,<empty>
53866,BLOCK,-1,,<empty>,,,,3,,<empty>
53871,BLOCK,-1,,<empty>,,,,2,,<empty>
53876,BLOCK,-1,,<empty>,,,,2,,<empty>
53881,BLOCK,-1,,<empty>,,,,2,,<empty>
53886,BLOCK,-1,,<empty>,,,,2,,<empty>
53892,BLOCK,-1,,<empty>,,,,3,,<empty>
53917,BLOCK,-1,,<empty>,1,,1,1,,ANY
53925,BLOCK,-1,,"{
    mc_resp *resp = c->resp;
    item *it = c->item;
    conn_set_state(c, conn_new_cmd);

    // information about the response line has been stashed in wbuf.
    char *p = resp->wbuf + resp->wbytes;
    char *end = p; // end of the stashed data portion.

    switch (ret) {
    case STORED:
      if (settings.meta_response_old) {
          memcpy(p, ""OK"", 2);
      } else {
          memcpy(p, ""HD"", 2);
      }
      // Only place noreply is used for meta cmds is a nominal response.
      if (c->noreply) {
          resp->skip = true;
      }
      break;
    case EXISTS:
      memcpy(p, ""EX"", 2);
      break;
    case NOT_FOUND:
      memcpy(p, ""NF"", 2);
      break;
    case NOT_STORED:
      memcpy(p, ""NS"", 2);
      break;
    default:
      c->noreply = false;
      out_string(c, ""SERVER_ERROR Unhandled storage type."");
      return;
    }
    p += 2;

    for (char *fp = resp->wbuf; fp < end; fp++) {
        switch (*fp) {
            case 'O':
                // Copy stash...",63,,54,3,,void
53957,BLOCK,-1,,"{
    case STORED:
      if (settings.meta_response_old) {
          memcpy(p, ""OK"", 2);
      } else {
          memcpy(p, ""HD"", 2);
      }
      // Only place noreply is used for meta cmds is a nominal response.
      if (c->noreply) {
          resp->skip = true;
      }
      break;
    case EXISTS:
      memcpy(p, ""EX"", 2);
      break;
    case NOT_FOUND:
      memcpy(p, ""NF"", 2);
      break;
    case NOT_STORED:
      memcpy(p, ""NS"", 2);
      break;
    default:
      c->noreply = false;
      out_string(c, ""SERVER_ERROR Unhandled storage type."");
      return;
    }",18,,63,2,,void
53964,BLOCK,-1,,"{
          memcpy(p, ""OK"", 2);
      }",39,,65,2,,void
53970,BLOCK,-1,,"{
          memcpy(p, ""HD"", 2);
      }",14,,67,1,,void
53979,BLOCK,-1,,"{
          resp->skip = true;
      }",23,,71,2,,void
54021,BLOCK,-1,,<empty>,5,,91,1,,void
54033,BLOCK,4,,"{
        switch (*fp) {
            case 'O':
                // Copy stashed opaque.
                META_SPACE(p);
                while (fp < end && *fp != ' ') {
                    *p = *fp;
                    p++;
                    fp++;
                }
                break;
            case 'k':
                // Encode the key here instead of earlier to minimize copying.
                META_KEY(p, ITEM_key(it), it->nkey, (it->it_flags & ITEM_KEY_BINARY));
                break;
            case 'c':
                // We don't have the CAS until this point, which is why we
                // generate this line so late.
                META_CHAR(p, 'c');
                p = itoa_u64(c->cas, p);
                break;
            default:
                break;
        }
    }",49,,91,4,,void
54037,BLOCK,-1,,"{
            case 'O':
                // Copy stashed opaque.
                META_SPACE(p);
                while (fp < end && *fp != ' ') {
                    *p = *fp;
                    p++;
                    fp++;
                }
                break;
            case 'k':
                // Encode the key here instead of earlier to minimize copying.
                META_KEY(p, ITEM_key(it), it->nkey, (it->it_flags & ITEM_KEY_BINARY));
                break;
            case 'c':
                // We don't have the CAS until this point, which is why we
                // generate this line so late.
                META_CHAR(p, 'c');
                p = itoa_u64(c->cas, p);
                break;
            default:
                break;
        }",22,,92,2,,void
54042,BLOCK,1,,META_SPACE(p),17,,95,3,,void
54058,BLOCK,-1,,"{
                    *p = *fp;
                    p++;
                    fp++;
                }",48,,96,2,,void
54076,BLOCK,1,,"META_KEY(p, ITEM_key(it), it->nkey, (it->it_flags & ITEM_KEY_BINARY))",17,,104,8,,void
54077,BLOCK,1,,"META_KEY(p, ITEM_key(it), it->nkey, (it->it_flags & ITEM_KEY_BINARY))",17,,104,1,,void
54098,BLOCK,-1,,"META_KEY(p, ITEM_key(it), it->nkey, (it->it_flags & ITEM_KEY_BINARY))",17,,104,2,,void
54126,BLOCK,-1,,"META_KEY(p, ITEM_key(it), it->nkey, (it->it_flags & ITEM_KEY_BINARY))",17,,104,1,,void
54176,BLOCK,1,,"META_CHAR(p, 'c')",17,,109,12,,void
54226,BLOCK,-1,,"{
    assert(c != NULL);

    item *it = c->item;
    int comm = c->cmd;
    enum store_item_type ret;
    bool is_valid = false;

    pthread_mutex_lock(&c->thread->stats.mutex);
    c->thread->stats.slab_stats[ITEM_clsid(it)].set_cmds++;
    pthread_mutex_unlock(&c->thread->stats.mutex);

    if ((it->it_flags & ITEM_CHUNKED) == 0) {
        if (strncmp(ITEM_data(it) + it->nbytes - 2, ""\r\n"", 2) == 0) {
            is_valid = true;
        }
    } else {
        char buf[2];
        /* should point to the final item chunk */
        item_chunk *ch = (item_chunk *) c->ritem;
        assert(ch->used != 0);
        /* :( We need to look at the last two bytes. This could span two
         * chunks.
         */
        if (ch->used > 1) {
            buf[0] = ch->data[ch->used - 2];
            buf[1] = ch->data[ch->used - 1];
        } else {
            assert(ch->prev);
            assert(ch->used == 1);
            buf[0] = ch->prev->data[ch->prev->used - 1];
            buf[1] = c...",36,,128,2,,void
54269,BLOCK,1,,<empty>,,,,3,,void
54295,BLOCK,1,,<empty>,,,,1,,void
54298,BLOCK,-1,,"{
        if (strncmp(ITEM_data(it) + it->nbytes - 2, ""\r\n"", 2) == 0) {
            is_valid = true;
        }
    }",45,,140,2,,void
54306,BLOCK,1,,<empty>,,,,6,,void
54346,BLOCK,-1,,"{
            is_valid = true;
        }",70,,141,2,,void
54351,BLOCK,-1,,"{
        char buf[2];
        /* should point to the final item chunk */
        item_chunk *ch = (item_chunk *) c->ritem;
        assert(ch->used != 0);
        /* :( We need to look at the last two bytes. This could span two
         * chunks.
         */
        if (ch->used > 1) {
            buf[0] = ch->data[ch->used - 2];
            buf[1] = ch->data[ch->used - 1];
        } else {
            assert(ch->prev);
            assert(ch->used == 1);
            buf[0] = ch->prev->data[ch->prev->used - 1];
            buf[1] = ch->data[ch->used - 1];
        }
        if (strncmp(buf, ""\r\n"", 2) == 0) {
            is_valid = true;
        } else {
            assert(1 == 0);
        }
    }",12,,144,1,,void
54373,BLOCK,-1,,"{
            buf[0] = ch->data[ch->used - 2];
            buf[1] = ch->data[ch->used - 1];
        }",27,,152,2,,void
54401,BLOCK,-1,,"{
            assert(ch->prev);
            assert(ch->used == 1);
            buf[0] = ch->prev->data[ch->prev->used - 1];
            buf[1] = ch->data[ch->used - 1];
        }",16,,155,1,,void
54449,BLOCK,-1,,"{
            is_valid = true;
        }",43,,161,2,,void
54454,BLOCK,-1,,"{
            assert(1 == 0);
        }",16,,163,1,,void
54462,BLOCK,-1,,"{
        // metaset mode always returns errors.
        if (c->mset_res) {
            c->noreply = false;
        }
        out_string(c, ""CLIENT_ERROR bad data chunk"");
    }",20,,168,2,,void
54467,BLOCK,-1,,"{
            c->noreply = false;
        }",26,,170,2,,void
54477,BLOCK,-1,,"{
      ret = store_item(it, comm, c);

#ifdef ENABLE_DTRACE
      uint64_t cas = ITEM_get_cas(it);
      switch (c->cmd) {
      case NREAD_ADD:
          MEMCACHED_COMMAND_ADD(c->sfd, ITEM_key(it), it->nkey,
                                (ret == 1) ? it->nbytes : -1, cas);
          break;
      case NREAD_REPLACE:
          MEMCACHED_COMMAND_REPLACE(c->sfd, ITEM_key(it), it->nkey,
                                    (ret == 1) ? it->nbytes : -1, cas);
          break;
      case NREAD_APPEND:
          MEMCACHED_COMMAND_APPEND(c->sfd, ITEM_key(it), it->nkey,
                                   (ret == 1) ? it->nbytes : -1, cas);
          break;
      case NREAD_PREPEND:
          MEMCACHED_COMMAND_PREPEND(c->sfd, ITEM_key(it), it->nkey,
                                    (ret == 1) ? it->nbytes : -1, cas);
          break;
      case NREAD_SET:
          MEMCACHED_COMMAND_SET(c->sfd, ITEM_key(it), it->nkey,
                                (ret == 1) ? it->nbytes : -1, cas);
  ...",12,,174,1,,void
54488,BLOCK,-1,,"{
          _finalize_mset(c, ret);
      }",24,,207,2,,void
54493,BLOCK,-1,,"{
          switch (ret) {
          case STORED:
              out_string(c, ""STORED"");
              break;
          case EXISTS:
              out_string(c, ""EXISTS"");
              break;
          case NOT_FOUND:
              out_string(c, ""NOT_FOUND"");
              break;
          case NOT_STORED:
              out_string(c, ""NOT_STORED"");
              break;
          default:
              out_string(c, ""SERVER_ERROR Unhandled storage type."");
          }
      }",14,,209,1,,void
54496,BLOCK,-1,,"{
          case STORED:
              out_string(c, ""STORED"");
              break;
          case EXISTS:
              out_string(c, ""EXISTS"");
              break;
          case NOT_FOUND:
              out_string(c, ""NOT_FOUND"");
              break;
          case NOT_STORED:
              out_string(c, ""NOT_STORED"");
              break;
          default:
              out_string(c, ""SERVER_ERROR Unhandled storage type."");
          }",24,,210,2,,void
54550,BLOCK,-1,,"{
    char *s, *e;
    size_t ntokens = 0;
    assert(command != NULL && tokens != NULL && max_tokens > 1);
    size_t len = strlen(command);
    unsigned int i = 0;

    s = e = command;
    for (i = 0; i < len; i++) {
        if (*e == ' ') {
            if (s != e) {
                tokens[ntokens].value = s;
                tokens[ntokens].length = e - s;
                ntokens++;
                *e = '\0';
                if (ntokens == max_tokens - 1) {
                    e++;
                    s = e; /* so we don't add an extra token */
                    break;
                }
            }
            s = e + 1;
        }
        e++;
    }

    if (s != e) {
        tokens[ntokens].value = s;
        tokens[ntokens].length = e - s;
        ntokens++;
    }

    /*
     * If we scanned the whole string, the terminal value pointer is null,
     * otherwise it is the first unprocessed character.
     */
    tokens[ntokens].value =  *e == '\0' ? NULL : e;
    tokens[nto...",89,,283,4,,void
54584,BLOCK,-1,,<empty>,5,,291,1,,void
54593,BLOCK,4,,"{
        if (*e == ' ') {
            if (s != e) {
                tokens[ntokens].value = s;
                tokens[ntokens].length = e - s;
                ntokens++;
                *e = '\0';
                if (ntokens == max_tokens - 1) {
                    e++;
                    s = e; /* so we don't add an extra token */
                    break;
                }
            }
            s = e + 1;
        }
        e++;
    }",31,,291,4,,void
54599,BLOCK,-1,,"{
            if (s != e) {
                tokens[ntokens].value = s;
                tokens[ntokens].length = e - s;
                ntokens++;
                *e = '\0';
                if (ntokens == max_tokens - 1) {
                    e++;
                    s = e; /* so we don't add an extra token */
                    break;
                }
            }
            s = e + 1;
        }",24,,292,2,,void
54604,BLOCK,-1,,"{
                tokens[ntokens].value = s;
                tokens[ntokens].length = e - s;
                ntokens++;
                *e = '\0';
                if (ntokens == max_tokens - 1) {
                    e++;
                    s = e; /* so we don't add an extra token */
                    break;
                }
            }",25,,293,2,,void
54633,BLOCK,-1,,"{
                    e++;
                    s = e; /* so we don't add an extra token */
                    break;
                }",48,,298,2,,void
54651,BLOCK,-1,,"{
        tokens[ntokens].value = s;
        tokens[ntokens].length = e - s;
        ntokens++;
    }",17,,309,2,,void
54698,BLOCK,-1,,"{
    token_t tokens[MAX_TOKENS];
    size_t ntokens;
    char *cont = NULL;

    // TODO: move to another function.
    if (!c->sasl_started) {
        char *el;
        uint32_t size = 0;

        // impossible for the auth command to be this short.
        if (c->rbytes < 2)
            return 0;

        el = memchr(c->rcurr, '\n', c->rbytes);

        // If no newline after 1k, getting junk data, close out.
        if (!el) {
            if (c->rbytes > 2048) {
                conn_set_state(c, conn_closing);
                return 1;
            }
            return 0;
        }

        // Looking for: ""set foo 0 0 N\r\nuser pass\r\n""
        // key, flags, and ttl are ignored. N is used to see if we have the rest.

        // so tokenize doesn't walk past into the value.
        // it's fine to leave the \r in, as strtoul will stop at it.
        *el = '\0';

        ntokens = tokenize_command(c->rcurr, tokens, MAX_TOKENS);
        // ensure the buffer is consumed.
        c...",41,,326,2,,void
54710,BLOCK,-1,,"{
        char *el;
        uint32_t size = 0;

        // impossible for the auth command to be this short.
        if (c->rbytes < 2)
            return 0;

        el = memchr(c->rcurr, '\n', c->rbytes);

        // If no newline after 1k, getting junk data, close out.
        if (!el) {
            if (c->rbytes > 2048) {
                conn_set_state(c, conn_closing);
                return 1;
            }
            return 0;
        }

        // Looking for: ""set foo 0 0 N\r\nuser pass\r\n""
        // key, flags, and ttl are ignored. N is used to see if we have the rest.

        // so tokenize doesn't walk past into the value.
        // it's fine to leave the \r in, as strtoul will stop at it.
        *el = '\0';

        ntokens = tokenize_command(c->rcurr, tokens, MAX_TOKENS);
        // ensure the buffer is consumed.
        c->rbytes -= (el - c->rcurr) + 1;
        c->rcurr += (el - c->rcurr) + 1;

        // final token is a NULL ender, so we have one more than exp...",27,,332,2,,void
54722,BLOCK,-1,,<empty>,13,,338,2,,void
54738,BLOCK,-1,,"{
            if (c->rbytes > 2048) {
                conn_set_state(c, conn_closing);
                return 1;
            }
            return 0;
        }",18,,343,2,,void
54745,BLOCK,-1,,"{
                conn_set_state(c, conn_closing);
                return 1;
            }",35,,344,2,,void
54765,BLOCK,1,,<empty>,,,,1,,void
54813,BLOCK,-1,,"{
            if (!c->resp) {
                if (!resp_start(c)) {
                    conn_set_state(c, conn_closing);
                    return 1;
                }
            }
            out_string(c, ""CLIENT_ERROR unauthenticated"");
            return 1;
        }",59,,366,2,,void
54819,BLOCK,-1,,"{
                if (!resp_start(c)) {
                    conn_set_state(c, conn_closing);
                    return 1;
                }
            }",27,,367,2,,void
54824,BLOCK,-1,,"{
                    conn_set_state(c, conn_closing);
                    return 1;
                }",37,,368,2,,void
54855,BLOCK,-1,,"{
        // need more bytes.
        return 0;
    }",33,,384,2,,void
54863,BLOCK,-1,,"{
        if (!resp_start(c)) {
            conn_set_state(c, conn_closing);
            return 1;
        }
    }",19,,390,2,,void
54868,BLOCK,-1,,"{
            conn_set_state(c, conn_closing);
            return 1;
        }",29,,391,2,,void
54911,BLOCK,-1,,"{
        out_string(c, ""CLIENT_ERROR bad command line termination"");
        return 1;
    }",57,,406,2,,void
54932,BLOCK,1,,<empty>,,,,1,,void
54938,BLOCK,-1,,"{
        out_string(c, ""CLIENT_ERROR bad authentication token format"");
        return 1;
    }",22,,415,2,,void
54958,BLOCK,-1,,"{
        out_string(c, ""STORED"");
        c->authenticated = true;
        c->try_read_command = try_read_command_ascii;
        pthread_mutex_lock(&c->thread->stats.mutex);
        c->thread->stats.auth_cmds++;
        pthread_mutex_unlock(&c->thread->stats.mutex);
    }",64,,420,2,,void
54999,BLOCK,-1,,"{
        out_string(c, ""CLIENT_ERROR authentication failure"");
        pthread_mutex_lock(&c->thread->stats.mutex);
        c->thread->stats.auth_cmds++;
        c->thread->stats.auth_errors++;
        pthread_mutex_unlock(&c->thread->stats.mutex);
    }",12,,427,1,,void
55043,BLOCK,-1,,"{
    char *el, *cont;

    if (c->rbytes == 0)
        return 0;

    el = memchr(c->rcurr, '\n', c->rbytes);
    if (!el) {
        if (c->rbytes > 2048) {
            /*
             * We didn't have a '\n' in the first few k. This _has_ to be a
             * large multiget, if not we should just nuke the connection.
             */
            char *ptr = c->rcurr;
            while (*ptr == ' ') { /* ignore leading whitespaces */
                ++ptr;
            }

            if (ptr - c->rcurr > 100 ||
                (strncmp(ptr, ""get "", 4) && strncmp(ptr, ""gets "", 5))) {

                conn_set_state(c, conn_closing);
                return 1;
            }

            // ASCII multigets are unbound, so our fixed size rbuf may not
            // work for this particular workload... For backcompat we'll use a
            // malloc/realloc/free routine just for this.
            if (!c->rbuf_malloced) {
                if (!rbuf_switch_to_malloc(c)) {
                 ...",37,,438,2,,void
55052,BLOCK,-1,,<empty>,9,,442,2,,void
55068,BLOCK,-1,,"{
        if (c->rbytes > 2048) {
            /*
             * We didn't have a '\n' in the first few k. This _has_ to be a
             * large multiget, if not we should just nuke the connection.
             */
            char *ptr = c->rcurr;
            while (*ptr == ' ') { /* ignore leading whitespaces */
                ++ptr;
            }

            if (ptr - c->rcurr > 100 ||
                (strncmp(ptr, ""get "", 4) && strncmp(ptr, ""gets "", 5))) {

                conn_set_state(c, conn_closing);
                return 1;
            }

            // ASCII multigets are unbound, so our fixed size rbuf may not
            // work for this particular workload... For backcompat we'll use a
            // malloc/realloc/free routine just for this.
            if (!c->rbuf_malloced) {
                if (!rbuf_switch_to_malloc(c)) {
                    conn_set_state(c, conn_closing);
                    return 1;
                }
            }
        }

        return ...",14,,445,2,,void
55075,BLOCK,-1,,"{
            /*
             * We didn't have a '\n' in the first few k. This _has_ to be a
             * large multiget, if not we should just nuke the connection.
             */
            char *ptr = c->rcurr;
            while (*ptr == ' ') { /* ignore leading whitespaces */
                ++ptr;
            }

            if (ptr - c->rcurr > 100 ||
                (strncmp(ptr, ""get "", 4) && strncmp(ptr, ""gets "", 5))) {

                conn_set_state(c, conn_closing);
                return 1;
            }

            // ASCII multigets are unbound, so our fixed size rbuf may not
            // work for this particular workload... For backcompat we'll use a
            // malloc/realloc/free routine just for this.
            if (!c->rbuf_malloced) {
                if (!rbuf_switch_to_malloc(c)) {
                    conn_set_state(c, conn_closing);
                    return 1;
                }
            }
        }",31,,446,2,,void
55087,BLOCK,-1,,"{ /* ignore leading whitespaces */
                ++ptr;
            }",33,,452,2,,void
55108,BLOCK,-1,,"{

                conn_set_state(c, conn_closing);
                return 1;
            }",72,,457,2,,void
55119,BLOCK,-1,,"{
                if (!rbuf_switch_to_malloc(c)) {
                    conn_set_state(c, conn_closing);
                    return 1;
                }
            }",36,,466,2,,void
55124,BLOCK,-1,,"{
                    conn_set_state(c, conn_closing);
                    return 1;
                }",48,,467,2,,void
55152,BLOCK,-1,,"{
        el--;
    }",51,,477,2,,void
55213,BLOCK,-1,,"{
    int noreply_index = ntokens - 2;

    /*
      NOTE: this function is not the first place where we are going to
      send the reply.  We could send it instead from process_command()
      if the request line has wrong number of tokens.  However parsing
      malformed line for ""noreply"" option is not reliable anyway, so
      it can't be helped.
    */
    if (tokens[noreply_index].value
        && strcmp(tokens[noreply_index].value, ""noreply"") == 0) {
        c->noreply = true;
    }
    return c->noreply;
}",1,,497,4,,void
55236,BLOCK,-1,,"{
        c->noreply = true;
    }",65,,508,2,,void
55253,BLOCK,-1,,"{
    char *p = suffix;
    *p = ' ';
    p++;
    if (FLAGS_SIZE(it) == 0) {
        *p = '0';
        p++;
    } else {
        p = itoa_u32(*((uint32_t *) ITEM_suffix(it)), p);
    }
    *p = ' ';
    p = itoa_u32(nbytes-2, p+1);

    if (return_cas) {
        *p = ' ';
        p = itoa_u64(ITEM_get_cas(it), p+1);
    }

    *p = '\r';
    *(p+1) = '\n';
    *(p+2) = '\0';
    return (p - suffix) + 2;
}",94,,515,5,,void
55268,BLOCK,1,,<empty>,,,,2,,void
55279,BLOCK,-1,,"{
        *p = '0';
        p++;
    }",30,,519,2,,void
55287,BLOCK,-1,,"{
        p = itoa_u32(*((uint32_t *) ITEM_suffix(it)), p);
    }",12,,522,1,,void
55296,BLOCK,1,,<empty>,,,,2,,void
55335,BLOCK,-1,,"{
        *p = ' ';
        p = itoa_u64(ITEM_get_cas(it), p+1);
    }",21,,528,2,,void
55345,BLOCK,1,,<empty>,,,,2,,void
55393,BLOCK,-1,,"{
    char *key;
    size_t nkey;
    item *it;
    token_t *key_token = &tokens[KEY_TOKEN];
    int32_t exptime_int = 0;
    rel_time_t exptime = 0;
    bool fail_length = false;
    assert(c != NULL);
    mc_resp *resp = c->resp;

    if (should_touch) {
        // For get and touch commands, use first token as exptime
        if (!safe_strtol(tokens[1].value, &exptime_int)) {
            out_string(c, ""CLIENT_ERROR invalid exptime argument"");
            return;
        }
        key_token++;
        exptime = realtime(EXPTIME_TO_POSITIVE_TIME(exptime_int));
    }

    do {
        while(key_token->length != 0) {
            bool overflow; // not used here.
            key = key_token->value;
            nkey = key_token->length;

            if (nkey > KEY_MAX_LENGTH) {
                fail_length = true;
                goto stop;
            }

            it = limited_get(key, nkey, c, exptime, should_touch, DO_UPDATE, &overflow);
            if (settings.detail_enabled) {
  ...",118,,540,6,,void
55404,BLOCK,1,,<empty>,,,,1,,void
55430,BLOCK,-1,,"{
        // For get and touch commands, use first token as exptime
        if (!safe_strtol(tokens[1].value, &exptime_int)) {
            out_string(c, ""CLIENT_ERROR invalid exptime argument"");
            return;
        }
        key_token++;
        exptime = realtime(EXPTIME_TO_POSITIVE_TIME(exptime_int));
    }",23,,551,2,,void
55441,BLOCK,-1,,"{
            out_string(c, ""CLIENT_ERROR invalid exptime argument"");
            return;
        }",58,,553,2,,void
55453,BLOCK,1,,<empty>,,,,4,,void
55469,BLOCK,-1,,"{
        while(key_token->length != 0) {
            bool overflow; // not used here.
            key = key_token->value;
            nkey = key_token->length;

            if (nkey > KEY_MAX_LENGTH) {
                fail_length = true;
                goto stop;
            }

            it = limited_get(key, nkey, c, exptime, should_touch, DO_UPDATE, &overflow);
            if (settings.detail_enabled) {
                stats_prefix_record_get(key, nkey, NULL != it);
            }
            if (it) {
                /*
                 * Construct the response. Each hit adds three elements to the
                 * outgoing data list:
                 *   ""VALUE ""
                 *   key
                 *   "" "" + flags + "" "" + data length + ""\r\n"" + data (with \r\n)
                 */

                {
                  MEMCACHED_COMMAND_GET(c->sfd, ITEM_key(it), it->nkey,
                                        it->nbytes, ITEM_get_cas(it));
                  int nbytes ...",8,,561,1,,void
55476,BLOCK,-1,,"{
            bool overflow; // not used here.
            key = key_token->value;
            nkey = key_token->length;

            if (nkey > KEY_MAX_LENGTH) {
                fail_length = true;
                goto stop;
            }

            it = limited_get(key, nkey, c, exptime, should_touch, DO_UPDATE, &overflow);
            if (settings.detail_enabled) {
                stats_prefix_record_get(key, nkey, NULL != it);
            }
            if (it) {
                /*
                 * Construct the response. Each hit adds three elements to the
                 * outgoing data list:
                 *   ""VALUE ""
                 *   key
                 *   "" "" + flags + "" "" + data length + ""\r\n"" + data (with \r\n)
                 */

                {
                  MEMCACHED_COMMAND_GET(c->sfd, ITEM_key(it), it->nkey,
                                        it->nbytes, ITEM_get_cas(it));
                  int nbytes = it->nbytes;;
                  nbytes ...",39,,562,2,,void
55492,BLOCK,1,,<empty>,,,,1,,void
55494,BLOCK,-1,,"{
                fail_length = true;
                goto stop;
            }",40,,567,2,,void
55508,BLOCK,1,,<empty>,,,,1,,void
55516,BLOCK,-1,,"{
                stats_prefix_record_get(key, nkey, NULL != it);
            }",42,,573,2,,void
55525,BLOCK,-1,,"{
                /*
                 * Construct the response. Each hit adds three elements to the
                 * outgoing data list:
                 *   ""VALUE ""
                 *   key
                 *   "" "" + flags + "" "" + data length + ""\r\n"" + data (with \r\n)
                 */

                {
                  MEMCACHED_COMMAND_GET(c->sfd, ITEM_key(it), it->nkey,
                                        it->nbytes, ITEM_get_cas(it));
                  int nbytes = it->nbytes;;
                  nbytes = it->nbytes;
                  char *p = resp->wbuf;
                  memcpy(p, ""VALUE "", 6);
                  p += 6;
                  memcpy(p, ITEM_key(it), it->nkey);
                  p += it->nkey;
                  p += make_ascii_get_suffix(p, it, return_cas, nbytes);
                  resp_add_iov(resp, resp->wbuf, p - resp->wbuf);

#ifdef EXTSTORE
                  if (it->it_flags & ITEM_HDR) {
                      if (storage_get_item(c, it, resp) !=...",21,,576,2,,void
55526,BLOCK,1,,"{
                  MEMCACHED_COMMAND_GET(c->sfd, ITEM_key(it), it->nkey,
                                        it->nbytes, ITEM_get_cas(it));
                  int nbytes = it->nbytes;;
                  nbytes = it->nbytes;
                  char *p = resp->wbuf;
                  memcpy(p, ""VALUE "", 6);
                  p += 6;
                  memcpy(p, ITEM_key(it), it->nkey);
                  p += it->nkey;
                  p += make_ascii_get_suffix(p, it, return_cas, nbytes);
                  resp_add_iov(resp, resp->wbuf, p - resp->wbuf);

#ifdef EXTSTORE
                  if (it->it_flags & ITEM_HDR) {
                      if (storage_get_item(c, it, resp) != 0) {
                          pthread_mutex_lock(&c->thread->stats.mutex);
                          c->thread->stats.get_oom_extstore++;
                          pthread_mutex_unlock(&c->thread->stats.mutex);

                          item_remove(it);
                          goto stop;
                  ...",17,,585,1,,void
55555,BLOCK,1,,<empty>,,,,4,,void
55604,BLOCK,1,,<empty>,,,,1,,void
55607,BLOCK,-1,,"{
                      resp_add_iov(resp, ITEM_data(it), it->nbytes);
                  }",59,,614,2,,void
55612,BLOCK,1,,<empty>,,,,6,,void
55649,BLOCK,-1,,"{
                      resp_add_chunked_iov(resp, it, it->nbytes);
                  }",26,,616,1,,void
55662,BLOCK,-1,,"{
                    int ii;
                    fprintf(stderr, "">%d sending key "", c->sfd);
                    for (ii = 0; ii < it->nkey; ++ii) {
                        fprintf(stderr, ""%c"", key[ii]);
                    }
                    fprintf(stderr, ""\n"");
                }",43,,622,2,,void
55671,BLOCK,-1,,<empty>,21,,625,1,,void
55682,BLOCK,4,,"{
                        fprintf(stderr, ""%c"", key[ii]);
                    }",55,,625,4,,void
55703,BLOCK,-1,,"{
                    c->thread->stats.touch_cmds++;
                    c->thread->stats.slab_stats[ITEM_clsid(it)].touch_hits++;
                }",35,,633,2,,void
55724,BLOCK,1,,<empty>,,,,3,,void
55735,BLOCK,-1,,"{
                    c->thread->stats.lru_hits[it->slabs_clsid]++;
                    c->thread->stats.get_cmds++;
                }",24,,636,1,,void
55771,BLOCK,-1,,"{
                pthread_mutex_lock(&c->thread->stats.mutex);
                if (should_touch) {
                    c->thread->stats.touch_cmds++;
                    c->thread->stats.touch_misses++;
                } else {
                    c->thread->stats.get_misses++;
                    c->thread->stats.get_cmds++;
                }
                MEMCACHED_COMMAND_GET(c->sfd, key, nkey, -1, 0);
                pthread_mutex_unlock(&c->thread->stats.mutex);
            }",20,,649,1,,void
55783,BLOCK,-1,,"{
                    c->thread->stats.touch_cmds++;
                    c->thread->stats.touch_misses++;
                }",35,,651,2,,void
55801,BLOCK,-1,,"{
                    c->thread->stats.get_misses++;
                    c->thread->stats.get_cmds++;
                }",24,,654,1,,void
55835,BLOCK,-1,,"{
                if (!resp_start(c)) {
                    goto stop;
                }
                resp = c->resp;
            }",41,,663,2,,void
55840,BLOCK,-1,,"{
                    goto stop;
                }",37,,664,2,,void
55853,BLOCK,-1,,"{
            ntokens = tokenize_command(key_token->value, tokens, MAX_TOKENS);
            key_token = tokens;
            if (!resp_start(c)) {
                goto stop;
            }
            resp = c->resp;
        }",39,,675,2,,void
55862,BLOCK,1,,<empty>,,,,1,,void
55871,BLOCK,-1,,"{
                goto stop;
            }",33,,678,2,,void
55890,BLOCK,-1,,<empty>,9,,687,2,,void
55903,BLOCK,-1,,"{
        // Kill any stacked responses we had.
        conn_release_items(c);
        // Start a new response object for the error message.
        if (!resp_start(c)) {
            // severe out of memory error.
            conn_set_state(c, conn_closing);
            return;
        }
        if (fail_length) {
            out_string(c, ""CLIENT_ERROR bad command line format"");
        } else {
            out_of_memory(c, ""SERVER_ERROR out of memory writing get response"");
        }
    }",35,,694,2,,void
55910,BLOCK,-1,,"{
            // severe out of memory error.
            conn_set_state(c, conn_closing);
            return;
        }",29,,698,2,,void
55917,BLOCK,-1,,"{
            out_string(c, ""CLIENT_ERROR bad command line format"");
        }",26,,703,2,,void
55922,BLOCK,-1,,"{
            out_of_memory(c, ""SERVER_ERROR out of memory writing get response"");
        }",16,,705,1,,void
55927,BLOCK,-1,,"{
        // Tag the end token onto the most recent response object.
        resp_add_iov(resp, ""END\r\n"", 5);
        conn_set_state(c, conn_mwrite);
    }",12,,708,1,,void
55940,BLOCK,-1,,"{
    assert(c != NULL);

    if (strcmp(command, ""on"") == 0) {
        settings.detail_enabled = 1;
        out_string(c, ""OK"");
    }
    else if (strcmp(command, ""off"") == 0) {
        settings.detail_enabled = 0;
        out_string(c, ""OK"");
    }
    else if (strcmp(command, ""dump"") == 0) {
        int len;
        char *stats = stats_prefix_dump(&len);
        write_and_free(c, stats, len);
    }
    else {
        out_string(c, ""CLIENT_ERROR usage: stats detail on|off|dump"");
    }
}",71,,715,3,,void
55951,BLOCK,-1,,"{
        settings.detail_enabled = 1;
        out_string(c, ""OK"");
    }",37,,718,2,,void
55961,BLOCK,-1,,<empty>,10,,722,1,,void
55968,BLOCK,-1,,"{
        settings.detail_enabled = 0;
        out_string(c, ""OK"");
    }",43,,722,2,,void
55978,BLOCK,-1,,<empty>,10,,726,1,,void
55985,BLOCK,-1,,"{
        int len;
        char *stats = stats_prefix_dump(&len);
        write_and_free(c, stats, len);
    }",44,,726,2,,void
55998,BLOCK,-1,,"{
        out_string(c, ""CLIENT_ERROR usage: stats detail on|off|dump"");
    }",10,,731,1,,void
56008,BLOCK,-1,,"{
    const char *subcommand = tokens[SUBCOMMAND_TOKEN].value;
    assert(c != NULL);

    if (ntokens < 2) {
        out_string(c, ""CLIENT_ERROR bad command line"");
        return;
    }

    if (ntokens == 2) {
        server_stats(&append_stats, c);
        (void)get_stats(NULL, 0, &append_stats, c);
    } else if (strcmp(subcommand, ""reset"") == 0) {
        stats_reset();
        out_string(c, ""RESET"");
        return;
    } else if (strcmp(subcommand, ""detail"") == 0) {
        /* NOTE: how to tackle detail with binary? */
        if (ntokens < 4)
            process_stats_detail(c, """");  /* outputs the error message */
        else
            process_stats_detail(c, tokens[2].value);
        /* Output already generated */
        return;
    } else if (strcmp(subcommand, ""settings"") == 0) {
        process_stat_settings(&append_stats, c);
    } else if (strcmp(subcommand, ""cachedump"") == 0) {
        char *buf;
        unsigned int bytes, id, limit = 0;

        if (!settings....",74,,736,4,,void
56016,BLOCK,1,,<empty>,,,,1,,void
56027,BLOCK,-1,,"{
        out_string(c, ""CLIENT_ERROR bad command line"");
        return;
    }",22,,740,2,,void
56036,BLOCK,-1,,"{
        server_stats(&append_stats, c);
        (void)get_stats(NULL, 0, &append_stats, c);
    }",23,,745,2,,void
56050,BLOCK,-1,,<empty>,12,,748,1,,void
56057,BLOCK,-1,,"{
        stats_reset();
        out_string(c, ""RESET"");
        return;
    }",50,,748,2,,void
56064,BLOCK,-1,,<empty>,12,,752,1,,void
56071,BLOCK,-1,,"{
        /* NOTE: how to tackle detail with binary? */
        if (ntokens < 4)
            process_stats_detail(c, """");  /* outputs the error message */
        else
            process_stats_detail(c, tokens[2].value);
        /* Output already generated */
        return;
    }",51,,752,2,,void
56076,BLOCK,-1,,<empty>,13,,755,2,,void
56081,BLOCK,-1,,<empty>,13,,757,1,,void
56091,BLOCK,-1,,<empty>,12,,760,1,,void
56098,BLOCK,-1,,"{
        process_stat_settings(&append_stats, c);
    }",53,,760,2,,void
56104,BLOCK,-1,,<empty>,12,,762,1,,void
56111,BLOCK,-1,,"{
        char *buf;
        unsigned int bytes, id, limit = 0;

        if (!settings.dump_enabled) {
            out_string(c, ""CLIENT_ERROR stats cachedump not allowed"");
            return;
        }

        if (ntokens < 5) {
            out_string(c, ""CLIENT_ERROR bad command line"");
            return;
        }

        if (!safe_strtoul(tokens[2].value, &id) ||
            !safe_strtoul(tokens[3].value, &limit)) {
            out_string(c, ""CLIENT_ERROR bad command line format"");
            return;
        }

        if (id >= MAX_NUMBER_OF_SLAB_CLASSES) {
            out_string(c, ""CLIENT_ERROR Illegal slab id"");
            return;
        }

        buf = item_cachedump(id, limit, &bytes);
        write_and_free(c, buf, bytes);
        return;
    }",54,,762,2,,void
56124,BLOCK,-1,,"{
            out_string(c, ""CLIENT_ERROR stats cachedump not allowed"");
            return;
        }",37,,766,2,,void
56133,BLOCK,-1,,"{
            out_string(c, ""CLIENT_ERROR bad command line"");
            return;
        }",26,,771,2,,void
56158,BLOCK,-1,,"{
            out_string(c, ""CLIENT_ERROR bad command line format"");
            return;
        }",53,,777,2,,void
56167,BLOCK,1,,<empty>,,,,1,,void
56171,BLOCK,-1,,"{
            out_string(c, ""CLIENT_ERROR Illegal slab id"");
            return;
        }",47,,782,2,,void
56189,BLOCK,-1,,<empty>,12,,790,1,,void
56196,BLOCK,-1,,"{
        process_stats_conns(&append_stats, c);
#ifdef EXTSTORE
    } else if (strcmp(subcommand, ""extstore"") == 0) {
        process_extstore_stats(&append_stats, c);
#endif
#ifdef PROXY
    } else if (strcmp(subcommand, ""proxy"") == 0) {
        process_proxy_stats(&append_stats, c);
#endif
    }",50,,790,2,,void
56202,BLOCK,-1,,"{
        /* getting here means that the subcommand is either engine specific or
           is invalid. query the engine and see. */
        if (get_stats(subcommand, strlen(subcommand), &append_stats, c)) {
            if (c->stats.buffer == NULL) {
                out_of_memory(c, ""SERVER_ERROR out of memory writing stats"");
            } else {
                write_and_free(c, c->stats.buffer, c->stats.offset);
                c->stats.buffer = NULL;
            }
        } else {
            out_string(c, ""ERROR"");
        }
        return;
    }",12,,800,1,,void
56211,BLOCK,-1,,"{
            if (c->stats.buffer == NULL) {
                out_of_memory(c, ""SERVER_ERROR out of memory writing stats"");
            } else {
                write_and_free(c, c->stats.buffer, c->stats.offset);
                c->stats.buffer = NULL;
            }
        }",74,,803,2,,void
56220,BLOCK,-1,,"{
                out_of_memory(c, ""SERVER_ERROR out of memory writing stats"");
            }",42,,804,2,,void
56225,BLOCK,-1,,"{
                write_and_free(c, c->stats.buffer, c->stats.offset);
                c->stats.buffer = NULL;
            }",20,,806,1,,void
56246,BLOCK,-1,,"{
            out_string(c, ""ERROR"");
        }",16,,810,1,,void
56265,BLOCK,-1,,"{
        out_of_memory(c, ""SERVER_ERROR out of memory writing stats"");
    }",34,,819,2,,void
56270,BLOCK,-1,,"{
        write_and_free(c, c->stats.buffer, c->stats.offset);
        c->stats.buffer = NULL;
    }",12,,821,1,,void
56296,BLOCK,-1,,"{
    assert(c != NULL);

    if (ntokens < 3 || tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {
        out_string(c, ""CLIENT_ERROR bad command line format"");
        return;
    }

    char *key = tokens[KEY_TOKEN].value;
    size_t nkey = tokens[KEY_TOKEN].length;

    if (ntokens >= 4 && tokens[2].length == 1 && tokens[2].value[0] == 'b') {
        size_t ret = base64_decode((unsigned char *)key, nkey,
                    (unsigned char *)key, nkey);
        if (ret == 0) {
            // failed to decode.
            out_string(c, ""CLIENT_ERROR bad command line format"");
            return;
        }
        nkey = ret;
    }

    bool overflow; // not used here.
    item *it = limited_get(key, nkey, c, 0, false, DONT_UPDATE, &overflow);
    if (it) {
        mc_resp *resp = c->resp;
        size_t total = 0;
        size_t ret;
        // similar to out_string().
        memcpy(resp->wbuf, ""ME "", 3);
        total += 3;
        if (it->it_flags & ITEM_KEY_BINARY) {
            //...",82,,828,4,,void
56311,BLOCK,1,,<empty>,,,,1,,void
56315,BLOCK,1,,<empty>,,,,1,,void
56317,BLOCK,-1,,"{
        out_string(c, ""CLIENT_ERROR bad command line format"");
        return;
    }",67,,831,2,,void
56329,BLOCK,1,,<empty>,,,,1,,void
56339,BLOCK,1,,<empty>,,,,1,,void
56364,BLOCK,-1,,"{
        size_t ret = base64_decode((unsigned char *)key, nkey,
                    (unsigned char *)key, nkey);
        if (ret == 0) {
            // failed to decode.
            out_string(c, ""CLIENT_ERROR bad command line format"");
            return;
        }
        nkey = ret;
    }",77,,839,2,,void
56381,BLOCK,-1,,"{
            // failed to decode.
            out_string(c, ""CLIENT_ERROR bad command line format"");
            return;
        }",23,,842,2,,void
56400,BLOCK,1,,<empty>,,,,1,,void
56406,BLOCK,-1,,"{
        mc_resp *resp = c->resp;
        size_t total = 0;
        size_t ret;
        // similar to out_string().
        memcpy(resp->wbuf, ""ME "", 3);
        total += 3;
        if (it->it_flags & ITEM_KEY_BINARY) {
            // re-encode from memory rather than copy the original key;
            // to help give confidence that what in memory is what we asked
            // for.
            total += base64_encode((unsigned char *) ITEM_key(it), it->nkey, (unsigned char *)resp->wbuf + total, WRITE_BUFFER_SIZE - total);
        } else {
            memcpy(resp->wbuf + total, ITEM_key(it), it->nkey);
            total += it->nkey;
        }
        resp->wbuf[total] = ' ';
        total++;

        ret = snprintf(resp->wbuf + total, WRITE_BUFFER_SIZE - (it->nkey + 12),
                ""exp=%d la=%llu cas=%llu fetch=%s cls=%u size=%lu\r\n"",
                (it->exptime == 0) ? -1 : (current_time - it->exptime),
                (unsigned long long)(current_time - it->time),
      ...",13,,852,2,,void
56433,BLOCK,1,,<empty>,,,,1,,void
56435,BLOCK,-1,,"{
            // re-encode from memory rather than copy the original key;
            // to help give confidence that what in memory is what we asked
            // for.
            total += base64_encode((unsigned char *) ITEM_key(it), it->nkey, (unsigned char *)resp->wbuf + total, WRITE_BUFFER_SIZE - total);
        }",45,,859,2,,void
56443,BLOCK,1,,<empty>,,,,4,,void
56472,BLOCK,1,,<empty>,,,,1,,void
56476,BLOCK,-1,,"{
            memcpy(resp->wbuf + total, ITEM_key(it), it->nkey);
            total += it->nkey;
        }",16,,864,1,,void
56485,BLOCK,1,,<empty>,,,,4,,void
56529,BLOCK,1,,<empty>,,,,1,,void
56561,BLOCK,1,,<empty>,,,,4,,void
56582,BLOCK,1,,<empty>,,,,1,,void
56588,BLOCK,1,,<empty>,,,,3,,void
56601,BLOCK,1,,<empty>,,,,6,,void
56655,BLOCK,-1,,"{
        out_string(c, ""EN"");
    }",12,,884,1,,void
56713,BLOCK,-1,,"{
    unsigned int i;
    size_t ret;
    int32_t tmp_int;
    uint8_t seen[127] = {0};
    // Start just past the key token. Look at first character of each token.
    for (i = start; tokens[i].length != 0; i++) {
        uint8_t o = (uint8_t)tokens[i].value[0];
        // zero out repeat flags so we don't over-parse for return data.
        if (o >= 127 || seen[o] != 0) {
            *errstr = ""CLIENT_ERROR duplicate flag"";
            return -1;
        }
        seen[o] = 1;
        switch (o) {
            // base64 decode the key in-place, as the binary should always be
            // shorter and the conversion code buffers bytes.
            case 'b':
                ret = base64_decode((unsigned char *)tokens[KEY_TOKEN].value, tokens[KEY_TOKEN].length,
                            (unsigned char *)tokens[KEY_TOKEN].value, tokens[KEY_TOKEN].length);
                if (ret == 0) {
                    // Failed to decode
                    *errstr = ""CLIENT_ERROR error decodin...",48,,919,5,,void
56723,BLOCK,-1,,<empty>,5,,925,1,,void
56736,BLOCK,4,,"{
        uint8_t o = (uint8_t)tokens[i].value[0];
        // zero out repeat flags so we don't over-parse for return data.
        if (o >= 127 || seen[o] != 0) {
            *errstr = ""CLIENT_ERROR duplicate flag"";
            return -1;
        }
        seen[o] = 1;
        switch (o) {
            // base64 decode the key in-place, as the binary should always be
            // shorter and the conversion code buffers bytes.
            case 'b':
                ret = base64_decode((unsigned char *)tokens[KEY_TOKEN].value, tokens[KEY_TOKEN].length,
                            (unsigned char *)tokens[KEY_TOKEN].value, tokens[KEY_TOKEN].length);
                if (ret == 0) {
                    // Failed to decode
                    *errstr = ""CLIENT_ERROR error decoding key"";
                    of->has_error = 1;
                }
                tokens[KEY_TOKEN].length = ret;
                of->key_binary = 1;
                break;
            /* Negative exptimes can unde...",49,,925,4,,void
56759,BLOCK,-1,,"{
            *errstr = ""CLIENT_ERROR duplicate flag"";
            return -1;
        }",39,,928,2,,void
56774,BLOCK,-1,,"{
            // base64 decode the key in-place, as the binary should always be
            // shorter and the conversion code buffers bytes.
            case 'b':
                ret = base64_decode((unsigned char *)tokens[KEY_TOKEN].value, tokens[KEY_TOKEN].length,
                            (unsigned char *)tokens[KEY_TOKEN].value, tokens[KEY_TOKEN].length);
                if (ret == 0) {
                    // Failed to decode
                    *errstr = ""CLIENT_ERROR error decoding key"";
                    of->has_error = 1;
                }
                tokens[KEY_TOKEN].length = ret;
                of->key_binary = 1;
                break;
            /* Negative exptimes can underflow and end up immortal. realtime() will
               immediately expire values that are greater than REALTIME_MAXDELTA, but less
               than process_started, so lets aim for that. */
            case 'N':
                of->locked = 1;
                of->vivify = 1;
        ...",20,,933,2,,void
56786,BLOCK,1,,<empty>,,,,1,,void
56793,BLOCK,1,,<empty>,,,,1,,void
56802,BLOCK,1,,<empty>,,,,1,,void
56809,BLOCK,1,,<empty>,,,,1,,void
56816,BLOCK,-1,,"{
                    // Failed to decode
                    *errstr = ""CLIENT_ERROR error decoding key"";
                    of->has_error = 1;
                }",31,,939,2,,void
56831,BLOCK,1,,<empty>,,,,1,,void
56865,BLOCK,-1,,"{
                    *errstr = ""CLIENT_ERROR bad token in command line format"";
                    of->has_error = 1;
                }",64,,953,2,,void
56876,BLOCK,-1,,"{
                    of->autoviv_exptime = realtime(EXPTIME_TO_POSITIVE_TIME(tmp_int));
                }",24,,956,1,,void
56884,BLOCK,1,,<empty>,,,,4,,void
56919,BLOCK,-1,,"{
                    *errstr = ""CLIENT_ERROR bad token in command line format"";
                    of->has_error = 1;
                }",64,,962,2,,void
56930,BLOCK,-1,,"{
                    of->exptime = realtime(EXPTIME_TO_POSITIVE_TIME(tmp_int));
                    of->new_ttl = true;
                }",24,,965,1,,void
56938,BLOCK,1,,<empty>,,,,4,,void
56978,BLOCK,-1,,"{
                    *errstr = ""CLIENT_ERROR bad token in command line format"";
                    of->has_error = 1;
                }",64,,972,2,,void
56989,BLOCK,-1,,"{
                    of->recache_time = realtime(EXPTIME_TO_POSITIVE_TIME(tmp_int));
                }",24,,975,1,,void
56997,BLOCK,1,,<empty>,,,,4,,void
57092,BLOCK,-1,,"{
                    of->has_error = true;
                }",74,,1007,2,,void
57115,BLOCK,-1,,"{
                    *errstr = ""CLIENT_ERROR bad token in command line format"";
                    of->has_error = true;
                }",73,,1012,2,,void
57126,BLOCK,-1,,"{
                    of->has_cas = true;
                }",24,,1015,1,,void
57143,BLOCK,-1,,"{
                    *errstr = ""CLIENT_ERROR incorrect length for M token"";
                    of->has_error = 1;
                }",44,,1020,2,,void
57154,BLOCK,-1,,"{
                    of->mode = tokens[i].value[1];
                }",24,,1023,1,,void
57183,BLOCK,-1,,"{
                    *errstr = ""CLIENT_ERROR invalid numeric initial value"";
                    of->has_error = 1;
                }",70,,1028,2,,void
57210,BLOCK,-1,,"{
                    *errstr = ""CLIENT_ERROR invalid numeric delta value"";
                    of->has_error = 1;
                }",68,,1034,2,,void
57251,BLOCK,-1,,"{
    char *key;
    size_t nkey;
    item *it;
    unsigned int i = 0;
    struct _meta_flags of = {0}; // option bitflags.
    uint32_t hv; // cached hash value for unlocking an item.
    bool failed = false;
    bool item_created = false;
    bool won_token = false;
    bool ttl_set = false;
    char *errstr = ""CLIENT_ERROR bad command line format"";
    assert(c != NULL);
    mc_resp *resp = c->resp;
    char *p = resp->wbuf;

    WANT_TOKENS_MIN(ntokens, 3);

    // FIXME: do we move this check to after preparse?
    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {
        out_errstring(c, ""CLIENT_ERROR bad command line format"");
        return;
    }

    // NOTE: final token has length == 0.
    // KEY_TOKEN == 1. 0 is command.

    if (ntokens == 3) {
        // TODO: any way to fix this?
        out_errstring(c, ""CLIENT_ERROR bad command line format"");
        return;
    } else if (ntokens > MFLAG_MAX_OPT_LENGTH) {
        // TODO: ensure the command tokenizer gives us at l...",82,,1051,4,,void
57304,BLOCK,1,,<empty>,,,,3,,void
57306,BLOCK,-1,,"WANT_TOKENS_MIN(ntokens, 3)",5,,1067,1,,void
57311,BLOCK,-1,,"WANT_TOKENS_MIN(ntokens, 3)",5,,1067,2,,void
57323,BLOCK,1,,<empty>,,,,1,,void
57327,BLOCK,1,,<empty>,,,,1,,void
57329,BLOCK,-1,,"{
        out_errstring(c, ""CLIENT_ERROR bad command line format"");
        return;
    }",52,,1070,2,,void
57338,BLOCK,-1,,"{
        // TODO: any way to fix this?
        out_errstring(c, ""CLIENT_ERROR bad command line format"");
        return;
    }",23,,1078,2,,void
57344,BLOCK,-1,,<empty>,12,,1082,1,,void
57349,BLOCK,1,,<empty>,,,,1,,void
57351,BLOCK,-1,,"{
        // TODO: ensure the command tokenizer gives us at least this many
        out_errstring(c, ""CLIENT_ERROR options flags are too long"");
        return;
    }",48,,1082,2,,void
57366,BLOCK,-1,,"{
        out_errstring(c, errstr);
        return;
    }",60,,1090,2,,void
57384,BLOCK,1,,<empty>,,,,1,,void
57393,BLOCK,1,,<empty>,,,,1,,void
57405,BLOCK,-1,,"{
        it = limited_get(key, nkey, c, 0, false, !of.no_update, &overflow);
    }",21,,1103,2,,void
57421,BLOCK,-1,,"{
        // If we had to lock the item, we're doing our own bump later.
        it = limited_get_locked(key, nkey, c, DONT_UPDATE, &hv, &overflow);
    }",12,,1105,1,,void
57429,BLOCK,1,,<empty>,,,,1,,void
57437,BLOCK,-1,,"{
        assert(it == NULL);
        out_errstring(c, ""SERVER_ERROR refcount overflow during fetch"");
        return;
    }",19,,1113,2,,void
57454,BLOCK,-1,,"{
        // Fill in the exptime during parsing later.
        it = item_alloc(key, nkey, 0, realtime(0), 2);
        // We don't actually need any of do_store_item's logic:
        // - already fetched and missed an existing item.
        // - lock is still held.
        // - not append/prepend/replace
        // - not testing CAS
        if (it != NULL) {
            // I look forward to the day I get rid of this :)
            memcpy(ITEM_data(it), ""\r\n"", 2);
            // NOTE: This initializes the CAS value.
            do_item_link(it, hv);
            item_created = true;
        }
    }",34,,1119,2,,void
57468,BLOCK,-1,,"{
            // I look forward to the day I get rid of this :)
            memcpy(ITEM_data(it), ""\r\n"", 2);
            // NOTE: This initializes the CAS value.
            do_item_link(it, hv);
            item_created = true;
        }",25,,1127,2,,void
57472,BLOCK,1,,<empty>,,,,6,,void
57515,BLOCK,-1,,"{
        if (of.value) {
            memcpy(p, ""VA "", 3);
            p = itoa_u32(it->nbytes-2, p+3);
        } else {
            if (settings.meta_response_old) {
                memcpy(p, ""OK"", 2);
            } else {
                memcpy(p, ""HD"", 2);
            }
            p += 2;
        }

        for (i = KEY_TOKEN+1; i < ntokens-1; i++) {
            switch (tokens[i].value[0]) {
                case 'T':
                    ttl_set = true;
                    it->exptime = of.exptime;
                    break;
                case 'N':
                    if (item_created) {
                        it->exptime = of.autoviv_exptime;
                        won_token = true;
                    }
                    break;
                case 'R':
                    // If we haven't autovivified and supplied token is less
                    // than current TTL, mark a win.
                    if ((it->it_flags & ITEM_TOKEN_SENT) == 0
                            &&...",13,,1138,2,,void
57520,BLOCK,-1,,"{
            memcpy(p, ""VA "", 3);
            p = itoa_u32(it->nbytes-2, p+3);
        }",23,,1139,2,,void
57537,BLOCK,-1,,"{
            if (settings.meta_response_old) {
                memcpy(p, ""OK"", 2);
            } else {
                memcpy(p, ""HD"", 2);
            }
            p += 2;
        }",16,,1142,1,,void
57542,BLOCK,-1,,"{
                memcpy(p, ""OK"", 2);
            }",45,,1143,2,,void
57548,BLOCK,-1,,"{
                memcpy(p, ""HD"", 2);
            }",20,,1145,1,,void
57557,BLOCK,-1,,<empty>,9,,1151,1,,void
57562,BLOCK,1,,<empty>,,,,1,,void
57572,BLOCK,4,,"{
            switch (tokens[i].value[0]) {
                case 'T':
                    ttl_set = true;
                    it->exptime = of.exptime;
                    break;
                case 'N':
                    if (item_created) {
                        it->exptime = of.autoviv_exptime;
                        won_token = true;
                    }
                    break;
                case 'R':
                    // If we haven't autovivified and supplied token is less
                    // than current TTL, mark a win.
                    if ((it->it_flags & ITEM_TOKEN_SENT) == 0
                            && !item_created
                            && it->exptime != 0
                            && it->exptime < of.recache_time) {
                        won_token = true;
                    }
                    break;
                case 's':
                    META_CHAR(p, 's');
                    p = itoa_u32(it->nbytes-2, p);
                    b...",51,,1151,4,,void
57581,BLOCK,-1,,"{
                case 'T':
                    ttl_set = true;
                    it->exptime = of.exptime;
                    break;
                case 'N':
                    if (item_created) {
                        it->exptime = of.autoviv_exptime;
                        won_token = true;
                    }
                    break;
                case 'R':
                    // If we haven't autovivified and supplied token is less
                    // than current TTL, mark a win.
                    if ((it->it_flags & ITEM_TOKEN_SENT) == 0
                            && !item_created
                            && it->exptime != 0
                            && it->exptime < of.recache_time) {
                        won_token = true;
                    }
                    break;
                case 's':
                    META_CHAR(p, 's');
                    p = itoa_u32(it->nbytes-2, p);
                    break;
                case 't':
          ...",41,,1152,2,,void
57599,BLOCK,-1,,"{
                        it->exptime = of.autoviv_exptime;
                        won_token = true;
                    }",39,,1158,2,,void
57623,BLOCK,1,,<empty>,,,,1,,void
57640,BLOCK,-1,,"{
                        won_token = true;
                    }",63,,1169,2,,void
57650,BLOCK,1,,"META_CHAR(p, 's')",21,,1174,16,,void
57679,BLOCK,1,,"META_CHAR(p, 't')",21,,1180,21,,void
57699,BLOCK,-1,,"{
                        *p = '-';
                        *(p+1) = '1';
                        p += 2;
                    }",43,,1181,2,,void
57714,BLOCK,-1,,"{
                        p = itoa_u32(it->exptime - current_time, p);
                    }",28,,1185,1,,void
57730,BLOCK,1,,"META_CHAR(p, 'c')",21,,1190,26,,void
57749,BLOCK,1,,<empty>,,,,4,,void
57771,BLOCK,1,,"META_CHAR(p, 'f')",21,,1194,31,,void
57789,BLOCK,1,,<empty>,,,,3,,void
57800,BLOCK,-1,,"{
                        *p = '0';
                        p++;
                    }",46,,1195,2,,void
57808,BLOCK,-1,,"{
                        p = itoa_u32(*((uint32_t *) ITEM_suffix(it)), p);
                    }",28,,1198,1,,void
57817,BLOCK,1,,<empty>,,,,5,,void
57847,BLOCK,1,,"META_CHAR(p, 'l')",21,,1203,36,,void
57876,BLOCK,1,,"META_CHAR(p, 'h')",21,,1207,41,,void
57896,BLOCK,1,,<empty>,,,,1,,void
57898,BLOCK,-1,,"{
                        *p = '1';
                    }",54,,1208,2,,void
57904,BLOCK,-1,,"{
                        *p = '0';
                    }",28,,1210,1,,void
57922,BLOCK,1,,<empty>,,,,1,,void
57924,BLOCK,-1,,"{
                        errstr = ""CLIENT_ERROR opaque token too long"";
                        goto error;
                    }",69,,1216,2,,void
57931,BLOCK,1,,META_SPACE(p),21,,1220,48,,void
57965,BLOCK,1,,"META_KEY(p, ITEM_key(it), it->nkey, (it->it_flags & ITEM_KEY_BINARY))",21,,1225,54,,void
57966,BLOCK,1,,"META_KEY(p, ITEM_key(it), it->nkey, (it->it_flags & ITEM_KEY_BINARY))",21,,1225,1,,void
57987,BLOCK,-1,,"META_KEY(p, ITEM_key(it), it->nkey, (it->it_flags & ITEM_KEY_BINARY))",21,,1225,2,,void
58015,BLOCK,-1,,"META_KEY(p, ITEM_key(it), it->nkey, (it->it_flags & ITEM_KEY_BINARY))",21,,1225,1,,void
58066,BLOCK,1,,<empty>,,,,1,,void
58068,BLOCK,-1,,"{
            META_CHAR(p, 'Z');
        }",45,,1233,2,,void
58072,BLOCK,1,,"META_CHAR(p, 'Z')",13,,1234,1,,void
58092,BLOCK,1,,<empty>,,,,1,,void
58094,BLOCK,-1,,"{
            META_CHAR(p, 'X');
            // FIXME: think hard about this. is this a default, or a flag?
            if ((it->it_flags & ITEM_TOKEN_SENT) == 0) {
                // If we're stale but no token already sent, now send one.
                won_token = true;
            }
        }",40,,1236,2,,void
58098,BLOCK,1,,"META_CHAR(p, 'X')",13,,1237,1,,void
58119,BLOCK,1,,<empty>,,,,1,,void
58122,BLOCK,-1,,"{
                // If we're stale but no token already sent, now send one.
                won_token = true;
            }",56,,1239,2,,void
58128,BLOCK,-1,,"{
            // Mark a win into the flag buffer.
            META_CHAR(p, 'W');
            it->it_flags |= ITEM_TOKEN_SENT;
        }",24,,1245,2,,void
58132,BLOCK,1,,"META_CHAR(p, 'W')",13,,1247,1,,void
58151,BLOCK,1,,<empty>,,,,1,,void
58186,BLOCK,-1,,"{
#ifdef EXTSTORE
            if (it->it_flags & ITEM_HDR) {
                if (storage_get_item(c, it, resp) != 0) {
                    pthread_mutex_lock(&c->thread->stats.mutex);
                    c->thread->stats.get_oom_extstore++;
                    pthread_mutex_unlock(&c->thread->stats.mutex);

                    failed = true;
                }
            } else if ((it->it_flags & ITEM_CHUNKED) == 0) {
                resp_add_iov(resp, ITEM_data(it), it->nbytes);
            } else {
                resp_add_chunked_iov(resp, it, it->nbytes);
            }
#else
            if ((it->it_flags & ITEM_CHUNKED) == 0) {
                resp_add_iov(resp, ITEM_data(it), it->nbytes);
            } else {
                resp_add_chunked_iov(resp, it, it->nbytes);
            }
#endif
        }",23,,1258,2,,void
58194,BLOCK,1,,<empty>,,,,1,,void
58197,BLOCK,-1,,"{
                resp_add_iov(resp, ITEM_data(it), it->nbytes);
            }",53,,1274,2,,void
58202,BLOCK,1,,<empty>,,,,6,,void
58239,BLOCK,-1,,"{
                resp_add_chunked_iov(resp, it, it->nbytes);
            }",20,,1276,1,,void
58252,BLOCK,-1,,"{
        failed = true;
    }",12,,1302,1,,void
58260,BLOCK,-1,,"{
        // Delayed bump so we could get fetched/last access time pre-update.
        if (!of.no_update && it != NULL) {
            do_item_bump(c, it, hv);
        }
        item_unlock(hv);
    }",20,,1306,2,,void
58270,BLOCK,-1,,"{
            do_item_bump(c, it, hv);
        }",42,,1308,2,,void
58280,BLOCK,-1,,"{
        pthread_mutex_lock(&c->thread->stats.mutex);
        if (ttl_set) {
            c->thread->stats.touch_cmds++;
            c->thread->stats.slab_stats[ITEM_clsid(it)].touch_hits++;
        } else {
            c->thread->stats.lru_hits[it->slabs_clsid]++;
            c->thread->stats.get_cmds++;
        }
        pthread_mutex_unlock(&c->thread->stats.mutex);

        conn_set_state(c, conn_new_cmd);
    }",18,,1316,2,,void
58292,BLOCK,-1,,"{
            c->thread->stats.touch_cmds++;
            c->thread->stats.slab_stats[ITEM_clsid(it)].touch_hits++;
        }",22,,1318,2,,void
58313,BLOCK,1,,<empty>,,,,3,,void
58324,BLOCK,-1,,"{
            c->thread->stats.lru_hits[it->slabs_clsid]++;
            c->thread->stats.get_cmds++;
        }",16,,1321,1,,void
58358,BLOCK,-1,,"{
        pthread_mutex_lock(&c->thread->stats.mutex);
        if (ttl_set) {
            c->thread->stats.touch_cmds++;
            c->thread->stats.touch_misses++;
        } else {
            c->thread->stats.get_misses++;
            c->thread->stats.get_cmds++;
        }
        MEMCACHED_COMMAND_GET(c->sfd, key, nkey, -1, 0);
        pthread_mutex_unlock(&c->thread->stats.mutex);

        // This gets elided in noreply mode.
        out_string(c, ""EN"");
    }",12,,1328,1,,void
58370,BLOCK,-1,,"{
            c->thread->stats.touch_cmds++;
            c->thread->stats.touch_misses++;
        }",22,,1330,2,,void
58388,BLOCK,-1,,"{
            c->thread->stats.get_misses++;
            c->thread->stats.get_cmds++;
        }",16,,1333,1,,void
58421,BLOCK,-1,,"{
        do_item_remove(it);
        if (of.locked) {
            item_unlock(hv);
        }
    }",13,,1345,2,,void
58428,BLOCK,-1,,"{
            item_unlock(hv);
        }",24,,1347,2,,void
58440,BLOCK,-1,,"{
    char *key;
    size_t nkey;
    item *it;
    int i;
    short comm = NREAD_SET;
    struct _meta_flags of = {0}; // option bitflags.
    char *errstr = ""CLIENT_ERROR bad command line format"";
    uint32_t hv; // cached hash value.
    int vlen = 0; // value from data line.
    assert(c != NULL);
    mc_resp *resp = c->resp;
    char *p = resp->wbuf;

    WANT_TOKENS_MIN(ntokens, 3);

    // TODO: most of this is identical to mget.
    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {
        out_errstring(c, ""CLIENT_ERROR bad command line format"");
        return;
    }

    if (ntokens == 3) {
        out_errstring(c, ""CLIENT_ERROR bad command line format"");
        return;
    }

    if (ntokens > MFLAG_MAX_OPT_LENGTH) {
        out_errstring(c, ""CLIENT_ERROR options flags too long"");
        return;
    }

    // We note tokens into the front of the write buffer, so we can create the
    // final buffer in complete_nread_ascii.
    p = resp->wbuf;

    if (!safe_strtol(toke...",82,,1354,4,,void
58449,BLOCK,1,,<empty>,,,,1,,void
58484,BLOCK,1,,<empty>,,,,3,,void
58486,BLOCK,-1,,"WANT_TOKENS_MIN(ntokens, 3)",5,,1368,1,,void
58491,BLOCK,-1,,"WANT_TOKENS_MIN(ntokens, 3)",5,,1368,2,,void
58503,BLOCK,1,,<empty>,,,,1,,void
58507,BLOCK,1,,<empty>,,,,1,,void
58509,BLOCK,-1,,"{
        out_errstring(c, ""CLIENT_ERROR bad command line format"");
        return;
    }",52,,1371,2,,void
58518,BLOCK,-1,,"{
        out_errstring(c, ""CLIENT_ERROR bad command line format"");
        return;
    }",23,,1376,2,,void
58527,BLOCK,1,,<empty>,,,,1,,void
58529,BLOCK,-1,,"{
        out_errstring(c, ""CLIENT_ERROR options flags too long"");
        return;
    }",41,,1381,2,,void
58547,BLOCK,1,,<empty>,,,,1,,void
58555,BLOCK,-1,,"{
        out_errstring(c, ""CLIENT_ERROR bad command line format"");
        return;
    }",69,,1390,2,,void
58570,BLOCK,-1,,"{
        out_errstring(c, ""CLIENT_ERROR bad command line format"");
        return;
    }",43,,1395,2,,void
58588,BLOCK,-1,,"{
        goto error;
    }",60,,1404,2,,void
58596,BLOCK,1,,<empty>,,,,1,,void
58605,BLOCK,1,,<empty>,,,,1,,void
58625,BLOCK,-1,,<empty>,5,,1417,1,,void
58630,BLOCK,1,,<empty>,,,,1,,void
58640,BLOCK,4,,"{
        switch (tokens[i].value[0]) {
            // TODO: macro perhaps?
            case 'O':
                if (tokens[i].length > MFLAG_MAX_OPAQUE_LENGTH) {
                    errstr = ""CLIENT_ERROR opaque token too long"";
                    has_error = true;
                    break;
                }
                META_SPACE(p);
                memcpy(p, tokens[i].value, tokens[i].length);
                p += tokens[i].length;
                break;
            case 'k':
                META_CHAR(p, 'k');
                break;
            case 'c':
                // need to set the cas value post-assignment.
                META_CHAR(p, 'c');
                break;
        }
    }",47,,1417,4,,void
58649,BLOCK,-1,,"{
            // TODO: macro perhaps?
            case 'O':
                if (tokens[i].length > MFLAG_MAX_OPAQUE_LENGTH) {
                    errstr = ""CLIENT_ERROR opaque token too long"";
                    has_error = true;
                    break;
                }
                META_SPACE(p);
                memcpy(p, tokens[i].value, tokens[i].length);
                p += tokens[i].length;
                break;
            case 'k':
                META_CHAR(p, 'k');
                break;
            case 'c':
                // need to set the cas value post-assignment.
                META_CHAR(p, 'c');
                break;
        }",37,,1418,2,,void
58660,BLOCK,1,,<empty>,,,,1,,void
58662,BLOCK,-1,,"{
                    errstr = ""CLIENT_ERROR opaque token too long"";
                    has_error = true;
                    break;
                }",65,,1421,2,,void
58672,BLOCK,1,,META_SPACE(p),17,,1426,4,,void
58704,BLOCK,1,,"META_CHAR(p, 'k')",17,,1431,10,,void
58724,BLOCK,1,,"META_CHAR(p, 'c')",17,,1435,14,,void
58743,BLOCK,-1,,"{
        case 0:
            break; // no mode supplied.
        case 'E': // Add...
            comm = NREAD_ADD;
            break;
        case 'A': // Append.
            comm = NREAD_APPEND;
            break;
        case 'P': // Prepend.
            comm = NREAD_PREPEND;
            break;
        case 'R': // Replace.
            comm = NREAD_REPLACE;
            break;
        case 'S': // Set. Default.
            comm = NREAD_SET;
            break;
        default:
            errstr = ""CLIENT_ERROR invalid mode for ms M token"";
            goto error;
    }",22,,1441,2,,void
58752,BLOCK,1,,<empty>,,,,1,,void
58760,BLOCK,1,,<empty>,,,,1,,void
58768,BLOCK,1,,<empty>,,,,1,,void
58776,BLOCK,1,,<empty>,,,,1,,void
58784,BLOCK,1,,<empty>,,,,1,,void
58801,BLOCK,1,,<empty>,,,,1,,void
58806,BLOCK,1,,<empty>,,,,1,,void
58808,BLOCK,-1,,"{
        comm = NREAD_CAS;
    }",69,,1469,2,,void
58812,BLOCK,1,,<empty>,,,,1,,void
58816,BLOCK,-1,,<empty>,9,,1476,2,,void
58834,BLOCK,-1,,"{
        enum store_item_type status;
        // TODO: These could be normalized codes (TL and OM). Need to
        // reorganize the output stuff a bit though.
        if (! item_size_ok(nkey, of.client_flags, vlen)) {
            errstr = ""SERVER_ERROR object too large for cache"";
            status = TOO_LARGE;
            pthread_mutex_lock(&c->thread->stats.mutex);
            c->thread->stats.store_too_large++;
            pthread_mutex_unlock(&c->thread->stats.mutex);
        } else {
            errstr = ""SERVER_ERROR out of memory storing object"";
            status = NO_MEMORY;
            pthread_mutex_lock(&c->thread->stats.mutex);
            c->thread->stats.store_no_memory++;
            pthread_mutex_unlock(&c->thread->stats.mutex);
        }
        // FIXME: LOGGER_LOG specific to mset, include options.
        LOGGER_LOG(c->thread->l, LOG_MUTATIONS, LOGGER_ITEM_STORE,
                NULL, status, comm, key, nkey, 0, 0);

        /* Avoid stale data persisting in...",18,,1480,2,,void
58844,BLOCK,-1,,"{
            errstr = ""SERVER_ERROR object too large for cache"";
            status = TOO_LARGE;
            pthread_mutex_lock(&c->thread->stats.mutex);
            c->thread->stats.store_too_large++;
            pthread_mutex_unlock(&c->thread->stats.mutex);
        }",58,,1484,2,,void
58878,BLOCK,-1,,"{
            errstr = ""SERVER_ERROR out of memory storing object"";
            status = NO_MEMORY;
            pthread_mutex_lock(&c->thread->stats.mutex);
            c->thread->stats.store_no_memory++;
            pthread_mutex_unlock(&c->thread->stats.mutex);
        }",16,,1490,1,,void
58919,BLOCK,1,,<empty>,,,,10,,void
58921,BLOCK,-1,,"LOGGER_LOG(c->thread->l, LOG_MUTATIONS, LOGGER_ITEM_STORE,
                NULL, status, comm, key, nkey, 0, 0)",9,,1498,1,,void
58938,BLOCK,-1,,<empty>,9,,1498,2,,void
58953,BLOCK,-1,,<empty>,9,,1498,2,,void
58972,BLOCK,1,,<empty>,,,,1,,void
58978,BLOCK,-1,,"{
            do_item_unlink(it, hv);
            STORAGE_delete(c->thread->storage, it);
            do_item_remove(it);
        }",17,,1504,2,,void
58992,BLOCK,1,,"ITEM_set_cas(it, of.req_cas_id)",5,,1513,40,,void
58999,BLOCK,-1,,"ITEM_set_cas(it, of.req_cas_id)",5,,1513,2,,void
59020,BLOCK,1,,<empty>,,,,6,,void
59069,BLOCK,-1,,"{
        it->it_flags |= ITEM_KEY_BINARY;
    }",24,,1529,2,,void
59075,BLOCK,1,,<empty>,,,,1,,void
59085,BLOCK,1,,<empty>,,,,1,,void
59087,BLOCK,-1,,"{
        c->set_stale = true;
    }",44,,1533,2,,void
59129,BLOCK,-1,,"{
    char *key;
    size_t nkey;
    item *it = NULL;
    int i;
    uint32_t hv;
    struct _meta_flags of = {0}; // option bitflags.
    char *errstr = ""CLIENT_ERROR bad command line format"";
    assert(c != NULL);
    mc_resp *resp = c->resp;
    // reserve 3 bytes for status code
    char *p = resp->wbuf + 3;

    WANT_TOKENS_MIN(ntokens, 3);

    // TODO: most of this is identical to mget.
    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {
        out_string(c, ""CLIENT_ERROR bad command line format"");
        return;
    }

    if (ntokens > MFLAG_MAX_OPT_LENGTH) {
        out_string(c, ""CLIENT_ERROR options flags too long"");
        return;
    }

    // scrubs duplicated options and sets flags for how to load the item.
    // we pass in the first token that should be a flag.
    // FIXME: not using the preparse errstr?
    if (_meta_flag_preparse(tokens, 2, &of, &errstr) != 0) {
        out_errstring(c, ""CLIENT_ERROR invalid or duplicate flag"");
        return;
    }
    a...",85,,1553,4,,void
59168,BLOCK,1,,<empty>,,,,3,,void
59170,BLOCK,-1,,"WANT_TOKENS_MIN(ntokens, 3)",5,,1566,1,,void
59175,BLOCK,-1,,"WANT_TOKENS_MIN(ntokens, 3)",5,,1566,2,,void
59187,BLOCK,1,,<empty>,,,,1,,void
59191,BLOCK,1,,<empty>,,,,1,,void
59193,BLOCK,-1,,"{
        out_string(c, ""CLIENT_ERROR bad command line format"");
        return;
    }",52,,1569,2,,void
59202,BLOCK,1,,<empty>,,,,1,,void
59204,BLOCK,-1,,"{
        out_string(c, ""CLIENT_ERROR options flags too long"");
        return;
    }",41,,1574,2,,void
59219,BLOCK,-1,,"{
        out_errstring(c, ""CLIENT_ERROR invalid or duplicate flag"");
        return;
    }",60,,1582,2,,void
59241,BLOCK,1,,<empty>,,,,1,,void
59250,BLOCK,1,,<empty>,,,,1,,void
59254,BLOCK,-1,,<empty>,5,,1592,1,,void
59259,BLOCK,1,,<empty>,,,,1,,void
59269,BLOCK,4,,"{
        switch (tokens[i].value[0]) {
            // TODO: macro perhaps?
            case 'O':
                if (tokens[i].length > MFLAG_MAX_OPAQUE_LENGTH) {
                    errstr = ""CLIENT_ERROR opaque token too long"";
                    goto error;
                }
                META_SPACE(p);
                memcpy(p, tokens[i].value, tokens[i].length);
                p += tokens[i].length;
                break;
            case 'k':
                META_KEY(p, key, nkey, of.key_binary);
                break;
        }
    }",47,,1592,4,,void
59278,BLOCK,-1,,"{
            // TODO: macro perhaps?
            case 'O':
                if (tokens[i].length > MFLAG_MAX_OPAQUE_LENGTH) {
                    errstr = ""CLIENT_ERROR opaque token too long"";
                    goto error;
                }
                META_SPACE(p);
                memcpy(p, tokens[i].value, tokens[i].length);
                p += tokens[i].length;
                break;
            case 'k':
                META_KEY(p, key, nkey, of.key_binary);
                break;
        }",37,,1593,2,,void
59289,BLOCK,1,,<empty>,,,,1,,void
59291,BLOCK,-1,,"{
                    errstr = ""CLIENT_ERROR opaque token too long"";
                    goto error;
                }",65,,1596,2,,void
59298,BLOCK,1,,META_SPACE(p),17,,1600,4,,void
59334,BLOCK,1,,"META_KEY(p, key, nkey, of.key_binary)",17,,1605,10,,void
59335,BLOCK,1,,"META_KEY(p, key, nkey, of.key_binary)",17,,1605,1,,void
59354,BLOCK,-1,,"META_KEY(p, key, nkey, of.key_binary)",17,,1605,2,,void
59363,BLOCK,-1,,"META_KEY(p, key, nkey, of.key_binary)",17,,1605,1,,void
59398,BLOCK,1,,<empty>,,,,1,,void
59404,BLOCK,-1,,"{
        MEMCACHED_COMMAND_DELETE(c->sfd, ITEM_key(it), it->nkey);

        // allow only deleting/marking if a CAS value matches.
        if (of.has_cas && ITEM_get_cas(it) != of.req_cas_id) {
            pthread_mutex_lock(&c->thread->stats.mutex);
            c->thread->stats.delete_misses++;
            pthread_mutex_unlock(&c->thread->stats.mutex);

            memcpy(resp->wbuf, ""EX "", 3);
            goto cleanup;
        }

        // If we're to set this item as stale, we don't actually want to
        // delete it. We mark the stale bit, bump CAS, and update exptime if
        // we were supplied a new TTL.
        if (of.set_stale) {
            if (of.new_ttl) {
                it->exptime = of.exptime;
            }
            it->it_flags |= ITEM_STALE;
            // Also need to remove TOKEN_SENT, so next client can win.
            it->it_flags &= ~ITEM_TOKEN_SENT;

            ITEM_set_cas(it, (settings.use_cas) ? get_cas_id() : 0);

            // Clients can no...",13,,1611,2,,void
59413,BLOCK,1,,<empty>,,,,4,,void
59431,BLOCK,-1,,"{
            pthread_mutex_lock(&c->thread->stats.mutex);
            c->thread->stats.delete_misses++;
            pthread_mutex_unlock(&c->thread->stats.mutex);

            memcpy(resp->wbuf, ""EX "", 3);
            goto cleanup;
        }",62,,1615,2,,void
59469,BLOCK,-1,,"{
            if (of.new_ttl) {
                it->exptime = of.exptime;
            }
            it->it_flags |= ITEM_STALE;
            // Also need to remove TOKEN_SENT, so next client can win.
            it->it_flags &= ~ITEM_TOKEN_SENT;

            ITEM_set_cas(it, (settings.use_cas) ? get_cas_id() : 0);

            // Clients can noreply nominal responses.
            if (c->noreply)
                resp->skip = true;
            if (settings.meta_response_old) {
                memcpy(resp->wbuf, ""OK "", 3);
            } else {
                memcpy(resp->wbuf, ""HD "", 3);
            }
        }",27,,1627,2,,void
59474,BLOCK,-1,,"{
                it->exptime = of.exptime;
            }",29,,1628,2,,void
59487,BLOCK,1,,<empty>,,,,1,,void
59495,BLOCK,1,,<empty>,,,,1,,void
59499,BLOCK,1,,"ITEM_set_cas(it, (settings.use_cas) ? get_cas_id() : 0)",13,,1635,4,,void
59506,BLOCK,-1,,"ITEM_set_cas(it, (settings.use_cas) ? get_cas_id() : 0)",13,,1635,2,,void
59523,BLOCK,-1,,<empty>,17,,1639,2,,void
59533,BLOCK,-1,,"{
                memcpy(resp->wbuf, ""OK "", 3);
            }",45,,1640,2,,void
59541,BLOCK,-1,,"{
                memcpy(resp->wbuf, ""HD "", 3);
            }",20,,1642,1,,void
59549,BLOCK,-1,,"{
            pthread_mutex_lock(&c->thread->stats.mutex);
            c->thread->stats.slab_stats[ITEM_clsid(it)].delete_hits++;
            pthread_mutex_unlock(&c->thread->stats.mutex);

            do_item_unlink(it, hv);
            STORAGE_delete(c->thread->storage, it);
            if (c->noreply)
                resp->skip = true;
            if (settings.meta_response_old) {
                memcpy(resp->wbuf, ""OK "", 3);
            } else {
                memcpy(resp->wbuf, ""HD "", 3);
            }
        }",16,,1645,1,,void
59571,BLOCK,1,,<empty>,,,,3,,void
59597,BLOCK,-1,,<empty>,17,,1653,2,,void
59607,BLOCK,-1,,"{
                memcpy(resp->wbuf, ""OK "", 3);
            }",45,,1654,2,,void
59615,BLOCK,-1,,"{
                memcpy(resp->wbuf, ""HD "", 3);
            }",20,,1656,1,,void
59624,BLOCK,-1,,"{
        pthread_mutex_lock(&c->thread->stats.mutex);
        c->thread->stats.delete_misses++;
        pthread_mutex_unlock(&c->thread->stats.mutex);

        memcpy(resp->wbuf, ""NF "", 3);
        goto cleanup;
    }",12,,1661,1,,void
59661,BLOCK,-1,,"{
        do_item_remove(it);
    }",13,,1670,2,,void
59712,BLOCK,-1,,"{
    char *key;
    size_t nkey;
    int i;
    struct _meta_flags of = {0}; // option bitflags.
    char *errstr = ""CLIENT_ERROR bad command line format"";
    assert(c != NULL);
    mc_resp *resp = c->resp;
    // no reservation (like del/set) since we post-process the status line.
    char *p = resp->wbuf;

    // If no argument supplied, incr or decr by one.
    of.delta = 1;
    of.initial = 0; // redundant, for clarity.
    bool incr = true; // default mode is to increment.
    bool locked = false;
    uint32_t hv = 0;
    item *it = NULL; // item returned by do_add_delta.

    WANT_TOKENS_MIN(ntokens, 3);

    // TODO: most of this is identical to mget.
    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {
        out_string(c, ""CLIENT_ERROR bad command line format"");
        return;
    }

    if (ntokens > MFLAG_MAX_OPT_LENGTH) {
        out_string(c, ""CLIENT_ERROR options flags too long"");
        return;
    }

    // scrubs duplicated options and sets flags for how to loa...",89,,1685,4,,void
59770,BLOCK,1,,<empty>,,,,3,,void
59772,BLOCK,-1,,"WANT_TOKENS_MIN(ntokens, 3)",5,,1704,1,,void
59777,BLOCK,-1,,"WANT_TOKENS_MIN(ntokens, 3)",5,,1704,2,,void
59789,BLOCK,1,,<empty>,,,,1,,void
59793,BLOCK,1,,<empty>,,,,1,,void
59795,BLOCK,-1,,"{
        out_string(c, ""CLIENT_ERROR bad command line format"");
        return;
    }",52,,1707,2,,void
59804,BLOCK,1,,<empty>,,,,1,,void
59806,BLOCK,-1,,"{
        out_string(c, ""CLIENT_ERROR options flags too long"");
        return;
    }",41,,1712,2,,void
59821,BLOCK,-1,,"{
        out_errstring(c, ""CLIENT_ERROR invalid or duplicate flag"");
        return;
    }",60,,1719,2,,void
59843,BLOCK,1,,<empty>,,,,1,,void
59852,BLOCK,1,,<empty>,,,,1,,void
59859,BLOCK,-1,,"{
        case 0: // no switch supplied.
            break;
        case 'I': // Incr (default)
        case '+':
            incr = true;
            break;
        case 'D': // Decr.
        case '-':
            incr = false;
            break;
        default:
            errstr = ""CLIENT_ERROR invalid mode for ma M token"";
            goto error;
            break;
    }",22,,1730,2,,void
59917,BLOCK,-1,,"{
    case OK:
        if (c->noreply)
            resp->skip = true;
        if (settings.meta_response_old) {
            memcpy(resp->wbuf, ""OK "", 3);
        } else {
            memcpy(resp->wbuf, ""HD "", 3);
        }
        break;
    case NON_NUMERIC:
        errstr = ""CLIENT_ERROR cannot increment or decrement non-numeric value"";
        goto error;
        break;
    case EOM:
        errstr = ""SERVER_ERROR out of memory"";
        goto error;
        break;
    case DELTA_ITEM_NOT_FOUND:
        if (of.vivify) {
            itoa_u64(of.initial, tmpbuf);
            int vlen = strlen(tmpbuf);

            it = item_alloc(key, nkey, 0, 0, vlen+2);
            if (it != NULL) {
                memcpy(ITEM_data(it), tmpbuf, vlen);
                memcpy(ITEM_data(it) + vlen, ""\r\n"", 2);
                if (do_store_item(it, NREAD_ADD, c, hv)) {
                    item_created = true;
                } else {
                    // Not sure how we can get here if we're holding...",89,,1757,2,,void
59924,BLOCK,-1,,<empty>,13,,1760,2,,void
59934,BLOCK,-1,,"{
            memcpy(resp->wbuf, ""OK "", 3);
        }",41,,1761,2,,void
59942,BLOCK,-1,,"{
            memcpy(resp->wbuf, ""HD "", 3);
        }",16,,1763,1,,void
59970,BLOCK,-1,,"{
            itoa_u64(of.initial, tmpbuf);
            int vlen = strlen(tmpbuf);

            it = item_alloc(key, nkey, 0, 0, vlen+2);
            if (it != NULL) {
                memcpy(ITEM_data(it), tmpbuf, vlen);
                memcpy(ITEM_data(it) + vlen, ""\r\n"", 2);
                if (do_store_item(it, NREAD_ADD, c, hv)) {
                    item_created = true;
                } else {
                    // Not sure how we can get here if we're holding the lock.
                    memcpy(resp->wbuf, ""NS "", 3);
                }
            } else {
                errstr = ""SERVER_ERROR Out of memory allocating new item"";
                goto error;
            }
        }",24,,1776,2,,void
59995,BLOCK,-1,,"{
                memcpy(ITEM_data(it), tmpbuf, vlen);
                memcpy(ITEM_data(it) + vlen, ""\r\n"", 2);
                if (do_store_item(it, NREAD_ADD, c, hv)) {
                    item_created = true;
                } else {
                    // Not sure how we can get here if we're holding the lock.
                    memcpy(resp->wbuf, ""NS "", 3);
                }
            }",29,,1781,2,,void
59999,BLOCK,1,,<empty>,,,,6,,void
60038,BLOCK,1,,<empty>,,,,6,,void
60078,BLOCK,1,,<empty>,,,,1,,void
60082,BLOCK,-1,,"{
                    item_created = true;
                }",58,,1784,2,,void
60087,BLOCK,-1,,"{
                    // Not sure how we can get here if we're holding the lock.
                    memcpy(resp->wbuf, ""NS "", 3);
                }",24,,1786,1,,void
60095,BLOCK,-1,,"{
                errstr = ""SERVER_ERROR Out of memory allocating new item"";
                goto error;
            }",20,,1790,1,,void
60101,BLOCK,-1,,"{
            pthread_mutex_lock(&c->thread->stats.mutex);
            if (incr) {
                c->thread->stats.incr_misses++;
            } else {
                c->thread->stats.decr_misses++;
            }
            pthread_mutex_unlock(&c->thread->stats.mutex);
            // won't have a valid it here.
            memcpy(p, ""NF "", 3);
            p += 3;
        }",16,,1794,1,,void
60113,BLOCK,-1,,"{
                c->thread->stats.incr_misses++;
            }",23,,1796,2,,void
60123,BLOCK,-1,,"{
                c->thread->stats.decr_misses++;
            }",20,,1798,1,,void
60161,BLOCK,-1,,"{
        size_t vlen = strlen(tmpbuf);
        if (of.value) {
            memcpy(p, ""VA "", 3);
            p = itoa_u32(vlen, p+3);
        } else {
            if (settings.meta_response_old) {
                memcpy(p, ""OK"", 2);
            } else {
                memcpy(p, ""HD"", 2);
            }
            p += 2;
        }

        for (i = KEY_TOKEN+1; i < ntokens-1; i++) {
            switch (tokens[i].value[0]) {
                case 'c':
                    META_CHAR(p, 'c');
                    p = itoa_u64(ITEM_get_cas(it), p);
                    break;
                case 't':
                    META_CHAR(p, 't');
                    if (it->exptime == 0) {
                        *p = '-';
                        *(p+1) = '1';
                        p += 2;
                    } else {
                        p = itoa_u32(it->exptime - current_time, p);
                    }
                    break;
                case 'T':
                    it->exptime = o...",13,,1817,2,,void
60171,BLOCK,-1,,"{
            memcpy(p, ""VA "", 3);
            p = itoa_u32(vlen, p+3);
        }",23,,1819,2,,void
60184,BLOCK,-1,,"{
            if (settings.meta_response_old) {
                memcpy(p, ""OK"", 2);
            } else {
                memcpy(p, ""HD"", 2);
            }
            p += 2;
        }",16,,1822,1,,void
60189,BLOCK,-1,,"{
                memcpy(p, ""OK"", 2);
            }",45,,1823,2,,void
60195,BLOCK,-1,,"{
                memcpy(p, ""HD"", 2);
            }",20,,1825,1,,void
60204,BLOCK,-1,,<empty>,9,,1831,1,,void
60209,BLOCK,1,,<empty>,,,,1,,void
60219,BLOCK,4,,"{
            switch (tokens[i].value[0]) {
                case 'c':
                    META_CHAR(p, 'c');
                    p = itoa_u64(ITEM_get_cas(it), p);
                    break;
                case 't':
                    META_CHAR(p, 't');
                    if (it->exptime == 0) {
                        *p = '-';
                        *(p+1) = '1';
                        p += 2;
                    } else {
                        p = itoa_u32(it->exptime - current_time, p);
                    }
                    break;
                case 'T':
                    it->exptime = of.exptime;
                    break;
                case 'N':
                    if (item_created) {
                        it->exptime = of.autoviv_exptime;
                    }
                    break;
                // TODO: macro perhaps?
                case 'O':
                    if (tokens[i].length > MFLAG_MAX_OPAQUE_LENGTH) {
                        errstr = ""CLIE...",51,,1831,4,,void
60228,BLOCK,-1,,"{
                case 'c':
                    META_CHAR(p, 'c');
                    p = itoa_u64(ITEM_get_cas(it), p);
                    break;
                case 't':
                    META_CHAR(p, 't');
                    if (it->exptime == 0) {
                        *p = '-';
                        *(p+1) = '1';
                        p += 2;
                    } else {
                        p = itoa_u32(it->exptime - current_time, p);
                    }
                    break;
                case 'T':
                    it->exptime = of.exptime;
                    break;
                case 'N':
                    if (item_created) {
                        it->exptime = of.autoviv_exptime;
                    }
                    break;
                // TODO: macro perhaps?
                case 'O':
                    if (tokens[i].length > MFLAG_MAX_OPAQUE_LENGTH) {
                        errstr = ""CLIENT_ERROR opaque token too long"";
         ...",41,,1832,2,,void
60234,BLOCK,1,,"META_CHAR(p, 'c')",21,,1834,3,,void
60253,BLOCK,1,,<empty>,,,,4,,void
60275,BLOCK,1,,"META_CHAR(p, 't')",21,,1838,8,,void
60295,BLOCK,-1,,"{
                        *p = '-';
                        *(p+1) = '1';
                        p += 2;
                    }",43,,1839,2,,void
60310,BLOCK,-1,,"{
                        p = itoa_u32(it->exptime - current_time, p);
                    }",28,,1843,1,,void
60335,BLOCK,-1,,"{
                        it->exptime = of.autoviv_exptime;
                    }",39,,1851,2,,void
60354,BLOCK,1,,<empty>,,,,1,,void
60356,BLOCK,-1,,"{
                        errstr = ""CLIENT_ERROR opaque token too long"";
                        goto error;
                    }",69,,1857,2,,void
60363,BLOCK,1,,META_SPACE(p),21,,1861,22,,void
60399,BLOCK,1,,"META_KEY(p, key, nkey, of.key_binary)",21,,1866,28,,void
60400,BLOCK,1,,"META_KEY(p, key, nkey, of.key_binary)",21,,1866,1,,void
60419,BLOCK,-1,,"META_KEY(p, key, nkey, of.key_binary)",21,,1866,2,,void
60428,BLOCK,-1,,"META_KEY(p, key, nkey, of.key_binary)",21,,1866,1,,void
60460,BLOCK,-1,,"{
            *p = '\r';
            *(p+1) = '\n';
            p += 2;
            memcpy(p, tmpbuf, vlen);
            p += vlen;
        }",23,,1871,2,,void
60484,BLOCK,-1,,"{
        // No item to handle. still need to return opaque/key tokens
        for (i = KEY_TOKEN+1; i < ntokens-1; i++) {
            switch (tokens[i].value[0]) {
                // TODO: macro perhaps?
                case 'O':
                    if (tokens[i].length > MFLAG_MAX_OPAQUE_LENGTH) {
                        errstr = ""CLIENT_ERROR opaque token too long"";
                        goto error;
                    }
                    META_SPACE(p);
                    memcpy(p, tokens[i].value, tokens[i].length);
                    p += tokens[i].length;
                    break;
                case 'k':
                    META_KEY(p, key, nkey, of.key_binary);
                    break;
            }
        }
    }",12,,1880,1,,void
60486,BLOCK,-1,,<empty>,9,,1882,1,,void
60491,BLOCK,1,,<empty>,,,,1,,void
60501,BLOCK,4,,"{
            switch (tokens[i].value[0]) {
                // TODO: macro perhaps?
                case 'O':
                    if (tokens[i].length > MFLAG_MAX_OPAQUE_LENGTH) {
                        errstr = ""CLIENT_ERROR opaque token too long"";
                        goto error;
                    }
                    META_SPACE(p);
                    memcpy(p, tokens[i].value, tokens[i].length);
                    p += tokens[i].length;
                    break;
                case 'k':
                    META_KEY(p, key, nkey, of.key_binary);
                    break;
            }
        }",51,,1882,4,,void
60510,BLOCK,-1,,"{
                // TODO: macro perhaps?
                case 'O':
                    if (tokens[i].length > MFLAG_MAX_OPAQUE_LENGTH) {
                        errstr = ""CLIENT_ERROR opaque token too long"";
                        goto error;
                    }
                    META_SPACE(p);
                    memcpy(p, tokens[i].value, tokens[i].length);
                    p += tokens[i].length;
                    break;
                case 'k':
                    META_KEY(p, key, nkey, of.key_binary);
                    break;
            }",41,,1883,2,,void
60521,BLOCK,1,,<empty>,,,,1,,void
60523,BLOCK,-1,,"{
                        errstr = ""CLIENT_ERROR opaque token too long"";
                        goto error;
                    }",69,,1886,2,,void
60530,BLOCK,1,,META_SPACE(p),21,,1890,4,,void
60566,BLOCK,1,,"META_KEY(p, key, nkey, of.key_binary)",21,,1895,10,,void
60567,BLOCK,1,,"META_KEY(p, key, nkey, of.key_binary)",21,,1895,1,,void
60586,BLOCK,-1,,"META_KEY(p, key, nkey, of.key_binary)",21,,1895,2,,void
60595,BLOCK,-1,,"META_KEY(p, key, nkey, of.key_binary)",21,,1895,1,,void
60666,BLOCK,-1,,<empty>,9,,1911,2,,void
60671,BLOCK,-1,,<empty>,9,,1913,2,,void
60685,BLOCK,-1,,"{
    char *key;
    size_t nkey;
    unsigned int flags;
    int32_t exptime_int = 0;
    rel_time_t exptime = 0;
    int vlen;
    uint64_t req_cas_id=0;
    item *it;

    assert(c != NULL);

    set_noreply_maybe(c, tokens, ntokens);

    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {
        out_string(c, ""CLIENT_ERROR bad command line format"");
        return;
    }

    key = tokens[KEY_TOKEN].value;
    nkey = tokens[KEY_TOKEN].length;

    if (! (safe_strtoul(tokens[2].value, (uint32_t *)&flags)
           && safe_strtol(tokens[3].value, &exptime_int)
           && safe_strtol(tokens[4].value, (int32_t *)&vlen))) {
        out_string(c, ""CLIENT_ERROR bad command line format"");
        return;
    }

    exptime = realtime(EXPTIME_TO_POSITIVE_TIME(exptime_int));

    // does cas value exist?
    if (handle_cas) {
        if (!safe_strtoull(tokens[5].value, &req_cas_id)) {
            out_string(c, ""CLIENT_ERROR bad command line format"");
            return;
        }
    }...",111,,1918,6,,void
60717,BLOCK,1,,<empty>,,,,1,,void
60721,BLOCK,1,,<empty>,,,,1,,void
60723,BLOCK,-1,,"{
        out_string(c, ""CLIENT_ERROR bad command line format"");
        return;
    }",52,,1932,2,,void
60734,BLOCK,1,,<empty>,,,,1,,void
60743,BLOCK,1,,<empty>,,,,1,,void
60778,BLOCK,-1,,"{
        out_string(c, ""CLIENT_ERROR bad command line format"");
        return;
    }",64,,1942,2,,void
60788,BLOCK,1,,<empty>,,,,4,,void
60805,BLOCK,-1,,"{
        if (!safe_strtoull(tokens[5].value, &req_cas_id)) {
            out_string(c, ""CLIENT_ERROR bad command line format"");
            return;
        }
    }",21,,1950,2,,void
60816,BLOCK,-1,,"{
            out_string(c, ""CLIENT_ERROR bad command line format"");
            return;
        }",59,,1951,2,,void
60831,BLOCK,-1,,"{
        out_string(c, ""CLIENT_ERROR bad command line format"");
        return;
    }",43,,1957,2,,void
60843,BLOCK,-1,,"{
        stats_prefix_record_set(key, nkey);
    }",34,,1963,2,,void
60859,BLOCK,-1,,"{
        enum store_item_type status;
        if (! item_size_ok(nkey, flags, vlen)) {
            out_string(c, ""SERVER_ERROR object too large for cache"");
            status = TOO_LARGE;
            pthread_mutex_lock(&c->thread->stats.mutex);
            c->thread->stats.store_too_large++;
            pthread_mutex_unlock(&c->thread->stats.mutex);
        } else {
            out_of_memory(c, ""SERVER_ERROR out of memory storing object"");
            status = NO_MEMORY;
            pthread_mutex_lock(&c->thread->stats.mutex);
            c->thread->stats.store_no_memory++;
            pthread_mutex_unlock(&c->thread->stats.mutex);
        }
        LOGGER_LOG(c->thread->l, LOG_MUTATIONS, LOGGER_ITEM_STORE,
                NULL, status, comm, key, nkey, 0, 0, c->sfd);
        /* swallow the data line */
        conn_set_state(c, conn_swallow);
        c->sbytes = vlen;

        /* Avoid stale data persisting in cache because we failed alloc.
         * Unacceptable for SET. Anywhe...",18,,1969,2,,void
60867,BLOCK,-1,,"{
            out_string(c, ""SERVER_ERROR object too large for cache"");
            status = TOO_LARGE;
            pthread_mutex_lock(&c->thread->stats.mutex);
            c->thread->stats.store_too_large++;
            pthread_mutex_unlock(&c->thread->stats.mutex);
        }",48,,1971,2,,void
60901,BLOCK,-1,,"{
            out_of_memory(c, ""SERVER_ERROR out of memory storing object"");
            status = NO_MEMORY;
            pthread_mutex_lock(&c->thread->stats.mutex);
            c->thread->stats.store_no_memory++;
            pthread_mutex_unlock(&c->thread->stats.mutex);
        }",16,,1977,1,,void
60942,BLOCK,1,,<empty>,,,,9,,void
60944,BLOCK,-1,,"LOGGER_LOG(c->thread->l, LOG_MUTATIONS, LOGGER_ITEM_STORE,
                NULL, status, comm, key, nkey, 0, 0, c->sfd)",9,,1984,1,,void
60961,BLOCK,-1,,<empty>,9,,1984,2,,void
60976,BLOCK,-1,,<empty>,9,,1984,2,,void
61003,BLOCK,1,,<empty>,,,,1,,void
61005,BLOCK,-1,,"{
            it = item_get(key, nkey, c, DONT_UPDATE);
            if (it) {
                item_unlink(it);
                STORAGE_delete(c->thread->storage, it);
                item_remove(it);
            }
        }",32,,1992,2,,void
61013,BLOCK,1,,<empty>,,,,1,,void
61017,BLOCK,-1,,"{
                item_unlink(it);
                STORAGE_delete(c->thread->storage, it);
                item_remove(it);
            }",21,,1994,2,,void
61026,BLOCK,1,,"ITEM_set_cas(it, req_cas_id)",5,,2003,25,,void
61033,BLOCK,-1,,"ITEM_set_cas(it, req_cas_id)",5,,2003,2,,void
61052,BLOCK,1,,<empty>,,,,6,,void
61106,BLOCK,-1,,"{
    char *key;
    size_t nkey;
    int32_t exptime_int = 0;
    rel_time_t exptime = 0;
    item *it;

    assert(c != NULL);

    set_noreply_maybe(c, tokens, ntokens);

    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {
        out_string(c, ""CLIENT_ERROR bad command line format"");
        return;
    }

    key = tokens[KEY_TOKEN].value;
    nkey = tokens[KEY_TOKEN].length;

    if (!safe_strtol(tokens[2].value, &exptime_int)) {
        out_string(c, ""CLIENT_ERROR invalid exptime argument"");
        return;
    }

    exptime = realtime(EXPTIME_TO_POSITIVE_TIME(exptime_int));
    it = item_touch(key, nkey, exptime, c);
    if (it) {
        pthread_mutex_lock(&c->thread->stats.mutex);
        c->thread->stats.touch_cmds++;
        c->thread->stats.slab_stats[ITEM_clsid(it)].touch_hits++;
        pthread_mutex_unlock(&c->thread->stats.mutex);

        out_string(c, ""TOUCHED"");
        item_remove(it);
    } else {
        pthread_mutex_lock(&c->thread->stats.mutex);
        c...",83,,2020,4,,void
61132,BLOCK,1,,<empty>,,,,1,,void
61136,BLOCK,1,,<empty>,,,,1,,void
61138,BLOCK,-1,,"{
        out_string(c, ""CLIENT_ERROR bad command line format"");
        return;
    }",52,,2031,2,,void
61149,BLOCK,1,,<empty>,,,,1,,void
61158,BLOCK,1,,<empty>,,,,1,,void
61171,BLOCK,-1,,"{
        out_string(c, ""CLIENT_ERROR invalid exptime argument"");
        return;
    }",54,,2039,2,,void
61181,BLOCK,1,,<empty>,,,,4,,void
61205,BLOCK,-1,,"{
        pthread_mutex_lock(&c->thread->stats.mutex);
        c->thread->stats.touch_cmds++;
        c->thread->stats.slab_stats[ITEM_clsid(it)].touch_hits++;
        pthread_mutex_unlock(&c->thread->stats.mutex);

        out_string(c, ""TOUCHED"");
        item_remove(it);
    }",13,,2046,2,,void
61235,BLOCK,1,,<empty>,,,,3,,void
61260,BLOCK,-1,,"{
        pthread_mutex_lock(&c->thread->stats.mutex);
        c->thread->stats.touch_cmds++;
        c->thread->stats.touch_misses++;
        pthread_mutex_unlock(&c->thread->stats.mutex);

        out_string(c, ""NOT_FOUND"");
    }",12,,2054,1,,void
61305,BLOCK,-1,,"{
    char temp[INCR_MAX_STORAGE_LEN];
    uint64_t delta;
    char *key;
    size_t nkey;

    assert(c != NULL);

    set_noreply_maybe(c, tokens, ntokens);

    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {
        out_string(c, ""CLIENT_ERROR bad command line format"");
        return;
    }

    key = tokens[KEY_TOKEN].value;
    nkey = tokens[KEY_TOKEN].length;

    if (!safe_strtoull(tokens[2].value, &delta)) {
        out_string(c, ""CLIENT_ERROR invalid numeric delta argument"");
        return;
    }

    switch(add_delta(c, key, nkey, incr, delta, temp, NULL)) {
    case OK:
        out_string(c, temp);
        break;
    case NON_NUMERIC:
        out_string(c, ""CLIENT_ERROR cannot increment or decrement non-numeric value"");
        break;
    case EOM:
        out_of_memory(c, ""SERVER_ERROR out of memory"");
        break;
    case DELTA_ITEM_NOT_FOUND:
        pthread_mutex_lock(&c->thread->stats.mutex);
        if (incr) {
            c->thread->stats.incr_misses++;
    ...",105,,2064,5,,void
61324,BLOCK,1,,<empty>,,,,1,,void
61328,BLOCK,1,,<empty>,,,,1,,void
61330,BLOCK,-1,,"{
        out_string(c, ""CLIENT_ERROR bad command line format"");
        return;
    }",52,,2074,2,,void
61341,BLOCK,1,,<empty>,,,,1,,void
61350,BLOCK,1,,<empty>,,,,1,,void
61363,BLOCK,-1,,"{
        out_string(c, ""CLIENT_ERROR invalid numeric delta argument"");
        return;
    }",50,,2082,2,,void
61377,BLOCK,-1,,"{
    case OK:
        out_string(c, temp);
        break;
    case NON_NUMERIC:
        out_string(c, ""CLIENT_ERROR cannot increment or decrement non-numeric value"");
        break;
    case EOM:
        out_of_memory(c, ""SERVER_ERROR out of memory"");
        break;
    case DELTA_ITEM_NOT_FOUND:
        pthread_mutex_lock(&c->thread->stats.mutex);
        if (incr) {
            c->thread->stats.incr_misses++;
        } else {
            c->thread->stats.decr_misses++;
        }
        pthread_mutex_unlock(&c->thread->stats.mutex);

        out_string(c, ""NOT_FOUND"");
        break;
    case DELTA_ITEM_CAS_MISMATCH:
        break; /* Should never get here */
    }",62,,2087,2,,void
61409,BLOCK,-1,,"{
            c->thread->stats.incr_misses++;
        }",19,,2099,2,,void
61419,BLOCK,-1,,"{
            c->thread->stats.decr_misses++;
        }",16,,2101,1,,void
61450,BLOCK,-1,,"{
    char *key;
    size_t nkey;
    item *it;
    uint32_t hv;

    assert(c != NULL);

    if (ntokens > 3) {
        bool hold_is_zero = strcmp(tokens[KEY_TOKEN+1].value, ""0"") == 0;
        bool sets_noreply = set_noreply_maybe(c, tokens, ntokens);
        bool valid = (ntokens == 4 && (hold_is_zero || sets_noreply))
            || (ntokens == 5 && hold_is_zero && sets_noreply);
        if (!valid) {
            out_string(c, ""CLIENT_ERROR bad command line format.  ""
                       ""Usage: delete <key> [noreply]"");
            return;
        }
    }


    key = tokens[KEY_TOKEN].value;
    nkey = tokens[KEY_TOKEN].length;

    if(nkey > KEY_MAX_LENGTH) {
        out_string(c, ""CLIENT_ERROR bad command line format"");
        return;
    }

    if (settings.detail_enabled) {
        stats_prefix_record_delete(key, nkey);
    }

    it = item_get_locked(key, nkey, c, DONT_UPDATE, &hv);
    if (it) {
        MEMCACHED_COMMAND_DELETE(c->sfd, ITEM_key(it), it->nkey);

       ...",84,,2114,4,,void
61463,BLOCK,-1,,"{
        bool hold_is_zero = strcmp(tokens[KEY_TOKEN+1].value, ""0"") == 0;
        bool sets_noreply = set_noreply_maybe(c, tokens, ntokens);
        bool valid = (ntokens == 4 && (hold_is_zero || sets_noreply))
            || (ntokens == 5 && hold_is_zero && sets_noreply);
        if (!valid) {
            out_string(c, ""CLIENT_ERROR bad command line format.  ""
                       ""Usage: delete <key> [noreply]"");
            return;
        }
    }",22,,2122,2,,void
61474,BLOCK,1,,<empty>,,,,1,,void
61508,BLOCK,-1,,"{
            out_string(c, ""CLIENT_ERROR bad command line format.  ""
                       ""Usage: delete <key> [noreply]"");
            return;
        }",21,,2127,2,,void
61519,BLOCK,1,,<empty>,,,,1,,void
61528,BLOCK,1,,<empty>,,,,1,,void
61535,BLOCK,1,,<empty>,,,,1,,void
61537,BLOCK,-1,,"{
        out_string(c, ""CLIENT_ERROR bad command line format"");
        return;
    }",31,,2138,2,,void
61546,BLOCK,-1,,"{
        stats_prefix_record_delete(key, nkey);
    }",34,,2143,2,,void
61557,BLOCK,1,,<empty>,,,,1,,void
61563,BLOCK,-1,,"{
        MEMCACHED_COMMAND_DELETE(c->sfd, ITEM_key(it), it->nkey);

        pthread_mutex_lock(&c->thread->stats.mutex);
        c->thread->stats.slab_stats[ITEM_clsid(it)].delete_hits++;
        pthread_mutex_unlock(&c->thread->stats.mutex);

        do_item_unlink(it, hv);
        STORAGE_delete(c->thread->storage, it);
        do_item_remove(it);      /* release our reference */
        out_string(c, ""DELETED"");
    }",13,,2148,2,,void
61585,BLOCK,1,,<empty>,,,,3,,void
61613,BLOCK,-1,,"{
        pthread_mutex_lock(&c->thread->stats.mutex);
        c->thread->stats.delete_misses++;
        pthread_mutex_unlock(&c->thread->stats.mutex);

        out_string(c, ""NOT_FOUND"");
    }",12,,2159,1,,void
61651,BLOCK,-1,,"{
    unsigned int level;

    assert(c != NULL);

    set_noreply_maybe(c, tokens, ntokens);

    if (!safe_strtoul(tokens[1].value, (uint32_t*)&level)) {
        out_string(c, ""CLIENT_ERROR bad command line format"");
        return;
    }
    settings.verbose = level > MAX_VERBOSITY_LEVEL ? MAX_VERBOSITY_LEVEL : level;
    out_string(c, ""OK"");
    return;
}",87,,2169,4,,void
61673,BLOCK,-1,,"{
        out_string(c, ""CLIENT_ERROR bad command line format"");
        return;
    }",60,,2176,2,,void
61686,BLOCK,1,,<empty>,,,,1,,void
61689,BLOCK,1,,<empty>,,,,1,,void
61702,BLOCK,-1,,"{
    unsigned int level;
    double ratio;

    assert(c != NULL);

    set_noreply_maybe(c, tokens, ntokens);

    if (strcmp(tokens[2].value, ""ratio"") == 0) {
        if (ntokens < 5 || !safe_strtod(tokens[3].value, &ratio)) {
            out_string(c, ""ERROR"");
            return;
        }
        settings.slab_automove_ratio = ratio;
    } else {
        if (!safe_strtoul(tokens[2].value, (uint32_t*)&level)) {
            out_string(c, ""CLIENT_ERROR bad command line format"");
            return;
        }
        if (level == 0) {
            settings.slab_automove = 0;
        } else if (level == 1 || level == 2) {
            settings.slab_automove = level;
        } else {
            out_string(c, ""ERROR"");
            return;
        }
    }
    out_string(c, ""OK"");
    return;
}",92,,2231,4,,void
61723,BLOCK,-1,,"{
        if (ntokens < 5 || !safe_strtod(tokens[3].value, &ratio)) {
            out_string(c, ""ERROR"");
            return;
        }
        settings.slab_automove_ratio = ratio;
    }",48,,2239,2,,void
61738,BLOCK,-1,,"{
            out_string(c, ""ERROR"");
            return;
        }",67,,2240,2,,void
61749,BLOCK,-1,,"{
        if (!safe_strtoul(tokens[2].value, (uint32_t*)&level)) {
            out_string(c, ""CLIENT_ERROR bad command line format"");
            return;
        }
        if (level == 0) {
            settings.slab_automove = 0;
        } else if (level == 1 || level == 2) {
            settings.slab_automove = level;
        } else {
            out_string(c, ""ERROR"");
            return;
        }
    }",12,,2245,1,,void
61762,BLOCK,-1,,"{
            out_string(c, ""CLIENT_ERROR bad command line format"");
            return;
        }",64,,2246,2,,void
61771,BLOCK,-1,,"{
            settings.slab_automove = 0;
        }",25,,2250,2,,void
61778,BLOCK,-1,,<empty>,16,,2252,1,,void
61787,BLOCK,-1,,"{
            settings.slab_automove = level;
        }",46,,2252,2,,void
61794,BLOCK,-1,,"{
            out_string(c, ""ERROR"");
            return;
        }",16,,2254,1,,void
61809,BLOCK,-1,,"{
    uint16_t f = 0;
    int x;
    assert(c != NULL);

    set_noreply_maybe(c, tokens, ntokens);
    if (!settings.watch_enabled) {
        out_string(c, ""CLIENT_ERROR watch commands not allowed"");
        return;
    }

    if (resp_has_stack(c)) {
        out_string(c, ""ERROR cannot pipeline other commands before watch"");
        return;
    }

    if (ntokens > 2) {
        for (x = COMMAND_TOKEN + 1; x < ntokens - 1; x++) {
            if ((strcmp(tokens[x].value, ""rawcmds"") == 0)) {
                f |= LOG_RAWCMDS;
            } else if ((strcmp(tokens[x].value, ""evictions"") == 0)) {
                f |= LOG_EVICTIONS;
            } else if ((strcmp(tokens[x].value, ""fetchers"") == 0)) {
                f |= LOG_FETCHERS;
            } else if ((strcmp(tokens[x].value, ""mutations"") == 0)) {
                f |= LOG_MUTATIONS;
            } else if ((strcmp(tokens[x].value, ""sysevents"") == 0)) {
                f |= LOG_SYSEVENTS;
            } else if ((strcmp(tokens[x].valu...",83,,2264,4,,void
61828,BLOCK,-1,,"{
        out_string(c, ""CLIENT_ERROR watch commands not allowed"");
        return;
    }",34,,2270,2,,void
61836,BLOCK,-1,,"{
        out_string(c, ""ERROR cannot pipeline other commands before watch"");
        return;
    }",28,,2275,2,,void
61845,BLOCK,-1,,"{
        for (x = COMMAND_TOKEN + 1; x < ntokens - 1; x++) {
            if ((strcmp(tokens[x].value, ""rawcmds"") == 0)) {
                f |= LOG_RAWCMDS;
            } else if ((strcmp(tokens[x].value, ""evictions"") == 0)) {
                f |= LOG_EVICTIONS;
            } else if ((strcmp(tokens[x].value, ""fetchers"") == 0)) {
                f |= LOG_FETCHERS;
            } else if ((strcmp(tokens[x].value, ""mutations"") == 0)) {
                f |= LOG_MUTATIONS;
            } else if ((strcmp(tokens[x].value, ""sysevents"") == 0)) {
                f |= LOG_SYSEVENTS;
            } else if ((strcmp(tokens[x].value, ""connevents"") == 0)) {
                f |= LOG_CONNEVENTS;
            } else if ((strcmp(tokens[x].value, ""proxyreqs"") == 0)) {
                f |= LOG_PROXYREQS;
            } else if ((strcmp(tokens[x].value, ""proxyevents"") == 0)) {
                f |= LOG_PROXYEVENTS;
            } else if ((strcmp(tokens[x].value, ""proxyuser"") == 0)) {
                f |= LOG...",22,,2280,2,,void
61847,BLOCK,-1,,<empty>,9,,2281,1,,void
61852,BLOCK,1,,<empty>,,,,1,,void
61862,BLOCK,4,,"{
            if ((strcmp(tokens[x].value, ""rawcmds"") == 0)) {
                f |= LOG_RAWCMDS;
            } else if ((strcmp(tokens[x].value, ""evictions"") == 0)) {
                f |= LOG_EVICTIONS;
            } else if ((strcmp(tokens[x].value, ""fetchers"") == 0)) {
                f |= LOG_FETCHERS;
            } else if ((strcmp(tokens[x].value, ""mutations"") == 0)) {
                f |= LOG_MUTATIONS;
            } else if ((strcmp(tokens[x].value, ""sysevents"") == 0)) {
                f |= LOG_SYSEVENTS;
            } else if ((strcmp(tokens[x].value, ""connevents"") == 0)) {
                f |= LOG_CONNEVENTS;
            } else if ((strcmp(tokens[x].value, ""proxyreqs"") == 0)) {
                f |= LOG_PROXYREQS;
            } else if ((strcmp(tokens[x].value, ""proxyevents"") == 0)) {
                f |= LOG_PROXYEVENTS;
            } else if ((strcmp(tokens[x].value, ""proxyuser"") == 0)) {
                f |= LOG_PROXYUSER;
            } else {
                out_string(...",59,,2281,4,,void
61873,BLOCK,-1,,"{
                f |= LOG_RAWCMDS;
            }",60,,2282,2,,void
61877,BLOCK,1,,<empty>,,,,1,,void
61882,BLOCK,-1,,<empty>,20,,2284,1,,void
61893,BLOCK,-1,,"{
                f |= LOG_EVICTIONS;
            }",69,,2284,2,,void
61897,BLOCK,1,,<empty>,,,,1,,void
61902,BLOCK,-1,,<empty>,20,,2286,1,,void
61913,BLOCK,-1,,"{
                f |= LOG_FETCHERS;
            }",68,,2286,2,,void
61917,BLOCK,1,,<empty>,,,,1,,void
61922,BLOCK,-1,,<empty>,20,,2288,1,,void
61933,BLOCK,-1,,"{
                f |= LOG_MUTATIONS;
            }",69,,2288,2,,void
61937,BLOCK,1,,<empty>,,,,1,,void
61942,BLOCK,-1,,<empty>,20,,2290,1,,void
61953,BLOCK,-1,,"{
                f |= LOG_SYSEVENTS;
            }",69,,2290,2,,void
61957,BLOCK,1,,<empty>,,,,1,,void
61962,BLOCK,-1,,<empty>,20,,2292,1,,void
61973,BLOCK,-1,,"{
                f |= LOG_CONNEVENTS;
            }",70,,2292,2,,void
61977,BLOCK,1,,<empty>,,,,1,,void
61982,BLOCK,-1,,<empty>,20,,2294,1,,void
61993,BLOCK,-1,,"{
                f |= LOG_PROXYREQS;
            }",69,,2294,2,,void
61997,BLOCK,1,,<empty>,,,,1,,void
62002,BLOCK,-1,,<empty>,20,,2296,1,,void
62013,BLOCK,-1,,"{
                f |= LOG_PROXYEVENTS;
            }",71,,2296,2,,void
62017,BLOCK,1,,<empty>,,,,1,,void
62022,BLOCK,-1,,<empty>,20,,2298,1,,void
62033,BLOCK,-1,,"{
                f |= LOG_PROXYUSER;
            }",69,,2298,2,,void
62037,BLOCK,1,,<empty>,,,,1,,void
62042,BLOCK,-1,,"{
                out_string(c, ""ERROR"");
                return;
            }",20,,2300,1,,void
62048,BLOCK,-1,,"{
        f |= LOG_FETCHERS;
    }",12,,2305,1,,void
62052,BLOCK,1,,<empty>,,,,1,,void
62063,BLOCK,-1,,"{
        case LOGGER_ADD_WATCHER_TOO_MANY:
            out_string(c, ""WATCHER_TOO_MANY log watcher limit reached"");
            break;
        case LOGGER_ADD_WATCHER_FAILED:
            out_string(c, ""WATCHER_FAILED failed to add log watcher"");
            break;
        case LOGGER_ADD_WATCHER_OK:
            conn_set_state(c, conn_watch);
            event_del(&c->event);
            break;
    }",46,,2309,2,,void
62093,BLOCK,-1,,"{
    uint32_t memlimit;
    assert(c != NULL);

    set_noreply_maybe(c, tokens, ntokens);

    if (!safe_strtoul(tokens[1].value, &memlimit)) {
        out_string(c, ""ERROR"");
    } else {
        if (memlimit < 8) {
            out_string(c, ""MEMLIMIT_TOO_SMALL cannot set maxbytes to less than 8m"");
        } else {
            if (memlimit > 1000000000) {
                out_string(c, ""MEMLIMIT_ADJUST_FAILED input value is megabytes not bytes"");
            } else if (slabs_adjust_mem_limit((size_t) memlimit * 1024 * 1024)) {
                if (settings.verbose > 0) {
                    fprintf(stderr, ""maxbytes adjusted to %llum\n"", (unsigned long long)memlimit);
                }

                out_string(c, ""OK"");
            } else {
                out_string(c, ""MEMLIMIT_ADJUST_FAILED out of bounds or unable to adjust"");
            }
        }
    }
}",86,,2323,4,,void
62113,BLOCK,-1,,"{
        out_string(c, ""ERROR"");
    }",52,,2329,2,,void
62118,BLOCK,-1,,"{
        if (memlimit < 8) {
            out_string(c, ""MEMLIMIT_TOO_SMALL cannot set maxbytes to less than 8m"");
        } else {
            if (memlimit > 1000000000) {
                out_string(c, ""MEMLIMIT_ADJUST_FAILED input value is megabytes not bytes"");
            } else if (slabs_adjust_mem_limit((size_t) memlimit * 1024 * 1024)) {
                if (settings.verbose > 0) {
                    fprintf(stderr, ""maxbytes adjusted to %llum\n"", (unsigned long long)memlimit);
                }

                out_string(c, ""OK"");
            } else {
                out_string(c, ""MEMLIMIT_ADJUST_FAILED out of bounds or unable to adjust"");
            }
        }
    }",12,,2331,1,,void
62123,BLOCK,-1,,"{
            out_string(c, ""MEMLIMIT_TOO_SMALL cannot set maxbytes to less than 8m"");
        }",27,,2332,2,,void
62128,BLOCK,-1,,"{
            if (memlimit > 1000000000) {
                out_string(c, ""MEMLIMIT_ADJUST_FAILED input value is megabytes not bytes"");
            } else if (slabs_adjust_mem_limit((size_t) memlimit * 1024 * 1024)) {
                if (settings.verbose > 0) {
                    fprintf(stderr, ""maxbytes adjusted to %llum\n"", (unsigned long long)memlimit);
                }

                out_string(c, ""OK"");
            } else {
                out_string(c, ""MEMLIMIT_ADJUST_FAILED out of bounds or unable to adjust"");
            }
        }",16,,2334,1,,void
62133,BLOCK,-1,,"{
                out_string(c, ""MEMLIMIT_ADJUST_FAILED input value is megabytes not bytes"");
            }",40,,2335,2,,void
62138,BLOCK,-1,,<empty>,20,,2337,1,,void
62148,BLOCK,-1,,"{
                if (settings.verbose > 0) {
                    fprintf(stderr, ""maxbytes adjusted to %llum\n"", (unsigned long long)memlimit);
                }

                out_string(c, ""OK"");
            }",81,,2337,2,,void
62155,BLOCK,-1,,"{
                    fprintf(stderr, ""maxbytes adjusted to %llum\n"", (unsigned long long)memlimit);
                }",43,,2338,2,,void
62166,BLOCK,-1,,"{
                out_string(c, ""MEMLIMIT_ADJUST_FAILED out of bounds or unable to adjust"");
            }",20,,2343,1,,void
62176,BLOCK,-1,,"{
    uint32_t pct_hot;
    uint32_t pct_warm;
    double hot_factor;
    int32_t ttl;
    double factor;

    set_noreply_maybe(c, tokens, ntokens);

    if (strcmp(tokens[1].value, ""tune"") == 0 && ntokens >= 7) {
        if (!safe_strtoul(tokens[2].value, &pct_hot) ||
            !safe_strtoul(tokens[3].value, &pct_warm) ||
            !safe_strtod(tokens[4].value, &hot_factor) ||
            !safe_strtod(tokens[5].value, &factor)) {
            out_string(c, ""ERROR"");
        } else {
            if (pct_hot + pct_warm > 80) {
                out_string(c, ""ERROR hot and warm pcts must not exceed 80"");
            } else if (factor <= 0 || hot_factor <= 0) {
                out_string(c, ""ERROR hot/warm age factors must be greater than 0"");
            } else {
                settings.hot_lru_pct = pct_hot;
                settings.warm_lru_pct = pct_warm;
                settings.hot_max_factor = hot_factor;
                settings.warm_max_factor = factor;
                out...",81,,2350,4,,void
62200,BLOCK,-1,,"{
        if (!safe_strtoul(tokens[2].value, &pct_hot) ||
            !safe_strtoul(tokens[3].value, &pct_warm) ||
            !safe_strtod(tokens[4].value, &hot_factor) ||
            !safe_strtod(tokens[5].value, &factor)) {
            out_string(c, ""ERROR"");
        } else {
            if (pct_hot + pct_warm > 80) {
                out_string(c, ""ERROR hot and warm pcts must not exceed 80"");
            } else if (factor <= 0 || hot_factor <= 0) {
                out_string(c, ""ERROR hot/warm age factors must be greater than 0"");
            } else {
                settings.hot_lru_pct = pct_hot;
                settings.warm_lru_pct = pct_warm;
                settings.hot_max_factor = hot_factor;
                settings.warm_max_factor = factor;
                out_string(c, ""OK"");
            }
        }
    }",63,,2359,2,,void
62241,BLOCK,-1,,"{
            out_string(c, ""ERROR"");
        }",53,,2363,2,,void
62246,BLOCK,-1,,"{
            if (pct_hot + pct_warm > 80) {
                out_string(c, ""ERROR hot and warm pcts must not exceed 80"");
            } else if (factor <= 0 || hot_factor <= 0) {
                out_string(c, ""ERROR hot/warm age factors must be greater than 0"");
            } else {
                settings.hot_lru_pct = pct_hot;
                settings.warm_lru_pct = pct_warm;
                settings.hot_max_factor = hot_factor;
                settings.warm_max_factor = factor;
                out_string(c, ""OK"");
            }
        }",16,,2365,1,,void
62253,BLOCK,-1,,"{
                out_string(c, ""ERROR hot and warm pcts must not exceed 80"");
            }",42,,2366,2,,void
62258,BLOCK,-1,,<empty>,20,,2368,1,,void
62267,BLOCK,-1,,"{
                out_string(c, ""ERROR hot/warm age factors must be greater than 0"");
            }",56,,2368,2,,void
62272,BLOCK,-1,,"{
                settings.hot_lru_pct = pct_hot;
                settings.warm_lru_pct = pct_warm;
                settings.hot_max_factor = hot_factor;
                settings.warm_max_factor = factor;
                out_string(c, ""OK"");
            }",20,,2370,1,,void
62297,BLOCK,-1,,<empty>,12,,2378,1,,void
62316,BLOCK,-1,,"{
        if (strcmp(tokens[2].value, ""flat"") == 0) {
            settings.lru_segmented = false;
            out_string(c, ""OK"");
        } else if (strcmp(tokens[2].value, ""segmented"") == 0) {
            settings.lru_segmented = true;
            out_string(c, ""OK"");
        } else {
            out_string(c, ""ERROR"");
        }
    }",48,,2379,2,,void
62327,BLOCK,-1,,"{
            settings.lru_segmented = false;
            out_string(c, ""OK"");
        }",51,,2380,2,,void
62337,BLOCK,-1,,<empty>,16,,2383,1,,void
62348,BLOCK,-1,,"{
            settings.lru_segmented = true;
            out_string(c, ""OK"");
        }",63,,2383,2,,void
62358,BLOCK,-1,,"{
            out_string(c, ""ERROR"");
        }",16,,2386,1,,void
62363,BLOCK,-1,,<empty>,12,,2389,1,,void
62382,BLOCK,-1,,"{
        if (!safe_strtol(tokens[2].value, &ttl)) {
            out_string(c, ""ERROR"");
        } else {
            if (ttl < 0) {
                settings.temp_lru = false;
            } else {
                settings.temp_lru = true;
                settings.temporary_ttl = ttl;
            }
            out_string(c, ""OK"");
        }
    }",48,,2390,2,,void
62393,BLOCK,-1,,"{
            out_string(c, ""ERROR"");
        }",50,,2391,2,,void
62398,BLOCK,-1,,"{
            if (ttl < 0) {
                settings.temp_lru = false;
            } else {
                settings.temp_lru = true;
                settings.temporary_ttl = ttl;
            }
            out_string(c, ""OK"");
        }",16,,2393,1,,void
62403,BLOCK,-1,,"{
                settings.temp_lru = false;
            }",26,,2394,2,,void
62410,BLOCK,-1,,"{
                settings.temp_lru = true;
                settings.temporary_ttl = ttl;
            }",20,,2396,1,,void
62425,BLOCK,-1,,"{
        out_string(c, ""ERROR"");
    }",12,,2402,1,,void
62435,BLOCK,-1,,"{
    int32_t exptime = 0;
    rel_time_t new_oldest = 0;

    set_noreply_maybe(c, tokens, ntokens);

    pthread_mutex_lock(&c->thread->stats.mutex);
    c->thread->stats.flush_cmds++;
    pthread_mutex_unlock(&c->thread->stats.mutex);

    if (!settings.flush_enabled) {
        // flush_all is not allowed but we log it on stats
        out_string(c, ""CLIENT_ERROR flush_all not allowed"");
        return;
    }

    if (ntokens != (c->noreply ? 3 : 2)) {
        if (!safe_strtol(tokens[1].value, &exptime)) {
            out_string(c, ""CLIENT_ERROR invalid exptime argument"");
            return;
        }
    }

    /*
      If exptime is zero realtime() would return zero too, and
      realtime(exptime) - 1 would overflow to the max unsigned
      value.  So we process exptime == 0 the same way we do when
      no delay is given at all.
    */
    if (exptime > 0) {
        new_oldest = realtime(exptime);
    } else { /* exptime == 0 */
        new_oldest = current_time;
    }

   ...",87,,2467,4,,void
62479,BLOCK,-1,,"{
        // flush_all is not allowed but we log it on stats
        out_string(c, ""CLIENT_ERROR flush_all not allowed"");
        return;
    }",34,,2477,2,,void
62493,BLOCK,-1,,"{
        if (!safe_strtol(tokens[1].value, &exptime)) {
            out_string(c, ""CLIENT_ERROR invalid exptime argument"");
            return;
        }
    }",42,,2483,2,,void
62504,BLOCK,-1,,"{
            out_string(c, ""CLIENT_ERROR invalid exptime argument"");
            return;
        }",54,,2484,2,,void
62513,BLOCK,-1,,"{
        new_oldest = realtime(exptime);
    }",22,,2496,2,,void
62519,BLOCK,-1,,"{ /* exptime == 0 */
        new_oldest = current_time;
    }",12,,2498,1,,void
62527,BLOCK,-1,,"{
        settings.oldest_live = new_oldest - 1;
        if (settings.oldest_live <= current_time)
            settings.oldest_cas = get_cas_id();
    }",27,,2502,2,,void
62541,BLOCK,-1,,<empty>,13,,2505,2,,void
62548,BLOCK,-1,,"{
        settings.oldest_live = new_oldest;
    }",12,,2506,1,,void
62561,BLOCK,-1,,"{
    out_string(c, ""VERSION "" VERSION);
}",46,,2512,2,,void
62567,BLOCK,-1,,"{
    conn_set_state(c, conn_mwrite);
    c->close_after_write = true;
    c->close_reason = NORMAL_CLOSE;
}",43,,2516,2,,void
62587,BLOCK,-1,,"{
    if (!settings.shutdown_command) {
        out_string(c, ""ERROR: shutdown not enabled"");
        return;
    }

    if (ntokens == 2) {
        c->close_reason = SHUTDOWN_CLOSE;
        conn_set_state(c, conn_closing);
        raise(SIGINT);
    } else if (ntokens == 3 && strcmp(tokens[SUBCOMMAND_TOKEN].value, ""graceful"") == 0) {
        c->close_reason = SHUTDOWN_CLOSE;
        conn_set_state(c, conn_closing);
        raise(SIGUSR1);
    } else {
        out_string(c, ""CLIENT_ERROR invalid shutdown mode"");
    }
}",86,,2522,4,,void
62593,BLOCK,-1,,"{
        out_string(c, ""ERROR: shutdown not enabled"");
        return;
    }",37,,2523,2,,void
62602,BLOCK,-1,,"{
        c->close_reason = SHUTDOWN_CLOSE;
        conn_set_state(c, conn_closing);
        raise(SIGINT);
    }",23,,2528,2,,void
62614,BLOCK,-1,,<empty>,12,,2532,1,,void
62626,BLOCK,1,,<empty>,,,,1,,void
62631,BLOCK,-1,,"{
        c->close_reason = SHUTDOWN_CLOSE;
        conn_set_state(c, conn_closing);
        raise(SIGUSR1);
    }",89,,2532,2,,void
62643,BLOCK,-1,,"{
        out_string(c, ""CLIENT_ERROR invalid shutdown mode"");
    }",12,,2536,1,,void
62653,BLOCK,-1,,"{
    if (ntokens == 5 && strcmp(tokens[COMMAND_TOKEN + 1].value, ""reassign"") == 0) {
        int src, dst, rv;

        if (settings.slab_reassign == false) {
            out_string(c, ""CLIENT_ERROR slab reassignment disabled"");
            return;
        }

        if (! (safe_strtol(tokens[2].value, (int32_t*)&src)
               && safe_strtol(tokens[3].value, (int32_t*)&dst))) {
            out_string(c, ""CLIENT_ERROR bad command line format"");
            return;
        }

        rv = slabs_reassign(src, dst);
        switch (rv) {
        case REASSIGN_OK:
            out_string(c, ""OK"");
            break;
        case REASSIGN_RUNNING:
            out_string(c, ""BUSY currently processing reassign request"");
            break;
        case REASSIGN_BADCLASS:
            out_string(c, ""BADCLASS invalid src or dst class id"");
            break;
        case REASSIGN_NOSPARE:
            out_string(c, ""NOSPARE source class has no spare pages"");
            break;
        cas...",83,,2541,4,,void
62666,BLOCK,1,,<empty>,,,,1,,void
62672,BLOCK,-1,,"{
        int src, dst, rv;

        if (settings.slab_reassign == false) {
            out_string(c, ""CLIENT_ERROR slab reassignment disabled"");
            return;
        }

        if (! (safe_strtol(tokens[2].value, (int32_t*)&src)
               && safe_strtol(tokens[3].value, (int32_t*)&dst))) {
            out_string(c, ""CLIENT_ERROR bad command line format"");
            return;
        }

        rv = slabs_reassign(src, dst);
        switch (rv) {
        case REASSIGN_OK:
            out_string(c, ""OK"");
            break;
        case REASSIGN_RUNNING:
            out_string(c, ""BUSY currently processing reassign request"");
            break;
        case REASSIGN_BADCLASS:
            out_string(c, ""BADCLASS invalid src or dst class id"");
            break;
        case REASSIGN_NOSPARE:
            out_string(c, ""NOSPARE source class has no spare pages"");
            break;
        case REASSIGN_SRC_DST_SAME:
            out_string(c, ""SAME src and dst class are ident...",83,,2542,2,,void
62682,BLOCK,-1,,"{
            out_string(c, ""CLIENT_ERROR slab reassignment disabled"");
            return;
        }",46,,2545,2,,void
62710,BLOCK,-1,,"{
            out_string(c, ""CLIENT_ERROR bad command line format"");
            return;
        }",66,,2551,2,,void
62722,BLOCK,-1,,"{
        case REASSIGN_OK:
            out_string(c, ""OK"");
            break;
        case REASSIGN_RUNNING:
            out_string(c, ""BUSY currently processing reassign request"");
            break;
        case REASSIGN_BADCLASS:
            out_string(c, ""BADCLASS invalid src or dst class id"");
            break;
        case REASSIGN_NOSPARE:
            out_string(c, ""NOSPARE source class has no spare pages"");
            break;
        case REASSIGN_SRC_DST_SAME:
            out_string(c, ""SAME src and dst class are identical"");
            break;
        }",21,,2557,2,,void
62755,BLOCK,-1,,<empty>,12,,2575,1,,void
62768,BLOCK,1,,<empty>,,,,1,,void
62774,BLOCK,-1,,"{
        process_slabs_automove_command(c, tokens, ntokens);
    }",69,,2576,2,,void
62780,BLOCK,-1,,"{
        out_string(c, ""ERROR"");
    }",12,,2578,1,,void
62790,BLOCK,-1,,"{
    if (ntokens == 4 && strcmp(tokens[COMMAND_TOKEN + 1].value, ""crawl"") == 0) {
        int rv;
        if (settings.lru_crawler == false) {
            out_string(c, ""CLIENT_ERROR lru crawler disabled"");
            return;
        }

        rv = lru_crawler_crawl(tokens[2].value, CRAWLER_EXPIRED, NULL, 0,
                settings.lru_crawler_tocrawl);
        switch(rv) {
        case CRAWLER_OK:
            out_string(c, ""OK"");
            break;
        case CRAWLER_RUNNING:
            out_string(c, ""BUSY currently processing crawler request"");
            break;
        case CRAWLER_BADCLASS:
            out_string(c, ""BADCLASS invalid class id"");
            break;
        case CRAWLER_NOTSTARTED:
            out_string(c, ""NOTSTARTED no items to crawl"");
            break;
        case CRAWLER_ERROR:
            out_string(c, ""ERROR an unknown error happened"");
            break;
        }
        return;
    } else if (ntokens == 4 && strcmp(tokens[COMMAND_TOKEN + 1].va...",89,,2583,4,,void
62803,BLOCK,1,,<empty>,,,,1,,void
62809,BLOCK,-1,,"{
        int rv;
        if (settings.lru_crawler == false) {
            out_string(c, ""CLIENT_ERROR lru crawler disabled"");
            return;
        }

        rv = lru_crawler_crawl(tokens[2].value, CRAWLER_EXPIRED, NULL, 0,
                settings.lru_crawler_tocrawl);
        switch(rv) {
        case CRAWLER_OK:
            out_string(c, ""OK"");
            break;
        case CRAWLER_RUNNING:
            out_string(c, ""BUSY currently processing crawler request"");
            break;
        case CRAWLER_BADCLASS:
            out_string(c, ""BADCLASS invalid class id"");
            break;
        case CRAWLER_NOTSTARTED:
            out_string(c, ""NOTSTARTED no items to crawl"");
            break;
        case CRAWLER_ERROR:
            out_string(c, ""ERROR an unknown error happened"");
            break;
        }
        return;
    }",80,,2584,2,,void
62817,BLOCK,-1,,"{
            out_string(c, ""CLIENT_ERROR lru crawler disabled"");
            return;
        }",44,,2586,2,,void
62838,BLOCK,-1,,"{
        case CRAWLER_OK:
            out_string(c, ""OK"");
            break;
        case CRAWLER_RUNNING:
            out_string(c, ""BUSY currently processing crawler request"");
            break;
        case CRAWLER_BADCLASS:
            out_string(c, ""BADCLASS invalid class id"");
            break;
        case CRAWLER_NOTSTARTED:
            out_string(c, ""NOTSTARTED no items to crawl"");
            break;
        case CRAWLER_ERROR:
            out_string(c, ""ERROR an unknown error happened"");
            break;
        }",20,,2593,2,,void
62871,BLOCK,-1,,<empty>,12,,2611,1,,void
62884,BLOCK,1,,<empty>,,,,1,,void
62890,BLOCK,-1,,"{
        if (settings.lru_crawler == false) {
            out_string(c, ""CLIENT_ERROR lru crawler disabled"");
            return;
        }
        if (!settings.dump_enabled) {
            out_string(c, ""ERROR metadump not allowed"");
            return;
        }
        if (resp_has_stack(c)) {
            out_string(c, ""ERROR cannot pipeline other commands before metadump"");
            return;
        }

        int rv = lru_crawler_crawl(tokens[2].value, CRAWLER_METADUMP,
                c, c->sfd, LRU_CRAWLER_CAP_REMAINING);
        switch(rv) {
            case CRAWLER_OK:
                // TODO: documentation says this string is returned, but
                // it never was before. We never switch to conn_write so
                // this o_s call never worked. Need to talk to users and
                // decide if removing the OK from docs is fine.
                //out_string(c, ""OK"");
                // TODO: Don't reuse conn_watch here.
                conn_set_state(c,...",90,,2611,2,,void
62897,BLOCK,-1,,"{
            out_string(c, ""CLIENT_ERROR lru crawler disabled"");
            return;
        }",44,,2612,2,,void
62907,BLOCK,-1,,"{
            out_string(c, ""ERROR metadump not allowed"");
            return;
        }",37,,2616,2,,void
62915,BLOCK,-1,,"{
            out_string(c, ""ERROR cannot pipeline other commands before metadump"");
            return;
        }",32,,2620,2,,void
62935,BLOCK,1,,<empty>,,,,1,,void
62940,BLOCK,-1,,"{
            case CRAWLER_OK:
                // TODO: documentation says this string is returned, but
                // it never was before. We never switch to conn_write so
                // this o_s call never worked. Need to talk to users and
                // decide if removing the OK from docs is fine.
                //out_string(c, ""OK"");
                // TODO: Don't reuse conn_watch here.
                conn_set_state(c, conn_watch);
                event_del(&c->event);
                break;
            case CRAWLER_RUNNING:
                out_string(c, ""BUSY currently processing crawler request"");
                break;
            case CRAWLER_BADCLASS:
                out_string(c, ""BADCLASS invalid class id"");
                break;
            case CRAWLER_NOTSTARTED:
                out_string(c, ""NOTSTARTED no items to crawl"");
                break;
            case CRAWLER_ERROR:
                out_string(c, ""ERROR an unknown error happened"");
          ...",20,,2627,2,,void
62978,BLOCK,-1,,<empty>,12,,2652,1,,void
62991,BLOCK,1,,<empty>,,,,1,,void
62997,BLOCK,-1,,"{
        uint32_t tocrawl;
         if (!safe_strtoul(tokens[2].value, &tocrawl)) {
            out_string(c, ""CLIENT_ERROR bad command line format"");
            return;
        }
        settings.lru_crawler_tocrawl = tocrawl;
        out_string(c, ""OK"");
        return;
    }",89,,2652,2,,void
63009,BLOCK,-1,,"{
            out_string(c, ""CLIENT_ERROR bad command line format"");
            return;
        }",56,,2654,2,,void
63024,BLOCK,-1,,<empty>,12,,2661,1,,void
63037,BLOCK,1,,<empty>,,,,1,,void
63043,BLOCK,-1,,"{
        uint32_t tosleep;
        if (!safe_strtoul(tokens[2].value, &tosleep)) {
            out_string(c, ""CLIENT_ERROR bad command line format"");
            return;
        }
        if (tosleep > 1000000) {
            out_string(c, ""CLIENT_ERROR sleep must be one second or less"");
            return;
        }
        settings.lru_crawler_sleep = tosleep;
        out_string(c, ""OK"");
        return;
    }",87,,2661,2,,void
63055,BLOCK,-1,,"{
            out_string(c, ""CLIENT_ERROR bad command line format"");
            return;
        }",55,,2663,2,,void
63064,BLOCK,-1,,"{
            out_string(c, ""CLIENT_ERROR sleep must be one second or less"");
            return;
        }",32,,2667,2,,void
63079,BLOCK,-1,,<empty>,12,,2674,1,,void
63084,BLOCK,-1,,"{
        if ((strcmp(tokens[COMMAND_TOKEN + 1].value, ""enable"") == 0)) {
            if (start_item_crawler_thread() == 0) {
                out_string(c, ""OK"");
            } else {
                out_string(c, ""ERROR failed to start lru crawler thread"");
            }
        } else if ((strcmp(tokens[COMMAND_TOKEN + 1].value, ""disable"") == 0)) {
            if (stop_item_crawler_thread(CRAWLER_NOWAIT) == 0) {
                out_string(c, ""OK"");
            } else {
                out_string(c, ""ERROR failed to stop lru crawler thread"");
            }
        } else {
            out_string(c, ""ERROR"");
        }
        return;
    }",30,,2674,2,,void
63093,BLOCK,1,,<empty>,,,,1,,void
63099,BLOCK,-1,,"{
            if (start_item_crawler_thread() == 0) {
                out_string(c, ""OK"");
            } else {
                out_string(c, ""ERROR failed to start lru crawler thread"");
            }
        }",71,,2675,2,,void
63104,BLOCK,-1,,"{
                out_string(c, ""OK"");
            }",51,,2676,2,,void
63109,BLOCK,-1,,"{
                out_string(c, ""ERROR failed to start lru crawler thread"");
            }",20,,2678,1,,void
63114,BLOCK,-1,,<empty>,16,,2681,1,,void
63123,BLOCK,1,,<empty>,,,,1,,void
63129,BLOCK,-1,,"{
            if (stop_item_crawler_thread(CRAWLER_NOWAIT) == 0) {
                out_string(c, ""OK"");
            } else {
                out_string(c, ""ERROR failed to stop lru crawler thread"");
            }
        }",79,,2681,2,,void
63134,BLOCK,1,,<empty>,,,,1,,void
63137,BLOCK,-1,,"{
                out_string(c, ""OK"");
            }",64,,2682,2,,void
63142,BLOCK,-1,,"{
                out_string(c, ""ERROR failed to stop lru crawler thread"");
            }",20,,2684,1,,void
63147,BLOCK,-1,,"{
            out_string(c, ""ERROR"");
        }",16,,2687,1,,void
63153,BLOCK,-1,,"{
        out_string(c, ""ERROR"");
    }",12,,2691,1,,void
63162,BLOCK,-1,,"{

    token_t tokens[MAX_TOKENS];
    size_t ntokens;
    int comm;

    assert(c != NULL);

    MEMCACHED_PROCESS_COMMAND_START(c->sfd, c->rcurr, c->rbytes);

    if (settings.verbose > 1)
        fprintf(stderr, ""<%d %s\n"", c->sfd, command);

    /*
     * for commands set/add/replace, we build an item and read the data
     * directly into it, then continue in nread_complete().
     */

    // Prep the response object for this query.
    if (!resp_start(c)) {
        conn_set_state(c, conn_closing);
        return;
    }

    ntokens = tokenize_command(command, tokens, MAX_TOKENS);
    // All commands need a minimum of two tokens: cmd and NULL finalizer
    // There are also no valid commands shorter than two bytes.
    if (ntokens < 2 || tokens[COMMAND_TOKEN].length < 2) {
        out_string(c, ""ERROR"");
        return;
    }

    // Meta commands are all 2-char in length.
    char first = tokens[COMMAND_TOKEN].value[0];
    if (first == 'm' && tokens[COMMAND_TOKEN].length == 2...",52,,2716,3,,void
63176,BLOCK,-1,,<empty>,9,,2727,2,,void
63188,BLOCK,-1,,"{
        conn_set_state(c, conn_closing);
        return;
    }",25,,2735,2,,void
63199,BLOCK,1,,<empty>,,,,1,,void
63211,BLOCK,1,,<empty>,,,,1,,void
63215,BLOCK,-1,,"{
        out_string(c, ""ERROR"");
        return;
    }",58,,2743,2,,void
63228,BLOCK,1,,<empty>,,,,1,,void
63242,BLOCK,1,,<empty>,,,,1,,void
63246,BLOCK,-1,,"{
        switch (tokens[COMMAND_TOKEN].value[1]) {
            case 'g':
                process_mget_command(c, tokens, ntokens);
                break;
            case 's':
                process_mset_command(c, tokens, ntokens);
                break;
            case 'd':
                process_mdelete_command(c, tokens, ntokens);
                break;
            case 'n':
                out_string(c, ""MN"");
                // mn command forces immediate writeback flush.
                conn_set_state(c, conn_mwrite);
                break;
            case 'a':
                process_marithmetic_command(c, tokens, ntokens);
                break;
            case 'e':
                process_meta_command(c, tokens, ntokens);
                break;
            default:
                out_string(c, ""ERROR"");
                break;
        }
    }",60,,2750,2,,void
63253,BLOCK,1,,<empty>,,,,1,,void
63257,BLOCK,-1,,"{
            case 'g':
                process_mget_command(c, tokens, ntokens);
                break;
            case 's':
                process_mset_command(c, tokens, ntokens);
                break;
            case 'd':
                process_mdelete_command(c, tokens, ntokens);
                break;
            case 'n':
                out_string(c, ""MN"");
                // mn command forces immediate writeback flush.
                conn_set_state(c, conn_mwrite);
                break;
            case 'a':
                process_marithmetic_command(c, tokens, ntokens);
                break;
            case 'e':
                process_meta_command(c, tokens, ntokens);
                break;
            default:
                out_string(c, ""ERROR"");
                break;
        }",49,,2751,2,,void
63308,BLOCK,-1,,<empty>,12,,2776,1,,void
63313,BLOCK,-1,,"{
        // Various get commands are very common.
        WANT_TOKENS_MIN(ntokens, 3);
        if (strcmp(tokens[COMMAND_TOKEN].value, ""get"") == 0) {

            process_get_command(c, tokens, ntokens, false, false);
        } else if (strcmp(tokens[COMMAND_TOKEN].value, ""gets"") == 0) {

            process_get_command(c, tokens, ntokens, true, false);
        } else if (strcmp(tokens[COMMAND_TOKEN].value, ""gat"") == 0) {

            process_get_command(c, tokens, ntokens, false, true);
        } else if (strcmp(tokens[COMMAND_TOKEN].value, ""gats"") == 0) {

            process_get_command(c, tokens, ntokens, true, true);
        } else {
            out_string(c, ""ERROR"");
        }
    }",30,,2776,2,,void
63317,BLOCK,1,,<empty>,,,,4,,void
63319,BLOCK,-1,,"WANT_TOKENS_MIN(ntokens, 3)",9,,2778,1,,void
63324,BLOCK,-1,,"WANT_TOKENS_MIN(ntokens, 3)",9,,2778,2,,void
63337,BLOCK,1,,<empty>,,,,1,,void
63342,BLOCK,-1,,"{

            process_get_command(c, tokens, ntokens, false, false);
        }",62,,2779,2,,void
63350,BLOCK,-1,,<empty>,16,,2782,1,,void
63358,BLOCK,1,,<empty>,,,,1,,void
63363,BLOCK,-1,,"{

            process_get_command(c, tokens, ntokens, true, false);
        }",70,,2782,2,,void
63371,BLOCK,-1,,<empty>,16,,2785,1,,void
63379,BLOCK,1,,<empty>,,,,1,,void
63384,BLOCK,-1,,"{

            process_get_command(c, tokens, ntokens, false, true);
        }",69,,2785,2,,void
63392,BLOCK,-1,,<empty>,16,,2788,1,,void
63400,BLOCK,1,,<empty>,,,,1,,void
63405,BLOCK,-1,,"{

            process_get_command(c, tokens, ntokens, true, true);
        }",70,,2788,2,,void
63413,BLOCK,-1,,"{
            out_string(c, ""ERROR"");
        }",16,,2791,1,,void
63418,BLOCK,-1,,<empty>,12,,2794,1,,void
63423,BLOCK,-1,,"{
        if (strcmp(tokens[COMMAND_TOKEN].value, ""set"") == 0 && (comm = NREAD_SET)) {

            WANT_TOKENS_OR(ntokens, 6, 7);
            process_update_command(c, tokens, ntokens, comm, false);
        } else if (strcmp(tokens[COMMAND_TOKEN].value, ""stats"") == 0) {

            process_stat(c, tokens, ntokens);
        } else if (strcmp(tokens[COMMAND_TOKEN].value, ""shutdown"") == 0) {

            process_shutdown_command(c, tokens, ntokens);
        } else if (strcmp(tokens[COMMAND_TOKEN].value, ""slabs"") == 0) {

            process_slabs_command(c, tokens, ntokens);
        } else {
            out_string(c, ""ERROR"");
        }
    }",30,,2794,2,,void
63432,BLOCK,1,,<empty>,,,,1,,void
63440,BLOCK,1,,<empty>,,,,1,,void
63442,BLOCK,-1,,"{

            WANT_TOKENS_OR(ntokens, 6, 7);
            process_update_command(c, tokens, ntokens, comm, false);
        }",84,,2795,2,,void
63447,BLOCK,1,,<empty>,,,,6,,void
63449,BLOCK,-1,,"WANT_TOKENS_OR(ntokens, 6, 7)",13,,2797,1,,void
63458,BLOCK,-1,,"WANT_TOKENS_OR(ntokens, 6, 7)",13,,2797,2,,void
63471,BLOCK,-1,,<empty>,16,,2799,1,,void
63479,BLOCK,1,,<empty>,,,,1,,void
63484,BLOCK,-1,,"{

            process_stat(c, tokens, ntokens);
        }",71,,2799,2,,void
63490,BLOCK,-1,,<empty>,16,,2802,1,,void
63498,BLOCK,1,,<empty>,,,,1,,void
63503,BLOCK,-1,,"{

            process_shutdown_command(c, tokens, ntokens);
        }",74,,2802,2,,void
63509,BLOCK,-1,,<empty>,16,,2805,1,,void
63517,BLOCK,1,,<empty>,,,,1,,void
63522,BLOCK,-1,,"{

            process_slabs_command(c, tokens, ntokens);
        }",71,,2805,2,,void
63528,BLOCK,-1,,"{
            out_string(c, ""ERROR"");
        }",16,,2808,1,,void
63533,BLOCK,-1,,<empty>,12,,2811,1,,void
63538,BLOCK,-1,,"{
        if ((strcmp(tokens[COMMAND_TOKEN].value, ""add"") == 0 && (comm = NREAD_ADD)) ||
            (strcmp(tokens[COMMAND_TOKEN].value, ""append"") == 0 && (comm = NREAD_APPEND)) ) {

            WANT_TOKENS_OR(ntokens, 6, 7);
            process_update_command(c, tokens, ntokens, comm, false);
        } else {
            out_string(c, ""ERROR"");
        }
    }",30,,2811,2,,void
63548,BLOCK,1,,<empty>,,,,1,,void
63556,BLOCK,1,,<empty>,,,,1,,void
63565,BLOCK,1,,<empty>,,,,1,,void
63573,BLOCK,1,,<empty>,,,,1,,void
63575,BLOCK,-1,,"{

            WANT_TOKENS_OR(ntokens, 6, 7);
            process_update_command(c, tokens, ntokens, comm, false);
        }",93,,2813,2,,void
63580,BLOCK,1,,<empty>,,,,6,,void
63582,BLOCK,-1,,"WANT_TOKENS_OR(ntokens, 6, 7)",13,,2815,1,,void
63591,BLOCK,-1,,"WANT_TOKENS_OR(ntokens, 6, 7)",13,,2815,2,,void
63604,BLOCK,-1,,"{
            out_string(c, ""ERROR"");
        }",16,,2817,1,,void
63609,BLOCK,-1,,<empty>,12,,2820,1,,void
63614,BLOCK,-1,,"{
        if (strcmp(tokens[COMMAND_TOKEN].value, ""cas"") == 0 && (comm = NREAD_CAS)) {

            WANT_TOKENS_OR(ntokens, 7, 8);
            process_update_command(c, tokens, ntokens, comm, true);
        } else if (strcmp(tokens[COMMAND_TOKEN].value, ""cache_memlimit"") == 0) {

            WANT_TOKENS_OR(ntokens, 3, 4);
            process_memlimit_command(c, tokens, ntokens);
        } else {
            out_string(c, ""ERROR"");
        }
    }",30,,2820,2,,void
63623,BLOCK,1,,<empty>,,,,1,,void
63631,BLOCK,1,,<empty>,,,,1,,void
63633,BLOCK,-1,,"{

            WANT_TOKENS_OR(ntokens, 7, 8);
            process_update_command(c, tokens, ntokens, comm, true);
        }",84,,2821,2,,void
63638,BLOCK,1,,<empty>,,,,6,,void
63640,BLOCK,-1,,"WANT_TOKENS_OR(ntokens, 7, 8)",13,,2823,1,,void
63649,BLOCK,-1,,"WANT_TOKENS_OR(ntokens, 7, 8)",13,,2823,2,,void
63662,BLOCK,-1,,<empty>,16,,2825,1,,void
63670,BLOCK,1,,<empty>,,,,1,,void
63675,BLOCK,-1,,"{

            WANT_TOKENS_OR(ntokens, 3, 4);
            process_memlimit_command(c, tokens, ntokens);
        }",80,,2825,2,,void
63680,BLOCK,1,,<empty>,,,,6,,void
63682,BLOCK,-1,,"WANT_TOKENS_OR(ntokens, 3, 4)",13,,2827,1,,void
63691,BLOCK,-1,,"WANT_TOKENS_OR(ntokens, 3, 4)",13,,2827,2,,void
63702,BLOCK,-1,,"{
            out_string(c, ""ERROR"");
        }",16,,2829,1,,void
63707,BLOCK,-1,,<empty>,12,,2832,1,,void
63712,BLOCK,-1,,"{
        if (strcmp(tokens[COMMAND_TOKEN].value, ""incr"") == 0) {

            WANT_TOKENS_OR(ntokens, 4, 5);
            process_arithmetic_command(c, tokens, ntokens, 1);
        } else {
            out_string(c, ""ERROR"");
        }
    }",30,,2832,2,,void
63720,BLOCK,1,,<empty>,,,,1,,void
63725,BLOCK,-1,,"{

            WANT_TOKENS_OR(ntokens, 4, 5);
            process_arithmetic_command(c, tokens, ntokens, 1);
        }",63,,2833,2,,void
63730,BLOCK,1,,<empty>,,,,6,,void
63732,BLOCK,-1,,"WANT_TOKENS_OR(ntokens, 4, 5)",13,,2835,1,,void
63741,BLOCK,-1,,"WANT_TOKENS_OR(ntokens, 4, 5)",13,,2835,2,,void
63753,BLOCK,-1,,"{
            out_string(c, ""ERROR"");
        }",16,,2837,1,,void
63758,BLOCK,-1,,<empty>,12,,2840,1,,void
63763,BLOCK,-1,,"{
        if (strcmp(tokens[COMMAND_TOKEN].value, ""delete"") == 0) {

            WANT_TOKENS(ntokens, 3, 5);
            process_delete_command(c, tokens, ntokens);
        } else if (strcmp(tokens[COMMAND_TOKEN].value, ""decr"") == 0) {

            WANT_TOKENS_OR(ntokens, 4, 5);
            process_arithmetic_command(c, tokens, ntokens, 0);
#ifdef MEMCACHED_DEBUG
        } else if (strcmp(tokens[COMMAND_TOKEN].value, ""debugtime"") == 0) {
            WANT_TOKENS_MIN(ntokens, 2);
            process_debugtime_command(c, tokens, ntokens);
#endif
        } else {
            out_string(c, ""ERROR"");
        }
    }",30,,2840,2,,void
63771,BLOCK,1,,<empty>,,,,1,,void
63776,BLOCK,-1,,"{

            WANT_TOKENS(ntokens, 3, 5);
            process_delete_command(c, tokens, ntokens);
        }",65,,2841,2,,void
63781,BLOCK,1,,<empty>,,,,6,,void
63783,BLOCK,-1,,"WANT_TOKENS(ntokens, 3, 5)",13,,2843,1,,void
63802,BLOCK,-1,,"WANT_TOKENS(ntokens, 3, 5)",13,,2843,2,,void
63813,BLOCK,-1,,<empty>,16,,2845,1,,void
63821,BLOCK,1,,<empty>,,,,1,,void
63826,BLOCK,-1,,"{

            WANT_TOKENS_OR(ntokens, 4, 5);
            process_arithmetic_command(c, tokens, ntokens, 0);
#ifdef MEMCACHED_DEBUG
        } else if (strcmp(tokens[COMMAND_TOKEN].value, ""debugtime"") == 0) {
            WANT_TOKENS_MIN(ntokens, 2);
            process_debugtime_command(c, tokens, ntokens);
#endif
        }",70,,2845,2,,void
63831,BLOCK,1,,<empty>,,,,6,,void
63833,BLOCK,-1,,"WANT_TOKENS_OR(ntokens, 4, 5)",13,,2847,1,,void
63842,BLOCK,-1,,"WANT_TOKENS_OR(ntokens, 4, 5)",13,,2847,2,,void
63854,BLOCK,-1,,"{
            out_string(c, ""ERROR"");
        }",16,,2854,1,,void
63859,BLOCK,-1,,<empty>,12,,2857,1,,void
63864,BLOCK,-1,,"{
        if (strcmp(tokens[COMMAND_TOKEN].value, ""touch"") == 0) {

            WANT_TOKENS_OR(ntokens, 4, 5);
            process_touch_command(c, tokens, ntokens);
        } else {
            out_string(c, ""ERROR"");
        }
    }",30,,2857,2,,void
63872,BLOCK,1,,<empty>,,,,1,,void
63877,BLOCK,-1,,"{

            WANT_TOKENS_OR(ntokens, 4, 5);
            process_touch_command(c, tokens, ntokens);
        }",64,,2858,2,,void
63882,BLOCK,1,,<empty>,,,,6,,void
63884,BLOCK,-1,,"WANT_TOKENS_OR(ntokens, 4, 5)",13,,2860,1,,void
63893,BLOCK,-1,,"WANT_TOKENS_OR(ntokens, 4, 5)",13,,2860,2,,void
63904,BLOCK,-1,,"{
            out_string(c, ""ERROR"");
        }",16,,2862,1,,void
63909,BLOCK,-1,,<empty>,12,,2865,1,,void
63919,BLOCK,1,,<empty>,,,,1,,void
63927,BLOCK,1,,<empty>,,,,1,,void
63936,BLOCK,1,,<empty>,,,,1,,void
63944,BLOCK,1,,<empty>,,,,1,,void
63946,BLOCK,-1,,"{

        WANT_TOKENS_OR(ntokens, 6, 7);
        process_update_command(c, tokens, ntokens, comm, false);

    }",99,,2867,2,,void
63951,BLOCK,1,,<empty>,,,,6,,void
63953,BLOCK,-1,,"WANT_TOKENS_OR(ntokens, 6, 7)",9,,2869,1,,void
63962,BLOCK,-1,,"WANT_TOKENS_OR(ntokens, 6, 7)",9,,2869,2,,void
63975,BLOCK,-1,,<empty>,12,,2872,1,,void
63983,BLOCK,1,,<empty>,,,,1,,void
63988,BLOCK,-1,,"{
        // ancient ""binary get"" command which isn't in any documentation, was
        // removed > 10 years ago, etc. Keeping for compatibility reasons but
        // we should look deeper into client code and remove this.
        WANT_TOKENS_MIN(ntokens, 3);
        process_get_command(c, tokens, ntokens, false, false);

    }",66,,2872,2,,void
63992,BLOCK,1,,<empty>,,,,4,,void
63994,BLOCK,-1,,"WANT_TOKENS_MIN(ntokens, 3)",9,,2876,1,,void
63999,BLOCK,-1,,"WANT_TOKENS_MIN(ntokens, 3)",9,,2876,2,,void
64012,BLOCK,-1,,<empty>,12,,2879,1,,void
64020,BLOCK,1,,<empty>,,,,1,,void
64025,BLOCK,-1,,"{

        WANT_TOKENS(ntokens, 2, 4);
        process_flush_all_command(c, tokens, ntokens);

    }",71,,2879,2,,void
64030,BLOCK,1,,<empty>,,,,6,,void
64032,BLOCK,-1,,"WANT_TOKENS(ntokens, 2, 4)",9,,2881,1,,void
64051,BLOCK,-1,,"WANT_TOKENS(ntokens, 2, 4)",9,,2881,2,,void
64062,BLOCK,-1,,<empty>,12,,2884,1,,void
64070,BLOCK,1,,<empty>,,,,1,,void
64075,BLOCK,-1,,"{

        process_version_command(c);

    }",69,,2884,2,,void
64079,BLOCK,-1,,<empty>,12,,2888,1,,void
64087,BLOCK,1,,<empty>,,,,1,,void
64092,BLOCK,-1,,"{

        process_quit_command(c);

    }",66,,2888,2,,void
64096,BLOCK,-1,,<empty>,12,,2892,1,,void
64104,BLOCK,1,,<empty>,,,,1,,void
64109,BLOCK,-1,,"{

        process_lru_crawler_command(c, tokens, ntokens);

    }",73,,2892,2,,void
64115,BLOCK,-1,,<empty>,12,,2896,1,,void
64123,BLOCK,1,,<empty>,,,,1,,void
64128,BLOCK,-1,,"{

        process_watch_command(c, tokens, ntokens);

    }",67,,2896,2,,void
64134,BLOCK,-1,,<empty>,12,,2900,1,,void
64142,BLOCK,1,,<empty>,,,,1,,void
64147,BLOCK,-1,,"{
        WANT_TOKENS_OR(ntokens, 3, 4);
        process_verbosity_command(c, tokens, ntokens);
    }",71,,2900,2,,void
64152,BLOCK,1,,<empty>,,,,6,,void
64154,BLOCK,-1,,"WANT_TOKENS_OR(ntokens, 3, 4)",9,,2901,1,,void
64163,BLOCK,-1,,"WANT_TOKENS_OR(ntokens, 3, 4)",9,,2901,2,,void
64174,BLOCK,-1,,<empty>,12,,2903,1,,void
64182,BLOCK,1,,<empty>,,,,1,,void
64187,BLOCK,-1,,"{
        WANT_TOKENS_MIN(ntokens, 3);
        process_lru_command(c, tokens, ntokens);
#ifdef MEMCACHED_DEBUG
    // commands which exist only for testing the memcached's security protection
    } else if (strcmp(tokens[COMMAND_TOKEN].value, ""misbehave"") == 0) {
        process_misbehave_command(c);
#endif
#ifdef EXTSTORE
    } else if (strcmp(tokens[COMMAND_TOKEN].value, ""extstore"") == 0) {
        WANT_TOKENS_MIN(ntokens, 3);
        process_extstore_command(c, tokens, ntokens);
#endif
#ifdef TLS
    } else if (strcmp(tokens[COMMAND_TOKEN].value, ""refresh_certs"") == 0) {
        process_refresh_certs_command(c, tokens, ntokens);
#endif
    }",65,,2903,2,,void
64191,BLOCK,1,,<empty>,,,,4,,void
64193,BLOCK,-1,,"WANT_TOKENS_MIN(ntokens, 3)",9,,2904,1,,void
64198,BLOCK,-1,,"WANT_TOKENS_MIN(ntokens, 3)",9,,2904,2,,void
64209,BLOCK,-1,,"{
        if (strncmp(tokens[ntokens - 2].value, ""HTTP/"", 5) == 0) {
            conn_set_state(c, conn_closing);
        } else {
            out_string(c, ""ERROR"");
        }
    }",12,,2920,1,,void
64223,BLOCK,-1,,"{
            conn_set_state(c, conn_closing);
        }",66,,2921,2,,void
64228,BLOCK,-1,,"{
            out_string(c, ""ERROR"");
        }",16,,2923,1,,void
64239,BLOCK,-1,,<empty>,1,,1,1,,ANY
64242,BLOCK,-1,,<empty>,,,,2,,<empty>
64247,BLOCK,-1,,<empty>,,,,2,,<empty>
64252,BLOCK,-1,,<empty>,,,,2,,<empty>
64258,BLOCK,-1,,<empty>,,,,3,,<empty>
64265,BLOCK,-1,,<empty>,1,,1,1,,ANY
64270,BLOCK,-1,,<empty>,,,,1,,<empty>
64293,BLOCK,-1,,<empty>,,,,1,,<empty>
64380,BLOCK,-1,,<empty>,,,,1,,<empty>
64531,BLOCK,-1,,<empty>,,,,1,,<empty>
64552,BLOCK,-1,,<empty>,,,,1,,<empty>
64572,BLOCK,-1,,<empty>,,,,1,,<empty>
64584,BLOCK,-1,,<empty>,,,,1,,<empty>
64597,BLOCK,-1,,<empty>,,,,1,,<empty>
64617,BLOCK,-1,,<empty>,,,,1,,<empty>
64640,BLOCK,-1,,<empty>,,,,1,,<empty>
64660,BLOCK,-1,,<empty>,,,,1,,<empty>
64687,BLOCK,-1,,<empty>,,,,1,,<empty>
64706,BLOCK,-1,,<empty>,,,,1,,<empty>
64735,BLOCK,-1,,<empty>,,,,1,,<empty>
64754,BLOCK,-1,,<empty>,,,,1,,<empty>
64782,BLOCK,-1,,<empty>,,,,1,,<empty>
64842,BLOCK,-1,,<empty>,1,,1,1,,ANY
64884,BLOCK,-1,,<empty>,,,,1,,<empty>
64895,BLOCK,-1,,<empty>,,,,1,,<empty>
64909,BLOCK,-1,,<empty>,,,,1,,<empty>
64922,BLOCK,-1,,<empty>,,,,1,,<empty>
64998,BLOCK,-1,,<empty>,,,,4,,<empty>
65008,BLOCK,-1,,<empty>,,,,5,,<empty>
65014,BLOCK,-1,,<empty>,,,,3,,<empty>
65027,BLOCK,-1,,<empty>,,,,1,,<empty>
65060,BLOCK,-1,,<empty>,,,,1,,<empty>
65063,BLOCK,1,,<empty>,,,,1,,void
65077,BLOCK,-1,,<empty>,,,,1,,<empty>
65117,BLOCK,-1,,<empty>,,,,1,,<empty>
65120,BLOCK,1,,<empty>,,,,1,,void
65125,BLOCK,1,,<empty>,,,,1,,void
65131,BLOCK,1,,<empty>,,,,1,,void
65171,BLOCK,-1,,<empty>,,,,1,,<empty>
65189,BLOCK,-1,,<empty>,,,,1,,<empty>
65193,BLOCK,1,,<empty>,,,,1,,void
65199,BLOCK,1,,<empty>,,,,1,,void
65231,BLOCK,-1,,<empty>,,,,1,,<empty>
65261,BLOCK,-1,,<empty>,,,,1,,<empty>
65265,BLOCK,1,,<empty>,,,,1,,void
65276,BLOCK,-1,,<empty>,,,,2,,<empty>
65281,BLOCK,-1,,<empty>,,,,2,,<empty>
65290,BLOCK,-1,,<empty>,,,,1,,<empty>
65298,BLOCK,-1,,<empty>,,,,2,,<empty>
65306,BLOCK,-1,,<empty>,,,,5,,<empty>
65311,BLOCK,-1,,<empty>,,,,2,,<empty>
65316,BLOCK,-1,,<empty>,,,,2,,<empty>
65321,BLOCK,-1,,<empty>,,,,2,,<empty>
65326,BLOCK,-1,,<empty>,,,,2,,<empty>
65333,BLOCK,-1,,<empty>,,,,4,,<empty>
65341,BLOCK,-1,,<empty>,,,,5,,<empty>
65346,BLOCK,-1,,<empty>,,,,2,,<empty>
65351,BLOCK,-1,,<empty>,,,,2,,<empty>
65356,BLOCK,-1,,<empty>,,,,2,,<empty>
65361,BLOCK,-1,,<empty>,,,,2,,<empty>
65366,BLOCK,-1,,<empty>,,,,2,,<empty>
65371,BLOCK,-1,,<empty>,,,,2,,<empty>
65376,BLOCK,-1,,<empty>,,,,2,,<empty>
65381,BLOCK,-1,,<empty>,,,,2,,<empty>
65386,BLOCK,-1,,<empty>,,,,2,,<empty>
65391,BLOCK,-1,,<empty>,,,,2,,<empty>
65396,BLOCK,-1,,<empty>,,,,2,,<empty>
65401,BLOCK,-1,,<empty>,,,,2,,<empty>
65409,BLOCK,-1,,<empty>,,,,5,,<empty>
65417,BLOCK,-1,,<empty>,,,,5,,<empty>
65424,BLOCK,-1,,<empty>,,,,4,,<empty>
65430,BLOCK,-1,,<empty>,,,,3,,<empty>
65436,BLOCK,-1,,<empty>,,,,3,,<empty>
65441,BLOCK,-1,,<empty>,,,,2,,<empty>
65446,BLOCK,-1,,<empty>,,,,2,,<empty>
65451,BLOCK,-1,,<empty>,,,,2,,<empty>
65456,BLOCK,-1,,<empty>,,,,2,,<empty>
65465,BLOCK,-1,,<empty>,1,,1,1,,ANY
65481,BLOCK,-1,,"{
    mcp_request_t *rq = luaL_checkudata(L, 1, ""mcp.request"");
    luaL_checktype(L, 2, LUA_TTABLE);
    int n = 0; // length of table of pools
    int wait_for = 0; // 0 means wait for all responses
    enum mcp_await_e type = AWAIT_GOOD;

    lua_pushnil(L); // init table key
    while (lua_next(L, 2) != 0) {
        luaL_checkudata(L, -1, ""mcp.pool_proxy"");
        lua_pop(L, 1); // remove value, keep key.
        n++;
    }

    if (n <= 0) {
        proxy_lua_error(L, ""mcp.await arguments must have at least one pool"");
    }

    if (lua_isnumber(L, 4)) {
        type = lua_tointeger(L, 4);
        lua_pop(L, 1);
        switch (type) {
            case AWAIT_GOOD:
            case AWAIT_ANY:
            case AWAIT_OK:
            case AWAIT_FIRST:
                break;
            default:
                proxy_lua_error(L, ""invalid type argument tp mcp.await"");
        }
    }

    if (lua_isnumber(L, 3)) {
        wait_for = lua_tointeger(L, 3);
        lua_pop(L, 1);
    ...",32,,26,2,,void
65513,BLOCK,-1,,"{
        luaL_checkudata(L, -1, ""mcp.pool_proxy"");
        lua_pop(L, 1); // remove value, keep key.
        n++;
    }",33,,34,2,,void
65528,BLOCK,-1,,"{
        proxy_lua_error(L, ""mcp.await arguments must have at least one pool"");
    }",17,,40,2,,void
65536,BLOCK,-1,,"{
        type = lua_tointeger(L, 4);
        lua_pop(L, 1);
        switch (type) {
            case AWAIT_GOOD:
            case AWAIT_ANY:
            case AWAIT_OK:
            case AWAIT_FIRST:
                break;
            default:
                proxy_lua_error(L, ""invalid type argument tp mcp.await"");
        }
    }",29,,44,2,,void
65547,BLOCK,-1,,"{
            case AWAIT_GOOD:
            case AWAIT_ANY:
            case AWAIT_OK:
            case AWAIT_FIRST:
                break;
            default:
                proxy_lua_error(L, ""invalid type argument tp mcp.await"");
        }",23,,47,2,,void
65565,BLOCK,-1,,"{
        wait_for = lua_tointeger(L, 3);
        lua_pop(L, 1);
        if (wait_for > n) {
            wait_for = n;
        }
    }",29,,58,2,,void
65578,BLOCK,-1,,"{
            wait_for = n;
        }",27,,61,2,,void
65586,BLOCK,-1,,"{
        wait_for = 1;
    }",30,,67,2,,void
65657,BLOCK,-1,,"{
    io_queue_t *q = conn_io_queue_get(c, IO_QUEUE_PROXY);

    mcp_backend_t *be = rq->be;

    // Then we push a response object, which we'll re-use later.
    // reserve one uservalue for a lua-supplied response.
    mcp_resp_t *r = lua_newuserdatauv(Lc, sizeof(mcp_resp_t), 1);
    memset(r, 0, sizeof(mcp_resp_t));
    // Set noreply mode.
    // TODO (v2): the response ""inherits"" the request's noreply mode, which isn't
    // strictly correct; we should inherit based on the request that spawned
    // the coroutine but the structure doesn't allow that yet.
    // Should also be able to settle this exact mode from the parser so we
    // don't have to re-branch here.
    if (rq->pr.noreply) {
        if (rq->pr.cmd_type == CMD_TYPE_META) {
            r->mode = RESP_MODE_METAQUIET;
            for (int x = 2; x < rq->pr.ntokens; x++) {
                if (rq->request[rq->pr.tokens[x]] == 'q') {
                    rq->request[rq->pr.tokens[x]] = ' ';
                }
          ...",108,,93,6,,void
65664,BLOCK,1,,<empty>,,,,1,,void
65691,BLOCK,-1,,"{
        if (rq->pr.cmd_type == CMD_TYPE_META) {
            r->mode = RESP_MODE_METAQUIET;
            for (int x = 2; x < rq->pr.ntokens; x++) {
                if (rq->request[rq->pr.tokens[x]] == 'q') {
                    rq->request[rq->pr.tokens[x]] = ' ';
                }
            }
        } else {
            r->mode = RESP_MODE_NOREPLY;
            rq->request[rq->pr.reqlen - 3] = 'Y';
        }
    }",25,,108,2,,void
65700,BLOCK,-1,,"{
            r->mode = RESP_MODE_METAQUIET;
            for (int x = 2; x < rq->pr.ntokens; x++) {
                if (rq->request[rq->pr.tokens[x]] == 'q') {
                    rq->request[rq->pr.tokens[x]] = ' ';
                }
            }
        }",47,,109,2,,void
65707,BLOCK,-1,,<empty>,13,,111,1,,void
65721,BLOCK,4,,"{
                if (rq->request[rq->pr.tokens[x]] == 'q') {
                    rq->request[rq->pr.tokens[x]] = ' ';
                }
            }",54,,111,4,,void
65736,BLOCK,-1,,"{
                    rq->request[rq->pr.tokens[x]] = ' ';
                }",59,,112,2,,void
65751,BLOCK,-1,,"{
            r->mode = RESP_MODE_NOREPLY;
            rq->request[rq->pr.reqlen - 3] = 'Y';
        }",16,,116,1,,void
65771,BLOCK,-1,,"{
        r->mode = RESP_MODE_NORMAL;
    }",12,,120,1,,void
65806,BLOCK,-1,,"{
        WSTAT_INCR(c, proxy_conn_oom, 1);
        proxy_lua_error(Lc, ""out of memory allocating from IO cache"");
        return;
    }",20,,130,2,,void
65810,BLOCK,1,,"WSTAT_INCR(c, proxy_conn_oom, 1)",9,,131,1,,void
65858,BLOCK,1,,<empty>,,,,1,,void
65940,BLOCK,1,,<empty>,,,,1,,void
65952,BLOCK,1,,<empty>,,,,1,,void
65979,BLOCK,-1,,"{
    P_DEBUG(""%s: start\n"", __func__);
    mcp_await_t *aw = lua_touserdata(L, -1);
    int await_ref = luaL_ref(L, LUA_REGISTRYINDEX); // await is popped.
    assert(aw != NULL);
    lua_rawgeti(L, LUA_REGISTRYINDEX, aw->argtable_ref); // -> 1
    //dump_stack(L);
    mcp_request_t *rq = aw->rq;
    aw->coro_ref = coro_ref;

    // create result table
    lua_newtable(L); // -> 2
    aw->restable_ref = luaL_ref(L, LUA_REGISTRYINDEX); // pop the result table

    // prepare the request key
    const char *key = MCP_PARSER_KEY(rq->pr);
    size_t len = rq->pr.klen;
    int n = 0;
    bool await_first = true;
    // loop arg table and run each hash selector
    lua_pushnil(L); // -> 3
    while (lua_next(L, 1) != 0) {
        P_DEBUG(""%s: top of loop\n"", __func__);
        // (key, -2), (val, -1)
        mcp_pool_proxy_t *pp = luaL_testudata(L, -1, ""mcp.pool_proxy"");
        if (pp == NULL) {
            proxy_lua_error(L, ""mcp.await must be supplied with a pool"");
        }
        ...",74,,182,5,,void
66030,BLOCK,1,,<empty>,,,,5,,void
66073,BLOCK,-1,,"{
        P_DEBUG(""%s: top of loop\n"", __func__);
        // (key, -2), (val, -1)
        mcp_pool_proxy_t *pp = luaL_testudata(L, -1, ""mcp.pool_proxy"");
        if (pp == NULL) {
            proxy_lua_error(L, ""mcp.await must be supplied with a pool"");
        }
        mcp_pool_t *p = pp->main;

        // NOTE: rq->be is only held to help pass the backend into the IOP in
        // mcp_queue call. Could be a local variable and an argument too.
        rq->be = mcplib_pool_proxy_call_helper(L, p, key, len);

        mcp_queue_await_io(c, L, rq, await_ref, await_first);
        await_first = false;

        // pop value, keep key.
        lua_pop(L, 1);
        n++;
    }",33,,203,2,,void
66086,BLOCK,-1,,"{
            proxy_lua_error(L, ""mcp.await must be supplied with a pool"");
        }",25,,207,2,,void
66133,BLOCK,-1,,"{
    mcp_await_t *aw;
    lua_State *L = p->thread->L; // use the main VM coroutine for work
    bool cleanup = false;
    bool valid = false; // is response valid to add to the result table.
    bool completing = false;

    // TODO (v2): just push the await ptr into *p?
    lua_rawgeti(L, LUA_REGISTRYINDEX, p->await_ref);
    aw = lua_touserdata(L, -1);
    lua_pop(L, 1); // remove AW object from stack
    assert(aw != NULL);
    P_DEBUG(""%s: start [pending: %d]\n"", __func__, aw->pending);
    //dump_stack(L);

    aw->pending--;
    assert(aw->pending >= 0);
    // Await not yet satisfied.
    // If wait_for != 0 check for response success
    // if success and wait_for is *now* 0, we complete.
    // add successful response to response table
    // Also, if no wait_for, add response to response table
    // TODO (v2): for GOOD or OK cases, it might be better to return the
    // last object as valid if there are otherwise zero valids?
    // Think we just have to count valids.....",48,,238,2,,void
66189,BLOCK,-1,,"{
        valid = true; // always collect results unless we are completed.
        if (aw->wait_for > 0) {
            bool is_good = false;
            switch (aw->type) {
                case AWAIT_GOOD:
                    if (p->client_resp->status == MCMC_OK && p->client_resp->resp.code != MCMC_CODE_MISS) {
                        is_good = true;
                    }
                    break;
                case AWAIT_ANY:
                    is_good = true;
                    break;
                case AWAIT_OK:
                    if (p->client_resp->status == MCMC_OK) {
                        is_good = true;
                    }
                    break;
                case AWAIT_FIRST:
                    if (p->await_first) {
                        is_good = true;
                    } else {
                        // user only wants the first pool's result.
                        valid = false;
                    }
                    break;
            }

  ...",25,,263,2,,void
66199,BLOCK,-1,,"{
            bool is_good = false;
            switch (aw->type) {
                case AWAIT_GOOD:
                    if (p->client_resp->status == MCMC_OK && p->client_resp->resp.code != MCMC_CODE_MISS) {
                        is_good = true;
                    }
                    break;
                case AWAIT_ANY:
                    is_good = true;
                    break;
                case AWAIT_OK:
                    if (p->client_resp->status == MCMC_OK) {
                        is_good = true;
                    }
                    break;
                case AWAIT_FIRST:
                    if (p->await_first) {
                        is_good = true;
                    } else {
                        // user only wants the first pool's result.
                        valid = false;
                    }
                    break;
            }

            if (is_good) {
                aw->wait_for--;
            }

            if (aw->wait_for == 0...",31,,265,2,,void
66208,BLOCK,-1,,"{
                case AWAIT_GOOD:
                    if (p->client_resp->status == MCMC_OK && p->client_resp->resp.code != MCMC_CODE_MISS) {
                        is_good = true;
                    }
                    break;
                case AWAIT_ANY:
                    is_good = true;
                    break;
                case AWAIT_OK:
                    if (p->client_resp->status == MCMC_OK) {
                        is_good = true;
                    }
                    break;
                case AWAIT_FIRST:
                    if (p->await_first) {
                        is_good = true;
                    } else {
                        // user only wants the first pool's result.
                        valid = false;
                    }
                    break;
            }",31,,267,2,,void
66220,BLOCK,1,,<empty>,,,,1,,void
66231,BLOCK,1,,<empty>,,,,1,,void
66233,BLOCK,-1,,"{
                        is_good = true;
                    }",107,,269,2,,void
66254,BLOCK,1,,<empty>,,,,1,,void
66256,BLOCK,-1,,"{
                        is_good = true;
                    }",60,,277,2,,void
66267,BLOCK,-1,,"{
                        is_good = true;
                    }",41,,282,2,,void
66272,BLOCK,-1,,"{
                        // user only wants the first pool's result.
                        valid = false;
                    }",28,,284,1,,void
66279,BLOCK,-1,,"{
                aw->wait_for--;
            }",26,,291,2,,void
66290,BLOCK,-1,,"{
                completing = true;
            }",36,,295,2,,void
66300,BLOCK,-1,,"{
        if (!aw->completed) {
            // were waiting for all responses.
            completing = true;
        }
        cleanup = true;
        P_DEBUG(""%s: pending == 0\n"", __func__);
    }",27,,304,2,,void
66306,BLOCK,-1,,"{
            // were waiting for all responses.
            completing = true;
        }",29,,305,2,,void
66315,BLOCK,-1,,"{
        P_DEBUG(""%s: valid\n"", __func__);
        lua_rawgeti(L, LUA_REGISTRYINDEX, aw->restable_ref); // -> 1
        lua_rawgeti(L, LUA_REGISTRYINDEX, p->mcpres_ref); // -> 2
        // couldn't find a table.insert() equivalent; so this is
        // inserting into the length + 1 position manually.
        //dump_stack(L);
        lua_rawseti(L, 1, lua_rawlen(L, 1) + 1); // pops mcpres
        lua_pop(L, 1); // pops restable
    }",16,,314,2,,void
66347,BLOCK,-1,,"{
        P_DEBUG(""%s: completing\n"", __func__);
        assert(p->c->thread == p->thread);
        aw->completed = true;
        // if we haven't completed yet, the connection reference is still
        // valid. So now we pull it, reduce count, and readd if necessary.
        // here is also the point where we resume the coroutine.
        lua_rawgeti(L, LUA_REGISTRYINDEX, aw->coro_ref);
        lua_State *Lc = lua_tothread(L, -1);
        lua_rawgeti(Lc, LUA_REGISTRYINDEX, aw->restable_ref); // -> 1
        proxy_run_coroutine(Lc, aw->resp, NULL, p->c);
        luaL_unref(L, LUA_REGISTRYINDEX, aw->coro_ref);
        luaL_unref(L, LUA_REGISTRYINDEX, aw->restable_ref);

        io_queue_t *q = conn_io_queue_get(p->c, p->io_queue_type);
        q->count--;
        if (q->count == 0) {
            // call re-add directly since we're already in the worker thread.
            conn_worker_readd(p->c);
        }

    }",21,,329,2,,void
66423,BLOCK,-1,,"{
            // call re-add directly since we're already in the worker thread.
            conn_worker_readd(p->c);
        }",28,,345,2,,void
66430,BLOCK,-1,,"{
        P_DEBUG(""%s: cleanup [completed: %d]\n"", __func__, aw->completed);
        luaL_unref(L, LUA_REGISTRYINDEX, aw->argtable_ref);
        luaL_unref(L, LUA_REGISTRYINDEX, aw->req_ref);
        luaL_unref(L, LUA_REGISTRYINDEX, p->await_ref);
    }",18,,352,2,,void
66469,BLOCK,-1,,<empty>,1,,1,1,,ANY
66479,BLOCK,-1,,"{
    (void)L;
    struct _dumpbuf *db = ud;
    if (db->used + sz > db->size) {
        db->size *= 2;
        char *nb = realloc(db->buf, db->size);
        if (nb == NULL) {
            return -1;
        }
        db->buf = nb;
    }
    memcpy(db->buf + db->used, (const char *)p, sz);
    db->used += sz;
    return 0;
}",75,,13,5,,void
66497,BLOCK,-1,,"{
        db->size *= 2;
        char *nb = realloc(db->buf, db->size);
        if (nb == NULL) {
            return -1;
        }
        db->buf = nb;
    }",35,,16,2,,void
66517,BLOCK,-1,,"{
            return -1;
        }",25,,19,2,,void
66551,BLOCK,-1,,"{
    (void)L;
    struct _dumpbuf *db = data;
    if (db->used == 0) {
        *size = 0;
        return NULL;
    }
    *size = db->used;
    db->used = 0;
    return db->buf;
}",74,,29,4,,void
66565,BLOCK,-1,,"{
        *size = 0;
        return NULL;
    }",24,,32,2,,void
66591,BLOCK,-1,,"{
    proxy_ctx_t *ctx = arg;
    if (pthread_mutex_trylock(&ctx->config_lock) == 0) {
        pthread_cond_signal(&ctx->config_cond);
        pthread_mutex_unlock(&ctx->config_lock);
    }
}",36,,41,2,,void
66604,BLOCK,-1,,"{
        pthread_cond_signal(&ctx->config_cond);
        pthread_mutex_unlock(&ctx->config_lock);
    }",56,,43,2,,void
66619,BLOCK,-1,,"{
    proxy_ctx_t *ctx = arg;
    pool_head_t head;

    pthread_mutex_lock(&ctx->manager_lock);
    while (1) {
        STAILQ_INIT(&head);
        while (STAILQ_EMPTY(&ctx->manager_head)) {
            pthread_cond_wait(&ctx->manager_cond, &ctx->manager_lock);
        }

        // pull dealloc queue into local queue.
        STAILQ_CONCAT(&head, &ctx->manager_head);
        pthread_mutex_unlock(&ctx->manager_lock);

        // Config lock is required for using config VM.
        pthread_mutex_lock(&ctx->config_lock);
        lua_State *L = ctx->proxy_state;
        mcp_pool_t *p;
        STAILQ_FOREACH(p, &head, next) {
            // we let the pool object _gc() handle backend references.

            luaL_unref(L, LUA_REGISTRYINDEX, p->phc_ref);
            // need to... unref self.
            // NOTE: double check if we really need to self-reference.
            // this is a backup here to ensure the external refcounts hit zero
            // before lua garbage collects the o...",47,,50,2,,void
66632,BLOCK,-1,,"{
        STAILQ_INIT(&head);
        while (STAILQ_EMPTY(&ctx->manager_head)) {
            pthread_cond_wait(&ctx->manager_cond, &ctx->manager_lock);
        }

        // pull dealloc queue into local queue.
        STAILQ_CONCAT(&head, &ctx->manager_head);
        pthread_mutex_unlock(&ctx->manager_lock);

        // Config lock is required for using config VM.
        pthread_mutex_lock(&ctx->config_lock);
        lua_State *L = ctx->proxy_state;
        mcp_pool_t *p;
        STAILQ_FOREACH(p, &head, next) {
            // we let the pool object _gc() handle backend references.

            luaL_unref(L, LUA_REGISTRYINDEX, p->phc_ref);
            // need to... unref self.
            // NOTE: double check if we really need to self-reference.
            // this is a backup here to ensure the external refcounts hit zero
            // before lua garbage collects the object. other things hold a
            // reference to the object though.
            luaL_unref(L, LUA_REGISTR...",15,,55,2,,void
66636,BLOCK,1,,<empty>,,,,5,,void
66638,BLOCK,-1,,STAILQ_INIT(&head),9,,56,1,,void
66662,BLOCK,1,,<empty>,,,,3,,void
66671,BLOCK,-1,,"{
            pthread_cond_wait(&ctx->manager_cond, &ctx->manager_lock);
        }",50,,57,2,,void
66688,BLOCK,1,,<empty>,,,,11,,void
66690,BLOCK,-1,,"STAILQ_CONCAT(&head, &ctx->manager_head)",9,,62,1,,void
66701,BLOCK,-1,,"STAILQ_CONCAT(&head, &ctx->manager_head)",9,,62,2,,void
66726,BLOCK,-1,,"STAILQ_CONCAT(&head, &ctx->manager_head)",9,,62,1,,void
66772,BLOCK,1,,<empty>,,,,12,,void
66774,BLOCK,-1,,<empty>,9,,69,1,,void
66789,BLOCK,4,,"{
            // we let the pool object _gc() handle backend references.

            luaL_unref(L, LUA_REGISTRYINDEX, p->phc_ref);
            // need to... unref self.
            // NOTE: double check if we really need to self-reference.
            // this is a backup here to ensure the external refcounts hit zero
            // before lua garbage collects the object. other things hold a
            // reference to the object though.
            luaL_unref(L, LUA_REGISTRYINDEX, p->self_ref);
        }",40,,69,4,,void
66818,BLOCK,-1,,"{
    proxy_ctx_t *ctx = arg;

    logger_create();
    pthread_mutex_lock(&ctx->config_lock);
    while (1) {
        pthread_cond_wait(&ctx->config_cond, &ctx->config_lock);
        LOGGER_LOG(NULL, LOG_PROXYEVENTS, LOGGER_PROXY_CONFIG, NULL, ""start"");
        STAT_INCR(ctx, config_reloads, 1);
        lua_State *L = ctx->proxy_state;
        lua_settop(L, 0); // clear off any crud that could have been left on the stack.

        // The main stages of config reload are:
        // - load and execute the config file
        // - run mcp_config_pools()
        // - for each worker:
        //   - copy and execute new lua code
        //   - copy selector table
        //   - run mcp_config_routes()

        if (proxy_load_config(ctx) != 0) {
            // Failed to load. log and wait for a retry.
            STAT_INCR(ctx, config_reload_fails, 1);
            LOGGER_LOG(NULL, LOG_PROXYEVENTS, LOGGER_PROXY_CONFIG, NULL, ""failed"");
            continue;
        }

        // TODO (v2...",46,,100,2,,void
66831,BLOCK,-1,,"{
        pthread_cond_wait(&ctx->config_cond, &ctx->config_lock);
        LOGGER_LOG(NULL, LOG_PROXYEVENTS, LOGGER_PROXY_CONFIG, NULL, ""start"");
        STAT_INCR(ctx, config_reloads, 1);
        lua_State *L = ctx->proxy_state;
        lua_settop(L, 0); // clear off any crud that could have been left on the stack.

        // The main stages of config reload are:
        // - load and execute the config file
        // - run mcp_config_pools()
        // - for each worker:
        //   - copy and execute new lua code
        //   - copy selector table
        //   - run mcp_config_routes()

        if (proxy_load_config(ctx) != 0) {
            // Failed to load. log and wait for a retry.
            STAT_INCR(ctx, config_reload_fails, 1);
            LOGGER_LOG(NULL, LOG_PROXYEVENTS, LOGGER_PROXY_CONFIG, NULL, ""failed"");
            continue;
        }

        // TODO (v2): create a temporary VM to test-load the worker code into.
        // failing to load partway through the wo...",15,,105,2,,void
66845,BLOCK,1,,<empty>,,,,6,,void
66847,BLOCK,-1,,"LOGGER_LOG(NULL, LOG_PROXYEVENTS, LOGGER_PROXY_CONFIG, NULL, ""start"")",9,,107,1,,void
66856,BLOCK,-1,,<empty>,9,,107,2,,void
66871,BLOCK,-1,,<empty>,9,,107,2,,void
66881,BLOCK,1,,"STAT_INCR(ctx, config_reloads, 1)",9,,108,3,,void
66913,BLOCK,-1,,"{
            // Failed to load. log and wait for a retry.
            STAT_INCR(ctx, config_reload_fails, 1);
            LOGGER_LOG(NULL, LOG_PROXYEVENTS, LOGGER_PROXY_CONFIG, NULL, ""failed"");
            continue;
        }",42,,120,2,,void
66917,BLOCK,1,,"STAT_INCR(ctx, config_reload_fails, 1)",13,,122,1,,void
66939,BLOCK,1,,<empty>,,,,6,,void
66941,BLOCK,-1,,"LOGGER_LOG(NULL, LOG_PROXYEVENTS, LOGGER_PROXY_CONFIG, NULL, ""failed"")",13,,123,1,,void
66950,BLOCK,-1,,<empty>,13,,123,2,,void
66965,BLOCK,-1,,<empty>,13,,123,2,,void
66974,BLOCK,-1,,<empty>,9,,133,1,,void
66986,BLOCK,4,,"{
            LIBEVENT_THREAD *thr = get_worker_thread(x);

            pthread_mutex_lock(&ctx->worker_lock);
            ctx->worker_done = false;
            ctx->worker_failed = false;
            proxy_reload_notify(thr);
            while (!ctx->worker_done) {
                // in case of spurious wakeup.
                pthread_cond_wait(&ctx->worker_cond, &ctx->worker_lock);
            }
            pthread_mutex_unlock(&ctx->worker_lock);

            // Code load bailed.
            if (ctx->worker_failed) {
                STAT_INCR(ctx, config_reload_fails, 1);
                LOGGER_LOG(NULL, LOG_PROXYEVENTS, LOGGER_PROXY_CONFIG, NULL, ""failed"");
                continue;
            }
        }",56,,133,4,,void
67014,BLOCK,-1,,"{
                // in case of spurious wakeup.
                pthread_cond_wait(&ctx->worker_cond, &ctx->worker_lock);
            }",39,,140,2,,void
67033,BLOCK,-1,,"{
                STAT_INCR(ctx, config_reload_fails, 1);
                LOGGER_LOG(NULL, LOG_PROXYEVENTS, LOGGER_PROXY_CONFIG, NULL, ""failed"");
                continue;
            }",37,,147,2,,void
67037,BLOCK,1,,"STAT_INCR(ctx, config_reload_fails, 1)",17,,148,1,,void
67059,BLOCK,1,,<empty>,,,,6,,void
67061,BLOCK,-1,,"LOGGER_LOG(NULL, LOG_PROXYEVENTS, LOGGER_PROXY_CONFIG, NULL, ""failed"")",17,,149,1,,void
67070,BLOCK,-1,,<empty>,17,,149,2,,void
67085,BLOCK,-1,,<empty>,17,,149,2,,void
67097,BLOCK,1,,<empty>,,,,6,,void
67099,BLOCK,-1,,"LOGGER_LOG(NULL, LOG_PROXYEVENTS, LOGGER_PROXY_CONFIG, NULL, ""done"")",9,,153,1,,void
67108,BLOCK,-1,,<empty>,9,,153,2,,void
67123,BLOCK,-1,,<empty>,9,,153,2,,void
67136,BLOCK,-1,,"{
    int ret;

    pthread_mutex_lock(&ctx->config_lock);
    if ((ret = pthread_create(&ctx->config_tid, NULL,
                    _proxy_config_thread, ctx)) != 0) {
        fprintf(stderr, ""Failed to start proxy configuration thread: %s\n"",
                strerror(ret));
        pthread_mutex_unlock(&ctx->config_lock);
        return -1;
    }
    pthread_mutex_unlock(&ctx->config_lock);

    pthread_mutex_lock(&ctx->manager_lock);
    if ((ret = pthread_create(&ctx->manager_tid, NULL,
                    _proxy_manager_thread, ctx)) != 0) {
        fprintf(stderr, ""Failed to start proxy configuration thread: %s\n"",
                strerror(ret));
        pthread_mutex_unlock(&ctx->manager_lock);
        return -1;
    }
    pthread_mutex_unlock(&ctx->manager_lock);

    return 0;
}",51,,159,2,,void
67156,BLOCK,-1,,"{
        fprintf(stderr, ""Failed to start proxy configuration thread: %s\n"",
                strerror(ret));
        pthread_mutex_unlock(&ctx->config_lock);
        return -1;
    }",55,,164,2,,void
67193,BLOCK,-1,,"{
        fprintf(stderr, ""Failed to start proxy configuration thread: %s\n"",
                strerror(ret));
        pthread_mutex_unlock(&ctx->manager_lock);
        return -1;
    }",56,,174,2,,void
67218,BLOCK,-1,,"{
    proxy_ctx_t *ctx = arg;
    lua_State *L = ctx->proxy_state;
    int res = luaL_loadfile(L, settings.proxy_startfile);
    if (res != LUA_OK) {
        fprintf(stderr, ""ERROR: Failed to load proxy_startfile: %s\n"", lua_tostring(L, -1));
        return -1;
    }
    // LUA_OK, LUA_ERRSYNTAX, LUA_ERRMEM, LUA_ERRFILE

    // Now we need to dump the compiled code into bytecode.
    // This will then get loaded into worker threads.
    struct _dumpbuf *db = malloc(sizeof(struct _dumpbuf));
    db->size = 16384;
    db->used = 0;
    db->buf = malloc(db->size);
    lua_dump(L, _dump_helper, db, 0);
    // 0 means no error.
    ctx->proxy_code = db;

    // now we complete the data load by calling the function.
    res = lua_pcall(L, 0, LUA_MULTRET, 0);
    if (res != LUA_OK) {
        fprintf(stderr, ""ERROR: Failed to load data into lua config state: %s\n"", lua_tostring(L, -1));
        exit(EXIT_FAILURE);
    }

    // call the mcp_config_pools function to get the central backends....",34,,185,2,,void
67241,BLOCK,-1,,"{
        fprintf(stderr, ""ERROR: Failed to load proxy_startfile: %s\n"", lua_tostring(L, -1));
        return -1;
    }",24,,189,2,,void
67297,BLOCK,-1,,"{
        fprintf(stderr, ""ERROR: Failed to load data into lua config state: %s\n"", lua_tostring(L, -1));
        exit(EXIT_FAILURE);
    }",24,,207,2,,void
67315,BLOCK,-1,,"{
        fprintf(stderr, ""ERROR: Configuration file missing 'mcp_config_pools' function\n"");
        exit(EXIT_FAILURE);
    }",27,,215,2,,void
67331,BLOCK,-1,,"{
        fprintf(stderr, ""ERROR: Failed to execute mcp_config_pools: %s\n"", lua_tostring(L, -1));
        exit(EXIT_FAILURE);
    }",42,,220,2,,void
67348,BLOCK,-1,,"{
    // from, -3 should have he userdata.
    mcp_pool_t *p = luaL_checkudata(from, -3, ""mcp.pool"");
    size_t size = sizeof(mcp_pool_proxy_t);
    mcp_pool_proxy_t *pp = lua_newuserdatauv(to, size, 0);
    luaL_setmetatable(to, ""mcp.pool_proxy"");

    pp->main = p;
    pthread_mutex_lock(&p->lock);
    p->refcount++;
    pthread_mutex_unlock(&p->lock);
    return 0;
}",55,,229,3,,void
67398,BLOCK,-1,,<empty>,,,,3,,<empty>
67404,BLOCK,-1,,"{
    int type = lua_type(from, -1);
    bool found = false;
    luaL_checkstack(from, 4, ""configuration error: table recursion too deep"");
    luaL_checkstack(to, 4, ""configuration error: table recursion too deep"");
    switch (type) {
        case LUA_TNIL:
            lua_pushnil(to);
            break;
        case LUA_TUSERDATA:
            // see dump_stack() - check if it's something we handle.
            if (lua_getmetatable(from, -1) != 0) {
                lua_pushstring(from, ""__name"");
                if (lua_rawget(from, -2) != LUA_TNIL) {
                    const char *name = lua_tostring(from, -1);
                    if (strcmp(name, ""mcp.pool"") == 0) {
                        _copy_pool(from, to);
                        found = true;
                    }
                }
                lua_pop(from, 2);
            }
            if (!found) {
                proxy_lua_ferror(from, ""unhandled userdata type in configuration table\n"");
            }
            b...",64,,246,3,,void
67426,BLOCK,-1,,"{
        case LUA_TNIL:
            lua_pushnil(to);
            break;
        case LUA_TUSERDATA:
            // see dump_stack() - check if it's something we handle.
            if (lua_getmetatable(from, -1) != 0) {
                lua_pushstring(from, ""__name"");
                if (lua_rawget(from, -2) != LUA_TNIL) {
                    const char *name = lua_tostring(from, -1);
                    if (strcmp(name, ""mcp.pool"") == 0) {
                        _copy_pool(from, to);
                        found = true;
                    }
                }
                lua_pop(from, 2);
            }
            if (!found) {
                proxy_lua_ferror(from, ""unhandled userdata type in configuration table\n"");
            }
            break;
        case LUA_TNUMBER:
            if (lua_isinteger(from, -1)) {
                lua_pushinteger(to, lua_tointeger(from, -1));
            } else {
                lua_pushnumber(to, lua_tonumber(from, -1));
            }
   ...",19,,251,2,,void
67441,BLOCK,-1,,"{
                lua_pushstring(from, ""__name"");
                if (lua_rawget(from, -2) != LUA_TNIL) {
                    const char *name = lua_tostring(from, -1);
                    if (strcmp(name, ""mcp.pool"") == 0) {
                        _copy_pool(from, to);
                        found = true;
                    }
                }
                lua_pop(from, 2);
            }",50,,257,2,,void
67452,BLOCK,-1,,"{
                    const char *name = lua_tostring(from, -1);
                    if (strcmp(name, ""mcp.pool"") == 0) {
                        _copy_pool(from, to);
                        found = true;
                    }
                }",55,,259,2,,void
67466,BLOCK,-1,,"{
                        _copy_pool(from, to);
                        found = true;
                    }",56,,261,2,,void
67479,BLOCK,-1,,"{
                proxy_lua_ferror(from, ""unhandled userdata type in configuration table\n"");
            }",25,,268,2,,void
67491,BLOCK,-1,,"{
                lua_pushinteger(to, lua_tointeger(from, -1));
            }",42,,273,2,,void
67499,BLOCK,-1,,"{
                lua_pushnumber(to, lua_tonumber(from, -1));
            }",20,,275,1,,void
67555,BLOCK,-1,,"{
                // (key, -2), (val, -1)
                int keytype = lua_type(from, -2);
                // to intentionally limit complexity and allow for future
                // optimizations we restrict what types may be used as keys
                // for sub-tables.
                switch (keytype) {
                    case LUA_TSTRING:
                        // to[l]string converts the actual key in the table
                        // into a string, so we must not do that unless it
                        // already is one.
                        lua_pushlstring(to, lua_tostring(from, -2), lua_rawlen(from, -2));
                        break;
                    case LUA_TNUMBER:
                        if (lua_isinteger(from, -1)) {
                            lua_pushinteger(to, lua_tointeger(from, -1));
                        } else {
                            lua_pushnumber(to, lua_tonumber(from, -1));
                        }
                        break;
  ...",44,,293,2,,void
67565,BLOCK,-1,,"{
                    case LUA_TSTRING:
                        // to[l]string converts the actual key in the table
                        // into a string, so we must not do that unless it
                        // already is one.
                        lua_pushlstring(to, lua_tostring(from, -2), lua_rawlen(from, -2));
                        break;
                    case LUA_TNUMBER:
                        if (lua_isinteger(from, -1)) {
                            lua_pushinteger(to, lua_tointeger(from, -1));
                        } else {
                            lua_pushnumber(to, lua_tonumber(from, -1));
                        }
                        break;
                    default:
                        proxy_lua_error(from, ""configuration table keys must be strings or numbers"");
                }",34,,299,2,,void
67586,BLOCK,-1,,"{
                            lua_pushinteger(to, lua_tointeger(from, -1));
                        }",54,,307,2,,void
67594,BLOCK,-1,,"{
                            lua_pushnumber(to, lua_tonumber(from, -1));
                        }",32,,309,1,,void
67625,BLOCK,-1,,"{
    proxy_ctx_t *ctx = arg;
    pthread_mutex_lock(&ctx->worker_lock);
    if (proxy_thread_loadconf(thr) != 0) {
        ctx->worker_failed = true;
    }
    ctx->worker_done = true;
    pthread_cond_signal(&ctx->worker_cond);
    pthread_mutex_unlock(&ctx->worker_lock);
}",59,,333,3,,void
67640,BLOCK,-1,,"{
        ctx->worker_failed = true;
    }",42,,336,2,,void
67665,BLOCK,-1,,"{
    lua_State *L = thr->L;
    // load the precompiled config function.
    proxy_ctx_t *ctx = settings.proxy_ctx;
    struct _dumpbuf *db = ctx->proxy_code;
    struct _dumpbuf db2; // copy because the helper modifies it.
    memcpy(&db2, db, sizeof(struct _dumpbuf));

    lua_load(L, _load_helper, &db2, ""config"", NULL);
    // LUA_OK + all errs from loadfile except LUA_ERRFILE.
    //dump_stack(L);
    // - pcall the func (which should load it)
    int res = lua_pcall(L, 0, LUA_MULTRET, 0);
    if (res != LUA_OK) {
        // FIXME (v2): don't exit here!
        fprintf(stderr, ""Failed to load data into worker thread\n"");
        return -1;
    }

    lua_getglobal(L, ""mcp_config_routes"");
    // create deepcopy of argument to pass into mcp_config_routes.
    // FIXME (v2): to avoid lua SIGABRT'ing on errors we need to protect the call
    // normal pattern:
    // lua_pushcfunction(L, &_copy_config_table);
    // lua_pushlightuserdata(L, &L2);
    // res = la_pcall(L, etc);
   ...",49,,346,2,,void
67710,BLOCK,-1,,"{
        // FIXME (v2): don't exit here!
        fprintf(stderr, ""Failed to load data into worker thread\n"");
        return -1;
    }",24,,359,2,,void
67733,BLOCK,-1,,"{
        fprintf(stderr, ""Failed to execute mcp_config_routes: %s\n"", lua_tostring(L, -1));
        return -1;
    }",42,,385,2,,void
67746,BLOCK,1,,<empty>,,,,3,,void
67769,BLOCK,-1,,"{
        pthread_mutex_lock(&thr->stats.mutex);
        if (thr->proxy_user_stats == NULL) {
            tus = calloc(1, sizeof(struct proxy_user_stats));
            thr->proxy_user_stats = tus;
        } else {
            tus = thr->proxy_user_stats;
        }

        // originally this was a realloc routine but it felt fragile.
        // that might still be a better idea; still need to zero out the end.
        uint64_t *counters = calloc(us->num_stats, sizeof(uint64_t));

        // note that num_stats can _only_ grow in size.
        // we also only care about counters on the worker threads.
        if (tus->counters) {
            assert(tus->num_stats <= us->num_stats);
            memcpy(counters, tus->counters, tus->num_stats * sizeof(uint64_t));
            free(tus->counters);
        }

        tus->counters = counters;
        tus->num_stats = us->num_stats;
        pthread_mutex_unlock(&thr->stats.mutex);
    }",29,,394,2,,void
67783,BLOCK,-1,,"{
            tus = calloc(1, sizeof(struct proxy_user_stats));
            thr->proxy_user_stats = tus;
        }",44,,396,2,,void
67796,BLOCK,-1,,"{
            tus = thr->proxy_user_stats;
        }",16,,399,1,,void
67815,BLOCK,-1,,"{
            assert(tus->num_stats <= us->num_stats);
            memcpy(counters, tus->counters, tus->num_stats * sizeof(uint64_t));
            free(tus->counters);
        }",28,,409,2,,void
67860,BLOCK,1,,<empty>,,,,3,,void
67876,BLOCK,-1,,<empty>,1,,1,1,,ANY
67885,BLOCK,-1,,"{
    mcplib_jump_hash_t *jh = ctx;

    int64_t b = -1, j = 0;
    while (j < jh->buckets) {
        b = j;
        hash = hash * 2862933555777941757ULL + 1;
        j = (b + 1) * ((double)(1LL << 31) / (double)((hash >> 33) + 1));
    }
    return b;
}",76,,10,3,,void
67905,BLOCK,-1,,"{
        b = j;
        hash = hash * 2862933555777941757ULL + 1;
        j = (b + 1) * ((double)(1LL << 31) / (double)((hash >> 33) + 1));
    }",29,,14,2,,void
67941,BLOCK,-1,,"{
    luaL_checktype(L, 1, LUA_TTABLE);
    lua_Unsigned buckets = lua_rawlen(L, 1);

    mcplib_jump_hash_t *jh = lua_newuserdatauv(L, sizeof(mcplib_jump_hash_t), 0);

    // don't need to loop through the table at all, just need its length.
    // could optimize startup time by adding hints to the module for how to
    // format pool (ie; just a total count or the full table)
    jh->buckets = buckets;
    jh->phc.ctx = jh;
    jh->phc.selector_func = mcplib_dist_jump_hash_get_server;

    lua_pushlightuserdata(L, &jh->phc);

    // - return [UD, lightuserdata]
    return 2;
}",52,,23,2,,void
67991,BLOCK,-1,,"{
    const struct luaL_Reg jump_f[] = {
        {""new"", mcplib_dist_jump_hash_new},
        {NULL, NULL},
    };

    luaL_newlib(L, jump_f);

    return 1;
}",46,,42,2,,void
68015,BLOCK,-1,,<empty>,1,,1,1,,ANY
68018,BLOCK,-1,,"{
    mcp_resp_t *r = luaL_checkudata(L, -1, ""mcp.response"");

    if (r->status == MCMC_OK) {
        lua_pushboolean(L, 1);
    } else {
        lua_pushboolean(L, 0);
    }

    return 1;
}",45,,11,2,,void
68033,BLOCK,1,,<empty>,,,,1,,void
68035,BLOCK,-1,,"{
        lua_pushboolean(L, 1);
    }",31,,14,2,,void
68040,BLOCK,-1,,"{
        lua_pushboolean(L, 0);
    }",12,,16,1,,void
68050,BLOCK,-1,,"{
    mcp_resp_t *r = luaL_checkudata(L, -1, ""mcp.response"");

    if (r->status == MCMC_OK && r->resp.code != MCMC_CODE_MISS) {
        lua_pushboolean(L, 1);
    } else {
        lua_pushboolean(L, 0);
    }

    return 1;
}",46,,23,2,,void
68066,BLOCK,1,,<empty>,,,,1,,void
68075,BLOCK,1,,<empty>,,,,1,,void
68077,BLOCK,-1,,"{
        lua_pushboolean(L, 1);
    }",65,,26,2,,void
68082,BLOCK,-1,,"{
        lua_pushboolean(L, 0);
    }",12,,28,1,,void
68092,BLOCK,-1,,"{
    mcp_resp_t *r = luaL_checkudata(L, -1, ""mcp.response"");

    // We do remove the ""\r\n"" from the value length, so if you're actually
    // processing the value nothing breaks.
    if (r->resp.vlen >= 2) {
        lua_pushinteger(L, r->resp.vlen-2);
    } else {
        lua_pushinteger(L, 0);
    }

    return 1;
}",47,,38,2,,void
68109,BLOCK,-1,,"{
        lua_pushinteger(L, r->resp.vlen-2);
    }",28,,43,2,,void
68120,BLOCK,-1,,"{
        lua_pushinteger(L, 0);
    }",12,,45,1,,void
68130,BLOCK,-1,,"{
    mcp_resp_t *r = luaL_checkudata(L, -1, ""mcp.response"");

    lua_pushinteger(L, r->resp.code);

    return 1;
}",47,,53,2,,void
68152,BLOCK,-1,,"{
    mcp_resp_t *r = luaL_checkudata(L, -1, ""mcp.response"");

    if (r->resp.rline != NULL) {
        lua_pushlstring(L, r->resp.rline, r->resp.rlen);
    } else {
        lua_pushnil(L);
    }

    return 1;
}",47,,62,2,,void
68169,BLOCK,-1,,"{
        lua_pushlstring(L, r->resp.rline, r->resp.rlen);
    }",32,,65,2,,void
68183,BLOCK,-1,,"{
        lua_pushnil(L);
    }",12,,67,1,,void
68192,BLOCK,-1,,"{
    mcp_resp_t *r = luaL_checkudata(L, -1, ""mcp.response"");

    // On error/similar we might be holding the read buffer.
    // If the buf is handed off to mc_resp for return, this pointer is NULL
    if (r->buf != NULL) {
        free(r->buf);
    }

    return 0;
}",45,,74,2,,void
68207,BLOCK,-1,,"{
        free(r->buf);
    }",25,,79,2,,void
68218,BLOCK,-1,,"{
    mcp_backend_t *be = luaL_checkudata(L, -1, ""mcp.backend"");

    assert(STAILQ_EMPTY(&be->io_head));

    mcmc_disconnect(be->client);
    free(be->client);

    // FIXME (v2): upvalue for global ctx.
    proxy_ctx_t *ctx = settings.proxy_ctx;
    STAT_DECR(ctx, backend_total, 1);

    return 0;
}",44,,93,2,,void
68233,BLOCK,1,,<empty>,,,,3,,void
68259,BLOCK,1,,"STAT_DECR(ctx, backend_total, 1)",5,,103,8,,void
68283,BLOCK,-1,,"{
    luaL_checkstring(L, -3); // label for indexing backends.
    size_t nlen = 0;
    const char *name = luaL_checklstring(L, -2, &nlen);
    const char *port = luaL_checkstring(L, -1);
    // FIXME (v2): upvalue for global ctx.
    proxy_ctx_t *ctx = settings.proxy_ctx;

    if (nlen > MAX_NAMELEN-1) {
        proxy_lua_error(L, ""backend name too long"");
        return 0;
    }

    // first check our reference table to compare.
    lua_pushvalue(L, 1);
    int ret = lua_gettable(L, lua_upvalueindex(MCP_BACKEND_UPVALUE));
    if (ret != LUA_TNIL) {
        mcp_backend_t *be_orig = luaL_checkudata(L, -1, ""mcp.backend"");
        if (strncmp(be_orig->name, name, MAX_NAMELEN) == 0
                && strncmp(be_orig->port, port, MAX_PORTLEN) == 0) {
            // backend is the same, return it.
            return 1;
        } else {
            // backend not the same, pop from stack and make new one.
            lua_pop(L, 1);
        }
    } else {
        lua_pop(L, 1);
    }

   ...",41,,108,2,,void
68319,BLOCK,1,,<empty>,,,,1,,void
68322,BLOCK,-1,,"{
        proxy_lua_error(L, ""backend name too long"");
        return 0;
    }",31,,116,2,,void
68338,BLOCK,1,,<empty>,,,,1,,void
68344,BLOCK,-1,,"{
        mcp_backend_t *be_orig = luaL_checkudata(L, -1, ""mcp.backend"");
        if (strncmp(be_orig->name, name, MAX_NAMELEN) == 0
                && strncmp(be_orig->port, port, MAX_PORTLEN) == 0) {
            // backend is the same, return it.
            return 1;
        } else {
            // backend not the same, pop from stack and make new one.
            lua_pop(L, 1);
        }
    }",26,,124,2,,void
68362,BLOCK,1,,<empty>,,,,1,,void
68372,BLOCK,1,,<empty>,,,,1,,void
68375,BLOCK,-1,,"{
            // backend is the same, return it.
            return 1;
        }",68,,127,2,,void
68379,BLOCK,-1,,"{
            // backend not the same, pop from stack and make new one.
            lua_pop(L, 1);
        }",16,,130,1,,void
68384,BLOCK,-1,,"{
        lua_pop(L, 1);
    }",12,,134,1,,void
68407,BLOCK,1,,<empty>,,,,1,,void
68415,BLOCK,1,,<empty>,,,,1,,void
68437,BLOCK,1,,<empty>,,,,5,,void
68439,BLOCK,-1,,STAILQ_INIT(&be->io_head),5,,148,1,,void
68494,BLOCK,1,,<empty>,,,,1,,void
68502,BLOCK,-1,,"{
        proxy_lua_error(L, ""out of memory allocating backend"");
        return 0;
    }",27,,159,2,,void
68525,BLOCK,1,,<empty>,,,,1,,void
68533,BLOCK,-1,,"{
        proxy_lua_error(L, ""out of memory allocating backend"");
        return 0;
    }",29,,169,2,,void
68543,BLOCK,1,,<empty>,,,,1,,void
68547,BLOCK,1,,<empty>,,,,3,,void
68559,BLOCK,-1,,"{
        flags |= MCMC_OPTION_TCP_KEEPALIVE;
    }",38,,183,2,,void
68563,BLOCK,1,,<empty>,,,,1,,void
68569,BLOCK,1,,<empty>,,,,3,,void
68598,BLOCK,1,,<empty>,,,,1,,void
68600,BLOCK,-1,,"{
        // FIXME (v2): is this possible? do we ever want to allow blocking
        // connections?
        proxy_lua_ferror(L, ""unexpectedly connected to backend early: %s:%s\n"", be->name, be->port);
        return 0;
    }",35,,189,2,,void
68613,BLOCK,-1,,<empty>,12,,194,1,,void
68618,BLOCK,1,,<empty>,,,,1,,void
68620,BLOCK,-1,,"{
        be->connecting = true;
        be->can_write = false;
    }",43,,194,2,,void
68632,BLOCK,-1,,"{
        proxy_lua_ferror(L, ""failed to connect to backend: %s:%s\n"", be->name, be->port);
        return 0;
    }",12,,197,1,,void
68662,BLOCK,1,,<empty>,,,,1,,void
68667,BLOCK,1,,"STAT_INCR(ctx, backend_total, 1)",5,,211,48,,void
68691,BLOCK,-1,,"{
    mcp_pool_t *p = luaL_checkudata(L, -1, ""mcp.pool"");
    assert(p->refcount == 0);
    pthread_mutex_destroy(&p->lock);

    for (int x = 0; x < p->pool_size; x++) {
        if (p->pool[x].ref) {
            luaL_unref(L, LUA_REGISTRYINDEX, p->pool[x].ref);
        }
    }

    return 0;
}",41,,216,2,,void
68712,BLOCK,-1,,<empty>,5,,221,1,,void
68724,BLOCK,4,,"{
        if (p->pool[x].ref) {
            luaL_unref(L, LUA_REGISTRYINDEX, p->pool[x].ref);
        }
    }",44,,221,4,,void
68733,BLOCK,-1,,"{
            luaL_unref(L, LUA_REGISTRYINDEX, p->pool[x].ref);
        }",29,,222,2,,void
68753,BLOCK,-1,,"{
    char temp[KEY_MAX_LENGTH+1];
    *newlen = klen;
    if (klen > KEY_MAX_LENGTH) {
        // Hedging against potential bugs.
        return key;
    }

    memcpy(temp, key, klen);
    temp[klen+1] = '\0';

    // TODO (v2): memmem would avoid the temp key and memcpy here, but it's
    // not technically portable. An easy improvement would be to detect
    // memmem() in `configure` and only use strstr/copy as a fallback.
    // Since keys are short it's unlikely this would be a major performance
    // win.
    char *found = strstr(temp, conf);

    if (found) {
        *newlen = found - temp;
    }

    // hash stop can't change where keys start.
    return key;
}",109,,233,5,,void
68763,BLOCK,1,,<empty>,,,,1,,void
68765,BLOCK,-1,,"{
        // Hedging against potential bugs.
        return key;
    }",32,,236,2,,void
68787,BLOCK,-1,,"{
        *newlen = found - temp;
    }",16,,251,2,,void
68803,BLOCK,-1,,"{
    *newlen = klen;

    const char *t1 = memchr(key, conf[0], klen);
    if (t1) {
        size_t remain = klen - (t1 - key);
        // must be at least one character inbetween the tags to hash.
        if (remain > 1) {
            const char *t2 = memchr(t1, conf[1], remain);

            if (t2) {
                *newlen = t2 - t1 - 1;
                return t1+1;
            }
        }
    }

    return key;
}",108,,262,5,,void
68819,BLOCK,-1,,"{
        size_t remain = klen - (t1 - key);
        // must be at least one character inbetween the tags to hash.
        if (remain > 1) {
            const char *t2 = memchr(t1, conf[1], remain);

            if (t2) {
                *newlen = t2 - t1 - 1;
                return t1+1;
            }
        }
    }",13,,266,2,,void
68832,BLOCK,-1,,"{
            const char *t2 = memchr(t1, conf[1], remain);

            if (t2) {
                *newlen = t2 - t1 - 1;
                return t1+1;
            }
        }",25,,269,2,,void
68844,BLOCK,-1,,"{
                *newlen = t2 - t1 - 1;
                return t1+1;
            }",21,,272,2,,void
68864,BLOCK,-1,,"{
    luaL_checktype(L, -1, LUA_TTABLE);
    if (lua_getfield(L, -1, ""new"") != LUA_TFUNCTION) {
        proxy_lua_error(L, ""key distribution object missing 'new' function"");
        return;
    }

    // - now create the copy pool table
    lua_createtable(L, p->pool_size, 0); // give the new pool table a sizing hint.
    for (int x = 1; x <= p->pool_size; x++) {
        mcp_backend_t *be = p->pool[x-1].be;
        lua_createtable(L, 0, 4);
        // stack = [p, h, f, optN, newpool, backend]
        // the key should be fine for id? maybe don't need to duplicate
        // this?
        lua_pushinteger(L, x);
        lua_setfield(L, -2, ""id"");
        // we don't use the hostname for ketama hashing
        // so passing ip for hostname is fine
        lua_pushstring(L, be->name);
        lua_setfield(L, -2, ""addr"");
        lua_pushstring(L, be->port);
        lua_setfield(L, -2, ""port"");

        // set the backend table into the new pool table.
        lua_rawseti(L, -2, x);
    ...",60,,282,3,,void
68878,BLOCK,-1,,"{
        proxy_lua_error(L, ""key distribution object missing 'new' function"");
        return;
    }",54,,284,2,,void
68890,BLOCK,-1,,<empty>,5,,291,1,,void
68902,BLOCK,4,,"{
        mcp_backend_t *be = p->pool[x-1].be;
        lua_createtable(L, 0, 4);
        // stack = [p, h, f, optN, newpool, backend]
        // the key should be fine for id? maybe don't need to duplicate
        // this?
        lua_pushinteger(L, x);
        lua_setfield(L, -2, ""id"");
        // we don't use the hostname for ketama hashing
        // so passing ip for hostname is fine
        lua_pushstring(L, be->name);
        lua_setfield(L, -2, ""addr"");
        lua_pushstring(L, be->port);
        lua_setfield(L, -2, ""port"");

        // set the backend table into the new pool table.
        lua_rawseti(L, -2, x);
    }",45,,291,4,,void
68967,BLOCK,-1,,"{
        lua_error(L); // error should be on the stack already.
        return;
    }",24,,319,2,,void
69011,BLOCK,-1,,"{
    int argc = lua_gettop(L);
    luaL_checktype(L, 1, LUA_TTABLE);
    int n = luaL_len(L, 1); // get length of array table

    size_t plen = sizeof(mcp_pool_t) + sizeof(mcp_pool_be_t) * n;
    mcp_pool_t *p = lua_newuserdatauv(L, plen, 0);
    // Zero the memory before use, so we can realibly use __gc to clean up
    memset(p, 0, plen);
    p->pool_size = n;
    // TODO (v2): Nicer if this is fetched from mcp.default_key_hash
    p->key_hasher = XXH3_64bits_withSeed;
    pthread_mutex_init(&p->lock, NULL);
    p->ctx = settings.proxy_ctx; // TODO (v2): store ctx in upvalue.

    luaL_setmetatable(L, ""mcp.pool"");

    lua_pushvalue(L, -1); // dupe self for reference.
    p->self_ref = luaL_ref(L, LUA_REGISTRYINDEX);

    // remember lua arrays are 1 indexed.
    for (int x = 1; x <= n; x++) {
        mcp_pool_be_t *s = &p->pool[x-1];
        lua_geti(L, 1, x); // get next server into the stack.
        // If we bail here, the pool _gc() should handle releasing any backend
      ...",38,,339,2,,void
69058,BLOCK,1,,<empty>,,,,1,,void
69088,BLOCK,-1,,<empty>,5,,360,1,,void
69098,BLOCK,4,,"{
        mcp_pool_be_t *s = &p->pool[x-1];
        lua_geti(L, 1, x); // get next server into the stack.
        // If we bail here, the pool _gc() should handle releasing any backend
        // references we made so far.
        s->be = luaL_checkudata(L, -1, ""mcp.backend"");
        s->ref = luaL_ref(L, LUA_REGISTRYINDEX); // references and pops object.
    }",34,,360,4,,void
69144,BLOCK,-1,,"{
        lua_getglobal(L, ""mcp"");
        // TODO (v2): decide on a mcp.default_dist and use that instead
        if (lua_getfield(L, -1, ""dist_jump_hash"") != LUA_TNIL) {
            _mcplib_pool_dist(L, p);
            lua_pop(L, 1); // pop ""dist_jump_hash"" value.
        } else {
            lua_pop(L, 1);
        }
        lua_pop(L, 1); // pop ""mcp""
        return 1;
    }",40,,371,2,,void
69156,BLOCK,-1,,"{
            _mcplib_pool_dist(L, p);
            lua_pop(L, 1); // pop ""dist_jump_hash"" value.
        }",64,,374,2,,void
69164,BLOCK,-1,,"{
            lua_pop(L, 1);
        }",16,,377,1,,void
69184,BLOCK,-1,,"{
        // overriding the distribution function.
        _mcplib_pool_dist(L, p);
        lua_pop(L, 1); // remove the dist table from stack.
    }",49,,389,2,,void
69192,BLOCK,-1,,"{
        lua_pop(L, 1); // pop the nil.
    }",12,,393,1,,void
69203,BLOCK,-1,,"{
        luaL_checktype(L, -1, LUA_TSTRING);
        const char *f_type = lua_tostring(L, -1);
        if (strcmp(f_type, ""stop"") == 0) {
            p->key_filter = mcp_key_hash_filter_stop;
        } else if (strcmp(f_type, ""tags"") == 0) {
            p->key_filter = mcp_key_hash_filter_tag;
        } else {
            proxy_lua_ferror(L, ""unknown hash filter specified: %s\n"", f_type);
        }

        lua_pop(L, 1); // pops ""filter"" value.

        if (lua_getfield(L, 2, ""filter_conf"") == LUA_TSTRING) {
            size_t len = 0;
            const char *conf = lua_tolstring(L, -1, &len);
            if (len < 2 || len > KEY_HASH_FILTER_MAX) {
                proxy_lua_ferror(L, ""hash filter conf must be between 2 and %d characters"", KEY_HASH_FILTER_MAX);
            }

            memcpy(p->key_filter_conf, conf, len);
            p->key_filter_conf[len+1] = '\0';
        } else {
            proxy_lua_error(L, ""hash filter requires 'filter_conf' string"");
        }
        ...",51,,397,2,,void
69222,BLOCK,-1,,"{
            p->key_filter = mcp_key_hash_filter_stop;
        }",42,,400,2,,void
69229,BLOCK,-1,,<empty>,16,,402,1,,void
69236,BLOCK,-1,,"{
            p->key_filter = mcp_key_hash_filter_tag;
        }",49,,402,2,,void
69243,BLOCK,-1,,"{
            proxy_lua_ferror(L, ""unknown hash filter specified: %s\n"", f_type);
        }",16,,404,1,,void
69258,BLOCK,-1,,"{
            size_t len = 0;
            const char *conf = lua_tolstring(L, -1, &len);
            if (len < 2 || len > KEY_HASH_FILTER_MAX) {
                proxy_lua_ferror(L, ""hash filter conf must be between 2 and %d characters"", KEY_HASH_FILTER_MAX);
            }

            memcpy(p->key_filter_conf, conf, len);
            p->key_filter_conf[len+1] = '\0';
        }",63,,410,2,,void
69280,BLOCK,1,,<empty>,,,,1,,void
69282,BLOCK,-1,,"{
                proxy_lua_ferror(L, ""hash filter conf must be between 2 and %d characters"", KEY_HASH_FILTER_MAX);
            }",55,,413,2,,void
69287,BLOCK,1,,<empty>,,,,1,,void
69305,BLOCK,-1,,"{
            proxy_lua_error(L, ""hash filter requires 'filter_conf' string"");
        }",16,,419,1,,void
69313,BLOCK,-1,,"{
        lua_pop(L, 1); // pop the nil.
    }",12,,423,1,,void
69324,BLOCK,-1,,"{
        luaL_checktype(L, -1, LUA_TLIGHTUSERDATA);
        struct proxy_hash_func *phf = lua_touserdata(L, -1);
        p->key_hasher = phf->func;
        lua_pop(L, 1);
    }",49,,427,2,,void
69348,BLOCK,-1,,"{
        lua_pop(L, 1); // pop the nil.
    }",12,,432,1,,void
69359,BLOCK,-1,,"{
        luaL_checktype(L, -1, LUA_TSTRING);
        size_t seedlen;
        const char *seedstr = lua_tolstring(L, -1, &seedlen);
        // Note: the custom hasher for a dist may be ""weird"" in some cases, so
        // we use a standard hash method for the seed here.
        // I'm open to changing this (ie; mcp.pool_seed_hasher = etc)
        p->hash_seed = XXH3_64bits(seedstr, seedlen);

        lua_pop(L, 1);
    }",49,,436,2,,void
69380,BLOCK,1,,<empty>,,,,3,,void
69388,BLOCK,-1,,"{
        lua_pop(L, 1); // pop the nil.
    }",12,,446,1,,void
69400,BLOCK,-1,,"{
        proxy_lua_error(L, ""cannot create pool missing 'dist' argument"");
    }",39,,450,2,,void
69410,BLOCK,-1,,"{
    mcp_pool_proxy_t *pp = luaL_checkudata(L, -1, ""mcp.pool_proxy"");
    mcp_pool_t *p = pp->main;
    pthread_mutex_lock(&p->lock);
    p->refcount--;
    if (p->refcount == 0) {
        proxy_ctx_t *ctx = p->ctx;
        pthread_mutex_lock(&ctx->manager_lock);
        STAILQ_INSERT_TAIL(&ctx->manager_head, p, next);
        pthread_cond_signal(&ctx->manager_cond);
        pthread_mutex_unlock(&ctx->manager_lock);
    }
    pthread_mutex_unlock(&p->lock);

    return 0;
}",47,,457,2,,void
69440,BLOCK,-1,,"{
        proxy_ctx_t *ctx = p->ctx;
        pthread_mutex_lock(&ctx->manager_lock);
        STAILQ_INSERT_TAIL(&ctx->manager_head, p, next);
        pthread_cond_signal(&ctx->manager_cond);
        pthread_mutex_unlock(&ctx->manager_lock);
    }",27,,462,2,,void
69458,BLOCK,1,,<empty>,,,,8,,void
69460,BLOCK,-1,,"STAILQ_INSERT_TAIL(&ctx->manager_head, p, next)",9,,465,1,,void
69515,BLOCK,-1,,"{
    if (p->key_filter) {
        key = p->key_filter(p->key_filter_conf, key, len, &len);
        P_DEBUG(""%s: filtered key for hashing (%.*s)\n"", __func__, (int)len, key);
    }
    uint64_t hash = p->key_hasher(key, len, p->hash_seed);
    uint32_t lookup = p->phc.selector_func(hash, p->phc.ctx);

    assert(p->phc.ctx != NULL);
    // attach the backend to the request object.
    // the lua modules should ""think"" in 1 based indexes, so we need to
    // subtract one here.
    if (lookup >= p->pool_size) {
        proxy_lua_error(L, ""key dist hasher tried to use out of bounds index"");
    }

    return p->pool[lookup].be;
}",104,,474,5,,void
69520,BLOCK,-1,,"{
        key = p->key_filter(p->key_filter_conf, key, len, &len);
        P_DEBUG(""%s: filtered key for hashing (%.*s)\n"", __func__, (int)len, key);
    }",24,,475,2,,void
69575,BLOCK,-1,,"{
        proxy_lua_error(L, ""key dist hasher tried to use out of bounds index"");
    }",33,,486,2,,void
69591,BLOCK,-1,,"{
    // internal args are the hash selector (self)
    mcp_pool_proxy_t *pp = luaL_checkudata(L, -2, ""mcp.pool_proxy"");
    mcp_pool_t *p = pp->main;
    // then request object.
    mcp_request_t *rq = luaL_checkudata(L, -1, ""mcp.request"");

    // we have a fast path to the key/length.
    if (!rq->pr.keytoken) {
        proxy_lua_error(L, ""cannot route commands without key"");
        return 0;
    }
    const char *key = MCP_PARSER_KEY(rq->pr);
    size_t len = rq->pr.klen;
    rq->be = mcplib_pool_proxy_call_helper(L, p, key, len);

    // now yield request, pool up.
    return lua_yield(L, 2);
}",49,,495,2,,void
69621,BLOCK,-1,,"{
        proxy_lua_error(L, ""cannot route commands without key"");
        return 0;
    }",27,,503,2,,void
69634,BLOCK,1,,<empty>,,,,5,,void
69678,BLOCK,-1,,"{
    luaL_checktype(L, -1, LUA_TBOOLEAN);
    int state = lua_toboolean(L, -1);
    proxy_ctx_t *ctx = settings.proxy_ctx; // FIXME (v2): get global ctx reference in thread/upvalue.

    STAT_L(ctx);
    ctx->tunables.tcp_keepalive = state;
    STAT_UL(ctx);

    return 0;
}",47,,515,2,,void
69699,BLOCK,1,,<empty>,,,,3,,void
69714,BLOCK,1,,<empty>,,,,3,,void
69726,BLOCK,-1,,"{
    int limit = luaL_checkinteger(L, -1);
    proxy_ctx_t *ctx = settings.proxy_ctx; // FIXME (v2): get global ctx reference in thread/upvalue.

    if (limit < 0) {
        proxy_lua_error(L, ""backend_failure_limit must be >= 0"");
        return 0;
    }

    STAT_L(ctx);
    ctx->tunables.backend_failure_limit = limit;
    STAT_UL(ctx);

    return 0;
}",55,,527,2,,void
69744,BLOCK,-1,,"{
        proxy_lua_error(L, ""backend_failure_limit must be >= 0"");
        return 0;
    }",20,,531,2,,void
69752,BLOCK,1,,<empty>,,,,3,,void
69767,BLOCK,1,,<empty>,,,,3,,void
69779,BLOCK,-1,,"{
    lua_Number secondsf = luaL_checknumber(L, -1);
    lua_Integer secondsi = (lua_Integer) secondsf;
    lua_Number subseconds = secondsf - secondsi;
    proxy_ctx_t *ctx = settings.proxy_ctx; // FIXME (v2): get global ctx reference in thread/upvalue.

    STAT_L(ctx);
    ctx->tunables.connect.tv_sec = secondsi;
    ctx->tunables.connect.tv_usec = MICROSECONDS(subseconds);
#ifdef HAVE_LIBURING
    ctx->tunables.connect_ur.tv_sec = secondsi;
    ctx->tunables.connect_ur.tv_nsec = NANOSECONDS(subseconds);
#endif
    STAT_UL(ctx);

    return 0;
}",57,,547,2,,void
69807,BLOCK,1,,<empty>,,,,3,,void
69832,BLOCK,1,,<empty>,,,,3,,void
69840,BLOCK,1,,<empty>,,,,3,,void
69852,BLOCK,-1,,"{
    lua_Number secondsf = luaL_checknumber(L, -1);
    lua_Integer secondsi = (lua_Integer) secondsf;
    lua_Number subseconds = secondsf - secondsi;
    proxy_ctx_t *ctx = settings.proxy_ctx; // FIXME (v2): get global ctx reference in thread/upvalue.

    STAT_L(ctx);
    ctx->tunables.retry.tv_sec = secondsi;
    ctx->tunables.retry.tv_usec = MICROSECONDS(subseconds);
#ifdef HAVE_LIBURING
    ctx->tunables.retry_ur.tv_sec = secondsi;
    ctx->tunables.retry_ur.tv_nsec = NANOSECONDS(subseconds);
#endif
    STAT_UL(ctx);

    return 0;
}",55,,565,2,,void
69880,BLOCK,1,,<empty>,,,,3,,void
69905,BLOCK,1,,<empty>,,,,3,,void
69913,BLOCK,1,,<empty>,,,,3,,void
69925,BLOCK,-1,,"{
    lua_Number secondsf = luaL_checknumber(L, -1);
    lua_Integer secondsi = (lua_Integer) secondsf;
    lua_Number subseconds = secondsf - secondsi;
    proxy_ctx_t *ctx = settings.proxy_ctx; // FIXME (v2): get global ctx reference in thread/upvalue.

    STAT_L(ctx);
    ctx->tunables.read.tv_sec = secondsi;
    ctx->tunables.read.tv_usec = MICROSECONDS(subseconds);
#ifdef HAVE_LIBURING
    ctx->tunables.read_ur.tv_sec = secondsi;
    ctx->tunables.read_ur.tv_nsec = NANOSECONDS(subseconds);
#endif
    STAT_UL(ctx);

    return 0;
}",54,,583,2,,void
69953,BLOCK,1,,<empty>,,,,3,,void
69978,BLOCK,1,,<empty>,,,,3,,void
69986,BLOCK,1,,<empty>,,,,3,,void
69998,BLOCK,-1,,"{
    // Pull the original worker thread out of the shared mcplib upvalue.
    LIBEVENT_THREAD *t = lua_touserdata(L, lua_upvalueindex(MCP_THREAD_UPVALUE));

    int hook = luaL_checkinteger(L, 1);
    // pushvalue to dupe func and etc.
    // can leave original func on stack afterward because it'll get cleared.
    int loop_end = 0;
    int loop_start = 1;
    if (hook == CMD_ANY) {
        // if CMD_ANY we need individually set loop 1 to CMD_SIZE.
        loop_end = CMD_SIZE;
    } else if (hook == CMD_ANY_STORAGE) {
        // if CMD_ANY_STORAGE we only override get/set/etc.
        loop_end = CMD_END_STORAGE;
    } else {
        loop_start = hook;
        loop_end = hook + 1;
    }

    if (lua_isfunction(L, 2)) {
        struct proxy_hook *hooks = t->proxy_hooks;
        uint64_t tag = 0; // listener socket tag

        if (lua_isstring(L, 3)) {
            size_t len;
            const char *stag = lua_tolstring(L, 3, &len);
            if (len < 1 || len > 8) {
             ...",40,,603,2,,void
70006,BLOCK,1,,<empty>,,,,1,,void
70026,BLOCK,-1,,"{
        // if CMD_ANY we need individually set loop 1 to CMD_SIZE.
        loop_end = CMD_SIZE;
    }",26,,612,2,,void
70031,BLOCK,-1,,<empty>,12,,615,1,,void
70036,BLOCK,-1,,"{
        // if CMD_ANY_STORAGE we only override get/set/etc.
        loop_end = CMD_END_STORAGE;
    }",41,,615,2,,void
70041,BLOCK,-1,,"{
        loop_start = hook;
        loop_end = hook + 1;
    }",12,,618,1,,void
70054,BLOCK,-1,,"{
        struct proxy_hook *hooks = t->proxy_hooks;
        uint64_t tag = 0; // listener socket tag

        if (lua_isstring(L, 3)) {
            size_t len;
            const char *stag = lua_tolstring(L, 3, &len);
            if (len < 1 || len > 8) {
                proxy_lua_error(L, ""mcp.attach: tag must be 1 to 8 characters"");
                return 0;
            }
            memcpy(&tag, stag, len);
        }

        for (int x = loop_start; x < loop_end; x++) {
            struct proxy_hook *h = &hooks[x];
            lua_pushvalue(L, 2); // duplicate the function for the ref.

            if (tag) {
                // listener was tagged. use the extended hook structure.
                struct proxy_hook_tagged *pht = h->tagged;

                if (h->tagcount == 0) {
                    pht = calloc(1, sizeof(struct proxy_hook_tagged));
                    if (pht == NULL) {
                        proxy_lua_error(L, ""mcp.attach: failure allocating tagged hooks"");
 ...",31,,623,2,,void
70069,BLOCK,-1,,"{
            size_t len;
            const char *stag = lua_tolstring(L, 3, &len);
            if (len < 1 || len > 8) {
                proxy_lua_error(L, ""mcp.attach: tag must be 1 to 8 characters"");
                return 0;
            }
            memcpy(&tag, stag, len);
        }",33,,627,2,,void
70087,BLOCK,-1,,"{
                proxy_lua_error(L, ""mcp.attach: tag must be 1 to 8 characters"");
                return 0;
            }",37,,630,2,,void
70099,BLOCK,-1,,<empty>,9,,637,1,,void
70109,BLOCK,4,,"{
            struct proxy_hook *h = &hooks[x];
            lua_pushvalue(L, 2); // duplicate the function for the ref.

            if (tag) {
                // listener was tagged. use the extended hook structure.
                struct proxy_hook_tagged *pht = h->tagged;

                if (h->tagcount == 0) {
                    pht = calloc(1, sizeof(struct proxy_hook_tagged));
                    if (pht == NULL) {
                        proxy_lua_error(L, ""mcp.attach: failure allocating tagged hooks"");
                        return 0;
                    }
                    h->tagcount = 1;
                    h->tagged = pht;
                }

                bool found = false;
                for (int x = 0; x < h->tagcount; x++) {
                    if (pht->tag == tag) {
                        if (pht->lua_ref) {
                            // Found existing tagged hook.
                            luaL_unref(L, LUA_REGISTRYINDEX, pht->lua_ref);
                ...",53,,637,4,,void
70122,BLOCK,-1,,"{
                // listener was tagged. use the extended hook structure.
                struct proxy_hook_tagged *pht = h->tagged;

                if (h->tagcount == 0) {
                    pht = calloc(1, sizeof(struct proxy_hook_tagged));
                    if (pht == NULL) {
                        proxy_lua_error(L, ""mcp.attach: failure allocating tagged hooks"");
                        return 0;
                    }
                    h->tagcount = 1;
                    h->tagged = pht;
                }

                bool found = false;
                for (int x = 0; x < h->tagcount; x++) {
                    if (pht->tag == tag) {
                        if (pht->lua_ref) {
                            // Found existing tagged hook.
                            luaL_unref(L, LUA_REGISTRYINDEX, pht->lua_ref);
                        }

                        pht->lua_ref = luaL_ref(L, LUA_REGISTRYINDEX);
                        assert(pht->lua_ref != 0);
         ...",22,,641,2,,void
70135,BLOCK,-1,,"{
                    pht = calloc(1, sizeof(struct proxy_hook_tagged));
                    if (pht == NULL) {
                        proxy_lua_error(L, ""mcp.attach: failure allocating tagged hooks"");
                        return 0;
                    }
                    h->tagcount = 1;
                    h->tagged = pht;
                }",39,,645,2,,void
70146,BLOCK,-1,,"{
                        proxy_lua_error(L, ""mcp.attach: failure allocating tagged hooks"");
                        return 0;
                    }",38,,647,2,,void
70167,BLOCK,-1,,<empty>,17,,656,1,,void
70179,BLOCK,4,,"{
                    if (pht->tag == tag) {
                        if (pht->lua_ref) {
                            // Found existing tagged hook.
                            luaL_unref(L, LUA_REGISTRYINDEX, pht->lua_ref);
                        }

                        pht->lua_ref = luaL_ref(L, LUA_REGISTRYINDEX);
                        assert(pht->lua_ref != 0);
                        found = true;
                        break;
                    } else if (pht->tag == 0) {
                        // no tag in this slot, so we use it.
                        pht->lua_ref = luaL_ref(L, LUA_REGISTRYINDEX);
                        pht->tag = tag;
                        assert(pht->lua_ref != 0);
                        found = true;
                        break;
                    }
                    pht++;
                }",55,,656,4,,void
70186,BLOCK,-1,,"{
                        if (pht->lua_ref) {
                            // Found existing tagged hook.
                            luaL_unref(L, LUA_REGISTRYINDEX, pht->lua_ref);
                        }

                        pht->lua_ref = luaL_ref(L, LUA_REGISTRYINDEX);
                        assert(pht->lua_ref != 0);
                        found = true;
                        break;
                    }",42,,657,2,,void
70191,BLOCK,-1,,"{
                            // Found existing tagged hook.
                            luaL_unref(L, LUA_REGISTRYINDEX, pht->lua_ref);
                        }",43,,658,2,,void
70216,BLOCK,-1,,<empty>,28,,667,1,,void
70223,BLOCK,-1,,"{
                        // no tag in this slot, so we use it.
                        pht->lua_ref = luaL_ref(L, LUA_REGISTRYINDEX);
                        pht->tag = tag;
                        assert(pht->lua_ref != 0);
                        found = true;
                        break;
                    }",47,,667,2,,void
70251,BLOCK,-1,,"{
                    pht = realloc(h->tagged, sizeof(struct proxy_hook_tagged) * (h->tagcount+1));
                    if (!pht) {
                        proxy_lua_error(L, ""mcp.attach: failure to resize tagged hooks"");
                        return 0;
                    }

                    pht[h->tagcount].lua_ref = luaL_ref(L, LUA_REGISTRYINDEX);
                    pht[h->tagcount].tag = tag;

                    h->tagcount++;
                    h->tagged = pht;
                }",29,,679,2,,void
70269,BLOCK,-1,,"{
                        proxy_lua_error(L, ""mcp.attach: failure to resize tagged hooks"");
                        return 0;
                    }",31,,681,2,,void
70305,BLOCK,-1,,"{
                if (h->lua_ref) {
                    // remove existing reference.
                    luaL_unref(L, LUA_REGISTRYINDEX, h->lua_ref);
                }

                // pops the function from the stack and leaves us a ref. for later.
                h->lua_ref = luaL_ref(L, LUA_REGISTRYINDEX);
                assert(h->lua_ref != 0);
            }",20,,693,1,,void
70310,BLOCK,-1,,"{
                    // remove existing reference.
                    luaL_unref(L, LUA_REGISTRYINDEX, h->lua_ref);
                }",33,,694,2,,void
70331,BLOCK,-1,,"{
        proxy_lua_error(L, ""Must pass a function to mcp.attach"");
        return 0;
    }",12,,704,1,,void
70343,BLOCK,-1,,"{
    LIBEVENT_THREAD *t = lua_touserdata(L, lua_upvalueindex(MCP_THREAD_UPVALUE));
    const char *msg = luaL_checkstring(L, -1);
    LOGGER_LOG(t->l, LOG_PROXYUSER, LOGGER_PROXY_USER, NULL, msg);
    return 0;
}",37,,714,2,,void
70351,BLOCK,1,,<empty>,,,,1,,void
70366,BLOCK,1,,<empty>,,,,9,,void
70368,BLOCK,-1,,"LOGGER_LOG(t->l, LOG_PROXYUSER, LOGGER_PROXY_USER, NULL, msg)",5,,717,1,,void
70381,BLOCK,-1,,<empty>,5,,717,2,,void
70396,BLOCK,-1,,<empty>,5,,717,2,,void
70409,BLOCK,-1,,"{
    LIBEVENT_THREAD *t = lua_touserdata(L, lua_upvalueindex(MCP_THREAD_UPVALUE));
    logger *l = t->l;
    // Not using the LOGGER_LOG macro so we can avoid as much overhead as
    // possible when logging is disabled.
    if (! (l->eflags & LOG_PROXYREQS)) {
        return 0;
    }
    int rtype = 0;
    int rcode = 0;
    int rstatus = 0;
    char *rname = NULL;
    char *rport = NULL;

    mcp_request_t *rq = luaL_checkudata(L, 1, ""mcp.request"");
    int type = lua_type(L, 2);
    if (type == LUA_TUSERDATA) {
        mcp_resp_t *rs = luaL_checkudata(L, 2, ""mcp.response"");
        rtype = rs->resp.type;
        rcode = rs->resp.code;
        rstatus = rs->status;
        rname = rs->be_name;
        rport = rs->be_port;
    }
    size_t dlen = 0;
    const char *detail = luaL_optlstring(L, 3, NULL, &dlen);

    struct timeval end;
    gettimeofday(&end, NULL);
    long elapsed = (end.tv_sec - rq->start.tv_sec) * 1000000 + (end.tv_usec - rq->start.tv_usec);

    logger_log(l, LO...",41,,722,2,,void
70417,BLOCK,1,,<empty>,,,,1,,void
70432,BLOCK,1,,<empty>,,,,1,,void
70436,BLOCK,-1,,"{
        return 0;
    }",40,,727,2,,void
70476,BLOCK,-1,,"{
        mcp_resp_t *rs = luaL_checkudata(L, 2, ""mcp.response"");
        rtype = rs->resp.type;
        rcode = rs->resp.code;
        rstatus = rs->status;
        rname = rs->be_name;
        rport = rs->be_port;
    }",32,,738,2,,void
70584,BLOCK,-1,,"{
    return (x << k) | (x >> (32 - k));
}",55,,758,3,,void
70599,BLOCK,-1,,"{
    const uint32_t result = _rotl(s[0] + s[3], 7) + s[0];

    const uint32_t t = s[1] << 9;

    s[2] ^= s[0];
    s[3] ^= s[1];
    s[1] ^= s[2];
    s[0] ^= s[3];

    s[2] ^= t;

    s[3] = _rotl(s[3], 11);

    return result;
}",40,,763,2,,void
70672,BLOCK,-1,,"{
    LIBEVENT_THREAD *t = lua_touserdata(L, lua_upvalueindex(MCP_THREAD_UPVALUE));
    logger *l = t->l;
    // Not using the LOGGER_LOG macro so we can avoid as much overhead as
    // possible when logging is disabled.
    if (! (l->eflags & LOG_PROXYREQS)) {
        return 0;
    }
    int rtype = 0;
    int rcode = 0;
    int rstatus = 0;
    char *rname = NULL;
    char *rport = NULL;

    int ms = luaL_checkinteger(L, 1);
    int rate = luaL_checkinteger(L, 2);
    int allerr = lua_toboolean(L, 3);
    mcp_request_t *rq = luaL_checkudata(L, 4, ""mcp.request"");
    int type = lua_type(L, 5);
    if (type == LUA_TUSERDATA) {
        mcp_resp_t *rs = luaL_checkudata(L, 5, ""mcp.response"");
        rtype = rs->resp.type;
        rcode = rs->resp.code;
        rstatus = rs->status;
        rname = rs->be_name;
        rport = rs->be_port;
    }
    size_t dlen = 0;
    const char *detail = luaL_optlstring(L, 6, NULL, &dlen);

    struct timeval end;
    gettimeofday(&end, NULL);
   ...",47,,782,2,,void
70680,BLOCK,1,,<empty>,,,,1,,void
70695,BLOCK,1,,<empty>,,,,1,,void
70699,BLOCK,-1,,"{
        return 0;
    }",40,,787,2,,void
70757,BLOCK,-1,,"{
        mcp_resp_t *rs = luaL_checkudata(L, 5, ""mcp.response"");
        rtype = rs->resp.type;
        rcode = rs->resp.code;
        rstatus = rs->status;
        rname = rs->be_name;
        rport = rs->be_port;
    }",32,,801,2,,void
70846,BLOCK,1,,<empty>,,,,1,,void
70848,BLOCK,-1,,"{
        do_log = true;
    }",39,,817,2,,void
70853,BLOCK,-1,,<empty>,12,,819,1,,void
70864,BLOCK,-1,,"{
        do_log = true;
    }",47,,819,2,,void
70869,BLOCK,-1,,<empty>,12,,821,1,,void
70874,BLOCK,-1,,"{
        // slightly biased random-to-rate without adding a loop, which is
        // completely fine for this use case.
        uint32_t rnd = (uint64_t)_nextrand(t->proxy_rng) * (uint64_t)rate >> 32;
        if (rnd == 0) {
            do_log = true;
        }
    }",26,,821,2,,void
70894,BLOCK,-1,,"{
            do_log = true;
        }",23,,825,2,,void
70900,BLOCK,-1,,"{
        logger_log(l, LOGGER_PROXY_REQ, NULL, rq->pr.request, rq->pr.reqlen, elapsed, rtype, rcode, rstatus, detail, dlen, rname, rport);
    }",17,,830,2,,void
70929,BLOCK,-1,,"{
#define X(x) \
    lua_pushinteger(L, x); \
    lua_setfield(L, -2, #x);

    X(MCMC_CODE_STORED);
    X(MCMC_CODE_EXISTS);
    X(MCMC_CODE_DELETED);
    X(MCMC_CODE_TOUCHED);
    X(MCMC_CODE_VERSION);
    X(MCMC_CODE_NOT_FOUND);
    X(MCMC_CODE_NOT_STORED);
    X(MCMC_CODE_OK);
    X(MCMC_CODE_NOP);
    X(MCMC_CODE_MISS);
    X(P_OK);
    X(CMD_ANY);
    X(CMD_ANY_STORAGE);
    X(AWAIT_GOOD);
    X(AWAIT_ANY);
    X(AWAIT_OK);
    X(AWAIT_FIRST);
    CMD_FIELDS
#undef X
}",50,,842,2,,void
70931,BLOCK,1,,<empty>,,,,1,,void
70941,BLOCK,1,,<empty>,,,,1,,void
70951,BLOCK,1,,<empty>,,,,1,,void
70961,BLOCK,1,,<empty>,,,,1,,void
70971,BLOCK,1,,<empty>,,,,1,,void
70981,BLOCK,1,,<empty>,,,,1,,void
70991,BLOCK,1,,<empty>,,,,1,,void
71001,BLOCK,1,,<empty>,,,,1,,void
71011,BLOCK,1,,<empty>,,,,1,,void
71021,BLOCK,1,,<empty>,,,,1,,void
71032,BLOCK,1,,<empty>,,,,2,,void
71043,BLOCK,1,,<empty>,,,,2,,void
71054,BLOCK,1,,<empty>,,,,2,,void
71065,BLOCK,1,,<empty>,,,,2,,void
71076,BLOCK,1,,<empty>,,,,2,,void
71087,BLOCK,1,,<empty>,,,,2,,void
71098,BLOCK,1,,<empty>,,,,2,,void
71108,BLOCK,1,,<empty>,,,,1,,void
71386,BLOCK,-1,,"{
    lua_State *L = ctx;

    const struct luaL_Reg mcplib_backend_m[] = {
        {""set"", NULL},
        {""__gc"", mcplib_backend_gc},
        {NULL, NULL}
    };

    const struct luaL_Reg mcplib_request_m[] = {
        {""command"", mcplib_request_command},
        {""key"", mcplib_request_key},
        {""ltrimkey"", mcplib_request_ltrimkey},
        {""rtrimkey"", mcplib_request_rtrimkey},
        {""token"", mcplib_request_token},
        {""ntokens"", mcplib_request_ntokens},
        {""has_flag"", mcplib_request_has_flag},
        {""flag_token"", mcplib_request_flag_token},
        {""__tostring"", NULL},
        {""__gc"", mcplib_request_gc},
        {NULL, NULL}
    };

    const struct luaL_Reg mcplib_response_m[] = {
        {""ok"", mcplib_response_ok},
        {""hit"", mcplib_response_hit},
        {""vlen"", mcplib_response_vlen},
        {""code"", mcplib_response_code},
        {""line"", mcplib_response_line},
        {""__gc"", mcplib_response_gc},
        {NULL, NULL}
    };

    const struct...",56,,869,3,,void
71702,BLOCK,-1,,<empty>,1,,1,1,,ANY
71707,BLOCK,-1,,<empty>,,,,4,,<empty>
71714,BLOCK,-1,,<empty>,,,,4,,<empty>
71721,BLOCK,-1,,<empty>,,,,4,,<empty>
71726,BLOCK,-1,,<empty>,,,,2,,<empty>
71732,BLOCK,-1,,<empty>,,,,3,,<empty>
71741,BLOCK,-1,,<empty>,,,,6,,<empty>
71746,BLOCK,-1,,<empty>,,,,2,,<empty>
71751,BLOCK,-1,,"{
    io_head_t head;

    STAILQ_INIT(&head);
    STAILQ_INIT(&t->be_head);

    // Pull the entire stack of inbound into local queue.
    pthread_mutex_lock(&t->mutex);
    STAILQ_CONCAT(&head, &t->io_head_in);
    pthread_mutex_unlock(&t->mutex);

    int io_count = 0;
    int be_count = 0;
    while (!STAILQ_EMPTY(&head)) {
        io_pending_proxy_t *io = STAILQ_FIRST(&head);
        io->flushed = false;
        mcp_backend_t *be = io->backend;
        // So the backend can retrieve its event base.
        be->event_thread = t;

        // _no_ mutex on backends. they are owned by the event thread.
        STAILQ_REMOVE_HEAD(&head, io_next);
        // paranoia about moving items between lists.
        io->io_next.stqe_next = NULL;

        if (be->bad) {
            P_DEBUG(""%s: fast failing request to bad backend\n"", __func__);
            io->client_resp->status = MCMC_ERR;
            return_io_pending((io_pending_t *)io);
            continue;
        }
        STAILQ_INSE...",66,,14,2,,void
71756,BLOCK,1,,<empty>,,,,5,,void
71758,BLOCK,-1,,STAILQ_INIT(&head),5,,17,1,,void
71781,BLOCK,1,,<empty>,,,,2,,void
71783,BLOCK,-1,,STAILQ_INIT(&t->be_head),5,,18,1,,void
71819,BLOCK,1,,<empty>,,,,5,,void
71821,BLOCK,-1,,"STAILQ_CONCAT(&head, &t->io_head_in)",5,,22,1,,void
71832,BLOCK,-1,,"STAILQ_CONCAT(&head, &t->io_head_in)",5,,22,2,,void
71857,BLOCK,-1,,"STAILQ_CONCAT(&head, &t->io_head_in)",5,,22,1,,void
71900,BLOCK,1,,<empty>,,,,3,,void
71907,BLOCK,-1,,"{
        io_pending_proxy_t *io = STAILQ_FIRST(&head);
        io->flushed = false;
        mcp_backend_t *be = io->backend;
        // So the backend can retrieve its event base.
        be->event_thread = t;

        // _no_ mutex on backends. they are owned by the event thread.
        STAILQ_REMOVE_HEAD(&head, io_next);
        // paranoia about moving items between lists.
        io->io_next.stqe_next = NULL;

        if (be->bad) {
            P_DEBUG(""%s: fast failing request to bad backend\n"", __func__);
            io->client_resp->status = MCMC_ERR;
            return_io_pending((io_pending_t *)io);
            continue;
        }
        STAILQ_INSERT_TAIL(&be->io_head, io, io_next);
        be->depth++;
        io_count++;
        if (!be->stacked) {
            be->stacked = true;
            // more paranoia about be_next not being overwritten
            be->be_next.stqe_next = NULL;
            STAILQ_INSERT_TAIL(&t->be_head, be, be_next);
            be_count++;
  ...",34,,27,2,,void
71914,BLOCK,1,,<empty>,,,,3,,void
71938,BLOCK,1,,<empty>,,,,6,,void
71940,BLOCK,-1,,"STAILQ_REMOVE_HEAD(&head, io_next)",9,,35,1,,void
71957,BLOCK,-1,,<empty>,9,,35,2,,void
71980,BLOCK,-1,,"{
            P_DEBUG(""%s: fast failing request to bad backend\n"", __func__);
            io->client_resp->status = MCMC_ERR;
            return_io_pending((io_pending_t *)io);
            continue;
        }",22,,39,2,,void
71988,BLOCK,1,,<empty>,,,,1,,void
72002,BLOCK,1,,<empty>,,,,8,,void
72004,BLOCK,-1,,"STAILQ_INSERT_TAIL(&be->io_head, io, io_next)",9,,45,1,,void
72046,BLOCK,-1,,"{
            be->stacked = true;
            // more paranoia about be_next not being overwritten
            be->be_next.stqe_next = NULL;
            STAILQ_INSERT_TAIL(&t->be_head, be, be_next);
            be_count++;
        }",27,,48,2,,void
72065,BLOCK,1,,<empty>,,,,6,,void
72067,BLOCK,-1,,"STAILQ_INSERT_TAIL(&t->be_head, be, be_next)",13,,52,1,,void
72108,BLOCK,-1,,"{
    proxy_event_thread_t *t = arg;
    proxy_ctx_t *ctx = t->ctx;

    // TODO (v2): double check how much of this boilerplate is still necessary?
    // reschedule the clock event.
    evtimer_del(&t->clock_event);

    evtimer_set(&t->clock_event, proxy_event_updater, t);
    event_base_set(t->base, &t->clock_event);
    struct timeval rate = {.tv_sec = 3, .tv_usec = 0};
    evtimer_add(&t->clock_event, &rate);

    // we reuse the ""global stats"" lock since it's hardly ever used.
    STAT_L(ctx);
    memcpy(&t->tunables, &ctx->tunables, sizeof(t->tunables));
    STAT_UL(ctx);
}",77,,386,4,,void
72143,BLOCK,1,,<empty>,28,,396,1,,void
72147,BLOCK,2,,<empty>,41,,396,2,,void
72160,BLOCK,1,,<empty>,,,,3,,void
72181,BLOCK,1,,<empty>,,,,3,,void
72193,BLOCK,-1,,"{
    proxy_event_thread_t *t = arg;

#ifdef USE_EVENTFD
    uint64_t u;
    if (read(fd, &u, sizeof(uint64_t)) != sizeof(uint64_t)) {
        // Temporary error or wasn't actually ready to read somehow.
        return;
    }
#else
    char buf[1];
    // TODO (v2): This is a lot more fatal than it should be. can it fail? can
    // it blow up the server?
    // TODO (v2): a cross-platform method of speeding this up would be nice. With
    // event fds we can queue N events and wakeup once here.
    // If we're pulling one byte out of the pipe at a time here it'll just
    // wake us up too often.
    // If the pipe is O_NONBLOCK then maybe just a larger read would work?
    if (read(fd, buf, 1) != 1) {
        P_DEBUG(""%s: pipe read failed\n"", __func__);
        return;
    }
#endif

    if (_proxy_event_handler_dequeue(t) == 0) {
        //P_DEBUG(""%s: no IO's to complete\n"", __func__);
        return;
    }

    // Re-walk each backend and check set event as required.
    mcp_bac...",77,,406,4,,void
72206,BLOCK,-1,,"{
        P_DEBUG(""%s: pipe read failed\n"", __func__);
        return;
    }",32,,424,2,,void
72213,BLOCK,-1,,"{
        //P_DEBUG(""%s: no IO's to complete\n"", __func__);
        return;
    }",47,,430,2,,void
72234,BLOCK,1,,<empty>,,,,21,,void
72236,BLOCK,-1,,<empty>,5,,440,1,,void
72253,BLOCK,4,,"{
        be->stacked = false;
        int flags = 0;

        if (be->connecting) {
            P_DEBUG(""%s: deferring IO pending connecting\n"", __func__);
        } else {
            flags = _flush_pending_write(be);
        }

        if (flags == -1) {
            _reset_bad_backend(be, P_BE_FAIL_WRITING);
        } else {
            flags = be->can_write ? EV_READ|EV_TIMEOUT : EV_READ|EV_WRITE|EV_TIMEOUT;
            _set_event(be, t->base, flags, tmp_time, proxy_backend_handler);
        }
    }",46,,440,4,,void
72267,BLOCK,-1,,"{
            P_DEBUG(""%s: deferring IO pending connecting\n"", __func__);
        }",29,,444,2,,void
72269,BLOCK,-1,,"{
            flags = _flush_pending_write(be);
        }",16,,446,1,,void
72279,BLOCK,-1,,"{
            _reset_bad_backend(be, P_BE_FAIL_WRITING);
        }",26,,450,2,,void
72284,BLOCK,-1,,"{
            flags = be->can_write ? EV_READ|EV_TIMEOUT : EV_READ|EV_WRITE|EV_TIMEOUT;
            _set_event(be, t->base, flags, tmp_time, proxy_backend_handler);
        }",16,,452,1,,void
72311,BLOCK,-1,,"{
    proxy_event_thread_t *t = arg;

    logger_create(); // TODO (v2): add logger ptr to structure
    event_base_loop(t->base, 0);
    event_base_free(t->base);

    // TODO (v2): join bt threads, free array.

    return NULL;
}",37,,460,2,,void
72336,BLOCK,-1,,"{
    // FIXME (v2): chicken and egg.
    // can't check if pending if the structure is was calloc'ed (sigh)
    // don't want to double test here. should be able to event_assign but
    // not add anything during initialization, but need the owner thread's
    // event base.
    int pending = 0;
    if (event_initialized(&be->event)) {
        pending = event_pending(&be->event, EV_READ|EV_WRITE|EV_TIMEOUT, NULL);
    }
    if ((pending & (EV_READ|EV_WRITE|EV_TIMEOUT)) != 0) {
            event_del(&be->event); // replace existing event.
    }

    // if we can't write, we could be connecting.
    // TODO (v2): always check for READ in case some commands were sent
    // successfully? The flags could be tracked on *be and reset in the
    // handler, perhaps?
    event_assign(&be->event, base, mcmc_fd(be->client),
            flags, callback, be);
    event_add(&be->event, &t);
}",125,,473,6,,void
72347,BLOCK,-1,,"{
        pending = event_pending(&be->event, EV_READ|EV_WRITE|EV_TIMEOUT, NULL);
    }",40,,480,2,,void
72371,BLOCK,-1,,"{
            event_del(&be->event); // replace existing event.
    }",57,,483,2,,void
72401,BLOCK,-1,,"{
    bool stop = false;
    io_pending_proxy_t *p = NULL;
    int flags = 0;

    p = STAILQ_FIRST(&be->io_head);
    if (p == NULL) {
        // got a read event, but nothing was queued.
        // probably means a disconnect event.
        // TODO (v2): could probably confirm this by attempting to read the
        // socket, getsockopt, or something else simply for logging or
        // statistical purposes.
        // In this case we know it's going to be a close so error.
        flags = -1;
        P_DEBUG(""%s: read event but nothing in IO queue\n"", __func__);
        return flags;
    }

    while (!stop) {
        mcp_resp_t *r;
        int res = 1;

    switch(be->state) {
        case mcp_backend_read:
            assert(p != NULL);
            // FIXME: remove the _read state?
            be->state = mcp_backend_parse;
            break;
        case mcp_backend_parse:
            r = p->client_resp;
            r->status = mcmc_parse_buf(be->client, be->rbuf, be->rbufuse...",59,,505,2,,void
72421,BLOCK,1,,<empty>,,,,2,,void
72432,BLOCK,-1,,"{
        // got a read event, but nothing was queued.
        // probably means a disconnect event.
        // TODO (v2): could probably confirm this by attempting to read the
        // socket, getsockopt, or something else simply for logging or
        // statistical purposes.
        // In this case we know it's going to be a close so error.
        flags = -1;
        P_DEBUG(""%s: read event but nothing in IO queue\n"", __func__);
        return flags;
    }",20,,511,2,,void
72442,BLOCK,-1,,"{
        mcp_resp_t *r;
        int res = 1;

    switch(be->state) {
        case mcp_backend_read:
            assert(p != NULL);
            // FIXME: remove the _read state?
            be->state = mcp_backend_parse;
            break;
        case mcp_backend_parse:
            r = p->client_resp;
            r->status = mcmc_parse_buf(be->client, be->rbuf, be->rbufused, &r->resp);
            if (r->status != MCMC_OK) {
                P_DEBUG(""%s: mcmc_read failed [%d]\n"", __func__, r->status);
                if (r->status == MCMC_WANT_READ) {
                    return EV_READ;
                } else {
                    flags = -1;
                    stop = true;
                    break;
                }
            }

            // we actually don't care about anything but the value length
            // TODO (v2): if vlen != vlen_read, pull an item and copy the data.
            int extra_space = 0;
            switch (r->resp.type) {
                case MCMC_RES...",19,,523,2,,void
72452,BLOCK,-1,,"{
        case mcp_backend_read:
            assert(p != NULL);
            // FIXME: remove the _read state?
            be->state = mcp_backend_parse;
            break;
        case mcp_backend_parse:
            r = p->client_resp;
            r->status = mcmc_parse_buf(be->client, be->rbuf, be->rbufused, &r->resp);
            if (r->status != MCMC_OK) {
                P_DEBUG(""%s: mcmc_read failed [%d]\n"", __func__, r->status);
                if (r->status == MCMC_WANT_READ) {
                    return EV_READ;
                } else {
                    flags = -1;
                    stop = true;
                    break;
                }
            }

            // we actually don't care about anything but the value length
            // TODO (v2): if vlen != vlen_read, pull an item and copy the data.
            int extra_space = 0;
            switch (r->resp.type) {
                case MCMC_RESP_GET:
                    // We're in GET mode. we only support one ...",23,,527,2,,void
72496,BLOCK,1,,<empty>,,,,1,,void
72498,BLOCK,-1,,"{
                P_DEBUG(""%s: mcmc_read failed [%d]\n"", __func__, r->status);
                if (r->status == MCMC_WANT_READ) {
                    return EV_READ;
                } else {
                    flags = -1;
                    stop = true;
                    break;
                }
            }",39,,536,2,,void
72505,BLOCK,1,,<empty>,,,,1,,void
72507,BLOCK,-1,,"{
                    return EV_READ;
                }",50,,538,2,,void
72511,BLOCK,-1,,"{
                    flags = -1;
                    stop = true;
                    break;
                }",24,,540,1,,void
72530,BLOCK,-1,,"{
                case MCMC_RESP_GET:
                    // We're in GET mode. we only support one key per
                    // GET in the proxy backends, so we need to later check
                    // for an END.
                    extra_space = ENDLEN;
                    break;
                case MCMC_RESP_END:
                    // this is a MISS from a GET request
                    // or final handler from a STAT request.
                    assert(r->resp.vlen == 0);
                    break;
                case MCMC_RESP_META:
                    // we can handle meta responses easily since they're self
                    // contained.
                    break;
                case MCMC_RESP_GENERIC:
                case MCMC_RESP_NUMERIC:
                    break;
                // TODO (v2): No-op response?
                default:
                    P_DEBUG(""%s: Unhandled response from backend: %d\n"", __func__, r->resp.type);
                    // unhand...",35,,550,2,,void
72533,BLOCK,1,,<empty>,,,,1,,void
72538,BLOCK,1,,<empty>,,,,1,,void
72546,BLOCK,1,,<empty>,,,,1,,void
72559,BLOCK,1,,<empty>,,,,1,,void
72564,BLOCK,1,,<empty>,,,,1,,void
72568,BLOCK,1,,<empty>,,,,1,,void
72582,BLOCK,-1,,"{
                if (p->ascii_multiget && r->resp.type == MCMC_RESP_END) {
                    // Ascii multiget hack mode; consume END's
                    be->state = mcp_backend_next;
                    break;
                }

                // r->resp.reslen + r->resp.vlen is the total length of the response.
                // TODO (v2): need to associate a buffer with this response...
                // for now lets abuse write_and_free on mc_resp and simply malloc the
                // space we need, stuffing it into the resp object.

                r->blen = r->resp.reslen + r->resp.vlen;
                r->buf = malloc(r->blen + extra_space);
                if (r->buf == NULL) {
                    flags = -1; // TODO (v2): specific error.
                    stop = true;
                    break;
                }

                P_DEBUG(""%s: r->status: %d, r->bread: %d, r->vlen: %lu\n"", __func__, r->status, r->bread, r->resp.vlen);
                if (r->resp.v...",22,,578,2,,void
72595,BLOCK,1,,<empty>,,,,1,,void
72597,BLOCK,-1,,"{
                    // Ascii multiget hack mode; consume END's
                    be->state = mcp_backend_next;
                    break;
                }",73,,579,2,,void
72635,BLOCK,-1,,"{
                    flags = -1; // TODO (v2): specific error.
                    stop = true;
                    break;
                }",37,,592,2,,void
72656,BLOCK,-1,,"{
                    // shouldn't be possible to have excess in buffer
                    // if we're dealing with a partial value.
                    assert(be->rbufused == r->resp.reslen+r->resp.vlen_read);
                    P_DEBUG(""%s: got a short read, moving to want_read\n"", __func__);
                    // copy the partial and advance mcmc's buffer digestion.
                    memcpy(r->buf, be->rbuf, r->resp.reslen + r->resp.vlen_read);
                    r->bread = r->resp.reslen + r->resp.vlen_read;
                    be->rbufused = 0;
                    be->state = mcp_backend_want_read;
                    flags |= EV_READ;
                    stop = true;
                    break;
                }",56,,599,2,,void
72724,BLOCK,-1,,"{
                    // mcmc's already counted the value as read if it fit in
                    // the original buffer...
                    memcpy(r->buf, be->rbuf, r->resp.reslen+r->resp.vlen_read);
                }",24,,612,1,,void
72744,BLOCK,-1,,"{
                // TODO (v2): no response read?
                // nothing currently sets res to 0. should remove if that
                // never comes up and handle the error entirely above.
                P_DEBUG(""%s: no response read from backend\n"", __func__);
                flags = -1;
                stop = true;
                break;
            }",20,,617,1,,void
72774,BLOCK,-1,,"{
                memmove(be->rbuf, be->rbuf+r->resp.reslen+r->resp.vlen_read, be->rbufused);
            }",35,,629,2,,void
72805,BLOCK,1,,<empty>,,,,1,,void
72807,BLOCK,-1,,"{
                be->state = mcp_backend_read_end;
            }",48,,633,2,,void
72814,BLOCK,-1,,"{
                be->state = mcp_backend_next;
            }",20,,635,1,,void
72834,BLOCK,1,,<empty>,,,,1,,void
72839,BLOCK,-1,,"{
                if (memcmp(be->rbuf, ENDSTR, ENDLEN) != 0) {
                    // TODO (v2): specific error.
                    flags = -1;
                    stop = true;
                    break;
                } else {
                    // response is good.
                    // FIXME (v2): copy what the server actually sent?
                    if (!p->ascii_multiget) {
                        // sigh... if part of a multiget we need to eat the END
                        // markers down here.
                        memcpy(r->buf+r->blen, ENDSTR, ENDLEN);
                        r->blen += 5;
                    }

                    // advance buffer
                    be->rbufused -= ENDLEN;
                    if (be->rbufused > 0) {
                        memmove(be->rbuf, be->rbuf+ENDLEN, be->rbufused);
                    }
                }
            }",41,,645,2,,void
72847,BLOCK,1,,<empty>,,,,1,,void
72850,BLOCK,1,,<empty>,,,,1,,void
72856,BLOCK,-1,,"{
                    // TODO (v2): specific error.
                    flags = -1;
                    stop = true;
                    break;
                }",60,,646,2,,void
72866,BLOCK,-1,,"{
                    // response is good.
                    // FIXME (v2): copy what the server actually sent?
                    if (!p->ascii_multiget) {
                        // sigh... if part of a multiget we need to eat the END
                        // markers down here.
                        memcpy(r->buf+r->blen, ENDSTR, ENDLEN);
                        r->blen += 5;
                    }

                    // advance buffer
                    be->rbufused -= ENDLEN;
                    if (be->rbufused > 0) {
                        memmove(be->rbuf, be->rbuf+ENDLEN, be->rbufused);
                    }
                }",24,,651,1,,void
72872,BLOCK,-1,,"{
                        // sigh... if part of a multiget we need to eat the END
                        // markers down here.
                        memcpy(r->buf+r->blen, ENDSTR, ENDLEN);
                        r->blen += 5;
                    }",45,,654,2,,void
72882,BLOCK,1,,<empty>,,,,1,,void
72885,BLOCK,1,,<empty>,,,,1,,void
72900,BLOCK,1,,<empty>,,,,1,,void
72911,BLOCK,-1,,"{
                        memmove(be->rbuf, be->rbuf+ENDLEN, be->rbufused);
                    }",43,,663,2,,void
72922,BLOCK,1,,<empty>,,,,1,,void
72930,BLOCK,-1,,"{
                flags |= EV_READ;
                stop = true;
                break;
            }",20,,667,1,,void
73009,BLOCK,-1,,"{
                // all done copying data.
                if (r->resp.type == MCMC_RESP_GET) {
                    be->state = mcp_backend_read_end;
                } else {
                    be->state = mcp_backend_next;
                }

                // shuffle remaining buffer.
                be->rbufused -= tocopy;
                if (be->rbufused > 0) {
                    memmove(be->rbuf, be->rbuf+tocopy, be->rbufused);
                }
            }",43,,688,2,,void
73018,BLOCK,1,,<empty>,,,,1,,void
73020,BLOCK,-1,,"{
                    be->state = mcp_backend_read_end;
                }",52,,690,2,,void
73027,BLOCK,-1,,"{
                    be->state = mcp_backend_next;
                }",24,,692,1,,void
73044,BLOCK,-1,,"{
                    memmove(be->rbuf, be->rbuf+tocopy, be->rbufused);
                }",39,,698,2,,void
73058,BLOCK,-1,,"{
                assert(tocopy == be->rbufused);
                // signal to caller to issue a read.
                be->rbufused = 0;
                flags |= EV_READ;
                stop = true;
            }",20,,701,1,,void
73084,BLOCK,1,,<empty>,,,,2,,void
73086,BLOCK,-1,,"STAILQ_REMOVE_HEAD(&be->io_head, io_next)",13,,712,1,,void
73107,BLOCK,-1,,<empty>,13,,712,2,,void
73142,BLOCK,1,,<empty>,,,,2,,void
73151,BLOCK,-1,,"{
                stop = true;
                // TODO: if there're no pending requests, the read buffer
                // should also be empty.
                // Get a specific return code for errors to surface this.
                if (be->rbufused > 0) {
                    flags = -1;
                }
                break;
            }",45,,720,2,,void
73161,BLOCK,-1,,"{
                    flags = -1;
                }",39,,725,2,,void
73168,BLOCK,-1,,"{
                p = STAILQ_FIRST(&be->io_head);
            }",20,,729,1,,void
73176,BLOCK,1,,<empty>,,,,2,,void
73189,BLOCK,-1,,"{
                // data trailing in the buffer, for a different request.
                be->state = mcp_backend_parse;
            }",36,,737,2,,void
73196,BLOCK,-1,,"{
                // need to read more data, buffer is empty.
                stop = true;
            }",20,,740,1,,void
73219,BLOCK,-1,,"{
    mcp_backend_t *be = arg;
    assert(which & EV_TIMEOUT);
    struct timeval tmp_time = be->event_thread->tunables.retry;
    _set_event(be, be->event_thread->base, EV_WRITE|EV_TIMEOUT, tmp_time, proxy_backend_handler);
}",85,,759,4,,void
73254,BLOCK,-1,,"{
    struct timeval tmp_time = be->event_thread->tunables.retry;
    if (++be->failed_count > be->event_thread->tunables.backend_failure_limit) {
        P_DEBUG(""%s: marking backend as bad\n"", __func__);
        be->bad = true;
       _set_event(be, be->event_thread->base, EV_TIMEOUT, tmp_time, proxy_backend_retry_handler);
        STAT_INCR(be->event_thread->ctx, backend_marked_bad, 1);
    } else {
        STAT_INCR(be->event_thread->ctx, backend_failed, 1);
        _set_event(be, be->event_thread->base, EV_WRITE|EV_TIMEOUT, tmp_time, proxy_backend_handler);
    }
}",48,,779,2,,void
73278,BLOCK,-1,,"{
        P_DEBUG(""%s: marking backend as bad\n"", __func__);
        be->bad = true;
       _set_event(be, be->event_thread->base, EV_TIMEOUT, tmp_time, proxy_backend_retry_handler);
        STAT_INCR(be->event_thread->ctx, backend_marked_bad, 1);
    }",80,,781,2,,void
73301,BLOCK,1,,"STAT_INCR(be->event_thread->ctx, backend_marked_bad, 1)",9,,785,3,,void
73332,BLOCK,-1,,"{
        STAT_INCR(be->event_thread->ctx, backend_failed, 1);
        _set_event(be, be->event_thread->base, EV_WRITE|EV_TIMEOUT, tmp_time, proxy_backend_handler);
    }",12,,786,1,,void
73340,BLOCK,1,,"STAT_INCR(be->event_thread->ctx, backend_failed, 1)",9,,787,1,,void
73388,BLOCK,1,,<empty>,5,,793,1,,void
73392,BLOCK,2,,<empty>,5,,794,2,,void
73396,BLOCK,3,,<empty>,5,,795,3,,void
73400,BLOCK,4,,<empty>,5,,796,4,,void
73404,BLOCK,5,,<empty>,5,,797,5,,void
73408,BLOCK,6,,<empty>,5,,798,6,,void
73416,BLOCK,-1,,"{
    io_pending_proxy_t *io = NULL;
    // Can't use STAILQ_FOREACH() since return_io_pending() free's the current
    // io. STAILQ_FOREACH_SAFE maybe?
    while (!STAILQ_EMPTY(&be->io_head)) {
        io = STAILQ_FIRST(&be->io_head);
        STAILQ_REMOVE_HEAD(&be->io_head, io_next);
        // TODO (v2): Unsure if this is the best way of surfacing errors to lua,
        // but will do for V1.
        io->client_resp->status = MCMC_ERR;
        be->depth--;
        return_io_pending((io_pending_t *)io);
    }

    STAILQ_INIT(&be->io_head);

    // reset buffer to blank state.
    be->rbufused = 0;
    mcmc_disconnect(be->client);
    int status = mcmc_connect(be->client, be->name, be->port, be->connect_flags);
    if (status == MCMC_CONNECTED) {
        // TODO (v2): unexpected but lets let it be here.
        be->connecting = false;
        be->can_write = true;
    } else if (status == MCMC_CONNECTING) {
        be->connecting = true;
        be->can_write = false;
    } else ...",78,,810,3,,void
73428,BLOCK,1,,<empty>,,,,2,,void
73437,BLOCK,-1,,"{
        io = STAILQ_FIRST(&be->io_head);
        STAILQ_REMOVE_HEAD(&be->io_head, io_next);
        // TODO (v2): Unsure if this is the best way of surfacing errors to lua,
        // but will do for V1.
        io->client_resp->status = MCMC_ERR;
        be->depth--;
        return_io_pending((io_pending_t *)io);
    }",41,,814,2,,void
73445,BLOCK,1,,<empty>,,,,2,,void
73457,BLOCK,1,,<empty>,,,,2,,void
73459,BLOCK,-1,,"STAILQ_REMOVE_HEAD(&be->io_head, io_next)",9,,816,1,,void
73480,BLOCK,-1,,<empty>,9,,816,2,,void
73503,BLOCK,1,,<empty>,,,,1,,void
73519,BLOCK,1,,<empty>,,,,2,,void
73521,BLOCK,-1,,STAILQ_INIT(&be->io_head),5,,824,1,,void
73574,BLOCK,1,,<empty>,,,,1,,void
73576,BLOCK,-1,,"{
        // TODO (v2): unexpected but lets let it be here.
        be->connecting = false;
        be->can_write = true;
    }",35,,830,2,,void
73588,BLOCK,-1,,<empty>,12,,834,1,,void
73593,BLOCK,1,,<empty>,,,,1,,void
73595,BLOCK,-1,,"{
        be->connecting = true;
        be->can_write = false;
    }",43,,834,2,,void
73607,BLOCK,-1,,"{
        // TODO (v2): failed to immediately re-establish the connection.
        // need to put the BE into a bad/retry state.
        // FIXME (v2): until we get an event to specifically handle connecting and
        // bad server handling, attempt to force a reconnect here the next
        // time a request comes through.
        // The event thread will attempt to write to the backend, fail, then
        // end up in this routine again.
        be->connecting = false;
        be->can_write = true;
    }",12,,837,1,,void
73622,BLOCK,1,,<empty>,,,,7,,void
73624,BLOCK,-1,,"LOGGER_LOG(NULL, LOG_PROXYEVENTS, LOGGER_PROXY_BE_ERROR, NULL, proxy_be_failure_text[err], be->name, be->port)",5,,849,1,,void
73633,BLOCK,-1,,<empty>,5,,849,2,,void
73648,BLOCK,-1,,<empty>,5,,849,2,,void
73670,BLOCK,-1,,"{
    struct iovec *iovs = be->write_iovs;
    io_pending_proxy_t *io = NULL;
    int iovused = 0;
    STAILQ_FOREACH(io, &be->io_head, io_next) {
        if (io->flushed)
            continue;

        if (io->iovcnt + iovused > BE_IOV_MAX) {
            // Signal to caller that we need to keep writing, if writeable.
            // FIXME (v2): can certainly refactor this to loop instead of waiting
            // for a writeable event.
            *tosend += 1;
            break;
        }

        memcpy(&iovs[iovused], io->iov, sizeof(struct iovec)*io->iovcnt);
        iovused += io->iovcnt;
        *tosend += io->iovbytes;
    }
    return iovused;
}",73,,854,3,,void
73686,BLOCK,-1,,<empty>,5,,858,1,,void
73703,BLOCK,4,,"{
        if (io->flushed)
            continue;

        if (io->iovcnt + iovused > BE_IOV_MAX) {
            // Signal to caller that we need to keep writing, if writeable.
            // FIXME (v2): can certainly refactor this to loop instead of waiting
            // for a writeable event.
            *tosend += 1;
            break;
        }

        memcpy(&iovs[iovused], io->iov, sizeof(struct iovec)*io->iovcnt);
        iovused += io->iovcnt;
        *tosend += io->iovbytes;
    }",47,,858,4,,void
73708,BLOCK,-1,,<empty>,13,,860,2,,void
73718,BLOCK,1,,<empty>,,,,1,,void
73720,BLOCK,-1,,"{
            // Signal to caller that we need to keep writing, if writeable.
            // FIXME (v2): can certainly refactor this to loop instead of waiting
            // for a writeable event.
            *tosend += 1;
            break;
        }",48,,862,2,,void
73757,BLOCK,-1,,"{
    int flags = 0;
    unsigned int tosend = 0;
    int iovcnt = _prep_pending_write(be, &tosend);

    ssize_t sent = writev(mcmc_fd(be->client), be->write_iovs, iovcnt);
    if (sent > 0) {
        io_pending_proxy_t *io = NULL;
        if (sent < tosend) {
            flags |= EV_WRITE;
        }

        STAILQ_FOREACH(io, &be->io_head, io_next) {
            bool flushed = true;
            if (io->flushed)
                continue;

            if (sent >= io->iovbytes) {
                // short circuit for common case.
                sent -= io->iovbytes;
            } else {
                io->iovbytes -= sent;
                for (int x = 0; x < io->iovcnt; x++) {
                    struct iovec *iov = &io->iov[x];
                    if (sent >= iov->iov_len) {
                        sent -= iov->iov_len;
                        iov->iov_len = 0;
                    } else {
                        iov->iov_len -= sent;
                        sent = 0;
            ...",52,,877,2,,void
73789,BLOCK,-1,,"{
        io_pending_proxy_t *io = NULL;
        if (sent < tosend) {
            flags |= EV_WRITE;
        }

        STAILQ_FOREACH(io, &be->io_head, io_next) {
            bool flushed = true;
            if (io->flushed)
                continue;

            if (sent >= io->iovbytes) {
                // short circuit for common case.
                sent -= io->iovbytes;
            } else {
                io->iovbytes -= sent;
                for (int x = 0; x < io->iovcnt; x++) {
                    struct iovec *iov = &io->iov[x];
                    if (sent >= iov->iov_len) {
                        sent -= iov->iov_len;
                        iov->iov_len = 0;
                    } else {
                        iov->iov_len -= sent;
                        sent = 0;
                        flushed = false;
                        break;
                    }
                }
            }
            io->flushed = flushed;

            if (flushed) {
               ...",19,,883,2,,void
73798,BLOCK,-1,,"{
            flags |= EV_WRITE;
        }",28,,885,2,,void
73811,BLOCK,1,,<empty>,,,,34,,void
73813,BLOCK,-1,,<empty>,9,,889,1,,void
73830,BLOCK,4,,"{
            bool flushed = true;
            if (io->flushed)
                continue;

            if (sent >= io->iovbytes) {
                // short circuit for common case.
                sent -= io->iovbytes;
            } else {
                io->iovbytes -= sent;
                for (int x = 0; x < io->iovcnt; x++) {
                    struct iovec *iov = &io->iov[x];
                    if (sent >= iov->iov_len) {
                        sent -= iov->iov_len;
                        iov->iov_len = 0;
                    } else {
                        iov->iov_len -= sent;
                        sent = 0;
                        flushed = false;
                        break;
                    }
                }
            }
            io->flushed = flushed;

            if (flushed) {
                flags |= EV_READ;
            }
            if (sent <= 0) {
                // really shouldn't be negative, though.
                assert(sent >= 0);
        ...",51,,889,4,,void
73839,BLOCK,-1,,<empty>,17,,892,2,,void
73847,BLOCK,-1,,"{
                // short circuit for common case.
                sent -= io->iovbytes;
            }",39,,894,2,,void
73854,BLOCK,-1,,"{
                io->iovbytes -= sent;
                for (int x = 0; x < io->iovcnt; x++) {
                    struct iovec *iov = &io->iov[x];
                    if (sent >= iov->iov_len) {
                        sent -= iov->iov_len;
                        iov->iov_len = 0;
                    } else {
                        iov->iov_len -= sent;
                        sent = 0;
                        flushed = false;
                        break;
                    }
                }
            }",20,,897,1,,void
73861,BLOCK,-1,,<empty>,17,,899,1,,void
73873,BLOCK,4,,"{
                    struct iovec *iov = &io->iov[x];
                    if (sent >= iov->iov_len) {
                        sent -= iov->iov_len;
                        iov->iov_len = 0;
                    } else {
                        iov->iov_len -= sent;
                        sent = 0;
                        flushed = false;
                        break;
                    }
                }",54,,899,4,,void
73889,BLOCK,-1,,"{
                        sent -= iov->iov_len;
                        iov->iov_len = 0;
                    }",47,,901,2,,void
73901,BLOCK,-1,,"{
                        iov->iov_len -= sent;
                        sent = 0;
                        flushed = false;
                        break;
                    }",28,,904,1,,void
73921,BLOCK,-1,,"{
                flags |= EV_READ;
            }",26,,914,2,,void
73929,BLOCK,-1,,"{
                // really shouldn't be negative, though.
                assert(sent >= 0);
                break;
            }",28,,917,2,,void
73936,BLOCK,-1,,<empty>,12,,923,1,,void
73942,BLOCK,-1,,"{
        if (errno == EAGAIN || errno == EWOULDBLOCK) {
            be->can_write = false;
            flags |= EV_WRITE;
        } else {
            flags = -1;
        }
    }",28,,923,2,,void
73951,BLOCK,-1,,"{
            be->can_write = false;
            flags |= EV_WRITE;
        }",54,,924,2,,void
73961,BLOCK,-1,,"{
            flags = -1;
        }",16,,927,1,,void
73974,BLOCK,-1,,"{
    mcp_backend_t *be = arg;
    int flags = EV_TIMEOUT;
    struct timeval tmp_time = be->event_thread->tunables.read;

    if (which & EV_TIMEOUT) {
        P_DEBUG(""%s: timeout received, killing backend queue\n"", __func__);
        _reset_bad_backend(be, P_BE_FAIL_TIMEOUT);
        _backend_failed(be);
        return;
    }

    if (which & EV_WRITE) {
        be->can_write = true;
        // TODO (v2): move connect routine to its own function?
        // - hard to do right now because we can't (easily?) edit libevent
        // events.
        if (be->connecting) {
            int err = 0;
            // We were connecting, now ensure we're properly connected.
            if (mcmc_check_nonblock_connect(be->client, &err) != MCMC_OK) {
                // kick the bad backend, clear the queue, retry later.
                // FIXME (v2): if a connect fails, anything currently in the queue
                // should be safe to hold up until their timeout.
                _reset_bad...",79,,938,4,,void
73997,BLOCK,-1,,"{
        P_DEBUG(""%s: timeout received, killing backend queue\n"", __func__);
        _reset_bad_backend(be, P_BE_FAIL_TIMEOUT);
        _backend_failed(be);
        return;
    }",29,,943,2,,void
74008,BLOCK,-1,,"{
        be->can_write = true;
        // TODO (v2): move connect routine to its own function?
        // - hard to do right now because we can't (easily?) edit libevent
        // events.
        if (be->connecting) {
            int err = 0;
            // We were connecting, now ensure we're properly connected.
            if (mcmc_check_nonblock_connect(be->client, &err) != MCMC_OK) {
                // kick the bad backend, clear the queue, retry later.
                // FIXME (v2): if a connect fails, anything currently in the queue
                // should be safe to hold up until their timeout.
                _reset_bad_backend(be, P_BE_FAIL_CONNECTING);
                _backend_failed(be);
                P_DEBUG(""%s: backend failed to connect\n"", __func__);
                return;
            }
            P_DEBUG(""%s: backend connected\n"", __func__);
            be->connecting = false;
            be->state = mcp_backend_read;
            be->bad = false;
            ...",27,,950,2,,void
74018,BLOCK,-1,,"{
            int err = 0;
            // We were connecting, now ensure we're properly connected.
            if (mcmc_check_nonblock_connect(be->client, &err) != MCMC_OK) {
                // kick the bad backend, clear the queue, retry later.
                // FIXME (v2): if a connect fails, anything currently in the queue
                // should be safe to hold up until their timeout.
                _reset_bad_backend(be, P_BE_FAIL_CONNECTING);
                _backend_failed(be);
                P_DEBUG(""%s: backend failed to connect\n"", __func__);
                return;
            }
            P_DEBUG(""%s: backend connected\n"", __func__);
            be->connecting = false;
            be->state = mcp_backend_read;
            be->bad = false;
            be->failed_count = 0;
        }",29,,955,2,,void
74032,BLOCK,1,,<empty>,,,,1,,void
74034,BLOCK,-1,,"{
                // kick the bad backend, clear the queue, retry later.
                // FIXME (v2): if a connect fails, anything currently in the queue
                // should be safe to hold up until their timeout.
                _reset_bad_backend(be, P_BE_FAIL_CONNECTING);
                _backend_failed(be);
                P_DEBUG(""%s: backend failed to connect\n"", __func__);
                return;
            }",75,,958,2,,void
74071,BLOCK,-1,,"{
            _reset_bad_backend(be, P_BE_FAIL_WRITING);
            return;
        }",24,,974,2,,void
74080,BLOCK,-1,,"{
        // We do the syscall here before diving into the state machine to allow a
        // common code path for io_uring/epoll
        int read = recv(mcmc_fd(be->client), be->rbuf + be->rbufused,
                    READ_BUFFER_SIZE - be->rbufused, 0);
        if (read > 0) {
            be->rbufused += read;
            int res = proxy_backend_drive_machine(be);
            if (res == -1) {
                _reset_bad_backend(be, P_BE_FAIL_PARSING);
                return;
            }
        } else if (read == 0) {
            // not connected or error.
            _reset_bad_backend(be, P_BE_FAIL_DISCONNECTED);
            return;
        } else if (read == -1) {
            // sit on epoll again.
            if (errno != EAGAIN && errno != EWOULDBLOCK) {
                _reset_bad_backend(be, P_BE_FAIL_READING);
                return;
            }
        }

#ifdef PROXY_DEBUG
        if (!STAILQ_EMPTY(&be->io_head)) {
            P_DEBUG(""backend has leftover IOs: %d\n""...",26,,980,2,,void
74098,BLOCK,1,,<empty>,,,,1,,void
74108,BLOCK,-1,,"{
            be->rbufused += read;
            int res = proxy_backend_drive_machine(be);
            if (res == -1) {
                _reset_bad_backend(be, P_BE_FAIL_PARSING);
                return;
            }
        }",23,,985,2,,void
74124,BLOCK,-1,,"{
                _reset_bad_backend(be, P_BE_FAIL_PARSING);
                return;
            }",28,,988,2,,void
74130,BLOCK,-1,,<empty>,16,,992,1,,void
74135,BLOCK,-1,,"{
            // not connected or error.
            _reset_bad_backend(be, P_BE_FAIL_DISCONNECTED);
            return;
        }",31,,992,2,,void
74141,BLOCK,-1,,<empty>,16,,996,1,,void
74147,BLOCK,-1,,"{
            // sit on epoll again.
            if (errno != EAGAIN && errno != EWOULDBLOCK) {
                _reset_bad_backend(be, P_BE_FAIL_READING);
                return;
            }
        }",32,,996,2,,void
74156,BLOCK,-1,,"{
                _reset_bad_backend(be, P_BE_FAIL_READING);
                return;
            }",58,,998,2,,void
74168,BLOCK,1,,<empty>,,,,3,,void
74177,BLOCK,-1,,"{
        flags |= EV_READ; // FIXME (v2): might not be necessary here, but ensures we get a disconnect event.
        _set_event(be, be->event_thread->base, flags, tmp_time, proxy_backend_handler);
    }",38,,1012,2,,void
74195,BLOCK,-1,,"{
#ifdef HAVE_LIBURING
    bool use_uring = t->ctx->use_uring;
    struct io_uring_params p = {0};
    assert(t->event_fd); // uring only exists where eventfd also does.

    // Setup the CQSIZE to be much larger than SQ size, since backpressure
    // issues can cause us to block on SQ submissions and as a network server,
    // stuff happens.

    if (use_uring) {
        p.flags = IORING_SETUP_CQSIZE;
        p.cq_entries = PRING_QUEUE_CQ_ENTRIES;
        int ret = io_uring_queue_init_params(PRING_QUEUE_SQ_ENTRIES, &t->ring, &p);
        if (ret) {
            perror(""io_uring_queue_init_params"");
            exit(1);
        }
        if (!(p.features & IORING_FEAT_NODROP)) {
            fprintf(stderr, ""uring: kernel missing IORING_FEAT_NODROP, using libevent\n"");
            use_uring = false;
        }
        if (!(p.features & IORING_FEAT_SINGLE_MMAP)) {
            fprintf(stderr, ""uring: kernel missing IORING_FEAT_SINGLE_MMAP, using libevent\n"");
            use_uring = f...",58,,1020,2,,void
74216,BLOCK,-1,,"{
        fprintf(stderr, ""Can't allocate event base\n"");
        exit(1);
    }",20,,1084,2,,void
74254,BLOCK,1,,<empty>,28,,1102,1,,void
74258,BLOCK,2,,<empty>,41,,1102,2,,void
74287,BLOCK,-1,,"{
        fprintf(stderr, ""Can't monitor libevent notify pipe\n"");
        exit(1);
    }",47,,1106,2,,void
74301,BLOCK,-1,,<empty>,1,,1,1,,ANY
74305,BLOCK,-1,,"{
    const char *s = pr->request;
    int len = pr->reqlen - 2;

    // since multigets can be huge, we can't purely judge reqlen against this
    // limit, but we also can't index past it since the tokens are shorts.
    if (len > PARSER_MAXLEN) {
        len = PARSER_MAXLEN;
    }
    const char *end = s + len;
    int curtoken = 0;

    int state = 0;
    while (s != end) {
        switch (state) {
            case 0:
                // scanning for first non-space to find a token.
                if (*s != ' ') {
                    pr->tokens[curtoken] = s - pr->request;
                    if (++curtoken == max) {
                        s++;
                        state = 2;
                        break;
                    }
                    state = 1;
                }
                s++;
                break;
            case 1:
                // advance over a token
                if (*s != ' ') {
                    s++;
                } else {
               ...",66,,10,3,,void
74324,BLOCK,1,,<empty>,,,,1,,void
74328,BLOCK,-1,,"{
        len = PARSER_MAXLEN;
    }",30,,16,2,,void
74332,BLOCK,1,,<empty>,,,,1,,void
74354,BLOCK,-1,,"{
        switch (state) {
            case 0:
                // scanning for first non-space to find a token.
                if (*s != ' ') {
                    pr->tokens[curtoken] = s - pr->request;
                    if (++curtoken == max) {
                        s++;
                        state = 2;
                        break;
                    }
                    state = 1;
                }
                s++;
                break;
            case 1:
                // advance over a token
                if (*s != ' ') {
                    s++;
                } else {
                    state = 0;
                }
                break;
            case 2:
                // hit max tokens before end of the line.
                // keep advancing so we can place endcap token.
                if (*s == ' ') {
                    goto endloop;
                }
                s++;
                break;
        }
    }",22,,23,2,,void
74357,BLOCK,-1,,"{
            case 0:
                // scanning for first non-space to find a token.
                if (*s != ' ') {
                    pr->tokens[curtoken] = s - pr->request;
                    if (++curtoken == max) {
                        s++;
                        state = 2;
                        break;
                    }
                    state = 1;
                }
                s++;
                break;
            case 1:
                // advance over a token
                if (*s != ' ') {
                    s++;
                } else {
                    state = 0;
                }
                break;
            case 2:
                // hit max tokens before end of the line.
                // keep advancing so we can place endcap token.
                if (*s == ' ') {
                    goto endloop;
                }
                s++;
                break;
        }",24,,24,2,,void
74365,BLOCK,-1,,"{
                    pr->tokens[curtoken] = s - pr->request;
                    if (++curtoken == max) {
                        s++;
                        state = 2;
                        break;
                    }
                    state = 1;
                }",32,,27,2,,void
74382,BLOCK,-1,,"{
                        s++;
                        state = 2;
                        break;
                    }",44,,29,2,,void
74402,BLOCK,-1,,"{
                    s++;
                }",32,,40,2,,void
74406,BLOCK,-1,,"{
                    state = 0;
                }",24,,42,1,,void
74418,BLOCK,-1,,"{
                    goto endloop;
                }",32,,49,2,,void
74447,BLOCK,-1,,"{
    const char *s = pr->request + pr->tokens[token];
    const char *e = pr->request + pr->tokens[token+1];
    // start of next token is after any space delimiters, so back those out.
    while (*(e-1) == ' ') {
        e--;
    }
    return e - s;
}",63,,67,3,,void
74481,BLOCK,-1,,"{
        e--;
    }",27,,71,2,,void
74492,BLOCK,-1,,"{
    pr->klen = _process_token_len(pr, pr->keytoken);
    // advance the parser in case of multikey.
    pr->parsed = pr->tokens[pr->keytoken] + pr->klen + 1;

    if (pr->request[pr->parsed-1] == ' ') {
        P_DEBUG(""%s: request_key found extra space\n"", __func__);
        pr->has_space = true;
    } else {
        pr->has_space = false;
    }
    return 0;
}",51,,77,2,,void
74531,BLOCK,-1,,"{
        P_DEBUG(""%s: request_key found extra space\n"", __func__);
        pr->has_space = true;
    }",43,,82,2,,void
74538,BLOCK,-1,,"{
        pr->has_space = false;
    }",12,,85,1,,void
74550,BLOCK,-1,,"{
    const char *cur = pr->request + pr->parsed;
    int remain = pr->reqlen - pr->parsed - 2;

    // chew off any leading whitespace.
    while (remain) {
        if (*cur == ' ') {
            remain--;
            cur++;
            pr->parsed++;
        } else {
            break;
        }
    }

    const char *s = memchr(cur, ' ', remain);
    if (s != NULL) {
        pr->klen = s - cur;
        pr->parsed += s - cur;
    } else {
        pr->klen = remain;
        pr->parsed += remain;
    }

    return cur - pr->request;
}",52,,94,2,,void
74575,BLOCK,-1,,"{
        if (*cur == ' ') {
            remain--;
            cur++;
            pr->parsed++;
        } else {
            break;
        }
    }",20,,99,2,,void
74581,BLOCK,-1,,"{
            remain--;
            cur++;
            pr->parsed++;
        }",26,,100,2,,void
74591,BLOCK,-1,,"{
            break;
        }",16,,104,1,,void
74604,BLOCK,-1,,"{
        pr->klen = s - cur;
        pr->parsed += s - cur;
    }",20,,110,2,,void
74620,BLOCK,-1,,"{
        pr->klen = remain;
        pr->parsed += remain;
    }",12,,113,1,,void
74642,BLOCK,-1,,"{
    if (pr->ntokens <= token) {
        pr->t.meta.flags = 0; // no flags found.
        return 0;
    }
    const char *cur = pr->request + pr->tokens[token];
    const char *end = pr->request + pr->reqlen - 2;

    // We blindly convert flags into bits, since the range of possible
    // flags is deliberately < 64.
    int state = 0;
    while (cur != end) {
        switch (state) {
            case 0:
                if (*cur == ' ') {
                    cur++;
                } else {
                    if (*cur < 65 || *cur > 122) {
                        return -1;
                    }
                    P_DEBUG(""%s: setting meta flag: %d\n"", __func__, *cur - 65);
                    pr->t.meta.flags |= (uint64_t)1 << (*cur - 65);
                    state = 1;
                }
                break;
            case 1:
                if (*cur != ' ') {
                    cur++;
                } else {
                    state = 0;
                }
               ...",68,,123,3,,void
74649,BLOCK,-1,,"{
        pr->t.meta.flags = 0; // no flags found.
        return 0;
    }",31,,124,2,,void
74693,BLOCK,-1,,"{
        switch (state) {
            case 0:
                if (*cur == ' ') {
                    cur++;
                } else {
                    if (*cur < 65 || *cur > 122) {
                        return -1;
                    }
                    P_DEBUG(""%s: setting meta flag: %d\n"", __func__, *cur - 65);
                    pr->t.meta.flags |= (uint64_t)1 << (*cur - 65);
                    state = 1;
                }
                break;
            case 1:
                if (*cur != ' ') {
                    cur++;
                } else {
                    state = 0;
                }
                break;
        }
    }",24,,134,2,,void
74696,BLOCK,-1,,"{
            case 0:
                if (*cur == ' ') {
                    cur++;
                } else {
                    if (*cur < 65 || *cur > 122) {
                        return -1;
                    }
                    P_DEBUG(""%s: setting meta flag: %d\n"", __func__, *cur - 65);
                    pr->t.meta.flags |= (uint64_t)1 << (*cur - 65);
                    state = 1;
                }
                break;
            case 1:
                if (*cur != ' ') {
                    cur++;
                } else {
                    state = 0;
                }
                break;
        }",24,,135,2,,void
74704,BLOCK,-1,,"{
                    cur++;
                }",34,,137,2,,void
74708,BLOCK,-1,,"{
                    if (*cur < 65 || *cur > 122) {
                        return -1;
                    }
                    P_DEBUG(""%s: setting meta flag: %d\n"", __func__, *cur - 65);
                    pr->t.meta.flags |= (uint64_t)1 << (*cur - 65);
                    state = 1;
                }",24,,139,1,,void
74719,BLOCK,-1,,"{
                        return -1;
                    }",50,,140,2,,void
74750,BLOCK,-1,,"{
                    cur++;
                }",34,,149,2,,void
74754,BLOCK,-1,,"{
                    state = 0;
                }",24,,151,1,,void
74773,BLOCK,-1,,"{
        pr->noreply = true;
    }",49,,161,2,,void
74785,BLOCK,-1,,"{
    _process_tokenize(pr, PARSER_MAX_TOKENS);
    if (pr->ntokens < 2) {
        P_DEBUG(""%s: not enough tokens for meta command: %d\n"", __func__, pr->ntokens);
        return -1;
    }
    pr->keytoken = 1;
    _process_request_key(pr);

    // pass the first flag token.
    return _process_request_metaflags(pr, 2);
}",52,,169,2,,void
74789,BLOCK,1,,<empty>,,,,1,,void
74797,BLOCK,-1,,"{
        P_DEBUG(""%s: not enough tokens for meta command: %d\n"", __func__, pr->ntokens);
        return -1;
    }",26,,171,2,,void
74816,BLOCK,-1,,"{
    _process_tokenize(pr, PARSER_MAX_TOKENS);
    if (pr->ntokens < 3) {
        P_DEBUG(""%s: not enough tokens for meta set command: %d\n"", __func__, pr->ntokens);
        return -1;
    }
    pr->keytoken = 1;
    _process_request_key(pr);

    const char *cur = pr->request + pr->tokens[2];

    errno = 0;
    char *n = NULL;
    int vlen = strtol(cur, &n, 10);
    if ((errno == ERANGE) || (cur == n)) {
        return -1;
    }

    if (vlen < 0 || vlen > (INT_MAX - 2)) {
       return -1;
    }
    vlen += 2;

    pr->vlen = vlen;

    // pass the first flag token
    return _process_request_metaflags(pr, 3);
}",52,,183,2,,void
74820,BLOCK,1,,<empty>,,,,1,,void
74828,BLOCK,-1,,"{
        P_DEBUG(""%s: not enough tokens for meta set command: %d\n"", __func__, pr->ntokens);
        return -1;
    }",26,,185,2,,void
74874,BLOCK,-1,,"{
        return -1;
    }",42,,197,2,,void
74888,BLOCK,-1,,"{
       return -1;
    }",43,,201,2,,void
74908,BLOCK,-1,,"{
    _process_tokenize(pr, 3);
    if (pr->ntokens < 3) {
        P_DEBUG(""%s: not enough tokens for GAT: %d\n"", __func__, pr->ntokens);
        return -1;
    }

    pr->keytoken = 2;
    _process_request_key(pr);
    return 0;
}",51,,213,2,,void
74918,BLOCK,-1,,"{
        P_DEBUG(""%s: not enough tokens for GAT: %d\n"", __func__, pr->ntokens);
        return -1;
    }",26,,215,2,,void
74935,BLOCK,-1,,"{
    if (pr->tokens[pr->ntokens] - pr->tokens[pr->ntokens-1] >= NOREPLYLEN
            && strncmp(NOREPLYSTR, pr->request + pr->tokens[pr->ntokens-1], NOREPLYLEN) == 0) {
        pr->noreply = true;
    }
    return 0;
}",55,,229,2,,void
74957,BLOCK,1,,<empty>,,,,1,,void
74965,BLOCK,1,,<empty>,,,,1,,void
74981,BLOCK,1,,<empty>,,,,1,,void
74987,BLOCK,-1,,"{
        pr->noreply = true;
    }",95,,231,2,,void
75000,BLOCK,-1,,"{
    _process_tokenize(pr, max);
    if (pr->ntokens < 5) {
        P_DEBUG(""%s: not enough tokens to storage command: %d\n"", __func__, pr->ntokens);
        return -1;
    }
    pr->keytoken = 1;
    _process_request_key(pr);

    errno = 0;
    char *n = NULL;
    const char *cur = pr->request + pr->tokens[4];

    int vlen = strtol(cur, &n, 10);
    if ((errno == ERANGE) || (cur == n)) {
        return -1;
    }

    if (vlen < 0 || vlen > (INT_MAX - 2)) {
       return -1;
    }
    vlen += 2;

    pr->vlen = vlen;

    return _process_request_noreply(pr);
}",67,,240,3,,void
75010,BLOCK,-1,,"{
        P_DEBUG(""%s: not enough tokens to storage command: %d\n"", __func__, pr->ntokens);
        return -1;
    }",26,,242,2,,void
75056,BLOCK,-1,,"{
        return -1;
    }",42,,254,2,,void
75070,BLOCK,-1,,"{
       return -1;
    }",43,,258,2,,void
75090,BLOCK,-1,,"{
    _process_tokenize(pr, max);
    pr->keytoken = 1; // second token is usually the key... stupid GAT.

    _process_request_key(pr);
    return _process_request_noreply(pr);
}",72,,269,3,,void
75110,BLOCK,-1,,"{
    // we want to ""parse in place"" as much as possible, which allows us to
    // forward an unmodified request without having to rebuild it.

    const char *cm = command;
    size_t cl = 0;
    // min command length is 2, plus the ""\r\n""
    if (cmdlen < 4) {
        return -1;
    }

    const char *s = memchr(command, ' ', cmdlen-2);
    if (s != NULL) {
        cl = s - command;
    } else {
        cl = cmdlen - 2;
    }
    pr->keytoken = 0;
    pr->has_space = false;
    pr->parsed = cl + 1;
    pr->request = command;
    pr->reqlen = cmdlen;
    int token_max = PARSER_MAX_TOKENS;

    int cmd = -1;
    int type = CMD_TYPE_GENERIC;
    int ret = 0;

    switch (cl) {
        case 0:
        case 1:
            // falls through with cmd as -1. should error.
            break;
        case 2:
            if (cm[0] == 'm') {
                type = CMD_TYPE_META;
                switch (cm[1]) {
                    case 'g':
                        cmd = CMD_MG;
              ...",75,,282,4,,void
75123,BLOCK,-1,,"{
        return -1;
    }",21,,289,2,,void
75140,BLOCK,-1,,"{
        cl = s - command;
    }",20,,294,2,,void
75147,BLOCK,-1,,"{
        cl = cmdlen - 2;
    }",12,,296,1,,void
75184,BLOCK,1,,<empty>,,,,1,,void
75201,BLOCK,-1,,"{
        case 0:
        case 1:
            // falls through with cmd as -1. should error.
            break;
        case 2:
            if (cm[0] == 'm') {
                type = CMD_TYPE_META;
                switch (cm[1]) {
                    case 'g':
                        cmd = CMD_MG;
                        ret = _process_request_meta(pr);
                        break;
                    case 's':
                        cmd = CMD_MS;
                        ret = _process_request_mset(pr);
                        break;
                    case 'd':
                        cmd = CMD_MD;
                        ret = _process_request_meta(pr);
                        break;
                    case 'n':
                        // TODO: do we route/handle NOP's at all?
                        // they should simply reflect to the client.
                        cmd = CMD_MN;
                        break;
                    case 'a':
                        cmd = CMD_...",17,,310,2,,void
75215,BLOCK,-1,,"{
                type = CMD_TYPE_META;
                switch (cm[1]) {
                    case 'g':
                        cmd = CMD_MG;
                        ret = _process_request_meta(pr);
                        break;
                    case 's':
                        cmd = CMD_MS;
                        ret = _process_request_mset(pr);
                        break;
                    case 'd':
                        cmd = CMD_MD;
                        ret = _process_request_meta(pr);
                        break;
                    case 'n':
                        // TODO: do we route/handle NOP's at all?
                        // they should simply reflect to the client.
                        cmd = CMD_MN;
                        break;
                    case 'a':
                        cmd = CMD_MA;
                        ret = _process_request_meta(pr);
                        break;
                    case 'e':
                        cmd = CMD_ME...",31,,316,2,,void
75223,BLOCK,-1,,"{
                    case 'g':
                        cmd = CMD_MG;
                        ret = _process_request_meta(pr);
                        break;
                    case 's':
                        cmd = CMD_MS;
                        ret = _process_request_mset(pr);
                        break;
                    case 'd':
                        cmd = CMD_MD;
                        ret = _process_request_meta(pr);
                        break;
                    case 'n':
                        // TODO: do we route/handle NOP's at all?
                        // they should simply reflect to the client.
                        cmd = CMD_MN;
                        break;
                    case 'a':
                        cmd = CMD_MA;
                        ret = _process_request_meta(pr);
                        break;
                    case 'e':
                        cmd = CMD_ME;
                        // TODO: not much special processing here; bi...",32,,318,2,,void
75289,BLOCK,-1,,"{
                if (cm[1] == 'e' && cm[2] == 't') {
                    cmd = CMD_GET;
                    type = CMD_TYPE_GET;
                    token_max = 2; // don't chew through multigets.
                    ret = _process_request_simple(pr, 2);
                }
                if (cm[1] == 'a' && cm[2] == 't') {
                    type = CMD_TYPE_GET;
                    cmd = CMD_GAT;
                    token_max = 2; // don't chew through multigets.
                    ret = _process_request_gat(pr);
                }
            }",31,,349,2,,void
75302,BLOCK,-1,,"{
                    cmd = CMD_GET;
                    type = CMD_TYPE_GET;
                    token_max = 2; // don't chew through multigets.
                    ret = _process_request_simple(pr, 2);
                }",51,,350,2,,void
75329,BLOCK,-1,,"{
                    type = CMD_TYPE_GET;
                    cmd = CMD_GAT;
                    token_max = 2; // don't chew through multigets.
                    ret = _process_request_gat(pr);
                }",51,,356,2,,void
75344,BLOCK,-1,,<empty>,20,,362,1,,void
75363,BLOCK,-1,,"{
                cmd = CMD_SET;
                ret = _process_request_storage(pr, token_max);
            }",70,,362,2,,void
75373,BLOCK,-1,,<empty>,20,,365,1,,void
75392,BLOCK,-1,,"{
                cmd = CMD_ADD;
                ret = _process_request_storage(pr, token_max);
            }",70,,365,2,,void
75402,BLOCK,-1,,<empty>,20,,368,1,,void
75421,BLOCK,-1,,"{
                cmd = CMD_CAS;
                ret = _process_request_storage(pr, token_max);
            }",70,,368,2,,void
75440,BLOCK,-1,,"{
                cmd = CMD_GETS;
                type = CMD_TYPE_GET;
                token_max = 2; // don't chew through multigets.
                ret = _process_request_simple(pr, 2);
            }",46,,374,2,,void
75456,BLOCK,-1,,<empty>,20,,379,1,,void
75464,BLOCK,-1,,"{
                cmd = CMD_INCR;
                ret = _process_request_simple(pr, 4);
            }",53,,379,2,,void
75474,BLOCK,-1,,<empty>,20,,382,1,,void
75482,BLOCK,-1,,"{
                cmd = CMD_DECR;
                ret = _process_request_simple(pr, 4);
            }",53,,382,2,,void
75492,BLOCK,-1,,<empty>,20,,385,1,,void
75500,BLOCK,-1,,"{
                cmd = CMD_GATS;
                type = CMD_TYPE_GET;
                ret = _process_request_gat(pr);
            }",53,,385,2,,void
75512,BLOCK,-1,,<empty>,20,,389,1,,void
75520,BLOCK,-1,,"{
                cmd = CMD_QUIT;
            }",53,,389,2,,void
75534,BLOCK,-1,,"{
                cmd = CMD_TOUCH;
                ret = _process_request_simple(pr, 4);
            }",47,,394,2,,void
75544,BLOCK,-1,,<empty>,20,,397,1,,void
75552,BLOCK,-1,,"{
                cmd = CMD_STATS;
                // Don't process a key; fetch via arguments.
                _process_tokenize(pr, token_max);
            }",54,,397,2,,void
75560,BLOCK,-1,,<empty>,20,,401,1,,void
75568,BLOCK,-1,,"{
                cmd = CMD_WATCH;
                _process_tokenize(pr, token_max);
            }",54,,401,2,,void
75585,BLOCK,-1,,"{
                cmd = CMD_DELETE;
                ret = _process_request_simple(pr, 4);
            }",48,,407,2,,void
75595,BLOCK,-1,,<empty>,20,,410,1,,void
75603,BLOCK,-1,,"{
                cmd = CMD_APPEND;
                ret = _process_request_storage(pr, token_max);
            }",55,,410,2,,void
75622,BLOCK,-1,,"{
                cmd = CMD_REPLACE;
                ret = _process_request_storage(pr, token_max);
            }",49,,416,2,,void
75632,BLOCK,-1,,<empty>,20,,419,1,,void
75640,BLOCK,-1,,"{
                cmd = CMD_PREPEND;
                ret = _process_request_storage(pr, token_max);
            }",56,,419,2,,void
75650,BLOCK,-1,,<empty>,20,,422,1,,void
75658,BLOCK,-1,,"{
                cmd = CMD_VERSION;
                _process_tokenize(pr, token_max);
            }",56,,422,2,,void
75675,BLOCK,-1,,"{
        return -1;
    }",32,,430,2,,void
75698,BLOCK,-1,,"{
    // reserving an upvalue for key.
    mcp_request_t *rq = lua_newuserdatauv(L, sizeof(mcp_request_t) + MCP_REQUEST_MAXLEN * 2 + KEY_MAX_LENGTH, 1);
    // TODO (v2): memset only the non-data part? as the rest gets memcpy'd
    // over.
    memset(rq, 0, sizeof(mcp_request_t));
    memcpy(&rq->pr, pr, sizeof(*pr));

    memcpy(rq->request, command, cmdlen);
    rq->pr.request = rq->request;
    rq->pr.reqlen = cmdlen;
    gettimeofday(&rq->start, NULL);

    luaL_getmetatable(L, ""mcp.request"");
    lua_setmetatable(L, -2);

    // at this point we should know if we have to bounce through _nread to
    // get item data or not.
    return rq;
}",100,,441,5,,void
75710,BLOCK,1,,<empty>,,,,1,,void
75716,BLOCK,1,,<empty>,,,,1,,void
75776,BLOCK,-1,,"{
    mcp_parser_t *pr = &rq->pr;
    char *r = (char *) pr->request;
    size_t len = pr->reqlen;

    // one or more of the tokens were changed
    if (rq->was_modified) {
        assert(rq->tokent_ref);
        // option table to top of stack.
        lua_rawgeti(L, LUA_REGISTRYINDEX, rq->tokent_ref);

        // space was reserved in case of modification.
        char *nr = rq->request + MCP_REQUEST_MAXLEN;
        r = nr;
        char *or = NULL;

        for (int x = 0; x < pr->ntokens; x++) {
            const char *newtok = NULL;
            size_t newlen = 0;
            if (x != 0 && x != pr->keytoken) {
                int type = lua_rawgeti(L, -1, x+1);
                if (type != LUA_TNIL) {
                    newtok = lua_tolstring(L, -1, &newlen);
                    memcpy(nr, newtok, newlen);
                    nr += newlen;
                }
                lua_pop(L, 1);
            }

            if (newtok == NULL) {
                // TODO (v2): if we add an ...",81,,467,4,,void
75802,BLOCK,-1,,"{
        assert(rq->tokent_ref);
        // option table to top of stack.
        lua_rawgeti(L, LUA_REGISTRYINDEX, rq->tokent_ref);

        // space was reserved in case of modification.
        char *nr = rq->request + MCP_REQUEST_MAXLEN;
        r = nr;
        char *or = NULL;

        for (int x = 0; x < pr->ntokens; x++) {
            const char *newtok = NULL;
            size_t newlen = 0;
            if (x != 0 && x != pr->keytoken) {
                int type = lua_rawgeti(L, -1, x+1);
                if (type != LUA_TNIL) {
                    newtok = lua_tolstring(L, -1, &newlen);
                    memcpy(nr, newtok, newlen);
                    nr += newlen;
                }
                lua_pop(L, 1);
            }

            if (newtok == NULL) {
                // TODO (v2): if we add an extra ""end"" token that's just reqlen we can
                // memcpy... however most args are short and that may not be worth
                // it.
                or = r...",27,,473,2,,void
75821,BLOCK,1,,<empty>,,,,1,,void
75833,BLOCK,-1,,<empty>,9,,483,1,,void
75845,BLOCK,4,,"{
            const char *newtok = NULL;
            size_t newlen = 0;
            if (x != 0 && x != pr->keytoken) {
                int type = lua_rawgeti(L, -1, x+1);
                if (type != LUA_TNIL) {
                    newtok = lua_tolstring(L, -1, &newlen);
                    memcpy(nr, newtok, newlen);
                    nr += newlen;
                }
                lua_pop(L, 1);
            }

            if (newtok == NULL) {
                // TODO (v2): if we add an extra ""end"" token that's just reqlen we can
                // memcpy... however most args are short and that may not be worth
                // it.
                or = rq->request + pr->tokens[x];
                // will walk past the end without the \r test.
                // if we add the end token trick this can be changed.
                while (*or != ' ' && *or != '\r' && *or != '\n') {
                    *nr = *or;
                    nr++;
                    or++;
                }
  ...",47,,483,4,,void
75864,BLOCK,-1,,"{
                int type = lua_rawgeti(L, -1, x+1);
                if (type != LUA_TNIL) {
                    newtok = lua_tolstring(L, -1, &newlen);
                    memcpy(nr, newtok, newlen);
                    nr += newlen;
                }
                lua_pop(L, 1);
            }",46,,486,2,,void
75879,BLOCK,-1,,"{
                    newtok = lua_tolstring(L, -1, &newlen);
                    memcpy(nr, newtok, newlen);
                    nr += newlen;
                }",39,,488,2,,void
75902,BLOCK,-1,,"{
                // TODO (v2): if we add an extra ""end"" token that's just reqlen we can
                // memcpy... however most args are short and that may not be worth
                // it.
                or = rq->request + pr->tokens[x];
                // will walk past the end without the \r test.
                // if we add the end token trick this can be changed.
                while (*or != ' ' && *or != '\r' && *or != '\n') {
                    *nr = *or;
                    nr++;
                    or++;
                }
            }",33,,496,2,,void
75929,BLOCK,-1,,"{
                    *nr = *or;
                    nr++;
                    or++;
                }",66,,503,2,,void
75962,BLOCK,1,,<empty>,,,,1,,void
76003,BLOCK,-1,,"{
        p->iov[1].iov_base = pr->vbuf;
        p->iov[1].iov_len = pr->vlen;
        p->iovcnt = 2;
        p->iovbytes += pr->vlen;
    }",24,,526,2,,void
76042,BLOCK,-1,,"{
    size_t len = 0;
    size_t vlen = 0;
    mcp_parser_t pr = {0};
    const char *cmd = luaL_checklstring(L, 1, &len);
    const char *val = NULL;
    int type = lua_type(L, 2);
    if (type == LUA_TSTRING) {
        val = luaL_optlstring(L, 2, NULL, &vlen);
        if (vlen < 2 || memcmp(val+vlen-2, ""\r\n"", 2) != 0) {
            proxy_lua_error(L, ""value passed to mcp.request must end with \\r\\n"");
        }
    } else if (type == LUA_TUSERDATA) {
        // vlen for requests and responses include the ""\r\n"" already.
        mcp_resp_t *r = luaL_testudata(L, 2, ""mcp.response"");
        if (r != NULL) {
            if (r->resp.value) {
                val = r->resp.value;
                vlen = r->resp.vlen_read; // paranoia, so we can't overread into memory.
            }
        } else {
            mcp_request_t *rq = luaL_testudata(L, 2, ""mcp.request"");
            if (rq->pr.vbuf) {
                val = rq->pr.vbuf;
                vlen = rq->pr.vlen;
            }
     ...",34,,537,2,,void
76078,BLOCK,-1,,"{
        val = luaL_optlstring(L, 2, NULL, &vlen);
        if (vlen < 2 || memcmp(val+vlen-2, ""\r\n"", 2) != 0) {
            proxy_lua_error(L, ""value passed to mcp.request must end with \\r\\n"");
        }
    }",30,,544,2,,void
76102,BLOCK,-1,,"{
            proxy_lua_error(L, ""value passed to mcp.request must end with \\r\\n"");
        }",61,,546,2,,void
76107,BLOCK,-1,,<empty>,12,,549,1,,void
76112,BLOCK,-1,,"{
        // vlen for requests and responses include the ""\r\n"" already.
        mcp_resp_t *r = luaL_testudata(L, 2, ""mcp.response"");
        if (r != NULL) {
            if (r->resp.value) {
                val = r->resp.value;
                vlen = r->resp.vlen_read; // paranoia, so we can't overread into memory.
            }
        } else {
            mcp_request_t *rq = luaL_testudata(L, 2, ""mcp.request"");
            if (rq->pr.vbuf) {
                val = rq->pr.vbuf;
                vlen = rq->pr.vlen;
            }
        }
    }",39,,549,2,,void
76124,BLOCK,-1,,"{
            if (r->resp.value) {
                val = r->resp.value;
                vlen = r->resp.vlen_read; // paranoia, so we can't overread into memory.
            }
        }",24,,552,2,,void
76131,BLOCK,-1,,"{
                val = r->resp.value;
                vlen = r->resp.vlen_read; // paranoia, so we can't overread into memory.
            }",32,,553,2,,void
76147,BLOCK,-1,,"{
            mcp_request_t *rq = luaL_testudata(L, 2, ""mcp.request"");
            if (rq->pr.vbuf) {
                val = rq->pr.vbuf;
                vlen = rq->pr.vlen;
            }
        }",16,,557,1,,void
76161,BLOCK,-1,,"{
                val = rq->pr.vbuf;
                vlen = rq->pr.vlen;
            }",30,,559,2,,void
76184,BLOCK,-1,,"{
        proxy_lua_error(L, ""failed to parse request"");
        return 0;
    }",46,,568,2,,void
76203,BLOCK,-1,,"{
        rq->pr.vlen = vlen;
        rq->pr.vbuf = malloc(vlen);
        if (rq->pr.vbuf == NULL) {
            // Note: without *c we can't tick the appropriate counter.
            // However, in practice raw malloc's are nearly never going to
            // fail.
            // TODO(v2): we can stack values into the request objects or use
            // the slabber memory, so this isn't necessary anyway.
            proxy_lua_error(L, ""failed to allocate value memory for request object"");
        }
        memcpy(rq->pr.vbuf, val, vlen);
    }",22,,574,2,,void
76227,BLOCK,-1,,"{
            // Note: without *c we can't tick the appropriate counter.
            // However, in practice raw malloc's are nearly never going to
            // fail.
            // TODO(v2): we can stack values into the request objects or use
            // the slabber memory, so this isn't necessary anyway.
            proxy_lua_error(L, ""failed to allocate value memory for request object"");
        }",34,,577,2,,void
76251,BLOCK,-1,,"{
    mcp_request_t *rq = luaL_checkudata(L, -1, ""mcp.request"");
    lua_pushlstring(L, MCP_PARSER_KEY(rq->pr), rq->pr.klen);
    return 1;
}",38,,593,2,,void
76266,BLOCK,1,,<empty>,,,,5,,void
76296,BLOCK,-1,,"{
    mcp_request_t *rq = luaL_checkudata(L, -2, ""mcp.request"");
    int totrim = luaL_checkinteger(L, -1);
    char *key = (char *) MCP_PARSER_KEY(rq->pr);

    if (totrim > rq->pr.klen) {
        proxy_lua_error(L, ""ltrimkey cannot zero out key"");
        return 0;
    } else {
        memset(key, ' ', totrim);
        rq->pr.klen -= totrim;
        rq->pr.tokens[rq->pr.keytoken] += totrim;
    }
    return 1;
}",43,,604,2,,void
76321,BLOCK,1,,<empty>,,,,5,,void
76348,BLOCK,-1,,"{
        proxy_lua_error(L, ""ltrimkey cannot zero out key"");
        return 0;
    }",31,,609,2,,void
76355,BLOCK,-1,,"{
        memset(key, ' ', totrim);
        rq->pr.klen -= totrim;
        rq->pr.tokens[rq->pr.keytoken] += totrim;
    }",12,,612,1,,void
76386,BLOCK,-1,,"{
    mcp_request_t *rq = luaL_checkudata(L, -2, ""mcp.request"");
    int totrim = luaL_checkinteger(L, -1);
    char *key = (char *) MCP_PARSER_KEY(rq->pr);

    if (totrim > rq->pr.klen) {
        proxy_lua_error(L, ""rtrimkey cannot zero out key"");
        return 0;
    } else {
        memset(key + (rq->pr.klen - totrim), ' ', totrim);
        rq->pr.klen -= totrim;
        // don't need to change the key token.
    }
    return 1;
}",43,,620,2,,void
76411,BLOCK,1,,<empty>,,,,5,,void
76438,BLOCK,-1,,"{
        proxy_lua_error(L, ""rtrimkey cannot zero out key"");
        return 0;
    }",31,,625,2,,void
76445,BLOCK,-1,,"{
        memset(key + (rq->pr.klen - totrim), ' ', totrim);
        rq->pr.klen -= totrim;
        // don't need to change the key token.
    }",12,,628,1,,void
76471,BLOCK,-1,,"{
    mcp_request_t *rq = luaL_checkudata(L, 1, ""mcp.request"");
    int argc = lua_gettop(L);

    if (argc == 1) {
        lua_pushnil(L);
        return 1;
    }

    int token = luaL_checkinteger(L, 2);

    if (token < 1 || token > rq->pr.ntokens) {
        // maybe an error?
        lua_pushnil(L);
        return 1;
    }

    // we hold overwritten or parsed tokens in a lua table.
    if (rq->tokent_ref == 0) {
        // create a presized table that can hold our tokens.
        lua_createtable(L, rq->pr.ntokens, 0);
        // duplicate value to set back
        lua_pushvalue(L, -1);
        rq->tokent_ref = luaL_ref(L, LUA_REGISTRYINDEX);
    } else {
        lua_rawgeti(L, LUA_REGISTRYINDEX, rq->tokent_ref);
    }
    // top of stack should be token table.

    size_t vlen = 0;
    if (argc > 2) {
        // overwriting a token.
        luaL_checklstring(L, 3, &vlen);
        lua_pushvalue(L, 3); // copy to top of stack
        lua_rawseti(L, -2, token);
        rq->was_mod...",40,,637,2,,void
76488,BLOCK,-1,,"{
        lua_pushnil(L);
        return 1;
    }",20,,641,2,,void
76511,BLOCK,-1,,"{
        // maybe an error?
        lua_pushnil(L);
        return 1;
    }",46,,648,2,,void
76522,BLOCK,-1,,"{
        // create a presized table that can hold our tokens.
        lua_createtable(L, rq->pr.ntokens, 0);
        // duplicate value to set back
        lua_pushvalue(L, -1);
        rq->tokent_ref = luaL_ref(L, LUA_REGISTRYINDEX);
    }",30,,655,2,,void
76543,BLOCK,-1,,"{
        lua_rawgeti(L, LUA_REGISTRYINDEX, rq->tokent_ref);
    }",12,,661,1,,void
76558,BLOCK,-1,,"{
        // overwriting a token.
        luaL_checklstring(L, 3, &vlen);
        lua_pushvalue(L, 3); // copy to top of stack
        lua_rawseti(L, -2, token);
        rq->was_modified = true;
        return 0;
    }",19,,667,2,,void
76580,BLOCK,-1,,"{
        // fetching a token.
        if (lua_rawgeti(L, -1, token) != LUA_TSTRING) {
            lua_pop(L, 1); // got a nil, drop it.

            // token not uploaded yet. find the len.
            const char *start = rq->pr.request + rq->pr.tokens[token-1];
            vlen = _process_token_len(&rq->pr, token-1);

            P_DEBUG(""%s: pushing token of len: %lu\n"", __func__, vlen);
            lua_pushlstring(L, start, vlen);
            lua_pushvalue(L, -1); // copy

            lua_rawseti(L, -3, token); // pops copy.
        }

        // return fetched token or copy of new token.
        return 1;
    }",12,,674,1,,void
76589,BLOCK,-1,,"{
            lua_pop(L, 1); // got a nil, drop it.

            // token not uploaded yet. find the len.
            const char *start = rq->pr.request + rq->pr.tokens[token-1];
            vlen = _process_token_len(&rq->pr, token-1);

            P_DEBUG(""%s: pushing token of len: %lu\n"", __func__, vlen);
            lua_pushlstring(L, start, vlen);
            lua_pushvalue(L, -1); // copy

            lua_rawseti(L, -3, token); // pops copy.
        }",55,,676,2,,void
76642,BLOCK,-1,,"{
    mcp_request_t *rq = luaL_checkudata(L, 1, ""mcp.request"");
    lua_pushinteger(L, rq->pr.ntokens);
    return 1;
}",42,,697,2,,void
76663,BLOCK,-1,,"{
    mcp_request_t *rq = luaL_checkudata(L, -1, ""mcp.request"");
    lua_pushinteger(L, rq->pr.command);
    return 1;
}",42,,703,2,,void
76685,BLOCK,-1,,"{
    mcp_request_t *rq = luaL_checkudata(L, 1, ""mcp.request"");
    size_t len = 0;
    const char *flagstr = luaL_checklstring(L, 2, &len);
    if (len != 1) {
        proxy_lua_error(L, ""has_flag(): meta flag must be a single character"");
        return 0;
    }
    if (flagstr[0] < 65 || flagstr[0] > 122) {
        proxy_lua_error(L, ""has_flag(): invalid flag, must be A-Z,a-z"");
        return 0;
    }
    uint64_t flagbit = (uint64_t)1 << (flagstr[0] - 65);
    if (rq->pr.t.meta.flags & flagbit) {
        lua_pushboolean(L, 1);
    } else {
        lua_pushboolean(L, 0);
    }

    return 1;
}",43,,709,2,,void
76709,BLOCK,-1,,"{
        proxy_lua_error(L, ""has_flag(): meta flag must be a single character"");
        return 0;
    }",19,,713,2,,void
76727,BLOCK,-1,,"{
        proxy_lua_error(L, ""has_flag(): invalid flag, must be A-Z,a-z"");
        return 0;
    }",46,,717,2,,void
76757,BLOCK,-1,,"{
        lua_pushboolean(L, 1);
    }",40,,722,2,,void
76762,BLOCK,-1,,"{
        lua_pushboolean(L, 0);
    }",12,,724,1,,void
76772,BLOCK,-1,,"{
    mcp_request_t *rq = luaL_checkudata(L, 1, ""mcp.request"");
    size_t len = 0;
    const char *flagstr = luaL_checklstring(L, 2, &len);
    bool replace = false;
    if (len != 1) {
        proxy_lua_error(L, ""has_flag(): meta flag must be a single character"");
        return 0;
    }
    if (flagstr[0] < 65 || flagstr[0] > 122) {
        proxy_lua_error(L, ""has_flag(): invalid flag, must be A-Z,a-z"");
        return 0;
    }
    if (lua_isstring(L, 3)) {
        // overwriting a flag/token with the third argument.
        // NOTE: semi duplicated from mcplib_request_token()
        if (rq->tokent_ref == 0) {
            // create a presized table that can hold our tokens.
            lua_createtable(L, rq->pr.ntokens, 0);
            rq->tokent_ref = luaL_ref(L, LUA_REGISTRYINDEX);
        }
        replace = true;
    }
    uint64_t flagbit = (uint64_t)1 << (flagstr[0] - 65);

    int ret = 1;
    if (rq->pr.t.meta.flags & flagbit) {
        // The flag definitely exists, but...",45,,733,2,,void
76800,BLOCK,-1,,"{
        proxy_lua_error(L, ""has_flag(): meta flag must be a single character"");
        return 0;
    }",19,,738,2,,void
76818,BLOCK,-1,,"{
        proxy_lua_error(L, ""has_flag(): invalid flag, must be A-Z,a-z"");
        return 0;
    }",46,,742,2,,void
76828,BLOCK,-1,,"{
        // overwriting a flag/token with the third argument.
        // NOTE: semi duplicated from mcplib_request_token()
        if (rq->tokent_ref == 0) {
            // create a presized table that can hold our tokens.
            lua_createtable(L, rq->pr.ntokens, 0);
            rq->tokent_ref = luaL_ref(L, LUA_REGISTRYINDEX);
        }
        replace = true;
    }",29,,746,2,,void
76835,BLOCK,-1,,"{
            // create a presized table that can hold our tokens.
            lua_createtable(L, rq->pr.ntokens, 0);
            rq->tokent_ref = luaL_ref(L, LUA_REGISTRYINDEX);
        }",34,,749,2,,void
76882,BLOCK,-1,,"{
        // The flag definitely exists, but sadly we need to scan for the
        // actual flag to see if it has a token.
        lua_pushboolean(L, 1);
        for (int x = rq->pr.keytoken+1; x < rq->pr.ntokens; x++) {
            const char *s = rq->pr.request + rq->pr.tokens[x];
            if (s[0] == flagstr[0]) {
                size_t vlen = _process_token_len(&rq->pr, x);
                if (vlen > 1) {
                    // strip the flag off the token and return.
                    lua_pushlstring(L, s+1, vlen-1);
                    ret = 2;
                }

                // Have something to replace the flag/token with.
                if (replace) {
                    // table is top of stack.
                    lua_rawgeti(L, LUA_REGISTRYINDEX, rq->tokent_ref);
                    // need to copy the string to top of stack.
                    lua_pushvalue(L, 3);

                    lua_rawseti(L, -2, x+1); // pops copy
                    lua_pop(L, 1); //...",40,,759,2,,void
76887,BLOCK,-1,,<empty>,9,,763,1,,void
76907,BLOCK,4,,"{
            const char *s = rq->pr.request + rq->pr.tokens[x];
            if (s[0] == flagstr[0]) {
                size_t vlen = _process_token_len(&rq->pr, x);
                if (vlen > 1) {
                    // strip the flag off the token and return.
                    lua_pushlstring(L, s+1, vlen-1);
                    ret = 2;
                }

                // Have something to replace the flag/token with.
                if (replace) {
                    // table is top of stack.
                    lua_rawgeti(L, LUA_REGISTRYINDEX, rq->tokent_ref);
                    // need to copy the string to top of stack.
                    lua_pushvalue(L, 3);

                    lua_rawseti(L, -2, x+1); // pops copy
                    lua_pop(L, 1); // pop table
                    rq->was_modified = true;
                }
                break;
            }
        }",66,,763,4,,void
76932,BLOCK,-1,,"{
                size_t vlen = _process_token_len(&rq->pr, x);
                if (vlen > 1) {
                    // strip the flag off the token and return.
                    lua_pushlstring(L, s+1, vlen-1);
                    ret = 2;
                }

                // Have something to replace the flag/token with.
                if (replace) {
                    // table is top of stack.
                    lua_rawgeti(L, LUA_REGISTRYINDEX, rq->tokent_ref);
                    // need to copy the string to top of stack.
                    lua_pushvalue(L, 3);

                    lua_rawseti(L, -2, x+1); // pops copy
                    lua_pop(L, 1); // pop table
                    rq->was_modified = true;
                }
                break;
            }",37,,765,2,,void
76946,BLOCK,-1,,"{
                    // strip the flag off the token and return.
                    lua_pushlstring(L, s+1, vlen-1);
                    ret = 2;
                }",31,,767,2,,void
76960,BLOCK,-1,,"{
                    // table is top of stack.
                    lua_rawgeti(L, LUA_REGISTRYINDEX, rq->tokent_ref);
                    // need to copy the string to top of stack.
                    lua_pushvalue(L, 3);

                    lua_rawseti(L, -2, x+1); // pops copy
                    lua_pop(L, 1); // pop table
                    rq->was_modified = true;
                }",30,,774,2,,void
76987,BLOCK,-1,,"{
        lua_pushboolean(L, 0);
    }",12,,787,1,,void
76997,BLOCK,-1,,"{
    mcp_request_t *rq = luaL_checkudata(L, -1, ""mcp.request"");
    // During nread c->item is the malloc'ed buffer. not yet put into
    // rq->buf - this gets freed because we've also set c->item_malloced if
    // the connection closes before finishing nread.
    if (rq->pr.vbuf != NULL) {
        free(rq->pr.vbuf);
    }

    if (rq->tokent_ref != 0) {
        luaL_unref(L, LUA_REGISTRYINDEX, rq->tokent_ref);
    }
    return 0;
}",37,,794,2,,void
77014,BLOCK,-1,,"{
        free(rq->pr.vbuf);
    }",30,,799,2,,void
77027,BLOCK,-1,,"{
        luaL_unref(L, LUA_REGISTRYINDEX, rq->tokent_ref);
    }",30,,803,2,,void
77046,BLOCK,-1,,<empty>,1,,1,1,,ANY
77057,BLOCK,-1,,<empty>,,,,1,,<empty>
77066,BLOCK,-1,,<empty>,,,,4,,<empty>
77078,BLOCK,-1,,"{
    md5_state_t md5state;

    md5_init( &md5state );
    md5_append( &md5state, (unsigned char *)inString, strlen( inString ) );
    md5_finish( &md5state, md5pword );
}",1,,55,3,,void
77100,BLOCK,-1,,"{
    const cpoint *a = p1;
    const cpoint *b = p2;

    return (a->point < b->point) ? -1 : ((a->point > b->point) ? 1 : 0);
}",59,,63,3,,void
77136,BLOCK,-1,,"{
    // NOTE: seed is ignored!
    // embedding the md5 bits since key is specified with a length here.
    md5_state_t md5state;
    unsigned char digest[16];

    md5_init(&md5state);
    md5_append(&md5state, (unsigned char *)key, len);
    md5_finish(&md5state, digest);

    // mix the hash down (from ketama_hashi)
    unsigned int h = (unsigned int)(( digest[3] << 24 )
                        | ( digest[2] << 16 )
                        | ( digest[1] <<  8 )
                        |   digest[0] );
    return h;
}",79,,70,4,,void
77186,BLOCK,-1,,"{
    ketama_t *kt = (ketama_t *)ctx;
    unsigned int h = hash;
    int highp = kt->total_buckets;
    int lowp = 0, midp;
    unsigned int midval, midval1;

    // divide and conquer array search to find server with next biggest
    // point after what this key hashes to
    while ( 1 )
    {
        midp = (int)( ( lowp+highp ) / 2 );

        if ( midp == kt->total_buckets )
            return kt->continuum[0].id-1; // if at the end, roll back to zeroth

        midval = kt->continuum[midp].point;
        midval1 = midp == 0 ? 0 : kt->continuum[midp-1].point;

        if ( h <= midval && h > midval1 )
            return kt->continuum[midp].id-1;

        if ( midval < h )
            lowp = midp + 1;
        else
            highp = midp - 1;

        if ( lowp > highp )
            return kt->continuum[0].id-1;
    }
}",61,,89,3,,void
77212,BLOCK,-1,,"{
        midp = (int)( ( lowp+highp ) / 2 );

        if ( midp == kt->total_buckets )
            return kt->continuum[0].id-1; // if at the end, roll back to zeroth

        midval = kt->continuum[midp].point;
        midval1 = midp == 0 ? 0 : kt->continuum[midp-1].point;

        if ( h <= midval && h > midval1 )
            return kt->continuum[midp].id-1;

        if ( midval < h )
            lowp = midp + 1;
        else
            highp = midp - 1;

        if ( lowp > highp )
            return kt->continuum[0].id-1;
    }",5,,99,2,,void
77228,BLOCK,-1,,<empty>,13,,103,2,,void
77272,BLOCK,-1,,<empty>,13,,109,2,,void
77287,BLOCK,-1,,<empty>,13,,112,2,,void
77294,BLOCK,-1,,<empty>,13,,114,1,,void
77304,BLOCK,-1,,<empty>,13,,117,2,,void
77324,BLOCK,-1,,"{
    char *hashstring = malloc(hashstring_size);

    for (int k = 0; k < bucket_size; k++) {
        size_t len = snprintf(hashstring, hashstring_size, ""%s:%s-%d"", parts[0], parts[1], k);
        kt->continuum[*cont].point = (unsigned int) XXH3_64bits(hashstring, len);
        kt->continuum[*cont].id = id;
    }

    free(hashstring);
}",70,,131,7,,void
77331,BLOCK,-1,,<empty>,5,,134,1,,void
77341,BLOCK,4,,"{
        size_t len = snprintf(hashstring, hashstring_size, ""%s:%s-%d"", parts[0], parts[1], k);
        kt->continuum[*cont].point = (unsigned int) XXH3_64bits(hashstring, len);
        kt->continuum[*cont].id = id;
    }",43,,134,4,,void
77368,BLOCK,1,,<empty>,,,,3,,void
77393,BLOCK,-1,,"{
    char *hashstring = malloc(hashstring_size);

    for (int k = 0; k < bucket_size / 4; k++) {
        unsigned char digest[16];

        // - create hashing string for ketama
        snprintf(hashstring, hashstring_size, ""%s:%s-%d"", parts[0], parts[1], k);

        // - md5() hash it
        // mostly from ketama.c
        ketama_md5_digest(hashstring, digest);

        /* Use successive 4-bytes from hash as numbers
         * for the points on the circle: */
        for(int h = 0; h < 4; h++ )
        {
            kt->continuum[*cont].point = ( digest[3+h*4] << 24 )
                                  | ( digest[2+h*4] << 16 )
                                  | ( digest[1+h*4] <<  8 )
                                  |   digest[h*4];
            kt->continuum[*cont].id = id;
            (*cont)++;
        }

    }

    free(hashstring);
}",70,,144,7,,void
77400,BLOCK,-1,,<empty>,5,,147,1,,void
77412,BLOCK,4,,"{
        unsigned char digest[16];

        // - create hashing string for ketama
        snprintf(hashstring, hashstring_size, ""%s:%s-%d"", parts[0], parts[1], k);

        // - md5() hash it
        // mostly from ketama.c
        ketama_md5_digest(hashstring, digest);

        /* Use successive 4-bytes from hash as numbers
         * for the points on the circle: */
        for(int h = 0; h < 4; h++ )
        {
            kt->continuum[*cont].point = ( digest[3+h*4] << 24 )
                                  | ( digest[2+h*4] << 16 )
                                  | ( digest[1+h*4] <<  8 )
                                  |   digest[h*4];
            kt->continuum[*cont].id = id;
            (*cont)++;
        }

    }",47,,147,4,,void
77429,BLOCK,-1,,<empty>,9,,159,1,,void
77439,BLOCK,4,,"{
            kt->continuum[*cont].point = ( digest[3+h*4] << 24 )
                                  | ( digest[2+h*4] << 16 )
                                  | ( digest[1+h*4] <<  8 )
                                  |   digest[h*4];
            kt->continuum[*cont].id = id;
            (*cont)++;
        }",9,,160,4,,void
77508,BLOCK,-1,,"{
    char *hashstring = malloc(hashstring_size);

    for (int k = 0; k < bucket_size / 4; k++) {
        unsigned char digest[16];

        // - create hashing string for ketama
        if (strcmp(parts[1], ""11211"") == 0) {
            // twemproxy sources libmemcached as removing the default port
            // from the string if found.
            snprintf(hashstring, hashstring_size, ""%s-%d"", parts[0], k);
        } else {
            snprintf(hashstring, hashstring_size, ""%s:%s-%d"", parts[0], parts[1], k);
        }

        // - md5() hash it
        // mostly from ketama.c
        ketama_md5_digest(hashstring, digest);

        /* Use successive 4-bytes from hash as numbers
         * for the points on the circle: */
        for(int h = 0; h < 4; h++ )
        {
            kt->continuum[*cont].point = ( digest[3+h*4] << 24 )
                                  | ( digest[2+h*4] << 16 )
                                  | ( digest[1+h*4] <<  8 )
                               ...",70,,175,7,,void
77515,BLOCK,-1,,<empty>,5,,178,1,,void
77527,BLOCK,4,,"{
        unsigned char digest[16];

        // - create hashing string for ketama
        if (strcmp(parts[1], ""11211"") == 0) {
            // twemproxy sources libmemcached as removing the default port
            // from the string if found.
            snprintf(hashstring, hashstring_size, ""%s-%d"", parts[0], k);
        } else {
            snprintf(hashstring, hashstring_size, ""%s:%s-%d"", parts[0], parts[1], k);
        }

        // - md5() hash it
        // mostly from ketama.c
        ketama_md5_digest(hashstring, digest);

        /* Use successive 4-bytes from hash as numbers
         * for the points on the circle: */
        for(int h = 0; h < 4; h++ )
        {
            kt->continuum[*cont].point = ( digest[3+h*4] << 24 )
                                  | ( digest[2+h*4] << 16 )
                                  | ( digest[1+h*4] <<  8 )
                                  |   digest[h*4];
            kt->continuum[*cont].id = id;
            (*cont)++;
        }

 ...",47,,178,4,,void
77537,BLOCK,-1,,"{
            // twemproxy sources libmemcached as removing the default port
            // from the string if found.
            snprintf(hashstring, hashstring_size, ""%s-%d"", parts[0], k);
        }",45,,182,2,,void
77547,BLOCK,-1,,"{
            snprintf(hashstring, hashstring_size, ""%s:%s-%d"", parts[0], parts[1], k);
        }",16,,186,1,,void
77563,BLOCK,-1,,<empty>,9,,196,1,,void
77573,BLOCK,4,,"{
            kt->continuum[*cont].point = ( digest[3+h*4] << 24 )
                                  | ( digest[2+h*4] << 16 )
                                  | ( digest[1+h*4] <<  8 )
                                  |   digest[h*4];
            kt->continuum[*cont].id = id;
            (*cont)++;
        }",9,,197,4,,void
77642,BLOCK,-1,,"{
    char *hashstring = malloc(hashstring_size);

    for (int k = 0; k < bucket_size / 4; k++) {
        unsigned char digest[16];

        // - create hashing string for ketama
        snprintf(hashstring, hashstring_size, ""%s/%s:%s-%d"", parts[0], parts[0], parts[1], k);
        // - md5() hash it
        // mostly from ketama.c
        ketama_md5_digest(hashstring, digest);

        /* Use successive 4-bytes from hash as numbers
         * for the points on the circle: */
        for(int h = 0; h < 4; h++ )
        {
            kt->continuum[*cont].point = ( digest[3+h*4] << 24 )
                                  | ( digest[2+h*4] << 16 )
                                  | ( digest[1+h*4] <<  8 )
                                  |   digest[h*4];
            kt->continuum[*cont].id = id;
            (*cont)++;
        }

    }

    free(hashstring);
}",70,,212,7,,void
77649,BLOCK,-1,,<empty>,5,,215,1,,void
77661,BLOCK,4,,"{
        unsigned char digest[16];

        // - create hashing string for ketama
        snprintf(hashstring, hashstring_size, ""%s/%s:%s-%d"", parts[0], parts[0], parts[1], k);
        // - md5() hash it
        // mostly from ketama.c
        ketama_md5_digest(hashstring, digest);

        /* Use successive 4-bytes from hash as numbers
         * for the points on the circle: */
        for(int h = 0; h < 4; h++ )
        {
            kt->continuum[*cont].point = ( digest[3+h*4] << 24 )
                                  | ( digest[2+h*4] << 16 )
                                  | ( digest[1+h*4] <<  8 )
                                  |   digest[h*4];
            kt->continuum[*cont].id = id;
            (*cont)++;
        }

    }",47,,215,4,,void
77681,BLOCK,-1,,<empty>,9,,226,1,,void
77691,BLOCK,4,,"{
            kt->continuum[*cont].point = ( digest[3+h*4] << 24 )
                                  | ( digest[2+h*4] << 16 )
                                  | ( digest[1+h*4] <<  8 )
                                  |   digest[h*4];
            kt->continuum[*cont].id = id;
            (*cont)++;
        }",9,,227,4,,void
77755,BLOCK,-1,,"{
    lua_Integer bucket_size = DEFAULT_BUCKET_SIZE;
    const char *parts[PARTS];
    size_t partlens[PARTS];
    int makemode = 0;

    // check for UA_TTABLE at 1
    luaL_checktype(L, 1, LUA_TTABLE);
    // get number of servers in pool.
    // NOTE: rawlen skips metatable redirection. if we care; lua_len instead.
    lua_Unsigned total = lua_rawlen(L, 1);

    // check for optional input
    int argc = lua_gettop(L);
    if (argc > 1) {
        luaL_checktype(L, 2, LUA_TTABLE);
        if (lua_getfield(L, 2, ""omode"") != LUA_TNIL) {
            luaL_checktype(L, -1, LUA_TSTRING);
            const char *mode = lua_tostring(L, -1);
            if (strcmp(mode, ""default"") == 0) {
                makemode = MODE_DEFAULT;
            } else if (strcmp(mode, ""ketama"") == 0) {
                makemode = MODE_KETAMA;
            } else if (strcmp(mode, ""twemproxy"") == 0) {
                makemode = MODE_TWEMPROXY;
            } else if (strcmp(mode, ""evcache"") == 0) {
                ...",37,,243,2,,void
77760,BLOCK,1,,<empty>,,,,1,,void
77787,BLOCK,-1,,"{
        luaL_checktype(L, 2, LUA_TTABLE);
        if (lua_getfield(L, 2, ""omode"") != LUA_TNIL) {
            luaL_checktype(L, -1, LUA_TSTRING);
            const char *mode = lua_tostring(L, -1);
            if (strcmp(mode, ""default"") == 0) {
                makemode = MODE_DEFAULT;
            } else if (strcmp(mode, ""ketama"") == 0) {
                makemode = MODE_KETAMA;
            } else if (strcmp(mode, ""twemproxy"") == 0) {
                makemode = MODE_TWEMPROXY;
            } else if (strcmp(mode, ""evcache"") == 0) {
                makemode = MODE_EVCACHE;
            } else {
                lua_pushstring(L, ""ring_hash: bad omode argument"");
                lua_error(L);
            }
        }
        lua_pop(L, 1); // pops the nil or mode

        if (lua_getfield(L, 2, ""obuckets"") != LUA_TNIL) {
          int success = 0;
          bucket_size = lua_tointegerx(L, -1, &success);
          if (!success || bucket_size < 1) {
              lua_pushstring(L, ""ring_has...",19,,257,2,,void
77799,BLOCK,-1,,"{
            luaL_checktype(L, -1, LUA_TSTRING);
            const char *mode = lua_tostring(L, -1);
            if (strcmp(mode, ""default"") == 0) {
                makemode = MODE_DEFAULT;
            } else if (strcmp(mode, ""ketama"") == 0) {
                makemode = MODE_KETAMA;
            } else if (strcmp(mode, ""twemproxy"") == 0) {
                makemode = MODE_TWEMPROXY;
            } else if (strcmp(mode, ""evcache"") == 0) {
                makemode = MODE_EVCACHE;
            } else {
                lua_pushstring(L, ""ring_hash: bad omode argument"");
                lua_error(L);
            }
        }",54,,259,2,,void
77818,BLOCK,-1,,"{
                makemode = MODE_DEFAULT;
            }",47,,262,2,,void
77822,BLOCK,1,,<empty>,,,,1,,void
77825,BLOCK,-1,,<empty>,20,,264,1,,void
77832,BLOCK,-1,,"{
                makemode = MODE_KETAMA;
            }",53,,264,2,,void
77836,BLOCK,1,,<empty>,,,,1,,void
77839,BLOCK,-1,,<empty>,20,,266,1,,void
77846,BLOCK,-1,,"{
                makemode = MODE_TWEMPROXY;
            }",56,,266,2,,void
77850,BLOCK,1,,<empty>,,,,1,,void
77853,BLOCK,-1,,<empty>,20,,268,1,,void
77860,BLOCK,-1,,"{
                makemode = MODE_EVCACHE;
            }",54,,268,2,,void
77864,BLOCK,1,,<empty>,,,,1,,void
77867,BLOCK,-1,,"{
                lua_pushstring(L, ""ring_hash: bad omode argument"");
                lua_error(L);
            }",20,,270,1,,void
77883,BLOCK,-1,,"{
          int success = 0;
          bucket_size = lua_tointegerx(L, -1, &success);
          if (!success || bucket_size < 1) {
              lua_pushstring(L, ""ring_hash: option argument must be a positive integer"");
              lua_error(L);
          }
        }",57,,277,2,,void
77903,BLOCK,-1,,"{
              lua_pushstring(L, ""ring_hash: option argument must be a positive integer"");
              lua_error(L);
          }",44,,280,2,,void
77950,BLOCK,-1,,"{
        // key is -2, value is -1.
        // value is another table. need to query it to get what we need for
        // the hash.
        // hash string is: hostname/ipaddr:port-repitition
        // TODO: bother doing error checking?
        lua_getfield(L, -1, ""id"");
        lua_Integer id = lua_tointeger(L, -1);
        lua_pop(L, 1);

        // FIXME: we need to do the lua_pop after string assembly to be safe.
        lua_getfield(L, -1, ""addr"");
        parts[0] = lua_tolstring(L, -1, &partlens[0]);
        lua_pop(L, 1);
        lua_getfield(L, -1, ""port"");
        parts[1] = lua_tolstring(L, -1, &partlens[1]);
        lua_pop(L, 1);

        size_t hashstring_size = 0;
        for (int x = 0; x < PARTS; x++) {
            hashstring_size += partlens[x];
        }

        // We have up to 3 delimiters in the final hashstring and an index
        // 16 bytes is plenty to accomodate this requirement.
        hashstring_size += 16;

        switch (makemode) {
            c...",33,,297,2,,void
78011,BLOCK,-1,,<empty>,9,,316,1,,void
78019,BLOCK,1,,<empty>,,,,1,,void
78023,BLOCK,4,,"{
            hashstring_size += partlens[x];
        }",41,,316,4,,void
78034,BLOCK,-1,,"{
            case MODE_DEFAULT:
                _add_server_default(kt, hashstring_size, parts, bucket_size, id, &cont);
                break;
            case MODE_KETAMA:
                _add_server_ketama(kt, hashstring_size, parts, bucket_size, id, &cont);
                break;
            case MODE_TWEMPROXY:
                _add_server_twemproxy(kt, hashstring_size, parts, bucket_size, id, &cont);
                break;
            case MODE_EVCACHE:
                // EVCache uses the ipaddress couple of times, we need to factor that in
                // when calculating the hashstring_size
                hashstring_size += partlens[0];
                _add_server_evcache(kt, hashstring_size, parts, bucket_size, id, &cont);
                break;
        }",27,,324,2,,void
78037,BLOCK,1,,<empty>,,,,1,,void
78050,BLOCK,1,,<empty>,,,,1,,void
78063,BLOCK,1,,<empty>,,,,1,,void
78076,BLOCK,1,,<empty>,,,,1,,void
78130,BLOCK,-1,,"{
    const struct luaL_Reg ketama_f[] = {
        {""new"", ketama_new},
        {NULL, NULL},
    };

    luaL_newlib(L, ketama_f);
    lua_pushlightuserdata(L, &ketama_key_hash);
    lua_setfield(L, -2, ""hash"");

    return 1;
}",46,,358,2,,void
78163,BLOCK,-1,,<empty>,1,,1,1,,ANY
78166,BLOCK,-1,,"{
    LIBEVENT_THREAD *t = lua_touserdata(L, lua_upvalueindex(MCP_THREAD_UPVALUE));
    if (t != NULL) {
        proxy_lua_error(L, ""add_stat must be called from config_pools"");
        return 0;
    }
    int idx = luaL_checkinteger(L, -2);
    const char *name = luaL_checkstring(L, -1);

    if (idx < 1) {
        proxy_lua_error(L, ""stat index must be 1 or higher"");
        return 0;
    }
    // max user counters? 1024? some weird number.
    if (idx > 1024) {
        proxy_lua_error(L, ""stat index must be 1024 or less"");
        return 0;
    }
    // max name length? avoids errors if something huge gets thrown in.
    if (strlen(name) > STAT_KEY_LEN - 6) {
        // we prepend ""user_"" to the output. + null byte.
        proxy_lua_ferror(L, ""stat name too long: %s\n"", name);
        return 0;
    }
    // restrict characters, at least no spaces/newlines.
    for (int x = 0; x < strlen(name); x++) {
        if (isspace(name[x])) {
            proxy_lua_error(L, ""stat cannot con...",35,,7,2,,void
78174,BLOCK,1,,<empty>,,,,1,,void
78180,BLOCK,-1,,"{
        proxy_lua_error(L, ""add_stat must be called from config_pools"");
        return 0;
    }",20,,9,2,,void
78204,BLOCK,-1,,"{
        proxy_lua_error(L, ""stat index must be 1 or higher"");
        return 0;
    }",18,,16,2,,void
78214,BLOCK,-1,,"{
        proxy_lua_error(L, ""stat index must be 1024 or less"");
        return 0;
    }",21,,21,2,,void
78226,BLOCK,1,,<empty>,,,,1,,void
78229,BLOCK,-1,,"{
        // we prepend ""user_"" to the output. + null byte.
        proxy_lua_ferror(L, ""stat name too long: %s\n"", name);
        return 0;
    }",42,,26,2,,void
78237,BLOCK,-1,,<empty>,5,,32,1,,void
78248,BLOCK,4,,"{
        if (isspace(name[x])) {
            proxy_lua_error(L, ""stat cannot contain spaces or newlines"");
            return 0;
        }
    }",44,,32,4,,void
78254,BLOCK,-1,,"{
            proxy_lua_error(L, ""stat cannot contain spaces or newlines"");
            return 0;
        }",31,,33,2,,void
78268,BLOCK,1,,<empty>,,,,3,,void
78287,BLOCK,-1,,"{
        // don't allocate counters memory for the global ctx.
        char **nnames = calloc(idx, sizeof(char *));
        if (us->names != NULL) {
            for (int x = 0; x < us->num_stats; x++) {
                nnames[x] = us->names[x];
            }
            free(us->names);
        }
        us->names = nnames;
        us->num_stats = idx;
    }",30,,46,2,,void
78301,BLOCK,-1,,"{
            for (int x = 0; x < us->num_stats; x++) {
                nnames[x] = us->names[x];
            }
            free(us->names);
        }",32,,49,2,,void
78303,BLOCK,-1,,<empty>,13,,50,1,,void
78315,BLOCK,4,,"{
                nnames[x] = us->names[x];
            }",53,,50,4,,void
78349,BLOCK,-1,,"{
        free(us->names[idx]);
    }",33,,61,2,,void
78366,BLOCK,1,,<empty>,,,,3,,void
78378,BLOCK,-1,,"{
    LIBEVENT_THREAD *t = lua_touserdata(L, lua_upvalueindex(MCP_THREAD_UPVALUE));
    if (t == NULL) {
        proxy_lua_error(L, ""stat must be called from router handlers"");
        return 0;
    }

    struct proxy_user_stats *tus = t->proxy_user_stats;
    if (tus == NULL) {
        proxy_lua_error(L, ""no stats counters initialized"");
        return 0;
    }

    int idx = luaL_checkinteger(L, -2);
    int change = luaL_checkinteger(L, -1);

    if (idx < 1 || idx > tus->num_stats) {
        proxy_lua_error(L, ""stat index out of range"");
        return 0;
    }

    idx--; // actual array is 0 indexed.
    WSTAT_L(t);
    tus->counters[idx] += change;
    WSTAT_UL(t);

    return 0;
}",31,,72,2,,void
78386,BLOCK,1,,<empty>,,,,1,,void
78392,BLOCK,-1,,"{
        proxy_lua_error(L, ""stat must be called from router handlers"");
        return 0;
    }",20,,74,2,,void
78408,BLOCK,-1,,"{
        proxy_lua_error(L, ""no stats counters initialized"");
        return 0;
    }",22,,80,2,,void
78438,BLOCK,-1,,"{
        proxy_lua_error(L, ""stat index out of range"");
        return 0;
    }",42,,88,2,,void
78448,BLOCK,1,,<empty>,,,,3,,void
78465,BLOCK,1,,<empty>,,,,3,,void
78483,BLOCK,-1,,<empty>,1,,1,1,,ANY
78490,BLOCK,1,,<empty>,,,,1,,void
78494,BLOCK,-1,,"{
    lua_pushlightuserdata(L, &mcplib_hash_xxhash);
    return 1;
}",43,,9,2,,void
78507,BLOCK,-1,,<empty>,1,,1,1,,ANY
78530,BLOCK,-1,,<empty>,1,,1,1,,ANY
78541,BLOCK,-1,,<empty>,,,,1,,<empty>
78544,BLOCK,1,,<empty>,,,,1,,void
78573,BLOCK,-1,,"{
    restart_data_cb *cb = calloc(1, sizeof(restart_data_cb));
    if (cb == NULL) {
        fprintf(stderr, ""[restart] failed to allocate callback register\n"");
        abort();
    }

    // Handle first time call initialization inline so we don't need separate
    // API call.
    if (cb_stack == NULL) {
        cb_stack = cb;
    } else {
        // Ensure we fire the callbacks in registration order.
        // Someday I'll get a queue.h overhaul.
        restart_data_cb *finder = cb_stack;
        while (finder->next != NULL) {
            finder = finder->next;
        }
        finder->next = cb;
    }

    safe_strcpy(cb->tag, tag, RESTART_TAG_MAXLEN);
    cb->data = data;
    cb->ccb = *ccb;
    cb->scb = *scb;
}",95,,33,5,,void
78585,BLOCK,-1,,"{
        fprintf(stderr, ""[restart] failed to allocate callback register\n"");
        abort();
    }",21,,35,2,,void
78594,BLOCK,-1,,"{
        cb_stack = cb;
    }",27,,42,2,,void
78599,BLOCK,-1,,"{
        // Ensure we fire the callbacks in registration order.
        // Someday I'll get a queue.h overhaul.
        restart_data_cb *finder = cb_stack;
        while (finder->next != NULL) {
            finder = finder->next;
        }
        finder->next = cb;
    }",12,,44,1,,void
78610,BLOCK,-1,,"{
            finder = finder->next;
        }",38,,48,2,,void
78627,BLOCK,1,,<empty>,,,,1,,void
78656,BLOCK,-1,,"{
    // metadata is kept in a separate file.
    size_t flen = strlen(file);
    const char *ext = "".meta"";
    char *metafile = calloc(1, flen + strlen(ext) + 1);
    if (metafile == NULL) {
        // probably in a really bad position if we hit here, so don't start.
        fprintf(stderr, ""[restart] failed to allocate memory for restart check\n"");
        abort();
    }
    memcpy(metafile, file, flen);
    memcpy(metafile+flen, ext, strlen(ext));

    FILE *f = fopen(metafile, ""r"");
    if (f == NULL) {
        fprintf(stderr, ""[restart] no metadata save file, starting with a clean cache\n"");
        free(metafile);
        return -1;
    }

    restart_cb_ctx ctx;

    ctx.f = f;
    ctx.cb = NULL;
    ctx.line = NULL;
    ctx.done = false;
    if (restart_get_kv(&ctx, NULL, NULL) != RESTART_DONE) {
        // First line must be a tag, so read it in and set up the proper
        // callback here.
        fprintf(stderr, ""[restart] corrupt metadata file\n"");
        // TODO: th...",44,,72,2,,void
78681,BLOCK,-1,,"{
        // probably in a really bad position if we hit here, so don't start.
        fprintf(stderr, ""[restart] failed to allocate memory for restart check\n"");
        abort();
    }",27,,77,2,,void
78707,BLOCK,-1,,"{
        fprintf(stderr, ""[restart] no metadata save file, starting with a clean cache\n"");
        free(metafile);
        return -1;
    }",20,,86,2,,void
78745,BLOCK,-1,,"{
        // First line must be a tag, so read it in and set up the proper
        // callback here.
        fprintf(stderr, ""[restart] corrupt metadata file\n"");
        // TODO: this should probably just return -1 and skip the reuse.
        abort();
    }",59,,98,2,,void
78756,BLOCK,-1,,"{
        fprintf(stderr, ""[restart] Failed to read a tag from metadata file\n"");
        abort();
    }",25,,105,2,,void
78770,BLOCK,-1,,"{
        restart_data_cb *cb = ctx.cb;
        if (cb->ccb(cb->tag, &ctx, cb->data) != 0) {
            failed = true;
            break;
        }
    }",23,,112,2,,void
78792,BLOCK,-1,,"{
            failed = true;
            break;
        }",52,,114,2,,void
78801,BLOCK,-1,,<empty>,9,,121,2,,void
78814,BLOCK,-1,,"{
        fprintf(stderr, ""[restart] failed to validate metadata, starting with a clean cache\n"");
        return -1;
    }",17,,128,2,,void
78822,BLOCK,-1,,"{
        return 0;
    }",12,,131,1,,void
78831,BLOCK,-1,,"{
    char *line = NULL;
    size_t len = 0;
    restart_data_cb *cb = NULL;
    restart_cb_ctx *c = (restart_cb_ctx *) ctx;
    // free previous line.
    // we could just pass it into getline, but it can randomly realloc so we'd
    // have to re-assign it into the structure anyway.
    if (c->line != NULL) {
        free(c->line);
        c->line = NULL;
    }

    if (getline(&line, &len, c->f) != -1) {
        // First char is an indicator:
        // T for TAG, changing the callback we use.
        // K for key/value, to ship to the active callback.
        char *p = line;
        while (*p != '\n') {
            p++;
        }
        *p = '\0';

        if (line[0] == 'T') {
            cb = cb_stack;
            while (cb != NULL) {
                // NOTE: len is allocated size, not line len. need to chomp \n
                if (strcmp(cb->tag, line+1) == 0) {
                    break;
                }
                cb = cb->next;
            }
            if (cb == NU...",75,,141,4,,void
78856,BLOCK,-1,,"{
        free(c->line);
        c->line = NULL;
    }",26,,149,2,,void
78878,BLOCK,-1,,"{
        // First char is an indicator:
        // T for TAG, changing the callback we use.
        // K for key/value, to ship to the active callback.
        char *p = line;
        while (*p != '\n') {
            p++;
        }
        *p = '\0';

        if (line[0] == 'T') {
            cb = cb_stack;
            while (cb != NULL) {
                // NOTE: len is allocated size, not line len. need to chomp \n
                if (strcmp(cb->tag, line+1) == 0) {
                    break;
                }
                cb = cb->next;
            }
            if (cb == NULL) {
                fprintf(stderr, ""[restart] internal handler for metadata tag not found: %s:\n"", line+1);
                return RESTART_NOTAG;
            }
            c->cb = cb;
        } else if (line[0] == 'K') {
            char *p = line+1; // start just ahead of the token.
            // tokenize the string and return the pointers?
            if (key != NULL) {
                *key = p;
    ...",43,,154,2,,void
78888,BLOCK,-1,,"{
            p++;
        }",28,,159,2,,void
78901,BLOCK,-1,,"{
            cb = cb_stack;
            while (cb != NULL) {
                // NOTE: len is allocated size, not line len. need to chomp \n
                if (strcmp(cb->tag, line+1) == 0) {
                    break;
                }
                cb = cb->next;
            }
            if (cb == NULL) {
                fprintf(stderr, ""[restart] internal handler for metadata tag not found: %s:\n"", line+1);
                return RESTART_NOTAG;
            }
            c->cb = cb;
        }",29,,164,2,,void
78909,BLOCK,-1,,"{
                // NOTE: len is allocated size, not line len. need to chomp \n
                if (strcmp(cb->tag, line+1) == 0) {
                    break;
                }
                cb = cb->next;
            }",32,,166,2,,void
78920,BLOCK,-1,,"{
                    break;
                }",51,,168,2,,void
78931,BLOCK,-1,,"{
                fprintf(stderr, ""[restart] internal handler for metadata tag not found: %s:\n"", line+1);
                return RESTART_NOTAG;
            }",29,,173,2,,void
78946,BLOCK,-1,,<empty>,16,,178,1,,void
78953,BLOCK,-1,,"{
            char *p = line+1; // start just ahead of the token.
            // tokenize the string and return the pointers?
            if (key != NULL) {
                *key = p;
            }

            // turn key into a normal NULL terminated string.
            while (*p != ' ' && (p - line < len)) {
                p++;
            }
            *p = '\0';
            p++;

            // value _should_ run until where the newline was, which is \0 now
            if (val != NULL) {
                *val = p;
            }
            c->line = line;

            return RESTART_OK;
        }",36,,178,2,,void
78964,BLOCK,-1,,"{
                *key = p;
            }",30,,181,2,,void
78980,BLOCK,-1,,"{
                p++;
            }",51,,186,2,,void
78993,BLOCK,-1,,"{
                *val = p;
            }",30,,193,2,,void
79006,BLOCK,-1,,"{
            // FIXME: proper error chain.
            fprintf(stderr, ""[restart] invalid metadata line:\n\n%s\n"", line);
            free(line);
            return RESTART_BADLINE;
        }",16,,199,1,,void
79016,BLOCK,-1,,"{
        // EOF or error in read.
        c->done = true;
    }",12,,205,1,,void
79028,BLOCK,-1,,"{
    // metadata is kept in a separate file.
    // FIXME: function.
    size_t flen = strlen(file);
    const char *ext = "".meta"";
    size_t extlen = strlen(ext);
    char *metafile = calloc(1, flen + extlen + 1);
    if (metafile == NULL) {
        fprintf(stderr, ""[restart] failed to allocate memory during metadata save\n"");
        return -1;
    }
    memcpy(metafile, file, flen);
    memcpy(metafile+flen, ext, extlen);

    // restrictive permissions for the metadata file.
    // TODO: also for the mmap file eh? :P
    mode_t oldmask = umask(~(S_IRUSR | S_IWUSR));
    FILE *f = fopen(metafile, ""w"");
    umask(oldmask);
    if (f == NULL) {
        // FIXME: correct error handling.
        free(metafile);
        perror(""failed to write metadata file"");
        return -1;
    }

    restart_data_cb *cb = cb_stack;
    restart_cb_ctx ctx;
    ctx.f = f;
    while (cb != NULL) {
        // Plugins/engines in the metadata file are separated by tag lines.
        fprintf(f, ""T%s\...",43,,217,2,,void
79057,BLOCK,-1,,"{
        fprintf(stderr, ""[restart] failed to allocate memory during metadata save\n"");
        return -1;
    }",27,,224,2,,void
79094,BLOCK,-1,,"{
        // FIXME: correct error handling.
        free(metafile);
        perror(""failed to write metadata file"");
        return -1;
    }",20,,236,2,,void
79116,BLOCK,-1,,"{
        // Plugins/engines in the metadata file are separated by tag lines.
        fprintf(f, ""T%s\n"", cb->tag);
        if (cb->scb(cb->tag, &ctx, cb->data) != 0) {
            fclose(f);
            free(metafile);
            return -1;
        }

        cb = cb->next;
    }",24,,246,2,,void
79138,BLOCK,-1,,"{
            fclose(f);
            free(metafile);
            return -1;
        }",52,,249,2,,void
79163,BLOCK,-1,,"{
    va_list ap;
    restart_cb_ctx *c = (restart_cb_ctx *) ctx;
    char valbuf[SET_VAL_MAX];

    va_start(ap, fmt);
    int vlen = vsnprintf(valbuf, SET_VAL_MAX-1, fmt, ap);
    va_end(ap);
    // This is heavy handed. We need to protect against corrupt data as much
    // as possible. The buffer is large and these values are currently small,
    // it will take a significant mistake to land here.
    if (vlen >= SET_VAL_MAX) {
        fprintf(stderr, ""[restart] fatal error while saving metadata state, value too long for: %s %s"",
                key, valbuf);
        abort();
    }

    fprintf(c->f, ""K%s %s\n"", key, valbuf);
    // TODO: update crc32c
}",71,,268,4,,void
79182,BLOCK,1,,<empty>,,,,1,,void
79193,BLOCK,1,,<empty>,,,,1,,void
79195,BLOCK,-1,,"{
        fprintf(stderr, ""[restart] fatal error while saving metadata state, value too long for: %s %s"",
                key, valbuf);
        abort();
    }",30,,279,2,,void
79213,BLOCK,-1,,"{
#if defined(HAVE_SYSCONF) && defined(_SC_PAGESIZE)
    return sysconf(_SC_PAGESIZE);
#else
    // A good guess.
    return 4096;
#endif
}",34,,289,2,,void
79222,BLOCK,-1,,"{
    bool reuse_mmap = true;

    long pagesize = _find_pagesize();
    memory_file = strdup(file);
    mmap_fd = open(file, O_RDWR|O_CREAT, S_IRWXU);
    if (mmap_fd == -1) {
        perror(""failed to open file for mmap"");
        abort();
    }
    if (ftruncate(mmap_fd, limit) != 0) {
        perror(""ftruncate failed"");
        abort();
    }
    /* Allocate everything in a big chunk with malloc */
    if (limit % pagesize) {
        // This is a sanity check; shouldn't ever be possible since we
        // increase memory by whole megabytes.
        fprintf(stderr, ""[restart] memory limit not divisible evenly by pagesize (please report bug)\n"");
        abort();
    }
    mmap_base = mmap(NULL, limit, PROT_READ|PROT_WRITE, MAP_SHARED, mmap_fd, 0);
    if (mmap_base == MAP_FAILED) {
        perror(""failed to mmap, aborting"");
        abort();
    }
    // Set the limit before calling check_mmap, so we can find the meta page..
    slabmem_limit = limit;
    if (restart_check(file)...",79,,298,4,,void
79248,BLOCK,-1,,"{
        perror(""failed to open file for mmap"");
        abort();
    }",24,,304,2,,void
79258,BLOCK,-1,,"{
        perror(""ftruncate failed"");
        abort();
    }",41,,308,2,,void
79266,BLOCK,-1,,"{
        // This is a sanity check; shouldn't ever be possible since we
        // increase memory by whole megabytes.
        fprintf(stderr, ""[restart] memory limit not divisible evenly by pagesize (please report bug)\n"");
        abort();
    }",27,,313,2,,void
79286,BLOCK,-1,,"{
        perror(""failed to mmap, aborting"");
        abort();
    }",34,,320,2,,void
79298,BLOCK,-1,,"{
        reuse_mmap = false;
    }",35,,326,2,,void
79312,BLOCK,-1,,"{
    msync(mmap_base, slabmem_limit, MS_SYNC);

    if (restart_save(memory_file) != 0) {
        fprintf(stderr, ""[restart] failed to save metadata"");
    }

    if (munmap(mmap_base, slabmem_limit) != 0) {
        perror(""[restart] failed to munmap shared memory"");
    } else if (close(mmap_fd) != 0) {
        perror(""[restart] failed to close shared memory fd"");
    }

    free(memory_file);
}",31,,335,2,,void
79322,BLOCK,-1,,"{
        fprintf(stderr, ""[restart] failed to save metadata"");
    }",41,,338,2,,void
79332,BLOCK,-1,,"{
        perror(""[restart] failed to munmap shared memory"");
    }",48,,342,2,,void
79336,BLOCK,-1,,<empty>,12,,344,1,,void
79342,BLOCK,-1,,"{
        perror(""[restart] failed to close shared memory fd"");
    }",37,,344,2,,void
79351,BLOCK,-1,,"{
    struct timeval tv;
    uint64_t checked = 0;
    const unsigned int page_size = settings.slab_page_size;
    unsigned int page_remain = page_size;

    gettimeofday(&tv, NULL);
    if (settings.verbose > 0) {
        fprintf(stderr, ""[restart] original memory base: [%p] new base: [%p]\n"", orig_addr, mmap_base);
        fprintf(stderr, ""[restart] recovery start [%d.%d]\n"", (int)tv.tv_sec, (int)tv.tv_usec);
    }

    // since chunks don't align with pages, we have to also track page size.
    while (checked < slabmem_limit) {
        //fprintf(stderr, ""checked: %lu\n"", checked);
        item *it = (item *)((char *)mmap_base + checked);

        int size = slabs_fixup((char *)mmap_base + checked,
                checked % settings.slab_page_size);
        //fprintf(stderr, ""id: %d, size: %d remain: %u\n"", it->slabs_clsid, size, page_remain);
        // slabber gobbled an entire page, skip and move on.
        if (size == -1) {
            assert(page_remain % page_size == 0);
  ...",45,,354,2,,void
79377,BLOCK,-1,,"{
        fprintf(stderr, ""[restart] original memory base: [%p] new base: [%p]\n"", orig_addr, mmap_base);
        fprintf(stderr, ""[restart] recovery start [%d.%d]\n"", (int)tv.tv_sec, (int)tv.tv_usec);
    }",31,,361,2,,void
79400,BLOCK,-1,,"{
        //fprintf(stderr, ""checked: %lu\n"", checked);
        item *it = (item *)((char *)mmap_base + checked);

        int size = slabs_fixup((char *)mmap_base + checked,
                checked % settings.slab_page_size);
        //fprintf(stderr, ""id: %d, size: %d remain: %u\n"", it->slabs_clsid, size, page_remain);
        // slabber gobbled an entire page, skip and move on.
        if (size == -1) {
            assert(page_remain % page_size == 0);
            assert(page_remain == page_size);
            checked += page_remain;
            page_remain = page_size;
            continue;
        }

        if (it->it_flags & ITEM_LINKED) {
            // fixup next/prev links while on LRU.
            if (it->next) {
                it->next = (item *)((mc_ptr_t)it->next - (mc_ptr_t)orig_addr);
                it->next = (item *)((mc_ptr_t)it->next + (mc_ptr_t)mmap_base);
            }
            if (it->prev) {
                it->prev = (item *)((mc_ptr_t)it->prev - (mc_ptr...",37,,367,2,,void
79430,BLOCK,-1,,"{
            assert(page_remain % page_size == 0);
            assert(page_remain == page_size);
            checked += page_remain;
            page_remain = page_size;
            continue;
        }",25,,375,2,,void
79454,BLOCK,1,,<empty>,,,,1,,void
79456,BLOCK,-1,,"{
            // fixup next/prev links while on LRU.
            if (it->next) {
                it->next = (item *)((mc_ptr_t)it->next - (mc_ptr_t)orig_addr);
                it->next = (item *)((mc_ptr_t)it->next + (mc_ptr_t)mmap_base);
            }
            if (it->prev) {
                it->prev = (item *)((mc_ptr_t)it->prev - (mc_ptr_t)orig_addr);
                it->prev = (item *)((mc_ptr_t)it->prev + (mc_ptr_t)mmap_base);
            }

            //fprintf(stderr, ""item was linked\n"");
            do_item_link_fixup(it);
        }",41,,383,2,,void
79461,BLOCK,-1,,"{
                it->next = (item *)((mc_ptr_t)it->next - (mc_ptr_t)orig_addr);
                it->next = (item *)((mc_ptr_t)it->next + (mc_ptr_t)mmap_base);
            }",27,,385,2,,void
79496,BLOCK,-1,,"{
                it->prev = (item *)((mc_ptr_t)it->prev - (mc_ptr_t)orig_addr);
                it->prev = (item *)((mc_ptr_t)it->prev + (mc_ptr_t)mmap_base);
            }",27,,389,2,,void
79536,BLOCK,1,,<empty>,,,,1,,void
79539,BLOCK,1,,<empty>,,,,1,,void
79541,BLOCK,-1,,"{
            item_chunk *ch;
            if (it->it_flags & ITEM_CHUNKED) {
                ch = (item_chunk *) ITEM_schunk(it);
                // Sigh. Chunked items are a hack; the clsid is the clsid of
                // the full object (always the largest slab class) rather than
                // the actual chunk.
                // I bet this is fixable :(
                size = slabs_size(ch->orig_clsid);
                //fprintf(stderr, ""fixing chunked item header [%d]\n"", size);
            } else {
                //fprintf(stderr, ""fixing item chunk [%d]\n"", size);
                ch = (item_chunk *) it;
            }
            if (ch->next) {
                ch->next = (item_chunk *)((mc_ptr_t)ch->next - (mc_ptr_t)orig_addr);
                ch->next = (item_chunk *)((mc_ptr_t)ch->next + (mc_ptr_t)mmap_base);
            }
            if (ch->prev) {
                ch->prev = (item_chunk *)((mc_ptr_t)ch->prev - (mc_ptr_t)orig_addr);
                ch->prev = (item...",55,,398,2,,void
79549,BLOCK,1,,<empty>,,,,1,,void
79551,BLOCK,-1,,"{
                ch = (item_chunk *) ITEM_schunk(it);
                // Sigh. Chunked items are a hack; the clsid is the clsid of
                // the full object (always the largest slab class) rather than
                // the actual chunk.
                // I bet this is fixable :(
                size = slabs_size(ch->orig_clsid);
                //fprintf(stderr, ""fixing chunked item header [%d]\n"", size);
            }",46,,400,2,,void
79558,BLOCK,1,,<empty>,,,,6,,void
79598,BLOCK,-1,,"{
                //fprintf(stderr, ""fixing item chunk [%d]\n"", size);
                ch = (item_chunk *) it;
            }",20,,408,1,,void
79608,BLOCK,-1,,"{
                ch->next = (item_chunk *)((mc_ptr_t)ch->next - (mc_ptr_t)orig_addr);
                ch->next = (item_chunk *)((mc_ptr_t)ch->next + (mc_ptr_t)mmap_base);
            }",27,,412,2,,void
79643,BLOCK,-1,,"{
                ch->prev = (item_chunk *)((mc_ptr_t)ch->prev - (mc_ptr_t)orig_addr);
                ch->prev = (item_chunk *)((mc_ptr_t)ch->prev + (mc_ptr_t)mmap_base);
            }",27,,416,2,,void
79678,BLOCK,-1,,"{
                ch->head = (item *)((mc_ptr_t)ch->head - (mc_ptr_t)orig_addr);
                ch->head = (item *)((mc_ptr_t)ch->head + (mc_ptr_t)mmap_base);
            }",27,,420,2,,void
79719,BLOCK,-1,,"{
            //fprintf(stderr, ""doot %d\n"", page_remain);
            checked += page_remain;
            page_remain = settings.slab_page_size;
        }",33,,429,2,,void
79734,BLOCK,-1,,"{
        gettimeofday(&tv, NULL);
        fprintf(stderr, ""[restart] recovery end [%d.%d]\n"", (int)tv.tv_sec, (int)tv.tv_usec);
    }",31,,437,2,,void
79760,BLOCK,-1,,<empty>,1,,1,1,,ANY
79768,BLOCK,-1,,<empty>,,,,1,,<empty>
79778,BLOCK,-1,,<empty>,,,,4,,<empty>
79785,BLOCK,-1,,<empty>,,,,4,,<empty>
79793,BLOCK,-1,,<empty>,,,,5,,<empty>
79800,BLOCK,-1,,<empty>,,,,4,,<empty>
79809,BLOCK,-1,,<empty>,,,,4,,<empty>
79814,BLOCK,-1,,<empty>,,,,2,,<empty>
79819,BLOCK,-1,,<empty>,,,,2,,<empty>
79836,BLOCK,-1,,<empty>,1,,1,1,,ANY
79842,BLOCK,-1,,<empty>,,,,2,,<empty>
79849,BLOCK,-1,,"{
    bool log = true;

    switch (level) {
    case SASL_LOG_NONE:
        log = false;
        break;
    case SASL_LOG_PASS:
    case SASL_LOG_TRACE:
    case SASL_LOG_DEBUG:
    case SASL_LOG_NOTE:
        if (settings.verbose < 2) {
            log = false;
        }
        break;
    case SASL_LOG_WARN:
    case SASL_LOG_FAIL:
        if (settings.verbose < 1) {
            log = false;
        }
        break;
    default:
        /* This is an error */
        ;
    }

    if (log) {
        fprintf(stderr, ""SASL (severity %d): %s\n"", level, message);
    }

    return SASL_OK;
}",1,,142,4,,void
79856,BLOCK,-1,,"{
    case SASL_LOG_NONE:
        log = false;
        break;
    case SASL_LOG_PASS:
    case SASL_LOG_TRACE:
    case SASL_LOG_DEBUG:
    case SASL_LOG_NOTE:
        if (settings.verbose < 2) {
            log = false;
        }
        break;
    case SASL_LOG_WARN:
    case SASL_LOG_FAIL:
        if (settings.verbose < 1) {
            log = false;
        }
        break;
    default:
        /* This is an error */
        ;
    }",20,,145,2,,void
79877,BLOCK,-1,,"{
            log = false;
        }",35,,153,2,,void
79892,BLOCK,-1,,"{
            log = false;
        }",35,,159,2,,void
79900,BLOCK,-1,,"{
        fprintf(stderr, ""SASL (severity %d): %s\n"", level, message);
    }",14,,168,2,,void
79908,BLOCK,1,,<empty>,,,,1,,void
79934,BLOCK,-1,,<empty>,1,,1,1,,ANY
79944,BLOCK,-1,,<empty>,1,,1,1,,ANY
79948,BLOCK,-1,,"{
    printf(""%s\t%d\n"", name, (int)size);
}",52,,5,3,,void
79960,BLOCK,-1,,"{

    display(""Slab Stats"", sizeof(struct slab_stats));
    display(""Thread stats"",
            sizeof(struct thread_stats)
            - (200 * sizeof(struct slab_stats)));
    display(""Global stats"", sizeof(struct stats));
    display(""Settings"", sizeof(struct settings));
    display(""Item (no cas)"", sizeof(item));
    display(""Item (cas)"", sizeof(item) + sizeof(uint64_t));
#ifdef EXTSTORE
    display(""extstore header"", sizeof(item_hdr));
#endif
    display(""Libevent thread"",
            sizeof(LIBEVENT_THREAD) - sizeof(struct thread_stats));
    display(""Connection"", sizeof(conn));
    display(""Response object"", sizeof(mc_resp));
    display(""Response bundle"", sizeof(mc_resp_bundle));
    display(""Response objects per bundle"", MAX_RESP_PER_BUNDLE);

    printf(""----------------------------------------\n"");

    display(""libevent thread cumulative"", sizeof(LIBEVENT_THREAD));
    display(""Thread stats cumulative\t"", sizeof(struct thread_stats));

    return 0;
}",33,,9,3,,void
80015,BLOCK,1,,<empty>,,,,1,,void
80049,BLOCK,-1,,<empty>,1,,1,1,,ANY
80066,BLOCK,-1,,<empty>,,,,1,,<empty>
80069,BLOCK,1,,<empty>,,,,1,,void
80075,BLOCK,1,,<empty>,,,,1,,void
80081,BLOCK,1,,<empty>,,,,1,,void
80087,BLOCK,1,,<empty>,,,,1,,void
80096,BLOCK,-1,,"{
    uint32_t window_size = settings->slab_automove_window;
    double max_age_ratio = settings->slab_automove_ratio;
    slab_automove *a = calloc(1, sizeof(slab_automove));
    if (a == NULL)
        return NULL;
    a->window_data = calloc(window_size * MAX_NUMBER_OF_SLAB_CLASSES, sizeof(struct window_data));
    a->window_size = window_size;
    a->max_age_ratio = max_age_ratio;
    if (a->window_data == NULL) {
        free(a);
        return NULL;
    }

    // do a dry run to fill the before structs
    fill_item_stats_automove(a->iam_before);
    fill_slab_stats_automove(a->sam_before);

    return (void *)a;
}",53,,34,2,,void
80120,BLOCK,-1,,<empty>,9,,39,2,,void
80131,BLOCK,1,,<empty>,,,,1,,void
80153,BLOCK,-1,,"{
        free(a);
        return NULL;
    }",33,,43,2,,void
80174,BLOCK,-1,,"{
    slab_automove *a = (slab_automove *)arg;
    free(a->window_data);
    free(a);
}",36,,55,2,,void
80193,BLOCK,-1,,"{
    int x;
    for (x = 0; x < size; x++) {
        struct window_data *d = &wd[x];
        w->age += d->age;
        w->dirty += d->dirty;
        w->evicted_ratio += d->evicted_ratio;
        w->evicted_seen += d->evicted_seen;
    }
}",86,,61,4,,void
80196,BLOCK,-1,,<empty>,5,,63,1,,void
80205,BLOCK,4,,"{
        struct window_data *d = &wd[x];
        w->age += d->age;
        w->dirty += d->dirty;
        w->evicted_ratio += d->evicted_ratio;
        w->evicted_seen += d->evicted_seen;
    }",32,,63,4,,void
80247,BLOCK,-1,,"{
    slab_automove *a = (slab_automove *)arg;
    int n;
    struct window_data w_sum;
    int oldest = -1;
    uint64_t oldest_age = 0;
    int youngest = -1;
    uint64_t youngest_age = ~0;
    bool youngest_evicting = false;
    *src = -1;
    *dst = -1;

    // fill after structs
    fill_item_stats_automove(a->iam_after);
    fill_slab_stats_automove(a->sam_after);
    // Loop once to get total_evicted for this window.
    uint64_t evicted_total = 0;
    for (n = POWER_SMALLEST; n < MAX_NUMBER_OF_SLAB_CLASSES; n++) {
        evicted_total += a->iam_after[n].evicted - a->iam_before[n].evicted;
    }
    a->window_cur++;

    // iterate slabs
    for (n = POWER_SMALLEST; n < MAX_NUMBER_OF_SLAB_CLASSES; n++) {
        int w_offset = n * a->window_size;
        struct window_data *wd = &a->window_data[w_offset + (a->window_cur % a->window_size)];
        memset(wd, 0, sizeof(struct window_data));

        // if page delta, or evicted delta, mark window dirty
        // (or outofme...",55,,74,4,,void
80302,BLOCK,-1,,<empty>,5,,91,1,,void
80306,BLOCK,1,,<empty>,,,,1,,void
80311,BLOCK,1,,<empty>,,,,1,,void
80317,BLOCK,4,,"{
        evicted_total += a->iam_after[n].evicted - a->iam_before[n].evicted;
    }",67,,91,4,,void
80340,BLOCK,-1,,<empty>,5,,97,1,,void
80344,BLOCK,1,,<empty>,,,,1,,void
80349,BLOCK,1,,<empty>,,,,1,,void
80355,BLOCK,4,,"{
        int w_offset = n * a->window_size;
        struct window_data *wd = &a->window_data[w_offset + (a->window_cur % a->window_size)];
        memset(wd, 0, sizeof(struct window_data));

        // if page delta, or evicted delta, mark window dirty
        // (or outofmemory)
        uint64_t evicted_delta = a->iam_after[n].evicted - a->iam_before[n].evicted;
        if (evicted_delta > 0) {
            // FIXME: the python script is using floats. we have ints.
            wd->evicted_ratio = (float) evicted_delta / evicted_total;
            wd->evicted_seen = 1;
            wd->dirty = 1;
        }

        if (a->iam_after[n].outofmemory - a->iam_before[n].outofmemory > 0) {
            wd->dirty = 1;
        }
        if (a->sam_after[n].total_pages - a->sam_before[n].total_pages > 0) {
            wd->dirty = 1;
        }

        // set age into window
        wd->age = a->iam_after[n].age;

        // summarize the window-up-to-now.
        memset(&w_sum, 0, sizeof(struc...",67,,97,4,,void
80408,BLOCK,-1,,"{
            // FIXME: the python script is using floats. we have ints.
            wd->evicted_ratio = (float) evicted_delta / evicted_total;
            wd->evicted_seen = 1;
            wd->dirty = 1;
        }",32,,105,2,,void
80446,BLOCK,-1,,"{
            wd->dirty = 1;
        }",77,,112,2,,void
80470,BLOCK,-1,,"{
            wd->dirty = 1;
        }",77,,115,2,,void
80533,BLOCK,1,,<empty>,,,,1,,void
80535,BLOCK,-1,,"{
            if (w_sum.dirty == 0) {
                *src = n;
                *dst = 0;
                youngest = oldest = -1;
                break;
            }
        }",100,,130,2,,void
80542,BLOCK,-1,,"{
                *src = n;
                *dst = 0;
                youngest = oldest = -1;
                break;
            }",35,,131,2,,void
80572,BLOCK,1,,<empty>,,,,1,,void
80574,BLOCK,-1,,"{
            oldest = n;
            oldest_age = age;
        }",85,,140,2,,void
80605,BLOCK,-1,,"{
            youngest = n;
            youngest_age = age;
            youngest_evicting = wd->evicted_seen ? true : false;
        }",70,,149,2,,void
80631,BLOCK,1,,<empty>,,,,1,,void
80646,BLOCK,1,,<empty>,,,,1,,void
80668,BLOCK,-1,,"{
        if (youngest_age < ((double)oldest_age * a->max_age_ratio) && youngest_evicting) {
            *src = oldest;
            *dst = youngest;
        }
    }",75,,162,2,,void
80681,BLOCK,-1,,"{
            *src = oldest;
            *dst = youngest;
        }",90,,163,2,,void
80697,BLOCK,-1,,<empty>,1,,1,1,,ANY
80700,BLOCK,-1,,<empty>,,,,2,,<empty>
80705,BLOCK,-1,,<empty>,,,,2,,<empty>
80712,BLOCK,-1,,<empty>,,,,4,,<empty>
80717,BLOCK,-1,,<empty>,,,,2,,<empty>
80722,BLOCK,-1,,<empty>,,,,2,,<empty>
80729,BLOCK,-1,,<empty>,,,,4,,<empty>
80749,BLOCK,-1,,<empty>,1,,1,1,,ANY
80773,BLOCK,-1,,<empty>,,,,1,,<empty>
80776,BLOCK,1,,<empty>,,,,1,,void
80782,BLOCK,1,,<empty>,,,,1,,void
80788,BLOCK,1,,<empty>,,,,1,,void
80794,BLOCK,1,,<empty>,,,,1,,void
80803,BLOCK,-1,,"{
    uint32_t window_size = settings->slab_automove_window;
    double max_age_ratio = settings->slab_automove_ratio;
    slab_automove *a = calloc(1, sizeof(slab_automove));
    if (a == NULL)
        return NULL;
    a->window_data = calloc(window_size * MAX_NUMBER_OF_SLAB_CLASSES, sizeof(struct window_data));
    a->window_size = window_size;
    a->max_age_ratio = max_age_ratio;
    a->free_ratio = settings->slab_automove_freeratio;
    a->item_size = settings->ext_item_size;
    a->settings = settings;
    a->pool_filled_once = false;
    if (a->window_data == NULL) {
        if (a->window_data)
            free(a->window_data);
        free(a);
        return NULL;
    }

    // do a dry run to fill the before structs
    fill_item_stats_automove(a->iam_before);
    fill_slab_stats_automove(a->sam_before);

    return (void *)a;
}",62,,41,2,,void
80827,BLOCK,-1,,<empty>,9,,46,2,,void
80838,BLOCK,1,,<empty>,,,,1,,void
80884,BLOCK,-1,,"{
        if (a->window_data)
            free(a->window_data);
        free(a);
        return NULL;
    }",33,,54,2,,void
80889,BLOCK,-1,,<empty>,13,,56,2,,void
80914,BLOCK,-1,,"{
    slab_automove *a = (slab_automove *)arg;
    free(a->window_data);
    free(a);
}",45,,68,2,,void
80933,BLOCK,-1,,"{
    for (int x = 0; x < size; x++) {
        struct window_data *d = &wd[x];
        w->age += d->age;
        w->dirty += d->dirty;
        w->evicted += d->evicted;
        w->excess_free += d->excess_free;
        w->relaxed += d->relaxed;
    }
}",24,,75,4,,void
80935,BLOCK,-1,,<empty>,5,,76,1,,void
80945,BLOCK,4,,"{
        struct window_data *d = &wd[x];
        w->age += d->age;
        w->dirty += d->dirty;
        w->evicted += d->evicted;
        w->excess_free += d->excess_free;
        w->relaxed += d->relaxed;
    }",36,,76,4,,void
80992,BLOCK,-1,,"{
    bool mem_limit_reached;
    unsigned int free = a->global_pool_watermark;
    unsigned int count = global_page_pool_size(&mem_limit_reached);
    if (!mem_limit_reached)
        return 0;
    if (count < free) {
        a->pool_filled_once = true;
        return 1;
    } else {
        a->pool_filled_once = true;
    }
    return 0;
}",48,,86,2,,void
81009,BLOCK,-1,,<empty>,9,,91,2,,void
81016,BLOCK,-1,,"{
        a->pool_filled_once = true;
        return 1;
    }",23,,92,2,,void
81025,BLOCK,-1,,"{
        a->pool_filled_once = true;
    }",12,,95,1,,void
81037,BLOCK,-1,,"{
    unsigned int total_pages = 0;

    // FIXME: is there a cached counter for total pages alloced?
    // technically we only really need to do this once as the pages are
    // prefilled and ratio isn't a runtime change.
    for (int n = 1; n < MAX_NUMBER_OF_SLAB_CLASSES; n++) {
        slab_stats_automove *sam = &a->sam_after[n];
        total_pages += sam->total_pages;
    }
    // always update what remains in the global page pool
    total_pages += a->sam_after[0].total_pages;
    a->global_pool_watermark = total_pages * a->free_ratio;
    if (a->global_pool_watermark < 2)
        a->global_pool_watermark = 2;
    settings.ext_global_pool_min = a->global_pool_watermark;
}",40,,110,2,,void
81043,BLOCK,-1,,<empty>,5,,116,1,,void
81051,BLOCK,1,,<empty>,,,,1,,void
81057,BLOCK,4,,"{
        slab_stats_automove *sam = &a->sam_after[n];
        total_pages += sam->total_pages;
    }",58,,116,4,,void
81096,BLOCK,-1,,<empty>,9,,124,2,,void
81114,BLOCK,-1,,"{
    int w_offset = class * a->window_size;
    return &a->window_data[w_offset + (a->window_cur % a->window_size)];
}",73,,128,3,,void
81144,BLOCK,-1,,"{
    slab_automove *a = (slab_automove *)arg;
    int n;
    struct window_data w_sum;
    int oldest = -1;
    uint64_t oldest_age = 0;
    bool too_free = false;
    *src = -1;
    *dst = -1;

    int global_low = global_pool_check(a);
    // fill after structs
    fill_item_stats_automove(a->iam_after);
    fill_slab_stats_automove(a->sam_after);
    a->window_cur++;

    memcheck(a);

    // iterate slabs
    for (n = POWER_SMALLEST; n < MAX_NUMBER_OF_SLAB_CLASSES; n++) {
        bool small_slab = a->sam_before[n].chunk_size < a->item_size
            ? true : false;
        struct window_data *wd = get_window_data(a, n);
        int w_offset = n * a->window_size;
        memset(wd, 0, sizeof(struct window_data));
        unsigned int free_target = a->sam_after[n].chunks_per_page * MIN_PAGES_FREE;

        // if page delta, oom, or evicted delta, mark window dirty
        // classes marked dirty cannot donate memory back to global pool.
        if (a->iam_after[n].evicted - a->...",64,,133,4,,void
81196,BLOCK,-1,,<empty>,5,,152,1,,void
81200,BLOCK,1,,<empty>,,,,1,,void
81205,BLOCK,1,,<empty>,,,,1,,void
81211,BLOCK,4,,"{
        bool small_slab = a->sam_before[n].chunk_size < a->item_size
            ? true : false;
        struct window_data *wd = get_window_data(a, n);
        int w_offset = n * a->window_size;
        memset(wd, 0, sizeof(struct window_data));
        unsigned int free_target = a->sam_after[n].chunks_per_page * MIN_PAGES_FREE;

        // if page delta, oom, or evicted delta, mark window dirty
        // classes marked dirty cannot donate memory back to global pool.
        if (a->iam_after[n].evicted - a->iam_before[n].evicted > 0 ||
            a->iam_after[n].outofmemory - a->iam_before[n].outofmemory > 0) {
            wd->evicted = 1;
            wd->dirty = 1;
        }
        if (a->sam_after[n].total_pages - a->sam_before[n].total_pages > 0) {
            wd->dirty = 1;
        }
        // double the free requirements means we may have memory we can
        // reclaim to global, if it stays this way for the whole window.
        if (a->sam_after[n].free_chunks > (free...",67,,152,4,,void
81260,BLOCK,1,,<empty>,,,,1,,void
81298,BLOCK,-1,,"{
            wd->evicted = 1;
            wd->dirty = 1;
        }",77,,163,2,,void
81327,BLOCK,-1,,"{
            wd->dirty = 1;
        }",77,,167,2,,void
81345,BLOCK,-1,,"{
            wd->excess_free = 1;
        }",62,,172,2,,void
81409,BLOCK,1,,<empty>,,,,1,,void
81416,BLOCK,-1,,"{
            if (small_slab) {
                *src = n;
                *dst = 0;
                too_free = true;
            } else if (!small_slab && w_sum.excess_free >= a->window_size) {
                // If large slab and free chunks haven't decreased for a full
                // window, reclaim pages.
                *src = n;
                *dst = 0;
                too_free = true;
            }
        }",38,,190,2,,void
81419,BLOCK,-1,,"{
                *src = n;
                *dst = 0;
                too_free = true;
            }",29,,191,2,,void
81432,BLOCK,-1,,<empty>,20,,195,1,,void
81444,BLOCK,-1,,"{
                // If large slab and free chunks haven't decreased for a full
                // window, reclaim pages.
                *src = n;
                *dst = 0;
                too_free = true;
            }",76,,195,2,,void
81459,BLOCK,-1,,"{
            // if oldest and have enough pages, is oldest
            if (age > oldest_age
                    && a->sam_after[n].total_pages > MIN_PAGES_FOR_SOURCE) {
                oldest = n;
                oldest_age = age;
            }

        }",26,,204,2,,void
81474,BLOCK,1,,<empty>,,,,1,,void
81476,BLOCK,-1,,"{
                oldest = n;
                oldest_age = age;
            }",76,,207,2,,void
81494,BLOCK,1,,<empty>,,,,1,,void
81509,BLOCK,1,,<empty>,,,,1,,void
81521,BLOCK,-1,,<empty>,9,,221,2,,void
81533,BLOCK,-1,,"{
        *src = oldest;
        *dst = 0;
    }",50,,223,2,,void
81549,BLOCK,-1,,<empty>,1,,1,1,,ANY
81552,BLOCK,-1,,<empty>,,,,2,,<empty>
81557,BLOCK,-1,,<empty>,,,,2,,<empty>
81564,BLOCK,-1,,<empty>,,,,4,,<empty>
81601,BLOCK,-1,,<empty>,1,,1,1,,ANY
81614,BLOCK,1,,<empty>,,,,1,,void
81653,BLOCK,-1,,<empty>,,,,2,,<empty>
81658,BLOCK,-1,,<empty>,,,,2,,<empty>
81663,BLOCK,-1,,<empty>,,,,2,,<empty>
81670,BLOCK,-1,,<empty>,,,,4,,<empty>
81675,BLOCK,-1,,<empty>,,,,2,,<empty>
81680,BLOCK,-1,,"{
    int res = POWER_SMALLEST;

    if (size == 0 || size > settings.item_size_max)
        return 0;
    while (size > slabclass[res].size)
        if (res++ == power_largest)     /* won't fit in the biggest slab */
            return power_largest;
    return res;
}",45,,90,2,,void
81685,BLOCK,1,,<empty>,,,,1,,void
81697,BLOCK,-1,,<empty>,9,,94,2,,void
81713,BLOCK,-1,,<empty>,13,,97,2,,void
81722,BLOCK,-1,,"{
    return slabclass[clsid].size;
}",42,,101,2,,void
81733,BLOCK,-1,,"{
    void *ptr = NULL;
#if defined(__linux__) && defined(MADV_HUGEPAGE)
    size_t pagesize = 0;
    FILE *fp;
    int ret;

    /* Get the size of huge pages */
    fp = fopen(""/proc/meminfo"", ""r"");
    if (fp != NULL) {
        char buf[64];

        while ((fgets(buf, sizeof(buf), fp)))
            if (!strncmp(buf, ""Hugepagesize:"", 13)) {
                ret = sscanf(buf + 13, ""%zu\n"", &pagesize);

                /* meminfo huge page size is in KiBs */
                pagesize <<= 10;
            }
        fclose(fp);
    }

    if (!pagesize) {
        fprintf(stderr, ""Failed to get supported huge page size\n"");
        return NULL;
    }

    if (settings.verbose > 1)
        fprintf(stderr, ""huge page size: %zu\n"", pagesize);

    /* This works because glibc simply uses mmap when the alignment is
     * above a certain limit. */
    ret = posix_memalign(&ptr, pagesize, limit);
    if (ret != 0) {
        fprintf(stderr, ""Failed to get aligned memory chunk: %d\n"", ret);
    ...",1,,109,2,,void
81749,BLOCK,-1,,"{
    slabclass_t *p;
    item *it = (item *)chunk;
    int id = ITEM_clsid(it);

    // memory isn't used yet. shunt to global pool.
    // (which must be 0)
    if (id == 0) {
        //assert(border == 0);
        p = &slabclass[0];
        grow_slab_list(0);
        p->slab_list[p->slabs++] = (char*)chunk;
        return -1;
    }
    p = &slabclass[id];

    // if we're on a page border, add the slab to slab class
    if (border == 0) {
        grow_slab_list(id);
        p->slab_list[p->slabs++] = chunk;
    }

    // increase free count if ITEM_SLABBED
    if (it->it_flags == ITEM_SLABBED) {
        // if ITEM_SLABBED re-stack on freelist.
        // don't have to run pointer fixups.
        it->prev = 0;
        it->next = p->slots;
        if (it->next) it->next->prev = it;
        p->slots = it;

        p->sl_curr++;
        //fprintf(stderr, ""replacing into freelist\n"");
    }

    return p->size;
}",57,,166,3,,void
81762,BLOCK,1,,<empty>,,,,3,,void
81775,BLOCK,-1,,"{
        //assert(border == 0);
        p = &slabclass[0];
        grow_slab_list(0);
        p->slab_list[p->slabs++] = (char*)chunk;
        return -1;
    }",18,,173,2,,void
81809,BLOCK,-1,,"{
        grow_slab_list(id);
        p->slab_list[p->slabs++] = chunk;
    }",22,,183,2,,void
81828,BLOCK,1,,<empty>,,,,1,,void
81830,BLOCK,-1,,"{
        // if ITEM_SLABBED re-stack on freelist.
        // don't have to run pointer fixups.
        it->prev = 0;
        it->next = p->slots;
        if (it->next) it->next->prev = it;
        p->slots = it;

        p->sl_curr++;
        //fprintf(stderr, ""replacing into freelist\n"");
    }",39,,189,2,,void
81847,BLOCK,-1,,<empty>,23,,194,2,,void
81877,BLOCK,-1,,"{
    int i = POWER_SMALLEST - 1;
    unsigned int size = sizeof(item) + settings.chunk_size;

    /* Some platforms use runtime transparent hugepages. If for any reason
     * the initial allocation fails, the required settings do not persist
     * for remaining allocations. As such it makes little sense to do slab
     * preallocation. */
    bool __attribute__ ((unused)) do_slab_prealloc = false;

    mem_limit = limit;

    if (prealloc && mem_base_external == NULL) {
        mem_base = alloc_large_chunk(mem_limit);
        if (mem_base) {
            do_slab_prealloc = true;
            mem_current = mem_base;
            mem_avail = mem_limit;
        } else {
            fprintf(stderr, ""Warning: Failed to allocate requested memory in""
                    "" one large chunk.\nWill allocate in smaller chunks\n"");
        }
    } else if (prealloc && mem_base_external != NULL) {
        // Can't (yet) mix hugepages with mmap allocations, so separate the
        // logic from ab...",148,,208,7,,void
81883,BLOCK,1,,<empty>,,,,1,,void
81908,BLOCK,-1,,"{
        mem_base = alloc_large_chunk(mem_limit);
        if (mem_base) {
            do_slab_prealloc = true;
            mem_current = mem_base;
            mem_avail = mem_limit;
        } else {
            fprintf(stderr, ""Warning: Failed to allocate requested memory in""
                    "" one large chunk.\nWill allocate in smaller chunks\n"");
        }
    }",48,,220,2,,void
81915,BLOCK,-1,,"{
            do_slab_prealloc = true;
            mem_current = mem_base;
            mem_avail = mem_limit;
        }",23,,222,2,,void
81926,BLOCK,-1,,"{
            fprintf(stderr, ""Warning: Failed to allocate requested memory in""
                    "" one large chunk.\nWill allocate in smaller chunks\n"");
        }",16,,226,1,,void
81931,BLOCK,-1,,<empty>,12,,230,1,,void
81938,BLOCK,-1,,"{
        // Can't (yet) mix hugepages with mmap allocations, so separate the
        // logic from above. Reusable memory also force-preallocates memory
        // pages into the global pool, which requires turning mem_* variables.
        do_slab_prealloc = true;
        mem_base = mem_base_external;
        // _current shouldn't be used in this case, but we set it to where it
        // should be anyway.
        if (reuse_mem) {
            mem_current = ((char*)mem_base) + mem_limit;
            mem_avail = 0;
        } else {
            mem_current = mem_base;
            mem_avail = mem_limit;
        }
    }",55,,230,2,,void
81947,BLOCK,-1,,"{
            mem_current = ((char*)mem_base) + mem_limit;
            mem_avail = 0;
        }",24,,238,2,,void
81959,BLOCK,-1,,"{
            mem_current = mem_base;
            mem_avail = mem_limit;
        }",16,,241,1,,void
81977,BLOCK,1,,<empty>,,,,1,,void
81982,BLOCK,-1,,"{
        if (slab_sizes != NULL) {
            if (slab_sizes[i-1] == 0)
                break;
            size = slab_sizes[i-1];
        } else if (size >= settings.slab_chunk_size_max / factor) {
            break;
        }
        /* Make sure items are always n-byte aligned */
        if (size % CHUNK_ALIGN_BYTES)
            size += CHUNK_ALIGN_BYTES - (size % CHUNK_ALIGN_BYTES);

        slabclass[i].size = size;
        slabclass[i].perslab = settings.slab_page_size / slabclass[i].size;
        if (slab_sizes == NULL)
            size *= factor;
        if (settings.verbose > 1) {
            fprintf(stderr, ""slab class %3d: chunk size %9u perslab %7u\n"",
                    i, slabclass[i].size, slabclass[i].perslab);
        }
    }",48,,249,2,,void
81987,BLOCK,-1,,"{
            if (slab_sizes[i-1] == 0)
                break;
            size = slab_sizes[i-1];
        }",33,,250,2,,void
81996,BLOCK,-1,,<empty>,17,,252,2,,void
82006,BLOCK,-1,,<empty>,16,,254,1,,void
82015,BLOCK,-1,,"{
            break;
        }",67,,254,2,,void
82021,BLOCK,1,,<empty>,,,,1,,void
82023,BLOCK,-1,,<empty>,13,,259,2,,void
82028,BLOCK,1,,<empty>,,,,1,,void
82033,BLOCK,1,,<empty>,,,,1,,void
82061,BLOCK,-1,,<empty>,13,,264,2,,void
82071,BLOCK,-1,,"{
            fprintf(stderr, ""slab class %3d: chunk size %9u perslab %7u\n"",
                    i, slabclass[i].size, slabclass[i].perslab);
        }",35,,265,2,,void
82117,BLOCK,-1,,"{
        fprintf(stderr, ""slab class %3d: chunk size %9u perslab %7u\n"",
                i, slabclass[i].size, slabclass[i].perslab);
    }",31,,274,2,,void
82132,BLOCK,15,,"{
        char *t_initial_malloc = getenv(""T_MEMD_INITIAL_MALLOC"");
        if (t_initial_malloc) {
            int64_t env_malloced;
            if (safe_strtoll((const char *)t_initial_malloc, &env_malloced)) {
                mem_malloced = (size_t)env_malloced;
            }
        }

    }",5,,280,15,,void
82140,BLOCK,-1,,"{
            int64_t env_malloced;
            if (safe_strtoll((const char *)t_initial_malloc, &env_malloced)) {
                mem_malloced = (size_t)env_malloced;
            }
        }",31,,282,2,,void
82149,BLOCK,-1,,"{
                mem_malloced = (size_t)env_malloced;
            }",78,,284,2,,void
82157,BLOCK,-1,,"{
        if (!reuse_mem) {
            slabs_preallocate(power_largest);
        }
    }",27,,291,2,,void
82161,BLOCK,-1,,"{
            slabs_preallocate(power_largest);
        }",25,,292,2,,void
82168,BLOCK,-1,,"{
    void *ptr;
    slabclass_t *p = &slabclass[0];
    int len = settings.slab_page_size;

    while (mem_malloced < mem_limit
            && (ptr = memory_allocate(len)) != NULL) {
        grow_slab_list(0);
        // Ensure the front header is zero'd to avoid confusing restart code.
        // It's probably good enough to cast it and just zero slabs_clsid, but
        // this is extra paranoid.
        memset(ptr, 0, sizeof(item));
        p->slab_list[p->slabs++] = ptr;
    }
    mem_limit_reached = true;
}",33,,298,2,,void
82194,BLOCK,-1,,"{
        grow_slab_list(0);
        // Ensure the front header is zero'd to avoid confusing restart code.
        // It's probably good enough to cast it and just zero slabs_clsid, but
        // this is extra paranoid.
        memset(ptr, 0, sizeof(item));
        p->slab_list[p->slabs++] = ptr;
    }",54,,304,2,,void
82219,BLOCK,-1,,"{
    int i;
    unsigned int prealloc = 0;

    /* pre-allocate a 1MB slab in every size class so people don't get
       confused by non-intuitive ""SERVER_ERROR out of memory""
       messages.  this is the most common question on the mailing
       list.  if you really don't want this, you can rebuild without
       these three lines.  */

    for (i = POWER_SMALLEST; i < MAX_NUMBER_OF_SLAB_CLASSES; i++) {
        if (++prealloc > maxslabs)
            break;
        if (do_slabs_newslab(i) == 0) {
            fprintf(stderr, ""Error while preallocating slab memory!\n""
                ""If using -L or other prealloc options, max memory must be ""
                ""at least %d megabytes.\n"", power_largest);
            exit(1);
        }
    }
}",61,,315,2,,void
82226,BLOCK,-1,,<empty>,5,,325,1,,void
82230,BLOCK,1,,<empty>,,,,1,,void
82235,BLOCK,1,,<empty>,,,,1,,void
82241,BLOCK,4,,"{
        if (++prealloc > maxslabs)
            break;
        if (do_slabs_newslab(i) == 0) {
            fprintf(stderr, ""Error while preallocating slab memory!\n""
                ""If using -L or other prealloc options, max memory must be ""
                ""at least %d megabytes.\n"", power_largest);
            exit(1);
        }
    }",67,,325,4,,void
82247,BLOCK,-1,,<empty>,13,,327,2,,void
82254,BLOCK,-1,,"{
            fprintf(stderr, ""Error while preallocating slab memory!\n""
                ""If using -L or other prealloc options, max memory must be ""
                ""at least %d megabytes.\n"", power_largest);
            exit(1);
        }",39,,328,2,,void
82265,BLOCK,-1,,"{
    slabclass_t *p = &slabclass[id];
    if (p->slabs == p->list_size) {
        size_t new_size =  (p->list_size != 0) ? p->list_size * 2 : 16;
        void *new_list = realloc(p->slab_list, new_size * sizeof(void *));
        if (new_list == 0) return 0;
        p->list_size = new_size;
        p->slab_list = new_list;
    }
    return 1;
}",51,,337,2,,void
82281,BLOCK,-1,,"{
        size_t new_size =  (p->list_size != 0) ? p->list_size * 2 : 16;
        void *new_list = realloc(p->slab_list, new_size * sizeof(void *));
        if (new_list == 0) return 0;
        p->list_size = new_size;
        p->slab_list = new_list;
    }",35,,339,2,,void
82312,BLOCK,-1,,<empty>,28,,342,2,,void
82332,BLOCK,-1,,"{
    slabclass_t *p = &slabclass[id];
    int x;
    for (x = 0; x < p->perslab; x++) {
        do_slabs_free(ptr, 0, id);
        ptr += p->size;
    }
}",77,,349,3,,void
82342,BLOCK,-1,,<empty>,5,,352,1,,void
82353,BLOCK,4,,"{
        do_slabs_free(ptr, 0, id);
        ptr += p->size;
    }",38,,352,4,,void
82367,BLOCK,-1,,"{
    slabclass_t *p = &slabclass[SLAB_GLOBAL_PAGE_POOL];
    if (p->slabs < 1) {
        return NULL;
    }
    char *ret = p->slab_list[p->slabs - 1];
    p->slabs--;
    return ret;
}",46,,359,2,,void
82375,BLOCK,1,,<empty>,,,,1,,void
82383,BLOCK,-1,,"{
        return NULL;
    }",23,,361,2,,void
82408,BLOCK,-1,,"{
    slabclass_t *p = &slabclass[id];
    slabclass_t *g = &slabclass[SLAB_GLOBAL_PAGE_POOL];
    int len = (settings.slab_reassign || settings.slab_chunk_size_max != settings.slab_page_size)
        ? settings.slab_page_size
        : p->size * p->perslab;
    char *ptr;

    if ((mem_limit && mem_malloced + len > mem_limit && p->slabs > 0
         && g->slabs == 0)) {
        mem_limit_reached = true;
        MEMCACHED_SLABS_SLABCLASS_ALLOCATE_FAILED(id);
        return 0;
    }

    if ((grow_slab_list(id) == 0) ||
        (((ptr = get_page_from_global_pool()) == NULL) &&
        ((ptr = memory_allocate((size_t)len)) == 0))) {

        MEMCACHED_SLABS_SLABCLASS_ALLOCATE_FAILED(id);
        return 0;
    }

    // Always wipe the memory at this stage: in restart mode the mmap memory
    // could be unused, yet still full of data. Better for usability if we're
    // wiping memory as it's being pulled out of the global pool instead of
    // blocking startup all at once.
    memse...",52,,369,2,,void
82423,BLOCK,1,,<empty>,,,,1,,void
82471,BLOCK,-1,,"{
        mem_limit_reached = true;
        MEMCACHED_SLABS_SLABCLASS_ALLOCATE_FAILED(id);
        return 0;
    }",29,,378,2,,void
82497,BLOCK,-1,,"{

        MEMCACHED_SLABS_SLABCLASS_ALLOCATE_FAILED(id);
        return 0;
    }",55,,386,2,,void
82527,BLOCK,-1,,"{
    slabclass_t *p;
    void *ret = NULL;
    item *it = NULL;

    if (id < POWER_SMALLEST || id > power_largest) {
        MEMCACHED_SLABS_ALLOCATE_FAILED(size, 0);
        return NULL;
    }
    p = &slabclass[id];
    assert(p->sl_curr == 0 || (((item *)p->slots)->it_flags & ITEM_SLABBED));

    assert(size <= p->size);
    /* fail unless we have space at the end of a recently allocated page,
       we have something on our freelist, or we could allocate a new page */
    if (p->sl_curr == 0 && flags != SLABS_ALLOC_NO_NEWPAGE) {
        do_slabs_newslab(id);
    }

    if (p->sl_curr != 0) {
        /* return off our freelist */
        it = (item *)p->slots;
        p->slots = it->next;
        if (it->next) it->next->prev = 0;
        /* Kill flag and initialize refcount here for lock safety in slab
         * mover's freeness detection. */
        it->it_flags &= ~ITEM_SLABBED;
        it->refcount = 1;
        p->sl_curr--;
        ret = (void *)it;
    } else {
        re...",29,,407,4,,void
82542,BLOCK,1,,<empty>,,,,1,,void
82547,BLOCK,-1,,"{
        MEMCACHED_SLABS_ALLOCATE_FAILED(size, 0);
        return NULL;
    }",52,,412,2,,void
82572,BLOCK,1,,<empty>,,,,1,,void
82590,BLOCK,1,,<empty>,,,,1,,void
82592,BLOCK,-1,,"{
        do_slabs_newslab(id);
    }",61,,422,2,,void
82601,BLOCK,-1,,"{
        /* return off our freelist */
        it = (item *)p->slots;
        p->slots = it->next;
        if (it->next) it->next->prev = 0;
        /* Kill flag and initialize refcount here for lock safety in slab
         * mover's freeness detection. */
        it->it_flags &= ~ITEM_SLABBED;
        it->refcount = 1;
        p->sl_curr--;
        ret = (void *)it;
    }",26,,426,2,,void
82620,BLOCK,-1,,<empty>,23,,430,2,,void
82634,BLOCK,1,,<empty>,,,,1,,void
82651,BLOCK,-1,,"{
        ret = NULL;
    }",12,,437,1,,void
82657,BLOCK,-1,,"{
        MEMCACHED_SLABS_ALLOCATE(size, id, p->size, ret);
    }",14,,441,2,,void
82659,BLOCK,-1,,"{
        MEMCACHED_SLABS_ALLOCATE_FAILED(size, id);
    }",12,,443,1,,void
82667,BLOCK,-1,,"{
    item_chunk *chunk = (item_chunk *) ITEM_schunk(it);
    slabclass_t *p;

    it->it_flags = ITEM_SLABBED;
    // FIXME: refresh on how this works?
    //it->slabs_clsid = 0;
    it->prev = 0;
    // header object's original classid is stored in chunk.
    p = &slabclass[chunk->orig_clsid];
    // original class id needs to be set on free memory.
    it->slabs_clsid = chunk->orig_clsid;
    if (chunk->next) {
        chunk = chunk->next;
        chunk->prev = 0;
    } else {
        // header with no attached chunk
        chunk = NULL;
    }

    // return the header object.
    // TODO: This is in three places, here and in do_slabs_free().
    it->prev = 0;
    it->next = p->slots;
    if (it->next) it->next->prev = it;
    p->slots = it;
    p->sl_curr++;

    item_chunk *next_chunk;
    while (chunk) {
        assert(chunk->it_flags == ITEM_CHUNK);
        chunk->it_flags = ITEM_SLABBED;
        p = &slabclass[chunk->slabs_clsid];
        next_chunk = chunk->next;

        ...",64,,450,3,,void
82675,BLOCK,1,,<empty>,,,,2,,void
82714,BLOCK,1,,<empty>,,,,1,,void
82740,BLOCK,-1,,"{
        chunk = chunk->next;
        chunk->prev = 0;
    }",22,,462,2,,void
82752,BLOCK,-1,,"{
        // header with no attached chunk
        chunk = NULL;
    }",12,,465,1,,void
82772,BLOCK,-1,,<empty>,19,,474,2,,void
82792,BLOCK,-1,,"{
        assert(chunk->it_flags == ITEM_CHUNK);
        chunk->it_flags = ITEM_SLABBED;
        p = &slabclass[chunk->slabs_clsid];
        next_chunk = chunk->next;

        chunk->prev = 0;
        chunk->next = p->slots;
        if (chunk->next) chunk->next->prev = chunk;
        p->slots = chunk;
        p->sl_curr++;

        chunk = next_chunk;
    }",19,,479,2,,void
82799,BLOCK,1,,<empty>,,,,1,,void
82806,BLOCK,1,,<empty>,,,,1,,void
82837,BLOCK,-1,,<empty>,26,,487,2,,void
82864,BLOCK,-1,,"{
    slabclass_t *p;
    item *it;

    assert(id >= POWER_SMALLEST && id <= power_largest);
    if (id < POWER_SMALLEST || id > power_largest)
        return;

    MEMCACHED_SLABS_FREE(size, id, ptr);
    p = &slabclass[id];

    it = (item *)ptr;
    if ((it->it_flags & ITEM_CHUNKED) == 0) {
        it->it_flags = ITEM_SLABBED;
        it->slabs_clsid = id;
        it->prev = 0;
        it->next = p->slots;
        if (it->next) it->next->prev = it;
        p->slots = it;

        p->sl_curr++;
    } else {
        do_slabs_free_chunked(it, size);
    }
    return;
}",74,,498,4,,void
82872,BLOCK,1,,<empty>,,,,1,,void
82882,BLOCK,1,,<empty>,,,,1,,void
82887,BLOCK,-1,,<empty>,9,,504,2,,void
82907,BLOCK,1,,<empty>,,,,1,,void
82910,BLOCK,-1,,"{
        it->it_flags = ITEM_SLABBED;
        it->slabs_clsid = id;
        it->prev = 0;
        it->next = p->slots;
        if (it->next) it->next->prev = it;
        p->slots = it;

        p->sl_curr++;
    }",45,,510,2,,void
82916,BLOCK,1,,<empty>,,,,1,,void
82939,BLOCK,-1,,<empty>,23,,515,2,,void
82957,BLOCK,-1,,"{
        do_slabs_free_chunked(it, size);
    }",12,,519,1,,void
82966,BLOCK,-1,,"{
    int n;
    pthread_mutex_lock(&slabs_lock);
    for (n = 0; n < MAX_NUMBER_OF_SLAB_CLASSES; n++) {
        slabclass_t *p = &slabclass[n];
        slab_stats_automove *cur = &am[n];
        cur->chunks_per_page = p->perslab;
        cur->free_chunks = p->sl_curr;
        cur->total_pages = p->slabs;
        cur->chunk_size = p->size;
    }
    pthread_mutex_unlock(&slabs_lock);
}",56,,528,2,,void
82972,BLOCK,-1,,<empty>,5,,531,1,,void
82979,BLOCK,1,,<empty>,,,,1,,void
82985,BLOCK,4,,"{
        slabclass_t *p = &slabclass[n];
        slab_stats_automove *cur = &am[n];
        cur->chunks_per_page = p->perslab;
        cur->free_chunks = p->sl_curr;
        cur->total_pages = p->slabs;
        cur->chunk_size = p->size;
    }",54,,531,4,,void
83035,BLOCK,-1,,"{
    unsigned int ret = 0;
    pthread_mutex_lock(&slabs_lock);
    if (mem_flag != NULL)
        *mem_flag = mem_malloced >= mem_limit ? true : false;
    ret = slabclass[SLAB_GLOBAL_PAGE_POOL].slabs;
    pthread_mutex_unlock(&slabs_lock);
    return ret;
}",52,,545,2,,void
83047,BLOCK,-1,,<empty>,9,,549,2,,void
83063,BLOCK,1,,<empty>,,,,1,,void
83076,BLOCK,-1,,"{
    int i, total;
    /* Get the per-thread stats which contain some interesting aggregates */
    struct thread_stats thread_stats;
    threadlocal_stats_aggregate(&thread_stats);

    total = 0;
    for(i = POWER_SMALLEST; i <= power_largest; i++) {
        slabclass_t *p = &slabclass[i];
        if (p->slabs != 0) {
            uint32_t perslab, slabs;
            slabs = p->slabs;
            perslab = p->perslab;

            char key_str[STAT_KEY_LEN];
            char val_str[STAT_VAL_LEN];
            int klen = 0, vlen = 0;

            APPEND_NUM_STAT(i, ""chunk_size"", ""%u"", p->size);
            APPEND_NUM_STAT(i, ""chunks_per_page"", ""%u"", perslab);
            APPEND_NUM_STAT(i, ""total_pages"", ""%u"", slabs);
            APPEND_NUM_STAT(i, ""total_chunks"", ""%u"", slabs * perslab);
            APPEND_NUM_STAT(i, ""used_chunks"", ""%u"",
                            slabs*perslab - p->sl_curr);
            APPEND_NUM_STAT(i, ""free_chunks"", ""%u"", p->sl_curr);
            /* Stat is ...",57,,556,3,,void
83087,BLOCK,-1,,<empty>,5,,563,1,,void
83091,BLOCK,1,,<empty>,,,,1,,void
83098,BLOCK,4,,"{
        slabclass_t *p = &slabclass[i];
        if (p->slabs != 0) {
            uint32_t perslab, slabs;
            slabs = p->slabs;
            perslab = p->perslab;

            char key_str[STAT_KEY_LEN];
            char val_str[STAT_VAL_LEN];
            int klen = 0, vlen = 0;

            APPEND_NUM_STAT(i, ""chunk_size"", ""%u"", p->size);
            APPEND_NUM_STAT(i, ""chunks_per_page"", ""%u"", perslab);
            APPEND_NUM_STAT(i, ""total_pages"", ""%u"", slabs);
            APPEND_NUM_STAT(i, ""total_chunks"", ""%u"", slabs * perslab);
            APPEND_NUM_STAT(i, ""used_chunks"", ""%u"",
                            slabs*perslab - p->sl_curr);
            APPEND_NUM_STAT(i, ""free_chunks"", ""%u"", p->sl_curr);
            /* Stat is dead, but displaying zero instead of removing it. */
            APPEND_NUM_STAT(i, ""free_chunks_end"", ""%u"", 0);
            APPEND_NUM_STAT(i, ""get_hits"", ""%llu"",
                    (unsigned long long)thread_stats.slab_stats[i].get_hits);
          ...",54,,563,4,,void
83112,BLOCK,-1,,"{
            uint32_t perslab, slabs;
            slabs = p->slabs;
            perslab = p->perslab;

            char key_str[STAT_KEY_LEN];
            char val_str[STAT_VAL_LEN];
            int klen = 0, vlen = 0;

            APPEND_NUM_STAT(i, ""chunk_size"", ""%u"", p->size);
            APPEND_NUM_STAT(i, ""chunks_per_page"", ""%u"", perslab);
            APPEND_NUM_STAT(i, ""total_pages"", ""%u"", slabs);
            APPEND_NUM_STAT(i, ""total_chunks"", ""%u"", slabs * perslab);
            APPEND_NUM_STAT(i, ""used_chunks"", ""%u"",
                            slabs*perslab - p->sl_curr);
            APPEND_NUM_STAT(i, ""free_chunks"", ""%u"", p->sl_curr);
            /* Stat is dead, but displaying zero instead of removing it. */
            APPEND_NUM_STAT(i, ""free_chunks_end"", ""%u"", 0);
            APPEND_NUM_STAT(i, ""get_hits"", ""%llu"",
                    (unsigned long long)thread_stats.slab_stats[i].get_hits);
            APPEND_NUM_STAT(i, ""cmd_set"", ""%llu"",
                    (unsigned...",28,,565,2,,void
83138,BLOCK,1,,<empty>,,,,6,,void
83165,BLOCK,1,,<empty>,,,,6,,void
83190,BLOCK,1,,<empty>,,,,6,,void
83215,BLOCK,1,,<empty>,,,,6,,void
83242,BLOCK,1,,<empty>,,,,6,,void
83273,BLOCK,1,,<empty>,,,,6,,void
83300,BLOCK,1,,<empty>,,,,6,,void
83325,BLOCK,1,,<empty>,,,,6,,void
83358,BLOCK,1,,<empty>,,,,6,,void
83391,BLOCK,1,,<empty>,,,,6,,void
83424,BLOCK,1,,<empty>,,,,6,,void
83457,BLOCK,1,,<empty>,,,,6,,void
83490,BLOCK,1,,<empty>,,,,6,,void
83523,BLOCK,1,,<empty>,,,,6,,void
83556,BLOCK,1,,<empty>,,,,6,,void
83592,BLOCK,1,,<empty>,,,,5,,void
83602,BLOCK,1,,<empty>,,,,4,,void
83621,BLOCK,-1,,"{
    void *ret;

    if (mem_base == NULL) {
        /* We are not using a preallocated large memory chunk */
        ret = malloc(size);
    } else {
        ret = mem_current;

        if (size > mem_avail) {
            return NULL;
        }

        /* mem_current pointer _must_ be aligned!!! */
        if (size % CHUNK_ALIGN_BYTES) {
            size += CHUNK_ALIGN_BYTES - (size % CHUNK_ALIGN_BYTES);
        }

        mem_current = ((char*)mem_current) + size;
        if (size < mem_avail) {
            mem_avail -= size;
        } else {
            mem_avail = 0;
        }
    }
    mem_malloced += size;

    return ret;
}",43,,610,2,,void
83627,BLOCK,-1,,"{
        /* We are not using a preallocated large memory chunk */
        ret = malloc(size);
    }",27,,613,2,,void
83633,BLOCK,-1,,"{
        ret = mem_current;

        if (size > mem_avail) {
            return NULL;
        }

        /* mem_current pointer _must_ be aligned!!! */
        if (size % CHUNK_ALIGN_BYTES) {
            size += CHUNK_ALIGN_BYTES - (size % CHUNK_ALIGN_BYTES);
        }

        mem_current = ((char*)mem_current) + size;
        if (size < mem_avail) {
            mem_avail -= size;
        } else {
            mem_avail = 0;
        }
    }",12,,616,1,,void
83641,BLOCK,-1,,"{
            return NULL;
        }",31,,619,2,,void
83648,BLOCK,1,,<empty>,,,,1,,void
83650,BLOCK,-1,,"{
            size += CHUNK_ALIGN_BYTES - (size % CHUNK_ALIGN_BYTES);
        }",39,,624,2,,void
83655,BLOCK,1,,<empty>,,,,1,,void
83660,BLOCK,1,,<empty>,,,,1,,void
83673,BLOCK,-1,,"{
            mem_avail -= size;
        }",31,,629,2,,void
83678,BLOCK,-1,,"{
            mem_avail = 0;
        }",16,,631,1,,void
83690,BLOCK,-1,,"{
    void *p = NULL;
    if (mem_base != NULL)
        return;

    if (!settings.slab_reassign)
        return;

    while (mem_malloced > mem_limit &&
            (p = get_page_from_global_pool()) != NULL) {
        free(p);
        mem_malloced -= settings.slab_page_size;
    }
}",30,,641,1,,void
83699,BLOCK,-1,,<empty>,9,,644,2,,void
83706,BLOCK,-1,,<empty>,9,,647,2,,void
83718,BLOCK,-1,,"{
        free(p);
        mem_malloced -= settings.slab_page_size;
    }",56,,650,2,,void
83732,BLOCK,-1,,"{
    void *ret;

    pthread_mutex_lock(&slabs_lock);
    ret = do_slabs_alloc(size, id, flags);
    pthread_mutex_unlock(&slabs_lock);
    return ret;
}",29,,657,4,,void
83754,BLOCK,-1,,"{
    pthread_mutex_lock(&slabs_lock);
    do_slabs_free(ptr, size, id);
    pthread_mutex_unlock(&slabs_lock);
}",58,,666,4,,void
83770,BLOCK,-1,,"{
    pthread_mutex_lock(&slabs_lock);
    do_slabs_stats(add_stats, c);
    pthread_mutex_unlock(&slabs_lock);
}",47,,672,3,,void
83784,BLOCK,-1,,"{
    /* Cannot adjust memory limit at runtime if prealloc'ed */
    if (mem_base != NULL)
        return false;
    settings.maxbytes = new_mem_limit;
    mem_limit = new_mem_limit;
    mem_limit_reached = false; /* Will reset on next alloc */
    memory_release(); /* free what might already be in the global pool */
    return true;
}",61,,678,2,,void
83789,BLOCK,-1,,<empty>,9,,681,2,,void
83810,BLOCK,-1,,"{
    bool ret;
    pthread_mutex_lock(&slabs_lock);
    ret = do_slabs_adjust_mem_limit(new_mem_limit);
    pthread_mutex_unlock(&slabs_lock);
    return ret;
}",51,,689,2,,void
83830,BLOCK,-1,,"{
    unsigned int ret;
    slabclass_t *p;

    pthread_mutex_lock(&slabs_lock);
    p = &slabclass[id];
    ret = p->sl_curr;
    if (mem_flag != NULL)
        *mem_flag = mem_malloced >= mem_limit ? true : false;
    if (chunks_perslab != NULL)
        *chunks_perslab = p->perslab;
    pthread_mutex_unlock(&slabs_lock);
    return ret;
}",39,,698,4,,void
83851,BLOCK,-1,,<empty>,9,,706,2,,void
83865,BLOCK,-1,,<empty>,9,,708,2,,void
83881,BLOCK,-1,,"{
    pthread_mutex_lock(&slabs_lock);
}",24,,719,2,,void
83889,BLOCK,-1,,"{
    pthread_mutex_unlock(&slabs_lock);
}",26,,723,2,,void
83905,BLOCK,-1,,"{
    slabclass_t *s_cls;
    int no_go = 0;

    pthread_mutex_lock(&slabs_lock);

    if (slab_rebal.s_clsid < SLAB_GLOBAL_PAGE_POOL ||
        slab_rebal.s_clsid > power_largest  ||
        slab_rebal.d_clsid < SLAB_GLOBAL_PAGE_POOL ||
        slab_rebal.d_clsid > power_largest  ||
        slab_rebal.s_clsid == slab_rebal.d_clsid)
        no_go = -2;

    s_cls = &slabclass[slab_rebal.s_clsid];

    if (!grow_slab_list(slab_rebal.d_clsid)) {
        no_go = -1;
    }

    if (s_cls->slabs < 2)
        no_go = -3;

    if (no_go != 0) {
        pthread_mutex_unlock(&slabs_lock);
        return no_go; /* Should use a wrapper function... */
    }

    /* Always kill the first available slab page as it is most likely to
     * contain the oldest items
     */
    slab_rebal.slab_start = s_cls->slab_list[0];
    slab_rebal.slab_end   = (char *)slab_rebal.slab_start +
        (s_cls->size * s_cls->perslab);
    slab_rebal.slab_pos   = slab_rebal.slab_start;
    slab_rebal.done       = ...",39,,730,2,,void
83924,BLOCK,1,,<empty>,,,,1,,void
83936,BLOCK,1,,<empty>,,,,1,,void
83950,BLOCK,-1,,<empty>,9,,741,2,,void
83969,BLOCK,-1,,"{
        no_go = -1;
    }",46,,745,2,,void
83980,BLOCK,-1,,<empty>,9,,750,2,,void
83989,BLOCK,-1,,"{
        pthread_mutex_unlock(&slabs_lock);
        return no_go; /* Should use a wrapper function... */
    }",21,,752,2,,void
84039,BLOCK,1,,<empty>,,,,1,,void
84041,BLOCK,-1,,"{
        slab_rebal.done = 1;
    }",54,,766,2,,void
84068,BLOCK,-1,,"{
        fprintf(stderr, ""Started a slab rebalance\n"");
    }",31,,775,2,,void
84089,BLOCK,-1,,"{
    slabclass_t *s_cls;
    s_cls = &slabclass[slab_rebal.s_clsid];
    int x;
    item *new_it = NULL;

    for (x = 0; x < s_cls->perslab; x++) {
        new_it = do_slabs_alloc(size, id, SLABS_ALLOC_NO_NEWPAGE);
        /* check that memory isn't within the range to clear */
        if (new_it == NULL) {
            break;
        }
        if ((void *)new_it >= slab_rebal.slab_start
            && (void *)new_it < slab_rebal.slab_end) {
            /* Pulled something we intend to free. Mark it as freed since
             * we've already done the work of unlinking it from the freelist.
             */
            new_it->refcount = 0;
            new_it->it_flags = ITEM_SLABBED|ITEM_FETCHED;
#ifdef DEBUG_SLAB_MOVER
            memcpy(ITEM_key(new_it), ""deadbeef"", 8);
#endif
            new_it = NULL;
            slab_rebal.inline_reclaim++;
        } else {
            break;
        }
    }
    return new_it;
}",71,,789,3,,void
84105,BLOCK,-1,,<empty>,5,,795,1,,void
84116,BLOCK,4,,"{
        new_it = do_slabs_alloc(size, id, SLABS_ALLOC_NO_NEWPAGE);
        /* check that memory isn't within the range to clear */
        if (new_it == NULL) {
            break;
        }
        if ((void *)new_it >= slab_rebal.slab_start
            && (void *)new_it < slab_rebal.slab_end) {
            /* Pulled something we intend to free. Mark it as freed since
             * we've already done the work of unlinking it from the freelist.
             */
            new_it->refcount = 0;
            new_it->it_flags = ITEM_SLABBED|ITEM_FETCHED;
#ifdef DEBUG_SLAB_MOVER
            memcpy(ITEM_key(new_it), ""deadbeef"", 8);
#endif
            new_it = NULL;
            slab_rebal.inline_reclaim++;
        } else {
            break;
        }
    }",42,,795,4,,void
84123,BLOCK,1,,<empty>,,,,1,,void
84129,BLOCK,-1,,"{
            break;
        }",29,,798,2,,void
84147,BLOCK,-1,,"{
            /* Pulled something we intend to free. Mark it as freed since
             * we've already done the work of unlinking it from the freelist.
             */
            new_it->refcount = 0;
            new_it->it_flags = ITEM_SLABBED|ITEM_FETCHED;
#ifdef DEBUG_SLAB_MOVER
            memcpy(ITEM_key(new_it), ""deadbeef"", 8);
#endif
            new_it = NULL;
            slab_rebal.inline_reclaim++;
        }",54,,802,2,,void
84159,BLOCK,1,,<empty>,,,,1,,void
84162,BLOCK,1,,<empty>,,,,1,,void
84172,BLOCK,-1,,"{
            break;
        }",16,,813,1,,void
84181,BLOCK,-1,,"{
    /* Ensure this was on the freelist and nothing else. */
    assert(it->it_flags == ITEM_SLABBED);
    if (s_cls->slots == it) {
        s_cls->slots = it->next;
    }
    if (it->next) it->next->prev = it->prev;
    if (it->prev) it->prev->next = it->next;
    s_cls->sl_curr--;
}",67,,822,3,,void
84188,BLOCK,1,,<empty>,,,,1,,void
84196,BLOCK,-1,,"{
        s_cls->slots = it->next;
    }",29,,825,2,,void
84208,BLOCK,-1,,<empty>,19,,828,2,,void
84222,BLOCK,-1,,<empty>,19,,829,2,,void
84245,BLOCK,-1,,<empty>,,,,1,,<empty>
84253,BLOCK,-1,,"{
    slabclass_t *s_cls;
    int was_busy = 0;
    int refcount = 0;
    uint32_t hv;
    void *hold_lock;
    enum move_status status = MOVE_PASS;

    s_cls = &slabclass[slab_rebal.s_clsid];
    // the offset to check if completed or not
    int offset = ((char*)slab_rebal.slab_pos-(char*)slab_rebal.slab_start)/(s_cls->size);

    // skip acquiring the slabs lock for items we've already fully processed.
    if (slab_rebal.completed[offset] == 0) {
        pthread_mutex_lock(&slabs_lock);
        hv = 0;
        hold_lock = NULL;
        item *it = slab_rebal.slab_pos;

        item_chunk *ch = NULL;
        status = MOVE_PASS;

        if (it->it_flags & ITEM_CHUNK) {
            /* This chunk is a chained part of a larger item. */
            ch = (item_chunk *) it;
            /* Instead, we use the head chunk to find the item and effectively
             * lock the entire structure. If a chunk has ITEM_CHUNK flag, its
             * head cannot be slabbed, so the normal routin...",38,,856,2,,void
84303,BLOCK,-1,,"{
        pthread_mutex_lock(&slabs_lock);
        hv = 0;
        hold_lock = NULL;
        item *it = slab_rebal.slab_pos;

        item_chunk *ch = NULL;
        status = MOVE_PASS;

        if (it->it_flags & ITEM_CHUNK) {
            /* This chunk is a chained part of a larger item. */
            ch = (item_chunk *) it;
            /* Instead, we use the head chunk to find the item and effectively
             * lock the entire structure. If a chunk has ITEM_CHUNK flag, its
             * head cannot be slabbed, so the normal routine is safe. */
            it = ch->head;
            assert(it->it_flags & ITEM_CHUNKED);
        }

        /* ITEM_FETCHED when ITEM_SLABBED is overloaded to mean we've cleared
         * the chunk for move. Only these two flags should exist.
         */
        if (it->it_flags != (ITEM_SLABBED|ITEM_FETCHED)) {
            /* ITEM_SLABBED can only be added/removed under the slabs_lock */
            if (it->it_flags & ITEM_SLABBED) {
            ...",44,,869,2,,void
84332,BLOCK,1,,<empty>,,,,1,,void
84334,BLOCK,-1,,"{
            /* This chunk is a chained part of a larger item. */
            ch = (item_chunk *) it;
            /* Instead, we use the head chunk to find the item and effectively
             * lock the entire structure. If a chunk has ITEM_CHUNK flag, its
             * head cannot be slabbed, so the normal routine is safe. */
            it = ch->head;
            assert(it->it_flags & ITEM_CHUNKED);
        }",40,,878,2,,void
84351,BLOCK,1,,<empty>,,,,1,,void
84360,BLOCK,1,,<empty>,,,,1,,void
84363,BLOCK,1,,<empty>,,,,1,,void
84365,BLOCK,-1,,"{
            /* ITEM_SLABBED can only be added/removed under the slabs_lock */
            if (it->it_flags & ITEM_SLABBED) {
                assert(ch == NULL);
                slab_rebalance_cut_free(s_cls, it);
                status = MOVE_FROM_SLAB;
            } else if ((it->it_flags & ITEM_LINKED) != 0) {
                /* If it doesn't have ITEM_SLABBED, the item could be in any
                 * state on its way to being freed or written to. If no
                 * ITEM_SLABBED, but it's had ITEM_LINKED, it must be active
                 * and have the key written to it already.
                 */
                hv = hash(ITEM_key(it), it->nkey);
                if ((hold_lock = item_trylock(hv)) == NULL) {
                    status = MOVE_LOCKED;
                } else {
                    bool is_linked = (it->it_flags & ITEM_LINKED);
                    refcount = refcount_incr(it);
                    if (refcount == 2) { /* item is linked but not busy */
    ...",58,,891,2,,void
84372,BLOCK,1,,<empty>,,,,1,,void
84374,BLOCK,-1,,"{
                assert(ch == NULL);
                slab_rebalance_cut_free(s_cls, it);
                status = MOVE_FROM_SLAB;
            }",46,,893,2,,void
84386,BLOCK,-1,,<empty>,20,,897,1,,void
84394,BLOCK,1,,<empty>,,,,1,,void
84397,BLOCK,-1,,"{
                /* If it doesn't have ITEM_SLABBED, the item could be in any
                 * state on its way to being freed or written to. If no
                 * ITEM_SLABBED, but it's had ITEM_LINKED, it must be active
                 * and have the key written to it already.
                 */
                hv = hash(ITEM_key(it), it->nkey);
                if ((hold_lock = item_trylock(hv)) == NULL) {
                    status = MOVE_LOCKED;
                } else {
                    bool is_linked = (it->it_flags & ITEM_LINKED);
                    refcount = refcount_incr(it);
                    if (refcount == 2) { /* item is linked but not busy */
                        /* Double check ITEM_LINKED flag here, since we're
                         * past a memory barrier from the mutex. */
                        if (is_linked) {
                            status = MOVE_FROM_LRU;
                        } else {
                            /* refcount == 1 + !I...",59,,897,2,,void
84403,BLOCK,1,,<empty>,,,,4,,void
84430,BLOCK,-1,,"{
                    status = MOVE_LOCKED;
                }",61,,904,2,,void
84435,BLOCK,-1,,"{
                    bool is_linked = (it->it_flags & ITEM_LINKED);
                    refcount = refcount_incr(it);
                    if (refcount == 2) { /* item is linked but not busy */
                        /* Double check ITEM_LINKED flag here, since we're
                         * past a memory barrier from the mutex. */
                        if (is_linked) {
                            status = MOVE_FROM_LRU;
                        } else {
                            /* refcount == 1 + !ITEM_LINKED means the item is being
                             * uploaded to, or was just unlinked but hasn't been freed
                             * yet. Let it bleed off on its own and try again later */
                            status = MOVE_BUSY;
                        }
                    } else if (refcount > 2 && is_linked) {
                        // TODO: Mark items for delete/rescue and process
                        // outside of the main loop.
               ...",24,,906,1,,void
84444,BLOCK,1,,<empty>,,,,1,,void
84450,BLOCK,1,,<empty>,,,,3,,void
84459,BLOCK,-1,,"{ /* item is linked but not busy */
                        /* Double check ITEM_LINKED flag here, since we're
                         * past a memory barrier from the mutex. */
                        if (is_linked) {
                            status = MOVE_FROM_LRU;
                        } else {
                            /* refcount == 1 + !ITEM_LINKED means the item is being
                             * uploaded to, or was just unlinked but hasn't been freed
                             * yet. Let it bleed off on its own and try again later */
                            status = MOVE_BUSY;
                        }
                    }",40,,909,2,,void
84462,BLOCK,-1,,"{
                            status = MOVE_FROM_LRU;
                        }",40,,912,2,,void
84467,BLOCK,-1,,"{
                            /* refcount == 1 + !ITEM_LINKED means the item is being
                             * uploaded to, or was just unlinked but hasn't been freed
                             * yet. Let it bleed off on its own and try again later */
                            status = MOVE_BUSY;
                        }",32,,914,1,,void
84472,BLOCK,-1,,<empty>,28,,920,1,,void
84479,BLOCK,-1,,"{
                        // TODO: Mark items for delete/rescue and process
                        // outside of the main loop.
                        if (slab_rebal.busy_loops > SLAB_MOVE_MAX_LOOPS) {
                            slab_rebal.busy_deletes++;
                            // Only safe to hold slabs lock because refcount
                            // can't drop to 0 until we release item lock.
                            STORAGE_delete(storage, it);
                            pthread_mutex_unlock(&slabs_lock);
                            do_item_unlink(it, hv);
                            pthread_mutex_lock(&slabs_lock);
                        }
                        status = MOVE_BUSY;
                    }",59,,920,2,,void
84486,BLOCK,1,,<empty>,,,,1,,void
84488,BLOCK,-1,,"{
                            slab_rebal.busy_deletes++;
                            // Only safe to hold slabs lock because refcount
                            // can't drop to 0 until we release item lock.
                            STORAGE_delete(storage, it);
                            pthread_mutex_unlock(&slabs_lock);
                            do_item_unlink(it, hv);
                            pthread_mutex_lock(&slabs_lock);
                        }",74,,923,2,,void
84506,BLOCK,-1,,"{
                        if (settings.verbose > 2) {
                            fprintf(stderr, ""Slab reassign hit a busy item: refcount: %d (%d -> %d)\n"",
                                it->refcount, slab_rebal.s_clsid, slab_rebal.d_clsid);
                        }
                        status = MOVE_BUSY;
                    }",28,,933,1,,void
84513,BLOCK,-1,,"{
                            fprintf(stderr, ""Slab reassign hit a busy item: refcount: %d (%d -> %d)\n"",
                                it->refcount, slab_rebal.s_clsid, slab_rebal.d_clsid);
                        }",51,,934,2,,void
84533,BLOCK,-1,,"{
                        refcount_decr(it);
                        item_trylock_unlock(hold_lock);
                    }",46,,941,2,,void
84536,BLOCK,1,,<empty>,,,,3,,void
84544,BLOCK,-1,,"{
                /* See above comment. No ITEM_SLABBED or ITEM_LINKED. Mark
                 * busy and wait for item to complete its upload. */
                status = MOVE_BUSY;
            }",20,,946,1,,void
84562,BLOCK,-1,,"{
            case MOVE_FROM_LRU:
                /* Lock order is LRU locks -> slabs_lock. unlink uses LRU lock.
                 * We only need to hold the slabs_lock while initially looking
                 * at an item, and at this point we have an exclusive refcount
                 * (2) + the item is locked. Drop slabs lock, drop item to
                 * refcount 1 (just our own, then fall through and wipe it
                 */
                /* Check if expired or flushed */
                ntotal = ITEM_ntotal(it);
#ifdef EXTSTORE
                if (it->it_flags & ITEM_HDR) {
                    ntotal = (ntotal - it->nbytes) + sizeof(item_hdr);
                }
#endif
                /* REQUIRES slabs_lock: CHECK FOR cls->sl_curr > 0 */
                if (ch == NULL && (it->it_flags & ITEM_CHUNKED)) {
                    /* Chunked should be identical to non-chunked, except we need
                     * to swap out ntotal for the head-chunk-total. */
              ...",25,,956,2,,void
84569,BLOCK,1,,<empty>,,,,6,,void
84612,BLOCK,1,,<empty>,,,,1,,void
84614,BLOCK,-1,,"{
                    /* Chunked should be identical to non-chunked, except we need
                     * to swap out ntotal for the head-chunk-total. */
                    ntotal = s_cls->size;
                }",66,,972,2,,void
84635,BLOCK,-1,,"{
                    /* Expired, don't save. */
                    save_item = 0;
                }",45,,978,2,,void
84640,BLOCK,-1,,<empty>,24,,981,1,,void
84655,BLOCK,-1,,"{
                    /* Not a chunk of an item, and nomem. */
                    save_item = 0;
                    slab_rebal.evictions_nomem++;
                }",94,,982,2,,void
84664,BLOCK,-1,,<empty>,24,,986,1,,void
84681,BLOCK,-1,,"{
                    /* Is a chunk of an item, and nomem. */
                    save_item = 0;
                    slab_rebal.evictions_nomem++;
                }",99,,987,2,,void
84690,BLOCK,-1,,"{
                    /* Was whatever it was, and we have memory for it. */
                    save_item = 1;
                }",24,,991,1,,void
84699,BLOCK,-1,,"{
                    if (ch == NULL) {
                        assert((new_it->it_flags & ITEM_CHUNKED) == 0);
                        /* if free memory, memcpy. clear prev/next/h_bucket */
                        memcpy(new_it, it, ntotal);
                        new_it->prev = 0;
                        new_it->next = 0;
                        new_it->h_next = 0;
                        /* These are definitely required. else fails assert */
                        new_it->it_flags &= ~ITEM_LINKED;
                        new_it->refcount = 0;
                        do_item_replace(it, new_it, hv);
                        /* Need to walk the chunks and repoint head  */
                        if (new_it->it_flags & ITEM_CHUNKED) {
                            item_chunk *fch = (item_chunk *) ITEM_schunk(new_it);
                            fch->next->prev = fch;
                            while (fch) {
                                fch->head = new_it;
                        ...",32,,996,2,,void
84704,BLOCK,-1,,"{
                        assert((new_it->it_flags & ITEM_CHUNKED) == 0);
                        /* if free memory, memcpy. clear prev/next/h_bucket */
                        memcpy(new_it, it, ntotal);
                        new_it->prev = 0;
                        new_it->next = 0;
                        new_it->h_next = 0;
                        /* These are definitely required. else fails assert */
                        new_it->it_flags &= ~ITEM_LINKED;
                        new_it->refcount = 0;
                        do_item_replace(it, new_it, hv);
                        /* Need to walk the chunks and repoint head  */
                        if (new_it->it_flags & ITEM_CHUNKED) {
                            item_chunk *fch = (item_chunk *) ITEM_schunk(new_it);
                            fch->next->prev = fch;
                            while (fch) {
                                fch->head = new_it;
                                fch = fch->next;
             ...",37,,997,2,,void
84712,BLOCK,1,,<empty>,,,,1,,void
84740,BLOCK,1,,<empty>,,,,1,,void
84757,BLOCK,1,,<empty>,,,,1,,void
84759,BLOCK,-1,,"{
                            item_chunk *fch = (item_chunk *) ITEM_schunk(new_it);
                            fch->next->prev = fch;
                            while (fch) {
                                fch->head = new_it;
                                fch = fch->next;
                            }
                        }",62,,1009,2,,void
84767,BLOCK,1,,<empty>,,,,6,,void
84809,BLOCK,-1,,"{
                                fch->head = new_it;
                                fch = fch->next;
                            }",41,,1012,2,,void
84831,BLOCK,1,,<empty>,,,,1,,void
84834,BLOCK,1,,<empty>,,,,1,,void
84841,BLOCK,-1,,"{
                        item_chunk *nch = (item_chunk *) new_it;
                        /* Chunks always have head chunk (the main it) */
                        ch->prev->next = nch;
                        if (ch->next)
                            ch->next->prev = nch;
                        memcpy(nch, ch, ch->used + sizeof(item_chunk));
                        ch->refcount = 0;
                        ch->it_flags = ITEM_SLABBED|ITEM_FETCHED;
                        slab_rebal.chunk_rescues++;
#ifdef DEBUG_SLAB_MOVER
                        memcpy(ITEM_key((item *)ch), ""deadbeef"", 8);
#endif
                        refcount_decr(it);
                    }",28,,1023,1,,void
84859,BLOCK,-1,,<empty>,29,,1028,2,,void
84887,BLOCK,1,,<empty>,,,,1,,void
84890,BLOCK,1,,<empty>,,,,1,,void
84898,BLOCK,1,,<empty>,,,,3,,void
84911,BLOCK,-1,,"{
                    /* unlink and mark as done if it's not
                     * a chunked item as they require more book-keeping) */
                    STORAGE_delete(storage, it);
                    if (!ch && (it->it_flags & ITEM_CHUNKED) == 0) {
                        do_item_unlink(it, hv);
                        it->it_flags = ITEM_SLABBED|ITEM_FETCHED;
                        it->refcount = 0;
#ifdef DEBUG_SLAB_MOVER
                        memcpy(ITEM_key(it), ""deadbeef"", 8);
#endif
                        slab_rebal.completed[offset] = 1;
                    } else {
                        ntotal = ITEM_ntotal(it);
                        do_item_unlink(it, hv);
                        slabs_free(it, ntotal, slab_rebal.s_clsid);
                        /* Swing around again later to remove it from the freelist. */
                        slab_rebal.busy_items++;
                        was_busy++;
                    }

                }",24,,1039,1,,void
84922,BLOCK,1,,<empty>,,,,1,,void
84925,BLOCK,-1,,"{
                        do_item_unlink(it, hv);
                        it->it_flags = ITEM_SLABBED|ITEM_FETCHED;
                        it->refcount = 0;
#ifdef DEBUG_SLAB_MOVER
                        memcpy(ITEM_key(it), ""deadbeef"", 8);
#endif
                        slab_rebal.completed[offset] = 1;
                    }",68,,1043,2,,void
84935,BLOCK,1,,<empty>,,,,1,,void
84938,BLOCK,1,,<empty>,,,,1,,void
84953,BLOCK,-1,,"{
                        ntotal = ITEM_ntotal(it);
                        do_item_unlink(it, hv);
                        slabs_free(it, ntotal, slab_rebal.s_clsid);
                        /* Swing around again later to remove it from the freelist. */
                        slab_rebal.busy_items++;
                        was_busy++;
                    }",28,,1051,1,,void
84958,BLOCK,1,,<empty>,,,,6,,void
85032,BLOCK,1,,<empty>,,,,1,,void
85035,BLOCK,1,,<empty>,,,,1,,void
85076,BLOCK,-1,,"{
        /* Some items were busy, start again from the top */
        if (slab_rebal.busy_items) {
            slab_rebal.slab_pos = slab_rebal.slab_start;
            STATS_LOCK();
            stats.slab_reassign_busy_items += slab_rebal.busy_items;
            STATS_UNLOCK();
            slab_rebal.busy_items = 0;
            slab_rebal.busy_loops++;
        } else {
            slab_rebal.done++;
        }
    }",53,,1092,2,,void
85081,BLOCK,-1,,"{
            slab_rebal.slab_pos = slab_rebal.slab_start;
            STATS_LOCK();
            stats.slab_reassign_busy_items += slab_rebal.busy_items;
            STATS_UNLOCK();
            slab_rebal.busy_items = 0;
            slab_rebal.busy_loops++;
        }",36,,1094,2,,void
85108,BLOCK,-1,,"{
            slab_rebal.done++;
        }",16,,1101,1,,void
85119,BLOCK,-1,,"{
    slabclass_t *s_cls;
    slabclass_t *d_cls;
    int x;
    uint32_t rescues;
    uint32_t evictions_nomem;
    uint32_t inline_reclaim;
    uint32_t chunk_rescues;
    uint32_t busy_deletes;

    pthread_mutex_lock(&slabs_lock);

    s_cls = &slabclass[slab_rebal.s_clsid];
    d_cls = &slabclass[slab_rebal.d_clsid];

#ifdef DEBUG_SLAB_MOVER
    /* If the algorithm is broken, live items can sneak in. */
    slab_rebal.slab_pos = slab_rebal.slab_start;
    while (1) {
        item *it = slab_rebal.slab_pos;
        assert(it->it_flags == (ITEM_SLABBED|ITEM_FETCHED));
        assert(memcmp(ITEM_key(it), ""deadbeef"", 8) == 0);
        it->it_flags = ITEM_SLABBED|ITEM_FETCHED;
        slab_rebal.slab_pos = (char *)slab_rebal.slab_pos + s_cls->size;
        if (slab_rebal.slab_pos >= slab_rebal.slab_end)
            break;
    }
#endif

    /* At this point the stolen slab is completely clear.
     * We always kill the ""first""/""oldest"" slab page in the slab_list, so
     * shuffle th...",41,,1109,2,,void
85152,BLOCK,-1,,<empty>,5,,1143,1,,void
85163,BLOCK,4,,"{
        s_cls->slab_list[x] = s_cls->slab_list[x+1];
    }",40,,1143,4,,void
85195,BLOCK,1,,<empty>,,,,1,,void
85197,BLOCK,-1,,"{
        memset(slab_rebal.slab_start, 0, (size_t)settings.slab_page_size);
        split_slab_page_into_freelist(slab_rebal.slab_start,
            slab_rebal.d_clsid);
    }",53,,1149,2,,void
85216,BLOCK,-1,,<empty>,12,,1153,1,,void
85223,BLOCK,1,,<empty>,,,,1,,void
85225,BLOCK,-1,,"{
        /* memset just enough to signal restart handler to skip */
        memset(slab_rebal.slab_start, 0, sizeof(item));
        /* mem_malloc'ed might be higher than mem_limit. */
        mem_limit_reached = false;
        memory_release();
    }",61,,1153,2,,void
85374,BLOCK,-1,,"{
        fprintf(stderr, ""finished a slab move\n"");
    }",31,,1194,2,,void
85382,BLOCK,-1,,"{
    int was_busy = 0;
    int backoff_timer = 1;
    int backoff_max = 1000;
    /* So we first pass into cond_wait with the mutex held */
    mutex_lock(&slabs_rebalance_lock);

    /* Must finish moving page before stopping */
    while (slab_rebalance_signal || do_run_slab_rebalance_thread) {
        if (slab_rebalance_signal == 1) {
            if (slab_rebalance_start() < 0) {
                /* Handle errors with more specificity as required. */
                slab_rebalance_signal = 0;
            }

            was_busy = 0;
        } else if (slab_rebalance_signal && slab_rebal.slab_start != NULL) {
            was_busy = slab_rebalance_move();
        }

        if (slab_rebal.done) {
            slab_rebalance_finish();
        } else if (was_busy) {
            /* Stuck waiting for some items to unlock, so slow down a bit
             * to give them a chance to free up */
            usleep(backoff_timer);
            backoff_timer = backoff_timer * 2;
            if ...",47,,1202,2,,void
85398,BLOCK,1,,<empty>,,,,3,,void
85406,BLOCK,-1,,"{
        if (slab_rebalance_signal == 1) {
            if (slab_rebalance_start() < 0) {
                /* Handle errors with more specificity as required. */
                slab_rebalance_signal = 0;
            }

            was_busy = 0;
        } else if (slab_rebalance_signal && slab_rebal.slab_start != NULL) {
            was_busy = slab_rebalance_move();
        }

        if (slab_rebal.done) {
            slab_rebalance_finish();
        } else if (was_busy) {
            /* Stuck waiting for some items to unlock, so slow down a bit
             * to give them a chance to free up */
            usleep(backoff_timer);
            backoff_timer = backoff_timer * 2;
            if (backoff_timer > backoff_max)
                backoff_timer = backoff_max;
        }

        if (slab_rebalance_signal == 0) {
            /* always hold this lock while we're running */
            pthread_cond_wait(&slab_rebalance_cond, &slabs_rebalance_lock);
        }
    }",67,,1210,2,,void
85411,BLOCK,-1,,"{
            if (slab_rebalance_start() < 0) {
                /* Handle errors with more specificity as required. */
                slab_rebalance_signal = 0;
            }

            was_busy = 0;
        }",41,,1211,2,,void
85416,BLOCK,-1,,"{
                /* Handle errors with more specificity as required. */
                slab_rebalance_signal = 0;
            }",45,,1212,2,,void
85424,BLOCK,-1,,<empty>,16,,1218,1,,void
85433,BLOCK,-1,,"{
            was_busy = slab_rebalance_move();
        }",76,,1218,2,,void
85441,BLOCK,-1,,"{
            slab_rebalance_finish();
        }",30,,1222,2,,void
85444,BLOCK,-1,,<empty>,16,,1224,1,,void
85447,BLOCK,-1,,"{
            /* Stuck waiting for some items to unlock, so slow down a bit
             * to give them a chance to free up */
            usleep(backoff_timer);
            backoff_timer = backoff_timer * 2;
            if (backoff_timer > backoff_max)
                backoff_timer = backoff_max;
        }",30,,1224,2,,void
85459,BLOCK,-1,,<empty>,17,,1230,2,,void
85467,BLOCK,-1,,"{
            /* always hold this lock while we're running */
            pthread_cond_wait(&slab_rebalance_cond, &slabs_rebalance_lock);
        }",41,,1233,2,,void
85476,BLOCK,1,,<empty>,,,,3,,void
85486,BLOCK,-1,,"{
    static int cur = POWER_SMALLEST - 1;
    int tries = power_largest - POWER_SMALLEST + 1;
    for (; tries > 0; tries--) {
        cur++;
        if (cur > power_largest)
            cur = POWER_SMALLEST;
        if (cur == dst)
            continue;
        if (slabclass[cur].slabs > 1) {
            return cur;
        }
    }
    return -1;
}",45,,1248,2,,void
85492,BLOCK,1,,<empty>,,,,1,,void
85502,BLOCK,1,,<empty>,,,,1,,void
85506,BLOCK,-1,,<empty>,5,,1251,1,,void
85512,BLOCK,4,,"{
        cur++;
        if (cur > power_largest)
            cur = POWER_SMALLEST;
        if (cur == dst)
            continue;
        if (slabclass[cur].slabs > 1) {
            return cur;
        }
    }",32,,1251,4,,void
85519,BLOCK,-1,,<empty>,13,,1254,2,,void
85523,BLOCK,1,,<empty>,,,,1,,void
85529,BLOCK,-1,,<empty>,13,,1256,2,,void
85539,BLOCK,-1,,"{
            return cur;
        }",39,,1257,2,,void
85550,BLOCK,-1,,"{
    bool nospare = false;
    if (slab_rebalance_signal != 0)
        return REASSIGN_RUNNING;

    if (src == dst)
        return REASSIGN_SRC_DST_SAME;

    /* Special indicator to choose ourselves. */
    if (src == -1) {
        src = slabs_reassign_pick_any(dst);
        /* TODO: If we end up back at -1, return a new error type */
    }

    if (src < SLAB_GLOBAL_PAGE_POOL || src > power_largest ||
        dst < SLAB_GLOBAL_PAGE_POOL || dst > power_largest)
        return REASSIGN_BADCLASS;

    pthread_mutex_lock(&slabs_lock);
    if (slabclass[src].slabs < 2)
        nospare = true;
    pthread_mutex_unlock(&slabs_lock);
    if (nospare)
        return REASSIGN_NOSPARE;

    slab_rebal.s_clsid = src;
    slab_rebal.d_clsid = dst;

    slab_rebalance_signal = 1;
    pthread_cond_signal(&slab_rebalance_cond);

    return REASSIGN_OK;
}",70,,1264,3,,void
85559,BLOCK,-1,,<empty>,9,,1267,2,,void
85566,BLOCK,-1,,<empty>,9,,1270,2,,void
85574,BLOCK,-1,,"{
        src = slabs_reassign_pick_any(dst);
        /* TODO: If we end up back at -1, return a new error type */
    }",20,,1273,2,,void
85586,BLOCK,1,,<empty>,,,,1,,void
85594,BLOCK,1,,<empty>,,,,1,,void
85599,BLOCK,-1,,<empty>,9,,1280,2,,void
85613,BLOCK,-1,,<empty>,9,,1284,2,,void
85622,BLOCK,-1,,<empty>,9,,1287,2,,void
85648,BLOCK,-1,,"{
    enum reassign_result_type ret;
    if (pthread_mutex_trylock(&slabs_rebalance_lock) != 0) {
        return REASSIGN_RUNNING;
    }
    ret = do_slabs_reassign(src, dst);
    pthread_mutex_unlock(&slabs_rebalance_lock);
    return ret;
}",60,,1298,3,,void
85656,BLOCK,-1,,"{
        return REASSIGN_RUNNING;
    }",60,,1300,2,,void
85673,BLOCK,-1,,"{
    pthread_mutex_lock(&slabs_rebalance_lock);
}",35,,1309,2,,void
85681,BLOCK,-1,,"{
    pthread_mutex_unlock(&slabs_rebalance_lock);
}",36,,1313,2,,void
85690,BLOCK,-1,,"{
    int ret;
    slab_rebalance_signal = 0;
    slab_rebal.slab_start = NULL;

    if ((ret = pthread_create(&rebalance_tid, NULL,
                              slab_rebalance_thread, NULL)) != 0) {
        fprintf(stderr, ""Can't create rebal thread: %s\n"", strerror(ret));
        return -1;
    }
    return 0;
}",41,,1319,2,,void
85711,BLOCK,-1,,"{
        fprintf(stderr, ""Can't create rebal thread: %s\n"", strerror(ret));
        return -1;
    }",67,,1325,2,,void
85726,BLOCK,-1,,"{
    mutex_lock(&slabs_rebalance_lock);
    do_run_slab_rebalance_thread = 0;
    pthread_cond_signal(&slab_rebalance_cond);
    pthread_mutex_unlock(&slabs_rebalance_lock);

    /* Wait for the maintenance thread to stop */
    pthread_join(rebalance_tid, NULL);
}",41,,1334,2,,void
85730,BLOCK,1,,<empty>,,,,3,,void
85752,BLOCK,-1,,<empty>,1,,1,1,,ANY
85760,BLOCK,-1,,<empty>,,,,7,,<empty>
85765,BLOCK,-1,,<empty>,,,,2,,<empty>
85770,BLOCK,-1,,<empty>,,,,2,,<empty>
85775,BLOCK,-1,,<empty>,,,,2,,<empty>
85782,BLOCK,-1,,<empty>,,,,4,,<empty>
85789,BLOCK,-1,,<empty>,,,,4,,<empty>
85794,BLOCK,-1,,<empty>,,,,2,,<empty>
85805,BLOCK,-1,,<empty>,,,,2,,<empty>
85810,BLOCK,-1,,<empty>,,,,2,,<empty>
85816,BLOCK,-1,,<empty>,,,,3,,<empty>
85823,BLOCK,-1,,<empty>,,,,4,,<empty>
85828,BLOCK,-1,,<empty>,,,,2,,<empty>
85833,BLOCK,-1,,<empty>,,,,2,,<empty>
85838,BLOCK,-1,,<empty>,,,,2,,<empty>
85843,BLOCK,-1,,<empty>,,,,2,,<empty>
85853,BLOCK,-1,,<empty>,,,,1,,<empty>
85863,BLOCK,-1,,<empty>,,,,2,,<empty>
85868,BLOCK,-1,,<empty>,,,,2,,<empty>
85874,BLOCK,-1,,<empty>,,,,3,,<empty>
85889,BLOCK,-1,,<empty>,1,,1,1,,ANY
85906,BLOCK,-1,,<empty>,1,,1,1,,ANY
85910,BLOCK,1,,<empty>,,,,1,,void
85923,BLOCK,-1,,"{
    prefix_delimiter = delimiter;
    memset(prefix_stats, 0, sizeof(prefix_stats));
}",40,,16,2,,void
85936,BLOCK,-1,,"{
    int i;

    for (i = 0; i < PREFIX_HASH_SIZE; i++) {
        PREFIX_STATS *cur, *next;
        for (cur = prefix_stats[i]; cur != NULL; cur = next) {
            next = cur->next;
            free(cur->prefix);
            free(cur);
        }
        prefix_stats[i] = NULL;
    }
    num_prefixes = 0;
    total_prefix_size = 0;
}",31,,21,2,,void
85939,BLOCK,-1,,<empty>,5,,24,1,,void
85946,BLOCK,1,,<empty>,,,,1,,void
85950,BLOCK,4,,"{
        PREFIX_STATS *cur, *next;
        for (cur = prefix_stats[i]; cur != NULL; cur = next) {
            next = cur->next;
            free(cur->prefix);
            free(cur);
        }
        prefix_stats[i] = NULL;
    }",44,,24,4,,void
85954,BLOCK,-1,,<empty>,9,,26,1,,void
85966,BLOCK,4,,"{
            next = cur->next;
            free(cur->prefix);
            free(cur);
        }",62,,26,4,,void
85994,BLOCK,-1,,"{
    PREFIX_STATS *pfs;
    uint32_t hashval;
    size_t length;
    bool bailout = true;

    assert(key != NULL);

    for (length = 0; length < nkey && key[length] != '\0'; length++) {
        if (key[length] == prefix_delimiter) {
            bailout = false;
            break;
        }
    }

    if (bailout) {
        return NULL;
    }

    hashval = hash(key, length) % PREFIX_HASH_SIZE;

    for (pfs = prefix_stats[hashval]; NULL != pfs; pfs = pfs->next) {
        if (strncmp(pfs->prefix, key, length) == 0)
            return pfs;
    }

    pfs = calloc(sizeof(PREFIX_STATS), 1);
    if (NULL == pfs) {
        perror(""Can't allocate space for stats structure: calloc"");
        return NULL;
    }

    pfs->prefix = malloc(length + 1);
    if (NULL == pfs->prefix) {
        perror(""Can't allocate space for copy of prefix: malloc"");
        free(pfs);
        return NULL;
    }

    strncpy(pfs->prefix, key, length);
    pfs->prefix[length] = '\0';      /* because strncpy() s...",69,,37,3,,void
86007,BLOCK,-1,,<empty>,5,,45,1,,void
86022,BLOCK,4,,"{
        if (key[length] == prefix_delimiter) {
            bailout = false;
            break;
        }
    }",70,,45,4,,void
86029,BLOCK,-1,,"{
            bailout = false;
            break;
        }",46,,46,2,,void
86036,BLOCK,-1,,"{
        return NULL;
    }",18,,52,2,,void
86046,BLOCK,1,,<empty>,,,,1,,void
86049,BLOCK,-1,,<empty>,5,,58,1,,void
86063,BLOCK,4,,"{
        if (strncmp(pfs->prefix, key, length) == 0)
            return pfs;
    }",69,,58,4,,void
86073,BLOCK,-1,,<empty>,13,,60,2,,void
86086,BLOCK,-1,,"{
        perror(""Can't allocate space for stats structure: calloc"");
        return NULL;
    }",22,,64,2,,void
86105,BLOCK,-1,,"{
        perror(""Can't allocate space for copy of prefix: malloc"");
        free(pfs);
        return NULL;
    }",30,,70,2,,void
86155,BLOCK,-1,,"{
    PREFIX_STATS *pfs;

    STATS_LOCK();
    pfs = stats_prefix_find(key, nkey);
    if (NULL != pfs) {
        pfs->num_gets++;
        if (is_hit) {
            pfs->num_hits++;
        }
    }
    STATS_UNLOCK();
}",85,,89,4,,void
86167,BLOCK,-1,,"{
        pfs->num_gets++;
        if (is_hit) {
            pfs->num_hits++;
        }
    }",22,,94,2,,void
86174,BLOCK,-1,,"{
            pfs->num_hits++;
        }",21,,96,2,,void
86185,BLOCK,-1,,"{
    PREFIX_STATS *pfs;

    STATS_LOCK();
    pfs = stats_prefix_find(key, nkey);
    if (NULL != pfs) {
        pfs->num_deletes++;
    }
    STATS_UNLOCK();
}",69,,103,3,,void
86197,BLOCK,-1,,"{
        pfs->num_deletes++;
    }",22,,108,2,,void
86208,BLOCK,-1,,"{
    PREFIX_STATS *pfs;

    STATS_LOCK();
    pfs = stats_prefix_find(key, nkey);
    if (NULL != pfs) {
        pfs->num_sets++;
    }
    STATS_UNLOCK();
}",66,,114,3,,void
86220,BLOCK,-1,,"{
        pfs->num_sets++;
    }",22,,119,2,,void
86230,BLOCK,-1,,"{
    const char *format = ""PREFIX %s get %llu hit %llu set %llu del %llu\r\n"";
    PREFIX_STATS *pfs;
    char *buf;
    int i, pos;
    size_t size = 0, written = 0;
#ifndef NDEBUG
    size_t total_written = 0;
#endif
    /*
     * Figure out how big the buffer needs to be. This is the sum of the
     * lengths of the prefixes themselves, plus the size of one copy of
     * the per-prefix output with 20-digit values for all the counts,
     * plus space for the ""END"" at the end.
     */
    STATS_LOCK();
    size = strlen(format) + total_prefix_size +
           num_prefixes * (strlen(format) - 2 /* %s */
                           + 4 * (20 - 4)) /* %llu replaced by 20-digit num */
                           + sizeof(""END\r\n"");
    buf = malloc(size);
    if (NULL == buf) {
        perror(""Can't allocate stats response: malloc"");
        STATS_UNLOCK();
        return NULL;
    }

    pos = 0;
    for (i = 0; i < PREFIX_HASH_SIZE; i++) {
        for (pfs = prefix_stats[i]; NULL ...",38,,125,2,,void
86282,BLOCK,-1,,"{
        perror(""Can't allocate stats response: malloc"");
        STATS_UNLOCK();
        return NULL;
    }",22,,146,2,,void
86292,BLOCK,-1,,<empty>,5,,153,1,,void
86299,BLOCK,1,,<empty>,,,,1,,void
86303,BLOCK,4,,"{
        for (pfs = prefix_stats[i]; NULL != pfs; pfs = pfs->next) {
            written = snprintf(buf + pos, size-pos, format,
                           pfs->prefix, pfs->num_gets, pfs->num_hits,
                           pfs->num_sets, pfs->num_deletes);
            pos += written;
#ifndef NDEBUG
            total_written += written;
            assert(total_written < size);
#endif
        }
    }",44,,153,4,,void
86305,BLOCK,-1,,<empty>,9,,154,1,,void
86319,BLOCK,4,,"{
            written = snprintf(buf + pos, size-pos, format,
                           pfs->prefix, pfs->num_gets, pfs->num_hits,
                           pfs->num_sets, pfs->num_deletes);
            pos += written;
#ifndef NDEBUG
            total_written += written;
            assert(total_written < size);
#endif
        }",67,,154,4,,void
86376,BLOCK,-1,,<empty>,1,,1,1,,ANY
86379,BLOCK,-1,,<empty>,,,,2,,<empty>
86384,BLOCK,-1,,<empty>,,,,2,,<empty>
86391,BLOCK,-1,,<empty>,,,,4,,<empty>
86397,BLOCK,-1,,<empty>,,,,3,,<empty>
86403,BLOCK,-1,,<empty>,,,,3,,<empty>
86408,BLOCK,-1,,<empty>,,,,2,,<empty>
86424,BLOCK,-1,,<empty>,,,,3,,<empty>
86449,BLOCK,-1,,<empty>,1,,1,1,,ANY
86454,BLOCK,-1,,<empty>,1,,1,1,,ANY
86458,BLOCK,-1,,<empty>,,,,3,,<empty>
86464,BLOCK,-1,,<empty>,,,,3,,<empty>
86470,BLOCK,-1,,<empty>,,,,3,,<empty>
86476,BLOCK,-1,,<empty>,,,,3,,<empty>
86483,BLOCK,-1,,<empty>,,,,4,,<empty>
86488,BLOCK,-1,,<empty>,,,,2,,<empty>
86493,BLOCK,-1,,<empty>,,,,2,,<empty>
86498,BLOCK,-1,,<empty>,,,,2,,<empty>
86503,BLOCK,-1,,<empty>,,,,2,,<empty>
86508,BLOCK,-1,,<empty>,,,,2,,<empty>
86513,BLOCK,-1,,<empty>,,,,2,,<empty>
86518,BLOCK,-1,,<empty>,,,,2,,<empty>
86523,BLOCK,-1,,<empty>,,,,2,,<empty>
86528,BLOCK,-1,,<empty>,,,,2,,<empty>
86535,BLOCK,-1,,<empty>,,,,2,,<empty>
86541,BLOCK,-1,,<empty>,,,,3,,<empty>
86546,BLOCK,-1,,<empty>,,,,2,,<empty>
86551,BLOCK,-1,,<empty>,,,,2,,<empty>
86610,BLOCK,-1,,<empty>,1,,1,1,,ANY
86623,BLOCK,-1,,<empty>,,,,4,,<empty>
86630,BLOCK,-1,,<empty>,,,,4,,<empty>
86638,BLOCK,-1,,<empty>,,,,4,,<empty>
86645,BLOCK,-1,,<empty>,,,,4,,<empty>
86652,BLOCK,-1,,"{
    assert(c != NULL);
    return read(c->sock, buf, count);
}",59,,56,4,,void
86670,BLOCK,-1,,"{
    assert(c != NULL);
    return write(c->sock, buf, count);
}",66,,61,4,,void
86700,BLOCK,-1,,"{
    if (con == NULL) return;
#ifdef TLS
    if (con->ssl) {
        SSL_shutdown(con->ssl);
        SSL_free(con->ssl);
    }
    if (con->ssl_ctx)
        SSL_CTX_free(con->ssl_ctx);
#endif
    if (con->sock > 0) close(con->sock);
    free(con);
    con = NULL;
}",26,,83,1,,void
86705,BLOCK,-1,,<empty>,22,,84,2,,void
86713,BLOCK,-1,,<empty>,24,,93,2,,void
86727,BLOCK,-1,,"{
    cache_t *cache = cache_create(""test"", sizeof(uint32_t), sizeof(char*));
    assert(cache != NULL);
    cache_destroy(cache);
    return TEST_PASS;
}",1,,99,2,,void
86749,BLOCK,-1,,"{
    int ii;
    cache_t *cache = cache_create(""test"", sizeof(uint32_t), sizeof(char*));
    if (cache == NULL) {
        return TEST_FAIL;
    }
    char *ptr = cache_alloc(cache);
    cache_free(cache, ptr);
    for (ii = 0; ii < 100; ++ii) {
        char *p = cache_alloc(cache);
        assert(p == ptr);
        cache_free(cache, ptr);
    }
    cache_destroy(cache);
    return TEST_PASS;
}",1,,107,2,,void
86764,BLOCK,-1,,"{
        return TEST_FAIL;
    }",24,,110,2,,void
86776,BLOCK,-1,,<empty>,5,,115,1,,void
86785,BLOCK,4,,"{
        char *p = cache_alloc(cache);
        assert(p == ptr);
        cache_free(cache, ptr);
    }",34,,115,4,,void
86806,BLOCK,-1,,"{
    cache_t *cache = cache_create(""test"", datasize, sizeof(char*));
    if (cache == NULL) {
        return TEST_FAIL;
    }
#define ITERATIONS 1024
    void *ptr[ITERATIONS];

    for (int ii = 0; ii < ITERATIONS; ++ii) {
        ptr[ii] = cache_alloc(cache);
        assert(ptr[ii] != 0);
        memset(ptr[ii], 0xff, datasize);
    }

    for (int ii = 0; ii < ITERATIONS; ++ii) {
        cache_free(cache, ptr[ii]);
    }

#undef ITERATIONS
    cache_destroy(cache);
    return TEST_PASS;
}",1,,126,2,,void
86819,BLOCK,-1,,"{
        return TEST_FAIL;
    }",24,,128,2,,void
86824,BLOCK,-1,,<empty>,5,,134,1,,void
86832,BLOCK,1,,<empty>,,,,1,,void
86836,BLOCK,4,,"{
        ptr[ii] = cache_alloc(cache);
        assert(ptr[ii] != 0);
        memset(ptr[ii], 0xff, datasize);
    }",45,,134,4,,void
86856,BLOCK,-1,,<empty>,5,,140,1,,void
86864,BLOCK,1,,<empty>,,,,1,,void
86868,BLOCK,4,,"{
        cache_free(cache, ptr[ii]);
    }",45,,140,4,,void
86882,BLOCK,-1,,"{
    enum test_return ret = cache_bulkalloc(1);
    if (ret == TEST_PASS) {
        ret = cache_bulkalloc(512);
    }

    return ret;
}",1,,150,2,,void
86892,BLOCK,-1,,"{
        ret = cache_bulkalloc(512);
    }",27,,152,2,,void
86903,BLOCK,-1,,"{
#ifndef HAVE_UMEM_H
    cache_t *cache = cache_create(""test"", sizeof(uint32_t), sizeof(char*));

    if (cache == NULL) {
        return TEST_FAIL;
    }
    /* Ignore SIGABRT */
    struct sigaction old_action;
    struct sigaction action = { .sa_handler = SIG_IGN, .sa_flags = 0};
    sigemptyset(&action.sa_mask);
    sigaction(SIGABRT, &action, &old_action);

    /* check memory debug.. */
    char *p = cache_alloc(cache);
    char old = *(p - 1);
    *(p - 1) = 0;
    cache_free(cache, p);
    assert(cache_error == -1);
    *(p - 1) = old;

    p[sizeof(uint32_t)] = 0;
    cache_free(cache, p);
    assert(cache_error == 1);

    /* restore signal handler */
    sigaction(SIGABRT, &old_action, NULL);

    cache_destroy(cache);

    return TEST_PASS;
#else
    return TEST_SKIP;
#endif
}",1,,160,2,,void
86917,BLOCK,-1,,"{
        return TEST_FAIL;
    }",24,,164,2,,void
86925,BLOCK,1,,<empty>,33,,169,1,,void
86929,BLOCK,2,,<empty>,56,,169,2,,void
87002,BLOCK,-1,,"{
    int limit = 10, allocated_num = limit + 1, i;
    char ** alloc_objs = calloc(allocated_num, sizeof(char *));

    cache_t *cache = cache_create(""test"", sizeof(uint32_t), sizeof(char*));
    assert(cache != NULL);

    /* cache->limit is 0 and we can allocate limit+1 items */
    for (i = 0; i < allocated_num; i++) {
        alloc_objs[i] = cache_alloc(cache);
        assert(alloc_objs[i] != NULL);
    }
    assert(cache->total == allocated_num);

    /* revised downward cache->limit */
    cache_set_limit(cache, limit);

    /* If we free one item, the cache->total should decreased by one*/
    cache_free(cache, alloc_objs[0]);

    assert(cache->total == allocated_num-1);
    cache_destroy(cache);

    free(alloc_objs);

    return TEST_PASS;
}",1,,197,2,,void
87035,BLOCK,-1,,<empty>,5,,205,1,,void
87044,BLOCK,4,,"{
        alloc_objs[i] = cache_alloc(cache);
        assert(alloc_objs[i] != NULL);
    }",41,,205,4,,void
87089,BLOCK,-1,,"{
    PREFIX_STATS *pfs1, *pfs2;

    stats_prefix_clear();
    pfs1 = stats_prefix_find(""abc"", 3);
    assert(pfs1 == NULL);
    pfs1 = stats_prefix_find(""abc|"", 4);
    assert(pfs1 == NULL);

    pfs1 = stats_prefix_find(""abc:"", 4);
    assert(pfs1 != NULL);
    assert(0ULL == (pfs1->num_gets + pfs1->num_sets + pfs1->num_deletes + pfs1->num_hits));
    pfs2 = stats_prefix_find(""abc:"", 4);
    assert(pfs1 == pfs2);
    pfs2 = stats_prefix_find(""abc:d"", 5);
    assert(pfs1 == pfs2);
    pfs2 = stats_prefix_find(""xyz123:"", 6);
    assert(pfs1 != pfs2);
    pfs2 = stats_prefix_find(""ab:"", 3);
    assert(pfs1 != pfs2);
    return TEST_PASS;
}",54,,225,2,,void
87180,BLOCK,-1,,"{
    PREFIX_STATS *pfs;
    stats_prefix_clear();

    stats_prefix_record_get(""abc:123"", 7, false);
    pfs = stats_prefix_find(""abc:123"", 7);
    if (pfs == NULL) {
        return TEST_FAIL;
    }
    assert(1 == pfs->num_gets);
    assert(0 == pfs->num_hits);
    stats_prefix_record_get(""abc:456"", 7, false);
    assert(2 == pfs->num_gets);
    assert(0 == pfs->num_hits);
    stats_prefix_record_get(""abc:456"", 7, true);
    assert(3 == pfs->num_gets);
    assert(1 == pfs->num_hits);
    stats_prefix_record_get(""def:"", 4, true);
    assert(3 == pfs->num_gets);
    assert(1 == pfs->num_hits);
    return TEST_PASS;
}",60,,248,2,,void
87196,BLOCK,-1,,"{
        return TEST_FAIL;
    }",22,,254,2,,void
87265,BLOCK,-1,,"{
    PREFIX_STATS *pfs;
    stats_prefix_clear();

    stats_prefix_record_delete(""abc:123"", 7);
    pfs = stats_prefix_find(""abc:123"", 7);
    if (pfs == NULL) {
        return TEST_FAIL;
    }
    assert(0 == pfs->num_gets);
    assert(0 == pfs->num_hits);
    assert(1 == pfs->num_deletes);
    assert(0 == pfs->num_sets);
    stats_prefix_record_delete(""def:"", 4);
    assert(1 == pfs->num_deletes);
    return TEST_PASS;
}",63,,271,2,,void
87280,BLOCK,-1,,"{
        return TEST_FAIL;
    }",22,,277,2,,void
87322,BLOCK,-1,,"{
    PREFIX_STATS *pfs;
    stats_prefix_clear();

    stats_prefix_record_set(""abc:123"", 7);
    pfs = stats_prefix_find(""abc:123"", 7);
    if (pfs == NULL) {
        return TEST_FAIL;
    }
    assert(0 == pfs->num_gets);
    assert(0 == pfs->num_hits);
    assert(0 == pfs->num_deletes);
    assert(1 == pfs->num_sets);
    stats_prefix_record_delete(""def:"", 4);
    assert(1 == pfs->num_sets);
    return TEST_PASS;
}",60,,289,2,,void
87337,BLOCK,-1,,"{
        return TEST_FAIL;
    }",22,,295,2,,void
87379,BLOCK,-1,,"{
    int hashval = hash(""abc"", 3) % PREFIX_HASH_SIZE;
    char tmp[500];
    char *buf;
    const char *expected;
    int keynum;
    int length;

    stats_prefix_clear();

    assert(strcmp(""END\r\n"", (buf = stats_prefix_dump(&length))) == 0);
    assert(5 == length);
    stats_prefix_record_set(""abc:123"", 7);
    free(buf);
    expected = ""PREFIX abc get 0 hit 0 set 1 del 0\r\nEND\r\n"";
    assert(strcmp(expected, (buf = stats_prefix_dump(&length))) == 0);
    assert(strlen(expected) == length);
    stats_prefix_record_get(""abc:123"", 7, false);
    free(buf);
    expected = ""PREFIX abc get 1 hit 0 set 1 del 0\r\nEND\r\n"";
    assert(strcmp(expected, (buf = stats_prefix_dump(&length))) == 0);
    assert(strlen(expected) == length);
    stats_prefix_record_get(""abc:123"", 7, true);
    free(buf);
    expected = ""PREFIX abc get 2 hit 1 set 1 del 0\r\nEND\r\n"";
    assert(strcmp(expected, (buf = stats_prefix_dump(&length))) == 0);
    assert(strlen(expected) == length);
    stats_pre...",54,,307,2,,void
87388,BLOCK,1,,<empty>,,,,1,,void
87539,BLOCK,-1,,<empty>,5,,352,1,,void
87547,BLOCK,1,,<empty>,,,,1,,void
87552,BLOCK,4,,"{
        snprintf(tmp, sizeof(tmp), ""%d:"", keynum);
        /* -1 because only the prefix portion is used when hashing */
        if (hashval == hash(tmp, strlen(tmp) - 1) % PREFIX_HASH_SIZE) {
            found_match = true;
            break;
        }
    }",65,,352,4,,void
87570,BLOCK,1,,<empty>,,,,1,,void
87572,BLOCK,-1,,"{
            found_match = true;
            break;
        }",71,,355,2,,void
87627,BLOCK,-1,,"{
    uint32_t val;
    assert(safe_strtoul(""123"", &val));
    assert(val == 123);
    assert(safe_strtoul(""+123"", &val));
    assert(val == 123);
    assert(!safe_strtoul("""", &val));  // empty
    assert(!safe_strtoul(""123BOGUS"", &val));  // non-numeric
    assert(!safe_strtoul("" issue221"", &val));  // non-numeric
    /* Not sure what it does, but this works with ICC :/
       assert(!safe_strtoul(""92837498237498237498029383"", &val)); // out of range
    */

    // extremes:
    assert(safe_strtoul(""4294967295"", &val)); // 2**32 - 1
    assert(val == 4294967295L);
    /* This actually works on 64-bit ubuntu
       assert(!safe_strtoul(""4294967296"", &val)); // 2**32
    */
    assert(!safe_strtoul(""-1"", &val));  // negative
    return TEST_PASS;
}",49,,376,2,,void
87686,BLOCK,-1,,"{
    uint64_t val;
    assert(safe_strtoull(""123"", &val));
    assert(val == 123);
    assert(safe_strtoull(""+123"", &val));
    assert(val == 123);
    assert(!safe_strtoull("""", &val));  // empty
    assert(!safe_strtoull(""123BOGUS"", &val));  // non-numeric
    assert(!safe_strtoull(""92837498237498237498029383"", &val)); // out of range
    assert(!safe_strtoull("" issue221"", &val));  // non-numeric

    // extremes:
    assert(safe_strtoull(""18446744073709551615"", &val)); // 2**64 - 1
    assert(val == 18446744073709551615ULL);
    assert(!safe_strtoull(""18446744073709551616"", &val)); // 2**64
    assert(!safe_strtoull(""-1"", &val));  // negative
    return TEST_PASS;
}",50,,400,2,,void
87757,BLOCK,-1,,"{
    int64_t val;
    assert(safe_strtoll(""123"", &val));
    assert(val == 123);
    assert(safe_strtoll(""+123"", &val));
    assert(val == 123);
    assert(safe_strtoll(""-123"", &val));
    assert(val == -123);
    assert(!safe_strtoll("""", &val));  // empty
    assert(!safe_strtoll(""123BOGUS"", &val));  // non-numeric
    assert(!safe_strtoll(""92837498237498237498029383"", &val)); // out of range
    assert(!safe_strtoll("" issue221"", &val));  // non-numeric

    // extremes:
    assert(!safe_strtoll(""18446744073709551615"", &val)); // 2**64 - 1
    assert(safe_strtoll(""9223372036854775807"", &val)); // 2**63 - 1
    assert(val == 9223372036854775807LL);
    /*
      assert(safe_strtoll(""-9223372036854775808"", &val)); // -2**63
      assert(val == -9223372036854775808LL);
    */
    assert(!safe_strtoll(""-9223372036854775809"", &val)); // -2**63 - 1

    // We'll allow space to terminate the string.  And leading space.
    assert(safe_strtoll("" 123 foo"", &val));
    assert(val == 123);
  ...",49,,419,2,,void
87847,BLOCK,-1,,"{
    int32_t val;
    assert(safe_strtol(""123"", &val));
    assert(val == 123);
    assert(safe_strtol(""+123"", &val));
    assert(val == 123);
    assert(safe_strtol(""-123"", &val));
    assert(val == -123);
    assert(!safe_strtol("""", &val));  // empty
    assert(!safe_strtol(""123BOGUS"", &val));  // non-numeric
    assert(!safe_strtol(""92837498237498237498029383"", &val)); // out of range
    assert(!safe_strtol("" issue221"", &val));  // non-numeric

    // extremes:
    /* This actually works on 64-bit ubuntu
       assert(!safe_strtol(""2147483648"", &val)); // (expt 2.0 31.0)
    */
    assert(safe_strtol(""2147483647"", &val)); // (- (expt 2.0 31) 1)
    assert(val == 2147483647L);
    /* This actually works on 64-bit ubuntu
       assert(!safe_strtol(""-2147483649"", &val)); // (- (expt -2.0 31) 1)
    */

    // We'll allow space to terminate the string.  And leading space.
    assert(safe_strtol("" 123 foo"", &val));
    assert(val == 123);
    return TEST_PASS;
}",48,,448,2,,void
87927,BLOCK,-1,,"{
    char environment[80];
    snprintf(environment, sizeof(environment),
             ""MEMCACHED_PORT_FILENAME=/tmp/ports.%lu"", (long)getpid());
    char *filename= environment + strlen(""MEMCACHED_PORT_FILENAME="");
    char pid_file[80];
    snprintf(pid_file, sizeof(pid_file), ""/tmp/pid.%lu"", (long)getpid());

    remove(filename);
    remove(pid_file);

#ifdef __sun
    /* I want to name the corefiles differently so that they don't
       overwrite each other
    */
    char coreadm[128];
    snprintf(coreadm, sizeof(coreadm),
             ""coreadm -p core.%%f.%%p %lu"", (unsigned long)getpid());
    system(coreadm);
#endif

    pid_t pid = fork();
    assert(pid != -1);
    if (pid == 0) {
        /* Child */
        char *argv[24];
        int arg = 0;
        char tmo[24];
        snprintf(tmo, sizeof(tmo), ""%u"", timeout);

        putenv(environment);
#ifdef __sun
        putenv(""LD_PRELOAD=watchmalloc.so.1"");
        putenv(""MALLOC_DEBUG=WATCH"");
#endif

        if (!daemon)...",74,,486,4,,void
87970,BLOCK,-1,,"{
        /* Child */
        char *argv[24];
        int arg = 0;
        char tmo[24];
        snprintf(tmo, sizeof(tmo), ""%u"", timeout);

        putenv(environment);
#ifdef __sun
        putenv(""LD_PRELOAD=watchmalloc.so.1"");
        putenv(""MALLOC_DEBUG=WATCH"");
#endif

        if (!daemon) {
            argv[arg++] = ""./timedrun"";
            argv[arg++] = tmo;
        }
        argv[arg++] = ""./memcached-debug"";
        argv[arg++] = ""-A"";
        argv[arg++] = ""-p"";
        argv[arg++] = ""-1"";
        argv[arg++] = ""-U"";
        argv[arg++] = ""0"";
#ifdef TLS
        if (enable_ssl) {
            argv[arg++] = ""-Z"";
            argv[arg++] = ""-o"";
            argv[arg++] = ""ssl_chain_cert=t/server_crt.pem"";
            argv[arg++] = ""-o"";
            argv[arg++] = ""ssl_key=t/server_key.pem"";
        }
#endif
        /* Handle rpmbuild and the like doing this as root */
        if (getuid() == 0) {
            argv[arg++] = ""-u"";
            argv[arg++] = ""root"";
        }
   ...",19,,509,2,,void
87988,BLOCK,-1,,"{
            argv[arg++] = ""./timedrun"";
            argv[arg++] = tmo;
        }",22,,522,2,,void
88041,BLOCK,-1,,"{
            argv[arg++] = ""-u"";
            argv[arg++] = ""root"";
        }",28,,542,2,,void
88056,BLOCK,-1,,"{
            argv[arg++] = ""-d"";
            argv[arg++] = ""-P"";
            argv[arg++] = pid_file;
        }",21,,546,2,,void
88111,BLOCK,-1,,"{
        usleep(wait);
        wait_timeout -= (wait > wait_timeout ? wait_timeout : wait);
    }",62,,565,2,,void
88129,BLOCK,-1,,"{
        fprintf(stderr, ""Failed to start the memcached server.\n"");
        assert(false);
    }",39,,570,2,,void
88145,BLOCK,-1,,"{
        fprintf(stderr, ""Failed to open the file containing port numbers: %s\n"",
                strerror(errno));
        assert(false);
    }",21,,576,2,,void
88168,BLOCK,-1,,"{
        if (strncmp(buffer, ""TCP INET: "", 10) == 0) {
            int32_t val;
            assert(safe_strtol(buffer + 10, &val));
            *port_out = (in_port_t)val;
        }
    }",57,,584,2,,void
88176,BLOCK,-1,,"{
            int32_t val;
            assert(safe_strtol(buffer + 10, &val));
            *port_out = (in_port_t)val;
        }",53,,585,2,,void
88200,BLOCK,-1,,"{
        /* loop and wait for the pid file.. There is a potential race
         * condition that the server just created the file but isn't
         * finished writing the content, so we loop a few times
         * reading as well */
        while (access(pid_file, F_OK) == -1) {
            usleep(10);
        }

        fp = fopen(pid_file, ""r"");
        if (fp == NULL) {
            fprintf(stderr, ""Failed to open pid file: %s\n"",
                    strerror(errno));
            assert(false);
        }

        /* Avoid race by retrying 20 times */
        for (int x = 0; x < 20 && fgets(buffer, sizeof(buffer), fp) == NULL; x++) {
            usleep(10);
        }
        fclose(fp);

        int32_t val;
        assert(safe_strtol(buffer, &val));
        pid = (pid_t)val;
    }",17,,594,2,,void
88208,BLOCK,-1,,"{
            usleep(10);
        }",46,,599,2,,void
88220,BLOCK,-1,,"{
            fprintf(stderr, ""Failed to open pid file: %s\n"",
                    strerror(errno));
            assert(false);
        }",25,,604,2,,void
88229,BLOCK,-1,,<empty>,9,,611,1,,void
88247,BLOCK,4,,"{
            usleep(10);
        }",83,,611,4,,void
88269,BLOCK,-1,,"{
    in_port_t port;
    pid_t pid = start_server(&port, true, 600);
    assert(kill(pid, SIGHUP) == 0);
    sleep(1);
    assert(kill(pid, SIGTERM) == 0);

    return TEST_PASS;
}",45,,624,2,,void
88300,BLOCK,-1,,"{
    struct addrinfo *ai = 0;
    struct addrinfo hints = { .ai_family = AF_UNSPEC,
                              .ai_protocol = IPPROTO_TCP,
                              .ai_socktype = SOCK_STREAM };
    char service[NI_MAXSERV];
    int error;

    (void)snprintf(service, NI_MAXSERV, ""%d"", port);
    if ((error = getaddrinfo(hostname, service, &hints, &ai)) != 0) {
       if (error != EAI_SYSTEM) {
          fprintf(stderr, ""getaddrinfo(): %s\n"", gai_strerror(error));
       } else {
          perror(""getaddrinfo()"");
       }
    }

    return ai;
}",1,,635,3,,void
88309,BLOCK,1,,<empty>,31,,637,1,,void
88313,BLOCK,2,,<empty>,31,,638,2,,void
88317,BLOCK,3,,<empty>,31,,639,3,,void
88342,BLOCK,-1,,"{
       if (error != EAI_SYSTEM) {
          fprintf(stderr, ""getaddrinfo(): %s\n"", gai_strerror(error));
       } else {
          perror(""getaddrinfo()"");
       }
    }",69,,644,2,,void
88347,BLOCK,-1,,"{
          fprintf(stderr, ""getaddrinfo(): %s\n"", gai_strerror(error));
       }",33,,645,2,,void
88354,BLOCK,-1,,"{
          perror(""getaddrinfo()"");
       }",15,,647,1,,void
88366,BLOCK,-1,,"{
    struct conn *c;
    if (!(c = (struct conn *)calloc(1, sizeof(struct conn)))) {
        fprintf(stderr, ""Failed to allocate the client connection: %s\n"",
                strerror(errno));
        return NULL;
    }

    struct addrinfo *ai = lookuphost(hostname, port);
    int sock = -1;
    if (ai != NULL) {
       if ((sock = socket(ai->ai_family, ai->ai_socktype,
                          ai->ai_protocol)) != -1) {
          if (connect(sock, ai->ai_addr, ai->ai_addrlen) == -1) {
             fprintf(stderr, ""Failed to connect socket: %s\n"",
                     strerror(errno));
             close(sock);
             sock = -1;
          } else if (nonblock) {
              int flags = fcntl(sock, F_GETFL, 0);
              if (flags < 0 || fcntl(sock, F_SETFL, flags | O_NONBLOCK) < 0) {
                  fprintf(stderr, ""Failed to enable nonblocking mode: %s\n"",
                          strerror(errno));
                  close(sock);
                  sock = -1;
       ...",1,,657,5,,void
88378,BLOCK,-1,,"{
        fprintf(stderr, ""Failed to allocate the client connection: %s\n"",
                strerror(errno));
        return NULL;
    }",63,,659,2,,void
88401,BLOCK,-1,,"{
       if ((sock = socket(ai->ai_family, ai->ai_socktype,
                          ai->ai_protocol)) != -1) {
          if (connect(sock, ai->ai_addr, ai->ai_addrlen) == -1) {
             fprintf(stderr, ""Failed to connect socket: %s\n"",
                     strerror(errno));
             close(sock);
             sock = -1;
          } else if (nonblock) {
              int flags = fcntl(sock, F_GETFL, 0);
              if (flags < 0 || fcntl(sock, F_SETFL, flags | O_NONBLOCK) < 0) {
                  fprintf(stderr, ""Failed to enable nonblocking mode: %s\n"",
                          strerror(errno));
                  close(sock);
                  sock = -1;
              }
          }
       } else {
          fprintf(stderr, ""Failed to create socket: %s\n"", strerror(errno));
       }

       freeaddrinfo(ai);
    }",21,,667,2,,void
88418,BLOCK,-1,,"{
          if (connect(sock, ai->ai_addr, ai->ai_addrlen) == -1) {
             fprintf(stderr, ""Failed to connect socket: %s\n"",
                     strerror(errno));
             close(sock);
             sock = -1;
          } else if (nonblock) {
              int flags = fcntl(sock, F_GETFL, 0);
              if (flags < 0 || fcntl(sock, F_SETFL, flags | O_NONBLOCK) < 0) {
                  fprintf(stderr, ""Failed to enable nonblocking mode: %s\n"",
                          strerror(errno));
                  close(sock);
                  sock = -1;
              }
          }
       }",52,,669,2,,void
88431,BLOCK,-1,,"{
             fprintf(stderr, ""Failed to connect socket: %s\n"",
                     strerror(errno));
             close(sock);
             sock = -1;
          }",65,,670,2,,void
88444,BLOCK,-1,,<empty>,18,,675,1,,void
88447,BLOCK,-1,,"{
              int flags = fcntl(sock, F_GETFL, 0);
              if (flags < 0 || fcntl(sock, F_SETFL, flags | O_NONBLOCK) < 0) {
                  fprintf(stderr, ""Failed to enable nonblocking mode: %s\n"",
                          strerror(errno));
                  close(sock);
                  sock = -1;
              }
          }",32,,675,2,,void
88468,BLOCK,-1,,"{
                  fprintf(stderr, ""Failed to enable nonblocking mode: %s\n"",
                          strerror(errno));
                  close(sock);
                  sock = -1;
              }",78,,677,2,,void
88481,BLOCK,-1,,"{
          fprintf(stderr, ""Failed to create socket: %s\n"", strerror(errno));
       }",15,,684,1,,void
88494,BLOCK,9,,"{
        c->read = tcp_read;
        c->write = tcp_write;
    }",5,,722,9,,void
88511,BLOCK,-1,,"{
    int rv = 0;
    int oldstderr = dup(STDERR_FILENO);
    assert(oldstderr >= 0);
    char tmpl[sizeof(TMP_TEMPLATE)+1];
    strncpy(tmpl, TMP_TEMPLATE, sizeof(TMP_TEMPLATE)+1);

    int newfile = mkstemp(tmpl);
    assert(newfile > 0);
    rv = dup2(newfile, STDERR_FILENO);
    assert(rv == STDERR_FILENO);
    rv = close(newfile);
    assert(rv == 0);

    errno = EIO;
    vperror(""Old McDonald had a farm.  %s"", ""EI EIO"");

    /* Restore stderr */
    rv = dup2(oldstderr, STDERR_FILENO);
    assert(rv == STDERR_FILENO);


    /* Go read the file */
    char buf[80] = { 0 };
    FILE *efile = fopen(tmpl, ""r"");
    assert(efile);
    char *prv = fgets(buf, sizeof(buf), efile);
    assert(prv);
    fclose(efile);

    unlink(tmpl);

    char expected[80] = { 0 };
    snprintf(expected, sizeof(expected),
             ""Old McDonald had a farm.  EI EIO: %s\n"", strerror(EIO));

    /*
    fprintf(stderr,
            ""\nExpected:  ``%s''""
            ""\nGot:       ``%s''\n"", expected,...",44,,729,2,,void
88529,BLOCK,1,,<empty>,,,,1,,void
88534,BLOCK,1,,<empty>,,,,1,,void
88630,BLOCK,-1,,"{
    off_t offset = 0;
    const char* ptr = buf;
    size_t len = strlen(buf);

    do {
        ssize_t nw = con->write((void*)con, ptr + offset, len - offset);
        if (nw == -1) {
            if (errno != EINTR) {
                fprintf(stderr, ""Failed to write: %s\n"", strerror(errno));
                abort();
            }
        } else {
            offset += nw;
        }
    } while (offset < len);
}",49,,774,2,,void
88645,BLOCK,-1,,"{
        ssize_t nw = con->write((void*)con, ptr + offset, len - offset);
        if (nw == -1) {
            if (errno != EINTR) {
                fprintf(stderr, ""Failed to write: %s\n"", strerror(errno));
                abort();
            }
        } else {
            offset += nw;
        }
    }",8,,779,1,,void
88667,BLOCK,-1,,"{
            if (errno != EINTR) {
                fprintf(stderr, ""Failed to write: %s\n"", strerror(errno));
                abort();
            }
        }",23,,781,2,,void
88672,BLOCK,-1,,"{
                fprintf(stderr, ""Failed to write: %s\n"", strerror(errno));
                abort();
            }",33,,782,2,,void
88680,BLOCK,-1,,"{
            offset += nw;
        }",16,,786,1,,void
88692,BLOCK,-1,,"{
    off_t offset = 0;
    bool need_more = true;
    do {
        ssize_t nr = con->read(con, buffer + offset, 1);
        if (nr == -1) {
            if (errno != EINTR) {
                fprintf(stderr, ""Failed to read: %s\n"", strerror(errno));
                abort();
            }
        } else {
            assert(nr == 1);
            if (buffer[offset] == '\n') {
                need_more = false;
                buffer[offset + 1] = '\0';
            }
            offset += nr;
            assert(offset + 1 < size);
        }
    } while (need_more);
}",60,,798,3,,void
88702,BLOCK,-1,,"{
        ssize_t nr = con->read(con, buffer + offset, 1);
        if (nr == -1) {
            if (errno != EINTR) {
                fprintf(stderr, ""Failed to read: %s\n"", strerror(errno));
                abort();
            }
        } else {
            assert(nr == 1);
            if (buffer[offset] == '\n') {
                need_more = false;
                buffer[offset + 1] = '\0';
            }
            offset += nr;
            assert(offset + 1 < size);
        }
    }",8,,801,1,,void
88720,BLOCK,-1,,"{
            if (errno != EINTR) {
                fprintf(stderr, ""Failed to read: %s\n"", strerror(errno));
                abort();
            }
        }",23,,803,2,,void
88725,BLOCK,-1,,"{
                fprintf(stderr, ""Failed to read: %s\n"", strerror(errno));
                abort();
            }",33,,804,2,,void
88733,BLOCK,-1,,"{
            assert(nr == 1);
            if (buffer[offset] == '\n') {
                need_more = false;
                buffer[offset + 1] = '\0';
            }
            offset += nr;
            assert(offset + 1 < size);
        }",16,,808,1,,void
88744,BLOCK,-1,,"{
                need_more = false;
                buffer[offset + 1] = '\0';
            }",41,,810,2,,void
88769,BLOCK,-1,,"{
    char buffer[1024];

    close_conn();
    con = connect_server(""127.0.0.1"", port, false, enable_ssl);
    assert(con);

    send_ascii_command(""stats cachedump 1 0 0\r\n"");

    read_ascii_response(buffer, sizeof(buffer));
    assert(strncmp(buffer, ""END"", strlen(""END"")) == 0);

    send_ascii_command(""stats cachedump 200 0 0\r\n"");
    read_ascii_response(buffer, sizeof(buffer));
    assert(strncmp(buffer, ""CLIENT_ERROR"", strlen(""CLIENT_ERROR"")) == 0);

    close_conn();
    con = connect_server(""127.0.0.1"", port, false, enable_ssl);
    assert(con);
    return TEST_PASS;
}",45,,820,2,,void
88825,BLOCK,-1,,"{
    uint32_t crc_hw, crc_sw;

    char buffer[256];
    for (int x = 0; x < 256; x++)
        buffer[x] = x;

    /* Compare hardware to software implementation */
    crc_hw = crc32c(0, buffer, 256);
    crc_sw = crc32c_sw(0, buffer, 256);
    assert(crc_hw == 0x9c44184b);
    assert(crc_sw == 0x9c44184b);

    /* Test that passing a CRC in also works */
    crc_hw = crc32c(crc_hw, buffer, 256);
    crc_sw = crc32c_sw(crc_sw, buffer, 256);
    assert(crc_hw == 0xae10ee5a);
    assert(crc_sw == 0xae10ee5a);

    /* Test odd offsets/sizes */
    crc_hw = crc32c(crc_hw, buffer + 1, 256 - 2);
    crc_sw = crc32c_sw(crc_sw, buffer + 1, 256 - 2);
    assert(crc_hw == 0xed37b906);
    assert(crc_sw == 0xed37b906);

    return TEST_PASS;
}",43,,842,2,,void
88830,BLOCK,-1,,<empty>,5,,846,1,,void
88919,BLOCK,-1,,"{
    char buffer[4096];
    memset(buffer, ' ', sizeof(buffer));
    buffer[sizeof(buffer) - 1] = '\0';

    close_conn();
    con = connect_server(""127.0.0.1"", port, false, enable_ssl);
    assert(con);

    send_ascii_command(buffer);
    /* verify that the server closed the connection */
    assert(con->read(con, buffer, sizeof(buffer)) == 0);

    close_conn();
    con = connect_server(""127.0.0.1"", port, false, enable_ssl);
    assert(con);

    snprintf(buffer, sizeof(buffer), ""gets "");
    size_t offset = 5;
    while (offset < 4000) {
        offset += snprintf(buffer + offset, sizeof(buffer) - offset,
                           ""%010u "", (unsigned int)offset);
    }

    send_ascii_command(buffer);
    usleep(250);

    send_ascii_command(""\r\n"");
    char rsp[80];
    read_ascii_response(rsp, sizeof(rsp));
    assert(strncmp(rsp, ""END"", strlen(""END"")) == 0);
    buffer[3]= ' ';
    send_ascii_command(buffer);
    usleep(250);
    send_ascii_command(""\r\n"");
    read_ascii_...",46,,870,2,,void
88980,BLOCK,-1,,"{
        offset += snprintf(buffer + offset, sizeof(buffer) - offset,
                           ""%010u "", (unsigned int)offset);
    }",27,,889,2,,void
89098,BLOCK,-1,,"{
    server_pid = start_server(&port, false, 600);
    close_conn();
    con = connect_server(""127.0.0.1"", port, false, enable_ssl);
    assert(con);
    return TEST_PASS;
}",54,,923,2,,void
89122,BLOCK,-1,,"{
    close_conn();
    if (server_pid != -1) {
        assert(kill(server_pid, SIGTERM) == 0);
    }

    return TEST_PASS;
}",53,,931,2,,void
89129,BLOCK,-1,,"{
        assert(kill(server_pid, SIGTERM) == 0);
    }",27,,933,2,,void
89142,BLOCK,-1,,"{
    char buffer[1024];

    close_conn();
    con = connect_server(""127.0.0.1"", port, false, enable_ssl);
    assert(con);

    send_ascii_command(""shutdown\r\n"");
    /* verify that the server closed the connection */
    assert(con->read(con, buffer, sizeof(buffer)) == 0);

    close_conn();

    /* We set server_pid to -1 so that we don't later call kill() */
    if (kill(server_pid, 0) == 0) {
        server_pid = -1;
    }

    return TEST_PASS;
}",57,,940,2,,void
89174,BLOCK,-1,,"{
        server_pid = -1;
    }",35,,954,2,,void
89187,BLOCK,-1,,"{
    off_t offset = 0;
    const char* ptr = buf;
#ifdef MESSAGE_DEBUG
    uint8_t val = *ptr;
    assert(val == (uint8_t)0x80);
    fprintf(stderr, ""About to send %lu bytes:"", (unsigned long)len);
    for (int ii = 0; ii < len; ++ii) {
        if (ii % 4 == 0) {
            fprintf(stderr, ""\n   "");
        }
        val = *(ptr + ii);
        fprintf(stderr, "" 0x%02x"", val);
    }
    fprintf(stderr, ""\n"");
    usleep(500);
#endif

    do {
        size_t num_bytes = len - offset;
        if (hickup) {
            if (num_bytes > 1024) {
                num_bytes = (rand() % 1023) + 1;
            }
        }
        ssize_t nw = con->write(con, ptr + offset, num_bytes);
        if (nw == -1) {
            if (errno != EINTR) {
                fprintf(stderr, ""Failed to write: %s\n"", strerror(errno));
                abort();
            }
        } else {
            if (hickup) {
                usleep(100);
            }
            offset += nw;
        }
    } while (offset ...",1,,962,4,,void
89197,BLOCK,-1,,"{
        size_t num_bytes = len - offset;
        if (hickup) {
            if (num_bytes > 1024) {
                num_bytes = (rand() % 1023) + 1;
            }
        }
        ssize_t nw = con->write(con, ptr + offset, num_bytes);
        if (nw == -1) {
            if (errno != EINTR) {
                fprintf(stderr, ""Failed to write: %s\n"", strerror(errno));
                abort();
            }
        } else {
            if (hickup) {
                usleep(100);
            }
            offset += nw;
        }
    }",8,,980,1,,void
89206,BLOCK,-1,,"{
            if (num_bytes > 1024) {
                num_bytes = (rand() % 1023) + 1;
            }
        }",21,,982,2,,void
89211,BLOCK,-1,,"{
                num_bytes = (rand() % 1023) + 1;
            }",35,,983,2,,void
89236,BLOCK,-1,,"{
            if (errno != EINTR) {
                fprintf(stderr, ""Failed to write: %s\n"", strerror(errno));
                abort();
            }
        }",23,,988,2,,void
89241,BLOCK,-1,,"{
                fprintf(stderr, ""Failed to write: %s\n"", strerror(errno));
                abort();
            }",33,,989,2,,void
89249,BLOCK,-1,,"{
            if (hickup) {
                usleep(100);
            }
            offset += nw;
        }",16,,993,1,,void
89252,BLOCK,-1,,"{
                usleep(100);
            }",25,,994,2,,void
89266,BLOCK,-1,,"{
    if (len == 0) {
        return true;
    }
    off_t offset = 0;
    do {
        ssize_t nr = con->read(con, ((char*)buf) + offset, len - offset);
        if (nr == -1) {
            if (errno != EINTR) {
                fprintf(stderr, ""Failed to read: %s\n"", strerror(errno));
                abort();
            }
        } else {
            if (nr == 0 && allow_closed_read) {
                return false;
            }
            assert(nr != 0);
            offset += nr;
        }
    } while (offset < len);

    return true;
}",46,,1002,3,,void
89271,BLOCK,-1,,"{
        return true;
    }",19,,1003,2,,void
89279,BLOCK,-1,,"{
        ssize_t nr = con->read(con, ((char*)buf) + offset, len - offset);
        if (nr == -1) {
            if (errno != EINTR) {
                fprintf(stderr, ""Failed to read: %s\n"", strerror(errno));
                abort();
            }
        } else {
            if (nr == 0 && allow_closed_read) {
                return false;
            }
            assert(nr != 0);
            offset += nr;
        }
    }",8,,1007,1,,void
89301,BLOCK,-1,,"{
            if (errno != EINTR) {
                fprintf(stderr, ""Failed to read: %s\n"", strerror(errno));
                abort();
            }
        }",23,,1009,2,,void
89306,BLOCK,-1,,"{
                fprintf(stderr, ""Failed to read: %s\n"", strerror(errno));
                abort();
            }",33,,1010,2,,void
89314,BLOCK,-1,,"{
            if (nr == 0 && allow_closed_read) {
                return false;
            }
            assert(nr != 0);
            offset += nr;
        }",16,,1014,1,,void
89321,BLOCK,-1,,"{
                return false;
            }",47,,1015,2,,void
89341,BLOCK,-1,,"{
    protocol_binary_response_no_extras *response = buf;
    assert(size > sizeof(*response));
    if (!safe_recv(response, sizeof(*response))) {
        return false;
    }
    response->message.header.response.keylen = ntohs(response->message.header.response.keylen);
    response->message.header.response.status = ntohs(response->message.header.response.status);
    response->message.header.response.bodylen = ntohl(response->message.header.response.bodylen);

    size_t len = sizeof(*response);

    char *ptr = buf;
    ptr += len;
    if (!safe_recv(ptr, response->message.header.response.bodylen)) {
        return false;
    }

#ifdef MESSAGE_DEBUG
    usleep(500);
    ptr = buf;
    len += response->message.header.response.bodylen;
    uint8_t val = *ptr;
    assert(val == (uint8_t)0x81);
    fprintf(stderr, ""Received %lu bytes:"", (unsigned long)len);
    for (int ii = 0; ii < len; ++ii) {
        if (ii % 4 == 0) {
            fprintf(stderr, ""\n   "");
        }
        val = *...",54,,1026,3,,void
89359,BLOCK,-1,,"{
        return false;
    }",50,,1029,2,,void
89448,BLOCK,-1,,"{
        return false;
    }",69,,1040,2,,void
89465,BLOCK,-1,,"{
    /* all of the storage commands use the same command layout */
    protocol_binary_request_set *request = (void*)buf;
    assert(bufsz > sizeof(*request) + keylen + dtalen);

    memset(request, 0, sizeof(*request));
    request->message.header.request.magic = PROTOCOL_BINARY_REQ;
    request->message.header.request.opcode = cmd;
    request->message.header.request.keylen = htons(keylen);
    request->message.header.request.extlen = 8;
    request->message.header.request.bodylen = htonl(keylen + 8 + dtalen);
    request->message.header.request.opaque = 0xdeadbeef;
    request->message.body.flags = flags;
    request->message.body.expiration = exp;

    off_t key_offset = sizeof(protocol_binary_request_no_extras) + 8;

    memcpy(buf + key_offset, key, keylen);
    if (dta != NULL) {
        memcpy(buf + key_offset + keylen, dta, dtalen);
    }

    return key_offset + keylen + dtalen;
}",44,,1071,10,,void
89595,BLOCK,-1,,"{
        memcpy(buf + key_offset + keylen, dta, dtalen);
    }",22,,1089,2,,void
89622,BLOCK,-1,,"{
    protocol_binary_request_no_extras *request = (void*)buf;
    assert(bufsz > sizeof(*request) + extlen + keylen + dtalen);

    memset(request, 0, sizeof(*request));
    request->message.header.request.magic = PROTOCOL_BINARY_REQ;
    request->message.header.request.opcode = cmd;
    request->message.header.request.extlen = extlen;
    request->message.header.request.keylen = htons(keylen);
    request->message.header.request.bodylen = htonl(extlen + keylen + dtalen);
    request->message.header.request.opaque = 0xdeadbeef;

    off_t ext_offset = sizeof(protocol_binary_request_no_extras);
    off_t key_offset = ext_offset + extlen;
    off_t dta_offset = key_offset + keylen;

    if (ext != NULL) {
        memcpy(buf + ext_offset, ext, extlen);
    }
    if (key != NULL) {
        memcpy(buf + key_offset, key, keylen);
    }
    if (dta != NULL) {
        memcpy(buf + dta_offset, dta, dtalen);
    }

    return sizeof(*request) + extlen + keylen + dtalen;
}",41,,1104,10,,void
89740,BLOCK,-1,,"{
        memcpy(buf + ext_offset, ext, extlen);
    }",22,,1120,2,,void
89751,BLOCK,-1,,"{
        memcpy(buf + key_offset, key, keylen);
    }",22,,1123,2,,void
89762,BLOCK,-1,,"{
        memcpy(buf + dta_offset, dta, dtalen);
    }",22,,1126,2,,void
89789,BLOCK,-1,,"{
    /* all of the storage commands use the same command layout */
    return ext_command(buf, bufsz, cmd, NULL, 0, key, keylen, dta, dtalen);
}",41,,1139,8,,void
89809,BLOCK,-1,,"{
    protocol_binary_request_flush *request = (void*)buf;
    assert(bufsz > sizeof(*request));

    memset(request, 0, sizeof(*request));
    request->message.header.request.magic = PROTOCOL_BINARY_REQ;
    request->message.header.request.opcode = cmd;

    off_t size = sizeof(protocol_binary_request_no_extras);
    if (use_extra) {
        request->message.header.request.extlen = 4;
        request->message.body.expiration = htonl(exptime);
        request->message.header.request.bodylen = htonl(4);
        size += 4;
    }

    request->message.header.request.opaque = 0xdeadbeef;

    return size;
}",100,,1144,6,,void
89857,BLOCK,-1,,"{
        request->message.header.request.extlen = 4;
        request->message.body.expiration = htonl(exptime);
        request->message.header.request.bodylen = htonl(4);
        size += 4;
    }",20,,1153,2,,void
89916,BLOCK,-1,,"{
    protocol_binary_request_touch *request = (void*)buf;
    assert(bufsz > sizeof(*request));

    memset(request, 0, sizeof(*request));
    request->message.header.request.magic = PROTOCOL_BINARY_REQ;
    request->message.header.request.opcode = cmd;

    request->message.header.request.keylen = htons(keylen);
    request->message.header.request.extlen = 4;
    request->message.body.expiration = htonl(exptime);
    request->message.header.request.bodylen = htonl(keylen + 4);

    request->message.header.request.opaque = 0xdeadbeef;

    off_t key_offset = sizeof(protocol_binary_request_no_extras) + 4;

    memcpy(buf + key_offset, key, keylen);
    return sizeof(protocol_binary_request_no_extras) + 4 + keylen;
}",46,,1171,7,,void
90046,BLOCK,-1,,"{
    protocol_binary_request_incr *request = (void*)buf;
    assert(bufsz > sizeof(*request) + keylen);

    memset(request, 0, sizeof(*request));
    request->message.header.request.magic = PROTOCOL_BINARY_REQ;
    request->message.header.request.opcode = cmd;
    request->message.header.request.keylen = htons(keylen);
    request->message.header.request.extlen = 20;
    request->message.header.request.bodylen = htonl(keylen + 20);
    request->message.header.request.opaque = 0xdeadbeef;
    request->message.body.delta = htonll(delta);
    request->message.body.initial = htonll(initial);
    request->message.body.expiration = htonl(exp);

    off_t key_offset = sizeof(protocol_binary_request_no_extras) + 20;

    memcpy(buf + key_offset, key, keylen);
    return key_offset + keylen;
}",47,,1199,9,,void
90190,BLOCK,-1,,"{
    assert(response->message.header.response.magic == PROTOCOL_BINARY_RES);
    assert(response->message.header.response.opcode == cmd);
    assert(response->message.header.response.datatype == PROTOCOL_BINARY_RAW_BYTES);
    assert(response->message.header.response.status == status);
    assert(response->message.header.response.opaque == 0xdeadbeef);

    if (status == PROTOCOL_BINARY_RESPONSE_SUCCESS) {
        switch (cmd) {
        case PROTOCOL_BINARY_CMD_ADDQ:
        case PROTOCOL_BINARY_CMD_APPENDQ:
        case PROTOCOL_BINARY_CMD_DECREMENTQ:
        case PROTOCOL_BINARY_CMD_DELETEQ:
        case PROTOCOL_BINARY_CMD_FLUSHQ:
        case PROTOCOL_BINARY_CMD_INCREMENTQ:
        case PROTOCOL_BINARY_CMD_PREPENDQ:
        case PROTOCOL_BINARY_CMD_QUITQ:
        case PROTOCOL_BINARY_CMD_REPLACEQ:
        case PROTOCOL_BINARY_CMD_SETQ:
            assert(""Quiet command shouldn't return on success"" == NULL);
        default:
            break;
        }

        switch (cmd) {
 ...",1,,1222,4,,void
90255,BLOCK,-1,,"{
        switch (cmd) {
        case PROTOCOL_BINARY_CMD_ADDQ:
        case PROTOCOL_BINARY_CMD_APPENDQ:
        case PROTOCOL_BINARY_CMD_DECREMENTQ:
        case PROTOCOL_BINARY_CMD_DELETEQ:
        case PROTOCOL_BINARY_CMD_FLUSHQ:
        case PROTOCOL_BINARY_CMD_INCREMENTQ:
        case PROTOCOL_BINARY_CMD_PREPENDQ:
        case PROTOCOL_BINARY_CMD_QUITQ:
        case PROTOCOL_BINARY_CMD_REPLACEQ:
        case PROTOCOL_BINARY_CMD_SETQ:
            assert(""Quiet command shouldn't return on success"" == NULL);
        default:
            break;
        }

        switch (cmd) {
        case PROTOCOL_BINARY_CMD_ADD:
        case PROTOCOL_BINARY_CMD_REPLACE:
        case PROTOCOL_BINARY_CMD_SET:
        case PROTOCOL_BINARY_CMD_APPEND:
        case PROTOCOL_BINARY_CMD_PREPEND:
            assert(response->message.header.response.keylen == 0);
            assert(response->message.header.response.extlen == 0);
            assert(response->message.header.response.bodylen == 0);
       ...",53,,1229,2,,void
90258,BLOCK,-1,,"{
        case PROTOCOL_BINARY_CMD_ADDQ:
        case PROTOCOL_BINARY_CMD_APPENDQ:
        case PROTOCOL_BINARY_CMD_DECREMENTQ:
        case PROTOCOL_BINARY_CMD_DELETEQ:
        case PROTOCOL_BINARY_CMD_FLUSHQ:
        case PROTOCOL_BINARY_CMD_INCREMENTQ:
        case PROTOCOL_BINARY_CMD_PREPENDQ:
        case PROTOCOL_BINARY_CMD_QUITQ:
        case PROTOCOL_BINARY_CMD_REPLACEQ:
        case PROTOCOL_BINARY_CMD_SETQ:
            assert(""Quiet command shouldn't return on success"" == NULL);
        default:
            break;
        }",22,,1230,2,,void
90287,BLOCK,-1,,"{
        case PROTOCOL_BINARY_CMD_ADD:
        case PROTOCOL_BINARY_CMD_REPLACE:
        case PROTOCOL_BINARY_CMD_SET:
        case PROTOCOL_BINARY_CMD_APPEND:
        case PROTOCOL_BINARY_CMD_PREPEND:
            assert(response->message.header.response.keylen == 0);
            assert(response->message.header.response.extlen == 0);
            assert(response->message.header.response.bodylen == 0);
            assert(response->message.header.response.cas != 0);
            break;
        case PROTOCOL_BINARY_CMD_FLUSH:
        case PROTOCOL_BINARY_CMD_NOOP:
        case PROTOCOL_BINARY_CMD_QUIT:
        case PROTOCOL_BINARY_CMD_DELETE:
            assert(response->message.header.response.keylen == 0);
            assert(response->message.header.response.extlen == 0);
            assert(response->message.header.response.bodylen == 0);
            assert(response->message.header.response.cas == 0);
            break;

        case PROTOCOL_BINARY_CMD_DECREMENT:
        case PROTOCO...",22,,1246,2,,void
90628,BLOCK,-1,,"{
        assert(response->message.header.response.cas == 0);
        assert(response->message.header.response.extlen == 0);
        if (cmd != PROTOCOL_BINARY_CMD_GETK &&
            cmd != PROTOCOL_BINARY_CMD_GATK) {
            assert(response->message.header.response.keylen == 0);
        }
    }",12,,1310,1,,void
90661,BLOCK,-1,,"{
            assert(response->message.header.response.keylen == 0);
        }",46,,1314,2,,void
90678,BLOCK,-1,,"{
    union {
        protocol_binary_request_no_extras request;
        protocol_binary_response_no_extras response;
        char bytes[1024];
    } buffer;

    size_t len = raw_command(buffer.bytes, sizeof(buffer.bytes),
                             PROTOCOL_BINARY_CMD_NOOP,
                             NULL, 0, NULL, 0);

    safe_send(buffer.bytes, len, false);
    safe_recv_packet(buffer.bytes, sizeof(buffer.bytes));
    validate_response_header(&buffer.response, PROTOCOL_BINARY_CMD_NOOP,
                             PROTOCOL_BINARY_RESPONSE_SUCCESS);

    return TEST_PASS;
}",48,,1320,2,,void
90723,BLOCK,-1,,"{
    union {
        protocol_binary_request_no_extras request;
        protocol_binary_response_no_extras response;
        char bytes[1024];
    } buffer;
    size_t len = raw_command(buffer.bytes, sizeof(buffer.bytes),
                             cmd, NULL, 0, NULL, 0);

    safe_send(buffer.bytes, len, false);
    if (cmd == PROTOCOL_BINARY_CMD_QUIT) {
        safe_recv_packet(buffer.bytes, sizeof(buffer.bytes));
        validate_response_header(&buffer.response, PROTOCOL_BINARY_CMD_QUIT,
                                 PROTOCOL_BINARY_RESPONSE_SUCCESS);
    }

    /* Socket should be closed now, read should return 0 */
    assert(con->read(con, buffer.bytes, sizeof(buffer.bytes)) == 0);
    close_conn();
    con = connect_server(""127.0.0.1"", port, false, enable_ssl);
    assert(con);

    return TEST_PASS;
}",60,,1339,2,,void
90751,BLOCK,-1,,"{
        safe_recv_packet(buffer.bytes, sizeof(buffer.bytes));
        validate_response_header(&buffer.response, PROTOCOL_BINARY_CMD_QUIT,
                                 PROTOCOL_BINARY_RESPONSE_SUCCESS);
    }",42,,1349,2,,void
90798,BLOCK,-1,,"{
    return test_binary_quit_impl(PROTOCOL_BINARY_CMD_QUIT);
}",48,,1364,2,,void
90806,BLOCK,-1,,"{
    return test_binary_quit_impl(PROTOCOL_BINARY_CMD_QUITQ);
}",49,,1368,2,,void
90815,BLOCK,-1,,"{
    union {
        protocol_binary_request_no_extras request;
        protocol_binary_response_no_extras response;
        char bytes[1024];
    } send, receive;
    uint64_t value = 0xdeadbeefdeadcafe;
    size_t len = storage_command(send.bytes, sizeof(send.bytes), cmd,
                                 key, strlen(key), &value, sizeof(value),
                                 0, 0);

    /* Set should work over and over again */
    int ii;
    for (ii = 0; ii < 10; ++ii) {
        safe_send(send.bytes, len, false);
        if (cmd == PROTOCOL_BINARY_CMD_SET) {
            safe_recv_packet(receive.bytes, sizeof(receive.bytes));
            validate_response_header(&receive.response, cmd,
                                     PROTOCOL_BINARY_RESPONSE_SUCCESS);
        }
    }

    if (cmd == PROTOCOL_BINARY_CMD_SETQ) {
        return test_binary_noop();
    }

    send.request.message.header.request.cas = receive.response.message.header.response.cas;
    safe_send(send.bytes, len,...",76,,1372,3,,void
90845,BLOCK,-1,,<empty>,5,,1385,1,,void
90854,BLOCK,4,,"{
        safe_send(send.bytes, len, false);
        if (cmd == PROTOCOL_BINARY_CMD_SET) {
            safe_recv_packet(receive.bytes, sizeof(receive.bytes));
            validate_response_header(&receive.response, cmd,
                                     PROTOCOL_BINARY_RESPONSE_SUCCESS);
        }
    }",33,,1385,4,,void
90865,BLOCK,-1,,"{
            safe_recv_packet(receive.bytes, sizeof(receive.bytes));
            validate_response_header(&receive.response, cmd,
                                     PROTOCOL_BINARY_RESPONSE_SUCCESS);
        }",45,,1387,2,,void
90885,BLOCK,-1,,"{
        return test_binary_noop();
    }",42,,1394,2,,void
90921,BLOCK,-1,,"{
        safe_recv_packet(receive.bytes, sizeof(receive.bytes));
        validate_response_header(&receive.response, cmd,
                                 PROTOCOL_BINARY_RESPONSE_SUCCESS);
        assert(receive.response.message.header.response.cas != send.request.message.header.request.cas);
    }",41,,1400,2,,void
90962,BLOCK,-1,,"{
        return test_binary_noop();
    }",12,,1405,1,,void
90971,BLOCK,-1,,"{
    return test_binary_set_impl(""test_binary_set"", PROTOCOL_BINARY_CMD_SET);
}",47,,1412,2,,void
90980,BLOCK,-1,,"{
    return test_binary_set_impl(""test_binary_setq"", PROTOCOL_BINARY_CMD_SETQ);
}",48,,1416,2,,void
90990,BLOCK,-1,,"{
    uint64_t value = 0xdeadbeefdeadcafe;
    union {
        protocol_binary_request_no_extras request;
        protocol_binary_response_no_extras response;
        char bytes[1024];
    } send, receive;
    size_t len = storage_command(send.bytes, sizeof(send.bytes), cmd, key,
                                 strlen(key), &value, sizeof(value),
                                 0, 0);

    /* Add should only work the first time */
    int ii;
    for (ii = 0; ii < 10; ++ii) {
        safe_send(send.bytes, len, false);
        if (ii == 0) {
            if (cmd == PROTOCOL_BINARY_CMD_ADD) {
                safe_recv_packet(receive.bytes, sizeof(receive.bytes));
                validate_response_header(&receive.response, cmd,
                                         PROTOCOL_BINARY_RESPONSE_SUCCESS);
            }
        } else {
            safe_recv_packet(receive.bytes, sizeof(receive.bytes));
            validate_response_header(&receive.response, cmd,
                         ...",76,,1421,3,,void
91020,BLOCK,-1,,<empty>,5,,1434,1,,void
91029,BLOCK,4,,"{
        safe_send(send.bytes, len, false);
        if (ii == 0) {
            if (cmd == PROTOCOL_BINARY_CMD_ADD) {
                safe_recv_packet(receive.bytes, sizeof(receive.bytes));
                validate_response_header(&receive.response, cmd,
                                         PROTOCOL_BINARY_RESPONSE_SUCCESS);
            }
        } else {
            safe_recv_packet(receive.bytes, sizeof(receive.bytes));
            validate_response_header(&receive.response, cmd,
                                     PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS);
        }
    }",33,,1434,4,,void
91040,BLOCK,-1,,"{
            if (cmd == PROTOCOL_BINARY_CMD_ADD) {
                safe_recv_packet(receive.bytes, sizeof(receive.bytes));
                validate_response_header(&receive.response, cmd,
                                         PROTOCOL_BINARY_RESPONSE_SUCCESS);
            }
        }",22,,1436,2,,void
91045,BLOCK,-1,,"{
                safe_recv_packet(receive.bytes, sizeof(receive.bytes));
                validate_response_header(&receive.response, cmd,
                                         PROTOCOL_BINARY_RESPONSE_SUCCESS);
            }",49,,1437,2,,void
91062,BLOCK,-1,,"{
            safe_recv_packet(receive.bytes, sizeof(receive.bytes));
            validate_response_header(&receive.response, cmd,
                                     PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS);
        }",16,,1442,1,,void
91084,BLOCK,-1,,"{
    return test_binary_add_impl(""test_binary_add"", PROTOCOL_BINARY_CMD_ADD);
}",47,,1452,2,,void
91093,BLOCK,-1,,"{
    return test_binary_add_impl(""test_binary_addq"", PROTOCOL_BINARY_CMD_ADDQ);
}",48,,1456,2,,void
91103,BLOCK,-1,,"{
    uint64_t value = 0xdeadbeefdeadcafe;
    union {
        protocol_binary_request_no_extras request;
        protocol_binary_response_no_extras response;
        char bytes[1024];
    } send, receive;
    size_t len = storage_command(send.bytes, sizeof(send.bytes), cmd,
                                 key, strlen(key), &value, sizeof(value),
                                 0, 0);
    safe_send(send.bytes, len, false);
    safe_recv_packet(receive.bytes, sizeof(receive.bytes));
    validate_response_header(&receive.response, cmd,
                             PROTOCOL_BINARY_RESPONSE_KEY_ENOENT);
    len = storage_command(send.bytes, sizeof(send.bytes),
                          PROTOCOL_BINARY_CMD_ADD,
                          key, strlen(key), &value, sizeof(value), 0, 0);
    safe_send(send.bytes, len, false);
    safe_recv_packet(receive.bytes, sizeof(receive.bytes));
    validate_response_header(&receive.response, PROTOCOL_BINARY_CMD_ADD,
                             PROT...",80,,1460,3,,void
91215,BLOCK,-1,,<empty>,5,,1485,1,,void
91224,BLOCK,4,,"{
        safe_send(send.bytes, len, false);
        if (cmd == PROTOCOL_BINARY_CMD_REPLACE) {
            safe_recv_packet(receive.bytes, sizeof(receive.bytes));
            validate_response_header(&receive.response,
                                     PROTOCOL_BINARY_CMD_REPLACE,
                                     PROTOCOL_BINARY_RESPONSE_SUCCESS);
        }
    }",33,,1485,4,,void
91235,BLOCK,-1,,"{
            safe_recv_packet(receive.bytes, sizeof(receive.bytes));
            validate_response_header(&receive.response,
                                     PROTOCOL_BINARY_CMD_REPLACE,
                                     PROTOCOL_BINARY_RESPONSE_SUCCESS);
        }",49,,1487,2,,void
91255,BLOCK,-1,,"{
        test_binary_noop();
    }",46,,1495,2,,void
91263,BLOCK,-1,,"{
    return test_binary_replace_impl(""test_binary_replace"",
                                    PROTOCOL_BINARY_CMD_REPLACE);
}",51,,1502,2,,void
91272,BLOCK,-1,,"{
    return test_binary_replace_impl(""test_binary_replaceq"",
                                    PROTOCOL_BINARY_CMD_REPLACEQ);
}",52,,1507,2,,void
91282,BLOCK,-1,,"{
    union {
        protocol_binary_request_no_extras request;
        protocol_binary_response_no_extras response;
        char bytes[1024];
    } send, receive;
    size_t len = raw_command(send.bytes, sizeof(send.bytes), cmd,
                             key, strlen(key), NULL, 0);

    safe_send(send.bytes, len, false);
    safe_recv_packet(receive.bytes, sizeof(receive.bytes));
    validate_response_header(&receive.response, cmd,
                             PROTOCOL_BINARY_RESPONSE_KEY_ENOENT);
    len = storage_command(send.bytes, sizeof(send.bytes),
                          PROTOCOL_BINARY_CMD_ADD,
                          key, strlen(key), NULL, 0, 0, 0);
    safe_send(send.bytes, len, false);
    safe_recv_packet(receive.bytes, sizeof(receive.bytes));
    validate_response_header(&receive.response, PROTOCOL_BINARY_CMD_ADD,
                             PROTOCOL_BINARY_RESPONSE_SUCCESS);

    len = raw_command(send.bytes, sizeof(send.bytes),
                      cmd, ke...",79,,1512,3,,void
91388,BLOCK,-1,,"{
        safe_recv_packet(receive.bytes, sizeof(receive.bytes));
        validate_response_header(&receive.response, PROTOCOL_BINARY_CMD_DELETE,
                                 PROTOCOL_BINARY_RESPONSE_SUCCESS);
    }",44,,1537,2,,void
91431,BLOCK,-1,,"{
    return test_binary_delete_impl(""test_binary_delete"",
                                   PROTOCOL_BINARY_CMD_DELETE);
}",50,,1551,2,,void
91440,BLOCK,-1,,"{
    return test_binary_delete_impl(""test_binary_deleteq"",
                                   PROTOCOL_BINARY_CMD_DELETEQ);
}",51,,1556,2,,void
91450,BLOCK,-1,,"{
    union {
        protocol_binary_request_no_extras request;
        protocol_binary_response_no_extras response;
        char bytes[1024];
    } send, receive;

    uint32_t expiration = htonl(3600);
    size_t extlen = 0;
    if (cmd == PROTOCOL_BINARY_CMD_GAT || cmd == PROTOCOL_BINARY_CMD_GATK)
        extlen = sizeof(expiration);

    size_t len = ext_command(send.bytes, sizeof(send.bytes), cmd,
                             extlen ? &expiration : NULL, extlen,
                             key, strlen(key), NULL, 0);

    safe_send(send.bytes, len, false);
    safe_recv_packet(receive.bytes, sizeof(receive.bytes));
    validate_response_header(&receive.response, cmd,
                             PROTOCOL_BINARY_RESPONSE_KEY_ENOENT);

    len = storage_command(send.bytes, sizeof(send.bytes),
                          PROTOCOL_BINARY_CMD_ADD,
                          key, strlen(key), NULL, 0,
                          0, 0);
    safe_send(send.bytes, len, false);
    safe_rec...",76,,1561,3,,void
91470,BLOCK,-1,,<empty>,9,,1571,2,,void
91563,BLOCK,-1,,<empty>,5,,1594,1,,void
91572,BLOCK,4,,"{
        union {
            protocol_binary_request_no_extras request;
            char bytes[1024];
        } temp;
        size_t l = ext_command(temp.bytes, sizeof(temp.bytes), cmd,
                               extlen ? &expiration : NULL, extlen,
                               key, strlen(key), NULL, 0);
        memcpy(send.bytes + len, temp.bytes, l);
        len += l;
    }",33,,1594,4,,void
91617,BLOCK,-1,,<empty>,5,,1607,1,,void
91626,BLOCK,4,,"{
        safe_recv_packet(receive.bytes, sizeof(receive.bytes));
        validate_response_header(&receive.response, cmd,
                                 PROTOCOL_BINARY_RESPONSE_SUCCESS);
    }",33,,1607,4,,void
91648,BLOCK,-1,,"{
    return test_binary_get_impl(""test_binary_get"", PROTOCOL_BINARY_CMD_GET);
}",47,,1616,2,,void
91657,BLOCK,-1,,"{
    return test_binary_get_impl(""test_binary_getk"", PROTOCOL_BINARY_CMD_GETK);
}",48,,1620,2,,void
91666,BLOCK,-1,,"{
    return test_binary_get_impl(""test_binary_gat"", PROTOCOL_BINARY_CMD_GAT);
}",47,,1624,2,,void
91675,BLOCK,-1,,"{
    return test_binary_get_impl(""test_binary_gatk"", PROTOCOL_BINARY_CMD_GATK);
}",48,,1628,2,,void
91685,BLOCK,-1,,"{
    const char *missing = ""test_binary_getq_missing"";
    union {
        protocol_binary_request_no_extras request;
        protocol_binary_response_no_extras response;
        char bytes[1024];
    } send, temp, receive;

    uint32_t expiration = htonl(3600);
    size_t extlen = 0;
    if (cmd == PROTOCOL_BINARY_CMD_GATQ || cmd == PROTOCOL_BINARY_CMD_GATKQ)
        extlen = sizeof(expiration);

    size_t len = storage_command(send.bytes, sizeof(send.bytes),
                                 PROTOCOL_BINARY_CMD_ADD,
                                 key, strlen(key), NULL, 0,
                                 0, 0);
    size_t len2 = ext_command(temp.bytes, sizeof(temp.bytes), cmd,
                              extlen ? &expiration : NULL, extlen,
                              missing, strlen(missing), NULL, 0);
    /* I need to change the first opaque so that I can separate the two
     * return packets */
    temp.request.message.header.request.opaque = 0xfeedface;
    memcpy(se...",77,,1632,3,,void
91710,BLOCK,-1,,<empty>,9,,1643,2,,void
91860,BLOCK,-1,,"{
    return test_binary_getq_impl(""test_binary_getq"", PROTOCOL_BINARY_CMD_GETQ);
}",48,,1676,2,,void
91869,BLOCK,-1,,"{
    return test_binary_getq_impl(""test_binary_getkq"", PROTOCOL_BINARY_CMD_GETKQ);
}",49,,1680,2,,void
91878,BLOCK,-1,,"{
    return test_binary_getq_impl(""test_binary_gatq"", PROTOCOL_BINARY_CMD_GATQ);
}",48,,1684,2,,void
91887,BLOCK,-1,,"{
    return test_binary_getq_impl(""test_binary_gatkq"", PROTOCOL_BINARY_CMD_GATKQ);
}",49,,1688,2,,void
91897,BLOCK,-1,,"{
    union {
        protocol_binary_request_no_extras request;
        protocol_binary_response_no_extras response_header;
        protocol_binary_response_incr response;
        char bytes[1024];
    } send, receive;
    size_t len = arithmetic_command(send.bytes, sizeof(send.bytes), cmd,
                                    key, strlen(key), 1, 0, 0);

    int ii;
    for (ii = 0; ii < 10; ++ii) {
        safe_send(send.bytes, len, false);
        if (cmd == PROTOCOL_BINARY_CMD_INCREMENT) {
            safe_recv_packet(receive.bytes, sizeof(receive.bytes));
            validate_response_header(&receive.response_header, cmd,
                                     PROTOCOL_BINARY_RESPONSE_SUCCESS);
            assert(ntohll(receive.response.message.body.value) == ii);
        }
    }

    if (cmd == PROTOCOL_BINARY_CMD_INCREMENTQ) {
        test_binary_noop();
    }
    return TEST_PASS;
}",77,,1692,3,,void
91920,BLOCK,-1,,<empty>,5,,1703,1,,void
91929,BLOCK,4,,"{
        safe_send(send.bytes, len, false);
        if (cmd == PROTOCOL_BINARY_CMD_INCREMENT) {
            safe_recv_packet(receive.bytes, sizeof(receive.bytes));
            validate_response_header(&receive.response_header, cmd,
                                     PROTOCOL_BINARY_RESPONSE_SUCCESS);
            assert(ntohll(receive.response.message.body.value) == ii);
        }
    }",33,,1703,4,,void
91940,BLOCK,-1,,"{
            safe_recv_packet(receive.bytes, sizeof(receive.bytes));
            validate_response_header(&receive.response_header, cmd,
                                     PROTOCOL_BINARY_RESPONSE_SUCCESS);
            assert(ntohll(receive.response.message.body.value) == ii);
        }",51,,1705,2,,void
91973,BLOCK,-1,,"{
        test_binary_noop();
    }",48,,1713,2,,void
91981,BLOCK,-1,,"{
    return test_binary_incr_impl(""test_binary_incr"",
                                 PROTOCOL_BINARY_CMD_INCREMENT);
}",48,,1719,2,,void
91990,BLOCK,-1,,"{
    return test_binary_incr_impl(""test_binary_incrq"",
                                 PROTOCOL_BINARY_CMD_INCREMENTQ);
}",49,,1724,2,,void
92000,BLOCK,-1,,"{
    union {
        protocol_binary_request_no_extras request;
        protocol_binary_response_no_extras response_header;
        protocol_binary_response_decr response;
        char bytes[1024];
    } send, receive;
    size_t len = arithmetic_command(send.bytes, sizeof(send.bytes), cmd,
                                    key, strlen(key), 1, 9, 0);

    int ii;
    for (ii = 9; ii >= 0; --ii) {
        safe_send(send.bytes, len, false);
        if (cmd == PROTOCOL_BINARY_CMD_DECREMENT) {
            safe_recv_packet(receive.bytes, sizeof(receive.bytes));
            validate_response_header(&receive.response_header, cmd,
                                     PROTOCOL_BINARY_RESPONSE_SUCCESS);
            assert(ntohll(receive.response.message.body.value) == ii);
        }
    }

    /* decr on 0 should not wrap */
    safe_send(send.bytes, len, false);
    if (cmd == PROTOCOL_BINARY_CMD_DECREMENT) {
        safe_recv_packet(receive.bytes, sizeof(receive.bytes));
        validat...",77,,1729,3,,void
92023,BLOCK,-1,,<empty>,5,,1740,1,,void
92032,BLOCK,4,,"{
        safe_send(send.bytes, len, false);
        if (cmd == PROTOCOL_BINARY_CMD_DECREMENT) {
            safe_recv_packet(receive.bytes, sizeof(receive.bytes));
            validate_response_header(&receive.response_header, cmd,
                                     PROTOCOL_BINARY_RESPONSE_SUCCESS);
            assert(ntohll(receive.response.message.body.value) == ii);
        }
    }",33,,1740,4,,void
92043,BLOCK,-1,,"{
            safe_recv_packet(receive.bytes, sizeof(receive.bytes));
            validate_response_header(&receive.response_header, cmd,
                                     PROTOCOL_BINARY_RESPONSE_SUCCESS);
            assert(ntohll(receive.response.message.body.value) == ii);
        }",51,,1742,2,,void
92082,BLOCK,-1,,"{
        safe_recv_packet(receive.bytes, sizeof(receive.bytes));
        validate_response_header(&receive.response_header, cmd,
                                 PROTOCOL_BINARY_RESPONSE_SUCCESS);
        assert(ntohll(receive.response.message.body.value) == 0);
    }",47,,1752,2,,void
92112,BLOCK,-1,,"{
        test_binary_noop();
    }",12,,1757,1,,void
92120,BLOCK,-1,,"{
    return test_binary_decr_impl(""test_binary_decr"",
                                 PROTOCOL_BINARY_CMD_DECREMENT);
}",48,,1764,2,,void
92129,BLOCK,-1,,"{
    return test_binary_decr_impl(""test_binary_decrq"",
                                 PROTOCOL_BINARY_CMD_DECREMENTQ);
}",49,,1769,2,,void
92138,BLOCK,-1,,"{
    union {
        protocol_binary_request_no_extras request;
        protocol_binary_response_no_extras response;
        char bytes[1024];
    } buffer;

    size_t len = raw_command(buffer.bytes, sizeof(buffer.bytes),
                             PROTOCOL_BINARY_CMD_VERSION,
                             NULL, 0, NULL, 0);

    safe_send(buffer.bytes, len, false);
    safe_recv_packet(buffer.bytes, sizeof(buffer.bytes));
    validate_response_header(&buffer.response, PROTOCOL_BINARY_CMD_VERSION,
                             PROTOCOL_BINARY_RESPONSE_SUCCESS);

    return TEST_PASS;
}",51,,1774,2,,void
92184,BLOCK,-1,,"{
    union {
        protocol_binary_request_no_extras request;
        protocol_binary_response_no_extras response;
        char bytes[1024];
    } send, receive;

    size_t len = storage_command(send.bytes, sizeof(send.bytes),
                                 PROTOCOL_BINARY_CMD_ADD,
                                 key, strlen(key), NULL, 0, 0, 0);
    safe_send(send.bytes, len, false);
    safe_recv_packet(receive.bytes, sizeof(receive.bytes));
    validate_response_header(&receive.response, PROTOCOL_BINARY_CMD_ADD,
                             PROTOCOL_BINARY_RESPONSE_SUCCESS);

    len = flush_command(send.bytes, sizeof(send.bytes), cmd, 2, true);
    safe_send(send.bytes, len, false);
    if (cmd == PROTOCOL_BINARY_CMD_FLUSH) {
        safe_recv_packet(receive.bytes, sizeof(receive.bytes));
        validate_response_header(&receive.response, cmd,
                                 PROTOCOL_BINARY_RESPONSE_SUCCESS);
    }

    len = raw_command(send.bytes, sizeof(send.bytes), ...",78,,1793,3,,void
92250,BLOCK,-1,,"{
        safe_recv_packet(receive.bytes, sizeof(receive.bytes));
        validate_response_header(&receive.response, cmd,
                                 PROTOCOL_BINARY_RESPONSE_SUCCESS);
    }",43,,1810,2,,void
92328,BLOCK,-1,,<empty>,5,,1830,1,,void
92337,BLOCK,4,,"{
        len = storage_command(send.bytes, sizeof(send.bytes),
                              PROTOCOL_BINARY_CMD_ADD,
                              key, strlen(key), NULL, 0, 0, 0);
        safe_send(send.bytes, len, false);
        safe_recv_packet(receive.bytes, sizeof(receive.bytes));
        validate_response_header(&receive.response, PROTOCOL_BINARY_CMD_ADD,
                                 PROTOCOL_BINARY_RESPONSE_SUCCESS);

        len = flush_command(send.bytes, sizeof(send.bytes), cmd, 0, ii == 0);
        safe_send(send.bytes, len, false);
        if (cmd == PROTOCOL_BINARY_CMD_FLUSH) {
            safe_recv_packet(receive.bytes, sizeof(receive.bytes));
            validate_response_header(&receive.response, cmd,
                                     PROTOCOL_BINARY_RESPONSE_SUCCESS);
        }

        len = raw_command(send.bytes, sizeof(send.bytes),
                          PROTOCOL_BINARY_CMD_GET,
                          key, strlen(key), NULL, 0);
        safe_send...",32,,1830,4,,void
92402,BLOCK,-1,,"{
            safe_recv_packet(receive.bytes, sizeof(receive.bytes));
            validate_response_header(&receive.response, cmd,
                                     PROTOCOL_BINARY_RESPONSE_SUCCESS);
        }",47,,1841,2,,void
92461,BLOCK,-1,,"{
    return test_binary_flush_impl(""test_binary_flush"",
                                  PROTOCOL_BINARY_CMD_FLUSH);
}",49,,1859,2,,void
92470,BLOCK,-1,,"{
    return test_binary_flush_impl(""test_binary_flushq"",
                                  PROTOCOL_BINARY_CMD_FLUSHQ);
}",50,,1864,2,,void
92480,BLOCK,-1,,"{
    union {
        protocol_binary_request_no_extras request;
        protocol_binary_response_no_extras response;
        char bytes[1024];
    } send, receive;
    const char *value = ""world"";

    size_t len = raw_command(send.bytes, sizeof(send.bytes), cmd,
                              key, strlen(key), value, strlen(value));


    safe_send(send.bytes, len, false);
    safe_recv_packet(receive.bytes, sizeof(receive.bytes));
    validate_response_header(&receive.response, cmd,
                             PROTOCOL_BINARY_RESPONSE_NOT_STORED);

    len = storage_command(send.bytes, sizeof(send.bytes),
                          PROTOCOL_BINARY_CMD_ADD,
                          key, strlen(key), value, strlen(value), 0, 0);
    safe_send(send.bytes, len, false);
    safe_recv_packet(receive.bytes, sizeof(receive.bytes));
    validate_response_header(&receive.response, PROTOCOL_BINARY_CMD_ADD,
                             PROTOCOL_BINARY_RESPONSE_SUCCESS);

    len = raw_comman...",79,,1869,3,,void
92597,BLOCK,-1,,"{
        safe_recv_packet(receive.bytes, sizeof(receive.bytes));
        validate_response_header(&receive.response, cmd,
                                 PROTOCOL_BINARY_RESPONSE_SUCCESS);
    }",82,,1898,2,,void
92614,BLOCK,-1,,"{
        len = raw_command(send.bytes, sizeof(send.bytes), PROTOCOL_BINARY_CMD_NOOP,
                          NULL, 0, NULL, 0);
        safe_send(send.bytes, len, false);
        safe_recv_packet(receive.bytes, sizeof(receive.bytes));
        validate_response_header(&receive.response, PROTOCOL_BINARY_CMD_NOOP,
                                 PROTOCOL_BINARY_RESPONSE_SUCCESS);
    }",12,,1902,1,,void
92778,BLOCK,-1,,"{
    return test_binary_concat_impl(""test_binary_append"",
                                   PROTOCOL_BINARY_CMD_APPEND);
}",50,,1935,2,,void
92787,BLOCK,-1,,"{
    return test_binary_concat_impl(""test_binary_prepend"",
                                   PROTOCOL_BINARY_CMD_PREPEND);
}",51,,1940,2,,void
92796,BLOCK,-1,,"{
    return test_binary_concat_impl(""test_binary_appendq"",
                                   PROTOCOL_BINARY_CMD_APPENDQ);
}",51,,1945,2,,void
92805,BLOCK,-1,,"{
    return test_binary_concat_impl(""test_binary_prependq"",
                                   PROTOCOL_BINARY_CMD_PREPENDQ);
}",52,,1950,2,,void
92814,BLOCK,-1,,"{
    union {
        protocol_binary_request_no_extras request;
        protocol_binary_response_no_extras response;
        char bytes[1024];
    } buffer;

    size_t len = raw_command(buffer.bytes, sizeof(buffer.bytes),
                             PROTOCOL_BINARY_CMD_STAT,
                             NULL, 0, NULL, 0);

    safe_send(buffer.bytes, len, false);
    do {
        safe_recv_packet(buffer.bytes, sizeof(buffer.bytes));
        validate_response_header(&buffer.response, PROTOCOL_BINARY_CMD_STAT,
                                 PROTOCOL_BINARY_RESPONSE_SUCCESS);
    } while (buffer.response.message.header.response.keylen != 0);

    return TEST_PASS;
}",48,,1955,2,,void
92839,BLOCK,-1,,"{
        safe_recv_packet(buffer.bytes, sizeof(buffer.bytes));
        validate_response_header(&buffer.response, PROTOCOL_BINARY_CMD_STAT,
                                 PROTOCOL_BINARY_RESPONSE_SUCCESS);
    }",8,,1967,1,,void
92874,BLOCK,-1,,"{
    uint8_t cmd = 0x25;
    while (cmd != 0x00) {
        union {
            protocol_binary_request_no_extras request;
            protocol_binary_response_no_extras response;
            char bytes[1024];
        } buffer;
        size_t len = raw_command(buffer.bytes, sizeof(buffer.bytes),
                                 cmd, NULL, 0, NULL, 0);
        safe_send(buffer.bytes, len, false);
        safe_recv_packet(buffer.bytes, sizeof(buffer.bytes));
        validate_response_header(&buffer.response, cmd,
                                 PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND);
        ++cmd;
    }

    return TEST_PASS;
}",51,,1976,2,,void
92883,BLOCK,-1,,"{
        union {
            protocol_binary_request_no_extras request;
            protocol_binary_response_no_extras response;
            char bytes[1024];
        } buffer;
        size_t len = raw_command(buffer.bytes, sizeof(buffer.bytes),
                                 cmd, NULL, 0, NULL, 0);
        safe_send(buffer.bytes, len, false);
        safe_recv_packet(buffer.bytes, sizeof(buffer.bytes));
        validate_response_header(&buffer.response, cmd,
                                 PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND);
        ++cmd;
    }",25,,1978,2,,void
92931,BLOCK,-1,,"{
    protocol_binary_response_no_extras *response = malloc(65*1024);
    if (response != NULL) {
        while (safe_recv_packet(response, 65*1024)) {
            /* Just validate the packet format */
            validate_response_header(response,
                                     response->message.header.response.opcode,
                                     response->message.header.response.status);
        }
        free(response);
    }
    hickup_thread_running = false;
    allow_closed_read = false;
    return NULL;
}",64,,1998,2,,void
92943,BLOCK,-1,,"{
        while (safe_recv_packet(response, 65*1024)) {
            /* Just validate the packet format */
            validate_response_header(response,
                                     response->message.header.response.opcode,
                                     response->message.header.response.status);
        }
        free(response);
    }",27,,2000,2,,void
92950,BLOCK,-1,,"{
            /* Just validate the packet format */
            validate_response_header(response,
                                     response->message.header.response.opcode,
                                     response->message.header.response.status);
        }",53,,2001,2,,void
92986,BLOCK,-1,,"{
    off_t offset = 0;
    char *key[256] = { NULL };
    uint64_t value = 0xfeedfacedeadbeef;

    while (hickup_thread_running &&
           offset + sizeof(protocol_binary_request_no_extras) < buffersize) {
        union {
            protocol_binary_request_no_extras request;
            char bytes[65 * 1024];
        } command;
        uint8_t cmd = (uint8_t)(rand() & 0xff);
        size_t len;
        size_t keylen = (rand() % 250) + 1;

        switch (cmd) {
        case PROTOCOL_BINARY_CMD_ADD:
        case PROTOCOL_BINARY_CMD_ADDQ:
        case PROTOCOL_BINARY_CMD_REPLACE:
        case PROTOCOL_BINARY_CMD_REPLACEQ:
        case PROTOCOL_BINARY_CMD_SET:
        case PROTOCOL_BINARY_CMD_SETQ:
            len = storage_command(command.bytes, sizeof(command.bytes), cmd,
                                  key, keylen , &value, sizeof(value),
                                  0, 0);
            break;
        case PROTOCOL_BINARY_CMD_APPEND:
        case PROTOCOL_BINARY_CMD_APPE...",92,,2014,3,,void
93009,BLOCK,-1,,"{
        union {
            protocol_binary_request_no_extras request;
            char bytes[65 * 1024];
        } command;
        uint8_t cmd = (uint8_t)(rand() & 0xff);
        size_t len;
        size_t keylen = (rand() % 250) + 1;

        switch (cmd) {
        case PROTOCOL_BINARY_CMD_ADD:
        case PROTOCOL_BINARY_CMD_ADDQ:
        case PROTOCOL_BINARY_CMD_REPLACE:
        case PROTOCOL_BINARY_CMD_REPLACEQ:
        case PROTOCOL_BINARY_CMD_SET:
        case PROTOCOL_BINARY_CMD_SETQ:
            len = storage_command(command.bytes, sizeof(command.bytes), cmd,
                                  key, keylen , &value, sizeof(value),
                                  0, 0);
            break;
        case PROTOCOL_BINARY_CMD_APPEND:
        case PROTOCOL_BINARY_CMD_APPENDQ:
        case PROTOCOL_BINARY_CMD_PREPEND:
        case PROTOCOL_BINARY_CMD_PREPENDQ:
            len = raw_command(command.bytes, sizeof(command.bytes), cmd,
                              key, keylen, &va...",77,,2020,2,,void
93029,BLOCK,-1,,"{
        case PROTOCOL_BINARY_CMD_ADD:
        case PROTOCOL_BINARY_CMD_ADDQ:
        case PROTOCOL_BINARY_CMD_REPLACE:
        case PROTOCOL_BINARY_CMD_REPLACEQ:
        case PROTOCOL_BINARY_CMD_SET:
        case PROTOCOL_BINARY_CMD_SETQ:
            len = storage_command(command.bytes, sizeof(command.bytes), cmd,
                                  key, keylen , &value, sizeof(value),
                                  0, 0);
            break;
        case PROTOCOL_BINARY_CMD_APPEND:
        case PROTOCOL_BINARY_CMD_APPENDQ:
        case PROTOCOL_BINARY_CMD_PREPEND:
        case PROTOCOL_BINARY_CMD_PREPENDQ:
            len = raw_command(command.bytes, sizeof(command.bytes), cmd,
                              key, keylen, &value, sizeof(value));
            break;
        case PROTOCOL_BINARY_CMD_FLUSH:
        case PROTOCOL_BINARY_CMD_FLUSHQ:
            len = raw_command(command.bytes, sizeof(command.bytes), cmd,
                              NULL, 0, NULL, 0);
            break;...",22,,2029,2,,void
93291,BLOCK,-1,,"{
            memcpy(((char*)buffer) + offset, command.bytes, len);
            offset += len;
        }",42,,2110,2,,void
93306,BLOCK,-1,,"{
            break;
        }",16,,2113,1,,void
93318,BLOCK,-1,,"{
    size_t buffersize = 65 * 1024;
    void *buffer = malloc(buffersize);
    int ii;

    pthread_t tid;
    int ret;
    allow_closed_read = true;
    hickup_thread_running = true;
    if ((ret = pthread_create(&tid, NULL,
                              binary_hickup_recv_verification_thread, NULL)) != 0) {
        fprintf(stderr, ""Can't create thread: %s\n"", strerror(ret));
        free(buffer);
        return TEST_FAIL;
    }

    /* Allow the thread to start */
    usleep(250);

    srand((int)time(NULL));
    for (ii = 0; ii < 2; ++ii) {
        test_binary_pipeline_hickup_chunk(buffer, buffersize);
    }

    /* send quitq to shut down the read thread ;-) */
    size_t len = raw_command(buffer, buffersize, PROTOCOL_BINARY_CMD_QUITQ,
                             NULL, 0, NULL, 0);
    safe_send(buffer, len, false);

    pthread_join(tid, NULL);
    free(buffer);
    return TEST_PASS;
}",1,,2123,2,,void
93350,BLOCK,-1,,"{
        fprintf(stderr, ""Can't create thread: %s\n"", strerror(ret));
        free(buffer);
        return TEST_FAIL;
    }",84,,2133,2,,void
93368,BLOCK,-1,,<empty>,5,,2143,1,,void
93377,BLOCK,4,,"{
        test_binary_pipeline_hickup_chunk(buffer, buffersize);
    }",32,,2143,4,,void
93407,BLOCK,-1,,"{
    enum { max = 2 };
    enum test_return ret = TEST_PASS;
    struct conn *conns[max];
    int ii = 0;
    pid_t child = 0;

    if (getenv(""SKIP_TEST_101"") != NULL) {
        return TEST_SKIP;
    }

    const char *command = ""stats\r\nstats\r\nstats\r\nstats\r\nstats\r\n"";
    size_t cmdlen = strlen(command);

    server_pid = start_server(&port, false, 1000);

    for (ii = 0; ii < max; ++ii) {
        conns[ii] = NULL;
        conns[ii] = connect_server(""127.0.0.1"", port, true, enable_ssl);
        assert(conns[ii]);
        assert(conns[ii]->sock > 0);
    }

    /* Send command on the connection until it blocks */
    for (ii = 0; ii < max; ++ii) {
        bool more = true;
        do {
            ssize_t err = conns[ii]->write(conns[ii], command, cmdlen);
            if (err == -1) {
                switch (errno) {
                case EINTR:
                    break;
                case ENOMEM:
                case EWOULDBLOCK:
                    more = false;
     ...",46,,2158,2,,void
93426,BLOCK,-1,,"{
        return TEST_SKIP;
    }",42,,2165,2,,void
93446,BLOCK,-1,,<empty>,5,,2174,1,,void
93455,BLOCK,4,,"{
        conns[ii] = NULL;
        conns[ii] = connect_server(""127.0.0.1"", port, true, enable_ssl);
        assert(conns[ii]);
        assert(conns[ii]->sock > 0);
    }",34,,2174,4,,void
93483,BLOCK,-1,,<empty>,5,,2182,1,,void
93492,BLOCK,4,,"{
        bool more = true;
        do {
            ssize_t err = conns[ii]->write(conns[ii], command, cmdlen);
            if (err == -1) {
                switch (errno) {
                case EINTR:
                    break;
                case ENOMEM:
                case EWOULDBLOCK:
                    more = false;
                    break;
                default:
                    ret = TEST_FAIL;
                    goto cleanup;
                }
            }
        } while (more);
    }",34,,2182,4,,void
93498,BLOCK,-1,,"{
            ssize_t err = conns[ii]->write(conns[ii], command, cmdlen);
            if (err == -1) {
                switch (errno) {
                case EINTR:
                    break;
                case ENOMEM:
                case EWOULDBLOCK:
                    more = false;
                    break;
                default:
                    ret = TEST_FAIL;
                    goto cleanup;
                }
            }
        }",12,,2184,1,,void
93518,BLOCK,-1,,"{
                switch (errno) {
                case EINTR:
                    break;
                case ENOMEM:
                case EWOULDBLOCK:
                    more = false;
                    break;
                default:
                    ret = TEST_FAIL;
                    goto cleanup;
                }
            }",28,,2186,2,,void
93521,BLOCK,-1,,"{
                case EINTR:
                    break;
                case ENOMEM:
                case EWOULDBLOCK:
                    more = false;
                    break;
                default:
                    ret = TEST_FAIL;
                    goto cleanup;
                }",32,,2187,2,,void
93548,BLOCK,-1,,"{
        abort();
    }",29,,2203,2,,void
93551,BLOCK,-1,,<empty>,12,,2205,1,,void
93556,BLOCK,-1,,"{
        int stat;
        pid_t c;
        while ((c = waitpid(child, &stat, 0)) == (pid_t)-1 && errno == EINTR);
        assert(c == child);
        assert(stat == 0);
    }",27,,2205,2,,void
93584,BLOCK,-1,,"{
        con = connect_server(""127.0.0.1"", port, false, enable_ssl);
        assert(con);
        ret = test_binary_noop();
        close_conn();
        exit(0);
    }",12,,2211,1,,void
93602,BLOCK,-1,,<empty>,5,,2221,1,,void
93611,BLOCK,4,,"{
        struct conn *c = conns[ii];
        if (c == NULL) continue;
#ifdef TLS
        if (c->ssl) {
            SSL_shutdown(c->ssl);
            SSL_free(c->ssl);
        }
        if (c->ssl_ctx)
            SSL_CTX_free(c->ssl_ctx);
#endif
        if (c->sock > 0) close(c->sock);
        free(conns[ii]);
        conns[ii] = NULL;
    }",34,,2221,4,,void
93622,BLOCK,-1,,<empty>,24,,2223,2,,void
93630,BLOCK,-1,,<empty>,26,,2232,2,,void
93837,BLOCK,-1,,<empty>,,,,2,,<empty>
93842,BLOCK,-1,,<empty>,,,,2,,<empty>
93847,BLOCK,-1,,<empty>,1,,2313,2,,void
93852,BLOCK,-1,,<empty>,1,,2315,2,,void
93858,BLOCK,-1,,"{
    int exitcode = 0;
    int ii = 0, num_cases = 0;
#ifdef TLS
    if (getenv(""SSL_TEST"") != NULL) {
        SSLeay_add_ssl_algorithms();
        SSL_load_error_strings();
        enable_ssl = true;
    }
#endif
    /* Initialized directly instead of using hash_init to avoid pulling in
       the definition of settings struct from memcached.h */
    hash = jenkins_hash;
    stats_prefix_init(':');

    crc32c_init();

    for (num_cases = 0; testcases[num_cases].description; num_cases++) {
        /* Just counting */
    }

    printf(""1..%d\n"", num_cases);

    for (ii = 0; testcases[ii].description != NULL; ++ii) {
        fflush(stdout);
#ifndef DEBUG
        /* the test program shouldn't run longer than 10 minutes... */
        alarm(600);
#endif
        enum test_return ret = testcases[ii].function();
        if (ret == TEST_SKIP) {
            fprintf(stdout, ""ok # SKIP %d - %s\n"", ii + 1, testcases[ii].description);
        } else if (ret == TEST_PASS) {
            fprint...",1,,2318,3,,void
93878,BLOCK,-1,,<empty>,5,,2335,1,,void
93889,BLOCK,4,,"{
        /* Just counting */
    }",72,,2335,4,,void
93894,BLOCK,-1,,<empty>,5,,2341,1,,void
93907,BLOCK,4,,"{
        fflush(stdout);
#ifndef DEBUG
        /* the test program shouldn't run longer than 10 minutes... */
        alarm(600);
#endif
        enum test_return ret = testcases[ii].function();
        if (ret == TEST_SKIP) {
            fprintf(stdout, ""ok # SKIP %d - %s\n"", ii + 1, testcases[ii].description);
        } else if (ret == TEST_PASS) {
            fprintf(stdout, ""ok %d - %s\n"", ii + 1, testcases[ii].description);
        } else {
            fprintf(stdout, ""not ok %d - %s\n"", ii + 1, testcases[ii].description);
            exitcode = 1;
        }
        fflush(stdout);
    }",59,,2341,4,,void
93925,BLOCK,-1,,"{
            fprintf(stdout, ""ok # SKIP %d - %s\n"", ii + 1, testcases[ii].description);
        }",31,,2348,2,,void
93938,BLOCK,-1,,<empty>,16,,2350,1,,void
93943,BLOCK,-1,,"{
            fprintf(stdout, ""ok %d - %s\n"", ii + 1, testcases[ii].description);
        }",38,,2350,2,,void
93956,BLOCK,-1,,"{
            fprintf(stdout, ""not ok %d - %s\n"", ii + 1, testcases[ii].description);
            exitcode = 1;
        }",16,,2352,1,,void
94007,BLOCK,-1,,<empty>,1,,1,1,,ANY
94051,BLOCK,1,,<empty>,,,,1,,void
94079,BLOCK,-1,,<empty>,,,,3,,<empty>
94086,BLOCK,-1,,<empty>,,,,4,,<empty>
94091,BLOCK,-1,,<empty>,,,,2,,<empty>
94097,BLOCK,-1,,<empty>,,,,3,,<empty>
94104,BLOCK,-1,,<empty>,,,,4,,<empty>
94109,BLOCK,-1,,"{
    mutex_lock(&item_locks[hv & hashmask(item_lock_hashpower)]);
}",29,,121,2,,void
94111,BLOCK,1,,<empty>,,,,3,,void
94129,BLOCK,-1,,"{
    pthread_mutex_t *lock = &item_locks[hv & hashmask(item_lock_hashpower)];
    if (pthread_mutex_trylock(lock) == 0) {
        return lock;
    }
    return NULL;
}",33,,125,2,,void
94140,BLOCK,1,,<empty>,,,,3,,void
94153,BLOCK,-1,,"{
        return lock;
    }",43,,127,2,,void
94162,BLOCK,-1,,"{
    mutex_unlock((pthread_mutex_t *) lock);
}",38,,133,2,,void
94164,BLOCK,1,,<empty>,,,,1,,void
94173,BLOCK,-1,,"{
    mutex_unlock(&item_locks[hv & hashmask(item_lock_hashpower)]);
}",31,,137,2,,void
94175,BLOCK,1,,<empty>,,,,3,,void
94193,BLOCK,-1,,"{
    while (init_count < nthreads) {
        pthread_cond_wait(&init_cond, &init_lock);
    }
}",56,,141,2,,void
94198,BLOCK,-1,,"{
        pthread_cond_wait(&init_cond, &init_lock);
    }",35,,142,2,,void
94208,BLOCK,-1,,"{
    pthread_mutex_lock(&init_lock);
    init_count++;
    pthread_cond_signal(&init_cond);
    pthread_mutex_unlock(&init_lock);
    /* Force worker threads to pile up if someone wants us to */
    pthread_mutex_lock(&worker_hang_lock);
    pthread_mutex_unlock(&worker_hang_lock);
}",47,,147,2,,void
94230,BLOCK,-1,,"{
    int i;
    bool pause_workers = false;

    switch (type) {
        case PAUSE_ALL_THREADS:
            slabs_rebalancer_pause();
            lru_maintainer_pause();
            lru_crawler_pause();
#ifdef EXTSTORE
            storage_compact_pause();
            storage_write_pause();
#endif
        case PAUSE_WORKER_THREADS:
            pause_workers = true;
            pthread_mutex_lock(&worker_hang_lock);
            break;
        case RESUME_ALL_THREADS:
            slabs_rebalancer_resume();
            lru_maintainer_resume();
            lru_crawler_resume();
#ifdef EXTSTORE
            storage_compact_resume();
            storage_write_resume();
#endif
        case RESUME_WORKER_THREADS:
            pthread_mutex_unlock(&worker_hang_lock);
            break;
        default:
            fprintf(stderr, ""Unknown lock type: %d\n"", type);
            assert(1 == 0);
            break;
    }

    /* Only send a message if we have one. */
    if (!pause_workers) {
     ...",50,,158,2,,void
94238,BLOCK,-1,,"{
        case PAUSE_ALL_THREADS:
            slabs_rebalancer_pause();
            lru_maintainer_pause();
            lru_crawler_pause();
#ifdef EXTSTORE
            storage_compact_pause();
            storage_write_pause();
#endif
        case PAUSE_WORKER_THREADS:
            pause_workers = true;
            pthread_mutex_lock(&worker_hang_lock);
            break;
        case RESUME_ALL_THREADS:
            slabs_rebalancer_resume();
            lru_maintainer_resume();
            lru_crawler_resume();
#ifdef EXTSTORE
            storage_compact_resume();
            storage_write_resume();
#endif
        case RESUME_WORKER_THREADS:
            pthread_mutex_unlock(&worker_hang_lock);
            break;
        default:
            fprintf(stderr, ""Unknown lock type: %d\n"", type);
            assert(1 == 0);
            break;
    }",19,,162,2,,void
94277,BLOCK,-1,,"{
        return;
    }",25,,193,2,,void
94286,BLOCK,-1,,<empty>,5,,199,1,,void
94297,BLOCK,4,,"{
        notify_worker_fd(&threads[i], 0, queue_pause);
    }",48,,199,4,,void
94316,BLOCK,-1,,"{
    int i;

    // assoc can call pause_threads(), so we have to stop it first.
    stop_assoc_maintenance_thread();
    if (settings.verbose > 0)
        fprintf(stderr, ""stopped assoc\n"");

    if (settings.verbose > 0)
        fprintf(stderr, ""asking workers to stop\n"");

    pthread_mutex_lock(&worker_hang_lock);
    pthread_mutex_lock(&init_lock);
    init_count = 0;
    for (i = 0; i < settings.num_threads; i++) {
        notify_worker_fd(&threads[i], 0, queue_stop);
    }
    wait_for_thread_registration(settings.num_threads);
    pthread_mutex_unlock(&init_lock);

    // All of the workers are hung but haven't done cleanup yet.

    if (settings.verbose > 0)
        fprintf(stderr, ""asking background threads to stop\n"");

    // stop each side thread.
    // TODO: Verify these all work if the threads are already stopped
    stop_item_crawler_thread(CRAWLER_WAIT);
    if (settings.verbose > 0)
        fprintf(stderr, ""stopped lru crawler\n"");
    if (settings.lru_maintainer...",25,,210,2,,void
94325,BLOCK,-1,,<empty>,9,,216,2,,void
94335,BLOCK,-1,,<empty>,9,,219,2,,void
94349,BLOCK,-1,,<empty>,5,,224,1,,void
94360,BLOCK,4,,"{
        notify_worker_fd(&threads[i], 0, queue_stop);
    }",48,,224,4,,void
94381,BLOCK,-1,,<empty>,9,,233,2,,void
94387,BLOCK,1,,<empty>,,,,1,,void
94395,BLOCK,-1,,<empty>,9,,239,2,,void
94403,BLOCK,-1,,"{
        stop_lru_maintainer_thread();
        if (settings.verbose > 0)
            fprintf(stderr, ""stopped maintainer\n"");
    }",41,,240,2,,void
94411,BLOCK,-1,,<empty>,13,,243,2,,void
94419,BLOCK,-1,,"{
        stop_slab_maintenance_thread();
        if (settings.verbose > 0)
            fprintf(stderr, ""stopped slab mover\n"");
    }",33,,245,2,,void
94427,BLOCK,-1,,<empty>,13,,248,2,,void
94438,BLOCK,-1,,<empty>,9,,252,2,,void
94449,BLOCK,-1,,<empty>,9,,255,2,,void
94459,BLOCK,-1,,<empty>,9,,259,2,,void
94473,BLOCK,-1,,<empty>,9,,263,2,,void
94478,BLOCK,-1,,<empty>,5,,264,1,,void
94489,BLOCK,4,,"{
        pthread_join(threads[i].thread_id, NULL);
    }",48,,264,4,,void
94503,BLOCK,-1,,<empty>,9,,269,2,,void
94511,BLOCK,-1,,"{
    pthread_mutex_init(&cq->lock, NULL);
    STAILQ_INIT(&cq->head);
    cq->cache = cache_create(""cq"", sizeof(CQ_ITEM), sizeof(char *));
    if (cq->cache == NULL) {
        fprintf(stderr, ""Failed to create connection queue cache\n"");
        exit(EXIT_FAILURE);
    }
}",29,,277,2,,void
94523,BLOCK,1,,<empty>,,,,2,,void
94525,BLOCK,-1,,STAILQ_INIT(&cq->head),5,,279,1,,void
94565,BLOCK,-1,,"{
        fprintf(stderr, ""Failed to create connection queue cache\n"");
        exit(EXIT_FAILURE);
    }",28,,281,2,,void
94575,BLOCK,-1,,"{
    CQ_ITEM *item;

    pthread_mutex_lock(&cq->lock);
    item = STAILQ_FIRST(&cq->head);
    if (item != NULL) {
        STAILQ_REMOVE_HEAD(&cq->head, i_next);
    }
    pthread_mutex_unlock(&cq->lock);

    return item;
}",32,,292,2,,void
94589,BLOCK,1,,<empty>,,,,2,,void
94600,BLOCK,-1,,"{
        STAILQ_REMOVE_HEAD(&cq->head, i_next);
    }",23,,297,2,,void
94606,BLOCK,1,,<empty>,,,,2,,void
94608,BLOCK,-1,,"STAILQ_REMOVE_HEAD(&cq->head, i_next)",9,,298,1,,void
94629,BLOCK,-1,,<empty>,9,,298,2,,void
94657,BLOCK,-1,,"{
    pthread_mutex_lock(&cq->lock);
    STAILQ_INSERT_TAIL(&cq->head, item, i_next);
    pthread_mutex_unlock(&cq->lock);
}",44,,308,3,,void
94669,BLOCK,1,,<empty>,,,,3,,void
94671,BLOCK,-1,,"STAILQ_INSERT_TAIL(&cq->head, item, i_next)",5,,310,1,,void
94711,BLOCK,-1,,"{
    CQ_ITEM *item = cache_alloc(cq->cache);
    if (item == NULL) {
        STATS_LOCK();
        stats.malloc_fails++;
        STATS_UNLOCK();
    }
    return item;
}",33,,317,2,,void
94723,BLOCK,-1,,"{
        STATS_LOCK();
        stats.malloc_fails++;
        STATS_UNLOCK();
    }",23,,319,2,,void
94737,BLOCK,-1,,"{
    cache_free(cq->cache, item);
}",45,,330,3,,void
94748,BLOCK,-1,,"{
    cq_push(t->ev_queue, item);
#ifdef HAVE_EVENTFD
    uint64_t u = 1;
    if (write(t->notify_event_fd, &u, sizeof(uint64_t)) != sizeof(uint64_t)) {
        perror(""failed writing to worker eventfd"");
        /* TODO: This is a fatal problem. Can it ever happen temporarily? */
    }
#else
    char buf[1] = ""c"";
    if (write(t->notify_send_fd, buf, 1) != 1) {
        perror(""Failed writing to notify pipe"");
        /* TODO: This is a fatal problem. Can it ever happen temporarily? */
    }
#endif
}",62,,340,3,,void
94767,BLOCK,-1,,"{
        perror(""Failed writing to notify pipe"");
        /* TODO: This is a fatal problem. Can it ever happen temporarily? */
    }",48,,350,2,,void
94776,BLOCK,-1,,"{
    CQ_ITEM *item;
    while ( (item = cqi_new(t->ev_queue)) == NULL ) {
        // NOTE: most callers of this function cannot fail, but mallocs in
        // theory can fail. Small mallocs essentially never do without also
        // killing the process. Syscalls can also fail but the original code
        // never handled this either.
        // As a compromise, I'm leaving this note and this loop: This alloc
        // cannot fail, but pre-allocating the data is too much code in an
        // area I want to keep more lean. If this CQ business becomes a more
        // generic queue I'll reconsider.
    }

    item->mode = mode;
    item->sfd = sfd;
    notify_worker(t, item);
}",92,,358,4,,void
94787,BLOCK,-1,,"{
        // NOTE: most callers of this function cannot fail, but mallocs in
        // theory can fail. Small mallocs essentially never do without also
        // killing the process. Syscalls can also fail but the original code
        // never handled this either.
        // As a compromise, I'm leaving this note and this loop: This alloc
        // cannot fail, but pre-allocating the data is too much code in an
        // area I want to keep more lean. If this CQ business becomes a more
        // generic queue I'll reconsider.
    }",53,,360,2,,void
94806,BLOCK,-1,,"{
    pthread_attr_t  attr;
    int             ret;

    pthread_attr_init(&attr);

    if ((ret = pthread_create(&((LIBEVENT_THREAD*)arg)->thread_id, &attr, func, arg)) != 0) {
        fprintf(stderr, ""Can't create thread: %s\n"",
                strerror(ret));
        exit(1);
    }
}",61,,379,3,,void
94828,BLOCK,-1,,"{
        fprintf(stderr, ""Can't create thread: %s\n"",
                strerror(ret));
        exit(1);
    }",93,,385,2,,void
94840,BLOCK,-1,,"{
    pthread_mutex_lock(&conn_lock);
    do_accept_new_conns(do_accept);
    pthread_mutex_unlock(&conn_lock);
}",45,,395,2,,void
94853,BLOCK,-1,,"{
#if defined(LIBEVENT_VERSION_NUMBER) && LIBEVENT_VERSION_NUMBER >= 0x02000101
    struct event_config *ev_config;
    ev_config = event_config_new();
    event_config_set_flag(ev_config, EVENT_BASE_FLAG_NOLOCK);
    me->base = event_base_new_with_config(ev_config);
    event_config_free(ev_config);
#else
    me->base = event_init();
#endif

    if (! me->base) {
        fprintf(stderr, ""Can't allocate event base\n"");
        exit(1);
    }

    /* Listen for notifications from other threads */
#ifdef HAVE_EVENTFD
    event_set(&me->notify_event, me->notify_event_fd,
              EV_READ | EV_PERSIST, thread_libevent_process, me);
#else
    event_set(&me->notify_event, me->notify_receive_fd,
              EV_READ | EV_PERSIST, thread_libevent_process, me);
#endif
    event_base_set(me->base, &me->notify_event);

    if (event_add(&me->notify_event, 0) == -1) {
        fprintf(stderr, ""Can't monitor libevent notify pipe\n"");
        exit(1);
    }

    me->ev_queue = malloc(sizeof(...",47,,405,2,,void
94864,BLOCK,-1,,"{
        fprintf(stderr, ""Can't allocate event base\n"");
        exit(1);
    }",21,,416,2,,void
94901,BLOCK,-1,,"{
        fprintf(stderr, ""Can't monitor libevent notify pipe\n"");
        exit(1);
    }",48,,431,2,,void
94920,BLOCK,-1,,"{
        perror(""Failed to allocate memory for connection queue"");
        exit(EXIT_FAILURE);
    }",31,,437,2,,void
94940,BLOCK,-1,,"{
        perror(""Failed to initialize mutex"");
        exit(EXIT_FAILURE);
    }",58,,443,2,,void
94952,BLOCK,1,,<empty>,,,,1,,void
94962,BLOCK,-1,,"{
        fprintf(stderr, ""Failed to create read buffer cache\n"");
        exit(EXIT_FAILURE);
    }",33,,449,2,,void
94972,BLOCK,-1,,"{
        int limit = settings.read_buf_mem_limit / settings.num_threads;
        if (limit < READ_BUFFER_SIZE) {
            limit = 1;
        } else {
            limit = limit / READ_BUFFER_SIZE;
        }
        cache_set_limit(me->rbuf_cache, limit);
    }",38,,455,2,,void
94987,BLOCK,1,,<empty>,,,,1,,void
94989,BLOCK,-1,,"{
            limit = 1;
        }",39,,457,2,,void
94994,BLOCK,-1,,"{
            limit = limit / READ_BUFFER_SIZE;
        }",16,,459,1,,void
95000,BLOCK,1,,<empty>,,,,1,,void
95023,BLOCK,-1,,"{
        fprintf(stderr, ""Failed to create IO object cache\n"");
        exit(EXIT_FAILURE);
    }",31,,466,2,,void
95032,BLOCK,1,,<empty>,,,,1,,void
95043,BLOCK,-1,,"{
    LIBEVENT_THREAD *me = arg;

    /* Any per-thread setup can happen here; memcached_thread_init() will block until
     * all threads have finished initializing.
     */
    me->l = logger_create();
    me->lru_bump_buf = item_lru_bump_buf_create();
    if (me->l == NULL || me->lru_bump_buf == NULL) {
        abort();
    }

    if (settings.drop_privileges) {
        drop_worker_privileges();
    }

    register_thread_initialized();

    event_base_loop(me->base, 0);

    // same mechanism used to watch for all threads exiting.
    register_thread_initialized();

    event_base_free(me->base);
    return NULL;
}",41,,502,2,,void
95070,BLOCK,-1,,"{
        abort();
    }",52,,510,2,,void
95076,BLOCK,-1,,"{
        drop_worker_privileges();
    }",35,,514,2,,void
95096,BLOCK,-1,,"{
    LIBEVENT_THREAD *me = arg;
    CQ_ITEM *item;
    conn *c;
    uint64_t ev_count = 0; // max number of events to loop through this run.
#ifdef HAVE_EVENTFD
    // NOTE: unlike pipe we aren't limiting the number of events per read.
    // However we do limit the number of queue pulls to what the count was at
    // the time of this function firing.
    if (read(fd, &ev_count, sizeof(uint64_t)) != sizeof(uint64_t)) {
        if (settings.verbose > 0)
            fprintf(stderr, ""Can't read from libevent pipe\n"");
        return;
    }
#else
    char buf[MAX_PIPE_EVENTS];

    ev_count = read(fd, buf, MAX_PIPE_EVENTS);
    if (ev_count == 0) {
        if (settings.verbose > 0)
            fprintf(stderr, ""Can't read from libevent pipe\n"");
        return;
    }
#endif

    for (int x = 0; x < ev_count; x++) {
        item = cq_pop(me->ev_queue);
        if (item == NULL) {
            return;
        }

        switch (item->mode) {
            case queue_new_conn:
              ...",81,,537,4,,void
95114,BLOCK,1,,<empty>,,,,1,,void
95120,BLOCK,-1,,"{
        if (settings.verbose > 0)
            fprintf(stderr, ""Can't read from libevent pipe\n"");
        return;
    }",24,,555,2,,void
95127,BLOCK,-1,,<empty>,13,,557,2,,void
95133,BLOCK,-1,,<empty>,5,,562,1,,void
95143,BLOCK,4,,"{
        item = cq_pop(me->ev_queue);
        if (item == NULL) {
            return;
        }

        switch (item->mode) {
            case queue_new_conn:
                c = conn_new(item->sfd, item->init_state, item->event_flags,
                                   item->read_buffer_size, item->transport,
                                   me->base, item->ssl, item->conntag, item->bproto);
                if (c == NULL) {
                    if (IS_UDP(item->transport)) {
                        fprintf(stderr, ""Can't listen for events on UDP socket\n"");
                        exit(1);
                    } else {
                        if (settings.verbose > 0) {
                            fprintf(stderr, ""Can't listen for events on fd %d\n"",
                                item->sfd);
                        }
#ifdef TLS
                        if (item->ssl) {
                            SSL_shutdown(item->ssl);
                            SSL_free(item->ssl);
         ...",40,,562,4,,void
95154,BLOCK,-1,,"{
            return;
        }",27,,564,2,,void
95160,BLOCK,-1,,"{
            case queue_new_conn:
                c = conn_new(item->sfd, item->init_state, item->event_flags,
                                   item->read_buffer_size, item->transport,
                                   me->base, item->ssl, item->conntag, item->bproto);
                if (c == NULL) {
                    if (IS_UDP(item->transport)) {
                        fprintf(stderr, ""Can't listen for events on UDP socket\n"");
                        exit(1);
                    } else {
                        if (settings.verbose > 0) {
                            fprintf(stderr, ""Can't listen for events on fd %d\n"",
                                item->sfd);
                        }
#ifdef TLS
                        if (item->ssl) {
                            SSL_shutdown(item->ssl);
                            SSL_free(item->ssl);
                        }
#endif
                        close(item->sfd);
                    }
                } else {
             ...",29,,568,2,,void
95197,BLOCK,-1,,"{
                    if (IS_UDP(item->transport)) {
                        fprintf(stderr, ""Can't listen for events on UDP socket\n"");
                        exit(1);
                    } else {
                        if (settings.verbose > 0) {
                            fprintf(stderr, ""Can't listen for events on fd %d\n"",
                                item->sfd);
                        }
#ifdef TLS
                        if (item->ssl) {
                            SSL_shutdown(item->ssl);
                            SSL_free(item->ssl);
                        }
#endif
                        close(item->sfd);
                    }
                }",32,,573,2,,void
95203,BLOCK,1,,<empty>,,,,3,,void
95209,BLOCK,-1,,"{
                        fprintf(stderr, ""Can't listen for events on UDP socket\n"");
                        exit(1);
                    }",50,,574,2,,void
95216,BLOCK,-1,,"{
                        if (settings.verbose > 0) {
                            fprintf(stderr, ""Can't listen for events on fd %d\n"",
                                item->sfd);
                        }
#ifdef TLS
                        if (item->ssl) {
                            SSL_shutdown(item->ssl);
                            SSL_free(item->ssl);
                        }
#endif
                        close(item->sfd);
                    }",28,,577,1,,void
95223,BLOCK,-1,,"{
                            fprintf(stderr, ""Can't listen for events on fd %d\n"",
                                item->sfd);
                        }",51,,578,2,,void
95235,BLOCK,-1,,"{
                    c->thread = me;
                    conn_io_queue_setup(c);
#ifdef TLS
                    if (settings.ssl_enabled && c->ssl != NULL) {
                        assert(c->thread && c->thread->ssl_wbuf);
                        c->ssl_wbuf = c->thread->ssl_wbuf;
                    }
#endif
                }",24,,590,1,,void
95290,BLOCK,-1,,"{
    return &threads[id];
}",44,,634,2,,void
95310,BLOCK,-1,,"{
    int tid = (last_thread + 1) % settings.num_threads;

    last_thread = tid;

    return threads + tid;
}",1,,645,2,,void
95332,BLOCK,-1,,"{
    LIBEVENT_THREAD *thread;
    int i;

    for (i = 0; i < settings.num_threads; i++) {
         thread = threads + i;
         thread->napi_id = 0;
    }

    last_thread_by_napi_id = -1;
}",1,,654,2,,void
95336,BLOCK,-1,,<empty>,5,,658,1,,void
95347,BLOCK,4,,"{
         thread = threads + i;
         thread->napi_id = 0;
    }",48,,658,4,,void
95366,BLOCK,-1,,"{
    LIBEVENT_THREAD *thread;
    int napi_id, err, i;
    socklen_t len;
    int tid = -1;

    len = sizeof(socklen_t);
    err = getsockopt(sfd, SOL_SOCKET, SO_INCOMING_NAPI_ID, &napi_id, &len);
    if ((err == -1) || (napi_id == 0)) {
        STATS_LOCK();
        stats.round_robin_fallback++;
        STATS_UNLOCK();
        return select_thread_round_robin();
    }

select:
    for (i = 0; i < settings.num_threads; i++) {
         thread = threads + i;
         if (last_thread_by_napi_id < i) {
             thread->napi_id = napi_id;
             last_thread_by_napi_id = i;
             tid = i;
             break;
         }
         if (thread->napi_id == napi_id) {
             tid = i;
             break;
         }
    }

    if (tid == -1) {
        STATS_LOCK();
        stats.unexpected_napi_ids++;
        STATS_UNLOCK();
        reset_threads_napi_id();
        goto select;
    }

    return threads + tid;
}",1,,671,2,,void
95387,BLOCK,1,,<empty>,,,,1,,void
95402,BLOCK,-1,,"{
        STATS_LOCK();
        stats.round_robin_fallback++;
        STATS_UNLOCK();
        return select_thread_round_robin();
    }",40,,679,2,,void
95413,BLOCK,-1,,<empty>,5,,687,1,,void
95424,BLOCK,4,,"{
         thread = threads + i;
         if (last_thread_by_napi_id < i) {
             thread->napi_id = napi_id;
             last_thread_by_napi_id = i;
             tid = i;
             break;
         }
         if (thread->napi_id == napi_id) {
             tid = i;
             break;
         }
    }",48,,687,4,,void
95434,BLOCK,-1,,"{
             thread->napi_id = napi_id;
             last_thread_by_napi_id = i;
             tid = i;
             break;
         }",42,,689,2,,void
95453,BLOCK,-1,,"{
             tid = i;
             break;
         }",42,,695,2,,void
95463,BLOCK,-1,,"{
        STATS_LOCK();
        stats.unexpected_napi_ids++;
        STATS_UNLOCK();
        reset_threads_napi_id();
        goto select;
    }",20,,701,2,,void
95487,BLOCK,-1,,"{
    CQ_ITEM *item = NULL;
    LIBEVENT_THREAD *thread;

    if (!settings.num_napi_ids)
        thread = select_thread_round_robin();
    else
        thread = select_thread_by_napi_id(sfd);

    item = cqi_new(thread->ev_queue);
    if (item == NULL) {
        close(sfd);
        /* given that malloc failed this may also fail, but let's try */
        fprintf(stderr, ""Failed to allocate memory for connection object\n"");
        return;
    }

    item->sfd = sfd;
    item->init_state = init_state;
    item->event_flags = event_flags;
    item->read_buffer_size = read_buffer_size;
    item->transport = transport;
    item->mode = queue_new_conn;
    item->ssl = ssl;
    item->conntag = conntag;
    item->bproto = bproto;

    MEMCACHED_CONN_DISPATCH(sfd, (int64_t)thread->thread_id);
    notify_worker(thread, item);
}",64,,719,9,,void
95498,BLOCK,-1,,<empty>,9,,724,2,,void
95503,BLOCK,-1,,<empty>,9,,726,1,,void
95518,BLOCK,-1,,"{
        close(sfd);
        /* given that malloc failed this may also fail, but let's try */
        fprintf(stderr, ""Failed to allocate memory for connection object\n"");
        return;
    }",23,,729,2,,void
95577,BLOCK,-1,,"{
    notify_worker_fd(c->thread, c->sfd, queue_redispatch);
}",31,,754,2,,void
95590,BLOCK,-1,,"{
    notify_worker_fd(c->thread, c->sfd, queue_timeout);
}",28,,758,2,,void
95603,BLOCK,-1,,"{
    CQ_ITEM *item = cqi_new(io->thread->ev_queue);
    if (item == NULL) {
        // TODO: how can we avoid this?
        // In the main case I just loop, since a malloc failure here for a
        // tiny object that's generally in a fixed size queue is going to
        // implode shortly.
        return;
    }

    item->mode = queue_return_io;
    item->io = io;

    notify_worker(io->thread, item);
}",42,,767,2,,void
95617,BLOCK,-1,,"{
        // TODO: how can we avoid this?
        // In the main case I just loop, since a malloc failure here for a
        // tiny object that's generally in a fixed size queue is going to
        // implode shortly.
        return;
    }",23,,769,2,,void
95638,BLOCK,-1,,"{
    if (settings.verbose > 1)
        fprintf(stderr, ""<%d connection closing from side thread.\n"", c->sfd);

    c->state = conn_closing;
    // redispatch will see closing flag and properly close connection.
    redispatch_conn(c);
    return;
}",37,,784,2,,void
95645,BLOCK,-1,,<empty>,9,,786,2,,void
95668,BLOCK,-1,,"{
    item *it;
    /* do_item_alloc handles its own locks */
    it = do_item_alloc(key, nkey, flags, exptime, nbytes);
    return it;
}",85,,799,6,,void
95687,BLOCK,-1,,"{
    item *it;
    uint32_t hv;
    hv = hash(key, nkey);
    item_lock(hv);
    it = do_item_get(key, nkey, hv, c, do_update);
    item_unlock(hv);
    return it;
}",83,,810,5,,void
95717,BLOCK,-1,,"{
    item *it;
    *hv = hash(key, nkey);
    item_lock(*hv);
    it = do_item_get(key, nkey, *hv, c, do_update);
    return it;
}",104,,823,6,,void
95746,BLOCK,-1,,"{
    item *it;
    uint32_t hv;
    hv = hash(key, nkey);
    item_lock(hv);
    it = do_item_touch(key, nkey, exptime, hv, c);
    item_unlock(hv);
    return it;
}",75,,831,5,,void
95772,BLOCK,-1,,"{
    int ret;
    uint32_t hv;

    hv = hash(ITEM_key(item), item->nkey);
    item_lock(hv);
    ret = do_item_link(item, hv);
    item_unlock(hv);
    return ret;
}",27,,844,2,,void
95780,BLOCK,1,,<empty>,,,,2,,void
95815,BLOCK,-1,,"{
    uint32_t hv;
    hv = hash(ITEM_key(item), item->nkey);

    item_lock(hv);
    do_item_remove(item);
    item_unlock(hv);
}",30,,859,2,,void
95822,BLOCK,1,,<empty>,,,,2,,void
95854,BLOCK,-1,,"{
    return do_item_replace(old_it, new_it, hv);
}",65,,873,4,,void
95864,BLOCK,-1,,"{
    uint32_t hv;
    hv = hash(ITEM_key(item), item->nkey);
    item_lock(hv);
    do_item_unlink(item, hv);
    item_unlock(hv);
}",30,,880,2,,void
95871,BLOCK,1,,<empty>,,,,2,,void
95908,BLOCK,-1,,"{
    enum delta_result_type ret;
    uint32_t hv;

    hv = hash(key, nkey);
    item_lock(hv);
    ret = do_add_delta(c, key, nkey, incr, delta, buf, cas, hv, NULL);
    item_unlock(hv);
    return ret;
}",49,,894,8,,void
95940,BLOCK,-1,,"{
    enum store_item_type ret;
    uint32_t hv;

    hv = hash(ITEM_key(item), item->nkey);
    item_lock(hv);
    ret = do_store_item(item, comm, c, hv);
    item_unlock(hv);
    return ret;
}",64,,908,4,,void
95948,BLOCK,1,,<empty>,,,,2,,void
95984,BLOCK,-1,,"{
    pthread_mutex_lock(&stats_lock);
}",19,,921,1,,void
95991,BLOCK,-1,,"{
    pthread_mutex_unlock(&stats_lock);
}",21,,925,1,,void
95999,BLOCK,-1,,"{
    int ii;
    for (ii = 0; ii < settings.num_threads; ++ii) {
        pthread_mutex_lock(&threads[ii].stats.mutex);
#define X(name) threads[ii].stats.name = 0;
        THREAD_STATS_FIELDS
#ifdef EXTSTORE
        EXTSTORE_THREAD_STATS_FIELDS
#endif
#ifdef PROXY
        PROXY_THREAD_STATS_FIELDS
#endif
#undef X

        memset(&threads[ii].stats.slab_stats, 0,
                sizeof(threads[ii].stats.slab_stats));
        memset(&threads[ii].stats.lru_hits, 0,
                sizeof(uint64_t) * POWER_LARGEST);

        pthread_mutex_unlock(&threads[ii].stats.mutex);
    }
}",36,,929,2,,void
96002,BLOCK,-1,,<empty>,5,,931,1,,void
96013,BLOCK,4,,"{
        pthread_mutex_lock(&threads[ii].stats.mutex);
#define X(name) threads[ii].stats.name = 0;
        THREAD_STATS_FIELDS
#ifdef EXTSTORE
        EXTSTORE_THREAD_STATS_FIELDS
#endif
#ifdef PROXY
        PROXY_THREAD_STATS_FIELDS
#endif
#undef X

        memset(&threads[ii].stats.slab_stats, 0,
                sizeof(threads[ii].stats.slab_stats));
        memset(&threads[ii].stats.lru_hits, 0,
                sizeof(uint64_t) * POWER_LARGEST);

        pthread_mutex_unlock(&threads[ii].stats.mutex);
    }",51,,931,4,,void
96024,BLOCK,1,,<empty>,,,,3,,void
96273,BLOCK,1,,<empty>,,,,1,,void
96288,BLOCK,-1,,"{
    int ii, sid;

    /* The struct has a mutex, but we can safely set the whole thing
     * to zero since it is unused when aggregating. */
    memset(stats, 0, sizeof(*stats));

    for (ii = 0; ii < settings.num_threads; ++ii) {
        pthread_mutex_lock(&threads[ii].stats.mutex);
#define X(name) stats->name += threads[ii].stats.name;
        THREAD_STATS_FIELDS
#ifdef EXTSTORE
        EXTSTORE_THREAD_STATS_FIELDS
#endif
#ifdef PROXY
        PROXY_THREAD_STATS_FIELDS
#endif
#undef X

        for (sid = 0; sid < MAX_NUMBER_OF_SLAB_CLASSES; sid++) {
#define X(name) stats->slab_stats[sid].name += \
            threads[ii].stats.slab_stats[sid].name;
            SLAB_STATS_FIELDS
#undef X
        }

        for (sid = 0; sid < POWER_LARGEST; sid++) {
            stats->lru_hits[sid] +=
                threads[ii].stats.lru_hits[sid];
            stats->slab_stats[CLEAR_LRU(sid)].get_hits +=
                threads[ii].stats.lru_hits[sid];
        }

        stats->read_buf_count ...",62,,952,2,,void
96298,BLOCK,-1,,<empty>,5,,959,1,,void
96309,BLOCK,4,,"{
        pthread_mutex_lock(&threads[ii].stats.mutex);
#define X(name) stats->name += threads[ii].stats.name;
        THREAD_STATS_FIELDS
#ifdef EXTSTORE
        EXTSTORE_THREAD_STATS_FIELDS
#endif
#ifdef PROXY
        PROXY_THREAD_STATS_FIELDS
#endif
#undef X

        for (sid = 0; sid < MAX_NUMBER_OF_SLAB_CLASSES; sid++) {
#define X(name) stats->slab_stats[sid].name += \
            threads[ii].stats.slab_stats[sid].name;
            SLAB_STATS_FIELDS
#undef X
        }

        for (sid = 0; sid < POWER_LARGEST; sid++) {
            stats->lru_hits[sid] +=
                threads[ii].stats.lru_hits[sid];
            stats->slab_stats[CLEAR_LRU(sid)].get_hits +=
                threads[ii].stats.lru_hits[sid];
        }

        stats->read_buf_count += threads[ii].rbuf_cache->total;
        stats->read_buf_bytes += threads[ii].rbuf_cache->total * READ_BUFFER_SIZE;
        stats->read_buf_bytes_free += threads[ii].rbuf_cache->freecurr * READ_BUFFER_SIZE;
        pthread_mutex_unl...",51,,959,4,,void
96320,BLOCK,1,,<empty>,,,,3,,void
96586,BLOCK,-1,,<empty>,9,,971,1,,void
96593,BLOCK,1,,<empty>,,,,1,,void
96599,BLOCK,4,,"{
#define X(name) stats->slab_stats[sid].name += \
            threads[ii].stats.slab_stats[sid].name;
            SLAB_STATS_FIELDS
#undef X
        }",64,,971,4,,void
96601,BLOCK,1,,<empty>,,,,5,,void
96755,BLOCK,-1,,<empty>,9,,978,1,,void
96762,BLOCK,1,,<empty>,,,,1,,void
96766,BLOCK,4,,"{
            stats->lru_hits[sid] +=
                threads[ii].stats.lru_hits[sid];
            stats->slab_stats[CLEAR_LRU(sid)].get_hits +=
                threads[ii].stats.lru_hits[sid];
        }",51,,978,4,,void
96790,BLOCK,1,,<empty>,,,,3,,void
96831,BLOCK,1,,<empty>,,,,1,,void
96846,BLOCK,1,,<empty>,,,,1,,void
96862,BLOCK,-1,,"{
    int sid;

    memset(out, 0, sizeof(*out));

    for (sid = 0; sid < MAX_NUMBER_OF_SLAB_CLASSES; sid++) {
#define X(name) out->name += stats->slab_stats[sid].name;
        SLAB_STATS_FIELDS
#undef X
    }
}",79,,992,3,,void
96871,BLOCK,-1,,<empty>,5,,997,1,,void
96878,BLOCK,1,,<empty>,,,,1,,void
96884,BLOCK,4,,"{
#define X(name) out->name += stats->slab_stats[sid].name;
        SLAB_STATS_FIELDS
#undef X
    }",60,,997,4,,void
96886,BLOCK,1,,<empty>,,,,2,,void
96980,BLOCK,-1,,"{
    int         i;
    int         power;

    for (i = 0; i < POWER_LARGEST; i++) {
        pthread_mutex_init(&lru_locks[i], NULL);
    }
    pthread_mutex_init(&worker_hang_lock, NULL);

    pthread_mutex_init(&init_lock, NULL);
    pthread_cond_init(&init_cond, NULL);

    /* Want a wide lock table, but don't waste memory */
    if (nthreads < 3) {
        power = 10;
    } else if (nthreads < 4) {
        power = 11;
    } else if (nthreads < 5) {
        power = 12;
    } else if (nthreads <= 10) {
        power = 13;
    } else if (nthreads <= 20) {
        power = 14;
    } else {
        /* 32k buckets. just under the hashpower default. */
        power = 15;
    }

    if (power >= hashpower) {
        fprintf(stderr, ""Hash table power size (%d) cannot be equal to or less than item lock table (%d)\n"", hashpower, power);
        fprintf(stderr, ""Item lock table grows with `-t N` (worker threadcount)\n"");
        fprintf(stderr, ""Hash table grows with `-o hashpower=N` \n"")...",53,,1009,3,,void
96984,BLOCK,-1,,<empty>,5,,1013,1,,void
96991,BLOCK,1,,<empty>,,,,1,,void
96995,BLOCK,4,,"{
        pthread_mutex_init(&lru_locks[i], NULL);
    }",41,,1013,4,,void
97018,BLOCK,-1,,"{
        power = 10;
    }",23,,1022,2,,void
97023,BLOCK,-1,,<empty>,12,,1024,1,,void
97028,BLOCK,-1,,"{
        power = 11;
    }",30,,1024,2,,void
97033,BLOCK,-1,,<empty>,12,,1026,1,,void
97038,BLOCK,-1,,"{
        power = 12;
    }",30,,1026,2,,void
97043,BLOCK,-1,,<empty>,12,,1028,1,,void
97048,BLOCK,-1,,"{
        power = 13;
    }",32,,1028,2,,void
97053,BLOCK,-1,,<empty>,12,,1030,1,,void
97058,BLOCK,-1,,"{
        power = 14;
    }",32,,1030,2,,void
97063,BLOCK,-1,,"{
        /* 32k buckets. just under the hashpower default. */
        power = 15;
    }",12,,1032,1,,void
97071,BLOCK,-1,,"{
        fprintf(stderr, ""Hash table power size (%d) cannot be equal to or less than item lock table (%d)\n"", hashpower, power);
        fprintf(stderr, ""Item lock table grows with `-t N` (worker threadcount)\n"");
        fprintf(stderr, ""Hash table grows with `-o hashpower=N` \n"");
        exit(1);
    }",29,,1037,2,,void
97089,BLOCK,1,,<empty>,,,,3,,void
97107,BLOCK,-1,,"{
        perror(""Can't allocate item locks"");
        exit(1);
    }",23,,1048,2,,void
97113,BLOCK,-1,,<empty>,5,,1052,1,,void
97122,BLOCK,4,,"{
        pthread_mutex_init(&item_locks[i], NULL);
    }",43,,1052,4,,void
97138,BLOCK,-1,,"{
        perror(""Can't allocate thread descriptors"");
        exit(1);
    }",20,,1057,2,,void
97144,BLOCK,-1,,<empty>,5,,1062,1,,void
97153,BLOCK,4,,"{
#ifdef HAVE_EVENTFD
        threads[i].notify_event_fd = eventfd(0, EFD_NONBLOCK);
        if (threads[i].notify_event_fd == -1) {
            perror(""failed creating eventfd for worker thread"");
            exit(1);
        }
#else
        int fds[2];
        if (pipe(fds)) {
            perror(""Can't create notify pipe"");
            exit(1);
        }

        threads[i].notify_receive_fd = fds[0];
        threads[i].notify_send_fd = fds[1];
#endif
#ifdef EXTSTORE
        threads[i].storage = arg;
#endif
        setup_thread(&threads[i]);
        /* Reserve three fds for the libevent base, and two for the pipe */
        stats_state.reserved_fds += 5;
    }",36,,1062,4,,void
97158,BLOCK,-1,,"{
            perror(""Can't create notify pipe"");
            exit(1);
        }",24,,1071,2,,void
97192,BLOCK,-1,,<empty>,5,,1088,1,,void
97201,BLOCK,4,,"{
        create_worker(worker_libevent, &threads[i]);
    }",36,,1088,4,,void
97238,BLOCK,-1,,<empty>,1,,1,1,,ANY
97245,BLOCK,-1,,"{
    caught_sig = which;
}",1,,14,2,,void
97253,BLOCK,-1,,"{
    int rv = EX_SOFTWARE;
    int status = 0;
    int i = 0;
    struct sigaction sig_handler;

    memset(&sig_handler, 0, sizeof(struct sigaction));
    sig_handler.sa_handler = signal_handler;
    sig_handler.sa_flags = 0;

    sigaction(SIGALRM, &sig_handler, NULL);
    sigaction(SIGHUP, &sig_handler, NULL);
    sigaction(SIGINT, &sig_handler, NULL);
    sigaction(SIGUSR1, &sig_handler, NULL);
    sigaction(SIGTERM, &sig_handler, NULL);
    sigaction(SIGPIPE, &sig_handler, NULL);

    /* Loop forever waiting for the process to quit */
    for (i = 0; ;i++) {
        pid_t p = waitpid(pid, &status, 0);
        if (p == pid) {
            /* child exited.  Let's get out of here */
            rv = WIFEXITED(status) ?
                WEXITSTATUS(status) :
                (0x80 | WTERMSIG(status));
            break;
        } else {
            int sig = 0;
            switch (i) {
            case 0:
                /* On the first iteration, pass the signal through */
         ...",1,,19,2,,void
97314,BLOCK,-1,,<empty>,5,,37,1,,void
97320,BLOCK,4,,"{
        pid_t p = waitpid(pid, &status, 0);
        if (p == pid) {
            /* child exited.  Let's get out of here */
            rv = WIFEXITED(status) ?
                WEXITSTATUS(status) :
                (0x80 | WTERMSIG(status));
            break;
        } else {
            int sig = 0;
            switch (i) {
            case 0:
                /* On the first iteration, pass the signal through */
                sig = caught_sig > 0 ? caught_sig : SIGTERM;
                if (caught_sig == SIGALRM) {
                   fprintf(stderr, ""Timeout.. killing the process\n"");
                }
                break;
            case 1:
                sig = SIGTERM;
                break;
            default:
                sig = SIGKILL;
                break;
            }
            if (kill(pid, sig) < 0) {
                /* Kill failed.  Must have lost the process. :/ */
                perror(""lost child when trying to kill"");
            }
            /* Wait ...",23,,37,4,,void
97333,BLOCK,-1,,"{
            /* child exited.  Let's get out of here */
            rv = WIFEXITED(status) ?
                WEXITSTATUS(status) :
                (0x80 | WTERMSIG(status));
            break;
        }",23,,39,2,,void
97347,BLOCK,-1,,"{
            int sig = 0;
            switch (i) {
            case 0:
                /* On the first iteration, pass the signal through */
                sig = caught_sig > 0 ? caught_sig : SIGTERM;
                if (caught_sig == SIGALRM) {
                   fprintf(stderr, ""Timeout.. killing the process\n"");
                }
                break;
            case 1:
                sig = SIGTERM;
                break;
            default:
                sig = SIGKILL;
                break;
            }
            if (kill(pid, sig) < 0) {
                /* Kill failed.  Must have lost the process. :/ */
                perror(""lost child when trying to kill"");
            }
            /* Wait up to 5 seconds for the pid */
            alarm(5);
        }",16,,45,1,,void
97354,BLOCK,-1,,"{
            case 0:
                /* On the first iteration, pass the signal through */
                sig = caught_sig > 0 ? caught_sig : SIGTERM;
                if (caught_sig == SIGALRM) {
                   fprintf(stderr, ""Timeout.. killing the process\n"");
                }
                break;
            case 1:
                sig = SIGTERM;
                break;
            default:
                sig = SIGKILL;
                break;
            }",24,,47,2,,void
97369,BLOCK,-1,,"{
                   fprintf(stderr, ""Timeout.. killing the process\n"");
                }",44,,51,2,,void
97391,BLOCK,-1,,"{
                /* Kill failed.  Must have lost the process. :/ */
                perror(""lost child when trying to kill"");
            }",37,,62,2,,void
97402,BLOCK,-1,,"{
    int rv = EX_SOFTWARE;
    pid_t pid = fork();

    switch (pid) {
    case -1:
        perror(""fork"");
        rv = EX_OSERR;
        break; /* NOTREACHED */
    case 0:
        execvp(argv[0], argv);
        perror(""exec"");
        rv = EX_SOFTWARE;
        break; /* NOTREACHED */
    default:
        rv = wait_for_process(pid);
    }
    return rv;
}",1,,74,2,,void
97413,BLOCK,-1,,"{
    case -1:
        perror(""fork"");
        rv = EX_OSERR;
        break; /* NOTREACHED */
    case 0:
        execvp(argv[0], argv);
        perror(""exec"");
        rv = EX_SOFTWARE;
        break; /* NOTREACHED */
    default:
        rv = wait_for_process(pid);
    }",18,,78,2,,void
97447,BLOCK,-1,,"{
    fprintf(stderr, ""./timedrun <naptime in sec> args...\n"");
    exit(-1);
}",25,,94,2,,void
97459,BLOCK,-1,,"{
    int naptime = 0;
    if (argc < 3)
        usage();

    naptime = atoi(argv[1]);
    assert(naptime > 0 && naptime < 1800);

    alarm(naptime);

    return spawn_and_wait(argv+2);
}",1,,100,3,,void
97468,BLOCK,-1,,<empty>,9,,103,2,,void
97509,BLOCK,-1,,<empty>,1,,1,1,,ANY
97514,BLOCK,-1,,<empty>,1,,1,1,,ANY
97517,BLOCK,-1,,<empty>,,,,2,,<empty>
97522,BLOCK,-1,,<empty>,,,,2,,<empty>
97529,BLOCK,-1,,<empty>,,,,4,,<empty>
97536,BLOCK,-1,,<empty>,,,,4,,<empty>
97543,BLOCK,-1,,<empty>,,,,4,,<empty>
97548,BLOCK,-1,,<empty>,,,,2,,<empty>
97553,BLOCK,-1,,<empty>,,,,2,,<empty>
97560,BLOCK,-1,,<empty>,,,,4,,<empty>
97566,BLOCK,-1,,<empty>,,,,3,,<empty>
97571,BLOCK,-1,,<empty>,,,,2,,<empty>
97580,BLOCK,-1,,<empty>,1,,1,1,,ANY
97601,BLOCK,-1,,<empty>,1,,1,1,,ANY
97610,BLOCK,-1,,"{
    int x;
    char *str = uriencode_str;
    for (x = 0; x < 256; x++) {
        if (isalnum(x) || x == '-' || x == '.' || x == '_' || x == '~') {
            uriencode_map[x] = NULL;
        } else {
            snprintf(str, 4, ""%%%02hhX"", (unsigned char)x);
            uriencode_map[x] = str;
            str += 3; /* lobbing off the \0 is fine */
        }
    }
}",27,,14,2,,void
97617,BLOCK,-1,,<empty>,5,,17,1,,void
97626,BLOCK,4,,"{
        if (isalnum(x) || x == '-' || x == '.' || x == '_' || x == '~') {
            uriencode_map[x] = NULL;
        } else {
            snprintf(str, 4, ""%%%02hhX"", (unsigned char)x);
            uriencode_map[x] = str;
            str += 3; /* lobbing off the \0 is fine */
        }
    }",31,,17,4,,void
97646,BLOCK,-1,,"{
            uriencode_map[x] = NULL;
        }",73,,18,2,,void
97653,BLOCK,-1,,"{
            snprintf(str, 4, ""%%%02hhX"", (unsigned char)x);
            uriencode_map[x] = str;
            str += 3; /* lobbing off the \0 is fine */
        }",16,,20,1,,void
97676,BLOCK,-1,,"{
    int x;
    size_t d = 0;
    for (x = 0; x < srclen; x++) {
        if (d + 4 > dstlen)
            return false;
        if (uriencode_map[(unsigned char) src[x]] != NULL) {
            memcpy(&dst[d], uriencode_map[(unsigned char) src[x]], 3);
            d += 3;
        } else {
            dst[d] = src[x];
            d++;
        }
    }
    dst[d] = '\0';
    return true;
}",86,,28,5,,void
97683,BLOCK,-1,,<empty>,5,,31,1,,void
97692,BLOCK,4,,"{
        if (d + 4 > dstlen)
            return false;
        if (uriencode_map[(unsigned char) src[x]] != NULL) {
            memcpy(&dst[d], uriencode_map[(unsigned char) src[x]], 3);
            d += 3;
        } else {
            dst[d] = src[x];
            d++;
        }
    }",34,,31,4,,void
97699,BLOCK,-1,,<empty>,13,,33,2,,void
97712,BLOCK,-1,,"{
            memcpy(&dst[d], uriencode_map[(unsigned char) src[x]], 3);
            d += 3;
        }",60,,34,2,,void
97730,BLOCK,-1,,"{
            dst[d] = src[x];
            d++;
        }",16,,37,1,,void
97752,BLOCK,-1,,"{
    assert(out != NULL);
    errno = 0;
    *out = 0;
    char *endptr;
    unsigned long long ull = strtoull(str, &endptr, 10);
    if ((errno == ERANGE) || (str == endptr)) {
        return false;
    }

    if (xisspace(*endptr) || (*endptr == '\0' && endptr != str)) {
        if ((long long) ull < 0) {
            /* only check for negative signs in the uncommon case when
             * the unsigned number is so big that it's negative as a
             * signed number. */
            if (strchr(str, '-') != NULL) {
                return false;
            }
        }
        *out = ull;
        return true;
    }
    return false;
}",52,,49,3,,void
97781,BLOCK,-1,,"{
        return false;
    }",47,,55,2,,void
97789,BLOCK,1,,<empty>,,,,3,,void
97803,BLOCK,-1,,"{
        if ((long long) ull < 0) {
            /* only check for negative signs in the uncommon case when
             * the unsigned number is so big that it's negative as a
             * signed number. */
            if (strchr(str, '-') != NULL) {
                return false;
            }
        }
        *out = ull;
        return true;
    }",66,,59,2,,void
97810,BLOCK,-1,,"{
            /* only check for negative signs in the uncommon case when
             * the unsigned number is so big that it's negative as a
             * signed number. */
            if (strchr(str, '-') != NULL) {
                return false;
            }
        }",34,,60,2,,void
97817,BLOCK,-1,,"{
                return false;
            }",43,,64,2,,void
97833,BLOCK,-1,,"{
    assert(out != NULL);
    errno = 0;
    *out = 0;
    char *endptr;
    unsigned long long ull = strtoull(str, &endptr, 16);
    if ((errno == ERANGE) || (str == endptr)) {
        return false;
    }

    if (xisspace(*endptr) || (*endptr == '\0' && endptr != str)) {
        if ((long long) ull < 0) {
            /* only check for negative signs in the uncommon case when
             * the unsigned number is so big that it's negative as a
             * signed number. */
            if (strchr(str, '-') != NULL) {
                return false;
            }
        }
        *out = ull;
        return true;
    }
    return false;
}",56,,79,3,,void
97862,BLOCK,-1,,"{
        return false;
    }",47,,85,2,,void
97870,BLOCK,1,,<empty>,,,,3,,void
97884,BLOCK,-1,,"{
        if ((long long) ull < 0) {
            /* only check for negative signs in the uncommon case when
             * the unsigned number is so big that it's negative as a
             * signed number. */
            if (strchr(str, '-') != NULL) {
                return false;
            }
        }
        *out = ull;
        return true;
    }",66,,89,2,,void
97891,BLOCK,-1,,"{
            /* only check for negative signs in the uncommon case when
             * the unsigned number is so big that it's negative as a
             * signed number. */
            if (strchr(str, '-') != NULL) {
                return false;
            }
        }",34,,90,2,,void
97898,BLOCK,-1,,"{
                return false;
            }",43,,94,2,,void
97914,BLOCK,-1,,"{
    assert(out != NULL);
    errno = 0;
    *out = 0;
    char *endptr;
    long long ll = strtoll(str, &endptr, 10);
    if ((errno == ERANGE) || (str == endptr)) {
        return false;
    }

    if (xisspace(*endptr) || (*endptr == '\0' && endptr != str)) {
        *out = ll;
        return true;
    }
    return false;
}",50,,104,3,,void
97943,BLOCK,-1,,"{
        return false;
    }",47,,110,2,,void
97951,BLOCK,1,,<empty>,,,,3,,void
97965,BLOCK,-1,,"{
        *out = ll;
        return true;
    }",66,,114,2,,void
97979,BLOCK,-1,,"{
    char *endptr = NULL;
    unsigned long l = 0;
    assert(out);
    assert(str);
    *out = 0;
    errno = 0;

    l = strtoul(str, &endptr, 10);
    if ((errno == ERANGE) || (str == endptr)) {
        return false;
    }

    if (xisspace(*endptr) || (*endptr == '\0' && endptr != str)) {
        if ((long) l < 0) {
            /* only check for negative signs in the uncommon case when
             * the unsigned number is so big that it's negative as a
             * signed number. */
            if (strchr(str, '-') != NULL) {
                return false;
            }
        }
        *out = l;
        return true;
    }

    return false;
}",51,,121,3,,void
98014,BLOCK,-1,,"{
        return false;
    }",47,,130,2,,void
98022,BLOCK,1,,<empty>,,,,3,,void
98036,BLOCK,-1,,"{
        if ((long) l < 0) {
            /* only check for negative signs in the uncommon case when
             * the unsigned number is so big that it's negative as a
             * signed number. */
            if (strchr(str, '-') != NULL) {
                return false;
            }
        }
        *out = l;
        return true;
    }",66,,134,2,,void
98043,BLOCK,-1,,"{
            /* only check for negative signs in the uncommon case when
             * the unsigned number is so big that it's negative as a
             * signed number. */
            if (strchr(str, '-') != NULL) {
                return false;
            }
        }",27,,135,2,,void
98050,BLOCK,-1,,"{
                return false;
            }",43,,139,2,,void
98066,BLOCK,-1,,"{
    assert(out != NULL);
    errno = 0;
    *out = 0;
    char *endptr;
    long l = strtol(str, &endptr, 10);
    if ((errno == ERANGE) || (str == endptr)) {
        return false;
    }

    if (xisspace(*endptr) || (*endptr == '\0' && endptr != str)) {
        *out = l;
        return true;
    }
    return false;
}",49,,150,3,,void
98095,BLOCK,-1,,"{
        return false;
    }",47,,156,2,,void
98103,BLOCK,1,,<empty>,,,,3,,void
98117,BLOCK,-1,,"{
        *out = l;
        return true;
    }",66,,160,2,,void
98131,BLOCK,-1,,"{
    assert(out != NULL);
    errno = 0;
    *out = 0;
    char *endptr;
    double d = strtod(str, &endptr);
    if ((errno == ERANGE) || (str == endptr)) {
        return false;
    }

    if (xisspace(*endptr) || (*endptr == '\0' && endptr != str)) {
        *out = d;
        return true;
    }
    return false;
}",48,,167,3,,void
98159,BLOCK,-1,,"{
        return false;
    }",47,,173,2,,void
98167,BLOCK,1,,<empty>,,,,3,,void
98181,BLOCK,-1,,"{
        *out = d;
        return true;
    }",66,,177,2,,void
98196,BLOCK,-1,,"{
   size_t x;

   for (x = 0; x < dstmax - 1 && src[x] != '\0'; x++) {
        dst[x] = src[x];
   }

   dst[x] = '\0';

   if (src[x] == '\0') {
       return true;
   } else {
       return false;
   }
}",67,,190,4,,void
98199,BLOCK,-1,,<empty>,4,,193,1,,void
98216,BLOCK,4,,"{
        dst[x] = src[x];
   }",55,,193,4,,void
98235,BLOCK,-1,,"{
       return true;
   }",24,,199,2,,void
98239,BLOCK,-1,,"{
       return false;
   }",11,,201,1,,void
98248,BLOCK,-1,,"{
    const volatile unsigned char *ua = (const volatile unsigned char *)a;
    const volatile unsigned char *ub = (const volatile unsigned char *)b;
    int delta = 0;
    size_t x;

    for (x = 0; x < len; x++) {
        delta |= ua[x] ^ ub[x];
    }

    if (delta == 0) {
        return true;
    } else {
        return false;
    }
}",60,,206,4,,void
98267,BLOCK,-1,,<empty>,5,,212,1,,void
98276,BLOCK,4,,"{
        delta |= ua[x] ^ ub[x];
    }",31,,212,4,,void
98290,BLOCK,-1,,"{
        return true;
    }",21,,216,2,,void
98294,BLOCK,-1,,"{
        return false;
    }",12,,218,1,,void
98301,BLOCK,-1,,"{
    int old_errno = errno;
    char buf[1024];
    va_list ap;

    va_start(ap, fmt);
    if (vsnprintf(buf, sizeof(buf), fmt, ap) == -1) {
        buf[sizeof(buf) - 1] = '\0';
    }
    va_end(ap);

    errno = old_errno;

    perror(buf);
}",36,,223,2,,void
98321,BLOCK,-1,,"{
        buf[sizeof(buf) - 1] = '\0';
    }",53,,229,2,,void
98341,BLOCK,-1,,"{
#ifdef ENDIAN_LITTLE
    /* Little endian, flip the bytes around until someone makes a faster/better
    * way to do this. */
    int64_t rv = 0;
    int i = 0;
     for(i = 0; i<8; i++) {
        rv = (rv << 8) | (in & 0xff);
        in >>= 8;
     }
    return rv;
#else
    /* big-endian machines don't need byte swapping */
    return in;
#endif
}",40,,240,2,,void
98348,BLOCK,-1,,"{
   return mc_swap64(val);
}",31,,257,2,,void
98356,BLOCK,-1,,"{
   return mc_swap64(val);
}",31,,261,2,,void
98368,BLOCK,-1,,<empty>,1,,1,1,,ANY
98371,BLOCK,-1,,<empty>,,,,2,,<empty>
98379,BLOCK,-1,,<empty>,,,,5,,<empty>
98385,BLOCK,-1,,<empty>,,,,3,,<empty>
98391,BLOCK,-1,,<empty>,,,,3,,<empty>
98397,BLOCK,-1,,<empty>,,,,3,,<empty>
98403,BLOCK,-1,,<empty>,,,,3,,<empty>
98409,BLOCK,-1,,<empty>,,,,3,,<empty>
98415,BLOCK,-1,,<empty>,,,,3,,<empty>
98422,BLOCK,-1,,<empty>,,,,4,,<empty>
98429,BLOCK,-1,,<empty>,,,,4,,<empty>
98434,BLOCK,-1,,<empty>,,,,2,,<empty>
98439,BLOCK,-1,,<empty>,,,,2,,<empty>
98444,BLOCK,-1,,<empty>,,,,2,,<empty>
98473,BLOCK,-1,,<empty>,1,,1,1,,ANY
98478,BLOCK,-1,,"{
    int status;
    mcmc_resp_t resp;
    char *val = NULL;

    do {
        int bread = recv(mcmc_fd(c), rbuf, bufsize, 0);

        // need to know how far to advance the buffer.
        // resp->reslen + resp->vlen_read works, but feels awkward.
        status = mcmc_parse_buf(c, rbuf, bread, &resp);
    } while (status == MCMC_WANT_READ);

    if (status != MCMC_OK) {
        printf(""bad response\n"");
    }

    // now we need to read the value back.
    // resp.reslen + resp.vlen is the total length.
    // resp.reslen + resp.vlen_read is how much of the buffer was used.
    // resp.vlen_read vs resp.vlen is how much was read vs how much still
    // needs to be read from the socket.
    if (resp.vlen != resp.vlen_read) {
        // malloc and recv the rest.
        // can/should add convenience functions for this?
        val = malloc(resp.vlen);
        memcpy(val, resp.value, resp.vlen_read);
        size_t toread = resp.vlen - resp.vlen_read;
        char *buf = val + re...",71,,16,4,,void
98486,BLOCK,-1,,"{
        int bread = recv(mcmc_fd(c), rbuf, bufsize, 0);

        // need to know how far to advance the buffer.
        // resp->reslen + resp->vlen_read works, but feels awkward.
        status = mcmc_parse_buf(c, rbuf, bread, &resp);
    }",8,,21,1,,void
98507,BLOCK,1,,<empty>,,,,1,,void
98513,BLOCK,1,,<empty>,,,,1,,void
98515,BLOCK,-1,,"{
        printf(""bad response\n"");
    }",28,,29,2,,void
98526,BLOCK,-1,,"{
        // malloc and recv the rest.
        // can/should add convenience functions for this?
        val = malloc(resp.vlen);
        memcpy(val, resp.value, resp.vlen_read);
        size_t toread = resp.vlen - resp.vlen_read;
        char *buf = val + resp.vlen_read;
        do {
            // TODO: bug: check for read == 0
            int read = recv(mcmc_fd(c), buf, toread, 0);
            toread -= read;
        } while (toread > 0);
    }",38,,38,2,,void
98560,BLOCK,-1,,"{
            // TODO: bug: check for read == 0
            int read = recv(mcmc_fd(c), buf, toread, 0);
            toread -= read;
        }",12,,45,1,,void
98577,BLOCK,-1,,"{
        val = resp.value;
    }",12,,50,1,,void
98590,BLOCK,-1,,"{
    void *c = malloc(mcmc_size(MCMC_OPTION_BLANK));
    size_t bufsize = mcmc_min_buffer_size(MCMC_OPTION_BLANK) * 2;
    char *rbuf = malloc(bufsize);

    int status = mcmc_connect(c, ""127.0.0.1"", ""11211"", MCMC_OPTION_BLANK);

    char *requests[5] = {""get foo\r\n"",
        ""get foob\r\n"",
        ""mg foo s t v\r\n"",
        ""mg doof s t v Omoo k\r\n"",
        """"};

    for (int x = 0; strlen(requests[x]) != 0; x++) {
        status = mcmc_send_request(c, requests[x], strlen(requests[x]), 1);

        if (status != MCMC_OK) {
            fprintf(stderr, ""Failed to send request to memcached\n"");
            return;
        }

        // Regardless of what command we sent, this should print out the response.
        show_response_buffer(c, rbuf, bufsize);
    }

}",24,,145,2,,void
98597,BLOCK,1,,<empty>,,,,1,,void
98605,BLOCK,1,,<empty>,,,,1,,void
98621,BLOCK,1,,<empty>,,,,1,,void
98633,BLOCK,-1,,<empty>,5,,158,1,,void
98646,BLOCK,4,,"{
        status = mcmc_send_request(c, requests[x], strlen(requests[x]), 1);

        if (status != MCMC_OK) {
            fprintf(stderr, ""Failed to send request to memcached\n"");
            return;
        }

        // Regardless of what command we sent, this should print out the response.
        show_response_buffer(c, rbuf, bufsize);
    }",52,,158,4,,void
98663,BLOCK,1,,<empty>,,,,1,,void
98665,BLOCK,-1,,"{
            fprintf(stderr, ""Failed to send request to memcached\n"");
            return;
        }",32,,161,2,,void
98679,BLOCK,-1,,"{
    // TODO: detect if C is pre-C11?
    printf(""C version: %ld\n"", __STDC_VERSION__);

    if (signal(SIGPIPE, SIG_IGN) == SIG_ERR) {
        perror(""signal"");
        exit(1);
    }
/*
    void *c = malloc(mcmc_size(MCMC_OPTION_BLANK));
    // we only ""need"" the minimum buf size.
    // buffers large enough to fit return values result in fewer syscalls.
    size_t bufsize = mcmc_min_buffer_size(MCMC_OPTION_BLANK) * 2;
    // buffers are also generally agnostic to clients. The buffer must be
    // held and re-used when required by the API. When the buffer is empty,
    // it may be released to a pool or reused with other connections.
    char *rbuf = malloc(bufsize);

    int status;

    // API is blocking by default.
    status = mcmc_connect(c, ""127.0.0.1"", ""11211"", MCMC_OPTION_BLANK);

    if (status != MCMC_CONNECTED) {
        // TODO: mc_strerr(c);
        fprintf(stderr, ""Failed to connect to memcached\n"");
        return -1;
    }

    char *requests[5] = {""get foo\r\n""...",34,,172,3,,void
98683,BLOCK,1,,<empty>,,,,1,,void
98691,BLOCK,-1,,"{
        perror(""signal"");
        exit(1);
    }",46,,176,2,,void
98729,BLOCK,-1,,<empty>,1,,1,1,,ANY
98746,BLOCK,-1,,"{
    char *buf = ctx->buffer_head;
    // we know that ""VALUE "" has matched, so skip that.
    char *p = buf+6;
    size_t l = ctx->buffer_request_len;

    // <key> <flags> <bytes> [<cas unique>]
    char *key = p;
    int keylen;
    p = memchr(p, ' ', l - 6);
    if (p == NULL) {
        // FIXME: these should return MCMC_ERR and set the internal parse
        // error code.
        return MCMC_PARSE_ERROR;
    }

    keylen = p - key;

    // convert flags into something useful.
    // FIXME: do we need to prevent overruns in strtoul?
    // we know for sure the line will eventually end in a \n.
    char *n = NULL;
    errno = 0;
    uint32_t flags = strtoul(p, &n, 10);
    if ((errno == ERANGE) || (p == n) || (*n != ' ')) {
        return MCMC_PARSE_ERROR;
    }
    p = n;

    errno = 0;
    uint32_t bytes = strtoul(p, &n, 10);
    if ((errno == ERANGE) || (p == n)) {
        return MCMC_PARSE_ERROR;
    }
    p = n;

    // If next byte is a space, we read the optional CAS v...",68,,54,3,,void
98782,BLOCK,-1,,"{
        // FIXME: these should return MCMC_ERR and set the internal parse
        // error code.
        return MCMC_PARSE_ERROR;
    }",20,,64,2,,void
98785,BLOCK,1,,<empty>,,,,1,,void
98820,BLOCK,-1,,"{
        return MCMC_PARSE_ERROR;
    }",55,,78,2,,void
98823,BLOCK,1,,<empty>,,,,1,,void
98847,BLOCK,-1,,"{
        return MCMC_PARSE_ERROR;
    }",40,,85,2,,void
98850,BLOCK,1,,<empty>,,,,1,,void
98864,BLOCK,-1,,"{
        errno = 0;
        cas = strtoull(p, &n, 10);
        if ((errno == ERANGE) || (p == n)) {
            return MCMC_PARSE_ERROR;
        }
    }",20,,92,2,,void
98883,BLOCK,-1,,"{
            return MCMC_PARSE_ERROR;
        }",44,,95,2,,void
98886,BLOCK,1,,<empty>,,,,1,,void
98915,BLOCK,-1,,"{
        r->vlen_read = r->vlen;
    }",35,,104,2,,void
98924,BLOCK,-1,,"{
        r->vlen_read = buffer_remain;
    }",12,,106,1,,void
98955,BLOCK,1,,<empty>,,,,1,,void
98962,BLOCK,1,,<empty>,,,,1,,void
98966,BLOCK,1,,<empty>,,,,1,,void
98973,BLOCK,-1,,"{
    char *buf = ctx->buffer_head;
    char *cur = buf;
    size_t l = ctx->buffer_request_len;
    int rlen; // response code length.
    int more = 0;
    r->reslen = ctx->buffer_request_len;
    r->type = MCMC_RESP_GENERIC;

    // walk until the \r\n
    while (l-- > 2) {
        if (*cur == ' ') {
            more = 1;
            break;
        }
        cur++;
    }
    rlen = cur - buf;

    // incr/decr returns a number with no code :(
    // not checking length first since buf must have at least one char to
    // enter this function.
    if (buf[0] >= '0' && buf[0] <= '9') {
        // TODO: parse it as a number on request.
        // TODO: validate whole thing as digits here?
        ctx->status_flags |= FLAG_BUF_IS_NUMERIC;
        r->type = MCMC_RESP_NUMERIC;
        return MCMC_OK;
    }

    if (rlen < 2) {
        ctx->error = MCMC_PARSE_ERROR_SHORT;
        return MCMC_ERR;
    }

    int rv = MCMC_OK;
    int code = MCMC_CODE_OK;
    switch (rlen) {
        case ...",66,,125,3,,void
99007,BLOCK,1,,<empty>,,,,1,,void
99014,BLOCK,-1,,"{
        if (*cur == ' ') {
            more = 1;
            break;
        }
        cur++;
    }",21,,135,2,,void
99020,BLOCK,-1,,"{
            more = 1;
            break;
        }",26,,136,2,,void
99044,BLOCK,-1,,"{
        // TODO: parse it as a number on request.
        // TODO: validate whole thing as digits here?
        ctx->status_flags |= FLAG_BUF_IS_NUMERIC;
        r->type = MCMC_RESP_NUMERIC;
        return MCMC_OK;
    }",41,,147,2,,void
99050,BLOCK,1,,<empty>,,,,1,,void
99057,BLOCK,1,,<empty>,,,,1,,void
99061,BLOCK,1,,<empty>,,,,1,,void
99067,BLOCK,-1,,"{
        ctx->error = MCMC_PARSE_ERROR_SHORT;
        return MCMC_ERR;
    }",19,,155,2,,void
99073,BLOCK,1,,<empty>,,,,1,,void
99077,BLOCK,1,,<empty>,,,,1,,void
99084,BLOCK,1,,<empty>,,,,1,,void
99090,BLOCK,1,,<empty>,,,,1,,void
99094,BLOCK,-1,,"{
        case 2:
            // meta, ""OK""
            // FIXME: adding new return codes would make the client completely
            // fail. The rest of the client is agnostic to requests/flags for
            // meta.
            // can we make it agnostic for return codes outside of ""read this
            // data"" types?
            // As-is it should fail down to the ""send the return code to the
            // user"". not sure that's right.
            r->type = MCMC_RESP_META;
            switch (buf[0]) {
            case 'E':
                if (buf[1] == 'N') {
                    code = MCMC_CODE_MISS;
                    // TODO: RESP type
                } else if (buf[1] == 'X') {
                    code = MCMC_CODE_EXISTS;
                }
                break;
            case 'H':
                if (buf[1] == 'D') {
                    // typical meta response.
                    code = MCMC_CODE_OK;
                }
                break;
            case 'M':...",19,,162,2,,void
99102,BLOCK,1,,<empty>,,,,1,,void
99108,BLOCK,-1,,"{
            case 'E':
                if (buf[1] == 'N') {
                    code = MCMC_CODE_MISS;
                    // TODO: RESP type
                } else if (buf[1] == 'X') {
                    code = MCMC_CODE_EXISTS;
                }
                break;
            case 'H':
                if (buf[1] == 'D') {
                    // typical meta response.
                    code = MCMC_CODE_OK;
                }
                break;
            case 'M':
                if (buf[1] == 'N') {
                    // specific return code so user can see pipeline end.
                    code = MCMC_CODE_NOP;
                } else if (buf[1] == 'E') {
                    // ME is the debug output line.
                    // TODO: this just gets returned as an rline?
                    // specific code? specific type?
                    // ME <key> <key=value debug line>
                    rv = MCMC_OK;
                }
                break;
            case ...",29,,173,2,,void
99117,BLOCK,-1,,"{
                    code = MCMC_CODE_MISS;
                    // TODO: RESP type
                }",36,,175,2,,void
99121,BLOCK,1,,<empty>,,,,1,,void
99124,BLOCK,-1,,<empty>,24,,178,1,,void
99131,BLOCK,-1,,"{
                    code = MCMC_CODE_EXISTS;
                }",43,,178,2,,void
99135,BLOCK,1,,<empty>,,,,1,,void
99146,BLOCK,-1,,"{
                    // typical meta response.
                    code = MCMC_CODE_OK;
                }",36,,183,2,,void
99150,BLOCK,1,,<empty>,,,,1,,void
99161,BLOCK,-1,,"{
                    // specific return code so user can see pipeline end.
                    code = MCMC_CODE_NOP;
                }",36,,189,2,,void
99165,BLOCK,1,,<empty>,,,,1,,void
99168,BLOCK,-1,,<empty>,24,,192,1,,void
99175,BLOCK,-1,,"{
                    // ME is the debug output line.
                    // TODO: this just gets returned as an rline?
                    // specific code? specific type?
                    // ME <key> <key=value debug line>
                    rv = MCMC_OK;
                }",43,,192,2,,void
99179,BLOCK,1,,<empty>,,,,1,,void
99190,BLOCK,-1,,"{
                    code = MCMC_CODE_NOT_FOUND;
                }",36,,201,2,,void
99194,BLOCK,1,,<empty>,,,,1,,void
99197,BLOCK,-1,,<empty>,24,,203,1,,void
99204,BLOCK,-1,,"{
                    code = MCMC_CODE_NOT_STORED;
                }",43,,203,2,,void
99208,BLOCK,1,,<empty>,,,,1,,void
99219,BLOCK,-1,,"{
                    // Used by many random management commands
                    r->type = MCMC_RESP_GENERIC;
                }",36,,208,2,,void
99225,BLOCK,1,,<empty>,,,,1,,void
99236,BLOCK,-1,,"{
                    // VA <size> <flags>*\r\n
                    if (more) {
                        errno = 0;
                        char *n = NULL;
                        uint32_t vsize = strtoul(cur, &n, 10);
                        if ((errno == ERANGE) || (cur == n)) {
                            rv = MCMC_ERR;
                        } else {
                            r->vlen = vsize + 2; // tag in the \r\n.
                            // FIXME: macro.
                            int buffer_remain = ctx->buffer_used - (r->value - ctx->buffer_head);
                            if (buffer_remain >= r->vlen) {
                                r->vlen_read = r->vlen;
                            } else {
                                r->vlen_read = buffer_remain;
                            }
                            cur = n;
                            if (*cur != ' ') {
                                more = 0;
                            }
                        }
 ...",36,,214,2,,void
99239,BLOCK,-1,,"{
                        errno = 0;
                        char *n = NULL;
                        uint32_t vsize = strtoul(cur, &n, 10);
                        if ((errno == ERANGE) || (cur == n)) {
                            rv = MCMC_ERR;
                        } else {
                            r->vlen = vsize + 2; // tag in the \r\n.
                            // FIXME: macro.
                            int buffer_remain = ctx->buffer_used - (r->value - ctx->buffer_head);
                            if (buffer_remain >= r->vlen) {
                                r->vlen_read = r->vlen;
                            } else {
                                r->vlen_read = buffer_remain;
                            }
                            cur = n;
                            if (*cur != ' ') {
                                more = 0;
                            }
                        }
                    }",31,,216,2,,void
99263,BLOCK,-1,,"{
                            rv = MCMC_ERR;
                        }",62,,220,2,,void
99267,BLOCK,1,,<empty>,,,,1,,void
99271,BLOCK,-1,,"{
                            r->vlen = vsize + 2; // tag in the \r\n.
                            // FIXME: macro.
                            int buffer_remain = ctx->buffer_used - (r->value - ctx->buffer_head);
                            if (buffer_remain >= r->vlen) {
                                r->vlen_read = r->vlen;
                            } else {
                                r->vlen_read = buffer_remain;
                            }
                            cur = n;
                            if (*cur != ' ') {
                                more = 0;
                            }
                        }",32,,222,1,,void
99299,BLOCK,-1,,"{
                                r->vlen_read = r->vlen;
                            }",59,,226,2,,void
99308,BLOCK,-1,,"{
                                r->vlen_read = buffer_remain;
                            }",36,,228,1,,void
99322,BLOCK,-1,,"{
                                more = 0;
                            }",46,,232,2,,void
99327,BLOCK,-1,,"{
                        rv = MCMC_ERR;
                    }",28,,236,1,,void
99331,BLOCK,1,,<empty>,,,,1,,void
99337,BLOCK,-1,,"{
                r->rline = cur+1; // eat the space.
                r->rlen = l-1;
            }",23,,244,2,,void
99353,BLOCK,-1,,"{
                r->rline = NULL;
                r->rlen = 0;
            }",20,,247,1,,void
99374,BLOCK,-1,,"{
                // Either end of STAT results, or end of ascii GET key list.
                ctx->state = STATE_DEFAULT;
                // FIXME: caller needs to understand if this is a real miss.
                code = MCMC_CODE_MISS;
                r->type = MCMC_RESP_END;
                rv = MCMC_OK;
            }",45,,253,2,,void
99380,BLOCK,1,,<empty>,,,,1,,void
99385,BLOCK,1,,<empty>,,,,1,,void
99392,BLOCK,1,,<empty>,,,,1,,void
99397,BLOCK,1,,<empty>,,,,1,,void
99409,BLOCK,-1,,"{
                r->type = MCMC_RESP_STAT;
                ctx->state = STATE_STAT_RESP;
                // TODO: initialize stat reader mode.
            }",46,,263,2,,void
99415,BLOCK,1,,<empty>,,,,1,,void
99422,BLOCK,1,,<empty>,,,,1,,void
99434,BLOCK,-1,,"{
                if (more) {
                    // <key> <flags> <bytes> [<cas unique>]
                    rv = _mcmc_parse_value_line(ctx, r);
                } else {
                    rv = MCMC_ERR; // FIXME: parse error.
                }
            }",47,,270,2,,void
99437,BLOCK,-1,,"{
                    // <key> <flags> <bytes> [<cas unique>]
                    rv = _mcmc_parse_value_line(ctx, r);
                }",27,,271,2,,void
99444,BLOCK,-1,,"{
                    rv = MCMC_ERR; // FIXME: parse error.
                }",24,,274,1,,void
99448,BLOCK,1,,<empty>,,,,1,,void
99461,BLOCK,-1,,"{
                code = MCMC_CODE_STORED;
            }",48,,280,2,,void
99465,BLOCK,1,,<empty>,,,,1,,void
99468,BLOCK,-1,,<empty>,20,,282,1,,void
99476,BLOCK,-1,,"{
                code = MCMC_CODE_EXISTS;
                // TODO: type -> ASCII?
            }",55,,282,2,,void
99480,BLOCK,1,,<empty>,,,,1,,void
99492,BLOCK,-1,,"{
                code = MCMC_CODE_DELETED;
            }",49,,288,2,,void
99496,BLOCK,1,,<empty>,,,,1,,void
99499,BLOCK,-1,,<empty>,20,,290,1,,void
99507,BLOCK,-1,,"{
                code = MCMC_CODE_TOUCHED;
            }",56,,290,2,,void
99511,BLOCK,1,,<empty>,,,,1,,void
99514,BLOCK,-1,,<empty>,20,,292,1,,void
99522,BLOCK,-1,,"{
                code = MCMC_CODE_VERSION;
                r->type = MCMC_RESP_VERSION;
                // TODO: prep the version line for return
            }",56,,292,2,,void
99526,BLOCK,1,,<empty>,,,,1,,void
99533,BLOCK,1,,<empty>,,,,1,,void
99545,BLOCK,-1,,"{
                code = MCMC_CODE_NOT_FOUND;
            }",51,,299,2,,void
99549,BLOCK,1,,<empty>,,,,1,,void
99561,BLOCK,-1,,"{
                code = MCMC_CODE_NOT_STORED;
            }",53,,304,2,,void
99565,BLOCK,1,,<empty>,,,,1,,void
99580,BLOCK,-1,,"{
        // TODO: Finish this.
        ctx->status_flags |= FLAG_BUF_IS_ERROR;
        rv = MCMC_ERR;
    }",19,,314,2,,void
99586,BLOCK,1,,<empty>,,,,1,,void
99591,BLOCK,1,,<empty>,,,,1,,void
99600,BLOCK,-1,,"{
    mcmc_ctx_t *ctx = (mcmc_ctx_t *)c;
    return ctx->fd;
}",22,,325,2,,void
99615,BLOCK,-1,,"{
    return sizeof(mcmc_ctx_t);
}",31,,330,2,,void
99623,BLOCK,-1,,"{
    return MIN_BUFFER_SIZE;
}",42,,337,2,,void
99626,BLOCK,1,,<empty>,,,,1,,void
99635,BLOCK,-1,,"{
    mcmc_ctx_t *ctx = c;
    char *el;

    el = memchr(buf, '\n', read);
    if (el == NULL) {
        return MCMC_WANT_READ;
    }

    memset(r, 0, sizeof(*r));

    // Consume through the newline, note where the value would start if exists
    r->value = el+1;

    ctx->buffer_used = read;
    // FIXME: the server must be stricter in what it sends back. should always
    // have a \r. check for it and fail?
    ctx->buffer_request_len = r->value - buf;
    // leave the \r\n in the line end cache.
    ctx->buffer_head = buf;

    return _mcmc_parse_response(ctx, r);
}",69,,347,5,,void
99651,BLOCK,-1,,"{
        return MCMC_WANT_READ;
    }",21,,352,2,,void
99654,BLOCK,1,,<empty>,,,,1,,void
99697,BLOCK,-1,,"{
    mcmc_ctx_t *ctx = (mcmc_ctx_t *)c;
    socklen_t errsize = sizeof(*err);
    if (getsockopt(ctx->fd, SOL_SOCKET, SO_ERROR, err, &errsize) == 0) {
        if (*err == 0) {
            return MCMC_OK;
        }
    } else {
        // getsockopt failed. still need to pass up the error.
        *err = errno;
    }

    return MCMC_ERR;
}",52,,376,3,,void
99722,BLOCK,-1,,"{
        if (*err == 0) {
            return MCMC_OK;
        }
    }",72,,379,2,,void
99728,BLOCK,-1,,"{
            return MCMC_OK;
        }",24,,380,2,,void
99731,BLOCK,1,,<empty>,,,,1,,void
99734,BLOCK,-1,,"{
        // getsockopt failed. still need to pass up the error.
        *err = errno;
    }",12,,383,1,,void
99741,BLOCK,1,,<empty>,,,,1,,void
99751,BLOCK,-1,,"{
    mcmc_ctx_t *ctx = (mcmc_ctx_t *)c;

    int s;
    int sock;
    int res = MCMC_CONNECTED;
    struct addrinfo hints;
    struct addrinfo *ai;
    struct addrinfo *next;

    // Since our cx memory was likely malloc'ed, ensure we start clear.
    memset(ctx, 0, sizeof(mcmc_ctx_t));
    memset(&hints, 0, sizeof(hints));
    hints.ai_family = AF_INET;
    hints.ai_socktype = SOCK_STREAM;

    s = getaddrinfo(host, port, &hints, &ai);

    if (s != 0) {
        hints.ai_family = AF_INET6;
        s = getaddrinfo(host, port, &hints, &ai);
        if (s != 0) {
            // TODO: gai_strerror(s)
            ctx->gai_status = s;
            res = MCMC_ERR;
            goto end;
        }
    }

    for (next = ai; next != NULL; next = next->ai_next) {
        sock = socket(next->ai_family, next->ai_socktype,
                next->ai_protocol);
        if (sock == -1)
            continue;

        if (options & MCMC_OPTION_TCP_KEEPALIVE) {
            int optval = 1;
            i...",64,,397,5,,void
99764,BLOCK,1,,<empty>,,,,1,,void
99803,BLOCK,-1,,"{
        hints.ai_family = AF_INET6;
        s = getaddrinfo(host, port, &hints, &ai);
        if (s != 0) {
            // TODO: gai_strerror(s)
            ctx->gai_status = s;
            res = MCMC_ERR;
            goto end;
        }
    }",17,,415,2,,void
99822,BLOCK,-1,,"{
            // TODO: gai_strerror(s)
            ctx->gai_status = s;
            res = MCMC_ERR;
            goto end;
        }",21,,418,2,,void
99831,BLOCK,1,,<empty>,,,,1,,void
99836,BLOCK,-1,,<empty>,5,,426,1,,void
99848,BLOCK,4,,"{
        sock = socket(next->ai_family, next->ai_socktype,
                next->ai_protocol);
        if (sock == -1)
            continue;

        if (options & MCMC_OPTION_TCP_KEEPALIVE) {
            int optval = 1;
            if (setsockopt(sock, SOL_SOCKET, SO_KEEPALIVE, &optval, sizeof(optval)) < 0) {
                res = MCMC_ERR;
                close(sock);
                goto end;
            }
        }

        if (options & MCMC_OPTION_NONBLOCK) {
            int flags = fcntl(sock, F_GETFL);
            if (flags < 0) {
                res = MCMC_ERR;
                close(sock);
                goto end;
            }
            if (fcntl(sock, F_SETFL, flags | O_NONBLOCK) < 0) {
                res = MCMC_ERR;
                close(sock);
                goto end;
            }
            res = MCMC_CONNECTING;

            if (connect(sock, next->ai_addr, next->ai_addrlen) != -1) {
                if (errno == EINPROGRESS) {
                    break; // We'...",57,,426,4,,void
99866,BLOCK,-1,,<empty>,13,,430,2,,void
99872,BLOCK,1,,<empty>,,,,1,,void
99876,BLOCK,-1,,"{
            int optval = 1;
            if (setsockopt(sock, SOL_SOCKET, SO_KEEPALIVE, &optval, sizeof(optval)) < 0) {
                res = MCMC_ERR;
                close(sock);
                goto end;
            }
        }",50,,432,2,,void
99892,BLOCK,-1,,"{
                res = MCMC_ERR;
                close(sock);
                goto end;
            }",90,,434,2,,void
99896,BLOCK,1,,<empty>,,,,1,,void
99906,BLOCK,1,,<empty>,,,,1,,void
99908,BLOCK,-1,,"{
            int flags = fcntl(sock, F_GETFL);
            if (flags < 0) {
                res = MCMC_ERR;
                close(sock);
                goto end;
            }
            if (fcntl(sock, F_SETFL, flags | O_NONBLOCK) < 0) {
                res = MCMC_ERR;
                close(sock);
                goto end;
            }
            res = MCMC_CONNECTING;

            if (connect(sock, next->ai_addr, next->ai_addrlen) != -1) {
                if (errno == EINPROGRESS) {
                    break; // We're good, stop the loop.
                }
            }

            break;
        }",45,,441,2,,void
99919,BLOCK,-1,,"{
                res = MCMC_ERR;
                close(sock);
                goto end;
            }",28,,443,2,,void
99923,BLOCK,1,,<empty>,,,,1,,void
99938,BLOCK,-1,,"{
                res = MCMC_ERR;
                close(sock);
                goto end;
            }",63,,448,2,,void
99942,BLOCK,1,,<empty>,,,,1,,void
99951,BLOCK,1,,<empty>,,,,1,,void
99965,BLOCK,-1,,"{
                if (errno == EINPROGRESS) {
                    break; // We're good, stop the loop.
                }
            }",71,,455,2,,void
99970,BLOCK,-1,,"{
                    break; // We're good, stop the loop.
                }",43,,456,2,,void
99974,BLOCK,-1,,"{
            // TODO: BIND local port.
            if (connect(sock, next->ai_addr, next->ai_addrlen) != -1)
                break;
        }",16,,462,1,,void
99987,BLOCK,-1,,<empty>,17,,465,2,,void
99995,BLOCK,-1,,"{
        res = MCMC_ERR;
        goto end;
    }",23,,472,2,,void
99999,BLOCK,1,,<empty>,,,,1,,void
100011,BLOCK,-1,,"{
        freeaddrinfo(ai);
    }",13,,479,2,,void
100023,BLOCK,-1,,"{
    mcmc_ctx_t *ctx = (mcmc_ctx_t *)c;

    // adjust our send buffer by how much has already been sent.
    const char *r = request + ctx->sent_bytes_partial;
    int l = len - ctx->sent_bytes_partial;
    int sent = send(ctx->fd, r, l, 0);
    if (sent == -1) {
        // implicitly handle nonblock mode.
        if (errno == EAGAIN || errno == EWOULDBLOCK) {
            return MCMC_WANT_WRITE;
        } else {
            return MCMC_ERR;
        }
    }

    if (sent < len) {
        // can happen anytime, but mostly in nonblocking mode.
        ctx->sent_bytes_partial += sent;
        return MCMC_WANT_WRITE;
    } else {
        ctx->sent_bytes_partial = 0;
    }

    return MCMC_OK;
}",73,,488,5,,void
100061,BLOCK,-1,,"{
        // implicitly handle nonblock mode.
        if (errno == EAGAIN || errno == EWOULDBLOCK) {
            return MCMC_WANT_WRITE;
        } else {
            return MCMC_ERR;
        }
    }",21,,495,2,,void
100070,BLOCK,-1,,"{
            return MCMC_WANT_WRITE;
        }",54,,497,2,,void
100073,BLOCK,1,,<empty>,,,,1,,void
100076,BLOCK,-1,,"{
            return MCMC_ERR;
        }",16,,499,1,,void
100079,BLOCK,1,,<empty>,,,,1,,void
100086,BLOCK,-1,,"{
        // can happen anytime, but mostly in nonblocking mode.
        ctx->sent_bytes_partial += sent;
        return MCMC_WANT_WRITE;
    }",21,,504,2,,void
100094,BLOCK,1,,<empty>,,,,1,,void
100097,BLOCK,-1,,"{
        ctx->sent_bytes_partial = 0;
    }",12,,508,1,,void
100105,BLOCK,1,,<empty>,,,,1,,void
100115,BLOCK,-1,,"{
    mcmc_ctx_t *ctx = (mcmc_ctx_t *)c;
    // need to track sent vs tosend to know when to update counters.
    ssize_t tosend = 0;
    for (int i = 0; i < iovcnt; i++) {
        tosend += iov[i].iov_len;
    }

    *sent = writev(ctx->fd, iov, iovcnt);
    if (*sent == -1) {
        // implicitly handle nonblock mode.
        if (errno == EAGAIN || errno == EWOULDBLOCK) {
            return MCMC_WANT_WRITE;
        } else {
            return MCMC_ERR;
        }
    }

    if (*sent < tosend) {
        // can happen anytime, but mostly in nonblocking mode.
        return MCMC_WANT_WRITE;
    }

    return MCMC_OK;
}",97,,518,6,,void
100127,BLOCK,-1,,<empty>,5,,522,1,,void
100137,BLOCK,4,,"{
        tosend += iov[i].iov_len;
    }",38,,522,4,,void
100160,BLOCK,-1,,"{
        // implicitly handle nonblock mode.
        if (errno == EAGAIN || errno == EWOULDBLOCK) {
            return MCMC_WANT_WRITE;
        } else {
            return MCMC_ERR;
        }
    }",22,,527,2,,void
100169,BLOCK,-1,,"{
            return MCMC_WANT_WRITE;
        }",54,,529,2,,void
100172,BLOCK,1,,<empty>,,,,1,,void
100175,BLOCK,-1,,"{
            return MCMC_ERR;
        }",16,,531,1,,void
100178,BLOCK,1,,<empty>,,,,1,,void
100186,BLOCK,-1,,"{
        // can happen anytime, but mostly in nonblocking mode.
        return MCMC_WANT_WRITE;
    }",25,,536,2,,void
100189,BLOCK,1,,<empty>,,,,1,,void
100193,BLOCK,1,,<empty>,,,,1,,void
100203,BLOCK,-1,,"{
    code[0] = '\0';
    msg[0] = '\0';
}",79,,609,6,,void
100218,BLOCK,-1,,"{
    mcmc_ctx_t *ctx = (mcmc_ctx_t *)c;

    // FIXME: I forget if 0 can be valid.
    if (ctx->fd != 0) {
        close(ctx->fd);
        return MCMC_OK;
    } else {
        return MCMC_NOT_CONNECTED;
    }
}",30,,659,2,,void
100231,BLOCK,-1,,"{
        close(ctx->fd);
        return MCMC_OK;
    }",23,,663,2,,void
100238,BLOCK,1,,<empty>,,,,1,,void
100241,BLOCK,-1,,"{
        return MCMC_NOT_CONNECTED;
    }",12,,666,1,,void
100244,BLOCK,1,,<empty>,,,,1,,void
100252,BLOCK,-1,,<empty>,1,,1,1,,ANY
100275,BLOCK,-1,,<empty>,,,,2,,<empty>
100280,BLOCK,-1,,<empty>,,,,2,,<empty>
100285,BLOCK,-1,,<empty>,,,,2,,<empty>
100293,BLOCK,-1,,<empty>,,,,5,,<empty>
100301,BLOCK,-1,,<empty>,,,,5,,<empty>
100307,BLOCK,-1,,<empty>,,,,3,,<empty>
100315,BLOCK,-1,,<empty>,,,,5,,<empty>
100324,BLOCK,-1,,<empty>,,,,6,,<empty>
100329,BLOCK,-1,,<empty>,,,,2,,<empty>
100338,BLOCK,-1,,<empty>,,,,6,,<empty>
100385,BLOCK,-1,,<empty>,1,,1,1,,ANY
100388,BLOCK,-1,,<empty>,,,,2,,<empty>
100395,BLOCK,-1,,<empty>,,,,1,,<empty>
100407,BLOCK,-1,,<empty>,,,,4,,<empty>
100414,BLOCK,-1,,<empty>,,,,2,,<empty>
100419,BLOCK,-1,,<empty>,,,,2,,<empty>
100425,BLOCK,-1,,<empty>,,,,3,,<empty>
100431,BLOCK,-1,,<empty>,,,,3,,<empty>
100438,BLOCK,-1,,<empty>,,,,4,,<empty>
100443,BLOCK,-1,,<empty>,,,,2,,<empty>
100449,BLOCK,-1,,<empty>,,,,1,,<empty>
100458,BLOCK,-1,,<empty>,,,,3,,<empty>
100463,BLOCK,-1,,<empty>,,,,2,,<empty>
100471,BLOCK,-1,,<empty>,,,,4,,<empty>
100478,BLOCK,-1,,<empty>,,,,2,,<empty>
100483,BLOCK,-1,,<empty>,,,,2,,<empty>
100489,BLOCK,-1,,<empty>,,,,3,,<empty>
100495,BLOCK,-1,,<empty>,,,,3,,<empty>
100502,BLOCK,-1,,<empty>,,,,4,,<empty>
100507,BLOCK,-1,,<empty>,,,,2,,<empty>
100513,BLOCK,-1,,<empty>,,,,1,,<empty>
100523,BLOCK,-1,,<empty>,,,,3,,<empty>
100528,BLOCK,-1,,<empty>,,,,2,,<empty>
100534,BLOCK,-1,,<empty>,,,,3,,<empty>
100541,BLOCK,-1,,<empty>,,,,4,,<empty>
100549,BLOCK,-1,,<empty>,,,,5,,<empty>
100556,BLOCK,-1,,<empty>,,,,2,,<empty>
100561,BLOCK,-1,,<empty>,,,,2,,<empty>
100567,BLOCK,-1,,<empty>,,,,3,,<empty>
100572,BLOCK,-1,,<empty>,,,,2,,<empty>
100578,BLOCK,-1,,<empty>,,,,3,,<empty>
100585,BLOCK,-1,,<empty>,,,,4,,<empty>
100592,BLOCK,-1,,<empty>,,,,4,,<empty>
100597,BLOCK,-1,,<empty>,,,,2,,<empty>
100607,BLOCK,-1,,<empty>,,,,3,,<empty>
100614,BLOCK,-1,,<empty>,,,,4,,<empty>
100622,BLOCK,-1,,<empty>,,,,5,,<empty>
100627,BLOCK,-1,,<empty>,,,,2,,<empty>
100633,BLOCK,-1,,<empty>,,,,3,,<empty>
100640,BLOCK,-1,,<empty>,,,,4,,<empty>
100647,BLOCK,-1,,<empty>,,,,4,,<empty>
100652,BLOCK,-1,,<empty>,,,,2,,<empty>
100658,BLOCK,-1,,<empty>,,,,3,,<empty>
100664,BLOCK,-1,,<empty>,,,,3,,<empty>
100670,BLOCK,-1,,<empty>,,,,1,,<empty>
100680,BLOCK,-1,,<empty>,,,,3,,<empty>
100685,BLOCK,-1,,<empty>,,,,2,,<empty>
102041,BLOCK,-1,,<empty>,,,,1,,ANY
102133,BLOCK,1,,<empty>,,,,1,,ANY
102136,BLOCK,1,,<empty>,,,,1,,ANY
102141,BLOCK,1,,<empty>,,,,1,,ANY
102145,BLOCK,1,,<empty>,,,,1,,ANY
102150,BLOCK,1,,<empty>,,,,1,,ANY
102155,BLOCK,1,,<empty>,,,,1,,ANY
102159,BLOCK,1,,<empty>,,,,1,,ANY
102163,BLOCK,1,,<empty>,,,,1,,ANY
102168,BLOCK,1,,<empty>,,,,1,,ANY
102172,BLOCK,1,,<empty>,,,,1,,ANY
102177,BLOCK,1,,<empty>,,,,1,,ANY
102182,BLOCK,1,,<empty>,,,,1,,ANY
102187,BLOCK,1,,<empty>,,,,1,,ANY
102192,BLOCK,1,,<empty>,,,,1,,ANY
102197,BLOCK,1,,<empty>,,,,1,,ANY
102201,BLOCK,1,,<empty>,,,,1,,ANY
102206,BLOCK,1,,<empty>,,,,1,,ANY
102211,BLOCK,1,,<empty>,,,,1,,ANY
102216,BLOCK,1,,<empty>,,,,1,,ANY
102221,BLOCK,1,,<empty>,,,,1,,ANY
102227,BLOCK,1,,<empty>,,,,1,,ANY
102231,BLOCK,1,,<empty>,,,,1,,ANY
102236,BLOCK,1,,<empty>,,,,1,,ANY
102240,BLOCK,1,,<empty>,,,,1,,ANY
102246,BLOCK,1,,<empty>,,,,1,,ANY
102250,BLOCK,1,,<empty>,,,,1,,ANY
102254,BLOCK,1,,<empty>,,,,1,,ANY
102259,BLOCK,1,,<empty>,,,,1,,ANY
102264,BLOCK,1,,<empty>,,,,1,,ANY
102269,BLOCK,1,,<empty>,,,,1,,ANY
102273,BLOCK,1,,<empty>,,,,1,,ANY
102278,BLOCK,1,,<empty>,,,,1,,ANY
102282,BLOCK,1,,<empty>,,,,1,,ANY
102287,BLOCK,1,,<empty>,,,,1,,ANY
102292,BLOCK,1,,<empty>,,,,1,,ANY
102295,BLOCK,1,,<empty>,,,,1,,ANY
102299,BLOCK,1,,<empty>,,,,1,,ANY
102303,BLOCK,1,,<empty>,,,,1,,ANY
102307,BLOCK,1,,<empty>,,,,1,,ANY
102310,BLOCK,1,,<empty>,,,,1,,ANY
102313,BLOCK,1,,<empty>,,,,1,,ANY
102317,BLOCK,1,,<empty>,,,,1,,ANY
102322,BLOCK,1,,<empty>,,,,1,,ANY
102326,BLOCK,1,,<empty>,,,,1,,ANY
102331,BLOCK,1,,<empty>,,,,1,,ANY
102335,BLOCK,1,,<empty>,,,,1,,ANY
102340,BLOCK,1,,<empty>,,,,1,,ANY
102343,BLOCK,1,,<empty>,,,,1,,ANY
102347,BLOCK,1,,<empty>,,,,1,,ANY
102351,BLOCK,1,,<empty>,,,,1,,ANY
102358,BLOCK,1,,<empty>,,,,1,,ANY
102362,BLOCK,1,,<empty>,,,,1,,ANY
102366,BLOCK,1,,<empty>,,,,1,,ANY
102371,BLOCK,1,,<empty>,,,,1,,ANY
102375,BLOCK,1,,<empty>,,,,1,,ANY
102378,BLOCK,1,,<empty>,,,,1,,ANY
102383,BLOCK,1,,<empty>,,,,1,,ANY
102388,BLOCK,1,,<empty>,,,,1,,ANY
102392,BLOCK,1,,<empty>,,,,1,,ANY
102396,BLOCK,1,,<empty>,,,,1,,ANY
102402,BLOCK,1,,<empty>,,,,1,,ANY
102405,BLOCK,1,,<empty>,,,,1,,ANY
102411,BLOCK,1,,<empty>,,,,1,,ANY
102415,BLOCK,1,,<empty>,,,,1,,ANY
102420,BLOCK,1,,<empty>,,,,1,,ANY
102425,BLOCK,1,,<empty>,,,,1,,ANY
102430,BLOCK,1,,<empty>,,,,1,,ANY
102434,BLOCK,1,,<empty>,,,,1,,ANY
102438,BLOCK,1,,<empty>,,,,1,,ANY
102442,BLOCK,1,,<empty>,,,,1,,ANY
102447,BLOCK,1,,<empty>,,,,1,,ANY
102451,BLOCK,1,,<empty>,,,,1,,ANY
102455,BLOCK,1,,<empty>,,,,1,,ANY
102459,BLOCK,1,,<empty>,,,,1,,ANY
102463,BLOCK,1,,<empty>,,,,1,,ANY
102467,BLOCK,1,,<empty>,,,,1,,ANY
102471,BLOCK,1,,<empty>,,,,1,,ANY
102475,BLOCK,1,,<empty>,,,,1,,ANY
102479,BLOCK,1,,<empty>,,,,1,,ANY
102482,BLOCK,1,,<empty>,,,,1,,ANY
102488,BLOCK,1,,<empty>,,,,1,,ANY
102491,BLOCK,1,,<empty>,,,,1,,ANY
102494,BLOCK,1,,<empty>,,,,1,,ANY
102498,BLOCK,1,,<empty>,,,,1,,ANY
102503,BLOCK,1,,<empty>,,,,1,,ANY
102506,BLOCK,1,,<empty>,,,,1,,ANY
102513,BLOCK,1,,<empty>,,,,1,,ANY
102517,BLOCK,1,,<empty>,,,,1,,ANY
102521,BLOCK,1,,<empty>,,,,1,,ANY
102525,BLOCK,1,,<empty>,,,,1,,ANY
102529,BLOCK,1,,<empty>,,,,1,,ANY
102532,BLOCK,1,,<empty>,,,,1,,ANY
102538,BLOCK,1,,<empty>,,,,1,,ANY
102544,BLOCK,1,,<empty>,,,,1,,ANY
102548,BLOCK,1,,<empty>,,,,1,,ANY
102556,BLOCK,1,,<empty>,,,,1,,ANY
102559,BLOCK,1,,<empty>,,,,1,,ANY
102567,BLOCK,1,,<empty>,,,,1,,ANY
102572,BLOCK,1,,<empty>,,,,1,,ANY
102575,BLOCK,1,,<empty>,,,,1,,ANY
102581,BLOCK,1,,<empty>,,,,1,,ANY
102586,BLOCK,1,,<empty>,,,,1,,ANY
102592,BLOCK,1,,<empty>,,,,1,,ANY
102595,BLOCK,1,,<empty>,,,,1,,ANY
102598,BLOCK,1,,<empty>,,,,1,,ANY
102601,BLOCK,1,,<empty>,,,,1,,ANY
102604,BLOCK,1,,<empty>,,,,1,,ANY
102607,BLOCK,1,,<empty>,,,,1,,ANY
102612,BLOCK,1,,<empty>,,,,1,,ANY
102615,BLOCK,1,,<empty>,,,,1,,ANY
102620,BLOCK,1,,<empty>,,,,1,,ANY
102625,BLOCK,1,,<empty>,,,,1,,ANY
102628,BLOCK,1,,<empty>,,,,1,,ANY
102632,BLOCK,1,,<empty>,,,,1,,ANY
102635,BLOCK,1,,<empty>,,,,1,,ANY
102639,BLOCK,1,,<empty>,,,,1,,ANY
102643,BLOCK,1,,<empty>,,,,1,,ANY
102649,BLOCK,1,,<empty>,,,,1,,ANY
102654,BLOCK,1,,<empty>,,,,1,,ANY
102658,BLOCK,1,,<empty>,,,,1,,ANY
102662,BLOCK,1,,<empty>,,,,1,,ANY
102666,BLOCK,1,,<empty>,,,,1,,ANY
102672,BLOCK,1,,<empty>,,,,1,,ANY
102677,BLOCK,1,,<empty>,,,,1,,ANY
102682,BLOCK,1,,<empty>,,,,1,,ANY
102687,BLOCK,1,,<empty>,,,,1,,ANY
102693,BLOCK,1,,<empty>,,,,1,,ANY
102699,BLOCK,1,,<empty>,,,,1,,ANY
102705,BLOCK,1,,<empty>,,,,1,,ANY
102712,BLOCK,1,,<empty>,,,,1,,ANY
102719,BLOCK,1,,<empty>,,,,1,,ANY
102722,BLOCK,1,,<empty>,,,,1,,ANY
102727,BLOCK,1,,<empty>,,,,1,,ANY
102730,BLOCK,1,,<empty>,,,,1,,ANY
102733,BLOCK,1,,<empty>,,,,1,,ANY
102738,BLOCK,1,,<empty>,,,,1,,ANY
102741,BLOCK,1,,<empty>,,,,1,,ANY
102744,BLOCK,1,,<empty>,,,,1,,ANY
102747,BLOCK,1,,<empty>,,,,1,,ANY
102750,BLOCK,1,,<empty>,,,,1,,ANY
102753,BLOCK,1,,<empty>,,,,1,,ANY
102757,BLOCK,1,,<empty>,,,,1,,ANY
102761,BLOCK,1,,<empty>,,,,1,,ANY
102764,BLOCK,1,,<empty>,,,,1,,ANY
102767,BLOCK,1,,<empty>,,,,1,,ANY
102772,BLOCK,1,,<empty>,,,,1,,ANY
102777,BLOCK,1,,<empty>,,,,1,,ANY
102781,BLOCK,1,,<empty>,,,,1,,ANY
102784,BLOCK,1,,<empty>,,,,1,,ANY
102787,BLOCK,1,,<empty>,,,,1,,ANY
102790,BLOCK,1,,<empty>,,,,1,,ANY
102793,BLOCK,1,,<empty>,,,,1,,ANY
102799,BLOCK,1,,<empty>,,,,1,,ANY
102804,BLOCK,1,,<empty>,,,,1,,ANY
102810,BLOCK,1,,<empty>,,,,1,,ANY
102818,BLOCK,1,,<empty>,,,,1,,ANY
102823,BLOCK,1,,<empty>,,,,1,,ANY
102827,BLOCK,1,,<empty>,,,,1,,ANY
102830,BLOCK,1,,<empty>,,,,1,,ANY
102835,BLOCK,1,,<empty>,,,,1,,ANY
102838,BLOCK,1,,<empty>,,,,1,,ANY
102841,BLOCK,1,,<empty>,,,,1,,ANY
102844,BLOCK,1,,<empty>,,,,1,,ANY
102847,BLOCK,1,,<empty>,,,,1,,ANY
102851,BLOCK,1,,<empty>,,,,1,,ANY
102854,BLOCK,1,,<empty>,,,,1,,ANY
102857,BLOCK,1,,<empty>,,,,1,,ANY
102862,BLOCK,1,,<empty>,,,,1,,ANY
102865,BLOCK,1,,<empty>,,,,1,,ANY
102870,BLOCK,1,,<empty>,,,,1,,ANY
102875,BLOCK,1,,<empty>,,,,1,,ANY
102880,BLOCK,1,,<empty>,,,,1,,ANY
102887,BLOCK,1,,<empty>,,,,1,,ANY
102892,BLOCK,1,,<empty>,,,,1,,ANY
102898,BLOCK,1,,<empty>,,,,1,,ANY
102905,BLOCK,1,,<empty>,,,,1,,ANY
102910,BLOCK,1,,<empty>,,,,1,,ANY
102917,BLOCK,1,,<empty>,,,,1,,ANY
102921,BLOCK,1,,<empty>,,,,1,,ANY
102924,BLOCK,1,,<empty>,,,,1,,ANY
102927,BLOCK,1,,<empty>,,,,1,,ANY
102930,BLOCK,1,,<empty>,,,,1,,ANY
102933,BLOCK,1,,<empty>,,,,1,,ANY
102936,BLOCK,1,,<empty>,,,,1,,ANY
102939,BLOCK,1,,<empty>,,,,1,,ANY
102942,BLOCK,1,,<empty>,,,,1,,ANY
102945,BLOCK,1,,<empty>,,,,1,,ANY
102951,BLOCK,1,,<empty>,,,,1,,ANY
102954,BLOCK,1,,<empty>,,,,1,,ANY
102961,BLOCK,1,,<empty>,,,,1,,ANY
102964,BLOCK,1,,<empty>,,,,1,,ANY
102967,BLOCK,1,,<empty>,,,,1,,ANY
102972,BLOCK,1,,<empty>,,,,1,,ANY
102977,BLOCK,1,,<empty>,,,,1,,ANY
102982,BLOCK,1,,<empty>,,,,1,,ANY
102987,BLOCK,1,,<empty>,,,,1,,ANY
102995,BLOCK,1,,<empty>,,,,1,,ANY
102999,BLOCK,1,,<empty>,,,,1,,ANY
103007,BLOCK,1,,<empty>,,,,1,,ANY
103015,BLOCK,1,,<empty>,,,,1,,ANY
103023,BLOCK,1,,<empty>,,,,1,,ANY
103031,BLOCK,1,,<empty>,,,,1,,ANY
103034,BLOCK,1,,<empty>,,,,1,,ANY
103040,BLOCK,1,,<empty>,,,,1,,ANY
103046,BLOCK,1,,<empty>,,,,1,,ANY
103051,BLOCK,1,,<empty>,,,,1,,ANY
103056,BLOCK,1,,<empty>,,,,1,,ANY
103060,BLOCK,1,,<empty>,,,,1,,ANY
103063,BLOCK,1,,<empty>,,,,1,,ANY
103067,BLOCK,1,,<empty>,,,,1,,ANY
103070,BLOCK,1,,<empty>,,,,1,,ANY
103073,BLOCK,1,,<empty>,,,,1,,ANY
103076,BLOCK,1,,<empty>,,,,1,,ANY
103079,BLOCK,1,,<empty>,,,,1,,ANY
103083,BLOCK,1,,<empty>,,,,1,,ANY
103089,BLOCK,1,,<empty>,,,,1,,ANY
103093,BLOCK,1,,<empty>,,,,1,,ANY
103097,BLOCK,1,,<empty>,,,,1,,ANY
103101,BLOCK,1,,<empty>,,,,1,,ANY
103104,BLOCK,1,,<empty>,,,,1,,ANY
103108,BLOCK,1,,<empty>,,,,1,,ANY
103113,BLOCK,1,,<empty>,,,,1,,ANY
103121,BLOCK,1,,<empty>,,,,1,,ANY
103126,BLOCK,1,,<empty>,,,,1,,ANY
103129,BLOCK,1,,<empty>,,,,1,,ANY
103134,BLOCK,1,,<empty>,,,,1,,ANY
103139,BLOCK,1,,<empty>,,,,1,,ANY
103145,BLOCK,1,,<empty>,,,,1,,ANY
103148,BLOCK,1,,<empty>,,,,1,,ANY
103152,BLOCK,1,,<empty>,,,,1,,ANY
103155,BLOCK,1,,<empty>,,,,1,,ANY
103158,BLOCK,1,,<empty>,,,,1,,ANY
103163,BLOCK,1,,<empty>,,,,1,,ANY
103166,BLOCK,1,,<empty>,,,,1,,ANY
103172,BLOCK,1,,<empty>,,,,1,,ANY
103176,BLOCK,1,,<empty>,,,,1,,ANY
103180,BLOCK,1,,<empty>,,,,1,,ANY
103185,BLOCK,1,,<empty>,,,,1,,ANY
103189,BLOCK,1,,<empty>,,,,1,,ANY
103192,BLOCK,1,,<empty>,,,,1,,ANY
103195,BLOCK,1,,<empty>,,,,1,,ANY
103198,BLOCK,1,,<empty>,,,,1,,ANY
103201,BLOCK,1,,<empty>,,,,1,,ANY
103204,BLOCK,1,,<empty>,,,,1,,ANY
103207,BLOCK,1,,<empty>,,,,1,,ANY
103210,BLOCK,1,,<empty>,,,,1,,ANY
103215,BLOCK,1,,<empty>,,,,1,,ANY
103218,BLOCK,1,,<empty>,,,,1,,ANY
103221,BLOCK,1,,<empty>,,,,1,,ANY
103224,BLOCK,1,,<empty>,,,,1,,ANY
103229,BLOCK,1,,<empty>,,,,1,,ANY
103232,BLOCK,1,,<empty>,,,,1,,ANY
103238,BLOCK,1,,<empty>,,,,1,,ANY
103244,BLOCK,1,,<empty>,,,,1,,ANY
103249,BLOCK,1,,<empty>,,,,1,,ANY
103252,BLOCK,1,,<empty>,,,,1,,ANY
103261,BLOCK,1,,<empty>,,,,1,,ANY
103267,BLOCK,1,,<empty>,,,,1,,ANY
103272,BLOCK,1,,<empty>,,,,1,,ANY
103277,BLOCK,1,,<empty>,,,,1,,ANY
103280,BLOCK,1,,<empty>,,,,1,,ANY
103283,BLOCK,1,,<empty>,,,,1,,ANY
103286,BLOCK,1,,<empty>,,,,1,,ANY
103289,BLOCK,1,,<empty>,,,,1,,ANY
103292,BLOCK,1,,<empty>,,,,1,,ANY
103298,BLOCK,1,,<empty>,,,,1,,ANY
103301,BLOCK,1,,<empty>,,,,1,,ANY
103306,BLOCK,1,,<empty>,,,,1,,ANY
103312,BLOCK,1,,<empty>,,,,1,,ANY
103320,BLOCK,1,,<empty>,,,,1,,ANY
103323,BLOCK,1,,<empty>,,,,1,,ANY
103331,BLOCK,1,,<empty>,,,,1,,ANY
103338,BLOCK,1,,<empty>,,,,1,,ANY
103342,BLOCK,1,,<empty>,,,,1,,ANY
103345,BLOCK,1,,<empty>,,,,1,,ANY
103351,BLOCK,1,,<empty>,,,,1,,ANY
103355,BLOCK,1,,<empty>,,,,1,,ANY
103358,BLOCK,1,,<empty>,,,,1,,ANY
103363,BLOCK,1,,<empty>,,,,1,,ANY
103368,BLOCK,1,,<empty>,,,,1,,ANY
103372,BLOCK,1,,<empty>,,,,1,,ANY
103376,BLOCK,1,,<empty>,,,,1,,ANY
103380,BLOCK,1,,<empty>,,,,1,,ANY
103385,BLOCK,1,,<empty>,,,,1,,ANY
103388,BLOCK,1,,<empty>,,,,1,,ANY
103391,BLOCK,1,,<empty>,,,,1,,ANY
103396,BLOCK,1,,<empty>,,,,1,,ANY
103401,BLOCK,1,,<empty>,,,,1,,ANY
103406,BLOCK,1,,<empty>,,,,1,,ANY
103410,BLOCK,1,,<empty>,,,,1,,ANY
103413,BLOCK,1,,<empty>,,,,1,,ANY
103416,BLOCK,1,,<empty>,,,,1,,ANY
103421,BLOCK,1,,<empty>,,,,1,,ANY
103426,BLOCK,1,,<empty>,,,,1,,ANY
103432,BLOCK,1,,<empty>,,,,1,,ANY
103438,BLOCK,1,,<empty>,,,,1,,ANY
103443,BLOCK,1,,<empty>,,,,1,,ANY
103447,BLOCK,1,,<empty>,,,,1,,ANY
103453,BLOCK,1,,<empty>,,,,1,,ANY
103458,BLOCK,1,,<empty>,,,,1,,ANY
103461,BLOCK,1,,<empty>,,,,1,,ANY
103464,BLOCK,1,,<empty>,,,,1,,ANY
103468,BLOCK,1,,<empty>,,,,1,,ANY
103473,BLOCK,1,,<empty>,,,,1,,ANY
103477,BLOCK,1,,<empty>,,,,1,,ANY
103481,BLOCK,1,,<empty>,,,,1,,ANY
103484,BLOCK,1,,<empty>,,,,1,,ANY
103487,BLOCK,1,,<empty>,,,,1,,ANY
103492,BLOCK,1,,<empty>,,,,1,,ANY
103496,BLOCK,1,,<empty>,,,,1,,ANY
103499,BLOCK,1,,<empty>,,,,1,,ANY
103504,BLOCK,1,,<empty>,,,,1,,ANY
103508,BLOCK,1,,<empty>,,,,1,,ANY
103511,BLOCK,1,,<empty>,,,,1,,ANY
103517,BLOCK,1,,<empty>,,,,1,,ANY
103520,BLOCK,1,,<empty>,,,,1,,ANY
103525,BLOCK,1,,<empty>,,,,1,,ANY
103528,BLOCK,1,,<empty>,,,,1,,ANY
103531,BLOCK,1,,<empty>,,,,1,,ANY
103534,BLOCK,1,,<empty>,,,,1,,ANY
103537,BLOCK,1,,<empty>,,,,1,,ANY
103540,BLOCK,1,,<empty>,,,,1,,ANY
103543,BLOCK,1,,<empty>,,,,1,,ANY
103546,BLOCK,1,,<empty>,,,,1,,ANY
103550,BLOCK,1,,<empty>,,,,1,,ANY
103554,BLOCK,1,,<empty>,,,,1,,ANY
103558,BLOCK,1,,<empty>,,,,1,,ANY
103562,BLOCK,1,,<empty>,,,,1,,ANY
103565,BLOCK,1,,<empty>,,,,1,,ANY
103568,BLOCK,1,,<empty>,,,,1,,ANY
103572,BLOCK,1,,<empty>,,,,1,,ANY
103576,BLOCK,1,,<empty>,,,,1,,ANY
103579,BLOCK,1,,<empty>,,,,1,,ANY
103584,BLOCK,1,,<empty>,,,,1,,ANY
103589,BLOCK,1,,<empty>,,,,1,,ANY
103595,BLOCK,1,,<empty>,,,,1,,ANY
103600,BLOCK,1,,<empty>,,,,1,,ANY
103606,BLOCK,1,,<empty>,,,,1,,ANY
103612,BLOCK,1,,<empty>,,,,1,,ANY
103615,BLOCK,1,,<empty>,,,,1,,ANY
103620,BLOCK,1,,<empty>,,,,1,,ANY
103626,BLOCK,1,,<empty>,,,,1,,ANY
103631,BLOCK,1,,<empty>,,,,1,,ANY
103637,BLOCK,1,,<empty>,,,,1,,ANY
103642,BLOCK,1,,<empty>,,,,1,,ANY
103646,BLOCK,1,,<empty>,,,,1,,ANY
103652,BLOCK,1,,<empty>,,,,1,,ANY
103655,BLOCK,1,,<empty>,,,,1,,ANY
103658,BLOCK,1,,<empty>,,,,1,,ANY
103661,BLOCK,1,,<empty>,,,,1,,ANY
103668,BLOCK,1,,<empty>,,,,1,,ANY
103673,BLOCK,1,,<empty>,,,,1,,ANY
103679,BLOCK,1,,<empty>,,,,1,,ANY
103685,BLOCK,1,,<empty>,,,,1,,ANY
103690,BLOCK,1,,<empty>,,,,1,,ANY
103695,BLOCK,1,,<empty>,,,,1,,ANY
103700,BLOCK,1,,<empty>,,,,1,,ANY
103705,BLOCK,1,,<empty>,,,,1,,ANY
103708,BLOCK,1,,<empty>,,,,1,,ANY
103711,BLOCK,1,,<empty>,,,,1,,ANY
103714,BLOCK,1,,<empty>,,,,1,,ANY
103717,BLOCK,1,,<empty>,,,,1,,ANY
103721,BLOCK,1,,<empty>,,,,1,,ANY
103724,BLOCK,1,,<empty>,,,,1,,ANY
103730,BLOCK,1,,<empty>,,,,1,,ANY
103735,BLOCK,1,,<empty>,,,,1,,ANY
103740,BLOCK,1,,<empty>,,,,1,,ANY
103743,BLOCK,1,,<empty>,,,,1,,ANY
103746,BLOCK,1,,<empty>,,,,1,,ANY
103750,BLOCK,1,,<empty>,,,,1,,ANY
103755,BLOCK,1,,<empty>,,,,1,,ANY
103760,BLOCK,1,,<empty>,,,,1,,ANY
103765,BLOCK,1,,<empty>,,,,1,,ANY
103769,BLOCK,1,,<empty>,,,,1,,ANY
103776,BLOCK,1,,<empty>,,,,1,,ANY
103781,BLOCK,1,,<empty>,,,,1,,ANY
103784,BLOCK,1,,<empty>,,,,1,,ANY
103788,BLOCK,1,,<empty>,,,,1,,ANY
103791,BLOCK,1,,<empty>,,,,1,,ANY
103795,BLOCK,1,,<empty>,,,,1,,ANY
103798,BLOCK,1,,<empty>,,,,1,,ANY
103803,BLOCK,1,,<empty>,,,,1,,ANY
103806,BLOCK,1,,<empty>,,,,1,,ANY
103809,BLOCK,1,,<empty>,,,,1,,ANY
103812,BLOCK,1,,<empty>,,,,1,,ANY
103815,BLOCK,1,,<empty>,,,,1,,ANY
103818,BLOCK,1,,<empty>,,,,1,,ANY
103821,BLOCK,1,,<empty>,,,,1,,ANY
103824,BLOCK,1,,<empty>,,,,1,,ANY
103827,BLOCK,1,,<empty>,,,,1,,ANY
103833,BLOCK,1,,<empty>,,,,1,,ANY
103839,BLOCK,1,,<empty>,,,,1,,ANY
103842,BLOCK,1,,<empty>,,,,1,,ANY
103845,BLOCK,1,,<empty>,,,,1,,ANY
103848,BLOCK,1,,<empty>,,,,1,,ANY
103854,BLOCK,1,,<empty>,,,,1,,ANY
103858,BLOCK,1,,<empty>,,,,1,,ANY
103863,BLOCK,1,,<empty>,,,,1,,ANY
103868,BLOCK,1,,<empty>,,,,1,,ANY
103873,BLOCK,1,,<empty>,,,,1,,ANY
103878,BLOCK,1,,<empty>,,,,1,,ANY
103883,BLOCK,1,,<empty>,,,,1,,ANY
103887,BLOCK,1,,<empty>,,,,1,,ANY
103891,BLOCK,1,,<empty>,,,,1,,ANY
103897,BLOCK,1,,<empty>,,,,1,,ANY
103903,BLOCK,1,,<empty>,,,,1,,ANY
103908,BLOCK,1,,<empty>,,,,1,,ANY
103913,BLOCK,1,,<empty>,,,,1,,ANY
103918,BLOCK,1,,<empty>,,,,1,,ANY
103922,BLOCK,1,,<empty>,,,,1,,ANY
103927,BLOCK,1,,<empty>,,,,1,,ANY
103934,BLOCK,1,,<empty>,,,,1,,ANY
103941,BLOCK,1,,<empty>,,,,1,,ANY
103946,BLOCK,1,,<empty>,,,,1,,ANY
103951,BLOCK,1,,<empty>,,,,1,,ANY
103956,BLOCK,1,,<empty>,,,,1,,ANY
103962,BLOCK,1,,<empty>,,,,1,,ANY
103967,BLOCK,1,,<empty>,,,,1,,ANY
103972,BLOCK,1,,<empty>,,,,1,,ANY
103977,BLOCK,1,,<empty>,,,,1,,ANY
103982,BLOCK,1,,<empty>,,,,1,,ANY
103988,BLOCK,1,,<empty>,,,,1,,ANY
103993,BLOCK,1,,<empty>,,,,1,,ANY
103998,BLOCK,1,,<empty>,,,,1,,ANY
104003,BLOCK,1,,<empty>,,,,1,,ANY
104008,BLOCK,1,,<empty>,,,,1,,ANY
104016,BLOCK,1,,<empty>,,,,1,,ANY
104021,BLOCK,1,,<empty>,,,,1,,ANY
104026,BLOCK,1,,<empty>,,,,1,,ANY
104031,BLOCK,1,,<empty>,,,,1,,ANY
104036,BLOCK,1,,<empty>,,,,1,,ANY
104042,BLOCK,1,,<empty>,,,,1,,ANY
104047,BLOCK,1,,<empty>,,,,1,,ANY
104052,BLOCK,1,,<empty>,,,,1,,ANY
104056,BLOCK,1,,<empty>,,,,1,,ANY
104059,BLOCK,1,,<empty>,,,,1,,ANY
104062,BLOCK,1,,<empty>,,,,1,,ANY
104065,BLOCK,1,,<empty>,,,,1,,ANY
104068,BLOCK,1,,<empty>,,,,1,,ANY
104071,BLOCK,1,,<empty>,,,,1,,ANY
104074,BLOCK,1,,<empty>,,,,1,,ANY
104080,BLOCK,1,,<empty>,,,,1,,ANY
104086,BLOCK,1,,<empty>,,,,1,,ANY
104092,BLOCK,1,,<empty>,,,,1,,ANY
104097,BLOCK,1,,<empty>,,,,1,,ANY
104100,BLOCK,1,,<empty>,,,,1,,ANY
104106,BLOCK,1,,<empty>,,,,1,,ANY
104114,BLOCK,1,,<empty>,,,,1,,ANY
104121,BLOCK,1,,<empty>,,,,1,,ANY
104127,BLOCK,1,,<empty>,,,,1,,ANY
104132,BLOCK,1,,<empty>,,,,1,,ANY
104137,BLOCK,1,,<empty>,,,,1,,ANY
104141,BLOCK,1,,<empty>,,,,1,,ANY
104144,BLOCK,1,,<empty>,,,,1,,ANY
104149,BLOCK,1,,<empty>,,,,1,,ANY
104154,BLOCK,1,,<empty>,,,,1,,ANY
104161,BLOCK,1,,<empty>,,,,1,,ANY
104165,BLOCK,1,,<empty>,,,,1,,ANY
104168,BLOCK,1,,<empty>,,,,1,,ANY
104173,BLOCK,1,,<empty>,,,,1,,ANY
104179,BLOCK,1,,<empty>,,,,1,,ANY
104184,BLOCK,1,,<empty>,,,,1,,ANY
104189,BLOCK,1,,<empty>,,,,1,,ANY
104192,BLOCK,1,,<empty>,,,,1,,ANY
104196,BLOCK,1,,<empty>,,,,1,,ANY
104202,BLOCK,1,,<empty>,,,,1,,ANY
104211,BLOCK,1,,<empty>,,,,1,,ANY
104214,BLOCK,1,,<empty>,,,,1,,ANY
104217,BLOCK,1,,<empty>,,,,1,,ANY
104220,BLOCK,1,,<empty>,,,,1,,ANY
104223,BLOCK,1,,<empty>,,,,1,,ANY
104226,BLOCK,1,,<empty>,,,,1,,ANY
104229,BLOCK,1,,<empty>,,,,1,,ANY
104235,BLOCK,1,,<empty>,,,,1,,ANY
104242,BLOCK,1,,<empty>,,,,1,,ANY
104245,BLOCK,1,,<empty>,,,,1,,ANY
104250,BLOCK,1,,<empty>,,,,1,,ANY
104254,BLOCK,1,,<empty>,,,,1,,ANY
104258,BLOCK,1,,<empty>,,,,1,,ANY
104261,BLOCK,1,,<empty>,,,,1,,ANY
104264,BLOCK,1,,<empty>,,,,1,,ANY
104267,BLOCK,1,,<empty>,,,,1,,ANY
104270,BLOCK,1,,<empty>,,,,1,,ANY
104273,BLOCK,1,,<empty>,,,,1,,ANY
104276,BLOCK,1,,<empty>,,,,1,,ANY
104279,BLOCK,1,,<empty>,,,,1,,ANY
104282,BLOCK,1,,<empty>,,,,1,,ANY
104288,BLOCK,1,,<empty>,,,,1,,ANY
104291,BLOCK,1,,<empty>,,,,1,,ANY
104298,BLOCK,1,,<empty>,,,,1,,ANY
104302,BLOCK,1,,<empty>,,,,1,,ANY
104305,BLOCK,1,,<empty>,,,,1,,ANY
104312,BLOCK,1,,<empty>,,,,1,,ANY
104318,BLOCK,1,,<empty>,,,,1,,ANY
104325,BLOCK,1,,<empty>,,,,1,,ANY
104328,BLOCK,1,,<empty>,,,,1,,ANY
104337,BLOCK,1,,<empty>,,,,1,,ANY
104343,BLOCK,1,,<empty>,,,,1,,ANY
104348,BLOCK,1,,<empty>,,,,1,,ANY
104351,BLOCK,1,,<empty>,,,,1,,ANY
104354,BLOCK,1,,<empty>,,,,1,,ANY
104357,BLOCK,1,,<empty>,,,,1,,ANY
104360,BLOCK,1,,<empty>,,,,1,,ANY
104363,BLOCK,1,,<empty>,,,,1,,ANY
104366,BLOCK,1,,<empty>,,,,1,,ANY
104369,BLOCK,1,,<empty>,,,,1,,ANY
104372,BLOCK,1,,<empty>,,,,1,,ANY
104375,BLOCK,1,,<empty>,,,,1,,ANY
104378,BLOCK,1,,<empty>,,,,1,,ANY
104382,BLOCK,1,,<empty>,,,,1,,ANY
104388,BLOCK,1,,<empty>,,,,1,,ANY
104392,BLOCK,1,,<empty>,,,,1,,ANY
104396,BLOCK,1,,<empty>,,,,1,,ANY
104401,BLOCK,1,,<empty>,,,,1,,ANY
104405,BLOCK,1,,<empty>,,,,1,,ANY
104411,BLOCK,1,,<empty>,,,,1,,ANY
104414,BLOCK,1,,<empty>,,,,1,,ANY
104418,BLOCK,1,,<empty>,,,,1,,ANY
104424,BLOCK,1,,<empty>,,,,1,,ANY
104428,BLOCK,1,,<empty>,,,,1,,ANY
104432,BLOCK,1,,<empty>,,,,1,,ANY
104438,BLOCK,1,,<empty>,,,,1,,ANY
104442,BLOCK,1,,<empty>,,,,1,,ANY
104446,BLOCK,1,,<empty>,,,,1,,ANY
104450,BLOCK,1,,<empty>,,,,1,,ANY
104454,BLOCK,1,,<empty>,,,,1,,ANY
104457,BLOCK,1,,<empty>,,,,1,,ANY
104461,BLOCK,1,,<empty>,,,,1,,ANY
104464,BLOCK,1,,<empty>,,,,1,,ANY
104469,BLOCK,1,,<empty>,,,,1,,ANY
104472,BLOCK,1,,<empty>,,,,1,,ANY
104475,BLOCK,1,,<empty>,,,,1,,ANY
104479,BLOCK,1,,<empty>,,,,1,,ANY
104483,BLOCK,1,,<empty>,,,,1,,ANY
104487,BLOCK,1,,<empty>,,,,1,,ANY
104491,BLOCK,1,,<empty>,,,,1,,ANY
104495,BLOCK,1,,<empty>,,,,1,,ANY
104500,BLOCK,1,,<empty>,,,,1,,ANY
104504,BLOCK,1,,<empty>,,,,1,,ANY
104508,BLOCK,1,,<empty>,,,,1,,ANY
104514,BLOCK,1,,<empty>,,,,1,,ANY
104520,BLOCK,1,,<empty>,,,,1,,ANY
104525,BLOCK,1,,<empty>,,,,1,,ANY
104528,BLOCK,1,,<empty>,,,,1,,ANY
104531,BLOCK,1,,<empty>,,,,1,,ANY
104534,BLOCK,1,,<empty>,,,,1,,ANY
104537,BLOCK,1,,<empty>,,,,1,,ANY
104540,BLOCK,1,,<empty>,,,,1,,ANY
104543,BLOCK,1,,<empty>,,,,1,,ANY
104546,BLOCK,1,,<empty>,,,,1,,ANY
104549,BLOCK,1,,<empty>,,,,1,,ANY
104552,BLOCK,1,,<empty>,,,,1,,ANY
104555,BLOCK,1,,<empty>,,,,1,,ANY
104558,BLOCK,1,,<empty>,,,,1,,ANY
104561,BLOCK,1,,<empty>,,,,1,,ANY
104564,BLOCK,1,,<empty>,,,,1,,ANY
104567,BLOCK,1,,<empty>,,,,1,,ANY
104570,BLOCK,1,,<empty>,,,,1,,ANY
104573,BLOCK,1,,<empty>,,,,1,,ANY
104576,BLOCK,1,,<empty>,,,,1,,ANY
104579,BLOCK,1,,<empty>,,,,1,,ANY
104582,BLOCK,1,,<empty>,,,,1,,ANY
104589,BLOCK,1,,<empty>,,,,1,,ANY
104592,BLOCK,1,,<empty>,,,,1,,ANY
104595,BLOCK,1,,<empty>,,,,1,,ANY
