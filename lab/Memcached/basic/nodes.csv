,Id,Name,NodeType,Fullname,Signature,Filename,Code,LineNumber,LineNumberEnd,ColumnNumber,ColumnNumberEnd,LineOfCode,NumberOfOperators,SetOfOperators,NumberOfOperands,SetOfOperands,FanIn,FanOut,McCabe,AccCyc,ConCf,ConDf,ConZc,ConRf,ConVal,Parma,ParmaIn,ParmaOut,RetType
0,102045,assoc.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1,102046,assoc.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2,102047,authfile.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3,102048,authfile.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4,102049,base64.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5,102050,base64.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
6,102051,bipbuffer.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7,102052,bipbuffer.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8,102053,cache.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
9,102054,cache.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
10,102055,crawler.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
11,102056,crawler.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
12,102057,crc32c.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
13,102058,crc32c.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
14,102059,daemon.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
15,102060,darwin_priv.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
16,102061,extstore.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
17,102062,extstore.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
18,102063,freebsd_priv.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
19,102064,globals.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
20,102065,hash.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
21,102066,hash.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
22,102067,items.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
23,102068,items.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
24,102069,itoa_ljust.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
25,102070,itoa_ljust.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
26,102071,jenkins_hash.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
27,102072,jenkins_hash.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
28,102073,linux_priv.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
29,102074,logger.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
30,102075,logger.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
31,102076,md5.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
32,102077,md5.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
33,102078,memcached.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
34,102079,memcached.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
35,102080,murmur3_hash.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
36,102081,murmur3_hash.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
37,102082,openbsd_priv.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
38,102083,proto_bin.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
39,102084,proto_bin.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
40,102085,proto_proxy.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
41,102086,proto_proxy.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
42,102087,proto_text.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
43,102088,proto_text.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
44,102089,protocol_binary.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
45,102090,proxy.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
46,102091,proxy_await.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
47,102092,proxy_config.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
48,102093,proxy_jump_hash.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
49,102094,proxy_lua.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
50,102095,proxy_network.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
51,102096,proxy_request.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
52,102097,proxy_ring_hash.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
53,102098,proxy_ustats.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
54,102099,proxy_xxhash.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
55,102100,queue.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
56,102101,restart.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
57,102102,restart.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
58,102103,sasl_defs.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
59,102104,sasl_defs.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
60,102105,sizes.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
61,102106,slab_automove.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
62,102107,slab_automove.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
63,102108,slab_automove_extstore.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
64,102109,slab_automove_extstore.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
65,102110,slabs.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
66,102111,slabs.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
67,102112,solaris_priv.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
68,102113,stats_prefix.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
69,102114,stats_prefix.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
70,102115,storage.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
71,102116,storage.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
72,102117,testapp.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
73,102118,thread.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
74,102119,timedrun.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
75,102120,tls.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
76,102121,tls.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
77,102122,trace.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
78,102123,util.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
79,102124,util.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
80,102125,vendor\mcmc\example.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
81,102126,vendor\mcmc\mcmc.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
82,102127,vendor\mcmc\mcmc.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
83,102128,xxhash.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
84,862,bucket,3,assoc_iterator.bucket,,assoc.c,bucket,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
85,863,it,3,assoc_iterator.it,,assoc.c,*it,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
86,864,next,3,assoc_iterator.next,,assoc.c,*next,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
87,865,bucket_locked,3,assoc_iterator.bucket_locked,,assoc.c,bucket_locked,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
88,1163,user,3,auth_entry.user,,authfile.c,*user,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
89,1164,ulen,3,auth_entry.ulen,,authfile.c,ulen,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
90,1165,pass,3,auth_entry.pass,,authfile.c,*pass,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
91,1166,plen,3,auth_entry.plen,,authfile.c,plen,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
92,1497,AUTHFILE_OK,3,authfile_ret.AUTHFILE_OK,,authfile.h,AUTHFILE_OK = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
93,1498,AUTHFILE_OOM,3,authfile_ret.AUTHFILE_OOM,,authfile.h,AUTHFILE_OOM,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
94,1499,AUTHFILE_STATFAIL,3,authfile_ret.AUTHFILE_STATFAIL,,authfile.h,AUTHFILE_STATFAIL,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
95,1500,AUTHFILE_OPENFAIL,3,authfile_ret.AUTHFILE_OPENFAIL,,authfile.h,AUTHFILE_OPENFAIL,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
96,1501,AUTHFILE_MALFORMED,3,authfile_ret.AUTHFILE_MALFORMED,,authfile.h,AUTHFILE_MALFORMED,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
97,2710,size,3,bipbuf_t.size,,bipbuffer.h,size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
98,2711,a_start,3,bipbuf_t.a_start,,bipbuffer.h,a_start,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,14,0,1,1,0,0,,0,0,0,0,0,
99,2712,a_end,3,bipbuf_t.a_end,,bipbuffer.h,a_end,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
100,2713,b_end,3,bipbuf_t.b_end,,bipbuffer.h,b_end,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
101,2714,b_inuse,3,bipbuf_t.b_inuse,,bipbuffer.h,b_inuse,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
102,2715,data,3,bipbuf_t.data,,bipbuffer.h,data[],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
103,3395,stqe_next,3,cache_free_s.c_next.stqe_next,,cache.h,cache_free_s *,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
104,3396,c_next,3,cache_free_s.c_next,,cache.h,c_next,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
105,3398,mutex,3,cache_t.mutex,,cache.h,mutex,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
106,3399,name,3,cache_t.name,,cache.h,*name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
107,3402,stqh_first,3,cache_t.cache_head.stqh_first,,cache.h,cache_free_s *,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
108,3404,stqh_last,3,cache_t.cache_head.stqh_last,,cache.h,cache_free_s * *,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
109,3405,head,3,cache_t.head,,cache.h,head,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,20,0,1,1,0,0,,0,0,0,0,0,
110,3406,bufsize,3,cache_t.bufsize,,cache.h,bufsize,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
111,3407,freetotal,3,cache_t.freetotal,,cache.h,freetotal,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
112,3408,total,3,cache_t.total,,cache.h,total,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
113,3409,freecurr,3,cache_t.freecurr,,cache.h,freecurr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
114,3410,limit,3,cache_t.limit,,cache.h,limit,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
115,3490,c,3,crawler_client_t.c,,crawler.c,*c,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
116,3491,sfd,3,crawler_client_t.sfd,,crawler.c,sfd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
117,3492,buf,3,crawler_client_t.buf,,crawler.c,*buf,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
118,3493,cbuf,3,crawler_client_t.cbuf,,crawler.c,*cbuf,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
119,3528,init,3,crawler_module_reg_t.init,,crawler.c,init,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
120,3529,eval,3,crawler_module_reg_t.eval,,crawler.c,eval,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
121,3530,doneclass,3,crawler_module_reg_t.doneclass,,crawler.c,doneclass,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
122,3531,finalize,3,crawler_module_reg_t.finalize,,crawler.c,finalize,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
123,3532,needs_lock,3,crawler_module_reg_t.needs_lock,,crawler.c,needs_lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
124,3533,needs_client,3,crawler_module_reg_t.needs_client,,crawler.c,needs_client,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
125,3536,data,3,_crawler_module_t.data,,crawler.c,*data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
126,3537,c,3,_crawler_module_t.c,,crawler.c,c,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
127,3538,mod,3,_crawler_module_t.mod,,crawler.c,*mod,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
128,6050,histo,3,crawlerstats_t.histo,,crawler.h,histo[61],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
129,6051,ttl_hourplus,3,crawlerstats_t.ttl_hourplus,,crawler.h,ttl_hourplus,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
130,6052,noexp,3,crawlerstats_t.noexp,,crawler.h,noexp,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
131,6053,reclaimed,3,crawlerstats_t.reclaimed,,crawler.h,reclaimed,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
132,6054,seen,3,crawlerstats_t.seen,,crawler.h,seen,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
133,6055,start_time,3,crawlerstats_t.start_time,,crawler.h,start_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
134,6056,end_time,3,crawlerstats_t.end_time,,crawler.h,end_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
135,6057,run_complete,3,crawlerstats_t.run_complete,,crawler.h,run_complete,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
136,6066,lock,3,crawler_expired_data.lock,,crawler.h,lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
137,6067,crawlerstats,3,crawler_expired_data.crawlerstats,,crawler.h,crawlerstats[POWER_LARGEST],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
138,6068,start_time,3,crawler_expired_data.start_time,,crawler.h,start_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
139,6069,end_time,3,crawler_expired_data.end_time,,crawler.h,end_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
140,6070,crawl_complete,3,crawler_expired_data.crawl_complete,,crawler.h,crawl_complete,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
141,6071,is_external,3,crawler_expired_data.is_external,,crawler.h,is_external,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
142,6079,CRAWLER_OK,3,crawler_result_type.CRAWLER_OK,,crawler.h,CRAWLER_OK=0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
143,6080,CRAWLER_RUNNING,3,crawler_result_type.CRAWLER_RUNNING,,crawler.h,CRAWLER_RUNNING,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
144,6081,CRAWLER_BADCLASS,3,crawler_result_type.CRAWLER_BADCLASS,,crawler.h,CRAWLER_BADCLASS,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
145,6082,CRAWLER_NOTSTARTED,3,crawler_result_type.CRAWLER_NOTSTARTED,,crawler.h,CRAWLER_NOTSTARTED,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
146,6083,CRAWLER_ERROR,3,crawler_result_type.CRAWLER_ERROR,,crawler.h,CRAWLER_ERROR,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
147,7236,next,3,__store_wbuf.next,,extstore.c,*next,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
148,7237,buf,3,__store_wbuf.buf,,extstore.c,*buf,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
149,7238,buf_pos,3,__store_wbuf.buf_pos,,extstore.c,*buf_pos,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
150,7239,free,3,__store_wbuf.free,,extstore.c,free,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
151,7240,size,3,__store_wbuf.size,,extstore.c,size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
152,7241,offset,3,__store_wbuf.offset,,extstore.c,offset,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
153,7242,full,3,__store_wbuf.full,,extstore.c,full,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
154,7243,flushed,3,__store_wbuf.flushed,,extstore.c,flushed,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
155,7246,mutex,3,_store_page.mutex,,extstore.c,mutex,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
156,7247,obj_count,3,_store_page.obj_count,,extstore.c,obj_count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
157,7248,bytes_used,3,_store_page.bytes_used,,extstore.c,bytes_used,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
158,7249,offset,3,_store_page.offset,,extstore.c,offset,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
159,7250,version,3,_store_page.version,,extstore.c,version,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
160,7251,refcount,3,_store_page.refcount,,extstore.c,refcount,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
161,7252,allocated,3,_store_page.allocated,,extstore.c,allocated,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
162,7253,written,3,_store_page.written,,extstore.c,written,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
163,7254,bucket,3,_store_page.bucket,,extstore.c,bucket,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
164,7255,free_bucket,3,_store_page.free_bucket,,extstore.c,free_bucket,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
165,7256,fd,3,_store_page.fd,,extstore.c,fd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
166,7257,id,3,_store_page.id,,extstore.c,id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
167,7258,active,3,_store_page.active,,extstore.c,active,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
168,7259,closed,3,_store_page.closed,,extstore.c,closed,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
169,7260,free,3,_store_page.free,,extstore.c,free,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
170,7261,wbuf,3,_store_page.wbuf,,extstore.c,*wbuf,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
171,7263,next,3,_store_page.next,,extstore.c,*next,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
172,7268,mutex,3,store_io_thread.mutex,,extstore.c,mutex,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
173,7269,cond,3,store_io_thread.cond,,extstore.c,cond,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
174,7270,queue,3,store_io_thread.queue,,extstore.c,*queue,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
175,7271,queue_tail,3,store_io_thread.queue_tail,,extstore.c,*queue_tail,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
176,7272,e,3,store_io_thread.e,,extstore.c,*e,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
177,7273,depth,3,store_io_thread.depth,,extstore.c,depth,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
178,7276,mutex,3,store_maint_thread.mutex,,extstore.c,mutex,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
179,7277,cond,3,store_maint_thread.cond,,extstore.c,cond,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
180,7278,e,3,store_maint_thread.e,,extstore.c,*e,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
181,7281,mutex,3,store_engine.mutex,,extstore.c,mutex,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,17,0,1,1,0,0,,0,0,0,0,0,
182,7282,pages,3,store_engine.pages,,extstore.c,*pages,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,16,0,1,1,0,0,,0,0,0,0,0,
183,7283,wbuf_stack,3,store_engine.wbuf_stack,,extstore.c,*wbuf_stack,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
184,7284,io_stack,3,store_engine.io_stack,,extstore.c,*io_stack,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
185,7285,io_threads,3,store_engine.io_threads,,extstore.c,*io_threads,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
186,7286,maint_thread,3,store_engine.maint_thread,,extstore.c,*maint_thread,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
187,7287,page_freelist,3,store_engine.page_freelist,,extstore.c,*page_freelist,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
188,7288,page_buckets,3,store_engine.page_buckets,,extstore.c,**page_buckets,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
189,7289,free_page_buckets,3,store_engine.free_page_buckets,,extstore.c,**free_page_buckets,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
190,7290,page_size,3,store_engine.page_size,,extstore.c,page_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
191,7291,version,3,store_engine.version,,extstore.c,version,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
192,7292,last_io_thread,3,store_engine.last_io_thread,,extstore.c,last_io_thread,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
193,7293,io_threadcount,3,store_engine.io_threadcount,,extstore.c,io_threadcount,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
194,7294,page_count,3,store_engine.page_count,,extstore.c,page_count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
195,7295,page_free,3,store_engine.page_free,,extstore.c,page_free,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
196,7296,page_bucketcount,3,store_engine.page_bucketcount,,extstore.c,page_bucketcount,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
197,7297,free_page_bucketcount,3,store_engine.free_page_bucketcount,,extstore.c,free_page_bucketcount,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
198,7298,io_depth,3,store_engine.io_depth,,extstore.c,io_depth,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
199,7299,stats_mutex,3,store_engine.stats_mutex,,extstore.c,stats_mutex,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
200,7301,stats,3,store_engine.stats,,extstore.c,stats,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,15,0,1,1,0,0,,0,0,0,0,0,
201,10672,version,3,extstore_page_data.version,,extstore.h,version,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
202,10673,bytes_used,3,extstore_page_data.bytes_used,,extstore.h,bytes_used,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
203,10674,bucket,3,extstore_page_data.bucket,,extstore.h,bucket,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
204,10675,free_bucket,3,extstore_page_data.free_bucket,,extstore.h,free_bucket,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
205,10677,page_allocs,3,extstore_stats.page_allocs,,extstore.h,page_allocs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
206,10678,page_count,3,extstore_stats.page_count,,extstore.h,page_count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
207,10679,page_evictions,3,extstore_stats.page_evictions,,extstore.h,page_evictions,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
208,10680,page_reclaims,3,extstore_stats.page_reclaims,,extstore.h,page_reclaims,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
209,10681,page_size,3,extstore_stats.page_size,,extstore.h,page_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
210,10682,pages_free,3,extstore_stats.pages_free,,extstore.h,pages_free,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
211,10683,pages_used,3,extstore_stats.pages_used,,extstore.h,pages_used,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
212,10684,objects_evicted,3,extstore_stats.objects_evicted,,extstore.h,objects_evicted,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
213,10685,objects_read,3,extstore_stats.objects_read,,extstore.h,objects_read,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
214,10686,objects_written,3,extstore_stats.objects_written,,extstore.h,objects_written,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
215,10687,objects_used,3,extstore_stats.objects_used,,extstore.h,objects_used,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
216,10688,bytes_evicted,3,extstore_stats.bytes_evicted,,extstore.h,bytes_evicted,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
217,10689,bytes_written,3,extstore_stats.bytes_written,,extstore.h,bytes_written,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
218,10690,bytes_read,3,extstore_stats.bytes_read,,extstore.h,bytes_read,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
219,10691,bytes_used,3,extstore_stats.bytes_used,,extstore.h,bytes_used,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
220,10692,bytes_fragmented,3,extstore_stats.bytes_fragmented,,extstore.h,bytes_fragmented,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
221,10693,io_queue,3,extstore_stats.io_queue,,extstore.h,io_queue,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
222,10695,page_data,3,extstore_stats.page_data,,extstore.h,*page_data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
223,10697,page_size,3,extstore_conf.page_size,,extstore.h,page_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
224,10698,page_count,3,extstore_conf.page_count,,extstore.h,page_count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
225,10699,page_buckets,3,extstore_conf.page_buckets,,extstore.h,page_buckets,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
226,10700,free_page_buckets,3,extstore_conf.free_page_buckets,,extstore.h,free_page_buckets,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
227,10701,wbuf_size,3,extstore_conf.wbuf_size,,extstore.h,wbuf_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
228,10702,wbuf_count,3,extstore_conf.wbuf_count,,extstore.h,wbuf_count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
229,10703,io_threadcount,3,extstore_conf.io_threadcount,,extstore.h,io_threadcount,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
230,10704,io_depth,3,extstore_conf.io_depth,,extstore.h,io_depth,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
231,10706,page_count,3,extstore_conf_file.page_count,,extstore.h,page_count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
232,10707,file,3,extstore_conf_file.file,,extstore.h,*file,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
233,10708,fd,3,extstore_conf_file.fd,,extstore.h,fd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
234,10709,offset,3,extstore_conf_file.offset,,extstore.h,offset,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
235,10710,bucket,3,extstore_conf_file.bucket,,extstore.h,bucket,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
236,10711,free_bucket,3,extstore_conf_file.free_bucket,,extstore.h,free_bucket,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
237,10713,next,3,extstore_conf_file.next,,extstore.h,*next,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
238,10715,OBJ_IO_READ,3,obj_io_mode.OBJ_IO_READ,,extstore.h,OBJ_IO_READ = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
239,10716,OBJ_IO_WRITE,3,obj_io_mode.OBJ_IO_WRITE,,extstore.h,OBJ_IO_WRITE,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
240,10734,data,3,_obj_io.data,,extstore.h,*data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
241,10736,next,3,_obj_io.next,,extstore.h,*next,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
242,10737,buf,3,_obj_io.buf,,extstore.h,*buf,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
243,10739,iov,3,_obj_io.iov,,extstore.h,*iov,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
244,10740,iovcnt,3,_obj_io.iovcnt,,extstore.h,iovcnt,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
245,10741,page_version,3,_obj_io.page_version,,extstore.h,page_version,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
246,10742,len,3,_obj_io.len,,extstore.h,len,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
247,10743,offset,3,_obj_io.offset,,extstore.h,offset,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
248,10744,page_id,3,_obj_io.page_id,,extstore.h,page_id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
249,10746,mode,3,_obj_io.mode,,extstore.h,mode,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
250,10747,cb,3,_obj_io.cb,,extstore.h,cb,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
251,10749,EXTSTORE_INIT_BAD_WBUF_SIZE,3,extstore_res.EXTSTORE_INIT_BAD_WBUF_SIZE,,extstore.h,EXTSTORE_INIT_BAD_WBUF_SIZE = 1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
252,10750,EXTSTORE_INIT_NEED_MORE_WBUF,3,extstore_res.EXTSTORE_INIT_NEED_MORE_WBUF,,extstore.h,EXTSTORE_INIT_NEED_MORE_WBUF,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
253,10751,EXTSTORE_INIT_NEED_MORE_BUCKETS,3,extstore_res.EXTSTORE_INIT_NEED_MORE_BUCKETS,,extstore.h,EXTSTORE_INIT_NEED_MORE_BUCKETS,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
254,10752,EXTSTORE_INIT_PAGE_WBUF_ALIGNMENT,3,extstore_res.EXTSTORE_INIT_PAGE_WBUF_ALIGNMENT,,extstore.h,EXTSTORE_INIT_PAGE_WBUF_ALIGNMENT,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
255,10753,EXTSTORE_INIT_TOO_MANY_PAGES,3,extstore_res.EXTSTORE_INIT_TOO_MANY_PAGES,,extstore.h,EXTSTORE_INIT_TOO_MANY_PAGES,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
256,10754,EXTSTORE_INIT_OOM,3,extstore_res.EXTSTORE_INIT_OOM,,extstore.h,EXTSTORE_INIT_OOM,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
257,10755,EXTSTORE_INIT_OPEN_FAIL,3,extstore_res.EXTSTORE_INIT_OPEN_FAIL,,extstore.h,EXTSTORE_INIT_OPEN_FAIL,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
258,10756,EXTSTORE_INIT_THREAD_FAIL,3,extstore_res.EXTSTORE_INIT_THREAD_FAIL,,extstore.h,EXTSTORE_INIT_THREAD_FAIL,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
259,10962,JENKINS_HASH,3,hashfunc_type.JENKINS_HASH,,hash.h,JENKINS_HASH=0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
260,10963,MURMUR3_HASH,3,hashfunc_type.MURMUR3_HASH,,hash.h,MURMUR3_HASH,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
261,10964,XXH3_HASH,3,hashfunc_type.XXH3_HASH,,hash.h,XXH3_HASH,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
262,11047,evicted,3,itemstats_t.evicted,,items.c,evicted,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
263,11048,evicted_nonzero,3,itemstats_t.evicted_nonzero,,items.c,evicted_nonzero,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
264,11049,reclaimed,3,itemstats_t.reclaimed,,items.c,reclaimed,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
265,11050,outofmemory,3,itemstats_t.outofmemory,,items.c,outofmemory,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
266,11051,tailrepairs,3,itemstats_t.tailrepairs,,items.c,tailrepairs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
267,11052,expired_unfetched,3,itemstats_t.expired_unfetched,,items.c,expired_unfetched,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
268,11053,evicted_unfetched,3,itemstats_t.evicted_unfetched,,items.c,evicted_unfetched,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
269,11054,evicted_active,3,itemstats_t.evicted_active,,items.c,evicted_active,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
270,11055,crawler_reclaimed,3,itemstats_t.crawler_reclaimed,,items.c,crawler_reclaimed,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
271,11056,crawler_items_checked,3,itemstats_t.crawler_items_checked,,items.c,crawler_items_checked,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
272,11057,lrutail_reflocked,3,itemstats_t.lrutail_reflocked,,items.c,lrutail_reflocked,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
273,11058,moves_to_cold,3,itemstats_t.moves_to_cold,,items.c,moves_to_cold,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
274,11059,moves_to_warm,3,itemstats_t.moves_to_warm,,items.c,moves_to_warm,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
275,11060,moves_within_lru,3,itemstats_t.moves_within_lru,,items.c,moves_within_lru,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
276,11061,direct_reclaims,3,itemstats_t.direct_reclaims,,items.c,direct_reclaims,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
277,11062,hits_to_hot,3,itemstats_t.hits_to_hot,,items.c,hits_to_hot,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
278,11063,hits_to_warm,3,itemstats_t.hits_to_warm,,items.c,hits_to_warm,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
279,11064,hits_to_cold,3,itemstats_t.hits_to_cold,,items.c,hits_to_cold,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
280,11065,hits_to_temp,3,itemstats_t.hits_to_temp,,items.c,hits_to_temp,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
281,11066,mem_requested,3,itemstats_t.mem_requested,,items.c,mem_requested,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
282,11067,evicted_time,3,itemstats_t.evicted_time,,items.c,evicted_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
283,11198,prev,3,_lru_bump_buf.prev,,items.c,*prev,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
284,11200,next,3,_lru_bump_buf.next,,items.c,*next,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
285,11201,mutex,3,_lru_bump_buf.mutex,,items.c,mutex,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
286,11202,buf,3,_lru_bump_buf.buf,,items.c,*buf,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
287,11203,dropped,3,_lru_bump_buf.dropped,,items.c,dropped,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
288,11206,it,3,lru_bump_entry.it,,items.c,*it,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
289,11207,hv,3,lru_bump_entry.hv,,items.c,hv,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
290,18867,it,3,lru_pull_tail_return.it,,items.h,*it,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
291,18868,hv,3,lru_pull_tail_return.hv,,items.h,hv,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
292,18945,evicted,3,item_stats_automove.evicted,,items.h,evicted,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
293,18946,outofmemory,3,item_stats_automove.outofmemory,,items.h,outofmemory,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
294,18947,age,3,item_stats_automove.age,,items.h,age,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
295,22267,LOGGER_ASCII_CMD,3,log_entry_type.LOGGER_ASCII_CMD,,logger.h,LOGGER_ASCII_CMD = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
296,22268,LOGGER_EVICTION,3,log_entry_type.LOGGER_EVICTION,,logger.h,LOGGER_EVICTION,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
297,22269,LOGGER_ITEM_GET,3,log_entry_type.LOGGER_ITEM_GET,,logger.h,LOGGER_ITEM_GET,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
298,22270,LOGGER_ITEM_STORE,3,log_entry_type.LOGGER_ITEM_STORE,,logger.h,LOGGER_ITEM_STORE,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
299,22271,LOGGER_CRAWLER_STATUS,3,log_entry_type.LOGGER_CRAWLER_STATUS,,logger.h,LOGGER_CRAWLER_STATUS,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
300,22272,LOGGER_SLAB_MOVE,3,log_entry_type.LOGGER_SLAB_MOVE,,logger.h,LOGGER_SLAB_MOVE,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
301,22273,LOGGER_CONNECTION_NEW,3,log_entry_type.LOGGER_CONNECTION_NEW,,logger.h,LOGGER_CONNECTION_NEW,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
302,22274,LOGGER_CONNECTION_CLOSE,3,log_entry_type.LOGGER_CONNECTION_CLOSE,,logger.h,LOGGER_CONNECTION_CLOSE,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
303,22283,LOGGER_RET_OK,3,logger_ret_type.LOGGER_RET_OK,,logger.h,LOGGER_RET_OK = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
304,22284,LOGGER_RET_NOSPACE,3,logger_ret_type.LOGGER_RET_NOSPACE,,logger.h,LOGGER_RET_NOSPACE,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
305,22285,LOGGER_RET_ERR,3,logger_ret_type.LOGGER_RET_ERR,,logger.h,LOGGER_RET_ERR,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
306,22294,LOGGER_PARSE_ENTRY_OK,3,logger_parse_entry_ret.LOGGER_PARSE_ENTRY_OK,,logger.h,LOGGER_PARSE_ENTRY_OK = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
307,22295,LOGGER_PARSE_ENTRY_FULLBUF,3,logger_parse_entry_ret.LOGGER_PARSE_ENTRY_FULLBUF,,logger.h,LOGGER_PARSE_ENTRY_FULLBUF,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
308,22296,LOGGER_PARSE_ENTRY_FAILED,3,logger_parse_entry_ret.LOGGER_PARSE_ENTRY_FAILED,,logger.h,LOGGER_PARSE_ENTRY_FAILED,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
309,22323,reqlen,3,_entry_details.reqlen,,logger.h,reqlen,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
310,22324,eflags,3,_entry_details.eflags,,logger.h,eflags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
311,22325,log_cb,3,_entry_details.log_cb,,logger.h,log_cb,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
312,22326,parse_cb,3,_entry_details.parse_cb,,logger.h,parse_cb,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
313,22327,format,3,_entry_details.format,,logger.h,*format,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
314,22329,exptime,3,logentry_eviction.exptime,,logger.h,exptime,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
315,22330,nbytes,3,logentry_eviction.nbytes,,logger.h,nbytes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
316,22331,latime,3,logentry_eviction.latime,,logger.h,latime,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
317,22332,it_flags,3,logentry_eviction.it_flags,,logger.h,it_flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
318,22333,nkey,3,logentry_eviction.nkey,,logger.h,nkey,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
319,22334,clsid,3,logentry_eviction.clsid,,logger.h,clsid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
320,22335,key,3,logentry_eviction.key,,logger.h,key[],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
321,22342,was_found,3,logentry_item_get.was_found,,logger.h,was_found,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
322,22343,nkey,3,logentry_item_get.nkey,,logger.h,nkey,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
323,22344,clsid,3,logentry_item_get.clsid,,logger.h,clsid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
324,22345,nbytes,3,logentry_item_get.nbytes,,logger.h,nbytes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
325,22346,sfd,3,logentry_item_get.sfd,,logger.h,sfd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
326,22347,key,3,logentry_item_get.key,,logger.h,key[],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
327,22354,status,3,logentry_item_store.status,,logger.h,status,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
328,22355,cmd,3,logentry_item_store.cmd,,logger.h,cmd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
329,22356,ttl,3,logentry_item_store.ttl,,logger.h,ttl,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
330,22357,nkey,3,logentry_item_store.nkey,,logger.h,nkey,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
331,22358,clsid,3,logentry_item_store.clsid,,logger.h,clsid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
332,22359,nbytes,3,logentry_item_store.nbytes,,logger.h,nbytes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
333,22360,sfd,3,logentry_item_store.sfd,,logger.h,sfd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
334,22361,key,3,logentry_item_store.key,,logger.h,key[],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
335,22368,transport,3,logentry_conn_event.transport,,logger.h,transport,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
336,22369,reason,3,logentry_conn_event.reason,,logger.h,reason,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
337,22370,sfd,3,logentry_conn_event.sfd,,logger.h,sfd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
338,22372,addr,3,logentry_conn_event.addr,,logger.h,addr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
339,22375,event,3,_logentry.event,,logger.h,event,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
340,22376,pad,3,_logentry.pad,,logger.h,pad,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
341,22377,eflags,3,_logentry.eflags,,logger.h,eflags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
342,22378,gid,3,_logentry.gid,,logger.h,gid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
343,22380,tv,3,_logentry.tv,,logger.h,tv,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
344,22381,size,3,_logentry.size,,logger.h,size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
345,22383,end,3,_logentry.data.end,,logger.h,end,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
346,22384,data,3,_logentry.data,,logger.h,data[],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
347,22392,prev,3,_logger.prev,,logger.h,*prev,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
348,22394,next,3,_logger.next,,logger.h,*next,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
349,22395,mutex,3,_logger.mutex,,logger.h,mutex,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
350,22396,written,3,_logger.written,,logger.h,written,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
351,22397,dropped,3,_logger.dropped,,logger.h,dropped,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
352,22398,blocked,3,_logger.blocked,,logger.h,blocked,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
353,22399,fetcher_ratio,3,_logger.fetcher_ratio,,logger.h,fetcher_ratio,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
354,22400,mutation_ratio,3,_logger.mutation_ratio,,logger.h,mutation_ratio,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
355,22401,eflags,3,_logger.eflags,,logger.h,eflags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
356,22402,buf,3,_logger.buf,,logger.h,*buf,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
357,22403,entry_map,3,_logger.entry_map,,logger.h,*entry_map,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
358,22406,LOGGER_WATCHER_STDERR,3,logger_watcher_type.LOGGER_WATCHER_STDERR,,logger.h,LOGGER_WATCHER_STDERR = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
359,22407,LOGGER_WATCHER_CLIENT,3,logger_watcher_type.LOGGER_WATCHER_CLIENT,,logger.h,LOGGER_WATCHER_CLIENT = 1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
360,22419,c,3,logger_watcher.c,,logger.h,*c,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
361,22420,sfd,3,logger_watcher.sfd,,logger.h,sfd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
362,22421,id,3,logger_watcher.id,,logger.h,id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
363,22422,skipped,3,logger_watcher.skipped,,logger.h,skipped,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
364,22423,min_gid,3,logger_watcher.min_gid,,logger.h,min_gid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
365,22424,failed_flush,3,logger_watcher.failed_flush,,logger.h,failed_flush,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
366,22426,t,3,logger_watcher.t,,logger.h,t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
367,22427,eflags,3,logger_watcher.eflags,,logger.h,eflags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
368,22428,buf,3,logger_watcher.buf,,logger.h,*buf,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
369,22431,worker_dropped,3,logger_stats.worker_dropped,,logger.h,worker_dropped,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
370,22432,worker_written,3,logger_stats.worker_written,,logger.h,worker_written,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
371,22433,watcher_skipped,3,logger_stats.watcher_skipped,,logger.h,watcher_skipped,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
372,22434,watcher_sent,3,logger_stats.watcher_sent,,logger.h,watcher_sent,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
373,22435,watcher_count,3,logger_stats.watcher_count,,logger.h,watcher_count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
374,22455,LOGGER_ADD_WATCHER_TOO_MANY,3,logger_add_watcher_ret.LOGGER_ADD_WATCHER_TOO_MANY,,logger.h,LOGGER_ADD_WATCHER_TOO_MANY = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
375,22456,LOGGER_ADD_WATCHER_OK,3,logger_add_watcher_ret.LOGGER_ADD_WATCHER_OK,,logger.h,LOGGER_ADD_WATCHER_OK,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
376,22457,LOGGER_ADD_WATCHER_FAILED,3,logger_add_watcher_ret.LOGGER_ADD_WATCHER_FAILED,,logger.h,LOGGER_ADD_WATCHER_FAILED,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
377,25574,count,3,md5_state_s.count,,md5.h,count[2],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
378,25575,abcd,3,md5_state_s.abcd,,md5.h,abcd[4],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
379,25576,buf,3,md5_state_s.buf,,md5.h,buf[64],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
380,25707,READ_DATA_RECEIVED,3,try_read_result.READ_DATA_RECEIVED,,memcached.c,READ_DATA_RECEIVED,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
381,25708,READ_NO_DATA_RECEIVED,3,try_read_result.READ_NO_DATA_RECEIVED,,memcached.c,READ_NO_DATA_RECEIVED,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
382,25709,READ_ERROR,3,try_read_result.READ_ERROR,,memcached.c,READ_ERROR,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
383,25710,READ_MEMORY_ERROR,3,try_read_result.READ_MEMORY_ERROR,,memcached.c,READ_MEMORY_ERROR,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
384,25798,TRANSMIT_COMPLETE,3,transmit_result.TRANSMIT_COMPLETE,,memcached.c,TRANSMIT_COMPLETE,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
385,25799,TRANSMIT_INCOMPLETE,3,transmit_result.TRANSMIT_INCOMPLETE,,memcached.c,TRANSMIT_INCOMPLETE,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
386,25800,TRANSMIT_SOFT_ERROR,3,transmit_result.TRANSMIT_SOFT_ERROR,,memcached.c,TRANSMIT_SOFT_ERROR,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
387,25801,TRANSMIT_HARD_ERROR,3,transmit_result.TRANSMIT_HARD_ERROR,,memcached.c,TRANSMIT_HARD_ERROR,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
388,40448,mmap_base,3,_mc_meta_data.mmap_base,,memcached.c,*mmap_base,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
389,40449,old_base,3,_mc_meta_data.old_base,,memcached.c,old_base,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
390,40450,slab_config,3,_mc_meta_data.slab_config,,memcached.c,*slab_config,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
391,40451,time_delta,3,_mc_meta_data.time_delta,,memcached.c,time_delta,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
392,40452,process_started,3,_mc_meta_data.process_started,,memcached.c,process_started,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
393,40453,current_time,3,_mc_meta_data.current_time,,memcached.c,current_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
394,44170,conn_listening,3,conn_states.conn_listening,,memcached.h,conn_listening,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
395,44171,conn_new_cmd,3,conn_states.conn_new_cmd,,memcached.h,conn_new_cmd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
396,44172,conn_waiting,3,conn_states.conn_waiting,,memcached.h,conn_waiting,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
397,44173,conn_read,3,conn_states.conn_read,,memcached.h,conn_read,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
398,44174,conn_parse_cmd,3,conn_states.conn_parse_cmd,,memcached.h,conn_parse_cmd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
399,44175,conn_write,3,conn_states.conn_write,,memcached.h,conn_write,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
400,44176,conn_nread,3,conn_states.conn_nread,,memcached.h,conn_nread,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
401,44177,conn_swallow,3,conn_states.conn_swallow,,memcached.h,conn_swallow,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
402,44178,conn_closing,3,conn_states.conn_closing,,memcached.h,conn_closing,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
403,44179,conn_mwrite,3,conn_states.conn_mwrite,,memcached.h,conn_mwrite,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
404,44180,conn_closed,3,conn_states.conn_closed,,memcached.h,conn_closed,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
405,44181,conn_watch,3,conn_states.conn_watch,,memcached.h,conn_watch,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
406,44182,conn_io_queue,3,conn_states.conn_io_queue,,memcached.h,conn_io_queue,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
407,44183,conn_max_state,3,conn_states.conn_max_state,,memcached.h,conn_max_state,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
408,44185,bin_no_state,3,bin_substates.bin_no_state,,memcached.h,bin_no_state,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
409,44186,bin_reading_set_header,3,bin_substates.bin_reading_set_header,,memcached.h,bin_reading_set_header,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
410,44187,bin_reading_cas_header,3,bin_substates.bin_reading_cas_header,,memcached.h,bin_reading_cas_header,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
411,44188,bin_read_set_value,3,bin_substates.bin_read_set_value,,memcached.h,bin_read_set_value,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
412,44189,bin_reading_get_key,3,bin_substates.bin_reading_get_key,,memcached.h,bin_reading_get_key,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
413,44190,bin_reading_stat,3,bin_substates.bin_reading_stat,,memcached.h,bin_reading_stat,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
414,44191,bin_reading_del_header,3,bin_substates.bin_reading_del_header,,memcached.h,bin_reading_del_header,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
415,44192,bin_reading_incr_header,3,bin_substates.bin_reading_incr_header,,memcached.h,bin_reading_incr_header,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
416,44193,bin_read_flush_exptime,3,bin_substates.bin_read_flush_exptime,,memcached.h,bin_read_flush_exptime,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
417,44194,bin_reading_sasl_auth,3,bin_substates.bin_reading_sasl_auth,,memcached.h,bin_reading_sasl_auth,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
418,44195,bin_reading_sasl_auth_data,3,bin_substates.bin_reading_sasl_auth_data,,memcached.h,bin_reading_sasl_auth_data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
419,44196,bin_reading_touch_key,3,bin_substates.bin_reading_touch_key,,memcached.h,bin_reading_touch_key,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
420,44198,ascii_prot,3,protocol.ascii_prot,,memcached.h,ascii_prot = 3,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
421,44199,binary_prot,3,protocol.binary_prot,,memcached.h,binary_prot,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
422,44200,negotiating_prot,3,protocol.negotiating_prot,,memcached.h,negotiating_prot,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
423,44209,local_transport,3,network_transport.local_transport,,memcached.h,local_transport,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
424,44210,tcp_transport,3,network_transport.tcp_transport,,memcached.h,tcp_transport,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
425,44211,udp_transport,3,network_transport.udp_transport,,memcached.h,udp_transport,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
426,44213,PAUSE_WORKER_THREADS,3,pause_thread_types.PAUSE_WORKER_THREADS,,memcached.h,PAUSE_WORKER_THREADS = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
427,44214,PAUSE_ALL_THREADS,3,pause_thread_types.PAUSE_ALL_THREADS,,memcached.h,PAUSE_ALL_THREADS,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
428,44215,RESUME_ALL_THREADS,3,pause_thread_types.RESUME_ALL_THREADS,,memcached.h,RESUME_ALL_THREADS,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
429,44216,RESUME_WORKER_THREADS,3,pause_thread_types.RESUME_WORKER_THREADS,,memcached.h,RESUME_WORKER_THREADS,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
430,44225,NOT_STOP,3,stop_reasons.NOT_STOP,,memcached.h,NOT_STOP,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
431,44226,GRACE_STOP,3,stop_reasons.GRACE_STOP,,memcached.h,GRACE_STOP,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
432,44227,EXIT_NORMALLY,3,stop_reasons.EXIT_NORMALLY,,memcached.h,EXIT_NORMALLY,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
433,44229,ERROR_CLOSE,3,close_reasons.ERROR_CLOSE,,memcached.h,ERROR_CLOSE,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
434,44230,NORMAL_CLOSE,3,close_reasons.NORMAL_CLOSE,,memcached.h,NORMAL_CLOSE,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
435,44231,IDLE_TIMEOUT_CLOSE,3,close_reasons.IDLE_TIMEOUT_CLOSE,,memcached.h,IDLE_TIMEOUT_CLOSE,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
436,44232,SHUTDOWN_CLOSE,3,close_reasons.SHUTDOWN_CLOSE,,memcached.h,SHUTDOWN_CLOSE,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
437,44234,NOT_STORED,3,store_item_type.NOT_STORED,,memcached.h,NOT_STORED=0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
438,44235,STORED,3,store_item_type.STORED,,memcached.h,STORED,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
439,44236,EXISTS,3,store_item_type.EXISTS,,memcached.h,EXISTS,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
440,44237,NOT_FOUND,3,store_item_type.NOT_FOUND,,memcached.h,NOT_FOUND,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
441,44238,TOO_LARGE,3,store_item_type.TOO_LARGE,,memcached.h,TOO_LARGE,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
442,44239,NO_MEMORY,3,store_item_type.NO_MEMORY,,memcached.h,NO_MEMORY,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
443,44248,OK,3,delta_result_type.OK,,memcached.h,OK,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
444,44249,NON_NUMERIC,3,delta_result_type.NON_NUMERIC,,memcached.h,NON_NUMERIC,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
445,44250,EOM,3,delta_result_type.EOM,,memcached.h,EOM,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
446,44251,DELTA_ITEM_NOT_FOUND,3,delta_result_type.DELTA_ITEM_NOT_FOUND,,memcached.h,DELTA_ITEM_NOT_FOUND,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
447,44252,DELTA_ITEM_CAS_MISMATCH,3,delta_result_type.DELTA_ITEM_CAS_MISMATCH,,memcached.h,DELTA_ITEM_CAS_MISMATCH,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
448,44254,set_cmds,3,slab_stats.set_cmds,,memcached.h,uint64_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
449,44255,get_hits,3,slab_stats.get_hits,,memcached.h,uint64_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
450,44256,touch_hits,3,slab_stats.touch_hits,,memcached.h,uint64_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
451,44257,delete_hits,3,slab_stats.delete_hits,,memcached.h,uint64_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
452,44258,cas_hits,3,slab_stats.cas_hits,,memcached.h,uint64_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
453,44259,cas_badval,3,slab_stats.cas_badval,,memcached.h,uint64_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
454,44260,incr_hits,3,slab_stats.incr_hits,,memcached.h,uint64_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
455,44261,decr_hits,3,slab_stats.decr_hits,,memcached.h,uint64_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
456,44263,mutex,3,thread_stats.mutex,,memcached.h,mutex,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
457,44264,get_cmds,3,thread_stats.get_cmds,,memcached.h,uint64_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
458,44265,get_misses,3,thread_stats.get_misses,,memcached.h,uint64_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
459,44266,get_expired,3,thread_stats.get_expired,,memcached.h,uint64_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
460,44267,get_flushed,3,thread_stats.get_flushed,,memcached.h,uint64_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
461,44268,touch_cmds,3,thread_stats.touch_cmds,,memcached.h,uint64_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
462,44269,touch_misses,3,thread_stats.touch_misses,,memcached.h,uint64_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
463,44270,delete_misses,3,thread_stats.delete_misses,,memcached.h,uint64_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
464,44271,incr_misses,3,thread_stats.incr_misses,,memcached.h,uint64_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
465,44272,decr_misses,3,thread_stats.decr_misses,,memcached.h,uint64_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
466,44273,cas_misses,3,thread_stats.cas_misses,,memcached.h,uint64_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
467,44274,meta_cmds,3,thread_stats.meta_cmds,,memcached.h,uint64_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
468,44275,bytes_read,3,thread_stats.bytes_read,,memcached.h,uint64_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
469,44276,bytes_written,3,thread_stats.bytes_written,,memcached.h,uint64_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
470,44277,flush_cmds,3,thread_stats.flush_cmds,,memcached.h,uint64_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
471,44278,conn_yields,3,thread_stats.conn_yields,,memcached.h,uint64_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
472,44279,auth_cmds,3,thread_stats.auth_cmds,,memcached.h,uint64_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
473,44280,auth_errors,3,thread_stats.auth_errors,,memcached.h,uint64_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
474,44281,idle_kicks,3,thread_stats.idle_kicks,,memcached.h,uint64_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
475,44282,response_obj_oom,3,thread_stats.response_obj_oom,,memcached.h,uint64_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
476,44283,response_obj_count,3,thread_stats.response_obj_count,,memcached.h,uint64_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
477,44284,response_obj_bytes,3,thread_stats.response_obj_bytes,,memcached.h,uint64_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
478,44285,read_buf_oom,3,thread_stats.read_buf_oom,,memcached.h,uint64_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
479,44286,store_too_large,3,thread_stats.store_too_large,,memcached.h,uint64_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
480,44287,store_no_memory,3,thread_stats.store_no_memory,,memcached.h,uint64_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
481,44291,slab_stats,3,thread_stats.slab_stats,,memcached.h,slab_stats[MAX_NUMBER_OF_SLAB_CLASSES],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
482,44292,lru_hits,3,thread_stats.lru_hits,,memcached.h,lru_hits[POWER_LARGEST],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
483,44293,read_buf_count,3,thread_stats.read_buf_count,,memcached.h,read_buf_count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
484,44294,read_buf_bytes,3,thread_stats.read_buf_bytes,,memcached.h,read_buf_bytes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
485,44295,read_buf_bytes_free,3,thread_stats.read_buf_bytes_free,,memcached.h,read_buf_bytes_free,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
486,44311,total_items,3,stats.total_items,,memcached.h,total_items,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
487,44312,total_conns,3,stats.total_conns,,memcached.h,total_conns,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
488,44313,rejected_conns,3,stats.rejected_conns,,memcached.h,rejected_conns,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
489,44314,malloc_fails,3,stats.malloc_fails,,memcached.h,malloc_fails,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
490,44315,listen_disabled_num,3,stats.listen_disabled_num,,memcached.h,listen_disabled_num,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
491,44316,slabs_moved,3,stats.slabs_moved,,memcached.h,slabs_moved,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
492,44317,slab_reassign_rescues,3,stats.slab_reassign_rescues,,memcached.h,slab_reassign_rescues,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
493,44318,slab_reassign_evictions_nomem,3,stats.slab_reassign_evictions_nomem,,memcached.h,slab_reassign_evictions_nomem,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
494,44319,slab_reassign_inline_reclaim,3,stats.slab_reassign_inline_reclaim,,memcached.h,slab_reassign_inline_reclaim,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
495,44320,slab_reassign_chunk_rescues,3,stats.slab_reassign_chunk_rescues,,memcached.h,slab_reassign_chunk_rescues,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
496,44321,slab_reassign_busy_items,3,stats.slab_reassign_busy_items,,memcached.h,slab_reassign_busy_items,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
497,44322,slab_reassign_busy_deletes,3,stats.slab_reassign_busy_deletes,,memcached.h,slab_reassign_busy_deletes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
498,44323,lru_crawler_starts,3,stats.lru_crawler_starts,,memcached.h,lru_crawler_starts,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
499,44324,lru_maintainer_juggles,3,stats.lru_maintainer_juggles,,memcached.h,lru_maintainer_juggles,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
500,44325,time_in_listen_disabled_us,3,stats.time_in_listen_disabled_us,,memcached.h,time_in_listen_disabled_us,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
501,44326,log_worker_dropped,3,stats.log_worker_dropped,,memcached.h,log_worker_dropped,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
502,44327,log_worker_written,3,stats.log_worker_written,,memcached.h,log_worker_written,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
503,44328,log_watcher_skipped,3,stats.log_watcher_skipped,,memcached.h,log_watcher_skipped,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
504,44329,log_watcher_sent,3,stats.log_watcher_sent,,memcached.h,log_watcher_sent,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
505,44330,extstore_compact_lost,3,stats.extstore_compact_lost,,memcached.h,extstore_compact_lost,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
506,44331,extstore_compact_rescues,3,stats.extstore_compact_rescues,,memcached.h,extstore_compact_rescues,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
507,44332,extstore_compact_skipped,3,stats.extstore_compact_skipped,,memcached.h,extstore_compact_skipped,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
508,44333,ssl_handshake_errors,3,stats.ssl_handshake_errors,,memcached.h,ssl_handshake_errors,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
509,44334,ssl_new_sessions,3,stats.ssl_new_sessions,,memcached.h,ssl_new_sessions,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
510,44336,maxconns_entered,3,stats.maxconns_entered,,memcached.h,maxconns_entered,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
511,44337,unexpected_napi_ids,3,stats.unexpected_napi_ids,,memcached.h,unexpected_napi_ids,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
512,44338,round_robin_fallback,3,stats.round_robin_fallback,,memcached.h,round_robin_fallback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
513,44340,curr_items,3,stats_state.curr_items,,memcached.h,curr_items,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
514,44341,curr_bytes,3,stats_state.curr_bytes,,memcached.h,curr_bytes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
515,44342,curr_conns,3,stats_state.curr_conns,,memcached.h,curr_conns,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
516,44343,hash_bytes,3,stats_state.hash_bytes,,memcached.h,hash_bytes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
517,44344,conn_structs,3,stats_state.conn_structs,,memcached.h,conn_structs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
518,44345,reserved_fds,3,stats_state.reserved_fds,,memcached.h,reserved_fds,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
519,44346,hash_power_level,3,stats_state.hash_power_level,,memcached.h,hash_power_level,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
520,44347,log_watchers,3,stats_state.log_watchers,,memcached.h,log_watchers,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
521,44348,hash_is_expanding,3,stats_state.hash_is_expanding,,memcached.h,hash_is_expanding,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
522,44349,accepting_conns,3,stats_state.accepting_conns,,memcached.h,accepting_conns,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
523,44350,slab_reassign_running,3,stats_state.slab_reassign_running,,memcached.h,slab_reassign_running,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
524,44351,lru_crawler_running,3,stats_state.lru_crawler_running,,memcached.h,lru_crawler_running,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
525,44353,maxbytes,3,settings.maxbytes,,memcached.h,maxbytes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
526,44354,maxconns,3,settings.maxconns,,memcached.h,maxconns,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
527,44355,port,3,settings.port,,memcached.h,port,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
528,44356,udpport,3,settings.udpport,,memcached.h,udpport,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
529,44357,inter,3,settings.inter,,memcached.h,*inter,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,16,0,1,1,0,0,,0,0,0,0,0,
530,44358,verbose,3,settings.verbose,,memcached.h,verbose,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,49,0,1,1,0,0,,0,0,0,0,0,
531,44359,oldest_live,3,settings.oldest_live,,memcached.h,oldest_live,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
532,44360,oldest_cas,3,settings.oldest_cas,,memcached.h,oldest_cas,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
533,44361,evict_to_free,3,settings.evict_to_free,,memcached.h,evict_to_free,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
534,44362,socketpath,3,settings.socketpath,,memcached.h,*socketpath,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
535,44363,auth_file,3,settings.auth_file,,memcached.h,*auth_file,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
536,44364,access,3,settings.access,,memcached.h,access,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
537,44365,factor,3,settings.factor,,memcached.h,factor,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
538,44366,chunk_size,3,settings.chunk_size,,memcached.h,chunk_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
539,44367,num_threads,3,settings.num_threads,,memcached.h,num_threads,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,17,0,1,1,0,0,,0,0,0,0,0,
540,44368,num_threads_per_udp,3,settings.num_threads_per_udp,,memcached.h,num_threads_per_udp,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
541,44369,prefix_delimiter,3,settings.prefix_delimiter,,memcached.h,prefix_delimiter,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
542,44370,detail_enabled,3,settings.detail_enabled,,memcached.h,detail_enabled,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
543,44371,reqs_per_event,3,settings.reqs_per_event,,memcached.h,reqs_per_event,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
544,44372,use_cas,3,settings.use_cas,,memcached.h,use_cas,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,14,0,1,1,0,0,,0,0,0,0,0,
545,44374,binding_protocol,3,settings.binding_protocol,,memcached.h,binding_protocol,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
546,44375,backlog,3,settings.backlog,,memcached.h,backlog,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
547,44376,item_size_max,3,settings.item_size_max,,memcached.h,item_size_max,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,16,0,1,1,0,0,,0,0,0,0,0,
548,44377,slab_chunk_size_max,3,settings.slab_chunk_size_max,,memcached.h,slab_chunk_size_max,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,22,0,1,1,0,0,,0,0,0,0,0,
549,44378,slab_page_size,3,settings.slab_page_size,,memcached.h,slab_page_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,15,0,1,1,0,0,,0,0,0,0,0,
550,44379,sig_hup,3,settings.sig_hup,,memcached.h,sig_hup,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
551,44380,sasl,3,settings.sasl,,memcached.h,sasl,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
552,44381,maxconns_fast,3,settings.maxconns_fast,,memcached.h,maxconns_fast,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
553,44382,lru_crawler,3,settings.lru_crawler,,memcached.h,lru_crawler,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
554,44383,lru_maintainer_thread,3,settings.lru_maintainer_thread,,memcached.h,lru_maintainer_thread,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
555,44384,lru_segmented,3,settings.lru_segmented,,memcached.h,lru_segmented,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
556,44385,slab_reassign,3,settings.slab_reassign,,memcached.h,slab_reassign,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
557,44386,slab_automove,3,settings.slab_automove,,memcached.h,slab_automove,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
558,44387,slab_automove_ratio,3,settings.slab_automove_ratio,,memcached.h,slab_automove_ratio,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
559,44388,slab_automove_window,3,settings.slab_automove_window,,memcached.h,slab_automove_window,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
560,44389,hashpower_init,3,settings.hashpower_init,,memcached.h,hashpower_init,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
561,44390,shutdown_command,3,settings.shutdown_command,,memcached.h,shutdown_command,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
562,44391,tail_repair_time,3,settings.tail_repair_time,,memcached.h,tail_repair_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
563,44392,flush_enabled,3,settings.flush_enabled,,memcached.h,flush_enabled,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
564,44393,dump_enabled,3,settings.dump_enabled,,memcached.h,dump_enabled,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
565,44394,hash_algorithm,3,settings.hash_algorithm,,memcached.h,*hash_algorithm,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
566,44395,lru_crawler_sleep,3,settings.lru_crawler_sleep,,memcached.h,lru_crawler_sleep,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
567,44396,lru_crawler_tocrawl,3,settings.lru_crawler_tocrawl,,memcached.h,lru_crawler_tocrawl,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
568,44397,hot_lru_pct,3,settings.hot_lru_pct,,memcached.h,hot_lru_pct,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
569,44398,warm_lru_pct,3,settings.warm_lru_pct,,memcached.h,warm_lru_pct,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
570,44399,hot_max_factor,3,settings.hot_max_factor,,memcached.h,hot_max_factor,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
571,44400,warm_max_factor,3,settings.warm_max_factor,,memcached.h,warm_max_factor,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
572,44401,crawls_persleep,3,settings.crawls_persleep,,memcached.h,crawls_persleep,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
573,44402,temp_lru,3,settings.temp_lru,,memcached.h,temp_lru,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
574,44403,temporary_ttl,3,settings.temporary_ttl,,memcached.h,temporary_ttl,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
575,44404,idle_timeout,3,settings.idle_timeout,,memcached.h,idle_timeout,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
576,44405,logger_watcher_buf_size,3,settings.logger_watcher_buf_size,,memcached.h,logger_watcher_buf_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
577,44406,logger_buf_size,3,settings.logger_buf_size,,memcached.h,logger_buf_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
578,44407,read_buf_mem_limit,3,settings.read_buf_mem_limit,,memcached.h,read_buf_mem_limit,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
579,44408,drop_privileges,3,settings.drop_privileges,,memcached.h,drop_privileges,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
580,44409,watch_enabled,3,settings.watch_enabled,,memcached.h,watch_enabled,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
581,44410,relaxed_privileges,3,settings.relaxed_privileges,,memcached.h,relaxed_privileges,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
582,44411,meta_response_old,3,settings.meta_response_old,,memcached.h,meta_response_old,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
583,44412,ext_io_threadcount,3,settings.ext_io_threadcount,,memcached.h,ext_io_threadcount,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
584,44413,ext_page_size,3,settings.ext_page_size,,memcached.h,ext_page_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
585,44414,ext_item_size,3,settings.ext_item_size,,memcached.h,ext_item_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
586,44415,ext_item_age,3,settings.ext_item_age,,memcached.h,ext_item_age,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
587,44416,ext_low_ttl,3,settings.ext_low_ttl,,memcached.h,ext_low_ttl,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
588,44417,ext_recache_rate,3,settings.ext_recache_rate,,memcached.h,ext_recache_rate,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
589,44418,ext_wbuf_size,3,settings.ext_wbuf_size,,memcached.h,ext_wbuf_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
590,44419,ext_compact_under,3,settings.ext_compact_under,,memcached.h,ext_compact_under,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
591,44420,ext_drop_under,3,settings.ext_drop_under,,memcached.h,ext_drop_under,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
592,44421,ext_max_sleep,3,settings.ext_max_sleep,,memcached.h,ext_max_sleep,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
593,44422,ext_max_frag,3,settings.ext_max_frag,,memcached.h,ext_max_frag,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
594,44423,slab_automove_freeratio,3,settings.slab_automove_freeratio,,memcached.h,slab_automove_freeratio,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
595,44424,ext_drop_unread,3,settings.ext_drop_unread,,memcached.h,ext_drop_unread,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
596,44425,ext_global_pool_min,3,settings.ext_global_pool_min,,memcached.h,ext_global_pool_min,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
597,44426,ssl_enabled,3,settings.ssl_enabled,,memcached.h,ssl_enabled,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
598,44427,ssl_ctx,3,settings.ssl_ctx,,memcached.h,*ssl_ctx,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
599,44428,ssl_chain_cert,3,settings.ssl_chain_cert,,memcached.h,*ssl_chain_cert,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
600,44429,ssl_key,3,settings.ssl_key,,memcached.h,*ssl_key,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
601,44430,ssl_verify_mode,3,settings.ssl_verify_mode,,memcached.h,ssl_verify_mode,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
602,44431,ssl_keyformat,3,settings.ssl_keyformat,,memcached.h,ssl_keyformat,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
603,44432,ssl_ciphers,3,settings.ssl_ciphers,,memcached.h,*ssl_ciphers,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
604,44433,ssl_ca_cert,3,settings.ssl_ca_cert,,memcached.h,*ssl_ca_cert,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
605,44434,ssl_last_cert_refresh_time,3,settings.ssl_last_cert_refresh_time,,memcached.h,ssl_last_cert_refresh_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
606,44435,ssl_wbuf_size,3,settings.ssl_wbuf_size,,memcached.h,ssl_wbuf_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
607,44436,ssl_session_cache,3,settings.ssl_session_cache,,memcached.h,ssl_session_cache,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
608,44437,ssl_kernel_tls,3,settings.ssl_kernel_tls,,memcached.h,ssl_kernel_tls,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
609,44438,ssl_min_version,3,settings.ssl_min_version,,memcached.h,ssl_min_version,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
610,44439,num_napi_ids,3,settings.num_napi_ids,,memcached.h,num_napi_ids,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
611,44440,memory_file,3,settings.memory_file,,memcached.h,*memory_file,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
612,44441,proxy_enabled,3,settings.proxy_enabled,,memcached.h,proxy_enabled,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
613,44442,proxy_uring,3,settings.proxy_uring,,memcached.h,proxy_uring,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
614,44443,proxy_startfile,3,settings.proxy_startfile,,memcached.h,*proxy_startfile,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
615,44444,proxy_ctx,3,settings.proxy_ctx,,memcached.h,*proxy_ctx,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
616,44445,sock_cookie_id,3,settings.sock_cookie_id,,memcached.h,sock_cookie_id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
617,44455,next,3,_stritem.next,,memcached.h,*next,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
618,44457,prev,3,_stritem.prev,,memcached.h,*prev,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
619,44459,h_next,3,_stritem.h_next,,memcached.h,*h_next,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
620,44460,time,3,_stritem.time,,memcached.h,time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
621,44461,exptime,3,_stritem.exptime,,memcached.h,exptime,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
622,44462,nbytes,3,_stritem.nbytes,,memcached.h,nbytes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
623,44463,refcount,3,_stritem.refcount,,memcached.h,refcount,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
624,44464,it_flags,3,_stritem.it_flags,,memcached.h,it_flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
625,44465,slabs_clsid,3,_stritem.slabs_clsid,,memcached.h,slabs_clsid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
626,44466,nkey,3,_stritem.nkey,,memcached.h,nkey,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
627,44468,cas,3,_stritem.data.cas,,memcached.h,cas,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
628,44469,end,3,_stritem.data.end,,memcached.h,end,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
629,44470,data,3,_stritem.data,,memcached.h,data[],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
630,44478,CRAWLER_AUTOEXPIRE,3,crawler_run_type.CRAWLER_AUTOEXPIRE,,memcached.h,CRAWLER_AUTOEXPIRE=0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
631,44479,CRAWLER_EXPIRED,3,crawler_run_type.CRAWLER_EXPIRED,,memcached.h,CRAWLER_EXPIRED,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
632,44480,CRAWLER_METADUMP,3,crawler_run_type.CRAWLER_METADUMP,,memcached.h,CRAWLER_METADUMP,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
633,44490,next,3,crawler.next,,memcached.h,*next,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
634,44492,prev,3,crawler.prev,,memcached.h,*prev,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
635,44494,h_next,3,crawler.h_next,,memcached.h,*h_next,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
636,44495,time,3,crawler.time,,memcached.h,time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
637,44496,exptime,3,crawler.exptime,,memcached.h,exptime,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
638,44497,nbytes,3,crawler.nbytes,,memcached.h,nbytes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
639,44498,refcount,3,crawler.refcount,,memcached.h,refcount,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
640,44499,it_flags,3,crawler.it_flags,,memcached.h,it_flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
641,44500,slabs_clsid,3,crawler.slabs_clsid,,memcached.h,slabs_clsid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
642,44501,nkey,3,crawler.nkey,,memcached.h,nkey,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
643,44502,remaining,3,crawler.remaining,,memcached.h,remaining,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
644,44503,reclaimed,3,crawler.reclaimed,,memcached.h,reclaimed,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
645,44504,unfetched,3,crawler.unfetched,,memcached.h,unfetched,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
646,44505,checked,3,crawler.checked,,memcached.h,checked,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
647,44509,next,3,_strchunk.next,,memcached.h,*next,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
648,44511,prev,3,_strchunk.prev,,memcached.h,*prev,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
649,44513,head,3,_strchunk.head,,memcached.h,*head,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
650,44514,size,3,_strchunk.size,,memcached.h,size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
651,44515,used,3,_strchunk.used,,memcached.h,used,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
652,44516,nbytes,3,_strchunk.nbytes,,memcached.h,nbytes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
653,44517,refcount,3,_strchunk.refcount,,memcached.h,refcount,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
654,44518,it_flags,3,_strchunk.it_flags,,memcached.h,it_flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
655,44519,slabs_clsid,3,_strchunk.slabs_clsid,,memcached.h,slabs_clsid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
656,44520,orig_clsid,3,_strchunk.orig_clsid,,memcached.h,orig_clsid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
657,44521,data,3,_strchunk.data,,memcached.h,data[],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
658,44543,ctx,3,io_queue_s.ctx,,memcached.h,*ctx,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
659,44544,stack_ctx,3,io_queue_s.stack_ctx,,memcached.h,*stack_ctx,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
660,44545,count,3,io_queue_s.count,,memcached.h,count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
661,44546,type,3,io_queue_s.type,,memcached.h,type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
662,44548,ctx,3,io_queue_cb_s.ctx,,memcached.h,*ctx,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
663,44549,submit_cb,3,io_queue_cb_s.submit_cb,,memcached.h,submit_cb,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
664,44550,complete_cb,3,io_queue_cb_s.complete_cb,,memcached.h,complete_cb,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
665,44551,return_cb,3,io_queue_cb_s.return_cb,,memcached.h,return_cb,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
666,44552,finalize_cb,3,io_queue_cb_s.finalize_cb,,memcached.h,finalize_cb,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
667,44553,type,3,io_queue_cb_s.type,,memcached.h,type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
668,44558,thread_id,3,LIBEVENT_THREAD.thread_id,,memcached.h,thread_id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
669,44560,base,3,LIBEVENT_THREAD.base,,memcached.h,*base,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
670,44562,notify_event,3,LIBEVENT_THREAD.notify_event,,memcached.h,notify_event,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
671,44563,notify_event_fd,3,LIBEVENT_THREAD.notify_event_fd,,memcached.h,notify_event_fd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
672,44564,notify_receive_fd,3,LIBEVENT_THREAD.notify_receive_fd,,memcached.h,notify_receive_fd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
673,44565,notify_send_fd,3,LIBEVENT_THREAD.notify_send_fd,,memcached.h,notify_send_fd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
674,44567,stats,3,LIBEVENT_THREAD.stats,,memcached.h,stats,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
675,44568,io_queues,3,LIBEVENT_THREAD.io_queues,,memcached.h,io_queues[IO_QUEUE_COUNT],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
676,44570,ev_queue,3,LIBEVENT_THREAD.ev_queue,,memcached.h,*ev_queue,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
677,44571,rbuf_cache,3,LIBEVENT_THREAD.rbuf_cache,,memcached.h,*rbuf_cache,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
678,44572,open_bundle,3,LIBEVENT_THREAD.open_bundle,,memcached.h,*open_bundle,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
679,44573,io_cache,3,LIBEVENT_THREAD.io_cache,,memcached.h,*io_cache,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
680,44574,storage,3,LIBEVENT_THREAD.storage,,memcached.h,*storage,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
681,44575,l,3,LIBEVENT_THREAD.l,,memcached.h,*l,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
682,44576,lru_bump_buf,3,LIBEVENT_THREAD.lru_bump_buf,,memcached.h,*lru_bump_buf,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
683,44577,ssl_wbuf,3,LIBEVENT_THREAD.ssl_wbuf,,memcached.h,*ssl_wbuf,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
684,44578,napi_id,3,LIBEVENT_THREAD.napi_id,,memcached.h,napi_id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
685,44579,L,3,LIBEVENT_THREAD.L,,memcached.h,*L,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
686,44580,proxy_hooks,3,LIBEVENT_THREAD.proxy_hooks,,memcached.h,*proxy_hooks,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
687,44581,proxy_user_stats,3,LIBEVENT_THREAD.proxy_user_stats,,memcached.h,*proxy_user_stats,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
688,44582,proxy_int_stats,3,LIBEVENT_THREAD.proxy_int_stats,,memcached.h,*proxy_int_stats,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
689,44583,proxy_rng,3,LIBEVENT_THREAD.proxy_rng,,memcached.h,proxy_rng[4],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
690,44596,bundle,3,_mc_resp.bundle,,memcached.h,*bundle,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
691,44598,next,3,_mc_resp.next,,memcached.h,*next,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
692,44599,wbytes,3,_mc_resp.wbytes,,memcached.h,wbytes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
693,44600,tosend,3,_mc_resp.tosend,,memcached.h,tosend,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
694,44601,write_and_free,3,_mc_resp.write_and_free,,memcached.h,*write_and_free,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
695,44602,io_pending,3,_mc_resp.io_pending,,memcached.h,*io_pending,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
696,44603,item,3,_mc_resp.item,,memcached.h,*item,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
697,44605,iov,3,_mc_resp.iov,,memcached.h,iov[MC_RESP_IOVCOUNT],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
698,44606,chunked_total,3,_mc_resp.chunked_total,,memcached.h,chunked_total,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
699,44607,iovcnt,3,_mc_resp.iovcnt,,memcached.h,iovcnt,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
700,44608,chunked_data_iov,3,_mc_resp.chunked_data_iov,,memcached.h,chunked_data_iov,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
701,44609,skip,3,_mc_resp.skip,,memcached.h,skip,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
702,44610,free,3,_mc_resp.free,,memcached.h,free,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
703,44611,request_id,3,_mc_resp.request_id,,memcached.h,request_id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
704,44612,udp_sequence,3,_mc_resp.udp_sequence,,memcached.h,udp_sequence,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
705,44613,udp_total,3,_mc_resp.udp_total,,memcached.h,udp_total,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
706,44615,request_addr,3,_mc_resp.request_addr,,memcached.h,request_addr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
707,44616,request_addr_size,3,_mc_resp.request_addr_size,,memcached.h,request_addr_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
708,44617,wbuf,3,_mc_resp.wbuf,,memcached.h,wbuf[WRITE_BUFFER_SIZE],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
709,44632,refcount,3,_mc_resp_bundle.refcount,,memcached.h,refcount,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
710,44633,next_check,3,_mc_resp_bundle.next_check,,memcached.h,next_check,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
711,44635,next,3,_mc_resp_bundle.next,,memcached.h,*next,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
712,44637,prev,3,_mc_resp_bundle.prev,,memcached.h,*prev,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
713,44638,r,3,_mc_resp_bundle.r,,memcached.h,r[],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
714,44647,io_queue_type,3,_io_pending_t.io_queue_type,,memcached.h,io_queue_type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
715,44648,thread,3,_io_pending_t.thread,,memcached.h,*thread,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
716,44649,c,3,_io_pending_t.c,,memcached.h,*c,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
717,44650,resp,3,_io_pending_t.resp,,memcached.h,*resp,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
718,44651,data,3,_io_pending_t.data,,memcached.h,data[120],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
719,44659,sasl_conn,3,conn.sasl_conn,,memcached.h,*sasl_conn,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
720,44660,sfd,3,conn.sfd,,memcached.h,sfd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,23,0,1,1,0,0,,0,0,0,0,0,
721,44661,sasl_started,3,conn.sasl_started,,memcached.h,sasl_started,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
722,44662,authenticated,3,conn.authenticated,,memcached.h,authenticated,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
723,44663,set_stale,3,conn.set_stale,,memcached.h,set_stale,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
724,44664,mset_res,3,conn.mset_res,,memcached.h,mset_res,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
725,44665,close_after_write,3,conn.close_after_write,,memcached.h,close_after_write,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
726,44666,rbuf_malloced,3,conn.rbuf_malloced,,memcached.h,rbuf_malloced,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
727,44667,item_malloced,3,conn.item_malloced,,memcached.h,item_malloced,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
728,44668,ssl,3,conn.ssl,,memcached.h,*ssl,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
729,44669,ssl_wbuf,3,conn.ssl_wbuf,,memcached.h,*ssl_wbuf,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
730,44670,ssl_enabled,3,conn.ssl_enabled,,memcached.h,ssl_enabled,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
731,44672,state,3,conn.state,,memcached.h,state,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
732,44674,substate,3,conn.substate,,memcached.h,substate,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
733,44675,last_cmd_time,3,conn.last_cmd_time,,memcached.h,last_cmd_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
734,44677,event,3,conn.event,,memcached.h,event,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
735,44678,ev_flags,3,conn.ev_flags,,memcached.h,ev_flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
736,44679,which,3,conn.which,,memcached.h,which,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
737,44680,rbuf,3,conn.rbuf,,memcached.h,*rbuf,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,26,0,1,1,0,0,,0,0,0,0,0,
738,44681,rcurr,3,conn.rcurr,,memcached.h,*rcurr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,40,0,1,1,0,0,,0,0,0,0,0,
739,44682,rsize,3,conn.rsize,,memcached.h,rsize,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,15,0,1,1,0,0,,0,0,0,0,0,
740,44683,rbytes,3,conn.rbytes,,memcached.h,rbytes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,33,0,1,1,0,0,,0,0,0,0,0,
741,44684,resp,3,conn.resp,,memcached.h,*resp,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,25,0,1,1,0,0,,0,0,0,0,0,
742,44685,resp_head,3,conn.resp_head,,memcached.h,*resp_head,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
743,44686,ritem,3,conn.ritem,,memcached.h,*ritem,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
744,44687,rlbytes,3,conn.rlbytes,,memcached.h,rlbytes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,15,0,1,1,0,0,,0,0,0,0,0,
745,44688,item,3,conn.item,,memcached.h,*item,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,19,0,1,1,0,0,,0,0,0,0,0,
746,44689,sbytes,3,conn.sbytes,,memcached.h,sbytes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
747,44690,io_queues_submitted,3,conn.io_queues_submitted,,memcached.h,io_queues_submitted,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
748,44691,io_queues,3,conn.io_queues,,memcached.h,io_queues[IO_QUEUE_COUNT],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
749,44692,proxy_coro_ref,3,conn.proxy_coro_ref,,memcached.h,proxy_coro_ref,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
750,44693,recache_counter,3,conn.recache_counter,,memcached.h,recache_counter,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
751,44695,protocol,3,conn.protocol,,memcached.h,protocol,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
752,44697,transport,3,conn.transport,,memcached.h,transport,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,14,0,1,1,0,0,,0,0,0,0,0,
753,44699,close_reason,3,conn.close_reason,,memcached.h,close_reason,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
754,44700,request_id,3,conn.request_id,,memcached.h,request_id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
755,44702,request_addr,3,conn.request_addr,,memcached.h,request_addr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
756,44703,request_addr_size,3,conn.request_addr_size,,memcached.h,request_addr_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
757,44704,noreply,3,conn.noreply,,memcached.h,noreply,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,16,0,1,1,0,0,,0,0,0,0,0,
758,44706,buffer,3,conn.stats.buffer,,memcached.h,*buffer,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
759,44707,size,3,conn.stats.size,,memcached.h,size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
760,44708,offset,3,conn.stats.offset,,memcached.h,offset,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
761,44709,stats,3,conn.stats,,memcached.h,stats,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
762,44710,binary_header,3,conn.binary_header,,memcached.h,binary_header,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
763,44711,cas,3,conn.cas,,memcached.h,cas,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
764,44712,tag,3,conn.tag,,memcached.h,tag,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
765,44713,cmd,3,conn.cmd,,memcached.h,cmd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
766,44714,opaque,3,conn.opaque,,memcached.h,opaque,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
767,44715,keylen,3,conn.keylen,,memcached.h,keylen,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
768,44716,next,3,conn.next,,memcached.h,*next,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
769,44717,thread,3,conn.thread,,memcached.h,*thread,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,112,0,1,1,0,0,,0,0,0,0,0,
770,44756,slab_start,3,slab_rebalance.slab_start,,memcached.h,*slab_start,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
771,44757,slab_end,3,slab_rebalance.slab_end,,memcached.h,*slab_end,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
772,44758,slab_pos,3,slab_rebalance.slab_pos,,memcached.h,*slab_pos,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
773,44759,s_clsid,3,slab_rebalance.s_clsid,,memcached.h,s_clsid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
774,44760,d_clsid,3,slab_rebalance.d_clsid,,memcached.h,d_clsid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
775,44761,busy_items,3,slab_rebalance.busy_items,,memcached.h,busy_items,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
776,44762,rescues,3,slab_rebalance.rescues,,memcached.h,rescues,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
777,44763,evictions_nomem,3,slab_rebalance.evictions_nomem,,memcached.h,evictions_nomem,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
778,44764,inline_reclaim,3,slab_rebalance.inline_reclaim,,memcached.h,inline_reclaim,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
779,44765,chunk_rescues,3,slab_rebalance.chunk_rescues,,memcached.h,chunk_rescues,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
780,44766,busy_deletes,3,slab_rebalance.busy_deletes,,memcached.h,busy_deletes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
781,44767,busy_loops,3,slab_rebalance.busy_loops,,memcached.h,busy_loops,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
782,44768,done,3,slab_rebalance.done,,memcached.h,done,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
783,44769,completed,3,slab_rebalance.completed,,memcached.h,*completed,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
784,53919,value,3,token_s.value,,proto_text.c,*value,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
785,53920,length,3,token_s.length,,proto_text.c,length,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
786,56688,has_error,3,_meta_flags.has_error,,proto_text.c,has_error :1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
787,56689,no_update,3,_meta_flags.no_update,,proto_text.c,no_update :1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
788,56690,locked,3,_meta_flags.locked,,proto_text.c,locked :1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
789,56691,vivify,3,_meta_flags.vivify,,proto_text.c,vivify :1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
790,56692,la,3,_meta_flags.la,,proto_text.c,la :1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
791,56693,hit,3,_meta_flags.hit,,proto_text.c,hit :1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
792,56694,value,3,_meta_flags.value,,proto_text.c,value :1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
793,56695,set_stale,3,_meta_flags.set_stale,,proto_text.c,set_stale :1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
794,56696,no_reply,3,_meta_flags.no_reply,,proto_text.c,no_reply :1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
795,56697,has_cas,3,_meta_flags.has_cas,,proto_text.c,has_cas :1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
796,56698,new_ttl,3,_meta_flags.new_ttl,,proto_text.c,new_ttl :1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
797,56699,key_binary,3,_meta_flags.key_binary,,proto_text.c,key_binary:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
798,56700,mode,3,_meta_flags.mode,,proto_text.c,mode,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
799,56701,exptime,3,_meta_flags.exptime,,proto_text.c,exptime,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
800,56702,autoviv_exptime,3,_meta_flags.autoviv_exptime,,proto_text.c,autoviv_exptime,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
801,56703,recache_time,3,_meta_flags.recache_time,,proto_text.c,recache_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
802,56704,client_flags,3,_meta_flags.client_flags,,proto_text.c,client_flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
803,56705,req_cas_id,3,_meta_flags.req_cas_id,,proto_text.c,req_cas_id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
804,56706,delta,3,_meta_flags.delta,,proto_text.c,delta,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
805,56707,initial,3,_meta_flags.initial,,proto_text.c,initial,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
806,64267,PROTOCOL_BINARY_REQ,3,protocol_binary_magic.PROTOCOL_BINARY_REQ,,protocol_binary.h,PROTOCOL_BINARY_REQ = 0x80,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
807,64268,PROTOCOL_BINARY_RES,3,protocol_binary_magic.PROTOCOL_BINARY_RES,,protocol_binary.h,PROTOCOL_BINARY_RES = 0x81,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
808,64281,PROTOCOL_BINARY_RESPONSE_SUCCESS,3,protocol_binary_response_status.PROTOCOL_BINARY_RESPONSE_SUCCESS,,protocol_binary.h,PROTOCOL_BINARY_RESPONSE_SUCCESS = 0x00,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
809,64282,PROTOCOL_BINARY_RESPONSE_KEY_ENOENT,3,protocol_binary_response_status.PROTOCOL_BINARY_RESPONSE_KEY_ENOENT,,protocol_binary.h,PROTOCOL_BINARY_RESPONSE_KEY_ENOENT = 0x01,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
810,64283,PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS,3,protocol_binary_response_status.PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS,,protocol_binary.h,PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS = 0x02,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
811,64284,PROTOCOL_BINARY_RESPONSE_E2BIG,3,protocol_binary_response_status.PROTOCOL_BINARY_RESPONSE_E2BIG,,protocol_binary.h,PROTOCOL_BINARY_RESPONSE_E2BIG = 0x03,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
812,64285,PROTOCOL_BINARY_RESPONSE_EINVAL,3,protocol_binary_response_status.PROTOCOL_BINARY_RESPONSE_EINVAL,,protocol_binary.h,PROTOCOL_BINARY_RESPONSE_EINVAL = 0x04,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
813,64286,PROTOCOL_BINARY_RESPONSE_NOT_STORED,3,protocol_binary_response_status.PROTOCOL_BINARY_RESPONSE_NOT_STORED,,protocol_binary.h,PROTOCOL_BINARY_RESPONSE_NOT_STORED = 0x05,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
814,64287,PROTOCOL_BINARY_RESPONSE_DELTA_BADVAL,3,protocol_binary_response_status.PROTOCOL_BINARY_RESPONSE_DELTA_BADVAL,,protocol_binary.h,PROTOCOL_BINARY_RESPONSE_DELTA_BADVAL = 0x06,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
815,64288,PROTOCOL_BINARY_RESPONSE_AUTH_ERROR,3,protocol_binary_response_status.PROTOCOL_BINARY_RESPONSE_AUTH_ERROR,,protocol_binary.h,PROTOCOL_BINARY_RESPONSE_AUTH_ERROR = 0x20,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
816,64289,PROTOCOL_BINARY_RESPONSE_AUTH_CONTINUE,3,protocol_binary_response_status.PROTOCOL_BINARY_RESPONSE_AUTH_CONTINUE,,protocol_binary.h,PROTOCOL_BINARY_RESPONSE_AUTH_CONTINUE = 0x21,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
817,64290,PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND,3,protocol_binary_response_status.PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND,,protocol_binary.h,PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND = 0x81,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
818,64291,PROTOCOL_BINARY_RESPONSE_ENOMEM,3,protocol_binary_response_status.PROTOCOL_BINARY_RESPONSE_ENOMEM,,protocol_binary.h,PROTOCOL_BINARY_RESPONSE_ENOMEM = 0x82,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
819,64331,PROTOCOL_BINARY_CMD_GET,3,protocol_binary_command.PROTOCOL_BINARY_CMD_GET,,protocol_binary.h,PROTOCOL_BINARY_CMD_GET = 0x00,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
820,64332,PROTOCOL_BINARY_CMD_SET,3,protocol_binary_command.PROTOCOL_BINARY_CMD_SET,,protocol_binary.h,PROTOCOL_BINARY_CMD_SET = 0x01,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
821,64333,PROTOCOL_BINARY_CMD_ADD,3,protocol_binary_command.PROTOCOL_BINARY_CMD_ADD,,protocol_binary.h,PROTOCOL_BINARY_CMD_ADD = 0x02,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
822,64334,PROTOCOL_BINARY_CMD_REPLACE,3,protocol_binary_command.PROTOCOL_BINARY_CMD_REPLACE,,protocol_binary.h,PROTOCOL_BINARY_CMD_REPLACE = 0x03,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
823,64335,PROTOCOL_BINARY_CMD_DELETE,3,protocol_binary_command.PROTOCOL_BINARY_CMD_DELETE,,protocol_binary.h,PROTOCOL_BINARY_CMD_DELETE = 0x04,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
824,64336,PROTOCOL_BINARY_CMD_INCREMENT,3,protocol_binary_command.PROTOCOL_BINARY_CMD_INCREMENT,,protocol_binary.h,PROTOCOL_BINARY_CMD_INCREMENT = 0x05,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
825,64337,PROTOCOL_BINARY_CMD_DECREMENT,3,protocol_binary_command.PROTOCOL_BINARY_CMD_DECREMENT,,protocol_binary.h,PROTOCOL_BINARY_CMD_DECREMENT = 0x06,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
826,64338,PROTOCOL_BINARY_CMD_QUIT,3,protocol_binary_command.PROTOCOL_BINARY_CMD_QUIT,,protocol_binary.h,PROTOCOL_BINARY_CMD_QUIT = 0x07,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
827,64339,PROTOCOL_BINARY_CMD_FLUSH,3,protocol_binary_command.PROTOCOL_BINARY_CMD_FLUSH,,protocol_binary.h,PROTOCOL_BINARY_CMD_FLUSH = 0x08,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
828,64340,PROTOCOL_BINARY_CMD_GETQ,3,protocol_binary_command.PROTOCOL_BINARY_CMD_GETQ,,protocol_binary.h,PROTOCOL_BINARY_CMD_GETQ = 0x09,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
829,64341,PROTOCOL_BINARY_CMD_NOOP,3,protocol_binary_command.PROTOCOL_BINARY_CMD_NOOP,,protocol_binary.h,PROTOCOL_BINARY_CMD_NOOP = 0x0a,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
830,64342,PROTOCOL_BINARY_CMD_VERSION,3,protocol_binary_command.PROTOCOL_BINARY_CMD_VERSION,,protocol_binary.h,PROTOCOL_BINARY_CMD_VERSION = 0x0b,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
831,64343,PROTOCOL_BINARY_CMD_GETK,3,protocol_binary_command.PROTOCOL_BINARY_CMD_GETK,,protocol_binary.h,PROTOCOL_BINARY_CMD_GETK = 0x0c,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
832,64344,PROTOCOL_BINARY_CMD_GETKQ,3,protocol_binary_command.PROTOCOL_BINARY_CMD_GETKQ,,protocol_binary.h,PROTOCOL_BINARY_CMD_GETKQ = 0x0d,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
833,64345,PROTOCOL_BINARY_CMD_APPEND,3,protocol_binary_command.PROTOCOL_BINARY_CMD_APPEND,,protocol_binary.h,PROTOCOL_BINARY_CMD_APPEND = 0x0e,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
834,64346,PROTOCOL_BINARY_CMD_PREPEND,3,protocol_binary_command.PROTOCOL_BINARY_CMD_PREPEND,,protocol_binary.h,PROTOCOL_BINARY_CMD_PREPEND = 0x0f,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
835,64347,PROTOCOL_BINARY_CMD_STAT,3,protocol_binary_command.PROTOCOL_BINARY_CMD_STAT,,protocol_binary.h,PROTOCOL_BINARY_CMD_STAT = 0x10,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
836,64348,PROTOCOL_BINARY_CMD_SETQ,3,protocol_binary_command.PROTOCOL_BINARY_CMD_SETQ,,protocol_binary.h,PROTOCOL_BINARY_CMD_SETQ = 0x11,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
837,64349,PROTOCOL_BINARY_CMD_ADDQ,3,protocol_binary_command.PROTOCOL_BINARY_CMD_ADDQ,,protocol_binary.h,PROTOCOL_BINARY_CMD_ADDQ = 0x12,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
838,64350,PROTOCOL_BINARY_CMD_REPLACEQ,3,protocol_binary_command.PROTOCOL_BINARY_CMD_REPLACEQ,,protocol_binary.h,PROTOCOL_BINARY_CMD_REPLACEQ = 0x13,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
839,64351,PROTOCOL_BINARY_CMD_DELETEQ,3,protocol_binary_command.PROTOCOL_BINARY_CMD_DELETEQ,,protocol_binary.h,PROTOCOL_BINARY_CMD_DELETEQ = 0x14,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
840,64352,PROTOCOL_BINARY_CMD_INCREMENTQ,3,protocol_binary_command.PROTOCOL_BINARY_CMD_INCREMENTQ,,protocol_binary.h,PROTOCOL_BINARY_CMD_INCREMENTQ = 0x15,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
841,64353,PROTOCOL_BINARY_CMD_DECREMENTQ,3,protocol_binary_command.PROTOCOL_BINARY_CMD_DECREMENTQ,,protocol_binary.h,PROTOCOL_BINARY_CMD_DECREMENTQ = 0x16,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
842,64354,PROTOCOL_BINARY_CMD_QUITQ,3,protocol_binary_command.PROTOCOL_BINARY_CMD_QUITQ,,protocol_binary.h,PROTOCOL_BINARY_CMD_QUITQ = 0x17,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
843,64355,PROTOCOL_BINARY_CMD_FLUSHQ,3,protocol_binary_command.PROTOCOL_BINARY_CMD_FLUSHQ,,protocol_binary.h,PROTOCOL_BINARY_CMD_FLUSHQ = 0x18,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
844,64356,PROTOCOL_BINARY_CMD_APPENDQ,3,protocol_binary_command.PROTOCOL_BINARY_CMD_APPENDQ,,protocol_binary.h,PROTOCOL_BINARY_CMD_APPENDQ = 0x19,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
845,64357,PROTOCOL_BINARY_CMD_PREPENDQ,3,protocol_binary_command.PROTOCOL_BINARY_CMD_PREPENDQ,,protocol_binary.h,PROTOCOL_BINARY_CMD_PREPENDQ = 0x1a,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
846,64358,PROTOCOL_BINARY_CMD_TOUCH,3,protocol_binary_command.PROTOCOL_BINARY_CMD_TOUCH,,protocol_binary.h,PROTOCOL_BINARY_CMD_TOUCH = 0x1c,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
847,64359,PROTOCOL_BINARY_CMD_GAT,3,protocol_binary_command.PROTOCOL_BINARY_CMD_GAT,,protocol_binary.h,PROTOCOL_BINARY_CMD_GAT = 0x1d,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
848,64360,PROTOCOL_BINARY_CMD_GATQ,3,protocol_binary_command.PROTOCOL_BINARY_CMD_GATQ,,protocol_binary.h,PROTOCOL_BINARY_CMD_GATQ = 0x1e,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
849,64361,PROTOCOL_BINARY_CMD_GATK,3,protocol_binary_command.PROTOCOL_BINARY_CMD_GATK,,protocol_binary.h,PROTOCOL_BINARY_CMD_GATK = 0x23,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
850,64362,PROTOCOL_BINARY_CMD_GATKQ,3,protocol_binary_command.PROTOCOL_BINARY_CMD_GATKQ,,protocol_binary.h,PROTOCOL_BINARY_CMD_GATKQ = 0x24,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
851,64363,PROTOCOL_BINARY_CMD_SASL_LIST_MECHS,3,protocol_binary_command.PROTOCOL_BINARY_CMD_SASL_LIST_MECHS,,protocol_binary.h,PROTOCOL_BINARY_CMD_SASL_LIST_MECHS = 0x20,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
852,64364,PROTOCOL_BINARY_CMD_SASL_AUTH,3,protocol_binary_command.PROTOCOL_BINARY_CMD_SASL_AUTH,,protocol_binary.h,PROTOCOL_BINARY_CMD_SASL_AUTH = 0x21,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
853,64365,PROTOCOL_BINARY_CMD_SASL_STEP,3,protocol_binary_command.PROTOCOL_BINARY_CMD_SASL_STEP,,protocol_binary.h,PROTOCOL_BINARY_CMD_SASL_STEP = 0x22,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
854,64366,PROTOCOL_BINARY_CMD_RGET,3,protocol_binary_command.PROTOCOL_BINARY_CMD_RGET,,protocol_binary.h,PROTOCOL_BINARY_CMD_RGET      = 0x30,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
855,64367,PROTOCOL_BINARY_CMD_RSET,3,protocol_binary_command.PROTOCOL_BINARY_CMD_RSET,,protocol_binary.h,PROTOCOL_BINARY_CMD_RSET      = 0x31,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
856,64368,PROTOCOL_BINARY_CMD_RSETQ,3,protocol_binary_command.PROTOCOL_BINARY_CMD_RSETQ,,protocol_binary.h,PROTOCOL_BINARY_CMD_RSETQ     = 0x32,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
857,64369,PROTOCOL_BINARY_CMD_RAPPEND,3,protocol_binary_command.PROTOCOL_BINARY_CMD_RAPPEND,,protocol_binary.h,PROTOCOL_BINARY_CMD_RAPPEND   = 0x33,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
858,64370,PROTOCOL_BINARY_CMD_RAPPENDQ,3,protocol_binary_command.PROTOCOL_BINARY_CMD_RAPPENDQ,,protocol_binary.h,PROTOCOL_BINARY_CMD_RAPPENDQ  = 0x34,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
859,64371,PROTOCOL_BINARY_CMD_RPREPEND,3,protocol_binary_command.PROTOCOL_BINARY_CMD_RPREPEND,,protocol_binary.h,PROTOCOL_BINARY_CMD_RPREPEND  = 0x35,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
860,64372,PROTOCOL_BINARY_CMD_RPREPENDQ,3,protocol_binary_command.PROTOCOL_BINARY_CMD_RPREPENDQ,,protocol_binary.h,PROTOCOL_BINARY_CMD_RPREPENDQ = 0x36,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
861,64373,PROTOCOL_BINARY_CMD_RDELETE,3,protocol_binary_command.PROTOCOL_BINARY_CMD_RDELETE,,protocol_binary.h,PROTOCOL_BINARY_CMD_RDELETE   = 0x37,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
862,64374,PROTOCOL_BINARY_CMD_RDELETEQ,3,protocol_binary_command.PROTOCOL_BINARY_CMD_RDELETEQ,,protocol_binary.h,PROTOCOL_BINARY_CMD_RDELETEQ  = 0x38,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
863,64375,PROTOCOL_BINARY_CMD_RINCR,3,protocol_binary_command.PROTOCOL_BINARY_CMD_RINCR,,protocol_binary.h,PROTOCOL_BINARY_CMD_RINCR     = 0x39,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
864,64376,PROTOCOL_BINARY_CMD_RINCRQ,3,protocol_binary_command.PROTOCOL_BINARY_CMD_RINCRQ,,protocol_binary.h,PROTOCOL_BINARY_CMD_RINCRQ    = 0x3a,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
865,64377,PROTOCOL_BINARY_CMD_RDECR,3,protocol_binary_command.PROTOCOL_BINARY_CMD_RDECR,,protocol_binary.h,PROTOCOL_BINARY_CMD_RDECR     = 0x3b,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
866,64378,PROTOCOL_BINARY_CMD_RDECRQ,3,protocol_binary_command.PROTOCOL_BINARY_CMD_RDECRQ,,protocol_binary.h,PROTOCOL_BINARY_CMD_RDECRQ    = 0x3c,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
867,64529,PROTOCOL_BINARY_RAW_BYTES,3,protocol_binary_datatypes.PROTOCOL_BINARY_RAW_BYTES,,protocol_binary.h,PROTOCOL_BINARY_RAW_BYTES = 0x00,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
868,64540,magic,3,protocol_binary_request_header.request.magic,,protocol_binary.h,magic,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
869,64541,opcode,3,protocol_binary_request_header.request.opcode,,protocol_binary.h,opcode,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
870,64542,keylen,3,protocol_binary_request_header.request.keylen,,protocol_binary.h,keylen,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
871,64543,extlen,3,protocol_binary_request_header.request.extlen,,protocol_binary.h,extlen,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
872,64544,datatype,3,protocol_binary_request_header.request.datatype,,protocol_binary.h,datatype,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
873,64545,reserved,3,protocol_binary_request_header.request.reserved,,protocol_binary.h,reserved,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
874,64546,bodylen,3,protocol_binary_request_header.request.bodylen,,protocol_binary.h,bodylen,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
875,64547,opaque,3,protocol_binary_request_header.request.opaque,,protocol_binary.h,opaque,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
876,64548,cas,3,protocol_binary_request_header.request.cas,,protocol_binary.h,cas,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
877,64549,request,3,protocol_binary_request_header.request,,protocol_binary.h,request,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
878,64550,bytes,3,protocol_binary_request_header.bytes,,protocol_binary.h,bytes[24],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
879,64560,magic,3,protocol_binary_response_header.response.magic,,protocol_binary.h,magic,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
880,64561,opcode,3,protocol_binary_response_header.response.opcode,,protocol_binary.h,opcode,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
881,64562,keylen,3,protocol_binary_response_header.response.keylen,,protocol_binary.h,keylen,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
882,64563,extlen,3,protocol_binary_response_header.response.extlen,,protocol_binary.h,extlen,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
883,64564,datatype,3,protocol_binary_response_header.response.datatype,,protocol_binary.h,datatype,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
884,64565,status,3,protocol_binary_response_header.response.status,,protocol_binary.h,status,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
885,64566,bodylen,3,protocol_binary_response_header.response.bodylen,,protocol_binary.h,bodylen,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
886,64567,opaque,3,protocol_binary_response_header.response.opaque,,protocol_binary.h,opaque,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
887,64568,cas,3,protocol_binary_response_header.response.cas,,protocol_binary.h,cas,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
888,64569,response,3,protocol_binary_response_header.response,,protocol_binary.h,response,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
889,64570,bytes,3,protocol_binary_response_header.bytes,,protocol_binary.h,bytes[24],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
890,64580,header,3,protocol_binary_request_no_extras.message.header,,protocol_binary.h,header,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
891,64581,message,3,protocol_binary_request_no_extras.message,,protocol_binary.h,message,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
892,64582,bytes,3,protocol_binary_request_no_extras.bytes,,protocol_binary.h,bytes[sizeof(protocol_binary_request_header)],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
893,64593,header,3,protocol_binary_response_no_extras.message.header,,protocol_binary.h,header,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
894,64594,message,3,protocol_binary_response_no_extras.message,,protocol_binary.h,message,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
895,64595,bytes,3,protocol_binary_response_no_extras.bytes,,protocol_binary.h,bytes[sizeof(protocol_binary_response_header)],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
896,64610,header,3,protocol_binary_response_get.message.header,,protocol_binary.h,header,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
897,64612,flags,3,protocol_binary_response_get.message.body.flags,,protocol_binary.h,flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
898,64613,body,3,protocol_binary_response_get.message.body,,protocol_binary.h,body,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
899,64614,message,3,protocol_binary_response_get.message,,protocol_binary.h,message,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
900,64615,bytes,3,protocol_binary_response_get.bytes,,protocol_binary.h,bytes[sizeof(protocol_binary_response_header) + 4],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
901,64633,header,3,protocol_binary_request_flush.message.header,,protocol_binary.h,header,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
902,64635,expiration,3,protocol_binary_request_flush.message.body.expiration,,protocol_binary.h,expiration,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
903,64636,body,3,protocol_binary_request_flush.message.body,,protocol_binary.h,body,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
904,64637,message,3,protocol_binary_request_flush.message,,protocol_binary.h,message,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
905,64638,bytes,3,protocol_binary_request_flush.bytes,,protocol_binary.h,bytes[sizeof(protocol_binary_request_header) + 4],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
906,64652,header,3,protocol_binary_request_set.message.header,,protocol_binary.h,header,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
907,64654,flags,3,protocol_binary_request_set.message.body.flags,,protocol_binary.h,flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
908,64655,expiration,3,protocol_binary_request_set.message.body.expiration,,protocol_binary.h,expiration,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
909,64656,body,3,protocol_binary_request_set.message.body,,protocol_binary.h,body,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
910,64657,message,3,protocol_binary_request_set.message,,protocol_binary.h,message,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
911,64658,bytes,3,protocol_binary_request_set.bytes,,protocol_binary.h,bytes[sizeof(protocol_binary_request_header) + 8],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
912,64678,header,3,protocol_binary_request_incr.message.header,,protocol_binary.h,header,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
913,64680,delta,3,protocol_binary_request_incr.message.body.delta,,protocol_binary.h,delta,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
914,64681,initial,3,protocol_binary_request_incr.message.body.initial,,protocol_binary.h,initial,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
915,64682,expiration,3,protocol_binary_request_incr.message.body.expiration,,protocol_binary.h,expiration,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
916,64683,body,3,protocol_binary_request_incr.message.body,,protocol_binary.h,body,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
917,64684,message,3,protocol_binary_request_incr.message,,protocol_binary.h,message,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
918,64685,bytes,3,protocol_binary_request_incr.bytes,,protocol_binary.h,bytes[sizeof(protocol_binary_request_header) + 20],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
919,64699,header,3,protocol_binary_response_incr.message.header,,protocol_binary.h,header,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
920,64701,value,3,protocol_binary_response_incr.message.body.value,,protocol_binary.h,value,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
921,64702,body,3,protocol_binary_response_incr.message.body,,protocol_binary.h,body,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
922,64703,message,3,protocol_binary_response_incr.message,,protocol_binary.h,message,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
923,64704,bytes,3,protocol_binary_response_incr.bytes,,protocol_binary.h,bytes[sizeof(protocol_binary_response_header) + 8],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
924,64728,header,3,protocol_binary_request_touch.message.header,,protocol_binary.h,header,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
925,64730,expiration,3,protocol_binary_request_touch.message.body.expiration,,protocol_binary.h,expiration,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
926,64731,body,3,protocol_binary_request_touch.message.body,,protocol_binary.h,body,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
927,64732,message,3,protocol_binary_request_touch.message,,protocol_binary.h,message,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
928,64733,bytes,3,protocol_binary_request_touch.bytes,,protocol_binary.h,bytes[sizeof(protocol_binary_request_header) + 4],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
929,64747,header,3,protocol_binary_request_gat.message.header,,protocol_binary.h,header,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
930,64749,expiration,3,protocol_binary_request_gat.message.body.expiration,,protocol_binary.h,expiration,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
931,64750,body,3,protocol_binary_request_gat.message.body,,protocol_binary.h,body,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
932,64751,message,3,protocol_binary_request_gat.message,,protocol_binary.h,message,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
933,64752,bytes,3,protocol_binary_request_gat.bytes,,protocol_binary.h,bytes[sizeof(protocol_binary_request_header) + 4],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
934,64772,header,3,protocol_binary_request_rangeop.message.header,,protocol_binary.h,header,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
935,64774,size,3,protocol_binary_request_rangeop.message.body.size,,protocol_binary.h,size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
936,64775,reserved,3,protocol_binary_request_rangeop.message.body.reserved,,protocol_binary.h,reserved,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
937,64776,flags,3,protocol_binary_request_rangeop.message.body.flags,,protocol_binary.h,flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
938,64777,max_results,3,protocol_binary_request_rangeop.message.body.max_results,,protocol_binary.h,max_results,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
939,64778,body,3,protocol_binary_request_rangeop.message.body,,protocol_binary.h,body,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
940,64779,message,3,protocol_binary_request_rangeop.message,,protocol_binary.h,message,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
941,64780,bytes,3,protocol_binary_request_rangeop.bytes,,protocol_binary.h,bytes[sizeof(protocol_binary_request_header) + 4],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
942,64844,P_OK,3,proxy_defines.P_OK,,proxy.h,P_OK = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
943,64845,CMD_MG,3,proxy_defines.CMD_MG,,proxy.h,CMD_FIELDS,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
944,64846,CMD_MS,3,proxy_defines.CMD_MS,,proxy.h,CMD_FIELDS,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
945,64847,CMD_MD,3,proxy_defines.CMD_MD,,proxy.h,CMD_FIELDS,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
946,64848,CMD_MN,3,proxy_defines.CMD_MN,,proxy.h,CMD_FIELDS,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
947,64849,CMD_MA,3,proxy_defines.CMD_MA,,proxy.h,CMD_FIELDS,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
948,64850,CMD_ME,3,proxy_defines.CMD_ME,,proxy.h,CMD_FIELDS,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
949,64851,CMD_GET,3,proxy_defines.CMD_GET,,proxy.h,CMD_FIELDS,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
950,64852,CMD_GAT,3,proxy_defines.CMD_GAT,,proxy.h,CMD_FIELDS,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
951,64853,CMD_SET,3,proxy_defines.CMD_SET,,proxy.h,CMD_FIELDS,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
952,64854,CMD_ADD,3,proxy_defines.CMD_ADD,,proxy.h,CMD_FIELDS,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
953,64855,CMD_CAS,3,proxy_defines.CMD_CAS,,proxy.h,CMD_FIELDS,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
954,64856,CMD_GETS,3,proxy_defines.CMD_GETS,,proxy.h,CMD_FIELDS,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
955,64857,CMD_GATS,3,proxy_defines.CMD_GATS,,proxy.h,CMD_FIELDS,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
956,64858,CMD_INCR,3,proxy_defines.CMD_INCR,,proxy.h,CMD_FIELDS,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
957,64859,CMD_DECR,3,proxy_defines.CMD_DECR,,proxy.h,CMD_FIELDS,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
958,64860,CMD_TOUCH,3,proxy_defines.CMD_TOUCH,,proxy.h,CMD_FIELDS,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
959,64861,CMD_APPEND,3,proxy_defines.CMD_APPEND,,proxy.h,CMD_FIELDS,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
960,64862,CMD_DELETE,3,proxy_defines.CMD_DELETE,,proxy.h,CMD_FIELDS,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
961,64863,CMD_REPLACE,3,proxy_defines.CMD_REPLACE,,proxy.h,CMD_FIELDS,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
962,64864,CMD_PREPEND,3,proxy_defines.CMD_PREPEND,,proxy.h,CMD_FIELDS,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
963,64865,CMD_END_STORAGE,3,proxy_defines.CMD_END_STORAGE,,proxy.h,CMD_FIELDS,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
964,64866,CMD_QUIT,3,proxy_defines.CMD_QUIT,,proxy.h,CMD_FIELDS,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
965,64867,CMD_STATS,3,proxy_defines.CMD_STATS,,proxy.h,CMD_FIELDS,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
966,64868,CMD_SLABS,3,proxy_defines.CMD_SLABS,,proxy.h,CMD_FIELDS,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
967,64869,CMD_WATCH,3,proxy_defines.CMD_WATCH,,proxy.h,CMD_FIELDS,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
968,64870,CMD_LRU,3,proxy_defines.CMD_LRU,,proxy.h,CMD_FIELDS,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
969,64871,CMD_VERSION,3,proxy_defines.CMD_VERSION,,proxy.h,CMD_FIELDS,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
970,64872,CMD_SHUTDOWN,3,proxy_defines.CMD_SHUTDOWN,,proxy.h,CMD_FIELDS,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
971,64873,CMD_EXTSTORE,3,proxy_defines.CMD_EXTSTORE,,proxy.h,CMD_FIELDS,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
972,64874,CMD_FLUSH_ALL,3,proxy_defines.CMD_FLUSH_ALL,,proxy.h,CMD_FIELDS,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
973,64875,CMD_VERBOSITY,3,proxy_defines.CMD_VERBOSITY,,proxy.h,CMD_FIELDS,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
974,64876,CMD_LRU_CRAWLER,3,proxy_defines.CMD_LRU_CRAWLER,,proxy.h,CMD_FIELDS,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
975,64877,CMD_REFRESH_CERTS,3,proxy_defines.CMD_REFRESH_CERTS,,proxy.h,CMD_FIELDS,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
976,64878,CMD_CACHE_MEMLIMIT,3,proxy_defines.CMD_CACHE_MEMLIMIT,,proxy.h,CMD_FIELDS,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
977,64879,CMD_SIZE,3,proxy_defines.CMD_SIZE,,proxy.h,CMD_SIZE,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
978,64880,CMD_ANY,3,proxy_defines.CMD_ANY,,proxy.h,CMD_ANY,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
979,64881,CMD_ANY_STORAGE,3,proxy_defines.CMD_ANY_STORAGE,,proxy.h,CMD_ANY_STORAGE,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
980,64882,CMD_FINAL,3,proxy_defines.CMD_FINAL,,proxy.h,CMD_FINAL,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
981,64891,CMD_TYPE_GENERIC,3,proxy_cmd_types.CMD_TYPE_GENERIC,,proxy.h,CMD_TYPE_GENERIC = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
982,64892,CMD_TYPE_GET,3,proxy_cmd_types.CMD_TYPE_GET,,proxy.h,CMD_TYPE_GET,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
983,64893,CMD_TYPE_META,3,proxy_cmd_types.CMD_TYPE_META,,proxy.h,CMD_TYPE_META,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
984,64902,P_BE_FAIL_TIMEOUT,3,proxy_be_failures.P_BE_FAIL_TIMEOUT,,proxy.h,P_BE_FAIL_TIMEOUT = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
985,64903,P_BE_FAIL_DISCONNECTED,3,proxy_be_failures.P_BE_FAIL_DISCONNECTED,,proxy.h,P_BE_FAIL_DISCONNECTED,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
986,64904,P_BE_FAIL_CONNECTING,3,proxy_be_failures.P_BE_FAIL_CONNECTING,,proxy.h,P_BE_FAIL_CONNECTING,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
987,64905,P_BE_FAIL_WRITING,3,proxy_be_failures.P_BE_FAIL_WRITING,,proxy.h,P_BE_FAIL_WRITING,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
988,64906,P_BE_FAIL_READING,3,proxy_be_failures.P_BE_FAIL_READING,,proxy.h,P_BE_FAIL_READING,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
989,64907,P_BE_FAIL_PARSING,3,proxy_be_failures.P_BE_FAIL_PARSING,,proxy.h,P_BE_FAIL_PARSING,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
990,64920,counters,3,proxy_int_stats.counters,,proxy.h,counters[CMD_FINAL],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,22,0,1,1,0,0,,0,0,0,0,0,
991,64928,num_stats,3,proxy_user_stats.num_stats,,proxy.h,num_stats,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
992,64929,names,3,proxy_user_stats.names,,proxy.h,**names,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
993,64930,counters,3,proxy_user_stats.counters,,proxy.h,*counters,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
994,64932,config_reloads,3,proxy_global_stats.config_reloads,,proxy.h,config_reloads,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
995,64933,config_reload_fails,3,proxy_global_stats.config_reload_fails,,proxy.h,config_reload_fails,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
996,64934,backend_total,3,proxy_global_stats.backend_total,,proxy.h,backend_total,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
997,64935,backend_disconn,3,proxy_global_stats.backend_disconn,,proxy.h,backend_disconn,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
998,64936,backend_requests,3,proxy_global_stats.backend_requests,,proxy.h,backend_requests,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
999,64937,backend_responses,3,proxy_global_stats.backend_responses,,proxy.h,backend_responses,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1000,64938,backend_errors,3,proxy_global_stats.backend_errors,,proxy.h,backend_errors,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1001,64939,backend_marked_bad,3,proxy_global_stats.backend_marked_bad,,proxy.h,backend_marked_bad,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1002,64940,backend_failed,3,proxy_global_stats.backend_failed,,proxy.h,backend_failed,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1003,64943,connect,3,proxy_tunables.connect,,proxy.h,connect,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1004,64945,retry,3,proxy_tunables.retry,,proxy.h,retry,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1005,64947,read,3,proxy_tunables.read,,proxy.h,read,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1006,64949,connect_ur,3,proxy_tunables.connect_ur,,proxy.h,connect_ur,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1007,64951,retry_ur,3,proxy_tunables.retry_ur,,proxy.h,retry_ur,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1008,64953,read_ur,3,proxy_tunables.read_ur,,proxy.h,read_ur,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1009,64954,backend_failure_limit,3,proxy_tunables.backend_failure_limit,,proxy.h,backend_failure_limit,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1010,64955,tcp_keepalive,3,proxy_tunables.tcp_keepalive,,proxy.h,tcp_keepalive,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1011,64958,stqh_first,3,pool_head_s.stqh_first,,proxy.h,mcp_pool_s *,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1012,64960,stqh_last,3,pool_head_s.stqh_last,,proxy.h,mcp_pool_s * *,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1013,64963,proxy_state,3,proxy_ctx_t.proxy_state,,proxy.h,*proxy_state,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1014,64964,proxy_code,3,proxy_ctx_t.proxy_code,,proxy.h,*proxy_code,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1015,64965,proxy_threads,3,proxy_ctx_t.proxy_threads,,proxy.h,*proxy_threads,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1016,64966,config_lock,3,proxy_ctx_t.config_lock,,proxy.h,config_lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1017,64967,config_cond,3,proxy_ctx_t.config_cond,,proxy.h,config_cond,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1018,64968,config_tid,3,proxy_ctx_t.config_tid,,proxy.h,config_tid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1019,64969,worker_lock,3,proxy_ctx_t.worker_lock,,proxy.h,worker_lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1020,64970,worker_cond,3,proxy_ctx_t.worker_cond,,proxy.h,worker_cond,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1021,64971,manager_tid,3,proxy_ctx_t.manager_tid,,proxy.h,manager_tid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1022,64972,manager_lock,3,proxy_ctx_t.manager_lock,,proxy.h,manager_lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
1023,64973,manager_cond,3,proxy_ctx_t.manager_cond,,proxy.h,manager_cond,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1024,64974,manager_head,3,proxy_ctx_t.manager_head,,proxy.h,manager_head,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,16,0,1,1,0,0,,0,0,0,0,0,
1025,64975,worker_done,3,proxy_ctx_t.worker_done,,proxy.h,worker_done,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1026,64976,worker_failed,3,proxy_ctx_t.worker_failed,,proxy.h,worker_failed,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1027,64977,use_uring,3,proxy_ctx_t.use_uring,,proxy.h,use_uring,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1028,64979,global_stats,3,proxy_ctx_t.global_stats,,proxy.h,global_stats,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
1029,64981,user_stats,3,proxy_ctx_t.user_stats,,proxy.h,user_stats,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1030,64983,tunables,3,proxy_ctx_t.tunables,,proxy.h,tunables,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,15,0,1,1,0,0,,0,0,0,0,0,
1031,64984,stats_lock,3,proxy_ctx_t.stats_lock,,proxy.h,stats_lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,27,0,1,1,0,0,,0,0,0,0,0,
1032,64987,tag,3,proxy_hook_tagged.tag,,proxy.h,tag,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1033,64988,lua_ref,3,proxy_hook_tagged.lua_ref,,proxy.h,lua_ref,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1034,64990,lua_ref,3,proxy_hook.lua_ref,,proxy.h,lua_ref,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1035,64991,tagcount,3,proxy_hook.tagcount,,proxy.h,tagcount,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
1036,64993,tagged,3,proxy_hook.tagged,,proxy.h,*tagged,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1037,65002,func,3,proxy_hash_func.func,,proxy.h,func,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1038,65018,selector_func,3,proxy_hash_caller.selector_func,,proxy.h,selector_func,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1039,65019,ctx,3,proxy_hash_caller.ctx,,proxy.h,*ctx,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1040,65021,mcp_backend_read,3,mcp_backend_states.mcp_backend_read,,proxy.h,mcp_backend_read = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1041,65022,mcp_backend_parse,3,mcp_backend_states.mcp_backend_parse,,proxy.h,mcp_backend_parse,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1042,65023,mcp_backend_read_end,3,mcp_backend_states.mcp_backend_read_end,,proxy.h,mcp_backend_read_end,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1043,65024,mcp_backend_want_read,3,mcp_backend_states.mcp_backend_want_read,,proxy.h,mcp_backend_want_read,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1044,65025,mcp_backend_next,3,mcp_backend_states.mcp_backend_next,,proxy.h,mcp_backend_next,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1045,65040,flags,3,mcp_parser_meta_s.flags,,proxy.h,flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1046,65042,request,3,mcp_parser_s.request,,proxy.h,*request,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1047,65043,vbuf,3,mcp_parser_s.vbuf,,proxy.h,*vbuf,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1048,65044,command,3,mcp_parser_s.command,,proxy.h,command,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1049,65045,cmd_type,3,mcp_parser_s.cmd_type,,proxy.h,cmd_type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1050,65046,ntokens,3,mcp_parser_s.ntokens,,proxy.h,ntokens,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1051,65047,keytoken,3,mcp_parser_s.keytoken,,proxy.h,keytoken,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1052,65048,parsed,3,mcp_parser_s.parsed,,proxy.h,parsed,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1053,65049,reqlen,3,mcp_parser_s.reqlen,,proxy.h,reqlen,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1054,65050,vlen,3,mcp_parser_s.vlen,,proxy.h,vlen,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1055,65051,klen,3,mcp_parser_s.klen,,proxy.h,klen,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1056,65052,tokens,3,mcp_parser_s.tokens,,proxy.h,tokens[PARSER_MAX_TOKENS],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1057,65053,has_space,3,mcp_parser_s.has_space,,proxy.h,has_space,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1058,65054,noreply,3,mcp_parser_s.noreply,,proxy.h,noreply,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1059,65057,meta,3,mcp_parser_s.t.meta,,proxy.h,meta,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1060,65058,t,3,mcp_parser_s.t,,proxy.h,t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1061,65068,pr,3,mcp_request_s.pr,,proxy.h,pr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1062,65070,start,3,mcp_request_s.start,,proxy.h,start,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1063,65071,be,3,mcp_request_s.be,,proxy.h,*be,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1064,65072,ascii_multiget,3,mcp_request_s.ascii_multiget,,proxy.h,ascii_multiget,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1065,65073,was_modified,3,mcp_request_s.was_modified,,proxy.h,was_modified,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1066,65074,tokent_ref,3,mcp_request_s.tokent_ref,,proxy.h,tokent_ref,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1067,65075,request,3,mcp_request_s.request,,proxy.h,request[],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1068,65083,stqh_first,3,io_head_s.stqh_first,,proxy.h,_io_pending_proxy_t *,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1069,65085,stqh_last,3,io_head_s.stqh_last,,proxy.h,_io_pending_proxy_t * *,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1070,65088,depth,3,mcp_backend_s.depth,,proxy.h,depth,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1071,65089,failed_count,3,mcp_backend_s.failed_count,,proxy.h,failed_count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1072,65090,mutex,3,mcp_backend_s.mutex,,proxy.h,mutex,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1073,65091,event_thread,3,mcp_backend_s.event_thread,,proxy.h,*event_thread,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1074,65092,client,3,mcp_backend_s.client,,proxy.h,*client,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1075,65095,stqe_next,3,mcp_backend_s.be_next.stqe_next,,proxy.h,mcp_backend_s *,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1076,65096,be_next,3,mcp_backend_s.be_next,,proxy.h,be_next,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1077,65097,io_head,3,mcp_backend_s.io_head,,proxy.h,io_head,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1078,65098,rbuf,3,mcp_backend_s.rbuf,,proxy.h,*rbuf,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1079,65099,rbufused,3,mcp_backend_s.rbufused,,proxy.h,rbufused,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1080,65101,event,3,mcp_backend_s.event,,proxy.h,event,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1081,65102,ur_rd_ev,3,mcp_backend_s.ur_rd_ev,,proxy.h,ur_rd_ev,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1082,65103,ur_wr_ev,3,mcp_backend_s.ur_wr_ev,,proxy.h,ur_wr_ev,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1083,65104,ur_te_ev,3,mcp_backend_s.ur_te_ev,,proxy.h,ur_te_ev,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1084,65106,state,3,mcp_backend_s.state,,proxy.h,state,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1085,65107,connect_flags,3,mcp_backend_s.connect_flags,,proxy.h,connect_flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1086,65108,connecting,3,mcp_backend_s.connecting,,proxy.h,connecting,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1087,65109,can_write,3,mcp_backend_s.can_write,,proxy.h,can_write,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1088,65110,stacked,3,mcp_backend_s.stacked,,proxy.h,stacked,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1089,65111,bad,3,mcp_backend_s.bad,,proxy.h,bad,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1090,65113,write_iovs,3,mcp_backend_s.write_iovs,,proxy.h,write_iovs[BE_IOV_MAX],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1091,65114,name,3,mcp_backend_s.name,,proxy.h,name[MAX_NAMELEN+1],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1092,65115,port,3,mcp_backend_s.port,,proxy.h,port[MAX_PORTLEN+1],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1093,65138,stqh_first,3,be_head_s.stqh_first,,proxy.h,mcp_backend_s *,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1094,65140,stqh_last,3,be_head_s.stqh_last,,proxy.h,mcp_backend_s * *,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1095,65143,thread_id,3,proxy_event_thread_s.thread_id,,proxy.h,thread_id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1096,65145,base,3,proxy_event_thread_s.base,,proxy.h,*base,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1097,65147,notify_event,3,proxy_event_thread_s.notify_event,,proxy.h,notify_event,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1098,65149,clock_event,3,proxy_event_thread_s.clock_event,,proxy.h,clock_event,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1099,65151,ring,3,proxy_event_thread_s.ring,,proxy.h,ring,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1100,65152,ur_notify_event,3,proxy_event_thread_s.ur_notify_event,,proxy.h,ur_notify_event,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1101,65153,ur_clock_event,3,proxy_event_thread_s.ur_clock_event,,proxy.h,ur_clock_event,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1102,65154,event_counter,3,proxy_event_thread_s.event_counter,,proxy.h,event_counter,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1103,65155,use_uring,3,proxy_event_thread_s.use_uring,,proxy.h,use_uring,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1104,65156,mutex,3,proxy_event_thread_s.mutex,,proxy.h,mutex,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1105,65157,cond,3,proxy_event_thread_s.cond,,proxy.h,cond,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1106,65158,io_head_in,3,proxy_event_thread_s.io_head_in,,proxy.h,io_head_in,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1107,65159,be_head,3,proxy_event_thread_s.be_head,,proxy.h,be_head,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1108,65160,event_fd,3,proxy_event_thread_s.event_fd,,proxy.h,event_fd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1109,65161,notify_receive_fd,3,proxy_event_thread_s.notify_receive_fd,,proxy.h,notify_receive_fd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1110,65162,notify_send_fd,3,proxy_event_thread_s.notify_send_fd,,proxy.h,notify_send_fd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1111,65163,ctx,3,proxy_event_thread_s.ctx,,proxy.h,*ctx,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1112,65165,tunables,3,proxy_event_thread_s.tunables,,proxy.h,tunables,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1113,65167,RESP_MODE_NORMAL,3,mcp_resp_mode.RESP_MODE_NORMAL,,proxy.h,RESP_MODE_NORMAL = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1114,65168,RESP_MODE_NOREPLY,3,mcp_resp_mode.RESP_MODE_NOREPLY,,proxy.h,RESP_MODE_NOREPLY,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1115,65169,RESP_MODE_METAQUIET,3,mcp_resp_mode.RESP_MODE_METAQUIET,,proxy.h,RESP_MODE_METAQUIET,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1116,65178,resp,3,mcp_resp_t.resp,,proxy.h,resp,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
1117,65179,buf,3,mcp_resp_t.buf,,proxy.h,*buf,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1118,65180,blen,3,mcp_resp_t.blen,,proxy.h,blen,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1119,65181,status,3,mcp_resp_t.status,,proxy.h,status,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1120,65182,bread,3,mcp_resp_t.bread,,proxy.h,bread,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1121,65183,cmd,3,mcp_resp_t.cmd,,proxy.h,cmd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1122,65185,mode,3,mcp_resp_t.mode,,proxy.h,mode,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1123,65186,be_name,3,mcp_resp_t.be_name,,proxy.h,be_name[MAX_NAMELEN+1],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1124,65187,be_port,3,mcp_resp_t.be_port,,proxy.h,be_port[MAX_PORTLEN+1],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1125,65206,io_queue_type,3,_io_pending_proxy_t.io_queue_type,,proxy.h,io_queue_type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1126,65207,thread,3,_io_pending_proxy_t.thread,,proxy.h,*thread,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1127,65208,c,3,_io_pending_proxy_t.c,,proxy.h,*c,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1128,65209,resp,3,_io_pending_proxy_t.resp,,proxy.h,*resp,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1129,65211,next,3,_io_pending_proxy_t.next,,proxy.h,*next,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1130,65214,stqe_next,3,_io_pending_proxy_t.io_next.stqe_next,,proxy.h,_io_pending_proxy_t *,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1131,65215,io_next,3,_io_pending_proxy_t.io_next,,proxy.h,io_next,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1132,65216,coro_ref,3,_io_pending_proxy_t.coro_ref,,proxy.h,coro_ref,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1133,65217,mcpres_ref,3,_io_pending_proxy_t.mcpres_ref,,proxy.h,mcpres_ref,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1134,65218,coro,3,_io_pending_proxy_t.coro,,proxy.h,*coro,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1135,65219,backend,3,_io_pending_proxy_t.backend,,proxy.h,*backend,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1136,65221,iov,3,_io_pending_proxy_t.iov,,proxy.h,iov[2],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1137,65222,iovcnt,3,_io_pending_proxy_t.iovcnt,,proxy.h,iovcnt,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1138,65223,iovbytes,3,_io_pending_proxy_t.iovbytes,,proxy.h,iovbytes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1139,65224,await_ref,3,_io_pending_proxy_t.await_ref,,proxy.h,await_ref,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1140,65225,client_resp,3,_io_pending_proxy_t.client_resp,,proxy.h,*client_resp,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1141,65226,flushed,3,_io_pending_proxy_t.flushed,,proxy.h,flushed,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1142,65227,ascii_multiget,3,_io_pending_proxy_t.ascii_multiget,,proxy.h,ascii_multiget,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1143,65228,is_await,3,_io_pending_proxy_t.is_await,,proxy.h,is_await,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1144,65229,await_first,3,_io_pending_proxy_t.await_first,,proxy.h,await_first,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1145,65237,ref,3,mcp_pool_be_t.ref,,proxy.h,ref,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1146,65238,be,3,mcp_pool_be_t.be,,proxy.h,*be,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1147,65244,phc,3,mcp_pool_s.phc,,proxy.h,phc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1148,65245,key_filter,3,mcp_pool_s.key_filter,,proxy.h,key_filter,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1149,65246,key_hasher,3,mcp_pool_s.key_hasher,,proxy.h,key_hasher,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1150,65247,lock,3,mcp_pool_s.lock,,proxy.h,lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1151,65248,ctx,3,mcp_pool_s.ctx,,proxy.h,*ctx,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1152,65251,stqe_next,3,mcp_pool_s.next.stqe_next,,proxy.h,mcp_pool_s *,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1153,65252,next,3,mcp_pool_s.next,,proxy.h,next,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1154,65253,key_filter_conf,3,mcp_pool_s.key_filter_conf,,proxy.h,key_filter_conf[KEY_HASH_FILTER_MAX+1],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1155,65254,hash_seed,3,mcp_pool_s.hash_seed,,proxy.h,hash_seed,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1156,65255,refcount,3,mcp_pool_s.refcount,,proxy.h,refcount,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1157,65256,phc_ref,3,mcp_pool_s.phc_ref,,proxy.h,phc_ref,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1158,65257,self_ref,3,mcp_pool_s.self_ref,,proxy.h,self_ref,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1159,65258,pool_size,3,mcp_pool_s.pool_size,,proxy.h,pool_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1160,65259,pool,3,mcp_pool_s.pool,,proxy.h,pool[],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1161,65272,main,3,mcp_pool_proxy_t.main,,proxy.h,*main,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1162,65285,AWAIT_GOOD,3,mcp_await_e.AWAIT_GOOD,,proxy.h,AWAIT_GOOD = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1163,65286,AWAIT_ANY,3,mcp_await_e.AWAIT_ANY,,proxy.h,AWAIT_ANY,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1164,65287,AWAIT_OK,3,mcp_await_e.AWAIT_OK,,proxy.h,AWAIT_OK,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1165,65288,AWAIT_FIRST,3,mcp_await_e.AWAIT_FIRST,,proxy.h,AWAIT_FIRST,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1166,65467,pending,3,mcp_await_s.pending,,proxy_await.c,pending,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1167,65468,wait_for,3,mcp_await_s.wait_for,,proxy_await.c,wait_for,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1168,65469,req_ref,3,mcp_await_s.req_ref,,proxy_await.c,req_ref,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1169,65470,argtable_ref,3,mcp_await_s.argtable_ref,,proxy_await.c,argtable_ref,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1170,65471,restable_ref,3,mcp_await_s.restable_ref,,proxy_await.c,restable_ref,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1171,65472,coro_ref,3,mcp_await_s.coro_ref,,proxy_await.c,coro_ref,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1172,65474,type,3,mcp_await_s.type,,proxy_await.c,type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1173,65475,completed,3,mcp_await_s.completed,,proxy_await.c,completed,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1174,65476,rq,3,mcp_await_s.rq,,proxy_await.c,*rq,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1175,65477,resp,3,mcp_await_s.resp,,proxy_await.c,*resp,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1176,66471,size,3,_dumpbuf.size,,proxy_config.c,size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1177,66472,used,3,_dumpbuf.used,,proxy_config.c,used,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1178,66473,buf,3,_dumpbuf.buf,,proxy_config.c,*buf,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1179,67879,phc,3,mcplib_jump_hash_t.phc,,proxy_jump_hash.c,phc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1180,67880,buckets,3,mcplib_jump_hash_t.buckets,,proxy_jump_hash.c,buckets,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1181,77048,point,3,cpoint.point,,proxy_ring_hash.c,point,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1182,77049,id,3,cpoint.id,,proxy_ring_hash.c,id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1183,77053,phc,3,ketama_t.phc,,proxy_ring_hash.c,phc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1184,77054,total_buckets,3,ketama_t.total_buckets,,proxy_ring_hash.c,total_buckets,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1185,77055,continuum,3,ketama_t.continuum,,proxy_ring_hash.c,continuum[],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,14,0,1,1,0,0,,0,0,0,0,0,
1186,78534,data,3,_restart_data_cb.data,,restart.c,*data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1187,78536,next,3,_restart_data_cb.next,,restart.c,*next,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1188,78537,ccb,3,_restart_data_cb.ccb,,restart.c,ccb,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1189,78538,scb,3,_restart_data_cb.scb,,restart.c,scb,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1190,78539,tag,3,_restart_data_cb.tag,,restart.c,tag[RESTART_TAG_MAXLEN],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1191,78649,f,3,restart_cb_ctx.f,,restart.c,*f,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1192,78650,cb,3,restart_cb_ctx.cb,,restart.c,*cb,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1193,78651,line,3,restart_cb_ctx.line,,restart.c,*line,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1194,78652,done,3,restart_cb_ctx.done,,restart.c,done,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1195,79763,RESTART_OK,3,restart_get_kv_ret.RESTART_OK,,restart.h,RESTART_OK=0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1196,79764,RESTART_NOTAG,3,restart_get_kv_ret.RESTART_NOTAG,,restart.h,RESTART_NOTAG,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1197,79765,RESTART_BADLINE,3,restart_get_kv_ret.RESTART_BADLINE,,restart.h,RESTART_BADLINE,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1198,79766,RESTART_DONE,3,restart_get_kv_ret.RESTART_DONE,,restart.h,RESTART_DONE,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1199,80051,age,3,window_data.age,,slab_automove.c,age,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1200,80052,dirty,3,window_data.dirty,,slab_automove.c,dirty,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
1201,80053,evicted_ratio,3,window_data.evicted_ratio,,slab_automove.c,evicted_ratio,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1202,80054,evicted_seen,3,window_data.evicted_seen,,slab_automove.c,evicted_seen,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1203,80057,window_data,3,slab_automove.window_data,,slab_automove.c,*window_data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1204,80058,window_size,3,slab_automove.window_size,,slab_automove.c,window_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1205,80059,window_cur,3,slab_automove.window_cur,,slab_automove.c,window_cur,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1206,80060,max_age_ratio,3,slab_automove.max_age_ratio,,slab_automove.c,max_age_ratio,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1207,80061,iam_before,3,slab_automove.iam_before,,slab_automove.c,iam_before[MAX_NUMBER_OF_SLAB_CLASSES],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1208,80062,iam_after,3,slab_automove.iam_after,,slab_automove.c,iam_after[MAX_NUMBER_OF_SLAB_CLASSES],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1209,80063,sam_before,3,slab_automove.sam_before,,slab_automove.c,sam_before[MAX_NUMBER_OF_SLAB_CLASSES],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1210,80064,sam_after,3,slab_automove.sam_after,,slab_automove.c,sam_after[MAX_NUMBER_OF_SLAB_CLASSES],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1211,80733,init,3,slab_automove_reg_t.init,,slab_automove.h,init,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1212,80734,free,3,slab_automove_reg_t.free,,slab_automove.h,free,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1213,80735,run,3,slab_automove_reg_t.run,,slab_automove.h,run,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1214,80751,age,3,window_data.age,,slab_automove_extstore.c,age,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1215,80752,dirty,3,window_data.dirty,,slab_automove_extstore.c,dirty,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1216,80753,evicted,3,window_data.evicted,,slab_automove_extstore.c,evicted,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1217,80754,excess_free,3,window_data.excess_free,,slab_automove_extstore.c,excess_free,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1218,80755,relaxed,3,window_data.relaxed,,slab_automove_extstore.c,relaxed,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1219,80758,window_data,3,slab_automove.window_data,,slab_automove_extstore.c,*window_data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1220,80760,settings,3,slab_automove.settings,,slab_automove_extstore.c,*settings,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1221,80761,window_size,3,slab_automove.window_size,,slab_automove_extstore.c,window_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,15,0,1,1,0,0,,0,0,0,0,0,
1222,80762,window_cur,3,slab_automove.window_cur,,slab_automove_extstore.c,window_cur,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1223,80763,item_size,3,slab_automove.item_size,,slab_automove_extstore.c,item_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1224,80764,max_age_ratio,3,slab_automove.max_age_ratio,,slab_automove_extstore.c,max_age_ratio,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1225,80765,free_ratio,3,slab_automove.free_ratio,,slab_automove_extstore.c,free_ratio,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1226,80766,pool_filled_once,3,slab_automove.pool_filled_once,,slab_automove_extstore.c,pool_filled_once,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1227,80767,global_pool_watermark,3,slab_automove.global_pool_watermark,,slab_automove_extstore.c,global_pool_watermark,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1228,80768,iam_before,3,slab_automove.iam_before,,slab_automove_extstore.c,iam_before[MAX_NUMBER_OF_SLAB_CLASSES],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
1229,80769,iam_after,3,slab_automove.iam_after,,slab_automove_extstore.c,iam_after[MAX_NUMBER_OF_SLAB_CLASSES],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
1230,80770,sam_before,3,slab_automove.sam_before,,slab_automove_extstore.c,sam_before[MAX_NUMBER_OF_SLAB_CLASSES],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
1231,80771,sam_after,3,slab_automove.sam_after,,slab_automove_extstore.c,sam_after[MAX_NUMBER_OF_SLAB_CLASSES],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,16,0,1,1,0,0,,0,0,0,0,0,
1232,81603,size,3,slabclass_t.size,,slabs.c,size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
1233,81604,perslab,3,slabclass_t.perslab,,slabs.c,perslab,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
1234,81605,slots,3,slabclass_t.slots,,slabs.c,*slots,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
1235,81606,sl_curr,3,slabclass_t.sl_curr,,slabs.c,sl_curr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
1236,81607,slabs,3,slabclass_t.slabs,,slabs.c,slabs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
1237,81608,slab_list,3,slabclass_t.slab_list,,slabs.c,**slab_list,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
1238,81609,list_size,3,slabclass_t.list_size,,slabs.c,list_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1239,84239,MOVE_PASS,3,move_status.MOVE_PASS,,slabs.c,MOVE_PASS=0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1240,84240,MOVE_FROM_SLAB,3,move_status.MOVE_FROM_SLAB,,slabs.c,MOVE_FROM_SLAB,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1241,84241,MOVE_FROM_LRU,3,move_status.MOVE_FROM_LRU,,slabs.c,MOVE_FROM_LRU,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1242,84242,MOVE_BUSY,3,move_status.MOVE_BUSY,,slabs.c,MOVE_BUSY,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1243,84243,MOVE_LOCKED,3,move_status.MOVE_LOCKED,,slabs.c,MOVE_LOCKED,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1244,85798,chunks_per_page,3,slab_stats_automove.chunks_per_page,,slabs.h,chunks_per_page,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1245,85799,chunk_size,3,slab_stats_automove.chunk_size,,slabs.h,chunk_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1246,85800,free_chunks,3,slab_stats_automove.free_chunks,,slabs.h,free_chunks,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1247,85801,total_pages,3,slab_stats_automove.total_pages,,slabs.h,total_pages,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1248,85847,REASSIGN_OK,3,reassign_result_type.REASSIGN_OK,,slabs.h,REASSIGN_OK=0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1249,85848,REASSIGN_RUNNING,3,reassign_result_type.REASSIGN_RUNNING,,slabs.h,REASSIGN_RUNNING,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1250,85849,REASSIGN_BADCLASS,3,reassign_result_type.REASSIGN_BADCLASS,,slabs.h,REASSIGN_BADCLASS,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1251,85850,REASSIGN_NOSPARE,3,reassign_result_type.REASSIGN_NOSPARE,,slabs.h,REASSIGN_NOSPARE,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1252,85851,REASSIGN_SRC_DST_SAME,3,reassign_result_type.REASSIGN_SRC_DST_SAME,,slabs.h,REASSIGN_SRC_DST_SAME,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1253,86414,prefix,3,_prefix_stats.prefix,,stats_prefix.h,*prefix,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1254,86415,prefix_len,3,_prefix_stats.prefix_len,,stats_prefix.h,prefix_len,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1255,86416,num_gets,3,_prefix_stats.num_gets,,stats_prefix.h,num_gets,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1256,86417,num_sets,3,_prefix_stats.num_sets,,stats_prefix.h,num_sets,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1257,86418,num_deletes,3,_prefix_stats.num_deletes,,stats_prefix.h,num_deletes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1258,86419,num_hits,3,_prefix_stats.num_hits,,stats_prefix.h,num_hits,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1259,86420,next,3,_prefix_stats.next,,stats_prefix.h,*next,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1260,86612,TEST_SKIP,3,test_return.TEST_SKIP,,testapp.c,TEST_SKIP,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1261,86613,TEST_PASS,3,test_return.TEST_PASS,,testapp.c,TEST_PASS,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1262,86614,TEST_FAIL,3,test_return.TEST_FAIL,,testapp.c,TEST_FAIL,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1263,86616,sock,3,conn.sock,,testapp.c,sock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1264,86617,ssl_ctx,3,conn.ssl_ctx,,testapp.c,*ssl_ctx,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1265,86618,ssl,3,conn.ssl,,testapp.c,*ssl,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1266,93657,description,3,testcase.description,,testapp.c,*description,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1267,93658,function,3,testcase.function,,testapp.c,function,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1268,94009,queue_new_conn,3,conn_queue_item_modes.queue_new_conn,,thread.c,queue_new_conn,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1269,94010,queue_pause,3,conn_queue_item_modes.queue_pause,,thread.c,queue_pause,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1270,94011,queue_timeout,3,conn_queue_item_modes.queue_timeout,,thread.c,queue_timeout,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1271,94012,queue_redispatch,3,conn_queue_item_modes.queue_redispatch,,thread.c,queue_redispatch,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1272,94013,queue_stop,3,conn_queue_item_modes.queue_stop,,thread.c,queue_stop,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1273,94014,queue_return_io,3,conn_queue_item_modes.queue_return_io,,thread.c,queue_return_io,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1274,94018,sfd,3,conn_queue_item.sfd,,thread.c,sfd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1275,94020,init_state,3,conn_queue_item.init_state,,thread.c,init_state,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1276,94021,event_flags,3,conn_queue_item.event_flags,,thread.c,event_flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1277,94022,read_buffer_size,3,conn_queue_item.read_buffer_size,,thread.c,read_buffer_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1278,94024,transport,3,conn_queue_item.transport,,thread.c,transport,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1279,94026,mode,3,conn_queue_item.mode,,thread.c,mode,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1280,94027,c,3,conn_queue_item.c,,thread.c,*c,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1281,94028,ssl,3,conn_queue_item.ssl,,thread.c,*ssl,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1282,94029,conntag,3,conn_queue_item.conntag,,thread.c,conntag,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1283,94031,bproto,3,conn_queue_item.bproto,,thread.c,bproto,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1284,94032,io,3,conn_queue_item.io,,thread.c,*io,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1285,94035,stqe_next,3,conn_queue_item.i_next.stqe_next,,thread.c,conn_queue_item *,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1286,94036,i_next,3,conn_queue_item.i_next,,thread.c,i_next,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1287,94042,stqh_first,3,conn_queue.conn_ev_head.stqh_first,,thread.c,conn_queue_item *,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1288,94044,stqh_last,3,conn_queue.conn_ev_head.stqh_last,,thread.c,conn_queue_item * *,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1289,94045,head,3,conn_queue.head,,thread.c,head,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1290,94046,lock,3,conn_queue.lock,,thread.c,lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1291,94047,cache,3,conn_queue.cache,,thread.c,*cache,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1292,98731,fd,3,mcmc_ctx.fd,,vendor\mcmc\mcmc.c,fd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1293,98732,gai_status,3,mcmc_ctx.gai_status,,vendor\mcmc\mcmc.c,gai_status,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1294,98733,last_sys_error,3,mcmc_ctx.last_sys_error,,vendor\mcmc\mcmc.c,last_sys_error,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1295,98734,sent_bytes_partial,3,mcmc_ctx.sent_bytes_partial,,vendor\mcmc\mcmc.c,sent_bytes_partial,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1296,98735,fail_code,3,mcmc_ctx.fail_code,,vendor\mcmc\mcmc.c,fail_code,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1297,98736,error,3,mcmc_ctx.error,,vendor\mcmc\mcmc.c,error,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1298,98737,status_flags,3,mcmc_ctx.status_flags,,vendor\mcmc\mcmc.c,status_flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1299,98738,state,3,mcmc_ctx.state,,vendor\mcmc\mcmc.c,state,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1300,98739,buffer_used,3,mcmc_ctx.buffer_used,,vendor\mcmc\mcmc.c,buffer_used,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1301,98740,buffer_request_len,3,mcmc_ctx.buffer_request_len,,vendor\mcmc\mcmc.c,buffer_request_len,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1302,98741,buffer_head,3,mcmc_ctx.buffer_head,,vendor\mcmc\mcmc.c,*buffer_head,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1303,100254,type,3,mcmc_resp_t.type,,vendor\mcmc\mcmc.h,type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
1304,100255,code,3,mcmc_resp_t.code,,vendor\mcmc\mcmc.h,code,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1305,100256,value,3,mcmc_resp_t.value,,vendor\mcmc\mcmc.h,*value,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1306,100257,reslen,3,mcmc_resp_t.reslen,,vendor\mcmc\mcmc.h,reslen,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1307,100258,vlen_read,3,mcmc_resp_t.vlen_read,,vendor\mcmc\mcmc.h,vlen_read,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1308,100259,vlen,3,mcmc_resp_t.vlen,,vendor\mcmc\mcmc.h,vlen,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1309,100262,rline,3,mcmc_resp_t.anonymous_composite_type_2.anonymous_composite_type_1.rline,,vendor\mcmc\mcmc.h,*rline,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1310,100263,rlen,3,mcmc_resp_t.anonymous_composite_type_2.anonymous_composite_type_1.rlen,,vendor\mcmc\mcmc.h,rlen,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1311,100265,key,3,mcmc_resp_t.anonymous_composite_type_4.anonymous_composite_type_3.key,,vendor\mcmc\mcmc.h,*key,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1312,100266,klen,3,mcmc_resp_t.anonymous_composite_type_4.anonymous_composite_type_3.klen,,vendor\mcmc\mcmc.h,klen,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1313,100267,flags,3,mcmc_resp_t.anonymous_composite_type_4.anonymous_composite_type_3.flags,,vendor\mcmc\mcmc.h,flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1314,100268,cas,3,mcmc_resp_t.anonymous_composite_type_4.anonymous_composite_type_3.cas,,vendor\mcmc\mcmc.h,cas,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1315,100270,stat,3,mcmc_resp_t.anonymous_composite_type_6.anonymous_composite_type_5.stat,,vendor\mcmc\mcmc.h,*stat,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1316,100271,slen,3,mcmc_resp_t.anonymous_composite_type_6.anonymous_composite_type_5.slen,,vendor\mcmc\mcmc.h,slen,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1317,100392,XXH_OK,3,XXH_errorcode.XXH_OK,,xxhash.h,XXH_OK=0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1318,100393,XXH_ERROR,3,XXH_errorcode.XXH_ERROR,,xxhash.h,XXH_ERROR,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1319,100447,digest,3,XXH32_canonical_t.digest,,xxhash.h,digest[4],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1320,100511,digest,3,XXH64_canonical_t.digest,,xxhash.h,digest[sizeof(XXH64_hash_t)],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1321,100601,low64,3,XXH128_hash_t.low64,,xxhash.h,low64,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1322,100602,high64,3,XXH128_hash_t.high64,,xxhash.h,high64,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1323,100668,digest,3,XXH128_canonical_t.digest,,xxhash.h,digest[sizeof(XXH128_hash_t)],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1324,63,assoc_init,1,assoc_init,void assoc_init (int),assoc.c,"void assoc_init(const int hashtable_init) {
    if (hashtable_init) {
        hashpower = hashtable_init;
    }
    primary_hashtable = calloc(hashsize(hashpower), sizeof(void *));
    if (! primary_hashtable) {
        fprintf(stderr, ""Failed to init hashtable.\n"");
        exit(EXIT_FAILURE);
    }
    STATS_LOCK();
    stats_state.hash_power_level = hashpower;
    stats_state.hash_bytes = hashsize(hashpower) * sizeof(void *);
    STATS_UNLOCK();
}",55.0,68.0,1.0,31.0,14.0,14,7,16,7,1,12,3,3,1,0,,0,10,2,1,1,void
1325,118,assoc_find,1,assoc_find,"item assoc_find (char*,size_t,uint32_t)",assoc.c,"item *assoc_find(const char *key, const size_t nkey, const uint32_t hv) {
    item *it;
    uint64_t oldbucket;

    if (expanding &&
        (oldbucket = (hv & hashmask(hashpower - 1))) >= expand_bucket)
    {
        it = old_hashtable[oldbucket];
    } else {
        it = primary_hashtable[hv & hashmask(hashpower)];
    }

    item *ret = NULL;
    int depth = 0;
    while (it) {
        if ((nkey == it->nkey) && (memcmp(key, ITEM_key(it), nkey) == 0)) {
            ret = it;
            break;
        }
        it = it->h_next;
        ++depth;
    }
    MEMCACHED_ASSOC_FIND(key, nkey, depth);
    return ret;
}",70.0,94.0,1.0,27.0,25.0,28,15,26,13,1,4,5,5,3,0,,0,4,6,3,3,item
1326,227,_hashitem_before,1,_hashitem_before,"item _hashitem_before (char*,size_t,uint32_t)",assoc.c,"static item** _hashitem_before (const char *key, const size_t nkey, const uint32_t hv) {
    item **pos;
    uint64_t oldbucket;

    if (expanding &&
        (oldbucket = (hv & hashmask(hashpower - 1))) >= expand_bucket)
    {
        pos = &old_hashtable[oldbucket];
    } else {
        pos = &primary_hashtable[hv & hashmask(hashpower)];
    }

    while (*pos && ((nkey != (*pos)->nkey) || memcmp(key, ITEM_key(*pos), nkey))) {
        pos = &(*pos)->h_next;
    }
    return pos;
}",99.0,115.0,1.0,27.0,17.0,32,16,20,10,1,4,3,3,3,0,,0,4,6,3,3,item
1327,328,assoc_expand,1,assoc_expand,void assoc_expand (void),assoc.c,"static void assoc_expand(void) {
    old_hashtable = primary_hashtable;

    primary_hashtable = calloc(hashsize(hashpower + 1), sizeof(void *));
    if (primary_hashtable) {
        if (settings.verbose > 1)
            fprintf(stderr, ""Hash table expansion starting\n"");
        hashpower++;
        expanding = true;
        expand_bucket = 0;
        STATS_LOCK();
        stats_state.hash_power_level = hashpower;
        stats_state.hash_bytes += hashsize(hashpower) * sizeof(void *);
        stats_state.hash_is_expanding = true;
        STATS_UNLOCK();
    } else {
        primary_hashtable = old_hashtable;
        /* Bad news, but we can keep running. */
    }
}",118.0,137.0,1.0,31.0,20.0,21,10,20,10,1,17,3,4,2,0,,0,15,2,1,1,void
1328,403,assoc_start_expand,1,assoc_start_expand,void assoc_start_expand (uint64_t),assoc.c,"void assoc_start_expand(uint64_t curr_items) {
    if (pthread_mutex_trylock(&maintenance_lock) == 0) {
        if (curr_items > (hashsize(hashpower) * 3) / 2 && hashpower < HASHPOWER_MAX) {
            pthread_cond_signal(&maintenance_cond);
        }
        pthread_mutex_unlock(&maintenance_lock);
    }
}",139.0,146.0,1.0,26.0,8.0,11,9,7,4,1,6,3,4,4,0,,0,6,2,1,1,void
1329,443,assoc_insert,1,assoc_insert,"int assoc_insert (item*,uint32_t)",assoc.c,"int assoc_insert(item *it, const uint32_t hv) {
    uint64_t oldbucket;

//    assert(assoc_find(ITEM_key(it), it->nkey) == 0);  /* shouldn't have duplicately named things defined */

    if (expanding &&
        (oldbucket = (hv & hashmask(hashpower - 1))) >= expand_bucket)
    {
        it->h_next = old_hashtable[oldbucket];
        old_hashtable[oldbucket] = it;
    } else {
        it->h_next = primary_hashtable[hv & hashmask(hashpower)];
        primary_hashtable[hv & hashmask(hashpower)] = it;
    }

    MEMCACHED_ASSOC_INSERT(ITEM_key(it), it->nkey);
    return 1;
}",149.0,166.0,1.0,27.0,18.0,13,9,11,7,2,5,2,2,3,0,,0,5,4,2,2,int
1330,521,assoc_delete,1,assoc_delete,"void assoc_delete (char*,size_t,uint32_t)",assoc.c,"void assoc_delete(const char *key, const size_t nkey, const uint32_t hv) {
    item **before = _hashitem_before(key, nkey, hv);

    if (*before) {
        item *nxt;
        /* The DTrace probe cannot be triggered as the last instruction
         * due to possible tail-optimization by the compiler
         */
        MEMCACHED_ASSOC_DELETE(key, nkey);
        nxt = (*before)->h_next;
        (*before)->h_next = 0;   /* probably pointless, but whatever. */
        *before = nxt;
        return;
    }
    /* Note:  we never actually get here.  the callers don't delete things
       they can't find. */
    assert(*before != 0);
}",168.0,185.0,1.0,8.0,18.0,12,4,11,5,2,1,2,2,0,1,,0,1,6,3,3,void
1331,572,assoc_maintenance_thread,1,assoc_maintenance_thread,void* assoc_maintenance_thread (void*),assoc.c,"static void *assoc_maintenance_thread(void *arg) {

    mutex_lock(&maintenance_lock);
    while (do_run_maintenance_thread) {
        int ii = 0;

        /* There is only one expansion thread, so no need to global lock. */
        for (ii = 0; ii < hash_bulk_move && expanding; ++ii) {
            item *it, *next;
            uint64_t bucket;
            void *item_lock = NULL;

            /* bucket = hv & hashmask(hashpower) =>the bucket of hash table
             * is the lowest N bits of the hv, and the bucket of item_locks is
             *  also the lowest M bits of hv, and N is greater than M.
             *  So we can process expanding with only one item_lock. cool! */
            if ((item_lock = item_trylock(expand_bucket))) {
                    for (it = old_hashtable[expand_bucket]; NULL != it; it = next) {
                        next = it->h_next;
                        bucket = hash(ITEM_key(it), it->nkey) & hashmask(hashpower);
                        it->h_next =...",193.0,260.0,1.0,4.0,68.0,57,21,62,23,0,36,10,28,10,5,,0,30,2,1,1,void*
1332,783,start_assoc_maintenance_thread,1,start_assoc_maintenance_thread,int start_assoc_maintenance_thread (),assoc.c,"int start_assoc_maintenance_thread() {
    int ret;
    char *env = getenv(""MEMCACHED_HASH_BULK_MOVE"");
    if (env != NULL) {
        hash_bulk_move = atoi(env);
        if (hash_bulk_move == 0) {
            hash_bulk_move = DEFAULT_HASH_BULK_MOVE;
        }
    }

    if ((ret = pthread_create(&maintenance_tid, NULL,
                              assoc_maintenance_thread, NULL)) != 0) {
        fprintf(stderr, ""Can't create thread: %s\n"", strerror(ret));
        return -1;
    }
    return 0;
}",264.0,280.0,1.0,29.0,17.0,9,5,13,6,1,4,4,5,2,0,,0,4,0,0,0,int
1333,834,stop_assoc_maintenance_thread,1,stop_assoc_maintenance_thread,void stop_assoc_maintenance_thread (),assoc.c,"void stop_assoc_maintenance_thread() {
    mutex_lock(&maintenance_lock);
    do_run_maintenance_thread = 0;
    pthread_cond_signal(&maintenance_cond);
    mutex_unlock(&maintenance_lock);

    /* Wait for the maintenance thread to stop */
    pthread_join(maintenance_tid, NULL);
}",282.0,290.0,1.0,4.0,9.0,6,2,8,5,0,7,1,1,0,0,,0,7,0,0,0,void
1334,866,assoc_get_iterator,1,assoc_get_iterator,void* assoc_get_iterator (void),assoc.c,"void *assoc_get_iterator(void) {
    struct assoc_iterator *iter = calloc(1, sizeof(struct assoc_iterator));
    if (iter == NULL) {
        return NULL;
    }
    // this will hang the caller while a hash table expansion is running.
    mutex_lock(&maintenance_lock);
    return iter;
}",299.0,307.0,1.0,4.0,9.0,5,4,8,4,1,2,2,2,0,0,,0,2,2,1,1,void*
1335,894,assoc_iterate,1,assoc_iterate,"bool assoc_iterate (void*,item**)",assoc.c,"bool assoc_iterate(void *iterp, item **it) {
    struct assoc_iterator *iter = (struct assoc_iterator *) iterp;
    *it = NULL;
    // - if locked bucket and next, update next and return
    if (iter->bucket_locked) {
        if (iter->next != NULL) {
            iter->it = iter->next;
            iter->next = iter->it->h_next;
            *it = iter->it;
        } else {
            // unlock previous bucket, if any
            item_unlock(iter->bucket);
            // iterate the bucket post since it starts at 0.
            iter->bucket++;
            iter->bucket_locked = false;
            *it = NULL;
        }
        return true;
    }

    // - loop until we hit the end or find something.
    if (iter->bucket != hashsize(hashpower)) {
        // - lock next bucket
        item_lock(iter->bucket);
        iter->bucket_locked = true;
        // - only check the primary hash table since expand is blocked.
        iter->it = primary_hashtable[iter->bucket];
        if (iter->it ...",309.0,351.0,1.0,24.0,43.0,37,7,30,7,1,20,5,7,6,1,,0,19,4,2,2,bool
1336,1040,assoc_iterate_final,1,assoc_iterate_final,void assoc_iterate_final (void*),assoc.c,"void assoc_iterate_final(void *iterp) {
    struct assoc_iterator *iter = (struct assoc_iterator *) iterp;
    if (iter->bucket_locked) {
        item_unlock(iter->bucket);
    }
    mutex_unlock(&maintenance_lock);
    free(iter);
}",353.0,360.0,1.0,4.0,8.0,6,4,7,3,1,5,2,2,1,1,,0,4,2,1,1,void
1337,1099,do_assoc_move_next_bucket,1,do_assoc_move_next_bucket,void do_assoc_move_next_bucket (void),assoc.h,void do_assoc_move_next_bucket(void);,6.0,6.0,6.0,36.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
1338,1181,authfile_load,1,authfile_load,enum authfile_ret authfile_load (char*),authfile.c,"enum authfile_ret authfile_load(const char *file) {
    struct stat sb;
    char *auth_data = NULL;
    auth_t auth_entries[MAX_ENTRIES];

    FILE *pwfile = fopen(file, ""r"");
    if (pwfile == NULL) {
        return AUTHFILE_OPENFAIL;
    } else if (fstat(fileno(pwfile), &sb)) {
        fclose(pwfile);
        return AUTHFILE_STATFAIL;
    }

    auth_data = calloc(1, sb.st_size + 1);

    char *auth_cur = auth_data;
    char *auth_end = auth_data + sb.st_size;
    auth_t *entry_cur = auth_entries;
    int used = 0;

    while ((fgets(auth_cur, auth_end - auth_cur < MAX_ENTRY_LEN ? auth_end - auth_cur : MAX_ENTRY_LEN, pwfile)) != NULL) {
        int x;
        int found = 0;

        for (x = 0; x < MAX_ENTRY_LEN; x++) {
            if (!found) {
                if (auth_cur[x] == '\0') {
                    // The username is malformed - this is either the end of the file or a null byte.
                    break;
                } else if (auth_cur[x] == ':') {
                  ...",31.0,109.0,1.0,24.0,79.0,36,15,52,18,2,5,13,19,1,0,,0,5,2,1,1,enum authfile_ret
1339,1421,authfile_check,1,authfile_check,"int authfile_check (char*,char*)",authfile.c,"int authfile_check(const char *user, const char *pass) {
    size_t ulen = strlen(user);
    size_t plen = strlen(pass);

    for (int x = 0; x < entry_cnt; x++) {
        auth_t *e = &main_auth_entries[x];
        if (ulen == e->ulen && plen == e->plen &&
            safe_memcmp(user, e->user, e->ulen) &&
            safe_memcmp(pass, e->pass, e->plen)) {
            return 1;
        }
    }

    return 0;
}",112.0,126.0,1.0,1.0,15.0,18,7,20,8,1,4,3,4,3,2,,0,4,4,2,2,int
1340,1790,base64_encode,1,base64_encode,"size_t base64_encode (unsigned char*,size_t,unsigned char*,size_t)",base64.c,"size_t base64_encode(const unsigned char *src, size_t len,
                  unsigned char *out, size_t out_len)
{
    unsigned char *pos;
    const unsigned char *end, *in;
    size_t olen;

    olen = len * 4 / 3 + 4; /* 3-byte blocks to 4-byte */
    olen += olen / 72; /* line feeds */
    olen++; /* nul termination */
    if (olen < len) {
        return 0; /* integer overflow */
    }
    if (olen > out_len) {
        return 0; /* not enough space in output buffer */
    }
    if (out == NULL) {
        return 0;
    }

    end = src + len;
    in = src;
    pos = out;
    while (end - in >= 3) {
        *pos++ = base64_table[in[0] >> 2];
        *pos++ = base64_table[((in[0] & 0x03) << 4) | (in[1] >> 4)];
        *pos++ = base64_table[((in[1] & 0x0f) << 2) | (in[2] >> 6)];
        *pos++ = base64_table[in[2] & 0x3f];
        in += 3;
    }

    if (end - in) {
        *pos++ = base64_table[in[0] >> 2];
        if (end - in == 1) {
            *pos++ = base64_table[(in[0] & 0x0...",93.0,139.0,1.0,1.0,47.0,74,17,50,10,5,6,7,8,0,0,,0,6,8,4,4,size_t
1341,2008,base64_decode,1,base64_decode,"size_t base64_decode (unsigned char*,size_t,unsigned char*,size_t)",base64.c,"size_t base64_decode(const unsigned char *src, size_t len,
                  unsigned char *out, size_t out_len)
{
    unsigned char *pos, block[4], tmp;
    size_t i, count, olen;
    int pad = 0;

    count = 0;
    for (i = 0; i < len; i++) {
        if (dtable[src[i]] != 0x80)
            count++;
    }

    if (count == 0 || count % 4)
        return 0;

    olen = count / 4 * 3;
    if (olen > out_len) {
        return 0;
    }
    pos = out;
    if (out == NULL) {
        return 0;
    }

    count = 0;
    for (i = 0; i < len; i++) {
        tmp = dtable[src[i]];
        if (tmp == 0x80)
            continue;

        if (src[i] == '=')
            pad++;
        block[count] = tmp;
        count++;
        if (count == 4) {
            *pos++ = (block[0] << 2) | (block[1] >> 4);
            *pos++ = (block[1] << 4) | (block[2] >> 2);
            *pos++ = (block[2] << 6) | block[3];
            count = 0;
            if (pad) {
                if (pad == 1)
                 ...",150.0,205.0,1.0,1.0,56.0,58,17,51,13,2,2,14,21,1,0,,0,2,8,4,4,size_t
1342,2243,bipbuf_sizeof,1,bipbuf_sizeof,size_t bipbuf_sizeof (unsigned int),bipbuffer.c,"static size_t bipbuf_sizeof(const unsigned int size)
{
    return sizeof(bipbuf_t) + size;
}",18.0,21.0,1.0,1.0,4.0,2,2,2,2,1,0,1,1,0,0,,0,0,2,1,1,size_t
1343,2253,bipbuf_unused,1,bipbuf_unused,int bipbuf_unused (bipbuf_t*),bipbuffer.c,"int bipbuf_unused(const bipbuf_t* me)
{
    if (1 == me->b_inuse)
        /* distance between region B and region A */
        return me->a_start - me->b_end;
    else
        return me->size - me->a_end;
}",23.0,30.0,1.0,1.0,8.0,5,3,3,1,3,3,2,2,1,0,,0,3,2,1,1,int
1344,2283,bipbuf_size,1,bipbuf_size,int bipbuf_size (bipbuf_t*),bipbuffer.c,"int bipbuf_size(const bipbuf_t* me)
{
    return me->size;
}",32.0,35.0,1.0,1.0,4.0,1,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,int
1345,2292,bipbuf_used,1,bipbuf_used,int bipbuf_used (bipbuf_t*),bipbuffer.c,"int bipbuf_used(const bipbuf_t* me)
{
    return (me->a_end - me->a_start) + me->b_end;
}",37.0,40.0,1.0,1.0,4.0,5,3,3,1,1,3,1,1,0,0,,0,3,2,1,1,int
1346,2309,bipbuf_init,1,bipbuf_init,"void bipbuf_init (bipbuf_t*,unsigned int)",bipbuffer.c,"void bipbuf_init(bipbuf_t* me, const unsigned int size)
{
    me->a_start = me->a_end = me->b_end = 0;
    me->size = size;
    me->b_inuse = 0;
}",42.0,47.0,1.0,1.0,6.0,10,2,6,2,1,5,1,1,0,0,,0,5,4,2,2,void
1347,2338,bipbuf_new,1,bipbuf_new,bipbuf_t bipbuf_new (unsigned int),bipbuffer.c,"bipbuf_t *bipbuf_new(const unsigned int size)
{
    bipbuf_t *me = malloc(bipbuf_sizeof(size));
    if (!me)
        return NULL;
    bipbuf_init(me, size);
    return me;
}",49.0,56.0,1.0,1.0,8.0,2,2,7,3,4,2,2,2,0,2,,0,1,2,1,1,bipbuf_t
1348,2360,bipbuf_free,1,bipbuf_free,void bipbuf_free (bipbuf_t*),bipbuffer.c,"void bipbuf_free(bipbuf_t* me)
{
    free(me);
}",58.0,61.0,1.0,1.0,4.0,0,0,1,1,3,0,1,1,0,0,,0,0,2,1,1,void
1349,2367,bipbuf_is_empty,1,bipbuf_is_empty,int bipbuf_is_empty (bipbuf_t*),bipbuffer.c,"int bipbuf_is_empty(const bipbuf_t* me)
{
    return me->a_start == me->a_end;
}",63.0,66.0,1.0,1.0,4.0,3,2,2,1,3,2,1,1,0,0,,0,2,2,1,1,int
1350,2380,__check_for_switch_to_b,1,__check_for_switch_to_b,void __check_for_switch_to_b (bipbuf_t*),bipbuffer.c,"static void __check_for_switch_to_b(bipbuf_t* me)
{
    if (me->size - me->a_end < me->a_start - me->b_end)
        me->b_inuse = 1;
}",70.0,74.0,1.0,1.0,5.0,9,4,5,1,3,5,2,2,4,0,,0,5,2,1,1,void
1351,2407,bipbuf_request,1,bipbuf_request,"unsigned char* bipbuf_request (bipbuf_t*,int)",bipbuffer.c,"unsigned char *bipbuf_request(bipbuf_t* me, const int size)
{
    if (bipbuf_unused(me) < size)
        return 0;
    if (1 == me->b_inuse)
    {
        return (unsigned char *)me->data + me->b_end;
    }
    else
    {
        return (unsigned char *)me->data + me->a_end;
    }
}",77.0,89.0,1.0,1.0,13.0,7,5,5,2,2,4,3,3,2,1,,0,4,4,2,2,unsigned char*
1352,2450,bipbuf_push,1,bipbuf_push,"int bipbuf_push (bipbuf_t*,int)",bipbuffer.c,"int bipbuf_push(bipbuf_t* me, const int size)
{
    if (bipbuf_unused(me) < size)
        return 0;

    if (1 == me->b_inuse)
    {
        me->b_end += size;
    }
    else
    {
        me->a_end += size;
    }

    __check_for_switch_to_b(me);
    return size;
}",91.0,107.0,1.0,1.0,17.0,5,4,7,2,2,4,3,3,2,2,,0,3,4,2,2,int
1353,2487,bipbuf_offer,1,bipbuf_offer,"int bipbuf_offer (bipbuf_t*,unsigned char*,int)",bipbuffer.c,"int bipbuf_offer(bipbuf_t* me, const unsigned char *data, const int size)
{
    /* not enough space */
    if (bipbuf_unused(me) < size)
        return 0;

    if (1 == me->b_inuse)
    {
        memcpy(me->data + me->b_end, data, size);
        me->b_end += size;
    }
    else
    {
        memcpy(me->data + me->a_end, data, size);
        me->a_end += size;
    }

    __check_for_switch_to_b(me);
    return size;
}",109.0,128.0,1.0,1.0,20.0,8,5,11,3,2,6,3,3,2,2,,0,5,6,3,3,int
1354,2545,bipbuf_peek,1,bipbuf_peek,"unsigned char* bipbuf_peek (bipbuf_t*,unsigned int)",bipbuffer.c,"unsigned char *bipbuf_peek(const bipbuf_t* me, const unsigned int size)
{
    /* make sure we can actually peek at this data */
    if (me->size < me->a_start + size)
        return NULL;

    if (bipbuf_is_empty(me))
        return NULL;

    return (unsigned char *)me->data + me->a_start;
}",130.0,140.0,1.0,1.0,11.0,8,4,8,3,0,5,3,3,3,1,,0,5,4,2,2,unsigned char*
1355,2580,bipbuf_peek_all,1,bipbuf_peek_all,"unsigned char* bipbuf_peek_all (bipbuf_t*,unsigned int*)",bipbuffer.c,"unsigned char *bipbuf_peek_all(const bipbuf_t* me, unsigned int *size)
{
    if (bipbuf_is_empty(me))
        return NULL;

    *size = me->a_end - me->a_start;
    return (unsigned char*)me->data + me->a_start;
}",142.0,149.0,1.0,1.0,8.0,9,6,7,3,3,5,2,2,1,1,,0,5,4,2,2,unsigned char*
1356,2612,bipbuf_poll,1,bipbuf_poll,"unsigned char* bipbuf_poll (bipbuf_t*,unsigned int)",bipbuffer.c,"unsigned char *bipbuf_poll(bipbuf_t* me, const unsigned int size)
{
    if (bipbuf_is_empty(me))
        return NULL;

    /* make sure we can actually poll this data */
    if (me->size < me->a_start + size)
        return NULL;

    void *end = me->data + me->a_start;
    me->a_start += size;

    /* we seem to be empty.. */
    if (me->a_start == me->a_end)
    {
        /* replace a with region b */
        if (1 == me->b_inuse)
        {
            me->a_start = 0;
            me->a_end = me->b_end;
            me->b_end = me->b_inuse = 0;
        }
        else
            /* safely move cursor back to the start because we are empty */
            me->a_start = me->a_end = 0;
    }

    __check_for_switch_to_b(me);
    return end;
}",151.0,180.0,1.0,1.0,30.0,24,6,21,4,2,15,5,6,6,2,,0,14,4,2,2,unsigned char*
1357,2820,cache_create,1,cache_create,"cache_t cache_create (char*,size_t,size_t)",cache.c,"cache_t* cache_create(const char *name, size_t bufsize, size_t align) {
    cache_t* ret = calloc(1, sizeof(cache_t));
    char* nm = strdup(name);
    if (ret == NULL || nm == NULL ||
        pthread_mutex_init(&ret->mutex, NULL) == -1) {
        free(ret);
        free(nm);
        return NULL;
    }

    ret->name = nm;
    STAILQ_INIT(&ret->head);

#ifndef NDEBUG
    ret->bufsize = bufsize + 2 * sizeof(redzone_pattern);
#else
    ret->bufsize = bufsize;
#endif
    assert(ret->bufsize >= sizeof(struct cache_free_s));

    return ret;
}",18.0,39.0,1.0,4.0,22.0,35,10,26,8,8,9,2,2,1,0,,0,9,6,3,3,cache_t
1358,2919,cache_set_limit,1,cache_set_limit,"void cache_set_limit (cache_t*,int)",cache.c,"void cache_set_limit(cache_t *cache, int limit) {
    pthread_mutex_lock(&cache->mutex);
    cache->limit = limit;
    pthread_mutex_unlock(&cache->mutex);
}",41.0,45.0,1.0,1.0,5.0,6,3,4,2,2,3,1,1,0,0,,0,3,4,2,2,void
1359,2940,get_object,1,get_object,void* get_object (void*),cache.c,"static inline void* get_object(void *ptr) {
#ifndef NDEBUG
    uint64_t *pre = ptr;
    return pre + 1;
#else
    return ptr;
#endif
}",47.0,54.0,1.0,1.0,8.0,2,2,3,2,1,0,1,1,0,0,,0,0,2,1,1,void*
1360,2953,cache_destroy,1,cache_destroy,void cache_destroy (cache_t*),cache.c,"void cache_destroy(cache_t *cache) {
    while (!STAILQ_EMPTY(&cache->head)) {
        struct cache_free_s *o = STAILQ_FIRST(&cache->head);
        STAILQ_REMOVE_HEAD(&cache->head, c_next);
        free(o);
    }
    free(cache->name);
    pthread_mutex_destroy(&cache->mutex);
    free(cache);
}",56.0,65.0,1.0,12.0,10.0,36,6,16,3,5,11,2,2,2,0,,0,11,2,1,1,void
1361,3047,cache_alloc,1,cache_alloc,void* cache_alloc (cache_t*),cache.c,"void* cache_alloc(cache_t *cache) {
    void *ret;
    pthread_mutex_lock(&cache->mutex);
    ret = do_cache_alloc(cache);
    pthread_mutex_unlock(&cache->mutex);
    return ret;
}",67.0,73.0,1.0,1.0,7.0,5,3,5,2,5,3,1,1,0,1,,0,3,2,1,1,void*
1362,3069,do_cache_alloc,1,do_cache_alloc,void* do_cache_alloc (cache_t*),cache.c,"void* do_cache_alloc(cache_t *cache) {
    void *ret;
    void *object;
    if (cache->freecurr > 0) {
        ret = STAILQ_FIRST(&cache->head);
        STAILQ_REMOVE_HEAD(&cache->head, c_next);
        object = get_object(ret);
        cache->freecurr--;
    } else if (cache->limit == 0 || cache->total < cache->limit) {
        object = ret = malloc(cache->bufsize);
        if (ret != NULL) {
            object = get_object(ret);

            cache->total++;
        }
    } else {
        object = NULL;
    }

#ifndef NDEBUG
    if (object != NULL) {
        /* add a simple form of buffer-check */
        uint64_t *pre = ret;
        *pre = redzone_pattern;
        ret = pre+1;
        memcpy(((char*)ret) + cache->bufsize - (2 * sizeof(redzone_pattern)),
               &redzone_pattern, sizeof(redzone_pattern));
    }
#endif

    return object;
}",75.0,106.0,1.0,14.0,32.0,45,14,27,6,4,15,3,3,1,1,,0,15,2,1,1,void*
1363,3229,cache_free,1,cache_free,"void cache_free (cache_t*,void*)",cache.c,"void cache_free(cache_t *cache, void *ptr) {
    pthread_mutex_lock(&cache->mutex);
    do_cache_free(cache, ptr);
    pthread_mutex_unlock(&cache->mutex);
}",108.0,112.0,1.0,1.0,5.0,4,2,4,2,7,3,1,1,0,1,,0,2,4,2,2,void
1364,3248,do_cache_free,1,do_cache_free,"void do_cache_free (cache_t*,void*)",cache.c,"void do_cache_free(cache_t *cache, void *ptr) {
#ifndef NDEBUG
    /* validate redzone... */
    if (memcmp(((char*)ptr) + cache->bufsize - (2 * sizeof(redzone_pattern)),
               &redzone_pattern, sizeof(redzone_pattern)) != 0) {
        raise(SIGABRT);
        cache_error = 1;
        return;
    }
    uint64_t *pre = ptr;
    --pre;
    if (*pre != redzone_pattern) {
        raise(SIGABRT);
        cache_error = -1;
        return;
    }
    ptr = pre;
#endif
    if (cache->limit != 0 && cache->limit < cache->total) {
        free(ptr);
        cache->total--;
    } else {
        STAILQ_INSERT_HEAD(&cache->head, (struct cache_free_s *)ptr, c_next);
        cache->freecurr++;
    }
}",114.0,139.0,1.0,8.0,26.0,25,15,21,6,3,11,4,4,8,0,,0,11,4,2,2,void
1365,3497,crawler_eval_func,1,crawler_eval_func,"void crawler_eval_func (crawler_module_t*,item*,uint32_t,int)",crawler.c,"typedef void (*crawler_eval_func)(crawler_module_t *cm, item *it, uint32_t hv, int slab_cls);",36.0,36.0,14.0,92.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,void
1366,3505,crawler_init_func,1,crawler_init_func,"int crawler_init_func (crawler_module_t*,void*)",crawler.c,"typedef int (*crawler_init_func)(crawler_module_t *cm, void *data);",37.0,37.0,13.0,66.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
1367,3511,crawler_deinit_func,1,crawler_deinit_func,void crawler_deinit_func (crawler_module_t*),crawler.c,typedef void (*crawler_deinit_func)(crawler_module_t *cm);,38.0,38.0,14.0,57.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
1368,3516,crawler_doneclass_func,1,crawler_doneclass_func,"void crawler_doneclass_func (crawler_module_t*,int)",crawler.c,"typedef void (*crawler_doneclass_func)(crawler_module_t *cm, int slab_cls);",39.0,39.0,14.0,74.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
1369,3522,crawler_finalize_func,1,crawler_finalize_func,void crawler_finalize_func (crawler_module_t*),crawler.c,typedef void (*crawler_finalize_func)(crawler_module_t *cm);,40.0,40.0,14.0,59.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
1370,3539,crawler_expired_init,1,crawler_expired_init,"int crawler_expired_init (crawler_module_t*,void*)",crawler.c,"static int crawler_expired_init(crawler_module_t *cm, void *data) {
    struct crawler_expired_data *d;
    if (data != NULL) {
        d = data;
        d->is_external = true;
        cm->data = data;
    } else {
        // allocate data.
        d = calloc(1, sizeof(struct crawler_expired_data));
        if (d == NULL) {
            return -1;
        }
        // init lock.
        pthread_mutex_init(&d->lock, NULL);
        d->is_external = false;
        d->start_time = current_time;

        cm->data = d;
    }
    pthread_mutex_lock(&d->lock);
    memset(&d->crawlerstats, 0, sizeof(crawlerstats_t) * POWER_LARGEST);
    for (int x = 0; x < POWER_LARGEST; x++) {
        d->crawlerstats[x].start_time = current_time;
        d->crawlerstats[x].run_complete = false;
    }
    pthread_mutex_unlock(&d->lock);
    return 0;
}",130.0,157.0,1.0,57.0,28.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
1371,3545,crawler_expired_doneclass,1,crawler_expired_doneclass,"void crawler_expired_doneclass (crawler_module_t*,int)",crawler.c,"static void crawler_expired_doneclass(crawler_module_t *cm, int slab_cls) {
    struct crawler_expired_data *d = (struct crawler_expired_data *) cm->data;
    pthread_mutex_lock(&d->lock);
    d->crawlerstats[slab_cls].end_time = current_time;
    d->crawlerstats[slab_cls].run_complete = true;
    pthread_mutex_unlock(&d->lock);
}",159.0,165.0,1.0,1.0,7.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
1372,3551,crawler_expired_finalize,1,crawler_expired_finalize,void crawler_expired_finalize (crawler_module_t*),crawler.c,"static void crawler_expired_finalize(crawler_module_t *cm) {
    struct crawler_expired_data *d = (struct crawler_expired_data *) cm->data;
    pthread_mutex_lock(&d->lock);
    d->end_time = current_time;
    d->crawl_complete = true;
    pthread_mutex_unlock(&d->lock);

    if (!d->is_external) {
        free(d);
    }
}",167.0,177.0,1.0,1.0,11.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
1373,3556,crawler_expired_eval,1,crawler_expired_eval,"void crawler_expired_eval (crawler_module_t*,item*,uint32_t,int)",crawler.c,"static void crawler_expired_eval(crawler_module_t *cm, item *search, uint32_t hv, int i) {
    struct crawler_expired_data *d = (struct crawler_expired_data *) cm->data;
    pthread_mutex_lock(&d->lock);
    crawlerstats_t *s = &d->crawlerstats[i];
    int is_flushed = item_is_flushed(search);
#ifdef EXTSTORE
    bool is_valid = true;
    if (search->it_flags & ITEM_HDR) {
        is_valid = storage_validate_item(storage, search);
    }
#endif
    if ((search->exptime != 0 && search->exptime < current_time)
        || is_flushed
#ifdef EXTSTORE
        || !is_valid
#endif
        ) {
        crawlers[i].reclaimed++;
        s->reclaimed++;

        if (settings.verbose > 1) {
            int ii;
            char *key = ITEM_key(search);
            fprintf(stderr, ""LRU crawler found an expired item (flags: %d, slab: %d): "",
                search->it_flags, search->slabs_clsid);
            for (ii = 0; ii < search->nkey; ++ii) {
                fprintf(stderr, ""%c"", key[ii]);
     ...",182.0,236.0,1.0,24.0,55.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,void
1374,3592,crawler_metadump_eval,1,crawler_metadump_eval,"void crawler_metadump_eval (crawler_module_t*,item*,uint32_t,int)",crawler.c,"static void crawler_metadump_eval(crawler_module_t *cm, item *it, uint32_t hv, int i) {
    //int slab_id = CLEAR_LRU(i);
    char keybuf[KEY_MAX_URI_ENCODED_LENGTH];
    int is_flushed = item_is_flushed(it);
    /* Ignore expired content. */
    if ((it->exptime != 0 && it->exptime < current_time)
        || is_flushed) {
        refcount_decr(it);
        return;
    }
    // TODO: uriencode directly into the buffer.
    uriencode(ITEM_key(it), keybuf, it->nkey, KEY_MAX_URI_ENCODED_LENGTH);
    int total = snprintf(cm->c.cbuf, 4096,
            ""key=%s exp=%ld la=%llu cas=%llu fetch=%s cls=%u size=%lu\n"",
            keybuf,
            (it->exptime == 0) ? -1 : (long)(it->exptime + process_started),
            (unsigned long long)(it->time + process_started),
            (unsigned long long)ITEM_get_cas(it),
            (it->it_flags & ITEM_FETCHED) ? ""yes"" : ""no"",
            ITEM_clsid(it),
            (unsigned long) ITEM_ntotal(it));
    refcount_decr(it);
    // TODO: some ...",238.0,266.0,1.0,16.0,29.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,void
1375,3600,crawler_metadump_finalize,1,crawler_metadump_finalize,void crawler_metadump_finalize (crawler_module_t*),crawler.c,"static void crawler_metadump_finalize(crawler_module_t *cm) {
    if (cm->c.c != NULL) {
        // Ensure space for final message.
        lru_crawler_client_getbuf(&cm->c);
        memcpy(cm->c.cbuf, ""END\r\n"", 5);
        bipbuf_push(cm->c.buf, 5);
    }
}",268.0,275.0,1.0,1.0,8.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
1376,3643,lru_crawler_client_getbuf,1,lru_crawler_client_getbuf,int lru_crawler_client_getbuf (crawler_client_t*),crawler.c,"static int lru_crawler_client_getbuf(crawler_client_t *c) {
    void *buf = NULL;
    if (c->c == NULL) return -1;
    /* not enough space. */
    while ((buf = bipbuf_request(c->buf, LRU_CRAWLER_WRITEBUF)) == NULL) {
        // TODO: max loops before closing.
        int ret = lru_crawler_poll(c);
        if (ret < 0) return ret;
    }

    c->cbuf = buf;
    return 0;
}",327.0,339.0,1.0,41.0,13.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,int
1377,3676,lru_crawler_close_client,1,lru_crawler_close_client,void lru_crawler_close_client (crawler_client_t*),crawler.c,"static void lru_crawler_close_client(crawler_client_t *c) {
    //fprintf(stderr, ""CRAWLER: Closing client\n"");
    sidethread_conn_close(c->c);
    c->c = NULL;
    c->cbuf = NULL;
    bipbuf_free(c->buf);
    c->buf = NULL;
}",112.0,119.0,1.0,1.0,8.0,8,2,8,2,2,7,1,1,0,2,,0,5,2,1,1,void
1378,3704,lru_crawler_release_client,1,lru_crawler_release_client,void lru_crawler_release_client (crawler_client_t*),crawler.c,"static void lru_crawler_release_client(crawler_client_t *c) {
    //fprintf(stderr, ""CRAWLER: Closing client\n"");
    redispatch_conn(c->c);
    c->c = NULL;
    c->cbuf = NULL;
    bipbuf_free(c->buf);
    c->buf = NULL;
}",121.0,128.0,1.0,1.0,8.0,8,2,8,2,1,7,1,1,0,2,,0,5,2,1,1,void
1379,4391,lru_crawler_poll,1,lru_crawler_poll,int lru_crawler_poll (crawler_client_t*),crawler.c,"static int lru_crawler_poll(crawler_client_t *c) {
    unsigned char *data;
    unsigned int data_size = 0;
    struct pollfd to_poll[1];
    to_poll[0].fd = c->sfd;
    to_poll[0].events = POLLOUT;

    int ret = poll(to_poll, 1, 1000);

    if (ret < 0) {
        // fatal.
        return -1;
    }

    if (ret == 0) return 0;

    if (to_poll[0].revents & POLLIN) {
        char buf[1];
        int res = ((conn*)c->c)->read(c->c, buf, 1);
        if (res == 0 || (res == -1 && (errno != EAGAIN && errno != EWOULDBLOCK))) {
            lru_crawler_close_client(c);
            return -1;
        }
    }
    if ((data = bipbuf_peek_all(c->buf, &data_size)) != NULL) {
        if (to_poll[0].revents & (POLLHUP|POLLERR)) {
            lru_crawler_close_client(c);
            return -1;
        } else if (to_poll[0].revents & POLLOUT) {
            int total = ((conn*)c->c)->write(c->c, data, data_size);
            if (total == -1) {
                if (errno != EAGAIN && errno != EWOULDBL...",277.0,321.0,1.0,1.0,45.0,38,14,30,15,1,8,7,9,2,4,,0,6,2,1,1,int
1380,4636,lru_crawler_class_done,1,lru_crawler_class_done,void lru_crawler_class_done (int),crawler.c,"static void lru_crawler_class_done(int i) {
    crawlers[i].it_flags = 0;
    crawler_count--;
    do_item_unlinktail_q((item *)&crawlers[i]);
    do_item_stats_add_crawl(i, crawlers[i].reclaimed,
            crawlers[i].unfetched, crawlers[i].checked);
    pthread_mutex_unlock(&lru_locks[i]);
    if (active_crawler_mod.mod->doneclass != NULL)
        active_crawler_mod.mod->doneclass(&active_crawler_mod, i);
}",341.0,350.0,1.0,1.0,10.0,21,8,19,6,0,11,2,2,1,2,,0,9,2,1,1,void
1381,4697,item_crawl_hash,1,item_crawl_hash,void item_crawl_hash (void),crawler.c,"static void item_crawl_hash(void) {
    // get iterator from assoc. can hang for a long time.
    // - blocks hash expansion
    void *iter = assoc_get_iterator();
    int crawls_persleep = settings.crawls_persleep;
    item *it = NULL;

    // loop while iterator returns something
    // - iterator func handles bucket-walking
    // - iterator returns with bucket locked.
    while (assoc_iterate(iter, &it)) {
        // if iterator returns true but no item, we're inbetween buckets and
        // can do sleep or cleanup work without holding a lock.
        if (it == NULL) {
            // - sleep bits from orig loop
            if (crawls_persleep-- <= 0 && settings.lru_crawler_sleep) {
                pthread_mutex_unlock(&lru_crawler_lock);
                usleep(settings.lru_crawler_sleep);
                pthread_mutex_lock(&lru_crawler_lock);
                crawls_persleep = settings.crawls_persleep;
            } else if (!settings.lru_crawler_sleep) {
                // TODO...",352.0,406.0,1.0,12.0,55.0,30,12,29,8,1,14,10,14,3,4,,0,13,2,1,1,void
1382,4833,item_crawler_thread,1,item_crawler_thread,void* item_crawler_thread (void*),crawler.c,"static void *item_crawler_thread(void *arg) {
    int i;
    int crawls_persleep = settings.crawls_persleep;

    pthread_mutex_lock(&lru_crawler_lock);
    pthread_cond_signal(&lru_crawler_cond);
    settings.lru_crawler = true;
    if (settings.verbose > 2)
        fprintf(stderr, ""Starting LRU crawler background thread\n"");
    while (do_run_lru_crawler_thread) {
    pthread_cond_wait(&lru_crawler_cond, &lru_crawler_lock);

    if (crawler_count == -1) {
        item_crawl_hash();
        crawler_count = 0;
    } else {
    while (crawler_count) {
        item *search = NULL;
        void *hold_lock = NULL;

        for (i = POWER_SMALLEST; i < LARGEST_ID; i++) {
            if (crawlers[i].it_flags != 1) {
                continue;
            }

            /* Get memory from bipbuf, if client has no space, flush. */
            if (active_crawler_mod.c.c != NULL) {
                int ret = lru_crawler_client_getbuf(&active_crawler_mod.c);
                if (ret != 0) {
     ...",408.0,526.0,1.0,17.0,119.0,45,9,38,12,0,31,10,19,11,4,,0,26,2,1,1,void*
1383,5264,stop_item_crawler_thread,1,stop_item_crawler_thread,int stop_item_crawler_thread (bool),crawler.c,"int stop_item_crawler_thread(bool wait) {
    int ret;
    pthread_mutex_lock(&lru_crawler_lock);
    if (do_run_lru_crawler_thread == 0) {
        pthread_mutex_unlock(&lru_crawler_lock);
        return 0;
    }
    do_run_lru_crawler_thread = 0;
    pthread_cond_signal(&lru_crawler_cond);
    pthread_mutex_unlock(&lru_crawler_lock);
    if (wait && (ret = pthread_join(item_crawler_tid, NULL)) != 0) {
        fprintf(stderr, ""Failed to stop LRU crawler thread: %s\n"", strerror(ret));
        return -1;
    }
    return 0;
}",530.0,545.0,1.0,1.0,16.0,10,6,12,8,0,7,3,3,2,0,,0,7,2,1,1,int
1384,5313,start_item_crawler_thread,1,start_item_crawler_thread,int start_item_crawler_thread (void),crawler.c,"int start_item_crawler_thread(void) {
    int ret;

    if (settings.lru_crawler)
        return -1;
    pthread_mutex_lock(&lru_crawler_lock);
    do_run_lru_crawler_thread = 1;
    if ((ret = pthread_create(&item_crawler_tid, NULL,
        item_crawler_thread, NULL)) != 0) {
        fprintf(stderr, ""Can't create LRU crawler thread: %s\n"",
            strerror(ret));
        pthread_mutex_unlock(&lru_crawler_lock);
        return -1;
    }
    /* Avoid returning until the crawler has actually started */
    pthread_cond_wait(&lru_crawler_cond, &lru_crawler_lock);
    pthread_mutex_unlock(&lru_crawler_lock);

    return 0;
}",558.0,577.0,1.0,1.0,20.0,12,5,13,8,1,8,3,3,2,0,,0,8,2,1,1,int
1385,5366,do_lru_crawler_start,1,do_lru_crawler_start,"int do_lru_crawler_start (uint32_t,uint32_t)",crawler.c,"static int do_lru_crawler_start(uint32_t id, uint32_t remaining) {
    uint32_t sid = id;
    int starts = 0;

    pthread_mutex_lock(&lru_locks[sid]);
    if (crawlers[sid].it_flags == 0) {
        if (settings.verbose > 2)
            fprintf(stderr, ""Kicking LRU crawler off for LRU %u\n"", sid);
        crawlers[sid].nbytes = 0;
        crawlers[sid].nkey = 0;
        crawlers[sid].it_flags = 1; /* For a crawler, this means enabled. */
        crawlers[sid].next = 0;
        crawlers[sid].prev = 0;
        crawlers[sid].time = 0;
        if (remaining == LRU_CRAWLER_CAP_REMAINING) {
            remaining = do_get_lru_size(sid);
        }
        /* Values for remaining:
         * remaining = 0
         * - scan all elements, until a NULL is reached
         * - if empty, NULL is reached right away
         * remaining = n + 1
         * - first n elements are parsed (or until a NULL is reached)
         */
        if (remaining) remaining++;
        crawlers[sid].remaining = rema...",582.0,618.0,1.0,25.0,37.0,53,9,46,9,0,17,5,8,2,2,,0,16,4,2,2,int
1386,5517,lru_crawler_set_client,1,lru_crawler_set_client,"int lru_crawler_set_client (crawler_module_t*,void*,int)",crawler.c,"static int lru_crawler_set_client(crawler_module_t *cm, void *c, const int sfd) {
    crawler_client_t *crawlc = &cm->c;
    if (crawlc->c != NULL) {
        return -1;
    }
    crawlc->c = c;
    crawlc->sfd = sfd;

    crawlc->buf = bipbuf_new(1024 * 128);
    if (crawlc->buf == NULL) {
        return -2;
    }
    return 0;
}",620.0,633.0,1.0,1.0,14.0,16,7,11,5,1,6,3,3,2,1,,0,6,6,3,3,int
1387,5571,lru_crawler_start,1,lru_crawler_start,"int lru_crawler_start (uint8_t*,uint32_t,crawler_run_type,void*,void*,int)",crawler.c,"int lru_crawler_start(uint8_t *ids, uint32_t remaining,
                             const enum crawler_run_type type, void *data,
                             void *c, const int sfd) {
    int starts = 0;
    bool is_running;
    static rel_time_t block_ae_until = 0;
    pthread_mutex_lock(&lru_crawler_lock);
    STATS_LOCK();
    is_running = stats_state.lru_crawler_running;
    STATS_UNLOCK();
    if (do_run_lru_crawler_thread == 0) {
        pthread_mutex_unlock(&lru_crawler_lock);
        return -2;
    }

    if (is_running &&
            !(type == CRAWLER_AUTOEXPIRE && active_crawler_type == CRAWLER_AUTOEXPIRE)) {
        pthread_mutex_unlock(&lru_crawler_lock);
        block_ae_until = current_time + 60;
        return -1;
    }

    if (type == CRAWLER_AUTOEXPIRE && block_ae_until > current_time) {
        pthread_mutex_unlock(&lru_crawler_lock);
        return -1;
    }

    /* hash table walk only supported with metadump for now. */
    if (type != CRAWLER_METADUMP && ids...",635.0,711.0,1.0,23.0,77.0,61,14,59,22,2,29,12,18,6,1,,0,25,12,6,6,int
1388,5801,lru_crawler_crawl,1,lru_crawler_crawl,"enum crawler_result_type lru_crawler_crawl (char*,crawler_run_type,void*,int,unsigned int)",crawler.c,"enum crawler_result_type lru_crawler_crawl(char *slabs, const enum crawler_run_type type,
        void *c, const int sfd, unsigned int remaining) {
    char *b = NULL;
    uint32_t sid = 0;
    int starts = 0;
    uint8_t tocrawl[POWER_LARGEST];
    bool hash_crawl = false;

    /* FIXME: I added this while debugging. Don't think it's needed? */
    memset(tocrawl, 0, sizeof(uint8_t) * POWER_LARGEST);
    if (strcmp(slabs, ""all"") == 0) {
        for (sid = 0; sid < POWER_LARGEST; sid++) {
            tocrawl[sid] = 1;
        }
    } else if (strcmp(slabs, ""hash"") == 0) {
        hash_crawl = true;
    } else {
        for (char *p = strtok_r(slabs, "","", &b);
             p != NULL;
             p = strtok_r(NULL, "","", &b)) {

            if (!safe_strtoul(p, &sid) || sid < POWER_SMALLEST
                    || sid >= MAX_NUMBER_OF_SLAB_CLASSES) {
                return CRAWLER_BADCLASS;
            }
            tocrawl[sid | TEMP_LRU] = 1;
            tocrawl[sid | HOT_LRU] = 1;
 ...",716.0,758.0,1.0,20.0,43.0,15,8,24,14,1,1,4,5,0,1,,0,1,10,5,5,enum crawler_result_type
1389,5996,lru_crawler_pause,1,lru_crawler_pause,void lru_crawler_pause (void),crawler.c,"void lru_crawler_pause(void) {
    pthread_mutex_lock(&lru_crawler_lock);
}",761.0,763.0,1.0,1.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,void
1390,6004,lru_crawler_resume,1,lru_crawler_resume,void lru_crawler_resume (void),crawler.c,"void lru_crawler_resume(void) {
    pthread_mutex_unlock(&lru_crawler_lock);
}",765.0,767.0,1.0,1.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,void
1391,6012,init_lru_crawler,1,init_lru_crawler,int init_lru_crawler (void*),crawler.c,"int init_lru_crawler(void *arg) {
    if (lru_crawler_initialized == 0) {
#ifdef EXTSTORE
        storage = arg;
#endif
        active_crawler_mod.c.c = NULL;
        active_crawler_mod.mod = NULL;
        active_crawler_mod.data = NULL;
        lru_crawler_initialized = 1;
    }
    return 0;
}",769.0,780.0,1.0,1.0,12.0,9,3,8,3,1,5,2,2,1,0,,0,5,2,1,1,int
1392,6142,crc32c_sw_little,1,crc32c_sw_little,"uint32_t crc32c_sw_little (uint32_t,void*,size_t)",crc32c.c,"uint32_t crc32c_sw_little(uint32_t crc, void const *buf, size_t len) {
    unsigned char const *next = buf;

    pthread_once(&crc32c_once_little, crc32c_init_sw_little);
    crc = ~crc;
    while (len && ((uintptr_t)next & 7) != 0) {
        crc = crc32c_table_little[0][(crc ^ *next++) & 0xff] ^ (crc >> 8);
        len--;
    }
    if (len >= 8) {
        uint64_t crcw = crc;
        do {
            crcw ^= *(uint64_t const *)next;
            crcw = crc32c_table_little[7][crcw & 0xff] ^
                   crc32c_table_little[6][(crcw >> 8) & 0xff] ^
                   crc32c_table_little[5][(crcw >> 16) & 0xff] ^
                   crc32c_table_little[4][(crcw >> 24) & 0xff] ^
                   crc32c_table_little[3][(crcw >> 32) & 0xff] ^
                   crc32c_table_little[2][(crcw >> 40) & 0xff] ^
                   crc32c_table_little[1][(crcw >> 48) & 0xff] ^
                   crc32c_table_little[0][crcw >> 56];
            next += 8;
            len -= 8;
        } whi...",392.0,423.0,1.0,1.0,32.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,uint32_t
1393,6149,crc32c_sw_big,1,crc32c_sw_big,"uint32_t crc32c_sw_big (uint32_t,void*,size_t)",crc32c.c,"uint32_t crc32c_sw_big(uint32_t crc, void const *buf, size_t len) {
    unsigned char const *next = buf;

    pthread_once(&crc32c_once_big, crc32c_init_sw_big);
    crc = ~crc;
    while (len && ((uintptr_t)next & 7) != 0) {
        crc = crc32c_table_big_byte[(crc ^ *next++) & 0xff] ^ (crc >> 8);
        len--;
    }
    if (len >= 8) {
        uint64_t crcw = swap(crc);
        do {
            crcw ^= *(uint64_t const *)next;
            crcw = crc32c_table_big[0][crcw & 0xff] ^
                   crc32c_table_big[1][(crcw >> 8) & 0xff] ^
                   crc32c_table_big[2][(crcw >> 16) & 0xff] ^
                   crc32c_table_big[3][(crcw >> 24) & 0xff] ^
                   crc32c_table_big[4][(crcw >> 32) & 0xff] ^
                   crc32c_table_big[5][(crcw >> 40) & 0xff] ^
                   crc32c_table_big[6][(crcw >> 48) & 0xff] ^
                   crc32c_table_big[7][(crcw >> 56)];
            next += 8;
            len -= 8;
        } while (len >= 8);
        crc...",466.0,497.0,1.0,1.0,32.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,uint32_t
1394,6156,crc32c_init,1,crc32c_init,void crc32c_init (void),crc32c.c,"void crc32c_init(void) {
    crc32c = crc32c_sw;
}",359.0,361.0,1.0,1.0,3.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
1395,6172,crc32c_init_sw_little,1,crc32c_init_sw_little,void crc32c_init_sw_little (void),crc32c.c,"static void crc32c_init_sw_little(void) {
    for (unsigned n = 0; n < 256; n++) {
        uint32_t crc = n;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc32c_table_little[0][n] = crc;
    }
    for (unsigned n = 0; n < 256; n++) {
        uint32_t crc = crc32c_table_little[0][n];
        for (unsigned k = 1; k < 8; k++) {
            crc = crc32c_table_little[0][crc & 0xff] ^ (crc >> 8);
            crc32c_table_little[k][n] = crc;
        }
    }
}",368.0,388.0,1.0,37.0,21.0,70,7,54,4,0,4,4,5,0,0,,0,4,2,1,1,void
1396,6560,swap,1,swap,uint64_t swap (uint64_t),crc32c.c,"static inline uint64_t swap(uint64_t x) {
    x = ((x << 8) & 0xff00ff00ff00ff00) | ((x >> 8) & 0xff00ff00ff00ff);
    x = ((x << 16) & 0xffff0000ffff0000) | ((x >> 16) & 0xffff0000ffff);
    return (x << 32) | (x >> 32);
}",430.0,434.0,1.0,1.0,5.0,15,5,8,1,2,0,1,1,0,0,,0,0,2,1,1,uint64_t
1397,6610,crc32c_init_sw_big,1,crc32c_init_sw_big,void crc32c_init_sw_big (void),crc32c.c,"static void crc32c_init_sw_big(void) {
    for (unsigned n = 0; n < 256; n++) {
        uint32_t crc = n;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc32c_table_big_byte[n] = crc;
    }
    for (unsigned n = 0; n < 256; n++) {
        uint32_t crc = crc32c_table_big_byte[n];
        crc32c_table_big[0][n] = swap(crc);
        for (unsigned k = 1; k < 8; k++) {
            crc = crc32c_table_big_byte[crc & 0xff] ^ (crc >> 8);
            crc32c_table_big[k][n] = swap(crc);
        }
    }
}",441.0,462.0,1.0,37.0,22.0,70,7,57,5,0,7,4,5,0,2,,0,7,2,1,1,void
1398,6999,crc32c_sw,1,crc32c_sw,"uint32_t crc32c_sw (uint32_t,void*,size_t)",crc32c.c,"uint32_t crc32c_sw(uint32_t crc, void const *buf, size_t len) {
    static int const little = 1;
    if (*(char const *)&little)
        return crc32c_sw_little(crc, buf, len);
    else
        return crc32c_sw_big(crc, buf, len);
}",506.0,512.0,1.0,1.0,7.0,4,4,5,4,3,1,2,2,0,1,,0,0,6,3,3,uint32_t
1399,7036,crc_func,1,crc_func,"uint32_t crc_func (uint32_t,void*,size_t)",crc32c.h,"typedef uint32_t (*crc_func)(uint32_t crc, const void *buf, size_t len);",15.0,15.0,18.0,71.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,uint32_t
1400,7071,daemonize,1,daemonize,"int daemonize (int,int)",daemon.c,"int daemonize(int nochdir, int noclose)
{
    int fd;

    switch (fork()) {
    case -1:
        return (-1);
    case 0:
        break;
    default:
        _exit(EXIT_SUCCESS);
    }

    if (setsid() == -1)
        return (-1);

    if (nochdir == 0) {
        if(chdir(""/"") != 0) {
            perror(""chdir"");
            return (-1);
        }
    }

    if (noclose == 0 && (fd = open(""/dev/null"", O_RDWR, 0)) != -1) {
        if(dup2(fd, STDIN_FILENO) < 0) {
            perror(""dup2 stdin"");
            goto err_cleanup;
        }
        if(dup2(fd, STDOUT_FILENO) < 0) {
            perror(""dup2 stdout"");
            goto err_cleanup;
        }
        if(dup2(fd, STDERR_FILENO) < 0) {
            perror(""dup2 stderr"");
            goto err_cleanup;
        }

        if(close(fd) < 0) {
            perror(""close"");
            return (-1);
        }
    }
    return (0);

    err_cleanup:
        close(fd);
        return (-1);
}",44.0,91.0,1.0,1.0,48.0,19,6,13,8,1,0,14,15,0,0,,0,0,4,2,2,int
1401,7302,wbuf_new,1,wbuf_new,_store_wbuf wbuf_new (size_t),extstore.c,"static _store_wbuf *wbuf_new(size_t size) {
    _store_wbuf *b = calloc(1, sizeof(_store_wbuf));
    if (b == NULL)
        return NULL;
    b->buf = calloc(size, sizeof(char));
    if (b->buf == NULL) {
        free(b);
        return NULL;
    }
    b->buf_pos = b->buf;
    b->free = size;
    b->size = size;
    return b;
}",115.0,128.0,1.0,1.0,14.0,15,4,19,5,1,0,3,3,0,0,,0,0,2,1,1,_store_wbuf
1402,7359,_get_io_thread,1,_get_io_thread,store_io_thread _get_io_thread (store_engine*),extstore.c,"static store_io_thread *_get_io_thread(store_engine *e) {
    int tid = -1;
    long long int low = LLONG_MAX;
    pthread_mutex_lock(&e->mutex);
    // find smallest queue. ignoring lock since being wrong isn't fatal.
    // TODO: if average queue depth can be quickly tracked, can break as soon
    // as we see a thread that's less than average, and start from last_io_thread
    for (int x = 0; x < e->io_threadcount; x++) {
        if (e->io_threads[x].depth == 0) {
            tid = x;
            break;
        } else if (e->io_threads[x].depth < low) {
                tid = x;
            low = e->io_threads[x].depth;
        }
    }
    pthread_mutex_unlock(&e->mutex);

    return &e->io_threads[tid];
}",130.0,149.0,1.0,1.0,20.0,18,8,14,5,1,5,4,4,2,0,,0,5,2,1,1,store_io_thread
1403,7444,_next_version,1,_next_version,uint64_t _next_version (store_engine*),extstore.c,"static uint64_t _next_version(store_engine *e) {
    return e->version++;
}",151.0,153.0,1.0,1.0,3.0,2,2,1,1,1,1,1,1,0,0,,0,1,2,1,1,uint64_t
1404,7454,extstore_io_thread,1,extstore_io_thread,void* extstore_io_thread (void*),extstore.c,"static void *extstore_io_thread(void *arg) {
    store_io_thread *me = (store_io_thread *)arg;
    store_engine *e = me->e;
    while (1) {
        obj_io *io_stack = NULL;
        pthread_mutex_lock(&me->mutex);
        if (me->queue == NULL) {
            pthread_cond_wait(&me->cond, &me->mutex);
        }

        // Pull and disconnect a batch from the queue
        // Chew small batches from the queue so the IO thread picker can keep
        // the IO queue depth even, instead of piling on threads one at a time
        // as they gobble a queue.
        if (me->queue != NULL) {
            int i;
            obj_io *end = NULL;
            io_stack = me->queue;
            end = io_stack;
            for (i = 1; i < e->io_depth; i++) {
                if (end->next) {
                    end = end->next;
                } else {
                    me->queue_tail = end->next;
                    break;
                }
            }
            me->depth -= i;
            me->...",739.0,849.0,1.0,24.0,111.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void*
1405,7459,extstore_maint_thread,1,extstore_maint_thread,void* extstore_maint_thread (void*),extstore.c,"static void *extstore_maint_thread(void *arg) {
    store_maint_thread *me = (store_maint_thread *)arg;
    store_engine *e = me->e;
    struct extstore_page_data *pd =
        calloc(e->page_count, sizeof(struct extstore_page_data));
    pthread_mutex_lock(&me->mutex);
    while (1) {
        int i;
        bool do_evict = false;
        unsigned int low_page = 0;
        uint64_t low_version = ULLONG_MAX;

        pthread_cond_wait(&me->cond, &me->mutex);
        pthread_mutex_lock(&e->mutex);
        // default freelist requires at least one page free.
        // specialized freelists fall back to default once full.
        if (e->page_free == 0 || e->page_freelist == NULL) {
            do_evict = true;
        }
        pthread_mutex_unlock(&e->mutex);
        memset(pd, 0, sizeof(struct extstore_page_data) * e->page_count);

        for (i = 0; i < e->page_count; i++) {
            store_page *p = &e->pages[i];
            pthread_mutex_lock(&p->mutex);
            pd[p->id].f...",913.0,994.0,1.0,12.0,82.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void*
1406,7464,extstore_get_stats,1,extstore_get_stats,"void extstore_get_stats (void*,extstore_stats*)",extstore.c,"void extstore_get_stats(void *ptr, struct extstore_stats *st) {
    store_engine *e = (store_engine *)ptr;
    STAT_L(e);
    memcpy(st, &e->stats, sizeof(struct extstore_stats));
    STAT_UL(e);

    // grab pages_free/pages_used
    pthread_mutex_lock(&e->mutex);
    st->pages_free = e->page_free;
    st->pages_used = e->page_count - e->page_free;
    pthread_mutex_unlock(&e->mutex);
    st->io_queue = 0;
    for (int x = 0; x < e->io_threadcount; x++) {
        pthread_mutex_lock(&e->io_threads[x].mutex);
        st->io_queue += e->io_threads[x].depth;
        pthread_mutex_unlock(&e->io_threads[x].mutex);
    }
    // calculate bytes_fragmented.
    // note that open and yet-filled pages count against fragmentation.
    st->bytes_fragmented = st->pages_used * e->page_size -
        st->bytes_used;
}",159.0,180.0,1.0,4.0,22.0,46,11,31,5,0,20,2,2,1,0,,0,20,4,2,2,void
1407,7591,extstore_get_page_data,1,extstore_get_page_data,"void extstore_get_page_data (void*,extstore_stats*)",extstore.c,"void extstore_get_page_data(void *ptr, struct extstore_stats *st) {
    store_engine *e = (store_engine *)ptr;
    STAT_L(e);
    memcpy(st->page_data, e->stats.page_data,
            sizeof(struct extstore_page_data) * e->page_count);
    STAT_UL(e);
}",182.0,188.0,1.0,4.0,7.0,12,7,10,4,0,5,1,1,0,0,,0,5,4,2,2,void
1408,7634,extstore_err,1,extstore_err,const char* extstore_err (extstore_res),extstore.c,"const char *extstore_err(enum extstore_res res) {
    const char *rv = ""unknown error"";
    switch (res) {
        case EXTSTORE_INIT_BAD_WBUF_SIZE:
            rv = ""page_size must be divisible by wbuf_size"";
            break;
        case EXTSTORE_INIT_NEED_MORE_WBUF:
            rv = ""wbuf_count must be >= page_buckets"";
            break;
        case EXTSTORE_INIT_NEED_MORE_BUCKETS:
            rv = ""page_buckets must be > 0"";
            break;
        case EXTSTORE_INIT_PAGE_WBUF_ALIGNMENT:
            rv = ""page_size and wbuf_size must be divisible by 1024*1024*2"";
            break;
        case EXTSTORE_INIT_TOO_MANY_PAGES:
            rv = ""page_count must total to < 65536. Increase page_size or lower path sizes"";
            break;
        case EXTSTORE_INIT_OOM:
            rv = ""failed calloc for engine"";
            break;
        case EXTSTORE_INIT_OPEN_FAIL:
            rv = ""failed to open file"";
            break;
        case EXTSTORE_INIT_THREAD_FAIL:
         ...",190.0,218.0,1.0,1.0,29.0,8,1,18,10,0,0,10,2,0,0,,0,0,2,1,1,const char*
1409,7693,extstore_init,1,extstore_init,"void* extstore_init (extstore_conf_file*,extstore_conf*,extstore_res*)",extstore.c,"void *extstore_init(struct extstore_conf_file *fh, struct extstore_conf *cf,
        enum extstore_res *res) {
    int i;
    struct extstore_conf_file *f = NULL;
    pthread_t thread;

    if (cf->page_size % cf->wbuf_size != 0) {
        *res = EXTSTORE_INIT_BAD_WBUF_SIZE;
        return NULL;
    }
    // Should ensure at least one write buffer per potential page
    if (cf->page_buckets > cf->wbuf_count) {
        *res = EXTSTORE_INIT_NEED_MORE_WBUF;
        return NULL;
    }
    if (cf->page_buckets < 1) {
        *res = EXTSTORE_INIT_NEED_MORE_BUCKETS;
        return NULL;
    }

    // TODO: More intelligence around alignment of flash erasure block sizes
    if (cf->page_size % (1024 * 1024 * 2) != 0 ||
        cf->wbuf_size % (1024 * 1024 * 2) != 0) {
        *res = EXTSTORE_INIT_PAGE_WBUF_ALIGNMENT;
        return NULL;
    }

    store_engine *e = calloc(1, sizeof(store_engine));
    if (e == NULL) {
        *res = EXTSTORE_INIT_OOM;
        return NULL;
    }

    e->pag...",221.0,394.0,1.0,1.0,174.0,238,21,202,34,0,85,21,29,17,2,,0,84,6,3,3,void*
1410,8422,extstore_run_maint,1,extstore_run_maint,void extstore_run_maint (void*),extstore.c,"void extstore_run_maint(void *ptr) {
    store_engine *e = (store_engine *)ptr;
    pthread_cond_signal(&e->maint_thread->cond);
}",396.0,399.0,1.0,1.0,4.0,5,4,3,2,3,1,1,1,0,0,,0,1,2,1,1,void
1411,8440,_allocate_page,1,_allocate_page,"store_page _allocate_page (store_engine*,unsigned int,unsigned int)",extstore.c,"static store_page *_allocate_page(store_engine *e, unsigned int bucket,
        unsigned int free_bucket) {
    assert(!e->page_buckets[bucket] || e->page_buckets[bucket]->allocated == e->page_size);
    store_page *tmp = NULL;
    // if a specific free bucket was requested, check there first
    if (free_bucket != 0 && e->free_page_buckets[free_bucket] != NULL) {
        assert(e->page_free > 0);
        tmp = e->free_page_buckets[free_bucket];
        e->free_page_buckets[free_bucket] = tmp->next;
    }
    // failing that, try the global list.
    if (tmp == NULL && e->page_freelist != NULL) {
        tmp = e->page_freelist;
        e->page_freelist = tmp->next;
    }
    E_DEBUG(""EXTSTORE: allocating new page\n"");
    // page_freelist can be empty if the only free pages are specialized and
    // we didn't just request one.
    if (e->page_free > 0 && tmp != NULL) {
        tmp->next = e->page_buckets[bucket];
        e->page_buckets[bucket] = tmp;
        tmp->active = true;
  ...",402.0,436.0,1.0,4.0,35.0,63,13,52,7,2,18,5,5,3,1,,0,18,6,3,3,store_page
1412,8615,_allocate_wbuf,1,_allocate_wbuf,"void _allocate_wbuf (store_engine*,store_page*)",extstore.c,"static void _allocate_wbuf(store_engine *e, store_page *p) {
    _store_wbuf *wbuf = NULL;
    assert(!p->wbuf);
    pthread_mutex_lock(&e->mutex);
    if (e->wbuf_stack) {
        wbuf = e->wbuf_stack;
        e->wbuf_stack = wbuf->next;
        wbuf->next = 0;
    }
    pthread_mutex_unlock(&e->mutex);
    if (wbuf) {
        wbuf->offset = p->allocated;
        p->allocated += wbuf->size;
        wbuf->free = wbuf->size;
        wbuf->buf_pos = wbuf->buf;
        wbuf->full = false;
        wbuf->flushed = false;

        p->wbuf = wbuf;
    }
}",439.0,459.0,1.0,1.0,21.0,33,5,26,5,1,5,3,3,1,0,,0,5,4,2,2,void
1413,8708,_wbuf_cb,1,_wbuf_cb,"void _wbuf_cb (void*,obj_io*,int)",extstore.c,"static void _wbuf_cb(void *ep, obj_io *io, int ret) {
    store_engine *e = (store_engine *)ep;
    store_page *p = &e->pages[io->page_id];
    _store_wbuf *w = (_store_wbuf *) io->data;

    // TODO: Examine return code. Not entirely sure how to handle errors.
    // Naive first-pass should probably cause the page to close/free.
    w->flushed = true;
    pthread_mutex_lock(&p->mutex);
    assert(p->wbuf != NULL && p->wbuf == w);
    assert(p->written == w->offset);
    p->written += w->size;
    p->wbuf = NULL;

    if (p->written == e->page_size)
        p->active = false;

    // return the wbuf
    pthread_mutex_lock(&e->mutex);
    w->next = e->wbuf_stack;
    e->wbuf_stack = w;
    // also return the IO we just used.
    io->next = e->io_stack;
    e->io_stack = io;
    pthread_mutex_unlock(&e->mutex);
    pthread_mutex_unlock(&p->mutex);
}",467.0,493.0,1.0,1.0,27.0,48,9,35,8,0,8,2,2,1,0,,0,8,6,3,3,void
1414,8835,_submit_wbuf,1,_submit_wbuf,"void _submit_wbuf (store_engine*,store_page*)",extstore.c,"static void _submit_wbuf(store_engine *e, store_page *p) {
    _store_wbuf *w;
    pthread_mutex_lock(&e->mutex);
    obj_io *io = e->io_stack;
    e->io_stack = io->next;
    pthread_mutex_unlock(&e->mutex);
    w = p->wbuf;

    // zero out the end of the wbuf to allow blind readback of data.
    memset(w->buf + (w->size - w->free), 0, w->free);

    io->next = NULL;
    io->mode = OBJ_IO_WRITE;
    io->page_id = p->id;
    io->data = w;
    io->offset = w->offset;
    io->len = w->size;
    io->buf = w->buf;
    io->cb = _wbuf_cb;

    extstore_submit(e, io);
}",498.0,519.0,1.0,1.0,22.0,37,5,29,6,1,5,1,1,0,1,,0,4,4,2,2,void
1415,8937,extstore_write_request,1,extstore_write_request,"int extstore_write_request (void*,unsigned int,unsigned int,obj_io*)",extstore.c,"int extstore_write_request(void *ptr, unsigned int bucket,
        unsigned int free_bucket, obj_io *io) {
    store_engine *e = (store_engine *)ptr;
    store_page *p;
    int ret = -1;
    if (bucket >= e->page_bucketcount)
        return ret;

    pthread_mutex_lock(&e->mutex);
    p = e->page_buckets[bucket];
    if (!p) {
        p = _allocate_page(e, bucket, free_bucket);
    }
    pthread_mutex_unlock(&e->mutex);
    if (!p)
        return ret;

    pthread_mutex_lock(&p->mutex);

    // FIXME: can't null out page_buckets!!!
    // page is full, clear bucket and retry later.
    if (!p->active ||
            ((!p->wbuf || p->wbuf->full) && p->allocated >= e->page_size)) {
        pthread_mutex_unlock(&p->mutex);
        pthread_mutex_lock(&e->mutex);
        _allocate_page(e, bucket, free_bucket);
        pthread_mutex_unlock(&e->mutex);
        return ret;
    }

    // if io won't fit, submit IO for wbuf and find new one.
    if (p->wbuf && p->wbuf->free < io->len && !p->wb...",530.0,581.0,1.0,1.0,52.0,74,11,54,8,0,12,8,8,3,4,,0,9,8,4,4,int
1416,9146,extstore_write,1,extstore_write,"void extstore_write (void*,obj_io*)",extstore.c,"void extstore_write(void *ptr, obj_io *io) {
    store_engine *e = (store_engine *)ptr;
    store_page *p = &e->pages[io->page_id];

    io->offset = p->wbuf->offset + (p->wbuf->size - p->wbuf->free);
    io->page_version = p->version;
    p->wbuf->buf_pos += io->len;
    p->wbuf->free -= io->len;
    p->bytes_used += io->len;
    p->obj_count++;
    STAT_L(e);
    e->stats.bytes_written += io->len;
    e->stats.bytes_used += io->len;
    e->stats.objects_written++;
    e->stats.objects_used++;
    STAT_UL(e);

    pthread_mutex_unlock(&p->mutex);
}",586.0,604.0,1.0,4.0,19.0,53,11,29,4,0,7,1,1,0,0,,0,7,4,2,2,void
1417,9277,extstore_submit,1,extstore_submit,"int extstore_submit (void*,obj_io*)",extstore.c,"int extstore_submit(void *ptr, obj_io *io) {
    store_engine *e = (store_engine *)ptr;

    unsigned int depth = 0;
    obj_io *tio = io;
    obj_io *tail = NULL;
    while (tio != NULL) {
        tail = tio; // keep updating potential tail.
        depth++;
        tio = tio->next;
    }

    store_io_thread *t = _get_io_thread(e);
    pthread_mutex_lock(&t->mutex);

    t->depth += depth;
    if (t->queue == NULL) {
        t->queue = io;
        t->queue_tail = tail;
    } else {
        // Have to put the *io stack at the end of current queue.
        assert(tail->next == NULL);
        assert(t->queue_tail->next == NULL);
        t->queue_tail->next = io;
        t->queue_tail = tail;
    }

    pthread_mutex_unlock(&t->mutex);

    //pthread_mutex_lock(&t->mutex);
    pthread_cond_signal(&t->cond);
    //pthread_mutex_unlock(&t->mutex);
    return 0;
}",611.0,644.0,1.0,1.0,34.0,25,8,27,8,1,8,3,3,1,1,,0,8,4,2,2,int
1418,9388,extstore_delete,1,extstore_delete,"int extstore_delete (void*,unsigned int,uint64_t,unsigned int,unsigned int)",extstore.c,"int extstore_delete(void *ptr, unsigned int page_id, uint64_t page_version,
        unsigned int count, unsigned int bytes) {
    store_engine *e = (store_engine *)ptr;
    // FIXME: validate page_id in bounds
    store_page *p = &e->pages[page_id];
    int ret = 0;

    pthread_mutex_lock(&p->mutex);
    if (!p->closed && p->version == page_version) {
        if (p->bytes_used >= bytes) {
            p->bytes_used -= bytes;
        } else {
            p->bytes_used = 0;
        }

        if (p->obj_count >= count) {
            p->obj_count -= count;
        } else {
            p->obj_count = 0; // caller has bad accounting?
        }
        STAT_L(e);
        e->stats.bytes_used -= bytes;
        e->stats.objects_used -= count;
        STAT_UL(e);

        if (p->obj_count == 0) {
            extstore_run_maint(e);
        }
    } else {
        ret = -1;
    }
    pthread_mutex_unlock(&p->mutex);
    return ret;
}",649.0,682.0,1.0,8.0,34.0,36,11,30,8,0,6,5,8,0,1,,0,5,10,5,5,int
1419,9523,extstore_check,1,extstore_check,"int extstore_check (void*,unsigned int,uint64_t)",extstore.c,"int extstore_check(void *ptr, unsigned int page_id, uint64_t page_version) {
    store_engine *e = (store_engine *)ptr;
    store_page *p = &e->pages[page_id];
    int ret = 0;

    pthread_mutex_lock(&p->mutex);
    if (p->version != page_version)
        ret = -1;
    pthread_mutex_unlock(&p->mutex);
    return ret;
}",684.0,694.0,1.0,1.0,11.0,15,7,12,6,0,1,2,2,0,0,,0,1,6,3,3,int
1420,9572,extstore_close_page,1,extstore_close_page,"void extstore_close_page (void*,unsigned int,uint64_t)",extstore.c,"void extstore_close_page(void *ptr, unsigned int page_id, uint64_t page_version) {
    store_engine *e = (store_engine *)ptr;
    store_page *p = &e->pages[page_id];

    pthread_mutex_lock(&p->mutex);
    if (!p->closed && p->version == page_version) {
        p->closed = true;
        extstore_run_maint(e);
    }
    pthread_mutex_unlock(&p->mutex);
}",697.0,707.0,1.0,1.0,11.0,17,8,13,6,0,2,2,2,0,1,,0,1,6,3,3,void
1421,9623,_read_from_wbuf,1,_read_from_wbuf,"int _read_from_wbuf (store_page*,obj_io*)",extstore.c,"static inline int _read_from_wbuf(store_page *p, obj_io *io) {
    _store_wbuf *wbuf = p->wbuf;
    assert(wbuf != NULL);
    assert(io->offset < p->written + wbuf->size);
    if (io->iov == NULL) {
        memcpy(io->buf, wbuf->buf + (io->offset - wbuf->offset), io->len);
    } else {
        int x;
        unsigned int off = io->offset - wbuf->offset;
        // need to loop fill iovecs
        for (x = 0; x < io->iovcnt; x++) {
            struct iovec *iov = &io->iov[x];
            memcpy(iov->iov_base, wbuf->buf + off, iov->iov_len);
            off += iov->iov_len;
        }
    }
    return io->len;
}",715.0,732.0,1.0,1.0,18.0,18,7,15,4,0,0,2,2,0,0,,0,0,4,2,2,int
1422,10102,_free_page,1,_free_page,"void _free_page (store_engine*,store_page*)",extstore.c,"static void _free_page(store_engine *e, store_page *p) {
    store_page *tmp = NULL;
    store_page *prev = NULL;
    E_DEBUG(""EXTSTORE: freeing page %u\n"", p->id);
    STAT_L(e);
    e->stats.objects_used -= p->obj_count;
    e->stats.bytes_used -= p->bytes_used;
    e->stats.page_reclaims++;
    STAT_UL(e);
    pthread_mutex_lock(&e->mutex);
    // unlink page from bucket list
    tmp = e->page_buckets[p->bucket];
    while (tmp) {
        if (tmp == p) {
            if (prev) {
                prev->next = tmp->next;
            } else {
                e->page_buckets[p->bucket] = tmp->next;
            }
            tmp->next = NULL;
            break;
        }
        prev = tmp;
        tmp = tmp->next;
    }
    // reset most values
    p->version = 0;
    p->obj_count = 0;
    p->bytes_used = 0;
    p->allocated = 0;
    p->written = 0;
    p->bucket = 0;
    p->active = false;
    p->closed = false;
    p->free = true;
    // add to page stack
    // TODO: free_page_bucke...",852.0,898.0,1.0,4.0,47.0,65,9,50,7,0,11,6,8,0,0,,0,11,4,2,2,void
1423,10726,obj_io_cb,1,obj_io_cb,"void obj_io_cb (void*,obj_io*,int)",extstore.h,"typedef void (*obj_io_cb)(void *e, obj_io *io, int ret);",71.0,71.0,14.0,55.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,void
1424,10888,XXH3_hash,1,XXH3_hash,"uint32_t XXH3_hash (void*,size_t)",hash.c,"static uint32_t XXH3_hash(const void *key, size_t length) {
    return (uint32_t)XXH3_64bits(key, length);
}",11.0,13.0,1.0,21.0,3.0,1,1,2,2,0,0,1,1,0,0,,0,0,4,2,2,uint32_t
1425,10902,hash_init,1,hash_init,int hash_init (hashfunc_type),hash.c,"int hash_init(enum hashfunc_type type) {
    switch(type) {
        case JENKINS_HASH:
            hash = jenkins_hash;
            settings.hash_algorithm = ""jenkins"";
            break;
        case MURMUR3_HASH:
            hash = MurmurHash3_x86_32;
            settings.hash_algorithm = ""murmur3"";
            break;
        case XXH3_HASH:
            hash = XXH3_hash;
            settings.hash_algorithm = ""xxh3"";
            break;
        default:
            return -1;
    }
    return 0;
}",15.0,33.0,1.0,1.0,19.0,10,3,12,8,1,6,5,2,0,0,,0,6,2,1,1,int
1426,10954,hash_func,1,hash_func,"uint32_t hash_func (void*,size_t)",hash.h,"typedef uint32_t (*hash_func)(const void *key, size_t length);",4.0,4.0,18.0,61.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,uint32_t
1427,11020,item_link_q,1,item_link_q,void item_link_q (item*),items.c,"static void item_link_q(item *it) {
    pthread_mutex_lock(&lru_locks[it->slabs_clsid]);
    do_item_link_q(it);
    pthread_mutex_unlock(&lru_locks[it->slabs_clsid]);
}",448.0,452.0,1.0,1.0,5.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,void
1428,11025,item_unlink_q,1,item_unlink_q,void item_unlink_q (item*),items.c,"static void item_unlink_q(item *it) {
    pthread_mutex_lock(&lru_locks[it->slabs_clsid]);
    do_item_unlink_q(it);
    pthread_mutex_unlock(&lru_locks[it->slabs_clsid]);
}",493.0,497.0,1.0,1.0,5.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,void
1429,11130,item_stats_reset,1,item_stats_reset,void item_stats_reset (void),items.c,"void item_stats_reset(void) {
    int i;
    for (i = 0; i < LARGEST_ID; i++) {
        pthread_mutex_lock(&lru_locks[i]);
        memset(&itemstats[i], 0, sizeof(itemstats_t));
        pthread_mutex_unlock(&lru_locks[i]);
    }
}",71.0,78.0,1.0,20.0,8.0,9,5,9,4,1,2,2,2,0,0,,0,2,2,1,1,void
1430,11167,do_item_stats_add_crawl,1,do_item_stats_add_crawl,"void do_item_stats_add_crawl (int,uint64_t,uint64_t,uint64_t)",items.c,"void do_item_stats_add_crawl(const int i, const uint64_t reclaimed,
        const uint64_t unfetched, const uint64_t checked) {
    itemstats[i].crawler_reclaimed += reclaimed;
    itemstats[i].expired_unfetched += unfetched;
    itemstats[i].crawler_items_checked += checked;
}",81.0,86.0,1.0,1.0,6.0,9,3,9,5,1,3,1,1,0,0,,0,3,8,4,4,void
1431,11221,lru_bump_async,1,lru_bump_async,"bool lru_bump_async (lru_bump_buf*,item*,uint32_t)",items.c,"static bool lru_bump_async(lru_bump_buf *b, item *it, uint32_t hv) {
    bool ret = true;
    refcount_incr(it);
    pthread_mutex_lock(&b->mutex);
    lru_bump_entry *be = (lru_bump_entry *) bipbuf_request(b->buf, sizeof(lru_bump_entry));
    if (be != NULL) {
        be->it = it;
        be->hv = hv;
        if (bipbuf_push(b->buf, sizeof(lru_bump_entry)) == 0) {
            ret = false;
            b->dropped++;
        }
    } else {
        ret = false;
        b->dropped++;
    }
    if (!ret) {
        refcount_decr(it);
    }
    pthread_mutex_unlock(&b->mutex);
    return ret;
}",1312.0,1333.0,1.0,4.0,22.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,bool
1432,11228,lru_total_bumps_dropped,1,lru_total_bumps_dropped,uint64_t lru_total_bumps_dropped (void),items.c,"static uint64_t lru_total_bumps_dropped(void) {
    uint64_t total = 0;
    lru_bump_buf *b;
    pthread_mutex_lock(&bump_buf_lock);
    for (b = bump_buf_head; b != NULL; b=b->next) {
        pthread_mutex_lock(&b->mutex);
        total += b->dropped;
        pthread_mutex_unlock(&b->mutex);
    }
    pthread_mutex_unlock(&bump_buf_lock);
    return total;
}",1376.0,1387.0,1.0,1.0,12.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,uint64_t
1433,11233,get_cas_id,1,get_cas_id,uint64_t get_cas_id (void),items.c,"uint64_t get_cas_id(void) {
    pthread_mutex_lock(&cas_id_lock);
    uint64_t next_id = ++cas_id;
    pthread_mutex_unlock(&cas_id_lock);
    return next_id;
}",112.0,117.0,1.0,1.0,6.0,4,3,5,3,6,3,1,1,0,0,,0,3,2,1,1,uint64_t
1434,11251,set_cas_id,1,set_cas_id,void set_cas_id (uint64_t),items.c,"void set_cas_id(uint64_t new_cas) {
    pthread_mutex_lock(&cas_id_lock);
    cas_id = new_cas;
    pthread_mutex_unlock(&cas_id_lock);
}",119.0,123.0,1.0,1.0,5.0,3,2,4,3,0,3,1,1,0,0,,0,3,2,1,1,void
1435,11265,item_is_flushed,1,item_is_flushed,int item_is_flushed (item*),items.c,"int item_is_flushed(item *it) {
    rel_time_t oldest_live = settings.oldest_live;
    uint64_t cas = ITEM_get_cas(it);
    uint64_t oldest_cas = settings.oldest_cas;
    if (oldest_live == 0 || oldest_live > current_time)
        return 0;
    if ((it->time <= oldest_live)
            || (oldest_cas != 0 && cas != 0 && cas < oldest_cas)) {
        return 1;
    }
    return 0;
}",125.0,136.0,1.0,19.0,12.0,22,13,17,6,3,2,3,3,0,0,,0,2,2,1,1,int
1436,11336,do_get_lru_size,1,do_get_lru_size,unsigned int do_get_lru_size (uint32_t),items.c,"unsigned int do_get_lru_size(uint32_t id) {
    return sizes[id];
}",139.0,141.0,1.0,1.0,3.0,1,1,2,2,1,1,1,1,0,0,,0,1,2,1,1,unsigned int
1437,11345,item_make_header,1,item_make_header,"size_t item_make_header (uint8_t,unsigned int,int,char*,uint8_t*)",items.c,"static size_t item_make_header(const uint8_t nkey, const unsigned int flags, const int nbytes,
                     char *suffix, uint8_t *nsuffix) {
    if (flags == 0) {
        *nsuffix = 0;
    } else {
        *nsuffix = sizeof(flags);
    }
    return sizeof(item) + nkey + *nsuffix + nbytes;
}",165.0,173.0,1.0,1.0,9.0,8,5,6,5,2,0,2,2,0,0,,0,0,10,5,5,size_t
1438,11380,do_item_alloc_pull,1,do_item_alloc_pull,"item do_item_alloc_pull (size_t,unsigned int)",items.c,"item *do_item_alloc_pull(const size_t ntotal, const unsigned int id) {
    item *it = NULL;
    int i;
    /* If no memory is available, attempt a direct LRU juggle/eviction */
    /* This is a race in order to simplify lru_pull_tail; in cases where
     * locked items are on the tail, you want them to fall out and cause
     * occasional OOM's, rather than internally work around them.
     * This also gives one fewer code path for slab alloc/free
     */
    for (i = 0; i < 10; i++) {
        /* Try to reclaim memory first */
        if (!settings.lru_segmented) {
            lru_pull_tail(id, COLD_LRU, 0, 0, 0, NULL);
        }
        it = slabs_alloc(ntotal, id, 0);

        if (it == NULL) {
            // We send '0' in for ""total_bytes"" as this routine is always
            // pulling to evict, or forcing HOT -> COLD migration.
            // As of this writing, total_bytes isn't at all used with COLD_LRU.
            if (lru_pull_tail(id, COLD_LRU, 0, LRU_PULL_EVICT, 0, NULL...",175.0,214.0,1.0,30.0,40.0,17,10,26,8,2,7,7,14,3,4,,0,5,4,2,2,item
1439,11487,do_item_alloc_chunk,1,do_item_alloc_chunk,"item_chunk do_item_alloc_chunk (item_chunk*,size_t)",items.c,"item_chunk *do_item_alloc_chunk(item_chunk *ch, const size_t bytes_remain) {
    // TODO: Should be a cleaner way of finding real size with slabber calls
    size_t size = bytes_remain + sizeof(item_chunk);
    if (size > settings.slab_chunk_size_max)
        size = settings.slab_chunk_size_max;
    unsigned int id = slabs_clsid(size);

    item_chunk *nch = (item_chunk *) do_item_alloc_pull(size, id);
    if (nch == NULL) {
        // The final chunk in a large item will attempt to be a more
        // appropriately sized chunk to minimize memory overhead. However, if
        // there's no memory available in the lower slab classes we fail the
        // SET. In these cases as a fallback we ensure we attempt to evict a
        // max-size item and reuse a large chunk.
        if (size == settings.slab_chunk_size_max) {
            return NULL;
        } else {
            size = settings.slab_chunk_size_max;
            id = slabs_clsid(size);
            nch = (item_chunk *) do_it...",221.0,260.0,1.0,21.0,40.0,31,9,32,8,2,7,4,5,2,4,,0,5,4,2,2,item_chunk
1440,11615,do_item_alloc,1,do_item_alloc,"item do_item_alloc (char*,size_t,unsigned int,rel_time_t,int)",items.c,"item *do_item_alloc(char *key, const size_t nkey, const unsigned int flags,
                    const rel_time_t exptime, const int nbytes) {
    uint8_t nsuffix;
    item *it = NULL;
    char suffix[40];
    // Avoid potential underflows.
    if (nbytes < 2)
        return 0;

    size_t ntotal = item_make_header(nkey + 1, flags, nbytes, suffix, &nsuffix);
    if (settings.use_cas) {
        ntotal += sizeof(uint64_t);
    }

    unsigned int id = slabs_clsid(ntotal);
    unsigned int hdr_id = 0;
    if (id == 0)
        return 0;

    /* This is a large item. Allocate a header object now, lazily allocate
     *  chunks while reading the upload.
     */
    if (ntotal > settings.slab_chunk_size_max) {
        /* We still link this item into the LRU for the larger slab class, but
         * we're pulling a header from an entirely different slab class. The
         * free routines handle large items specifically.
         */
        int htotal = nkey + 1 + nsuffix + sizeof(item) + si...",262.0,361.0,1.0,28.0,100.0,119,20,97,22,1,11,11,13,5,4,,0,11,10,5,5,item
1441,12006,item_free,1,item_free,void item_free (item*),items.c,"void item_free(item *it) {
    size_t ntotal = ITEM_ntotal(it);
    unsigned int clsid;
    assert((it->it_flags & ITEM_LINKED) == 0);
    assert(it != heads[it->slabs_clsid]);
    assert(it != tails[it->slabs_clsid]);
    assert(it->refcount == 0);

    /* so slab size changer can tell later if item is already free or not */
    clsid = ITEM_clsid(it);
    DEBUG_REFCNT(it, 'F');
    slabs_free(it, ntotal, clsid);
}",363.0,375.0,1.0,20.0,13.0,33,11,23,8,1,3,1,1,0,1,,0,2,2,1,1,void
1442,12103,item_size_ok,1,item_size_ok,"bool item_size_ok (size_t,int,int)",items.c,"bool item_size_ok(const size_t nkey, const int flags, const int nbytes) {
    char prefix[40];
    uint8_t nsuffix;
    if (nbytes < 2)
        return false;

    size_t ntotal = item_make_header(nkey + 1, flags, nbytes,
                                     prefix, &nsuffix);
    if (settings.use_cas) {
        ntotal += sizeof(uint64_t);
    }

    return slabs_clsid(ntotal) != 0;
}",381.0,394.0,1.0,1.0,14.0,8,8,12,9,2,3,3,3,1,2,,0,2,6,3,3,bool
1443,12145,do_item_link_fixup,1,do_item_link_fixup,void do_item_link_fixup (item*),items.c,"void do_item_link_fixup(item *it) {
    item **head, **tail;
    int ntotal = ITEM_ntotal(it);
    uint32_t hv = hash(ITEM_key(it), it->nkey);
    assoc_insert(it, hv);

    head = &heads[it->slabs_clsid];
    tail = &tails[it->slabs_clsid];
    if (it->prev == 0 && *head == 0) *head = it;
    if (it->next == 0 && *tail == 0) *tail = it;
    sizes[it->slabs_clsid]++;
    sizes_bytes[it->slabs_clsid] += ntotal;

    STATS_LOCK();
    stats_state.curr_bytes += ntotal;
    stats_state.curr_items += 1;
    stats.total_items += 1;
    STATS_UNLOCK();

    item_stats_sizes_add(it);

    return;
}",397.0,419.0,1.0,17.0,23.0,61,15,41,14,1,11,3,3,0,2,,0,7,2,1,1,void
1444,12300,do_item_link_q,1,do_item_link_q,void do_item_link_q (item*),items.c,"static void do_item_link_q(item *it) { /* item is the new head */
    item **head, **tail;
    assert((it->it_flags & ITEM_SLABBED) == 0);

    head = &heads[it->slabs_clsid];
    tail = &tails[it->slabs_clsid];
    assert(it != *head);
    assert((*head && *tail) || (*head == 0 && *tail == 0));
    it->prev = 0;
    it->next = *head;
    if (it->next) it->next->prev = it;
    *head = it;
    if (*tail == 0) *tail = it;
    sizes[it->slabs_clsid]++;
#ifdef EXTSTORE
    if (it->it_flags & ITEM_HDR) {
        sizes_bytes[it->slabs_clsid] += (ITEM_ntotal(it) - it->nbytes) + sizeof(item_hdr);
    } else {
        sizes_bytes[it->slabs_clsid] += ITEM_ntotal(it);
    }
#else
    sizes_bytes[it->slabs_clsid] += ITEM_ntotal(it);
#endif

    return;
}",421.0,446.0,1.0,27.0,26.0,59,15,36,10,2,4,3,3,0,0,,0,4,2,1,1,void
1445,12460,item_link_q_warm,1,item_link_q_warm,void item_link_q_warm (item*),items.c,"static void item_link_q_warm(item *it) {
    pthread_mutex_lock(&lru_locks[it->slabs_clsid]);
    do_item_link_q(it);
    itemstats[it->slabs_clsid].moves_to_warm++;
    pthread_mutex_unlock(&lru_locks[it->slabs_clsid]);
}",454.0,459.0,1.0,1.0,6.0,10,5,7,3,1,2,1,1,0,1,,0,1,2,1,1,void
1446,12489,do_item_unlink_q,1,do_item_unlink_q,void do_item_unlink_q (item*),items.c,"static void do_item_unlink_q(item *it) {
    item **head, **tail;
    head = &heads[it->slabs_clsid];
    tail = &tails[it->slabs_clsid];

    if (*head == it) {
        assert(it->prev == 0);
        *head = it->next;
    }
    if (*tail == it) {
        assert(it->next == 0);
        *tail = it->prev;
    }
    assert(it->next != it);
    assert(it->prev != it);

    if (it->next) it->next->prev = it->prev;
    if (it->prev) it->prev->next = it->next;
    sizes[it->slabs_clsid]--;
#ifdef EXTSTORE
    if (it->it_flags & ITEM_HDR) {
        sizes_bytes[it->slabs_clsid] -= (ITEM_ntotal(it) - it->nbytes) + sizeof(item_hdr);
    } else {
        sizes_bytes[it->slabs_clsid] -= ITEM_ntotal(it);
    }
#else
    sizes_bytes[it->slabs_clsid] -= ITEM_ntotal(it);
#endif

    return;
}",461.0,491.0,1.0,36.0,31.0,58,13,38,10,2,4,5,5,0,0,,0,4,2,1,1,void
1447,12657,do_item_link,1,do_item_link,"int do_item_link (item*,uint32_t)",items.c,"int do_item_link(item *it, const uint32_t hv) {
    MEMCACHED_ITEM_LINK(ITEM_key(it), it->nkey, it->nbytes);
    assert((it->it_flags & (ITEM_LINKED|ITEM_SLABBED)) == 0);
    it->it_flags |= ITEM_LINKED;
    it->time = current_time;

    STATS_LOCK();
    stats_state.curr_bytes += ITEM_ntotal(it);
    stats_state.curr_items += 1;
    stats.total_items += 1;
    STATS_UNLOCK();

    /* Allocate a new CAS ID on link. */
    ITEM_set_cas(it, (settings.use_cas) ? get_cas_id() : 0);
    assoc_insert(it, hv);
    item_link_q(it);
    refcount_incr(it);
    item_stats_sizes_add(it);

    return 1;
}",499.0,519.0,1.0,4.0,21.0,38,11,25,9,2,10,1,1,0,4,,0,5,4,2,2,int
1448,12778,do_item_unlink,1,do_item_unlink,"void do_item_unlink (item*,uint32_t)",items.c,"void do_item_unlink(item *it, const uint32_t hv) {
    MEMCACHED_ITEM_UNLINK(ITEM_key(it), it->nkey, it->nbytes);
    if ((it->it_flags & ITEM_LINKED) != 0) {
        it->it_flags &= ~ITEM_LINKED;
        STATS_LOCK();
        stats_state.curr_bytes -= ITEM_ntotal(it);
        stats_state.curr_items -= 1;
        STATS_UNLOCK();
        item_stats_sizes_remove(it);
        assoc_delete(ITEM_key(it), it->nkey, hv);
        item_unlink_q(it);
        do_item_remove(it);
    }
}",521.0,534.0,1.0,4.0,14.0,34,11,21,6,4,8,2,2,0,4,,0,2,4,2,2,void
1449,12879,do_item_unlink_nolock,1,do_item_unlink_nolock,"void do_item_unlink_nolock (item*,uint32_t)",items.c,"void do_item_unlink_nolock(item *it, const uint32_t hv) {
    MEMCACHED_ITEM_UNLINK(ITEM_key(it), it->nkey, it->nbytes);
    if ((it->it_flags & ITEM_LINKED) != 0) {
        it->it_flags &= ~ITEM_LINKED;
        STATS_LOCK();
        stats_state.curr_bytes -= ITEM_ntotal(it);
        stats_state.curr_items -= 1;
        STATS_UNLOCK();
        item_stats_sizes_remove(it);
        assoc_delete(ITEM_key(it), it->nkey, hv);
        do_item_unlink_q(it);
        do_item_remove(it);
    }
}",537.0,550.0,1.0,4.0,14.0,34,11,21,6,3,8,2,2,0,4,,0,2,4,2,2,void
1450,12980,do_item_remove,1,do_item_remove,void do_item_remove (item*),items.c,"void do_item_remove(item *it) {
    MEMCACHED_ITEM_REMOVE(ITEM_key(it), it->nkey, it->nbytes);
    assert((it->it_flags & ITEM_SLABBED) == 0);
    assert(it->refcount > 0);

    if (refcount_decr(it) == 0) {
        item_free(it);
    }
}",552.0,560.0,1.0,4.0,9.0,8,5,5,1,20,1,2,2,0,1,,0,0,2,1,1,void
1451,13014,do_item_update,1,do_item_update,void do_item_update (item*),items.c,"void do_item_update(item *it) {
    MEMCACHED_ITEM_UPDATE(ITEM_key(it), it->nkey, it->nbytes);

    /* Hits to COLD_LRU immediately move to WARM. */
    if (settings.lru_segmented) {
        assert((it->it_flags & ITEM_SLABBED) == 0);
        if ((it->it_flags & ITEM_LINKED) != 0) {
            if (ITEM_lruid(it) == COLD_LRU && (it->it_flags & ITEM_ACTIVE)) {
                it->time = current_time;
                item_unlink_q(it);
                it->slabs_clsid = ITEM_clsid(it);
                it->slabs_clsid |= WARM_LRU;
                it->it_flags &= ~ITEM_ACTIVE;
                item_link_q_warm(it);
            } else {
                it->time = current_time;
            }
        }
    } else if (it->time < current_time - ITEM_UPDATE_INTERVAL) {
        assert((it->it_flags & ITEM_SLABBED) == 0);

        if ((it->it_flags & ITEM_LINKED) != 0) {
            it->time = current_time;
            item_unlink_q(it);
            item_link_q(it);
        }
    }
}",563.0,590.0,1.0,4.0,28.0,25,9,15,3,3,3,4,7,1,2,,0,1,2,1,1,void
1452,13158,do_item_replace,1,do_item_replace,"int do_item_replace (item*,item*,uint32_t)",items.c,"int do_item_replace(item *it, item *new_it, const uint32_t hv) {
    MEMCACHED_ITEM_REPLACE(ITEM_key(it), it->nkey, it->nbytes,
                           ITEM_key(new_it), new_it->nkey, new_it->nbytes);
    assert((it->it_flags & ITEM_SLABBED) == 0);

    do_item_unlink(it, hv);
    return do_item_link(new_it, hv);
}",592.0,599.0,1.0,4.0,8.0,3,3,5,3,1,2,1,1,0,2,,0,0,6,3,3,int
1453,13182,item_cachedump,1,item_cachedump,"char* item_cachedump (unsigned int,unsigned int,unsigned int*)",items.c,"char *item_cachedump(const unsigned int slabs_clsid, const unsigned int limit, unsigned int *bytes) {
    unsigned int memlimit = 2 * 1024 * 1024;   /* 2MB max response size */
    char *buffer;
    unsigned int bufcurr;
    item *it;
    unsigned int len;
    unsigned int shown = 0;
    char key_temp[KEY_MAX_LENGTH + 1];
    char temp[512];
    unsigned int id = slabs_clsid;
    id |= COLD_LRU;

    pthread_mutex_lock(&lru_locks[id]);
    it = heads[id];

    buffer = malloc((size_t)memlimit);
    if (buffer == 0) {
        pthread_mutex_unlock(&lru_locks[id]);
        return NULL;
    }
    bufcurr = 0;

    while (it != NULL && (limit == 0 || shown < limit)) {
        assert(it->nkey <= KEY_MAX_LENGTH);
        // protect from printing binary keys.
        if ((it->nbytes == 0 && it->nkey == 0) || (it->it_flags & ITEM_KEY_BINARY)) {
            it = it->next;
            continue;
        }
        /* Copy the key since it may not be null-terminated in the struct */
        strnc...",608.0,658.0,1.0,18.0,51.0,68,21,64,17,0,1,7,7,0,0,,0,1,6,3,3,char*
1454,13399,fill_item_stats_automove,1,fill_item_stats_automove,void fill_item_stats_automove (item_stats_automove*),items.c,"void fill_item_stats_automove(item_stats_automove *am) {
    int n;
    for (n = 0; n < MAX_NUMBER_OF_SLAB_CLASSES; n++) {
        item_stats_automove *cur = &am[n];

        // outofmemory records into HOT
        int i = n | HOT_LRU;
        pthread_mutex_lock(&lru_locks[i]);
        cur->outofmemory = itemstats[i].outofmemory;
        pthread_mutex_unlock(&lru_locks[i]);

        // evictions and tail age are from COLD
        i = n | COLD_LRU;
        pthread_mutex_lock(&lru_locks[i]);
        cur->evicted = itemstats[i].evicted;
        if (!tails[i]) {
            cur->age = 0;
        } else if (tails[i]->nbytes == 0 && tails[i]->nkey == 0 && tails[i]->it_flags == 1) {
            /* it's a crawler, check previous entry */
            if (tails[i]->prev) {
               cur->age = current_time - tails[i]->prev->time;
            } else {
               cur->age = 0;
            }
        } else {
            cur->age = current_time - tails[i]->time;
        }
        pthread...",663.0,692.0,1.0,20.0,30.0,30,9,26,7,4,6,3,4,1,0,,0,6,2,1,1,void
1455,13558,item_stats_totals,1,item_stats_totals,"void item_stats_totals (ADD_STAT,void*)",items.c,"void item_stats_totals(ADD_STAT add_stats, void *c) {
    itemstats_t totals;
    memset(&totals, 0, sizeof(itemstats_t));
    int n;
    for (n = 0; n < MAX_NUMBER_OF_SLAB_CLASSES; n++) {
        int x;
        int i;
        for (x = 0; x < 4; x++) {
            i = n | lru_type_map[x];
            pthread_mutex_lock(&lru_locks[i]);
            totals.expired_unfetched += itemstats[i].expired_unfetched;
            totals.evicted_unfetched += itemstats[i].evicted_unfetched;
            totals.evicted_active += itemstats[i].evicted_active;
            totals.evicted += itemstats[i].evicted;
            totals.reclaimed += itemstats[i].reclaimed;
            totals.crawler_reclaimed += itemstats[i].crawler_reclaimed;
            totals.crawler_items_checked += itemstats[i].crawler_items_checked;
            totals.lrutail_reflocked += itemstats[i].lrutail_reflocked;
            totals.moves_to_cold += itemstats[i].moves_to_cold;
            totals.moves_to_warm += itemstats[i].moves...",694.0,749.0,1.0,20.0,56.0,89,10,90,11,1,54,5,6,2,14,,0,41,4,2,2,void
1456,13915,item_stats,1,item_stats,"void item_stats (ADD_STAT,void*)",items.c,"void item_stats(ADD_STAT add_stats, void *c) {
    struct thread_stats thread_stats;
    threadlocal_stats_aggregate(&thread_stats);
    itemstats_t totals;
    int n;
    for (n = 0; n < MAX_NUMBER_OF_SLAB_CLASSES; n++) {
        memset(&totals, 0, sizeof(itemstats_t));
        int x;
        int i;
        unsigned int size = 0;
        unsigned int age  = 0;
        unsigned int age_hot = 0;
        unsigned int age_warm = 0;
        unsigned int lru_size_map[4];
        const char *fmt = ""items:%d:%s"";
        char key_str[STAT_KEY_LEN];
        char val_str[STAT_VAL_LEN];
        int klen = 0, vlen = 0;
        for (x = 0; x < 4; x++) {
            i = n | lru_type_map[x];
            pthread_mutex_lock(&lru_locks[i]);
            totals.evicted += itemstats[i].evicted;
            totals.evicted_nonzero += itemstats[i].evicted_nonzero;
            totals.outofmemory += itemstats[i].outofmemory;
            totals.tailrepairs += itemstats[i].tailrepairs;
            totals.recl...",751.0,882.0,1.0,20.0,132.0,230,15,519,26,0,77,16,24,8,1,,0,76,4,2,2,void
1457,15194,item_stats_sizes_status,1,item_stats_sizes_status,bool item_stats_sizes_status (void),items.c,"bool item_stats_sizes_status(void) {
    bool ret = false;
    mutex_lock(&stats_sizes_lock);
    if (stats_sizes_hist != NULL)
        ret = true;
    mutex_unlock(&stats_sizes_lock);
    return ret;
}",884.0,891.0,1.0,4.0,8.0,7,3,11,6,1,5,2,2,1,0,,0,5,2,1,1,bool
1458,15227,item_stats_sizes_init,1,item_stats_sizes_init,void item_stats_sizes_init (void),items.c,"void item_stats_sizes_init(void) {
    if (stats_sizes_hist != NULL)
        return;
    stats_sizes_buckets = settings.item_size_max / 32 + 1;
    stats_sizes_hist = calloc(stats_sizes_buckets, sizeof(int));
    stats_sizes_cas_min = (settings.use_cas) ? get_cas_id() : 0;
}",893.0,899.0,1.0,1.0,7.0,10,7,9,6,1,8,2,2,1,1,,0,8,2,1,1,void
1459,15261,item_stats_sizes_enable,1,item_stats_sizes_enable,"void item_stats_sizes_enable (ADD_STAT,void*)",items.c,"void item_stats_sizes_enable(ADD_STAT add_stats, void *c) {
    mutex_lock(&stats_sizes_lock);
    if (!settings.use_cas) {
        APPEND_STAT(""sizes_status"", ""error"", """");
        APPEND_STAT(""sizes_error"", ""cas_support_disabled"", """");
    } else if (stats_sizes_hist == NULL) {
        item_stats_sizes_init();
        if (stats_sizes_hist != NULL) {
            APPEND_STAT(""sizes_status"", ""enabled"", """");
        } else {
            APPEND_STAT(""sizes_status"", ""error"", """");
            APPEND_STAT(""sizes_error"", ""no_memory"", """");
        }
    } else {
        APPEND_STAT(""sizes_status"", ""enabled"", """");
    }
    mutex_unlock(&stats_sizes_lock);
}",901.0,918.0,1.0,4.0,18.0,6,3,9,4,0,7,2,2,1,2,,0,5,4,2,2,void
1460,15370,item_stats_sizes_disable,1,item_stats_sizes_disable,"void item_stats_sizes_disable (ADD_STAT,void*)",items.c,"void item_stats_sizes_disable(ADD_STAT add_stats, void *c) {
    mutex_lock(&stats_sizes_lock);
    if (stats_sizes_hist != NULL) {
        free(stats_sizes_hist);
        stats_sizes_hist = NULL;
    }
    APPEND_STAT(""sizes_status"", ""disabled"", """");
    mutex_unlock(&stats_sizes_lock);
}",920.0,928.0,1.0,4.0,9.0,6,3,11,5,0,8,2,2,1,1,,0,7,4,2,2,void
1461,15411,item_stats_sizes_add,1,item_stats_sizes_add,void item_stats_sizes_add (item*),items.c,"void item_stats_sizes_add(item *it) {
    if (stats_sizes_hist == NULL || stats_sizes_cas_min > ITEM_get_cas(it))
        return;
    int ntotal = ITEM_ntotal(it);
    int bucket = ntotal / 32;
    if ((ntotal % 32) != 0) bucket++;
    if (bucket < stats_sizes_buckets) stats_sizes_hist[bucket]++;
}",930.0,937.0,1.0,58.0,8.0,34,16,23,10,3,4,4,4,3,0,,0,4,2,1,1,void
1462,15504,item_stats_sizes_remove,1,item_stats_sizes_remove,void item_stats_sizes_remove (item*),items.c,"void item_stats_sizes_remove(item *it) {
    if (stats_sizes_hist == NULL || stats_sizes_cas_min > ITEM_get_cas(it))
        return;
    int ntotal = ITEM_ntotal(it);
    int bucket = ntotal / 32;
    if ((ntotal % 32) != 0) bucket++;
    if (bucket < stats_sizes_buckets) stats_sizes_hist[bucket]--;
}",942.0,949.0,1.0,58.0,8.0,34,17,23,10,3,4,4,4,3,0,,0,4,2,1,1,void
1463,15597,item_stats_sizes,1,item_stats_sizes,"void item_stats_sizes (ADD_STAT,void*)",items.c,"void item_stats_sizes(ADD_STAT add_stats, void *c) {
    mutex_lock(&stats_sizes_lock);

    if (stats_sizes_hist != NULL) {
        int i;
        for (i = 0; i < stats_sizes_buckets; i++) {
            if (stats_sizes_hist[i] != 0) {
                char key[12];
                snprintf(key, sizeof(key), ""%d"", i * 32);
                APPEND_STAT(key, ""%u"", stats_sizes_hist[i]);
            }
        }
    } else {
        APPEND_STAT(""sizes_status"", ""disabled"", """");
    }

    add_stats(NULL, 0, NULL, 0, c);
    mutex_unlock(&stats_sizes_lock);
}",957.0,975.0,1.0,4.0,19.0,13,7,25,8,0,10,4,7,3,1,,0,9,4,2,2,void
1464,15684,do_item_get,1,do_item_get,"item do_item_get (char*,size_t,uint32_t,conn*,bool)",items.c,"item *do_item_get(const char *key, const size_t nkey, const uint32_t hv, conn *c, const bool do_update) {
    item *it = assoc_find(key, nkey, hv);
    if (it != NULL) {
        refcount_incr(it);
        /* Optimization for slab reassignment. prevents popular items from
         * jamming in busy wait. Can only do this here to satisfy lock order
         * of item_lock, slabs_lock. */
        /* This was made unsafe by removal of the cache_lock:
         * slab_rebalance_signal and slab_rebal.* are modified in a separate
         * thread under slabs_lock. If slab_rebalance_signal = 1, slab_start =
         * NULL (0), but slab_end is still equal to some value, this would end
         * up unlinking every item fetched.
         * This is either an acceptable loss, or if slab_rebalance_signal is
         * true, slab_start/slab_end should be put behind the slabs_lock.
         * Which would cause a huge potential slowdown.
         * Could also use a specific lock for slab_rebal.* a...",978.0,1058.0,1.0,8.0,81.0,52,16,57,14,3,15,9,14,4,5,,0,12,10,5,5,item
1465,15971,do_item_bump,1,do_item_bump,"void do_item_bump (conn*,item*,uint32_t)",items.c,"void do_item_bump(conn *c, item *it, const uint32_t hv) {
    /* We update the hit markers only during fetches.
     * An item needs to be hit twice overall to be considered
     * ACTIVE, but only needs a single hit to maintain activity
     * afterward.
     * FETCHED tells if an item has ever been active.
     */
    if (settings.lru_segmented) {
        if ((it->it_flags & ITEM_ACTIVE) == 0) {
            if ((it->it_flags & ITEM_FETCHED) == 0) {
                it->it_flags |= ITEM_FETCHED;
            } else {
                it->it_flags |= ITEM_ACTIVE;
                if (ITEM_lruid(it) != COLD_LRU) {
                    it->time = current_time; // only need to bump time.
                } else if (!lru_bump_async(c->thread->lru_bump_buf, it, hv)) {
                    // add flag before async bump to avoid race.
                    it->it_flags &= ~ITEM_ACTIVE;
                }
            }
        }
    } else {
        it->it_flags |= ITEM_FETCHED;
        do_item_updat...",1063.0,1088.0,1.0,28.0,26.0,8,4,4,2,1,1,4,7,1,0,,0,1,6,3,3,void
1466,16074,do_item_touch,1,do_item_touch,"item do_item_touch (char*,size_t,uint32_t,uint32_t,conn*)",items.c,"item *do_item_touch(const char *key, size_t nkey, uint32_t exptime,
                    const uint32_t hv, conn *c) {
    item *it = do_item_get(key, nkey, hv, c, DO_UPDATE);
    if (it != NULL) {
        it->exptime = exptime;
    }
    return it;
}",1090.0,1097.0,1.0,45.0,8.0,4,3,11,8,0,1,2,2,0,1,,0,1,10,5,5,item
1467,16106,lru_pull_tail,1,lru_pull_tail,"int lru_pull_tail (int,int,uint64_t,uint8_t,rel_time_t,lru_pull_tail_return*)",items.c,"int lru_pull_tail(const int orig_id, const int cur_lru,
        const uint64_t total_bytes, const uint8_t flags, const rel_time_t max_age,
        struct lru_pull_tail_return *ret_it) {
    item *it = NULL;
    int id = orig_id;
    int removed = 0;
    if (id == 0)
        return 0;

    int tries = 5;
    item *search;
    item *next_it;
    void *hold_lock = NULL;
    unsigned int move_to_lru = 0;
    uint64_t limit = 0;

    id |= cur_lru;
    pthread_mutex_lock(&lru_locks[id]);
    search = tails[id];
    /* We walk up *only* for locked items, and if bottom is expired. */
    for (; tries > 0 && search != NULL; tries--, search=next_it) {
        /* we might relink search mid-loop, so search->prev isn't reliable */
        next_it = search->prev;
        if (search->nbytes == 0 && search->nkey == 0 && search->it_flags == 1) {
            /* We are a crawler, ignore it. */
            if (flags & LRU_PULL_CRAWL_BLOCKS) {
                pthread_mutex_unlock(&lru_locks[id]);
     ...",1103.0,1277.0,1.0,24.0,175.0,146,24,141,25,7,34,33,62,6,17,,0,19,12,6,6,int
1468,16753,lru_bump_buf_link_q,1,lru_bump_buf_link_q,void lru_bump_buf_link_q (lru_bump_buf*),items.c,"static void lru_bump_buf_link_q(lru_bump_buf *b) {
    pthread_mutex_lock(&bump_buf_lock);
    assert(b != bump_buf_head);

    b->prev = 0;
    b->next = bump_buf_head;
    if (b->next) b->next->prev = b;
    bump_buf_head = b;
    if (bump_buf_tail == 0) bump_buf_tail = b;
    pthread_mutex_unlock(&bump_buf_lock);
    return;
}",1281.0,1292.0,1.0,1.0,12.0,14,5,15,4,1,7,3,3,1,0,,0,7,2,1,1,void
1469,16802,item_lru_bump_buf_create,1,item_lru_bump_buf_create,void* item_lru_bump_buf_create (void),items.c,"void *item_lru_bump_buf_create(void) {
    lru_bump_buf *b = calloc(1, sizeof(lru_bump_buf));
    if (b == NULL) {
        return NULL;
    }

    b->buf = bipbuf_new(sizeof(lru_bump_entry) * LRU_BUMP_BUF_SIZE);
    if (b->buf == NULL) {
        free(b);
        return NULL;
    }

    pthread_mutex_init(&b->mutex, NULL);

    lru_bump_buf_link_q(b);
    return b;
}",1294.0,1310.0,1.0,49.0,17.0,11,6,15,4,1,3,3,3,0,2,,0,2,2,1,1,void*
1470,16946,lru_maintainer_bumps,1,lru_maintainer_bumps,bool lru_maintainer_bumps (void),items.c,"static bool lru_maintainer_bumps(void) {
    lru_bump_buf *b;
    lru_bump_entry *be;
    unsigned int size;
    unsigned int todo;
    bool bumped = false;
    pthread_mutex_lock(&bump_buf_lock);
    for (b = bump_buf_head; b != NULL; b=b->next) {
        pthread_mutex_lock(&b->mutex);
        be = (lru_bump_entry *) bipbuf_peek_all(b->buf, &size);
        pthread_mutex_unlock(&b->mutex);

        if (be == NULL) {
            continue;
        }
        todo = size;
        bumped = true;

        while (todo) {
            item_lock(be->hv);
            do_item_update(be->it);
            do_item_remove(be->it);
            item_unlock(be->hv);
            be++;
            todo -= sizeof(lru_bump_entry);
        }

        pthread_mutex_lock(&b->mutex);
        be = (lru_bump_entry *) bipbuf_poll(b->buf, size);
        pthread_mutex_unlock(&b->mutex);
    }
    pthread_mutex_unlock(&bump_buf_lock);
    return bumped;
}",1341.0,1374.0,1.0,1.0,34.0,30,9,33,11,1,14,5,6,0,6,,0,10,2,1,1,bool
1471,17104,lru_maintainer_juggle,1,lru_maintainer_juggle,int lru_maintainer_juggle (int),items.c,"static int lru_maintainer_juggle(const int slabs_clsid) {
    int i;
    int did_moves = 0;
    uint64_t total_bytes = 0;
    unsigned int chunks_perslab = 0;
    //unsigned int chunks_free = 0;
    /* TODO: if free_chunks below high watermark, increase aggressiveness */
    slabs_available_chunks(slabs_clsid, NULL,
            &chunks_perslab);
    if (settings.temp_lru) {
        /* Only looking for reclaims. Run before we size the LRU. */
        for (i = 0; i < 500; i++) {
            if (lru_pull_tail(slabs_clsid, TEMP_LRU, 0, 0, 0, NULL) <= 0) {
                break;
            } else {
                did_moves++;
            }
        }
    }

    rel_time_t cold_age = 0;
    rel_time_t hot_age = 0;
    rel_time_t warm_age = 0;
    /* If LRU is in flat mode, force items to drain into COLD via max age of 0 */
    if (settings.lru_segmented) {
        pthread_mutex_lock(&lru_locks[slabs_clsid|COLD_LRU]);
        if (tails[slabs_clsid|COLD_LRU]) {
            cold_age = curre...",1397.0,1458.0,1.0,43.0,62.0,61,14,68,15,1,15,12,17,7,5,,0,13,2,1,1,int
1472,17365,lru_maintainer_crawler_check,1,lru_maintainer_crawler_check,"void lru_maintainer_crawler_check (crawler_expired_data*,logger*)",items.c,"static void lru_maintainer_crawler_check(struct crawler_expired_data *cdata, logger *l) {
    int i;
    static rel_time_t next_crawls[POWER_LARGEST];
    static rel_time_t next_crawl_wait[POWER_LARGEST];
    uint8_t todo[POWER_LARGEST];
    memset(todo, 0, sizeof(uint8_t) * POWER_LARGEST);
    bool do_run = false;
    unsigned int tocrawl_limit = 0;

    // TODO: If not segmented LRU, skip non-cold
    for (i = POWER_SMALLEST; i < POWER_LARGEST; i++) {
        crawlerstats_t *s = &cdata->crawlerstats[i];
        /* We've not successfully kicked off a crawl yet. */
        if (s->run_complete) {
            char *lru_name = ""na"";
            pthread_mutex_lock(&cdata->lock);
            int x;
            /* Should we crawl again? */
            uint64_t possible_reclaims = s->seen - s->noexp;
            uint64_t available_reclaims = 0;
            /* Need to think we can free at least 1% of the items before
             * crawling. */
            /* FIXME: Configurable? */
       ...",1474.0,1566.0,1.0,34.0,93.0,102,19,110,28,1,20,18,33,4,2,,0,18,4,2,2,void
1473,17763,lru_maintainer_thread,1,lru_maintainer_thread,void* lru_maintainer_thread (void*),items.c,"static void *lru_maintainer_thread(void *arg) {
    slab_automove_reg_t *sam = &slab_automove_default;
#ifdef EXTSTORE
    void *storage = arg;
    if (storage != NULL)
        sam = &slab_automove_extstore;
#endif
    int i;
    useconds_t to_sleep = MIN_LRU_MAINTAINER_SLEEP;
    useconds_t last_sleep = MIN_LRU_MAINTAINER_SLEEP;
    rel_time_t last_crawler_check = 0;
    rel_time_t last_automove_check = 0;
    useconds_t next_juggles[MAX_NUMBER_OF_SLAB_CLASSES] = {0};
    useconds_t backoff_juggles[MAX_NUMBER_OF_SLAB_CLASSES] = {0};
    struct crawler_expired_data *cdata =
        calloc(1, sizeof(struct crawler_expired_data));
    if (cdata == NULL) {
        fprintf(stderr, ""Failed to allocate crawler data for LRU maintainer thread\n"");
        abort();
    }
    pthread_mutex_init(&cdata->lock, NULL);
    cdata->crawl_complete = true; // kick off the crawler.
    logger *l = logger_create();
    if (l == NULL) {
        fprintf(stderr, ""Failed to allocate logger for LRU maintain...",1585.0,1704.0,1.0,26.0,120.0,112,22,134,29,0,30,21,46,8,6,,0,25,2,1,1,void*
1474,18224,stop_lru_maintainer_thread,1,stop_lru_maintainer_thread,int stop_lru_maintainer_thread (void),items.c,"int stop_lru_maintainer_thread(void) {
    int ret;
    pthread_mutex_lock(&lru_maintainer_lock);
    /* LRU thread is a sleep loop, will die on its own */
    do_run_lru_maintainer_thread = 0;
    pthread_mutex_unlock(&lru_maintainer_lock);
    if ((ret = pthread_join(lru_maintainer_tid, NULL)) != 0) {
        fprintf(stderr, ""Failed to stop LRU maintainer thread: %s\n"", strerror(ret));
        return -1;
    }
    settings.lru_maintainer_thread = false;
    return 0;
}",1706.0,1718.0,1.0,1.0,13.0,8,5,10,8,0,5,2,2,1,0,,0,5,2,1,1,int
1475,18263,start_lru_maintainer_thread,1,start_lru_maintainer_thread,int start_lru_maintainer_thread (void*),items.c,"int start_lru_maintainer_thread(void *arg) {
    int ret;

    pthread_mutex_lock(&lru_maintainer_lock);
    do_run_lru_maintainer_thread = 1;
    settings.lru_maintainer_thread = true;
    if ((ret = pthread_create(&lru_maintainer_tid, NULL,
        lru_maintainer_thread, arg)) != 0) {
        fprintf(stderr, ""Can't create LRU maintainer thread: %s\n"",
            strerror(ret));
        pthread_mutex_unlock(&lru_maintainer_lock);
        return -1;
    }
    pthread_mutex_unlock(&lru_maintainer_lock);

    return 0;
}",1720.0,1736.0,1.0,1.0,17.0,10,5,12,9,1,6,2,2,1,0,,0,6,2,1,1,int
1476,18308,lru_maintainer_pause,1,lru_maintainer_pause,void lru_maintainer_pause (void),items.c,"void lru_maintainer_pause(void) {
    pthread_mutex_lock(&lru_maintainer_lock);
}",1739.0,1741.0,1.0,1.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,void
1477,18316,lru_maintainer_resume,1,lru_maintainer_resume,void lru_maintainer_resume (void),items.c,"void lru_maintainer_resume(void) {
    pthread_mutex_unlock(&lru_maintainer_lock);
}",1743.0,1745.0,1.0,1.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,void
1478,18324,init_lru_maintainer,1,init_lru_maintainer,int init_lru_maintainer (void),items.c,"int init_lru_maintainer(void) {
    lru_maintainer_initialized = 1;
    return 0;
}",1747.0,1750.0,1.0,1.0,4.0,1,1,1,1,1,1,1,1,0,0,,0,1,2,1,1,int
1479,18334,do_item_linktail_q,1,do_item_linktail_q,void do_item_linktail_q (item*),items.c,"void do_item_linktail_q(item *it) { /* item is the new tail */
    item **head, **tail;
    assert(it->it_flags == 1);
    assert(it->nbytes == 0);

    head = &heads[it->slabs_clsid];
    tail = &tails[it->slabs_clsid];
    //assert(*tail != 0);
    assert(it != *tail);
    assert((*head && *tail) || (*head == 0 && *tail == 0));
    it->prev = *tail;
    it->next = 0;
    if (it->prev) {
        assert(it->prev->next == 0);
        it->prev->next = it;
    }
    *tail = it;
    if (*head == 0) *head = it;
    return;
}",1753.0,1772.0,1.0,1.0,20.0,41,9,26,5,1,2,3,3,0,0,,0,2,2,1,1,void
1480,18436,do_item_unlinktail_q,1,do_item_unlinktail_q,void do_item_unlinktail_q (item*),items.c,"void do_item_unlinktail_q(item *it) {
    item **head, **tail;
    head = &heads[it->slabs_clsid];
    tail = &tails[it->slabs_clsid];

    if (*head == it) {
        assert(it->prev == 0);
        *head = it->next;
    }
    if (*tail == it) {
        assert(it->next == 0);
        *tail = it->prev;
    }
    assert(it->next != it);
    assert(it->prev != it);

    if (it->next) it->next->prev = it->prev;
    if (it->prev) it->prev->next = it->next;
    return;
}",1774.0,1793.0,1.0,1.0,20.0,36,7,26,5,1,2,5,5,0,0,,0,2,2,1,1,void
1481,18536,do_item_crawl_q,1,do_item_crawl_q,item do_item_crawl_q (item*),items.c,"item *do_item_crawl_q(item *it) {
    item **head, **tail;
    assert(it->it_flags == 1);
    assert(it->nbytes == 0);
    head = &heads[it->slabs_clsid];
    tail = &tails[it->slabs_clsid];

    /* We've hit the head, pop off */
    if (it->prev == 0) {
        assert(*head == it);
        if (it->next) {
            *head = it->next;
            assert(it->next->prev == it);
            it->next->prev = 0;
        }
        return NULL; /* Done */
    }

    /* Swing ourselves in front of the next item */
    /* NB: If there is a prev, we can't be the head */
    assert(it->prev != it);
    if (it->prev) {
        if (*head == it->prev) {
            /* Prev was the head, now we're the head */
            *head = it;
        }
        if (*tail == it) {
            /* We are the tail, now they are the tail */
            *tail = it->prev;
        }
        assert(it->next != it);
        if (it->next) {
            assert(it->prev->next == it);
            it->prev->next = it->nex...",1797.0,1849.0,1.0,1.0,53.0,72,7,52,6,0,2,8,13,0,0,,0,2,2,1,1,item
1482,18819,do_item_update_nolock,1,do_item_update_nolock,void do_item_update_nolock (item*),items.h,void do_item_update_nolock(item *it);,25.0,25.0,6.0,36.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
1483,19012,lru_bump_buf_create,1,lru_bump_buf_create,void* lru_bump_buf_create (void),items.h,void *lru_bump_buf_create(void);,86.0,86.0,6.0,31.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void*
1484,19030,out2,1,out2,"char* out2 (int,char*)",itoa_ljust.c,"static inline char* out2(const int d, char* p) {
    memcpy(p, &((uint16_t *)lut)[d], 2);
    return p + 2;
}",73.0,76.0,1.0,1.0,4.0,4,4,4,3,5,1,1,1,0,0,,0,1,4,2,2,char*
1485,19049,out1,1,out1,"char* out1 (char,char*)",itoa_ljust.c,"static inline char* out1(const char in, char* p) {
    memcpy(p, &in, 1);
    return p + 1;
}",78.0,81.0,1.0,1.0,4.0,2,2,3,2,2,0,1,1,0,0,,0,0,4,2,2,char*
1486,19064,digits,1,digits,"int digits (uint32_t,unsigned,int*,char**,int)",itoa_ljust.c,"static inline int digits( uint32_t u, unsigned k, int* d, char** p, int n ) {
    if (u < k*10) {
        *d = u / k;
        *p = out1('0'+*d, *p);
        --n;
    }
    return n;
}",83.0,90.0,1.0,1.0,8.0,11,7,10,5,1,1,2,2,0,1,,0,1,10,5,5,int
1487,19100,itoa,1,itoa,"char* itoa (uint32_t,char*,int,int)",itoa_ljust.c,"static inline char* itoa(uint32_t u, char* p, int d, int n) {
    switch(n) {
    case 10: d  = u / 100000000; p = out2( d, p );
    case  9: u -= d * 100000000;
    case  8: d  = u /   1000000; p = out2( d, p );
    case  7: u -= d *   1000000;
    case  6: d  = u /     10000; p = out2( d, p );
    case  5: u -= d *     10000;
    case  4: d  = u /       100; p = out2( d, p );
    case  3: u -= d *       100;
    case  2: d  = u /         1; p = out2( d, p );
    case  1: ;
    }
    *p = '\0';
    return p;
}",92.0,107.0,1.0,1.0,16.0,25,5,36,4,2,5,2,2,0,5,,0,5,8,4,4,char*
1488,19207,itoa_u32,1,itoa_u32,"char* itoa_u32 (uint32_t,char*)",itoa_ljust.c,"char* itoa_u32(uint32_t u, char* p) {
    int d = 0,n;
         if (u >=100000000) n = digits(u, 100000000, &d, &p, 10);
    else if (u <       100) n = digits(u,         1, &d, &p,  2);
    else if (u <     10000) n = digits(u,       100, &d, &p,  4);
    else if (u <   1000000) n = digits(u,     10000, &d, &p,  6);
    else                    n = digits(u,   1000000, &d, &p,  8);
    return itoa( u, p, d, n );
}",109.0,117.0,1.0,1.0,9.0,5,3,10,4,7,2,2,2,0,2,,0,1,4,2,2,char*
1489,19302,itoa_32,1,itoa_32,"char* itoa_32 (int32_t,char*)",itoa_ljust.c,"char* itoa_32(int32_t i, char* p) {
    uint32_t u = i;
    if (i < 0) {
        *p++ = '-';
        u = -u;
    }
    return itoa_u32(u, p);
}",119.0,126.0,1.0,1.0,8.0,7,5,8,3,0,1,2,2,0,1,,0,0,4,2,2,char*
1490,19330,itoa_u64,1,itoa_u64,"char* itoa_u64 (uint64_t,char*)",itoa_ljust.c,"char* itoa_u64(uint64_t u, char* p) {
    int d;

    uint32_t lower = (uint32_t)u;
    if (lower == u) return itoa_u32(lower, p);

    uint64_t upper = u / 1000000000;
    p = itoa_u64(upper, p);
    lower = u - (upper * 1000000000);
    d = lower / 100000000;
    p = out1('0'+d,p);
    return itoa( lower, p, d, 9 );
}",128.0,140.0,1.0,1.0,13.0,13,7,22,5,7,3,2,2,0,3,,0,1,4,2,2,char*
1491,19388,itoa_64,1,itoa_64,"char* itoa_64 (int64_t,char*)",itoa_ljust.c,"char* itoa_64(int64_t i, char* p) {
    uint64_t u = i;
    if (i < 0) {
        *p++ = '-';
        u = -u;
    }
    return itoa_u64(u, p);
}",142.0,149.0,1.0,1.0,8.0,7,5,8,3,0,1,2,2,0,1,,0,0,4,2,2,char*
1492,19461,jenkins_hash,1,jenkins_hash,"uint32_t jenkins_hash (void*,size_t)",jenkins_hash.h,"uint32_t jenkins_hash(const void *key, size_t length);",8.0,8.0,10.0,53.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,uint32_t
1493,19491,handle_syssig,1,handle_syssig,"void handle_syssig (int,siginfo_t*,void*)",linux_priv.c,"static void handle_syssig(int signum, siginfo_t *si, void *thread_context) {
#if defined(si_syscall)
    int syscall_no = si->si_syscall;
#else
    // If system has no support for si_syscal, the information may not be
    // precise.
    int syscall_no = si->si_value.sival_int;
#endif

    // Replace the characters in the kill message with the syscall number. We
    // can't safely printf (even write is not really valid, but we're crashing
    // anyway).

    kill_msg[39] = (syscall_no / 100) % 10 + '0';
    kill_msg[40] = (syscall_no / 10) % 10 + '0';
    kill_msg[41] = syscall_no % 10 + '0';
    if (write(2, kill_msg, strlen(kill_msg)) == -1) {
        // An error occurred, but we can't do anything about it here. This check
        // is mostly to avoid the ""ignoring return value of 'write'"" error on
        // distributions with broken gcc (no ""ignore via cast to void"" support).
    }

    // We can't use the nice exit() version because it causes at_exit handlers
    // to be lo...",17.0,43.0,1.0,1.0,27.0,19,9,11,4,0,5,2,2,2,0,,0,5,6,3,3,void
1494,19633,logger_thread_poll_watchers,1,logger_thread_poll_watchers,"int logger_thread_poll_watchers (int,int)",logger.c,"static int logger_thread_poll_watchers(int force_poll, int watcher) {
    int x;
    int nfd = 0;
    unsigned char *data;
    unsigned int data_size = 0;
    int flushed = 0;

    for (x = 0; x < WATCHER_LIMIT; x++) {
        logger_watcher *w = watchers[x];
        if (w == NULL || (watcher != WATCHER_ALL && x != watcher))
            continue;

        data = bipbuf_peek_all(w->buf, &data_size);
        if (data != NULL) {
            watchers_pollfds[nfd].fd = w->sfd;
            watchers_pollfds[nfd].events = POLLOUT;
            nfd++;
        } else if (force_poll) {
            watchers_pollfds[nfd].fd = w->sfd;
            watchers_pollfds[nfd].events = POLLIN;
            nfd++;
        }
        /* This gets set after a call to poll, and should be used to gate on
         * calling poll again.
         */
        w->failed_flush = false;
    }

    if (nfd == 0)
        return 0;

    //L_DEBUG(""LOGGER: calling poll() [data_size: %d]\n"", data_size);
    int ret = poll(wat...",656.0,750.0,1.0,20.0,95.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,int
1495,19639,_logger_log_text,1,_logger_log_text,"void _logger_log_text (logentry*,entry_details*,void*,va_list)",logger.c,"static void _logger_log_text(logentry *e, const entry_details *d, const void *entry, va_list ap) {
    int reqlen = d->reqlen;
    int total = vsnprintf((char *) e->data, reqlen, d->format, ap);
    if (total <= 0) {
        fprintf(stderr, ""LOGGER: Failed to vsnprintf a text entry: (total) %d\n"", total);
    }
    e->size = total + 1; // null byte
}",54.0,61.0,1.0,1.0,8.0,10,5,12,6,0,0,2,2,0,0,,0,0,8,4,4,void
1496,19683,_logger_log_evictions,1,_logger_log_evictions,"void _logger_log_evictions (logentry*,entry_details*,void*,va_list)",logger.c,"static void _logger_log_evictions(logentry *e, const entry_details *d, const void *entry, va_list ap) {
    item *it = (item *)entry;
    struct logentry_eviction *le = (struct logentry_eviction *) e->data;

    le->exptime = (it->exptime > 0) ? (long long int)(it->exptime - current_time) : (long long int) -1;
    le->latime = current_time - it->time;
    le->it_flags = it->it_flags;
    le->nkey = it->nkey;
    le->nbytes = it->nbytes;
    le->clsid = ITEM_clsid(it);
    memcpy(le->key, ITEM_key(it), it->nkey);
    e->size = sizeof(struct logentry_eviction) + le->nkey;
}",63.0,75.0,1.0,16.0,13.0,49,13,29,7,0,8,1,1,0,0,,0,8,8,4,4,void
1497,19807,_logger_log_item_get,1,_logger_log_item_get,"void _logger_log_item_get (logentry*,entry_details*,void*,va_list)",logger.c,"static void _logger_log_item_get(logentry *e, const entry_details *d, const void *entry, va_list ap) {
    int was_found = va_arg(ap, int);
    char *key = va_arg(ap, char *);
    int nkey = va_arg(ap, int);
    int nbytes = va_arg(ap, int);
    uint8_t clsid = va_arg(ap, int);
    int sfd = va_arg(ap, int);

    struct logentry_item_get *le = (struct logentry_item_get *) e->data;
    le->was_found = was_found;
    le->nkey = nkey;
    le->nbytes = nbytes;
    le->clsid = clsid;
    memcpy(le->key, key, nkey);
    le->sfd = sfd;
    e->size = sizeof(struct logentry_item_get) + nkey;
}",96.0,112.0,1.0,1.0,17.0,18,5,19,10,0,6,1,1,0,0,,0,6,8,4,4,void
1498,19870,_logger_log_item_store,1,_logger_log_item_store,"void _logger_log_item_store (logentry*,entry_details*,void*,va_list)",logger.c,"static void _logger_log_item_store(logentry *e, const entry_details *d, const void *entry, va_list ap) {
    enum store_item_type status = va_arg(ap, enum store_item_type);
    int comm = va_arg(ap, int);
    char *key = va_arg(ap, char *);
    int nkey = va_arg(ap, int);
    int nbytes = va_arg(ap, int);
    rel_time_t ttl = va_arg(ap, rel_time_t);
    uint8_t clsid = va_arg(ap, int);
    int sfd = va_arg(ap, int);

    struct logentry_item_store *le = (struct logentry_item_store *) e->data;
    le->status = status;
    le->cmd = comm;
    le->nkey = nkey;
    le->nbytes = nbytes;
    le->clsid = clsid;
    if (ttl != 0) {
        le->ttl = ttl - current_time;
    } else {
        le->ttl = 0;
    }
    memcpy(le->key, key, nkey);
    le->sfd = sfd;
    e->size = sizeof(struct logentry_item_store) + nkey;
}",114.0,138.0,1.0,1.0,25.0,25,7,28,15,0,8,2,2,0,0,,0,8,8,4,4,void
1499,19965,_logger_log_conn_event,1,_logger_log_conn_event,"void _logger_log_conn_event (logentry*,entry_details*,void*,va_list)",logger.c,"static void _logger_log_conn_event(logentry *e, const entry_details *d, const void *entry, va_list ap) {
    struct sockaddr_in6 *addr = va_arg(ap, struct sockaddr_in6 *);
    socklen_t addrlen = va_arg(ap, socklen_t);
    enum network_transport transport = va_arg(ap, enum network_transport);
    enum close_reasons reason = va_arg(ap, enum close_reasons);
    int sfd = va_arg(ap, int);

    struct logentry_conn_event *le = (struct logentry_conn_event *) e->data;

    memcpy(&le->addr, addr, addrlen);
    le->sfd = sfd;
    le->transport = transport;
    le->reason = reason;
    e->size = sizeof(struct logentry_conn_event);
}",140.0,154.0,1.0,1.0,15.0,15,5,16,10,0,4,1,1,0,0,,0,4,8,4,4,void
1500,20022,_logger_util_addr_endpoint,1,_logger_util_addr_endpoint,"int _logger_util_addr_endpoint (sockaddr_in6*,char*,size_t,short unsigned*)",logger.c,"static int _logger_util_addr_endpoint(struct sockaddr_in6 *addr, char *rip,
        size_t riplen, unsigned short *rport) {
    memset(rip, 0, riplen);

    switch (addr->sin6_family) {
        case AF_INET:
            inet_ntop(AF_INET, &((struct sockaddr_in *) addr)->sin_addr,
                    rip, riplen - 1);
            *rport = ntohs(((struct sockaddr_in *) addr)->sin_port);
            break;
        case AF_INET6:
            inet_ntop(AF_INET6, &((struct sockaddr_in6 *) addr)->sin6_addr,
                    rip, riplen - 1);
            *rport = ntohs(((struct sockaddr_in6 *) addr)->sin6_port);
            break;
#ifndef DISABLE_UNIX_SOCKET
        // Connections on Unix socket transports have c->request_addr zeroed out.
        case AF_UNSPEC:
        case AF_UNIX:
            strncpy(rip, ""unix"", strlen(""unix"") + 1);
            *rport = 0;
            break;
#endif // #ifndef DISABLE_UNIX_SOCKET
    }

    return 0;
}",160.0,186.0,1.0,1.0,27.0,20,7,21,8,2,0,5,2,0,0,,0,0,8,4,4,int
1501,20105,_logger_parse_text,1,_logger_parse_text,"int _logger_parse_text (logentry*,char*)",logger.c,"static int _logger_parse_text(logentry *e, char *scratch) {
    return snprintf(scratch, LOGGER_PARSE_SCRATCH, ""ts=%d.%d gid=%llu %s\n"",
            (int)e->tv.tv_sec, (int)e->tv.tv_usec,
            (unsigned long long) e->gid, (char *) e->data);
}",195.0,199.0,1.0,29.0,5.0,10,3,5,2,0,0,1,1,0,0,,0,0,4,2,2,int
1502,20142,_logger_parse_ise,1,_logger_parse_ise,"int _logger_parse_ise (logentry*,char*)",logger.c,"static int _logger_parse_ise(logentry *e, char *scratch) {
    int total;
    const char *cmd = ""na"";
    char keybuf[KEY_MAX_URI_ENCODED_LENGTH];
    struct logentry_item_store *le = (struct logentry_item_store *) e->data;
    const char * const status_map[] = {
        ""not_stored"", ""stored"", ""exists"", ""not_found"", ""too_large"", ""no_memory"" };
    const char * const cmd_map[] = {
        ""null"", ""add"", ""set"", ""replace"", ""append"", ""prepend"", ""cas"" };

    if (le->cmd <= 6)
        cmd = cmd_map[le->cmd];

    uriencode(le->key, keybuf, le->nkey, KEY_MAX_URI_ENCODED_LENGTH);
    total = snprintf(scratch, LOGGER_PARSE_SCRATCH,
            ""ts=%d.%d gid=%llu type=item_store key=%s status=%s cmd=%s ttl=%u clsid=%u cfd=%d size=%d\n"",
            (int)e->tv.tv_sec, (int)e->tv.tv_usec, (unsigned long long) e->gid,
            keybuf, status_map[le->status], cmd, le->ttl, le->clsid, le->sfd,
            le->nbytes > 0 ? le->nbytes - 2 : 0); // CLRF
    return total;
}",201.0,221.0,1.0,16.0,21.0,36,12,27,8,0,11,2,2,1,1,,0,10,4,2,2,int
1503,20269,_logger_parse_ige,1,_logger_parse_ige,"int _logger_parse_ige (logentry*,char*)",logger.c,"static int _logger_parse_ige(logentry *e, char *scratch) {
    int total;
    struct logentry_item_get *le = (struct logentry_item_get *) e->data;
    char keybuf[KEY_MAX_URI_ENCODED_LENGTH];
    const char * const was_found_map[] = {
        ""not_found"", ""found"", ""flushed"", ""expired"" };

    uriencode(le->key, keybuf, le->nkey, KEY_MAX_URI_ENCODED_LENGTH);
    total = snprintf(scratch, LOGGER_PARSE_SCRATCH,
            ""ts=%d.%d gid=%llu type=item_get key=%s status=%s clsid=%u cfd=%d size=%d\n"",
            (int)e->tv.tv_sec, (int)e->tv.tv_usec, (unsigned long long) e->gid,
            keybuf, was_found_map[le->was_found], le->clsid, le->sfd,
            le->nbytes > 0 ? le->nbytes - 2 : 0); // CLRF
    return total;
}",223.0,237.0,1.0,16.0,15.0,27,11,19,6,0,8,1,1,0,1,,0,7,4,2,2,int
1504,20361,_logger_parse_ee,1,_logger_parse_ee,"int _logger_parse_ee (logentry*,char*)",logger.c,"static int _logger_parse_ee(logentry *e, char *scratch) {
    int total;
    char keybuf[KEY_MAX_URI_ENCODED_LENGTH];
    struct logentry_eviction *le = (struct logentry_eviction *) e->data;
    uriencode(le->key, keybuf, le->nkey, KEY_MAX_URI_ENCODED_LENGTH);
    total = snprintf(scratch, LOGGER_PARSE_SCRATCH,
            ""ts=%d.%d gid=%llu type=eviction key=%s fetch=%s ttl=%lld la=%d clsid=%u size=%d\n"",
            (int)e->tv.tv_sec, (int)e->tv.tv_usec, (unsigned long long) e->gid,
            keybuf, (le->it_flags & ITEM_FETCHED) ? ""yes"" : ""no"",
            (long long int)le->exptime, le->latime, le->clsid,
            le->nbytes > 0 ? le->nbytes - 2 : 0); // CLRF

    return total;
}",239.0,252.0,1.0,16.0,14.0,28,10,18,5,0,9,1,1,0,1,,0,8,4,2,2,int
1505,20455,_logger_parse_cne,1,_logger_parse_cne,"int _logger_parse_cne (logentry*,char*)",logger.c,"static int _logger_parse_cne(logentry *e, char *scratch) {
    int total;
    unsigned short rport;
    char rip[64];
    struct logentry_conn_event *le = (struct logentry_conn_event *) e->data;
    const char * const transport_map[] = { ""local"", ""tcp"", ""udp"" };

    _logger_util_addr_endpoint(&le->addr, rip, sizeof(rip), &rport);

    total = snprintf(scratch, LOGGER_PARSE_SCRATCH,
            ""ts=%d.%d gid=%llu type=conn_new rip=%s rport=%hu transport=%s cfd=%d\n"",
            (int) e->tv.tv_sec, (int) e->tv.tv_usec, (unsigned long long) e->gid,
            rip, rport, transport_map[le->transport], le->sfd);

    return total;
}",270.0,285.0,1.0,30.0,16.0,21,8,18,7,0,4,1,1,0,1,,0,3,4,2,2,int
1506,20528,_logger_parse_cce,1,_logger_parse_cce,"int _logger_parse_cce (logentry*,char*)",logger.c,"static int _logger_parse_cce(logentry *e, char *scratch) {
    int total;
    unsigned short rport;
    char rip[64];
    struct logentry_conn_event *le = (struct logentry_conn_event *) e->data;
    const char * const transport_map[] = { ""local"", ""tcp"", ""udp"" };
    const char * const reason_map[] = { ""error"", ""normal"", ""idle_timeout"", ""shutdown"" };

    _logger_util_addr_endpoint(&le->addr, rip, sizeof(rip), &rport);

    total = snprintf(scratch, LOGGER_PARSE_SCRATCH,
            ""ts=%d.%d gid=%llu type=conn_close rip=%s rport=%hu transport=%s reason=%s cfd=%d\n"",
            (int) e->tv.tv_sec, (int) e->tv.tv_usec, (unsigned long long) e->gid,
            rip, rport, transport_map[le->transport],
            reason_map[le->reason], le->sfd);

    return total;
}",287.0,304.0,1.0,30.0,18.0,25,8,21,8,0,5,1,1,0,1,,0,4,4,2,2,int
1507,20726,logger_get_gid,1,logger_get_gid,uint64_t logger_get_gid (void),logger.c,"uint64_t logger_get_gid(void) {
#ifdef HAVE_GCC_64ATOMICS
    return __sync_add_and_fetch(&logger_gid, 1);
#elif defined(__sun)
    return atomic_inc_64_nv(&logger_gid);
#else
    mutex_lock(&logger_atomics_mutex);
    uint64_t res = ++logger_gid;
    mutex_unlock(&logger_atomics_mutex);
    return res;
#endif
}",431.0,442.0,1.0,4.0,12.0,6,3,7,3,3,5,1,1,0,0,,0,5,2,1,1,uint64_t
1508,20752,logger_set_gid,1,logger_set_gid,void logger_set_gid (uint64_t),logger.c,"void logger_set_gid(uint64_t gid) {
#ifdef HAVE_GCC_64ATOMICS
    __sync_add_and_fetch(&logger_gid, gid);
#elif defined(__sun)
    atomic_add_64(&logger_gid);
#else
    mutex_lock(&logger_atomics_mutex);
    logger_gid = gid;
    mutex_unlock(&logger_atomics_mutex);
#endif
}",444.0,454.0,1.0,4.0,11.0,5,2,6,3,0,5,1,1,0,0,,0,5,2,1,1,void
1509,20774,logger_link_q,1,logger_link_q,void logger_link_q (logger*),logger.c,"static void logger_link_q(logger *l) {
    pthread_mutex_lock(&logger_stack_lock);
    assert(l != logger_stack_head);

    l->prev = 0;
    l->next = logger_stack_head;
    if (l->next) l->next->prev = l;
    logger_stack_head = l;
    if (logger_stack_tail == 0) logger_stack_tail = l;
    logger_count++;
    pthread_mutex_unlock(&logger_stack_lock);
    return;
}",460.0,472.0,1.0,1.0,13.0,15,6,16,5,1,8,3,3,1,0,,0,8,2,1,1,void
1510,20825,logger_set_flags,1,logger_set_flags,void logger_set_flags (void),logger.c,"static void logger_set_flags(void) {
    logger *l = NULL;
    int x = 0;
    uint16_t f = 0; /* logger eflags */

    for (x = 0; x < WATCHER_LIMIT; x++) {
        logger_watcher *w = watchers[x];
        if (w == NULL)
            continue;

        f |= w->eflags;
    }
    for (l = logger_stack_head; l != NULL; l=l->next) {
        pthread_mutex_lock(&l->mutex);
        l->eflags = f;
        pthread_mutex_unlock(&l->mutex);
    }
    return;
}",498.0,516.0,1.0,20.0,19.0,17,7,21,7,2,3,5,5,0,0,,0,3,2,1,1,void
1511,20902,logger_thread_parse_entry,1,logger_thread_parse_entry,"enum logger_parse_entry_ret logger_thread_parse_entry (logentry*,logger_stats*,char*,int*)",logger.c,"static enum logger_parse_entry_ret logger_thread_parse_entry(logentry *e, struct logger_stats *ls,
        char *scratch, int *scratch_len) {
    int total = 0;
    const entry_details *d = &default_entries[e->event];
    assert(d->parse_cb != NULL);
    total = d->parse_cb(e, scratch);

    if (total >= LOGGER_PARSE_SCRATCH || total <= 0) {
        L_DEBUG(""LOGGER: Failed to flatten log entry!\n"");
        return LOGGER_PARSE_ENTRY_FAILED;
    } else {
        *scratch_len = total;
    }

    return LOGGER_PARSE_ENTRY_OK;
}",519.0,534.0,1.0,17.0,16.0,12,8,14,8,1,1,2,2,0,0,,0,1,8,4,4,enum logger_parse_entry_ret
1512,20958,logger_thread_write_entry,1,logger_thread_write_entry,"void logger_thread_write_entry (logentry*,logger_stats*,char*,int)",logger.c,"static void logger_thread_write_entry(logentry *e, struct logger_stats *ls,
        char *scratch, int scratch_len) {
    int x, total;
    /* Write the line into available watchers with matching flags */
    for (x = 0; x < WATCHER_LIMIT; x++) {
        logger_watcher *w = watchers[x];
        char *skip_scr = NULL;
        if (w == NULL || (e->eflags & w->eflags) == 0 || (e->gid < w->min_gid))
            continue;

         /* Avoid poll()'ing constantly when buffer is full by resetting a
         * flag periodically.
         */
        while (!w->failed_flush &&
                (skip_scr = (char *) bipbuf_request(w->buf, scratch_len + 128)) == NULL) {
            if (logger_thread_poll_watchers(0, x) <= 0) {
                L_DEBUG(""LOGGER: Watcher had no free space for line of size (%d)\n"", scratch_len + 128);
                w->failed_flush = true;
            }
        }

        if (w->failed_flush) {
            L_DEBUG(""LOGGER: Fast skipped for watcher [%d] due to failed_...",537.0,580.0,1.0,20.0,44.0,50,15,39,11,0,21,11,16,8,4,,0,19,8,4,4,void
1513,21119,logger_thread_close_watcher,1,logger_thread_close_watcher,void logger_thread_close_watcher (logger_watcher*),logger.c,"static void logger_thread_close_watcher(logger_watcher *w) {
    L_DEBUG(""LOGGER: Closing dead watcher\n"");
    watchers[w->id] = NULL;
    sidethread_conn_close(w->c);
    watcher_count--;
    bipbuf_free(w->buf);
    free(w);
    logger_set_flags();
}",587.0,595.0,1.0,4.0,9.0,6,4,7,4,0,8,1,1,0,3,,0,5,2,1,1,void
1514,21144,logger_thread_read,1,logger_thread_read,"int logger_thread_read (logger*,logger_stats*)",logger.c,"static int logger_thread_read(logger *l, struct logger_stats *ls) {
    unsigned int size;
    unsigned int pos = 0;
    unsigned char *data;
    char scratch[LOGGER_PARSE_SCRATCH];
    logentry *e;
    pthread_mutex_lock(&l->mutex);
    data = bipbuf_peek_all(l->buf, &size);
    pthread_mutex_unlock(&l->mutex);

    if (data == NULL) {
        return 0;
    }
    L_DEBUG(""LOGGER: Got %d bytes from bipbuffer\n"", size);

    /* parse buffer */
    while (pos < size && watcher_count > 0) {
        enum logger_parse_entry_ret ret;
        int scratch_len = 0;
        e = (logentry *) (data + pos);
        ret = logger_thread_parse_entry(e, ls, scratch, &scratch_len);
        if (ret != LOGGER_PARSE_ENTRY_OK) {
            /* TODO: stats counter */
            fprintf(stderr, ""LOGGER: Failed to parse log entry\n"");
        } else {
            logger_thread_write_entry(e, ls, scratch, scratch_len);
        }
        pos += sizeof(logentry) + e->size + e->pad;
    }
    assert(pos <= siz...",600.0,643.0,1.0,17.0,44.0,43,13,44,14,1,6,5,6,1,3,,0,6,4,2,2,int
1515,21639,logger_thread_flush_stats,1,logger_thread_flush_stats,void logger_thread_flush_stats (logger_stats*),logger.c,"static void logger_thread_flush_stats(struct logger_stats *ls) {
    STATS_LOCK();
    stats.log_worker_dropped  += ls->worker_dropped;
    stats.log_worker_written  += ls->worker_written;
    stats.log_watcher_skipped += ls->watcher_skipped;
    stats.log_watcher_sent    += ls->watcher_sent;
    stats_state.log_watchers   = ls->watcher_count;
    STATS_UNLOCK();
}",752.0,760.0,1.0,1.0,9.0,15,4,10,3,1,12,1,1,0,0,,0,10,2,1,1,void
1516,21681,logger_thread,1,logger_thread,void* logger_thread (void*),logger.c,"static void *logger_thread(void *arg) {
    useconds_t to_sleep = MIN_LOGGER_SLEEP;
    L_DEBUG(""LOGGER: Starting logger thread\n"");
    // TODO: If we ever have item references in the logger code, will need to
    // ensure everything is dequeued before stopping the thread.
    while (do_run_logger_thread) {
        int found_logs = 0;
        logger *l;
        struct logger_stats ls;
        memset(&ls, 0, sizeof(struct logger_stats));

        /* only sleep if we're *above* the minimum */
        if (to_sleep > MIN_LOGGER_SLEEP)
            usleep(to_sleep);

        /* Call function to iterate each logger. */
        pthread_mutex_lock(&logger_stack_lock);
        if (watcher_count == 0) {
            // Not bothering to loop on the condition here since it's fine to
            // walk through with zero watchers.
            pthread_cond_wait(&logger_stack_cond, &logger_stack_lock);
        }
        for (l = logger_stack_head; l != NULL; l=l->next) {
            /* lock logger...",766.0,815.0,1.0,26.0,50.0,24,12,29,11,0,12,8,16,2,3,,0,9,2,1,1,void*
1517,21813,start_logger_thread,1,start_logger_thread,int start_logger_thread (void),logger.c,"static int start_logger_thread(void) {
    int ret;
    do_run_logger_thread = 1;
    if ((ret = pthread_create(&logger_tid, NULL,
                              logger_thread, NULL)) != 0) {
        fprintf(stderr, ""Can't start logger thread: %s\n"", strerror(ret));
        return -1;
    }
    return 0;
}",817.0,826.0,1.0,1.0,10.0,5,4,7,5,1,2,2,2,1,0,,0,2,2,1,1,int
1518,21844,stop_logger_thread,1,stop_logger_thread,int stop_logger_thread (void),logger.c,"static int stop_logger_thread(void) {
    // Guarantees that the logger thread is waiting on 'logger_stack_cond'
    // before we signal it.
    pthread_mutex_lock(&logger_stack_lock);
    do_run_logger_thread = 0;
    pthread_cond_signal(&logger_stack_cond);
    pthread_mutex_unlock(&logger_stack_lock);
    pthread_join(logger_tid, NULL);
    return 0;
}",828.0,837.0,1.0,1.0,10.0,4,2,6,5,1,5,1,1,0,0,,0,5,2,1,1,int
1519,21866,logger_init,1,logger_init,void logger_init (void),logger.c,"void logger_init(void) {
    /* TODO: auto destructor when threads exit */
    /* TODO: error handling */

    /* init stack for iterating loggers */
    logger_stack_head = 0;
    logger_stack_tail = 0;
    pthread_key_create(&logger_key, NULL);

    if (start_logger_thread() != 0) {
        abort();
    }

    /* This is what adding a STDERR watcher looks like. should replace old
     * ""verbose"" settings. */
    //logger_add_watcher(NULL, 0);
    return;
}",844.0,861.0,1.0,1.0,18.0,4,3,4,4,1,4,2,2,1,1,,0,4,2,1,1,void
1520,21888,logger_stop,1,logger_stop,void logger_stop (void),logger.c,"void logger_stop(void) {
    stop_logger_thread();
}",863.0,865.0,1.0,1.0,3.0,0,0,0,0,0,1,1,1,0,1,,0,0,2,1,1,void
1521,21894,logger_create,1,logger_create,logger logger_create (void),logger.c,"logger *logger_create(void) {
    L_DEBUG(""LOGGER: Creating and linking new logger instance\n"");
    logger *l = calloc(1, sizeof(logger));
    if (l == NULL) {
        return NULL;
    }

    l->buf = bipbuf_new(settings.logger_buf_size);
    if (l->buf == NULL) {
        free(l);
        return NULL;
    }

    l->entry_map = default_entries;

    pthread_mutex_init(&l->mutex, NULL);
    pthread_setspecific(logger_key, l);

    /* add to list of loggers */
    logger_link_q(l);
    return l;
}",870.0,891.0,1.0,4.0,22.0,12,6,19,6,3,5,3,3,0,2,,0,4,2,1,1,logger
1522,21950,logger_log,1,logger_log,"enum logger_ret_type logger_log (logger*,log_entry_type,void*...)",logger.c,"enum logger_ret_type logger_log(logger *l, const enum log_entry_type event, const void *entry, ...) {
    bipbuf_t *buf = l->buf;
    bool nospace = false;
    va_list ap;
    logentry *e;

    const entry_details *d = &l->entry_map[event];
    int reqlen = d->reqlen;

    pthread_mutex_lock(&l->mutex);
    /* Request a maximum length of data to write to */
    e = (logentry *) bipbuf_request(buf, (sizeof(logentry) + reqlen));
    if (e == NULL) {
        pthread_mutex_unlock(&l->mutex);
        l->dropped++;
        return LOGGER_RET_NOSPACE;
    }
    e->event = event;
    e->pad = 0;
    e->gid = logger_get_gid();
    /* TODO: Could pass this down as an argument now that we're using
     * LOGGER_LOG() macro.
     */
    e->eflags = d->eflags;
    /* Noting time isn't optional. A feature may be added to avoid rendering
     * time and/or gid to a logger.
     */
    gettimeofday(&e->tv, NULL);

    va_start(ap, entry);
    d->log_cb(e, d, entry, ap);
    va_end(ap);

#ifdef NEED_...",897.0,954.0,1.0,4.0,58.0,44,9,46,15,15,3,4,4,1,3,,0,3,6,3,3,enum logger_ret_type
1523,22100,logger_add_watcher,1,logger_add_watcher,"enum logger_add_watcher_ret logger_add_watcher (void*,int,uint16_t)",logger.c,"enum logger_add_watcher_ret logger_add_watcher(void *c, const int sfd, uint16_t f) {
    int x;
    logger_watcher *w = NULL;
    pthread_mutex_lock(&logger_stack_lock);
    if (watcher_count >= WATCHER_LIMIT) {
        pthread_mutex_unlock(&logger_stack_lock);
        return LOGGER_ADD_WATCHER_TOO_MANY;
    }

    for (x = 0; x < WATCHER_LIMIT-1; x++) {
        if (watchers[x] == NULL)
            break;
    }

    w = calloc(1, sizeof(logger_watcher));
    if (w == NULL) {
        pthread_mutex_unlock(&logger_stack_lock);
        return LOGGER_ADD_WATCHER_FAILED;
    }
    w->c = c;
    w->sfd = sfd;
    if (sfd == 0 && c == NULL) {
        w->t = LOGGER_WATCHER_STDERR;
    } else {
        w->t = LOGGER_WATCHER_CLIENT;
    }
    w->id = x;
    w->eflags = f;
    w->min_gid = logger_get_gid();
    w->buf = bipbuf_new(settings.logger_watcher_buf_size);
    if (w->buf == NULL) {
        free(w);
        pthread_mutex_unlock(&logger_stack_lock);
        return LOGGER_ADD_WATCHER_FAIL...",960.0,1005.0,1.0,25.0,46.0,41,13,46,16,1,24,8,8,3,4,,0,22,6,3,3,enum logger_add_watcher_ret
1524,22308,entry_log_cb,1,entry_log_cb,"void entry_log_cb (logentry*,entry_details*,void*,va_list)",logger.h,"typedef void (*entry_log_cb)(logentry *e, const entry_details *d, const void *entry, va_list ap);",59.0,59.0,14.0,96.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,void
1525,22316,entry_parse_cb,1,entry_parse_cb,"int entry_parse_cb (logentry*,char*)",logger.h,"typedef int (*entry_parse_cb)(logentry *e, char *scratch);",60.0,60.0,13.0,57.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
1526,22486,md5_process,1,md5_process,"void md5_process (md5_state_t*,md5_byte_t*)",md5.c,"static void
md5_process(md5_state_t *pms, const md5_byte_t *data /*[64]*/)
{
    md5_word_t
	a = pms->abcd[0], b = pms->abcd[1],
	c = pms->abcd[2], d = pms->abcd[3];
    md5_word_t t;
#if BYTE_ORDER > 0
    /* Define storage only for big-endian CPUs. */
    md5_word_t X[16];
#else
    /* Define storage for little-endian or both types of CPUs. */
    md5_word_t xbuf[16];
    const md5_word_t *X;
#endif

    {
#if BYTE_ORDER == 0
	/*
	 * Determine dynamically whether this is a big-endian or
	 * little-endian machine, since we can use a more efficient
	 * algorithm on the latter.
	 */
	static const int w = 1;

	if (*((const md5_byte_t *)&w)) /* dynamic little-endian */
#endif
#if BYTE_ORDER <= 0		/* little-endian */
	{
	    /*
	     * On little-endian machines, we can process properly aligned
	     * data without copying it.
	     */
	    if (!((data - (const md5_byte_t *)0) & 3)) {
		/* data are properly aligned */
		X = (const md5_word_t *)data;
	    } else {
		/* not aligned */
		me...",131.0,310.0,1.0,4.0,180.0,1078,16,949,9,1,0,3,4,0,0,,0,0,4,2,2,void
1527,25213,md5_init,1,md5_init,void md5_init (md5_state_t*),md5.c,"void
md5_init(md5_state_t *pms)
{
    pms->count[0] = pms->count[1] = 0;
    pms->abcd[0] = 0x67452301;
    pms->abcd[1] = /*0xefcdab89*/ T_MASK ^ 0x10325476;
    pms->abcd[2] = /*0x98badcfe*/ T_MASK ^ 0x67452301;
    pms->abcd[3] = 0x10325476;
}",312.0,320.0,1.0,34.0,9.0,24,6,6,1,1,0,1,1,0,0,,0,0,2,1,1,void
1528,25273,md5_append,1,md5_append,"void md5_append (md5_state_t*,md5_byte_t*,int)",md5.c,"void
md5_append(md5_state_t *pms, const md5_byte_t *data, int nbytes)
{
    const md5_byte_t *p = data;
    int left = nbytes;
    int offset = (pms->count[0] >> 3) & 63;
    md5_word_t nbits = (md5_word_t)(nbytes << 3);

    if (nbytes <= 0)
	return;

    /* Update the message length. */
    pms->count[1] += nbytes >> 29;
    pms->count[0] += nbits;
    if (pms->count[0] < nbits)
	pms->count[1]++;

    /* Process an initial partial block. */
    if (offset) {
	int copy = (offset + nbytes > 64 ? 64 - offset : nbytes);

	memcpy(pms->buf + offset, p, copy);
	if (offset + copy < 64)
	    return;
	p += copy;
	left -= copy;
	md5_process(pms, pms->buf);
    }

    /* Process full blocks. */
    for (; left >= 64; p += 64, left -= 64)
	md5_process(pms, p);

    /* Process a final partial block. */
    if (left)
	memcpy(pms->buf, p, left);
}",322.0,358.0,1.0,1.0,37.0,38,17,39,8,3,1,7,8,0,1,,0,0,6,3,3,void
1529,25412,md5_finish,1,md5_finish,"void md5_finish (md5_state_t*,md5_byte_t[16])",md5.c,"void
md5_finish(md5_state_t *pms, md5_byte_t digest[16])
{
    static const md5_byte_t pad[64] = {
	0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    };
    md5_byte_t data[8];
    int i;

    /* Save the length before padding. */
    for (i = 0; i < 8; ++i)
	data[i] = (md5_byte_t)(pms->count[i >> 2] >> ((i & 3) << 3));
    /* Pad to 56 bytes mod 64. */
    md5_append(pms, pad, ((55 - (pms->count[0] >> 3)) & 63) + 1);
    /* Append the length. */
    md5_append(pms, data, 8);
    for (i = 0; i < 16; ++i)
	digest[i] = (md5_byte_t)(pms->abcd[i >> 2] >> ((i & 3) << 3));
}",360.0,381.0,1.0,1.0,22.0,12,9,10,4,1,2,3,3,0,2,,0,0,4,2,2,void
1530,25675,drive_machine,1,drive_machine,void drive_machine (conn*),memcached.c,"static void drive_machine(conn *c) {
    bool stop = false;
    int sfd;
    socklen_t addrlen;
    struct sockaddr_storage addr;
    int nreqs = settings.reqs_per_event;
    int res;
    const char *str;
#ifdef HAVE_ACCEPT4
    static int  use_accept4 = 1;
#else
    static int  use_accept4 = 0;
#endif

    assert(c != NULL);

    while (!stop) {

        switch(c->state) {
        case conn_listening:
            addrlen = sizeof(addr);
#ifdef HAVE_ACCEPT4
            if (use_accept4) {
                sfd = accept4(c->sfd, (struct sockaddr *)&addr, &addrlen, SOCK_NONBLOCK);
            } else {
                sfd = accept(c->sfd, (struct sockaddr *)&addr, &addrlen);
            }
#else
            sfd = accept(c->sfd, (struct sockaddr *)&addr, &addrlen);
#endif
            if (sfd == -1) {
                if (use_accept4 && errno == ENOSYS) {
                    use_accept4 = 0;
                    continue;
                }
                perror(use_accept4 ? ""accept4()"" : ""ac...",2963.0,3390.0,1.0,37.0,428.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,void
1531,25680,new_socket,1,new_socket,int new_socket (addrinfo*),memcached.c,"static int new_socket(struct addrinfo *ai) {
    int sfd;
    int flags;

    if ((sfd = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol)) == -1) {
        return -1;
    }

    if ((flags = fcntl(sfd, F_GETFL, 0)) < 0 ||
        fcntl(sfd, F_SETFL, flags | O_NONBLOCK) < 0) {
        perror(""setting O_NONBLOCK"");
        close(sfd);
        return -1;
    }
    return sfd;
}",3414.0,3429.0,1.0,1.0,16.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,int
1532,25685,tcp_read,1,tcp_read,"ssize_t tcp_read (conn*,void*,size_t)",testapp.c,"ssize_t tcp_read(struct conn *c, void *buf, size_t count) {
    assert(c != NULL);
    return read(c->sock, buf, count);
}",56.0,59.0,1.0,1.0,4.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,ssize_t
1533,25692,tcp_sendmsg,1,tcp_sendmsg,"ssize_t tcp_sendmsg (conn*,msghdr*,int)",memcached.c,"ssize_t tcp_sendmsg(conn *c, struct msghdr *msg, int flags) {
    assert (c != NULL);
    return sendmsg(c->sfd, msg, flags);
}",138.0,141.0,1.0,1.0,4.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,ssize_t
1534,25699,tcp_write,1,tcp_write,"ssize_t tcp_write (conn*,void*,size_t)",testapp.c,"ssize_t tcp_write(struct conn *c, const void *buf, size_t count) {
    assert(c != NULL);
    return write(c->sock, buf, count);
}",61.0,64.0,1.0,1.0,4.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,ssize_t
1535,25711,try_read_command_negotiate,1,try_read_command_negotiate,int try_read_command_negotiate (conn*),memcached.c,"static int try_read_command_negotiate(conn *c) {
    assert(c != NULL);
    assert(c->protocol == negotiating_prot);
    assert(c->rcurr <= (c->rbuf + c->rsize));
    assert(c->rbytes > 0);

    if ((unsigned char)c->rbuf[0] == (unsigned char)PROTOCOL_BINARY_REQ) {
        c->protocol = binary_prot;
        c->try_read_command = try_read_command_binary;
    } else {
        // authentication doesn't work with negotiated protocol.
        c->protocol = ascii_prot;
        c->try_read_command = try_read_command_ascii;
    }

    if (settings.verbose > 1) {
        fprintf(stderr, ""%d: Client using the %s protocol\n"", c->sfd,
                prot_text(c->protocol));
    }

    return c->try_read_command(c);
}",2347.0,2368.0,1.0,1.0,22.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
1536,25716,try_read_command_udp,1,try_read_command_udp,int try_read_command_udp (conn*),memcached.c,"static int try_read_command_udp(conn *c) {
    assert(c != NULL);
    assert(c->rcurr <= (c->rbuf + c->rsize));
    assert(c->rbytes > 0);

    if ((unsigned char)c->rbuf[0] == (unsigned char)PROTOCOL_BINARY_REQ) {
        c->protocol = binary_prot;
        return try_read_command_binary(c);
    } else {
        c->protocol = ascii_prot;
        return try_read_command_ascii(c);
    }
}",2370.0,2382.0,1.0,1.0,13.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
1537,25725,start_conn_timeout_thread,1,start_conn_timeout_thread,int start_conn_timeout_thread (),memcached.c,"static int start_conn_timeout_thread() {
    int ret;

    if (settings.idle_timeout == 0)
        return -1;

    do_run_conn_timeout_thread = 1;
    if ((ret = pthread_create(&conn_timeout_tid, NULL,
        conn_timeout_thread, NULL)) != 0) {
        fprintf(stderr, ""Can't create idle connection timeout thread: %s\n"",
            strerror(ret));
        return -1;
    }

    return 0;
}",377.0,392.0,1.0,1.0,16.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,int
1538,25729,stats_init,1,stats_init,void stats_init (void),memcached.c,"static void stats_init(void) {
    memset(&stats, 0, sizeof(struct stats));
    memset(&stats_state, 0, sizeof(struct stats_state));
    stats_state.accepting_conns = true; /* assuming we start in this state. */

    /* make the time we started always be 2 seconds before we really
       did, so time(0) - time.started is never zero.  if so, things
       like 'settings.oldest_live' which act as booleans as well as
       values are now false in boolean context... */
    process_started = time(0) - ITEM_UPDATE_INTERVAL - 2;
    stats_prefix_init(settings.prefix_delimiter);
}",197.0,208.0,1.0,32.0,12.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
1539,25734,conn_to_str,1,conn_to_str,"void conn_to_str (conn*,char*,char*)",memcached.c,"static void conn_to_str(const conn *c, char *addr, char *svr_addr) {
    if (!c) {
        memcpy(addr, ""<null>"", 6);
    } else if (c->state == conn_closed) {
        memcpy(addr, ""<closed>"", 8);
    } else {
        struct sockaddr_in6 local_addr;
        struct sockaddr *sock_addr = (void *)&c->request_addr;

        /* For listen ports and idle UDP ports, show listen address */
        if (c->state == conn_listening ||
                (IS_UDP(c->transport) &&
                 c->state == conn_read)) {
            socklen_t local_addr_len = sizeof(local_addr);

            if (getsockname(c->sfd,
                        (struct sockaddr *)&local_addr,
                        &local_addr_len) == 0) {
                sock_addr = (struct sockaddr *)&local_addr;
            }
        }
        get_conn_text(c, sock_addr->sa_family, addr, sock_addr);

        if (c->state != conn_listening && !(IS_UDP(c->transport) &&
                 c->state == conn_read)) {
            struct socka...",2114.0,2145.0,1.0,17.0,32.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,void
1540,25741,settings_init,1,settings_init,void settings_init (void),memcached.c,"static void settings_init(void) {
    settings.use_cas = true;
    settings.access = 0700;
    settings.port = 11211;
    settings.udpport = 0;
#ifdef TLS
    settings.ssl_enabled = false;
    settings.ssl_ctx = NULL;
    settings.ssl_chain_cert = NULL;
    settings.ssl_key = NULL;
    settings.ssl_verify_mode = SSL_VERIFY_NONE;
    settings.ssl_keyformat = SSL_FILETYPE_PEM;
    settings.ssl_ciphers = NULL;
    settings.ssl_ca_cert = NULL;
    settings.ssl_last_cert_refresh_time = current_time;
    settings.ssl_wbuf_size = 16 * 1024; // default is 16KB (SSL max frame size is 17KB)
    settings.ssl_session_cache = false;
    settings.ssl_kernel_tls = false;
    settings.ssl_min_version = TLS1_2_VERSION;
#endif
    /* By default this string should be NULL for getaddrinfo() */
    settings.inter = NULL;
    settings.maxbytes = 64 * 1024 * 1024; /* default is 64MB */
    settings.maxconns = 1024;         /* to limit connections-related memory to about 5MB */
    settings.verbose = 0;
  ...",219.0,298.0,1.0,32.0,80.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
1541,25746,event_handler,1,event_handler,"void event_handler (evutil_socket_t,short,void*)",memcached.c,"void event_handler(const evutil_socket_t fd, const short which, void *arg) {
    conn *c;

    c = (conn *)arg;
    assert(c != NULL);

    c->which = which;

    /* sanity */
    if (fd != c->sfd) {
        if (settings.verbose > 0)
            fprintf(stderr, ""Catastrophic: event fd doesn't match conn fd!\n"");
        conn_close(c);
        return;
    }

    drive_machine(c);

    /* wait for next event */
    return;
}",3392.0,3412.0,1.0,1.0,21.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,void
1542,25753,conn_close,1,conn_close,void conn_close (conn*),memcached.c,"static void conn_close(conn *c) {
    assert(c != NULL);

    if (c->thread) {
        LOGGER_LOG(c->thread->l, LOG_CONNEVENTS, LOGGER_CONNECTION_CLOSE, NULL,
                &c->request_addr, c->request_addr_size, c->transport,
                c->close_reason, c->sfd);
    }

    /* delete the event, the socket and the conn */
    event_del(&c->event);

    if (settings.verbose > 1)
        fprintf(stderr, ""<%d connection closed.\n"", c->sfd);

    conn_cleanup(c);

    // force release of read buffer.
    if (c->thread) {
        c->rbytes = 0;
        rbuf_release(c);
    }

    MEMCACHED_CONN_RELEASE(c->sfd);
    conn_set_state(c, conn_closed);
#ifdef TLS
    if (c->ssl) {
        SSL_shutdown(c->ssl);
        SSL_free(c->ssl);
    }
#endif
    close(c->sfd);
    c->close_reason = 0;
    pthread_mutex_lock(&conn_lock);
    allow_new_conns = true;
    pthread_mutex_unlock(&conn_lock);

    STATS_LOCK();
    stats_state.curr_conns--;
    STATS_UNLOCK();

    return;
}",919.0,961.0,1.0,8.0,43.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
1543,25758,conn_init,1,conn_init,void conn_init (void),memcached.c,"static void conn_init(void) {
    /* We're unlikely to see an FD much higher than maxconns. */
    int next_fd = dup(1);
    if (next_fd < 0) {
        perror(""Failed to duplicate file descriptor\n"");
        exit(1);
    }
    int headroom = 10;      /* account for extra unexpected open FDs */
    struct rlimit rl;

    max_fds = settings.maxconns + headroom + next_fd;

    /* But if possible, get the actual highest FD we can possibly ever see. */
    if (getrlimit(RLIMIT_NOFILE, &rl) == 0) {
        max_fds = rl.rlim_max;
    } else {
        fprintf(stderr, ""Failed to query maximum file descriptor; ""
                        ""falling back to maxconns\n"");
    }

    close(next_fd);

    if ((conns = calloc(max_fds, sizeof(conn *))) == NULL) {
        fprintf(stderr, ""Failed to allocate connection structures\n"");
        /* This is unrecoverable so bail out early. */
        exit(1);
    }
}",466.0,493.0,1.0,1.0,28.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
1544,25763,update_event,1,update_event,"bool update_event (conn*,int)",memcached.c,"static bool update_event(conn *c, const int new_flags) {
    assert(c != NULL);

    struct event_base *base = c->event.ev_base;
    if (c->ev_flags == new_flags)
        return true;
    if (event_del(&c->event) == -1) return false;
    event_set(&c->event, c->sfd, new_flags, event_handler, (void *)c);
    event_base_set(base, &c->event);
    c->ev_flags = new_flags;
    if (event_add(&c->event, 0) == -1) return false;
    return true;
}",2498.0,2510.0,1.0,1.0,13.0,0,0,0,0,3,0,1,1,0,0,,0,0,4,2,2,bool
1545,25769,complete_nread,1,complete_nread,void complete_nread (conn*),memcached.c,"static void complete_nread(conn *c) {
    assert(c != NULL);
#ifdef PROXY
    assert(c->protocol == ascii_prot
           || c->protocol == binary_prot
           || c->protocol == proxy_prot);
#else
    assert(c->protocol == ascii_prot
           || c->protocol == binary_prot);
#endif
    if (c->protocol == ascii_prot) {
        complete_nread_ascii(c);
    } else if (c->protocol == binary_prot) {
        complete_nread_binary(c);
#ifdef PROXY
    } else if (c->protocol == proxy_prot) {
        complete_nread_proxy(c);
#endif
    }
}",1442.0,1461.0,1.0,1.0,20.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
1546,25774,conn_free,1,conn_free,void conn_free (conn*),memcached.c,"void conn_free(conn *c) {
    if (c) {
        assert(c != NULL);
        assert(c->sfd >= 0 && c->sfd < max_fds);

        MEMCACHED_CONN_DESTROY(c);
        conns[c->sfd] = NULL;
        if (c->rbuf)
            free(c->rbuf);
#ifdef TLS
        if (c->ssl_wbuf)
            c->ssl_wbuf = NULL;
#endif

        free(c);
    }
}",901.0,917.0,1.0,8.0,17.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
1547,25868,maxconns_handler,1,maxconns_handler,"void maxconns_handler (evutil_socket_t,short,void*)",memcached.c,"static void maxconns_handler(const evutil_socket_t fd, const short which, void *arg) {
    struct timeval t = {.tv_sec = 0, .tv_usec = 10000};

    if (fd == -42 || allow_new_conns == false) {
        /* reschedule in 10ms if we need to keep polling */
        evtimer_set(&maxconnsevent, maxconns_handler, 0);
        event_base_set(main_base, &maxconnsevent);
        evtimer_add(&maxconnsevent, &t);
    } else {
        evtimer_del(&maxconnsevent);
        accept_new_conns(true);
    }
}",158.0,170.0,1.0,1.0,13.0,12,6,11,8,0,5,2,2,1,0,,0,5,6,3,3,void
1548,25918,realtime,1,realtime,rel_time_t realtime (time_t),memcached.c,"rel_time_t realtime(const time_t exptime) {
    /* no. of seconds in 30 days - largest possible delta exptime */

    if (exptime == 0) return 0; /* 0 means never expire */

    if (exptime > REALTIME_MAXDELTA) {
        /* if item expiration is at/before the server started, give it an
           expiration time of 1 second after the server started.
           (because 0 means don't expire).  without this, we'd
           underflow and wrap around to some large value way in the
           future, effectively making items expiring in the past
           really expiring never */
        if (exptime <= process_started)
            return (rel_time_t)1;
        return (rel_time_t)(exptime - process_started);
    } else {
        return (rel_time_t)(exptime + current_time);
    }
}",177.0,195.0,1.0,18.0,19.0,9,6,6,2,5,0,4,5,0,0,,0,0,2,1,1,rel_time_t
1549,26002,stats_reset,1,stats_reset,void stats_reset (void),memcached.c,"void stats_reset(void) {
    STATS_LOCK();
    memset(&stats, 0, sizeof(struct stats));
    stats_prefix_clear();
    STATS_UNLOCK();
    threadlocal_stats_reset();
    item_stats_reset();
}",210.0,217.0,1.0,1.0,8.0,2,2,2,2,0,6,1,1,0,3,,0,1,2,1,1,void
1550,26336,conn_timeout_thread,1,conn_timeout_thread,void* conn_timeout_thread (void*),memcached.c,"static void *conn_timeout_thread(void *arg) {
    int i;
    conn *c;
    rel_time_t oldest_last_cmd;
    int sleep_time;
    int sleep_slice = max_fds / CONNS_PER_SLICE;
    if (sleep_slice == 0)
        sleep_slice = CONNS_PER_SLICE;

    useconds_t timeslice = 1000000 / sleep_slice;

    mutex_lock(&conn_timeout_lock);
    while(do_run_conn_timeout_thread) {
        if (settings.verbose > 2)
            fprintf(stderr, ""idle timeout thread at top of connection list\n"");

        oldest_last_cmd = current_time;

        for (i = 0; i < max_fds; i++) {
            if ((i % CONNS_PER_SLICE) == 0) {
                if (settings.verbose > 2)
                    fprintf(stderr, ""idle timeout thread sleeping for %ulus\n"",
                        (unsigned int)timeslice);
                usleep(timeslice);
            }

            if (!conns[i])
                continue;

            c = conns[i];

            if (!IS_TCP(c->transport))
                continue;

            if (c->sta...",309.0,375.0,1.0,32.0,67.0,56,17,58,20,0,27,16,30,16,1,,0,26,2,1,1,void*
1551,26600,stop_conn_timeout_thread,1,stop_conn_timeout_thread,int stop_conn_timeout_thread (void),memcached.c,"int stop_conn_timeout_thread(void) {
    if (!do_run_conn_timeout_thread)
        return -1;
    mutex_lock(&conn_timeout_lock);
    do_run_conn_timeout_thread = 0;
    pthread_cond_signal(&conn_timeout_cond);
    mutex_unlock(&conn_timeout_lock);
    pthread_join(conn_timeout_tid, NULL);
    return 0;
}",394.0,403.0,1.0,4.0,10.0,8,4,9,5,0,8,2,2,1,0,,0,8,2,1,1,int
1552,26637,rbuf_release,1,rbuf_release,void rbuf_release (conn*),memcached.c,"static void rbuf_release(conn *c) {
    if (c->rbuf != NULL && c->rbytes == 0 && !IS_UDP(c->transport)) {
        if (c->rbuf_malloced) {
            free(c->rbuf);
            c->rbuf_malloced = false;
        } else {
            do_cache_free(c->thread->rbuf_cache, c->rbuf);
        }
        c->rsize = 0;
        c->rbuf = NULL;
        c->rcurr = NULL;
    }
}",408.0,420.0,1.0,46.0,13.0,20,6,15,4,0,10,3,4,5,0,,0,10,2,1,1,void
1553,26707,rbuf_alloc,1,rbuf_alloc,bool rbuf_alloc (conn*),memcached.c,"static bool rbuf_alloc(conn *c) {
    if (c->rbuf == NULL) {
        c->rbuf = do_cache_alloc(c->thread->rbuf_cache);
        if (!c->rbuf) {
            THR_STATS_LOCK(c);
            c->thread->stats.read_buf_oom++;
            THR_STATS_UNLOCK(c);
            return false;
        }
        c->rsize = READ_BUFFER_SIZE;
        c->rcurr = c->rbuf;
    }
    return true;
}",422.0,435.0,1.0,12.0,14.0,25,7,15,4,0,11,3,4,2,1,,0,11,2,1,1,bool
1554,26785,rbuf_switch_to_malloc,1,rbuf_switch_to_malloc,bool rbuf_switch_to_malloc (conn*),memcached.c,"bool rbuf_switch_to_malloc(conn *c) {
    // Might as well start with x2 and work from there.
    size_t size = c->rsize * 2;
    char *tmp = malloc(size);
    if (!tmp)
        return false;

    memcpy(tmp, c->rcurr, c->rbytes);
    do_cache_free(c->thread->rbuf_cache, c->rbuf);

    c->rcurr = c->rbuf = tmp;
    c->rsize = size;
    c->rbuf_malloced = true;
    return true;
}",440.0,454.0,1.0,1.0,15.0,18,4,19,5,2,10,2,2,0,1,,0,9,2,1,1,bool
1555,26915,prot_text,1,prot_text,const char* prot_text (protocol),memcached.c,"static const char *prot_text(enum protocol prot) {
    char *rv = ""unknown"";
    switch(prot) {
        case ascii_prot:
            rv = ""ascii"";
            break;
        case binary_prot:
            rv = ""binary"";
            break;
        case negotiating_prot:
            rv = ""auto-negotiate"";
            break;
#ifdef PROXY
        case proxy_prot:
            rv = ""proxy"";
            break;
#endif
    }
    return rv;
}",495.0,514.0,1.0,1.0,20.0,4,1,9,5,4,0,5,2,0,0,,0,0,2,1,1,const char*
1556,26947,conn_close_idle,1,conn_close_idle,void conn_close_idle (conn*),memcached.c,"void conn_close_idle(conn *c) {
    if (settings.idle_timeout > 0 &&
        (current_time - c->last_cmd_time) > settings.idle_timeout) {
        if (c->state != conn_new_cmd && c->state != conn_read) {
            if (settings.verbose > 1)
                fprintf(stderr,
                    ""fd %d wants to timeout, but isn't in read state"", c->sfd);
            return;
        }

        if (settings.verbose > 1)
            fprintf(stderr, ""Closing idle fd %d\n"", c->sfd);

        pthread_mutex_lock(&c->thread->stats.mutex);
        c->thread->stats.idle_kicks++;
        pthread_mutex_unlock(&c->thread->stats.mutex);

        c->close_reason = IDLE_TIMEOUT_CLOSE;

        conn_set_state(c, conn_closing);
        drive_machine(c);
    }
}",516.0,538.0,1.0,1.0,23.0,32,9,22,8,0,19,5,9,11,2,,0,17,2,1,1,void
1557,27045,conn_worker_readd,1,conn_worker_readd,void conn_worker_readd (conn*),memcached.c,"void conn_worker_readd(conn *c) {
    if (c->state == conn_io_queue) {
        c->io_queues_submitted--;
        // If we're still waiting for other queues to return, don't re-add the
        // connection yet.
        if (c->io_queues_submitted != 0) {
            return;
        }
    }
    c->ev_flags = EV_READ | EV_PERSIST;
    event_set(&c->event, c->sfd, c->ev_flags, event_handler, (void *)c);
    event_base_set(c->thread->base, &c->event);

    // TODO: call conn_cleanup/fail/etc
    if (event_add(&c->event, 0) == -1) {
        perror(""event_add"");
    }

    // side thread wanted us to close immediately.
    if (c->state == conn_closing) {
        drive_machine(c);
        return;
    } else if (c->state == conn_io_queue) {
        // machine will know how to return based on secondary state.
        drive_machine(c);
    } else {
        conn_set_state(c, conn_new_cmd);
    }
}",541.0,569.0,1.0,1.0,29.0,24,9,18,6,0,9,5,6,3,1,,0,8,2,1,1,void
1558,27140,thread_io_queue_add,1,thread_io_queue_add,"void thread_io_queue_add (LIBEVENT_THREAD*,int,void*,io_queue_stack_cb,io_queue_stack_cb,io_queue_cb,io_queue_cb)",memcached.c,"void thread_io_queue_add(LIBEVENT_THREAD *t, int type, void *ctx, io_queue_stack_cb cb, io_queue_stack_cb com_cb, io_queue_cb ret_cb, io_queue_cb fin_cb) {
    io_queue_cb_t *q = t->io_queues;
    while (q->type != IO_QUEUE_NONE) {
        q++;
    }
    q->type = type;
    q->ctx = ctx;
    q->submit_cb = cb;
    q->complete_cb = com_cb;
    q->finalize_cb = fin_cb;
    q->return_cb   = ret_cb;
    return;
}",571.0,583.0,1.0,22.0,13.0,17,4,16,8,1,1,2,2,0,0,,0,1,14,7,7,void
1559,27199,conn_io_queue_setup,1,conn_io_queue_setup,void conn_io_queue_setup (conn*),memcached.c,"void conn_io_queue_setup(conn *c) {
    io_queue_cb_t *qcb = c->thread->io_queues;
    io_queue_t *q = c->io_queues;
    while (qcb->type != IO_QUEUE_NONE) {
        q->type = qcb->type;
        q->ctx = qcb->ctx;
        q->stack_ctx = NULL;
        q->count = 0;
        qcb++;
        q++;
    }
}",585.0,596.0,1.0,24.0,12.0,19,4,14,4,0,2,2,2,0,0,,0,2,2,1,1,void
1560,27255,conn_io_queue_reset,1,conn_io_queue_reset,void conn_io_queue_reset (conn*),memcached.c,"static void conn_io_queue_reset(conn *c) {
    for (io_queue_t *q = c->io_queues; q->type != IO_QUEUE_NONE; q++) {
        assert(q->count == 0);
        q->stack_ctx = NULL;
    }
}",599.0,604.0,1.0,50.0,6.0,8,4,6,3,1,1,2,2,0,0,,0,1,2,1,1,void
1561,27289,thread_io_queue_get,1,thread_io_queue_get,"io_queue_cb_t thread_io_queue_get (LIBEVENT_THREAD*,int)",memcached.c,"io_queue_cb_t *thread_io_queue_get(LIBEVENT_THREAD *t, int type) {
    io_queue_cb_t *q = t->io_queues;
    while (q->type != IO_QUEUE_NONE) {
        if (q->type == type) {
            return q;
        }
        q++;
    }
    return NULL;
}",606.0,615.0,1.0,22.0,10.0,7,5,8,4,2,1,3,4,0,0,,0,1,4,2,2,io_queue_cb_t
1562,27323,conn_io_queue_get,1,conn_io_queue_get,"io_queue_t conn_io_queue_get (conn*,int)",memcached.c,"io_queue_t *conn_io_queue_get(conn *c, int type) {
    io_queue_t *q = c->io_queues;
    while (q->type != IO_QUEUE_NONE) {
        if (q->type == type) {
            return q;
        }
        q++;
    }
    return NULL;
}",617.0,626.0,1.0,22.0,10.0,7,5,8,4,1,1,3,4,0,0,,0,1,4,2,2,io_queue_t
1563,27357,conn_io_queue_complete,1,conn_io_queue_complete,void conn_io_queue_complete (conn*),memcached.c,"static void conn_io_queue_complete(conn *c) {
    io_queue_t *q = c->io_queues;
    io_queue_cb_t *qcb = c->thread->io_queues;
    while (q->type != IO_QUEUE_NONE) {
        if (q->stack_ctx) {
            qcb->complete_cb(q);
        }
        qcb++;
        q++;
    }
}",631.0,641.0,1.0,22.0,11.0,11,4,10,3,0,2,3,4,0,0,,0,2,2,1,1,void
1564,27399,conn_io_queue_return,1,conn_io_queue_return,void conn_io_queue_return (io_pending_t*),memcached.c,"void conn_io_queue_return(io_pending_t *io) {
    io_queue_cb_t *q = thread_io_queue_get(io->thread, io->io_queue_type);
    q->return_cb(io);
    return;
}",644.0,648.0,1.0,1.0,5.0,4,2,5,2,0,1,1,1,0,1,,0,1,2,1,1,void
1565,27420,conn_new,1,conn_new,"conn conn_new (int,conn_states,int,int,network_transport,event_base*,void*,uint64_t,protocol)",memcached.c,"conn *conn_new(const int sfd, enum conn_states init_state,
                const int event_flags,
                const int read_buffer_size, enum network_transport transport,
                struct event_base *base, void *ssl, uint64_t conntag,
                enum protocol bproto) {
    conn *c;

    assert(sfd >= 0 && sfd < max_fds);
    c = conns[sfd];

    if (NULL == c) {
        if (!(c = (conn *)calloc(1, sizeof(conn)))) {
            STATS_LOCK();
            stats.malloc_fails++;
            STATS_UNLOCK();
            fprintf(stderr, ""Failed to allocate connection object\n"");
            return NULL;
        }
        MEMCACHED_CONN_CREATE(c);
        c->read = NULL;
        c->sendmsg = NULL;
        c->write = NULL;
        c->rbuf = NULL;

        c->rsize = read_buffer_size;

        // UDP connections use a persistent static buffer.
        if (c->rsize) {
            c->rbuf = (char *)malloc((size_t)c->rsize);
        }

        if (c->rsize && c->rbuf == NULL) {
  ...",650.0,840.0,1.0,8.0,191.0,142,17,133,30,1,67,13,18,9,3,,0,56,18,9,9,conn
1566,27998,conn_release_items,1,conn_release_items,void conn_release_items (conn*),memcached.c,"void conn_release_items(conn *c) {
    assert(c != NULL);

    if (c->item) {
        if (c->item_malloced) {
            free(c->item);
            c->item_malloced = false;
        } else {
            item_remove(c->item);
        }
        c->item = 0;
    }

    // Cull any unsent responses.
    if (c->resp_head) {
        mc_resp *resp = c->resp_head;
        // r_f() handles the chain maintenance.
        while (resp) {
            // temporary by default. hide behind a debug flag in the future:
            // double free detection. Transmit loops can drop out early, but
            // here we could infinite loop.
            if (resp->free) {
                fprintf(stderr, ""ERROR: double free detected during conn_release_items(): [%d] [%s]\n"",
                        c->sfd, c->protocol == binary_prot ? ""binary"" : ""ascii"");
                // Since this is a critical failure, just leak the memory.
                // If these errors are seen, an abort() can be used instead.
...",842.0,876.0,1.0,1.0,35.0,21,5,25,6,2,12,7,10,3,2,,0,11,2,1,1,void
1567,28088,conn_cleanup,1,conn_cleanup,void conn_cleanup (conn*),memcached.c,"static void conn_cleanup(conn *c) {
    assert(c != NULL);

    conn_release_items(c);
#ifdef PROXY
    if (c->proxy_coro_ref) {
        proxy_cleanup_conn(c);
    }
#endif
    if (c->sasl_conn) {
        assert(settings.sasl);
        sasl_dispose(&c->sasl_conn);
        c->sasl_conn = NULL;
    }

    if (IS_UDP(c->transport)) {
        conn_set_state(c, conn_read);
    }
}",878.0,896.0,1.0,8.0,19.0,8,5,12,5,0,8,3,3,3,2,,0,6,2,1,1,void
1568,28310,conn_close_all,1,conn_close_all,void conn_close_all (void),memcached.c,"void conn_close_all(void) {
    int i;
    for (i = 0; i < max_fds; i++) {
        if (conns[i] && conns[i]->state != conn_closed) {
            conn_close(conns[i]);
        }
    }
}",966.0,973.0,1.0,1.0,8.0,8,6,10,4,0,5,3,4,3,1,,0,4,2,1,1,void
1569,28344,state_text,1,state_text,const char* state_text (conn_states),memcached.c,"static const char *state_text(enum conn_states state) {
    const char* const statenames[] = { ""conn_listening"",
                                       ""conn_new_cmd"",
                                       ""conn_waiting"",
                                       ""conn_read"",
                                       ""conn_parse_cmd"",
                                       ""conn_write"",
                                       ""conn_nread"",
                                       ""conn_swallow"",
                                       ""conn_closing"",
                                       ""conn_mwrite"",
                                       ""conn_closed"",
                                       ""conn_watch"",
                                       ""conn_io_queue"" };
    return statenames[state];
}",978.0,993.0,1.0,1.0,16.0,3,3,3,2,3,0,1,1,0,0,,0,0,2,1,1,const char*
1570,28370,conn_set_state,1,conn_set_state,"void conn_set_state (conn*,conn_states)",memcached.c,"void conn_set_state(conn *c, enum conn_states state) {
    assert(c != NULL);
    assert(state >= conn_listening && state < conn_max_state);

    if (state != c->state) {
        if (settings.verbose > 2) {
            fprintf(stderr, ""%d: going from %s to %s\n"",
                    c->sfd, state_text(c->state),
                    state_text(state));
        }

        if (state == conn_write || state == conn_mwrite) {
            MEMCACHED_PROCESS_COMMAND_END(c->sfd, c->resp->wbuf, c->resp->wbytes);
        }
        c->state = state;
    }
}",1000.0,1016.0,1.0,12.0,17.0,15,10,19,9,35,8,4,6,3,2,,0,6,4,2,2,void
1571,28428,resp_reset,1,resp_reset,void resp_reset (mc_resp*),memcached.c,"void resp_reset(mc_resp *resp) {
    if (resp->item) {
        item_remove(resp->item);
        resp->item = NULL;
    }
    if (resp->write_and_free) {
        free(resp->write_and_free);
        resp->write_and_free = NULL;
    }
    resp->wbytes = 0;
    resp->tosend = 0;
    resp->iovcnt = 0;
    resp->chunked_data_iov = 0;
    resp->chunked_total = 0;
    resp->skip = false;
}",1021.0,1036.0,1.0,1.0,16.0,20,2,15,3,2,1,3,3,0,1,,0,0,2,1,1,void
1572,28491,resp_add_iov,1,resp_add_iov,"void resp_add_iov (mc_resp*,void*,int)",memcached.c,"void resp_add_iov(mc_resp *resp, const void *buf, int len) {
    assert(resp->iovcnt < MC_RESP_IOVCOUNT);
    int x = resp->iovcnt;
    resp->iov[x].iov_base = (void *)buf;
    resp->iov[x].iov_len = len;
    resp->iovcnt++;
    resp->tosend += len;
}",1038.0,1045.0,1.0,26.0,8.0,17,8,12,4,15,0,1,1,0,0,,0,0,6,3,3,void
1573,28541,resp_add_chunked_iov,1,resp_add_chunked_iov,"void resp_add_chunked_iov (mc_resp*,void*,int)",memcached.c,"void resp_add_chunked_iov(mc_resp *resp, const void *buf, int len) {
    resp->chunked_data_iov = resp->iovcnt;
    resp->chunked_total = len;
    resp_add_iov(resp, buf, len);
}",1050.0,1054.0,1.0,1.0,5.0,5,2,7,3,0,1,1,1,0,1,,0,0,6,3,3,void
1574,28564,resp_allocate,1,resp_allocate,mc_resp resp_allocate (conn*),memcached.c,"static mc_resp* resp_allocate(conn *c) {
    LIBEVENT_THREAD *th = c->thread;
    mc_resp *resp = NULL;
    mc_resp_bundle *b = th->open_bundle;

    if (b != NULL) {
        for (int i = 0; i < MAX_RESP_PER_BUNDLE; i++) {
            // loop around starting from the most likely to be free
            int x = (i + b->next_check) % MAX_RESP_PER_BUNDLE;
            if (b->r[x].free) {
                resp = &b->r[x];
                b->next_check = x+1;
                break;
            }
        }

        if (resp != NULL) {
            b->refcount++;
            resp->free = false;
            if (b->refcount == MAX_RESP_PER_BUNDLE) {
                assert(b->prev == NULL);
                // We only allocate off the head. Assign new head.
                th->open_bundle = b->next;
                // Remove ourselves from the list.
                if (b->next) {
                    b->next->prev = 0;
                    b->next = 0;
                }
            }
        }
    }...",1061.0,1117.0,1.0,28.0,57.0,99,15,72,11,1,10,11,22,0,1,,0,10,2,1,1,mc_resp
1575,28849,resp_free,1,resp_free,"void resp_free (conn*,mc_resp*)",memcached.c,"static void resp_free(conn *c, mc_resp *resp) {
    LIBEVENT_THREAD *th = c->thread;
    mc_resp_bundle *b = resp->bundle;

    resp->free = true;
    b->refcount--;
    if (b->refcount == 0) {
        if (b == th->open_bundle && b->next == 0) {
            // This is the final bundle. Just hold and reuse to skip init loop
            assert(b->prev == 0);
            b->next_check = 0;
        } else {
            // Assert that we're either in the list or at the head.
            assert((b->next || b->prev) || b == th->open_bundle);

            // unlink from list.
            mc_resp_bundle **head = &th->open_bundle;
            if (*head == b) *head = b->next;
            // Not tracking the tail.
            assert(b->next != b && b->prev != b);

            if (b->next) b->next->prev = b->prev;
            if (b->prev) b->prev->next = b->next;

            // Now completely done with this buffer.
            do_cache_free(th->rbuf_cache, b);
            THR_STATS_LOCK(c);
   ...",1119.0,1163.0,1.0,12.0,45.0,19,5,13,5,1,2,3,4,1,0,,0,2,4,2,2,void
1576,29075,resp_start,1,resp_start,bool resp_start (conn*),memcached.c,"bool resp_start(conn *c) {
    mc_resp *resp = resp_allocate(c);
    if (!resp) {
        THR_STATS_LOCK(c);
        c->thread->stats.response_obj_oom++;
        THR_STATS_UNLOCK(c);
        return false;
    }
    // handling the stats counters here to simplify testing
    THR_STATS_LOCK(c);
    c->thread->stats.response_obj_count++;
    THR_STATS_UNLOCK(c);
    // Skip zeroing the bundle pointer at the start.
    // TODO: this line is here temporarily to make the code easy to disable.
    // when it's more mature, move the memset into resp_allocate() and have it
    // set the bundle pointer on allocate so this line isn't as complex.
    memset((char *)resp + sizeof(mc_resp_bundle*), 0, sizeof(*resp) - sizeof(mc_resp_bundle*));
    // TODO: this next line works. memset _does_ show up significantly under
    // perf reports due to zeroing out the entire resp->wbuf. before swapping
    // the lines more validation work should be done to ensure wbuf's aren't
    // accidentally reuse...",1165.0,1203.0,1.0,8.0,39.0,56,12,34,6,6,19,5,5,4,1,,0,19,2,1,1,bool
1577,29246,resp_finish,1,resp_finish,"mc_resp resp_finish (conn*,mc_resp*)",memcached.c,"mc_resp* resp_finish(conn *c, mc_resp *resp) {
    mc_resp *next = resp->next;
    if (resp->item) {
        // TODO: cache hash value in resp obj?
        item_remove(resp->item);
        resp->item = NULL;
    }
    if (resp->write_and_free) {
        free(resp->write_and_free);
    }
    if (resp->io_pending) {
        // If we had a pending IO, tell it to internally clean up then return
        // the main object back to our thread cache.
        io_queue_cb_t *qcb = thread_io_queue_get(c->thread, resp->io_pending->io_queue_type);
        qcb->finalize_cb(resp->io_pending);
        do_cache_free(c->thread->io_cache, resp->io_pending);
        resp->io_pending = NULL;
    }
    if (c->resp_head == resp) {
        c->resp_head = next;
    }
    if (c->resp == resp) {
        c->resp = NULL;
    }
    resp_free(c, resp);
    THR_STATS_LOCK(c);
    c->thread->stats.response_obj_count--;
    THR_STATS_UNLOCK(c);
    return next;
}",1206.0,1235.0,1.0,4.0,30.0,40,6,34,5,5,13,6,6,2,4,,0,10,4,2,2,mc_resp
1578,29380,resp_has_stack,1,resp_has_stack,bool resp_has_stack (conn*),memcached.c,"bool resp_has_stack(conn *c) {
    return c->resp_head->next != NULL ? true : false;
}",1238.0,1240.0,1.0,1.0,3.0,4,3,4,4,1,1,1,1,0,0,,0,1,2,1,1,bool
1579,29396,out_string,1,out_string,"void out_string (conn*,char*)",memcached.c,"void out_string(conn *c, const char *str) {
    size_t len;
    assert(c != NULL);
    mc_resp *resp = c->resp;

    // if response was original filled with something, but we're now writing
    // out an error or similar, have to reset the object first.
    // TODO: since this is often redundant with allocation, how many callers
    // are actually requiring it be reset? Can we fast test by just looking at
    // tosend and reset if nonzero?
    resp_reset(resp);

    if (c->noreply) {
        // TODO: just invalidate the response since nothing's been attempted
        // to send yet?
        resp->skip = true;
        if (settings.verbose > 1)
            fprintf(stderr, "">%d NOREPLY %s\n"", c->sfd, str);
        conn_set_state(c, conn_new_cmd);
        return;
    }

    if (settings.verbose > 1)
        fprintf(stderr, "">%d %s\n"", c->sfd, str);

    // Fill response object with static string.

    len = strlen(str);
    if ((len + 2) > WRITE_BUFFER_SIZE) {
        /* ought to be a...",1242.0,1282.0,1.0,20.0,41.0,22,6,34,9,68,12,5,6,5,4,,0,8,4,2,2,void
1580,29503,out_errstring,1,out_errstring,"void out_errstring (conn*,char*)",memcached.c,"void out_errstring(conn *c, const char *str) {
    c->noreply = false;
    out_string(c, str);
}",1286.0,1289.0,1.0,1.0,4.0,2,2,4,3,15,2,1,1,0,1,,0,1,4,2,2,void
1581,29517,out_of_memory,1,out_of_memory,"void out_of_memory (conn*,char*)",memcached.c,"void out_of_memory(conn *c, char *ascii_error) {
    const static char error_prefix[] = ""SERVER_ERROR "";
    const static int error_prefix_len = sizeof(error_prefix) - 1;

    if (c->protocol == binary_prot) {
        /* Strip off the generic error prefix; it's irrelevant in binary */
        if (!strncmp(ascii_error, error_prefix, error_prefix_len)) {
            ascii_error += error_prefix_len;
        }
        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, ascii_error, 0);
    } else {
        out_string(c, ascii_error);
    }
}",1295.0,1308.0,1.0,1.0,14.0,8,7,13,6,3,1,3,4,0,1,,0,0,4,2,2,void
1582,29561,append_bin_stats,1,append_bin_stats,"void append_bin_stats (char*,uint16_t,char*,uint32_t,conn*)",memcached.c,"static void append_bin_stats(const char *key, const uint16_t klen,
                             const char *val, const uint32_t vlen,
                             conn *c) {
    char *buf = c->stats.buffer + c->stats.offset;
    uint32_t bodylen = klen + vlen;
    protocol_binary_response_header header = {
        .response.magic = (uint8_t)PROTOCOL_BINARY_RES,
        .response.opcode = PROTOCOL_BINARY_CMD_STAT,
        .response.keylen = (uint16_t)htons(klen),
        .response.datatype = (uint8_t)PROTOCOL_BINARY_RAW_BYTES,
        .response.bodylen = htonl(bodylen),
        .response.opaque = c->opaque
    };

    memcpy(buf, header.bytes, sizeof(header.response));
    buf += sizeof(header.response);

    if (klen > 0) {
        memcpy(buf, key, klen);
        buf += klen;

        if (vlen > 0) {
            memcpy(buf, val, vlen);
        }
    }

    c->stats.offset += sizeof(header.response) + bodylen;
}",1310.0,1337.0,1.0,1.0,28.0,45,9,49,17,1,3,3,4,0,0,,0,3,10,5,5,void
1583,29704,append_ascii_stats,1,append_ascii_stats,"void append_ascii_stats (char*,uint16_t,char*,uint32_t,conn*)",memcached.c,"static void append_ascii_stats(const char *key, const uint16_t klen,
                               const char *val, const uint32_t vlen,
                               conn *c) {
    char *pos = c->stats.buffer + c->stats.offset;
    uint32_t nbytes = 0;
    int remaining = c->stats.size - c->stats.offset;
    int room = remaining - 1;

    if (klen == 0 && vlen == 0) {
        nbytes = snprintf(pos, room, ""END\r\n"");
    } else if (vlen == 0) {
        nbytes = snprintf(pos, room, ""STAT %s\r\n"", key);
    } else {
        nbytes = snprintf(pos, room, ""STAT %s %s\r\n"", key, val);
    }

    c->stats.offset += nbytes;
}",1339.0,1356.0,1.0,1.0,18.0,22,8,16,7,0,0,2,2,0,0,,0,0,10,5,5,void
1584,29797,grow_stats_buf,1,grow_stats_buf,"bool grow_stats_buf (conn*,size_t)",memcached.c,"static bool grow_stats_buf(conn *c, size_t needed) {
    size_t nsize = c->stats.size;
    size_t available = nsize - c->stats.offset;
    bool rv = true;

    /* Special case: No buffer -- need to allocate fresh */
    if (c->stats.buffer == NULL) {
        nsize = 1024;
        available = c->stats.size = c->stats.offset = 0;
    }

    while (needed > available) {
        assert(nsize > 0);
        nsize = nsize << 1;
        available = nsize - c->stats.offset;
    }

    if (nsize != c->stats.size) {
        char *ptr = realloc(c->stats.buffer, nsize);
        if (ptr) {
            c->stats.buffer = ptr;
            c->stats.size = nsize;
        } else {
            STATS_LOCK();
            stats.malloc_fails++;
            STATS_UNLOCK();
            rv = false;
        }
    }

    return rv;
}",1358.0,1389.0,1.0,1.0,32.0,39,8,32,8,1,0,5,6,0,0,,0,0,4,2,2,bool
1585,29924,append_stats,1,append_stats,"void append_stats (char*,uint16_t,char*,uint32_t,void*)",memcached.c,"void append_stats(const char *key, const uint16_t klen,
                  const char *val, const uint32_t vlen,
                  const void *cookie)
{
    /* value without a key is invalid */
    if (klen == 0 && vlen > 0) {
        return;
    }

    conn *c = (conn*)cookie;

    if (c->protocol == binary_prot) {
        size_t needed = vlen + klen + sizeof(protocol_binary_response_header);
        if (!grow_stats_buf(c, needed)) {
            return;
        }
        append_bin_stats(key, klen, val, vlen, c);
    } else {
        size_t needed = vlen + klen + 10; // 10 == ""STAT = \r\n""
        if (!grow_stats_buf(c, needed)) {
            return;
        }
        append_ascii_stats(key, klen, val, vlen, c);
    }

    assert(c->stats.offset <= c->stats.size);
}",1391.0,1417.0,1.0,1.0,27.0,17,11,19,9,1,2,4,5,1,2,,0,1,10,5,5,void
1586,30013,reset_cmd_handler,1,reset_cmd_handler,void reset_cmd_handler (conn*),memcached.c,"static void reset_cmd_handler(conn *c) {
    c->cmd = -1;
    c->substate = bin_no_state;
    if (c->item != NULL) {
        // TODO: Any other way to get here?
        // SASL auth was mistakenly using it. Nothing else should?
        if (c->item_malloced) {
            free(c->item);
            c->item_malloced = false;
        } else {
            item_remove(c->item);
        }
        c->item = NULL;
    }
    if (c->rbytes > 0) {
        conn_set_state(c, conn_parse_cmd);
    } else if (c->resp_head) {
        conn_set_state(c, conn_mwrite);
    } else {
        conn_set_state(c, conn_waiting);
    }
}",1419.0,1440.0,1.0,1.0,22.0,15,5,14,5,0,9,4,5,3,1,,0,8,2,1,1,void
1587,30127,_store_item_copy_chunks,1,_store_item_copy_chunks,"int _store_item_copy_chunks (item*,item*,int)",memcached.c,"static int _store_item_copy_chunks(item *d_it, item *s_it, const int len) {
    item_chunk *dch = (item_chunk *) ITEM_schunk(d_it);
    /* Advance dch until we find free space */
    while (dch->size == dch->used) {
        if (dch->next) {
            dch = dch->next;
        } else {
            break;
        }
    }

    if (s_it->it_flags & ITEM_CHUNKED) {
        int remain = len;
        item_chunk *sch = (item_chunk *) ITEM_schunk(s_it);
        int copied = 0;
        /* Fills dch's to capacity, not straight copy sch in case data is
         * being added or removed (ie append/prepend)
         */
        while (sch && dch && remain) {
            assert(dch->used <= dch->size);
            int todo = (dch->size - dch->used < sch->used - copied)
                ? dch->size - dch->used : sch->used - copied;
            if (remain < todo)
                todo = remain;
            memcpy(dch->data + dch->used, sch->data + copied, todo);
            dch->used += todo;
        ...",1465.0,1533.0,1.0,37.0,69.0,91,15,72,11,2,1,9,20,0,1,,0,1,6,3,3,int
1588,30523,_store_item_copy_data,1,_store_item_copy_data,"int _store_item_copy_data (int,item*,item*,item*)",memcached.c,"static int _store_item_copy_data(int comm, item *old_it, item *new_it, item *add_it) {
    if (comm == NREAD_APPEND) {
        if (new_it->it_flags & ITEM_CHUNKED) {
            if (_store_item_copy_chunks(new_it, old_it, old_it->nbytes - 2) == -1 ||
                _store_item_copy_chunks(new_it, add_it, add_it->nbytes) == -1) {
                return -1;
            }
        } else {
            memcpy(ITEM_data(new_it), ITEM_data(old_it), old_it->nbytes);
            memcpy(ITEM_data(new_it) + old_it->nbytes - 2 /* CRLF */, ITEM_data(add_it), add_it->nbytes);
        }
    } else {
        /* NREAD_PREPEND */
        if (new_it->it_flags & ITEM_CHUNKED) {
            if (_store_item_copy_chunks(new_it, add_it, add_it->nbytes - 2) == -1 ||
                _store_item_copy_chunks(new_it, old_it, old_it->nbytes) == -1) {
                return -1;
            }
        } else {
            memcpy(ITEM_data(new_it), ITEM_data(add_it), add_it->nbytes);
            memcpy(ITEM_data(ne...",1535.0,1559.0,1.0,16.0,25.0,12,6,8,4,1,2,4,7,2,2,,0,2,8,4,4,int
1589,30924,do_store_item,1,do_store_item,"enum store_item_type do_store_item (item*,int,conn*,uint32_t)",memcached.c,"enum store_item_type do_store_item(item *it, int comm, conn *c, const uint32_t hv) {
    char *key = ITEM_key(it);
    item *old_it = do_item_get(key, it->nkey, hv, c, DONT_UPDATE);
    enum store_item_type stored = NOT_STORED;

    enum cas_result { CAS_NONE, CAS_MATCH, CAS_BADVAL, CAS_STALE, CAS_MISS };

    item *new_it = NULL;
    uint32_t flags;

    /* Do the CAS test up front so we can apply to all store modes */
    enum cas_result cas_res = CAS_NONE;

    bool do_store = false;
    if (old_it != NULL) {
        // Most of the CAS work requires something to compare to.
        uint64_t it_cas = ITEM_get_cas(it);
        uint64_t old_cas = ITEM_get_cas(old_it);
        if (it_cas == 0) {
            cas_res = CAS_NONE;
        } else if (it_cas == old_cas) {
            cas_res = CAS_MATCH;
        } else if (c->set_stale && it_cas < old_cas) {
            cas_res = CAS_STALE;
        } else {
            cas_res = CAS_BADVAL;
        }

        switch (comm) {
            ca...",1567.0,1726.0,1.0,16.0,160.0,124,19,112,26,2,16,18,23,1,8,,0,11,8,4,4,enum store_item_type
1590,31654,write_and_free,1,write_and_free,"void write_and_free (conn*,char*,int)",memcached.c,"void write_and_free(conn *c, char *buf, int bytes) {
    if (buf) {
        mc_resp *resp = c->resp;
        resp->write_and_free = buf;
        resp_add_iov(resp, buf, bytes);
        conn_set_state(c, conn_new_cmd);
    } else {
        out_of_memory(c, ""SERVER_ERROR out of memory writing stats"");
    }
}",1729.0,1738.0,1.0,1.0,10.0,4,2,10,5,0,3,2,2,0,2,,0,1,6,3,3,void
1591,31687,append_stat,1,append_stat,"void append_stat (char*,ADD_STAT,conn*,char*...)",memcached.c,"void append_stat(const char *name, ADD_STAT add_stats, conn *c,
                 const char *fmt, ...) {
    char val_str[STAT_VAL_LEN];
    int vlen;
    va_list ap;

    assert(name);
    assert(add_stats);
    assert(c);
    assert(fmt);

    va_start(ap, fmt);
    vlen = vsnprintf(val_str, sizeof(val_str) - 1, fmt, ap);
    va_end(ap);

    add_stats(name, strlen(name), val_str, vlen, c);
}",1740.0,1756.0,1.0,17.0,17.0,3,3,17,7,179,0,1,1,0,0,,0,0,8,4,4,void
1592,31728,server_stats,1,server_stats,"void server_stats (ADD_STAT,conn*)",memcached.c,"void server_stats(ADD_STAT add_stats, conn *c) {
    pid_t pid = getpid();
    rel_time_t now = current_time;

    struct thread_stats thread_stats;
    threadlocal_stats_aggregate(&thread_stats);
    struct slab_stats slab_stats;
    slab_stats_aggregate(&thread_stats, &slab_stats);
#ifndef WIN32
    struct rusage usage;
    getrusage(RUSAGE_SELF, &usage);
#endif /* !WIN32 */

    STATS_LOCK();

    APPEND_STAT(""pid"", ""%lu"", (long)pid);
    APPEND_STAT(""uptime"", ""%u"", now - ITEM_UPDATE_INTERVAL);
    APPEND_STAT(""time"", ""%ld"", now + (long)process_started);
    APPEND_STAT(""version"", ""%s"", VERSION);
    APPEND_STAT(""libevent"", ""%s"", event_get_version());
    APPEND_STAT(""pointer_size"", ""%d"", (int)(8 * sizeof(void *)));

#ifndef WIN32
    append_stat(""rusage_user"", add_stats, c, ""%ld.%06ld"",
                (long)usage.ru_utime.tv_sec,
                (long)usage.ru_utime.tv_usec);
    append_stat(""rusage_system"", add_stats, c, ""%ld.%06ld"",
                (long)usage.ru_stime.tv_sec...",1759.0,1903.0,1.0,4.0,145.0,168,8,263,15,1,227,6,6,10,78,,0,147,4,2,2,void
1593,32872,process_stat_settings,1,process_stat_settings,"void process_stat_settings (ADD_STAT,void*)",memcached.c,"void process_stat_settings(ADD_STAT add_stats, void *c) {
    assert(add_stats);
    APPEND_STAT(""maxbytes"", ""%llu"", (unsigned long long)settings.maxbytes);
    APPEND_STAT(""maxconns"", ""%d"", settings.maxconns);
    APPEND_STAT(""tcpport"", ""%d"", settings.port);
    APPEND_STAT(""udpport"", ""%d"", settings.udpport);
    APPEND_STAT(""inter"", ""%s"", settings.inter ? settings.inter : ""NULL"");
    APPEND_STAT(""verbosity"", ""%d"", settings.verbose);
    APPEND_STAT(""oldest"", ""%lu"", (unsigned long)settings.oldest_live);
    APPEND_STAT(""evictions"", ""%s"", settings.evict_to_free ? ""on"" : ""off"");
    APPEND_STAT(""domain_socket"", ""%s"",
                settings.socketpath ? settings.socketpath : ""NULL"");
    APPEND_STAT(""umask"", ""%o"", settings.access);
    APPEND_STAT(""shutdown_command"", ""%s"",
                settings.shutdown_command ? ""yes"" : ""no"");
    APPEND_STAT(""growth_factor"", ""%.2f"", settings.factor);
    APPEND_STAT(""chunk_size"", ""%d"", settings.chunk_size);
    APPEND_STAT(""num_threads"", ""%d"",...",1905.0,1998.0,1.0,4.0,94.0,108,3,197,3,0,233,1,1,0,57,,0,178,4,2,2,void
1594,33689,nz_strcmp,1,nz_strcmp,"int nz_strcmp (int,char*,char*)",memcached.c,"static int nz_strcmp(int nzlength, const char *nz, const char *z) {
    int zlength=strlen(z);
    return (zlength == nzlength) && (strncmp(nz, z, zlength) == 0) ? 0 : -1;
}",2000.0,2003.0,1.0,1.0,4.0,6,5,7,4,0,0,1,1,0,0,,0,0,6,3,3,int
1595,33716,get_stats,1,get_stats,"bool get_stats (char*,int,ADD_STAT,void*)",memcached.c,"bool get_stats(const char *stat_type, int nkey, ADD_STAT add_stats, void *c) {
    bool ret = true;

    if (add_stats != NULL) {
        if (!stat_type) {
            /* prepare general statistics for the engine */
            STATS_LOCK();
            APPEND_STAT(""bytes"", ""%llu"", (unsigned long long)stats_state.curr_bytes);
            APPEND_STAT(""curr_items"", ""%llu"", (unsigned long long)stats_state.curr_items);
            APPEND_STAT(""total_items"", ""%llu"", (unsigned long long)stats.total_items);
            STATS_UNLOCK();
            APPEND_STAT(""slab_global_page_pool"", ""%u"", global_page_pool_size(NULL));
            item_stats_totals(add_stats, c);
        } else if (nz_strcmp(nkey, stat_type, ""items"") == 0) {
            item_stats(add_stats, c);
        } else if (nz_strcmp(nkey, stat_type, ""slabs"") == 0) {
            slabs_stats(add_stats, c);
        } else if (nz_strcmp(nkey, stat_type, ""sizes"") == 0) {
            item_stats_sizes(add_stats, c);
        } else if (nz_s...",2005.0,2036.0,1.0,12.0,32.0,9,5,21,8,1,15,3,4,0,7,,0,7,8,4,4,bool
1596,33874,get_conn_text,1,get_conn_text,"void get_conn_text (conn*,int,char*,sockaddr*)",memcached.c,"static inline void get_conn_text(const conn *c, const int af,
                char* addr, struct sockaddr *sock_addr) {
    char addr_text[MAXPATHLEN];
    addr_text[0] = '\0';
    const char *protoname = ""?"";
    unsigned short port = 0;

    switch (af) {
        case AF_INET:
            (void) inet_ntop(af,
                    &((struct sockaddr_in *)sock_addr)->sin_addr,
                    addr_text,
                    sizeof(addr_text) - 1);
            port = ntohs(((struct sockaddr_in *)sock_addr)->sin_port);
            protoname = IS_UDP(c->transport) ? ""udp"" : ""tcp"";
            break;

        case AF_INET6:
            addr_text[0] = '[';
            addr_text[1] = '\0';
            if (inet_ntop(af,
                    &((struct sockaddr_in6 *)sock_addr)->sin6_addr,
                    addr_text + 1,
                    sizeof(addr_text) - 2)) {
                strncat(addr_text, ""]"", 2);
            }
            port = ntohs(((struct sockaddr_in6 *)sock_addr)->sin6...",2038.0,2112.0,1.0,24.0,75.0,51,12,53,13,0,4,9,8,0,0,,0,4,8,4,4,void
1597,34219,process_stats_conns,1,process_stats_conns,"void process_stats_conns (ADD_STAT,void*)",memcached.c,"void process_stats_conns(ADD_STAT add_stats, void *c) {
    int i;
    char key_str[STAT_KEY_LEN];
    char val_str[STAT_VAL_LEN];
    size_t extras_len = sizeof("":unix:"") + sizeof(""65535"");
    char addr[MAXPATHLEN + extras_len];
    char svr_addr[MAXPATHLEN + extras_len];
    memset(addr, 0, sizeof(addr));
    memset(svr_addr, 0, sizeof(svr_addr));
    int klen = 0, vlen = 0;

    assert(add_stats);

    for (i = 0; i < max_fds; i++) {
        if (conns[i]) {
            /* This is safe to do unlocked because conns are never freed; the
             * worst that'll happen will be a minor inconsistency in the
             * output -- not worth the complexity of the locking that'd be
             * required to prevent it.
             */
            if (IS_UDP(conns[i]->transport)) {
                APPEND_NUM_STAT(i, ""UDP"", ""%s"", ""UDP"");
            }
            if (conns[i]->state != conn_closed) {
                conn_to_str(conns[i], addr, svr_addr);

                APPEND_NUM_...",2147.0,2185.0,1.0,17.0,39.0,49,11,98,17,0,14,6,14,9,2,,0,13,4,2,2,void
1598,34475,limited_get,1,limited_get,"item limited_get (char*,size_t,conn*,uint32_t,bool,bool,bool*)",memcached.c,"item* limited_get(char *key, size_t nkey, conn *c, uint32_t exptime, bool should_touch, bool do_update, bool *overflow) {
    item *it;
    if (should_touch) {
        it = item_touch(key, nkey, exptime, c);
    } else {
        it = item_get(key, nkey, c, do_update);
    }
    if (it && it->refcount > IT_REFCOUNT_LIMIT) {
        item_remove(it);
        it = NULL;
        *overflow = true;
    } else {
        *overflow = false;
    }
    return it;
}",2188.0,2203.0,1.0,29.0,16.0,7,5,14,9,3,2,3,3,0,2,,0,1,14,7,7,item
1599,34534,limited_get_locked,1,limited_get_locked,"item limited_get_locked (char*,size_t,conn*,bool,uint32_t*,bool*)",memcached.c,"item* limited_get_locked(char *key, size_t nkey, conn *c, bool do_update, uint32_t *hv, bool *overflow) {
    item *it;
    it = item_get_locked(key, nkey, c, do_update, hv);
    if (it && it->refcount > IT_REFCOUNT_LIMIT) {
        do_item_remove(it);
        it = NULL;
        item_unlock(*hv);
        *overflow = true;
    } else {
        *overflow = false;
    }
    return it;
}",2209.0,2221.0,1.0,29.0,13.0,8,5,15,9,0,3,2,2,0,3,,0,1,12,6,6,item
1600,34584,do_add_delta,1,do_add_delta,"enum delta_result_type do_add_delta (conn*,char*,size_t,bool,int64_t,char*,uint64_t*,uint32_t,item**)",memcached.c,"enum delta_result_type do_add_delta(conn *c, const char *key, const size_t nkey,
                                    const bool incr, const int64_t delta,
                                    char *buf, uint64_t *cas,
                                    const uint32_t hv,
                                    item **it_ret) {
    char *ptr;
    uint64_t value;
    int res;
    item *it;

    it = do_item_get(key, nkey, hv, c, DONT_UPDATE);
    if (!it) {
        return DELTA_ITEM_NOT_FOUND;
    }

    /* Can't delta zero byte values. 2-byte are the ""\r\n"" */
    /* Also can't delta for chunked items. Too large to be a number */
#ifdef EXTSTORE
    if (it->nbytes <= 2 || (it->it_flags & (ITEM_CHUNKED|ITEM_HDR)) != 0) {
#else
    if (it->nbytes <= 2 || (it->it_flags & (ITEM_CHUNKED)) != 0) {
#endif
        do_item_remove(it);
        return NON_NUMERIC;
    }

    if (cas != NULL && *cas != 0 && ITEM_get_cas(it) != *cas) {
        do_item_remove(it);
        return DELTA_ITEM_CAS_MISMATC...",2234.0,2345.0,1.0,39.0,112.0,120,22,85,22,2,15,10,10,1,10,,0,8,18,9,9,enum delta_result_type
1601,35365,try_read_udp,1,try_read_udp,enum try_read_result try_read_udp (conn*),memcached.c,"static enum try_read_result try_read_udp(conn *c) {
    int res;

    assert(c != NULL);

    c->request_addr_size = sizeof(c->request_addr);
    res = recvfrom(c->sfd, c->rbuf, c->rsize,
                   0, (struct sockaddr *)&c->request_addr,
                   &c->request_addr_size);
    if (res > 8) {
        unsigned char *buf = (unsigned char *)c->rbuf;
        pthread_mutex_lock(&c->thread->stats.mutex);
        c->thread->stats.bytes_read += res;
        pthread_mutex_unlock(&c->thread->stats.mutex);

        /* Beginning of UDP packet is the request ID; save it. */
        c->request_id = buf[0] * 256 + buf[1];

        /* If this is a multi-packet request, drop it. */
        if (buf[4] != 0 || buf[5] != 1) {
            return READ_NO_DATA_RECEIVED;
        }

        /* Don't care about any of the rest of the header. */
        res -= 8;
        memmove(c->rbuf, c->rbuf + 8, res);

        c->rbytes = res;
        c->rcurr = c->rbuf;
        return READ_DATA_RECEIVED;
...",2387.0,2419.0,1.0,1.0,33.0,50,14,33,6,0,17,3,4,0,0,,0,17,2,1,1,enum try_read_result
1602,35503,try_read_network,1,try_read_network,enum try_read_result try_read_network (conn*),memcached.c,"static enum try_read_result try_read_network(conn *c) {
    enum try_read_result gotdata = READ_NO_DATA_RECEIVED;
    int res;
    int num_allocs = 0;
    assert(c != NULL);

    if (c->rcurr != c->rbuf) {
        if (c->rbytes != 0) /* otherwise there's nothing to copy */
            memmove(c->rbuf, c->rcurr, c->rbytes);
        c->rcurr = c->rbuf;
    }

    while (1) {
        // TODO: move to rbuf_* func?
        if (c->rbytes >= c->rsize && c->rbuf_malloced) {
            if (num_allocs == 4) {
                return gotdata;
            }
            ++num_allocs;
            char *new_rbuf = realloc(c->rbuf, c->rsize * 2);
            if (!new_rbuf) {
                STATS_LOCK();
                stats.malloc_fails++;
                STATS_UNLOCK();
                if (settings.verbose > 0) {
                    fprintf(stderr, ""Couldn't realloc input buffer\n"");
                }
                c->rbytes = 0; /* ignore what we read */
                out_of_memory(c, ""SERV...",2433.0,2496.0,1.0,1.0,64.0,76,19,67,19,0,36,15,29,9,2,,0,33,2,1,1,enum try_read_result
1603,35828,do_accept_new_conns,1,do_accept_new_conns,void do_accept_new_conns (bool),memcached.c,"void do_accept_new_conns(const bool do_accept) {
    conn *next;

    for (next = listen_conn; next; next = next->next) {
        if (do_accept) {
            update_event(next, EV_READ | EV_PERSIST);
            if (listen(next->sfd, settings.backlog) != 0) {
                perror(""listen"");
            }
        }
        else {
            update_event(next, 0);
            if (listen(next->sfd, 0) != 0) {
                perror(""listen"");
            }
        }
    }

    if (do_accept) {
        struct timeval maxconns_exited;
        uint64_t elapsed_us;
        gettimeofday(&maxconns_exited,NULL);
        STATS_LOCK();
        elapsed_us =
            (maxconns_exited.tv_sec - stats.maxconns_entered.tv_sec) * 1000000
            + (maxconns_exited.tv_usec - stats.maxconns_entered.tv_usec);
        stats.time_in_listen_disabled_us += elapsed_us;
        stats_state.accepting_conns = true;
        STATS_UNLOCK();
    } else {
        STATS_LOCK();
        stats_state.acceptin...",2515.0,2553.0,1.0,1.0,39.0,21,10,21,12,0,15,5,8,3,1,,0,12,2,1,1,void
1604,35954,_transmit_pre,1,_transmit_pre,"int _transmit_pre (conn*,iovec*,int,bool)",memcached.c,"static int _transmit_pre(conn *c, struct iovec *iovs, int iovused, bool one_resp) {
    mc_resp *resp = c->resp_head;
    while (resp && iovused + resp->iovcnt < IOV_MAX-1) {
        if (resp->skip) {
            // Don't actually unchain the resp obj here since it's singly-linked.
            // Just let the post function handle it linearly.
            resp = resp->next;
            continue;
        }
        if (resp->chunked_data_iov) {
            // Handle chunked items specially.
            // They spend much more time in send so we can be a bit wasteful
            // in rebuilding iovecs for them.
            item_chunk *ch = (item_chunk *)ITEM_schunk((item *)resp->iov[resp->chunked_data_iov].iov_base);
            int x;
            for (x = 0; x < resp->iovcnt; x++) {
                // This iov is tracking how far we've copied so far.
                if (x == resp->chunked_data_iov) {
                    int done = resp->chunked_total - resp->iov[x].iov_len;
          ...",2557.0,2620.0,1.0,43.0,64.0,104,19,71,13,2,1,16,36,0,0,,0,1,8,4,4,int
1605,36294,_transmit_post,1,_transmit_post,"void _transmit_post (conn*,ssize_t)",memcached.c,"static void _transmit_post(conn *c, ssize_t res) {
    // We've written some of the data. Remove the completed
    // responses from the list of pending writes.
    mc_resp *resp = c->resp_head;
    while (resp) {
        int x;
        if (resp->skip) {
            resp = resp_finish(c, resp);
            continue;
        }

        // fastpath check. all small responses should cut here.
        if (res >= resp->tosend) {
            res -= resp->tosend;
            resp = resp_finish(c, resp);
            continue;
        }

        // it's fine to re-check iov's that were zeroed out before.
        for (x = 0; x < resp->iovcnt; x++) {
            struct iovec *iov = &resp->iov[x];
            if (res >= iov->iov_len) {
                resp->tosend -= iov->iov_len;
                res -= iov->iov_len;
                iov->iov_len = 0;
            } else {
                // Dumb special case for chunked items. Currently tracking
                // where to inject the chunked ite...",2626.0,2674.0,1.0,1.0,49.0,28,8,31,5,3,4,9,13,0,3,,0,4,4,2,2,void
1606,36439,transmit,1,transmit,enum transmit_result transmit (conn*),memcached.c,"static enum transmit_result transmit(conn *c) {
    assert(c != NULL);
    struct iovec iovs[IOV_MAX];
    struct msghdr msg;
    int iovused = 0;

    // init the msg.
    memset(&msg, 0, sizeof(struct msghdr));
    msg.msg_iov = iovs;

    iovused = _transmit_pre(c, iovs, iovused, TRANSMIT_ALL_RESP);
    if (iovused == 0) {
        // Avoid the syscall if we're only handling a noreply.
        // Return the response object.
        _transmit_post(c, 0);
        return TRANSMIT_COMPLETE;
    }

    // Alright, send.
    ssize_t res;
    msg.msg_iovlen = iovused;
    res = c->sendmsg(c, &msg, 0);
    if (res >= 0) {
        pthread_mutex_lock(&c->thread->stats.mutex);
        c->thread->stats.bytes_written += res;
        pthread_mutex_unlock(&c->thread->stats.mutex);

        // Decrement any partial IOV's and complete any finished resp's.
        _transmit_post(c, res);

        if (c->resp_head) {
            return TRANSMIT_INCOMPLETE;
        } else {
            return TRANSMI...",2685.0,2738.0,1.0,46.0,54.0,39,15,48,20,0,15,8,12,6,7,,0,11,2,1,1,enum transmit_result
1607,36599,build_udp_header,1,build_udp_header,"void build_udp_header (unsigned char*,mc_resp*)",memcached.c,"static void build_udp_header(unsigned char *hdr, mc_resp *resp) {
    // We need to communicate the total number of packets
    // If this isn't set, it's the first time this response is building a udp
    // header, so ""tosend"" must be static.
    if (!resp->udp_total) {
        uint32_t total;
        total = resp->tosend / UDP_DATA_SIZE;
        if (resp->tosend % UDP_DATA_SIZE)
            total++;
        // The spec doesn't really say what we should do here. It's _probably_
        // better to bail out?
        if (total > USHRT_MAX) {
            total = USHRT_MAX;
        }
        resp->udp_total = total;
    }

    // TODO: why wasn't this hto*'s and casts?
    // this ends up sending UDP hdr data specifically in host byte order.
    *hdr++ = resp->request_id / 256;
    *hdr++ = resp->request_id % 256;
    *hdr++ = resp->udp_sequence / 256;
    *hdr++ = resp->udp_sequence % 256;
    *hdr++ = resp->udp_total / 256;
    *hdr++ = resp->udp_total % 256;
    *hdr++ = 0;
    *h...",2740.0,2768.0,1.0,31.0,29.0,50,8,26,4,1,0,4,6,0,0,,0,0,4,2,2,void
1608,36713,transmit_udp,1,transmit_udp,enum transmit_result transmit_udp (conn*),memcached.c,"static enum transmit_result transmit_udp(conn *c) {
    assert(c != NULL);
    struct iovec iovs[IOV_MAX];
    struct msghdr msg;
    mc_resp *resp;
    int iovused = 0;
    unsigned char udp_hdr[UDP_HEADER_SIZE];

    // We only send one UDP packet per call (ugh), so we can only operate on a
    // single response at a time.
    resp = c->resp_head;

    if (!resp) {
        return TRANSMIT_COMPLETE;
    }

    if (resp->skip) {
        resp = resp_finish(c, resp);
        return TRANSMIT_INCOMPLETE;
    }

    // clear the message and initialize it.
    memset(&msg, 0, sizeof(struct msghdr));
    msg.msg_iov = iovs;

    // the UDP source to return to.
    msg.msg_name = &resp->request_addr;
    msg.msg_namelen = resp->request_addr_size;

    // First IOV is the custom UDP header.
    iovs[0].iov_base = (void *)udp_hdr;
    iovs[0].iov_len = UDP_HEADER_SIZE;
    build_udp_header(udp_hdr, resp);
    iovused++;

    // Fill the IOV's the standard way.
    // TODO: might get a small ...",2782.0,2877.0,1.0,26.0,96.0,73,22,78,25,0,17,12,16,6,7,,0,13,2,1,1,enum transmit_result
1609,36989,read_into_chunked_item,1,read_into_chunked_item,int read_into_chunked_item (conn*),memcached.c,"static int read_into_chunked_item(conn *c) {
    int total = 0;
    int res;
    assert(c->rcurr != c->ritem);

    while (c->rlbytes > 0) {
        item_chunk *ch = (item_chunk *)c->ritem;
        if (ch->size == ch->used) {
            // FIXME: ch->next is currently always 0. remove this?
            if (ch->next) {
                c->ritem = (char *) ch->next;
            } else {
                /* Allocate next chunk. Binary protocol needs 2b for \r\n */
                c->ritem = (char *) do_item_alloc_chunk(ch, c->rlbytes +
                       ((c->protocol == binary_prot) ? 2 : 0));
                if (!c->ritem) {
                    // We failed an allocation. Let caller handle cleanup.
                    total = -2;
                    break;
                }
                // ritem has new chunk, restart the loop.
                continue;
                //assert(c->rlbytes == 0);
            }
        }

        int unused = ch->size - ch->used;
        /* first...",2884.0,2961.0,1.0,1.0,78.0,73,16,56,6,0,22,11,21,7,1,,0,22,2,1,1,int
1610,38523,maximize_sndbuf,1,maximize_sndbuf,void maximize_sndbuf (int),memcached.c,"static void maximize_sndbuf(const int sfd) {
    socklen_t intsize = sizeof(int);
    int last_good = 0;
    int min, max, avg;
    int old_size;

    /* Start with the default size. */
#ifdef _WIN32
    if (getsockopt((SOCKET)sfd, SOL_SOCKET, SO_SNDBUF, (char *)&old_size, &intsize) != 0) {
#else
    if (getsockopt(sfd, SOL_SOCKET, SO_SNDBUF, &old_size, &intsize) != 0) {
#endif /* #ifdef _WIN32 */
        if (settings.verbose > 0)
            perror(""getsockopt(SO_SNDBUF)"");
        return;
    }

    /* Binary-search for the real maximum. */
    min = old_size;
    max = MAX_SENDBUF_SIZE;

    while (min <= max) {
        avg = ((unsigned int)(min + max)) / 2;
        if (setsockopt(sfd, SOL_SOCKET, SO_SNDBUF, (void *)&avg, intsize) == 0) {
            last_good = avg;
            min = avg + 1;
        } else {
            max = avg - 1;
        }
    }

    if (settings.verbose > 1)
        fprintf(stderr, ""<%d send buffer was %d, now %d\n"", sfd, old_size, last_good);
}",3435.0,3468.0,1.0,10.0,34.0,25,12,31,12,1,4,6,8,4,0,,0,4,2,1,1,void
1611,38630,server_socket,1,server_socket,"int server_socket (char*,int,network_transport,FILE*,bool,uint64_t,protocol)",memcached.c,"static int server_socket(const char *interface,
                         int port,
                         enum network_transport transport,
                         FILE *portnumber_file, bool ssl_enabled,
                         uint64_t conntag,
                         enum protocol bproto) {
    int sfd;
    struct linger ling = {0, 0};
    struct addrinfo *ai;
    struct addrinfo *next;
    struct addrinfo hints = { .ai_flags = AI_PASSIVE,
                              .ai_family = AF_UNSPEC };
    char port_buf[NI_MAXSERV];
    int error;
    int success = 0;
    int flags =1;

    hints.ai_socktype = IS_UDP(transport) ? SOCK_DGRAM : SOCK_STREAM;

    if (port == -1) {
        port = 0;
    }
    snprintf(port_buf, sizeof(port_buf), ""%d"", port);
    error= getaddrinfo(interface, port_buf, &hints, &ai);
    if (error != 0) {
        if (error != EAI_SYSTEM)
          fprintf(stderr, ""getaddrinfo(): %s\n"", gai_strerror(error));
        else
          perror(""getaddrinfo()"");
...",3479.0,3656.0,1.0,24.0,178.0,50,13,84,40,1,7,17,32,5,3,,0,5,14,7,7,int
1612,39120,server_sockets,1,server_sockets,"int server_sockets (int,network_transport,FILE*)",memcached.c,"static int server_sockets(int port, enum network_transport transport,
                          FILE *portnumber_file) {
    bool ssl_enabled = false;
    uint64_t conntag = 0;

#ifdef TLS
    const char *notls = ""notls"";
    ssl_enabled = settings.ssl_enabled;
#endif

    if (settings.inter == NULL) {
        return server_socket(settings.inter, port, transport, portnumber_file, ssl_enabled, conntag, settings.binding_protocol);
    } else {
        // tokenize them and bind to each one of them..
        char *b;
        int ret = 0;
        char *list = strdup(settings.inter);

        if (list == NULL) {
            fprintf(stderr, ""Failed to allocate memory for parsing server interface string\n"");
            return 1;
        }
        // If we encounter any failure, preserve the first errno for the caller.
        int errno_save = 0;
        for (char *p = strtok_r(list, "";,"", &b);
            p != NULL;
            p = strtok_r(NULL, "";,"", &b)) {
            int the_port = por...",3658.0,3816.0,1.0,1.0,159.0,6,3,12,8,2,7,2,2,2,1,,0,6,6,3,3,int
1613,39550,new_socket_unix,1,new_socket_unix,int new_socket_unix (void),memcached.c,"static int new_socket_unix(void) {
    int sfd;
    int flags;

    if ((sfd = socket(AF_UNIX, SOCK_STREAM, 0)) == -1) {
        perror(""socket()"");
        return -1;
    }

    if ((flags = fcntl(sfd, F_GETFL, 0)) < 0 ||
        fcntl(sfd, F_SETFL, flags | O_NONBLOCK) < 0) {
        perror(""setting O_NONBLOCK"");
        close(sfd);
        return -1;
    }
    return sfd;
}",3819.0,3835.0,1.0,1.0,17.0,10,6,12,7,1,0,3,3,0,0,,0,0,2,1,1,int
1614,39601,server_socket_unix,1,server_socket_unix,"int server_socket_unix (char*,int)",memcached.c,"static int server_socket_unix(const char *path, int access_mask) {
    int sfd;
    struct linger ling = {0, 0};
    struct sockaddr_un addr;
    struct stat tstat;
    int flags =1;
    int old_umask;

    if (!path) {
        return 1;
    }

    if ((sfd = new_socket_unix()) == -1) {
        return 1;
    }

    /*
     * Clean up a previous socket file if we left it around
     */
    if (lstat(path, &tstat) == 0) {
        if (S_ISSOCK(tstat.st_mode))
            unlink(path);
    }

    setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void *)&flags, sizeof(flags));
    setsockopt(sfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flags, sizeof(flags));
    setsockopt(sfd, SOL_SOCKET, SO_LINGER, (void *)&ling, sizeof(ling));

    /*
     * the memset call clears nonstandard fields in some implementations
     * that otherwise mess things up.
     */
    memset(&addr, 0, sizeof(addr));

    addr.sun_family = AF_UNIX;
    strncpy(addr.sun_path, path, sizeof(addr.sun_path) - 1);
    assert(strcmp(...",3837.0,3895.0,1.0,1.0,59.0,44,13,54,23,1,8,8,9,8,2,,0,8,4,2,2,int
1615,39788,clock_handler,1,clock_handler,"void clock_handler (evutil_socket_t,short,void*)",memcached.c,"static void clock_handler(const evutil_socket_t fd, const short which, void *arg) {
    struct timeval t = {.tv_sec = 1, .tv_usec = 0};
    static bool initialized = false;

    if (initialized) {
        /* only delete the event if it's actually there. */
        evtimer_del(&clockevent);
    } else {
        initialized = true;
    }

    // While we're here, check for hash table expansion.
    // This function should be quick to avoid delaying the timer.
    assoc_start_expand(stats_state.curr_items);
    // also, if HUP'ed we need to do some maintenance.
    // for now that's just the authfile reload.
    if (settings.sig_hup) {
        settings.sig_hup = false;

        authfile_load(settings.auth_file);
#ifdef PROXY
        if (settings.proxy_ctx) {
            proxy_start_reload(settings.proxy_ctx);
        }
#endif
    }

    evtimer_set(&clockevent, clock_handler, 0);
    event_base_set(main_base, &clockevent);
    evtimer_add(&clockevent, &t);

#ifdef MEMCACHED_DEBUG
    i...",3923.0,3980.0,1.0,1.0,58.0,20,6,22,13,1,15,3,3,2,2,,0,13,6,3,3,void
1616,39869,flag_enabled_disabled,1,flag_enabled_disabled,const char* flag_enabled_disabled (bool),memcached.c,"static const char* flag_enabled_disabled(bool flag) {
    return (flag ? ""enabled"" : ""disabled"");
}",3982.0,3984.0,1.0,1.0,3.0,1,1,1,1,1,0,1,1,0,0,,0,0,2,1,1,const char*
1617,39879,verify_default,1,verify_default,"void verify_default (char*,bool)",memcached.c,"static void verify_default(const char* param, bool condition) {
    if (!condition) {
        printf(""Default value of [%s] has changed.""
            "" Modify the help text and default value check.\n"", param);
        exit(EXIT_FAILURE);
    }
}",3986.0,3992.0,1.0,1.0,7.0,1,1,3,3,6,0,2,2,0,0,,0,0,4,2,2,void
1618,39894,usage,1,usage,void usage (void),timedrun.c,"static void usage(void) {
    fprintf(stderr, ""./timedrun <naptime in sec> args...\n"");
    exit(-1);
}",94.0,97.0,1.0,1.0,4.0,54,6,32,1,1,71,1,1,0,7,,0,64,2,1,1,void
1619,40109,usage_license,1,usage_license,void usage_license (void),memcached.c,"static void usage_license(void) {
    printf(PACKAGE "" "" VERSION ""\n\n"");
    printf(
    ""Copyright (c) 2003, Danga Interactive, Inc. <http://www.danga.com/>\n""
    ""All rights reserved.\n""
    ""\n""
    ""Redistribution and use in source and binary forms, with or without\n""
    ""modification, are permitted provided that the following conditions are\n""
    ""met:\n""
    ""\n""
    ""    * Redistributions of source code must retain the above copyright\n""
    ""notice, this list of conditions and the following disclaimer.\n""
    ""\n""
    ""    * Redistributions in binary form must reproduce the above\n""
    ""copyright notice, this list of conditions and the following disclaimer\n""
    ""in the documentation and/or other materials provided with the\n""
    ""distribution.\n""
    ""\n""
    ""    * Neither the name of the Danga Interactive nor the names of its\n""
    ""contributors may be used to endorse or promote products derived from\n""
    ""this software without specific prior written permission....",4189.0,4258.0,1.0,1.0,70.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
1620,40118,save_pid,1,save_pid,void save_pid (char*),memcached.c,"static void save_pid(const char *pid_file) {
    FILE *fp;
    if (access(pid_file, F_OK) == 0) {
        if ((fp = fopen(pid_file, ""r"")) != NULL) {
            char buffer[1024];
            if (fgets(buffer, sizeof(buffer), fp) != NULL) {
                unsigned int pid;
                if (safe_strtoul(buffer, &pid) && kill((pid_t)pid, 0) == 0) {
                    fprintf(stderr, ""WARNING: The pid file contained the following (running) pid: %u\n"", pid);
                }
            }
            fclose(fp);
        }
    }

    /* Create the pid file first with a temporary name, then
     * atomically move the file to the real name to avoid a race with
     * another process opening the file to read the pid, but finding
     * it empty.
     */
    char tmp_pid_file[1024];
    snprintf(tmp_pid_file, sizeof(tmp_pid_file), ""%s.tmp"", pid_file);

    if ((fp = fopen(tmp_pid_file, ""w"")) == NULL) {
        vperror(""Could not open the pid file %s for writing"", tmp_pid_file);
       ...",4260.0,4297.0,1.0,1.0,38.0,16,8,29,8,1,4,8,14,1,4,,0,1,2,1,1,void
1621,40218,remove_pidfile,1,remove_pidfile,void remove_pidfile (char*),memcached.c,"static void remove_pidfile(const char *pid_file) {
  if (pid_file == NULL)
      return;

  if (unlink(pid_file) != 0) {
      vperror(""Could not remove the pid file %s"", pid_file);
  }

}",4299.0,4307.0,1.0,1.0,9.0,2,2,4,2,1,1,3,3,0,1,,0,0,2,1,1,void
1622,40238,sig_handler,1,sig_handler,void sig_handler (int),memcached.c,"static void sig_handler(const int sig) {
    stop_main_loop = EXIT_NORMALLY;
    printf(""Signal handled: %s.\n"", strsignal(sig));
}",4309.0,4312.0,1.0,1.0,4.0,1,1,3,3,0,1,1,1,0,0,,0,1,2,1,1,void
1623,40250,sighup_handler,1,sighup_handler,void sighup_handler (int),memcached.c,"static void sighup_handler(const int sig) {
    settings.sig_hup = true;
}",4314.0,4316.0,1.0,1.0,3.0,2,2,2,2,0,2,1,1,0,0,,0,2,2,1,1,void
1624,40260,sig_usrhandler,1,sig_usrhandler,void sig_usrhandler (int),memcached.c,"static void sig_usrhandler(const int sig) {
    printf(""Graceful shutdown signal handled: %s.\n"", strsignal(sig));
    stop_main_loop = GRACE_STOP;
}",4318.0,4321.0,1.0,1.0,4.0,1,1,3,3,0,1,1,1,0,0,,0,1,2,1,1,void
1625,40272,enable_large_pages,1,enable_large_pages,int enable_large_pages (void),memcached.c,"static int enable_large_pages(void) {
#if defined(HAVE_GETPAGESIZES) && defined(HAVE_MEMCNTL)
    int ret = -1;
    size_t sizes[32];
    int avail = getpagesizes(sizes, 32);
    if (avail != -1) {
        size_t max = sizes[0];
        struct memcntl_mha arg = {0};
        int ii;

        for (ii = 1; ii < avail; ++ii) {
            if (max < sizes[ii]) {
                max = sizes[ii];
            }
        }

        arg.mha_flags   = 0;
        arg.mha_pagesize = max;
        arg.mha_cmd = MHA_MAPSIZE_BSSBRK;

        if (memcntl(0, 0, MC_HAT_ADVISE, (caddr_t)&arg, 0, 0) == -1) {
            fprintf(stderr, ""Failed to set large pages: %s\n"",
                    strerror(errno));
            fprintf(stderr, ""Will use default page size\n"");
        } else {
            ret = 0;
        }
    } else {
        fprintf(stderr, ""Failed to get supported pagesizes: %s\n"",
                strerror(errno));
        fprintf(stderr, ""Will use default page size\n"");
    }

    return ret;
...",4327.0,4414.0,1.0,1.0,88.0,1,1,0,0,1,0,1,1,0,0,,0,0,2,1,1,int
1626,40280,sanitycheck,1,sanitycheck,bool sanitycheck (void),memcached.c,"static bool sanitycheck(void) {
    /* One of our biggest problems is old and bogus libevents */
    const char *ever = event_get_version();
    if (ever != NULL) {
        if (strncmp(ever, ""1."", 2) == 0) {
            fprintf(stderr, ""You are using libevent %s.\nPlease upgrade to 2.x""
                        "" or newer\n"", event_get_version());
            return false;
        }
    }

    return true;
}",4420.0,4432.0,1.0,1.0,13.0,3,3,7,5,1,0,3,4,0,0,,0,0,2,1,1,bool
1627,40310,_parse_slab_sizes,1,_parse_slab_sizes,"bool _parse_slab_sizes (char*,uint32_t*)",memcached.c,"static bool _parse_slab_sizes(char *s, uint32_t *slab_sizes) {
    char *b = NULL;
    uint32_t size = 0;
    int i = 0;
    uint32_t last_size = 0;

    if (strlen(s) < 1)
        return false;

    for (char *p = strtok_r(s, ""-"", &b);
         p != NULL;
         p = strtok_r(NULL, ""-"", &b)) {
        if (!safe_strtoul(p, &size) || size < settings.chunk_size
             || size > settings.slab_chunk_size_max) {
            fprintf(stderr, ""slab size %u is out of valid range\n"", size);
            return false;
        }
        if (last_size >= size) {
            fprintf(stderr, ""slab size %u cannot be lower than or equal to a previous class size\n"", size);
            return false;
        }
        if (size <= last_size + CHUNK_ALIGN_BYTES) {
            fprintf(stderr, ""slab size %u must be at least %d bytes larger than previous class\n"",
                    size, CHUNK_ALIGN_BYTES);
            return false;
        }
        slab_sizes[i++] = size;
        last_size = size;...",4434.0,4470.0,1.0,32.0,37.0,28,14,42,12,1,5,7,11,5,1,,0,5,4,2,2,bool
1628,40454,_mc_meta_save_cb,1,_mc_meta_save_cb,"int _mc_meta_save_cb (char*,void*,void*)",memcached.c,"static int _mc_meta_save_cb(const char *tag, void *ctx, void *data) {
    struct _mc_meta_data *meta = (struct _mc_meta_data *)data;

    // Settings to remember.
    // TODO: should get a version of version which is numeric, else
    // comparisons for compat reasons are difficult.
    // it may be possible to punt on this for now; since we can test for the
    // absence of another key... such as the new numeric version.
    //restart_set_kv(ctx, ""version"", ""%s"", VERSION);
    // We hold the original factor or subopts _string_
    // it can be directly compared without roundtripping through floats or
    // serializing/deserializing the long options list.
    restart_set_kv(ctx, ""slab_config"", ""%s"", meta->slab_config);
    restart_set_kv(ctx, ""maxbytes"", ""%llu"", (unsigned long long) settings.maxbytes);
    restart_set_kv(ctx, ""chunk_size"", ""%d"", settings.chunk_size);
    restart_set_kv(ctx, ""item_size_max"", ""%d"", settings.item_size_max);
    restart_set_kv(ctx, ""slab_chunk_size_ma...",4487.0,4539.0,1.0,1.0,53.0,22,6,36,9,0,41,1,1,0,19,,0,24,6,3,3,int
1629,40600,_mc_meta_load_cb,1,_mc_meta_load_cb,"int _mc_meta_load_cb (char*,void*,void*)",memcached.c,"static int _mc_meta_load_cb(const char *tag, void *ctx, void *data) {
    struct _mc_meta_data *meta = (struct _mc_meta_data *)data;
    char *key;
    char *val;
    int reuse_mmap = 0;
    meta->process_started = 0;
    meta->time_delta = 0;
    meta->current_time = 0;
    int lines_seen = 0;

    // TODO: not sure this is any better than just doing an if/else tree with
    // strcmp's...
    enum {
        R_MMAP_OLDBASE = 0,
        R_MAXBYTES,
        R_CHUNK_SIZE,
        R_ITEM_SIZE_MAX,
        R_SLAB_CHUNK_SIZE_MAX,
        R_SLAB_PAGE_SIZE,
        R_SLAB_CONFIG,
        R_USE_CAS,
        R_SLAB_REASSIGN,
        R_CURRENT_CAS,
        R_OLDEST_CAS,
        R_OLDEST_LIVE,
        R_LOGGER_GID,
        R_CURRENT_TIME,
        R_STOP_TIME,
        R_PROCESS_STARTED,
        R_HASHPOWER,
    };

    const char *opts[] = {
        [R_MMAP_OLDBASE] = ""mmap_oldbase"",
        [R_MAXBYTES] = ""maxbytes"",
        [R_CHUNK_SIZE] = ""chunk_size"",
        [R_ITEM_SIZE_MAX] = ""item_size...",4551.0,4760.0,1.0,21.0,210.0,142,15,149,38,0,34,44,64,31,15,,0,34,6,3,3,int
1630,41195,main,1,main,"int main (int,char**)",vendor\mcmc\example.c,"int main (int argc, char *agv[]) {
    // TODO: detect if C is pre-C11?
    printf(""C version: %ld\n"", __STDC_VERSION__);

    if (signal(SIGPIPE, SIG_IGN) == SIG_ERR) {
        perror(""signal"");
        exit(1);
    }
/*
    void *c = malloc(mcmc_size(MCMC_OPTION_BLANK));
    // we only ""need"" the minimum buf size.
    // buffers large enough to fit return values result in fewer syscalls.
    size_t bufsize = mcmc_min_buffer_size(MCMC_OPTION_BLANK) * 2;
    // buffers are also generally agnostic to clients. The buffer must be
    // held and re-used when required by the API. When the buffer is empty,
    // it may be released to a pool or reused with other connections.
    char *rbuf = malloc(bufsize);

    int status;

    // API is blocking by default.
    status = mcmc_connect(c, ""127.0.0.1"", ""11211"", MCMC_OPTION_BLANK);

    if (status != MCMC_CONNECTED) {
        // TODO: mc_strerr(c);
        fprintf(stderr, ""Failed to connect to memcached\n"");
        return -1;
    }

    c...",172.0,292.0,1.0,31.0,121.0,586,27,777,129,0,412,213,349,178,45,,0,385,4,2,2,int
1631,44160,ADD_STAT,1,ADD_STAT,"void ADD_STAT (char*,uint16_t,char*,uint32_t,void*)",memcached.h,"typedef void (*ADD_STAT)(const char *key, const uint16_t klen,
                         const char *val, const uint32_t vlen,
                         const void *cookie);",189.0,191.0,14.0,44.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,10,5,5,void
1632,44532,io_queue_stack_cb,1,io_queue_stack_cb,void io_queue_stack_cb (io_queue_t*),memcached.h,typedef void (*io_queue_stack_cb)(io_queue_t *q);,670.0,670.0,14.0,48.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
1633,44537,io_queue_cb,1,io_queue_cb,void io_queue_cb (io_pending_t*),memcached.h,typedef void (*io_queue_cb)(io_pending_t *pending);,671.0,671.0,14.0,50.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
1634,44718,try_read_command,1,conn.try_read_command,int conn.try_read_command (conn*),memcached.h,int (*try_read_command)(conn *c);,872.0,872.0,9.0,36.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
1635,44723,read,1,conn.read,"ssize_t conn.read (conn*,void*,size_t)",memcached.h,"ssize_t (*read)(conn  *c, void *buf, size_t count);",873.0,873.0,13.0,54.0,1.0,0,0,0,0,8,0,1,1,0,0,,0,0,6,3,3,ssize_t
1636,44730,sendmsg,1,conn.sendmsg,"ssize_t conn.sendmsg (conn*,msghdr*,int)",memcached.h,"ssize_t (*sendmsg)(conn *c, struct msghdr *msg, int flags);",874.0,874.0,13.0,62.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,ssize_t
1637,44737,write,1,conn.write,"ssize_t conn.write (conn*,void*,size_t)",memcached.h,"ssize_t (*write)(conn *c, void *buf, size_t count);",875.0,875.0,13.0,54.0,1.0,0,0,0,0,3,0,1,1,0,0,,0,0,6,3,3,ssize_t
1638,44838,memcached_thread_init,1,memcached_thread_init,"void memcached_thread_init (int,void*)",thread.c,"void memcached_thread_init(int nthreads, void *arg) {
    int         i;
    int         power;

    for (i = 0; i < POWER_LARGEST; i++) {
        pthread_mutex_init(&lru_locks[i], NULL);
    }
    pthread_mutex_init(&worker_hang_lock, NULL);

    pthread_mutex_init(&init_lock, NULL);
    pthread_cond_init(&init_cond, NULL);

    /* Want a wide lock table, but don't waste memory */
    if (nthreads < 3) {
        power = 10;
    } else if (nthreads < 4) {
        power = 11;
    } else if (nthreads < 5) {
        power = 12;
    } else if (nthreads <= 10) {
        power = 13;
    } else if (nthreads <= 20) {
        power = 14;
    } else {
        /* 32k buckets. just under the hashpower default. */
        power = 15;
    }

    if (power >= hashpower) {
        fprintf(stderr, ""Hash table power size (%d) cannot be equal to or less than item lock table (%d)\n"", hashpower, power);
        fprintf(stderr, ""Item lock table grows with `-t N` (worker threadcount)\n"");
        fprintf(...",1009.0,1096.0,1.0,20.0,88.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
1639,44844,redispatch_conn,1,redispatch_conn,void redispatch_conn (conn*),thread.c,"void redispatch_conn(conn *c) {
    notify_worker_fd(c->thread, c->sfd, queue_redispatch);
}",754.0,756.0,1.0,1.0,3.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
1640,44849,timeout_conn,1,timeout_conn,void timeout_conn (conn*),thread.c,"void timeout_conn(conn *c) {
    notify_worker_fd(c->thread, c->sfd, queue_timeout);
}",758.0,760.0,1.0,1.0,3.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
1641,44854,return_io_pending,1,return_io_pending,void return_io_pending (io_pending_t*),thread.c,"void return_io_pending(io_pending_t *io) {
    CQ_ITEM *item = cqi_new(io->thread->ev_queue);
    if (item == NULL) {
        // TODO: how can we avoid this?
        // In the main case I just loop, since a malloc failure here for a
        // tiny object that's generally in a fixed size queue is going to
        // implode shortly.
        return;
    }

    item->mode = queue_return_io;
    item->io = io;

    notify_worker(io->thread, item);
}",767.0,781.0,1.0,1.0,15.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
1642,44859,dispatch_conn_new,1,dispatch_conn_new,"void dispatch_conn_new (int,conn_states,int,int,network_transport,void*,uint64_t,protocol)",thread.c,"void dispatch_conn_new(int sfd, enum conn_states init_state, int event_flags,
                       int read_buffer_size, enum network_transport transport, void *ssl,
                       uint64_t conntag, enum protocol bproto) {
    CQ_ITEM *item = NULL;
    LIBEVENT_THREAD *thread;

    if (!settings.num_napi_ids)
        thread = select_thread_round_robin();
    else
        thread = select_thread_by_napi_id(sfd);

    item = cqi_new(thread->ev_queue);
    if (item == NULL) {
        close(sfd);
        /* given that malloc failed this may also fail, but let's try */
        fprintf(stderr, ""Failed to allocate memory for connection object\n"");
        return;
    }

    item->sfd = sfd;
    item->init_state = init_state;
    item->event_flags = event_flags;
    item->read_buffer_size = read_buffer_size;
    item->transport = transport;
    item->mode = queue_new_conn;
    item->ssl = ssl;
    item->conntag = conntag;
    item->bproto = bproto;

    MEMCACHED_CONN_DISPATCH(sfd,...",717.0,748.0,1.0,4.0,32.0,0,0,0,0,1,0,1,1,0,0,,0,0,16,8,8,void
1643,44871,sidethread_conn_close,1,sidethread_conn_close,void sidethread_conn_close (conn*),thread.c,"void sidethread_conn_close(conn *c) {
    if (settings.verbose > 1)
        fprintf(stderr, ""<%d connection closing from side thread.\n"", c->sfd);

    c->state = conn_closing;
    // redispatch will see closing flag and properly close connection.
    redispatch_conn(c);
    return;
}",784.0,792.0,1.0,1.0,9.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,void
1644,44878,accept_new_conns,1,accept_new_conns,void accept_new_conns (bool),thread.c,"void accept_new_conns(const bool do_accept) {
    pthread_mutex_lock(&conn_lock);
    do_accept_new_conns(do_accept);
    pthread_mutex_unlock(&conn_lock);
}",395.0,399.0,1.0,1.0,5.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
1645,44893,item_alloc,1,item_alloc,"item* item_alloc (char*,size_t,int,rel_time_t,int)",thread.c,"item *item_alloc(char *key, size_t nkey, int flags, rel_time_t exptime, int nbytes) {
    item *it;
    /* do_item_alloc handles its own locks */
    it = do_item_alloc(key, nkey, flags, exptime, nbytes);
    return it;
}",799.0,804.0,1.0,1.0,6.0,0,0,0,0,4,0,1,1,0,0,,0,0,10,5,5,item
1646,44902,item_get,1,item_get,"item* item_get (char*,size_t,conn*,bool)",thread.c,"item *item_get(const char *key, const size_t nkey, conn *c, const bool do_update) {
    item *it;
    uint32_t hv;
    hv = hash(key, nkey);
    item_lock(hv);
    it = do_item_get(key, nkey, hv, c, do_update);
    item_unlock(hv);
    return it;
}",810.0,818.0,1.0,1.0,9.0,0,0,0,0,1,0,1,1,0,0,,0,0,8,4,4,item
1647,44910,item_get_locked,1,item_get_locked,"item* item_get_locked (char*,size_t,conn*,bool,uint32_t*)",thread.c,"item *item_get_locked(const char *key, const size_t nkey, conn *c, const bool do_update, uint32_t *hv) {
    item *it;
    *hv = hash(key, nkey);
    item_lock(*hv);
    it = do_item_get(key, nkey, *hv, c, do_update);
    return it;
}",823.0,829.0,1.0,1.0,7.0,0,0,0,0,4,0,1,1,0,0,,0,0,10,5,5,item
1648,44919,item_touch,1,item_touch,"item* item_touch (char*,size_t,uint32_t,conn*)",thread.c,"item *item_touch(const char *key, size_t nkey, uint32_t exptime, conn *c) {
    item *it;
    uint32_t hv;
    hv = hash(key, nkey);
    item_lock(hv);
    it = do_item_touch(key, nkey, exptime, hv, c);
    item_unlock(hv);
    return it;
}",831.0,839.0,1.0,1.0,9.0,0,0,0,0,2,0,1,1,0,0,,0,0,8,4,4,item
1649,44927,item_link,1,item_link,int item_link (item*),thread.c,"int item_link(item *item) {
    int ret;
    uint32_t hv;

    hv = hash(ITEM_key(item), item->nkey);
    item_lock(hv);
    ret = do_item_link(item, hv);
    item_unlock(hv);
    return ret;
}",844.0,853.0,1.0,14.0,10.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
1650,44932,item_remove,1,item_remove,void item_remove (item*),thread.c,"void item_remove(item *item) {
    uint32_t hv;
    hv = hash(ITEM_key(item), item->nkey);

    item_lock(hv);
    do_item_remove(item);
    item_unlock(hv);
}",859.0,866.0,1.0,14.0,8.0,0,0,0,0,7,0,1,1,0,0,,0,0,2,1,1,void
1651,44937,item_replace,1,item_replace,"int item_replace (item*,item*,uint32_t)",thread.c,"int item_replace(item *old_it, item *new_it, const uint32_t hv) {
    return do_item_replace(old_it, new_it, hv);
}",873.0,875.0,1.0,1.0,3.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,int
1652,44944,item_unlink,1,item_unlink,void item_unlink (item*),thread.c,"void item_unlink(item *item) {
    uint32_t hv;
    hv = hash(ITEM_key(item), item->nkey);
    item_lock(hv);
    do_item_unlink(item, hv);
    item_unlock(hv);
}",880.0,886.0,1.0,14.0,7.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
1653,44949,item_lock,1,item_lock,void item_lock (uint32_t),thread.c,"void item_lock(uint32_t hv) {
    mutex_lock(&item_locks[hv & hashmask(item_lock_hashpower)]);
}",121.0,123.0,1.0,4.0,3.0,0,0,0,0,5,0,1,1,0,0,,0,0,2,1,1,void
1654,44954,item_trylock,1,item_trylock,void* item_trylock (uint32_t),thread.c,"void *item_trylock(uint32_t hv) {
    pthread_mutex_t *lock = &item_locks[hv & hashmask(item_lock_hashpower)];
    if (pthread_mutex_trylock(lock) == 0) {
        return lock;
    }
    return NULL;
}",125.0,131.0,1.0,45.0,7.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,void*
1655,44959,item_trylock_unlock,1,item_trylock_unlock,void item_trylock_unlock (void*),thread.c,"void item_trylock_unlock(void *lock) {
    mutex_unlock((pthread_mutex_t *) lock);
}",133.0,135.0,1.0,4.0,3.0,0,0,0,0,6,0,1,1,0,0,,0,0,2,1,1,void
1656,44964,item_unlock,1,item_unlock,void item_unlock (uint32_t),thread.c,"void item_unlock(uint32_t hv) {
    mutex_unlock(&item_locks[hv & hashmask(item_lock_hashpower)]);
}",137.0,139.0,1.0,4.0,3.0,0,0,0,0,12,0,1,1,0,0,,0,0,2,1,1,void
1657,44969,pause_threads,1,pause_threads,void pause_threads (pause_thread_types),thread.c,"void pause_threads(enum pause_thread_types type) {
    int i;
    bool pause_workers = false;

    switch (type) {
        case PAUSE_ALL_THREADS:
            slabs_rebalancer_pause();
            lru_maintainer_pause();
            lru_crawler_pause();
#ifdef EXTSTORE
            storage_compact_pause();
            storage_write_pause();
#endif
        case PAUSE_WORKER_THREADS:
            pause_workers = true;
            pthread_mutex_lock(&worker_hang_lock);
            break;
        case RESUME_ALL_THREADS:
            slabs_rebalancer_resume();
            lru_maintainer_resume();
            lru_crawler_resume();
#ifdef EXTSTORE
            storage_compact_resume();
            storage_write_resume();
#endif
        case RESUME_WORKER_THREADS:
            pthread_mutex_unlock(&worker_hang_lock);
            break;
        default:
            fprintf(stderr, ""Unknown lock type: %d\n"", type);
            assert(1 == 0);
            break;
    }

    /* Only send a message i...",158.0,204.0,1.0,1.0,47.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,void
1658,44974,stop_threads,1,stop_threads,void stop_threads (void),thread.c,"void stop_threads(void) {
    int i;

    // assoc can call pause_threads(), so we have to stop it first.
    stop_assoc_maintenance_thread();
    if (settings.verbose > 0)
        fprintf(stderr, ""stopped assoc\n"");

    if (settings.verbose > 0)
        fprintf(stderr, ""asking workers to stop\n"");

    pthread_mutex_lock(&worker_hang_lock);
    pthread_mutex_lock(&init_lock);
    init_count = 0;
    for (i = 0; i < settings.num_threads; i++) {
        notify_worker_fd(&threads[i], 0, queue_stop);
    }
    wait_for_thread_registration(settings.num_threads);
    pthread_mutex_unlock(&init_lock);

    // All of the workers are hung but haven't done cleanup yet.

    if (settings.verbose > 0)
        fprintf(stderr, ""asking background threads to stop\n"");

    // stop each side thread.
    // TODO: Verify these all work if the threads are already stopped
    stop_item_crawler_thread(CRAWLER_WAIT);
    if (settings.verbose > 0)
        fprintf(stderr, ""stopped lru crawler\n"");
    if ...",210.0,272.0,1.0,29.0,63.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
1659,44984,STATS_LOCK,1,STATS_LOCK,void STATS_LOCK (void),thread.c,"void STATS_LOCK() {
    pthread_mutex_lock(&stats_lock);
}",921.0,923.0,1.0,1.0,3.0,0,0,0,0,30,0,1,1,0,0,,0,0,0,0,0,void
1660,44989,STATS_UNLOCK,1,STATS_UNLOCK,void STATS_UNLOCK (void),thread.c,"void STATS_UNLOCK() {
    pthread_mutex_unlock(&stats_lock);
}",925.0,927.0,1.0,1.0,3.0,0,0,0,0,31,0,1,1,0,0,,0,0,0,0,0,void
1661,44994,threadlocal_stats_reset,1,threadlocal_stats_reset,void threadlocal_stats_reset (void),thread.c,"void threadlocal_stats_reset(void) {
    int ii;
    for (ii = 0; ii < settings.num_threads; ++ii) {
        pthread_mutex_lock(&threads[ii].stats.mutex);
#define X(name) threads[ii].stats.name = 0;
        THREAD_STATS_FIELDS
#ifdef EXTSTORE
        EXTSTORE_THREAD_STATS_FIELDS
#endif
#ifdef PROXY
        PROXY_THREAD_STATS_FIELDS
#endif
#undef X

        memset(&threads[ii].stats.slab_stats, 0,
                sizeof(threads[ii].stats.slab_stats));
        memset(&threads[ii].stats.lru_hits, 0,
                sizeof(uint64_t) * POWER_LARGEST);

        pthread_mutex_unlock(&threads[ii].stats.mutex);
    }
}",929.0,950.0,1.0,8.0,22.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
1662,44999,threadlocal_stats_aggregate,1,threadlocal_stats_aggregate,void threadlocal_stats_aggregate (thread_stats*),thread.c,"void threadlocal_stats_aggregate(struct thread_stats *stats) {
    int ii, sid;

    /* The struct has a mutex, but we can safely set the whole thing
     * to zero since it is unused when aggregating. */
    memset(stats, 0, sizeof(*stats));

    for (ii = 0; ii < settings.num_threads; ++ii) {
        pthread_mutex_lock(&threads[ii].stats.mutex);
#define X(name) stats->name += threads[ii].stats.name;
        THREAD_STATS_FIELDS
#ifdef EXTSTORE
        EXTSTORE_THREAD_STATS_FIELDS
#endif
#ifdef PROXY
        PROXY_THREAD_STATS_FIELDS
#endif
#undef X

        for (sid = 0; sid < MAX_NUMBER_OF_SLAB_CLASSES; sid++) {
#define X(name) stats->slab_stats[sid].name += \
            threads[ii].stats.slab_stats[sid].name;
            SLAB_STATS_FIELDS
#undef X
        }

        for (sid = 0; sid < POWER_LARGEST; sid++) {
            stats->lru_hits[sid] +=
                threads[ii].stats.lru_hits[sid];
            stats->slab_stats[CLEAR_LRU(sid)].get_hits +=
                threads[ii].s...",952.0,990.0,1.0,8.0,39.0,0,0,0,0,3,0,1,1,0,0,,0,0,2,1,1,void
1663,45004,slab_stats_aggregate,1,slab_stats_aggregate,"void slab_stats_aggregate (thread_stats*,slab_stats*)",thread.c,"void slab_stats_aggregate(struct thread_stats *stats, struct slab_stats *out) {
    int sid;

    memset(out, 0, sizeof(*out));

    for (sid = 0; sid < MAX_NUMBER_OF_SLAB_CLASSES; sid++) {
#define X(name) out->name += stats->slab_stats[sid].name;
        SLAB_STATS_FIELDS
#undef X
    }
}",992.0,1002.0,1.0,24.0,11.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
1664,45010,get_worker_thread,1,get_worker_thread,LIBEVENT_THREAD* get_worker_thread (int),thread.c,"LIBEVENT_THREAD *get_worker_thread(int id) {
    return &threads[id];
}",634.0,636.0,1.0,1.0,3.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,LIBEVENT_THREAD
1665,45176,rotl32,1,rotl32,"uint32_t rotl32 (uint32_t,int8_t)",murmur3_hash.c,"static inline uint32_t rotl32 ( uint32_t x, int8_t r )
{
  return (x << r) | (x >> (32 - r));
}",33.0,36.0,1.0,1.0,4.0,4,4,4,2,3,0,1,1,0,0,,0,0,4,2,2,uint32_t
1666,45192,getblock32,1,getblock32,"uint32_t getblock32 (uint32_t*,int)",murmur3_hash.c,"static FORCE_INLINE uint32_t getblock32 ( const uint32_t * p, int i )
{
  return p[i];
}",48.0,51.0,1.0,7.0,4.0,1,1,2,2,1,0,1,1,0,0,,0,0,4,2,2,uint32_t
1667,45202,fmix32,1,fmix32,uint32_t fmix32 (uint32_t),murmur3_hash.c,"static FORCE_INLINE uint32_t fmix32 ( uint32_t h )
{
  h ^= h >> 16;
  h *= 0x85ebca6b;
  h ^= h >> 13;
  h *= 0xc2b2ae35;
  h ^= h >> 16;

  return h;
}",56.0,65.0,1.0,7.0,10.0,5,2,9,1,1,0,1,1,0,0,,0,0,2,1,1,uint32_t
1668,45230,MurmurHash3_x86_32,1,MurmurHash3_x86_32,"uint32_t MurmurHash3_x86_32 (void*,size_t)",murmur3_hash.c,"uint32_t MurmurHash3_x86_32 ( const void * key, size_t length)
{
  const uint8_t * data = (const uint8_t*)key;
  const int nblocks = length / 4;

  uint32_t h1 = 0;

  uint32_t c1 = 0xcc9e2d51;
  uint32_t c2 = 0x1b873593;

  //----------
  // body

  const uint32_t * blocks = (const uint32_t *)(data + nblocks*4);

  for(int i = -nblocks; i; i++)
  {
    uint32_t k1 = getblock32(blocks,i);

    k1 *= c1;
    k1 = ROTL32(k1,15);
    k1 *= c2;

    h1 ^= k1;
    h1 = ROTL32(h1,13);
    h1 = h1*5+0xe6546b64;
  }

  //----------
  // tail

  const uint8_t * tail = (const uint8_t*)(data + nblocks*4);

  uint32_t k1 = 0;

  switch(length & 3)
  {
  case 3: k1 ^= tail[2] << 16;
  case 2: k1 ^= tail[1] << 8;
  case 1: k1 ^= tail[0];
          k1 *= c1; k1 = ROTL32(k1,15); k1 *= c2; h1 ^= k1;
  };

  //----------
  // finalization

  h1 ^= length;

  h1 = fmix32(h1);

  //*(uint32_t*)out = h1;
  return h1;
}",71.0,123.0,1.0,9.0,53.0,36,10,55,11,0,5,3,3,0,5,,0,5,4,2,2,uint32_t
1669,45443,process_bin_flush,1,process_bin_flush,"void process_bin_flush (conn*,char*)",proto_bin.c,"static void process_bin_flush(conn *c, char *extbuf) {
    time_t exptime = 0;
    protocol_binary_request_flush* req = (void *)extbuf;
    rel_time_t new_oldest = 0;

    if (!settings.flush_enabled) {
      // flush_all is not allowed but we log it on stats
      write_bin_error(c, PROTOCOL_BINARY_RESPONSE_AUTH_ERROR, NULL, 0);
      return;
    }

    if (c->binary_header.request.extlen == sizeof(req->message.body)) {
        exptime = ntohl(req->message.body.expiration);
    }

    if (exptime > 0) {
        new_oldest = realtime(exptime);
    } else {
        new_oldest = current_time;
    }
    if (settings.use_cas) {
        settings.oldest_live = new_oldest - 1;
        if (settings.oldest_live <= current_time)
            settings.oldest_cas = get_cas_id();
    } else {
        settings.oldest_live = new_oldest;
    }

    pthread_mutex_lock(&c->thread->stats.mutex);
    c->thread->stats.flush_cmds++;
    pthread_mutex_unlock(&c->thread->stats.mutex);

    write_bin_respons...",1250.0,1283.0,1.0,1.0,34.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
1670,45449,process_bin_append_prepend,1,process_bin_append_prepend,void process_bin_append_prepend (conn*),proto_bin.c,"static void process_bin_append_prepend(conn *c) {
    char *key;
    int nkey;
    int vlen;
    item *it;

    assert(c != NULL);

    key = binary_get_key(c);
    nkey = c->binary_header.request.keylen;
    vlen = c->binary_header.request.bodylen - nkey;

    if (settings.verbose > 1) {
        fprintf(stderr, ""Value len is %d\n"", vlen);
    }

    if (settings.detail_enabled) {
        stats_prefix_record_set(key, nkey);
    }

    it = item_alloc(key, nkey, 0, 0, vlen+2);

    if (it == 0) {
        if (! item_size_ok(nkey, 0, vlen + 2)) {
            write_bin_error(c, PROTOCOL_BINARY_RESPONSE_E2BIG, NULL, vlen);
        } else {
            out_of_memory(c, ""SERVER_ERROR Out of memory allocating item"");
            /* OOM calls eat the swallow value. Add here. */
            c->sbytes = vlen;
        }
        /* swallow the data line */
        conn_set_state(c, conn_swallow);
        return;
    }

    ITEM_set_cas(it, c->binary_header.request.cas);

    switch (c->cmd) {
  ...",1187.0,1248.0,1.0,4.0,62.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
1671,45454,process_bin_update,1,process_bin_update,"void process_bin_update (conn*,char*)",proto_bin.c,"static void process_bin_update(conn *c, char *extbuf) {
    char *key;
    int nkey;
    int vlen;
    item *it;
    protocol_binary_request_set* req = (void *)extbuf;

    assert(c != NULL);

    key = binary_get_key(c);
    nkey = c->binary_header.request.keylen;

    /* fix byteorder in the request */
    req->message.body.flags = ntohl(req->message.body.flags);
    req->message.body.expiration = ntohl(req->message.body.expiration);

    vlen = c->binary_header.request.bodylen - (nkey + c->binary_header.request.extlen);

    if (settings.verbose > 1) {
        int ii;
        if (c->cmd == PROTOCOL_BINARY_CMD_ADD) {
            fprintf(stderr, ""<%d ADD "", c->sfd);
        } else if (c->cmd == PROTOCOL_BINARY_CMD_SET) {
            fprintf(stderr, ""<%d SET "", c->sfd);
        } else {
            fprintf(stderr, ""<%d REPLACE "", c->sfd);
        }
        for (ii = 0; ii < nkey; ++ii) {
            fprintf(stderr, ""%c"", key[ii]);
        }

        fprintf(stderr, "" Value len is %d...",1078.0,1185.0,1.0,8.0,108.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
1672,45460,process_bin_get_or_touch,1,process_bin_get_or_touch,"void process_bin_get_or_touch (conn*,char*)",proto_bin.c,"static void process_bin_get_or_touch(conn *c, char *extbuf) {
    item *it;

    protocol_binary_response_get* rsp = (protocol_binary_response_get*)c->resp->wbuf;
    char* key = binary_get_key(c);
    size_t nkey = c->binary_header.request.keylen;
    int should_touch = (c->cmd == PROTOCOL_BINARY_CMD_TOUCH ||
                        c->cmd == PROTOCOL_BINARY_CMD_GAT ||
                        c->cmd == PROTOCOL_BINARY_CMD_GATK);
    int should_return_key = (c->cmd == PROTOCOL_BINARY_CMD_GETK ||
                             c->cmd == PROTOCOL_BINARY_CMD_GATK);
    int should_return_value = (c->cmd != PROTOCOL_BINARY_CMD_TOUCH);
    bool failed = false;

    if (settings.verbose > 1) {
        fprintf(stderr, ""<%d %s "", c->sfd, should_touch ? ""TOUCH"" : ""GET"");
        if (fwrite(key, 1, nkey, stderr)) {}
        fputc('\n', stderr);
    }

    if (should_touch) {
        protocol_binary_request_touch *t = (void *)extbuf;
        time_t exptime = ntohl(t->message.body.expiration);

  ...",455.0,603.0,1.0,36.0,149.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
1673,45466,process_bin_delete,1,process_bin_delete,void process_bin_delete (conn*),proto_bin.c,"static void process_bin_delete(conn *c) {
    item *it;
    uint32_t hv;

    assert(c != NULL);
    char* key = binary_get_key(c);
    size_t nkey = c->binary_header.request.keylen;

    if (settings.verbose > 1) {
        int ii;
        fprintf(stderr, ""Deleting "");
        for (ii = 0; ii < nkey; ++ii) {
            fprintf(stderr, ""%c"", key[ii]);
        }
        fprintf(stderr, ""\n"");
    }

    if (settings.detail_enabled) {
        stats_prefix_record_delete(key, nkey);
    }

    it = item_get_locked(key, nkey, c, DONT_UPDATE, &hv);
    if (it) {
        uint64_t cas = c->binary_header.request.cas;
        if (cas == 0 || cas == ITEM_get_cas(it)) {
            MEMCACHED_COMMAND_DELETE(c->sfd, ITEM_key(it), it->nkey);
            pthread_mutex_lock(&c->thread->stats.mutex);
            c->thread->stats.slab_stats[ITEM_clsid(it)].delete_hits++;
            pthread_mutex_unlock(&c->thread->stats.mutex);
            do_item_unlink(it, hv);
            STORAGE_delete(c->thread-...",1285.0,1328.0,1.0,39.0,44.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
1674,45471,complete_incr_bin,1,complete_incr_bin,"void complete_incr_bin (conn*,char*)",proto_bin.c,"static void complete_incr_bin(conn *c, char *extbuf) {
    item *it;
    char *key;
    size_t nkey;
    /* Weird magic in add_delta forces me to pad here */
    char tmpbuf[INCR_MAX_STORAGE_LEN];
    uint64_t cas = 0;

    assert(c != NULL);
    protocol_binary_response_incr* rsp = (protocol_binary_response_incr*)c->resp->wbuf;
    protocol_binary_request_incr* req = (void *)extbuf;

    //assert(c->wsize >= sizeof(*rsp));

    /* fix byteorder in the request */
    req->message.body.delta = ntohll(req->message.body.delta);
    req->message.body.initial = ntohll(req->message.body.initial);
    req->message.body.expiration = ntohl(req->message.body.expiration);
    key = binary_get_key(c);
    nkey = c->binary_header.request.keylen;

    if (settings.verbose > 1) {
        int i;
        fprintf(stderr, ""incr "");

        for (i = 0; i < nkey; i++) {
            fprintf(stderr, ""%c"", key[i]);
        }
        fprintf(stderr, "" %lld, %llu, %d\n"",
                (long long)req->mess...",260.0,357.0,1.0,16.0,98.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
1675,45477,process_bin_stat,1,process_bin_stat,void process_bin_stat (conn*),proto_bin.c,"static void process_bin_stat(conn *c) {
    char *subcommand = binary_get_key(c);
    size_t nkey = c->binary_header.request.keylen;

    if (settings.verbose > 1) {
        int ii;
        fprintf(stderr, ""<%d STATS "", c->sfd);
        for (ii = 0; ii < nkey; ++ii) {
            fprintf(stderr, ""%c"", subcommand[ii]);
        }
        fprintf(stderr, ""\n"");
    }

    if (nkey == 0) {
        /* request all statistics */
        server_stats(&append_stats, c);
        (void)get_stats(NULL, 0, &append_stats, c);
    } else if (strncmp(subcommand, ""reset"", 5) == 0) {
        stats_reset();
    } else if (strncmp(subcommand, ""settings"", 8) == 0) {
        process_stat_settings(&append_stats, c);
    } else if (strncmp(subcommand, ""detail"", 6) == 0) {
        char *subcmd_pos = subcommand + 6;
        if (strncmp(subcmd_pos, "" dump"", 5) == 0) {
            int len;
            char *dump_buf = stats_prefix_dump(&len);
            if (dump_buf == NULL || len <= 0) {
                out_...",605.0,671.0,1.0,1.0,67.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
1676,45482,process_bin_sasl_auth,1,process_bin_sasl_auth,void process_bin_sasl_auth (conn*),proto_bin.c,"static void process_bin_sasl_auth(conn *c) {
    // Guard for handling disabled SASL on the server.
    if (!settings.sasl) {
        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND, NULL,
                        c->binary_header.request.bodylen
                        - c->binary_header.request.keylen);
        return;
    }

    assert(c->binary_header.request.extlen == 0);

    int nkey = c->binary_header.request.keylen;
    int vlen = c->binary_header.request.bodylen - nkey;

    if (nkey > MAX_SASL_MECH_LEN) {
        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_EINVAL, NULL, vlen);
        conn_set_state(c, conn_swallow);
        return;
    }

    char *key = binary_get_key(c);
    assert(key);

    item *it = item_alloc(key, nkey, 0, 0, vlen+2);

    /* Can't use a chunked item for SASL authentication. */
    if (it == 0 || (it->it_flags & ITEM_CHUNKED)) {
        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, NULL, vlen);
        conn_set_state(c, conn_swall...",725.0,765.0,1.0,15.0,41.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
1677,45487,dispatch_bin_command,1,dispatch_bin_command,"void dispatch_bin_command (conn*,char*)",proto_bin.c,"static void dispatch_bin_command(conn *c, char *extbuf) {
    int protocol_error = 0;

    uint8_t extlen = c->binary_header.request.extlen;
    uint16_t keylen = c->binary_header.request.keylen;
    uint32_t bodylen = c->binary_header.request.bodylen;

    if (keylen > bodylen || keylen + extlen > bodylen) {
        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND, NULL, 0);
        c->close_after_write = true;
        return;
    }

    if (settings.sasl && !authenticated(c)) {
        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_AUTH_ERROR, NULL, 0);
        c->close_after_write = true;
        return;
    }

    MEMCACHED_PROCESS_COMMAND_START(c->sfd, c->rcurr, c->rbytes);
    c->noreply = true;

    /* binprot supports 16bit keys, but internals are still 8bit */
    if (keylen > KEY_MAX_LENGTH) {
        handle_binary_protocol_error(c);
        return;
    }

    switch (c->cmd) {
    case PROTOCOL_BINARY_CMD_SETQ:
        c->cmd = PROTOCOL_BINARY_CMD_SET;
        bre...",885.0,1076.0,1.0,4.0,192.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
1678,45493,complete_update_bin,1,complete_update_bin,void complete_update_bin (conn*),proto_bin.c,"static void complete_update_bin(conn *c) {
    protocol_binary_response_status eno = PROTOCOL_BINARY_RESPONSE_EINVAL;
    enum store_item_type ret = NOT_STORED;
    assert(c != NULL);

    item *it = c->item;
    pthread_mutex_lock(&c->thread->stats.mutex);
    c->thread->stats.slab_stats[ITEM_clsid(it)].set_cmds++;
    pthread_mutex_unlock(&c->thread->stats.mutex);

    /* We don't actually receive the trailing two characters in the bin
     * protocol, so we're going to just set them here */
    if ((it->it_flags & ITEM_CHUNKED) == 0) {
        *(ITEM_data(it) + it->nbytes - 2) = '\r';
        *(ITEM_data(it) + it->nbytes - 1) = '\n';
    } else {
        assert(c->ritem);
        item_chunk *ch = (item_chunk *) c->ritem;
        if (ch->size == ch->used)
            ch = ch->next;
        assert(ch->size - ch->used >= 2);
        ch->data[ch->used] = '\r';
        ch->data[ch->used + 1] = '\n';
        ch->used += 2;
    }

    ret = store_item(it, c->cmd, c);

#ifdef ENABLE_DTRA...",359.0,439.0,1.0,32.0,81.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
1679,45498,process_bin_complete_sasl_auth,1,process_bin_complete_sasl_auth,void process_bin_complete_sasl_auth (conn*),proto_bin.c,"static void process_bin_complete_sasl_auth(conn *c) {
    assert(settings.sasl);
    const char *out = NULL;
    unsigned int outlen = 0;

    assert(c->item);
    init_sasl_conn(c);

    int nkey = c->binary_header.request.keylen;
    int vlen = c->binary_header.request.bodylen - nkey;

    if (nkey > ((item*) c->item)->nkey) {
        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_EINVAL, NULL, vlen);
        conn_set_state(c, conn_swallow);
        return;
    }

    char mech[nkey+1];
    memcpy(mech, ITEM_key((item*)c->item), nkey);
    mech[nkey] = 0x00;

    if (settings.verbose)
        fprintf(stderr, ""mech:  ``%s'' with %d bytes of data\n"", mech, vlen);

    const char *challenge = vlen == 0 ? NULL : ITEM_data((item*) c->item);

    if (vlen > ((item*) c->item)->nbytes) {
        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_EINVAL, NULL, vlen);
        conn_set_state(c, conn_swallow);
        return;
    }

    int result=-1;

    switch (c->cmd) {
    case PROTOCOL_BINARY_CMD...",767.0,860.0,1.0,17.0,94.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
1680,45503,write_bin_miss_response,1,write_bin_miss_response,"void write_bin_miss_response (conn*,char*,size_t)",proto_bin.c,"static void write_bin_miss_response(conn *c, char *key, size_t nkey) {
    if (nkey) {
        add_bin_header(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT,
                0, nkey, nkey);
        char *ofs = c->resp->wbuf + sizeof(protocol_binary_response_header);
        memcpy(ofs, key, nkey);
        resp_add_iov(c->resp, ofs, nkey);
        conn_set_state(c, conn_new_cmd);
    } else {
        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT,
                        NULL, 0);
    }
}",441.0,453.0,1.0,1.0,13.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,void
1681,45510,complete_nread_binary,1,complete_nread_binary,void complete_nread_binary (conn*),proto_bin.c,"void complete_nread_binary(conn *c) {
    assert(c != NULL);
    assert(c->cmd >= 0);

    switch(c->substate) {
    case bin_read_set_value:
        complete_update_bin(c);
        break;
    case bin_reading_sasl_auth_data:
        process_bin_complete_sasl_auth(c);
        if (c->item) {
            do_item_remove(c->item);
            c->item = NULL;
        }
        break;
    default:
        fprintf(stderr, ""Not handling substate %d\n"", c->substate);
        assert(0);
    }
}",31.0,50.0,1.0,1.0,20.0,9,4,14,5,0,9,5,4,2,3,,0,6,2,1,1,void
1682,45563,try_read_command_binary,1,try_read_command_binary,int try_read_command_binary (conn*),proto_bin.c,"int try_read_command_binary(conn *c) {
    /* Do we have the complete packet header? */
    if (c->rbytes < sizeof(c->binary_header)) {
        /* need more data! */
        return 0;
    } else {
        memcpy(&c->binary_header, c->rcurr, sizeof(c->binary_header));
        protocol_binary_request_header* req;
        req = &c->binary_header;

        if (settings.verbose > 1) {
            /* Dump the packet before we convert it to host order */
            int ii;
            fprintf(stderr, ""<%d Read binary protocol data:"", c->sfd);
            for (ii = 0; ii < sizeof(req->bytes); ++ii) {
                if (ii % 4 == 0) {
                    fprintf(stderr, ""\n<%d   "", c->sfd);
                }
                fprintf(stderr, "" 0x%02x"", req->bytes[ii]);
            }
            fprintf(stderr, ""\n"");
        }

        c->binary_header = *req;
        c->binary_header.request.keylen = ntohs(req->request.keylen);
        c->binary_header.request.bodylen = ntohl(req->request.b...",52.0,126.0,1.0,47.0,75.0,4,3,2,1,0,2,2,2,2,0,,0,2,2,1,1,int
1683,45878,binary_get_key,1,binary_get_key,char* binary_get_key (conn*),proto_bin.c,"static char* binary_get_key(conn *c) {
    return c->rcurr - (c->binary_header.request.keylen);
}",131.0,133.0,1.0,1.0,3.0,5,3,2,1,0,2,1,1,0,0,,0,2,2,1,1,char*
1684,45895,add_bin_header,1,add_bin_header,"void add_bin_header (conn*,uint16_t,uint8_t,uint16_t,uint32_t)",proto_bin.c,"static void add_bin_header(conn *c, uint16_t err, uint8_t hdr_len, uint16_t key_len, uint32_t body_len) {
    protocol_binary_response_header* header;
    mc_resp *resp = c->resp;

    assert(c);

    resp_reset(resp);

    header = (protocol_binary_response_header *)resp->wbuf;

    header->response.magic = (uint8_t)PROTOCOL_BINARY_RES;
    header->response.opcode = c->binary_header.request.opcode;
    header->response.keylen = (uint16_t)htons(key_len);

    header->response.extlen = (uint8_t)hdr_len;
    header->response.datatype = (uint8_t)PROTOCOL_BINARY_RAW_BYTES;
    header->response.status = (uint16_t)htons(err);

    header->response.bodylen = htonl(body_len);
    header->response.opaque = c->opaque;
    header->response.cas = htonll(c->cas);

    if (settings.verbose > 1) {
        int ii;
        fprintf(stderr, "">%d Writing bin response:"", c->sfd);
        for (ii = 0; ii < sizeof(header->bytes); ++ii) {
            if (ii % 4 == 0) {
                fprintf(stderr, ""\n>%...",135.0,171.0,1.0,1.0,37.0,60,10,42,12,2,12,4,7,2,3,,0,10,10,5,5,void
1685,46077,write_bin_error,1,write_bin_error,"void write_bin_error (conn*,protocol_binary_response_status,char*,int)",proto_bin.c,"void write_bin_error(conn *c, protocol_binary_response_status err,
                            const char *errstr, int swallow) {
    size_t len;

    if (!errstr) {
        switch (err) {
        case PROTOCOL_BINARY_RESPONSE_ENOMEM:
            errstr = ""Out of memory"";
            break;
        case PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND:
            errstr = ""Unknown command"";
            break;
        case PROTOCOL_BINARY_RESPONSE_KEY_ENOENT:
            errstr = ""Not found"";
            break;
        case PROTOCOL_BINARY_RESPONSE_EINVAL:
            errstr = ""Invalid arguments"";
            break;
        case PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS:
            errstr = ""Data exists for key."";
            break;
        case PROTOCOL_BINARY_RESPONSE_E2BIG:
            errstr = ""Too large."";
            break;
        case PROTOCOL_BINARY_RESPONSE_DELTA_BADVAL:
            errstr = ""Non-numeric server-side value for incr or decr"";
            break;
        case PROTOCOL_BIN...",179.0,234.0,1.0,1.0,56.0,21,5,43,18,4,8,15,7,1,3,,0,5,8,4,4,void
1686,46213,handle_binary_protocol_error,1,handle_binary_protocol_error,void handle_binary_protocol_error (conn*),proto_bin.c,"static void handle_binary_protocol_error(conn *c) {
    write_bin_error(c, PROTOCOL_BINARY_RESPONSE_EINVAL, NULL, 0);
    if (settings.verbose) {
        fprintf(stderr, ""Protocol error (opcode %02x), close connection %d\n"",
                c->binary_header.request.opcode, c->sfd);
    }
    c->close_after_write = true;
}",237.0,244.0,1.0,1.0,8.0,7,3,9,6,0,5,2,2,1,1,,0,4,2,1,1,void
1687,46246,write_bin_response,1,write_bin_response,"void write_bin_response (conn*,void*,int,int,int)",proto_bin.c,"static void write_bin_response(conn *c, void *d, int hlen, int keylen, int dlen) {
    if (!c->noreply || c->cmd == PROTOCOL_BINARY_CMD_GET ||
        c->cmd == PROTOCOL_BINARY_CMD_GETK) {
        add_bin_header(c, 0, hlen, keylen, dlen);
        mc_resp *resp = c->resp;
        if (dlen > 0) {
            resp_add_iov(resp, d, dlen);
        }
    }

    conn_set_state(c, conn_new_cmd);
}",247.0,258.0,1.0,1.0,12.0,11,6,17,9,1,7,3,4,3,3,,0,4,10,5,5,void
1688,48077,init_sasl_conn,1,init_sasl_conn,void init_sasl_conn (conn*),proto_bin.c,"static void init_sasl_conn(conn *c) {
    assert(c);
    /* should something else be returned? */
    if (!settings.sasl)
        return;

    c->authenticated = false;

    if (!c->sasl_conn) {
        int result=sasl_server_new(""memcached"",
                                   NULL,
                                   my_sasl_hostname[0] ? my_sasl_hostname : NULL,
                                   NULL, NULL,
                                   NULL, 0, &c->sasl_conn);
        if (result != SASL_OK) {
            if (settings.verbose) {
                fprintf(stderr, ""Failed to initialize SASL conn.\n"");
            }
            c->sasl_conn = NULL;
        }
    }
}",673.0,694.0,1.0,19.0,22.0,11,5,11,6,1,5,5,8,3,0,,0,5,2,1,1,void
1689,48128,bin_list_sasl_mechs,1,bin_list_sasl_mechs,void bin_list_sasl_mechs (conn*),proto_bin.c,"static void bin_list_sasl_mechs(conn *c) {
    // Guard against a disabled SASL.
    if (!settings.sasl) {
        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND, NULL,
                        c->binary_header.request.bodylen
                        - c->binary_header.request.keylen);
        return;
    }

    init_sasl_conn(c);
    const char *result_string = NULL;
    unsigned int string_length = 0;
    int result=sasl_listmech(c->sasl_conn, NULL,
                             """",   /* What to prepend the string with */
                             "" "",  /* What to separate mechanisms with */
                             """",   /* What to append to the string */
                             &result_string, &string_length,
                             NULL);
    if (result != SASL_OK) {
        /* Perhaps there's a better error for this... */
        if (settings.verbose) {
            fprintf(stderr, ""Failed to list SASL mechanisms.\n"");
        }
        write_bin_err...",696.0,723.0,1.0,15.0,28.0,15,7,20,9,0,8,4,5,2,4,,0,4,2,1,1,void
1690,48779,authenticated,1,authenticated,bool authenticated (conn*),proto_bin.c,"static bool authenticated(conn *c) {
    assert(settings.sasl);
    bool rv = false;

    switch (c->cmd) {
    case PROTOCOL_BINARY_CMD_SASL_LIST_MECHS: /* FALLTHROUGH */
    case PROTOCOL_BINARY_CMD_SASL_AUTH:       /* FALLTHROUGH */
    case PROTOCOL_BINARY_CMD_SASL_STEP:       /* FALLTHROUGH */
    case PROTOCOL_BINARY_CMD_VERSION:         /* FALLTHROUGH */
        rv = true;
        break;
    default:
        rv = c->authenticated;
    }

    if (settings.verbose > 1) {
        fprintf(stderr, ""authenticated() in cmd 0x%02x is %s\n"",
                c->cmd, rv ? ""true"" : ""false"");
    }

    return rv;
}",862.0,883.0,1.0,1.0,22.0,10,5,17,10,0,5,4,3,2,0,,0,5,2,1,1,bool
1691,50476,proxy_process_command,1,proxy_process_command,"void proxy_process_command (conn*,char*,size_t,bool)",proto_proxy.c,"static void proxy_process_command(conn *c, char *command, size_t cmdlen, bool multiget) {
    assert(c != NULL);
    LIBEVENT_THREAD *thr = c->thread;
    struct proxy_hook *hooks = thr->proxy_hooks;
    lua_State *L = thr->L;
    mcp_parser_t pr = {0};

    // Avoid doing resp_start() here, instead do it a bit later or as-needed.
    // This allows us to hop over to the internal text protocol parser, which
    // also calls resp_start().
    // Tighter integration later should obviate the need for this, it is not a
    // permanent solution.
    int ret = process_request(&pr, command, cmdlen);
    if (ret != 0) {
        WSTAT_INCR(c, proxy_conn_errors, 1);
        if (!resp_start(c)) {
            conn_set_state(c, conn_closing);
            return;
        }
        proxy_out_errstring(c->resp, ""parsing request"");
        if (ret == -2) {
            // Kill connection on more critical parse failure.
            conn_set_state(c, conn_closing);
        }
        return;
    }

  ...",619.0,803.0,1.0,8.0,185.0,0,0,0,0,1,0,1,1,0,0,,0,0,8,4,4,void
1692,50484,mcp_queue_io,1,mcp_queue_io,"void mcp_queue_io (conn*,mc_resp*,int,lua_State*)",proto_proxy.c,"static void mcp_queue_io(conn *c, mc_resp *resp, int coro_ref, lua_State *Lc) {
    io_queue_t *q = conn_io_queue_get(c, IO_QUEUE_PROXY);

    // stack: request, hash selector. latter just to hold a reference.

    mcp_request_t *rq = luaL_checkudata(Lc, -1, ""mcp.request"");
    mcp_backend_t *be = rq->be;

    // Then we push a response object, which we'll re-use later.
    // reserve one uservalue for a lua-supplied response.
    mcp_resp_t *r = lua_newuserdatauv(Lc, sizeof(mcp_resp_t), 1);
    // FIXME (v2): is this memset still necessary? I was using it for
    // debugging.
    memset(r, 0, sizeof(mcp_resp_t));
    r->buf = NULL;
    r->blen = 0;
    // Set noreply mode.
    // TODO (v2): the response ""inherits"" the request's noreply mode, which isn't
    // strictly correct; we should inherit based on the request that spawned
    // the coroutine but the structure doesn't allow that yet.
    // Should also be able to settle this exact mode from the parser so we
    // don't hav...",809.0,894.0,1.0,41.0,86.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,void
1693,50492,proxy_out_errstring,1,proxy_out_errstring,"void proxy_out_errstring (mc_resp*,char*)",proto_proxy.c,"static void proxy_out_errstring(mc_resp *resp, const char *str) {
    size_t len;
    const static char error_prefix[] = ""SERVER_ERROR "";
    const static int error_prefix_len = sizeof(error_prefix) - 1;

    assert(resp != NULL);

    resp_reset(resp);
    // avoid noreply since we're throwing important errors.

    // Fill response object with static string.
    len = strlen(str);
    if ((len + error_prefix_len + 2) > WRITE_BUFFER_SIZE) {
        /* ought to be always enough. just fail for simplicity */
        str = ""SERVER_ERROR output line too long"";
        len = strlen(str);
    }

    char *w = resp->wbuf;
    memcpy(w, error_prefix, error_prefix_len);
    w += error_prefix_len;

    memcpy(w, str, len);
    w += len;

    memcpy(w, ""\r\n"", 2);
    resp_add_iov(resp, resp->wbuf, len + error_prefix_len + 2);
    return;
}",452.0,480.0,1.0,39.0,29.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
1694,50498,proxy_stats,1,proxy_stats,"void proxy_stats (ADD_STAT,conn*)",proto_proxy.c,"void proxy_stats(ADD_STAT add_stats, conn *c) {
    if (!settings.proxy_enabled) {
       return;
    }
    proxy_ctx_t *ctx = settings.proxy_ctx;
    STAT_L(ctx);

    APPEND_STAT(""proxy_config_reloads"", ""%llu"", (unsigned long long)ctx->global_stats.config_reloads);
    APPEND_STAT(""proxy_config_reload_fails"", ""%llu"", (unsigned long long)ctx->global_stats.config_reload_fails);
    APPEND_STAT(""proxy_backend_total"", ""%llu"", (unsigned long long)ctx->global_stats.backend_total);
    APPEND_STAT(""proxy_backend_marked_bad"", ""%llu"", (unsigned long long)ctx->global_stats.backend_marked_bad);
    APPEND_STAT(""proxy_backend_failed"", ""%llu"", (unsigned long long)ctx->global_stats.backend_failed);
    STAT_UL(ctx);
}",24.0,37.0,1.0,4.0,14.0,23,6,22,4,0,14,2,2,1,5,,0,9,4,2,2,void
1695,50613,process_proxy_stats,1,process_proxy_stats,"void process_proxy_stats (ADD_STAT,conn*)",proto_proxy.c,"void process_proxy_stats(ADD_STAT add_stats, conn *c) {
    char key_str[STAT_KEY_LEN];
    struct proxy_int_stats istats = {0};

    if (!settings.proxy_enabled) {
        return;
    }
    proxy_ctx_t *ctx = settings.proxy_ctx;
    STAT_L(ctx);

    // prepare aggregated counters.
    struct proxy_user_stats *us = &ctx->user_stats;
    uint64_t counters[us->num_stats];
    memset(counters, 0, sizeof(counters));

    // aggregate worker thread counters.
    for (int x = 0; x < settings.num_threads; x++) {
        LIBEVENT_THREAD *t = get_worker_thread(x);
        struct proxy_user_stats *tus = t->proxy_user_stats;
        struct proxy_int_stats *is = t->proxy_int_stats;
        WSTAT_L(t);
        for (int i = 0; i < CMD_FINAL; i++) {
            istats.counters[i] += is->counters[i];
        }
        if (tus && tus->num_stats >= us->num_stats) {
            for (int i = 0; i < us->num_stats; i++) {
                counters[i] += tus->counters[i];
            }
        }
        W...",39.0,99.0,1.0,17.0,61.0,114,14,134,34,0,60,7,11,6,22,,0,39,4,2,2,void
1696,51136,proxy_init,1,proxy_init,void proxy_init (bool),proto_proxy.c,"void proxy_init(bool use_uring) {
    proxy_ctx_t *ctx = calloc(1, sizeof(proxy_ctx_t));
    settings.proxy_ctx = ctx;
    ctx->use_uring = use_uring;

    pthread_mutex_init(&ctx->config_lock, NULL);
    pthread_cond_init(&ctx->config_cond, NULL);
    pthread_mutex_init(&ctx->worker_lock, NULL);
    pthread_cond_init(&ctx->worker_cond, NULL);
    pthread_mutex_init(&ctx->manager_lock, NULL);
    pthread_cond_init(&ctx->manager_cond, NULL);
    pthread_mutex_init(&ctx->stats_lock, NULL);

    // FIXME (v2): default defines.
    ctx->tunables.tcp_keepalive = false;
    ctx->tunables.backend_failure_limit = 3;
    ctx->tunables.connect.tv_sec = 5;
    ctx->tunables.retry.tv_sec = 3;
    ctx->tunables.read.tv_sec = 3;
#ifdef HAVE_LIBURING
    ctx->tunables.connect_ur.tv_sec = 5;
    ctx->tunables.retry_ur.tv_sec = 3;
    ctx->tunables.read_ur.tv_sec = 3;
#endif // HAVE_LIBURING

    STAILQ_INIT(&ctx->manager_head);
    lua_State *L = luaL_newstate();
    ctx->proxy_state = L;
    luaL_...",103.0,182.0,1.0,4.0,80.0,98,7,71,13,0,24,3,4,0,3,,0,21,2,1,1,void
1697,51413,proxy_thread_init,1,proxy_thread_init,void proxy_thread_init (LIBEVENT_THREAD*),proto_proxy.c,"void proxy_thread_init(LIBEVENT_THREAD *thr) {
    // Create the hook table.
    thr->proxy_hooks = calloc(CMD_SIZE, sizeof(struct proxy_hook));
    if (thr->proxy_hooks == NULL) {
        fprintf(stderr, ""Failed to allocate proxy hooks\n"");
        exit(EXIT_FAILURE);
    }
    thr->proxy_int_stats = calloc(1, sizeof(struct proxy_int_stats));
    if (thr->proxy_int_stats == NULL) {
        fprintf(stderr, ""Failed to allocate proxy thread stats\n"");
        exit(EXIT_FAILURE);
    }

    // Initialize the lua state.
    lua_State *L = luaL_newstate();
    thr->L = L;
    luaL_openlibs(L);
    proxy_register_libs(thr, L);
    // TODO: srand on time? do we need to bother?
    for (int x = 0; x < 3; x++) {
        thr->proxy_rng[x] = rand();
    }

    // kick off the configuration.
    if (proxy_thread_loadconf(thr) != 0) {
        exit(EXIT_FAILURE);
    }
}",185.0,212.0,1.0,1.0,28.0,19,7,25,9,0,8,5,5,3,2,,0,7,2,1,1,void
1698,51499,proxy_submit_cb,1,proxy_submit_cb,void proxy_submit_cb (io_queue_t*),proto_proxy.c,"void proxy_submit_cb(io_queue_t *q) {
    proxy_event_thread_t *e = ((proxy_ctx_t *)q->ctx)->proxy_threads;
    io_pending_proxy_t *p = q->stack_ctx;
    io_head_t head;
    STAILQ_INIT(&head);

    // NOTE: responses get returned in the correct order no matter what, since
    // mc_resp's are linked.
    // we just need to ensure stuff is parsed off the backend in the correct
    // order.
    // So we can do with a single list here, but we need to repair the list as
    // responses are parsed. (in the req_remaining-- section)
    // TODO (v2):
    // - except we can't do that because the deferred IO stack isn't
    // compatible with queue.h.
    // So for now we build the secondary list with an STAILQ, which
    // can be transplanted/etc.
    while (p) {
        // insert into tail so head is oldest request.
        STAILQ_INSERT_TAIL(&head, p, io_next);
        if (p->is_await) {
            // need to not count await objects multiple times.
            if (p->await_first) {
 ...",215.0,274.0,1.0,4.0,60.0,74,10,40,5,0,0,5,8,0,0,,0,0,2,1,1,void
1699,51697,proxy_complete_cb,1,proxy_complete_cb,void proxy_complete_cb (io_queue_t*),proto_proxy.c,"void proxy_complete_cb(io_queue_t *q) {
    // empty/unused.
}",276.0,278.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
1700,51702,proxy_return_cb,1,proxy_return_cb,void proxy_return_cb (io_pending_t*),proto_proxy.c,"void proxy_return_cb(io_pending_t *pending) {
    io_pending_proxy_t *p = (io_pending_proxy_t *)pending;
    if (p->is_await) {
        mcplib_await_return(p);
    } else {
        lua_State *Lc = p->coro;

        // in order to resume we need to remove the objects that were
        // originally returned
        // what's currently on the top of the stack is what we want to keep.
        lua_rotate(Lc, 1, 1);
        // We kept the original results from the yield so lua would not
        // collect them in the meantime. We can drop those now.
        lua_settop(Lc, 1);

        // p can be freed/changed from the call below, so fetch the queue now.
        io_queue_t *q = conn_io_queue_get(p->c, p->io_queue_type);
        conn *c = p->c;
        proxy_run_coroutine(Lc, p->resp, p, c);

        q->count--;
        if (q->count == 0) {
            // call re-add directly since we're already in the worker thread.
            conn_worker_readd(c);
        }
    }
}",282.0,308.0,1.0,1.0,27.0,3,3,4,2,0,1,2,2,0,1,,0,0,2,1,1,void
1701,51771,proxy_finalize_cb,1,proxy_finalize_cb,void proxy_finalize_cb (io_pending_t*),proto_proxy.c,"void proxy_finalize_cb(io_pending_t *pending) {
    io_pending_proxy_t *p = (io_pending_proxy_t *)pending;

    // release our coroutine reference.
    // TODO (v2): coroutines are reusable in lua 5.4. we can stack this onto a freelist
    // after a lua_resetthread(Lc) call.
    if (p->coro_ref) {
        // Note: lua registry is the same for main thread or a coroutine.
        luaL_unref(p->coro, LUA_REGISTRYINDEX, p->coro_ref);
    }
    return;
}",313.0,324.0,1.0,1.0,12.0,5,3,6,3,0,0,2,2,0,0,,0,0,2,1,1,void
1702,51796,try_read_command_proxy,1,try_read_command_proxy,int try_read_command_proxy (conn*),proto_proxy.c,"int try_read_command_proxy(conn *c) {
    char *el, *cont;

    if (c->rbytes == 0)
        return 0;

    el = memchr(c->rcurr, '\n', c->rbytes);
    if (!el) {
        if (c->rbytes > 1024) {
            /*
             * We didn't have a '\n' in the first k. This _has_ to be a
             * large multiget, if not we should just nuke the connection.
             */
            char *ptr = c->rcurr;
            while (*ptr == ' ') { /* ignore leading whitespaces */
                ++ptr;
            }

            if (ptr - c->rcurr > 100 ||
                (strncmp(ptr, ""get "", 4) && strncmp(ptr, ""gets "", 5))) {

                conn_set_state(c, conn_closing);
                return 1;
            }

            // ASCII multigets are unbound, so our fixed size rbuf may not
            // work for this particular workload... For backcompat we'll use a
            // malloc/realloc/free routine just for this.
            if (!c->rbuf_malloced) {
                if (!rbuf_switch_t...",326.0,378.0,1.0,56.0,53.0,43,13,40,7,0,22,8,18,5,4,,0,19,2,1,1,int
1703,51950,proxy_cleanup_conn,1,proxy_cleanup_conn,void proxy_cleanup_conn (conn*),proto_proxy.c,"void proxy_cleanup_conn(conn *c) {
    assert(c->proxy_coro_ref != 0);
    LIBEVENT_THREAD *thr = c->thread;
    lua_State *L = thr->L;
    luaL_unref(L, LUA_REGISTRYINDEX, c->proxy_coro_ref);
    c->proxy_coro_ref = 0;
    WSTAT_DECR(c, proxy_req_active, 1);
}",382.0,389.0,1.0,4.0,8.0,21,6,13,4,0,8,1,1,0,0,,0,8,2,1,1,void
1704,52015,complete_nread_proxy,1,complete_nread_proxy,void complete_nread_proxy (conn*),proto_proxy.c,"void complete_nread_proxy(conn *c) {
    assert(c != NULL);

    LIBEVENT_THREAD *thr = c->thread;
    lua_State *L = thr->L;

    if (c->proxy_coro_ref == 0) {
        complete_nread_ascii(c);
        return;
    }

    conn_set_state(c, conn_new_cmd);

    // Grab our coroutine.
    lua_rawgeti(L, LUA_REGISTRYINDEX, c->proxy_coro_ref);
    luaL_unref(L, LUA_REGISTRYINDEX, c->proxy_coro_ref);
    lua_State *Lc = lua_tothread(L, -1);
    mcp_request_t *rq = luaL_checkudata(Lc, -1, ""mcp.request"");

    // validate the data chunk.
    if (strncmp((char *)c->item + rq->pr.vlen - 2, ""\r\n"", 2) != 0) {
        lua_settop(L, 0); // clear anything remaining on the main thread.
        // FIXME (v2): need to set noreply false if mset_res, but that's kind
        // of a weird hack to begin with. Evaluate how to best do that here.
        out_string(c, ""CLIENT_ERROR bad data chunk"");
        return;
    }

    // We move ownership of the c->item buffer from the connection to the
    // reque...",392.0,433.0,1.0,1.0,42.0,31,9,36,9,0,15,3,3,2,4,,0,11,2,1,1,void
1705,52138,proxy_lua_error,1,proxy_lua_error,"void proxy_lua_error (lua_State*,char*)",proto_proxy.c,"void proxy_lua_error(lua_State *L, const char *s) {
    lua_pushstring(L, s);
    lua_error(L);
}",438.0,441.0,1.0,1.0,4.0,0,0,3,2,11,0,1,1,0,0,,0,0,4,2,2,void
1706,52149,proxy_lua_ferror,1,proxy_lua_ferror,"void proxy_lua_ferror (lua_State*,char*...)",proto_proxy.c,"void proxy_lua_ferror(lua_State *L, const char *fmt, ...) {
    va_list ap;
    va_start(ap, fmt);
    lua_pushfstring(L, fmt, ap);
    va_end(ap);
    lua_error(L);
}",443.0,449.0,1.0,1.0,7.0,0,0,7,3,2,0,1,1,0,0,,0,0,4,2,2,void
1707,52248,_set_noreply_mode,1,_set_noreply_mode,"void _set_noreply_mode (mc_resp*,mcp_resp_t*)",proto_proxy.c,"static void _set_noreply_mode(mc_resp *resp, mcp_resp_t *r) {
    switch (r->mode) {
        case RESP_MODE_NORMAL:
            break;
        case RESP_MODE_NOREPLY:
            // ascii noreply only threw egregious errors to client
            if (r->status == MCMC_OK) {
                resp->skip = true;
            }
            break;
        case RESP_MODE_METAQUIET:
            if (r->resp.code == MCMC_CODE_MISS) {
                resp->skip = true;
            } else if (r->cmd != CMD_MG && r->resp.code == MCMC_CODE_OK) {
                // FIXME (v2): mcmc's parser needs to help us out a bit more
                // here.
                // This is a broken case in the protocol though; quiet mode
                // ignores HD for mutations but not get.
                resp->skip = true;
            }
            break;
        default:
            assert(1 == 0);
    }
}",486.0,510.0,1.0,29.0,25.0,11,4,10,6,1,3,7,6,3,0,,0,3,4,2,2,void
1708,52327,proxy_run_coroutine,1,proxy_run_coroutine,"int proxy_run_coroutine (lua_State*,mc_resp*,io_pending_proxy_t*,conn*)",proto_proxy.c,"int proxy_run_coroutine(lua_State *Lc, mc_resp *resp, io_pending_proxy_t *p, conn *c) {
    int nresults = 0;
    int cores = lua_resume(Lc, NULL, 1, &nresults);
    size_t rlen = 0;

    if (cores == LUA_OK) {
        WSTAT_DECR(c, proxy_req_active, 1);
        int type = lua_type(Lc, 1);
        if (type == LUA_TUSERDATA) {
            mcp_resp_t *r = luaL_checkudata(Lc, 1, ""mcp.response"");
            _set_noreply_mode(resp, r);
            if (r->buf) {
                // response set from C.
                // FIXME (v2): write_and_free() ? it's a bit wrong for here.
                resp->write_and_free = r->buf;
                resp_add_iov(resp, r->buf, r->blen);
                r->buf = NULL;
            } else if (lua_getiuservalue(Lc, 1, 1) != LUA_TNIL) {
                // uservalue slot 1 is pre-created, so we get TNIL instead of
                // TNONE when nothing was set into it.
                const char *s = lua_tolstring(Lc, -1, &rlen);
                size_t l =...",523.0,617.0,1.0,8.0,95.0,28,6,28,11,1,10,4,7,1,2,,0,8,8,4,4,int
1709,53714,dump_stack,1,dump_stack,void dump_stack (lua_State*),proto_proxy.c,"__attribute__((unused)) void dump_stack(lua_State *L) {
    int top = lua_gettop(L);
    int i = 1;
    fprintf(stderr, ""--TOP OF STACK [%d]\n"", top);
    for (; i < top + 1; i++) {
        int type = lua_type(L, i);
        // lets find the metatable of this userdata to identify it.
        if (lua_getmetatable(L, i) != 0) {
            lua_pushstring(L, ""__name"");
            if (lua_rawget(L, -2) != LUA_TNIL) {
                fprintf(stderr, ""--|%d| [%s] (%s)\n"", i, lua_typename(L, type), lua_tostring(L, -1));
                lua_pop(L, 2);
                continue;
            }
            lua_pop(L, 2);
        }
        if (type == LUA_TSTRING) {
            fprintf(stderr, ""--|%d| [%s] | %s\n"", i, lua_typename(L, type), lua_tostring(L, i));
        } else {
            fprintf(stderr, ""--|%d| [%s]\n"", i, lua_typename(L, type));
        }
    }
    fprintf(stderr, ""-----------------\n"");
}",897.0,920.0,1.0,1.0,24.0,10,6,31,7,0,0,6,9,0,0,,0,0,2,1,1,void
1710,53853,proxy_start_reload,1,proxy_start_reload,void proxy_start_reload (void*),proxy_config.c,"void proxy_start_reload(void *arg) {
    proxy_ctx_t *ctx = arg;
    if (pthread_mutex_trylock(&ctx->config_lock) == 0) {
        pthread_cond_signal(&ctx->config_cond);
        pthread_mutex_unlock(&ctx->config_lock);
    }
}",41.0,47.0,1.0,1.0,7.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
1711,53858,proxy_load_config,1,proxy_load_config,int proxy_load_config (void*),proxy_config.c,"int proxy_load_config(void *arg) {
    proxy_ctx_t *ctx = arg;
    lua_State *L = ctx->proxy_state;
    int res = luaL_loadfile(L, settings.proxy_startfile);
    if (res != LUA_OK) {
        fprintf(stderr, ""ERROR: Failed to load proxy_startfile: %s\n"", lua_tostring(L, -1));
        return -1;
    }
    // LUA_OK, LUA_ERRSYNTAX, LUA_ERRMEM, LUA_ERRFILE

    // Now we need to dump the compiled code into bytecode.
    // This will then get loaded into worker threads.
    struct _dumpbuf *db = malloc(sizeof(struct _dumpbuf));
    db->size = 16384;
    db->used = 0;
    db->buf = malloc(db->size);
    lua_dump(L, _dump_helper, db, 0);
    // 0 means no error.
    ctx->proxy_code = db;

    // now we complete the data load by calling the function.
    res = lua_pcall(L, 0, LUA_MULTRET, 0);
    if (res != LUA_OK) {
        fprintf(stderr, ""ERROR: Failed to load data into lua config state: %s\n"", lua_tostring(L, -1));
        exit(EXIT_FAILURE);
    }

    // call the mcp_config_pools func...",185.0,227.0,1.0,1.0,43.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,int
1712,53863,proxy_worker_reload,1,proxy_worker_reload,"void proxy_worker_reload (void*,LIBEVENT_THREAD*)",proxy_config.c,"void proxy_worker_reload(void *arg, LIBEVENT_THREAD *thr) {
    proxy_ctx_t *ctx = arg;
    pthread_mutex_lock(&ctx->worker_lock);
    if (proxy_thread_loadconf(thr) != 0) {
        ctx->worker_failed = true;
    }
    ctx->worker_done = true;
    pthread_cond_signal(&ctx->worker_cond);
    pthread_mutex_unlock(&ctx->worker_lock);
}",333.0,342.0,1.0,1.0,10.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
1713,53889,proxy_register_libs,1,proxy_register_libs,"int proxy_register_libs (LIBEVENT_THREAD*,void*)",proxy_lua.c,"int proxy_register_libs(LIBEVENT_THREAD *t, void *ctx) {
    lua_State *L = ctx;

    const struct luaL_Reg mcplib_backend_m[] = {
        {""set"", NULL},
        {""__gc"", mcplib_backend_gc},
        {NULL, NULL}
    };

    const struct luaL_Reg mcplib_request_m[] = {
        {""command"", mcplib_request_command},
        {""key"", mcplib_request_key},
        {""ltrimkey"", mcplib_request_ltrimkey},
        {""rtrimkey"", mcplib_request_rtrimkey},
        {""token"", mcplib_request_token},
        {""ntokens"", mcplib_request_ntokens},
        {""has_flag"", mcplib_request_has_flag},
        {""flag_token"", mcplib_request_flag_token},
        {""__tostring"", NULL},
        {""__gc"", mcplib_request_gc},
        {NULL, NULL}
    };

    const struct luaL_Reg mcplib_response_m[] = {
        {""ok"", mcplib_response_ok},
        {""hit"", mcplib_response_hit},
        {""vlen"", mcplib_response_vlen},
        {""code"", mcplib_response_code},
        {""line"", mcplib_response_line},
        {""__gc"", mcplib_resp...",869.0,996.0,1.0,1.0,128.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,int
1714,53922,_finalize_mset,1,_finalize_mset,"void _finalize_mset (conn*,store_item_type)",proto_text.c,"static void _finalize_mset(conn *c, enum store_item_type ret) {
    mc_resp *resp = c->resp;
    item *it = c->item;
    conn_set_state(c, conn_new_cmd);

    // information about the response line has been stashed in wbuf.
    char *p = resp->wbuf + resp->wbytes;
    char *end = p; // end of the stashed data portion.

    switch (ret) {
    case STORED:
      if (settings.meta_response_old) {
          memcpy(p, ""OK"", 2);
      } else {
          memcpy(p, ""HD"", 2);
      }
      // Only place noreply is used for meta cmds is a nominal response.
      if (c->noreply) {
          resp->skip = true;
      }
      break;
    case EXISTS:
      memcpy(p, ""EX"", 2);
      break;
    case NOT_FOUND:
      memcpy(p, ""NF"", 2);
      break;
    case NOT_STORED:
      memcpy(p, ""NS"", 2);
      break;
    default:
      c->noreply = false;
      out_string(c, ""SERVER_ERROR Unhandled storage type."");
      return;
    }
    p += 2;

    for (char *fp = resp->wbuf; fp < end; fp++) {
        swit...",54.0,122.0,1.0,16.0,69.0,86,18,81,16,0,11,15,12,2,5,,0,7,4,2,2,void
1715,54224,complete_nread_ascii,1,complete_nread_ascii,void complete_nread_ascii (conn*),proto_text.c,"void complete_nread_ascii(conn *c) {
    assert(c != NULL);

    item *it = c->item;
    int comm = c->cmd;
    enum store_item_type ret;
    bool is_valid = false;

    pthread_mutex_lock(&c->thread->stats.mutex);
    c->thread->stats.slab_stats[ITEM_clsid(it)].set_cmds++;
    pthread_mutex_unlock(&c->thread->stats.mutex);

    if ((it->it_flags & ITEM_CHUNKED) == 0) {
        if (strncmp(ITEM_data(it) + it->nbytes - 2, ""\r\n"", 2) == 0) {
            is_valid = true;
        }
    } else {
        char buf[2];
        /* should point to the final item chunk */
        item_chunk *ch = (item_chunk *) c->ritem;
        assert(ch->used != 0);
        /* :( We need to look at the last two bytes. This could span two
         * chunks.
         */
        if (ch->used > 1) {
            buf[0] = ch->data[ch->used - 2];
            buf[1] = ch->data[ch->used - 1];
        } else {
            assert(ch->prev);
            assert(ch->used == 1);
            buf[0] = ch->prev->data[ch->prev...",128.0,234.0,1.0,32.0,107.0,59,17,35,9,1,13,5,7,1,2,,0,11,2,1,1,void
1716,54546,tokenize_command,1,tokenize_command,"size_t tokenize_command (char*,token_t*,size_t)",proto_text.c,"static size_t tokenize_command(char *command, token_t *tokens, const size_t max_tokens) {
    char *s, *e;
    size_t ntokens = 0;
    assert(command != NULL && tokens != NULL && max_tokens > 1);
    size_t len = strlen(command);
    unsigned int i = 0;

    s = e = command;
    for (i = 0; i < len; i++) {
        if (*e == ' ') {
            if (s != e) {
                tokens[ntokens].value = s;
                tokens[ntokens].length = e - s;
                ntokens++;
                *e = '\0';
                if (ntokens == max_tokens - 1) {
                    e++;
                    s = e; /* so we don't add an extra token */
                    break;
                }
            }
            s = e + 1;
        }
        e++;
    }

    if (s != e) {
        tokens[ntokens].value = s;
        tokens[ntokens].length = e - s;
        ntokens++;
    }

    /*
     * If we scanned the whole string, the terminal value pointer is null,
     * otherwise it is the first unprocess...",283.0,324.0,1.0,1.0,42.0,51,13,54,9,4,0,7,12,0,0,,0,0,6,3,3,size_t
1717,54696,try_read_command_asciiauth,1,try_read_command_asciiauth,int try_read_command_asciiauth (conn*),proto_text.c,"int try_read_command_asciiauth(conn *c) {
    token_t tokens[MAX_TOKENS];
    size_t ntokens;
    char *cont = NULL;

    // TODO: move to another function.
    if (!c->sasl_started) {
        char *el;
        uint32_t size = 0;

        // impossible for the auth command to be this short.
        if (c->rbytes < 2)
            return 0;

        el = memchr(c->rcurr, '\n', c->rbytes);

        // If no newline after 1k, getting junk data, close out.
        if (!el) {
            if (c->rbytes > 2048) {
                conn_set_state(c, conn_closing);
                return 1;
            }
            return 0;
        }

        // Looking for: ""set foo 0 0 N\r\nuser pass\r\n""
        // key, flags, and ttl are ignored. N is used to see if we have the rest.

        // so tokenize doesn't walk past into the value.
        // it's fine to leave the \r in, as strtoul will stop at it.
        *el = '\0';

        ntokens = tokenize_command(c->rcurr, tokens, MAX_TOKENS);
        // ...",326.0,436.0,1.0,19.0,111.0,91,17,69,11,0,41,14,25,12,13,,0,34,2,1,1,int
1718,55041,try_read_command_ascii,1,try_read_command_ascii,int try_read_command_ascii (conn*),proto_text.c,"int try_read_command_ascii(conn *c) {
    char *el, *cont;

    if (c->rbytes == 0)
        return 0;

    el = memchr(c->rcurr, '\n', c->rbytes);
    if (!el) {
        if (c->rbytes > 2048) {
            /*
             * We didn't have a '\n' in the first few k. This _has_ to be a
             * large multiget, if not we should just nuke the connection.
             */
            char *ptr = c->rcurr;
            while (*ptr == ' ') { /* ignore leading whitespaces */
                ++ptr;
            }

            if (ptr - c->rcurr > 100 ||
                (strncmp(ptr, ""get "", 4) && strncmp(ptr, ""gets "", 5))) {

                conn_set_state(c, conn_closing);
                return 1;
            }

            // ASCII multigets are unbound, so our fixed size rbuf may not
            // work for this particular workload... For backcompat we'll use a
            // malloc/realloc/free routine just for this.
            if (!c->rbuf_malloced) {
                if (!rbuf_swit...",438.0,493.0,1.0,1.0,56.0,51,14,42,6,0,22,9,19,6,4,,0,19,2,1,1,int
1719,55209,set_noreply_maybe,1,set_noreply_maybe,"bool set_noreply_maybe (conn*,token_t*,size_t)",proto_text.c,"static inline bool set_noreply_maybe(conn *c, token_t *tokens, size_t ntokens)
{
    int noreply_index = ntokens - 2;

    /*
      NOTE: this function is not the first place where we are going to
      send the reply.  We could send it instead from process_command()
      if the request line has wrong number of tokens.  However parsing
      malformed line for ""noreply"" option is not reliable anyway, so
      it can't be helped.
    */
    if (tokens[noreply_index].value
        && strcmp(tokens[noreply_index].value, ""noreply"") == 0) {
        c->noreply = true;
    }
    return c->noreply;
}",496.0,512.0,1.0,1.0,17.0,11,7,9,5,10,2,2,2,0,0,,0,2,6,3,3,bool
1720,55248,make_ascii_get_suffix,1,make_ascii_get_suffix,"int make_ascii_get_suffix (char*,item*,bool,int)",proto_text.c,"static inline int make_ascii_get_suffix(char *suffix, item *it, bool return_cas, int nbytes) {
    char *p = suffix;
    *p = ' ';
    p++;
    if (FLAGS_SIZE(it) == 0) {
        *p = '0';
        p++;
    } else {
        p = itoa_u32(*((uint32_t *) ITEM_suffix(it)), p);
    }
    *p = ' ';
    p = itoa_u32(nbytes-2, p+1);

    if (return_cas) {
        *p = ' ';
        p = itoa_u64(ITEM_get_cas(it), p+1);
    }

    *p = '\r';
    *(p+1) = '\n';
    *(p+2) = '\0';
    return (p - suffix) + 2;
}",515.0,537.0,1.0,8.0,23.0,37,11,25,6,1,2,3,3,0,2,,0,2,8,4,4,int
1721,55387,process_get_command,1,process_get_command,"void process_get_command (conn*,token_t*,size_t,bool,bool)",proto_text.c,"static inline void process_get_command(conn *c, token_t *tokens, size_t ntokens, bool return_cas, bool should_touch) {
    char *key;
    size_t nkey;
    item *it;
    token_t *key_token = &tokens[KEY_TOKEN];
    int32_t exptime_int = 0;
    rel_time_t exptime = 0;
    bool fail_length = false;
    assert(c != NULL);
    mc_resp *resp = c->resp;

    if (should_touch) {
        // For get and touch commands, use first token as exptime
        if (!safe_strtol(tokens[1].value, &exptime_int)) {
            out_string(c, ""CLIENT_ERROR invalid exptime argument"");
            return;
        }
        key_token++;
        exptime = realtime(EXPTIME_TO_POSITIVE_TIME(exptime_int));
    }

    do {
        while(key_token->length != 0) {
            bool overflow; // not used here.
            key = key_token->value;
            nkey = key_token->length;

            if (nkey > KEY_MAX_LENGTH) {
                fail_length = true;
                goto stop;
            }

            it = ...",540.0,713.0,1.0,33.0,174.0,128,21,123,25,0,27,23,51,7,15,,0,19,10,5,5,void
1722,55937,process_stats_detail,1,process_stats_detail,"void process_stats_detail (conn*,char*)",proto_text.c,"inline static void process_stats_detail(conn *c, const char *command) {
    assert(c != NULL);

    if (strcmp(command, ""on"") == 0) {
        settings.detail_enabled = 1;
        out_string(c, ""OK"");
    }
    else if (strcmp(command, ""off"") == 0) {
        settings.detail_enabled = 0;
        out_string(c, ""OK"");
    }
    else if (strcmp(command, ""dump"") == 0) {
        int len;
        char *stats = stats_prefix_dump(&len);
        write_and_free(c, stats, len);
    }
    else {
        out_string(c, ""CLIENT_ERROR usage: stats detail on|off|dump"");
    }
}",715.0,734.0,1.0,1.0,20.0,4,4,5,4,0,2,2,2,0,1,,0,1,4,2,2,void
1723,56004,process_stat,1,process_stat,"void process_stat (conn*,token_t*,size_t)",proto_text.c,"static void process_stat(conn *c, token_t *tokens, const size_t ntokens) {
    const char *subcommand = tokens[SUBCOMMAND_TOKEN].value;
    assert(c != NULL);

    if (ntokens < 2) {
        out_string(c, ""CLIENT_ERROR bad command line"");
        return;
    }

    if (ntokens == 2) {
        server_stats(&append_stats, c);
        (void)get_stats(NULL, 0, &append_stats, c);
    } else if (strcmp(subcommand, ""reset"") == 0) {
        stats_reset();
        out_string(c, ""RESET"");
        return;
    } else if (strcmp(subcommand, ""detail"") == 0) {
        /* NOTE: how to tackle detail with binary? */
        if (ntokens < 4)
            process_stats_detail(c, """");  /* outputs the error message */
        else
            process_stats_detail(c, tokens[2].value);
        /* Output already generated */
        return;
    } else if (strcmp(subcommand, ""settings"") == 0) {
        process_stat_settings(&append_stats, c);
    } else if (strcmp(subcommand, ""cachedump"") == 0) {
        char...",736.0,825.0,1.0,36.0,90.0,12,9,18,6,0,5,4,4,0,5,,0,0,6,3,3,void
1724,56292,process_meta_command,1,process_meta_command,"void process_meta_command (conn*,token_t*,size_t)",proto_text.c,"static void process_meta_command(conn *c, token_t *tokens, const size_t ntokens) {
    assert(c != NULL);

    if (ntokens < 3 || tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {
        out_string(c, ""CLIENT_ERROR bad command line format"");
        return;
    }

    char *key = tokens[KEY_TOKEN].value;
    size_t nkey = tokens[KEY_TOKEN].length;

    if (ntokens >= 4 && tokens[2].length == 1 && tokens[2].value[0] == 'b') {
        size_t ret = base64_decode((unsigned char *)key, nkey,
                    (unsigned char *)key, nkey);
        if (ret == 0) {
            // failed to decode.
            out_string(c, ""CLIENT_ERROR bad command line format"");
            return;
        }
        nkey = ret;
    }

    bool overflow; // not used here.
    item *it = limited_get(key, nkey, c, 0, false, DONT_UPDATE, &overflow);
    if (it) {
        mc_resp *resp = c->resp;
        size_t total = 0;
        size_t ret;
        // similar to out_string().
        memcpy(resp->wbuf, ""ME "", 3);...",828.0,890.0,1.0,30.0,63.0,118,23,82,17,1,12,6,8,0,8,,0,6,6,3,3,void
1725,56708,_meta_flag_preparse,1,_meta_flag_preparse,"int _meta_flag_preparse (token_t*,size_t,_meta_flags*,char**)",proto_text.c,"static int _meta_flag_preparse(token_t *tokens, const size_t start,
        struct _meta_flags *of, char **errstr) {
    unsigned int i;
    size_t ret;
    int32_t tmp_int;
    uint8_t seen[127] = {0};
    // Start just past the key token. Look at first character of each token.
    for (i = start; tokens[i].length != 0; i++) {
        uint8_t o = (uint8_t)tokens[i].value[0];
        // zero out repeat flags so we don't over-parse for return data.
        if (o >= 127 || seen[o] != 0) {
            *errstr = ""CLIENT_ERROR duplicate flag"";
            return -1;
        }
        seen[o] = 1;
        switch (o) {
            // base64 decode the key in-place, as the binary should always be
            // shorter and the conversion code buffers bytes.
            case 'b':
                ret = base64_decode((unsigned char *)tokens[KEY_TOKEN].value, tokens[KEY_TOKEN].length,
                            (unsigned char *)tokens[KEY_TOKEN].value, tokens[KEY_TOKEN].length);
              ...",918.0,1049.0,1.0,60.0,132.0,141,16,79,10,4,34,30,33,11,8,,0,34,8,4,4,int
1726,57247,process_mget_command,1,process_mget_command,"void process_mget_command (conn*,token_t*,size_t)",proto_text.c,"static void process_mget_command(conn *c, token_t *tokens, const size_t ntokens) {
    char *key;
    size_t nkey;
    item *it;
    unsigned int i = 0;
    struct _meta_flags of = {0}; // option bitflags.
    uint32_t hv; // cached hash value for unlocking an item.
    bool failed = false;
    bool item_created = false;
    bool won_token = false;
    bool ttl_set = false;
    char *errstr = ""CLIENT_ERROR bad command line format"";
    assert(c != NULL);
    mc_resp *resp = c->resp;
    char *p = resp->wbuf;

    WANT_TOKENS_MIN(ntokens, 3);

    // FIXME: do we move this check to after preparse?
    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {
        out_errstring(c, ""CLIENT_ERROR bad command line format"");
        return;
    }

    // NOTE: final token has length == 0.
    // KEY_TOKEN == 1. 0 is command.

    if (ntokens == 3) {
        // TODO: any way to fix this?
        out_errstring(c, ""CLIENT_ERROR bad command line format"");
        return;
    } else if (ntokens > MF...",1051.0,1352.0,1.0,4.0,302.0,308,24,243,24,1,41,42,64,9,23,,0,26,6,3,3,void
1727,58436,process_mset_command,1,process_mset_command,"void process_mset_command (conn*,token_t*,size_t)",proto_text.c,"static void process_mset_command(conn *c, token_t *tokens, const size_t ntokens) {
    char *key;
    size_t nkey;
    item *it;
    int i;
    short comm = NREAD_SET;
    struct _meta_flags of = {0}; // option bitflags.
    char *errstr = ""CLIENT_ERROR bad command line format"";
    uint32_t hv; // cached hash value.
    int vlen = 0; // value from data line.
    assert(c != NULL);
    mc_resp *resp = c->resp;
    char *p = resp->wbuf;

    WANT_TOKENS_MIN(ntokens, 3);

    // TODO: most of this is identical to mget.
    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {
        out_errstring(c, ""CLIENT_ERROR bad command line format"");
        return;
    }

    if (ntokens == 3) {
        out_errstring(c, ""CLIENT_ERROR bad command line format"");
        return;
    }

    if (ntokens > MFLAG_MAX_OPT_LENGTH) {
        out_errstring(c, ""CLIENT_ERROR options flags too long"");
        return;
    }

    // We note tokens into the front of the write buffer, so we can create the
    // fin...",1354.0,1551.0,1.0,17.0,198.0,173,23,163,29,1,44,32,23,8,18,,0,31,6,3,3,void
1728,59125,process_mdelete_command,1,process_mdelete_command,"void process_mdelete_command (conn*,token_t*,size_t)",proto_text.c,"static void process_mdelete_command(conn *c, token_t *tokens, const size_t ntokens) {
    char *key;
    size_t nkey;
    item *it = NULL;
    int i;
    uint32_t hv;
    struct _meta_flags of = {0}; // option bitflags.
    char *errstr = ""CLIENT_ERROR bad command line format"";
    assert(c != NULL);
    mc_resp *resp = c->resp;
    // reserve 3 bytes for status code
    char *p = resp->wbuf + 3;

    WANT_TOKENS_MIN(ntokens, 3);

    // TODO: most of this is identical to mget.
    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {
        out_string(c, ""CLIENT_ERROR bad command line format"");
        return;
    }

    if (ntokens > MFLAG_MAX_OPT_LENGTH) {
        out_string(c, ""CLIENT_ERROR options flags too long"");
        return;
    }

    // scrubs duplicated options and sets flags for how to load the item.
    // we pass in the first token that should be a flag.
    // FIXME: not using the preparse errstr?
    if (_meta_flag_preparse(tokens, 2, &of, &errstr) != 0) {
        out...",1553.0,1683.0,1.0,4.0,131.0,125,21,115,17,1,29,19,25,7,13,,0,19,6,3,3,void
1729,59708,process_marithmetic_command,1,process_marithmetic_command,"void process_marithmetic_command (conn*,token_t*,size_t)",proto_text.c,"static void process_marithmetic_command(conn *c, token_t *tokens, const size_t ntokens) {
    char *key;
    size_t nkey;
    int i;
    struct _meta_flags of = {0}; // option bitflags.
    char *errstr = ""CLIENT_ERROR bad command line format"";
    assert(c != NULL);
    mc_resp *resp = c->resp;
    // no reservation (like del/set) since we post-process the status line.
    char *p = resp->wbuf;

    // If no argument supplied, incr or decr by one.
    of.delta = 1;
    of.initial = 0; // redundant, for clarity.
    bool incr = true; // default mode is to increment.
    bool locked = false;
    uint32_t hv = 0;
    item *it = NULL; // item returned by do_add_delta.

    WANT_TOKENS_MIN(ntokens, 3);

    // TODO: most of this is identical to mget.
    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {
        out_string(c, ""CLIENT_ERROR bad command line format"");
        return;
    }

    if (ntokens > MFLAG_MAX_OPT_LENGTH) {
        out_string(c, ""CLIENT_ERROR options flags too long""...",1685.0,1915.0,1.0,4.0,231.0,191,21,204,29,1,38,40,43,11,20,,0,24,6,3,3,void
1730,60679,process_update_command,1,process_update_command,"void process_update_command (conn*,token_t*,size_t,int,bool)",proto_text.c,"static void process_update_command(conn *c, token_t *tokens, const size_t ntokens, int comm, bool handle_cas) {
    char *key;
    size_t nkey;
    unsigned int flags;
    int32_t exptime_int = 0;
    rel_time_t exptime = 0;
    int vlen;
    uint64_t req_cas_id=0;
    item *it;

    assert(c != NULL);

    set_noreply_maybe(c, tokens, ntokens);

    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {
        out_string(c, ""CLIENT_ERROR bad command line format"");
        return;
    }

    key = tokens[KEY_TOKEN].value;
    nkey = tokens[KEY_TOKEN].length;

    if (! (safe_strtoul(tokens[2].value, (uint32_t *)&flags)
           && safe_strtol(tokens[3].value, &exptime_int)
           && safe_strtol(tokens[4].value, (int32_t *)&vlen))) {
        out_string(c, ""CLIENT_ERROR bad command line format"");
        return;
    }

    exptime = realtime(EXPTIME_TO_POSITIVE_TIME(exptime_int));

    // does cas value exist?
    if (handle_cas) {
        if (!safe_strtoull(tokens[5].value, &req_cas...",1918.0,2018.0,1.0,15.0,101.0,108,22,104,27,0,33,11,16,6,20,,0,21,10,5,5,void
1731,61102,process_touch_command,1,process_touch_command,"void process_touch_command (conn*,token_t*,size_t)",proto_text.c,"static void process_touch_command(conn *c, token_t *tokens, const size_t ntokens) {
    char *key;
    size_t nkey;
    int32_t exptime_int = 0;
    rel_time_t exptime = 0;
    item *it;

    assert(c != NULL);

    set_noreply_maybe(c, tokens, ntokens);

    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {
        out_string(c, ""CLIENT_ERROR bad command line format"");
        return;
    }

    key = tokens[KEY_TOKEN].value;
    nkey = tokens[KEY_TOKEN].length;

    if (!safe_strtol(tokens[2].value, &exptime_int)) {
        out_string(c, ""CLIENT_ERROR invalid exptime argument"");
        return;
    }

    exptime = realtime(EXPTIME_TO_POSITIVE_TIME(exptime_int));
    it = item_touch(key, nkey, exptime, c);
    if (it) {
        pthread_mutex_lock(&c->thread->stats.mutex);
        c->thread->stats.touch_cmds++;
        c->thread->stats.slab_stats[ITEM_clsid(it)].touch_hits++;
        pthread_mutex_unlock(&c->thread->stats.mutex);

        out_string(c, ""TOUCHED"");
        item_remov...",2020.0,2062.0,1.0,15.0,43.0,46,16,34,9,0,12,4,4,1,8,,0,7,6,3,3,void
1732,61300,process_arithmetic_command,1,process_arithmetic_command,"void process_arithmetic_command (conn*,token_t*,size_t,bool)",proto_text.c,"static void process_arithmetic_command(conn *c, token_t *tokens, const size_t ntokens, const bool incr) {
    char temp[INCR_MAX_STORAGE_LEN];
    uint64_t delta;
    char *key;
    size_t nkey;

    assert(c != NULL);

    set_noreply_maybe(c, tokens, ntokens);

    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {
        out_string(c, ""CLIENT_ERROR bad command line format"");
        return;
    }

    key = tokens[KEY_TOKEN].value;
    nkey = tokens[KEY_TOKEN].length;

    if (!safe_strtoull(tokens[2].value, &delta)) {
        out_string(c, ""CLIENT_ERROR invalid numeric delta argument"");
        return;
    }

    switch(add_delta(c, key, nkey, incr, delta, temp, NULL)) {
    case OK:
        out_string(c, temp);
        break;
    case NON_NUMERIC:
        out_string(c, ""CLIENT_ERROR cannot increment or decrement non-numeric value"");
        break;
    case EOM:
        out_of_memory(c, ""SERVER_ERROR out of memory"");
        break;
    case DELTA_ITEM_NOT_FOUND:
        pthread_m...",2064.0,2111.0,1.0,14.0,48.0,26,9,35,14,0,12,10,6,2,9,,0,5,8,4,4,void
1733,61446,process_delete_command,1,process_delete_command,"void process_delete_command (conn*,token_t*,size_t)",proto_text.c,"static void process_delete_command(conn *c, token_t *tokens, const size_t ntokens) {
    char *key;
    size_t nkey;
    item *it;
    uint32_t hv;

    assert(c != NULL);

    if (ntokens > 3) {
        bool hold_is_zero = strcmp(tokens[KEY_TOKEN+1].value, ""0"") == 0;
        bool sets_noreply = set_noreply_maybe(c, tokens, ntokens);
        bool valid = (ntokens == 4 && (hold_is_zero || sets_noreply))
            || (ntokens == 5 && hold_is_zero && sets_noreply);
        if (!valid) {
            out_string(c, ""CLIENT_ERROR bad command line format.  ""
                       ""Usage: delete <key> [noreply]"");
            return;
        }
    }


    key = tokens[KEY_TOKEN].value;
    nkey = tokens[KEY_TOKEN].length;

    if(nkey > KEY_MAX_LENGTH) {
        out_string(c, ""CLIENT_ERROR bad command line format"");
        return;
    }

    if (settings.detail_enabled) {
        stats_prefix_record_delete(key, nkey);
    }

    it = item_get_locked(key, nkey, c, DONT_UPDATE, &hv);
    i...",2114.0,2167.0,1.0,42.0,54.0,45,16,44,13,0,13,6,7,1,9,,0,6,6,3,3,void
1734,61647,process_verbosity_command,1,process_verbosity_command,"void process_verbosity_command (conn*,token_t*,size_t)",proto_text.c,"static void process_verbosity_command(conn *c, token_t *tokens, const size_t ntokens) {
    unsigned int level;

    assert(c != NULL);

    set_noreply_maybe(c, tokens, ntokens);

    if (!safe_strtoul(tokens[1].value, (uint32_t*)&level)) {
        out_string(c, ""CLIENT_ERROR bad command line format"");
        return;
    }
    settings.verbose = level > MAX_VERBOSITY_LEVEL ? MAX_VERBOSITY_LEVEL : level;
    out_string(c, ""OK"");
    return;
}",2169.0,2183.0,1.0,31.0,15.0,10,9,12,6,0,5,2,2,1,4,,0,2,6,3,3,void
1735,61698,process_slabs_automove_command,1,process_slabs_automove_command,"void process_slabs_automove_command (conn*,token_t*,size_t)",proto_text.c,"static void process_slabs_automove_command(conn *c, token_t *tokens, const size_t ntokens) {
    unsigned int level;
    double ratio;

    assert(c != NULL);

    set_noreply_maybe(c, tokens, ntokens);

    if (strcmp(tokens[2].value, ""ratio"") == 0) {
        if (ntokens < 5 || !safe_strtod(tokens[3].value, &ratio)) {
            out_string(c, ""ERROR"");
            return;
        }
        settings.slab_automove_ratio = ratio;
    } else {
        if (!safe_strtoul(tokens[2].value, (uint32_t*)&level)) {
            out_string(c, ""CLIENT_ERROR bad command line format"");
            return;
        }
        if (level == 0) {
            settings.slab_automove = 0;
        } else if (level == 1 || level == 2) {
            settings.slab_automove = level;
        } else {
            out_string(c, ""ERROR"");
            return;
        }
    }
    out_string(c, ""OK"");
    return;
}",2231.0,2261.0,1.0,1.0,31.0,12,9,13,6,0,5,3,4,1,4,,0,2,6,3,3,void
1736,61805,process_watch_command,1,process_watch_command,"void process_watch_command (conn*,token_t*,size_t)",proto_text.c,"static void process_watch_command(conn *c, token_t *tokens, const size_t ntokens) {
    uint16_t f = 0;
    int x;
    assert(c != NULL);

    set_noreply_maybe(c, tokens, ntokens);
    if (!settings.watch_enabled) {
        out_string(c, ""CLIENT_ERROR watch commands not allowed"");
        return;
    }

    if (resp_has_stack(c)) {
        out_string(c, ""ERROR cannot pipeline other commands before watch"");
        return;
    }

    if (ntokens > 2) {
        for (x = COMMAND_TOKEN + 1; x < ntokens - 1; x++) {
            if ((strcmp(tokens[x].value, ""rawcmds"") == 0)) {
                f |= LOG_RAWCMDS;
            } else if ((strcmp(tokens[x].value, ""evictions"") == 0)) {
                f |= LOG_EVICTIONS;
            } else if ((strcmp(tokens[x].value, ""fetchers"") == 0)) {
                f |= LOG_FETCHERS;
            } else if ((strcmp(tokens[x].value, ""mutations"") == 0)) {
                f |= LOG_MUTATIONS;
            } else if ((strcmp(tokens[x].value, ""sysevents"") == 0)) {...",2264.0,2321.0,1.0,17.0,58.0,16,13,28,11,0,10,10,10,4,8,,0,4,6,3,3,void
1737,62089,process_memlimit_command,1,process_memlimit_command,"void process_memlimit_command (conn*,token_t*,size_t)",proto_text.c,"static void process_memlimit_command(conn *c, token_t *tokens, const size_t ntokens) {
    uint32_t memlimit;
    assert(c != NULL);

    set_noreply_maybe(c, tokens, ntokens);

    if (!safe_strtoul(tokens[1].value, &memlimit)) {
        out_string(c, ""ERROR"");
    } else {
        if (memlimit < 8) {
            out_string(c, ""MEMLIMIT_TOO_SMALL cannot set maxbytes to less than 8m"");
        } else {
            if (memlimit > 1000000000) {
                out_string(c, ""MEMLIMIT_ADJUST_FAILED input value is megabytes not bytes"");
            } else if (slabs_adjust_mem_limit((size_t) memlimit * 1024 * 1024)) {
                if (settings.verbose > 0) {
                    fprintf(stderr, ""maxbytes adjusted to %llum\n"", (unsigned long long)memlimit);
                }

                out_string(c, ""OK"");
            } else {
                out_string(c, ""MEMLIMIT_ADJUST_FAILED out of bounds or unable to adjust"");
            }
        }
    }
}",2323.0,2348.0,1.0,1.0,26.0,5,5,8,5,0,3,2,2,1,3,,0,1,6,3,3,void
1738,62172,process_lru_command,1,process_lru_command,"void process_lru_command (conn*,token_t*,size_t)",proto_text.c,"static void process_lru_command(conn *c, token_t *tokens, const size_t ntokens) {
    uint32_t pct_hot;
    uint32_t pct_warm;
    double hot_factor;
    int32_t ttl;
    double factor;

    set_noreply_maybe(c, tokens, ntokens);

    if (strcmp(tokens[1].value, ""tune"") == 0 && ntokens >= 7) {
        if (!safe_strtoul(tokens[2].value, &pct_hot) ||
            !safe_strtoul(tokens[3].value, &pct_warm) ||
            !safe_strtod(tokens[4].value, &hot_factor) ||
            !safe_strtod(tokens[5].value, &factor)) {
            out_string(c, ""ERROR"");
        } else {
            if (pct_hot + pct_warm > 80) {
                out_string(c, ""ERROR hot and warm pcts must not exceed 80"");
            } else if (factor <= 0 || hot_factor <= 0) {
                out_string(c, ""ERROR hot/warm age factors must be greater than 0"");
            } else {
                settings.hot_lru_pct = pct_hot;
                settings.warm_lru_pct = pct_warm;
                settings.hot_max_factor = ho...",2350.0,2405.0,1.0,1.0,56.0,24,8,14,7,0,6,3,4,4,6,,0,4,6,3,3,void
1739,62431,process_flush_all_command,1,process_flush_all_command,"void process_flush_all_command (conn*,token_t*,size_t)",proto_text.c,"static void process_flush_all_command(conn *c, token_t *tokens, const size_t ntokens) {
    int32_t exptime = 0;
    rel_time_t new_oldest = 0;

    set_noreply_maybe(c, tokens, ntokens);

    pthread_mutex_lock(&c->thread->stats.mutex);
    c->thread->stats.flush_cmds++;
    pthread_mutex_unlock(&c->thread->stats.mutex);

    if (!settings.flush_enabled) {
        // flush_all is not allowed but we log it on stats
        out_string(c, ""CLIENT_ERROR flush_all not allowed"");
        return;
    }

    if (ntokens != (c->noreply ? 3 : 2)) {
        if (!safe_strtol(tokens[1].value, &exptime)) {
            out_string(c, ""CLIENT_ERROR invalid exptime argument"");
            return;
        }
    }

    /*
      If exptime is zero realtime() would return zero too, and
      realtime(exptime) - 1 would overflow to the max unsigned
      value.  So we process exptime == 0 the same way we do when
      no delay is given at all.
    */
    if (exptime > 0) {
        new_oldest = realtime(e...",2467.0,2510.0,1.0,1.0,44.0,33,12,25,7,0,16,7,9,5,7,,0,12,6,3,3,void
1740,62559,process_version_command,1,process_version_command,void process_version_command (conn*),proto_text.c,"static void process_version_command(conn *c) {
    out_string(c, ""VERSION "" VERSION);
}",2512.0,2514.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
1741,62565,process_quit_command,1,process_quit_command,void process_quit_command (conn*),proto_text.c,"static void process_quit_command(conn *c) {
    conn_set_state(c, conn_mwrite);
    c->close_after_write = true;
    c->close_reason = NORMAL_CLOSE;
}",2516.0,2520.0,1.0,1.0,5.0,4,2,6,4,0,3,1,1,0,1,,0,2,2,1,1,void
1742,62583,process_shutdown_command,1,process_shutdown_command,"void process_shutdown_command (conn*,token_t*,size_t)",proto_text.c,"static void process_shutdown_command(conn *c, token_t *tokens, const size_t ntokens) {
    if (!settings.shutdown_command) {
        out_string(c, ""ERROR: shutdown not enabled"");
        return;
    }

    if (ntokens == 2) {
        c->close_reason = SHUTDOWN_CLOSE;
        conn_set_state(c, conn_closing);
        raise(SIGINT);
    } else if (ntokens == 3 && strcmp(tokens[SUBCOMMAND_TOKEN].value, ""graceful"") == 0) {
        c->close_reason = SHUTDOWN_CLOSE;
        conn_set_state(c, conn_closing);
        raise(SIGUSR1);
    } else {
        out_string(c, ""CLIENT_ERROR invalid shutdown mode"");
    }
}",2522.0,2539.0,1.0,45.0,18.0,5,5,8,6,0,4,3,3,1,2,,0,2,6,3,3,void
1743,62649,process_slabs_command,1,process_slabs_command,"void process_slabs_command (conn*,token_t*,size_t)",proto_text.c,"static void process_slabs_command(conn *c, token_t *tokens, const size_t ntokens) {
    if (ntokens == 5 && strcmp(tokens[COMMAND_TOKEN + 1].value, ""reassign"") == 0) {
        int src, dst, rv;

        if (settings.slab_reassign == false) {
            out_string(c, ""CLIENT_ERROR slab reassignment disabled"");
            return;
        }

        if (! (safe_strtol(tokens[2].value, (int32_t*)&src)
               && safe_strtol(tokens[3].value, (int32_t*)&dst))) {
            out_string(c, ""CLIENT_ERROR bad command line format"");
            return;
        }

        rv = slabs_reassign(src, dst);
        switch (rv) {
        case REASSIGN_OK:
            out_string(c, ""OK"");
            break;
        case REASSIGN_RUNNING:
            out_string(c, ""BUSY currently processing reassign request"");
            break;
        case REASSIGN_BADCLASS:
            out_string(c, ""BADCLASS invalid src or dst class id"");
            break;
        case REASSIGN_NOSPARE:
            out_st...",2541.0,2581.0,1.0,38.0,41.0,19,9,24,13,0,11,10,8,3,10,,0,4,6,3,3,void
1744,62786,process_lru_crawler_command,1,process_lru_crawler_command,"void process_lru_crawler_command (conn*,token_t*,size_t)",proto_text.c,"static void process_lru_crawler_command(conn *c, token_t *tokens, const size_t ntokens) {
    if (ntokens == 4 && strcmp(tokens[COMMAND_TOKEN + 1].value, ""crawl"") == 0) {
        int rv;
        if (settings.lru_crawler == false) {
            out_string(c, ""CLIENT_ERROR lru crawler disabled"");
            return;
        }

        rv = lru_crawler_crawl(tokens[2].value, CRAWLER_EXPIRED, NULL, 0,
                settings.lru_crawler_tocrawl);
        switch(rv) {
        case CRAWLER_OK:
            out_string(c, ""OK"");
            break;
        case CRAWLER_RUNNING:
            out_string(c, ""BUSY currently processing crawler request"");
            break;
        case CRAWLER_BADCLASS:
            out_string(c, ""BADCLASS invalid class id"");
            break;
        case CRAWLER_NOTSTARTED:
            out_string(c, ""NOTSTARTED no items to crawl"");
            break;
        case CRAWLER_ERROR:
            out_string(c, ""ERROR an unknown error happened"");
            break;
    ...",2583.0,2694.0,1.0,38.0,112.0,12,6,21,13,0,9,9,6,1,7,,0,3,6,3,3,void
1745,63159,process_command_ascii,1,process_command_ascii,"void process_command_ascii (conn*,char*)",proto_text.c,"void process_command_ascii(conn *c, char *command) {

    token_t tokens[MAX_TOKENS];
    size_t ntokens;
    int comm;

    assert(c != NULL);

    MEMCACHED_PROCESS_COMMAND_START(c->sfd, c->rcurr, c->rbytes);

    if (settings.verbose > 1)
        fprintf(stderr, ""<%d %s\n"", c->sfd, command);

    /*
     * for commands set/add/replace, we build an item and read the data
     * directly into it, then continue in nread_complete().
     */

    // Prep the response object for this query.
    if (!resp_start(c)) {
        conn_set_state(c, conn_closing);
        return;
    }

    ntokens = tokenize_command(command, tokens, MAX_TOKENS);
    // All commands need a minimum of two tokens: cmd and NULL finalizer
    // There are also no valid commands shorter than two bytes.
    if (ntokens < 2 || tokens[COMMAND_TOKEN].length < 2) {
        out_string(c, ""ERROR"");
        return;
    }

    // Meta commands are all 2-char in length.
    char first = tokens[COMMAND_TOKEN].value[0];
    if...",2716.0,2928.0,1.0,19.0,213.0,23,11,39,10,1,14,13,7,2,12,,0,4,4,2,2,void
1746,64994,key_hash_func,1,key_hash_func,"uint64_t key_hash_func (void*,size_t,uint64_t)",proxy.h,"typedef uint64_t (*key_hash_func)(const void *key, size_t len, uint64_t seed);",234.0,234.0,18.0,77.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,uint64_t
1747,65003,key_hash_filter_func,1,key_hash_filter_func,"char* key_hash_filter_func (char*,char*,size_t,size_t*)",proxy.h,"typedef const char *(*key_hash_filter_func)(const char *conf, const char *key, size_t klen, size_t *newlen);",238.0,238.0,20.0,107.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,char*
1748,65011,hash_selector_func,1,hash_selector_func,"uint32_t hash_selector_func (uint64_t,void*)",proxy.h,"typedef uint32_t (*hash_selector_func)(uint64_t hash, void *ctx);",239.0,239.0,18.0,64.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,uint32_t
1749,65274,proxy_init_evthread_events,1,proxy_init_evthread_events,void proxy_init_evthread_events (proxy_event_thread_t*),proxy_network.c,"void proxy_init_evthread_events(proxy_event_thread_t *t) {
#ifdef HAVE_LIBURING
    bool use_uring = t->ctx->use_uring;
    struct io_uring_params p = {0};
    assert(t->event_fd); // uring only exists where eventfd also does.

    // Setup the CQSIZE to be much larger than SQ size, since backpressure
    // issues can cause us to block on SQ submissions and as a network server,
    // stuff happens.

    if (use_uring) {
        p.flags = IORING_SETUP_CQSIZE;
        p.cq_entries = PRING_QUEUE_CQ_ENTRIES;
        int ret = io_uring_queue_init_params(PRING_QUEUE_SQ_ENTRIES, &t->ring, &p);
        if (ret) {
            perror(""io_uring_queue_init_params"");
            exit(1);
        }
        if (!(p.features & IORING_FEAT_NODROP)) {
            fprintf(stderr, ""uring: kernel missing IORING_FEAT_NODROP, using libevent\n"");
            use_uring = false;
        }
        if (!(p.features & IORING_FEAT_SINGLE_MMAP)) {
            fprintf(stderr, ""uring: kernel missing IORING_FEAT_S...",1020.0,1111.0,1.0,1.0,92.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
1750,65279,proxy_event_thread,1,proxy_event_thread,void* proxy_event_thread (void*),proxy_network.c,"void *proxy_event_thread(void *arg) {
    proxy_event_thread_t *t = arg;

    logger_create(); // TODO (v2): add logger ptr to structure
    event_base_loop(t->base, 0);
    event_base_free(t->base);

    // TODO (v2): join bt threads, free array.

    return NULL;
}",460.0,470.0,1.0,1.0,11.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void*
1751,65296,mcplib_await,1,mcplib_await,int mcplib_await (lua_State*),proxy_await.c,"int mcplib_await(lua_State *L) {
    mcp_request_t *rq = luaL_checkudata(L, 1, ""mcp.request"");
    luaL_checktype(L, 2, LUA_TTABLE);
    int n = 0; // length of table of pools
    int wait_for = 0; // 0 means wait for all responses
    enum mcp_await_e type = AWAIT_GOOD;

    lua_pushnil(L); // init table key
    while (lua_next(L, 2) != 0) {
        luaL_checkudata(L, -1, ""mcp.pool_proxy"");
        lua_pop(L, 1); // remove value, keep key.
        n++;
    }

    if (n <= 0) {
        proxy_lua_error(L, ""mcp.await arguments must have at least one pool"");
    }

    if (lua_isnumber(L, 4)) {
        type = lua_tointeger(L, 4);
        lua_pop(L, 1);
        switch (type) {
            case AWAIT_GOOD:
            case AWAIT_ANY:
            case AWAIT_OK:
            case AWAIT_FIRST:
                break;
            default:
                proxy_lua_error(L, ""invalid type argument tp mcp.await"");
        }
    }

    if (lua_isnumber(L, 3)) {
        wait_for = lua_tointeger(L, ...",26.0,91.0,1.0,4.0,66.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
1752,65301,mcplib_await_run,1,mcplib_await_run,"int mcplib_await_run (conn*,mc_resp*,lua_State*,int)",proxy_await.c,"int mcplib_await_run(conn *c, mc_resp *resp, lua_State *L, int coro_ref) {
    P_DEBUG(""%s: start\n"", __func__);
    mcp_await_t *aw = lua_touserdata(L, -1);
    int await_ref = luaL_ref(L, LUA_REGISTRYINDEX); // await is popped.
    assert(aw != NULL);
    lua_rawgeti(L, LUA_REGISTRYINDEX, aw->argtable_ref); // -> 1
    //dump_stack(L);
    mcp_request_t *rq = aw->rq;
    aw->coro_ref = coro_ref;

    // create result table
    lua_newtable(L); // -> 2
    aw->restable_ref = luaL_ref(L, LUA_REGISTRYINDEX); // pop the result table

    // prepare the request key
    const char *key = MCP_PARSER_KEY(rq->pr);
    size_t len = rq->pr.klen;
    int n = 0;
    bool await_first = true;
    // loop arg table and run each hash selector
    lua_pushnil(L); // -> 3
    while (lua_next(L, 1) != 0) {
        P_DEBUG(""%s: top of loop\n"", __func__);
        // (key, -2), (val, -1)
        mcp_pool_proxy_t *pp = luaL_testudata(L, -1, ""mcp.pool_proxy"");
        if (pp == NULL) {
            proxy_l...",182.0,231.0,1.0,4.0,50.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,int
1753,65309,mcplib_await_return,1,mcplib_await_return,int mcplib_await_return (io_pending_proxy_t*),proxy_await.c,"int mcplib_await_return(io_pending_proxy_t *p) {
    mcp_await_t *aw;
    lua_State *L = p->thread->L; // use the main VM coroutine for work
    bool cleanup = false;
    bool valid = false; // is response valid to add to the result table.
    bool completing = false;

    // TODO (v2): just push the await ptr into *p?
    lua_rawgeti(L, LUA_REGISTRYINDEX, p->await_ref);
    aw = lua_touserdata(L, -1);
    lua_pop(L, 1); // remove AW object from stack
    assert(aw != NULL);
    P_DEBUG(""%s: start [pending: %d]\n"", __func__, aw->pending);
    //dump_stack(L);

    aw->pending--;
    assert(aw->pending >= 0);
    // Await not yet satisfied.
    // If wait_for != 0 check for response success
    // if success and wait_for is *now* 0, we complete.
    // add successful response to response table
    // Also, if no wait_for, add response to response table
    // TODO (v2): for GOOD or OK cases, it might be better to return the
    // last object as valid if there are otherwise zero vali...",238.0,366.0,1.0,4.0,129.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,int
1754,65314,mcplib_add_stat,1,mcplib_add_stat,int mcplib_add_stat (lua_State*),proxy_ustats.c,"int mcplib_add_stat(lua_State *L) {
    LIBEVENT_THREAD *t = lua_touserdata(L, lua_upvalueindex(MCP_THREAD_UPVALUE));
    if (t != NULL) {
        proxy_lua_error(L, ""add_stat must be called from config_pools"");
        return 0;
    }
    int idx = luaL_checkinteger(L, -2);
    const char *name = luaL_checkstring(L, -1);

    if (idx < 1) {
        proxy_lua_error(L, ""stat index must be 1 or higher"");
        return 0;
    }
    // max user counters? 1024? some weird number.
    if (idx > 1024) {
        proxy_lua_error(L, ""stat index must be 1024 or less"");
        return 0;
    }
    // max name length? avoids errors if something huge gets thrown in.
    if (strlen(name) > STAT_KEY_LEN - 6) {
        // we prepend ""user_"" to the output. + null byte.
        proxy_lua_ferror(L, ""stat name too long: %s\n"", name);
        return 0;
    }
    // restrict characters, at least no spaces/newlines.
    for (int x = 0; x < strlen(name); x++) {
        if (isspace(name[x])) {
            p...",7.0,70.0,1.0,60.0,64.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
1755,65319,mcplib_stat,1,mcplib_stat,int mcplib_stat (lua_State*),proxy_ustats.c,"int mcplib_stat(lua_State *L) {
    LIBEVENT_THREAD *t = lua_touserdata(L, lua_upvalueindex(MCP_THREAD_UPVALUE));
    if (t == NULL) {
        proxy_lua_error(L, ""stat must be called from router handlers"");
        return 0;
    }

    struct proxy_user_stats *tus = t->proxy_user_stats;
    if (tus == NULL) {
        proxy_lua_error(L, ""no stats counters initialized"");
        return 0;
    }

    int idx = luaL_checkinteger(L, -2);
    int change = luaL_checkinteger(L, -1);

    if (idx < 1 || idx > tus->num_stats) {
        proxy_lua_error(L, ""stat index out of range"");
        return 0;
    }

    idx--; // actual array is 0 indexed.
    WSTAT_L(t);
    tus->counters[idx] += change;
    WSTAT_UL(t);

    return 0;
}",72.0,99.0,1.0,60.0,28.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
1756,65324,_process_request_next_key,1,_process_request_next_key,size_t _process_request_next_key (mcp_parser_t*),proxy_request.c,"size_t _process_request_next_key(mcp_parser_t *pr) {
    const char *cur = pr->request + pr->parsed;
    int remain = pr->reqlen - pr->parsed - 2;

    // chew off any leading whitespace.
    while (remain) {
        if (*cur == ' ') {
            remain--;
            cur++;
            pr->parsed++;
        } else {
            break;
        }
    }

    const char *s = memchr(cur, ' ', remain);
    if (s != NULL) {
        pr->klen = s - cur;
        pr->parsed += s - cur;
    } else {
        pr->klen = remain;
        pr->parsed += remain;
    }

    return cur - pr->request;
}",94.0,119.0,1.0,1.0,26.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,size_t
1757,65329,process_request,1,process_request,"int process_request (mcp_parser_t*,char*,size_t)",proxy_request.c,"int process_request(mcp_parser_t *pr, const char *command, size_t cmdlen) {
    // we want to ""parse in place"" as much as possible, which allows us to
    // forward an unmodified request without having to rebuild it.

    const char *cm = command;
    size_t cl = 0;
    // min command length is 2, plus the ""\r\n""
    if (cmdlen < 4) {
        return -1;
    }

    const char *s = memchr(command, ' ', cmdlen-2);
    if (s != NULL) {
        cl = s - command;
    } else {
        cl = cmdlen - 2;
    }
    pr->keytoken = 0;
    pr->has_space = false;
    pr->parsed = cl + 1;
    pr->request = command;
    pr->reqlen = cmdlen;
    int token_max = PARSER_MAX_TOKENS;

    int cmd = -1;
    int type = CMD_TYPE_GENERIC;
    int ret = 0;

    switch (cl) {
        case 0:
        case 1:
            // falls through with cmd as -1. should error.
            break;
        case 2:
            if (cm[0] == 'm') {
                type = CMD_TYPE_META;
                switch (cm[1]) {
        ...",282.0,438.0,1.0,20.0,157.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,int
1758,65336,mcp_new_request,1,mcp_new_request,"mcp_request_t* mcp_new_request (lua_State*,mcp_parser_t*,char*,size_t)",proxy_request.c,"mcp_request_t *mcp_new_request(lua_State *L, mcp_parser_t *pr, const char *command, size_t cmdlen) {
    // reserving an upvalue for key.
    mcp_request_t *rq = lua_newuserdatauv(L, sizeof(mcp_request_t) + MCP_REQUEST_MAXLEN * 2 + KEY_MAX_LENGTH, 1);
    // TODO (v2): memset only the non-data part? as the rest gets memcpy'd
    // over.
    memset(rq, 0, sizeof(mcp_request_t));
    memcpy(&rq->pr, pr, sizeof(*pr));

    memcpy(rq->request, command, cmdlen);
    rq->pr.request = rq->request;
    rq->pr.reqlen = cmdlen;
    gettimeofday(&rq->start, NULL);

    luaL_getmetatable(L, ""mcp.request"");
    lua_setmetatable(L, -2);

    // at this point we should know if we have to bounce through _nread to
    // get item data or not.
    return rq;
}",441.0,460.0,1.0,69.0,20.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,mcp_request_t
1759,65344,mcplib_request,1,mcplib_request,int mcplib_request (lua_State*),proxy_request.c,"int mcplib_request(lua_State *L) {
    size_t len = 0;
    size_t vlen = 0;
    mcp_parser_t pr = {0};
    const char *cmd = luaL_checklstring(L, 1, &len);
    const char *val = NULL;
    int type = lua_type(L, 2);
    if (type == LUA_TSTRING) {
        val = luaL_optlstring(L, 2, NULL, &vlen);
        if (vlen < 2 || memcmp(val+vlen-2, ""\r\n"", 2) != 0) {
            proxy_lua_error(L, ""value passed to mcp.request must end with \\r\\n"");
        }
    } else if (type == LUA_TUSERDATA) {
        // vlen for requests and responses include the ""\r\n"" already.
        mcp_resp_t *r = luaL_testudata(L, 2, ""mcp.response"");
        if (r != NULL) {
            if (r->resp.value) {
                val = r->resp.value;
                vlen = r->resp.vlen_read; // paranoia, so we can't overread into memory.
            }
        } else {
            mcp_request_t *rq = luaL_testudata(L, 2, ""mcp.request"");
            if (rq->pr.vbuf) {
                val = rq->pr.vbuf;
                vlen =...",537.0,591.0,1.0,1.0,55.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
1760,65349,mcplib_request_command,1,mcplib_request_command,int mcplib_request_command (lua_State*),proxy_request.c,"int mcplib_request_command(lua_State *L) {
    mcp_request_t *rq = luaL_checkudata(L, -1, ""mcp.request"");
    lua_pushinteger(L, rq->pr.command);
    return 1;
}",703.0,707.0,1.0,1.0,5.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
1761,65354,mcplib_request_key,1,mcplib_request_key,int mcplib_request_key (lua_State*),proxy_request.c,"int mcplib_request_key(lua_State *L) {
    mcp_request_t *rq = luaL_checkudata(L, -1, ""mcp.request"");
    lua_pushlstring(L, MCP_PARSER_KEY(rq->pr), rq->pr.klen);
    return 1;
}",593.0,597.0,1.0,23.0,5.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
1762,65359,mcplib_request_ltrimkey,1,mcplib_request_ltrimkey,int mcplib_request_ltrimkey (lua_State*),proxy_request.c,"int mcplib_request_ltrimkey(lua_State *L) {
    mcp_request_t *rq = luaL_checkudata(L, -2, ""mcp.request"");
    int totrim = luaL_checkinteger(L, -1);
    char *key = (char *) MCP_PARSER_KEY(rq->pr);

    if (totrim > rq->pr.klen) {
        proxy_lua_error(L, ""ltrimkey cannot zero out key"");
        return 0;
    } else {
        memset(key, ' ', totrim);
        rq->pr.klen -= totrim;
        rq->pr.tokens[rq->pr.keytoken] += totrim;
    }
    return 1;
}",604.0,618.0,1.0,25.0,15.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
1763,65364,mcplib_request_rtrimkey,1,mcplib_request_rtrimkey,int mcplib_request_rtrimkey (lua_State*),proxy_request.c,"int mcplib_request_rtrimkey(lua_State *L) {
    mcp_request_t *rq = luaL_checkudata(L, -2, ""mcp.request"");
    int totrim = luaL_checkinteger(L, -1);
    char *key = (char *) MCP_PARSER_KEY(rq->pr);

    if (totrim > rq->pr.klen) {
        proxy_lua_error(L, ""rtrimkey cannot zero out key"");
        return 0;
    } else {
        memset(key + (rq->pr.klen - totrim), ' ', totrim);
        rq->pr.klen -= totrim;
        // don't need to change the key token.
    }
    return 1;
}",620.0,634.0,1.0,25.0,15.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
1764,65369,mcplib_request_token,1,mcplib_request_token,int mcplib_request_token (lua_State*),proxy_request.c,"int mcplib_request_token(lua_State *L) {
    mcp_request_t *rq = luaL_checkudata(L, 1, ""mcp.request"");
    int argc = lua_gettop(L);

    if (argc == 1) {
        lua_pushnil(L);
        return 1;
    }

    int token = luaL_checkinteger(L, 2);

    if (token < 1 || token > rq->pr.ntokens) {
        // maybe an error?
        lua_pushnil(L);
        return 1;
    }

    // we hold overwritten or parsed tokens in a lua table.
    if (rq->tokent_ref == 0) {
        // create a presized table that can hold our tokens.
        lua_createtable(L, rq->pr.ntokens, 0);
        // duplicate value to set back
        lua_pushvalue(L, -1);
        rq->tokent_ref = luaL_ref(L, LUA_REGISTRYINDEX);
    } else {
        lua_rawgeti(L, LUA_REGISTRYINDEX, rq->tokent_ref);
    }
    // top of stack should be token table.

    size_t vlen = 0;
    if (argc > 2) {
        // overwriting a token.
        luaL_checklstring(L, 3, &vlen);
        lua_pushvalue(L, 3); // copy to top of stack
        lua_raw...",637.0,695.0,1.0,12.0,59.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
1765,65374,mcplib_request_ntokens,1,mcplib_request_ntokens,int mcplib_request_ntokens (lua_State*),proxy_request.c,"int mcplib_request_ntokens(lua_State *L) {
    mcp_request_t *rq = luaL_checkudata(L, 1, ""mcp.request"");
    lua_pushinteger(L, rq->pr.ntokens);
    return 1;
}",697.0,701.0,1.0,1.0,5.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
1766,65379,mcplib_request_has_flag,1,mcplib_request_has_flag,int mcplib_request_has_flag (lua_State*),proxy_request.c,"int mcplib_request_has_flag(lua_State *L) {
    mcp_request_t *rq = luaL_checkudata(L, 1, ""mcp.request"");
    size_t len = 0;
    const char *flagstr = luaL_checklstring(L, 2, &len);
    if (len != 1) {
        proxy_lua_error(L, ""has_flag(): meta flag must be a single character"");
        return 0;
    }
    if (flagstr[0] < 65 || flagstr[0] > 122) {
        proxy_lua_error(L, ""has_flag(): invalid flag, must be A-Z,a-z"");
        return 0;
    }
    uint64_t flagbit = (uint64_t)1 << (flagstr[0] - 65);
    if (rq->pr.t.meta.flags & flagbit) {
        lua_pushboolean(L, 1);
    } else {
        lua_pushboolean(L, 0);
    }

    return 1;
}",709.0,729.0,1.0,1.0,21.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
1767,65384,mcplib_request_flag_token,1,mcplib_request_flag_token,int mcplib_request_flag_token (lua_State*),proxy_request.c,"int mcplib_request_flag_token(lua_State *L) {
    mcp_request_t *rq = luaL_checkudata(L, 1, ""mcp.request"");
    size_t len = 0;
    const char *flagstr = luaL_checklstring(L, 2, &len);
    bool replace = false;
    if (len != 1) {
        proxy_lua_error(L, ""has_flag(): meta flag must be a single character"");
        return 0;
    }
    if (flagstr[0] < 65 || flagstr[0] > 122) {
        proxy_lua_error(L, ""has_flag(): invalid flag, must be A-Z,a-z"");
        return 0;
    }
    if (lua_isstring(L, 3)) {
        // overwriting a flag/token with the third argument.
        // NOTE: semi duplicated from mcplib_request_token()
        if (rq->tokent_ref == 0) {
            // create a presized table that can hold our tokens.
            lua_createtable(L, rq->pr.ntokens, 0);
            rq->tokent_ref = luaL_ref(L, LUA_REGISTRYINDEX);
        }
        replace = true;
    }
    uint64_t flagbit = (uint64_t)1 << (flagstr[0] - 65);

    int ret = 1;
    if (rq->pr.t.meta.flags & flagbit) ...",733.0,792.0,1.0,1.0,60.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
1768,65389,mcplib_request_gc,1,mcplib_request_gc,int mcplib_request_gc (lua_State*),proxy_request.c,"int mcplib_request_gc(lua_State *L) {
    mcp_request_t *rq = luaL_checkudata(L, -1, ""mcp.request"");
    // During nread c->item is the malloc'ed buffer. not yet put into
    // rq->buf - this gets freed because we've also set c->item_malloced if
    // the connection closes before finishing nread.
    if (rq->pr.vbuf != NULL) {
        free(rq->pr.vbuf);
    }

    if (rq->tokent_ref != 0) {
        luaL_unref(L, LUA_REGISTRYINDEX, rq->tokent_ref);
    }
    return 0;
}",794.0,807.0,1.0,1.0,14.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
1769,65394,mcplib_open_dist_jump_hash,1,mcplib_open_dist_jump_hash,int mcplib_open_dist_jump_hash (lua_State*),proxy_jump_hash.c,"int mcplib_open_dist_jump_hash(lua_State *L) {
    const struct luaL_Reg jump_f[] = {
        {""new"", mcplib_dist_jump_hash_new},
        {NULL, NULL},
    };

    luaL_newlib(L, jump_f);

    return 1;
}",42.0,51.0,1.0,1.0,10.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
1770,65399,mcplib_open_dist_ring_hash,1,mcplib_open_dist_ring_hash,int mcplib_open_dist_ring_hash (lua_State*),proxy_ring_hash.c,"int mcplib_open_dist_ring_hash(lua_State *L) {
    const struct luaL_Reg ketama_f[] = {
        {""new"", ketama_new},
        {NULL, NULL},
    };

    luaL_newlib(L, ketama_f);
    lua_pushlightuserdata(L, &ketama_key_hash);
    lua_setfield(L, -2, ""hash"");

    return 1;
}",358.0,369.0,1.0,1.0,12.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
1771,65412,mcplib_pool_proxy_call_helper,1,mcplib_pool_proxy_call_helper,"mcp_backend_t* mcplib_pool_proxy_call_helper (lua_State*,mcp_pool_t*,char*,size_t)",proxy_lua.c,"mcp_backend_t *mcplib_pool_proxy_call_helper(lua_State *L, mcp_pool_t *p, const char *key, size_t len) {
    if (p->key_filter) {
        key = p->key_filter(p->key_filter_conf, key, len, &len);
        P_DEBUG(""%s: filtered key for hashing (%.*s)\n"", __func__, (int)len, key);
    }
    uint64_t hash = p->key_hasher(key, len, p->hash_seed);
    uint32_t lookup = p->phc.selector_func(hash, p->phc.ctx);

    assert(p->phc.ctx != NULL);
    // attach the backend to the request object.
    // the lua modules should ""think"" in 1 based indexes, so we need to
    // subtract one here.
    if (lookup >= p->pool_size) {
        proxy_lua_error(L, ""key dist hasher tried to use out of bounds index"");
    }

    return p->pool[lookup].be;
}",474.0,491.0,1.0,8.0,18.0,0,0,0,0,1,0,1,1,0,0,,0,0,8,4,4,mcp_backend_t
1772,65420,mcp_request_attach,1,mcp_request_attach,"void mcp_request_attach (lua_State*,mcp_request_t*,io_pending_proxy_t*)",proxy_request.c,"void mcp_request_attach(lua_State *L, mcp_request_t *rq, io_pending_proxy_t *p) {
    mcp_parser_t *pr = &rq->pr;
    char *r = (char *) pr->request;
    size_t len = pr->reqlen;

    // one or more of the tokens were changed
    if (rq->was_modified) {
        assert(rq->tokent_ref);
        // option table to top of stack.
        lua_rawgeti(L, LUA_REGISTRYINDEX, rq->tokent_ref);

        // space was reserved in case of modification.
        char *nr = rq->request + MCP_REQUEST_MAXLEN;
        r = nr;
        char *or = NULL;

        for (int x = 0; x < pr->ntokens; x++) {
            const char *newtok = NULL;
            size_t newlen = 0;
            if (x != 0 && x != pr->keytoken) {
                int type = lua_rawgeti(L, -1, x+1);
                if (type != LUA_TNIL) {
                    newtok = lua_tolstring(L, -1, &newlen);
                    memcpy(nr, newtok, newlen);
                    nr += newlen;
                }
                lua_pop(L, 1);
            ...",467.0,533.0,1.0,33.0,67.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,void
1773,65439,_start_proxy_config_threads,1,_start_proxy_config_threads,int _start_proxy_config_threads (proxy_ctx_t*),proxy_config.c,"int _start_proxy_config_threads(proxy_ctx_t *ctx) {
    int ret;

    pthread_mutex_lock(&ctx->config_lock);
    if ((ret = pthread_create(&ctx->config_tid, NULL,
                    _proxy_config_thread, ctx)) != 0) {
        fprintf(stderr, ""Failed to start proxy configuration thread: %s\n"",
                strerror(ret));
        pthread_mutex_unlock(&ctx->config_lock);
        return -1;
    }
    pthread_mutex_unlock(&ctx->config_lock);

    pthread_mutex_lock(&ctx->manager_lock);
    if ((ret = pthread_create(&ctx->manager_tid, NULL,
                    _proxy_manager_thread, ctx)) != 0) {
        fprintf(stderr, ""Failed to start proxy configuration thread: %s\n"",
                strerror(ret));
        pthread_mutex_unlock(&ctx->manager_lock);
        return -1;
    }
    pthread_mutex_unlock(&ctx->manager_lock);

    return 0;
}",159.0,183.0,1.0,1.0,25.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,int
1774,65444,proxy_thread_loadconf,1,proxy_thread_loadconf,int proxy_thread_loadconf (LIBEVENT_THREAD*),proxy_config.c,"int proxy_thread_loadconf(LIBEVENT_THREAD *thr) {
    lua_State *L = thr->L;
    // load the precompiled config function.
    proxy_ctx_t *ctx = settings.proxy_ctx;
    struct _dumpbuf *db = ctx->proxy_code;
    struct _dumpbuf db2; // copy because the helper modifies it.
    memcpy(&db2, db, sizeof(struct _dumpbuf));

    lua_load(L, _load_helper, &db2, ""config"", NULL);
    // LUA_OK + all errs from loadfile except LUA_ERRFILE.
    //dump_stack(L);
    // - pcall the func (which should load it)
    int res = lua_pcall(L, 0, LUA_MULTRET, 0);
    if (res != LUA_OK) {
        // FIXME (v2): don't exit here!
        fprintf(stderr, ""Failed to load data into worker thread\n"");
        return -1;
    }

    lua_getglobal(L, ""mcp_config_routes"");
    // create deepcopy of argument to pass into mcp_config_routes.
    // FIXME (v2): to avoid lua SIGABRT'ing on errors we need to protect the call
    // normal pattern:
    // lua_pushcfunction(L, &_copy_config_table);
    // lua_pushlightuser...",346.0,422.0,1.0,4.0,77.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,int
1775,65449,mcplib_open_hash_xxhash,1,mcplib_open_hash_xxhash,int mcplib_open_hash_xxhash (lua_State*),proxy_xxhash.c,"int mcplib_open_hash_xxhash(lua_State *L) {
    lua_pushlightuserdata(L, &mcplib_hash_xxhash);
    return 1;
}",9.0,12.0,1.0,1.0,4.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
1776,65651,mcp_queue_await_io,1,mcp_queue_await_io,"void mcp_queue_await_io (conn*,lua_State*,mcp_request_t*,int,bool)",proxy_await.c,"static void mcp_queue_await_io(conn *c, lua_State *Lc, mcp_request_t *rq, int await_ref, bool await_first) {
    io_queue_t *q = conn_io_queue_get(c, IO_QUEUE_PROXY);

    mcp_backend_t *be = rq->be;

    // Then we push a response object, which we'll re-use later.
    // reserve one uservalue for a lua-supplied response.
    mcp_resp_t *r = lua_newuserdatauv(Lc, sizeof(mcp_resp_t), 1);
    memset(r, 0, sizeof(mcp_resp_t));
    // Set noreply mode.
    // TODO (v2): the response ""inherits"" the request's noreply mode, which isn't
    // strictly correct; we should inherit based on the request that spawned
    // the coroutine but the structure doesn't allow that yet.
    // Should also be able to settle this exact mode from the parser so we
    // don't have to re-branch here.
    if (rq->pr.noreply) {
        if (rq->pr.cmd_type == CMD_TYPE_META) {
            r->mode = RESP_MODE_METAQUIET;
            for (int x = 2; x < rq->pr.ntokens; x++) {
                if (rq->request[rq->pr...",93.0,176.0,1.0,41.0,84.0,95,12,78,19,0,13,6,12,0,4,,0,11,10,5,5,void
1777,66474,_dump_helper,1,_dump_helper,"int _dump_helper (lua_State*,void*,size_t,void*)",proxy_config.c,"static int _dump_helper(lua_State *L, const void *p, size_t sz, void *ud) {
    (void)L;
    struct _dumpbuf *db = ud;
    if (db->used + sz > db->size) {
        db->size *= 2;
        char *nb = realloc(db->buf, db->size);
        if (nb == NULL) {
            return -1;
        }
        db->buf = nb;
    }
    memcpy(db->buf + db->used, (const char *)p, sz);
    db->used += sz;
    return 0;
}",13.0,27.0,1.0,1.0,15.0,21,9,20,7,0,9,3,4,2,0,,0,9,8,4,4,int
1778,66547,_load_helper,1,_load_helper,"const char* _load_helper (lua_State*,void*,size_t*)",proxy_config.c,"static const char * _load_helper(lua_State *L, void *data, size_t *size) {
    (void)L;
    struct _dumpbuf *db = data;
    if (db->used == 0) {
        *size = 0;
        return NULL;
    }
    *size = db->used;
    db->used = 0;
    return db->buf;
}",29.0,39.0,1.0,1.0,11.0,12,5,10,5,0,4,2,2,1,0,,0,4,6,3,3,const char*
1779,66617,_proxy_manager_thread,1,_proxy_manager_thread,void* _proxy_manager_thread (void*),proxy_config.c,"static void *_proxy_manager_thread(void *arg) {
    proxy_ctx_t *ctx = arg;
    pool_head_t head;

    pthread_mutex_lock(&ctx->manager_lock);
    while (1) {
        STAILQ_INIT(&head);
        while (STAILQ_EMPTY(&ctx->manager_head)) {
            pthread_cond_wait(&ctx->manager_cond, &ctx->manager_lock);
        }

        // pull dealloc queue into local queue.
        STAILQ_CONCAT(&head, &ctx->manager_head);
        pthread_mutex_unlock(&ctx->manager_lock);

        // Config lock is required for using config VM.
        pthread_mutex_lock(&ctx->config_lock);
        lua_State *L = ctx->proxy_state;
        mcp_pool_t *p;
        STAILQ_FOREACH(p, &head, next) {
            // we let the pool object _gc() handle backend references.

            luaL_unref(L, LUA_REGISTRYINDEX, p->phc_ref);
            // need to... unref self.
            // NOTE: double check if we really need to self-reference.
            // this is a backup here to ensure the external refcounts hit zero
  ...",50.0,87.0,1.0,8.0,38.0,75,7,45,7,0,17,3,4,2,0,,0,17,2,1,1,void*
1780,66816,_proxy_config_thread,1,_proxy_config_thread,void* _proxy_config_thread (void*),proxy_config.c,"static void *_proxy_config_thread(void *arg) {
    proxy_ctx_t *ctx = arg;

    logger_create();
    pthread_mutex_lock(&ctx->config_lock);
    while (1) {
        pthread_cond_wait(&ctx->config_cond, &ctx->config_lock);
        LOGGER_LOG(NULL, LOG_PROXYEVENTS, LOGGER_PROXY_CONFIG, NULL, ""start"");
        STAT_INCR(ctx, config_reloads, 1);
        lua_State *L = ctx->proxy_state;
        lua_settop(L, 0); // clear off any crud that could have been left on the stack.

        // The main stages of config reload are:
        // - load and execute the config file
        // - run mcp_config_pools()
        // - for each worker:
        //   - copy and execute new lua code
        //   - copy selector table
        //   - run mcp_config_routes()

        if (proxy_load_config(ctx) != 0) {
            // Failed to load. log and wait for a retry.
            STAT_INCR(ctx, config_reload_fails, 1);
            LOGGER_LOG(NULL, LOG_PROXYEVENTS, LOGGER_PROXY_CONFIG, NULL, ""failed"");
       ...",100.0,157.0,1.0,8.0,58.0,78,12,86,14,0,29,8,12,4,7,,0,24,2,1,1,void*
1781,67345,_copy_pool,1,_copy_pool,"int _copy_pool (lua_State*,lua_State*)",proxy_config.c,"static int _copy_pool(lua_State *from, lua_State *to) {
    // from, -3 should have he userdata.
    mcp_pool_t *p = luaL_checkudata(from, -3, ""mcp.pool"");
    size_t size = sizeof(mcp_pool_proxy_t);
    mcp_pool_proxy_t *pp = lua_newuserdatauv(to, size, 0);
    luaL_setmetatable(to, ""mcp.pool_proxy"");

    pp->main = p;
    pthread_mutex_lock(&p->lock);
    p->refcount++;
    pthread_mutex_unlock(&p->lock);
    return 0;
}",229.0,241.0,1.0,1.0,13.0,13,6,13,6,0,1,1,1,0,0,,0,1,4,2,2,int
1782,67395,_copy_config_table,1,_copy_config_table,"void _copy_config_table (lua_State*,lua_State*)",proxy_config.c,"static void _copy_config_table(lua_State *from, lua_State *to) {
    int type = lua_type(from, -1);
    bool found = false;
    luaL_checkstack(from, 4, ""configuration error: table recursion too deep"");
    luaL_checkstack(to, 4, ""configuration error: table recursion too deep"");
    switch (type) {
        case LUA_TNIL:
            lua_pushnil(to);
            break;
        case LUA_TUSERDATA:
            // see dump_stack() - check if it's something we handle.
            if (lua_getmetatable(from, -1) != 0) {
                lua_pushstring(from, ""__name"");
                if (lua_rawget(from, -2) != LUA_TNIL) {
                    const char *name = lua_tostring(from, -1);
                    if (strcmp(name, ""mcp.pool"") == 0) {
                        _copy_pool(from, to);
                        found = true;
                    }
                }
                lua_pop(from, 2);
            }
            if (!found) {
                proxy_lua_ferror(from, ""unhandled userda...",246.0,329.0,1.0,1.0,84.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
1783,67882,mcplib_dist_jump_hash_get_server,1,mcplib_dist_jump_hash_get_server,"uint32_t mcplib_dist_jump_hash_get_server (uint64_t,void*)",proxy_jump_hash.c,"static uint32_t mcplib_dist_jump_hash_get_server(uint64_t hash, void *ctx) {
    mcplib_jump_hash_t *jh = ctx;

    int64_t b = -1, j = 0;
    while (j < jh->buckets) {
        b = j;
        hash = hash * 2862933555777941757ULL + 1;
        j = (b + 1) * ((double)(1LL << 31) / (double)((hash >> 33) + 1));
    }
    return b;
}",10.0,20.0,1.0,1.0,11.0,19,10,14,5,0,1,2,2,1,0,,0,1,4,2,2,uint32_t
1784,67939,mcplib_dist_jump_hash_new,1,mcplib_dist_jump_hash_new,int mcplib_dist_jump_hash_new (lua_State*),proxy_jump_hash.c,"static int mcplib_dist_jump_hash_new(lua_State *L) {
    luaL_checktype(L, 1, LUA_TTABLE);
    lua_Unsigned buckets = lua_rawlen(L, 1);

    mcplib_jump_hash_t *jh = lua_newuserdatauv(L, sizeof(mcplib_jump_hash_t), 0);

    // don't need to loop through the table at all, just need its length.
    // could optimize startup time by adding hints to the module for how to
    // format pool (ie; just a total count or the full table)
    jh->buckets = buckets;
    jh->phc.ctx = jh;
    jh->phc.selector_func = mcplib_dist_jump_hash_get_server;

    lua_pushlightuserdata(L, &jh->phc);

    // - return [UD, lightuserdata]
    return 2;
}",23.0,40.0,1.0,1.0,18.0,13,5,14,5,0,5,1,1,0,0,,0,5,2,1,1,int
1785,68016,mcplib_response_ok,1,mcplib_response_ok,int mcplib_response_ok (lua_State*),proxy_lua.c,"static int mcplib_response_ok(lua_State *L) {
    mcp_resp_t *r = luaL_checkudata(L, -1, ""mcp.response"");

    if (r->status == MCMC_OK) {
        lua_pushboolean(L, 1);
    } else {
        lua_pushboolean(L, 0);
    }

    return 1;
}",11.0,21.0,1.0,21.0,11.0,4,4,4,2,0,1,2,2,1,0,,0,1,2,1,1,int
1786,68048,mcplib_response_hit,1,mcplib_response_hit,int mcplib_response_hit (lua_State*),proxy_lua.c,"static int mcplib_response_hit(lua_State *L) {
    mcp_resp_t *r = luaL_checkudata(L, -1, ""mcp.response"");

    if (r->status == MCMC_OK && r->resp.code != MCMC_CODE_MISS) {
        lua_pushboolean(L, 1);
    } else {
        lua_pushboolean(L, 0);
    }

    return 1;
}",23.0,33.0,1.0,21.0,11.0,8,7,5,2,0,2,2,2,2,0,,0,2,2,1,1,int
1787,68090,mcplib_response_vlen,1,mcplib_response_vlen,int mcplib_response_vlen (lua_State*),proxy_lua.c,"static int mcplib_response_vlen(lua_State *L) {
    mcp_resp_t *r = luaL_checkudata(L, -1, ""mcp.response"");

    // We do remove the ""\r\n"" from the value length, so if you're actually
    // processing the value nothing breaks.
    if (r->resp.vlen >= 2) {
        lua_pushinteger(L, r->resp.vlen-2);
    } else {
        lua_pushinteger(L, 0);
    }

    return 1;
}",38.0,50.0,1.0,1.0,13.0,8,6,5,2,0,2,2,2,1,0,,0,2,2,1,1,int
1788,68128,mcplib_response_code,1,mcplib_response_code,int mcplib_response_code (lua_State*),proxy_lua.c,"static int mcplib_response_code(lua_State *L) {
    mcp_resp_t *r = luaL_checkudata(L, -1, ""mcp.response"");

    lua_pushinteger(L, r->resp.code);

    return 1;
}",53.0,59.0,1.0,1.0,7.0,4,4,4,2,0,1,1,1,0,0,,0,1,2,1,1,int
1789,68150,mcplib_response_line,1,mcplib_response_line,int mcplib_response_line (lua_State*),proxy_lua.c,"static int mcplib_response_line(lua_State *L) {
    mcp_resp_t *r = luaL_checkudata(L, -1, ""mcp.response"");

    if (r->resp.rline != NULL) {
        lua_pushlstring(L, r->resp.rline, r->resp.rlen);
    } else {
        lua_pushnil(L);
    }

    return 1;
}",62.0,72.0,1.0,1.0,11.0,9,5,7,3,0,3,2,2,1,0,,0,3,2,1,1,int
1790,68190,mcplib_response_gc,1,mcplib_response_gc,int mcplib_response_gc (lua_State*),proxy_lua.c,"static int mcplib_response_gc(lua_State *L) {
    mcp_resp_t *r = luaL_checkudata(L, -1, ""mcp.response"");

    // On error/similar we might be holding the read buffer.
    // If the buf is handed off to mc_resp for return, this pointer is NULL
    if (r->buf != NULL) {
        free(r->buf);
    }

    return 0;
}",74.0,84.0,1.0,1.0,11.0,5,4,5,3,0,2,2,2,1,0,,0,2,2,1,1,int
1791,68216,mcplib_backend_gc,1,mcplib_backend_gc,int mcplib_backend_gc (lua_State*),proxy_lua.c,"static int mcplib_backend_gc(lua_State *L) {
    mcp_backend_t *be = luaL_checkudata(L, -1, ""mcp.backend"");

    assert(STAILQ_EMPTY(&be->io_head));

    mcmc_disconnect(be->client);
    free(be->client);

    // FIXME (v2): upvalue for global ctx.
    proxy_ctx_t *ctx = settings.proxy_ctx;
    STAT_DECR(ctx, backend_total, 1);

    return 0;
}",93.0,106.0,1.0,11.0,14.0,19,7,13,5,0,5,1,1,0,1,,0,4,2,1,1,int
1792,68281,mcplib_backend,1,mcplib_backend,int mcplib_backend (lua_State*),proxy_lua.c,"static int mcplib_backend(lua_State *L) {
    luaL_checkstring(L, -3); // label for indexing backends.
    size_t nlen = 0;
    const char *name = luaL_checklstring(L, -2, &nlen);
    const char *port = luaL_checkstring(L, -1);
    // FIXME (v2): upvalue for global ctx.
    proxy_ctx_t *ctx = settings.proxy_ctx;

    if (nlen > MAX_NAMELEN-1) {
        proxy_lua_error(L, ""backend name too long"");
        return 0;
    }

    // first check our reference table to compare.
    lua_pushvalue(L, 1);
    int ret = lua_gettable(L, lua_upvalueindex(MCP_BACKEND_UPVALUE));
    if (ret != LUA_TNIL) {
        mcp_backend_t *be_orig = luaL_checkudata(L, -1, ""mcp.backend"");
        if (strncmp(be_orig->name, name, MAX_NAMELEN) == 0
                && strncmp(be_orig->port, port, MAX_PORTLEN) == 0) {
            // backend is the same, return it.
            return 1;
        } else {
            // backend not the same, pop from stack and make new one.
            lua_pop(L, 1);
        }
    } ...",108.0,214.0,1.0,15.0,107.0,93,13,86,16,0,13,8,9,1,6,,0,9,2,1,1,int
1793,68689,mcplib_pool_gc,1,mcplib_pool_gc,int mcplib_pool_gc (lua_State*),proxy_lua.c,"static int mcplib_pool_gc(lua_State *L) {
    mcp_pool_t *p = luaL_checkudata(L, -1, ""mcp.pool"");
    assert(p->refcount == 0);
    pthread_mutex_destroy(&p->lock);

    for (int x = 0; x < p->pool_size; x++) {
        if (p->pool[x].ref) {
            luaL_unref(L, LUA_REGISTRYINDEX, p->pool[x].ref);
        }
    }

    return 0;
}",216.0,228.0,1.0,1.0,13.0,15,8,13,4,0,0,3,4,0,0,,0,0,2,1,1,int
1794,68748,mcp_key_hash_filter_stop,1,mcp_key_hash_filter_stop,"const char* mcp_key_hash_filter_stop (char*,char*,size_t,size_t*)",proxy_lua.c,"static const char *mcp_key_hash_filter_stop(const char *conf, const char *key, size_t klen, size_t *newlen) {
    char temp[KEY_MAX_LENGTH+1];
    *newlen = klen;
    if (klen > KEY_MAX_LENGTH) {
        // Hedging against potential bugs.
        return key;
    }

    memcpy(temp, key, klen);
    temp[klen+1] = '\0';

    // TODO (v2): memmem would avoid the temp key and memcpy here, but it's
    // not technically portable. An easy improvement would be to detect
    // memmem() in `configure` and only use strstr/copy as a fallback.
    // Since keys are short it's unlikely this would be a major performance
    // win.
    char *found = strstr(temp, conf);

    if (found) {
        *newlen = found - temp;
    }

    // hash stop can't change where keys start.
    return key;
}",233.0,257.0,1.0,14.0,25.0,10,6,17,6,0,0,3,3,0,0,,0,0,8,4,4,const char*
1795,68798,mcp_key_hash_filter_tag,1,mcp_key_hash_filter_tag,"const char* mcp_key_hash_filter_tag (char*,char*,size_t,size_t*)",proxy_lua.c,"static const char *mcp_key_hash_filter_tag(const char *conf, const char *key, size_t klen, size_t *newlen) {
    *newlen = klen;

    const char *t1 = memchr(key, conf[0], klen);
    if (t1) {
        size_t remain = klen - (t1 - key);
        // must be at least one character inbetween the tags to hash.
        if (remain > 1) {
            const char *t2 = memchr(t1, conf[1], remain);

            if (t2) {
                *newlen = t2 - t1 - 1;
                return t1+1;
            }
        }
    }

    return key;
}",262.0,280.0,1.0,1.0,19.0,15,6,22,7,0,0,4,7,0,0,,0,0,8,4,4,const char*
1796,68861,_mcplib_pool_dist,1,_mcplib_pool_dist,"void _mcplib_pool_dist (lua_State*,mcp_pool_t*)",proxy_lua.c,"static void _mcplib_pool_dist(lua_State *L, mcp_pool_t *p) {
    luaL_checktype(L, -1, LUA_TTABLE);
    if (lua_getfield(L, -1, ""new"") != LUA_TFUNCTION) {
        proxy_lua_error(L, ""key distribution object missing 'new' function"");
        return;
    }

    // - now create the copy pool table
    lua_createtable(L, p->pool_size, 0); // give the new pool table a sizing hint.
    for (int x = 1; x <= p->pool_size; x++) {
        mcp_backend_t *be = p->pool[x-1].be;
        lua_createtable(L, 0, 4);
        // stack = [p, h, f, optN, newpool, backend]
        // the key should be fine for id? maybe don't need to duplicate
        // this?
        lua_pushinteger(L, x);
        lua_setfield(L, -2, ""id"");
        // we don't use the hostname for ketama hashing
        // so passing ip for hostname is fine
        lua_pushstring(L, be->name);
        lua_setfield(L, -2, ""addr"");
        lua_pushstring(L, be->port);
        lua_setfield(L, -2, ""port"");

        // set the backend table i...",282.0,336.0,1.0,1.0,55.0,30,11,44,12,2,1,4,4,0,1,,0,0,4,2,2,void
1797,69009,mcplib_pool,1,mcplib_pool,int mcplib_pool (lua_State*),proxy_lua.c,"static int mcplib_pool(lua_State *L) {
    int argc = lua_gettop(L);
    luaL_checktype(L, 1, LUA_TTABLE);
    int n = luaL_len(L, 1); // get length of array table

    size_t plen = sizeof(mcp_pool_t) + sizeof(mcp_pool_be_t) * n;
    mcp_pool_t *p = lua_newuserdatauv(L, plen, 0);
    // Zero the memory before use, so we can realibly use __gc to clean up
    memset(p, 0, plen);
    p->pool_size = n;
    // TODO (v2): Nicer if this is fetched from mcp.default_key_hash
    p->key_hasher = XXH3_64bits_withSeed;
    pthread_mutex_init(&p->lock, NULL);
    p->ctx = settings.proxy_ctx; // TODO (v2): store ctx in upvalue.

    luaL_setmetatable(L, ""mcp.pool"");

    lua_pushvalue(L, -1); // dupe self for reference.
    p->self_ref = luaL_ref(L, LUA_REGISTRYINDEX);

    // remember lua arrays are 1 indexed.
    for (int x = 1; x <= n; x++) {
        mcp_pool_be_t *s = &p->pool[x-1];
        lua_geti(L, 1, x); // get next server into the stack.
        // If we bail here, the pool _gc() shoul...",339.0,455.0,1.0,20.0,117.0,76,16,107,24,0,8,12,17,0,4,,0,4,2,1,1,int
1798,69408,mcplib_pool_proxy_gc,1,mcplib_pool_proxy_gc,int mcplib_pool_proxy_gc (lua_State*),proxy_lua.c,"static int mcplib_pool_proxy_gc(lua_State *L) {
    mcp_pool_proxy_t *pp = luaL_checkudata(L, -1, ""mcp.pool_proxy"");
    mcp_pool_t *p = pp->main;
    pthread_mutex_lock(&p->lock);
    p->refcount--;
    if (p->refcount == 0) {
        proxy_ctx_t *ctx = p->ctx;
        pthread_mutex_lock(&ctx->manager_lock);
        STAILQ_INSERT_TAIL(&ctx->manager_head, p, next);
        pthread_cond_signal(&ctx->manager_cond);
        pthread_mutex_unlock(&ctx->manager_lock);
    }
    pthread_mutex_unlock(&p->lock);

    return 0;
}",457.0,472.0,1.0,8.0,16.0,37,8,21,5,0,7,2,2,0,0,,0,7,2,1,1,int
1799,69589,mcplib_pool_proxy_call,1,mcplib_pool_proxy_call,int mcplib_pool_proxy_call (lua_State*),proxy_lua.c,"static int mcplib_pool_proxy_call(lua_State *L) {
    // internal args are the hash selector (self)
    mcp_pool_proxy_t *pp = luaL_checkudata(L, -2, ""mcp.pool_proxy"");
    mcp_pool_t *p = pp->main;
    // then request object.
    mcp_request_t *rq = luaL_checkudata(L, -1, ""mcp.request"");

    // we have a fast path to the key/length.
    if (!rq->pr.keytoken) {
        proxy_lua_error(L, ""cannot route commands without key"");
        return 0;
    }
    const char *key = MCP_PARSER_KEY(rq->pr);
    size_t len = rq->pr.klen;
    rq->be = mcplib_pool_proxy_call_helper(L, p, key, len);

    // now yield request, pool up.
    return lua_yield(L, 2);
}",495.0,513.0,1.0,22.0,19.0,25,7,21,6,0,3,2,2,0,2,,0,2,2,1,1,int
1800,69676,mcplib_tcp_keepalive,1,mcplib_tcp_keepalive,int mcplib_tcp_keepalive (lua_State*),proxy_lua.c,"static int mcplib_tcp_keepalive(lua_State *L) {
    luaL_checktype(L, -1, LUA_TBOOLEAN);
    int state = lua_toboolean(L, -1);
    proxy_ctx_t *ctx = settings.proxy_ctx; // FIXME (v2): get global ctx reference in thread/upvalue.

    STAT_L(ctx);
    ctx->tunables.tcp_keepalive = state;
    STAT_UL(ctx);

    return 0;
}",515.0,525.0,1.0,4.0,11.0,12,5,12,5,0,4,1,1,0,0,,0,4,2,1,1,int
1801,69724,mcplib_backend_failure_limit,1,mcplib_backend_failure_limit,int mcplib_backend_failure_limit (lua_State*),proxy_lua.c,"static int mcplib_backend_failure_limit(lua_State *L) {
    int limit = luaL_checkinteger(L, -1);
    proxy_ctx_t *ctx = settings.proxy_ctx; // FIXME (v2): get global ctx reference in thread/upvalue.

    if (limit < 0) {
        proxy_lua_error(L, ""backend_failure_limit must be >= 0"");
        return 0;
    }

    STAT_L(ctx);
    ctx->tunables.backend_failure_limit = limit;
    STAT_UL(ctx);

    return 0;
}",527.0,541.0,1.0,4.0,15.0,12,6,12,4,0,5,2,2,0,1,,0,4,2,1,1,int
1802,69777,mcplib_backend_connect_timeout,1,mcplib_backend_connect_timeout,int mcplib_backend_connect_timeout (lua_State*),proxy_lua.c,"static int mcplib_backend_connect_timeout(lua_State *L) {
    lua_Number secondsf = luaL_checknumber(L, -1);
    lua_Integer secondsi = (lua_Integer) secondsf;
    lua_Number subseconds = secondsf - secondsi;
    proxy_ctx_t *ctx = settings.proxy_ctx; // FIXME (v2): get global ctx reference in thread/upvalue.

    STAT_L(ctx);
    ctx->tunables.connect.tv_sec = secondsi;
    ctx->tunables.connect.tv_usec = MICROSECONDS(subseconds);
#ifdef HAVE_LIBURING
    ctx->tunables.connect_ur.tv_sec = secondsi;
    ctx->tunables.connect_ur.tv_nsec = NANOSECONDS(subseconds);
#endif
    STAT_UL(ctx);

    return 0;
}",547.0,563.0,1.0,4.0,17.0,22,9,18,6,0,5,1,1,0,0,,0,5,2,1,1,int
1803,69850,mcplib_backend_retry_timeout,1,mcplib_backend_retry_timeout,int mcplib_backend_retry_timeout (lua_State*),proxy_lua.c,"static int mcplib_backend_retry_timeout(lua_State *L) {
    lua_Number secondsf = luaL_checknumber(L, -1);
    lua_Integer secondsi = (lua_Integer) secondsf;
    lua_Number subseconds = secondsf - secondsi;
    proxy_ctx_t *ctx = settings.proxy_ctx; // FIXME (v2): get global ctx reference in thread/upvalue.

    STAT_L(ctx);
    ctx->tunables.retry.tv_sec = secondsi;
    ctx->tunables.retry.tv_usec = MICROSECONDS(subseconds);
#ifdef HAVE_LIBURING
    ctx->tunables.retry_ur.tv_sec = secondsi;
    ctx->tunables.retry_ur.tv_nsec = NANOSECONDS(subseconds);
#endif
    STAT_UL(ctx);

    return 0;
}",565.0,581.0,1.0,4.0,17.0,22,9,18,6,0,5,1,1,0,0,,0,5,2,1,1,int
1804,69923,mcplib_backend_read_timeout,1,mcplib_backend_read_timeout,int mcplib_backend_read_timeout (lua_State*),proxy_lua.c,"static int mcplib_backend_read_timeout(lua_State *L) {
    lua_Number secondsf = luaL_checknumber(L, -1);
    lua_Integer secondsi = (lua_Integer) secondsf;
    lua_Number subseconds = secondsf - secondsi;
    proxy_ctx_t *ctx = settings.proxy_ctx; // FIXME (v2): get global ctx reference in thread/upvalue.

    STAT_L(ctx);
    ctx->tunables.read.tv_sec = secondsi;
    ctx->tunables.read.tv_usec = MICROSECONDS(subseconds);
#ifdef HAVE_LIBURING
    ctx->tunables.read_ur.tv_sec = secondsi;
    ctx->tunables.read_ur.tv_nsec = NANOSECONDS(subseconds);
#endif
    STAT_UL(ctx);

    return 0;
}",583.0,599.0,1.0,4.0,17.0,22,9,18,6,0,5,1,1,0,0,,0,5,2,1,1,int
1805,69996,mcplib_attach,1,mcplib_attach,int mcplib_attach (lua_State*),proxy_lua.c,"static int mcplib_attach(lua_State *L) {
    // Pull the original worker thread out of the shared mcplib upvalue.
    LIBEVENT_THREAD *t = lua_touserdata(L, lua_upvalueindex(MCP_THREAD_UPVALUE));

    int hook = luaL_checkinteger(L, 1);
    // pushvalue to dupe func and etc.
    // can leave original func on stack afterward because it'll get cleared.
    int loop_end = 0;
    int loop_start = 1;
    if (hook == CMD_ANY) {
        // if CMD_ANY we need individually set loop 1 to CMD_SIZE.
        loop_end = CMD_SIZE;
    } else if (hook == CMD_ANY_STORAGE) {
        // if CMD_ANY_STORAGE we only override get/set/etc.
        loop_end = CMD_END_STORAGE;
    } else {
        loop_start = hook;
        loop_end = hook + 1;
    }

    if (lua_isfunction(L, 2)) {
        struct proxy_hook *hooks = t->proxy_hooks;
        uint64_t tag = 0; // listener socket tag

        if (lua_isstring(L, 3)) {
            size_t len;
            const char *stag = lua_tolstring(L, 3, &len);
            ...",603.0,710.0,1.0,60.0,108.0,65,15,79,20,0,20,15,46,4,3,,0,17,2,1,1,int
1806,70341,mcplib_log,1,mcplib_log,int mcplib_log (lua_State*),proxy_lua.c,"static int mcplib_log(lua_State *L) {
    LIBEVENT_THREAD *t = lua_touserdata(L, lua_upvalueindex(MCP_THREAD_UPVALUE));
    const char *msg = luaL_checkstring(L, -1);
    LOGGER_LOG(t->l, LOG_PROXYUSER, LOGGER_PROXY_USER, NULL, msg);
    return 0;
}",714.0,719.0,1.0,60.0,6.0,13,7,17,8,0,4,1,1,0,1,,0,3,2,1,1,int
1807,70407,mcplib_log_req,1,mcplib_log_req,int mcplib_log_req (lua_State*),proxy_lua.c,"static int mcplib_log_req(lua_State *L) {
    LIBEVENT_THREAD *t = lua_touserdata(L, lua_upvalueindex(MCP_THREAD_UPVALUE));
    logger *l = t->l;
    // Not using the LOGGER_LOG macro so we can avoid as much overhead as
    // possible when logging is disabled.
    if (! (l->eflags & LOG_PROXYREQS)) {
        return 0;
    }
    int rtype = 0;
    int rcode = 0;
    int rstatus = 0;
    char *rname = NULL;
    char *rport = NULL;

    mcp_request_t *rq = luaL_checkudata(L, 1, ""mcp.request"");
    int type = lua_type(L, 2);
    if (type == LUA_TUSERDATA) {
        mcp_resp_t *rs = luaL_checkudata(L, 2, ""mcp.response"");
        rtype = rs->resp.type;
        rcode = rs->resp.code;
        rstatus = rs->status;
        rname = rs->be_name;
        rport = rs->be_port;
    }
    size_t dlen = 0;
    const char *detail = luaL_optlstring(L, 3, NULL, &dlen);

    struct timeval end;
    gettimeofday(&end, NULL);
    long elapsed = (end.tv_sec - rq->start.tv_sec) * 1000000 + (end.tv_usec - r...",722.0,756.0,1.0,60.0,35.0,47,11,55,18,0,7,3,3,0,1,,0,6,2,1,1,int
1808,70581,_rotl,1,_rotl,"uint32_t _rotl (uint32_t,int)",proxy_lua.c,"static inline uint32_t _rotl(const uint32_t x, int k) {
    return (x << k) | (x >> (32 - k));
}",758.0,760.0,1.0,1.0,3.0,4,4,4,2,2,0,1,1,0,0,,0,0,4,2,2,uint32_t
1809,70597,_nextrand,1,_nextrand,uint32_t _nextrand (uint32_t*),proxy_lua.c,"static uint32_t _nextrand(uint32_t *s) {
    const uint32_t result = _rotl(s[0] + s[3], 7) + s[0];

    const uint32_t t = s[1] << 9;

    s[2] ^= s[0];
    s[3] ^= s[1];
    s[1] ^= s[2];
    s[0] ^= s[3];

    s[2] ^= t;

    s[3] = _rotl(s[3], 11);

    return result;
}",763.0,778.0,1.0,1.0,16.0,21,4,19,3,0,2,1,1,0,2,,0,2,2,1,1,uint32_t
1810,70670,mcplib_log_reqsample,1,mcplib_log_reqsample,int mcplib_log_reqsample (lua_State*),proxy_lua.c,"static int mcplib_log_reqsample(lua_State *L) {
    LIBEVENT_THREAD *t = lua_touserdata(L, lua_upvalueindex(MCP_THREAD_UPVALUE));
    logger *l = t->l;
    // Not using the LOGGER_LOG macro so we can avoid as much overhead as
    // possible when logging is disabled.
    if (! (l->eflags & LOG_PROXYREQS)) {
        return 0;
    }
    int rtype = 0;
    int rcode = 0;
    int rstatus = 0;
    char *rname = NULL;
    char *rport = NULL;

    int ms = luaL_checkinteger(L, 1);
    int rate = luaL_checkinteger(L, 2);
    int allerr = lua_toboolean(L, 3);
    mcp_request_t *rq = luaL_checkudata(L, 4, ""mcp.request"");
    int type = lua_type(L, 5);
    if (type == LUA_TUSERDATA) {
        mcp_resp_t *rs = luaL_checkudata(L, 5, ""mcp.response"");
        rtype = rs->resp.type;
        rcode = rs->resp.code;
        rstatus = rs->status;
        rname = rs->be_name;
        rport = rs->be_port;
    }
    size_t dlen = 0;
    const char *detail = luaL_optlstring(L, 6, NULL, &dlen);

    struct ...",782.0,835.0,1.0,60.0,54.0,54,13,68,24,0,7,5,5,0,1,,0,6,2,1,1,int
1811,70927,proxy_register_defines,1,proxy_register_defines,void proxy_register_defines (lua_State*),proxy_lua.c,"static void proxy_register_defines(lua_State *L) {
#define X(x) \
    lua_pushinteger(L, x); \
    lua_setfield(L, -2, #x);

    X(MCMC_CODE_STORED);
    X(MCMC_CODE_EXISTS);
    X(MCMC_CODE_DELETED);
    X(MCMC_CODE_TOUCHED);
    X(MCMC_CODE_VERSION);
    X(MCMC_CODE_NOT_FOUND);
    X(MCMC_CODE_NOT_STORED);
    X(MCMC_CODE_OK);
    X(MCMC_CODE_NOP);
    X(MCMC_CODE_MISS);
    X(P_OK);
    X(CMD_ANY);
    X(CMD_ANY_STORAGE);
    X(AWAIT_GOOD);
    X(AWAIT_ANY);
    X(AWAIT_OK);
    X(AWAIT_FIRST);
    CMD_FIELDS
#undef X
}",842.0,866.0,1.0,4.0,25.0,51,1,150,42,0,0,1,1,0,0,,0,0,2,1,1,void
1812,71703,proxy_backend_handler,1,proxy_backend_handler,"void proxy_backend_handler (int,short,void*)",proxy_network.c,"static void proxy_backend_handler(const int fd, const short which, void *arg) {
    mcp_backend_t *be = arg;
    int flags = EV_TIMEOUT;
    struct timeval tmp_time = be->event_thread->tunables.read;

    if (which & EV_TIMEOUT) {
        P_DEBUG(""%s: timeout received, killing backend queue\n"", __func__);
        _reset_bad_backend(be, P_BE_FAIL_TIMEOUT);
        _backend_failed(be);
        return;
    }

    if (which & EV_WRITE) {
        be->can_write = true;
        // TODO (v2): move connect routine to its own function?
        // - hard to do right now because we can't (easily?) edit libevent
        // events.
        if (be->connecting) {
            int err = 0;
            // We were connecting, now ensure we're properly connected.
            if (mcmc_check_nonblock_connect(be->client, &err) != MCMC_OK) {
                // kick the bad backend, clear the queue, retry later.
                // FIXME (v2): if a connect fails, anything currently in the queue
              ...",938.0,1016.0,1.0,8.0,79.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,void
1813,71710,proxy_event_handler,1,proxy_event_handler,"void proxy_event_handler (evutil_socket_t,short,void*)",proxy_network.c,"static void proxy_event_handler(evutil_socket_t fd, short which, void *arg) {
    proxy_event_thread_t *t = arg;

#ifdef USE_EVENTFD
    uint64_t u;
    if (read(fd, &u, sizeof(uint64_t)) != sizeof(uint64_t)) {
        // Temporary error or wasn't actually ready to read somehow.
        return;
    }
#else
    char buf[1];
    // TODO (v2): This is a lot more fatal than it should be. can it fail? can
    // it blow up the server?
    // TODO (v2): a cross-platform method of speeding this up would be nice. With
    // event fds we can queue N events and wakeup once here.
    // If we're pulling one byte out of the pipe at a time here it'll just
    // wake us up too often.
    // If the pipe is O_NONBLOCK then maybe just a larger read would work?
    if (read(fd, buf, 1) != 1) {
        P_DEBUG(""%s: pipe read failed\n"", __func__);
        return;
    }
#endif

    if (_proxy_event_handler_dequeue(t) == 0) {
        //P_DEBUG(""%s: no IO's to complete\n"", __func__);
        return;
   ...",406.0,458.0,1.0,8.0,53.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,void
1814,71717,proxy_event_updater,1,proxy_event_updater,"void proxy_event_updater (evutil_socket_t,short,void*)",proxy_network.c,"static void proxy_event_updater(evutil_socket_t fd, short which, void *arg) {
    proxy_event_thread_t *t = arg;
    proxy_ctx_t *ctx = t->ctx;

    // TODO (v2): double check how much of this boilerplate is still necessary?
    // reschedule the clock event.
    evtimer_del(&t->clock_event);

    evtimer_set(&t->clock_event, proxy_event_updater, t);
    event_base_set(t->base, &t->clock_event);
    struct timeval rate = {.tv_sec = 3, .tv_usec = 0};
    evtimer_add(&t->clock_event, &rate);

    // we reuse the ""global stats"" lock since it's hardly ever used.
    STAT_L(ctx);
    memcpy(&t->tunables, &ctx->tunables, sizeof(t->tunables));
    STAT_UL(ctx);
}",386.0,403.0,1.0,4.0,18.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,void
1815,71724,_flush_pending_write,1,_flush_pending_write,int _flush_pending_write (mcp_backend_t*),proxy_network.c,"static int _flush_pending_write(mcp_backend_t *be) {
    int flags = 0;
    unsigned int tosend = 0;
    int iovcnt = _prep_pending_write(be, &tosend);

    ssize_t sent = writev(mcmc_fd(be->client), be->write_iovs, iovcnt);
    if (sent > 0) {
        io_pending_proxy_t *io = NULL;
        if (sent < tosend) {
            flags |= EV_WRITE;
        }

        STAILQ_FOREACH(io, &be->io_head, io_next) {
            bool flushed = true;
            if (io->flushed)
                continue;

            if (sent >= io->iovbytes) {
                // short circuit for common case.
                sent -= io->iovbytes;
            } else {
                io->iovbytes -= sent;
                for (int x = 0; x < io->iovcnt; x++) {
                    struct iovec *iov = &io->iov[x];
                    if (sent >= iov->iov_len) {
                        sent -= iov->iov_len;
                        iov->iov_len = 0;
                    } else {
                        iov->iov_len -= s...",877.0,933.0,1.0,8.0,57.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
1816,71729,_reset_bad_backend,1,_reset_bad_backend,"int _reset_bad_backend (mcp_backend_t*,proxy_be_failures)",proxy_network.c,"static int _reset_bad_backend(mcp_backend_t *be, enum proxy_be_failures err) {
    io_pending_proxy_t *io = NULL;
    // Can't use STAILQ_FOREACH() since return_io_pending() free's the current
    // io. STAILQ_FOREACH_SAFE maybe?
    while (!STAILQ_EMPTY(&be->io_head)) {
        io = STAILQ_FIRST(&be->io_head);
        STAILQ_REMOVE_HEAD(&be->io_head, io_next);
        // TODO (v2): Unsure if this is the best way of surfacing errors to lua,
        // but will do for V1.
        io->client_resp->status = MCMC_ERR;
        be->depth--;
        return_io_pending((io_pending_t *)io);
    }

    STAILQ_INIT(&be->io_head);

    // reset buffer to blank state.
    be->rbufused = 0;
    mcmc_disconnect(be->client);
    int status = mcmc_connect(be->client, be->name, be->port, be->connect_flags);
    if (status == MCMC_CONNECTED) {
        // TODO (v2): unexpected but lets let it be here.
        be->connecting = false;
        be->can_write = true;
    } else if (status == MCMC_CONNECTING...",810.0,852.0,1.0,12.0,43.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
1817,71735,_set_event,1,_set_event,"void _set_event (mcp_backend_t*,event_base*,int,timeval,event_callback_fn)",proxy_network.c,"static void _set_event(mcp_backend_t *be, struct event_base *base, int flags, struct timeval t, event_callback_fn callback) {
    // FIXME (v2): chicken and egg.
    // can't check if pending if the structure is was calloc'ed (sigh)
    // don't want to double test here. should be able to event_assign but
    // not add anything during initialization, but need the owner thread's
    // event base.
    int pending = 0;
    if (event_initialized(&be->event)) {
        pending = event_pending(&be->event, EV_READ|EV_WRITE|EV_TIMEOUT, NULL);
    }
    if ((pending & (EV_READ|EV_WRITE|EV_TIMEOUT)) != 0) {
            event_del(&be->event); // replace existing event.
    }

    // if we can't write, we could be connecting.
    // TODO (v2): always check for READ in case some commands were sent
    // successfully? The flags could be tracked on *be and reset in the
    // handler, perhaps?
    event_assign(&be->event, base, mcmc_fd(be->client),
            flags, callback, be);
    event_ad...",473.0,494.0,1.0,1.0,22.0,0,0,0,0,2,0,1,1,0,0,,0,0,10,5,5,void
1818,71744,proxy_backend_drive_machine,1,proxy_backend_drive_machine,int proxy_backend_drive_machine (mcp_backend_t*),proxy_network.c,"static int proxy_backend_drive_machine(mcp_backend_t *be) {
    bool stop = false;
    io_pending_proxy_t *p = NULL;
    int flags = 0;

    p = STAILQ_FIRST(&be->io_head);
    if (p == NULL) {
        // got a read event, but nothing was queued.
        // probably means a disconnect event.
        // TODO (v2): could probably confirm this by attempting to read the
        // socket, getsockopt, or something else simply for logging or
        // statistical purposes.
        // In this case we know it's going to be a close so error.
        flags = -1;
        P_DEBUG(""%s: read event but nothing in IO queue\n"", __func__);
        return flags;
    }

    while (!stop) {
        mcp_resp_t *r;
        int res = 1;

    switch(be->state) {
        case mcp_backend_read:
            assert(p != NULL);
            // FIXME: remove the _read state?
            be->state = mcp_backend_parse;
            break;
        case mcp_backend_parse:
            r = p->client_resp;
            r-...",505.0,756.0,1.0,8.0,252.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
1819,71749,_proxy_event_handler_dequeue,1,_proxy_event_handler_dequeue,int _proxy_event_handler_dequeue (proxy_event_thread_t*),proxy_network.c,"static int _proxy_event_handler_dequeue(proxy_event_thread_t *t) {
    io_head_t head;

    STAILQ_INIT(&head);
    STAILQ_INIT(&t->be_head);

    // Pull the entire stack of inbound into local queue.
    pthread_mutex_lock(&t->mutex);
    STAILQ_CONCAT(&head, &t->io_head_in);
    pthread_mutex_unlock(&t->mutex);

    int io_count = 0;
    int be_count = 0;
    while (!STAILQ_EMPTY(&head)) {
        io_pending_proxy_t *io = STAILQ_FIRST(&head);
        io->flushed = false;
        mcp_backend_t *be = io->backend;
        // So the backend can retrieve its event base.
        be->event_thread = t;

        // _no_ mutex on backends. they are owned by the event thread.
        STAILQ_REMOVE_HEAD(&head, io_next);
        // paranoia about moving items between lists.
        io->io_next.stqe_next = NULL;

        if (be->bad) {
            P_DEBUG(""%s: fast failing request to bad backend\n"", __func__);
            io->client_resp->status = MCMC_ERR;
            return_io_pending((io_pen...",14.0,58.0,1.0,4.0,45.0,147,10,74,9,0,1,5,6,0,1,,0,0,2,1,1,int
1820,73215,proxy_backend_retry_handler,1,proxy_backend_retry_handler,"void proxy_backend_retry_handler (int,short,void*)",proxy_network.c,"static void proxy_backend_retry_handler(const int fd, const short which, void *arg) {
    mcp_backend_t *be = arg;
    assert(which & EV_TIMEOUT);
    struct timeval tmp_time = be->event_thread->tunables.retry;
    _set_event(be, be->event_thread->base, EV_WRITE|EV_TIMEOUT, tmp_time, proxy_backend_handler);
}",759.0,764.0,1.0,1.0,6.0,9,5,12,7,0,1,1,1,0,1,,0,0,6,3,3,void
1821,73252,_backend_failed,1,_backend_failed,void _backend_failed (mcp_backend_t*),proxy_network.c,"static void _backend_failed(mcp_backend_t *be) {
    struct timeval tmp_time = be->event_thread->tunables.retry;
    if (++be->failed_count > be->event_thread->tunables.backend_failure_limit) {
        P_DEBUG(""%s: marking backend as bad\n"", __func__);
        be->bad = true;
       _set_event(be, be->event_thread->base, EV_TIMEOUT, tmp_time, proxy_backend_retry_handler);
        STAT_INCR(be->event_thread->ctx, backend_marked_bad, 1);
    } else {
        STAT_INCR(be->event_thread->ctx, backend_failed, 1);
        _set_event(be, be->event_thread->base, EV_WRITE|EV_TIMEOUT, tmp_time, proxy_backend_handler);
    }
}",779.0,790.0,1.0,8.0,12.0,29,7,14,4,0,1,2,2,0,1,,0,0,2,1,1,void
1822,73667,_prep_pending_write,1,_prep_pending_write,"int _prep_pending_write (mcp_backend_t*,unsigned int*)",proxy_network.c,"static int _prep_pending_write(mcp_backend_t *be, unsigned int *tosend) {
    struct iovec *iovs = be->write_iovs;
    io_pending_proxy_t *io = NULL;
    int iovused = 0;
    STAILQ_FOREACH(io, &be->io_head, io_next) {
        if (io->flushed)
            continue;

        if (io->iovcnt + iovused > BE_IOV_MAX) {
            // Signal to caller that we need to keep writing, if writeable.
            // FIXME (v2): can certainly refactor this to loop instead of waiting
            // for a writeable event.
            *tosend += 1;
            break;
        }

        memcpy(&iovs[iovused], io->iov, sizeof(struct iovec)*io->iovcnt);
        iovused += io->iovcnt;
        *tosend += io->iovbytes;
    }
    return iovused;
}",854.0,875.0,1.0,4.0,22.0,25,10,23,8,0,0,6,6,0,0,,0,0,4,2,2,int
1823,74302,_process_tokenize,1,_process_tokenize,"int _process_tokenize (mcp_parser_t*,size_t)",proxy_request.c,"static int _process_tokenize(mcp_parser_t *pr, const size_t max) {
    const char *s = pr->request;
    int len = pr->reqlen - 2;

    // since multigets can be huge, we can't purely judge reqlen against this
    // limit, but we also can't index past it since the tokens are shorts.
    if (len > PARSER_MAXLEN) {
        len = PARSER_MAXLEN;
    }
    const char *end = s + len;
    int curtoken = 0;

    int state = 0;
    while (s != end) {
        switch (state) {
            case 0:
                // scanning for first non-space to find a token.
                if (*s != ' ') {
                    pr->tokens[curtoken] = s - pr->request;
                    if (++curtoken == max) {
                        s++;
                        state = 2;
                        break;
                    }
                    state = 1;
                }
                s++;
                break;
            case 1:
                // advance over a token
                if (*s != ' ') {
...",10.0,65.0,1.0,14.0,56.0,40,11,37,8,5,0,13,18,0,0,,0,0,4,2,2,int
1824,74444,_process_token_len,1,_process_token_len,"int _process_token_len (mcp_parser_t*,size_t)",proxy_request.c,"static int _process_token_len(mcp_parser_t *pr, size_t token) {
    const char *s = pr->request + pr->tokens[token];
    const char *e = pr->request + pr->tokens[token+1];
    // start of next token is after any space delimiters, so back those out.
    while (*(e-1) == ' ') {
        e--;
    }
    return e - s;
}",67.0,75.0,1.0,1.0,9.0,16,8,12,4,1,0,2,2,0,0,,0,0,4,2,2,int
1825,74490,_process_request_key,1,_process_request_key,int _process_request_key (mcp_parser_t*),proxy_request.c,"static int _process_request_key(mcp_parser_t *pr) {
    pr->klen = _process_token_len(pr, pr->keytoken);
    // advance the parser in case of multikey.
    pr->parsed = pr->tokens[pr->keytoken] + pr->klen + 1;

    if (pr->request[pr->parsed-1] == ' ') {
        P_DEBUG(""%s: request_key found extra space\n"", __func__);
        pr->has_space = true;
    } else {
        pr->has_space = false;
    }
    return 0;
}",77.0,89.0,1.0,8.0,13.0,18,6,11,2,5,1,2,2,0,1,,0,1,2,1,1,int
1826,74639,_process_request_metaflags,1,_process_request_metaflags,"int _process_request_metaflags (mcp_parser_t*,int)",proxy_request.c,"static int _process_request_metaflags(mcp_parser_t *pr, int token) {
    if (pr->ntokens <= token) {
        pr->t.meta.flags = 0; // no flags found.
        return 0;
    }
    const char *cur = pr->request + pr->tokens[token];
    const char *end = pr->request + pr->reqlen - 2;

    // We blindly convert flags into bits, since the range of possible
    // flags is deliberately < 64.
    int state = 0;
    while (cur != end) {
        switch (state) {
            case 0:
                if (*cur == ' ') {
                    cur++;
                } else {
                    if (*cur < 65 || *cur > 122) {
                        return -1;
                    }
                    P_DEBUG(""%s: setting meta flag: %d\n"", __func__, *cur - 65);
                    pr->t.meta.flags |= (uint64_t)1 << (*cur - 65);
                    state = 1;
                }
                break;
            case 1:
                if (*cur != ' ') {
                    cur++;
                } else...",123.0,166.0,1.0,20.0,44.0,32,14,21,6,2,0,9,12,0,0,,0,0,4,2,2,int
1827,74783,_process_request_meta,1,_process_request_meta,int _process_request_meta (mcp_parser_t*),proxy_request.c,"static int _process_request_meta(mcp_parser_t *pr) {
    _process_tokenize(pr, PARSER_MAX_TOKENS);
    if (pr->ntokens < 2) {
        P_DEBUG(""%s: not enough tokens for meta command: %d\n"", __func__, pr->ntokens);
        return -1;
    }
    pr->keytoken = 1;
    _process_request_key(pr);

    // pass the first flag token.
    return _process_request_metaflags(pr, 2);
}",169.0,180.0,1.0,26.0,12.0,5,4,5,1,0,3,2,2,0,3,,0,0,2,1,1,int
1828,74814,_process_request_mset,1,_process_request_mset,int _process_request_mset (mcp_parser_t*),proxy_request.c,"static int _process_request_mset(mcp_parser_t *pr) {
    _process_tokenize(pr, PARSER_MAX_TOKENS);
    if (pr->ntokens < 3) {
        P_DEBUG(""%s: not enough tokens for meta set command: %d\n"", __func__, pr->ntokens);
        return -1;
    }
    pr->keytoken = 1;
    _process_request_key(pr);

    const char *cur = pr->request + pr->tokens[2];

    errno = 0;
    char *n = NULL;
    int vlen = strtol(cur, &n, 10);
    if ((errno == ERANGE) || (cur == n)) {
        return -1;
    }

    if (vlen < 0 || vlen > (INT_MAX - 2)) {
       return -1;
    }
    vlen += 2;

    pr->vlen = vlen;

    // pass the first flag token
    return _process_request_metaflags(pr, 3);
}",183.0,210.0,1.0,26.0,28.0,26,12,24,8,0,3,4,4,0,3,,0,0,2,1,1,int
1829,74906,_process_request_gat,1,_process_request_gat,int _process_request_gat (mcp_parser_t*),proxy_request.c,"static int _process_request_gat(mcp_parser_t *pr) {
    _process_tokenize(pr, 3);
    if (pr->ntokens < 3) {
        P_DEBUG(""%s: not enough tokens for GAT: %d\n"", __func__, pr->ntokens);
        return -1;
    }

    pr->keytoken = 2;
    _process_request_key(pr);
    return 0;
}",213.0,223.0,1.0,8.0,11.0,5,4,4,1,0,2,2,2,0,2,,0,0,2,1,1,int
1830,74933,_process_request_noreply,1,_process_request_noreply,int _process_request_noreply (mcp_parser_t*),proxy_request.c,"static int _process_request_noreply(mcp_parser_t *pr) {
    if (pr->tokens[pr->ntokens] - pr->tokens[pr->ntokens-1] >= NOREPLYLEN
            && strncmp(NOREPLYSTR, pr->request + pr->tokens[pr->ntokens-1], NOREPLYLEN) == 0) {
        pr->noreply = true;
    }
    return 0;
}",229.0,235.0,1.0,63.0,7.0,23,9,9,2,2,0,2,2,0,0,,0,0,2,1,1,int
1831,74997,_process_request_storage,1,_process_request_storage,"int _process_request_storage (mcp_parser_t*,size_t)",proxy_request.c,"static int _process_request_storage(mcp_parser_t *pr, size_t max) {
    _process_tokenize(pr, max);
    if (pr->ntokens < 5) {
        P_DEBUG(""%s: not enough tokens to storage command: %d\n"", __func__, pr->ntokens);
        return -1;
    }
    pr->keytoken = 1;
    _process_request_key(pr);

    errno = 0;
    char *n = NULL;
    const char *cur = pr->request + pr->tokens[4];

    int vlen = strtol(cur, &n, 10);
    if ((errno == ERANGE) || (cur == n)) {
        return -1;
    }

    if (vlen < 0 || vlen > (INT_MAX - 2)) {
       return -1;
    }
    vlen += 2;

    pr->vlen = vlen;

    return _process_request_noreply(pr);
}",240.0,266.0,1.0,8.0,27.0,26,12,25,9,0,3,4,4,0,3,,0,0,4,2,2,int
1832,75087,_process_request_simple,1,_process_request_simple,"int _process_request_simple (mcp_parser_t*,size_t)",proxy_request.c,"static int _process_request_simple(mcp_parser_t *pr, const size_t max) {
    _process_tokenize(pr, max);
    pr->keytoken = 1; // second token is usually the key... stupid GAT.

    _process_request_key(pr);
    return _process_request_noreply(pr);
}",269.0,275.0,1.0,1.0,7.0,2,2,5,2,0,3,1,1,0,3,,0,0,4,2,2,int
1833,77062,ketama_key_hasher,1,ketama_key_hasher,"uint64_t ketama_key_hasher (void*,size_t,uint64_t)",proxy_ring_hash.c,"static uint64_t ketama_key_hasher(const void *key, size_t len, uint64_t seed) {
    // NOTE: seed is ignored!
    // embedding the md5 bits since key is specified with a length here.
    md5_state_t md5state;
    unsigned char digest[16];

    md5_init(&md5state);
    md5_append(&md5state, (unsigned char *)key, len);
    md5_finish(&md5state, digest);

    // mix the hash down (from ketama_hashi)
    unsigned int h = (unsigned int)(( digest[3] << 24 )
                        | ( digest[2] << 16 )
                        | ( digest[1] <<  8 )
                        |   digest[0] );
    return h;
}",70.0,86.0,1.0,1.0,17.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,uint64_t
1834,77075,ketama_md5_digest,1,ketama_md5_digest,"void ketama_md5_digest (char*,unsigned char[16])",proxy_ring_hash.c,"static void ketama_md5_digest( char* inString, unsigned char md5pword[16] )
{
    md5_state_t md5state;

    md5_init( &md5state );
    md5_append( &md5state, (unsigned char *)inString, strlen( inString ) );
    md5_finish( &md5state, md5pword );
}",54.0,61.0,1.0,1.0,8.0,4,2,6,3,3,3,1,1,0,3,,0,0,4,2,2,void
1835,77097,ketama_compare,1,ketama_compare,"int ketama_compare (void*,void*)",proxy_ring_hash.c,"static int ketama_compare(const void *p1, const void *p2) {
    const cpoint *a = p1;
    const cpoint *b = p2;

    return (a->point < b->point) ? -1 : ((a->point > b->point) ? 1 : 0);
}",63.0,68.0,1.0,1.0,6.0,11,6,8,4,0,4,1,1,0,0,,0,4,4,2,2,int
1836,77183,ketama_get_server,1,ketama_get_server,"uint32_t ketama_get_server (uint64_t,void*)",proxy_ring_hash.c,"static uint32_t ketama_get_server(uint64_t hash, void *ctx) {
    ketama_t *kt = (ketama_t *)ctx;
    unsigned int h = hash;
    int highp = kt->total_buckets;
    int lowp = 0, midp;
    unsigned int midval, midval1;

    // divide and conquer array search to find server with next biggest
    // point after what this key hashes to
    while ( 1 )
    {
        midp = (int)( ( lowp+highp ) / 2 );

        if ( midp == kt->total_buckets )
            return kt->continuum[0].id-1; // if at the end, roll back to zeroth

        midval = kt->continuum[midp].point;
        midval1 = midp == 0 ? 0 : kt->continuum[midp-1].point;

        if ( h <= midval && h > midval1 )
            return kt->continuum[midp].id-1;

        if ( midval < h )
            lowp = midp + 1;
        else
            highp = midp - 1;

        if ( lowp > highp )
            return kt->continuum[0].id-1;
    }
}",89.0,119.0,1.0,1.0,31.0,42,14,33,9,0,7,6,10,1,0,,0,7,4,2,2,uint32_t
1837,77317,_add_server_default,1,_add_server_default,"void _add_server_default (ketama_t*,size_t,char**,lua_Integer,lua_Integer,unsigned int*)",proxy_ring_hash.c,"static void _add_server_default(ketama_t *kt, size_t hashstring_size, const char **parts,
        lua_Integer bucket_size, lua_Integer id, unsigned int *cont) {
    char *hashstring = malloc(hashstring_size);

    for (int k = 0; k < bucket_size; k++) {
        size_t len = snprintf(hashstring, hashstring_size, ""%s:%s-%d"", parts[0], parts[1], k);
        kt->continuum[*cont].point = (unsigned int) XXH3_64bits(hashstring, len);
        kt->continuum[*cont].id = id;
    }

    free(hashstring);
}",130.0,141.0,1.0,52.0,12.0,17,7,19,9,1,2,2,2,0,0,,0,2,12,6,6,void
1838,77386,_add_server_ketama,1,_add_server_ketama,"void _add_server_ketama (ketama_t*,size_t,char**,lua_Integer,lua_Integer,unsigned int*)",proxy_ring_hash.c,"static void _add_server_ketama(ketama_t *kt, size_t hashstring_size, const char **parts,
        lua_Integer bucket_size, lua_Integer id, unsigned int *cont) {
    char *hashstring = malloc(hashstring_size);

    for (int k = 0; k < bucket_size / 4; k++) {
        unsigned char digest[16];

        // - create hashing string for ketama
        snprintf(hashstring, hashstring_size, ""%s:%s-%d"", parts[0], parts[1], k);

        // - md5() hash it
        // mostly from ketama.c
        ketama_md5_digest(hashstring, digest);

        /* Use successive 4-bytes from hash as numbers
         * for the points on the circle: */
        for(int h = 0; h < 4; h++ )
        {
            kt->continuum[*cont].point = ( digest[3+h*4] << 24 )
                                  | ( digest[2+h*4] << 16 )
                                  | ( digest[1+h*4] <<  8 )
                                  |   digest[h*4];
            kt->continuum[*cont].id = id;
            (*cont)++;
        }

    }

    f...",143.0,172.0,1.0,1.0,30.0,37,12,29,10,1,3,3,4,0,1,,0,2,12,6,6,void
1839,77501,_add_server_twemproxy,1,_add_server_twemproxy,"void _add_server_twemproxy (ketama_t*,size_t,char**,lua_Integer,lua_Integer,unsigned int*)",proxy_ring_hash.c,"static void _add_server_twemproxy(ketama_t *kt, size_t hashstring_size, const char **parts,
        lua_Integer bucket_size, lua_Integer id, unsigned int *cont) {
    char *hashstring = malloc(hashstring_size);

    for (int k = 0; k < bucket_size / 4; k++) {
        unsigned char digest[16];

        // - create hashing string for ketama
        if (strcmp(parts[1], ""11211"") == 0) {
            // twemproxy sources libmemcached as removing the default port
            // from the string if found.
            snprintf(hashstring, hashstring_size, ""%s-%d"", parts[0], k);
        } else {
            snprintf(hashstring, hashstring_size, ""%s:%s-%d"", parts[0], parts[1], k);
        }

        // - md5() hash it
        // mostly from ketama.c
        ketama_md5_digest(hashstring, digest);

        /* Use successive 4-bytes from hash as numbers
         * for the points on the circle: */
        for(int h = 0; h < 4; h++ )
        {
            kt->continuum[*cont].point = ( digest[3+h*4...",174.0,209.0,1.0,1.0,36.0,38,13,29,10,1,3,4,6,0,1,,0,2,12,6,6,void
1840,77635,_add_server_evcache,1,_add_server_evcache,"void _add_server_evcache (ketama_t*,size_t,char**,lua_Integer,lua_Integer,unsigned int*)",proxy_ring_hash.c,"static void _add_server_evcache(ketama_t *kt, size_t hashstring_size, const char **parts,
        lua_Integer bucket_size, lua_Integer id, unsigned int *cont) {
    char *hashstring = malloc(hashstring_size);

    for (int k = 0; k < bucket_size / 4; k++) {
        unsigned char digest[16];

        // - create hashing string for ketama
        snprintf(hashstring, hashstring_size, ""%s/%s:%s-%d"", parts[0], parts[0], parts[1], k);
        // - md5() hash it
        // mostly from ketama.c
        ketama_md5_digest(hashstring, digest);

        /* Use successive 4-bytes from hash as numbers
         * for the points on the circle: */
        for(int h = 0; h < 4; h++ )
        {
            kt->continuum[*cont].point = ( digest[3+h*4] << 24 )
                                  | ( digest[2+h*4] << 16 )
                                  | ( digest[1+h*4] <<  8 )
                                  |   digest[h*4];
            kt->continuum[*cont].id = id;
            (*cont)++;
        }
...",211.0,239.0,1.0,1.0,29.0,38,12,30,10,1,3,3,4,0,1,,0,2,12,6,6,void
1841,77753,ketama_new,1,ketama_new,int ketama_new (lua_State*),proxy_ring_hash.c,"static int ketama_new(lua_State *L) {
    lua_Integer bucket_size = DEFAULT_BUCKET_SIZE;
    const char *parts[PARTS];
    size_t partlens[PARTS];
    int makemode = 0;

    // check for UA_TTABLE at 1
    luaL_checktype(L, 1, LUA_TTABLE);
    // get number of servers in pool.
    // NOTE: rawlen skips metatable redirection. if we care; lua_len instead.
    lua_Unsigned total = lua_rawlen(L, 1);

    // check for optional input
    int argc = lua_gettop(L);
    if (argc > 1) {
        luaL_checktype(L, 2, LUA_TTABLE);
        if (lua_getfield(L, 2, ""omode"") != LUA_TNIL) {
            luaL_checktype(L, -1, LUA_TSTRING);
            const char *mode = lua_tostring(L, -1);
            if (strcmp(mode, ""default"") == 0) {
                makemode = MODE_DEFAULT;
            } else if (strcmp(mode, ""ketama"") == 0) {
                makemode = MODE_KETAMA;
            } else if (strcmp(mode, ""twemproxy"") == 0) {
                makemode = MODE_TWEMPROXY;
            } else if (strcmp(mode,...",243.0,356.0,1.0,30.0,114.0,69,16,102,20,0,12,13,17,0,4,,0,8,2,1,1,int
1842,78568,restart_register,1,restart_register,"void restart_register (char*,restart_check_cb,restart_save_cb,void*)",restart.c,"void restart_register(const char *tag, restart_check_cb ccb, restart_save_cb scb, void *data) {
    restart_data_cb *cb = calloc(1, sizeof(restart_data_cb));
    if (cb == NULL) {
        fprintf(stderr, ""[restart] failed to allocate callback register\n"");
        abort();
    }

    // Handle first time call initialization inline so we don't need separate
    // API call.
    if (cb_stack == NULL) {
        cb_stack = cb;
    } else {
        // Ensure we fire the callbacks in registration order.
        // Someday I'll get a queue.h overhaul.
        restart_data_cb *finder = cb_stack;
        while (finder->next != NULL) {
            finder = finder->next;
        }
        finder->next = cb;
    }

    safe_strcpy(cb->tag, tag, RESTART_TAG_MAXLEN);
    cb->data = data;
    cb->ccb = *ccb;
    cb->scb = *scb;
}",33.0,58.0,1.0,30.0,26.0,14,5,17,9,1,3,3,3,1,1,,0,2,8,4,4,void
1843,78654,restart_check,1,restart_check,int restart_check (char*),restart.c,"static int restart_check(const char *file) {
    // metadata is kept in a separate file.
    size_t flen = strlen(file);
    const char *ext = "".meta"";
    char *metafile = calloc(1, flen + strlen(ext) + 1);
    if (metafile == NULL) {
        // probably in a really bad position if we hit here, so don't start.
        fprintf(stderr, ""[restart] failed to allocate memory for restart check\n"");
        abort();
    }
    memcpy(metafile, file, flen);
    memcpy(metafile+flen, ext, strlen(ext));

    FILE *f = fopen(metafile, ""r"");
    if (f == NULL) {
        fprintf(stderr, ""[restart] no metadata save file, starting with a clean cache\n"");
        free(metafile);
        return -1;
    }

    restart_cb_ctx ctx;

    ctx.f = f;
    ctx.cb = NULL;
    ctx.line = NULL;
    ctx.done = false;
    if (restart_get_kv(&ctx, NULL, NULL) != RESTART_DONE) {
        // First line must be a tag, so read it in and set up the proper
        // callback here.
        fprintf(stderr, ""[restart] cor...",72.0,134.0,1.0,1.0,63.0,36,9,56,13,1,10,10,10,4,1,,0,10,2,1,1,int
1844,78827,restart_get_kv,1,restart_get_kv,"enum restart_get_kv_ret restart_get_kv (void*,char**,char**)",restart.c,"enum restart_get_kv_ret restart_get_kv(void *ctx, char **key, char **val) {
    char *line = NULL;
    size_t len = 0;
    restart_data_cb *cb = NULL;
    restart_cb_ctx *c = (restart_cb_ctx *) ctx;
    // free previous line.
    // we could just pass it into getline, but it can randomly realloc so we'd
    // have to re-assign it into the structure anyway.
    if (c->line != NULL) {
        free(c->line);
        c->line = NULL;
    }

    if (getline(&line, &len, c->f) != -1) {
        // First char is an indicator:
        // T for TAG, changing the callback we use.
        // K for key/value, to ship to the active callback.
        char *p = line;
        while (*p != '\n') {
            p++;
        }
        *p = '\0';

        if (line[0] == 'T') {
            cb = cb_stack;
            while (cb != NULL) {
                // NOTE: len is allocated size, not line len. need to chomp \n
                if (strcmp(cb->tag, line+1) == 0) {
                    break;
             ...",141.0,211.0,1.0,1.0,71.0,34,11,37,11,2,6,9,17,2,0,,0,6,6,3,3,enum restart_get_kv_ret
1845,79026,restart_save,1,restart_save,int restart_save (char*),restart.c,"static int restart_save(const char *file) {
    // metadata is kept in a separate file.
    // FIXME: function.
    size_t flen = strlen(file);
    const char *ext = "".meta"";
    size_t extlen = strlen(ext);
    char *metafile = calloc(1, flen + extlen + 1);
    if (metafile == NULL) {
        fprintf(stderr, ""[restart] failed to allocate memory during metadata save\n"");
        return -1;
    }
    memcpy(metafile, file, flen);
    memcpy(metafile+flen, ext, extlen);

    // restrictive permissions for the metadata file.
    // TODO: also for the mmap file eh? :P
    mode_t oldmask = umask(~(S_IRUSR | S_IWUSR));
    FILE *f = fopen(metafile, ""w"");
    umask(oldmask);
    if (f == NULL) {
        // FIXME: correct error handling.
        free(metafile);
        perror(""failed to write metadata file"");
        return -1;
    }

    restart_data_cb *cb = cb_stack;
    restart_cb_ctx ctx;
    ctx.f = f;
    while (cb != NULL) {
        // Plugins/engines in the metadata file are separa...",217.0,262.0,1.0,1.0,46.0,28,10,45,14,1,2,5,6,0,0,,0,2,2,1,1,int
1846,79159,restart_set_kv,1,restart_set_kv,"void restart_set_kv (void*,char*,char*...)",restart.c,"void restart_set_kv(void *ctx, const char *key, const char *fmt, ...) {
    va_list ap;
    restart_cb_ctx *c = (restart_cb_ctx *) ctx;
    char valbuf[SET_VAL_MAX];

    va_start(ap, fmt);
    int vlen = vsnprintf(valbuf, SET_VAL_MAX-1, fmt, ap);
    va_end(ap);
    // This is heavy handed. We need to protect against corrupt data as much
    // as possible. The buffer is large and these values are currently small,
    // it will take a significant mistake to land here.
    if (vlen >= SET_VAL_MAX) {
        fprintf(stderr, ""[restart] fatal error while saving metadata state, value too long for: %s %s"",
                key, valbuf);
        abort();
    }

    fprintf(c->f, ""K%s %s\n"", key, valbuf);
    // TODO: update crc32c
}",268.0,287.0,1.0,16.0,20.0,6,5,16,8,17,1,2,2,0,0,,0,1,6,3,3,void
1847,79211,_find_pagesize,1,_find_pagesize,long _find_pagesize (void),restart.c,"static long _find_pagesize(void) {
#if defined(HAVE_SYSCONF) && defined(_SC_PAGESIZE)
    return sysconf(_SC_PAGESIZE);
#else
    // A good guess.
    return 4096;
#endif
}",289.0,296.0,1.0,1.0,8.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,long
1848,79218,restart_mmap_open,1,restart_mmap_open,"bool restart_mmap_open (size_t,char*,void**)",restart.c,"bool restart_mmap_open(const size_t limit, const char *file, void **mem_base) {
    bool reuse_mmap = true;

    long pagesize = _find_pagesize();
    memory_file = strdup(file);
    mmap_fd = open(file, O_RDWR|O_CREAT, S_IRWXU);
    if (mmap_fd == -1) {
        perror(""failed to open file for mmap"");
        abort();
    }
    if (ftruncate(mmap_fd, limit) != 0) {
        perror(""ftruncate failed"");
        abort();
    }
    /* Allocate everything in a big chunk with malloc */
    if (limit % pagesize) {
        // This is a sanity check; shouldn't ever be possible since we
        // increase memory by whole megabytes.
        fprintf(stderr, ""[restart] memory limit not divisible evenly by pagesize (please report bug)\n"");
        abort();
    }
    mmap_base = mmap(NULL, limit, PROT_READ|PROT_WRITE, MAP_SHARED, mmap_fd, 0);
    if (mmap_base == MAP_FAILED) {
        perror(""failed to mmap, aborting"");
        abort();
    }
    // Set the limit before calling check_mmap, so we c...",298.0,332.0,1.0,1.0,35.0,17,7,33,20,1,10,6,6,4,2,,0,10,6,3,3,bool
1849,79310,restart_mmap_close,1,restart_mmap_close,void restart_mmap_close (void),restart.c,"void restart_mmap_close(void) {
    msync(mmap_base, slabmem_limit, MS_SYNC);

    if (restart_save(memory_file) != 0) {
        fprintf(stderr, ""[restart] failed to save metadata"");
    }

    if (munmap(mmap_base, slabmem_limit) != 0) {
        perror(""[restart] failed to munmap shared memory"");
    } else if (close(mmap_fd) != 0) {
        perror(""[restart] failed to close shared memory fd"");
    }

    free(memory_file);
}",335.0,349.0,1.0,1.0,15.0,2,1,8,5,1,5,3,3,3,1,,0,5,2,1,1,void
1850,79349,restart_fixup,1,restart_fixup,unsigned int restart_fixup (void*),restart.c,"unsigned int restart_fixup(void *orig_addr) {
    struct timeval tv;
    uint64_t checked = 0;
    const unsigned int page_size = settings.slab_page_size;
    unsigned int page_remain = page_size;

    gettimeofday(&tv, NULL);
    if (settings.verbose > 0) {
        fprintf(stderr, ""[restart] original memory base: [%p] new base: [%p]\n"", orig_addr, mmap_base);
        fprintf(stderr, ""[restart] recovery start [%d.%d]\n"", (int)tv.tv_sec, (int)tv.tv_usec);
    }

    // since chunks don't align with pages, we have to also track page size.
    while (checked < slabmem_limit) {
        //fprintf(stderr, ""checked: %lu\n"", checked);
        item *it = (item *)((char *)mmap_base + checked);

        int size = slabs_fixup((char *)mmap_base + checked,
                checked % settings.slab_page_size);
        //fprintf(stderr, ""id: %d, size: %d remain: %u\n"", it->slabs_clsid, size, page_remain);
        // slabber gobbled an entire page, skip and move on.
        if (size == -1) {
        ...",354.0,443.0,1.0,27.0,90.0,143,18,98,15,1,17,15,30,3,3,,0,16,2,1,1,unsigned int
1851,79774,restart_check_cb,1,restart_check_cb,"int restart_check_cb (char*,void*,void*)",restart.h,"typedef int (*restart_check_cb)(const char *tag, void *ctx, void *data);",17.0,17.0,13.0,71.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,int
1852,79781,restart_save_cb,1,restart_save_cb,"int restart_save_cb (char*,void*,void*)",restart.h,"typedef int (*restart_save_cb)(const char *tag, void *ctx, void *data);",18.0,18.0,13.0,70.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,int
1853,79840,sasl_callback_ft,1,sasl_callback_ft,int sasl_callback_ft (void),sasl_defs.c,typedef int (*sasl_callback_ft)(void);,39.0,39.0,13.0,37.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
1854,79845,sasl_log,1,sasl_log,"int sasl_log (void*,int,char*)",sasl_defs.c,"static int sasl_log(void *context, int level, const char *message)
{
    bool log = true;

    switch (level) {
    case SASL_LOG_NONE:
        log = false;
        break;
    case SASL_LOG_PASS:
    case SASL_LOG_TRACE:
    case SASL_LOG_DEBUG:
    case SASL_LOG_NOTE:
        if (settings.verbose < 2) {
            log = false;
        }
        break;
    case SASL_LOG_WARN:
    case SASL_LOG_FAIL:
        if (settings.verbose < 1) {
            log = false;
        }
        break;
    default:
        /* This is an error */
        ;
    }

    if (log) {
        fprintf(stderr, ""SASL (severity %d): %s\n"", level, message);
    }

    return SASL_OK;
}",141.0,173.0,1.0,11.0,33.0,8,3,22,14,0,2,8,7,2,0,,0,2,6,3,3,int
1855,79945,display,1,display,"void display (char*,size_t)",sizes.c,"static void display(const char *name, size_t size) {
    printf(""%s\t%d\n"", name, (int)size);
}",5.0,7.0,1.0,1.0,3.0,1,1,2,2,0,0,1,1,0,0,,0,0,4,2,2,void
1856,80094,slab_automove_init,1,slab_automove_init,void* slab_automove_init (settings*),slab_automove.c,"void *slab_automove_init(struct settings *settings) {
    uint32_t window_size = settings->slab_automove_window;
    double max_age_ratio = settings->slab_automove_ratio;
    slab_automove *a = calloc(1, sizeof(slab_automove));
    if (a == NULL)
        return NULL;
    a->window_data = calloc(window_size * MAX_NUMBER_OF_SLAB_CLASSES, sizeof(struct window_data));
    a->window_size = window_size;
    a->max_age_ratio = max_age_ratio;
    if (a->window_data == NULL) {
        free(a);
        return NULL;
    }

    // do a dry run to fill the before structs
    fill_item_stats_automove(a->iam_before);
    fill_slab_stats_automove(a->sam_before);

    return (void *)a;
}",34.0,53.0,1.0,42.0,20.0,21,7,23,7,0,9,3,3,0,2,,0,7,2,1,1,void*
1857,80172,slab_automove_free,1,slab_automove_free,void slab_automove_free (void*),slab_automove.c,"void slab_automove_free(void *arg) {
    slab_automove *a = (slab_automove *)arg;
    free(a->window_data);
    free(a);
}",55.0,59.0,1.0,1.0,5.0,3,3,4,2,0,0,1,1,0,0,,0,0,2,1,1,void
1858,80189,window_sum,1,window_sum,"void window_sum (window_data*,window_data*,uint32_t)",slab_automove_extstore.c,"static void window_sum(struct window_data *wd, struct window_data *w,
        uint32_t size) {
    for (int x = 0; x < size; x++) {
        struct window_data *d = &wd[x];
        w->age += d->age;
        w->dirty += d->dirty;
        w->evicted += d->evicted;
        w->excess_free += d->excess_free;
        w->relaxed += d->relaxed;
    }
}",74.0,84.0,1.0,1.0,11.0,17,6,14,5,2,8,2,2,0,0,,0,8,6,3,3,void
1859,80243,slab_automove_run,1,slab_automove_run,"void slab_automove_run (void*,int*,int*)",slab_automove.c,"void slab_automove_run(void *arg, int *src, int *dst) {
    slab_automove *a = (slab_automove *)arg;
    int n;
    struct window_data w_sum;
    int oldest = -1;
    uint64_t oldest_age = 0;
    int youngest = -1;
    uint64_t youngest_age = ~0;
    bool youngest_evicting = false;
    *src = -1;
    *dst = -1;

    // fill after structs
    fill_item_stats_automove(a->iam_after);
    fill_slab_stats_automove(a->sam_after);
    // Loop once to get total_evicted for this window.
    uint64_t evicted_total = 0;
    for (n = POWER_SMALLEST; n < MAX_NUMBER_OF_SLAB_CLASSES; n++) {
        evicted_total += a->iam_after[n].evicted - a->iam_before[n].evicted;
    }
    a->window_cur++;

    // iterate slabs
    for (n = POWER_SMALLEST; n < MAX_NUMBER_OF_SLAB_CLASSES; n++) {
        int w_offset = n * a->window_size;
        struct window_data *wd = &a->window_data[w_offset + (a->window_cur % a->window_size)];
        memset(wd, 0, sizeof(struct window_data));

        // if page delta, or e...",74.0,169.0,1.0,13.0,96.0,169,24,116,21,0,43,13,21,15,3,,0,40,6,3,3,void
1860,80715,slab_automove_init_func,1,slab_automove_init_func,void* slab_automove_init_func (settings*),slab_automove.h,typedef void *(*slab_automove_init_func)(struct settings *settings);,9.0,9.0,14.0,67.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void*
1861,80720,slab_automove_free_func,1,slab_automove_free_func,void slab_automove_free_func (void*),slab_automove.h,typedef void (*slab_automove_free_func)(void *arg);,10.0,10.0,14.0,50.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
1862,80725,slab_automove_run_func,1,slab_automove_run_func,"void slab_automove_run_func (void*,int*,int*)",slab_automove.h,"typedef void (*slab_automove_run_func)(void *arg, int *src, int *dst);",11.0,11.0,14.0,69.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,void
1863,80801,slab_automove_extstore_init,1,slab_automove_extstore_init,void* slab_automove_extstore_init (settings*),slab_automove_extstore.c,"void *slab_automove_extstore_init(struct settings *settings) {
    uint32_t window_size = settings->slab_automove_window;
    double max_age_ratio = settings->slab_automove_ratio;
    slab_automove *a = calloc(1, sizeof(slab_automove));
    if (a == NULL)
        return NULL;
    a->window_data = calloc(window_size * MAX_NUMBER_OF_SLAB_CLASSES, sizeof(struct window_data));
    a->window_size = window_size;
    a->max_age_ratio = max_age_ratio;
    a->free_ratio = settings->slab_automove_freeratio;
    a->item_size = settings->ext_item_size;
    a->settings = settings;
    a->pool_filled_once = false;
    if (a->window_data == NULL) {
        if (a->window_data)
            free(a->window_data);
        free(a);
        return NULL;
    }

    // do a dry run to fill the before structs
    fill_item_stats_automove(a->iam_before);
    fill_slab_stats_automove(a->sam_before);

    return (void *)a;
}",41.0,66.0,1.0,42.0,26.0,33,7,33,8,0,14,4,5,0,2,,0,12,2,1,1,void*
1864,80912,slab_automove_extstore_free,1,slab_automove_extstore_free,void slab_automove_extstore_free (void*),slab_automove_extstore.c,"void slab_automove_extstore_free(void *arg) {
    slab_automove *a = (slab_automove *)arg;
    free(a->window_data);
    free(a);
}",68.0,72.0,1.0,1.0,5.0,3,3,4,2,0,0,1,1,0,0,,0,0,2,1,1,void
1865,80990,global_pool_check,1,global_pool_check,int global_pool_check (slab_automove*),slab_automove_extstore.c,"static int global_pool_check(slab_automove *a) {
    bool mem_limit_reached;
    unsigned int free = a->global_pool_watermark;
    unsigned int count = global_page_pool_size(&mem_limit_reached);
    if (!mem_limit_reached)
        return 0;
    if (count < free) {
        a->pool_filled_once = true;
        return 1;
    } else {
        a->pool_filled_once = true;
    }
    return 0;
}",86.0,99.0,1.0,1.0,14.0,8,5,9,5,1,3,3,3,0,1,,0,3,2,1,1,int
1866,81035,memcheck,1,memcheck,void memcheck (slab_automove*),slab_automove_extstore.c,"static void memcheck(slab_automove *a) {
    unsigned int total_pages = 0;

    // FIXME: is there a cached counter for total pages alloced?
    // technically we only really need to do this once as the pages are
    // prefilled and ratio isn't a runtime change.
    for (int n = 1; n < MAX_NUMBER_OF_SLAB_CLASSES; n++) {
        slab_stats_automove *sam = &a->sam_after[n];
        total_pages += sam->total_pages;
    }
    // always update what remains in the global page pool
    total_pages += a->sam_after[0].total_pages;
    a->global_pool_watermark = total_pages * a->free_ratio;
    if (a->global_pool_watermark < 2)
        a->global_pool_watermark = 2;
    settings.ext_global_pool_min = a->global_pool_watermark;
}",110.0,126.0,1.0,24.0,17.0,25,9,17,5,1,9,3,3,1,0,,0,9,2,1,1,void
1867,81111,get_window_data,1,get_window_data,"struct window_data get_window_data (slab_automove*,int)",slab_automove_extstore.c,"static struct window_data *get_window_data(slab_automove *a, int class) {
    int w_offset = class * a->window_size;
    return &a->window_data[w_offset + (a->window_cur % a->window_size)];
}",128.0,131.0,1.0,1.0,4.0,10,7,7,3,1,3,1,1,0,0,,0,3,4,2,2,struct window_data
1868,81140,slab_automove_extstore_run,1,slab_automove_extstore_run,"void slab_automove_extstore_run (void*,int*,int*)",slab_automove_extstore.c,"void slab_automove_extstore_run(void *arg, int *src, int *dst) {
    slab_automove *a = (slab_automove *)arg;
    int n;
    struct window_data w_sum;
    int oldest = -1;
    uint64_t oldest_age = 0;
    bool too_free = false;
    *src = -1;
    *dst = -1;

    int global_low = global_pool_check(a);
    // fill after structs
    fill_item_stats_automove(a->iam_after);
    fill_slab_stats_automove(a->sam_after);
    a->window_cur++;

    memcheck(a);

    // iterate slabs
    for (n = POWER_SMALLEST; n < MAX_NUMBER_OF_SLAB_CLASSES; n++) {
        bool small_slab = a->sam_before[n].chunk_size < a->item_size
            ? true : false;
        struct window_data *wd = get_window_data(a, n);
        int w_offset = n * a->window_size;
        memset(wd, 0, sizeof(struct window_data));
        unsigned int free_target = a->sam_after[n].chunks_per_page * MIN_PAGES_FREE;

        // if page delta, oom, or evicted delta, mark window dirty
        // classes marked dirty cannot donate memory...",133.0,228.0,1.0,13.0,96.0,138,22,98,20,0,39,11,20,13,6,,0,35,6,3,3,void
1869,81651,grow_slab_list,1,grow_slab_list,int grow_slab_list (unsigned int),slabs.c,"static int grow_slab_list (const unsigned int id) {
    slabclass_t *p = &slabclass[id];
    if (p->slabs == p->list_size) {
        size_t new_size =  (p->list_size != 0) ? p->list_size * 2 : 16;
        void *new_list = realloc(p->slab_list, new_size * sizeof(void *));
        if (new_list == 0) return 0;
        p->list_size = new_size;
        p->slab_list = new_list;
    }
    return 1;
}",337.0,347.0,1.0,1.0,11.0,0,0,0,0,4,0,1,1,0,0,,0,0,2,1,1,int
1870,81656,do_slabs_newslab,1,do_slabs_newslab,int do_slabs_newslab (unsigned int),slabs.c,"static int do_slabs_newslab(const unsigned int id) {
    slabclass_t *p = &slabclass[id];
    slabclass_t *g = &slabclass[SLAB_GLOBAL_PAGE_POOL];
    int len = (settings.slab_reassign || settings.slab_chunk_size_max != settings.slab_page_size)
        ? settings.slab_page_size
        : p->size * p->perslab;
    char *ptr;

    if ((mem_limit && mem_malloced + len > mem_limit && p->slabs > 0
         && g->slabs == 0)) {
        mem_limit_reached = true;
        MEMCACHED_SLABS_SLABCLASS_ALLOCATE_FAILED(id);
        return 0;
    }

    if ((grow_slab_list(id) == 0) ||
        (((ptr = get_page_from_global_pool()) == NULL) &&
        ((ptr = memory_allocate((size_t)len)) == 0))) {

        MEMCACHED_SLABS_SLABCLASS_ALLOCATE_FAILED(id);
        return 0;
    }

    // Always wipe the memory at this stage: in restart mode the mmap memory
    // could be unused, yet still full of data. Better for usability if we're
    // wiping memory as it's being pulled out of the global pool instea...",369.0,403.0,1.0,32.0,35.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,int
1871,81661,memory_allocate,1,memory_allocate,void* memory_allocate (size_t),slabs.c,"static void *memory_allocate(size_t size) {
    void *ret;

    if (mem_base == NULL) {
        /* We are not using a preallocated large memory chunk */
        ret = malloc(size);
    } else {
        ret = mem_current;

        if (size > mem_avail) {
            return NULL;
        }

        /* mem_current pointer _must_ be aligned!!! */
        if (size % CHUNK_ALIGN_BYTES) {
            size += CHUNK_ALIGN_BYTES - (size % CHUNK_ALIGN_BYTES);
        }

        mem_current = ((char*)mem_current) + size;
        if (size < mem_avail) {
            mem_avail -= size;
        } else {
            mem_avail = 0;
        }
    }
    mem_malloced += size;

    return ret;
}",610.0,638.0,1.0,19.0,29.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void*
1872,81666,do_slabs_free,1,do_slabs_free,"void do_slabs_free (void*,size_t,unsigned int)",slabs.c,"static void do_slabs_free(void *ptr, const size_t size, unsigned int id) {
    slabclass_t *p;
    item *it;

    assert(id >= POWER_SMALLEST && id <= power_largest);
    if (id < POWER_SMALLEST || id > power_largest)
        return;

    MEMCACHED_SLABS_FREE(size, id, ptr);
    p = &slabclass[id];

    it = (item *)ptr;
    if ((it->it_flags & ITEM_CHUNKED) == 0) {
        it->it_flags = ITEM_SLABBED;
        it->slabs_clsid = id;
        it->prev = 0;
        it->next = p->slots;
        if (it->next) it->next->prev = it;
        p->slots = it;

        p->sl_curr++;
    } else {
        do_slabs_free_chunked(it, size);
    }
    return;
}",498.0,523.0,1.0,17.0,26.0,0,0,0,0,2,0,1,1,0,0,,0,0,6,3,3,void
1873,81673,slabs_preallocate,1,slabs_preallocate,void slabs_preallocate (unsigned int),slabs.c,"static void slabs_preallocate (const unsigned int maxslabs) {
    int i;
    unsigned int prealloc = 0;

    /* pre-allocate a 1MB slab in every size class so people don't get
       confused by non-intuitive ""SERVER_ERROR out of memory""
       messages.  this is the most common question on the mailing
       list.  if you really don't want this, you can rebuild without
       these three lines.  */

    for (i = POWER_SMALLEST; i < MAX_NUMBER_OF_SLAB_CLASSES; i++) {
        if (++prealloc > maxslabs)
            break;
        if (do_slabs_newslab(i) == 0) {
            fprintf(stderr, ""Error while preallocating slab memory!\n""
                ""If using -L or other prealloc options, max memory must be ""
                ""at least %d megabytes.\n"", power_largest);
            exit(1);
        }
    }
}",315.0,335.0,1.0,13.0,21.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
1874,81678,slabs_clsid,1,slabs_clsid,unsigned int slabs_clsid (size_t),slabs.c,"unsigned int slabs_clsid(const size_t size) {
    int res = POWER_SMALLEST;

    if (size == 0 || size > settings.item_size_max)
        return 0;
    while (size > slabclass[res].size)
        if (res++ == power_largest)     /* won't fit in the biggest slab */
            return power_largest;
    return res;
}",90.0,99.0,1.0,14.0,10.0,8,6,8,4,4,2,3,3,2,0,,0,2,2,1,1,unsigned int
1875,81720,slabs_size,1,slabs_size,unsigned int slabs_size (int),slabs.c,"unsigned int slabs_size(const int clsid) {
    return slabclass[clsid].size;
}",101.0,103.0,1.0,1.0,3.0,2,2,2,2,1,1,1,1,0,0,,0,1,2,1,1,unsigned int
1876,81731,alloc_large_chunk,1,alloc_large_chunk,void* alloc_large_chunk (size_t),slabs.c,"static void * alloc_large_chunk(const size_t limit)
{
    void *ptr = NULL;
#if defined(__linux__) && defined(MADV_HUGEPAGE)
    size_t pagesize = 0;
    FILE *fp;
    int ret;

    /* Get the size of huge pages */
    fp = fopen(""/proc/meminfo"", ""r"");
    if (fp != NULL) {
        char buf[64];

        while ((fgets(buf, sizeof(buf), fp)))
            if (!strncmp(buf, ""Hugepagesize:"", 13)) {
                ret = sscanf(buf + 13, ""%zu\n"", &pagesize);

                /* meminfo huge page size is in KiBs */
                pagesize <<= 10;
            }
        fclose(fp);
    }

    if (!pagesize) {
        fprintf(stderr, ""Failed to get supported huge page size\n"");
        return NULL;
    }

    if (settings.verbose > 1)
        fprintf(stderr, ""huge page size: %zu\n"", pagesize);

    /* This works because glibc simply uses mmap when the alignment is
     * above a certain limit. */
    ret = posix_memalign(&ptr, pagesize, limit);
    if (ret != 0) {
        fprintf(stderr, ""F...",108.0,164.0,1.0,1.0,57.0,2,1,5,3,1,0,1,1,0,0,,0,0,2,1,1,void*
1877,81746,slabs_fixup,1,slabs_fixup,"unsigned int slabs_fixup (char*,int)",slabs.c,"unsigned int slabs_fixup(char *chunk, const int border) {
    slabclass_t *p;
    item *it = (item *)chunk;
    int id = ITEM_clsid(it);

    // memory isn't used yet. shunt to global pool.
    // (which must be 0)
    if (id == 0) {
        //assert(border == 0);
        p = &slabclass[0];
        grow_slab_list(0);
        p->slab_list[p->slabs++] = (char*)chunk;
        return -1;
    }
    p = &slabclass[id];

    // if we're on a page border, add the slab to slab class
    if (border == 0) {
        grow_slab_list(id);
        p->slab_list[p->slabs++] = chunk;
    }

    // increase free count if ITEM_SLABBED
    if (it->it_flags == ITEM_SLABBED) {
        // if ITEM_SLABBED re-stack on freelist.
        // don't have to run pointer fixups.
        it->prev = 0;
        it->next = p->slots;
        if (it->next) it->next->prev = it;
        p->slots = it;

        p->sl_curr++;
        //fprintf(stderr, ""replacing into freelist\n"");
    }

    return p->size;
}",166.0,202.0,1.0,13.0,37.0,43,11,30,6,1,12,5,6,0,2,,0,10,4,2,2,unsigned int
1878,81870,slabs_init,1,slabs_init,"void slabs_init (size_t,double,bool,uint32_t*,void*,bool)",slabs.c,"void slabs_init(const size_t limit, const double factor, const bool prealloc, const uint32_t *slab_sizes, void *mem_base_external, bool reuse_mem) {
    int i = POWER_SMALLEST - 1;
    unsigned int size = sizeof(item) + settings.chunk_size;

    /* Some platforms use runtime transparent hugepages. If for any reason
     * the initial allocation fails, the required settings do not persist
     * for remaining allocations. As such it makes little sense to do slab
     * preallocation. */
    bool __attribute__ ((unused)) do_slab_prealloc = false;

    mem_limit = limit;

    if (prealloc && mem_base_external == NULL) {
        mem_base = alloc_large_chunk(mem_limit);
        if (mem_base) {
            do_slab_prealloc = true;
            mem_current = mem_base;
            mem_avail = mem_limit;
        } else {
            fprintf(stderr, ""Warning: Failed to allocate requested memory in""
                    "" one large chunk.\nWill allocate in smaller chunks\n"");
        }
    } els...",208.0,296.0,1.0,12.0,89.0,71,19,77,24,1,34,15,23,4,3,,0,33,12,6,6,void
1879,82166,slabs_prefill_global,1,slabs_prefill_global,void slabs_prefill_global (void),slabs.c,"void slabs_prefill_global(void) {
    void *ptr;
    slabclass_t *p = &slabclass[0];
    int len = settings.slab_page_size;

    while (mem_malloced < mem_limit
            && (ptr = memory_allocate(len)) != NULL) {
        grow_slab_list(0);
        // Ensure the front header is zero'd to avoid confusing restart code.
        // It's probably good enough to cast it and just zero slabs_clsid, but
        // this is extra paranoid.
        memset(ptr, 0, sizeof(item));
        p->slab_list[p->slabs++] = ptr;
    }
    mem_limit_reached = true;
}",298.0,313.0,1.0,1.0,16.0,16,10,16,11,1,9,2,2,3,2,,0,8,2,1,1,void
1880,82329,split_slab_page_into_freelist,1,split_slab_page_into_freelist,"void split_slab_page_into_freelist (char*,unsigned int)",slabs.c,"static void split_slab_page_into_freelist(char *ptr, const unsigned int id) {
    slabclass_t *p = &slabclass[id];
    int x;
    for (x = 0; x < p->perslab; x++) {
        do_slabs_free(ptr, 0, id);
        ptr += p->size;
    }
}",349.0,356.0,1.0,1.0,8.0,8,6,10,5,1,4,2,2,1,1,,0,3,4,2,2,void
1881,82365,get_page_from_global_pool,1,get_page_from_global_pool,void* get_page_from_global_pool (void),slabs.c,"static void *get_page_from_global_pool(void) {
    slabclass_t *p = &slabclass[SLAB_GLOBAL_PAGE_POOL];
    if (p->slabs < 1) {
        return NULL;
    }
    char *ret = p->slab_list[p->slabs - 1];
    p->slabs--;
    return ret;
}",359.0,367.0,1.0,32.0,9.0,12,7,9,4,1,5,2,2,1,0,,0,5,2,1,1,void*
1882,82523,do_slabs_alloc,1,do_slabs_alloc,"void* do_slabs_alloc (size_t,unsigned int,unsigned int)",slabs.c,"static void *do_slabs_alloc(const size_t size, unsigned int id,
        unsigned int flags) {
    slabclass_t *p;
    void *ret = NULL;
    item *it = NULL;

    if (id < POWER_SMALLEST || id > power_largest) {
        MEMCACHED_SLABS_ALLOCATE_FAILED(size, 0);
        return NULL;
    }
    p = &slabclass[id];
    assert(p->sl_curr == 0 || (((item *)p->slots)->it_flags & ITEM_SLABBED));

    assert(size <= p->size);
    /* fail unless we have space at the end of a recently allocated page,
       we have something on our freelist, or we could allocate a new page */
    if (p->sl_curr == 0 && flags != SLABS_ALLOC_NO_NEWPAGE) {
        do_slabs_newslab(id);
    }

    if (p->sl_curr != 0) {
        /* return off our freelist */
        it = (item *)p->slots;
        p->slots = it->next;
        if (it->next) it->next->prev = 0;
        /* Kill flag and initialize refcount here for lock safety in slab
         * mover's freeness detection. */
        it->it_flags &= ~ITEM_SLABBED;
     ...",406.0,448.0,1.0,13.0,43.0,41,15,32,9,2,11,6,7,3,1,,0,10,6,3,3,void*
1883,82664,do_slabs_free_chunked,1,do_slabs_free_chunked,"void do_slabs_free_chunked (item*,size_t)",slabs.c,"static void do_slabs_free_chunked(item *it, const size_t size) {
    item_chunk *chunk = (item_chunk *) ITEM_schunk(it);
    slabclass_t *p;

    it->it_flags = ITEM_SLABBED;
    // FIXME: refresh on how this works?
    //it->slabs_clsid = 0;
    it->prev = 0;
    // header object's original classid is stored in chunk.
    p = &slabclass[chunk->orig_clsid];
    // original class id needs to be set on free memory.
    it->slabs_clsid = chunk->orig_clsid;
    if (chunk->next) {
        chunk = chunk->next;
        chunk->prev = 0;
    } else {
        // header with no attached chunk
        chunk = NULL;
    }

    // return the header object.
    // TODO: This is in three places, here and in do_slabs_free().
    it->prev = 0;
    it->next = p->slots;
    if (it->next) it->next->prev = it;
    p->slots = it;
    p->sl_curr++;

    item_chunk *next_chunk;
    while (chunk) {
        assert(chunk->it_flags == ITEM_CHUNK);
        chunk->it_flags = ITEM_SLABBED;
        p = &slabclass[c...",450.0,495.0,1.0,39.0,46.0,71,11,47,7,0,8,5,6,0,0,,0,8,4,2,2,void
1884,82964,fill_slab_stats_automove,1,fill_slab_stats_automove,void fill_slab_stats_automove (slab_stats_automove*),slabs.c,"void fill_slab_stats_automove(slab_stats_automove *am) {
    int n;
    pthread_mutex_lock(&slabs_lock);
    for (n = 0; n < MAX_NUMBER_OF_SLAB_CLASSES; n++) {
        slabclass_t *p = &slabclass[n];
        slab_stats_automove *cur = &am[n];
        cur->chunks_per_page = p->perslab;
        cur->free_chunks = p->sl_curr;
        cur->total_pages = p->slabs;
        cur->chunk_size = p->size;
    }
    pthread_mutex_unlock(&slabs_lock);
}",528.0,540.0,1.0,20.0,13.0,23,6,18,6,4,11,2,2,0,0,,0,11,2,1,1,void
1885,83033,global_page_pool_size,1,global_page_pool_size,unsigned int global_page_pool_size (bool*),slabs.c,"unsigned int global_page_pool_size(bool *mem_flag) {
    unsigned int ret = 0;
    pthread_mutex_lock(&slabs_lock);
    if (mem_flag != NULL)
        *mem_flag = mem_malloced >= mem_limit ? true : false;
    ret = slabclass[SLAB_GLOBAL_PAGE_POOL].slabs;
    pthread_mutex_unlock(&slabs_lock);
    return ret;
}",545.0,553.0,1.0,20.0,9.0,11,8,13,9,3,5,2,2,0,0,,0,5,2,1,1,unsigned int
1886,83073,do_slabs_stats,1,do_slabs_stats,"void do_slabs_stats (ADD_STAT,void*)",slabs.c,"static void do_slabs_stats(ADD_STAT add_stats, void *c) {
    int i, total;
    /* Get the per-thread stats which contain some interesting aggregates */
    struct thread_stats thread_stats;
    threadlocal_stats_aggregate(&thread_stats);

    total = 0;
    for(i = POWER_SMALLEST; i <= power_largest; i++) {
        slabclass_t *p = &slabclass[i];
        if (p->slabs != 0) {
            uint32_t perslab, slabs;
            slabs = p->slabs;
            perslab = p->perslab;

            char key_str[STAT_KEY_LEN];
            char val_str[STAT_VAL_LEN];
            int klen = 0, vlen = 0;

            APPEND_NUM_STAT(i, ""chunk_size"", ""%u"", p->size);
            APPEND_NUM_STAT(i, ""chunks_per_page"", ""%u"", perslab);
            APPEND_NUM_STAT(i, ""total_pages"", ""%u"", slabs);
            APPEND_NUM_STAT(i, ""total_chunks"", ""%u"", slabs * perslab);
            APPEND_NUM_STAT(i, ""used_chunks"", ""%u"",
                            slabs*perslab - p->sl_curr);
            APPEND_NUM_STAT(i, ""...",556.0,608.0,1.0,12.0,53.0,85,11,216,16,1,12,3,4,2,3,,0,9,4,2,2,void
1887,83689,memory_release,1,memory_release,void memory_release (),slabs.c,"static void memory_release() {
    void *p = NULL;
    if (mem_base != NULL)
        return;

    if (!settings.slab_reassign)
        return;

    while (mem_malloced > mem_limit &&
            (p = get_page_from_global_pool()) != NULL) {
        free(p);
        mem_malloced -= settings.slab_page_size;
    }
}",641.0,654.0,1.0,1.0,14.0,10,7,12,6,1,7,4,4,5,1,,0,7,0,0,0,void
1888,83728,slabs_alloc,1,slabs_alloc,"void* slabs_alloc (size_t,unsigned int,unsigned int)",slabs.c,"void *slabs_alloc(size_t size, unsigned int id,
        unsigned int flags) {
    void *ret;

    pthread_mutex_lock(&slabs_lock);
    ret = do_slabs_alloc(size, id, flags);
    pthread_mutex_unlock(&slabs_lock);
    return ret;
}",656.0,664.0,1.0,1.0,9.0,3,2,7,5,1,3,1,1,0,1,,0,3,6,3,3,void*
1889,83750,slabs_free,1,slabs_free,"void slabs_free (void*,size_t,unsigned int)",slabs.c,"void slabs_free(void *ptr, size_t size, unsigned int id) {
    pthread_mutex_lock(&slabs_lock);
    do_slabs_free(ptr, size, id);
    pthread_mutex_unlock(&slabs_lock);
}",666.0,670.0,1.0,1.0,5.0,2,1,5,4,1,3,1,1,0,1,,0,2,6,3,3,void
1890,83767,slabs_stats,1,slabs_stats,"void slabs_stats (ADD_STAT,void*)",slabs.c,"void slabs_stats(ADD_STAT add_stats, void *c) {
    pthread_mutex_lock(&slabs_lock);
    do_slabs_stats(add_stats, c);
    pthread_mutex_unlock(&slabs_lock);
}",672.0,676.0,1.0,1.0,5.0,2,1,4,3,0,3,1,1,0,1,,0,2,4,2,2,void
1891,83782,do_slabs_adjust_mem_limit,1,do_slabs_adjust_mem_limit,bool do_slabs_adjust_mem_limit (size_t),slabs.c,"static bool do_slabs_adjust_mem_limit(size_t new_mem_limit) {
    /* Cannot adjust memory limit at runtime if prealloc'ed */
    if (mem_base != NULL)
        return false;
    settings.maxbytes = new_mem_limit;
    mem_limit = new_mem_limit;
    mem_limit_reached = false; /* Will reset on next alloc */
    memory_release(); /* free what might already be in the global pool */
    return true;
}",678.0,687.0,1.0,1.0,10.0,5,3,10,8,1,5,2,2,1,0,,0,4,2,1,1,bool
1892,83808,slabs_adjust_mem_limit,1,slabs_adjust_mem_limit,bool slabs_adjust_mem_limit (size_t),slabs.c,"bool slabs_adjust_mem_limit(size_t new_mem_limit) {
    bool ret;
    pthread_mutex_lock(&slabs_lock);
    ret = do_slabs_adjust_mem_limit(new_mem_limit);
    pthread_mutex_unlock(&slabs_lock);
    return ret;
}",689.0,695.0,1.0,1.0,7.0,3,2,5,3,0,3,1,1,0,1,,0,3,2,1,1,bool
1893,83826,slabs_available_chunks,1,slabs_available_chunks,"unsigned int slabs_available_chunks (unsigned int,bool*,unsigned int*)",slabs.c,"unsigned int slabs_available_chunks(const unsigned int id, bool *mem_flag,
        unsigned int *chunks_perslab) {
    unsigned int ret;
    slabclass_t *p;

    pthread_mutex_lock(&slabs_lock);
    p = &slabclass[id];
    ret = p->sl_curr;
    if (mem_flag != NULL)
        *mem_flag = mem_malloced >= mem_limit ? true : false;
    if (chunks_perslab != NULL)
        *chunks_perslab = p->perslab;
    pthread_mutex_unlock(&slabs_lock);
    return ret;
}",697.0,711.0,1.0,1.0,15.0,16,8,19,12,1,7,3,3,0,0,,0,7,6,3,3,unsigned int
1894,83879,slabs_mlock,1,slabs_mlock,void slabs_mlock (void),slabs.c,"void slabs_mlock(void) {
    pthread_mutex_lock(&slabs_lock);
}",719.0,721.0,1.0,1.0,3.0,1,1,1,1,1,1,1,1,0,0,,0,1,2,1,1,void
1895,83887,slabs_munlock,1,slabs_munlock,void slabs_munlock (void),slabs.c,"void slabs_munlock(void) {
    pthread_mutex_unlock(&slabs_lock);
}",723.0,725.0,1.0,1.0,3.0,1,1,1,1,1,1,1,1,0,0,,0,1,2,1,1,void
1896,83903,slab_rebalance_start,1,slab_rebalance_start,int slab_rebalance_start (void),slabs.c,"static int slab_rebalance_start(void) {
    slabclass_t *s_cls;
    int no_go = 0;

    pthread_mutex_lock(&slabs_lock);

    if (slab_rebal.s_clsid < SLAB_GLOBAL_PAGE_POOL ||
        slab_rebal.s_clsid > power_largest  ||
        slab_rebal.d_clsid < SLAB_GLOBAL_PAGE_POOL ||
        slab_rebal.d_clsid > power_largest  ||
        slab_rebal.s_clsid == slab_rebal.d_clsid)
        no_go = -2;

    s_cls = &slabclass[slab_rebal.s_clsid];

    if (!grow_slab_list(slab_rebal.d_clsid)) {
        no_go = -1;
    }

    if (s_cls->slabs < 2)
        no_go = -3;

    if (no_go != 0) {
        pthread_mutex_unlock(&slabs_lock);
        return no_go; /* Should use a wrapper function... */
    }

    /* Always kill the first available slab page as it is most likely to
     * contain the oldest items
     */
    slab_rebal.slab_start = s_cls->slab_list[0];
    slab_rebal.slab_end   = (char *)slab_rebal.slab_start +
        (s_cls->size * s_cls->perslab);
    slab_rebal.slab_pos   = slab_rebal.sl...",730.0,786.0,1.0,29.0,57.0,65,16,41,12,1,16,7,7,5,1,,0,14,2,1,1,int
1897,84086,slab_rebalance_alloc,1,slab_rebalance_alloc,"void* slab_rebalance_alloc (size_t,unsigned int)",slabs.c,"static void *slab_rebalance_alloc(const size_t size, unsigned int id) {
    slabclass_t *s_cls;
    s_cls = &slabclass[slab_rebal.s_clsid];
    int x;
    item *new_it = NULL;

    for (x = 0; x < s_cls->perslab; x++) {
        new_it = do_slabs_alloc(size, id, SLABS_ALLOC_NO_NEWPAGE);
        /* check that memory isn't within the range to clear */
        if (new_it == NULL) {
            break;
        }
        if ((void *)new_it >= slab_rebal.slab_start
            && (void *)new_it < slab_rebal.slab_end) {
            /* Pulled something we intend to free. Mark it as freed since
             * we've already done the work of unlinking it from the freelist.
             */
            new_it->refcount = 0;
            new_it->it_flags = ITEM_SLABBED|ITEM_FETCHED;
#ifdef DEBUG_SLAB_MOVER
            memcpy(ITEM_key(new_it), ""deadbeef"", 8);
#endif
            new_it = NULL;
            slab_rebal.inline_reclaim++;
        } else {
            break;
        }
    }
    return new_i...",789.0,818.0,1.0,42.0,30.0,25,12,23,8,0,3,5,6,1,1,,0,3,4,2,2,void*
1898,84178,slab_rebalance_cut_free,1,slab_rebalance_cut_free,"void slab_rebalance_cut_free (slabclass_t*,item*)",slabs.c,"static void slab_rebalance_cut_free(slabclass_t *s_cls, item *it) {
    /* Ensure this was on the freelist and nothing else. */
    assert(it->it_flags == ITEM_SLABBED);
    if (s_cls->slots == it) {
        s_cls->slots = it->next;
    }
    if (it->next) it->next->prev = it->prev;
    if (it->prev) it->prev->next = it->next;
    s_cls->sl_curr--;
}",822.0,831.0,1.0,27.0,10.0,19,4,12,2,1,3,4,4,1,0,,0,3,4,2,2,void
1899,84251,slab_rebalance_move,1,slab_rebalance_move,int slab_rebalance_move (void),slabs.c,"static int slab_rebalance_move(void) {
    slabclass_t *s_cls;
    int was_busy = 0;
    int refcount = 0;
    uint32_t hv;
    void *hold_lock;
    enum move_status status = MOVE_PASS;

    s_cls = &slabclass[slab_rebal.s_clsid];
    // the offset to check if completed or not
    int offset = ((char*)slab_rebal.slab_pos-(char*)slab_rebal.slab_start)/(s_cls->size);

    // skip acquiring the slabs lock for items we've already fully processed.
    if (slab_rebal.completed[offset] == 0) {
        pthread_mutex_lock(&slabs_lock);
        hv = 0;
        hold_lock = NULL;
        item *it = slab_rebal.slab_pos;

        item_chunk *ch = NULL;
        status = MOVE_PASS;

        if (it->it_flags & ITEM_CHUNK) {
            /* This chunk is a chained part of a larger item. */
            ch = (item_chunk *) it;
            /* Instead, we use the head chunk to find the item and effectively
             * lock the entire structure. If a chunk has ITEM_CHUNK flag, its
             * head ca...",856.0,1107.0,1.0,27.0,252.0,158,22,125,27,0,15,18,38,1,4,,0,10,2,1,1,int
1900,85117,slab_rebalance_finish,1,slab_rebalance_finish,void slab_rebalance_finish (void),slabs.c,"static void slab_rebalance_finish(void) {
    slabclass_t *s_cls;
    slabclass_t *d_cls;
    int x;
    uint32_t rescues;
    uint32_t evictions_nomem;
    uint32_t inline_reclaim;
    uint32_t chunk_rescues;
    uint32_t busy_deletes;

    pthread_mutex_lock(&slabs_lock);

    s_cls = &slabclass[slab_rebal.s_clsid];
    d_cls = &slabclass[slab_rebal.d_clsid];

#ifdef DEBUG_SLAB_MOVER
    /* If the algorithm is broken, live items can sneak in. */
    slab_rebal.slab_pos = slab_rebal.slab_start;
    while (1) {
        item *it = slab_rebal.slab_pos;
        assert(it->it_flags == (ITEM_SLABBED|ITEM_FETCHED));
        assert(memcmp(ITEM_key(it), ""deadbeef"", 8) == 0);
        it->it_flags = ITEM_SLABBED|ITEM_FETCHED;
        slab_rebal.slab_pos = (char *)slab_rebal.slab_pos + s_cls->size;
        if (slab_rebal.slab_pos >= slab_rebal.slab_end)
            break;
    }
#endif

    /* At this point the stolen slab is completely clear.
     * We always kill the ""first""/""oldest"" slab pag...",1109.0,1197.0,1.0,29.0,89.0,86,12,66,18,1,22,4,4,2,1,,0,19,2,1,1,void
1901,85380,slab_rebalance_thread,1,slab_rebalance_thread,void* slab_rebalance_thread (void*),slabs.c,"static void *slab_rebalance_thread(void *arg) {
    int was_busy = 0;
    int backoff_timer = 1;
    int backoff_max = 1000;
    /* So we first pass into cond_wait with the mutex held */
    mutex_lock(&slabs_rebalance_lock);

    /* Must finish moving page before stopping */
    while (slab_rebalance_signal || do_run_slab_rebalance_thread) {
        if (slab_rebalance_signal == 1) {
            if (slab_rebalance_start() < 0) {
                /* Handle errors with more specificity as required. */
                slab_rebalance_signal = 0;
            }

            was_busy = 0;
        } else if (slab_rebalance_signal && slab_rebal.slab_start != NULL) {
            was_busy = slab_rebalance_move();
        }

        if (slab_rebal.done) {
            slab_rebalance_finish();
        } else if (was_busy) {
            /* Stuck waiting for some items to unlock, so slow down a bit
             * to give them a chance to free up */
            usleep(backoff_timer);
            back...",1202.0,1242.0,1.0,4.0,41.0,16,6,17,9,0,9,6,11,2,2,,0,8,2,1,1,void*
1902,85484,slabs_reassign_pick_any,1,slabs_reassign_pick_any,int slabs_reassign_pick_any (int),slabs.c,"static int slabs_reassign_pick_any(int dst) {
    static int cur = POWER_SMALLEST - 1;
    int tries = power_largest - POWER_SMALLEST + 1;
    for (; tries > 0; tries--) {
        cur++;
        if (cur > power_largest)
            cur = POWER_SMALLEST;
        if (cur == dst)
            continue;
        if (slabclass[cur].slabs > 1) {
            return cur;
        }
    }
    return -1;
}",1248.0,1262.0,1.0,21.0,15.0,14,9,13,5,1,3,6,8,2,0,,0,3,2,1,1,int
1903,85547,do_slabs_reassign,1,do_slabs_reassign,"enum reassign_result_type do_slabs_reassign (int,int)",slabs.c,"static enum reassign_result_type do_slabs_reassign(int src, int dst) {
    bool nospare = false;
    if (slab_rebalance_signal != 0)
        return REASSIGN_RUNNING;

    if (src == dst)
        return REASSIGN_SRC_DST_SAME;

    /* Special indicator to choose ourselves. */
    if (src == -1) {
        src = slabs_reassign_pick_any(dst);
        /* TODO: If we end up back at -1, return a new error type */
    }

    if (src < SLAB_GLOBAL_PAGE_POOL || src > power_largest ||
        dst < SLAB_GLOBAL_PAGE_POOL || dst > power_largest)
        return REASSIGN_BADCLASS;

    pthread_mutex_lock(&slabs_lock);
    if (slabclass[src].slabs < 2)
        nospare = true;
    pthread_mutex_unlock(&slabs_lock);
    if (nospare)
        return REASSIGN_NOSPARE;

    slab_rebal.s_clsid = src;
    slab_rebal.d_clsid = dst;

    slab_rebalance_signal = 1;
    pthread_cond_signal(&slab_rebalance_cond);

    return REASSIGN_OK;
}",1264.0,1296.0,1.0,14.0,33.0,25,10,32,16,1,7,7,7,3,1,,0,7,4,2,2,enum reassign_result_type
1904,85645,slabs_reassign,1,slabs_reassign,"enum reassign_result_type slabs_reassign (int,int)",slabs.c,"enum reassign_result_type slabs_reassign(int src, int dst) {
    enum reassign_result_type ret;
    if (pthread_mutex_trylock(&slabs_rebalance_lock) != 0) {
        return REASSIGN_RUNNING;
    }
    ret = do_slabs_reassign(src, dst);
    pthread_mutex_unlock(&slabs_rebalance_lock);
    return ret;
}",1298.0,1306.0,1.0,1.0,9.0,4,3,7,5,3,3,2,2,1,1,,0,3,4,2,2,enum reassign_result_type
1905,85671,slabs_rebalancer_pause,1,slabs_rebalancer_pause,void slabs_rebalancer_pause (void),slabs.c,"void slabs_rebalancer_pause(void) {
    pthread_mutex_lock(&slabs_rebalance_lock);
}",1309.0,1311.0,1.0,1.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,void
1906,85679,slabs_rebalancer_resume,1,slabs_rebalancer_resume,void slabs_rebalancer_resume (void),slabs.c,"void slabs_rebalancer_resume(void) {
    pthread_mutex_unlock(&slabs_rebalance_lock);
}",1313.0,1315.0,1.0,1.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,void
1907,85688,start_slab_maintenance_thread,1,start_slab_maintenance_thread,int start_slab_maintenance_thread (void),slabs.c,"int start_slab_maintenance_thread(void) {
    int ret;
    slab_rebalance_signal = 0;
    slab_rebal.slab_start = NULL;

    if ((ret = pthread_create(&rebalance_tid, NULL,
                              slab_rebalance_thread, NULL)) != 0) {
        fprintf(stderr, ""Can't create rebal thread: %s\n"", strerror(ret));
        return -1;
    }
    return 0;
}",1319.0,1330.0,1.0,1.0,12.0,7,5,9,6,1,1,2,2,1,0,,0,1,2,1,1,int
1908,85724,stop_slab_maintenance_thread,1,stop_slab_maintenance_thread,void stop_slab_maintenance_thread (void),slabs.c,"void stop_slab_maintenance_thread(void) {
    mutex_lock(&slabs_rebalance_lock);
    do_run_slab_rebalance_thread = 0;
    pthread_cond_signal(&slab_rebalance_cond);
    pthread_mutex_unlock(&slabs_rebalance_lock);

    /* Wait for the maintenance thread to stop */
    pthread_join(rebalance_tid, NULL);
}",1334.0,1342.0,1.0,4.0,9.0,5,2,7,5,0,6,1,1,0,0,,0,6,2,1,1,void
1909,85921,stats_prefix_init,1,stats_prefix_init,void stats_prefix_init (char),stats_prefix.c,"void stats_prefix_init(char delimiter) {
    prefix_delimiter = delimiter;
    memset(prefix_stats, 0, sizeof(prefix_stats));
}",16.0,19.0,1.0,1.0,4.0,2,2,4,3,0,3,1,1,0,0,,0,3,2,1,1,void
1910,85934,stats_prefix_clear,1,stats_prefix_clear,void stats_prefix_clear (void),stats_prefix.c,"void stats_prefix_clear(void) {
    int i;

    for (i = 0; i < PREFIX_HASH_SIZE; i++) {
        PREFIX_STATS *cur, *next;
        for (cur = prefix_stats[i]; cur != NULL; cur = next) {
            next = cur->next;
            free(cur->prefix);
            free(cur);
        }
        prefix_stats[i] = NULL;
    }
    num_prefixes = 0;
    total_prefix_size = 0;
}",21.0,35.0,1.0,20.0,15.0,12,5,16,7,7,4,3,4,0,0,,0,4,2,1,1,void
1911,85991,stats_prefix_find,1,stats_prefix_find,"PREFIX_STATS stats_prefix_find (char*,size_t)",stats_prefix.c,"PREFIX_STATS *stats_prefix_find(const char *key, const size_t nkey) {
    PREFIX_STATS *pfs;
    uint32_t hashval;
    size_t length;
    bool bailout = true;

    assert(key != NULL);

    for (length = 0; length < nkey && key[length] != '\0'; length++) {
        if (key[length] == prefix_delimiter) {
            bailout = false;
            break;
        }
    }

    if (bailout) {
        return NULL;
    }

    hashval = hash(key, length) % PREFIX_HASH_SIZE;

    for (pfs = prefix_stats[hashval]; NULL != pfs; pfs = pfs->next) {
        if (strncmp(pfs->prefix, key, length) == 0)
            return pfs;
    }

    pfs = calloc(sizeof(PREFIX_STATS), 1);
    if (NULL == pfs) {
        perror(""Can't allocate space for stats structure: calloc"");
        return NULL;
    }

    pfs->prefix = malloc(length + 1);
    if (NULL == pfs->prefix) {
        perror(""Can't allocate space for copy of prefix: malloc"");
        free(pfs);
        return NULL;
    }

    strncpy(pfs->prefix, key, ...",37.0,87.0,1.0,34.0,51.0,38,12,56,14,13,6,9,10,1,0,,0,6,4,2,2,PREFIX_STATS
1912,86151,stats_prefix_record_get,1,stats_prefix_record_get,"void stats_prefix_record_get (char*,size_t,bool)",stats_prefix.c,"void stats_prefix_record_get(const char *key, const size_t nkey, const bool is_hit) {
    PREFIX_STATS *pfs;

    STATS_LOCK();
    pfs = stats_prefix_find(key, nkey);
    if (NULL != pfs) {
        pfs->num_gets++;
        if (is_hit) {
            pfs->num_hits++;
        }
    }
    STATS_UNLOCK();
}",89.0,101.0,1.0,1.0,13.0,6,4,8,5,7,3,3,4,0,1,,0,1,6,3,3,void
1913,86182,stats_prefix_record_delete,1,stats_prefix_record_delete,"void stats_prefix_record_delete (char*,size_t)",stats_prefix.c,"void stats_prefix_record_delete(const char *key, const size_t nkey) {
    PREFIX_STATS *pfs;

    STATS_LOCK();
    pfs = stats_prefix_find(key, nkey);
    if (NULL != pfs) {
        pfs->num_deletes++;
    }
    STATS_UNLOCK();
}",103.0,112.0,1.0,1.0,10.0,4,4,6,4,6,3,2,2,0,1,,0,1,4,2,2,void
1914,86205,stats_prefix_record_set,1,stats_prefix_record_set,"void stats_prefix_record_set (char*,size_t)",stats_prefix.c,"void stats_prefix_record_set(const char *key, const size_t nkey) {
    PREFIX_STATS *pfs;

    STATS_LOCK();
    pfs = stats_prefix_find(key, nkey);
    if (NULL != pfs) {
        pfs->num_sets++;
    }
    STATS_UNLOCK();
}",114.0,123.0,1.0,1.0,10.0,4,4,6,4,4,3,2,2,0,1,,0,1,4,2,2,void
1915,86228,stats_prefix_dump,1,stats_prefix_dump,char* stats_prefix_dump (int*),stats_prefix.c,"char *stats_prefix_dump(int *length) {
    const char *format = ""PREFIX %s get %llu hit %llu set %llu del %llu\r\n"";
    PREFIX_STATS *pfs;
    char *buf;
    int i, pos;
    size_t size = 0, written = 0;
#ifndef NDEBUG
    size_t total_written = 0;
#endif
    /*
     * Figure out how big the buffer needs to be. This is the sum of the
     * lengths of the prefixes themselves, plus the size of one copy of
     * the per-prefix output with 20-digit values for all the counts,
     * plus space for the ""END"" at the end.
     */
    STATS_LOCK();
    size = strlen(format) + total_prefix_size +
           num_prefixes * (strlen(format) - 2 /* %s */
                           + 4 * (20 - 4)) /* %llu replaced by 20-digit num */
                           + sizeof(""END\r\n"");
    buf = malloc(size);
    if (NULL == buf) {
        perror(""Can't allocate stats response: malloc"");
        STATS_UNLOCK();
        return NULL;
    }

    pos = 0;
    for (i = 0; i < PREFIX_HASH_SIZE; i++) {
    ...",125.0,171.0,1.0,20.0,47.0,37,12,44,13,7,6,4,5,0,0,,0,3,2,1,1,char*
1916,86455,storage_delete,1,storage_delete,"void storage_delete (void*,item*)",storage.h,"void storage_delete(void *e, item *it);",4.0,4.0,6.0,38.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
1917,86461,storage_stats,1,storage_stats,"void storage_stats (ADD_STAT,conn*)",storage.h,"void storage_stats(ADD_STAT add_stats, conn *c);",15.0,15.0,6.0,47.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
1918,86467,process_extstore_stats,1,process_extstore_stats,"void process_extstore_stats (ADD_STAT,conn*)",storage.h,"void process_extstore_stats(ADD_STAT add_stats, conn *c);",16.0,16.0,6.0,56.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
1919,86473,storage_validate_item,1,storage_validate_item,"bool storage_validate_item (void*,item*)",storage.h,"bool storage_validate_item(void *e, item *it);",17.0,17.0,6.0,45.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,bool
1920,86479,storage_get_item,1,storage_get_item,"int storage_get_item (conn*,item*,mc_resp*)",storage.h,"int storage_get_item(conn *c, item *it, mc_resp *resp);",18.0,18.0,5.0,54.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,int
1921,86486,storage_submit_cb,1,storage_submit_cb,void storage_submit_cb (io_queue_t*),storage.h,void storage_submit_cb(io_queue_t *q);,21.0,21.0,6.0,37.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
1922,86491,storage_complete_cb,1,storage_complete_cb,void storage_complete_cb (io_queue_t*),storage.h,void storage_complete_cb(io_queue_t *q);,22.0,22.0,6.0,39.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
1923,86496,storage_finalize_cb,1,storage_finalize_cb,void storage_finalize_cb (io_pending_t*),storage.h,void storage_finalize_cb(io_pending_t *pending);,23.0,23.0,6.0,47.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
1924,86501,start_storage_write_thread,1,start_storage_write_thread,int start_storage_write_thread (void*),storage.h,int start_storage_write_thread(void *arg);,26.0,26.0,5.0,41.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
1925,86506,storage_write_pause,1,storage_write_pause,void storage_write_pause (void),storage.h,void storage_write_pause(void);,27.0,27.0,6.0,30.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
1926,86511,storage_write_resume,1,storage_write_resume,void storage_write_resume (void),storage.h,void storage_write_resume(void);,28.0,28.0,6.0,31.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
1927,86516,start_storage_compact_thread,1,start_storage_compact_thread,int start_storage_compact_thread (void*),storage.h,int start_storage_compact_thread(void *arg);,29.0,29.0,5.0,43.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
1928,86521,storage_compact_pause,1,storage_compact_pause,void storage_compact_pause (void),storage.h,void storage_compact_pause(void);,30.0,30.0,6.0,32.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
1929,86526,storage_compact_resume,1,storage_compact_resume,void storage_compact_resume (void),storage.h,void storage_compact_resume(void);,31.0,31.0,6.0,33.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
1930,86533,storage_init_config,1,storage_init_config,void* storage_init_config (settings*),storage.h,void *storage_init_config(struct settings *s);,35.0,35.0,6.0,45.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void*
1931,86538,storage_read_config,1,storage_read_config,"int storage_read_config (void*,char**)",storage.h,"int storage_read_config(void *conf, char **subopt);",36.0,36.0,5.0,50.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
1932,86544,storage_check_config,1,storage_check_config,int storage_check_config (void*),storage.h,int storage_check_config(void *conf);,37.0,37.0,5.0,36.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
1933,86549,storage_init,1,storage_init,void* storage_init (void*),storage.h,void *storage_init(void *conf);,38.0,38.0,6.0,30.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void*
1934,86699,close_conn,1,close_conn,void close_conn (),testapp.c,"static void close_conn() {
    if (con == NULL) return;
#ifdef TLS
    if (con->ssl) {
        SSL_shutdown(con->ssl);
        SSL_free(con->ssl);
    }
    if (con->ssl_ctx)
        SSL_CTX_free(con->ssl_ctx);
#endif
    if (con->sock > 0) close(con->sock);
    free(con);
    con = NULL;
}",83.0,96.0,1.0,1.0,14.0,5,4,7,2,10,7,3,3,3,0,,0,7,0,0,0,void
1935,86725,cache_create_test,1,cache_create_test,enum test_return cache_create_test (void),testapp.c,"static enum test_return cache_create_test(void)
{
    cache_t *cache = cache_create(""test"", sizeof(uint32_t), sizeof(char*));
    assert(cache != NULL);
    cache_destroy(cache);
    return TEST_PASS;
}",98.0,104.0,1.0,1.0,7.0,4,3,7,5,0,2,1,1,0,2,,0,1,2,1,1,enum test_return
1936,86747,cache_reuse_test,1,cache_reuse_test,enum test_return cache_reuse_test (void),testapp.c,"static enum test_return cache_reuse_test(void)
{
    int ii;
    cache_t *cache = cache_create(""test"", sizeof(uint32_t), sizeof(char*));
    if (cache == NULL) {
        return TEST_FAIL;
    }
    char *ptr = cache_alloc(cache);
    cache_free(cache, ptr);
    for (ii = 0; ii < 100; ++ii) {
        char *p = cache_alloc(cache);
        assert(p == ptr);
        cache_free(cache, ptr);
    }
    cache_destroy(cache);
    return TEST_PASS;
}",106.0,122.0,1.0,1.0,17.0,9,4,20,9,0,6,3,3,0,6,,0,3,2,1,1,enum test_return
1937,86804,cache_bulkalloc,1,cache_bulkalloc,enum test_return cache_bulkalloc (size_t),testapp.c,"static enum test_return cache_bulkalloc(size_t datasize)
{
    cache_t *cache = cache_create(""test"", datasize, sizeof(char*));
    if (cache == NULL) {
        return TEST_FAIL;
    }
#define ITERATIONS 1024
    void *ptr[ITERATIONS];

    for (int ii = 0; ii < ITERATIONS; ++ii) {
        ptr[ii] = cache_alloc(cache);
        assert(ptr[ii] != 0);
        memset(ptr[ii], 0xff, datasize);
    }

    for (int ii = 0; ii < ITERATIONS; ++ii) {
        cache_free(cache, ptr[ii]);
    }

#undef ITERATIONS
    cache_destroy(cache);
    return TEST_PASS;
}",125.0,147.0,1.0,14.0,23.0,13,6,23,8,2,4,4,4,0,4,,0,2,2,1,1,enum test_return
1938,86880,test_issue_161,1,test_issue_161,enum test_return test_issue_161 (void),testapp.c,"static enum test_return test_issue_161(void)
{
    enum test_return ret = cache_bulkalloc(1);
    if (ret == TEST_PASS) {
        ret = cache_bulkalloc(512);
    }

    return ret;
}",149.0,157.0,1.0,1.0,9.0,3,2,5,2,0,2,2,2,0,2,,0,2,2,1,1,enum test_return
1939,86901,cache_redzone_test,1,cache_redzone_test,enum test_return cache_redzone_test (void),testapp.c,"static enum test_return cache_redzone_test(void)
{
#ifndef HAVE_UMEM_H
    cache_t *cache = cache_create(""test"", sizeof(uint32_t), sizeof(char*));

    if (cache == NULL) {
        return TEST_FAIL;
    }
    /* Ignore SIGABRT */
    struct sigaction old_action;
    struct sigaction action = { .sa_handler = SIG_IGN, .sa_flags = 0};
    sigemptyset(&action.sa_mask);
    sigaction(SIGABRT, &action, &old_action);

    /* check memory debug.. */
    char *p = cache_alloc(cache);
    char old = *(p - 1);
    *(p - 1) = 0;
    cache_free(cache, p);
    assert(cache_error == -1);
    *(p - 1) = old;

    p[sizeof(uint32_t)] = 0;
    cache_free(cache, p);
    assert(cache_error == 1);

    /* restore signal handler */
    sigaction(SIGABRT, &old_action, NULL);

    cache_destroy(cache);

    return TEST_PASS;
#else
    return TEST_SKIP;
#endif
}",159.0,194.0,1.0,1.0,36.0,29,10,34,15,0,5,2,2,0,5,,0,2,2,1,1,enum test_return
1940,87000,cache_limit_revised_downward_test,1,cache_limit_revised_downward_test,enum test_return cache_limit_revised_downward_test (void),testapp.c,"static enum test_return cache_limit_revised_downward_test(void)
{
    int limit = 10, allocated_num = limit + 1, i;
    char ** alloc_objs = calloc(allocated_num, sizeof(char *));

    cache_t *cache = cache_create(""test"", sizeof(uint32_t), sizeof(char*));
    assert(cache != NULL);

    /* cache->limit is 0 and we can allocate limit+1 items */
    for (i = 0; i < allocated_num; i++) {
        alloc_objs[i] = cache_alloc(cache);
        assert(alloc_objs[i] != NULL);
    }
    assert(cache->total == allocated_num);

    /* revised downward cache->limit */
    cache_set_limit(cache, limit);

    /* If we free one item, the cache->total should decreased by one*/
    cache_free(cache, alloc_objs[0]);

    assert(cache->total == allocated_num-1);
    cache_destroy(cache);

    free(alloc_objs);

    return TEST_PASS;
}",196.0,223.0,1.0,1.0,28.0,21,9,31,9,0,7,2,2,0,5,,0,4,2,1,1,enum test_return
1941,87087,test_stats_prefix_find,1,test_stats_prefix_find,enum test_return test_stats_prefix_find (void),testapp.c,"static enum test_return test_stats_prefix_find(void) {
    PREFIX_STATS *pfs1, *pfs2;

    stats_prefix_clear();
    pfs1 = stats_prefix_find(""abc"", 3);
    assert(pfs1 == NULL);
    pfs1 = stats_prefix_find(""abc|"", 4);
    assert(pfs1 == NULL);

    pfs1 = stats_prefix_find(""abc:"", 4);
    assert(pfs1 != NULL);
    assert(0ULL == (pfs1->num_gets + pfs1->num_sets + pfs1->num_deletes + pfs1->num_hits));
    pfs2 = stats_prefix_find(""abc:"", 4);
    assert(pfs1 == pfs2);
    pfs2 = stats_prefix_find(""abc:d"", 5);
    assert(pfs1 == pfs2);
    pfs2 = stats_prefix_find(""xyz123:"", 6);
    assert(pfs1 != pfs2);
    pfs2 = stats_prefix_find(""ab:"", 3);
    assert(pfs1 != pfs2);
    return TEST_PASS;
}",225.0,246.0,1.0,1.0,22.0,22,5,26,4,0,8,1,1,0,8,,0,7,2,1,1,enum test_return
1942,87178,test_stats_prefix_record_get,1,test_stats_prefix_record_get,enum test_return test_stats_prefix_record_get (void),testapp.c,"static enum test_return test_stats_prefix_record_get(void) {
    PREFIX_STATS *pfs;
    stats_prefix_clear();

    stats_prefix_record_get(""abc:123"", 7, false);
    pfs = stats_prefix_find(""abc:123"", 7);
    if (pfs == NULL) {
        return TEST_FAIL;
    }
    assert(1 == pfs->num_gets);
    assert(0 == pfs->num_hits);
    stats_prefix_record_get(""abc:456"", 7, false);
    assert(2 == pfs->num_gets);
    assert(0 == pfs->num_hits);
    stats_prefix_record_get(""abc:456"", 7, true);
    assert(3 == pfs->num_gets);
    assert(1 == pfs->num_hits);
    stats_prefix_record_get(""def:"", 4, true);
    assert(3 == pfs->num_gets);
    assert(1 == pfs->num_hits);
    return TEST_PASS;
}",248.0,269.0,1.0,1.0,22.0,18,3,17,6,0,6,2,2,0,6,,0,1,2,1,1,enum test_return
1943,87263,test_stats_prefix_record_delete,1,test_stats_prefix_record_delete,enum test_return test_stats_prefix_record_delete (void),testapp.c,"static enum test_return test_stats_prefix_record_delete(void) {
    PREFIX_STATS *pfs;
    stats_prefix_clear();

    stats_prefix_record_delete(""abc:123"", 7);
    pfs = stats_prefix_find(""abc:123"", 7);
    if (pfs == NULL) {
        return TEST_FAIL;
    }
    assert(0 == pfs->num_gets);
    assert(0 == pfs->num_hits);
    assert(1 == pfs->num_deletes);
    assert(0 == pfs->num_sets);
    stats_prefix_record_delete(""def:"", 4);
    assert(1 == pfs->num_deletes);
    return TEST_PASS;
}",271.0,287.0,1.0,1.0,17.0,12,3,10,4,0,4,2,2,0,4,,0,1,2,1,1,enum test_return
1944,87320,test_stats_prefix_record_set,1,test_stats_prefix_record_set,enum test_return test_stats_prefix_record_set (void),testapp.c,"static enum test_return test_stats_prefix_record_set(void) {
    PREFIX_STATS *pfs;
    stats_prefix_clear();

    stats_prefix_record_set(""abc:123"", 7);
    pfs = stats_prefix_find(""abc:123"", 7);
    if (pfs == NULL) {
        return TEST_FAIL;
    }
    assert(0 == pfs->num_gets);
    assert(0 == pfs->num_hits);
    assert(0 == pfs->num_deletes);
    assert(1 == pfs->num_sets);
    stats_prefix_record_delete(""def:"", 4);
    assert(1 == pfs->num_sets);
    return TEST_PASS;
}",289.0,305.0,1.0,1.0,17.0,12,3,10,4,0,4,2,2,0,4,,0,1,2,1,1,enum test_return
1945,87377,test_stats_prefix_dump,1,test_stats_prefix_dump,enum test_return test_stats_prefix_dump (void),testapp.c,"static enum test_return test_stats_prefix_dump(void) {
    int hashval = hash(""abc"", 3) % PREFIX_HASH_SIZE;
    char tmp[500];
    char *buf;
    const char *expected;
    int keynum;
    int length;

    stats_prefix_clear();

    assert(strcmp(""END\r\n"", (buf = stats_prefix_dump(&length))) == 0);
    assert(5 == length);
    stats_prefix_record_set(""abc:123"", 7);
    free(buf);
    expected = ""PREFIX abc get 0 hit 0 set 1 del 0\r\nEND\r\n"";
    assert(strcmp(expected, (buf = stats_prefix_dump(&length))) == 0);
    assert(strlen(expected) == length);
    stats_prefix_record_get(""abc:123"", 7, false);
    free(buf);
    expected = ""PREFIX abc get 1 hit 0 set 1 del 0\r\nEND\r\n"";
    assert(strcmp(expected, (buf = stats_prefix_dump(&length))) == 0);
    assert(strlen(expected) == length);
    stats_prefix_record_get(""abc:123"", 7, true);
    free(buf);
    expected = ""PREFIX abc get 2 hit 1 set 1 del 0\r\nEND\r\n"";
    assert(strcmp(expected, (buf = stats_prefix_dump(&length))) == 0);
...",307.0,374.0,1.0,35.0,68.0,47,9,75,11,0,15,4,4,0,15,,0,7,2,1,1,enum test_return
1946,87625,test_safe_strtoul,1,test_safe_strtoul,enum test_return test_safe_strtoul (void),testapp.c,"static enum test_return test_safe_strtoul(void) {
    uint32_t val;
    assert(safe_strtoul(""123"", &val));
    assert(val == 123);
    assert(safe_strtoul(""+123"", &val));
    assert(val == 123);
    assert(!safe_strtoul("""", &val));  // empty
    assert(!safe_strtoul(""123BOGUS"", &val));  // non-numeric
    assert(!safe_strtoul("" issue221"", &val));  // non-numeric
    /* Not sure what it does, but this works with ICC :/
       assert(!safe_strtoul(""92837498237498237498029383"", &val)); // out of range
    */

    // extremes:
    assert(safe_strtoul(""4294967295"", &val)); // 2**32 - 1
    assert(val == 4294967295L);
    /* This actually works on 64-bit ubuntu
       assert(!safe_strtoul(""4294967296"", &val)); // 2**32
    */
    assert(!safe_strtoul(""-1"", &val));  // negative
    return TEST_PASS;
}",376.0,397.0,1.0,1.0,22.0,14,3,11,2,0,7,1,1,0,7,,0,0,2,1,1,enum test_return
1947,87684,test_safe_strtoull,1,test_safe_strtoull,enum test_return test_safe_strtoull (void),testapp.c,"static enum test_return test_safe_strtoull(void) {
    uint64_t val;
    assert(safe_strtoull(""123"", &val));
    assert(val == 123);
    assert(safe_strtoull(""+123"", &val));
    assert(val == 123);
    assert(!safe_strtoull("""", &val));  // empty
    assert(!safe_strtoull(""123BOGUS"", &val));  // non-numeric
    assert(!safe_strtoull(""92837498237498237498029383"", &val)); // out of range
    assert(!safe_strtoull("" issue221"", &val));  // non-numeric

    // extremes:
    assert(safe_strtoull(""18446744073709551615"", &val)); // 2**64 - 1
    assert(val == 18446744073709551615ULL);
    assert(!safe_strtoull(""18446744073709551616"", &val)); // 2**64
    assert(!safe_strtoull(""-1"", &val));  // negative
    return TEST_PASS;
}",400.0,417.0,1.0,1.0,18.0,18,3,13,2,0,9,1,1,0,9,,0,0,2,1,1,enum test_return
1948,87755,test_safe_strtoll,1,test_safe_strtoll,enum test_return test_safe_strtoll (void),testapp.c,"static enum test_return test_safe_strtoll(void) {
    int64_t val;
    assert(safe_strtoll(""123"", &val));
    assert(val == 123);
    assert(safe_strtoll(""+123"", &val));
    assert(val == 123);
    assert(safe_strtoll(""-123"", &val));
    assert(val == -123);
    assert(!safe_strtoll("""", &val));  // empty
    assert(!safe_strtoll(""123BOGUS"", &val));  // non-numeric
    assert(!safe_strtoll(""92837498237498237498029383"", &val)); // out of range
    assert(!safe_strtoll("" issue221"", &val));  // non-numeric

    // extremes:
    assert(!safe_strtoll(""18446744073709551615"", &val)); // 2**64 - 1
    assert(safe_strtoll(""9223372036854775807"", &val)); // 2**63 - 1
    assert(val == 9223372036854775807LL);
    /*
      assert(safe_strtoll(""-9223372036854775808"", &val)); // -2**63
      assert(val == -9223372036854775808LL);
    */
    assert(!safe_strtoll(""-9223372036854775809"", &val)); // -2**63 - 1

    // We'll allow space to terminate the string.  And leading space.
    assert(safe_strtol...",419.0,446.0,1.0,1.0,28.0,23,4,17,2,0,11,1,1,0,11,,0,0,2,1,1,enum test_return
1949,87845,test_safe_strtol,1,test_safe_strtol,enum test_return test_safe_strtol (void),testapp.c,"static enum test_return test_safe_strtol(void) {
    int32_t val;
    assert(safe_strtol(""123"", &val));
    assert(val == 123);
    assert(safe_strtol(""+123"", &val));
    assert(val == 123);
    assert(safe_strtol(""-123"", &val));
    assert(val == -123);
    assert(!safe_strtol("""", &val));  // empty
    assert(!safe_strtol(""123BOGUS"", &val));  // non-numeric
    assert(!safe_strtol(""92837498237498237498029383"", &val)); // out of range
    assert(!safe_strtol("" issue221"", &val));  // non-numeric

    // extremes:
    /* This actually works on 64-bit ubuntu
       assert(!safe_strtol(""2147483648"", &val)); // (expt 2.0 31.0)
    */
    assert(safe_strtol(""2147483647"", &val)); // (- (expt 2.0 31) 1)
    assert(val == 2147483647L);
    /* This actually works on 64-bit ubuntu
       assert(!safe_strtol(""-2147483649"", &val)); // (- (expt -2.0 31) 1)
    */

    // We'll allow space to terminate the string.  And leading space.
    assert(safe_strtol("" 123 foo"", &val));
    assert(val == 123...",448.0,475.0,1.0,1.0,28.0,19,4,15,2,0,9,1,1,0,9,,0,0,2,1,1,enum test_return
1950,87923,start_server,1,start_server,"pid_t start_server (in_port_t*,bool,int)",testapp.c,"static pid_t start_server(in_port_t *port_out, bool daemon, int timeout) {
    char environment[80];
    snprintf(environment, sizeof(environment),
             ""MEMCACHED_PORT_FILENAME=/tmp/ports.%lu"", (long)getpid());
    char *filename= environment + strlen(""MEMCACHED_PORT_FILENAME="");
    char pid_file[80];
    snprintf(pid_file, sizeof(pid_file), ""/tmp/pid.%lu"", (long)getpid());

    remove(filename);
    remove(pid_file);

#ifdef __sun
    /* I want to name the corefiles differently so that they don't
       overwrite each other
    */
    char coreadm[128];
    snprintf(coreadm, sizeof(coreadm),
             ""coreadm -p core.%%f.%%p %lu"", (unsigned long)getpid());
    system(coreadm);
#endif

    pid_t pid = fork();
    assert(pid != -1);
    if (pid == 0) {
        /* Child */
        char *argv[24];
        int arg = 0;
        char tmo[24];
        snprintf(tmo, sizeof(tmo), ""%u"", timeout);

        putenv(environment);
#ifdef __sun
        putenv(""LD_PRELOAD=watchmalloc.s...",486.0,622.0,1.0,1.0,137.0,97,19,108,22,3,2,14,21,0,2,,0,0,6,3,3,pid_t
1951,88267,test_issue_44,1,test_issue_44,enum test_return test_issue_44 (void),testapp.c,"static enum test_return test_issue_44(void) {
    in_port_t port;
    pid_t pid = start_server(&port, true, 600);
    assert(kill(pid, SIGHUP) == 0);
    sleep(1);
    assert(kill(pid, SIGTERM) == 0);

    return TEST_PASS;
}",624.0,632.0,1.0,1.0,9.0,4,3,8,6,0,1,1,1,0,1,,0,1,2,1,1,enum test_return
1952,88297,lookuphost,1,lookuphost,"struct addrinfo lookuphost (char*,in_port_t)",testapp.c,"static struct addrinfo *lookuphost(const char *hostname, in_port_t port)
{
    struct addrinfo *ai = 0;
    struct addrinfo hints = { .ai_family = AF_UNSPEC,
                              .ai_protocol = IPPROTO_TCP,
                              .ai_socktype = SOCK_STREAM };
    char service[NI_MAXSERV];
    int error;

    (void)snprintf(service, NI_MAXSERV, ""%d"", port);
    if ((error = getaddrinfo(hostname, service, &hints, &ai)) != 0) {
       if (error != EAI_SYSTEM) {
          fprintf(stderr, ""getaddrinfo(): %s\n"", gai_strerror(error));
       } else {
          perror(""getaddrinfo()"");
       }
    }

    return ai;
}",634.0,653.0,1.0,1.0,20.0,12,5,21,15,1,0,3,4,0,0,,0,0,4,2,2,struct addrinfo
1953,88361,connect_server,1,connect_server,"struct conn connect_server (char*,in_port_t,bool,bool)",testapp.c,"static struct conn *connect_server(const char *hostname, in_port_t port,
                            bool nonblock, const bool ssl)
{
    struct conn *c;
    if (!(c = (struct conn *)calloc(1, sizeof(struct conn)))) {
        fprintf(stderr, ""Failed to allocate the client connection: %s\n"",
                strerror(errno));
        return NULL;
    }

    struct addrinfo *ai = lookuphost(hostname, port);
    int sock = -1;
    if (ai != NULL) {
       if ((sock = socket(ai->ai_family, ai->ai_socktype,
                          ai->ai_protocol)) != -1) {
          if (connect(sock, ai->ai_addr, ai->ai_addrlen) == -1) {
             fprintf(stderr, ""Failed to connect socket: %s\n"",
                     strerror(errno));
             close(sock);
             sock = -1;
          } else if (nonblock) {
              int flags = fcntl(sock, F_GETFL, 0);
              if (flags < 0 || fcntl(sock, F_SETFL, flags | O_NONBLOCK) < 0) {
                  fprintf(stderr, ""Failed to enable nonb...",655.0,727.0,1.0,1.0,73.0,26,8,28,9,9,2,5,8,0,1,,0,2,8,4,4,struct conn
1954,88509,test_vperror,1,test_vperror,enum test_return test_vperror (void),testapp.c,"static enum test_return test_vperror(void) {
    int rv = 0;
    int oldstderr = dup(STDERR_FILENO);
    assert(oldstderr >= 0);
    char tmpl[sizeof(TMP_TEMPLATE)+1];
    strncpy(tmpl, TMP_TEMPLATE, sizeof(TMP_TEMPLATE)+1);

    int newfile = mkstemp(tmpl);
    assert(newfile > 0);
    rv = dup2(newfile, STDERR_FILENO);
    assert(rv == STDERR_FILENO);
    rv = close(newfile);
    assert(rv == 0);

    errno = EIO;
    vperror(""Old McDonald had a farm.  %s"", ""EI EIO"");

    /* Restore stderr */
    rv = dup2(oldstderr, STDERR_FILENO);
    assert(rv == STDERR_FILENO);


    /* Go read the file */
    char buf[80] = { 0 };
    FILE *efile = fopen(tmpl, ""r"");
    assert(efile);
    char *prv = fgets(buf, sizeof(buf), efile);
    assert(prv);
    fclose(efile);

    unlink(tmpl);

    char expected[80] = { 0 };
    snprintf(expected, sizeof(expected),
             ""Old McDonald had a farm.  EI EIO: %s\n"", strerror(EIO));

    /*
    fprintf(stderr,
            ""\nExpected:  ``%s''""
   ...",729.0,772.0,1.0,21.0,44.0,24,8,42,13,0,1,1,1,0,1,,0,0,2,1,1,enum test_return
1955,88628,send_ascii_command,1,send_ascii_command,void send_ascii_command (char*),testapp.c,"static void send_ascii_command(const char *buf) {
    off_t offset = 0;
    const char* ptr = buf;
    size_t len = strlen(buf);

    do {
        ssize_t nw = con->write((void*)con, ptr + offset, len - offset);
        if (nw == -1) {
            if (errno != EINTR) {
                fprintf(stderr, ""Failed to write: %s\n"", strerror(errno));
                abort();
            }
        } else {
            offset += nw;
        }
    } while (offset < len);
}",774.0,790.0,1.0,1.0,17.0,12,9,19,9,9,3,4,7,0,1,,0,3,2,1,1,void
1956,88689,read_ascii_response,1,read_ascii_response,"void read_ascii_response (char*,size_t)",testapp.c,"static void read_ascii_response(char *buffer, size_t size) {
    off_t offset = 0;
    bool need_more = true;
    do {
        ssize_t nr = con->read(con, buffer + offset, 1);
        if (nr == -1) {
            if (errno != EINTR) {
                fprintf(stderr, ""Failed to read: %s\n"", strerror(errno));
                abort();
            }
        } else {
            assert(nr == 1);
            if (buffer[offset] == '\n') {
                need_more = false;
                buffer[offset + 1] = '\0';
            }
            offset += nr;
            assert(offset + 1 < size);
        }
    } while (need_more);
}",798.0,818.0,1.0,1.0,21.0,8,6,14,9,4,3,4,7,0,1,,0,3,4,2,2,void
1957,88767,test_issue_92,1,test_issue_92,enum test_return test_issue_92 (void),testapp.c,"static enum test_return test_issue_92(void) {
    char buffer[1024];

    close_conn();
    con = connect_server(""127.0.0.1"", port, false, enable_ssl);
    assert(con);

    send_ascii_command(""stats cachedump 1 0 0\r\n"");

    read_ascii_response(buffer, sizeof(buffer));
    assert(strncmp(buffer, ""END"", strlen(""END"")) == 0);

    send_ascii_command(""stats cachedump 200 0 0\r\n"");
    read_ascii_response(buffer, sizeof(buffer));
    assert(strncmp(buffer, ""CLIENT_ERROR"", strlen(""CLIENT_ERROR"")) == 0);

    close_conn();
    con = connect_server(""127.0.0.1"", port, false, enable_ssl);
    assert(con);
    return TEST_PASS;
}",820.0,840.0,1.0,1.0,21.0,6,3,17,6,0,16,1,1,0,6,,0,10,2,1,1,enum test_return
1958,88823,test_crc32c,1,test_crc32c,enum test_return test_crc32c (void),testapp.c,"static enum test_return test_crc32c(void) {
    uint32_t crc_hw, crc_sw;

    char buffer[256];
    for (int x = 0; x < 256; x++)
        buffer[x] = x;

    /* Compare hardware to software implementation */
    crc_hw = crc32c(0, buffer, 256);
    crc_sw = crc32c_sw(0, buffer, 256);
    assert(crc_hw == 0x9c44184b);
    assert(crc_sw == 0x9c44184b);

    /* Test that passing a CRC in also works */
    crc_hw = crc32c(crc_hw, buffer, 256);
    crc_sw = crc32c_sw(crc_sw, buffer, 256);
    assert(crc_hw == 0xae10ee5a);
    assert(crc_sw == 0xae10ee5a);

    /* Test odd offsets/sizes */
    crc_hw = crc32c(crc_hw, buffer + 1, 256 - 2);
    crc_sw = crc32c_sw(crc_sw, buffer + 1, 256 - 2);
    assert(crc_hw == 0xed37b906);
    assert(crc_sw == 0xed37b906);

    return TEST_PASS;
}",842.0,868.0,1.0,1.0,27.0,18,5,25,5,0,3,2,2,0,3,,0,3,2,1,1,enum test_return
1959,88917,test_issue_102,1,test_issue_102,enum test_return test_issue_102 (void),testapp.c,"static enum test_return test_issue_102(void) {
    char buffer[4096];
    memset(buffer, ' ', sizeof(buffer));
    buffer[sizeof(buffer) - 1] = '\0';

    close_conn();
    con = connect_server(""127.0.0.1"", port, false, enable_ssl);
    assert(con);

    send_ascii_command(buffer);
    /* verify that the server closed the connection */
    assert(con->read(con, buffer, sizeof(buffer)) == 0);

    close_conn();
    con = connect_server(""127.0.0.1"", port, false, enable_ssl);
    assert(con);

    snprintf(buffer, sizeof(buffer), ""gets "");
    size_t offset = 5;
    while (offset < 4000) {
        offset += snprintf(buffer + offset, sizeof(buffer) - offset,
                           ""%010u "", (unsigned int)offset);
    }

    send_ascii_command(buffer);
    usleep(250);

    send_ascii_command(""\r\n"");
    char rsp[80];
    read_ascii_response(rsp, sizeof(rsp));
    assert(strncmp(rsp, ""END"", strlen(""END"")) == 0);
    buffer[3]= ' ';
    send_ascii_command(buffer);
    usleep(250);
  ...",870.0,921.0,1.0,1.0,52.0,40,10,58,9,0,32,2,2,0,13,,0,19,2,1,1,enum test_return
1960,89096,start_memcached_server,1,start_memcached_server,enum test_return start_memcached_server (void),testapp.c,"static enum test_return start_memcached_server(void) {
    server_pid = start_server(&port, false, 600);
    close_conn();
    con = connect_server(""127.0.0.1"", port, false, enable_ssl);
    assert(con);
    return TEST_PASS;
}",923.0,929.0,1.0,1.0,7.0,3,2,9,6,0,9,1,1,0,2,,0,8,2,1,1,enum test_return
1961,89120,stop_memcached_server,1,stop_memcached_server,enum test_return stop_memcached_server (void),testapp.c,"static enum test_return stop_memcached_server(void) {
    close_conn();
    if (server_pid != -1) {
        assert(kill(server_pid, SIGTERM) == 0);
    }

    return TEST_PASS;
}",931.0,938.0,1.0,1.0,8.0,3,3,4,3,0,3,2,2,1,0,,0,2,2,1,1,enum test_return
1962,89140,shutdown_memcached_server,1,shutdown_memcached_server,enum test_return shutdown_memcached_server (void),testapp.c,"static enum test_return shutdown_memcached_server(void) {
    char buffer[1024];

    close_conn();
    con = connect_server(""127.0.0.1"", port, false, enable_ssl);
    assert(con);

    send_ascii_command(""shutdown\r\n"");
    /* verify that the server closed the connection */
    assert(con->read(con, buffer, sizeof(buffer)) == 0);

    close_conn();

    /* We set server_pid to -1 so that we don't later call kill() */
    if (kill(server_pid, 0) == 0) {
        server_pid = -1;
    }

    return TEST_PASS;
}",940.0,959.0,1.0,1.0,20.0,7,5,12,7,0,13,2,2,1,3,,0,9,2,1,1,enum test_return
1963,89183,safe_send,1,safe_send,"void safe_send (void*,size_t,bool)",testapp.c,"static void safe_send(const void* buf, size_t len, bool hickup)
{
    off_t offset = 0;
    const char* ptr = buf;
#ifdef MESSAGE_DEBUG
    uint8_t val = *ptr;
    assert(val == (uint8_t)0x80);
    fprintf(stderr, ""About to send %lu bytes:"", (unsigned long)len);
    for (int ii = 0; ii < len; ++ii) {
        if (ii % 4 == 0) {
            fprintf(stderr, ""\n   "");
        }
        val = *(ptr + ii);
        fprintf(stderr, "" 0x%02x"", val);
    }
    fprintf(stderr, ""\n"");
    usleep(500);
#endif

    do {
        size_t num_bytes = len - offset;
        if (hickup) {
            if (num_bytes > 1024) {
                num_bytes = (rand() % 1023) + 1;
            }
        }
        ssize_t nw = con->write(con, ptr + offset, num_bytes);
        if (nw == -1) {
            if (errno != EINTR) {
                fprintf(stderr, ""Failed to write: %s\n"", strerror(errno));
                abort();
            }
        } else {
            if (hickup) {
                usleep(100);
      ...",961.0,1000.0,1.0,1.0,40.0,15,10,22,11,35,3,6,12,0,1,,0,3,6,3,3,void
1964,89263,safe_recv,1,safe_recv,"bool safe_recv (void*,size_t)",testapp.c,"static bool safe_recv(void *buf, size_t len) {
    if (len == 0) {
        return true;
    }
    off_t offset = 0;
    do {
        ssize_t nr = con->read(con, ((char*)buf) + offset, len - offset);
        if (nr == -1) {
            if (errno != EINTR) {
                fprintf(stderr, ""Failed to read: %s\n"", strerror(errno));
                abort();
            }
        } else {
            if (nr == 0 && allow_closed_read) {
                return false;
            }
            assert(nr != 0);
            offset += nr;
        }
    } while (offset < len);

    return true;
}",1002.0,1024.0,1.0,1.0,23.0,11,9,18,9,2,3,5,8,0,1,,0,3,4,2,2,bool
1965,89338,safe_recv_packet,1,safe_recv_packet,"bool safe_recv_packet (void*,size_t)",testapp.c,"static bool safe_recv_packet(void *buf, size_t size) {
    protocol_binary_response_no_extras *response = buf;
    assert(size > sizeof(*response));
    if (!safe_recv(response, sizeof(*response))) {
        return false;
    }
    response->message.header.response.keylen = ntohs(response->message.header.response.keylen);
    response->message.header.response.status = ntohs(response->message.header.response.status);
    response->message.header.response.bodylen = ntohl(response->message.header.response.bodylen);

    size_t len = sizeof(*response);

    char *ptr = buf;
    ptr += len;
    if (!safe_recv(ptr, response->message.header.response.bodylen)) {
        return false;
    }

#ifdef MESSAGE_DEBUG
    usleep(500);
    ptr = buf;
    len += response->message.header.response.bodylen;
    uint8_t val = *ptr;
    assert(val == (uint8_t)0x81);
    fprintf(stderr, ""Received %lu bytes:"", (unsigned long)len);
    for (int ii = 0; ii < len; ++ii) {
        if (ii % 4 == 0) {
          ...",1026.0,1061.0,1.0,1.0,36.0,44,8,23,7,35,2,3,3,2,2,,0,2,4,2,2,bool
1966,89455,storage_command,1,storage_command,"off_t storage_command (char*,size_t,uint8_t,void*,size_t,void*,size_t,uint32_t,uint32_t)",testapp.c,"static off_t storage_command(char*buf,
                             size_t bufsz,
                             uint8_t cmd,
                             const void* key,
                             size_t keylen,
                             const void* dta,
                             size_t dtalen,
                             uint32_t flags,
                             uint32_t exp) {
    /* all of the storage commands use the same command layout */
    protocol_binary_request_set *request = (void*)buf;
    assert(bufsz > sizeof(*request) + keylen + dtalen);

    memset(request, 0, sizeof(*request));
    request->message.header.request.magic = PROTOCOL_BINARY_REQ;
    request->message.header.request.opcode = cmd;
    request->message.header.request.keylen = htons(keylen);
    request->message.header.request.extlen = 8;
    request->message.header.request.bodylen = htonl(keylen + 8 + dtalen);
    request->message.header.request.opaque = 0xdeadbeef;
    request->message.body.fla...",1063.0,1094.0,1.0,1.0,32.0,58,9,39,14,12,8,2,2,0,0,,0,8,18,9,9,off_t
1967,89612,ext_command,1,ext_command,"off_t ext_command (char*,size_t,uint8_t,void*,size_t,void*,size_t,void*,size_t)",testapp.c,"static off_t ext_command(char* buf,
                         size_t bufsz,
                         uint8_t cmd,
                         const void* ext,
                         size_t extlen,
                         const void* key,
                         size_t keylen,
                         const void* dta,
                         size_t dtalen) {
    protocol_binary_request_no_extras *request = (void*)buf;
    assert(bufsz > sizeof(*request) + extlen + keylen + dtalen);

    memset(request, 0, sizeof(*request));
    request->message.header.request.magic = PROTOCOL_BINARY_REQ;
    request->message.header.request.opcode = cmd;
    request->message.header.request.extlen = extlen;
    request->message.header.request.keylen = htons(keylen);
    request->message.header.request.bodylen = htonl(extlen + keylen + dtalen);
    request->message.header.request.opaque = 0xdeadbeef;

    off_t ext_offset = sizeof(protocol_binary_request_no_extras);
    off_t key_offset = ext_offset + ...",1096.0,1131.0,1.0,1.0,36.0,59,9,52,16,5,0,4,4,0,0,,0,0,18,9,9,off_t
1968,89781,raw_command,1,raw_command,"off_t raw_command (char*,size_t,uint8_t,void*,size_t,void*,size_t)",testapp.c,"static off_t raw_command(char* buf,
                         size_t bufsz,
                         uint8_t cmd,
                         const void* key,
                         size_t keylen,
                         const void* dta,
                         size_t dtalen) {
    /* all of the storage commands use the same command layout */
    return ext_command(buf, bufsz, cmd, NULL, 0, key, keylen, dta, dtalen);
}",1133.0,1142.0,1.0,1.0,10.0,0,0,8,8,21,1,1,1,0,1,,0,0,14,7,7,off_t
1969,89803,flush_command,1,flush_command,"off_t flush_command (char*,size_t,uint8_t,uint32_t,bool)",testapp.c,"static off_t flush_command(char* buf, size_t bufsz, uint8_t cmd, uint32_t exptime, bool use_extra) {
    protocol_binary_request_flush *request = (void*)buf;
    assert(bufsz > sizeof(*request));

    memset(request, 0, sizeof(*request));
    request->message.header.request.magic = PROTOCOL_BINARY_REQ;
    request->message.header.request.opcode = cmd;

    off_t size = sizeof(protocol_binary_request_no_extras);
    if (use_extra) {
        request->message.header.request.extlen = 4;
        request->message.body.expiration = htonl(exptime);
        request->message.header.request.bodylen = htonl(4);
        size += 4;
    }

    request->message.header.request.opaque = 0xdeadbeef;

    return size;
}",1144.0,1163.0,1.0,1.0,20.0,39,8,20,9,2,0,2,2,0,0,,0,0,10,5,5,off_t
1970,89909,touch_command,1,touch_command,"off_t touch_command (char*,size_t,uint8_t,void*,size_t,uint32_t)",testapp.c,"static off_t touch_command(char* buf,
                           size_t bufsz,
                           uint8_t cmd,
                           const void* key,
                           size_t keylen,
                           uint32_t exptime) {
    protocol_binary_request_touch *request = (void*)buf;
    assert(bufsz > sizeof(*request));

    memset(request, 0, sizeof(*request));
    request->message.header.request.magic = PROTOCOL_BINARY_REQ;
    request->message.header.request.opcode = cmd;

    request->message.header.request.keylen = htons(keylen);
    request->message.header.request.extlen = 4;
    request->message.body.expiration = htonl(exptime);
    request->message.header.request.bodylen = htonl(keylen + 4);

    request->message.header.request.opaque = 0xdeadbeef;

    off_t key_offset = sizeof(protocol_binary_request_no_extras) + 4;

    memcpy(buf + key_offset, key, keylen);
    return sizeof(protocol_binary_request_no_extras) + 4 + keylen;
}",1166.0,1190.0,1.0,1.0,25.0,49,8,26,10,1,0,1,1,0,0,,0,0,12,6,6,off_t
1971,90037,arithmetic_command,1,arithmetic_command,"off_t arithmetic_command (char*,size_t,uint8_t,void*,size_t,uint64_t,uint64_t,uint32_t)",testapp.c,"static off_t arithmetic_command(char* buf,
                                size_t bufsz,
                                uint8_t cmd,
                                const void* key,
                                size_t keylen,
                                uint64_t delta,
                                uint64_t initial,
                                uint32_t exp) {
    protocol_binary_request_incr *request = (void*)buf;
    assert(bufsz > sizeof(*request) + keylen);

    memset(request, 0, sizeof(*request));
    request->message.header.request.magic = PROTOCOL_BINARY_REQ;
    request->message.header.request.opcode = cmd;
    request->message.header.request.keylen = htons(keylen);
    request->message.header.request.extlen = 20;
    request->message.header.request.bodylen = htonl(keylen + 20);
    request->message.header.request.opaque = 0xdeadbeef;
    request->message.body.delta = htonll(delta);
    request->message.body.initial = htonll(initial);
    request->message.body....",1192.0,1218.0,1.0,1.0,27.0,56,8,31,12,3,2,1,1,0,2,,0,2,16,8,8,off_t
1972,90186,validate_response_header,1,validate_response_header,"void validate_response_header (protocol_binary_response_no_extras*,uint8_t,uint16_t)",testapp.c,"static void validate_response_header(protocol_binary_response_no_extras *response,
                                     uint8_t cmd, uint16_t status)
{
    assert(response->message.header.response.magic == PROTOCOL_BINARY_RES);
    assert(response->message.header.response.opcode == cmd);
    assert(response->message.header.response.datatype == PROTOCOL_BINARY_RAW_BYTES);
    assert(response->message.header.response.status == status);
    assert(response->message.header.response.opaque == 0xdeadbeef);

    if (status == PROTOCOL_BINARY_RESPONSE_SUCCESS) {
        switch (cmd) {
        case PROTOCOL_BINARY_CMD_ADDQ:
        case PROTOCOL_BINARY_CMD_APPENDQ:
        case PROTOCOL_BINARY_CMD_DECREMENTQ:
        case PROTOCOL_BINARY_CMD_DELETEQ:
        case PROTOCOL_BINARY_CMD_FLUSHQ:
        case PROTOCOL_BINARY_CMD_INCREMENTQ:
        case PROTOCOL_BINARY_CMD_PREPENDQ:
        case PROTOCOL_BINARY_CMD_QUITQ:
        case PROTOCOL_BINARY_CMD_REPLACEQ:
        case PROTOCOL_BINARY_CMD_...",1220.0,1318.0,1.0,1.0,99.0,147,4,69,38,35,0,13,6,0,0,,0,0,6,3,3,void
1973,90676,test_binary_noop,1,test_binary_noop,enum test_return test_binary_noop (void),testapp.c,"static enum test_return test_binary_noop(void) {
    union {
        protocol_binary_request_no_extras request;
        protocol_binary_response_no_extras response;
        char bytes[1024];
    } buffer;

    size_t len = raw_command(buffer.bytes, sizeof(buffer.bytes),
                             PROTOCOL_BINARY_CMD_NOOP,
                             NULL, 0, NULL, 0);

    safe_send(buffer.bytes, len, false);
    safe_recv_packet(buffer.bytes, sizeof(buffer.bytes));
    validate_response_header(&buffer.response, PROTOCOL_BINARY_CMD_NOOP,
                             PROTOCOL_BINARY_RESPONSE_SUCCESS);

    return TEST_PASS;
}",1320.0,1337.0,1.0,1.0,18.0,10,4,15,7,3,4,1,1,0,4,,0,1,2,1,1,enum test_return
1974,90721,test_binary_quit_impl,1,test_binary_quit_impl,enum test_return test_binary_quit_impl (uint8_t),testapp.c,"static enum test_return test_binary_quit_impl(uint8_t cmd) {
    union {
        protocol_binary_request_no_extras request;
        protocol_binary_response_no_extras response;
        char bytes[1024];
    } buffer;
    size_t len = raw_command(buffer.bytes, sizeof(buffer.bytes),
                             cmd, NULL, 0, NULL, 0);

    safe_send(buffer.bytes, len, false);
    if (cmd == PROTOCOL_BINARY_CMD_QUIT) {
        safe_recv_packet(buffer.bytes, sizeof(buffer.bytes));
        validate_response_header(&buffer.response, PROTOCOL_BINARY_CMD_QUIT,
                                 PROTOCOL_BINARY_RESPONSE_SUCCESS);
    }

    /* Socket should be closed now, read should return 0 */
    assert(con->read(con, buffer.bytes, sizeof(buffer.bytes)) == 0);
    close_conn();
    con = connect_server(""127.0.0.1"", port, false, enable_ssl);
    assert(con);

    return TEST_PASS;
}",1339.0,1362.0,1.0,1.0,24.0,17,6,26,11,2,13,2,2,0,6,,0,8,2,1,1,enum test_return
1975,90796,test_binary_quit,1,test_binary_quit,enum test_return test_binary_quit (void),testapp.c,"static enum test_return test_binary_quit(void) {
    return test_binary_quit_impl(PROTOCOL_BINARY_CMD_QUIT);
}",1364.0,1366.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,enum test_return
1976,90804,test_binary_quitq,1,test_binary_quitq,enum test_return test_binary_quitq (void),testapp.c,"static enum test_return test_binary_quitq(void) {
    return test_binary_quit_impl(PROTOCOL_BINARY_CMD_QUITQ);
}",1368.0,1370.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,enum test_return
1977,90812,test_binary_set_impl,1,test_binary_set_impl,"enum test_return test_binary_set_impl (char*,uint8_t)",testapp.c,"static enum test_return test_binary_set_impl(const char *key, uint8_t cmd) {
    union {
        protocol_binary_request_no_extras request;
        protocol_binary_response_no_extras response;
        char bytes[1024];
    } send, receive;
    uint64_t value = 0xdeadbeefdeadcafe;
    size_t len = storage_command(send.bytes, sizeof(send.bytes), cmd,
                                 key, strlen(key), &value, sizeof(value),
                                 0, 0);

    /* Set should work over and over again */
    int ii;
    for (ii = 0; ii < 10; ++ii) {
        safe_send(send.bytes, len, false);
        if (cmd == PROTOCOL_BINARY_CMD_SET) {
            safe_recv_packet(receive.bytes, sizeof(receive.bytes));
            validate_response_header(&receive.response, cmd,
                                     PROTOCOL_BINARY_RESPONSE_SUCCESS);
        }
    }

    if (cmd == PROTOCOL_BINARY_CMD_SETQ) {
        return test_binary_noop();
    }

    send.request.message.header.request.cas = r...",1372.0,1410.0,1.0,1.0,39.0,46,7,38,12,2,8,5,6,0,8,,0,1,4,2,2,enum test_return
1978,90969,test_binary_set,1,test_binary_set,enum test_return test_binary_set (void),testapp.c,"static enum test_return test_binary_set(void) {
    return test_binary_set_impl(""test_binary_set"", PROTOCOL_BINARY_CMD_SET);
}",1412.0,1414.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,enum test_return
1979,90978,test_binary_setq,1,test_binary_setq,enum test_return test_binary_setq (void),testapp.c,"static enum test_return test_binary_setq(void) {
    return test_binary_set_impl(""test_binary_setq"", PROTOCOL_BINARY_CMD_SETQ);
}",1416.0,1418.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,enum test_return
1980,90987,test_binary_add_impl,1,test_binary_add_impl,"enum test_return test_binary_add_impl (char*,uint8_t)",testapp.c,"static enum test_return test_binary_add_impl(const char *key, uint8_t cmd) {
    uint64_t value = 0xdeadbeefdeadcafe;
    union {
        protocol_binary_request_no_extras request;
        protocol_binary_response_no_extras response;
        char bytes[1024];
    } send, receive;
    size_t len = storage_command(send.bytes, sizeof(send.bytes), cmd, key,
                                 strlen(key), &value, sizeof(value),
                                 0, 0);

    /* Add should only work the first time */
    int ii;
    for (ii = 0; ii < 10; ++ii) {
        safe_send(send.bytes, len, false);
        if (ii == 0) {
            if (cmd == PROTOCOL_BINARY_CMD_ADD) {
                safe_recv_packet(receive.bytes, sizeof(receive.bytes));
                validate_response_header(&receive.response, cmd,
                                         PROTOCOL_BINARY_RESPONSE_SUCCESS);
            }
        } else {
            safe_recv_packet(receive.bytes, sizeof(receive.bytes));
           ...",1421.0,1450.0,1.0,1.0,30.0,17,6,23,11,2,4,4,7,0,4,,0,1,4,2,2,enum test_return
1981,91082,test_binary_add,1,test_binary_add,enum test_return test_binary_add (void),testapp.c,"static enum test_return test_binary_add(void) {
    return test_binary_add_impl(""test_binary_add"", PROTOCOL_BINARY_CMD_ADD);
}",1452.0,1454.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,enum test_return
1982,91091,test_binary_addq,1,test_binary_addq,enum test_return test_binary_addq (void),testapp.c,"static enum test_return test_binary_addq(void) {
    return test_binary_add_impl(""test_binary_addq"", PROTOCOL_BINARY_CMD_ADDQ);
}",1456.0,1458.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,enum test_return
1983,91100,test_binary_replace_impl,1,test_binary_replace_impl,"enum test_return test_binary_replace_impl (char*,uint8_t)",testapp.c,"static enum test_return test_binary_replace_impl(const char* key, uint8_t cmd) {
    uint64_t value = 0xdeadbeefdeadcafe;
    union {
        protocol_binary_request_no_extras request;
        protocol_binary_response_no_extras response;
        char bytes[1024];
    } send, receive;
    size_t len = storage_command(send.bytes, sizeof(send.bytes), cmd,
                                 key, strlen(key), &value, sizeof(value),
                                 0, 0);
    safe_send(send.bytes, len, false);
    safe_recv_packet(receive.bytes, sizeof(receive.bytes));
    validate_response_header(&receive.response, cmd,
                             PROTOCOL_BINARY_RESPONSE_KEY_ENOENT);
    len = storage_command(send.bytes, sizeof(send.bytes),
                          PROTOCOL_BINARY_CMD_ADD,
                          key, strlen(key), &value, sizeof(value), 0, 0);
    safe_send(send.bytes, len, false);
    safe_recv_packet(receive.bytes, sizeof(receive.bytes));
    validate_response_heade...",1460.0,1500.0,1.0,1.0,41.0,41,6,56,14,2,13,4,5,0,13,,0,3,4,2,2,enum test_return
1984,91261,test_binary_replace,1,test_binary_replace,enum test_return test_binary_replace (void),testapp.c,"static enum test_return test_binary_replace(void) {
    return test_binary_replace_impl(""test_binary_replace"",
                                    PROTOCOL_BINARY_CMD_REPLACE);
}",1502.0,1505.0,1.0,1.0,4.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,enum test_return
1985,91270,test_binary_replaceq,1,test_binary_replaceq,enum test_return test_binary_replaceq (void),testapp.c,"static enum test_return test_binary_replaceq(void) {
    return test_binary_replace_impl(""test_binary_replaceq"",
                                    PROTOCOL_BINARY_CMD_REPLACEQ);
}",1507.0,1510.0,1.0,1.0,4.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,enum test_return
1986,91279,test_binary_delete_impl,1,test_binary_delete_impl,"enum test_return test_binary_delete_impl (char*,uint8_t)",testapp.c,"static enum test_return test_binary_delete_impl(const char *key, uint8_t cmd) {
    union {
        protocol_binary_request_no_extras request;
        protocol_binary_response_no_extras response;
        char bytes[1024];
    } send, receive;
    size_t len = raw_command(send.bytes, sizeof(send.bytes), cmd,
                             key, strlen(key), NULL, 0);

    safe_send(send.bytes, len, false);
    safe_recv_packet(receive.bytes, sizeof(receive.bytes));
    validate_response_header(&receive.response, cmd,
                             PROTOCOL_BINARY_RESPONSE_KEY_ENOENT);
    len = storage_command(send.bytes, sizeof(send.bytes),
                          PROTOCOL_BINARY_CMD_ADD,
                          key, strlen(key), NULL, 0, 0, 0);
    safe_send(send.bytes, len, false);
    safe_recv_packet(receive.bytes, sizeof(receive.bytes));
    validate_response_header(&receive.response, PROTOCOL_BINARY_CMD_ADD,
                             PROTOCOL_BINARY_RESPONSE_SUCCESS);

    l...",1512.0,1549.0,1.0,1.0,38.0,37,5,56,12,2,15,2,2,0,15,,0,3,4,2,2,enum test_return
1987,91429,test_binary_delete,1,test_binary_delete,enum test_return test_binary_delete (void),testapp.c,"static enum test_return test_binary_delete(void) {
    return test_binary_delete_impl(""test_binary_delete"",
                                   PROTOCOL_BINARY_CMD_DELETE);
}",1551.0,1554.0,1.0,1.0,4.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,enum test_return
1988,91438,test_binary_deleteq,1,test_binary_deleteq,enum test_return test_binary_deleteq (void),testapp.c,"static enum test_return test_binary_deleteq(void) {
    return test_binary_delete_impl(""test_binary_deleteq"",
                                   PROTOCOL_BINARY_CMD_DELETEQ);
}",1556.0,1559.0,1.0,1.0,4.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,enum test_return
1989,91447,test_binary_get_impl,1,test_binary_get_impl,"enum test_return test_binary_get_impl (char*,uint8_t)",testapp.c,"static enum test_return test_binary_get_impl(const char *key, uint8_t cmd) {
    union {
        protocol_binary_request_no_extras request;
        protocol_binary_response_no_extras response;
        char bytes[1024];
    } send, receive;

    uint32_t expiration = htonl(3600);
    size_t extlen = 0;
    if (cmd == PROTOCOL_BINARY_CMD_GAT || cmd == PROTOCOL_BINARY_CMD_GATK)
        extlen = sizeof(expiration);

    size_t len = ext_command(send.bytes, sizeof(send.bytes), cmd,
                             extlen ? &expiration : NULL, extlen,
                             key, strlen(key), NULL, 0);

    safe_send(send.bytes, len, false);
    safe_recv_packet(receive.bytes, sizeof(receive.bytes));
    validate_response_header(&receive.response, cmd,
                             PROTOCOL_BINARY_RESPONSE_KEY_ENOENT);

    len = storage_command(send.bytes, sizeof(send.bytes),
                          PROTOCOL_BINARY_CMD_ADD,
                          key, strlen(key), NULL, 0,
         ...",1561.0,1614.0,1.0,1.0,54.0,50,10,73,18,4,12,4,4,0,12,,0,3,4,2,2,enum test_return
1990,91646,test_binary_get,1,test_binary_get,enum test_return test_binary_get (void),testapp.c,"static enum test_return test_binary_get(void) {
    return test_binary_get_impl(""test_binary_get"", PROTOCOL_BINARY_CMD_GET);
}",1616.0,1618.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,enum test_return
1991,91655,test_binary_getk,1,test_binary_getk,enum test_return test_binary_getk (void),testapp.c,"static enum test_return test_binary_getk(void) {
    return test_binary_get_impl(""test_binary_getk"", PROTOCOL_BINARY_CMD_GETK);
}",1620.0,1622.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,enum test_return
1992,91664,test_binary_gat,1,test_binary_gat,enum test_return test_binary_gat (void),testapp.c,"static enum test_return test_binary_gat(void) {
    return test_binary_get_impl(""test_binary_gat"", PROTOCOL_BINARY_CMD_GAT);
}",1624.0,1626.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,enum test_return
1993,91673,test_binary_gatk,1,test_binary_gatk,enum test_return test_binary_gatk (void),testapp.c,"static enum test_return test_binary_gatk(void) {
    return test_binary_get_impl(""test_binary_gatk"", PROTOCOL_BINARY_CMD_GATK);
}",1628.0,1630.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,enum test_return
1994,91682,test_binary_getq_impl,1,test_binary_getq_impl,"enum test_return test_binary_getq_impl (char*,uint8_t)",testapp.c,"static enum test_return test_binary_getq_impl(const char *key, uint8_t cmd) {
    const char *missing = ""test_binary_getq_missing"";
    union {
        protocol_binary_request_no_extras request;
        protocol_binary_response_no_extras response;
        char bytes[1024];
    } send, temp, receive;

    uint32_t expiration = htonl(3600);
    size_t extlen = 0;
    if (cmd == PROTOCOL_BINARY_CMD_GATQ || cmd == PROTOCOL_BINARY_CMD_GATKQ)
        extlen = sizeof(expiration);

    size_t len = storage_command(send.bytes, sizeof(send.bytes),
                                 PROTOCOL_BINARY_CMD_ADD,
                                 key, strlen(key), NULL, 0,
                                 0, 0);
    size_t len2 = ext_command(temp.bytes, sizeof(temp.bytes), cmd,
                              extlen ? &expiration : NULL, extlen,
                              missing, strlen(missing), NULL, 0);
    /* I need to change the first opaque so that I can separate the two
     * return packets *...",1632.0,1674.0,1.0,1.0,43.0,49,9,65,17,4,8,2,2,0,8,,0,3,4,2,2,enum test_return
1995,91858,test_binary_getq,1,test_binary_getq,enum test_return test_binary_getq (void),testapp.c,"static enum test_return test_binary_getq(void) {
    return test_binary_getq_impl(""test_binary_getq"", PROTOCOL_BINARY_CMD_GETQ);
}",1676.0,1678.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,enum test_return
1996,91867,test_binary_getkq,1,test_binary_getkq,enum test_return test_binary_getkq (void),testapp.c,"static enum test_return test_binary_getkq(void) {
    return test_binary_getq_impl(""test_binary_getkq"", PROTOCOL_BINARY_CMD_GETKQ);
}",1680.0,1682.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,enum test_return
1997,91876,test_binary_gatq,1,test_binary_gatq,enum test_return test_binary_gatq (void),testapp.c,"static enum test_return test_binary_gatq(void) {
    return test_binary_getq_impl(""test_binary_gatq"", PROTOCOL_BINARY_CMD_GATQ);
}",1684.0,1686.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,enum test_return
1998,91885,test_binary_gatkq,1,test_binary_gatkq,enum test_return test_binary_gatkq (void),testapp.c,"static enum test_return test_binary_gatkq(void) {
    return test_binary_getq_impl(""test_binary_gatkq"", PROTOCOL_BINARY_CMD_GATKQ);
}",1688.0,1690.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,enum test_return
1999,91894,test_binary_incr_impl,1,test_binary_incr_impl,"enum test_return test_binary_incr_impl (char*,uint8_t)",testapp.c,"static enum test_return test_binary_incr_impl(const char* key, uint8_t cmd) {
    union {
        protocol_binary_request_no_extras request;
        protocol_binary_response_no_extras response_header;
        protocol_binary_response_incr response;
        char bytes[1024];
    } send, receive;
    size_t len = arithmetic_command(send.bytes, sizeof(send.bytes), cmd,
                                    key, strlen(key), 1, 0, 0);

    int ii;
    for (ii = 0; ii < 10; ++ii) {
        safe_send(send.bytes, len, false);
        if (cmd == PROTOCOL_BINARY_CMD_INCREMENT) {
            safe_recv_packet(receive.bytes, sizeof(receive.bytes));
            validate_response_header(&receive.response_header, cmd,
                                     PROTOCOL_BINARY_RESPONSE_SUCCESS);
            assert(ntohll(receive.response.message.body.value) == ii);
        }
    }

    if (cmd == PROTOCOL_BINARY_CMD_INCREMENTQ) {
        test_binary_noop();
    }
    return TEST_PASS;
}",1692.0,1717.0,1.0,1.0,26.0,19,6,23,11,2,6,4,5,0,6,,0,1,4,2,2,enum test_return
2000,91979,test_binary_incr,1,test_binary_incr,enum test_return test_binary_incr (void),testapp.c,"static enum test_return test_binary_incr(void) {
    return test_binary_incr_impl(""test_binary_incr"",
                                 PROTOCOL_BINARY_CMD_INCREMENT);
}",1719.0,1722.0,1.0,1.0,4.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,enum test_return
2001,91988,test_binary_incrq,1,test_binary_incrq,enum test_return test_binary_incrq (void),testapp.c,"static enum test_return test_binary_incrq(void) {
    return test_binary_incr_impl(""test_binary_incrq"",
                                 PROTOCOL_BINARY_CMD_INCREMENTQ);
}",1724.0,1727.0,1.0,1.0,4.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,enum test_return
2002,91997,test_binary_decr_impl,1,test_binary_decr_impl,"enum test_return test_binary_decr_impl (char*,uint8_t)",testapp.c,"static enum test_return test_binary_decr_impl(const char* key, uint8_t cmd) {
    union {
        protocol_binary_request_no_extras request;
        protocol_binary_response_no_extras response_header;
        protocol_binary_response_decr response;
        char bytes[1024];
    } send, receive;
    size_t len = arithmetic_command(send.bytes, sizeof(send.bytes), cmd,
                                    key, strlen(key), 1, 9, 0);

    int ii;
    for (ii = 9; ii >= 0; --ii) {
        safe_send(send.bytes, len, false);
        if (cmd == PROTOCOL_BINARY_CMD_DECREMENT) {
            safe_recv_packet(receive.bytes, sizeof(receive.bytes));
            validate_response_header(&receive.response_header, cmd,
                                     PROTOCOL_BINARY_RESPONSE_SUCCESS);
            assert(ntohll(receive.response.message.body.value) == ii);
        }
    }

    /* decr on 0 should not wrap */
    safe_send(send.bytes, len, false);
    if (cmd == PROTOCOL_BINARY_CMD_DECREMENT) {
   ...",1729.0,1762.0,1.0,1.0,34.0,30,6,32,10,2,9,4,5,0,9,,0,1,4,2,2,enum test_return
2003,92118,test_binary_decr,1,test_binary_decr,enum test_return test_binary_decr (void),testapp.c,"static enum test_return test_binary_decr(void) {
    return test_binary_decr_impl(""test_binary_decr"",
                                 PROTOCOL_BINARY_CMD_DECREMENT);
}",1764.0,1767.0,1.0,1.0,4.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,enum test_return
2004,92127,test_binary_decrq,1,test_binary_decrq,enum test_return test_binary_decrq (void),testapp.c,"static enum test_return test_binary_decrq(void) {
    return test_binary_decr_impl(""test_binary_decrq"",
                                 PROTOCOL_BINARY_CMD_DECREMENTQ);
}",1769.0,1772.0,1.0,1.0,4.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,enum test_return
2005,92136,test_binary_version,1,test_binary_version,enum test_return test_binary_version (void),testapp.c,"static enum test_return test_binary_version(void) {
    union {
        protocol_binary_request_no_extras request;
        protocol_binary_response_no_extras response;
        char bytes[1024];
    } buffer;

    size_t len = raw_command(buffer.bytes, sizeof(buffer.bytes),
                             PROTOCOL_BINARY_CMD_VERSION,
                             NULL, 0, NULL, 0);

    safe_send(buffer.bytes, len, false);
    safe_recv_packet(buffer.bytes, sizeof(buffer.bytes));
    validate_response_header(&buffer.response, PROTOCOL_BINARY_CMD_VERSION,
                             PROTOCOL_BINARY_RESPONSE_SUCCESS);

    return TEST_PASS;
}",1774.0,1791.0,1.0,1.0,18.0,10,4,15,7,0,4,1,1,0,4,,0,1,2,1,1,enum test_return
2006,92181,test_binary_flush_impl,1,test_binary_flush_impl,"enum test_return test_binary_flush_impl (char*,uint8_t)",testapp.c,"static enum test_return test_binary_flush_impl(const char *key, uint8_t cmd) {
    union {
        protocol_binary_request_no_extras request;
        protocol_binary_response_no_extras response;
        char bytes[1024];
    } send, receive;

    size_t len = storage_command(send.bytes, sizeof(send.bytes),
                                 PROTOCOL_BINARY_CMD_ADD,
                                 key, strlen(key), NULL, 0, 0, 0);
    safe_send(send.bytes, len, false);
    safe_recv_packet(receive.bytes, sizeof(receive.bytes));
    validate_response_header(&receive.response, PROTOCOL_BINARY_CMD_ADD,
                             PROTOCOL_BINARY_RESPONSE_SUCCESS);

    len = flush_command(send.bytes, sizeof(send.bytes), cmd, 2, true);
    safe_send(send.bytes, len, false);
    if (cmd == PROTOCOL_BINARY_CMD_FLUSH) {
        safe_recv_packet(receive.bytes, sizeof(receive.bytes));
        validate_response_header(&receive.response, cmd,
                                 PROTOCOL_BINARY_RES...",1793.0,1857.0,1.0,1.0,65.0,71,6,101,15,2,27,4,5,0,27,,0,6,4,2,2,enum test_return
2007,92459,test_binary_flush,1,test_binary_flush,enum test_return test_binary_flush (void),testapp.c,"static enum test_return test_binary_flush(void) {
    return test_binary_flush_impl(""test_binary_flush"",
                                  PROTOCOL_BINARY_CMD_FLUSH);
}",1859.0,1862.0,1.0,1.0,4.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,enum test_return
2008,92468,test_binary_flushq,1,test_binary_flushq,enum test_return test_binary_flushq (void),testapp.c,"static enum test_return test_binary_flushq(void) {
    return test_binary_flush_impl(""test_binary_flushq"",
                                  PROTOCOL_BINARY_CMD_FLUSHQ);
}",1864.0,1867.0,1.0,1.0,4.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,enum test_return
2009,92477,test_binary_concat_impl,1,test_binary_concat_impl,"enum test_return test_binary_concat_impl (char*,uint8_t)",testapp.c,"static enum test_return test_binary_concat_impl(const char *key, uint8_t cmd) {
    union {
        protocol_binary_request_no_extras request;
        protocol_binary_response_no_extras response;
        char bytes[1024];
    } send, receive;
    const char *value = ""world"";

    size_t len = raw_command(send.bytes, sizeof(send.bytes), cmd,
                              key, strlen(key), value, strlen(value));


    safe_send(send.bytes, len, false);
    safe_recv_packet(receive.bytes, sizeof(receive.bytes));
    validate_response_header(&receive.response, cmd,
                             PROTOCOL_BINARY_RESPONSE_NOT_STORED);

    len = storage_command(send.bytes, sizeof(send.bytes),
                          PROTOCOL_BINARY_CMD_ADD,
                          key, strlen(key), value, strlen(value), 0, 0);
    safe_send(send.bytes, len, false);
    safe_recv_packet(receive.bytes, sizeof(receive.bytes));
    validate_response_header(&receive.response, PROTOCOL_BINARY_CMD_ADD,
       ...",1869.0,1933.0,1.0,1.0,65.0,70,9,92,16,4,16,2,2,0,16,,0,4,4,2,2,enum test_return
2010,92776,test_binary_append,1,test_binary_append,enum test_return test_binary_append (void),testapp.c,"static enum test_return test_binary_append(void) {
    return test_binary_concat_impl(""test_binary_append"",
                                   PROTOCOL_BINARY_CMD_APPEND);
}",1935.0,1938.0,1.0,1.0,4.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,enum test_return
2011,92785,test_binary_prepend,1,test_binary_prepend,enum test_return test_binary_prepend (void),testapp.c,"static enum test_return test_binary_prepend(void) {
    return test_binary_concat_impl(""test_binary_prepend"",
                                   PROTOCOL_BINARY_CMD_PREPEND);
}",1940.0,1943.0,1.0,1.0,4.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,enum test_return
2012,92794,test_binary_appendq,1,test_binary_appendq,enum test_return test_binary_appendq (void),testapp.c,"static enum test_return test_binary_appendq(void) {
    return test_binary_concat_impl(""test_binary_appendq"",
                                   PROTOCOL_BINARY_CMD_APPENDQ);
}",1945.0,1948.0,1.0,1.0,4.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,enum test_return
2013,92803,test_binary_prependq,1,test_binary_prependq,enum test_return test_binary_prependq (void),testapp.c,"static enum test_return test_binary_prependq(void) {
    return test_binary_concat_impl(""test_binary_prependq"",
                                   PROTOCOL_BINARY_CMD_PREPENDQ);
}",1950.0,1953.0,1.0,1.0,4.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,enum test_return
2014,92812,test_binary_stat,1,test_binary_stat,enum test_return test_binary_stat (void),testapp.c,"static enum test_return test_binary_stat(void) {
    union {
        protocol_binary_request_no_extras request;
        protocol_binary_response_no_extras response;
        char bytes[1024];
    } buffer;

    size_t len = raw_command(buffer.bytes, sizeof(buffer.bytes),
                             PROTOCOL_BINARY_CMD_STAT,
                             NULL, 0, NULL, 0);

    safe_send(buffer.bytes, len, false);
    do {
        safe_recv_packet(buffer.bytes, sizeof(buffer.bytes));
        validate_response_header(&buffer.response, PROTOCOL_BINARY_CMD_STAT,
                                 PROTOCOL_BINARY_RESPONSE_SUCCESS);
    } while (buffer.response.message.header.response.keylen != 0);

    return TEST_PASS;
}",1955.0,1974.0,1.0,1.0,20.0,16,5,16,7,0,4,2,2,0,4,,0,1,2,1,1,enum test_return
2015,92872,test_binary_illegal,1,test_binary_illegal,enum test_return test_binary_illegal (void),testapp.c,"static enum test_return test_binary_illegal(void) {
    uint8_t cmd = 0x25;
    while (cmd != 0x00) {
        union {
            protocol_binary_request_no_extras request;
            protocol_binary_response_no_extras response;
            char bytes[1024];
        } buffer;
        size_t len = raw_command(buffer.bytes, sizeof(buffer.bytes),
                                 cmd, NULL, 0, NULL, 0);
        safe_send(buffer.bytes, len, false);
        safe_recv_packet(buffer.bytes, sizeof(buffer.bytes));
        validate_response_header(&buffer.response, cmd,
                                 PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND);
        ++cmd;
    }

    return TEST_PASS;
}",1976.0,1994.0,1.0,1.0,19.0,13,6,18,7,0,4,2,2,0,4,,0,1,2,1,1,enum test_return
2016,92929,binary_hickup_recv_verification_thread,1,binary_hickup_recv_verification_thread,void* binary_hickup_recv_verification_thread (void*),testapp.c,"static void *binary_hickup_recv_verification_thread(void *arg) {
    protocol_binary_response_no_extras *response = malloc(65*1024);
    if (response != NULL) {
        while (safe_recv_packet(response, 65*1024)) {
            /* Just validate the packet format */
            validate_response_header(response,
                                     response->message.header.response.opcode,
                                     response->message.header.response.status);
        }
        free(response);
    }
    hickup_thread_running = false;
    allow_closed_read = false;
    return NULL;
}",1998.0,2012.0,1.0,1.0,15.0,14,5,13,5,0,4,3,4,1,2,,0,3,2,1,1,void*
2017,92983,test_binary_pipeline_hickup_chunk,1,test_binary_pipeline_hickup_chunk,"enum test_return test_binary_pipeline_hickup_chunk (void*,size_t)",testapp.c,"static enum test_return test_binary_pipeline_hickup_chunk(void *buffer, size_t buffersize) {
    off_t offset = 0;
    char *key[256] = { NULL };
    uint64_t value = 0xfeedfacedeadbeef;

    while (hickup_thread_running &&
           offset + sizeof(protocol_binary_request_no_extras) < buffersize) {
        union {
            protocol_binary_request_no_extras request;
            char bytes[65 * 1024];
        } command;
        uint8_t cmd = (uint8_t)(rand() & 0xff);
        size_t len;
        size_t keylen = (rand() % 250) + 1;

        switch (cmd) {
        case PROTOCOL_BINARY_CMD_ADD:
        case PROTOCOL_BINARY_CMD_ADDQ:
        case PROTOCOL_BINARY_CMD_REPLACE:
        case PROTOCOL_BINARY_CMD_REPLACEQ:
        case PROTOCOL_BINARY_CMD_SET:
        case PROTOCOL_BINARY_CMD_SETQ:
            len = storage_command(command.bytes, sizeof(command.bytes), cmd,
                                  key, keylen , &value, sizeof(value),
                                  0, 0);
      ...",2014.0,2120.0,1.0,1.0,107.0,67,12,132,49,1,13,14,6,1,12,,0,12,4,2,2,enum test_return
2018,93316,test_binary_pipeline_hickup,1,test_binary_pipeline_hickup,enum test_return test_binary_pipeline_hickup (void),testapp.c,"static enum test_return test_binary_pipeline_hickup(void)
{
    size_t buffersize = 65 * 1024;
    void *buffer = malloc(buffersize);
    int ii;

    pthread_t tid;
    int ret;
    allow_closed_read = true;
    hickup_thread_running = true;
    if ((ret = pthread_create(&tid, NULL,
                              binary_hickup_recv_verification_thread, NULL)) != 0) {
        fprintf(stderr, ""Can't create thread: %s\n"", strerror(ret));
        free(buffer);
        return TEST_FAIL;
    }

    /* Allow the thread to start */
    usleep(250);

    srand((int)time(NULL));
    for (ii = 0; ii < 2; ++ii) {
        test_binary_pipeline_hickup_chunk(buffer, buffersize);
    }

    /* send quitq to shut down the read thread ;-) */
    size_t len = raw_command(buffer, buffersize, PROTOCOL_BINARY_CMD_QUITQ,
                             NULL, 0, NULL, 0);
    safe_send(buffer, len, false);

    pthread_join(tid, NULL);
    free(buffer);
    return TEST_PASS;
}",2122.0,2155.0,1.0,1.0,34.0,12,6,33,15,0,5,3,3,0,3,,0,3,2,1,1,enum test_return
2019,93405,test_issue_101,1,test_issue_101,enum test_return test_issue_101 (void),testapp.c,"static enum test_return test_issue_101(void) {
    enum { max = 2 };
    enum test_return ret = TEST_PASS;
    struct conn *conns[max];
    int ii = 0;
    pid_t child = 0;

    if (getenv(""SKIP_TEST_101"") != NULL) {
        return TEST_SKIP;
    }

    const char *command = ""stats\r\nstats\r\nstats\r\nstats\r\nstats\r\n"";
    size_t cmdlen = strlen(command);

    server_pid = start_server(&port, false, 1000);

    for (ii = 0; ii < max; ++ii) {
        conns[ii] = NULL;
        conns[ii] = connect_server(""127.0.0.1"", port, true, enable_ssl);
        assert(conns[ii]);
        assert(conns[ii]->sock > 0);
    }

    /* Send command on the connection until it blocks */
    for (ii = 0; ii < max; ++ii) {
        bool more = true;
        do {
            ssize_t err = conns[ii]->write(conns[ii], command, cmdlen);
            if (err == -1) {
                switch (errno) {
                case EINTR:
                    break;
                case ENOMEM:
                case EWOULDB...",2158.0,2240.0,1.0,1.0,83.0,44,10,70,25,0,10,15,19,1,3,,0,10,2,1,1,enum test_return
2020,94076,notify_worker,1,notify_worker,"void notify_worker (LIBEVENT_THREAD*,CQ_ITEM*)",thread.c,"static void notify_worker(LIBEVENT_THREAD *t, CQ_ITEM *item) {
    cq_push(t->ev_queue, item);
#ifdef HAVE_EVENTFD
    uint64_t u = 1;
    if (write(t->notify_event_fd, &u, sizeof(uint64_t)) != sizeof(uint64_t)) {
        perror(""failed writing to worker eventfd"");
        /* TODO: This is a fatal problem. Can it ever happen temporarily? */
    }
#else
    char buf[1] = ""c"";
    if (write(t->notify_send_fd, buf, 1) != 1) {
        perror(""Failed writing to notify pipe"");
        /* TODO: This is a fatal problem. Can it ever happen temporarily? */
    }
#endif
}",340.0,355.0,1.0,1.0,16.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
2021,94082,notify_worker_fd,1,notify_worker_fd,"void notify_worker_fd (LIBEVENT_THREAD*,int,conn_queue_item_modes)",thread.c,"static void notify_worker_fd(LIBEVENT_THREAD *t, int sfd, enum conn_queue_item_modes mode) {
    CQ_ITEM *item;
    while ( (item = cqi_new(t->ev_queue)) == NULL ) {
        // NOTE: most callers of this function cannot fail, but mallocs in
        // theory can fail. Small mallocs essentially never do without also
        // killing the process. Syscalls can also fail but the original code
        // never handled this either.
        // As a compromise, I'm leaving this note and this loop: This alloc
        // cannot fail, but pre-allocating the data is too much code in an
        // area I want to keep more lean. If this CQ business becomes a more
        // generic queue I'll reconsider.
    }

    item->mode = mode;
    item->sfd = sfd;
    notify_worker(t, item);
}",358.0,374.0,1.0,1.0,17.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,void
2022,94089,cqi_new,1,cqi_new,CQ_ITEM* cqi_new (CQ*),thread.c,"static CQ_ITEM *cqi_new(CQ *cq) {
    CQ_ITEM *item = cache_alloc(cq->cache);
    if (item == NULL) {
        STATS_LOCK();
        stats.malloc_fails++;
        STATS_UNLOCK();
    }
    return item;
}",317.0,325.0,1.0,1.0,9.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,CQ_ITEM
2023,94094,cq_push,1,cq_push,"void cq_push (CQ*,CQ_ITEM*)",thread.c,"static void cq_push(CQ *cq, CQ_ITEM *item) {
    pthread_mutex_lock(&cq->lock);
    STAILQ_INSERT_TAIL(&cq->head, item, i_next);
    pthread_mutex_unlock(&cq->lock);
}",308.0,312.0,1.0,4.0,5.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
2024,94100,thread_libevent_process,1,thread_libevent_process,"void thread_libevent_process (evutil_socket_t,short,void*)",thread.c,"static void thread_libevent_process(evutil_socket_t fd, short which, void *arg) {
    LIBEVENT_THREAD *me = arg;
    CQ_ITEM *item;
    conn *c;
    uint64_t ev_count = 0; // max number of events to loop through this run.
#ifdef HAVE_EVENTFD
    // NOTE: unlike pipe we aren't limiting the number of events per read.
    // However we do limit the number of queue pulls to what the count was at
    // the time of this function firing.
    if (read(fd, &ev_count, sizeof(uint64_t)) != sizeof(uint64_t)) {
        if (settings.verbose > 0)
            fprintf(stderr, ""Can't read from libevent pipe\n"");
        return;
    }
#else
    char buf[MAX_PIPE_EVENTS];

    ev_count = read(fd, buf, MAX_PIPE_EVENTS);
    if (ev_count == 0) {
        if (settings.verbose > 0)
            fprintf(stderr, ""Can't read from libevent pipe\n"");
        return;
    }
#endif

    for (int x = 0; x < ev_count; x++) {
        item = cq_pop(me->ev_queue);
        if (item == NULL) {
            return;
        ...",537.0,630.0,1.0,13.0,94.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,void
2025,94191,wait_for_thread_registration,1,wait_for_thread_registration,void wait_for_thread_registration (int),thread.c,"static void wait_for_thread_registration(int nthreads) {
    while (init_count < nthreads) {
        pthread_cond_wait(&init_cond, &init_lock);
    }
}",141.0,145.0,1.0,1.0,5.0,3,2,4,4,0,3,2,2,1,0,,0,3,2,1,1,void
2026,94206,register_thread_initialized,1,register_thread_initialized,void register_thread_initialized (void),thread.c,"static void register_thread_initialized(void) {
    pthread_mutex_lock(&init_lock);
    init_count++;
    pthread_cond_signal(&init_cond);
    pthread_mutex_unlock(&init_lock);
    /* Force worker threads to pile up if someone wants us to */
    pthread_mutex_lock(&worker_hang_lock);
    pthread_mutex_unlock(&worker_hang_lock);
}",147.0,155.0,1.0,1.0,9.0,6,2,6,4,2,6,1,1,0,0,,0,6,2,1,1,void
2027,94509,cq_init,1,cq_init,void cq_init (CQ*),thread.c,"static void cq_init(CQ *cq) {
    pthread_mutex_init(&cq->lock, NULL);
    STAILQ_INIT(&cq->head);
    cq->cache = cache_create(""cq"", sizeof(CQ_ITEM), sizeof(char *));
    if (cq->cache == NULL) {
        fprintf(stderr, ""Failed to create connection queue cache\n"");
        exit(EXIT_FAILURE);
    }
}",277.0,285.0,1.0,4.0,9.0,22,5,14,6,1,1,2,2,0,1,,0,1,2,1,1,void
2028,94573,cq_pop,1,cq_pop,CQ_ITEM cq_pop (CQ*),thread.c,"static CQ_ITEM *cq_pop(CQ *cq) {
    CQ_ITEM *item;

    pthread_mutex_lock(&cq->lock);
    item = STAILQ_FIRST(&cq->head);
    if (item != NULL) {
        STAILQ_REMOVE_HEAD(&cq->head, i_next);
    }
    pthread_mutex_unlock(&cq->lock);

    return item;
}",292.0,303.0,1.0,11.0,12.0,31,6,14,3,0,0,2,2,0,0,,0,0,2,1,1,CQ_ITEM
2029,94734,cqi_free,1,cqi_free,"void cqi_free (CQ*,CQ_ITEM*)",thread.c,"static void cqi_free(CQ *cq, CQ_ITEM *item) {
    cache_free(cq->cache, item);
}",330.0,332.0,1.0,1.0,3.0,1,1,2,2,0,1,1,1,0,1,,0,0,4,2,2,void
2030,94803,create_worker,1,create_worker,"void create_worker (void*,void*)",thread.c,"static void create_worker(void *(*func)(void *), void *arg) {
    pthread_attr_t  attr;
    int             ret;

    pthread_attr_init(&attr);

    if ((ret = pthread_create(&((LIBEVENT_THREAD*)arg)->thread_id, &attr, func, arg)) != 0) {
        fprintf(stderr, ""Can't create thread: %s\n"",
                strerror(ret));
        exit(1);
    }
}",379.0,390.0,1.0,1.0,12.0,7,5,8,5,0,0,2,2,0,0,,0,0,4,2,2,void
2031,94851,setup_thread,1,setup_thread,void setup_thread (LIBEVENT_THREAD*),thread.c,"static void setup_thread(LIBEVENT_THREAD *me) {
#if defined(LIBEVENT_VERSION_NUMBER) && LIBEVENT_VERSION_NUMBER >= 0x02000101
    struct event_config *ev_config;
    ev_config = event_config_new();
    event_config_set_flag(ev_config, EVENT_BASE_FLAG_NOLOCK);
    me->base = event_base_new_with_config(ev_config);
    event_config_free(ev_config);
#else
    me->base = event_init();
#endif

    if (! me->base) {
        fprintf(stderr, ""Can't allocate event base\n"");
        exit(1);
    }

    /* Listen for notifications from other threads */
#ifdef HAVE_EVENTFD
    event_set(&me->notify_event, me->notify_event_fd,
              EV_READ | EV_PERSIST, thread_libevent_process, me);
#else
    event_set(&me->notify_event, me->notify_receive_fd,
              EV_READ | EV_PERSIST, thread_libevent_process, me);
#endif
    event_base_set(me->base, &me->notify_event);

    if (event_add(&me->notify_event, 0) == -1) {
        fprintf(stderr, ""Can't monitor libevent notify pipe\n"");
        exi...",405.0,497.0,1.0,42.0,93.0,44,12,49,12,0,24,9,10,7,5,,0,21,2,1,1,void
2032,95041,worker_libevent,1,worker_libevent,void* worker_libevent (void*),thread.c,"static void *worker_libevent(void *arg) {
    LIBEVENT_THREAD *me = arg;

    /* Any per-thread setup can happen here; memcached_thread_init() will block until
     * all threads have finished initializing.
     */
    me->l = logger_create();
    me->lru_bump_buf = item_lru_bump_buf_create();
    if (me->l == NULL || me->lru_bump_buf == NULL) {
        abort();
    }

    if (settings.drop_privileges) {
        drop_worker_privileges();
    }

    register_thread_initialized();

    event_base_loop(me->base, 0);

    // same mechanism used to watch for all threads exiting.
    register_thread_initialized();

    event_base_free(me->base);
    return NULL;
}",502.0,527.0,1.0,8.0,26.0,13,5,12,4,0,11,3,3,3,4,,0,9,2,1,1,void*
2033,95308,select_thread_round_robin,1,select_thread_round_robin,LIBEVENT_THREAD select_thread_round_robin (void),thread.c,"static LIBEVENT_THREAD *select_thread_round_robin(void)
{
    int tid = (last_thread + 1) % settings.num_threads;

    last_thread = tid;

    return threads + tid;
}",644.0,651.0,1.0,1.0,8.0,6,4,7,4,1,4,1,1,0,0,,0,4,2,1,1,LIBEVENT_THREAD
2034,95330,reset_threads_napi_id,1,reset_threads_napi_id,void reset_threads_napi_id (void),thread.c,"static void reset_threads_napi_id(void)
{
    LIBEVENT_THREAD *thread;
    int i;

    for (i = 0; i < settings.num_threads; i++) {
         thread = threads + i;
         thread->napi_id = 0;
    }

    last_thread_by_napi_id = -1;
}",653.0,664.0,1.0,1.0,12.0,9,6,8,5,1,4,2,2,1,0,,0,4,2,1,1,void
2035,95364,select_thread_by_napi_id,1,select_thread_by_napi_id,LIBEVENT_THREAD select_thread_by_napi_id (int),thread.c,"static LIBEVENT_THREAD *select_thread_by_napi_id(int sfd)
{
    LIBEVENT_THREAD *thread;
    int napi_id, err, i;
    socklen_t len;
    int tid = -1;

    len = sizeof(socklen_t);
    err = getsockopt(sfd, SOL_SOCKET, SO_INCOMING_NAPI_ID, &napi_id, &len);
    if ((err == -1) || (napi_id == 0)) {
        STATS_LOCK();
        stats.round_robin_fallback++;
        STATS_UNLOCK();
        return select_thread_round_robin();
    }

select:
    for (i = 0; i < settings.num_threads; i++) {
         thread = threads + i;
         if (last_thread_by_napi_id < i) {
             thread->napi_id = napi_id;
             last_thread_by_napi_id = i;
             tid = i;
             break;
         }
         if (thread->napi_id == napi_id) {
             tid = i;
             break;
         }
    }

    if (tid == -1) {
        STATS_LOCK();
        stats.unexpected_napi_ids++;
        STATS_UNLOCK();
        reset_threads_napi_id();
        goto select;
    }

    return threads + tid;
}",670.0,710.0,1.0,38.0,41.0,31,11,33,13,0,15,9,8,3,2,,0,9,2,1,1,LIBEVENT_THREAD
2036,95900,add_delta,1,add_delta,"enum delta_result_type add_delta (conn*,char*,size_t,bool,int64_t,char*,uint64_t*)",thread.c,"enum delta_result_type add_delta(conn *c, const char *key,
                                 const size_t nkey, bool incr,
                                 const int64_t delta, char *buf,
                                 uint64_t *cas) {
    enum delta_result_type ret;
    uint32_t hv;

    hv = hash(key, nkey);
    item_lock(hv);
    ret = do_add_delta(c, key, nkey, incr, delta, buf, cas, hv, NULL);
    item_unlock(hv);
    return ret;
}",891.0,903.0,1.0,1.0,13.0,2,1,16,10,1,3,1,1,0,3,,0,1,14,7,7,enum delta_result_type
2037,95936,store_item,1,store_item,"enum store_item_type store_item (item*,int,conn*)",thread.c,"enum store_item_type store_item(item *item, int comm, conn* c) {
    enum store_item_type ret;
    uint32_t hv;

    hv = hash(ITEM_key(item), item->nkey);
    item_lock(hv);
    ret = do_store_item(item, comm, c, hv);
    item_unlock(hv);
    return ret;
}",908.0,917.0,1.0,14.0,10.0,11,8,14,6,0,3,1,1,0,3,,0,1,6,3,3,enum store_item_type
2038,97243,signal_handler,1,signal_handler,void signal_handler (int),timedrun.c,"static void signal_handler(int which)
{
    caught_sig = which;
}",13.0,16.0,1.0,1.0,4.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
2039,97251,wait_for_process,1,wait_for_process,int wait_for_process (pid_t),timedrun.c,"static int wait_for_process(pid_t pid)
{
    int rv = EX_SOFTWARE;
    int status = 0;
    int i = 0;
    struct sigaction sig_handler;

    memset(&sig_handler, 0, sizeof(struct sigaction));
    sig_handler.sa_handler = signal_handler;
    sig_handler.sa_flags = 0;

    sigaction(SIGALRM, &sig_handler, NULL);
    sigaction(SIGHUP, &sig_handler, NULL);
    sigaction(SIGINT, &sig_handler, NULL);
    sigaction(SIGUSR1, &sig_handler, NULL);
    sigaction(SIGTERM, &sig_handler, NULL);
    sigaction(SIGPIPE, &sig_handler, NULL);

    /* Loop forever waiting for the process to quit */
    for (i = 0; ;i++) {
        pid_t p = waitpid(pid, &status, 0);
        if (p == pid) {
            /* child exited.  Let's get out of here */
            rv = WIFEXITED(status) ?
                WEXITSTATUS(status) :
                (0x80 | WTERMSIG(status));
            break;
        } else {
            int sig = 0;
            switch (i) {
            case 0:
                /* On the first iteratio...",18.0,71.0,1.0,1.0,54.0,23,8,38,15,1,0,4,4,0,0,,0,0,2,1,1,int
2040,97400,spawn_and_wait,1,spawn_and_wait,int spawn_and_wait (char**),timedrun.c,"static int spawn_and_wait(char **argv)
{
    int rv = EX_SOFTWARE;
    pid_t pid = fork();

    switch (pid) {
    case -1:
        perror(""fork"");
        rv = EX_OSERR;
        break; /* NOTREACHED */
    case 0:
        execvp(argv[0], argv);
        perror(""exec"");
        rv = EX_SOFTWARE;
        break; /* NOTREACHED */
    default:
        rv = wait_for_process(pid);
    }
    return rv;
}",73.0,92.0,1.0,1.0,20.0,7,3,13,5,0,1,4,2,0,1,,0,1,2,1,1,int
2041,97515,SSL_LOCK,1,SSL_LOCK,void SSL_LOCK (void),tls.h,void SSL_LOCK(void);,8.0,8.0,6.0,19.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
2042,97520,SSL_UNLOCK,1,SSL_UNLOCK,void SSL_UNLOCK (void),tls.h,void SSL_UNLOCK(void);,9.0,9.0,6.0,21.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
2043,97525,ssl_read,1,ssl_read,"ssize_t ssl_read (conn*,void*,size_t)",tls.h,"ssize_t ssl_read(conn *c, void *buf, size_t count);",10.0,10.0,9.0,50.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,ssize_t
2044,97532,ssl_sendmsg,1,ssl_sendmsg,"ssize_t ssl_sendmsg (conn*,msghdr*,int)",tls.h,"ssize_t ssl_sendmsg(conn *c, struct msghdr *msg, int flags);",11.0,11.0,9.0,59.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,ssize_t
2045,97539,ssl_write,1,ssl_write,"ssize_t ssl_write (conn*,void*,size_t)",tls.h,"ssize_t ssl_write(conn *c, void *buf, size_t count);",12.0,12.0,9.0,51.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,ssize_t
2046,97546,ssl_init,1,ssl_init,int ssl_init (void),tls.h,int ssl_init(void);,14.0,14.0,5.0,18.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
2047,97551,refresh_certs,1,refresh_certs,bool refresh_certs (char**),tls.h,bool refresh_certs(char **errmsg);,15.0,15.0,6.0,33.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,bool
2048,97556,ssl_callback,1,ssl_callback,"void ssl_callback (SSL*,int,int)",tls.h,"void ssl_callback(const SSL *s, int where, int ret);",16.0,16.0,6.0,51.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,void
2049,97563,ssl_new_session_callback,1,ssl_new_session_callback,"int ssl_new_session_callback (SSL*,SSL_SESSION*)",tls.h,"int ssl_new_session_callback(SSL *s, SSL_SESSION *sess);",17.0,17.0,5.0,55.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
2050,97569,ssl_proto_text,1,ssl_proto_text,char* ssl_proto_text (int),tls.h,const char *ssl_proto_text(int version);,18.0,18.0,12.0,39.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,char*
2051,97608,uriencode_init,1,uriencode_init,void uriencode_init (void),util.c,"void uriencode_init(void) {
    int x;
    char *str = uriencode_str;
    for (x = 0; x < 256; x++) {
        if (isalnum(x) || x == '-' || x == '.' || x == '_' || x == '~') {
            uriencode_map[x] = NULL;
        } else {
            snprintf(str, 4, ""%%%02hhX"", (unsigned char)x);
            uriencode_map[x] = str;
            str += 3; /* lobbing off the \0 is fine */
        }
    }
}",14.0,26.0,1.0,1.0,13.0,13,5,12,5,1,2,3,4,0,0,,0,2,2,1,1,void
2052,97671,uriencode,1,uriencode,"bool uriencode (char*,char*,size_t,size_t)",util.c,"bool uriencode(const char *src, char *dst, const size_t srclen, const size_t dstlen) {
    int x;
    size_t d = 0;
    for (x = 0; x < srclen; x++) {
        if (d + 4 > dstlen)
            return false;
        if (uriencode_map[(unsigned char) src[x]] != NULL) {
            memcpy(&dst[d], uriencode_map[(unsigned char) src[x]], 3);
            d += 3;
        } else {
            dst[d] = src[x];
            d++;
        }
    }
    dst[d] = '\0';
    return true;
}",28.0,44.0,1.0,1.0,17.0,17,9,20,10,3,2,4,6,1,0,,0,2,8,4,4,bool
2053,97749,safe_strtoull,1,safe_strtoull,"bool safe_strtoull (char*,uint64_t*)",util.c,"bool safe_strtoull(const char *str, uint64_t *out) {
    assert(out != NULL);
    errno = 0;
    *out = 0;
    char *endptr;
    unsigned long long ull = strtoull(str, &endptr, 10);
    if ((errno == ERANGE) || (str == endptr)) {
        return false;
    }

    if (xisspace(*endptr) || (*endptr == '\0' && endptr != str)) {
        if ((long long) ull < 0) {
            /* only check for negative signs in the uncommon case when
             * the unsigned number is so big that it's negative as a
             * signed number. */
            if (strchr(str, '-') != NULL) {
                return false;
            }
        }
        *out = ull;
        return true;
    }
    return false;
}",49.0,72.0,1.0,8.0,24.0,22,9,25,9,19,0,5,8,0,0,,0,0,4,2,2,bool
2054,97830,safe_strtoull_hex,1,safe_strtoull_hex,"bool safe_strtoull_hex (char*,uint64_t*)",util.c,"bool safe_strtoull_hex(const char *str, uint64_t *out) {
    assert(out != NULL);
    errno = 0;
    *out = 0;
    char *endptr;
    unsigned long long ull = strtoull(str, &endptr, 16);
    if ((errno == ERANGE) || (str == endptr)) {
        return false;
    }

    if (xisspace(*endptr) || (*endptr == '\0' && endptr != str)) {
        if ((long long) ull < 0) {
            /* only check for negative signs in the uncommon case when
             * the unsigned number is so big that it's negative as a
             * signed number. */
            if (strchr(str, '-') != NULL) {
                return false;
            }
        }
        *out = ull;
        return true;
    }
    return false;
}",79.0,102.0,1.0,8.0,24.0,22,9,25,9,1,0,5,8,0,0,,0,0,4,2,2,bool
2055,97911,safe_strtoll,1,safe_strtoll,"bool safe_strtoll (char*,int64_t*)",util.c,"bool safe_strtoll(const char *str, int64_t *out) {
    assert(out != NULL);
    errno = 0;
    *out = 0;
    char *endptr;
    long long ll = strtoll(str, &endptr, 10);
    if ((errno == ERANGE) || (str == endptr)) {
        return false;
    }

    if (xisspace(*endptr) || (*endptr == '\0' && endptr != str)) {
        *out = ll;
        return true;
    }
    return false;
}",104.0,119.0,1.0,8.0,16.0,19,8,21,9,14,0,3,3,0,0,,0,0,4,2,2,bool
2056,97976,safe_strtoul,1,safe_strtoul,"bool safe_strtoul (char*,uint32_t*)",util.c,"bool safe_strtoul(const char *str, uint32_t *out) {
    char *endptr = NULL;
    unsigned long l = 0;
    assert(out);
    assert(str);
    *out = 0;
    errno = 0;

    l = strtoul(str, &endptr, 10);
    if ((errno == ERANGE) || (str == endptr)) {
        return false;
    }

    if (xisspace(*endptr) || (*endptr == '\0' && endptr != str)) {
        if ((long) l < 0) {
            /* only check for negative signs in the uncommon case when
             * the unsigned number is so big that it's negative as a
             * signed number. */
            if (strchr(str, '-') != NULL) {
                return false;
            }
        }
        *out = l;
        return true;
    }

    return false;
}",121.0,148.0,1.0,8.0,28.0,23,9,28,9,23,0,5,8,0,0,,0,0,4,2,2,bool
2057,98063,safe_strtol,1,safe_strtol,"bool safe_strtol (char*,int32_t*)",util.c,"bool safe_strtol(const char *str, int32_t *out) {
    assert(out != NULL);
    errno = 0;
    *out = 0;
    char *endptr;
    long l = strtol(str, &endptr, 10);
    if ((errno == ERANGE) || (str == endptr)) {
        return false;
    }

    if (xisspace(*endptr) || (*endptr == '\0' && endptr != str)) {
        *out = l;
        return true;
    }
    return false;
}",150.0,165.0,1.0,8.0,16.0,19,8,21,9,27,0,3,3,0,0,,0,0,4,2,2,bool
2058,98128,safe_strtod,1,safe_strtod,"bool safe_strtod (char*,double*)",util.c,"bool safe_strtod(const char *str, double *out) {
    assert(out != NULL);
    errno = 0;
    *out = 0;
    char *endptr;
    double d = strtod(str, &endptr);
    if ((errno == ERANGE) || (str == endptr)) {
        return false;
    }

    if (xisspace(*endptr) || (*endptr == '\0' && endptr != str)) {
        *out = d;
        return true;
    }
    return false;
}",167.0,182.0,1.0,8.0,16.0,19,8,21,9,3,0,3,3,0,0,,0,0,4,2,2,bool
2059,98192,safe_strcpy,1,safe_strcpy,"bool safe_strcpy (char*,char*,size_t)",util.c,"bool safe_strcpy(char *dst, const char *src, const size_t dstmax) {
   size_t x;

   for (x = 0; x < dstmax - 1 && src[x] != '\0'; x++) {
        dst[x] = src[x];
   }

   dst[x] = '\0';

   if (src[x] == '\0') {
       return true;
   } else {
       return false;
   }
}",190.0,204.0,1.0,1.0,15.0,13,7,14,5,1,0,3,3,0,0,,0,0,6,3,3,bool
2060,98244,safe_memcmp,1,safe_memcmp,"bool safe_memcmp (void*,void*,size_t)",util.c,"bool safe_memcmp(const void *a, const void *b, size_t len) {
    const volatile unsigned char *ua = (const volatile unsigned char *)a;
    const volatile unsigned char *ub = (const volatile unsigned char *)b;
    int delta = 0;
    size_t x;

    for (x = 0; x < len; x++) {
        delta |= ua[x] ^ ub[x];
    }

    if (delta == 0) {
        return true;
    } else {
        return false;
    }
}",206.0,221.0,1.0,1.0,16.0,11,6,15,8,2,0,3,3,0,0,,0,0,6,3,3,bool
2061,98299,vperror,1,vperror,void vperror (char*...),util.c,"void vperror(const char *fmt, ...) {
    int old_errno = errno;
    char buf[1024];
    va_list ap;

    va_start(ap, fmt);
    if (vsnprintf(buf, sizeof(buf), fmt, ap) == -1) {
        buf[sizeof(buf) - 1] = '\0';
    }
    va_end(ap);

    errno = old_errno;

    perror(buf);
}",223.0,237.0,1.0,1.0,15.0,9,6,14,5,10,0,2,2,0,0,,0,0,2,1,1,void
2062,98339,mc_swap64,1,mc_swap64,uint64_t mc_swap64 (uint64_t),util.c,"static uint64_t mc_swap64(uint64_t in) {
#ifdef ENDIAN_LITTLE
    /* Little endian, flip the bytes around until someone makes a faster/better
    * way to do this. */
    int64_t rv = 0;
    int i = 0;
     for(i = 0; i<8; i++) {
        rv = (rv << 8) | (in & 0xff);
        in >>= 8;
     }
    return rv;
#else
    /* big-endian machines don't need byte swapping */
    return in;
#endif
}",240.0,255.0,1.0,1.0,16.0,0,0,1,1,2,0,1,1,0,0,,0,0,2,1,1,uint64_t
2063,98346,ntohll,1,ntohll,uint64_t ntohll (uint64_t),util.c,"uint64_t ntohll(uint64_t val) {
   return mc_swap64(val);
}",257.0,259.0,1.0,1.0,3.0,0,0,1,1,3,1,1,1,0,1,,0,0,2,1,1,uint64_t
2064,98354,htonll,1,htonll,uint64_t htonll (uint64_t),util.c,"uint64_t htonll(uint64_t val) {
   return mc_swap64(val);
}",261.0,263.0,1.0,1.0,3.0,0,0,1,1,3,1,1,1,0,1,,0,0,2,1,1,uint64_t
2065,98474,show_response_buffer,1,show_response_buffer,"void show_response_buffer (void*,char*,size_t)",vendor\mcmc\example.c,"static void show_response_buffer(void *c, char *rbuf, size_t bufsize) {
    int status;
    mcmc_resp_t resp;
    char *val = NULL;

    do {
        int bread = recv(mcmc_fd(c), rbuf, bufsize, 0);

        // need to know how far to advance the buffer.
        // resp->reslen + resp->vlen_read works, but feels awkward.
        status = mcmc_parse_buf(c, rbuf, bread, &resp);
    } while (status == MCMC_WANT_READ);

    if (status != MCMC_OK) {
        printf(""bad response\n"");
    }

    // now we need to read the value back.
    // resp.reslen + resp.vlen is the total length.
    // resp.reslen + resp.vlen_read is how much of the buffer was used.
    // resp.vlen_read vs resp.vlen is how much was read vs how much still
    // needs to be read from the socket.
    if (resp.vlen != resp.vlen_read) {
        // malloc and recv the rest.
        // can/should add convenience functions for this?
        val = malloc(resp.vlen);
        memcpy(val, resp.value, resp.vlen_read);
        si...",16.0,56.0,1.0,23.0,41.0,23,9,34,11,1,11,5,6,2,3,,0,11,6,3,3,void
2066,98588,buffer_mode,1,buffer_mode,void buffer_mode (void),vendor\mcmc\example.c,"void buffer_mode(void) {
    void *c = malloc(mcmc_size(MCMC_OPTION_BLANK));
    size_t bufsize = mcmc_min_buffer_size(MCMC_OPTION_BLANK) * 2;
    char *rbuf = malloc(bufsize);

    int status = mcmc_connect(c, ""127.0.0.1"", ""11211"", MCMC_OPTION_BLANK);

    char *requests[5] = {""get foo\r\n"",
        ""get foob\r\n"",
        ""mg foo s t v\r\n"",
        ""mg doof s t v Omoo k\r\n"",
        """"};

    for (int x = 0; strlen(requests[x]) != 0; x++) {
        status = mcmc_send_request(c, requests[x], strlen(requests[x]), 1);

        if (status != MCMC_OK) {
            fprintf(stderr, ""Failed to send request to memcached\n"");
            return;
        }

        // Regardless of what command we sent, this should print out the response.
        show_response_buffer(c, rbuf, bufsize);
    }

}",145.0,170.0,1.0,31.0,26.0,14,5,21,7,0,5,3,4,0,5,,0,4,2,1,1,void
2067,98743,_mcmc_parse_value_line,1,_mcmc_parse_value_line,"int _mcmc_parse_value_line (mcmc_ctx_t*,mcmc_resp_t*)",vendor\mcmc\mcmc.c,"static int _mcmc_parse_value_line(mcmc_ctx_t *ctx, mcmc_resp_t *r) {
    char *buf = ctx->buffer_head;
    // we know that ""VALUE "" has matched, so skip that.
    char *p = buf+6;
    size_t l = ctx->buffer_request_len;

    // <key> <flags> <bytes> [<cas unique>]
    char *key = p;
    int keylen;
    p = memchr(p, ' ', l - 6);
    if (p == NULL) {
        // FIXME: these should return MCMC_ERR and set the internal parse
        // error code.
        return MCMC_PARSE_ERROR;
    }

    keylen = p - key;

    // convert flags into something useful.
    // FIXME: do we need to prevent overruns in strtoul?
    // we know for sure the line will eventually end in a \n.
    char *n = NULL;
    errno = 0;
    uint32_t flags = strtoul(p, &n, 10);
    if ((errno == ERANGE) || (p == n) || (*n != ' ')) {
        return MCMC_PARSE_ERROR;
    }
    p = n;

    errno = 0;
    uint32_t bytes = strtoul(p, &n, 10);
    if ((errno == ERANGE) || (p == n)) {
        return MCMC_PARSE_ERROR;
    }
   ...",54.0,120.0,1.0,15.0,67.0,65,10,69,15,1,6,7,8,1,0,,0,6,4,2,2,int
2068,98970,_mcmc_parse_response,1,_mcmc_parse_response,"int _mcmc_parse_response (mcmc_ctx_t*,mcmc_resp_t*)",vendor\mcmc\mcmc.c,"static int _mcmc_parse_response(mcmc_ctx_t *ctx, mcmc_resp_t *r) {
    char *buf = ctx->buffer_head;
    char *cur = buf;
    size_t l = ctx->buffer_request_len;
    int rlen; // response code length.
    int more = 0;
    r->reslen = ctx->buffer_request_len;
    r->type = MCMC_RESP_GENERIC;

    // walk until the \r\n
    while (l-- > 2) {
        if (*cur == ' ') {
            more = 1;
            break;
        }
        cur++;
    }
    rlen = cur - buf;

    // incr/decr returns a number with no code :(
    // not checking length first since buf must have at least one char to
    // enter this function.
    if (buf[0] >= '0' && buf[0] <= '9') {
        // TODO: parse it as a number on request.
        // TODO: validate whole thing as digits here?
        ctx->status_flags |= FLAG_BUF_IS_NUMERIC;
        r->type = MCMC_RESP_NUMERIC;
        return MCMC_OK;
    }

    if (rlen < 2) {
        ctx->error = MCMC_PARSE_ERROR_SHORT;
        return MCMC_ERR;
    }

    int rv = MCMC_O...",125.0,321.0,1.0,14.0,197.0,98,17,83,14,1,9,41,56,0,1,,0,9,4,2,2,int
2069,99598,mcmc_fd,1,mcmc_fd,int mcmc_fd (void*),vendor\mcmc\mcmc.c,"int mcmc_fd(void *c) {
    mcmc_ctx_t *ctx = (mcmc_ctx_t *)c;
    return ctx->fd;
}",325.0,328.0,1.0,1.0,4.0,3,3,3,2,2,0,1,1,0,0,,0,0,2,1,1,int
2070,99613,mcmc_size,1,mcmc_size,size_t mcmc_size (int),vendor\mcmc\mcmc.c,"size_t mcmc_size(int options) {
    return sizeof(mcmc_ctx_t);
}",330.0,332.0,1.0,1.0,3.0,1,1,1,1,2,0,1,1,0,0,,0,0,2,1,1,size_t
2071,99621,mcmc_min_buffer_size,1,mcmc_min_buffer_size,size_t mcmc_min_buffer_size (int),vendor\mcmc\mcmc.c,"size_t mcmc_min_buffer_size(int options) {
    return MIN_BUFFER_SIZE;
}",337.0,339.0,1.0,11.0,3.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,size_t
2072,99630,mcmc_parse_buf,1,mcmc_parse_buf,"int mcmc_parse_buf (void*,char*,size_t,mcmc_resp_t*)",vendor\mcmc\mcmc.c,"int mcmc_parse_buf(void *c, char *buf, size_t read, mcmc_resp_t *r) {
    mcmc_ctx_t *ctx = c;
    char *el;

    el = memchr(buf, '\n', read);
    if (el == NULL) {
        return MCMC_WANT_READ;
    }

    memset(r, 0, sizeof(*r));

    // Consume through the newline, note where the value would start if exists
    r->value = el+1;

    ctx->buffer_used = read;
    // FIXME: the server must be stricter in what it sends back. should always
    // have a \r. check for it and fail?
    ctx->buffer_request_len = r->value - buf;
    // leave the \r\n in the line end cache.
    ctx->buffer_head = buf;

    return _mcmc_parse_response(ctx, r);
}",347.0,369.0,1.0,15.0,23.0,16,7,20,7,1,3,2,2,0,1,,0,2,8,4,4,int
2073,99694,mcmc_check_nonblock_connect,1,mcmc_check_nonblock_connect,"int mcmc_check_nonblock_connect (void*,int*)",vendor\mcmc\mcmc.c,"int mcmc_check_nonblock_connect(void *c, int *err) {
    mcmc_ctx_t *ctx = (mcmc_ctx_t *)c;
    socklen_t errsize = sizeof(*err);
    if (getsockopt(ctx->fd, SOL_SOCKET, SO_ERROR, err, &errsize) == 0) {
        if (*err == 0) {
            return MCMC_OK;
        }
    } else {
        // getsockopt failed. still need to pass up the error.
        *err = errno;
    }

    return MCMC_ERR;
}",376.0,389.0,1.0,19.0,14.0,11,8,10,6,0,0,3,4,0,0,,0,0,4,2,2,int
2074,99746,mcmc_connect,1,mcmc_connect,"int mcmc_connect (void*,char*,char*,int)",vendor\mcmc\mcmc.c,"int mcmc_connect(void *c, char *host, char *port, int options) {
    mcmc_ctx_t *ctx = (mcmc_ctx_t *)c;

    int s;
    int sock;
    int res = MCMC_CONNECTED;
    struct addrinfo hints;
    struct addrinfo *ai;
    struct addrinfo *next;

    // Since our cx memory was likely malloc'ed, ensure we start clear.
    memset(ctx, 0, sizeof(mcmc_ctx_t));
    memset(&hints, 0, sizeof(hints));
    hints.ai_family = AF_INET;
    hints.ai_socktype = SOCK_STREAM;

    s = getaddrinfo(host, port, &hints, &ai);

    if (s != 0) {
        hints.ai_family = AF_INET6;
        s = getaddrinfo(host, port, &hints, &ai);
        if (s != 0) {
            // TODO: gai_strerror(s)
            ctx->gai_status = s;
            res = MCMC_ERR;
            goto end;
        }
    }

    for (next = ai; next != NULL; next = next->ai_next) {
        sock = socket(next->ai_family, next->ai_socktype,
                next->ai_protocol);
        if (sock == -1)
            continue;

        if (options & MCMC_OP...",397.0,483.0,1.0,14.0,87.0,60,13,74,25,2,0,22,29,0,0,,0,0,8,4,4,int
2075,100018,mcmc_send_request,1,mcmc_send_request,"int mcmc_send_request (void*,char*,int,int)",vendor\mcmc\mcmc.c,"int mcmc_send_request(void *c, const char *request, int len, int count) {
    mcmc_ctx_t *ctx = (mcmc_ctx_t *)c;

    // adjust our send buffer by how much has already been sent.
    const char *r = request + ctx->sent_bytes_partial;
    int l = len - ctx->sent_bytes_partial;
    int sent = send(ctx->fd, r, l, 0);
    if (sent == -1) {
        // implicitly handle nonblock mode.
        if (errno == EAGAIN || errno == EWOULDBLOCK) {
            return MCMC_WANT_WRITE;
        } else {
            return MCMC_ERR;
        }
    }

    if (sent < len) {
        // can happen anytime, but mostly in nonblocking mode.
        ctx->sent_bytes_partial += sent;
        return MCMC_WANT_WRITE;
    } else {
        ctx->sent_bytes_partial = 0;
    }

    return MCMC_OK;
}",488.0,513.0,1.0,19.0,26.0,18,10,21,10,1,0,4,5,0,0,,0,0,8,4,4,int
2076,100109,mcmc_request_writev,1,mcmc_request_writev,"int mcmc_request_writev (void*,iovec*,int,ssize_t*,int)",vendor\mcmc\mcmc.c,"int mcmc_request_writev(void *c, const struct iovec *iov, int iovcnt, ssize_t *sent, int count) {
    mcmc_ctx_t *ctx = (mcmc_ctx_t *)c;
    // need to track sent vs tosend to know when to update counters.
    ssize_t tosend = 0;
    for (int i = 0; i < iovcnt; i++) {
        tosend += iov[i].iov_len;
    }

    *sent = writev(ctx->fd, iov, iovcnt);
    if (*sent == -1) {
        // implicitly handle nonblock mode.
        if (errno == EAGAIN || errno == EWOULDBLOCK) {
            return MCMC_WANT_WRITE;
        } else {
            return MCMC_ERR;
        }
    }

    if (*sent < tosend) {
        // can happen anytime, but mostly in nonblocking mode.
        return MCMC_WANT_WRITE;
    }

    return MCMC_OK;
}",518.0,542.0,1.0,19.0,25.0,19,11,20,10,0,0,5,6,0,0,,0,0,10,5,5,int
2077,100197,mcmc_get_error,1,mcmc_get_error,"void mcmc_get_error (void*,char*,size_t,char*,size_t)",vendor\mcmc\mcmc.c,"void mcmc_get_error(void *c, char *code, size_t clen, char *msg, size_t mlen) {
    code[0] = '\0';
    msg[0] = '\0';
}",609.0,612.0,1.0,1.0,4.0,4,2,2,2,0,0,1,1,0,0,,0,0,10,5,5,void
2078,100216,mcmc_disconnect,1,mcmc_disconnect,int mcmc_disconnect (void*),vendor\mcmc\mcmc.c,"int mcmc_disconnect(void *c) {
    mcmc_ctx_t *ctx = (mcmc_ctx_t *)c;

    // FIXME: I forget if 0 can be valid.
    if (ctx->fd != 0) {
        close(ctx->fd);
        return MCMC_OK;
    } else {
        return MCMC_NOT_CONNECTED;
    }
}",659.0,669.0,1.0,15.0,11.0,5,4,4,2,1,0,2,2,0,0,,0,0,2,1,1,int
2079,100386,XXH_versionNumber,1,XXH_versionNumber,unsigned XXH_versionNumber (void),xxhash.h,unsigned XXH_versionNumber (void);,280.0,280.0,25.0,48.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,unsigned
2080,100403,XXH32,1,XXH32,"XXH32_hash_t XXH32 (void*,size_t,XXH32_hash_t)",xxhash.h,"XXH32_hash_t XXH32 (const void* input, size_t length, XXH32_hash_t seed);",358.0,358.0,29.0,87.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,XXH32_hash_t
2081,100412,XXH32_createState,1,XXH32_createState,XXH32_state_t* XXH32_createState (void),xxhash.h,XXH32_state_t* XXH32_createState(void);,424.0,424.0,29.0,53.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,XXH32_state_t*
2082,100417,XXH32_freeState,1,XXH32_freeState,XXH_errorcode XXH32_freeState (XXH32_state_t*),xxhash.h,XXH_errorcode  XXH32_freeState(XXH32_state_t* statePtr);,432.0,432.0,31.0,70.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,XXH_errorcode
2083,100422,XXH32_copyState,1,XXH32_copyState,"void XXH32_copyState (XXH32_state_t*,XXH32_state_t*)",xxhash.h,"void XXH32_copyState(XXH32_state_t* dst_state, const XXH32_state_t* src_state);",441.0,441.0,21.0,93.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
2084,100428,XXH32_reset,1,XXH32_reset,"XXH_errorcode XXH32_reset (XXH32_state_t*,XXH32_hash_t)",xxhash.h,"XXH_errorcode XXH32_reset  (XXH32_state_t* statePtr, XXH32_hash_t seed);",456.0,456.0,30.0,86.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,XXH_errorcode
2085,100434,XXH32_update,1,XXH32_update,"XXH_errorcode XXH32_update (XXH32_state_t*,void*,size_t)",xxhash.h,"XXH_errorcode XXH32_update (XXH32_state_t* statePtr, const void* input, size_t length);",476.0,476.0,30.0,101.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,XXH_errorcode
2086,100441,XXH32_digest,1,XXH32_digest,XXH32_hash_t XXH32_digest (XXH32_state_t*),xxhash.h,XXH32_hash_t  XXH32_digest (const XXH32_state_t* statePtr);,492.0,492.0,30.0,73.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,XXH32_hash_t
2087,100455,XXH32_canonicalFromHash,1,XXH32_canonicalFromHash,"void XXH32_canonicalFromHash (XXH32_canonical_t*,XXH32_hash_t)",xxhash.h,"void XXH32_canonicalFromHash(XXH32_canonical_t* dst, XXH32_hash_t hash);",531.0,531.0,21.0,86.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
2088,100461,XXH32_hashFromCanonical,1,XXH32_hashFromCanonical,XXH32_hash_t XXH32_hashFromCanonical (XXH32_canonical_t*),xxhash.h,XXH32_hash_t XXH32_hashFromCanonical(const XXH32_canonical_t* src);,543.0,543.0,29.0,81.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,XXH32_hash_t
2089,100467,XXH64,1,XXH64,"XXH64_hash_t XXH64 (void*,size_t,XXH64_hash_t)",xxhash.h,"XXH64_hash_t XXH64(const void* input, size_t length, XXH64_hash_t seed);",617.0,617.0,29.0,86.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,XXH64_hash_t
2090,100476,XXH64_createState,1,XXH64_createState,XXH64_state_t* XXH64_createState (void),xxhash.h,XXH64_state_t* XXH64_createState(void);,626.0,626.0,29.0,53.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,XXH64_state_t*
2091,100481,XXH64_freeState,1,XXH64_freeState,XXH_errorcode XXH64_freeState (XXH64_state_t*),xxhash.h,XXH_errorcode  XXH64_freeState(XXH64_state_t* statePtr);,627.0,627.0,31.0,70.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,XXH_errorcode
2092,100486,XXH64_copyState,1,XXH64_copyState,"void XXH64_copyState (XXH64_state_t*,XXH64_state_t*)",xxhash.h,"void XXH64_copyState(XXH64_state_t* dst_state, const XXH64_state_t* src_state);",628.0,628.0,21.0,93.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
2093,100492,XXH64_reset,1,XXH64_reset,"XXH_errorcode XXH64_reset (XXH64_state_t*,XXH64_hash_t)",xxhash.h,"XXH_errorcode XXH64_reset  (XXH64_state_t* statePtr, XXH64_hash_t seed);",630.0,630.0,30.0,86.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,XXH_errorcode
2094,100498,XXH64_update,1,XXH64_update,"XXH_errorcode XXH64_update (XXH64_state_t*,void*,size_t)",xxhash.h,"XXH_errorcode XXH64_update (XXH64_state_t* statePtr, const void* input, size_t length);",631.0,631.0,30.0,101.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,XXH_errorcode
2095,100505,XXH64_digest,1,XXH64_digest,XXH64_hash_t XXH64_digest (XXH64_state_t*),xxhash.h,XXH64_hash_t  XXH64_digest (const XXH64_state_t* statePtr);,632.0,632.0,30.0,73.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,XXH64_hash_t
2096,100520,XXH64_canonicalFromHash,1,XXH64_canonicalFromHash,"void XXH64_canonicalFromHash (XXH64_canonical_t*,XXH64_hash_t)",xxhash.h,"void XXH64_canonicalFromHash(XXH64_canonical_t* dst, XXH64_hash_t hash);",636.0,636.0,21.0,86.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
2097,100526,XXH64_hashFromCanonical,1,XXH64_hashFromCanonical,XXH64_hash_t XXH64_hashFromCanonical (XXH64_canonical_t*),xxhash.h,XXH64_hash_t XXH64_hashFromCanonical(const XXH64_canonical_t* src);,637.0,637.0,29.0,81.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,XXH64_hash_t
2098,100531,XXH3_64bits,1,XXH3_64bits,"XXH64_hash_t XXH3_64bits (void*,size_t)",xxhash.h,"XXH64_hash_t XXH3_64bits(const void* data, size_t len);",691.0,691.0,29.0,69.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,XXH64_hash_t
2099,100537,XXH3_64bits_withSeed,1,XXH3_64bits_withSeed,"XXH64_hash_t XXH3_64bits_withSeed (void*,size_t,XXH64_hash_t)",xxhash.h,"XXH64_hash_t XXH3_64bits_withSeed(const void* data, size_t len, XXH64_hash_t seed);",700.0,700.0,29.0,97.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,XXH64_hash_t
2100,100544,XXH3_64bits_withSecret,1,XXH3_64bits_withSecret,"XXH64_hash_t XXH3_64bits_withSecret (void*,size_t,void*,size_t)",xxhash.h,"XXH64_hash_t XXH3_64bits_withSecret(const void* data, size_t len, const void* secret, size_t secretSize);",724.0,724.0,29.0,119.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,XXH64_hash_t
2101,100554,XXH3_createState,1,XXH3_createState,XXH3_state_t* XXH3_createState (void),xxhash.h,XXH3_state_t* XXH3_createState(void);,741.0,741.0,28.0,51.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,XXH3_state_t*
2102,100559,XXH3_freeState,1,XXH3_freeState,XXH_errorcode XXH3_freeState (XXH3_state_t*),xxhash.h,XXH_errorcode XXH3_freeState(XXH3_state_t* statePtr);,742.0,742.0,30.0,67.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,XXH_errorcode
2103,100564,XXH3_copyState,1,XXH3_copyState,"void XXH3_copyState (XXH3_state_t*,XXH3_state_t*)",xxhash.h,"void XXH3_copyState(XXH3_state_t* dst_state, const XXH3_state_t* src_state);",743.0,743.0,21.0,90.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
2104,100570,XXH3_64bits_reset,1,XXH3_64bits_reset,XXH_errorcode XXH3_64bits_reset (XXH3_state_t*),xxhash.h,XXH_errorcode XXH3_64bits_reset(XXH3_state_t* statePtr);,750.0,750.0,30.0,70.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,XXH_errorcode
2105,100575,XXH3_64bits_reset_withSeed,1,XXH3_64bits_reset_withSeed,"XXH_errorcode XXH3_64bits_reset_withSeed (XXH3_state_t*,XXH64_hash_t)",xxhash.h,"XXH_errorcode XXH3_64bits_reset_withSeed(XXH3_state_t* statePtr, XXH64_hash_t seed);",756.0,756.0,30.0,98.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,XXH_errorcode
2106,100581,XXH3_64bits_reset_withSecret,1,XXH3_64bits_reset_withSecret,"XXH_errorcode XXH3_64bits_reset_withSecret (XXH3_state_t*,void*,size_t)",xxhash.h,"XXH_errorcode XXH3_64bits_reset_withSecret(XXH3_state_t* statePtr, const void* secret, size_t secretSize);",766.0,766.0,30.0,120.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,XXH_errorcode
2107,100588,XXH3_64bits_update,1,XXH3_64bits_update,"XXH_errorcode XXH3_64bits_update (XXH3_state_t*,void*,size_t)",xxhash.h,"XXH_errorcode XXH3_64bits_update (XXH3_state_t* statePtr, const void* input, size_t length);",768.0,768.0,30.0,106.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,XXH_errorcode
2108,100595,XXH3_64bits_digest,1,XXH3_64bits_digest,XXH64_hash_t XXH3_64bits_digest (XXH3_state_t*),xxhash.h,XXH64_hash_t  XXH3_64bits_digest (const XXH3_state_t* statePtr);,769.0,769.0,30.0,78.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,XXH64_hash_t
2109,100604,XXH3_128bits,1,XXH3_128bits,"XXH128_hash_t XXH3_128bits (void*,size_t)",xxhash.h,"XXH128_hash_t XXH3_128bits(const void* data, size_t len);",790.0,790.0,30.0,71.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,XXH128_hash_t
2110,100610,XXH3_128bits_withSeed,1,XXH3_128bits_withSeed,"XXH128_hash_t XXH3_128bits_withSeed (void*,size_t,XXH64_hash_t)",xxhash.h,"XXH128_hash_t XXH3_128bits_withSeed(const void* data, size_t len, XXH64_hash_t seed);",791.0,791.0,30.0,99.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,XXH128_hash_t
2111,100617,XXH3_128bits_withSecret,1,XXH3_128bits_withSecret,"XXH128_hash_t XXH3_128bits_withSecret (void*,size_t,void*,size_t)",xxhash.h,"XXH128_hash_t XXH3_128bits_withSecret(const void* data, size_t len, const void* secret, size_t secretSize);",792.0,792.0,30.0,121.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,XXH128_hash_t
2112,100625,XXH3_128bits_reset,1,XXH3_128bits_reset,XXH_errorcode XXH3_128bits_reset (XXH3_state_t*),xxhash.h,XXH_errorcode XXH3_128bits_reset(XXH3_state_t* statePtr);,807.0,807.0,30.0,71.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,XXH_errorcode
2113,100630,XXH3_128bits_reset_withSeed,1,XXH3_128bits_reset_withSeed,"XXH_errorcode XXH3_128bits_reset_withSeed (XXH3_state_t*,XXH64_hash_t)",xxhash.h,"XXH_errorcode XXH3_128bits_reset_withSeed(XXH3_state_t* statePtr, XXH64_hash_t seed);",808.0,808.0,30.0,99.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,XXH_errorcode
2114,100636,XXH3_128bits_reset_withSecret,1,XXH3_128bits_reset_withSecret,"XXH_errorcode XXH3_128bits_reset_withSecret (XXH3_state_t*,void*,size_t)",xxhash.h,"XXH_errorcode XXH3_128bits_reset_withSecret(XXH3_state_t* statePtr, const void* secret, size_t secretSize);",809.0,809.0,30.0,121.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,XXH_errorcode
2115,100643,XXH3_128bits_update,1,XXH3_128bits_update,"XXH_errorcode XXH3_128bits_update (XXH3_state_t*,void*,size_t)",xxhash.h,"XXH_errorcode XXH3_128bits_update (XXH3_state_t* statePtr, const void* input, size_t length);",811.0,811.0,30.0,107.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,XXH_errorcode
2116,100650,XXH3_128bits_digest,1,XXH3_128bits_digest,XXH128_hash_t XXH3_128bits_digest (XXH3_state_t*),xxhash.h,XXH128_hash_t XXH3_128bits_digest (const XXH3_state_t* statePtr);,812.0,812.0,30.0,79.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,XXH128_hash_t
2117,100655,XXH128_isEqual,1,XXH128_isEqual,"int XXH128_isEqual (XXH128_hash_t,XXH128_hash_t)",xxhash.h,"int XXH128_isEqual(XXH128_hash_t h1, XXH128_hash_t h2);",822.0,822.0,20.0,69.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
2118,100661,XXH128_cmp,1,XXH128_cmp,"int XXH128_cmp (void*,void*)",xxhash.h,"int XXH128_cmp(const void* h128_1, const void* h128_2);",833.0,833.0,20.0,69.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
2119,100677,XXH128_canonicalFromHash,1,XXH128_canonicalFromHash,"void XXH128_canonicalFromHash (XXH128_canonical_t*,XXH128_hash_t)",xxhash.h,"void XXH128_canonicalFromHash(XXH128_canonical_t* dst, XXH128_hash_t hash);",838.0,838.0,21.0,89.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
2120,100683,XXH128_hashFromCanonical,1,XXH128_hashFromCanonical,XXH128_hash_t XXH128_hashFromCanonical (XXH128_canonical_t*),xxhash.h,XXH128_hash_t XXH128_hashFromCanonical(const XXH128_canonical_t* src);,839.0,839.0,30.0,84.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,XXH128_hash_t
2121,861,assoc_iterator,4,assoc_iterator,,assoc.c,"struct assoc_iterator {
    uint64_t bucket;
    item *it;
    item *next;
    bool bucket_locked;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2122,1162,auth_entry,4,auth_entry,,authfile.c,"typedef struct auth_entry {
    char *user;
    size_t ulen;
    char *pass;
    size_t plen;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2123,1167,auth_t,4,auth_t,,authfile.c,"typedef struct auth_entry {
    char *user;
    size_t ulen;
    char *pass;
    size_t plen;
} auth_t;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2124,1496,authfile_ret,4,authfile_ret,,authfile.h,"enum authfile_ret {
    AUTHFILE_OK = 0,
    AUTHFILE_OOM,
    AUTHFILE_STATFAIL, // not likely, but just to be sure
    AUTHFILE_OPENFAIL,
    AUTHFILE_MALFORMED,
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2125,1509,authfile_ret,4,authfile_ret,,authfile.h,enum authfile_ret,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2126,2709,bipbuf_t,4,bipbuf_t,,bipbuffer.h,"typedef struct
{
    unsigned long int size;

    /* region A */
    unsigned int a_start, a_end;

    /* region B */
    unsigned int b_end;

    /* is B inuse? */
    int b_inuse;

    unsigned char data[];
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2127,3392,cache_free_s,4,cache_free_s,,cache.h,"struct cache_free_s {
    STAILQ_ENTRY(cache_free_s) c_next;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2128,3393,cache_free_s.c_next,4,cache_free_s.c_next,,cache.h,STAILQ_ENTRY(cache_free_s),-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2129,3394,cache_free_s,4,cache_free_s.c_next.cache_free_s,,cache.h,cache_free_s,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2130,3397,cache_t,4,cache_t,,cache.h,"typedef struct {
    /** Mutex to protect access to the structure */
    pthread_mutex_t mutex;
    /** Name of the cache objects in this cache (provided by the caller) */
    char *name;
    /** freelist of available buffers */
    STAILQ_HEAD(cache_head, cache_free_s) head;
    /** The size of each element in this cache */
    size_t bufsize;
    /** The capacity of the list of elements */
    int freetotal;
    /** Total malloc'ed objects */
    int total;
    /** The current number of free elements */
    int freecurr;
    /** A limit on the total number of elements */
    int limit;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2131,3400,cache_head,4,cache_t.cache_head,,cache.h,cache_head,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2132,3401,cache_free_s,4,cache_t.cache_head.cache_free_s,,cache.h,cache_free_s,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2133,3403,cache_free_s,4,cache_t.cache_head.cache_free_s,,cache.h,cache_free_s,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2134,3489,crawler_client_t,4,crawler_client_t,,crawler.c,"typedef struct {
    void *c; /* original connection structure. still with source thread attached. */
    int sfd; /* client fd. */
    bipbuf_t *buf; /* output buffer */
    char *cbuf; /* current buffer */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2135,3495,_crawler_module_t,4,_crawler_module_t,,crawler.c,typedef struct _crawler_module_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2136,3496,crawler_module_t,4,crawler_module_t,,crawler.c,typedef struct _crawler_module_t crawler_module_t;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2137,3527,crawler_module_reg_t,4,crawler_module_reg_t,,crawler.c,"typedef struct {
    crawler_init_func init; /* run before crawl starts */
    crawler_eval_func eval; /* runs on an item. */
    crawler_doneclass_func doneclass; /* runs once per sub-crawler completion. */
    crawler_finalize_func finalize; /* runs once when all sub-crawlers are done. */
    bool needs_lock; /* whether or not we need the LRU lock held when eval is called */
    bool needs_client; /* whether or not to grab onto the remote client */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2138,3535,_crawler_module_t,4,_crawler_module_t,,crawler.c,"struct _crawler_module_t {
    void *data; /* opaque data pointer */
    crawler_client_t c;
    crawler_module_reg_t *mod;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2139,3649,crawler_run_type,4,crawler_run_type,,crawler.c,enum crawler_run_type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2140,6049,crawlerstats_t,4,crawlerstats_t,,crawler.h,"typedef struct {
    uint64_t histo[61];
    uint64_t ttl_hourplus;
    uint64_t noexp;
    uint64_t reclaimed;
    uint64_t seen;
    rel_time_t start_time;
    rel_time_t end_time;
    bool run_complete;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2141,6065,crawler_expired_data,4,crawler_expired_data,,crawler.h,"struct crawler_expired_data {
    pthread_mutex_t lock;
    crawlerstats_t crawlerstats[POWER_LARGEST];
    /* redundant with crawlerstats_t so we can get overall start/stop/done */
    rel_time_t start_time;
    rel_time_t end_time;
    bool crawl_complete;
    bool is_external; /* whether this was an alloc local or remote to the module. */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2142,6078,crawler_result_type,4,crawler_result_type,,crawler.h,"enum crawler_result_type {
    CRAWLER_OK=0, CRAWLER_RUNNING, CRAWLER_BADCLASS, CRAWLER_NOTSTARTED, CRAWLER_ERROR
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2143,6106,crawler_result_type,4,crawler_result_type,,crawler.h,enum crawler_result_type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2144,7234,__store_wbuf,4,__store_wbuf,,extstore.c,"typedef struct __store_wbuf {
    struct __store_wbuf *next;
    char *buf;
    char *buf_pos;
    unsigned int free;
    unsigned int size;
    unsigned int offset; /* offset into page this write starts at */
    bool full; /* done writing to this page */
    bool flushed; /* whether wbuf has been flushed to disk */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2145,7235,__store_wbuf,4,__store_wbuf.__store_wbuf,,extstore.c,struct __store_wbuf,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2146,7244,_store_wbuf,4,_store_wbuf,,extstore.c,"typedef struct __store_wbuf {
    struct __store_wbuf *next;
    char *buf;
    char *buf_pos;
    unsigned int free;
    unsigned int size;
    unsigned int offset; /* offset into page this write starts at */
    bool full; /* done writing to this page */
    bool flushed; /* whether wbuf has been flushed to disk */
} _store_wbuf;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2147,7245,_store_page,4,_store_page,,extstore.c,"typedef struct _store_page {
    pthread_mutex_t mutex; /* Need to be held for most operations */
    uint64_t obj_count; /* _delete can decrease post-closing */
    uint64_t bytes_used; /* _delete can decrease post-closing */
    uint64_t offset; /* starting address of page within fd */
    unsigned int version;
    unsigned int refcount;
    unsigned int allocated;
    unsigned int written; /* item offsets can be past written if wbuf not flushed */
    unsigned int bucket; /* which bucket the page is linked into */
    unsigned int free_bucket; /* which bucket this page returns to when freed */
    int fd;
    unsigned short id;
    bool active; /* actively being written to */
    bool closed; /* closed and draining before free */
    bool free; /* on freelist */
    _store_wbuf *wbuf; /* currently active wbuf from the stack */
    struct _store_page *next;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2148,7262,_store_page,4,_store_page._store_page,,extstore.c,struct _store_page,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2149,7264,store_page,4,store_page,,extstore.c,"typedef struct _store_page {
    pthread_mutex_t mutex; /* Need to be held for most operations */
    uint64_t obj_count; /* _delete can decrease post-closing */
    uint64_t bytes_used; /* _delete can decrease post-closing */
    uint64_t offset; /* starting address of page within fd */
    unsigned int version;
    unsigned int refcount;
    unsigned int allocated;
    unsigned int written; /* item offsets can be past written if wbuf not flushed */
    unsigned int bucket; /* which bucket the page is linked into */
    unsigned int free_bucket; /* which bucket this page returns to when freed */
    int fd;
    unsigned short id;
    bool active; /* actively being written to */
    bool closed; /* closed and draining before free */
    bool free; /* on freelist */
    _store_wbuf *wbuf; /* currently active wbuf from the stack */
    struct _store_page *next;
} store_page;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2150,7265,store_engine,4,store_engine,,extstore.c,typedef struct store_engine,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2151,7266,store_engine,4,store_engine,,extstore.c,typedef struct store_engine store_engine;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2152,7267,store_io_thread,4,store_io_thread,,extstore.c,"typedef struct {
    pthread_mutex_t mutex;
    pthread_cond_t cond;
    obj_io *queue;
    obj_io *queue_tail;
    store_engine *e;
    unsigned int depth; // queue depth
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2153,7275,store_maint_thread,4,store_maint_thread,,extstore.c,"typedef struct {
    pthread_mutex_t mutex;
    pthread_cond_t cond;
    store_engine *e;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2154,7280,store_engine,4,store_engine,,extstore.c,"struct store_engine {
    pthread_mutex_t mutex; /* covers internal stacks and variables */
    store_page *pages; /* directly addressable page list */
    _store_wbuf *wbuf_stack; /* wbuf freelist */
    obj_io *io_stack; /* IO's to use with submitting wbuf's */
    store_io_thread *io_threads;
    store_maint_thread *maint_thread;
    store_page *page_freelist;
    store_page **page_buckets; /* stack of pages currently allocated to each bucket */
    store_page **free_page_buckets; /* stack of use-case isolated free pages */
    size_t page_size;
    unsigned int version; /* global version counter */
    unsigned int last_io_thread; /* round robin the IO threads */
    unsigned int io_threadcount; /* count of IO threads */
    unsigned int page_count;
    unsigned int page_free; /* unallocated pages */
    unsigned int page_bucketcount; /* count of potential page buckets */
    unsigned int free_page_bucketcount; /* count of free page buckets */
    unsigned int io_depth; /* FIXME...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2155,7300,extstore_stats,4,store_engine.extstore_stats,,extstore.c,struct extstore_stats,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2156,10671,extstore_page_data,4,extstore_page_data,,extstore.h,"struct extstore_page_data {
    uint64_t version;
    uint64_t bytes_used;
    unsigned int bucket;
    unsigned int free_bucket;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2157,10676,extstore_stats,4,extstore_stats,,extstore.h,"struct extstore_stats {
    uint64_t page_allocs;
    uint64_t page_count; /* total page count */
    uint64_t page_evictions;
    uint64_t page_reclaims;
    uint64_t page_size; /* size in bytes per page (supplied by caller) */
    uint64_t pages_free; /* currently unallocated/unused pages */
    uint64_t pages_used;
    uint64_t objects_evicted;
    uint64_t objects_read;
    uint64_t objects_written;
    uint64_t objects_used; /* total number of objects stored */
    uint64_t bytes_evicted;
    uint64_t bytes_written;
    uint64_t bytes_read; /* wbuf - read -> bytes read from storage */
    uint64_t bytes_used; /* total number of bytes stored */
    uint64_t bytes_fragmented; /* see above comment */
    uint64_t io_queue;
    struct extstore_page_data *page_data;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2158,10694,extstore_page_data,4,extstore_stats.extstore_page_data,,extstore.h,struct extstore_page_data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2159,10696,extstore_conf,4,extstore_conf,,extstore.h,"struct extstore_conf {
    unsigned int page_size; // ideally 64-256M in size
    unsigned int page_count;
    unsigned int page_buckets; // number of different writeable pages
    unsigned int free_page_buckets; // buckets of dedicated pages (see code)
    unsigned int wbuf_size; // must divide cleanly into page_size
    unsigned int wbuf_count; // this might get locked to ""2 per active page""
    unsigned int io_threadcount;
    unsigned int io_depth; // with normal I/O, hits locks less. req'd for AIO
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2160,10705,extstore_conf_file,4,extstore_conf_file,,extstore.h,"struct extstore_conf_file {
    unsigned int page_count;
    char *file;
    int fd; // internal usage
    uint64_t offset; // internal usage
    unsigned int bucket; // free page bucket
    unsigned int free_bucket; // specialized free bucket
    struct extstore_conf_file *next;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2161,10712,extstore_conf_file,4,extstore_conf_file.extstore_conf_file,,extstore.h,struct extstore_conf_file,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2162,10714,obj_io_mode,4,obj_io_mode,,extstore.h,"enum obj_io_mode {
    OBJ_IO_READ = 0,
    OBJ_IO_WRITE,
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2163,10724,_obj_io,4,_obj_io,,extstore.h,typedef struct _obj_io,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2164,10725,obj_io,4,obj_io,,extstore.h,typedef struct _obj_io obj_io;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2165,10733,_obj_io,4,_obj_io,,extstore.h,"struct _obj_io {
    void *data; /* user supplied data pointer */
    struct _obj_io *next;
    char *buf;  /* buffer of data to read or write to */
    struct iovec *iov; /* alternatively, use this iovec */
    unsigned int iovcnt; /* number of IOV's */
    unsigned int page_version;     /* page version for read mode */
    unsigned int len;     /* for both modes */
    unsigned int offset;  /* for read mode */
    unsigned short page_id; /* for read mode */
    enum obj_io_mode mode;
    /* callback pointers? */
    obj_io_cb cb;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2166,10735,_obj_io,4,_obj_io._obj_io,,extstore.h,struct _obj_io,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2167,10738,iovec,4,_obj_io.iovec,,extstore.h,struct iovec,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2168,10745,obj_io_mode,4,_obj_io.obj_io_mode,,extstore.h,enum obj_io_mode,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2169,10748,extstore_res,4,extstore_res,,extstore.h,"enum extstore_res {
    EXTSTORE_INIT_BAD_WBUF_SIZE = 1,
    EXTSTORE_INIT_NEED_MORE_WBUF,
    EXTSTORE_INIT_NEED_MORE_BUCKETS,
    EXTSTORE_INIT_PAGE_WBUF_ALIGNMENT,
    EXTSTORE_INIT_TOO_MANY_PAGES,
    EXTSTORE_INIT_OOM,
    EXTSTORE_INIT_OPEN_FAIL,
    EXTSTORE_INIT_THREAD_FAIL
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2170,10865,stats,4,stats,,globals.c,struct stats,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2171,10867,stats_state,4,stats_state,,globals.c,struct stats_state,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2172,10869,settings,4,settings,,globals.c,struct settings,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2173,10871,slab_rebalance,4,slab_rebalance,,globals.c,struct slab_rebalance,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2174,10961,hashfunc_type,4,hashfunc_type,,hash.h,"enum hashfunc_type {
    JENKINS_HASH=0, MURMUR3_HASH, XXH3_HASH
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2175,11046,itemstats_t,4,itemstats_t,,items.c,"typedef struct {
    uint64_t evicted;
    uint64_t evicted_nonzero;
    uint64_t reclaimed;
    uint64_t outofmemory;
    uint64_t tailrepairs;
    uint64_t expired_unfetched; /* items reclaimed but never touched */
    uint64_t evicted_unfetched; /* items evicted but never touched */
    uint64_t evicted_active; /* items evicted that should have been shuffled */
    uint64_t crawler_reclaimed;
    uint64_t crawler_items_checked;
    uint64_t lrutail_reflocked;
    uint64_t moves_to_cold;
    uint64_t moves_to_warm;
    uint64_t moves_within_lru;
    uint64_t direct_reclaims;
    uint64_t hits_to_hot;
    uint64_t hits_to_warm;
    uint64_t hits_to_cold;
    uint64_t hits_to_temp;
    uint64_t mem_requested;
    rel_time_t evicted_time;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2176,11196,_lru_bump_buf,4,_lru_bump_buf,,items.c,"typedef struct _lru_bump_buf {
    struct _lru_bump_buf *prev;
    struct _lru_bump_buf *next;
    pthread_mutex_t mutex;
    bipbuf_t *buf;
    uint64_t dropped;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2177,11197,_lru_bump_buf,4,_lru_bump_buf._lru_bump_buf,,items.c,struct _lru_bump_buf,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2178,11199,_lru_bump_buf,4,_lru_bump_buf._lru_bump_buf,,items.c,struct _lru_bump_buf,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2179,11204,lru_bump_buf,4,lru_bump_buf,,items.c,"typedef struct _lru_bump_buf {
    struct _lru_bump_buf *prev;
    struct _lru_bump_buf *next;
    pthread_mutex_t mutex;
    bipbuf_t *buf;
    uint64_t dropped;
} lru_bump_buf;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2180,11205,lru_bump_entry,4,lru_bump_entry,,items.c,"typedef struct {
    item *it;
    uint32_t hv;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2181,18866,lru_pull_tail_return,4,lru_pull_tail_return,,items.h,"struct lru_pull_tail_return {
    item *it;
    uint32_t hv;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2182,18944,item_stats_automove,4,item_stats_automove,,items.h,"typedef struct {
    int64_t evicted;
    int64_t outofmemory;
    uint32_t age;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2183,19549,sigaction,4,sigaction,,linux_priv.c,static const struct sigaction,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2184,19625,pollfd,4,pollfd,,logger.c,struct pollfd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2185,22265,rel_time_t,4,rel_time_t,,logger.h,typedef unsigned int rel_time_t;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2186,22266,log_entry_type,4,log_entry_type,,logger.h,"enum log_entry_type {
    LOGGER_ASCII_CMD = 0,
    LOGGER_EVICTION,
    LOGGER_ITEM_GET,
    LOGGER_ITEM_STORE,
    LOGGER_CRAWLER_STATUS,
    LOGGER_SLAB_MOVE,
    LOGGER_CONNECTION_NEW,
    LOGGER_CONNECTION_CLOSE,
#ifdef EXTSTORE
    LOGGER_EXTSTORE_WRITE,
    LOGGER_COMPACT_START,
    LOGGER_COMPACT_ABORT,
    LOGGER_COMPACT_READ_START,
    LOGGER_COMPACT_READ_END,
    LOGGER_COMPACT_END,
    LOGGER_COMPACT_FRAGINFO,
#endif
#ifdef PROXY
    LOGGER_PROXY_CONFIG,
    LOGGER_PROXY_RAW,
    LOGGER_PROXY_ERROR,
    LOGGER_PROXY_USER,
    LOGGER_PROXY_REQ,
    LOGGER_PROXY_BE_ERROR,
#endif
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2187,22282,logger_ret_type,4,logger_ret_type,,logger.h,"enum logger_ret_type {
    LOGGER_RET_OK = 0,
    LOGGER_RET_NOSPACE,
    LOGGER_RET_ERR
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2188,22293,logger_parse_entry_ret,4,logger_parse_entry_ret,,logger.h,"enum logger_parse_entry_ret {
    LOGGER_PARSE_ENTRY_OK = 0,
    LOGGER_PARSE_ENTRY_FULLBUF,
    LOGGER_PARSE_ENTRY_FAILED
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2189,22304,_logentry,4,_logentry,,logger.h,typedef struct _logentry,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2190,22305,logentry,4,logentry,,logger.h,typedef struct _logentry logentry;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2191,22306,_entry_details,4,_entry_details,,logger.h,typedef struct _entry_details,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2192,22307,entry_details,4,entry_details,,logger.h,typedef struct _entry_details entry_details;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2193,22322,_entry_details,4,_entry_details,,logger.h,"struct _entry_details {
    int reqlen;
    uint16_t eflags;
    entry_log_cb log_cb;
    entry_parse_cb parse_cb;
    char *format;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2194,22328,logentry_eviction,4,logentry_eviction,,logger.h,"struct logentry_eviction {
    long long int exptime;
    int nbytes;
    uint32_t latime;
    uint16_t it_flags;
    uint8_t nkey;
    uint8_t clsid;
    char key[];
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2195,22341,logentry_item_get,4,logentry_item_get,,logger.h,"struct logentry_item_get {
    uint8_t was_found;
    uint8_t nkey;
    uint8_t clsid;
    int nbytes;
    int sfd;
    char key[];
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2196,22353,logentry_item_store,4,logentry_item_store,,logger.h,"struct logentry_item_store {
    int status;
    int cmd;
    rel_time_t ttl;
    uint8_t nkey;
    uint8_t clsid;
    int nbytes;
    int sfd;
    char key[];
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2197,22367,logentry_conn_event,4,logentry_conn_event,,logger.h,"struct logentry_conn_event {
    int transport;
    int reason;
    int sfd;
    struct sockaddr_in6 addr;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2198,22371,sockaddr_in6,4,logentry_conn_event.sockaddr_in6,,logger.h,struct sockaddr_in6,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2199,22373,_logentry,4,_logentry,,logger.h,"struct _logentry {
    enum log_entry_type event;
    uint8_t pad;
    uint16_t eflags;
    uint64_t gid;
    struct timeval tv; /* not monotonic! */
    int size;
    union {
        char end;
    } data[];
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2200,22374,log_entry_type,4,_logentry.log_entry_type,,logger.h,enum log_entry_type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2201,22379,timeval,4,_logentry.timeval,,logger.h,struct timeval,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2202,22382,_logentry.data,4,_logentry.data,,logger.h,"union {
        char end;
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2203,22390,_logger,4,_logger,,logger.h,"typedef struct _logger {
    struct _logger *prev;
    struct _logger *next;
    pthread_mutex_t mutex; /* guard for this + *buf */
    uint64_t written; /* entries written to the buffer */
    uint64_t dropped; /* entries dropped */
    uint64_t blocked; /* times blocked instead of dropped */
    uint16_t fetcher_ratio; /* log one out of every N fetches */
    uint16_t mutation_ratio; /* log one out of every N mutations */
    uint16_t eflags; /* flags this logger should log */
    bipbuf_t *buf;
    const entry_details *entry_map;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2204,22391,_logger,4,_logger._logger,,logger.h,struct _logger,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2205,22393,_logger,4,_logger._logger,,logger.h,struct _logger,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2206,22404,logger,4,logger,,logger.h,"typedef struct _logger {
    struct _logger *prev;
    struct _logger *next;
    pthread_mutex_t mutex; /* guard for this + *buf */
    uint64_t written; /* entries written to the buffer */
    uint64_t dropped; /* entries dropped */
    uint64_t blocked; /* times blocked instead of dropped */
    uint16_t fetcher_ratio; /* log one out of every N fetches */
    uint16_t mutation_ratio; /* log one out of every N mutations */
    uint16_t eflags; /* flags this logger should log */
    bipbuf_t *buf;
    const entry_details *entry_map;
} logger;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2207,22405,logger_watcher_type,4,logger_watcher_type,,logger.h,"enum logger_watcher_type {
    LOGGER_WATCHER_STDERR = 0,
    LOGGER_WATCHER_CLIENT = 1
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2208,22418,logger_watcher,4,logger_watcher,,logger.h,"typedef struct  {
    void *c; /* original connection structure. still with source thread attached */
    int sfd; /* client fd */
    int id; /* id number for watcher list */
    uint64_t skipped; /* lines skipped since last successful print */
    uint64_t min_gid; /* don't show log entries older than this GID */
    bool failed_flush; /* recently failed to write out (EAGAIN), wait before retry */
    enum logger_watcher_type t; /* stderr, client, syslog, etc */
    uint16_t eflags; /* flags we are interested in */
    bipbuf_t *buf; /* per-watcher output buffer */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2209,22425,logger_watcher_type,4,logger_watcher.logger_watcher_type,,logger.h,enum logger_watcher_type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2210,22430,logger_stats,4,logger_stats,,logger.h,"struct logger_stats {
    uint64_t worker_dropped;
    uint64_t worker_written;
    uint64_t watcher_skipped;
    uint64_t watcher_sent;
    uint64_t watcher_count;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2211,22452,logger_ret_type,4,logger_ret_type,,logger.h,enum logger_ret_type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2212,22454,logger_add_watcher_ret,4,logger_add_watcher_ret,,logger.h,"enum logger_add_watcher_ret {
    LOGGER_ADD_WATCHER_TOO_MANY = 0,
    LOGGER_ADD_WATCHER_OK,
    LOGGER_ADD_WATCHER_FAILED
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2213,22465,logger_add_watcher_ret,4,logger_add_watcher_ret,,logger.h,enum logger_add_watcher_ret,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2214,25571,md5_byte_t,4,md5_byte_t,,md5.h,typedef unsigned char md5_byte_t;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2215,25572,md5_word_t,4,md5_word_t,,md5.h,typedef unsigned int md5_word_t;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2216,25573,md5_state_s,4,md5_state_s,,md5.h,"typedef struct md5_state_s {
    md5_word_t count[2];	/* message length in bits, lsw first */
    md5_word_t abcd[4];		/* digest buffer */
    md5_byte_t buf[64];		/* accumulate block */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2217,25587,md5_state_t,4,md5_state_t,,md5.h,"typedef struct md5_state_s {
    md5_word_t count[2];	/* message length in bits, lsw first */
    md5_word_t abcd[4];		/* digest buffer */
    md5_byte_t buf[64];		/* accumulate block */
} md5_state_t;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2218,25706,try_read_result,4,try_read_result,,memcached.c,"enum try_read_result {
    READ_DATA_RECEIVED,
    READ_NO_DATA_RECEIVED,
    READ_ERROR,            /** an error occurred (on the socket) (or client closed connection) */
    READ_MEMORY_ERROR      /** failed to allocate more memory */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2219,25721,try_read_result,4,try_read_result,,memcached.c,static enum try_read_result,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2220,25723,try_read_result,4,try_read_result,,memcached.c,static enum try_read_result,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2221,25779,stats,4,stats,,memcached.c,struct stats,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2222,25781,stats_state,4,stats_state,,memcached.c,struct stats_state,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2223,25783,settings,4,settings,,memcached.c,struct settings,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2224,25787,slab_rebalance,4,slab_rebalance,,memcached.c,struct slab_rebalance,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2225,25795,event_base,4,event_base,,memcached.c,static struct event_base,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2226,25797,transmit_result,4,transmit_result,,memcached.c,"enum transmit_result {
    TRANSMIT_COMPLETE,   /** All done writing. */
    TRANSMIT_INCOMPLETE, /** More data remaining to write. */
    TRANSMIT_SOFT_ERROR, /** Can't write any more right now. */
    TRANSMIT_HARD_ERROR  /** Can't write (c->state is set to conn_closing) */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2227,25856,transmit_result,4,transmit_result,,memcached.c,static enum transmit_result,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2228,25866,event,4,event,,memcached.c,static struct event,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2229,39786,event,4,event,,memcached.c,static struct event,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2230,40447,_mc_meta_data,4,_mc_meta_data,,memcached.c,"struct _mc_meta_data {
    void *mmap_base;
    uint64_t old_base;
    char *slab_config; // string containing either factor or custom slab list.
    int64_t time_delta;
    uint64_t process_started;
    uint32_t current_time;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2231,44169,conn_states,4,conn_states,,memcached.h,"enum conn_states {
    conn_listening,  /**< the socket which listens for connections */
    conn_new_cmd,    /**< Prepare connection for next command */
    conn_waiting,    /**< waiting for a readable socket */
    conn_read,       /**< reading in a command line */
    conn_parse_cmd,  /**< try to parse a command from the input buffer */
    conn_write,      /**< writing out a simple response */
    conn_nread,      /**< reading in a fixed number of bytes */
    conn_swallow,    /**< swallowing unnecessary bytes w/o storing */
    conn_closing,    /**< closing this connection */
    conn_mwrite,     /**< writing out many items sequentially */
    conn_closed,     /**< connection is closed */
    conn_watch,      /**< held by the logger thread as a watcher */
    conn_io_queue,   /**< wait on async. process to get response object */
    conn_max_state   /**< Max state value (used for assertion) */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2232,44184,bin_substates,4,bin_substates,,memcached.h,"enum bin_substates {
    bin_no_state,
    bin_reading_set_header,
    bin_reading_cas_header,
    bin_read_set_value,
    bin_reading_get_key,
    bin_reading_stat,
    bin_reading_del_header,
    bin_reading_incr_header,
    bin_read_flush_exptime,
    bin_reading_sasl_auth,
    bin_reading_sasl_auth_data,
    bin_reading_touch_key,
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2233,44197,protocol,4,protocol,,memcached.h,"enum protocol {
    ascii_prot = 3, /* arbitrary value. */
    binary_prot,
    negotiating_prot, /* Discovering the protocol */
#ifdef PROXY
    proxy_prot,
#endif
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2234,44208,network_transport,4,network_transport,,memcached.h,"enum network_transport {
    local_transport, /* Unix sockets*/
    tcp_transport,
    udp_transport
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2235,44212,pause_thread_types,4,pause_thread_types,,memcached.h,"enum pause_thread_types {
    PAUSE_WORKER_THREADS = 0,
    PAUSE_ALL_THREADS,
    RESUME_ALL_THREADS,
    RESUME_WORKER_THREADS
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2236,44224,stop_reasons,4,stop_reasons,,memcached.h,"enum stop_reasons {
    NOT_STOP,
    GRACE_STOP,
    EXIT_NORMALLY
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2237,44228,close_reasons,4,close_reasons,,memcached.h,"enum close_reasons {
    ERROR_CLOSE,
    NORMAL_CLOSE,
    IDLE_TIMEOUT_CLOSE,
    SHUTDOWN_CLOSE,
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2238,44233,store_item_type,4,store_item_type,,memcached.h,"enum store_item_type {
    NOT_STORED=0, STORED, EXISTS, NOT_FOUND, TOO_LARGE, NO_MEMORY
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2239,44247,delta_result_type,4,delta_result_type,,memcached.h,"enum delta_result_type {
    OK, NON_NUMERIC, EOM, DELTA_ITEM_NOT_FOUND, DELTA_ITEM_CAS_MISMATCH
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2240,44253,slab_stats,4,slab_stats,,memcached.h,"struct slab_stats {
#define X(name) uint64_t    name;
    SLAB_STATS_FIELDS
#undef X
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2241,44262,thread_stats,4,thread_stats,,memcached.h,"struct thread_stats {
    pthread_mutex_t   mutex;
#define X(name) uint64_t    name;
    THREAD_STATS_FIELDS
#ifdef EXTSTORE
    EXTSTORE_THREAD_STATS_FIELDS
#endif
#ifdef PROXY
    PROXY_THREAD_STATS_FIELDS
#endif
#undef X
    struct slab_stats slab_stats[MAX_NUMBER_OF_SLAB_CLASSES];
    uint64_t lru_hits[POWER_LARGEST];
    uint64_t read_buf_count;
    uint64_t read_buf_bytes;
    uint64_t read_buf_bytes_free;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2242,44290,slab_stats,4,thread_stats.slab_stats,,memcached.h,struct slab_stats,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2243,44310,stats,4,stats,,memcached.h,"struct stats {
    uint64_t      total_items;
    uint64_t      total_conns;
    uint64_t      rejected_conns;
    uint64_t      malloc_fails;
    uint64_t      listen_disabled_num;
    uint64_t      slabs_moved;       /* times slabs were moved around */
    uint64_t      slab_reassign_rescues; /* items rescued during slab move */
    uint64_t      slab_reassign_evictions_nomem; /* valid items lost during slab move */
    uint64_t      slab_reassign_inline_reclaim; /* valid items lost during slab move */
    uint64_t      slab_reassign_chunk_rescues; /* chunked-item chunks recovered */
    uint64_t      slab_reassign_busy_items; /* valid temporarily unmovable */
    uint64_t      slab_reassign_busy_deletes; /* refcounted items killed */
    uint64_t      lru_crawler_starts; /* Number of item crawlers kicked off */
    uint64_t      lru_maintainer_juggles; /* number of LRU bg pokes */
    uint64_t      time_in_listen_disabled_us;  /* elapsed time in microseconds while server unable t...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2244,44335,timeval,4,stats.timeval,,memcached.h,struct timeval,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2245,44339,stats_state,4,stats_state,,memcached.h,"struct stats_state {
    uint64_t      curr_items;
    uint64_t      curr_bytes;
    uint64_t      curr_conns;
    uint64_t      hash_bytes;       /* size used for hash tables */
    unsigned int  conn_structs;
    unsigned int  reserved_fds;
    unsigned int  hash_power_level; /* Better hope it's not over 9000 */
    unsigned int  log_watchers; /* number of currently active watchers */
    bool          hash_is_expanding; /* If the hash table is being expanded */
    bool          accepting_conns;  /* whether we are currently accepting */
    bool          slab_reassign_running; /* slab reassign in progress */
    bool          lru_crawler_running; /* crawl in progress */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2246,44352,settings,4,settings,,memcached.h,"struct settings {
    size_t maxbytes;
    int maxconns;
    int port;
    int udpport;
    char *inter;
    int verbose;
    rel_time_t oldest_live; /* ignore existing items older than this */
    uint64_t oldest_cas; /* ignore existing items with CAS values lower than this */
    int evict_to_free;
    char *socketpath;   /* path to unix socket if using local socket */
    char *auth_file;    /* path to user authentication file */
    int access;  /* access mask (a la chmod) for unix domain socket */
    double factor;          /* chunk size growth factor */
    int chunk_size;
    int num_threads;        /* number of worker (without dispatcher) libevent threads to run */
    int num_threads_per_udp; /* number of worker threads serving each udp socket */
    char prefix_delimiter;  /* character that marks a key prefix (for stats) */
    int detail_enabled;     /* nonzero if we're collecting detailed stats */
    int reqs_per_event;     /* Maximum number of io to process on each
  ...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2247,44373,protocol,4,settings.protocol,,memcached.h,enum protocol,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2248,44446,stats,4,stats,,memcached.h,extern struct stats,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2249,44448,stats_state,4,stats_state,,memcached.h,extern struct stats_state,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2250,44451,settings,4,settings,,memcached.h,extern struct settings,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2251,44453,_stritem,4,_stritem,,memcached.h,"typedef struct _stritem {
    /* Protected by LRU locks */
    struct _stritem *next;
    struct _stritem *prev;
    /* Rest are protected by an item lock */
    struct _stritem *h_next;    /* hash chain next */
    rel_time_t      time;       /* least recent access */
    rel_time_t      exptime;    /* expire time */
    int             nbytes;     /* size of data */
    unsigned short  refcount;
    uint16_t        it_flags;   /* ITEM_* above */
    uint8_t         slabs_clsid;/* which slab class we're in */
    uint8_t         nkey;       /* key length, w/terminating null and padding */
    /* this odd type prevents type-punning issues when we do
     * the little shuffle to save space when not using CAS. */
    union {
        uint64_t cas;
        char end;
    } data[];
    /* if it_flags & ITEM_CAS we have 8 bytes CAS */
    /* then null-terminated key */
    /* then "" flags length\r\n"" (no terminating null) */
    /* then data with terminating \r\n (no terminating null; it's...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2252,44454,_stritem,4,_stritem._stritem,,memcached.h,struct _stritem,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2253,44456,_stritem,4,_stritem._stritem,,memcached.h,struct _stritem,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2254,44458,_stritem,4,_stritem._stritem,,memcached.h,struct _stritem,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2255,44467,_stritem.data,4,_stritem.data,,memcached.h,"union {
        uint64_t cas;
        char end;
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2256,44476,item,4,item,,memcached.h,"typedef struct _stritem {
    /* Protected by LRU locks */
    struct _stritem *next;
    struct _stritem *prev;
    /* Rest are protected by an item lock */
    struct _stritem *h_next;    /* hash chain next */
    rel_time_t      time;       /* least recent access */
    rel_time_t      exptime;    /* expire time */
    int             nbytes;     /* size of data */
    unsigned short  refcount;
    uint16_t        it_flags;   /* ITEM_* above */
    uint8_t         slabs_clsid;/* which slab class we're in */
    uint8_t         nkey;       /* key length, w/terminating null and padding */
    /* this odd type prevents type-punning issues when we do
     * the little shuffle to save space when not using CAS. */
    union {
        uint64_t cas;
        char end;
    } data[];
    /* if it_flags & ITEM_CAS we have 8 bytes CAS */
    /* then null-terminated key */
    /* then "" flags length\r\n"" (no terminating null) */
    /* then data with terminating \r\n (no terminating null; it's...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2257,44477,crawler_run_type,4,crawler_run_type,,memcached.h,"enum crawler_run_type {
    CRAWLER_AUTOEXPIRE=0, CRAWLER_EXPIRED, CRAWLER_METADUMP
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2258,44488,crawler,4,crawler,,memcached.h,"typedef struct {
    struct _stritem *next;
    struct _stritem *prev;
    struct _stritem *h_next;    /* hash chain next */
    rel_time_t      time;       /* least recent access */
    rel_time_t      exptime;    /* expire time */
    int             nbytes;     /* size of data */
    unsigned short  refcount;
    uint16_t        it_flags;   /* ITEM_* above */
    uint8_t         slabs_clsid;/* which slab class we're in */
    uint8_t         nkey;       /* key length, w/terminating null and padding */
    uint32_t        remaining;  /* Max keys to crawl per slab per invocation */
    uint64_t        reclaimed;  /* items reclaimed during this crawl. */
    uint64_t        unfetched;  /* items reclaimed unfetched during this crawl. */
    uint64_t        checked;    /* items examined during this crawl. */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2259,44489,_stritem,4,crawler._stritem,,memcached.h,struct _stritem,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2260,44491,_stritem,4,crawler._stritem,,memcached.h,struct _stritem,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2261,44493,_stritem,4,crawler._stritem,,memcached.h,struct _stritem,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2262,44507,_strchunk,4,_strchunk,,memcached.h,"typedef struct _strchunk {
    struct _strchunk *next;     /* points within its own chain. */
    struct _strchunk *prev;     /* can potentially point to the head. */
    struct _stritem  *head;     /* always points to the owner chunk */
    int              size;      /* available chunk space in bytes */
    int              used;      /* chunk space used */
    int              nbytes;    /* used. */
    unsigned short   refcount;  /* used? */
    uint16_t         it_flags;  /* ITEM_* above. */
    uint8_t          slabs_clsid; /* Same as above. */
    uint8_t          orig_clsid; /* For obj hdr chunks slabs_clsid is fake. */
    char data[];
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2263,44508,_strchunk,4,_strchunk._strchunk,,memcached.h,struct _strchunk,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2264,44510,_strchunk,4,_strchunk._strchunk,,memcached.h,struct _strchunk,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2265,44512,_stritem,4,_strchunk._stritem,,memcached.h,struct _stritem,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2266,44527,item_chunk,4,item_chunk,,memcached.h,"typedef struct _strchunk {
    struct _strchunk *next;     /* points within its own chain. */
    struct _strchunk *prev;     /* can potentially point to the head. */
    struct _stritem  *head;     /* always points to the owner chunk */
    int              size;      /* available chunk space in bytes */
    int              used;      /* chunk space used */
    int              nbytes;    /* used. */
    unsigned short   refcount;  /* used? */
    uint16_t         it_flags;  /* ITEM_* above. */
    uint8_t          slabs_clsid; /* Same as above. */
    uint8_t          orig_clsid; /* For obj hdr chunks slabs_clsid is fake. */
    char data[];
} item_chunk;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2267,44528,_io_pending_t,4,_io_pending_t,,memcached.h,typedef struct _io_pending_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2268,44529,io_pending_t,4,io_pending_t,,memcached.h,typedef struct _io_pending_t io_pending_t;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2269,44530,io_queue_s,4,io_queue_s,,memcached.h,typedef struct io_queue_s,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2270,44531,io_queue_t,4,io_queue_t,,memcached.h,typedef struct io_queue_s io_queue_t;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2271,44542,io_queue_s,4,io_queue_s,,memcached.h,"struct io_queue_s {
    void *ctx; // duplicated from io_queue_cb_t
    void *stack_ctx; // module-specific context to be batch-submitted
    int count; // ios to process before returning. only accessed by queue processor once submitted
    int type; // duplicated from io_queue_cb_t
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2272,44547,io_queue_cb_s,4,io_queue_cb_s,,memcached.h,"typedef struct io_queue_cb_s {
    void *ctx; // untouched ptr for specific context
    io_queue_stack_cb submit_cb; // callback given a full stack of pending IO's at once.
    io_queue_stack_cb complete_cb;
    io_queue_cb return_cb; // called on worker thread.
    io_queue_cb finalize_cb; // called back on the worker thread.
    int type;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2273,44554,io_queue_cb_t,4,io_queue_cb_t,,memcached.h,"typedef struct io_queue_cb_s {
    void *ctx; // untouched ptr for specific context
    io_queue_stack_cb submit_cb; // callback given a full stack of pending IO's at once.
    io_queue_stack_cb complete_cb;
    io_queue_cb return_cb; // called on worker thread.
    io_queue_cb finalize_cb; // called back on the worker thread.
    int type;
} io_queue_cb_t;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2274,44555,_mc_resp_bundle,4,_mc_resp_bundle,,memcached.h,typedef struct _mc_resp_bundle,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2275,44556,mc_resp_bundle,4,mc_resp_bundle,,memcached.h,typedef struct _mc_resp_bundle mc_resp_bundle;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2276,44557,LIBEVENT_THREAD,4,LIBEVENT_THREAD,,memcached.h,"typedef struct {
    pthread_t thread_id;        /* unique ID of this thread */
    struct event_base *base;    /* libevent handle this thread uses */
    struct event notify_event;  /* listen event for notify pipe */
#ifdef HAVE_EVENTFD
    int notify_event_fd;        /* notify counter */
#else
    int notify_receive_fd;      /* receiving end of notify pipe */
    int notify_send_fd;         /* sending end of notify pipe */
#endif
    struct thread_stats stats;  /* Stats generated by this thread */
    io_queue_cb_t io_queues[IO_QUEUE_COUNT];
    struct conn_queue *ev_queue; /* Worker/conn event queue */
    cache_t *rbuf_cache;        /* static-sized read buffers */
    mc_resp_bundle *open_bundle;
    cache_t *io_cache;          /* IO objects */
#ifdef EXTSTORE
    void *storage;              /* data object for storage system */
#endif
    logger *l;                  /* logger buffer */
    void *lru_bump_buf;         /* async LRU bump buffer */
#ifdef TLS
    char   *ssl_wbuf;
#...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2277,44559,event_base,4,LIBEVENT_THREAD.event_base,,memcached.h,struct event_base,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2278,44561,event,4,LIBEVENT_THREAD.event,,memcached.h,struct event,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2279,44566,thread_stats,4,LIBEVENT_THREAD.thread_stats,,memcached.h,struct thread_stats,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2280,44569,conn_queue,4,LIBEVENT_THREAD.conn_queue,,memcached.h,struct conn_queue,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2281,44595,_mc_resp,4,_mc_resp,,memcached.h,"typedef struct _mc_resp {
    mc_resp_bundle *bundle; // ptr back to bundle
    struct _mc_resp *next; // choo choo.
    int wbytes; // bytes to write out of wbuf: might be able to nuke this.
    int tosend; // total bytes to send for this response
    void *write_and_free; /** free this memory after finishing writing */
    io_pending_t *io_pending; /* pending IO descriptor for this response */

    item *item; /* item associated with this response object, with reference held */
    struct iovec iov[MC_RESP_IOVCOUNT]; /* built-in iovecs to simplify network code */
    int chunked_total; /* total amount of chunked item data to send. */
    uint8_t iovcnt;
    uint8_t chunked_data_iov; /* this iov is a pointer to chunked data header */

    /* instruct transmit to skip this response object. used by storage engines
     * to asynchronously kill an object that was queued to write
     */
    bool skip;
    bool free; // double free detection.
    // UDP bits. Copied in from the client....",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2282,44597,_mc_resp,4,_mc_resp._mc_resp,,memcached.h,struct _mc_resp,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2283,44604,iovec,4,_mc_resp.iovec,,memcached.h,struct iovec,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2284,44614,sockaddr_in6,4,_mc_resp.sockaddr_in6,,memcached.h,struct sockaddr_in6,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2285,44630,mc_resp,4,mc_resp,,memcached.h,"typedef struct _mc_resp {
    mc_resp_bundle *bundle; // ptr back to bundle
    struct _mc_resp *next; // choo choo.
    int wbytes; // bytes to write out of wbuf: might be able to nuke this.
    int tosend; // total bytes to send for this response
    void *write_and_free; /** free this memory after finishing writing */
    io_pending_t *io_pending; /* pending IO descriptor for this response */

    item *item; /* item associated with this response object, with reference held */
    struct iovec iov[MC_RESP_IOVCOUNT]; /* built-in iovecs to simplify network code */
    int chunked_total; /* total amount of chunked item data to send. */
    uint8_t iovcnt;
    uint8_t chunked_data_iov; /* this iov is a pointer to chunked data header */

    /* instruct transmit to skip this response object. used by storage engines
     * to asynchronously kill an object that was queued to write
     */
    bool skip;
    bool free; // double free detection.
    // UDP bits. Copied in from the client....",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2286,44631,_mc_resp_bundle,4,_mc_resp_bundle,,memcached.h,"struct _mc_resp_bundle {
    uint8_t refcount;
    uint8_t next_check; // next object to check on assignment.
    struct _mc_resp_bundle *next;
    struct _mc_resp_bundle *prev;
    mc_resp r[];
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2287,44634,_mc_resp_bundle,4,_mc_resp_bundle._mc_resp_bundle,,memcached.h,struct _mc_resp_bundle,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2288,44636,_mc_resp_bundle,4,_mc_resp_bundle._mc_resp_bundle,,memcached.h,struct _mc_resp_bundle,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2289,44644,conn,4,conn,,memcached.h,typedef struct conn,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2290,44645,conn,4,conn,,memcached.h,typedef struct conn conn;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2291,44646,_io_pending_t,4,_io_pending_t,,memcached.h,"struct _io_pending_t {
    int io_queue_type; // matches one of IO_QUEUE_*
    LIBEVENT_THREAD *thread;
    conn *c;
    mc_resp *resp; // associated response object
    char data[120];
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2292,44658,conn,4,conn,,memcached.h,"struct conn {
    sasl_conn_t *sasl_conn;
    int    sfd;
    bool sasl_started;
    bool authenticated;
    bool set_stale;
    bool mset_res; /** uses mset format for return code */
    bool close_after_write; /** flush write then move to close connection */
    bool rbuf_malloced; /** read buffer was malloc'ed for ascii mget, needs free() */
    bool item_malloced; /** item for conn_nread state is a temporary malloc */
#ifdef TLS
    SSL    *ssl;
    char   *ssl_wbuf;
    bool ssl_enabled;
#endif
    enum conn_states  state;
    enum bin_substates substate;
    rel_time_t last_cmd_time;
    struct event event;
    short  ev_flags;
    short  which;   /** which events were just triggered */

    char   *rbuf;   /** buffer to read commands into */
    char   *rcurr;  /** but if we parsed some already, this is where we stopped */
    int    rsize;   /** total allocated size of rbuf */
    int    rbytes;  /** how much data, starting from rcur, do we have unparsed */

    mc_resp *res...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2293,44671,conn_states,4,conn.conn_states,,memcached.h,enum conn_states,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2294,44673,bin_substates,4,conn.bin_substates,,memcached.h,enum bin_substates,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2295,44676,event,4,conn.event,,memcached.h,struct event,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2296,44694,protocol,4,conn.protocol,,memcached.h,enum protocol,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2297,44696,network_transport,4,conn.network_transport,,memcached.h,enum network_transport,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2298,44698,close_reasons,4,conn.close_reasons,,memcached.h,enum close_reasons,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2299,44701,sockaddr_in6,4,conn.sockaddr_in6,,memcached.h,struct sockaddr_in6,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2300,44705,conn.stats,4,conn.stats,,memcached.h,"struct {
        char *buffer;
        size_t size;
        size_t offset;
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2301,44755,slab_rebalance,4,slab_rebalance,,memcached.h,"struct slab_rebalance {
    void *slab_start;
    void *slab_end;
    void *slab_pos;
    int s_clsid;
    int d_clsid;
    uint32_t busy_items;
    uint32_t rescues;
    uint32_t evictions_nomem;
    uint32_t inline_reclaim;
    uint32_t chunk_rescues;
    uint32_t busy_deletes;
    uint32_t busy_loops;
    uint8_t done;
    uint8_t *completed;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2302,44770,slab_rebalance,4,slab_rebalance,,memcached.h,extern struct slab_rebalance,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2303,44777,delta_result_type,4,delta_result_type,,memcached.h,enum delta_result_type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2304,44779,store_item_type,4,store_item_type,,memcached.h,enum store_item_type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2305,44876,delta_result_type,4,delta_result_type,,memcached.h,enum delta_result_type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2306,45023,store_item_type,4,store_item_type,,memcached.h,enum store_item_type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2307,53918,token_s,4,token_s,,proto_text.c,"typedef struct token_s {
    char *value;
    size_t length;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2308,53921,token_t,4,token_t,,proto_text.c,"typedef struct token_s {
    char *value;
    size_t length;
} token_t;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2309,56687,_meta_flags,4,_meta_flags,,proto_text.c,"struct _meta_flags {
    unsigned int has_error :1; // flipped if we found an error during parsing.
    unsigned int no_update :1;
    unsigned int locked :1;
    unsigned int vivify :1;
    unsigned int la :1;
    unsigned int hit :1;
    unsigned int value :1;
    unsigned int set_stale :1;
    unsigned int no_reply :1;
    unsigned int has_cas :1;
    unsigned int new_ttl :1;
    unsigned int key_binary:1;
    char mode; // single character mode switch, common to ms/ma
    rel_time_t exptime;
    rel_time_t autoviv_exptime;
    rel_time_t recache_time;
    uint32_t client_flags;
    uint64_t req_cas_id;
    uint64_t delta; // ma
    uint64_t initial; // ma
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2310,64266,protocol_binary_magic,4,protocol_binary_magic,,protocol_binary.h,"typedef enum {
        PROTOCOL_BINARY_REQ = 0x80,
        PROTOCOL_BINARY_RES = 0x81
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2311,64280,protocol_binary_response_status,4,protocol_binary_response_status,,protocol_binary.h,"typedef enum {
        PROTOCOL_BINARY_RESPONSE_SUCCESS = 0x00,
        PROTOCOL_BINARY_RESPONSE_KEY_ENOENT = 0x01,
        PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS = 0x02,
        PROTOCOL_BINARY_RESPONSE_E2BIG = 0x03,
        PROTOCOL_BINARY_RESPONSE_EINVAL = 0x04,
        PROTOCOL_BINARY_RESPONSE_NOT_STORED = 0x05,
        PROTOCOL_BINARY_RESPONSE_DELTA_BADVAL = 0x06,
        PROTOCOL_BINARY_RESPONSE_AUTH_ERROR = 0x20,
        PROTOCOL_BINARY_RESPONSE_AUTH_CONTINUE = 0x21,
        PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND = 0x81,
        PROTOCOL_BINARY_RESPONSE_ENOMEM = 0x82
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2312,64330,protocol_binary_command,4,protocol_binary_command,,protocol_binary.h,"typedef enum {
        PROTOCOL_BINARY_CMD_GET = 0x00,
        PROTOCOL_BINARY_CMD_SET = 0x01,
        PROTOCOL_BINARY_CMD_ADD = 0x02,
        PROTOCOL_BINARY_CMD_REPLACE = 0x03,
        PROTOCOL_BINARY_CMD_DELETE = 0x04,
        PROTOCOL_BINARY_CMD_INCREMENT = 0x05,
        PROTOCOL_BINARY_CMD_DECREMENT = 0x06,
        PROTOCOL_BINARY_CMD_QUIT = 0x07,
        PROTOCOL_BINARY_CMD_FLUSH = 0x08,
        PROTOCOL_BINARY_CMD_GETQ = 0x09,
        PROTOCOL_BINARY_CMD_NOOP = 0x0a,
        PROTOCOL_BINARY_CMD_VERSION = 0x0b,
        PROTOCOL_BINARY_CMD_GETK = 0x0c,
        PROTOCOL_BINARY_CMD_GETKQ = 0x0d,
        PROTOCOL_BINARY_CMD_APPEND = 0x0e,
        PROTOCOL_BINARY_CMD_PREPEND = 0x0f,
        PROTOCOL_BINARY_CMD_STAT = 0x10,
        PROTOCOL_BINARY_CMD_SETQ = 0x11,
        PROTOCOL_BINARY_CMD_ADDQ = 0x12,
        PROTOCOL_BINARY_CMD_REPLACEQ = 0x13,
        PROTOCOL_BINARY_CMD_DELETEQ = 0x14,
        PROTOCOL_BINARY_CMD_INCREMENTQ = 0x15,
        PROTOCOL_BINARY_CMD_DECREMENTQ = 0x16...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2313,64528,protocol_binary_datatypes,4,protocol_binary_datatypes,,protocol_binary.h,"typedef enum {
        PROTOCOL_BINARY_RAW_BYTES = 0x00
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2314,64538,protocol_binary_request_header,4,protocol_binary_request_header,,protocol_binary.h,"typedef union {
        struct {
            uint8_t magic;
            uint8_t opcode;
            uint16_t keylen;
            uint8_t extlen;
            uint8_t datatype;
            uint16_t reserved;
            uint32_t bodylen;
            uint32_t opaque;
            uint64_t cas;
        } request;
        uint8_t bytes[24];
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2315,64539,protocol_binary_request_header.request,4,protocol_binary_request_header.request,,protocol_binary.h,"struct {
            uint8_t magic;
            uint8_t opcode;
            uint16_t keylen;
            uint8_t extlen;
            uint8_t datatype;
            uint16_t reserved;
            uint32_t bodylen;
            uint32_t opaque;
            uint64_t cas;
        }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2316,64558,protocol_binary_response_header,4,protocol_binary_response_header,,protocol_binary.h,"typedef union {
        struct {
            uint8_t magic;
            uint8_t opcode;
            uint16_t keylen;
            uint8_t extlen;
            uint8_t datatype;
            uint16_t status;
            uint32_t bodylen;
            uint32_t opaque;
            uint64_t cas;
        } response;
        uint8_t bytes[24];
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2317,64559,protocol_binary_response_header.response,4,protocol_binary_response_header.response,,protocol_binary.h,"struct {
            uint8_t magic;
            uint8_t opcode;
            uint16_t keylen;
            uint8_t extlen;
            uint8_t datatype;
            uint16_t status;
            uint32_t bodylen;
            uint32_t opaque;
            uint64_t cas;
        }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2318,64578,protocol_binary_request_no_extras,4,protocol_binary_request_no_extras,,protocol_binary.h,"typedef union {
        struct {
            protocol_binary_request_header header;
        } message;
        uint8_t bytes[sizeof(protocol_binary_request_header)];
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2319,64579,protocol_binary_request_no_extras.message,4,protocol_binary_request_no_extras.message,,protocol_binary.h,"struct {
            protocol_binary_request_header header;
        }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2320,64591,protocol_binary_response_no_extras,4,protocol_binary_response_no_extras,,protocol_binary.h,"typedef union {
        struct {
            protocol_binary_response_header header;
        } message;
        uint8_t bytes[sizeof(protocol_binary_response_header)];
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2321,64592,protocol_binary_response_no_extras.message,4,protocol_binary_response_no_extras.message,,protocol_binary.h,"struct {
            protocol_binary_response_header header;
        }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2322,64604,protocol_binary_request_get,4,protocol_binary_request_get,,protocol_binary.h,typedef protocol_binary_request_no_extras protocol_binary_request_get;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2323,64605,protocol_binary_request_getq,4,protocol_binary_request_getq,,protocol_binary.h,typedef protocol_binary_request_no_extras protocol_binary_request_getq;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2324,64606,protocol_binary_request_getk,4,protocol_binary_request_getk,,protocol_binary.h,typedef protocol_binary_request_no_extras protocol_binary_request_getk;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2325,64607,protocol_binary_request_getkq,4,protocol_binary_request_getkq,,protocol_binary.h,typedef protocol_binary_request_no_extras protocol_binary_request_getkq;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2326,64608,protocol_binary_response_get,4,protocol_binary_response_get,,protocol_binary.h,"typedef union {
        struct {
            protocol_binary_response_header header;
            struct {
                uint32_t flags;
            } body;
        } message;
        uint8_t bytes[sizeof(protocol_binary_response_header) + 4];
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2327,64609,protocol_binary_response_get.message,4,protocol_binary_response_get.message,,protocol_binary.h,"struct {
            protocol_binary_response_header header;
            struct {
                uint32_t flags;
            } body;
        }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2328,64611,protocol_binary_response_get.message.body,4,protocol_binary_response_get.message.body,,protocol_binary.h,"struct {
                uint32_t flags;
            }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2329,64626,protocol_binary_response_getq,4,protocol_binary_response_getq,,protocol_binary.h,typedef protocol_binary_response_get protocol_binary_response_getq;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2330,64627,protocol_binary_response_getk,4,protocol_binary_response_getk,,protocol_binary.h,typedef protocol_binary_response_get protocol_binary_response_getk;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2331,64628,protocol_binary_response_getkq,4,protocol_binary_response_getkq,,protocol_binary.h,typedef protocol_binary_response_get protocol_binary_response_getkq;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2332,64629,protocol_binary_request_delete,4,protocol_binary_request_delete,,protocol_binary.h,typedef protocol_binary_request_no_extras protocol_binary_request_delete;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2333,64630,protocol_binary_response_delete,4,protocol_binary_response_delete,,protocol_binary.h,typedef protocol_binary_response_no_extras protocol_binary_response_delete;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2334,64631,protocol_binary_request_flush,4,protocol_binary_request_flush,,protocol_binary.h,"typedef union {
        struct {
            protocol_binary_request_header header;
            struct {
                uint32_t expiration;
            } body;
        } message;
        uint8_t bytes[sizeof(protocol_binary_request_header) + 4];
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2335,64632,protocol_binary_request_flush.message,4,protocol_binary_request_flush.message,,protocol_binary.h,"struct {
            protocol_binary_request_header header;
            struct {
                uint32_t expiration;
            } body;
        }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2336,64634,protocol_binary_request_flush.message.body,4,protocol_binary_request_flush.message.body,,protocol_binary.h,"struct {
                uint32_t expiration;
            }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2337,64649,protocol_binary_response_flush,4,protocol_binary_response_flush,,protocol_binary.h,typedef protocol_binary_response_no_extras protocol_binary_response_flush;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2338,64650,protocol_binary_request_set,4,protocol_binary_request_set,,protocol_binary.h,"typedef union {
        struct {
            protocol_binary_request_header header;
            struct {
                uint32_t flags;
                uint32_t expiration;
            } body;
        } message;
        uint8_t bytes[sizeof(protocol_binary_request_header) + 8];
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2339,64651,protocol_binary_request_set.message,4,protocol_binary_request_set.message,,protocol_binary.h,"struct {
            protocol_binary_request_header header;
            struct {
                uint32_t flags;
                uint32_t expiration;
            } body;
        }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2340,64653,protocol_binary_request_set.message.body,4,protocol_binary_request_set.message.body,,protocol_binary.h,"struct {
                uint32_t flags;
                uint32_t expiration;
            }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2341,64669,protocol_binary_request_add,4,protocol_binary_request_add,,protocol_binary.h,typedef protocol_binary_request_set protocol_binary_request_add;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2342,64670,protocol_binary_request_replace,4,protocol_binary_request_replace,,protocol_binary.h,typedef protocol_binary_request_set protocol_binary_request_replace;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2343,64671,protocol_binary_response_set,4,protocol_binary_response_set,,protocol_binary.h,typedef protocol_binary_response_no_extras protocol_binary_response_set;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2344,64672,protocol_binary_response_add,4,protocol_binary_response_add,,protocol_binary.h,typedef protocol_binary_response_no_extras protocol_binary_response_add;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2345,64673,protocol_binary_response_replace,4,protocol_binary_response_replace,,protocol_binary.h,typedef protocol_binary_response_no_extras protocol_binary_response_replace;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2346,64674,protocol_binary_request_noop,4,protocol_binary_request_noop,,protocol_binary.h,typedef protocol_binary_request_no_extras protocol_binary_request_noop;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2347,64675,protocol_binary_response_noop,4,protocol_binary_response_noop,,protocol_binary.h,typedef protocol_binary_response_no_extras protocol_binary_response_noop;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2348,64676,protocol_binary_request_incr,4,protocol_binary_request_incr,,protocol_binary.h,"typedef union {
        struct {
            protocol_binary_request_header header;
            struct {
                uint64_t delta;
                uint64_t initial;
                uint32_t expiration;
            } body;
        } message;
        uint8_t bytes[sizeof(protocol_binary_request_header) + 20];
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2349,64677,protocol_binary_request_incr.message,4,protocol_binary_request_incr.message,,protocol_binary.h,"struct {
            protocol_binary_request_header header;
            struct {
                uint64_t delta;
                uint64_t initial;
                uint32_t expiration;
            } body;
        }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2350,64679,protocol_binary_request_incr.message.body,4,protocol_binary_request_incr.message.body,,protocol_binary.h,"struct {
                uint64_t delta;
                uint64_t initial;
                uint32_t expiration;
            }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2351,64696,protocol_binary_request_decr,4,protocol_binary_request_decr,,protocol_binary.h,typedef protocol_binary_request_incr protocol_binary_request_decr;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2352,64697,protocol_binary_response_incr,4,protocol_binary_response_incr,,protocol_binary.h,"typedef union {
        struct {
            protocol_binary_response_header header;
            struct {
                uint64_t value;
            } body;
        } message;
        uint8_t bytes[sizeof(protocol_binary_response_header) + 8];
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2353,64698,protocol_binary_response_incr.message,4,protocol_binary_response_incr.message,,protocol_binary.h,"struct {
            protocol_binary_response_header header;
            struct {
                uint64_t value;
            } body;
        }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2354,64700,protocol_binary_response_incr.message.body,4,protocol_binary_response_incr.message.body,,protocol_binary.h,"struct {
                uint64_t value;
            }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2355,64715,protocol_binary_response_decr,4,protocol_binary_response_decr,,protocol_binary.h,typedef protocol_binary_response_incr protocol_binary_response_decr;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2356,64716,protocol_binary_request_quit,4,protocol_binary_request_quit,,protocol_binary.h,typedef protocol_binary_request_no_extras protocol_binary_request_quit;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2357,64717,protocol_binary_response_quit,4,protocol_binary_response_quit,,protocol_binary.h,typedef protocol_binary_response_no_extras protocol_binary_response_quit;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2358,64718,protocol_binary_request_append,4,protocol_binary_request_append,,protocol_binary.h,typedef protocol_binary_request_no_extras protocol_binary_request_append;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2359,64719,protocol_binary_request_prepend,4,protocol_binary_request_prepend,,protocol_binary.h,typedef protocol_binary_request_no_extras protocol_binary_request_prepend;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2360,64720,protocol_binary_response_append,4,protocol_binary_response_append,,protocol_binary.h,typedef protocol_binary_response_no_extras protocol_binary_response_append;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2361,64721,protocol_binary_response_prepend,4,protocol_binary_response_prepend,,protocol_binary.h,typedef protocol_binary_response_no_extras protocol_binary_response_prepend;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2362,64722,protocol_binary_request_version,4,protocol_binary_request_version,,protocol_binary.h,typedef protocol_binary_request_no_extras protocol_binary_request_version;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2363,64723,protocol_binary_response_version,4,protocol_binary_response_version,,protocol_binary.h,typedef protocol_binary_response_no_extras protocol_binary_response_version;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2364,64724,protocol_binary_request_stats,4,protocol_binary_request_stats,,protocol_binary.h,typedef protocol_binary_request_no_extras protocol_binary_request_stats;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2365,64725,protocol_binary_response_stats,4,protocol_binary_response_stats,,protocol_binary.h,typedef protocol_binary_response_no_extras protocol_binary_response_stats;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2366,64726,protocol_binary_request_touch,4,protocol_binary_request_touch,,protocol_binary.h,"typedef union {
        struct {
            protocol_binary_request_header header;
            struct {
                uint32_t expiration;
            } body;
        } message;
        uint8_t bytes[sizeof(protocol_binary_request_header) + 4];
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2367,64727,protocol_binary_request_touch.message,4,protocol_binary_request_touch.message,,protocol_binary.h,"struct {
            protocol_binary_request_header header;
            struct {
                uint32_t expiration;
            } body;
        }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2368,64729,protocol_binary_request_touch.message.body,4,protocol_binary_request_touch.message.body,,protocol_binary.h,"struct {
                uint32_t expiration;
            }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2369,64744,protocol_binary_response_touch,4,protocol_binary_response_touch,,protocol_binary.h,typedef protocol_binary_response_no_extras protocol_binary_response_touch;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2370,64745,protocol_binary_request_gat,4,protocol_binary_request_gat,,protocol_binary.h,"typedef union {
        struct {
            protocol_binary_request_header header;
            struct {
                uint32_t expiration;
            } body;
        } message;
        uint8_t bytes[sizeof(protocol_binary_request_header) + 4];
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2371,64746,protocol_binary_request_gat.message,4,protocol_binary_request_gat.message,,protocol_binary.h,"struct {
            protocol_binary_request_header header;
            struct {
                uint32_t expiration;
            } body;
        }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2372,64748,protocol_binary_request_gat.message.body,4,protocol_binary_request_gat.message.body,,protocol_binary.h,"struct {
                uint32_t expiration;
            }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2373,64763,protocol_binary_request_gatq,4,protocol_binary_request_gatq,,protocol_binary.h,typedef protocol_binary_request_gat protocol_binary_request_gatq;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2374,64764,protocol_binary_request_gatk,4,protocol_binary_request_gatk,,protocol_binary.h,typedef protocol_binary_request_gat protocol_binary_request_gatk;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2375,64765,protocol_binary_request_gatkq,4,protocol_binary_request_gatkq,,protocol_binary.h,typedef protocol_binary_request_gat protocol_binary_request_gatkq;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2376,64766,protocol_binary_response_gat,4,protocol_binary_response_gat,,protocol_binary.h,typedef protocol_binary_response_get protocol_binary_response_gat;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2377,64767,protocol_binary_response_gatq,4,protocol_binary_response_gatq,,protocol_binary.h,typedef protocol_binary_response_get protocol_binary_response_gatq;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2378,64768,protocol_binary_response_gatk,4,protocol_binary_response_gatk,,protocol_binary.h,typedef protocol_binary_response_get protocol_binary_response_gatk;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2379,64769,protocol_binary_response_gatkq,4,protocol_binary_response_gatkq,,protocol_binary.h,typedef protocol_binary_response_get protocol_binary_response_gatkq;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2380,64770,protocol_binary_request_rangeop,4,protocol_binary_request_rangeop,,protocol_binary.h,"typedef union {
        struct {
            protocol_binary_response_header header;
            struct {
                uint16_t size;
                uint8_t  reserved;
                uint8_t  flags;
                uint32_t max_results;
            } body;
        } message;
        uint8_t bytes[sizeof(protocol_binary_request_header) + 4];
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2381,64771,protocol_binary_request_rangeop.message,4,protocol_binary_request_rangeop.message,,protocol_binary.h,"struct {
            protocol_binary_response_header header;
            struct {
                uint16_t size;
                uint8_t  reserved;
                uint8_t  flags;
                uint32_t max_results;
            } body;
        }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2382,64773,protocol_binary_request_rangeop.message.body,4,protocol_binary_request_rangeop.message.body,,protocol_binary.h,"struct {
                uint16_t size;
                uint8_t  reserved;
                uint8_t  flags;
                uint32_t max_results;
            }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2383,64791,protocol_binary_request_rget,4,protocol_binary_request_rget,,protocol_binary.h,typedef protocol_binary_request_rangeop protocol_binary_request_rget;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2384,64792,protocol_binary_request_rset,4,protocol_binary_request_rset,,protocol_binary.h,typedef protocol_binary_request_rangeop protocol_binary_request_rset;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2385,64793,protocol_binary_request_rsetq,4,protocol_binary_request_rsetq,,protocol_binary.h,typedef protocol_binary_request_rangeop protocol_binary_request_rsetq;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2386,64794,protocol_binary_request_rappend,4,protocol_binary_request_rappend,,protocol_binary.h,typedef protocol_binary_request_rangeop protocol_binary_request_rappend;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2387,64795,protocol_binary_request_rappendq,4,protocol_binary_request_rappendq,,protocol_binary.h,typedef protocol_binary_request_rangeop protocol_binary_request_rappendq;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2388,64796,protocol_binary_request_rprepend,4,protocol_binary_request_rprepend,,protocol_binary.h,typedef protocol_binary_request_rangeop protocol_binary_request_rprepend;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2389,64797,protocol_binary_request_rprependq,4,protocol_binary_request_rprependq,,protocol_binary.h,typedef protocol_binary_request_rangeop protocol_binary_request_rprependq;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2390,64798,protocol_binary_request_rdelete,4,protocol_binary_request_rdelete,,protocol_binary.h,typedef protocol_binary_request_rangeop protocol_binary_request_rdelete;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2391,64799,protocol_binary_request_rdeleteq,4,protocol_binary_request_rdeleteq,,protocol_binary.h,typedef protocol_binary_request_rangeop protocol_binary_request_rdeleteq;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2392,64800,protocol_binary_request_rincr,4,protocol_binary_request_rincr,,protocol_binary.h,typedef protocol_binary_request_rangeop protocol_binary_request_rincr;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2393,64801,protocol_binary_request_rincrq,4,protocol_binary_request_rincrq,,protocol_binary.h,typedef protocol_binary_request_rangeop protocol_binary_request_rincrq;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2394,64802,protocol_binary_request_rdecr,4,protocol_binary_request_rdecr,,protocol_binary.h,typedef protocol_binary_request_rangeop protocol_binary_request_rdecr;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2395,64803,protocol_binary_request_rdecrq,4,protocol_binary_request_rdecrq,,protocol_binary.h,typedef protocol_binary_request_rangeop protocol_binary_request_rdecrq;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2396,64843,proxy_defines,4,proxy_defines,,proxy.h,"enum proxy_defines {
    P_OK = 0,
    CMD_FIELDS
    CMD_SIZE, // used to define array size for command hooks.
    CMD_ANY, // override _all_ commands
    CMD_ANY_STORAGE, // override commands specific to key storage.
    CMD_FINAL, // end cap for convenience.
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2397,64890,proxy_cmd_types,4,proxy_cmd_types,,proxy.h,"enum proxy_cmd_types {
    CMD_TYPE_GENERIC = 0,
    CMD_TYPE_GET, // get/gets/gat/gats
    CMD_TYPE_META, // m*'s.
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2398,64901,proxy_be_failures,4,proxy_be_failures,,proxy.h,"enum proxy_be_failures {
    P_BE_FAIL_TIMEOUT = 0,
    P_BE_FAIL_DISCONNECTED,
    P_BE_FAIL_CONNECTING,
    P_BE_FAIL_WRITING,
    P_BE_FAIL_READING,
    P_BE_FAIL_PARSING,
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2399,64915,_io_pending_proxy_t,4,_io_pending_proxy_t,,proxy.h,typedef struct _io_pending_proxy_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2400,64916,io_pending_proxy_t,4,io_pending_proxy_t,,proxy.h,typedef struct _io_pending_proxy_t io_pending_proxy_t;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2401,64917,proxy_event_thread_s,4,proxy_event_thread_s,,proxy.h,typedef struct proxy_event_thread_s,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2402,64918,proxy_event_thread_t,4,proxy_event_thread_t,,proxy.h,typedef struct proxy_event_thread_s proxy_event_thread_t;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2403,64919,proxy_int_stats,4,proxy_int_stats,,proxy.h,"struct proxy_int_stats {
    uint64_t counters[CMD_FINAL];
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2404,64927,proxy_user_stats,4,proxy_user_stats,,proxy.h,"struct proxy_user_stats {
    size_t num_stats; // number of stats, for sizing various arrays
    char **names; // not needed for worker threads
    uint64_t *counters; // array of counters.
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2405,64931,proxy_global_stats,4,proxy_global_stats,,proxy.h,"struct proxy_global_stats {
    uint64_t config_reloads;
    uint64_t config_reload_fails;
    uint64_t backend_total;
    uint64_t backend_disconn; // backends with no connections
    uint64_t backend_requests; // reqs sent to backends
    uint64_t backend_responses; // responses received from backends
    uint64_t backend_errors; // errors from backends
    uint64_t backend_marked_bad; // backend set to autofail
    uint64_t backend_failed; // an error caused a backend reset
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2406,64941,proxy_tunables,4,proxy_tunables,,proxy.h,"struct proxy_tunables {
    struct timeval connect;
    struct timeval retry; // wait time before retrying a dead backend
    struct timeval read;
#ifdef HAVE_LIBURING
    struct __kernel_timespec connect_ur;
    struct __kernel_timespec retry_ur;
    struct __kernel_timespec read_ur;
#endif // HAVE_LIBURING
    int backend_failure_limit;
    bool tcp_keepalive;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2407,64942,timeval,4,proxy_tunables.timeval,,proxy.h,struct timeval,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2408,64944,timeval,4,proxy_tunables.timeval,,proxy.h,struct timeval,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2409,64946,timeval,4,proxy_tunables.timeval,,proxy.h,struct timeval,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2410,64948,__kernel_timespec,4,proxy_tunables.__kernel_timespec,,proxy.h,struct __kernel_timespec,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2411,64950,__kernel_timespec,4,proxy_tunables.__kernel_timespec,,proxy.h,struct __kernel_timespec,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2412,64952,__kernel_timespec,4,proxy_tunables.__kernel_timespec,,proxy.h,struct __kernel_timespec,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2413,64956,pool_head_s,4,pool_head_s,,proxy.h,"typedef STAILQ_HEAD(pool_head_s, mcp_pool_s)",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2414,64957,mcp_pool_s,4,pool_head_s.mcp_pool_s,,proxy.h,mcp_pool_s,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2415,64959,mcp_pool_s,4,pool_head_s.mcp_pool_s,,proxy.h,mcp_pool_s,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2416,64961,pool_head_t,4,pool_head_t,,proxy.h,"typedef STAILQ_HEAD(pool_head_s, mcp_pool_s) pool_head_t;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2417,64962,proxy_ctx_t,4,proxy_ctx_t,,proxy.h,"typedef struct {
    lua_State *proxy_state;
    void *proxy_code;
    proxy_event_thread_t *proxy_threads;
    pthread_mutex_t config_lock;
    pthread_cond_t config_cond;
    pthread_t config_tid;
    pthread_mutex_t worker_lock;
    pthread_cond_t worker_cond;
    pthread_t manager_tid; // deallocation management thread
    pthread_mutex_t manager_lock;
    pthread_cond_t manager_cond;
    pool_head_t manager_head; // stack for pool deallocation.
    bool worker_done; // signal variable for the worker lock/cond system.
    bool worker_failed; // covered by worker_lock as well.
    bool use_uring; // use IO_URING for backend connections.
    struct proxy_global_stats global_stats;
    struct proxy_user_stats user_stats;
    struct proxy_tunables tunables; // NOTE: updates covered by stats_lock
    pthread_mutex_t stats_lock; // used for rare global counters
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2418,64978,proxy_global_stats,4,proxy_ctx_t.proxy_global_stats,,proxy.h,struct proxy_global_stats,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2419,64980,proxy_user_stats,4,proxy_ctx_t.proxy_user_stats,,proxy.h,struct proxy_user_stats,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2420,64982,proxy_tunables,4,proxy_ctx_t.proxy_tunables,,proxy.h,struct proxy_tunables,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2421,64986,proxy_hook_tagged,4,proxy_hook_tagged,,proxy.h,"struct proxy_hook_tagged {
    uint64_t tag;
    int lua_ref;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2422,64989,proxy_hook,4,proxy_hook,,proxy.h,"struct proxy_hook {
    int lua_ref;
    int tagcount;
    struct proxy_hook_tagged *tagged; // array of possible tagged hooks.
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2423,64992,proxy_hook_tagged,4,proxy_hook.proxy_hook_tagged,,proxy.h,struct proxy_hook_tagged,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2424,65001,proxy_hash_func,4,proxy_hash_func,,proxy.h,"struct proxy_hash_func {
    key_hash_func func;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2425,65017,proxy_hash_caller,4,proxy_hash_caller,,proxy.h,"struct proxy_hash_caller {
    hash_selector_func selector_func;
    void *ctx;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2426,65020,mcp_backend_states,4,mcp_backend_states,,proxy.h,"enum mcp_backend_states {
    mcp_backend_read = 0, // waiting to read any response
    mcp_backend_parse, // have some buffered data to check
    mcp_backend_read_end, // looking for an ""END"" marker for GET
    mcp_backend_want_read, // read more data to complete command
    mcp_backend_next, // advance to the next IO
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2427,65033,mcp_backend_s,4,mcp_backend_s,,proxy.h,typedef struct mcp_backend_s,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2428,65034,mcp_backend_t,4,mcp_backend_t,,proxy.h,typedef struct mcp_backend_s mcp_backend_t;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2429,65035,mcp_request_s,4,mcp_request_s,,proxy.h,typedef struct mcp_request_s,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2430,65036,mcp_request_t,4,mcp_request_t,,proxy.h,typedef struct mcp_request_s mcp_request_t;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2431,65037,mcp_parser_s,4,mcp_parser_s,,proxy.h,typedef struct mcp_parser_s,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2432,65038,mcp_parser_t,4,mcp_parser_t,,proxy.h,typedef struct mcp_parser_s mcp_parser_t;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2433,65039,mcp_parser_meta_s,4,mcp_parser_meta_s,,proxy.h,"struct mcp_parser_meta_s {
    uint64_t flags;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2434,65041,mcp_parser_s,4,mcp_parser_s,,proxy.h,"struct mcp_parser_s {
    const char *request;
    void *vbuf; // temporary buffer for holding value lengths.
    uint8_t command;
    uint8_t cmd_type; // command class.
    uint8_t ntokens;
    uint8_t keytoken; // because GAT. sigh. also cmds without a key.
    uint32_t parsed; // how far into the request we parsed already
    uint32_t reqlen; // full length of request buffer.
    int vlen;
    uint32_t klen; // length of key.
    uint16_t tokens[PARSER_MAX_TOKENS]; // offsets for start of each token
    bool has_space; // a space was found after the last byte parsed.
    bool noreply; // if quiet/noreply mode is set.
    union {
        struct mcp_parser_meta_s meta;
    } t;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2435,65055,mcp_parser_s.t,4,mcp_parser_s.t,,proxy.h,"union {
        struct mcp_parser_meta_s meta;
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2436,65056,mcp_parser_meta_s,4,mcp_parser_s.t.mcp_parser_meta_s,,proxy.h,struct mcp_parser_meta_s,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2437,65067,mcp_request_s,4,mcp_request_s,,proxy.h,"struct mcp_request_s {
    mcp_parser_t pr; // non-lua-specific parser handling.
    struct timeval start; // time this object was created.
    mcp_backend_t *be; // backend handling this request.
    bool ascii_multiget; // ascii multiget mode. (hide errors/END)
    bool was_modified; // need to rewrite the request
    int tokent_ref; // reference to token table if modified.
    char request[];
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2438,65069,timeval,4,mcp_request_s.timeval,,proxy.h,struct timeval,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2439,65081,io_head_s,4,io_head_s,,proxy.h,"typedef STAILQ_HEAD(io_head_s, _io_pending_proxy_t)",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2440,65082,_io_pending_proxy_t,4,io_head_s._io_pending_proxy_t,,proxy.h,_io_pending_proxy_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2441,65084,_io_pending_proxy_t,4,io_head_s._io_pending_proxy_t,,proxy.h,_io_pending_proxy_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2442,65086,io_head_t,4,io_head_t,,proxy.h,"typedef STAILQ_HEAD(io_head_s, _io_pending_proxy_t) io_head_t;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2443,65087,mcp_backend_s,4,mcp_backend_s,,proxy.h,"struct mcp_backend_s {
    int depth;
    int failed_count; // number of fails (timeouts) in a row
    pthread_mutex_t mutex; // covers stack.
    proxy_event_thread_t *event_thread; // event thread owning this backend.
    void *client; // mcmc client
    STAILQ_ENTRY(mcp_backend_s) be_next; // stack for backends
    io_head_t io_head; // stack of requests.
    char *rbuf; // statically allocated read buffer.
    size_t rbufused; // currently active bytes in the buffer
    struct event event; // libevent
#ifdef HAVE_LIBURING
    proxy_event_t ur_rd_ev; // liburing.
    proxy_event_t ur_wr_ev; // need a separate event/cb for writing/polling
    proxy_event_t ur_te_ev; // for timeout handling
#endif
    enum mcp_backend_states state; // readback state machine
    int connect_flags; // flags to pass to mcmc_connect
    bool connecting; // in the process of an asynch connection.
    bool can_write; // recently got a WANT_WRITE or are connecting.
    bool stacked; // if backend already ...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2444,65093,mcp_backend_s.be_next,4,mcp_backend_s.be_next,,proxy.h,STAILQ_ENTRY(mcp_backend_s),-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2445,65094,mcp_backend_s,4,mcp_backend_s.be_next.mcp_backend_s,,proxy.h,mcp_backend_s,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2446,65100,event,4,mcp_backend_s.event,,proxy.h,struct event,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2447,65105,mcp_backend_states,4,mcp_backend_s.mcp_backend_states,,proxy.h,enum mcp_backend_states,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2448,65112,iovec,4,mcp_backend_s.iovec,,proxy.h,struct iovec,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2449,65136,be_head_s,4,be_head_s,,proxy.h,"typedef STAILQ_HEAD(be_head_s, mcp_backend_s)",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2450,65137,mcp_backend_s,4,be_head_s.mcp_backend_s,,proxy.h,mcp_backend_s,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2451,65139,mcp_backend_s,4,be_head_s.mcp_backend_s,,proxy.h,mcp_backend_s,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2452,65141,be_head_t,4,be_head_t,,proxy.h,"typedef STAILQ_HEAD(be_head_s, mcp_backend_s) be_head_t;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2453,65142,proxy_event_thread_s,4,proxy_event_thread_s,,proxy.h,"struct proxy_event_thread_s {
    pthread_t thread_id;
    struct event_base *base;
    struct event notify_event; // listen event for the notify pipe/eventfd.
    struct event clock_event; // timer for updating event thread data.
#ifdef HAVE_LIBURING
    struct io_uring ring;
    proxy_event_t ur_notify_event; // listen on eventfd.
    proxy_event_t ur_clock_event; // timer for updating event thread data.
    eventfd_t event_counter;
    bool use_uring;
#endif
    pthread_mutex_t mutex; // covers stack.
    pthread_cond_t cond; // condition to wait on while stack drains.
    io_head_t io_head_in; // inbound requests to process.
    be_head_t be_head; // stack of backends for processing.
#ifdef USE_EVENTFD
    int event_fd;
#else
    int notify_receive_fd;
    int notify_send_fd;
#endif
    proxy_ctx_t *ctx; // main context.
    struct proxy_tunables tunables; // periodically copied from main ctx
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2454,65144,event_base,4,proxy_event_thread_s.event_base,,proxy.h,struct event_base,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2455,65146,event,4,proxy_event_thread_s.event,,proxy.h,struct event,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2456,65148,event,4,proxy_event_thread_s.event,,proxy.h,struct event,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2457,65150,io_uring,4,proxy_event_thread_s.io_uring,,proxy.h,struct io_uring,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2458,65164,proxy_tunables,4,proxy_event_thread_s.proxy_tunables,,proxy.h,struct proxy_tunables,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2459,65166,mcp_resp_mode,4,mcp_resp_mode,,proxy.h,"enum mcp_resp_mode {
    RESP_MODE_NORMAL = 0,
    RESP_MODE_NOREPLY,
    RESP_MODE_METAQUIET
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2460,65177,mcp_resp_t,4,mcp_resp_t,,proxy.h,"typedef struct {
    mcmc_resp_t resp;
    char *buf; // response line + potentially value.
    size_t blen; // total size of the value to read.
    int status; // status code from mcmc_read()
    int bread; // amount of bytes read into value so far.
    uint8_t cmd; // from parser (pr.command)
    enum mcp_resp_mode mode; // reply mode (for noreply fixing)
    char be_name[MAX_NAMELEN+1];
    char be_port[MAX_PORTLEN+1];
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2461,65184,mcp_resp_mode,4,mcp_resp_t.mcp_resp_mode,,proxy.h,enum mcp_resp_mode,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2462,65205,_io_pending_proxy_t,4,_io_pending_proxy_t,,proxy.h,"struct _io_pending_proxy_t {
    int io_queue_type;
    LIBEVENT_THREAD *thread;
    conn *c;
    mc_resp *resp;  // original struct ends here

    struct _io_pending_proxy_t *next; // stack for IO submission
    STAILQ_ENTRY(_io_pending_proxy_t) io_next; // stack for backends
    int coro_ref; // lua registry reference to the coroutine
    int mcpres_ref; // mcp.res reference used for await()
    lua_State *coro; // pointer directly to the coroutine
    mcp_backend_t *backend; // backend server to request from
    struct iovec iov[2]; // request string + tail buffer
    int iovcnt; // 1 or 2...
    unsigned int iovbytes; // total bytes in the iovec
    int await_ref; // lua reference if we were an await object
    mcp_resp_t *client_resp; // reference (currently pointing to a lua object)
    bool flushed; // whether we've fully written this request to a backend.
    bool ascii_multiget; // passed on from mcp_r_t
    bool is_await; // are we an await object?
    bool await_first; //...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2463,65210,_io_pending_proxy_t,4,_io_pending_proxy_t._io_pending_proxy_t,,proxy.h,struct _io_pending_proxy_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2464,65212,_io_pending_proxy_t.io_next,4,_io_pending_proxy_t.io_next,,proxy.h,STAILQ_ENTRY(_io_pending_proxy_t),-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2465,65213,_io_pending_proxy_t,4,_io_pending_proxy_t.io_next._io_pending_proxy_t,,proxy.h,_io_pending_proxy_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2466,65220,iovec,4,_io_pending_proxy_t.iovec,,proxy.h,struct iovec,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2467,65236,mcp_pool_be_t,4,mcp_pool_be_t,,proxy.h,"typedef struct {
    int ref; // luaL_ref reference.
    mcp_backend_t *be;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2468,65240,mcp_pool_s,4,mcp_pool_s,,proxy.h,typedef struct mcp_pool_s,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2469,65241,mcp_pool_t,4,mcp_pool_t,,proxy.h,typedef struct mcp_pool_s mcp_pool_t;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2470,65242,mcp_pool_s,4,mcp_pool_s,,proxy.h,"struct mcp_pool_s {
    struct proxy_hash_caller phc;
    key_hash_filter_func key_filter;
    key_hash_func key_hasher;
    pthread_mutex_t lock; // protects refcount.
    proxy_ctx_t *ctx; // main context.
    STAILQ_ENTRY(mcp_pool_s) next; // stack for deallocator.
    char key_filter_conf[KEY_HASH_FILTER_MAX+1];
    uint64_t hash_seed; // calculated from a string.
    int refcount;
    int phc_ref;
    int self_ref; // TODO (v2): double check that this is needed.
    int pool_size;
    mcp_pool_be_t pool[];
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2471,65243,proxy_hash_caller,4,mcp_pool_s.proxy_hash_caller,,proxy.h,struct proxy_hash_caller,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2472,65249,mcp_pool_s.next,4,mcp_pool_s.next,,proxy.h,STAILQ_ENTRY(mcp_pool_s),-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2473,65250,mcp_pool_s,4,mcp_pool_s.next.mcp_pool_s,,proxy.h,mcp_pool_s,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2474,65271,mcp_pool_proxy_t,4,mcp_pool_proxy_t,,proxy.h,"typedef struct {
    mcp_pool_t *main; // ptr to original
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2475,65284,mcp_await_e,4,mcp_await_e,,proxy.h,"enum mcp_await_e {
    AWAIT_GOOD = 0, // looks for OK + NOT MISS
    AWAIT_ANY, // any response, including errors,
    AWAIT_OK, // any non-error response
    AWAIT_FIRST, // return the result from the first pool
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2476,65466,mcp_await_s,4,mcp_await_s,,proxy_await.c,"typedef struct mcp_await_s {
    int pending;
    int wait_for;
    int req_ref;
    int argtable_ref; // need to hold refs to any potential hash selectors
    int restable_ref; // table of result objects
    int coro_ref; // reference to parent coroutine
    enum mcp_await_e type;
    bool completed; // have we completed the parent coroutine or not
    mcp_request_t *rq;
    mc_resp *resp; // the top level mc_resp to fill in (as if we were an iop)
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2477,65473,mcp_await_e,4,mcp_await_s.mcp_await_e,,proxy_await.c,enum mcp_await_e,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2478,65478,mcp_await_t,4,mcp_await_t,,proxy_await.c,"typedef struct mcp_await_s {
    int pending;
    int wait_for;
    int req_ref;
    int argtable_ref; // need to hold refs to any potential hash selectors
    int restable_ref; // table of result objects
    int coro_ref; // reference to parent coroutine
    enum mcp_await_e type;
    bool completed; // have we completed the parent coroutine or not
    mcp_request_t *rq;
    mc_resp *resp; // the top level mc_resp to fill in (as if we were an iop)
} mcp_await_t;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2479,66470,_dumpbuf,4,_dumpbuf,,proxy_config.c,"struct _dumpbuf {
    size_t size;
    size_t used;
    char *buf;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2480,67877,mcplib_jump_hash_t,4,mcplib_jump_hash_t,,proxy_jump_hash.c,"typedef struct {
    struct proxy_hash_caller phc; // passed back to proxy API
    unsigned int buckets;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2481,67878,proxy_hash_caller,4,mcplib_jump_hash_t.proxy_hash_caller,,proxy_jump_hash.c,struct proxy_hash_caller,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2482,77047,cpoint,4,cpoint,,proxy_ring_hash.c,"typedef struct {
    unsigned int point; // continuum point.
    unsigned int id; // server id.
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2483,77051,ketama_t,4,ketama_t,,proxy_ring_hash.c,"typedef struct {
    struct proxy_hash_caller phc; // passed back to the proxy API.
    unsigned int total_buckets;
    cpoint continuum[]; // points to server ids.
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2484,77052,proxy_hash_caller,4,ketama_t.proxy_hash_caller,,proxy_ring_hash.c,struct proxy_hash_caller,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2485,77069,proxy_hash_func,4,proxy_hash_func,,proxy_ring_hash.c,static struct proxy_hash_func,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2486,78484,proxy_hash_func,4,proxy_hash_func,,proxy_xxhash.c,static struct proxy_hash_func,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2487,78531,_restart_data_cb,4,_restart_data_cb,,restart.c,typedef struct _restart_data_cb,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2488,78532,restart_data_cb,4,restart_data_cb,,restart.c,typedef struct _restart_data_cb restart_data_cb;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2489,78533,_restart_data_cb,4,_restart_data_cb,,restart.c,"struct _restart_data_cb {
    void *data; // user supplied opaque data.
    struct _restart_data_cb *next; // callbacks are ordered stack
    restart_check_cb ccb;
    restart_save_cb scb;
    char tag[RESTART_TAG_MAXLEN];
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2490,78535,_restart_data_cb,4,_restart_data_cb._restart_data_cb,,restart.c,struct _restart_data_cb,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2491,78648,restart_cb_ctx,4,restart_cb_ctx,,restart.c,"typedef struct {
    FILE *f;
    restart_data_cb *cb;
    char *line;
    bool done;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2492,79761,mc_ptr_t,4,mc_ptr_t,,restart.h,typedef uint32_t mc_ptr_t;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2493,79762,restart_get_kv_ret,4,restart_get_kv_ret,,restart.h,"enum restart_get_kv_ret {
    RESTART_OK=0, RESTART_NOTAG, RESTART_BADLINE, RESTART_DONE
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2494,79803,restart_get_kv_ret,4,restart_get_kv_ret,,restart.h,enum restart_get_kv_ret,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2495,79935,sasl_conn_t,4,sasl_conn_t,,sasl_defs.h,typedef void* sasl_conn_t;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2496,80050,window_data,4,window_data,,slab_automove.c,"struct window_data {
    uint64_t age;
    uint64_t dirty;
    float evicted_ratio;
    uint64_t evicted_seen; // if evictions were seen at all this window
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2497,80055,slab_automove,4,slab_automove,,slab_automove.c,"typedef struct {
    struct window_data *window_data;
    uint32_t window_size;
    uint32_t window_cur;
    double max_age_ratio;
    item_stats_automove iam_before[MAX_NUMBER_OF_SLAB_CLASSES];
    item_stats_automove iam_after[MAX_NUMBER_OF_SLAB_CLASSES];
    slab_stats_automove sam_before[MAX_NUMBER_OF_SLAB_CLASSES];
    slab_stats_automove sam_after[MAX_NUMBER_OF_SLAB_CLASSES];
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2498,80056,window_data,4,slab_automove.window_data,,slab_automove.c,struct window_data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2499,80732,slab_automove_reg_t,4,slab_automove_reg_t,,slab_automove.h,"typedef struct {
    slab_automove_init_func init;
    slab_automove_free_func free;
    slab_automove_run_func run;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2500,80750,window_data,4,window_data,,slab_automove_extstore.c,"struct window_data {
    uint64_t age;
    uint64_t dirty;
    uint64_t evicted;
    unsigned int excess_free;
    unsigned int relaxed;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2501,80756,slab_automove,4,slab_automove,,slab_automove_extstore.c,"typedef struct {
    struct window_data *window_data;
    struct settings *settings;
    uint32_t window_size;
    uint32_t window_cur;
    uint32_t item_size;
    double max_age_ratio;
    double free_ratio;
    bool pool_filled_once;
    unsigned int global_pool_watermark;
    item_stats_automove iam_before[MAX_NUMBER_OF_SLAB_CLASSES];
    item_stats_automove iam_after[MAX_NUMBER_OF_SLAB_CLASSES];
    slab_stats_automove sam_before[MAX_NUMBER_OF_SLAB_CLASSES];
    slab_stats_automove sam_after[MAX_NUMBER_OF_SLAB_CLASSES];
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2502,80757,window_data,4,slab_automove.window_data,,slab_automove_extstore.c,struct window_data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2503,80759,settings,4,slab_automove.settings,,slab_automove_extstore.c,struct settings,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2504,81602,slabclass_t,4,slabclass_t,,slabs.c,"typedef struct {
    unsigned int size;      /* sizes of items */
    unsigned int perslab;   /* how many items per slab */

    void *slots;           /* list of item ptrs */
    unsigned int sl_curr;   /* total free items in list */

    unsigned int slabs;     /* how many slabs were allocated for this class */

    void **slab_list;       /* array of slab pointers */
    unsigned int list_size; /* size of prev array */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2505,84238,move_status,4,move_status,,slabs.c,"enum move_status {
    MOVE_PASS=0, MOVE_FROM_SLAB, MOVE_FROM_LRU, MOVE_BUSY, MOVE_LOCKED
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2506,85797,slab_stats_automove,4,slab_stats_automove,,slabs.h,"typedef struct {
    unsigned int chunks_per_page;
    unsigned int chunk_size;
    long int free_chunks;
    long int total_pages;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2507,85846,reassign_result_type,4,reassign_result_type,,slabs.h,"enum reassign_result_type {
    REASSIGN_OK=0, REASSIGN_RUNNING, REASSIGN_BADCLASS, REASSIGN_NOSPARE,
    REASSIGN_SRC_DST_SAME
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2508,85859,reassign_result_type,4,reassign_result_type,,slabs.h,enum reassign_result_type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2509,86411,_prefix_stats,4,_prefix_stats,,stats_prefix.h,typedef struct _prefix_stats,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2510,86412,PREFIX_STATS,4,PREFIX_STATS,,stats_prefix.h,typedef struct _prefix_stats PREFIX_STATS;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2511,86413,_prefix_stats,4,_prefix_stats,,stats_prefix.h,"struct _prefix_stats {
    char *prefix;
    size_t prefix_len;
    uint64_t num_gets;
    uint64_t num_sets;
    uint64_t num_deletes;
    uint64_t num_hits;
    PREFIX_STATS *next;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2512,86531,extstore_conf_file,4,extstore_conf_file,,storage.h,struct extstore_conf_file,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2513,86611,test_return,4,test_return,,testapp.c,"enum test_return { TEST_SKIP, TEST_PASS, TEST_FAIL }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2514,86615,conn,4,conn,,testapp.c,"struct conn {
    int sock;
#ifdef TLS
    SSL_CTX   *ssl_ctx;
    SSL    *ssl;
#endif
    ssize_t (*read)(struct conn  *c, void *buf, size_t count);
    ssize_t (*write)(struct conn *c, const void *buf, size_t count);
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2515,86686,conn,4,conn,,testapp.c,static struct conn,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2516,93654,test_return,4,test_return,,testapp.c,typedef enum test_return,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2517,93655,,4,,,testapp.c,typedef enum test_return (*TEST_FUNC)(void);,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2518,93656,testcase,4,testcase,,testapp.c,"struct testcase {
    const char *description;
    TEST_FUNC function;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2519,93659,testcase,4,testcase,,testapp.c,struct testcase,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2520,94008,conn_queue_item_modes,4,conn_queue_item_modes,,thread.c,"enum conn_queue_item_modes {
    queue_new_conn,   /* brand new connection. */
    queue_pause,      /* pause thread */
    queue_timeout,    /* socket sfd timed out */
    queue_redispatch, /* return conn from side thread */
    queue_stop,       /* exit thread */
    queue_return_io,  /* returning a pending IO object immediately */
#ifdef PROXY
    queue_proxy_reload, /* signal proxy to reload worker VM */
#endif
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2521,94015,conn_queue_item,4,conn_queue_item,,thread.c,typedef struct conn_queue_item,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2522,94016,CQ_ITEM,4,CQ_ITEM,,thread.c,typedef struct conn_queue_item CQ_ITEM;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2523,94017,conn_queue_item,4,conn_queue_item,,thread.c,"struct conn_queue_item {
    int               sfd;
    enum conn_states  init_state;
    int               event_flags;
    int               read_buffer_size;
    enum network_transport     transport;
    enum conn_queue_item_modes mode;
    conn *c;
    void    *ssl;
    uint64_t conntag;
    enum protocol bproto;
    io_pending_t *io; // IO when used for deferred IO handling.
    STAILQ_ENTRY(conn_queue_item) i_next;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2524,94019,conn_states,4,conn_queue_item.conn_states,,thread.c,enum conn_states,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2525,94023,network_transport,4,conn_queue_item.network_transport,,thread.c,enum network_transport,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2526,94025,conn_queue_item_modes,4,conn_queue_item.conn_queue_item_modes,,thread.c,enum conn_queue_item_modes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2527,94030,protocol,4,conn_queue_item.protocol,,thread.c,enum protocol,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2528,94033,conn_queue_item.i_next,4,conn_queue_item.i_next,,thread.c,STAILQ_ENTRY(conn_queue_item),-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2529,94034,conn_queue_item,4,conn_queue_item.i_next.conn_queue_item,,thread.c,conn_queue_item,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2530,94037,conn_queue,4,conn_queue,,thread.c,typedef struct conn_queue,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2531,94038,CQ,4,CQ,,thread.c,typedef struct conn_queue CQ;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2532,94039,conn_queue,4,conn_queue,,thread.c,"struct conn_queue {
    STAILQ_HEAD(conn_ev_head, conn_queue_item) head;
    pthread_mutex_t lock;
    cache_t *cache; /* freelisted objects */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2533,94040,conn_ev_head,4,conn_queue.conn_ev_head,,thread.c,conn_ev_head,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2534,94041,conn_queue_item,4,conn_queue.conn_ev_head.conn_queue_item,,thread.c,conn_queue_item,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2535,94043,conn_queue_item,4,conn_queue.conn_ev_head.conn_queue_item,,thread.c,conn_queue_item,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2536,98730,mcmc_ctx,4,mcmc_ctx,,vendor\mcmc\mcmc.c,"typedef struct mcmc_ctx {
    int fd;
    int gai_status; // getaddrinfo() last status.
    int last_sys_error; // last syscall error (connect/etc?)
    int sent_bytes_partial; // note for partially sent buffers.
    int fail_code; // recent failure reason.
    int error; // latest error code.
    uint32_t status_flags; // internal only flags.
    int state;

    // FIXME: s/buffer_used/buffer_filled/ ?
    size_t buffer_used; // amount of bytes read into the buffer so far.
    size_t buffer_request_len; // cached endpoint for current request
    char *buffer_head; // buffer pointer currently in use.
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2537,98742,mcmc_ctx_t,4,mcmc_ctx_t,,vendor\mcmc\mcmc.c,"typedef struct mcmc_ctx {
    int fd;
    int gai_status; // getaddrinfo() last status.
    int last_sys_error; // last syscall error (connect/etc?)
    int sent_bytes_partial; // note for partially sent buffers.
    int fail_code; // recent failure reason.
    int error; // latest error code.
    uint32_t status_flags; // internal only flags.
    int state;

    // FIXME: s/buffer_used/buffer_filled/ ?
    size_t buffer_used; // amount of bytes read into the buffer so far.
    size_t buffer_request_len; // cached endpoint for current request
    char *buffer_head; // buffer pointer currently in use.
} mcmc_ctx_t;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2538,100253,mcmc_resp_t,4,mcmc_resp_t,,vendor\mcmc\mcmc.h,"typedef struct {
    unsigned short type;
    unsigned short code;
    char *value; // pointer to start of value in buffer.
    size_t reslen; // full length of the response line
    size_t vlen_read; // amount of value that was in supplied buffer.
    size_t vlen; // reslen + vlen is the full length of the response.
    union {
        // META response
        struct {
            char *rline; // start of meta response line.
            size_t rlen;
        };
        // GET response
        struct {
            char *key;
            size_t klen;
            uint32_t flags;
            uint64_t cas;
            // TODO: value info
        };
        // STAT response
        struct {
            char *stat;
            size_t slen;
        };
    };
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2539,100260,mcmc_resp_t.anonymous_composite_type_0,4,mcmc_resp_t.anonymous_composite_type_0,,vendor\mcmc\mcmc.h,"union {
        // META response
        struct {
            char *rline; // start of meta response line.
            size_t rlen;
        };
        // GET response
        struct {
            char *key;
            size_t klen;
            uint32_t flags;
            uint64_t cas;
            // TODO: value info
        };
        // STAT response
        struct {
            char *stat;
            size_t slen;
        };
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2540,100261,mcmc_resp_t.anonymous_composite_type_2.anonymous_composite_type_1,4,mcmc_resp_t.anonymous_composite_type_2.anonymous_composite_type_1,,vendor\mcmc\mcmc.h,"struct {
            char *rline; // start of meta response line.
            size_t rlen;
        }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2541,100264,mcmc_resp_t.anonymous_composite_type_4.anonymous_composite_type_3,4,mcmc_resp_t.anonymous_composite_type_4.anonymous_composite_type_3,,vendor\mcmc\mcmc.h,"struct {
            char *key;
            size_t klen;
            uint32_t flags;
            uint64_t cas;
            // TODO: value info
        }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2542,100269,mcmc_resp_t.anonymous_composite_type_6.anonymous_composite_type_5,4,mcmc_resp_t.anonymous_composite_type_6.anonymous_composite_type_5,,vendor\mcmc\mcmc.h,"struct {
            char *stat;
            size_t slen;
        }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2543,100391,XXH_errorcode,4,XXH_errorcode,,xxhash.h,"typedef enum { XXH_OK=0, XXH_ERROR }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2544,100402,XXH32_hash_t,4,XXH32_hash_t,,xxhash.h,typedef uint32_t XXH32_hash_t;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2545,100410,XXH32_state_s,4,XXH32_state_s,,xxhash.h,typedef struct XXH32_state_s,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2546,100411,XXH32_state_t,4,XXH32_state_t,,xxhash.h,typedef struct XXH32_state_s XXH32_state_t;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2547,100446,XXH32_canonical_t,4,XXH32_canonical_t,,xxhash.h,"typedef struct {
    unsigned char digest[4]; /*!< Hash bytes, big endian */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2548,100466,XXH64_hash_t,4,XXH64_hash_t,,xxhash.h,typedef uint64_t XXH64_hash_t;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2549,100474,XXH64_state_s,4,XXH64_state_s,,xxhash.h,typedef struct XXH64_state_s,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2550,100475,XXH64_state_t,4,XXH64_state_t,,xxhash.h,typedef struct XXH64_state_s XXH64_state_t;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2551,100510,XXH64_canonical_t,4,XXH64_canonical_t,,xxhash.h,typedef struct { unsigned char digest[sizeof(XXH64_hash_t)]; },-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2552,100552,XXH3_state_s,4,XXH3_state_s,,xxhash.h,typedef struct XXH3_state_s,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2553,100553,XXH3_state_t,4,XXH3_state_t,,xxhash.h,typedef struct XXH3_state_s XXH3_state_t;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2554,100600,XXH128_hash_t,4,XXH128_hash_t,,xxhash.h,"typedef struct {
    XXH64_hash_t low64;   /*!< `value & 0xFFFFFFFFFFFFFFFF` */
    XXH64_hash_t high64;  /*!< `value >> 64` */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2555,100667,XXH128_canonical_t,4,XXH128_canonical_t,,xxhash.h,typedef struct { unsigned char digest[sizeof(XXH128_hash_t)]; },-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2556,33,maintenance_cond,2,assoc.c.maintenance_cond,,assoc.c,pthread_cond_t maintenance_cond,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2557,37,maintenance_lock,2,assoc.c.maintenance_lock,,assoc.c,pthread_mutex_t maintenance_lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,15,0,1,1,0,0,,0,0,0,0,0,
2558,41,hashpower,2,assoc.c.hashpower,,assoc.c,unsigned int hashpower,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,23,0,1,1,0,0,,0,0,0,0,0,
2559,47,primary_hashtable,2,assoc.c.primary_hashtable,,assoc.c,item** primary_hashtable,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
2560,51,old_hashtable,2,assoc.c.old_hashtable,,assoc.c,item** old_hashtable,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
2561,55,expanding,2,assoc.c.expanding,,assoc.c,bool expanding,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
2562,59,expand_bucket,2,assoc.c.expand_bucket,,assoc.c,uint64_t expand_bucket,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
2563,562,do_run_maintenance_thread,2,assoc.c.do_run_maintenance_thread,,assoc.c,static volatile int do_run_maintenance_thread,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2564,566,hash_bulk_move,2,assoc.c.hash_bulk_move,,assoc.c,int hash_bulk_move,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
2565,782,maintenance_tid,2,assoc.c.maintenance_tid,,assoc.c,pthread_t maintenance_tid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2566,1135,hashpower,2,assoc.h.hashpower,,assoc.h,extern unsigned int hashpower,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2567,1136,item_lock_hashpower,2,assoc.h.item_lock_hashpower,,assoc.h,extern unsigned int item_lock_hashpower,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2568,1168,main_auth_entries,2,authfile.c.main_auth_entries,,authfile.c,auth_entry[8] main_auth_entries,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2569,1173,entry_cnt,2,authfile.c.entry_cnt,,authfile.c,int entry_cnt,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2570,1177,main_auth_data,2,authfile.c.main_auth_data,,authfile.c,char* main_auth_data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2571,1510,authfile_load,2,authfile.h.authfile_load,,authfile.h,enum authfile_ret authfile_load,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2572,1526,base64_table,2,base64.c.base64_table,,base64.c,unsigned char[65] base64_table,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
2573,1530,dtable,2,base64.c.dtable,,base64.c,unsigned char[256] dtable,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2574,2721,bipbuf_t,2,bipbuffer.h.bipbuf_t,,bipbuffer.h,struct bipbuf_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2575,2812,redzone_pattern,2,cache.c.redzone_pattern,,cache.c,const uint64_t redzone_pattern,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
2576,2816,cache_error,2,cache.c.cache_error,,cache.c,int cache_error,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2577,3391,cache_error,2,cache.h.cache_error,,cache.h,extern int cache_error,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2578,3411,cache_t,2,cache.h.cache_t,,cache.h,struct cache_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2579,3494,crawler_client_t,2,crawler.c.crawler_client_t,,crawler.c,struct crawler_client_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2580,3534,crawler_module_reg_t,2,crawler.c.crawler_module_reg_t,,crawler.c,struct crawler_module_reg_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2581,3564,crawler_expired_mod,2,crawler.c.crawler_expired_mod,,crawler.c,crawler_module_reg_t crawler_expired_mod,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2582,3605,crawler_metadump_mod,2,crawler.c.crawler_metadump_mod,,crawler.c,crawler_module_reg_t crawler_metadump_mod,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2583,3633,crawler_mod_regs,2,crawler.c.crawler_mod_regs,,crawler.c,crawler_module_reg_t *[3] crawler_mod_regs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2584,3648,active_crawler_mod,2,crawler.c.active_crawler_mod,,crawler.c,crawler_module_t active_crawler_mod,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,26,0,1,1,0,0,,0,0,0,0,0,
2585,3650,active_crawler_type,2,crawler.c.active_crawler_type,,crawler.c,enum crawler_run_type active_crawler_type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2586,3651,crawlers,2,crawler.c.crawlers,,crawler.c,static crawler[256] crawlers,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,18,0,1,1,0,0,,0,0,0,0,0,
2587,3656,crawler_count,2,crawler.c.crawler_count,,crawler.c,static int crawler_count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
2588,3660,do_run_lru_crawler_thread,2,crawler.c.do_run_lru_crawler_thread,,crawler.c,static volatile int do_run_lru_crawler_thread,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
2589,3664,lru_crawler_initialized,2,crawler.c.lru_crawler_initialized,,crawler.c,static int lru_crawler_initialized,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2590,3668,lru_crawler_lock,2,crawler.c.lru_crawler_lock,,crawler.c,pthread_mutex_t lru_crawler_lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,22,0,1,1,0,0,,0,0,0,0,0,
2591,3672,lru_crawler_cond,2,crawler.c.lru_crawler_cond,,crawler.c,pthread_cond_t lru_crawler_cond,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
2592,5263,item_crawler_tid,2,crawler.c.item_crawler_tid,,crawler.c,pthread_t item_crawler_tid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2593,6064,crawlerstats_t,2,crawler.h.crawlerstats_t,,crawler.h,struct crawlerstats_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2594,6107,lru_crawler_crawl,2,crawler.h.lru_crawler_crawl,,crawler.h,enum crawler_result_type lru_crawler_crawl,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2595,6141,crc32c,2,crc32c.c.crc32c,,crc32c.c,crc_func crc32c,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2596,6164,crc32c_once_little,2,crc32c.c.crc32c_once_little,,crc32c.c,pthread_once_t crc32c_once_little,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2597,6168,crc32c_table_little,2,crc32c.c.crc32c_table_little,,crc32c.c,static uint32_t[8][256] crc32c_table_little,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
2598,6599,crc32c_once_big,2,crc32c.c.crc32c_once_big,,crc32c.c,pthread_once_t crc32c_once_big,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2599,6603,crc32c_table_big_byte,2,crc32c.c.crc32c_table_big_byte,,crc32c.c,static uint32_t[256] crc32c_table_big_byte,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2600,6606,crc32c_table_big,2,crc32c.c.crc32c_table_big,,crc32c.c,static uint64_t[8][256] crc32c_table_big,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2601,7043,crc32c,2,crc32c.h.crc32c,,crc32c.h,crc_func crc32c,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2602,7274,store_io_thread,2,extstore.c.store_io_thread,,extstore.c,struct store_io_thread,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2603,7279,store_maint_thread,2,extstore.c.store_maint_thread,,extstore.c,struct store_maint_thread,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2604,10864,current_time,2,memcached.h.current_time,,memcached.h,volatile rel_time_t current_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2605,10868,stats_state,2,memcached.h.stats_state,,memcached.h,struct stats_state stats_state,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2606,10870,settings,2,memcached.h.settings,,memcached.h,struct settings settings,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2607,10872,slab_rebal,2,memcached.h.slab_rebal,,memcached.h,struct slab_rebalance slab_rebal,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2608,10873,slab_rebalance_signal,2,memcached.h.slab_rebalance_signal,,memcached.h,volatile int slab_rebalance_signal,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2609,10887,hash,2,hash.c.hash,,hash.c,hash_func hash,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2610,10960,hash,2,hash.h.hash,,hash.h,hash_func hash,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2611,11030,lru_type_map,2,items.c.lru_type_map,,items.c,unsigned int[4] lru_type_map,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
2612,11068,itemstats_t,2,items.c.itemstats_t,,items.c,struct itemstats_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2613,11069,heads,2,items.c.heads,,items.c,_stritem*[256] heads,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
2614,11074,tails,2,items.c.tails,,items.c,_stritem*[256] tails,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
2615,11079,itemstats,2,items.c.itemstats,,items.c,static itemstats_t[256] itemstats,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,47,0,1,1,0,0,,0,0,0,0,0,
2616,11084,sizes,2,items.c.sizes,,items.c,unsigned int[256] sizes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
2617,11089,sizes_bytes,2,items.c.sizes_bytes,,items.c,static uint64_t[256] sizes_bytes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
2618,11094,stats_sizes_hist,2,items.c.stats_sizes_hist,,items.c,static unsigned int* stats_sizes_hist,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,14,0,1,1,0,0,,0,0,0,0,0,
2619,11098,stats_sizes_cas_min,2,items.c.stats_sizes_cas_min,,items.c,uint64_t stats_sizes_cas_min,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2620,11102,stats_sizes_buckets,2,items.c.stats_sizes_buckets,,items.c,static int stats_sizes_buckets,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
2621,11106,cas_id,2,items.c.cas_id,,items.c,uint64_t cas_id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2622,11110,do_run_lru_maintainer_thread,2,items.c.do_run_lru_maintainer_thread,,items.c,static volatile int do_run_lru_maintainer_thread,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2623,11114,lru_maintainer_initialized,2,items.c.lru_maintainer_initialized,,items.c,static int lru_maintainer_initialized,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2624,11118,lru_maintainer_lock,2,items.c.lru_maintainer_lock,,items.c,pthread_mutex_t lru_maintainer_lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
2625,11122,cas_id_lock,2,items.c.cas_id_lock,,items.c,pthread_mutex_t cas_id_lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
2626,11126,stats_sizes_lock,2,items.c.stats_sizes_lock,,items.c,pthread_mutex_t stats_sizes_lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,16,0,1,1,0,0,,0,0,0,0,0,
2627,11208,lru_bump_entry,2,items.c.lru_bump_entry,,items.c,struct lru_bump_entry,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2628,11209,bump_buf_head,2,items.c.bump_buf_head,,items.c,lru_bump_buf* bump_buf_head,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
2629,11213,bump_buf_tail,2,items.c.bump_buf_tail,,items.c,lru_bump_buf* bump_buf_tail,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2630,11217,bump_buf_lock,2,items.c.bump_buf_lock,,items.c,pthread_mutex_t bump_buf_lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
2631,17746,slab_automove_default,2,items.c.slab_automove_default,,items.c,slab_automove_reg_t slab_automove_default,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2632,17762,lru_maintainer_tid,2,items.c.lru_maintainer_tid,,items.c,pthread_t lru_maintainer_tid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2633,18948,item_stats_automove,2,items.h.item_stats_automove,,items.h,struct item_stats_automove,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2634,18984,lru_locks,2,items.h.lru_locks,,items.h,extern pthread_mutex_t[] lru_locks,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2635,19026,lut,2,itoa_ljust.c.lut,,itoa_ljust.c,char[201] lut,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2636,19490,kill_msg,2,linux_priv.c.kill_msg,,linux_priv.c,static char* kill_msg,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
2637,19550,act,2,linux_priv.c.act,,linux_priv.c,const struct sigaction act,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2638,19592,logger_stack_head,2,logger.c.logger_stack_head,,logger.c,logger* logger_stack_head,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
2639,19596,logger_stack_tail,2,logger.c.logger_stack_tail,,logger.c,logger* logger_stack_tail,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2640,19600,logger_count,2,logger.c.logger_count,,logger.c,static unsigned int logger_count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2641,19604,do_run_logger_thread,2,logger.c.do_run_logger_thread,,logger.c,static volatile int do_run_logger_thread,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2642,19608,logger_tid,2,logger.c.logger_tid,,logger.c,pthread_t logger_tid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2643,19609,logger_stack_lock,2,logger.c.logger_stack_lock,,logger.c,pthread_mutex_t logger_stack_lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
2644,19613,logger_stack_cond,2,logger.c.logger_stack_cond,,logger.c,pthread_cond_t logger_stack_cond,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2645,19617,logger_key,2,logger.c.logger_key,,logger.c,pthread_key_t logger_key,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2646,19618,logger_atomics_mutex,2,logger.c.logger_atomics_mutex,,logger.c,pthread_mutex_t logger_atomics_mutex,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
2647,19622,watchers,2,logger.c.watchers,,logger.c,logger_watcher *[20] watchers,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
2648,19626,watchers_pollfds,2,logger.c.watchers_pollfds,,logger.c,pollfd[20] watchers_pollfds,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2649,19629,watcher_count,2,logger.c.watcher_count,,logger.c,int watcher_count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
2650,20614,default_entries,2,logger.c.default_entries,,logger.c,_entry_details[] default_entries,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2651,20722,logger_gid,2,logger.c.logger_gid,,logger.c,uint64_t logger_gid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2652,22429,logger_watcher,2,logger.h.logger_watcher,,logger.h,struct logger_watcher,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2653,22436,logger_key,2,logger.h.logger_key,,logger.h,pthread_key_t logger_key,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2654,22453,logger_log,2,logger.h.logger_log,,logger.h,enum logger_ret_type logger_log,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2655,22466,logger_add_watcher,2,logger.h.logger_add_watcher,,logger.h,enum logger_add_watcher_ret logger_add_watcher,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2656,25722,try_read_network,2,memcached.c.try_read_network,,memcached.c,enum try_read_result try_read_network,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2657,25724,try_read_udp,2,memcached.c.try_read_udp,,memcached.c,enum try_read_result try_read_udp,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2658,25780,stats,2,memcached.c.stats,,memcached.c,struct stats stats,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,38,0,1,1,0,0,,0,0,0,0,0,
2659,25782,stats_state,2,memcached.c.stats_state,,memcached.c,struct stats_state stats_state,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,26,0,1,1,0,0,,0,0,0,0,0,
2660,25784,settings,2,memcached.c.settings,,memcached.c,struct settings settings,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,356,0,1,1,0,0,,0,0,0,0,0,
2661,25786,conns,2,memcached.c.conns,,memcached.c,conn** conns,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,18,0,1,1,0,0,,0,0,0,0,0,
2662,25788,slab_rebal,2,memcached.c.slab_rebal,,memcached.c,struct slab_rebalance slab_rebal,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2663,25789,slab_rebalance_signal,2,memcached.c.slab_rebalance_signal,,memcached.c,volatile int slab_rebalance_signal,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2664,25790,listen_conn,2,memcached.c.listen_conn,,memcached.c,conn* listen_conn,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2665,25794,max_fds,2,memcached.c.max_fds,,memcached.c,static int max_fds,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
2666,25796,main_base,2,memcached.c.main_base,,memcached.c,struct event_base* main_base,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
2667,25857,transmit,2,memcached.c.transmit,,memcached.c,enum transmit_result transmit,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2668,25858,allow_new_conns,2,memcached.c.allow_new_conns,,memcached.c,volatile bool allow_new_conns,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2669,25862,stop_main_loop,2,memcached.c.stop_main_loop,,memcached.c,static int stop_main_loop,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
2670,25867,maxconnsevent,2,memcached.c.maxconnsevent,,memcached.c,struct event maxconnsevent,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2671,26325,conn_lock,2,memcached.c.conn_lock,,memcached.c,pthread_mutex_t conn_lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2672,26326,conn_timeout_tid,2,memcached.c.conn_timeout_tid,,memcached.c,pthread_t conn_timeout_tid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2673,26327,do_run_conn_timeout_thread,2,memcached.c.do_run_conn_timeout_thread,,memcached.c,static int do_run_conn_timeout_thread,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2674,26328,conn_timeout_cond,2,memcached.c.conn_timeout_cond,,memcached.c,pthread_cond_t conn_timeout_cond,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2675,26332,conn_timeout_lock,2,memcached.c.conn_timeout_lock,,memcached.c,pthread_mutex_t conn_timeout_lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
2676,39787,clockevent,2,memcached.c.clockevent,,memcached.c,struct event clockevent,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
2677,44449,stats_state,2,memcached.h.stats_state,,memcached.h,struct stats_state stats_state,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2678,44450,process_started,2,memcached.h.process_started,,memcached.h,time_t process_started,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2679,44452,settings,2,memcached.h.settings,,memcached.h,struct settings settings,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2680,44506,crawler,2,memcached.h.crawler,,memcached.h,struct crawler,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2681,44594,LIBEVENT_THREAD,2,memcached.h.LIBEVENT_THREAD,,memcached.h,struct LIBEVENT_THREAD,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2682,44752,conns,2,memcached.h.conns,,memcached.h,conn** conns,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2683,44753,current_time,2,memcached.h.current_time,,memcached.h,volatile rel_time_t current_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2684,44754,slab_rebalance_signal,2,memcached.h.slab_rebalance_signal,,memcached.h,extern volatile int slab_rebalance_signal,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2685,44771,slab_rebal,2,memcached.h.slab_rebal,,memcached.h,struct slab_rebalance slab_rebal,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2686,44778,do_add_delta,2,memcached.h.do_add_delta,,memcached.h,enum delta_result_type do_add_delta,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2687,44780,do_store_item,2,memcached.h.do_store_item,,memcached.h,enum store_item_type do_store_item,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2688,44877,add_delta,2,memcached.h.add_delta,,memcached.h,enum delta_result_type add_delta,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2689,45024,store_item,2,memcached.h.store_item,,memcached.h,enum store_item_type store_item,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2690,64279,protocol_binary_magic,2,protocol_binary.h.protocol_binary_magic,,protocol_binary.h,enum protocol_binary_magic,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2691,64329,protocol_binary_response_status,2,protocol_binary.h.protocol_binary_response_status,,protocol_binary.h,enum protocol_binary_response_status,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2692,64527,protocol_binary_command,2,protocol_binary.h.protocol_binary_command,,protocol_binary.h,enum protocol_binary_command,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2693,64537,protocol_binary_datatypes,2,protocol_binary.h.protocol_binary_datatypes,,protocol_binary.h,enum protocol_binary_datatypes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2694,64557,protocol_binary_request_header,2,protocol_binary.h.protocol_binary_request_header,,protocol_binary.h,union protocol_binary_request_header,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2695,64577,protocol_binary_response_header,2,protocol_binary.h.protocol_binary_response_header,,protocol_binary.h,union protocol_binary_response_header,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2696,64590,protocol_binary_request_no_extras,2,protocol_binary.h.protocol_binary_request_no_extras,,protocol_binary.h,union protocol_binary_request_no_extras,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2697,64603,protocol_binary_response_no_extras,2,protocol_binary.h.protocol_binary_response_no_extras,,protocol_binary.h,union protocol_binary_response_no_extras,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2698,64625,protocol_binary_response_get,2,protocol_binary.h.protocol_binary_response_get,,protocol_binary.h,union protocol_binary_response_get,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2699,64648,protocol_binary_request_flush,2,protocol_binary.h.protocol_binary_request_flush,,protocol_binary.h,union protocol_binary_request_flush,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2700,64668,protocol_binary_request_set,2,protocol_binary.h.protocol_binary_request_set,,protocol_binary.h,union protocol_binary_request_set,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2701,64695,protocol_binary_request_incr,2,protocol_binary.h.protocol_binary_request_incr,,protocol_binary.h,union protocol_binary_request_incr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2702,64714,protocol_binary_response_incr,2,protocol_binary.h.protocol_binary_response_incr,,protocol_binary.h,union protocol_binary_response_incr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2703,64743,protocol_binary_request_touch,2,protocol_binary.h.protocol_binary_request_touch,,protocol_binary.h,union protocol_binary_request_touch,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2704,64762,protocol_binary_request_gat,2,protocol_binary.h.protocol_binary_request_gat,,protocol_binary.h,union protocol_binary_request_gat,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2705,64790,protocol_binary_request_rangeop,2,protocol_binary.h.protocol_binary_request_rangeop,,protocol_binary.h,union protocol_binary_request_rangeop,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2706,64985,proxy_ctx_t,2,proxy.h.proxy_ctx_t,,proxy.h,struct proxy_ctx_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2707,65204,mcp_resp_t,2,proxy.h.mcp_resp_t,,proxy.h,struct mcp_resp_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2708,65239,mcp_pool_be_t,2,proxy.h.mcp_pool_be_t,,proxy.h,struct mcp_pool_be_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2709,65273,mcp_pool_proxy_t,2,proxy.h.mcp_pool_proxy_t,,proxy.h,struct mcp_pool_proxy_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2710,67881,mcplib_jump_hash_t,2,proxy_jump_hash.c.mcplib_jump_hash_t,,proxy_jump_hash.c,struct mcplib_jump_hash_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2711,73384,proxy_be_failure_text,2,proxy_network.c.proxy_be_failure_text,,proxy_network.c,char[] proxy_be_failure_text,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2712,77050,cpoint,2,proxy_ring_hash.c.cpoint,,proxy_ring_hash.c,struct cpoint,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2713,77061,ketama_t,2,proxy_ring_hash.c.ketama_t,,proxy_ring_hash.c,struct ketama_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2714,77070,ketama_key_hash,2,proxy_ring_hash.c.ketama_key_hash,,proxy_ring_hash.c,struct proxy_hash_func ketama_key_hash,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2715,78485,mcplib_hash_xxhash,2,proxy_xxhash.c.mcplib_hash_xxhash,,proxy_xxhash.c,struct proxy_hash_func mcplib_hash_xxhash,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2716,78548,mmap_fd,2,memcached.h.mmap_fd,,memcached.h,static int mmap_fd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
2717,78552,mmap_base,2,memcached.h.mmap_base,,memcached.h,static void* mmap_base,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
2718,78556,slabmem_limit,2,memcached.h.slabmem_limit,,memcached.h,size_t slabmem_limit,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
2719,78564,cb_stack,2,memcached.h.cb_stack,,memcached.h,restart_data_cb* cb_stack,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
2720,78653,restart_cb_ctx,2,memcached.h.restart_cb_ctx,,memcached.h,struct restart_cb_ctx,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2721,79804,restart_get_kv,2,restart.h.restart_get_kv,,restart.h,enum restart_get_kv_ret restart_get_kv,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2722,79837,my_sasl_hostname,2,sasl_defs.c.my_sasl_hostname,,sasl_defs.c,char[1025] my_sasl_hostname,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2723,79912,sasl_callbacks,2,sasl_defs.c.sasl_callbacks,,sasl_defs.c,static sasl_callback_t[] sasl_callbacks,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2724,80093,slab_automove,2,slab_automove.c.slab_automove,,slab_automove.c,struct slab_automove,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2725,80736,slab_automove_reg_t,2,slab_automove.h.slab_automove_reg_t,,slab_automove.h,struct slab_automove_reg_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2726,80800,slab_automove,2,slab_automove_extstore.c.slab_automove,,slab_automove_extstore.c,struct slab_automove,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2727,81610,slabclass_t,2,slabs.c.slabclass_t,,slabs.c,struct slabclass_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2728,81611,slabclass,2,slabs.c.slabclass,,slabs.c,static slabclass_t[64] slabclass,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,32,0,1,1,0,0,,0,0,0,0,0,
2729,81618,mem_limit,2,slabs.c.mem_limit,,slabs.c,size_t mem_limit,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
2730,81622,mem_malloced,2,slabs.c.mem_malloced,,slabs.c,size_t mem_malloced,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
2731,81626,mem_limit_reached,2,slabs.c.mem_limit_reached,,slabs.c,bool mem_limit_reached,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2732,81630,power_largest,2,slabs.c.power_largest,,slabs.c,static int power_largest,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
2733,81631,mem_base,2,slabs.c.mem_base,,slabs.c,static void* mem_base,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
2734,81635,mem_current,2,slabs.c.mem_current,,slabs.c,static void* mem_current,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2735,81639,mem_avail,2,slabs.c.mem_avail,,slabs.c,size_t mem_avail,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2736,81643,slabs_lock,2,slabs.c.slabs_lock,,slabs.c,pthread_mutex_t slabs_lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,27,0,1,1,0,0,,0,0,0,0,0,
2737,81647,slabs_rebalance_lock,2,slabs.c.slabs_rebalance_lock,,slabs.c,pthread_mutex_t slabs_rebalance_lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
2738,83895,slab_rebalance_cond,2,slabs.c.slab_rebalance_cond,,slabs.c,pthread_cond_t slab_rebalance_cond,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2739,83899,do_run_slab_rebalance_thread,2,slabs.c.do_run_slab_rebalance_thread,,slabs.c,static volatile int do_run_slab_rebalance_thread,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2740,85687,rebalance_tid,2,slabs.c.rebalance_tid,,slabs.c,pthread_t rebalance_tid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2741,85802,slab_stats_automove,2,slabs.h.slab_stats_automove,,slabs.h,struct slab_stats_automove,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2742,85860,slabs_reassign,2,slabs.h.slabs_reassign,,slabs.h,enum reassign_result_type slabs_reassign,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2743,85907,prefix_stats,2,stats_prefix.c.prefix_stats,,stats_prefix.c,_prefix_stats*[256] prefix_stats,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
2744,85912,prefix_delimiter,2,stats_prefix.c.prefix_delimiter,,stats_prefix.c,static char prefix_delimiter,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2745,85913,num_prefixes,2,stats_prefix.c.num_prefixes,,stats_prefix.c,static int num_prefixes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2746,85917,total_prefix_size,2,stats_prefix.c.total_prefix_size,,stats_prefix.c,static int total_prefix_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2747,86532,storage_conf_parse,2,storage.h.storage_conf_parse,,storage.h,struct extstore_conf_file* storage_conf_parse,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2748,86633,hash,2,testapp.c.hash,,testapp.c,hash_func hash,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2749,86684,server_pid,2,testapp.c.server_pid,,testapp.c,pid_t server_pid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
2750,86685,port,2,testapp.c.port,,testapp.c,in_port_t port,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
2751,86687,con,2,testapp.c.con,,testapp.c,struct conn* con,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,37,0,1,1,0,0,,0,0,0,0,0,
2752,86691,allow_closed_read,2,testapp.c.allow_closed_read,,testapp.c,bool allow_closed_read,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2753,86695,enable_ssl,2,testapp.c.enable_ssl,,testapp.c,bool enable_ssl,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
2754,92928,hickup_thread_running,2,testapp.c.hickup_thread_running,,testapp.c,volatile bool hickup_thread_running,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2755,93660,testcases,2,testapp.c.testcases,,testapp.c,testcase[] testcases,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2756,94048,lru_locks,2,thread.c.lru_locks,,thread.c,pthread_mutex_t[256] lru_locks,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2757,94053,conn_lock,2,thread.c.conn_lock,,thread.c,pthread_mutex_t conn_lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2758,94057,atomics_mutex,2,thread.c.atomics_mutex,,thread.c,pthread_mutex_t atomics_mutex,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2759,94061,stats_lock,2,thread.c.stats_lock,,thread.c,pthread_mutex_t stats_lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2760,94065,worker_hang_lock,2,thread.c.worker_hang_lock,,thread.c,pthread_mutex_t worker_hang_lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2761,94066,item_locks,2,thread.c.item_locks,,thread.c,pthread_mutex_t* item_locks,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2762,94067,item_lock_count,2,thread.c.item_lock_count,,thread.c,uint32_t item_lock_count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2763,94068,item_lock_hashpower,2,thread.c.item_lock_hashpower,,thread.c,unsigned int item_lock_hashpower,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2764,94069,threads,2,thread.c.threads,,thread.c,LIBEVENT_THREAD* threads,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
2765,94070,init_count,2,thread.c.init_count,,thread.c,static int init_count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2766,94074,init_lock,2,thread.c.init_lock,,thread.c,pthread_mutex_t init_lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2767,94075,init_cond,2,thread.c.init_cond,,thread.c,pthread_cond_t init_cond,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2768,95298,last_thread,2,thread.c.last_thread,,thread.c,static int last_thread,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2769,95303,last_thread_by_napi_id,2,thread.c.last_thread_by_napi_id,,thread.c,static int last_thread_by_napi_id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2770,97239,caught_sig,2,timedrun.c.caught_sig,,timedrun.c,volatile sig_atomic_t caught_sig,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2771,97602,uriencode_map,2,util.c.uriencode_map,,util.c,char*[256] uriencode_map,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2772,97605,uriencode_str,2,util.c.uriencode_str,,util.c,char[768] uriencode_str,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2773,100272,mcmc_resp_t,2,vendor\mcmc\mcmc.h.mcmc_resp_t,,vendor\mcmc\mcmc.h,struct mcmc_resp_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2774,100401,XXH_errorcode,2,xxhash.h.XXH_errorcode,,xxhash.h,enum XXH_errorcode,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2775,100454,XXH32_canonical_t,2,xxhash.h.XXH32_canonical_t,,xxhash.h,struct XXH32_canonical_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2776,100519,XXH64_canonical_t,2,xxhash.h.XXH64_canonical_t,,xxhash.h,struct XXH64_canonical_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2777,100603,XXH128_hash_t,2,xxhash.h.XXH128_hash_t,,xxhash.h,struct XXH128_hash_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2778,100676,XXH128_canonical_t,2,xxhash.h.XXH128_canonical_t,,xxhash.h,struct XXH128_canonical_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
