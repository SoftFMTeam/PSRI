,Id,Name,NodeType,Fullname,Signature,Filename,Code,LineNumber,LineNumberEnd,ColumnNumber,ColumnNumberEnd,LineOfCode,NumberOfOperators,SetOfOperators,NumberOfOperands,SetOfOperands,FanIn,FanOut,McCabe,AccCyc,ConCf,ConDf,ConZc,ConRf,ConVal,Parma,ParmaIn,ParmaOut,RetType
0,862,bucket,3,assoc_iterator.bucket,,assoc.c,bucket,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1,863,it,3,assoc_iterator.it,,assoc.c,*it,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
2,864,next,3,assoc_iterator.next,,assoc.c,*next,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
3,865,bucket_locked,3,assoc_iterator.bucket_locked,,assoc.c,bucket_locked,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
4,2710,size,3,bipbuf_t.size,,bipbuffer.h,size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
5,2711,a_start,3,bipbuf_t.a_start,,bipbuffer.h,a_start,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,14,0,1,1,0,0,,0,0,0,0,0,
6,2712,a_end,3,bipbuf_t.a_end,,bipbuffer.h,a_end,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
7,2713,b_end,3,bipbuf_t.b_end,,bipbuffer.h,b_end,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
8,2714,b_inuse,3,bipbuf_t.b_inuse,,bipbuffer.h,b_inuse,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
9,2715,data,3,bipbuf_t.data,,bipbuffer.h,data[],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
10,3398,mutex,3,cache_t.mutex,,cache.h,mutex,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
11,3399,name,3,cache_t.name,,cache.h,*name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
12,3405,head,3,cache_t.head,,cache.h,head,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,20,0,1,1,0,0,,0,0,0,0,0,
13,3406,bufsize,3,cache_t.bufsize,,cache.h,bufsize,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
14,3408,total,3,cache_t.total,,cache.h,total,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
15,3409,freecurr,3,cache_t.freecurr,,cache.h,freecurr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
16,3410,limit,3,cache_t.limit,,cache.h,limit,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
17,3490,c,3,crawler_client_t.c,,crawler.c,*c,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
18,3491,sfd,3,crawler_client_t.sfd,,crawler.c,sfd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
19,3492,buf,3,crawler_client_t.buf,,crawler.c,*buf,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
20,3493,cbuf,3,crawler_client_t.cbuf,,crawler.c,*cbuf,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
21,6050,histo,3,crawlerstats_t.histo,,crawler.h,histo[61],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
22,6052,noexp,3,crawlerstats_t.noexp,,crawler.h,noexp,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
23,6053,reclaimed,3,crawlerstats_t.reclaimed,,crawler.h,reclaimed,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
24,6054,seen,3,crawlerstats_t.seen,,crawler.h,seen,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
25,6055,start_time,3,crawlerstats_t.start_time,,crawler.h,start_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
26,6056,end_time,3,crawlerstats_t.end_time,,crawler.h,end_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
27,6057,run_complete,3,crawlerstats_t.run_complete,,crawler.h,run_complete,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
28,6066,lock,3,crawler_expired_data.lock,,crawler.h,lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
29,6067,crawlerstats,3,crawler_expired_data.crawlerstats,,crawler.h,crawlerstats[POWER_LARGEST],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
30,6070,crawl_complete,3,crawler_expired_data.crawl_complete,,crawler.h,crawl_complete,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
31,7268,mutex,3,store_io_thread.mutex,,extstore.c,mutex,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
32,7269,cond,3,store_io_thread.cond,,extstore.c,cond,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
33,7270,queue,3,store_io_thread.queue,,extstore.c,*queue,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
34,7271,queue_tail,3,store_io_thread.queue_tail,,extstore.c,*queue_tail,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
35,7273,depth,3,store_io_thread.depth,,extstore.c,depth,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
36,7281,mutex,3,store_engine.mutex,,extstore.c,mutex,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,17,0,1,1,0,0,,0,0,0,0,0,
37,7282,pages,3,store_engine.pages,,extstore.c,*pages,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,16,0,1,1,0,0,,0,0,0,0,0,
38,7283,wbuf_stack,3,store_engine.wbuf_stack,,extstore.c,*wbuf_stack,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
39,7284,io_stack,3,store_engine.io_stack,,extstore.c,*io_stack,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
40,7285,io_threads,3,store_engine.io_threads,,extstore.c,*io_threads,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
41,7286,maint_thread,3,store_engine.maint_thread,,extstore.c,*maint_thread,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
42,7287,page_freelist,3,store_engine.page_freelist,,extstore.c,*page_freelist,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
43,7288,page_buckets,3,store_engine.page_buckets,,extstore.c,**page_buckets,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
44,7289,free_page_buckets,3,store_engine.free_page_buckets,,extstore.c,**free_page_buckets,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
45,7290,page_size,3,store_engine.page_size,,extstore.c,page_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
46,7291,version,3,store_engine.version,,extstore.c,version,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
47,7293,io_threadcount,3,store_engine.io_threadcount,,extstore.c,io_threadcount,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
48,7294,page_count,3,store_engine.page_count,,extstore.c,page_count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
49,7295,page_free,3,store_engine.page_free,,extstore.c,page_free,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
50,7296,page_bucketcount,3,store_engine.page_bucketcount,,extstore.c,page_bucketcount,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
51,7298,io_depth,3,store_engine.io_depth,,extstore.c,io_depth,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
52,7299,stats_mutex,3,store_engine.stats_mutex,,extstore.c,stats_mutex,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
53,7301,stats,3,store_engine.stats,,extstore.c,stats,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,15,0,1,1,0,0,,0,0,0,0,0,
54,10682,pages_free,3,extstore_stats.pages_free,,extstore.h,pages_free,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
55,10683,pages_used,3,extstore_stats.pages_used,,extstore.h,pages_used,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
56,10691,bytes_used,3,extstore_stats.bytes_used,,extstore.h,bytes_used,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
57,10692,bytes_fragmented,3,extstore_stats.bytes_fragmented,,extstore.h,bytes_fragmented,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
58,10693,io_queue,3,extstore_stats.io_queue,,extstore.h,io_queue,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
59,10695,page_data,3,extstore_stats.page_data,,extstore.h,*page_data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
60,10697,page_size,3,extstore_conf.page_size,,extstore.h,page_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
61,10699,page_buckets,3,extstore_conf.page_buckets,,extstore.h,page_buckets,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
62,10701,wbuf_size,3,extstore_conf.wbuf_size,,extstore.h,wbuf_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
63,10702,wbuf_count,3,extstore_conf.wbuf_count,,extstore.h,wbuf_count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
64,10703,io_threadcount,3,extstore_conf.io_threadcount,,extstore.h,io_threadcount,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
65,10704,io_depth,3,extstore_conf.io_depth,,extstore.h,io_depth,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
66,10706,page_count,3,extstore_conf_file.page_count,,extstore.h,page_count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
67,10707,file,3,extstore_conf_file.file,,extstore.h,*file,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
68,10708,fd,3,extstore_conf_file.fd,,extstore.h,fd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
69,10709,offset,3,extstore_conf_file.offset,,extstore.h,offset,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
70,10711,free_bucket,3,extstore_conf_file.free_bucket,,extstore.h,free_bucket,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
71,10713,next,3,extstore_conf_file.next,,extstore.h,*next,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
72,11047,evicted,3,itemstats_t.evicted,,items.c,evicted,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
73,11048,evicted_nonzero,3,itemstats_t.evicted_nonzero,,items.c,evicted_nonzero,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
74,11049,reclaimed,3,itemstats_t.reclaimed,,items.c,reclaimed,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
75,11050,outofmemory,3,itemstats_t.outofmemory,,items.c,outofmemory,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
76,11051,tailrepairs,3,itemstats_t.tailrepairs,,items.c,tailrepairs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
77,11052,expired_unfetched,3,itemstats_t.expired_unfetched,,items.c,expired_unfetched,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
78,11053,evicted_unfetched,3,itemstats_t.evicted_unfetched,,items.c,evicted_unfetched,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
79,11054,evicted_active,3,itemstats_t.evicted_active,,items.c,evicted_active,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
80,11055,crawler_reclaimed,3,itemstats_t.crawler_reclaimed,,items.c,crawler_reclaimed,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
81,11056,crawler_items_checked,3,itemstats_t.crawler_items_checked,,items.c,crawler_items_checked,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
82,11057,lrutail_reflocked,3,itemstats_t.lrutail_reflocked,,items.c,lrutail_reflocked,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
83,11058,moves_to_cold,3,itemstats_t.moves_to_cold,,items.c,moves_to_cold,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
84,11059,moves_to_warm,3,itemstats_t.moves_to_warm,,items.c,moves_to_warm,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
85,11060,moves_within_lru,3,itemstats_t.moves_within_lru,,items.c,moves_within_lru,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
86,11061,direct_reclaims,3,itemstats_t.direct_reclaims,,items.c,direct_reclaims,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
87,11062,hits_to_hot,3,itemstats_t.hits_to_hot,,items.c,hits_to_hot,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
88,11063,hits_to_warm,3,itemstats_t.hits_to_warm,,items.c,hits_to_warm,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
89,11064,hits_to_cold,3,itemstats_t.hits_to_cold,,items.c,hits_to_cold,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
90,11065,hits_to_temp,3,itemstats_t.hits_to_temp,,items.c,hits_to_temp,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
91,11066,mem_requested,3,itemstats_t.mem_requested,,items.c,mem_requested,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
92,11067,evicted_time,3,itemstats_t.evicted_time,,items.c,evicted_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
93,11206,it,3,lru_bump_entry.it,,items.c,*it,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
94,11207,hv,3,lru_bump_entry.hv,,items.c,hv,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
95,18945,evicted,3,item_stats_automove.evicted,,items.h,evicted,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
96,18946,outofmemory,3,item_stats_automove.outofmemory,,items.h,outofmemory,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
97,18947,age,3,item_stats_automove.age,,items.h,age,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
98,22329,exptime,3,logentry_eviction.exptime,,logger.h,exptime,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
99,22330,nbytes,3,logentry_eviction.nbytes,,logger.h,nbytes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
100,22331,latime,3,logentry_eviction.latime,,logger.h,latime,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
101,22332,it_flags,3,logentry_eviction.it_flags,,logger.h,it_flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
102,22333,nkey,3,logentry_eviction.nkey,,logger.h,nkey,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
103,22334,clsid,3,logentry_eviction.clsid,,logger.h,clsid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
104,22335,key,3,logentry_eviction.key,,logger.h,key[],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
105,22342,was_found,3,logentry_item_get.was_found,,logger.h,was_found,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
106,22343,nkey,3,logentry_item_get.nkey,,logger.h,nkey,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
107,22344,clsid,3,logentry_item_get.clsid,,logger.h,clsid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
108,22345,nbytes,3,logentry_item_get.nbytes,,logger.h,nbytes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
109,22346,sfd,3,logentry_item_get.sfd,,logger.h,sfd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
110,22347,key,3,logentry_item_get.key,,logger.h,key[],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
111,22354,status,3,logentry_item_store.status,,logger.h,status,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
112,22355,cmd,3,logentry_item_store.cmd,,logger.h,cmd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
113,22356,ttl,3,logentry_item_store.ttl,,logger.h,ttl,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
114,22357,nkey,3,logentry_item_store.nkey,,logger.h,nkey,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
115,22358,clsid,3,logentry_item_store.clsid,,logger.h,clsid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
116,22359,nbytes,3,logentry_item_store.nbytes,,logger.h,nbytes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
117,22360,sfd,3,logentry_item_store.sfd,,logger.h,sfd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
118,22361,key,3,logentry_item_store.key,,logger.h,key[],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
119,22368,transport,3,logentry_conn_event.transport,,logger.h,transport,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
120,22369,reason,3,logentry_conn_event.reason,,logger.h,reason,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
121,22370,sfd,3,logentry_conn_event.sfd,,logger.h,sfd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
122,22372,addr,3,logentry_conn_event.addr,,logger.h,addr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
123,22419,c,3,logger_watcher.c,,logger.h,*c,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
124,22420,sfd,3,logger_watcher.sfd,,logger.h,sfd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
125,22421,id,3,logger_watcher.id,,logger.h,id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
126,22422,skipped,3,logger_watcher.skipped,,logger.h,skipped,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
127,22423,min_gid,3,logger_watcher.min_gid,,logger.h,min_gid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
128,22424,failed_flush,3,logger_watcher.failed_flush,,logger.h,failed_flush,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
129,22426,t,3,logger_watcher.t,,logger.h,t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
130,22427,eflags,3,logger_watcher.eflags,,logger.h,eflags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
131,22428,buf,3,logger_watcher.buf,,logger.h,*buf,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
132,22431,worker_dropped,3,logger_stats.worker_dropped,,logger.h,worker_dropped,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
133,22432,worker_written,3,logger_stats.worker_written,,logger.h,worker_written,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
134,22433,watcher_skipped,3,logger_stats.watcher_skipped,,logger.h,watcher_skipped,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
135,22434,watcher_sent,3,logger_stats.watcher_sent,,logger.h,watcher_sent,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
136,22435,watcher_count,3,logger_stats.watcher_count,,logger.h,watcher_count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
137,40448,mmap_base,3,_mc_meta_data.mmap_base,,memcached.c,*mmap_base,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
138,40449,old_base,3,_mc_meta_data.old_base,,memcached.c,old_base,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
139,40450,slab_config,3,_mc_meta_data.slab_config,,memcached.c,*slab_config,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
140,40451,time_delta,3,_mc_meta_data.time_delta,,memcached.c,time_delta,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
141,40452,process_started,3,_mc_meta_data.process_started,,memcached.c,process_started,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
142,40453,current_time,3,_mc_meta_data.current_time,,memcached.c,current_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
143,44254,set_cmds,3,slab_stats.set_cmds,,memcached.h,uint64_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
144,44255,get_hits,3,slab_stats.get_hits,,memcached.h,uint64_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
145,44256,touch_hits,3,slab_stats.touch_hits,,memcached.h,uint64_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
146,44257,delete_hits,3,slab_stats.delete_hits,,memcached.h,uint64_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
147,44258,cas_hits,3,slab_stats.cas_hits,,memcached.h,uint64_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
148,44259,cas_badval,3,slab_stats.cas_badval,,memcached.h,uint64_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
149,44260,incr_hits,3,slab_stats.incr_hits,,memcached.h,uint64_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
150,44261,decr_hits,3,slab_stats.decr_hits,,memcached.h,uint64_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
151,44264,get_cmds,3,thread_stats.get_cmds,,memcached.h,uint64_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
152,44265,get_misses,3,thread_stats.get_misses,,memcached.h,uint64_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
153,44266,get_expired,3,thread_stats.get_expired,,memcached.h,uint64_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
154,44267,get_flushed,3,thread_stats.get_flushed,,memcached.h,uint64_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
155,44268,touch_cmds,3,thread_stats.touch_cmds,,memcached.h,uint64_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
156,44269,touch_misses,3,thread_stats.touch_misses,,memcached.h,uint64_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
157,44270,delete_misses,3,thread_stats.delete_misses,,memcached.h,uint64_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
158,44271,incr_misses,3,thread_stats.incr_misses,,memcached.h,uint64_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
159,44272,decr_misses,3,thread_stats.decr_misses,,memcached.h,uint64_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
160,44273,cas_misses,3,thread_stats.cas_misses,,memcached.h,uint64_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
161,44274,meta_cmds,3,thread_stats.meta_cmds,,memcached.h,uint64_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
162,44275,bytes_read,3,thread_stats.bytes_read,,memcached.h,uint64_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
163,44276,bytes_written,3,thread_stats.bytes_written,,memcached.h,uint64_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
164,44277,flush_cmds,3,thread_stats.flush_cmds,,memcached.h,uint64_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
165,44278,conn_yields,3,thread_stats.conn_yields,,memcached.h,uint64_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
166,44279,auth_cmds,3,thread_stats.auth_cmds,,memcached.h,uint64_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
167,44280,auth_errors,3,thread_stats.auth_errors,,memcached.h,uint64_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
168,44281,idle_kicks,3,thread_stats.idle_kicks,,memcached.h,uint64_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
169,44282,response_obj_oom,3,thread_stats.response_obj_oom,,memcached.h,uint64_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
170,44283,response_obj_count,3,thread_stats.response_obj_count,,memcached.h,uint64_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
171,44284,response_obj_bytes,3,thread_stats.response_obj_bytes,,memcached.h,uint64_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
172,44285,read_buf_oom,3,thread_stats.read_buf_oom,,memcached.h,uint64_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
173,44286,store_too_large,3,thread_stats.store_too_large,,memcached.h,uint64_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
174,44287,store_no_memory,3,thread_stats.store_no_memory,,memcached.h,uint64_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
175,44292,lru_hits,3,thread_stats.lru_hits,,memcached.h,lru_hits[POWER_LARGEST],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
176,44293,read_buf_count,3,thread_stats.read_buf_count,,memcached.h,read_buf_count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
177,44294,read_buf_bytes,3,thread_stats.read_buf_bytes,,memcached.h,read_buf_bytes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
178,44295,read_buf_bytes_free,3,thread_stats.read_buf_bytes_free,,memcached.h,read_buf_bytes_free,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
179,44311,total_items,3,stats.total_items,,memcached.h,total_items,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
180,44312,total_conns,3,stats.total_conns,,memcached.h,total_conns,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
181,44313,rejected_conns,3,stats.rejected_conns,,memcached.h,rejected_conns,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
182,44314,malloc_fails,3,stats.malloc_fails,,memcached.h,malloc_fails,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
183,44315,listen_disabled_num,3,stats.listen_disabled_num,,memcached.h,listen_disabled_num,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
184,44316,slabs_moved,3,stats.slabs_moved,,memcached.h,slabs_moved,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
185,44317,slab_reassign_rescues,3,stats.slab_reassign_rescues,,memcached.h,slab_reassign_rescues,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
186,44318,slab_reassign_evictions_nomem,3,stats.slab_reassign_evictions_nomem,,memcached.h,slab_reassign_evictions_nomem,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
187,44319,slab_reassign_inline_reclaim,3,stats.slab_reassign_inline_reclaim,,memcached.h,slab_reassign_inline_reclaim,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
188,44320,slab_reassign_chunk_rescues,3,stats.slab_reassign_chunk_rescues,,memcached.h,slab_reassign_chunk_rescues,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
189,44321,slab_reassign_busy_items,3,stats.slab_reassign_busy_items,,memcached.h,slab_reassign_busy_items,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
190,44322,slab_reassign_busy_deletes,3,stats.slab_reassign_busy_deletes,,memcached.h,slab_reassign_busy_deletes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
191,44323,lru_crawler_starts,3,stats.lru_crawler_starts,,memcached.h,lru_crawler_starts,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
192,44324,lru_maintainer_juggles,3,stats.lru_maintainer_juggles,,memcached.h,lru_maintainer_juggles,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
193,44325,time_in_listen_disabled_us,3,stats.time_in_listen_disabled_us,,memcached.h,time_in_listen_disabled_us,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
194,44326,log_worker_dropped,3,stats.log_worker_dropped,,memcached.h,log_worker_dropped,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
195,44327,log_worker_written,3,stats.log_worker_written,,memcached.h,log_worker_written,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
196,44328,log_watcher_skipped,3,stats.log_watcher_skipped,,memcached.h,log_watcher_skipped,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
197,44329,log_watcher_sent,3,stats.log_watcher_sent,,memcached.h,log_watcher_sent,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
198,44336,maxconns_entered,3,stats.maxconns_entered,,memcached.h,maxconns_entered,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
199,44337,unexpected_napi_ids,3,stats.unexpected_napi_ids,,memcached.h,unexpected_napi_ids,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
200,44338,round_robin_fallback,3,stats.round_robin_fallback,,memcached.h,round_robin_fallback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
201,44340,curr_items,3,stats_state.curr_items,,memcached.h,curr_items,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
202,44341,curr_bytes,3,stats_state.curr_bytes,,memcached.h,curr_bytes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
203,44342,curr_conns,3,stats_state.curr_conns,,memcached.h,curr_conns,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
204,44343,hash_bytes,3,stats_state.hash_bytes,,memcached.h,hash_bytes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
205,44344,conn_structs,3,stats_state.conn_structs,,memcached.h,conn_structs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
206,44345,reserved_fds,3,stats_state.reserved_fds,,memcached.h,reserved_fds,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
207,44346,hash_power_level,3,stats_state.hash_power_level,,memcached.h,hash_power_level,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
208,44347,log_watchers,3,stats_state.log_watchers,,memcached.h,log_watchers,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
209,44348,hash_is_expanding,3,stats_state.hash_is_expanding,,memcached.h,hash_is_expanding,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
210,44349,accepting_conns,3,stats_state.accepting_conns,,memcached.h,accepting_conns,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
211,44350,slab_reassign_running,3,stats_state.slab_reassign_running,,memcached.h,slab_reassign_running,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
212,44351,lru_crawler_running,3,stats_state.lru_crawler_running,,memcached.h,lru_crawler_running,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
213,44353,maxbytes,3,settings.maxbytes,,memcached.h,maxbytes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
214,44354,maxconns,3,settings.maxconns,,memcached.h,maxconns,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
215,44355,port,3,settings.port,,memcached.h,port,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
216,44356,udpport,3,settings.udpport,,memcached.h,udpport,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
217,44357,inter,3,settings.inter,,memcached.h,*inter,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,16,0,1,1,0,0,,0,0,0,0,0,
218,44358,verbose,3,settings.verbose,,memcached.h,verbose,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,49,0,1,1,0,0,,0,0,0,0,0,
219,44359,oldest_live,3,settings.oldest_live,,memcached.h,oldest_live,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
220,44360,oldest_cas,3,settings.oldest_cas,,memcached.h,oldest_cas,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
221,44361,evict_to_free,3,settings.evict_to_free,,memcached.h,evict_to_free,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
222,44362,socketpath,3,settings.socketpath,,memcached.h,*socketpath,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
223,44363,auth_file,3,settings.auth_file,,memcached.h,*auth_file,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
224,44364,access,3,settings.access,,memcached.h,access,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
225,44365,factor,3,settings.factor,,memcached.h,factor,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
226,44366,chunk_size,3,settings.chunk_size,,memcached.h,chunk_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
227,44367,num_threads,3,settings.num_threads,,memcached.h,num_threads,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,17,0,1,1,0,0,,0,0,0,0,0,
228,44368,num_threads_per_udp,3,settings.num_threads_per_udp,,memcached.h,num_threads_per_udp,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
229,44369,prefix_delimiter,3,settings.prefix_delimiter,,memcached.h,prefix_delimiter,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
230,44370,detail_enabled,3,settings.detail_enabled,,memcached.h,detail_enabled,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
231,44371,reqs_per_event,3,settings.reqs_per_event,,memcached.h,reqs_per_event,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
232,44372,use_cas,3,settings.use_cas,,memcached.h,use_cas,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,14,0,1,1,0,0,,0,0,0,0,0,
233,44374,binding_protocol,3,settings.binding_protocol,,memcached.h,binding_protocol,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
234,44375,backlog,3,settings.backlog,,memcached.h,backlog,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
235,44376,item_size_max,3,settings.item_size_max,,memcached.h,item_size_max,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,16,0,1,1,0,0,,0,0,0,0,0,
236,44377,slab_chunk_size_max,3,settings.slab_chunk_size_max,,memcached.h,slab_chunk_size_max,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,22,0,1,1,0,0,,0,0,0,0,0,
237,44378,slab_page_size,3,settings.slab_page_size,,memcached.h,slab_page_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,15,0,1,1,0,0,,0,0,0,0,0,
238,44379,sig_hup,3,settings.sig_hup,,memcached.h,sig_hup,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
239,44380,sasl,3,settings.sasl,,memcached.h,sasl,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
240,44381,maxconns_fast,3,settings.maxconns_fast,,memcached.h,maxconns_fast,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
241,44382,lru_crawler,3,settings.lru_crawler,,memcached.h,lru_crawler,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
242,44383,lru_maintainer_thread,3,settings.lru_maintainer_thread,,memcached.h,lru_maintainer_thread,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
243,44384,lru_segmented,3,settings.lru_segmented,,memcached.h,lru_segmented,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
244,44385,slab_reassign,3,settings.slab_reassign,,memcached.h,slab_reassign,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
245,44386,slab_automove,3,settings.slab_automove,,memcached.h,slab_automove,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
246,44387,slab_automove_ratio,3,settings.slab_automove_ratio,,memcached.h,slab_automove_ratio,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
247,44388,slab_automove_window,3,settings.slab_automove_window,,memcached.h,slab_automove_window,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
248,44389,hashpower_init,3,settings.hashpower_init,,memcached.h,hashpower_init,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
249,44390,shutdown_command,3,settings.shutdown_command,,memcached.h,shutdown_command,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
250,44391,tail_repair_time,3,settings.tail_repair_time,,memcached.h,tail_repair_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
251,44392,flush_enabled,3,settings.flush_enabled,,memcached.h,flush_enabled,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
252,44393,dump_enabled,3,settings.dump_enabled,,memcached.h,dump_enabled,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
253,44394,hash_algorithm,3,settings.hash_algorithm,,memcached.h,*hash_algorithm,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
254,44395,lru_crawler_sleep,3,settings.lru_crawler_sleep,,memcached.h,lru_crawler_sleep,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
255,44396,lru_crawler_tocrawl,3,settings.lru_crawler_tocrawl,,memcached.h,lru_crawler_tocrawl,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
256,44397,hot_lru_pct,3,settings.hot_lru_pct,,memcached.h,hot_lru_pct,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
257,44398,warm_lru_pct,3,settings.warm_lru_pct,,memcached.h,warm_lru_pct,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
258,44399,hot_max_factor,3,settings.hot_max_factor,,memcached.h,hot_max_factor,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
259,44400,warm_max_factor,3,settings.warm_max_factor,,memcached.h,warm_max_factor,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
260,44401,crawls_persleep,3,settings.crawls_persleep,,memcached.h,crawls_persleep,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
261,44402,temp_lru,3,settings.temp_lru,,memcached.h,temp_lru,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
262,44403,temporary_ttl,3,settings.temporary_ttl,,memcached.h,temporary_ttl,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
263,44404,idle_timeout,3,settings.idle_timeout,,memcached.h,idle_timeout,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
264,44405,logger_watcher_buf_size,3,settings.logger_watcher_buf_size,,memcached.h,logger_watcher_buf_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
265,44406,logger_buf_size,3,settings.logger_buf_size,,memcached.h,logger_buf_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
266,44407,read_buf_mem_limit,3,settings.read_buf_mem_limit,,memcached.h,read_buf_mem_limit,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
267,44408,drop_privileges,3,settings.drop_privileges,,memcached.h,drop_privileges,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
268,44409,watch_enabled,3,settings.watch_enabled,,memcached.h,watch_enabled,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
269,44411,meta_response_old,3,settings.meta_response_old,,memcached.h,meta_response_old,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
270,44414,ext_item_size,3,settings.ext_item_size,,memcached.h,ext_item_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
271,44423,slab_automove_freeratio,3,settings.slab_automove_freeratio,,memcached.h,slab_automove_freeratio,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
272,44425,ext_global_pool_min,3,settings.ext_global_pool_min,,memcached.h,ext_global_pool_min,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
273,44439,num_napi_ids,3,settings.num_napi_ids,,memcached.h,num_napi_ids,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
274,44440,memory_file,3,settings.memory_file,,memcached.h,*memory_file,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
275,44441,proxy_enabled,3,settings.proxy_enabled,,memcached.h,proxy_enabled,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
276,44444,proxy_ctx,3,settings.proxy_ctx,,memcached.h,*proxy_ctx,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
277,44560,base,3,LIBEVENT_THREAD.base,,memcached.h,*base,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
278,44562,notify_event,3,LIBEVENT_THREAD.notify_event,,memcached.h,notify_event,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
279,44564,notify_receive_fd,3,LIBEVENT_THREAD.notify_receive_fd,,memcached.h,notify_receive_fd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
280,44567,stats,3,LIBEVENT_THREAD.stats,,memcached.h,stats,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
281,44568,io_queues,3,LIBEVENT_THREAD.io_queues,,memcached.h,io_queues[IO_QUEUE_COUNT],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
282,44570,ev_queue,3,LIBEVENT_THREAD.ev_queue,,memcached.h,*ev_queue,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
283,44571,rbuf_cache,3,LIBEVENT_THREAD.rbuf_cache,,memcached.h,*rbuf_cache,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
284,44572,open_bundle,3,LIBEVENT_THREAD.open_bundle,,memcached.h,*open_bundle,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
285,44573,io_cache,3,LIBEVENT_THREAD.io_cache,,memcached.h,*io_cache,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
286,44575,l,3,LIBEVENT_THREAD.l,,memcached.h,*l,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
287,44576,lru_bump_buf,3,LIBEVENT_THREAD.lru_bump_buf,,memcached.h,*lru_bump_buf,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
288,44578,napi_id,3,LIBEVENT_THREAD.napi_id,,memcached.h,napi_id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
289,44579,L,3,LIBEVENT_THREAD.L,,memcached.h,*L,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
290,44580,proxy_hooks,3,LIBEVENT_THREAD.proxy_hooks,,memcached.h,*proxy_hooks,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
291,44581,proxy_user_stats,3,LIBEVENT_THREAD.proxy_user_stats,,memcached.h,*proxy_user_stats,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
292,44582,proxy_int_stats,3,LIBEVENT_THREAD.proxy_int_stats,,memcached.h,*proxy_int_stats,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
293,44583,proxy_rng,3,LIBEVENT_THREAD.proxy_rng,,memcached.h,proxy_rng[4],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
294,44659,sasl_conn,3,conn.sasl_conn,,memcached.h,*sasl_conn,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
295,44660,sfd,3,conn.sfd,,memcached.h,sfd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,23,0,1,1,0,0,,0,0,0,0,0,
296,44661,sasl_started,3,conn.sasl_started,,memcached.h,sasl_started,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
297,44662,authenticated,3,conn.authenticated,,memcached.h,authenticated,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
298,44663,set_stale,3,conn.set_stale,,memcached.h,set_stale,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
299,44664,mset_res,3,conn.mset_res,,memcached.h,mset_res,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
300,44665,close_after_write,3,conn.close_after_write,,memcached.h,close_after_write,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
301,44666,rbuf_malloced,3,conn.rbuf_malloced,,memcached.h,rbuf_malloced,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
302,44667,item_malloced,3,conn.item_malloced,,memcached.h,item_malloced,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
303,44672,state,3,conn.state,,memcached.h,state,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
304,44674,substate,3,conn.substate,,memcached.h,substate,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
305,44675,last_cmd_time,3,conn.last_cmd_time,,memcached.h,last_cmd_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
306,44678,ev_flags,3,conn.ev_flags,,memcached.h,ev_flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
307,44680,rbuf,3,conn.rbuf,,memcached.h,*rbuf,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,26,0,1,1,0,0,,0,0,0,0,0,
308,44681,rcurr,3,conn.rcurr,,memcached.h,*rcurr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,40,0,1,1,0,0,,0,0,0,0,0,
309,44682,rsize,3,conn.rsize,,memcached.h,rsize,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,15,0,1,1,0,0,,0,0,0,0,0,
310,44683,rbytes,3,conn.rbytes,,memcached.h,rbytes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,33,0,1,1,0,0,,0,0,0,0,0,
311,44684,resp,3,conn.resp,,memcached.h,*resp,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,25,0,1,1,0,0,,0,0,0,0,0,
312,44685,resp_head,3,conn.resp_head,,memcached.h,*resp_head,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
313,44686,ritem,3,conn.ritem,,memcached.h,*ritem,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
314,44687,rlbytes,3,conn.rlbytes,,memcached.h,rlbytes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,15,0,1,1,0,0,,0,0,0,0,0,
315,44688,item,3,conn.item,,memcached.h,*item,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,19,0,1,1,0,0,,0,0,0,0,0,
316,44689,sbytes,3,conn.sbytes,,memcached.h,sbytes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
317,44690,io_queues_submitted,3,conn.io_queues_submitted,,memcached.h,io_queues_submitted,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
318,44691,io_queues,3,conn.io_queues,,memcached.h,io_queues[IO_QUEUE_COUNT],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
319,44692,proxy_coro_ref,3,conn.proxy_coro_ref,,memcached.h,proxy_coro_ref,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
320,44697,transport,3,conn.transport,,memcached.h,transport,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,14,0,1,1,0,0,,0,0,0,0,0,
321,44699,close_reason,3,conn.close_reason,,memcached.h,close_reason,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
322,44700,request_id,3,conn.request_id,,memcached.h,request_id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
323,44702,request_addr,3,conn.request_addr,,memcached.h,request_addr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
324,44703,request_addr_size,3,conn.request_addr_size,,memcached.h,request_addr_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
325,44704,noreply,3,conn.noreply,,memcached.h,noreply,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,16,0,1,1,0,0,,0,0,0,0,0,
326,44710,binary_header,3,conn.binary_header,,memcached.h,binary_header,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
327,44711,cas,3,conn.cas,,memcached.h,cas,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
328,44712,tag,3,conn.tag,,memcached.h,tag,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
329,44713,cmd,3,conn.cmd,,memcached.h,cmd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
330,44714,opaque,3,conn.opaque,,memcached.h,opaque,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
331,44717,thread,3,conn.thread,,memcached.h,*thread,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,112,0,1,1,0,0,,0,0,0,0,0,
332,56688,has_error,3,_meta_flags.has_error,,proto_text.c,has_error :1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
333,56689,no_update,3,_meta_flags.no_update,,proto_text.c,no_update :1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
334,56690,locked,3,_meta_flags.locked,,proto_text.c,locked :1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
335,56691,vivify,3,_meta_flags.vivify,,proto_text.c,vivify :1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
336,56692,la,3,_meta_flags.la,,proto_text.c,la :1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
337,56694,value,3,_meta_flags.value,,proto_text.c,value :1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
338,56695,set_stale,3,_meta_flags.set_stale,,proto_text.c,set_stale :1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
339,56696,no_reply,3,_meta_flags.no_reply,,proto_text.c,no_reply :1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
340,56697,has_cas,3,_meta_flags.has_cas,,proto_text.c,has_cas :1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
341,56698,new_ttl,3,_meta_flags.new_ttl,,proto_text.c,new_ttl :1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
342,56699,key_binary,3,_meta_flags.key_binary,,proto_text.c,key_binary:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
343,56700,mode,3,_meta_flags.mode,,proto_text.c,mode,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
344,56701,exptime,3,_meta_flags.exptime,,proto_text.c,exptime,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
345,56702,autoviv_exptime,3,_meta_flags.autoviv_exptime,,proto_text.c,autoviv_exptime,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
346,56703,recache_time,3,_meta_flags.recache_time,,proto_text.c,recache_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
347,56704,client_flags,3,_meta_flags.client_flags,,proto_text.c,client_flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
348,56705,req_cas_id,3,_meta_flags.req_cas_id,,proto_text.c,req_cas_id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
349,56706,delta,3,_meta_flags.delta,,proto_text.c,delta,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
350,56707,initial,3,_meta_flags.initial,,proto_text.c,initial,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
351,64570,bytes,3,protocol_binary_response_header.bytes,,protocol_binary.h,bytes[24],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
352,64657,message,3,protocol_binary_request_set.message,,protocol_binary.h,message,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
353,64920,counters,3,proxy_int_stats.counters,,proxy.h,counters[CMD_FINAL],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,22,0,1,1,0,0,,0,0,0,0,0,
354,64928,num_stats,3,proxy_user_stats.num_stats,,proxy.h,num_stats,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
355,64929,names,3,proxy_user_stats.names,,proxy.h,**names,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
356,64930,counters,3,proxy_user_stats.counters,,proxy.h,*counters,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
357,64963,proxy_state,3,proxy_ctx_t.proxy_state,,proxy.h,*proxy_state,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
358,64965,proxy_threads,3,proxy_ctx_t.proxy_threads,,proxy.h,*proxy_threads,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
359,64966,config_lock,3,proxy_ctx_t.config_lock,,proxy.h,config_lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
360,64967,config_cond,3,proxy_ctx_t.config_cond,,proxy.h,config_cond,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
361,64969,worker_lock,3,proxy_ctx_t.worker_lock,,proxy.h,worker_lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
362,64970,worker_cond,3,proxy_ctx_t.worker_cond,,proxy.h,worker_cond,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
363,64972,manager_lock,3,proxy_ctx_t.manager_lock,,proxy.h,manager_lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
364,64973,manager_cond,3,proxy_ctx_t.manager_cond,,proxy.h,manager_cond,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
365,64974,manager_head,3,proxy_ctx_t.manager_head,,proxy.h,manager_head,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,16,0,1,1,0,0,,0,0,0,0,0,
366,64975,worker_done,3,proxy_ctx_t.worker_done,,proxy.h,worker_done,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
367,64976,worker_failed,3,proxy_ctx_t.worker_failed,,proxy.h,worker_failed,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
368,64977,use_uring,3,proxy_ctx_t.use_uring,,proxy.h,use_uring,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
369,64979,global_stats,3,proxy_ctx_t.global_stats,,proxy.h,global_stats,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
370,64981,user_stats,3,proxy_ctx_t.user_stats,,proxy.h,user_stats,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
371,64983,tunables,3,proxy_ctx_t.tunables,,proxy.h,tunables,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,15,0,1,1,0,0,,0,0,0,0,0,
372,64984,stats_lock,3,proxy_ctx_t.stats_lock,,proxy.h,stats_lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,27,0,1,1,0,0,,0,0,0,0,0,
373,64987,tag,3,proxy_hook_tagged.tag,,proxy.h,tag,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
374,64988,lua_ref,3,proxy_hook_tagged.lua_ref,,proxy.h,lua_ref,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
375,64991,tagcount,3,proxy_hook.tagcount,,proxy.h,tagcount,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
376,64993,tagged,3,proxy_hook.tagged,,proxy.h,*tagged,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
377,65002,func,3,proxy_hash_func.func,,proxy.h,func,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
378,65178,resp,3,mcp_resp_t.resp,,proxy.h,resp,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
379,65179,buf,3,mcp_resp_t.buf,,proxy.h,*buf,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
380,65180,blen,3,mcp_resp_t.blen,,proxy.h,blen,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
381,65181,status,3,mcp_resp_t.status,,proxy.h,status,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
382,65183,cmd,3,mcp_resp_t.cmd,,proxy.h,cmd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
383,65185,mode,3,mcp_resp_t.mode,,proxy.h,mode,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
384,65186,be_name,3,mcp_resp_t.be_name,,proxy.h,be_name[MAX_NAMELEN+1],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
385,65187,be_port,3,mcp_resp_t.be_port,,proxy.h,be_port[MAX_PORTLEN+1],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
386,65237,ref,3,mcp_pool_be_t.ref,,proxy.h,ref,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
387,65238,be,3,mcp_pool_be_t.be,,proxy.h,*be,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
388,65272,main,3,mcp_pool_proxy_t.main,,proxy.h,*main,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
389,66471,size,3,_dumpbuf.size,,proxy_config.c,size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
390,66472,used,3,_dumpbuf.used,,proxy_config.c,used,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
391,66473,buf,3,_dumpbuf.buf,,proxy_config.c,*buf,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
392,67879,phc,3,mcplib_jump_hash_t.phc,,proxy_jump_hash.c,phc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
393,67880,buckets,3,mcplib_jump_hash_t.buckets,,proxy_jump_hash.c,buckets,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
394,77048,point,3,cpoint.point,,proxy_ring_hash.c,point,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
395,77053,phc,3,ketama_t.phc,,proxy_ring_hash.c,phc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
396,77054,total_buckets,3,ketama_t.total_buckets,,proxy_ring_hash.c,total_buckets,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
397,77055,continuum,3,ketama_t.continuum,,proxy_ring_hash.c,continuum[],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,14,0,1,1,0,0,,0,0,0,0,0,
398,78649,f,3,restart_cb_ctx.f,,restart.c,*f,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
399,78650,cb,3,restart_cb_ctx.cb,,restart.c,*cb,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
400,78651,line,3,restart_cb_ctx.line,,restart.c,*line,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
401,78652,done,3,restart_cb_ctx.done,,restart.c,done,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
402,80051,age,3,window_data.age,,slab_automove.c,age,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
403,80052,dirty,3,window_data.dirty,,slab_automove.c,dirty,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
404,80053,evicted_ratio,3,window_data.evicted_ratio,,slab_automove.c,evicted_ratio,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
405,80054,evicted_seen,3,window_data.evicted_seen,,slab_automove.c,evicted_seen,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
406,80733,init,3,slab_automove_reg_t.init,,slab_automove.h,init,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
407,80734,free,3,slab_automove_reg_t.free,,slab_automove.h,free,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
408,80735,run,3,slab_automove_reg_t.run,,slab_automove.h,run,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
409,80753,evicted,3,window_data.evicted,,slab_automove_extstore.c,evicted,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
410,80754,excess_free,3,window_data.excess_free,,slab_automove_extstore.c,excess_free,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
411,80761,window_size,3,slab_automove.window_size,,slab_automove_extstore.c,window_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,15,0,1,1,0,0,,0,0,0,0,0,
412,80762,window_cur,3,slab_automove.window_cur,,slab_automove_extstore.c,window_cur,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
413,80763,item_size,3,slab_automove.item_size,,slab_automove_extstore.c,item_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
414,80764,max_age_ratio,3,slab_automove.max_age_ratio,,slab_automove_extstore.c,max_age_ratio,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
415,80765,free_ratio,3,slab_automove.free_ratio,,slab_automove_extstore.c,free_ratio,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
416,80766,pool_filled_once,3,slab_automove.pool_filled_once,,slab_automove_extstore.c,pool_filled_once,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
417,80767,global_pool_watermark,3,slab_automove.global_pool_watermark,,slab_automove_extstore.c,global_pool_watermark,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
418,80768,iam_before,3,slab_automove.iam_before,,slab_automove_extstore.c,iam_before[MAX_NUMBER_OF_SLAB_CLASSES],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
419,80769,iam_after,3,slab_automove.iam_after,,slab_automove_extstore.c,iam_after[MAX_NUMBER_OF_SLAB_CLASSES],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
420,80770,sam_before,3,slab_automove.sam_before,,slab_automove_extstore.c,sam_before[MAX_NUMBER_OF_SLAB_CLASSES],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
421,80771,sam_after,3,slab_automove.sam_after,,slab_automove_extstore.c,sam_after[MAX_NUMBER_OF_SLAB_CLASSES],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,16,0,1,1,0,0,,0,0,0,0,0,
422,81603,size,3,slabclass_t.size,,slabs.c,size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
423,81604,perslab,3,slabclass_t.perslab,,slabs.c,perslab,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
424,81605,slots,3,slabclass_t.slots,,slabs.c,*slots,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
425,81606,sl_curr,3,slabclass_t.sl_curr,,slabs.c,sl_curr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
426,81607,slabs,3,slabclass_t.slabs,,slabs.c,slabs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
427,81608,slab_list,3,slabclass_t.slab_list,,slabs.c,**slab_list,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
428,85798,chunks_per_page,3,slab_stats_automove.chunks_per_page,,slabs.h,chunks_per_page,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
429,85799,chunk_size,3,slab_stats_automove.chunk_size,,slabs.h,chunk_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
430,85800,free_chunks,3,slab_stats_automove.free_chunks,,slabs.h,free_chunks,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
431,85801,total_pages,3,slab_stats_automove.total_pages,,slabs.h,total_pages,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
432,86616,sock,3,conn.sock,,testapp.c,sock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
433,100254,type,3,mcmc_resp_t.type,,vendor\mcmc\mcmc.h,type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
434,100255,code,3,mcmc_resp_t.code,,vendor\mcmc\mcmc.h,code,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
435,100256,value,3,mcmc_resp_t.value,,vendor\mcmc\mcmc.h,*value,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
436,100257,reslen,3,mcmc_resp_t.reslen,,vendor\mcmc\mcmc.h,reslen,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
437,100258,vlen_read,3,mcmc_resp_t.vlen_read,,vendor\mcmc\mcmc.h,vlen_read,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
438,100259,vlen,3,mcmc_resp_t.vlen,,vendor\mcmc\mcmc.h,vlen,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
439,63,assoc_init,1,assoc_init,void assoc_init (int),assoc.c,"void assoc_init(const int hashtable_init) {
    if (hashtable_init) {
        hashpower = hashtable_init;
    }
    primary_hashtable = calloc(hashsize(hashpower), sizeof(void *));
    if (! primary_hashtable) {
        fprintf(stderr, ""Failed to init hashtable.\n"");
        exit(EXIT_FAILURE);
    }
    STATS_LOCK();
    stats_state.hash_power_level = hashpower;
    stats_state.hash_bytes = hashsize(hashpower) * sizeof(void *);
    STATS_UNLOCK();
}",55.0,68.0,1.0,31.0,14.0,14,7,16,7,1,12,3,3,1,0,,0,10,2,1,1,void
440,118,assoc_find,1,assoc_find,"item assoc_find (char*,size_t,uint32_t)",assoc.c,"item *assoc_find(const char *key, const size_t nkey, const uint32_t hv) {
    item *it;
    uint64_t oldbucket;

    if (expanding &&
        (oldbucket = (hv & hashmask(hashpower - 1))) >= expand_bucket)
    {
        it = old_hashtable[oldbucket];
    } else {
        it = primary_hashtable[hv & hashmask(hashpower)];
    }

    item *ret = NULL;
    int depth = 0;
    while (it) {
        if ((nkey == it->nkey) && (memcmp(key, ITEM_key(it), nkey) == 0)) {
            ret = it;
            break;
        }
        it = it->h_next;
        ++depth;
    }
    MEMCACHED_ASSOC_FIND(key, nkey, depth);
    return ret;
}",70.0,94.0,1.0,27.0,25.0,28,15,26,13,1,4,5,5,3,0,,0,4,6,3,3,item
441,227,_hashitem_before,1,_hashitem_before,"item _hashitem_before (char*,size_t,uint32_t)",assoc.c,"static item** _hashitem_before (const char *key, const size_t nkey, const uint32_t hv) {
    item **pos;
    uint64_t oldbucket;

    if (expanding &&
        (oldbucket = (hv & hashmask(hashpower - 1))) >= expand_bucket)
    {
        pos = &old_hashtable[oldbucket];
    } else {
        pos = &primary_hashtable[hv & hashmask(hashpower)];
    }

    while (*pos && ((nkey != (*pos)->nkey) || memcmp(key, ITEM_key(*pos), nkey))) {
        pos = &(*pos)->h_next;
    }
    return pos;
}",99.0,115.0,1.0,27.0,17.0,32,16,20,10,1,4,3,3,3,0,,0,4,6,3,3,item
442,328,assoc_expand,1,assoc_expand,void assoc_expand (void),assoc.c,"static void assoc_expand(void) {
    old_hashtable = primary_hashtable;

    primary_hashtable = calloc(hashsize(hashpower + 1), sizeof(void *));
    if (primary_hashtable) {
        if (settings.verbose > 1)
            fprintf(stderr, ""Hash table expansion starting\n"");
        hashpower++;
        expanding = true;
        expand_bucket = 0;
        STATS_LOCK();
        stats_state.hash_power_level = hashpower;
        stats_state.hash_bytes += hashsize(hashpower) * sizeof(void *);
        stats_state.hash_is_expanding = true;
        STATS_UNLOCK();
    } else {
        primary_hashtable = old_hashtable;
        /* Bad news, but we can keep running. */
    }
}",118.0,137.0,1.0,31.0,20.0,21,10,20,10,1,17,3,4,2,0,,0,15,2,1,1,void
443,403,assoc_start_expand,1,assoc_start_expand,void assoc_start_expand (uint64_t),assoc.c,"void assoc_start_expand(uint64_t curr_items) {
    if (pthread_mutex_trylock(&maintenance_lock) == 0) {
        if (curr_items > (hashsize(hashpower) * 3) / 2 && hashpower < HASHPOWER_MAX) {
            pthread_cond_signal(&maintenance_cond);
        }
        pthread_mutex_unlock(&maintenance_lock);
    }
}",139.0,146.0,1.0,26.0,8.0,11,9,7,4,1,6,3,4,4,0,,0,6,2,1,1,void
444,443,assoc_insert,1,assoc_insert,"int assoc_insert (item*,uint32_t)",assoc.c,"int assoc_insert(item *it, const uint32_t hv) {
    uint64_t oldbucket;

//    assert(assoc_find(ITEM_key(it), it->nkey) == 0);  /* shouldn't have duplicately named things defined */

    if (expanding &&
        (oldbucket = (hv & hashmask(hashpower - 1))) >= expand_bucket)
    {
        it->h_next = old_hashtable[oldbucket];
        old_hashtable[oldbucket] = it;
    } else {
        it->h_next = primary_hashtable[hv & hashmask(hashpower)];
        primary_hashtable[hv & hashmask(hashpower)] = it;
    }

    MEMCACHED_ASSOC_INSERT(ITEM_key(it), it->nkey);
    return 1;
}",149.0,166.0,1.0,27.0,18.0,13,9,11,7,2,5,2,2,3,0,,0,5,4,2,2,int
445,521,assoc_delete,1,assoc_delete,"void assoc_delete (char*,size_t,uint32_t)",assoc.c,"void assoc_delete(const char *key, const size_t nkey, const uint32_t hv) {
    item **before = _hashitem_before(key, nkey, hv);

    if (*before) {
        item *nxt;
        /* The DTrace probe cannot be triggered as the last instruction
         * due to possible tail-optimization by the compiler
         */
        MEMCACHED_ASSOC_DELETE(key, nkey);
        nxt = (*before)->h_next;
        (*before)->h_next = 0;   /* probably pointless, but whatever. */
        *before = nxt;
        return;
    }
    /* Note:  we never actually get here.  the callers don't delete things
       they can't find. */
    assert(*before != 0);
}",168.0,185.0,1.0,8.0,18.0,12,4,11,5,2,1,2,2,0,1,,0,1,6,3,3,void
446,572,assoc_maintenance_thread,1,assoc_maintenance_thread,void* assoc_maintenance_thread (void*),assoc.c,"static void *assoc_maintenance_thread(void *arg) {

    mutex_lock(&maintenance_lock);
    while (do_run_maintenance_thread) {
        int ii = 0;

        /* There is only one expansion thread, so no need to global lock. */
        for (ii = 0; ii < hash_bulk_move && expanding; ++ii) {
            item *it, *next;
            uint64_t bucket;
            void *item_lock = NULL;

            /* bucket = hv & hashmask(hashpower) =>the bucket of hash table
             * is the lowest N bits of the hv, and the bucket of item_locks is
             *  also the lowest M bits of hv, and N is greater than M.
             *  So we can process expanding with only one item_lock. cool! */
            if ((item_lock = item_trylock(expand_bucket))) {
                    for (it = old_hashtable[expand_bucket]; NULL != it; it = next) {
                        next = it->h_next;
                        bucket = hash(ITEM_key(it), it->nkey) & hashmask(hashpower);
                        it->h_next =...",193.0,260.0,1.0,4.0,68.0,57,21,62,23,0,36,10,28,10,5,,0,30,2,1,1,void*
447,783,start_assoc_maintenance_thread,1,start_assoc_maintenance_thread,int start_assoc_maintenance_thread (),assoc.c,"int start_assoc_maintenance_thread() {
    int ret;
    char *env = getenv(""MEMCACHED_HASH_BULK_MOVE"");
    if (env != NULL) {
        hash_bulk_move = atoi(env);
        if (hash_bulk_move == 0) {
            hash_bulk_move = DEFAULT_HASH_BULK_MOVE;
        }
    }

    if ((ret = pthread_create(&maintenance_tid, NULL,
                              assoc_maintenance_thread, NULL)) != 0) {
        fprintf(stderr, ""Can't create thread: %s\n"", strerror(ret));
        return -1;
    }
    return 0;
}",264.0,280.0,1.0,29.0,17.0,9,5,13,6,1,4,4,5,2,0,,0,4,0,0,0,int
448,834,stop_assoc_maintenance_thread,1,stop_assoc_maintenance_thread,void stop_assoc_maintenance_thread (),assoc.c,"void stop_assoc_maintenance_thread() {
    mutex_lock(&maintenance_lock);
    do_run_maintenance_thread = 0;
    pthread_cond_signal(&maintenance_cond);
    mutex_unlock(&maintenance_lock);

    /* Wait for the maintenance thread to stop */
    pthread_join(maintenance_tid, NULL);
}",282.0,290.0,1.0,4.0,9.0,6,2,8,5,0,7,1,1,0,0,,0,7,0,0,0,void
449,866,assoc_get_iterator,1,assoc_get_iterator,void* assoc_get_iterator (void),assoc.c,"void *assoc_get_iterator(void) {
    struct assoc_iterator *iter = calloc(1, sizeof(struct assoc_iterator));
    if (iter == NULL) {
        return NULL;
    }
    // this will hang the caller while a hash table expansion is running.
    mutex_lock(&maintenance_lock);
    return iter;
}",299.0,307.0,1.0,4.0,9.0,5,4,8,4,1,2,2,2,0,0,,0,2,2,1,1,void*
450,894,assoc_iterate,1,assoc_iterate,"bool assoc_iterate (void*,item**)",assoc.c,"bool assoc_iterate(void *iterp, item **it) {
    struct assoc_iterator *iter = (struct assoc_iterator *) iterp;
    *it = NULL;
    // - if locked bucket and next, update next and return
    if (iter->bucket_locked) {
        if (iter->next != NULL) {
            iter->it = iter->next;
            iter->next = iter->it->h_next;
            *it = iter->it;
        } else {
            // unlock previous bucket, if any
            item_unlock(iter->bucket);
            // iterate the bucket post since it starts at 0.
            iter->bucket++;
            iter->bucket_locked = false;
            *it = NULL;
        }
        return true;
    }

    // - loop until we hit the end or find something.
    if (iter->bucket != hashsize(hashpower)) {
        // - lock next bucket
        item_lock(iter->bucket);
        iter->bucket_locked = true;
        // - only check the primary hash table since expand is blocked.
        iter->it = primary_hashtable[iter->bucket];
        if (iter->it ...",309.0,351.0,1.0,24.0,43.0,37,7,30,7,1,20,5,7,6,1,,0,19,4,2,2,bool
451,1040,assoc_iterate_final,1,assoc_iterate_final,void assoc_iterate_final (void*),assoc.c,"void assoc_iterate_final(void *iterp) {
    struct assoc_iterator *iter = (struct assoc_iterator *) iterp;
    if (iter->bucket_locked) {
        item_unlock(iter->bucket);
    }
    mutex_unlock(&maintenance_lock);
    free(iter);
}",353.0,360.0,1.0,4.0,8.0,6,4,7,3,1,5,2,2,1,1,,0,4,2,1,1,void
452,1181,authfile_load,1,authfile_load,enum authfile_ret authfile_load (char*),authfile.c,"enum authfile_ret authfile_load(const char *file) {
    struct stat sb;
    char *auth_data = NULL;
    auth_t auth_entries[MAX_ENTRIES];

    FILE *pwfile = fopen(file, ""r"");
    if (pwfile == NULL) {
        return AUTHFILE_OPENFAIL;
    } else if (fstat(fileno(pwfile), &sb)) {
        fclose(pwfile);
        return AUTHFILE_STATFAIL;
    }

    auth_data = calloc(1, sb.st_size + 1);

    char *auth_cur = auth_data;
    char *auth_end = auth_data + sb.st_size;
    auth_t *entry_cur = auth_entries;
    int used = 0;

    while ((fgets(auth_cur, auth_end - auth_cur < MAX_ENTRY_LEN ? auth_end - auth_cur : MAX_ENTRY_LEN, pwfile)) != NULL) {
        int x;
        int found = 0;

        for (x = 0; x < MAX_ENTRY_LEN; x++) {
            if (!found) {
                if (auth_cur[x] == '\0') {
                    // The username is malformed - this is either the end of the file or a null byte.
                    break;
                } else if (auth_cur[x] == ':') {
                  ...",31.0,109.0,1.0,24.0,79.0,36,15,52,18,2,5,13,19,1,0,,0,5,2,1,1,enum authfile_ret
453,1421,authfile_check,1,authfile_check,"int authfile_check (char*,char*)",authfile.c,"int authfile_check(const char *user, const char *pass) {
    size_t ulen = strlen(user);
    size_t plen = strlen(pass);

    for (int x = 0; x < entry_cnt; x++) {
        auth_t *e = &main_auth_entries[x];
        if (ulen == e->ulen && plen == e->plen &&
            safe_memcmp(user, e->user, e->ulen) &&
            safe_memcmp(pass, e->pass, e->plen)) {
            return 1;
        }
    }

    return 0;
}",112.0,126.0,1.0,1.0,15.0,18,7,20,8,1,4,3,4,3,2,,0,4,4,2,2,int
454,1790,base64_encode,1,base64_encode,"size_t base64_encode (unsigned char*,size_t,unsigned char*,size_t)",base64.c,"size_t base64_encode(const unsigned char *src, size_t len,
                  unsigned char *out, size_t out_len)
{
    unsigned char *pos;
    const unsigned char *end, *in;
    size_t olen;

    olen = len * 4 / 3 + 4; /* 3-byte blocks to 4-byte */
    olen += olen / 72; /* line feeds */
    olen++; /* nul termination */
    if (olen < len) {
        return 0; /* integer overflow */
    }
    if (olen > out_len) {
        return 0; /* not enough space in output buffer */
    }
    if (out == NULL) {
        return 0;
    }

    end = src + len;
    in = src;
    pos = out;
    while (end - in >= 3) {
        *pos++ = base64_table[in[0] >> 2];
        *pos++ = base64_table[((in[0] & 0x03) << 4) | (in[1] >> 4)];
        *pos++ = base64_table[((in[1] & 0x0f) << 2) | (in[2] >> 6)];
        *pos++ = base64_table[in[2] & 0x3f];
        in += 3;
    }

    if (end - in) {
        *pos++ = base64_table[in[0] >> 2];
        if (end - in == 1) {
            *pos++ = base64_table[(in[0] & 0x0...",93.0,139.0,1.0,1.0,47.0,74,17,50,10,5,6,7,8,0,0,,0,6,8,4,4,size_t
455,2008,base64_decode,1,base64_decode,"size_t base64_decode (unsigned char*,size_t,unsigned char*,size_t)",base64.c,"size_t base64_decode(const unsigned char *src, size_t len,
                  unsigned char *out, size_t out_len)
{
    unsigned char *pos, block[4], tmp;
    size_t i, count, olen;
    int pad = 0;

    count = 0;
    for (i = 0; i < len; i++) {
        if (dtable[src[i]] != 0x80)
            count++;
    }

    if (count == 0 || count % 4)
        return 0;

    olen = count / 4 * 3;
    if (olen > out_len) {
        return 0;
    }
    pos = out;
    if (out == NULL) {
        return 0;
    }

    count = 0;
    for (i = 0; i < len; i++) {
        tmp = dtable[src[i]];
        if (tmp == 0x80)
            continue;

        if (src[i] == '=')
            pad++;
        block[count] = tmp;
        count++;
        if (count == 4) {
            *pos++ = (block[0] << 2) | (block[1] >> 4);
            *pos++ = (block[1] << 4) | (block[2] >> 2);
            *pos++ = (block[2] << 6) | block[3];
            count = 0;
            if (pad) {
                if (pad == 1)
                 ...",150.0,205.0,1.0,1.0,56.0,58,17,51,13,2,2,14,21,1,0,,0,2,8,4,4,size_t
456,2243,bipbuf_sizeof,1,bipbuf_sizeof,size_t bipbuf_sizeof (unsigned int),bipbuffer.c,"static size_t bipbuf_sizeof(const unsigned int size)
{
    return sizeof(bipbuf_t) + size;
}",18.0,21.0,1.0,1.0,4.0,2,2,2,2,1,0,1,1,0,0,,0,0,2,1,1,size_t
457,2253,bipbuf_unused,1,bipbuf_unused,int bipbuf_unused (bipbuf_t*),bipbuffer.c,"int bipbuf_unused(const bipbuf_t* me)
{
    if (1 == me->b_inuse)
        /* distance between region B and region A */
        return me->a_start - me->b_end;
    else
        return me->size - me->a_end;
}",23.0,30.0,1.0,1.0,8.0,5,3,3,1,3,3,2,2,1,0,,0,3,2,1,1,int
458,2283,bipbuf_size,1,bipbuf_size,int bipbuf_size (bipbuf_t*),bipbuffer.c,"int bipbuf_size(const bipbuf_t* me)
{
    return me->size;
}",32.0,35.0,1.0,1.0,4.0,1,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,int
459,2292,bipbuf_used,1,bipbuf_used,int bipbuf_used (bipbuf_t*),bipbuffer.c,"int bipbuf_used(const bipbuf_t* me)
{
    return (me->a_end - me->a_start) + me->b_end;
}",37.0,40.0,1.0,1.0,4.0,5,3,3,1,1,3,1,1,0,0,,0,3,2,1,1,int
460,2309,bipbuf_init,1,bipbuf_init,"void bipbuf_init (bipbuf_t*,unsigned int)",bipbuffer.c,"void bipbuf_init(bipbuf_t* me, const unsigned int size)
{
    me->a_start = me->a_end = me->b_end = 0;
    me->size = size;
    me->b_inuse = 0;
}",42.0,47.0,1.0,1.0,6.0,10,2,6,2,1,5,1,1,0,0,,0,5,4,2,2,void
461,2338,bipbuf_new,1,bipbuf_new,bipbuf_t bipbuf_new (unsigned int),bipbuffer.c,"bipbuf_t *bipbuf_new(const unsigned int size)
{
    bipbuf_t *me = malloc(bipbuf_sizeof(size));
    if (!me)
        return NULL;
    bipbuf_init(me, size);
    return me;
}",49.0,56.0,1.0,1.0,8.0,2,2,7,3,4,2,2,2,0,2,,0,1,2,1,1,bipbuf_t
462,2360,bipbuf_free,1,bipbuf_free,void bipbuf_free (bipbuf_t*),bipbuffer.c,"void bipbuf_free(bipbuf_t* me)
{
    free(me);
}",58.0,61.0,1.0,1.0,4.0,0,0,1,1,3,0,1,1,0,0,,0,0,2,1,1,void
463,2367,bipbuf_is_empty,1,bipbuf_is_empty,int bipbuf_is_empty (bipbuf_t*),bipbuffer.c,"int bipbuf_is_empty(const bipbuf_t* me)
{
    return me->a_start == me->a_end;
}",63.0,66.0,1.0,1.0,4.0,3,2,2,1,3,2,1,1,0,0,,0,2,2,1,1,int
464,2380,__check_for_switch_to_b,1,__check_for_switch_to_b,void __check_for_switch_to_b (bipbuf_t*),bipbuffer.c,"static void __check_for_switch_to_b(bipbuf_t* me)
{
    if (me->size - me->a_end < me->a_start - me->b_end)
        me->b_inuse = 1;
}",70.0,74.0,1.0,1.0,5.0,9,4,5,1,3,5,2,2,4,0,,0,5,2,1,1,void
465,2407,bipbuf_request,1,bipbuf_request,"unsigned char* bipbuf_request (bipbuf_t*,int)",bipbuffer.c,"unsigned char *bipbuf_request(bipbuf_t* me, const int size)
{
    if (bipbuf_unused(me) < size)
        return 0;
    if (1 == me->b_inuse)
    {
        return (unsigned char *)me->data + me->b_end;
    }
    else
    {
        return (unsigned char *)me->data + me->a_end;
    }
}",77.0,89.0,1.0,1.0,13.0,7,5,5,2,2,4,3,3,2,1,,0,4,4,2,2,unsigned char*
466,2450,bipbuf_push,1,bipbuf_push,"int bipbuf_push (bipbuf_t*,int)",bipbuffer.c,"int bipbuf_push(bipbuf_t* me, const int size)
{
    if (bipbuf_unused(me) < size)
        return 0;

    if (1 == me->b_inuse)
    {
        me->b_end += size;
    }
    else
    {
        me->a_end += size;
    }

    __check_for_switch_to_b(me);
    return size;
}",91.0,107.0,1.0,1.0,17.0,5,4,7,2,2,4,3,3,2,2,,0,3,4,2,2,int
467,2487,bipbuf_offer,1,bipbuf_offer,"int bipbuf_offer (bipbuf_t*,unsigned char*,int)",bipbuffer.c,"int bipbuf_offer(bipbuf_t* me, const unsigned char *data, const int size)
{
    /* not enough space */
    if (bipbuf_unused(me) < size)
        return 0;

    if (1 == me->b_inuse)
    {
        memcpy(me->data + me->b_end, data, size);
        me->b_end += size;
    }
    else
    {
        memcpy(me->data + me->a_end, data, size);
        me->a_end += size;
    }

    __check_for_switch_to_b(me);
    return size;
}",109.0,128.0,1.0,1.0,20.0,8,5,11,3,2,6,3,3,2,2,,0,5,6,3,3,int
468,2545,bipbuf_peek,1,bipbuf_peek,"unsigned char* bipbuf_peek (bipbuf_t*,unsigned int)",bipbuffer.c,"unsigned char *bipbuf_peek(const bipbuf_t* me, const unsigned int size)
{
    /* make sure we can actually peek at this data */
    if (me->size < me->a_start + size)
        return NULL;

    if (bipbuf_is_empty(me))
        return NULL;

    return (unsigned char *)me->data + me->a_start;
}",130.0,140.0,1.0,1.0,11.0,8,4,8,3,0,5,3,3,3,1,,0,5,4,2,2,unsigned char*
469,2580,bipbuf_peek_all,1,bipbuf_peek_all,"unsigned char* bipbuf_peek_all (bipbuf_t*,unsigned int*)",bipbuffer.c,"unsigned char *bipbuf_peek_all(const bipbuf_t* me, unsigned int *size)
{
    if (bipbuf_is_empty(me))
        return NULL;

    *size = me->a_end - me->a_start;
    return (unsigned char*)me->data + me->a_start;
}",142.0,149.0,1.0,1.0,8.0,9,6,7,3,3,5,2,2,1,1,,0,5,4,2,2,unsigned char*
470,2612,bipbuf_poll,1,bipbuf_poll,"unsigned char* bipbuf_poll (bipbuf_t*,unsigned int)",bipbuffer.c,"unsigned char *bipbuf_poll(bipbuf_t* me, const unsigned int size)
{
    if (bipbuf_is_empty(me))
        return NULL;

    /* make sure we can actually poll this data */
    if (me->size < me->a_start + size)
        return NULL;

    void *end = me->data + me->a_start;
    me->a_start += size;

    /* we seem to be empty.. */
    if (me->a_start == me->a_end)
    {
        /* replace a with region b */
        if (1 == me->b_inuse)
        {
            me->a_start = 0;
            me->a_end = me->b_end;
            me->b_end = me->b_inuse = 0;
        }
        else
            /* safely move cursor back to the start because we are empty */
            me->a_start = me->a_end = 0;
    }

    __check_for_switch_to_b(me);
    return end;
}",151.0,180.0,1.0,1.0,30.0,24,6,21,4,2,15,5,6,6,2,,0,14,4,2,2,unsigned char*
471,2820,cache_create,1,cache_create,"cache_t cache_create (char*,size_t,size_t)",cache.c,"cache_t* cache_create(const char *name, size_t bufsize, size_t align) {
    cache_t* ret = calloc(1, sizeof(cache_t));
    char* nm = strdup(name);
    if (ret == NULL || nm == NULL ||
        pthread_mutex_init(&ret->mutex, NULL) == -1) {
        free(ret);
        free(nm);
        return NULL;
    }

    ret->name = nm;
    STAILQ_INIT(&ret->head);

#ifndef NDEBUG
    ret->bufsize = bufsize + 2 * sizeof(redzone_pattern);
#else
    ret->bufsize = bufsize;
#endif
    assert(ret->bufsize >= sizeof(struct cache_free_s));

    return ret;
}",18.0,39.0,1.0,4.0,22.0,35,10,26,8,8,9,2,2,1,0,,0,9,6,3,3,cache_t
472,2919,cache_set_limit,1,cache_set_limit,"void cache_set_limit (cache_t*,int)",cache.c,"void cache_set_limit(cache_t *cache, int limit) {
    pthread_mutex_lock(&cache->mutex);
    cache->limit = limit;
    pthread_mutex_unlock(&cache->mutex);
}",41.0,45.0,1.0,1.0,5.0,6,3,4,2,2,3,1,1,0,0,,0,3,4,2,2,void
473,2940,get_object,1,get_object,void* get_object (void*),cache.c,"static inline void* get_object(void *ptr) {
#ifndef NDEBUG
    uint64_t *pre = ptr;
    return pre + 1;
#else
    return ptr;
#endif
}",47.0,54.0,1.0,1.0,8.0,2,2,3,2,1,0,1,1,0,0,,0,0,2,1,1,void*
474,2953,cache_destroy,1,cache_destroy,void cache_destroy (cache_t*),cache.c,"void cache_destroy(cache_t *cache) {
    while (!STAILQ_EMPTY(&cache->head)) {
        struct cache_free_s *o = STAILQ_FIRST(&cache->head);
        STAILQ_REMOVE_HEAD(&cache->head, c_next);
        free(o);
    }
    free(cache->name);
    pthread_mutex_destroy(&cache->mutex);
    free(cache);
}",56.0,65.0,1.0,12.0,10.0,36,6,16,3,5,11,2,2,2,0,,0,11,2,1,1,void
475,3047,cache_alloc,1,cache_alloc,void* cache_alloc (cache_t*),cache.c,"void* cache_alloc(cache_t *cache) {
    void *ret;
    pthread_mutex_lock(&cache->mutex);
    ret = do_cache_alloc(cache);
    pthread_mutex_unlock(&cache->mutex);
    return ret;
}",67.0,73.0,1.0,1.0,7.0,5,3,5,2,5,3,1,1,0,1,,0,3,2,1,1,void*
476,3069,do_cache_alloc,1,do_cache_alloc,void* do_cache_alloc (cache_t*),cache.c,"void* do_cache_alloc(cache_t *cache) {
    void *ret;
    void *object;
    if (cache->freecurr > 0) {
        ret = STAILQ_FIRST(&cache->head);
        STAILQ_REMOVE_HEAD(&cache->head, c_next);
        object = get_object(ret);
        cache->freecurr--;
    } else if (cache->limit == 0 || cache->total < cache->limit) {
        object = ret = malloc(cache->bufsize);
        if (ret != NULL) {
            object = get_object(ret);

            cache->total++;
        }
    } else {
        object = NULL;
    }

#ifndef NDEBUG
    if (object != NULL) {
        /* add a simple form of buffer-check */
        uint64_t *pre = ret;
        *pre = redzone_pattern;
        ret = pre+1;
        memcpy(((char*)ret) + cache->bufsize - (2 * sizeof(redzone_pattern)),
               &redzone_pattern, sizeof(redzone_pattern));
    }
#endif

    return object;
}",75.0,106.0,1.0,14.0,32.0,45,14,27,6,4,15,3,3,1,1,,0,15,2,1,1,void*
477,3229,cache_free,1,cache_free,"void cache_free (cache_t*,void*)",cache.c,"void cache_free(cache_t *cache, void *ptr) {
    pthread_mutex_lock(&cache->mutex);
    do_cache_free(cache, ptr);
    pthread_mutex_unlock(&cache->mutex);
}",108.0,112.0,1.0,1.0,5.0,4,2,4,2,7,3,1,1,0,1,,0,2,4,2,2,void
478,3248,do_cache_free,1,do_cache_free,"void do_cache_free (cache_t*,void*)",cache.c,"void do_cache_free(cache_t *cache, void *ptr) {
#ifndef NDEBUG
    /* validate redzone... */
    if (memcmp(((char*)ptr) + cache->bufsize - (2 * sizeof(redzone_pattern)),
               &redzone_pattern, sizeof(redzone_pattern)) != 0) {
        raise(SIGABRT);
        cache_error = 1;
        return;
    }
    uint64_t *pre = ptr;
    --pre;
    if (*pre != redzone_pattern) {
        raise(SIGABRT);
        cache_error = -1;
        return;
    }
    ptr = pre;
#endif
    if (cache->limit != 0 && cache->limit < cache->total) {
        free(ptr);
        cache->total--;
    } else {
        STAILQ_INSERT_HEAD(&cache->head, (struct cache_free_s *)ptr, c_next);
        cache->freecurr++;
    }
}",114.0,139.0,1.0,8.0,26.0,25,15,21,6,3,11,4,4,8,0,,0,11,4,2,2,void
479,3643,lru_crawler_client_getbuf,1,lru_crawler_client_getbuf,int lru_crawler_client_getbuf (crawler_client_t*),crawler.c,"static int lru_crawler_client_getbuf(crawler_client_t *c) {
    void *buf = NULL;
    if (c->c == NULL) return -1;
    /* not enough space. */
    while ((buf = bipbuf_request(c->buf, LRU_CRAWLER_WRITEBUF)) == NULL) {
        // TODO: max loops before closing.
        int ret = lru_crawler_poll(c);
        if (ret < 0) return ret;
    }

    c->cbuf = buf;
    return 0;
}",327.0,339.0,1.0,41.0,13.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,int
480,3676,lru_crawler_close_client,1,lru_crawler_close_client,void lru_crawler_close_client (crawler_client_t*),crawler.c,"static void lru_crawler_close_client(crawler_client_t *c) {
    //fprintf(stderr, ""CRAWLER: Closing client\n"");
    sidethread_conn_close(c->c);
    c->c = NULL;
    c->cbuf = NULL;
    bipbuf_free(c->buf);
    c->buf = NULL;
}",112.0,119.0,1.0,1.0,8.0,8,2,8,2,2,7,1,1,0,2,,0,5,2,1,1,void
481,3704,lru_crawler_release_client,1,lru_crawler_release_client,void lru_crawler_release_client (crawler_client_t*),crawler.c,"static void lru_crawler_release_client(crawler_client_t *c) {
    //fprintf(stderr, ""CRAWLER: Closing client\n"");
    redispatch_conn(c->c);
    c->c = NULL;
    c->cbuf = NULL;
    bipbuf_free(c->buf);
    c->buf = NULL;
}",121.0,128.0,1.0,1.0,8.0,8,2,8,2,1,7,1,1,0,2,,0,5,2,1,1,void
482,4391,lru_crawler_poll,1,lru_crawler_poll,int lru_crawler_poll (crawler_client_t*),crawler.c,"static int lru_crawler_poll(crawler_client_t *c) {
    unsigned char *data;
    unsigned int data_size = 0;
    struct pollfd to_poll[1];
    to_poll[0].fd = c->sfd;
    to_poll[0].events = POLLOUT;

    int ret = poll(to_poll, 1, 1000);

    if (ret < 0) {
        // fatal.
        return -1;
    }

    if (ret == 0) return 0;

    if (to_poll[0].revents & POLLIN) {
        char buf[1];
        int res = ((conn*)c->c)->read(c->c, buf, 1);
        if (res == 0 || (res == -1 && (errno != EAGAIN && errno != EWOULDBLOCK))) {
            lru_crawler_close_client(c);
            return -1;
        }
    }
    if ((data = bipbuf_peek_all(c->buf, &data_size)) != NULL) {
        if (to_poll[0].revents & (POLLHUP|POLLERR)) {
            lru_crawler_close_client(c);
            return -1;
        } else if (to_poll[0].revents & POLLOUT) {
            int total = ((conn*)c->c)->write(c->c, data, data_size);
            if (total == -1) {
                if (errno != EAGAIN && errno != EWOULDBL...",277.0,321.0,1.0,1.0,45.0,38,14,30,15,1,8,7,9,2,4,,0,6,2,1,1,int
483,4636,lru_crawler_class_done,1,lru_crawler_class_done,void lru_crawler_class_done (int),crawler.c,"static void lru_crawler_class_done(int i) {
    crawlers[i].it_flags = 0;
    crawler_count--;
    do_item_unlinktail_q((item *)&crawlers[i]);
    do_item_stats_add_crawl(i, crawlers[i].reclaimed,
            crawlers[i].unfetched, crawlers[i].checked);
    pthread_mutex_unlock(&lru_locks[i]);
    if (active_crawler_mod.mod->doneclass != NULL)
        active_crawler_mod.mod->doneclass(&active_crawler_mod, i);
}",341.0,350.0,1.0,1.0,10.0,21,8,19,6,0,11,2,2,1,2,,0,9,2,1,1,void
484,4697,item_crawl_hash,1,item_crawl_hash,void item_crawl_hash (void),crawler.c,"static void item_crawl_hash(void) {
    // get iterator from assoc. can hang for a long time.
    // - blocks hash expansion
    void *iter = assoc_get_iterator();
    int crawls_persleep = settings.crawls_persleep;
    item *it = NULL;

    // loop while iterator returns something
    // - iterator func handles bucket-walking
    // - iterator returns with bucket locked.
    while (assoc_iterate(iter, &it)) {
        // if iterator returns true but no item, we're inbetween buckets and
        // can do sleep or cleanup work without holding a lock.
        if (it == NULL) {
            // - sleep bits from orig loop
            if (crawls_persleep-- <= 0 && settings.lru_crawler_sleep) {
                pthread_mutex_unlock(&lru_crawler_lock);
                usleep(settings.lru_crawler_sleep);
                pthread_mutex_lock(&lru_crawler_lock);
                crawls_persleep = settings.crawls_persleep;
            } else if (!settings.lru_crawler_sleep) {
                // TODO...",352.0,406.0,1.0,12.0,55.0,30,12,29,8,1,14,10,14,3,4,,0,13,2,1,1,void
485,4833,item_crawler_thread,1,item_crawler_thread,void* item_crawler_thread (void*),crawler.c,"static void *item_crawler_thread(void *arg) {
    int i;
    int crawls_persleep = settings.crawls_persleep;

    pthread_mutex_lock(&lru_crawler_lock);
    pthread_cond_signal(&lru_crawler_cond);
    settings.lru_crawler = true;
    if (settings.verbose > 2)
        fprintf(stderr, ""Starting LRU crawler background thread\n"");
    while (do_run_lru_crawler_thread) {
    pthread_cond_wait(&lru_crawler_cond, &lru_crawler_lock);

    if (crawler_count == -1) {
        item_crawl_hash();
        crawler_count = 0;
    } else {
    while (crawler_count) {
        item *search = NULL;
        void *hold_lock = NULL;

        for (i = POWER_SMALLEST; i < LARGEST_ID; i++) {
            if (crawlers[i].it_flags != 1) {
                continue;
            }

            /* Get memory from bipbuf, if client has no space, flush. */
            if (active_crawler_mod.c.c != NULL) {
                int ret = lru_crawler_client_getbuf(&active_crawler_mod.c);
                if (ret != 0) {
     ...",408.0,526.0,1.0,17.0,119.0,45,9,38,12,0,31,10,19,11,4,,0,26,2,1,1,void*
486,5264,stop_item_crawler_thread,1,stop_item_crawler_thread,int stop_item_crawler_thread (bool),crawler.c,"int stop_item_crawler_thread(bool wait) {
    int ret;
    pthread_mutex_lock(&lru_crawler_lock);
    if (do_run_lru_crawler_thread == 0) {
        pthread_mutex_unlock(&lru_crawler_lock);
        return 0;
    }
    do_run_lru_crawler_thread = 0;
    pthread_cond_signal(&lru_crawler_cond);
    pthread_mutex_unlock(&lru_crawler_lock);
    if (wait && (ret = pthread_join(item_crawler_tid, NULL)) != 0) {
        fprintf(stderr, ""Failed to stop LRU crawler thread: %s\n"", strerror(ret));
        return -1;
    }
    return 0;
}",530.0,545.0,1.0,1.0,16.0,10,6,12,8,0,7,3,3,2,0,,0,7,2,1,1,int
487,5313,start_item_crawler_thread,1,start_item_crawler_thread,int start_item_crawler_thread (void),crawler.c,"int start_item_crawler_thread(void) {
    int ret;

    if (settings.lru_crawler)
        return -1;
    pthread_mutex_lock(&lru_crawler_lock);
    do_run_lru_crawler_thread = 1;
    if ((ret = pthread_create(&item_crawler_tid, NULL,
        item_crawler_thread, NULL)) != 0) {
        fprintf(stderr, ""Can't create LRU crawler thread: %s\n"",
            strerror(ret));
        pthread_mutex_unlock(&lru_crawler_lock);
        return -1;
    }
    /* Avoid returning until the crawler has actually started */
    pthread_cond_wait(&lru_crawler_cond, &lru_crawler_lock);
    pthread_mutex_unlock(&lru_crawler_lock);

    return 0;
}",558.0,577.0,1.0,1.0,20.0,12,5,13,8,1,8,3,3,2,0,,0,8,2,1,1,int
488,5366,do_lru_crawler_start,1,do_lru_crawler_start,"int do_lru_crawler_start (uint32_t,uint32_t)",crawler.c,"static int do_lru_crawler_start(uint32_t id, uint32_t remaining) {
    uint32_t sid = id;
    int starts = 0;

    pthread_mutex_lock(&lru_locks[sid]);
    if (crawlers[sid].it_flags == 0) {
        if (settings.verbose > 2)
            fprintf(stderr, ""Kicking LRU crawler off for LRU %u\n"", sid);
        crawlers[sid].nbytes = 0;
        crawlers[sid].nkey = 0;
        crawlers[sid].it_flags = 1; /* For a crawler, this means enabled. */
        crawlers[sid].next = 0;
        crawlers[sid].prev = 0;
        crawlers[sid].time = 0;
        if (remaining == LRU_CRAWLER_CAP_REMAINING) {
            remaining = do_get_lru_size(sid);
        }
        /* Values for remaining:
         * remaining = 0
         * - scan all elements, until a NULL is reached
         * - if empty, NULL is reached right away
         * remaining = n + 1
         * - first n elements are parsed (or until a NULL is reached)
         */
        if (remaining) remaining++;
        crawlers[sid].remaining = rema...",582.0,618.0,1.0,25.0,37.0,53,9,46,9,0,17,5,8,2,2,,0,16,4,2,2,int
489,5517,lru_crawler_set_client,1,lru_crawler_set_client,"int lru_crawler_set_client (crawler_module_t*,void*,int)",crawler.c,"static int lru_crawler_set_client(crawler_module_t *cm, void *c, const int sfd) {
    crawler_client_t *crawlc = &cm->c;
    if (crawlc->c != NULL) {
        return -1;
    }
    crawlc->c = c;
    crawlc->sfd = sfd;

    crawlc->buf = bipbuf_new(1024 * 128);
    if (crawlc->buf == NULL) {
        return -2;
    }
    return 0;
}",620.0,633.0,1.0,1.0,14.0,16,7,11,5,1,6,3,3,2,1,,0,6,6,3,3,int
490,5571,lru_crawler_start,1,lru_crawler_start,"int lru_crawler_start (uint8_t*,uint32_t,crawler_run_type,void*,void*,int)",crawler.c,"int lru_crawler_start(uint8_t *ids, uint32_t remaining,
                             const enum crawler_run_type type, void *data,
                             void *c, const int sfd) {
    int starts = 0;
    bool is_running;
    static rel_time_t block_ae_until = 0;
    pthread_mutex_lock(&lru_crawler_lock);
    STATS_LOCK();
    is_running = stats_state.lru_crawler_running;
    STATS_UNLOCK();
    if (do_run_lru_crawler_thread == 0) {
        pthread_mutex_unlock(&lru_crawler_lock);
        return -2;
    }

    if (is_running &&
            !(type == CRAWLER_AUTOEXPIRE && active_crawler_type == CRAWLER_AUTOEXPIRE)) {
        pthread_mutex_unlock(&lru_crawler_lock);
        block_ae_until = current_time + 60;
        return -1;
    }

    if (type == CRAWLER_AUTOEXPIRE && block_ae_until > current_time) {
        pthread_mutex_unlock(&lru_crawler_lock);
        return -1;
    }

    /* hash table walk only supported with metadump for now. */
    if (type != CRAWLER_METADUMP && ids...",635.0,711.0,1.0,23.0,77.0,61,14,59,22,2,29,12,18,6,1,,0,25,12,6,6,int
491,5801,lru_crawler_crawl,1,lru_crawler_crawl,"enum crawler_result_type lru_crawler_crawl (char*,crawler_run_type,void*,int,unsigned int)",crawler.c,"enum crawler_result_type lru_crawler_crawl(char *slabs, const enum crawler_run_type type,
        void *c, const int sfd, unsigned int remaining) {
    char *b = NULL;
    uint32_t sid = 0;
    int starts = 0;
    uint8_t tocrawl[POWER_LARGEST];
    bool hash_crawl = false;

    /* FIXME: I added this while debugging. Don't think it's needed? */
    memset(tocrawl, 0, sizeof(uint8_t) * POWER_LARGEST);
    if (strcmp(slabs, ""all"") == 0) {
        for (sid = 0; sid < POWER_LARGEST; sid++) {
            tocrawl[sid] = 1;
        }
    } else if (strcmp(slabs, ""hash"") == 0) {
        hash_crawl = true;
    } else {
        for (char *p = strtok_r(slabs, "","", &b);
             p != NULL;
             p = strtok_r(NULL, "","", &b)) {

            if (!safe_strtoul(p, &sid) || sid < POWER_SMALLEST
                    || sid >= MAX_NUMBER_OF_SLAB_CLASSES) {
                return CRAWLER_BADCLASS;
            }
            tocrawl[sid | TEMP_LRU] = 1;
            tocrawl[sid | HOT_LRU] = 1;
 ...",716.0,758.0,1.0,20.0,43.0,15,8,24,14,1,1,4,5,0,1,,0,1,10,5,5,enum crawler_result_type
492,5996,lru_crawler_pause,1,lru_crawler_pause,void lru_crawler_pause (void),crawler.c,"void lru_crawler_pause(void) {
    pthread_mutex_lock(&lru_crawler_lock);
}",761.0,763.0,1.0,1.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,void
493,6004,lru_crawler_resume,1,lru_crawler_resume,void lru_crawler_resume (void),crawler.c,"void lru_crawler_resume(void) {
    pthread_mutex_unlock(&lru_crawler_lock);
}",765.0,767.0,1.0,1.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,void
494,6012,init_lru_crawler,1,init_lru_crawler,int init_lru_crawler (void*),crawler.c,"int init_lru_crawler(void *arg) {
    if (lru_crawler_initialized == 0) {
#ifdef EXTSTORE
        storage = arg;
#endif
        active_crawler_mod.c.c = NULL;
        active_crawler_mod.mod = NULL;
        active_crawler_mod.data = NULL;
        lru_crawler_initialized = 1;
    }
    return 0;
}",769.0,780.0,1.0,1.0,12.0,9,3,8,3,1,5,2,2,1,0,,0,5,2,1,1,int
495,6142,crc32c_sw_little,1,crc32c_sw_little,"uint32_t crc32c_sw_little (uint32_t,void*,size_t)",crc32c.c,"uint32_t crc32c_sw_little(uint32_t crc, void const *buf, size_t len) {
    unsigned char const *next = buf;

    pthread_once(&crc32c_once_little, crc32c_init_sw_little);
    crc = ~crc;
    while (len && ((uintptr_t)next & 7) != 0) {
        crc = crc32c_table_little[0][(crc ^ *next++) & 0xff] ^ (crc >> 8);
        len--;
    }
    if (len >= 8) {
        uint64_t crcw = crc;
        do {
            crcw ^= *(uint64_t const *)next;
            crcw = crc32c_table_little[7][crcw & 0xff] ^
                   crc32c_table_little[6][(crcw >> 8) & 0xff] ^
                   crc32c_table_little[5][(crcw >> 16) & 0xff] ^
                   crc32c_table_little[4][(crcw >> 24) & 0xff] ^
                   crc32c_table_little[3][(crcw >> 32) & 0xff] ^
                   crc32c_table_little[2][(crcw >> 40) & 0xff] ^
                   crc32c_table_little[1][(crcw >> 48) & 0xff] ^
                   crc32c_table_little[0][crcw >> 56];
            next += 8;
            len -= 8;
        } whi...",392.0,423.0,1.0,1.0,32.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,uint32_t
496,6156,crc32c_init,1,crc32c_init,void crc32c_init (void),crc32c.c,"void crc32c_init(void) {
    crc32c = crc32c_sw;
}",359.0,361.0,1.0,1.0,3.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
497,6172,crc32c_init_sw_little,1,crc32c_init_sw_little,void crc32c_init_sw_little (void),crc32c.c,"static void crc32c_init_sw_little(void) {
    for (unsigned n = 0; n < 256; n++) {
        uint32_t crc = n;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc32c_table_little[0][n] = crc;
    }
    for (unsigned n = 0; n < 256; n++) {
        uint32_t crc = crc32c_table_little[0][n];
        for (unsigned k = 1; k < 8; k++) {
            crc = crc32c_table_little[0][crc & 0xff] ^ (crc >> 8);
            crc32c_table_little[k][n] = crc;
        }
    }
}",368.0,388.0,1.0,37.0,21.0,70,7,54,4,0,4,4,5,0,0,,0,4,2,1,1,void
498,6560,swap,1,swap,uint64_t swap (uint64_t),crc32c.c,"static inline uint64_t swap(uint64_t x) {
    x = ((x << 8) & 0xff00ff00ff00ff00) | ((x >> 8) & 0xff00ff00ff00ff);
    x = ((x << 16) & 0xffff0000ffff0000) | ((x >> 16) & 0xffff0000ffff);
    return (x << 32) | (x >> 32);
}",430.0,434.0,1.0,1.0,5.0,15,5,8,1,2,0,1,1,0,0,,0,0,2,1,1,uint64_t
499,6610,crc32c_init_sw_big,1,crc32c_init_sw_big,void crc32c_init_sw_big (void),crc32c.c,"static void crc32c_init_sw_big(void) {
    for (unsigned n = 0; n < 256; n++) {
        uint32_t crc = n;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc = crc & 1 ? (crc >> 1) ^ POLY : crc >> 1;
        crc32c_table_big_byte[n] = crc;
    }
    for (unsigned n = 0; n < 256; n++) {
        uint32_t crc = crc32c_table_big_byte[n];
        crc32c_table_big[0][n] = swap(crc);
        for (unsigned k = 1; k < 8; k++) {
            crc = crc32c_table_big_byte[crc & 0xff] ^ (crc >> 8);
            crc32c_table_big[k][n] = swap(crc);
        }
    }
}",441.0,462.0,1.0,37.0,22.0,70,7,57,5,0,7,4,5,0,2,,0,7,2,1,1,void
500,6999,crc32c_sw,1,crc32c_sw,"uint32_t crc32c_sw (uint32_t,void*,size_t)",crc32c.c,"uint32_t crc32c_sw(uint32_t crc, void const *buf, size_t len) {
    static int const little = 1;
    if (*(char const *)&little)
        return crc32c_sw_little(crc, buf, len);
    else
        return crc32c_sw_big(crc, buf, len);
}",506.0,512.0,1.0,1.0,7.0,4,4,5,4,3,1,2,2,0,1,,0,0,6,3,3,uint32_t
501,7071,daemonize,1,daemonize,"int daemonize (int,int)",daemon.c,"int daemonize(int nochdir, int noclose)
{
    int fd;

    switch (fork()) {
    case -1:
        return (-1);
    case 0:
        break;
    default:
        _exit(EXIT_SUCCESS);
    }

    if (setsid() == -1)
        return (-1);

    if (nochdir == 0) {
        if(chdir(""/"") != 0) {
            perror(""chdir"");
            return (-1);
        }
    }

    if (noclose == 0 && (fd = open(""/dev/null"", O_RDWR, 0)) != -1) {
        if(dup2(fd, STDIN_FILENO) < 0) {
            perror(""dup2 stdin"");
            goto err_cleanup;
        }
        if(dup2(fd, STDOUT_FILENO) < 0) {
            perror(""dup2 stdout"");
            goto err_cleanup;
        }
        if(dup2(fd, STDERR_FILENO) < 0) {
            perror(""dup2 stderr"");
            goto err_cleanup;
        }

        if(close(fd) < 0) {
            perror(""close"");
            return (-1);
        }
    }
    return (0);

    err_cleanup:
        close(fd);
        return (-1);
}",44.0,91.0,1.0,1.0,48.0,19,6,13,8,1,0,14,15,0,0,,0,0,4,2,2,int
502,7302,wbuf_new,1,wbuf_new,_store_wbuf wbuf_new (size_t),extstore.c,"static _store_wbuf *wbuf_new(size_t size) {
    _store_wbuf *b = calloc(1, sizeof(_store_wbuf));
    if (b == NULL)
        return NULL;
    b->buf = calloc(size, sizeof(char));
    if (b->buf == NULL) {
        free(b);
        return NULL;
    }
    b->buf_pos = b->buf;
    b->free = size;
    b->size = size;
    return b;
}",115.0,128.0,1.0,1.0,14.0,15,4,19,5,1,0,3,3,0,0,,0,0,2,1,1,_store_wbuf
503,7359,_get_io_thread,1,_get_io_thread,store_io_thread _get_io_thread (store_engine*),extstore.c,"static store_io_thread *_get_io_thread(store_engine *e) {
    int tid = -1;
    long long int low = LLONG_MAX;
    pthread_mutex_lock(&e->mutex);
    // find smallest queue. ignoring lock since being wrong isn't fatal.
    // TODO: if average queue depth can be quickly tracked, can break as soon
    // as we see a thread that's less than average, and start from last_io_thread
    for (int x = 0; x < e->io_threadcount; x++) {
        if (e->io_threads[x].depth == 0) {
            tid = x;
            break;
        } else if (e->io_threads[x].depth < low) {
                tid = x;
            low = e->io_threads[x].depth;
        }
    }
    pthread_mutex_unlock(&e->mutex);

    return &e->io_threads[tid];
}",130.0,149.0,1.0,1.0,20.0,18,8,14,5,1,5,4,4,2,0,,0,5,2,1,1,store_io_thread
504,7444,_next_version,1,_next_version,uint64_t _next_version (store_engine*),extstore.c,"static uint64_t _next_version(store_engine *e) {
    return e->version++;
}",151.0,153.0,1.0,1.0,3.0,2,2,1,1,1,1,1,1,0,0,,0,1,2,1,1,uint64_t
505,7464,extstore_get_stats,1,extstore_get_stats,"void extstore_get_stats (void*,extstore_stats*)",extstore.c,"void extstore_get_stats(void *ptr, struct extstore_stats *st) {
    store_engine *e = (store_engine *)ptr;
    STAT_L(e);
    memcpy(st, &e->stats, sizeof(struct extstore_stats));
    STAT_UL(e);

    // grab pages_free/pages_used
    pthread_mutex_lock(&e->mutex);
    st->pages_free = e->page_free;
    st->pages_used = e->page_count - e->page_free;
    pthread_mutex_unlock(&e->mutex);
    st->io_queue = 0;
    for (int x = 0; x < e->io_threadcount; x++) {
        pthread_mutex_lock(&e->io_threads[x].mutex);
        st->io_queue += e->io_threads[x].depth;
        pthread_mutex_unlock(&e->io_threads[x].mutex);
    }
    // calculate bytes_fragmented.
    // note that open and yet-filled pages count against fragmentation.
    st->bytes_fragmented = st->pages_used * e->page_size -
        st->bytes_used;
}",159.0,180.0,1.0,4.0,22.0,46,11,31,5,0,20,2,2,1,0,,0,20,4,2,2,void
506,7591,extstore_get_page_data,1,extstore_get_page_data,"void extstore_get_page_data (void*,extstore_stats*)",extstore.c,"void extstore_get_page_data(void *ptr, struct extstore_stats *st) {
    store_engine *e = (store_engine *)ptr;
    STAT_L(e);
    memcpy(st->page_data, e->stats.page_data,
            sizeof(struct extstore_page_data) * e->page_count);
    STAT_UL(e);
}",182.0,188.0,1.0,4.0,7.0,12,7,10,4,0,5,1,1,0,0,,0,5,4,2,2,void
507,7693,extstore_init,1,extstore_init,"void* extstore_init (extstore_conf_file*,extstore_conf*,extstore_res*)",extstore.c,"void *extstore_init(struct extstore_conf_file *fh, struct extstore_conf *cf,
        enum extstore_res *res) {
    int i;
    struct extstore_conf_file *f = NULL;
    pthread_t thread;

    if (cf->page_size % cf->wbuf_size != 0) {
        *res = EXTSTORE_INIT_BAD_WBUF_SIZE;
        return NULL;
    }
    // Should ensure at least one write buffer per potential page
    if (cf->page_buckets > cf->wbuf_count) {
        *res = EXTSTORE_INIT_NEED_MORE_WBUF;
        return NULL;
    }
    if (cf->page_buckets < 1) {
        *res = EXTSTORE_INIT_NEED_MORE_BUCKETS;
        return NULL;
    }

    // TODO: More intelligence around alignment of flash erasure block sizes
    if (cf->page_size % (1024 * 1024 * 2) != 0 ||
        cf->wbuf_size % (1024 * 1024 * 2) != 0) {
        *res = EXTSTORE_INIT_PAGE_WBUF_ALIGNMENT;
        return NULL;
    }

    store_engine *e = calloc(1, sizeof(store_engine));
    if (e == NULL) {
        *res = EXTSTORE_INIT_OOM;
        return NULL;
    }

    e->pag...",221.0,394.0,1.0,1.0,174.0,238,21,202,34,0,85,21,29,17,2,,0,84,6,3,3,void*
508,8422,extstore_run_maint,1,extstore_run_maint,void extstore_run_maint (void*),extstore.c,"void extstore_run_maint(void *ptr) {
    store_engine *e = (store_engine *)ptr;
    pthread_cond_signal(&e->maint_thread->cond);
}",396.0,399.0,1.0,1.0,4.0,5,4,3,2,3,1,1,1,0,0,,0,1,2,1,1,void
509,8440,_allocate_page,1,_allocate_page,"store_page _allocate_page (store_engine*,unsigned int,unsigned int)",extstore.c,"static store_page *_allocate_page(store_engine *e, unsigned int bucket,
        unsigned int free_bucket) {
    assert(!e->page_buckets[bucket] || e->page_buckets[bucket]->allocated == e->page_size);
    store_page *tmp = NULL;
    // if a specific free bucket was requested, check there first
    if (free_bucket != 0 && e->free_page_buckets[free_bucket] != NULL) {
        assert(e->page_free > 0);
        tmp = e->free_page_buckets[free_bucket];
        e->free_page_buckets[free_bucket] = tmp->next;
    }
    // failing that, try the global list.
    if (tmp == NULL && e->page_freelist != NULL) {
        tmp = e->page_freelist;
        e->page_freelist = tmp->next;
    }
    E_DEBUG(""EXTSTORE: allocating new page\n"");
    // page_freelist can be empty if the only free pages are specialized and
    // we didn't just request one.
    if (e->page_free > 0 && tmp != NULL) {
        tmp->next = e->page_buckets[bucket];
        e->page_buckets[bucket] = tmp;
        tmp->active = true;
  ...",402.0,436.0,1.0,4.0,35.0,63,13,52,7,2,18,5,5,3,1,,0,18,6,3,3,store_page
510,8615,_allocate_wbuf,1,_allocate_wbuf,"void _allocate_wbuf (store_engine*,store_page*)",extstore.c,"static void _allocate_wbuf(store_engine *e, store_page *p) {
    _store_wbuf *wbuf = NULL;
    assert(!p->wbuf);
    pthread_mutex_lock(&e->mutex);
    if (e->wbuf_stack) {
        wbuf = e->wbuf_stack;
        e->wbuf_stack = wbuf->next;
        wbuf->next = 0;
    }
    pthread_mutex_unlock(&e->mutex);
    if (wbuf) {
        wbuf->offset = p->allocated;
        p->allocated += wbuf->size;
        wbuf->free = wbuf->size;
        wbuf->buf_pos = wbuf->buf;
        wbuf->full = false;
        wbuf->flushed = false;

        p->wbuf = wbuf;
    }
}",439.0,459.0,1.0,1.0,21.0,33,5,26,5,1,5,3,3,1,0,,0,5,4,2,2,void
511,8708,_wbuf_cb,1,_wbuf_cb,"void _wbuf_cb (void*,obj_io*,int)",extstore.c,"static void _wbuf_cb(void *ep, obj_io *io, int ret) {
    store_engine *e = (store_engine *)ep;
    store_page *p = &e->pages[io->page_id];
    _store_wbuf *w = (_store_wbuf *) io->data;

    // TODO: Examine return code. Not entirely sure how to handle errors.
    // Naive first-pass should probably cause the page to close/free.
    w->flushed = true;
    pthread_mutex_lock(&p->mutex);
    assert(p->wbuf != NULL && p->wbuf == w);
    assert(p->written == w->offset);
    p->written += w->size;
    p->wbuf = NULL;

    if (p->written == e->page_size)
        p->active = false;

    // return the wbuf
    pthread_mutex_lock(&e->mutex);
    w->next = e->wbuf_stack;
    e->wbuf_stack = w;
    // also return the IO we just used.
    io->next = e->io_stack;
    e->io_stack = io;
    pthread_mutex_unlock(&e->mutex);
    pthread_mutex_unlock(&p->mutex);
}",467.0,493.0,1.0,1.0,27.0,48,9,35,8,0,8,2,2,1,0,,0,8,6,3,3,void
512,8835,_submit_wbuf,1,_submit_wbuf,"void _submit_wbuf (store_engine*,store_page*)",extstore.c,"static void _submit_wbuf(store_engine *e, store_page *p) {
    _store_wbuf *w;
    pthread_mutex_lock(&e->mutex);
    obj_io *io = e->io_stack;
    e->io_stack = io->next;
    pthread_mutex_unlock(&e->mutex);
    w = p->wbuf;

    // zero out the end of the wbuf to allow blind readback of data.
    memset(w->buf + (w->size - w->free), 0, w->free);

    io->next = NULL;
    io->mode = OBJ_IO_WRITE;
    io->page_id = p->id;
    io->data = w;
    io->offset = w->offset;
    io->len = w->size;
    io->buf = w->buf;
    io->cb = _wbuf_cb;

    extstore_submit(e, io);
}",498.0,519.0,1.0,1.0,22.0,37,5,29,6,1,5,1,1,0,1,,0,4,4,2,2,void
513,8937,extstore_write_request,1,extstore_write_request,"int extstore_write_request (void*,unsigned int,unsigned int,obj_io*)",extstore.c,"int extstore_write_request(void *ptr, unsigned int bucket,
        unsigned int free_bucket, obj_io *io) {
    store_engine *e = (store_engine *)ptr;
    store_page *p;
    int ret = -1;
    if (bucket >= e->page_bucketcount)
        return ret;

    pthread_mutex_lock(&e->mutex);
    p = e->page_buckets[bucket];
    if (!p) {
        p = _allocate_page(e, bucket, free_bucket);
    }
    pthread_mutex_unlock(&e->mutex);
    if (!p)
        return ret;

    pthread_mutex_lock(&p->mutex);

    // FIXME: can't null out page_buckets!!!
    // page is full, clear bucket and retry later.
    if (!p->active ||
            ((!p->wbuf || p->wbuf->full) && p->allocated >= e->page_size)) {
        pthread_mutex_unlock(&p->mutex);
        pthread_mutex_lock(&e->mutex);
        _allocate_page(e, bucket, free_bucket);
        pthread_mutex_unlock(&e->mutex);
        return ret;
    }

    // if io won't fit, submit IO for wbuf and find new one.
    if (p->wbuf && p->wbuf->free < io->len && !p->wb...",530.0,581.0,1.0,1.0,52.0,74,11,54,8,0,12,8,8,3,4,,0,9,8,4,4,int
514,9146,extstore_write,1,extstore_write,"void extstore_write (void*,obj_io*)",extstore.c,"void extstore_write(void *ptr, obj_io *io) {
    store_engine *e = (store_engine *)ptr;
    store_page *p = &e->pages[io->page_id];

    io->offset = p->wbuf->offset + (p->wbuf->size - p->wbuf->free);
    io->page_version = p->version;
    p->wbuf->buf_pos += io->len;
    p->wbuf->free -= io->len;
    p->bytes_used += io->len;
    p->obj_count++;
    STAT_L(e);
    e->stats.bytes_written += io->len;
    e->stats.bytes_used += io->len;
    e->stats.objects_written++;
    e->stats.objects_used++;
    STAT_UL(e);

    pthread_mutex_unlock(&p->mutex);
}",586.0,604.0,1.0,4.0,19.0,53,11,29,4,0,7,1,1,0,0,,0,7,4,2,2,void
515,9277,extstore_submit,1,extstore_submit,"int extstore_submit (void*,obj_io*)",extstore.c,"int extstore_submit(void *ptr, obj_io *io) {
    store_engine *e = (store_engine *)ptr;

    unsigned int depth = 0;
    obj_io *tio = io;
    obj_io *tail = NULL;
    while (tio != NULL) {
        tail = tio; // keep updating potential tail.
        depth++;
        tio = tio->next;
    }

    store_io_thread *t = _get_io_thread(e);
    pthread_mutex_lock(&t->mutex);

    t->depth += depth;
    if (t->queue == NULL) {
        t->queue = io;
        t->queue_tail = tail;
    } else {
        // Have to put the *io stack at the end of current queue.
        assert(tail->next == NULL);
        assert(t->queue_tail->next == NULL);
        t->queue_tail->next = io;
        t->queue_tail = tail;
    }

    pthread_mutex_unlock(&t->mutex);

    //pthread_mutex_lock(&t->mutex);
    pthread_cond_signal(&t->cond);
    //pthread_mutex_unlock(&t->mutex);
    return 0;
}",611.0,644.0,1.0,1.0,34.0,25,8,27,8,1,8,3,3,1,1,,0,8,4,2,2,int
516,9388,extstore_delete,1,extstore_delete,"int extstore_delete (void*,unsigned int,uint64_t,unsigned int,unsigned int)",extstore.c,"int extstore_delete(void *ptr, unsigned int page_id, uint64_t page_version,
        unsigned int count, unsigned int bytes) {
    store_engine *e = (store_engine *)ptr;
    // FIXME: validate page_id in bounds
    store_page *p = &e->pages[page_id];
    int ret = 0;

    pthread_mutex_lock(&p->mutex);
    if (!p->closed && p->version == page_version) {
        if (p->bytes_used >= bytes) {
            p->bytes_used -= bytes;
        } else {
            p->bytes_used = 0;
        }

        if (p->obj_count >= count) {
            p->obj_count -= count;
        } else {
            p->obj_count = 0; // caller has bad accounting?
        }
        STAT_L(e);
        e->stats.bytes_used -= bytes;
        e->stats.objects_used -= count;
        STAT_UL(e);

        if (p->obj_count == 0) {
            extstore_run_maint(e);
        }
    } else {
        ret = -1;
    }
    pthread_mutex_unlock(&p->mutex);
    return ret;
}",649.0,682.0,1.0,8.0,34.0,36,11,30,8,0,6,5,8,0,1,,0,5,10,5,5,int
517,9523,extstore_check,1,extstore_check,"int extstore_check (void*,unsigned int,uint64_t)",extstore.c,"int extstore_check(void *ptr, unsigned int page_id, uint64_t page_version) {
    store_engine *e = (store_engine *)ptr;
    store_page *p = &e->pages[page_id];
    int ret = 0;

    pthread_mutex_lock(&p->mutex);
    if (p->version != page_version)
        ret = -1;
    pthread_mutex_unlock(&p->mutex);
    return ret;
}",684.0,694.0,1.0,1.0,11.0,15,7,12,6,0,1,2,2,0,0,,0,1,6,3,3,int
518,9572,extstore_close_page,1,extstore_close_page,"void extstore_close_page (void*,unsigned int,uint64_t)",extstore.c,"void extstore_close_page(void *ptr, unsigned int page_id, uint64_t page_version) {
    store_engine *e = (store_engine *)ptr;
    store_page *p = &e->pages[page_id];

    pthread_mutex_lock(&p->mutex);
    if (!p->closed && p->version == page_version) {
        p->closed = true;
        extstore_run_maint(e);
    }
    pthread_mutex_unlock(&p->mutex);
}",697.0,707.0,1.0,1.0,11.0,17,8,13,6,0,2,2,2,0,1,,0,1,6,3,3,void
519,10102,_free_page,1,_free_page,"void _free_page (store_engine*,store_page*)",extstore.c,"static void _free_page(store_engine *e, store_page *p) {
    store_page *tmp = NULL;
    store_page *prev = NULL;
    E_DEBUG(""EXTSTORE: freeing page %u\n"", p->id);
    STAT_L(e);
    e->stats.objects_used -= p->obj_count;
    e->stats.bytes_used -= p->bytes_used;
    e->stats.page_reclaims++;
    STAT_UL(e);
    pthread_mutex_lock(&e->mutex);
    // unlink page from bucket list
    tmp = e->page_buckets[p->bucket];
    while (tmp) {
        if (tmp == p) {
            if (prev) {
                prev->next = tmp->next;
            } else {
                e->page_buckets[p->bucket] = tmp->next;
            }
            tmp->next = NULL;
            break;
        }
        prev = tmp;
        tmp = tmp->next;
    }
    // reset most values
    p->version = 0;
    p->obj_count = 0;
    p->bytes_used = 0;
    p->allocated = 0;
    p->written = 0;
    p->bucket = 0;
    p->active = false;
    p->closed = false;
    p->free = true;
    // add to page stack
    // TODO: free_page_bucke...",852.0,898.0,1.0,4.0,47.0,65,9,50,7,0,11,6,8,0,0,,0,11,4,2,2,void
520,10902,hash_init,1,hash_init,int hash_init (hashfunc_type),hash.c,"int hash_init(enum hashfunc_type type) {
    switch(type) {
        case JENKINS_HASH:
            hash = jenkins_hash;
            settings.hash_algorithm = ""jenkins"";
            break;
        case MURMUR3_HASH:
            hash = MurmurHash3_x86_32;
            settings.hash_algorithm = ""murmur3"";
            break;
        case XXH3_HASH:
            hash = XXH3_hash;
            settings.hash_algorithm = ""xxh3"";
            break;
        default:
            return -1;
    }
    return 0;
}",15.0,33.0,1.0,1.0,19.0,10,3,12,8,1,6,5,2,0,0,,0,6,2,1,1,int
521,11020,item_link_q,1,item_link_q,void item_link_q (item*),items.c,"static void item_link_q(item *it) {
    pthread_mutex_lock(&lru_locks[it->slabs_clsid]);
    do_item_link_q(it);
    pthread_mutex_unlock(&lru_locks[it->slabs_clsid]);
}",448.0,452.0,1.0,1.0,5.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,void
522,11025,item_unlink_q,1,item_unlink_q,void item_unlink_q (item*),items.c,"static void item_unlink_q(item *it) {
    pthread_mutex_lock(&lru_locks[it->slabs_clsid]);
    do_item_unlink_q(it);
    pthread_mutex_unlock(&lru_locks[it->slabs_clsid]);
}",493.0,497.0,1.0,1.0,5.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,void
523,11130,item_stats_reset,1,item_stats_reset,void item_stats_reset (void),items.c,"void item_stats_reset(void) {
    int i;
    for (i = 0; i < LARGEST_ID; i++) {
        pthread_mutex_lock(&lru_locks[i]);
        memset(&itemstats[i], 0, sizeof(itemstats_t));
        pthread_mutex_unlock(&lru_locks[i]);
    }
}",71.0,78.0,1.0,20.0,8.0,9,5,9,4,1,2,2,2,0,0,,0,2,2,1,1,void
524,11167,do_item_stats_add_crawl,1,do_item_stats_add_crawl,"void do_item_stats_add_crawl (int,uint64_t,uint64_t,uint64_t)",items.c,"void do_item_stats_add_crawl(const int i, const uint64_t reclaimed,
        const uint64_t unfetched, const uint64_t checked) {
    itemstats[i].crawler_reclaimed += reclaimed;
    itemstats[i].expired_unfetched += unfetched;
    itemstats[i].crawler_items_checked += checked;
}",81.0,86.0,1.0,1.0,6.0,9,3,9,5,1,3,1,1,0,0,,0,3,8,4,4,void
525,11228,lru_total_bumps_dropped,1,lru_total_bumps_dropped,uint64_t lru_total_bumps_dropped (void),items.c,"static uint64_t lru_total_bumps_dropped(void) {
    uint64_t total = 0;
    lru_bump_buf *b;
    pthread_mutex_lock(&bump_buf_lock);
    for (b = bump_buf_head; b != NULL; b=b->next) {
        pthread_mutex_lock(&b->mutex);
        total += b->dropped;
        pthread_mutex_unlock(&b->mutex);
    }
    pthread_mutex_unlock(&bump_buf_lock);
    return total;
}",1376.0,1387.0,1.0,1.0,12.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,uint64_t
526,11233,get_cas_id,1,get_cas_id,uint64_t get_cas_id (void),items.c,"uint64_t get_cas_id(void) {
    pthread_mutex_lock(&cas_id_lock);
    uint64_t next_id = ++cas_id;
    pthread_mutex_unlock(&cas_id_lock);
    return next_id;
}",112.0,117.0,1.0,1.0,6.0,4,3,5,3,6,3,1,1,0,0,,0,3,2,1,1,uint64_t
527,11251,set_cas_id,1,set_cas_id,void set_cas_id (uint64_t),items.c,"void set_cas_id(uint64_t new_cas) {
    pthread_mutex_lock(&cas_id_lock);
    cas_id = new_cas;
    pthread_mutex_unlock(&cas_id_lock);
}",119.0,123.0,1.0,1.0,5.0,3,2,4,3,0,3,1,1,0,0,,0,3,2,1,1,void
528,11265,item_is_flushed,1,item_is_flushed,int item_is_flushed (item*),items.c,"int item_is_flushed(item *it) {
    rel_time_t oldest_live = settings.oldest_live;
    uint64_t cas = ITEM_get_cas(it);
    uint64_t oldest_cas = settings.oldest_cas;
    if (oldest_live == 0 || oldest_live > current_time)
        return 0;
    if ((it->time <= oldest_live)
            || (oldest_cas != 0 && cas != 0 && cas < oldest_cas)) {
        return 1;
    }
    return 0;
}",125.0,136.0,1.0,19.0,12.0,22,13,17,6,3,2,3,3,0,0,,0,2,2,1,1,int
529,11336,do_get_lru_size,1,do_get_lru_size,unsigned int do_get_lru_size (uint32_t),items.c,"unsigned int do_get_lru_size(uint32_t id) {
    return sizes[id];
}",139.0,141.0,1.0,1.0,3.0,1,1,2,2,1,1,1,1,0,0,,0,1,2,1,1,unsigned int
530,11345,item_make_header,1,item_make_header,"size_t item_make_header (uint8_t,unsigned int,int,char*,uint8_t*)",items.c,"static size_t item_make_header(const uint8_t nkey, const unsigned int flags, const int nbytes,
                     char *suffix, uint8_t *nsuffix) {
    if (flags == 0) {
        *nsuffix = 0;
    } else {
        *nsuffix = sizeof(flags);
    }
    return sizeof(item) + nkey + *nsuffix + nbytes;
}",165.0,173.0,1.0,1.0,9.0,8,5,6,5,2,0,2,2,0,0,,0,0,10,5,5,size_t
531,11380,do_item_alloc_pull,1,do_item_alloc_pull,"item do_item_alloc_pull (size_t,unsigned int)",items.c,"item *do_item_alloc_pull(const size_t ntotal, const unsigned int id) {
    item *it = NULL;
    int i;
    /* If no memory is available, attempt a direct LRU juggle/eviction */
    /* This is a race in order to simplify lru_pull_tail; in cases where
     * locked items are on the tail, you want them to fall out and cause
     * occasional OOM's, rather than internally work around them.
     * This also gives one fewer code path for slab alloc/free
     */
    for (i = 0; i < 10; i++) {
        /* Try to reclaim memory first */
        if (!settings.lru_segmented) {
            lru_pull_tail(id, COLD_LRU, 0, 0, 0, NULL);
        }
        it = slabs_alloc(ntotal, id, 0);

        if (it == NULL) {
            // We send '0' in for ""total_bytes"" as this routine is always
            // pulling to evict, or forcing HOT -> COLD migration.
            // As of this writing, total_bytes isn't at all used with COLD_LRU.
            if (lru_pull_tail(id, COLD_LRU, 0, LRU_PULL_EVICT, 0, NULL...",175.0,214.0,1.0,30.0,40.0,17,10,26,8,2,7,7,14,3,4,,0,5,4,2,2,item
532,11487,do_item_alloc_chunk,1,do_item_alloc_chunk,"item_chunk do_item_alloc_chunk (item_chunk*,size_t)",items.c,"item_chunk *do_item_alloc_chunk(item_chunk *ch, const size_t bytes_remain) {
    // TODO: Should be a cleaner way of finding real size with slabber calls
    size_t size = bytes_remain + sizeof(item_chunk);
    if (size > settings.slab_chunk_size_max)
        size = settings.slab_chunk_size_max;
    unsigned int id = slabs_clsid(size);

    item_chunk *nch = (item_chunk *) do_item_alloc_pull(size, id);
    if (nch == NULL) {
        // The final chunk in a large item will attempt to be a more
        // appropriately sized chunk to minimize memory overhead. However, if
        // there's no memory available in the lower slab classes we fail the
        // SET. In these cases as a fallback we ensure we attempt to evict a
        // max-size item and reuse a large chunk.
        if (size == settings.slab_chunk_size_max) {
            return NULL;
        } else {
            size = settings.slab_chunk_size_max;
            id = slabs_clsid(size);
            nch = (item_chunk *) do_it...",221.0,260.0,1.0,21.0,40.0,31,9,32,8,2,7,4,5,2,4,,0,5,4,2,2,item_chunk
533,11615,do_item_alloc,1,do_item_alloc,"item do_item_alloc (char*,size_t,unsigned int,rel_time_t,int)",items.c,"item *do_item_alloc(char *key, const size_t nkey, const unsigned int flags,
                    const rel_time_t exptime, const int nbytes) {
    uint8_t nsuffix;
    item *it = NULL;
    char suffix[40];
    // Avoid potential underflows.
    if (nbytes < 2)
        return 0;

    size_t ntotal = item_make_header(nkey + 1, flags, nbytes, suffix, &nsuffix);
    if (settings.use_cas) {
        ntotal += sizeof(uint64_t);
    }

    unsigned int id = slabs_clsid(ntotal);
    unsigned int hdr_id = 0;
    if (id == 0)
        return 0;

    /* This is a large item. Allocate a header object now, lazily allocate
     *  chunks while reading the upload.
     */
    if (ntotal > settings.slab_chunk_size_max) {
        /* We still link this item into the LRU for the larger slab class, but
         * we're pulling a header from an entirely different slab class. The
         * free routines handle large items specifically.
         */
        int htotal = nkey + 1 + nsuffix + sizeof(item) + si...",262.0,361.0,1.0,28.0,100.0,119,20,97,22,1,11,11,13,5,4,,0,11,10,5,5,item
534,12006,item_free,1,item_free,void item_free (item*),items.c,"void item_free(item *it) {
    size_t ntotal = ITEM_ntotal(it);
    unsigned int clsid;
    assert((it->it_flags & ITEM_LINKED) == 0);
    assert(it != heads[it->slabs_clsid]);
    assert(it != tails[it->slabs_clsid]);
    assert(it->refcount == 0);

    /* so slab size changer can tell later if item is already free or not */
    clsid = ITEM_clsid(it);
    DEBUG_REFCNT(it, 'F');
    slabs_free(it, ntotal, clsid);
}",363.0,375.0,1.0,20.0,13.0,33,11,23,8,1,3,1,1,0,1,,0,2,2,1,1,void
535,12103,item_size_ok,1,item_size_ok,"bool item_size_ok (size_t,int,int)",items.c,"bool item_size_ok(const size_t nkey, const int flags, const int nbytes) {
    char prefix[40];
    uint8_t nsuffix;
    if (nbytes < 2)
        return false;

    size_t ntotal = item_make_header(nkey + 1, flags, nbytes,
                                     prefix, &nsuffix);
    if (settings.use_cas) {
        ntotal += sizeof(uint64_t);
    }

    return slabs_clsid(ntotal) != 0;
}",381.0,394.0,1.0,1.0,14.0,8,8,12,9,2,3,3,3,1,2,,0,2,6,3,3,bool
536,12145,do_item_link_fixup,1,do_item_link_fixup,void do_item_link_fixup (item*),items.c,"void do_item_link_fixup(item *it) {
    item **head, **tail;
    int ntotal = ITEM_ntotal(it);
    uint32_t hv = hash(ITEM_key(it), it->nkey);
    assoc_insert(it, hv);

    head = &heads[it->slabs_clsid];
    tail = &tails[it->slabs_clsid];
    if (it->prev == 0 && *head == 0) *head = it;
    if (it->next == 0 && *tail == 0) *tail = it;
    sizes[it->slabs_clsid]++;
    sizes_bytes[it->slabs_clsid] += ntotal;

    STATS_LOCK();
    stats_state.curr_bytes += ntotal;
    stats_state.curr_items += 1;
    stats.total_items += 1;
    STATS_UNLOCK();

    item_stats_sizes_add(it);

    return;
}",397.0,419.0,1.0,17.0,23.0,61,15,41,14,1,11,3,3,0,2,,0,7,2,1,1,void
537,12300,do_item_link_q,1,do_item_link_q,void do_item_link_q (item*),items.c,"static void do_item_link_q(item *it) { /* item is the new head */
    item **head, **tail;
    assert((it->it_flags & ITEM_SLABBED) == 0);

    head = &heads[it->slabs_clsid];
    tail = &tails[it->slabs_clsid];
    assert(it != *head);
    assert((*head && *tail) || (*head == 0 && *tail == 0));
    it->prev = 0;
    it->next = *head;
    if (it->next) it->next->prev = it;
    *head = it;
    if (*tail == 0) *tail = it;
    sizes[it->slabs_clsid]++;
#ifdef EXTSTORE
    if (it->it_flags & ITEM_HDR) {
        sizes_bytes[it->slabs_clsid] += (ITEM_ntotal(it) - it->nbytes) + sizeof(item_hdr);
    } else {
        sizes_bytes[it->slabs_clsid] += ITEM_ntotal(it);
    }
#else
    sizes_bytes[it->slabs_clsid] += ITEM_ntotal(it);
#endif

    return;
}",421.0,446.0,1.0,27.0,26.0,59,15,36,10,2,4,3,3,0,0,,0,4,2,1,1,void
538,12460,item_link_q_warm,1,item_link_q_warm,void item_link_q_warm (item*),items.c,"static void item_link_q_warm(item *it) {
    pthread_mutex_lock(&lru_locks[it->slabs_clsid]);
    do_item_link_q(it);
    itemstats[it->slabs_clsid].moves_to_warm++;
    pthread_mutex_unlock(&lru_locks[it->slabs_clsid]);
}",454.0,459.0,1.0,1.0,6.0,10,5,7,3,1,2,1,1,0,1,,0,1,2,1,1,void
539,12489,do_item_unlink_q,1,do_item_unlink_q,void do_item_unlink_q (item*),items.c,"static void do_item_unlink_q(item *it) {
    item **head, **tail;
    head = &heads[it->slabs_clsid];
    tail = &tails[it->slabs_clsid];

    if (*head == it) {
        assert(it->prev == 0);
        *head = it->next;
    }
    if (*tail == it) {
        assert(it->next == 0);
        *tail = it->prev;
    }
    assert(it->next != it);
    assert(it->prev != it);

    if (it->next) it->next->prev = it->prev;
    if (it->prev) it->prev->next = it->next;
    sizes[it->slabs_clsid]--;
#ifdef EXTSTORE
    if (it->it_flags & ITEM_HDR) {
        sizes_bytes[it->slabs_clsid] -= (ITEM_ntotal(it) - it->nbytes) + sizeof(item_hdr);
    } else {
        sizes_bytes[it->slabs_clsid] -= ITEM_ntotal(it);
    }
#else
    sizes_bytes[it->slabs_clsid] -= ITEM_ntotal(it);
#endif

    return;
}",461.0,491.0,1.0,36.0,31.0,58,13,38,10,2,4,5,5,0,0,,0,4,2,1,1,void
540,12657,do_item_link,1,do_item_link,"int do_item_link (item*,uint32_t)",items.c,"int do_item_link(item *it, const uint32_t hv) {
    MEMCACHED_ITEM_LINK(ITEM_key(it), it->nkey, it->nbytes);
    assert((it->it_flags & (ITEM_LINKED|ITEM_SLABBED)) == 0);
    it->it_flags |= ITEM_LINKED;
    it->time = current_time;

    STATS_LOCK();
    stats_state.curr_bytes += ITEM_ntotal(it);
    stats_state.curr_items += 1;
    stats.total_items += 1;
    STATS_UNLOCK();

    /* Allocate a new CAS ID on link. */
    ITEM_set_cas(it, (settings.use_cas) ? get_cas_id() : 0);
    assoc_insert(it, hv);
    item_link_q(it);
    refcount_incr(it);
    item_stats_sizes_add(it);

    return 1;
}",499.0,519.0,1.0,4.0,21.0,38,11,25,9,2,10,1,1,0,4,,0,5,4,2,2,int
541,12778,do_item_unlink,1,do_item_unlink,"void do_item_unlink (item*,uint32_t)",items.c,"void do_item_unlink(item *it, const uint32_t hv) {
    MEMCACHED_ITEM_UNLINK(ITEM_key(it), it->nkey, it->nbytes);
    if ((it->it_flags & ITEM_LINKED) != 0) {
        it->it_flags &= ~ITEM_LINKED;
        STATS_LOCK();
        stats_state.curr_bytes -= ITEM_ntotal(it);
        stats_state.curr_items -= 1;
        STATS_UNLOCK();
        item_stats_sizes_remove(it);
        assoc_delete(ITEM_key(it), it->nkey, hv);
        item_unlink_q(it);
        do_item_remove(it);
    }
}",521.0,534.0,1.0,4.0,14.0,34,11,21,6,4,8,2,2,0,4,,0,2,4,2,2,void
542,12879,do_item_unlink_nolock,1,do_item_unlink_nolock,"void do_item_unlink_nolock (item*,uint32_t)",items.c,"void do_item_unlink_nolock(item *it, const uint32_t hv) {
    MEMCACHED_ITEM_UNLINK(ITEM_key(it), it->nkey, it->nbytes);
    if ((it->it_flags & ITEM_LINKED) != 0) {
        it->it_flags &= ~ITEM_LINKED;
        STATS_LOCK();
        stats_state.curr_bytes -= ITEM_ntotal(it);
        stats_state.curr_items -= 1;
        STATS_UNLOCK();
        item_stats_sizes_remove(it);
        assoc_delete(ITEM_key(it), it->nkey, hv);
        do_item_unlink_q(it);
        do_item_remove(it);
    }
}",537.0,550.0,1.0,4.0,14.0,34,11,21,6,3,8,2,2,0,4,,0,2,4,2,2,void
543,12980,do_item_remove,1,do_item_remove,void do_item_remove (item*),items.c,"void do_item_remove(item *it) {
    MEMCACHED_ITEM_REMOVE(ITEM_key(it), it->nkey, it->nbytes);
    assert((it->it_flags & ITEM_SLABBED) == 0);
    assert(it->refcount > 0);

    if (refcount_decr(it) == 0) {
        item_free(it);
    }
}",552.0,560.0,1.0,4.0,9.0,8,5,5,1,20,1,2,2,0,1,,0,0,2,1,1,void
544,13014,do_item_update,1,do_item_update,void do_item_update (item*),items.c,"void do_item_update(item *it) {
    MEMCACHED_ITEM_UPDATE(ITEM_key(it), it->nkey, it->nbytes);

    /* Hits to COLD_LRU immediately move to WARM. */
    if (settings.lru_segmented) {
        assert((it->it_flags & ITEM_SLABBED) == 0);
        if ((it->it_flags & ITEM_LINKED) != 0) {
            if (ITEM_lruid(it) == COLD_LRU && (it->it_flags & ITEM_ACTIVE)) {
                it->time = current_time;
                item_unlink_q(it);
                it->slabs_clsid = ITEM_clsid(it);
                it->slabs_clsid |= WARM_LRU;
                it->it_flags &= ~ITEM_ACTIVE;
                item_link_q_warm(it);
            } else {
                it->time = current_time;
            }
        }
    } else if (it->time < current_time - ITEM_UPDATE_INTERVAL) {
        assert((it->it_flags & ITEM_SLABBED) == 0);

        if ((it->it_flags & ITEM_LINKED) != 0) {
            it->time = current_time;
            item_unlink_q(it);
            item_link_q(it);
        }
    }
}",563.0,590.0,1.0,4.0,28.0,25,9,15,3,3,3,4,7,1,2,,0,1,2,1,1,void
545,13158,do_item_replace,1,do_item_replace,"int do_item_replace (item*,item*,uint32_t)",items.c,"int do_item_replace(item *it, item *new_it, const uint32_t hv) {
    MEMCACHED_ITEM_REPLACE(ITEM_key(it), it->nkey, it->nbytes,
                           ITEM_key(new_it), new_it->nkey, new_it->nbytes);
    assert((it->it_flags & ITEM_SLABBED) == 0);

    do_item_unlink(it, hv);
    return do_item_link(new_it, hv);
}",592.0,599.0,1.0,4.0,8.0,3,3,5,3,1,2,1,1,0,2,,0,0,6,3,3,int
546,13182,item_cachedump,1,item_cachedump,"char* item_cachedump (unsigned int,unsigned int,unsigned int*)",items.c,"char *item_cachedump(const unsigned int slabs_clsid, const unsigned int limit, unsigned int *bytes) {
    unsigned int memlimit = 2 * 1024 * 1024;   /* 2MB max response size */
    char *buffer;
    unsigned int bufcurr;
    item *it;
    unsigned int len;
    unsigned int shown = 0;
    char key_temp[KEY_MAX_LENGTH + 1];
    char temp[512];
    unsigned int id = slabs_clsid;
    id |= COLD_LRU;

    pthread_mutex_lock(&lru_locks[id]);
    it = heads[id];

    buffer = malloc((size_t)memlimit);
    if (buffer == 0) {
        pthread_mutex_unlock(&lru_locks[id]);
        return NULL;
    }
    bufcurr = 0;

    while (it != NULL && (limit == 0 || shown < limit)) {
        assert(it->nkey <= KEY_MAX_LENGTH);
        // protect from printing binary keys.
        if ((it->nbytes == 0 && it->nkey == 0) || (it->it_flags & ITEM_KEY_BINARY)) {
            it = it->next;
            continue;
        }
        /* Copy the key since it may not be null-terminated in the struct */
        strnc...",608.0,658.0,1.0,18.0,51.0,68,21,64,17,0,1,7,7,0,0,,0,1,6,3,3,char*
547,13399,fill_item_stats_automove,1,fill_item_stats_automove,void fill_item_stats_automove (item_stats_automove*),items.c,"void fill_item_stats_automove(item_stats_automove *am) {
    int n;
    for (n = 0; n < MAX_NUMBER_OF_SLAB_CLASSES; n++) {
        item_stats_automove *cur = &am[n];

        // outofmemory records into HOT
        int i = n | HOT_LRU;
        pthread_mutex_lock(&lru_locks[i]);
        cur->outofmemory = itemstats[i].outofmemory;
        pthread_mutex_unlock(&lru_locks[i]);

        // evictions and tail age are from COLD
        i = n | COLD_LRU;
        pthread_mutex_lock(&lru_locks[i]);
        cur->evicted = itemstats[i].evicted;
        if (!tails[i]) {
            cur->age = 0;
        } else if (tails[i]->nbytes == 0 && tails[i]->nkey == 0 && tails[i]->it_flags == 1) {
            /* it's a crawler, check previous entry */
            if (tails[i]->prev) {
               cur->age = current_time - tails[i]->prev->time;
            } else {
               cur->age = 0;
            }
        } else {
            cur->age = current_time - tails[i]->time;
        }
        pthread...",663.0,692.0,1.0,20.0,30.0,30,9,26,7,4,6,3,4,1,0,,0,6,2,1,1,void
548,13558,item_stats_totals,1,item_stats_totals,"void item_stats_totals (ADD_STAT,void*)",items.c,"void item_stats_totals(ADD_STAT add_stats, void *c) {
    itemstats_t totals;
    memset(&totals, 0, sizeof(itemstats_t));
    int n;
    for (n = 0; n < MAX_NUMBER_OF_SLAB_CLASSES; n++) {
        int x;
        int i;
        for (x = 0; x < 4; x++) {
            i = n | lru_type_map[x];
            pthread_mutex_lock(&lru_locks[i]);
            totals.expired_unfetched += itemstats[i].expired_unfetched;
            totals.evicted_unfetched += itemstats[i].evicted_unfetched;
            totals.evicted_active += itemstats[i].evicted_active;
            totals.evicted += itemstats[i].evicted;
            totals.reclaimed += itemstats[i].reclaimed;
            totals.crawler_reclaimed += itemstats[i].crawler_reclaimed;
            totals.crawler_items_checked += itemstats[i].crawler_items_checked;
            totals.lrutail_reflocked += itemstats[i].lrutail_reflocked;
            totals.moves_to_cold += itemstats[i].moves_to_cold;
            totals.moves_to_warm += itemstats[i].moves...",694.0,749.0,1.0,20.0,56.0,89,10,90,11,1,54,5,6,2,14,,0,41,4,2,2,void
549,13915,item_stats,1,item_stats,"void item_stats (ADD_STAT,void*)",items.c,"void item_stats(ADD_STAT add_stats, void *c) {
    struct thread_stats thread_stats;
    threadlocal_stats_aggregate(&thread_stats);
    itemstats_t totals;
    int n;
    for (n = 0; n < MAX_NUMBER_OF_SLAB_CLASSES; n++) {
        memset(&totals, 0, sizeof(itemstats_t));
        int x;
        int i;
        unsigned int size = 0;
        unsigned int age  = 0;
        unsigned int age_hot = 0;
        unsigned int age_warm = 0;
        unsigned int lru_size_map[4];
        const char *fmt = ""items:%d:%s"";
        char key_str[STAT_KEY_LEN];
        char val_str[STAT_VAL_LEN];
        int klen = 0, vlen = 0;
        for (x = 0; x < 4; x++) {
            i = n | lru_type_map[x];
            pthread_mutex_lock(&lru_locks[i]);
            totals.evicted += itemstats[i].evicted;
            totals.evicted_nonzero += itemstats[i].evicted_nonzero;
            totals.outofmemory += itemstats[i].outofmemory;
            totals.tailrepairs += itemstats[i].tailrepairs;
            totals.recl...",751.0,882.0,1.0,20.0,132.0,230,15,519,26,0,77,16,24,8,1,,0,76,4,2,2,void
550,15194,item_stats_sizes_status,1,item_stats_sizes_status,bool item_stats_sizes_status (void),items.c,"bool item_stats_sizes_status(void) {
    bool ret = false;
    mutex_lock(&stats_sizes_lock);
    if (stats_sizes_hist != NULL)
        ret = true;
    mutex_unlock(&stats_sizes_lock);
    return ret;
}",884.0,891.0,1.0,4.0,8.0,7,3,11,6,1,5,2,2,1,0,,0,5,2,1,1,bool
551,15227,item_stats_sizes_init,1,item_stats_sizes_init,void item_stats_sizes_init (void),items.c,"void item_stats_sizes_init(void) {
    if (stats_sizes_hist != NULL)
        return;
    stats_sizes_buckets = settings.item_size_max / 32 + 1;
    stats_sizes_hist = calloc(stats_sizes_buckets, sizeof(int));
    stats_sizes_cas_min = (settings.use_cas) ? get_cas_id() : 0;
}",893.0,899.0,1.0,1.0,7.0,10,7,9,6,1,8,2,2,1,1,,0,8,2,1,1,void
552,15261,item_stats_sizes_enable,1,item_stats_sizes_enable,"void item_stats_sizes_enable (ADD_STAT,void*)",items.c,"void item_stats_sizes_enable(ADD_STAT add_stats, void *c) {
    mutex_lock(&stats_sizes_lock);
    if (!settings.use_cas) {
        APPEND_STAT(""sizes_status"", ""error"", """");
        APPEND_STAT(""sizes_error"", ""cas_support_disabled"", """");
    } else if (stats_sizes_hist == NULL) {
        item_stats_sizes_init();
        if (stats_sizes_hist != NULL) {
            APPEND_STAT(""sizes_status"", ""enabled"", """");
        } else {
            APPEND_STAT(""sizes_status"", ""error"", """");
            APPEND_STAT(""sizes_error"", ""no_memory"", """");
        }
    } else {
        APPEND_STAT(""sizes_status"", ""enabled"", """");
    }
    mutex_unlock(&stats_sizes_lock);
}",901.0,918.0,1.0,4.0,18.0,6,3,9,4,0,7,2,2,1,2,,0,5,4,2,2,void
553,15370,item_stats_sizes_disable,1,item_stats_sizes_disable,"void item_stats_sizes_disable (ADD_STAT,void*)",items.c,"void item_stats_sizes_disable(ADD_STAT add_stats, void *c) {
    mutex_lock(&stats_sizes_lock);
    if (stats_sizes_hist != NULL) {
        free(stats_sizes_hist);
        stats_sizes_hist = NULL;
    }
    APPEND_STAT(""sizes_status"", ""disabled"", """");
    mutex_unlock(&stats_sizes_lock);
}",920.0,928.0,1.0,4.0,9.0,6,3,11,5,0,8,2,2,1,1,,0,7,4,2,2,void
554,15411,item_stats_sizes_add,1,item_stats_sizes_add,void item_stats_sizes_add (item*),items.c,"void item_stats_sizes_add(item *it) {
    if (stats_sizes_hist == NULL || stats_sizes_cas_min > ITEM_get_cas(it))
        return;
    int ntotal = ITEM_ntotal(it);
    int bucket = ntotal / 32;
    if ((ntotal % 32) != 0) bucket++;
    if (bucket < stats_sizes_buckets) stats_sizes_hist[bucket]++;
}",930.0,937.0,1.0,58.0,8.0,34,16,23,10,3,4,4,4,3,0,,0,4,2,1,1,void
555,15504,item_stats_sizes_remove,1,item_stats_sizes_remove,void item_stats_sizes_remove (item*),items.c,"void item_stats_sizes_remove(item *it) {
    if (stats_sizes_hist == NULL || stats_sizes_cas_min > ITEM_get_cas(it))
        return;
    int ntotal = ITEM_ntotal(it);
    int bucket = ntotal / 32;
    if ((ntotal % 32) != 0) bucket++;
    if (bucket < stats_sizes_buckets) stats_sizes_hist[bucket]--;
}",942.0,949.0,1.0,58.0,8.0,34,17,23,10,3,4,4,4,3,0,,0,4,2,1,1,void
556,15597,item_stats_sizes,1,item_stats_sizes,"void item_stats_sizes (ADD_STAT,void*)",items.c,"void item_stats_sizes(ADD_STAT add_stats, void *c) {
    mutex_lock(&stats_sizes_lock);

    if (stats_sizes_hist != NULL) {
        int i;
        for (i = 0; i < stats_sizes_buckets; i++) {
            if (stats_sizes_hist[i] != 0) {
                char key[12];
                snprintf(key, sizeof(key), ""%d"", i * 32);
                APPEND_STAT(key, ""%u"", stats_sizes_hist[i]);
            }
        }
    } else {
        APPEND_STAT(""sizes_status"", ""disabled"", """");
    }

    add_stats(NULL, 0, NULL, 0, c);
    mutex_unlock(&stats_sizes_lock);
}",957.0,975.0,1.0,4.0,19.0,13,7,25,8,0,10,4,7,3,1,,0,9,4,2,2,void
557,15684,do_item_get,1,do_item_get,"item do_item_get (char*,size_t,uint32_t,conn*,bool)",items.c,"item *do_item_get(const char *key, const size_t nkey, const uint32_t hv, conn *c, const bool do_update) {
    item *it = assoc_find(key, nkey, hv);
    if (it != NULL) {
        refcount_incr(it);
        /* Optimization for slab reassignment. prevents popular items from
         * jamming in busy wait. Can only do this here to satisfy lock order
         * of item_lock, slabs_lock. */
        /* This was made unsafe by removal of the cache_lock:
         * slab_rebalance_signal and slab_rebal.* are modified in a separate
         * thread under slabs_lock. If slab_rebalance_signal = 1, slab_start =
         * NULL (0), but slab_end is still equal to some value, this would end
         * up unlinking every item fetched.
         * This is either an acceptable loss, or if slab_rebalance_signal is
         * true, slab_start/slab_end should be put behind the slabs_lock.
         * Which would cause a huge potential slowdown.
         * Could also use a specific lock for slab_rebal.* a...",978.0,1058.0,1.0,8.0,81.0,52,16,57,14,3,15,9,14,4,5,,0,12,10,5,5,item
558,15971,do_item_bump,1,do_item_bump,"void do_item_bump (conn*,item*,uint32_t)",items.c,"void do_item_bump(conn *c, item *it, const uint32_t hv) {
    /* We update the hit markers only during fetches.
     * An item needs to be hit twice overall to be considered
     * ACTIVE, but only needs a single hit to maintain activity
     * afterward.
     * FETCHED tells if an item has ever been active.
     */
    if (settings.lru_segmented) {
        if ((it->it_flags & ITEM_ACTIVE) == 0) {
            if ((it->it_flags & ITEM_FETCHED) == 0) {
                it->it_flags |= ITEM_FETCHED;
            } else {
                it->it_flags |= ITEM_ACTIVE;
                if (ITEM_lruid(it) != COLD_LRU) {
                    it->time = current_time; // only need to bump time.
                } else if (!lru_bump_async(c->thread->lru_bump_buf, it, hv)) {
                    // add flag before async bump to avoid race.
                    it->it_flags &= ~ITEM_ACTIVE;
                }
            }
        }
    } else {
        it->it_flags |= ITEM_FETCHED;
        do_item_updat...",1063.0,1088.0,1.0,28.0,26.0,8,4,4,2,1,1,4,7,1,0,,0,1,6,3,3,void
559,16074,do_item_touch,1,do_item_touch,"item do_item_touch (char*,size_t,uint32_t,uint32_t,conn*)",items.c,"item *do_item_touch(const char *key, size_t nkey, uint32_t exptime,
                    const uint32_t hv, conn *c) {
    item *it = do_item_get(key, nkey, hv, c, DO_UPDATE);
    if (it != NULL) {
        it->exptime = exptime;
    }
    return it;
}",1090.0,1097.0,1.0,45.0,8.0,4,3,11,8,0,1,2,2,0,1,,0,1,10,5,5,item
560,16106,lru_pull_tail,1,lru_pull_tail,"int lru_pull_tail (int,int,uint64_t,uint8_t,rel_time_t,lru_pull_tail_return*)",items.c,"int lru_pull_tail(const int orig_id, const int cur_lru,
        const uint64_t total_bytes, const uint8_t flags, const rel_time_t max_age,
        struct lru_pull_tail_return *ret_it) {
    item *it = NULL;
    int id = orig_id;
    int removed = 0;
    if (id == 0)
        return 0;

    int tries = 5;
    item *search;
    item *next_it;
    void *hold_lock = NULL;
    unsigned int move_to_lru = 0;
    uint64_t limit = 0;

    id |= cur_lru;
    pthread_mutex_lock(&lru_locks[id]);
    search = tails[id];
    /* We walk up *only* for locked items, and if bottom is expired. */
    for (; tries > 0 && search != NULL; tries--, search=next_it) {
        /* we might relink search mid-loop, so search->prev isn't reliable */
        next_it = search->prev;
        if (search->nbytes == 0 && search->nkey == 0 && search->it_flags == 1) {
            /* We are a crawler, ignore it. */
            if (flags & LRU_PULL_CRAWL_BLOCKS) {
                pthread_mutex_unlock(&lru_locks[id]);
     ...",1103.0,1277.0,1.0,24.0,175.0,146,24,141,25,7,34,33,62,6,17,,0,19,12,6,6,int
561,16753,lru_bump_buf_link_q,1,lru_bump_buf_link_q,void lru_bump_buf_link_q (lru_bump_buf*),items.c,"static void lru_bump_buf_link_q(lru_bump_buf *b) {
    pthread_mutex_lock(&bump_buf_lock);
    assert(b != bump_buf_head);

    b->prev = 0;
    b->next = bump_buf_head;
    if (b->next) b->next->prev = b;
    bump_buf_head = b;
    if (bump_buf_tail == 0) bump_buf_tail = b;
    pthread_mutex_unlock(&bump_buf_lock);
    return;
}",1281.0,1292.0,1.0,1.0,12.0,14,5,15,4,1,7,3,3,1,0,,0,7,2,1,1,void
562,16802,item_lru_bump_buf_create,1,item_lru_bump_buf_create,void* item_lru_bump_buf_create (void),items.c,"void *item_lru_bump_buf_create(void) {
    lru_bump_buf *b = calloc(1, sizeof(lru_bump_buf));
    if (b == NULL) {
        return NULL;
    }

    b->buf = bipbuf_new(sizeof(lru_bump_entry) * LRU_BUMP_BUF_SIZE);
    if (b->buf == NULL) {
        free(b);
        return NULL;
    }

    pthread_mutex_init(&b->mutex, NULL);

    lru_bump_buf_link_q(b);
    return b;
}",1294.0,1310.0,1.0,49.0,17.0,11,6,15,4,1,3,3,3,0,2,,0,2,2,1,1,void*
563,16946,lru_maintainer_bumps,1,lru_maintainer_bumps,bool lru_maintainer_bumps (void),items.c,"static bool lru_maintainer_bumps(void) {
    lru_bump_buf *b;
    lru_bump_entry *be;
    unsigned int size;
    unsigned int todo;
    bool bumped = false;
    pthread_mutex_lock(&bump_buf_lock);
    for (b = bump_buf_head; b != NULL; b=b->next) {
        pthread_mutex_lock(&b->mutex);
        be = (lru_bump_entry *) bipbuf_peek_all(b->buf, &size);
        pthread_mutex_unlock(&b->mutex);

        if (be == NULL) {
            continue;
        }
        todo = size;
        bumped = true;

        while (todo) {
            item_lock(be->hv);
            do_item_update(be->it);
            do_item_remove(be->it);
            item_unlock(be->hv);
            be++;
            todo -= sizeof(lru_bump_entry);
        }

        pthread_mutex_lock(&b->mutex);
        be = (lru_bump_entry *) bipbuf_poll(b->buf, size);
        pthread_mutex_unlock(&b->mutex);
    }
    pthread_mutex_unlock(&bump_buf_lock);
    return bumped;
}",1341.0,1374.0,1.0,1.0,34.0,30,9,33,11,1,14,5,6,0,6,,0,10,2,1,1,bool
564,17104,lru_maintainer_juggle,1,lru_maintainer_juggle,int lru_maintainer_juggle (int),items.c,"static int lru_maintainer_juggle(const int slabs_clsid) {
    int i;
    int did_moves = 0;
    uint64_t total_bytes = 0;
    unsigned int chunks_perslab = 0;
    //unsigned int chunks_free = 0;
    /* TODO: if free_chunks below high watermark, increase aggressiveness */
    slabs_available_chunks(slabs_clsid, NULL,
            &chunks_perslab);
    if (settings.temp_lru) {
        /* Only looking for reclaims. Run before we size the LRU. */
        for (i = 0; i < 500; i++) {
            if (lru_pull_tail(slabs_clsid, TEMP_LRU, 0, 0, 0, NULL) <= 0) {
                break;
            } else {
                did_moves++;
            }
        }
    }

    rel_time_t cold_age = 0;
    rel_time_t hot_age = 0;
    rel_time_t warm_age = 0;
    /* If LRU is in flat mode, force items to drain into COLD via max age of 0 */
    if (settings.lru_segmented) {
        pthread_mutex_lock(&lru_locks[slabs_clsid|COLD_LRU]);
        if (tails[slabs_clsid|COLD_LRU]) {
            cold_age = curre...",1397.0,1458.0,1.0,43.0,62.0,61,14,68,15,1,15,12,17,7,5,,0,13,2,1,1,int
565,17365,lru_maintainer_crawler_check,1,lru_maintainer_crawler_check,"void lru_maintainer_crawler_check (crawler_expired_data*,logger*)",items.c,"static void lru_maintainer_crawler_check(struct crawler_expired_data *cdata, logger *l) {
    int i;
    static rel_time_t next_crawls[POWER_LARGEST];
    static rel_time_t next_crawl_wait[POWER_LARGEST];
    uint8_t todo[POWER_LARGEST];
    memset(todo, 0, sizeof(uint8_t) * POWER_LARGEST);
    bool do_run = false;
    unsigned int tocrawl_limit = 0;

    // TODO: If not segmented LRU, skip non-cold
    for (i = POWER_SMALLEST; i < POWER_LARGEST; i++) {
        crawlerstats_t *s = &cdata->crawlerstats[i];
        /* We've not successfully kicked off a crawl yet. */
        if (s->run_complete) {
            char *lru_name = ""na"";
            pthread_mutex_lock(&cdata->lock);
            int x;
            /* Should we crawl again? */
            uint64_t possible_reclaims = s->seen - s->noexp;
            uint64_t available_reclaims = 0;
            /* Need to think we can free at least 1% of the items before
             * crawling. */
            /* FIXME: Configurable? */
       ...",1474.0,1566.0,1.0,34.0,93.0,102,19,110,28,1,20,18,33,4,2,,0,18,4,2,2,void
566,17763,lru_maintainer_thread,1,lru_maintainer_thread,void* lru_maintainer_thread (void*),items.c,"static void *lru_maintainer_thread(void *arg) {
    slab_automove_reg_t *sam = &slab_automove_default;
#ifdef EXTSTORE
    void *storage = arg;
    if (storage != NULL)
        sam = &slab_automove_extstore;
#endif
    int i;
    useconds_t to_sleep = MIN_LRU_MAINTAINER_SLEEP;
    useconds_t last_sleep = MIN_LRU_MAINTAINER_SLEEP;
    rel_time_t last_crawler_check = 0;
    rel_time_t last_automove_check = 0;
    useconds_t next_juggles[MAX_NUMBER_OF_SLAB_CLASSES] = {0};
    useconds_t backoff_juggles[MAX_NUMBER_OF_SLAB_CLASSES] = {0};
    struct crawler_expired_data *cdata =
        calloc(1, sizeof(struct crawler_expired_data));
    if (cdata == NULL) {
        fprintf(stderr, ""Failed to allocate crawler data for LRU maintainer thread\n"");
        abort();
    }
    pthread_mutex_init(&cdata->lock, NULL);
    cdata->crawl_complete = true; // kick off the crawler.
    logger *l = logger_create();
    if (l == NULL) {
        fprintf(stderr, ""Failed to allocate logger for LRU maintain...",1585.0,1704.0,1.0,26.0,120.0,112,22,134,29,0,30,21,46,8,6,,0,25,2,1,1,void*
567,18224,stop_lru_maintainer_thread,1,stop_lru_maintainer_thread,int stop_lru_maintainer_thread (void),items.c,"int stop_lru_maintainer_thread(void) {
    int ret;
    pthread_mutex_lock(&lru_maintainer_lock);
    /* LRU thread is a sleep loop, will die on its own */
    do_run_lru_maintainer_thread = 0;
    pthread_mutex_unlock(&lru_maintainer_lock);
    if ((ret = pthread_join(lru_maintainer_tid, NULL)) != 0) {
        fprintf(stderr, ""Failed to stop LRU maintainer thread: %s\n"", strerror(ret));
        return -1;
    }
    settings.lru_maintainer_thread = false;
    return 0;
}",1706.0,1718.0,1.0,1.0,13.0,8,5,10,8,0,5,2,2,1,0,,0,5,2,1,1,int
568,18263,start_lru_maintainer_thread,1,start_lru_maintainer_thread,int start_lru_maintainer_thread (void*),items.c,"int start_lru_maintainer_thread(void *arg) {
    int ret;

    pthread_mutex_lock(&lru_maintainer_lock);
    do_run_lru_maintainer_thread = 1;
    settings.lru_maintainer_thread = true;
    if ((ret = pthread_create(&lru_maintainer_tid, NULL,
        lru_maintainer_thread, arg)) != 0) {
        fprintf(stderr, ""Can't create LRU maintainer thread: %s\n"",
            strerror(ret));
        pthread_mutex_unlock(&lru_maintainer_lock);
        return -1;
    }
    pthread_mutex_unlock(&lru_maintainer_lock);

    return 0;
}",1720.0,1736.0,1.0,1.0,17.0,10,5,12,9,1,6,2,2,1,0,,0,6,2,1,1,int
569,18308,lru_maintainer_pause,1,lru_maintainer_pause,void lru_maintainer_pause (void),items.c,"void lru_maintainer_pause(void) {
    pthread_mutex_lock(&lru_maintainer_lock);
}",1739.0,1741.0,1.0,1.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,void
570,18316,lru_maintainer_resume,1,lru_maintainer_resume,void lru_maintainer_resume (void),items.c,"void lru_maintainer_resume(void) {
    pthread_mutex_unlock(&lru_maintainer_lock);
}",1743.0,1745.0,1.0,1.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,void
571,18324,init_lru_maintainer,1,init_lru_maintainer,int init_lru_maintainer (void),items.c,"int init_lru_maintainer(void) {
    lru_maintainer_initialized = 1;
    return 0;
}",1747.0,1750.0,1.0,1.0,4.0,1,1,1,1,1,1,1,1,0,0,,0,1,2,1,1,int
572,18334,do_item_linktail_q,1,do_item_linktail_q,void do_item_linktail_q (item*),items.c,"void do_item_linktail_q(item *it) { /* item is the new tail */
    item **head, **tail;
    assert(it->it_flags == 1);
    assert(it->nbytes == 0);

    head = &heads[it->slabs_clsid];
    tail = &tails[it->slabs_clsid];
    //assert(*tail != 0);
    assert(it != *tail);
    assert((*head && *tail) || (*head == 0 && *tail == 0));
    it->prev = *tail;
    it->next = 0;
    if (it->prev) {
        assert(it->prev->next == 0);
        it->prev->next = it;
    }
    *tail = it;
    if (*head == 0) *head = it;
    return;
}",1753.0,1772.0,1.0,1.0,20.0,41,9,26,5,1,2,3,3,0,0,,0,2,2,1,1,void
573,18436,do_item_unlinktail_q,1,do_item_unlinktail_q,void do_item_unlinktail_q (item*),items.c,"void do_item_unlinktail_q(item *it) {
    item **head, **tail;
    head = &heads[it->slabs_clsid];
    tail = &tails[it->slabs_clsid];

    if (*head == it) {
        assert(it->prev == 0);
        *head = it->next;
    }
    if (*tail == it) {
        assert(it->next == 0);
        *tail = it->prev;
    }
    assert(it->next != it);
    assert(it->prev != it);

    if (it->next) it->next->prev = it->prev;
    if (it->prev) it->prev->next = it->next;
    return;
}",1774.0,1793.0,1.0,1.0,20.0,36,7,26,5,1,2,5,5,0,0,,0,2,2,1,1,void
574,18536,do_item_crawl_q,1,do_item_crawl_q,item do_item_crawl_q (item*),items.c,"item *do_item_crawl_q(item *it) {
    item **head, **tail;
    assert(it->it_flags == 1);
    assert(it->nbytes == 0);
    head = &heads[it->slabs_clsid];
    tail = &tails[it->slabs_clsid];

    /* We've hit the head, pop off */
    if (it->prev == 0) {
        assert(*head == it);
        if (it->next) {
            *head = it->next;
            assert(it->next->prev == it);
            it->next->prev = 0;
        }
        return NULL; /* Done */
    }

    /* Swing ourselves in front of the next item */
    /* NB: If there is a prev, we can't be the head */
    assert(it->prev != it);
    if (it->prev) {
        if (*head == it->prev) {
            /* Prev was the head, now we're the head */
            *head = it;
        }
        if (*tail == it) {
            /* We are the tail, now they are the tail */
            *tail = it->prev;
        }
        assert(it->next != it);
        if (it->next) {
            assert(it->prev->next == it);
            it->prev->next = it->nex...",1797.0,1849.0,1.0,1.0,53.0,72,7,52,6,0,2,8,13,0,0,,0,2,2,1,1,item
575,19030,out2,1,out2,"char* out2 (int,char*)",itoa_ljust.c,"static inline char* out2(const int d, char* p) {
    memcpy(p, &((uint16_t *)lut)[d], 2);
    return p + 2;
}",73.0,76.0,1.0,1.0,4.0,4,4,4,3,5,1,1,1,0,0,,0,1,4,2,2,char*
576,19049,out1,1,out1,"char* out1 (char,char*)",itoa_ljust.c,"static inline char* out1(const char in, char* p) {
    memcpy(p, &in, 1);
    return p + 1;
}",78.0,81.0,1.0,1.0,4.0,2,2,3,2,2,0,1,1,0,0,,0,0,4,2,2,char*
577,19064,digits,1,digits,"int digits (uint32_t,unsigned,int*,char**,int)",itoa_ljust.c,"static inline int digits( uint32_t u, unsigned k, int* d, char** p, int n ) {
    if (u < k*10) {
        *d = u / k;
        *p = out1('0'+*d, *p);
        --n;
    }
    return n;
}",83.0,90.0,1.0,1.0,8.0,11,7,10,5,1,1,2,2,0,1,,0,1,10,5,5,int
578,19100,itoa,1,itoa,"char* itoa (uint32_t,char*,int,int)",itoa_ljust.c,"static inline char* itoa(uint32_t u, char* p, int d, int n) {
    switch(n) {
    case 10: d  = u / 100000000; p = out2( d, p );
    case  9: u -= d * 100000000;
    case  8: d  = u /   1000000; p = out2( d, p );
    case  7: u -= d *   1000000;
    case  6: d  = u /     10000; p = out2( d, p );
    case  5: u -= d *     10000;
    case  4: d  = u /       100; p = out2( d, p );
    case  3: u -= d *       100;
    case  2: d  = u /         1; p = out2( d, p );
    case  1: ;
    }
    *p = '\0';
    return p;
}",92.0,107.0,1.0,1.0,16.0,25,5,36,4,2,5,2,2,0,5,,0,5,8,4,4,char*
579,19207,itoa_u32,1,itoa_u32,"char* itoa_u32 (uint32_t,char*)",itoa_ljust.c,"char* itoa_u32(uint32_t u, char* p) {
    int d = 0,n;
         if (u >=100000000) n = digits(u, 100000000, &d, &p, 10);
    else if (u <       100) n = digits(u,         1, &d, &p,  2);
    else if (u <     10000) n = digits(u,       100, &d, &p,  4);
    else if (u <   1000000) n = digits(u,     10000, &d, &p,  6);
    else                    n = digits(u,   1000000, &d, &p,  8);
    return itoa( u, p, d, n );
}",109.0,117.0,1.0,1.0,9.0,5,3,10,4,7,2,2,2,0,2,,0,1,4,2,2,char*
580,19302,itoa_32,1,itoa_32,"char* itoa_32 (int32_t,char*)",itoa_ljust.c,"char* itoa_32(int32_t i, char* p) {
    uint32_t u = i;
    if (i < 0) {
        *p++ = '-';
        u = -u;
    }
    return itoa_u32(u, p);
}",119.0,126.0,1.0,1.0,8.0,7,5,8,3,0,1,2,2,0,1,,0,0,4,2,2,char*
581,19330,itoa_u64,1,itoa_u64,"char* itoa_u64 (uint64_t,char*)",itoa_ljust.c,"char* itoa_u64(uint64_t u, char* p) {
    int d;

    uint32_t lower = (uint32_t)u;
    if (lower == u) return itoa_u32(lower, p);

    uint64_t upper = u / 1000000000;
    p = itoa_u64(upper, p);
    lower = u - (upper * 1000000000);
    d = lower / 100000000;
    p = out1('0'+d,p);
    return itoa( lower, p, d, 9 );
}",128.0,140.0,1.0,1.0,13.0,13,7,22,5,7,3,2,2,0,3,,0,1,4,2,2,char*
582,19388,itoa_64,1,itoa_64,"char* itoa_64 (int64_t,char*)",itoa_ljust.c,"char* itoa_64(int64_t i, char* p) {
    uint64_t u = i;
    if (i < 0) {
        *p++ = '-';
        u = -u;
    }
    return itoa_u64(u, p);
}",142.0,149.0,1.0,1.0,8.0,7,5,8,3,0,1,2,2,0,1,,0,0,4,2,2,char*
583,19491,handle_syssig,1,handle_syssig,"void handle_syssig (int,siginfo_t*,void*)",linux_priv.c,"static void handle_syssig(int signum, siginfo_t *si, void *thread_context) {
#if defined(si_syscall)
    int syscall_no = si->si_syscall;
#else
    // If system has no support for si_syscal, the information may not be
    // precise.
    int syscall_no = si->si_value.sival_int;
#endif

    // Replace the characters in the kill message with the syscall number. We
    // can't safely printf (even write is not really valid, but we're crashing
    // anyway).

    kill_msg[39] = (syscall_no / 100) % 10 + '0';
    kill_msg[40] = (syscall_no / 10) % 10 + '0';
    kill_msg[41] = syscall_no % 10 + '0';
    if (write(2, kill_msg, strlen(kill_msg)) == -1) {
        // An error occurred, but we can't do anything about it here. This check
        // is mostly to avoid the ""ignoring return value of 'write'"" error on
        // distributions with broken gcc (no ""ignore via cast to void"" support).
    }

    // We can't use the nice exit() version because it causes at_exit handlers
    // to be lo...",17.0,43.0,1.0,1.0,27.0,19,9,11,4,0,5,2,2,2,0,,0,5,6,3,3,void
584,19633,logger_thread_poll_watchers,1,logger_thread_poll_watchers,"int logger_thread_poll_watchers (int,int)",logger.c,"static int logger_thread_poll_watchers(int force_poll, int watcher) {
    int x;
    int nfd = 0;
    unsigned char *data;
    unsigned int data_size = 0;
    int flushed = 0;

    for (x = 0; x < WATCHER_LIMIT; x++) {
        logger_watcher *w = watchers[x];
        if (w == NULL || (watcher != WATCHER_ALL && x != watcher))
            continue;

        data = bipbuf_peek_all(w->buf, &data_size);
        if (data != NULL) {
            watchers_pollfds[nfd].fd = w->sfd;
            watchers_pollfds[nfd].events = POLLOUT;
            nfd++;
        } else if (force_poll) {
            watchers_pollfds[nfd].fd = w->sfd;
            watchers_pollfds[nfd].events = POLLIN;
            nfd++;
        }
        /* This gets set after a call to poll, and should be used to gate on
         * calling poll again.
         */
        w->failed_flush = false;
    }

    if (nfd == 0)
        return 0;

    //L_DEBUG(""LOGGER: calling poll() [data_size: %d]\n"", data_size);
    int ret = poll(wat...",656.0,750.0,1.0,20.0,95.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,int
585,19683,_logger_log_evictions,1,_logger_log_evictions,"void _logger_log_evictions (logentry*,entry_details*,void*,va_list)",logger.c,"static void _logger_log_evictions(logentry *e, const entry_details *d, const void *entry, va_list ap) {
    item *it = (item *)entry;
    struct logentry_eviction *le = (struct logentry_eviction *) e->data;

    le->exptime = (it->exptime > 0) ? (long long int)(it->exptime - current_time) : (long long int) -1;
    le->latime = current_time - it->time;
    le->it_flags = it->it_flags;
    le->nkey = it->nkey;
    le->nbytes = it->nbytes;
    le->clsid = ITEM_clsid(it);
    memcpy(le->key, ITEM_key(it), it->nkey);
    e->size = sizeof(struct logentry_eviction) + le->nkey;
}",63.0,75.0,1.0,16.0,13.0,49,13,29,7,0,8,1,1,0,0,,0,8,8,4,4,void
586,19807,_logger_log_item_get,1,_logger_log_item_get,"void _logger_log_item_get (logentry*,entry_details*,void*,va_list)",logger.c,"static void _logger_log_item_get(logentry *e, const entry_details *d, const void *entry, va_list ap) {
    int was_found = va_arg(ap, int);
    char *key = va_arg(ap, char *);
    int nkey = va_arg(ap, int);
    int nbytes = va_arg(ap, int);
    uint8_t clsid = va_arg(ap, int);
    int sfd = va_arg(ap, int);

    struct logentry_item_get *le = (struct logentry_item_get *) e->data;
    le->was_found = was_found;
    le->nkey = nkey;
    le->nbytes = nbytes;
    le->clsid = clsid;
    memcpy(le->key, key, nkey);
    le->sfd = sfd;
    e->size = sizeof(struct logentry_item_get) + nkey;
}",96.0,112.0,1.0,1.0,17.0,18,5,19,10,0,6,1,1,0,0,,0,6,8,4,4,void
587,19870,_logger_log_item_store,1,_logger_log_item_store,"void _logger_log_item_store (logentry*,entry_details*,void*,va_list)",logger.c,"static void _logger_log_item_store(logentry *e, const entry_details *d, const void *entry, va_list ap) {
    enum store_item_type status = va_arg(ap, enum store_item_type);
    int comm = va_arg(ap, int);
    char *key = va_arg(ap, char *);
    int nkey = va_arg(ap, int);
    int nbytes = va_arg(ap, int);
    rel_time_t ttl = va_arg(ap, rel_time_t);
    uint8_t clsid = va_arg(ap, int);
    int sfd = va_arg(ap, int);

    struct logentry_item_store *le = (struct logentry_item_store *) e->data;
    le->status = status;
    le->cmd = comm;
    le->nkey = nkey;
    le->nbytes = nbytes;
    le->clsid = clsid;
    if (ttl != 0) {
        le->ttl = ttl - current_time;
    } else {
        le->ttl = 0;
    }
    memcpy(le->key, key, nkey);
    le->sfd = sfd;
    e->size = sizeof(struct logentry_item_store) + nkey;
}",114.0,138.0,1.0,1.0,25.0,25,7,28,15,0,8,2,2,0,0,,0,8,8,4,4,void
588,19965,_logger_log_conn_event,1,_logger_log_conn_event,"void _logger_log_conn_event (logentry*,entry_details*,void*,va_list)",logger.c,"static void _logger_log_conn_event(logentry *e, const entry_details *d, const void *entry, va_list ap) {
    struct sockaddr_in6 *addr = va_arg(ap, struct sockaddr_in6 *);
    socklen_t addrlen = va_arg(ap, socklen_t);
    enum network_transport transport = va_arg(ap, enum network_transport);
    enum close_reasons reason = va_arg(ap, enum close_reasons);
    int sfd = va_arg(ap, int);

    struct logentry_conn_event *le = (struct logentry_conn_event *) e->data;

    memcpy(&le->addr, addr, addrlen);
    le->sfd = sfd;
    le->transport = transport;
    le->reason = reason;
    e->size = sizeof(struct logentry_conn_event);
}",140.0,154.0,1.0,1.0,15.0,15,5,16,10,0,4,1,1,0,0,,0,4,8,4,4,void
589,20022,_logger_util_addr_endpoint,1,_logger_util_addr_endpoint,"int _logger_util_addr_endpoint (sockaddr_in6*,char*,size_t,short unsigned*)",logger.c,"static int _logger_util_addr_endpoint(struct sockaddr_in6 *addr, char *rip,
        size_t riplen, unsigned short *rport) {
    memset(rip, 0, riplen);

    switch (addr->sin6_family) {
        case AF_INET:
            inet_ntop(AF_INET, &((struct sockaddr_in *) addr)->sin_addr,
                    rip, riplen - 1);
            *rport = ntohs(((struct sockaddr_in *) addr)->sin_port);
            break;
        case AF_INET6:
            inet_ntop(AF_INET6, &((struct sockaddr_in6 *) addr)->sin6_addr,
                    rip, riplen - 1);
            *rport = ntohs(((struct sockaddr_in6 *) addr)->sin6_port);
            break;
#ifndef DISABLE_UNIX_SOCKET
        // Connections on Unix socket transports have c->request_addr zeroed out.
        case AF_UNSPEC:
        case AF_UNIX:
            strncpy(rip, ""unix"", strlen(""unix"") + 1);
            *rport = 0;
            break;
#endif // #ifndef DISABLE_UNIX_SOCKET
    }

    return 0;
}",160.0,186.0,1.0,1.0,27.0,20,7,21,8,2,0,5,2,0,0,,0,0,8,4,4,int
590,20142,_logger_parse_ise,1,_logger_parse_ise,"int _logger_parse_ise (logentry*,char*)",logger.c,"static int _logger_parse_ise(logentry *e, char *scratch) {
    int total;
    const char *cmd = ""na"";
    char keybuf[KEY_MAX_URI_ENCODED_LENGTH];
    struct logentry_item_store *le = (struct logentry_item_store *) e->data;
    const char * const status_map[] = {
        ""not_stored"", ""stored"", ""exists"", ""not_found"", ""too_large"", ""no_memory"" };
    const char * const cmd_map[] = {
        ""null"", ""add"", ""set"", ""replace"", ""append"", ""prepend"", ""cas"" };

    if (le->cmd <= 6)
        cmd = cmd_map[le->cmd];

    uriencode(le->key, keybuf, le->nkey, KEY_MAX_URI_ENCODED_LENGTH);
    total = snprintf(scratch, LOGGER_PARSE_SCRATCH,
            ""ts=%d.%d gid=%llu type=item_store key=%s status=%s cmd=%s ttl=%u clsid=%u cfd=%d size=%d\n"",
            (int)e->tv.tv_sec, (int)e->tv.tv_usec, (unsigned long long) e->gid,
            keybuf, status_map[le->status], cmd, le->ttl, le->clsid, le->sfd,
            le->nbytes > 0 ? le->nbytes - 2 : 0); // CLRF
    return total;
}",201.0,221.0,1.0,16.0,21.0,36,12,27,8,0,11,2,2,1,1,,0,10,4,2,2,int
591,20269,_logger_parse_ige,1,_logger_parse_ige,"int _logger_parse_ige (logentry*,char*)",logger.c,"static int _logger_parse_ige(logentry *e, char *scratch) {
    int total;
    struct logentry_item_get *le = (struct logentry_item_get *) e->data;
    char keybuf[KEY_MAX_URI_ENCODED_LENGTH];
    const char * const was_found_map[] = {
        ""not_found"", ""found"", ""flushed"", ""expired"" };

    uriencode(le->key, keybuf, le->nkey, KEY_MAX_URI_ENCODED_LENGTH);
    total = snprintf(scratch, LOGGER_PARSE_SCRATCH,
            ""ts=%d.%d gid=%llu type=item_get key=%s status=%s clsid=%u cfd=%d size=%d\n"",
            (int)e->tv.tv_sec, (int)e->tv.tv_usec, (unsigned long long) e->gid,
            keybuf, was_found_map[le->was_found], le->clsid, le->sfd,
            le->nbytes > 0 ? le->nbytes - 2 : 0); // CLRF
    return total;
}",223.0,237.0,1.0,16.0,15.0,27,11,19,6,0,8,1,1,0,1,,0,7,4,2,2,int
592,20361,_logger_parse_ee,1,_logger_parse_ee,"int _logger_parse_ee (logentry*,char*)",logger.c,"static int _logger_parse_ee(logentry *e, char *scratch) {
    int total;
    char keybuf[KEY_MAX_URI_ENCODED_LENGTH];
    struct logentry_eviction *le = (struct logentry_eviction *) e->data;
    uriencode(le->key, keybuf, le->nkey, KEY_MAX_URI_ENCODED_LENGTH);
    total = snprintf(scratch, LOGGER_PARSE_SCRATCH,
            ""ts=%d.%d gid=%llu type=eviction key=%s fetch=%s ttl=%lld la=%d clsid=%u size=%d\n"",
            (int)e->tv.tv_sec, (int)e->tv.tv_usec, (unsigned long long) e->gid,
            keybuf, (le->it_flags & ITEM_FETCHED) ? ""yes"" : ""no"",
            (long long int)le->exptime, le->latime, le->clsid,
            le->nbytes > 0 ? le->nbytes - 2 : 0); // CLRF

    return total;
}",239.0,252.0,1.0,16.0,14.0,28,10,18,5,0,9,1,1,0,1,,0,8,4,2,2,int
593,20455,_logger_parse_cne,1,_logger_parse_cne,"int _logger_parse_cne (logentry*,char*)",logger.c,"static int _logger_parse_cne(logentry *e, char *scratch) {
    int total;
    unsigned short rport;
    char rip[64];
    struct logentry_conn_event *le = (struct logentry_conn_event *) e->data;
    const char * const transport_map[] = { ""local"", ""tcp"", ""udp"" };

    _logger_util_addr_endpoint(&le->addr, rip, sizeof(rip), &rport);

    total = snprintf(scratch, LOGGER_PARSE_SCRATCH,
            ""ts=%d.%d gid=%llu type=conn_new rip=%s rport=%hu transport=%s cfd=%d\n"",
            (int) e->tv.tv_sec, (int) e->tv.tv_usec, (unsigned long long) e->gid,
            rip, rport, transport_map[le->transport], le->sfd);

    return total;
}",270.0,285.0,1.0,30.0,16.0,21,8,18,7,0,4,1,1,0,1,,0,3,4,2,2,int
594,20528,_logger_parse_cce,1,_logger_parse_cce,"int _logger_parse_cce (logentry*,char*)",logger.c,"static int _logger_parse_cce(logentry *e, char *scratch) {
    int total;
    unsigned short rport;
    char rip[64];
    struct logentry_conn_event *le = (struct logentry_conn_event *) e->data;
    const char * const transport_map[] = { ""local"", ""tcp"", ""udp"" };
    const char * const reason_map[] = { ""error"", ""normal"", ""idle_timeout"", ""shutdown"" };

    _logger_util_addr_endpoint(&le->addr, rip, sizeof(rip), &rport);

    total = snprintf(scratch, LOGGER_PARSE_SCRATCH,
            ""ts=%d.%d gid=%llu type=conn_close rip=%s rport=%hu transport=%s reason=%s cfd=%d\n"",
            (int) e->tv.tv_sec, (int) e->tv.tv_usec, (unsigned long long) e->gid,
            rip, rport, transport_map[le->transport],
            reason_map[le->reason], le->sfd);

    return total;
}",287.0,304.0,1.0,30.0,18.0,25,8,21,8,0,5,1,1,0,1,,0,4,4,2,2,int
595,20726,logger_get_gid,1,logger_get_gid,uint64_t logger_get_gid (void),logger.c,"uint64_t logger_get_gid(void) {
#ifdef HAVE_GCC_64ATOMICS
    return __sync_add_and_fetch(&logger_gid, 1);
#elif defined(__sun)
    return atomic_inc_64_nv(&logger_gid);
#else
    mutex_lock(&logger_atomics_mutex);
    uint64_t res = ++logger_gid;
    mutex_unlock(&logger_atomics_mutex);
    return res;
#endif
}",431.0,442.0,1.0,4.0,12.0,6,3,7,3,3,5,1,1,0,0,,0,5,2,1,1,uint64_t
596,20752,logger_set_gid,1,logger_set_gid,void logger_set_gid (uint64_t),logger.c,"void logger_set_gid(uint64_t gid) {
#ifdef HAVE_GCC_64ATOMICS
    __sync_add_and_fetch(&logger_gid, gid);
#elif defined(__sun)
    atomic_add_64(&logger_gid);
#else
    mutex_lock(&logger_atomics_mutex);
    logger_gid = gid;
    mutex_unlock(&logger_atomics_mutex);
#endif
}",444.0,454.0,1.0,4.0,11.0,5,2,6,3,0,5,1,1,0,0,,0,5,2,1,1,void
597,20774,logger_link_q,1,logger_link_q,void logger_link_q (logger*),logger.c,"static void logger_link_q(logger *l) {
    pthread_mutex_lock(&logger_stack_lock);
    assert(l != logger_stack_head);

    l->prev = 0;
    l->next = logger_stack_head;
    if (l->next) l->next->prev = l;
    logger_stack_head = l;
    if (logger_stack_tail == 0) logger_stack_tail = l;
    logger_count++;
    pthread_mutex_unlock(&logger_stack_lock);
    return;
}",460.0,472.0,1.0,1.0,13.0,15,6,16,5,1,8,3,3,1,0,,0,8,2,1,1,void
598,20825,logger_set_flags,1,logger_set_flags,void logger_set_flags (void),logger.c,"static void logger_set_flags(void) {
    logger *l = NULL;
    int x = 0;
    uint16_t f = 0; /* logger eflags */

    for (x = 0; x < WATCHER_LIMIT; x++) {
        logger_watcher *w = watchers[x];
        if (w == NULL)
            continue;

        f |= w->eflags;
    }
    for (l = logger_stack_head; l != NULL; l=l->next) {
        pthread_mutex_lock(&l->mutex);
        l->eflags = f;
        pthread_mutex_unlock(&l->mutex);
    }
    return;
}",498.0,516.0,1.0,20.0,19.0,17,7,21,7,2,3,5,5,0,0,,0,3,2,1,1,void
599,20902,logger_thread_parse_entry,1,logger_thread_parse_entry,"enum logger_parse_entry_ret logger_thread_parse_entry (logentry*,logger_stats*,char*,int*)",logger.c,"static enum logger_parse_entry_ret logger_thread_parse_entry(logentry *e, struct logger_stats *ls,
        char *scratch, int *scratch_len) {
    int total = 0;
    const entry_details *d = &default_entries[e->event];
    assert(d->parse_cb != NULL);
    total = d->parse_cb(e, scratch);

    if (total >= LOGGER_PARSE_SCRATCH || total <= 0) {
        L_DEBUG(""LOGGER: Failed to flatten log entry!\n"");
        return LOGGER_PARSE_ENTRY_FAILED;
    } else {
        *scratch_len = total;
    }

    return LOGGER_PARSE_ENTRY_OK;
}",519.0,534.0,1.0,17.0,16.0,12,8,14,8,1,1,2,2,0,0,,0,1,8,4,4,enum logger_parse_entry_ret
600,20958,logger_thread_write_entry,1,logger_thread_write_entry,"void logger_thread_write_entry (logentry*,logger_stats*,char*,int)",logger.c,"static void logger_thread_write_entry(logentry *e, struct logger_stats *ls,
        char *scratch, int scratch_len) {
    int x, total;
    /* Write the line into available watchers with matching flags */
    for (x = 0; x < WATCHER_LIMIT; x++) {
        logger_watcher *w = watchers[x];
        char *skip_scr = NULL;
        if (w == NULL || (e->eflags & w->eflags) == 0 || (e->gid < w->min_gid))
            continue;

         /* Avoid poll()'ing constantly when buffer is full by resetting a
         * flag periodically.
         */
        while (!w->failed_flush &&
                (skip_scr = (char *) bipbuf_request(w->buf, scratch_len + 128)) == NULL) {
            if (logger_thread_poll_watchers(0, x) <= 0) {
                L_DEBUG(""LOGGER: Watcher had no free space for line of size (%d)\n"", scratch_len + 128);
                w->failed_flush = true;
            }
        }

        if (w->failed_flush) {
            L_DEBUG(""LOGGER: Fast skipped for watcher [%d] due to failed_...",537.0,580.0,1.0,20.0,44.0,50,15,39,11,0,21,11,16,8,4,,0,19,8,4,4,void
601,21119,logger_thread_close_watcher,1,logger_thread_close_watcher,void logger_thread_close_watcher (logger_watcher*),logger.c,"static void logger_thread_close_watcher(logger_watcher *w) {
    L_DEBUG(""LOGGER: Closing dead watcher\n"");
    watchers[w->id] = NULL;
    sidethread_conn_close(w->c);
    watcher_count--;
    bipbuf_free(w->buf);
    free(w);
    logger_set_flags();
}",587.0,595.0,1.0,4.0,9.0,6,4,7,4,0,8,1,1,0,3,,0,5,2,1,1,void
602,21144,logger_thread_read,1,logger_thread_read,"int logger_thread_read (logger*,logger_stats*)",logger.c,"static int logger_thread_read(logger *l, struct logger_stats *ls) {
    unsigned int size;
    unsigned int pos = 0;
    unsigned char *data;
    char scratch[LOGGER_PARSE_SCRATCH];
    logentry *e;
    pthread_mutex_lock(&l->mutex);
    data = bipbuf_peek_all(l->buf, &size);
    pthread_mutex_unlock(&l->mutex);

    if (data == NULL) {
        return 0;
    }
    L_DEBUG(""LOGGER: Got %d bytes from bipbuffer\n"", size);

    /* parse buffer */
    while (pos < size && watcher_count > 0) {
        enum logger_parse_entry_ret ret;
        int scratch_len = 0;
        e = (logentry *) (data + pos);
        ret = logger_thread_parse_entry(e, ls, scratch, &scratch_len);
        if (ret != LOGGER_PARSE_ENTRY_OK) {
            /* TODO: stats counter */
            fprintf(stderr, ""LOGGER: Failed to parse log entry\n"");
        } else {
            logger_thread_write_entry(e, ls, scratch, scratch_len);
        }
        pos += sizeof(logentry) + e->size + e->pad;
    }
    assert(pos <= siz...",600.0,643.0,1.0,17.0,44.0,43,13,44,14,1,6,5,6,1,3,,0,6,4,2,2,int
603,21639,logger_thread_flush_stats,1,logger_thread_flush_stats,void logger_thread_flush_stats (logger_stats*),logger.c,"static void logger_thread_flush_stats(struct logger_stats *ls) {
    STATS_LOCK();
    stats.log_worker_dropped  += ls->worker_dropped;
    stats.log_worker_written  += ls->worker_written;
    stats.log_watcher_skipped += ls->watcher_skipped;
    stats.log_watcher_sent    += ls->watcher_sent;
    stats_state.log_watchers   = ls->watcher_count;
    STATS_UNLOCK();
}",752.0,760.0,1.0,1.0,9.0,15,4,10,3,1,12,1,1,0,0,,0,10,2,1,1,void
604,21681,logger_thread,1,logger_thread,void* logger_thread (void*),logger.c,"static void *logger_thread(void *arg) {
    useconds_t to_sleep = MIN_LOGGER_SLEEP;
    L_DEBUG(""LOGGER: Starting logger thread\n"");
    // TODO: If we ever have item references in the logger code, will need to
    // ensure everything is dequeued before stopping the thread.
    while (do_run_logger_thread) {
        int found_logs = 0;
        logger *l;
        struct logger_stats ls;
        memset(&ls, 0, sizeof(struct logger_stats));

        /* only sleep if we're *above* the minimum */
        if (to_sleep > MIN_LOGGER_SLEEP)
            usleep(to_sleep);

        /* Call function to iterate each logger. */
        pthread_mutex_lock(&logger_stack_lock);
        if (watcher_count == 0) {
            // Not bothering to loop on the condition here since it's fine to
            // walk through with zero watchers.
            pthread_cond_wait(&logger_stack_cond, &logger_stack_lock);
        }
        for (l = logger_stack_head; l != NULL; l=l->next) {
            /* lock logger...",766.0,815.0,1.0,26.0,50.0,24,12,29,11,0,12,8,16,2,3,,0,9,2,1,1,void*
605,21813,start_logger_thread,1,start_logger_thread,int start_logger_thread (void),logger.c,"static int start_logger_thread(void) {
    int ret;
    do_run_logger_thread = 1;
    if ((ret = pthread_create(&logger_tid, NULL,
                              logger_thread, NULL)) != 0) {
        fprintf(stderr, ""Can't start logger thread: %s\n"", strerror(ret));
        return -1;
    }
    return 0;
}",817.0,826.0,1.0,1.0,10.0,5,4,7,5,1,2,2,2,1,0,,0,2,2,1,1,int
606,21844,stop_logger_thread,1,stop_logger_thread,int stop_logger_thread (void),logger.c,"static int stop_logger_thread(void) {
    // Guarantees that the logger thread is waiting on 'logger_stack_cond'
    // before we signal it.
    pthread_mutex_lock(&logger_stack_lock);
    do_run_logger_thread = 0;
    pthread_cond_signal(&logger_stack_cond);
    pthread_mutex_unlock(&logger_stack_lock);
    pthread_join(logger_tid, NULL);
    return 0;
}",828.0,837.0,1.0,1.0,10.0,4,2,6,5,1,5,1,1,0,0,,0,5,2,1,1,int
607,21866,logger_init,1,logger_init,void logger_init (void),logger.c,"void logger_init(void) {
    /* TODO: auto destructor when threads exit */
    /* TODO: error handling */

    /* init stack for iterating loggers */
    logger_stack_head = 0;
    logger_stack_tail = 0;
    pthread_key_create(&logger_key, NULL);

    if (start_logger_thread() != 0) {
        abort();
    }

    /* This is what adding a STDERR watcher looks like. should replace old
     * ""verbose"" settings. */
    //logger_add_watcher(NULL, 0);
    return;
}",844.0,861.0,1.0,1.0,18.0,4,3,4,4,1,4,2,2,1,1,,0,4,2,1,1,void
608,21888,logger_stop,1,logger_stop,void logger_stop (void),logger.c,"void logger_stop(void) {
    stop_logger_thread();
}",863.0,865.0,1.0,1.0,3.0,0,0,0,0,0,1,1,1,0,1,,0,0,2,1,1,void
609,21894,logger_create,1,logger_create,logger logger_create (void),logger.c,"logger *logger_create(void) {
    L_DEBUG(""LOGGER: Creating and linking new logger instance\n"");
    logger *l = calloc(1, sizeof(logger));
    if (l == NULL) {
        return NULL;
    }

    l->buf = bipbuf_new(settings.logger_buf_size);
    if (l->buf == NULL) {
        free(l);
        return NULL;
    }

    l->entry_map = default_entries;

    pthread_mutex_init(&l->mutex, NULL);
    pthread_setspecific(logger_key, l);

    /* add to list of loggers */
    logger_link_q(l);
    return l;
}",870.0,891.0,1.0,4.0,22.0,12,6,19,6,3,5,3,3,0,2,,0,4,2,1,1,logger
610,21950,logger_log,1,logger_log,"enum logger_ret_type logger_log (logger*,log_entry_type,void*...)",logger.c,"enum logger_ret_type logger_log(logger *l, const enum log_entry_type event, const void *entry, ...) {
    bipbuf_t *buf = l->buf;
    bool nospace = false;
    va_list ap;
    logentry *e;

    const entry_details *d = &l->entry_map[event];
    int reqlen = d->reqlen;

    pthread_mutex_lock(&l->mutex);
    /* Request a maximum length of data to write to */
    e = (logentry *) bipbuf_request(buf, (sizeof(logentry) + reqlen));
    if (e == NULL) {
        pthread_mutex_unlock(&l->mutex);
        l->dropped++;
        return LOGGER_RET_NOSPACE;
    }
    e->event = event;
    e->pad = 0;
    e->gid = logger_get_gid();
    /* TODO: Could pass this down as an argument now that we're using
     * LOGGER_LOG() macro.
     */
    e->eflags = d->eflags;
    /* Noting time isn't optional. A feature may be added to avoid rendering
     * time and/or gid to a logger.
     */
    gettimeofday(&e->tv, NULL);

    va_start(ap, entry);
    d->log_cb(e, d, entry, ap);
    va_end(ap);

#ifdef NEED_...",897.0,954.0,1.0,4.0,58.0,44,9,46,15,15,3,4,4,1,3,,0,3,6,3,3,enum logger_ret_type
611,22100,logger_add_watcher,1,logger_add_watcher,"enum logger_add_watcher_ret logger_add_watcher (void*,int,uint16_t)",logger.c,"enum logger_add_watcher_ret logger_add_watcher(void *c, const int sfd, uint16_t f) {
    int x;
    logger_watcher *w = NULL;
    pthread_mutex_lock(&logger_stack_lock);
    if (watcher_count >= WATCHER_LIMIT) {
        pthread_mutex_unlock(&logger_stack_lock);
        return LOGGER_ADD_WATCHER_TOO_MANY;
    }

    for (x = 0; x < WATCHER_LIMIT-1; x++) {
        if (watchers[x] == NULL)
            break;
    }

    w = calloc(1, sizeof(logger_watcher));
    if (w == NULL) {
        pthread_mutex_unlock(&logger_stack_lock);
        return LOGGER_ADD_WATCHER_FAILED;
    }
    w->c = c;
    w->sfd = sfd;
    if (sfd == 0 && c == NULL) {
        w->t = LOGGER_WATCHER_STDERR;
    } else {
        w->t = LOGGER_WATCHER_CLIENT;
    }
    w->id = x;
    w->eflags = f;
    w->min_gid = logger_get_gid();
    w->buf = bipbuf_new(settings.logger_watcher_buf_size);
    if (w->buf == NULL) {
        free(w);
        pthread_mutex_unlock(&logger_stack_lock);
        return LOGGER_ADD_WATCHER_FAIL...",960.0,1005.0,1.0,25.0,46.0,41,13,46,16,1,24,8,8,3,4,,0,22,6,3,3,enum logger_add_watcher_ret
612,22486,md5_process,1,md5_process,"void md5_process (md5_state_t*,md5_byte_t*)",md5.c,"static void
md5_process(md5_state_t *pms, const md5_byte_t *data /*[64]*/)
{
    md5_word_t
	a = pms->abcd[0], b = pms->abcd[1],
	c = pms->abcd[2], d = pms->abcd[3];
    md5_word_t t;
#if BYTE_ORDER > 0
    /* Define storage only for big-endian CPUs. */
    md5_word_t X[16];
#else
    /* Define storage for little-endian or both types of CPUs. */
    md5_word_t xbuf[16];
    const md5_word_t *X;
#endif

    {
#if BYTE_ORDER == 0
	/*
	 * Determine dynamically whether this is a big-endian or
	 * little-endian machine, since we can use a more efficient
	 * algorithm on the latter.
	 */
	static const int w = 1;

	if (*((const md5_byte_t *)&w)) /* dynamic little-endian */
#endif
#if BYTE_ORDER <= 0		/* little-endian */
	{
	    /*
	     * On little-endian machines, we can process properly aligned
	     * data without copying it.
	     */
	    if (!((data - (const md5_byte_t *)0) & 3)) {
		/* data are properly aligned */
		X = (const md5_word_t *)data;
	    } else {
		/* not aligned */
		me...",131.0,310.0,1.0,4.0,180.0,1078,16,949,9,1,0,3,4,0,0,,0,0,4,2,2,void
613,25213,md5_init,1,md5_init,void md5_init (md5_state_t*),md5.c,"void
md5_init(md5_state_t *pms)
{
    pms->count[0] = pms->count[1] = 0;
    pms->abcd[0] = 0x67452301;
    pms->abcd[1] = /*0xefcdab89*/ T_MASK ^ 0x10325476;
    pms->abcd[2] = /*0x98badcfe*/ T_MASK ^ 0x67452301;
    pms->abcd[3] = 0x10325476;
}",312.0,320.0,1.0,34.0,9.0,24,6,6,1,1,0,1,1,0,0,,0,0,2,1,1,void
614,25273,md5_append,1,md5_append,"void md5_append (md5_state_t*,md5_byte_t*,int)",md5.c,"void
md5_append(md5_state_t *pms, const md5_byte_t *data, int nbytes)
{
    const md5_byte_t *p = data;
    int left = nbytes;
    int offset = (pms->count[0] >> 3) & 63;
    md5_word_t nbits = (md5_word_t)(nbytes << 3);

    if (nbytes <= 0)
	return;

    /* Update the message length. */
    pms->count[1] += nbytes >> 29;
    pms->count[0] += nbits;
    if (pms->count[0] < nbits)
	pms->count[1]++;

    /* Process an initial partial block. */
    if (offset) {
	int copy = (offset + nbytes > 64 ? 64 - offset : nbytes);

	memcpy(pms->buf + offset, p, copy);
	if (offset + copy < 64)
	    return;
	p += copy;
	left -= copy;
	md5_process(pms, pms->buf);
    }

    /* Process full blocks. */
    for (; left >= 64; p += 64, left -= 64)
	md5_process(pms, p);

    /* Process a final partial block. */
    if (left)
	memcpy(pms->buf, p, left);
}",322.0,358.0,1.0,1.0,37.0,38,17,39,8,3,1,7,8,0,1,,0,0,6,3,3,void
615,25412,md5_finish,1,md5_finish,"void md5_finish (md5_state_t*,md5_byte_t[16])",md5.c,"void
md5_finish(md5_state_t *pms, md5_byte_t digest[16])
{
    static const md5_byte_t pad[64] = {
	0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    };
    md5_byte_t data[8];
    int i;

    /* Save the length before padding. */
    for (i = 0; i < 8; ++i)
	data[i] = (md5_byte_t)(pms->count[i >> 2] >> ((i & 3) << 3));
    /* Pad to 56 bytes mod 64. */
    md5_append(pms, pad, ((55 - (pms->count[0] >> 3)) & 63) + 1);
    /* Append the length. */
    md5_append(pms, data, 8);
    for (i = 0; i < 16; ++i)
	digest[i] = (md5_byte_t)(pms->abcd[i >> 2] >> ((i & 3) << 3));
}",360.0,381.0,1.0,1.0,22.0,12,9,10,4,1,2,3,3,0,2,,0,0,4,2,2,void
616,25675,drive_machine,1,drive_machine,void drive_machine (conn*),memcached.c,"static void drive_machine(conn *c) {
    bool stop = false;
    int sfd;
    socklen_t addrlen;
    struct sockaddr_storage addr;
    int nreqs = settings.reqs_per_event;
    int res;
    const char *str;
#ifdef HAVE_ACCEPT4
    static int  use_accept4 = 1;
#else
    static int  use_accept4 = 0;
#endif

    assert(c != NULL);

    while (!stop) {

        switch(c->state) {
        case conn_listening:
            addrlen = sizeof(addr);
#ifdef HAVE_ACCEPT4
            if (use_accept4) {
                sfd = accept4(c->sfd, (struct sockaddr *)&addr, &addrlen, SOCK_NONBLOCK);
            } else {
                sfd = accept(c->sfd, (struct sockaddr *)&addr, &addrlen);
            }
#else
            sfd = accept(c->sfd, (struct sockaddr *)&addr, &addrlen);
#endif
            if (sfd == -1) {
                if (use_accept4 && errno == ENOSYS) {
                    use_accept4 = 0;
                    continue;
                }
                perror(use_accept4 ? ""accept4()"" : ""ac...",2963.0,3390.0,1.0,37.0,428.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,void
617,25680,new_socket,1,new_socket,int new_socket (addrinfo*),memcached.c,"static int new_socket(struct addrinfo *ai) {
    int sfd;
    int flags;

    if ((sfd = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol)) == -1) {
        return -1;
    }

    if ((flags = fcntl(sfd, F_GETFL, 0)) < 0 ||
        fcntl(sfd, F_SETFL, flags | O_NONBLOCK) < 0) {
        perror(""setting O_NONBLOCK"");
        close(sfd);
        return -1;
    }
    return sfd;
}",3414.0,3429.0,1.0,1.0,16.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,int
618,25725,start_conn_timeout_thread,1,start_conn_timeout_thread,int start_conn_timeout_thread (),memcached.c,"static int start_conn_timeout_thread() {
    int ret;

    if (settings.idle_timeout == 0)
        return -1;

    do_run_conn_timeout_thread = 1;
    if ((ret = pthread_create(&conn_timeout_tid, NULL,
        conn_timeout_thread, NULL)) != 0) {
        fprintf(stderr, ""Can't create idle connection timeout thread: %s\n"",
            strerror(ret));
        return -1;
    }

    return 0;
}",377.0,392.0,1.0,1.0,16.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,int
619,25729,stats_init,1,stats_init,void stats_init (void),memcached.c,"static void stats_init(void) {
    memset(&stats, 0, sizeof(struct stats));
    memset(&stats_state, 0, sizeof(struct stats_state));
    stats_state.accepting_conns = true; /* assuming we start in this state. */

    /* make the time we started always be 2 seconds before we really
       did, so time(0) - time.started is never zero.  if so, things
       like 'settings.oldest_live' which act as booleans as well as
       values are now false in boolean context... */
    process_started = time(0) - ITEM_UPDATE_INTERVAL - 2;
    stats_prefix_init(settings.prefix_delimiter);
}",197.0,208.0,1.0,32.0,12.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
620,25734,conn_to_str,1,conn_to_str,"void conn_to_str (conn*,char*,char*)",memcached.c,"static void conn_to_str(const conn *c, char *addr, char *svr_addr) {
    if (!c) {
        memcpy(addr, ""<null>"", 6);
    } else if (c->state == conn_closed) {
        memcpy(addr, ""<closed>"", 8);
    } else {
        struct sockaddr_in6 local_addr;
        struct sockaddr *sock_addr = (void *)&c->request_addr;

        /* For listen ports and idle UDP ports, show listen address */
        if (c->state == conn_listening ||
                (IS_UDP(c->transport) &&
                 c->state == conn_read)) {
            socklen_t local_addr_len = sizeof(local_addr);

            if (getsockname(c->sfd,
                        (struct sockaddr *)&local_addr,
                        &local_addr_len) == 0) {
                sock_addr = (struct sockaddr *)&local_addr;
            }
        }
        get_conn_text(c, sock_addr->sa_family, addr, sock_addr);

        if (c->state != conn_listening && !(IS_UDP(c->transport) &&
                 c->state == conn_read)) {
            struct socka...",2114.0,2145.0,1.0,17.0,32.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,void
621,25741,settings_init,1,settings_init,void settings_init (void),memcached.c,"static void settings_init(void) {
    settings.use_cas = true;
    settings.access = 0700;
    settings.port = 11211;
    settings.udpport = 0;
#ifdef TLS
    settings.ssl_enabled = false;
    settings.ssl_ctx = NULL;
    settings.ssl_chain_cert = NULL;
    settings.ssl_key = NULL;
    settings.ssl_verify_mode = SSL_VERIFY_NONE;
    settings.ssl_keyformat = SSL_FILETYPE_PEM;
    settings.ssl_ciphers = NULL;
    settings.ssl_ca_cert = NULL;
    settings.ssl_last_cert_refresh_time = current_time;
    settings.ssl_wbuf_size = 16 * 1024; // default is 16KB (SSL max frame size is 17KB)
    settings.ssl_session_cache = false;
    settings.ssl_kernel_tls = false;
    settings.ssl_min_version = TLS1_2_VERSION;
#endif
    /* By default this string should be NULL for getaddrinfo() */
    settings.inter = NULL;
    settings.maxbytes = 64 * 1024 * 1024; /* default is 64MB */
    settings.maxconns = 1024;         /* to limit connections-related memory to about 5MB */
    settings.verbose = 0;
  ...",219.0,298.0,1.0,32.0,80.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
622,25753,conn_close,1,conn_close,void conn_close (conn*),memcached.c,"static void conn_close(conn *c) {
    assert(c != NULL);

    if (c->thread) {
        LOGGER_LOG(c->thread->l, LOG_CONNEVENTS, LOGGER_CONNECTION_CLOSE, NULL,
                &c->request_addr, c->request_addr_size, c->transport,
                c->close_reason, c->sfd);
    }

    /* delete the event, the socket and the conn */
    event_del(&c->event);

    if (settings.verbose > 1)
        fprintf(stderr, ""<%d connection closed.\n"", c->sfd);

    conn_cleanup(c);

    // force release of read buffer.
    if (c->thread) {
        c->rbytes = 0;
        rbuf_release(c);
    }

    MEMCACHED_CONN_RELEASE(c->sfd);
    conn_set_state(c, conn_closed);
#ifdef TLS
    if (c->ssl) {
        SSL_shutdown(c->ssl);
        SSL_free(c->ssl);
    }
#endif
    close(c->sfd);
    c->close_reason = 0;
    pthread_mutex_lock(&conn_lock);
    allow_new_conns = true;
    pthread_mutex_unlock(&conn_lock);

    STATS_LOCK();
    stats_state.curr_conns--;
    STATS_UNLOCK();

    return;
}",919.0,961.0,1.0,8.0,43.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
623,25758,conn_init,1,conn_init,void conn_init (void),memcached.c,"static void conn_init(void) {
    /* We're unlikely to see an FD much higher than maxconns. */
    int next_fd = dup(1);
    if (next_fd < 0) {
        perror(""Failed to duplicate file descriptor\n"");
        exit(1);
    }
    int headroom = 10;      /* account for extra unexpected open FDs */
    struct rlimit rl;

    max_fds = settings.maxconns + headroom + next_fd;

    /* But if possible, get the actual highest FD we can possibly ever see. */
    if (getrlimit(RLIMIT_NOFILE, &rl) == 0) {
        max_fds = rl.rlim_max;
    } else {
        fprintf(stderr, ""Failed to query maximum file descriptor; ""
                        ""falling back to maxconns\n"");
    }

    close(next_fd);

    if ((conns = calloc(max_fds, sizeof(conn *))) == NULL) {
        fprintf(stderr, ""Failed to allocate connection structures\n"");
        /* This is unrecoverable so bail out early. */
        exit(1);
    }
}",466.0,493.0,1.0,1.0,28.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
624,25763,update_event,1,update_event,"bool update_event (conn*,int)",memcached.c,"static bool update_event(conn *c, const int new_flags) {
    assert(c != NULL);

    struct event_base *base = c->event.ev_base;
    if (c->ev_flags == new_flags)
        return true;
    if (event_del(&c->event) == -1) return false;
    event_set(&c->event, c->sfd, new_flags, event_handler, (void *)c);
    event_base_set(base, &c->event);
    c->ev_flags = new_flags;
    if (event_add(&c->event, 0) == -1) return false;
    return true;
}",2498.0,2510.0,1.0,1.0,13.0,0,0,0,0,3,0,1,1,0,0,,0,0,4,2,2,bool
625,25774,conn_free,1,conn_free,void conn_free (conn*),memcached.c,"void conn_free(conn *c) {
    if (c) {
        assert(c != NULL);
        assert(c->sfd >= 0 && c->sfd < max_fds);

        MEMCACHED_CONN_DESTROY(c);
        conns[c->sfd] = NULL;
        if (c->rbuf)
            free(c->rbuf);
#ifdef TLS
        if (c->ssl_wbuf)
            c->ssl_wbuf = NULL;
#endif

        free(c);
    }
}",901.0,917.0,1.0,8.0,17.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
626,25868,maxconns_handler,1,maxconns_handler,"void maxconns_handler (evutil_socket_t,short,void*)",memcached.c,"static void maxconns_handler(const evutil_socket_t fd, const short which, void *arg) {
    struct timeval t = {.tv_sec = 0, .tv_usec = 10000};

    if (fd == -42 || allow_new_conns == false) {
        /* reschedule in 10ms if we need to keep polling */
        evtimer_set(&maxconnsevent, maxconns_handler, 0);
        event_base_set(main_base, &maxconnsevent);
        evtimer_add(&maxconnsevent, &t);
    } else {
        evtimer_del(&maxconnsevent);
        accept_new_conns(true);
    }
}",158.0,170.0,1.0,1.0,13.0,12,6,11,8,0,5,2,2,1,0,,0,5,6,3,3,void
627,25918,realtime,1,realtime,rel_time_t realtime (time_t),memcached.c,"rel_time_t realtime(const time_t exptime) {
    /* no. of seconds in 30 days - largest possible delta exptime */

    if (exptime == 0) return 0; /* 0 means never expire */

    if (exptime > REALTIME_MAXDELTA) {
        /* if item expiration is at/before the server started, give it an
           expiration time of 1 second after the server started.
           (because 0 means don't expire).  without this, we'd
           underflow and wrap around to some large value way in the
           future, effectively making items expiring in the past
           really expiring never */
        if (exptime <= process_started)
            return (rel_time_t)1;
        return (rel_time_t)(exptime - process_started);
    } else {
        return (rel_time_t)(exptime + current_time);
    }
}",177.0,195.0,1.0,18.0,19.0,9,6,6,2,5,0,4,5,0,0,,0,0,2,1,1,rel_time_t
628,26002,stats_reset,1,stats_reset,void stats_reset (void),memcached.c,"void stats_reset(void) {
    STATS_LOCK();
    memset(&stats, 0, sizeof(struct stats));
    stats_prefix_clear();
    STATS_UNLOCK();
    threadlocal_stats_reset();
    item_stats_reset();
}",210.0,217.0,1.0,1.0,8.0,2,2,2,2,0,6,1,1,0,3,,0,1,2,1,1,void
629,26336,conn_timeout_thread,1,conn_timeout_thread,void* conn_timeout_thread (void*),memcached.c,"static void *conn_timeout_thread(void *arg) {
    int i;
    conn *c;
    rel_time_t oldest_last_cmd;
    int sleep_time;
    int sleep_slice = max_fds / CONNS_PER_SLICE;
    if (sleep_slice == 0)
        sleep_slice = CONNS_PER_SLICE;

    useconds_t timeslice = 1000000 / sleep_slice;

    mutex_lock(&conn_timeout_lock);
    while(do_run_conn_timeout_thread) {
        if (settings.verbose > 2)
            fprintf(stderr, ""idle timeout thread at top of connection list\n"");

        oldest_last_cmd = current_time;

        for (i = 0; i < max_fds; i++) {
            if ((i % CONNS_PER_SLICE) == 0) {
                if (settings.verbose > 2)
                    fprintf(stderr, ""idle timeout thread sleeping for %ulus\n"",
                        (unsigned int)timeslice);
                usleep(timeslice);
            }

            if (!conns[i])
                continue;

            c = conns[i];

            if (!IS_TCP(c->transport))
                continue;

            if (c->sta...",309.0,375.0,1.0,32.0,67.0,56,17,58,20,0,27,16,30,16,1,,0,26,2,1,1,void*
630,26600,stop_conn_timeout_thread,1,stop_conn_timeout_thread,int stop_conn_timeout_thread (void),memcached.c,"int stop_conn_timeout_thread(void) {
    if (!do_run_conn_timeout_thread)
        return -1;
    mutex_lock(&conn_timeout_lock);
    do_run_conn_timeout_thread = 0;
    pthread_cond_signal(&conn_timeout_cond);
    mutex_unlock(&conn_timeout_lock);
    pthread_join(conn_timeout_tid, NULL);
    return 0;
}",394.0,403.0,1.0,4.0,10.0,8,4,9,5,0,8,2,2,1,0,,0,8,2,1,1,int
631,26637,rbuf_release,1,rbuf_release,void rbuf_release (conn*),memcached.c,"static void rbuf_release(conn *c) {
    if (c->rbuf != NULL && c->rbytes == 0 && !IS_UDP(c->transport)) {
        if (c->rbuf_malloced) {
            free(c->rbuf);
            c->rbuf_malloced = false;
        } else {
            do_cache_free(c->thread->rbuf_cache, c->rbuf);
        }
        c->rsize = 0;
        c->rbuf = NULL;
        c->rcurr = NULL;
    }
}",408.0,420.0,1.0,46.0,13.0,20,6,15,4,0,10,3,4,5,0,,0,10,2,1,1,void
632,26707,rbuf_alloc,1,rbuf_alloc,bool rbuf_alloc (conn*),memcached.c,"static bool rbuf_alloc(conn *c) {
    if (c->rbuf == NULL) {
        c->rbuf = do_cache_alloc(c->thread->rbuf_cache);
        if (!c->rbuf) {
            THR_STATS_LOCK(c);
            c->thread->stats.read_buf_oom++;
            THR_STATS_UNLOCK(c);
            return false;
        }
        c->rsize = READ_BUFFER_SIZE;
        c->rcurr = c->rbuf;
    }
    return true;
}",422.0,435.0,1.0,12.0,14.0,25,7,15,4,0,11,3,4,2,1,,0,11,2,1,1,bool
633,26785,rbuf_switch_to_malloc,1,rbuf_switch_to_malloc,bool rbuf_switch_to_malloc (conn*),memcached.c,"bool rbuf_switch_to_malloc(conn *c) {
    // Might as well start with x2 and work from there.
    size_t size = c->rsize * 2;
    char *tmp = malloc(size);
    if (!tmp)
        return false;

    memcpy(tmp, c->rcurr, c->rbytes);
    do_cache_free(c->thread->rbuf_cache, c->rbuf);

    c->rcurr = c->rbuf = tmp;
    c->rsize = size;
    c->rbuf_malloced = true;
    return true;
}",440.0,454.0,1.0,1.0,15.0,18,4,19,5,2,10,2,2,0,1,,0,9,2,1,1,bool
634,26915,prot_text,1,prot_text,const char* prot_text (protocol),memcached.c,"static const char *prot_text(enum protocol prot) {
    char *rv = ""unknown"";
    switch(prot) {
        case ascii_prot:
            rv = ""ascii"";
            break;
        case binary_prot:
            rv = ""binary"";
            break;
        case negotiating_prot:
            rv = ""auto-negotiate"";
            break;
#ifdef PROXY
        case proxy_prot:
            rv = ""proxy"";
            break;
#endif
    }
    return rv;
}",495.0,514.0,1.0,1.0,20.0,4,1,9,5,4,0,5,2,0,0,,0,0,2,1,1,const char*
635,26947,conn_close_idle,1,conn_close_idle,void conn_close_idle (conn*),memcached.c,"void conn_close_idle(conn *c) {
    if (settings.idle_timeout > 0 &&
        (current_time - c->last_cmd_time) > settings.idle_timeout) {
        if (c->state != conn_new_cmd && c->state != conn_read) {
            if (settings.verbose > 1)
                fprintf(stderr,
                    ""fd %d wants to timeout, but isn't in read state"", c->sfd);
            return;
        }

        if (settings.verbose > 1)
            fprintf(stderr, ""Closing idle fd %d\n"", c->sfd);

        pthread_mutex_lock(&c->thread->stats.mutex);
        c->thread->stats.idle_kicks++;
        pthread_mutex_unlock(&c->thread->stats.mutex);

        c->close_reason = IDLE_TIMEOUT_CLOSE;

        conn_set_state(c, conn_closing);
        drive_machine(c);
    }
}",516.0,538.0,1.0,1.0,23.0,32,9,22,8,0,19,5,9,11,2,,0,17,2,1,1,void
636,27045,conn_worker_readd,1,conn_worker_readd,void conn_worker_readd (conn*),memcached.c,"void conn_worker_readd(conn *c) {
    if (c->state == conn_io_queue) {
        c->io_queues_submitted--;
        // If we're still waiting for other queues to return, don't re-add the
        // connection yet.
        if (c->io_queues_submitted != 0) {
            return;
        }
    }
    c->ev_flags = EV_READ | EV_PERSIST;
    event_set(&c->event, c->sfd, c->ev_flags, event_handler, (void *)c);
    event_base_set(c->thread->base, &c->event);

    // TODO: call conn_cleanup/fail/etc
    if (event_add(&c->event, 0) == -1) {
        perror(""event_add"");
    }

    // side thread wanted us to close immediately.
    if (c->state == conn_closing) {
        drive_machine(c);
        return;
    } else if (c->state == conn_io_queue) {
        // machine will know how to return based on secondary state.
        drive_machine(c);
    } else {
        conn_set_state(c, conn_new_cmd);
    }
}",541.0,569.0,1.0,1.0,29.0,24,9,18,6,0,9,5,6,3,1,,0,8,2,1,1,void
637,27140,thread_io_queue_add,1,thread_io_queue_add,"void thread_io_queue_add (LIBEVENT_THREAD*,int,void*,io_queue_stack_cb,io_queue_stack_cb,io_queue_cb,io_queue_cb)",memcached.c,"void thread_io_queue_add(LIBEVENT_THREAD *t, int type, void *ctx, io_queue_stack_cb cb, io_queue_stack_cb com_cb, io_queue_cb ret_cb, io_queue_cb fin_cb) {
    io_queue_cb_t *q = t->io_queues;
    while (q->type != IO_QUEUE_NONE) {
        q++;
    }
    q->type = type;
    q->ctx = ctx;
    q->submit_cb = cb;
    q->complete_cb = com_cb;
    q->finalize_cb = fin_cb;
    q->return_cb   = ret_cb;
    return;
}",571.0,583.0,1.0,22.0,13.0,17,4,16,8,1,1,2,2,0,0,,0,1,14,7,7,void
638,27199,conn_io_queue_setup,1,conn_io_queue_setup,void conn_io_queue_setup (conn*),memcached.c,"void conn_io_queue_setup(conn *c) {
    io_queue_cb_t *qcb = c->thread->io_queues;
    io_queue_t *q = c->io_queues;
    while (qcb->type != IO_QUEUE_NONE) {
        q->type = qcb->type;
        q->ctx = qcb->ctx;
        q->stack_ctx = NULL;
        q->count = 0;
        qcb++;
        q++;
    }
}",585.0,596.0,1.0,24.0,12.0,19,4,14,4,0,2,2,2,0,0,,0,2,2,1,1,void
639,27255,conn_io_queue_reset,1,conn_io_queue_reset,void conn_io_queue_reset (conn*),memcached.c,"static void conn_io_queue_reset(conn *c) {
    for (io_queue_t *q = c->io_queues; q->type != IO_QUEUE_NONE; q++) {
        assert(q->count == 0);
        q->stack_ctx = NULL;
    }
}",599.0,604.0,1.0,50.0,6.0,8,4,6,3,1,1,2,2,0,0,,0,1,2,1,1,void
640,27289,thread_io_queue_get,1,thread_io_queue_get,"io_queue_cb_t thread_io_queue_get (LIBEVENT_THREAD*,int)",memcached.c,"io_queue_cb_t *thread_io_queue_get(LIBEVENT_THREAD *t, int type) {
    io_queue_cb_t *q = t->io_queues;
    while (q->type != IO_QUEUE_NONE) {
        if (q->type == type) {
            return q;
        }
        q++;
    }
    return NULL;
}",606.0,615.0,1.0,22.0,10.0,7,5,8,4,2,1,3,4,0,0,,0,1,4,2,2,io_queue_cb_t
641,27323,conn_io_queue_get,1,conn_io_queue_get,"io_queue_t conn_io_queue_get (conn*,int)",memcached.c,"io_queue_t *conn_io_queue_get(conn *c, int type) {
    io_queue_t *q = c->io_queues;
    while (q->type != IO_QUEUE_NONE) {
        if (q->type == type) {
            return q;
        }
        q++;
    }
    return NULL;
}",617.0,626.0,1.0,22.0,10.0,7,5,8,4,1,1,3,4,0,0,,0,1,4,2,2,io_queue_t
642,27357,conn_io_queue_complete,1,conn_io_queue_complete,void conn_io_queue_complete (conn*),memcached.c,"static void conn_io_queue_complete(conn *c) {
    io_queue_t *q = c->io_queues;
    io_queue_cb_t *qcb = c->thread->io_queues;
    while (q->type != IO_QUEUE_NONE) {
        if (q->stack_ctx) {
            qcb->complete_cb(q);
        }
        qcb++;
        q++;
    }
}",631.0,641.0,1.0,22.0,11.0,11,4,10,3,0,2,3,4,0,0,,0,2,2,1,1,void
643,27399,conn_io_queue_return,1,conn_io_queue_return,void conn_io_queue_return (io_pending_t*),memcached.c,"void conn_io_queue_return(io_pending_t *io) {
    io_queue_cb_t *q = thread_io_queue_get(io->thread, io->io_queue_type);
    q->return_cb(io);
    return;
}",644.0,648.0,1.0,1.0,5.0,4,2,5,2,0,1,1,1,0,1,,0,1,2,1,1,void
644,27420,conn_new,1,conn_new,"conn conn_new (int,conn_states,int,int,network_transport,event_base*,void*,uint64_t,protocol)",memcached.c,"conn *conn_new(const int sfd, enum conn_states init_state,
                const int event_flags,
                const int read_buffer_size, enum network_transport transport,
                struct event_base *base, void *ssl, uint64_t conntag,
                enum protocol bproto) {
    conn *c;

    assert(sfd >= 0 && sfd < max_fds);
    c = conns[sfd];

    if (NULL == c) {
        if (!(c = (conn *)calloc(1, sizeof(conn)))) {
            STATS_LOCK();
            stats.malloc_fails++;
            STATS_UNLOCK();
            fprintf(stderr, ""Failed to allocate connection object\n"");
            return NULL;
        }
        MEMCACHED_CONN_CREATE(c);
        c->read = NULL;
        c->sendmsg = NULL;
        c->write = NULL;
        c->rbuf = NULL;

        c->rsize = read_buffer_size;

        // UDP connections use a persistent static buffer.
        if (c->rsize) {
            c->rbuf = (char *)malloc((size_t)c->rsize);
        }

        if (c->rsize && c->rbuf == NULL) {
  ...",650.0,840.0,1.0,8.0,191.0,142,17,133,30,1,67,13,18,9,3,,0,56,18,9,9,conn
645,27998,conn_release_items,1,conn_release_items,void conn_release_items (conn*),memcached.c,"void conn_release_items(conn *c) {
    assert(c != NULL);

    if (c->item) {
        if (c->item_malloced) {
            free(c->item);
            c->item_malloced = false;
        } else {
            item_remove(c->item);
        }
        c->item = 0;
    }

    // Cull any unsent responses.
    if (c->resp_head) {
        mc_resp *resp = c->resp_head;
        // r_f() handles the chain maintenance.
        while (resp) {
            // temporary by default. hide behind a debug flag in the future:
            // double free detection. Transmit loops can drop out early, but
            // here we could infinite loop.
            if (resp->free) {
                fprintf(stderr, ""ERROR: double free detected during conn_release_items(): [%d] [%s]\n"",
                        c->sfd, c->protocol == binary_prot ? ""binary"" : ""ascii"");
                // Since this is a critical failure, just leak the memory.
                // If these errors are seen, an abort() can be used instead.
...",842.0,876.0,1.0,1.0,35.0,21,5,25,6,2,12,7,10,3,2,,0,11,2,1,1,void
646,28088,conn_cleanup,1,conn_cleanup,void conn_cleanup (conn*),memcached.c,"static void conn_cleanup(conn *c) {
    assert(c != NULL);

    conn_release_items(c);
#ifdef PROXY
    if (c->proxy_coro_ref) {
        proxy_cleanup_conn(c);
    }
#endif
    if (c->sasl_conn) {
        assert(settings.sasl);
        sasl_dispose(&c->sasl_conn);
        c->sasl_conn = NULL;
    }

    if (IS_UDP(c->transport)) {
        conn_set_state(c, conn_read);
    }
}",878.0,896.0,1.0,8.0,19.0,8,5,12,5,0,8,3,3,3,2,,0,6,2,1,1,void
647,28310,conn_close_all,1,conn_close_all,void conn_close_all (void),memcached.c,"void conn_close_all(void) {
    int i;
    for (i = 0; i < max_fds; i++) {
        if (conns[i] && conns[i]->state != conn_closed) {
            conn_close(conns[i]);
        }
    }
}",966.0,973.0,1.0,1.0,8.0,8,6,10,4,0,5,3,4,3,1,,0,4,2,1,1,void
648,28344,state_text,1,state_text,const char* state_text (conn_states),memcached.c,"static const char *state_text(enum conn_states state) {
    const char* const statenames[] = { ""conn_listening"",
                                       ""conn_new_cmd"",
                                       ""conn_waiting"",
                                       ""conn_read"",
                                       ""conn_parse_cmd"",
                                       ""conn_write"",
                                       ""conn_nread"",
                                       ""conn_swallow"",
                                       ""conn_closing"",
                                       ""conn_mwrite"",
                                       ""conn_closed"",
                                       ""conn_watch"",
                                       ""conn_io_queue"" };
    return statenames[state];
}",978.0,993.0,1.0,1.0,16.0,3,3,3,2,3,0,1,1,0,0,,0,0,2,1,1,const char*
649,28370,conn_set_state,1,conn_set_state,"void conn_set_state (conn*,conn_states)",memcached.c,"void conn_set_state(conn *c, enum conn_states state) {
    assert(c != NULL);
    assert(state >= conn_listening && state < conn_max_state);

    if (state != c->state) {
        if (settings.verbose > 2) {
            fprintf(stderr, ""%d: going from %s to %s\n"",
                    c->sfd, state_text(c->state),
                    state_text(state));
        }

        if (state == conn_write || state == conn_mwrite) {
            MEMCACHED_PROCESS_COMMAND_END(c->sfd, c->resp->wbuf, c->resp->wbytes);
        }
        c->state = state;
    }
}",1000.0,1016.0,1.0,12.0,17.0,15,10,19,9,35,8,4,6,3,2,,0,6,4,2,2,void
650,28428,resp_reset,1,resp_reset,void resp_reset (mc_resp*),memcached.c,"void resp_reset(mc_resp *resp) {
    if (resp->item) {
        item_remove(resp->item);
        resp->item = NULL;
    }
    if (resp->write_and_free) {
        free(resp->write_and_free);
        resp->write_and_free = NULL;
    }
    resp->wbytes = 0;
    resp->tosend = 0;
    resp->iovcnt = 0;
    resp->chunked_data_iov = 0;
    resp->chunked_total = 0;
    resp->skip = false;
}",1021.0,1036.0,1.0,1.0,16.0,20,2,15,3,2,1,3,3,0,1,,0,0,2,1,1,void
651,28491,resp_add_iov,1,resp_add_iov,"void resp_add_iov (mc_resp*,void*,int)",memcached.c,"void resp_add_iov(mc_resp *resp, const void *buf, int len) {
    assert(resp->iovcnt < MC_RESP_IOVCOUNT);
    int x = resp->iovcnt;
    resp->iov[x].iov_base = (void *)buf;
    resp->iov[x].iov_len = len;
    resp->iovcnt++;
    resp->tosend += len;
}",1038.0,1045.0,1.0,26.0,8.0,17,8,12,4,15,0,1,1,0,0,,0,0,6,3,3,void
652,28541,resp_add_chunked_iov,1,resp_add_chunked_iov,"void resp_add_chunked_iov (mc_resp*,void*,int)",memcached.c,"void resp_add_chunked_iov(mc_resp *resp, const void *buf, int len) {
    resp->chunked_data_iov = resp->iovcnt;
    resp->chunked_total = len;
    resp_add_iov(resp, buf, len);
}",1050.0,1054.0,1.0,1.0,5.0,5,2,7,3,0,1,1,1,0,1,,0,0,6,3,3,void
653,28564,resp_allocate,1,resp_allocate,mc_resp resp_allocate (conn*),memcached.c,"static mc_resp* resp_allocate(conn *c) {
    LIBEVENT_THREAD *th = c->thread;
    mc_resp *resp = NULL;
    mc_resp_bundle *b = th->open_bundle;

    if (b != NULL) {
        for (int i = 0; i < MAX_RESP_PER_BUNDLE; i++) {
            // loop around starting from the most likely to be free
            int x = (i + b->next_check) % MAX_RESP_PER_BUNDLE;
            if (b->r[x].free) {
                resp = &b->r[x];
                b->next_check = x+1;
                break;
            }
        }

        if (resp != NULL) {
            b->refcount++;
            resp->free = false;
            if (b->refcount == MAX_RESP_PER_BUNDLE) {
                assert(b->prev == NULL);
                // We only allocate off the head. Assign new head.
                th->open_bundle = b->next;
                // Remove ourselves from the list.
                if (b->next) {
                    b->next->prev = 0;
                    b->next = 0;
                }
            }
        }
    }...",1061.0,1117.0,1.0,28.0,57.0,99,15,72,11,1,10,11,22,0,1,,0,10,2,1,1,mc_resp
654,28849,resp_free,1,resp_free,"void resp_free (conn*,mc_resp*)",memcached.c,"static void resp_free(conn *c, mc_resp *resp) {
    LIBEVENT_THREAD *th = c->thread;
    mc_resp_bundle *b = resp->bundle;

    resp->free = true;
    b->refcount--;
    if (b->refcount == 0) {
        if (b == th->open_bundle && b->next == 0) {
            // This is the final bundle. Just hold and reuse to skip init loop
            assert(b->prev == 0);
            b->next_check = 0;
        } else {
            // Assert that we're either in the list or at the head.
            assert((b->next || b->prev) || b == th->open_bundle);

            // unlink from list.
            mc_resp_bundle **head = &th->open_bundle;
            if (*head == b) *head = b->next;
            // Not tracking the tail.
            assert(b->next != b && b->prev != b);

            if (b->next) b->next->prev = b->prev;
            if (b->prev) b->prev->next = b->next;

            // Now completely done with this buffer.
            do_cache_free(th->rbuf_cache, b);
            THR_STATS_LOCK(c);
   ...",1119.0,1163.0,1.0,12.0,45.0,19,5,13,5,1,2,3,4,1,0,,0,2,4,2,2,void
655,29075,resp_start,1,resp_start,bool resp_start (conn*),memcached.c,"bool resp_start(conn *c) {
    mc_resp *resp = resp_allocate(c);
    if (!resp) {
        THR_STATS_LOCK(c);
        c->thread->stats.response_obj_oom++;
        THR_STATS_UNLOCK(c);
        return false;
    }
    // handling the stats counters here to simplify testing
    THR_STATS_LOCK(c);
    c->thread->stats.response_obj_count++;
    THR_STATS_UNLOCK(c);
    // Skip zeroing the bundle pointer at the start.
    // TODO: this line is here temporarily to make the code easy to disable.
    // when it's more mature, move the memset into resp_allocate() and have it
    // set the bundle pointer on allocate so this line isn't as complex.
    memset((char *)resp + sizeof(mc_resp_bundle*), 0, sizeof(*resp) - sizeof(mc_resp_bundle*));
    // TODO: this next line works. memset _does_ show up significantly under
    // perf reports due to zeroing out the entire resp->wbuf. before swapping
    // the lines more validation work should be done to ensure wbuf's aren't
    // accidentally reuse...",1165.0,1203.0,1.0,8.0,39.0,56,12,34,6,6,19,5,5,4,1,,0,19,2,1,1,bool
656,29246,resp_finish,1,resp_finish,"mc_resp resp_finish (conn*,mc_resp*)",memcached.c,"mc_resp* resp_finish(conn *c, mc_resp *resp) {
    mc_resp *next = resp->next;
    if (resp->item) {
        // TODO: cache hash value in resp obj?
        item_remove(resp->item);
        resp->item = NULL;
    }
    if (resp->write_and_free) {
        free(resp->write_and_free);
    }
    if (resp->io_pending) {
        // If we had a pending IO, tell it to internally clean up then return
        // the main object back to our thread cache.
        io_queue_cb_t *qcb = thread_io_queue_get(c->thread, resp->io_pending->io_queue_type);
        qcb->finalize_cb(resp->io_pending);
        do_cache_free(c->thread->io_cache, resp->io_pending);
        resp->io_pending = NULL;
    }
    if (c->resp_head == resp) {
        c->resp_head = next;
    }
    if (c->resp == resp) {
        c->resp = NULL;
    }
    resp_free(c, resp);
    THR_STATS_LOCK(c);
    c->thread->stats.response_obj_count--;
    THR_STATS_UNLOCK(c);
    return next;
}",1206.0,1235.0,1.0,4.0,30.0,40,6,34,5,5,13,6,6,2,4,,0,10,4,2,2,mc_resp
657,29380,resp_has_stack,1,resp_has_stack,bool resp_has_stack (conn*),memcached.c,"bool resp_has_stack(conn *c) {
    return c->resp_head->next != NULL ? true : false;
}",1238.0,1240.0,1.0,1.0,3.0,4,3,4,4,1,1,1,1,0,0,,0,1,2,1,1,bool
658,29396,out_string,1,out_string,"void out_string (conn*,char*)",memcached.c,"void out_string(conn *c, const char *str) {
    size_t len;
    assert(c != NULL);
    mc_resp *resp = c->resp;

    // if response was original filled with something, but we're now writing
    // out an error or similar, have to reset the object first.
    // TODO: since this is often redundant with allocation, how many callers
    // are actually requiring it be reset? Can we fast test by just looking at
    // tosend and reset if nonzero?
    resp_reset(resp);

    if (c->noreply) {
        // TODO: just invalidate the response since nothing's been attempted
        // to send yet?
        resp->skip = true;
        if (settings.verbose > 1)
            fprintf(stderr, "">%d NOREPLY %s\n"", c->sfd, str);
        conn_set_state(c, conn_new_cmd);
        return;
    }

    if (settings.verbose > 1)
        fprintf(stderr, "">%d %s\n"", c->sfd, str);

    // Fill response object with static string.

    len = strlen(str);
    if ((len + 2) > WRITE_BUFFER_SIZE) {
        /* ought to be a...",1242.0,1282.0,1.0,20.0,41.0,22,6,34,9,68,12,5,6,5,4,,0,8,4,2,2,void
659,29503,out_errstring,1,out_errstring,"void out_errstring (conn*,char*)",memcached.c,"void out_errstring(conn *c, const char *str) {
    c->noreply = false;
    out_string(c, str);
}",1286.0,1289.0,1.0,1.0,4.0,2,2,4,3,15,2,1,1,0,1,,0,1,4,2,2,void
660,29517,out_of_memory,1,out_of_memory,"void out_of_memory (conn*,char*)",memcached.c,"void out_of_memory(conn *c, char *ascii_error) {
    const static char error_prefix[] = ""SERVER_ERROR "";
    const static int error_prefix_len = sizeof(error_prefix) - 1;

    if (c->protocol == binary_prot) {
        /* Strip off the generic error prefix; it's irrelevant in binary */
        if (!strncmp(ascii_error, error_prefix, error_prefix_len)) {
            ascii_error += error_prefix_len;
        }
        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, ascii_error, 0);
    } else {
        out_string(c, ascii_error);
    }
}",1295.0,1308.0,1.0,1.0,14.0,8,7,13,6,3,1,3,4,0,1,,0,0,4,2,2,void
661,29561,append_bin_stats,1,append_bin_stats,"void append_bin_stats (char*,uint16_t,char*,uint32_t,conn*)",memcached.c,"static void append_bin_stats(const char *key, const uint16_t klen,
                             const char *val, const uint32_t vlen,
                             conn *c) {
    char *buf = c->stats.buffer + c->stats.offset;
    uint32_t bodylen = klen + vlen;
    protocol_binary_response_header header = {
        .response.magic = (uint8_t)PROTOCOL_BINARY_RES,
        .response.opcode = PROTOCOL_BINARY_CMD_STAT,
        .response.keylen = (uint16_t)htons(klen),
        .response.datatype = (uint8_t)PROTOCOL_BINARY_RAW_BYTES,
        .response.bodylen = htonl(bodylen),
        .response.opaque = c->opaque
    };

    memcpy(buf, header.bytes, sizeof(header.response));
    buf += sizeof(header.response);

    if (klen > 0) {
        memcpy(buf, key, klen);
        buf += klen;

        if (vlen > 0) {
            memcpy(buf, val, vlen);
        }
    }

    c->stats.offset += sizeof(header.response) + bodylen;
}",1310.0,1337.0,1.0,1.0,28.0,45,9,49,17,1,3,3,4,0,0,,0,3,10,5,5,void
662,29797,grow_stats_buf,1,grow_stats_buf,"bool grow_stats_buf (conn*,size_t)",memcached.c,"static bool grow_stats_buf(conn *c, size_t needed) {
    size_t nsize = c->stats.size;
    size_t available = nsize - c->stats.offset;
    bool rv = true;

    /* Special case: No buffer -- need to allocate fresh */
    if (c->stats.buffer == NULL) {
        nsize = 1024;
        available = c->stats.size = c->stats.offset = 0;
    }

    while (needed > available) {
        assert(nsize > 0);
        nsize = nsize << 1;
        available = nsize - c->stats.offset;
    }

    if (nsize != c->stats.size) {
        char *ptr = realloc(c->stats.buffer, nsize);
        if (ptr) {
            c->stats.buffer = ptr;
            c->stats.size = nsize;
        } else {
            STATS_LOCK();
            stats.malloc_fails++;
            STATS_UNLOCK();
            rv = false;
        }
    }

    return rv;
}",1358.0,1389.0,1.0,1.0,32.0,39,8,32,8,1,0,5,6,0,0,,0,0,4,2,2,bool
663,29924,append_stats,1,append_stats,"void append_stats (char*,uint16_t,char*,uint32_t,void*)",memcached.c,"void append_stats(const char *key, const uint16_t klen,
                  const char *val, const uint32_t vlen,
                  const void *cookie)
{
    /* value without a key is invalid */
    if (klen == 0 && vlen > 0) {
        return;
    }

    conn *c = (conn*)cookie;

    if (c->protocol == binary_prot) {
        size_t needed = vlen + klen + sizeof(protocol_binary_response_header);
        if (!grow_stats_buf(c, needed)) {
            return;
        }
        append_bin_stats(key, klen, val, vlen, c);
    } else {
        size_t needed = vlen + klen + 10; // 10 == ""STAT = \r\n""
        if (!grow_stats_buf(c, needed)) {
            return;
        }
        append_ascii_stats(key, klen, val, vlen, c);
    }

    assert(c->stats.offset <= c->stats.size);
}",1391.0,1417.0,1.0,1.0,27.0,17,11,19,9,1,2,4,5,1,2,,0,1,10,5,5,void
664,30013,reset_cmd_handler,1,reset_cmd_handler,void reset_cmd_handler (conn*),memcached.c,"static void reset_cmd_handler(conn *c) {
    c->cmd = -1;
    c->substate = bin_no_state;
    if (c->item != NULL) {
        // TODO: Any other way to get here?
        // SASL auth was mistakenly using it. Nothing else should?
        if (c->item_malloced) {
            free(c->item);
            c->item_malloced = false;
        } else {
            item_remove(c->item);
        }
        c->item = NULL;
    }
    if (c->rbytes > 0) {
        conn_set_state(c, conn_parse_cmd);
    } else if (c->resp_head) {
        conn_set_state(c, conn_mwrite);
    } else {
        conn_set_state(c, conn_waiting);
    }
}",1419.0,1440.0,1.0,1.0,22.0,15,5,14,5,0,9,4,5,3,1,,0,8,2,1,1,void
665,30127,_store_item_copy_chunks,1,_store_item_copy_chunks,"int _store_item_copy_chunks (item*,item*,int)",memcached.c,"static int _store_item_copy_chunks(item *d_it, item *s_it, const int len) {
    item_chunk *dch = (item_chunk *) ITEM_schunk(d_it);
    /* Advance dch until we find free space */
    while (dch->size == dch->used) {
        if (dch->next) {
            dch = dch->next;
        } else {
            break;
        }
    }

    if (s_it->it_flags & ITEM_CHUNKED) {
        int remain = len;
        item_chunk *sch = (item_chunk *) ITEM_schunk(s_it);
        int copied = 0;
        /* Fills dch's to capacity, not straight copy sch in case data is
         * being added or removed (ie append/prepend)
         */
        while (sch && dch && remain) {
            assert(dch->used <= dch->size);
            int todo = (dch->size - dch->used < sch->used - copied)
                ? dch->size - dch->used : sch->used - copied;
            if (remain < todo)
                todo = remain;
            memcpy(dch->data + dch->used, sch->data + copied, todo);
            dch->used += todo;
        ...",1465.0,1533.0,1.0,37.0,69.0,91,15,72,11,2,1,9,20,0,1,,0,1,6,3,3,int
666,30523,_store_item_copy_data,1,_store_item_copy_data,"int _store_item_copy_data (int,item*,item*,item*)",memcached.c,"static int _store_item_copy_data(int comm, item *old_it, item *new_it, item *add_it) {
    if (comm == NREAD_APPEND) {
        if (new_it->it_flags & ITEM_CHUNKED) {
            if (_store_item_copy_chunks(new_it, old_it, old_it->nbytes - 2) == -1 ||
                _store_item_copy_chunks(new_it, add_it, add_it->nbytes) == -1) {
                return -1;
            }
        } else {
            memcpy(ITEM_data(new_it), ITEM_data(old_it), old_it->nbytes);
            memcpy(ITEM_data(new_it) + old_it->nbytes - 2 /* CRLF */, ITEM_data(add_it), add_it->nbytes);
        }
    } else {
        /* NREAD_PREPEND */
        if (new_it->it_flags & ITEM_CHUNKED) {
            if (_store_item_copy_chunks(new_it, add_it, add_it->nbytes - 2) == -1 ||
                _store_item_copy_chunks(new_it, old_it, old_it->nbytes) == -1) {
                return -1;
            }
        } else {
            memcpy(ITEM_data(new_it), ITEM_data(add_it), add_it->nbytes);
            memcpy(ITEM_data(ne...",1535.0,1559.0,1.0,16.0,25.0,12,6,8,4,1,2,4,7,2,2,,0,2,8,4,4,int
667,30924,do_store_item,1,do_store_item,"enum store_item_type do_store_item (item*,int,conn*,uint32_t)",memcached.c,"enum store_item_type do_store_item(item *it, int comm, conn *c, const uint32_t hv) {
    char *key = ITEM_key(it);
    item *old_it = do_item_get(key, it->nkey, hv, c, DONT_UPDATE);
    enum store_item_type stored = NOT_STORED;

    enum cas_result { CAS_NONE, CAS_MATCH, CAS_BADVAL, CAS_STALE, CAS_MISS };

    item *new_it = NULL;
    uint32_t flags;

    /* Do the CAS test up front so we can apply to all store modes */
    enum cas_result cas_res = CAS_NONE;

    bool do_store = false;
    if (old_it != NULL) {
        // Most of the CAS work requires something to compare to.
        uint64_t it_cas = ITEM_get_cas(it);
        uint64_t old_cas = ITEM_get_cas(old_it);
        if (it_cas == 0) {
            cas_res = CAS_NONE;
        } else if (it_cas == old_cas) {
            cas_res = CAS_MATCH;
        } else if (c->set_stale && it_cas < old_cas) {
            cas_res = CAS_STALE;
        } else {
            cas_res = CAS_BADVAL;
        }

        switch (comm) {
            ca...",1567.0,1726.0,1.0,16.0,160.0,124,19,112,26,2,16,18,23,1,8,,0,11,8,4,4,enum store_item_type
668,31654,write_and_free,1,write_and_free,"void write_and_free (conn*,char*,int)",memcached.c,"void write_and_free(conn *c, char *buf, int bytes) {
    if (buf) {
        mc_resp *resp = c->resp;
        resp->write_and_free = buf;
        resp_add_iov(resp, buf, bytes);
        conn_set_state(c, conn_new_cmd);
    } else {
        out_of_memory(c, ""SERVER_ERROR out of memory writing stats"");
    }
}",1729.0,1738.0,1.0,1.0,10.0,4,2,10,5,0,3,2,2,0,2,,0,1,6,3,3,void
669,31687,append_stat,1,append_stat,"void append_stat (char*,ADD_STAT,conn*,char*...)",memcached.c,"void append_stat(const char *name, ADD_STAT add_stats, conn *c,
                 const char *fmt, ...) {
    char val_str[STAT_VAL_LEN];
    int vlen;
    va_list ap;

    assert(name);
    assert(add_stats);
    assert(c);
    assert(fmt);

    va_start(ap, fmt);
    vlen = vsnprintf(val_str, sizeof(val_str) - 1, fmt, ap);
    va_end(ap);

    add_stats(name, strlen(name), val_str, vlen, c);
}",1740.0,1756.0,1.0,17.0,17.0,3,3,17,7,179,0,1,1,0,0,,0,0,8,4,4,void
670,31728,server_stats,1,server_stats,"void server_stats (ADD_STAT,conn*)",memcached.c,"void server_stats(ADD_STAT add_stats, conn *c) {
    pid_t pid = getpid();
    rel_time_t now = current_time;

    struct thread_stats thread_stats;
    threadlocal_stats_aggregate(&thread_stats);
    struct slab_stats slab_stats;
    slab_stats_aggregate(&thread_stats, &slab_stats);
#ifndef WIN32
    struct rusage usage;
    getrusage(RUSAGE_SELF, &usage);
#endif /* !WIN32 */

    STATS_LOCK();

    APPEND_STAT(""pid"", ""%lu"", (long)pid);
    APPEND_STAT(""uptime"", ""%u"", now - ITEM_UPDATE_INTERVAL);
    APPEND_STAT(""time"", ""%ld"", now + (long)process_started);
    APPEND_STAT(""version"", ""%s"", VERSION);
    APPEND_STAT(""libevent"", ""%s"", event_get_version());
    APPEND_STAT(""pointer_size"", ""%d"", (int)(8 * sizeof(void *)));

#ifndef WIN32
    append_stat(""rusage_user"", add_stats, c, ""%ld.%06ld"",
                (long)usage.ru_utime.tv_sec,
                (long)usage.ru_utime.tv_usec);
    append_stat(""rusage_system"", add_stats, c, ""%ld.%06ld"",
                (long)usage.ru_stime.tv_sec...",1759.0,1903.0,1.0,4.0,145.0,168,8,263,15,1,227,6,6,10,78,,0,147,4,2,2,void
671,32872,process_stat_settings,1,process_stat_settings,"void process_stat_settings (ADD_STAT,void*)",memcached.c,"void process_stat_settings(ADD_STAT add_stats, void *c) {
    assert(add_stats);
    APPEND_STAT(""maxbytes"", ""%llu"", (unsigned long long)settings.maxbytes);
    APPEND_STAT(""maxconns"", ""%d"", settings.maxconns);
    APPEND_STAT(""tcpport"", ""%d"", settings.port);
    APPEND_STAT(""udpport"", ""%d"", settings.udpport);
    APPEND_STAT(""inter"", ""%s"", settings.inter ? settings.inter : ""NULL"");
    APPEND_STAT(""verbosity"", ""%d"", settings.verbose);
    APPEND_STAT(""oldest"", ""%lu"", (unsigned long)settings.oldest_live);
    APPEND_STAT(""evictions"", ""%s"", settings.evict_to_free ? ""on"" : ""off"");
    APPEND_STAT(""domain_socket"", ""%s"",
                settings.socketpath ? settings.socketpath : ""NULL"");
    APPEND_STAT(""umask"", ""%o"", settings.access);
    APPEND_STAT(""shutdown_command"", ""%s"",
                settings.shutdown_command ? ""yes"" : ""no"");
    APPEND_STAT(""growth_factor"", ""%.2f"", settings.factor);
    APPEND_STAT(""chunk_size"", ""%d"", settings.chunk_size);
    APPEND_STAT(""num_threads"", ""%d"",...",1905.0,1998.0,1.0,4.0,94.0,108,3,197,3,0,233,1,1,0,57,,0,178,4,2,2,void
672,33716,get_stats,1,get_stats,"bool get_stats (char*,int,ADD_STAT,void*)",memcached.c,"bool get_stats(const char *stat_type, int nkey, ADD_STAT add_stats, void *c) {
    bool ret = true;

    if (add_stats != NULL) {
        if (!stat_type) {
            /* prepare general statistics for the engine */
            STATS_LOCK();
            APPEND_STAT(""bytes"", ""%llu"", (unsigned long long)stats_state.curr_bytes);
            APPEND_STAT(""curr_items"", ""%llu"", (unsigned long long)stats_state.curr_items);
            APPEND_STAT(""total_items"", ""%llu"", (unsigned long long)stats.total_items);
            STATS_UNLOCK();
            APPEND_STAT(""slab_global_page_pool"", ""%u"", global_page_pool_size(NULL));
            item_stats_totals(add_stats, c);
        } else if (nz_strcmp(nkey, stat_type, ""items"") == 0) {
            item_stats(add_stats, c);
        } else if (nz_strcmp(nkey, stat_type, ""slabs"") == 0) {
            slabs_stats(add_stats, c);
        } else if (nz_strcmp(nkey, stat_type, ""sizes"") == 0) {
            item_stats_sizes(add_stats, c);
        } else if (nz_s...",2005.0,2036.0,1.0,12.0,32.0,9,5,21,8,1,15,3,4,0,7,,0,7,8,4,4,bool
673,33874,get_conn_text,1,get_conn_text,"void get_conn_text (conn*,int,char*,sockaddr*)",memcached.c,"static inline void get_conn_text(const conn *c, const int af,
                char* addr, struct sockaddr *sock_addr) {
    char addr_text[MAXPATHLEN];
    addr_text[0] = '\0';
    const char *protoname = ""?"";
    unsigned short port = 0;

    switch (af) {
        case AF_INET:
            (void) inet_ntop(af,
                    &((struct sockaddr_in *)sock_addr)->sin_addr,
                    addr_text,
                    sizeof(addr_text) - 1);
            port = ntohs(((struct sockaddr_in *)sock_addr)->sin_port);
            protoname = IS_UDP(c->transport) ? ""udp"" : ""tcp"";
            break;

        case AF_INET6:
            addr_text[0] = '[';
            addr_text[1] = '\0';
            if (inet_ntop(af,
                    &((struct sockaddr_in6 *)sock_addr)->sin6_addr,
                    addr_text + 1,
                    sizeof(addr_text) - 2)) {
                strncat(addr_text, ""]"", 2);
            }
            port = ntohs(((struct sockaddr_in6 *)sock_addr)->sin6...",2038.0,2112.0,1.0,24.0,75.0,51,12,53,13,0,4,9,8,0,0,,0,4,8,4,4,void
674,34219,process_stats_conns,1,process_stats_conns,"void process_stats_conns (ADD_STAT,void*)",memcached.c,"void process_stats_conns(ADD_STAT add_stats, void *c) {
    int i;
    char key_str[STAT_KEY_LEN];
    char val_str[STAT_VAL_LEN];
    size_t extras_len = sizeof("":unix:"") + sizeof(""65535"");
    char addr[MAXPATHLEN + extras_len];
    char svr_addr[MAXPATHLEN + extras_len];
    memset(addr, 0, sizeof(addr));
    memset(svr_addr, 0, sizeof(svr_addr));
    int klen = 0, vlen = 0;

    assert(add_stats);

    for (i = 0; i < max_fds; i++) {
        if (conns[i]) {
            /* This is safe to do unlocked because conns are never freed; the
             * worst that'll happen will be a minor inconsistency in the
             * output -- not worth the complexity of the locking that'd be
             * required to prevent it.
             */
            if (IS_UDP(conns[i]->transport)) {
                APPEND_NUM_STAT(i, ""UDP"", ""%s"", ""UDP"");
            }
            if (conns[i]->state != conn_closed) {
                conn_to_str(conns[i], addr, svr_addr);

                APPEND_NUM_...",2147.0,2185.0,1.0,17.0,39.0,49,11,98,17,0,14,6,14,9,2,,0,13,4,2,2,void
675,34475,limited_get,1,limited_get,"item limited_get (char*,size_t,conn*,uint32_t,bool,bool,bool*)",memcached.c,"item* limited_get(char *key, size_t nkey, conn *c, uint32_t exptime, bool should_touch, bool do_update, bool *overflow) {
    item *it;
    if (should_touch) {
        it = item_touch(key, nkey, exptime, c);
    } else {
        it = item_get(key, nkey, c, do_update);
    }
    if (it && it->refcount > IT_REFCOUNT_LIMIT) {
        item_remove(it);
        it = NULL;
        *overflow = true;
    } else {
        *overflow = false;
    }
    return it;
}",2188.0,2203.0,1.0,29.0,16.0,7,5,14,9,3,2,3,3,0,2,,0,1,14,7,7,item
676,34534,limited_get_locked,1,limited_get_locked,"item limited_get_locked (char*,size_t,conn*,bool,uint32_t*,bool*)",memcached.c,"item* limited_get_locked(char *key, size_t nkey, conn *c, bool do_update, uint32_t *hv, bool *overflow) {
    item *it;
    it = item_get_locked(key, nkey, c, do_update, hv);
    if (it && it->refcount > IT_REFCOUNT_LIMIT) {
        do_item_remove(it);
        it = NULL;
        item_unlock(*hv);
        *overflow = true;
    } else {
        *overflow = false;
    }
    return it;
}",2209.0,2221.0,1.0,29.0,13.0,8,5,15,9,0,3,2,2,0,3,,0,1,12,6,6,item
677,34584,do_add_delta,1,do_add_delta,"enum delta_result_type do_add_delta (conn*,char*,size_t,bool,int64_t,char*,uint64_t*,uint32_t,item**)",memcached.c,"enum delta_result_type do_add_delta(conn *c, const char *key, const size_t nkey,
                                    const bool incr, const int64_t delta,
                                    char *buf, uint64_t *cas,
                                    const uint32_t hv,
                                    item **it_ret) {
    char *ptr;
    uint64_t value;
    int res;
    item *it;

    it = do_item_get(key, nkey, hv, c, DONT_UPDATE);
    if (!it) {
        return DELTA_ITEM_NOT_FOUND;
    }

    /* Can't delta zero byte values. 2-byte are the ""\r\n"" */
    /* Also can't delta for chunked items. Too large to be a number */
#ifdef EXTSTORE
    if (it->nbytes <= 2 || (it->it_flags & (ITEM_CHUNKED|ITEM_HDR)) != 0) {
#else
    if (it->nbytes <= 2 || (it->it_flags & (ITEM_CHUNKED)) != 0) {
#endif
        do_item_remove(it);
        return NON_NUMERIC;
    }

    if (cas != NULL && *cas != 0 && ITEM_get_cas(it) != *cas) {
        do_item_remove(it);
        return DELTA_ITEM_CAS_MISMATC...",2234.0,2345.0,1.0,39.0,112.0,120,22,85,22,2,15,10,10,1,10,,0,8,18,9,9,enum delta_result_type
678,35365,try_read_udp,1,try_read_udp,enum try_read_result try_read_udp (conn*),memcached.c,"static enum try_read_result try_read_udp(conn *c) {
    int res;

    assert(c != NULL);

    c->request_addr_size = sizeof(c->request_addr);
    res = recvfrom(c->sfd, c->rbuf, c->rsize,
                   0, (struct sockaddr *)&c->request_addr,
                   &c->request_addr_size);
    if (res > 8) {
        unsigned char *buf = (unsigned char *)c->rbuf;
        pthread_mutex_lock(&c->thread->stats.mutex);
        c->thread->stats.bytes_read += res;
        pthread_mutex_unlock(&c->thread->stats.mutex);

        /* Beginning of UDP packet is the request ID; save it. */
        c->request_id = buf[0] * 256 + buf[1];

        /* If this is a multi-packet request, drop it. */
        if (buf[4] != 0 || buf[5] != 1) {
            return READ_NO_DATA_RECEIVED;
        }

        /* Don't care about any of the rest of the header. */
        res -= 8;
        memmove(c->rbuf, c->rbuf + 8, res);

        c->rbytes = res;
        c->rcurr = c->rbuf;
        return READ_DATA_RECEIVED;
...",2387.0,2419.0,1.0,1.0,33.0,50,14,33,6,0,17,3,4,0,0,,0,17,2,1,1,enum try_read_result
679,35503,try_read_network,1,try_read_network,enum try_read_result try_read_network (conn*),memcached.c,"static enum try_read_result try_read_network(conn *c) {
    enum try_read_result gotdata = READ_NO_DATA_RECEIVED;
    int res;
    int num_allocs = 0;
    assert(c != NULL);

    if (c->rcurr != c->rbuf) {
        if (c->rbytes != 0) /* otherwise there's nothing to copy */
            memmove(c->rbuf, c->rcurr, c->rbytes);
        c->rcurr = c->rbuf;
    }

    while (1) {
        // TODO: move to rbuf_* func?
        if (c->rbytes >= c->rsize && c->rbuf_malloced) {
            if (num_allocs == 4) {
                return gotdata;
            }
            ++num_allocs;
            char *new_rbuf = realloc(c->rbuf, c->rsize * 2);
            if (!new_rbuf) {
                STATS_LOCK();
                stats.malloc_fails++;
                STATS_UNLOCK();
                if (settings.verbose > 0) {
                    fprintf(stderr, ""Couldn't realloc input buffer\n"");
                }
                c->rbytes = 0; /* ignore what we read */
                out_of_memory(c, ""SERV...",2433.0,2496.0,1.0,1.0,64.0,76,19,67,19,0,36,15,29,9,2,,0,33,2,1,1,enum try_read_result
680,35828,do_accept_new_conns,1,do_accept_new_conns,void do_accept_new_conns (bool),memcached.c,"void do_accept_new_conns(const bool do_accept) {
    conn *next;

    for (next = listen_conn; next; next = next->next) {
        if (do_accept) {
            update_event(next, EV_READ | EV_PERSIST);
            if (listen(next->sfd, settings.backlog) != 0) {
                perror(""listen"");
            }
        }
        else {
            update_event(next, 0);
            if (listen(next->sfd, 0) != 0) {
                perror(""listen"");
            }
        }
    }

    if (do_accept) {
        struct timeval maxconns_exited;
        uint64_t elapsed_us;
        gettimeofday(&maxconns_exited,NULL);
        STATS_LOCK();
        elapsed_us =
            (maxconns_exited.tv_sec - stats.maxconns_entered.tv_sec) * 1000000
            + (maxconns_exited.tv_usec - stats.maxconns_entered.tv_usec);
        stats.time_in_listen_disabled_us += elapsed_us;
        stats_state.accepting_conns = true;
        STATS_UNLOCK();
    } else {
        STATS_LOCK();
        stats_state.acceptin...",2515.0,2553.0,1.0,1.0,39.0,21,10,21,12,0,15,5,8,3,1,,0,12,2,1,1,void
681,35954,_transmit_pre,1,_transmit_pre,"int _transmit_pre (conn*,iovec*,int,bool)",memcached.c,"static int _transmit_pre(conn *c, struct iovec *iovs, int iovused, bool one_resp) {
    mc_resp *resp = c->resp_head;
    while (resp && iovused + resp->iovcnt < IOV_MAX-1) {
        if (resp->skip) {
            // Don't actually unchain the resp obj here since it's singly-linked.
            // Just let the post function handle it linearly.
            resp = resp->next;
            continue;
        }
        if (resp->chunked_data_iov) {
            // Handle chunked items specially.
            // They spend much more time in send so we can be a bit wasteful
            // in rebuilding iovecs for them.
            item_chunk *ch = (item_chunk *)ITEM_schunk((item *)resp->iov[resp->chunked_data_iov].iov_base);
            int x;
            for (x = 0; x < resp->iovcnt; x++) {
                // This iov is tracking how far we've copied so far.
                if (x == resp->chunked_data_iov) {
                    int done = resp->chunked_total - resp->iov[x].iov_len;
          ...",2557.0,2620.0,1.0,43.0,64.0,104,19,71,13,2,1,16,36,0,0,,0,1,8,4,4,int
682,36294,_transmit_post,1,_transmit_post,"void _transmit_post (conn*,ssize_t)",memcached.c,"static void _transmit_post(conn *c, ssize_t res) {
    // We've written some of the data. Remove the completed
    // responses from the list of pending writes.
    mc_resp *resp = c->resp_head;
    while (resp) {
        int x;
        if (resp->skip) {
            resp = resp_finish(c, resp);
            continue;
        }

        // fastpath check. all small responses should cut here.
        if (res >= resp->tosend) {
            res -= resp->tosend;
            resp = resp_finish(c, resp);
            continue;
        }

        // it's fine to re-check iov's that were zeroed out before.
        for (x = 0; x < resp->iovcnt; x++) {
            struct iovec *iov = &resp->iov[x];
            if (res >= iov->iov_len) {
                resp->tosend -= iov->iov_len;
                res -= iov->iov_len;
                iov->iov_len = 0;
            } else {
                // Dumb special case for chunked items. Currently tracking
                // where to inject the chunked ite...",2626.0,2674.0,1.0,1.0,49.0,28,8,31,5,3,4,9,13,0,3,,0,4,4,2,2,void
683,36439,transmit,1,transmit,enum transmit_result transmit (conn*),memcached.c,"static enum transmit_result transmit(conn *c) {
    assert(c != NULL);
    struct iovec iovs[IOV_MAX];
    struct msghdr msg;
    int iovused = 0;

    // init the msg.
    memset(&msg, 0, sizeof(struct msghdr));
    msg.msg_iov = iovs;

    iovused = _transmit_pre(c, iovs, iovused, TRANSMIT_ALL_RESP);
    if (iovused == 0) {
        // Avoid the syscall if we're only handling a noreply.
        // Return the response object.
        _transmit_post(c, 0);
        return TRANSMIT_COMPLETE;
    }

    // Alright, send.
    ssize_t res;
    msg.msg_iovlen = iovused;
    res = c->sendmsg(c, &msg, 0);
    if (res >= 0) {
        pthread_mutex_lock(&c->thread->stats.mutex);
        c->thread->stats.bytes_written += res;
        pthread_mutex_unlock(&c->thread->stats.mutex);

        // Decrement any partial IOV's and complete any finished resp's.
        _transmit_post(c, res);

        if (c->resp_head) {
            return TRANSMIT_INCOMPLETE;
        } else {
            return TRANSMI...",2685.0,2738.0,1.0,46.0,54.0,39,15,48,20,0,15,8,12,6,7,,0,11,2,1,1,enum transmit_result
684,36599,build_udp_header,1,build_udp_header,"void build_udp_header (unsigned char*,mc_resp*)",memcached.c,"static void build_udp_header(unsigned char *hdr, mc_resp *resp) {
    // We need to communicate the total number of packets
    // If this isn't set, it's the first time this response is building a udp
    // header, so ""tosend"" must be static.
    if (!resp->udp_total) {
        uint32_t total;
        total = resp->tosend / UDP_DATA_SIZE;
        if (resp->tosend % UDP_DATA_SIZE)
            total++;
        // The spec doesn't really say what we should do here. It's _probably_
        // better to bail out?
        if (total > USHRT_MAX) {
            total = USHRT_MAX;
        }
        resp->udp_total = total;
    }

    // TODO: why wasn't this hto*'s and casts?
    // this ends up sending UDP hdr data specifically in host byte order.
    *hdr++ = resp->request_id / 256;
    *hdr++ = resp->request_id % 256;
    *hdr++ = resp->udp_sequence / 256;
    *hdr++ = resp->udp_sequence % 256;
    *hdr++ = resp->udp_total / 256;
    *hdr++ = resp->udp_total % 256;
    *hdr++ = 0;
    *h...",2740.0,2768.0,1.0,31.0,29.0,50,8,26,4,1,0,4,6,0,0,,0,0,4,2,2,void
685,36713,transmit_udp,1,transmit_udp,enum transmit_result transmit_udp (conn*),memcached.c,"static enum transmit_result transmit_udp(conn *c) {
    assert(c != NULL);
    struct iovec iovs[IOV_MAX];
    struct msghdr msg;
    mc_resp *resp;
    int iovused = 0;
    unsigned char udp_hdr[UDP_HEADER_SIZE];

    // We only send one UDP packet per call (ugh), so we can only operate on a
    // single response at a time.
    resp = c->resp_head;

    if (!resp) {
        return TRANSMIT_COMPLETE;
    }

    if (resp->skip) {
        resp = resp_finish(c, resp);
        return TRANSMIT_INCOMPLETE;
    }

    // clear the message and initialize it.
    memset(&msg, 0, sizeof(struct msghdr));
    msg.msg_iov = iovs;

    // the UDP source to return to.
    msg.msg_name = &resp->request_addr;
    msg.msg_namelen = resp->request_addr_size;

    // First IOV is the custom UDP header.
    iovs[0].iov_base = (void *)udp_hdr;
    iovs[0].iov_len = UDP_HEADER_SIZE;
    build_udp_header(udp_hdr, resp);
    iovused++;

    // Fill the IOV's the standard way.
    // TODO: might get a small ...",2782.0,2877.0,1.0,26.0,96.0,73,22,78,25,0,17,12,16,6,7,,0,13,2,1,1,enum transmit_result
686,36989,read_into_chunked_item,1,read_into_chunked_item,int read_into_chunked_item (conn*),memcached.c,"static int read_into_chunked_item(conn *c) {
    int total = 0;
    int res;
    assert(c->rcurr != c->ritem);

    while (c->rlbytes > 0) {
        item_chunk *ch = (item_chunk *)c->ritem;
        if (ch->size == ch->used) {
            // FIXME: ch->next is currently always 0. remove this?
            if (ch->next) {
                c->ritem = (char *) ch->next;
            } else {
                /* Allocate next chunk. Binary protocol needs 2b for \r\n */
                c->ritem = (char *) do_item_alloc_chunk(ch, c->rlbytes +
                       ((c->protocol == binary_prot) ? 2 : 0));
                if (!c->ritem) {
                    // We failed an allocation. Let caller handle cleanup.
                    total = -2;
                    break;
                }
                // ritem has new chunk, restart the loop.
                continue;
                //assert(c->rlbytes == 0);
            }
        }

        int unused = ch->size - ch->used;
        /* first...",2884.0,2961.0,1.0,1.0,78.0,73,16,56,6,0,22,11,21,7,1,,0,22,2,1,1,int
687,38523,maximize_sndbuf,1,maximize_sndbuf,void maximize_sndbuf (int),memcached.c,"static void maximize_sndbuf(const int sfd) {
    socklen_t intsize = sizeof(int);
    int last_good = 0;
    int min, max, avg;
    int old_size;

    /* Start with the default size. */
#ifdef _WIN32
    if (getsockopt((SOCKET)sfd, SOL_SOCKET, SO_SNDBUF, (char *)&old_size, &intsize) != 0) {
#else
    if (getsockopt(sfd, SOL_SOCKET, SO_SNDBUF, &old_size, &intsize) != 0) {
#endif /* #ifdef _WIN32 */
        if (settings.verbose > 0)
            perror(""getsockopt(SO_SNDBUF)"");
        return;
    }

    /* Binary-search for the real maximum. */
    min = old_size;
    max = MAX_SENDBUF_SIZE;

    while (min <= max) {
        avg = ((unsigned int)(min + max)) / 2;
        if (setsockopt(sfd, SOL_SOCKET, SO_SNDBUF, (void *)&avg, intsize) == 0) {
            last_good = avg;
            min = avg + 1;
        } else {
            max = avg - 1;
        }
    }

    if (settings.verbose > 1)
        fprintf(stderr, ""<%d send buffer was %d, now %d\n"", sfd, old_size, last_good);
}",3435.0,3468.0,1.0,10.0,34.0,25,12,31,12,1,4,6,8,4,0,,0,4,2,1,1,void
688,38630,server_socket,1,server_socket,"int server_socket (char*,int,network_transport,FILE*,bool,uint64_t,protocol)",memcached.c,"static int server_socket(const char *interface,
                         int port,
                         enum network_transport transport,
                         FILE *portnumber_file, bool ssl_enabled,
                         uint64_t conntag,
                         enum protocol bproto) {
    int sfd;
    struct linger ling = {0, 0};
    struct addrinfo *ai;
    struct addrinfo *next;
    struct addrinfo hints = { .ai_flags = AI_PASSIVE,
                              .ai_family = AF_UNSPEC };
    char port_buf[NI_MAXSERV];
    int error;
    int success = 0;
    int flags =1;

    hints.ai_socktype = IS_UDP(transport) ? SOCK_DGRAM : SOCK_STREAM;

    if (port == -1) {
        port = 0;
    }
    snprintf(port_buf, sizeof(port_buf), ""%d"", port);
    error= getaddrinfo(interface, port_buf, &hints, &ai);
    if (error != 0) {
        if (error != EAI_SYSTEM)
          fprintf(stderr, ""getaddrinfo(): %s\n"", gai_strerror(error));
        else
          perror(""getaddrinfo()"");
...",3479.0,3656.0,1.0,24.0,178.0,50,13,84,40,1,7,17,32,5,3,,0,5,14,7,7,int
689,39120,server_sockets,1,server_sockets,"int server_sockets (int,network_transport,FILE*)",memcached.c,"static int server_sockets(int port, enum network_transport transport,
                          FILE *portnumber_file) {
    bool ssl_enabled = false;
    uint64_t conntag = 0;

#ifdef TLS
    const char *notls = ""notls"";
    ssl_enabled = settings.ssl_enabled;
#endif

    if (settings.inter == NULL) {
        return server_socket(settings.inter, port, transport, portnumber_file, ssl_enabled, conntag, settings.binding_protocol);
    } else {
        // tokenize them and bind to each one of them..
        char *b;
        int ret = 0;
        char *list = strdup(settings.inter);

        if (list == NULL) {
            fprintf(stderr, ""Failed to allocate memory for parsing server interface string\n"");
            return 1;
        }
        // If we encounter any failure, preserve the first errno for the caller.
        int errno_save = 0;
        for (char *p = strtok_r(list, "";,"", &b);
            p != NULL;
            p = strtok_r(NULL, "";,"", &b)) {
            int the_port = por...",3658.0,3816.0,1.0,1.0,159.0,6,3,12,8,2,7,2,2,2,1,,0,6,6,3,3,int
690,39550,new_socket_unix,1,new_socket_unix,int new_socket_unix (void),memcached.c,"static int new_socket_unix(void) {
    int sfd;
    int flags;

    if ((sfd = socket(AF_UNIX, SOCK_STREAM, 0)) == -1) {
        perror(""socket()"");
        return -1;
    }

    if ((flags = fcntl(sfd, F_GETFL, 0)) < 0 ||
        fcntl(sfd, F_SETFL, flags | O_NONBLOCK) < 0) {
        perror(""setting O_NONBLOCK"");
        close(sfd);
        return -1;
    }
    return sfd;
}",3819.0,3835.0,1.0,1.0,17.0,10,6,12,7,1,0,3,3,0,0,,0,0,2,1,1,int
691,39601,server_socket_unix,1,server_socket_unix,"int server_socket_unix (char*,int)",memcached.c,"static int server_socket_unix(const char *path, int access_mask) {
    int sfd;
    struct linger ling = {0, 0};
    struct sockaddr_un addr;
    struct stat tstat;
    int flags =1;
    int old_umask;

    if (!path) {
        return 1;
    }

    if ((sfd = new_socket_unix()) == -1) {
        return 1;
    }

    /*
     * Clean up a previous socket file if we left it around
     */
    if (lstat(path, &tstat) == 0) {
        if (S_ISSOCK(tstat.st_mode))
            unlink(path);
    }

    setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void *)&flags, sizeof(flags));
    setsockopt(sfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flags, sizeof(flags));
    setsockopt(sfd, SOL_SOCKET, SO_LINGER, (void *)&ling, sizeof(ling));

    /*
     * the memset call clears nonstandard fields in some implementations
     * that otherwise mess things up.
     */
    memset(&addr, 0, sizeof(addr));

    addr.sun_family = AF_UNIX;
    strncpy(addr.sun_path, path, sizeof(addr.sun_path) - 1);
    assert(strcmp(...",3837.0,3895.0,1.0,1.0,59.0,44,13,54,23,1,8,8,9,8,2,,0,8,4,2,2,int
692,39788,clock_handler,1,clock_handler,"void clock_handler (evutil_socket_t,short,void*)",memcached.c,"static void clock_handler(const evutil_socket_t fd, const short which, void *arg) {
    struct timeval t = {.tv_sec = 1, .tv_usec = 0};
    static bool initialized = false;

    if (initialized) {
        /* only delete the event if it's actually there. */
        evtimer_del(&clockevent);
    } else {
        initialized = true;
    }

    // While we're here, check for hash table expansion.
    // This function should be quick to avoid delaying the timer.
    assoc_start_expand(stats_state.curr_items);
    // also, if HUP'ed we need to do some maintenance.
    // for now that's just the authfile reload.
    if (settings.sig_hup) {
        settings.sig_hup = false;

        authfile_load(settings.auth_file);
#ifdef PROXY
        if (settings.proxy_ctx) {
            proxy_start_reload(settings.proxy_ctx);
        }
#endif
    }

    evtimer_set(&clockevent, clock_handler, 0);
    event_base_set(main_base, &clockevent);
    evtimer_add(&clockevent, &t);

#ifdef MEMCACHED_DEBUG
    i...",3923.0,3980.0,1.0,1.0,58.0,20,6,22,13,1,15,3,3,2,2,,0,13,6,3,3,void
693,39869,flag_enabled_disabled,1,flag_enabled_disabled,const char* flag_enabled_disabled (bool),memcached.c,"static const char* flag_enabled_disabled(bool flag) {
    return (flag ? ""enabled"" : ""disabled"");
}",3982.0,3984.0,1.0,1.0,3.0,1,1,1,1,1,0,1,1,0,0,,0,0,2,1,1,const char*
694,39879,verify_default,1,verify_default,"void verify_default (char*,bool)",memcached.c,"static void verify_default(const char* param, bool condition) {
    if (!condition) {
        printf(""Default value of [%s] has changed.""
            "" Modify the help text and default value check.\n"", param);
        exit(EXIT_FAILURE);
    }
}",3986.0,3992.0,1.0,1.0,7.0,1,1,3,3,6,0,2,2,0,0,,0,0,4,2,2,void
695,39894,usage,1,usage,void usage (void),timedrun.c,"static void usage(void) {
    fprintf(stderr, ""./timedrun <naptime in sec> args...\n"");
    exit(-1);
}",94.0,97.0,1.0,1.0,4.0,54,6,32,1,1,71,1,1,0,7,,0,64,2,1,1,void
696,40109,usage_license,1,usage_license,void usage_license (void),memcached.c,"static void usage_license(void) {
    printf(PACKAGE "" "" VERSION ""\n\n"");
    printf(
    ""Copyright (c) 2003, Danga Interactive, Inc. <http://www.danga.com/>\n""
    ""All rights reserved.\n""
    ""\n""
    ""Redistribution and use in source and binary forms, with or without\n""
    ""modification, are permitted provided that the following conditions are\n""
    ""met:\n""
    ""\n""
    ""    * Redistributions of source code must retain the above copyright\n""
    ""notice, this list of conditions and the following disclaimer.\n""
    ""\n""
    ""    * Redistributions in binary form must reproduce the above\n""
    ""copyright notice, this list of conditions and the following disclaimer\n""
    ""in the documentation and/or other materials provided with the\n""
    ""distribution.\n""
    ""\n""
    ""    * Neither the name of the Danga Interactive nor the names of its\n""
    ""contributors may be used to endorse or promote products derived from\n""
    ""this software without specific prior written permission....",4189.0,4258.0,1.0,1.0,70.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
697,40118,save_pid,1,save_pid,void save_pid (char*),memcached.c,"static void save_pid(const char *pid_file) {
    FILE *fp;
    if (access(pid_file, F_OK) == 0) {
        if ((fp = fopen(pid_file, ""r"")) != NULL) {
            char buffer[1024];
            if (fgets(buffer, sizeof(buffer), fp) != NULL) {
                unsigned int pid;
                if (safe_strtoul(buffer, &pid) && kill((pid_t)pid, 0) == 0) {
                    fprintf(stderr, ""WARNING: The pid file contained the following (running) pid: %u\n"", pid);
                }
            }
            fclose(fp);
        }
    }

    /* Create the pid file first with a temporary name, then
     * atomically move the file to the real name to avoid a race with
     * another process opening the file to read the pid, but finding
     * it empty.
     */
    char tmp_pid_file[1024];
    snprintf(tmp_pid_file, sizeof(tmp_pid_file), ""%s.tmp"", pid_file);

    if ((fp = fopen(tmp_pid_file, ""w"")) == NULL) {
        vperror(""Could not open the pid file %s for writing"", tmp_pid_file);
       ...",4260.0,4297.0,1.0,1.0,38.0,16,8,29,8,1,4,8,14,1,4,,0,1,2,1,1,void
698,40218,remove_pidfile,1,remove_pidfile,void remove_pidfile (char*),memcached.c,"static void remove_pidfile(const char *pid_file) {
  if (pid_file == NULL)
      return;

  if (unlink(pid_file) != 0) {
      vperror(""Could not remove the pid file %s"", pid_file);
  }

}",4299.0,4307.0,1.0,1.0,9.0,2,2,4,2,1,1,3,3,0,1,,0,0,2,1,1,void
699,40238,sig_handler,1,sig_handler,void sig_handler (int),memcached.c,"static void sig_handler(const int sig) {
    stop_main_loop = EXIT_NORMALLY;
    printf(""Signal handled: %s.\n"", strsignal(sig));
}",4309.0,4312.0,1.0,1.0,4.0,1,1,3,3,0,1,1,1,0,0,,0,1,2,1,1,void
700,40250,sighup_handler,1,sighup_handler,void sighup_handler (int),memcached.c,"static void sighup_handler(const int sig) {
    settings.sig_hup = true;
}",4314.0,4316.0,1.0,1.0,3.0,2,2,2,2,0,2,1,1,0,0,,0,2,2,1,1,void
701,40260,sig_usrhandler,1,sig_usrhandler,void sig_usrhandler (int),memcached.c,"static void sig_usrhandler(const int sig) {
    printf(""Graceful shutdown signal handled: %s.\n"", strsignal(sig));
    stop_main_loop = GRACE_STOP;
}",4318.0,4321.0,1.0,1.0,4.0,1,1,3,3,0,1,1,1,0,0,,0,1,2,1,1,void
702,40272,enable_large_pages,1,enable_large_pages,int enable_large_pages (void),memcached.c,"static int enable_large_pages(void) {
#if defined(HAVE_GETPAGESIZES) && defined(HAVE_MEMCNTL)
    int ret = -1;
    size_t sizes[32];
    int avail = getpagesizes(sizes, 32);
    if (avail != -1) {
        size_t max = sizes[0];
        struct memcntl_mha arg = {0};
        int ii;

        for (ii = 1; ii < avail; ++ii) {
            if (max < sizes[ii]) {
                max = sizes[ii];
            }
        }

        arg.mha_flags   = 0;
        arg.mha_pagesize = max;
        arg.mha_cmd = MHA_MAPSIZE_BSSBRK;

        if (memcntl(0, 0, MC_HAT_ADVISE, (caddr_t)&arg, 0, 0) == -1) {
            fprintf(stderr, ""Failed to set large pages: %s\n"",
                    strerror(errno));
            fprintf(stderr, ""Will use default page size\n"");
        } else {
            ret = 0;
        }
    } else {
        fprintf(stderr, ""Failed to get supported pagesizes: %s\n"",
                strerror(errno));
        fprintf(stderr, ""Will use default page size\n"");
    }

    return ret;
...",4327.0,4414.0,1.0,1.0,88.0,1,1,0,0,1,0,1,1,0,0,,0,0,2,1,1,int
703,40280,sanitycheck,1,sanitycheck,bool sanitycheck (void),memcached.c,"static bool sanitycheck(void) {
    /* One of our biggest problems is old and bogus libevents */
    const char *ever = event_get_version();
    if (ever != NULL) {
        if (strncmp(ever, ""1."", 2) == 0) {
            fprintf(stderr, ""You are using libevent %s.\nPlease upgrade to 2.x""
                        "" or newer\n"", event_get_version());
            return false;
        }
    }

    return true;
}",4420.0,4432.0,1.0,1.0,13.0,3,3,7,5,1,0,3,4,0,0,,0,0,2,1,1,bool
704,40310,_parse_slab_sizes,1,_parse_slab_sizes,"bool _parse_slab_sizes (char*,uint32_t*)",memcached.c,"static bool _parse_slab_sizes(char *s, uint32_t *slab_sizes) {
    char *b = NULL;
    uint32_t size = 0;
    int i = 0;
    uint32_t last_size = 0;

    if (strlen(s) < 1)
        return false;

    for (char *p = strtok_r(s, ""-"", &b);
         p != NULL;
         p = strtok_r(NULL, ""-"", &b)) {
        if (!safe_strtoul(p, &size) || size < settings.chunk_size
             || size > settings.slab_chunk_size_max) {
            fprintf(stderr, ""slab size %u is out of valid range\n"", size);
            return false;
        }
        if (last_size >= size) {
            fprintf(stderr, ""slab size %u cannot be lower than or equal to a previous class size\n"", size);
            return false;
        }
        if (size <= last_size + CHUNK_ALIGN_BYTES) {
            fprintf(stderr, ""slab size %u must be at least %d bytes larger than previous class\n"",
                    size, CHUNK_ALIGN_BYTES);
            return false;
        }
        slab_sizes[i++] = size;
        last_size = size;...",4434.0,4470.0,1.0,32.0,37.0,28,14,42,12,1,5,7,11,5,1,,0,5,4,2,2,bool
705,40454,_mc_meta_save_cb,1,_mc_meta_save_cb,"int _mc_meta_save_cb (char*,void*,void*)",memcached.c,"static int _mc_meta_save_cb(const char *tag, void *ctx, void *data) {
    struct _mc_meta_data *meta = (struct _mc_meta_data *)data;

    // Settings to remember.
    // TODO: should get a version of version which is numeric, else
    // comparisons for compat reasons are difficult.
    // it may be possible to punt on this for now; since we can test for the
    // absence of another key... such as the new numeric version.
    //restart_set_kv(ctx, ""version"", ""%s"", VERSION);
    // We hold the original factor or subopts _string_
    // it can be directly compared without roundtripping through floats or
    // serializing/deserializing the long options list.
    restart_set_kv(ctx, ""slab_config"", ""%s"", meta->slab_config);
    restart_set_kv(ctx, ""maxbytes"", ""%llu"", (unsigned long long) settings.maxbytes);
    restart_set_kv(ctx, ""chunk_size"", ""%d"", settings.chunk_size);
    restart_set_kv(ctx, ""item_size_max"", ""%d"", settings.item_size_max);
    restart_set_kv(ctx, ""slab_chunk_size_ma...",4487.0,4539.0,1.0,1.0,53.0,22,6,36,9,0,41,1,1,0,19,,0,24,6,3,3,int
706,40600,_mc_meta_load_cb,1,_mc_meta_load_cb,"int _mc_meta_load_cb (char*,void*,void*)",memcached.c,"static int _mc_meta_load_cb(const char *tag, void *ctx, void *data) {
    struct _mc_meta_data *meta = (struct _mc_meta_data *)data;
    char *key;
    char *val;
    int reuse_mmap = 0;
    meta->process_started = 0;
    meta->time_delta = 0;
    meta->current_time = 0;
    int lines_seen = 0;

    // TODO: not sure this is any better than just doing an if/else tree with
    // strcmp's...
    enum {
        R_MMAP_OLDBASE = 0,
        R_MAXBYTES,
        R_CHUNK_SIZE,
        R_ITEM_SIZE_MAX,
        R_SLAB_CHUNK_SIZE_MAX,
        R_SLAB_PAGE_SIZE,
        R_SLAB_CONFIG,
        R_USE_CAS,
        R_SLAB_REASSIGN,
        R_CURRENT_CAS,
        R_OLDEST_CAS,
        R_OLDEST_LIVE,
        R_LOGGER_GID,
        R_CURRENT_TIME,
        R_STOP_TIME,
        R_PROCESS_STARTED,
        R_HASHPOWER,
    };

    const char *opts[] = {
        [R_MMAP_OLDBASE] = ""mmap_oldbase"",
        [R_MAXBYTES] = ""maxbytes"",
        [R_CHUNK_SIZE] = ""chunk_size"",
        [R_ITEM_SIZE_MAX] = ""item_size...",4551.0,4760.0,1.0,21.0,210.0,142,15,149,38,0,34,44,64,31,15,,0,34,6,3,3,int
707,41195,main,1,main,"int main (int,char**)",vendor\mcmc\example.c,"int main (int argc, char *agv[]) {
    // TODO: detect if C is pre-C11?
    printf(""C version: %ld\n"", __STDC_VERSION__);

    if (signal(SIGPIPE, SIG_IGN) == SIG_ERR) {
        perror(""signal"");
        exit(1);
    }
/*
    void *c = malloc(mcmc_size(MCMC_OPTION_BLANK));
    // we only ""need"" the minimum buf size.
    // buffers large enough to fit return values result in fewer syscalls.
    size_t bufsize = mcmc_min_buffer_size(MCMC_OPTION_BLANK) * 2;
    // buffers are also generally agnostic to clients. The buffer must be
    // held and re-used when required by the API. When the buffer is empty,
    // it may be released to a pool or reused with other connections.
    char *rbuf = malloc(bufsize);

    int status;

    // API is blocking by default.
    status = mcmc_connect(c, ""127.0.0.1"", ""11211"", MCMC_OPTION_BLANK);

    if (status != MCMC_CONNECTED) {
        // TODO: mc_strerr(c);
        fprintf(stderr, ""Failed to connect to memcached\n"");
        return -1;
    }

    c...",172.0,292.0,1.0,31.0,121.0,586,27,777,129,0,412,213,349,178,45,,0,385,4,2,2,int
708,44723,read,1,conn.read,"ssize_t conn.read (conn*,void*,size_t)",memcached.h,"ssize_t (*read)(conn  *c, void *buf, size_t count);",873.0,873.0,13.0,54.0,1.0,0,0,0,0,8,0,1,1,0,0,,0,0,6,3,3,ssize_t
709,44730,sendmsg,1,conn.sendmsg,"ssize_t conn.sendmsg (conn*,msghdr*,int)",memcached.h,"ssize_t (*sendmsg)(conn *c, struct msghdr *msg, int flags);",874.0,874.0,13.0,62.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,ssize_t
710,44737,write,1,conn.write,"ssize_t conn.write (conn*,void*,size_t)",memcached.h,"ssize_t (*write)(conn *c, void *buf, size_t count);",875.0,875.0,13.0,54.0,1.0,0,0,0,0,3,0,1,1,0,0,,0,0,6,3,3,ssize_t
711,44838,memcached_thread_init,1,memcached_thread_init,"void memcached_thread_init (int,void*)",thread.c,"void memcached_thread_init(int nthreads, void *arg) {
    int         i;
    int         power;

    for (i = 0; i < POWER_LARGEST; i++) {
        pthread_mutex_init(&lru_locks[i], NULL);
    }
    pthread_mutex_init(&worker_hang_lock, NULL);

    pthread_mutex_init(&init_lock, NULL);
    pthread_cond_init(&init_cond, NULL);

    /* Want a wide lock table, but don't waste memory */
    if (nthreads < 3) {
        power = 10;
    } else if (nthreads < 4) {
        power = 11;
    } else if (nthreads < 5) {
        power = 12;
    } else if (nthreads <= 10) {
        power = 13;
    } else if (nthreads <= 20) {
        power = 14;
    } else {
        /* 32k buckets. just under the hashpower default. */
        power = 15;
    }

    if (power >= hashpower) {
        fprintf(stderr, ""Hash table power size (%d) cannot be equal to or less than item lock table (%d)\n"", hashpower, power);
        fprintf(stderr, ""Item lock table grows with `-t N` (worker threadcount)\n"");
        fprintf(...",1009.0,1096.0,1.0,20.0,88.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
712,44844,redispatch_conn,1,redispatch_conn,void redispatch_conn (conn*),thread.c,"void redispatch_conn(conn *c) {
    notify_worker_fd(c->thread, c->sfd, queue_redispatch);
}",754.0,756.0,1.0,1.0,3.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
713,44849,timeout_conn,1,timeout_conn,void timeout_conn (conn*),thread.c,"void timeout_conn(conn *c) {
    notify_worker_fd(c->thread, c->sfd, queue_timeout);
}",758.0,760.0,1.0,1.0,3.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
714,44854,return_io_pending,1,return_io_pending,void return_io_pending (io_pending_t*),thread.c,"void return_io_pending(io_pending_t *io) {
    CQ_ITEM *item = cqi_new(io->thread->ev_queue);
    if (item == NULL) {
        // TODO: how can we avoid this?
        // In the main case I just loop, since a malloc failure here for a
        // tiny object that's generally in a fixed size queue is going to
        // implode shortly.
        return;
    }

    item->mode = queue_return_io;
    item->io = io;

    notify_worker(io->thread, item);
}",767.0,781.0,1.0,1.0,15.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
715,44859,dispatch_conn_new,1,dispatch_conn_new,"void dispatch_conn_new (int,conn_states,int,int,network_transport,void*,uint64_t,protocol)",thread.c,"void dispatch_conn_new(int sfd, enum conn_states init_state, int event_flags,
                       int read_buffer_size, enum network_transport transport, void *ssl,
                       uint64_t conntag, enum protocol bproto) {
    CQ_ITEM *item = NULL;
    LIBEVENT_THREAD *thread;

    if (!settings.num_napi_ids)
        thread = select_thread_round_robin();
    else
        thread = select_thread_by_napi_id(sfd);

    item = cqi_new(thread->ev_queue);
    if (item == NULL) {
        close(sfd);
        /* given that malloc failed this may also fail, but let's try */
        fprintf(stderr, ""Failed to allocate memory for connection object\n"");
        return;
    }

    item->sfd = sfd;
    item->init_state = init_state;
    item->event_flags = event_flags;
    item->read_buffer_size = read_buffer_size;
    item->transport = transport;
    item->mode = queue_new_conn;
    item->ssl = ssl;
    item->conntag = conntag;
    item->bproto = bproto;

    MEMCACHED_CONN_DISPATCH(sfd,...",717.0,748.0,1.0,4.0,32.0,0,0,0,0,1,0,1,1,0,0,,0,0,16,8,8,void
716,44871,sidethread_conn_close,1,sidethread_conn_close,void sidethread_conn_close (conn*),thread.c,"void sidethread_conn_close(conn *c) {
    if (settings.verbose > 1)
        fprintf(stderr, ""<%d connection closing from side thread.\n"", c->sfd);

    c->state = conn_closing;
    // redispatch will see closing flag and properly close connection.
    redispatch_conn(c);
    return;
}",784.0,792.0,1.0,1.0,9.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,void
717,44893,item_alloc,1,item_alloc,"item* item_alloc (char*,size_t,int,rel_time_t,int)",thread.c,"item *item_alloc(char *key, size_t nkey, int flags, rel_time_t exptime, int nbytes) {
    item *it;
    /* do_item_alloc handles its own locks */
    it = do_item_alloc(key, nkey, flags, exptime, nbytes);
    return it;
}",799.0,804.0,1.0,1.0,6.0,0,0,0,0,4,0,1,1,0,0,,0,0,10,5,5,item
718,44902,item_get,1,item_get,"item* item_get (char*,size_t,conn*,bool)",thread.c,"item *item_get(const char *key, const size_t nkey, conn *c, const bool do_update) {
    item *it;
    uint32_t hv;
    hv = hash(key, nkey);
    item_lock(hv);
    it = do_item_get(key, nkey, hv, c, do_update);
    item_unlock(hv);
    return it;
}",810.0,818.0,1.0,1.0,9.0,0,0,0,0,1,0,1,1,0,0,,0,0,8,4,4,item
719,44910,item_get_locked,1,item_get_locked,"item* item_get_locked (char*,size_t,conn*,bool,uint32_t*)",thread.c,"item *item_get_locked(const char *key, const size_t nkey, conn *c, const bool do_update, uint32_t *hv) {
    item *it;
    *hv = hash(key, nkey);
    item_lock(*hv);
    it = do_item_get(key, nkey, *hv, c, do_update);
    return it;
}",823.0,829.0,1.0,1.0,7.0,0,0,0,0,4,0,1,1,0,0,,0,0,10,5,5,item
720,44919,item_touch,1,item_touch,"item* item_touch (char*,size_t,uint32_t,conn*)",thread.c,"item *item_touch(const char *key, size_t nkey, uint32_t exptime, conn *c) {
    item *it;
    uint32_t hv;
    hv = hash(key, nkey);
    item_lock(hv);
    it = do_item_touch(key, nkey, exptime, hv, c);
    item_unlock(hv);
    return it;
}",831.0,839.0,1.0,1.0,9.0,0,0,0,0,2,0,1,1,0,0,,0,0,8,4,4,item
721,44932,item_remove,1,item_remove,void item_remove (item*),thread.c,"void item_remove(item *item) {
    uint32_t hv;
    hv = hash(ITEM_key(item), item->nkey);

    item_lock(hv);
    do_item_remove(item);
    item_unlock(hv);
}",859.0,866.0,1.0,14.0,8.0,0,0,0,0,7,0,1,1,0,0,,0,0,2,1,1,void
722,44937,item_replace,1,item_replace,"int item_replace (item*,item*,uint32_t)",thread.c,"int item_replace(item *old_it, item *new_it, const uint32_t hv) {
    return do_item_replace(old_it, new_it, hv);
}",873.0,875.0,1.0,1.0,3.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,int
723,44944,item_unlink,1,item_unlink,void item_unlink (item*),thread.c,"void item_unlink(item *item) {
    uint32_t hv;
    hv = hash(ITEM_key(item), item->nkey);
    item_lock(hv);
    do_item_unlink(item, hv);
    item_unlock(hv);
}",880.0,886.0,1.0,14.0,7.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
724,44949,item_lock,1,item_lock,void item_lock (uint32_t),thread.c,"void item_lock(uint32_t hv) {
    mutex_lock(&item_locks[hv & hashmask(item_lock_hashpower)]);
}",121.0,123.0,1.0,4.0,3.0,0,0,0,0,5,0,1,1,0,0,,0,0,2,1,1,void
725,44954,item_trylock,1,item_trylock,void* item_trylock (uint32_t),thread.c,"void *item_trylock(uint32_t hv) {
    pthread_mutex_t *lock = &item_locks[hv & hashmask(item_lock_hashpower)];
    if (pthread_mutex_trylock(lock) == 0) {
        return lock;
    }
    return NULL;
}",125.0,131.0,1.0,45.0,7.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,void*
726,44959,item_trylock_unlock,1,item_trylock_unlock,void item_trylock_unlock (void*),thread.c,"void item_trylock_unlock(void *lock) {
    mutex_unlock((pthread_mutex_t *) lock);
}",133.0,135.0,1.0,4.0,3.0,0,0,0,0,6,0,1,1,0,0,,0,0,2,1,1,void
727,44964,item_unlock,1,item_unlock,void item_unlock (uint32_t),thread.c,"void item_unlock(uint32_t hv) {
    mutex_unlock(&item_locks[hv & hashmask(item_lock_hashpower)]);
}",137.0,139.0,1.0,4.0,3.0,0,0,0,0,12,0,1,1,0,0,,0,0,2,1,1,void
728,44969,pause_threads,1,pause_threads,void pause_threads (pause_thread_types),thread.c,"void pause_threads(enum pause_thread_types type) {
    int i;
    bool pause_workers = false;

    switch (type) {
        case PAUSE_ALL_THREADS:
            slabs_rebalancer_pause();
            lru_maintainer_pause();
            lru_crawler_pause();
#ifdef EXTSTORE
            storage_compact_pause();
            storage_write_pause();
#endif
        case PAUSE_WORKER_THREADS:
            pause_workers = true;
            pthread_mutex_lock(&worker_hang_lock);
            break;
        case RESUME_ALL_THREADS:
            slabs_rebalancer_resume();
            lru_maintainer_resume();
            lru_crawler_resume();
#ifdef EXTSTORE
            storage_compact_resume();
            storage_write_resume();
#endif
        case RESUME_WORKER_THREADS:
            pthread_mutex_unlock(&worker_hang_lock);
            break;
        default:
            fprintf(stderr, ""Unknown lock type: %d\n"", type);
            assert(1 == 0);
            break;
    }

    /* Only send a message i...",158.0,204.0,1.0,1.0,47.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,void
729,44974,stop_threads,1,stop_threads,void stop_threads (void),thread.c,"void stop_threads(void) {
    int i;

    // assoc can call pause_threads(), so we have to stop it first.
    stop_assoc_maintenance_thread();
    if (settings.verbose > 0)
        fprintf(stderr, ""stopped assoc\n"");

    if (settings.verbose > 0)
        fprintf(stderr, ""asking workers to stop\n"");

    pthread_mutex_lock(&worker_hang_lock);
    pthread_mutex_lock(&init_lock);
    init_count = 0;
    for (i = 0; i < settings.num_threads; i++) {
        notify_worker_fd(&threads[i], 0, queue_stop);
    }
    wait_for_thread_registration(settings.num_threads);
    pthread_mutex_unlock(&init_lock);

    // All of the workers are hung but haven't done cleanup yet.

    if (settings.verbose > 0)
        fprintf(stderr, ""asking background threads to stop\n"");

    // stop each side thread.
    // TODO: Verify these all work if the threads are already stopped
    stop_item_crawler_thread(CRAWLER_WAIT);
    if (settings.verbose > 0)
        fprintf(stderr, ""stopped lru crawler\n"");
    if ...",210.0,272.0,1.0,29.0,63.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
730,44984,STATS_LOCK,1,STATS_LOCK,void STATS_LOCK (void),thread.c,"void STATS_LOCK() {
    pthread_mutex_lock(&stats_lock);
}",921.0,923.0,1.0,1.0,3.0,0,0,0,0,30,0,1,1,0,0,,0,0,0,0,0,void
731,44989,STATS_UNLOCK,1,STATS_UNLOCK,void STATS_UNLOCK (void),thread.c,"void STATS_UNLOCK() {
    pthread_mutex_unlock(&stats_lock);
}",925.0,927.0,1.0,1.0,3.0,0,0,0,0,31,0,1,1,0,0,,0,0,0,0,0,void
732,44994,threadlocal_stats_reset,1,threadlocal_stats_reset,void threadlocal_stats_reset (void),thread.c,"void threadlocal_stats_reset(void) {
    int ii;
    for (ii = 0; ii < settings.num_threads; ++ii) {
        pthread_mutex_lock(&threads[ii].stats.mutex);
#define X(name) threads[ii].stats.name = 0;
        THREAD_STATS_FIELDS
#ifdef EXTSTORE
        EXTSTORE_THREAD_STATS_FIELDS
#endif
#ifdef PROXY
        PROXY_THREAD_STATS_FIELDS
#endif
#undef X

        memset(&threads[ii].stats.slab_stats, 0,
                sizeof(threads[ii].stats.slab_stats));
        memset(&threads[ii].stats.lru_hits, 0,
                sizeof(uint64_t) * POWER_LARGEST);

        pthread_mutex_unlock(&threads[ii].stats.mutex);
    }
}",929.0,950.0,1.0,8.0,22.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
733,44999,threadlocal_stats_aggregate,1,threadlocal_stats_aggregate,void threadlocal_stats_aggregate (thread_stats*),thread.c,"void threadlocal_stats_aggregate(struct thread_stats *stats) {
    int ii, sid;

    /* The struct has a mutex, but we can safely set the whole thing
     * to zero since it is unused when aggregating. */
    memset(stats, 0, sizeof(*stats));

    for (ii = 0; ii < settings.num_threads; ++ii) {
        pthread_mutex_lock(&threads[ii].stats.mutex);
#define X(name) stats->name += threads[ii].stats.name;
        THREAD_STATS_FIELDS
#ifdef EXTSTORE
        EXTSTORE_THREAD_STATS_FIELDS
#endif
#ifdef PROXY
        PROXY_THREAD_STATS_FIELDS
#endif
#undef X

        for (sid = 0; sid < MAX_NUMBER_OF_SLAB_CLASSES; sid++) {
#define X(name) stats->slab_stats[sid].name += \
            threads[ii].stats.slab_stats[sid].name;
            SLAB_STATS_FIELDS
#undef X
        }

        for (sid = 0; sid < POWER_LARGEST; sid++) {
            stats->lru_hits[sid] +=
                threads[ii].stats.lru_hits[sid];
            stats->slab_stats[CLEAR_LRU(sid)].get_hits +=
                threads[ii].s...",952.0,990.0,1.0,8.0,39.0,0,0,0,0,3,0,1,1,0,0,,0,0,2,1,1,void
734,45004,slab_stats_aggregate,1,slab_stats_aggregate,"void slab_stats_aggregate (thread_stats*,slab_stats*)",thread.c,"void slab_stats_aggregate(struct thread_stats *stats, struct slab_stats *out) {
    int sid;

    memset(out, 0, sizeof(*out));

    for (sid = 0; sid < MAX_NUMBER_OF_SLAB_CLASSES; sid++) {
#define X(name) out->name += stats->slab_stats[sid].name;
        SLAB_STATS_FIELDS
#undef X
    }
}",992.0,1002.0,1.0,24.0,11.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
735,45010,get_worker_thread,1,get_worker_thread,LIBEVENT_THREAD* get_worker_thread (int),thread.c,"LIBEVENT_THREAD *get_worker_thread(int id) {
    return &threads[id];
}",634.0,636.0,1.0,1.0,3.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,LIBEVENT_THREAD
736,45176,rotl32,1,rotl32,"uint32_t rotl32 (uint32_t,int8_t)",murmur3_hash.c,"static inline uint32_t rotl32 ( uint32_t x, int8_t r )
{
  return (x << r) | (x >> (32 - r));
}",33.0,36.0,1.0,1.0,4.0,4,4,4,2,3,0,1,1,0,0,,0,0,4,2,2,uint32_t
737,45192,getblock32,1,getblock32,"uint32_t getblock32 (uint32_t*,int)",murmur3_hash.c,"static FORCE_INLINE uint32_t getblock32 ( const uint32_t * p, int i )
{
  return p[i];
}",48.0,51.0,1.0,7.0,4.0,1,1,2,2,1,0,1,1,0,0,,0,0,4,2,2,uint32_t
738,45202,fmix32,1,fmix32,uint32_t fmix32 (uint32_t),murmur3_hash.c,"static FORCE_INLINE uint32_t fmix32 ( uint32_t h )
{
  h ^= h >> 16;
  h *= 0x85ebca6b;
  h ^= h >> 13;
  h *= 0xc2b2ae35;
  h ^= h >> 16;

  return h;
}",56.0,65.0,1.0,7.0,10.0,5,2,9,1,1,0,1,1,0,0,,0,0,2,1,1,uint32_t
739,45230,MurmurHash3_x86_32,1,MurmurHash3_x86_32,"uint32_t MurmurHash3_x86_32 (void*,size_t)",murmur3_hash.c,"uint32_t MurmurHash3_x86_32 ( const void * key, size_t length)
{
  const uint8_t * data = (const uint8_t*)key;
  const int nblocks = length / 4;

  uint32_t h1 = 0;

  uint32_t c1 = 0xcc9e2d51;
  uint32_t c2 = 0x1b873593;

  //----------
  // body

  const uint32_t * blocks = (const uint32_t *)(data + nblocks*4);

  for(int i = -nblocks; i; i++)
  {
    uint32_t k1 = getblock32(blocks,i);

    k1 *= c1;
    k1 = ROTL32(k1,15);
    k1 *= c2;

    h1 ^= k1;
    h1 = ROTL32(h1,13);
    h1 = h1*5+0xe6546b64;
  }

  //----------
  // tail

  const uint8_t * tail = (const uint8_t*)(data + nblocks*4);

  uint32_t k1 = 0;

  switch(length & 3)
  {
  case 3: k1 ^= tail[2] << 16;
  case 2: k1 ^= tail[1] << 8;
  case 1: k1 ^= tail[0];
          k1 *= c1; k1 = ROTL32(k1,15); k1 *= c2; h1 ^= k1;
  };

  //----------
  // finalization

  h1 ^= length;

  h1 = fmix32(h1);

  //*(uint32_t*)out = h1;
  return h1;
}",71.0,123.0,1.0,9.0,53.0,36,10,55,11,0,5,3,3,0,5,,0,5,4,2,2,uint32_t
740,45493,complete_update_bin,1,complete_update_bin,void complete_update_bin (conn*),proto_bin.c,"static void complete_update_bin(conn *c) {
    protocol_binary_response_status eno = PROTOCOL_BINARY_RESPONSE_EINVAL;
    enum store_item_type ret = NOT_STORED;
    assert(c != NULL);

    item *it = c->item;
    pthread_mutex_lock(&c->thread->stats.mutex);
    c->thread->stats.slab_stats[ITEM_clsid(it)].set_cmds++;
    pthread_mutex_unlock(&c->thread->stats.mutex);

    /* We don't actually receive the trailing two characters in the bin
     * protocol, so we're going to just set them here */
    if ((it->it_flags & ITEM_CHUNKED) == 0) {
        *(ITEM_data(it) + it->nbytes - 2) = '\r';
        *(ITEM_data(it) + it->nbytes - 1) = '\n';
    } else {
        assert(c->ritem);
        item_chunk *ch = (item_chunk *) c->ritem;
        if (ch->size == ch->used)
            ch = ch->next;
        assert(ch->size - ch->used >= 2);
        ch->data[ch->used] = '\r';
        ch->data[ch->used + 1] = '\n';
        ch->used += 2;
    }

    ret = store_item(it, c->cmd, c);

#ifdef ENABLE_DTRA...",359.0,439.0,1.0,32.0,81.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
741,45498,process_bin_complete_sasl_auth,1,process_bin_complete_sasl_auth,void process_bin_complete_sasl_auth (conn*),proto_bin.c,"static void process_bin_complete_sasl_auth(conn *c) {
    assert(settings.sasl);
    const char *out = NULL;
    unsigned int outlen = 0;

    assert(c->item);
    init_sasl_conn(c);

    int nkey = c->binary_header.request.keylen;
    int vlen = c->binary_header.request.bodylen - nkey;

    if (nkey > ((item*) c->item)->nkey) {
        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_EINVAL, NULL, vlen);
        conn_set_state(c, conn_swallow);
        return;
    }

    char mech[nkey+1];
    memcpy(mech, ITEM_key((item*)c->item), nkey);
    mech[nkey] = 0x00;

    if (settings.verbose)
        fprintf(stderr, ""mech:  ``%s'' with %d bytes of data\n"", mech, vlen);

    const char *challenge = vlen == 0 ? NULL : ITEM_data((item*) c->item);

    if (vlen > ((item*) c->item)->nbytes) {
        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_EINVAL, NULL, vlen);
        conn_set_state(c, conn_swallow);
        return;
    }

    int result=-1;

    switch (c->cmd) {
    case PROTOCOL_BINARY_CMD...",767.0,860.0,1.0,17.0,94.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
742,45510,complete_nread_binary,1,complete_nread_binary,void complete_nread_binary (conn*),proto_bin.c,"void complete_nread_binary(conn *c) {
    assert(c != NULL);
    assert(c->cmd >= 0);

    switch(c->substate) {
    case bin_read_set_value:
        complete_update_bin(c);
        break;
    case bin_reading_sasl_auth_data:
        process_bin_complete_sasl_auth(c);
        if (c->item) {
            do_item_remove(c->item);
            c->item = NULL;
        }
        break;
    default:
        fprintf(stderr, ""Not handling substate %d\n"", c->substate);
        assert(0);
    }
}",31.0,50.0,1.0,1.0,20.0,9,4,14,5,0,9,5,4,2,3,,0,6,2,1,1,void
743,45563,try_read_command_binary,1,try_read_command_binary,int try_read_command_binary (conn*),proto_bin.c,"int try_read_command_binary(conn *c) {
    /* Do we have the complete packet header? */
    if (c->rbytes < sizeof(c->binary_header)) {
        /* need more data! */
        return 0;
    } else {
        memcpy(&c->binary_header, c->rcurr, sizeof(c->binary_header));
        protocol_binary_request_header* req;
        req = &c->binary_header;

        if (settings.verbose > 1) {
            /* Dump the packet before we convert it to host order */
            int ii;
            fprintf(stderr, ""<%d Read binary protocol data:"", c->sfd);
            for (ii = 0; ii < sizeof(req->bytes); ++ii) {
                if (ii % 4 == 0) {
                    fprintf(stderr, ""\n<%d   "", c->sfd);
                }
                fprintf(stderr, "" 0x%02x"", req->bytes[ii]);
            }
            fprintf(stderr, ""\n"");
        }

        c->binary_header = *req;
        c->binary_header.request.keylen = ntohs(req->request.keylen);
        c->binary_header.request.bodylen = ntohl(req->request.b...",52.0,126.0,1.0,47.0,75.0,4,3,2,1,0,2,2,2,2,0,,0,2,2,1,1,int
744,45878,binary_get_key,1,binary_get_key,char* binary_get_key (conn*),proto_bin.c,"static char* binary_get_key(conn *c) {
    return c->rcurr - (c->binary_header.request.keylen);
}",131.0,133.0,1.0,1.0,3.0,5,3,2,1,0,2,1,1,0,0,,0,2,2,1,1,char*
745,45895,add_bin_header,1,add_bin_header,"void add_bin_header (conn*,uint16_t,uint8_t,uint16_t,uint32_t)",proto_bin.c,"static void add_bin_header(conn *c, uint16_t err, uint8_t hdr_len, uint16_t key_len, uint32_t body_len) {
    protocol_binary_response_header* header;
    mc_resp *resp = c->resp;

    assert(c);

    resp_reset(resp);

    header = (protocol_binary_response_header *)resp->wbuf;

    header->response.magic = (uint8_t)PROTOCOL_BINARY_RES;
    header->response.opcode = c->binary_header.request.opcode;
    header->response.keylen = (uint16_t)htons(key_len);

    header->response.extlen = (uint8_t)hdr_len;
    header->response.datatype = (uint8_t)PROTOCOL_BINARY_RAW_BYTES;
    header->response.status = (uint16_t)htons(err);

    header->response.bodylen = htonl(body_len);
    header->response.opaque = c->opaque;
    header->response.cas = htonll(c->cas);

    if (settings.verbose > 1) {
        int ii;
        fprintf(stderr, "">%d Writing bin response:"", c->sfd);
        for (ii = 0; ii < sizeof(header->bytes); ++ii) {
            if (ii % 4 == 0) {
                fprintf(stderr, ""\n>%...",135.0,171.0,1.0,1.0,37.0,60,10,42,12,2,12,4,7,2,3,,0,10,10,5,5,void
746,46077,write_bin_error,1,write_bin_error,"void write_bin_error (conn*,protocol_binary_response_status,char*,int)",proto_bin.c,"void write_bin_error(conn *c, protocol_binary_response_status err,
                            const char *errstr, int swallow) {
    size_t len;

    if (!errstr) {
        switch (err) {
        case PROTOCOL_BINARY_RESPONSE_ENOMEM:
            errstr = ""Out of memory"";
            break;
        case PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND:
            errstr = ""Unknown command"";
            break;
        case PROTOCOL_BINARY_RESPONSE_KEY_ENOENT:
            errstr = ""Not found"";
            break;
        case PROTOCOL_BINARY_RESPONSE_EINVAL:
            errstr = ""Invalid arguments"";
            break;
        case PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS:
            errstr = ""Data exists for key."";
            break;
        case PROTOCOL_BINARY_RESPONSE_E2BIG:
            errstr = ""Too large."";
            break;
        case PROTOCOL_BINARY_RESPONSE_DELTA_BADVAL:
            errstr = ""Non-numeric server-side value for incr or decr"";
            break;
        case PROTOCOL_BIN...",179.0,234.0,1.0,1.0,56.0,21,5,43,18,4,8,15,7,1,3,,0,5,8,4,4,void
747,46213,handle_binary_protocol_error,1,handle_binary_protocol_error,void handle_binary_protocol_error (conn*),proto_bin.c,"static void handle_binary_protocol_error(conn *c) {
    write_bin_error(c, PROTOCOL_BINARY_RESPONSE_EINVAL, NULL, 0);
    if (settings.verbose) {
        fprintf(stderr, ""Protocol error (opcode %02x), close connection %d\n"",
                c->binary_header.request.opcode, c->sfd);
    }
    c->close_after_write = true;
}",237.0,244.0,1.0,1.0,8.0,7,3,9,6,0,5,2,2,1,1,,0,4,2,1,1,void
748,46246,write_bin_response,1,write_bin_response,"void write_bin_response (conn*,void*,int,int,int)",proto_bin.c,"static void write_bin_response(conn *c, void *d, int hlen, int keylen, int dlen) {
    if (!c->noreply || c->cmd == PROTOCOL_BINARY_CMD_GET ||
        c->cmd == PROTOCOL_BINARY_CMD_GETK) {
        add_bin_header(c, 0, hlen, keylen, dlen);
        mc_resp *resp = c->resp;
        if (dlen > 0) {
            resp_add_iov(resp, d, dlen);
        }
    }

    conn_set_state(c, conn_new_cmd);
}",247.0,258.0,1.0,1.0,12.0,11,6,17,9,1,7,3,4,3,3,,0,4,10,5,5,void
749,48077,init_sasl_conn,1,init_sasl_conn,void init_sasl_conn (conn*),proto_bin.c,"static void init_sasl_conn(conn *c) {
    assert(c);
    /* should something else be returned? */
    if (!settings.sasl)
        return;

    c->authenticated = false;

    if (!c->sasl_conn) {
        int result=sasl_server_new(""memcached"",
                                   NULL,
                                   my_sasl_hostname[0] ? my_sasl_hostname : NULL,
                                   NULL, NULL,
                                   NULL, 0, &c->sasl_conn);
        if (result != SASL_OK) {
            if (settings.verbose) {
                fprintf(stderr, ""Failed to initialize SASL conn.\n"");
            }
            c->sasl_conn = NULL;
        }
    }
}",673.0,694.0,1.0,19.0,22.0,11,5,11,6,1,5,5,8,3,0,,0,5,2,1,1,void
750,48128,bin_list_sasl_mechs,1,bin_list_sasl_mechs,void bin_list_sasl_mechs (conn*),proto_bin.c,"static void bin_list_sasl_mechs(conn *c) {
    // Guard against a disabled SASL.
    if (!settings.sasl) {
        write_bin_error(c, PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND, NULL,
                        c->binary_header.request.bodylen
                        - c->binary_header.request.keylen);
        return;
    }

    init_sasl_conn(c);
    const char *result_string = NULL;
    unsigned int string_length = 0;
    int result=sasl_listmech(c->sasl_conn, NULL,
                             """",   /* What to prepend the string with */
                             "" "",  /* What to separate mechanisms with */
                             """",   /* What to append to the string */
                             &result_string, &string_length,
                             NULL);
    if (result != SASL_OK) {
        /* Perhaps there's a better error for this... */
        if (settings.verbose) {
            fprintf(stderr, ""Failed to list SASL mechanisms.\n"");
        }
        write_bin_err...",696.0,723.0,1.0,15.0,28.0,15,7,20,9,0,8,4,5,2,4,,0,4,2,1,1,void
751,48779,authenticated,1,authenticated,bool authenticated (conn*),proto_bin.c,"static bool authenticated(conn *c) {
    assert(settings.sasl);
    bool rv = false;

    switch (c->cmd) {
    case PROTOCOL_BINARY_CMD_SASL_LIST_MECHS: /* FALLTHROUGH */
    case PROTOCOL_BINARY_CMD_SASL_AUTH:       /* FALLTHROUGH */
    case PROTOCOL_BINARY_CMD_SASL_STEP:       /* FALLTHROUGH */
    case PROTOCOL_BINARY_CMD_VERSION:         /* FALLTHROUGH */
        rv = true;
        break;
    default:
        rv = c->authenticated;
    }

    if (settings.verbose > 1) {
        fprintf(stderr, ""authenticated() in cmd 0x%02x is %s\n"",
                c->cmd, rv ? ""true"" : ""false"");
    }

    return rv;
}",862.0,883.0,1.0,1.0,22.0,10,5,17,10,0,5,4,3,2,0,,0,5,2,1,1,bool
752,50476,proxy_process_command,1,proxy_process_command,"void proxy_process_command (conn*,char*,size_t,bool)",proto_proxy.c,"static void proxy_process_command(conn *c, char *command, size_t cmdlen, bool multiget) {
    assert(c != NULL);
    LIBEVENT_THREAD *thr = c->thread;
    struct proxy_hook *hooks = thr->proxy_hooks;
    lua_State *L = thr->L;
    mcp_parser_t pr = {0};

    // Avoid doing resp_start() here, instead do it a bit later or as-needed.
    // This allows us to hop over to the internal text protocol parser, which
    // also calls resp_start().
    // Tighter integration later should obviate the need for this, it is not a
    // permanent solution.
    int ret = process_request(&pr, command, cmdlen);
    if (ret != 0) {
        WSTAT_INCR(c, proxy_conn_errors, 1);
        if (!resp_start(c)) {
            conn_set_state(c, conn_closing);
            return;
        }
        proxy_out_errstring(c->resp, ""parsing request"");
        if (ret == -2) {
            // Kill connection on more critical parse failure.
            conn_set_state(c, conn_closing);
        }
        return;
    }

  ...",619.0,803.0,1.0,8.0,185.0,0,0,0,0,1,0,1,1,0,0,,0,0,8,4,4,void
753,50498,proxy_stats,1,proxy_stats,"void proxy_stats (ADD_STAT,conn*)",proto_proxy.c,"void proxy_stats(ADD_STAT add_stats, conn *c) {
    if (!settings.proxy_enabled) {
       return;
    }
    proxy_ctx_t *ctx = settings.proxy_ctx;
    STAT_L(ctx);

    APPEND_STAT(""proxy_config_reloads"", ""%llu"", (unsigned long long)ctx->global_stats.config_reloads);
    APPEND_STAT(""proxy_config_reload_fails"", ""%llu"", (unsigned long long)ctx->global_stats.config_reload_fails);
    APPEND_STAT(""proxy_backend_total"", ""%llu"", (unsigned long long)ctx->global_stats.backend_total);
    APPEND_STAT(""proxy_backend_marked_bad"", ""%llu"", (unsigned long long)ctx->global_stats.backend_marked_bad);
    APPEND_STAT(""proxy_backend_failed"", ""%llu"", (unsigned long long)ctx->global_stats.backend_failed);
    STAT_UL(ctx);
}",24.0,37.0,1.0,4.0,14.0,23,6,22,4,0,14,2,2,1,5,,0,9,4,2,2,void
754,50613,process_proxy_stats,1,process_proxy_stats,"void process_proxy_stats (ADD_STAT,conn*)",proto_proxy.c,"void process_proxy_stats(ADD_STAT add_stats, conn *c) {
    char key_str[STAT_KEY_LEN];
    struct proxy_int_stats istats = {0};

    if (!settings.proxy_enabled) {
        return;
    }
    proxy_ctx_t *ctx = settings.proxy_ctx;
    STAT_L(ctx);

    // prepare aggregated counters.
    struct proxy_user_stats *us = &ctx->user_stats;
    uint64_t counters[us->num_stats];
    memset(counters, 0, sizeof(counters));

    // aggregate worker thread counters.
    for (int x = 0; x < settings.num_threads; x++) {
        LIBEVENT_THREAD *t = get_worker_thread(x);
        struct proxy_user_stats *tus = t->proxy_user_stats;
        struct proxy_int_stats *is = t->proxy_int_stats;
        WSTAT_L(t);
        for (int i = 0; i < CMD_FINAL; i++) {
            istats.counters[i] += is->counters[i];
        }
        if (tus && tus->num_stats >= us->num_stats) {
            for (int i = 0; i < us->num_stats; i++) {
                counters[i] += tus->counters[i];
            }
        }
        W...",39.0,99.0,1.0,17.0,61.0,114,14,134,34,0,60,7,11,6,22,,0,39,4,2,2,void
755,51136,proxy_init,1,proxy_init,void proxy_init (bool),proto_proxy.c,"void proxy_init(bool use_uring) {
    proxy_ctx_t *ctx = calloc(1, sizeof(proxy_ctx_t));
    settings.proxy_ctx = ctx;
    ctx->use_uring = use_uring;

    pthread_mutex_init(&ctx->config_lock, NULL);
    pthread_cond_init(&ctx->config_cond, NULL);
    pthread_mutex_init(&ctx->worker_lock, NULL);
    pthread_cond_init(&ctx->worker_cond, NULL);
    pthread_mutex_init(&ctx->manager_lock, NULL);
    pthread_cond_init(&ctx->manager_cond, NULL);
    pthread_mutex_init(&ctx->stats_lock, NULL);

    // FIXME (v2): default defines.
    ctx->tunables.tcp_keepalive = false;
    ctx->tunables.backend_failure_limit = 3;
    ctx->tunables.connect.tv_sec = 5;
    ctx->tunables.retry.tv_sec = 3;
    ctx->tunables.read.tv_sec = 3;
#ifdef HAVE_LIBURING
    ctx->tunables.connect_ur.tv_sec = 5;
    ctx->tunables.retry_ur.tv_sec = 3;
    ctx->tunables.read_ur.tv_sec = 3;
#endif // HAVE_LIBURING

    STAILQ_INIT(&ctx->manager_head);
    lua_State *L = luaL_newstate();
    ctx->proxy_state = L;
    luaL_...",103.0,182.0,1.0,4.0,80.0,98,7,71,13,0,24,3,4,0,3,,0,21,2,1,1,void
756,51413,proxy_thread_init,1,proxy_thread_init,void proxy_thread_init (LIBEVENT_THREAD*),proto_proxy.c,"void proxy_thread_init(LIBEVENT_THREAD *thr) {
    // Create the hook table.
    thr->proxy_hooks = calloc(CMD_SIZE, sizeof(struct proxy_hook));
    if (thr->proxy_hooks == NULL) {
        fprintf(stderr, ""Failed to allocate proxy hooks\n"");
        exit(EXIT_FAILURE);
    }
    thr->proxy_int_stats = calloc(1, sizeof(struct proxy_int_stats));
    if (thr->proxy_int_stats == NULL) {
        fprintf(stderr, ""Failed to allocate proxy thread stats\n"");
        exit(EXIT_FAILURE);
    }

    // Initialize the lua state.
    lua_State *L = luaL_newstate();
    thr->L = L;
    luaL_openlibs(L);
    proxy_register_libs(thr, L);
    // TODO: srand on time? do we need to bother?
    for (int x = 0; x < 3; x++) {
        thr->proxy_rng[x] = rand();
    }

    // kick off the configuration.
    if (proxy_thread_loadconf(thr) != 0) {
        exit(EXIT_FAILURE);
    }
}",185.0,212.0,1.0,1.0,28.0,19,7,25,9,0,8,5,5,3,2,,0,7,2,1,1,void
757,51702,proxy_return_cb,1,proxy_return_cb,void proxy_return_cb (io_pending_t*),proto_proxy.c,"void proxy_return_cb(io_pending_t *pending) {
    io_pending_proxy_t *p = (io_pending_proxy_t *)pending;
    if (p->is_await) {
        mcplib_await_return(p);
    } else {
        lua_State *Lc = p->coro;

        // in order to resume we need to remove the objects that were
        // originally returned
        // what's currently on the top of the stack is what we want to keep.
        lua_rotate(Lc, 1, 1);
        // We kept the original results from the yield so lua would not
        // collect them in the meantime. We can drop those now.
        lua_settop(Lc, 1);

        // p can be freed/changed from the call below, so fetch the queue now.
        io_queue_t *q = conn_io_queue_get(p->c, p->io_queue_type);
        conn *c = p->c;
        proxy_run_coroutine(Lc, p->resp, p, c);

        q->count--;
        if (q->count == 0) {
            // call re-add directly since we're already in the worker thread.
            conn_worker_readd(c);
        }
    }
}",282.0,308.0,1.0,1.0,27.0,3,3,4,2,0,1,2,2,0,1,,0,0,2,1,1,void
758,51796,try_read_command_proxy,1,try_read_command_proxy,int try_read_command_proxy (conn*),proto_proxy.c,"int try_read_command_proxy(conn *c) {
    char *el, *cont;

    if (c->rbytes == 0)
        return 0;

    el = memchr(c->rcurr, '\n', c->rbytes);
    if (!el) {
        if (c->rbytes > 1024) {
            /*
             * We didn't have a '\n' in the first k. This _has_ to be a
             * large multiget, if not we should just nuke the connection.
             */
            char *ptr = c->rcurr;
            while (*ptr == ' ') { /* ignore leading whitespaces */
                ++ptr;
            }

            if (ptr - c->rcurr > 100 ||
                (strncmp(ptr, ""get "", 4) && strncmp(ptr, ""gets "", 5))) {

                conn_set_state(c, conn_closing);
                return 1;
            }

            // ASCII multigets are unbound, so our fixed size rbuf may not
            // work for this particular workload... For backcompat we'll use a
            // malloc/realloc/free routine just for this.
            if (!c->rbuf_malloced) {
                if (!rbuf_switch_t...",326.0,378.0,1.0,56.0,53.0,43,13,40,7,0,22,8,18,5,4,,0,19,2,1,1,int
759,51950,proxy_cleanup_conn,1,proxy_cleanup_conn,void proxy_cleanup_conn (conn*),proto_proxy.c,"void proxy_cleanup_conn(conn *c) {
    assert(c->proxy_coro_ref != 0);
    LIBEVENT_THREAD *thr = c->thread;
    lua_State *L = thr->L;
    luaL_unref(L, LUA_REGISTRYINDEX, c->proxy_coro_ref);
    c->proxy_coro_ref = 0;
    WSTAT_DECR(c, proxy_req_active, 1);
}",382.0,389.0,1.0,4.0,8.0,21,6,13,4,0,8,1,1,0,0,,0,8,2,1,1,void
760,52015,complete_nread_proxy,1,complete_nread_proxy,void complete_nread_proxy (conn*),proto_proxy.c,"void complete_nread_proxy(conn *c) {
    assert(c != NULL);

    LIBEVENT_THREAD *thr = c->thread;
    lua_State *L = thr->L;

    if (c->proxy_coro_ref == 0) {
        complete_nread_ascii(c);
        return;
    }

    conn_set_state(c, conn_new_cmd);

    // Grab our coroutine.
    lua_rawgeti(L, LUA_REGISTRYINDEX, c->proxy_coro_ref);
    luaL_unref(L, LUA_REGISTRYINDEX, c->proxy_coro_ref);
    lua_State *Lc = lua_tothread(L, -1);
    mcp_request_t *rq = luaL_checkudata(Lc, -1, ""mcp.request"");

    // validate the data chunk.
    if (strncmp((char *)c->item + rq->pr.vlen - 2, ""\r\n"", 2) != 0) {
        lua_settop(L, 0); // clear anything remaining on the main thread.
        // FIXME (v2): need to set noreply false if mset_res, but that's kind
        // of a weird hack to begin with. Evaluate how to best do that here.
        out_string(c, ""CLIENT_ERROR bad data chunk"");
        return;
    }

    // We move ownership of the c->item buffer from the connection to the
    // reque...",392.0,433.0,1.0,1.0,42.0,31,9,36,9,0,15,3,3,2,4,,0,11,2,1,1,void
761,52138,proxy_lua_error,1,proxy_lua_error,"void proxy_lua_error (lua_State*,char*)",proto_proxy.c,"void proxy_lua_error(lua_State *L, const char *s) {
    lua_pushstring(L, s);
    lua_error(L);
}",438.0,441.0,1.0,1.0,4.0,0,0,3,2,11,0,1,1,0,0,,0,0,4,2,2,void
762,52149,proxy_lua_ferror,1,proxy_lua_ferror,"void proxy_lua_ferror (lua_State*,char*...)",proto_proxy.c,"void proxy_lua_ferror(lua_State *L, const char *fmt, ...) {
    va_list ap;
    va_start(ap, fmt);
    lua_pushfstring(L, fmt, ap);
    va_end(ap);
    lua_error(L);
}",443.0,449.0,1.0,1.0,7.0,0,0,7,3,2,0,1,1,0,0,,0,0,4,2,2,void
763,52248,_set_noreply_mode,1,_set_noreply_mode,"void _set_noreply_mode (mc_resp*,mcp_resp_t*)",proto_proxy.c,"static void _set_noreply_mode(mc_resp *resp, mcp_resp_t *r) {
    switch (r->mode) {
        case RESP_MODE_NORMAL:
            break;
        case RESP_MODE_NOREPLY:
            // ascii noreply only threw egregious errors to client
            if (r->status == MCMC_OK) {
                resp->skip = true;
            }
            break;
        case RESP_MODE_METAQUIET:
            if (r->resp.code == MCMC_CODE_MISS) {
                resp->skip = true;
            } else if (r->cmd != CMD_MG && r->resp.code == MCMC_CODE_OK) {
                // FIXME (v2): mcmc's parser needs to help us out a bit more
                // here.
                // This is a broken case in the protocol though; quiet mode
                // ignores HD for mutations but not get.
                resp->skip = true;
            }
            break;
        default:
            assert(1 == 0);
    }
}",486.0,510.0,1.0,29.0,25.0,11,4,10,6,1,3,7,6,3,0,,0,3,4,2,2,void
764,52327,proxy_run_coroutine,1,proxy_run_coroutine,"int proxy_run_coroutine (lua_State*,mc_resp*,io_pending_proxy_t*,conn*)",proto_proxy.c,"int proxy_run_coroutine(lua_State *Lc, mc_resp *resp, io_pending_proxy_t *p, conn *c) {
    int nresults = 0;
    int cores = lua_resume(Lc, NULL, 1, &nresults);
    size_t rlen = 0;

    if (cores == LUA_OK) {
        WSTAT_DECR(c, proxy_req_active, 1);
        int type = lua_type(Lc, 1);
        if (type == LUA_TUSERDATA) {
            mcp_resp_t *r = luaL_checkudata(Lc, 1, ""mcp.response"");
            _set_noreply_mode(resp, r);
            if (r->buf) {
                // response set from C.
                // FIXME (v2): write_and_free() ? it's a bit wrong for here.
                resp->write_and_free = r->buf;
                resp_add_iov(resp, r->buf, r->blen);
                r->buf = NULL;
            } else if (lua_getiuservalue(Lc, 1, 1) != LUA_TNIL) {
                // uservalue slot 1 is pre-created, so we get TNIL instead of
                // TNONE when nothing was set into it.
                const char *s = lua_tolstring(Lc, -1, &rlen);
                size_t l =...",523.0,617.0,1.0,8.0,95.0,28,6,28,11,1,10,4,7,1,2,,0,8,8,4,4,int
765,53858,proxy_load_config,1,proxy_load_config,int proxy_load_config (void*),proxy_config.c,"int proxy_load_config(void *arg) {
    proxy_ctx_t *ctx = arg;
    lua_State *L = ctx->proxy_state;
    int res = luaL_loadfile(L, settings.proxy_startfile);
    if (res != LUA_OK) {
        fprintf(stderr, ""ERROR: Failed to load proxy_startfile: %s\n"", lua_tostring(L, -1));
        return -1;
    }
    // LUA_OK, LUA_ERRSYNTAX, LUA_ERRMEM, LUA_ERRFILE

    // Now we need to dump the compiled code into bytecode.
    // This will then get loaded into worker threads.
    struct _dumpbuf *db = malloc(sizeof(struct _dumpbuf));
    db->size = 16384;
    db->used = 0;
    db->buf = malloc(db->size);
    lua_dump(L, _dump_helper, db, 0);
    // 0 means no error.
    ctx->proxy_code = db;

    // now we complete the data load by calling the function.
    res = lua_pcall(L, 0, LUA_MULTRET, 0);
    if (res != LUA_OK) {
        fprintf(stderr, ""ERROR: Failed to load data into lua config state: %s\n"", lua_tostring(L, -1));
        exit(EXIT_FAILURE);
    }

    // call the mcp_config_pools func...",185.0,227.0,1.0,1.0,43.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,int
766,53889,proxy_register_libs,1,proxy_register_libs,"int proxy_register_libs (LIBEVENT_THREAD*,void*)",proxy_lua.c,"int proxy_register_libs(LIBEVENT_THREAD *t, void *ctx) {
    lua_State *L = ctx;

    const struct luaL_Reg mcplib_backend_m[] = {
        {""set"", NULL},
        {""__gc"", mcplib_backend_gc},
        {NULL, NULL}
    };

    const struct luaL_Reg mcplib_request_m[] = {
        {""command"", mcplib_request_command},
        {""key"", mcplib_request_key},
        {""ltrimkey"", mcplib_request_ltrimkey},
        {""rtrimkey"", mcplib_request_rtrimkey},
        {""token"", mcplib_request_token},
        {""ntokens"", mcplib_request_ntokens},
        {""has_flag"", mcplib_request_has_flag},
        {""flag_token"", mcplib_request_flag_token},
        {""__tostring"", NULL},
        {""__gc"", mcplib_request_gc},
        {NULL, NULL}
    };

    const struct luaL_Reg mcplib_response_m[] = {
        {""ok"", mcplib_response_ok},
        {""hit"", mcplib_response_hit},
        {""vlen"", mcplib_response_vlen},
        {""code"", mcplib_response_code},
        {""line"", mcplib_response_line},
        {""__gc"", mcplib_resp...",869.0,996.0,1.0,1.0,128.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,int
767,53922,_finalize_mset,1,_finalize_mset,"void _finalize_mset (conn*,store_item_type)",proto_text.c,"static void _finalize_mset(conn *c, enum store_item_type ret) {
    mc_resp *resp = c->resp;
    item *it = c->item;
    conn_set_state(c, conn_new_cmd);

    // information about the response line has been stashed in wbuf.
    char *p = resp->wbuf + resp->wbytes;
    char *end = p; // end of the stashed data portion.

    switch (ret) {
    case STORED:
      if (settings.meta_response_old) {
          memcpy(p, ""OK"", 2);
      } else {
          memcpy(p, ""HD"", 2);
      }
      // Only place noreply is used for meta cmds is a nominal response.
      if (c->noreply) {
          resp->skip = true;
      }
      break;
    case EXISTS:
      memcpy(p, ""EX"", 2);
      break;
    case NOT_FOUND:
      memcpy(p, ""NF"", 2);
      break;
    case NOT_STORED:
      memcpy(p, ""NS"", 2);
      break;
    default:
      c->noreply = false;
      out_string(c, ""SERVER_ERROR Unhandled storage type."");
      return;
    }
    p += 2;

    for (char *fp = resp->wbuf; fp < end; fp++) {
        swit...",54.0,122.0,1.0,16.0,69.0,86,18,81,16,0,11,15,12,2,5,,0,7,4,2,2,void
768,54224,complete_nread_ascii,1,complete_nread_ascii,void complete_nread_ascii (conn*),proto_text.c,"void complete_nread_ascii(conn *c) {
    assert(c != NULL);

    item *it = c->item;
    int comm = c->cmd;
    enum store_item_type ret;
    bool is_valid = false;

    pthread_mutex_lock(&c->thread->stats.mutex);
    c->thread->stats.slab_stats[ITEM_clsid(it)].set_cmds++;
    pthread_mutex_unlock(&c->thread->stats.mutex);

    if ((it->it_flags & ITEM_CHUNKED) == 0) {
        if (strncmp(ITEM_data(it) + it->nbytes - 2, ""\r\n"", 2) == 0) {
            is_valid = true;
        }
    } else {
        char buf[2];
        /* should point to the final item chunk */
        item_chunk *ch = (item_chunk *) c->ritem;
        assert(ch->used != 0);
        /* :( We need to look at the last two bytes. This could span two
         * chunks.
         */
        if (ch->used > 1) {
            buf[0] = ch->data[ch->used - 2];
            buf[1] = ch->data[ch->used - 1];
        } else {
            assert(ch->prev);
            assert(ch->used == 1);
            buf[0] = ch->prev->data[ch->prev...",128.0,234.0,1.0,32.0,107.0,59,17,35,9,1,13,5,7,1,2,,0,11,2,1,1,void
769,54546,tokenize_command,1,tokenize_command,"size_t tokenize_command (char*,token_t*,size_t)",proto_text.c,"static size_t tokenize_command(char *command, token_t *tokens, const size_t max_tokens) {
    char *s, *e;
    size_t ntokens = 0;
    assert(command != NULL && tokens != NULL && max_tokens > 1);
    size_t len = strlen(command);
    unsigned int i = 0;

    s = e = command;
    for (i = 0; i < len; i++) {
        if (*e == ' ') {
            if (s != e) {
                tokens[ntokens].value = s;
                tokens[ntokens].length = e - s;
                ntokens++;
                *e = '\0';
                if (ntokens == max_tokens - 1) {
                    e++;
                    s = e; /* so we don't add an extra token */
                    break;
                }
            }
            s = e + 1;
        }
        e++;
    }

    if (s != e) {
        tokens[ntokens].value = s;
        tokens[ntokens].length = e - s;
        ntokens++;
    }

    /*
     * If we scanned the whole string, the terminal value pointer is null,
     * otherwise it is the first unprocess...",283.0,324.0,1.0,1.0,42.0,51,13,54,9,4,0,7,12,0,0,,0,0,6,3,3,size_t
770,54696,try_read_command_asciiauth,1,try_read_command_asciiauth,int try_read_command_asciiauth (conn*),proto_text.c,"int try_read_command_asciiauth(conn *c) {
    token_t tokens[MAX_TOKENS];
    size_t ntokens;
    char *cont = NULL;

    // TODO: move to another function.
    if (!c->sasl_started) {
        char *el;
        uint32_t size = 0;

        // impossible for the auth command to be this short.
        if (c->rbytes < 2)
            return 0;

        el = memchr(c->rcurr, '\n', c->rbytes);

        // If no newline after 1k, getting junk data, close out.
        if (!el) {
            if (c->rbytes > 2048) {
                conn_set_state(c, conn_closing);
                return 1;
            }
            return 0;
        }

        // Looking for: ""set foo 0 0 N\r\nuser pass\r\n""
        // key, flags, and ttl are ignored. N is used to see if we have the rest.

        // so tokenize doesn't walk past into the value.
        // it's fine to leave the \r in, as strtoul will stop at it.
        *el = '\0';

        ntokens = tokenize_command(c->rcurr, tokens, MAX_TOKENS);
        // ...",326.0,436.0,1.0,19.0,111.0,91,17,69,11,0,41,14,25,12,13,,0,34,2,1,1,int
771,55041,try_read_command_ascii,1,try_read_command_ascii,int try_read_command_ascii (conn*),proto_text.c,"int try_read_command_ascii(conn *c) {
    char *el, *cont;

    if (c->rbytes == 0)
        return 0;

    el = memchr(c->rcurr, '\n', c->rbytes);
    if (!el) {
        if (c->rbytes > 2048) {
            /*
             * We didn't have a '\n' in the first few k. This _has_ to be a
             * large multiget, if not we should just nuke the connection.
             */
            char *ptr = c->rcurr;
            while (*ptr == ' ') { /* ignore leading whitespaces */
                ++ptr;
            }

            if (ptr - c->rcurr > 100 ||
                (strncmp(ptr, ""get "", 4) && strncmp(ptr, ""gets "", 5))) {

                conn_set_state(c, conn_closing);
                return 1;
            }

            // ASCII multigets are unbound, so our fixed size rbuf may not
            // work for this particular workload... For backcompat we'll use a
            // malloc/realloc/free routine just for this.
            if (!c->rbuf_malloced) {
                if (!rbuf_swit...",438.0,493.0,1.0,1.0,56.0,51,14,42,6,0,22,9,19,6,4,,0,19,2,1,1,int
772,55209,set_noreply_maybe,1,set_noreply_maybe,"bool set_noreply_maybe (conn*,token_t*,size_t)",proto_text.c,"static inline bool set_noreply_maybe(conn *c, token_t *tokens, size_t ntokens)
{
    int noreply_index = ntokens - 2;

    /*
      NOTE: this function is not the first place where we are going to
      send the reply.  We could send it instead from process_command()
      if the request line has wrong number of tokens.  However parsing
      malformed line for ""noreply"" option is not reliable anyway, so
      it can't be helped.
    */
    if (tokens[noreply_index].value
        && strcmp(tokens[noreply_index].value, ""noreply"") == 0) {
        c->noreply = true;
    }
    return c->noreply;
}",496.0,512.0,1.0,1.0,17.0,11,7,9,5,10,2,2,2,0,0,,0,2,6,3,3,bool
773,55248,make_ascii_get_suffix,1,make_ascii_get_suffix,"int make_ascii_get_suffix (char*,item*,bool,int)",proto_text.c,"static inline int make_ascii_get_suffix(char *suffix, item *it, bool return_cas, int nbytes) {
    char *p = suffix;
    *p = ' ';
    p++;
    if (FLAGS_SIZE(it) == 0) {
        *p = '0';
        p++;
    } else {
        p = itoa_u32(*((uint32_t *) ITEM_suffix(it)), p);
    }
    *p = ' ';
    p = itoa_u32(nbytes-2, p+1);

    if (return_cas) {
        *p = ' ';
        p = itoa_u64(ITEM_get_cas(it), p+1);
    }

    *p = '\r';
    *(p+1) = '\n';
    *(p+2) = '\0';
    return (p - suffix) + 2;
}",515.0,537.0,1.0,8.0,23.0,37,11,25,6,1,2,3,3,0,2,,0,2,8,4,4,int
774,55387,process_get_command,1,process_get_command,"void process_get_command (conn*,token_t*,size_t,bool,bool)",proto_text.c,"static inline void process_get_command(conn *c, token_t *tokens, size_t ntokens, bool return_cas, bool should_touch) {
    char *key;
    size_t nkey;
    item *it;
    token_t *key_token = &tokens[KEY_TOKEN];
    int32_t exptime_int = 0;
    rel_time_t exptime = 0;
    bool fail_length = false;
    assert(c != NULL);
    mc_resp *resp = c->resp;

    if (should_touch) {
        // For get and touch commands, use first token as exptime
        if (!safe_strtol(tokens[1].value, &exptime_int)) {
            out_string(c, ""CLIENT_ERROR invalid exptime argument"");
            return;
        }
        key_token++;
        exptime = realtime(EXPTIME_TO_POSITIVE_TIME(exptime_int));
    }

    do {
        while(key_token->length != 0) {
            bool overflow; // not used here.
            key = key_token->value;
            nkey = key_token->length;

            if (nkey > KEY_MAX_LENGTH) {
                fail_length = true;
                goto stop;
            }

            it = ...",540.0,713.0,1.0,33.0,174.0,128,21,123,25,0,27,23,51,7,15,,0,19,10,5,5,void
775,55937,process_stats_detail,1,process_stats_detail,"void process_stats_detail (conn*,char*)",proto_text.c,"inline static void process_stats_detail(conn *c, const char *command) {
    assert(c != NULL);

    if (strcmp(command, ""on"") == 0) {
        settings.detail_enabled = 1;
        out_string(c, ""OK"");
    }
    else if (strcmp(command, ""off"") == 0) {
        settings.detail_enabled = 0;
        out_string(c, ""OK"");
    }
    else if (strcmp(command, ""dump"") == 0) {
        int len;
        char *stats = stats_prefix_dump(&len);
        write_and_free(c, stats, len);
    }
    else {
        out_string(c, ""CLIENT_ERROR usage: stats detail on|off|dump"");
    }
}",715.0,734.0,1.0,1.0,20.0,4,4,5,4,0,2,2,2,0,1,,0,1,4,2,2,void
776,56004,process_stat,1,process_stat,"void process_stat (conn*,token_t*,size_t)",proto_text.c,"static void process_stat(conn *c, token_t *tokens, const size_t ntokens) {
    const char *subcommand = tokens[SUBCOMMAND_TOKEN].value;
    assert(c != NULL);

    if (ntokens < 2) {
        out_string(c, ""CLIENT_ERROR bad command line"");
        return;
    }

    if (ntokens == 2) {
        server_stats(&append_stats, c);
        (void)get_stats(NULL, 0, &append_stats, c);
    } else if (strcmp(subcommand, ""reset"") == 0) {
        stats_reset();
        out_string(c, ""RESET"");
        return;
    } else if (strcmp(subcommand, ""detail"") == 0) {
        /* NOTE: how to tackle detail with binary? */
        if (ntokens < 4)
            process_stats_detail(c, """");  /* outputs the error message */
        else
            process_stats_detail(c, tokens[2].value);
        /* Output already generated */
        return;
    } else if (strcmp(subcommand, ""settings"") == 0) {
        process_stat_settings(&append_stats, c);
    } else if (strcmp(subcommand, ""cachedump"") == 0) {
        char...",736.0,825.0,1.0,36.0,90.0,12,9,18,6,0,5,4,4,0,5,,0,0,6,3,3,void
777,56292,process_meta_command,1,process_meta_command,"void process_meta_command (conn*,token_t*,size_t)",proto_text.c,"static void process_meta_command(conn *c, token_t *tokens, const size_t ntokens) {
    assert(c != NULL);

    if (ntokens < 3 || tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {
        out_string(c, ""CLIENT_ERROR bad command line format"");
        return;
    }

    char *key = tokens[KEY_TOKEN].value;
    size_t nkey = tokens[KEY_TOKEN].length;

    if (ntokens >= 4 && tokens[2].length == 1 && tokens[2].value[0] == 'b') {
        size_t ret = base64_decode((unsigned char *)key, nkey,
                    (unsigned char *)key, nkey);
        if (ret == 0) {
            // failed to decode.
            out_string(c, ""CLIENT_ERROR bad command line format"");
            return;
        }
        nkey = ret;
    }

    bool overflow; // not used here.
    item *it = limited_get(key, nkey, c, 0, false, DONT_UPDATE, &overflow);
    if (it) {
        mc_resp *resp = c->resp;
        size_t total = 0;
        size_t ret;
        // similar to out_string().
        memcpy(resp->wbuf, ""ME "", 3);...",828.0,890.0,1.0,30.0,63.0,118,23,82,17,1,12,6,8,0,8,,0,6,6,3,3,void
778,56708,_meta_flag_preparse,1,_meta_flag_preparse,"int _meta_flag_preparse (token_t*,size_t,_meta_flags*,char**)",proto_text.c,"static int _meta_flag_preparse(token_t *tokens, const size_t start,
        struct _meta_flags *of, char **errstr) {
    unsigned int i;
    size_t ret;
    int32_t tmp_int;
    uint8_t seen[127] = {0};
    // Start just past the key token. Look at first character of each token.
    for (i = start; tokens[i].length != 0; i++) {
        uint8_t o = (uint8_t)tokens[i].value[0];
        // zero out repeat flags so we don't over-parse for return data.
        if (o >= 127 || seen[o] != 0) {
            *errstr = ""CLIENT_ERROR duplicate flag"";
            return -1;
        }
        seen[o] = 1;
        switch (o) {
            // base64 decode the key in-place, as the binary should always be
            // shorter and the conversion code buffers bytes.
            case 'b':
                ret = base64_decode((unsigned char *)tokens[KEY_TOKEN].value, tokens[KEY_TOKEN].length,
                            (unsigned char *)tokens[KEY_TOKEN].value, tokens[KEY_TOKEN].length);
              ...",918.0,1049.0,1.0,60.0,132.0,141,16,79,10,4,34,30,33,11,8,,0,34,8,4,4,int
779,57247,process_mget_command,1,process_mget_command,"void process_mget_command (conn*,token_t*,size_t)",proto_text.c,"static void process_mget_command(conn *c, token_t *tokens, const size_t ntokens) {
    char *key;
    size_t nkey;
    item *it;
    unsigned int i = 0;
    struct _meta_flags of = {0}; // option bitflags.
    uint32_t hv; // cached hash value for unlocking an item.
    bool failed = false;
    bool item_created = false;
    bool won_token = false;
    bool ttl_set = false;
    char *errstr = ""CLIENT_ERROR bad command line format"";
    assert(c != NULL);
    mc_resp *resp = c->resp;
    char *p = resp->wbuf;

    WANT_TOKENS_MIN(ntokens, 3);

    // FIXME: do we move this check to after preparse?
    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {
        out_errstring(c, ""CLIENT_ERROR bad command line format"");
        return;
    }

    // NOTE: final token has length == 0.
    // KEY_TOKEN == 1. 0 is command.

    if (ntokens == 3) {
        // TODO: any way to fix this?
        out_errstring(c, ""CLIENT_ERROR bad command line format"");
        return;
    } else if (ntokens > MF...",1051.0,1352.0,1.0,4.0,302.0,308,24,243,24,1,41,42,64,9,23,,0,26,6,3,3,void
780,58436,process_mset_command,1,process_mset_command,"void process_mset_command (conn*,token_t*,size_t)",proto_text.c,"static void process_mset_command(conn *c, token_t *tokens, const size_t ntokens) {
    char *key;
    size_t nkey;
    item *it;
    int i;
    short comm = NREAD_SET;
    struct _meta_flags of = {0}; // option bitflags.
    char *errstr = ""CLIENT_ERROR bad command line format"";
    uint32_t hv; // cached hash value.
    int vlen = 0; // value from data line.
    assert(c != NULL);
    mc_resp *resp = c->resp;
    char *p = resp->wbuf;

    WANT_TOKENS_MIN(ntokens, 3);

    // TODO: most of this is identical to mget.
    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {
        out_errstring(c, ""CLIENT_ERROR bad command line format"");
        return;
    }

    if (ntokens == 3) {
        out_errstring(c, ""CLIENT_ERROR bad command line format"");
        return;
    }

    if (ntokens > MFLAG_MAX_OPT_LENGTH) {
        out_errstring(c, ""CLIENT_ERROR options flags too long"");
        return;
    }

    // We note tokens into the front of the write buffer, so we can create the
    // fin...",1354.0,1551.0,1.0,17.0,198.0,173,23,163,29,1,44,32,23,8,18,,0,31,6,3,3,void
781,59125,process_mdelete_command,1,process_mdelete_command,"void process_mdelete_command (conn*,token_t*,size_t)",proto_text.c,"static void process_mdelete_command(conn *c, token_t *tokens, const size_t ntokens) {
    char *key;
    size_t nkey;
    item *it = NULL;
    int i;
    uint32_t hv;
    struct _meta_flags of = {0}; // option bitflags.
    char *errstr = ""CLIENT_ERROR bad command line format"";
    assert(c != NULL);
    mc_resp *resp = c->resp;
    // reserve 3 bytes for status code
    char *p = resp->wbuf + 3;

    WANT_TOKENS_MIN(ntokens, 3);

    // TODO: most of this is identical to mget.
    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {
        out_string(c, ""CLIENT_ERROR bad command line format"");
        return;
    }

    if (ntokens > MFLAG_MAX_OPT_LENGTH) {
        out_string(c, ""CLIENT_ERROR options flags too long"");
        return;
    }

    // scrubs duplicated options and sets flags for how to load the item.
    // we pass in the first token that should be a flag.
    // FIXME: not using the preparse errstr?
    if (_meta_flag_preparse(tokens, 2, &of, &errstr) != 0) {
        out...",1553.0,1683.0,1.0,4.0,131.0,125,21,115,17,1,29,19,25,7,13,,0,19,6,3,3,void
782,59708,process_marithmetic_command,1,process_marithmetic_command,"void process_marithmetic_command (conn*,token_t*,size_t)",proto_text.c,"static void process_marithmetic_command(conn *c, token_t *tokens, const size_t ntokens) {
    char *key;
    size_t nkey;
    int i;
    struct _meta_flags of = {0}; // option bitflags.
    char *errstr = ""CLIENT_ERROR bad command line format"";
    assert(c != NULL);
    mc_resp *resp = c->resp;
    // no reservation (like del/set) since we post-process the status line.
    char *p = resp->wbuf;

    // If no argument supplied, incr or decr by one.
    of.delta = 1;
    of.initial = 0; // redundant, for clarity.
    bool incr = true; // default mode is to increment.
    bool locked = false;
    uint32_t hv = 0;
    item *it = NULL; // item returned by do_add_delta.

    WANT_TOKENS_MIN(ntokens, 3);

    // TODO: most of this is identical to mget.
    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {
        out_string(c, ""CLIENT_ERROR bad command line format"");
        return;
    }

    if (ntokens > MFLAG_MAX_OPT_LENGTH) {
        out_string(c, ""CLIENT_ERROR options flags too long""...",1685.0,1915.0,1.0,4.0,231.0,191,21,204,29,1,38,40,43,11,20,,0,24,6,3,3,void
783,60679,process_update_command,1,process_update_command,"void process_update_command (conn*,token_t*,size_t,int,bool)",proto_text.c,"static void process_update_command(conn *c, token_t *tokens, const size_t ntokens, int comm, bool handle_cas) {
    char *key;
    size_t nkey;
    unsigned int flags;
    int32_t exptime_int = 0;
    rel_time_t exptime = 0;
    int vlen;
    uint64_t req_cas_id=0;
    item *it;

    assert(c != NULL);

    set_noreply_maybe(c, tokens, ntokens);

    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {
        out_string(c, ""CLIENT_ERROR bad command line format"");
        return;
    }

    key = tokens[KEY_TOKEN].value;
    nkey = tokens[KEY_TOKEN].length;

    if (! (safe_strtoul(tokens[2].value, (uint32_t *)&flags)
           && safe_strtol(tokens[3].value, &exptime_int)
           && safe_strtol(tokens[4].value, (int32_t *)&vlen))) {
        out_string(c, ""CLIENT_ERROR bad command line format"");
        return;
    }

    exptime = realtime(EXPTIME_TO_POSITIVE_TIME(exptime_int));

    // does cas value exist?
    if (handle_cas) {
        if (!safe_strtoull(tokens[5].value, &req_cas...",1918.0,2018.0,1.0,15.0,101.0,108,22,104,27,0,33,11,16,6,20,,0,21,10,5,5,void
784,61102,process_touch_command,1,process_touch_command,"void process_touch_command (conn*,token_t*,size_t)",proto_text.c,"static void process_touch_command(conn *c, token_t *tokens, const size_t ntokens) {
    char *key;
    size_t nkey;
    int32_t exptime_int = 0;
    rel_time_t exptime = 0;
    item *it;

    assert(c != NULL);

    set_noreply_maybe(c, tokens, ntokens);

    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {
        out_string(c, ""CLIENT_ERROR bad command line format"");
        return;
    }

    key = tokens[KEY_TOKEN].value;
    nkey = tokens[KEY_TOKEN].length;

    if (!safe_strtol(tokens[2].value, &exptime_int)) {
        out_string(c, ""CLIENT_ERROR invalid exptime argument"");
        return;
    }

    exptime = realtime(EXPTIME_TO_POSITIVE_TIME(exptime_int));
    it = item_touch(key, nkey, exptime, c);
    if (it) {
        pthread_mutex_lock(&c->thread->stats.mutex);
        c->thread->stats.touch_cmds++;
        c->thread->stats.slab_stats[ITEM_clsid(it)].touch_hits++;
        pthread_mutex_unlock(&c->thread->stats.mutex);

        out_string(c, ""TOUCHED"");
        item_remov...",2020.0,2062.0,1.0,15.0,43.0,46,16,34,9,0,12,4,4,1,8,,0,7,6,3,3,void
785,61300,process_arithmetic_command,1,process_arithmetic_command,"void process_arithmetic_command (conn*,token_t*,size_t,bool)",proto_text.c,"static void process_arithmetic_command(conn *c, token_t *tokens, const size_t ntokens, const bool incr) {
    char temp[INCR_MAX_STORAGE_LEN];
    uint64_t delta;
    char *key;
    size_t nkey;

    assert(c != NULL);

    set_noreply_maybe(c, tokens, ntokens);

    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {
        out_string(c, ""CLIENT_ERROR bad command line format"");
        return;
    }

    key = tokens[KEY_TOKEN].value;
    nkey = tokens[KEY_TOKEN].length;

    if (!safe_strtoull(tokens[2].value, &delta)) {
        out_string(c, ""CLIENT_ERROR invalid numeric delta argument"");
        return;
    }

    switch(add_delta(c, key, nkey, incr, delta, temp, NULL)) {
    case OK:
        out_string(c, temp);
        break;
    case NON_NUMERIC:
        out_string(c, ""CLIENT_ERROR cannot increment or decrement non-numeric value"");
        break;
    case EOM:
        out_of_memory(c, ""SERVER_ERROR out of memory"");
        break;
    case DELTA_ITEM_NOT_FOUND:
        pthread_m...",2064.0,2111.0,1.0,14.0,48.0,26,9,35,14,0,12,10,6,2,9,,0,5,8,4,4,void
786,61446,process_delete_command,1,process_delete_command,"void process_delete_command (conn*,token_t*,size_t)",proto_text.c,"static void process_delete_command(conn *c, token_t *tokens, const size_t ntokens) {
    char *key;
    size_t nkey;
    item *it;
    uint32_t hv;

    assert(c != NULL);

    if (ntokens > 3) {
        bool hold_is_zero = strcmp(tokens[KEY_TOKEN+1].value, ""0"") == 0;
        bool sets_noreply = set_noreply_maybe(c, tokens, ntokens);
        bool valid = (ntokens == 4 && (hold_is_zero || sets_noreply))
            || (ntokens == 5 && hold_is_zero && sets_noreply);
        if (!valid) {
            out_string(c, ""CLIENT_ERROR bad command line format.  ""
                       ""Usage: delete <key> [noreply]"");
            return;
        }
    }


    key = tokens[KEY_TOKEN].value;
    nkey = tokens[KEY_TOKEN].length;

    if(nkey > KEY_MAX_LENGTH) {
        out_string(c, ""CLIENT_ERROR bad command line format"");
        return;
    }

    if (settings.detail_enabled) {
        stats_prefix_record_delete(key, nkey);
    }

    it = item_get_locked(key, nkey, c, DONT_UPDATE, &hv);
    i...",2114.0,2167.0,1.0,42.0,54.0,45,16,44,13,0,13,6,7,1,9,,0,6,6,3,3,void
787,61647,process_verbosity_command,1,process_verbosity_command,"void process_verbosity_command (conn*,token_t*,size_t)",proto_text.c,"static void process_verbosity_command(conn *c, token_t *tokens, const size_t ntokens) {
    unsigned int level;

    assert(c != NULL);

    set_noreply_maybe(c, tokens, ntokens);

    if (!safe_strtoul(tokens[1].value, (uint32_t*)&level)) {
        out_string(c, ""CLIENT_ERROR bad command line format"");
        return;
    }
    settings.verbose = level > MAX_VERBOSITY_LEVEL ? MAX_VERBOSITY_LEVEL : level;
    out_string(c, ""OK"");
    return;
}",2169.0,2183.0,1.0,31.0,15.0,10,9,12,6,0,5,2,2,1,4,,0,2,6,3,3,void
788,61698,process_slabs_automove_command,1,process_slabs_automove_command,"void process_slabs_automove_command (conn*,token_t*,size_t)",proto_text.c,"static void process_slabs_automove_command(conn *c, token_t *tokens, const size_t ntokens) {
    unsigned int level;
    double ratio;

    assert(c != NULL);

    set_noreply_maybe(c, tokens, ntokens);

    if (strcmp(tokens[2].value, ""ratio"") == 0) {
        if (ntokens < 5 || !safe_strtod(tokens[3].value, &ratio)) {
            out_string(c, ""ERROR"");
            return;
        }
        settings.slab_automove_ratio = ratio;
    } else {
        if (!safe_strtoul(tokens[2].value, (uint32_t*)&level)) {
            out_string(c, ""CLIENT_ERROR bad command line format"");
            return;
        }
        if (level == 0) {
            settings.slab_automove = 0;
        } else if (level == 1 || level == 2) {
            settings.slab_automove = level;
        } else {
            out_string(c, ""ERROR"");
            return;
        }
    }
    out_string(c, ""OK"");
    return;
}",2231.0,2261.0,1.0,1.0,31.0,12,9,13,6,0,5,3,4,1,4,,0,2,6,3,3,void
789,61805,process_watch_command,1,process_watch_command,"void process_watch_command (conn*,token_t*,size_t)",proto_text.c,"static void process_watch_command(conn *c, token_t *tokens, const size_t ntokens) {
    uint16_t f = 0;
    int x;
    assert(c != NULL);

    set_noreply_maybe(c, tokens, ntokens);
    if (!settings.watch_enabled) {
        out_string(c, ""CLIENT_ERROR watch commands not allowed"");
        return;
    }

    if (resp_has_stack(c)) {
        out_string(c, ""ERROR cannot pipeline other commands before watch"");
        return;
    }

    if (ntokens > 2) {
        for (x = COMMAND_TOKEN + 1; x < ntokens - 1; x++) {
            if ((strcmp(tokens[x].value, ""rawcmds"") == 0)) {
                f |= LOG_RAWCMDS;
            } else if ((strcmp(tokens[x].value, ""evictions"") == 0)) {
                f |= LOG_EVICTIONS;
            } else if ((strcmp(tokens[x].value, ""fetchers"") == 0)) {
                f |= LOG_FETCHERS;
            } else if ((strcmp(tokens[x].value, ""mutations"") == 0)) {
                f |= LOG_MUTATIONS;
            } else if ((strcmp(tokens[x].value, ""sysevents"") == 0)) {...",2264.0,2321.0,1.0,17.0,58.0,16,13,28,11,0,10,10,10,4,8,,0,4,6,3,3,void
790,62089,process_memlimit_command,1,process_memlimit_command,"void process_memlimit_command (conn*,token_t*,size_t)",proto_text.c,"static void process_memlimit_command(conn *c, token_t *tokens, const size_t ntokens) {
    uint32_t memlimit;
    assert(c != NULL);

    set_noreply_maybe(c, tokens, ntokens);

    if (!safe_strtoul(tokens[1].value, &memlimit)) {
        out_string(c, ""ERROR"");
    } else {
        if (memlimit < 8) {
            out_string(c, ""MEMLIMIT_TOO_SMALL cannot set maxbytes to less than 8m"");
        } else {
            if (memlimit > 1000000000) {
                out_string(c, ""MEMLIMIT_ADJUST_FAILED input value is megabytes not bytes"");
            } else if (slabs_adjust_mem_limit((size_t) memlimit * 1024 * 1024)) {
                if (settings.verbose > 0) {
                    fprintf(stderr, ""maxbytes adjusted to %llum\n"", (unsigned long long)memlimit);
                }

                out_string(c, ""OK"");
            } else {
                out_string(c, ""MEMLIMIT_ADJUST_FAILED out of bounds or unable to adjust"");
            }
        }
    }
}",2323.0,2348.0,1.0,1.0,26.0,5,5,8,5,0,3,2,2,1,3,,0,1,6,3,3,void
791,62172,process_lru_command,1,process_lru_command,"void process_lru_command (conn*,token_t*,size_t)",proto_text.c,"static void process_lru_command(conn *c, token_t *tokens, const size_t ntokens) {
    uint32_t pct_hot;
    uint32_t pct_warm;
    double hot_factor;
    int32_t ttl;
    double factor;

    set_noreply_maybe(c, tokens, ntokens);

    if (strcmp(tokens[1].value, ""tune"") == 0 && ntokens >= 7) {
        if (!safe_strtoul(tokens[2].value, &pct_hot) ||
            !safe_strtoul(tokens[3].value, &pct_warm) ||
            !safe_strtod(tokens[4].value, &hot_factor) ||
            !safe_strtod(tokens[5].value, &factor)) {
            out_string(c, ""ERROR"");
        } else {
            if (pct_hot + pct_warm > 80) {
                out_string(c, ""ERROR hot and warm pcts must not exceed 80"");
            } else if (factor <= 0 || hot_factor <= 0) {
                out_string(c, ""ERROR hot/warm age factors must be greater than 0"");
            } else {
                settings.hot_lru_pct = pct_hot;
                settings.warm_lru_pct = pct_warm;
                settings.hot_max_factor = ho...",2350.0,2405.0,1.0,1.0,56.0,24,8,14,7,0,6,3,4,4,6,,0,4,6,3,3,void
792,62431,process_flush_all_command,1,process_flush_all_command,"void process_flush_all_command (conn*,token_t*,size_t)",proto_text.c,"static void process_flush_all_command(conn *c, token_t *tokens, const size_t ntokens) {
    int32_t exptime = 0;
    rel_time_t new_oldest = 0;

    set_noreply_maybe(c, tokens, ntokens);

    pthread_mutex_lock(&c->thread->stats.mutex);
    c->thread->stats.flush_cmds++;
    pthread_mutex_unlock(&c->thread->stats.mutex);

    if (!settings.flush_enabled) {
        // flush_all is not allowed but we log it on stats
        out_string(c, ""CLIENT_ERROR flush_all not allowed"");
        return;
    }

    if (ntokens != (c->noreply ? 3 : 2)) {
        if (!safe_strtol(tokens[1].value, &exptime)) {
            out_string(c, ""CLIENT_ERROR invalid exptime argument"");
            return;
        }
    }

    /*
      If exptime is zero realtime() would return zero too, and
      realtime(exptime) - 1 would overflow to the max unsigned
      value.  So we process exptime == 0 the same way we do when
      no delay is given at all.
    */
    if (exptime > 0) {
        new_oldest = realtime(e...",2467.0,2510.0,1.0,1.0,44.0,33,12,25,7,0,16,7,9,5,7,,0,12,6,3,3,void
793,62565,process_quit_command,1,process_quit_command,void process_quit_command (conn*),proto_text.c,"static void process_quit_command(conn *c) {
    conn_set_state(c, conn_mwrite);
    c->close_after_write = true;
    c->close_reason = NORMAL_CLOSE;
}",2516.0,2520.0,1.0,1.0,5.0,4,2,6,4,0,3,1,1,0,1,,0,2,2,1,1,void
794,62583,process_shutdown_command,1,process_shutdown_command,"void process_shutdown_command (conn*,token_t*,size_t)",proto_text.c,"static void process_shutdown_command(conn *c, token_t *tokens, const size_t ntokens) {
    if (!settings.shutdown_command) {
        out_string(c, ""ERROR: shutdown not enabled"");
        return;
    }

    if (ntokens == 2) {
        c->close_reason = SHUTDOWN_CLOSE;
        conn_set_state(c, conn_closing);
        raise(SIGINT);
    } else if (ntokens == 3 && strcmp(tokens[SUBCOMMAND_TOKEN].value, ""graceful"") == 0) {
        c->close_reason = SHUTDOWN_CLOSE;
        conn_set_state(c, conn_closing);
        raise(SIGUSR1);
    } else {
        out_string(c, ""CLIENT_ERROR invalid shutdown mode"");
    }
}",2522.0,2539.0,1.0,45.0,18.0,5,5,8,6,0,4,3,3,1,2,,0,2,6,3,3,void
795,62649,process_slabs_command,1,process_slabs_command,"void process_slabs_command (conn*,token_t*,size_t)",proto_text.c,"static void process_slabs_command(conn *c, token_t *tokens, const size_t ntokens) {
    if (ntokens == 5 && strcmp(tokens[COMMAND_TOKEN + 1].value, ""reassign"") == 0) {
        int src, dst, rv;

        if (settings.slab_reassign == false) {
            out_string(c, ""CLIENT_ERROR slab reassignment disabled"");
            return;
        }

        if (! (safe_strtol(tokens[2].value, (int32_t*)&src)
               && safe_strtol(tokens[3].value, (int32_t*)&dst))) {
            out_string(c, ""CLIENT_ERROR bad command line format"");
            return;
        }

        rv = slabs_reassign(src, dst);
        switch (rv) {
        case REASSIGN_OK:
            out_string(c, ""OK"");
            break;
        case REASSIGN_RUNNING:
            out_string(c, ""BUSY currently processing reassign request"");
            break;
        case REASSIGN_BADCLASS:
            out_string(c, ""BADCLASS invalid src or dst class id"");
            break;
        case REASSIGN_NOSPARE:
            out_st...",2541.0,2581.0,1.0,38.0,41.0,19,9,24,13,0,11,10,8,3,10,,0,4,6,3,3,void
796,62786,process_lru_crawler_command,1,process_lru_crawler_command,"void process_lru_crawler_command (conn*,token_t*,size_t)",proto_text.c,"static void process_lru_crawler_command(conn *c, token_t *tokens, const size_t ntokens) {
    if (ntokens == 4 && strcmp(tokens[COMMAND_TOKEN + 1].value, ""crawl"") == 0) {
        int rv;
        if (settings.lru_crawler == false) {
            out_string(c, ""CLIENT_ERROR lru crawler disabled"");
            return;
        }

        rv = lru_crawler_crawl(tokens[2].value, CRAWLER_EXPIRED, NULL, 0,
                settings.lru_crawler_tocrawl);
        switch(rv) {
        case CRAWLER_OK:
            out_string(c, ""OK"");
            break;
        case CRAWLER_RUNNING:
            out_string(c, ""BUSY currently processing crawler request"");
            break;
        case CRAWLER_BADCLASS:
            out_string(c, ""BADCLASS invalid class id"");
            break;
        case CRAWLER_NOTSTARTED:
            out_string(c, ""NOTSTARTED no items to crawl"");
            break;
        case CRAWLER_ERROR:
            out_string(c, ""ERROR an unknown error happened"");
            break;
    ...",2583.0,2694.0,1.0,38.0,112.0,12,6,21,13,0,9,9,6,1,7,,0,3,6,3,3,void
797,63159,process_command_ascii,1,process_command_ascii,"void process_command_ascii (conn*,char*)",proto_text.c,"void process_command_ascii(conn *c, char *command) {

    token_t tokens[MAX_TOKENS];
    size_t ntokens;
    int comm;

    assert(c != NULL);

    MEMCACHED_PROCESS_COMMAND_START(c->sfd, c->rcurr, c->rbytes);

    if (settings.verbose > 1)
        fprintf(stderr, ""<%d %s\n"", c->sfd, command);

    /*
     * for commands set/add/replace, we build an item and read the data
     * directly into it, then continue in nread_complete().
     */

    // Prep the response object for this query.
    if (!resp_start(c)) {
        conn_set_state(c, conn_closing);
        return;
    }

    ntokens = tokenize_command(command, tokens, MAX_TOKENS);
    // All commands need a minimum of two tokens: cmd and NULL finalizer
    // There are also no valid commands shorter than two bytes.
    if (ntokens < 2 || tokens[COMMAND_TOKEN].length < 2) {
        out_string(c, ""ERROR"");
        return;
    }

    // Meta commands are all 2-char in length.
    char first = tokens[COMMAND_TOKEN].value[0];
    if...",2716.0,2928.0,1.0,19.0,213.0,23,11,39,10,1,14,13,7,2,12,,0,4,4,2,2,void
798,65274,proxy_init_evthread_events,1,proxy_init_evthread_events,void proxy_init_evthread_events (proxy_event_thread_t*),proxy_network.c,"void proxy_init_evthread_events(proxy_event_thread_t *t) {
#ifdef HAVE_LIBURING
    bool use_uring = t->ctx->use_uring;
    struct io_uring_params p = {0};
    assert(t->event_fd); // uring only exists where eventfd also does.

    // Setup the CQSIZE to be much larger than SQ size, since backpressure
    // issues can cause us to block on SQ submissions and as a network server,
    // stuff happens.

    if (use_uring) {
        p.flags = IORING_SETUP_CQSIZE;
        p.cq_entries = PRING_QUEUE_CQ_ENTRIES;
        int ret = io_uring_queue_init_params(PRING_QUEUE_SQ_ENTRIES, &t->ring, &p);
        if (ret) {
            perror(""io_uring_queue_init_params"");
            exit(1);
        }
        if (!(p.features & IORING_FEAT_NODROP)) {
            fprintf(stderr, ""uring: kernel missing IORING_FEAT_NODROP, using libevent\n"");
            use_uring = false;
        }
        if (!(p.features & IORING_FEAT_SINGLE_MMAP)) {
            fprintf(stderr, ""uring: kernel missing IORING_FEAT_S...",1020.0,1111.0,1.0,1.0,92.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
799,65309,mcplib_await_return,1,mcplib_await_return,int mcplib_await_return (io_pending_proxy_t*),proxy_await.c,"int mcplib_await_return(io_pending_proxy_t *p) {
    mcp_await_t *aw;
    lua_State *L = p->thread->L; // use the main VM coroutine for work
    bool cleanup = false;
    bool valid = false; // is response valid to add to the result table.
    bool completing = false;

    // TODO (v2): just push the await ptr into *p?
    lua_rawgeti(L, LUA_REGISTRYINDEX, p->await_ref);
    aw = lua_touserdata(L, -1);
    lua_pop(L, 1); // remove AW object from stack
    assert(aw != NULL);
    P_DEBUG(""%s: start [pending: %d]\n"", __func__, aw->pending);
    //dump_stack(L);

    aw->pending--;
    assert(aw->pending >= 0);
    // Await not yet satisfied.
    // If wait_for != 0 check for response success
    // if success and wait_for is *now* 0, we complete.
    // add successful response to response table
    // Also, if no wait_for, add response to response table
    // TODO (v2): for GOOD or OK cases, it might be better to return the
    // last object as valid if there are otherwise zero vali...",238.0,366.0,1.0,4.0,129.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,int
800,65412,mcplib_pool_proxy_call_helper,1,mcplib_pool_proxy_call_helper,"mcp_backend_t* mcplib_pool_proxy_call_helper (lua_State*,mcp_pool_t*,char*,size_t)",proxy_lua.c,"mcp_backend_t *mcplib_pool_proxy_call_helper(lua_State *L, mcp_pool_t *p, const char *key, size_t len) {
    if (p->key_filter) {
        key = p->key_filter(p->key_filter_conf, key, len, &len);
        P_DEBUG(""%s: filtered key for hashing (%.*s)\n"", __func__, (int)len, key);
    }
    uint64_t hash = p->key_hasher(key, len, p->hash_seed);
    uint32_t lookup = p->phc.selector_func(hash, p->phc.ctx);

    assert(p->phc.ctx != NULL);
    // attach the backend to the request object.
    // the lua modules should ""think"" in 1 based indexes, so we need to
    // subtract one here.
    if (lookup >= p->pool_size) {
        proxy_lua_error(L, ""key dist hasher tried to use out of bounds index"");
    }

    return p->pool[lookup].be;
}",474.0,491.0,1.0,8.0,18.0,0,0,0,0,1,0,1,1,0,0,,0,0,8,4,4,mcp_backend_t
801,65420,mcp_request_attach,1,mcp_request_attach,"void mcp_request_attach (lua_State*,mcp_request_t*,io_pending_proxy_t*)",proxy_request.c,"void mcp_request_attach(lua_State *L, mcp_request_t *rq, io_pending_proxy_t *p) {
    mcp_parser_t *pr = &rq->pr;
    char *r = (char *) pr->request;
    size_t len = pr->reqlen;

    // one or more of the tokens were changed
    if (rq->was_modified) {
        assert(rq->tokent_ref);
        // option table to top of stack.
        lua_rawgeti(L, LUA_REGISTRYINDEX, rq->tokent_ref);

        // space was reserved in case of modification.
        char *nr = rq->request + MCP_REQUEST_MAXLEN;
        r = nr;
        char *or = NULL;

        for (int x = 0; x < pr->ntokens; x++) {
            const char *newtok = NULL;
            size_t newlen = 0;
            if (x != 0 && x != pr->keytoken) {
                int type = lua_rawgeti(L, -1, x+1);
                if (type != LUA_TNIL) {
                    newtok = lua_tolstring(L, -1, &newlen);
                    memcpy(nr, newtok, newlen);
                    nr += newlen;
                }
                lua_pop(L, 1);
            ...",467.0,533.0,1.0,33.0,67.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,void
802,65439,_start_proxy_config_threads,1,_start_proxy_config_threads,int _start_proxy_config_threads (proxy_ctx_t*),proxy_config.c,"int _start_proxy_config_threads(proxy_ctx_t *ctx) {
    int ret;

    pthread_mutex_lock(&ctx->config_lock);
    if ((ret = pthread_create(&ctx->config_tid, NULL,
                    _proxy_config_thread, ctx)) != 0) {
        fprintf(stderr, ""Failed to start proxy configuration thread: %s\n"",
                strerror(ret));
        pthread_mutex_unlock(&ctx->config_lock);
        return -1;
    }
    pthread_mutex_unlock(&ctx->config_lock);

    pthread_mutex_lock(&ctx->manager_lock);
    if ((ret = pthread_create(&ctx->manager_tid, NULL,
                    _proxy_manager_thread, ctx)) != 0) {
        fprintf(stderr, ""Failed to start proxy configuration thread: %s\n"",
                strerror(ret));
        pthread_mutex_unlock(&ctx->manager_lock);
        return -1;
    }
    pthread_mutex_unlock(&ctx->manager_lock);

    return 0;
}",159.0,183.0,1.0,1.0,25.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,int
803,65444,proxy_thread_loadconf,1,proxy_thread_loadconf,int proxy_thread_loadconf (LIBEVENT_THREAD*),proxy_config.c,"int proxy_thread_loadconf(LIBEVENT_THREAD *thr) {
    lua_State *L = thr->L;
    // load the precompiled config function.
    proxy_ctx_t *ctx = settings.proxy_ctx;
    struct _dumpbuf *db = ctx->proxy_code;
    struct _dumpbuf db2; // copy because the helper modifies it.
    memcpy(&db2, db, sizeof(struct _dumpbuf));

    lua_load(L, _load_helper, &db2, ""config"", NULL);
    // LUA_OK + all errs from loadfile except LUA_ERRFILE.
    //dump_stack(L);
    // - pcall the func (which should load it)
    int res = lua_pcall(L, 0, LUA_MULTRET, 0);
    if (res != LUA_OK) {
        // FIXME (v2): don't exit here!
        fprintf(stderr, ""Failed to load data into worker thread\n"");
        return -1;
    }

    lua_getglobal(L, ""mcp_config_routes"");
    // create deepcopy of argument to pass into mcp_config_routes.
    // FIXME (v2): to avoid lua SIGABRT'ing on errors we need to protect the call
    // normal pattern:
    // lua_pushcfunction(L, &_copy_config_table);
    // lua_pushlightuser...",346.0,422.0,1.0,4.0,77.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,int
804,65651,mcp_queue_await_io,1,mcp_queue_await_io,"void mcp_queue_await_io (conn*,lua_State*,mcp_request_t*,int,bool)",proxy_await.c,"static void mcp_queue_await_io(conn *c, lua_State *Lc, mcp_request_t *rq, int await_ref, bool await_first) {
    io_queue_t *q = conn_io_queue_get(c, IO_QUEUE_PROXY);

    mcp_backend_t *be = rq->be;

    // Then we push a response object, which we'll re-use later.
    // reserve one uservalue for a lua-supplied response.
    mcp_resp_t *r = lua_newuserdatauv(Lc, sizeof(mcp_resp_t), 1);
    memset(r, 0, sizeof(mcp_resp_t));
    // Set noreply mode.
    // TODO (v2): the response ""inherits"" the request's noreply mode, which isn't
    // strictly correct; we should inherit based on the request that spawned
    // the coroutine but the structure doesn't allow that yet.
    // Should also be able to settle this exact mode from the parser so we
    // don't have to re-branch here.
    if (rq->pr.noreply) {
        if (rq->pr.cmd_type == CMD_TYPE_META) {
            r->mode = RESP_MODE_METAQUIET;
            for (int x = 2; x < rq->pr.ntokens; x++) {
                if (rq->request[rq->pr...",93.0,176.0,1.0,41.0,84.0,95,12,78,19,0,13,6,12,0,4,,0,11,10,5,5,void
805,66474,_dump_helper,1,_dump_helper,"int _dump_helper (lua_State*,void*,size_t,void*)",proxy_config.c,"static int _dump_helper(lua_State *L, const void *p, size_t sz, void *ud) {
    (void)L;
    struct _dumpbuf *db = ud;
    if (db->used + sz > db->size) {
        db->size *= 2;
        char *nb = realloc(db->buf, db->size);
        if (nb == NULL) {
            return -1;
        }
        db->buf = nb;
    }
    memcpy(db->buf + db->used, (const char *)p, sz);
    db->used += sz;
    return 0;
}",13.0,27.0,1.0,1.0,15.0,21,9,20,7,0,9,3,4,2,0,,0,9,8,4,4,int
806,66547,_load_helper,1,_load_helper,"const char* _load_helper (lua_State*,void*,size_t*)",proxy_config.c,"static const char * _load_helper(lua_State *L, void *data, size_t *size) {
    (void)L;
    struct _dumpbuf *db = data;
    if (db->used == 0) {
        *size = 0;
        return NULL;
    }
    *size = db->used;
    db->used = 0;
    return db->buf;
}",29.0,39.0,1.0,1.0,11.0,12,5,10,5,0,4,2,2,1,0,,0,4,6,3,3,const char*
807,66617,_proxy_manager_thread,1,_proxy_manager_thread,void* _proxy_manager_thread (void*),proxy_config.c,"static void *_proxy_manager_thread(void *arg) {
    proxy_ctx_t *ctx = arg;
    pool_head_t head;

    pthread_mutex_lock(&ctx->manager_lock);
    while (1) {
        STAILQ_INIT(&head);
        while (STAILQ_EMPTY(&ctx->manager_head)) {
            pthread_cond_wait(&ctx->manager_cond, &ctx->manager_lock);
        }

        // pull dealloc queue into local queue.
        STAILQ_CONCAT(&head, &ctx->manager_head);
        pthread_mutex_unlock(&ctx->manager_lock);

        // Config lock is required for using config VM.
        pthread_mutex_lock(&ctx->config_lock);
        lua_State *L = ctx->proxy_state;
        mcp_pool_t *p;
        STAILQ_FOREACH(p, &head, next) {
            // we let the pool object _gc() handle backend references.

            luaL_unref(L, LUA_REGISTRYINDEX, p->phc_ref);
            // need to... unref self.
            // NOTE: double check if we really need to self-reference.
            // this is a backup here to ensure the external refcounts hit zero
  ...",50.0,87.0,1.0,8.0,38.0,75,7,45,7,0,17,3,4,2,0,,0,17,2,1,1,void*
808,66816,_proxy_config_thread,1,_proxy_config_thread,void* _proxy_config_thread (void*),proxy_config.c,"static void *_proxy_config_thread(void *arg) {
    proxy_ctx_t *ctx = arg;

    logger_create();
    pthread_mutex_lock(&ctx->config_lock);
    while (1) {
        pthread_cond_wait(&ctx->config_cond, &ctx->config_lock);
        LOGGER_LOG(NULL, LOG_PROXYEVENTS, LOGGER_PROXY_CONFIG, NULL, ""start"");
        STAT_INCR(ctx, config_reloads, 1);
        lua_State *L = ctx->proxy_state;
        lua_settop(L, 0); // clear off any crud that could have been left on the stack.

        // The main stages of config reload are:
        // - load and execute the config file
        // - run mcp_config_pools()
        // - for each worker:
        //   - copy and execute new lua code
        //   - copy selector table
        //   - run mcp_config_routes()

        if (proxy_load_config(ctx) != 0) {
            // Failed to load. log and wait for a retry.
            STAT_INCR(ctx, config_reload_fails, 1);
            LOGGER_LOG(NULL, LOG_PROXYEVENTS, LOGGER_PROXY_CONFIG, NULL, ""failed"");
       ...",100.0,157.0,1.0,8.0,58.0,78,12,86,14,0,29,8,12,4,7,,0,24,2,1,1,void*
809,67345,_copy_pool,1,_copy_pool,"int _copy_pool (lua_State*,lua_State*)",proxy_config.c,"static int _copy_pool(lua_State *from, lua_State *to) {
    // from, -3 should have he userdata.
    mcp_pool_t *p = luaL_checkudata(from, -3, ""mcp.pool"");
    size_t size = sizeof(mcp_pool_proxy_t);
    mcp_pool_proxy_t *pp = lua_newuserdatauv(to, size, 0);
    luaL_setmetatable(to, ""mcp.pool_proxy"");

    pp->main = p;
    pthread_mutex_lock(&p->lock);
    p->refcount++;
    pthread_mutex_unlock(&p->lock);
    return 0;
}",229.0,241.0,1.0,1.0,13.0,13,6,13,6,0,1,1,1,0,0,,0,1,4,2,2,int
810,67882,mcplib_dist_jump_hash_get_server,1,mcplib_dist_jump_hash_get_server,"uint32_t mcplib_dist_jump_hash_get_server (uint64_t,void*)",proxy_jump_hash.c,"static uint32_t mcplib_dist_jump_hash_get_server(uint64_t hash, void *ctx) {
    mcplib_jump_hash_t *jh = ctx;

    int64_t b = -1, j = 0;
    while (j < jh->buckets) {
        b = j;
        hash = hash * 2862933555777941757ULL + 1;
        j = (b + 1) * ((double)(1LL << 31) / (double)((hash >> 33) + 1));
    }
    return b;
}",10.0,20.0,1.0,1.0,11.0,19,10,14,5,0,1,2,2,1,0,,0,1,4,2,2,uint32_t
811,67939,mcplib_dist_jump_hash_new,1,mcplib_dist_jump_hash_new,int mcplib_dist_jump_hash_new (lua_State*),proxy_jump_hash.c,"static int mcplib_dist_jump_hash_new(lua_State *L) {
    luaL_checktype(L, 1, LUA_TTABLE);
    lua_Unsigned buckets = lua_rawlen(L, 1);

    mcplib_jump_hash_t *jh = lua_newuserdatauv(L, sizeof(mcplib_jump_hash_t), 0);

    // don't need to loop through the table at all, just need its length.
    // could optimize startup time by adding hints to the module for how to
    // format pool (ie; just a total count or the full table)
    jh->buckets = buckets;
    jh->phc.ctx = jh;
    jh->phc.selector_func = mcplib_dist_jump_hash_get_server;

    lua_pushlightuserdata(L, &jh->phc);

    // - return [UD, lightuserdata]
    return 2;
}",23.0,40.0,1.0,1.0,18.0,13,5,14,5,0,5,1,1,0,0,,0,5,2,1,1,int
812,68016,mcplib_response_ok,1,mcplib_response_ok,int mcplib_response_ok (lua_State*),proxy_lua.c,"static int mcplib_response_ok(lua_State *L) {
    mcp_resp_t *r = luaL_checkudata(L, -1, ""mcp.response"");

    if (r->status == MCMC_OK) {
        lua_pushboolean(L, 1);
    } else {
        lua_pushboolean(L, 0);
    }

    return 1;
}",11.0,21.0,1.0,21.0,11.0,4,4,4,2,0,1,2,2,1,0,,0,1,2,1,1,int
813,68048,mcplib_response_hit,1,mcplib_response_hit,int mcplib_response_hit (lua_State*),proxy_lua.c,"static int mcplib_response_hit(lua_State *L) {
    mcp_resp_t *r = luaL_checkudata(L, -1, ""mcp.response"");

    if (r->status == MCMC_OK && r->resp.code != MCMC_CODE_MISS) {
        lua_pushboolean(L, 1);
    } else {
        lua_pushboolean(L, 0);
    }

    return 1;
}",23.0,33.0,1.0,21.0,11.0,8,7,5,2,0,2,2,2,2,0,,0,2,2,1,1,int
814,68090,mcplib_response_vlen,1,mcplib_response_vlen,int mcplib_response_vlen (lua_State*),proxy_lua.c,"static int mcplib_response_vlen(lua_State *L) {
    mcp_resp_t *r = luaL_checkudata(L, -1, ""mcp.response"");

    // We do remove the ""\r\n"" from the value length, so if you're actually
    // processing the value nothing breaks.
    if (r->resp.vlen >= 2) {
        lua_pushinteger(L, r->resp.vlen-2);
    } else {
        lua_pushinteger(L, 0);
    }

    return 1;
}",38.0,50.0,1.0,1.0,13.0,8,6,5,2,0,2,2,2,1,0,,0,2,2,1,1,int
815,68128,mcplib_response_code,1,mcplib_response_code,int mcplib_response_code (lua_State*),proxy_lua.c,"static int mcplib_response_code(lua_State *L) {
    mcp_resp_t *r = luaL_checkudata(L, -1, ""mcp.response"");

    lua_pushinteger(L, r->resp.code);

    return 1;
}",53.0,59.0,1.0,1.0,7.0,4,4,4,2,0,1,1,1,0,0,,0,1,2,1,1,int
816,68150,mcplib_response_line,1,mcplib_response_line,int mcplib_response_line (lua_State*),proxy_lua.c,"static int mcplib_response_line(lua_State *L) {
    mcp_resp_t *r = luaL_checkudata(L, -1, ""mcp.response"");

    if (r->resp.rline != NULL) {
        lua_pushlstring(L, r->resp.rline, r->resp.rlen);
    } else {
        lua_pushnil(L);
    }

    return 1;
}",62.0,72.0,1.0,1.0,11.0,9,5,7,3,0,3,2,2,1,0,,0,3,2,1,1,int
817,68190,mcplib_response_gc,1,mcplib_response_gc,int mcplib_response_gc (lua_State*),proxy_lua.c,"static int mcplib_response_gc(lua_State *L) {
    mcp_resp_t *r = luaL_checkudata(L, -1, ""mcp.response"");

    // On error/similar we might be holding the read buffer.
    // If the buf is handed off to mc_resp for return, this pointer is NULL
    if (r->buf != NULL) {
        free(r->buf);
    }

    return 0;
}",74.0,84.0,1.0,1.0,11.0,5,4,5,3,0,2,2,2,1,0,,0,2,2,1,1,int
818,68216,mcplib_backend_gc,1,mcplib_backend_gc,int mcplib_backend_gc (lua_State*),proxy_lua.c,"static int mcplib_backend_gc(lua_State *L) {
    mcp_backend_t *be = luaL_checkudata(L, -1, ""mcp.backend"");

    assert(STAILQ_EMPTY(&be->io_head));

    mcmc_disconnect(be->client);
    free(be->client);

    // FIXME (v2): upvalue for global ctx.
    proxy_ctx_t *ctx = settings.proxy_ctx;
    STAT_DECR(ctx, backend_total, 1);

    return 0;
}",93.0,106.0,1.0,11.0,14.0,19,7,13,5,0,5,1,1,0,1,,0,4,2,1,1,int
819,68281,mcplib_backend,1,mcplib_backend,int mcplib_backend (lua_State*),proxy_lua.c,"static int mcplib_backend(lua_State *L) {
    luaL_checkstring(L, -3); // label for indexing backends.
    size_t nlen = 0;
    const char *name = luaL_checklstring(L, -2, &nlen);
    const char *port = luaL_checkstring(L, -1);
    // FIXME (v2): upvalue for global ctx.
    proxy_ctx_t *ctx = settings.proxy_ctx;

    if (nlen > MAX_NAMELEN-1) {
        proxy_lua_error(L, ""backend name too long"");
        return 0;
    }

    // first check our reference table to compare.
    lua_pushvalue(L, 1);
    int ret = lua_gettable(L, lua_upvalueindex(MCP_BACKEND_UPVALUE));
    if (ret != LUA_TNIL) {
        mcp_backend_t *be_orig = luaL_checkudata(L, -1, ""mcp.backend"");
        if (strncmp(be_orig->name, name, MAX_NAMELEN) == 0
                && strncmp(be_orig->port, port, MAX_PORTLEN) == 0) {
            // backend is the same, return it.
            return 1;
        } else {
            // backend not the same, pop from stack and make new one.
            lua_pop(L, 1);
        }
    } ...",108.0,214.0,1.0,15.0,107.0,93,13,86,16,0,13,8,9,1,6,,0,9,2,1,1,int
820,68861,_mcplib_pool_dist,1,_mcplib_pool_dist,"void _mcplib_pool_dist (lua_State*,mcp_pool_t*)",proxy_lua.c,"static void _mcplib_pool_dist(lua_State *L, mcp_pool_t *p) {
    luaL_checktype(L, -1, LUA_TTABLE);
    if (lua_getfield(L, -1, ""new"") != LUA_TFUNCTION) {
        proxy_lua_error(L, ""key distribution object missing 'new' function"");
        return;
    }

    // - now create the copy pool table
    lua_createtable(L, p->pool_size, 0); // give the new pool table a sizing hint.
    for (int x = 1; x <= p->pool_size; x++) {
        mcp_backend_t *be = p->pool[x-1].be;
        lua_createtable(L, 0, 4);
        // stack = [p, h, f, optN, newpool, backend]
        // the key should be fine for id? maybe don't need to duplicate
        // this?
        lua_pushinteger(L, x);
        lua_setfield(L, -2, ""id"");
        // we don't use the hostname for ketama hashing
        // so passing ip for hostname is fine
        lua_pushstring(L, be->name);
        lua_setfield(L, -2, ""addr"");
        lua_pushstring(L, be->port);
        lua_setfield(L, -2, ""port"");

        // set the backend table i...",282.0,336.0,1.0,1.0,55.0,30,11,44,12,2,1,4,4,0,1,,0,0,4,2,2,void
821,69009,mcplib_pool,1,mcplib_pool,int mcplib_pool (lua_State*),proxy_lua.c,"static int mcplib_pool(lua_State *L) {
    int argc = lua_gettop(L);
    luaL_checktype(L, 1, LUA_TTABLE);
    int n = luaL_len(L, 1); // get length of array table

    size_t plen = sizeof(mcp_pool_t) + sizeof(mcp_pool_be_t) * n;
    mcp_pool_t *p = lua_newuserdatauv(L, plen, 0);
    // Zero the memory before use, so we can realibly use __gc to clean up
    memset(p, 0, plen);
    p->pool_size = n;
    // TODO (v2): Nicer if this is fetched from mcp.default_key_hash
    p->key_hasher = XXH3_64bits_withSeed;
    pthread_mutex_init(&p->lock, NULL);
    p->ctx = settings.proxy_ctx; // TODO (v2): store ctx in upvalue.

    luaL_setmetatable(L, ""mcp.pool"");

    lua_pushvalue(L, -1); // dupe self for reference.
    p->self_ref = luaL_ref(L, LUA_REGISTRYINDEX);

    // remember lua arrays are 1 indexed.
    for (int x = 1; x <= n; x++) {
        mcp_pool_be_t *s = &p->pool[x-1];
        lua_geti(L, 1, x); // get next server into the stack.
        // If we bail here, the pool _gc() shoul...",339.0,455.0,1.0,20.0,117.0,76,16,107,24,0,8,12,17,0,4,,0,4,2,1,1,int
822,69408,mcplib_pool_proxy_gc,1,mcplib_pool_proxy_gc,int mcplib_pool_proxy_gc (lua_State*),proxy_lua.c,"static int mcplib_pool_proxy_gc(lua_State *L) {
    mcp_pool_proxy_t *pp = luaL_checkudata(L, -1, ""mcp.pool_proxy"");
    mcp_pool_t *p = pp->main;
    pthread_mutex_lock(&p->lock);
    p->refcount--;
    if (p->refcount == 0) {
        proxy_ctx_t *ctx = p->ctx;
        pthread_mutex_lock(&ctx->manager_lock);
        STAILQ_INSERT_TAIL(&ctx->manager_head, p, next);
        pthread_cond_signal(&ctx->manager_cond);
        pthread_mutex_unlock(&ctx->manager_lock);
    }
    pthread_mutex_unlock(&p->lock);

    return 0;
}",457.0,472.0,1.0,8.0,16.0,37,8,21,5,0,7,2,2,0,0,,0,7,2,1,1,int
823,69589,mcplib_pool_proxy_call,1,mcplib_pool_proxy_call,int mcplib_pool_proxy_call (lua_State*),proxy_lua.c,"static int mcplib_pool_proxy_call(lua_State *L) {
    // internal args are the hash selector (self)
    mcp_pool_proxy_t *pp = luaL_checkudata(L, -2, ""mcp.pool_proxy"");
    mcp_pool_t *p = pp->main;
    // then request object.
    mcp_request_t *rq = luaL_checkudata(L, -1, ""mcp.request"");

    // we have a fast path to the key/length.
    if (!rq->pr.keytoken) {
        proxy_lua_error(L, ""cannot route commands without key"");
        return 0;
    }
    const char *key = MCP_PARSER_KEY(rq->pr);
    size_t len = rq->pr.klen;
    rq->be = mcplib_pool_proxy_call_helper(L, p, key, len);

    // now yield request, pool up.
    return lua_yield(L, 2);
}",495.0,513.0,1.0,22.0,19.0,25,7,21,6,0,3,2,2,0,2,,0,2,2,1,1,int
824,69676,mcplib_tcp_keepalive,1,mcplib_tcp_keepalive,int mcplib_tcp_keepalive (lua_State*),proxy_lua.c,"static int mcplib_tcp_keepalive(lua_State *L) {
    luaL_checktype(L, -1, LUA_TBOOLEAN);
    int state = lua_toboolean(L, -1);
    proxy_ctx_t *ctx = settings.proxy_ctx; // FIXME (v2): get global ctx reference in thread/upvalue.

    STAT_L(ctx);
    ctx->tunables.tcp_keepalive = state;
    STAT_UL(ctx);

    return 0;
}",515.0,525.0,1.0,4.0,11.0,12,5,12,5,0,4,1,1,0,0,,0,4,2,1,1,int
825,69724,mcplib_backend_failure_limit,1,mcplib_backend_failure_limit,int mcplib_backend_failure_limit (lua_State*),proxy_lua.c,"static int mcplib_backend_failure_limit(lua_State *L) {
    int limit = luaL_checkinteger(L, -1);
    proxy_ctx_t *ctx = settings.proxy_ctx; // FIXME (v2): get global ctx reference in thread/upvalue.

    if (limit < 0) {
        proxy_lua_error(L, ""backend_failure_limit must be >= 0"");
        return 0;
    }

    STAT_L(ctx);
    ctx->tunables.backend_failure_limit = limit;
    STAT_UL(ctx);

    return 0;
}",527.0,541.0,1.0,4.0,15.0,12,6,12,4,0,5,2,2,0,1,,0,4,2,1,1,int
826,69777,mcplib_backend_connect_timeout,1,mcplib_backend_connect_timeout,int mcplib_backend_connect_timeout (lua_State*),proxy_lua.c,"static int mcplib_backend_connect_timeout(lua_State *L) {
    lua_Number secondsf = luaL_checknumber(L, -1);
    lua_Integer secondsi = (lua_Integer) secondsf;
    lua_Number subseconds = secondsf - secondsi;
    proxy_ctx_t *ctx = settings.proxy_ctx; // FIXME (v2): get global ctx reference in thread/upvalue.

    STAT_L(ctx);
    ctx->tunables.connect.tv_sec = secondsi;
    ctx->tunables.connect.tv_usec = MICROSECONDS(subseconds);
#ifdef HAVE_LIBURING
    ctx->tunables.connect_ur.tv_sec = secondsi;
    ctx->tunables.connect_ur.tv_nsec = NANOSECONDS(subseconds);
#endif
    STAT_UL(ctx);

    return 0;
}",547.0,563.0,1.0,4.0,17.0,22,9,18,6,0,5,1,1,0,0,,0,5,2,1,1,int
827,69850,mcplib_backend_retry_timeout,1,mcplib_backend_retry_timeout,int mcplib_backend_retry_timeout (lua_State*),proxy_lua.c,"static int mcplib_backend_retry_timeout(lua_State *L) {
    lua_Number secondsf = luaL_checknumber(L, -1);
    lua_Integer secondsi = (lua_Integer) secondsf;
    lua_Number subseconds = secondsf - secondsi;
    proxy_ctx_t *ctx = settings.proxy_ctx; // FIXME (v2): get global ctx reference in thread/upvalue.

    STAT_L(ctx);
    ctx->tunables.retry.tv_sec = secondsi;
    ctx->tunables.retry.tv_usec = MICROSECONDS(subseconds);
#ifdef HAVE_LIBURING
    ctx->tunables.retry_ur.tv_sec = secondsi;
    ctx->tunables.retry_ur.tv_nsec = NANOSECONDS(subseconds);
#endif
    STAT_UL(ctx);

    return 0;
}",565.0,581.0,1.0,4.0,17.0,22,9,18,6,0,5,1,1,0,0,,0,5,2,1,1,int
828,69923,mcplib_backend_read_timeout,1,mcplib_backend_read_timeout,int mcplib_backend_read_timeout (lua_State*),proxy_lua.c,"static int mcplib_backend_read_timeout(lua_State *L) {
    lua_Number secondsf = luaL_checknumber(L, -1);
    lua_Integer secondsi = (lua_Integer) secondsf;
    lua_Number subseconds = secondsf - secondsi;
    proxy_ctx_t *ctx = settings.proxy_ctx; // FIXME (v2): get global ctx reference in thread/upvalue.

    STAT_L(ctx);
    ctx->tunables.read.tv_sec = secondsi;
    ctx->tunables.read.tv_usec = MICROSECONDS(subseconds);
#ifdef HAVE_LIBURING
    ctx->tunables.read_ur.tv_sec = secondsi;
    ctx->tunables.read_ur.tv_nsec = NANOSECONDS(subseconds);
#endif
    STAT_UL(ctx);

    return 0;
}",583.0,599.0,1.0,4.0,17.0,22,9,18,6,0,5,1,1,0,0,,0,5,2,1,1,int
829,69996,mcplib_attach,1,mcplib_attach,int mcplib_attach (lua_State*),proxy_lua.c,"static int mcplib_attach(lua_State *L) {
    // Pull the original worker thread out of the shared mcplib upvalue.
    LIBEVENT_THREAD *t = lua_touserdata(L, lua_upvalueindex(MCP_THREAD_UPVALUE));

    int hook = luaL_checkinteger(L, 1);
    // pushvalue to dupe func and etc.
    // can leave original func on stack afterward because it'll get cleared.
    int loop_end = 0;
    int loop_start = 1;
    if (hook == CMD_ANY) {
        // if CMD_ANY we need individually set loop 1 to CMD_SIZE.
        loop_end = CMD_SIZE;
    } else if (hook == CMD_ANY_STORAGE) {
        // if CMD_ANY_STORAGE we only override get/set/etc.
        loop_end = CMD_END_STORAGE;
    } else {
        loop_start = hook;
        loop_end = hook + 1;
    }

    if (lua_isfunction(L, 2)) {
        struct proxy_hook *hooks = t->proxy_hooks;
        uint64_t tag = 0; // listener socket tag

        if (lua_isstring(L, 3)) {
            size_t len;
            const char *stag = lua_tolstring(L, 3, &len);
            ...",603.0,710.0,1.0,60.0,108.0,65,15,79,20,0,20,15,46,4,3,,0,17,2,1,1,int
830,70341,mcplib_log,1,mcplib_log,int mcplib_log (lua_State*),proxy_lua.c,"static int mcplib_log(lua_State *L) {
    LIBEVENT_THREAD *t = lua_touserdata(L, lua_upvalueindex(MCP_THREAD_UPVALUE));
    const char *msg = luaL_checkstring(L, -1);
    LOGGER_LOG(t->l, LOG_PROXYUSER, LOGGER_PROXY_USER, NULL, msg);
    return 0;
}",714.0,719.0,1.0,60.0,6.0,13,7,17,8,0,4,1,1,0,1,,0,3,2,1,1,int
831,70407,mcplib_log_req,1,mcplib_log_req,int mcplib_log_req (lua_State*),proxy_lua.c,"static int mcplib_log_req(lua_State *L) {
    LIBEVENT_THREAD *t = lua_touserdata(L, lua_upvalueindex(MCP_THREAD_UPVALUE));
    logger *l = t->l;
    // Not using the LOGGER_LOG macro so we can avoid as much overhead as
    // possible when logging is disabled.
    if (! (l->eflags & LOG_PROXYREQS)) {
        return 0;
    }
    int rtype = 0;
    int rcode = 0;
    int rstatus = 0;
    char *rname = NULL;
    char *rport = NULL;

    mcp_request_t *rq = luaL_checkudata(L, 1, ""mcp.request"");
    int type = lua_type(L, 2);
    if (type == LUA_TUSERDATA) {
        mcp_resp_t *rs = luaL_checkudata(L, 2, ""mcp.response"");
        rtype = rs->resp.type;
        rcode = rs->resp.code;
        rstatus = rs->status;
        rname = rs->be_name;
        rport = rs->be_port;
    }
    size_t dlen = 0;
    const char *detail = luaL_optlstring(L, 3, NULL, &dlen);

    struct timeval end;
    gettimeofday(&end, NULL);
    long elapsed = (end.tv_sec - rq->start.tv_sec) * 1000000 + (end.tv_usec - r...",722.0,756.0,1.0,60.0,35.0,47,11,55,18,0,7,3,3,0,1,,0,6,2,1,1,int
832,70581,_rotl,1,_rotl,"uint32_t _rotl (uint32_t,int)",proxy_lua.c,"static inline uint32_t _rotl(const uint32_t x, int k) {
    return (x << k) | (x >> (32 - k));
}",758.0,760.0,1.0,1.0,3.0,4,4,4,2,2,0,1,1,0,0,,0,0,4,2,2,uint32_t
833,70597,_nextrand,1,_nextrand,uint32_t _nextrand (uint32_t*),proxy_lua.c,"static uint32_t _nextrand(uint32_t *s) {
    const uint32_t result = _rotl(s[0] + s[3], 7) + s[0];

    const uint32_t t = s[1] << 9;

    s[2] ^= s[0];
    s[3] ^= s[1];
    s[1] ^= s[2];
    s[0] ^= s[3];

    s[2] ^= t;

    s[3] = _rotl(s[3], 11);

    return result;
}",763.0,778.0,1.0,1.0,16.0,21,4,19,3,0,2,1,1,0,2,,0,2,2,1,1,uint32_t
834,70670,mcplib_log_reqsample,1,mcplib_log_reqsample,int mcplib_log_reqsample (lua_State*),proxy_lua.c,"static int mcplib_log_reqsample(lua_State *L) {
    LIBEVENT_THREAD *t = lua_touserdata(L, lua_upvalueindex(MCP_THREAD_UPVALUE));
    logger *l = t->l;
    // Not using the LOGGER_LOG macro so we can avoid as much overhead as
    // possible when logging is disabled.
    if (! (l->eflags & LOG_PROXYREQS)) {
        return 0;
    }
    int rtype = 0;
    int rcode = 0;
    int rstatus = 0;
    char *rname = NULL;
    char *rport = NULL;

    int ms = luaL_checkinteger(L, 1);
    int rate = luaL_checkinteger(L, 2);
    int allerr = lua_toboolean(L, 3);
    mcp_request_t *rq = luaL_checkudata(L, 4, ""mcp.request"");
    int type = lua_type(L, 5);
    if (type == LUA_TUSERDATA) {
        mcp_resp_t *rs = luaL_checkudata(L, 5, ""mcp.response"");
        rtype = rs->resp.type;
        rcode = rs->resp.code;
        rstatus = rs->status;
        rname = rs->be_name;
        rport = rs->be_port;
    }
    size_t dlen = 0;
    const char *detail = luaL_optlstring(L, 6, NULL, &dlen);

    struct ...",782.0,835.0,1.0,60.0,54.0,54,13,68,24,0,7,5,5,0,1,,0,6,2,1,1,int
835,71735,_set_event,1,_set_event,"void _set_event (mcp_backend_t*,event_base*,int,timeval,event_callback_fn)",proxy_network.c,"static void _set_event(mcp_backend_t *be, struct event_base *base, int flags, struct timeval t, event_callback_fn callback) {
    // FIXME (v2): chicken and egg.
    // can't check if pending if the structure is was calloc'ed (sigh)
    // don't want to double test here. should be able to event_assign but
    // not add anything during initialization, but need the owner thread's
    // event base.
    int pending = 0;
    if (event_initialized(&be->event)) {
        pending = event_pending(&be->event, EV_READ|EV_WRITE|EV_TIMEOUT, NULL);
    }
    if ((pending & (EV_READ|EV_WRITE|EV_TIMEOUT)) != 0) {
            event_del(&be->event); // replace existing event.
    }

    // if we can't write, we could be connecting.
    // TODO (v2): always check for READ in case some commands were sent
    // successfully? The flags could be tracked on *be and reset in the
    // handler, perhaps?
    event_assign(&be->event, base, mcmc_fd(be->client),
            flags, callback, be);
    event_ad...",473.0,494.0,1.0,1.0,22.0,0,0,0,0,2,0,1,1,0,0,,0,0,10,5,5,void
836,71749,_proxy_event_handler_dequeue,1,_proxy_event_handler_dequeue,int _proxy_event_handler_dequeue (proxy_event_thread_t*),proxy_network.c,"static int _proxy_event_handler_dequeue(proxy_event_thread_t *t) {
    io_head_t head;

    STAILQ_INIT(&head);
    STAILQ_INIT(&t->be_head);

    // Pull the entire stack of inbound into local queue.
    pthread_mutex_lock(&t->mutex);
    STAILQ_CONCAT(&head, &t->io_head_in);
    pthread_mutex_unlock(&t->mutex);

    int io_count = 0;
    int be_count = 0;
    while (!STAILQ_EMPTY(&head)) {
        io_pending_proxy_t *io = STAILQ_FIRST(&head);
        io->flushed = false;
        mcp_backend_t *be = io->backend;
        // So the backend can retrieve its event base.
        be->event_thread = t;

        // _no_ mutex on backends. they are owned by the event thread.
        STAILQ_REMOVE_HEAD(&head, io_next);
        // paranoia about moving items between lists.
        io->io_next.stqe_next = NULL;

        if (be->bad) {
            P_DEBUG(""%s: fast failing request to bad backend\n"", __func__);
            io->client_resp->status = MCMC_ERR;
            return_io_pending((io_pen...",14.0,58.0,1.0,4.0,45.0,147,10,74,9,0,1,5,6,0,1,,0,0,2,1,1,int
837,73215,proxy_backend_retry_handler,1,proxy_backend_retry_handler,"void proxy_backend_retry_handler (int,short,void*)",proxy_network.c,"static void proxy_backend_retry_handler(const int fd, const short which, void *arg) {
    mcp_backend_t *be = arg;
    assert(which & EV_TIMEOUT);
    struct timeval tmp_time = be->event_thread->tunables.retry;
    _set_event(be, be->event_thread->base, EV_WRITE|EV_TIMEOUT, tmp_time, proxy_backend_handler);
}",759.0,764.0,1.0,1.0,6.0,9,5,12,7,0,1,1,1,0,1,,0,0,6,3,3,void
838,73252,_backend_failed,1,_backend_failed,void _backend_failed (mcp_backend_t*),proxy_network.c,"static void _backend_failed(mcp_backend_t *be) {
    struct timeval tmp_time = be->event_thread->tunables.retry;
    if (++be->failed_count > be->event_thread->tunables.backend_failure_limit) {
        P_DEBUG(""%s: marking backend as bad\n"", __func__);
        be->bad = true;
       _set_event(be, be->event_thread->base, EV_TIMEOUT, tmp_time, proxy_backend_retry_handler);
        STAT_INCR(be->event_thread->ctx, backend_marked_bad, 1);
    } else {
        STAT_INCR(be->event_thread->ctx, backend_failed, 1);
        _set_event(be, be->event_thread->base, EV_WRITE|EV_TIMEOUT, tmp_time, proxy_backend_handler);
    }
}",779.0,790.0,1.0,8.0,12.0,29,7,14,4,0,1,2,2,0,1,,0,0,2,1,1,void
839,74302,_process_tokenize,1,_process_tokenize,"int _process_tokenize (mcp_parser_t*,size_t)",proxy_request.c,"static int _process_tokenize(mcp_parser_t *pr, const size_t max) {
    const char *s = pr->request;
    int len = pr->reqlen - 2;

    // since multigets can be huge, we can't purely judge reqlen against this
    // limit, but we also can't index past it since the tokens are shorts.
    if (len > PARSER_MAXLEN) {
        len = PARSER_MAXLEN;
    }
    const char *end = s + len;
    int curtoken = 0;

    int state = 0;
    while (s != end) {
        switch (state) {
            case 0:
                // scanning for first non-space to find a token.
                if (*s != ' ') {
                    pr->tokens[curtoken] = s - pr->request;
                    if (++curtoken == max) {
                        s++;
                        state = 2;
                        break;
                    }
                    state = 1;
                }
                s++;
                break;
            case 1:
                // advance over a token
                if (*s != ' ') {
...",10.0,65.0,1.0,14.0,56.0,40,11,37,8,5,0,13,18,0,0,,0,0,4,2,2,int
840,74444,_process_token_len,1,_process_token_len,"int _process_token_len (mcp_parser_t*,size_t)",proxy_request.c,"static int _process_token_len(mcp_parser_t *pr, size_t token) {
    const char *s = pr->request + pr->tokens[token];
    const char *e = pr->request + pr->tokens[token+1];
    // start of next token is after any space delimiters, so back those out.
    while (*(e-1) == ' ') {
        e--;
    }
    return e - s;
}",67.0,75.0,1.0,1.0,9.0,16,8,12,4,1,0,2,2,0,0,,0,0,4,2,2,int
841,74490,_process_request_key,1,_process_request_key,int _process_request_key (mcp_parser_t*),proxy_request.c,"static int _process_request_key(mcp_parser_t *pr) {
    pr->klen = _process_token_len(pr, pr->keytoken);
    // advance the parser in case of multikey.
    pr->parsed = pr->tokens[pr->keytoken] + pr->klen + 1;

    if (pr->request[pr->parsed-1] == ' ') {
        P_DEBUG(""%s: request_key found extra space\n"", __func__);
        pr->has_space = true;
    } else {
        pr->has_space = false;
    }
    return 0;
}",77.0,89.0,1.0,8.0,13.0,18,6,11,2,5,1,2,2,0,1,,0,1,2,1,1,int
842,74639,_process_request_metaflags,1,_process_request_metaflags,"int _process_request_metaflags (mcp_parser_t*,int)",proxy_request.c,"static int _process_request_metaflags(mcp_parser_t *pr, int token) {
    if (pr->ntokens <= token) {
        pr->t.meta.flags = 0; // no flags found.
        return 0;
    }
    const char *cur = pr->request + pr->tokens[token];
    const char *end = pr->request + pr->reqlen - 2;

    // We blindly convert flags into bits, since the range of possible
    // flags is deliberately < 64.
    int state = 0;
    while (cur != end) {
        switch (state) {
            case 0:
                if (*cur == ' ') {
                    cur++;
                } else {
                    if (*cur < 65 || *cur > 122) {
                        return -1;
                    }
                    P_DEBUG(""%s: setting meta flag: %d\n"", __func__, *cur - 65);
                    pr->t.meta.flags |= (uint64_t)1 << (*cur - 65);
                    state = 1;
                }
                break;
            case 1:
                if (*cur != ' ') {
                    cur++;
                } else...",123.0,166.0,1.0,20.0,44.0,32,14,21,6,2,0,9,12,0,0,,0,0,4,2,2,int
843,74783,_process_request_meta,1,_process_request_meta,int _process_request_meta (mcp_parser_t*),proxy_request.c,"static int _process_request_meta(mcp_parser_t *pr) {
    _process_tokenize(pr, PARSER_MAX_TOKENS);
    if (pr->ntokens < 2) {
        P_DEBUG(""%s: not enough tokens for meta command: %d\n"", __func__, pr->ntokens);
        return -1;
    }
    pr->keytoken = 1;
    _process_request_key(pr);

    // pass the first flag token.
    return _process_request_metaflags(pr, 2);
}",169.0,180.0,1.0,26.0,12.0,5,4,5,1,0,3,2,2,0,3,,0,0,2,1,1,int
844,74814,_process_request_mset,1,_process_request_mset,int _process_request_mset (mcp_parser_t*),proxy_request.c,"static int _process_request_mset(mcp_parser_t *pr) {
    _process_tokenize(pr, PARSER_MAX_TOKENS);
    if (pr->ntokens < 3) {
        P_DEBUG(""%s: not enough tokens for meta set command: %d\n"", __func__, pr->ntokens);
        return -1;
    }
    pr->keytoken = 1;
    _process_request_key(pr);

    const char *cur = pr->request + pr->tokens[2];

    errno = 0;
    char *n = NULL;
    int vlen = strtol(cur, &n, 10);
    if ((errno == ERANGE) || (cur == n)) {
        return -1;
    }

    if (vlen < 0 || vlen > (INT_MAX - 2)) {
       return -1;
    }
    vlen += 2;

    pr->vlen = vlen;

    // pass the first flag token
    return _process_request_metaflags(pr, 3);
}",183.0,210.0,1.0,26.0,28.0,26,12,24,8,0,3,4,4,0,3,,0,0,2,1,1,int
845,74906,_process_request_gat,1,_process_request_gat,int _process_request_gat (mcp_parser_t*),proxy_request.c,"static int _process_request_gat(mcp_parser_t *pr) {
    _process_tokenize(pr, 3);
    if (pr->ntokens < 3) {
        P_DEBUG(""%s: not enough tokens for GAT: %d\n"", __func__, pr->ntokens);
        return -1;
    }

    pr->keytoken = 2;
    _process_request_key(pr);
    return 0;
}",213.0,223.0,1.0,8.0,11.0,5,4,4,1,0,2,2,2,0,2,,0,0,2,1,1,int
846,74933,_process_request_noreply,1,_process_request_noreply,int _process_request_noreply (mcp_parser_t*),proxy_request.c,"static int _process_request_noreply(mcp_parser_t *pr) {
    if (pr->tokens[pr->ntokens] - pr->tokens[pr->ntokens-1] >= NOREPLYLEN
            && strncmp(NOREPLYSTR, pr->request + pr->tokens[pr->ntokens-1], NOREPLYLEN) == 0) {
        pr->noreply = true;
    }
    return 0;
}",229.0,235.0,1.0,63.0,7.0,23,9,9,2,2,0,2,2,0,0,,0,0,2,1,1,int
847,74997,_process_request_storage,1,_process_request_storage,"int _process_request_storage (mcp_parser_t*,size_t)",proxy_request.c,"static int _process_request_storage(mcp_parser_t *pr, size_t max) {
    _process_tokenize(pr, max);
    if (pr->ntokens < 5) {
        P_DEBUG(""%s: not enough tokens to storage command: %d\n"", __func__, pr->ntokens);
        return -1;
    }
    pr->keytoken = 1;
    _process_request_key(pr);

    errno = 0;
    char *n = NULL;
    const char *cur = pr->request + pr->tokens[4];

    int vlen = strtol(cur, &n, 10);
    if ((errno == ERANGE) || (cur == n)) {
        return -1;
    }

    if (vlen < 0 || vlen > (INT_MAX - 2)) {
       return -1;
    }
    vlen += 2;

    pr->vlen = vlen;

    return _process_request_noreply(pr);
}",240.0,266.0,1.0,8.0,27.0,26,12,25,9,0,3,4,4,0,3,,0,0,4,2,2,int
848,75087,_process_request_simple,1,_process_request_simple,"int _process_request_simple (mcp_parser_t*,size_t)",proxy_request.c,"static int _process_request_simple(mcp_parser_t *pr, const size_t max) {
    _process_tokenize(pr, max);
    pr->keytoken = 1; // second token is usually the key... stupid GAT.

    _process_request_key(pr);
    return _process_request_noreply(pr);
}",269.0,275.0,1.0,1.0,7.0,2,2,5,2,0,3,1,1,0,3,,0,0,4,2,2,int
849,77075,ketama_md5_digest,1,ketama_md5_digest,"void ketama_md5_digest (char*,unsigned char[16])",proxy_ring_hash.c,"static void ketama_md5_digest( char* inString, unsigned char md5pword[16] )
{
    md5_state_t md5state;

    md5_init( &md5state );
    md5_append( &md5state, (unsigned char *)inString, strlen( inString ) );
    md5_finish( &md5state, md5pword );
}",54.0,61.0,1.0,1.0,8.0,4,2,6,3,3,3,1,1,0,3,,0,0,4,2,2,void
850,77097,ketama_compare,1,ketama_compare,"int ketama_compare (void*,void*)",proxy_ring_hash.c,"static int ketama_compare(const void *p1, const void *p2) {
    const cpoint *a = p1;
    const cpoint *b = p2;

    return (a->point < b->point) ? -1 : ((a->point > b->point) ? 1 : 0);
}",63.0,68.0,1.0,1.0,6.0,11,6,8,4,0,4,1,1,0,0,,0,4,4,2,2,int
851,77183,ketama_get_server,1,ketama_get_server,"uint32_t ketama_get_server (uint64_t,void*)",proxy_ring_hash.c,"static uint32_t ketama_get_server(uint64_t hash, void *ctx) {
    ketama_t *kt = (ketama_t *)ctx;
    unsigned int h = hash;
    int highp = kt->total_buckets;
    int lowp = 0, midp;
    unsigned int midval, midval1;

    // divide and conquer array search to find server with next biggest
    // point after what this key hashes to
    while ( 1 )
    {
        midp = (int)( ( lowp+highp ) / 2 );

        if ( midp == kt->total_buckets )
            return kt->continuum[0].id-1; // if at the end, roll back to zeroth

        midval = kt->continuum[midp].point;
        midval1 = midp == 0 ? 0 : kt->continuum[midp-1].point;

        if ( h <= midval && h > midval1 )
            return kt->continuum[midp].id-1;

        if ( midval < h )
            lowp = midp + 1;
        else
            highp = midp - 1;

        if ( lowp > highp )
            return kt->continuum[0].id-1;
    }
}",89.0,119.0,1.0,1.0,31.0,42,14,33,9,0,7,6,10,1,0,,0,7,4,2,2,uint32_t
852,77317,_add_server_default,1,_add_server_default,"void _add_server_default (ketama_t*,size_t,char**,lua_Integer,lua_Integer,unsigned int*)",proxy_ring_hash.c,"static void _add_server_default(ketama_t *kt, size_t hashstring_size, const char **parts,
        lua_Integer bucket_size, lua_Integer id, unsigned int *cont) {
    char *hashstring = malloc(hashstring_size);

    for (int k = 0; k < bucket_size; k++) {
        size_t len = snprintf(hashstring, hashstring_size, ""%s:%s-%d"", parts[0], parts[1], k);
        kt->continuum[*cont].point = (unsigned int) XXH3_64bits(hashstring, len);
        kt->continuum[*cont].id = id;
    }

    free(hashstring);
}",130.0,141.0,1.0,52.0,12.0,17,7,19,9,1,2,2,2,0,0,,0,2,12,6,6,void
853,77386,_add_server_ketama,1,_add_server_ketama,"void _add_server_ketama (ketama_t*,size_t,char**,lua_Integer,lua_Integer,unsigned int*)",proxy_ring_hash.c,"static void _add_server_ketama(ketama_t *kt, size_t hashstring_size, const char **parts,
        lua_Integer bucket_size, lua_Integer id, unsigned int *cont) {
    char *hashstring = malloc(hashstring_size);

    for (int k = 0; k < bucket_size / 4; k++) {
        unsigned char digest[16];

        // - create hashing string for ketama
        snprintf(hashstring, hashstring_size, ""%s:%s-%d"", parts[0], parts[1], k);

        // - md5() hash it
        // mostly from ketama.c
        ketama_md5_digest(hashstring, digest);

        /* Use successive 4-bytes from hash as numbers
         * for the points on the circle: */
        for(int h = 0; h < 4; h++ )
        {
            kt->continuum[*cont].point = ( digest[3+h*4] << 24 )
                                  | ( digest[2+h*4] << 16 )
                                  | ( digest[1+h*4] <<  8 )
                                  |   digest[h*4];
            kt->continuum[*cont].id = id;
            (*cont)++;
        }

    }

    f...",143.0,172.0,1.0,1.0,30.0,37,12,29,10,1,3,3,4,0,1,,0,2,12,6,6,void
854,77501,_add_server_twemproxy,1,_add_server_twemproxy,"void _add_server_twemproxy (ketama_t*,size_t,char**,lua_Integer,lua_Integer,unsigned int*)",proxy_ring_hash.c,"static void _add_server_twemproxy(ketama_t *kt, size_t hashstring_size, const char **parts,
        lua_Integer bucket_size, lua_Integer id, unsigned int *cont) {
    char *hashstring = malloc(hashstring_size);

    for (int k = 0; k < bucket_size / 4; k++) {
        unsigned char digest[16];

        // - create hashing string for ketama
        if (strcmp(parts[1], ""11211"") == 0) {
            // twemproxy sources libmemcached as removing the default port
            // from the string if found.
            snprintf(hashstring, hashstring_size, ""%s-%d"", parts[0], k);
        } else {
            snprintf(hashstring, hashstring_size, ""%s:%s-%d"", parts[0], parts[1], k);
        }

        // - md5() hash it
        // mostly from ketama.c
        ketama_md5_digest(hashstring, digest);

        /* Use successive 4-bytes from hash as numbers
         * for the points on the circle: */
        for(int h = 0; h < 4; h++ )
        {
            kt->continuum[*cont].point = ( digest[3+h*4...",174.0,209.0,1.0,1.0,36.0,38,13,29,10,1,3,4,6,0,1,,0,2,12,6,6,void
855,77635,_add_server_evcache,1,_add_server_evcache,"void _add_server_evcache (ketama_t*,size_t,char**,lua_Integer,lua_Integer,unsigned int*)",proxy_ring_hash.c,"static void _add_server_evcache(ketama_t *kt, size_t hashstring_size, const char **parts,
        lua_Integer bucket_size, lua_Integer id, unsigned int *cont) {
    char *hashstring = malloc(hashstring_size);

    for (int k = 0; k < bucket_size / 4; k++) {
        unsigned char digest[16];

        // - create hashing string for ketama
        snprintf(hashstring, hashstring_size, ""%s/%s:%s-%d"", parts[0], parts[0], parts[1], k);
        // - md5() hash it
        // mostly from ketama.c
        ketama_md5_digest(hashstring, digest);

        /* Use successive 4-bytes from hash as numbers
         * for the points on the circle: */
        for(int h = 0; h < 4; h++ )
        {
            kt->continuum[*cont].point = ( digest[3+h*4] << 24 )
                                  | ( digest[2+h*4] << 16 )
                                  | ( digest[1+h*4] <<  8 )
                                  |   digest[h*4];
            kt->continuum[*cont].id = id;
            (*cont)++;
        }
...",211.0,239.0,1.0,1.0,29.0,38,12,30,10,1,3,3,4,0,1,,0,2,12,6,6,void
856,77753,ketama_new,1,ketama_new,int ketama_new (lua_State*),proxy_ring_hash.c,"static int ketama_new(lua_State *L) {
    lua_Integer bucket_size = DEFAULT_BUCKET_SIZE;
    const char *parts[PARTS];
    size_t partlens[PARTS];
    int makemode = 0;

    // check for UA_TTABLE at 1
    luaL_checktype(L, 1, LUA_TTABLE);
    // get number of servers in pool.
    // NOTE: rawlen skips metatable redirection. if we care; lua_len instead.
    lua_Unsigned total = lua_rawlen(L, 1);

    // check for optional input
    int argc = lua_gettop(L);
    if (argc > 1) {
        luaL_checktype(L, 2, LUA_TTABLE);
        if (lua_getfield(L, 2, ""omode"") != LUA_TNIL) {
            luaL_checktype(L, -1, LUA_TSTRING);
            const char *mode = lua_tostring(L, -1);
            if (strcmp(mode, ""default"") == 0) {
                makemode = MODE_DEFAULT;
            } else if (strcmp(mode, ""ketama"") == 0) {
                makemode = MODE_KETAMA;
            } else if (strcmp(mode, ""twemproxy"") == 0) {
                makemode = MODE_TWEMPROXY;
            } else if (strcmp(mode,...",243.0,356.0,1.0,30.0,114.0,69,16,102,20,0,12,13,17,0,4,,0,8,2,1,1,int
857,78568,restart_register,1,restart_register,"void restart_register (char*,restart_check_cb,restart_save_cb,void*)",restart.c,"void restart_register(const char *tag, restart_check_cb ccb, restart_save_cb scb, void *data) {
    restart_data_cb *cb = calloc(1, sizeof(restart_data_cb));
    if (cb == NULL) {
        fprintf(stderr, ""[restart] failed to allocate callback register\n"");
        abort();
    }

    // Handle first time call initialization inline so we don't need separate
    // API call.
    if (cb_stack == NULL) {
        cb_stack = cb;
    } else {
        // Ensure we fire the callbacks in registration order.
        // Someday I'll get a queue.h overhaul.
        restart_data_cb *finder = cb_stack;
        while (finder->next != NULL) {
            finder = finder->next;
        }
        finder->next = cb;
    }

    safe_strcpy(cb->tag, tag, RESTART_TAG_MAXLEN);
    cb->data = data;
    cb->ccb = *ccb;
    cb->scb = *scb;
}",33.0,58.0,1.0,30.0,26.0,14,5,17,9,1,3,3,3,1,1,,0,2,8,4,4,void
858,78654,restart_check,1,restart_check,int restart_check (char*),restart.c,"static int restart_check(const char *file) {
    // metadata is kept in a separate file.
    size_t flen = strlen(file);
    const char *ext = "".meta"";
    char *metafile = calloc(1, flen + strlen(ext) + 1);
    if (metafile == NULL) {
        // probably in a really bad position if we hit here, so don't start.
        fprintf(stderr, ""[restart] failed to allocate memory for restart check\n"");
        abort();
    }
    memcpy(metafile, file, flen);
    memcpy(metafile+flen, ext, strlen(ext));

    FILE *f = fopen(metafile, ""r"");
    if (f == NULL) {
        fprintf(stderr, ""[restart] no metadata save file, starting with a clean cache\n"");
        free(metafile);
        return -1;
    }

    restart_cb_ctx ctx;

    ctx.f = f;
    ctx.cb = NULL;
    ctx.line = NULL;
    ctx.done = false;
    if (restart_get_kv(&ctx, NULL, NULL) != RESTART_DONE) {
        // First line must be a tag, so read it in and set up the proper
        // callback here.
        fprintf(stderr, ""[restart] cor...",72.0,134.0,1.0,1.0,63.0,36,9,56,13,1,10,10,10,4,1,,0,10,2,1,1,int
859,78827,restart_get_kv,1,restart_get_kv,"enum restart_get_kv_ret restart_get_kv (void*,char**,char**)",restart.c,"enum restart_get_kv_ret restart_get_kv(void *ctx, char **key, char **val) {
    char *line = NULL;
    size_t len = 0;
    restart_data_cb *cb = NULL;
    restart_cb_ctx *c = (restart_cb_ctx *) ctx;
    // free previous line.
    // we could just pass it into getline, but it can randomly realloc so we'd
    // have to re-assign it into the structure anyway.
    if (c->line != NULL) {
        free(c->line);
        c->line = NULL;
    }

    if (getline(&line, &len, c->f) != -1) {
        // First char is an indicator:
        // T for TAG, changing the callback we use.
        // K for key/value, to ship to the active callback.
        char *p = line;
        while (*p != '\n') {
            p++;
        }
        *p = '\0';

        if (line[0] == 'T') {
            cb = cb_stack;
            while (cb != NULL) {
                // NOTE: len is allocated size, not line len. need to chomp \n
                if (strcmp(cb->tag, line+1) == 0) {
                    break;
             ...",141.0,211.0,1.0,1.0,71.0,34,11,37,11,2,6,9,17,2,0,,0,6,6,3,3,enum restart_get_kv_ret
860,79026,restart_save,1,restart_save,int restart_save (char*),restart.c,"static int restart_save(const char *file) {
    // metadata is kept in a separate file.
    // FIXME: function.
    size_t flen = strlen(file);
    const char *ext = "".meta"";
    size_t extlen = strlen(ext);
    char *metafile = calloc(1, flen + extlen + 1);
    if (metafile == NULL) {
        fprintf(stderr, ""[restart] failed to allocate memory during metadata save\n"");
        return -1;
    }
    memcpy(metafile, file, flen);
    memcpy(metafile+flen, ext, extlen);

    // restrictive permissions for the metadata file.
    // TODO: also for the mmap file eh? :P
    mode_t oldmask = umask(~(S_IRUSR | S_IWUSR));
    FILE *f = fopen(metafile, ""w"");
    umask(oldmask);
    if (f == NULL) {
        // FIXME: correct error handling.
        free(metafile);
        perror(""failed to write metadata file"");
        return -1;
    }

    restart_data_cb *cb = cb_stack;
    restart_cb_ctx ctx;
    ctx.f = f;
    while (cb != NULL) {
        // Plugins/engines in the metadata file are separa...",217.0,262.0,1.0,1.0,46.0,28,10,45,14,1,2,5,6,0,0,,0,2,2,1,1,int
861,79159,restart_set_kv,1,restart_set_kv,"void restart_set_kv (void*,char*,char*...)",restart.c,"void restart_set_kv(void *ctx, const char *key, const char *fmt, ...) {
    va_list ap;
    restart_cb_ctx *c = (restart_cb_ctx *) ctx;
    char valbuf[SET_VAL_MAX];

    va_start(ap, fmt);
    int vlen = vsnprintf(valbuf, SET_VAL_MAX-1, fmt, ap);
    va_end(ap);
    // This is heavy handed. We need to protect against corrupt data as much
    // as possible. The buffer is large and these values are currently small,
    // it will take a significant mistake to land here.
    if (vlen >= SET_VAL_MAX) {
        fprintf(stderr, ""[restart] fatal error while saving metadata state, value too long for: %s %s"",
                key, valbuf);
        abort();
    }

    fprintf(c->f, ""K%s %s\n"", key, valbuf);
    // TODO: update crc32c
}",268.0,287.0,1.0,16.0,20.0,6,5,16,8,17,1,2,2,0,0,,0,1,6,3,3,void
862,79211,_find_pagesize,1,_find_pagesize,long _find_pagesize (void),restart.c,"static long _find_pagesize(void) {
#if defined(HAVE_SYSCONF) && defined(_SC_PAGESIZE)
    return sysconf(_SC_PAGESIZE);
#else
    // A good guess.
    return 4096;
#endif
}",289.0,296.0,1.0,1.0,8.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,long
863,79218,restart_mmap_open,1,restart_mmap_open,"bool restart_mmap_open (size_t,char*,void**)",restart.c,"bool restart_mmap_open(const size_t limit, const char *file, void **mem_base) {
    bool reuse_mmap = true;

    long pagesize = _find_pagesize();
    memory_file = strdup(file);
    mmap_fd = open(file, O_RDWR|O_CREAT, S_IRWXU);
    if (mmap_fd == -1) {
        perror(""failed to open file for mmap"");
        abort();
    }
    if (ftruncate(mmap_fd, limit) != 0) {
        perror(""ftruncate failed"");
        abort();
    }
    /* Allocate everything in a big chunk with malloc */
    if (limit % pagesize) {
        // This is a sanity check; shouldn't ever be possible since we
        // increase memory by whole megabytes.
        fprintf(stderr, ""[restart] memory limit not divisible evenly by pagesize (please report bug)\n"");
        abort();
    }
    mmap_base = mmap(NULL, limit, PROT_READ|PROT_WRITE, MAP_SHARED, mmap_fd, 0);
    if (mmap_base == MAP_FAILED) {
        perror(""failed to mmap, aborting"");
        abort();
    }
    // Set the limit before calling check_mmap, so we c...",298.0,332.0,1.0,1.0,35.0,17,7,33,20,1,10,6,6,4,2,,0,10,6,3,3,bool
864,79310,restart_mmap_close,1,restart_mmap_close,void restart_mmap_close (void),restart.c,"void restart_mmap_close(void) {
    msync(mmap_base, slabmem_limit, MS_SYNC);

    if (restart_save(memory_file) != 0) {
        fprintf(stderr, ""[restart] failed to save metadata"");
    }

    if (munmap(mmap_base, slabmem_limit) != 0) {
        perror(""[restart] failed to munmap shared memory"");
    } else if (close(mmap_fd) != 0) {
        perror(""[restart] failed to close shared memory fd"");
    }

    free(memory_file);
}",335.0,349.0,1.0,1.0,15.0,2,1,8,5,1,5,3,3,3,1,,0,5,2,1,1,void
865,79349,restart_fixup,1,restart_fixup,unsigned int restart_fixup (void*),restart.c,"unsigned int restart_fixup(void *orig_addr) {
    struct timeval tv;
    uint64_t checked = 0;
    const unsigned int page_size = settings.slab_page_size;
    unsigned int page_remain = page_size;

    gettimeofday(&tv, NULL);
    if (settings.verbose > 0) {
        fprintf(stderr, ""[restart] original memory base: [%p] new base: [%p]\n"", orig_addr, mmap_base);
        fprintf(stderr, ""[restart] recovery start [%d.%d]\n"", (int)tv.tv_sec, (int)tv.tv_usec);
    }

    // since chunks don't align with pages, we have to also track page size.
    while (checked < slabmem_limit) {
        //fprintf(stderr, ""checked: %lu\n"", checked);
        item *it = (item *)((char *)mmap_base + checked);

        int size = slabs_fixup((char *)mmap_base + checked,
                checked % settings.slab_page_size);
        //fprintf(stderr, ""id: %d, size: %d remain: %u\n"", it->slabs_clsid, size, page_remain);
        // slabber gobbled an entire page, skip and move on.
        if (size == -1) {
        ...",354.0,443.0,1.0,27.0,90.0,143,18,98,15,1,17,15,30,3,3,,0,16,2,1,1,unsigned int
866,79845,sasl_log,1,sasl_log,"int sasl_log (void*,int,char*)",sasl_defs.c,"static int sasl_log(void *context, int level, const char *message)
{
    bool log = true;

    switch (level) {
    case SASL_LOG_NONE:
        log = false;
        break;
    case SASL_LOG_PASS:
    case SASL_LOG_TRACE:
    case SASL_LOG_DEBUG:
    case SASL_LOG_NOTE:
        if (settings.verbose < 2) {
            log = false;
        }
        break;
    case SASL_LOG_WARN:
    case SASL_LOG_FAIL:
        if (settings.verbose < 1) {
            log = false;
        }
        break;
    default:
        /* This is an error */
        ;
    }

    if (log) {
        fprintf(stderr, ""SASL (severity %d): %s\n"", level, message);
    }

    return SASL_OK;
}",141.0,173.0,1.0,11.0,33.0,8,3,22,14,0,2,8,7,2,0,,0,2,6,3,3,int
867,80094,slab_automove_init,1,slab_automove_init,void* slab_automove_init (settings*),slab_automove.c,"void *slab_automove_init(struct settings *settings) {
    uint32_t window_size = settings->slab_automove_window;
    double max_age_ratio = settings->slab_automove_ratio;
    slab_automove *a = calloc(1, sizeof(slab_automove));
    if (a == NULL)
        return NULL;
    a->window_data = calloc(window_size * MAX_NUMBER_OF_SLAB_CLASSES, sizeof(struct window_data));
    a->window_size = window_size;
    a->max_age_ratio = max_age_ratio;
    if (a->window_data == NULL) {
        free(a);
        return NULL;
    }

    // do a dry run to fill the before structs
    fill_item_stats_automove(a->iam_before);
    fill_slab_stats_automove(a->sam_before);

    return (void *)a;
}",34.0,53.0,1.0,42.0,20.0,21,7,23,7,0,9,3,3,0,2,,0,7,2,1,1,void*
868,80189,window_sum,1,window_sum,"void window_sum (window_data*,window_data*,uint32_t)",slab_automove_extstore.c,"static void window_sum(struct window_data *wd, struct window_data *w,
        uint32_t size) {
    for (int x = 0; x < size; x++) {
        struct window_data *d = &wd[x];
        w->age += d->age;
        w->dirty += d->dirty;
        w->evicted += d->evicted;
        w->excess_free += d->excess_free;
        w->relaxed += d->relaxed;
    }
}",74.0,84.0,1.0,1.0,11.0,17,6,14,5,2,8,2,2,0,0,,0,8,6,3,3,void
869,80243,slab_automove_run,1,slab_automove_run,"void slab_automove_run (void*,int*,int*)",slab_automove.c,"void slab_automove_run(void *arg, int *src, int *dst) {
    slab_automove *a = (slab_automove *)arg;
    int n;
    struct window_data w_sum;
    int oldest = -1;
    uint64_t oldest_age = 0;
    int youngest = -1;
    uint64_t youngest_age = ~0;
    bool youngest_evicting = false;
    *src = -1;
    *dst = -1;

    // fill after structs
    fill_item_stats_automove(a->iam_after);
    fill_slab_stats_automove(a->sam_after);
    // Loop once to get total_evicted for this window.
    uint64_t evicted_total = 0;
    for (n = POWER_SMALLEST; n < MAX_NUMBER_OF_SLAB_CLASSES; n++) {
        evicted_total += a->iam_after[n].evicted - a->iam_before[n].evicted;
    }
    a->window_cur++;

    // iterate slabs
    for (n = POWER_SMALLEST; n < MAX_NUMBER_OF_SLAB_CLASSES; n++) {
        int w_offset = n * a->window_size;
        struct window_data *wd = &a->window_data[w_offset + (a->window_cur % a->window_size)];
        memset(wd, 0, sizeof(struct window_data));

        // if page delta, or e...",74.0,169.0,1.0,13.0,96.0,169,24,116,21,0,43,13,21,15,3,,0,40,6,3,3,void
870,80801,slab_automove_extstore_init,1,slab_automove_extstore_init,void* slab_automove_extstore_init (settings*),slab_automove_extstore.c,"void *slab_automove_extstore_init(struct settings *settings) {
    uint32_t window_size = settings->slab_automove_window;
    double max_age_ratio = settings->slab_automove_ratio;
    slab_automove *a = calloc(1, sizeof(slab_automove));
    if (a == NULL)
        return NULL;
    a->window_data = calloc(window_size * MAX_NUMBER_OF_SLAB_CLASSES, sizeof(struct window_data));
    a->window_size = window_size;
    a->max_age_ratio = max_age_ratio;
    a->free_ratio = settings->slab_automove_freeratio;
    a->item_size = settings->ext_item_size;
    a->settings = settings;
    a->pool_filled_once = false;
    if (a->window_data == NULL) {
        if (a->window_data)
            free(a->window_data);
        free(a);
        return NULL;
    }

    // do a dry run to fill the before structs
    fill_item_stats_automove(a->iam_before);
    fill_slab_stats_automove(a->sam_before);

    return (void *)a;
}",41.0,66.0,1.0,42.0,26.0,33,7,33,8,0,14,4,5,0,2,,0,12,2,1,1,void*
871,80990,global_pool_check,1,global_pool_check,int global_pool_check (slab_automove*),slab_automove_extstore.c,"static int global_pool_check(slab_automove *a) {
    bool mem_limit_reached;
    unsigned int free = a->global_pool_watermark;
    unsigned int count = global_page_pool_size(&mem_limit_reached);
    if (!mem_limit_reached)
        return 0;
    if (count < free) {
        a->pool_filled_once = true;
        return 1;
    } else {
        a->pool_filled_once = true;
    }
    return 0;
}",86.0,99.0,1.0,1.0,14.0,8,5,9,5,1,3,3,3,0,1,,0,3,2,1,1,int
872,81035,memcheck,1,memcheck,void memcheck (slab_automove*),slab_automove_extstore.c,"static void memcheck(slab_automove *a) {
    unsigned int total_pages = 0;

    // FIXME: is there a cached counter for total pages alloced?
    // technically we only really need to do this once as the pages are
    // prefilled and ratio isn't a runtime change.
    for (int n = 1; n < MAX_NUMBER_OF_SLAB_CLASSES; n++) {
        slab_stats_automove *sam = &a->sam_after[n];
        total_pages += sam->total_pages;
    }
    // always update what remains in the global page pool
    total_pages += a->sam_after[0].total_pages;
    a->global_pool_watermark = total_pages * a->free_ratio;
    if (a->global_pool_watermark < 2)
        a->global_pool_watermark = 2;
    settings.ext_global_pool_min = a->global_pool_watermark;
}",110.0,126.0,1.0,24.0,17.0,25,9,17,5,1,9,3,3,1,0,,0,9,2,1,1,void
873,81111,get_window_data,1,get_window_data,"struct window_data get_window_data (slab_automove*,int)",slab_automove_extstore.c,"static struct window_data *get_window_data(slab_automove *a, int class) {
    int w_offset = class * a->window_size;
    return &a->window_data[w_offset + (a->window_cur % a->window_size)];
}",128.0,131.0,1.0,1.0,4.0,10,7,7,3,1,3,1,1,0,0,,0,3,4,2,2,struct window_data
874,81140,slab_automove_extstore_run,1,slab_automove_extstore_run,"void slab_automove_extstore_run (void*,int*,int*)",slab_automove_extstore.c,"void slab_automove_extstore_run(void *arg, int *src, int *dst) {
    slab_automove *a = (slab_automove *)arg;
    int n;
    struct window_data w_sum;
    int oldest = -1;
    uint64_t oldest_age = 0;
    bool too_free = false;
    *src = -1;
    *dst = -1;

    int global_low = global_pool_check(a);
    // fill after structs
    fill_item_stats_automove(a->iam_after);
    fill_slab_stats_automove(a->sam_after);
    a->window_cur++;

    memcheck(a);

    // iterate slabs
    for (n = POWER_SMALLEST; n < MAX_NUMBER_OF_SLAB_CLASSES; n++) {
        bool small_slab = a->sam_before[n].chunk_size < a->item_size
            ? true : false;
        struct window_data *wd = get_window_data(a, n);
        int w_offset = n * a->window_size;
        memset(wd, 0, sizeof(struct window_data));
        unsigned int free_target = a->sam_after[n].chunks_per_page * MIN_PAGES_FREE;

        // if page delta, oom, or evicted delta, mark window dirty
        // classes marked dirty cannot donate memory...",133.0,228.0,1.0,13.0,96.0,138,22,98,20,0,39,11,20,13,6,,0,35,6,3,3,void
875,81651,grow_slab_list,1,grow_slab_list,int grow_slab_list (unsigned int),slabs.c,"static int grow_slab_list (const unsigned int id) {
    slabclass_t *p = &slabclass[id];
    if (p->slabs == p->list_size) {
        size_t new_size =  (p->list_size != 0) ? p->list_size * 2 : 16;
        void *new_list = realloc(p->slab_list, new_size * sizeof(void *));
        if (new_list == 0) return 0;
        p->list_size = new_size;
        p->slab_list = new_list;
    }
    return 1;
}",337.0,347.0,1.0,1.0,11.0,0,0,0,0,4,0,1,1,0,0,,0,0,2,1,1,int
876,81656,do_slabs_newslab,1,do_slabs_newslab,int do_slabs_newslab (unsigned int),slabs.c,"static int do_slabs_newslab(const unsigned int id) {
    slabclass_t *p = &slabclass[id];
    slabclass_t *g = &slabclass[SLAB_GLOBAL_PAGE_POOL];
    int len = (settings.slab_reassign || settings.slab_chunk_size_max != settings.slab_page_size)
        ? settings.slab_page_size
        : p->size * p->perslab;
    char *ptr;

    if ((mem_limit && mem_malloced + len > mem_limit && p->slabs > 0
         && g->slabs == 0)) {
        mem_limit_reached = true;
        MEMCACHED_SLABS_SLABCLASS_ALLOCATE_FAILED(id);
        return 0;
    }

    if ((grow_slab_list(id) == 0) ||
        (((ptr = get_page_from_global_pool()) == NULL) &&
        ((ptr = memory_allocate((size_t)len)) == 0))) {

        MEMCACHED_SLABS_SLABCLASS_ALLOCATE_FAILED(id);
        return 0;
    }

    // Always wipe the memory at this stage: in restart mode the mmap memory
    // could be unused, yet still full of data. Better for usability if we're
    // wiping memory as it's being pulled out of the global pool instea...",369.0,403.0,1.0,32.0,35.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,int
877,81661,memory_allocate,1,memory_allocate,void* memory_allocate (size_t),slabs.c,"static void *memory_allocate(size_t size) {
    void *ret;

    if (mem_base == NULL) {
        /* We are not using a preallocated large memory chunk */
        ret = malloc(size);
    } else {
        ret = mem_current;

        if (size > mem_avail) {
            return NULL;
        }

        /* mem_current pointer _must_ be aligned!!! */
        if (size % CHUNK_ALIGN_BYTES) {
            size += CHUNK_ALIGN_BYTES - (size % CHUNK_ALIGN_BYTES);
        }

        mem_current = ((char*)mem_current) + size;
        if (size < mem_avail) {
            mem_avail -= size;
        } else {
            mem_avail = 0;
        }
    }
    mem_malloced += size;

    return ret;
}",610.0,638.0,1.0,19.0,29.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void*
878,81666,do_slabs_free,1,do_slabs_free,"void do_slabs_free (void*,size_t,unsigned int)",slabs.c,"static void do_slabs_free(void *ptr, const size_t size, unsigned int id) {
    slabclass_t *p;
    item *it;

    assert(id >= POWER_SMALLEST && id <= power_largest);
    if (id < POWER_SMALLEST || id > power_largest)
        return;

    MEMCACHED_SLABS_FREE(size, id, ptr);
    p = &slabclass[id];

    it = (item *)ptr;
    if ((it->it_flags & ITEM_CHUNKED) == 0) {
        it->it_flags = ITEM_SLABBED;
        it->slabs_clsid = id;
        it->prev = 0;
        it->next = p->slots;
        if (it->next) it->next->prev = it;
        p->slots = it;

        p->sl_curr++;
    } else {
        do_slabs_free_chunked(it, size);
    }
    return;
}",498.0,523.0,1.0,17.0,26.0,0,0,0,0,2,0,1,1,0,0,,0,0,6,3,3,void
879,81673,slabs_preallocate,1,slabs_preallocate,void slabs_preallocate (unsigned int),slabs.c,"static void slabs_preallocate (const unsigned int maxslabs) {
    int i;
    unsigned int prealloc = 0;

    /* pre-allocate a 1MB slab in every size class so people don't get
       confused by non-intuitive ""SERVER_ERROR out of memory""
       messages.  this is the most common question on the mailing
       list.  if you really don't want this, you can rebuild without
       these three lines.  */

    for (i = POWER_SMALLEST; i < MAX_NUMBER_OF_SLAB_CLASSES; i++) {
        if (++prealloc > maxslabs)
            break;
        if (do_slabs_newslab(i) == 0) {
            fprintf(stderr, ""Error while preallocating slab memory!\n""
                ""If using -L or other prealloc options, max memory must be ""
                ""at least %d megabytes.\n"", power_largest);
            exit(1);
        }
    }
}",315.0,335.0,1.0,13.0,21.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
880,81678,slabs_clsid,1,slabs_clsid,unsigned int slabs_clsid (size_t),slabs.c,"unsigned int slabs_clsid(const size_t size) {
    int res = POWER_SMALLEST;

    if (size == 0 || size > settings.item_size_max)
        return 0;
    while (size > slabclass[res].size)
        if (res++ == power_largest)     /* won't fit in the biggest slab */
            return power_largest;
    return res;
}",90.0,99.0,1.0,14.0,10.0,8,6,8,4,4,2,3,3,2,0,,0,2,2,1,1,unsigned int
881,81720,slabs_size,1,slabs_size,unsigned int slabs_size (int),slabs.c,"unsigned int slabs_size(const int clsid) {
    return slabclass[clsid].size;
}",101.0,103.0,1.0,1.0,3.0,2,2,2,2,1,1,1,1,0,0,,0,1,2,1,1,unsigned int
882,81731,alloc_large_chunk,1,alloc_large_chunk,void* alloc_large_chunk (size_t),slabs.c,"static void * alloc_large_chunk(const size_t limit)
{
    void *ptr = NULL;
#if defined(__linux__) && defined(MADV_HUGEPAGE)
    size_t pagesize = 0;
    FILE *fp;
    int ret;

    /* Get the size of huge pages */
    fp = fopen(""/proc/meminfo"", ""r"");
    if (fp != NULL) {
        char buf[64];

        while ((fgets(buf, sizeof(buf), fp)))
            if (!strncmp(buf, ""Hugepagesize:"", 13)) {
                ret = sscanf(buf + 13, ""%zu\n"", &pagesize);

                /* meminfo huge page size is in KiBs */
                pagesize <<= 10;
            }
        fclose(fp);
    }

    if (!pagesize) {
        fprintf(stderr, ""Failed to get supported huge page size\n"");
        return NULL;
    }

    if (settings.verbose > 1)
        fprintf(stderr, ""huge page size: %zu\n"", pagesize);

    /* This works because glibc simply uses mmap when the alignment is
     * above a certain limit. */
    ret = posix_memalign(&ptr, pagesize, limit);
    if (ret != 0) {
        fprintf(stderr, ""F...",108.0,164.0,1.0,1.0,57.0,2,1,5,3,1,0,1,1,0,0,,0,0,2,1,1,void*
883,81746,slabs_fixup,1,slabs_fixup,"unsigned int slabs_fixup (char*,int)",slabs.c,"unsigned int slabs_fixup(char *chunk, const int border) {
    slabclass_t *p;
    item *it = (item *)chunk;
    int id = ITEM_clsid(it);

    // memory isn't used yet. shunt to global pool.
    // (which must be 0)
    if (id == 0) {
        //assert(border == 0);
        p = &slabclass[0];
        grow_slab_list(0);
        p->slab_list[p->slabs++] = (char*)chunk;
        return -1;
    }
    p = &slabclass[id];

    // if we're on a page border, add the slab to slab class
    if (border == 0) {
        grow_slab_list(id);
        p->slab_list[p->slabs++] = chunk;
    }

    // increase free count if ITEM_SLABBED
    if (it->it_flags == ITEM_SLABBED) {
        // if ITEM_SLABBED re-stack on freelist.
        // don't have to run pointer fixups.
        it->prev = 0;
        it->next = p->slots;
        if (it->next) it->next->prev = it;
        p->slots = it;

        p->sl_curr++;
        //fprintf(stderr, ""replacing into freelist\n"");
    }

    return p->size;
}",166.0,202.0,1.0,13.0,37.0,43,11,30,6,1,12,5,6,0,2,,0,10,4,2,2,unsigned int
884,81870,slabs_init,1,slabs_init,"void slabs_init (size_t,double,bool,uint32_t*,void*,bool)",slabs.c,"void slabs_init(const size_t limit, const double factor, const bool prealloc, const uint32_t *slab_sizes, void *mem_base_external, bool reuse_mem) {
    int i = POWER_SMALLEST - 1;
    unsigned int size = sizeof(item) + settings.chunk_size;

    /* Some platforms use runtime transparent hugepages. If for any reason
     * the initial allocation fails, the required settings do not persist
     * for remaining allocations. As such it makes little sense to do slab
     * preallocation. */
    bool __attribute__ ((unused)) do_slab_prealloc = false;

    mem_limit = limit;

    if (prealloc && mem_base_external == NULL) {
        mem_base = alloc_large_chunk(mem_limit);
        if (mem_base) {
            do_slab_prealloc = true;
            mem_current = mem_base;
            mem_avail = mem_limit;
        } else {
            fprintf(stderr, ""Warning: Failed to allocate requested memory in""
                    "" one large chunk.\nWill allocate in smaller chunks\n"");
        }
    } els...",208.0,296.0,1.0,12.0,89.0,71,19,77,24,1,34,15,23,4,3,,0,33,12,6,6,void
885,82166,slabs_prefill_global,1,slabs_prefill_global,void slabs_prefill_global (void),slabs.c,"void slabs_prefill_global(void) {
    void *ptr;
    slabclass_t *p = &slabclass[0];
    int len = settings.slab_page_size;

    while (mem_malloced < mem_limit
            && (ptr = memory_allocate(len)) != NULL) {
        grow_slab_list(0);
        // Ensure the front header is zero'd to avoid confusing restart code.
        // It's probably good enough to cast it and just zero slabs_clsid, but
        // this is extra paranoid.
        memset(ptr, 0, sizeof(item));
        p->slab_list[p->slabs++] = ptr;
    }
    mem_limit_reached = true;
}",298.0,313.0,1.0,1.0,16.0,16,10,16,11,1,9,2,2,3,2,,0,8,2,1,1,void
886,82329,split_slab_page_into_freelist,1,split_slab_page_into_freelist,"void split_slab_page_into_freelist (char*,unsigned int)",slabs.c,"static void split_slab_page_into_freelist(char *ptr, const unsigned int id) {
    slabclass_t *p = &slabclass[id];
    int x;
    for (x = 0; x < p->perslab; x++) {
        do_slabs_free(ptr, 0, id);
        ptr += p->size;
    }
}",349.0,356.0,1.0,1.0,8.0,8,6,10,5,1,4,2,2,1,1,,0,3,4,2,2,void
887,82365,get_page_from_global_pool,1,get_page_from_global_pool,void* get_page_from_global_pool (void),slabs.c,"static void *get_page_from_global_pool(void) {
    slabclass_t *p = &slabclass[SLAB_GLOBAL_PAGE_POOL];
    if (p->slabs < 1) {
        return NULL;
    }
    char *ret = p->slab_list[p->slabs - 1];
    p->slabs--;
    return ret;
}",359.0,367.0,1.0,32.0,9.0,12,7,9,4,1,5,2,2,1,0,,0,5,2,1,1,void*
888,82523,do_slabs_alloc,1,do_slabs_alloc,"void* do_slabs_alloc (size_t,unsigned int,unsigned int)",slabs.c,"static void *do_slabs_alloc(const size_t size, unsigned int id,
        unsigned int flags) {
    slabclass_t *p;
    void *ret = NULL;
    item *it = NULL;

    if (id < POWER_SMALLEST || id > power_largest) {
        MEMCACHED_SLABS_ALLOCATE_FAILED(size, 0);
        return NULL;
    }
    p = &slabclass[id];
    assert(p->sl_curr == 0 || (((item *)p->slots)->it_flags & ITEM_SLABBED));

    assert(size <= p->size);
    /* fail unless we have space at the end of a recently allocated page,
       we have something on our freelist, or we could allocate a new page */
    if (p->sl_curr == 0 && flags != SLABS_ALLOC_NO_NEWPAGE) {
        do_slabs_newslab(id);
    }

    if (p->sl_curr != 0) {
        /* return off our freelist */
        it = (item *)p->slots;
        p->slots = it->next;
        if (it->next) it->next->prev = 0;
        /* Kill flag and initialize refcount here for lock safety in slab
         * mover's freeness detection. */
        it->it_flags &= ~ITEM_SLABBED;
     ...",406.0,448.0,1.0,13.0,43.0,41,15,32,9,2,11,6,7,3,1,,0,10,6,3,3,void*
889,82664,do_slabs_free_chunked,1,do_slabs_free_chunked,"void do_slabs_free_chunked (item*,size_t)",slabs.c,"static void do_slabs_free_chunked(item *it, const size_t size) {
    item_chunk *chunk = (item_chunk *) ITEM_schunk(it);
    slabclass_t *p;

    it->it_flags = ITEM_SLABBED;
    // FIXME: refresh on how this works?
    //it->slabs_clsid = 0;
    it->prev = 0;
    // header object's original classid is stored in chunk.
    p = &slabclass[chunk->orig_clsid];
    // original class id needs to be set on free memory.
    it->slabs_clsid = chunk->orig_clsid;
    if (chunk->next) {
        chunk = chunk->next;
        chunk->prev = 0;
    } else {
        // header with no attached chunk
        chunk = NULL;
    }

    // return the header object.
    // TODO: This is in three places, here and in do_slabs_free().
    it->prev = 0;
    it->next = p->slots;
    if (it->next) it->next->prev = it;
    p->slots = it;
    p->sl_curr++;

    item_chunk *next_chunk;
    while (chunk) {
        assert(chunk->it_flags == ITEM_CHUNK);
        chunk->it_flags = ITEM_SLABBED;
        p = &slabclass[c...",450.0,495.0,1.0,39.0,46.0,71,11,47,7,0,8,5,6,0,0,,0,8,4,2,2,void
890,82964,fill_slab_stats_automove,1,fill_slab_stats_automove,void fill_slab_stats_automove (slab_stats_automove*),slabs.c,"void fill_slab_stats_automove(slab_stats_automove *am) {
    int n;
    pthread_mutex_lock(&slabs_lock);
    for (n = 0; n < MAX_NUMBER_OF_SLAB_CLASSES; n++) {
        slabclass_t *p = &slabclass[n];
        slab_stats_automove *cur = &am[n];
        cur->chunks_per_page = p->perslab;
        cur->free_chunks = p->sl_curr;
        cur->total_pages = p->slabs;
        cur->chunk_size = p->size;
    }
    pthread_mutex_unlock(&slabs_lock);
}",528.0,540.0,1.0,20.0,13.0,23,6,18,6,4,11,2,2,0,0,,0,11,2,1,1,void
891,83033,global_page_pool_size,1,global_page_pool_size,unsigned int global_page_pool_size (bool*),slabs.c,"unsigned int global_page_pool_size(bool *mem_flag) {
    unsigned int ret = 0;
    pthread_mutex_lock(&slabs_lock);
    if (mem_flag != NULL)
        *mem_flag = mem_malloced >= mem_limit ? true : false;
    ret = slabclass[SLAB_GLOBAL_PAGE_POOL].slabs;
    pthread_mutex_unlock(&slabs_lock);
    return ret;
}",545.0,553.0,1.0,20.0,9.0,11,8,13,9,3,5,2,2,0,0,,0,5,2,1,1,unsigned int
892,83073,do_slabs_stats,1,do_slabs_stats,"void do_slabs_stats (ADD_STAT,void*)",slabs.c,"static void do_slabs_stats(ADD_STAT add_stats, void *c) {
    int i, total;
    /* Get the per-thread stats which contain some interesting aggregates */
    struct thread_stats thread_stats;
    threadlocal_stats_aggregate(&thread_stats);

    total = 0;
    for(i = POWER_SMALLEST; i <= power_largest; i++) {
        slabclass_t *p = &slabclass[i];
        if (p->slabs != 0) {
            uint32_t perslab, slabs;
            slabs = p->slabs;
            perslab = p->perslab;

            char key_str[STAT_KEY_LEN];
            char val_str[STAT_VAL_LEN];
            int klen = 0, vlen = 0;

            APPEND_NUM_STAT(i, ""chunk_size"", ""%u"", p->size);
            APPEND_NUM_STAT(i, ""chunks_per_page"", ""%u"", perslab);
            APPEND_NUM_STAT(i, ""total_pages"", ""%u"", slabs);
            APPEND_NUM_STAT(i, ""total_chunks"", ""%u"", slabs * perslab);
            APPEND_NUM_STAT(i, ""used_chunks"", ""%u"",
                            slabs*perslab - p->sl_curr);
            APPEND_NUM_STAT(i, ""...",556.0,608.0,1.0,12.0,53.0,85,11,216,16,1,12,3,4,2,3,,0,9,4,2,2,void
893,83689,memory_release,1,memory_release,void memory_release (),slabs.c,"static void memory_release() {
    void *p = NULL;
    if (mem_base != NULL)
        return;

    if (!settings.slab_reassign)
        return;

    while (mem_malloced > mem_limit &&
            (p = get_page_from_global_pool()) != NULL) {
        free(p);
        mem_malloced -= settings.slab_page_size;
    }
}",641.0,654.0,1.0,1.0,14.0,10,7,12,6,1,7,4,4,5,1,,0,7,0,0,0,void
894,83728,slabs_alloc,1,slabs_alloc,"void* slabs_alloc (size_t,unsigned int,unsigned int)",slabs.c,"void *slabs_alloc(size_t size, unsigned int id,
        unsigned int flags) {
    void *ret;

    pthread_mutex_lock(&slabs_lock);
    ret = do_slabs_alloc(size, id, flags);
    pthread_mutex_unlock(&slabs_lock);
    return ret;
}",656.0,664.0,1.0,1.0,9.0,3,2,7,5,1,3,1,1,0,1,,0,3,6,3,3,void*
895,83750,slabs_free,1,slabs_free,"void slabs_free (void*,size_t,unsigned int)",slabs.c,"void slabs_free(void *ptr, size_t size, unsigned int id) {
    pthread_mutex_lock(&slabs_lock);
    do_slabs_free(ptr, size, id);
    pthread_mutex_unlock(&slabs_lock);
}",666.0,670.0,1.0,1.0,5.0,2,1,5,4,1,3,1,1,0,1,,0,2,6,3,3,void
896,83767,slabs_stats,1,slabs_stats,"void slabs_stats (ADD_STAT,void*)",slabs.c,"void slabs_stats(ADD_STAT add_stats, void *c) {
    pthread_mutex_lock(&slabs_lock);
    do_slabs_stats(add_stats, c);
    pthread_mutex_unlock(&slabs_lock);
}",672.0,676.0,1.0,1.0,5.0,2,1,4,3,0,3,1,1,0,1,,0,2,4,2,2,void
897,83782,do_slabs_adjust_mem_limit,1,do_slabs_adjust_mem_limit,bool do_slabs_adjust_mem_limit (size_t),slabs.c,"static bool do_slabs_adjust_mem_limit(size_t new_mem_limit) {
    /* Cannot adjust memory limit at runtime if prealloc'ed */
    if (mem_base != NULL)
        return false;
    settings.maxbytes = new_mem_limit;
    mem_limit = new_mem_limit;
    mem_limit_reached = false; /* Will reset on next alloc */
    memory_release(); /* free what might already be in the global pool */
    return true;
}",678.0,687.0,1.0,1.0,10.0,5,3,10,8,1,5,2,2,1,0,,0,4,2,1,1,bool
898,83808,slabs_adjust_mem_limit,1,slabs_adjust_mem_limit,bool slabs_adjust_mem_limit (size_t),slabs.c,"bool slabs_adjust_mem_limit(size_t new_mem_limit) {
    bool ret;
    pthread_mutex_lock(&slabs_lock);
    ret = do_slabs_adjust_mem_limit(new_mem_limit);
    pthread_mutex_unlock(&slabs_lock);
    return ret;
}",689.0,695.0,1.0,1.0,7.0,3,2,5,3,0,3,1,1,0,1,,0,3,2,1,1,bool
899,83826,slabs_available_chunks,1,slabs_available_chunks,"unsigned int slabs_available_chunks (unsigned int,bool*,unsigned int*)",slabs.c,"unsigned int slabs_available_chunks(const unsigned int id, bool *mem_flag,
        unsigned int *chunks_perslab) {
    unsigned int ret;
    slabclass_t *p;

    pthread_mutex_lock(&slabs_lock);
    p = &slabclass[id];
    ret = p->sl_curr;
    if (mem_flag != NULL)
        *mem_flag = mem_malloced >= mem_limit ? true : false;
    if (chunks_perslab != NULL)
        *chunks_perslab = p->perslab;
    pthread_mutex_unlock(&slabs_lock);
    return ret;
}",697.0,711.0,1.0,1.0,15.0,16,8,19,12,1,7,3,3,0,0,,0,7,6,3,3,unsigned int
900,83879,slabs_mlock,1,slabs_mlock,void slabs_mlock (void),slabs.c,"void slabs_mlock(void) {
    pthread_mutex_lock(&slabs_lock);
}",719.0,721.0,1.0,1.0,3.0,1,1,1,1,1,1,1,1,0,0,,0,1,2,1,1,void
901,83887,slabs_munlock,1,slabs_munlock,void slabs_munlock (void),slabs.c,"void slabs_munlock(void) {
    pthread_mutex_unlock(&slabs_lock);
}",723.0,725.0,1.0,1.0,3.0,1,1,1,1,1,1,1,1,0,0,,0,1,2,1,1,void
902,83903,slab_rebalance_start,1,slab_rebalance_start,int slab_rebalance_start (void),slabs.c,"static int slab_rebalance_start(void) {
    slabclass_t *s_cls;
    int no_go = 0;

    pthread_mutex_lock(&slabs_lock);

    if (slab_rebal.s_clsid < SLAB_GLOBAL_PAGE_POOL ||
        slab_rebal.s_clsid > power_largest  ||
        slab_rebal.d_clsid < SLAB_GLOBAL_PAGE_POOL ||
        slab_rebal.d_clsid > power_largest  ||
        slab_rebal.s_clsid == slab_rebal.d_clsid)
        no_go = -2;

    s_cls = &slabclass[slab_rebal.s_clsid];

    if (!grow_slab_list(slab_rebal.d_clsid)) {
        no_go = -1;
    }

    if (s_cls->slabs < 2)
        no_go = -3;

    if (no_go != 0) {
        pthread_mutex_unlock(&slabs_lock);
        return no_go; /* Should use a wrapper function... */
    }

    /* Always kill the first available slab page as it is most likely to
     * contain the oldest items
     */
    slab_rebal.slab_start = s_cls->slab_list[0];
    slab_rebal.slab_end   = (char *)slab_rebal.slab_start +
        (s_cls->size * s_cls->perslab);
    slab_rebal.slab_pos   = slab_rebal.sl...",730.0,786.0,1.0,29.0,57.0,65,16,41,12,1,16,7,7,5,1,,0,14,2,1,1,int
903,84086,slab_rebalance_alloc,1,slab_rebalance_alloc,"void* slab_rebalance_alloc (size_t,unsigned int)",slabs.c,"static void *slab_rebalance_alloc(const size_t size, unsigned int id) {
    slabclass_t *s_cls;
    s_cls = &slabclass[slab_rebal.s_clsid];
    int x;
    item *new_it = NULL;

    for (x = 0; x < s_cls->perslab; x++) {
        new_it = do_slabs_alloc(size, id, SLABS_ALLOC_NO_NEWPAGE);
        /* check that memory isn't within the range to clear */
        if (new_it == NULL) {
            break;
        }
        if ((void *)new_it >= slab_rebal.slab_start
            && (void *)new_it < slab_rebal.slab_end) {
            /* Pulled something we intend to free. Mark it as freed since
             * we've already done the work of unlinking it from the freelist.
             */
            new_it->refcount = 0;
            new_it->it_flags = ITEM_SLABBED|ITEM_FETCHED;
#ifdef DEBUG_SLAB_MOVER
            memcpy(ITEM_key(new_it), ""deadbeef"", 8);
#endif
            new_it = NULL;
            slab_rebal.inline_reclaim++;
        } else {
            break;
        }
    }
    return new_i...",789.0,818.0,1.0,42.0,30.0,25,12,23,8,0,3,5,6,1,1,,0,3,4,2,2,void*
904,84178,slab_rebalance_cut_free,1,slab_rebalance_cut_free,"void slab_rebalance_cut_free (slabclass_t*,item*)",slabs.c,"static void slab_rebalance_cut_free(slabclass_t *s_cls, item *it) {
    /* Ensure this was on the freelist and nothing else. */
    assert(it->it_flags == ITEM_SLABBED);
    if (s_cls->slots == it) {
        s_cls->slots = it->next;
    }
    if (it->next) it->next->prev = it->prev;
    if (it->prev) it->prev->next = it->next;
    s_cls->sl_curr--;
}",822.0,831.0,1.0,27.0,10.0,19,4,12,2,1,3,4,4,1,0,,0,3,4,2,2,void
905,84251,slab_rebalance_move,1,slab_rebalance_move,int slab_rebalance_move (void),slabs.c,"static int slab_rebalance_move(void) {
    slabclass_t *s_cls;
    int was_busy = 0;
    int refcount = 0;
    uint32_t hv;
    void *hold_lock;
    enum move_status status = MOVE_PASS;

    s_cls = &slabclass[slab_rebal.s_clsid];
    // the offset to check if completed or not
    int offset = ((char*)slab_rebal.slab_pos-(char*)slab_rebal.slab_start)/(s_cls->size);

    // skip acquiring the slabs lock for items we've already fully processed.
    if (slab_rebal.completed[offset] == 0) {
        pthread_mutex_lock(&slabs_lock);
        hv = 0;
        hold_lock = NULL;
        item *it = slab_rebal.slab_pos;

        item_chunk *ch = NULL;
        status = MOVE_PASS;

        if (it->it_flags & ITEM_CHUNK) {
            /* This chunk is a chained part of a larger item. */
            ch = (item_chunk *) it;
            /* Instead, we use the head chunk to find the item and effectively
             * lock the entire structure. If a chunk has ITEM_CHUNK flag, its
             * head ca...",856.0,1107.0,1.0,27.0,252.0,158,22,125,27,0,15,18,38,1,4,,0,10,2,1,1,int
906,85117,slab_rebalance_finish,1,slab_rebalance_finish,void slab_rebalance_finish (void),slabs.c,"static void slab_rebalance_finish(void) {
    slabclass_t *s_cls;
    slabclass_t *d_cls;
    int x;
    uint32_t rescues;
    uint32_t evictions_nomem;
    uint32_t inline_reclaim;
    uint32_t chunk_rescues;
    uint32_t busy_deletes;

    pthread_mutex_lock(&slabs_lock);

    s_cls = &slabclass[slab_rebal.s_clsid];
    d_cls = &slabclass[slab_rebal.d_clsid];

#ifdef DEBUG_SLAB_MOVER
    /* If the algorithm is broken, live items can sneak in. */
    slab_rebal.slab_pos = slab_rebal.slab_start;
    while (1) {
        item *it = slab_rebal.slab_pos;
        assert(it->it_flags == (ITEM_SLABBED|ITEM_FETCHED));
        assert(memcmp(ITEM_key(it), ""deadbeef"", 8) == 0);
        it->it_flags = ITEM_SLABBED|ITEM_FETCHED;
        slab_rebal.slab_pos = (char *)slab_rebal.slab_pos + s_cls->size;
        if (slab_rebal.slab_pos >= slab_rebal.slab_end)
            break;
    }
#endif

    /* At this point the stolen slab is completely clear.
     * We always kill the ""first""/""oldest"" slab pag...",1109.0,1197.0,1.0,29.0,89.0,86,12,66,18,1,22,4,4,2,1,,0,19,2,1,1,void
907,85380,slab_rebalance_thread,1,slab_rebalance_thread,void* slab_rebalance_thread (void*),slabs.c,"static void *slab_rebalance_thread(void *arg) {
    int was_busy = 0;
    int backoff_timer = 1;
    int backoff_max = 1000;
    /* So we first pass into cond_wait with the mutex held */
    mutex_lock(&slabs_rebalance_lock);

    /* Must finish moving page before stopping */
    while (slab_rebalance_signal || do_run_slab_rebalance_thread) {
        if (slab_rebalance_signal == 1) {
            if (slab_rebalance_start() < 0) {
                /* Handle errors with more specificity as required. */
                slab_rebalance_signal = 0;
            }

            was_busy = 0;
        } else if (slab_rebalance_signal && slab_rebal.slab_start != NULL) {
            was_busy = slab_rebalance_move();
        }

        if (slab_rebal.done) {
            slab_rebalance_finish();
        } else if (was_busy) {
            /* Stuck waiting for some items to unlock, so slow down a bit
             * to give them a chance to free up */
            usleep(backoff_timer);
            back...",1202.0,1242.0,1.0,4.0,41.0,16,6,17,9,0,9,6,11,2,2,,0,8,2,1,1,void*
908,85484,slabs_reassign_pick_any,1,slabs_reassign_pick_any,int slabs_reassign_pick_any (int),slabs.c,"static int slabs_reassign_pick_any(int dst) {
    static int cur = POWER_SMALLEST - 1;
    int tries = power_largest - POWER_SMALLEST + 1;
    for (; tries > 0; tries--) {
        cur++;
        if (cur > power_largest)
            cur = POWER_SMALLEST;
        if (cur == dst)
            continue;
        if (slabclass[cur].slabs > 1) {
            return cur;
        }
    }
    return -1;
}",1248.0,1262.0,1.0,21.0,15.0,14,9,13,5,1,3,6,8,2,0,,0,3,2,1,1,int
909,85547,do_slabs_reassign,1,do_slabs_reassign,"enum reassign_result_type do_slabs_reassign (int,int)",slabs.c,"static enum reassign_result_type do_slabs_reassign(int src, int dst) {
    bool nospare = false;
    if (slab_rebalance_signal != 0)
        return REASSIGN_RUNNING;

    if (src == dst)
        return REASSIGN_SRC_DST_SAME;

    /* Special indicator to choose ourselves. */
    if (src == -1) {
        src = slabs_reassign_pick_any(dst);
        /* TODO: If we end up back at -1, return a new error type */
    }

    if (src < SLAB_GLOBAL_PAGE_POOL || src > power_largest ||
        dst < SLAB_GLOBAL_PAGE_POOL || dst > power_largest)
        return REASSIGN_BADCLASS;

    pthread_mutex_lock(&slabs_lock);
    if (slabclass[src].slabs < 2)
        nospare = true;
    pthread_mutex_unlock(&slabs_lock);
    if (nospare)
        return REASSIGN_NOSPARE;

    slab_rebal.s_clsid = src;
    slab_rebal.d_clsid = dst;

    slab_rebalance_signal = 1;
    pthread_cond_signal(&slab_rebalance_cond);

    return REASSIGN_OK;
}",1264.0,1296.0,1.0,14.0,33.0,25,10,32,16,1,7,7,7,3,1,,0,7,4,2,2,enum reassign_result_type
910,85645,slabs_reassign,1,slabs_reassign,"enum reassign_result_type slabs_reassign (int,int)",slabs.c,"enum reassign_result_type slabs_reassign(int src, int dst) {
    enum reassign_result_type ret;
    if (pthread_mutex_trylock(&slabs_rebalance_lock) != 0) {
        return REASSIGN_RUNNING;
    }
    ret = do_slabs_reassign(src, dst);
    pthread_mutex_unlock(&slabs_rebalance_lock);
    return ret;
}",1298.0,1306.0,1.0,1.0,9.0,4,3,7,5,3,3,2,2,1,1,,0,3,4,2,2,enum reassign_result_type
911,85671,slabs_rebalancer_pause,1,slabs_rebalancer_pause,void slabs_rebalancer_pause (void),slabs.c,"void slabs_rebalancer_pause(void) {
    pthread_mutex_lock(&slabs_rebalance_lock);
}",1309.0,1311.0,1.0,1.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,void
912,85679,slabs_rebalancer_resume,1,slabs_rebalancer_resume,void slabs_rebalancer_resume (void),slabs.c,"void slabs_rebalancer_resume(void) {
    pthread_mutex_unlock(&slabs_rebalance_lock);
}",1313.0,1315.0,1.0,1.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,void
913,85688,start_slab_maintenance_thread,1,start_slab_maintenance_thread,int start_slab_maintenance_thread (void),slabs.c,"int start_slab_maintenance_thread(void) {
    int ret;
    slab_rebalance_signal = 0;
    slab_rebal.slab_start = NULL;

    if ((ret = pthread_create(&rebalance_tid, NULL,
                              slab_rebalance_thread, NULL)) != 0) {
        fprintf(stderr, ""Can't create rebal thread: %s\n"", strerror(ret));
        return -1;
    }
    return 0;
}",1319.0,1330.0,1.0,1.0,12.0,7,5,9,6,1,1,2,2,1,0,,0,1,2,1,1,int
914,85724,stop_slab_maintenance_thread,1,stop_slab_maintenance_thread,void stop_slab_maintenance_thread (void),slabs.c,"void stop_slab_maintenance_thread(void) {
    mutex_lock(&slabs_rebalance_lock);
    do_run_slab_rebalance_thread = 0;
    pthread_cond_signal(&slab_rebalance_cond);
    pthread_mutex_unlock(&slabs_rebalance_lock);

    /* Wait for the maintenance thread to stop */
    pthread_join(rebalance_tid, NULL);
}",1334.0,1342.0,1.0,4.0,9.0,5,2,7,5,0,6,1,1,0,0,,0,6,2,1,1,void
915,85921,stats_prefix_init,1,stats_prefix_init,void stats_prefix_init (char),stats_prefix.c,"void stats_prefix_init(char delimiter) {
    prefix_delimiter = delimiter;
    memset(prefix_stats, 0, sizeof(prefix_stats));
}",16.0,19.0,1.0,1.0,4.0,2,2,4,3,0,3,1,1,0,0,,0,3,2,1,1,void
916,85934,stats_prefix_clear,1,stats_prefix_clear,void stats_prefix_clear (void),stats_prefix.c,"void stats_prefix_clear(void) {
    int i;

    for (i = 0; i < PREFIX_HASH_SIZE; i++) {
        PREFIX_STATS *cur, *next;
        for (cur = prefix_stats[i]; cur != NULL; cur = next) {
            next = cur->next;
            free(cur->prefix);
            free(cur);
        }
        prefix_stats[i] = NULL;
    }
    num_prefixes = 0;
    total_prefix_size = 0;
}",21.0,35.0,1.0,20.0,15.0,12,5,16,7,7,4,3,4,0,0,,0,4,2,1,1,void
917,85991,stats_prefix_find,1,stats_prefix_find,"PREFIX_STATS stats_prefix_find (char*,size_t)",stats_prefix.c,"PREFIX_STATS *stats_prefix_find(const char *key, const size_t nkey) {
    PREFIX_STATS *pfs;
    uint32_t hashval;
    size_t length;
    bool bailout = true;

    assert(key != NULL);

    for (length = 0; length < nkey && key[length] != '\0'; length++) {
        if (key[length] == prefix_delimiter) {
            bailout = false;
            break;
        }
    }

    if (bailout) {
        return NULL;
    }

    hashval = hash(key, length) % PREFIX_HASH_SIZE;

    for (pfs = prefix_stats[hashval]; NULL != pfs; pfs = pfs->next) {
        if (strncmp(pfs->prefix, key, length) == 0)
            return pfs;
    }

    pfs = calloc(sizeof(PREFIX_STATS), 1);
    if (NULL == pfs) {
        perror(""Can't allocate space for stats structure: calloc"");
        return NULL;
    }

    pfs->prefix = malloc(length + 1);
    if (NULL == pfs->prefix) {
        perror(""Can't allocate space for copy of prefix: malloc"");
        free(pfs);
        return NULL;
    }

    strncpy(pfs->prefix, key, ...",37.0,87.0,1.0,34.0,51.0,38,12,56,14,13,6,9,10,1,0,,0,6,4,2,2,PREFIX_STATS
918,86151,stats_prefix_record_get,1,stats_prefix_record_get,"void stats_prefix_record_get (char*,size_t,bool)",stats_prefix.c,"void stats_prefix_record_get(const char *key, const size_t nkey, const bool is_hit) {
    PREFIX_STATS *pfs;

    STATS_LOCK();
    pfs = stats_prefix_find(key, nkey);
    if (NULL != pfs) {
        pfs->num_gets++;
        if (is_hit) {
            pfs->num_hits++;
        }
    }
    STATS_UNLOCK();
}",89.0,101.0,1.0,1.0,13.0,6,4,8,5,7,3,3,4,0,1,,0,1,6,3,3,void
919,86182,stats_prefix_record_delete,1,stats_prefix_record_delete,"void stats_prefix_record_delete (char*,size_t)",stats_prefix.c,"void stats_prefix_record_delete(const char *key, const size_t nkey) {
    PREFIX_STATS *pfs;

    STATS_LOCK();
    pfs = stats_prefix_find(key, nkey);
    if (NULL != pfs) {
        pfs->num_deletes++;
    }
    STATS_UNLOCK();
}",103.0,112.0,1.0,1.0,10.0,4,4,6,4,6,3,2,2,0,1,,0,1,4,2,2,void
920,86205,stats_prefix_record_set,1,stats_prefix_record_set,"void stats_prefix_record_set (char*,size_t)",stats_prefix.c,"void stats_prefix_record_set(const char *key, const size_t nkey) {
    PREFIX_STATS *pfs;

    STATS_LOCK();
    pfs = stats_prefix_find(key, nkey);
    if (NULL != pfs) {
        pfs->num_sets++;
    }
    STATS_UNLOCK();
}",114.0,123.0,1.0,1.0,10.0,4,4,6,4,4,3,2,2,0,1,,0,1,4,2,2,void
921,86228,stats_prefix_dump,1,stats_prefix_dump,char* stats_prefix_dump (int*),stats_prefix.c,"char *stats_prefix_dump(int *length) {
    const char *format = ""PREFIX %s get %llu hit %llu set %llu del %llu\r\n"";
    PREFIX_STATS *pfs;
    char *buf;
    int i, pos;
    size_t size = 0, written = 0;
#ifndef NDEBUG
    size_t total_written = 0;
#endif
    /*
     * Figure out how big the buffer needs to be. This is the sum of the
     * lengths of the prefixes themselves, plus the size of one copy of
     * the per-prefix output with 20-digit values for all the counts,
     * plus space for the ""END"" at the end.
     */
    STATS_LOCK();
    size = strlen(format) + total_prefix_size +
           num_prefixes * (strlen(format) - 2 /* %s */
                           + 4 * (20 - 4)) /* %llu replaced by 20-digit num */
                           + sizeof(""END\r\n"");
    buf = malloc(size);
    if (NULL == buf) {
        perror(""Can't allocate stats response: malloc"");
        STATS_UNLOCK();
        return NULL;
    }

    pos = 0;
    for (i = 0; i < PREFIX_HASH_SIZE; i++) {
    ...",125.0,171.0,1.0,20.0,47.0,37,12,44,13,7,6,4,5,0,0,,0,3,2,1,1,char*
922,86699,close_conn,1,close_conn,void close_conn (),testapp.c,"static void close_conn() {
    if (con == NULL) return;
#ifdef TLS
    if (con->ssl) {
        SSL_shutdown(con->ssl);
        SSL_free(con->ssl);
    }
    if (con->ssl_ctx)
        SSL_CTX_free(con->ssl_ctx);
#endif
    if (con->sock > 0) close(con->sock);
    free(con);
    con = NULL;
}",83.0,96.0,1.0,1.0,14.0,5,4,7,2,10,7,3,3,3,0,,0,7,0,0,0,void
923,86725,cache_create_test,1,cache_create_test,enum test_return cache_create_test (void),testapp.c,"static enum test_return cache_create_test(void)
{
    cache_t *cache = cache_create(""test"", sizeof(uint32_t), sizeof(char*));
    assert(cache != NULL);
    cache_destroy(cache);
    return TEST_PASS;
}",98.0,104.0,1.0,1.0,7.0,4,3,7,5,0,2,1,1,0,2,,0,1,2,1,1,enum test_return
924,86747,cache_reuse_test,1,cache_reuse_test,enum test_return cache_reuse_test (void),testapp.c,"static enum test_return cache_reuse_test(void)
{
    int ii;
    cache_t *cache = cache_create(""test"", sizeof(uint32_t), sizeof(char*));
    if (cache == NULL) {
        return TEST_FAIL;
    }
    char *ptr = cache_alloc(cache);
    cache_free(cache, ptr);
    for (ii = 0; ii < 100; ++ii) {
        char *p = cache_alloc(cache);
        assert(p == ptr);
        cache_free(cache, ptr);
    }
    cache_destroy(cache);
    return TEST_PASS;
}",106.0,122.0,1.0,1.0,17.0,9,4,20,9,0,6,3,3,0,6,,0,3,2,1,1,enum test_return
925,86804,cache_bulkalloc,1,cache_bulkalloc,enum test_return cache_bulkalloc (size_t),testapp.c,"static enum test_return cache_bulkalloc(size_t datasize)
{
    cache_t *cache = cache_create(""test"", datasize, sizeof(char*));
    if (cache == NULL) {
        return TEST_FAIL;
    }
#define ITERATIONS 1024
    void *ptr[ITERATIONS];

    for (int ii = 0; ii < ITERATIONS; ++ii) {
        ptr[ii] = cache_alloc(cache);
        assert(ptr[ii] != 0);
        memset(ptr[ii], 0xff, datasize);
    }

    for (int ii = 0; ii < ITERATIONS; ++ii) {
        cache_free(cache, ptr[ii]);
    }

#undef ITERATIONS
    cache_destroy(cache);
    return TEST_PASS;
}",125.0,147.0,1.0,14.0,23.0,13,6,23,8,2,4,4,4,0,4,,0,2,2,1,1,enum test_return
926,86880,test_issue_161,1,test_issue_161,enum test_return test_issue_161 (void),testapp.c,"static enum test_return test_issue_161(void)
{
    enum test_return ret = cache_bulkalloc(1);
    if (ret == TEST_PASS) {
        ret = cache_bulkalloc(512);
    }

    return ret;
}",149.0,157.0,1.0,1.0,9.0,3,2,5,2,0,2,2,2,0,2,,0,2,2,1,1,enum test_return
927,86901,cache_redzone_test,1,cache_redzone_test,enum test_return cache_redzone_test (void),testapp.c,"static enum test_return cache_redzone_test(void)
{
#ifndef HAVE_UMEM_H
    cache_t *cache = cache_create(""test"", sizeof(uint32_t), sizeof(char*));

    if (cache == NULL) {
        return TEST_FAIL;
    }
    /* Ignore SIGABRT */
    struct sigaction old_action;
    struct sigaction action = { .sa_handler = SIG_IGN, .sa_flags = 0};
    sigemptyset(&action.sa_mask);
    sigaction(SIGABRT, &action, &old_action);

    /* check memory debug.. */
    char *p = cache_alloc(cache);
    char old = *(p - 1);
    *(p - 1) = 0;
    cache_free(cache, p);
    assert(cache_error == -1);
    *(p - 1) = old;

    p[sizeof(uint32_t)] = 0;
    cache_free(cache, p);
    assert(cache_error == 1);

    /* restore signal handler */
    sigaction(SIGABRT, &old_action, NULL);

    cache_destroy(cache);

    return TEST_PASS;
#else
    return TEST_SKIP;
#endif
}",159.0,194.0,1.0,1.0,36.0,29,10,34,15,0,5,2,2,0,5,,0,2,2,1,1,enum test_return
928,87000,cache_limit_revised_downward_test,1,cache_limit_revised_downward_test,enum test_return cache_limit_revised_downward_test (void),testapp.c,"static enum test_return cache_limit_revised_downward_test(void)
{
    int limit = 10, allocated_num = limit + 1, i;
    char ** alloc_objs = calloc(allocated_num, sizeof(char *));

    cache_t *cache = cache_create(""test"", sizeof(uint32_t), sizeof(char*));
    assert(cache != NULL);

    /* cache->limit is 0 and we can allocate limit+1 items */
    for (i = 0; i < allocated_num; i++) {
        alloc_objs[i] = cache_alloc(cache);
        assert(alloc_objs[i] != NULL);
    }
    assert(cache->total == allocated_num);

    /* revised downward cache->limit */
    cache_set_limit(cache, limit);

    /* If we free one item, the cache->total should decreased by one*/
    cache_free(cache, alloc_objs[0]);

    assert(cache->total == allocated_num-1);
    cache_destroy(cache);

    free(alloc_objs);

    return TEST_PASS;
}",196.0,223.0,1.0,1.0,28.0,21,9,31,9,0,7,2,2,0,5,,0,4,2,1,1,enum test_return
929,87087,test_stats_prefix_find,1,test_stats_prefix_find,enum test_return test_stats_prefix_find (void),testapp.c,"static enum test_return test_stats_prefix_find(void) {
    PREFIX_STATS *pfs1, *pfs2;

    stats_prefix_clear();
    pfs1 = stats_prefix_find(""abc"", 3);
    assert(pfs1 == NULL);
    pfs1 = stats_prefix_find(""abc|"", 4);
    assert(pfs1 == NULL);

    pfs1 = stats_prefix_find(""abc:"", 4);
    assert(pfs1 != NULL);
    assert(0ULL == (pfs1->num_gets + pfs1->num_sets + pfs1->num_deletes + pfs1->num_hits));
    pfs2 = stats_prefix_find(""abc:"", 4);
    assert(pfs1 == pfs2);
    pfs2 = stats_prefix_find(""abc:d"", 5);
    assert(pfs1 == pfs2);
    pfs2 = stats_prefix_find(""xyz123:"", 6);
    assert(pfs1 != pfs2);
    pfs2 = stats_prefix_find(""ab:"", 3);
    assert(pfs1 != pfs2);
    return TEST_PASS;
}",225.0,246.0,1.0,1.0,22.0,22,5,26,4,0,8,1,1,0,8,,0,7,2,1,1,enum test_return
930,87178,test_stats_prefix_record_get,1,test_stats_prefix_record_get,enum test_return test_stats_prefix_record_get (void),testapp.c,"static enum test_return test_stats_prefix_record_get(void) {
    PREFIX_STATS *pfs;
    stats_prefix_clear();

    stats_prefix_record_get(""abc:123"", 7, false);
    pfs = stats_prefix_find(""abc:123"", 7);
    if (pfs == NULL) {
        return TEST_FAIL;
    }
    assert(1 == pfs->num_gets);
    assert(0 == pfs->num_hits);
    stats_prefix_record_get(""abc:456"", 7, false);
    assert(2 == pfs->num_gets);
    assert(0 == pfs->num_hits);
    stats_prefix_record_get(""abc:456"", 7, true);
    assert(3 == pfs->num_gets);
    assert(1 == pfs->num_hits);
    stats_prefix_record_get(""def:"", 4, true);
    assert(3 == pfs->num_gets);
    assert(1 == pfs->num_hits);
    return TEST_PASS;
}",248.0,269.0,1.0,1.0,22.0,18,3,17,6,0,6,2,2,0,6,,0,1,2,1,1,enum test_return
931,87263,test_stats_prefix_record_delete,1,test_stats_prefix_record_delete,enum test_return test_stats_prefix_record_delete (void),testapp.c,"static enum test_return test_stats_prefix_record_delete(void) {
    PREFIX_STATS *pfs;
    stats_prefix_clear();

    stats_prefix_record_delete(""abc:123"", 7);
    pfs = stats_prefix_find(""abc:123"", 7);
    if (pfs == NULL) {
        return TEST_FAIL;
    }
    assert(0 == pfs->num_gets);
    assert(0 == pfs->num_hits);
    assert(1 == pfs->num_deletes);
    assert(0 == pfs->num_sets);
    stats_prefix_record_delete(""def:"", 4);
    assert(1 == pfs->num_deletes);
    return TEST_PASS;
}",271.0,287.0,1.0,1.0,17.0,12,3,10,4,0,4,2,2,0,4,,0,1,2,1,1,enum test_return
932,87320,test_stats_prefix_record_set,1,test_stats_prefix_record_set,enum test_return test_stats_prefix_record_set (void),testapp.c,"static enum test_return test_stats_prefix_record_set(void) {
    PREFIX_STATS *pfs;
    stats_prefix_clear();

    stats_prefix_record_set(""abc:123"", 7);
    pfs = stats_prefix_find(""abc:123"", 7);
    if (pfs == NULL) {
        return TEST_FAIL;
    }
    assert(0 == pfs->num_gets);
    assert(0 == pfs->num_hits);
    assert(0 == pfs->num_deletes);
    assert(1 == pfs->num_sets);
    stats_prefix_record_delete(""def:"", 4);
    assert(1 == pfs->num_sets);
    return TEST_PASS;
}",289.0,305.0,1.0,1.0,17.0,12,3,10,4,0,4,2,2,0,4,,0,1,2,1,1,enum test_return
933,87377,test_stats_prefix_dump,1,test_stats_prefix_dump,enum test_return test_stats_prefix_dump (void),testapp.c,"static enum test_return test_stats_prefix_dump(void) {
    int hashval = hash(""abc"", 3) % PREFIX_HASH_SIZE;
    char tmp[500];
    char *buf;
    const char *expected;
    int keynum;
    int length;

    stats_prefix_clear();

    assert(strcmp(""END\r\n"", (buf = stats_prefix_dump(&length))) == 0);
    assert(5 == length);
    stats_prefix_record_set(""abc:123"", 7);
    free(buf);
    expected = ""PREFIX abc get 0 hit 0 set 1 del 0\r\nEND\r\n"";
    assert(strcmp(expected, (buf = stats_prefix_dump(&length))) == 0);
    assert(strlen(expected) == length);
    stats_prefix_record_get(""abc:123"", 7, false);
    free(buf);
    expected = ""PREFIX abc get 1 hit 0 set 1 del 0\r\nEND\r\n"";
    assert(strcmp(expected, (buf = stats_prefix_dump(&length))) == 0);
    assert(strlen(expected) == length);
    stats_prefix_record_get(""abc:123"", 7, true);
    free(buf);
    expected = ""PREFIX abc get 2 hit 1 set 1 del 0\r\nEND\r\n"";
    assert(strcmp(expected, (buf = stats_prefix_dump(&length))) == 0);
...",307.0,374.0,1.0,35.0,68.0,47,9,75,11,0,15,4,4,0,15,,0,7,2,1,1,enum test_return
934,87625,test_safe_strtoul,1,test_safe_strtoul,enum test_return test_safe_strtoul (void),testapp.c,"static enum test_return test_safe_strtoul(void) {
    uint32_t val;
    assert(safe_strtoul(""123"", &val));
    assert(val == 123);
    assert(safe_strtoul(""+123"", &val));
    assert(val == 123);
    assert(!safe_strtoul("""", &val));  // empty
    assert(!safe_strtoul(""123BOGUS"", &val));  // non-numeric
    assert(!safe_strtoul("" issue221"", &val));  // non-numeric
    /* Not sure what it does, but this works with ICC :/
       assert(!safe_strtoul(""92837498237498237498029383"", &val)); // out of range
    */

    // extremes:
    assert(safe_strtoul(""4294967295"", &val)); // 2**32 - 1
    assert(val == 4294967295L);
    /* This actually works on 64-bit ubuntu
       assert(!safe_strtoul(""4294967296"", &val)); // 2**32
    */
    assert(!safe_strtoul(""-1"", &val));  // negative
    return TEST_PASS;
}",376.0,397.0,1.0,1.0,22.0,14,3,11,2,0,7,1,1,0,7,,0,0,2,1,1,enum test_return
935,87684,test_safe_strtoull,1,test_safe_strtoull,enum test_return test_safe_strtoull (void),testapp.c,"static enum test_return test_safe_strtoull(void) {
    uint64_t val;
    assert(safe_strtoull(""123"", &val));
    assert(val == 123);
    assert(safe_strtoull(""+123"", &val));
    assert(val == 123);
    assert(!safe_strtoull("""", &val));  // empty
    assert(!safe_strtoull(""123BOGUS"", &val));  // non-numeric
    assert(!safe_strtoull(""92837498237498237498029383"", &val)); // out of range
    assert(!safe_strtoull("" issue221"", &val));  // non-numeric

    // extremes:
    assert(safe_strtoull(""18446744073709551615"", &val)); // 2**64 - 1
    assert(val == 18446744073709551615ULL);
    assert(!safe_strtoull(""18446744073709551616"", &val)); // 2**64
    assert(!safe_strtoull(""-1"", &val));  // negative
    return TEST_PASS;
}",400.0,417.0,1.0,1.0,18.0,18,3,13,2,0,9,1,1,0,9,,0,0,2,1,1,enum test_return
936,87755,test_safe_strtoll,1,test_safe_strtoll,enum test_return test_safe_strtoll (void),testapp.c,"static enum test_return test_safe_strtoll(void) {
    int64_t val;
    assert(safe_strtoll(""123"", &val));
    assert(val == 123);
    assert(safe_strtoll(""+123"", &val));
    assert(val == 123);
    assert(safe_strtoll(""-123"", &val));
    assert(val == -123);
    assert(!safe_strtoll("""", &val));  // empty
    assert(!safe_strtoll(""123BOGUS"", &val));  // non-numeric
    assert(!safe_strtoll(""92837498237498237498029383"", &val)); // out of range
    assert(!safe_strtoll("" issue221"", &val));  // non-numeric

    // extremes:
    assert(!safe_strtoll(""18446744073709551615"", &val)); // 2**64 - 1
    assert(safe_strtoll(""9223372036854775807"", &val)); // 2**63 - 1
    assert(val == 9223372036854775807LL);
    /*
      assert(safe_strtoll(""-9223372036854775808"", &val)); // -2**63
      assert(val == -9223372036854775808LL);
    */
    assert(!safe_strtoll(""-9223372036854775809"", &val)); // -2**63 - 1

    // We'll allow space to terminate the string.  And leading space.
    assert(safe_strtol...",419.0,446.0,1.0,1.0,28.0,23,4,17,2,0,11,1,1,0,11,,0,0,2,1,1,enum test_return
937,87845,test_safe_strtol,1,test_safe_strtol,enum test_return test_safe_strtol (void),testapp.c,"static enum test_return test_safe_strtol(void) {
    int32_t val;
    assert(safe_strtol(""123"", &val));
    assert(val == 123);
    assert(safe_strtol(""+123"", &val));
    assert(val == 123);
    assert(safe_strtol(""-123"", &val));
    assert(val == -123);
    assert(!safe_strtol("""", &val));  // empty
    assert(!safe_strtol(""123BOGUS"", &val));  // non-numeric
    assert(!safe_strtol(""92837498237498237498029383"", &val)); // out of range
    assert(!safe_strtol("" issue221"", &val));  // non-numeric

    // extremes:
    /* This actually works on 64-bit ubuntu
       assert(!safe_strtol(""2147483648"", &val)); // (expt 2.0 31.0)
    */
    assert(safe_strtol(""2147483647"", &val)); // (- (expt 2.0 31) 1)
    assert(val == 2147483647L);
    /* This actually works on 64-bit ubuntu
       assert(!safe_strtol(""-2147483649"", &val)); // (- (expt -2.0 31) 1)
    */

    // We'll allow space to terminate the string.  And leading space.
    assert(safe_strtol("" 123 foo"", &val));
    assert(val == 123...",448.0,475.0,1.0,1.0,28.0,19,4,15,2,0,9,1,1,0,9,,0,0,2,1,1,enum test_return
938,87923,start_server,1,start_server,"pid_t start_server (in_port_t*,bool,int)",testapp.c,"static pid_t start_server(in_port_t *port_out, bool daemon, int timeout) {
    char environment[80];
    snprintf(environment, sizeof(environment),
             ""MEMCACHED_PORT_FILENAME=/tmp/ports.%lu"", (long)getpid());
    char *filename= environment + strlen(""MEMCACHED_PORT_FILENAME="");
    char pid_file[80];
    snprintf(pid_file, sizeof(pid_file), ""/tmp/pid.%lu"", (long)getpid());

    remove(filename);
    remove(pid_file);

#ifdef __sun
    /* I want to name the corefiles differently so that they don't
       overwrite each other
    */
    char coreadm[128];
    snprintf(coreadm, sizeof(coreadm),
             ""coreadm -p core.%%f.%%p %lu"", (unsigned long)getpid());
    system(coreadm);
#endif

    pid_t pid = fork();
    assert(pid != -1);
    if (pid == 0) {
        /* Child */
        char *argv[24];
        int arg = 0;
        char tmo[24];
        snprintf(tmo, sizeof(tmo), ""%u"", timeout);

        putenv(environment);
#ifdef __sun
        putenv(""LD_PRELOAD=watchmalloc.s...",486.0,622.0,1.0,1.0,137.0,97,19,108,22,3,2,14,21,0,2,,0,0,6,3,3,pid_t
939,88267,test_issue_44,1,test_issue_44,enum test_return test_issue_44 (void),testapp.c,"static enum test_return test_issue_44(void) {
    in_port_t port;
    pid_t pid = start_server(&port, true, 600);
    assert(kill(pid, SIGHUP) == 0);
    sleep(1);
    assert(kill(pid, SIGTERM) == 0);

    return TEST_PASS;
}",624.0,632.0,1.0,1.0,9.0,4,3,8,6,0,1,1,1,0,1,,0,1,2,1,1,enum test_return
940,88297,lookuphost,1,lookuphost,"struct addrinfo lookuphost (char*,in_port_t)",testapp.c,"static struct addrinfo *lookuphost(const char *hostname, in_port_t port)
{
    struct addrinfo *ai = 0;
    struct addrinfo hints = { .ai_family = AF_UNSPEC,
                              .ai_protocol = IPPROTO_TCP,
                              .ai_socktype = SOCK_STREAM };
    char service[NI_MAXSERV];
    int error;

    (void)snprintf(service, NI_MAXSERV, ""%d"", port);
    if ((error = getaddrinfo(hostname, service, &hints, &ai)) != 0) {
       if (error != EAI_SYSTEM) {
          fprintf(stderr, ""getaddrinfo(): %s\n"", gai_strerror(error));
       } else {
          perror(""getaddrinfo()"");
       }
    }

    return ai;
}",634.0,653.0,1.0,1.0,20.0,12,5,21,15,1,0,3,4,0,0,,0,0,4,2,2,struct addrinfo
941,88361,connect_server,1,connect_server,"struct conn connect_server (char*,in_port_t,bool,bool)",testapp.c,"static struct conn *connect_server(const char *hostname, in_port_t port,
                            bool nonblock, const bool ssl)
{
    struct conn *c;
    if (!(c = (struct conn *)calloc(1, sizeof(struct conn)))) {
        fprintf(stderr, ""Failed to allocate the client connection: %s\n"",
                strerror(errno));
        return NULL;
    }

    struct addrinfo *ai = lookuphost(hostname, port);
    int sock = -1;
    if (ai != NULL) {
       if ((sock = socket(ai->ai_family, ai->ai_socktype,
                          ai->ai_protocol)) != -1) {
          if (connect(sock, ai->ai_addr, ai->ai_addrlen) == -1) {
             fprintf(stderr, ""Failed to connect socket: %s\n"",
                     strerror(errno));
             close(sock);
             sock = -1;
          } else if (nonblock) {
              int flags = fcntl(sock, F_GETFL, 0);
              if (flags < 0 || fcntl(sock, F_SETFL, flags | O_NONBLOCK) < 0) {
                  fprintf(stderr, ""Failed to enable nonb...",655.0,727.0,1.0,1.0,73.0,26,8,28,9,9,2,5,8,0,1,,0,2,8,4,4,struct conn
942,88509,test_vperror,1,test_vperror,enum test_return test_vperror (void),testapp.c,"static enum test_return test_vperror(void) {
    int rv = 0;
    int oldstderr = dup(STDERR_FILENO);
    assert(oldstderr >= 0);
    char tmpl[sizeof(TMP_TEMPLATE)+1];
    strncpy(tmpl, TMP_TEMPLATE, sizeof(TMP_TEMPLATE)+1);

    int newfile = mkstemp(tmpl);
    assert(newfile > 0);
    rv = dup2(newfile, STDERR_FILENO);
    assert(rv == STDERR_FILENO);
    rv = close(newfile);
    assert(rv == 0);

    errno = EIO;
    vperror(""Old McDonald had a farm.  %s"", ""EI EIO"");

    /* Restore stderr */
    rv = dup2(oldstderr, STDERR_FILENO);
    assert(rv == STDERR_FILENO);


    /* Go read the file */
    char buf[80] = { 0 };
    FILE *efile = fopen(tmpl, ""r"");
    assert(efile);
    char *prv = fgets(buf, sizeof(buf), efile);
    assert(prv);
    fclose(efile);

    unlink(tmpl);

    char expected[80] = { 0 };
    snprintf(expected, sizeof(expected),
             ""Old McDonald had a farm.  EI EIO: %s\n"", strerror(EIO));

    /*
    fprintf(stderr,
            ""\nExpected:  ``%s''""
   ...",729.0,772.0,1.0,21.0,44.0,24,8,42,13,0,1,1,1,0,1,,0,0,2,1,1,enum test_return
943,88628,send_ascii_command,1,send_ascii_command,void send_ascii_command (char*),testapp.c,"static void send_ascii_command(const char *buf) {
    off_t offset = 0;
    const char* ptr = buf;
    size_t len = strlen(buf);

    do {
        ssize_t nw = con->write((void*)con, ptr + offset, len - offset);
        if (nw == -1) {
            if (errno != EINTR) {
                fprintf(stderr, ""Failed to write: %s\n"", strerror(errno));
                abort();
            }
        } else {
            offset += nw;
        }
    } while (offset < len);
}",774.0,790.0,1.0,1.0,17.0,12,9,19,9,9,3,4,7,0,1,,0,3,2,1,1,void
944,88689,read_ascii_response,1,read_ascii_response,"void read_ascii_response (char*,size_t)",testapp.c,"static void read_ascii_response(char *buffer, size_t size) {
    off_t offset = 0;
    bool need_more = true;
    do {
        ssize_t nr = con->read(con, buffer + offset, 1);
        if (nr == -1) {
            if (errno != EINTR) {
                fprintf(stderr, ""Failed to read: %s\n"", strerror(errno));
                abort();
            }
        } else {
            assert(nr == 1);
            if (buffer[offset] == '\n') {
                need_more = false;
                buffer[offset + 1] = '\0';
            }
            offset += nr;
            assert(offset + 1 < size);
        }
    } while (need_more);
}",798.0,818.0,1.0,1.0,21.0,8,6,14,9,4,3,4,7,0,1,,0,3,4,2,2,void
945,88767,test_issue_92,1,test_issue_92,enum test_return test_issue_92 (void),testapp.c,"static enum test_return test_issue_92(void) {
    char buffer[1024];

    close_conn();
    con = connect_server(""127.0.0.1"", port, false, enable_ssl);
    assert(con);

    send_ascii_command(""stats cachedump 1 0 0\r\n"");

    read_ascii_response(buffer, sizeof(buffer));
    assert(strncmp(buffer, ""END"", strlen(""END"")) == 0);

    send_ascii_command(""stats cachedump 200 0 0\r\n"");
    read_ascii_response(buffer, sizeof(buffer));
    assert(strncmp(buffer, ""CLIENT_ERROR"", strlen(""CLIENT_ERROR"")) == 0);

    close_conn();
    con = connect_server(""127.0.0.1"", port, false, enable_ssl);
    assert(con);
    return TEST_PASS;
}",820.0,840.0,1.0,1.0,21.0,6,3,17,6,0,16,1,1,0,6,,0,10,2,1,1,enum test_return
946,88823,test_crc32c,1,test_crc32c,enum test_return test_crc32c (void),testapp.c,"static enum test_return test_crc32c(void) {
    uint32_t crc_hw, crc_sw;

    char buffer[256];
    for (int x = 0; x < 256; x++)
        buffer[x] = x;

    /* Compare hardware to software implementation */
    crc_hw = crc32c(0, buffer, 256);
    crc_sw = crc32c_sw(0, buffer, 256);
    assert(crc_hw == 0x9c44184b);
    assert(crc_sw == 0x9c44184b);

    /* Test that passing a CRC in also works */
    crc_hw = crc32c(crc_hw, buffer, 256);
    crc_sw = crc32c_sw(crc_sw, buffer, 256);
    assert(crc_hw == 0xae10ee5a);
    assert(crc_sw == 0xae10ee5a);

    /* Test odd offsets/sizes */
    crc_hw = crc32c(crc_hw, buffer + 1, 256 - 2);
    crc_sw = crc32c_sw(crc_sw, buffer + 1, 256 - 2);
    assert(crc_hw == 0xed37b906);
    assert(crc_sw == 0xed37b906);

    return TEST_PASS;
}",842.0,868.0,1.0,1.0,27.0,18,5,25,5,0,3,2,2,0,3,,0,3,2,1,1,enum test_return
947,88917,test_issue_102,1,test_issue_102,enum test_return test_issue_102 (void),testapp.c,"static enum test_return test_issue_102(void) {
    char buffer[4096];
    memset(buffer, ' ', sizeof(buffer));
    buffer[sizeof(buffer) - 1] = '\0';

    close_conn();
    con = connect_server(""127.0.0.1"", port, false, enable_ssl);
    assert(con);

    send_ascii_command(buffer);
    /* verify that the server closed the connection */
    assert(con->read(con, buffer, sizeof(buffer)) == 0);

    close_conn();
    con = connect_server(""127.0.0.1"", port, false, enable_ssl);
    assert(con);

    snprintf(buffer, sizeof(buffer), ""gets "");
    size_t offset = 5;
    while (offset < 4000) {
        offset += snprintf(buffer + offset, sizeof(buffer) - offset,
                           ""%010u "", (unsigned int)offset);
    }

    send_ascii_command(buffer);
    usleep(250);

    send_ascii_command(""\r\n"");
    char rsp[80];
    read_ascii_response(rsp, sizeof(rsp));
    assert(strncmp(rsp, ""END"", strlen(""END"")) == 0);
    buffer[3]= ' ';
    send_ascii_command(buffer);
    usleep(250);
  ...",870.0,921.0,1.0,1.0,52.0,40,10,58,9,0,32,2,2,0,13,,0,19,2,1,1,enum test_return
948,89096,start_memcached_server,1,start_memcached_server,enum test_return start_memcached_server (void),testapp.c,"static enum test_return start_memcached_server(void) {
    server_pid = start_server(&port, false, 600);
    close_conn();
    con = connect_server(""127.0.0.1"", port, false, enable_ssl);
    assert(con);
    return TEST_PASS;
}",923.0,929.0,1.0,1.0,7.0,3,2,9,6,0,9,1,1,0,2,,0,8,2,1,1,enum test_return
949,89120,stop_memcached_server,1,stop_memcached_server,enum test_return stop_memcached_server (void),testapp.c,"static enum test_return stop_memcached_server(void) {
    close_conn();
    if (server_pid != -1) {
        assert(kill(server_pid, SIGTERM) == 0);
    }

    return TEST_PASS;
}",931.0,938.0,1.0,1.0,8.0,3,3,4,3,0,3,2,2,1,0,,0,2,2,1,1,enum test_return
950,89140,shutdown_memcached_server,1,shutdown_memcached_server,enum test_return shutdown_memcached_server (void),testapp.c,"static enum test_return shutdown_memcached_server(void) {
    char buffer[1024];

    close_conn();
    con = connect_server(""127.0.0.1"", port, false, enable_ssl);
    assert(con);

    send_ascii_command(""shutdown\r\n"");
    /* verify that the server closed the connection */
    assert(con->read(con, buffer, sizeof(buffer)) == 0);

    close_conn();

    /* We set server_pid to -1 so that we don't later call kill() */
    if (kill(server_pid, 0) == 0) {
        server_pid = -1;
    }

    return TEST_PASS;
}",940.0,959.0,1.0,1.0,20.0,7,5,12,7,0,13,2,2,1,3,,0,9,2,1,1,enum test_return
951,89183,safe_send,1,safe_send,"void safe_send (void*,size_t,bool)",testapp.c,"static void safe_send(const void* buf, size_t len, bool hickup)
{
    off_t offset = 0;
    const char* ptr = buf;
#ifdef MESSAGE_DEBUG
    uint8_t val = *ptr;
    assert(val == (uint8_t)0x80);
    fprintf(stderr, ""About to send %lu bytes:"", (unsigned long)len);
    for (int ii = 0; ii < len; ++ii) {
        if (ii % 4 == 0) {
            fprintf(stderr, ""\n   "");
        }
        val = *(ptr + ii);
        fprintf(stderr, "" 0x%02x"", val);
    }
    fprintf(stderr, ""\n"");
    usleep(500);
#endif

    do {
        size_t num_bytes = len - offset;
        if (hickup) {
            if (num_bytes > 1024) {
                num_bytes = (rand() % 1023) + 1;
            }
        }
        ssize_t nw = con->write(con, ptr + offset, num_bytes);
        if (nw == -1) {
            if (errno != EINTR) {
                fprintf(stderr, ""Failed to write: %s\n"", strerror(errno));
                abort();
            }
        } else {
            if (hickup) {
                usleep(100);
      ...",961.0,1000.0,1.0,1.0,40.0,15,10,22,11,35,3,6,12,0,1,,0,3,6,3,3,void
952,89263,safe_recv,1,safe_recv,"bool safe_recv (void*,size_t)",testapp.c,"static bool safe_recv(void *buf, size_t len) {
    if (len == 0) {
        return true;
    }
    off_t offset = 0;
    do {
        ssize_t nr = con->read(con, ((char*)buf) + offset, len - offset);
        if (nr == -1) {
            if (errno != EINTR) {
                fprintf(stderr, ""Failed to read: %s\n"", strerror(errno));
                abort();
            }
        } else {
            if (nr == 0 && allow_closed_read) {
                return false;
            }
            assert(nr != 0);
            offset += nr;
        }
    } while (offset < len);

    return true;
}",1002.0,1024.0,1.0,1.0,23.0,11,9,18,9,2,3,5,8,0,1,,0,3,4,2,2,bool
953,89338,safe_recv_packet,1,safe_recv_packet,"bool safe_recv_packet (void*,size_t)",testapp.c,"static bool safe_recv_packet(void *buf, size_t size) {
    protocol_binary_response_no_extras *response = buf;
    assert(size > sizeof(*response));
    if (!safe_recv(response, sizeof(*response))) {
        return false;
    }
    response->message.header.response.keylen = ntohs(response->message.header.response.keylen);
    response->message.header.response.status = ntohs(response->message.header.response.status);
    response->message.header.response.bodylen = ntohl(response->message.header.response.bodylen);

    size_t len = sizeof(*response);

    char *ptr = buf;
    ptr += len;
    if (!safe_recv(ptr, response->message.header.response.bodylen)) {
        return false;
    }

#ifdef MESSAGE_DEBUG
    usleep(500);
    ptr = buf;
    len += response->message.header.response.bodylen;
    uint8_t val = *ptr;
    assert(val == (uint8_t)0x81);
    fprintf(stderr, ""Received %lu bytes:"", (unsigned long)len);
    for (int ii = 0; ii < len; ++ii) {
        if (ii % 4 == 0) {
          ...",1026.0,1061.0,1.0,1.0,36.0,44,8,23,7,35,2,3,3,2,2,,0,2,4,2,2,bool
954,89455,storage_command,1,storage_command,"off_t storage_command (char*,size_t,uint8_t,void*,size_t,void*,size_t,uint32_t,uint32_t)",testapp.c,"static off_t storage_command(char*buf,
                             size_t bufsz,
                             uint8_t cmd,
                             const void* key,
                             size_t keylen,
                             const void* dta,
                             size_t dtalen,
                             uint32_t flags,
                             uint32_t exp) {
    /* all of the storage commands use the same command layout */
    protocol_binary_request_set *request = (void*)buf;
    assert(bufsz > sizeof(*request) + keylen + dtalen);

    memset(request, 0, sizeof(*request));
    request->message.header.request.magic = PROTOCOL_BINARY_REQ;
    request->message.header.request.opcode = cmd;
    request->message.header.request.keylen = htons(keylen);
    request->message.header.request.extlen = 8;
    request->message.header.request.bodylen = htonl(keylen + 8 + dtalen);
    request->message.header.request.opaque = 0xdeadbeef;
    request->message.body.fla...",1063.0,1094.0,1.0,1.0,32.0,58,9,39,14,12,8,2,2,0,0,,0,8,18,9,9,off_t
955,89612,ext_command,1,ext_command,"off_t ext_command (char*,size_t,uint8_t,void*,size_t,void*,size_t,void*,size_t)",testapp.c,"static off_t ext_command(char* buf,
                         size_t bufsz,
                         uint8_t cmd,
                         const void* ext,
                         size_t extlen,
                         const void* key,
                         size_t keylen,
                         const void* dta,
                         size_t dtalen) {
    protocol_binary_request_no_extras *request = (void*)buf;
    assert(bufsz > sizeof(*request) + extlen + keylen + dtalen);

    memset(request, 0, sizeof(*request));
    request->message.header.request.magic = PROTOCOL_BINARY_REQ;
    request->message.header.request.opcode = cmd;
    request->message.header.request.extlen = extlen;
    request->message.header.request.keylen = htons(keylen);
    request->message.header.request.bodylen = htonl(extlen + keylen + dtalen);
    request->message.header.request.opaque = 0xdeadbeef;

    off_t ext_offset = sizeof(protocol_binary_request_no_extras);
    off_t key_offset = ext_offset + ...",1096.0,1131.0,1.0,1.0,36.0,59,9,52,16,5,0,4,4,0,0,,0,0,18,9,9,off_t
956,89781,raw_command,1,raw_command,"off_t raw_command (char*,size_t,uint8_t,void*,size_t,void*,size_t)",testapp.c,"static off_t raw_command(char* buf,
                         size_t bufsz,
                         uint8_t cmd,
                         const void* key,
                         size_t keylen,
                         const void* dta,
                         size_t dtalen) {
    /* all of the storage commands use the same command layout */
    return ext_command(buf, bufsz, cmd, NULL, 0, key, keylen, dta, dtalen);
}",1133.0,1142.0,1.0,1.0,10.0,0,0,8,8,21,1,1,1,0,1,,0,0,14,7,7,off_t
957,89803,flush_command,1,flush_command,"off_t flush_command (char*,size_t,uint8_t,uint32_t,bool)",testapp.c,"static off_t flush_command(char* buf, size_t bufsz, uint8_t cmd, uint32_t exptime, bool use_extra) {
    protocol_binary_request_flush *request = (void*)buf;
    assert(bufsz > sizeof(*request));

    memset(request, 0, sizeof(*request));
    request->message.header.request.magic = PROTOCOL_BINARY_REQ;
    request->message.header.request.opcode = cmd;

    off_t size = sizeof(protocol_binary_request_no_extras);
    if (use_extra) {
        request->message.header.request.extlen = 4;
        request->message.body.expiration = htonl(exptime);
        request->message.header.request.bodylen = htonl(4);
        size += 4;
    }

    request->message.header.request.opaque = 0xdeadbeef;

    return size;
}",1144.0,1163.0,1.0,1.0,20.0,39,8,20,9,2,0,2,2,0,0,,0,0,10,5,5,off_t
958,89909,touch_command,1,touch_command,"off_t touch_command (char*,size_t,uint8_t,void*,size_t,uint32_t)",testapp.c,"static off_t touch_command(char* buf,
                           size_t bufsz,
                           uint8_t cmd,
                           const void* key,
                           size_t keylen,
                           uint32_t exptime) {
    protocol_binary_request_touch *request = (void*)buf;
    assert(bufsz > sizeof(*request));

    memset(request, 0, sizeof(*request));
    request->message.header.request.magic = PROTOCOL_BINARY_REQ;
    request->message.header.request.opcode = cmd;

    request->message.header.request.keylen = htons(keylen);
    request->message.header.request.extlen = 4;
    request->message.body.expiration = htonl(exptime);
    request->message.header.request.bodylen = htonl(keylen + 4);

    request->message.header.request.opaque = 0xdeadbeef;

    off_t key_offset = sizeof(protocol_binary_request_no_extras) + 4;

    memcpy(buf + key_offset, key, keylen);
    return sizeof(protocol_binary_request_no_extras) + 4 + keylen;
}",1166.0,1190.0,1.0,1.0,25.0,49,8,26,10,1,0,1,1,0,0,,0,0,12,6,6,off_t
959,90037,arithmetic_command,1,arithmetic_command,"off_t arithmetic_command (char*,size_t,uint8_t,void*,size_t,uint64_t,uint64_t,uint32_t)",testapp.c,"static off_t arithmetic_command(char* buf,
                                size_t bufsz,
                                uint8_t cmd,
                                const void* key,
                                size_t keylen,
                                uint64_t delta,
                                uint64_t initial,
                                uint32_t exp) {
    protocol_binary_request_incr *request = (void*)buf;
    assert(bufsz > sizeof(*request) + keylen);

    memset(request, 0, sizeof(*request));
    request->message.header.request.magic = PROTOCOL_BINARY_REQ;
    request->message.header.request.opcode = cmd;
    request->message.header.request.keylen = htons(keylen);
    request->message.header.request.extlen = 20;
    request->message.header.request.bodylen = htonl(keylen + 20);
    request->message.header.request.opaque = 0xdeadbeef;
    request->message.body.delta = htonll(delta);
    request->message.body.initial = htonll(initial);
    request->message.body....",1192.0,1218.0,1.0,1.0,27.0,56,8,31,12,3,2,1,1,0,2,,0,2,16,8,8,off_t
960,90186,validate_response_header,1,validate_response_header,"void validate_response_header (protocol_binary_response_no_extras*,uint8_t,uint16_t)",testapp.c,"static void validate_response_header(protocol_binary_response_no_extras *response,
                                     uint8_t cmd, uint16_t status)
{
    assert(response->message.header.response.magic == PROTOCOL_BINARY_RES);
    assert(response->message.header.response.opcode == cmd);
    assert(response->message.header.response.datatype == PROTOCOL_BINARY_RAW_BYTES);
    assert(response->message.header.response.status == status);
    assert(response->message.header.response.opaque == 0xdeadbeef);

    if (status == PROTOCOL_BINARY_RESPONSE_SUCCESS) {
        switch (cmd) {
        case PROTOCOL_BINARY_CMD_ADDQ:
        case PROTOCOL_BINARY_CMD_APPENDQ:
        case PROTOCOL_BINARY_CMD_DECREMENTQ:
        case PROTOCOL_BINARY_CMD_DELETEQ:
        case PROTOCOL_BINARY_CMD_FLUSHQ:
        case PROTOCOL_BINARY_CMD_INCREMENTQ:
        case PROTOCOL_BINARY_CMD_PREPENDQ:
        case PROTOCOL_BINARY_CMD_QUITQ:
        case PROTOCOL_BINARY_CMD_REPLACEQ:
        case PROTOCOL_BINARY_CMD_...",1220.0,1318.0,1.0,1.0,99.0,147,4,69,38,35,0,13,6,0,0,,0,0,6,3,3,void
961,90676,test_binary_noop,1,test_binary_noop,enum test_return test_binary_noop (void),testapp.c,"static enum test_return test_binary_noop(void) {
    union {
        protocol_binary_request_no_extras request;
        protocol_binary_response_no_extras response;
        char bytes[1024];
    } buffer;

    size_t len = raw_command(buffer.bytes, sizeof(buffer.bytes),
                             PROTOCOL_BINARY_CMD_NOOP,
                             NULL, 0, NULL, 0);

    safe_send(buffer.bytes, len, false);
    safe_recv_packet(buffer.bytes, sizeof(buffer.bytes));
    validate_response_header(&buffer.response, PROTOCOL_BINARY_CMD_NOOP,
                             PROTOCOL_BINARY_RESPONSE_SUCCESS);

    return TEST_PASS;
}",1320.0,1337.0,1.0,1.0,18.0,10,4,15,7,3,4,1,1,0,4,,0,1,2,1,1,enum test_return
962,90721,test_binary_quit_impl,1,test_binary_quit_impl,enum test_return test_binary_quit_impl (uint8_t),testapp.c,"static enum test_return test_binary_quit_impl(uint8_t cmd) {
    union {
        protocol_binary_request_no_extras request;
        protocol_binary_response_no_extras response;
        char bytes[1024];
    } buffer;
    size_t len = raw_command(buffer.bytes, sizeof(buffer.bytes),
                             cmd, NULL, 0, NULL, 0);

    safe_send(buffer.bytes, len, false);
    if (cmd == PROTOCOL_BINARY_CMD_QUIT) {
        safe_recv_packet(buffer.bytes, sizeof(buffer.bytes));
        validate_response_header(&buffer.response, PROTOCOL_BINARY_CMD_QUIT,
                                 PROTOCOL_BINARY_RESPONSE_SUCCESS);
    }

    /* Socket should be closed now, read should return 0 */
    assert(con->read(con, buffer.bytes, sizeof(buffer.bytes)) == 0);
    close_conn();
    con = connect_server(""127.0.0.1"", port, false, enable_ssl);
    assert(con);

    return TEST_PASS;
}",1339.0,1362.0,1.0,1.0,24.0,17,6,26,11,2,13,2,2,0,6,,0,8,2,1,1,enum test_return
963,90796,test_binary_quit,1,test_binary_quit,enum test_return test_binary_quit (void),testapp.c,"static enum test_return test_binary_quit(void) {
    return test_binary_quit_impl(PROTOCOL_BINARY_CMD_QUIT);
}",1364.0,1366.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,enum test_return
964,90804,test_binary_quitq,1,test_binary_quitq,enum test_return test_binary_quitq (void),testapp.c,"static enum test_return test_binary_quitq(void) {
    return test_binary_quit_impl(PROTOCOL_BINARY_CMD_QUITQ);
}",1368.0,1370.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,enum test_return
965,90812,test_binary_set_impl,1,test_binary_set_impl,"enum test_return test_binary_set_impl (char*,uint8_t)",testapp.c,"static enum test_return test_binary_set_impl(const char *key, uint8_t cmd) {
    union {
        protocol_binary_request_no_extras request;
        protocol_binary_response_no_extras response;
        char bytes[1024];
    } send, receive;
    uint64_t value = 0xdeadbeefdeadcafe;
    size_t len = storage_command(send.bytes, sizeof(send.bytes), cmd,
                                 key, strlen(key), &value, sizeof(value),
                                 0, 0);

    /* Set should work over and over again */
    int ii;
    for (ii = 0; ii < 10; ++ii) {
        safe_send(send.bytes, len, false);
        if (cmd == PROTOCOL_BINARY_CMD_SET) {
            safe_recv_packet(receive.bytes, sizeof(receive.bytes));
            validate_response_header(&receive.response, cmd,
                                     PROTOCOL_BINARY_RESPONSE_SUCCESS);
        }
    }

    if (cmd == PROTOCOL_BINARY_CMD_SETQ) {
        return test_binary_noop();
    }

    send.request.message.header.request.cas = r...",1372.0,1410.0,1.0,1.0,39.0,46,7,38,12,2,8,5,6,0,8,,0,1,4,2,2,enum test_return
966,90969,test_binary_set,1,test_binary_set,enum test_return test_binary_set (void),testapp.c,"static enum test_return test_binary_set(void) {
    return test_binary_set_impl(""test_binary_set"", PROTOCOL_BINARY_CMD_SET);
}",1412.0,1414.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,enum test_return
967,90978,test_binary_setq,1,test_binary_setq,enum test_return test_binary_setq (void),testapp.c,"static enum test_return test_binary_setq(void) {
    return test_binary_set_impl(""test_binary_setq"", PROTOCOL_BINARY_CMD_SETQ);
}",1416.0,1418.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,enum test_return
968,90987,test_binary_add_impl,1,test_binary_add_impl,"enum test_return test_binary_add_impl (char*,uint8_t)",testapp.c,"static enum test_return test_binary_add_impl(const char *key, uint8_t cmd) {
    uint64_t value = 0xdeadbeefdeadcafe;
    union {
        protocol_binary_request_no_extras request;
        protocol_binary_response_no_extras response;
        char bytes[1024];
    } send, receive;
    size_t len = storage_command(send.bytes, sizeof(send.bytes), cmd, key,
                                 strlen(key), &value, sizeof(value),
                                 0, 0);

    /* Add should only work the first time */
    int ii;
    for (ii = 0; ii < 10; ++ii) {
        safe_send(send.bytes, len, false);
        if (ii == 0) {
            if (cmd == PROTOCOL_BINARY_CMD_ADD) {
                safe_recv_packet(receive.bytes, sizeof(receive.bytes));
                validate_response_header(&receive.response, cmd,
                                         PROTOCOL_BINARY_RESPONSE_SUCCESS);
            }
        } else {
            safe_recv_packet(receive.bytes, sizeof(receive.bytes));
           ...",1421.0,1450.0,1.0,1.0,30.0,17,6,23,11,2,4,4,7,0,4,,0,1,4,2,2,enum test_return
969,91082,test_binary_add,1,test_binary_add,enum test_return test_binary_add (void),testapp.c,"static enum test_return test_binary_add(void) {
    return test_binary_add_impl(""test_binary_add"", PROTOCOL_BINARY_CMD_ADD);
}",1452.0,1454.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,enum test_return
970,91091,test_binary_addq,1,test_binary_addq,enum test_return test_binary_addq (void),testapp.c,"static enum test_return test_binary_addq(void) {
    return test_binary_add_impl(""test_binary_addq"", PROTOCOL_BINARY_CMD_ADDQ);
}",1456.0,1458.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,enum test_return
971,91100,test_binary_replace_impl,1,test_binary_replace_impl,"enum test_return test_binary_replace_impl (char*,uint8_t)",testapp.c,"static enum test_return test_binary_replace_impl(const char* key, uint8_t cmd) {
    uint64_t value = 0xdeadbeefdeadcafe;
    union {
        protocol_binary_request_no_extras request;
        protocol_binary_response_no_extras response;
        char bytes[1024];
    } send, receive;
    size_t len = storage_command(send.bytes, sizeof(send.bytes), cmd,
                                 key, strlen(key), &value, sizeof(value),
                                 0, 0);
    safe_send(send.bytes, len, false);
    safe_recv_packet(receive.bytes, sizeof(receive.bytes));
    validate_response_header(&receive.response, cmd,
                             PROTOCOL_BINARY_RESPONSE_KEY_ENOENT);
    len = storage_command(send.bytes, sizeof(send.bytes),
                          PROTOCOL_BINARY_CMD_ADD,
                          key, strlen(key), &value, sizeof(value), 0, 0);
    safe_send(send.bytes, len, false);
    safe_recv_packet(receive.bytes, sizeof(receive.bytes));
    validate_response_heade...",1460.0,1500.0,1.0,1.0,41.0,41,6,56,14,2,13,4,5,0,13,,0,3,4,2,2,enum test_return
972,91261,test_binary_replace,1,test_binary_replace,enum test_return test_binary_replace (void),testapp.c,"static enum test_return test_binary_replace(void) {
    return test_binary_replace_impl(""test_binary_replace"",
                                    PROTOCOL_BINARY_CMD_REPLACE);
}",1502.0,1505.0,1.0,1.0,4.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,enum test_return
973,91270,test_binary_replaceq,1,test_binary_replaceq,enum test_return test_binary_replaceq (void),testapp.c,"static enum test_return test_binary_replaceq(void) {
    return test_binary_replace_impl(""test_binary_replaceq"",
                                    PROTOCOL_BINARY_CMD_REPLACEQ);
}",1507.0,1510.0,1.0,1.0,4.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,enum test_return
974,91279,test_binary_delete_impl,1,test_binary_delete_impl,"enum test_return test_binary_delete_impl (char*,uint8_t)",testapp.c,"static enum test_return test_binary_delete_impl(const char *key, uint8_t cmd) {
    union {
        protocol_binary_request_no_extras request;
        protocol_binary_response_no_extras response;
        char bytes[1024];
    } send, receive;
    size_t len = raw_command(send.bytes, sizeof(send.bytes), cmd,
                             key, strlen(key), NULL, 0);

    safe_send(send.bytes, len, false);
    safe_recv_packet(receive.bytes, sizeof(receive.bytes));
    validate_response_header(&receive.response, cmd,
                             PROTOCOL_BINARY_RESPONSE_KEY_ENOENT);
    len = storage_command(send.bytes, sizeof(send.bytes),
                          PROTOCOL_BINARY_CMD_ADD,
                          key, strlen(key), NULL, 0, 0, 0);
    safe_send(send.bytes, len, false);
    safe_recv_packet(receive.bytes, sizeof(receive.bytes));
    validate_response_header(&receive.response, PROTOCOL_BINARY_CMD_ADD,
                             PROTOCOL_BINARY_RESPONSE_SUCCESS);

    l...",1512.0,1549.0,1.0,1.0,38.0,37,5,56,12,2,15,2,2,0,15,,0,3,4,2,2,enum test_return
975,91429,test_binary_delete,1,test_binary_delete,enum test_return test_binary_delete (void),testapp.c,"static enum test_return test_binary_delete(void) {
    return test_binary_delete_impl(""test_binary_delete"",
                                   PROTOCOL_BINARY_CMD_DELETE);
}",1551.0,1554.0,1.0,1.0,4.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,enum test_return
976,91438,test_binary_deleteq,1,test_binary_deleteq,enum test_return test_binary_deleteq (void),testapp.c,"static enum test_return test_binary_deleteq(void) {
    return test_binary_delete_impl(""test_binary_deleteq"",
                                   PROTOCOL_BINARY_CMD_DELETEQ);
}",1556.0,1559.0,1.0,1.0,4.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,enum test_return
977,91447,test_binary_get_impl,1,test_binary_get_impl,"enum test_return test_binary_get_impl (char*,uint8_t)",testapp.c,"static enum test_return test_binary_get_impl(const char *key, uint8_t cmd) {
    union {
        protocol_binary_request_no_extras request;
        protocol_binary_response_no_extras response;
        char bytes[1024];
    } send, receive;

    uint32_t expiration = htonl(3600);
    size_t extlen = 0;
    if (cmd == PROTOCOL_BINARY_CMD_GAT || cmd == PROTOCOL_BINARY_CMD_GATK)
        extlen = sizeof(expiration);

    size_t len = ext_command(send.bytes, sizeof(send.bytes), cmd,
                             extlen ? &expiration : NULL, extlen,
                             key, strlen(key), NULL, 0);

    safe_send(send.bytes, len, false);
    safe_recv_packet(receive.bytes, sizeof(receive.bytes));
    validate_response_header(&receive.response, cmd,
                             PROTOCOL_BINARY_RESPONSE_KEY_ENOENT);

    len = storage_command(send.bytes, sizeof(send.bytes),
                          PROTOCOL_BINARY_CMD_ADD,
                          key, strlen(key), NULL, 0,
         ...",1561.0,1614.0,1.0,1.0,54.0,50,10,73,18,4,12,4,4,0,12,,0,3,4,2,2,enum test_return
978,91646,test_binary_get,1,test_binary_get,enum test_return test_binary_get (void),testapp.c,"static enum test_return test_binary_get(void) {
    return test_binary_get_impl(""test_binary_get"", PROTOCOL_BINARY_CMD_GET);
}",1616.0,1618.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,enum test_return
979,91655,test_binary_getk,1,test_binary_getk,enum test_return test_binary_getk (void),testapp.c,"static enum test_return test_binary_getk(void) {
    return test_binary_get_impl(""test_binary_getk"", PROTOCOL_BINARY_CMD_GETK);
}",1620.0,1622.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,enum test_return
980,91664,test_binary_gat,1,test_binary_gat,enum test_return test_binary_gat (void),testapp.c,"static enum test_return test_binary_gat(void) {
    return test_binary_get_impl(""test_binary_gat"", PROTOCOL_BINARY_CMD_GAT);
}",1624.0,1626.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,enum test_return
981,91673,test_binary_gatk,1,test_binary_gatk,enum test_return test_binary_gatk (void),testapp.c,"static enum test_return test_binary_gatk(void) {
    return test_binary_get_impl(""test_binary_gatk"", PROTOCOL_BINARY_CMD_GATK);
}",1628.0,1630.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,enum test_return
982,91682,test_binary_getq_impl,1,test_binary_getq_impl,"enum test_return test_binary_getq_impl (char*,uint8_t)",testapp.c,"static enum test_return test_binary_getq_impl(const char *key, uint8_t cmd) {
    const char *missing = ""test_binary_getq_missing"";
    union {
        protocol_binary_request_no_extras request;
        protocol_binary_response_no_extras response;
        char bytes[1024];
    } send, temp, receive;

    uint32_t expiration = htonl(3600);
    size_t extlen = 0;
    if (cmd == PROTOCOL_BINARY_CMD_GATQ || cmd == PROTOCOL_BINARY_CMD_GATKQ)
        extlen = sizeof(expiration);

    size_t len = storage_command(send.bytes, sizeof(send.bytes),
                                 PROTOCOL_BINARY_CMD_ADD,
                                 key, strlen(key), NULL, 0,
                                 0, 0);
    size_t len2 = ext_command(temp.bytes, sizeof(temp.bytes), cmd,
                              extlen ? &expiration : NULL, extlen,
                              missing, strlen(missing), NULL, 0);
    /* I need to change the first opaque so that I can separate the two
     * return packets *...",1632.0,1674.0,1.0,1.0,43.0,49,9,65,17,4,8,2,2,0,8,,0,3,4,2,2,enum test_return
983,91858,test_binary_getq,1,test_binary_getq,enum test_return test_binary_getq (void),testapp.c,"static enum test_return test_binary_getq(void) {
    return test_binary_getq_impl(""test_binary_getq"", PROTOCOL_BINARY_CMD_GETQ);
}",1676.0,1678.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,enum test_return
984,91867,test_binary_getkq,1,test_binary_getkq,enum test_return test_binary_getkq (void),testapp.c,"static enum test_return test_binary_getkq(void) {
    return test_binary_getq_impl(""test_binary_getkq"", PROTOCOL_BINARY_CMD_GETKQ);
}",1680.0,1682.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,enum test_return
985,91876,test_binary_gatq,1,test_binary_gatq,enum test_return test_binary_gatq (void),testapp.c,"static enum test_return test_binary_gatq(void) {
    return test_binary_getq_impl(""test_binary_gatq"", PROTOCOL_BINARY_CMD_GATQ);
}",1684.0,1686.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,enum test_return
986,91885,test_binary_gatkq,1,test_binary_gatkq,enum test_return test_binary_gatkq (void),testapp.c,"static enum test_return test_binary_gatkq(void) {
    return test_binary_getq_impl(""test_binary_gatkq"", PROTOCOL_BINARY_CMD_GATKQ);
}",1688.0,1690.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,enum test_return
987,91894,test_binary_incr_impl,1,test_binary_incr_impl,"enum test_return test_binary_incr_impl (char*,uint8_t)",testapp.c,"static enum test_return test_binary_incr_impl(const char* key, uint8_t cmd) {
    union {
        protocol_binary_request_no_extras request;
        protocol_binary_response_no_extras response_header;
        protocol_binary_response_incr response;
        char bytes[1024];
    } send, receive;
    size_t len = arithmetic_command(send.bytes, sizeof(send.bytes), cmd,
                                    key, strlen(key), 1, 0, 0);

    int ii;
    for (ii = 0; ii < 10; ++ii) {
        safe_send(send.bytes, len, false);
        if (cmd == PROTOCOL_BINARY_CMD_INCREMENT) {
            safe_recv_packet(receive.bytes, sizeof(receive.bytes));
            validate_response_header(&receive.response_header, cmd,
                                     PROTOCOL_BINARY_RESPONSE_SUCCESS);
            assert(ntohll(receive.response.message.body.value) == ii);
        }
    }

    if (cmd == PROTOCOL_BINARY_CMD_INCREMENTQ) {
        test_binary_noop();
    }
    return TEST_PASS;
}",1692.0,1717.0,1.0,1.0,26.0,19,6,23,11,2,6,4,5,0,6,,0,1,4,2,2,enum test_return
988,91979,test_binary_incr,1,test_binary_incr,enum test_return test_binary_incr (void),testapp.c,"static enum test_return test_binary_incr(void) {
    return test_binary_incr_impl(""test_binary_incr"",
                                 PROTOCOL_BINARY_CMD_INCREMENT);
}",1719.0,1722.0,1.0,1.0,4.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,enum test_return
989,91988,test_binary_incrq,1,test_binary_incrq,enum test_return test_binary_incrq (void),testapp.c,"static enum test_return test_binary_incrq(void) {
    return test_binary_incr_impl(""test_binary_incrq"",
                                 PROTOCOL_BINARY_CMD_INCREMENTQ);
}",1724.0,1727.0,1.0,1.0,4.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,enum test_return
990,91997,test_binary_decr_impl,1,test_binary_decr_impl,"enum test_return test_binary_decr_impl (char*,uint8_t)",testapp.c,"static enum test_return test_binary_decr_impl(const char* key, uint8_t cmd) {
    union {
        protocol_binary_request_no_extras request;
        protocol_binary_response_no_extras response_header;
        protocol_binary_response_decr response;
        char bytes[1024];
    } send, receive;
    size_t len = arithmetic_command(send.bytes, sizeof(send.bytes), cmd,
                                    key, strlen(key), 1, 9, 0);

    int ii;
    for (ii = 9; ii >= 0; --ii) {
        safe_send(send.bytes, len, false);
        if (cmd == PROTOCOL_BINARY_CMD_DECREMENT) {
            safe_recv_packet(receive.bytes, sizeof(receive.bytes));
            validate_response_header(&receive.response_header, cmd,
                                     PROTOCOL_BINARY_RESPONSE_SUCCESS);
            assert(ntohll(receive.response.message.body.value) == ii);
        }
    }

    /* decr on 0 should not wrap */
    safe_send(send.bytes, len, false);
    if (cmd == PROTOCOL_BINARY_CMD_DECREMENT) {
   ...",1729.0,1762.0,1.0,1.0,34.0,30,6,32,10,2,9,4,5,0,9,,0,1,4,2,2,enum test_return
991,92118,test_binary_decr,1,test_binary_decr,enum test_return test_binary_decr (void),testapp.c,"static enum test_return test_binary_decr(void) {
    return test_binary_decr_impl(""test_binary_decr"",
                                 PROTOCOL_BINARY_CMD_DECREMENT);
}",1764.0,1767.0,1.0,1.0,4.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,enum test_return
992,92127,test_binary_decrq,1,test_binary_decrq,enum test_return test_binary_decrq (void),testapp.c,"static enum test_return test_binary_decrq(void) {
    return test_binary_decr_impl(""test_binary_decrq"",
                                 PROTOCOL_BINARY_CMD_DECREMENTQ);
}",1769.0,1772.0,1.0,1.0,4.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,enum test_return
993,92136,test_binary_version,1,test_binary_version,enum test_return test_binary_version (void),testapp.c,"static enum test_return test_binary_version(void) {
    union {
        protocol_binary_request_no_extras request;
        protocol_binary_response_no_extras response;
        char bytes[1024];
    } buffer;

    size_t len = raw_command(buffer.bytes, sizeof(buffer.bytes),
                             PROTOCOL_BINARY_CMD_VERSION,
                             NULL, 0, NULL, 0);

    safe_send(buffer.bytes, len, false);
    safe_recv_packet(buffer.bytes, sizeof(buffer.bytes));
    validate_response_header(&buffer.response, PROTOCOL_BINARY_CMD_VERSION,
                             PROTOCOL_BINARY_RESPONSE_SUCCESS);

    return TEST_PASS;
}",1774.0,1791.0,1.0,1.0,18.0,10,4,15,7,0,4,1,1,0,4,,0,1,2,1,1,enum test_return
994,92181,test_binary_flush_impl,1,test_binary_flush_impl,"enum test_return test_binary_flush_impl (char*,uint8_t)",testapp.c,"static enum test_return test_binary_flush_impl(const char *key, uint8_t cmd) {
    union {
        protocol_binary_request_no_extras request;
        protocol_binary_response_no_extras response;
        char bytes[1024];
    } send, receive;

    size_t len = storage_command(send.bytes, sizeof(send.bytes),
                                 PROTOCOL_BINARY_CMD_ADD,
                                 key, strlen(key), NULL, 0, 0, 0);
    safe_send(send.bytes, len, false);
    safe_recv_packet(receive.bytes, sizeof(receive.bytes));
    validate_response_header(&receive.response, PROTOCOL_BINARY_CMD_ADD,
                             PROTOCOL_BINARY_RESPONSE_SUCCESS);

    len = flush_command(send.bytes, sizeof(send.bytes), cmd, 2, true);
    safe_send(send.bytes, len, false);
    if (cmd == PROTOCOL_BINARY_CMD_FLUSH) {
        safe_recv_packet(receive.bytes, sizeof(receive.bytes));
        validate_response_header(&receive.response, cmd,
                                 PROTOCOL_BINARY_RES...",1793.0,1857.0,1.0,1.0,65.0,71,6,101,15,2,27,4,5,0,27,,0,6,4,2,2,enum test_return
995,92459,test_binary_flush,1,test_binary_flush,enum test_return test_binary_flush (void),testapp.c,"static enum test_return test_binary_flush(void) {
    return test_binary_flush_impl(""test_binary_flush"",
                                  PROTOCOL_BINARY_CMD_FLUSH);
}",1859.0,1862.0,1.0,1.0,4.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,enum test_return
996,92468,test_binary_flushq,1,test_binary_flushq,enum test_return test_binary_flushq (void),testapp.c,"static enum test_return test_binary_flushq(void) {
    return test_binary_flush_impl(""test_binary_flushq"",
                                  PROTOCOL_BINARY_CMD_FLUSHQ);
}",1864.0,1867.0,1.0,1.0,4.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,enum test_return
997,92477,test_binary_concat_impl,1,test_binary_concat_impl,"enum test_return test_binary_concat_impl (char*,uint8_t)",testapp.c,"static enum test_return test_binary_concat_impl(const char *key, uint8_t cmd) {
    union {
        protocol_binary_request_no_extras request;
        protocol_binary_response_no_extras response;
        char bytes[1024];
    } send, receive;
    const char *value = ""world"";

    size_t len = raw_command(send.bytes, sizeof(send.bytes), cmd,
                              key, strlen(key), value, strlen(value));


    safe_send(send.bytes, len, false);
    safe_recv_packet(receive.bytes, sizeof(receive.bytes));
    validate_response_header(&receive.response, cmd,
                             PROTOCOL_BINARY_RESPONSE_NOT_STORED);

    len = storage_command(send.bytes, sizeof(send.bytes),
                          PROTOCOL_BINARY_CMD_ADD,
                          key, strlen(key), value, strlen(value), 0, 0);
    safe_send(send.bytes, len, false);
    safe_recv_packet(receive.bytes, sizeof(receive.bytes));
    validate_response_header(&receive.response, PROTOCOL_BINARY_CMD_ADD,
       ...",1869.0,1933.0,1.0,1.0,65.0,70,9,92,16,4,16,2,2,0,16,,0,4,4,2,2,enum test_return
998,92776,test_binary_append,1,test_binary_append,enum test_return test_binary_append (void),testapp.c,"static enum test_return test_binary_append(void) {
    return test_binary_concat_impl(""test_binary_append"",
                                   PROTOCOL_BINARY_CMD_APPEND);
}",1935.0,1938.0,1.0,1.0,4.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,enum test_return
999,92785,test_binary_prepend,1,test_binary_prepend,enum test_return test_binary_prepend (void),testapp.c,"static enum test_return test_binary_prepend(void) {
    return test_binary_concat_impl(""test_binary_prepend"",
                                   PROTOCOL_BINARY_CMD_PREPEND);
}",1940.0,1943.0,1.0,1.0,4.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,enum test_return
1000,92794,test_binary_appendq,1,test_binary_appendq,enum test_return test_binary_appendq (void),testapp.c,"static enum test_return test_binary_appendq(void) {
    return test_binary_concat_impl(""test_binary_appendq"",
                                   PROTOCOL_BINARY_CMD_APPENDQ);
}",1945.0,1948.0,1.0,1.0,4.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,enum test_return
1001,92803,test_binary_prependq,1,test_binary_prependq,enum test_return test_binary_prependq (void),testapp.c,"static enum test_return test_binary_prependq(void) {
    return test_binary_concat_impl(""test_binary_prependq"",
                                   PROTOCOL_BINARY_CMD_PREPENDQ);
}",1950.0,1953.0,1.0,1.0,4.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,enum test_return
1002,92812,test_binary_stat,1,test_binary_stat,enum test_return test_binary_stat (void),testapp.c,"static enum test_return test_binary_stat(void) {
    union {
        protocol_binary_request_no_extras request;
        protocol_binary_response_no_extras response;
        char bytes[1024];
    } buffer;

    size_t len = raw_command(buffer.bytes, sizeof(buffer.bytes),
                             PROTOCOL_BINARY_CMD_STAT,
                             NULL, 0, NULL, 0);

    safe_send(buffer.bytes, len, false);
    do {
        safe_recv_packet(buffer.bytes, sizeof(buffer.bytes));
        validate_response_header(&buffer.response, PROTOCOL_BINARY_CMD_STAT,
                                 PROTOCOL_BINARY_RESPONSE_SUCCESS);
    } while (buffer.response.message.header.response.keylen != 0);

    return TEST_PASS;
}",1955.0,1974.0,1.0,1.0,20.0,16,5,16,7,0,4,2,2,0,4,,0,1,2,1,1,enum test_return
1003,92872,test_binary_illegal,1,test_binary_illegal,enum test_return test_binary_illegal (void),testapp.c,"static enum test_return test_binary_illegal(void) {
    uint8_t cmd = 0x25;
    while (cmd != 0x00) {
        union {
            protocol_binary_request_no_extras request;
            protocol_binary_response_no_extras response;
            char bytes[1024];
        } buffer;
        size_t len = raw_command(buffer.bytes, sizeof(buffer.bytes),
                                 cmd, NULL, 0, NULL, 0);
        safe_send(buffer.bytes, len, false);
        safe_recv_packet(buffer.bytes, sizeof(buffer.bytes));
        validate_response_header(&buffer.response, cmd,
                                 PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND);
        ++cmd;
    }

    return TEST_PASS;
}",1976.0,1994.0,1.0,1.0,19.0,13,6,18,7,0,4,2,2,0,4,,0,1,2,1,1,enum test_return
1004,92929,binary_hickup_recv_verification_thread,1,binary_hickup_recv_verification_thread,void* binary_hickup_recv_verification_thread (void*),testapp.c,"static void *binary_hickup_recv_verification_thread(void *arg) {
    protocol_binary_response_no_extras *response = malloc(65*1024);
    if (response != NULL) {
        while (safe_recv_packet(response, 65*1024)) {
            /* Just validate the packet format */
            validate_response_header(response,
                                     response->message.header.response.opcode,
                                     response->message.header.response.status);
        }
        free(response);
    }
    hickup_thread_running = false;
    allow_closed_read = false;
    return NULL;
}",1998.0,2012.0,1.0,1.0,15.0,14,5,13,5,0,4,3,4,1,2,,0,3,2,1,1,void*
1005,92983,test_binary_pipeline_hickup_chunk,1,test_binary_pipeline_hickup_chunk,"enum test_return test_binary_pipeline_hickup_chunk (void*,size_t)",testapp.c,"static enum test_return test_binary_pipeline_hickup_chunk(void *buffer, size_t buffersize) {
    off_t offset = 0;
    char *key[256] = { NULL };
    uint64_t value = 0xfeedfacedeadbeef;

    while (hickup_thread_running &&
           offset + sizeof(protocol_binary_request_no_extras) < buffersize) {
        union {
            protocol_binary_request_no_extras request;
            char bytes[65 * 1024];
        } command;
        uint8_t cmd = (uint8_t)(rand() & 0xff);
        size_t len;
        size_t keylen = (rand() % 250) + 1;

        switch (cmd) {
        case PROTOCOL_BINARY_CMD_ADD:
        case PROTOCOL_BINARY_CMD_ADDQ:
        case PROTOCOL_BINARY_CMD_REPLACE:
        case PROTOCOL_BINARY_CMD_REPLACEQ:
        case PROTOCOL_BINARY_CMD_SET:
        case PROTOCOL_BINARY_CMD_SETQ:
            len = storage_command(command.bytes, sizeof(command.bytes), cmd,
                                  key, keylen , &value, sizeof(value),
                                  0, 0);
      ...",2014.0,2120.0,1.0,1.0,107.0,67,12,132,49,1,13,14,6,1,12,,0,12,4,2,2,enum test_return
1006,93316,test_binary_pipeline_hickup,1,test_binary_pipeline_hickup,enum test_return test_binary_pipeline_hickup (void),testapp.c,"static enum test_return test_binary_pipeline_hickup(void)
{
    size_t buffersize = 65 * 1024;
    void *buffer = malloc(buffersize);
    int ii;

    pthread_t tid;
    int ret;
    allow_closed_read = true;
    hickup_thread_running = true;
    if ((ret = pthread_create(&tid, NULL,
                              binary_hickup_recv_verification_thread, NULL)) != 0) {
        fprintf(stderr, ""Can't create thread: %s\n"", strerror(ret));
        free(buffer);
        return TEST_FAIL;
    }

    /* Allow the thread to start */
    usleep(250);

    srand((int)time(NULL));
    for (ii = 0; ii < 2; ++ii) {
        test_binary_pipeline_hickup_chunk(buffer, buffersize);
    }

    /* send quitq to shut down the read thread ;-) */
    size_t len = raw_command(buffer, buffersize, PROTOCOL_BINARY_CMD_QUITQ,
                             NULL, 0, NULL, 0);
    safe_send(buffer, len, false);

    pthread_join(tid, NULL);
    free(buffer);
    return TEST_PASS;
}",2122.0,2155.0,1.0,1.0,34.0,12,6,33,15,0,5,3,3,0,3,,0,3,2,1,1,enum test_return
1007,93405,test_issue_101,1,test_issue_101,enum test_return test_issue_101 (void),testapp.c,"static enum test_return test_issue_101(void) {
    enum { max = 2 };
    enum test_return ret = TEST_PASS;
    struct conn *conns[max];
    int ii = 0;
    pid_t child = 0;

    if (getenv(""SKIP_TEST_101"") != NULL) {
        return TEST_SKIP;
    }

    const char *command = ""stats\r\nstats\r\nstats\r\nstats\r\nstats\r\n"";
    size_t cmdlen = strlen(command);

    server_pid = start_server(&port, false, 1000);

    for (ii = 0; ii < max; ++ii) {
        conns[ii] = NULL;
        conns[ii] = connect_server(""127.0.0.1"", port, true, enable_ssl);
        assert(conns[ii]);
        assert(conns[ii]->sock > 0);
    }

    /* Send command on the connection until it blocks */
    for (ii = 0; ii < max; ++ii) {
        bool more = true;
        do {
            ssize_t err = conns[ii]->write(conns[ii], command, cmdlen);
            if (err == -1) {
                switch (errno) {
                case EINTR:
                    break;
                case ENOMEM:
                case EWOULDB...",2158.0,2240.0,1.0,1.0,83.0,44,10,70,25,0,10,15,19,1,3,,0,10,2,1,1,enum test_return
1008,94191,wait_for_thread_registration,1,wait_for_thread_registration,void wait_for_thread_registration (int),thread.c,"static void wait_for_thread_registration(int nthreads) {
    while (init_count < nthreads) {
        pthread_cond_wait(&init_cond, &init_lock);
    }
}",141.0,145.0,1.0,1.0,5.0,3,2,4,4,0,3,2,2,1,0,,0,3,2,1,1,void
1009,94206,register_thread_initialized,1,register_thread_initialized,void register_thread_initialized (void),thread.c,"static void register_thread_initialized(void) {
    pthread_mutex_lock(&init_lock);
    init_count++;
    pthread_cond_signal(&init_cond);
    pthread_mutex_unlock(&init_lock);
    /* Force worker threads to pile up if someone wants us to */
    pthread_mutex_lock(&worker_hang_lock);
    pthread_mutex_unlock(&worker_hang_lock);
}",147.0,155.0,1.0,1.0,9.0,6,2,6,4,2,6,1,1,0,0,,0,6,2,1,1,void
1010,94509,cq_init,1,cq_init,void cq_init (CQ*),thread.c,"static void cq_init(CQ *cq) {
    pthread_mutex_init(&cq->lock, NULL);
    STAILQ_INIT(&cq->head);
    cq->cache = cache_create(""cq"", sizeof(CQ_ITEM), sizeof(char *));
    if (cq->cache == NULL) {
        fprintf(stderr, ""Failed to create connection queue cache\n"");
        exit(EXIT_FAILURE);
    }
}",277.0,285.0,1.0,4.0,9.0,22,5,14,6,1,1,2,2,0,1,,0,1,2,1,1,void
1011,94734,cqi_free,1,cqi_free,"void cqi_free (CQ*,CQ_ITEM*)",thread.c,"static void cqi_free(CQ *cq, CQ_ITEM *item) {
    cache_free(cq->cache, item);
}",330.0,332.0,1.0,1.0,3.0,1,1,2,2,0,1,1,1,0,1,,0,0,4,2,2,void
1012,94851,setup_thread,1,setup_thread,void setup_thread (LIBEVENT_THREAD*),thread.c,"static void setup_thread(LIBEVENT_THREAD *me) {
#if defined(LIBEVENT_VERSION_NUMBER) && LIBEVENT_VERSION_NUMBER >= 0x02000101
    struct event_config *ev_config;
    ev_config = event_config_new();
    event_config_set_flag(ev_config, EVENT_BASE_FLAG_NOLOCK);
    me->base = event_base_new_with_config(ev_config);
    event_config_free(ev_config);
#else
    me->base = event_init();
#endif

    if (! me->base) {
        fprintf(stderr, ""Can't allocate event base\n"");
        exit(1);
    }

    /* Listen for notifications from other threads */
#ifdef HAVE_EVENTFD
    event_set(&me->notify_event, me->notify_event_fd,
              EV_READ | EV_PERSIST, thread_libevent_process, me);
#else
    event_set(&me->notify_event, me->notify_receive_fd,
              EV_READ | EV_PERSIST, thread_libevent_process, me);
#endif
    event_base_set(me->base, &me->notify_event);

    if (event_add(&me->notify_event, 0) == -1) {
        fprintf(stderr, ""Can't monitor libevent notify pipe\n"");
        exi...",405.0,497.0,1.0,42.0,93.0,44,12,49,12,0,24,9,10,7,5,,0,21,2,1,1,void
1013,95041,worker_libevent,1,worker_libevent,void* worker_libevent (void*),thread.c,"static void *worker_libevent(void *arg) {
    LIBEVENT_THREAD *me = arg;

    /* Any per-thread setup can happen here; memcached_thread_init() will block until
     * all threads have finished initializing.
     */
    me->l = logger_create();
    me->lru_bump_buf = item_lru_bump_buf_create();
    if (me->l == NULL || me->lru_bump_buf == NULL) {
        abort();
    }

    if (settings.drop_privileges) {
        drop_worker_privileges();
    }

    register_thread_initialized();

    event_base_loop(me->base, 0);

    // same mechanism used to watch for all threads exiting.
    register_thread_initialized();

    event_base_free(me->base);
    return NULL;
}",502.0,527.0,1.0,8.0,26.0,13,5,12,4,0,11,3,3,3,4,,0,9,2,1,1,void*
1014,95308,select_thread_round_robin,1,select_thread_round_robin,LIBEVENT_THREAD select_thread_round_robin (void),thread.c,"static LIBEVENT_THREAD *select_thread_round_robin(void)
{
    int tid = (last_thread + 1) % settings.num_threads;

    last_thread = tid;

    return threads + tid;
}",644.0,651.0,1.0,1.0,8.0,6,4,7,4,1,4,1,1,0,0,,0,4,2,1,1,LIBEVENT_THREAD
1015,95330,reset_threads_napi_id,1,reset_threads_napi_id,void reset_threads_napi_id (void),thread.c,"static void reset_threads_napi_id(void)
{
    LIBEVENT_THREAD *thread;
    int i;

    for (i = 0; i < settings.num_threads; i++) {
         thread = threads + i;
         thread->napi_id = 0;
    }

    last_thread_by_napi_id = -1;
}",653.0,664.0,1.0,1.0,12.0,9,6,8,5,1,4,2,2,1,0,,0,4,2,1,1,void
1016,95364,select_thread_by_napi_id,1,select_thread_by_napi_id,LIBEVENT_THREAD select_thread_by_napi_id (int),thread.c,"static LIBEVENT_THREAD *select_thread_by_napi_id(int sfd)
{
    LIBEVENT_THREAD *thread;
    int napi_id, err, i;
    socklen_t len;
    int tid = -1;

    len = sizeof(socklen_t);
    err = getsockopt(sfd, SOL_SOCKET, SO_INCOMING_NAPI_ID, &napi_id, &len);
    if ((err == -1) || (napi_id == 0)) {
        STATS_LOCK();
        stats.round_robin_fallback++;
        STATS_UNLOCK();
        return select_thread_round_robin();
    }

select:
    for (i = 0; i < settings.num_threads; i++) {
         thread = threads + i;
         if (last_thread_by_napi_id < i) {
             thread->napi_id = napi_id;
             last_thread_by_napi_id = i;
             tid = i;
             break;
         }
         if (thread->napi_id == napi_id) {
             tid = i;
             break;
         }
    }

    if (tid == -1) {
        STATS_LOCK();
        stats.unexpected_napi_ids++;
        STATS_UNLOCK();
        reset_threads_napi_id();
        goto select;
    }

    return threads + tid;
}",670.0,710.0,1.0,38.0,41.0,31,11,33,13,0,15,9,8,3,2,,0,9,2,1,1,LIBEVENT_THREAD
1017,95900,add_delta,1,add_delta,"enum delta_result_type add_delta (conn*,char*,size_t,bool,int64_t,char*,uint64_t*)",thread.c,"enum delta_result_type add_delta(conn *c, const char *key,
                                 const size_t nkey, bool incr,
                                 const int64_t delta, char *buf,
                                 uint64_t *cas) {
    enum delta_result_type ret;
    uint32_t hv;

    hv = hash(key, nkey);
    item_lock(hv);
    ret = do_add_delta(c, key, nkey, incr, delta, buf, cas, hv, NULL);
    item_unlock(hv);
    return ret;
}",891.0,903.0,1.0,1.0,13.0,2,1,16,10,1,3,1,1,0,3,,0,1,14,7,7,enum delta_result_type
1018,95936,store_item,1,store_item,"enum store_item_type store_item (item*,int,conn*)",thread.c,"enum store_item_type store_item(item *item, int comm, conn* c) {
    enum store_item_type ret;
    uint32_t hv;

    hv = hash(ITEM_key(item), item->nkey);
    item_lock(hv);
    ret = do_store_item(item, comm, c, hv);
    item_unlock(hv);
    return ret;
}",908.0,917.0,1.0,14.0,10.0,11,8,14,6,0,3,1,1,0,3,,0,1,6,3,3,enum store_item_type
1019,97243,signal_handler,1,signal_handler,void signal_handler (int),timedrun.c,"static void signal_handler(int which)
{
    caught_sig = which;
}",13.0,16.0,1.0,1.0,4.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
1020,97251,wait_for_process,1,wait_for_process,int wait_for_process (pid_t),timedrun.c,"static int wait_for_process(pid_t pid)
{
    int rv = EX_SOFTWARE;
    int status = 0;
    int i = 0;
    struct sigaction sig_handler;

    memset(&sig_handler, 0, sizeof(struct sigaction));
    sig_handler.sa_handler = signal_handler;
    sig_handler.sa_flags = 0;

    sigaction(SIGALRM, &sig_handler, NULL);
    sigaction(SIGHUP, &sig_handler, NULL);
    sigaction(SIGINT, &sig_handler, NULL);
    sigaction(SIGUSR1, &sig_handler, NULL);
    sigaction(SIGTERM, &sig_handler, NULL);
    sigaction(SIGPIPE, &sig_handler, NULL);

    /* Loop forever waiting for the process to quit */
    for (i = 0; ;i++) {
        pid_t p = waitpid(pid, &status, 0);
        if (p == pid) {
            /* child exited.  Let's get out of here */
            rv = WIFEXITED(status) ?
                WEXITSTATUS(status) :
                (0x80 | WTERMSIG(status));
            break;
        } else {
            int sig = 0;
            switch (i) {
            case 0:
                /* On the first iteratio...",18.0,71.0,1.0,1.0,54.0,23,8,38,15,1,0,4,4,0,0,,0,0,2,1,1,int
1021,97400,spawn_and_wait,1,spawn_and_wait,int spawn_and_wait (char**),timedrun.c,"static int spawn_and_wait(char **argv)
{
    int rv = EX_SOFTWARE;
    pid_t pid = fork();

    switch (pid) {
    case -1:
        perror(""fork"");
        rv = EX_OSERR;
        break; /* NOTREACHED */
    case 0:
        execvp(argv[0], argv);
        perror(""exec"");
        rv = EX_SOFTWARE;
        break; /* NOTREACHED */
    default:
        rv = wait_for_process(pid);
    }
    return rv;
}",73.0,92.0,1.0,1.0,20.0,7,3,13,5,0,1,4,2,0,1,,0,1,2,1,1,int
1022,97608,uriencode_init,1,uriencode_init,void uriencode_init (void),util.c,"void uriencode_init(void) {
    int x;
    char *str = uriencode_str;
    for (x = 0; x < 256; x++) {
        if (isalnum(x) || x == '-' || x == '.' || x == '_' || x == '~') {
            uriencode_map[x] = NULL;
        } else {
            snprintf(str, 4, ""%%%02hhX"", (unsigned char)x);
            uriencode_map[x] = str;
            str += 3; /* lobbing off the \0 is fine */
        }
    }
}",14.0,26.0,1.0,1.0,13.0,13,5,12,5,1,2,3,4,0,0,,0,2,2,1,1,void
1023,97671,uriencode,1,uriencode,"bool uriencode (char*,char*,size_t,size_t)",util.c,"bool uriencode(const char *src, char *dst, const size_t srclen, const size_t dstlen) {
    int x;
    size_t d = 0;
    for (x = 0; x < srclen; x++) {
        if (d + 4 > dstlen)
            return false;
        if (uriencode_map[(unsigned char) src[x]] != NULL) {
            memcpy(&dst[d], uriencode_map[(unsigned char) src[x]], 3);
            d += 3;
        } else {
            dst[d] = src[x];
            d++;
        }
    }
    dst[d] = '\0';
    return true;
}",28.0,44.0,1.0,1.0,17.0,17,9,20,10,3,2,4,6,1,0,,0,2,8,4,4,bool
1024,97749,safe_strtoull,1,safe_strtoull,"bool safe_strtoull (char*,uint64_t*)",util.c,"bool safe_strtoull(const char *str, uint64_t *out) {
    assert(out != NULL);
    errno = 0;
    *out = 0;
    char *endptr;
    unsigned long long ull = strtoull(str, &endptr, 10);
    if ((errno == ERANGE) || (str == endptr)) {
        return false;
    }

    if (xisspace(*endptr) || (*endptr == '\0' && endptr != str)) {
        if ((long long) ull < 0) {
            /* only check for negative signs in the uncommon case when
             * the unsigned number is so big that it's negative as a
             * signed number. */
            if (strchr(str, '-') != NULL) {
                return false;
            }
        }
        *out = ull;
        return true;
    }
    return false;
}",49.0,72.0,1.0,8.0,24.0,22,9,25,9,19,0,5,8,0,0,,0,0,4,2,2,bool
1025,97830,safe_strtoull_hex,1,safe_strtoull_hex,"bool safe_strtoull_hex (char*,uint64_t*)",util.c,"bool safe_strtoull_hex(const char *str, uint64_t *out) {
    assert(out != NULL);
    errno = 0;
    *out = 0;
    char *endptr;
    unsigned long long ull = strtoull(str, &endptr, 16);
    if ((errno == ERANGE) || (str == endptr)) {
        return false;
    }

    if (xisspace(*endptr) || (*endptr == '\0' && endptr != str)) {
        if ((long long) ull < 0) {
            /* only check for negative signs in the uncommon case when
             * the unsigned number is so big that it's negative as a
             * signed number. */
            if (strchr(str, '-') != NULL) {
                return false;
            }
        }
        *out = ull;
        return true;
    }
    return false;
}",79.0,102.0,1.0,8.0,24.0,22,9,25,9,1,0,5,8,0,0,,0,0,4,2,2,bool
1026,97911,safe_strtoll,1,safe_strtoll,"bool safe_strtoll (char*,int64_t*)",util.c,"bool safe_strtoll(const char *str, int64_t *out) {
    assert(out != NULL);
    errno = 0;
    *out = 0;
    char *endptr;
    long long ll = strtoll(str, &endptr, 10);
    if ((errno == ERANGE) || (str == endptr)) {
        return false;
    }

    if (xisspace(*endptr) || (*endptr == '\0' && endptr != str)) {
        *out = ll;
        return true;
    }
    return false;
}",104.0,119.0,1.0,8.0,16.0,19,8,21,9,14,0,3,3,0,0,,0,0,4,2,2,bool
1027,97976,safe_strtoul,1,safe_strtoul,"bool safe_strtoul (char*,uint32_t*)",util.c,"bool safe_strtoul(const char *str, uint32_t *out) {
    char *endptr = NULL;
    unsigned long l = 0;
    assert(out);
    assert(str);
    *out = 0;
    errno = 0;

    l = strtoul(str, &endptr, 10);
    if ((errno == ERANGE) || (str == endptr)) {
        return false;
    }

    if (xisspace(*endptr) || (*endptr == '\0' && endptr != str)) {
        if ((long) l < 0) {
            /* only check for negative signs in the uncommon case when
             * the unsigned number is so big that it's negative as a
             * signed number. */
            if (strchr(str, '-') != NULL) {
                return false;
            }
        }
        *out = l;
        return true;
    }

    return false;
}",121.0,148.0,1.0,8.0,28.0,23,9,28,9,23,0,5,8,0,0,,0,0,4,2,2,bool
1028,98063,safe_strtol,1,safe_strtol,"bool safe_strtol (char*,int32_t*)",util.c,"bool safe_strtol(const char *str, int32_t *out) {
    assert(out != NULL);
    errno = 0;
    *out = 0;
    char *endptr;
    long l = strtol(str, &endptr, 10);
    if ((errno == ERANGE) || (str == endptr)) {
        return false;
    }

    if (xisspace(*endptr) || (*endptr == '\0' && endptr != str)) {
        *out = l;
        return true;
    }
    return false;
}",150.0,165.0,1.0,8.0,16.0,19,8,21,9,27,0,3,3,0,0,,0,0,4,2,2,bool
1029,98128,safe_strtod,1,safe_strtod,"bool safe_strtod (char*,double*)",util.c,"bool safe_strtod(const char *str, double *out) {
    assert(out != NULL);
    errno = 0;
    *out = 0;
    char *endptr;
    double d = strtod(str, &endptr);
    if ((errno == ERANGE) || (str == endptr)) {
        return false;
    }

    if (xisspace(*endptr) || (*endptr == '\0' && endptr != str)) {
        *out = d;
        return true;
    }
    return false;
}",167.0,182.0,1.0,8.0,16.0,19,8,21,9,3,0,3,3,0,0,,0,0,4,2,2,bool
1030,98192,safe_strcpy,1,safe_strcpy,"bool safe_strcpy (char*,char*,size_t)",util.c,"bool safe_strcpy(char *dst, const char *src, const size_t dstmax) {
   size_t x;

   for (x = 0; x < dstmax - 1 && src[x] != '\0'; x++) {
        dst[x] = src[x];
   }

   dst[x] = '\0';

   if (src[x] == '\0') {
       return true;
   } else {
       return false;
   }
}",190.0,204.0,1.0,1.0,15.0,13,7,14,5,1,0,3,3,0,0,,0,0,6,3,3,bool
1031,98244,safe_memcmp,1,safe_memcmp,"bool safe_memcmp (void*,void*,size_t)",util.c,"bool safe_memcmp(const void *a, const void *b, size_t len) {
    const volatile unsigned char *ua = (const volatile unsigned char *)a;
    const volatile unsigned char *ub = (const volatile unsigned char *)b;
    int delta = 0;
    size_t x;

    for (x = 0; x < len; x++) {
        delta |= ua[x] ^ ub[x];
    }

    if (delta == 0) {
        return true;
    } else {
        return false;
    }
}",206.0,221.0,1.0,1.0,16.0,11,6,15,8,2,0,3,3,0,0,,0,0,6,3,3,bool
1032,98299,vperror,1,vperror,void vperror (char*...),util.c,"void vperror(const char *fmt, ...) {
    int old_errno = errno;
    char buf[1024];
    va_list ap;

    va_start(ap, fmt);
    if (vsnprintf(buf, sizeof(buf), fmt, ap) == -1) {
        buf[sizeof(buf) - 1] = '\0';
    }
    va_end(ap);

    errno = old_errno;

    perror(buf);
}",223.0,237.0,1.0,1.0,15.0,9,6,14,5,10,0,2,2,0,0,,0,0,2,1,1,void
1033,98339,mc_swap64,1,mc_swap64,uint64_t mc_swap64 (uint64_t),util.c,"static uint64_t mc_swap64(uint64_t in) {
#ifdef ENDIAN_LITTLE
    /* Little endian, flip the bytes around until someone makes a faster/better
    * way to do this. */
    int64_t rv = 0;
    int i = 0;
     for(i = 0; i<8; i++) {
        rv = (rv << 8) | (in & 0xff);
        in >>= 8;
     }
    return rv;
#else
    /* big-endian machines don't need byte swapping */
    return in;
#endif
}",240.0,255.0,1.0,1.0,16.0,0,0,1,1,2,0,1,1,0,0,,0,0,2,1,1,uint64_t
1034,98346,ntohll,1,ntohll,uint64_t ntohll (uint64_t),util.c,"uint64_t ntohll(uint64_t val) {
   return mc_swap64(val);
}",257.0,259.0,1.0,1.0,3.0,0,0,1,1,3,1,1,1,0,1,,0,0,2,1,1,uint64_t
1035,98354,htonll,1,htonll,uint64_t htonll (uint64_t),util.c,"uint64_t htonll(uint64_t val) {
   return mc_swap64(val);
}",261.0,263.0,1.0,1.0,3.0,0,0,1,1,3,1,1,1,0,1,,0,0,2,1,1,uint64_t
1036,98474,show_response_buffer,1,show_response_buffer,"void show_response_buffer (void*,char*,size_t)",vendor\mcmc\example.c,"static void show_response_buffer(void *c, char *rbuf, size_t bufsize) {
    int status;
    mcmc_resp_t resp;
    char *val = NULL;

    do {
        int bread = recv(mcmc_fd(c), rbuf, bufsize, 0);

        // need to know how far to advance the buffer.
        // resp->reslen + resp->vlen_read works, but feels awkward.
        status = mcmc_parse_buf(c, rbuf, bread, &resp);
    } while (status == MCMC_WANT_READ);

    if (status != MCMC_OK) {
        printf(""bad response\n"");
    }

    // now we need to read the value back.
    // resp.reslen + resp.vlen is the total length.
    // resp.reslen + resp.vlen_read is how much of the buffer was used.
    // resp.vlen_read vs resp.vlen is how much was read vs how much still
    // needs to be read from the socket.
    if (resp.vlen != resp.vlen_read) {
        // malloc and recv the rest.
        // can/should add convenience functions for this?
        val = malloc(resp.vlen);
        memcpy(val, resp.value, resp.vlen_read);
        si...",16.0,56.0,1.0,23.0,41.0,23,9,34,11,1,11,5,6,2,3,,0,11,6,3,3,void
1037,98588,buffer_mode,1,buffer_mode,void buffer_mode (void),vendor\mcmc\example.c,"void buffer_mode(void) {
    void *c = malloc(mcmc_size(MCMC_OPTION_BLANK));
    size_t bufsize = mcmc_min_buffer_size(MCMC_OPTION_BLANK) * 2;
    char *rbuf = malloc(bufsize);

    int status = mcmc_connect(c, ""127.0.0.1"", ""11211"", MCMC_OPTION_BLANK);

    char *requests[5] = {""get foo\r\n"",
        ""get foob\r\n"",
        ""mg foo s t v\r\n"",
        ""mg doof s t v Omoo k\r\n"",
        """"};

    for (int x = 0; strlen(requests[x]) != 0; x++) {
        status = mcmc_send_request(c, requests[x], strlen(requests[x]), 1);

        if (status != MCMC_OK) {
            fprintf(stderr, ""Failed to send request to memcached\n"");
            return;
        }

        // Regardless of what command we sent, this should print out the response.
        show_response_buffer(c, rbuf, bufsize);
    }

}",145.0,170.0,1.0,31.0,26.0,14,5,21,7,0,5,3,4,0,5,,0,4,2,1,1,void
1038,98743,_mcmc_parse_value_line,1,_mcmc_parse_value_line,"int _mcmc_parse_value_line (mcmc_ctx_t*,mcmc_resp_t*)",vendor\mcmc\mcmc.c,"static int _mcmc_parse_value_line(mcmc_ctx_t *ctx, mcmc_resp_t *r) {
    char *buf = ctx->buffer_head;
    // we know that ""VALUE "" has matched, so skip that.
    char *p = buf+6;
    size_t l = ctx->buffer_request_len;

    // <key> <flags> <bytes> [<cas unique>]
    char *key = p;
    int keylen;
    p = memchr(p, ' ', l - 6);
    if (p == NULL) {
        // FIXME: these should return MCMC_ERR and set the internal parse
        // error code.
        return MCMC_PARSE_ERROR;
    }

    keylen = p - key;

    // convert flags into something useful.
    // FIXME: do we need to prevent overruns in strtoul?
    // we know for sure the line will eventually end in a \n.
    char *n = NULL;
    errno = 0;
    uint32_t flags = strtoul(p, &n, 10);
    if ((errno == ERANGE) || (p == n) || (*n != ' ')) {
        return MCMC_PARSE_ERROR;
    }
    p = n;

    errno = 0;
    uint32_t bytes = strtoul(p, &n, 10);
    if ((errno == ERANGE) || (p == n)) {
        return MCMC_PARSE_ERROR;
    }
   ...",54.0,120.0,1.0,15.0,67.0,65,10,69,15,1,6,7,8,1,0,,0,6,4,2,2,int
1039,98970,_mcmc_parse_response,1,_mcmc_parse_response,"int _mcmc_parse_response (mcmc_ctx_t*,mcmc_resp_t*)",vendor\mcmc\mcmc.c,"static int _mcmc_parse_response(mcmc_ctx_t *ctx, mcmc_resp_t *r) {
    char *buf = ctx->buffer_head;
    char *cur = buf;
    size_t l = ctx->buffer_request_len;
    int rlen; // response code length.
    int more = 0;
    r->reslen = ctx->buffer_request_len;
    r->type = MCMC_RESP_GENERIC;

    // walk until the \r\n
    while (l-- > 2) {
        if (*cur == ' ') {
            more = 1;
            break;
        }
        cur++;
    }
    rlen = cur - buf;

    // incr/decr returns a number with no code :(
    // not checking length first since buf must have at least one char to
    // enter this function.
    if (buf[0] >= '0' && buf[0] <= '9') {
        // TODO: parse it as a number on request.
        // TODO: validate whole thing as digits here?
        ctx->status_flags |= FLAG_BUF_IS_NUMERIC;
        r->type = MCMC_RESP_NUMERIC;
        return MCMC_OK;
    }

    if (rlen < 2) {
        ctx->error = MCMC_PARSE_ERROR_SHORT;
        return MCMC_ERR;
    }

    int rv = MCMC_O...",125.0,321.0,1.0,14.0,197.0,98,17,83,14,1,9,41,56,0,1,,0,9,4,2,2,int
1040,99598,mcmc_fd,1,mcmc_fd,int mcmc_fd (void*),vendor\mcmc\mcmc.c,"int mcmc_fd(void *c) {
    mcmc_ctx_t *ctx = (mcmc_ctx_t *)c;
    return ctx->fd;
}",325.0,328.0,1.0,1.0,4.0,3,3,3,2,2,0,1,1,0,0,,0,0,2,1,1,int
1041,99613,mcmc_size,1,mcmc_size,size_t mcmc_size (int),vendor\mcmc\mcmc.c,"size_t mcmc_size(int options) {
    return sizeof(mcmc_ctx_t);
}",330.0,332.0,1.0,1.0,3.0,1,1,1,1,2,0,1,1,0,0,,0,0,2,1,1,size_t
1042,99621,mcmc_min_buffer_size,1,mcmc_min_buffer_size,size_t mcmc_min_buffer_size (int),vendor\mcmc\mcmc.c,"size_t mcmc_min_buffer_size(int options) {
    return MIN_BUFFER_SIZE;
}",337.0,339.0,1.0,11.0,3.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,size_t
1043,99630,mcmc_parse_buf,1,mcmc_parse_buf,"int mcmc_parse_buf (void*,char*,size_t,mcmc_resp_t*)",vendor\mcmc\mcmc.c,"int mcmc_parse_buf(void *c, char *buf, size_t read, mcmc_resp_t *r) {
    mcmc_ctx_t *ctx = c;
    char *el;

    el = memchr(buf, '\n', read);
    if (el == NULL) {
        return MCMC_WANT_READ;
    }

    memset(r, 0, sizeof(*r));

    // Consume through the newline, note where the value would start if exists
    r->value = el+1;

    ctx->buffer_used = read;
    // FIXME: the server must be stricter in what it sends back. should always
    // have a \r. check for it and fail?
    ctx->buffer_request_len = r->value - buf;
    // leave the \r\n in the line end cache.
    ctx->buffer_head = buf;

    return _mcmc_parse_response(ctx, r);
}",347.0,369.0,1.0,15.0,23.0,16,7,20,7,1,3,2,2,0,1,,0,2,8,4,4,int
1044,99746,mcmc_connect,1,mcmc_connect,"int mcmc_connect (void*,char*,char*,int)",vendor\mcmc\mcmc.c,"int mcmc_connect(void *c, char *host, char *port, int options) {
    mcmc_ctx_t *ctx = (mcmc_ctx_t *)c;

    int s;
    int sock;
    int res = MCMC_CONNECTED;
    struct addrinfo hints;
    struct addrinfo *ai;
    struct addrinfo *next;

    // Since our cx memory was likely malloc'ed, ensure we start clear.
    memset(ctx, 0, sizeof(mcmc_ctx_t));
    memset(&hints, 0, sizeof(hints));
    hints.ai_family = AF_INET;
    hints.ai_socktype = SOCK_STREAM;

    s = getaddrinfo(host, port, &hints, &ai);

    if (s != 0) {
        hints.ai_family = AF_INET6;
        s = getaddrinfo(host, port, &hints, &ai);
        if (s != 0) {
            // TODO: gai_strerror(s)
            ctx->gai_status = s;
            res = MCMC_ERR;
            goto end;
        }
    }

    for (next = ai; next != NULL; next = next->ai_next) {
        sock = socket(next->ai_family, next->ai_socktype,
                next->ai_protocol);
        if (sock == -1)
            continue;

        if (options & MCMC_OP...",397.0,483.0,1.0,14.0,87.0,60,13,74,25,2,0,22,29,0,0,,0,0,8,4,4,int
1045,100018,mcmc_send_request,1,mcmc_send_request,"int mcmc_send_request (void*,char*,int,int)",vendor\mcmc\mcmc.c,"int mcmc_send_request(void *c, const char *request, int len, int count) {
    mcmc_ctx_t *ctx = (mcmc_ctx_t *)c;

    // adjust our send buffer by how much has already been sent.
    const char *r = request + ctx->sent_bytes_partial;
    int l = len - ctx->sent_bytes_partial;
    int sent = send(ctx->fd, r, l, 0);
    if (sent == -1) {
        // implicitly handle nonblock mode.
        if (errno == EAGAIN || errno == EWOULDBLOCK) {
            return MCMC_WANT_WRITE;
        } else {
            return MCMC_ERR;
        }
    }

    if (sent < len) {
        // can happen anytime, but mostly in nonblocking mode.
        ctx->sent_bytes_partial += sent;
        return MCMC_WANT_WRITE;
    } else {
        ctx->sent_bytes_partial = 0;
    }

    return MCMC_OK;
}",488.0,513.0,1.0,19.0,26.0,18,10,21,10,1,0,4,5,0,0,,0,0,8,4,4,int
1046,100216,mcmc_disconnect,1,mcmc_disconnect,int mcmc_disconnect (void*),vendor\mcmc\mcmc.c,"int mcmc_disconnect(void *c) {
    mcmc_ctx_t *ctx = (mcmc_ctx_t *)c;

    // FIXME: I forget if 0 can be valid.
    if (ctx->fd != 0) {
        close(ctx->fd);
        return MCMC_OK;
    } else {
        return MCMC_NOT_CONNECTED;
    }
}",659.0,669.0,1.0,15.0,11.0,5,4,4,2,1,0,2,2,0,0,,0,0,2,1,1,int
1047,33,maintenance_cond,2,assoc.c.maintenance_cond,,assoc.c,pthread_cond_t maintenance_cond,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1048,37,maintenance_lock,2,assoc.c.maintenance_lock,,assoc.c,pthread_mutex_t maintenance_lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,15,0,1,1,0,0,,0,0,0,0,0,
1049,41,hashpower,2,assoc.c.hashpower,,assoc.c,unsigned int hashpower,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,23,0,1,1,0,0,,0,0,0,0,0,
1050,47,primary_hashtable,2,assoc.c.primary_hashtable,,assoc.c,item** primary_hashtable,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
1051,51,old_hashtable,2,assoc.c.old_hashtable,,assoc.c,item** old_hashtable,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
1052,55,expanding,2,assoc.c.expanding,,assoc.c,bool expanding,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
1053,59,expand_bucket,2,assoc.c.expand_bucket,,assoc.c,uint64_t expand_bucket,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
1054,562,do_run_maintenance_thread,2,assoc.c.do_run_maintenance_thread,,assoc.c,static volatile int do_run_maintenance_thread,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1055,566,hash_bulk_move,2,assoc.c.hash_bulk_move,,assoc.c,int hash_bulk_move,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1056,782,maintenance_tid,2,assoc.c.maintenance_tid,,assoc.c,pthread_t maintenance_tid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1057,1168,main_auth_entries,2,authfile.c.main_auth_entries,,authfile.c,auth_entry[8] main_auth_entries,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1058,1173,entry_cnt,2,authfile.c.entry_cnt,,authfile.c,int entry_cnt,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1059,1177,main_auth_data,2,authfile.c.main_auth_data,,authfile.c,char* main_auth_data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1060,1526,base64_table,2,base64.c.base64_table,,base64.c,unsigned char[65] base64_table,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1061,1530,dtable,2,base64.c.dtable,,base64.c,unsigned char[256] dtable,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1062,2812,redzone_pattern,2,cache.c.redzone_pattern,,cache.c,const uint64_t redzone_pattern,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
1063,2816,cache_error,2,cache.c.cache_error,,cache.c,int cache_error,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1064,3633,crawler_mod_regs,2,crawler.c.crawler_mod_regs,,crawler.c,crawler_module_reg_t *[3] crawler_mod_regs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1065,3648,active_crawler_mod,2,crawler.c.active_crawler_mod,,crawler.c,crawler_module_t active_crawler_mod,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,26,0,1,1,0,0,,0,0,0,0,0,
1066,3650,active_crawler_type,2,crawler.c.active_crawler_type,,crawler.c,enum crawler_run_type active_crawler_type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1067,3651,crawlers,2,crawler.c.crawlers,,crawler.c,static crawler[256] crawlers,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,18,0,1,1,0,0,,0,0,0,0,0,
1068,3656,crawler_count,2,crawler.c.crawler_count,,crawler.c,static int crawler_count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1069,3660,do_run_lru_crawler_thread,2,crawler.c.do_run_lru_crawler_thread,,crawler.c,static volatile int do_run_lru_crawler_thread,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1070,3664,lru_crawler_initialized,2,crawler.c.lru_crawler_initialized,,crawler.c,static int lru_crawler_initialized,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1071,3668,lru_crawler_lock,2,crawler.c.lru_crawler_lock,,crawler.c,pthread_mutex_t lru_crawler_lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,22,0,1,1,0,0,,0,0,0,0,0,
1072,3672,lru_crawler_cond,2,crawler.c.lru_crawler_cond,,crawler.c,pthread_cond_t lru_crawler_cond,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1073,5263,item_crawler_tid,2,crawler.c.item_crawler_tid,,crawler.c,pthread_t item_crawler_tid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1074,6141,crc32c,2,crc32c.c.crc32c,,crc32c.c,crc_func crc32c,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1075,6168,crc32c_table_little,2,crc32c.c.crc32c_table_little,,crc32c.c,static uint32_t[8][256] crc32c_table_little,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1076,6603,crc32c_table_big_byte,2,crc32c.c.crc32c_table_big_byte,,crc32c.c,static uint32_t[256] crc32c_table_big_byte,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1077,6606,crc32c_table_big,2,crc32c.c.crc32c_table_big,,crc32c.c,static uint64_t[8][256] crc32c_table_big,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1078,7274,store_io_thread,2,extstore.c.store_io_thread,,extstore.c,struct store_io_thread,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1079,7279,store_maint_thread,2,extstore.c.store_maint_thread,,extstore.c,struct store_maint_thread,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1080,10887,hash,2,hash.c.hash,,hash.c,hash_func hash,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1081,11030,lru_type_map,2,items.c.lru_type_map,,items.c,unsigned int[4] lru_type_map,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1082,11068,itemstats_t,2,items.c.itemstats_t,,items.c,struct itemstats_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1083,11069,heads,2,items.c.heads,,items.c,_stritem*[256] heads,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
1084,11074,tails,2,items.c.tails,,items.c,_stritem*[256] tails,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
1085,11079,itemstats,2,items.c.itemstats,,items.c,static itemstats_t[256] itemstats,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,47,0,1,1,0,0,,0,0,0,0,0,
1086,11084,sizes,2,items.c.sizes,,items.c,unsigned int[256] sizes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
1087,11089,sizes_bytes,2,items.c.sizes_bytes,,items.c,static uint64_t[256] sizes_bytes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
1088,11094,stats_sizes_hist,2,items.c.stats_sizes_hist,,items.c,static unsigned int* stats_sizes_hist,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,14,0,1,1,0,0,,0,0,0,0,0,
1089,11098,stats_sizes_cas_min,2,items.c.stats_sizes_cas_min,,items.c,uint64_t stats_sizes_cas_min,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1090,11102,stats_sizes_buckets,2,items.c.stats_sizes_buckets,,items.c,static int stats_sizes_buckets,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1091,11106,cas_id,2,items.c.cas_id,,items.c,uint64_t cas_id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1092,11110,do_run_lru_maintainer_thread,2,items.c.do_run_lru_maintainer_thread,,items.c,static volatile int do_run_lru_maintainer_thread,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1093,11114,lru_maintainer_initialized,2,items.c.lru_maintainer_initialized,,items.c,static int lru_maintainer_initialized,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1094,11118,lru_maintainer_lock,2,items.c.lru_maintainer_lock,,items.c,pthread_mutex_t lru_maintainer_lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
1095,11122,cas_id_lock,2,items.c.cas_id_lock,,items.c,pthread_mutex_t cas_id_lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1096,11126,stats_sizes_lock,2,items.c.stats_sizes_lock,,items.c,pthread_mutex_t stats_sizes_lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,16,0,1,1,0,0,,0,0,0,0,0,
1097,11208,lru_bump_entry,2,items.c.lru_bump_entry,,items.c,struct lru_bump_entry,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1098,11209,bump_buf_head,2,items.c.bump_buf_head,,items.c,lru_bump_buf* bump_buf_head,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1099,11213,bump_buf_tail,2,items.c.bump_buf_tail,,items.c,lru_bump_buf* bump_buf_tail,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1100,11217,bump_buf_lock,2,items.c.bump_buf_lock,,items.c,pthread_mutex_t bump_buf_lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1101,17746,slab_automove_default,2,items.c.slab_automove_default,,items.c,slab_automove_reg_t slab_automove_default,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1102,17762,lru_maintainer_tid,2,items.c.lru_maintainer_tid,,items.c,pthread_t lru_maintainer_tid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1103,19026,lut,2,itoa_ljust.c.lut,,itoa_ljust.c,char[201] lut,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1104,19490,kill_msg,2,linux_priv.c.kill_msg,,linux_priv.c,static char* kill_msg,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1105,19592,logger_stack_head,2,logger.c.logger_stack_head,,logger.c,logger* logger_stack_head,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1106,19596,logger_stack_tail,2,logger.c.logger_stack_tail,,logger.c,logger* logger_stack_tail,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1107,19600,logger_count,2,logger.c.logger_count,,logger.c,static unsigned int logger_count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1108,19604,do_run_logger_thread,2,logger.c.do_run_logger_thread,,logger.c,static volatile int do_run_logger_thread,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1109,19608,logger_tid,2,logger.c.logger_tid,,logger.c,pthread_t logger_tid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1110,19609,logger_stack_lock,2,logger.c.logger_stack_lock,,logger.c,pthread_mutex_t logger_stack_lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
1111,19613,logger_stack_cond,2,logger.c.logger_stack_cond,,logger.c,pthread_cond_t logger_stack_cond,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1112,19617,logger_key,2,logger.c.logger_key,,logger.c,pthread_key_t logger_key,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1113,19618,logger_atomics_mutex,2,logger.c.logger_atomics_mutex,,logger.c,pthread_mutex_t logger_atomics_mutex,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
1114,19622,watchers,2,logger.c.watchers,,logger.c,logger_watcher *[20] watchers,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1115,19629,watcher_count,2,logger.c.watcher_count,,logger.c,int watcher_count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1116,20614,default_entries,2,logger.c.default_entries,,logger.c,_entry_details[] default_entries,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1117,20722,logger_gid,2,logger.c.logger_gid,,logger.c,uint64_t logger_gid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1118,25780,stats,2,memcached.c.stats,,memcached.c,struct stats stats,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,38,0,1,1,0,0,,0,0,0,0,0,
1119,25782,stats_state,2,memcached.c.stats_state,,memcached.c,struct stats_state stats_state,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,26,0,1,1,0,0,,0,0,0,0,0,
1120,25784,settings,2,memcached.c.settings,,memcached.c,struct settings settings,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,356,0,1,1,0,0,,0,0,0,0,0,
1121,25786,conns,2,memcached.c.conns,,memcached.c,conn** conns,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,18,0,1,1,0,0,,0,0,0,0,0,
1122,25790,listen_conn,2,memcached.c.listen_conn,,memcached.c,conn* listen_conn,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1123,25794,max_fds,2,memcached.c.max_fds,,memcached.c,static int max_fds,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1124,25796,main_base,2,memcached.c.main_base,,memcached.c,struct event_base* main_base,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1125,25858,allow_new_conns,2,memcached.c.allow_new_conns,,memcached.c,volatile bool allow_new_conns,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1126,25862,stop_main_loop,2,memcached.c.stop_main_loop,,memcached.c,static int stop_main_loop,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1127,25867,maxconnsevent,2,memcached.c.maxconnsevent,,memcached.c,struct event maxconnsevent,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1128,26326,conn_timeout_tid,2,memcached.c.conn_timeout_tid,,memcached.c,pthread_t conn_timeout_tid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1129,26327,do_run_conn_timeout_thread,2,memcached.c.do_run_conn_timeout_thread,,memcached.c,static int do_run_conn_timeout_thread,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1130,26328,conn_timeout_cond,2,memcached.c.conn_timeout_cond,,memcached.c,pthread_cond_t conn_timeout_cond,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1131,26332,conn_timeout_lock,2,memcached.c.conn_timeout_lock,,memcached.c,pthread_mutex_t conn_timeout_lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
1132,39787,clockevent,2,memcached.c.clockevent,,memcached.c,struct event clockevent,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1133,67881,mcplib_jump_hash_t,2,proxy_jump_hash.c.mcplib_jump_hash_t,,proxy_jump_hash.c,struct mcplib_jump_hash_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1134,77050,cpoint,2,proxy_ring_hash.c.cpoint,,proxy_ring_hash.c,struct cpoint,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1135,77061,ketama_t,2,proxy_ring_hash.c.ketama_t,,proxy_ring_hash.c,struct ketama_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1136,78548,mmap_fd,2,memcached.h.mmap_fd,,memcached.h,static int mmap_fd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1137,78552,mmap_base,2,memcached.h.mmap_base,,memcached.h,static void* mmap_base,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
1138,78556,slabmem_limit,2,memcached.h.slabmem_limit,,memcached.h,size_t slabmem_limit,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1139,78564,cb_stack,2,memcached.h.cb_stack,,memcached.h,restart_data_cb* cb_stack,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1140,80093,slab_automove,2,slab_automove.c.slab_automove,,slab_automove.c,struct slab_automove,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1141,80800,slab_automove,2,slab_automove_extstore.c.slab_automove,,slab_automove_extstore.c,struct slab_automove,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1142,81611,slabclass,2,slabs.c.slabclass,,slabs.c,static slabclass_t[64] slabclass,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,32,0,1,1,0,0,,0,0,0,0,0,
1143,81618,mem_limit,2,slabs.c.mem_limit,,slabs.c,size_t mem_limit,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
1144,81622,mem_malloced,2,slabs.c.mem_malloced,,slabs.c,size_t mem_malloced,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
1145,81626,mem_limit_reached,2,slabs.c.mem_limit_reached,,slabs.c,bool mem_limit_reached,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1146,81630,power_largest,2,slabs.c.power_largest,,slabs.c,static int power_largest,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
1147,81631,mem_base,2,slabs.c.mem_base,,slabs.c,static void* mem_base,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1148,81635,mem_current,2,slabs.c.mem_current,,slabs.c,static void* mem_current,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1149,81639,mem_avail,2,slabs.c.mem_avail,,slabs.c,size_t mem_avail,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1150,81643,slabs_lock,2,slabs.c.slabs_lock,,slabs.c,pthread_mutex_t slabs_lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,27,0,1,1,0,0,,0,0,0,0,0,
1151,81647,slabs_rebalance_lock,2,slabs.c.slabs_rebalance_lock,,slabs.c,pthread_mutex_t slabs_rebalance_lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
1152,83895,slab_rebalance_cond,2,slabs.c.slab_rebalance_cond,,slabs.c,pthread_cond_t slab_rebalance_cond,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1153,83899,do_run_slab_rebalance_thread,2,slabs.c.do_run_slab_rebalance_thread,,slabs.c,static volatile int do_run_slab_rebalance_thread,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1154,85687,rebalance_tid,2,slabs.c.rebalance_tid,,slabs.c,pthread_t rebalance_tid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1155,85907,prefix_stats,2,stats_prefix.c.prefix_stats,,stats_prefix.c,_prefix_stats*[256] prefix_stats,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
1156,85912,prefix_delimiter,2,stats_prefix.c.prefix_delimiter,,stats_prefix.c,static char prefix_delimiter,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1157,85913,num_prefixes,2,stats_prefix.c.num_prefixes,,stats_prefix.c,static int num_prefixes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1158,85917,total_prefix_size,2,stats_prefix.c.total_prefix_size,,stats_prefix.c,static int total_prefix_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1159,86684,server_pid,2,testapp.c.server_pid,,testapp.c,pid_t server_pid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
1160,86685,port,2,testapp.c.port,,testapp.c,in_port_t port,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
1161,86687,con,2,testapp.c.con,,testapp.c,struct conn* con,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,37,0,1,1,0,0,,0,0,0,0,0,
1162,86691,allow_closed_read,2,testapp.c.allow_closed_read,,testapp.c,bool allow_closed_read,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1163,86695,enable_ssl,2,testapp.c.enable_ssl,,testapp.c,bool enable_ssl,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
1164,92928,hickup_thread_running,2,testapp.c.hickup_thread_running,,testapp.c,volatile bool hickup_thread_running,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1165,94065,worker_hang_lock,2,thread.c.worker_hang_lock,,thread.c,pthread_mutex_t worker_hang_lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1166,94069,threads,2,thread.c.threads,,thread.c,LIBEVENT_THREAD* threads,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1167,94070,init_count,2,thread.c.init_count,,thread.c,static int init_count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1168,94074,init_lock,2,thread.c.init_lock,,thread.c,pthread_mutex_t init_lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1169,94075,init_cond,2,thread.c.init_cond,,thread.c,pthread_cond_t init_cond,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1170,95298,last_thread,2,thread.c.last_thread,,thread.c,static int last_thread,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1171,95303,last_thread_by_napi_id,2,thread.c.last_thread_by_napi_id,,thread.c,static int last_thread_by_napi_id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1172,97239,caught_sig,2,timedrun.c.caught_sig,,timedrun.c,volatile sig_atomic_t caught_sig,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1173,97602,uriencode_map,2,util.c.uriencode_map,,util.c,char*[256] uriencode_map,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1174,97605,uriencode_str,2,util.c.uriencode_str,,util.c,char[768] uriencode_str,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
