,Id,Name,NodeType,Fullname,Signature,Filename,Code,LineNumber,LineNumberEnd,ColumnNumber,ColumnNumberEnd,LineOfCode,NumberOfOperators,SetOfOperators,NumberOfOperands,SetOfOperands,FanIn,FanOut,McCabe,AccCyc,ConCf,ConDf,ConZc,ConRf,ConVal,Parma,ParmaIn,ParmaOut,RetType
0,303538,acorn_version.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1,303539,aliased_buffer-inl.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2,303540,aliased_buffer.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3,303541,aliased_struct-inl.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4,303542,aliased_struct.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5,303543,api\async_resource.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
6,303544,api\callback.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7,303545,api\embed_helpers.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8,303546,api\encoding.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
9,303547,api\environment.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
10,303548,api\exceptions.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
11,303549,api\hooks.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
12,303550,api\utils.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
13,303551,async_wrap-inl.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
14,303552,async_wrap.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
15,303553,async_wrap.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
16,303554,base64-inl.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
17,303555,base64.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
18,303556,base64_version.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
19,303557,base_object-inl.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
20,303558,base_object.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
21,303559,base_object.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
22,303560,base_object_types.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
23,303561,blob_serializer_deserializer-inl.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
24,303562,blob_serializer_deserializer.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
25,303563,callback_queue-inl.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
26,303564,callback_queue.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
27,303565,cares_wrap.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
28,303566,cares_wrap.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
29,303567,cjs_module_lexer_version.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
30,303568,cleanup_queue-inl.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
31,303569,cleanup_queue.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
32,303570,cleanup_queue.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
33,303571,connect_wrap.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
34,303572,connect_wrap.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
35,303573,connection_wrap.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
36,303574,connection_wrap.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
37,303575,crypto\crypto_aes.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
38,303576,crypto\crypto_aes.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
39,303577,crypto\crypto_bio.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
40,303578,crypto\crypto_bio.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
41,303579,crypto\crypto_cipher.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
42,303580,crypto\crypto_cipher.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
43,303581,crypto\crypto_clienthello-inl.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
44,303582,crypto\crypto_clienthello.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
45,303583,crypto\crypto_clienthello.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
46,303584,crypto\crypto_common.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
47,303585,crypto\crypto_common.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
48,303586,crypto\crypto_context.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
49,303587,crypto\crypto_context.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
50,303588,crypto\crypto_dh.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
51,303589,crypto\crypto_dh.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
52,303590,crypto\crypto_dsa.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
53,303591,crypto\crypto_dsa.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
54,303592,crypto\crypto_ec.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
55,303593,crypto\crypto_ec.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
56,303594,crypto\crypto_hash.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
57,303595,crypto\crypto_hash.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
58,303596,crypto\crypto_hkdf.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
59,303597,crypto\crypto_hkdf.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
60,303598,crypto\crypto_hmac.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
61,303599,crypto\crypto_hmac.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
62,303600,crypto\crypto_keygen.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
63,303601,crypto\crypto_keygen.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
64,303602,crypto\crypto_keys.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
65,303603,crypto\crypto_keys.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
66,303604,crypto\crypto_pbkdf2.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
67,303605,crypto\crypto_pbkdf2.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
68,303606,crypto\crypto_random.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
69,303607,crypto\crypto_random.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
70,303608,crypto\crypto_rsa.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
71,303609,crypto\crypto_rsa.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
72,303610,crypto\crypto_scrypt.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
73,303611,crypto\crypto_scrypt.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
74,303612,crypto\crypto_sig.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
75,303613,crypto\crypto_sig.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
76,303614,crypto\crypto_spkac.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
77,303615,crypto\crypto_spkac.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
78,303616,crypto\crypto_timing.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
79,303617,crypto\crypto_timing.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
80,303618,crypto\crypto_tls.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
81,303619,crypto\crypto_tls.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
82,303620,crypto\crypto_util.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
83,303621,crypto\crypto_util.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
84,303622,crypto\crypto_x509.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
85,303623,crypto\crypto_x509.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
86,303624,dataqueue\queue.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
87,303625,dataqueue\queue.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
88,303626,debug_utils-inl.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
89,303627,debug_utils.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
90,303628,debug_utils.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
91,303629,diagnosticfilename-inl.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
92,303630,encoding_binding.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
93,303631,encoding_binding.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
94,303632,env-inl.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
95,303633,env.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
96,303634,env.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
97,303635,env_properties.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
98,303636,fs_event_wrap.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
99,303637,handle_wrap.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
100,303638,handle_wrap.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
101,303639,heap_utils.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
102,303640,histogram-inl.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
103,303641,histogram.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
104,303642,histogram.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
105,303643,inspector\main_thread_interface.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
106,303644,inspector\main_thread_interface.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
107,303645,inspector\node_string.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
108,303646,inspector\node_string.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
109,303647,inspector\runtime_agent.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
110,303648,inspector\runtime_agent.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
111,303649,inspector\tracing_agent.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
112,303650,inspector\tracing_agent.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
113,303651,inspector\worker_agent.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
114,303652,inspector\worker_agent.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
115,303653,inspector\worker_inspector.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
116,303654,inspector\worker_inspector.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
117,303655,inspector_agent.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
118,303656,inspector_agent.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
119,303657,inspector_io.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
120,303658,inspector_io.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
121,303659,inspector_js_api.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
122,303660,inspector_profiler.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
123,303661,inspector_profiler.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
124,303662,inspector_socket.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
125,303663,inspector_socket.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
126,303664,inspector_socket_server.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
127,303665,inspector_socket_server.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
128,303666,js_native_api.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
129,303667,js_native_api_types.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
130,303668,js_native_api_v8.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
131,303669,js_native_api_v8.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
132,303670,js_native_api_v8_internals.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
133,303671,js_stream.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
134,303672,js_stream.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
135,303673,js_udp_wrap.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
136,303674,json_parser.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
137,303675,json_parser.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
138,303676,json_utils.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
139,303677,json_utils.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
140,303678,large_pages\node_large_page.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
141,303679,large_pages\node_large_page.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
142,303680,memory_tracker-inl.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
143,303681,memory_tracker.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
144,303682,module_wrap.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
145,303683,module_wrap.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
146,303684,node.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
147,303685,node.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
148,303686,node_api.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
149,303687,node_api.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
150,303688,node_api_internals.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
151,303689,node_api_types.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
152,303690,node_binding.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
153,303691,node_binding.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
154,303692,node_blob.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
155,303693,node_blob.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
156,303694,node_bob-inl.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
157,303695,node_bob.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
158,303696,node_buffer.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
159,303697,node_buffer.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
160,303698,node_builtins.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
161,303699,node_builtins.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
162,303700,node_config.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
163,303701,node_constants.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
164,303702,node_constants.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
165,303703,node_context_data.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
166,303704,node_contextify.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
167,303705,node_contextify.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
168,303706,node_credentials.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
169,303707,node_crypto.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
170,303708,node_crypto.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
171,303709,node_dir.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
172,303710,node_dir.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
173,303711,node_env_var.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
174,303712,node_errors.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
175,303713,node_errors.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
176,303714,node_exit_code.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
177,303715,node_external_reference.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
178,303716,node_external_reference.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
179,303717,node_file-inl.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
180,303718,node_file.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
181,303719,node_file.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
182,303720,node_http2.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
183,303721,node_http2.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
184,303722,node_http2_state.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
185,303723,node_http_common-inl.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
186,303724,node_http_common.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
187,303725,node_http_parser.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
188,303726,node_i18n.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
189,303727,node_i18n.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
190,303728,node_internals.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
191,303729,node_main.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
192,303730,node_main_instance.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
193,303731,node_main_instance.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
194,303732,node_mem-inl.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
195,303733,node_mem.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
196,303734,node_messaging.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
197,303735,node_messaging.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
198,303736,node_metadata.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
199,303737,node_metadata.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
200,303738,node_mutex.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
201,303739,node_object_wrap.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
202,303740,node_options-inl.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
203,303741,node_options.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
204,303742,node_options.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
205,303743,node_os.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
206,303744,node_perf.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
207,303745,node_perf.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
208,303746,node_perf_common.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
209,303747,node_platform.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
210,303748,node_platform.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
211,303749,node_postmortem_metadata.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
212,303750,node_process-inl.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
213,303751,node_process.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
214,303752,node_process_events.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
215,303753,node_process_methods.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
216,303754,node_process_object.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
217,303755,node_realm-inl.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
218,303756,node_realm.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
219,303757,node_realm.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
220,303758,node_report.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
221,303759,node_report.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
222,303760,node_report_module.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
223,303761,node_report_utils.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
224,303762,node_revert.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
225,303763,node_root_certs.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
226,303764,node_sea.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
227,303765,node_sea.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
228,303766,node_serdes.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
229,303767,node_shadow_realm.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
230,303768,node_shadow_realm.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
231,303769,node_snapshot_builder.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
232,303770,node_snapshot_stub.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
233,303771,node_snapshotable.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
234,303772,node_snapshotable.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
235,303773,node_sockaddr-inl.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
236,303774,node_sockaddr.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
237,303775,node_sockaddr.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
238,303776,node_stat_watcher.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
239,303777,node_stat_watcher.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
240,303778,node_symbols.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
241,303779,node_task_queue.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
242,303780,node_threadsafe_cow-inl.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
243,303781,node_threadsafe_cow.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
244,303782,node_trace_events.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
245,303783,node_types.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
246,303784,node_union_bytes.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
247,303785,node_url.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
248,303786,node_url.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
249,303787,node_util.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
250,303788,node_util.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
251,303789,node_v8.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
252,303790,node_v8.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
253,303791,node_v8_platform-inl.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
254,303792,node_version.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
255,303793,node_wasi.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
256,303794,node_wasi.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
257,303795,node_wasm_web_api.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
258,303796,node_wasm_web_api.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
259,303797,node_watchdog.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
260,303798,node_watchdog.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
261,303799,node_worker.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
262,303800,node_worker.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
263,303801,node_zlib.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
264,303802,permission\child_process_permission.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
265,303803,permission\child_process_permission.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
266,303804,permission\fs_permission.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
267,303805,permission\fs_permission.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
268,303806,permission\permission.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
269,303807,permission\permission.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
270,303808,permission\permission_base.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
271,303809,permission\worker_permission.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
272,303810,permission\worker_permission.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
273,303811,pipe_wrap.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
274,303812,pipe_wrap.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
275,303813,process_wrap.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
276,303814,quic\bindingdata.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
277,303815,quic\bindingdata.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
278,303816,quic\cid.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
279,303817,quic\cid.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
280,303818,quic\data.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
281,303819,quic\data.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
282,303820,quic\defs.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
283,303821,quic\logstream.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
284,303822,quic\logstream.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
285,303823,quic\packet.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
286,303824,quic\packet.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
287,303825,quic\preferredaddress.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
288,303826,quic\preferredaddress.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
289,303827,quic\sessionticket.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
290,303828,quic\sessionticket.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
291,303829,quic\tlscontext.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
292,303830,quic\tlscontext.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
293,303831,quic\tokens.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
294,303832,quic\tokens.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
295,303833,quic\transportparams.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
296,303834,quic\transportparams.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
297,303835,req_wrap-inl.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
298,303836,req_wrap.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
299,303837,signal_wrap.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
300,303838,spawn_sync.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
301,303839,spawn_sync.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
302,303840,stream_base-inl.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
303,303841,stream_base.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
304,303842,stream_base.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
305,303843,stream_pipe.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
306,303844,stream_pipe.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
307,303845,stream_wrap.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
308,303846,stream_wrap.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
309,303847,string_bytes.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
310,303848,string_bytes.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
311,303849,string_decoder-inl.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
312,303850,string_decoder.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
313,303851,string_decoder.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
314,303852,string_search.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
315,303853,tcp_wrap.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
316,303854,tcp_wrap.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
317,303855,threadpoolwork-inl.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
318,303856,timer_wrap-inl.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
319,303857,timer_wrap.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
320,303858,timer_wrap.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
321,303859,timers.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
322,303860,timers.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
323,303861,tracing\agent.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
324,303862,tracing\agent.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
325,303863,tracing\node_trace_buffer.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
326,303864,tracing\node_trace_buffer.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
327,303865,tracing\node_trace_writer.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
328,303866,tracing\node_trace_writer.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
329,303867,tracing\trace_event.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
330,303868,tracing\trace_event.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
331,303869,tracing\trace_event_common.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
332,303870,tracing\traced_value.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
333,303871,tracing\traced_value.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
334,303872,tty_wrap.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
335,303873,tty_wrap.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
336,303874,udp_wrap.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
337,303875,udp_wrap.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
338,303876,undici_version.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
339,303877,util-inl.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
340,303878,util.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
341,303879,util.hpp,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
342,303880,uv.cc,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
343,1463,platform,3,node.Impl.platform,,api\embed_helpers.cc,* platform = nullptr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
344,1464,loop,3,node.Impl.loop,,api\embed_helpers.cc,loop,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
345,1465,allocator,3,node.Impl.allocator,,api\embed_helpers.cc,allocator,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
346,1466,snapshot_creator,3,node.Impl.snapshot_creator,,api\embed_helpers.cc,snapshot_creator,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
347,1467,isolate,3,node.Impl.isolate,,api\embed_helpers.cc,* isolate = nullptr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
348,1468,isolate_data,3,node.Impl.isolate_data,,api\embed_helpers.cc,isolate_data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
349,1469,env,3,node.Impl.env,,api\embed_helpers.cc,env,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
350,1470,main_context,3,node.Impl.main_context,,api\embed_helpers.cc,main_context,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
351,6112,env,3,node.AsyncCleanupHookInfo.env,,api\hooks.cc,* env,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
352,6113,fun,3,node.AsyncCleanupHookInfo.fun,,api\hooks.cc,fun,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
353,6114,arg,3,node.AsyncCleanupHookInfo.arg,,api\hooks.cc,* arg,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
354,6115,started,3,node.AsyncCleanupHookInfo.started,,api\hooks.cc,started = false,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
355,6116,self,3,node.AsyncCleanupHookInfo.self,,api\hooks.cc,self,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
356,6125,info,3,node.ACHHandle.info,,api\hooks.cc,info,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
357,7186,asyncId,3,node.DestroyParam.asyncId,,async_wrap.cc,asyncId,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
358,7187,env,3,node.DestroyParam.env,,async_wrap.cc,* env,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
359,7188,target,3,node.DestroyParam.target,,async_wrap.cc,target,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
360,7189,propBag,3,node.DestroyParam.propBag,,async_wrap.cc,propBag,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
361,71401,,3,node.anonymous_namespace_5.DataQueueImpl.nan,,dataqueue\queue.cc,(DataQueue),-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
362,71403,,3,node.anonymous_namespace_5.DataQueueImpl.nan,,dataqueue\queue.cc,(DataQueueImpl),-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
363,71405,entries_,3,node.anonymous_namespace_5.DataQueueImpl.entries_,,dataqueue\queue.cc,entries_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
364,71406,idempotent_,3,node.anonymous_namespace_5.DataQueueImpl.idempotent_,,dataqueue\queue.cc,idempotent_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
365,71407,size_,3,node.anonymous_namespace_5.DataQueueImpl.size_,,dataqueue\queue.cc,size_ = std::nullopt,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
366,71408,capped_size_,3,node.anonymous_namespace_5.DataQueueImpl.capped_size_,,dataqueue\queue.cc,capped_size_ = std::nullopt,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
367,71409,locked_to_reader_,3,node.anonymous_namespace_5.DataQueueImpl.locked_to_reader_,,dataqueue\queue.cc,locked_to_reader_ = false,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
368,71644,current_index_,3,node.anonymous_namespace_25.IdempotentDataQueueReader.current_index_,,dataqueue\queue.cc,current_index_ = std::nullopt,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
369,71645,current_reader_,3,node.anonymous_namespace_25.IdempotentDataQueueReader.current_reader_,,dataqueue\queue.cc,current_reader_ = nullptr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
370,71646,ended_,3,node.anonymous_namespace_25.IdempotentDataQueueReader.ended_,,dataqueue\queue.cc,ended_ = false,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
371,71647,pull_pending_,3,node.anonymous_namespace_25.IdempotentDataQueueReader.pull_pending_,,dataqueue\queue.cc,pull_pending_ = false,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
372,71936,current_reader_,3,node.anonymous_namespace_39.NonIdempotentDataQueueReader.current_reader_,,dataqueue\queue.cc,current_reader_ = nullptr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
373,71937,ended_,3,node.anonymous_namespace_39.NonIdempotentDataQueueReader.ended_,,dataqueue\queue.cc,ended_ = false,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
374,71938,pull_pending_,3,node.anonymous_namespace_39.NonIdempotentDataQueueReader.pull_pending_,,dataqueue\queue.cc,pull_pending_ = false,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
375,72109,backing_store,3,node.anonymous_namespace_72.InMemoryEntry.InMemoryFunctor.backing_store,,dataqueue\queue.cc,backing_store,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
376,72207,ended_,3,node.anonymous_namespace_74.InMemoryEntry.InMemoryReader.ended_,,dataqueue\queue.cc,ended_ = false,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
377,72351,,3,node.anonymous_namespace_71.InMemoryEntry.nan,,dataqueue\queue.cc,(InMemoryEntry),-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
378,72353,,3,node.anonymous_namespace_71.InMemoryEntry.nan,,dataqueue\queue.cc,(InMemoryEntry),-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
379,72355,backing_store_,3,node.anonymous_namespace_71.InMemoryEntry.backing_store_,,dataqueue\queue.cc,backing_store_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
380,72356,offset_,3,node.anonymous_namespace_71.InMemoryEntry.offset_,,dataqueue\queue.cc,offset_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
381,72357,byte_length_,3,node.anonymous_namespace_71.InMemoryEntry.byte_length_,,dataqueue\queue.cc,byte_length_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
382,72477,,3,node.anonymous_namespace_90.DataQueueEntry.nan,,dataqueue\queue.cc,(DataQueueEntry),-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
383,72479,,3,node.anonymous_namespace_90.DataQueueEntry.nan,,dataqueue\queue.cc,(DataQueueEntry),-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
384,72481,data_queue_,3,node.anonymous_namespace_90.DataQueueEntry.data_queue_,,dataqueue\queue.cc,data_queue_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
385,72680,path_,3,node.anonymous_namespace_105.FdEntry.path_,,dataqueue\queue.cc,path_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
386,72681,stat_,3,node.anonymous_namespace_105.FdEntry.stat_,,dataqueue\queue.cc,stat_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
387,72682,start_,3,node.anonymous_namespace_105.FdEntry.start_,,dataqueue\queue.cc,start_ = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
388,72683,end_,3,node.anonymous_namespace_105.FdEntry.end_,,dataqueue\queue.cc,end_ = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
389,73129,env_,3,node.anonymous_namespace_118.FdEntry.ReaderImpl.env_,,dataqueue\queue.cc,* env_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
390,73130,handle_,3,node.anonymous_namespace_118.FdEntry.ReaderImpl.handle_,,dataqueue\queue.cc,handle_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
391,73131,entry_,3,node.anonymous_namespace_118.FdEntry.ReaderImpl.entry_,,dataqueue\queue.cc,* entry_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
392,73132,pending_pulls_,3,node.anonymous_namespace_118.FdEntry.ReaderImpl.pending_pulls_,,dataqueue\queue.cc,pending_pulls_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
393,73133,reading_,3,node.anonymous_namespace_118.FdEntry.ReaderImpl.reading_,,dataqueue\queue.cc,reading_ = false,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
394,73134,ended_,3,node.anonymous_namespace_118.FdEntry.ReaderImpl.ended_,,dataqueue\queue.cc,ended_ = false,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
395,74011,current_process_,3,node.Win32SymbolDebuggingContext.current_process_,,debug_utils.cc,current_process_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
396,80544,handle_,3,node.anonymous_namespace_1.FSEventWrap.handle_,,fs_event_wrap.cc,handle_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
397,80546,encoding_,3,node.anonymous_namespace_1.FSEventWrap.encoding_,,fs_event_wrap.cc,encoding_ = kDefaultEncoding,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
398,81765,persistent_,3,node.heap.JSGraphJSNode.persistent_,,heap_utils.cc,persistent_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
399,82406,isolate_,3,node.heap.JSGraph.isolate_,,heap_utils.cc,* isolate_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,15,0,1,1,0,0,,0,0,0,0,0,
400,82407,nodes_,3,node.heap.JSGraph.nodes_,,heap_utils.cc,nodes_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
401,82408,engine_nodes_,3,node.heap.JSGraph.engine_nodes_,,heap_utils.cc,engine_nodes_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
402,82409,edges_,3,node.heap.JSGraph.edges_,,heap_utils.cc,edges_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
403,82556,fd_,3,node.heap.anonymous_namespace_1.FileOutputStream.fd_,,heap_utils.cc,fd_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
404,82557,req_,3,node.heap.anonymous_namespace_1.FileOutputStream.req_,,heap_utils.cc,* req_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
405,82558,status_,3,node.heap.anonymous_namespace_1.FileOutputStream.status_,,heap_utils.cc,status_ = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
406,82731,,3,node.heap.anonymous_namespace_7.HeapSnapshotStream.nan,,heap_utils.cc,(HeapSnapshotStream),-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
407,82733,,3,node.heap.anonymous_namespace_7.HeapSnapshotStream.nan,,heap_utils.cc,(HeapSnapshotStream),-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
408,82735,snapshot_,3,node.heap.anonymous_namespace_7.HeapSnapshotStream.snapshot_,,heap_utils.cc,snapshot_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
409,86007,object_,3,node.inspector.anonymous_namespace_3.DeletableWrapper.object_,,inspector\main_thread_interface.cc,object_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
410,86049,object_id_,3,node.inspector.anonymous_namespace_8.CreateObjectRequest.object_id_,,inspector\main_thread_interface.cc,object_id_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
411,86050,factory_,3,node.inspector.anonymous_namespace_8.CreateObjectRequest.factory_,,inspector\main_thread_interface.cc,factory_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
412,86088,object_id_,3,node.inspector.anonymous_namespace_12.DeleteRequest.object_id_,,inspector\main_thread_interface.cc,object_id_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
413,86108,id_,3,node.inspector.anonymous_namespace_15.CallRequest.id_,,inspector\main_thread_interface.cc,id_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
414,86109,fn_,3,node.inspector.anonymous_namespace_15.CallRequest.fn_,,inspector\main_thread_interface.cc,fn_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
415,86217,thread_,3,node.inspector.anonymous_namespace_18.AnotherThreadObjectReference.thread_,,inspector\main_thread_interface.cc,thread_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
416,86218,object_id_,3,node.inspector.anonymous_namespace_18.AnotherThreadObjectReference.object_id_,,inspector\main_thread_interface.cc,object_id_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
417,86285,thread_,3,node.inspector.anonymous_namespace_26.MainThreadSessionState.thread_,,inspector\main_thread_interface.cc,* thread_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
418,86286,prevent_shutdown_,3,node.inspector.anonymous_namespace_26.MainThreadSessionState.prevent_shutdown_,,inspector\main_thread_interface.cc,prevent_shutdown_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
419,86287,session_,3,node.inspector.anonymous_namespace_26.MainThreadSessionState.session_,,inspector\main_thread_interface.cc,session_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
420,86328,state_,3,node.inspector.anonymous_namespace_31.CrossThreadInspectorSession.state_,,inspector\main_thread_interface.cc,state_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
421,86345,thread_,3,node.inspector.anonymous_namespace_34.ThreadSafeDelegate.thread_,,inspector\main_thread_interface.cc,thread_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
422,86346,delegate_,3,node.inspector.anonymous_namespace_34.ThreadSafeDelegate.delegate_,,inspector\main_thread_interface.cc,delegate_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
423,86855,main_thread_,3,node.inspector.MainThreadHandle.main_thread_,,inspector\main_thread_interface.hpp,* main_thread_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
424,86856,block_lock_,3,node.inspector.MainThreadHandle.block_lock_,,inspector\main_thread_interface.hpp,block_lock_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
425,86857,next_session_id_,3,node.inspector.MainThreadHandle.next_session_id_,,inspector\main_thread_interface.hpp,next_session_id_ = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
426,86858,next_object_id_,3,node.inspector.MainThreadHandle.next_object_id_,,inspector\main_thread_interface.hpp,next_object_id_ = {1},-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
427,86925,requests_,3,node.inspector.MainThreadInterface.requests_,,inspector\main_thread_interface.hpp,requests_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
428,86926,requests_lock_,3,node.inspector.MainThreadInterface.requests_lock_,,inspector\main_thread_interface.hpp,requests_lock_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
429,86927,dispatching_message_queue_,3,node.inspector.MainThreadInterface.dispatching_message_queue_,,inspector\main_thread_interface.hpp,dispatching_message_queue_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
430,86928,dispatching_messages_,3,node.inspector.MainThreadInterface.dispatching_messages_,,inspector\main_thread_interface.hpp,dispatching_messages_ = false,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
431,86929,incoming_message_cond_,3,node.inspector.MainThreadInterface.incoming_message_cond_,,inspector\main_thread_interface.hpp,incoming_message_cond_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
432,86930,agent_,3,node.inspector.MainThreadInterface.agent_,,inspector\main_thread_interface.hpp,* const agent_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
433,86931,handle_,3,node.inspector.MainThreadInterface.handle_,,inspector\main_thread_interface.hpp,handle_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
434,86932,managed_objects_,3,node.inspector.MainThreadInterface.managed_objects_,,inspector\main_thread_interface.hpp,managed_objects_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
435,87799,frontend_,3,node.inspector.protocol.RuntimeAgent.frontend_,,inspector\runtime_agent.hpp,frontend_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
436,87800,notify_when_waiting_for_disconnect_,3,node.inspector.protocol.RuntimeAgent.notify_when_waiting_for_disconnect_,,inspector\runtime_agent.hpp,notify_when_waiting_for_disconnect_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
437,87842,frontend_,3,node.inspector.protocol.anonymous_namespace_2.DeletableFrontendWrapper.frontend_,,inspector\tracing_agent.cc,frontend_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
438,87874,object_id_,3,node.inspector.protocol.anonymous_namespace_5.CreateFrontendWrapperRequest.object_id_,,inspector\tracing_agent.cc,object_id_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
439,87875,frontend_wrapper_,3,node.inspector.protocol.anonymous_namespace_5.CreateFrontendWrapperRequest.frontend_wrapper_,,inspector\tracing_agent.cc,frontend_wrapper_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
440,87892,object_id_,3,node.inspector.protocol.anonymous_namespace_8.DestroyFrontendWrapperRequest.object_id_,,inspector\tracing_agent.cc,object_id_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
441,87938,object_id_,3,node.inspector.protocol.anonymous_namespace_11.SendMessageRequest.object_id_,,inspector\tracing_agent.cc,object_id_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
442,87939,message_,3,node.inspector.protocol.anonymous_namespace_11.SendMessageRequest.message_,,inspector\tracing_agent.cc,message_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
443,88024,json_writer_,3,node.inspector.protocol.anonymous_namespace_14.InspectorTraceWriter.json_writer_,,inspector\tracing_agent.cc,json_writer_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
444,88025,stream_,3,node.inspector.protocol.anonymous_namespace_14.InspectorTraceWriter.stream_,,inspector\tracing_agent.cc,stream_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
445,88026,frontend_object_id_,3,node.inspector.protocol.anonymous_namespace_14.InspectorTraceWriter.frontend_object_id_,,inspector\tracing_agent.cc,frontend_object_id_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
446,88027,main_thread_,3,node.inspector.protocol.anonymous_namespace_14.InspectorTraceWriter.main_thread_,,inspector\tracing_agent.cc,main_thread_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
447,88426,env_,3,node.inspector.protocol.TracingAgent.env_,,inspector\tracing_agent.hpp,* env_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
448,88427,main_thread_,3,node.inspector.protocol.TracingAgent.main_thread_,,inspector\tracing_agent.hpp,main_thread_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
449,88428,trace_writer_,3,node.inspector.protocol.TracingAgent.trace_writer_,,inspector\tracing_agent.hpp,trace_writer_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
450,88429,frontend_object_id_,3,node.inspector.protocol.TracingAgent.frontend_object_id_,,inspector\tracing_agent.hpp,frontend_object_id_ = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
451,88430,frontend_,3,node.inspector.protocol.TracingAgent.frontend_,,inspector\tracing_agent.hpp,frontend_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
452,88486,frontend_,3,node.inspector.protocol.NodeWorkers.frontend_,,inspector\worker_agent.cc,frontend_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
453,88487,thread_,3,node.inspector.protocol.NodeWorkers.thread_,,inspector\worker_agent.cc,thread_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
454,88488,sessions_,3,node.inspector.protocol.NodeWorkers.sessions_,,inspector\worker_agent.cc,sessions_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
455,88489,next_target_id_,3,node.inspector.protocol.NodeWorkers.next_target_id_,,inspector\worker_agent.cc,next_target_id_ = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
456,88520,workers_,3,node.inspector.protocol.anonymous_namespace_1.AgentWorkerInspectorDelegate.workers_,,inspector\worker_agent.cc,workers_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
457,88558,id_,3,node.inspector.protocol.anonymous_namespace_4.ParentInspectorSessionDelegate.id_,,inspector\worker_agent.cc,id_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
458,88559,workers_,3,node.inspector.protocol.anonymous_namespace_4.ParentInspectorSessionDelegate.workers_,,inspector\worker_agent.cc,workers_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
459,88946,frontend_,3,node.inspector.protocol.WorkerAgent.frontend_,,inspector\worker_agent.hpp,frontend_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
460,88947,manager_,3,node.inspector.protocol.WorkerAgent.manager_,,inspector\worker_agent.hpp,manager_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
461,88948,event_handle_,3,node.inspector.protocol.WorkerAgent.event_handle_,,inspector\worker_agent.hpp,event_handle_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
462,88949,workers_,3,node.inspector.protocol.WorkerAgent.workers_,,inspector\worker_agent.hpp,workers_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
463,89023,id_,3,node.inspector.anonymous_namespace_1.WorkerStartedRequest.id_,,inspector\worker_inspector.cc,id_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
464,89024,info_,3,node.inspector.anonymous_namespace_1.WorkerStartedRequest.info_,,inspector\worker_inspector.cc,info_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
465,89025,waiting_,3,node.inspector.anonymous_namespace_1.WorkerStartedRequest.waiting_,,inspector\worker_inspector.cc,waiting_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
466,89074,worker_id_,3,node.inspector.anonymous_namespace_6.WorkerFinishedRequest.worker_id_,,inspector\worker_inspector.cc,worker_id_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
467,89363,manager_,3,node.inspector.WorkerManagerEventHandle.manager_,,inspector\worker_inspector.hpp,manager_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
468,89364,id_,3,node.inspector.WorkerManagerEventHandle.id_,,inspector\worker_inspector.hpp,id_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
469,89373,title,3,node.inspector.WorkerInfo.title,,inspector\worker_inspector.hpp,title,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
470,89374,url,3,node.inspector.WorkerInfo.url,,inspector\worker_inspector.hpp,url,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
471,89375,worker_thread,3,node.inspector.WorkerInfo.worker_thread,,inspector\worker_inspector.hpp,worker_thread,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
472,89435,id_,3,node.inspector.ParentInspectorHandle.id_,,inspector\worker_inspector.hpp,id_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
473,89436,url_,3,node.inspector.ParentInspectorHandle.url_,,inspector\worker_inspector.hpp,url_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
474,89437,parent_thread_,3,node.inspector.ParentInspectorHandle.parent_thread_,,inspector\worker_inspector.hpp,parent_thread_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
475,89438,wait_,3,node.inspector.ParentInspectorHandle.wait_,,inspector\worker_inspector.hpp,wait_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
476,89439,name_,3,node.inspector.ParentInspectorHandle.name_,,inspector\worker_inspector.hpp,name_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
477,89487,thread_,3,node.inspector.WorkerManager.thread_,,inspector\worker_inspector.hpp,thread_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
478,89488,children_,3,node.inspector.WorkerManager.children_,,inspector\worker_inspector.hpp,children_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
479,89489,delegates_,3,node.inspector.WorkerManager.delegates_,,inspector\worker_inspector.hpp,delegates_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
480,89490,delegates_waiting_on_start_,3,node.inspector.WorkerManager.delegates_waiting_on_start_,,inspector\worker_inspector.hpp,delegates_waiting_on_start_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
481,89491,next_delegate_id_,3,node.inspector.WorkerManager.next_delegate_id_,,inspector\worker_inspector.hpp,next_delegate_id_ = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
482,90081,runtime_agent_,3,node.inspector.anonymous_namespace_17.ChannelImpl.runtime_agent_,,inspector_agent.cc,runtime_agent_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
483,90082,tracing_agent_,3,node.inspector.anonymous_namespace_17.ChannelImpl.tracing_agent_,,inspector_agent.cc,tracing_agent_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
484,90083,worker_agent_,3,node.inspector.anonymous_namespace_17.ChannelImpl.worker_agent_,,inspector_agent.cc,worker_agent_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
485,90084,delegate_,3,node.inspector.anonymous_namespace_17.ChannelImpl.delegate_,,inspector_agent.cc,delegate_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
486,90085,session_,3,node.inspector.anonymous_namespace_17.ChannelImpl.session_,,inspector_agent.cc,session_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
487,90086,node_dispatcher_,3,node.inspector.anonymous_namespace_17.ChannelImpl.node_dispatcher_,,inspector_agent.cc,node_dispatcher_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
488,90087,prevent_shutdown_,3,node.inspector.anonymous_namespace_17.ChannelImpl.prevent_shutdown_,,inspector_agent.cc,prevent_shutdown_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
489,90088,retaining_context_,3,node.inspector.anonymous_namespace_17.ChannelImpl.retaining_context_,,inspector_agent.cc,retaining_context_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
490,90105,session_id_,3,node.inspector.anonymous_namespace_33.SameThreadInspectorSession.session_id_,,inspector_agent.cc,session_id_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
491,90106,client_,3,node.inspector.anonymous_namespace_33.SameThreadInspectorSession.client_,,inspector_agent.cc,client_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
492,91032,env_,3,node.inspector.NodeInspectorClient.env_,,inspector_agent.cc,* env_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
493,91033,is_main_,3,node.inspector.NodeInspectorClient.is_main_,,inspector_agent.cc,is_main_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
494,91034,running_nested_loop_,3,node.inspector.NodeInspectorClient.running_nested_loop_,,inspector_agent.cc,running_nested_loop_ = false,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
495,91035,client_,3,node.inspector.NodeInspectorClient.client_,,inspector_agent.cc,client_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
496,91036,timers_,3,node.inspector.NodeInspectorClient.timers_,,inspector_agent.cc,timers_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
497,91037,channels_,3,node.inspector.NodeInspectorClient.channels_,,inspector_agent.cc,channels_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
498,91038,next_session_id_,3,node.inspector.NodeInspectorClient.next_session_id_,,inspector_agent.cc,next_session_id_ = 1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
499,91039,waiting_for_resume_,3,node.inspector.NodeInspectorClient.waiting_for_resume_,,inspector_agent.cc,waiting_for_resume_ = false,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
500,91040,waiting_for_frontend_,3,node.inspector.NodeInspectorClient.waiting_for_frontend_,,inspector_agent.cc,waiting_for_frontend_ = false,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
501,91041,waiting_for_sessions_disconnect_,3,node.inspector.NodeInspectorClient.waiting_for_sessions_disconnect_,,inspector_agent.cc,waiting_for_sessions_disconnect_ = false,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
502,91042,interface_,3,node.inspector.NodeInspectorClient.interface_,,inspector_agent.cc,interface_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
503,91043,worker_manager_,3,node.inspector.NodeInspectorClient.worker_manager_,,inspector_agent.cc,worker_manager_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
504,92058,kKill,3,node.inspector.anonymous_namespace_3.TransportAction.kKill,,inspector_io.cc,kKill,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
505,92059,kSendMessage,3,node.inspector.anonymous_namespace_3.TransportAction.kSendMessage,,inspector_io.cc,kSendMessage,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
506,92060,kStop,3,node.inspector.anonymous_namespace_3.TransportAction.kStop,,inspector_io.cc,kStop,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
507,92223,action_,3,node.inspector.anonymous_namespace_6.RequestToServer.action_,,inspector_io.cc,action_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
508,92224,session_id_,3,node.inspector.anonymous_namespace_6.RequestToServer.session_id_,,inspector_io.cc,session_id_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
509,92225,message_,3,node.inspector.anonymous_namespace_6.RequestToServer.message_,,inspector_io.cc,message_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
510,92359,handle_,3,node.inspector.anonymous_namespace_9.RequestQueueData.handle_,,inspector_io.cc,handle_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
511,92360,async_,3,node.inspector.anonymous_namespace_9.RequestQueueData.async_,,inspector_io.cc,async_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
512,92361,server_,3,node.inspector.anonymous_namespace_9.RequestQueueData.server_,,inspector_io.cc,* server_ = nullptr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
513,92362,messages_,3,node.inspector.anonymous_namespace_9.RequestQueueData.messages_,,inspector_io.cc,messages_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
514,92363,state_lock_,3,node.inspector.anonymous_namespace_9.RequestQueueData.state_lock_,,inspector_io.cc,state_lock_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
515,92364,incoming_message_cond_,3,node.inspector.anonymous_namespace_9.RequestQueueData.incoming_message_cond_,,inspector_io.cc,incoming_message_cond_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
516,92425,data_,3,node.inspector.RequestQueue.data_,,inspector_io.cc,* data_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
517,92426,lock_,3,node.inspector.RequestQueue.lock_,,inspector_io.cc,lock_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
518,92452,request_queue_,3,node.inspector.IoSessionDelegate.request_queue_,,inspector_io.cc,request_queue_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
519,92453,id_,3,node.inspector.IoSessionDelegate.id_,,inspector_io.cc,id_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
520,92509,request_queue_,3,node.inspector.InspectorIoDelegate.request_queue_,,inspector_io.cc,request_queue_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
521,92510,main_thread_,3,node.inspector.InspectorIoDelegate.main_thread_,,inspector_io.cc,main_thread_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
522,92511,sessions_,3,node.inspector.InspectorIoDelegate.sessions_,,inspector_io.cc,sessions_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
523,92512,script_name_,3,node.inspector.InspectorIoDelegate.script_name_,,inspector_io.cc,script_name_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
524,92513,script_path_,3,node.inspector.InspectorIoDelegate.script_path_,,inspector_io.cc,script_path_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
525,92514,target_id_,3,node.inspector.InspectorIoDelegate.target_id_,,inspector_io.cc,target_id_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
526,93106,env_,3,node.inspector.anonymous_namespace_25.JSBindingsConnection.JSBindingsSessionDelegate.env_,,inspector_js_api.cc,* env_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
527,93107,connection_,3,node.inspector.anonymous_namespace_25.JSBindingsConnection.JSBindingsSessionDelegate.connection_,,inspector_js_api.cc,connection_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
528,93368,,3,node.inspector.anonymous_namespace_24.JSBindingsConnection.nan,,inspector_js_api.cc,(JSBindingsConnection),-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
529,93370,,3,node.inspector.anonymous_namespace_24.JSBindingsConnection.nan,,inspector_js_api.cc,(JSBindingsConnection),-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
530,93378,session_,3,node.inspector.anonymous_namespace_24.JSBindingsConnection.session_,,inspector_js_api.cc,session_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
531,93379,callback_,3,node.inspector.anonymous_namespace_24.JSBindingsConnection.callback_,,inspector_js_api.cc,callback_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
532,96175,tcp_,3,node.inspector.TcpHolder.tcp_,,inspector_socket.cc,tcp_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
533,96176,delegate_,3,node.inspector.TcpHolder.delegate_,,inspector_socket.cc,delegate_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
534,96177,handler_,3,node.inspector.TcpHolder.handler_,,inspector_socket.cc,* handler_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
535,96178,buffer,3,node.inspector.TcpHolder.buffer,,inspector_socket.cc,buffer,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
536,96237,inspector_,3,node.inspector.ProtocolHandler.inspector_,,inspector_socket.cc,* const inspector_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
537,96238,tcp_,3,node.inspector.ProtocolHandler.tcp_,,inspector_socket.cc,tcp_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
538,96274,handler,3,node.inspector.anonymous_namespace_1.WriteRequest.handler,,inspector_socket.cc,* const handler,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
539,96275,storage,3,node.inspector.anonymous_namespace_1.WriteRequest.storage,,inspector_socket.cc,storage,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
540,96276,req,3,node.inspector.anonymous_namespace_1.WriteRequest.req,,inspector_socket.cc,req,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
541,96277,buf,3,node.inspector.anonymous_namespace_1.WriteRequest.buf,,inspector_socket.cc,buf,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
542,96319,FRAME_OK,3,node.inspector.anonymous_namespace_8.ws_decode_result.FRAME_OK,,inspector_socket.cc,FRAME_OK,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
543,96320,FRAME_INCOMPLETE,3,node.inspector.anonymous_namespace_8.ws_decode_result.FRAME_INCOMPLETE,,inspector_socket.cc,FRAME_INCOMPLETE,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
544,96321,FRAME_CLOSE,3,node.inspector.anonymous_namespace_8.ws_decode_result.FRAME_CLOSE,,inspector_socket.cc,FRAME_CLOSE,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
545,96322,FRAME_ERROR,3,node.inspector.anonymous_namespace_8.ws_decode_result.FRAME_ERROR,,inspector_socket.cc,FRAME_ERROR,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
546,97304,OnCloseSent,3,node.inspector.anonymous_namespace_15.WsHandler.OnCloseSent,,inspector_socket.cc,OnCloseSent,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
547,97305,OnCloseReceived,3,node.inspector.anonymous_namespace_15.WsHandler.OnCloseReceived,,inspector_socket.cc,OnCloseReceived,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
548,97306,dispose_,3,node.inspector.anonymous_namespace_15.WsHandler.dispose_,,inspector_socket.cc,dispose_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
549,97317,path,3,node.inspector.anonymous_namespace_36.HttpEvent.path,,inspector_socket.cc,path,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
550,97318,upgrade,3,node.inspector.anonymous_namespace_36.HttpEvent.upgrade,,inspector_socket.cc,upgrade,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
551,97319,isGET,3,node.inspector.anonymous_namespace_36.HttpEvent.isGET,,inspector_socket.cc,isGET,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
552,97320,ws_key,3,node.inspector.anonymous_namespace_36.HttpEvent.ws_key,,inspector_socket.cc,ws_key,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
553,97321,host,3,node.inspector.anonymous_namespace_36.HttpEvent.host,,inspector_socket.cc,host,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
554,97868,parsing_value_,3,node.inspector.anonymous_namespace_38.HttpHandler.parsing_value_,,inspector_socket.cc,parsing_value_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
555,97869,parser_,3,node.inspector.anonymous_namespace_38.HttpHandler.parser_,,inspector_socket.cc,parser_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
556,97870,parser_settings,3,node.inspector.anonymous_namespace_38.HttpHandler.parser_settings,,inspector_socket.cc,parser_settings,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
557,97871,events_,3,node.inspector.anonymous_namespace_38.HttpHandler.events_,,inspector_socket.cc,events_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
558,97872,current_header_,3,node.inspector.anonymous_namespace_38.HttpHandler.current_header_,,inspector_socket.cc,current_header_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
559,97873,headers_,3,node.inspector.anonymous_namespace_38.HttpHandler.headers_,,inspector_socket.cc,headers_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
560,97874,path_,3,node.inspector.anonymous_namespace_38.HttpHandler.path_,,inspector_socket.cc,path_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
561,98955,server_,3,node.inspector.SocketSession.Delegate.server_,,inspector_socket_server.cc,* server_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
562,98956,session_id_,3,node.inspector.SocketSession.Delegate.session_id_,,inspector_socket_server.cc,session_id_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
563,98957,id_,3,node.inspector.SocketSession.id_,,inspector_socket_server.cc,id_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
564,98958,ws_socket_,3,node.inspector.SocketSession.ws_socket_,,inspector_socket_server.cc,ws_socket_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
565,98959,server_port_,3,node.inspector.SocketSession.server_port_,,inspector_socket_server.cc,server_port_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
566,99027,tcp_socket_,3,node.inspector.ServerSocket.tcp_socket_,,inspector_socket_server.cc,tcp_socket_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
567,99028,server_,3,node.inspector.ServerSocket.server_,,inspector_socket_server.cc,* server_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
568,99029,port_,3,node.inspector.ServerSocket.port_,,inspector_socket_server.cc,port_ = -1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
569,101059,napi_default,3,napi_property_attributes.napi_default,,js_native_api_types.hpp,napi_default = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
570,101060,napi_writable,3,napi_property_attributes.napi_writable,,js_native_api_types.hpp,napi_writable = 1 << 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
571,101061,napi_enumerable,3,napi_property_attributes.napi_enumerable,,js_native_api_types.hpp,napi_enumerable = 1 << 1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
572,101062,napi_configurable,3,napi_property_attributes.napi_configurable,,js_native_api_types.hpp,napi_configurable = 1 << 2,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
573,101063,napi_static,3,napi_property_attributes.napi_static,,js_native_api_types.hpp,napi_static = 1 << 10,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
574,101093,napi_undefined,3,napi_valuetype.napi_undefined,,js_native_api_types.hpp,napi_undefined,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
575,101094,napi_null,3,napi_valuetype.napi_null,,js_native_api_types.hpp,napi_null,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
576,101095,napi_boolean,3,napi_valuetype.napi_boolean,,js_native_api_types.hpp,napi_boolean,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
577,101096,napi_number,3,napi_valuetype.napi_number,,js_native_api_types.hpp,napi_number,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
578,101097,napi_string,3,napi_valuetype.napi_string,,js_native_api_types.hpp,napi_string,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
579,101098,napi_symbol,3,napi_valuetype.napi_symbol,,js_native_api_types.hpp,napi_symbol,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
580,101099,napi_object,3,napi_valuetype.napi_object,,js_native_api_types.hpp,napi_object,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
581,101100,napi_function,3,napi_valuetype.napi_function,,js_native_api_types.hpp,napi_function,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
582,101101,napi_external,3,napi_valuetype.napi_external,,js_native_api_types.hpp,napi_external,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
583,101102,napi_bigint,3,napi_valuetype.napi_bigint,,js_native_api_types.hpp,napi_bigint,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
584,101105,napi_int8_array,3,napi_typedarray_type.napi_int8_array,,js_native_api_types.hpp,napi_int8_array,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
585,101106,napi_uint8_array,3,napi_typedarray_type.napi_uint8_array,,js_native_api_types.hpp,napi_uint8_array,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
586,101107,napi_uint8_clamped_array,3,napi_typedarray_type.napi_uint8_clamped_array,,js_native_api_types.hpp,napi_uint8_clamped_array,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
587,101108,napi_int16_array,3,napi_typedarray_type.napi_int16_array,,js_native_api_types.hpp,napi_int16_array,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
588,101109,napi_uint16_array,3,napi_typedarray_type.napi_uint16_array,,js_native_api_types.hpp,napi_uint16_array,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
589,101110,napi_int32_array,3,napi_typedarray_type.napi_int32_array,,js_native_api_types.hpp,napi_int32_array,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
590,101111,napi_uint32_array,3,napi_typedarray_type.napi_uint32_array,,js_native_api_types.hpp,napi_uint32_array,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
591,101112,napi_float32_array,3,napi_typedarray_type.napi_float32_array,,js_native_api_types.hpp,napi_float32_array,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
592,101113,napi_float64_array,3,napi_typedarray_type.napi_float64_array,,js_native_api_types.hpp,napi_float64_array,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
593,101114,napi_bigint64_array,3,napi_typedarray_type.napi_bigint64_array,,js_native_api_types.hpp,napi_bigint64_array,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
594,101115,napi_biguint64_array,3,napi_typedarray_type.napi_biguint64_array,,js_native_api_types.hpp,napi_biguint64_array,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
595,101118,napi_ok,3,napi_status.napi_ok,,js_native_api_types.hpp,napi_ok,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
596,101119,napi_invalid_arg,3,napi_status.napi_invalid_arg,,js_native_api_types.hpp,napi_invalid_arg,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
597,101120,napi_object_expected,3,napi_status.napi_object_expected,,js_native_api_types.hpp,napi_object_expected,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
598,101121,napi_string_expected,3,napi_status.napi_string_expected,,js_native_api_types.hpp,napi_string_expected,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
599,101122,napi_name_expected,3,napi_status.napi_name_expected,,js_native_api_types.hpp,napi_name_expected,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
600,101123,napi_function_expected,3,napi_status.napi_function_expected,,js_native_api_types.hpp,napi_function_expected,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
601,101124,napi_number_expected,3,napi_status.napi_number_expected,,js_native_api_types.hpp,napi_number_expected,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
602,101125,napi_boolean_expected,3,napi_status.napi_boolean_expected,,js_native_api_types.hpp,napi_boolean_expected,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
603,101126,napi_array_expected,3,napi_status.napi_array_expected,,js_native_api_types.hpp,napi_array_expected,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
604,101127,napi_generic_failure,3,napi_status.napi_generic_failure,,js_native_api_types.hpp,napi_generic_failure,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
605,101128,napi_pending_exception,3,napi_status.napi_pending_exception,,js_native_api_types.hpp,napi_pending_exception,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
606,101129,napi_cancelled,3,napi_status.napi_cancelled,,js_native_api_types.hpp,napi_cancelled,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
607,101130,napi_escape_called_twice,3,napi_status.napi_escape_called_twice,,js_native_api_types.hpp,napi_escape_called_twice,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
608,101131,napi_handle_scope_mismatch,3,napi_status.napi_handle_scope_mismatch,,js_native_api_types.hpp,napi_handle_scope_mismatch,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
609,101132,napi_callback_scope_mismatch,3,napi_status.napi_callback_scope_mismatch,,js_native_api_types.hpp,napi_callback_scope_mismatch,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
610,101133,napi_queue_full,3,napi_status.napi_queue_full,,js_native_api_types.hpp,napi_queue_full,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
611,101134,napi_closing,3,napi_status.napi_closing,,js_native_api_types.hpp,napi_closing,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
612,101135,napi_bigint_expected,3,napi_status.napi_bigint_expected,,js_native_api_types.hpp,napi_bigint_expected,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
613,101136,napi_date_expected,3,napi_status.napi_date_expected,,js_native_api_types.hpp,napi_date_expected,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
614,101137,napi_arraybuffer_expected,3,napi_status.napi_arraybuffer_expected,,js_native_api_types.hpp,napi_arraybuffer_expected,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
615,101138,napi_detachable_arraybuffer_expected,3,napi_status.napi_detachable_arraybuffer_expected,,js_native_api_types.hpp,napi_detachable_arraybuffer_expected,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
616,101139,napi_would_deadlock,3,napi_status.napi_would_deadlock,,js_native_api_types.hpp,napi_would_deadlock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
617,101140,napi_no_external_buffers_allowed,3,napi_status.napi_no_external_buffers_allowed,,js_native_api_types.hpp,napi_no_external_buffers_allowed,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
618,101156,utf8name,3,napi_property_descriptor.utf8name,,js_native_api_types.hpp,* utf8name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
619,101157,name,3,napi_property_descriptor.name,,js_native_api_types.hpp,name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
620,101158,method,3,napi_property_descriptor.method,,js_native_api_types.hpp,method,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
621,101159,getter,3,napi_property_descriptor.getter,,js_native_api_types.hpp,getter,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
622,101160,setter,3,napi_property_descriptor.setter,,js_native_api_types.hpp,setter,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
623,101161,value,3,napi_property_descriptor.value,,js_native_api_types.hpp,value,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
624,101162,attributes,3,napi_property_descriptor.attributes,,js_native_api_types.hpp,attributes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
625,101163,data,3,napi_property_descriptor.data,,js_native_api_types.hpp,* data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
626,101166,error_message,3,napi_extended_error_info.error_message,,js_native_api_types.hpp,* error_message,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
627,101167,engine_reserved,3,napi_extended_error_info.engine_reserved,,js_native_api_types.hpp,* engine_reserved,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
628,101168,engine_error_code,3,napi_extended_error_info.engine_error_code,,js_native_api_types.hpp,engine_error_code,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
629,101169,error_code,3,napi_extended_error_info.error_code,,js_native_api_types.hpp,error_code,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
630,101494,scope,3,v8impl.anonymous_namespace_5.HandleScopeWrapper.scope,,js_native_api_v8.cc,scope,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
631,101521,scope,3,v8impl.anonymous_namespace_7.EscapableHandleScopeWrapper.scope,,js_native_api_v8.cc,scope,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
632,101522,escape_called_,3,v8impl.anonymous_namespace_7.EscapableHandleScopeWrapper.escape_called_,,js_native_api_v8.cc,escape_called_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
633,101742,KeepWrap,3,v8impl.anonymous_namespace_17.UnwrapAction.KeepWrap,,js_native_api_v8.cc,KeepWrap,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
634,101743,RemoveWrap,3,v8impl.anonymous_namespace_17.UnwrapAction.RemoveWrap,,js_native_api_v8.cc,RemoveWrap,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
635,102085,env,3,v8impl.anonymous_namespace_19.CallbackBundle.env,,js_native_api_v8.cc,env,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
636,102086,cb_data,3,v8impl.anonymous_namespace_19.CallbackBundle.cb_data,,js_native_api_v8.cc,* cb_data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
637,102087,cb,3,v8impl.anonymous_namespace_19.CallbackBundle.cb,,js_native_api_v8.cc,cb,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
638,102144,_this,3,v8impl.anonymous_namespace_23.CallbackWrapper._this,,js_native_api_v8.cc,_this,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
639,102145,_args_length,3,v8impl.anonymous_namespace_23.CallbackWrapper._args_length,,js_native_api_v8.cc,_args_length,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
640,102146,_data,3,v8impl.anonymous_namespace_23.CallbackWrapper._data,,js_native_api_v8.cc,* _data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
641,102219,_cbinfo,3,v8impl.anonymous_namespace_31.CallbackWrapperBase._cbinfo,,js_native_api_v8.cc,& _cbinfo,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
642,102220,_bundle,3,v8impl.anonymous_namespace_31.CallbackWrapperBase._bundle,,js_native_api_v8.cc,* _bundle,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
643,121180,next_,3,v8impl.RefTracker.next_,,js_native_api_v8.hpp,* next_ = nullptr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
644,121181,prev_,3,v8impl.RefTracker.prev_,,js_native_api_v8.hpp,* prev_ = nullptr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
645,121366,isolate,3,napi_env__.isolate,,js_native_api_v8.hpp,* const isolate,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
646,121367,context_persistent,3,napi_env__.context_persistent,,js_native_api_v8.hpp,context_persistent,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
647,121368,last_exception,3,napi_env__.last_exception,,js_native_api_v8.hpp,last_exception,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
648,121369,reflist,3,napi_env__.reflist,,js_native_api_v8.hpp,reflist,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
649,121370,finalizing_reflist,3,napi_env__.finalizing_reflist,,js_native_api_v8.hpp,finalizing_reflist,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
650,121371,pending_finalizers,3,napi_env__.pending_finalizers,,js_native_api_v8.hpp,pending_finalizers,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
651,121372,last_error,3,napi_env__.last_error,,js_native_api_v8.hpp,last_error,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
652,121373,open_handle_scopes,3,napi_env__.open_handle_scopes,,js_native_api_v8.hpp,open_handle_scopes = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
653,121374,open_callback_scopes,3,napi_env__.open_callback_scopes,,js_native_api_v8.hpp,open_callback_scopes = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
654,121375,refs,3,napi_env__.refs,,js_native_api_v8.hpp,refs = 1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
655,121376,instance_data,3,napi_env__.instance_data,,js_native_api_v8.hpp,* instance_data = nullptr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
656,121377,module_api_version,3,napi_env__.module_api_version,,js_native_api_v8.hpp,module_api_version = NODE_API_DEFAULT_MODULE_API_VERSION,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
657,121562,env_,3,v8impl.Finalizer.env_,,js_native_api_v8.hpp,env_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
658,121563,finalize_callback_,3,v8impl.Finalizer.finalize_callback_,,js_native_api_v8.hpp,finalize_callback_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
659,121564,finalize_data_,3,v8impl.Finalizer.finalize_data_,,js_native_api_v8.hpp,* finalize_data_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
660,121565,finalize_hint_,3,v8impl.Finalizer.finalize_hint_,,js_native_api_v8.hpp,* finalize_hint_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
661,121589,_env,3,v8impl.TryCatch._env,,js_native_api_v8.hpp,_env,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
662,121591,kRuntime,3,v8impl.Ownership.kRuntime,,js_native_api_v8.hpp,kRuntime,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
663,121592,kUserland,3,v8impl.Ownership.kUserland,,js_native_api_v8.hpp,kUserland,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
664,121644,refcount_,3,v8impl.RefBase.refcount_,,js_native_api_v8.hpp,refcount_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
665,121645,ownership_,3,v8impl.RefBase.ownership_,,js_native_api_v8.hpp,ownership_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
666,121694,persistent_,3,v8impl.Reference.persistent_,,js_native_api_v8.hpp,persistent_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
667,121695,can_be_weak_,3,v8impl.Reference.can_be_weak_,,js_native_api_v8.hpp,can_be_weak_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
668,129746,kNoFlags,3,node.ProcessInitializationFlags.Flags.kNoFlags,,node.hpp,kNoFlags = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
669,129747,kEnableStdioInheritance,3,node.ProcessInitializationFlags.Flags.kEnableStdioInheritance,,node.hpp,kEnableStdioInheritance = 1 << 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
670,129748,kDisableNodeOptionsEnv,3,node.ProcessInitializationFlags.Flags.kDisableNodeOptionsEnv,,node.hpp,kDisableNodeOptionsEnv = 1 << 1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
671,129749,kDisableCLIOptions,3,node.ProcessInitializationFlags.Flags.kDisableCLIOptions,,node.hpp,kDisableCLIOptions = 1 << 2,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
672,129750,kNoICU,3,node.ProcessInitializationFlags.Flags.kNoICU,,node.hpp,kNoICU = 1 << 3,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
673,129751,kNoStdioInitialization,3,node.ProcessInitializationFlags.Flags.kNoStdioInitialization,,node.hpp,kNoStdioInitialization = 1 << 4,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
674,129752,kNoDefaultSignalHandling,3,node.ProcessInitializationFlags.Flags.kNoDefaultSignalHandling,,node.hpp,kNoDefaultSignalHandling = 1 << 5,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
675,129753,kNoInitializeV8,3,node.ProcessInitializationFlags.Flags.kNoInitializeV8,,node.hpp,kNoInitializeV8 = 1 << 6,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
676,129754,kNoInitializeNodeV8Platform,3,node.ProcessInitializationFlags.Flags.kNoInitializeNodeV8Platform,,node.hpp,kNoInitializeNodeV8Platform = 1 << 7,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
677,129755,kNoInitOpenSSL,3,node.ProcessInitializationFlags.Flags.kNoInitOpenSSL,,node.hpp,kNoInitOpenSSL = 1 << 8,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
678,129756,kNoParseGlobalDebugVariables,3,node.ProcessInitializationFlags.Flags.kNoParseGlobalDebugVariables,,node.hpp,kNoParseGlobalDebugVariables = 1 << 9,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
679,129757,kNoAdjustResourceLimits,3,node.ProcessInitializationFlags.Flags.kNoAdjustResourceLimits,,node.hpp,kNoAdjustResourceLimits = 1 << 10,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
680,129758,kNoUseLargePages,3,node.ProcessInitializationFlags.Flags.kNoUseLargePages,,node.hpp,kNoUseLargePages = 1 << 11,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
681,129759,kNoPrintHelpOrVersionOutput,3,node.ProcessInitializationFlags.Flags.kNoPrintHelpOrVersionOutput,,node.hpp,kNoPrintHelpOrVersionOutput = 1 << 12,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
682,129760,kLegacyInitializeNodeWithArgsBehavior,3,node.ProcessInitializationFlags.Flags.kLegacyInitializeNodeWithArgsBehavior,,node.hpp,"kLegacyInitializeNodeWithArgsBehavior =
      kNoStdioInitialization | kNoDefaultSignalHandling | kNoInitializeV8 |
      kNoInitializeNodeV8Platform | kNoInitOpenSSL |
      kNoParseGlobalDebugVariables | kNoAdjustResourceLimits |
      kNoUseLargePages | kNoPrintHelpOrVersionOutput",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
683,129855,kNoFlags,3,node.StopFlags.Flags.kNoFlags,,node.hpp,kNoFlags = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
684,129856,kDoNotTerminateIsolate,3,node.StopFlags.Flags.kDoNotTerminateIsolate,,node.hpp,kDoNotTerminateIsolate = 1 << 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
685,129960,kAllowedInEnvvar,3,node.OptionEnvvarSettings.kAllowedInEnvvar,,node.hpp,kAllowedInEnvvar = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
686,129961,kDisallowedInEnvvar,3,node.OptionEnvvarSettings.kDisallowedInEnvvar,,node.hpp,kDisallowedInEnvvar = 1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
687,129962,kAllowedInEnvironment,3,node.OptionEnvvarSettings.kAllowedInEnvironment,,node.hpp,kAllowedInEnvironment = kAllowedInEnvvar,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
688,129963,kDisallowedInEnvironment,3,node.OptionEnvvarSettings.kDisallowedInEnvironment,,node.hpp,kDisallowedInEnvironment = kDisallowedInEnvvar,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
689,130065,MESSAGE_LISTENER_WITH_ERROR_LEVEL,3,node.IsolateSettingsFlags.MESSAGE_LISTENER_WITH_ERROR_LEVEL,,node.hpp,MESSAGE_LISTENER_WITH_ERROR_LEVEL = 1 << 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
690,130066,DETAILED_SOURCE_POSITIONS_FOR_PROFILING,3,node.IsolateSettingsFlags.DETAILED_SOURCE_POSITIONS_FOR_PROFILING,,node.hpp,DETAILED_SOURCE_POSITIONS_FOR_PROFILING = 1 << 1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
691,130067,SHOULD_NOT_SET_PROMISE_REJECTION_CALLBACK,3,node.IsolateSettingsFlags.SHOULD_NOT_SET_PROMISE_REJECTION_CALLBACK,,node.hpp,SHOULD_NOT_SET_PROMISE_REJECTION_CALLBACK = 1 << 2,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
692,130068,SHOULD_NOT_SET_PREPARE_STACK_TRACE_CALLBACK,3,node.IsolateSettingsFlags.SHOULD_NOT_SET_PREPARE_STACK_TRACE_CALLBACK,,node.hpp,SHOULD_NOT_SET_PREPARE_STACK_TRACE_CALLBACK = 1 << 3,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
693,130069,ALLOW_MODIFY_CODE_GENERATION_FROM_STRINGS_CALLBACK,3,node.IsolateSettingsFlags.ALLOW_MODIFY_CODE_GENERATION_FROM_STRINGS_CALLBACK,,node.hpp,ALLOW_MODIFY_CODE_GENERATION_FROM_STRINGS_CALLBACK = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
694,130098,flags,3,node.IsolateSettings.flags,,node.hpp,"flags = MESSAGE_LISTENER_WITH_ERROR_LEVEL |
      DETAILED_SOURCE_POSITIONS_FOR_PROFILING",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
695,130099,policy,3,node.IsolateSettings.policy,,node.hpp,policy = v8::MicrotasksPolicy::kExplicit,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
696,130100,should_abort_on_uncaught_exception_callback,3,node.IsolateSettings.should_abort_on_uncaught_exception_callback,,node.hpp,should_abort_on_uncaught_exception_callback = nullptr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
697,130101,fatal_error_callback,3,node.IsolateSettings.fatal_error_callback,,node.hpp,fatal_error_callback = nullptr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
698,130102,prepare_stack_trace_callback,3,node.IsolateSettings.prepare_stack_trace_callback,,node.hpp,prepare_stack_trace_callback = nullptr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
699,130103,promise_reject_callback,3,node.IsolateSettings.promise_reject_callback,,node.hpp,promise_reject_callback = nullptr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
700,130104,allow_wasm_code_generation_callback,3,node.IsolateSettings.allow_wasm_code_generation_callback,,node.hpp,allow_wasm_code_generation_callback = nullptr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
701,130105,modify_code_generation_from_strings_callback,3,node.IsolateSettings.modify_code_generation_from_strings_callback,,node.hpp,modify_code_generation_from_strings_callback = nullptr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
702,130201,impl_,3,node.EmbedderSnapshotData.impl_,,node.hpp,* impl_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
703,130202,owns_impl_,3,node.EmbedderSnapshotData.owns_impl_,,node.hpp,owns_impl_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
704,130260,id,3,node.ThreadId.id,,node.hpp,id = static_cast<uint64_t>(-1),-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
705,130277,kNoFlags,3,node.EnvironmentFlags.Flags.kNoFlags,,node.hpp,kNoFlags = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
706,130278,kDefaultFlags,3,node.EnvironmentFlags.Flags.kDefaultFlags,,node.hpp,kDefaultFlags = 1 << 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
707,130279,kOwnsProcessState,3,node.EnvironmentFlags.Flags.kOwnsProcessState,,node.hpp,kOwnsProcessState = 1 << 1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
708,130280,kOwnsInspector,3,node.EnvironmentFlags.Flags.kOwnsInspector,,node.hpp,kOwnsInspector = 1 << 2,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
709,130281,kNoRegisterESMLoader,3,node.EnvironmentFlags.Flags.kNoRegisterESMLoader,,node.hpp,kNoRegisterESMLoader = 1 << 3,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
710,130282,kTrackUnmanagedFds,3,node.EnvironmentFlags.Flags.kTrackUnmanagedFds,,node.hpp,kTrackUnmanagedFds = 1 << 4,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
711,130283,kHideConsoleWindows,3,node.EnvironmentFlags.Flags.kHideConsoleWindows,,node.hpp,kHideConsoleWindows = 1 << 5,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
712,130284,kNoNativeAddons,3,node.EnvironmentFlags.Flags.kNoNativeAddons,,node.hpp,kNoNativeAddons = 1 << 6,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
713,130285,kNoGlobalSearchPaths,3,node.EnvironmentFlags.Flags.kNoGlobalSearchPaths,,node.hpp,kNoGlobalSearchPaths = 1 << 7,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
714,130286,kNoBrowserGlobals,3,node.EnvironmentFlags.Flags.kNoBrowserGlobals,,node.hpp,kNoBrowserGlobals = 1 << 8,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
715,130287,kNoCreateInspector,3,node.EnvironmentFlags.Flags.kNoCreateInspector,,node.hpp,kNoCreateInspector = 1 << 9,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
716,130377,process_object,3,node.StartExecutionCallbackInfo.process_object,,node.hpp,process_object,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
717,130378,native_require,3,node.StartExecutionCallbackInfo.native_require,,node.hpp,native_require,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
718,130379,run_cjs,3,node.StartExecutionCallbackInfo.run_cjs,,node.hpp,run_cjs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
719,130590,event_loop,3,node.CommonEnvironmentSetup.event_loop,,node.hpp,* event_loop() const,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
720,130636,kNoFlags,3,node.CommonEnvironmentSetup.Flags.kNoFlags,,node.hpp,kNoFlags = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
721,130637,kIsForSnapshotting,3,node.CommonEnvironmentSetup.Flags.kIsForSnapshotting,,node.hpp,kIsForSnapshotting = 1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
722,130649,impl_,3,node.CommonEnvironmentSetup.impl_,,node.hpp,* impl_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,35,0,1,1,0,0,,0,0,0,0,0,
723,131061,ASCII,3,node.encoding.ASCII,,node.hpp,ASCII,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
724,131062,UTF8,3,node.encoding.UTF8,,node.hpp,UTF8,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
725,131063,BASE64,3,node.encoding.BASE64,,node.hpp,BASE64,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
726,131064,UCS2,3,node.encoding.UCS2,,node.hpp,UCS2,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
727,131065,BINARY,3,node.encoding.BINARY,,node.hpp,BINARY,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
728,131066,HEX,3,node.encoding.HEX,,node.hpp,HEX,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
729,131067,BUFFER,3,node.encoding.BUFFER,,node.hpp,BUFFER,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
730,131068,BASE64URL,3,node.encoding.BASE64URL,,node.hpp,BASE64URL,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
731,131069,LATIN1,3,node.encoding.LATIN1,,node.hpp,LATIN1 = BINARY,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
732,131137,kLinked,3,node.ModuleFlags.kLinked,,node.hpp,kLinked = 0x02,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
733,131146,nm_version,3,node.node_module.nm_version,,node.hpp,nm_version,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
734,131147,nm_flags,3,node.node_module.nm_flags,,node.hpp,nm_flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
735,131148,nm_dso_handle,3,node.node_module.nm_dso_handle,,node.hpp,* nm_dso_handle,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
736,131149,nm_filename,3,node.node_module.nm_filename,,node.hpp,* nm_filename,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
737,131150,nm_register_func,3,node.node_module.nm_register_func,,node.hpp,nm_register_func,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
738,131151,nm_context_register_func,3,node.node_module.nm_context_register_func,,node.hpp,nm_context_register_func,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
739,131152,nm_modname,3,node.node_module.nm_modname,,node.hpp,* nm_modname,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
740,131153,nm_priv,3,node.node_module.nm_priv,,node.hpp,* nm_priv,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
741,131155,nm_link,3,node.node_module.nm_link,,node.hpp,* nm_link,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
742,131198,async_id,3,node.async_context.async_id,,node.hpp,async_id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
743,131199,trigger_async_id,3,node.async_context.trigger_async_id,,node.hpp,trigger_async_id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
744,131342,private_,3,node.CallbackScope.private_,,node.hpp,* private_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
745,131343,try_catch_,3,node.CallbackScope.try_catch_,,node.hpp,try_catch_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
746,131419,env_,3,node.AsyncResource.env_,,node.hpp,* env_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
747,131420,resource_,3,node.AsyncResource.resource_,,node.hpp,resource_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
748,131421,async_context_,3,node.AsyncResource.async_context_,,node.hpp,async_context_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
749,132700,kDispatchIdle,3,v8impl.anonymous_namespace_11.ThreadSafeFunction.kDispatchIdle,,node_api.cc,kDispatchIdle = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
750,132701,kDispatchRunning,3,v8impl.anonymous_namespace_11.ThreadSafeFunction.kDispatchRunning,,node_api.cc,kDispatchRunning = 1 << 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
751,132702,kDispatchPending,3,v8impl.anonymous_namespace_11.ThreadSafeFunction.kDispatchPending,,node_api.cc,kDispatchPending = 1 << 1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
752,132703,kMaxIterationCount,3,v8impl.anonymous_namespace_11.ThreadSafeFunction.kMaxIterationCount,,node_api.cc,kMaxIterationCount = 1000,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
753,132704,mutex,3,v8impl.anonymous_namespace_11.ThreadSafeFunction.mutex,,node_api.cc,mutex,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
754,132705,cond,3,v8impl.anonymous_namespace_11.ThreadSafeFunction.cond,,node_api.cc,cond,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
755,132706,queue,3,v8impl.anonymous_namespace_11.ThreadSafeFunction.queue,,node_api.cc,queue,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
756,132707,async,3,v8impl.anonymous_namespace_11.ThreadSafeFunction.async,,node_api.cc,async,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
757,132708,thread_count,3,v8impl.anonymous_namespace_11.ThreadSafeFunction.thread_count,,node_api.cc,thread_count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
758,132709,is_closing,3,v8impl.anonymous_namespace_11.ThreadSafeFunction.is_closing,,node_api.cc,is_closing,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
759,132710,dispatch_state,3,v8impl.anonymous_namespace_11.ThreadSafeFunction.dispatch_state,,node_api.cc,dispatch_state,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
760,132711,context,3,v8impl.anonymous_namespace_11.ThreadSafeFunction.context,,node_api.cc,* context,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
761,132712,max_queue_size,3,v8impl.anonymous_namespace_11.ThreadSafeFunction.max_queue_size,,node_api.cc,max_queue_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
762,132713,ref,3,v8impl.anonymous_namespace_11.ThreadSafeFunction.ref,,node_api.cc,ref,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
763,132714,env,3,v8impl.anonymous_namespace_11.ThreadSafeFunction.env,,node_api.cc,env,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,15,0,1,1,0,0,,0,0,0,0,0,
764,132715,finalize_data,3,v8impl.anonymous_namespace_11.ThreadSafeFunction.finalize_data,,node_api.cc,* finalize_data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
765,132716,finalize_cb,3,v8impl.anonymous_namespace_11.ThreadSafeFunction.finalize_cb,,node_api.cc,finalize_cb,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
766,132717,call_js_cb,3,v8impl.anonymous_namespace_11.ThreadSafeFunction.call_js_cb,,node_api.cc,call_js_cb,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
767,132718,handles_closing,3,v8impl.anonymous_namespace_11.ThreadSafeFunction.handles_closing,,node_api.cc,handles_closing,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
768,132968,env_,3,v8impl.anonymous_namespace_43.AsyncContext.env_,,node_api.cc,env_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
769,132969,async_id_,3,v8impl.anonymous_namespace_43.AsyncContext.async_id_,,node_api.cc,async_id_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
770,132970,trigger_async_id_,3,v8impl.anonymous_namespace_43.AsyncContext.trigger_async_id_,,node_api.cc,trigger_async_id_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
771,132971,resource_,3,v8impl.anonymous_namespace_43.AsyncContext.resource_,,node_api.cc,resource_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
772,132972,lost_reference_,3,v8impl.anonymous_namespace_43.AsyncContext.lost_reference_,,node_api.cc,lost_reference_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
773,133404,handle_,3,napi_async_cleanup_hook_handle__.handle_,,node_api.cc,handle_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
774,133405,env_,3,napi_async_cleanup_hook_handle__.env_,,node_api.cc,env_ = nullptr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
775,133406,user_hook_,3,napi_async_cleanup_hook_handle__.user_hook_,,node_api.cc,user_hook_ = nullptr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
776,133407,user_data_,3,napi_async_cleanup_hook_handle__.user_data_,,node_api.cc,* user_data_ = nullptr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
777,133413,done_data_,3,napi_async_cleanup_hook_handle__.done_data_,,node_api.cc,* done_data_ = nullptr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
778,135209,_env,3,anonymous_namespace_75.uvimpl.Work._env,,node_api.cc,_env,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
779,135210,_data,3,anonymous_namespace_75.uvimpl.Work._data,,node_api.cc,* _data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
780,135211,_execute,3,anonymous_namespace_75.uvimpl.Work._execute,,node_api.cc,_execute,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
781,135212,_complete,3,anonymous_namespace_75.uvimpl.Work._complete,,node_api.cc,_complete,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
782,136263,nm_version,3,napi_module.nm_version,,node_api.hpp,nm_version,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
783,136264,nm_flags,3,napi_module.nm_flags,,node_api.hpp,nm_flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
784,136265,nm_filename,3,napi_module.nm_filename,,node_api.hpp,* nm_filename,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
785,136266,nm_register_func,3,napi_module.nm_register_func,,node_api.hpp,nm_register_func,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
786,136267,nm_modname,3,napi_module.nm_modname,,node_api.hpp,* nm_modname,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
787,136268,nm_priv,3,napi_module.nm_priv,,node_api.hpp,* nm_priv,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
788,136269,reserved,3,napi_module.reserved,,node_api.hpp,* reserved[4],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
789,136581,filename,3,node_napi_env__.filename,,node_api_internals.hpp,filename,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
790,136582,destructing,3,node_napi_env__.destructing,,node_api_internals.hpp,destructing = false,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
791,136583,finalization_scheduled,3,node_napi_env__.finalization_scheduled,,node_api_internals.hpp,finalization_scheduled = false,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
792,136622,major,3,napi_node_version.major,,node_api_types.hpp,major,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
793,136623,minor,3,napi_node_version.minor,,node_api_types.hpp,minor,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
794,136624,patch,3,napi_node_version.patch,,node_api_types.hpp,patch,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
795,136625,release,3,napi_node_version.release,,node_api_types.hpp,* release,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
796,137347,mutex_,3,node.binding.global_handle_map_t.mutex_,,node_binding.cc,mutex_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
797,137349,refcount,3,node.binding.global_handle_map_t.Entry.refcount,,node_binding.cc,refcount,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
798,137350,wants_delete_module,3,node.binding.global_handle_map_t.Entry.wants_delete_module,,node_binding.cc,wants_delete_module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
799,137351,module,3,node.binding.global_handle_map_t.Entry.module,,node_binding.cc,* module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
800,137352,map_,3,node.binding.global_handle_map_t.map_,,node_binding.cc,map_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
801,140775,STATUS_EOS,3,node.bob.Status.STATUS_EOS,,node_bob.hpp,STATUS_EOS = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
802,140776,STATUS_CONTINUE,3,node.bob.Status.STATUS_CONTINUE,,node_bob.hpp,STATUS_CONTINUE = 1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
803,140777,STATUS_BLOCK,3,node.bob.Status.STATUS_BLOCK,,node_bob.hpp,STATUS_BLOCK = 2,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
804,140778,STATUS_WAIT,3,node.bob.Status.STATUS_WAIT,,node_bob.hpp,STATUS_WAIT = 3,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
805,140796,OPTIONS_NONE,3,node.bob.Options.OPTIONS_NONE,,node_bob.hpp,OPTIONS_NONE = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
806,140797,OPTIONS_END,3,node.bob.Options.OPTIONS_END,,node_bob.hpp,OPTIONS_END = 1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
807,140798,OPTIONS_SYNC,3,node.bob.Options.OPTIONS_SYNC,,node_bob.hpp,OPTIONS_SYNC = 2,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
808,140853,eos_,3,node.bob.SourceImpl.eos_,,node_bob.hpp,eos_ = false,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
809,140991,persistent_,3,node.Buffer.anonymous_namespace_1.CallbackInfo.persistent_,,node_buffer.cc,persistent_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
810,140992,mutex_,3,node.Buffer.anonymous_namespace_1.CallbackInfo.mutex_,,node_buffer.cc,mutex_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
811,140993,callback_,3,node.Buffer.anonymous_namespace_1.CallbackInfo.callback_,,node_buffer.cc,callback_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
812,140994,data_,3,node.Buffer.anonymous_namespace_1.CallbackInfo.data_,,node_buffer.cc,* const data_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
813,140995,hint_,3,node.Buffer.anonymous_namespace_1.CallbackInfo.hint_,,node_buffer.cc,* const hint_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
814,140996,env_,3,node.Buffer.anonymous_namespace_1.CallbackInfo.env_,,node_buffer.cc,* const env_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
815,157359,mutex_,3,node.MapKVStore.mutex_,,node_env_var.cc,mutex_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
816,157360,map_,3,node.MapKVStore.map_,,node_env_var.cc,map_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
817,160081,kEnhance,3,node.EnhanceFatalException.kEnhance,,node_errors.cc,kEnhance,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
818,160082,kDontEnhance,3,node.EnhanceFatalException.kDontEnhance,,node_errors.cc,kDontEnhance,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
819,197291,,3,node.anonymous_namespace_22.BindingData.nan,,node_http_parser.cc,(http_parser_binding_data),-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
820,197293,parser_buffer,3,node.anonymous_namespace_22.BindingData.parser_buffer,,node_http_parser.cc,parser_buffer,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
821,197294,parser_buffer_in_use,3,node.anonymous_namespace_22.BindingData.parser_buffer_in_use,,node_http_parser.cc,parser_buffer_in_use = false,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
822,197306,,3,node.anonymous_namespace_22.BindingData.nan,,node_http_parser.cc,(BindingData),-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
823,197308,,3,node.anonymous_namespace_22.BindingData.nan,,node_http_parser.cc,(BindingData),-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
824,197483,str_,3,node.anonymous_namespace_25.StringPtr.str_,,node_http_parser.cc,* str_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
825,197484,on_heap_,3,node.anonymous_namespace_25.StringPtr.on_heap_,,node_http_parser.cc,on_heap_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
826,197485,size_,3,node.anonymous_namespace_25.StringPtr.size_,,node_http_parser.cc,size_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
827,197561,all_connections_,3,node.anonymous_namespace_39.ConnectionsList.all_connections_,,node_http_parser.cc,all_connections_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
828,197562,active_connections_,3,node.anonymous_namespace_39.ConnectionsList.active_connections_,,node_http_parser.cc,active_connections_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
829,198987,kAllocBufferSize,3,node.anonymous_namespace_49.Parser.kAllocBufferSize,,node_http_parser.cc,kAllocBufferSize = 64 * 1024,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
830,199684,parser_,3,node.anonymous_namespace_49.Parser.parser_,,node_http_parser.cc,parser_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,23,0,1,1,0,0,,0,0,0,0,0,
831,199685,fields_,3,node.anonymous_namespace_49.Parser.fields_,,node_http_parser.cc,fields_[kMaxHeaderFieldsCount],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
832,199686,values_,3,node.anonymous_namespace_49.Parser.values_,,node_http_parser.cc,values_[kMaxHeaderFieldsCount],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
833,199687,url_,3,node.anonymous_namespace_49.Parser.url_,,node_http_parser.cc,url_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
834,199688,status_message_,3,node.anonymous_namespace_49.Parser.status_message_,,node_http_parser.cc,status_message_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
835,199689,num_fields_,3,node.anonymous_namespace_49.Parser.num_fields_,,node_http_parser.cc,num_fields_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,14,0,1,1,0,0,,0,0,0,0,0,
836,199690,num_values_,3,node.anonymous_namespace_49.Parser.num_values_,,node_http_parser.cc,num_values_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,14,0,1,1,0,0,,0,0,0,0,0,
837,199691,have_flushed_,3,node.anonymous_namespace_49.Parser.have_flushed_,,node_http_parser.cc,have_flushed_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
838,199692,got_exception_,3,node.anonymous_namespace_49.Parser.got_exception_,,node_http_parser.cc,got_exception_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
839,199693,current_buffer_len_,3,node.anonymous_namespace_49.Parser.current_buffer_len_,,node_http_parser.cc,current_buffer_len_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
840,199694,current_buffer_data_,3,node.anonymous_namespace_49.Parser.current_buffer_data_,,node_http_parser.cc,* current_buffer_data_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
841,199695,headers_completed_,3,node.anonymous_namespace_49.Parser.headers_completed_,,node_http_parser.cc,headers_completed_ = false,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
842,199696,pending_pause_,3,node.anonymous_namespace_49.Parser.pending_pause_,,node_http_parser.cc,pending_pause_ = false,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
843,199697,header_nread_,3,node.anonymous_namespace_49.Parser.header_nread_,,node_http_parser.cc,header_nread_ = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
844,199698,max_http_header_size_,3,node.anonymous_namespace_49.Parser.max_http_header_size_,,node_http_parser.cc,max_http_header_size_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
845,199699,last_message_start_,3,node.anonymous_namespace_49.Parser.last_message_start_,,node_http_parser.cc,last_message_start_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
846,199700,connectionsList_,3,node.anonymous_namespace_49.Parser.connectionsList_,,node_http_parser.cc,* connectionsList_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
847,199701,binding_data_,3,node.anonymous_namespace_49.Parser.binding_data_,,node_http_parser.cc,binding_data_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
848,199756,settings,3,node.anonymous_namespace_49.Parser.settings,,node_http_parser.cc,settings,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
849,201672,deserializer,3,node.worker.anonymous_namespace_1.DeserializerDelegate.deserializer,,node_messaging.cc,* deserializer = nullptr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
850,201673,host_objects_,3,node.worker.anonymous_namespace_1.DeserializerDelegate.host_objects_,,node_messaging.cc,& host_objects_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
851,201674,shared_array_buffers_,3,node.worker.anonymous_namespace_1.DeserializerDelegate.shared_array_buffers_,,node_messaging.cc,& shared_array_buffers_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
852,201675,wasm_modules_,3,node.worker.anonymous_namespace_1.DeserializerDelegate.wasm_modules_,,node_messaging.cc,& wasm_modules_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
853,201676,shared_value_conveyor_,3,node.worker.anonymous_namespace_1.DeserializerDelegate.shared_value_conveyor_,,node_messaging.cc,& shared_value_conveyor_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
854,202662,serializer,3,node.worker.anonymous_namespace_12.SerializerDelegate.serializer,,node_messaging.cc,* serializer = nullptr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
855,202769,env_,3,node.worker.anonymous_namespace_12.SerializerDelegate.env_,,node_messaging.cc,* env_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
856,202770,context_,3,node.worker.anonymous_namespace_12.SerializerDelegate.context_,,node_messaging.cc,context_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
857,202771,msg_,3,node.worker.anonymous_namespace_12.SerializerDelegate.msg_,,node_messaging.cc,* msg_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
858,202772,seen_shared_array_buffers_,3,node.worker.anonymous_namespace_12.SerializerDelegate.seen_shared_array_buffers_,,node_messaging.cc,seen_shared_array_buffers_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
859,202773,host_objects_,3,node.worker.anonymous_namespace_12.SerializerDelegate.host_objects_,,node_messaging.cc,host_objects_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
860,202774,first_cloned_object_index_,3,node.worker.anonymous_namespace_12.SerializerDelegate.first_cloned_object_index_,,node_messaging.cc,first_cloned_object_index_ = SIZE_MAX,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
861,207244,refs_,3,node.ObjectWrap.refs_,,node_object_wrap.hpp,refs_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
862,207271,handle_,3,node.ObjectWrap.handle_,,node_object_wrap.hpp,handle_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
863,214713,task_queue,3,node.anonymous_namespace_1.PlatformWorkerData.task_queue,,node_platform.cc,* task_queue,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
864,214714,platform_workers_mutex,3,node.anonymous_namespace_1.PlatformWorkerData.platform_workers_mutex,,node_platform.cc,* platform_workers_mutex,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
865,214715,platform_workers_ready,3,node.anonymous_namespace_1.PlatformWorkerData.platform_workers_ready,,node_platform.cc,* platform_workers_ready,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
866,214716,pending_platform_workers,3,node.anonymous_namespace_1.PlatformWorkerData.pending_platform_workers,,node_platform.cc,* pending_platform_workers,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
867,214717,id,3,node.anonymous_namespace_1.PlatformWorkerData.id,,node_platform.cc,id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
868,215009,scheduler_,3,node.DelayedTaskScheduler.StopTask.scheduler_,,node_platform.cc,* scheduler_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
869,215077,scheduler_,3,node.DelayedTaskScheduler.ScheduleTask.scheduler_,,node_platform.cc,* scheduler_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
870,215078,task_,3,node.DelayedTaskScheduler.ScheduleTask.task_,,node_platform.cc,task_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
871,215079,delay_in_seconds_,3,node.DelayedTaskScheduler.ScheduleTask.delay_in_seconds_,,node_platform.cc,delay_in_seconds_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
872,215138,ready_,3,node.DelayedTaskScheduler.ready_,,node_platform.cc,ready_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
873,215139,pending_worker_tasks_,3,node.DelayedTaskScheduler.pending_worker_tasks_,,node_platform.cc,* pending_worker_tasks_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
874,215140,tasks_,3,node.DelayedTaskScheduler.tasks_,,node_platform.cc,tasks_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
875,215141,loop_,3,node.DelayedTaskScheduler.loop_,,node_platform.cc,loop_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
876,215142,flush_tasks_,3,node.DelayedTaskScheduler.flush_tasks_,,node_platform.cc,flush_tasks_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
877,215143,timers_,3,node.DelayedTaskScheduler.timers_,,node_platform.cc,timers_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
878,226019,kDefault,3,node.sea.anonymous_namespace_1.SeaFlags.kDefault,,node_sea.cc,kDefault = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
879,226020,kDisableExperimentalSeaWarning,3,node.sea.anonymous_namespace_1.SeaFlags.kDisableExperimentalSeaWarning,,node_sea.cc,kDisableExperimentalSeaWarning = 1 << 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
880,226078,flags,3,node.sea.anonymous_namespace_5.SeaResource.flags,,node_sea.cc,flags = SeaFlags::kDefault,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
881,226079,code,3,node.sea.anonymous_namespace_5.SeaResource.code,,node_sea.cc,code,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
882,226080,kHeaderSize,3,node.sea.anonymous_namespace_5.SeaResource.kHeaderSize,,node_sea.cc,kHeaderSize = sizeof(kMagic) + sizeof(SeaFlags),-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
883,226224,main_path,3,node.sea.anonymous_namespace_11.SeaConfig.main_path,,node_sea.cc,main_path,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
884,226225,output_path,3,node.sea.anonymous_namespace_11.SeaConfig.output_path,,node_sea.cc,output_path,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
885,226226,flags,3,node.sea.anonymous_namespace_11.SeaConfig.flags,,node_sea.cc,flags = SeaFlags::kDefault,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
886,226780,length_,3,node.serdes.DeserializerContext.length_,,node_serdes.cc,length_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
887,226781,deserializer_,3,node.serdes.DeserializerContext.deserializer_,,node_serdes.cc,deserializer_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
888,237193,,3,node.NodeCategorySet.nan,,node_trace_events.cc,(NodeCategorySet),-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
889,237195,,3,node.NodeCategorySet.nan,,node_trace_events.cc,(NodeCategorySet),-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
890,237205,enabled_,3,node.NodeCategorySet.enabled_,,node_trace_events.cc,enabled_ = false,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
891,237206,categories_,3,node.NodeCategorySet.categories_,,node_trace_events.cc,categories_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
892,251603,w_,3,node.worker.WorkerThreadData.w_,,node_worker.cc,* const w_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
893,251604,loop_,3,node.worker.WorkerThreadData.loop_,,node_worker.cc,loop_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
894,251605,loop_init_failed_,3,node.worker.WorkerThreadData.loop_init_failed_,,node_worker.cc,loop_init_failed_ = true,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
895,251606,isolate_data_,3,node.worker.WorkerThreadData.isolate_data_,,node_worker.cc,isolate_data_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
896,251607,snapshot_data_,3,node.worker.WorkerThreadData.snapshot_data_,,node_worker.cc,* snapshot_data_ = nullptr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
897,254795,NONE,3,node.anonymous_namespace_2.node_zlib_mode.NONE,,node_zlib.cc,NONE,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
898,254796,DEFLATE,3,node.anonymous_namespace_2.node_zlib_mode.DEFLATE,,node_zlib.cc,DEFLATE,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
899,254797,INFLATE,3,node.anonymous_namespace_2.node_zlib_mode.INFLATE,,node_zlib.cc,INFLATE,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
900,254798,GZIP,3,node.anonymous_namespace_2.node_zlib_mode.GZIP,,node_zlib.cc,GZIP,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
901,254799,GUNZIP,3,node.anonymous_namespace_2.node_zlib_mode.GUNZIP,,node_zlib.cc,GUNZIP,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
902,254800,DEFLATERAW,3,node.anonymous_namespace_2.node_zlib_mode.DEFLATERAW,,node_zlib.cc,DEFLATERAW,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
903,254801,INFLATERAW,3,node.anonymous_namespace_2.node_zlib_mode.INFLATERAW,,node_zlib.cc,INFLATERAW,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
904,254802,UNZIP,3,node.anonymous_namespace_2.node_zlib_mode.UNZIP,,node_zlib.cc,UNZIP,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
905,254803,BROTLI_DECODE,3,node.anonymous_namespace_2.node_zlib_mode.BROTLI_DECODE,,node_zlib.cc,BROTLI_DECODE,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
906,254804,BROTLI_ENCODE,3,node.anonymous_namespace_2.node_zlib_mode.BROTLI_ENCODE,,node_zlib.cc,BROTLI_ENCODE,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
907,254827,message,3,node.anonymous_namespace_3.CompressionError.message,,node_zlib.cc,* message = nullptr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
908,254828,code,3,node.anonymous_namespace_3.CompressionError.code,,node_zlib.cc,* code = nullptr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
909,254829,err,3,node.anonymous_namespace_3.CompressionError.err,,node_zlib.cc,err = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
910,254921,,3,node.anonymous_namespace_7.ZlibContext.nan,,node_zlib.cc,(ZlibContext),-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
911,254923,,3,node.anonymous_namespace_7.ZlibContext.nan,,node_zlib.cc,(ZlibContext),-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
912,254959,mutex_,3,node.anonymous_namespace_7.ZlibContext.mutex_,,node_zlib.cc,mutex_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
913,254960,zlib_init_done_,3,node.anonymous_namespace_7.ZlibContext.zlib_init_done_,,node_zlib.cc,zlib_init_done_ = false,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
914,254961,err_,3,node.anonymous_namespace_7.ZlibContext.err_,,node_zlib.cc,err_ = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
915,254962,flush_,3,node.anonymous_namespace_7.ZlibContext.flush_,,node_zlib.cc,flush_ = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
916,254963,level_,3,node.anonymous_namespace_7.ZlibContext.level_,,node_zlib.cc,level_ = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
917,254964,mem_level_,3,node.anonymous_namespace_7.ZlibContext.mem_level_,,node_zlib.cc,mem_level_ = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
918,254965,mode_,3,node.anonymous_namespace_7.ZlibContext.mode_,,node_zlib.cc,mode_ = NONE,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
919,254966,strategy_,3,node.anonymous_namespace_7.ZlibContext.strategy_,,node_zlib.cc,strategy_ = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
920,254967,window_bits_,3,node.anonymous_namespace_7.ZlibContext.window_bits_,,node_zlib.cc,window_bits_ = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
921,254968,gzip_id_bytes_read_,3,node.anonymous_namespace_7.ZlibContext.gzip_id_bytes_read_,,node_zlib.cc,gzip_id_bytes_read_ = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
922,254969,dictionary_,3,node.anonymous_namespace_7.ZlibContext.dictionary_,,node_zlib.cc,dictionary_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
923,254970,strm_,3,node.anonymous_namespace_7.ZlibContext.strm_,,node_zlib.cc,strm_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
924,255044,mode_,3,node.anonymous_namespace_26.BrotliContext.mode_,,node_zlib.cc,mode_ = NONE,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
925,255045,next_in_,3,node.anonymous_namespace_26.BrotliContext.next_in_,,node_zlib.cc,* next_in_ = nullptr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
926,255046,next_out_,3,node.anonymous_namespace_26.BrotliContext.next_out_,,node_zlib.cc,* next_out_ = nullptr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
927,255047,avail_in_,3,node.anonymous_namespace_26.BrotliContext.avail_in_,,node_zlib.cc,avail_in_ = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
928,255048,avail_out_,3,node.anonymous_namespace_26.BrotliContext.avail_out_,,node_zlib.cc,avail_out_ = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
929,255049,flush_,3,node.anonymous_namespace_26.BrotliContext.flush_,,node_zlib.cc,flush_ = BROTLI_OPERATION_PROCESS,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
930,255050,alloc_,3,node.anonymous_namespace_26.BrotliContext.alloc_,,node_zlib.cc,alloc_ = nullptr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
931,255051,free_,3,node.anonymous_namespace_26.BrotliContext.free_,,node_zlib.cc,free_ = nullptr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
932,255052,alloc_opaque_,3,node.anonymous_namespace_26.BrotliContext.alloc_opaque_,,node_zlib.cc,* alloc_opaque_ = nullptr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
933,255114,,3,node.anonymous_namespace_34.BrotliEncoderContext.nan,,node_zlib.cc,(BrotliEncoderContext),-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
934,255116,,3,node.anonymous_namespace_34.BrotliEncoderContext.nan,,node_zlib.cc,(BrotliEncoderContext),-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
935,255119,state_,3,node.anonymous_namespace_34.BrotliEncoderContext.state_,,node_zlib.cc,state_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
936,255150,,3,node.anonymous_namespace_41.BrotliDecoderContext.nan,,node_zlib.cc,(BrotliDecoderContext),-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
937,255152,,3,node.anonymous_namespace_41.BrotliDecoderContext.nan,,node_zlib.cc,(BrotliDecoderContext),-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
938,255155,error_,3,node.anonymous_namespace_41.BrotliDecoderContext.error_,,node_zlib.cc,error_ = BROTLI_DECODER_NO_ERROR,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
939,255156,error_string_,3,node.anonymous_namespace_41.BrotliDecoderContext.error_string_,,node_zlib.cc,error_string_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
940,255157,state_,3,node.anonymous_namespace_41.BrotliDecoderContext.state_,,node_zlib.cc,state_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
941,255166,kCompressionStreamBaseField,3,node.anonymous_namespace_49.CompressionStream.InternalFields.kCompressionStreamBaseField,,node_zlib.cc,kCompressionStreamBaseField = AsyncWrap::kInternalFieldCount,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
942,255167,kWriteJSCallback,3,node.anonymous_namespace_49.CompressionStream.InternalFields.kWriteJSCallback,,node_zlib.cc,kWriteJSCallback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
943,255168,kInternalFieldCount,3,node.anonymous_namespace_49.CompressionStream.InternalFields.kInternalFieldCount,,node_zlib.cc,kInternalFieldCount,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
944,256038,stream,3,node.anonymous_namespace_91.CompressionStream.AllocScope.stream,,node_zlib.cc,* stream,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
945,256064,init_done_,3,node.anonymous_namespace_48.CompressionStream.init_done_,,node_zlib.cc,init_done_ = false,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
946,256065,write_in_progress_,3,node.anonymous_namespace_48.CompressionStream.write_in_progress_,,node_zlib.cc,write_in_progress_ = false,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
947,256066,pending_close_,3,node.anonymous_namespace_48.CompressionStream.pending_close_,,node_zlib.cc,pending_close_ = false,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
948,256067,closed_,3,node.anonymous_namespace_48.CompressionStream.closed_,,node_zlib.cc,closed_ = false,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
949,256068,refs_,3,node.anonymous_namespace_48.CompressionStream.refs_,,node_zlib.cc,refs_ = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
950,256069,write_result_,3,node.anonymous_namespace_48.CompressionStream.write_result_,,node_zlib.cc,* write_result_ = nullptr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
951,256070,unreported_allocations_,3,node.anonymous_namespace_48.CompressionStream.unreported_allocations_,,node_zlib.cc,unreported_allocations_{0},-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
952,256071,zlib_memory_,3,node.anonymous_namespace_48.CompressionStream.zlib_memory_,,node_zlib.cc,zlib_memory_ = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
953,256072,ctx_,3,node.anonymous_namespace_48.CompressionStream.ctx_,,node_zlib.cc,ctx_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
954,256498,,3,node.anonymous_namespace_96.ZlibStream.nan,,node_zlib.cc,(ZlibStream),-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
955,256500,,3,node.anonymous_namespace_96.ZlibStream.nan,,node_zlib.cc,(ZlibStream),-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
956,256779,,3,node.anonymous_namespace_101.BrotliCompressionStream.nan,,node_zlib.cc,(BrotliCompressionStream),-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
957,256781,,3,node.anonymous_namespace_101.BrotliCompressionStream.nan,,node_zlib.cc,(BrotliCompressionStream),-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
958,272380,process_,3,node.anonymous_namespace_1.ProcessWrap.process_,,process_wrap.cc,process_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
959,273463,handle_,3,node.anonymous_namespace_1.SignalWrap.handle_,,signal_wrap.cc,handle_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
960,273464,active_,3,node.anonymous_namespace_1.SignalWrap.active_,,signal_wrap.cc,active_ = false,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
961,282664,isolate_,3,node.anonymous_namespace_1.ExternString.isolate_,,string_bytes.cc,* isolate_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
962,282665,data_,3,node.anonymous_namespace_1.ExternString.data_,,string_bytes.cc,* data_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
963,282666,length_,3,node.anonymous_namespace_1.ExternString.length_,,string_bytes.cc,length_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
964,289538,controller_,3,node.tracing.ScopedSuspendTracing.controller_,,tracing\agent.cc,* controller_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
965,289539,agent_,3,node.tracing.ScopedSuspendTracing.agent_,,tracing\agent.cc,* agent_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
966,290329,agent_,3,node.tracing.AgentWriterHandle.agent_,,tracing\agent.hpp,* agent_ = nullptr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
967,290330,id_,3,node.tracing.AgentWriterHandle.id_,,tracing\agent.hpp,id_ = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
968,290367,kUseDefaultCategories,3,node.tracing.Agent.UseDefaultCategoryMode.kUseDefaultCategories,,tracing\agent.hpp,kUseDefaultCategories,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
969,290368,kIgnoreDefaultCategories,3,node.tracing.Agent.UseDefaultCategoryMode.kIgnoreDefaultCategories,,tracing\agent.hpp,kIgnoreDefaultCategories,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
970,290433,thread_,3,node.tracing.Agent.thread_,,tracing\agent.hpp,thread_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
971,290434,tracing_loop_,3,node.tracing.Agent.tracing_loop_,,tracing\agent.hpp,tracing_loop_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
972,290435,started_,3,node.tracing.Agent.started_,,tracing\agent.hpp,started_ = false,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
973,290437,next_writer_id_,3,node.tracing.Agent.next_writer_id_,,tracing\agent.hpp,next_writer_id_ = 1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
974,290439,kDefaultHandleId,3,node.tracing.Agent.anonymous_enum_0.kDefaultHandleId,,tracing\agent.hpp,kDefaultHandleId = -1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
975,290448,categories_,3,node.tracing.Agent.categories_,,tracing\agent.hpp,categories_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
976,290449,writers_,3,node.tracing.Agent.writers_,,tracing\agent.hpp,writers_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
977,290450,tracing_controller_,3,node.tracing.Agent.tracing_controller_,,tracing\agent.hpp,tracing_controller_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
978,290451,initialize_writer_mutex_,3,node.tracing.Agent.initialize_writer_mutex_,,tracing\agent.hpp,initialize_writer_mutex_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
979,290452,initialize_writer_condvar_,3,node.tracing.Agent.initialize_writer_condvar_,,tracing\agent.hpp,initialize_writer_condvar_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
980,290453,initialize_writer_async_,3,node.tracing.Agent.initialize_writer_async_,,tracing\agent.hpp,initialize_writer_async_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
981,290454,to_be_initialized_,3,node.tracing.Agent.to_be_initialized_,,tracing\agent.hpp,to_be_initialized_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
982,290455,metadata_events_mutex_,3,node.tracing.Agent.metadata_events_mutex_,,tracing\agent.hpp,metadata_events_mutex_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
983,290456,metadata_events_,3,node.tracing.Agent.metadata_events_,,tracing\agent.hpp,metadata_events_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
984,291300,mutex_,3,node.tracing.InternalTraceBuffer.mutex_,,tracing\node_trace_buffer.hpp,mutex_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
985,291301,flushing_,3,node.tracing.InternalTraceBuffer.flushing_,,tracing\node_trace_buffer.hpp,flushing_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
986,291302,max_chunks_,3,node.tracing.InternalTraceBuffer.max_chunks_,,tracing\node_trace_buffer.hpp,max_chunks_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
987,291303,agent_,3,node.tracing.InternalTraceBuffer.agent_,,tracing\node_trace_buffer.hpp,* agent_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
988,291304,chunks_,3,node.tracing.InternalTraceBuffer.chunks_,,tracing\node_trace_buffer.hpp,chunks_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
989,291305,total_chunks_,3,node.tracing.InternalTraceBuffer.total_chunks_,,tracing\node_trace_buffer.hpp,total_chunks_ = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
990,291306,current_chunk_seq_,3,node.tracing.InternalTraceBuffer.current_chunk_seq_,,tracing\node_trace_buffer.hpp,current_chunk_seq_ = 1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
991,291307,id_,3,node.tracing.InternalTraceBuffer.id_,,tracing\node_trace_buffer.hpp,id_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
992,291344,kBufferChunks,3,node.tracing.NodeTraceBuffer.kBufferChunks,,tracing\node_trace_buffer.hpp,kBufferChunks = 1024,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
993,291359,tracing_loop_,3,node.tracing.NodeTraceBuffer.tracing_loop_,,tracing\node_trace_buffer.hpp,* tracing_loop_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
994,291360,flush_signal_,3,node.tracing.NodeTraceBuffer.flush_signal_,,tracing\node_trace_buffer.hpp,flush_signal_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
995,291361,exit_signal_,3,node.tracing.NodeTraceBuffer.exit_signal_,,tracing\node_trace_buffer.hpp,exit_signal_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
996,291362,exited_,3,node.tracing.NodeTraceBuffer.exited_,,tracing\node_trace_buffer.hpp,exited_ = false,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
997,291363,exit_mutex_,3,node.tracing.NodeTraceBuffer.exit_mutex_,,tracing\node_trace_buffer.hpp,exit_mutex_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
998,291364,exit_cond_,3,node.tracing.NodeTraceBuffer.exit_cond_,,tracing\node_trace_buffer.hpp,exit_cond_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
999,291365,current_buf_,3,node.tracing.NodeTraceBuffer.current_buf_,,tracing\node_trace_buffer.hpp,current_buf_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1000,291366,buffer1_,3,node.tracing.NodeTraceBuffer.buffer1_,,tracing\node_trace_buffer.hpp,buffer1_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
1001,291367,buffer2_,3,node.tracing.NodeTraceBuffer.buffer2_,,tracing\node_trace_buffer.hpp,buffer2_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1002,292112,kTracesPerFile,3,node.tracing.NodeTraceWriter.kTracesPerFile,,tracing\node_trace_writer.hpp,kTracesPerFile = 1 << 19,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1003,292114,str,3,node.tracing.NodeTraceWriter.WriteRequest.str,,tracing\node_trace_writer.hpp,str,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1004,292115,highest_request_id,3,node.tracing.NodeTraceWriter.WriteRequest.highest_request_id,,tracing\node_trace_writer.hpp,highest_request_id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1005,292148,tracing_loop_,3,node.tracing.NodeTraceWriter.tracing_loop_,,tracing\node_trace_writer.hpp,* tracing_loop_ = nullptr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1006,292149,flush_signal_,3,node.tracing.NodeTraceWriter.flush_signal_,,tracing\node_trace_writer.hpp,flush_signal_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1007,292150,exit_signal_,3,node.tracing.NodeTraceWriter.exit_signal_,,tracing\node_trace_writer.hpp,exit_signal_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1008,292151,stream_mutex_,3,node.tracing.NodeTraceWriter.stream_mutex_,,tracing\node_trace_writer.hpp,stream_mutex_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1009,292152,request_mutex_,3,node.tracing.NodeTraceWriter.request_mutex_,,tracing\node_trace_writer.hpp,request_mutex_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1010,292153,request_cond_,3,node.tracing.NodeTraceWriter.request_cond_,,tracing\node_trace_writer.hpp,request_cond_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1011,292154,exit_cond_,3,node.tracing.NodeTraceWriter.exit_cond_,,tracing\node_trace_writer.hpp,exit_cond_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1012,292155,fd_,3,node.tracing.NodeTraceWriter.fd_,,tracing\node_trace_writer.hpp,fd_ = -1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
1013,292156,write_req_,3,node.tracing.NodeTraceWriter.write_req_,,tracing\node_trace_writer.hpp,write_req_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1014,292157,write_req_queue_,3,node.tracing.NodeTraceWriter.write_req_queue_,,tracing\node_trace_writer.hpp,write_req_queue_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
1015,292158,num_write_requests_,3,node.tracing.NodeTraceWriter.num_write_requests_,,tracing\node_trace_writer.hpp,num_write_requests_ = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1016,292159,highest_request_id_completed_,3,node.tracing.NodeTraceWriter.highest_request_id_completed_,,tracing\node_trace_writer.hpp,highest_request_id_completed_ = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1017,292160,total_traces_,3,node.tracing.NodeTraceWriter.total_traces_,,tracing\node_trace_writer.hpp,total_traces_ = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1018,292161,file_num_,3,node.tracing.NodeTraceWriter.file_num_,,tracing\node_trace_writer.hpp,file_num_ = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1019,292162,log_file_pattern_,3,node.tracing.NodeTraceWriter.log_file_pattern_,,tracing\node_trace_writer.hpp,log_file_pattern_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1020,292163,stream_,3,node.tracing.NodeTraceWriter.stream_,,tracing\node_trace_writer.hpp,stream_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1021,292164,json_trace_writer_,3,node.tracing.NodeTraceWriter.json_trace_writer_,,tracing\node_trace_writer.hpp,json_trace_writer_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1022,292165,exited_,3,node.tracing.NodeTraceWriter.exited_,,tracing\node_trace_writer.hpp,exited_ = false,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1023,292298,kEnabledForRecording_CategoryGroupEnabledFlags,3,CategoryGroupEnabledFlags.kEnabledForRecording_CategoryGroupEnabledFlags,,tracing\trace_event.hpp,kEnabledForRecording_CategoryGroupEnabledFlags = 1 << 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1024,292299,kEnabledForEventCallback_CategoryGroupEnabledFlags,3,CategoryGroupEnabledFlags.kEnabledForEventCallback_CategoryGroupEnabledFlags,,tracing\trace_event.hpp,kEnabledForEventCallback_CategoryGroupEnabledFlags = 1 << 2,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1025,292300,kEnabledForETWExport_CategoryGroupEnabledFlags,3,CategoryGroupEnabledFlags.kEnabledForETWExport_CategoryGroupEnabledFlags,,tracing\trace_event.hpp,kEnabledForETWExport_CategoryGroupEnabledFlags = 1 << 3,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1026,292401,scope_,3,node.tracing.TraceID.WithScope.scope_,,tracing\trace_event.hpp,* scope_ = nullptr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1027,292402,raw_id_,3,node.tracing.TraceID.WithScope.raw_id_,,tracing\trace_event.hpp,raw_id_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1028,292473,scope_,3,node.tracing.TraceID.DontMangle.scope_,,tracing\trace_event.hpp,* scope_ = nullptr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1029,292474,raw_id_,3,node.tracing.TraceID.DontMangle.raw_id_,,tracing\trace_event.hpp,raw_id_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1030,292529,raw_id_,3,node.tracing.TraceID.ForceMangle.raw_id_,,tracing\trace_event.hpp,raw_id_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1031,292658,scope_,3,node.tracing.TraceID.scope_,,tracing\trace_event.hpp,* scope_ = nullptr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1032,292659,raw_id_,3,node.tracing.TraceID.raw_id_,,tracing\trace_event.hpp,raw_id_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1033,292668,as_bool,3,node.tracing.TraceValueUnion.as_bool,,tracing\trace_event.hpp,as_bool,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1034,292669,as_uint,3,node.tracing.TraceValueUnion.as_uint,,tracing\trace_event.hpp,as_uint,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1035,292670,as_int,3,node.tracing.TraceValueUnion.as_int,,tracing\trace_event.hpp,as_int,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1036,292671,as_double,3,node.tracing.TraceValueUnion.as_double,,tracing\trace_event.hpp,as_double,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1037,292672,as_pointer,3,node.tracing.TraceValueUnion.as_pointer,,tracing\trace_event.hpp,* as_pointer,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1038,292673,as_string,3,node.tracing.TraceValueUnion.as_string,,tracing\trace_event.hpp,* as_string,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1039,292686,str_,3,node.tracing.TraceStringWithCopy.str_,,tracing\trace_event.hpp,* str_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1040,293351,category_group_enabled,3,node.tracing.ScopedTracer.Data.category_group_enabled,,tracing\trace_event.hpp,* category_group_enabled,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1041,293352,name,3,node.tracing.ScopedTracer.Data.name,,tracing\trace_event.hpp,* name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1042,293353,event_handle,3,node.tracing.ScopedTracer.Data.event_handle,,tracing\trace_event.hpp,event_handle,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1043,293354,p_data_,3,node.tracing.ScopedTracer.p_data_,,tracing\trace_event.hpp,* p_data_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1044,293355,data_,3,node.tracing.ScopedTracer.data_,,tracing\trace_event.hpp,data_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
1045,293960,data_,3,node.tracing.TracedValue.data_,,tracing\traced_value.hpp,data_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,18,0,1,1,0,0,,0,0,0,0,0,
1046,293961,first_item_,3,node.tracing.TracedValue.first_item_,,tracing\traced_value.hpp,first_item_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1047,293962,root_is_array_,3,node.tracing.TracedValue.root_is_array_,,tracing\traced_value.hpp,root_is_array_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1048,294604,msg_size,3,node.SendWrap.msg_size,,udp_wrap.cc,msg_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1049,299447,value,3,node.per_process.UVError.value,,uv.cc,value,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1050,299448,name,3,node.per_process.UVError.name,,uv.cc,* name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1051,299449,message,3,node.per_process.UVError.message,,uv.cc,* message,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1052,59,AsyncResource,1,node.AsyncResource.AsyncResource,"ANY node.AsyncResource.AsyncResource (Isolate*,Local<Object>,char*,async_id)",api\async_resource.cc,"AsyncResource::AsyncResource(Isolate* isolate,
                             Local<Object> resource,
                             const char* name,
                             async_id trigger_async_id)
    : env_(Environment::GetCurrent(isolate)),
      resource_(isolate, resource) {
  CHECK_NOT_NULL(env_);
  async_context_ = EmitAsyncInit(isolate, resource, name,
                                 trigger_async_id);
}",14.0,23.0,1.0,1.0,10.0,1,1,6,6,0,2,1,1,0,0,,0,2,8,4,4,ANY
1053,76,~AsyncResource,1,node.AsyncResource.~AsyncResource,ANY node.AsyncResource.~AsyncResource (),api\async_resource.cc,"AsyncResource::~AsyncResource() {
  EmitAsyncDestroy(env_, async_context_);
}",25.0,27.0,1.0,1.0,3.0,0,0,2,2,0,2,1,1,0,0,,0,2,0,0,0,ANY
1054,83,MakeCallback,1,node.AsyncResource.MakeCallback,"MaybeLocal<Value> node.AsyncResource.MakeCallback (Local<Function>,int,Local<Value>*)",api\async_resource.cc,"MaybeLocal<Value> AsyncResource::MakeCallback(Local<String> symbol,
                                              int argc,
                                              Local<Value>* argv) {
  return node::MakeCallback(env_->isolate(), get_resource(),
                            symbol, argc, argv,
                            async_context_);
}",45.0,51.0,1.0,1.0,7.0,2,2,6,6,0,3,1,1,0,1,,0,2,6,3,3,MaybeLocal<Value>
1055,146,get_resource,1,node.AsyncResource.get_resource,Local<Object> node.AsyncResource.get_resource (),api\async_resource.cc,"Local<Object> AsyncResource::get_resource() {
  return resource_.Get(env_->isolate());
}",53.0,55.0,1.0,1.0,3.0,2,2,2,2,0,2,1,1,0,0,,0,2,0,0,0,Local<Object>
1056,159,get_async_id,1,node.AsyncResource.get_async_id,async_id node.AsyncResource.get_async_id (),api\async_resource.cc,"async_id AsyncResource::get_async_id() const {
  return async_context_.async_id;
}",57.0,59.0,1.0,1.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,async_id
1057,167,get_trigger_async_id,1,node.AsyncResource.get_trigger_async_id,async_id node.AsyncResource.get_trigger_async_id (),api\async_resource.cc,"async_id AsyncResource::get_trigger_async_id() const {
  return async_context_.trigger_async_id;
}",61.0,63.0,1.0,1.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,async_id
1058,175,CallbackScope,1,node.AsyncResource.CallbackScope.CallbackScope,ANY node.AsyncResource.CallbackScope.CallbackScope (AsyncResource*),api\async_resource.cc,"AsyncResource::CallbackScope::CallbackScope(AsyncResource* res)
    : node::CallbackScope(res->env_,
                          res->resource_.Get(res->env_->isolate()),
                          res->async_context_) {}",65.0,68.0,1.0,49.0,4.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
1059,181,<lambda>0,1,node.InternalCallbackScope.Close.<lambda>0,ANY node.InternalCallbackScope.Close.<lambda>0 (),api\callback.cc,"[&]() {
    if (env_->is_stopping()) {
      MarkAsFailed();
      env_->async_hooks()->clear_async_id_stack();
    }
  }",103.0,108.0,33.0,3.0,6.0,3,1,2,1,0,0,2,2,0,0,,0,0,0,0,0,ANY
1060,201,<lambda>1,1,node.InternalCallbackScope.Close.<lambda>1,ANY node.InternalCallbackScope.Close.<lambda>1 (),api\callback.cc,[&]() { isolate->SetIdle(true); },114.0,114.0,28.0,60.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,ANY
1061,212,<lambda>2,1,node.InternalCallbackScope.Close.<lambda>2,ANY node.InternalCallbackScope.Close.<lambda>2 (),api\callback.cc,[&]() { env_->RunWeakRefCleanup(); },133.0,133.0,39.0,74.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,ANY
1062,233,CallbackScope,1,node.CallbackScope.CallbackScope,"ANY node.CallbackScope.CallbackScope (Isolate*,Local<Object>,async_context)",api\callback.cc,"CallbackScope::CallbackScope(Environment* env,
                             Local<Object> object,
                             async_context asyncContext)
  : private_(new InternalCallbackScope(env,
                                       object,
                                       asyncContext)),
    try_catch_(env->isolate()) {
  try_catch_.SetVerbose(true);
}",24.0,32.0,1.0,1.0,9.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,ANY
1063,252,~CallbackScope,1,node.CallbackScope.~CallbackScope,ANY node.CallbackScope.~CallbackScope (),api\callback.cc,"CallbackScope::~CallbackScope() {
  if (try_catch_.HasCaught())
    private_->MarkAsFailed();
  delete private_;
}",34.0,38.0,1.0,1.0,5.0,3,3,3,2,0,3,2,2,1,0,,0,3,0,0,0,ANY
1064,268,InternalCallbackScope,1,node.InternalCallbackScope.InternalCallbackScope,"ANY node.InternalCallbackScope.InternalCallbackScope (AsyncWrap*,int)",api\callback.cc,"InternalCallbackScope::InternalCallbackScope(Environment* env,
                                             Local<Object> object,
                                             const async_context& asyncContext,
                                             int flags)
  : env_(env),
    async_context_(asyncContext),
    object_(object),
    skip_hooks_(flags & kSkipAsyncHooks),
    skip_task_queues_(flags & kSkipTaskQueues) {
  CHECK_NOT_NULL(env);
  env->PushAsyncCallbackScope();

  if (!env->can_call_into_js()) {
    failed_ = true;
    return;
  }

  Isolate* isolate = env->isolate();

  HandleScope handle_scope(isolate);
  Local<Context> current_context = isolate->GetCurrentContext();
  // If you hit this assertion, the caller forgot to enter the right Node.js
  // Environment's v8::Context first.
  // We first check `env->context() != current_context` because the contexts
  // likely *are* the same, in which case we can skip the slightly more
  // expensive Environment::GetCurrent...",47.0,89.0,1.0,1.0,43.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,ANY
1065,375,~InternalCallbackScope,1,node.InternalCallbackScope.~InternalCallbackScope,ANY node.InternalCallbackScope.~InternalCallbackScope (),api\callback.cc,"InternalCallbackScope::~InternalCallbackScope() {
  Close();
  env_->PopAsyncCallbackScope();
}",91.0,94.0,1.0,1.0,4.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,ANY
1066,384,Close,1,node.InternalCallbackScope.Close,void node.InternalCallbackScope.Close (),api\callback.cc,"void InternalCallbackScope::Close() {
  if (closed_) return;
  closed_ = true;

  // This function must ends up with either cleanup the
  // async id stack or pop the topmost one from it

  auto perform_stopping_check = [&]() {
    if (env_->is_stopping()) {
      MarkAsFailed();
      env_->async_hooks()->clear_async_id_stack();
    }
  };
  perform_stopping_check();

  if (env_->is_stopping()) return;

  Isolate* isolate = env_->isolate();
  auto idle = OnScopeLeave([&]() { isolate->SetIdle(true); });

  if (!failed_ && async_context_.async_id != 0 && !skip_hooks_) {
    AsyncWrap::EmitAfter(env_, async_context_.async_id);
  }

  if (pushed_ids_)
    env_->async_hooks()->pop_async_context(async_context_.async_id);

  if (failed_) return;

  if (env_->async_callback_scope_depth() > 1 || skip_task_queues_) {
    return;
  }

  TickInfo* tick_info = env_->tick_info();

  if (!env_->can_call_into_js()) return;

  auto weakref_cleanup = OnScopeLeave([&]() { env_->RunWeakRefCleanup(); }...",96.0,168.0,1.0,1.0,73.0,59,10,51,21,0,0,13,13,0,0,,0,0,0,0,0,void
1067,606,InternalMakeCallback,1,node.InternalMakeCallback,"MaybeLocal<Value> node.InternalMakeCallback (Environment*,Local<Object>,Local<Object>,Local<Function>,int,Local<Value>[],async_context)",api\callback.cc,"MaybeLocal<Value> InternalMakeCallback(Environment* env,
                                       Local<Object> resource,
                                       Local<Object> recv,
                                       const Local<Function> callback,
                                       int argc,
                                       Local<Value> argv[],
                                       async_context asyncContext) {
  CHECK(!recv.IsEmpty());
#ifdef DEBUG
  for (int i = 0; i < argc; i++)
    CHECK(!argv[i].IsEmpty());
#endif

  Local<Function> hook_cb = env->async_hooks_callback_trampoline();
  int flags = InternalCallbackScope::kNoFlags;
  bool use_async_hooks_trampoline = false;
  AsyncHooks* async_hooks = env->async_hooks();
  if (!hook_cb.IsEmpty()) {
    // Use the callback trampoline if there are any before or after hooks, or
    // we can expect some kind of usage of async_hooks.executionAsyncResource().
    flags = InternalCallbackScope::kSkipAsyncHooks;
    use_async...",170.0,229.0,1.0,1.0,60.0,61,9,61,25,1,1,7,8,0,0,,0,1,14,7,7,MaybeLocal<Value>
1068,831,MakeCallback,1,node.MakeCallback,"MaybeLocal<Value> node.MakeCallback (Isolate*,Local<Object>,char*,int,Local<Value>[],async_context)",api\callback.cc,"Local<Value> MakeCallback(Isolate* isolate,
                          Local<Object> recv,
                          Local<Function> callback,
                          int argc,
                          Local<Value>* argv) {
  EscapableHandleScope handle_scope(isolate);
  return handle_scope.Escape(
      MakeCallback(isolate, recv, callback, argc, argv, {0, 0})
          .FromMaybe(Local<Value>()));
}",349.0,358.0,1.0,1.0,10.0,5,4,12,9,3,0,1,1,0,0,,0,0,10,5,5,Local<Value>
1069,1015,MakeSyncCallback,1,node.MakeSyncCallback,"MaybeLocal<Value> node.MakeSyncCallback (Isolate*,Local<Object>,Local<Function>,int,Local<Value>[])",api\callback.cc,"MaybeLocal<Value> MakeSyncCallback(Isolate* isolate,
                                   Local<Object> recv,
                                   Local<Function> callback,
                                   int argc,
                                   Local<Value> argv[]) {
  Environment* env =
      Environment::GetCurrent(callback->GetCreationContext().ToLocalChecked());
  CHECK_NOT_NULL(env);
  if (!env->can_call_into_js()) return Local<Value>();

  Local<Context> context = env->context();
  Context::Scope context_scope(context);
  if (env->async_callback_scope_depth()) {
    // There's another MakeCallback() on the stack, piggy back on it.
    // In particular, retain the current async_context.
    return callback->Call(context, recv, argc, argv);
  }

  // This is a toplevel invocation and the caller (intentionally)
  // didn't provide any async_context to run in. Install a default context.
  MaybeLocal<Value> ret =
    InternalMakeCallback(env, env->process_object(), recv, callba...",299.0,323.0,1.0,1.0,25.0,17,7,26,12,0,0,3,3,0,0,,0,0,10,5,5,MaybeLocal<Value>
1070,1190,<lambda>0,1,node.SpinEventLoopInternal.<lambda>0,ANY node.SpinEventLoopInternal.<lambda>0 (Realm*),api\embed_helpers.cc,[](Realm* realm) { realm->VerifyNoStrongBaseObjects(); },75.0,75.0,21.0,76.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,ANY
1071,1201,<lambda>1,1,node.CommonEnvironmentSetup.CommonEnvironmentSetup.<lambda>1,ANY node.CommonEnvironmentSetup.CommonEnvironmentSetup.<lambda>1 (),api\embed_helpers.cc,"[&]() {
      if (bootstrapCatch.HasCaught()) {
        errors->push_back(FormatCaughtException(
            isolate, isolate->GetCurrentContext(), bootstrapCatch));
      }
    }",136.0,141.0,41.0,5.0,6.0,3,2,5,3,0,0,2,2,0,0,,0,0,0,0,0,ANY
1072,1225,<lambda>2,1,"new CommonEnvironmentSetup( platform, errors, nullptr, true, [&](const CommonEnvironmentSetup* setup) -> Environment* { return CreateEnvironment( setup->isolate_data(), setup->context(), args, exec_args, static_cast<EnvironmentFlags.Flags>(env_flags)); }).<lambda>2","Environment new CommonEnvironmentSetup( platform, errors, nullptr, true, [&](const CommonEnvironmentSetup* setup) -> Environment* { return CreateEnvironment( setup->isolate_data(), setup->context(), args, exec_args, static_cast<EnvironmentFlags.Flags>(env_flags)); }).<lambda>2 (CommonEnvironmentSetup*)",api\embed_helpers.cc,"[&](const CommonEnvironmentSetup* setup) -> Environment* {
        return CreateEnvironment(
            setup->isolate_data(),
            setup->context(),
            args,
            exec_args,
            static_cast<EnvironmentFlags::Flags>(env_flags));
      }",192.0,199.0,7.0,7.0,8.0,3,2,5,4,0,0,1,1,0,0,,0,0,2,1,1,Environment
1073,1249,<lambda>3,1,node.CommonEnvironmentSetup.~CommonEnvironmentSetup.<lambda>3,ANY node.CommonEnvironmentSetup.~CommonEnvironmentSetup.<lambda>3 (void*),api\embed_helpers.cc,"[](void* data) {
      *static_cast<bool*>(data) = true;
    }",217.0,219.0,58.0,5.0,3.0,3,3,1,1,0,0,1,1,0,0,,0,0,2,1,1,ANY
1074,1273,SpinEventLoopInternal,1,node.SpinEventLoopInternal,Maybe<ExitCode> node.SpinEventLoopInternal (Environment*),api\embed_helpers.cc,"Maybe<ExitCode> SpinEventLoopInternal(Environment* env) {
  CHECK_NOT_NULL(env);
  MultiIsolatePlatform* platform = GetMultiIsolatePlatform(env);
  CHECK_NOT_NULL(platform);

  Isolate* isolate = env->isolate();
  HandleScope handle_scope(isolate);
  Context::Scope context_scope(env->context());
  SealHandleScope seal(isolate);

  if (env->is_stopping()) return Nothing<ExitCode>();

  env->set_trace_sync_io(env->options()->trace_sync_io);
  {
    bool more;
    env->performance_state()->Mark(
        node::performance::NODE_PERFORMANCE_MILESTONE_LOOP_START);
    do {
      if (env->is_stopping()) break;
      uv_run(env->event_loop(), UV_RUN_DEFAULT);
      if (env->is_stopping()) break;

      platform->DrainTasks(isolate);

      more = uv_loop_alive(env->event_loop());
      if (more && !env->is_stopping()) continue;

      if (EmitProcessBeforeExit(env).IsNothing())
        break;

      {
        HandleScope handle_scope(isolate);
        if (env->RunSnapshotSerializeCallback()...",22.0,77.0,1.0,1.0,56.0,39,6,41,7,0,0,14,14,0,0,,0,0,2,1,1,Maybe<ExitCode>
1075,1481,CommonEnvironmentSetup,1,node.CommonEnvironmentSetup.CommonEnvironmentSetup,"ANY node.CommonEnvironmentSetup.CommonEnvironmentSetup (MultiIsolatePlatform*,ANY*,EmbedderSnapshotData*,uint32_t,ANY)",api\embed_helpers.cc,"CommonEnvironmentSetup::CommonEnvironmentSetup(
    MultiIsolatePlatform* platform,
    std::vector<std::string>* errors,
    std::function<Environment*(const CommonEnvironmentSetup*)> make_env)
    : CommonEnvironmentSetup(platform, errors, nullptr, false, make_env) {}",168.0,172.0,1.0,75.0,5.0,57,10,63,19,0,15,6,7,2,0,,0,15,6,3,3,ANY
1076,1745,CreateForSnapshotting,1,node.CommonEnvironmentSetup.CreateForSnapshotting,"unique_ptr<CommonEnvironmentSetup> node.CommonEnvironmentSetup.CreateForSnapshotting (MultiIsolatePlatform*,ANY*,ANY,ANY)",node.hpp,"static std::unique_ptr<CommonEnvironmentSetup> CreateForSnapshotting(
      MultiIsolatePlatform* platform,
      std::vector<std::string>* errors,
      const std::vector<std::string>& args = {},
      const std::vector<std::string>& exec_args = {});",854.0,858.0,50.0,53.0,5.0,12,8,12,7,0,0,2,2,0,0,,0,0,8,4,4,ANY
1077,1789,~CommonEnvironmentSetup,1,node.CommonEnvironmentSetup.~CommonEnvironmentSetup,ANY node.CommonEnvironmentSetup.~CommonEnvironmentSetup (),api\embed_helpers.cc,"CommonEnvironmentSetup::~CommonEnvironmentSetup() {
  if (impl_->isolate != nullptr) {
    Isolate* isolate = impl_->isolate;
    {
      Locker locker(isolate);
      Isolate::Scope isolate_scope(isolate);

      impl_->main_context.Reset();
      impl_->env.reset();
      impl_->isolate_data.reset();
    }

    bool platform_finished = false;
    impl_->platform->AddIsolateFinishedCallback(isolate, [](void* data) {
      *static_cast<bool*>(data) = true;
    }, &platform_finished);
    impl_->platform->UnregisterIsolate(isolate);
    if (impl_->snapshot_creator.has_value())
      impl_->snapshot_creator.reset();
    else
      isolate->Dispose();

    // Wait until the platform has cleaned up all relevant resources.
    while (!platform_finished)
      uv_run(&impl_->loop, UV_RUN_ONCE);
  }

  if (impl_->isolate || impl_->loop.data != nullptr)
    CheckedUvLoopClose(&impl_->loop);

  delete impl_;
}",204.0,235.0,1.0,1.0,32.0,29,8,21,3,0,13,5,7,4,0,,0,13,0,0,0,ANY
1078,1901,CreateSnapshot,1,node.CommonEnvironmentSetup.CreateSnapshot,Pointer node.CommonEnvironmentSetup.CreateSnapshot (),api\embed_helpers.cc,"EmbedderSnapshotData::Pointer CommonEnvironmentSetup::CreateSnapshot() {
  CHECK_NOT_NULL(snapshot_creator());
  SnapshotData* snapshot_data = new SnapshotData();
  EmbedderSnapshotData::Pointer result{
      new EmbedderSnapshotData(snapshot_data, true)};

  auto exit_code = SnapshotBuilder::CreateSnapshot(
      snapshot_data,
      this,
      static_cast<uint8_t>(SnapshotMetadata::Type::kFullyCustomized));
  if (exit_code != ExitCode::kNoFailure) return {};

  return result;
}",237.0,250.0,1.0,1.0,14.0,12,6,13,9,0,0,2,2,0,0,,0,0,0,0,0,Pointer
1079,1946,SpinEventLoop,1,node.SpinEventLoop,Maybe<int> node.SpinEventLoop (Environment*),api\embed_helpers.cc,"Maybe<int> SpinEventLoop(Environment* env) {
  Maybe<ExitCode> result = SpinEventLoopInternal(env);
  if (result.IsNothing()) {
    return Nothing<int>();
  }
  return Just(static_cast<int>(result.FromJust()));
}",252.0,258.0,1.0,1.0,7.0,6,5,6,4,0,0,2,2,0,0,,0,0,2,1,1,Maybe<int>
1080,1975,event_loop,1,node.CommonEnvironmentSetup.event_loop,uv_loop_t node.CommonEnvironmentSetup.event_loop (),api\embed_helpers.cc,"uv_loop_t* CommonEnvironmentSetup::event_loop() const {
  return &impl_->loop;
}",260.0,262.0,1.0,1.0,3.0,2,2,1,1,0,0,1,1,0,0,,0,0,0,0,0,uv_loop_t
1081,1984,array_buffer_allocator,1,node.CommonEnvironmentSetup.array_buffer_allocator,shared_ptr<ArrayBufferAllocator> node.CommonEnvironmentSetup.array_buffer_allocator (),api\embed_helpers.cc,"std::shared_ptr<ArrayBufferAllocator>
CommonEnvironmentSetup::array_buffer_allocator() const {
  return impl_->allocator;
}",264.0,267.0,1.0,1.0,4.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,shared_ptr<ArrayBufferAllocator>
1082,1992,isolate,1,node.CommonEnvironmentSetup.isolate,Isolate node.CommonEnvironmentSetup.isolate (),api\embed_helpers.cc,"Isolate* CommonEnvironmentSetup::isolate() const {
  return impl_->isolate;
}",269.0,271.0,1.0,1.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,Isolate
1083,2000,isolate_data,1,node.CommonEnvironmentSetup.isolate_data,IsolateData node.CommonEnvironmentSetup.isolate_data (),api\embed_helpers.cc,"IsolateData* CommonEnvironmentSetup::isolate_data() const {
  return impl_->isolate_data.get();
}",273.0,275.0,1.0,1.0,3.0,2,2,1,1,0,1,1,1,0,0,,0,1,0,0,0,IsolateData
1084,2011,env,1,node.CommonEnvironmentSetup.env,Environment node.CommonEnvironmentSetup.env (),api\embed_helpers.cc,"Environment* CommonEnvironmentSetup::env() const {
  return impl_->env.get();
}",277.0,279.0,1.0,1.0,3.0,2,2,1,1,0,1,1,1,0,0,,0,1,0,0,0,Environment
1085,2022,context,1,node.CommonEnvironmentSetup.context,Local<v8::Context> node.CommonEnvironmentSetup.context (),api\embed_helpers.cc,"v8::Local<v8::Context> CommonEnvironmentSetup::context() const {
  return impl_->main_context.Get(impl_->isolate);
}",281.0,283.0,1.0,1.0,3.0,3,2,2,1,0,2,1,1,0,0,,0,2,0,0,0,Local<v8.Context>
1086,2036,snapshot_creator,1,node.CommonEnvironmentSetup.snapshot_creator,SnapshotCreator node.CommonEnvironmentSetup.snapshot_creator (),api\embed_helpers.cc,"v8::SnapshotCreator* CommonEnvironmentSetup::snapshot_creator() {
  return impl_->snapshot_creator ? &impl_->snapshot_creator.value() : nullptr;
}",285.0,287.0,1.0,1.0,3.0,5,4,2,1,0,2,1,1,0,0,,0,2,0,0,0,SnapshotCreator
1087,2053,operator (),1,node.EmbedderSnapshotData.DeleteSnapshotData.operator (),void node.EmbedderSnapshotData.DeleteSnapshotData.operator () (EmbedderSnapshotData*),api\embed_helpers.cc,"void EmbedderSnapshotData::DeleteSnapshotData::operator()(
    const EmbedderSnapshotData* data) const {
  CHECK_IMPLIES(data->owns_impl_, data->impl_);
  if (data->owns_impl_ &&
      data->impl_->data_ownership == SnapshotData::DataOwnership::kOwned) {
    delete data->impl_;
  }
  delete data;
}",289.0,297.0,1.0,1.0,9.0,12,5,8,3,0,5,2,2,2,0,,0,5,2,1,1,void
1088,2088,BuiltinSnapshotData,1,node.EmbedderSnapshotData.BuiltinSnapshotData,Pointer node.EmbedderSnapshotData.BuiltinSnapshotData (),api\embed_helpers.cc,"EmbedderSnapshotData::Pointer EmbedderSnapshotData::BuiltinSnapshotData() {
  return EmbedderSnapshotData::Pointer{new EmbedderSnapshotData(
      SnapshotBuilder::GetEmbeddedSnapshotData(), false)};
}",299.0,302.0,1.0,1.0,4.0,3,3,2,2,0,0,1,1,0,0,,0,0,0,0,0,Pointer
1089,2102,FromBlob,1,node.EmbedderSnapshotData.FromBlob,Pointer node.EmbedderSnapshotData.FromBlob (ANY),api\embed_helpers.cc,"EmbedderSnapshotData::Pointer EmbedderSnapshotData::FromBlob(
    const std::vector<char>& in) {
  SnapshotData* snapshot_data = new SnapshotData();
  CHECK_EQ(snapshot_data->data_ownership, SnapshotData::DataOwnership::kOwned);
  EmbedderSnapshotData::Pointer result{
      new EmbedderSnapshotData(snapshot_data, true)};
  if (!SnapshotData::FromBlob(snapshot_data, in)) {
    return {};
  }
  return result;
}",304.0,314.0,1.0,1.0,11.0,10,6,12,6,0,0,2,2,0,0,,0,0,2,1,1,Pointer
1090,2141,FromFile,1,node.EmbedderSnapshotData.FromFile,Pointer node.EmbedderSnapshotData.FromFile (FILE*),api\embed_helpers.cc,"EmbedderSnapshotData::Pointer EmbedderSnapshotData::FromFile(FILE* in) {
  return FromBlob(ReadFileSync(in));
}",316.0,318.0,1.0,1.0,3.0,0,0,1,1,0,0,1,1,0,0,,0,0,2,1,1,Pointer
1091,2150,ToBlob,1,node.EmbedderSnapshotData.ToBlob,vector<char> node.EmbedderSnapshotData.ToBlob (),api\embed_helpers.cc,"std::vector<char> EmbedderSnapshotData::ToBlob() const {
  return impl_->ToBlob();
}",320.0,322.0,1.0,1.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,vector<char>
1092,2159,ToFile,1,node.EmbedderSnapshotData.ToFile,void node.EmbedderSnapshotData.ToFile (FILE*),api\embed_helpers.cc,"void EmbedderSnapshotData::ToFile(FILE* out) const {
  impl_->ToFile(out);
}",324.0,326.0,1.0,1.0,3.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
1093,2169,EmbedderSnapshotData,1,node.EmbedderSnapshotData.EmbedderSnapshotData,"ANY node.EmbedderSnapshotData.EmbedderSnapshotData (SnapshotData*,bool)",api\embed_helpers.cc,"EmbedderSnapshotData::EmbedderSnapshotData(const SnapshotData* impl,
                                           bool owns_impl)
    : impl_(impl), owns_impl_(owns_impl) {}",328.0,330.0,1.0,43.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,ANY
1094,2175,CanUseCustomSnapshotPerIsolate,1,node.EmbedderSnapshotData.CanUseCustomSnapshotPerIsolate,bool node.EmbedderSnapshotData.CanUseCustomSnapshotPerIsolate (),api\embed_helpers.cc,"bool EmbedderSnapshotData::CanUseCustomSnapshotPerIsolate() {
#ifdef NODE_V8_SHARED_RO_HEAP
  return false;
#else
  return true;
#endif
}",332.0,338.0,1.0,1.0,7.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,bool
1095,2195,ParseEncoding,1,node.ParseEncoding,"enum encoding node.ParseEncoding (char*,encoding)",api\encoding.cc,"enum encoding ParseEncoding(Isolate* isolate,
                            Local<Value> encoding_v,
                            enum encoding default_encoding) {
  CHECK(!encoding_v.IsEmpty());

  if (!encoding_v->IsString())
    return default_encoding;

  Utf8Value encoding(isolate, encoding_v);

  return ParseEncoding(*encoding, default_encoding);
}",113.0,124.0,1.0,1.0,12.0,37,6,53,11,0,0,31,56,0,0,,0,0,6,3,3,enum encoding
1096,2584,Encode,1,node.Encode,"Local<Value> node.Encode (Isolate*,char*,size_t,encoding)",api\encoding.cc,"Local<Value> Encode(Isolate* isolate, const uint16_t* buf, size_t len) {
  Local<Value> error;
  return StringBytes::Encode(isolate, buf, len, &error)
      .ToLocalChecked();
}",136.0,140.0,1.0,1.0,5.0,5,4,11,9,0,0,1,1,0,0,,0,0,6,3,3,Local<Value>
1097,2639,DecodeBytes,1,node.DecodeBytes,"ssize_t node.DecodeBytes (Isolate*,Local<Value>,encoding)",api\encoding.cc,"ssize_t DecodeBytes(Isolate* isolate,
                    Local<Value> val,
                    enum encoding encoding) {
  HandleScope scope(isolate);

  return StringBytes::Size(isolate, val, encoding).FromMaybe(-1);
}",143.0,149.0,1.0,1.0,7.0,3,2,5,4,0,0,1,1,0,0,,0,0,6,3,3,ssize_t
1098,2662,DecodeWrite,1,node.DecodeWrite,"ssize_t node.DecodeWrite (Isolate*,char*,size_t,Local<Value>,encoding)",api\encoding.cc,"ssize_t DecodeWrite(Isolate* isolate,
                    char* buf,
                    size_t buflen,
                    Local<Value> val,
                    enum encoding encoding) {
  return StringBytes::Write(isolate, buf, buflen, val, encoding);
}",152.0,158.0,1.0,1.0,7.0,1,1,6,6,0,0,1,1,0,0,,0,0,10,5,5,ssize_t
1099,2682,<lambda>0,1,node.LoadEnvironment.<lambda>0,MaybeLocal<Value> node.LoadEnvironment.<lambda>0 (StartExecutionCallbackInfo),api\environment.cc,"[&](const StartExecutionCallbackInfo& info) -> MaybeLocal<Value> {
        Local<Value> main_script =
            ToV8Value(env->context(), main_script_source_utf8).ToLocalChecked();
        return info.run_cjs->Call(
            env->context(), Null(env->isolate()), 1, &main_script);
      }",556.0,561.0,12.0,7.0,6.0,10,6,9,6,0,0,1,1,0,0,,0,0,2,1,1,MaybeLocal<Value>
1100,2725,<lambda>1,1,node.SetProcessExitHandler.<lambda>1,"ANY node.SetProcessExitHandler.<lambda>1 (Environment*,ExitCode)",api\environment.cc,"[=](Environment* env, ExitCode exit_code) {
    movedHandler(env, static_cast<int>(exit_code));
  }",932.0,934.0,33.0,3.0,3.0,1,1,2,2,0,0,1,1,0,0,,0,0,4,2,2,ANY
1101,2776,AllowWasmCodeGenerationCallback,1,node.AllowWasmCodeGenerationCallback,"bool node.AllowWasmCodeGenerationCallback (Local<Context>,Local<String>)",api\environment.cc,"bool AllowWasmCodeGenerationCallback(Local<Context> context,
                                     Local<String>) {
  Local<Value> wasm_code_gen =
      context->GetEmbedderData(ContextEmbedderIndex::kAllowWasmCodeGeneration);
  return wasm_code_gen->IsUndefined() || wasm_code_gen->IsTrue();
}",47.0,52.0,1.0,1.0,6.0,8,6,7,5,0,0,1,1,0,0,,0,0,4,2,2,bool
1102,2805,ShouldAbortOnUncaughtException,1,node.ShouldAbortOnUncaughtException,bool node.ShouldAbortOnUncaughtException (Isolate*),api\environment.cc,"bool ShouldAbortOnUncaughtException(Isolate* isolate) {
  DebugSealHandleScope scope(isolate);
  Environment* env = Environment::GetCurrent(isolate);
  return env != nullptr &&
         (env->is_main_thread() || !env->is_stopping()) &&
         env->abort_on_uncaught_exception() &&
         env->should_abort_on_uncaught_toggle()[0] &&
         !env->inside_should_not_abort_on_uncaught_scope();
}",54.0,62.0,1.0,1.0,9.0,16,8,10,3,0,0,1,1,0,0,,0,0,2,1,1,bool
1103,2854,PrepareStackTraceCallback,1,node.PrepareStackTraceCallback,"MaybeLocal<Value> node.PrepareStackTraceCallback (Local<Context>,Local<Value>,Local<Array>)",api\environment.cc,"MaybeLocal<Value> PrepareStackTraceCallback(Local<Context> context,
                                            Local<Value> exception,
                                            Local<Array> trace) {
  Environment* env = Environment::GetCurrent(context);
  if (env == nullptr) {
    return exception->ToString(context).FromMaybe(Local<Value>());
  }
  Realm* realm = Realm::GetCurrent(context);
  Local<Function> prepare;
  if (realm != nullptr) {
    // If we are in a Realm, call the realm specific prepareStackTrace callback
    // to avoid passing the JS objects (the exception and trace) across the
    // realm boundary with the `Error.prepareStackTrace` override.
    prepare = realm->prepare_stack_trace_callback();
  } else {
    // The context is created with ContextifyContext, call the principal
    // realm's prepareStackTrace callback.
    prepare = env->principal_realm()->prepare_stack_trace_callback();
  }
  if (prepare.IsEmpty()) {
    return exception->ToString(context).Fro...",64.0,102.0,1.0,1.0,39.0,28,10,35,15,0,0,5,5,0,0,,0,0,6,3,3,MaybeLocal<Value>
1104,2985,Allocate,1,node.NodeArrayBufferAllocator.Allocate,void* node.NodeArrayBufferAllocator.Allocate (size_t),api\environment.cc,"void* NodeArrayBufferAllocator::Allocate(size_t size) {
  void* ret;
  if (zero_fill_field_ || per_process::cli_options->zero_fill_all_buffers)
    ret = allocator_->Allocate(size);
  else
    ret = allocator_->AllocateUninitialized(size);
  if (LIKELY(ret != nullptr))
    total_mem_usage_.fetch_add(size, std::memory_order_relaxed);
  return ret;
}",104.0,113.0,1.0,1.0,10.0,8,5,10,7,0,0,3,3,0,0,,0,0,2,1,1,void*
1105,3032,AllocateUninitialized,1,node.NodeArrayBufferAllocator.AllocateUninitialized,void* node.NodeArrayBufferAllocator.AllocateUninitialized (size_t),api\environment.cc,"void* NodeArrayBufferAllocator::AllocateUninitialized(size_t size) {
  void* ret = allocator_->AllocateUninitialized(size);
  if (LIKELY(ret != nullptr))
    total_mem_usage_.fetch_add(size, std::memory_order_relaxed);
  return ret;
}",115.0,120.0,1.0,1.0,6.0,5,4,8,5,0,0,2,2,0,0,,0,0,2,1,1,void*
1106,3061,Reallocate,1,node.NodeArrayBufferAllocator.Reallocate,"void* node.NodeArrayBufferAllocator.Reallocate (void*,size_t,size_t)",api\environment.cc,"void* NodeArrayBufferAllocator::Reallocate(
    void* data, size_t old_size, size_t size) {
  void* ret = allocator_->Reallocate(data, old_size, size);
  if (LIKELY(ret != nullptr) || UNLIKELY(size == 0))
    total_mem_usage_.fetch_add(size - old_size, std::memory_order_relaxed);
  return ret;
}",122.0,128.0,1.0,1.0,7.0,8,7,12,7,0,0,2,2,0,0,,0,0,6,3,3,void*
1107,3101,Free,1,node.NodeArrayBufferAllocator.Free,"void node.NodeArrayBufferAllocator.Free (void*,size_t)",api\environment.cc,"void NodeArrayBufferAllocator::Free(void* data, size_t size) {
  total_mem_usage_.fetch_sub(size, std::memory_order_relaxed);
  allocator_->Free(data, size);
}",130.0,133.0,1.0,1.0,4.0,3,2,6,5,0,0,1,1,0,0,,0,0,4,2,2,void
1108,3121,~DebuggingArrayBufferAllocator,1,node.DebuggingArrayBufferAllocator.~DebuggingArrayBufferAllocator,ANY node.DebuggingArrayBufferAllocator.~DebuggingArrayBufferAllocator (),api\environment.cc,"DebuggingArrayBufferAllocator::~DebuggingArrayBufferAllocator() {
  CHECK(allocations_.empty());
}",135.0,137.0,1.0,1.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,ANY
1109,3130,Allocate,1,node.DebuggingArrayBufferAllocator.Allocate,void* node.DebuggingArrayBufferAllocator.Allocate (size_t),api\environment.cc,"void* DebuggingArrayBufferAllocator::Allocate(size_t size) {
  Mutex::ScopedLock lock(mutex_);
  void* data = NodeArrayBufferAllocator::Allocate(size);
  RegisterPointerInternal(data, size);
  return data;
}",139.0,144.0,1.0,1.0,6.0,2,2,7,4,0,0,1,1,0,0,,0,0,2,1,1,void*
1110,3151,AllocateUninitialized,1,node.DebuggingArrayBufferAllocator.AllocateUninitialized,void* node.DebuggingArrayBufferAllocator.AllocateUninitialized (size_t),api\environment.cc,"void* DebuggingArrayBufferAllocator::AllocateUninitialized(size_t size) {
  Mutex::ScopedLock lock(mutex_);
  void* data = NodeArrayBufferAllocator::AllocateUninitialized(size);
  RegisterPointerInternal(data, size);
  return data;
}",146.0,151.0,1.0,1.0,6.0,2,2,7,4,0,0,1,1,0,0,,0,0,2,1,1,void*
1111,3172,Free,1,node.DebuggingArrayBufferAllocator.Free,"void node.DebuggingArrayBufferAllocator.Free (void*,size_t)",api\environment.cc,"void DebuggingArrayBufferAllocator::Free(void* data, size_t size) {
  Mutex::ScopedLock lock(mutex_);
  UnregisterPointerInternal(data, size);
  NodeArrayBufferAllocator::Free(data, size);
}",153.0,157.0,1.0,1.0,5.0,1,1,6,4,0,0,1,1,0,0,,0,0,4,2,2,void
1112,3190,Reallocate,1,node.DebuggingArrayBufferAllocator.Reallocate,"void* node.DebuggingArrayBufferAllocator.Reallocate (void*,size_t,size_t)",api\environment.cc,"void* DebuggingArrayBufferAllocator::Reallocate(void* data,
                                                size_t old_size,
                                                size_t size) {
  Mutex::ScopedLock lock(mutex_);
  void* ret = NodeArrayBufferAllocator::Reallocate(data, old_size, size);
  if (ret == nullptr) {
    if (size == 0) {  // i.e. equivalent to free().
      // suppress coverity warning as data is used as key versus as pointer
      // in UnregisterPointerInternal
      // coverity[pass_freed_arg]
      UnregisterPointerInternal(data, old_size);
    }
    return nullptr;
  }

  if (data != nullptr) {
    auto it = allocations_.find(data);
    CHECK_NE(it, allocations_.end());
    allocations_.erase(it);
  }

  RegisterPointerInternal(ret, size);
  return ret;
}",159.0,182.0,1.0,1.0,24.0,9,4,21,8,0,0,4,5,0,0,,0,0,6,3,3,void*
1113,3254,RegisterPointer,1,node.DebuggingArrayBufferAllocator.RegisterPointer,"void node.DebuggingArrayBufferAllocator.RegisterPointer (void*,size_t)",api\environment.cc,"void DebuggingArrayBufferAllocator::RegisterPointer(void* data, size_t size) {
  Mutex::ScopedLock lock(mutex_);
  NodeArrayBufferAllocator::RegisterPointer(data, size);
  RegisterPointerInternal(data, size);
}",184.0,188.0,1.0,1.0,5.0,1,1,6,4,0,0,1,1,0,0,,0,0,4,2,2,void
1114,3272,UnregisterPointer,1,node.DebuggingArrayBufferAllocator.UnregisterPointer,"void node.DebuggingArrayBufferAllocator.UnregisterPointer (void*,size_t)",api\environment.cc,"void DebuggingArrayBufferAllocator::UnregisterPointer(void* data, size_t size) {
  Mutex::ScopedLock lock(mutex_);
  NodeArrayBufferAllocator::UnregisterPointer(data, size);
  UnregisterPointerInternal(data, size);
}",190.0,194.0,1.0,1.0,5.0,1,1,6,4,0,0,1,1,0,0,,0,0,4,2,2,void
1115,3290,UnregisterPointerInternal,1,node.DebuggingArrayBufferAllocator.UnregisterPointerInternal,"void node.DebuggingArrayBufferAllocator.UnregisterPointerInternal (void*,size_t)",api\environment.cc,"void DebuggingArrayBufferAllocator::UnregisterPointerInternal(void* data,
                                                              size_t size) {
  if (data == nullptr) return;
  auto it = allocations_.find(data);
  CHECK_NE(it, allocations_.end());
  if (size > 0) {
    // We allow allocations with size 1 for 0-length buffers to avoid having
    // to deal with nullptr values.
    CHECK_EQ(it->second, size);
  }
  allocations_.erase(it);
}",196.0,207.0,1.0,1.0,12.0,7,5,11,4,0,0,3,3,0,0,,0,0,4,2,2,void
1116,3331,RegisterPointerInternal,1,node.DebuggingArrayBufferAllocator.RegisterPointerInternal,"void node.DebuggingArrayBufferAllocator.RegisterPointerInternal (void*,size_t)",api\environment.cc,"void DebuggingArrayBufferAllocator::RegisterPointerInternal(void* data,
                                                            size_t size) {
  if (data == nullptr) return;
  CHECK_EQ(allocations_.count(data), 0);
  allocations_[data] = size;
}",209.0,214.0,1.0,1.0,6.0,4,4,6,3,0,0,2,2,0,0,,0,0,4,2,2,void
1117,3355,Create,1,node.ArrayBufferAllocator.Create,unique_ptr<ArrayBufferAllocator> node.ArrayBufferAllocator.Create (bool),api\environment.cc,"std::unique_ptr<ArrayBufferAllocator> ArrayBufferAllocator::Create(bool debug) {
  if (debug || per_process::cli_options->debug_arraybuffer_allocations)
    return std::make_unique<DebuggingArrayBufferAllocator>();
  else
    return std::make_unique<NodeArrayBufferAllocator>();
}",216.0,221.0,1.0,1.0,6.0,4,3,3,3,1,0,2,2,0,0,,0,0,2,1,1,unique_ptr<ArrayBufferAllocator>
1118,3381,CreateArrayBufferAllocator,1,node.CreateArrayBufferAllocator,ArrayBufferAllocator node.CreateArrayBufferAllocator (),api\environment.cc,"ArrayBufferAllocator* CreateArrayBufferAllocator() {
  return ArrayBufferAllocator::Create().release();
}",223.0,225.0,1.0,1.0,3.0,2,1,1,1,0,1,1,1,0,1,,0,0,0,0,0,ArrayBufferAllocator
1119,3393,FreeArrayBufferAllocator,1,node.FreeArrayBufferAllocator,void node.FreeArrayBufferAllocator (ArrayBufferAllocator*),api\environment.cc,"void FreeArrayBufferAllocator(ArrayBufferAllocator* allocator) {
  delete allocator;
}",227.0,229.0,1.0,1.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,void
1120,3400,SetIsolateCreateParamsForNode,1,node.SetIsolateCreateParamsForNode,void node.SetIsolateCreateParamsForNode (ANY*),api\environment.cc,"void SetIsolateCreateParamsForNode(Isolate::CreateParams* params) {
  const uint64_t constrained_memory = uv_get_constrained_memory();
  const uint64_t total_memory = constrained_memory > 0 ?
      std::min(uv_get_total_memory(), constrained_memory) :
      uv_get_total_memory();
  if (total_memory > 0 &&
      params->constraints.max_old_generation_size_in_bytes() == 0) {
    // V8 defaults to 700MB or 1.4GB on 32 and 64 bit platforms respectively.
    // This default is based on browser use-cases. Tell V8 to configure the
    // heap based on the actual physical memory.
    params->constraints.ConfigureDefaults(total_memory, 0);
  }
  params->embedder_wrapper_object_index = BaseObject::InternalFields::kSlot;
  params->embedder_wrapper_type_index = std::numeric_limits<int>::max();

#ifdef NODE_ENABLE_VTUNE_PROFILING
  params->code_event_handler = vTune::GetVtuneCodeEventHandler();
#endif
}",231.0,249.0,1.0,1.0,19.0,20,7,15,7,0,0,2,2,0,0,,0,0,2,1,1,void
1121,3464,SetIsolateErrorHandlers,1,node.SetIsolateErrorHandlers,"void node.SetIsolateErrorHandlers (ANY*,IsolateSettings)",api\environment.cc,"void SetIsolateErrorHandlers(v8::Isolate* isolate, const IsolateSettings& s) {
  if (s.flags & MESSAGE_LISTENER_WITH_ERROR_LEVEL)
    isolate->AddMessageListenerWithErrorLevel(
            errors::PerIsolateMessageListener,
            Isolate::MessageErrorLevel::kMessageError |
                Isolate::MessageErrorLevel::kMessageWarning);

  auto* abort_callback = s.should_abort_on_uncaught_exception_callback ?
      s.should_abort_on_uncaught_exception_callback :
      ShouldAbortOnUncaughtException;
  isolate->SetAbortOnUncaughtExceptionCallback(abort_callback);

  auto* fatal_error_cb = s.fatal_error_callback ?
      s.fatal_error_callback : OnFatalError;
  isolate->SetFatalErrorHandler(fatal_error_cb);
  isolate->SetOOMErrorHandler(OOMErrorHandler);

  if ((s.flags & SHOULD_NOT_SET_PREPARE_STACK_TRACE_CALLBACK) == 0) {
    auto* prepare_stack_trace_cb = s.prepare_stack_trace_callback ?
        s.prepare_stack_trace_callback : PrepareStackTraceCallback;
    isolate->SetPrepareSt...",251.0,273.0,1.0,1.0,23.0,28,7,28,12,0,8,3,3,2,0,,0,8,4,2,2,void
1122,3557,SetIsolateMiscHandlers,1,node.SetIsolateMiscHandlers,"void node.SetIsolateMiscHandlers (ANY*,IsolateSettings)",api\environment.cc,"void SetIsolateMiscHandlers(v8::Isolate* isolate, const IsolateSettings& s) {
  isolate->SetMicrotasksPolicy(s.policy);

  auto* allow_wasm_codegen_cb = s.allow_wasm_code_generation_callback ?
    s.allow_wasm_code_generation_callback : AllowWasmCodeGenerationCallback;
  isolate->SetAllowWasmCodeGenerationCallback(allow_wasm_codegen_cb);

  auto* modify_code_generation_from_strings_callback =
      ModifyCodeGenerationFromStrings;
  if (s.modify_code_generation_from_strings_callback != nullptr) {
    modify_code_generation_from_strings_callback =
        s.modify_code_generation_from_strings_callback;
  }
  isolate->SetModifyCodeGenerationFromStringsCallback(
      modify_code_generation_from_strings_callback);

  Mutex::ScopedLock lock(node::per_process::cli_options_mutex);
  if (per_process::cli_options->get_per_isolate_options()
          ->get_per_env_options()
          ->experimental_fetch) {
    isolate->SetWasmStreamingCallback(wasm_web_api::StartStreamingCompilation);
  }

...",275.0,312.0,1.0,1.0,38.0,38,7,35,15,0,9,6,6,3,0,,0,9,4,2,2,void
1123,3690,SetIsolateUpForNode,1,node.SetIsolateUpForNode,"void node.SetIsolateUpForNode (ANY*,IsolateSettings)",api\environment.cc,"void SetIsolateUpForNode(v8::Isolate* isolate) {
  IsolateSettings settings;
  SetIsolateUpForNode(isolate, settings);
}",320.0,323.0,1.0,1.0,4.0,0,0,4,2,0,0,1,1,0,0,,0,0,2,1,1,void
1124,3711,NewIsolate,1,node.NewIsolate,"Isolate node.NewIsolate (ANY*,uv_loop_t*,MultiIsolatePlatform*,SnapshotData*,IsolateSettings)",json_parser.cc,"static Isolate* NewIsolate(v8::ArrayBuffer::Allocator* allocator) {
  Isolate* isolate = Isolate::Allocate();
  CHECK_NOT_NULL(isolate);
  per_process::v8_platform.Platform()->RegisterIsolate(isolate,
                                                       uv_default_loop());
  Isolate::CreateParams params;
  params.array_buffer_allocator = allocator;
  Isolate::Initialize(isolate, params);
  return isolate;
}",15.0,24.0,1.0,1.0,10.0,9,6,18,8,0,0,4,4,0,0,,0,0,2,1,1,Isolate
1125,3837,CreateIsolateData,1,node.CreateIsolateData,"IsolateData node.CreateIsolateData (Isolate*,uv_loop_t*,MultiIsolatePlatform*,ArrayBufferAllocator*,EmbedderSnapshotData*)",api\environment.cc,"IsolateData* CreateIsolateData(
    Isolate* isolate,
    uv_loop_t* loop,
    MultiIsolatePlatform* platform,
    ArrayBufferAllocator* allocator,
    const EmbedderSnapshotData* embedder_snapshot_data) {
  const SnapshotData* snapshot_data =
      SnapshotData::FromEmbedderWrapper(embedder_snapshot_data);
  return new IsolateData(isolate, loop, platform, allocator, snapshot_data);
}",396.0,405.0,1.0,1.0,10.0,3,3,9,8,0,0,1,1,0,0,,0,0,10,5,5,IsolateData
1126,3862,FreeIsolateData,1,node.FreeIsolateData,void node.FreeIsolateData (IsolateData*),api\environment.cc,"void FreeIsolateData(IsolateData* isolate_data) {
  delete isolate_data;
}",407.0,409.0,1.0,1.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,void
1127,3869,~InspectorParentHandle,1,node.InspectorParentHandle.~InspectorParentHandle,ANY node.InspectorParentHandle.~InspectorParentHandle (),api\environment.cc,InspectorParentHandle::~InspectorParentHandle() {},411.0,411.0,1.0,50.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
1128,3873,CreateEnvironment,1,node.CreateEnvironment,"Environment node.CreateEnvironment (IsolateData*,Local<Context>,ANY,ANY,ANY,ThreadId,ANY)",api\environment.cc,"Environment* CreateEnvironment(
    IsolateData* isolate_data,
    Local<Context> context,
    const std::vector<std::string>& args,
    const std::vector<std::string>& exec_args,
    EnvironmentFlags::Flags flags,
    ThreadId thread_id,
    std::unique_ptr<InspectorParentHandle> inspector_parent_handle) {
  Isolate* isolate = isolate_data->isolate();
  HandleScope handle_scope(isolate);

  const bool use_snapshot = context.IsEmpty();
  const EnvSerializeInfo* env_snapshot_info = nullptr;
  if (use_snapshot) {
    CHECK_NOT_NULL(isolate_data->snapshot_data());
    env_snapshot_info = &isolate_data->snapshot_data()->env_info;
  }

  // TODO(addaleax): This is a much better place for parsing per-Environment
  // options than the global parse call.
  Environment* env = new Environment(isolate_data,
                                     isolate,
                                     args,
                                     exec_args,
                                     env_snapshot_in...",424.0,490.0,1.0,1.0,67.0,27,8,40,14,0,0,5,6,0,0,,0,0,14,7,7,Environment
1129,4008,FreeEnvironment,1,node.FreeEnvironment,void node.FreeEnvironment (Environment*),api\environment.cc,"void FreeEnvironment(Environment* env) {
  Isolate* isolate = env->isolate();
  Isolate::DisallowJavascriptExecutionScope disallow_js(isolate,
      Isolate::DisallowJavascriptExecutionScope::THROW_ON_FAILURE);
  {
    HandleScope handle_scope(isolate);  // For env->context().
    Context::Scope context_scope(env->context());
    SealHandleScope seal_handle_scope(isolate);

    // Set the flag in accordance with the DisallowJavascriptExecutionScope
    // above.
    env->set_can_call_into_js(false);
    env->set_stopping(true);
    env->stop_sub_worker_contexts();
    env->RunCleanup();
    RunAtExit(env);
  }

  // This call needs to be made while the `Environment` is still alive
  // because we assume that it is available for async tracking in the
  // NodePlatform implementation.
  MultiIsolatePlatform* platform = env->isolate_data()->platform();
  if (platform != nullptr)
    platform->DrainTasks(isolate);

  delete env;
}",492.0,518.0,1.0,1.0,27.0,15,5,19,5,0,0,2,2,0,0,,0,0,2,1,1,void
1130,4083,GetInspectorParentHandle,1,node.GetInspectorParentHandle,"unique_ptr<InspectorParentHandle> node.GetInspectorParentHandle (Environment*,ThreadId,char*)",api\environment.cc,"NODE_EXTERN std::unique_ptr<InspectorParentHandle> GetInspectorParentHandle(
    Environment* env, ThreadId thread_id, const char* url, const char* name) {
  CHECK_NOT_NULL(env);
  if (name == nullptr) name = """";
  CHECK_NE(thread_id.id, static_cast<uint64_t>(-1));
  if (!env->should_create_inspector()) {
    return nullptr;
  }
#if HAVE_INSPECTOR
  return std::make_unique<InspectorParentHandleImpl>(
      env->inspector_agent()->GetParentHandle(thread_id.id, url, name));
#else
  return {};
#endif
}",527.0,541.0,1.0,11.0,15.0,0,0,3,3,0,0,1,1,0,0,,0,0,8,4,4,unique_ptr<InspectorParentHandle>
1131,4132,LoadEnvironment,1,node.LoadEnvironment,"MaybeLocal<Value> node.LoadEnvironment (Environment*,StartExecutionCallback)",api\environment.cc,"MaybeLocal<Value> LoadEnvironment(Environment* env,
                                  std::string_view main_script_source_utf8) {
  CHECK_NOT_NULL(main_script_source_utf8.data());
  return LoadEnvironment(
      env, [&](const StartExecutionCallbackInfo& info) -> MaybeLocal<Value> {
        Local<Value> main_script =
            ToV8Value(env->context(), main_script_source_utf8).ToLocalChecked();
        return info.run_cjs->Call(
            env->context(), Null(env->isolate()), 1, &main_script);
      });
}",552.0,562.0,1.0,1.0,11.0,2,1,4,2,0,0,1,1,0,0,,0,0,4,2,2,MaybeLocal<Value>
1132,4163,GetCurrentEnvironment,1,node.GetCurrentEnvironment,Environment node.GetCurrentEnvironment (Local<Context>),api\environment.cc,"Environment* GetCurrentEnvironment(Local<Context> context) {
  return Environment::GetCurrent(context);
}",564.0,566.0,1.0,1.0,3.0,1,1,2,2,0,0,1,1,0,0,,0,0,2,1,1,Environment
1133,4174,GetEnvironmentIsolateData,1,node.GetEnvironmentIsolateData,IsolateData node.GetEnvironmentIsolateData (Environment*),api\environment.cc,"IsolateData* GetEnvironmentIsolateData(Environment* env) {
  return env->isolate_data();
}",568.0,570.0,1.0,1.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,IsolateData
1134,4184,GetArrayBufferAllocator,1,node.GetArrayBufferAllocator,ArrayBufferAllocator node.GetArrayBufferAllocator (IsolateData*),api\environment.cc,"ArrayBufferAllocator* GetArrayBufferAllocator(IsolateData* isolate_data) {
  return isolate_data->node_allocator();
}",572.0,574.0,1.0,1.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,ArrayBufferAllocator
1135,4194,GetMainContext,1,node.GetMainContext,Local<Context> node.GetMainContext (Environment*),api\environment.cc,"Local<Context> GetMainContext(Environment* env) {
  return env->context();
}",576.0,578.0,1.0,1.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,Local<Context>
1136,4204,GetMultiIsolatePlatform,1,node.GetMultiIsolatePlatform,MultiIsolatePlatform node.GetMultiIsolatePlatform (Environment*),api\environment.cc,"MultiIsolatePlatform* GetMultiIsolatePlatform(IsolateData* env) {
  return env->platform();
}",584.0,586.0,1.0,1.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,MultiIsolatePlatform
1137,4225,CreatePlatform,1,node.CreatePlatform,"MultiIsolatePlatform node.CreatePlatform (int,ANY*)",api\environment.cc,"MultiIsolatePlatform* CreatePlatform(
    int thread_pool_size,
    v8::TracingController* tracing_controller) {
  return MultiIsolatePlatform::Create(thread_pool_size,
                                      tracing_controller)
      .release();
}",596.0,602.0,1.0,1.0,7.0,1,1,2,2,0,0,1,1,0,0,,0,0,4,2,2,MultiIsolatePlatform
1138,4253,FreePlatform,1,node.FreePlatform,void node.FreePlatform (MultiIsolatePlatform*),api\environment.cc,"void FreePlatform(MultiIsolatePlatform* platform) {
  delete platform;
}",604.0,606.0,1.0,1.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,void
1139,4260,Create,1,node.MultiIsolatePlatform.Create,"unique_ptr<MultiIsolatePlatform> node.MultiIsolatePlatform.Create (int,ANY*,ANY*)",api\environment.cc,"std::unique_ptr<MultiIsolatePlatform> MultiIsolatePlatform::Create(
    int thread_pool_size,
    v8::TracingController* tracing_controller,
    v8::PageAllocator* page_allocator) {
  return std::make_unique<NodePlatform>(thread_pool_size,
                                        tracing_controller,
                                        page_allocator);
}",608.0,615.0,1.0,1.0,8.0,5,5,5,5,0,0,1,1,0,0,,0,0,6,3,3,unique_ptr<MultiIsolatePlatform>
1140,4279,GetPerContextExports,1,node.GetPerContextExports,MaybeLocal<Object> node.GetPerContextExports (Local<Context>),api\environment.cc,"MaybeLocal<Object> GetPerContextExports(Local<Context> context) {
  Isolate* isolate = context->GetIsolate();
  EscapableHandleScope handle_scope(isolate);

  Local<Object> global = context->Global();
  Local<Private> key = Private::ForApi(isolate,
      FIXED_ONE_BYTE_STRING(isolate, ""node:per_context_binding_exports""));

  Local<Value> existing_value;
  if (!global->GetPrivate(context, key).ToLocal(&existing_value))
    return MaybeLocal<Object>();
  if (existing_value->IsObject())
    return handle_scope.Escape(existing_value.As<Object>());

  Local<Object> exports = Object::New(isolate);
  if (context->Global()->SetPrivate(context, key, exports).IsNothing() ||
      InitializePrimordials(context).IsNothing())
    return MaybeLocal<Object>();
  return handle_scope.Escape(exports);
}",617.0,636.0,1.0,1.0,20.0,29,8,35,11,0,0,4,4,0,0,,0,0,2,1,1,MaybeLocal<Object>
1141,4394,NewContext,1,node.NewContext,"Local<Context> node.NewContext (Isolate*,Local<ObjectTemplate>)",api\environment.cc,"Local<Context> NewContext(Isolate* isolate,
                          Local<ObjectTemplate> object_template) {
  auto context = Context::New(isolate, nullptr, object_template);
  if (context.IsEmpty()) return context;

  if (InitializeContext(context).IsNothing()) {
    return Local<Context>();
  }

  return context;
}",641.0,651.0,1.0,1.0,11.0,4,2,8,4,0,0,3,3,0,0,,0,0,4,2,2,Local<Context>
1142,4429,ProtoThrower,1,node.ProtoThrower,void node.ProtoThrower (FunctionCallbackInfo<Value>),api\environment.cc,"void ProtoThrower(const FunctionCallbackInfo<Value>& info) {
  THROW_ERR_PROTO_ACCESS(info.GetIsolate());
}",653.0,655.0,1.0,1.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,void
1143,4439,InitializeContextRuntime,1,node.InitializeContextRuntime,Maybe<bool> node.InitializeContextRuntime (Local<Context>),api\environment.cc,"Maybe<bool> InitializeContextRuntime(Local<Context> context) {
  Isolate* isolate = context->GetIsolate();
  HandleScope handle_scope(isolate);

  // When `IsCodeGenerationFromStringsAllowed` is true, V8 takes the fast path
  // and ignores the ModifyCodeGenerationFromStrings callback. Set it to false
  // to delegate the code generation validation to
  // node::ModifyCodeGenerationFromStrings.
  // The `IsCodeGenerationFromStringsAllowed` can be refreshed by V8 according
  // to the runtime flags, propagate the value to the embedder data.
  bool is_code_generation_from_strings_allowed =
      context->IsCodeGenerationFromStringsAllowed();
  context->AllowCodeGenerationFromStrings(false);
  context->SetEmbedderData(
      ContextEmbedderIndex::kAllowCodeGenerationFromStrings,
      Boolean::New(isolate, is_code_generation_from_strings_allowed));

  if (per_process::cli_options->disable_proto == """") {
    return Just(true);
  }

  // Remove __proto__
  // https://github.com/nodejs/no...",659.0,736.0,1.0,1.0,78.0,43,8,47,16,0,0,6,7,0,0,,0,0,2,1,1,Maybe<bool>
1144,4677,InitializeBaseContextForSnapshot,1,node.InitializeBaseContextForSnapshot,Maybe<bool> node.InitializeBaseContextForSnapshot (Local<Context>),api\environment.cc,"Maybe<bool> InitializeBaseContextForSnapshot(Local<Context> context) {
  Isolate* isolate = context->GetIsolate();
  HandleScope handle_scope(isolate);

  // Delete `Intl.v8BreakIterator`
  // https://github.com/nodejs/node/issues/14909
  {
    Context::Scope context_scope(context);
    Local<String> intl_string = FIXED_ONE_BYTE_STRING(isolate, ""Intl"");
    Local<String> break_iter_string =
        FIXED_ONE_BYTE_STRING(isolate, ""v8BreakIterator"");

    Local<Value> intl_v;
    if (!context->Global()->Get(context, intl_string).ToLocal(&intl_v)) {
      return Nothing<bool>();
    }

    if (intl_v->IsObject() &&
        intl_v.As<Object>()->Delete(context, break_iter_string).IsNothing()) {
      return Nothing<bool>();
    }
  }
  return Just(true);
}",738.0,761.0,1.0,1.0,24.0,20,8,23,8,0,0,3,3,0,0,,0,0,2,1,1,Maybe<bool>
1145,4762,InitializeMainContextForSnapshot,1,node.InitializeMainContextForSnapshot,Maybe<bool> node.InitializeMainContextForSnapshot (Local<Context>),api\environment.cc,"Maybe<bool> InitializeMainContextForSnapshot(Local<Context> context) {
  Isolate* isolate = context->GetIsolate();
  HandleScope handle_scope(isolate);

  // Initialize the default values.
  context->SetEmbedderData(ContextEmbedderIndex::kAllowWasmCodeGeneration,
                           True(isolate));
  context->SetEmbedderData(
      ContextEmbedderIndex::kAllowCodeGenerationFromStrings, True(isolate));

  if (InitializeBaseContextForSnapshot(context).IsNothing()) {
    return Nothing<bool>();
  }
  return InitializePrimordials(context);
}",763.0,777.0,1.0,1.0,15.0,7,3,11,3,0,0,2,2,0,0,,0,0,2,1,1,Maybe<bool>
1146,4807,InitializePrimordials,1,node.InitializePrimordials,Maybe<bool> node.InitializePrimordials (Local<Context>),api\environment.cc,"Maybe<bool> InitializePrimordials(Local<Context> context) {
  // Run per-context JS files.
  Isolate* isolate = context->GetIsolate();
  Context::Scope context_scope(context);
  Local<Object> exports;

  Local<String> primordials_string =
      FIXED_ONE_BYTE_STRING(isolate, ""primordials"");

  // Create primordials first and make it available to per-context scripts.
  Local<Object> primordials = Object::New(isolate);
  if (primordials->SetPrototype(context, Null(isolate)).IsNothing() ||
      !GetPerContextExports(context).ToLocal(&exports) ||
      exports->Set(context, primordials_string, primordials).IsNothing()) {
    return Nothing<bool>();
  }

  static const char* context_files[] = {""internal/per_context/primordials"",
                                        ""internal/per_context/domexception"",
                                        ""internal/per_context/messageport"",
                                        nullptr};

  // We do not have access to a per-Environment BuiltinLoa...",779.0,819.0,1.0,1.0,41.0,30,11,36,12,0,0,4,5,0,0,,0,0,2,1,1,Maybe<bool>
1147,4930,InitializeContext,1,node.InitializeContext,Maybe<bool> node.InitializeContext (Local<Context>),api\environment.cc,"Maybe<bool> InitializeContext(Local<Context> context) {
  if (InitializeMainContextForSnapshot(context).IsNothing()) {
    return Nothing<bool>();
  }

  return InitializeContextRuntime(context);
}",822.0,828.0,1.0,1.0,7.0,1,1,2,1,0,0,2,2,0,0,,0,0,2,1,1,Maybe<bool>
1148,4947,GetCurrentEventLoop,1,node.GetCurrentEventLoop,uv_loop_t node.GetCurrentEventLoop (Isolate*),api\environment.cc,"uv_loop_t* GetCurrentEventLoop(Isolate* isolate) {
  HandleScope handle_scope(isolate);
  Local<Context> context = isolate->GetCurrentContext();
  if (context.IsEmpty()) return nullptr;
  Environment* env = Environment::GetCurrent(context);
  if (env == nullptr) return nullptr;
  return env->event_loop();
}",830.0,837.0,1.0,1.0,8.0,9,6,11,6,0,0,3,3,0,0,,0,0,2,1,1,uv_loop_t
1149,4993,AddLinkedBinding,1,node.AddLinkedBinding,"void node.AddLinkedBinding (Environment*,node_module)",api\environment.cc,"void AddLinkedBinding(Environment* env,
                      const char* name,
                      napi_addon_register_func fn,
                      int32_t module_api_version) {
  node_module mod = {
      -1,           // nm_version for Node-API
      NM_F_LINKED,  // nm_flags
      nullptr,      // nm_dso_handle
      nullptr,      // nm_filename
      nullptr,      // nm_register_func
      get_node_api_context_register_func(env, name, module_api_version),
      name,                         // nm_modname
      reinterpret_cast<void*>(fn),  // nm_priv
      nullptr                       // nm_link
  };
  AddLinkedBinding(env, mod);
}",873.0,889.0,1.0,1.0,17.0,11,4,9,3,0,1,2,2,0,0,,0,1,8,4,4,void
1150,5120,AllocateEnvironmentThreadId,1,node.AllocateEnvironmentThreadId,ThreadId node.AllocateEnvironmentThreadId (),api\environment.cc,"ThreadId AllocateEnvironmentThreadId() {
  return ThreadId { next_thread_id++ };
}",893.0,895.0,1.0,1.0,3.0,2,2,1,1,0,0,1,1,0,0,,0,0,0,0,0,ThreadId
1151,5129,Exit,1,node.Exit,void node.Exit (ExitCode),api\environment.cc,"[[noreturn]] void Exit(ExitCode exit_code) {
  exit(static_cast<int>(exit_code));
}",897.0,899.0,1.0,1.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,void
1152,5138,DefaultProcessExitHandlerInternal,1,node.DefaultProcessExitHandlerInternal,"void node.DefaultProcessExitHandlerInternal (Environment*,ExitCode)",api\environment.cc,"void DefaultProcessExitHandlerInternal(Environment* env, ExitCode exit_code) {
  env->set_stopping(true);
  env->set_can_call_into_js(false);
  env->stop_sub_worker_contexts();
  env->isolate()->DumpAndResetStats();
  // The tracing agent could be in the process of writing data using the
  // threadpool. Stop it before shutting down libuv. The rest of the tracing
  // agent disposal will be performed in DisposePlatform().
  per_process::v8_platform.StopTracingAgent();
  // When the process exits, the tasks in the thread pool may also need to
  // access the data of V8Platform, such as trace agent, or a field
  // added in the future. So make sure the thread pool exits first.
  // And make sure V8Platform don not call into Libuv threadpool, see Dispose
  // in node_v8_platform-inl.h
  uv_library_shutdown();
  DisposePlatform();
  Exit(exit_code);
}",901.0,918.0,1.0,1.0,18.0,7,2,6,3,0,0,1,1,0,0,,0,0,4,2,2,void
1153,5175,DefaultProcessExitHandler,1,node.DefaultProcessExitHandler,"void node.DefaultProcessExitHandler (Environment*,int)",api\environment.cc,"void DefaultProcessExitHandler(Environment* env, int exit_code) {
  DefaultProcessExitHandlerInternal(env, static_cast<ExitCode>(exit_code));
}",920.0,922.0,1.0,1.0,3.0,1,1,2,2,0,0,1,1,0,0,,0,0,4,2,2,void
1154,5186,SetProcessExitHandler,1,node.SetProcessExitHandler,"void node.SetProcessExitHandler (Environment*,ANY)",api\environment.cc,"void SetProcessExitHandler(Environment* env,
                           std::function<void(Environment*, int)>&& handler) {
  auto movedHandler = std::move(handler);
  env->set_process_exit_handler([=](Environment* env, ExitCode exit_code) {
    movedHandler(env, static_cast<int>(exit_code));
  });
}",929.0,935.0,1.0,1.0,7.0,2,2,3,3,0,0,1,1,0,0,,0,0,4,2,2,void
1155,5239,ErrnoException,1,node.ErrnoException,"Local<Value> node.ErrnoException (Isolate*,int,char*,char*,char*)",node.hpp,"NODE_DEPRECATED(""Use ErrnoException(isolate, ...)"",
                inline v8::Local<v8::Value> ErrnoException(
      int errorno,
      const char* syscall = nullptr,
      const char* message = nullptr,
      const char* path = nullptr) {
  return ErrnoException(v8::Isolate::GetCurrent(),
                        errorno,
                        syscall,
                        message,
                        path);
})",151.0,162.0,1.0,2.0,12.0,62,9,91,22,0,0,6,6,0,0,,0,0,8,4,4,Local<v8.Value>
1156,5485,StringFromPath,1,node.StringFromPath,"Local<String> node.StringFromPath (Isolate*,char*)",api\exceptions.cc,"static Local<String> StringFromPath(Isolate* isolate, const char* path) {
#ifdef _WIN32
  if (strncmp(path, ""\\\\?\\UNC\\"", 8) == 0) {
    return String::Concat(
        isolate,
        FIXED_ONE_BYTE_STRING(isolate, ""\\\\""),
        String::NewFromUtf8(isolate, path + 8).ToLocalChecked());
  } else if (strncmp(path, ""\\\\?\\"", 4) == 0) {
    return String::NewFromUtf8(isolate, path + 4).ToLocalChecked();
  }
#endif

  return String::NewFromUtf8(isolate, path).ToLocalChecked();
}",75.0,88.0,1.0,1.0,14.0,2,1,3,3,0,0,1,1,0,0,,0,0,4,2,2,Local<String>
1157,5501,UVException,1,node.UVException,"Local<Value> node.UVException (Isolate*,int,char*,char*,char*,char*)",node.hpp,"NODE_DEPRECATED(""Use UVException(isolate, ...)"",
                inline v8::Local<v8::Value> UVException(int errorno,
                                        const char* syscall = nullptr,
                                        const char* message = nullptr,
                                        const char* path = nullptr) {
  return UVException(v8::Isolate::GetCurrent(),
                     errorno,
                     syscall,
                     message,
                     path);
})",164.0,174.0,1.0,2.0,11.0,75,9,122,21,0,0,6,6,0,0,,0,0,8,4,4,Local<v8.Value>
1158,5811,FatalException,1,node.FatalException,"void node.FatalException (Isolate*,ANY)",api\exceptions.cc,"void FatalException(Isolate* isolate, const v8::TryCatch& try_catch) {
  errors::TriggerUncaughtException(isolate, try_catch);
}",246.0,248.0,1.0,1.0,3.0,1,1,3,3,0,0,1,1,0,0,,0,0,4,2,2,void
1159,5824,<lambda>0,1,node.RequestInterrupt.<lambda>0,ANY node.RequestInterrupt.<lambda>0 (Environment*),api\hooks.cc,"[fun, arg](Environment* env) {
    // Disallow JavaScript execution during interrupt.
    Isolate::DisallowJavascriptExecutionScope scope(
        env->isolate(),
        Isolate::DisallowJavascriptExecutionScope::CRASH_ON_FAILURE);
    fun(arg);
  }",172.0,178.0,25.0,3.0,7.0,3,2,4,4,0,0,1,1,0,0,,0,0,2,1,1,ANY
1160,5858,RunAtExit,1,node.RunAtExit,void node.RunAtExit (Environment*),api\hooks.cc,"void RunAtExit(Environment* env) {
  env->RunAtExitCallbacks();
}",20.0,22.0,1.0,1.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,void
1161,5867,AtExit,1,node.AtExit,"void node.AtExit (Environment*,void,void*)",api\hooks.cc,"void AtExit(Environment* env, void (*cb)(void* arg), void* arg) {
  CHECK_NOT_NULL(env);
  env->AtExit(cb, arg);
}",24.0,27.0,1.0,1.0,4.0,1,1,4,3,0,0,1,1,0,0,,0,0,6,3,3,void
1162,5882,EmitBeforeExit,1,node.EmitBeforeExit,void node.EmitBeforeExit (Environment*),api\hooks.cc,"void EmitBeforeExit(Environment* env) {
  USE(EmitProcessBeforeExit(env));
}",29.0,31.0,1.0,1.0,3.0,0,0,1,1,0,0,1,1,0,0,,0,0,2,1,1,void
1163,5890,EmitProcessBeforeExit,1,node.EmitProcessBeforeExit,Maybe<bool> node.EmitProcessBeforeExit (Environment*),api\hooks.cc,"Maybe<bool> EmitProcessBeforeExit(Environment* env) {
  TRACE_EVENT0(TRACING_CATEGORY_NODE1(environment), ""BeforeExit"");
  if (!env->destroy_async_id_list()->empty())
    AsyncWrap::DestroyAsyncIdsCallback(env);

  Isolate* isolate = env->isolate();
  HandleScope handle_scope(isolate);
  Context::Scope context_scope(env->context());

  if (!env->can_call_into_js()) {
    return Nothing<bool>();
  }

  Local<Integer> exit_code = Integer::New(
      isolate, static_cast<int32_t>(env->exit_code(ExitCode::kNoFailure)));

  return ProcessEmit(env, ""beforeExit"", exit_code).IsEmpty() ?
      Nothing<bool>() : Just(true);
}",33.0,51.0,1.0,1.0,19.0,18,8,18,8,0,0,3,3,0,0,,0,0,2,1,1,Maybe<bool>
1164,5971,EmitExitInternal,1,node.EmitExitInternal,ExitCode node.EmitExitInternal (Environment*),api\hooks.cc,"static ExitCode EmitExitInternal(Environment* env) {
  return EmitProcessExitInternal(env).FromMaybe(ExitCode::kGenericUserError);
}",53.0,55.0,1.0,1.0,3.0,2,1,2,2,0,0,1,1,0,0,,0,0,2,1,1,ExitCode
1165,5985,EmitExit,1,node.EmitExit,int node.EmitExit (Environment*),api\hooks.cc,"int EmitExit(Environment* env) {
  return static_cast<int>(EmitExitInternal(env));
}",57.0,59.0,1.0,1.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,int
1166,5995,EmitProcessExitInternal,1,node.EmitProcessExitInternal,Maybe<ExitCode> node.EmitProcessExitInternal (Environment*),api\hooks.cc,"Maybe<ExitCode> EmitProcessExitInternal(Environment* env) {
  // process.emit('exit')
  Isolate* isolate = env->isolate();
  HandleScope handle_scope(isolate);
  Context::Scope context_scope(env->context());

  env->set_exiting(true);

  if (!env->can_call_into_js()) {
    return Nothing<ExitCode>();
  }

  Local<Integer> exit_code = Integer::New(
      isolate, static_cast<int32_t>(env->exit_code(ExitCode::kNoFailure)));

  if (ProcessEmit(env, ""exit"", exit_code).IsEmpty()) {
    return Nothing<ExitCode>();
  }
  // Reload exit code, it may be changed by `emit('exit')`
  return Just(env->exit_code(ExitCode::kNoFailure));
}",61.0,81.0,1.0,1.0,21.0,16,7,17,6,0,0,3,3,0,0,,0,0,2,1,1,Maybe<ExitCode>
1167,6070,EmitProcessExit,1,node.EmitProcessExit,Maybe<int> node.EmitProcessExit (Environment*),api\hooks.cc,"Maybe<int> EmitProcessExit(Environment* env) {
  Maybe<ExitCode> result = EmitProcessExitInternal(env);
  if (result.IsNothing()) {
    return Nothing<int>();
  }
  return Just(static_cast<int>(result.FromJust()));
}",83.0,89.0,1.0,1.0,7.0,6,5,6,4,0,0,2,2,0,0,,0,0,2,1,1,Maybe<int>
1168,6099,CleanupHook,1,node.CleanupHook,void node.CleanupHook (void*),api\hooks.cc,typedef void (*CleanupHook)(void* arg);,91.0,91.0,14.0,38.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
1169,6104,AsyncCleanupHook,1,node.AsyncCleanupHook,"void node.AsyncCleanupHook (void*,void,void*)",api\hooks.cc,"typedef void (*AsyncCleanupHook)(void* arg, void(*)(void*), void*);",92.0,92.0,14.0,66.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,void
1170,6126,operator (),1,node.DeleteACHHandle.operator (),void node.DeleteACHHandle.operator () (ACHHandle*),api\hooks.cc,void DeleteACHHandle::operator ()(ACHHandle* handle) const { delete handle; },116.0,116.0,1.0,77.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,void
1171,6133,AddEnvironmentCleanupHook,1,node.AddEnvironmentCleanupHook,"void node.AddEnvironmentCleanupHook (Isolate*,CleanupHook,void*)",node.hpp,"inline AsyncCleanupHookHandle AddEnvironmentCleanupHook(
    v8::Isolate* isolate,
    void (*fun)(void* arg, void (*cb)(void*), void* cbarg),
    void* arg) {
  return AsyncCleanupHookHandle(AddEnvironmentCleanupHookInternal(isolate, fun,
      arg));
}",1289.0,1295.0,1.0,1.0,7.0,3,3,7,5,3,0,1,1,0,0,,0,0,6,3,3,AsyncCleanupHookHandle
1172,6156,RemoveEnvironmentCleanupHook,1,node.RemoveEnvironmentCleanupHook,"void node.RemoveEnvironmentCleanupHook (Isolate*,CleanupHook,void*)",node.hpp,"inline void RemoveEnvironmentCleanupHook(AsyncCleanupHookHandle holder) {
  RemoveEnvironmentCleanupHookInternal(holder.get());
}",1300.0,1302.0,1.0,1.0,3.0,3,3,7,5,3,0,1,1,0,0,,0,0,2,1,1,void
1173,6179,FinishAsyncCleanupHook,1,node.FinishAsyncCleanupHook,void node.FinishAsyncCleanupHook (void*),api\hooks.cc,"static void FinishAsyncCleanupHook(void* arg) {
  AsyncCleanupHookInfo* info = static_cast<AsyncCleanupHookInfo*>(arg);
  std::shared_ptr<AsyncCleanupHookInfo> keep_alive = info->self;

  info->env->DecreaseWaitingRequestCounter();
  info->self.reset();
}",134.0,140.0,1.0,1.0,7.0,8,4,6,3,0,3,1,1,0,0,,0,3,2,1,1,void
1174,6208,RunAsyncCleanupHook,1,node.RunAsyncCleanupHook,void node.RunAsyncCleanupHook (void*),api\hooks.cc,"static void RunAsyncCleanupHook(void* arg) {
  AsyncCleanupHookInfo* info = static_cast<AsyncCleanupHookInfo*>(arg);
  info->env->IncreaseWaitingRequestCounter();
  info->started = true;
  info->fun(info->arg, FinishAsyncCleanupHook, info);
}",142.0,147.0,1.0,1.0,6.0,8,3,7,2,0,4,1,1,0,0,,0,4,2,1,1,void
1175,6239,AddEnvironmentCleanupHookInternal,1,node.AddEnvironmentCleanupHookInternal,"ACHHandle node.AddEnvironmentCleanupHookInternal (Isolate*,AsyncCleanupHook,void*)",api\hooks.cc,"ACHHandle* AddEnvironmentCleanupHookInternal(
    Isolate* isolate,
    AsyncCleanupHook fun,
    void* arg) {
  Environment* env = Environment::GetCurrent(isolate);
  CHECK_NOT_NULL(env);
  auto info = std::make_shared<AsyncCleanupHookInfo>();
  info->env = env;
  info->fun = fun;
  info->arg = arg;
  info->self = info;
  env->AddCleanupHook(RunAsyncCleanupHook, info.get());
  return new ACHHandle { info };
}",149.0,162.0,1.0,1.0,14.0,15,4,17,8,0,0,1,1,0,0,,0,0,6,3,3,ACHHandle
1176,6295,RemoveEnvironmentCleanupHookInternal,1,node.RemoveEnvironmentCleanupHookInternal,void node.RemoveEnvironmentCleanupHookInternal (ACHHandle*),api\hooks.cc,"void RemoveEnvironmentCleanupHookInternal(
    ACHHandle* handle) {
  if (handle->info->started) return;
  handle->info->self.reset();
  handle->info->env->RemoveCleanupHook(RunAsyncCleanupHook, handle->info.get());
}",164.0,169.0,1.0,1.0,6.0,10,2,4,1,0,4,2,2,1,0,,0,4,2,1,1,void
1177,6331,RequestInterrupt,1,node.RequestInterrupt,"void node.RequestInterrupt (Environment*,void,void*)",api\hooks.cc,"void RequestInterrupt(Environment* env, void (*fun)(void* arg), void* arg) {
  env->RequestInterrupt([fun, arg](Environment* env) {
    // Disallow JavaScript execution during interrupt.
    Isolate::DisallowJavascriptExecutionScope scope(
        env->isolate(),
        Isolate::DisallowJavascriptExecutionScope::CRASH_ON_FAILURE);
    fun(arg);
  });
}",171.0,179.0,1.0,1.0,9.0,1,1,1,1,0,0,1,1,0,0,,0,0,6,3,3,void
1178,6341,AsyncHooksGetExecutionAsyncId,1,node.AsyncHooksGetExecutionAsyncId,async_id node.AsyncHooksGetExecutionAsyncId (Isolate*),api\hooks.cc,"async_id AsyncHooksGetExecutionAsyncId(Isolate* isolate) {
  Environment* env = Environment::GetCurrent(isolate);
  if (env == nullptr) return -1;
  return env->execution_async_id();
}",181.0,185.0,1.0,1.0,5.0,5,5,5,3,0,0,2,2,0,0,,0,0,2,1,1,async_id
1179,6367,AsyncHooksGetTriggerAsyncId,1,node.AsyncHooksGetTriggerAsyncId,async_id node.AsyncHooksGetTriggerAsyncId (Isolate*),api\hooks.cc,"async_id AsyncHooksGetTriggerAsyncId(Isolate* isolate) {
  Environment* env = Environment::GetCurrent(isolate);
  if (env == nullptr) return -1;
  return env->trigger_async_id();
}",187.0,191.0,1.0,1.0,5.0,5,5,5,3,0,0,2,2,0,0,,0,0,2,1,1,async_id
1180,6393,EmitAsyncInit,1,node.EmitAsyncInit,"async_context node.EmitAsyncInit (Isolate*,Local<Object>,char*,async_id)",api\hooks.cc,"async_context EmitAsyncInit(Isolate* isolate,
                            Local<Object> resource,
                            Local<String> name,
                            async_id trigger_async_id) {
  DebugSealHandleScope handle_scope(isolate);
  Environment* env = Environment::GetCurrent(isolate);
  CHECK_NOT_NULL(env);

  // Initialize async context struct
  if (trigger_async_id == -1)
    trigger_async_id = env->get_default_trigger_async_id();

  async_context context = {
    env->new_async_id(),  // async_id_
    trigger_async_id  // trigger_async_id_
  };

  // Run init hooks
  AsyncWrap::EmitAsyncInit(env, resource, name, context.async_id,
                           context.trigger_async_id);

  return context;
}",205.0,227.0,1.0,1.0,23.0,6,4,12,8,0,0,1,1,0,0,,0,0,8,4,4,async_context
1181,6485,EmitAsyncDestroy,1,node.EmitAsyncDestroy,"void node.EmitAsyncDestroy (Isolate*,async_context)",api\hooks.cc,"void EmitAsyncDestroy(Environment* env, async_context asyncContext) {
  AsyncWrap::EmitDestroy(env, asyncContext.async_id);
}",233.0,235.0,1.0,1.0,3.0,1,1,3,3,0,0,1,1,0,0,,0,0,4,2,2,void
1182,6522,signo_string,1,node.signo_string,const char* node.signo_string (int),api\utils.cc,"const char* signo_string(int signo) {
#define SIGNO_CASE(e)                                                          \
  case e:                                                                      \
    return #e;
  switch (signo) {
#ifdef SIGHUP
    SIGNO_CASE(SIGHUP);
#endif

#ifdef SIGINT
    SIGNO_CASE(SIGINT);
#endif

#ifdef SIGQUIT
    SIGNO_CASE(SIGQUIT);
#endif

#ifdef SIGILL
    SIGNO_CASE(SIGILL);
#endif

#ifdef SIGTRAP
    SIGNO_CASE(SIGTRAP);
#endif

#ifdef SIGABRT
    SIGNO_CASE(SIGABRT);
#endif

#ifdef SIGIOT
#if SIGABRT != SIGIOT
    SIGNO_CASE(SIGIOT);
#endif
#endif

#ifdef SIGBUS
    SIGNO_CASE(SIGBUS);
#endif

#ifdef SIGFPE
    SIGNO_CASE(SIGFPE);
#endif

#ifdef SIGKILL
    SIGNO_CASE(SIGKILL);
#endif

#ifdef SIGUSR1
    SIGNO_CASE(SIGUSR1);
#endif

#ifdef SIGSEGV
    SIGNO_CASE(SIGSEGV);
#endif

#ifdef SIGUSR2
    SIGNO_CASE(SIGUSR2);
#endif

#ifdef SIGPIPE
    SIGNO_CASE(SIGPIPE);
#endif

#ifdef SIGALRM
    SIGNO_CASE(SIGALRM);
#endif

    SIGNO_CASE(SIGTERM);

...",7.0,167.0,1.0,4.0,161.0,0,0,2,2,0,0,2,2,0,0,,0,0,2,1,1,const char*
1183,6551,<lambda>1,1,node.AsyncWrap.EmitDestroy..<lambda>1,ANY node.AsyncWrap.EmitDestroy..<lambda>1 (void*),async_wrap.cc,"[](void* arg) {
          DestroyAsyncIdsCallback(static_cast<Environment*>(arg));
        }",570.0,572.0,9.0,9.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,ANY
1184,6562,<lambda>0,1,node.AsyncWrap.EmitDestroy.<lambda>0,ANY node.AsyncWrap.EmitDestroy.<lambda>0 (Environment*),async_wrap.cc,"[](Environment* env) {
      env->context()->GetMicrotaskQueue()->EnqueueMicrotask(
        env->isolate(),
        [](void* arg) {
          DestroyAsyncIdsCallback(static_cast<Environment*>(arg));
        }, env);
      }",567.0,573.0,27.0,7.0,7.0,4,1,3,1,0,0,1,1,0,0,,0,0,2,1,1,ANY
1185,6612,DestroyAsyncIdsCallback,1,node.AsyncWrap.DestroyAsyncIdsCallback,void node.AsyncWrap.DestroyAsyncIdsCallback (Environment*),async_wrap.cc,"void AsyncWrap::DestroyAsyncIdsCallback(Environment* env) {
  Local<Function> fn = env->async_hooks_destroy_function();

  TryCatchScope try_catch(env, TryCatchScope::CatchMode::kFatal);

  do {
    std::vector<double> destroy_async_id_list;
    destroy_async_id_list.swap(*env->destroy_async_id_list());
    if (!env->can_call_into_js()) return;
    for (auto async_id : destroy_async_id_list) {
      // Want each callback to be cleaned up after itself, instead of cleaning
      // them all up after the while() loop completes.
      HandleScope scope(env->isolate());
      Local<Value> async_id_value = Number::New(env->isolate(), async_id);
      MaybeLocal<Value> ret = fn->Call(
          env->context(), Undefined(env->isolate()), 1, &async_id_value);

      if (ret.IsEmpty())
        return;
    }
  } while (!env->destroy_async_id_list()->empty());
}",67.0,88.0,1.0,1.0,22.0,28,8,27,13,0,0,5,9,0,0,,0,0,2,1,1,void
1186,6717,Emit,1,node.Emit,"void node.Emit (Environment*,double,ANY,Local<Function>)",async_wrap.cc,"void Emit(Environment* env, double async_id, AsyncHooks::Fields type,
          Local<Function> fn) {
  AsyncHooks* async_hooks = env->async_hooks();

  if (async_hooks->fields()[type] == 0 || !env->can_call_into_js())
    return;

  HandleScope handle_scope(env->isolate());
  Local<Value> async_id_value = Number::New(env->isolate(), async_id);
  TryCatchScope try_catch(env, TryCatchScope::CatchMode::kFatal);
  USE(fn->Call(env->context(), Undefined(env->isolate()), 1, &async_id_value));
}",90.0,101.0,1.0,1.0,12.0,20,10,19,11,0,0,2,2,0,0,,0,0,8,4,4,void
1187,6795,EmitPromiseResolve,1,node.AsyncWrap.EmitPromiseResolve,"void node.AsyncWrap.EmitPromiseResolve (Environment*,double)",async_wrap.cc,"void AsyncWrap::EmitPromiseResolve(Environment* env, double async_id) {
  Emit(env, async_id, AsyncHooks::kPromiseResolve,
       env->async_hooks_promise_resolve_function());
}",104.0,107.0,1.0,1.0,4.0,2,2,4,3,0,0,1,1,0,0,,0,0,4,2,2,void
1188,6811,EmitTraceEventBefore,1,node.AsyncWrap.EmitTraceEventBefore,void node.AsyncWrap.EmitTraceEventBefore (),async_wrap.cc,"void AsyncWrap::EmitTraceEventBefore() {
  switch (provider_type()) {
#define V(PROVIDER)                                                           \
    case PROVIDER_ ## PROVIDER:                                               \
      TRACE_EVENT_NESTABLE_ASYNC_BEGIN0(                                      \
        TRACING_CATEGORY_NODE1(async_hooks),                                  \
        #PROVIDER ""_CALLBACK"", static_cast<int64_t>(get_async_id()));         \
      break;
    NODE_ASYNC_PROVIDER_TYPES(V)
#undef V
    default:
      UNREACHABLE();
  }
}",110.0,123.0,1.0,1.0,14.0,0,0,0,0,0,0,2,2,0,0,,0,0,0,0,0,void
1189,6822,EmitBefore,1,node.AsyncWrap.EmitBefore,"void node.AsyncWrap.EmitBefore (Environment*,double)",async_wrap.cc,"void AsyncWrap::EmitBefore(Environment* env, double async_id) {
  Emit(env, async_id, AsyncHooks::kBefore,
       env->async_hooks_before_function());
}",126.0,129.0,1.0,1.0,4.0,2,2,4,3,0,0,1,1,0,0,,0,0,4,2,2,void
1190,6838,EmitTraceEventAfter,1,node.AsyncWrap.EmitTraceEventAfter,"void node.AsyncWrap.EmitTraceEventAfter (ProviderType,double)",async_wrap.cc,"void AsyncWrap::EmitTraceEventAfter(ProviderType type, double async_id) {
  switch (type) {
#define V(PROVIDER)                                                           \
    case PROVIDER_ ## PROVIDER:                                               \
      TRACE_EVENT_NESTABLE_ASYNC_END0(                                        \
        TRACING_CATEGORY_NODE1(async_hooks),                                  \
        #PROVIDER ""_CALLBACK"", static_cast<int64_t>(async_id));               \
      break;
    NODE_ASYNC_PROVIDER_TYPES(V)
#undef V
    default:
      UNREACHABLE();
  }
}",132.0,145.0,1.0,1.0,14.0,0,0,1,1,0,0,2,2,0,0,,0,0,4,2,2,void
1191,6851,EmitAfter,1,node.AsyncWrap.EmitAfter,"void node.AsyncWrap.EmitAfter (Environment*,double)",async_wrap.cc,"void AsyncWrap::EmitAfter(Environment* env, double async_id) {
  // If the user's callback failed then the after() hooks will be called at the
  // end of _fatalException().
  Emit(env, async_id, AsyncHooks::kAfter,
       env->async_hooks_after_function());
}",148.0,153.0,1.0,1.0,6.0,2,2,4,3,0,0,1,1,0,0,,0,0,4,2,2,void
1192,6867,SetupHooks,1,node.SetupHooks,void node.SetupHooks (FunctionCallbackInfo<Value>),async_wrap.cc,"static void SetupHooks(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  CHECK(args[0]->IsObject());

  // All of init, before, after, destroy, and promise_resolve are supplied by
  // async_hooks internally, so this should only ever be called once. At which
  // time all the functions should be set. Detect this by checking if
  // init !IsEmpty().
  CHECK(env->async_hooks_init_function().IsEmpty());

  Local<Object> fn_obj = args[0].As<Object>();

#define SET_HOOK_FN(name)                                                      \
  do {                                                                         \
    Local<Value> v =                                                           \
        fn_obj->Get(env->context(),                                            \
                    FIXED_ONE_BYTE_STRING(env->isolate(), #name))              \
            .ToLocalChecked();                                                 \
    CHECK(...",155.0,184.0,1.0,2.0,30.0,61,6,54,8,0,0,1,1,0,0,,0,0,2,1,1,void
1193,7112,SetPromiseHooks,1,node.SetPromiseHooks,void node.SetPromiseHooks (FunctionCallbackInfo<Value>),async_wrap.cc,"static void SetPromiseHooks(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  env->ResetPromiseHooks(
      args[0]->IsFunction() ? args[0].As<Function>() : Local<Function>(),
      args[1]->IsFunction() ? args[1].As<Function>() : Local<Function>(),
      args[2]->IsFunction() ? args[2].As<Function>() : Local<Function>(),
      args[3]->IsFunction() ? args[3].As<Function>() : Local<Function>());
}",186.0,194.0,1.0,1.0,9.0,23,5,12,3,0,0,1,1,0,0,,0,0,2,1,1,void
1194,7190,DestroyParamCleanupHook,1,node.DestroyParamCleanupHook,void node.DestroyParamCleanupHook (void*),async_wrap.cc,"static void DestroyParamCleanupHook(void* ptr) {
  delete static_cast<DestroyParam*>(ptr);
}",204.0,206.0,1.0,1.0,3.0,2,2,1,1,0,0,1,1,0,0,,0,0,2,1,1,void
1195,7199,WeakCallback,1,node.AsyncWrap.WeakCallback,void node.AsyncWrap.WeakCallback (WeakCallbackInfo<DestroyParam>),async_wrap.cc,"void AsyncWrap::WeakCallback(const WeakCallbackInfo<DestroyParam>& info) {
  HandleScope scope(info.GetIsolate());

  std::unique_ptr<DestroyParam> p{info.GetParameter()};
  Local<Object> prop_bag = PersistentToLocal::Default(info.GetIsolate(),
                                                      p->propBag);
  Local<Value> val;

  p->env->RemoveCleanupHook(DestroyParamCleanupHook, p.get());

  if (!prop_bag.IsEmpty() &&
      !prop_bag->Get(p->env->context(), p->env->destroyed_string())
        .ToLocal(&val)) {
    return;
  }

  if (val.IsEmpty() || val->IsFalse()) {
    AsyncWrap::EmitDestroy(p->env, p->asyncId);
  }
  // unique_ptr goes out of scope here and pointer is deleted.
}",208.0,228.0,1.0,1.0,21.0,34,10,26,12,0,0,3,3,0,0,,0,0,2,1,1,void
1196,7307,RegisterDestroyHook,1,node.RegisterDestroyHook,void node.RegisterDestroyHook (FunctionCallbackInfo<Value>),async_wrap.cc,"static void RegisterDestroyHook(const FunctionCallbackInfo<Value>& args) {
  CHECK(args[0]->IsObject());
  CHECK(args[1]->IsNumber());
  CHECK(args.Length() == 2 || args[2]->IsObject());

  Isolate* isolate = args.GetIsolate();
  DestroyParam* p = new DestroyParam();
  p->asyncId = args[1].As<Number>()->Value();
  p->env = Environment::GetCurrent(args);
  p->target.Reset(isolate, args[0].As<Object>());
  if (args.Length() > 2) {
    p->propBag.Reset(isolate, args[2].As<Object>());
  }
  p->target.SetWeak(p, AsyncWrap::WeakCallback, WeakCallbackType::kParameter);
  p->env->AddCleanupHook(DestroyParamCleanupHook, p);
}",231.0,246.0,1.0,1.0,16.0,37,8,26,7,0,6,2,2,0,0,,0,6,2,1,1,void
1197,7429,GetAsyncId,1,node.AsyncWrap.GetAsyncId,void node.AsyncWrap.GetAsyncId (FunctionCallbackInfo<Value>),async_wrap.cc,"void AsyncWrap::GetAsyncId(const FunctionCallbackInfo<Value>& args) {
  AsyncWrap* wrap;
  args.GetReturnValue().Set(kInvalidAsyncId);
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
  args.GetReturnValue().Set(wrap->get_async_id());
}",248.0,253.0,1.0,1.0,6.0,7,3,6,3,0,0,1,1,0,0,,0,0,2,1,1,void
1198,7461,PushAsyncContext,1,node.AsyncWrap.PushAsyncContext,void node.AsyncWrap.PushAsyncContext (FunctionCallbackInfo<Value>),async_wrap.cc,"void AsyncWrap::PushAsyncContext(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  // No need for CHECK(IsNumber()) on args because if FromJust() doesn't fail
  // then the checks in push_async_ids() and pop_async_id() will.
  double async_id = args[0]->NumberValue(env->context()).FromJust();
  double trigger_async_id = args[1]->NumberValue(env->context()).FromJust();
  env->async_hooks()->push_async_context(async_id, trigger_async_id, {});
}",256.0,263.0,1.0,1.0,8.0,15,5,12,5,0,0,1,1,0,0,,0,0,2,1,1,void
1199,7516,PopAsyncContext,1,node.AsyncWrap.PopAsyncContext,void node.AsyncWrap.PopAsyncContext (FunctionCallbackInfo<Value>),async_wrap.cc,"void AsyncWrap::PopAsyncContext(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  double async_id = args[0]->NumberValue(env->context()).FromJust();
  args.GetReturnValue().Set(env->async_hooks()->pop_async_context(async_id));
}",266.0,270.0,1.0,1.0,5.0,11,4,9,4,0,0,1,1,0,0,,0,0,2,1,1,void
1200,7560,ExecutionAsyncResource,1,node.AsyncWrap.ExecutionAsyncResource,void node.AsyncWrap.ExecutionAsyncResource (FunctionCallbackInfo<Value>),async_wrap.cc,"void AsyncWrap::ExecutionAsyncResource(
    const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  uint32_t index;
  if (!args[0]->Uint32Value(env->context()).To(&index)) return;
  args.GetReturnValue().Set(
      env->async_hooks()->native_execution_async_resource(index));
}",273.0,280.0,1.0,1.0,8.0,12,6,9,4,0,0,2,2,0,0,,0,0,2,1,1,void
1201,7608,ClearAsyncIdStack,1,node.AsyncWrap.ClearAsyncIdStack,void node.AsyncWrap.ClearAsyncIdStack (FunctionCallbackInfo<Value>),async_wrap.cc,"void AsyncWrap::ClearAsyncIdStack(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  env->async_hooks()->clear_async_id_stack();
}",283.0,286.0,1.0,1.0,4.0,4,3,4,3,0,0,1,1,0,0,,0,0,2,1,1,void
1202,7628,AsyncReset,1,node.AsyncWrap.AsyncReset,void node.AsyncWrap.AsyncReset (FunctionCallbackInfo<Value>),async_wrap.cc,"void AsyncWrap::AsyncReset(Local<Object> resource, double execution_async_id,
                           bool silent) {
  CHECK_NE(provider_type(), PROVIDER_NONE);

  if (async_id_ != kInvalidAsyncId) {
    // This instance was in use before, we have already emitted an init with
    // its previous async_id and need to emit a matching destroy for that
    // before generating a new async_id.
    EmitDestroy();
  }

  // Now we can assign a new async_id_ to this instance.
  async_id_ = execution_async_id == kInvalidAsyncId ? env()->new_async_id()
                                                     : execution_async_id;
  trigger_async_id_ = env()->get_default_trigger_async_id();

  {
    HandleScope handle_scope(env()->isolate());
    Local<Object> obj = object();
    CHECK(!obj.IsEmpty());
    if (resource != obj) {
      USE(obj->Set(env()->context(), env()->resource_symbol(), resource));
    }
  }

  switch (provider_type()) {
#define V(PROVIDER)                                  ...",582.0,634.0,1.0,1.0,53.0,17,8,14,7,0,0,1,1,0,0,,0,0,6,3,3,void
1203,7686,GetProviderType,1,node.AsyncWrap.GetProviderType,void node.AsyncWrap.GetProviderType (FunctionCallbackInfo<Value>),async_wrap.cc,"void AsyncWrap::GetProviderType(const FunctionCallbackInfo<Value>& args) {
  AsyncWrap* wrap;
  args.GetReturnValue().Set(AsyncWrap::PROVIDER_NONE);
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
  args.GetReturnValue().Set(wrap->provider_type());
}",302.0,307.0,1.0,1.0,6.0,8,3,6,3,0,0,1,1,0,0,,0,0,2,1,1,void
1204,7720,EmitDestroy,1,node.AsyncWrap.EmitDestroy,void node.AsyncWrap.EmitDestroy (bool),async_wrap.cc,"void AsyncWrap::EmitDestroy(Environment* env, double async_id) {
  if (env->async_hooks()->fields()[AsyncHooks::kDestroy] == 0 ||
      !env->can_call_into_js()) {
    return;
  }

  if (env->destroy_async_id_list()->empty()) {
    env->SetImmediate(&DestroyAsyncIdsCallback, CallbackFlags::kUnrefed);
  }

  // If the list gets very large empty it faster using a Microtask.
  // Microtasks can't be added in GC context therefore we use an
  // interrupt to get this Microtask scheduled as fast as possible.
  if (env->destroy_async_id_list()->size() == 16384) {
    env->RequestInterrupt([](Environment* env) {
      env->context()->GetMicrotaskQueue()->EnqueueMicrotask(
        env->isolate(),
        [](void* arg) {
          DestroyAsyncIdsCallback(static_cast<Environment*>(arg));
        }, env);
      });
  }

  env->destroy_async_id_list()->push_back(async_id);
}",553.0,577.0,1.0,1.0,25.0,7,5,5,4,1,0,2,2,0,0,,0,0,4,2,2,void
1205,7751,QueueDestroyAsyncId,1,node.AsyncWrap.QueueDestroyAsyncId,void node.AsyncWrap.QueueDestroyAsyncId (FunctionCallbackInfo<Value>),async_wrap.cc,"void AsyncWrap::QueueDestroyAsyncId(const FunctionCallbackInfo<Value>& args) {
  CHECK(args[0]->IsNumber());
  AsyncWrap::EmitDestroy(
      Environment::GetCurrent(args),
      args[0].As<Number>()->Value());
}",321.0,326.0,1.0,1.0,6.0,7,3,5,3,0,0,1,1,0,0,,0,0,2,1,1,void
1206,7781,SetCallbackTrampoline,1,node.AsyncWrap.SetCallbackTrampoline,void node.AsyncWrap.SetCallbackTrampoline (FunctionCallbackInfo<Value>),async_wrap.cc,"void AsyncWrap::SetCallbackTrampoline(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  if (args[0]->IsFunction()) {
    env->set_async_hooks_callback_trampoline(args[0].As<Function>());
  } else {
    env->set_async_hooks_callback_trampoline(Local<Function>());
  }
}",328.0,336.0,1.0,1.0,9.0,7,4,6,3,0,0,2,2,0,0,,0,0,2,1,1,void
1207,7819,GetConstructorTemplate,1,node.AsyncWrap.GetConstructorTemplate,Local<FunctionTemplate> node.AsyncWrap.GetConstructorTemplate (IsolateData*),async_wrap.cc,"Local<FunctionTemplate> AsyncWrap::GetConstructorTemplate(
    IsolateData* isolate_data) {
  Local<FunctionTemplate> tmpl = isolate_data->async_wrap_ctor_template();
  if (tmpl.IsEmpty()) {
    Isolate* isolate = isolate_data->isolate();
    tmpl = NewFunctionTemplate(isolate, nullptr);
    tmpl->SetClassName(
        FIXED_ONE_BYTE_STRING(isolate_data->isolate(), ""AsyncWrap""));
    SetProtoMethod(isolate, tmpl, ""getAsyncId"", AsyncWrap::GetAsyncId);
    SetProtoMethod(isolate, tmpl, ""asyncReset"", AsyncWrap::AsyncReset);
    SetProtoMethod(
        isolate, tmpl, ""getProviderType"", AsyncWrap::GetProviderType);
    isolate_data->set_async_wrap_ctor_template(tmpl);
  }
  return tmpl;
}",338.0,353.0,1.0,1.0,16.0,14,5,23,6,0,0,2,2,0,0,,0,0,2,1,1,Local<FunctionTemplate>
1208,7890,CreatePerIsolateProperties,1,node.AsyncWrap.CreatePerIsolateProperties,"void node.AsyncWrap.CreatePerIsolateProperties (IsolateData*,Local<FunctionTemplate>)",async_wrap.cc,"void AsyncWrap::CreatePerIsolateProperties(IsolateData* isolate_data,
                                           Local<FunctionTemplate> ctor) {
  Isolate* isolate = isolate_data->isolate();
  Local<ObjectTemplate> target = ctor->InstanceTemplate();

  SetMethod(isolate, target, ""setupHooks"", SetupHooks);
  SetMethod(isolate, target, ""setCallbackTrampoline"", SetCallbackTrampoline);
  SetMethod(isolate, target, ""pushAsyncContext"", PushAsyncContext);
  SetMethod(isolate, target, ""popAsyncContext"", PopAsyncContext);
  SetMethod(isolate, target, ""executionAsyncResource"", ExecutionAsyncResource);
  SetMethod(isolate, target, ""clearAsyncIdStack"", ClearAsyncIdStack);
  SetMethod(isolate, target, ""queueDestroyAsyncId"", QueueDestroyAsyncId);
  SetMethod(isolate, target, ""setPromiseHooks"", SetPromiseHooks);
  SetMethod(isolate, target, ""registerDestroyHook"", RegisterDestroyHook);
  AsyncWrap::GetConstructorTemplate(isolate_data);
}",355.0,370.0,1.0,1.0,16.0,7,5,35,16,0,0,1,1,0,0,,0,0,4,2,2,void
1209,7963,CreatePerContextProperties,1,node.AsyncWrap.CreatePerContextProperties,"void node.AsyncWrap.CreatePerContextProperties (Local<Object>,Local<Value>,Local<Context>,void*)",async_wrap.cc,"void AsyncWrap::CreatePerContextProperties(Local<Object> target,
                                           Local<Value> unused,
                                           Local<Context> context,
                                           void* priv) {
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();
  HandleScope scope(isolate);

  PropertyAttribute ReadOnlyDontDelete =
      static_cast<PropertyAttribute>(ReadOnly | DontDelete);

#define FORCE_SET_TARGET_FIELD(obj, str, field)                               \
  (obj)->DefineOwnProperty(context,                                           \
                           FIXED_ONE_BYTE_STRING(isolate, str),               \
                           field,                                             \
                           ReadOnlyDontDelete).FromJust()

  // Attach the uint32_t[] where each slot contains the count of the number of
  // callbacks waiting to be called on a particular event. I...",372.0,457.0,1.0,2.0,86.0,106,7,157,26,0,0,1,1,0,0,,0,0,8,4,4,void
1210,8501,RegisterExternalReferences,1,node.AsyncWrap.RegisterExternalReferences,void node.AsyncWrap.RegisterExternalReferences (ExternalReferenceRegistry*),async_wrap.cc,"void AsyncWrap::RegisterExternalReferences(
    ExternalReferenceRegistry* registry) {
  registry->Register(SetupHooks);
  registry->Register(SetCallbackTrampoline);
  registry->Register(PushAsyncContext);
  registry->Register(PopAsyncContext);
  registry->Register(ExecutionAsyncResource);
  registry->Register(ClearAsyncIdStack);
  registry->Register(QueueDestroyAsyncId);
  registry->Register(SetPromiseHooks);
  registry->Register(RegisterDestroyHook);
  registry->Register(AsyncWrap::GetAsyncId);
  registry->Register(AsyncWrap::AsyncReset);
  registry->Register(AsyncWrap::GetProviderType);
}",459.0,473.0,1.0,1.0,15.0,15,2,24,11,0,0,1,1,0,0,,0,0,2,1,1,void
1211,8572,AsyncWrap,1,node.AsyncWrap.AsyncWrap,"ANY node.AsyncWrap.AsyncWrap (Environment*,Local<Object>,ProviderType,double)",async_wrap.cc,"AsyncWrap::AsyncWrap(Environment* env, Local<Object> object)
  : BaseObject(env, object) {
}",504.0,506.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,ANY
1212,8620,IsDoneInitializing,1,node.AsyncWrap.IsDoneInitializing,bool node.AsyncWrap.IsDoneInitializing (),async_wrap.cc,"bool AsyncWrap::IsDoneInitializing() const {
  return init_hook_ran_;
}",529.0,531.0,1.0,1.0,3.0,0,0,1,1,0,0,1,1,0,0,,0,0,0,0,0,bool
1213,8626,~AsyncWrap,1,node.AsyncWrap.~AsyncWrap,ANY node.AsyncWrap.~AsyncWrap (),async_wrap.cc,"AsyncWrap::~AsyncWrap() {
  EmitTraceEventDestroy();
  EmitDestroy(true /* from gc */);
}",533.0,536.0,1.0,1.0,4.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
1214,8633,EmitTraceEventDestroy,1,node.AsyncWrap.EmitTraceEventDestroy,void node.AsyncWrap.EmitTraceEventDestroy (),async_wrap.cc,"void AsyncWrap::EmitTraceEventDestroy() {
  switch (provider_type()) {
  #define V(PROVIDER)                                                         \
    case PROVIDER_ ## PROVIDER:                                               \
      TRACE_EVENT_NESTABLE_ASYNC_END0(                                        \
        TRACING_CATEGORY_NODE1(async_hooks),                                  \
        #PROVIDER, static_cast<int64_t>(get_async_id()));                     \
      break;
    NODE_ASYNC_PROVIDER_TYPES(V)
  #undef V
    default:
      UNREACHABLE();
  }
}",538.0,551.0,1.0,1.0,14.0,0,0,0,0,0,0,2,2,0,0,,0,0,0,0,0,void
1215,8809,EmitAsyncInit,1,node.AsyncWrap.EmitAsyncInit,"void node.AsyncWrap.EmitAsyncInit (Environment*,Local<Object>,Local<String>,double,double)",async_wrap.cc,"void AsyncWrap::EmitAsyncInit(Environment* env,
                              Local<Object> object,
                              Local<String> type,
                              double async_id,
                              double trigger_async_id) {
  CHECK(!object.IsEmpty());
  CHECK(!type.IsEmpty());
  AsyncHooks* async_hooks = env->async_hooks();

  // Nothing to execute, so can continue normally.
  if (async_hooks->fields()[AsyncHooks::kInit] == 0) {
    return;
  }

  HandleScope scope(env->isolate());
  Local<Function> init_fn = env->async_hooks_init_function();

  Local<Value> argv[] = {
    Number::New(env->isolate(), async_id),
    type,
    Number::New(env->isolate(), trigger_async_id),
    object,
  };

  TryCatchScope try_catch(env, TryCatchScope::CatchMode::kFatal);
  USE(init_fn->Call(env->context(), object, arraysize(argv), argv));
}",636.0,662.0,1.0,1.0,27.0,25,9,28,14,1,0,2,2,0,0,,0,0,10,5,5,void
1216,8911,MakeCallback,1,node.AsyncWrap.MakeCallback,"MaybeLocal<Value> node.AsyncWrap.MakeCallback (Local<Function>,int,Local<Value>*)",async_wrap.cc,"MaybeLocal<Value> AsyncWrap::MakeCallback(const Local<Function> cb,
                                          int argc,
                                          Local<Value>* argv) {
  EmitTraceEventBefore();

  ProviderType provider = provider_type();
  async_context context { get_async_id(), get_trigger_async_id() };
  MaybeLocal<Value> ret = InternalMakeCallback(
      env(), object(), object(), cb, argc, argv, context);

  // This is a static call with cached values because the `this` object may
  // no longer be alive at this point.
  EmitTraceEventAfter(provider, context.async_id);

  return ret;
}",665.0,680.0,1.0,1.0,16.0,7,5,12,8,0,1,1,1,0,0,,0,1,6,3,3,MaybeLocal<Value>
1217,8950,MemoryInfoName,1,node.AsyncWrap.MemoryInfoName,const char* node.AsyncWrap.MemoryInfoName (),async_wrap.cc,"const char* AsyncWrap::MemoryInfoName() const {
  return provider_names[provider_type()];
}",682.0,684.0,1.0,1.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,const char*
1218,8958,diagnostic_name,1,node.AsyncWrap.diagnostic_name,string node.AsyncWrap.diagnostic_name (),async_wrap.cc,"std::string AsyncWrap::diagnostic_name() const {
  char buf[64];
  snprintf(buf,
           sizeof(buf),
           ""%s(%"" PRIu64 "":%.0f)"",
           MemoryInfoName(),
           env()->thread_id(),
           async_id_);
  return buf;
}",686.0,695.0,1.0,1.0,10.0,0,0,1,1,0,0,1,1,0,0,,0,0,0,0,0,string
1219,8966,GetOwner,1,node.AsyncWrap.GetOwner,Local<Object> node.AsyncWrap.GetOwner (),async_wrap.cc,"Local<Object> AsyncWrap::GetOwner(Environment* env, Local<Object> obj) {
  EscapableHandleScope handle_scope(env->isolate());
  CHECK(!obj.IsEmpty());

  TryCatchScope ignore_exceptions(env);
  while (true) {
    Local<Value> owner;
    if (!obj->Get(env->context(),
                  env->owner_symbol()).ToLocal(&owner) ||
        !owner->IsObject()) {
      return handle_scope.Escape(obj);
    }

    obj = owner.As<Object>();
  }
}",701.0,716.0,1.0,1.0,16.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,Local<Object>
1220,9096,<lambda>0,1,node.BaseObject.MakeWeak.<lambda>0,ANY node.BaseObject.MakeWeak.<lambda>0 (WeakCallbackInfo<BaseObject>),base_object.cc,"[](const WeakCallbackInfo<BaseObject>& data) {
        BaseObject* obj = data.GetParameter();
        // Clear the persistent handle so that ~BaseObject() doesn't attempt
        // to mess with internal fields, since the JS object may have
        // transitioned into an invalid state.
        // Refs: https://github.com/nodejs/node/issues/18897
        obj->persistent_handle_.Reset();
        CHECK_IMPLIES(obj->has_pointer_data(),
                      obj->pointer_data()->strong_ptr_count == 0);
        obj->OnGCCollect();
      }",55.0,65.0,7.0,7.0,11.0,9,4,6,2,0,0,1,1,0,0,,0,0,2,1,1,ANY
1221,9143,BaseObject,1,node.BaseObject.BaseObject,"ANY node.BaseObject.BaseObject (Realm*,Local<Object>)",base_object.cc,"BaseObject::BaseObject(Realm* realm, Local<Object> object)
    : persistent_handle_(realm->isolate(), object), realm_(realm) {
  CHECK_EQ(false, object.IsEmpty());
  CHECK_GE(object->InternalFieldCount(), BaseObject::kInternalFieldCount);
  SetInternalFields(object, static_cast<void*>(this));
  realm->AddCleanupHook(DeleteMe, static_cast<void*>(this));
  realm->modify_base_object_count(1);
}",16.0,23.0,1.0,1.0,8.0,7,3,7,4,0,0,1,1,0,0,,0,0,4,2,2,ANY
1222,9181,~BaseObject,1,node.BaseObject.~BaseObject,ANY node.BaseObject.~BaseObject (),base_object.cc,"BaseObject::~BaseObject() {
  realm()->modify_base_object_count(-1);
  realm()->RemoveCleanupHook(DeleteMe, static_cast<void*>(this));

  if (UNLIKELY(has_pointer_data())) {
    PointerData* metadata = pointer_data();
    CHECK_EQ(metadata->strong_ptr_count, 0);
    metadata->self = nullptr;
    if (metadata->weak_ptr_count == 0) delete metadata;
  }

  if (persistent_handle_.IsEmpty()) {
    // This most likely happened because the weak callback below cleared it.
    return;
  }

  {
    HandleScope handle_scope(realm()->isolate());
    object()->SetAlignedPointerInInternalField(BaseObject::kSlot, nullptr);
  }
}",25.0,45.0,1.0,1.0,21.0,15,7,8,4,0,0,4,5,0,0,,0,0,0,0,0,ANY
1223,9248,MakeWeak,1,node.BaseObject.MakeWeak,void node.BaseObject.MakeWeak (),base_object.cc,"void BaseObject::MakeWeak() {
  if (has_pointer_data()) {
    pointer_data()->wants_weak_jsobj = true;
    if (pointer_data()->strong_ptr_count > 0) return;
  }

  persistent_handle_.SetWeak(
      this,
      [](const WeakCallbackInfo<BaseObject>& data) {
        BaseObject* obj = data.GetParameter();
        // Clear the persistent handle so that ~BaseObject() doesn't attempt
        // to mess with internal fields, since the JS object may have
        // transitioned into an invalid state.
        // Refs: https://github.com/nodejs/node/issues/18897
        obj->persistent_handle_.Reset();
        CHECK_IMPLIES(obj->has_pointer_data(),
                      obj->pointer_data()->strong_ptr_count == 0);
        obj->OnGCCollect();
      },
      WeakCallbackType::kParameter);
}",47.0,67.0,1.0,1.0,21.0,6,4,2,2,0,0,3,4,0,0,,0,0,0,0,0,void
1224,9281,LazilyInitializedJSTemplateConstructor,1,node.BaseObject.LazilyInitializedJSTemplateConstructor,void node.BaseObject.LazilyInitializedJSTemplateConstructor (FunctionCallbackInfo<Value>),base_object.cc,"void BaseObject::LazilyInitializedJSTemplateConstructor(
    const FunctionCallbackInfo<Value>& args) {
  DCHECK(args.IsConstructCall());
  CHECK_GE(args.This()->InternalFieldCount(), BaseObject::kInternalFieldCount);
  SetInternalFields(args.This(), nullptr);
}",76.0,81.0,1.0,1.0,6.0,5,2,4,2,0,0,1,1,0,0,,0,0,2,1,1,void
1225,9308,MakeLazilyInitializedJSTemplate,1,node.BaseObject.MakeLazilyInitializedJSTemplate,Local<FunctionTemplate> node.BaseObject.MakeLazilyInitializedJSTemplate (Environment*),base_object.cc,"Local<FunctionTemplate> BaseObject::MakeLazilyInitializedJSTemplate(
    IsolateData* isolate_data) {
  Local<FunctionTemplate> t = NewFunctionTemplate(
      isolate_data->isolate(), LazilyInitializedJSTemplateConstructor);
  t->InstanceTemplate()->SetInternalFieldCount(BaseObject::kInternalFieldCount);
  return t;
}",88.0,94.0,1.0,1.0,7.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,Local<FunctionTemplate>
1226,9348,pointer_data,1,node.BaseObject.pointer_data,PointerData node.BaseObject.pointer_data (),base_object.cc,"BaseObject::PointerData* BaseObject::pointer_data() {
  if (!has_pointer_data()) {
    PointerData* metadata = new PointerData();
    metadata->wants_weak_jsobj = persistent_handle_.IsWeak();
    metadata->self = this;
    pointer_data_ = metadata;
  }
  CHECK(has_pointer_data());
  return pointer_data_;
}",96.0,105.0,1.0,1.0,10.0,9,5,8,4,0,0,2,2,0,0,,0,0,0,0,0,PointerData
1227,9380,decrease_refcount,1,node.BaseObject.decrease_refcount,void node.BaseObject.decrease_refcount (),base_object.cc,"void BaseObject::decrease_refcount() {
  CHECK(has_pointer_data());
  PointerData* metadata = pointer_data();
  CHECK_GT(metadata->strong_ptr_count, 0);
  unsigned int new_refcount = --metadata->strong_ptr_count;
  if (new_refcount == 0) {
    if (metadata->is_detached) {
      OnGCCollect();
    } else if (metadata->wants_weak_jsobj && !persistent_handle_.IsEmpty()) {
      MakeWeak();
    }
  }
}",107.0,119.0,1.0,1.0,13.0,7,4,6,2,0,0,3,4,0,0,,0,0,0,0,0,void
1228,9426,increase_refcount,1,node.BaseObject.increase_refcount,void node.BaseObject.increase_refcount (),base_object.cc,"void BaseObject::increase_refcount() {
  unsigned int prev_refcount = pointer_data()->strong_ptr_count++;
  if (prev_refcount == 0 && !persistent_handle_.IsEmpty())
    persistent_handle_.ClearWeak();
}",121.0,125.0,1.0,1.0,5.0,8,7,4,2,0,0,2,2,0,0,,0,0,0,0,0,void
1229,9452,DeleteMe,1,node.BaseObject.DeleteMe,void node.BaseObject.DeleteMe (void*),base_object.cc,"void BaseObject::DeleteMe(void* data) {
  BaseObject* self = static_cast<BaseObject*>(data);
  if (self->has_pointer_data() && self->pointer_data()->strong_ptr_count > 0) {
    return self->Detach();
  }
  delete self;
}",127.0,133.0,1.0,1.0,7.0,9,6,6,2,0,0,2,2,0,0,,0,0,2,1,1,void
1230,9485,IsDoneInitializing,1,node.BaseObject.IsDoneInitializing,bool node.BaseObject.IsDoneInitializing (),base_object.cc,"bool BaseObject::IsDoneInitializing() const {
  return true;
}",135.0,137.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,bool
1231,9491,WrappedObject,1,node.BaseObject.WrappedObject,Local<Object> node.BaseObject.WrappedObject (),base_object.cc,"Local<Object> BaseObject::WrappedObject() const {
  return object();
}",139.0,141.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,Local<Object>
1232,9497,IsRootNode,1,node.BaseObject.IsRootNode,bool node.BaseObject.IsRootNode (),base_object.cc,"bool BaseObject::IsRootNode() const {
  return !persistent_handle_.IsWeak();
}",143.0,145.0,1.0,1.0,3.0,2,2,1,1,0,0,1,1,0,0,,0,0,0,0,0,bool
1233,9507,IsNotIndicativeOfMemoryLeakAtExit,1,node.BaseObject.IsNotIndicativeOfMemoryLeakAtExit,bool node.BaseObject.IsNotIndicativeOfMemoryLeakAtExit (),base_object.cc,"bool BaseObject::IsNotIndicativeOfMemoryLeakAtExit() const {
  return IsWeakOrDetached();
}",147.0,149.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,bool
1234,9576,<lambda>0,1,node.cares_wrap.ChannelWrap.CloseTimer.<lambda>0,ANY node.cares_wrap.ChannelWrap.CloseTimer.<lambda>0 (uv_timer_t*),cares_wrap.cc,[](uv_timer_t* handle) { delete handle; },763.0,763.0,37.0,77.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,ANY
1235,9585,<lambda>1,1,node.cares_wrap.anonymous_namespace_23.AfterGetAddrInfo.<lambda>1,ANY node.cares_wrap.anonymous_namespace_23.AfterGetAddrInfo.<lambda>1 (),cares_wrap.cc,[&]() { uv_freeaddrinfo(res); },1432.0,1432.0,31.0,61.0,1.0,0,0,1,1,0,0,1,1,0,0,,0,0,0,0,0,ANY
1236,9593,<lambda>2,1,node.cares_wrap.anonymous_namespace_24.AfterGetAddrInfo.<lambda>2,"Maybe<bool> node.cares_wrap.anonymous_namespace_24.AfterGetAddrInfo.<lambda>2 (bool,bool)",cares_wrap.cc,"[&] (bool want_ipv4, bool want_ipv6) -> Maybe<bool> {
      for (auto p = res; p != nullptr; p = p->ai_next) {
        CHECK_EQ(p->ai_socktype, SOCK_STREAM);

        const char* addr;
        if (want_ipv4 && p->ai_family == AF_INET) {
          addr = reinterpret_cast<char*>(
              &(reinterpret_cast<struct sockaddr_in*>(p->ai_addr)->sin_addr));
        } else if (want_ipv6 && p->ai_family == AF_INET6) {
          addr = reinterpret_cast<char*>(
              &(reinterpret_cast<struct sockaddr_in6*>(p->ai_addr)->sin6_addr));
        } else {
          continue;
        }

        char ip[INET6_ADDRSTRLEN];
        if (uv_inet_ntop(p->ai_family, addr, ip, sizeof(ip)))
          continue;

        Local<String> s = OneByteString(env->isolate(), ip);
        if (results->Set(env->context(), n, s).IsNothing())
          return Nothing<bool>();
        n++;
      }
      return Just(true);
    }",1451.0,1476.0,16.0,5.0,26.0,22,12,24,13,0,0,6,8,0,0,,0,0,4,2,2,Maybe<bool>
1237,9716,<lambda>3,1,node.cares_wrap.anonymous_namespace_32.GetServers.<lambda>3,ANY node.cares_wrap.anonymous_namespace_32.GetServers.<lambda>3 (),cares_wrap.cc,[&]() { ares_free_data(servers); },1658.0,1658.0,31.0,64.0,1.0,0,0,1,1,0,0,1,1,0,0,,0,0,0,0,0,ANY
1238,9769,cares_get_16bit,1,node.cares_wrap.anonymous_namespace_1.cares_get_16bit,uint16_t node.cares_wrap.anonymous_namespace_1.cares_get_16bit (unsigned char*),cares_wrap.cc,"inline uint16_t cares_get_16bit(const unsigned char* p) {
  return static_cast<uint32_t>(p[0] << 8U) | (static_cast<uint32_t>(p[1]));
}",81.0,83.0,1.0,1.0,3.0,6,4,2,1,0,0,1,1,0,0,,0,0,2,1,1,uint16_t
1239,9788,ares_poll_cb,1,node.cares_wrap.anonymous_namespace_2.ares_poll_cb,"void node.cares_wrap.anonymous_namespace_2.ares_poll_cb (uv_poll_t*,int,int)",cares_wrap.cc,"void ares_poll_cb(uv_poll_t* watcher, int status, int events) {
  NodeAresTask* task = ContainerOf(&NodeAresTask::poll_watcher, watcher);
  ChannelWrap* channel = task->channel;

  /* Reset the idle timer */
  uv_timer_again(channel->timer_handle());

  if (status < 0) {
    /* An error happened. Just pretend that the socket is both readable and */
    /* writable. */
    ares_process_fd(channel->cares_channel(), task->sock, task->sock);
    return;
  }

  /* Process DNS responses */
  ares_process_fd(channel->cares_channel(),
                  events & UV_READABLE ? task->sock : ARES_SOCKET_BAD,
                  events & UV_WRITABLE ? task->sock : ARES_SOCKET_BAD);
}",85.0,103.0,1.0,1.0,19.0,17,7,19,9,0,0,2,2,0,0,,0,0,6,3,3,void
1240,9853,ares_poll_close_cb,1,node.cares_wrap.anonymous_namespace_3.ares_poll_close_cb,void node.cares_wrap.anonymous_namespace_3.ares_poll_close_cb (uv_poll_t*),cares_wrap.cc,"void ares_poll_close_cb(uv_poll_t* watcher) {
  std::unique_ptr<NodeAresTask> free_me(
        ContainerOf(&NodeAresTask::poll_watcher, watcher));
}",106.0,109.0,1.0,1.0,4.0,5,4,4,3,0,0,1,1,0,0,,0,0,2,1,1,void
1241,9871,ares_sockstate_cb,1,node.cares_wrap.anonymous_namespace_4.ares_sockstate_cb,"void node.cares_wrap.anonymous_namespace_4.ares_sockstate_cb (void*,ares_socket_t,int,int)",cares_wrap.cc,"void ares_sockstate_cb(void* data, ares_socket_t sock, int read, int write) {
  ChannelWrap* channel = static_cast<ChannelWrap*>(data);
  NodeAresTask* task;

  NodeAresTask lookup_task;
  lookup_task.sock = sock;
  auto it = channel->task_list()->find(&lookup_task);

  task = (it == channel->task_list()->end()) ? nullptr : *it;

  if (read || write) {
    if (!task) {
      /* New socket */
      channel->StartTimer();

      task = NodeAresTask::Create(channel, sock);
      if (task == nullptr) {
        /* This should never happen unless we're out of memory or something */
        /* is seriously wrong. The socket won't be polled, but the query will */
        /* eventually time out. */
        return;
      }

      channel->task_list()->insert(task);
    }

    /* This should never fail. If it fails anyway, the query will eventually */
    /* time out. */
    uv_poll_start(&task->poll_watcher,
                  (read ? UV_READABLE : 0) | (write ? UV_WRITABLE : 0),
             ...",113.0,159.0,1.0,1.0,47.0,27,11,27,11,0,0,4,7,0,0,,0,0,8,4,4,void
1242,10008,HostentToNames,1,node.cares_wrap.anonymous_namespace_7.HostentToNames,"Local<Array> node.cares_wrap.anonymous_namespace_7.HostentToNames (Environment*,hostent*)",cares_wrap.cc,"Local<Array> HostentToNames(Environment* env, struct hostent* host) {
  EscapableHandleScope scope(env->isolate());

  std::vector<Local<Value>> names;

  for (uint32_t i = 0; host->h_aliases[i] != nullptr; ++i)
    names.emplace_back(OneByteString(env->isolate(), host->h_aliases[i]));

  Local<Array> ret = Array::New(env->isolate(), names.data(), names.size());

  return scope.Escape(ret);
}",161.0,172.0,1.0,1.0,12.0,17,8,17,10,0,0,2,2,0,0,,0,0,4,2,2,Local<Array>
1243,10086,HostentToNames,1,node.cares_wrap.anonymous_namespace_8.HostentToNames,"Local<Array> node.cares_wrap.anonymous_namespace_8.HostentToNames (Environment*,hostent*,Local<Array>)",cares_wrap.cc,"Local<Array> HostentToNames(Environment* env,
                            struct hostent* host,
                            Local<Array> names) {
  size_t offset = names->Length();

  for (uint32_t i = 0; host->h_aliases[i] != nullptr; ++i) {
    names->Set(
        env->context(),
        i + offset,
        OneByteString(env->isolate(), host->h_aliases[i])).Check();
  }

  return names;
}",174.0,187.0,1.0,1.0,14.0,13,6,13,5,0,0,2,2,0,0,,0,0,6,3,3,Local<Array>
1244,10142,AddrTTLToArray,1,node.cares_wrap.anonymous_namespace_9.AddrTTLToArray,"Local<Array> node.cares_wrap.anonymous_namespace_9.AddrTTLToArray<T> (Environment*,T*,size_t)",cares_wrap.cc,"Local<Array> AddrTTLToArray(
    Environment* env,
    const T* addrttls,
    size_t naddrttls) {
  MaybeStackBuffer<Local<Value>, 8> ttls(naddrttls);
  for (size_t i = 0; i < naddrttls; i++)
    ttls[i] = Integer::NewFromUnsigned(env->isolate(), addrttls[i].ttl);

  return Array::New(env->isolate(), ttls.out(), naddrttls);
}",190.0,199.0,1.0,1.0,10.0,5,4,8,5,0,0,2,2,0,0,,0,0,6,3,3,Local<Array>
1245,10194,ParseGeneralReply,1,node.cares_wrap.anonymous_namespace_10.ParseGeneralReply,"int node.cares_wrap.anonymous_namespace_10.ParseGeneralReply (Environment*,unsigned char*,int,int*,Local<Array>,void*,int*)",cares_wrap.cc,"int ParseGeneralReply(
    Environment* env,
    const unsigned char* buf,
    int len,
    int* type,
    Local<Array> ret,
    void* addrttls = nullptr,
    int* naddrttls = nullptr) {
  HandleScope handle_scope(env->isolate());
  hostent* host;

  int status;
  switch (*type) {
    case ns_t_a:
    case ns_t_cname:
    case ns_t_cname_or_a:
      status = ares_parse_a_reply(buf,
                                  len,
                                  &host,
                                  static_cast<ares_addrttl*>(addrttls),
                                  naddrttls);
      break;
    case ns_t_aaaa:
      status = ares_parse_aaaa_reply(buf,
                                     len,
                                     &host,
                                     static_cast<ares_addr6ttl*>(addrttls),
                                     naddrttls);
      break;
    case ns_t_ns:
      status = ares_parse_ns_reply(buf, len, &host);
      break;
    case ns_t_ptr:
      status...",201.0,282.0,1.0,1.0,82.0,38,11,58,18,0,0,10,6,0,0,,0,0,14,7,7,int
1246,10483,ParseMxReply,1,node.cares_wrap.anonymous_namespace_11.ParseMxReply,"int node.cares_wrap.anonymous_namespace_11.ParseMxReply (Environment*,unsigned char*,int,Local<Array>,bool)",cares_wrap.cc,"int ParseMxReply(
    Environment* env,
    const unsigned char* buf,
    int len,
    Local<Array> ret,
    bool need_type = false) {
  HandleScope handle_scope(env->isolate());

  struct ares_mx_reply* mx_start;
  int status = ares_parse_mx_reply(buf, len, &mx_start);
  if (status != ARES_SUCCESS)
    return status;

  uint32_t offset = ret->Length();
  ares_mx_reply* current = mx_start;
  for (uint32_t i = 0; current != nullptr; ++i, current = current->next) {
    Local<Object> mx_record = Object::New(env->isolate());
    mx_record->Set(env->context(),
                   env->exchange_string(),
                   OneByteString(env->isolate(), current->host)).Check();
    mx_record->Set(env->context(),
                   env->priority_string(),
                   Integer::New(env->isolate(), current->priority)).Check();
    if (need_type)
      mx_record->Set(env->context(),
                     env->type_string(),
                     env->dns_mx_string()).Check();

    ret->Set(...",284.0,317.0,1.0,1.0,34.0,36,8,42,15,0,0,4,5,0,0,,0,0,10,5,5,int
1247,10647,ParseCaaReply,1,node.cares_wrap.anonymous_namespace_12.ParseCaaReply,"int node.cares_wrap.anonymous_namespace_12.ParseCaaReply (Environment*,unsigned char*,int,Local<Array>,bool)",cares_wrap.cc,"int ParseCaaReply(
    Environment* env,
    const unsigned char* buf,
    int len,
    Local<Array> ret,
    bool need_type = false) {
  HandleScope handle_scope(env->isolate());

  struct ares_caa_reply* caa_start;
  int status = ares_parse_caa_reply(buf, len, &caa_start);
  if (status != ARES_SUCCESS)
    return status;

  uint32_t offset = ret->Length();
  ares_caa_reply* current = caa_start;
  for (uint32_t i = 0; current != nullptr; ++i, current = current->next) {
    Local<Object> caa_record = Object::New(env->isolate());

    caa_record->Set(env->context(),
                    env->dns_critical_string(),
                    Integer::New(env->isolate(), current->critical)).Check();
    caa_record->Set(env->context(),
                    OneByteString(env->isolate(), current->property),
                    OneByteString(env->isolate(), current->value)).Check();
    if (need_type)
      caa_record->Set(env->context(),
                      env->type_string(),
                  ...",319.0,353.0,1.0,1.0,35.0,37,8,43,15,0,0,4,5,0,0,,0,0,10,5,5,int
1248,10815,ParseTxtReply,1,node.cares_wrap.anonymous_namespace_13.ParseTxtReply,"int node.cares_wrap.anonymous_namespace_13.ParseTxtReply (Environment*,unsigned char*,int,Local<Array>,bool)",cares_wrap.cc,"int ParseTxtReply(
    Environment* env,
    const unsigned char* buf,
    int len,
    Local<Array> ret,
    bool need_type = false) {
  HandleScope handle_scope(env->isolate());

  struct ares_txt_ext* txt_out;

  int status = ares_parse_txt_reply_ext(buf, len, &txt_out);
  if (status != ARES_SUCCESS)
    return status;

  Local<Array> txt_chunk;

  struct ares_txt_ext* current = txt_out;
  uint32_t i = 0, j;
  uint32_t offset = ret->Length();
  for (j = 0; current != nullptr; current = current->next) {
    Local<String> txt =
        OneByteString(env->isolate(), current->txt, current->length);

    // New record found - write out the current chunk
    if (current->record_start) {
      if (!txt_chunk.IsEmpty()) {
        if (need_type) {
          Local<Object> elem = Object::New(env->isolate());
          elem->Set(env->context(), env->entries_string(), txt_chunk).Check();
          elem->Set(env->context(),
                    env->type_string(),
                    env->dns_t...",355.0,416.0,1.0,1.0,62.0,68,10,75,19,0,0,8,15,0,0,,0,0,10,5,5,int
1249,11118,ParseSrvReply,1,node.cares_wrap.anonymous_namespace_14.ParseSrvReply,"int node.cares_wrap.anonymous_namespace_14.ParseSrvReply (Environment*,unsigned char*,int,Local<Array>,bool)",cares_wrap.cc,"int ParseSrvReply(
    Environment* env,
    const unsigned char* buf,
    int len,
    Local<Array> ret,
    bool need_type = false) {
  HandleScope handle_scope(env->isolate());

  struct ares_srv_reply* srv_start;
  int status = ares_parse_srv_reply(buf, len, &srv_start);
  if (status != ARES_SUCCESS)
    return status;

  ares_srv_reply* current = srv_start;
  int offset = ret->Length();
  for (uint32_t i = 0; current != nullptr; ++i, current = current->next) {
    Local<Object> srv_record = Object::New(env->isolate());
    srv_record->Set(env->context(),
                    env->name_string(),
                    OneByteString(env->isolate(), current->host)).Check();
    srv_record->Set(env->context(),
                    env->port_string(),
                    Integer::New(env->isolate(), current->port)).Check();
    srv_record->Set(env->context(),
                    env->priority_string(),
                    Integer::New(env->isolate(), current->priority)).Check();
    srv_...",419.0,458.0,1.0,1.0,40.0,50,8,54,15,0,0,4,5,0,0,,0,0,10,5,5,int
1250,11334,ParseNaptrReply,1,node.cares_wrap.anonymous_namespace_15.ParseNaptrReply,"int node.cares_wrap.anonymous_namespace_15.ParseNaptrReply (Environment*,unsigned char*,int,Local<Array>,bool)",cares_wrap.cc,"int ParseNaptrReply(
    Environment* env,
    const unsigned char* buf,
    int len,
    Local<Array> ret,
    bool need_type = false) {
  HandleScope handle_scope(env->isolate());

  ares_naptr_reply* naptr_start;
  int status = ares_parse_naptr_reply(buf, len, &naptr_start);

  if (status != ARES_SUCCESS)
    return status;

  ares_naptr_reply* current = naptr_start;
  int offset = ret->Length();
  for (uint32_t i = 0; current != nullptr; ++i, current = current->next) {
    Local<Object> naptr_record = Object::New(env->isolate());
    naptr_record->Set(env->context(),
                      env->flags_string(),
                      OneByteString(env->isolate(), current->flags)).Check();
    naptr_record->Set(env->context(),
                      env->service_string(),
                      OneByteString(env->isolate(),
                                    current->service)).Check();
    naptr_record->Set(env->context(),
                      env->regexp_string(),
                 ...",461.0,511.0,1.0,1.0,51.0,61,8,63,15,0,0,4,5,0,0,,0,0,10,5,5,int
1251,11593,ParseSoaReply,1,node.cares_wrap.anonymous_namespace_16.ParseSoaReply,"int node.cares_wrap.anonymous_namespace_16.ParseSoaReply (Environment*,unsigned char*,int,Local<Object>*)",cares_wrap.cc,"int ParseSoaReply(
    Environment* env,
    unsigned char* buf,
    int len,
    Local<Object>* ret) {
  EscapableHandleScope handle_scope(env->isolate());

  // Manage memory using standardard smart pointer std::unique_tr
  struct AresDeleter {
    void operator()(char* ptr) const noexcept { ares_free_string(ptr); }
  };
  using ares_unique_ptr = std::unique_ptr<char[], AresDeleter>;

  // Can't use ares_parse_soa_reply() here which can only parse single record
  const unsigned int ancount = cares_get_16bit(buf + 6);
  unsigned char* ptr = buf + NS_HFIXEDSZ;
  char* name_temp = nullptr;
  long temp_len;  // NOLINT(runtime/int)
  int status = ares_expand_name(ptr, buf, len, &name_temp, &temp_len);
  if (status != ARES_SUCCESS) {
    // returns EBADRESP in case of invalid input
    return status == ARES_EBADNAME ? ARES_EBADRESP : status;
  }

  const ares_unique_ptr name(name_temp);

  if (ptr + temp_len + NS_QFIXEDSZ > buf + len) {
    return ARES_EBADRESP;
  }
  ptr += temp_len + ...",514.0,635.0,1.0,1.0,122.0,127,13,162,40,0,0,11,19,0,0,,0,0,8,4,4,int
1252,12088,ChannelWrap,1,node.cares_wrap.ChannelWrap.ChannelWrap,"ANY node.cares_wrap.ChannelWrap.ChannelWrap (Environment*,Local<Object>,int,int)",cares_wrap.cc,"ChannelWrap::ChannelWrap(
      Environment* env,
      Local<Object> object,
      int timeout,
      int tries)
    : AsyncWrap(env, object, PROVIDER_DNSCHANNEL),
      timeout_(timeout),
      tries_(tries) {
  MakeWeak();

  Setup();
}",638.0,649.0,1.0,1.0,12.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,ANY
1253,12098,MemoryInfo,1,node.cares_wrap.ChannelWrap.MemoryInfo,void node.cares_wrap.ChannelWrap.MemoryInfo (MemoryTracker*),cares_wrap.cc,"void ChannelWrap::MemoryInfo(MemoryTracker* tracker) const {
  if (timer_handle_ != nullptr)
    tracker->TrackField(""timer_handle"", *timer_handle_);
  tracker->TrackField(""task_list"", task_list_, ""NodeAresTask::List"");
}",651.0,655.0,1.0,1.0,5.0,4,3,5,3,0,0,2,2,0,0,,0,0,2,1,1,void
1254,12122,New,1,node.cares_wrap.ChannelWrap.New,void node.cares_wrap.ChannelWrap.New (FunctionCallbackInfo<Value>),cares_wrap.cc,"void ChannelWrap::New(const FunctionCallbackInfo<Value>& args) {
  CHECK(args.IsConstructCall());
  CHECK_EQ(args.Length(), 2);
  CHECK(args[0]->IsInt32());
  CHECK(args[1]->IsInt32());
  const int timeout = args[0].As<Int32>()->Value();
  const int tries = args[1].As<Int32>()->Value();
  Environment* env = Environment::GetCurrent(args);
  new ChannelWrap(env, args.This(), timeout, tries);
}",657.0,666.0,1.0,1.0,10.0,18,5,16,6,0,0,1,1,0,0,,0,0,2,1,1,void
1255,12193,GetAddrInfoReqWrap,1,node.cares_wrap.GetAddrInfoReqWrap.GetAddrInfoReqWrap,"ANY node.cares_wrap.GetAddrInfoReqWrap.GetAddrInfoReqWrap (Environment*,Local<Object>,bool)",cares_wrap.cc,"GetAddrInfoReqWrap::GetAddrInfoReqWrap(
    Environment* env,
    Local<Object> req_wrap_obj,
    bool verbatim)
    : ReqWrap(env, req_wrap_obj, AsyncWrap::PROVIDER_GETADDRINFOREQWRAP),
      verbatim_(verbatim) {}",668.0,673.0,1.0,28.0,6.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,ANY
1256,12200,GetNameInfoReqWrap,1,node.cares_wrap.GetNameInfoReqWrap.GetNameInfoReqWrap,"ANY node.cares_wrap.GetNameInfoReqWrap.GetNameInfoReqWrap (Environment*,Local<Object>)",cares_wrap.cc,"GetNameInfoReqWrap::GetNameInfoReqWrap(
    Environment* env,
    Local<Object> req_wrap_obj)
    : ReqWrap(env, req_wrap_obj, AsyncWrap::PROVIDER_GETNAMEINFOREQWRAP) {}",675.0,678.0,1.0,75.0,4.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,ANY
1257,12206,AresTimeout,1,node.cares_wrap.ChannelWrap.AresTimeout,void node.cares_wrap.ChannelWrap.AresTimeout (uv_timer_t*),cares_wrap.cc,"void ChannelWrap::AresTimeout(uv_timer_t* handle) {
  ChannelWrap* channel = static_cast<ChannelWrap*>(handle->data);
  CHECK_EQ(channel->timer_handle(), handle);
  CHECK_EQ(false, channel->task_list()->empty());
  ares_process_fd(channel->cares_channel(), ARES_SOCKET_BAD, ARES_SOCKET_BAD);
}",682.0,687.0,1.0,1.0,6.0,7,3,8,3,0,0,1,1,0,0,,0,0,2,1,1,void
1258,12241,MemoryInfo,1,node.cares_wrap.NodeAresTask.MemoryInfo,void node.cares_wrap.NodeAresTask.MemoryInfo (MemoryTracker*),cares_wrap.cc,"void NodeAresTask::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackField(""channel"", channel);
}",690.0,692.0,1.0,1.0,3.0,1,1,2,2,0,0,1,1,0,0,,0,0,2,1,1,void
1259,12252,Create,1,node.cares_wrap.NodeAresTask.Create,"NodeAresTask node.cares_wrap.NodeAresTask.Create (ChannelWrap*,ares_socket_t)",cares_wrap.cc,"NodeAresTask* NodeAresTask::Create(ChannelWrap* channel, ares_socket_t sock) {
  auto task = new NodeAresTask();

  task->channel = channel;
  task->sock = sock;

  if (uv_poll_init_socket(channel->env()->event_loop(),
                          &task->poll_watcher, sock) < 0) {
    /* This should never happen. */
    delete task;
    return nullptr;
  }

  return task;
}",695.0,709.0,1.0,1.0,15.0,12,6,11,4,0,0,2,2,0,0,,0,0,4,2,2,NodeAresTask
1260,12296,Setup,1,node.cares_wrap.ChannelWrap.Setup,void node.cares_wrap.ChannelWrap.Setup (),cares_wrap.cc,"void ChannelWrap::Setup() {
  struct ares_options options;
  memset(&options, 0, sizeof(options));
  options.flags = ARES_FLAG_NOCHECKRESP;
  options.sock_state_cb = ares_sockstate_cb;
  options.sock_state_cb_data = this;
  options.timeout = timeout_;
  options.tries = tries_;

  int r;
  if (!library_inited_) {
    Mutex::ScopedLock lock(ares_library_mutex);
    // Multiple calls to ares_library_init() increase a reference counter,
    // so this is a no-op except for the first call to it.
    r = ares_library_init(ARES_LIB_INIT_ALL);
    if (r != ARES_SUCCESS)
      return env()->ThrowError(ToErrorCodeString(r));
  }

  /* We do the call to ares_init_option for caller. */
  const int optmask =
      ARES_OPT_FLAGS | ARES_OPT_TIMEOUTMS |
      ARES_OPT_SOCK_STATE_CB | ARES_OPT_TRIES;
  r = ares_init_options(&channel_, &options, optmask);

  if (r != ARES_SUCCESS) {
    Mutex::ScopedLock lock(ares_library_mutex);
    ares_library_cleanup();
    return env()->ThrowError(ToErrorCodeSt...",711.0,743.0,1.0,1.0,33.0,26,8,32,16,0,0,4,5,0,0,,0,0,0,0,0,void
1261,12393,StartTimer,1,node.cares_wrap.ChannelWrap.StartTimer,void node.cares_wrap.ChannelWrap.StartTimer (),cares_wrap.cc,"void ChannelWrap::StartTimer() {
  if (timer_handle_ == nullptr) {
    timer_handle_ = new uv_timer_t();
    timer_handle_->data = static_cast<void*>(this);
    uv_timer_init(env()->event_loop(), timer_handle_);
  } else if (uv_is_active(reinterpret_cast<uv_handle_t*>(timer_handle_))) {
    return;
  }
  int timeout = timeout_;
  if (timeout == 0) timeout = 1;
  if (timeout < 0 || timeout > 1000) timeout = 1000;
  uv_timer_start(timer_handle_, AresTimeout, timeout, timeout);
}",745.0,757.0,1.0,1.0,13.0,14,8,16,5,0,0,4,4,0,0,,0,0,0,0,0,void
1262,12457,CloseTimer,1,node.cares_wrap.ChannelWrap.CloseTimer,void node.cares_wrap.ChannelWrap.CloseTimer (),cares_wrap.cc,"void ChannelWrap::CloseTimer() {
  if (timer_handle_ == nullptr)
    return;

  env()->CloseHandle(timer_handle_, [](uv_timer_t* handle) { delete handle; });
  timer_handle_ = nullptr;
}",759.0,765.0,1.0,1.0,7.0,3,3,3,1,0,0,2,2,0,0,,0,0,0,0,0,void
1263,12476,~ChannelWrap,1,node.cares_wrap.ChannelWrap.~ChannelWrap,ANY node.cares_wrap.ChannelWrap.~ChannelWrap (),cares_wrap.cc,"ChannelWrap::~ChannelWrap() {
  ares_destroy(channel_);

  if (library_inited_) {
    Mutex::ScopedLock lock(ares_library_mutex);
    // This decreases the reference counter increased by ares_library_init().
    ares_library_cleanup();
  }

  CloseTimer();
}",767.0,777.0,1.0,1.0,11.0,0,0,2,2,0,0,2,2,0,0,,0,0,0,0,0,ANY
1264,12489,ModifyActivityQueryCount,1,node.cares_wrap.ChannelWrap.ModifyActivityQueryCount,void node.cares_wrap.ChannelWrap.ModifyActivityQueryCount (int),cares_wrap.cc,"void ChannelWrap::ModifyActivityQueryCount(int count) {
  active_query_count_ += count;
  CHECK_GE(active_query_count_, 0);
}",780.0,783.0,1.0,1.0,4.0,1,1,3,2,0,0,1,1,0,0,,0,0,2,1,1,void
1265,12500,EnsureServers,1,node.cares_wrap.ChannelWrap.EnsureServers,void node.cares_wrap.ChannelWrap.EnsureServers (),cares_wrap.cc,"void ChannelWrap::EnsureServers() {
  /* if last query is OK or servers are set by user self, do not check */
  if (query_last_ok_ || !is_servers_default_) {
    return;
  }

  ares_addr_port_node* servers = nullptr;

  ares_get_servers_ports(channel_, &servers);

  /* if no server or multi-servers, ignore */
  if (servers == nullptr) return;
  if (servers->next != nullptr) {
    ares_free_data(servers);
    is_servers_default_ = false;
    return;
  }

  /* if the only server is not 127.0.0.1, ignore */
  if (servers[0].family != AF_INET ||
      servers[0].addr.addr4.s_addr != htonl(INADDR_LOOPBACK) ||
      servers[0].tcp_port != 0 ||
      servers[0].udp_port != 0) {
    ares_free_data(servers);
    is_servers_default_ = false;
    return;
  }

  ares_free_data(servers);
  servers = nullptr;

  /* destroy channel and reset channel */
  ares_destroy(channel_);

  CloseTimer();
  Setup();
}",793.0,829.0,1.0,1.0,37.0,27,9,19,6,0,0,5,5,0,0,,0,0,0,0,0,void
1266,12590,Send,1,node.cares_wrap.AnyTraits.Send,"int node.cares_wrap.AnyTraits.Send (QueryWrap<AnyTraits>*,char*)",cares_wrap.cc,"int AnyTraits::Send(QueryWrap<AnyTraits>* wrap, const char* name) {
  wrap->AresQuery(name, ns_c_in, ns_t_any);
  return 0;
}",831.0,834.0,1.0,1.0,4.0,1,1,4,4,0,0,1,1,0,0,,0,0,4,2,2,int
1267,12605,Send,1,node.cares_wrap.ATraits.Send,"int node.cares_wrap.ATraits.Send (QueryWrap<ATraits>*,char*)",cares_wrap.cc,"int ATraits::Send(QueryWrap<ATraits>* wrap, const char* name) {
  wrap->AresQuery(name, ns_c_in, ns_t_a);
  return 0;
}",836.0,839.0,1.0,1.0,4.0,1,1,4,4,0,0,1,1,0,0,,0,0,4,2,2,int
1268,12620,Send,1,node.cares_wrap.AaaaTraits.Send,"int node.cares_wrap.AaaaTraits.Send (QueryWrap<AaaaTraits>*,char*)",cares_wrap.cc,"int AaaaTraits::Send(QueryWrap<AaaaTraits>* wrap, const char* name) {
  wrap->AresQuery(name, ns_c_in, ns_t_aaaa);
  return 0;
}",841.0,844.0,1.0,1.0,4.0,1,1,4,4,0,0,1,1,0,0,,0,0,4,2,2,int
1269,12635,Send,1,node.cares_wrap.CaaTraits.Send,"int node.cares_wrap.CaaTraits.Send (QueryWrap<CaaTraits>*,char*)",cares_wrap.cc,"int CaaTraits::Send(QueryWrap<CaaTraits>* wrap, const char* name) {
  wrap->AresQuery(name, ns_c_in, T_CAA);
  return 0;
}",846.0,849.0,1.0,33.0,4.0,1,1,3,3,0,0,1,1,0,0,,0,0,4,2,2,int
1270,12652,Send,1,node.cares_wrap.CnameTraits.Send,"int node.cares_wrap.CnameTraits.Send (QueryWrap<CnameTraits>*,char*)",cares_wrap.cc,"int CnameTraits::Send(QueryWrap<CnameTraits>* wrap, const char* name) {
  wrap->AresQuery(name, ns_c_in, ns_t_cname);
  return 0;
}",851.0,854.0,1.0,1.0,4.0,1,1,4,4,0,0,1,1,0,0,,0,0,4,2,2,int
1271,12667,Send,1,node.cares_wrap.MxTraits.Send,"int node.cares_wrap.MxTraits.Send (QueryWrap<MxTraits>*,char*)",cares_wrap.cc,"int MxTraits::Send(QueryWrap<MxTraits>* wrap, const char* name) {
  wrap->AresQuery(name, ns_c_in, ns_t_mx);
  return 0;
}",856.0,859.0,1.0,1.0,4.0,1,1,4,4,0,0,1,1,0,0,,0,0,4,2,2,int
1272,12682,Send,1,node.cares_wrap.NsTraits.Send,"int node.cares_wrap.NsTraits.Send (QueryWrap<NsTraits>*,char*)",cares_wrap.cc,"int NsTraits::Send(QueryWrap<NsTraits>* wrap, const char* name) {
  wrap->AresQuery(name, ns_c_in, ns_t_ns);
  return 0;
}",861.0,864.0,1.0,1.0,4.0,1,1,4,4,0,0,1,1,0,0,,0,0,4,2,2,int
1273,12697,Send,1,node.cares_wrap.TxtTraits.Send,"int node.cares_wrap.TxtTraits.Send (QueryWrap<TxtTraits>*,char*)",cares_wrap.cc,"int TxtTraits::Send(QueryWrap<TxtTraits>* wrap, const char* name) {
  wrap->AresQuery(name, ns_c_in, ns_t_txt);
  return 0;
}",866.0,869.0,1.0,1.0,4.0,1,1,4,4,0,0,1,1,0,0,,0,0,4,2,2,int
1274,12712,Send,1,node.cares_wrap.SrvTraits.Send,"int node.cares_wrap.SrvTraits.Send (QueryWrap<SrvTraits>*,char*)",cares_wrap.cc,"int SrvTraits::Send(QueryWrap<SrvTraits>* wrap, const char* name) {
  wrap->AresQuery(name, ns_c_in, ns_t_srv);
  return 0;
}",871.0,874.0,1.0,1.0,4.0,1,1,4,4,0,0,1,1,0,0,,0,0,4,2,2,int
1275,12727,Send,1,node.cares_wrap.PtrTraits.Send,"int node.cares_wrap.PtrTraits.Send (QueryWrap<PtrTraits>*,char*)",cares_wrap.cc,"int PtrTraits::Send(QueryWrap<PtrTraits>* wrap, const char* name) {
  wrap->AresQuery(name, ns_c_in, ns_t_ptr);
  return 0;
}",876.0,879.0,1.0,1.0,4.0,1,1,4,4,0,0,1,1,0,0,,0,0,4,2,2,int
1276,12742,Send,1,node.cares_wrap.NaptrTraits.Send,"int node.cares_wrap.NaptrTraits.Send (QueryWrap<NaptrTraits>*,char*)",cares_wrap.cc,"int NaptrTraits::Send(QueryWrap<NaptrTraits>* wrap, const char* name) {
  wrap->AresQuery(name, ns_c_in, ns_t_naptr);
  return 0;
}",881.0,884.0,1.0,1.0,4.0,1,1,4,4,0,0,1,1,0,0,,0,0,4,2,2,int
1277,12757,Send,1,node.cares_wrap.SoaTraits.Send,"int node.cares_wrap.SoaTraits.Send (QueryWrap<SoaTraits>*,char*)",cares_wrap.cc,"int SoaTraits::Send(QueryWrap<SoaTraits>* wrap, const char* name) {
  wrap->AresQuery(name, ns_c_in, ns_t_soa);
  return 0;
}",886.0,889.0,1.0,1.0,4.0,1,1,4,4,0,0,1,1,0,0,,0,0,4,2,2,int
1278,12772,Parse,1,node.cares_wrap.AnyTraits.Parse,"int node.cares_wrap.AnyTraits.Parse (QueryAnyWrap*,ANY)",cares_wrap.cc,"int AnyTraits::Parse(
    QueryAnyWrap* wrap,
    const std::unique_ptr<ResponseData>& response) {
  if (UNLIKELY(response->is_host))
    return ARES_EBADRESP;

  unsigned char* buf = response->buf.data;
  int len = response->buf.size;

  Environment* env = wrap->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  Local<Array> ret = Array::New(env->isolate());
  int type, status, old_count;

  /* Parse A records or CNAME records */
  ares_addrttl addrttls[256];
  int naddrttls = arraysize(addrttls);

  type = ns_t_cname_or_a;
  status = ParseGeneralReply(env,
                             buf,
                             len,
                             &type,
                             ret,
                             addrttls,
                             &naddrttls);
  uint32_t a_count = ret->Length();
  if (status != ARES_SUCCESS && status != ARES_ENODATA)
    return status;

  if (type == ns_t_a) {
    CHECK_EQ(static_cast<u...",891.0,1056.0,1.0,1.0,166.0,201,14,269,30,0,0,18,19,0,0,,0,0,4,2,2,int
1279,13644,Parse,1,node.cares_wrap.ATraits.Parse,"int node.cares_wrap.ATraits.Parse (QueryAWrap*,ANY)",cares_wrap.cc,"int ATraits::Parse(
    QueryAWrap* wrap,
    const std::unique_ptr<ResponseData>& response) {
  if (UNLIKELY(response->is_host))
    return ARES_EBADRESP;

  unsigned char* buf = response->buf.data;
  int len = response->buf.size;

  Environment* env = wrap->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  ares_addrttl addrttls[256];
  int naddrttls = arraysize(addrttls), status;
  Local<Array> ret = Array::New(env->isolate());

  int type = ns_t_a;
  status = ParseGeneralReply(env,
                             buf,
                             len,
                             &type,
                             ret,
                             addrttls,
                             &naddrttls);
  if (status != ARES_SUCCESS)
    return status;

  Local<Array> ttls = AddrTTLToArray<ares_addrttl>(env, addrttls, naddrttls);

  wrap->CallOnComplete(ret, ttls);
  return 0;
}",1058.0,1090.0,1.0,1.0,33.0,30,9,41,18,0,0,3,3,0,0,,0,0,4,2,2,int
1280,13760,Parse,1,node.cares_wrap.AaaaTraits.Parse,"int node.cares_wrap.AaaaTraits.Parse (QueryAaaaWrap*,ANY)",cares_wrap.cc,"int AaaaTraits::Parse(
    QueryAaaaWrap* wrap,
    const std::unique_ptr<ResponseData>& response) {
  if (UNLIKELY(response->is_host))
    return ARES_EBADRESP;

  unsigned char* buf = response->buf.data;
  int len = response->buf.size;

  Environment* env = wrap->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  ares_addr6ttl addrttls[256];
  int naddrttls = arraysize(addrttls), status;
  Local<Array> ret = Array::New(env->isolate());

  int type = ns_t_aaaa;
  status = ParseGeneralReply(env,
                             buf,
                             len,
                             &type,
                             ret,
                             addrttls,
                             &naddrttls);
  if (status != ARES_SUCCESS)
    return status;

  Local<Array> ttls = AddrTTLToArray<ares_addr6ttl>(env, addrttls, naddrttls);

  wrap->CallOnComplete(ret, ttls);
  return 0;
}",1092.0,1124.0,1.0,1.0,33.0,30,9,41,18,0,0,3,3,0,0,,0,0,4,2,2,int
1281,13876,Parse,1,node.cares_wrap.CaaTraits.Parse,"int node.cares_wrap.CaaTraits.Parse (QueryCaaWrap*,ANY)",cares_wrap.cc,"int CaaTraits::Parse(
    QueryCaaWrap* wrap,
    const std::unique_ptr<ResponseData>& response) {
  if (UNLIKELY(response->is_host))
    return ARES_EBADRESP;

  unsigned char* buf = response->buf.data;
  int len = response->buf.size;

  Environment* env = wrap->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  Local<Array> ret = Array::New(env->isolate());
  int status = ParseCaaReply(env, buf, len, ret);
  if (status != ARES_SUCCESS)
    return status;

  wrap->CallOnComplete(ret);
  return 0;
}",1126.0,1146.0,1.0,1.0,21.0,19,6,25,11,0,0,3,3,0,0,,0,0,4,2,2,int
1282,13961,Parse,1,node.cares_wrap.CnameTraits.Parse,"int node.cares_wrap.CnameTraits.Parse (QueryCnameWrap*,ANY)",cares_wrap.cc,"int CnameTraits::Parse(
    QueryCnameWrap* wrap,
    const std::unique_ptr<ResponseData>& response) {
  if (UNLIKELY(response->is_host))
    return ARES_EBADRESP;

  unsigned char* buf = response->buf.data;
  int len = response->buf.size;

  Environment* env = wrap->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  Local<Array> ret = Array::New(env->isolate());
  int type = ns_t_cname;
  int status = ParseGeneralReply(env, buf, len, &type, ret);
  if (status != ARES_SUCCESS)
    return status;

  wrap->CallOnComplete(ret);
  return 0;
}",1148.0,1169.0,1.0,1.0,22.0,21,7,28,13,0,0,3,3,0,0,,0,0,4,2,2,int
1283,14052,Parse,1,node.cares_wrap.MxTraits.Parse,"int node.cares_wrap.MxTraits.Parse (QueryMxWrap*,ANY)",cares_wrap.cc,"int MxTraits::Parse(
    QueryMxWrap* wrap,
    const std::unique_ptr<ResponseData>& response) {
  if (UNLIKELY(response->is_host))
    return ARES_EBADRESP;

  unsigned char* buf = response->buf.data;
  int len = response->buf.size;

  Environment* env = wrap->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  Local<Array> mx_records = Array::New(env->isolate());
  int status = ParseMxReply(env, buf, len, mx_records);

  if (status != ARES_SUCCESS)
    return status;

  wrap->CallOnComplete(mx_records);
  return 0;
}",1171.0,1192.0,1.0,1.0,22.0,19,6,25,11,0,0,3,3,0,0,,0,0,4,2,2,int
1284,14137,Parse,1,node.cares_wrap.NsTraits.Parse,"int node.cares_wrap.NsTraits.Parse (QueryNsWrap*,ANY)",cares_wrap.cc,"int NsTraits::Parse(
    QueryNsWrap* wrap,
    const std::unique_ptr<ResponseData>& response) {
  if (UNLIKELY(response->is_host))
    return ARES_EBADRESP;

  unsigned char* buf = response->buf.data;
  int len = response->buf.size;

  Environment* env = wrap->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  int type = ns_t_ns;
  Local<Array> names = Array::New(env->isolate());
  int status = ParseGeneralReply(env, buf, len, &type, names);
  if (status != ARES_SUCCESS)
    return status;

  wrap->CallOnComplete(names);
  return 0;
}",1194.0,1215.0,1.0,1.0,22.0,21,7,28,13,0,0,3,3,0,0,,0,0,4,2,2,int
1285,14228,Parse,1,node.cares_wrap.TxtTraits.Parse,"int node.cares_wrap.TxtTraits.Parse (QueryTxtWrap*,ANY)",cares_wrap.cc,"int TxtTraits::Parse(
    QueryTxtWrap* wrap,
    const std::unique_ptr<ResponseData>& response) {
  if (UNLIKELY(response->is_host))
    return ARES_EBADRESP;

  unsigned char* buf = response->buf.data;
  int len = response->buf.size;

  Environment* env = wrap->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  Local<Array> txt_records = Array::New(env->isolate());
  int status = ParseTxtReply(env, buf, len, txt_records);
  if (status != ARES_SUCCESS)
    return status;

  wrap->CallOnComplete(txt_records);
  return 0;
}",1217.0,1237.0,1.0,1.0,21.0,19,6,25,11,0,0,3,3,0,0,,0,0,4,2,2,int
1286,14313,Parse,1,node.cares_wrap.SrvTraits.Parse,"int node.cares_wrap.SrvTraits.Parse (QuerySrvWrap*,ANY)",cares_wrap.cc,"int SrvTraits::Parse(
    QuerySrvWrap* wrap,
    const std::unique_ptr<ResponseData>& response) {
  if (UNLIKELY(response->is_host))
    return ARES_EBADRESP;

  unsigned char* buf = response->buf.data;
  int len = response->buf.size;

  Environment* env = wrap->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  Local<Array> srv_records = Array::New(env->isolate());
  int status = ParseSrvReply(env, buf, len, srv_records);
  if (status != ARES_SUCCESS)
    return status;

  wrap->CallOnComplete(srv_records);
  return 0;
}",1239.0,1259.0,1.0,1.0,21.0,19,6,25,11,0,0,3,3,0,0,,0,0,4,2,2,int
1287,14398,Parse,1,node.cares_wrap.PtrTraits.Parse,"int node.cares_wrap.PtrTraits.Parse (QueryPtrWrap*,ANY)",cares_wrap.cc,"int PtrTraits::Parse(
    QueryPtrWrap* wrap,
    const std::unique_ptr<ResponseData>& response) {
  if (UNLIKELY(response->is_host))
    return ARES_EBADRESP;

  unsigned char* buf = response->buf.data;
  int len = response->buf.size;

  Environment* env = wrap->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  int type = ns_t_ptr;
  Local<Array> aliases = Array::New(env->isolate());

  int status = ParseGeneralReply(env, buf, len, &type, aliases);
  if (status != ARES_SUCCESS)
    return status;

  wrap->CallOnComplete(aliases);
  return 0;
}",1261.0,1283.0,1.0,1.0,23.0,21,7,28,13,0,0,3,3,0,0,,0,0,4,2,2,int
1288,14489,Parse,1,node.cares_wrap.NaptrTraits.Parse,"int node.cares_wrap.NaptrTraits.Parse (QueryNaptrWrap*,ANY)",cares_wrap.cc,"int NaptrTraits::Parse(
    QueryNaptrWrap* wrap,
    const std::unique_ptr<ResponseData>& response) {
  if (UNLIKELY(response->is_host))
    return ARES_EBADRESP;

  unsigned char* buf = response->buf.data;
  int len = response->buf.size;

  Environment* env = wrap->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  Local<Array> naptr_records = Array::New(env->isolate());
  int status = ParseNaptrReply(env, buf, len, naptr_records);
  if (status != ARES_SUCCESS)
    return status;

  wrap->CallOnComplete(naptr_records);
  return 0;
}",1285.0,1305.0,1.0,1.0,21.0,19,6,25,11,0,0,3,3,0,0,,0,0,4,2,2,int
1289,14574,Parse,1,node.cares_wrap.SoaTraits.Parse,"int node.cares_wrap.SoaTraits.Parse (QuerySoaWrap*,ANY)",cares_wrap.cc,"int SoaTraits::Parse(
    QuerySoaWrap* wrap,
    const std::unique_ptr<ResponseData>& response) {
  if (UNLIKELY(response->is_host))
    return ARES_EBADRESP;

  unsigned char* buf = response->buf.data;
  int len = response->buf.size;

  Environment* env = wrap->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  ares_soa_reply* soa_out;
  int status = ares_parse_soa_reply(buf, len, &soa_out);

  if (status != ARES_SUCCESS)
    return status;

  Local<Object> soa_record = Object::New(env->isolate());

  soa_record->Set(env->context(),
                  env->nsname_string(),
                  OneByteString(env->isolate(), soa_out->nsname)).Check();
  soa_record->Set(env->context(),
                  env->hostmaster_string(),
                  OneByteString(env->isolate(), soa_out->hostmaster)).Check();
  soa_record->Set(env->context(),
                  env->serial_string(),
                  Integer::NewFromUnsigned(
               ...",1307.0,1356.0,1.0,1.0,50.0,67,7,65,13,0,0,3,3,0,0,,0,0,4,2,2,int
1290,14838,Send,1,node.cares_wrap.ReverseTraits.Send,"int node.cares_wrap.ReverseTraits.Send (GetHostByAddrWrap*,char*)",cares_wrap.cc,"int ReverseTraits::Send(GetHostByAddrWrap* wrap, const char* name) {
  int length, family;
  char address_buffer[sizeof(struct in6_addr)];

  if (uv_inet_pton(AF_INET, name, &address_buffer) == 0) {
    length = sizeof(struct in_addr);
    family = AF_INET;
  } else if (uv_inet_pton(AF_INET6, name, &address_buffer) == 0) {
    length = sizeof(struct in6_addr);
    family = AF_INET6;
  } else {
    return UV_EINVAL;  // So errnoException() reports a proper error.
  }

  TRACE_EVENT_NESTABLE_ASYNC_BEGIN2(
      TRACING_CATEGORY_NODE2(dns, native), ""reverse"", wrap,
      ""name"", TRACE_STR_COPY(name),
      ""family"", family == AF_INET ? ""ipv4"" : ""ipv6"");

  ares_gethostbyaddr(
      wrap->channel()->cares_channel(),
      address_buffer,
      length,
      family,
      GetHostByAddrWrap::Callback,
      wrap->MakeCallbackPointer());
  return 0;
}",1358.0,1385.0,1.0,1.0,28.0,11,7,19,10,0,0,2,2,0,0,,0,0,4,2,2,int
1291,14921,Parse,1,node.cares_wrap.ReverseTraits.Parse,"int node.cares_wrap.ReverseTraits.Parse (GetHostByAddrWrap*,ANY)",cares_wrap.cc,"int ReverseTraits::Parse(
    GetHostByAddrWrap* wrap,
    const std::unique_ptr<ResponseData>& response) {
  if (UNLIKELY(!response->is_host))
    return ARES_EBADRESP;

  struct hostent* host = response->host.get();

  Environment* env = wrap->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());
  wrap->CallOnComplete(HostentToNames(env, host));
  return 0;
}",1387.0,1400.0,1.0,1.0,14.0,10,4,11,5,0,0,2,2,0,0,,0,0,4,2,2,int
1292,14974,Query,1,node.cares_wrap.anonymous_namespace_21.Query,void node.cares_wrap.anonymous_namespace_21.Query<Wrap> (FunctionCallbackInfo<Value>),cares_wrap.cc,"static void Query(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  ChannelWrap* channel;
  ASSIGN_OR_RETURN_UNWRAP(&channel, args.Holder());

  CHECK_EQ(false, args.IsConstructCall());
  CHECK(args[0]->IsObject());
  CHECK(args[1]->IsString());

  Local<Object> req_wrap_obj = args[0].As<Object>();
  Local<String> string = args[1].As<String>();
  auto wrap = std::make_unique<Wrap>(channel, req_wrap_obj);

  node::Utf8Value name(env->isolate(), string);
  channel->ModifyActivityQueryCount(1);
  int err = wrap->Send(*name);
  if (err) {
    channel->ModifyActivityQueryCount(-1);
  } else {
    // Release ownership of the pointer allowing the ownership to be transferred
    USE(wrap.release());
  }

  args.GetReturnValue().Set(err);
}",1404.0,1428.0,1.0,1.0,25.0,34,11,31,14,0,0,2,2,0,0,,0,0,2,1,1,void
1293,15097,AfterGetAddrInfo,1,node.cares_wrap.anonymous_namespace_22.AfterGetAddrInfo,"void node.cares_wrap.anonymous_namespace_22.AfterGetAddrInfo (uv_getaddrinfo_t*,int,addrinfo*)",cares_wrap.cc,"void AfterGetAddrInfo(uv_getaddrinfo_t* req, int status, struct addrinfo* res) {
  auto cleanup = OnScopeLeave([&]() { uv_freeaddrinfo(res); });
  BaseObjectPtr<GetAddrInfoReqWrap> req_wrap{
      static_cast<GetAddrInfoReqWrap*>(req->data)};
  Environment* env = req_wrap->env();

  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  Local<Value> argv[] = {
    Integer::New(env->isolate(), status),
    Null(env->isolate())
  };

  uint32_t n = 0;
  const bool verbatim = req_wrap->verbatim();

  if (status == 0) {
    Local<Array> results = Array::New(env->isolate());

    auto add = [&] (bool want_ipv4, bool want_ipv6) -> Maybe<bool> {
      for (auto p = res; p != nullptr; p = p->ai_next) {
        CHECK_EQ(p->ai_socktype, SOCK_STREAM);

        const char* addr;
        if (want_ipv4 && p->ai_family == AF_INET) {
          addr = reinterpret_cast<char*>(
              &(reinterpret_cast<struct sockaddr_in*>(p->ai_addr)->sin_addr));
        ...",1431.0,1499.0,1.0,1.0,69.0,38,9,41,18,0,0,6,11,0,0,,0,0,6,3,3,void
1294,15258,AfterGetNameInfo,1,node.cares_wrap.anonymous_namespace_25.AfterGetNameInfo,"void node.cares_wrap.anonymous_namespace_25.AfterGetNameInfo (uv_getnameinfo_t*,int,char*,char*)",cares_wrap.cc,"void AfterGetNameInfo(uv_getnameinfo_t* req,
                      int status,
                      const char* hostname,
                      const char* service) {
  BaseObjectPtr<GetNameInfoReqWrap> req_wrap{
      static_cast<GetNameInfoReqWrap*>(req->data)};
  Environment* env = req_wrap->env();

  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  Local<Value> argv[] = {
    Integer::New(env->isolate(), status),
    Null(env->isolate()),
    Null(env->isolate())
  };

  if (status == 0) {
    // Success
    Local<String> js_hostname = OneByteString(env->isolate(), hostname);
    Local<String> js_service = OneByteString(env->isolate(), service);
    argv[1] = js_hostname;
    argv[2] = js_service;
  }

  TRACE_EVENT_NESTABLE_ASYNC_END2(
      TRACING_CATEGORY_NODE2(dns, native), ""lookupService"", req_wrap.get(),
      ""hostname"", TRACE_STR_COPY(hostname),
      ""service"", TRACE_STR_COPY(service));

  // Make the callback into JavaScrip...",1502.0,1534.0,1.0,1.0,33.0,31,9,37,16,0,0,2,2,0,0,,0,0,8,4,4,void
1295,15384,CanonicalizeIP,1,node.cares_wrap.anonymous_namespace_26.CanonicalizeIP,void node.cares_wrap.anonymous_namespace_26.CanonicalizeIP (FunctionCallbackInfo<Value>),cares_wrap.cc,"void CanonicalizeIP(const FunctionCallbackInfo<Value>& args) {
  Isolate* isolate = args.GetIsolate();
  node::Utf8Value ip(isolate, args[0]);

  int af;
  unsigned char result[sizeof(ares_addr_port_node::addr)];
  if (uv_inet_pton(af = AF_INET, *ip, result) != 0 &&
      uv_inet_pton(af = AF_INET6, *ip, result) != 0)
    return;

  char canonical_ip[INET6_ADDRSTRLEN];
  CHECK_EQ(0, uv_inet_ntop(af, result, canonical_ip, sizeof(canonical_ip)));
  Local<String> val = String::NewFromUtf8(isolate, canonical_ip)
      .ToLocalChecked();
  args.GetReturnValue().Set(val);
}",1536.0,1551.0,1.0,1.0,16.0,18,9,24,11,0,0,2,2,0,0,,0,0,2,1,1,void
1296,15458,GetAddrInfo,1,node.cares_wrap.anonymous_namespace_27.GetAddrInfo,void node.cares_wrap.anonymous_namespace_27.GetAddrInfo (FunctionCallbackInfo<Value>),cares_wrap.cc,"void GetAddrInfo(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  CHECK(args[0]->IsObject());
  CHECK(args[1]->IsString());
  CHECK(args[2]->IsInt32());
  CHECK(args[4]->IsBoolean());
  Local<Object> req_wrap_obj = args[0].As<Object>();
  node::Utf8Value hostname(env->isolate(), args[1]);
  std::string ascii_hostname = ada::idna::to_ascii(hostname.ToStringView());

  int32_t flags = 0;
  if (args[3]->IsInt32()) {
    flags = args[3].As<Int32>()->Value();
  }

  int family;

  switch (args[2].As<Int32>()->Value()) {
    case 0:
      family = AF_UNSPEC;
      break;
    case 4:
      family = AF_INET;
      break;
    case 6:
      family = AF_INET6;
      break;
    default:
      UNREACHABLE(""bad address family"");
  }

  auto req_wrap = std::make_unique<GetAddrInfoReqWrap>(env,
                                                       req_wrap_obj,
                                                       args[4]->IsTrue());

  struct addr...",1553.0,1612.0,1.0,1.0,60.0,64,12,59,24,0,0,7,4,0,0,,0,0,2,1,1,void
1297,15691,GetNameInfo,1,node.cares_wrap.anonymous_namespace_29.GetNameInfo,void node.cares_wrap.anonymous_namespace_29.GetNameInfo (FunctionCallbackInfo<Value>),cares_wrap.cc,"void GetNameInfo(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  CHECK(args[0]->IsObject());
  CHECK(args[1]->IsString());
  CHECK(args[2]->IsUint32());
  Local<Object> req_wrap_obj = args[0].As<Object>();
  node::Utf8Value ip(env->isolate(), args[1]);
  const unsigned port = args[2]->Uint32Value(env->context()).FromJust();
  struct sockaddr_storage addr;

  CHECK(uv_ip4_addr(*ip, port, reinterpret_cast<sockaddr_in*>(&addr)) == 0 ||
        uv_ip6_addr(*ip, port, reinterpret_cast<sockaddr_in6*>(&addr)) == 0);

  auto req_wrap = std::make_unique<GetNameInfoReqWrap>(env, req_wrap_obj);

  TRACE_EVENT_NESTABLE_ASYNC_BEGIN2(
      TRACING_CATEGORY_NODE2(dns, native), ""lookupService"", req_wrap.get(),
      ""ip"", TRACE_STR_COPY(*ip), ""port"", port);

  int err = req_wrap->Dispatch(uv_getnameinfo,
                               AfterGetNameInfo,
                               reinterpret_cast<struct sockaddr*>(&addr),
                       ...",1615.0,1644.0,1.0,1.0,30.0,45,13,40,17,0,0,2,2,0,0,,0,0,2,1,1,void
1298,15845,GetServers,1,node.cares_wrap.anonymous_namespace_31.GetServers,void node.cares_wrap.anonymous_namespace_31.GetServers (FunctionCallbackInfo<Value>),cares_wrap.cc,"void GetServers(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  ChannelWrap* channel;
  ASSIGN_OR_RETURN_UNWRAP(&channel, args.Holder());

  Local<Array> server_array = Array::New(env->isolate());

  ares_addr_port_node* servers;

  int r = ares_get_servers_ports(channel->cares_channel(), &servers);
  CHECK_EQ(r, ARES_SUCCESS);
  auto cleanup = OnScopeLeave([&]() { ares_free_data(servers); });

  ares_addr_port_node* cur = servers;

  for (uint32_t i = 0; cur != nullptr; ++i, cur = cur->next) {
    char ip[INET6_ADDRSTRLEN];

    const void* caddr = static_cast<const void*>(&cur->addr);
    int err = uv_inet_ntop(cur->family, caddr, ip, sizeof(ip));
    CHECK_EQ(err, 0);

    Local<Value> ret[] = {
      OneByteString(env->isolate(), ip),
      Integer::New(env->isolate(), cur->udp_port)
    };

    if (server_array->Set(env->context(), i,
                          Array::New(env->isolate(), ret, arraysize(ret)))
          .IsNothing(...",1647.0,1682.0,1.0,1.0,36.0,36,10,43,18,0,0,3,4,0,0,,0,0,2,1,1,void
1299,15999,SetServers,1,node.cares_wrap.anonymous_namespace_33.SetServers,void node.cares_wrap.anonymous_namespace_33.SetServers (FunctionCallbackInfo<Value>),cares_wrap.cc,"void SetServers(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  ChannelWrap* channel;
  ASSIGN_OR_RETURN_UNWRAP(&channel, args.Holder());

  if (channel->active_query_count()) {
    return args.GetReturnValue().Set(DNS_ESETSRVPENDING);
  }

  CHECK(args[0]->IsArray());

  Local<Array> arr = args[0].As<Array>();

  uint32_t len = arr->Length();

  if (len == 0) {
    int rv = ares_set_servers(channel->cares_channel(), nullptr);
    return args.GetReturnValue().Set(rv);
  }

  std::vector<ares_addr_port_node> servers(len);
  ares_addr_port_node* last = nullptr;

  int err;

  for (uint32_t i = 0; i < len; i++) {
    CHECK(arr->Get(env->context(), i).ToLocalChecked()->IsArray());

    Local<Array> elm = arr->Get(env->context(), i).ToLocalChecked().As<Array>();

    CHECK(elm->Get(env->context(),
                   0).ToLocalChecked()->Int32Value(env->context()).FromJust());
    CHECK(elm->Get(env->context(), 1).ToLocalChecked()->IsString...",1685.0,1764.0,1.0,1.0,80.0,105,10,90,24,0,0,12,12,0,0,,0,0,2,1,1,void
1300,16395,SetLocalAddress,1,node.cares_wrap.anonymous_namespace_34.SetLocalAddress,void node.cares_wrap.anonymous_namespace_34.SetLocalAddress (FunctionCallbackInfo<Value>),cares_wrap.cc,"void SetLocalAddress(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  ChannelWrap* channel;
  ASSIGN_OR_RETURN_UNWRAP(&channel, args.Holder());

  CHECK_EQ(args.Length(), 2);
  CHECK(args[0]->IsString());

  Isolate* isolate = args.GetIsolate();
  node::Utf8Value ip0(isolate, args[0]);

  unsigned char addr0[sizeof(struct in6_addr)];
  unsigned char addr1[sizeof(struct in6_addr)];
  int type0 = 0;

  // This function accepts 2 arguments.  The first may be either an IPv4
  // address or an IPv6 address.  If present, the second argument must be the
  // other type of address.  Otherwise, the unspecified type of IP is set
  // to 0 (any).

  if (uv_inet_pton(AF_INET, *ip0, &addr0) == 0) {
    ares_set_local_ip4(channel->cares_channel(), ReadUint32BE(addr0));
    type0 = 4;
  } else if (uv_inet_pton(AF_INET6, *ip0, &addr0) == 0) {
    ares_set_local_ip6(channel->cares_channel(), addr0);
    type0 = 6;
  } else {
    THROW_ERR_INVALID_ARG_V...",1766.0,1828.0,1.0,1.0,63.0,26,8,27,11,0,0,5,8,0,0,,0,0,2,1,1,void
1301,16607,Cancel,1,node.cares_wrap.anonymous_namespace_35.Cancel,void node.cares_wrap.anonymous_namespace_35.Cancel (FunctionCallbackInfo<Value>),cares_wrap.cc,"void Cancel(const FunctionCallbackInfo<Value>& args) {
  ChannelWrap* channel;
  ASSIGN_OR_RETURN_UNWRAP(&channel, args.Holder());

  TRACE_EVENT_INSTANT0(TRACING_CATEGORY_NODE2(dns, native),
      ""cancel"", TRACE_EVENT_SCOPE_THREAD);

  ares_cancel(channel->cares_channel());
}",1830.0,1838.0,1.0,1.0,9.0,3,3,6,5,0,0,1,1,0,0,,0,0,2,1,1,void
1302,16635,StrError,1,node.cares_wrap.anonymous_namespace_36.StrError,void node.cares_wrap.anonymous_namespace_36.StrError (FunctionCallbackInfo<Value>),cares_wrap.cc,"void StrError(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  int code = args[0]->Int32Value(env->context()).FromJust();
  const char* errmsg = (code == DNS_ESETSRVPENDING) ?
    EMSG_ESETSRVPENDING :
    ares_strerror(code);
  args.GetReturnValue().Set(OneByteString(env->isolate(), errmsg));
}",1841.0,1848.0,1.0,1.0,8.0,13,6,14,7,0,0,1,1,0,0,,0,0,2,1,1,void
1303,16687,safe_free_hostent,1,node.cares_wrap.safe_free_hostent,void node.cares_wrap.safe_free_hostent (hostent*),cares_wrap.cc,"inline void safe_free_hostent(struct hostent* host) {
  int idx;

  if (host->h_addr_list != nullptr) {
    idx = 0;
    while (host->h_addr_list[idx]) {
      free(host->h_addr_list[idx++]);
    }
    free(host->h_addr_list);
    host->h_addr_list = nullptr;
  }

  if (host->h_aliases != nullptr) {
    idx = 0;
    while (host->h_aliases[idx]) {
      free(host->h_aliases[idx++]);
    }
    free(host->h_aliases);
    host->h_aliases = nullptr;
  }

  free(host->h_name);
  free(host);
}",1852.0,1875.0,1.0,1.0,24.0,23,5,18,2,0,0,5,7,0,0,,0,0,2,1,1,void
1304,16765,Initialize,1,node.cares_wrap.Initialize,"void node.cares_wrap.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)",node.cc,void Initialize() {},1277.0,1277.0,1.0,20.0,1.0,67,5,140,32,0,0,1,1,0,0,,0,0,0,0,0,void
1305,17163,RegisterExternalReferences,1,node.cares_wrap.RegisterExternalReferences,void node.cares_wrap.RegisterExternalReferences (ExternalReferenceRegistry*),cares_wrap.cc,"void RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  registry->Register(GetAddrInfo);
  registry->Register(GetNameInfo);
  registry->Register(CanonicalizeIP);
  registry->Register(StrError);
  registry->Register(ChannelWrap::New);

  registry->Register(Query<QueryAnyWrap>);
  registry->Register(Query<QueryAWrap>);
  registry->Register(Query<QueryAaaaWrap>);
  registry->Register(Query<QueryCaaWrap>);
  registry->Register(Query<QueryCnameWrap>);
  registry->Register(Query<QueryMxWrap>);
  registry->Register(Query<QueryNsWrap>);
  registry->Register(Query<QueryTxtWrap>);
  registry->Register(Query<QuerySrvWrap>);
  registry->Register(Query<QueryPtrWrap>);
  registry->Register(Query<QueryNaptrWrap>);
  registry->Register(Query<QuerySoaWrap>);
  registry->Register(Query<GetHostByAddrWrap>);

  registry->Register(GetServers);
  registry->Register(SetServers);
  registry->Register(SetLocalAddress);
  registry->Register(Cancel);
}",1951.0,1976.0,1.0,1.0,26.0,23,2,36,15,0,0,1,1,0,0,,0,0,2,1,1,void
1306,17331,<lambda>0,1,node.CleanupQueue.Drain.<lambda>0,"ANY node.CleanupQueue.Drain.<lambda>0 (CleanupHookCallback,CleanupHookCallback)",cleanup_queue.cc,"[](const CleanupHookCallback& a, const CleanupHookCallback& b) {
              // Sort in descending order so that the most recently inserted
              // callbacks are run first.
              return a.insertion_order_counter_ > b.insertion_order_counter_;
            }",17.0,21.0,13.0,13.0,5.0,3,2,2,2,0,0,1,1,0,0,,0,0,4,2,2,ANY
1307,17359,Drain,1,node.CleanupQueue.Drain,void node.CleanupQueue.Drain (),cleanup_queue.cc,"void CleanupQueue::Drain() {
  // Copy into a vector, since we can't sort an unordered_set in-place.
  std::vector<CleanupHookCallback> callbacks(cleanup_hooks_.begin(),
                                             cleanup_hooks_.end());
  // We can't erase the copied elements from `cleanup_hooks_` yet, because we
  // need to be able to check whether they were un-scheduled by another hook.

  std::sort(callbacks.begin(),
            callbacks.end(),
            [](const CleanupHookCallback& a, const CleanupHookCallback& b) {
              // Sort in descending order so that the most recently inserted
              // callbacks are run first.
              return a.insertion_order_counter_ > b.insertion_order_counter_;
            });

  for (const CleanupHookCallback& cb : callbacks) {
    if (cleanup_hooks_.count(cb) == 0) {
      // This hook was removed from the `cleanup_hooks_` set during another
      // hook that was run earlier. Nothing to do here.
      continue;
    }

   ...",8.0,33.0,1.0,1.0,26.0,13,4,14,5,0,0,4,4,0,0,,0,0,0,0,0,void
1308,17417,operator (),1,node.CleanupQueue.CleanupHookCallback.Hash.operator (),size_t node.CleanupQueue.CleanupHookCallback.Hash.operator () (CleanupHookCallback),cleanup_queue.cc,"size_t CleanupQueue::CleanupHookCallback::Hash::operator()(
    const CleanupHookCallback& cb) const {
  return std::hash<void*>()(cb.arg_);
}",35.0,38.0,1.0,1.0,4.0,2,1,2,2,0,0,1,1,0,0,,0,0,2,1,1,size_t
1309,17431,operator (),1,node.CleanupQueue.CleanupHookCallback.Equal.operator (),"bool node.CleanupQueue.CleanupHookCallback.Equal.operator () (CleanupHookCallback,CleanupHookCallback)",cleanup_queue.cc,"bool CleanupQueue::CleanupHookCallback::Equal::operator()(
    const CleanupHookCallback& a, const CleanupHookCallback& b) const {
  return a.fn_ == b.fn_ && a.arg_ == b.arg_;
}",40.0,43.0,1.0,1.0,4.0,7,3,4,2,0,0,1,1,0,0,,0,0,4,2,2,bool
1310,17477,ConnectWrap,1,node.ConnectWrap.ConnectWrap,"ANY node.ConnectWrap.ConnectWrap (Environment*,Local<Object>,ANY)",connect_wrap.cc,"ConnectWrap::ConnectWrap(Environment* env,
    Local<Object> req_wrap_obj,
    AsyncWrap::ProviderType provider) : ReqWrap(env, req_wrap_obj, provider) {
}",11.0,14.0,1.0,1.0,4.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,ANY
1311,17515,ConnectionWrap,1,"node.ConnectionWrap<WrapType,UVType>.ConnectionWrap","ANY node.ConnectionWrap<WrapType,UVType>.ConnectionWrap<WrapType,UVType> (Environment*,Local<Object>,ProviderType)",connection_wrap.cc,"ConnectionWrap<WrapType, UVType>::ConnectionWrap(Environment* env,
                                                 Local<Object> object,
                                                 ProviderType provider)
    : LibuvStreamWrap(env,
                      object,
                      reinterpret_cast<uv_stream_t*>(&handle_),
                      provider) {}",23.0,29.0,1.0,34.0,7.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,ANY
1312,17522,OnConnection,1,"node.ConnectionWrap<WrapType,UVType>.OnConnection","void node.ConnectionWrap<WrapType,UVType>.OnConnection<WrapType,UVType> (uv_stream_t*,int)",connection_wrap.cc,"void ConnectionWrap<WrapType, UVType>::OnConnection(uv_stream_t* handle,
                                                    int status) {
  WrapType* wrap_data = static_cast<WrapType*>(handle->data);
  CHECK_NOT_NULL(wrap_data);
  CHECK_EQ(&wrap_data->handle_, reinterpret_cast<UVType*>(handle));

  Environment* env = wrap_data->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  // We should not be getting this callback if someone has already called
  // uv_close() on the handle.
  CHECK_EQ(wrap_data->persistent().IsEmpty(), false);

  Local<Value> client_handle;

  if (status == 0) {
    // Instantiate the client javascript object and handle.
    Local<Object> client_obj;
    if (!WrapType::Instantiate(env, wrap_data, WrapType::SOCKET)
             .ToLocal(&client_obj))
      return;

    // Unwrap the client javascript object.
    WrapType* wrap;
    ASSIGN_OR_RETURN_UNWRAP(&wrap, client_obj);
    uv_stream_t* client = reinterpre...",33.0,74.0,1.0,1.0,42.0,34,10,39,14,0,0,4,6,0,0,,0,0,4,2,2,void
1313,17664,AfterConnect,1,"node.ConnectionWrap<WrapType,UVType>.AfterConnect","void node.ConnectionWrap<WrapType,UVType>.AfterConnect<WrapType,UVType> (uv_connect_t*,int)",connection_wrap.cc,"void ConnectionWrap<WrapType, UVType>::AfterConnect(uv_connect_t* req,
                                                    int status) {
  BaseObjectPtr<ConnectWrap> req_wrap{static_cast<ConnectWrap*>(req->data)};
  CHECK(req_wrap);
  WrapType* wrap = static_cast<WrapType*>(req->handle->data);
  CHECK_EQ(req_wrap->env(), wrap->env());
  Environment* env = wrap->env();

  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  // The wrap and request objects should still be there.
  CHECK_EQ(req_wrap->persistent().IsEmpty(), false);
  CHECK_EQ(wrap->persistent().IsEmpty(), false);

  bool readable, writable;

  if (status) {
    readable = writable = false;
  } else {
    readable = uv_is_readable(req->handle) != 0;
    writable = uv_is_writable(req->handle) != 0;
  }

  Local<Value> argv[5] = {
    Integer::New(env->isolate(), status),
    wrap->object(),
    req_wrap->object(),
    Boolean::New(env->isolate(), readable),
    Boolean::New(env->is...",78.0,117.0,1.0,1.0,40.0,28,8,27,14,0,0,2,2,0,0,,0,0,4,2,2,void
1314,17837,AES_Cipher,1,node.crypto.anonymous_namespace_1.AES_Cipher,"WebCryptoCipherStatus node.crypto.anonymous_namespace_1.AES_Cipher (Environment*,KeyObjectData*,WebCryptoCipherMode,AESCipherConfig,ByteSource,ByteSource*)",crypto\crypto_aes.cc,"WebCryptoCipherStatus AES_Cipher(
    Environment* env,
    KeyObjectData* key_data,
    WebCryptoCipherMode cipher_mode,
    const AESCipherConfig& params,
    const ByteSource& in,
    ByteSource* out) {
  CHECK_NOT_NULL(key_data);
  CHECK_EQ(key_data->GetKeyType(), kKeyTypeSecret);

  const int mode = EVP_CIPHER_mode(params.cipher);

  CipherCtxPointer ctx(EVP_CIPHER_CTX_new());
  EVP_CIPHER_CTX_init(ctx.get());
  if (mode == EVP_CIPH_WRAP_MODE)
    EVP_CIPHER_CTX_set_flags(ctx.get(), EVP_CIPHER_CTX_FLAG_WRAP_ALLOW);

  const bool encrypt = cipher_mode == kWebCryptoCipherEncrypt;

  if (!EVP_CipherInit_ex(
          ctx.get(),
          params.cipher,
          nullptr,
          nullptr,
          nullptr,
          encrypt)) {
    // Cipher init failed
    return WebCryptoCipherStatus::FAILED;
  }

  if (mode == EVP_CIPH_GCM_MODE && !EVP_CIPHER_CTX_ctrl(
        ctx.get(),
        EVP_CTRL_AEAD_SET_IVLEN,
        params.iv.size(),
        nullptr)) {
    return WebCryptoCipherS...",34.0,171.0,1.0,1.0,138.0,89,12,90,24,0,0,15,17,0,0,,0,0,12,6,6,WebCryptoCipherStatus
1315,18208,CeilDiv,1,node.crypto.anonymous_namespace_2.CeilDiv,"T node.crypto.anonymous_namespace_2.CeilDiv<T> (T,T)",crypto\crypto_aes.cc,"T CeilDiv(T a, T b) {
  return a == 0 ? 0 : 1 + (a - 1) / b;
}",178.0,180.0,1.0,1.0,3.0,5,5,3,2,0,0,1,1,0,0,,0,0,4,2,2,T
1316,18227,GetCounter,1,node.crypto.anonymous_namespace_3.GetCounter,BignumPointer node.crypto.anonymous_namespace_3.GetCounter (AESCipherConfig),crypto\crypto_aes.cc,"BignumPointer GetCounter(const AESCipherConfig& params) {
  unsigned int remainder = (params.length % CHAR_BIT);
  const unsigned char* data = params.iv.data<unsigned char>();

  if (remainder == 0) {
    unsigned int byte_length = params.length / CHAR_BIT;
    return BignumPointer(BN_bin2bn(
        data + params.iv.size() - byte_length,
        byte_length,
        nullptr));
  }

  unsigned int byte_length =
      CeilDiv(params.length, static_cast<size_t>(CHAR_BIT));

  std::vector<unsigned char> counter(
      data + params.iv.size() - byte_length,
      data + params.iv.size());
  counter[0] &= ~(0xFF << remainder);

  return BignumPointer(BN_bin2bn(counter.data(), counter.size(), nullptr));
}",182.0,203.0,1.0,1.0,22.0,29,11,25,6,0,0,2,2,0,0,,0,0,2,1,1,BignumPointer
1317,18327,BlockWithZeroedCounter,1,node.crypto.anonymous_namespace_4.BlockWithZeroedCounter,vector<unsigned char> node.crypto.anonymous_namespace_4.BlockWithZeroedCounter (AESCipherConfig),crypto\crypto_aes.cc,"std::vector<unsigned char> BlockWithZeroedCounter(
    const AESCipherConfig& params) {
  unsigned int length_bytes = params.length / CHAR_BIT;
  unsigned int remainder = params.length % CHAR_BIT;

  const unsigned char* data = params.iv.data<unsigned char>();

  std::vector<unsigned char> new_counter_block(data, data + params.iv.size());

  size_t index = new_counter_block.size() - length_bytes;
  memset(&new_counter_block.front() + index, 0, length_bytes);

  if (remainder)
    new_counter_block[index - 1] &= 0xFF << remainder;

  return new_counter_block;
}",205.0,221.0,1.0,1.0,17.0,21,9,22,7,0,0,2,2,0,0,,0,0,2,1,1,vector<unsigned char>
1318,18401,AES_CTR_Cipher2,1,node.crypto.anonymous_namespace_5.AES_CTR_Cipher2,"WebCryptoCipherStatus node.crypto.anonymous_namespace_5.AES_CTR_Cipher2 (KeyObjectData*,WebCryptoCipherMode,AESCipherConfig,ByteSource,unsigned char*,unsigned char*)",crypto\crypto_aes.cc,"WebCryptoCipherStatus AES_CTR_Cipher2(
    KeyObjectData* key_data,
    WebCryptoCipherMode cipher_mode,
    const AESCipherConfig& params,
    const ByteSource& in,
    unsigned const char* counter,
    unsigned char* out) {
  CipherCtxPointer ctx(EVP_CIPHER_CTX_new());
  const bool encrypt = cipher_mode == kWebCryptoCipherEncrypt;

  if (!EVP_CipherInit_ex(
          ctx.get(),
          params.cipher,
          nullptr,
          reinterpret_cast<const unsigned char*>(key_data->GetSymmetricKey()),
          counter,
          encrypt)) {
    // Cipher init failed
    return WebCryptoCipherStatus::FAILED;
  }

  int out_len = 0;
  int final_len = 0;
  if (!EVP_CipherUpdate(
          ctx.get(),
          out,
          &out_len,
          in.data<unsigned char>(),
          in.size())) {
    return WebCryptoCipherStatus::FAILED;
  }

  if (!EVP_CipherFinal_ex(ctx.get(), out + out_len, &final_len))
    return WebCryptoCipherStatus::FAILED;

  out_len += final_len;
  if (static_cast...",223.0,263.0,1.0,1.0,41.0,27,10,28,12,0,0,5,5,0,0,,0,0,12,6,6,WebCryptoCipherStatus
1319,18513,AES_CTR_Cipher,1,node.crypto.anonymous_namespace_6.AES_CTR_Cipher,"WebCryptoCipherStatus node.crypto.anonymous_namespace_6.AES_CTR_Cipher (Environment*,KeyObjectData*,WebCryptoCipherMode,AESCipherConfig,ByteSource,ByteSource*)",crypto\crypto_aes.cc,"WebCryptoCipherStatus AES_CTR_Cipher(
    Environment* env,
    KeyObjectData* key_data,
    WebCryptoCipherMode cipher_mode,
    const AESCipherConfig& params,
    const ByteSource& in,
    ByteSource* out) {
  BignumPointer num_counters(BN_new());
  if (!BN_lshift(num_counters.get(), BN_value_one(), params.length))
    return WebCryptoCipherStatus::FAILED;

  BignumPointer current_counter = GetCounter(params);

  BignumPointer num_output(BN_new());

  if (!BN_set_word(num_output.get(), CeilDiv(in.size(), kAesBlockSize)))
    return WebCryptoCipherStatus::FAILED;

  // Just like in chromium's implementation, if the counter will
  // be incremented more than there are counter values, we fail.
  if (BN_cmp(num_output.get(), num_counters.get()) > 0)
    return WebCryptoCipherStatus::FAILED;

  BignumPointer remaining_until_reset(BN_new());
  if (!BN_sub(remaining_until_reset.get(),
              num_counters.get(),
              current_counter.get())) {
    return WebCryptoCipherStat...",265.0,343.0,1.0,1.0,79.0,60,11,69,18,0,0,9,10,0,0,,0,0,12,6,6,WebCryptoCipherStatus
1320,18771,ValidateIV,1,node.crypto.anonymous_namespace_9.ValidateIV,"bool node.crypto.anonymous_namespace_9.ValidateIV (Environment*,CryptoJobMode,Local<Value>,AESCipherConfig*)",crypto\crypto_aes.cc,"bool ValidateIV(
    Environment* env,
    CryptoJobMode mode,
    Local<Value> value,
    AESCipherConfig* params) {
  ArrayBufferOrViewContents<char> iv(value);
  if (UNLIKELY(!iv.CheckSizeInt32())) {
    THROW_ERR_OUT_OF_RANGE(env, ""iv is too big"");
    return false;
  }
  params->iv = (mode == kCryptoJobAsync)
      ? iv.ToCopy()
      : iv.ToByteSource();
  return true;
}",345.0,359.0,1.0,1.0,15.0,8,6,8,6,0,0,2,2,0,0,,0,0,8,4,4,bool
1321,18813,ValidateCounter,1,node.crypto.anonymous_namespace_10.ValidateCounter,"bool node.crypto.anonymous_namespace_10.ValidateCounter (Environment*,Local<Value>,AESCipherConfig*)",crypto\crypto_aes.cc,"bool ValidateCounter(
  Environment* env,
  Local<Value> value,
  AESCipherConfig* params) {
  CHECK(value->IsUint32());  // Length
  params->length = value.As<Uint32>()->Value();
  if (params->iv.size() != 16 ||
      params->length == 0 ||
      params->length > 128) {
    THROW_ERR_CRYPTO_INVALID_COUNTER(env);
    return false;
  }
  return true;
}",361.0,374.0,1.0,1.0,14.0,14,7,7,3,0,0,2,2,0,0,,0,0,6,3,3,bool
1322,18864,ValidateAuthTag,1,node.crypto.anonymous_namespace_11.ValidateAuthTag,"bool node.crypto.anonymous_namespace_11.ValidateAuthTag (Environment*,CryptoJobMode,WebCryptoCipherMode,Local<Value>,AESCipherConfig*)",crypto\crypto_aes.cc,"bool ValidateAuthTag(
    Environment* env,
    CryptoJobMode mode,
    WebCryptoCipherMode cipher_mode,
    Local<Value> value,
    AESCipherConfig* params) {
  switch (cipher_mode) {
    case kWebCryptoCipherDecrypt: {
      if (!IsAnyByteSource(value)) {
        THROW_ERR_CRYPTO_INVALID_TAG_LENGTH(env);
        return false;
      }
      ArrayBufferOrViewContents<char> tag_contents(value);
      if (UNLIKELY(!tag_contents.CheckSizeInt32())) {
        THROW_ERR_OUT_OF_RANGE(env, ""tagLength is too big"");
        return false;
      }
      params->tag = mode == kCryptoJobAsync
          ? tag_contents.ToCopy()
          : tag_contents.ToByteSource();
      break;
    }
    case kWebCryptoCipherEncrypt: {
      if (!value->IsUint32()) {
        THROW_ERR_CRYPTO_INVALID_TAG_LENGTH(env);
        return false;
      }
      params->length = value.As<Uint32>()->Value();
      if (params->length > 128) {
        THROW_ERR_CRYPTO_INVALID_TAG_LENGTH(env);
        return false;
      }
   ...",376.0,414.0,1.0,1.0,39.0,17,7,19,9,0,0,8,10,0,0,,0,0,10,5,5,bool
1323,18962,ValidateAdditionalData,1,node.crypto.anonymous_namespace_12.ValidateAdditionalData,"bool node.crypto.anonymous_namespace_12.ValidateAdditionalData (Environment*,CryptoJobMode,Local<Value>,AESCipherConfig*)",crypto\crypto_aes.cc,"bool ValidateAdditionalData(
    Environment* env,
    CryptoJobMode mode,
    Local<Value> value,
    AESCipherConfig* params) {
  // Additional Data
  if (IsAnyByteSource(value)) {
    ArrayBufferOrViewContents<char> additional(value);
    if (UNLIKELY(!additional.CheckSizeInt32())) {
      THROW_ERR_OUT_OF_RANGE(env, ""additionalData is too big"");
      return false;
    }
    params->additional_data = mode == kCryptoJobAsync
        ? additional.ToCopy()
        : additional.ToByteSource();
  }
  return true;
}",416.0,433.0,1.0,1.0,18.0,8,6,9,6,0,0,3,4,0,0,,0,0,8,4,4,bool
1324,19008,UseDefaultIV,1,node.crypto.anonymous_namespace_13.UseDefaultIV,void node.crypto.anonymous_namespace_13.UseDefaultIV (AESCipherConfig*),crypto\crypto_aes.cc,"void UseDefaultIV(AESCipherConfig* params) {
  params->iv = ByteSource::Foreign(kDefaultWrapIV, strlen(kDefaultWrapIV));
}",435.0,437.0,1.0,1.0,3.0,3,3,4,3,0,0,1,1,0,0,,0,0,2,1,1,void
1325,19024,AESCipherConfig,1,node.crypto.AESCipherConfig.AESCipherConfig,ANY node.crypto.AESCipherConfig.AESCipherConfig (AESCipherConfig),crypto\crypto_aes.cc,"AESCipherConfig::AESCipherConfig(AESCipherConfig&& other) noexcept
    : mode(other.mode),
      variant(other.variant),
      cipher(other.cipher),
      length(other.length),
      iv(std::move(other.iv)),
      additional_data(std::move(other.additional_data)),
      tag(std::move(other.tag)) {}",440.0,447.0,1.0,34.0,8.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
1326,19029,operator =,1,node.crypto.AESCipherConfig.operator =,AESCipherConfig node.crypto.AESCipherConfig.operator = (AESCipherConfig),crypto\crypto_aes.cc,"AESCipherConfig& AESCipherConfig::operator=(AESCipherConfig&& other) noexcept {
  if (&other == this) return *this;
  this->~AESCipherConfig();
  return *new (this) AESCipherConfig(std::move(other));
}",449.0,453.0,1.0,1.0,5.0,7,6,4,3,0,0,2,2,0,0,,0,0,2,1,1,AESCipherConfig
1327,19057,MemoryInfo,1,node.crypto.AESCipherConfig.MemoryInfo,void node.crypto.AESCipherConfig.MemoryInfo (MemoryTracker*),crypto\crypto_aes.cc,"void AESCipherConfig::MemoryInfo(MemoryTracker* tracker) const {
  // If mode is sync, then the data in each of these properties
  // is not owned by the AESCipherConfig, so we ignore it.
  if (mode == kCryptoJobAsync) {
    tracker->TrackFieldWithSize(""iv"", iv.size());
    tracker->TrackFieldWithSize(""additional_data"", additional_data.size());
    tracker->TrackFieldWithSize(""tag"", tag.size());
  }
}",455.0,463.0,1.0,1.0,9.0,7,3,8,6,0,0,2,2,0,0,,0,0,2,1,1,void
1328,19094,AdditionalConfig,1,node.crypto.AESCipherTraits.AdditionalConfig,"Maybe<bool> node.crypto.AESCipherTraits.AdditionalConfig (CryptoJobMode,FunctionCallbackInfo<Value>,unsigned int,WebCryptoCipherMode,AESCipherConfig*)",crypto\crypto_aes.cc,"Maybe<bool> AESCipherTraits::AdditionalConfig(
    CryptoJobMode mode,
    const FunctionCallbackInfo<Value>& args,
    unsigned int offset,
    WebCryptoCipherMode cipher_mode,
    AESCipherConfig* params) {
  Environment* env = Environment::GetCurrent(args);

  params->mode = mode;

  CHECK(args[offset]->IsUint32());  // Key Variant
  params->variant =
      static_cast<AESKeyVariant>(args[offset].As<Uint32>()->Value());

  int cipher_nid;

  switch (params->variant) {
    case kKeyVariantAES_CTR_128:
      if (!ValidateIV(env, mode, args[offset + 1], params) ||
          !ValidateCounter(env, args[offset + 2], params)) {
        return Nothing<bool>();
      }
      cipher_nid = NID_aes_128_ctr;
      break;
    case kKeyVariantAES_CTR_192:
      if (!ValidateIV(env, mode, args[offset + 1], params) ||
          !ValidateCounter(env, args[offset + 2], params)) {
        return Nothing<bool>();
      }
      cipher_nid = NID_aes_192_ctr;
      break;
    case kKeyVariantAES_CTR_256...",465.0,571.0,1.0,1.0,107.0,97,10,147,32,0,0,25,22,0,0,,0,0,10,5,5,Maybe<bool>
1329,19488,DoCipher,1,node.crypto.AESCipherTraits.DoCipher,"WebCryptoCipherStatus node.crypto.AESCipherTraits.DoCipher (Environment*,ANY,WebCryptoCipherMode,AESCipherConfig,ByteSource,ByteSource*)",crypto\crypto_aes.cc,"WebCryptoCipherStatus AESCipherTraits::DoCipher(
    Environment* env,
    std::shared_ptr<KeyObjectData> key_data,
    WebCryptoCipherMode cipher_mode,
    const AESCipherConfig& params,
    const ByteSource& in,
    ByteSource* out) {
#define V(name, fn)                                                           \
  case kKeyVariantAES_ ## name:                                               \
    return fn(env, key_data.get(), cipher_mode, params, in, out);
  switch (params.variant) {
    VARIANTS(V)
    default:
      UNREACHABLE();
  }
#undef V
}",573.0,589.0,1.0,1.0,17.0,1,1,1,1,0,0,2,2,0,0,,0,0,12,6,6,WebCryptoCipherStatus
1330,19507,Initialize,1,node.crypto.AES.Initialize,"void node.crypto.AES.Initialize (Environment*,Local<Object>)",crypto\crypto_aes.cc,"void AES::Initialize(Environment* env, Local<Object> target) {
  AESCryptoJob::Initialize(env, target);

#define V(name, _) NODE_DEFINE_CONSTANT(target, kKeyVariantAES_ ## name);
  VARIANTS(V)
#undef V
}",591.0,597.0,1.0,1.0,7.0,1,1,3,3,0,0,1,1,0,0,,0,0,4,2,2,void
1331,19521,RegisterExternalReferences,1,node.crypto.AES.RegisterExternalReferences,void node.crypto.AES.RegisterExternalReferences (ExternalReferenceRegistry*),crypto\crypto_aes.cc,"void AES::RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  AESCryptoJob::RegisterExternalReferences(registry);
}",599.0,601.0,1.0,1.0,3.0,1,1,2,2,0,0,1,1,0,0,,0,0,2,1,1,void
1332,19547,<lambda>0,1,node.crypto.NodeBIO.GetMethod.<lambda>0,ANY node.crypto.NodeBIO.GetMethod.<lambda>0 (),crypto\crypto_bio.cc,"[&]() {
    BIO_METHOD* method = BIO_meth_new(BIO_TYPE_MEM, ""node.js SSL buffer"");
    BIO_meth_set_write(method, Write);
    BIO_meth_set_read(method, Read);
    BIO_meth_set_puts(method, Puts);
    BIO_meth_set_gets(method, Gets);
    BIO_meth_set_ctrl(method, Ctrl);
    BIO_meth_set_create(method, New);
    BIO_meth_set_destroy(method, Free);
    return method;
  }",224.0,234.0,37.0,3.0,11.0,1,1,17,9,1,0,1,1,0,0,,0,0,0,0,0,ANY
1333,19601,New,1,node.crypto.NodeBIO.New,BIOPointer node.crypto.NodeBIO.New (Environment*),crypto\crypto_bio.cc,"int NodeBIO::New(BIO* bio) {
  BIO_set_data(bio, new NodeBIO());
  BIO_set_init(bio, 1);

  return 1;
}",57.0,62.0,1.0,1.0,6.0,6,5,6,3,0,0,2,2,0,0,,0,0,2,1,1,int
1334,19604,bio,1,node.crypto.NodeBIO.New.bio,BIOPointer node.crypto.NodeBIO.New.bio (BIO_new),crypto\crypto_bio.cc,BIOPointer bio(BIO_new(GetMethod()));,36.0,36.0,14.0,38.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,BIOPointer
1335,19632,NewFixed,1,node.crypto.NodeBIO.NewFixed,"BIOPointer node.crypto.NodeBIO.NewFixed (char*,size_t,Environment*)",crypto\crypto_bio.cc,"BIOPointer NodeBIO::NewFixed(const char* data, size_t len, Environment* env) {
  BIOPointer bio = New(env);

  if (!bio ||
      len > INT_MAX ||
      BIO_write(bio.get(), data, len) != static_cast<int>(len) ||
      BIO_set_mem_eof_return(bio.get(), 0) != 1) {
    return BIOPointer();
  }

  return bio;
}",43.0,54.0,1.0,1.0,12.0,11,7,11,5,0,0,2,2,0,0,,0,0,6,3,3,BIOPointer
1336,19691,Free,1,node.crypto.NodeBIO.Free,int node.crypto.NodeBIO.Free (BIO*),crypto\crypto_bio.cc,"int NodeBIO::Free(BIO* bio) {
  if (bio == nullptr)
    return 0;

  if (BIO_get_shutdown(bio)) {
    if (BIO_get_init(bio) && BIO_get_data(bio) != nullptr) {
      delete FromBIO(bio);
      BIO_set_data(bio, nullptr);
    }
  }

  return 1;
}",65.0,77.0,1.0,1.0,13.0,4,4,6,1,0,0,4,5,0,0,,0,0,2,1,1,int
1337,19724,Read,1,node.crypto.NodeBIO.Read,"int node.crypto.NodeBIO.Read (BIO*,char*,int)",crypto\crypto_bio.cc,"size_t NodeBIO::Read(char* out, size_t size) {
  size_t bytes_read = 0;
  size_t expected = Length() > size ? size : Length();
  size_t offset = 0;
  size_t left = size;

  while (bytes_read < expected) {
    CHECK_LE(read_head_->read_pos_, read_head_->write_pos_);
    size_t avail = read_head_->write_pos_ - read_head_->read_pos_;
    if (avail > left)
      avail = left;

    // Copy data
    if (out != nullptr)
      memcpy(out + offset, read_head_->data_ + read_head_->read_pos_, avail);
    read_head_->read_pos_ += avail;

    // Move pointers
    bytes_read += avail;
    offset += avail;
    left -= avail;

    TryMoveReadHead();
  }
  CHECK_EQ(expected, bytes_read);
  length_ -= bytes_read;

  // Free all empty buffers, but write_head's child
  FreeEmpty();

  return bytes_read;
}",259.0,290.0,1.0,1.0,32.0,7,4,13,5,0,0,3,4,0,0,,0,0,4,2,2,size_t
1338,19767,Peek,1,node.crypto.NodeBIO.Peek,char* node.crypto.NodeBIO.Peek (size_t*),crypto\crypto_bio.cc,"char* NodeBIO::Peek(size_t* size) {
  *size = read_head_->write_pos_ - read_head_->read_pos_;
  return read_head_->data_ + read_head_->read_pos_;
}",97.0,100.0,1.0,1.0,4.0,8,5,5,2,0,0,1,1,0,0,,0,0,2,1,1,char*
1339,19790,PeekMultiple,1,node.crypto.NodeBIO.PeekMultiple,"size_t node.crypto.NodeBIO.PeekMultiple (char**,size_t*,size_t*)",crypto\crypto_bio.cc,"size_t NodeBIO::PeekMultiple(char** out, size_t* size, size_t* count) {
  Buffer* pos = read_head_;
  size_t max = *count;
  size_t total = 0;

  size_t i;
  for (i = 0; i < max; i++) {
    size[i] = pos->write_pos_ - pos->read_pos_;
    total += size[i];
    out[i] = pos->data_ + pos->read_pos_;

    /* Don't get past write head */
    if (pos == write_head_)
      break;
    else
      pos = pos->next_;
  }

  if (i == max)
    *count = i;
  else
    *count = i + 1;

  return total;
}",103.0,127.0,1.0,1.0,25.0,22,9,26,9,0,0,5,5,0,0,,0,0,6,3,3,size_t
1340,19881,Write,1,node.crypto.NodeBIO.Write,"int node.crypto.NodeBIO.Write (BIO*,char*,int)",crypto\crypto_bio.cc,"void NodeBIO::Write(const char* data, size_t size) {
  size_t offset = 0;
  size_t left = size;

  // Allocate initial buffer if the ring is empty
  TryAllocateForWrite(left);

  while (left > 0) {
    size_t to_write = left;
    CHECK_LE(write_head_->write_pos_, write_head_->len_);
    size_t avail = write_head_->len_ - write_head_->write_pos_;

    if (to_write > avail)
      to_write = avail;

    // Copy data
    memcpy(write_head_->data_ + write_head_->write_pos_,
           data + offset,
           to_write);

    // Move pointers
    left -= to_write;
    offset += to_write;
    length_ += to_write;
    write_head_->write_pos_ += to_write;
    CHECK_LE(write_head_->write_pos_, write_head_->len_);

    // Go to next buffer if there still are some bytes to write
    if (left != 0) {
      CHECK_EQ(write_head_->write_pos_, write_head_->len_);
      TryAllocateForWrite(left);
      write_head_ = write_head_->next_;

      // Additionally, since we're moved to the next buffer, re...",356.0,395.0,1.0,1.0,40.0,1,1,5,3,0,0,1,1,0,0,,0,0,4,2,2,void
1341,19899,Puts,1,node.crypto.NodeBIO.Puts,"int node.crypto.NodeBIO.Puts (BIO*,char*)",crypto\crypto_bio.cc,"int NodeBIO::Puts(BIO* bio, const char* str) {
  return Write(bio, str, strlen(str));
}",139.0,141.0,1.0,1.0,3.0,0,0,3,2,0,0,1,1,0,0,,0,0,4,2,2,int
1342,19911,Gets,1,node.crypto.NodeBIO.Gets,"int node.crypto.NodeBIO.Gets (BIO*,char*,int)",crypto\crypto_bio.cc,"int NodeBIO::Gets(BIO* bio, char* out, int size) {
  NodeBIO* nbio = FromBIO(bio);

  if (nbio->Length() == 0)
    return 0;

  int i = nbio->IndexOf('\n', size);

  // Include '\n', if it's there.  If not, don't read off the end.
  if (i < size && i >= 0 && static_cast<size_t>(i) < nbio->Length())
    i++;

  // Shift `i` a bit to nullptr-terminate string later
  if (size == i)
    i--;

  // Flush read data
  nbio->Read(out, i);

  out[i] = 0;

  return i;
}",144.0,166.0,1.0,1.0,23.0,18,10,21,5,0,0,4,4,0,0,,0,0,6,3,3,int
1343,19982,Ctrl,1,node.crypto.NodeBIO.Ctrl,"long node.crypto.NodeBIO.Ctrl (BIO*,int,long,void*)",crypto\crypto_bio.cc,"long NodeBIO::Ctrl(BIO* bio, int cmd, long num,  // NOLINT(runtime/int)
                   void* ptr) {
  NodeBIO* nbio;
  long ret;  // NOLINT(runtime/int)

  nbio = FromBIO(bio);
  ret = 1;

  switch (cmd) {
    case BIO_CTRL_RESET:
      nbio->Reset();
      break;
    case BIO_CTRL_EOF:
      ret = nbio->Length() == 0;
      break;
    case BIO_C_SET_BUF_MEM_EOF_RETURN:
      nbio->set_eof_return(num);
      break;
    case BIO_CTRL_INFO:
      ret = nbio->Length();
      if (ptr != nullptr)
        *reinterpret_cast<void**>(ptr) = nullptr;
      break;
    case BIO_C_SET_BUF_MEM:
      UNREACHABLE(""Can't use SET_BUF_MEM_PTR with NodeBIO"");
    case BIO_C_GET_BUF_MEM_PTR:
      UNREACHABLE(""Can't use GET_BUF_MEM_PTR with NodeBIO"");
    case BIO_CTRL_GET_CLOSE:
      ret = BIO_get_shutdown(bio);
      break;
    case BIO_CTRL_SET_CLOSE:
      BIO_set_shutdown(bio, num);
      break;
    case BIO_CTRL_WPENDING:
      ret = 0;
      break;
    case BIO_CTRL_PENDING:
      ret = nbi...",169.0,219.0,1.0,1.0,51.0,19,6,37,20,0,0,13,4,0,0,,0,0,8,4,4,long
1344,20103,GetMethod,1,node.crypto.NodeBIO.GetMethod,BIO_METHOD node.crypto.NodeBIO.GetMethod (),crypto\crypto_bio.cc,"const BIO_METHOD* NodeBIO::GetMethod() {
  // Static initialization ensures that this is safe to use concurrently.
  static const BIO_METHOD* method = [&]() {
    BIO_METHOD* method = BIO_meth_new(BIO_TYPE_MEM, ""node.js SSL buffer"");
    BIO_meth_set_write(method, Write);
    BIO_meth_set_read(method, Read);
    BIO_meth_set_puts(method, Puts);
    BIO_meth_set_gets(method, Gets);
    BIO_meth_set_ctrl(method, Ctrl);
    BIO_meth_set_create(method, New);
    BIO_meth_set_destroy(method, Free);
    return method;
  }();

  return method;
}",222.0,237.0,1.0,1.0,16.0,1,1,2,1,0,1,1,1,0,0,,0,1,0,0,0,BIO_METHOD
1345,20114,TryMoveReadHead,1,node.crypto.NodeBIO.TryMoveReadHead,void node.crypto.NodeBIO.TryMoveReadHead (),crypto\crypto_bio.cc,"void NodeBIO::TryMoveReadHead() {
  // `read_pos_` and `write_pos_` means the position of the reader and writer
  // inside the buffer, respectively. When they're equal - its safe to reset
  // them, because both reader and writer will continue doing their stuff
  // from new (zero) positions.
  while (read_head_->read_pos_ != 0 &&
         read_head_->read_pos_ == read_head_->write_pos_) {
    // Reset positions
    read_head_->read_pos_ = 0;
    read_head_->write_pos_ = 0;

    // Move read_head_ forward, just in case if there're still some data to
    // read in the next buffer.
    if (read_head_ != write_head_)
      read_head_ = read_head_->next_;
  }
}",240.0,256.0,1.0,1.0,17.0,13,5,9,2,0,0,3,4,0,0,,0,0,0,0,0,void
1346,20251,FreeEmpty,1,node.crypto.NodeBIO.FreeEmpty,void node.crypto.NodeBIO.FreeEmpty (),crypto\crypto_bio.cc,"void NodeBIO::FreeEmpty() {
  if (write_head_ == nullptr)
    return;
  Buffer* child = write_head_->next_;
  if (child == write_head_ || child == read_head_)
    return;
  Buffer* cur = child->next_;
  if (cur == write_head_ || cur == read_head_)
    return;

  Buffer* prev = child;
  while (cur != read_head_) {
    CHECK_NE(cur, write_head_);
    CHECK_EQ(cur->write_pos_, cur->read_pos_);

    Buffer* next = cur->next_;
    delete cur;
    cur = next;
  }
  prev->next_ = cur;
}",293.0,313.0,1.0,1.0,21.0,21,6,28,6,0,0,5,5,0,0,,0,0,0,0,0,void
1347,20328,IndexOf,1,node.crypto.NodeBIO.IndexOf,"size_t node.crypto.NodeBIO.IndexOf (char,size_t)",crypto\crypto_bio.cc,"size_t NodeBIO::IndexOf(char delim, size_t limit) {
  size_t bytes_read = 0;
  size_t max = Length() > limit ? limit : Length();
  size_t left = limit;
  Buffer* current = read_head_;

  while (bytes_read < max) {
    CHECK_LE(current->read_pos_, current->write_pos_);
    size_t avail = current->write_pos_ - current->read_pos_;
    if (avail > left)
      avail = left;

    // Walk through data
    char* tmp = current->data_ + current->read_pos_;
    size_t off = 0;
    while (off < avail && *tmp != delim) {
      off++;
      tmp++;
    }

    // Move pointers
    bytes_read += off;
    left -= off;

    // Found `delim`
    if (off != avail) {
      return bytes_read;
    }

    // Move to next buffer
    if (current->read_pos_ + avail == current->len_) {
      current = current->next_;
    }
  }
  CHECK_EQ(max, bytes_read);

  return max;
}",316.0,353.0,1.0,1.0,38.0,35,14,44,10,0,0,6,10,0,0,,0,0,4,2,2,size_t
1348,20553,PeekWritable,1,node.crypto.NodeBIO.PeekWritable,char* node.crypto.NodeBIO.PeekWritable (size_t*),crypto\crypto_bio.cc,"char* NodeBIO::PeekWritable(size_t* size) {
  TryAllocateForWrite(*size);

  size_t available = write_head_->len_ - write_head_->write_pos_;
  if (*size == 0 || available <= *size)
    *size = available;

  return write_head_->data_ + write_head_->write_pos_;
}",398.0,406.0,1.0,1.0,9.0,15,8,11,3,0,0,2,2,0,0,,0,0,2,1,1,char*
1349,20594,Commit,1,node.crypto.NodeBIO.Commit,void node.crypto.NodeBIO.Commit (size_t),crypto\crypto_bio.cc,"void NodeBIO::Commit(size_t size) {
  write_head_->write_pos_ += size;
  length_ += size;
  CHECK_LE(write_head_->write_pos_, write_head_->len_);

  // Allocate new buffer if write head is full,
  // and there're no other place to go
  TryAllocateForWrite(0);
  if (write_head_->write_pos_ == write_head_->len_) {
    write_head_ = write_head_->next_;

    // Additionally, since we're moved to the next buffer, read head
    // may be moved as well.
    TryMoveReadHead();
  }
}",409.0,424.0,1.0,1.0,16.0,10,4,10,3,0,0,2,2,0,0,,0,0,2,1,1,void
1350,20631,TryAllocateForWrite,1,node.crypto.NodeBIO.TryAllocateForWrite,void node.crypto.NodeBIO.TryAllocateForWrite (size_t),crypto\crypto_bio.cc,"void NodeBIO::TryAllocateForWrite(size_t hint) {
  Buffer* w = write_head_;
  Buffer* r = read_head_;
  // If write head is full, next buffer is either read head or not empty.
  if (w == nullptr ||
      (w->write_pos_ == w->len_ &&
       (w->next_ == r || w->next_->write_pos_ != 0))) {
    size_t len = w == nullptr ? initial_ :
                             kThroughputBufferLength;
    if (len < hint)
      len = hint;

    // If there is a one time allocation size hint, use it.
    if (allocate_hint_ > len) {
      len = allocate_hint_;
      allocate_hint_ = 0;
    }

    Buffer* next = new Buffer(env_, len);

    if (w == nullptr) {
      next->next_ = next;
      write_head_ = next;
      read_head_ = next;
    } else {
      next->next_ = w->next_;
      w->next_ = next;
    }
  }
}",427.0,456.0,1.0,1.0,30.0,29,10,34,12,0,0,5,8,0,0,,0,0,2,1,1,void
1351,20736,Reset,1,node.crypto.NodeBIO.Reset,void node.crypto.NodeBIO.Reset (),crypto\crypto_bio.cc,"void NodeBIO::Reset() {
  if (read_head_ == nullptr)
    return;

  while (read_head_->read_pos_ != read_head_->write_pos_) {
    CHECK(read_head_->write_pos_ > read_head_->read_pos_);

    length_ -= read_head_->write_pos_ - read_head_->read_pos_;
    read_head_->write_pos_ = 0;
    read_head_->read_pos_ = 0;

    read_head_ = read_head_->next_;
  }
  write_head_ = read_head_;
  CHECK_EQ(length_, 0);
}",459.0,474.0,1.0,1.0,16.0,18,7,15,3,0,0,3,3,0,0,,0,0,0,0,0,void
1352,20793,~NodeBIO,1,node.crypto.NodeBIO.~NodeBIO,ANY node.crypto.NodeBIO.~NodeBIO (),crypto\crypto_bio.cc,"NodeBIO::~NodeBIO() {
  if (read_head_ == nullptr)
    return;

  Buffer* current = read_head_;
  do {
    Buffer* next = current->next_;
    delete current;
    current = next;
  } while (current != read_head_);

  read_head_ = nullptr;
  write_head_ = nullptr;
}",477.0,490.0,1.0,1.0,14.0,9,5,12,4,0,0,3,3,0,0,,0,0,0,0,0,ANY
1353,20829,FromBIO,1,node.crypto.NodeBIO.FromBIO,NodeBIO node.crypto.NodeBIO.FromBIO (BIO*),crypto\crypto_bio.cc,"NodeBIO* NodeBIO::FromBIO(BIO* bio) {
  CHECK_NOT_NULL(BIO_get_data(bio));
  return static_cast<NodeBIO*>(BIO_get_data(bio));
}",493.0,496.0,1.0,1.0,4.0,1,1,2,1,0,0,1,1,0,0,,0,0,2,1,1,NodeBIO
1354,20856,<lambda>0,1,"args, [](CipherBase* cipher, const FunctionCallbackInfo<Value>& args, const char* data, size_t size) { std.unique_ptr<BackingStore> out; Environment* env = Environment.GetCurrent(args); if (UNLIKELY(size > INT_MAX)) return THROW_ERR_OUT_OF_RANGE(env, ""data is too long""); UpdateResult r = cipher->Update(data, size, &out); if (r != kSuccess) { if (r == kErrorState) { ThrowCryptoError(env, ERR_get_error(), ""Trying to add data in unsupported state""); } return; } Local<ArrayBuffer> ab = ArrayBuffer.New(env->isolate(), std.move(out)); args.GetReturnValue().Set( Buffer.New(env, ab, 0, ab->ByteLength()).FromMaybe(Local<Value>())); }.<lambda>0","ANY args, [](CipherBase* cipher, const FunctionCallbackInfo<Value>& args, const char* data, size_t size) { std.unique_ptr<BackingStore> out; Environment* env = Environment.GetCurrent(args); if (UNLIKELY(size > INT_MAX)) return THROW_ERR_OUT_OF_RANGE(env, ""data is too long""); UpdateResult r = cipher->Update(data, size, &out); if (r != kSuccess) { if (r == kErrorState) { ThrowCryptoError(env, ERR_get_error(), ""Trying to add data in unsupported state""); } return; } Local<ArrayBuffer> ab = ArrayBuffer.New(env->isolate(), std.move(out)); args.GetReturnValue().Set( Buffer.New(env, ab, 0, ab->ByteLength()).FromMaybe(Local<Value>())); }.<lambda>0 (CipherBase*,FunctionCallbackInfo<Value>,char*,size_t)",crypto\crypto_cipher.cc,"[](CipherBase* cipher,
                              const FunctionCallbackInfo<Value>& args,
                              const char* data, size_t size) {
    std::unique_ptr<BackingStore> out;
    Environment* env = Environment::GetCurrent(args);

    if (UNLIKELY(size > INT_MAX))
      return THROW_ERR_OUT_OF_RANGE(env, ""data is too long"");

    UpdateResult r = cipher->Update(data, size, &out);

    if (r != kSuccess) {
      if (r == kErrorState) {
        ThrowCryptoError(env, ERR_get_error(),
                         ""Trying to add data in unsupported state"");
      }
      return;
    }

    Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(out));
    args.GetReturnValue().Set(
        Buffer::New(env, ab, 0, ab->ByteLength()).FromMaybe(Local<Value>()));
  }",847.0,869.0,28.0,3.0,23.0,22,8,31,17,0,0,4,5,0,0,,0,0,8,4,4,ANY
1355,20983,IsSupportedAuthenticatedMode,1,node.crypto.anonymous_namespace_1.IsSupportedAuthenticatedMode,bool node.crypto.anonymous_namespace_1.IsSupportedAuthenticatedMode (EVP_CIPHER*),crypto\crypto_cipher.cc,"bool IsSupportedAuthenticatedMode(const EVP_CIPHER* cipher) {
  switch (EVP_CIPHER_mode(cipher)) {
  case EVP_CIPH_CCM_MODE:
  case EVP_CIPH_GCM_MODE:
#ifndef OPENSSL_NO_OCB
  case EVP_CIPH_OCB_MODE:
#endif
    return true;
  case EVP_CIPH_STREAM_CIPHER:
    return EVP_CIPHER_nid(cipher) == NID_chacha20_poly1305;
  default:
    return false;
  }
}",29.0,42.0,1.0,1.0,14.0,1,1,7,6,0,0,2,2,0,0,,0,0,2,1,1,bool
1356,21010,IsSupportedAuthenticatedMode,1,node.crypto.anonymous_namespace_2.IsSupportedAuthenticatedMode,bool node.crypto.anonymous_namespace_2.IsSupportedAuthenticatedMode (EVP_CIPHER_CTX*),crypto\crypto_cipher.cc,"bool IsSupportedAuthenticatedMode(const EVP_CIPHER_CTX* ctx) {
  const EVP_CIPHER* cipher = EVP_CIPHER_CTX_cipher(ctx);
  return IsSupportedAuthenticatedMode(cipher);
}",44.0,47.0,1.0,1.0,4.0,1,1,3,2,0,0,1,1,0,0,,0,0,2,1,1,bool
1357,21023,IsValidGCMTagLength,1,node.crypto.anonymous_namespace_4.IsValidGCMTagLength,bool node.crypto.anonymous_namespace_4.IsValidGCMTagLength (unsigned int),crypto\crypto_cipher.cc,"bool IsValidGCMTagLength(unsigned int tag_len) {
  return tag_len == 4 || tag_len == 8 || (tag_len >= 12 && tag_len <= 16);
}",49.0,51.0,1.0,1.0,3.0,7,5,4,1,0,0,1,1,0,0,,0,0,2,1,1,bool
1358,21044,GetCipherInfo,1,node.crypto.anonymous_namespace_5.GetCipherInfo,void node.crypto.anonymous_namespace_5.GetCipherInfo (FunctionCallbackInfo<Value>),crypto\crypto_cipher.cc,"void GetCipherInfo(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  CHECK(args[0]->IsObject());
  Local<Object> info = args[0].As<Object>();

  CHECK(args[1]->IsString() || args[1]->IsInt32());

  const EVP_CIPHER* cipher;
  if (args[1]->IsString()) {
    Utf8Value name(env->isolate(), args[1]);
    cipher = EVP_get_cipherbyname(*name);
  } else {
    int nid = args[1].As<Int32>()->Value();
    cipher = EVP_get_cipherbynid(nid);
  }

  if (cipher == nullptr)
    return;

  int mode = EVP_CIPHER_mode(cipher);
  int iv_length = EVP_CIPHER_iv_length(cipher);
  int key_length = EVP_CIPHER_key_length(cipher);
  int block_length = EVP_CIPHER_block_size(cipher);
  const char* mode_label = nullptr;
  switch (mode) {
    case EVP_CIPH_CBC_MODE: mode_label = ""cbc""; break;
    case EVP_CIPH_CCM_MODE: mode_label = ""ccm""; break;
    case EVP_CIPH_CFB_MODE: mode_label = ""cfb""; break;
    case EVP_CIPH_CTR_MODE: mode_label = ""ctr""; break;
    case EV...",54.0,194.0,1.0,1.0,141.0,108,12,115,28,0,0,32,35,0,0,,0,0,2,1,1,void
1359,21547,GetSSLCiphers,1,node.crypto.CipherBase.GetSSLCiphers,void node.crypto.CipherBase.GetSSLCiphers (FunctionCallbackInfo<Value>),crypto\crypto_cipher.cc,"void CipherBase::GetSSLCiphers(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  SSLCtxPointer ctx(SSL_CTX_new(TLS_method()));
  if (!ctx) {
    return ThrowCryptoError(env, ERR_get_error(), ""SSL_CTX_new"");
  }

  SSLPointer ssl(SSL_new(ctx.get()));
  if (!ssl) {
    return ThrowCryptoError(env, ERR_get_error(), ""SSL_new"");
  }

  STACK_OF(SSL_CIPHER)* ciphers = SSL_get_ciphers(ssl.get());

  // TLSv1.3 ciphers aren't listed by EVP. There are only 5, we could just
  // document them, but since there are only 5, easier to just add them manually
  // and not have to explain their absence in the API docs. They are lower-cased
  // because the docs say they will be.
  static const char* TLS13_CIPHERS[] = {
    ""tls_aes_256_gcm_sha384"",
    ""tls_chacha20_poly1305_sha256"",
    ""tls_aes_128_gcm_sha256"",
    ""tls_aes_128_ccm_8_sha256"",
    ""tls_aes_128_ccm_sha256""
  };

  const int n = sk_SSL_CIPHER_num(ciphers);
  std::vector<Local<Value>> ar...",197.0,238.0,1.0,1.0,42.0,36,10,45,17,0,0,5,5,0,0,,0,0,2,1,1,void
1360,21558,ctx,1,node.crypto.CipherBase.GetSSLCiphers.ctx,SSLCtxPointer node.crypto.CipherBase.GetSSLCiphers.ctx (SSL_CTX_new),crypto\crypto_cipher.cc,SSLCtxPointer ctx(SSL_CTX_new(TLS_method()));,200.0,200.0,17.0,46.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,SSLCtxPointer
1361,21710,GetCiphers,1,node.crypto.CipherBase.GetCiphers,void node.crypto.CipherBase.GetCiphers (FunctionCallbackInfo<Value>),crypto\crypto_cipher.cc,"void CipherBase::GetCiphers(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  MarkPopErrorOnReturn mark_pop_error_on_return;
  CipherPushContext ctx(env);
  EVP_CIPHER_do_all_sorted(
#if OPENSSL_VERSION_MAJOR >= 3
    array_push_back<EVP_CIPHER,
                    EVP_CIPHER_fetch,
                    EVP_CIPHER_free,
                    EVP_get_cipherbyname,
                    EVP_CIPHER_get0_name>,
#else
    array_push_back<EVP_CIPHER>,
#endif
    &ctx);
  args.GetReturnValue().Set(ctx.ToJSArray());
}",240.0,256.0,1.0,1.0,17.0,6,3,8,5,0,0,1,1,0,0,,0,0,2,1,1,void
1362,21742,CipherBase,1,node.crypto.CipherBase.CipherBase,"ANY node.crypto.CipherBase.CipherBase (Environment*,Local<Object>,CipherKind)",crypto\crypto_cipher.cc,"CipherBase::CipherBase(Environment* env,
                       Local<Object> wrap,
                       CipherKind kind)
    : BaseObject(env, wrap),
      ctx_(nullptr),
      kind_(kind),
      auth_tag_state_(kAuthTagUnknown),
      auth_tag_len_(kNoAuthTagLength),
      pending_auth_failed_(false) {
  MakeWeak();
}",258.0,268.0,1.0,1.0,11.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,ANY
1363,21750,MemoryInfo,1,node.crypto.CipherBase.MemoryInfo,void node.crypto.CipherBase.MemoryInfo (MemoryTracker*),crypto\crypto_cipher.cc,"void CipherBase::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackFieldWithSize(""context"", ctx_ ? kSizeOf_EVP_CIPHER_CTX : 0);
}",270.0,272.0,1.0,1.0,3.0,2,2,3,3,0,0,1,1,0,0,,0,0,2,1,1,void
1364,21764,Initialize,1,node.crypto.CipherBase.Initialize,"void node.crypto.CipherBase.Initialize (Environment*,Local<Object>)",crypto\crypto_cipher.cc,"void CipherBase::Initialize(Environment* env, Local<Object> target) {
  Isolate* isolate = env->isolate();
  Local<Context> context = env->context();

  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, New);

  t->InstanceTemplate()->SetInternalFieldCount(CipherBase::kInternalFieldCount);

  SetProtoMethod(isolate, t, ""init"", Init);
  SetProtoMethod(isolate, t, ""initiv"", InitIv);
  SetProtoMethod(isolate, t, ""update"", Update);
  SetProtoMethod(isolate, t, ""final"", Final);
  SetProtoMethod(isolate, t, ""setAutoPadding"", SetAutoPadding);
  SetProtoMethodNoSideEffect(isolate, t, ""getAuthTag"", GetAuthTag);
  SetProtoMethod(isolate, t, ""setAuthTag"", SetAuthTag);
  SetProtoMethod(isolate, t, ""setAAD"", SetAAD);
  SetConstructorFunction(context, target, ""CipherBase"", t);

  SetMethodNoSideEffect(context, target, ""getSSLCiphers"", GetSSLCiphers);
  SetMethodNoSideEffect(context, target, ""getCiphers"", GetCiphers);

  SetMethod(context,
            target,
            ""publicEncrypt"",
  ...",274.0,324.0,1.0,2.0,51.0,82,7,123,29,0,0,1,1,0,0,,0,0,4,2,2,void
1365,22092,RegisterExternalReferences,1,node.crypto.CipherBase.RegisterExternalReferences,void node.crypto.CipherBase.RegisterExternalReferences (ExternalReferenceRegistry*),crypto\crypto_cipher.cc,"void CipherBase::RegisterExternalReferences(
    ExternalReferenceRegistry* registry) {
  registry->Register(New);

  registry->Register(Init);
  registry->Register(InitIv);
  registry->Register(Update);
  registry->Register(Final);
  registry->Register(SetAutoPadding);
  registry->Register(GetAuthTag);
  registry->Register(SetAuthTag);
  registry->Register(SetAAD);

  registry->Register(GetSSLCiphers);
  registry->Register(GetCiphers);

  registry->Register(PublicKeyCipher::Cipher<PublicKeyCipher::kPublic,
                                             EVP_PKEY_encrypt_init,
                                             EVP_PKEY_encrypt>);
  registry->Register(PublicKeyCipher::Cipher<PublicKeyCipher::kPrivate,
                                             EVP_PKEY_decrypt_init,
                                             EVP_PKEY_decrypt>);
  registry->Register(PublicKeyCipher::Cipher<PublicKeyCipher::kPrivate,
                                             EVP_PKEY_sign_init,
         ...",326.0,356.0,1.0,1.0,31.0,20,2,32,14,0,0,1,1,0,0,,0,0,2,1,1,void
1366,22185,New,1,node.crypto.CipherBase.New,void node.crypto.CipherBase.New (FunctionCallbackInfo<Value>),crypto\crypto_cipher.cc,"void CipherBase::New(const FunctionCallbackInfo<Value>& args) {
  CHECK(args.IsConstructCall());
  Environment* env = Environment::GetCurrent(args);
  new CipherBase(env, args.This(), args[0]->IsTrue() ? kCipher : kDecipher);
}",358.0,362.0,1.0,1.0,5.0,8,6,10,6,0,0,1,1,0,0,,0,0,2,1,1,void
1367,22219,CommonInit,1,node.crypto.CipherBase.CommonInit,"void node.crypto.CipherBase.CommonInit (char*,EVP_CIPHER*,unsigned char*,int,unsigned char*,int,unsigned int)",crypto\crypto_cipher.cc,"void CipherBase::CommonInit(const char* cipher_type,
                            const EVP_CIPHER* cipher,
                            const unsigned char* key,
                            int key_len,
                            const unsigned char* iv,
                            int iv_len,
                            unsigned int auth_tag_len) {
  CHECK(!ctx_);
  ctx_.reset(EVP_CIPHER_CTX_new());

  const int mode = EVP_CIPHER_mode(cipher);
  if (mode == EVP_CIPH_WRAP_MODE)
    EVP_CIPHER_CTX_set_flags(ctx_.get(), EVP_CIPHER_CTX_FLAG_WRAP_ALLOW);

  const bool encrypt = (kind_ == kCipher);
  if (1 != EVP_CipherInit_ex(ctx_.get(), cipher, nullptr,
                             nullptr, nullptr, encrypt)) {
    return ThrowCryptoError(env(), ERR_get_error(),
                            ""Failed to initialize cipher"");
  }

  if (IsSupportedAuthenticatedMode(cipher)) {
    CHECK_GE(iv_len, 0);
    if (!InitAuthenticated(cipher_type, iv_len, auth_tag_len))
      return;
  }

  if (!EV...",364.0,400.0,1.0,1.0,37.0,15,5,26,14,0,0,7,8,0,0,,0,0,14,7,7,void
1368,22329,Init,1,node.crypto.CipherBase.Init,"void node.crypto.CipherBase.Init (char*,ArrayBufferOrViewContents<unsigned char>,unsigned int)",crypto\crypto_cipher.cc,"void CipherBase::Init(const FunctionCallbackInfo<Value>& args) {
  CipherBase* cipher;
  ASSIGN_OR_RETURN_UNWRAP(&cipher, args.Holder());
  Environment* env = Environment::GetCurrent(args);

  CHECK_GE(args.Length(), 3);

  const Utf8Value cipher_type(args.GetIsolate(), args[0]);
  ArrayBufferOrViewContents<unsigned char> key_buf(args[1]);
  if (!key_buf.CheckSizeInt32())
    return THROW_ERR_OUT_OF_RANGE(env, ""password is too large"");

  // Don't assign to cipher->auth_tag_len_ directly; the value might not
  // represent a valid length at this point.
  unsigned int auth_tag_len;
  if (args[2]->IsUint32()) {
    auth_tag_len = args[2].As<Uint32>()->Value();
  } else {
    CHECK(args[2]->IsInt32() && args[2].As<Int32>()->Value() == -1);
    auth_tag_len = kNoAuthTagLength;
  }

  cipher->Init(*cipher_type, key_buf, auth_tag_len);
}",448.0,471.0,1.0,1.0,24.0,14,6,28,13,0,0,4,4,0,0,,0,0,2,1,1,void
1369,22526,InitIv,1,node.crypto.CipherBase.InitIv,"void node.crypto.CipherBase.InitIv (char*,ByteSource,ArrayBufferOrViewContents<unsigned char>,unsigned int)",crypto\crypto_cipher.cc,"void CipherBase::InitIv(const FunctionCallbackInfo<Value>& args) {
  CipherBase* cipher;
  ASSIGN_OR_RETURN_UNWRAP(&cipher, args.Holder());
  Environment* env = cipher->env();

  CHECK_GE(args.Length(), 4);

  const Utf8Value cipher_type(env->isolate(), args[0]);

  // The argument can either be a KeyObjectHandle or a byte source
  // (e.g. ArrayBuffer, TypedArray, etc). Whichever it is, grab the
  // raw bytes and proceed...
  const ByteSource key_buf = ByteSource::FromSecretKeyBytes(env, args[1]);

  if (UNLIKELY(key_buf.size() > INT_MAX))
    return THROW_ERR_OUT_OF_RANGE(env, ""key is too big"");

  ArrayBufferOrViewContents<unsigned char> iv_buf(
      !args[2]->IsNull() ? args[2] : Local<Value>());

  if (UNLIKELY(!iv_buf.CheckSizeInt32()))
    return THROW_ERR_OUT_OF_RANGE(env, ""iv is too big"");

  // Don't assign to cipher->auth_tag_len_ directly; the value might not
  // represent a valid length at this point.
  unsigned int auth_tag_len;
  if (args[3]->IsUint32()) {
    auth...",520.0,554.0,1.0,1.0,35.0,24,9,26,9,0,0,6,7,0,0,,0,0,2,1,1,void
1370,22780,InitAuthenticated,1,node.crypto.CipherBase.InitAuthenticated,"bool node.crypto.CipherBase.InitAuthenticated (char*,int,unsigned int)",crypto\crypto_cipher.cc,"bool CipherBase::InitAuthenticated(
    const char* cipher_type,
    int iv_len,
    unsigned int auth_tag_len) {
  CHECK(IsAuthenticatedMode());
  MarkPopErrorOnReturn mark_pop_error_on_return;

  if (!EVP_CIPHER_CTX_ctrl(ctx_.get(),
                           EVP_CTRL_AEAD_SET_IVLEN,
                           iv_len,
                           nullptr)) {
    THROW_ERR_CRYPTO_INVALID_IV(env());
    return false;
  }

  const int mode = EVP_CIPHER_CTX_mode(ctx_.get());
  if (mode == EVP_CIPH_GCM_MODE) {
    if (auth_tag_len != kNoAuthTagLength) {
      if (!IsValidGCMTagLength(auth_tag_len)) {
        THROW_ERR_CRYPTO_INVALID_AUTH_TAG(
          env(),
          ""Invalid authentication tag length: %u"",
          auth_tag_len);
        return false;
      }

      // Remember the given authentication tag length for later.
      auth_tag_len_ = auth_tag_len;
    }
  } else {
    if (auth_tag_len == kNoAuthTagLength) {
      // We treat ChaCha20-Poly1305 specially. Like GCM, the auth...",556.0,634.0,1.0,1.0,79.0,8,5,13,8,0,0,5,8,0,0,,0,0,6,3,3,bool
1371,22932,CheckCCMMessageLength,1,node.crypto.CipherBase.CheckCCMMessageLength,bool node.crypto.CipherBase.CheckCCMMessageLength (int),crypto\crypto_cipher.cc,"bool CipherBase::CheckCCMMessageLength(int message_len) {
  CHECK(ctx_);
  CHECK(EVP_CIPHER_CTX_mode(ctx_.get()) == EVP_CIPH_CCM_MODE);

  if (message_len > max_message_size_) {
    THROW_ERR_CRYPTO_INVALID_MESSAGELEN(env());
    return false;
  }

  return true;
}",636.0,646.0,1.0,1.0,11.0,3,3,4,4,0,0,2,2,0,0,,0,0,2,1,1,bool
1372,22956,IsAuthenticatedMode,1,node.crypto.CipherBase.IsAuthenticatedMode,bool node.crypto.CipherBase.IsAuthenticatedMode (),crypto\crypto_cipher.cc,"bool CipherBase::IsAuthenticatedMode() const {
  // Check if this cipher operates in an AEAD mode that we support.
  CHECK(ctx_);
  return IsSupportedAuthenticatedMode(ctx_.get());
}",648.0,652.0,1.0,1.0,5.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,bool
1373,22967,GetAuthTag,1,node.crypto.CipherBase.GetAuthTag,void node.crypto.CipherBase.GetAuthTag (FunctionCallbackInfo<Value>),crypto\crypto_cipher.cc,"void CipherBase::GetAuthTag(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  CipherBase* cipher;
  ASSIGN_OR_RETURN_UNWRAP(&cipher, args.Holder());

  // Only callable after Final and if encrypting.
  if (cipher->ctx_ ||
      cipher->kind_ != kCipher ||
      cipher->auth_tag_len_ == kNoAuthTagLength) {
    return;
  }

  args.GetReturnValue().Set(
      Buffer::Copy(env, cipher->auth_tag_, cipher->auth_tag_len_)
          .FromMaybe(Local<Value>()));
}",654.0,669.0,1.0,1.0,16.0,17,7,15,7,0,0,2,2,0,0,,0,0,2,1,1,void
1374,23028,SetAuthTag,1,node.crypto.CipherBase.SetAuthTag,void node.crypto.CipherBase.SetAuthTag (FunctionCallbackInfo<Value>),crypto\crypto_cipher.cc,"void CipherBase::SetAuthTag(const FunctionCallbackInfo<Value>& args) {
  CipherBase* cipher;
  ASSIGN_OR_RETURN_UNWRAP(&cipher, args.Holder());
  Environment* env = Environment::GetCurrent(args);

  if (!cipher->ctx_ ||
      !cipher->IsAuthenticatedMode() ||
      cipher->kind_ != kDecipher ||
      cipher->auth_tag_state_ != kAuthTagUnknown) {
    return args.GetReturnValue().Set(false);
  }

  ArrayBufferOrViewContents<char> auth_tag(args[0]);
  if (UNLIKELY(!auth_tag.CheckSizeInt32()))
    return THROW_ERR_OUT_OF_RANGE(env, ""buffer is too big"");

  unsigned int tag_len = auth_tag.size();

  const int mode = EVP_CIPHER_CTX_mode(cipher->ctx_.get());
  bool is_valid;
  if (mode == EVP_CIPH_GCM_MODE) {
    // Restrict GCM tag lengths according to NIST 800-38d, page 9.
    is_valid = (cipher->auth_tag_len_ == kNoAuthTagLength ||
                cipher->auth_tag_len_ == tag_len) &&
               IsValidGCMTagLength(tag_len);
  } else {
    // At this point, the tag length is already ...",671.0,717.0,1.0,1.0,47.0,49,11,42,13,0,0,5,5,0,0,,0,0,2,1,1,void
1375,23214,MaybePassAuthTagToOpenSSL,1,node.crypto.CipherBase.MaybePassAuthTagToOpenSSL,bool node.crypto.CipherBase.MaybePassAuthTagToOpenSSL (),crypto\crypto_cipher.cc,"bool CipherBase::MaybePassAuthTagToOpenSSL() {
  if (auth_tag_state_ == kAuthTagKnown) {
    if (!EVP_CIPHER_CTX_ctrl(ctx_.get(),
                             EVP_CTRL_AEAD_SET_TAG,
                             auth_tag_len_,
                             reinterpret_cast<unsigned char*>(auth_tag_))) {
      return false;
    }
    auth_tag_state_ = kAuthTagPassedToOpenSSL;
  }
  return true;
}",719.0,730.0,1.0,1.0,12.0,5,5,8,7,0,0,3,4,0,0,,0,0,0,0,0,bool
1376,23243,SetAAD,1,node.crypto.CipherBase.SetAAD,"bool node.crypto.CipherBase.SetAAD (ArrayBufferOrViewContents<unsigned char>,int)",crypto\crypto_cipher.cc,"void CipherBase::SetAAD(const FunctionCallbackInfo<Value>& args) {
  CipherBase* cipher;
  ASSIGN_OR_RETURN_UNWRAP(&cipher, args.Holder());
  Environment* env = Environment::GetCurrent(args);

  CHECK_EQ(args.Length(), 2);
  CHECK(args[1]->IsInt32());
  int plaintext_len = args[1].As<Int32>()->Value();
  ArrayBufferOrViewContents<unsigned char> buf(args[0]);

  if (UNLIKELY(!buf.CheckSizeInt32()))
    return THROW_ERR_OUT_OF_RANGE(env, ""buffer is too big"");
  args.GetReturnValue().Set(cipher->SetAAD(buf, plaintext_len));
}",771.0,784.0,1.0,1.0,14.0,18,7,16,8,0,0,8,14,0,0,,0,0,2,1,1,void
1377,23411,Update,1,node.crypto.CipherBase.Update,"UpdateResult node.crypto.CipherBase.Update (char*,size_t,ANY*)",crypto\crypto_cipher.cc,"void CipherBase::Update(const FunctionCallbackInfo<Value>& args) {
  Decode<CipherBase>(args, [](CipherBase* cipher,
                              const FunctionCallbackInfo<Value>& args,
                              const char* data, size_t size) {
    std::unique_ptr<BackingStore> out;
    Environment* env = Environment::GetCurrent(args);

    if (UNLIKELY(size > INT_MAX))
      return THROW_ERR_OUT_OF_RANGE(env, ""data is too long"");

    UpdateResult r = cipher->Update(data, size, &out);

    if (r != kSuccess) {
      if (r == kErrorState) {
        ThrowCryptoError(env, ERR_get_error(),
                         ""Trying to add data in unsupported state"");
      }
      return;
    }

    Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(out));
    args.GetReturnValue().Set(
        Buffer::New(env, ab, 0, ab->ByteLength()).FromMaybe(Local<Value>()));
  });
}",846.0,870.0,1.0,1.0,25.0,52,14,55,19,0,0,8,8,0,0,,0,0,2,1,1,void
1378,23630,SetAutoPadding,1,node.crypto.CipherBase.SetAutoPadding,bool node.crypto.CipherBase.SetAutoPadding (bool),crypto\crypto_cipher.cc,"void CipherBase::SetAutoPadding(const FunctionCallbackInfo<Value>& args) {
  CipherBase* cipher;
  ASSIGN_OR_RETURN_UNWRAP(&cipher, args.Holder());

  bool b = cipher->SetAutoPadding(args.Length() < 1 || args[0]->IsTrue());
  args.GetReturnValue().Set(b);  // Possibly report invalid state failure
}",879.0,885.0,1.0,1.0,7.0,2,2,3,2,0,0,2,2,0,0,,0,0,2,1,1,void
1379,23690,Final,1,node.crypto.CipherBase.Final,bool node.crypto.CipherBase.Final (ANY*),crypto\crypto_cipher.cc,"void CipherBase::Final(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  CipherBase* cipher;
  ASSIGN_OR_RETURN_UNWRAP(&cipher, args.Holder());
  if (cipher->ctx_ == nullptr)
    return THROW_ERR_CRYPTO_INVALID_STATE(env);

  std::unique_ptr<BackingStore> out;

  // Check IsAuthenticatedMode() first, Final() destroys the EVP_CIPHER_CTX.
  const bool is_auth_mode = cipher->IsAuthenticatedMode();
  bool r = cipher->Final(&out);

  if (!r) {
    const char* msg = is_auth_mode
                          ? ""Unsupported state or unable to authenticate data""
                          : ""Unsupported state"";

    return ThrowCryptoError(env, ERR_get_error(), msg);
  }

  Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(out));
  args.GetReturnValue().Set(
      Buffer::New(env, ab, 0, ab->ByteLength()).FromMaybe(Local<Value>()));
}",949.0,974.0,1.0,1.0,26.0,31,10,26,13,0,0,5,5,0,0,,0,0,2,1,1,void
1380,24022,Cipher,1,node.crypto.PublicKeyCipher.Cipher,"bool node.crypto.PublicKeyCipher.Cipher<PublicKeyCipher::Operation,PublicKeyCipher::EVP_PKEY_cipher_init_t,PublicKeyCipher::EVP_PKEY_cipher_t> (Environment*,ManagedEVPPKey,int,EVP_MD*,ArrayBufferOrViewContents<unsigned char>,ArrayBufferOrViewContents<unsigned char>,ANY*)",crypto\crypto_cipher.cc,"void PublicKeyCipher::Cipher(const FunctionCallbackInfo<Value>& args) {
  MarkPopErrorOnReturn mark_pop_error_on_return;
  Environment* env = Environment::GetCurrent(args);

  unsigned int offset = 0;
  ManagedEVPPKey pkey =
      ManagedEVPPKey::GetPublicOrPrivateKeyFromJs(args, &offset);
  if (!pkey)
    return;

  ArrayBufferOrViewContents<unsigned char> buf(args[offset]);
  if (UNLIKELY(!buf.CheckSizeInt32()))
    return THROW_ERR_OUT_OF_RANGE(env, ""buffer is too long"");

  uint32_t padding;
  if (!args[offset + 1]->Uint32Value(env->context()).To(&padding)) return;

  const EVP_MD* digest = nullptr;
  if (args[offset + 2]->IsString()) {
    const Utf8Value oaep_str(env->isolate(), args[offset + 2]);
    digest = EVP_get_digestbyname(*oaep_str);
    if (digest == nullptr)
      return THROW_ERR_OSSL_EVP_INVALID_DIGEST(env);
  }

  ArrayBufferOrViewContents<unsigned char> oaep_label(
      !args[offset + 3]->IsUndefined() ? args[offset + 3] : Local<Value>());
  if (UNLIKELY(!oaep_...",1038.0,1077.0,1.0,1.0,40.0,39,10,34,12,0,0,10,11,0,0,,0,0,2,1,1,void
1381,24460,Parse,1,node.crypto.ClientHelloParser.Parse,"void node.crypto.ClientHelloParser.Parse (uint8_t*,size_t)",crypto\crypto_clienthello.cc,"void ClientHelloParser::Parse(const uint8_t* data, size_t avail) {
  switch (state_) {
    case kWaiting:
      if (!ParseRecordHeader(data, avail))
        break;
      [[fallthrough]];
    case kTLSHeader:
      ParseHeader(data, avail);
      break;
    case kPaused:
      // Just nop
    case kEnded:
      // Already ended, just ignore it
      break;
    default:
      break;
  }
}",27.0,44.0,1.0,1.0,18.0,1,1,9,7,0,0,7,4,0,0,,0,0,4,2,2,void
1382,24491,ParseRecordHeader,1,node.crypto.ClientHelloParser.ParseRecordHeader,"bool node.crypto.ClientHelloParser.ParseRecordHeader (uint8_t*,size_t)",crypto\crypto_clienthello.cc,"bool ClientHelloParser::ParseRecordHeader(const uint8_t* data, size_t avail) {
  // >= 5 bytes for header parsing
  if (avail < 5)
    return false;

  if (data[0] == kChangeCipherSpec ||
      data[0] == kAlert ||
      data[0] == kHandshake ||
      data[0] == kApplicationData) {
    frame_len_ = (data[3] << 8) + data[4];
    state_ = kTLSHeader;
    body_offset_ = 5;
  } else {
    End();
    return false;
  }

  // Sanity check (too big frame, or too small)
  // Let OpenSSL handle it
  if (frame_len_ >= kMaxTLSFrameLen) {
    End();
    return false;
  }

  return true;
}",47.0,72.0,1.0,1.0,26.0,20,8,17,11,0,0,4,4,0,0,,0,0,4,2,2,bool
1383,24561,ParseHeader,1,node.crypto.ClientHelloParser.ParseHeader,"void node.crypto.ClientHelloParser.ParseHeader (uint8_t*,size_t)",crypto\crypto_clienthello.cc,"void ClientHelloParser::ParseHeader(const uint8_t* data, size_t avail) {
  ClientHello hello;

  // We need at least six bytes (one byte for kClientHello, three bytes for the
  // length of the handshake message, and two bytes for the protocol version).
  // If the client sent a frame that suggests a smaller ClientHello, give up.
  if (frame_len_ < 6) return End();

  // >= 5 + frame size bytes for frame parsing
  if (body_offset_ + frame_len_ > avail)
    return;

  // Check hello protocol version.  Protocol tuples that we know about:
  //
  // (3,1) TLS v1.0
  // (3,2) TLS v1.1
  // (3,3) TLS v1.2
  //
  // Note that TLS v1.3 uses a TLS v1.2 handshake so requires no specific
  // support here.
  if (data[body_offset_ + 4] != 0x03 ||
      data[body_offset_ + 5] < 0x01 ||
      data[body_offset_ + 5] > 0x03) {
    return End();
  }

  if (data[body_offset_] == kClientHello) {
    if (state_ == kTLSHeader) {
      if (!ParseTLSClientHello(data, avail))
        return End();
    } el...",75.0,125.0,1.0,1.0,51.0,40,12,38,16,0,0,8,12,0,0,,0,0,4,2,2,void
1384,24692,ParseExtension,1,node.crypto.ClientHelloParser.ParseExtension,"void node.crypto.ClientHelloParser.ParseExtension (uint16_t,uint8_t*,size_t)",crypto\crypto_clienthello.cc,"void ClientHelloParser::ParseExtension(const uint16_t type,
                                       const uint8_t* data,
                                       size_t len) {
  // NOTE: In case of anything we're just returning back, ignoring the problem.
  // That's because we're heavily relying on OpenSSL to solve any problem with
  // incoming data.
  switch (type) {
    case kServerName:
      {
        if (len < 2)
          return;
        uint32_t server_names_len = (data[0] << 8) + data[1];
        if (server_names_len + 2 > len)
          return;
        for (size_t offset = 2; offset < 2 + server_names_len; ) {
          if (offset + 3 > len)
            return;
          uint8_t name_type = data[offset];
          if (name_type != kServernameHostname)
            return;
          uint16_t name_len = (data[offset + 1] << 8) + data[offset + 2];
          offset += 3;
          if (offset + name_len > len)
            return;
          servername_ = data + offset;
          se...",128.0,166.0,1.0,1.0,39.0,33,8,40,14,0,0,11,17,0,0,,0,0,6,3,3,void
1385,24815,ParseTLSClientHello,1,node.crypto.ClientHelloParser.ParseTLSClientHello,"bool node.crypto.ClientHelloParser.ParseTLSClientHello (uint8_t*,size_t)",crypto\crypto_clienthello.cc,"bool ClientHelloParser::ParseTLSClientHello(const uint8_t* data, size_t avail) {
  const uint8_t* body;

  // Skip frame header, hello header, protocol version and random data
  size_t session_offset = body_offset_ + 4 + 2 + 32;

  if (session_offset + 1 >= avail)
    return false;

  body = data + session_offset;
  session_size_ = *body;
  session_id_ = body + 1;

  size_t cipher_offset = session_offset + 1 + session_size_;

  // Session OOB failure
  if (cipher_offset + 1 >= avail)
    return false;

  uint16_t cipher_len =
      (data[cipher_offset] << 8) + data[cipher_offset + 1];
  size_t comp_offset = cipher_offset + 2 + cipher_len;

  // Cipher OOB failure
  if (comp_offset >= avail)
    return false;

  uint8_t comp_len = data[comp_offset];
  size_t extension_offset = comp_offset + 1 + comp_len;

  // Compression OOB failure
  if (extension_offset > avail)
    return false;

  // No extensions present
  if (extension_offset == avail)
    return true;

  size_t ext_off = exte...",169.0,235.0,1.0,1.0,67.0,58,10,64,15,0,0,10,12,0,0,,0,0,4,2,2,bool
1386,25019,<lambda>0,1,node.crypto.GetX509NameObject.<lambda>0,ANY node.crypto.GetX509NameObject.<lambda>0 (),crypto\crypto_common.cc,[&]() { OPENSSL_free(value_str); },999.0,999.0,40.0,73.0,1.0,0,0,1,1,0,0,1,1,0,0,,0,0,0,0,0,ANY
1387,25095,SSL_CTX_get_issuer,1,node.crypto.SSL_CTX_get_issuer,"X509Pointer node.crypto.SSL_CTX_get_issuer (SSL_CTX*,X509*)",crypto\crypto_common.cc,"X509Pointer SSL_CTX_get_issuer(SSL_CTX* ctx, X509* cert) {
  X509_STORE* store = SSL_CTX_get_cert_store(ctx);
  DeleteFnPtr<X509_STORE_CTX, X509_STORE_CTX_free> store_ctx(
      X509_STORE_CTX_new());
  X509Pointer result;
  X509* issuer;
  if (store_ctx.get() != nullptr &&
      X509_STORE_CTX_init(store_ctx.get(), store, nullptr, nullptr) == 1 &&
      X509_STORE_CTX_get1_issuer(&issuer, store_ctx.get(), cert) == 1) {
    result.reset(issuer);
  }
  return result;
}",54.0,66.0,1.0,1.0,13.0,14,9,14,9,0,0,2,2,0,0,,0,0,4,2,2,X509Pointer
1388,25153,LogSecret,1,node.crypto.LogSecret,"void node.crypto.LogSecret (SSLPointer,char*,unsigned char*,size_t)",crypto\crypto_common.cc,"void LogSecret(
    const SSLPointer& ssl,
    const char* name,
    const unsigned char* secret,
    size_t secretlen) {
  auto keylog_cb = SSL_CTX_get_keylog_callback(SSL_get_SSL_CTX(ssl.get()));
  // All supported versions of TLS/SSL fix the client random to the same size.
  constexpr size_t kTlsClientRandomSize = SSL3_RANDOM_SIZE;
  unsigned char crandom[kTlsClientRandomSize];

  if (keylog_cb == nullptr ||
      SSL_get_client_random(ssl.get(), crandom, kTlsClientRandomSize) !=
          kTlsClientRandomSize) {
    return;
  }

  std::string line = name;
  line += "" "" + StringBytes::hex_encode(reinterpret_cast<const char*>(crandom),
                                        kTlsClientRandomSize);
  line += "" "" + StringBytes::hex_encode(
      reinterpret_cast<const char*>(secret), secretlen);
  keylog_cb(ssl.get(), line.c_str());
}",68.0,90.0,1.0,1.0,23.0,18,8,21,10,0,0,2,2,0,0,,0,0,8,4,4,void
1389,25228,GetSSLOCSPResponse,1,node.crypto.GetSSLOCSPResponse,"MaybeLocal<Value> node.crypto.GetSSLOCSPResponse (Environment*,SSL*,Local<Value>)",crypto\crypto_common.cc,"MaybeLocal<Value> GetSSLOCSPResponse(
    Environment* env,
    SSL* ssl,
    Local<Value> default_value) {
  const unsigned char* resp;
  int len = SSL_get_tlsext_status_ocsp_resp(ssl, &resp);
  if (resp == nullptr)
    return default_value;

  Local<Value> ret;
  MaybeLocal<Object> maybe_buffer =
      Buffer::Copy(env, reinterpret_cast<const char*>(resp), len);

  if (!maybe_buffer.ToLocal(&ret))
    return MaybeLocal<Value>();

  return ret;
}",92.0,109.0,1.0,1.0,18.0,13,8,18,12,0,0,3,3,0,0,,0,0,6,3,3,MaybeLocal<Value>
1390,25283,SetTLSSession,1,node.crypto.SetTLSSession,"bool node.crypto.SetTLSSession (SSLPointer,SSLSessionPointer)",crypto\crypto_common.cc,"bool SetTLSSession(
    const SSLPointer& ssl,
    const SSLSessionPointer& session) {
  return session != nullptr && SSL_set_session(ssl.get(), session.get()) == 1;
}",111.0,115.0,1.0,1.0,5.0,5,4,3,2,0,0,1,1,0,0,,0,0,4,2,2,bool
1391,25305,GetTLSSession,1,node.crypto.GetTLSSession,"SSLSessionPointer node.crypto.GetTLSSession (unsigned char*,size_t)",crypto\crypto_common.cc,"SSLSessionPointer GetTLSSession(const unsigned char* buf, size_t length) {
  return SSLSessionPointer(d2i_SSL_SESSION(nullptr, &buf, length));
}",117.0,119.0,1.0,1.0,3.0,1,1,2,2,0,0,1,1,0,0,,0,0,4,2,2,SSLSessionPointer
1392,25318,VerifyPeerCertificate,1,node.crypto.VerifyPeerCertificate,"long node.crypto.VerifyPeerCertificate (SSLPointer,long)",crypto\crypto_common.cc,"long VerifyPeerCertificate(  // NOLINT(runtime/int)
    const SSLPointer& ssl,
    long def) {  // NOLINT(runtime/int)
  long err = def;  // NOLINT(runtime/int)
  if (X509* peer_cert = SSL_get_peer_certificate(ssl.get())) {
    X509_free(peer_cert);
    err = SSL_get_verify_result(ssl.get());
  } else {
    const SSL_CIPHER* curr_cipher = SSL_get_current_cipher(ssl.get());
    const SSL_SESSION* sess = SSL_get_session(ssl.get());
    // Allow no-cert for PSK authentication in TLS1.2 and lower.
    // In TLS1.3 check that session was reused because TLS1.3 PSK
    // looks like session resumption.
    if (SSL_CIPHER_get_auth_nid(curr_cipher) == NID_auth_psk ||
        (SSL_SESSION_get_protocol_version(sess) == TLS1_3_VERSION &&
         SSL_session_reused(ssl.get()))) {
      return X509_V_OK;
    }
  }
  return err;
}",121.0,141.0,1.0,1.0,21.0,14,5,18,9,0,0,2,2,0,0,,0,0,4,2,2,long
1393,25387,UseSNIContext,1,node.crypto.UseSNIContext,"bool node.crypto.UseSNIContext (SSLPointer,BaseObjectPtr<SecureContext>)",crypto\crypto_common.cc,"bool UseSNIContext(
    const SSLPointer& ssl, BaseObjectPtr<SecureContext> context) {
  SSL_CTX* ctx = context->ctx().get();
  X509* x509 = SSL_CTX_get0_certificate(ctx);
  EVP_PKEY* pkey = SSL_CTX_get0_privatekey(ctx);
  STACK_OF(X509)* chain;

  int err = SSL_CTX_get0_chain_certs(ctx, &chain);
  if (err == 1) err = SSL_use_certificate(ssl.get(), x509);
  if (err == 1) err = SSL_use_PrivateKey(ssl.get(), pkey);
  if (err == 1 && chain != nullptr) err = SSL_set1_chain(ssl.get(), chain);
  return err == 1;
}",143.0,155.0,1.0,1.0,13.0,20,8,25,8,0,0,4,4,0,0,,0,0,4,2,2,bool
1394,25471,GetClientHelloALPN,1,node.crypto.GetClientHelloALPN,const char* node.crypto.GetClientHelloALPN (SSLPointer),crypto\crypto_common.cc,"const char* GetClientHelloALPN(const SSLPointer& ssl) {
  const unsigned char* buf;
  size_t len;
  size_t rem;

  if (!SSL_client_hello_get0_ext(
          ssl.get(),
          TLSEXT_TYPE_application_layer_protocol_negotiation,
          &buf,
          &rem) ||
      rem < 2) {
    return nullptr;
  }

  len = (buf[0] << 8) | buf[1];
  if (len + 2 != rem) return nullptr;
  return reinterpret_cast<const char*>(buf + 3);
}",157.0,174.0,1.0,1.0,18.0,15,12,11,5,0,0,3,3,0,0,,0,0,2,1,1,const char*
1395,25524,GetClientHelloServerName,1,node.crypto.GetClientHelloServerName,const char* node.crypto.GetClientHelloServerName (SSLPointer),crypto\crypto_common.cc,"const char* GetClientHelloServerName(const SSLPointer& ssl) {
  const unsigned char* buf;
  size_t len;
  size_t rem;

  if (!SSL_client_hello_get0_ext(
          ssl.get(),
          TLSEXT_TYPE_server_name,
          &buf,
          &rem) || rem <= 2) {
    return nullptr;
  }

  len = (*buf << 8) | *(buf + 1);
  if (len + 2 != rem)
    return nullptr;
  rem = len;

  if (rem == 0 || *(buf + 2) != TLSEXT_NAMETYPE_host_name) return nullptr;
  rem--;
  if (rem <= 2)
    return nullptr;
  len = (*(buf + 3) << 8) | *(buf + 4);
  if (len + 2 > rem)
    return nullptr;
  return reinterpret_cast<const char*>(buf + 5);
}",176.0,202.0,1.0,1.0,27.0,33,15,23,6,0,0,6,6,0,0,,0,0,2,1,1,const char*
1396,25625,GetServerName,1,node.crypto.GetServerName,const char* node.crypto.GetServerName (SSL*),crypto\crypto_common.cc,"const char* GetServerName(SSL* ssl) {
  return SSL_get_servername(ssl, TLSEXT_NAMETYPE_host_name);
}",204.0,206.0,1.0,1.0,3.0,0,0,2,2,0,0,1,1,0,0,,0,0,2,1,1,const char*
1397,25634,SetGroups,1,node.crypto.SetGroups,"bool node.crypto.SetGroups (SecureContext*,char*)",crypto\crypto_common.cc,"bool SetGroups(SecureContext* sc, const char* groups) {
  return SSL_CTX_set1_groups_list(sc->ctx().get(), groups) == 1;
}",208.0,210.0,1.0,1.0,3.0,3,3,2,2,0,0,1,1,0,0,,0,0,4,2,2,bool
1398,25652,X509ErrorCode,1,node.crypto.X509ErrorCode,const char* node.crypto.X509ErrorCode (long),crypto\crypto_common.cc,"const char* X509ErrorCode(long err) {  // NOLINT(runtime/int)
  const char* code = ""UNSPECIFIED"";
#define CASE_X509_ERR(CODE) case X509_V_ERR_##CODE: code = #CODE; break;
  switch (err) {
    // if you modify anything in here, *please* update the respective section in
    // doc/api/tls.md as well
    CASE_X509_ERR(UNABLE_TO_GET_ISSUER_CERT)
    CASE_X509_ERR(UNABLE_TO_GET_CRL)
    CASE_X509_ERR(UNABLE_TO_DECRYPT_CERT_SIGNATURE)
    CASE_X509_ERR(UNABLE_TO_DECRYPT_CRL_SIGNATURE)
    CASE_X509_ERR(UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY)
    CASE_X509_ERR(CERT_SIGNATURE_FAILURE)
    CASE_X509_ERR(CRL_SIGNATURE_FAILURE)
    CASE_X509_ERR(CERT_NOT_YET_VALID)
    CASE_X509_ERR(CERT_HAS_EXPIRED)
    CASE_X509_ERR(CRL_NOT_YET_VALID)
    CASE_X509_ERR(CRL_HAS_EXPIRED)
    CASE_X509_ERR(ERROR_IN_CERT_NOT_BEFORE_FIELD)
    CASE_X509_ERR(ERROR_IN_CERT_NOT_AFTER_FIELD)
    CASE_X509_ERR(ERROR_IN_CRL_LAST_UPDATE_FIELD)
    CASE_X509_ERR(ERROR_IN_CRL_NEXT_UPDATE_FIELD)
    CASE_X509_ERR(OUT_OF_MEM)
 ...",212.0,249.0,1.0,4.0,38.0,29,1,59,30,0,0,30,2,0,0,,0,0,2,1,1,const char*
1399,25890,GetValidationErrorReason,1,node.crypto.GetValidationErrorReason,"MaybeLocal<Value> node.crypto.GetValidationErrorReason (Environment*,int)",crypto\crypto_common.cc,"MaybeLocal<Value> GetValidationErrorReason(Environment* env, int err) {
  if (err == 0)
    return Undefined(env->isolate());
  const char* reason = X509_verify_cert_error_string(err);
  return OneByteString(env->isolate(), reason);
}",251.0,256.0,1.0,1.0,6.0,4,3,6,3,0,0,2,2,0,0,,0,0,4,2,2,MaybeLocal<Value>
1400,25919,GetValidationErrorCode,1,node.crypto.GetValidationErrorCode,"MaybeLocal<Value> node.crypto.GetValidationErrorCode (Environment*,int)",crypto\crypto_common.cc,"MaybeLocal<Value> GetValidationErrorCode(Environment* env, int err) {
  if (err == 0)
    return Undefined(env->isolate());
  return OneByteString(env->isolate(), X509ErrorCode(err));
}",258.0,262.0,1.0,1.0,5.0,3,2,4,2,0,0,2,2,0,0,,0,0,4,2,2,MaybeLocal<Value>
1401,25944,GetCert,1,node.crypto.GetCert,"MaybeLocal<Value> node.crypto.GetCert (Environment*,SSLPointer)",crypto\crypto_common.cc,"MaybeLocal<Value> GetCert(Environment* env, const SSLPointer& ssl) {
  ClearErrorOnReturn clear_error_on_return;
  X509* cert = SSL_get_certificate(ssl.get());
  if (cert == nullptr)
    return Undefined(env->isolate());

  MaybeLocal<Object> maybe_cert = X509ToObject(env, cert);
  return maybe_cert.FromMaybe<Value>(Local<Value>());
}",264.0,272.0,1.0,1.0,9.0,10,6,11,7,0,0,2,2,0,0,,0,0,4,2,2,MaybeLocal<Value>
1402,25987,ToV8Value,1,node.crypto.ToV8Value,"Local<Value> node.crypto.ToV8Value (Environment*,BIOPointer)",crypto\crypto_common.cc,"Local<Value> ToV8Value(Environment* env, const BIOPointer& bio) {
  BUF_MEM* mem;
  BIO_get_mem_ptr(bio.get(), &mem);
  MaybeLocal<String> ret =
      String::NewFromUtf8(
          env->isolate(),
          mem->data,
          NewStringType::kNormal,
          mem->length);
  CHECK_EQ(BIO_reset(bio.get()), 1);
  return ret.FromMaybe(Local<Value>());
}",274.0,285.0,1.0,1.0,12.0,12,6,12,7,0,0,1,1,0,0,,0,0,4,2,2,Local<Value>
1403,26038,Set,1,node.crypto.anonymous_namespace_1.Set,"bool node.crypto.anonymous_namespace_1.Set<T> (Local<Context>,Local<Object>,Local<Value>,MaybeLocal<T>)",crypto\crypto_common.cc,"bool Set(
    Local<Context> context,
    Local<Object> target,
    Local<Value> name,
    MaybeLocal<T> maybe_value) {
  Local<Value> value;
  if (!maybe_value.ToLocal(&value))
    return false;

  // Undefined is ignored, but still considered successful
  if (value->IsUndefined())
    return true;

  return !target->Set(context, name, value).IsNothing();
}",289.0,303.0,1.0,1.0,15.0,9,6,10,7,0,0,3,3,0,0,,0,0,8,4,4,bool
1404,26082,GetCipherValue,1,node.crypto.anonymous_namespace_2.GetCipherValue,"MaybeLocal<Value> node.crypto.anonymous_namespace_2.GetCipherValue<const char*(*)(const SSL_CIPHER*)> (Environment*,SSL_CIPHER*)",crypto\crypto_common.cc,"MaybeLocal<Value> GetCipherValue(Environment* env, const SSL_CIPHER* cipher) {
  if (cipher == nullptr)
    return Undefined(env->isolate());

  return OneByteString(env->isolate(), getstr(cipher));
}",306.0,311.0,1.0,1.0,6.0,3,2,4,2,0,0,2,2,0,0,,0,0,4,2,2,MaybeLocal<Value>
1405,26120,AddIssuerChainToObject,1,node.crypto.anonymous_namespace_3.AddIssuerChainToObject,"MaybeLocal<Object> node.crypto.anonymous_namespace_3.AddIssuerChainToObject (X509Pointer*,Local<Object>,StackOfX509,Environment*)",crypto\crypto_common.cc,"MaybeLocal<Object> AddIssuerChainToObject(
    X509Pointer* cert,
    Local<Object> object,
    StackOfX509&& peer_certs,
    Environment* const env) {
  Local<Context> context = env->isolate()->GetCurrentContext();
  cert->reset(sk_X509_delete(peer_certs.get(), 0));
  for (;;) {
    int i;
    for (i = 0; i < sk_X509_num(peer_certs.get()); i++) {
      X509* ca = sk_X509_value(peer_certs.get(), i);
      if (X509_check_issued(ca, cert->get()) != X509_V_OK)
        continue;

      Local<Object> ca_info;
      MaybeLocal<Object> maybe_ca_info = X509ToObject(env, ca);
      if (!maybe_ca_info.ToLocal(&ca_info))
        return MaybeLocal<Object>();

      if (!Set<Object>(context, object, env->issuercert_string(), ca_info))
        return MaybeLocal<Object>();
      object = ca_info;

      // NOTE: Intentionally freeing cert that is not used anymore.
      // Delete cert and continue aggregating issuers.
      cert->reset(sk_X509_delete(peer_certs.get(), i));
      break;
    }

    ...",333.0,367.0,1.0,1.0,35.0,31,9,39,14,0,0,10,15,0,0,,0,0,8,4,4,MaybeLocal<Object>
1406,26258,GetLastIssuedCert,1,node.crypto.anonymous_namespace_4.GetLastIssuedCert,"MaybeLocal<Object> node.crypto.anonymous_namespace_4.GetLastIssuedCert (X509Pointer*,SSLPointer,Local<Object>,Environment*)",crypto\crypto_common.cc,"MaybeLocal<Object> GetLastIssuedCert(
    X509Pointer* cert,
    const SSLPointer& ssl,
    Local<Object> issuer_chain,
    Environment* const env) {
  Local<Context> context = env->isolate()->GetCurrentContext();
  while (X509_check_issued(cert->get(), cert->get()) != X509_V_OK) {
    X509Pointer ca;
    if (!(ca = SSL_CTX_get_issuer(SSL_get_SSL_CTX(ssl.get()), cert->get())))
      break;

    Local<Object> ca_info;
    MaybeLocal<Object> maybe_ca_info = X509ToObject(env, ca.get());
    if (!maybe_ca_info.ToLocal(&ca_info))
      return MaybeLocal<Object>();

    if (!Set<Object>(context, issuer_chain, env->issuercert_string(), ca_info))
      return MaybeLocal<Object>();
    issuer_chain = ca_info;

    // For self-signed certificates whose keyUsage field does not include
    // keyCertSign, X509_check_issued() will return false. Avoid going into an
    // infinite loop by checking if SSL_CTX_get_issuer() returned the same
    // certificate.
    if (cert->get() == ca.get()) break...",369.0,399.0,1.0,1.0,31.0,32,10,34,14,0,0,8,10,0,0,,0,0,8,4,4,MaybeLocal<Object>
1407,26379,AddFingerprintDigest,1,node.crypto.anonymous_namespace_5.AddFingerprintDigest,"void node.crypto.anonymous_namespace_5.AddFingerprintDigest (unsigned char*,unsigned int,char[3 * EVP_MAX_MD_SIZE])",crypto\crypto_common.cc,"void AddFingerprintDigest(
    const unsigned char* md,
    unsigned int md_size,
    char fingerprint[3 * EVP_MAX_MD_SIZE]) {
  unsigned int i;
  const char hex[] = ""0123456789ABCDEF"";

  for (i = 0; i < md_size; i++) {
    fingerprint[3*i] = hex[(md[i] & 0xf0) >> 4];
    fingerprint[(3*i)+1] = hex[(md[i] & 0x0f)];
    fingerprint[(3*i)+2] = ':';
  }

  DCHECK_GT(md_size, 0);
  fingerprint[(3 * (md_size - 1)) + 2] = '\0';
}",401.0,416.0,1.0,1.0,16.0,26,8,19,5,0,0,2,2,0,0,,0,0,6,3,3,void
1408,26455,GetCurveName,1,node.crypto.anonymous_namespace_6.GetCurveName,"MaybeLocal<Value> node.crypto.anonymous_namespace_6.GetCurveName<const char*(*)(int)> (Environment*,int)",crypto\crypto_common.cc,"MaybeLocal<Value> GetCurveName(Environment* env, const int nid) {
  const char* name = nid2string(nid);
  return name != nullptr ?
      MaybeLocal<Value>(OneByteString(env->isolate(), name)) :
      MaybeLocal<Value>(Undefined(env->isolate()));
}",419.0,424.0,1.0,1.0,6.0,9,6,10,5,0,0,1,1,0,0,,0,0,4,2,2,MaybeLocal<Value>
1409,26490,GetECPubKey,1,node.crypto.anonymous_namespace_7.GetECPubKey,"MaybeLocal<Value> node.crypto.anonymous_namespace_7.GetECPubKey (Environment*,EC_GROUP*,ECPointer)",crypto\crypto_common.cc,"MaybeLocal<Value> GetECPubKey(
    Environment* env,
    const EC_GROUP* group,
    const ECPointer& ec) {
  const EC_POINT* pubkey = EC_KEY_get0_public_key(ec.get());
  if (pubkey == nullptr)
    return Undefined(env->isolate());

  return ECPointToBuffer(
      env,
      group,
      pubkey,
      EC_KEY_get_conv_form(ec.get()),
      nullptr).FromMaybe(Local<Object>());
}",426.0,440.0,1.0,1.0,15.0,6,4,8,4,0,0,2,2,0,0,,0,0,6,3,3,MaybeLocal<Value>
1410,26531,GetECGroup,1,node.crypto.anonymous_namespace_8.GetECGroup,"MaybeLocal<Value> node.crypto.anonymous_namespace_8.GetECGroup (Environment*,EC_GROUP*,ECPointer)",crypto\crypto_common.cc,"MaybeLocal<Value> GetECGroup(
    Environment* env,
    const EC_GROUP* group,
    const ECPointer& ec) {
  if (group == nullptr)
    return Undefined(env->isolate());

  int bits = EC_GROUP_order_bits(group);
  if (bits <= 0)
    return Undefined(env->isolate());

  return Integer::New(env->isolate(), bits);
}",442.0,454.0,1.0,1.0,13.0,7,5,9,4,0,0,3,3,0,0,,0,0,6,3,3,MaybeLocal<Value>
1411,26575,GetPubKey,1,node.crypto.anonymous_namespace_9.GetPubKey,"MaybeLocal<Object> node.crypto.anonymous_namespace_9.GetPubKey (Environment*,RSAPointer)",crypto\crypto_common.cc,"MaybeLocal<Object> GetPubKey(Environment* env, const RSAPointer& rsa) {
  int size = i2d_RSA_PUBKEY(rsa.get(), nullptr);
  CHECK_GE(size, 0);

  std::unique_ptr<BackingStore> bs;
  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), size);
  }

  unsigned char* serialized = reinterpret_cast<unsigned char*>(bs->Data());
  CHECK_GE(i2d_RSA_PUBKEY(rsa.get(), &serialized), 0);

  Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(bs));
  return Buffer::New(env, ab, 0, ab->ByteLength()).FromMaybe(Local<Object>());
}",456.0,471.0,1.0,1.0,16.0,23,7,26,11,0,0,1,1,0,0,,0,0,4,2,2,MaybeLocal<Object>
1412,26671,GetExponentString,1,node.crypto.anonymous_namespace_10.GetExponentString,"MaybeLocal<Value> node.crypto.anonymous_namespace_10.GetExponentString (Environment*,BIOPointer,BIGNUM*)",crypto\crypto_common.cc,"MaybeLocal<Value> GetExponentString(
    Environment* env,
    const BIOPointer& bio,
    const BIGNUM* e) {
  uint64_t exponent_word = static_cast<uint64_t>(BN_get_word(e));
  BIO_printf(bio.get(), ""0x%"" PRIx64, exponent_word);
  return ToV8Value(env, bio);
}",473.0,480.0,1.0,1.0,8.0,2,2,4,4,0,0,1,1,0,0,,0,0,6,3,3,MaybeLocal<Value>
1413,26690,GetBits,1,node.crypto.anonymous_namespace_11.GetBits,"Local<Value> node.crypto.anonymous_namespace_11.GetBits (Environment*,BIGNUM*)",crypto\crypto_common.cc,"Local<Value> GetBits(Environment* env, const BIGNUM* n) {
  return Integer::New(env->isolate(), BN_num_bits(n));
}",482.0,484.0,1.0,1.0,3.0,2,2,3,3,0,0,1,1,0,0,,0,0,4,2,2,Local<Value>
1414,26707,GetModulusString,1,node.crypto.anonymous_namespace_12.GetModulusString,"MaybeLocal<Value> node.crypto.anonymous_namespace_12.GetModulusString (Environment*,BIOPointer,BIGNUM*)",crypto\crypto_common.cc,"MaybeLocal<Value> GetModulusString(
    Environment* env,
    const BIOPointer& bio,
    const BIGNUM* n) {
  BN_print(bio.get(), n);
  return ToV8Value(env, bio);
}",486.0,492.0,1.0,1.0,7.0,1,1,4,3,0,0,1,1,0,0,,0,0,6,3,3,MaybeLocal<Value>
1415,26724,GetRawDERCertificate,1,node.crypto.GetRawDERCertificate,"MaybeLocal<Object> node.crypto.GetRawDERCertificate (Environment*,X509*)",crypto\crypto_common.cc,"MaybeLocal<Object> GetRawDERCertificate(Environment* env, X509* cert) {
  int size = i2d_X509(cert, nullptr);

  std::unique_ptr<BackingStore> bs;
  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), size);
  }

  unsigned char* serialized = reinterpret_cast<unsigned char*>(bs->Data());
  CHECK_GE(i2d_X509(cert, &serialized), 0);

  Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(bs));
  return Buffer::New(env, ab, 0, ab->ByteLength()).FromMaybe(Local<Object>());
}",495.0,509.0,1.0,1.0,15.0,21,7,25,11,0,0,1,1,0,0,,0,0,4,2,2,MaybeLocal<Object>
1416,26811,GetSerialNumber,1,node.crypto.GetSerialNumber,"MaybeLocal<Value> node.crypto.GetSerialNumber (Environment*,X509*)",crypto\crypto_common.cc,"MaybeLocal<Value> GetSerialNumber(Environment* env, X509* cert) {
  if (ASN1_INTEGER* serial_number = X509_get_serialNumber(cert)) {
    BignumPointer bn(ASN1_INTEGER_to_BN(serial_number, nullptr));
    if (bn) {
      char* data = BN_bn2hex(bn.get());
      ByteSource buf = ByteSource::Allocated(data, strlen(data));
      if (buf) return OneByteString(env->isolate(), buf.data<unsigned char>());
    }
  }

  return Undefined(env->isolate());
}",511.0,522.0,1.0,1.0,12.0,8,3,14,7,0,0,4,7,0,0,,0,0,4,2,2,MaybeLocal<Value>
1417,26870,GetKeyUsage,1,node.crypto.GetKeyUsage,"MaybeLocal<Value> node.crypto.GetKeyUsage (Environment*,X509*)",crypto\crypto_common.cc,"MaybeLocal<Value> GetKeyUsage(Environment* env, X509* cert) {
  StackOfASN1 eku(static_cast<STACK_OF(ASN1_OBJECT)*>(
      X509_get_ext_d2i(cert, NID_ext_key_usage, nullptr, nullptr)));
  if (eku) {
    const int count = sk_ASN1_OBJECT_num(eku.get());
    MaybeStackBuffer<Local<Value>, 16> ext_key_usage(count);
    char buf[256];

    int j = 0;
    for (int i = 0; i < count; i++) {
      if (OBJ_obj2txt(buf,
                      sizeof(buf),
                      sk_ASN1_OBJECT_value(eku.get(), i), 1) >= 0) {
        ext_key_usage[j++] = OneByteString(env->isolate(), buf);
      }
    }

    return Array::New(env->isolate(), ext_key_usage.out(), count);
  }

  return Undefined(env->isolate());
}",524.0,545.0,1.0,1.0,22.0,16,8,22,9,0,0,4,7,0,0,,0,0,4,2,2,MaybeLocal<Value>
1418,26956,GetCurrentCipherName,1,node.crypto.GetCurrentCipherName,"MaybeLocal<Value> node.crypto.GetCurrentCipherName (Environment*,SSLPointer)",crypto\crypto_common.cc,"MaybeLocal<Value> GetCurrentCipherName(Environment* env,
                                       const SSLPointer& ssl) {
  return GetCipherName(env, SSL_get_current_cipher(ssl.get()));
}",547.0,550.0,1.0,1.0,4.0,1,1,2,2,0,0,1,1,0,0,,0,0,4,2,2,MaybeLocal<Value>
1419,26970,GetCurrentCipherVersion,1,node.crypto.GetCurrentCipherVersion,"MaybeLocal<Value> node.crypto.GetCurrentCipherVersion (Environment*,SSLPointer)",crypto\crypto_common.cc,"MaybeLocal<Value> GetCurrentCipherVersion(Environment* env,
                                          const SSLPointer& ssl) {
  return GetCipherVersion(env, SSL_get_current_cipher(ssl.get()));
}",552.0,555.0,1.0,1.0,4.0,1,1,2,2,0,0,1,1,0,0,,0,0,4,2,2,MaybeLocal<Value>
1420,26984,GetFingerprintDigest,1,node.crypto.GetFingerprintDigest,"MaybeLocal<Value> node.crypto.GetFingerprintDigest (Environment*,EVP_MD*,X509*)",crypto\crypto_common.cc,"MaybeLocal<Value> GetFingerprintDigest(
    Environment* env,
    const EVP_MD* method,
    X509* cert) {
  unsigned char md[EVP_MAX_MD_SIZE];
  unsigned int md_size;
  char fingerprint[EVP_MAX_MD_SIZE * 3];

  if (X509_digest(cert, method, md, &md_size)) {
    AddFingerprintDigest(md, md_size, fingerprint);
    return OneByteString(env->isolate(), fingerprint);
  }
  return Undefined(env->isolate());
}",557.0,570.0,1.0,1.0,14.0,3,2,10,6,0,0,2,2,0,0,,0,0,6,3,3,MaybeLocal<Value>
1421,27019,GetValidTo,1,node.crypto.GetValidTo,"MaybeLocal<Value> node.crypto.GetValidTo (Environment*,X509*,BIOPointer)",crypto\crypto_common.cc,"MaybeLocal<Value> GetValidTo(
    Environment* env,
    X509* cert,
    const BIOPointer& bio) {
  ASN1_TIME_print(bio.get(), X509_get0_notAfter(cert));
  return ToV8Value(env, bio);
}",572.0,578.0,1.0,1.0,7.0,1,1,4,3,0,0,1,1,0,0,,0,0,6,3,3,MaybeLocal<Value>
1422,27037,GetValidFrom,1,node.crypto.GetValidFrom,"MaybeLocal<Value> node.crypto.GetValidFrom (Environment*,X509*,BIOPointer)",crypto\crypto_common.cc,"MaybeLocal<Value> GetValidFrom(
    Environment* env,
    X509* cert,
    const BIOPointer& bio) {
  ASN1_TIME_print(bio.get(), X509_get0_notBefore(cert));
  return ToV8Value(env, bio);
}",580.0,586.0,1.0,1.0,7.0,1,1,4,3,0,0,1,1,0,0,,0,0,6,3,3,MaybeLocal<Value>
1423,27055,IsSafeAltName,1,node.crypto.IsSafeAltName,"bool node.crypto.IsSafeAltName (char*,size_t,bool)",crypto\crypto_common.cc,"static inline bool IsSafeAltName(const char* name, size_t length, bool utf8) {
  for (size_t i = 0; i < length; i++) {
    char c = name[i];
    switch (c) {
    case '""':
    case '\\':
      // These mess with encoding rules.
      // Fall through.
    case ',':
      // Commas make it impossible to split the list of subject alternative
      // names unambiguously, which is why we have to escape.
      // Fall through.
    case '\'':
      // Single quotes are unlikely to appear in any legitimate values, but they
      // could be used to make a value look like it was escaped (i.e., enclosed
      // in single/double quotes).
      return false;
    default:
      if (utf8) {
        // In UTF8 strings, we require escaping for any ASCII control character,
        // but NOT for non-ASCII characters. Note that all bytes of any code
        // point that consists of more than a single byte have their MSB set.
        if (static_cast<unsigned char>(c) < ' ' || c == '\x7f') {
       ...",588.0,624.0,1.0,1.0,37.0,8,6,10,5,0,0,5,11,0,0,,0,0,6,3,3,bool
1424,27125,PrintAltName,1,node.crypto.PrintAltName,"void node.crypto.PrintAltName (BIOPointer,char*,size_t,bool,char*)",crypto\crypto_common.cc,"static inline void PrintAltName(const BIOPointer& out, const char* name,
                                size_t length, bool utf8,
                                const char* safe_prefix) {
  if (IsSafeAltName(name, length, utf8)) {
    // For backward-compatibility, append ""safe"" names without any
    // modifications.
    if (safe_prefix != nullptr) {
      BIO_printf(out.get(), ""%s:"", safe_prefix);
    }
    BIO_write(out.get(), name, length);
  } else {
    // If a name is not ""safe"", we cannot embed it without special
    // encoding. This does not usually happen, but we don't want to hide
    // it from the user either. We use JSON compatible escaping here.
    BIO_write(out.get(), ""\"""", 1);
    if (safe_prefix != nullptr) {
      BIO_printf(out.get(), ""%s:"", safe_prefix);
    }
    for (size_t j = 0; j < length; j++) {
      char c = static_cast<char>(name[j]);
      if (c == '\\') {
        BIO_write(out.get(), ""\\\\"", 2);
      } else if (c == '""') {
        BIO_write(out.g...",626.0,668.0,1.0,1.0,43.0,3,2,9,5,0,0,3,4,0,0,,0,0,10,5,5,void
1425,27296,PrintLatin1AltName,1,node.crypto.PrintLatin1AltName,"void node.crypto.PrintLatin1AltName (BIOPointer,ASN1_IA5STRING*,char*)",crypto\crypto_common.cc,"static inline void PrintLatin1AltName(const BIOPointer& out,
                                      const ASN1_IA5STRING* name,
                                      const char* safe_prefix = nullptr) {
  PrintAltName(out, reinterpret_cast<const char*>(name->data), name->length,
               false, safe_prefix);
}",670.0,675.0,1.0,1.0,6.0,3,2,4,3,0,0,1,1,0,0,,0,0,6,3,3,void
1426,27315,PrintUtf8AltName,1,node.crypto.PrintUtf8AltName,"void node.crypto.PrintUtf8AltName (BIOPointer,ASN1_UTF8STRING*,char*)",crypto\crypto_common.cc,"static inline void PrintUtf8AltName(const BIOPointer& out,
                                    const ASN1_UTF8STRING* name,
                                    const char* safe_prefix = nullptr) {
  PrintAltName(out, reinterpret_cast<const char*>(name->data), name->length,
               true, safe_prefix);
}",677.0,682.0,1.0,1.0,6.0,3,2,4,3,0,0,1,1,0,0,,0,0,6,3,3,void
1427,27334,PrintGeneralName,1,node.crypto.PrintGeneralName,"bool node.crypto.PrintGeneralName (BIOPointer,GENERAL_NAME*)",crypto\crypto_common.cc,"static bool PrintGeneralName(const BIOPointer& out, const GENERAL_NAME* gen) {
  if (gen->type == GEN_DNS) {
    ASN1_IA5STRING* name = gen->d.dNSName;
    BIO_write(out.get(), ""DNS:"", 4);
    // Note that the preferred name syntax (see RFCs 5280 and 1034) with
    // wildcards is a subset of what we consider ""safe"", so spec-compliant DNS
    // names will never need to be escaped.
    PrintLatin1AltName(out, name);
  } else if (gen->type == GEN_EMAIL) {
    ASN1_IA5STRING* name = gen->d.rfc822Name;
    BIO_write(out.get(), ""email:"", 6);
    PrintLatin1AltName(out, name);
  } else if (gen->type == GEN_URI) {
    ASN1_IA5STRING* name = gen->d.uniformResourceIdentifier;
    BIO_write(out.get(), ""URI:"", 4);
    // The set of ""safe"" names was designed to include just about any URI,
    // with a few exceptions, most notably URIs that contains commas (see
    // RFC 2396). In other words, most legitimate URIs will not require
    // escaping.
    PrintLatin1AltName(out, name);
  } else i...",686.0,815.0,1.0,1.0,130.0,6,4,7,4,0,0,2,2,0,0,,0,0,4,2,2,bool
1428,27432,tmp,1,node.crypto.PrintGeneralName.tmp,BIOPointer node.crypto.PrintGeneralName.tmp (BIO_new),crypto\crypto_common.cc,BIOPointer tmp(BIO_new(BIO_s_mem()));,720.0,720.0,16.0,40.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,BIOPointer
1429,27760,SafeX509SubjectAltNamePrint,1,node.crypto.SafeX509SubjectAltNamePrint,"bool node.crypto.SafeX509SubjectAltNamePrint (BIOPointer,X509_EXTENSION*)",crypto\crypto_common.cc,"bool SafeX509SubjectAltNamePrint(const BIOPointer& out, X509_EXTENSION* ext) {
  const X509V3_EXT_METHOD* method = X509V3_EXT_get(ext);
  CHECK(method == X509V3_EXT_get_nid(NID_subject_alt_name));

  GENERAL_NAMES* names = static_cast<GENERAL_NAMES*>(X509V3_EXT_d2i(ext));
  if (names == nullptr)
    return false;

  bool ok = true;

  for (int i = 0; i < sk_GENERAL_NAME_num(names); i++) {
    GENERAL_NAME* gen = sk_GENERAL_NAME_value(names, i);

    if (i != 0)
      BIO_write(out.get(), "", "", 2);

    if (!(ok = PrintGeneralName(out, gen))) {
      break;
    }
  }
  sk_GENERAL_NAME_pop_free(names, GENERAL_NAME_free);

  return ok;
}",817.0,840.0,1.0,1.0,24.0,13,7,22,9,0,0,6,7,0,0,,0,0,4,2,2,bool
1430,27839,SafeX509InfoAccessPrint,1,node.crypto.SafeX509InfoAccessPrint,"bool node.crypto.SafeX509InfoAccessPrint (BIOPointer,X509_EXTENSION*)",crypto\crypto_common.cc,"bool SafeX509InfoAccessPrint(const BIOPointer& out, X509_EXTENSION* ext) {
  const X509V3_EXT_METHOD* method = X509V3_EXT_get(ext);
  CHECK(method == X509V3_EXT_get_nid(NID_info_access));

  AUTHORITY_INFO_ACCESS* descs =
      static_cast<AUTHORITY_INFO_ACCESS*>(X509V3_EXT_d2i(ext));
  if (descs == nullptr)
    return false;

  bool ok = true;

  for (int i = 0; i < sk_ACCESS_DESCRIPTION_num(descs); i++) {
    ACCESS_DESCRIPTION* desc = sk_ACCESS_DESCRIPTION_value(descs, i);

    if (i != 0)
      BIO_write(out.get(), ""\n"", 1);

    char objtmp[80];
    i2t_ASN1_OBJECT(objtmp, sizeof(objtmp), desc->method);
    BIO_printf(out.get(), ""%s - "", objtmp);
    if (!(ok = PrintGeneralName(out, desc->location))) {
      break;
    }
  }
  sk_ACCESS_DESCRIPTION_pop_free(descs, ACCESS_DESCRIPTION_free);

#if OPENSSL_VERSION_MAJOR < 3
  BIO_write(out.get(), ""\n"", 1);
#endif

  return ok;
}",842.0,873.0,1.0,1.0,32.0,18,9,28,10,0,0,6,7,0,0,,0,0,4,2,2,bool
1431,27942,GetSubjectAltNameString,1,node.crypto.GetSubjectAltNameString,"MaybeLocal<v8::Value> node.crypto.GetSubjectAltNameString (Environment*,BIOPointer,X509*)",crypto\crypto_common.cc,"v8::MaybeLocal<v8::Value> GetSubjectAltNameString(
    Environment* env,
    const BIOPointer& bio,
    X509* cert) {
  int index = X509_get_ext_by_NID(cert, NID_subject_alt_name, -1);
  if (index < 0)
    return Undefined(env->isolate());

  X509_EXTENSION* ext = X509_get_ext(cert, index);
  CHECK_NOT_NULL(ext);

  if (!SafeX509SubjectAltNamePrint(bio, ext)) {
    CHECK_EQ(BIO_reset(bio.get()), 1);
    return v8::Null(env->isolate());
  }

  return ToV8Value(env, bio);
}",875.0,892.0,1.0,1.0,18.0,9,6,16,7,0,0,3,3,0,0,,0,0,6,3,3,MaybeLocal<v8.Value>
1432,28002,GetInfoAccessString,1,node.crypto.GetInfoAccessString,"MaybeLocal<v8::Value> node.crypto.GetInfoAccessString (Environment*,BIOPointer,X509*)",crypto\crypto_common.cc,"v8::MaybeLocal<v8::Value> GetInfoAccessString(
    Environment* env,
    const BIOPointer& bio,
    X509* cert) {
  int index = X509_get_ext_by_NID(cert, NID_info_access, -1);
  if (index < 0)
    return Undefined(env->isolate());

  X509_EXTENSION* ext = X509_get_ext(cert, index);
  CHECK_NOT_NULL(ext);

  if (!SafeX509InfoAccessPrint(bio, ext)) {
    CHECK_EQ(BIO_reset(bio.get()), 1);
    return v8::Null(env->isolate());
  }

  return ToV8Value(env, bio);
}",894.0,911.0,1.0,1.0,18.0,9,6,16,7,0,0,3,3,0,0,,0,0,6,3,3,MaybeLocal<v8.Value>
1433,28062,GetIssuerString,1,node.crypto.GetIssuerString,"MaybeLocal<Value> node.crypto.GetIssuerString (Environment*,BIOPointer,X509*)",crypto\crypto_common.cc,"MaybeLocal<Value> GetIssuerString(
    Environment* env,
    const BIOPointer& bio,
    X509* cert) {
  X509_NAME* issuer_name = X509_get_issuer_name(cert);
  if (X509_NAME_print_ex(
          bio.get(),
          issuer_name,
          0,
          kX509NameFlagsMultiline) <= 0) {
    CHECK_EQ(BIO_reset(bio.get()), 1);
    return Undefined(env->isolate());
  }

  return ToV8Value(env, bio);
}",913.0,928.0,1.0,1.0,16.0,5,4,9,5,0,0,2,2,0,0,,0,0,6,3,3,MaybeLocal<Value>
1434,28103,GetSubject,1,node.crypto.GetSubject,"MaybeLocal<Value> node.crypto.GetSubject (Environment*,BIOPointer,X509*)",crypto\crypto_common.cc,"MaybeLocal<Value> GetSubject(
    Environment* env,
    const BIOPointer& bio,
    X509* cert) {
  if (X509_NAME_print_ex(
          bio.get(),
          X509_get_subject_name(cert),
          0,
          kX509NameFlagsMultiline) <= 0) {
    CHECK_EQ(BIO_reset(bio.get()), 1);
    return Undefined(env->isolate());
  }

  return ToV8Value(env, bio);
}",930.0,944.0,1.0,1.0,15.0,4,3,7,4,0,0,2,2,0,0,,0,0,6,3,3,MaybeLocal<Value>
1435,28140,GetX509NameObject,1,node.crypto.GetX509NameObject,"MaybeLocal<Value> node.crypto.GetX509NameObject<X509_NAME*(const X509*)> (Environment*,X509*)",crypto\crypto_common.cc,"static MaybeLocal<Value> GetX509NameObject(Environment* env, X509* cert) {
  X509_NAME* name = get_name(cert);
  CHECK_NOT_NULL(name);

  int cnt = X509_NAME_entry_count(name);
  CHECK_GE(cnt, 0);

  Local<Object> result =
      Object::New(env->isolate(), Null(env->isolate()), nullptr, nullptr, 0);
  if (result.IsEmpty()) {
    return MaybeLocal<Value>();
  }

  for (int i = 0; i < cnt; i++) {
    X509_NAME_ENTRY* entry = X509_NAME_get_entry(name, i);
    CHECK_NOT_NULL(entry);

    // We intentionally ignore the value of X509_NAME_ENTRY_set because the
    // representation as an object does not allow grouping entries into sets
    // anyway, and multi-value RDNs are rare, i.e., the vast majority of
    // Relative Distinguished Names contains a single type-value pair only.
    const ASN1_OBJECT* type = X509_NAME_ENTRY_get_object(entry);
    const ASN1_STRING* value = X509_NAME_ENTRY_get_data(entry);

    // If OpenSSL knows the type, use the short name of the type as the key, and...",947.0,1039.0,1.0,1.0,93.0,43,9,58,22,0,0,8,13,0,0,,0,0,4,2,2,MaybeLocal<Value>
1436,28464,GetCurrentCipherValue,1,node.crypto.GetCurrentCipherValue,"MaybeLocal<Value> node.crypto.GetCurrentCipherValue<MaybeLocal<Value>(*)(Environment*, const SSL_CIPHER*)> (Environment*,SSLPointer)",crypto\crypto_common.cc,"MaybeLocal<Value> GetCurrentCipherValue(Environment* env,
                                        const SSLPointer& ssl) {
  return Get(env, SSL_get_current_cipher(ssl.get()));
}",1042.0,1045.0,1.0,1.0,4.0,1,1,2,2,0,0,1,1,0,0,,0,0,4,2,2,MaybeLocal<Value>
1437,28478,GetClientHelloCiphers,1,node.crypto.GetClientHelloCiphers,"MaybeLocal<Array> node.crypto.GetClientHelloCiphers (Environment*,SSLPointer)",crypto\crypto_common.cc,"MaybeLocal<Array> GetClientHelloCiphers(
    Environment* env,
    const SSLPointer& ssl) {
  EscapableHandleScope scope(env->isolate());
  const unsigned char* buf;
  size_t len = SSL_client_hello_get0_ciphers(ssl.get(), &buf);
  size_t count = len / 2;
  MaybeStackBuffer<Local<Value>, 16> ciphers(count);
  int j = 0;
  for (size_t n = 0; n < len; n += 2) {
    const SSL_CIPHER* cipher = SSL_CIPHER_find(ssl.get(), buf);
    buf += 2;
    Local<Object> obj = Object::New(env->isolate());
    if (!Set(env->context(),
             obj,
             env->name_string(),
             GetCipherName(env, cipher)) ||
        !Set(env->context(),
             obj,
             env->standard_name_string(),
             GetCipherStandardName(env, cipher)) ||
        !Set(env->context(),
             obj,
             env->version_string(),
             GetCipherVersion(env, cipher))) {
      return MaybeLocal<Array>();
    }
    ciphers[j++] = obj;
  }
  Local<Array> ret = Array::New(env->isola...",1047.0,1078.0,1.0,1.0,32.0,38,12,47,15,0,0,3,4,0,0,,0,0,4,2,2,MaybeLocal<Array>
1438,28632,GetCipherInfo,1,node.crypto.GetCipherInfo,"MaybeLocal<Object> node.crypto.GetCipherInfo (Environment*,SSLPointer)",crypto\crypto_common.cc,"MaybeLocal<Object> GetCipherInfo(Environment* env, const SSLPointer& ssl) {
  if (SSL_get_current_cipher(ssl.get()) == nullptr)
    return MaybeLocal<Object>();
  EscapableHandleScope scope(env->isolate());
  Local<Object> info = Object::New(env->isolate());

  if (!Set<Value>(env->context(),
                  info,
                  env->name_string(),
                  GetCurrentCipherValue<GetCipherName>(env, ssl)) ||
      !Set<Value>(env->context(),
                  info,
                  env->standard_name_string(),
                  GetCurrentCipherValue<GetCipherStandardName>(env, ssl)) ||
      !Set<Value>(env->context(),
                  info,
                  env->version_string(),
                  GetCurrentCipherValue<GetCipherVersion>(env, ssl))) {
    return MaybeLocal<Object>();
  }

  return scope.Escape(info);
}",1081.0,1103.0,1.0,1.0,23.0,20,8,24,6,0,0,3,3,0,0,,0,0,4,2,2,MaybeLocal<Object>
1439,28723,GetEphemeralKey,1,node.crypto.GetEphemeralKey,"MaybeLocal<Object> node.crypto.GetEphemeralKey (Environment*,SSLPointer)",crypto\crypto_common.cc,"MaybeLocal<Object> GetEphemeralKey(Environment* env, const SSLPointer& ssl) {
  CHECK_EQ(SSL_is_server(ssl.get()), 0);
  EVP_PKEY* raw_key;

  EscapableHandleScope scope(env->isolate());
  Local<Object> info = Object::New(env->isolate());
  if (!SSL_get_server_tmp_key(ssl.get(), &raw_key))
    return scope.Escape(info);

  Local<Context> context = env->context();
  crypto::EVPKeyPointer key(raw_key);

  int kid = EVP_PKEY_id(key.get());
  int bits = EVP_PKEY_bits(key.get());
  switch (kid) {
    case EVP_PKEY_DH:
      if (!Set<String>(context, info, env->type_string(), env->dh_string()) ||
          !Set<Integer>(context,
               info,
               env->size_string(),
               Integer::New(env->isolate(), bits))) {
        return MaybeLocal<Object>();
      }
      break;
    case EVP_PKEY_EC:
    case EVP_PKEY_X25519:
    case EVP_PKEY_X448:
      {
        const char* curve_name;
        if (kid == EVP_PKEY_EC) {
          ECKeyPointer ec(EVP_PKEY_get1_EC_KEY(key.g...",1105.0,1160.0,1.0,1.0,56.0,45,9,59,20,0,0,8,9,0,0,,0,0,4,2,2,MaybeLocal<Object>
1440,28937,ECPointToBuffer,1,node.crypto.ECPointToBuffer,"MaybeLocal<Object> node.crypto.ECPointToBuffer (Environment*,EC_GROUP*,EC_POINT*,point_conversion_form_t,char**)",crypto\crypto_common.cc,"MaybeLocal<Object> ECPointToBuffer(Environment* env,
                                   const EC_GROUP* group,
                                   const EC_POINT* point,
                                   point_conversion_form_t form,
                                   const char** error) {
  size_t len = EC_POINT_point2oct(group, point, form, nullptr, 0, nullptr);
  if (len == 0) {
    if (error != nullptr) *error = ""Failed to get public key length"";
    return MaybeLocal<Object>();
  }

  std::unique_ptr<BackingStore> bs;
  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), len);
  }

  len = EC_POINT_point2oct(group,
                           point,
                           form,
                           reinterpret_cast<unsigned char*>(bs->Data()),
                           bs->ByteLength(),
                           nullptr);
  if (len == 0) {
    if (error != nullptr) *error = ""Failed to get pub...",1162.0,1192.0,1.0,1.0,31.0,29,9,35,13,0,0,5,7,0,0,,0,0,10,5,5,MaybeLocal<Object>
1441,29065,GetPeerCert,1,node.crypto.GetPeerCert,"MaybeLocal<Value> node.crypto.GetPeerCert (Environment*,SSLPointer,bool,bool)",crypto\crypto_common.cc,"MaybeLocal<Value> GetPeerCert(
    Environment* env,
    const SSLPointer& ssl,
    bool abbreviated,
    bool is_server) {
  ClearErrorOnReturn clear_error_on_return;
  Local<Object> result;
  MaybeLocal<Object> maybe_cert;

  // NOTE: This is because of the odd OpenSSL behavior. On client `cert_chain`
  // contains the `peer_certificate`, but on server it doesn't.
  X509Pointer cert(is_server ? SSL_get_peer_certificate(ssl.get()) : nullptr);
  STACK_OF(X509)* ssl_certs = SSL_get_peer_cert_chain(ssl.get());
  if (!cert && (ssl_certs == nullptr || sk_X509_num(ssl_certs) == 0))
    return Undefined(env->isolate());

  // Short result requested.
  if (abbreviated) {
    maybe_cert =
        X509ToObject(env, cert ? cert.get() : sk_X509_value(ssl_certs, 0));
    return maybe_cert.ToLocal(&result) ? result : MaybeLocal<Value>();
  }

  StackOfX509 peer_certs = CloneSSLCerts(std::move(cert), ssl_certs);
  if (peer_certs == nullptr)
    return Undefined(env->isolate());

  // First and ma...",1194.0,1261.0,1.0,1.0,68.0,54,12,67,18,0,0,8,8,0,0,,0,0,8,4,4,MaybeLocal<Value>
1442,29285,X509ToObject,1,node.crypto.X509ToObject,"MaybeLocal<Object> node.crypto.X509ToObject (Environment*,X509*)",crypto\crypto_common.cc,"MaybeLocal<Object> X509ToObject(
    Environment* env,
    X509* cert) {
  EscapableHandleScope scope(env->isolate());
  Local<Context> context = env->context();
  Local<Object> info = Object::New(env->isolate());

  BIOPointer bio(BIO_new(BIO_s_mem()));
  CHECK(bio);

  // X509_check_ca() returns a range of values. Only 1 means ""is a CA""
  auto is_ca = Boolean::New(env->isolate(), 1 == X509_check_ca(cert));
  if (!Set<Value>(context,
                  info,
                  env->subject_string(),
                  GetX509NameObject<X509_get_subject_name>(env, cert)) ||
      !Set<Value>(context,
                  info,
                  env->issuer_string(),
                  GetX509NameObject<X509_get_issuer_name>(env, cert)) ||
      !Set<Value>(context,
                  info,
                  env->subjectaltname_string(),
                  GetSubjectAltNameString(env, bio, cert)) ||
      !Set<Value>(context,
                  info,
                  env->infoaccess_string(),...",1263.0,1409.0,1.0,1.0,147.0,74,9,124,18,0,0,10,10,0,0,,0,0,4,2,2,MaybeLocal<Object>
1443,29319,bio,1,node.crypto.X509ToObject.bio,BIOPointer node.crypto.X509ToObject.bio (BIO_new),crypto\crypto_common.cc,BIOPointer bio(BIO_new(BIO_s_mem()));,1270.0,1270.0,14.0,38.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,BIOPointer
1444,29792,GetOrCreateRootCertStore,1,node.crypto.GetOrCreateRootCertStore,X509_STORE node.crypto.GetOrCreateRootCertStore (),crypto\crypto_context.cc,"inline X509_STORE* GetOrCreateRootCertStore() {
  // Guaranteed thread-safe by standard, just don't use -fno-threadsafe-statics.
  static X509_STORE* store = NewRootCertStore();
  return store;
}",56.0,60.0,1.0,1.0,5.0,1,1,2,1,0,0,1,1,0,0,,0,0,0,0,0,X509_STORE
1445,29802,LoadBIO,1,node.crypto.LoadBIO,"BIOPointer node.crypto.LoadBIO (Environment*,Local<Value>)",crypto\crypto_context.cc,"BIOPointer LoadBIO(Environment* env, Local<Value> v) {
  HandleScope scope(env->isolate());

  if (v->IsString()) {
    Utf8Value s(env->isolate(), v);
    return NodeBIO::NewFixed(*s, s.length());
  }

  if (v->IsArrayBufferView()) {
    ArrayBufferViewContents<char> buf(v.As<ArrayBufferView>());
    return NodeBIO::NewFixed(buf.data(), buf.length());
  }

  return nullptr;
}",64.0,78.0,1.0,1.0,15.0,11,3,12,5,0,0,3,3,0,0,,0,0,4,2,2,BIOPointer
1446,29867,SSL_CTX_use_certificate_chain,1,node.crypto.anonymous_namespace_1.SSL_CTX_use_certificate_chain,"int node.crypto.anonymous_namespace_1.SSL_CTX_use_certificate_chain (SSL_CTX*,BIOPointer,X509Pointer*,X509Pointer*)",crypto\crypto_context.cc,"int SSL_CTX_use_certificate_chain(SSL_CTX* ctx,
                                  BIOPointer&& in,
                                  X509Pointer* cert,
                                  X509Pointer* issuer) {
  // Just to ensure that `ERR_peek_last_error` below will return only errors
  // that we are interested in
  ERR_clear_error();

  X509Pointer x(
      PEM_read_bio_X509_AUX(in.get(), nullptr, NoPasswordCallback, nullptr));

  if (!x)
    return 0;

  unsigned long err = 0;  // NOLINT(runtime/int)

  StackOfX509 extra_certs(sk_X509_new_null());
  if (!extra_certs)
    return 0;

  while (X509Pointer extra {PEM_read_bio_X509(in.get(),
                                    nullptr,
                                    NoPasswordCallback,
                                    nullptr)}) {
    if (sk_X509_push(extra_certs.get(), extra.get())) {
      extra.release();
      continue;
    }

    return 0;
  }

  // When the while loop ends, it's usually just EOF.
  err = ERR_peek_last_er...",150.0,197.0,1.0,1.0,48.0,13,5,19,12,0,0,7,7,0,0,,0,0,8,4,4,int
1447,29958,NewRootCertStore,1,node.crypto.NewRootCertStore,X509_STORE node.crypto.NewRootCertStore (),crypto\crypto_context.cc,"X509_STORE* NewRootCertStore() {
  static std::vector<X509*> root_certs_vector;
  static Mutex root_certs_vector_mutex;
  Mutex::ScopedLock lock(root_certs_vector_mutex);

  if (root_certs_vector.empty() &&
      per_process::cli_options->ssl_openssl_cert_store == false) {
    for (size_t i = 0; i < arraysize(root_certs); i++) {
      X509* x509 =
          PEM_read_bio_X509(NodeBIO::NewFixed(root_certs[i],
                                              strlen(root_certs[i])).get(),
                            nullptr,   // no re-use of X509 structure
                            NoPasswordCallback,
                            nullptr);  // no callback data

      // Parse errors from the built-in roots are fatal.
      CHECK_NOT_NULL(x509);

      root_certs_vector.push_back(x509);
    }
  }

  X509_STORE* store = X509_STORE_new();
  if (*system_cert_path != '\0') {
    ERR_set_mark();
    X509_STORE_load_locations(store, system_cert_path, nullptr);
    ERR_pop_to_mark();
  }

  Mute...",201.0,241.0,1.0,1.0,41.0,20,9,25,11,0,0,5,6,0,0,,0,0,0,0,0,X509_STORE
1448,30067,GetRootCertificates,1,node.crypto.GetRootCertificates,void node.crypto.GetRootCertificates (FunctionCallbackInfo<Value>),crypto\crypto_context.cc,"void GetRootCertificates(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Local<Value> result[arraysize(root_certs)];

  for (size_t i = 0; i < arraysize(root_certs); i++) {
    if (!String::NewFromOneByte(
            env->isolate(),
            reinterpret_cast<const uint8_t*>(root_certs[i]))
            .ToLocal(&result[i])) {
      return;
    }
  }

  args.GetReturnValue().Set(
      Array::New(env->isolate(), result, arraysize(root_certs)));
}",243.0,258.0,1.0,1.0,16.0,19,9,21,10,0,0,3,4,0,0,,0,0,2,1,1,void
1449,30143,HasInstance,1,node.crypto.SecureContext.HasInstance,"bool node.crypto.SecureContext.HasInstance (Environment*,Local<Value>)",crypto\crypto_context.cc,"bool SecureContext::HasInstance(Environment* env, const Local<Value>& value) {
  return GetConstructorTemplate(env)->HasInstance(value);
}",260.0,262.0,1.0,1.0,3.0,1,1,2,2,0,0,1,1,0,0,,0,0,4,2,2,bool
1450,30156,GetConstructorTemplate,1,node.crypto.SecureContext.GetConstructorTemplate,Local<FunctionTemplate> node.crypto.SecureContext.GetConstructorTemplate (Environment*),crypto\crypto_context.cc,"Local<FunctionTemplate> SecureContext::GetConstructorTemplate(
    Environment* env) {
  Local<FunctionTemplate> tmpl = env->secure_context_constructor_template();
  if (tmpl.IsEmpty()) {
    Isolate* isolate = env->isolate();
    tmpl = NewFunctionTemplate(isolate, New);
    tmpl->InstanceTemplate()->SetInternalFieldCount(
        SecureContext::kInternalFieldCount);
    tmpl->SetClassName(FIXED_ONE_BYTE_STRING(env->isolate(), ""SecureContext""));

    SetProtoMethod(isolate, tmpl, ""init"", Init);
    SetProtoMethod(isolate, tmpl, ""setKey"", SetKey);
    SetProtoMethod(isolate, tmpl, ""setCert"", SetCert);
    SetProtoMethod(isolate, tmpl, ""addCACert"", AddCACert);
    SetProtoMethod(isolate, tmpl, ""addCRL"", AddCRL);
    SetProtoMethod(isolate, tmpl, ""addRootCerts"", AddRootCerts);
    SetProtoMethod(isolate, tmpl, ""setCipherSuites"", SetCipherSuites);
    SetProtoMethod(isolate, tmpl, ""setCiphers"", SetCiphers);
    SetProtoMethod(isolate, tmpl, ""setSigalgs"", SetSigalgs);
    SetProtoMethod...",264.0,331.0,1.0,4.0,68.0,33,7,142,49,0,0,2,2,0,0,,0,0,2,1,1,Local<FunctionTemplate>
1451,30472,Initialize,1,node.crypto.SecureContext.Initialize,"void node.crypto.SecureContext.Initialize (Environment*,Local<Object>)",crypto\crypto_context.cc,"void SecureContext::Initialize(Environment* env, Local<Object> target) {
  Local<Context> context = env->context();
  SetConstructorFunction(context,
                         target,
                         ""SecureContext"",
                         GetConstructorTemplate(env),
                         SetConstructorFunctionFlag::NONE);

  SetMethodNoSideEffect(
      context, target, ""getRootCertificates"", GetRootCertificates);
  // Exposed for testing purposes only.
  SetMethodNoSideEffect(context,
                        target,
                        ""isExtraRootCertsFileLoaded"",
                        IsExtraRootCertsFileLoaded);
}",333.0,348.0,1.0,1.0,16.0,5,5,14,8,0,0,1,1,0,0,,0,0,4,2,2,void
1452,30507,RegisterExternalReferences,1,node.crypto.SecureContext.RegisterExternalReferences,void node.crypto.SecureContext.RegisterExternalReferences (ExternalReferenceRegistry*),crypto\crypto_context.cc,"void SecureContext::RegisterExternalReferences(
    ExternalReferenceRegistry* registry) {
  registry->Register(New);
  registry->Register(Init);
  registry->Register(SetKey);
  registry->Register(SetCert);
  registry->Register(AddCACert);
  registry->Register(AddCRL);
  registry->Register(AddRootCerts);
  registry->Register(SetCipherSuites);
  registry->Register(SetCiphers);
  registry->Register(SetSigalgs);
  registry->Register(SetECDHCurve);
  registry->Register(SetDHParam);
  registry->Register(SetMaxProto);
  registry->Register(SetMinProto);
  registry->Register(GetMaxProto);
  registry->Register(GetMinProto);
  registry->Register(SetOptions);
  registry->Register(SetSessionIdContext);
  registry->Register(SetSessionTimeout);
  registry->Register(Close);
  registry->Register(LoadPKCS12);
  registry->Register(SetTicketKeys);
  registry->Register(EnableTicketKeyCallback);
  registry->Register(GetTicketKeys);
  registry->Register(GetCertificate<true>);
  registry->Register(GetCert...",350.0,388.0,1.0,1.0,39.0,31,1,62,32,0,0,1,1,0,0,,0,0,2,1,1,void
1453,30667,Create,1,node.crypto.SecureContext.Create,SecureContext node.crypto.SecureContext.Create (Environment*),crypto\crypto_context.cc,"SecureContext* SecureContext::Create(Environment* env) {
  Local<Object> obj;
  if (!GetConstructorTemplate(env)
          ->InstanceTemplate()
          ->NewInstance(env->context()).ToLocal(&obj)) {
    return nullptr;
  }

  return new SecureContext(env, obj);
}",390.0,399.0,1.0,1.0,10.0,9,7,9,5,0,0,2,2,0,0,,0,0,2,1,1,SecureContext
1454,30704,SecureContext,1,node.crypto.SecureContext.SecureContext,"ANY node.crypto.SecureContext.SecureContext (Environment*,Local<Object>)",crypto\crypto_context.cc,"SecureContext::SecureContext(Environment* env, Local<Object> wrap)
    : BaseObject(env, wrap) {
  MakeWeak();
  env->isolate()->AdjustAmountOfExternalAllocatedMemory(kExternalSize);
}",401.0,405.0,1.0,1.0,5.0,2,1,2,2,0,0,1,1,0,0,,0,0,4,2,2,ANY
1455,30719,Reset,1,node.crypto.SecureContext.Reset,void node.crypto.SecureContext.Reset (),crypto\crypto_context.cc,"inline void SecureContext::Reset() {
  if (ctx_ != nullptr) {
    env()->isolate()->AdjustAmountOfExternalAllocatedMemory(-kExternalSize);
  }
  ctx_.reset();
  cert_.reset();
  issuer_.reset();
}",407.0,414.0,1.0,1.0,8.0,7,4,5,4,0,0,2,2,0,0,,0,0,0,0,0,void
1456,30749,~SecureContext,1,node.crypto.SecureContext.~SecureContext,ANY node.crypto.SecureContext.~SecureContext (),crypto\crypto_context.cc,"SecureContext::~SecureContext() {
  Reset();
}",416.0,418.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
1457,30754,New,1,node.crypto.SecureContext.New,void node.crypto.SecureContext.New (FunctionCallbackInfo<Value>),crypto\crypto_context.cc,"void SecureContext::New(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  new SecureContext(env, args.This());
}",420.0,423.0,1.0,1.0,4.0,4,3,6,4,0,0,1,1,0,0,,0,0,2,1,1,void
1458,30774,Init,1,node.crypto.SecureContext.Init,void node.crypto.SecureContext.Init (FunctionCallbackInfo<Value>),crypto\crypto_context.cc,"void SecureContext::Init(const FunctionCallbackInfo<Value>& args) {
  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());
  Environment* env = sc->env();

  CHECK_EQ(args.Length(), 3);
  CHECK(args[1]->IsInt32());
  CHECK(args[2]->IsInt32());

  int min_version = args[1].As<Int32>()->Value();
  int max_version = args[2].As<Int32>()->Value();
  const SSL_METHOD* method = TLS_method();

  if (max_version == 0)
    max_version = kMaxSupportedVersion;

  if (args[0]->IsString()) {
    Utf8Value sslmethod(env->isolate(), args[0]);

    // Note that SSLv2 and SSLv3 are disallowed but SSLv23_method and friends
    // are still accepted.  They are OpenSSL's way of saying that all known
    // protocols below TLS 1.3 are supported unless explicitly disabled (which
    // we do below for SSLv2 and SSLv3.)
    if (sslmethod == ""SSLv2_method"" ||
        sslmethod == ""SSLv2_server_method"" ||
        sslmethod == ""SSLv2_client_method"") {
      THROW_ERR_TLS_INVALID_PROTOCOL_METHOD(e...",425.0,558.0,1.0,1.0,134.0,66,10,52,16,0,0,6,7,0,0,,0,0,2,1,1,void
1459,31257,CreateSSL,1,node.crypto.SecureContext.CreateSSL,SSLPointer node.crypto.SecureContext.CreateSSL (),crypto\crypto_context.cc,"SSLPointer SecureContext::CreateSSL() {
  return SSLPointer(SSL_new(ctx_.get()));
}",560.0,562.0,1.0,1.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,SSLPointer
1460,31268,SetNewSessionCallback,1,node.crypto.SecureContext.SetNewSessionCallback,void node.crypto.SecureContext.SetNewSessionCallback (NewSessionCb),crypto\crypto_context.cc,"void SecureContext::SetNewSessionCallback(NewSessionCb cb) {
  SSL_CTX_sess_set_new_cb(ctx_.get(), cb);
}",564.0,566.0,1.0,1.0,3.0,1,1,2,2,0,0,1,1,0,0,,0,0,2,1,1,void
1461,31279,SetGetSessionCallback,1,node.crypto.SecureContext.SetGetSessionCallback,void node.crypto.SecureContext.SetGetSessionCallback (GetSessionCb),crypto\crypto_context.cc,"void SecureContext::SetGetSessionCallback(GetSessionCb cb) {
  SSL_CTX_sess_set_get_cb(ctx_.get(), cb);
}",568.0,570.0,1.0,1.0,3.0,1,1,2,2,0,0,1,1,0,0,,0,0,2,1,1,void
1462,31290,SetSelectSNIContextCallback,1,node.crypto.SecureContext.SetSelectSNIContextCallback,void node.crypto.SecureContext.SetSelectSNIContextCallback (SelectSNIContextCb),crypto\crypto_context.cc,"void SecureContext::SetSelectSNIContextCallback(SelectSNIContextCb cb) {
  SSL_CTX_set_tlsext_servername_callback(ctx_.get(), cb);
}",572.0,574.0,1.0,1.0,3.0,1,1,2,2,0,0,1,1,0,0,,0,0,2,1,1,void
1463,31301,SetKeylogCallback,1,node.crypto.SecureContext.SetKeylogCallback,void node.crypto.SecureContext.SetKeylogCallback (KeylogCb),crypto\crypto_context.cc,"void SecureContext::SetKeylogCallback(KeylogCb cb) {
  SSL_CTX_set_keylog_callback(ctx_.get(), cb);
}",576.0,578.0,1.0,1.0,3.0,1,1,2,2,0,0,1,1,0,0,,0,0,2,1,1,void
1464,31312,UseKey,1,node.crypto.SecureContext.UseKey,"Maybe<bool> node.crypto.SecureContext.UseKey (Environment*,ANY)",crypto\crypto_context.cc,"Maybe<bool> SecureContext::UseKey(Environment* env,
                                  std::shared_ptr<KeyObjectData> key) {
  if (key->GetKeyType() != KeyType::kKeyTypePrivate) {
    THROW_ERR_CRYPTO_INVALID_KEYTYPE(env);
    return Nothing<bool>();
  }

  ClearErrorOnReturn clear_error_on_return;
  if (!SSL_CTX_use_PrivateKey(ctx_.get(), key->GetAsymmetricKey().get())) {
    ThrowCryptoError(env, ERR_get_error(), ""SSL_CTX_use_PrivateKey"");
    return Nothing<bool>();
  }

  return Just(true);
}",580.0,594.0,1.0,1.0,15.0,7,4,6,4,0,0,3,3,0,0,,0,0,4,2,2,Maybe<bool>
1465,31357,SetKey,1,node.crypto.SecureContext.SetKey,void node.crypto.SecureContext.SetKey (FunctionCallbackInfo<Value>),crypto\crypto_context.cc,"void SecureContext::SetKey(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());

  CHECK_GE(args.Length(), 1);  // Private key argument is mandatory

  BIOPointer bio(LoadBIO(env, args[0]));
  if (!bio)
    return;

  ByteSource passphrase;
  if (args[1]->IsString())
    passphrase = ByteSource::FromString(env, args[1].As<String>());
  // This redirection is necessary because the PasswordCallback expects a
  // pointer to a pointer to the passphrase ByteSource to allow passing in
  // const ByteSources.
  const ByteSource* pass_ptr = &passphrase;

  EVPKeyPointer key(
      PEM_read_bio_PrivateKey(bio.get(),
                              nullptr,
                              PasswordCallback,
                              &pass_ptr));

  if (!key)
    return ThrowCryptoError(env, ERR_get_error(), ""PEM_read_bio_PrivateKey"");

  if (!SSL_CTX_use_PrivateKey(sc->ctx_.get(), ke...",596.0,627.0,1.0,1.0,32.0,22,6,24,10,0,0,5,5,0,0,,0,0,2,1,1,void
1466,31462,SetSigalgs,1,node.crypto.SecureContext.SetSigalgs,void node.crypto.SecureContext.SetSigalgs (FunctionCallbackInfo<Value>),crypto\crypto_context.cc,"void SecureContext::SetSigalgs(const FunctionCallbackInfo<Value>& args) {
  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());
  Environment* env = sc->env();
  ClearErrorOnReturn clear_error_on_return;

  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsString());

  const Utf8Value sigalgs(env->isolate(), args[0]);

  if (!SSL_CTX_set1_sigalgs_list(sc->ctx_.get(), *sigalgs))
    return ThrowCryptoError(env, ERR_get_error());
}",629.0,642.0,1.0,1.0,14.0,13,7,11,4,0,0,2,2,0,0,,0,0,2,1,1,void
1467,31521,SetEngineKey,1,node.crypto.SecureContext.SetEngineKey,void node.crypto.SecureContext.SetEngineKey (FunctionCallbackInfo<Value>),crypto\crypto_context.cc,"void SecureContext::SetEngineKey(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());

  CHECK_EQ(args.Length(), 2);

  CryptoErrorStore errors;
  Utf8Value engine_id(env->isolate(), args[1]);
  EnginePointer engine = LoadEngineById(*engine_id, &errors);
  if (!engine) {
    Local<Value> exception;
    if (errors.ToException(env).ToLocal(&exception))
      env->isolate()->ThrowException(exception);
    return;
  }

  if (!ENGINE_init(engine.get())) {
    return THROW_ERR_CRYPTO_OPERATION_FAILED(
        env, ""Failure to initialize engine"");
  }

  engine.finish_on_exit = true;

  Utf8Value key_name(env->isolate(), args[0]);
  EVPKeyPointer key(ENGINE_load_private_key(engine.get(), *key_name,
                                            nullptr, nullptr));

  if (!key)
    return ThrowCryptoError(env, ERR_get_error(), ""ENGINE_load_private_key"");

  if (!SSL_CTX_use_PrivateKey...",645.0,681.0,1.0,1.0,37.0,34,9,35,13,0,0,6,7,0,0,,0,0,2,1,1,void
1468,31670,AddCert,1,node.crypto.SecureContext.AddCert,"Maybe<bool> node.crypto.SecureContext.AddCert (Environment*,BIOPointer)",crypto\crypto_context.cc,"Maybe<bool> SecureContext::AddCert(Environment* env, BIOPointer&& bio) {
  ClearErrorOnReturn clear_error_on_return;
  if (!bio) return Just(false);
  cert_.reset();
  issuer_.reset();

  // The SSL_CTX_use_certificate_chain call here is not from openssl, this is
  // the method implemented elsewhere in this file. The naming is a bit
  // confusing, unfortunately.
  if (SSL_CTX_use_certificate_chain(
          ctx_.get(), std::move(bio), &cert_, &issuer_) == 0) {
    ThrowCryptoError(env, ERR_get_error(), ""SSL_CTX_use_certificate_chain"");
    return Nothing<bool>();
  }
  return Just(true);
}",684.0,699.0,1.0,1.0,16.0,8,4,9,6,0,0,3,3,0,0,,0,0,4,2,2,Maybe<bool>
1469,31719,SetCert,1,node.crypto.SecureContext.SetCert,void node.crypto.SecureContext.SetCert (FunctionCallbackInfo<Value>),crypto\crypto_context.cc,"void SecureContext::SetCert(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());

  CHECK_GE(args.Length(), 1);  // Certificate argument is mandatory

  BIOPointer bio(LoadBIO(env, args[0]));
  USE(sc->AddCert(env, std::move(bio)));
}",701.0,711.0,1.0,1.0,11.0,8,5,12,6,0,0,1,1,0,0,,0,0,2,1,1,void
1470,31764,SetCACert,1,node.crypto.SecureContext.SetCACert,void node.crypto.SecureContext.SetCACert (BIOPointer),crypto\crypto_context.cc,"void SecureContext::SetCACert(const BIOPointer& bio) {
  ClearErrorOnReturn clear_error_on_return;
  if (!bio) return;
  X509_STORE* cert_store = SSL_CTX_get_cert_store(ctx_.get());
  while (X509Pointer x509 = X509Pointer(PEM_read_bio_X509_AUX(
             bio.get(), nullptr, NoPasswordCallback, nullptr))) {
    if (cert_store == GetOrCreateRootCertStore()) {
      cert_store = NewRootCertStore();
      SSL_CTX_set_cert_store(ctx_.get(), cert_store);
    }
    CHECK_EQ(1, X509_STORE_add_cert(cert_store, x509.get()));
    CHECK_EQ(1, SSL_CTX_add_client_CA(ctx_.get(), x509.get()));
  }
}",713.0,726.0,1.0,1.0,14.0,9,4,11,4,0,0,4,5,0,0,,0,0,2,1,1,void
1471,31818,AddCACert,1,node.crypto.SecureContext.AddCACert,void node.crypto.SecureContext.AddCACert (FunctionCallbackInfo<Value>),crypto\crypto_context.cc,"void SecureContext::AddCACert(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());

  CHECK_GE(args.Length(), 1);  // CA certificate argument is mandatory

  BIOPointer bio(LoadBIO(env, args[0]));
  sc->SetCACert(bio);
}",728.0,738.0,1.0,1.0,11.0,7,5,10,5,0,0,1,1,0,0,,0,0,2,1,1,void
1472,31857,SetCRL,1,node.crypto.SecureContext.SetCRL,"Maybe<bool> node.crypto.SecureContext.SetCRL (Environment*,BIOPointer)",crypto\crypto_context.cc,"Maybe<bool> SecureContext::SetCRL(Environment* env, const BIOPointer& bio) {
  ClearErrorOnReturn clear_error_on_return;
  if (!bio) return Just(false);

  DeleteFnPtr<X509_CRL, X509_CRL_free> crl(
      PEM_read_bio_X509_CRL(bio.get(), nullptr, NoPasswordCallback, nullptr));

  if (!crl) {
    THROW_ERR_CRYPTO_OPERATION_FAILED(env, ""Failed to parse CRL"");
    return Nothing<bool>();
  }

  X509_STORE* cert_store = SSL_CTX_get_cert_store(ctx_.get());
  if (cert_store == GetOrCreateRootCertStore()) {
    cert_store = NewRootCertStore();
    SSL_CTX_set_cert_store(ctx_.get(), cert_store);
  }

  CHECK_EQ(1, X509_STORE_add_crl(cert_store, crl.get()));
  CHECK_EQ(1,
           X509_STORE_set_flags(
               cert_store, X509_V_FLAG_CRL_CHECK | X509_V_FLAG_CRL_CHECK_ALL));
  return Just(true);
}",740.0,763.0,1.0,1.0,24.0,13,8,19,11,0,0,4,4,0,0,,0,0,4,2,2,Maybe<bool>
1473,31935,AddCRL,1,node.crypto.SecureContext.AddCRL,void node.crypto.SecureContext.AddCRL (FunctionCallbackInfo<Value>),crypto\crypto_context.cc,"void SecureContext::AddCRL(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());

  CHECK_GE(args.Length(), 1);  // CRL argument is mandatory

  BIOPointer bio(LoadBIO(env, args[0]));
  USE(sc->SetCRL(env, bio));
}",765.0,775.0,1.0,1.0,11.0,7,5,11,5,0,0,1,1,0,0,,0,0,2,1,1,void
1474,31976,SetRootCerts,1,node.crypto.SecureContext.SetRootCerts,void node.crypto.SecureContext.SetRootCerts (),crypto\crypto_context.cc,"void SecureContext::SetRootCerts() {
  ClearErrorOnReturn clear_error_on_return;
  auto store = GetOrCreateRootCertStore();

  // Increment reference count so global store is not deleted along with CTX.
  X509_STORE_up_ref(store);
  SSL_CTX_set_cert_store(ctx_.get(), store);
}",777.0,784.0,1.0,1.0,8.0,2,2,4,2,0,0,1,1,0,0,,0,0,0,0,0,void
1475,31993,AddRootCerts,1,node.crypto.SecureContext.AddRootCerts,void node.crypto.SecureContext.AddRootCerts (FunctionCallbackInfo<Value>),crypto\crypto_context.cc,"void SecureContext::AddRootCerts(const FunctionCallbackInfo<Value>& args) {
  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());
  sc->SetRootCerts();
}",786.0,790.0,1.0,1.0,5.0,3,3,3,2,0,0,1,1,0,0,,0,0,2,1,1,void
1476,32010,SetCipherSuites,1,node.crypto.SecureContext.SetCipherSuites,void node.crypto.SecureContext.SetCipherSuites (FunctionCallbackInfo<Value>),crypto\crypto_context.cc,"void SecureContext::SetCipherSuites(const FunctionCallbackInfo<Value>& args) {
  // BoringSSL doesn't allow API config of TLS1.3 cipher suites.
#ifndef OPENSSL_IS_BORINGSSL
  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());
  Environment* env = sc->env();
  ClearErrorOnReturn clear_error_on_return;

  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsString());

  const Utf8Value ciphers(env->isolate(), args[0]);
  if (!SSL_CTX_set_ciphersuites(sc->ctx_.get(), *ciphers))
    return ThrowCryptoError(env, ERR_get_error(), ""Failed to set ciphers"");
#endif
}",792.0,807.0,1.0,1.0,16.0,13,7,11,4,0,0,2,2,0,0,,0,0,2,1,1,void
1477,32070,SetCiphers,1,node.crypto.SecureContext.SetCiphers,void node.crypto.SecureContext.SetCiphers (FunctionCallbackInfo<Value>),crypto\crypto_context.cc,"void SecureContext::SetCiphers(const FunctionCallbackInfo<Value>& args) {
  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());
  Environment* env = sc->env();
  ClearErrorOnReturn clear_error_on_return;

  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsString());

  Utf8Value ciphers(env->isolate(), args[0]);
  if (!SSL_CTX_set_cipher_list(sc->ctx_.get(), *ciphers)) {
    unsigned long err = ERR_get_error();  // NOLINT(runtime/int)

    if (strlen(*ciphers) == 0 && ERR_GET_REASON(err) == SSL_R_NO_CIPHER_MATCH) {
      // TLS1.2 ciphers were deliberately cleared, so don't consider
      // SSL_R_NO_CIPHER_MATCH to be an error (this is how _set_cipher_suites()
      // works). If the user actually sets a value (like ""no-such-cipher""), then
      // that's actually an error.
      return;
    }
    return ThrowCryptoError(env, err, ""Failed to set ciphers"");
  }
}",809.0,831.0,1.0,1.0,23.0,18,9,16,6,0,0,3,4,0,0,,0,0,2,1,1,void
1478,32147,SetECDHCurve,1,node.crypto.SecureContext.SetECDHCurve,void node.crypto.SecureContext.SetECDHCurve (FunctionCallbackInfo<Value>),crypto\crypto_context.cc,"void SecureContext::SetECDHCurve(const FunctionCallbackInfo<Value>& args) {
  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());
  Environment* env = sc->env();

  CHECK_GE(args.Length(), 1);  // ECDH curve name argument is mandatory
  CHECK(args[0]->IsString());

  Utf8Value curve(env->isolate(), args[0]);

  if (curve != ""auto"" && !SSL_CTX_set1_curves_list(sc->ctx_.get(), *curve)) {
    return THROW_ERR_CRYPTO_OPERATION_FAILED(env, ""Failed to set ECDH curve"");
  }
}",833.0,846.0,1.0,1.0,14.0,15,9,12,4,0,0,2,2,0,0,,0,0,2,1,1,void
1479,32209,SetDHParam,1,node.crypto.SecureContext.SetDHParam,void node.crypto.SecureContext.SetDHParam (FunctionCallbackInfo<Value>),crypto\crypto_context.cc,"void SecureContext::SetDHParam(const FunctionCallbackInfo<Value>& args) {
  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.This());
  Environment* env = sc->env();
  ClearErrorOnReturn clear_error_on_return;

  CHECK_GE(args.Length(), 1);  // DH argument is mandatory

  // If the user specified ""auto"" for dhparams, the JavaScript layer will pass
  // true to this function instead of the original string. Any other string
  // value will be interpreted as custom DH parameters below.
  if (args[0]->IsTrue()) {
    CHECK(SSL_CTX_set_dh_auto(sc->ctx_.get(), true));
    return;
  }

  DHPointer dh;
  {
    BIOPointer bio(LoadBIO(env, args[0]));
    if (!bio)
      return;

    dh.reset(PEM_read_bio_DHparams(bio.get(), nullptr, nullptr, nullptr));
  }

  // Invalid dhparam is silently discarded and DHE is no longer used.
  // TODO(tniessen): don't silently discard invalid dhparam.
  if (!dh)
    return;

  const BIGNUM* p;
  DH_get0_pqg(dh.get(), &p, nullptr, nullptr);
  const int ...",848.0,893.0,1.0,1.0,46.0,22,7,22,7,0,0,6,6,0,0,,0,0,2,1,1,void
1480,32347,SetMinProto,1,node.crypto.SecureContext.SetMinProto,void node.crypto.SecureContext.SetMinProto (FunctionCallbackInfo<Value>),crypto\crypto_context.cc,"void SecureContext::SetMinProto(const FunctionCallbackInfo<Value>& args) {
  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());

  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsInt32());

  int version = args[0].As<Int32>()->Value();

  CHECK(SSL_CTX_set_min_proto_version(sc->ctx_.get(), version));
}",895.0,905.0,1.0,1.0,11.0,11,5,8,3,0,0,1,1,0,0,,0,0,2,1,1,void
1481,32394,SetMaxProto,1,node.crypto.SecureContext.SetMaxProto,void node.crypto.SecureContext.SetMaxProto (FunctionCallbackInfo<Value>),crypto\crypto_context.cc,"void SecureContext::SetMaxProto(const FunctionCallbackInfo<Value>& args) {
  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());

  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsInt32());

  int version = args[0].As<Int32>()->Value();

  CHECK(SSL_CTX_set_max_proto_version(sc->ctx_.get(), version));
}",907.0,917.0,1.0,1.0,11.0,11,5,8,3,0,0,1,1,0,0,,0,0,2,1,1,void
1482,32441,GetMinProto,1,node.crypto.SecureContext.GetMinProto,void node.crypto.SecureContext.GetMinProto (FunctionCallbackInfo<Value>),crypto\crypto_context.cc,"void SecureContext::GetMinProto(const FunctionCallbackInfo<Value>& args) {
  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());

  CHECK_EQ(args.Length(), 0);

  long version =  // NOLINT(runtime/int)
    SSL_CTX_get_min_proto_version(sc->ctx_.get());
  args.GetReturnValue().Set(static_cast<uint32_t>(version));
}",919.0,928.0,1.0,1.0,10.0,9,5,7,3,0,0,1,1,0,0,,0,0,2,1,1,void
1483,32480,GetMaxProto,1,node.crypto.SecureContext.GetMaxProto,void node.crypto.SecureContext.GetMaxProto (FunctionCallbackInfo<Value>),crypto\crypto_context.cc,"void SecureContext::GetMaxProto(const FunctionCallbackInfo<Value>& args) {
  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());

  CHECK_EQ(args.Length(), 0);

  long version =  // NOLINT(runtime/int)
    SSL_CTX_get_max_proto_version(sc->ctx_.get());
  args.GetReturnValue().Set(static_cast<uint32_t>(version));
}",930.0,939.0,1.0,1.0,10.0,9,5,7,3,0,0,1,1,0,0,,0,0,2,1,1,void
1484,32519,SetOptions,1,node.crypto.SecureContext.SetOptions,void node.crypto.SecureContext.SetOptions (FunctionCallbackInfo<Value>),crypto\crypto_context.cc,"void SecureContext::SetOptions(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());

  CHECK_GE(args.Length(), 1);
  CHECK(args[0]->IsNumber());

  int64_t val = args[0]->IntegerValue(env->context()).FromMaybe(0);

  SSL_CTX_set_options(sc->ctx_.get(),
                      static_cast<long>(val));  // NOLINT(runtime/int)
}",941.0,953.0,1.0,1.0,13.0,15,6,12,5,0,0,1,1,0,0,,0,0,2,1,1,void
1485,32580,SetSessionIdContext,1,node.crypto.SecureContext.SetSessionIdContext,void node.crypto.SecureContext.SetSessionIdContext (FunctionCallbackInfo<Value>),crypto\crypto_context.cc,"void SecureContext::SetSessionIdContext(
    const FunctionCallbackInfo<Value>& args) {
  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());
  Environment* env = sc->env();

  CHECK_GE(args.Length(), 1);
  CHECK(args[0]->IsString());

  const Utf8Value sessionIdContext(env->isolate(), args[0]);
  const unsigned char* sid_ctx =
      reinterpret_cast<const unsigned char*>(*sessionIdContext);
  unsigned int sid_ctx_len = sessionIdContext.length();

  if (SSL_CTX_set_session_id_context(sc->ctx_.get(), sid_ctx, sid_ctx_len) == 1)
    return;

  BUF_MEM* mem;
  Local<String> message;

  BIOPointer bio(BIO_new(BIO_s_mem()));
  if (!bio) {
    message = FIXED_ONE_BYTE_STRING(env->isolate(),
                                    ""SSL_CTX_set_session_id_context error"");
  } else {
    ERR_print_errors(bio.get());
    BIO_get_mem_ptr(bio.get(), &mem);
    message = OneByteString(env->isolate(), mem->data, mem->length);
  }

  env->isolate()->ThrowException(Exception::TypeError(me...",955.0,986.0,1.0,1.0,32.0,25,11,24,11,0,0,3,3,0,0,,0,0,2,1,1,void
1486,32654,bio,1,node.crypto.SecureContext.SetSessionIdContext.bio,BIOPointer node.crypto.SecureContext.SetSessionIdContext.bio (BIO_new),crypto\crypto_context.cc,BIOPointer bio(BIO_new(BIO_s_mem()));,975.0,975.0,14.0,38.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,BIOPointer
1487,32712,SetSessionTimeout,1,node.crypto.SecureContext.SetSessionTimeout,void node.crypto.SecureContext.SetSessionTimeout (FunctionCallbackInfo<Value>),crypto\crypto_context.cc,"void SecureContext::SetSessionTimeout(const FunctionCallbackInfo<Value>& args) {
  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());

  CHECK_GE(args.Length(), 1);
  CHECK(args[0]->IsInt32());

  int32_t sessionTimeout = args[0].As<Int32>()->Value();
  SSL_CTX_set_timeout(sc->ctx_.get(), sessionTimeout);
}",988.0,997.0,1.0,1.0,10.0,11,5,8,3,0,0,1,1,0,0,,0,0,2,1,1,void
1488,32758,Close,1,node.crypto.SecureContext.Close,void node.crypto.SecureContext.Close (FunctionCallbackInfo<Value>),crypto\crypto_context.cc,"void SecureContext::Close(const FunctionCallbackInfo<Value>& args) {
  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());
  sc->Reset();
}",999.0,1003.0,1.0,1.0,5.0,3,3,3,2,0,0,1,1,0,0,,0,0,2,1,1,void
1489,32775,LoadPKCS12,1,node.crypto.SecureContext.LoadPKCS12,void node.crypto.SecureContext.LoadPKCS12 (FunctionCallbackInfo<Value>),crypto\crypto_context.cc,"void SecureContext::LoadPKCS12(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  std::vector<char> pass;
  bool ret = false;

  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());
  ClearErrorOnReturn clear_error_on_return;

  if (args.Length() < 1) {
    return THROW_ERR_MISSING_ARGS(env, ""PFX certificate argument is mandatory"");
  }

  BIOPointer in(LoadBIO(env, args[0]));
  if (!in) {
    return THROW_ERR_CRYPTO_OPERATION_FAILED(
        env, ""Unable to load PFX certificate"");
  }

  if (args.Length() >= 2) {
    THROW_AND_RETURN_IF_NOT_BUFFER(env, args[1], ""Pass phrase"");
    Local<ArrayBufferView> abv = args[1].As<ArrayBufferView>();
    size_t passlen = abv->ByteLength();
    pass.resize(passlen + 1);
    abv->CopyContents(pass.data(), passlen);
    pass[passlen] = '\0';
  }

  // Free previous certs
  sc->issuer_.reset();
  sc->cert_.reset();

  X509_STORE* cert_store = SSL_CTX_get_cert_store(sc->ctx_.get());

  De...",1006.0,1086.0,1.0,1.0,81.0,90,17,88,29,0,0,8,11,0,0,,0,0,2,1,1,void
1490,33105,SetClientCertEngine,1,node.crypto.SecureContext.SetClientCertEngine,void node.crypto.SecureContext.SetClientCertEngine (FunctionCallbackInfo<Value>),crypto\crypto_context.cc,"void SecureContext::SetClientCertEngine(
    const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsString());

  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, args.Holder());

  MarkPopErrorOnReturn mark_pop_error_on_return;

  // SSL_CTX_set_client_cert_engine does not itself support multiple
  // calls by cleaning up before overwriting the client_cert_engine
  // internal context variable.
  // Instead of trying to fix up this problem we in turn also do not
  // support multiple calls to SetClientCertEngine.
  CHECK(!sc->client_cert_engine_provided_);

  CryptoErrorStore errors;
  const Utf8Value engine_id(env->isolate(), args[0]);
  EnginePointer engine = LoadEngineById(*engine_id, &errors);
  if (!engine) {
    Local<Value> exception;
    if (errors.ToException(env).ToLocal(&exception))
      env->isolate()->ThrowException(exception);
    return;
  }

  // Note that this takes another r...",1089.0,1121.0,1.0,1.0,33.0,28,9,26,10,0,0,4,5,0,0,,0,0,2,1,1,void
1491,33216,GetTicketKeys,1,node.crypto.SecureContext.GetTicketKeys,void node.crypto.SecureContext.GetTicketKeys (FunctionCallbackInfo<Value>),crypto\crypto_context.cc,"void SecureContext::GetTicketKeys(const FunctionCallbackInfo<Value>& args) {
  SecureContext* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  Local<Object> buff;
  if (!Buffer::New(wrap->env(), 48).ToLocal(&buff))
    return;

  memcpy(Buffer::Data(buff), wrap->ticket_key_name_, 16);
  memcpy(Buffer::Data(buff) + 16, wrap->ticket_key_hmac_, 16);
  memcpy(Buffer::Data(buff) + 32, wrap->ticket_key_aes_, 16);

  args.GetReturnValue().Set(buff);
}",1124.0,1137.0,1.0,1.0,14.0,19,7,19,6,0,0,2,2,0,0,,0,0,2,1,1,void
1492,33294,SetTicketKeys,1,node.crypto.SecureContext.SetTicketKeys,void node.crypto.SecureContext.SetTicketKeys (FunctionCallbackInfo<Value>),crypto\crypto_context.cc,"void SecureContext::SetTicketKeys(const FunctionCallbackInfo<Value>& args) {
  SecureContext* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  CHECK_GE(args.Length(), 1);  // Ticket keys argument is mandatory
  CHECK(args[0]->IsArrayBufferView());
  ArrayBufferViewContents<char> buf(args[0].As<ArrayBufferView>());

  CHECK_EQ(buf.length(), 48);

  memcpy(wrap->ticket_key_name_, buf.data(), 16);
  memcpy(wrap->ticket_key_hmac_, buf.data() + 16, 16);
  memcpy(wrap->ticket_key_aes_, buf.data() + 32, 16);

  args.GetReturnValue().Set(true);
}",1139.0,1154.0,1.0,1.0,16.0,18,5,13,3,0,0,1,1,0,0,,0,0,2,1,1,void
1493,33373,EnableTicketKeyCallback,1,node.crypto.SecureContext.EnableTicketKeyCallback,void node.crypto.SecureContext.EnableTicketKeyCallback (FunctionCallbackInfo<Value>),crypto\crypto_context.cc,"void SecureContext::EnableTicketKeyCallback(
    const FunctionCallbackInfo<Value>& args) {
  SecureContext* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  SSL_CTX_set_tlsext_ticket_key_cb(wrap->ctx_.get(), TicketKeyCallback);
}",1158.0,1164.0,1.0,1.0,7.0,4,3,4,3,0,0,1,1,0,0,,0,0,2,1,1,void
1494,33394,TicketKeyCallback,1,node.crypto.SecureContext.TicketKeyCallback,"int node.crypto.SecureContext.TicketKeyCallback (SSL*,unsigned char*,unsigned char*,EVP_CIPHER_CTX*,HMAC_CTX*,int)",crypto\crypto_context.cc,"int SecureContext::TicketKeyCallback(SSL* ssl,
                                     unsigned char* name,
                                     unsigned char* iv,
                                     EVP_CIPHER_CTX* ectx,
                                     HMAC_CTX* hctx,
                                     int enc) {
  static const int kTicketPartSize = 16;

  SecureContext* sc = static_cast<SecureContext*>(
      SSL_CTX_get_app_data(SSL_get_SSL_CTX(ssl)));

  Environment* env = sc->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  Local<Value> argv[3];

  if (!Buffer::Copy(
          env,
          reinterpret_cast<char*>(name),
          kTicketPartSize).ToLocal(&argv[0]) ||
      !Buffer::Copy(
          env,
          reinterpret_cast<char*>(iv),
          kTicketPartSize).ToLocal(&argv[1])) {
    return -1;
  }

  argv[2] = Boolean::New(env->isolate(), enc != 0);

  Local<Value> ret;
  if (!node::MakeCallback(
          env...",1166.0,1265.0,1.0,1.0,100.0,111,13,105,31,0,1,9,10,1,1,,0,1,12,6,6,int
1495,33782,TicketCompatibilityCallback,1,node.crypto.SecureContext.TicketCompatibilityCallback,"int node.crypto.SecureContext.TicketCompatibilityCallback (SSL*,unsigned char*,unsigned char*,EVP_CIPHER_CTX*,HMAC_CTX*,int)",crypto\crypto_context.cc,"int SecureContext::TicketCompatibilityCallback(SSL* ssl,
                                               unsigned char* name,
                                               unsigned char* iv,
                                               EVP_CIPHER_CTX* ectx,
                                               HMAC_CTX* hctx,
                                               int enc) {
  SecureContext* sc = static_cast<SecureContext*>(
      SSL_CTX_get_app_data(SSL_get_SSL_CTX(ssl)));

  if (enc) {
    memcpy(name, sc->ticket_key_name_, sizeof(sc->ticket_key_name_));
    if (CSPRNG(iv, 16).is_err() ||
        EVP_EncryptInit_ex(
            ectx, EVP_aes_128_cbc(), nullptr, sc->ticket_key_aes_, iv) <= 0 ||
        HMAC_Init_ex(hctx,
                     sc->ticket_key_hmac_,
                     sizeof(sc->ticket_key_hmac_),
                     EVP_sha256(),
                     nullptr) <= 0) {
      return -1;
    }
    return 1;
  }

  if (memcmp(name, sc->ticket_key_name_, sizeof(sc->...",1267.0,1303.0,1.0,1.0,37.0,27,9,22,7,0,0,5,6,0,0,,0,0,12,6,6,int
1496,33896,CtxGetter,1,node.crypto.SecureContext.CtxGetter,void node.crypto.SecureContext.CtxGetter (FunctionCallbackInfo<Value>),crypto\crypto_context.cc,"void SecureContext::CtxGetter(const FunctionCallbackInfo<Value>& info) {
  SecureContext* sc;
  ASSIGN_OR_RETURN_UNWRAP(&sc, info.This());
  Local<External> ext = External::New(info.GetIsolate(), sc->ctx_.get());
  info.GetReturnValue().Set(ext);
}",1305.0,1310.0,1.0,1.0,6.0,11,6,10,5,0,0,1,1,0,0,,0,0,2,1,1,void
1497,33937,GetCertificate,1,node.crypto.SecureContext.GetCertificate,void node.crypto.SecureContext.GetCertificate<bool> (FunctionCallbackInfo<Value>),crypto\crypto_context.cc,"void SecureContext::GetCertificate(const FunctionCallbackInfo<Value>& args) {
  SecureContext* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
  Environment* env = wrap->env();
  X509* cert;

  if (primary)
    cert = wrap->cert_.get();
  else
    cert = wrap->issuer_.get();
  if (cert == nullptr)
    return args.GetReturnValue().SetNull();

  int size = i2d_X509(cert, nullptr);
  Local<Object> buff;
  if (!Buffer::New(env, size).ToLocal(&buff))
    return;
  unsigned char* serialized = reinterpret_cast<unsigned char*>(
      Buffer::Data(buff));
  i2d_X509(cert, &serialized);

  args.GetReturnValue().Set(buff);
}",1313.0,1335.0,1.0,1.0,23.0,23,9,25,11,0,0,4,4,0,0,,0,0,2,1,1,void
1498,34041,AddCertsFromFile,1,node.crypto.anonymous_namespace_3.AddCertsFromFile,"unsigned long node.crypto.anonymous_namespace_3.AddCertsFromFile (X509_STORE*,char*)",crypto\crypto_context.cc,"unsigned long AddCertsFromFile(  // NOLINT(runtime/int)
    X509_STORE* store,
    const char* file) {
  ERR_clear_error();
  MarkPopErrorOnReturn mark_pop_error_on_return;

  BIOPointer bio(BIO_new_file(file, ""r""));
  if (!bio)
    return ERR_get_error();

  while (X509Pointer x509 = X509Pointer(PEM_read_bio_X509(
             bio.get(), nullptr, NoPasswordCallback, nullptr))) {
    X509_STORE_add_cert(store, x509.get());
  }

  unsigned long err = ERR_peek_error();  // NOLINT(runtime/int)
  // Ignore error if its EOF/no start line found.
  if (ERR_GET_LIB(err) == ERR_LIB_PEM &&
      ERR_GET_REASON(err) == PEM_R_NO_START_LINE) {
    return 0;
  }

  return err;
}",1338.0,1361.0,1.0,1.0,24.0,6,5,10,7,0,0,4,4,0,0,,0,0,4,2,2,unsigned long
1499,34087,UseExtraCaCerts,1,node.crypto.UseExtraCaCerts,void node.crypto.UseExtraCaCerts (ANY),crypto\crypto_context.cc,"void UseExtraCaCerts(const std::string& file) {
  if (file.empty()) return;
  ClearErrorOnReturn clear_error_on_return;
  X509_STORE* store = GetOrCreateRootCertStore();
  if (auto err = AddCertsFromFile(store, file.c_str())) {
    char buf[256];
    ERR_error_string_n(err, buf, sizeof(buf));
    fprintf(stderr,
            ""Warning: Ignoring extra certs from `%s`, load failed: %s\n"",
            file.c_str(),
            buf);
  } else {
    extra_root_certs_loaded = true;
  }
}",1365.0,1379.0,1.0,1.0,15.0,7,3,12,6,0,0,3,3,0,0,,0,0,2,1,1,void
1500,34135,IsExtraRootCertsFileLoaded,1,node.crypto.IsExtraRootCertsFileLoaded,void node.crypto.IsExtraRootCertsFileLoaded (FunctionCallbackInfo<Value>),crypto\crypto_context.cc,"void IsExtraRootCertsFileLoaded(
    const FunctionCallbackInfo<Value>& args) {
  return args.GetReturnValue().Set(extra_root_certs_loaded);
}",1382.0,1385.0,1.0,1.0,4.0,2,1,2,2,0,0,1,1,0,0,,0,0,2,1,1,void
1501,34167,<lambda>0,1,node.crypto.DiffieHellman.Initialize.<lambda>0,"ANY node.crypto.DiffieHellman.Initialize.<lambda>0 (Local<String>,FunctionCallback)",crypto\crypto_dh.cc,"[&](Local<String> name, FunctionCallback callback) {
    Local<FunctionTemplate> t = NewFunctionTemplate(isolate, callback);

    const PropertyAttribute attributes =
        static_cast<PropertyAttribute>(ReadOnly | DontDelete);

    t->InstanceTemplate()->SetInternalFieldCount(
        DiffieHellman::kInternalFieldCount);

    SetProtoMethod(isolate, t, ""generateKeys"", GenerateKeys);
    SetProtoMethod(isolate, t, ""computeSecret"", ComputeSecret);
    SetProtoMethodNoSideEffect(isolate, t, ""getPrime"", GetPrime);
    SetProtoMethodNoSideEffect(isolate, t, ""getGenerator"", GetGenerator);
    SetProtoMethodNoSideEffect(isolate, t, ""getPublicKey"", GetPublicKey);
    SetProtoMethodNoSideEffect(isolate, t, ""getPrivateKey"", GetPrivateKey);
    SetProtoMethod(isolate, t, ""setPublicKey"", SetPublicKey);
    SetProtoMethod(isolate, t, ""setPrivateKey"", SetPrivateKey);

    Local<FunctionTemplate> verify_error_getter_templ =
        FunctionTemplate::New(isolate,
                              Di...",64.0,98.0,15.0,3.0,35.0,21,7,53,25,0,0,1,1,0,0,,0,0,4,2,2,ANY
1502,34295,<lambda>1,1,node.crypto.DiffieHellman.GetPrime.<lambda>1,BIGNUM node.crypto.DiffieHellman.GetPrime.<lambda>1 (DH*),crypto\crypto_dh.cc,"[](const DH* dh) -> const BIGNUM* {
    const BIGNUM* p;
    DH_get0_pqg(dh, &p, nullptr, nullptr);
    return p;
  }",355.0,359.0,18.0,3.0,5.0,1,1,3,2,0,0,1,1,0,0,,0,0,2,1,1,BIGNUM
1503,34310,<lambda>2,1,node.crypto.DiffieHellman.GetGenerator.<lambda>2,BIGNUM node.crypto.DiffieHellman.GetGenerator.<lambda>2 (DH*),crypto\crypto_dh.cc,"[](const DH* dh) -> const BIGNUM* {
    const BIGNUM* g;
    DH_get0_pqg(dh, nullptr, nullptr, &g);
    return g;
  }",363.0,367.0,18.0,3.0,5.0,1,1,3,2,0,0,1,1,0,0,,0,0,2,1,1,BIGNUM
1504,34325,<lambda>3,1,node.crypto.DiffieHellman.GetPublicKey.<lambda>3,BIGNUM node.crypto.DiffieHellman.GetPublicKey.<lambda>3 (DH*),crypto\crypto_dh.cc,"[](const DH* dh) -> const BIGNUM* {
    const BIGNUM* pub_key;
    DH_get0_key(dh, &pub_key, nullptr);
    return pub_key;
  }",371.0,375.0,18.0,3.0,5.0,1,1,3,2,0,0,1,1,0,0,,0,0,2,1,1,BIGNUM
1505,34339,<lambda>4,1,node.crypto.DiffieHellman.GetPrivateKey.<lambda>4,BIGNUM node.crypto.DiffieHellman.GetPrivateKey.<lambda>4 (DH*),crypto\crypto_dh.cc,"[](const DH* dh) -> const BIGNUM* {
    const BIGNUM* priv_key;
    DH_get0_key(dh, nullptr, &priv_key);
    return priv_key;
  }",379.0,383.0,18.0,3.0,5.0,1,1,3,2,0,0,1,1,0,0,,0,0,2,1,1,BIGNUM
1506,34353,<lambda>5,1,node.crypto.DiffieHellman.SetPublicKey.<lambda>5,"ANY node.crypto.DiffieHellman.SetPublicKey.<lambda>5 (DH*,BIGNUM*)",crypto\crypto_dh.cc,"[](DH* dh, BIGNUM* num) { return DH_set0_key(dh, num, nullptr); }",461.0,461.0,10.0,74.0,1.0,0,0,2,2,0,0,1,1,0,0,,0,0,4,2,2,ANY
1507,34365,<lambda>6,1,node.crypto.DiffieHellman.SetPrivateKey.<lambda>6,"ANY node.crypto.DiffieHellman.SetPrivateKey.<lambda>6 (DH*,BIGNUM*)",crypto\crypto_dh.cc,"[](DH* dh, BIGNUM* num) { return DH_set0_key(dh, nullptr, num); }",467.0,467.0,10.0,74.0,1.0,0,0,2,2,0,0,1,1,0,0,,0,0,4,2,2,ANY
1508,34401,ZeroPadDiffieHellmanSecret,1,node.crypto.anonymous_namespace_1.ZeroPadDiffieHellmanSecret,"void node.crypto.anonymous_namespace_1.ZeroPadDiffieHellmanSecret (size_t,char*,size_t)",crypto\crypto_dh.cc,"void ZeroPadDiffieHellmanSecret(size_t remainder_size,
                                char* data,
                                size_t length) {
  // DH_size returns number of bytes in a prime number.
  // DH_compute_key returns number of bytes in a remainder of exponent, which
  // may have less bytes than a prime number. Therefore add 0-padding to the
  // allocated buffer.
  const size_t prime_size = length;
  if (remainder_size != prime_size) {
    CHECK_LT(remainder_size, prime_size);
    const size_t padding = prime_size - remainder_size;
    memmove(data + padding, data, remainder_size);
    memset(data, 0, padding);
  }
}",39.0,53.0,1.0,1.0,15.0,5,4,15,5,0,0,2,2,0,0,,0,0,6,3,3,void
1509,34436,DiffieHellman,1,node.crypto.DiffieHellman.DiffieHellman,"ANY node.crypto.DiffieHellman.DiffieHellman (Environment*,Local<Object>)",crypto\crypto_dh.cc,"DiffieHellman::DiffieHellman(Environment* env, Local<Object> wrap)
    : BaseObject(env, wrap), verifyError_(0) {
  MakeWeak();
}",56.0,59.0,1.0,1.0,4.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,ANY
1510,34443,Initialize,1,node.crypto.DiffieHellman.Initialize,"void node.crypto.DiffieHellman.Initialize (Environment*,Local<Object>)",crypto\crypto_dh.cc,"void DiffieHellman::Initialize(Environment* env, Local<Object> target) {
  Isolate* isolate = env->isolate();
  Local<Context> context = env->context();
  auto make = [&](Local<String> name, FunctionCallback callback) {
    Local<FunctionTemplate> t = NewFunctionTemplate(isolate, callback);

    const PropertyAttribute attributes =
        static_cast<PropertyAttribute>(ReadOnly | DontDelete);

    t->InstanceTemplate()->SetInternalFieldCount(
        DiffieHellman::kInternalFieldCount);

    SetProtoMethod(isolate, t, ""generateKeys"", GenerateKeys);
    SetProtoMethod(isolate, t, ""computeSecret"", ComputeSecret);
    SetProtoMethodNoSideEffect(isolate, t, ""getPrime"", GetPrime);
    SetProtoMethodNoSideEffect(isolate, t, ""getGenerator"", GetGenerator);
    SetProtoMethodNoSideEffect(isolate, t, ""getPublicKey"", GetPublicKey);
    SetProtoMethodNoSideEffect(isolate, t, ""getPrivateKey"", GetPrivateKey);
    SetProtoMethod(isolate, t, ""setPublicKey"", SetPublicKey);
    SetProtoMethod(isolat...",61.0,109.0,1.0,1.0,49.0,13,5,23,13,0,0,1,1,0,0,,0,0,4,2,2,void
1511,34508,RegisterExternalReferences,1,node.crypto.DiffieHellman.RegisterExternalReferences,void node.crypto.DiffieHellman.RegisterExternalReferences (ExternalReferenceRegistry*),crypto\crypto_dh.cc,"void DiffieHellman::RegisterExternalReferences(
    ExternalReferenceRegistry* registry) {
  registry->Register(New);
  registry->Register(DiffieHellmanGroup);

  registry->Register(GenerateKeys);
  registry->Register(ComputeSecret);
  registry->Register(GetPrime);
  registry->Register(GetGenerator);
  registry->Register(GetPublicKey);
  registry->Register(GetPrivateKey);
  registry->Register(SetPublicKey);
  registry->Register(SetPrivateKey);

  registry->Register(DiffieHellman::VerifyErrorGetter);
  registry->Register(DiffieHellman::Stateless);

  DHKeyPairGenJob::RegisterExternalReferences(registry);
  DHKeyExportJob::RegisterExternalReferences(registry);
  DHBitsJob::RegisterExternalReferences(registry);
}",111.0,131.0,1.0,1.0,21.0,17,2,30,15,0,0,1,1,0,0,,0,0,2,1,1,void
1512,34592,Init,1,node.crypto.DiffieHellman.Init,"bool node.crypto.DiffieHellman.Init (int,int)",crypto\crypto_dh.cc,"bool DiffieHellman::Init(const char* p, int p_len, const char* g, int g_len) {
  dh_.reset(DH_new());
  if (p_len <= 0) {
    ERR_put_error(ERR_LIB_BN, BN_F_BN_GENERATE_PRIME_EX,
      BN_R_BITS_TOO_SMALL, __FILE__, __LINE__);
    return false;
  }
  if (g_len <= 0) {
    ERR_put_error(ERR_LIB_DH, DH_F_DH_BUILTIN_GENPARAMS,
      DH_R_BAD_GENERATOR, __FILE__, __LINE__);
    return false;
  }
  BIGNUM* bn_g =
      BN_bin2bn(reinterpret_cast<const unsigned char*>(g), g_len, nullptr);
  if (BN_is_zero(bn_g) || BN_is_one(bn_g)) {
    BN_free(bn_g);
    ERR_put_error(ERR_LIB_DH, DH_F_DH_BUILTIN_GENPARAMS,
      DH_R_BAD_GENERATOR, __FILE__, __LINE__);
    return false;
  }
  BIGNUM* bn_p =
      BN_bin2bn(reinterpret_cast<const unsigned char*>(p), p_len, nullptr);
  if (!DH_set0_pqg(dh_.get(), bn_p, nullptr, bn_g)) {
    BN_free(bn_p);
    BN_free(bn_g);
    return false;
  }
  return VerifyContext();
}",177.0,205.0,1.0,27.0,29.0,3,2,4,3,0,0,2,2,0,0,,0,0,8,4,4,bool
1513,34618,MemoryInfo,1,node.crypto.DiffieHellman.MemoryInfo,void node.crypto.DiffieHellman.MemoryInfo (MemoryTracker*),crypto\crypto_dh.cc,"void DiffieHellman::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackFieldWithSize(""dh"", dh_ ? kSizeOf_DH : 0);
}",140.0,142.0,1.0,1.0,3.0,2,2,3,3,0,0,1,1,0,0,,0,0,2,1,1,void
1514,34867,InstantiateStandardizedGroup,1,node.crypto.InstantiateStandardizedGroup,BignumPointer node.crypto.InstantiateStandardizedGroup<BIGNUM*(*)(BIGNUM*)> (),crypto\crypto_dh.cc,"BignumPointer InstantiateStandardizedGroup() {
  return BignumPointer(p(nullptr));
}",210.0,212.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,BignumPointer
1515,34875,StandardizedGroupInstantiator,1,node.crypto.StandardizedGroupInstantiator,BignumPointer node.crypto.StandardizedGroupInstantiator (),crypto\crypto_dh.cc,typedef BignumPointer (*StandardizedGroupInstantiator)();,214.0,214.0,23.0,56.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,BignumPointer
1516,34879,FindDiffieHellmanGroup,1,node.crypto.FindDiffieHellmanGroup,StandardizedGroupInstantiator node.crypto.FindDiffieHellmanGroup (char*),crypto\crypto_dh.cc,"inline StandardizedGroupInstantiator FindDiffieHellmanGroup(const char* name) {
#define V(n, p)                                                                \
  if (StringEqualNoCase(name, n)) return InstantiateStandardizedGroup<p>
  V(""modp1"", BN_get_rfc2409_prime_768);
  V(""modp2"", BN_get_rfc2409_prime_1024);
  V(""modp5"", BN_get_rfc3526_prime_1536);
  V(""modp14"", BN_get_rfc3526_prime_2048);
  V(""modp15"", BN_get_rfc3526_prime_3072);
  V(""modp16"", BN_get_rfc3526_prime_4096);
  V(""modp17"", BN_get_rfc3526_prime_6144);
  V(""modp18"", BN_get_rfc3526_prime_8192);
#undef V
  return nullptr;
}",218.0,231.0,1.0,2.0,14.0,0,0,16,9,0,0,1,1,0,0,,0,0,2,1,1,StandardizedGroupInstantiator
1517,34966,DiffieHellmanGroup,1,node.crypto.DiffieHellman.DiffieHellmanGroup,void node.crypto.DiffieHellman.DiffieHellmanGroup (FunctionCallbackInfo<Value>),crypto\crypto_dh.cc,"void DiffieHellman::DiffieHellmanGroup(
    const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  DiffieHellman* diffieHellman = new DiffieHellman(env, args.This());

  CHECK_EQ(args.Length(), 1);
  THROW_AND_RETURN_IF_NOT_STRING(env, args[0], ""Group name"");

  bool initialized = false;

  const node::Utf8Value group_name(env->isolate(), args[0]);
  auto group = FindDiffieHellmanGroup(*group_name);
  if (group == nullptr)
    return THROW_ERR_CRYPTO_UNKNOWN_DH_GROUP(env);

  initialized = diffieHellman->Init(group(), kStandardizedGenerator);
  if (!initialized)
    THROW_ERR_CRYPTO_INITIALIZATION_FAILED(env);
}",233.0,251.0,1.0,1.0,19.0,16,8,22,9,0,0,3,3,0,0,,0,0,2,1,1,void
1518,35042,New,1,node.crypto.DiffieHellman.New,void node.crypto.DiffieHellman.New (FunctionCallbackInfo<Value>),crypto\crypto_dh.cc,"void DiffieHellman::New(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  DiffieHellman* diffieHellman =
      new DiffieHellman(env, args.This());
  bool initialized = false;

  if (args.Length() == 2) {
    if (args[0]->IsInt32()) {
      if (args[1]->IsInt32()) {
        initialized = diffieHellman->Init(args[0].As<Int32>()->Value(),
                                          args[1].As<Int32>()->Value());
      }
    } else {
      ArrayBufferOrViewContents<char> arg0(args[0]);
      if (UNLIKELY(!arg0.CheckSizeInt32()))
        return THROW_ERR_OUT_OF_RANGE(env, ""prime is too big"");
      if (args[1]->IsInt32()) {
        initialized = diffieHellman->Init(arg0.data(),
                                          arg0.size(),
                                          args[1].As<Int32>()->Value());
      } else {
        ArrayBufferOrViewContents<char> arg1(args[1]);
        if (UNLIKELY(!arg1.CheckSizeInt32()))
          return THROW_ER...",254.0,287.0,1.0,1.0,34.0,21,7,17,6,0,0,5,8,0,0,,0,0,2,1,1,void
1519,35217,GenerateKeys,1,node.crypto.DiffieHellman.GenerateKeys,void node.crypto.DiffieHellman.GenerateKeys (FunctionCallbackInfo<Value>),crypto\crypto_dh.cc,"void DiffieHellman::GenerateKeys(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  DiffieHellman* diffieHellman;
  ASSIGN_OR_RETURN_UNWRAP(&diffieHellman, args.Holder());

  if (!DH_generate_key(diffieHellman->dh_.get())) {
    return ThrowCryptoError(env, ERR_get_error(), ""Key generation failed"");
  }

  const BIGNUM* pub_key;
  DH_get0_key(diffieHellman->dh_.get(), &pub_key, nullptr);

  std::unique_ptr<BackingStore> bs;
  {
    const int size = BN_num_bytes(pub_key);
    CHECK_GE(size, 0);
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), size);
  }

  CHECK_EQ(static_cast<int>(bs->ByteLength()),
           BN_bn2binpad(pub_key,
                        static_cast<unsigned char*>(bs->Data()),
                        bs->ByteLength()));

  Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(bs));
  Local<Value> buffer;
  if (!Buffer::New(env, a...",290.0,320.0,1.0,1.0,31.0,38,8,41,15,0,0,3,3,0,0,,0,0,2,1,1,void
1520,35368,GetField,1,node.crypto.DiffieHellman.GetField,"void node.crypto.DiffieHellman.GetField (FunctionCallbackInfo<Value>,BIGNUM*,char*)",crypto\crypto_dh.cc,"void DiffieHellman::GetField(const FunctionCallbackInfo<Value>& args,
                             const BIGNUM* (*get_field)(const DH*),
                             const char* err_if_null) {
  Environment* env = Environment::GetCurrent(args);

  DiffieHellman* dh;
  ASSIGN_OR_RETURN_UNWRAP(&dh, args.Holder());

  const BIGNUM* num = get_field(dh->dh_.get());
  if (num == nullptr)
    return THROW_ERR_CRYPTO_INVALID_STATE(env, err_if_null);

  std::unique_ptr<BackingStore> bs;
  {
    const int size = BN_num_bytes(num);
    CHECK_GE(size, 0);
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), size);
  }

  CHECK_EQ(static_cast<int>(bs->ByteLength()),
           BN_bn2binpad(num,
                        static_cast<unsigned char*>(bs->Data()),
                        bs->ByteLength()));

  Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(bs));
  Local<Value> buffer;
  if (!Buffer::New(env, ...",323.0,352.0,1.0,1.0,30.0,36,9,42,16,0,0,3,3,0,0,,0,0,6,3,3,void
1521,35514,GetPrime,1,node.crypto.DiffieHellman.GetPrime,void node.crypto.DiffieHellman.GetPrime (FunctionCallbackInfo<Value>),crypto\crypto_dh.cc,"void DiffieHellman::GetPrime(const FunctionCallbackInfo<Value>& args) {
  GetField(args, [](const DH* dh) -> const BIGNUM* {
    const BIGNUM* p;
    DH_get0_pqg(dh, &p, nullptr, nullptr);
    return p;
  }, ""p is null"");
}",354.0,360.0,1.0,1.0,7.0,0,0,1,1,0,0,1,1,0,0,,0,0,2,1,1,void
1522,35523,GetGenerator,1,node.crypto.DiffieHellman.GetGenerator,void node.crypto.DiffieHellman.GetGenerator (FunctionCallbackInfo<Value>),crypto\crypto_dh.cc,"void DiffieHellman::GetGenerator(const FunctionCallbackInfo<Value>& args) {
  GetField(args, [](const DH* dh) -> const BIGNUM* {
    const BIGNUM* g;
    DH_get0_pqg(dh, nullptr, nullptr, &g);
    return g;
  }, ""g is null"");
}",362.0,368.0,1.0,1.0,7.0,0,0,1,1,0,0,1,1,0,0,,0,0,2,1,1,void
1523,35532,GetPublicKey,1,node.crypto.DiffieHellman.GetPublicKey,void node.crypto.DiffieHellman.GetPublicKey (FunctionCallbackInfo<Value>),crypto\crypto_dh.cc,"void DiffieHellman::GetPublicKey(const FunctionCallbackInfo<Value>& args) {
  GetField(args, [](const DH* dh) -> const BIGNUM* {
    const BIGNUM* pub_key;
    DH_get0_key(dh, &pub_key, nullptr);
    return pub_key;
  }, ""No public key - did you forget to generate one?"");
}",370.0,376.0,1.0,1.0,7.0,0,0,1,1,0,0,1,1,0,0,,0,0,2,1,1,void
1524,35541,GetPrivateKey,1,node.crypto.DiffieHellman.GetPrivateKey,void node.crypto.DiffieHellman.GetPrivateKey (FunctionCallbackInfo<Value>),crypto\crypto_dh.cc,"void DiffieHellman::GetPrivateKey(const FunctionCallbackInfo<Value>& args) {
  GetField(args, [](const DH* dh) -> const BIGNUM* {
    const BIGNUM* priv_key;
    DH_get0_key(dh, nullptr, &priv_key);
    return priv_key;
  }, ""No private key - did you forget to generate one?"");
}",378.0,384.0,1.0,1.0,7.0,0,0,1,1,0,0,1,1,0,0,,0,0,2,1,1,void
1525,35550,ComputeSecret,1,node.crypto.DiffieHellman.ComputeSecret,void node.crypto.DiffieHellman.ComputeSecret (FunctionCallbackInfo<Value>),crypto\crypto_dh.cc,"void DiffieHellman::ComputeSecret(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  DiffieHellman* diffieHellman;
  ASSIGN_OR_RETURN_UNWRAP(&diffieHellman, args.Holder());

  ClearErrorOnReturn clear_error_on_return;

  CHECK_EQ(args.Length(), 1);
  ArrayBufferOrViewContents<unsigned char> key_buf(args[0]);
  if (UNLIKELY(!key_buf.CheckSizeInt32()))
    return THROW_ERR_OUT_OF_RANGE(env, ""secret is too big"");
  BignumPointer key(BN_bin2bn(key_buf.data(), key_buf.size(), nullptr));

  std::unique_ptr<BackingStore> bs;
  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(),
                                      DH_size(diffieHellman->dh_.get()));
  }

  int size = DH_compute_key(static_cast<unsigned char*>(bs->Data()),
                            key.get(),
                            diffieHellman->dh_.get());

  if (size == -1) {
    int checkResult;
    int chec...",386.0,443.0,1.0,1.0,58.0,51,11,52,18,0,0,5,6,0,0,,0,0,2,1,1,void
1526,35785,SetKey,1,node.crypto.DiffieHellman.SetKey,"void node.crypto.DiffieHellman.SetKey (FunctionCallbackInfo<Value>,int,char*)",crypto\crypto_dh.cc,"void DiffieHellman::SetKey(const FunctionCallbackInfo<Value>& args,
                           int (*set_field)(DH*, BIGNUM*), const char* what) {
  Environment* env = Environment::GetCurrent(args);
  DiffieHellman* dh;
  ASSIGN_OR_RETURN_UNWRAP(&dh, args.Holder());
  CHECK_EQ(args.Length(), 1);
  ArrayBufferOrViewContents<unsigned char> buf(args[0]);
  if (UNLIKELY(!buf.CheckSizeInt32()))
    return THROW_ERR_OUT_OF_RANGE(env, ""buf is too big"");
  BIGNUM* num = BN_bin2bn(buf.data(), buf.size(), nullptr);
  CHECK_NOT_NULL(num);
  CHECK_EQ(1, set_field(dh->dh_.get(), num));
}",445.0,457.0,1.0,1.0,13.0,13,6,15,6,0,0,2,2,0,0,,0,0,6,3,3,void
1527,35856,SetPublicKey,1,node.crypto.DiffieHellman.SetPublicKey,void node.crypto.DiffieHellman.SetPublicKey (FunctionCallbackInfo<Value>),crypto\crypto_dh.cc,"void DiffieHellman::SetPublicKey(const FunctionCallbackInfo<Value>& args) {
  SetKey(args,
         [](DH* dh, BIGNUM* num) { return DH_set0_key(dh, num, nullptr); },
         ""Public key"");
}",459.0,463.0,1.0,1.0,5.0,0,0,1,1,0,0,1,1,0,0,,0,0,2,1,1,void
1528,35865,SetPrivateKey,1,node.crypto.DiffieHellman.SetPrivateKey,void node.crypto.DiffieHellman.SetPrivateKey (FunctionCallbackInfo<Value>),crypto\crypto_dh.cc,"void DiffieHellman::SetPrivateKey(const FunctionCallbackInfo<Value>& args) {
  SetKey(args,
         [](DH* dh, BIGNUM* num) { return DH_set0_key(dh, nullptr, num); },
         ""Private key"");
}",465.0,469.0,1.0,1.0,5.0,0,0,1,1,0,0,1,1,0,0,,0,0,2,1,1,void
1529,35874,VerifyErrorGetter,1,node.crypto.DiffieHellman.VerifyErrorGetter,void node.crypto.DiffieHellman.VerifyErrorGetter (FunctionCallbackInfo<Value>),crypto\crypto_dh.cc,"void DiffieHellman::VerifyErrorGetter(const FunctionCallbackInfo<Value>& args) {
  HandleScope scope(args.GetIsolate());

  DiffieHellman* diffieHellman;
  ASSIGN_OR_RETURN_UNWRAP(&diffieHellman, args.Holder());

  args.GetReturnValue().Set(diffieHellman->verifyError_);
}",471.0,478.0,1.0,1.0,8.0,6,3,5,2,0,0,1,1,0,0,,0,0,2,1,1,void
1530,35903,VerifyContext,1,node.crypto.DiffieHellman.VerifyContext,bool node.crypto.DiffieHellman.VerifyContext (),crypto\crypto_dh.cc,"bool DiffieHellman::VerifyContext() {
  int codes;
  if (!DH_check(dh_.get(), &codes))
    return false;
  verifyError_ = codes;
  return true;
}",480.0,486.0,1.0,1.0,7.0,4,4,4,3,0,0,2,2,0,0,,0,0,0,0,0,bool
1531,35925,AdditionalConfig,1,node.crypto.DhKeyGenTraits.AdditionalConfig,"Maybe<bool> node.crypto.DhKeyGenTraits.AdditionalConfig (CryptoJobMode,FunctionCallbackInfo<Value>,unsigned int*,DhKeyPairGenConfig*)",crypto\crypto_dh.cc,"Maybe<bool> DhKeyGenTraits::AdditionalConfig(
    CryptoJobMode mode,
    const FunctionCallbackInfo<Value>& args,
    unsigned int* offset,
    DhKeyPairGenConfig* params) {
  Environment* env = Environment::GetCurrent(args);

  if (args[*offset]->IsString()) {
    Utf8Value group_name(env->isolate(), args[*offset]);
    auto group = FindDiffieHellmanGroup(*group_name);
    if (group == nullptr) {
      THROW_ERR_CRYPTO_UNKNOWN_DH_GROUP(env);
      return Nothing<bool>();
    }

    params->params.prime = group();
    params->params.generator = kStandardizedGenerator;
    *offset += 1;
  } else {
    if (args[*offset]->IsInt32()) {
      int size = args[*offset].As<Int32>()->Value();
      if (size < 0) {
        THROW_ERR_OUT_OF_RANGE(env, ""Invalid prime size"");
        return Nothing<bool>();
      }
      params->params.prime = size;
    } else {
      ArrayBufferOrViewContents<unsigned char> input(args[*offset]);
      if (UNLIKELY(!input.CheckSizeInt32())) {
        THROW_ERR_...",502.0,544.0,1.0,1.0,43.0,19,7,16,8,0,0,3,4,0,0,,0,0,8,4,4,Maybe<bool>
1532,36107,Setup,1,node.crypto.DhKeyGenTraits.Setup,EVPKeyCtxPointer node.crypto.DhKeyGenTraits.Setup (DhKeyPairGenConfig*),crypto\crypto_dh.cc,"EVPKeyCtxPointer DhKeyGenTraits::Setup(DhKeyPairGenConfig* params) {
  EVPKeyPointer key_params;
  if (BignumPointer* prime_fixed_value =
          std::get_if<BignumPointer>(&params->params.prime)) {
    DHPointer dh(DH_new());
    if (!dh)
      return EVPKeyCtxPointer();

    BIGNUM* prime = prime_fixed_value->get();
    BignumPointer bn_g(BN_new());
    if (!BN_set_word(bn_g.get(), params->params.generator) ||
        !DH_set0_pqg(dh.get(), prime, nullptr, bn_g.get())) {
      return EVPKeyCtxPointer();
    }

    prime_fixed_value->release();
    bn_g.release();

    key_params = EVPKeyPointer(EVP_PKEY_new());
    CHECK(key_params);
    CHECK_EQ(EVP_PKEY_assign_DH(key_params.get(), dh.release()), 1);
  } else if (int* prime_size = std::get_if<int>(&params->params.prime)) {
    EVPKeyCtxPointer param_ctx(EVP_PKEY_CTX_new_id(EVP_PKEY_DH, nullptr));
    EVP_PKEY* raw_params = nullptr;
    if (!param_ctx ||
        EVP_PKEY_paramgen_init(param_ctx.get()) <= 0 ||
        EVP_PKEY_CT...",546.0,592.0,1.0,1.0,47.0,52,10,37,13,0,0,5,7,0,0,,0,0,2,1,1,EVPKeyCtxPointer
1533,36308,AdditionalConfig,1,node.crypto.DHKeyExportTraits.AdditionalConfig,"Maybe<bool> node.crypto.DHKeyExportTraits.AdditionalConfig (FunctionCallbackInfo<Value>,unsigned int,DHKeyExportConfig*)",crypto\crypto_dh.cc,"Maybe<bool> DHKeyExportTraits::AdditionalConfig(
    const FunctionCallbackInfo<Value>& args,
    unsigned int offset,
    DHKeyExportConfig* params) {
  return Just(true);
}",594.0,599.0,1.0,1.0,6.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,Maybe<bool>
1534,36318,DoExport,1,node.crypto.DHKeyExportTraits.DoExport,"WebCryptoKeyExportStatus node.crypto.DHKeyExportTraits.DoExport (ANY,WebCryptoKeyFormat,DHKeyExportConfig,ByteSource*)",crypto\crypto_dh.cc,"WebCryptoKeyExportStatus DHKeyExportTraits::DoExport(
    std::shared_ptr<KeyObjectData> key_data,
    WebCryptoKeyFormat format,
    const DHKeyExportConfig& params,
    ByteSource* out) {
  CHECK_NE(key_data->GetKeyType(), kKeyTypeSecret);

  switch (format) {
    case kWebCryptoKeyFormatPKCS8:
      if (key_data->GetKeyType() != kKeyTypePrivate)
        return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;
      return PKEY_PKCS8_Export(key_data.get(), out);
    case kWebCryptoKeyFormatSPKI:
      if (key_data->GetKeyType() != kKeyTypePublic)
        return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;
      return PKEY_SPKI_Export(key_data.get(), out);
    default:
      UNREACHABLE();
  }
}",601.0,620.0,1.0,1.0,20.0,9,3,15,9,0,0,4,6,0,0,,0,0,8,4,4,WebCryptoKeyExportStatus
1535,36380,StatelessDiffieHellmanThreadsafe,1,node.crypto.anonymous_namespace_3.StatelessDiffieHellmanThreadsafe,"ByteSource node.crypto.anonymous_namespace_3.StatelessDiffieHellmanThreadsafe (ManagedEVPPKey,ManagedEVPPKey)",crypto\crypto_dh.cc,"ByteSource StatelessDiffieHellmanThreadsafe(
    const ManagedEVPPKey& our_key,
    const ManagedEVPPKey& their_key) {
  size_t out_size;

  EVPKeyCtxPointer ctx(EVP_PKEY_CTX_new(our_key.get(), nullptr));
  if (!ctx ||
      EVP_PKEY_derive_init(ctx.get()) <= 0 ||
      EVP_PKEY_derive_set_peer(ctx.get(), their_key.get()) <= 0 ||
      EVP_PKEY_derive(ctx.get(), nullptr, &out_size) <= 0)
    return ByteSource();

  ByteSource::Builder out(out_size);
  if (EVP_PKEY_derive(ctx.get(), out.data<unsigned char>(), &out_size) <= 0) {
    return ByteSource();
  }

  ZeroPadDiffieHellmanSecret(out_size, out.data<char>(), out.size());
  return std::move(out).release();
}",623.0,642.0,1.0,1.0,20.0,21,5,16,6,0,0,3,3,0,0,,0,0,4,2,2,ByteSource
1536,36471,Stateless,1,node.crypto.DiffieHellman.Stateless,void node.crypto.DiffieHellman.Stateless (FunctionCallbackInfo<Value>),crypto\crypto_dh.cc,"void DiffieHellman::Stateless(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  CHECK(args[0]->IsObject() && args[1]->IsObject());
  KeyObjectHandle* our_key_object;
  ASSIGN_OR_RETURN_UNWRAP(&our_key_object, args[0].As<Object>());
  CHECK_EQ(our_key_object->Data()->GetKeyType(), kKeyTypePrivate);
  KeyObjectHandle* their_key_object;
  ASSIGN_OR_RETURN_UNWRAP(&their_key_object, args[1].As<Object>());
  CHECK_NE(their_key_object->Data()->GetKeyType(), kKeyTypeSecret);

  ManagedEVPPKey our_key = our_key_object->Data()->GetAsymmetricKey();
  ManagedEVPPKey their_key = their_key_object->Data()->GetAsymmetricKey();

  Local<Value> out;
  if (!StatelessDiffieHellmanThreadsafe(our_key, their_key)
          .ToBuffer(env)
              .ToLocal(&out)) return;

  if (Buffer::Length(out) == 0)
    return ThrowCryptoError(env, ERR_get_error(), ""diffieHellman failed"");

  args.GetReturnValue().Set(out);
}",645.0,668.0,1.0,1.0,24.0,33,10,29,13,0,0,3,3,0,0,,0,0,2,1,1,void
1537,36599,AdditionalConfig,1,node.crypto.DHBitsTraits.AdditionalConfig,"Maybe<bool> node.crypto.DHBitsTraits.AdditionalConfig (CryptoJobMode,FunctionCallbackInfo<Value>,unsigned int,DHBitsConfig*)",crypto\crypto_dh.cc,"Maybe<bool> DHBitsTraits::AdditionalConfig(
    CryptoJobMode mode,
    const FunctionCallbackInfo<Value>& args,
    unsigned int offset,
    DHBitsConfig* params) {
  Environment* env = Environment::GetCurrent(args);

  CHECK(args[offset]->IsObject());  // public key
  CHECK(args[offset + 1]->IsObject());  // private key

  KeyObjectHandle* private_key;
  KeyObjectHandle* public_key;

  ASSIGN_OR_RETURN_UNWRAP(&public_key, args[offset], Nothing<bool>());
  ASSIGN_OR_RETURN_UNWRAP(&private_key, args[offset + 1], Nothing<bool>());

  if (private_key->Data()->GetKeyType() != kKeyTypePrivate ||
      public_key->Data()->GetKeyType() != kKeyTypePublic) {
    THROW_ERR_CRYPTO_INVALID_KEYTYPE(env);
    return Nothing<bool>();
  }

  params->public_key = public_key->Data();
  params->private_key = private_key->Data();

  return Just(true);
}",670.0,696.0,1.0,1.0,27.0,25,8,22,9,0,0,2,2,0,0,,0,0,8,4,4,Maybe<bool>
1538,36693,EncodeOutput,1,node.crypto.DHBitsTraits.EncodeOutput,"Maybe<bool> node.crypto.DHBitsTraits.EncodeOutput (Environment*,DHBitsConfig,ByteSource*,ANY*)",crypto\crypto_dh.cc,"Maybe<bool> DHBitsTraits::EncodeOutput(
    Environment* env,
    const DHBitsConfig& params,
    ByteSource* out,
    v8::Local<v8::Value>* result) {
  *result = out->ToArrayBuffer(env);
  return Just(!result->IsEmpty());
}",698.0,705.0,1.0,1.0,8.0,5,4,4,3,0,0,1,1,0,0,,0,0,8,4,4,Maybe<bool>
1539,36716,DeriveBits,1,node.crypto.DHBitsTraits.DeriveBits,"bool node.crypto.DHBitsTraits.DeriveBits (Environment*,DHBitsConfig,ByteSource*)",crypto\crypto_dh.cc,"bool DHBitsTraits::DeriveBits(
    Environment* env,
    const DHBitsConfig& params,
    ByteSource* out) {
  *out = StatelessDiffieHellmanThreadsafe(
      params.private_key->GetAsymmetricKey(),
      params.public_key->GetAsymmetricKey());
  return true;
}",707.0,715.0,1.0,1.0,9.0,6,4,3,2,0,0,1,1,0,0,,0,0,6,3,3,bool
1540,36741,GetDhKeyDetail,1,node.crypto.GetDhKeyDetail,"Maybe<bool> node.crypto.GetDhKeyDetail (Environment*,ANY,Local<Object>)",crypto\crypto_dh.cc,"Maybe<bool> GetDhKeyDetail(
    Environment* env,
    std::shared_ptr<KeyObjectData> key,
    Local<Object> target) {
  ManagedEVPPKey pkey = key->GetAsymmetricKey();
  CHECK_EQ(EVP_PKEY_id(pkey.get()), EVP_PKEY_DH);
  return Just(true);
}",717.0,724.0,1.0,1.0,8.0,3,3,4,3,0,0,1,1,0,0,,0,0,6,3,3,Maybe<bool>
1541,36813,Setup,1,node.crypto.DsaKeyGenTraits.Setup,EVPKeyCtxPointer node.crypto.DsaKeyGenTraits.Setup (DsaKeyPairGenConfig*),crypto\crypto_dsa.cc,"EVPKeyCtxPointer DsaKeyGenTraits::Setup(DsaKeyPairGenConfig* params) {
  EVPKeyCtxPointer param_ctx(EVP_PKEY_CTX_new_id(EVP_PKEY_DSA, nullptr));
  EVP_PKEY* raw_params = nullptr;

  if (!param_ctx ||
      EVP_PKEY_paramgen_init(param_ctx.get()) <= 0 ||
      EVP_PKEY_CTX_set_dsa_paramgen_bits(
          param_ctx.get(),
          params->params.modulus_bits) <= 0) {
    return EVPKeyCtxPointer();
  }

  if (params->params.divisor_bits != -1) {
    if (EVP_PKEY_CTX_set_dsa_paramgen_q_bits(
            param_ctx.get(), params->params.divisor_bits) <= 0) {
      return EVPKeyCtxPointer();
    }
  }

  if (EVP_PKEY_paramgen(param_ctx.get(), &raw_params) <= 0)
    return EVPKeyCtxPointer();

  EVPKeyPointer key_params(raw_params);
  EVPKeyCtxPointer key_ctx(EVP_PKEY_CTX_new(key_params.get(), nullptr));

  if (!key_ctx || EVP_PKEY_keygen_init(key_ctx.get()) <= 0)
    return EVPKeyCtxPointer();

  return key_ctx;
}",40.0,69.0,1.0,8.0,30.0,29,9,21,8,0,0,6,7,0,0,,0,0,2,1,1,EVPKeyCtxPointer
1542,36935,AdditionalConfig,1,node.crypto.DsaKeyGenTraits.AdditionalConfig,"Maybe<bool> node.crypto.DsaKeyGenTraits.AdditionalConfig (CryptoJobMode,FunctionCallbackInfo<Value>,unsigned int*,DsaKeyPairGenConfig*)",crypto\crypto_dsa.cc,"Maybe<bool> DsaKeyGenTraits::AdditionalConfig(
    CryptoJobMode mode,
    const FunctionCallbackInfo<Value>& args,
    unsigned int* offset,
    DsaKeyPairGenConfig* params) {
  CHECK(args[*offset]->IsUint32());  // modulus bits
  CHECK(args[*offset + 1]->IsInt32());  // divisor bits

  params->params.modulus_bits = args[*offset].As<Uint32>()->Value();
  params->params.divisor_bits = args[*offset + 1].As<Int32>()->Value();
  CHECK_GE(params->params.divisor_bits, -1);

  *offset += 2;

  return Just(true);
}",81.0,96.0,1.0,1.0,16.0,27,8,12,3,0,0,1,1,0,0,,0,0,8,4,4,Maybe<bool>
1543,37010,AdditionalConfig,1,node.crypto.DSAKeyExportTraits.AdditionalConfig,"Maybe<bool> node.crypto.DSAKeyExportTraits.AdditionalConfig (FunctionCallbackInfo<Value>,unsigned int,DSAKeyExportConfig*)",crypto\crypto_dsa.cc,"Maybe<bool> DSAKeyExportTraits::AdditionalConfig(
    const FunctionCallbackInfo<Value>& args,
    unsigned int offset,
    DSAKeyExportConfig* params) {
  return Just(true);
}",98.0,103.0,1.0,1.0,6.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,Maybe<bool>
1544,37020,DoExport,1,node.crypto.DSAKeyExportTraits.DoExport,"WebCryptoKeyExportStatus node.crypto.DSAKeyExportTraits.DoExport (ANY,WebCryptoKeyFormat,DSAKeyExportConfig,ByteSource*)",crypto\crypto_dsa.cc,"WebCryptoKeyExportStatus DSAKeyExportTraits::DoExport(
    std::shared_ptr<KeyObjectData> key_data,
    WebCryptoKeyFormat format,
    const DSAKeyExportConfig& params,
    ByteSource* out) {
  CHECK_NE(key_data->GetKeyType(), kKeyTypeSecret);

  switch (format) {
    case kWebCryptoKeyFormatRaw:
      // Not supported for RSA keys of either type
      return WebCryptoKeyExportStatus::FAILED;
    case kWebCryptoKeyFormatPKCS8:
      if (key_data->GetKeyType() != kKeyTypePrivate)
        return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;
      return PKEY_PKCS8_Export(key_data.get(), out);
    case kWebCryptoKeyFormatSPKI:
      if (key_data->GetKeyType() != kKeyTypePublic)
        return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;
      return PKEY_SPKI_Export(key_data.get(), out);
    default:
      UNREACHABLE();
  }
}",105.0,127.0,1.0,1.0,23.0,10,3,17,10,0,0,4,6,0,0,,0,0,8,4,4,WebCryptoKeyExportStatus
1545,37087,GetDsaKeyDetail,1,node.crypto.GetDsaKeyDetail,"Maybe<bool> node.crypto.GetDsaKeyDetail (Environment*,ANY,Local<Object>)",crypto\crypto_dsa.cc,"Maybe<bool> GetDsaKeyDetail(
    Environment* env,
    std::shared_ptr<KeyObjectData> key,
    Local<Object> target) {
  const BIGNUM* p;  // Modulus length
  const BIGNUM* q;  // Divisor length

  ManagedEVPPKey m_pkey = key->GetAsymmetricKey();
  Mutex::ScopedLock lock(*m_pkey.mutex());
  int type = EVP_PKEY_id(m_pkey.get());
  CHECK(type == EVP_PKEY_DSA);

  const DSA* dsa = EVP_PKEY_get0_DSA(m_pkey.get());
  CHECK_NOT_NULL(dsa);

  DSA_get0_pqg(dsa, &p, &q, nullptr);

  size_t modulus_length = BN_num_bits(p);
  size_t divisor_length = BN_num_bits(q);

  if (target
          ->Set(
              env->context(),
              env->modulus_length_string(),
              Number::New(env->isolate(), static_cast<double>(modulus_length)))
          .IsNothing() ||
      target
          ->Set(
              env->context(),
              env->divisor_length_string(),
              Number::New(env->isolate(), static_cast<double>(divisor_length)))
          .IsNothing()) {
    return Noth...",129.0,165.0,1.0,1.0,37.0,28,8,29,12,0,0,2,2,0,0,,0,0,6,3,3,Maybe<bool>
1546,37210,Initialize,1,node.crypto.DSAAlg.Initialize,"void node.crypto.DSAAlg.Initialize (Environment*,Local<Object>)",crypto\crypto_dsa.cc,"void Initialize(Environment* env, Local<Object> target) {
  DsaKeyPairGenJob::Initialize(env, target);
  DSAKeyExportJob::Initialize(env, target);
}",168.0,171.0,1.0,1.0,4.0,2,1,6,4,0,0,1,1,0,0,,0,0,4,2,2,void
1547,37228,RegisterExternalReferences,1,node.crypto.DSAAlg.RegisterExternalReferences,void node.crypto.DSAAlg.RegisterExternalReferences (ExternalReferenceRegistry*),crypto\crypto_dsa.cc,"void RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  DsaKeyPairGenJob::RegisterExternalReferences(registry);
  DSAKeyExportJob::RegisterExternalReferences(registry);
}",173.0,176.0,1.0,1.0,4.0,2,1,4,3,0,0,1,1,0,0,,0,0,2,1,1,void
1548,37261,<lambda>0,1,node.crypto.ECDH.GetCurves.<lambda>0,ANY node.crypto.ECDH.GetCurves.<lambda>0 (auto),crypto\crypto_ec.cc,"[env](auto& curve) {
    return OneByteString(env->isolate(), OBJ_nid2sn(curve.nid));
  }",115.0,117.0,61.0,3.0,3.0,2,2,2,2,0,0,1,1,0,0,,0,0,2,1,1,ANY
1549,37314,GetCurveFromName,1,node.crypto.GetCurveFromName,int node.crypto.GetCurveFromName (char*),crypto\crypto_ec.cc,"int GetCurveFromName(const char* name) {
  int nid = EC_curve_nist2nid(name);
  if (nid == NID_undef)
    nid = OBJ_sn2nid(name);
  return nid;
}",41.0,46.0,1.0,1.0,6.0,3,2,7,3,0,0,2,2,0,0,,0,0,2,1,1,int
1550,37335,GetOKPCurveFromName,1,node.crypto.GetOKPCurveFromName,int node.crypto.GetOKPCurveFromName (char*),crypto\crypto_ec.cc,"int GetOKPCurveFromName(const char* name) {
  int nid;
  if (strcmp(name, ""Ed25519"") == 0) {
    nid = EVP_PKEY_ED25519;
  } else if (strcmp(name, ""Ed448"") == 0) {
    nid = EVP_PKEY_ED448;
  } else if (strcmp(name, ""X25519"") == 0) {
    nid = EVP_PKEY_X25519;
  } else if (strcmp(name, ""X448"") == 0) {
    nid = EVP_PKEY_X448;
  } else {
    nid = NID_undef;
  }
  return nid;
}",48.0,62.0,1.0,1.0,15.0,2,2,4,3,0,0,2,2,0,0,,0,0,2,1,1,int
1551,37394,Initialize,1,node.crypto.ECDH.Initialize,"void node.crypto.ECDH.Initialize (Environment*,Local<Object>)",crypto\crypto_ec.cc,"void ECDH::Initialize(Environment* env, Local<Object> target) {
  Isolate* isolate = env->isolate();
  Local<Context> context = env->context();

  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, New);

  t->InstanceTemplate()->SetInternalFieldCount(ECDH::kInternalFieldCount);

  SetProtoMethod(isolate, t, ""generateKeys"", GenerateKeys);
  SetProtoMethod(isolate, t, ""computeSecret"", ComputeSecret);
  SetProtoMethodNoSideEffect(isolate, t, ""getPublicKey"", GetPublicKey);
  SetProtoMethodNoSideEffect(isolate, t, ""getPrivateKey"", GetPrivateKey);
  SetProtoMethod(isolate, t, ""setPublicKey"", SetPublicKey);
  SetProtoMethod(isolate, t, ""setPrivateKey"", SetPrivateKey);

  SetConstructorFunction(context, target, ""ECDH"", t);

  SetMethodNoSideEffect(context, target, ""ECDHConvertKey"", ECDH::ConvertKey);
  SetMethodNoSideEffect(context, target, ""getCurves"", ECDH::GetCurves);

  ECDHBitsJob::Initialize(env, target);
  ECKeyPairGenJob::Initialize(env, target);
  ECKeyExportJob::Initialize(...",64.0,90.0,1.0,2.0,27.0,83,7,111,26,0,0,1,1,0,0,,0,0,4,2,2,void
1552,37701,RegisterExternalReferences,1,node.crypto.ECDH.RegisterExternalReferences,void node.crypto.ECDH.RegisterExternalReferences (ExternalReferenceRegistry*),crypto\crypto_ec.cc,"void ECDH::RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  registry->Register(New);
  registry->Register(GenerateKeys);
  registry->Register(ComputeSecret);
  registry->Register(GetPublicKey);
  registry->Register(GetPrivateKey);
  registry->Register(SetPublicKey);
  registry->Register(SetPrivateKey);
  registry->Register(ECDH::ConvertKey);
  registry->Register(ECDH::GetCurves);

  ECDHBitsJob::RegisterExternalReferences(registry);
  ECKeyPairGenJob::RegisterExternalReferences(registry);
  ECKeyExportJob::RegisterExternalReferences(registry);
}",92.0,106.0,1.0,1.0,15.0,14,2,24,12,0,0,1,1,0,0,,0,0,2,1,1,void
1553,37770,GetCurves,1,node.crypto.ECDH.GetCurves,void node.crypto.ECDH.GetCurves (FunctionCallbackInfo<Value>),crypto\crypto_ec.cc,"void ECDH::GetCurves(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  const size_t num_curves = EC_get_builtin_curves(nullptr, 0);
  std::vector<EC_builtin_curve> curves(num_curves);
  CHECK_EQ(EC_get_builtin_curves(curves.data(), num_curves), num_curves);

  std::vector<Local<Value>> arr(num_curves);
  std::transform(curves.begin(), curves.end(), arr.begin(), [env](auto& curve) {
    return OneByteString(env->isolate(), OBJ_nid2sn(curve.nid));
  });
  args.GetReturnValue().Set(Array::New(env->isolate(), arr.data(), arr.size()));
}",108.0,119.0,1.0,1.0,12.0,21,6,23,11,0,0,1,1,0,0,,0,0,2,1,1,void
1554,37854,ECDH,1,node.crypto.ECDH.ECDH,"ANY node.crypto.ECDH.ECDH (Environment*,Local<Object>,ECKeyPointer)",crypto\crypto_ec.cc,"ECDH::ECDH(Environment* env, Local<Object> wrap, ECKeyPointer&& key)
    : BaseObject(env, wrap),
    key_(std::move(key)),
    group_(EC_KEY_get0_group(key_.get())) {
  MakeWeak();
  CHECK_NOT_NULL(group_);
}",121.0,127.0,1.0,1.0,7.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,ANY
1555,37863,MemoryInfo,1,node.crypto.ECDH.MemoryInfo,void node.crypto.ECDH.MemoryInfo (MemoryTracker*),crypto\crypto_ec.cc,"void ECDH::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackFieldWithSize(""key"", key_ ? kSizeOf_EC_KEY : 0);
}",129.0,131.0,1.0,1.0,3.0,2,2,3,3,0,0,1,1,0,0,,0,0,2,1,1,void
1556,37877,~ECDH,1,node.crypto.ECDH.~ECDH,ANY node.crypto.ECDH.~ECDH (),crypto\crypto_ec.cc,ECDH::~ECDH() {},133.0,133.0,1.0,16.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
1557,37881,New,1,node.crypto.ECDH.New,void node.crypto.ECDH.New (FunctionCallbackInfo<Value>),crypto\crypto_ec.cc,"void ECDH::New(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  MarkPopErrorOnReturn mark_pop_error_on_return;

  // TODO(indutny): Support raw curves?
  CHECK(args[0]->IsString());
  node::Utf8Value curve(env->isolate(), args[0]);

  int nid = OBJ_sn2nid(*curve);
  if (nid == NID_undef)
    return THROW_ERR_CRYPTO_INVALID_CURVE(env);

  ECKeyPointer key(EC_KEY_new_by_curve_name(nid));
  if (!key)
    return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
      ""Failed to create key using named curve"");

  new ECDH(env, args.This(), std::move(key));
}",135.0,154.0,1.0,1.0,20.0,13,8,19,9,0,0,3,3,0,0,,0,0,2,1,1,void
1558,37949,GenerateKeys,1,node.crypto.ECDH.GenerateKeys,void node.crypto.ECDH.GenerateKeys (FunctionCallbackInfo<Value>),crypto\crypto_ec.cc,"void ECDH::GenerateKeys(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  ECDH* ecdh;
  ASSIGN_OR_RETURN_UNWRAP(&ecdh, args.Holder());

  if (!EC_KEY_generate_key(ecdh->key_.get()))
    return THROW_ERR_CRYPTO_OPERATION_FAILED(env, ""Failed to generate key"");
}",156.0,164.0,1.0,1.0,9.0,7,5,7,4,0,0,2,2,0,0,,0,0,2,1,1,void
1559,37984,BufferToPoint,1,node.crypto.ECDH.BufferToPoint,"ECPointPointer node.crypto.ECDH.BufferToPoint (Environment*,EC_GROUP*,Local<Value>)",crypto\crypto_ec.cc,"ECPointPointer ECDH::BufferToPoint(Environment* env,
                                   const EC_GROUP* group,
                                   Local<Value> buf) {
  int r;

  ECPointPointer pub(EC_POINT_new(group));
  if (!pub) {
    THROW_ERR_CRYPTO_OPERATION_FAILED(env,
        ""Failed to allocate EC_POINT for a public key"");
    return pub;
  }

  ArrayBufferOrViewContents<unsigned char> input(buf);
  if (UNLIKELY(!input.CheckSizeInt32())) {
    THROW_ERR_OUT_OF_RANGE(env, ""buffer is too big"");
    return ECPointPointer();
  }
  r = EC_POINT_oct2point(
      group,
      pub.get(),
      input.data(),
      input.size(),
      nullptr);
  if (!r)
    return ECPointPointer();

  return pub;
}",166.0,193.0,1.0,1.0,28.0,8,3,14,6,0,0,4,4,0,0,,0,0,6,3,3,ECPointPointer
1560,38046,ComputeSecret,1,node.crypto.ECDH.ComputeSecret,void node.crypto.ECDH.ComputeSecret (FunctionCallbackInfo<Value>),crypto\crypto_ec.cc,"void ECDH::ComputeSecret(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  CHECK(IsAnyByteSource(args[0]));

  ECDH* ecdh;
  ASSIGN_OR_RETURN_UNWRAP(&ecdh, args.Holder());

  MarkPopErrorOnReturn mark_pop_error_on_return;

  if (!ecdh->IsKeyPairValid())
    return THROW_ERR_CRYPTO_INVALID_KEYPAIR(env);

  ECPointPointer pub(
      ECDH::BufferToPoint(env,
                          ecdh->group_,
                          args[0]));
  if (!pub) {
    args.GetReturnValue().Set(
        FIXED_ONE_BYTE_STRING(env->isolate(),
        ""ERR_CRYPTO_ECDH_INVALID_PUBLIC_KEY""));
    return;
  }

  std::unique_ptr<BackingStore> bs;
  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    // NOTE: field_size is in bits
    int field_size = EC_GROUP_get_degree(ecdh->group_);
    size_t out_len = (field_size + 7) / 8;
    bs = ArrayBuffer::NewBackingStore(env->isolate(), out_len);
  }

  if (!ECDH_compute_key(
          bs->Data...",195.0,236.0,1.0,1.0,42.0,47,10,49,17,0,0,5,5,0,0,,0,0,2,1,1,void
1561,38233,GetPublicKey,1,node.crypto.ECDH.GetPublicKey,void node.crypto.ECDH.GetPublicKey (FunctionCallbackInfo<Value>),crypto\crypto_ec.cc,"void ECDH::GetPublicKey(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  // Conversion form
  CHECK_EQ(args.Length(), 1);

  ECDH* ecdh;
  ASSIGN_OR_RETURN_UNWRAP(&ecdh, args.Holder());

  const EC_GROUP* group = EC_KEY_get0_group(ecdh->key_.get());
  const EC_POINT* pub = EC_KEY_get0_public_key(ecdh->key_.get());
  if (pub == nullptr)
    return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
        ""Failed to get ECDH public key"");

  CHECK(args[0]->IsUint32());
  uint32_t val = args[0].As<Uint32>()->Value();
  point_conversion_form_t form = static_cast<point_conversion_form_t>(val);

  const char* error;
  Local<Object> buf;
  if (!ECPointToBuffer(env, group, pub, form, &error).ToLocal(&buf))
    return THROW_ERR_CRYPTO_OPERATION_FAILED(env, error);
  args.GetReturnValue().Set(buf);
}",238.0,262.0,1.0,1.0,25.0,28,10,30,12,0,0,3,3,0,0,,0,0,2,1,1,void
1562,38347,GetPrivateKey,1,node.crypto.ECDH.GetPrivateKey,void node.crypto.ECDH.GetPrivateKey (FunctionCallbackInfo<Value>),crypto\crypto_ec.cc,"void ECDH::GetPrivateKey(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  ECDH* ecdh;
  ASSIGN_OR_RETURN_UNWRAP(&ecdh, args.Holder());

  const BIGNUM* b = EC_KEY_get0_private_key(ecdh->key_.get());
  if (b == nullptr)
    return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
        ""Failed to get ECDH private key"");

  std::unique_ptr<BackingStore> bs;
  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), BN_num_bytes(b));
  }
  CHECK_EQ(static_cast<int>(bs->ByteLength()),
           BN_bn2binpad(
               b, static_cast<unsigned char*>(bs->Data()), bs->ByteLength()));

  Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(bs));
  Local<Value> buffer;
  if (!Buffer::New(env, ab, 0, ab->ByteLength()).ToLocal(&buffer)) return;
  args.GetReturnValue().Set(buffer);
}",264.0,288.0,1.0,1.0,25.0,35,9,38,14,0,0,3,3,0,0,,0,0,2,1,1,void
1563,38484,SetPrivateKey,1,node.crypto.ECDH.SetPrivateKey,void node.crypto.ECDH.SetPrivateKey (FunctionCallbackInfo<Value>),crypto\crypto_ec.cc,"void ECDH::SetPrivateKey(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  ECDH* ecdh;
  ASSIGN_OR_RETURN_UNWRAP(&ecdh, args.Holder());

  ArrayBufferOrViewContents<unsigned char> priv_buffer(args[0]);
  if (UNLIKELY(!priv_buffer.CheckSizeInt32()))
    return THROW_ERR_OUT_OF_RANGE(env, ""key is too big"");

  BignumPointer priv(BN_bin2bn(
      priv_buffer.data(), priv_buffer.size(), nullptr));
  if (!priv) {
    return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
        ""Failed to convert Buffer to BN"");
  }

  if (!ecdh->IsKeyValidForCurve(priv)) {
    return THROW_ERR_CRYPTO_INVALID_KEYTYPE(env,
        ""Private key is not valid for specified curve."");
  }

  ECKeyPointer new_key(EC_KEY_dup(ecdh->key_.get()));
  CHECK(new_key);

  int result = EC_KEY_set_private_key(new_key.get(), priv.get());
  priv.reset();

  if (!result) {
    return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
        ""Failed to convert BN to a private key"");
  }

  MarkPo...",290.0,344.0,1.0,1.0,55.0,36,6,41,12,0,0,7,7,0,0,,0,0,2,1,1,void
1564,38666,SetPublicKey,1,node.crypto.ECDH.SetPublicKey,void node.crypto.ECDH.SetPublicKey (FunctionCallbackInfo<Value>),crypto\crypto_ec.cc,"void ECDH::SetPublicKey(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  ECDH* ecdh;
  ASSIGN_OR_RETURN_UNWRAP(&ecdh, args.Holder());

  CHECK(IsAnyByteSource(args[0]));

  MarkPopErrorOnReturn mark_pop_error_on_return;

  ECPointPointer pub(
      ECDH::BufferToPoint(env,
                          ecdh->group_,
                          args[0]));
  if (!pub) {
    return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
        ""Failed to convert Buffer to EC_POINT"");
  }

  int r = EC_KEY_set_public_key(ecdh->key_.get(), pub.get());
  if (!r) {
    return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
        ""Failed to set EC_POINT as the public key"");
  }
}",346.0,370.0,1.0,1.0,25.0,14,6,17,7,0,0,3,3,0,0,,0,0,2,1,1,void
1565,38736,IsKeyValidForCurve,1,node.crypto.ECDH.IsKeyValidForCurve,bool node.crypto.ECDH.IsKeyValidForCurve (BignumPointer),crypto\crypto_ec.cc,"bool ECDH::IsKeyValidForCurve(const BignumPointer& private_key) {
  CHECK(group_);
  CHECK(private_key);
  // Private keys must be in the range [1, n-1].
  // Ref: Section 3.2.1 - http://www.secg.org/sec1-v2.pdf
  if (BN_cmp(private_key.get(), BN_value_one()) < 0) {
    return false;
  }
  BignumPointer order(BN_new());
  CHECK(order);
  return EC_GROUP_get_order(group_, order.get(), nullptr) &&
         BN_cmp(private_key.get(), order.get()) < 0;
}",372.0,384.0,1.0,1.0,13.0,7,3,7,3,0,0,2,2,0,0,,0,0,2,1,1,bool
1566,38781,IsKeyPairValid,1,node.crypto.ECDH.IsKeyPairValid,bool node.crypto.ECDH.IsKeyPairValid (),crypto\crypto_ec.cc,"bool ECDH::IsKeyPairValid() {
  MarkPopErrorOnReturn mark_pop_error_on_return;
  USE(&mark_pop_error_on_return);
  return 1 == EC_KEY_check_key(key_.get());
}",386.0,390.0,1.0,1.0,5.0,3,3,2,2,0,0,1,1,0,0,,0,0,0,0,0,bool
1567,38797,ConvertKey,1,node.crypto.ECDH.ConvertKey,void node.crypto.ECDH.ConvertKey (FunctionCallbackInfo<Value>),crypto\crypto_ec.cc,"void ECDH::ConvertKey(const FunctionCallbackInfo<Value>& args) {
  MarkPopErrorOnReturn mark_pop_error_on_return;
  Environment* env = Environment::GetCurrent(args);

  CHECK_EQ(args.Length(), 3);
  CHECK(IsAnyByteSource(args[0]));

  ArrayBufferOrViewContents<char> args0(args[0]);
  if (UNLIKELY(!args0.CheckSizeInt32()))
    return THROW_ERR_OUT_OF_RANGE(env, ""key is too big"");
  if (args0.size() == 0)
    return args.GetReturnValue().SetEmptyString();

  node::Utf8Value curve(env->isolate(), args[1]);

  int nid = OBJ_sn2nid(*curve);
  if (nid == NID_undef)
    return THROW_ERR_CRYPTO_INVALID_CURVE(env);

  ECGroupPointer group(
      EC_GROUP_new_by_curve_name(nid));
  if (group == nullptr)
    return THROW_ERR_CRYPTO_OPERATION_FAILED(env, ""Failed to get EC_GROUP"");

  ECPointPointer pub(
      ECDH::BufferToPoint(env,
                          group.get(),
                          args[0]));

  if (pub == nullptr) {
    return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
        ""Fai...",393.0,436.0,1.0,1.0,44.0,39,11,44,16,0,0,7,7,0,0,,0,0,2,1,1,void
1568,38978,MemoryInfo,1,node.crypto.ECDHBitsConfig.MemoryInfo,void node.crypto.ECDHBitsConfig.MemoryInfo (MemoryTracker*),crypto\crypto_ec.cc,"void ECDHBitsConfig::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackField(""public"", public_);
  tracker->TrackField(""private"", private_);
}",438.0,441.0,1.0,1.0,4.0,2,1,4,3,0,0,1,1,0,0,,0,0,2,1,1,void
1569,38995,EncodeOutput,1,node.crypto.ECDHBitsTraits.EncodeOutput,"Maybe<bool> node.crypto.ECDHBitsTraits.EncodeOutput (Environment*,ECDHBitsConfig,ByteSource*,ANY*)",crypto\crypto_ec.cc,"Maybe<bool> ECDHBitsTraits::EncodeOutput(
    Environment* env,
    const ECDHBitsConfig& params,
    ByteSource* out,
    v8::Local<v8::Value>* result) {
  *result = out->ToArrayBuffer(env);
  return Just(!result->IsEmpty());
}",443.0,450.0,1.0,1.0,8.0,5,4,4,3,0,0,1,1,0,0,,0,0,8,4,4,Maybe<bool>
1570,39018,AdditionalConfig,1,node.crypto.ECDHBitsTraits.AdditionalConfig,"Maybe<bool> node.crypto.ECDHBitsTraits.AdditionalConfig (CryptoJobMode,FunctionCallbackInfo<Value>,unsigned int,ECDHBitsConfig*)",crypto\crypto_ec.cc,"Maybe<bool> ECDHBitsTraits::AdditionalConfig(
    CryptoJobMode mode,
    const FunctionCallbackInfo<Value>& args,
    unsigned int offset,
    ECDHBitsConfig* params) {
  Environment* env = Environment::GetCurrent(args);

  CHECK(args[offset]->IsString());  // curve name
  CHECK(args[offset + 1]->IsObject());  // public key
  CHECK(args[offset + 2]->IsObject());  // private key

  KeyObjectHandle* private_key;
  KeyObjectHandle* public_key;

  Utf8Value name(env->isolate(), args[offset]);

  ASSIGN_OR_RETURN_UNWRAP(&public_key, args[offset + 1], Nothing<bool>());
  ASSIGN_OR_RETURN_UNWRAP(&private_key, args[offset + 2], Nothing<bool>());

  if (private_key->Data()->GetKeyType() != kKeyTypePrivate ||
      public_key->Data()->GetKeyType() != kKeyTypePublic) {
    THROW_ERR_CRYPTO_INVALID_KEYTYPE(env);
    return Nothing<bool>();
  }

  params->id_ = GetOKPCurveFromName(*name);
  params->private_ = private_key->Data();
  params->public_ = public_key->Data();

  return Just(true);
}",452.0,482.0,1.0,1.0,31.0,34,9,29,10,0,0,2,2,0,0,,0,0,8,4,4,Maybe<bool>
1571,39139,DeriveBits,1,node.crypto.ECDHBitsTraits.DeriveBits,"bool node.crypto.ECDHBitsTraits.DeriveBits (Environment*,ECDHBitsConfig,ByteSource*)",crypto\crypto_ec.cc,"bool ECDHBitsTraits::DeriveBits(Environment* env,
                                const ECDHBitsConfig& params,
                                ByteSource* out) {
  size_t len = 0;
  ManagedEVPPKey m_privkey = params.private_->GetAsymmetricKey();
  ManagedEVPPKey m_pubkey = params.public_->GetAsymmetricKey();

  switch (params.id_) {
    case EVP_PKEY_X25519:
      // Fall through
    case EVP_PKEY_X448: {
      EVPKeyCtxPointer ctx = nullptr;
      {
        ctx.reset(EVP_PKEY_CTX_new(m_privkey.get(), nullptr));
      }
      Mutex::ScopedLock pub_lock(*m_pubkey.mutex());
      if (EVP_PKEY_derive_init(ctx.get()) <= 0 ||
          EVP_PKEY_derive_set_peer(
              ctx.get(),
              m_pubkey.get()) <= 0 ||
          EVP_PKEY_derive(ctx.get(), nullptr, &len) <= 0) {
        return false;
      }

      ByteSource::Builder buf(len);

      if (EVP_PKEY_derive(ctx.get(), buf.data<unsigned char>(), &len) <= 0) {
        return false;
      }

      *out = std::move(buf).rel...",484.0,550.0,1.0,1.0,67.0,52,10,52,15,0,0,7,10,0,0,,0,0,6,3,3,bool
1572,39372,Setup,1,node.crypto.EcKeyGenTraits.Setup,EVPKeyCtxPointer node.crypto.EcKeyGenTraits.Setup (EcKeyPairGenConfig*),crypto\crypto_ec.cc,"EVPKeyCtxPointer EcKeyGenTraits::Setup(EcKeyPairGenConfig* params) {
  EVPKeyCtxPointer key_ctx;
  switch (params->params.curve_nid) {
    case EVP_PKEY_ED25519:
      // Fall through
    case EVP_PKEY_ED448:
      // Fall through
    case EVP_PKEY_X25519:
      // Fall through
    case EVP_PKEY_X448:
      key_ctx.reset(EVP_PKEY_CTX_new_id(params->params.curve_nid, nullptr));
      break;
    default: {
      EVPKeyCtxPointer param_ctx(EVP_PKEY_CTX_new_id(EVP_PKEY_EC, nullptr));
      EVP_PKEY* raw_params = nullptr;
      if (!param_ctx ||
          EVP_PKEY_paramgen_init(param_ctx.get()) <= 0 ||
          EVP_PKEY_CTX_set_ec_paramgen_curve_nid(
              param_ctx.get(), params->params.curve_nid) <= 0 ||
          EVP_PKEY_CTX_set_ec_param_enc(
              param_ctx.get(), params->params.param_encoding) <= 0 ||
          EVP_PKEY_paramgen(param_ctx.get(), &raw_params) <= 0) {
        return EVPKeyCtxPointer();
      }
      EVPKeyPointer key_params(raw_params);
      key_ctx...",552.0,585.0,1.0,1.0,34.0,30,8,24,10,0,0,5,5,0,0,,0,0,2,1,1,EVPKeyCtxPointer
1573,39496,AdditionalConfig,1,node.crypto.EcKeyGenTraits.AdditionalConfig,"Maybe<bool> node.crypto.EcKeyGenTraits.AdditionalConfig (CryptoJobMode,FunctionCallbackInfo<Value>,unsigned int*,EcKeyPairGenConfig*)",crypto\crypto_ec.cc,"Maybe<bool> EcKeyGenTraits::AdditionalConfig(
    CryptoJobMode mode,
    const FunctionCallbackInfo<Value>& args,
    unsigned int* offset,
    EcKeyPairGenConfig* params) {
  Environment* env = Environment::GetCurrent(args);
  CHECK(args[*offset]->IsString());  // curve name
  CHECK(args[*offset + 1]->IsInt32());  // param encoding

  Utf8Value curve_name(env->isolate(), args[*offset]);
  params->params.curve_nid = GetCurveFromName(*curve_name);
  if (params->params.curve_nid == NID_undef) {
    THROW_ERR_CRYPTO_INVALID_CURVE(env);
    return Nothing<bool>();
  }

  params->params.param_encoding = args[*offset + 1].As<Int32>()->Value();
  if (params->params.param_encoding != OPENSSL_EC_NAMED_CURVE &&
      params->params.param_encoding != OPENSSL_EC_EXPLICIT_CURVE) {
    THROW_ERR_OUT_OF_RANGE(env, ""Invalid param_encoding specified"");
    return Nothing<bool>();
  }

  *offset += 2;

  return Just(true);
}",597.0,623.0,1.0,1.0,27.0,36,10,24,9,0,0,3,3,0,0,,0,0,8,4,4,Maybe<bool>
1574,39610,EC_Raw_Export,1,node.crypto.anonymous_namespace_1.EC_Raw_Export,"WebCryptoKeyExportStatus node.crypto.anonymous_namespace_1.EC_Raw_Export (KeyObjectData*,ECKeyExportConfig,ByteSource*)",crypto\crypto_ec.cc,"WebCryptoKeyExportStatus EC_Raw_Export(
    KeyObjectData* key_data,
    const ECKeyExportConfig& params,
    ByteSource* out) {
  ManagedEVPPKey m_pkey = key_data->GetAsymmetricKey();
  CHECK(m_pkey);
  Mutex::ScopedLock lock(*m_pkey.mutex());

  const EC_KEY* ec_key = EVP_PKEY_get0_EC_KEY(m_pkey.get());

  size_t len = 0;

  if (ec_key == nullptr) {
    typedef int (*export_fn)(const EVP_PKEY*, unsigned char*, size_t* len);
    export_fn fn = nullptr;
    switch (key_data->GetKeyType()) {
      case kKeyTypePrivate:
        fn = EVP_PKEY_get_raw_private_key;
        break;
      case kKeyTypePublic:
        fn = EVP_PKEY_get_raw_public_key;
        break;
      case kKeyTypeSecret:
        UNREACHABLE();
    }
    CHECK_NOT_NULL(fn);
    // Get the size of the raw key data
    if (fn(m_pkey.get(), nullptr, &len) == 0)
      return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;
    ByteSource::Builder data(len);
    if (fn(m_pkey.get(), data.data<unsigned char>(), &len) == 0)
      re...",626.0,681.0,1.0,1.0,56.0,26,6,31,14,0,0,7,8,0,0,,0,0,6,3,3,WebCryptoKeyExportStatus
1575,39648,export_fn,1,node.crypto.anonymous_namespace_2.EC_Raw_Export.export_fn,"int node.crypto.anonymous_namespace_2.EC_Raw_Export.export_fn (EVP_PKEY*,unsigned char*,size_t*)",crypto\crypto_ec.cc,"typedef int (*export_fn)(const EVP_PKEY*, unsigned char*, size_t* len);",639.0,639.0,17.0,74.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,int
1576,39823,AdditionalConfig,1,node.crypto.ECKeyExportTraits.AdditionalConfig,"Maybe<bool> node.crypto.ECKeyExportTraits.AdditionalConfig (FunctionCallbackInfo<Value>,unsigned int,ECKeyExportConfig*)",crypto\crypto_ec.cc,"Maybe<bool> ECKeyExportTraits::AdditionalConfig(
    const FunctionCallbackInfo<Value>& args,
    unsigned int offset,
    ECKeyExportConfig* params) {
  return Just(true);
}",684.0,689.0,1.0,1.0,6.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,Maybe<bool>
1577,39833,DoExport,1,node.crypto.ECKeyExportTraits.DoExport,"WebCryptoKeyExportStatus node.crypto.ECKeyExportTraits.DoExport (ANY,WebCryptoKeyFormat,ECKeyExportConfig,ByteSource*)",crypto\crypto_ec.cc,"WebCryptoKeyExportStatus ECKeyExportTraits::DoExport(
    std::shared_ptr<KeyObjectData> key_data,
    WebCryptoKeyFormat format,
    const ECKeyExportConfig& params,
    ByteSource* out) {
  CHECK_NE(key_data->GetKeyType(), kKeyTypeSecret);

  switch (format) {
    case kWebCryptoKeyFormatRaw:
      return EC_Raw_Export(key_data.get(), params, out);
    case kWebCryptoKeyFormatPKCS8:
      if (key_data->GetKeyType() != kKeyTypePrivate)
        return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;
      return PKEY_PKCS8_Export(key_data.get(), out);
    case kWebCryptoKeyFormatSPKI: {
      if (key_data->GetKeyType() != kKeyTypePublic)
        return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;

      ManagedEVPPKey m_pkey = key_data->GetAsymmetricKey();
      if (EVP_PKEY_id(m_pkey.get()) != EVP_PKEY_EC) {
        return PKEY_SPKI_Export(key_data.get(), out);
      } else {
        // Ensure exported key is in uncompressed point format.
        // The temporary EC key is so we can have...",691.0,753.0,1.0,1.0,63.0,14,4,23,13,0,0,5,8,0,0,,0,0,8,4,4,WebCryptoKeyExportStatus
1578,40049,bio,1,node.crypto.ECKeyExportTraits.DoExport.bio,BIOPointer node.crypto.ECKeyExportTraits.DoExport.bio (BIO_new),crypto\crypto_ec.cc,BIOPointer bio(BIO_new(BIO_s_mem()));,742.0,742.0,20.0,44.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,BIOPointer
1579,40088,ExportJWKEcKey,1,node.crypto.ExportJWKEcKey,"Maybe<void> node.crypto.ExportJWKEcKey (Environment*,ANY,Local<Object>)",crypto\crypto_ec.cc,"Maybe<void> ExportJWKEcKey(
    Environment* env,
    std::shared_ptr<KeyObjectData> key,
    Local<Object> target) {
  ManagedEVPPKey m_pkey = key->GetAsymmetricKey();
  Mutex::ScopedLock lock(*m_pkey.mutex());
  CHECK_EQ(EVP_PKEY_id(m_pkey.get()), EVP_PKEY_EC);

  const EC_KEY* ec = EVP_PKEY_get0_EC_KEY(m_pkey.get());
  CHECK_NOT_NULL(ec);

  const EC_POINT* pub = EC_KEY_get0_public_key(ec);
  const EC_GROUP* group = EC_KEY_get0_group(ec);

  int degree_bits = EC_GROUP_get_degree(group);
  int degree_bytes =
    (degree_bits / CHAR_BIT) + (7 + (degree_bits % CHAR_BIT)) / 8;

  BignumPointer x(BN_new());
  BignumPointer y(BN_new());

  if (!EC_POINT_get_affine_coordinates(group, pub, x.get(), y.get(), nullptr)) {
    ThrowCryptoError(env, ERR_get_error(),
                     ""Failed to get elliptic-curve point coordinates"");
    return Nothing<void>();
  }

  if (target->Set(
          env->context(),
          env->jwk_kty_string(),
          env->jwk_ec_string()).IsNothing()) {
...",755.0,843.0,1.0,1.0,89.0,52,13,71,23,0,0,11,7,0,0,,0,0,6,3,3,Maybe<void>
1580,40357,ExportJWKEdKey,1,node.crypto.ExportJWKEdKey,"Maybe<bool> node.crypto.ExportJWKEdKey (Environment*,ANY,Local<Object>)",crypto\crypto_ec.cc,"Maybe<bool> ExportJWKEdKey(
    Environment* env,
    std::shared_ptr<KeyObjectData> key,
    Local<Object> target) {
  ManagedEVPPKey pkey = key->GetAsymmetricKey();
  Mutex::ScopedLock lock(*pkey.mutex());

  const char* curve = nullptr;
  switch (EVP_PKEY_id(pkey.get())) {
    case EVP_PKEY_ED25519:
      curve = ""Ed25519"";
      break;
    case EVP_PKEY_ED448:
      curve = ""Ed448"";
      break;
    case EVP_PKEY_X25519:
      curve = ""X25519"";
      break;
    case EVP_PKEY_X448:
      curve = ""X448"";
      break;
    default:
      UNREACHABLE();
  }
  if (target->Set(
          env->context(),
          env->jwk_crv_string(),
          OneByteString(env->isolate(), curve)).IsNothing()) {
    return Nothing<bool>();
  }

  size_t len = 0;
  Local<Value> encoded;
  Local<Value> error;

  if (!EVP_PKEY_get_raw_public_key(pkey.get(), nullptr, &len))
    return Nothing<bool>();

  ByteSource::Builder out(len);

  if (key->GetKeyType() == kKeyTypePrivate) {
    if (!EVP_PKEY_get_ra...",845.0,917.0,1.0,1.0,73.0,74,10,68,18,0,0,14,14,0,0,,0,0,6,3,3,Maybe<bool>
1581,40648,ImportJWKEcKey,1,node.crypto.ImportJWKEcKey,"shared_ptr<KeyObjectData> node.crypto.ImportJWKEcKey (Environment*,Local<Object>,FunctionCallbackInfo<Value>,unsigned int)",crypto\crypto_ec.cc,"std::shared_ptr<KeyObjectData> ImportJWKEcKey(
    Environment* env,
    Local<Object> jwk,
    const FunctionCallbackInfo<Value>& args,
    unsigned int offset) {
  CHECK(args[offset]->IsString());  // curve name
  Utf8Value curve(env->isolate(), args[offset].As<String>());

  int nid = GetCurveFromName(*curve);
  if (nid == NID_undef) {  // Unknown curve
    THROW_ERR_CRYPTO_INVALID_CURVE(env);
    return std::shared_ptr<KeyObjectData>();
  }

  Local<Value> x_value;
  Local<Value> y_value;
  Local<Value> d_value;

  if (!jwk->Get(env->context(), env->jwk_x_string()).ToLocal(&x_value) ||
      !jwk->Get(env->context(), env->jwk_y_string()).ToLocal(&y_value) ||
      !jwk->Get(env->context(), env->jwk_d_string()).ToLocal(&d_value)) {
    return std::shared_ptr<KeyObjectData>();
  }

  if (!x_value->IsString() ||
      !y_value->IsString() ||
      (!d_value->IsUndefined() && !d_value->IsString())) {
    THROW_ERR_CRYPTO_INVALID_JWK(env, ""Invalid JWK EC key"");
    return std::shared...",919.0,981.0,1.0,1.0,63.0,79,13,76,23,0,0,8,9,0,0,,0,0,8,4,4,shared_ptr<KeyObjectData>
1582,40950,GetEcKeyDetail,1,node.crypto.GetEcKeyDetail,"Maybe<bool> node.crypto.GetEcKeyDetail (Environment*,ANY,Local<Object>)",crypto\crypto_ec.cc,"Maybe<bool> GetEcKeyDetail(
    Environment* env,
    std::shared_ptr<KeyObjectData> key,
    Local<Object> target) {
  ManagedEVPPKey m_pkey = key->GetAsymmetricKey();
  Mutex::ScopedLock lock(*m_pkey.mutex());
  CHECK_EQ(EVP_PKEY_id(m_pkey.get()), EVP_PKEY_EC);

  const EC_KEY* ec = EVP_PKEY_get0_EC_KEY(m_pkey.get());
  CHECK_NOT_NULL(ec);

  const EC_GROUP* group = EC_KEY_get0_group(ec);
  int nid = EC_GROUP_get_curve_name(group);

  return target->Set(
      env->context(),
      env->named_curve_string(),
      OneByteString(env->isolate(), OBJ_nid2sn(nid)));
}",983.0,1001.0,1.0,1.0,19.0,13,4,17,8,0,0,1,1,0,0,,0,0,6,3,3,Maybe<bool>
1583,41018,GroupOrderSize,1,node.crypto.GroupOrderSize,size_t node.crypto.GroupOrderSize (ManagedEVPPKey),crypto\crypto_ec.cc,"size_t GroupOrderSize(const ManagedEVPPKey& key) {
  const EC_KEY* ec = EVP_PKEY_get0_EC_KEY(key.get());
  CHECK_NOT_NULL(ec);
  const EC_GROUP* group = EC_KEY_get0_group(ec);
  BignumPointer order(BN_new());
  CHECK(EC_GROUP_get_order(group, order.get(), nullptr));
  return BN_num_bytes(order.get());
}",1008.0,1015.0,1.0,1.0,8.0,5,2,8,4,0,0,1,1,0,0,,0,0,2,1,1,size_t
1584,41079,<lambda>0,1,"args, [](Hash* hash, const FunctionCallbackInfo<Value>& args, const char* data, size_t size) { Environment* env = Environment.GetCurrent(args); if (UNLIKELY(size > INT_MAX)) return THROW_ERR_OUT_OF_RANGE(env, ""data is too long""); bool r = hash->HashUpdate(data, size); args.GetReturnValue().Set(r); }.<lambda>0","ANY args, [](Hash* hash, const FunctionCallbackInfo<Value>& args, const char* data, size_t size) { Environment* env = Environment.GetCurrent(args); if (UNLIKELY(size > INT_MAX)) return THROW_ERR_OUT_OF_RANGE(env, ""data is too long""); bool r = hash->HashUpdate(data, size); args.GetReturnValue().Set(r); }.<lambda>0 (Hash*,FunctionCallbackInfo<Value>,char*,size_t)",crypto\crypto_hash.cc,"[](Hash* hash, const FunctionCallbackInfo<Value>& args,
                        const char* data, size_t size) {
    Environment* env = Environment::GetCurrent(args);
    if (UNLIKELY(size > INT_MAX))
      return THROW_ERR_OUT_OF_RANGE(env, ""data is too long"");
    bool r = hash->HashUpdate(data, size);
    args.GetReturnValue().Set(r);
  }",141.0,148.0,22.0,3.0,8.0,7,4,12,8,0,0,2,2,0,0,,0,0,8,4,4,ANY
1585,41148,Hash,1,node.crypto.Hash.Hash,"ANY node.crypto.Hash.Hash (Environment*,Local<Object>)",crypto\crypto_hash.cc,"Hash::Hash(Environment* env, Local<Object> wrap) : BaseObject(env, wrap) {
  MakeWeak();
}",28.0,30.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,ANY
1586,41155,MemoryInfo,1,node.crypto.Hash.MemoryInfo,void node.crypto.Hash.MemoryInfo (MemoryTracker*),crypto\crypto_hash.cc,"void Hash::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackFieldWithSize(""mdctx"", mdctx_ ? kSizeOf_EVP_MD_CTX : 0);
  tracker->TrackFieldWithSize(""md"", digest_ ? md_len_ : 0);
}",32.0,35.0,1.0,1.0,4.0,4,2,6,5,0,0,1,1,0,0,,0,0,2,1,1,void
1587,41178,GetHashes,1,node.crypto.Hash.GetHashes,void node.crypto.Hash.GetHashes (FunctionCallbackInfo<Value>),crypto\crypto_hash.cc,"void Hash::GetHashes(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  MarkPopErrorOnReturn mark_pop_error_on_return;
  CipherPushContext ctx(env);
  EVP_MD_do_all_sorted(
#if OPENSSL_VERSION_MAJOR >= 3
    array_push_back<EVP_MD,
                    EVP_MD_fetch,
                    EVP_MD_free,
                    EVP_get_digestbyname,
                    EVP_MD_get0_name>,
#else
    array_push_back<EVP_MD>,
#endif
    &ctx);
  args.GetReturnValue().Set(ctx.ToJSArray());
}",37.0,53.0,1.0,1.0,17.0,6,3,8,5,0,0,1,1,0,0,,0,0,2,1,1,void
1588,41210,Initialize,1,node.crypto.Hash.Initialize,"void node.crypto.Hash.Initialize (Environment*,Local<Object>)",crypto\crypto_hash.cc,"void Hash::Initialize(Environment* env, Local<Object> target) {
  Isolate* isolate = env->isolate();
  Local<Context> context = env->context();
  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, New);

  t->InstanceTemplate()->SetInternalFieldCount(Hash::kInternalFieldCount);

  SetProtoMethod(isolate, t, ""update"", HashUpdate);
  SetProtoMethod(isolate, t, ""digest"", HashDigest);

  SetConstructorFunction(context, target, ""Hash"", t);

  SetMethodNoSideEffect(context, target, ""getHashes"", GetHashes);

  HashJob::Initialize(env, target);
}",55.0,70.0,1.0,1.0,16.0,13,5,28,14,0,0,1,1,0,0,,0,0,4,2,2,void
1589,41278,RegisterExternalReferences,1,node.crypto.Hash.RegisterExternalReferences,void node.crypto.Hash.RegisterExternalReferences (ExternalReferenceRegistry*),crypto\crypto_hash.cc,"void Hash::RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  registry->Register(New);
  registry->Register(HashUpdate);
  registry->Register(HashDigest);
  registry->Register(GetHashes);

  HashJob::RegisterExternalReferences(registry);
}",72.0,79.0,1.0,1.0,8.0,5,2,10,6,0,0,1,1,0,0,,0,0,2,1,1,void
1590,41308,New,1,node.crypto.Hash.New,void node.crypto.Hash.New (FunctionCallbackInfo<Value>),crypto\crypto_hash.cc,"void Hash::New(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  const Hash* orig = nullptr;
  const EVP_MD* md = nullptr;

  if (args[0]->IsObject()) {
    ASSIGN_OR_RETURN_UNWRAP(&orig, args[0].As<Object>());
    md = EVP_MD_CTX_md(orig->mdctx_.get());
  } else {
    const Utf8Value hash_type(env->isolate(), args[0]);
    md = EVP_get_digestbyname(*hash_type);
  }

  Maybe<unsigned int> xof_md_len = Nothing<unsigned int>();
  if (!args[1]->IsUndefined()) {
    CHECK(args[1]->IsUint32());
    xof_md_len = Just<unsigned int>(args[1].As<Uint32>()->Value());
  }

  Hash* hash = new Hash(env, args.This());
  if (md == nullptr || !hash->HashInit(md, xof_md_len)) {
    return ThrowCryptoError(env, ERR_get_error(),
                            ""Digest method not supported"");
  }

  if (orig != nullptr &&
      0 >= EVP_MD_CTX_copy(hash->mdctx_.get(), orig->mdctx_.get())) {
    return ThrowCryptoError(env, ERR_get_error(), ""Digest copy error"")...",81.0,111.0,1.0,1.0,31.0,36,12,28,8,0,0,5,5,0,0,,0,0,2,1,1,void
1591,41457,HashInit,1,node.crypto.Hash.HashInit,"bool node.crypto.Hash.HashInit (EVP_MD*,Maybe<unsigned int>)",crypto\crypto_hash.cc,"bool Hash::HashInit(const EVP_MD* md, Maybe<unsigned int> xof_md_len) {
  mdctx_.reset(EVP_MD_CTX_new());
  if (!mdctx_ || EVP_DigestInit_ex(mdctx_.get(), md, nullptr) <= 0) {
    mdctx_.reset();
    return false;
  }

  md_len_ = EVP_MD_size(md);
  if (xof_md_len.IsJust() && xof_md_len.FromJust() != md_len_) {
    // This is a little hack to cause createHash to fail when an incorrect
    // hashSize option was passed for a non-XOF hash function.
    if ((EVP_MD_flags(md) & EVP_MD_FLAG_XOF) == 0) {
      EVPerr(EVP_F_EVP_DIGESTFINALXOF, EVP_R_NOT_XOF_OR_INVALID_LENGTH);
      return false;
    }
    md_len_ = xof_md_len.FromJust();
  }

  return true;
}",113.0,132.0,1.0,1.0,20.0,15,9,16,7,0,0,4,5,0,0,,0,0,4,2,2,bool
1592,41526,HashUpdate,1,node.crypto.Hash.HashUpdate,"bool node.crypto.Hash.HashUpdate (char*,size_t)",crypto\crypto_hash.cc,"void Hash::HashUpdate(const FunctionCallbackInfo<Value>& args) {
  Decode<Hash>(args, [](Hash* hash, const FunctionCallbackInfo<Value>& args,
                        const char* data, size_t size) {
    Environment* env = Environment::GetCurrent(args);
    if (UNLIKELY(size > INT_MAX))
      return THROW_ERR_OUT_OF_RANGE(env, ""data is too long"");
    bool r = hash->HashUpdate(data, size);
    args.GetReturnValue().Set(r);
  });
}",140.0,149.0,1.0,1.0,10.0,3,3,4,3,0,0,2,2,0,0,,0,0,2,1,1,void
1593,41560,HashDigest,1,node.crypto.Hash.HashDigest,void node.crypto.Hash.HashDigest (FunctionCallbackInfo<Value>),crypto\crypto_hash.cc,"void Hash::HashDigest(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  Hash* hash;
  ASSIGN_OR_RETURN_UNWRAP(&hash, args.Holder());

  enum encoding encoding = BUFFER;
  if (args.Length() >= 1) {
    encoding = ParseEncoding(env->isolate(), args[0], BUFFER);
  }

  unsigned int len = hash->md_len_;

  // TODO(tniessen): SHA3_squeeze does not work for zero-length outputs on all
  // platforms and will cause a segmentation fault if called. This workaround
  // causes hash.digest() to correctly return an empty buffer / string.
  // See https://github.com/openssl/openssl/issues/9431.

  if (!hash->digest_ && len > 0) {
    // Some hash algorithms such as SHA3 do not support calling
    // EVP_DigestFinal_ex more than once, however, Hash._flush
    // and Hash.digest can both be used to retrieve the digest,
    // so we need to cache it.
    // See https://github.com/nodejs/node/issues/28245.

    ByteSource::Builder digest(len);

    size...",151.0,205.0,1.0,1.0,55.0,49,12,50,17,0,0,6,8,0,0,,0,0,2,1,1,void
1594,41758,HashConfig,1,node.crypto.HashConfig.HashConfig,ANY node.crypto.HashConfig.HashConfig (HashConfig),crypto\crypto_hash.cc,"HashConfig::HashConfig(HashConfig&& other) noexcept
    : mode(other.mode),
      in(std::move(other.in)),
      digest(other.digest),
      length(other.length) {}",207.0,211.0,1.0,29.0,5.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
1595,41763,operator =,1,node.crypto.HashConfig.operator =,HashConfig node.crypto.HashConfig.operator = (HashConfig),crypto\crypto_hash.cc,"HashConfig& HashConfig::operator=(HashConfig&& other) noexcept {
  if (&other == this) return *this;
  this->~HashConfig();
  return *new (this) HashConfig(std::move(other));
}",213.0,217.0,1.0,1.0,5.0,7,6,4,3,0,0,2,2,0,0,,0,0,2,1,1,HashConfig
1596,41791,MemoryInfo,1,node.crypto.HashConfig.MemoryInfo,void node.crypto.HashConfig.MemoryInfo (MemoryTracker*),crypto\crypto_hash.cc,"void HashConfig::MemoryInfo(MemoryTracker* tracker) const {
  // If the Job is sync, then the HashConfig does not own the data.
  if (mode == kCryptoJobAsync)
    tracker->TrackFieldWithSize(""in"", in.size());
}",219.0,223.0,1.0,1.0,5.0,3,3,4,4,0,0,2,2,0,0,,0,0,2,1,1,void
1597,41810,EncodeOutput,1,node.crypto.HashTraits.EncodeOutput,"Maybe<bool> node.crypto.HashTraits.EncodeOutput (Environment*,HashConfig,ByteSource*,ANY*)",crypto\crypto_hash.cc,"Maybe<bool> HashTraits::EncodeOutput(
    Environment* env,
    const HashConfig& params,
    ByteSource* out,
    v8::Local<v8::Value>* result) {
  *result = out->ToArrayBuffer(env);
  return Just(!result->IsEmpty());
}",225.0,232.0,1.0,1.0,8.0,5,4,4,3,0,0,1,1,0,0,,0,0,8,4,4,Maybe<bool>
1598,41833,AdditionalConfig,1,node.crypto.HashTraits.AdditionalConfig,"Maybe<bool> node.crypto.HashTraits.AdditionalConfig (CryptoJobMode,FunctionCallbackInfo<Value>,unsigned int,HashConfig*)",crypto\crypto_hash.cc,"Maybe<bool> HashTraits::AdditionalConfig(
    CryptoJobMode mode,
    const FunctionCallbackInfo<Value>& args,
    unsigned int offset,
    HashConfig* params) {
  Environment* env = Environment::GetCurrent(args);

  params->mode = mode;

  CHECK(args[offset]->IsString());  // Hash algorithm
  Utf8Value digest(env->isolate(), args[offset]);
  params->digest = EVP_get_digestbyname(*digest);
  if (UNLIKELY(params->digest == nullptr)) {
    THROW_ERR_CRYPTO_INVALID_DIGEST(env, ""Invalid digest: %s"", *digest);
    return Nothing<bool>();
  }

  ArrayBufferOrViewContents<char> data(args[offset + 1]);
  if (UNLIKELY(!data.CheckSizeInt32())) {
    THROW_ERR_OUT_OF_RANGE(env, ""data is too big"");
    return Nothing<bool>();
  }
  params->in = mode == kCryptoJobAsync
      ? data.ToCopy()
      : data.ToByteSource();

  unsigned int expected = EVP_MD_size(params->digest);
  params->length = expected;
  if (UNLIKELY(args[offset + 2]->IsUint32())) {
    // length is expressed in terms of bits
  ...",234.0,276.0,1.0,1.0,43.0,44,13,39,12,0,0,6,9,0,0,,0,0,8,4,4,Maybe<bool>
1599,41995,DeriveBits,1,node.crypto.HashTraits.DeriveBits,"bool node.crypto.HashTraits.DeriveBits (Environment*,HashConfig,ByteSource*)",crypto\crypto_hash.cc,"bool HashTraits::DeriveBits(
    Environment* env,
    const HashConfig& params,
    ByteSource* out) {
  EVPMDPointer ctx(EVP_MD_CTX_new());

  if (UNLIKELY(!ctx ||
               EVP_DigestInit_ex(ctx.get(), params.digest, nullptr) <= 0 ||
               EVP_DigestUpdate(
                   ctx.get(), params.in.data<char>(), params.in.size()) <= 0)) {
    return false;
  }

  if (LIKELY(params.length > 0)) {
    unsigned int length = params.length;
    ByteSource::Builder buf(length);

    size_t expected = EVP_MD_CTX_size(ctx.get());

    int ret =
        (length == expected)
            ? EVP_DigestFinal_ex(ctx.get(), buf.data<unsigned char>(), &length)
            : EVP_DigestFinalXOF(ctx.get(), buf.data<unsigned char>(), length);

    if (UNLIKELY(ret != 1))
      return false;

    *out = std::move(buf).release();
  }

  return true;
}",278.0,309.0,1.0,1.0,32.0,31,11,25,8,0,0,4,5,0,0,,0,0,6,3,3,bool
1600,42158,HKDFConfig,1,node.crypto.HKDFConfig.HKDFConfig,ANY node.crypto.HKDFConfig.HKDFConfig (HKDFConfig),crypto\crypto_hkdf.cc,"HKDFConfig::HKDFConfig(HKDFConfig&& other) noexcept
    : mode(other.mode),
      length(other.length),
      digest(other.digest),
      key(other.key),
      salt(std::move(other.salt)),
      info(std::move(other.info)) {}",20.0,26.0,1.0,36.0,7.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
1601,42163,operator =,1,node.crypto.HKDFConfig.operator =,HKDFConfig node.crypto.HKDFConfig.operator = (HKDFConfig),crypto\crypto_hkdf.cc,"HKDFConfig& HKDFConfig::operator=(HKDFConfig&& other) noexcept {
  if (&other == this) return *this;
  this->~HKDFConfig();
  return *new (this) HKDFConfig(std::move(other));
}",28.0,32.0,1.0,1.0,5.0,7,6,4,3,0,0,2,2,0,0,,0,0,2,1,1,HKDFConfig
1602,42191,EncodeOutput,1,node.crypto.HKDFTraits.EncodeOutput,"Maybe<bool> node.crypto.HKDFTraits.EncodeOutput (Environment*,HKDFConfig,ByteSource*,ANY*)",crypto\crypto_hkdf.cc,"Maybe<bool> HKDFTraits::EncodeOutput(
    Environment* env,
    const HKDFConfig& params,
    ByteSource* out,
    v8::Local<v8::Value>* result) {
  *result = out->ToArrayBuffer(env);
  return Just(!result->IsEmpty());
}",34.0,41.0,1.0,1.0,8.0,5,4,4,3,0,0,1,1,0,0,,0,0,8,4,4,Maybe<bool>
1603,42214,AdditionalConfig,1,node.crypto.HKDFTraits.AdditionalConfig,"Maybe<bool> node.crypto.HKDFTraits.AdditionalConfig (CryptoJobMode,FunctionCallbackInfo<Value>,unsigned int,HKDFConfig*)",crypto\crypto_hkdf.cc,"Maybe<bool> HKDFTraits::AdditionalConfig(
    CryptoJobMode mode,
    const FunctionCallbackInfo<Value>& args,
    unsigned int offset,
    HKDFConfig* params) {
  Environment* env = Environment::GetCurrent(args);

  params->mode = mode;

  CHECK(args[offset]->IsString());  // Hash
  CHECK(args[offset + 1]->IsObject());  // Key
  CHECK(IsAnyByteSource(args[offset + 2]));  // Salt
  CHECK(IsAnyByteSource(args[offset + 3]));  // Info
  CHECK(args[offset + 4]->IsUint32());  // Length

  Utf8Value hash(env->isolate(), args[offset]);
  params->digest = EVP_get_digestbyname(*hash);
  if (params->digest == nullptr) {
    THROW_ERR_CRYPTO_INVALID_DIGEST(env, ""Invalid digest: %s"", *hash);
    return Nothing<bool>();
  }

  KeyObjectHandle* key;
  ASSIGN_OR_RETURN_UNWRAP(&key, args[offset + 1], Nothing<bool>());
  params->key = key->Data();

  ArrayBufferOrViewContents<char> salt(args[offset + 2]);
  ArrayBufferOrViewContents<char> info(args[offset + 3]);

  if (UNLIKELY(!salt.CheckSizeInt32(...",43.0,101.0,1.0,1.0,59.0,62,12,56,13,0,0,5,5,0,0,,0,0,8,4,4,Maybe<bool>
1604,42436,DeriveBits,1,node.crypto.HKDFTraits.DeriveBits,"bool node.crypto.HKDFTraits.DeriveBits (Environment*,HKDFConfig,ByteSource*)",crypto\crypto_hkdf.cc,"bool HKDFTraits::DeriveBits(
    Environment* env,
    const HKDFConfig& params,
    ByteSource* out) {
  EVPKeyCtxPointer ctx =
      EVPKeyCtxPointer(EVP_PKEY_CTX_new_id(EVP_PKEY_HKDF, nullptr));
  if (!ctx || !EVP_PKEY_derive_init(ctx.get()) ||
      !EVP_PKEY_CTX_set_hkdf_md(ctx.get(), params.digest) ||
      !EVP_PKEY_CTX_add1_hkdf_info(
          ctx.get(), params.info.data<unsigned char>(), params.info.size())) {
    return false;
  }

  // TODO(panva): Once support for OpenSSL 1.1.1 is dropped the whole
  // of HKDFTraits::DeriveBits can be refactored to use
  // EVP_KDF which does handle zero length key.

  std::string_view salt;
  if (params.salt.size() != 0) {
    salt = {params.salt.data<char>(), params.salt.size()};
  } else {
    static const char default_salt[EVP_MAX_MD_SIZE] = {0};
    salt = {default_salt, static_cast<unsigned>(EVP_MD_size(params.digest))};
  }

  // We do not use EVP_PKEY_HKDEF_MODE_EXTRACT_AND_EXPAND and instead implement
  // the extraction step ...",103.0,155.0,1.0,1.0,53.0,47,12,34,11,0,0,6,6,0,0,,0,0,6,3,3,bool
1605,42614,MemoryInfo,1,node.crypto.HKDFConfig.MemoryInfo,void node.crypto.HKDFConfig.MemoryInfo (MemoryTracker*),crypto\crypto_hkdf.cc,"void HKDFConfig::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackField(""key"", key);
  // If the job is sync, then the HKDFConfig does not own the data
  if (mode == kCryptoJobAsync) {
    tracker->TrackFieldWithSize(""salt"", salt.size());
    tracker->TrackFieldWithSize(""info"", info.size());
  }
}",157.0,164.0,1.0,1.0,8.0,6,3,8,6,0,0,2,2,0,0,,0,0,2,1,1,void
1606,42664,<lambda>0,1,"args, [](Hmac* hmac, const FunctionCallbackInfo<Value>& args, const char* data, size_t size) { Environment* env = Environment.GetCurrent(args); if (UNLIKELY(size > INT_MAX)) return THROW_ERR_OUT_OF_RANGE(env, ""data is too long""); bool r = hmac->HmacUpdate(data, size); args.GetReturnValue().Set(r); }.<lambda>0","ANY args, [](Hmac* hmac, const FunctionCallbackInfo<Value>& args, const char* data, size_t size) { Environment* env = Environment.GetCurrent(args); if (UNLIKELY(size > INT_MAX)) return THROW_ERR_OUT_OF_RANGE(env, ""data is too long""); bool r = hmac->HmacUpdate(data, size); args.GetReturnValue().Set(r); }.<lambda>0 (Hmac*,FunctionCallbackInfo<Value>,char*,size_t)",crypto\crypto_hmac.cc,"[](Hmac* hmac, const FunctionCallbackInfo<Value>& args,
                        const char* data, size_t size) {
    Environment* env = Environment::GetCurrent(args);
    if (UNLIKELY(size > INT_MAX))
      return THROW_ERR_OUT_OF_RANGE(env, ""data is too long"");
    bool r = hmac->HmacUpdate(data, size);
    args.GetReturnValue().Set(r);
  }",103.0,110.0,22.0,3.0,8.0,7,4,12,8,0,0,2,2,0,0,,0,0,8,4,4,ANY
1607,42739,Hmac,1,node.crypto.Hmac.Hmac,"ANY node.crypto.Hmac.Hmac (Environment*,Local<Object>)",crypto\crypto_hmac.cc,"Hmac::Hmac(Environment* env, Local<Object> wrap)
    : BaseObject(env, wrap),
      ctx_(nullptr) {
  MakeWeak();
}",31.0,35.0,1.0,1.0,5.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,ANY
1608,42746,MemoryInfo,1,node.crypto.Hmac.MemoryInfo,void node.crypto.Hmac.MemoryInfo (MemoryTracker*),crypto\crypto_hmac.cc,"void Hmac::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackFieldWithSize(""context"", ctx_ ? kSizeOf_HMAC_CTX : 0);
}",37.0,39.0,1.0,1.0,3.0,2,2,3,3,0,0,1,1,0,0,,0,0,2,1,1,void
1609,42760,Initialize,1,node.crypto.Hmac.Initialize,"void node.crypto.Hmac.Initialize (Environment*,Local<Object>)",crypto\crypto_hmac.cc,"void Hmac::Initialize(Environment* env, Local<Object> target) {
  Isolate* isolate = env->isolate();
  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, New);

  t->InstanceTemplate()->SetInternalFieldCount(Hmac::kInternalFieldCount);

  SetProtoMethod(isolate, t, ""init"", HmacInit);
  SetProtoMethod(isolate, t, ""update"", HmacUpdate);
  SetProtoMethod(isolate, t, ""digest"", HmacDigest);

  SetConstructorFunction(env->context(), target, ""Hmac"", t);

  HmacJob::Initialize(env, target);
}",41.0,54.0,1.0,1.0,14.0,10,5,24,12,0,0,1,1,0,0,,0,0,4,2,2,void
1610,42821,RegisterExternalReferences,1,node.crypto.Hmac.RegisterExternalReferences,void node.crypto.Hmac.RegisterExternalReferences (ExternalReferenceRegistry*),crypto\crypto_hmac.cc,"void Hmac::RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  registry->Register(New);
  registry->Register(HmacInit);
  registry->Register(HmacUpdate);
  registry->Register(HmacDigest);
  HmacJob::RegisterExternalReferences(registry);
}",56.0,62.0,1.0,1.0,7.0,5,2,10,6,0,0,1,1,0,0,,0,0,2,1,1,void
1611,42851,New,1,node.crypto.Hmac.New,void node.crypto.Hmac.New (FunctionCallbackInfo<Value>),crypto\crypto_hmac.cc,"void Hmac::New(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  new Hmac(env, args.This());
}",64.0,67.0,1.0,1.0,4.0,4,3,6,4,0,0,1,1,0,0,,0,0,2,1,1,void
1612,42871,HmacInit,1,node.crypto.Hmac.HmacInit,"void node.crypto.Hmac.HmacInit (char*,char*,int)",crypto\crypto_hmac.cc,"void Hmac::HmacInit(const FunctionCallbackInfo<Value>& args) {
  Hmac* hmac;
  ASSIGN_OR_RETURN_UNWRAP(&hmac, args.Holder());
  Environment* env = hmac->env();

  const node::Utf8Value hash_type(env->isolate(), args[0]);
  ByteSource key = ByteSource::FromSecretKeyBytes(env, args[1]);
  hmac->HmacInit(*hash_type, key.data<char>(), key.size());
}",86.0,94.0,1.0,1.0,9.0,11,6,13,5,0,0,4,4,0,0,,0,0,2,1,1,void
1613,42989,HmacUpdate,1,node.crypto.Hmac.HmacUpdate,"bool node.crypto.Hmac.HmacUpdate (char*,size_t)",crypto\crypto_hmac.cc,"void Hmac::HmacUpdate(const FunctionCallbackInfo<Value>& args) {
  Decode<Hmac>(args, [](Hmac* hmac, const FunctionCallbackInfo<Value>& args,
                        const char* data, size_t size) {
    Environment* env = Environment::GetCurrent(args);
    if (UNLIKELY(size > INT_MAX))
      return THROW_ERR_OUT_OF_RANGE(env, ""data is too long"");
    bool r = hmac->HmacUpdate(data, size);
    args.GetReturnValue().Set(r);
  });
}",102.0,111.0,1.0,1.0,10.0,4,4,4,3,0,0,1,1,0,0,,0,0,2,1,1,void
1614,43021,HmacDigest,1,node.crypto.Hmac.HmacDigest,void node.crypto.Hmac.HmacDigest (FunctionCallbackInfo<Value>),crypto\crypto_hmac.cc,"void Hmac::HmacDigest(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  Hmac* hmac;
  ASSIGN_OR_RETURN_UNWRAP(&hmac, args.Holder());

  enum encoding encoding = BUFFER;
  if (args.Length() >= 1) {
    encoding = ParseEncoding(env->isolate(), args[0], BUFFER);
  }

  unsigned char md_value[EVP_MAX_MD_SIZE];
  unsigned int md_len = 0;

  if (hmac->ctx_) {
    bool ok = HMAC_Final(hmac->ctx_.get(), md_value, &md_len);
    hmac->ctx_.reset();
    if (!ok) {
      return ThrowCryptoError(env, ERR_get_error(), ""Failed to finalize HMAC"");
    }
  }

  Local<Value> error;
  MaybeLocal<Value> rc =
      StringBytes::Encode(env->isolate(),
                          reinterpret_cast<const char*>(md_value),
                          md_len,
                          encoding,
                          &error);
  if (rc.IsEmpty()) {
    CHECK(!error.IsEmpty());
    env->isolate()->ThrowException(error);
    return;
  }
  args.GetReturnValue().Set(r...",113.0,148.0,1.0,1.0,36.0,36,10,39,15,0,0,5,6,0,0,,0,0,2,1,1,void
1615,43162,HmacConfig,1,node.crypto.HmacConfig.HmacConfig,ANY node.crypto.HmacConfig.HmacConfig (HmacConfig),crypto\crypto_hmac.cc,"HmacConfig::HmacConfig(HmacConfig&& other) noexcept
    : job_mode(other.job_mode),
      mode(other.mode),
      key(std::move(other.key)),
      data(std::move(other.data)),
      signature(std::move(other.signature)),
      digest(other.digest) {}",150.0,156.0,1.0,29.0,7.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
1616,43167,operator =,1,node.crypto.HmacConfig.operator =,HmacConfig node.crypto.HmacConfig.operator = (HmacConfig),crypto\crypto_hmac.cc,"HmacConfig& HmacConfig::operator=(HmacConfig&& other) noexcept {
  if (&other == this) return *this;
  this->~HmacConfig();
  return *new (this) HmacConfig(std::move(other));
}",158.0,162.0,1.0,1.0,5.0,7,6,4,3,0,0,2,2,0,0,,0,0,2,1,1,HmacConfig
1617,43195,MemoryInfo,1,node.crypto.HmacConfig.MemoryInfo,void node.crypto.HmacConfig.MemoryInfo (MemoryTracker*),crypto\crypto_hmac.cc,"void HmacConfig::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackField(""key"", key.get());
  // If the job is sync, then the HmacConfig does not own the data
  if (job_mode == kCryptoJobAsync) {
    tracker->TrackFieldWithSize(""data"", data.size());
    tracker->TrackFieldWithSize(""signature"", signature.size());
  }
}",164.0,171.0,1.0,1.0,8.0,7,3,8,6,0,0,2,2,0,0,,0,0,2,1,1,void
1618,43232,AdditionalConfig,1,node.crypto.HmacTraits.AdditionalConfig,"Maybe<bool> node.crypto.HmacTraits.AdditionalConfig (CryptoJobMode,FunctionCallbackInfo<Value>,unsigned int,HmacConfig*)",crypto\crypto_hmac.cc,"Maybe<bool> HmacTraits::AdditionalConfig(
    CryptoJobMode mode,
    const FunctionCallbackInfo<Value>& args,
    unsigned int offset,
    HmacConfig* params) {
  Environment* env = Environment::GetCurrent(args);

  params->job_mode = mode;

  CHECK(args[offset]->IsUint32());  // SignConfiguration::Mode
  params->mode =
    static_cast<SignConfiguration::Mode>(args[offset].As<Uint32>()->Value());

  CHECK(args[offset + 1]->IsString());  // Hash
  CHECK(args[offset + 2]->IsObject());  // Key

  Utf8Value digest(env->isolate(), args[offset + 1]);
  params->digest = EVP_get_digestbyname(*digest);
  if (params->digest == nullptr) {
    THROW_ERR_CRYPTO_INVALID_DIGEST(env, ""Invalid digest: %s"", *digest);
    return Nothing<bool>();
  }

  KeyObjectHandle* key;
  ASSIGN_OR_RETURN_UNWRAP(&key, args[offset + 2], Nothing<bool>());
  params->key = key->Data();

  ArrayBufferOrViewContents<char> data(args[offset + 3]);
  if (UNLIKELY(!data.CheckSizeInt32())) {
    THROW_ERR_OUT_OF_RANGE(env, ...",173.0,221.0,1.0,1.0,49.0,57,11,47,11,0,0,5,6,0,0,,0,0,8,4,4,Maybe<bool>
1619,43429,DeriveBits,1,node.crypto.HmacTraits.DeriveBits,"bool node.crypto.HmacTraits.DeriveBits (Environment*,HmacConfig,ByteSource*)",crypto\crypto_hmac.cc,"bool HmacTraits::DeriveBits(
    Environment* env,
    const HmacConfig& params,
    ByteSource* out) {
  HMACCtxPointer ctx(HMAC_CTX_new());

  if (!ctx ||
      !HMAC_Init_ex(
          ctx.get(),
          params.key->GetSymmetricKey(),
          params.key->GetSymmetricKeySize(),
          params.digest,
          nullptr)) {
    return false;
  }

  if (!HMAC_Update(
          ctx.get(),
          params.data.data<unsigned char>(),
          params.data.size())) {
    return false;
  }

  ByteSource::Builder buf(EVP_MAX_MD_SIZE);
  unsigned int len;

  if (!HMAC_Final(ctx.get(), buf.data<unsigned char>(), &len)) {
    return false;
  }

  *out = std::move(buf).release(len);

  return true;
}",223.0,256.0,1.0,1.0,34.0,23,7,16,7,0,0,4,4,0,0,,0,0,6,3,3,bool
1620,43524,EncodeOutput,1,node.crypto.HmacTraits.EncodeOutput,"Maybe<bool> node.crypto.HmacTraits.EncodeOutput (Environment*,HmacConfig,ByteSource*,Local<Value>*)",crypto\crypto_hmac.cc,"Maybe<bool> HmacTraits::EncodeOutput(
    Environment* env,
    const HmacConfig& params,
    ByteSource* out,
    Local<Value>* result) {
  switch (params.mode) {
    case SignConfiguration::kSign:
      *result = out->ToArrayBuffer(env);
      break;
    case SignConfiguration::kVerify:
      *result = Boolean::New(
          env->isolate(),
          out->size() > 0 && out->size() == params.signature.size() &&
              memcmp(out->data(), params.signature.data(), out->size()) == 0);
      break;
    default:
      UNREACHABLE();
  }
  return Just(!result->IsEmpty());
}",258.0,277.0,1.0,1.0,20.0,25,8,16,6,0,0,4,2,0,0,,0,0,8,4,4,Maybe<bool>
1621,43655,AdditionalConfig,1,node.crypto.NidKeyPairGenTraits.AdditionalConfig,"Maybe<bool> node.crypto.NidKeyPairGenTraits.AdditionalConfig (CryptoJobMode,FunctionCallbackInfo<Value>,unsigned int*,NidKeyPairGenConfig*)",crypto\crypto_keygen.cc,"Maybe<bool> NidKeyPairGenTraits::AdditionalConfig(
    CryptoJobMode mode,
    const FunctionCallbackInfo<Value>& args,
    unsigned int* offset,
    NidKeyPairGenConfig* params) {
  CHECK(args[*offset]->IsInt32());
  params->params.id = args[*offset].As<Int32>()->Value();

  *offset += 1;

  return Just(true);
}",33.0,44.0,1.0,1.0,12.0,12,6,6,3,0,0,1,1,0,0,,0,0,8,4,4,Maybe<bool>
1622,43694,Setup,1,node.crypto.NidKeyPairGenTraits.Setup,EVPKeyCtxPointer node.crypto.NidKeyPairGenTraits.Setup (NidKeyPairGenConfig*),crypto\crypto_keygen.cc,"EVPKeyCtxPointer NidKeyPairGenTraits::Setup(NidKeyPairGenConfig* params) {
  EVPKeyCtxPointer ctx =
      EVPKeyCtxPointer(EVP_PKEY_CTX_new_id(params->params.id, nullptr));
  if (!ctx || EVP_PKEY_keygen_init(ctx.get()) <= 0)
    return EVPKeyCtxPointer();

  return ctx;
}",46.0,53.0,1.0,1.0,8.0,7,6,5,2,0,0,2,2,0,0,,0,0,2,1,1,EVPKeyCtxPointer
1623,43726,MemoryInfo,1,node.crypto.SecretKeyGenConfig.MemoryInfo,void node.crypto.SecretKeyGenConfig.MemoryInfo (MemoryTracker*),crypto\crypto_keygen.cc,"void SecretKeyGenConfig::MemoryInfo(MemoryTracker* tracker) const {
  if (out) tracker->TrackFieldWithSize(""out"", length);
}",55.0,57.0,1.0,1.0,3.0,1,1,3,3,0,0,2,2,0,0,,0,0,2,1,1,void
1624,43740,AdditionalConfig,1,node.crypto.SecretKeyGenTraits.AdditionalConfig,"Maybe<bool> node.crypto.SecretKeyGenTraits.AdditionalConfig (CryptoJobMode,FunctionCallbackInfo<Value>,unsigned int*,SecretKeyGenConfig*)",crypto\crypto_keygen.cc,"Maybe<bool> SecretKeyGenTraits::AdditionalConfig(
    CryptoJobMode mode,
    const FunctionCallbackInfo<Value>& args,
    unsigned int* offset,
    SecretKeyGenConfig* params) {
  CHECK(args[*offset]->IsUint32());
  uint32_t bits = args[*offset].As<Uint32>()->Value();
  static_assert(std::numeric_limits<decltype(bits)>::max() / CHAR_BIT <=
                INT_MAX);
  params->length = bits / CHAR_BIT;
  *offset += 1;
  return Just(true);
}",59.0,71.0,1.0,1.0,13.0,17,8,13,8,0,0,1,1,0,0,,0,0,8,4,4,Maybe<bool>
1625,43794,DoKeyGen,1,node.crypto.SecretKeyGenTraits.DoKeyGen,"KeyGenJobStatus node.crypto.SecretKeyGenTraits.DoKeyGen (Environment*,SecretKeyGenConfig*)",crypto\crypto_keygen.cc,"KeyGenJobStatus SecretKeyGenTraits::DoKeyGen(
    Environment* env,
    SecretKeyGenConfig* params) {
  CHECK_LE(params->length, INT_MAX);
  ByteSource::Builder bytes(params->length);
  if (CSPRNG(bytes.data<unsigned char>(), params->length).is_err())
    return KeyGenJobStatus::FAILED;
  params->out = std::move(bytes).release();
  return KeyGenJobStatus::OK;
}",73.0,82.0,1.0,1.0,10.0,11,3,10,5,0,0,2,2,0,0,,0,0,4,2,2,KeyGenJobStatus
1626,43843,EncodeKey,1,node.crypto.SecretKeyGenTraits.EncodeKey,"Maybe<bool> node.crypto.SecretKeyGenTraits.EncodeKey (Environment*,SecretKeyGenConfig*,Local<Value>*)",crypto\crypto_keygen.cc,"Maybe<bool> SecretKeyGenTraits::EncodeKey(Environment* env,
                                          SecretKeyGenConfig* params,
                                          Local<Value>* result) {
  std::shared_ptr<KeyObjectData> data =
      KeyObjectData::CreateSecret(std::move(params->out));
  return Just(KeyObjectHandle::Create(env, data).ToLocal(result));
}",84.0,90.0,1.0,1.0,7.0,9,5,10,7,0,0,1,1,0,0,,0,0,6,3,3,Maybe<bool>
1627,43882,Initialize,1,node.crypto.Keygen.Initialize,"void node.crypto.Keygen.Initialize (Environment*,Local<Object>)",crypto\crypto_keygen.cc,"void Initialize(Environment* env, Local<Object> target) {
  NidKeyPairGenJob::Initialize(env, target);
  SecretKeyGenJob::Initialize(env, target);
}",93.0,96.0,1.0,1.0,4.0,2,1,6,4,0,0,1,1,0,0,,0,0,4,2,2,void
1628,43900,RegisterExternalReferences,1,node.crypto.Keygen.RegisterExternalReferences,void node.crypto.Keygen.RegisterExternalReferences (ExternalReferenceRegistry*),crypto\crypto_keygen.cc,"void RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  NidKeyPairGenJob::RegisterExternalReferences(registry);
  SecretKeyGenJob::RegisterExternalReferences(registry);
}",98.0,101.0,1.0,1.0,4.0,2,1,4,3,0,0,1,1,0,0,,0,0,2,1,1,void
1629,43935,<lambda>0,1,node.crypto.anonymous_namespace_4.ParsePublicKeyPEM.<lambda>0,"ANY node.crypto.anonymous_namespace_4.ParsePublicKeyPEM.<lambda>0 (unsigned char**,long)",crypto\crypto_keys.cc,"[](const unsigned char** p, long l) {  // NOLINT(runtime/int)
        return d2i_PUBKEY(nullptr, p, l);
      }",115.0,117.0,7.0,7.0,3.0,0,0,2,2,0,0,1,1,0,0,,0,0,4,2,2,ANY
1630,43948,<lambda>1,1,node.crypto.anonymous_namespace_5.ParsePublicKeyPEM.<lambda>1,"ANY node.crypto.anonymous_namespace_5.ParsePublicKeyPEM.<lambda>1 (unsigned char**,long)",crypto\crypto_keys.cc,"[](const unsigned char** p, long l) {  // NOLINT(runtime/int)
        return d2i_PublicKey(EVP_PKEY_RSA, nullptr, p, l);
      }",124.0,126.0,7.0,7.0,3.0,0,0,3,3,0,0,1,1,0,0,,0,0,4,2,2,ANY
1631,43961,<lambda>2,1,node.crypto.anonymous_namespace_6.ParsePublicKeyPEM.<lambda>2,"ANY node.crypto.anonymous_namespace_6.ParsePublicKeyPEM.<lambda>2 (unsigned char**,long)",crypto\crypto_keys.cc,"[](const unsigned char** p, long l) {  // NOLINT(runtime/int)
        X509Pointer x509(d2i_X509(nullptr, p, l));
        return x509 ? X509_get_pubkey(x509.get()) : nullptr;
      }",133.0,136.0,7.0,7.0,4.0,2,2,4,3,0,0,1,1,0,0,,0,0,4,2,2,ANY
1632,44023,GetKeyFormatAndTypeFromJs,1,node.crypto.anonymous_namespace_1.GetKeyFormatAndTypeFromJs,"void node.crypto.anonymous_namespace_1.GetKeyFormatAndTypeFromJs (AsymmetricKeyEncodingConfig*,FunctionCallbackInfo<Value>,unsigned int*,KeyEncodingContext)",crypto\crypto_keys.cc,"void GetKeyFormatAndTypeFromJs(
    AsymmetricKeyEncodingConfig* config,
    const FunctionCallbackInfo<Value>& args,
    unsigned int* offset,
    KeyEncodingContext context) {
  // During key pair generation, it is possible not to specify a key encoding,
  // which will lead to a key object being returned.
  if (args[*offset]->IsUndefined()) {
    CHECK_EQ(context, kKeyContextGenerate);
    CHECK(args[*offset + 1]->IsUndefined());
    config->output_key_object_ = true;
  } else {
    config->output_key_object_ = false;

    CHECK(args[*offset]->IsInt32());
    config->format_ = static_cast<PKFormatType>(
        args[*offset].As<Int32>()->Value());

    if (args[*offset + 1]->IsInt32()) {
      config->type_ = Just<PKEncodingType>(static_cast<PKEncodingType>(
          args[*offset + 1].As<Int32>()->Value()));
    } else {
      CHECK(
          (context == kKeyContextInput &&
           config->format_ == kKeyFormatPEM) ||
          (context == kKeyContextGenerate &&
           c...",43.0,76.0,1.0,1.0,34.0,11,6,8,5,0,0,2,2,0,0,,0,0,8,4,4,void
1633,44163,TryParsePublicKey,1,node.crypto.anonymous_namespace_2.TryParsePublicKey,"ParseKeyResult node.crypto.anonymous_namespace_2.TryParsePublicKey (EVPKeyPointer*,BIOPointer,char*,ANY)",crypto\crypto_keys.cc,"ParseKeyResult TryParsePublicKey(
    EVPKeyPointer* pkey,
    const BIOPointer& bp,
    const char* name,
    // NOLINTNEXTLINE(runtime/int)
    const std::function<EVP_PKEY*(const unsigned char** p, long l)>& parse) {
  unsigned char* der_data;
  long der_len;  // NOLINT(runtime/int)

  // This skips surrounding data and decodes PEM to DER.
  {
    MarkPopErrorOnReturn mark_pop_error_on_return;
    if (PEM_bytes_read_bio(&der_data, &der_len, nullptr, name,
                           bp.get(), nullptr, nullptr) != 1)
      return ParseKeyResult::kParseKeyNotRecognized;
  }

  // OpenSSL might modify the pointer, so we need to make a copy before parsing.
  const unsigned char* p = der_data;
  pkey->reset(parse(&p, der_len));
  OPENSSL_clear_free(der_data, der_len);

  return *pkey ? ParseKeyResult::kParseKeyOk :
                 ParseKeyResult::kParseKeyFailed;
}",78.0,102.0,1.0,1.0,25.0,12,7,15,7,0,0,2,2,0,0,,0,0,8,4,4,ParseKeyResult
1634,44221,ParsePublicKeyPEM,1,node.crypto.anonymous_namespace_3.ParsePublicKeyPEM,"ParseKeyResult node.crypto.anonymous_namespace_3.ParsePublicKeyPEM (EVPKeyPointer*,char*,int)",crypto\crypto_keys.cc,"ParseKeyResult ParsePublicKeyPEM(EVPKeyPointer* pkey,
                                 const char* key_pem,
                                 int key_pem_len) {
  BIOPointer bp(BIO_new_mem_buf(const_cast<char*>(key_pem), key_pem_len));
  if (!bp)
    return ParseKeyResult::kParseKeyFailed;

  ParseKeyResult ret;

  // Try parsing as a SubjectPublicKeyInfo first.
  ret = TryParsePublicKey(pkey, bp, ""PUBLIC KEY"",
      [](const unsigned char** p, long l) {  // NOLINT(runtime/int)
        return d2i_PUBKEY(nullptr, p, l);
      });
  if (ret != ParseKeyResult::kParseKeyNotRecognized)
    return ret;

  // Maybe it is PKCS#1.
  CHECK(BIO_reset(bp.get()));
  ret = TryParsePublicKey(pkey, bp, ""RSA PUBLIC KEY"",
      [](const unsigned char** p, long l) {  // NOLINT(runtime/int)
        return d2i_PublicKey(EVP_PKEY_RSA, nullptr, p, l);
      });
  if (ret != ParseKeyResult::kParseKeyNotRecognized)
    return ret;

  // X.509 fallback.
  CHECK(BIO_reset(bp.get()));
  return TryParsePublicKey...",104.0,137.0,1.0,1.0,34.0,11,5,20,6,0,0,4,4,0,0,,0,0,6,3,3,ParseKeyResult
1635,44294,ParsePublicKey,1,node.crypto.anonymous_namespace_7.ParsePublicKey,"ParseKeyResult node.crypto.anonymous_namespace_7.ParsePublicKey (EVPKeyPointer*,PublicKeyEncodingConfig,char*,size_t)",crypto\crypto_keys.cc,"ParseKeyResult ParsePublicKey(EVPKeyPointer* pkey,
                              const PublicKeyEncodingConfig& config,
                              const char* key,
                              size_t key_len) {
  if (config.format_ == kKeyFormatPEM) {
    return ParsePublicKeyPEM(pkey, key, key_len);
  } else {
    CHECK_EQ(config.format_, kKeyFormatDER);

    const unsigned char* p = reinterpret_cast<const unsigned char*>(key);
    if (config.type_.ToChecked() == kKeyEncodingPKCS1) {
      pkey->reset(d2i_PublicKey(EVP_PKEY_RSA, nullptr, &p, key_len));
    } else {
      CHECK_EQ(config.type_.ToChecked(), kKeyEncodingSPKI);
      pkey->reset(d2i_PUBKEY(nullptr, &p, key_len));
    }

    return *pkey ? ParseKeyResult::kParseKeyOk :
                   ParseKeyResult::kParseKeyFailed;
  }
}",139.0,159.0,1.0,1.0,21.0,2,2,5,5,0,0,2,2,0,0,,0,0,8,4,4,ParseKeyResult
1636,44376,IsASN1Sequence,1,node.crypto.anonymous_namespace_8.IsASN1Sequence,"bool node.crypto.anonymous_namespace_8.IsASN1Sequence (unsigned char*,size_t,size_t*,size_t*)",crypto\crypto_keys.cc,"bool IsASN1Sequence(const unsigned char* data, size_t size,
                    size_t* data_offset, size_t* data_size) {
  if (size < 2 || data[0] != 0x30)
    return false;

  if (data[1] & 0x80) {
    // Long form.
    size_t n_bytes = data[1] & ~0x80;
    if (n_bytes + 2 > size || n_bytes > sizeof(size_t))
      return false;
    size_t length = 0;
    for (size_t i = 0; i < n_bytes; i++)
      length = (length << 8) | data[i + 2];
    *data_offset = 2 + n_bytes;
    *data_size = std::min(size - 2 - n_bytes, length);
  } else {
    // Short form.
    *data_offset = 2;
    *data_size = std::min<size_t>(size - 2, data[1]);
  }

  return true;
}",161.0,183.0,1.0,1.0,23.0,26,13,20,9,0,0,5,7,0,0,,0,0,8,4,4,bool
1637,44497,IsRSAPrivateKey,1,node.crypto.anonymous_namespace_9.IsRSAPrivateKey,"bool node.crypto.anonymous_namespace_9.IsRSAPrivateKey (unsigned char*,size_t)",crypto\crypto_keys.cc,"bool IsRSAPrivateKey(const unsigned char* data, size_t size) {
  // Both RSAPrivateKey and RSAPublicKey structures start with a SEQUENCE.
  size_t offset, len;
  if (!IsASN1Sequence(data, size, &offset, &len))
    return false;

  // An RSAPrivateKey sequence always starts with a single-byte integer whose
  // value is either 0 or 1, whereas an RSAPublicKey starts with the modulus
  // (which is the product of two primes and therefore at least 4), so we can
  // decide the type of the structure based on the first three bytes of the
  // sequence.
  return len >= 3 &&
         data[offset] == 2 &&
         data[offset + 1] == 1 &&
         !(data[offset + 2] & 0xfe);
}",185.0,200.0,1.0,1.0,16.0,16,8,11,4,0,0,2,2,0,0,,0,0,4,2,2,bool
1638,44544,IsEncryptedPrivateKeyInfo,1,node.crypto.anonymous_namespace_11.IsEncryptedPrivateKeyInfo,"bool node.crypto.anonymous_namespace_11.IsEncryptedPrivateKeyInfo (unsigned char*,size_t)",crypto\crypto_keys.cc,"bool IsEncryptedPrivateKeyInfo(const unsigned char* data, size_t size) {
  // Both PrivateKeyInfo and EncryptedPrivateKeyInfo start with a SEQUENCE.
  size_t offset, len;
  if (!IsASN1Sequence(data, size, &offset, &len))
    return false;

  // A PrivateKeyInfo sequence always starts with an integer whereas an
  // EncryptedPrivateKeyInfo starts with an AlgorithmIdentifier.
  return len >= 1 &&
         data[offset] != 2;
}",202.0,212.0,1.0,1.0,11.0,7,6,7,4,0,0,2,2,0,0,,0,0,4,2,2,bool
1639,44574,ParsePrivateKey,1,node.crypto.anonymous_namespace_13.ParsePrivateKey,"ParseKeyResult node.crypto.anonymous_namespace_13.ParsePrivateKey (EVPKeyPointer*,PrivateKeyEncodingConfig,char*,size_t)",crypto\crypto_keys.cc,"ParseKeyResult ParsePrivateKey(EVPKeyPointer* pkey,
                               const PrivateKeyEncodingConfig& config,
                               const char* key,
                               size_t key_len) {
  const ByteSource* passphrase = config.passphrase_.get();

  if (config.format_ == kKeyFormatPEM) {
    BIOPointer bio(BIO_new_mem_buf(key, key_len));
    if (!bio)
      return ParseKeyResult::kParseKeyFailed;

    pkey->reset(PEM_read_bio_PrivateKey(bio.get(),
                                        nullptr,
                                        PasswordCallback,
                                        &passphrase));
  } else {
    CHECK_EQ(config.format_, kKeyFormatDER);

    if (config.type_.ToChecked() == kKeyEncodingPKCS1) {
      const unsigned char* p = reinterpret_cast<const unsigned char*>(key);
      pkey->reset(d2i_PrivateKey(EVP_PKEY_RSA, nullptr, &p, key_len));
    } else if (config.type_.ToChecked() == kKeyEncodingPKCS8) {
      BIOPointer bio(BIO_n...",214.0,271.0,1.0,1.0,58.0,22,9,24,12,0,0,7,9,0,0,,0,0,8,4,4,ParseKeyResult
1640,44798,BIOToStringOrBuffer,1,node.crypto.anonymous_namespace_15.BIOToStringOrBuffer,"MaybeLocal<Value> node.crypto.anonymous_namespace_15.BIOToStringOrBuffer (Environment*,BIO*,PKFormatType)",crypto\crypto_keys.cc,"MaybeLocal<Value> BIOToStringOrBuffer(
    Environment* env,
    BIO* bio,
    PKFormatType format) {
  BUF_MEM* bptr;
  BIO_get_mem_ptr(bio, &bptr);
  if (format == kKeyFormatPEM) {
    // PEM is an ASCII format, so we will return it as a string.
    return String::NewFromUtf8(env->isolate(), bptr->data,
                               NewStringType::kNormal,
                               bptr->length).FromMaybe(Local<Value>());
  } else {
    CHECK_EQ(format, kKeyFormatDER);
    // DER is binary, return it as a buffer.
    return Buffer::Copy(env, bptr->data, bptr->length)
        .FromMaybe(Local<Value>());
  }
}",273.0,290.0,1.0,1.0,18.0,8,4,9,7,0,0,2,2,0,0,,0,0,6,3,3,MaybeLocal<Value>
1641,44858,WritePrivateKey,1,node.crypto.anonymous_namespace_16.WritePrivateKey,"MaybeLocal<Value> node.crypto.anonymous_namespace_16.WritePrivateKey (Environment*,EVP_PKEY*,PrivateKeyEncodingConfig)",crypto\crypto_keys.cc,"MaybeLocal<Value> WritePrivateKey(
    Environment* env,
    EVP_PKEY* pkey,
    const PrivateKeyEncodingConfig& config) {
  BIOPointer bio(BIO_new(BIO_s_mem()));
  CHECK(bio);

  // If an empty string was passed as the passphrase, the ByteSource might
  // contain a null pointer, which OpenSSL will ignore, causing it to invoke its
  // default passphrase callback, which would block the thread until the user
  // manually enters a passphrase. We could supply our own passphrase callback
  // to handle this special case, but it is easier to avoid passing a null
  // pointer to OpenSSL.
  char* pass = nullptr;
  size_t pass_len = 0;
  if (!config.passphrase_.IsEmpty()) {
    pass = const_cast<char*>(config.passphrase_->data<char>());
    pass_len = config.passphrase_->size();
    if (pass == nullptr) {
      // OpenSSL will not actually dereference this pointer, so it can be any
      // non-null pointer. We cannot assert that directly, which is why we
      // intentionally use a poin...",293.0,392.0,1.0,1.0,100.0,30,8,32,12,0,0,6,8,0,0,,0,0,6,3,3,MaybeLocal<Value>
1642,44863,bio,1,node.crypto.anonymous_namespace_17.WritePrivateKey.bio,BIOPointer node.crypto.anonymous_namespace_17.WritePrivateKey.bio (BIO_new),crypto\crypto_keys.cc,BIOPointer bio(BIO_new(BIO_s_mem()));,297.0,297.0,14.0,38.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,BIOPointer
1643,45141,WritePublicKeyInner,1,node.crypto.anonymous_namespace_18.WritePublicKeyInner,"bool node.crypto.anonymous_namespace_18.WritePublicKeyInner (EVP_PKEY*,BIOPointer,PublicKeyEncodingConfig)",crypto\crypto_keys.cc,"bool WritePublicKeyInner(EVP_PKEY* pkey,
                         const BIOPointer& bio,
                         const PublicKeyEncodingConfig& config) {
  if (config.type_.ToChecked() == kKeyEncodingPKCS1) {
    // PKCS#1 is only valid for RSA keys.
    CHECK_EQ(EVP_PKEY_id(pkey), EVP_PKEY_RSA);
    RSAPointer rsa(EVP_PKEY_get1_RSA(pkey));
    if (config.format_ == kKeyFormatPEM) {
      // Encode PKCS#1 as PEM.
      return PEM_write_bio_RSAPublicKey(bio.get(), rsa.get()) == 1;
    } else {
      // Encode PKCS#1 as DER.
      CHECK_EQ(config.format_, kKeyFormatDER);
      return i2d_RSAPublicKey_bio(bio.get(), rsa.get()) == 1;
    }
  } else {
    CHECK_EQ(config.type_.ToChecked(), kKeyEncodingSPKI);
    if (config.format_ == kKeyFormatPEM) {
      // Encode SPKI as PEM.
      return PEM_write_bio_PUBKEY(bio.get(), pkey) == 1;
    } else {
      // Encode SPKI as DER.
      CHECK_EQ(config.format_, kKeyFormatDER);
      return i2d_PUBKEY_bio(bio.get(), pkey) == 1;
    }
  }
}",394.0,420.0,1.0,1.0,27.0,8,2,9,7,0,0,3,4,0,0,,0,0,6,3,3,bool
1644,45246,WritePublicKey,1,node.crypto.anonymous_namespace_19.WritePublicKey,"MaybeLocal<Value> node.crypto.anonymous_namespace_19.WritePublicKey (Environment*,EVP_PKEY*,PublicKeyEncodingConfig)",crypto\crypto_keys.cc,"MaybeLocal<Value> WritePublicKey(Environment* env,
                                 EVP_PKEY* pkey,
                                 const PublicKeyEncodingConfig& config) {
  BIOPointer bio(BIO_new(BIO_s_mem()));
  CHECK(bio);

  if (!WritePublicKeyInner(pkey, bio, config)) {
    ThrowCryptoError(env, ERR_get_error(), ""Failed to encode public key"");
    return MaybeLocal<Value>();
  }
  return BIOToStringOrBuffer(env, bio.get(), config.format_);
}",422.0,433.0,1.0,1.0,12.0,3,2,8,4,0,0,2,2,0,0,,0,0,6,3,3,MaybeLocal<Value>
1645,45251,bio,1,node.crypto.anonymous_namespace_20.WritePublicKey.bio,BIOPointer node.crypto.anonymous_namespace_20.WritePublicKey.bio (BIO_new),crypto\crypto_keys.cc,BIOPointer bio(BIO_new(BIO_s_mem()));,425.0,425.0,14.0,38.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,BIOPointer
1646,45283,ExportJWKSecretKey,1,node.crypto.anonymous_namespace_21.ExportJWKSecretKey,"Maybe<bool> node.crypto.anonymous_namespace_21.ExportJWKSecretKey (Environment*,ANY,Local<Object>)",crypto\crypto_keys.cc,"Maybe<bool> ExportJWKSecretKey(
    Environment* env,
    std::shared_ptr<KeyObjectData> key,
    Local<Object> target) {
  CHECK_EQ(key->GetKeyType(), kKeyTypeSecret);

  Local<Value> error;
  Local<Value> raw;
  MaybeLocal<Value> key_data =
      StringBytes::Encode(
          env->isolate(),
          key->GetSymmetricKey(),
          key->GetSymmetricKeySize(),
          BASE64URL,
          &error);
  if (key_data.IsEmpty()) {
    CHECK(!error.IsEmpty());
    env->isolate()->ThrowException(error);
    return Nothing<bool>();
  }
  if (!key_data.ToLocal(&raw))
    return Nothing<bool>();

  if (target->Set(
          env->context(),
          env->jwk_kty_string(),
          env->jwk_oct_string()).IsNothing() ||
      target->Set(
          env->context(),
          env->jwk_k_string(),
          raw).IsNothing()) {
    return Nothing<bool>();
  }

  return Just(true);
}",435.0,470.0,1.0,1.0,36.0,31,8,31,12,0,0,4,4,0,0,,0,0,6,3,3,Maybe<bool>
1647,45407,ImportJWKSecretKey,1,node.crypto.anonymous_namespace_22.ImportJWKSecretKey,"shared_ptr<KeyObjectData> node.crypto.anonymous_namespace_22.ImportJWKSecretKey (Environment*,Local<Object>)",crypto\crypto_keys.cc,"std::shared_ptr<KeyObjectData> ImportJWKSecretKey(
    Environment* env,
    Local<Object> jwk) {
  Local<Value> key;
  if (!jwk->Get(env->context(), env->jwk_k_string()).ToLocal(&key) ||
      !key->IsString()) {
    THROW_ERR_CRYPTO_INVALID_JWK(env, ""Invalid JWK secret key format"");
    return std::shared_ptr<KeyObjectData>();
  }

  static_assert(String::kMaxLength <= INT_MAX);
  ByteSource key_data = ByteSource::FromEncodedString(env, key.As<String>());
  return KeyObjectData::CreateSecret(std::move(key_data));
}",472.0,485.0,1.0,1.0,14.0,19,9,19,11,0,0,2,2,0,0,,0,0,4,2,2,shared_ptr<KeyObjectData>
1648,45480,ExportJWKAsymmetricKey,1,node.crypto.anonymous_namespace_23.ExportJWKAsymmetricKey,"Maybe<bool> node.crypto.anonymous_namespace_23.ExportJWKAsymmetricKey (Environment*,ANY,Local<Object>,bool)",crypto\crypto_keys.cc,"Maybe<bool> ExportJWKAsymmetricKey(
    Environment* env,
    std::shared_ptr<KeyObjectData> key,
    Local<Object> target,
    bool handleRsaPss) {
  switch (EVP_PKEY_id(key->GetAsymmetricKey().get())) {
    case EVP_PKEY_RSA_PSS: {
      if (handleRsaPss) return ExportJWKRsaKey(env, key, target);
      break;
    }
    case EVP_PKEY_RSA: return ExportJWKRsaKey(env, key, target);
    case EVP_PKEY_EC: return ExportJWKEcKey(env, key, target).IsJust() ?
                               Just(true) : Nothing<bool>();
    case EVP_PKEY_ED25519:
      // Fall through
    case EVP_PKEY_ED448:
      // Fall through
    case EVP_PKEY_X25519:
      // Fall through
    case EVP_PKEY_X448: return ExportJWKEdKey(env, key, target);
  }
  THROW_ERR_CRYPTO_JWK_UNSUPPORTED_KEY_TYPE(env);
  return Just(false);
}",487.0,510.0,1.0,1.0,24.0,4,3,22,11,0,0,4,4,0,0,,0,0,8,4,4,Maybe<bool>
1649,45549,ImportJWKAsymmetricKey,1,node.crypto.anonymous_namespace_24.ImportJWKAsymmetricKey,"shared_ptr<KeyObjectData> node.crypto.anonymous_namespace_24.ImportJWKAsymmetricKey (Environment*,Local<Object>,char*,FunctionCallbackInfo<Value>,unsigned int)",crypto\crypto_keys.cc,"std::shared_ptr<KeyObjectData> ImportJWKAsymmetricKey(
    Environment* env,
    Local<Object> jwk,
    const char* kty,
    const FunctionCallbackInfo<Value>& args,
    unsigned int offset) {
  if (strcmp(kty, ""RSA"") == 0) {
    return ImportJWKRsaKey(env, jwk, args, offset);
  } else if (strcmp(kty, ""EC"") == 0) {
    return ImportJWKEcKey(env, jwk, args, offset);
  }

  THROW_ERR_CRYPTO_INVALID_JWK(env, ""%s is not a supported JWK key type"", kty);
  return std::shared_ptr<KeyObjectData>();
}",512.0,526.0,1.0,1.0,15.0,2,2,8,6,0,0,2,2,0,0,,0,0,10,5,5,shared_ptr<KeyObjectData>
1650,45595,GetSecretKeyDetail,1,node.crypto.anonymous_namespace_25.GetSecretKeyDetail,"Maybe<bool> node.crypto.anonymous_namespace_25.GetSecretKeyDetail (Environment*,ANY,Local<Object>)",crypto\crypto_keys.cc,"Maybe<bool> GetSecretKeyDetail(
    Environment* env,
    std::shared_ptr<KeyObjectData> key,
    Local<Object> target) {
  // For the secret key detail, all we care about is the length,
  // converted to bits.

  size_t length = key->GetSymmetricKeySize() * CHAR_BIT;
  return target->Set(env->context(),
                     env->length_string(),
                     Number::New(env->isolate(), static_cast<double>(length)));
}",528.0,539.0,1.0,1.0,12.0,9,5,9,6,0,0,1,1,0,0,,0,0,6,3,3,Maybe<bool>
1651,45635,GetAsymmetricKeyDetail,1,node.crypto.anonymous_namespace_26.GetAsymmetricKeyDetail,"Maybe<bool> node.crypto.anonymous_namespace_26.GetAsymmetricKeyDetail (Environment*,ANY,Local<Object>)",crypto\crypto_keys.cc,"Maybe<bool> GetAsymmetricKeyDetail(
  Environment* env,
  std::shared_ptr<KeyObjectData> key,
  Local<Object> target) {
  switch (EVP_PKEY_id(key->GetAsymmetricKey().get())) {
    case EVP_PKEY_RSA:
      // Fall through
    case EVP_PKEY_RSA_PSS: return GetRsaKeyDetail(env, key, target);
    case EVP_PKEY_DSA: return GetDsaKeyDetail(env, key, target);
    case EVP_PKEY_EC: return GetEcKeyDetail(env, key, target);
    case EVP_PKEY_DH: return GetDhKeyDetail(env, key, target);
  }
  THROW_ERR_CRYPTO_INVALID_KEYTYPE(env);
  return Nothing<bool>();
}",541.0,555.0,1.0,1.0,15.0,2,2,19,8,0,0,2,2,0,0,,0,0,6,3,3,Maybe<bool>
1652,45686,ManagedEVPPKey,1,node.crypto.ManagedEVPPKey.ManagedEVPPKey,ANY node.crypto.ManagedEVPPKey.ManagedEVPPKey (EVPKeyPointer),crypto\crypto_keys.cc,"ManagedEVPPKey::ManagedEVPPKey(const ManagedEVPPKey& that) {
  *this = that;
}",561.0,563.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
1653,45700,operator =,1,node.crypto.ManagedEVPPKey.operator =,ManagedEVPPKey node.crypto.ManagedEVPPKey.operator = (ManagedEVPPKey),crypto\crypto_keys.cc,"ManagedEVPPKey& ManagedEVPPKey::operator=(const ManagedEVPPKey& that) {
  Mutex::ScopedLock lock(*that.mutex_);

  pkey_.reset(that.get());

  if (pkey_)
    EVP_PKEY_up_ref(pkey_.get());

  mutex_ = that.mutex_;

  return *this;
}",565.0,576.0,1.0,1.0,12.0,8,3,7,3,0,0,2,2,0,0,,0,0,2,1,1,ManagedEVPPKey
1654,45735,operator bool,1,node.crypto.ManagedEVPPKey.operator bool,ANY node.crypto.ManagedEVPPKey.operator bool (),crypto\crypto_keys.cc,"ManagedEVPPKey::operator bool() const {
  return !!pkey_;
}",578.0,580.0,1.0,1.0,3.0,2,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,ANY
1655,45743,get,1,node.crypto.ManagedEVPPKey.get,EVP_PKEY node.crypto.ManagedEVPPKey.get (),crypto\crypto_keys.cc,"EVP_PKEY* ManagedEVPPKey::get() const {
  return pkey_.get();
}",582.0,584.0,1.0,1.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,EVP_PKEY
1656,45752,mutex,1,node.crypto.ManagedEVPPKey.mutex,Mutex node.crypto.ManagedEVPPKey.mutex (),crypto\crypto_keys.cc,"Mutex* ManagedEVPPKey::mutex() const {
  return mutex_.get();
}",586.0,588.0,1.0,1.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,Mutex
1657,45761,MemoryInfo,1,node.crypto.ManagedEVPPKey.MemoryInfo,void node.crypto.ManagedEVPPKey.MemoryInfo (MemoryTracker*),crypto\crypto_keys.cc,"void ManagedEVPPKey::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackFieldWithSize(""pkey"",
                              !pkey_ ? 0 : kSizeOf_EVP_PKEY +
                              size_of_private_key() +
                              size_of_public_key());
}",590.0,595.0,1.0,1.0,6.0,5,4,3,3,0,0,1,1,0,0,,0,0,2,1,1,void
1658,45780,size_of_private_key,1,node.crypto.ManagedEVPPKey.size_of_private_key,size_t node.crypto.ManagedEVPPKey.size_of_private_key (),crypto\crypto_keys.cc,"size_t ManagedEVPPKey::size_of_private_key() const {
  size_t len = 0;
  return (pkey_ && EVP_PKEY_get_raw_private_key(
      pkey_.get(), nullptr, &len) == 1) ? len : 0;
}",597.0,601.0,1.0,1.0,5.0,6,6,5,2,0,0,1,1,0,0,,0,0,0,0,0,size_t
1659,45804,size_of_public_key,1,node.crypto.ManagedEVPPKey.size_of_public_key,size_t node.crypto.ManagedEVPPKey.size_of_public_key (),crypto\crypto_keys.cc,"size_t ManagedEVPPKey::size_of_public_key() const {
  size_t len = 0;
  return (pkey_ && EVP_PKEY_get_raw_public_key(
      pkey_.get(), nullptr, &len) == 1) ? len : 0;
}",603.0,607.0,1.0,1.0,5.0,6,6,5,2,0,0,1,1,0,0,,0,0,0,0,0,size_t
1660,45828,Tristate,1,node.crypto.Tristate,Maybe<bool> node.crypto.Tristate (bool),crypto\crypto_keys.cc,"static inline Maybe<bool> Tristate(bool b) {
  return b ? Just(true) : Nothing<bool>();
}",610.0,612.0,1.0,1.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,Maybe<bool>
1661,45839,ExportJWKInner,1,node.crypto.ExportJWKInner,"Maybe<bool> node.crypto.ExportJWKInner (Environment*,ANY,Local<Value>,bool)",crypto\crypto_keys.cc,"Maybe<bool> ExportJWKInner(Environment* env,
                           std::shared_ptr<KeyObjectData> key,
                           Local<Value> result,
                           bool handleRsaPss) {
  switch (key->GetKeyType()) {
    case kKeyTypeSecret:
      return ExportJWKSecretKey(env, key, result.As<Object>());
    case kKeyTypePublic:
      // Fall through
    case kKeyTypePrivate:
      return ExportJWKAsymmetricKey(
        env, key, result.As<Object>(), handleRsaPss);
    default:
      UNREACHABLE();
  }
}",614.0,629.0,1.0,1.0,16.0,3,2,11,7,0,0,2,2,0,0,,0,0,8,4,4,Maybe<bool>
1662,45878,ToEncodedPublicKey,1,node.crypto.ManagedEVPPKey.ToEncodedPublicKey,"Maybe<bool> node.crypto.ManagedEVPPKey.ToEncodedPublicKey (Environment*,PublicKeyEncodingConfig,Local<Value>*)",crypto\crypto_keys.cc,"Maybe<bool> ManagedEVPPKey::ToEncodedPublicKey(
    Environment* env,
    const PublicKeyEncodingConfig& config,
    Local<Value>* out) {
  if (!*this) return Nothing<bool>();
  if (config.output_key_object_) {
    // Note that this has the downside of containing sensitive data of the
    // private key.
    std::shared_ptr<KeyObjectData> data =
        KeyObjectData::CreateAsymmetric(kKeyTypePublic, *this);
    return Tristate(KeyObjectHandle::Create(env, data).ToLocal(out));
  } else if (config.format_ == kKeyFormatJWK) {
    std::shared_ptr<KeyObjectData> data =
        KeyObjectData::CreateAsymmetric(kKeyTypePublic, *this);
    *out = Object::New(env->isolate());
    return ExportJWKInner(env, data, *out, false);
  }

  return Tristate(WritePublicKey(env, get(), config).ToLocal(out));
}",631.0,650.0,1.0,1.0,20.0,12,6,13,8,0,0,3,3,0,0,,0,0,6,3,3,Maybe<bool>
1663,45976,ToEncodedPrivateKey,1,node.crypto.ManagedEVPPKey.ToEncodedPrivateKey,"Maybe<bool> node.crypto.ManagedEVPPKey.ToEncodedPrivateKey (Environment*,PrivateKeyEncodingConfig,Local<Value>*)",crypto\crypto_keys.cc,"Maybe<bool> ManagedEVPPKey::ToEncodedPrivateKey(
    Environment* env,
    const PrivateKeyEncodingConfig& config,
    Local<Value>* out) {
  if (!*this) return Nothing<bool>();
  if (config.output_key_object_) {
    std::shared_ptr<KeyObjectData> data =
        KeyObjectData::CreateAsymmetric(kKeyTypePrivate, *this);
    return Tristate(KeyObjectHandle::Create(env, data).ToLocal(out));
  } else if (config.format_ == kKeyFormatJWK) {
    std::shared_ptr<KeyObjectData> data =
        KeyObjectData::CreateAsymmetric(kKeyTypePrivate, *this);
    *out = Object::New(env->isolate());
    return ExportJWKInner(env, data, *out, false);
  }

  return Tristate(WritePrivateKey(env, get(), config).ToLocal(out));
}",652.0,669.0,1.0,1.0,18.0,12,6,13,8,0,0,3,3,0,0,,0,0,6,3,3,Maybe<bool>
1664,46074,GetPrivateKeyEncodingFromJs,1,node.crypto.ManagedEVPPKey.GetPrivateKeyEncodingFromJs,"NonCopyableMaybe<PrivateKeyEncodingConfig> node.crypto.ManagedEVPPKey.GetPrivateKeyEncodingFromJs (FunctionCallbackInfo<Value>,unsigned int*,KeyEncodingContext)",crypto\crypto_keys.cc,"NonCopyableMaybe<PrivateKeyEncodingConfig>
ManagedEVPPKey::GetPrivateKeyEncodingFromJs(
    const FunctionCallbackInfo<Value>& args,
    unsigned int* offset,
    KeyEncodingContext context) {
  Environment* env = Environment::GetCurrent(args);

  PrivateKeyEncodingConfig result;
  GetKeyFormatAndTypeFromJs(&result, args, offset, context);

  if (result.output_key_object_) {
    if (context != kKeyContextInput)
      (*offset)++;
  } else {
    bool needs_passphrase = false;
    if (context != kKeyContextInput) {
      if (args[*offset]->IsString()) {
        Utf8Value cipher_name(env->isolate(), args[*offset]);
        result.cipher_ = EVP_get_cipherbyname(*cipher_name);
        if (result.cipher_ == nullptr) {
          THROW_ERR_CRYPTO_UNKNOWN_CIPHER(env);
          return NonCopyableMaybe<PrivateKeyEncodingConfig>();
        }
        needs_passphrase = true;
      } else {
        CHECK(args[*offset]->IsNullOrUndefined());
        result.cipher_ = nullptr;
      }
      (*offse...",671.0,718.0,1.0,1.0,48.0,12,8,16,10,0,0,3,4,0,0,,0,0,6,3,3,NonCopyableMaybe<PrivateKeyEncodingConfig>
1665,46251,GetPublicKeyEncodingFromJs,1,node.crypto.ManagedEVPPKey.GetPublicKeyEncodingFromJs,"PublicKeyEncodingConfig node.crypto.ManagedEVPPKey.GetPublicKeyEncodingFromJs (FunctionCallbackInfo<Value>,unsigned int*,KeyEncodingContext)",crypto\crypto_keys.cc,"PublicKeyEncodingConfig ManagedEVPPKey::GetPublicKeyEncodingFromJs(
    const FunctionCallbackInfo<Value>& args,
    unsigned int* offset,
    KeyEncodingContext context) {
  PublicKeyEncodingConfig result;
  GetKeyFormatAndTypeFromJs(&result, args, offset, context);
  return result;
}",720.0,727.0,1.0,1.0,8.0,1,1,5,4,0,0,1,1,0,0,,0,0,6,3,3,PublicKeyEncodingConfig
1666,46267,GetPrivateKeyFromJs,1,node.crypto.ManagedEVPPKey.GetPrivateKeyFromJs,"ManagedEVPPKey node.crypto.ManagedEVPPKey.GetPrivateKeyFromJs (FunctionCallbackInfo<Value>,unsigned int*,bool)",crypto\crypto_keys.cc,"ManagedEVPPKey ManagedEVPPKey::GetPrivateKeyFromJs(
    const FunctionCallbackInfo<Value>& args,
    unsigned int* offset,
    bool allow_key_object) {
  if (args[*offset]->IsString() || IsAnyByteSource(args[*offset])) {
    Environment* env = Environment::GetCurrent(args);
    ByteSource key = ByteSource::FromStringOrBuffer(env, args[(*offset)++]);
    NonCopyableMaybe<PrivateKeyEncodingConfig> config =
        GetPrivateKeyEncodingFromJs(args, offset, kKeyContextInput);
    if (config.IsEmpty())
      return ManagedEVPPKey();

    EVPKeyPointer pkey;
    ParseKeyResult ret =
        ParsePrivateKey(&pkey, config.Release(), key.data<char>(), key.size());
    return GetParsedKey(env, std::move(pkey), ret,
                        ""Failed to read private key"");
  } else {
    CHECK(args[*offset]->IsObject() && allow_key_object);
    KeyObjectHandle* key;
    ASSIGN_OR_RETURN_UNWRAP(&key, args[*offset].As<Object>(), ManagedEVPPKey());
    CHECK_EQ(key->Data()->GetKeyType(), kKeyTypePri...",729.0,754.0,1.0,1.0,26.0,23,10,28,13,0,0,3,4,0,0,,0,0,6,3,3,ManagedEVPPKey
1667,46402,GetPublicOrPrivateKeyFromJs,1,node.crypto.ManagedEVPPKey.GetPublicOrPrivateKeyFromJs,"ManagedEVPPKey node.crypto.ManagedEVPPKey.GetPublicOrPrivateKeyFromJs (FunctionCallbackInfo<Value>,unsigned int*)",crypto\crypto_keys.cc,"ManagedEVPPKey ManagedEVPPKey::GetPublicOrPrivateKeyFromJs(
    const FunctionCallbackInfo<Value>& args,
    unsigned int* offset) {
  if (IsAnyByteSource(args[*offset])) {
    Environment* env = Environment::GetCurrent(args);
    ArrayBufferOrViewContents<char> data(args[(*offset)++]);
    if (UNLIKELY(!data.CheckSizeInt32())) {
      THROW_ERR_OUT_OF_RANGE(env, ""keyData is too big"");
      return ManagedEVPPKey();
    }
    NonCopyableMaybe<PrivateKeyEncodingConfig> config_ =
        GetPrivateKeyEncodingFromJs(args, offset, kKeyContextInput);
    if (config_.IsEmpty())
      return ManagedEVPPKey();

    ParseKeyResult ret;
    PrivateKeyEncodingConfig config = config_.Release();
    EVPKeyPointer pkey;
    if (config.format_ == kKeyFormatPEM) {
      // For PEM, we can easily determine whether it is a public or private key
      // by looking for the respective PEM tags.
      ret = ParsePublicKeyPEM(&pkey, data.data(), data.size());
      if (ret == ParseKeyResult::kParseKeyNot...",756.0,818.0,1.0,1.0,63.0,29,10,36,16,0,0,6,11,0,0,,0,0,4,2,2,ManagedEVPPKey
1668,46649,GetParsedKey,1,node.crypto.ManagedEVPPKey.GetParsedKey,"ManagedEVPPKey node.crypto.ManagedEVPPKey.GetParsedKey (Environment*,EVPKeyPointer,ParseKeyResult,char*)",crypto\crypto_keys.cc,"ManagedEVPPKey ManagedEVPPKey::GetParsedKey(Environment* env,
                                            EVPKeyPointer&& pkey,
                                            ParseKeyResult ret,
                                            const char* default_msg) {
  switch (ret) {
    case ParseKeyResult::kParseKeyOk:
      CHECK(pkey);
      break;
    case ParseKeyResult::kParseKeyNeedPassphrase:
      THROW_ERR_MISSING_PASSPHRASE(env,
                                   ""Passphrase required for encrypted key"");
      break;
    default:
      ThrowCryptoError(env, ERR_get_error(), default_msg);
  }

  return ManagedEVPPKey(std::move(pkey));
}",820.0,837.0,1.0,1.0,18.0,3,1,9,6,0,0,4,2,0,0,,0,0,8,4,4,ManagedEVPPKey
1669,46687,KeyObjectData,1,node.crypto.KeyObjectData.KeyObjectData,ANY node.crypto.KeyObjectData.KeyObjectData (ByteSource),crypto\crypto_keys.cc,"KeyObjectData::KeyObjectData(KeyType type, const ManagedEVPPKey& pkey)
    : key_type_(type), symmetric_key_(), asymmetric_key_{pkey} {}",844.0,845.0,1.0,65.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,ANY
1670,46698,MemoryInfo,1,node.crypto.KeyObjectData.MemoryInfo,void node.crypto.KeyObjectData.MemoryInfo (MemoryTracker*),crypto\crypto_keys.cc,"void KeyObjectData::MemoryInfo(MemoryTracker* tracker) const {
  switch (GetKeyType()) {
    case kKeyTypeSecret:
      tracker->TrackFieldWithSize(""symmetric_key"", symmetric_key_.size());
      break;
    case kKeyTypePrivate:
      // Fall through
    case kKeyTypePublic:
      tracker->TrackFieldWithSize(""key"", asymmetric_key_);
      break;
    default:
      UNREACHABLE();
  }
}",847.0,860.0,1.0,1.0,14.0,3,2,7,6,0,0,4,2,0,0,,0,0,2,1,1,void
1671,46731,CreateSecret,1,node.crypto.KeyObjectData.CreateSecret,shared_ptr<KeyObjectData> node.crypto.KeyObjectData.CreateSecret (ByteSource),crypto\crypto_keys.cc,"std::shared_ptr<KeyObjectData> KeyObjectData::CreateSecret(ByteSource key) {
  return std::shared_ptr<KeyObjectData>(new KeyObjectData(std::move(key)));
}",862.0,864.0,1.0,1.0,3.0,5,4,5,3,0,0,1,1,0,0,,0,0,2,1,1,shared_ptr<KeyObjectData>
1672,46750,CreateAsymmetric,1,node.crypto.KeyObjectData.CreateAsymmetric,"shared_ptr<KeyObjectData> node.crypto.KeyObjectData.CreateAsymmetric (KeyType,ManagedEVPPKey)",crypto\crypto_keys.cc,"std::shared_ptr<KeyObjectData> KeyObjectData::CreateAsymmetric(
    KeyType key_type,
    const ManagedEVPPKey& pkey) {
  CHECK(pkey);
  return std::shared_ptr<KeyObjectData>(new KeyObjectData(key_type, pkey));
}",866.0,871.0,1.0,1.0,6.0,4,4,6,4,0,0,1,1,0,0,,0,0,4,2,2,shared_ptr<KeyObjectData>
1673,46769,GetKeyType,1,node.crypto.KeyObjectData.GetKeyType,KeyType node.crypto.KeyObjectData.GetKeyType (),crypto\crypto_keys.cc,"KeyType KeyObjectData::GetKeyType() const {
  return key_type_;
}",873.0,875.0,1.0,1.0,3.0,0,0,1,1,0,0,1,1,0,0,,0,0,0,0,0,KeyType
1674,46775,GetAsymmetricKey,1,node.crypto.KeyObjectData.GetAsymmetricKey,ManagedEVPPKey node.crypto.KeyObjectData.GetAsymmetricKey (),crypto\crypto_keys.cc,"ManagedEVPPKey KeyObjectData::GetAsymmetricKey() const {
  CHECK_NE(key_type_, kKeyTypeSecret);
  return asymmetric_key_;
}",877.0,880.0,1.0,1.0,4.0,0,0,3,3,0,0,1,1,0,0,,0,0,0,0,0,ManagedEVPPKey
1675,46784,GetSymmetricKey,1,node.crypto.KeyObjectData.GetSymmetricKey,const char* node.crypto.KeyObjectData.GetSymmetricKey (),crypto\crypto_keys.cc,"const char* KeyObjectData::GetSymmetricKey() const {
  CHECK_EQ(key_type_, kKeyTypeSecret);
  return symmetric_key_.data<char>();
}",882.0,885.0,1.0,1.0,4.0,1,1,3,3,0,0,1,1,0,0,,0,0,0,0,0,const char*
1676,46796,GetSymmetricKeySize,1,node.crypto.KeyObjectData.GetSymmetricKeySize,size_t node.crypto.KeyObjectData.GetSymmetricKeySize (),crypto\crypto_keys.cc,"size_t KeyObjectData::GetSymmetricKeySize() const {
  CHECK_EQ(key_type_, kKeyTypeSecret);
  return symmetric_key_.size();
}",887.0,890.0,1.0,1.0,4.0,1,1,3,3,0,0,1,1,0,0,,0,0,0,0,0,size_t
1677,46808,HasInstance,1,node.crypto.KeyObjectHandle.HasInstance,"bool node.crypto.KeyObjectHandle.HasInstance (Environment*,Local<Value>)",crypto\crypto_keys.cc,"bool KeyObjectHandle::HasInstance(Environment* env, Local<Value> value) {
  Local<FunctionTemplate> t = env->crypto_key_object_handle_constructor();
  return !t.IsEmpty() && t->HasInstance(value);
}",892.0,895.0,1.0,1.0,4.0,8,7,7,5,0,0,1,1,0,0,,0,0,4,2,2,bool
1678,46836,Initialize,1,node.crypto.KeyObjectHandle.Initialize,Local<v8::Function> node.crypto.KeyObjectHandle.Initialize (Environment*),crypto\crypto_keys.cc,"v8::Local<v8::Function> KeyObjectHandle::Initialize(Environment* env) {
  Local<FunctionTemplate> templ = env->crypto_key_object_handle_constructor();
  if (templ.IsEmpty()) {
    Isolate* isolate = env->isolate();
    templ = NewFunctionTemplate(isolate, New);
    templ->InstanceTemplate()->SetInternalFieldCount(
        KeyObjectHandle::kInternalFieldCount);

    SetProtoMethod(isolate, templ, ""init"", Init);
    SetProtoMethodNoSideEffect(
        isolate, templ, ""getSymmetricKeySize"", GetSymmetricKeySize);
    SetProtoMethodNoSideEffect(
        isolate, templ, ""getAsymmetricKeyType"", GetAsymmetricKeyType);
    SetProtoMethod(isolate, templ, ""export"", Export);
    SetProtoMethod(isolate, templ, ""exportJwk"", ExportJWK);
    SetProtoMethod(isolate, templ, ""initECRaw"", InitECRaw);
    SetProtoMethod(isolate, templ, ""initEDRaw"", InitEDRaw);
    SetProtoMethod(isolate, templ, ""initJwk"", InitJWK);
    SetProtoMethod(isolate, templ, ""keyDetail"", GetKeyDetail);
    SetProtoMethod(isolate...",897.0,921.0,1.0,1.0,25.0,15,5,46,17,0,0,2,2,0,0,,0,0,2,1,1,Local<v8.Function>
1679,46946,RegisterExternalReferences,1,node.crypto.KeyObjectHandle.RegisterExternalReferences,void node.crypto.KeyObjectHandle.RegisterExternalReferences (ExternalReferenceRegistry*),crypto\crypto_keys.cc,"void KeyObjectHandle::RegisterExternalReferences(
    ExternalReferenceRegistry* registry) {
  registry->Register(New);
  registry->Register(Init);
  registry->Register(GetSymmetricKeySize);
  registry->Register(GetAsymmetricKeyType);
  registry->Register(Export);
  registry->Register(ExportJWK);
  registry->Register(InitECRaw);
  registry->Register(InitEDRaw);
  registry->Register(InitJWK);
  registry->Register(GetKeyDetail);
  registry->Register(Equals);
}",923.0,936.0,1.0,1.0,14.0,11,1,22,12,0,0,1,1,0,0,,0,0,2,1,1,void
1680,47006,Create,1,node.crypto.KeyObjectHandle.Create,"MaybeLocal<Object> node.crypto.KeyObjectHandle.Create (Environment*,ANY)",crypto\crypto_keys.cc,"MaybeLocal<Object> KeyObjectHandle::Create(
    Environment* env,
    std::shared_ptr<KeyObjectData> data) {
  Local<Object> obj;
  Local<Function> ctor = KeyObjectHandle::Initialize(env);
  CHECK(!env->crypto_key_object_handle_constructor().IsEmpty());
  if (!ctor->NewInstance(env->context(), 0, nullptr).ToLocal(&obj))
    return MaybeLocal<Object>();

  KeyObjectHandle* key = Unwrap<KeyObjectHandle>(obj);
  CHECK_NOT_NULL(key);
  key->data_ = data;
  return obj;
}",938.0,951.0,1.0,1.0,14.0,19,7,20,10,0,0,2,2,0,0,,0,0,4,2,2,MaybeLocal<Object>
1681,47074,Data,1,node.crypto.KeyObjectHandle.Data,shared_ptr<KeyObjectData> node.crypto.KeyObjectHandle.Data (),crypto\crypto_keys.cc,"const std::shared_ptr<KeyObjectData>& KeyObjectHandle::Data() {
  return data_;
}",953.0,955.0,1.0,1.0,3.0,0,0,1,1,0,0,1,1,0,0,,0,0,0,0,0,shared_ptr<KeyObjectData>
1682,47080,New,1,node.crypto.KeyObjectHandle.New,void node.crypto.KeyObjectHandle.New (FunctionCallbackInfo<Value>),crypto\crypto_keys.cc,"void KeyObjectHandle::New(const FunctionCallbackInfo<Value>& args) {
  CHECK(args.IsConstructCall());
  Environment* env = Environment::GetCurrent(args);
  new KeyObjectHandle(env, args.This());
}",957.0,961.0,1.0,1.0,5.0,5,3,7,4,0,0,1,1,0,0,,0,0,2,1,1,void
1683,47105,KeyObjectHandle,1,node.crypto.KeyObjectHandle.KeyObjectHandle,"ANY node.crypto.KeyObjectHandle.KeyObjectHandle (Environment*,Local<Object>)",crypto\crypto_keys.cc,"KeyObjectHandle::KeyObjectHandle(Environment* env,
                                 Local<Object> wrap)
    : BaseObject(env, wrap) {
  MakeWeak();
}",963.0,967.0,1.0,1.0,5.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,ANY
1684,47112,Init,1,node.crypto.KeyObjectHandle.Init,void node.crypto.KeyObjectHandle.Init (FunctionCallbackInfo<Value>),crypto\crypto_keys.cc,"void KeyObjectHandle::Init(const FunctionCallbackInfo<Value>& args) {
  KeyObjectHandle* key;
  ASSIGN_OR_RETURN_UNWRAP(&key, args.Holder());
  MarkPopErrorOnReturn mark_pop_error_on_return;

  CHECK(args[0]->IsInt32());
  KeyType type = static_cast<KeyType>(args[0].As<Uint32>()->Value());

  unsigned int offset;
  ManagedEVPPKey pkey;

  switch (type) {
  case kKeyTypeSecret: {
    CHECK_EQ(args.Length(), 2);
    ArrayBufferOrViewContents<char> buf(args[1]);
    key->data_ = KeyObjectData::CreateSecret(buf.ToCopy());
    break;
  }
  case kKeyTypePublic: {
    CHECK_EQ(args.Length(), 5);

    offset = 1;
    pkey = ManagedEVPPKey::GetPublicOrPrivateKeyFromJs(args, &offset);
    if (!pkey)
      return;
    key->data_ = KeyObjectData::CreateAsymmetric(type, pkey);
    break;
  }
  case kKeyTypePrivate: {
    CHECK_EQ(args.Length(), 5);

    offset = 1;
    pkey = ManagedEVPPKey::GetPrivateKeyFromJs(args, &offset, false);
    if (!pkey)
      return;
    key->data_ = KeyObjectData::C...",969.0,1010.0,1.0,1.0,42.0,33,7,36,11,0,0,7,6,0,0,,0,0,2,1,1,void
1685,47256,InitJWK,1,node.crypto.KeyObjectHandle.InitJWK,void node.crypto.KeyObjectHandle.InitJWK (FunctionCallbackInfo<Value>),crypto\crypto_keys.cc,"void KeyObjectHandle::InitJWK(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  KeyObjectHandle* key;
  ASSIGN_OR_RETURN_UNWRAP(&key, args.Holder());
  MarkPopErrorOnReturn mark_pop_error_on_return;

  // The argument must be a JavaScript object that we will inspect
  // to get the JWK properties from.
  CHECK(args[0]->IsObject());

  // Step one, Secret key or not?
  Local<Object> input = args[0].As<Object>();

  Local<Value> kty;
  if (!input->Get(env->context(), env->jwk_kty_string()).ToLocal(&kty) ||
      !kty->IsString()) {
    return THROW_ERR_CRYPTO_INVALID_JWK(env);
  }

  Utf8Value kty_string(env->isolate(), kty);

  if (strcmp(*kty_string, ""oct"") == 0) {
    // Secret key
    key->data_ = ImportJWKSecretKey(env, input);
    if (!key->data_) {
      // ImportJWKSecretKey is responsible for throwing an appropriate error
      return;
    }
  } else {
    key->data_ = ImportJWKAsymmetricKey(env, input, *kty_string, args, 1);
   ...",1012.0,1049.0,1.0,1.0,38.0,33,11,28,10,0,0,4,5,0,0,,0,0,2,1,1,void
1686,47393,InitECRaw,1,node.crypto.KeyObjectHandle.InitECRaw,void node.crypto.KeyObjectHandle.InitECRaw (FunctionCallbackInfo<Value>),crypto\crypto_keys.cc,"void KeyObjectHandle::InitECRaw(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  KeyObjectHandle* key;
  ASSIGN_OR_RETURN_UNWRAP(&key, args.Holder());

  CHECK(args[0]->IsString());
  Utf8Value name(env->isolate(), args[0]);

  MarkPopErrorOnReturn mark_pop_error_on_return;

  int id = OBJ_txt2nid(*name);
  ECKeyPointer eckey(EC_KEY_new_by_curve_name(id));
  if (!eckey)
    return args.GetReturnValue().Set(false);

  const EC_GROUP* group = EC_KEY_get0_group(eckey.get());
  ECPointPointer pub(ECDH::BufferToPoint(env, group, args[1]));

  if (!pub ||
      !eckey ||
      !EC_KEY_set_public_key(eckey.get(), pub.get())) {
    return args.GetReturnValue().Set(false);
  }

  EVPKeyPointer pkey(EVP_PKEY_new());
  if (!EVP_PKEY_assign_EC_KEY(pkey.get(), eckey.get()))
    args.GetReturnValue().Set(false);

  eckey.release();  // Release ownership of the key

  key->data_ =
      KeyObjectData::CreateAsymmetric(
          kKeyTypePublic,
     ...",1051.0,1087.0,1.0,1.0,37.0,38,8,34,14,0,0,4,4,0,0,,0,0,2,1,1,void
1687,47550,InitEDRaw,1,node.crypto.KeyObjectHandle.InitEDRaw,void node.crypto.KeyObjectHandle.InitEDRaw (FunctionCallbackInfo<Value>),crypto\crypto_keys.cc,"void KeyObjectHandle::InitEDRaw(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  KeyObjectHandle* key;
  ASSIGN_OR_RETURN_UNWRAP(&key, args.Holder());

  CHECK(args[0]->IsString());
  Utf8Value name(env->isolate(), args[0]);

  ArrayBufferOrViewContents<unsigned char> key_data(args[1]);
  KeyType type = static_cast<KeyType>(args[2].As<Int32>()->Value());

  MarkPopErrorOnReturn mark_pop_error_on_return;

  typedef EVP_PKEY* (*new_key_fn)(int, ENGINE*, const unsigned char*, size_t);
  new_key_fn fn = type == kKeyTypePrivate
      ? EVP_PKEY_new_raw_private_key
      : EVP_PKEY_new_raw_public_key;

  int id = GetOKPCurveFromName(*name);

  switch (id) {
    case EVP_PKEY_X25519:
    case EVP_PKEY_X448:
    case EVP_PKEY_ED25519:
    case EVP_PKEY_ED448: {
      EVPKeyPointer pkey(fn(id, nullptr, key_data.data(), key_data.size()));
      if (!pkey)
        return args.GetReturnValue().Set(false);
      key->data_ =
          KeyObjectData...",1089.0,1129.0,1.0,1.0,41.0,31,10,35,19,0,0,4,4,0,0,,0,0,2,1,1,void
1688,47605,new_key_fn,1,node.crypto.KeyObjectHandle.InitEDRaw.new_key_fn,"EVP_PKEY* node.crypto.KeyObjectHandle.InitEDRaw.new_key_fn (int,ENGINE*,unsigned char*,size_t)",crypto\crypto_keys.cc,"typedef EVP_PKEY* (*new_key_fn)(int, ENGINE*, const unsigned char*, size_t);",1102.0,1102.0,19.0,77.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,EVP_PKEY*
1689,47698,Equals,1,node.crypto.KeyObjectHandle.Equals,void node.crypto.KeyObjectHandle.Equals (FunctionCallbackInfo<Value>),crypto\crypto_keys.cc,"void KeyObjectHandle::Equals(const FunctionCallbackInfo<Value>& args) {
  KeyObjectHandle* self_handle;
  KeyObjectHandle* arg_handle;
  ASSIGN_OR_RETURN_UNWRAP(&self_handle, args.Holder());
  ASSIGN_OR_RETURN_UNWRAP(&arg_handle, args[0].As<Object>());
  std::shared_ptr<KeyObjectData> key = self_handle->Data();
  std::shared_ptr<KeyObjectData> key2 = arg_handle->Data();

  KeyType key_type = key->GetKeyType();
  CHECK_EQ(key_type, key2->GetKeyType());

  bool ret;
  switch (key_type) {
    case kKeyTypeSecret: {
      size_t size = key->GetSymmetricKeySize();
      if (size == key2->GetSymmetricKeySize()) {
        ret = CRYPTO_memcmp(
          key->GetSymmetricKey(),
          key2->GetSymmetricKey(),
          size) == 0;
      } else {
        ret = false;
      }
      break;
    }
    case kKeyTypePublic:
    case kKeyTypePrivate: {
      EVP_PKEY* pkey = key->GetAsymmetricKey().get();
      EVP_PKEY* pkey2 = key2->GetAsymmetricKey().get();
#if OPENSSL_VERSION_MAJOR >= 3
     ...",1131.0,1177.0,1.0,1.0,47.0,41,9,44,18,0,0,6,6,0,0,,0,0,2,1,1,void
1690,47865,GetKeyDetail,1,node.crypto.KeyObjectHandle.GetKeyDetail,void node.crypto.KeyObjectHandle.GetKeyDetail (FunctionCallbackInfo<Value>),crypto\crypto_keys.cc,"void KeyObjectHandle::GetKeyDetail(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  KeyObjectHandle* key;
  ASSIGN_OR_RETURN_UNWRAP(&key, args.Holder());

  CHECK(args[0]->IsObject());

  std::shared_ptr<KeyObjectData> data = key->Data();

  switch (data->GetKeyType()) {
    case kKeyTypeSecret:
      if (GetSecretKeyDetail(env, data, args[0].As<Object>()).IsNothing())
        return;
      break;
    case kKeyTypePublic:
      // Fall through
    case kKeyTypePrivate:
      if (GetAsymmetricKeyDetail(env, data, args[0].As<Object>()).IsNothing())
        return;
      break;
    default:
      UNREACHABLE();
  }

  args.GetReturnValue().Set(args[0]);
}",1179.0,1204.0,1.0,1.0,26.0,21,7,22,10,0,0,6,6,0,0,,0,0,2,1,1,void
1691,47961,GetAsymmetricKeyType,1,node.crypto.KeyObjectHandle.GetAsymmetricKeyType,Local<Value> node.crypto.KeyObjectHandle.GetAsymmetricKeyType (),crypto\crypto_keys.cc,"void KeyObjectHandle::GetAsymmetricKeyType(
    const FunctionCallbackInfo<Value>& args) {
  KeyObjectHandle* key;
  ASSIGN_OR_RETURN_UNWRAP(&key, args.Holder());

  args.GetReturnValue().Set(key->GetAsymmetricKeyType());
}",1232.0,1238.0,1.0,1.0,7.0,13,3,12,11,0,0,2,2,0,0,,0,0,2,1,1,void
1692,48073,GetSymmetricKeySize,1,node.crypto.KeyObjectHandle.GetSymmetricKeySize,void node.crypto.KeyObjectHandle.GetSymmetricKeySize (FunctionCallbackInfo<Value>),crypto\crypto_keys.cc,"void KeyObjectHandle::GetSymmetricKeySize(
    const FunctionCallbackInfo<Value>& args) {
  KeyObjectHandle* key;
  ASSIGN_OR_RETURN_UNWRAP(&key, args.Holder());
  args.GetReturnValue().Set(
      static_cast<uint32_t>(key->Data()->GetSymmetricKeySize()));
}",1240.0,1246.0,1.0,1.0,7.0,7,4,4,2,0,0,1,1,0,0,,0,0,2,1,1,void
1693,48102,Export,1,node.crypto.KeyObjectHandle.Export,void node.crypto.KeyObjectHandle.Export (FunctionCallbackInfo<Value>),crypto\crypto_keys.cc,"void KeyObjectHandle::Export(const FunctionCallbackInfo<Value>& args) {
  KeyObjectHandle* key;
  ASSIGN_OR_RETURN_UNWRAP(&key, args.Holder());

  KeyType type = key->Data()->GetKeyType();

  MaybeLocal<Value> result;
  if (type == kKeyTypeSecret) {
    result = key->ExportSecretKey();
  } else if (type == kKeyTypePublic) {
    unsigned int offset = 0;
    PublicKeyEncodingConfig config =
        ManagedEVPPKey::GetPublicKeyEncodingFromJs(
            args, &offset, kKeyContextExport);
    CHECK_EQ(offset, static_cast<unsigned int>(args.Length()));
    result = key->ExportPublicKey(config);
  } else {
    CHECK_EQ(type, kKeyTypePrivate);
    unsigned int offset = 0;
    NonCopyableMaybe<PrivateKeyEncodingConfig> config =
        ManagedEVPPKey::GetPrivateKeyEncodingFromJs(
            args, &offset, kKeyContextExport);
    if (config.IsEmpty())
      return;
    CHECK_EQ(offset, static_cast<unsigned int>(args.Length()));
    result = key->ExportPrivateKey(config.Release());
  }

  i...",1248.0,1278.0,1.0,1.0,31.0,15,8,14,7,0,0,3,3,0,0,,0,0,2,1,1,void
1694,48245,ExportSecretKey,1,node.crypto.KeyObjectHandle.ExportSecretKey,MaybeLocal<Value> node.crypto.KeyObjectHandle.ExportSecretKey (),crypto\crypto_keys.cc,"MaybeLocal<Value> KeyObjectHandle::ExportSecretKey() const {
  const char* buf = data_->GetSymmetricKey();
  unsigned int len = data_->GetSymmetricKeySize();
  return Buffer::Copy(env(), buf, len).FromMaybe(Local<Value>());
}",1280.0,1284.0,1.0,1.0,5.0,6,3,7,4,0,0,1,1,0,0,,0,0,0,0,0,MaybeLocal<Value>
1695,48275,ExportPublicKey,1,node.crypto.KeyObjectHandle.ExportPublicKey,MaybeLocal<Value> node.crypto.KeyObjectHandle.ExportPublicKey (PublicKeyEncodingConfig),crypto\crypto_keys.cc,"MaybeLocal<Value> KeyObjectHandle::ExportPublicKey(
    const PublicKeyEncodingConfig& config) const {
  return WritePublicKey(env(), data_->GetAsymmetricKey().get(), config);
}",1286.0,1289.0,1.0,1.0,4.0,2,2,2,2,0,0,1,1,0,0,,0,0,2,1,1,MaybeLocal<Value>
1696,48291,ExportPrivateKey,1,node.crypto.KeyObjectHandle.ExportPrivateKey,MaybeLocal<Value> node.crypto.KeyObjectHandle.ExportPrivateKey (PrivateKeyEncodingConfig),crypto\crypto_keys.cc,"MaybeLocal<Value> KeyObjectHandle::ExportPrivateKey(
    const PrivateKeyEncodingConfig& config) const {
  return WritePrivateKey(env(), data_->GetAsymmetricKey().get(), config);
}",1291.0,1294.0,1.0,1.0,4.0,2,2,2,2,0,0,1,1,0,0,,0,0,2,1,1,MaybeLocal<Value>
1697,48307,ExportJWK,1,node.crypto.KeyObjectHandle.ExportJWK,void node.crypto.KeyObjectHandle.ExportJWK (ANY),crypto\crypto_keys.cc,"void KeyObjectHandle::ExportJWK(
    const v8::FunctionCallbackInfo<v8::Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  KeyObjectHandle* key;
  ASSIGN_OR_RETURN_UNWRAP(&key, args.Holder());

  CHECK(args[0]->IsObject());
  CHECK(args[1]->IsBoolean());

  ExportJWKInner(env, key->Data(), args[0], args[1]->IsTrue());

  args.GetReturnValue().Set(args[0]);
}",1296.0,1308.0,1.0,1.0,13.0,15,5,13,4,0,0,1,1,0,0,,0,0,2,1,1,void
1698,48367,Initialize,1,node.crypto.NativeKeyObject.Initialize,"void node.crypto.NativeKeyObject.Initialize (Environment*,Local<Object>)",crypto\crypto_keys.cc,"void NativeKeyObject::Initialize(Environment* env, Local<Object> target) {
  SetMethod(env->context(),
            target,
            ""createNativeKeyObjectClass"",
            NativeKeyObject::CreateNativeKeyObjectClass);
}",1310.0,1315.0,1.0,1.0,6.0,2,2,3,3,0,0,1,1,0,0,,0,0,4,2,2,void
1699,48383,RegisterExternalReferences,1,node.crypto.NativeKeyObject.RegisterExternalReferences,void node.crypto.NativeKeyObject.RegisterExternalReferences (ExternalReferenceRegistry*),crypto\crypto_keys.cc,"void NativeKeyObject::RegisterExternalReferences(
    ExternalReferenceRegistry* registry) {
  registry->Register(NativeKeyObject::CreateNativeKeyObjectClass);
  registry->Register(NativeKeyObject::New);
}",1317.0,1321.0,1.0,1.0,5.0,4,2,4,2,0,0,1,1,0,0,,0,0,2,1,1,void
1700,48402,New,1,node.crypto.NativeKeyObject.New,void node.crypto.NativeKeyObject.New (FunctionCallbackInfo<Value>),crypto\crypto_keys.cc,"void NativeKeyObject::New(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsObject());
  KeyObjectHandle* handle = Unwrap<KeyObjectHandle>(args[0].As<Object>());
  new NativeKeyObject(env, args.This(), handle->Data());
}",1323.0,1329.0,1.0,1.0,7.0,13,7,13,7,0,0,1,1,0,0,,0,0,2,1,1,void
1701,48452,CreateNativeKeyObjectClass,1,node.crypto.NativeKeyObject.CreateNativeKeyObjectClass,void node.crypto.NativeKeyObject.CreateNativeKeyObjectClass (FunctionCallbackInfo<Value>),crypto\crypto_keys.cc,"void NativeKeyObject::CreateNativeKeyObjectClass(
    const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  CHECK_EQ(args.Length(), 1);
  Local<Value> callback = args[0];
  CHECK(callback->IsFunction());

  Local<FunctionTemplate> t =
      NewFunctionTemplate(isolate, NativeKeyObject::New);
  t->InstanceTemplate()->SetInternalFieldCount(
      KeyObjectHandle::kInternalFieldCount);

  Local<Value> ctor;
  if (!t->GetFunction(env->context()).ToLocal(&ctor))
    return;

  Local<Value> recv = Undefined(env->isolate());
  Local<Value> ret_v;
  if (!callback.As<Function>()->Call(
          env->context(), recv, 1, &ctor).ToLocal(&ret_v)) {
    return;
  }
  Local<Array> ret = ret_v.As<Array>();
  if (!ret->Get(env->context(), 1).ToLocal(&ctor)) return;
  env->set_crypto_key_object_secret_constructor(ctor.As<Function>());
  if (!ret->Get(env->context(), 2).ToLocal(&ctor)) return;
  env->set_crypto_key_objec...",1331.0,1363.0,1.0,1.0,33.0,64,8,57,16,0,0,6,6,0,0,,0,0,2,1,1,void
1702,48671,Deserialize,1,node.crypto.NativeKeyObject.KeyObjectTransferData.Deserialize,"BaseObjectPtr<BaseObject> node.crypto.NativeKeyObject.KeyObjectTransferData.Deserialize (Environment*,Local<Context>,ANY)",crypto\crypto_keys.cc,"BaseObjectPtr<BaseObject> NativeKeyObject::KeyObjectTransferData::Deserialize(
        Environment* env,
        Local<Context> context,
        std::unique_ptr<worker::TransferData> self) {
  if (context != env->context()) {
    THROW_ERR_MESSAGE_TARGET_CONTEXT_UNAVAILABLE(env);
    return {};
  }

  Local<Value> handle;
  if (!KeyObjectHandle::Create(env, data_).ToLocal(&handle))
    return {};

  Local<Function> key_ctor;
  Local<Value> arg = FIXED_ONE_BYTE_STRING(env->isolate(),
                                           ""internal/crypto/keys"");
  if (env->builtin_module_require()
          ->Call(context, Null(env->isolate()), 1, &arg)
          .IsEmpty()) {
    return {};
  }
  switch (data_->GetKeyType()) {
    case kKeyTypeSecret:
      key_ctor = env->crypto_key_object_secret_constructor();
      break;
    case kKeyTypePublic:
      key_ctor = env->crypto_key_object_public_constructor();
      break;
    case kKeyTypePrivate:
      key_ctor = env->crypto_key_object_privat...",1365.0,1405.0,1.0,1.0,41.0,38,8,43,17,0,0,9,6,0,0,,0,0,6,3,3,BaseObjectPtr<BaseObject>
1703,48818,GetTransferMode,1,node.crypto.NativeKeyObject.GetTransferMode,TransferMode node.crypto.NativeKeyObject.GetTransferMode (),crypto\crypto_keys.cc,"BaseObject::TransferMode NativeKeyObject::GetTransferMode() const {
  return BaseObject::TransferMode::kCloneable;
}",1407.0,1409.0,1.0,1.0,3.0,2,1,2,2,0,0,1,1,0,0,,0,0,0,0,0,TransferMode
1704,48828,CloneForMessaging,1,node.crypto.NativeKeyObject.CloneForMessaging,unique_ptr<worker::TransferData> node.crypto.NativeKeyObject.CloneForMessaging (),crypto\crypto_keys.cc,"std::unique_ptr<worker::TransferData> NativeKeyObject::CloneForMessaging()
    const {
  return std::make_unique<KeyObjectTransferData>(handle_data_);
}",1411.0,1414.0,1.0,1.0,4.0,3,3,3,3,0,0,1,1,0,0,,0,0,0,0,0,unique_ptr<worker.TransferData>
1705,48840,PKEY_SPKI_Export,1,node.crypto.PKEY_SPKI_Export,"WebCryptoKeyExportStatus node.crypto.PKEY_SPKI_Export (KeyObjectData*,ByteSource*)",crypto\crypto_keys.cc,"WebCryptoKeyExportStatus PKEY_SPKI_Export(
    KeyObjectData* key_data,
    ByteSource* out) {
  CHECK_EQ(key_data->GetKeyType(), kKeyTypePublic);
  ManagedEVPPKey m_pkey = key_data->GetAsymmetricKey();
  Mutex::ScopedLock lock(*m_pkey.mutex());
  BIOPointer bio(BIO_new(BIO_s_mem()));
  CHECK(bio);
  if (!i2d_PUBKEY_bio(bio.get(), m_pkey.get()))
    return WebCryptoKeyExportStatus::FAILED;

  *out = ByteSource::FromBIO(bio);
  return WebCryptoKeyExportStatus::OK;
}",1416.0,1429.0,1.0,1.0,14.0,13,5,13,7,0,0,2,2,0,0,,0,0,4,2,2,WebCryptoKeyExportStatus
1706,48864,bio,1,node.crypto.PKEY_SPKI_Export.bio,BIOPointer node.crypto.PKEY_SPKI_Export.bio (BIO_new),crypto\crypto_keys.cc,BIOPointer bio(BIO_new(BIO_s_mem()));,1422.0,1422.0,14.0,38.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,BIOPointer
1707,48901,PKEY_PKCS8_Export,1,node.crypto.PKEY_PKCS8_Export,"WebCryptoKeyExportStatus node.crypto.PKEY_PKCS8_Export (KeyObjectData*,ByteSource*)",crypto\crypto_keys.cc,"WebCryptoKeyExportStatus PKEY_PKCS8_Export(
    KeyObjectData* key_data,
    ByteSource* out) {
  CHECK_EQ(key_data->GetKeyType(), kKeyTypePrivate);
  ManagedEVPPKey m_pkey = key_data->GetAsymmetricKey();
  Mutex::ScopedLock lock(*m_pkey.mutex());

  BIOPointer bio(BIO_new(BIO_s_mem()));
  CHECK(bio);
  PKCS8Pointer p8inf(EVP_PKEY2PKCS8(m_pkey.get()));
  if (!i2d_PKCS8_PRIV_KEY_INFO_bio(bio.get(), p8inf.get()))
    return WebCryptoKeyExportStatus::FAILED;

  *out = ByteSource::FromBIO(bio);
  return WebCryptoKeyExportStatus::OK;
}",1431.0,1446.0,1.0,1.0,16.0,14,5,14,8,0,0,2,2,0,0,,0,0,4,2,2,WebCryptoKeyExportStatus
1708,48925,bio,1,node.crypto.PKEY_PKCS8_Export.bio,BIOPointer node.crypto.PKEY_PKCS8_Export.bio (BIO_new),crypto\crypto_keys.cc,BIOPointer bio(BIO_new(BIO_s_mem()));,1438.0,1438.0,14.0,38.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,BIOPointer
1709,48970,Initialize,1,node.crypto.Keys.Initialize,"void node.crypto.Keys.Initialize (Environment*,Local<Object>)",crypto\crypto_keys.cc,"void Initialize(Environment* env, Local<Object> target) {
  target->Set(env->context(),
              FIXED_ONE_BYTE_STRING(env->isolate(), ""KeyObjectHandle""),
              KeyObjectHandle::Initialize(env)).Check();

  NODE_DEFINE_CONSTANT(target, kWebCryptoKeyFormatRaw);
  NODE_DEFINE_CONSTANT(target, kWebCryptoKeyFormatPKCS8);
  NODE_DEFINE_CONSTANT(target, kWebCryptoKeyFormatSPKI);
  NODE_DEFINE_CONSTANT(target, kWebCryptoKeyFormatJWK);

  NODE_DEFINE_CONSTANT(target, EVP_PKEY_ED25519);
  NODE_DEFINE_CONSTANT(target, EVP_PKEY_ED448);
  NODE_DEFINE_CONSTANT(target, EVP_PKEY_X25519);
  NODE_DEFINE_CONSTANT(target, EVP_PKEY_X448);
  NODE_DEFINE_CONSTANT(target, kKeyEncodingPKCS1);
  NODE_DEFINE_CONSTANT(target, kKeyEncodingPKCS8);
  NODE_DEFINE_CONSTANT(target, kKeyEncodingSPKI);
  NODE_DEFINE_CONSTANT(target, kKeyEncodingSEC1);
  NODE_DEFINE_CONSTANT(target, kKeyFormatDER);
  NODE_DEFINE_CONSTANT(target, kKeyFormatPEM);
  NODE_DEFINE_CONSTANT(target, kKeyFormatJWK);
  NODE_DEFINE_...",1449.0,1475.0,1.0,2.0,27.0,665,7,625,48,0,0,1,1,0,0,,0,0,4,2,2,void
1710,50978,RegisterExternalReferences,1,node.crypto.Keys.RegisterExternalReferences,void node.crypto.Keys.RegisterExternalReferences (ExternalReferenceRegistry*),crypto\crypto_keys.cc,"void RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  KeyObjectHandle::RegisterExternalReferences(registry);
}",1477.0,1479.0,1.0,1.0,3.0,1,1,2,2,0,0,1,1,0,0,,0,0,2,1,1,void
1711,51036,PBKDF2Config,1,node.crypto.PBKDF2Config.PBKDF2Config,ANY node.crypto.PBKDF2Config.PBKDF2Config (PBKDF2Config),crypto\crypto_pbkdf2.cc,"PBKDF2Config::PBKDF2Config(PBKDF2Config&& other) noexcept
    : mode(other.mode),
      pass(std::move(other.pass)),
      salt(std::move(other.salt)),
      iterations(other.iterations),
      length(other.length),
      digest(other.digest) {}",20.0,26.0,1.0,29.0,7.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
1712,51041,operator =,1,node.crypto.PBKDF2Config.operator =,PBKDF2Config node.crypto.PBKDF2Config.operator = (PBKDF2Config),crypto\crypto_pbkdf2.cc,"PBKDF2Config& PBKDF2Config::operator=(PBKDF2Config&& other) noexcept {
  if (&other == this) return *this;
  this->~PBKDF2Config();
  return *new (this) PBKDF2Config(std::move(other));
}",28.0,32.0,1.0,1.0,5.0,7,6,4,3,0,0,2,2,0,0,,0,0,2,1,1,PBKDF2Config
1713,51069,MemoryInfo,1,node.crypto.PBKDF2Config.MemoryInfo,void node.crypto.PBKDF2Config.MemoryInfo (MemoryTracker*),crypto\crypto_pbkdf2.cc,"void PBKDF2Config::MemoryInfo(MemoryTracker* tracker) const {
  // The job is sync, the PBKDF2Config does not own the data.
  if (mode == kCryptoJobAsync) {
    tracker->TrackFieldWithSize(""pass"", pass.size());
    tracker->TrackFieldWithSize(""salt"", salt.size());
  }
}",34.0,40.0,1.0,1.0,7.0,5,3,6,5,0,0,2,2,0,0,,0,0,2,1,1,void
1714,51097,EncodeOutput,1,node.crypto.PBKDF2Traits.EncodeOutput,"Maybe<bool> node.crypto.PBKDF2Traits.EncodeOutput (Environment*,PBKDF2Config,ByteSource*,ANY*)",crypto\crypto_pbkdf2.cc,"Maybe<bool> PBKDF2Traits::EncodeOutput(
    Environment* env,
    const PBKDF2Config& params,
    ByteSource* out,
    v8::Local<v8::Value>* result) {
  *result = out->ToArrayBuffer(env);
  return Just(!result->IsEmpty());
}",42.0,49.0,1.0,1.0,8.0,5,4,4,3,0,0,1,1,0,0,,0,0,8,4,4,Maybe<bool>
1715,51120,AdditionalConfig,1,node.crypto.PBKDF2Traits.AdditionalConfig,"Maybe<bool> node.crypto.PBKDF2Traits.AdditionalConfig (CryptoJobMode,FunctionCallbackInfo<Value>,unsigned int,PBKDF2Config*)",crypto\crypto_pbkdf2.cc,"Maybe<bool> PBKDF2Traits::AdditionalConfig(
    CryptoJobMode mode,
    const FunctionCallbackInfo<Value>& args,
    unsigned int offset,
    PBKDF2Config* params) {
  Environment* env = Environment::GetCurrent(args);

  params->mode = mode;

  ArrayBufferOrViewContents<char> pass(args[offset]);
  ArrayBufferOrViewContents<char> salt(args[offset + 1]);

  if (UNLIKELY(!pass.CheckSizeInt32())) {
    THROW_ERR_OUT_OF_RANGE(env, ""pass is too large"");
    return Nothing<bool>();
  }

  if (UNLIKELY(!salt.CheckSizeInt32())) {
    THROW_ERR_OUT_OF_RANGE(env, ""salt is too large"");
    return Nothing<bool>();
  }

  params->pass = mode == kCryptoJobAsync
      ? pass.ToCopy()
      : pass.ToByteSource();

  params->salt = mode == kCryptoJobAsync
      ? salt.ToCopy()
      : salt.ToByteSource();

  CHECK(args[offset + 2]->IsInt32());  // iteration_count
  CHECK(args[offset + 3]->IsInt32());  // length
  CHECK(args[offset + 4]->IsString());  // digest_name

  params->iterations = args[offset...",58.0,112.0,1.0,1.0,55.0,57,10,49,11,0,0,6,6,0,0,,0,0,8,4,4,Maybe<bool>
1716,51329,DeriveBits,1,node.crypto.PBKDF2Traits.DeriveBits,"bool node.crypto.PBKDF2Traits.DeriveBits (Environment*,PBKDF2Config,ByteSource*)",crypto\crypto_pbkdf2.cc,"bool PBKDF2Traits::DeriveBits(
    Environment* env,
    const PBKDF2Config& params,
    ByteSource* out) {
  ByteSource::Builder buf(params.length);

  // Both pass and salt may be zero length here.
  // The generated bytes are stored in buf, which is
  // assigned to out on success.

  if (PKCS5_PBKDF2_HMAC(params.pass.data<char>(),
                        params.pass.size(),
                        params.salt.data<unsigned char>(),
                        params.salt.size(),
                        params.iterations,
                        params.digest,
                        params.length,
                        buf.data<unsigned char>()) <= 0) {
    return false;
  }
  *out = std::move(buf).release();
  return true;
}",114.0,136.0,1.0,1.0,23.0,18,4,12,4,0,0,2,2,0,0,,0,0,6,3,3,bool
1717,51438,EncodeOutput,1,node.crypto.RandomBytesTraits.EncodeOutput,"Maybe<bool> node.crypto.RandomBytesTraits.EncodeOutput (Environment*,RandomBytesConfig,ByteSource*,ANY*)",crypto\crypto_random.cc,"Maybe<bool> RandomBytesTraits::EncodeOutput(
    Environment* env,
    const RandomBytesConfig& params,
    ByteSource* unused,
    v8::Local<v8::Value>* result) {
  *result = v8::Undefined(env->isolate());
  return Just(!result->IsEmpty());
}",28.0,35.0,1.0,1.0,8.0,6,5,4,3,0,0,1,1,0,0,,0,0,8,4,4,Maybe<bool>
1718,51464,AdditionalConfig,1,node.crypto.RandomBytesTraits.AdditionalConfig,"Maybe<bool> node.crypto.RandomBytesTraits.AdditionalConfig (CryptoJobMode,FunctionCallbackInfo<Value>,unsigned int,RandomBytesConfig*)",crypto\crypto_random.cc,"Maybe<bool> RandomBytesTraits::AdditionalConfig(
    CryptoJobMode mode,
    const FunctionCallbackInfo<Value>& args,
    unsigned int offset,
    RandomBytesConfig* params) {
  CHECK(IsAnyByteSource(args[offset]));  // Buffer to fill
  CHECK(args[offset + 1]->IsUint32());  // Offset
  CHECK(args[offset + 2]->IsUint32());  // Size

  ArrayBufferOrViewContents<unsigned char> in(args[offset]);

  const uint32_t byte_offset = args[offset + 1].As<Uint32>()->Value();
  const uint32_t size = args[offset + 2].As<Uint32>()->Value();
  CHECK_GE(byte_offset + size, byte_offset);  // Overflow check.
  CHECK_LE(byte_offset + size, in.size());  // Bounds check.

  params->buffer = in.data() + byte_offset;
  params->size = size;

  return Just(true);
}",37.0,57.0,1.0,1.0,21.0,27,5,25,6,0,0,1,1,0,0,,0,0,8,4,4,Maybe<bool>
1719,51559,DeriveBits,1,node.crypto.RandomBytesTraits.DeriveBits,"bool node.crypto.RandomBytesTraits.DeriveBits (Environment*,RandomBytesConfig,ByteSource*)",crypto\crypto_random.cc,"bool RandomBytesTraits::DeriveBits(
    Environment* env,
    const RandomBytesConfig& params,
    ByteSource* unused) {
  return CSPRNG(params.buffer, params.size).is_ok();
}",59.0,64.0,1.0,1.0,6.0,3,1,2,1,0,0,1,1,0,0,,0,0,6,3,3,bool
1720,51577,MemoryInfo,1,node.crypto.RandomPrimeConfig.MemoryInfo,void node.crypto.RandomPrimeConfig.MemoryInfo (MemoryTracker*),crypto\crypto_random.cc,"void RandomPrimeConfig::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackFieldWithSize(""prime"", prime ? bits * 8 : 0);
}",66.0,68.0,1.0,1.0,3.0,3,3,3,3,0,0,1,1,0,0,,0,0,2,1,1,void
1721,51593,EncodeOutput,1,node.crypto.RandomPrimeTraits.EncodeOutput,"Maybe<bool> node.crypto.RandomPrimeTraits.EncodeOutput (Environment*,RandomPrimeConfig,ByteSource*,ANY*)",crypto\crypto_random.cc,"Maybe<bool> RandomPrimeTraits::EncodeOutput(
    Environment* env,
    const RandomPrimeConfig& params,
    ByteSource* unused,
    v8::Local<v8::Value>* result) {
  size_t size = BN_num_bytes(params.prime.get());
  std::shared_ptr<BackingStore> store =
      ArrayBuffer::NewBackingStore(env->isolate(), size);
  BN_bn2binpad(
      params.prime.get(),
      reinterpret_cast<unsigned char*>(store->Data()),
      size);
  *result = ArrayBuffer::New(env->isolate(), store);
  return Just(true);
}",70.0,84.0,1.0,1.0,15.0,17,7,15,8,0,0,1,1,0,0,,0,0,8,4,4,Maybe<bool>
1722,51657,AdditionalConfig,1,node.crypto.RandomPrimeTraits.AdditionalConfig,"Maybe<bool> node.crypto.RandomPrimeTraits.AdditionalConfig (CryptoJobMode,FunctionCallbackInfo<Value>,unsigned int,RandomPrimeConfig*)",crypto\crypto_random.cc,"Maybe<bool> RandomPrimeTraits::AdditionalConfig(
    CryptoJobMode mode,
    const FunctionCallbackInfo<Value>& args,
    unsigned int offset,
    RandomPrimeConfig* params) {
  ClearErrorOnReturn clear_error;
  Environment* env = Environment::GetCurrent(args);
  CHECK(args[offset]->IsUint32());  // Size
  CHECK(args[offset + 1]->IsBoolean());  // Safe

  const uint32_t size = args[offset].As<Uint32>()->Value();
  bool safe = args[offset + 1]->IsTrue();

  if (!args[offset + 2]->IsUndefined()) {
    ArrayBufferOrViewContents<unsigned char> add(args[offset + 2]);
    params->add.reset(BN_bin2bn(add.data(), add.size(), nullptr));
    if (!params->add) {
      THROW_ERR_CRYPTO_OPERATION_FAILED(env, ""could not generate prime"");
      return Nothing<bool>();
    }
  }

  if (!args[offset + 3]->IsUndefined()) {
    ArrayBufferOrViewContents<unsigned char> rem(args[offset + 3]);
    params->rem.reset(BN_bin2bn(rem.data(), rem.size(), nullptr));
    if (!params->rem) {
      THROW_ERR_CRYPT...",86.0,150.0,1.0,1.0,65.0,59,9,49,10,0,0,10,16,0,0,,0,0,8,4,4,Maybe<bool>
1723,51891,DeriveBits,1,node.crypto.RandomPrimeTraits.DeriveBits,"bool node.crypto.RandomPrimeTraits.DeriveBits (Environment*,RandomPrimeConfig,ByteSource*)",crypto\crypto_random.cc,"bool RandomPrimeTraits::DeriveBits(Environment* env,
                                   const RandomPrimeConfig& params,
                                   ByteSource* unused) {
  // BN_generate_prime_ex() calls RAND_bytes_ex() internally.
  // Make sure the CSPRNG is properly seeded.
  CHECK(CSPRNG(nullptr, 0).is_ok());

  if (BN_generate_prime_ex(
          params.prime.get(),
          params.bits,
          params.safe ? 1 : 0,
          params.add.get(),
          params.rem.get(),
          nullptr) == 0) {
    return false;
  }

  return true;
}",152.0,170.0,1.0,1.0,19.0,11,3,5,1,0,0,2,2,0,0,,0,0,6,3,3,bool
1724,51942,MemoryInfo,1,node.crypto.CheckPrimeConfig.MemoryInfo,void node.crypto.CheckPrimeConfig.MemoryInfo (MemoryTracker*),crypto\crypto_random.cc,"void CheckPrimeConfig::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackFieldWithSize(
      ""prime"", candidate ? BN_num_bytes(candidate.get()) : 0);
}",172.0,175.0,1.0,1.0,4.0,3,3,3,2,0,0,1,1,0,0,,0,0,2,1,1,void
1725,51960,AdditionalConfig,1,node.crypto.CheckPrimeTraits.AdditionalConfig,"Maybe<bool> node.crypto.CheckPrimeTraits.AdditionalConfig (CryptoJobMode,FunctionCallbackInfo<Value>,unsigned int,CheckPrimeConfig*)",crypto\crypto_random.cc,"Maybe<bool> CheckPrimeTraits::AdditionalConfig(
    CryptoJobMode mode,
    const FunctionCallbackInfo<Value>& args,
    unsigned int offset,
    CheckPrimeConfig* params) {
  ArrayBufferOrViewContents<unsigned char> candidate(args[offset]);

  params->candidate =
      BignumPointer(BN_bin2bn(
          candidate.data(),
          candidate.size(),
          nullptr));

  CHECK(args[offset + 1]->IsInt32());  // Checks
  params->checks = args[offset + 1].As<Int32>()->Value();
  CHECK_GE(params->checks, 0);

  return Just(true);
}",177.0,195.0,1.0,1.0,19.0,15,5,11,4,0,0,1,1,0,0,,0,0,8,4,4,Maybe<bool>
1726,52020,DeriveBits,1,node.crypto.CheckPrimeTraits.DeriveBits,"bool node.crypto.CheckPrimeTraits.DeriveBits (Environment*,CheckPrimeConfig,ByteSource*)",crypto\crypto_random.cc,"bool CheckPrimeTraits::DeriveBits(
    Environment* env,
    const CheckPrimeConfig& params,
    ByteSource* out) {

  BignumCtxPointer ctx(BN_CTX_new());

  int ret = BN_is_prime_ex(
            params.candidate.get(),
            params.checks,
            ctx.get(),
            nullptr);
  if (ret < 0) return false;
  ByteSource::Builder buf(1);
  buf.data<char>()[0] = ret;
  *out = std::move(buf).release();
  return true;
}",197.0,214.0,1.0,1.0,18.0,13,5,10,6,0,0,2,2,0,0,,0,0,6,3,3,bool
1727,52079,EncodeOutput,1,node.crypto.CheckPrimeTraits.EncodeOutput,"Maybe<bool> node.crypto.CheckPrimeTraits.EncodeOutput (Environment*,CheckPrimeConfig,ByteSource*,ANY*)",crypto\crypto_random.cc,"Maybe<bool> CheckPrimeTraits::EncodeOutput(
    Environment* env,
    const CheckPrimeConfig& params,
    ByteSource* out,
    v8::Local<v8::Value>* result) {
  *result = Boolean::New(env->isolate(), out->data<char>()[0] != 0);
  return Just(true);
}",216.0,223.0,1.0,1.0,8.0,7,6,4,4,0,0,1,1,0,0,,0,0,8,4,4,Maybe<bool>
1728,52110,Initialize,1,node.crypto.Random.Initialize,"void node.crypto.Random.Initialize (Environment*,Local<Object>)",crypto\crypto_random.cc,"void Initialize(Environment* env, Local<Object> target) {
  RandomBytesJob::Initialize(env, target);
  RandomPrimeJob::Initialize(env, target);
  CheckPrimeJob::Initialize(env, target);
}",226.0,230.0,1.0,1.0,5.0,3,1,9,5,0,0,1,1,0,0,,0,0,4,2,2,void
1729,52134,RegisterExternalReferences,1,node.crypto.Random.RegisterExternalReferences,void node.crypto.Random.RegisterExternalReferences (ExternalReferenceRegistry*),crypto\crypto_random.cc,"void RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  RandomBytesJob::RegisterExternalReferences(registry);
  RandomPrimeJob::RegisterExternalReferences(registry);
  CheckPrimeJob::RegisterExternalReferences(registry);
}",232.0,236.0,1.0,1.0,5.0,3,1,6,4,0,0,1,1,0,0,,0,0,2,1,1,void
1730,52202,Setup,1,node.crypto.RsaKeyGenTraits.Setup,EVPKeyCtxPointer node.crypto.RsaKeyGenTraits.Setup (RsaKeyPairGenConfig*),crypto\crypto_rsa.cc,"EVPKeyCtxPointer RsaKeyGenTraits::Setup(RsaKeyPairGenConfig* params) {
  EVPKeyCtxPointer ctx(
      EVP_PKEY_CTX_new_id(
          params->params.variant == kKeyVariantRSA_PSS
              ? EVP_PKEY_RSA_PSS
              : EVP_PKEY_RSA,
          nullptr));

  if (EVP_PKEY_keygen_init(ctx.get()) <= 0)
    return EVPKeyCtxPointer();

  if (EVP_PKEY_CTX_set_rsa_keygen_bits(
          ctx.get(),
          params->params.modulus_bits) <= 0) {
    return EVPKeyCtxPointer();
  }

  // 0x10001 is the default RSA exponent.
  if (params->params.exponent != 0x10001) {
    BignumPointer bn(BN_new());
    CHECK_NOT_NULL(bn.get());
    CHECK(BN_set_word(bn.get(), params->params.exponent));
    // EVP_CTX accepts ownership of bn on success.
    if (EVP_PKEY_CTX_set_rsa_keygen_pubexp(ctx.get(), bn.get()) <= 0)
      return EVPKeyCtxPointer();

    bn.release();
  }

  if (params->params.variant == kKeyVariantRSA_PSS) {
    if (params->params.md != nullptr &&
        EVP_PKEY_CTX_set_rsa_pss_key...",32.0,97.0,1.0,1.0,66.0,62,10,38,8,0,0,11,17,0,0,,0,0,2,1,1,EVPKeyCtxPointer
1731,52419,AdditionalConfig,1,node.crypto.RsaKeyGenTraits.AdditionalConfig,"Maybe<bool> node.crypto.RsaKeyGenTraits.AdditionalConfig (CryptoJobMode,FunctionCallbackInfo<Value>,unsigned int*,RsaKeyPairGenConfig*)",crypto\crypto_rsa.cc,"Maybe<bool> RsaKeyGenTraits::AdditionalConfig(
    CryptoJobMode mode,
    const FunctionCallbackInfo<Value>& args,
    unsigned int* offset,
    RsaKeyPairGenConfig* params) {
  Environment* env = Environment::GetCurrent(args);

  CHECK(args[*offset]->IsUint32());  // Variant
  CHECK(args[*offset + 1]->IsUint32());  // Modulus bits
  CHECK(args[*offset + 2]->IsUint32());  // Exponent

  params->params.variant =
      static_cast<RSAKeyVariant>(args[*offset].As<Uint32>()->Value());

  CHECK_IMPLIES(params->params.variant != kKeyVariantRSA_PSS,
                args.Length() == 10);
  CHECK_IMPLIES(params->params.variant == kKeyVariantRSA_PSS,
                args.Length() == 13);

  params->params.modulus_bits = args[*offset + 1].As<Uint32>()->Value();
  params->params.exponent = args[*offset + 2].As<Uint32>()->Value();

  *offset += 3;

  if (params->params.variant == kKeyVariantRSA_PSS) {
    if (!args[*offset]->IsUndefined()) {
      CHECK(args[*offset]->IsString());
      Utf8Val...",126.0,187.0,1.0,1.0,62.0,113,12,61,7,0,0,8,17,0,0,,0,0,8,4,4,Maybe<bool>
1732,52732,RSA_JWK_Export,1,node.crypto.anonymous_namespace_1.RSA_JWK_Export,"WebCryptoKeyExportStatus node.crypto.anonymous_namespace_1.RSA_JWK_Export (KeyObjectData*,RSAKeyExportConfig,ByteSource*)",crypto\crypto_rsa.cc,"WebCryptoKeyExportStatus RSA_JWK_Export(
    KeyObjectData* key_data,
    const RSAKeyExportConfig& params,
    ByteSource* out) {
  return WebCryptoKeyExportStatus::FAILED;
}",190.0,195.0,1.0,1.0,6.0,1,1,1,1,0,0,1,1,0,0,,0,0,6,3,3,WebCryptoKeyExportStatus
1733,52743,RSA_Cipher,1,node.crypto.anonymous_namespace_2.RSA_Cipher,"WebCryptoCipherStatus node.crypto.anonymous_namespace_2.RSA_Cipher<PublicKeyCipher::EVP_PKEY_cipher_init_t,PublicKeyCipher::EVP_PKEY_cipher_t> (Environment*,KeyObjectData*,RSACipherConfig,ByteSource,ByteSource*)",crypto\crypto_rsa.cc,"WebCryptoCipherStatus RSA_Cipher(
    Environment* env,
    KeyObjectData* key_data,
    const RSACipherConfig& params,
    const ByteSource& in,
    ByteSource* out) {
  CHECK_NE(key_data->GetKeyType(), kKeyTypeSecret);
  ManagedEVPPKey m_pkey = key_data->GetAsymmetricKey();
  Mutex::ScopedLock lock(*m_pkey.mutex());

  EVPKeyCtxPointer ctx(EVP_PKEY_CTX_new(m_pkey.get(), nullptr));

  if (!ctx || init(ctx.get()) <= 0)
    return WebCryptoCipherStatus::FAILED;

  if (EVP_PKEY_CTX_set_rsa_padding(ctx.get(), params.padding) <= 0) {
    return WebCryptoCipherStatus::FAILED;
  }

  if (params.digest != nullptr &&
      (EVP_PKEY_CTX_set_rsa_oaep_md(ctx.get(), params.digest) <= 0 ||
       EVP_PKEY_CTX_set_rsa_mgf1_md(ctx.get(), params.digest) <= 0)) {
    return WebCryptoCipherStatus::FAILED;
  }

  if (!SetRsaOaepLabel(ctx, params.label)) return WebCryptoCipherStatus::FAILED;

  size_t out_len = 0;
  if (cipher(
          ctx.get(),
          nullptr,
          &out_len,
          in.d...",199.0,248.0,1.0,1.0,50.0,48,10,39,11,0,0,7,7,0,0,,0,0,10,5,5,WebCryptoCipherStatus
1734,52931,AdditionalConfig,1,node.crypto.RSAKeyExportTraits.AdditionalConfig,"Maybe<bool> node.crypto.RSAKeyExportTraits.AdditionalConfig (FunctionCallbackInfo<Value>,unsigned int,RSAKeyExportConfig*)",crypto\crypto_rsa.cc,"Maybe<bool> RSAKeyExportTraits::AdditionalConfig(
    const FunctionCallbackInfo<Value>& args,
    unsigned int offset,
    RSAKeyExportConfig* params) {
  CHECK(args[offset]->IsUint32());  // RSAKeyVariant
  params->variant =
      static_cast<RSAKeyVariant>(args[offset].As<Uint32>()->Value());
  return Just(true);
}",251.0,259.0,1.0,1.0,9.0,8,5,5,3,0,0,1,1,0,0,,0,0,6,3,3,Maybe<bool>
1735,52963,DoExport,1,node.crypto.RSAKeyExportTraits.DoExport,"WebCryptoKeyExportStatus node.crypto.RSAKeyExportTraits.DoExport (ANY,WebCryptoKeyFormat,RSAKeyExportConfig,ByteSource*)",crypto\crypto_rsa.cc,"WebCryptoKeyExportStatus RSAKeyExportTraits::DoExport(
    std::shared_ptr<KeyObjectData> key_data,
    WebCryptoKeyFormat format,
    const RSAKeyExportConfig& params,
    ByteSource* out) {
  CHECK_NE(key_data->GetKeyType(), kKeyTypeSecret);

  switch (format) {
    case kWebCryptoKeyFormatRaw:
      // Not supported for RSA keys of either type
      return WebCryptoKeyExportStatus::FAILED;
    case kWebCryptoKeyFormatJWK:
      return RSA_JWK_Export(key_data.get(), params, out);
    case kWebCryptoKeyFormatPKCS8:
      if (key_data->GetKeyType() != kKeyTypePrivate)
        return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;
      return PKEY_PKCS8_Export(key_data.get(), out);
    case kWebCryptoKeyFormatSPKI:
      if (key_data->GetKeyType() != kKeyTypePublic)
        return WebCryptoKeyExportStatus::INVALID_KEY_TYPE;
      return PKEY_SPKI_Export(key_data.get(), out);
    default:
      UNREACHABLE();
  }
}",261.0,285.0,1.0,1.0,25.0,11,3,21,12,0,0,4,6,0,0,,0,0,8,4,4,WebCryptoKeyExportStatus
1736,53040,RSACipherConfig,1,node.crypto.RSACipherConfig.RSACipherConfig,ANY node.crypto.RSACipherConfig.RSACipherConfig (RSACipherConfig),crypto\crypto_rsa.cc,"RSACipherConfig::RSACipherConfig(RSACipherConfig&& other) noexcept
    : mode(other.mode),
      label(std::move(other.label)),
      padding(other.padding),
      digest(other.digest) {}",287.0,291.0,1.0,29.0,5.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
1737,53045,MemoryInfo,1,node.crypto.RSACipherConfig.MemoryInfo,void node.crypto.RSACipherConfig.MemoryInfo (MemoryTracker*),crypto\crypto_rsa.cc,"void RSACipherConfig::MemoryInfo(MemoryTracker* tracker) const {
  if (mode == kCryptoJobAsync)
    tracker->TrackFieldWithSize(""label"", label.size());
}",293.0,296.0,1.0,1.0,4.0,3,3,4,4,0,0,2,2,0,0,,0,0,2,1,1,void
1738,53064,AdditionalConfig,1,node.crypto.RSACipherTraits.AdditionalConfig,"Maybe<bool> node.crypto.RSACipherTraits.AdditionalConfig (CryptoJobMode,FunctionCallbackInfo<Value>,unsigned int,WebCryptoCipherMode,RSACipherConfig*)",crypto\crypto_rsa.cc,"Maybe<bool> RSACipherTraits::AdditionalConfig(
    CryptoJobMode mode,
    const FunctionCallbackInfo<Value>& args,
    unsigned int offset,
    WebCryptoCipherMode cipher_mode,
    RSACipherConfig* params) {
  Environment* env = Environment::GetCurrent(args);

  params->mode = mode;
  params->padding = RSA_PKCS1_OAEP_PADDING;

  CHECK(args[offset]->IsUint32());
  RSAKeyVariant variant =
      static_cast<RSAKeyVariant>(args[offset].As<Uint32>()->Value());

  switch (variant) {
    case kKeyVariantRSA_OAEP: {
      CHECK(args[offset + 1]->IsString());  // digest
      Utf8Value digest(env->isolate(), args[offset + 1]);

      params->digest = EVP_get_digestbyname(*digest);
      if (params->digest == nullptr) {
        THROW_ERR_CRYPTO_INVALID_DIGEST(env, ""Invalid digest: %s"", *digest);
        return Nothing<bool>();
      }

      if (IsAnyByteSource(args[offset + 2])) {
        ArrayBufferOrViewContents<char> label(args[offset + 2]);
        if (UNLIKELY(!label.CheckSizeInt32()))...",298.0,340.0,1.0,1.0,43.0,34,9,33,11,0,0,6,9,0,0,,0,0,10,5,5,Maybe<bool>
1739,53204,DoCipher,1,node.crypto.RSACipherTraits.DoCipher,"WebCryptoCipherStatus node.crypto.RSACipherTraits.DoCipher (Environment*,ANY,WebCryptoCipherMode,RSACipherConfig,ByteSource,ByteSource*)",crypto\crypto_rsa.cc,"WebCryptoCipherStatus RSACipherTraits::DoCipher(
    Environment* env,
    std::shared_ptr<KeyObjectData> key_data,
    WebCryptoCipherMode cipher_mode,
    const RSACipherConfig& params,
    const ByteSource& in,
    ByteSource* out) {
  switch (cipher_mode) {
    case kWebCryptoCipherEncrypt:
      CHECK_EQ(key_data->GetKeyType(), kKeyTypePublic);
      return RSA_Cipher<EVP_PKEY_encrypt_init, EVP_PKEY_encrypt>(
          env, key_data.get(), params, in, out);
    case kWebCryptoCipherDecrypt:
      CHECK_EQ(key_data->GetKeyType(), kKeyTypePrivate);
      return RSA_Cipher<EVP_PKEY_decrypt_init, EVP_PKEY_decrypt>(
          env, key_data.get(), params, in, out);
  }
  return WebCryptoCipherStatus::FAILED;
}",342.0,360.0,1.0,1.0,19.0,5,2,18,11,0,0,2,2,0,0,,0,0,12,6,6,WebCryptoCipherStatus
1740,53257,ExportJWKRsaKey,1,node.crypto.ExportJWKRsaKey,"Maybe<bool> node.crypto.ExportJWKRsaKey (Environment*,ANY,Local<Object>)",crypto\crypto_rsa.cc,"Maybe<bool> ExportJWKRsaKey(
    Environment* env,
    std::shared_ptr<KeyObjectData> key,
    Local<Object> target) {
  ManagedEVPPKey m_pkey = key->GetAsymmetricKey();
  Mutex::ScopedLock lock(*m_pkey.mutex());
  int type = EVP_PKEY_id(m_pkey.get());
  CHECK(type == EVP_PKEY_RSA || type == EVP_PKEY_RSA_PSS);

  // TODO(tniessen): Remove the ""else"" branch once we drop support for OpenSSL
  // versions older than 1.1.1e via FIPS / dynamic linking.
  const RSA* rsa;
  if (OpenSSL_version_num() >= 0x1010105fL) {
    rsa = EVP_PKEY_get0_RSA(m_pkey.get());
  } else {
    rsa = static_cast<const RSA*>(EVP_PKEY_get0(m_pkey.get()));
  }
  CHECK_NOT_NULL(rsa);

  const BIGNUM* n;
  const BIGNUM* e;
  const BIGNUM* d;
  const BIGNUM* p;
  const BIGNUM* q;
  const BIGNUM* dp;
  const BIGNUM* dq;
  const BIGNUM* qi;
  RSA_get0_key(rsa, &n, &e, &d);

  if (target->Set(
          env->context(),
          env->jwk_kty_string(),
          env->jwk_rsa_string()).IsNothing()) {
    return Nothing<b...",362.0,417.0,1.0,1.0,56.0,49,8,61,17,0,0,6,7,0,0,,0,0,6,3,3,Maybe<bool>
1741,53486,ImportJWKRsaKey,1,node.crypto.ImportJWKRsaKey,"shared_ptr<KeyObjectData> node.crypto.ImportJWKRsaKey (Environment*,Local<Object>,FunctionCallbackInfo<Value>,unsigned int)",crypto\crypto_rsa.cc,"std::shared_ptr<KeyObjectData> ImportJWKRsaKey(
    Environment* env,
    Local<Object> jwk,
    const FunctionCallbackInfo<Value>& args,
    unsigned int offset) {
  Local<Value> n_value;
  Local<Value> e_value;
  Local<Value> d_value;

  if (!jwk->Get(env->context(), env->jwk_n_string()).ToLocal(&n_value) ||
      !jwk->Get(env->context(), env->jwk_e_string()).ToLocal(&e_value) ||
      !jwk->Get(env->context(), env->jwk_d_string()).ToLocal(&d_value) ||
      !n_value->IsString() ||
      !e_value->IsString()) {
    THROW_ERR_CRYPTO_INVALID_JWK(env, ""Invalid JWK RSA key"");
    return std::shared_ptr<KeyObjectData>();
  }

  if (!d_value->IsUndefined() && !d_value->IsString()) {
    THROW_ERR_CRYPTO_INVALID_JWK(env, ""Invalid JWK RSA key"");
    return std::shared_ptr<KeyObjectData>();
  }

  KeyType type = d_value->IsString() ? kKeyTypePrivate : kKeyTypePublic;

  RsaPointer rsa(RSA_new());

  ByteSource n = ByteSource::FromEncodedString(env, n_value.As<String>());
  ByteSource e = ...",419.0,506.0,1.0,1.0,88.0,159,11,133,28,0,0,8,11,0,0,,0,0,8,4,4,shared_ptr<KeyObjectData>
1742,54021,GetRsaKeyDetail,1,node.crypto.GetRsaKeyDetail,"Maybe<bool> node.crypto.GetRsaKeyDetail (Environment*,ANY,Local<Object>)",crypto\crypto_rsa.cc,"Maybe<bool> GetRsaKeyDetail(
    Environment* env,
    std::shared_ptr<KeyObjectData> key,
    Local<Object> target) {
  const BIGNUM* e;  // Public Exponent
  const BIGNUM* n;  // Modulus

  ManagedEVPPKey m_pkey = key->GetAsymmetricKey();
  Mutex::ScopedLock lock(*m_pkey.mutex());
  int type = EVP_PKEY_id(m_pkey.get());
  CHECK(type == EVP_PKEY_RSA || type == EVP_PKEY_RSA_PSS);

  // TODO(tniessen): Remove the ""else"" branch once we drop support for OpenSSL
  // versions older than 1.1.1e via FIPS / dynamic linking.
  const RSA* rsa;
  if (OpenSSL_version_num() >= 0x1010105fL) {
    rsa = EVP_PKEY_get0_RSA(m_pkey.get());
  } else {
    rsa = static_cast<const RSA*>(EVP_PKEY_get0(m_pkey.get()));
  }
  CHECK_NOT_NULL(rsa);

  RSA_get0_key(rsa, &n, &e, nullptr);

  size_t modulus_length = BN_num_bits(n);

  if (target
          ->Set(
              env->context(),
              env->modulus_length_string(),
              Number::New(env->isolate(), static_cast<double>(modulus_length))...",508.0,631.0,1.0,1.0,124.0,85,12,86,23,0,0,15,37,0,0,,0,0,6,3,3,Maybe<bool>
1743,54393,Initialize,1,node.crypto.RSAAlg.Initialize,"void node.crypto.RSAAlg.Initialize (Environment*,Local<Object>)",crypto\crypto_rsa.cc,"void Initialize(Environment* env, Local<Object> target) {
  RSAKeyPairGenJob::Initialize(env, target);
  RSAKeyExportJob::Initialize(env, target);
  RSACipherJob::Initialize(env, target);

  NODE_DEFINE_CONSTANT(target, kKeyVariantRSA_SSA_PKCS1_v1_5);
  NODE_DEFINE_CONSTANT(target, kKeyVariantRSA_PSS);
  NODE_DEFINE_CONSTANT(target, kKeyVariantRSA_OAEP);
}",634.0,642.0,1.0,1.0,9.0,3,1,15,8,0,0,1,1,0,0,,0,0,4,2,2,void
1744,54426,RegisterExternalReferences,1,node.crypto.RSAAlg.RegisterExternalReferences,void node.crypto.RSAAlg.RegisterExternalReferences (ExternalReferenceRegistry*),crypto\crypto_rsa.cc,"void RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  RSAKeyPairGenJob::RegisterExternalReferences(registry);
  RSAKeyExportJob::RegisterExternalReferences(registry);
  RSACipherJob::RegisterExternalReferences(registry);
}",644.0,648.0,1.0,1.0,5.0,3,1,6,4,0,0,1,1,0,0,,0,0,2,1,1,void
1745,54488,ScryptConfig,1,node.crypto.ScryptConfig.ScryptConfig,ANY node.crypto.ScryptConfig.ScryptConfig (ScryptConfig),crypto\crypto_scrypt.cc,"ScryptConfig::ScryptConfig(ScryptConfig&& other) noexcept
  : mode(other.mode),
    pass(std::move(other.pass)),
    salt(std::move(other.salt)),
    N(other.N),
    r(other.r),
    p(other.p),
    maxmem(other.maxmem),
    length(other.length) {}",23.0,31.0,1.0,27.0,9.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
1746,54493,operator =,1,node.crypto.ScryptConfig.operator =,ScryptConfig node.crypto.ScryptConfig.operator = (ScryptConfig),crypto\crypto_scrypt.cc,"ScryptConfig& ScryptConfig::operator=(ScryptConfig&& other) noexcept {
  if (&other == this) return *this;
  this->~ScryptConfig();
  return *new (this) ScryptConfig(std::move(other));
}",33.0,37.0,1.0,1.0,5.0,7,6,4,3,0,0,2,2,0,0,,0,0,2,1,1,ScryptConfig
1747,54521,MemoryInfo,1,node.crypto.ScryptConfig.MemoryInfo,void node.crypto.ScryptConfig.MemoryInfo (MemoryTracker*),crypto\crypto_scrypt.cc,"void ScryptConfig::MemoryInfo(MemoryTracker* tracker) const {
  if (mode == kCryptoJobAsync) {
    tracker->TrackFieldWithSize(""pass"", pass.size());
    tracker->TrackFieldWithSize(""salt"", salt.size());
  }
}",39.0,44.0,1.0,1.0,6.0,5,3,6,5,0,0,2,2,0,0,,0,0,2,1,1,void
1748,54549,EncodeOutput,1,node.crypto.ScryptTraits.EncodeOutput,"Maybe<bool> node.crypto.ScryptTraits.EncodeOutput (Environment*,ScryptConfig,ByteSource*,ANY*)",crypto\crypto_scrypt.cc,"Maybe<bool> ScryptTraits::EncodeOutput(
    Environment* env,
    const ScryptConfig& params,
    ByteSource* out,
    v8::Local<v8::Value>* result) {
  *result = out->ToArrayBuffer(env);
  return Just(!result->IsEmpty());
}",46.0,53.0,1.0,1.0,8.0,5,4,4,3,0,0,1,1,0,0,,0,0,8,4,4,Maybe<bool>
1749,54572,AdditionalConfig,1,node.crypto.ScryptTraits.AdditionalConfig,"Maybe<bool> node.crypto.ScryptTraits.AdditionalConfig (CryptoJobMode,FunctionCallbackInfo<Value>,unsigned int,ScryptConfig*)",crypto\crypto_scrypt.cc,"Maybe<bool> ScryptTraits::AdditionalConfig(
    CryptoJobMode mode,
    const FunctionCallbackInfo<Value>& args,
    unsigned int offset,
    ScryptConfig* params) {
  Environment* env = Environment::GetCurrent(args);

  params->mode = mode;

  ArrayBufferOrViewContents<char> pass(args[offset]);
  ArrayBufferOrViewContents<char> salt(args[offset + 1]);

  if (UNLIKELY(!pass.CheckSizeInt32())) {
    THROW_ERR_OUT_OF_RANGE(env, ""pass is too large"");
    return Nothing<bool>();
  }

  if (UNLIKELY(!salt.CheckSizeInt32())) {
    THROW_ERR_OUT_OF_RANGE(env, ""salt is too large"");
    return Nothing<bool>();
  }

  params->pass = mode == kCryptoJobAsync
      ? pass.ToCopy()
      : pass.ToByteSource();

  params->salt = mode == kCryptoJobAsync
      ? salt.ToCopy()
      : salt.ToByteSource();

  CHECK(args[offset + 2]->IsUint32());  // N
  CHECK(args[offset + 3]->IsUint32());  // r
  CHECK(args[offset + 4]->IsUint32());  // p
  CHECK(args[offset + 5]->IsNumber());  // maxmem
  CHECK(args...",55.0,115.0,1.0,1.0,61.0,75,9,55,9,0,0,4,4,0,0,,0,0,8,4,4,Maybe<bool>
1750,54822,DeriveBits,1,node.crypto.ScryptTraits.DeriveBits,"bool node.crypto.ScryptTraits.DeriveBits (Environment*,ScryptConfig,ByteSource*)",crypto\crypto_scrypt.cc,"bool ScryptTraits::DeriveBits(
    Environment* env,
    const ScryptConfig& params,
    ByteSource* out) {
  ByteSource::Builder buf(params.length);

  // Both the pass and salt may be zero-length at this point

  if (!EVP_PBE_scrypt(params.pass.data<char>(),
                      params.pass.size(),
                      params.salt.data<unsigned char>(),
                      params.salt.size(),
                      params.N,
                      params.r,
                      params.p,
                      params.maxmem,
                      buf.data<unsigned char>(),
                      params.length)) {
    return false;
  }
  *out = std::move(buf).release();
  return true;
}",117.0,139.0,1.0,1.0,23.0,20,4,14,4,0,0,2,2,0,0,,0,0,6,3,3,bool
1751,54910,<lambda>0,1,"args, [](Sign* sign, const FunctionCallbackInfo<Value>& args, const char* data, size_t size) { Environment* env = Environment.GetCurrent(args); if (UNLIKELY(size > INT_MAX)) return THROW_ERR_OUT_OF_RANGE(env, ""data is too long""); Error err = sign->Update(data, size); crypto.CheckThrow(sign->env(), err); }.<lambda>0","ANY args, [](Sign* sign, const FunctionCallbackInfo<Value>& args, const char* data, size_t size) { Environment* env = Environment.GetCurrent(args); if (UNLIKELY(size > INT_MAX)) return THROW_ERR_OUT_OF_RANGE(env, ""data is too long""); Error err = sign->Update(data, size); crypto.CheckThrow(sign->env(), err); }.<lambda>0 (Sign*,FunctionCallbackInfo<Value>,char*,size_t)",crypto\crypto_sig.cc,"[](Sign* sign, const FunctionCallbackInfo<Value>& args,
                        const char* data, size_t size) {
    Environment* env = Environment::GetCurrent(args);
    if (UNLIKELY(size > INT_MAX))
      return THROW_ERR_OUT_OF_RANGE(env, ""data is too long"");
    Error err = sign->Update(data, size);
    crypto::CheckThrow(sign->env(), err);
  }",376.0,383.0,22.0,3.0,8.0,7,4,13,9,0,0,2,2,0,0,,0,0,8,4,4,ANY
1752,54957,<lambda>1,1,"args, [](Verify* verify, const FunctionCallbackInfo<Value>& args, const char* data, size_t size) { Environment* env = Environment.GetCurrent(args); if (UNLIKELY(size > INT_MAX)) return THROW_ERR_OUT_OF_RANGE(env, ""data is too long""); Error err = verify->Update(data, size); crypto.CheckThrow(verify->env(), err); }.<lambda>1","ANY args, [](Verify* verify, const FunctionCallbackInfo<Value>& args, const char* data, size_t size) { Environment* env = Environment.GetCurrent(args); if (UNLIKELY(size > INT_MAX)) return THROW_ERR_OUT_OF_RANGE(env, ""data is too long""); Error err = verify->Update(data, size); crypto.CheckThrow(verify->env(), err); }.<lambda>1 (Verify*,FunctionCallbackInfo<Value>,char*,size_t)",crypto\crypto_sig.cc,"[](Verify* verify,
                          const FunctionCallbackInfo<Value>& args,
                          const char* data, size_t size) {
    Environment* env = Environment::GetCurrent(args);
    if (UNLIKELY(size > INT_MAX))
      return THROW_ERR_OUT_OF_RANGE(env, ""data is too long"");
    Error err = verify->Update(data, size);
    crypto::CheckThrow(verify->env(), err);
  }",492.0,500.0,24.0,3.0,9.0,7,4,13,9,0,0,2,2,0,0,,0,0,8,4,4,ANY
1753,55029,ValidateDSAParameters,1,node.crypto.anonymous_namespace_1.ValidateDSAParameters,bool node.crypto.anonymous_namespace_1.ValidateDSAParameters (EVP_PKEY*),crypto\crypto_sig.cc,"bool ValidateDSAParameters(EVP_PKEY* key) {
  /* Validate DSA2 parameters from FIPS 186-4 */
#if OPENSSL_VERSION_MAJOR >= 3
  if (EVP_default_properties_is_fips_enabled(nullptr) &&
      EVP_PKEY_DSA == EVP_PKEY_base_id(key)) {
#else
  if (FIPS_mode() && EVP_PKEY_DSA == EVP_PKEY_base_id(key)) {
#endif
    const DSA* dsa = EVP_PKEY_get0_DSA(key);
    const BIGNUM* p;
    DSA_get0_pqg(dsa, &p, nullptr, nullptr);
    size_t L = BN_num_bits(p);
    const BIGNUM* q;
    DSA_get0_pqg(dsa, nullptr, &q, nullptr);
    size_t N = BN_num_bits(q);

    return (L == 1024 && N == 160) ||
           (L == 2048 && N == 224) ||
           (L == 2048 && N == 256) ||
           (L == 3072 && N == 256);
  }

  return true;
}",32.0,55.0,1.0,1.0,24.0,22,5,20,7,0,0,2,2,0,0,,0,0,2,1,1,bool
1754,55105,ApplyRSAOptions,1,node.crypto.anonymous_namespace_2.ApplyRSAOptions,"bool node.crypto.anonymous_namespace_2.ApplyRSAOptions (ManagedEVPPKey,EVP_PKEY_CTX*,int,Maybe<int>)",crypto\crypto_sig.cc,"bool ApplyRSAOptions(const ManagedEVPPKey& pkey,
                     EVP_PKEY_CTX* pkctx,
                     int padding,
                     const Maybe<int>& salt_len) {
  if (EVP_PKEY_id(pkey.get()) == EVP_PKEY_RSA ||
      EVP_PKEY_id(pkey.get()) == EVP_PKEY_RSA2 ||
      EVP_PKEY_id(pkey.get()) == EVP_PKEY_RSA_PSS) {
    if (EVP_PKEY_CTX_set_rsa_padding(pkctx, padding) <= 0)
      return false;
    if (padding == RSA_PKCS1_PSS_PADDING && salt_len.IsJust()) {
      if (EVP_PKEY_CTX_set_rsa_pss_saltlen(pkctx, salt_len.FromJust()) <= 0)
        return false;
    }
  }

  return true;
}",57.0,73.0,1.0,1.0,17.0,14,5,13,8,0,0,5,9,0,0,,0,0,8,4,4,bool
1755,55171,Node_SignFinal,1,node.crypto.anonymous_namespace_3.Node_SignFinal,"unique_ptr<BackingStore> node.crypto.anonymous_namespace_3.Node_SignFinal (Environment*,EVPMDPointer,ManagedEVPPKey,int,Maybe<int>)",crypto\crypto_sig.cc,"std::unique_ptr<BackingStore> Node_SignFinal(Environment* env,
                                             EVPMDPointer&& mdctx,
                                             const ManagedEVPPKey& pkey,
                                             int padding,
                                             Maybe<int> pss_salt_len) {
  unsigned char m[EVP_MAX_MD_SIZE];
  unsigned int m_len;

  if (!EVP_DigestFinal_ex(mdctx.get(), m, &m_len))
    return nullptr;

  int signed_sig_len = EVP_PKEY_size(pkey.get());
  CHECK_GE(signed_sig_len, 0);
  size_t sig_len = static_cast<size_t>(signed_sig_len);
  std::unique_ptr<BackingStore> sig;
  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    sig = ArrayBuffer::NewBackingStore(env->isolate(), sig_len);
  }
  EVPKeyCtxPointer pkctx(EVP_PKEY_CTX_new(pkey.get(), nullptr));
  if (pkctx &&
      EVP_PKEY_sign_init(pkctx.get()) &&
      ApplyRSAOptions(pkey, pkctx.get(), padding, pss_salt_len) &&
      EVP_PKEY_CTX_set_sig...",75.0,110.0,1.0,1.0,36.0,32,10,37,14,0,0,4,5,0,0,,0,0,10,5,5,unique_ptr<BackingStore>
1756,55334,GetDefaultSignPadding,1,node.crypto.anonymous_namespace_4.GetDefaultSignPadding,int node.crypto.anonymous_namespace_4.GetDefaultSignPadding (ManagedEVPPKey),crypto\crypto_sig.cc,"int GetDefaultSignPadding(const ManagedEVPPKey& m_pkey) {
  return EVP_PKEY_id(m_pkey.get()) == EVP_PKEY_RSA_PSS ? RSA_PKCS1_PSS_PADDING :
                                                         RSA_PKCS1_PADDING;
}",112.0,115.0,1.0,1.0,4.0,3,3,4,4,0,0,1,1,0,0,,0,0,2,1,1,int
1757,55350,GetBytesOfRS,1,node.crypto.anonymous_namespace_5.GetBytesOfRS,unsigned int node.crypto.anonymous_namespace_5.GetBytesOfRS (ManagedEVPPKey),crypto\crypto_sig.cc,"unsigned int GetBytesOfRS(const ManagedEVPPKey& pkey) {
  int bits, base_id = EVP_PKEY_base_id(pkey.get());

  if (base_id == EVP_PKEY_DSA) {
    const DSA* dsa_key = EVP_PKEY_get0_DSA(pkey.get());
    // Both r and s are computed mod q, so their width is limited by that of q.
    bits = BN_num_bits(DSA_get0_q(dsa_key));
  } else if (base_id == EVP_PKEY_EC) {
    const EC_KEY* ec_key = EVP_PKEY_get0_EC_KEY(pkey.get());
    const EC_GROUP* ec_group = EC_KEY_get0_group(ec_key);
    bits = EC_GROUP_order_bits(ec_group);
  } else {
    return kNoDsaSignature;
  }

  return (bits + 7) / 8;
}",117.0,133.0,1.0,1.0,17.0,8,5,9,5,0,0,2,2,0,0,,0,0,2,1,1,unsigned int
1758,55416,ExtractP1363,1,node.crypto.anonymous_namespace_6.ExtractP1363,"bool node.crypto.anonymous_namespace_6.ExtractP1363 (unsigned char*,unsigned char*,size_t,size_t)",crypto\crypto_sig.cc,"bool ExtractP1363(
    const unsigned char* sig_data,
    unsigned char* out,
    size_t len,
    size_t n) {
  ECDSASigPointer asn1_sig(d2i_ECDSA_SIG(nullptr, &sig_data, len));
  if (!asn1_sig)
    return false;

  const BIGNUM* pr = ECDSA_SIG_get0_r(asn1_sig.get());
  const BIGNUM* ps = ECDSA_SIG_get0_s(asn1_sig.get());

  return BN_bn2binpad(pr, out, n) > 0 && BN_bn2binpad(ps, out + n, n) > 0;
}",135.0,148.0,1.0,1.0,14.0,10,7,14,7,0,0,2,2,0,0,,0,0,8,4,4,bool
1759,55469,ConvertSignatureToP1363,1,node.crypto.anonymous_namespace_7.ConvertSignatureToP1363,"unique_ptr<BackingStore> node.crypto.anonymous_namespace_7.ConvertSignatureToP1363 (Environment*,ManagedEVPPKey,ANY)",crypto\crypto_sig.cc,"std::unique_ptr<BackingStore> ConvertSignatureToP1363(Environment* env,
    const ManagedEVPPKey& pkey, std::unique_ptr<BackingStore>&& signature) {
  unsigned int n = GetBytesOfRS(pkey);
  if (n == kNoDsaSignature)
    return std::move(signature);

  std::unique_ptr<BackingStore> buf;
  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    buf = ArrayBuffer::NewBackingStore(env->isolate(), 2 * n);
  }
  if (!ExtractP1363(static_cast<unsigned char*>(signature->Data()),
                    static_cast<unsigned char*>(buf->Data()),
                    signature->ByteLength(), n))
    return std::move(signature);

  return buf;
}",151.0,168.0,1.0,1.0,18.0,18,9,21,9,0,0,3,3,0,0,,0,0,6,3,3,unique_ptr<BackingStore>
1760,55548,ConvertSignatureToP1363,1,node.crypto.anonymous_namespace_9.ConvertSignatureToP1363,"ByteSource node.crypto.anonymous_namespace_9.ConvertSignatureToP1363 (Environment*,ManagedEVPPKey,ByteSource)",crypto\crypto_sig.cc,"ByteSource ConvertSignatureToP1363(
    Environment* env,
    const ManagedEVPPKey& pkey,
    const ByteSource& signature) {
  unsigned int n = GetBytesOfRS(pkey);
  if (n == kNoDsaSignature)
    return ByteSource();

  const unsigned char* sig_data = signature.data<unsigned char>();

  ByteSource::Builder out(n * 2);
  memset(out.data<void>(), 0, n * 2);

  if (!ExtractP1363(sig_data, out.data<unsigned char>(), signature.size(), n))
    return ByteSource();

  return std::move(out).release();
}",171.0,188.0,1.0,1.0,18.0,12,5,15,7,0,0,3,3,0,0,,0,0,6,3,3,ByteSource
1761,55613,ConvertSignatureToDER,1,node.crypto.anonymous_namespace_11.ConvertSignatureToDER,"ByteSource node.crypto.anonymous_namespace_11.ConvertSignatureToDER (ManagedEVPPKey,ByteSource)",crypto\crypto_sig.cc,"ByteSource ConvertSignatureToDER(
      const ManagedEVPPKey& pkey,
      ByteSource&& out) {
  unsigned int n = GetBytesOfRS(pkey);
  if (n == kNoDsaSignature)
    return std::move(out);

  const unsigned char* sig_data = out.data<unsigned char>();

  if (out.size() != 2 * n)
    return ByteSource();

  ECDSASigPointer asn1_sig(ECDSA_SIG_new());
  CHECK(asn1_sig);
  BIGNUM* r = BN_new();
  CHECK_NOT_NULL(r);
  BIGNUM* s = BN_new();
  CHECK_NOT_NULL(s);
  CHECK_EQ(r, BN_bin2bn(sig_data, n, r));
  CHECK_EQ(s, BN_bin2bn(sig_data + n, n, s));
  CHECK_EQ(1, ECDSA_SIG_set0(asn1_sig.get(), r, s));

  unsigned char* data = nullptr;
  int len = i2d_ECDSA_SIG(asn1_sig.get(), &data);

  if (len <= 0)
    return ByteSource();

  CHECK_NOT_NULL(data);

  return ByteSource::Allocated(data, len);
}",190.0,221.0,1.0,1.0,32.0,18,8,36,12,0,0,4,4,0,0,,0,0,4,2,2,ByteSource
1762,55724,CheckThrow,1,node.crypto.anonymous_namespace_13.CheckThrow,"void node.crypto.anonymous_namespace_13.CheckThrow (Environment*,ANY)",crypto\crypto_sig.cc,"void CheckThrow(Environment* env, SignBase::Error error) {
  HandleScope scope(env->isolate());

  switch (error) {
    case SignBase::Error::kSignUnknownDigest:
      return THROW_ERR_CRYPTO_INVALID_DIGEST(env);

    case SignBase::Error::kSignNotInitialised:
      return THROW_ERR_CRYPTO_INVALID_STATE(env, ""Not initialised"");

    case SignBase::Error::kSignMalformedSignature:
      return THROW_ERR_CRYPTO_OPERATION_FAILED(env, ""Malformed signature"");

    case SignBase::Error::kSignInit:
    case SignBase::Error::kSignUpdate:
    case SignBase::Error::kSignPrivateKey:
    case SignBase::Error::kSignPublicKey:
      {
        unsigned long err = ERR_get_error();  // NOLINT(runtime/int)
        if (err)
          return ThrowCryptoError(env, err);
        switch (error) {
          case SignBase::Error::kSignInit:
            return THROW_ERR_CRYPTO_OPERATION_FAILED(env,
                ""EVP_SignInit_ex failed"");
          case SignBase::Error::kSignUpdate:
            return THROW...",223.0,265.0,1.0,1.0,43.0,26,3,38,5,0,0,4,6,0,0,,0,0,4,2,2,void
1763,55856,IsOneShot,1,node.crypto.anonymous_namespace_14.IsOneShot,bool node.crypto.anonymous_namespace_14.IsOneShot (ManagedEVPPKey),crypto\crypto_sig.cc,"bool IsOneShot(const ManagedEVPPKey& key) {
  switch (EVP_PKEY_id(key.get())) {
    case EVP_PKEY_ED25519:
    case EVP_PKEY_ED448:
      return true;
    default:
      return false;
  }
}",267.0,275.0,1.0,1.0,9.0,1,1,3,3,0,0,2,2,0,0,,0,0,2,1,1,bool
1764,55877,UseP1363Encoding,1,node.crypto.anonymous_namespace_15.UseP1363Encoding,"bool node.crypto.anonymous_namespace_15.UseP1363Encoding (ManagedEVPPKey,DSASigEnc)",crypto\crypto_sig.cc,"bool UseP1363Encoding(const ManagedEVPPKey& key,
                      const DSASigEnc& dsa_encoding) {
  switch (EVP_PKEY_id(key.get())) {
    case EVP_PKEY_EC:
    case EVP_PKEY_DSA:
      return dsa_encoding == kSigEncP1363;
    default:
      return false;
  }
}",277.0,286.0,1.0,1.0,10.0,2,2,5,5,0,0,2,2,0,0,,0,0,4,2,2,bool
1765,55901,Init,1,node.crypto.SignBase.Init,Error node.crypto.SignBase.Init (char*),crypto\crypto_sig.cc,"SignBase::Error SignBase::Init(const char* sign_type) {
  CHECK_NULL(mdctx_);
  // Historically, ""dss1"" and ""DSS1"" were DSA aliases for SHA-1
  // exposed through the public API.
  if (strcmp(sign_type, ""dss1"") == 0 ||
      strcmp(sign_type, ""DSS1"") == 0) {
    sign_type = ""SHA1"";
  }
  const EVP_MD* md = EVP_get_digestbyname(sign_type);
  if (md == nullptr)
    return kSignUnknownDigest;

  mdctx_.reset(EVP_MD_CTX_new());
  if (!mdctx_ || !EVP_DigestInit_ex(mdctx_.get(), md, nullptr)) {
    mdctx_.reset();
    return kSignInit;
  }

  return kSignOk;
}",289.0,308.0,1.0,1.0,20.0,12,5,14,6,0,0,4,4,0,0,,0,0,2,1,1,Error
1766,55961,Update,1,node.crypto.SignBase.Update,"Error node.crypto.SignBase.Update (char*,size_t)",crypto\crypto_sig.cc,"SignBase::Error SignBase::Update(const char* data, size_t len) {
  if (mdctx_ == nullptr)
    return kSignNotInitialised;
  if (!EVP_DigestUpdate(mdctx_.get(), data, len))
    return kSignUpdate;
  return kSignOk;
}",310.0,316.0,1.0,1.0,7.0,3,3,7,6,0,0,3,3,0,0,,0,0,4,2,2,Error
1767,55988,SignBase,1,node.crypto.SignBase.SignBase,"ANY node.crypto.SignBase.SignBase (Environment*,Local<Object>)",crypto\crypto_sig.cc,"SignBase::SignBase(Environment* env, Local<Object> wrap)
    : BaseObject(env, wrap) {}",318.0,319.0,1.0,30.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,ANY
1768,55994,MemoryInfo,1,node.crypto.SignBase.MemoryInfo,void node.crypto.SignBase.MemoryInfo (MemoryTracker*),crypto\crypto_sig.cc,"void SignBase::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackFieldWithSize(""mdctx"", mdctx_ ? kSizeOf_EVP_MD_CTX : 0);
}",321.0,323.0,1.0,1.0,3.0,2,2,3,3,0,0,1,1,0,0,,0,0,2,1,1,void
1769,56008,Sign,1,node.crypto.Sign.Sign,"ANY node.crypto.Sign.Sign (Environment*,Local<Object>)",crypto\crypto_sig.cc,"Sign::Sign(Environment* env, Local<Object> wrap) : SignBase(env, wrap) {
  MakeWeak();
}",325.0,327.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,ANY
1770,56015,Initialize,1,node.crypto.Sign.Initialize,"void node.crypto.Sign.Initialize (Environment*,Local<Object>)",crypto\crypto_sig.cc,"void Sign::Initialize(Environment* env, Local<Object> target) {
  Isolate* isolate = env->isolate();
  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, New);

  t->InstanceTemplate()->SetInternalFieldCount(SignBase::kInternalFieldCount);

  SetProtoMethod(isolate, t, ""init"", SignInit);
  SetProtoMethod(isolate, t, ""update"", SignUpdate);
  SetProtoMethod(isolate, t, ""sign"", SignFinal);

  SetConstructorFunction(env->context(), target, ""Sign"", t);

  SignJob::Initialize(env, target);

  constexpr int kSignJobModeSign = SignConfiguration::kSign;
  constexpr int kSignJobModeVerify = SignConfiguration::kVerify;

  NODE_DEFINE_CONSTANT(target, kSignJobModeSign);
  NODE_DEFINE_CONSTANT(target, kSignJobModeVerify);
  NODE_DEFINE_CONSTANT(target, kSigEncDER);
  NODE_DEFINE_CONSTANT(target, kSigEncP1363);
  NODE_DEFINE_CONSTANT(target, RSA_PKCS1_PSS_PADDING);
}",329.0,351.0,1.0,1.0,23.0,14,5,38,18,0,0,1,1,0,0,,0,0,4,2,2,void
1771,56103,RegisterExternalReferences,1,node.crypto.Sign.RegisterExternalReferences,void node.crypto.Sign.RegisterExternalReferences (ExternalReferenceRegistry*),crypto\crypto_sig.cc,"void Sign::RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  registry->Register(New);
  registry->Register(SignInit);
  registry->Register(SignUpdate);
  registry->Register(SignFinal);
  SignJob::RegisterExternalReferences(registry);
}",353.0,359.0,1.0,1.0,7.0,5,2,10,6,0,0,1,1,0,0,,0,0,2,1,1,void
1772,56133,New,1,node.crypto.Sign.New,void node.crypto.Sign.New (FunctionCallbackInfo<Value>),crypto\crypto_sig.cc,"void Sign::New(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  new Sign(env, args.This());
}",361.0,364.0,1.0,1.0,4.0,4,3,6,4,0,0,1,1,0,0,,0,0,2,1,1,void
1773,56153,SignInit,1,node.crypto.Sign.SignInit,void node.crypto.Sign.SignInit (FunctionCallbackInfo<Value>),crypto\crypto_sig.cc,"void Sign::SignInit(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Sign* sign;
  ASSIGN_OR_RETURN_UNWRAP(&sign, args.Holder());

  const node::Utf8Value sign_type(args.GetIsolate(), args[0]);
  crypto::CheckThrow(env, sign->Init(*sign_type));
}",366.0,373.0,1.0,1.0,8.0,9,6,11,6,0,0,1,1,0,0,,0,0,2,1,1,void
1774,56194,SignUpdate,1,node.crypto.Sign.SignUpdate,void node.crypto.Sign.SignUpdate (FunctionCallbackInfo<Value>),crypto\crypto_sig.cc,"void Sign::SignUpdate(const FunctionCallbackInfo<Value>& args) {
  Decode<Sign>(args, [](Sign* sign, const FunctionCallbackInfo<Value>& args,
                        const char* data, size_t size) {
    Environment* env = Environment::GetCurrent(args);
    if (UNLIKELY(size > INT_MAX))
      return THROW_ERR_OUT_OF_RANGE(env, ""data is too long"");
    Error err = sign->Update(data, size);
    crypto::CheckThrow(sign->env(), err);
  });
}",375.0,384.0,1.0,1.0,10.0,4,4,3,3,0,0,1,1,0,0,,0,0,2,1,1,void
1775,56206,SignFinal,1,node.crypto.Sign.SignFinal,"SignResult node.crypto.Sign.SignFinal (ManagedEVPPKey,int,Maybe<int>,DSASigEnc)",crypto\crypto_sig.cc,"void Sign::SignFinal(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Sign* sign;
  ASSIGN_OR_RETURN_UNWRAP(&sign, args.Holder());

  ClearErrorOnReturn clear_error_on_return;

  unsigned int offset = 0;
  ManagedEVPPKey key = ManagedEVPPKey::GetPrivateKeyFromJs(args, &offset, true);
  if (!key)
    return;

  int padding = GetDefaultSignPadding(key);
  if (!args[offset]->IsUndefined()) {
    CHECK(args[offset]->IsInt32());
    padding = args[offset].As<Int32>()->Value();
  }

  Maybe<int> salt_len = Nothing<int>();
  if (!args[offset + 1]->IsUndefined()) {
    CHECK(args[offset + 1]->IsInt32());
    salt_len = Just<int>(args[offset + 1].As<Int32>()->Value());
  }

  CHECK(args[offset + 2]->IsInt32());
  DSASigEnc dsa_sig_enc =
      static_cast<DSASigEnc>(args[offset + 2].As<Int32>()->Value());

  SignResult ret = sign->SignFinal(
      key,
      padding,
      salt_len,
      dsa_sig_enc);

  if (ret.error != kSignOk)
    return cry...",409.0,450.0,1.0,1.0,42.0,19,9,31,14,0,0,4,4,0,0,,0,0,2,1,1,void
1776,56504,Verify,1,node.crypto.Verify.Verify,"ANY node.crypto.Verify.Verify (Environment*,Local<Object>)",crypto\crypto_sig.cc,"Verify::Verify(Environment* env, Local<Object> wrap)
  : SignBase(env, wrap) {
  MakeWeak();
}",452.0,455.0,1.0,1.0,4.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,ANY
1777,56511,Initialize,1,node.crypto.Verify.Initialize,"void node.crypto.Verify.Initialize (Environment*,Local<Object>)",crypto\crypto_sig.cc,"void Verify::Initialize(Environment* env, Local<Object> target) {
  Isolate* isolate = env->isolate();
  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, New);

  t->InstanceTemplate()->SetInternalFieldCount(SignBase::kInternalFieldCount);

  SetProtoMethod(isolate, t, ""init"", VerifyInit);
  SetProtoMethod(isolate, t, ""update"", VerifyUpdate);
  SetProtoMethod(isolate, t, ""verify"", VerifyFinal);

  SetConstructorFunction(env->context(), target, ""Verify"", t);
}",457.0,468.0,1.0,1.0,12.0,9,5,21,11,0,0,1,1,0,0,,0,0,4,2,2,void
1778,56566,RegisterExternalReferences,1,node.crypto.Verify.RegisterExternalReferences,void node.crypto.Verify.RegisterExternalReferences (ExternalReferenceRegistry*),crypto\crypto_sig.cc,"void Verify::RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  registry->Register(New);
  registry->Register(VerifyInit);
  registry->Register(VerifyUpdate);
  registry->Register(VerifyFinal);
}",470.0,475.0,1.0,1.0,6.0,4,1,8,5,0,0,1,1,0,0,,0,0,2,1,1,void
1779,56591,New,1,node.crypto.Verify.New,void node.crypto.Verify.New (FunctionCallbackInfo<Value>),crypto\crypto_sig.cc,"void Verify::New(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  new Verify(env, args.This());
}",477.0,480.0,1.0,1.0,4.0,4,3,6,4,0,0,1,1,0,0,,0,0,2,1,1,void
1780,56611,VerifyInit,1,node.crypto.Verify.VerifyInit,void node.crypto.Verify.VerifyInit (FunctionCallbackInfo<Value>),crypto\crypto_sig.cc,"void Verify::VerifyInit(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Verify* verify;
  ASSIGN_OR_RETURN_UNWRAP(&verify, args.Holder());

  const node::Utf8Value verify_type(args.GetIsolate(), args[0]);
  crypto::CheckThrow(env, verify->Init(*verify_type));
}",482.0,489.0,1.0,1.0,8.0,9,6,11,6,0,0,1,1,0,0,,0,0,2,1,1,void
1781,56652,VerifyUpdate,1,node.crypto.Verify.VerifyUpdate,void node.crypto.Verify.VerifyUpdate (FunctionCallbackInfo<Value>),crypto\crypto_sig.cc,"void Verify::VerifyUpdate(const FunctionCallbackInfo<Value>& args) {
  Decode<Verify>(args, [](Verify* verify,
                          const FunctionCallbackInfo<Value>& args,
                          const char* data, size_t size) {
    Environment* env = Environment::GetCurrent(args);
    if (UNLIKELY(size > INT_MAX))
      return THROW_ERR_OUT_OF_RANGE(env, ""data is too long"");
    Error err = verify->Update(data, size);
    crypto::CheckThrow(verify->env(), err);
  });
}",491.0,501.0,1.0,1.0,11.0,4,4,3,3,0,0,1,1,0,0,,0,0,2,1,1,void
1782,56664,VerifyFinal,1,node.crypto.Verify.VerifyFinal,"Error node.crypto.Verify.VerifyFinal (ManagedEVPPKey,ByteSource,int,Maybe<int>,bool*)",crypto\crypto_sig.cc,"void Verify::VerifyFinal(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  ClearErrorOnReturn clear_error_on_return;

  Verify* verify;
  ASSIGN_OR_RETURN_UNWRAP(&verify, args.Holder());

  unsigned int offset = 0;
  ManagedEVPPKey pkey =
      ManagedEVPPKey::GetPublicOrPrivateKeyFromJs(args, &offset);
  if (!pkey)
    return;

  ArrayBufferOrViewContents<char> hbuf(args[offset]);
  if (UNLIKELY(!hbuf.CheckSizeInt32()))
    return THROW_ERR_OUT_OF_RANGE(env, ""buffer is too big"");

  int padding = GetDefaultSignPadding(pkey);
  if (!args[offset + 1]->IsUndefined()) {
    CHECK(args[offset + 1]->IsInt32());
    padding = args[offset + 1].As<Int32>()->Value();
  }

  Maybe<int> salt_len = Nothing<int>();
  if (!args[offset + 2]->IsUndefined()) {
    CHECK(args[offset + 2]->IsInt32());
    salt_len = Just<int>(args[offset + 2].As<Int32>()->Value());
  }

  CHECK(args[offset + 3]->IsInt32());
  DSASigEnc dsa_sig_enc =
      static_cast<DSAS...",533.0,579.0,1.0,1.0,47.0,26,8,30,16,0,0,4,4,0,0,,0,0,2,1,1,void
1783,57007,SignConfiguration,1,node.crypto.SignConfiguration.SignConfiguration,ANY node.crypto.SignConfiguration.SignConfiguration (SignConfiguration),crypto\crypto_sig.cc,"SignConfiguration::SignConfiguration(SignConfiguration&& other) noexcept
    : job_mode(other.job_mode),
      mode(other.mode),
      key(std::move(other.key)),
      data(std::move(other.data)),
      signature(std::move(other.signature)),
      digest(other.digest),
      flags(other.flags),
      padding(other.padding),
      salt_length(other.salt_length),
      dsa_encoding(other.dsa_encoding) {}",581.0,591.0,1.0,41.0,11.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
1784,57012,operator =,1,node.crypto.SignConfiguration.operator =,SignConfiguration node.crypto.SignConfiguration.operator = (SignConfiguration),crypto\crypto_sig.cc,"SignConfiguration& SignConfiguration::operator=(
    SignConfiguration&& other) noexcept {
  if (&other == this) return *this;
  this->~SignConfiguration();
  return *new (this) SignConfiguration(std::move(other));
}",593.0,598.0,1.0,1.0,6.0,7,6,4,3,0,0,2,2,0,0,,0,0,2,1,1,SignConfiguration
1785,57040,MemoryInfo,1,node.crypto.SignConfiguration.MemoryInfo,void node.crypto.SignConfiguration.MemoryInfo (MemoryTracker*),crypto\crypto_sig.cc,"void SignConfiguration::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackField(""key"", key);
  if (job_mode == kCryptoJobAsync) {
    tracker->TrackFieldWithSize(""data"", data.size());
    tracker->TrackFieldWithSize(""signature"", signature.size());
  }
}",600.0,606.0,1.0,1.0,7.0,6,3,8,6,0,0,2,2,0,0,,0,0,2,1,1,void
1786,57074,AdditionalConfig,1,node.crypto.SignTraits.AdditionalConfig,"Maybe<bool> node.crypto.SignTraits.AdditionalConfig (CryptoJobMode,FunctionCallbackInfo<Value>,unsigned int,SignConfiguration*)",crypto\crypto_sig.cc,"Maybe<bool> SignTraits::AdditionalConfig(
    CryptoJobMode mode,
    const FunctionCallbackInfo<Value>& args,
    unsigned int offset,
    SignConfiguration* params) {
  ClearErrorOnReturn clear_error_on_return;
  Environment* env = Environment::GetCurrent(args);

  params->job_mode = mode;

  CHECK(args[offset]->IsUint32());  // Sign Mode

  params->mode =
      static_cast<SignConfiguration::Mode>(args[offset].As<Uint32>()->Value());

  ManagedEVPPKey key;
  unsigned int keyParamOffset = offset + 1;
  if (params->mode == SignConfiguration::kVerify) {
    key = ManagedEVPPKey::GetPublicOrPrivateKeyFromJs(args, &keyParamOffset);
  } else {
    key = ManagedEVPPKey::GetPrivateKeyFromJs(args, &keyParamOffset, true);
  }
  if (!key)
    return Nothing<bool>();
  params->key = key;

  ArrayBufferOrViewContents<char> data(args[offset + 5]);
  if (UNLIKELY(!data.CheckSizeInt32())) {
    THROW_ERR_OUT_OF_RANGE(env, ""data is too big"");
    return Nothing<bool>();
  }
  params->data = mode ...",608.0,692.0,1.0,1.0,85.0,97,13,78,17,0,0,13,17,0,0,,0,0,8,4,4,Maybe<bool>
1787,57433,DeriveBits,1,node.crypto.SignTraits.DeriveBits,"bool node.crypto.SignTraits.DeriveBits (Environment*,SignConfiguration,ByteSource*)",crypto\crypto_sig.cc,"bool SignTraits::DeriveBits(
    Environment* env,
    const SignConfiguration& params,
    ByteSource* out) {
  ClearErrorOnReturn clear_error_on_return;
  EVPMDPointer context(EVP_MD_CTX_new());
  EVP_PKEY_CTX* ctx = nullptr;

  switch (params.mode) {
    case SignConfiguration::kSign:
      if (!EVP_DigestSignInit(
              context.get(),
              &ctx,
              params.digest,
              nullptr,
              params.key.get())) {
        crypto::CheckThrow(env, SignBase::Error::kSignInit);
        return false;
      }
      break;
    case SignConfiguration::kVerify:
      if (!EVP_DigestVerifyInit(
              context.get(),
              &ctx,
              params.digest,
              nullptr,
              params.key.get())) {
        crypto::CheckThrow(env, SignBase::Error::kSignInit);
        return false;
      }
      break;
  }

  int padding = params.flags & SignConfiguration::kHasPadding
      ? params.padding
      : GetDefaultSignPadding(params....",694.0,808.0,1.0,1.0,115.0,89,9,73,14,0,0,13,18,0,0,,0,0,6,3,3,bool
1788,57872,EncodeOutput,1,node.crypto.SignTraits.EncodeOutput,"Maybe<bool> node.crypto.SignTraits.EncodeOutput (Environment*,SignConfiguration,ByteSource*,Local<Value>*)",crypto\crypto_sig.cc,"Maybe<bool> SignTraits::EncodeOutput(
    Environment* env,
    const SignConfiguration& params,
    ByteSource* out,
    Local<Value>* result) {
  switch (params.mode) {
    case SignConfiguration::kSign:
      *result = out->ToArrayBuffer(env);
      break;
    case SignConfiguration::kVerify:
      *result = Boolean::New(env->isolate(), out->data<char>()[0] == 1);
      break;
    default:
      UNREACHABLE();
  }
  return Just(!result->IsEmpty());
}",810.0,826.0,1.0,1.0,17.0,15,7,11,6,0,0,4,2,0,0,,0,0,8,4,4,Maybe<bool>
1789,57968,VerifySpkac,1,node.crypto.SPKAC.VerifySpkac,bool node.crypto.SPKAC.VerifySpkac (ArrayBufferOrViewContents<char>),crypto\crypto_spkac.cc,"void VerifySpkac(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  ArrayBufferOrViewContents<char> input(args[0]);
  if (input.size() == 0)
    return args.GetReturnValue().SetEmptyString();

  if (UNLIKELY(!input.CheckSizeInt32()))
    return THROW_ERR_OUT_OF_RANGE(env, ""spkac is too large"");

  args.GetReturnValue().Set(VerifySpkac(input));
}",39.0,49.0,1.0,1.0,11.0,10,5,9,4,0,0,3,3,0,0,,0,0,2,1,1,void
1790,58075,ExportPublicKey,1,node.crypto.SPKAC.ExportPublicKey,"ByteSource node.crypto.SPKAC.ExportPublicKey (Environment*,ArrayBufferOrViewContents<char>)",crypto\crypto_spkac.cc,"void ExportPublicKey(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  ArrayBufferOrViewContents<char> input(args[0]);
  if (input.size() == 0) return args.GetReturnValue().SetEmptyString();

  if (UNLIKELY(!input.CheckSizeInt32()))
    return THROW_ERR_OUT_OF_RANGE(env, ""spkac is too large"");

  ByteSource pkey = ExportPublicKey(env, input);
  if (!pkey) return args.GetReturnValue().SetEmptyString();

  args.GetReturnValue().Set(pkey.ToBuffer(env).FromMaybe(Local<Value>()));
}",75.0,88.0,1.0,1.0,14.0,11,4,12,6,0,0,5,5,0,0,,0,0,2,1,1,void
1791,58079,bio,1,node.crypto.SPKAC.ExportPublicKey.bio,BIOPointer node.crypto.SPKAC.ExportPublicKey.bio (BIO_new),crypto\crypto_spkac.cc,BIOPointer bio(BIO_new(BIO_s_mem()));,53.0,53.0,14.0,38.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,BIOPointer
1792,58227,ExportChallenge,1,node.crypto.SPKAC.ExportChallenge,ByteSource node.crypto.SPKAC.ExportChallenge (ArrayBufferOrViewContents<char>),crypto\crypto_spkac.cc,"void ExportChallenge(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  ArrayBufferOrViewContents<char> input(args[0]);
  if (input.size() == 0)
    return args.GetReturnValue().SetEmptyString();

  if (UNLIKELY(!input.CheckSizeInt32()))
    return THROW_ERR_OUT_OF_RANGE(env, ""spkac is too large"");

  ByteSource cert = ExportChallenge(input);
  if (!cert)
    return args.GetReturnValue().SetEmptyString();

  Local<Value> outString =
      Encode(env->isolate(), cert.data<char>(), cert.size(), BUFFER);

  args.GetReturnValue().Set(outString);
}",108.0,126.0,1.0,1.0,19.0,12,7,13,6,0,0,2,2,0,0,,0,0,2,1,1,void
1793,58371,Initialize,1,node.crypto.SPKAC.Initialize,"void node.crypto.SPKAC.Initialize (Environment*,Local<Object>)",crypto\crypto_spkac.cc,"void Initialize(Environment* env, Local<Object> target) {
  Local<Context> context = env->context();
  SetMethodNoSideEffect(context, target, ""certVerifySpkac"", VerifySpkac);
  SetMethodNoSideEffect(
      context, target, ""certExportPublicKey"", ExportPublicKey);
  SetMethodNoSideEffect(
      context, target, ""certExportChallenge"", ExportChallenge);
}",128.0,135.0,1.0,1.0,8.0,4,4,13,8,0,0,1,1,0,0,,0,0,4,2,2,void
1794,58402,RegisterExternalReferences,1,node.crypto.SPKAC.RegisterExternalReferences,void node.crypto.SPKAC.RegisterExternalReferences (ExternalReferenceRegistry*),crypto\crypto_spkac.cc,"void RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  registry->Register(VerifySpkac);
  registry->Register(ExportPublicKey);
  registry->Register(ExportChallenge);
}",137.0,141.0,1.0,1.0,5.0,3,1,6,4,0,0,1,1,0,0,,0,0,2,1,1,void
1795,58455,TimingSafeEqual,1,node.crypto.Timing.TimingSafeEqual,void node.crypto.Timing.TimingSafeEqual (FunctionCallbackInfo<Value>),crypto\crypto_timing.cc,"void TimingSafeEqual(const FunctionCallbackInfo<Value>& args) {
  // Moving the type checking into JS leads to test failures, most likely due
  // to V8 inlining certain parts of the wrapper. Therefore, keep them in C++.
  // Refs: https://github.com/nodejs/node/issues/34073.
  Environment* env = Environment::GetCurrent(args);
  if (!IsAnyByteSource(args[0])) {
    THROW_ERR_INVALID_ARG_TYPE(
      env, ""The \""buf1\"" argument must be an instance of ""
      ""ArrayBuffer, Buffer, TypedArray, or DataView."");
    return;
  }
  if (!IsAnyByteSource(args[1])) {
    THROW_ERR_INVALID_ARG_TYPE(
      env, ""The \""buf2\"" argument must be an instance of ""
      ""ArrayBuffer, Buffer, TypedArray, or DataView."");
    return;
  }

  ArrayBufferOrViewContents<char> buf1(args[0]);
  ArrayBufferOrViewContents<char> buf2(args[1]);

  if (buf1.size() != buf2.size()) {
    THROW_ERR_CRYPTO_TIMING_SAFE_EQUAL_LENGTH(env);
    return;
  }

  return args.GetReturnValue().Set(
      CRYPTO_memcmp(buf1.data()...",19.0,47.0,1.0,1.0,29.0,17,6,16,5,0,0,4,4,0,0,,0,0,2,1,1,void
1796,58537,Initialize,1,node.crypto.Timing.Initialize,"void node.crypto.Timing.Initialize (Environment*,Local<Object>)",crypto\crypto_timing.cc,"void Initialize(Environment* env, Local<Object> target) {
  SetMethodNoSideEffect(
      env->context(), target, ""timingSafeEqual"", TimingSafeEqual);
}",49.0,52.0,1.0,1.0,4.0,1,1,2,2,0,0,1,1,0,0,,0,0,4,2,2,void
1797,58551,RegisterExternalReferences,1,node.crypto.Timing.RegisterExternalReferences,void node.crypto.Timing.RegisterExternalReferences (ExternalReferenceRegistry*),crypto\crypto_timing.cc,"void RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  registry->Register(TimingSafeEqual);
}",53.0,55.0,1.0,1.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,void
1798,58571,<lambda>0,1,node.crypto.anonymous_namespace_12.GetBIOError.<lambda>0,"ANY node.crypto.anonymous_namespace_12.GetBIOError.<lambda>0 (char*,size_t,void*)",crypto\crypto_tls.cc,"[](const char* str, size_t len, void* opaque) {
        static_cast<std::string*>(opaque)->assign(str, len);
        return 0;
      }",309.0,312.0,7.0,7.0,4.0,2,2,3,3,0,0,1,1,0,0,,0,0,6,3,3,ANY
1799,58590,<lambda>1,1,node.crypto.TLSWrap.EncOut.<lambda>1,ANY node.crypto.TLSWrap.EncOut.<lambda>1 (Environment*),crypto\crypto_tls.cc,"[this, strong_ref](Environment* env) {
          InvokeQueued(0);
        }",591.0,593.0,29.0,9.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
1800,58598,<lambda>2,1,node.crypto.TLSWrap.EncOut.<lambda>2,ANY node.crypto.TLSWrap.EncOut.<lambda>2 (Environment*),crypto\crypto_tls.cc,"[this, strong_ref](Environment* env) {
      OnStreamAfterWrite(nullptr, 0);
    }",623.0,625.0,25.0,5.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
1801,58607,<lambda>3,1,node.crypto.TLSWrap.ClearOut.<lambda>3,ANY node.crypto.TLSWrap.ClearOut.<lambda>3 (char),crypto\crypto_tls.cc,[](char c) { return c == ' ' ? '_' : ToUpper(c); },769.0,769.0,26.0,75.0,1.0,2,2,2,1,0,0,1,1,0,0,,0,0,2,1,1,ANY
1802,58621,<lambda>4,1,node.crypto.TLSWrap.DoWrite.<lambda>4,ANY node.crypto.TLSWrap.DoWrite.<lambda>4 (Environment*),crypto\crypto_tls.cc,"[this, strong_ref](Environment* env) {
          OnStreamAfterWrite(WriteWrap::FromObject(current_empty_write_), 0);
        }",936.0,938.0,29.0,9.0,3.0,1,1,2,2,0,0,1,1,0,0,,0,0,2,1,1,ANY
1803,58634,<lambda>5,1,node.crypto.TLSWrap.EnableTrace.<lambda>5,"void node.crypto.TLSWrap.EnableTrace.<lambda>5 (int,int,int,void*,size_t,SSL*,void*)",crypto\crypto_tls.cc,"[](int write_p, int version, int
          content_type, const void* buf, size_t len, SSL* ssl, void* arg)
        -> void {
        // BIO_write(), etc., called by SSL_trace, may error. The error should
        // be ignored, trace is a ""best effort"", and its usually because stderr
        // is a non-blocking pipe, and its buffer has overflowed. Leaving errors
        // on the stack that can get picked up by later SSL_ calls causes
        // unwanted failures in SSL_ calls, so keep the error stack unchanged.
        MarkPopErrorOnReturn mark_pop_error_on_return;
        SSL_trace(write_p,  version, content_type, buf, len, ssl, arg);
    }",1165.0,1175.0,44.0,5.0,11.0,0,0,7,7,0,0,1,1,0,0,,0,0,14,7,7,void
1804,58687,GetSessionCallback,1,node.crypto.anonymous_namespace_1.GetSessionCallback,"SSL_SESSION node.crypto.anonymous_namespace_1.GetSessionCallback (SSL*,unsigned char*,int,int*)",crypto\crypto_tls.cc,"SSL_SESSION* GetSessionCallback(
    SSL* s,
    const unsigned char* key,
    int len,
    int* copy) {
  TLSWrap* w = static_cast<TLSWrap*>(SSL_get_app_data(s));
  *copy = 0;
  return w->ReleaseSession();
}",67.0,75.0,1.0,1.0,9.0,5,4,4,3,0,0,1,1,0,0,,0,0,8,4,4,SSL_SESSION
1805,58711,OnClientHello,1,node.crypto.anonymous_namespace_2.OnClientHello,"void node.crypto.anonymous_namespace_2.OnClientHello (void*,ANY)",crypto\crypto_tls.cc,"void OnClientHello(
    void* arg,
    const ClientHelloParser::ClientHello& hello) {
  TLSWrap* w = static_cast<TLSWrap*>(arg);
  Environment* env = w->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  Local<Object> hello_obj = Object::New(env->isolate());
  Local<String> servername = (hello.servername() == nullptr)
      ? String::Empty(env->isolate())
      : OneByteString(env->isolate(),
                      hello.servername(),
                      hello.servername_size());
  Local<Object> buf =
      Buffer::Copy(
          env,
          reinterpret_cast<const char*>(hello.session_id()),
          hello.session_size()).FromMaybe(Local<Object>());

  if ((buf.IsEmpty() ||
       hello_obj->Set(env->context(), env->session_id_string(), buf)
           .IsNothing()) ||
      hello_obj->Set(env->context(), env->servername_string(), servername)
          .IsNothing() ||
      hello_obj
          ->Set(env->context(),
           ...",77.0,112.0,1.0,1.0,36.0,53,10,48,13,0,0,2,2,0,0,,0,0,4,2,2,void
1806,58900,KeylogCallback,1,node.crypto.anonymous_namespace_3.KeylogCallback,"void node.crypto.anonymous_namespace_3.KeylogCallback (SSL*,char*)",crypto\crypto_tls.cc,"void KeylogCallback(const SSL* s, const char* line) {
  TLSWrap* w = static_cast<TLSWrap*>(SSL_get_app_data(s));
  Environment* env = w->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  const size_t size = strlen(line);
  Local<Value> line_bf = Buffer::Copy(env, line, 1 + size)
      .FromMaybe(Local<Value>());
  if (UNLIKELY(line_bf.IsEmpty()))
    return;

  char* data = Buffer::Data(line_bf);
  data[size] = '\n';
  w->MakeCallback(env->onkeylog_string(), 1, &line_bf);
}",114.0,129.0,1.0,1.0,16.0,21,9,24,10,0,0,2,2,0,0,,0,0,4,2,2,void
1807,58988,NewSessionCallback,1,node.crypto.anonymous_namespace_4.NewSessionCallback,"int node.crypto.anonymous_namespace_4.NewSessionCallback (SSL*,SSL_SESSION*)",crypto\crypto_tls.cc,"int NewSessionCallback(SSL* s, SSL_SESSION* sess) {
  TLSWrap* w = static_cast<TLSWrap*>(SSL_get_app_data(s));
  Environment* env = w->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  if (!w->has_session_callbacks())
    return 0;

  // Check if session is small enough to be stored
  int size = i2d_SSL_SESSION(sess, nullptr);
  if (UNLIKELY(size > SecureContext::kMaxSessionSize))
    return 0;

  // Serialize session
  Local<Object> session = Buffer::New(env, size).FromMaybe(Local<Object>());
  if (UNLIKELY(session.IsEmpty()))
    return 0;

  unsigned char* session_data =
      reinterpret_cast<unsigned char*>(Buffer::Data(session));

  CHECK_EQ(i2d_SSL_SESSION(sess, &session_data), size);

  unsigned int session_id_length;
  const unsigned char* session_id_data =
      SSL_SESSION_get_id(sess, &session_id_length);

  Local<Object> session_id = Buffer::Copy(
      env,
      reinterpret_cast<const char*>(session_id_data),
      s...",131.0,179.0,1.0,1.0,49.0,36,9,44,15,0,0,6,6,0,0,,0,0,4,2,2,int
1808,59152,SSLCertCallback,1,node.crypto.anonymous_namespace_5.SSLCertCallback,"int node.crypto.anonymous_namespace_5.SSLCertCallback (SSL*,void*)",crypto\crypto_tls.cc,"int SSLCertCallback(SSL* s, void* arg) {
  TLSWrap* w = static_cast<TLSWrap*>(SSL_get_app_data(s));

  if (!w->is_server() || !w->is_waiting_cert_cb())
    return 1;

  if (w->is_cert_cb_running())
    // Not an error. Suspend handshake with SSL_ERROR_WANT_X509_LOOKUP, and
    // handshake will continue after certcb is done.
    return -1;

  Environment* env = w->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());
  w->set_cert_cb_running();

  Local<Object> info = Object::New(env->isolate());

  const char* servername = GetServerName(s);
  Local<String> servername_str = (servername == nullptr)
      ? String::Empty(env->isolate())
      : OneByteString(env->isolate(), servername, strlen(servername));

  Local<Value> ocsp = Boolean::New(
      env->isolate(), SSL_get_tlsext_status_type(s) == TLSEXT_STATUSTYPE_ocsp);

  if (info->Set(env->context(), env->servername_string(), servername_str)
          .IsNothing() ||
      info->Set(env-...",181.0,217.0,1.0,1.0,37.0,50,12,48,14,0,0,4,4,0,0,,0,0,4,2,2,int
1809,59337,SelectALPNCallback,1,node.crypto.anonymous_namespace_6.SelectALPNCallback,"int node.crypto.anonymous_namespace_6.SelectALPNCallback (SSL*,unsigned char**,unsigned char*,unsigned char*,unsigned int,void*)",crypto\crypto_tls.cc,"int SelectALPNCallback(
    SSL* s,
    const unsigned char** out,
    unsigned char* outlen,
    const unsigned char* in,
    unsigned int inlen,
    void* arg) {
  TLSWrap* w = static_cast<TLSWrap*>(arg);
  const std::vector<unsigned char>& alpn_protos = w->alpn_protos_;

  if (alpn_protos.empty()) return SSL_TLSEXT_ERR_NOACK;

  int status = SSL_select_next_proto(const_cast<unsigned char**>(out),
                                     outlen,
                                     alpn_protos.data(),
                                     alpn_protos.size(),
                                     in,
                                     inlen);

  // Previous versions of Node.js returned SSL_TLSEXT_ERR_NOACK if no protocol
  // match was found. This would neither cause a fatal alert nor would it result
  // in a useful ALPN response as part of the Server Hello message.
  // We now return SSL_TLSEXT_ERR_ALERT_FATAL in that case as per Section 3.2
  // of RFC 7301, which causes a fatal no_...",219.0,245.0,1.0,1.0,27.0,11,6,17,12,0,0,2,2,0,0,,0,0,12,6,6,int
1810,59392,TLSExtStatusCallback,1,node.crypto.anonymous_namespace_7.TLSExtStatusCallback,"int node.crypto.anonymous_namespace_7.TLSExtStatusCallback (SSL*,void*)",crypto\crypto_tls.cc,"int TLSExtStatusCallback(SSL* s, void* arg) {
  TLSWrap* w = static_cast<TLSWrap*>(SSL_get_app_data(s));
  Environment* env = w->env();
  HandleScope handle_scope(env->isolate());

  if (w->is_client()) {
    // Incoming response
    Local<Value> arg;
    if (GetSSLOCSPResponse(env, s, Null(env->isolate())).ToLocal(&arg))
      w->MakeCallback(env->onocspresponse_string(), 1, &arg);

    // No async acceptance is possible, so always return 1 to accept the
    // response.  The listener for 'OCSPResponse' event has no control over
    // return value, but it can .destroy() the connection if the response is not
    // acceptable.
    return 1;
  }

  // Outgoing response
  Local<ArrayBufferView> obj =
      w->ocsp_response().FromMaybe(Local<ArrayBufferView>());
  if (UNLIKELY(obj.IsEmpty()))
    return SSL_TLSEXT_ERR_NOACK;

  size_t len = obj->ByteLength();

  // OpenSSL takes control of the pointer after accepting it
  unsigned char* data = MallocOpenSSL<unsigned char>(len);
  obj-...",247.0,283.0,1.0,1.0,37.0,26,8,35,12,0,0,5,6,0,0,,0,0,4,2,2,int
1811,59513,ConfigureSecureContext,1,node.crypto.anonymous_namespace_8.ConfigureSecureContext,void node.crypto.anonymous_namespace_8.ConfigureSecureContext (SecureContext*),crypto\crypto_tls.cc,"void ConfigureSecureContext(SecureContext* sc) {
  // OCSP stapling
  SSL_CTX_set_tlsext_status_cb(sc->ctx().get(), TLSExtStatusCallback);
  SSL_CTX_set_tlsext_status_arg(sc->ctx().get(), nullptr);
}",285.0,289.0,1.0,1.0,5.0,4,2,2,1,0,0,1,1,0,0,,0,0,2,1,1,void
1812,59536,Set,1,node.crypto.anonymous_namespace_10.Set,"bool node.crypto.anonymous_namespace_10.Set (Environment*,Local<Object>,Local<String>,char*,bool)",crypto\crypto_tls.cc,"inline bool Set(
    Environment* env,
    Local<Object> target,
    Local<String> name,
    const char* value,
    bool ignore_null = true) {
  if (value == nullptr)
    return ignore_null;
  return !target->Set(
      env->context(),
      name,
      OneByteString(env->isolate(), value))
          .IsNothing();
}",291.0,304.0,1.0,1.0,14.0,6,4,7,5,0,0,2,2,0,0,,0,0,10,5,5,bool
1813,59572,GetBIOError,1,node.crypto.anonymous_namespace_11.GetBIOError,string node.crypto.anonymous_namespace_11.GetBIOError (),crypto\crypto_tls.cc,"std::string GetBIOError() {
  std::string ret;
  ERR_print_errors_cb(
      [](const char* str, size_t len, void* opaque) {
        static_cast<std::string*>(opaque)->assign(str, len);
        return 0;
      },
      static_cast<void*>(&ret));
  return ret;
}",306.0,315.0,1.0,1.0,10.0,2,2,2,1,0,0,1,1,0,0,,0,0,0,0,0,string
1814,59585,TLSWrap,1,node.crypto.TLSWrap.TLSWrap,"ANY node.crypto.TLSWrap.TLSWrap (Environment*,Local<Object>,Kind,StreamBase*,SecureContext*)",crypto\crypto_tls.cc,"TLSWrap::TLSWrap(Environment* env,
                 Local<Object> obj,
                 Kind kind,
                 StreamBase* stream,
                 SecureContext* sc)
    : AsyncWrap(env, obj, AsyncWrap::PROVIDER_TLSWRAP),
      StreamBase(env),
      env_(env),
      kind_(kind),
      sc_(sc) {
  MakeWeak();
  CHECK(sc_);
  ssl_ = sc_->CreateSSL();
  CHECK(ssl_);

  sc_->SetGetSessionCallback(GetSessionCallback);
  sc_->SetNewSessionCallback(NewSessionCallback);

  StreamBase::AttachToObject(GetObject());
  stream->PushStreamListener(this);

  env_->isolate()->AdjustAmountOfExternalAllocatedMemory(kExternalSize);

  InitSSL();
  Debug(this, ""Created new TLSWrap"");
}",318.0,343.0,1.0,1.0,26.0,7,2,9,7,0,0,1,1,0,0,,0,0,10,5,5,ANY
1815,59631,~TLSWrap,1,node.crypto.TLSWrap.~TLSWrap,ANY node.crypto.TLSWrap.~TLSWrap (),crypto\crypto_tls.cc,"TLSWrap::~TLSWrap() {
  Destroy();
}",345.0,347.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
1816,59636,ocsp_response,1,node.crypto.TLSWrap.ocsp_response,MaybeLocal<ArrayBufferView> node.crypto.TLSWrap.ocsp_response (),crypto\crypto_tls.cc,"MaybeLocal<ArrayBufferView> TLSWrap::ocsp_response() const {
  if (ocsp_response_.IsEmpty())
    return MaybeLocal<ArrayBufferView>();
  return PersistentToLocal::Default(env()->isolate(), ocsp_response_);
}",349.0,353.0,1.0,1.0,5.0,3,2,3,2,0,0,2,2,0,0,,0,0,0,0,0,MaybeLocal<ArrayBufferView>
1817,59658,ClearOcspResponse,1,node.crypto.TLSWrap.ClearOcspResponse,void node.crypto.TLSWrap.ClearOcspResponse (),crypto\crypto_tls.cc,"void TLSWrap::ClearOcspResponse() {
  ocsp_response_.Reset();
}",355.0,357.0,1.0,1.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1818,59666,ReleaseSession,1,node.crypto.TLSWrap.ReleaseSession,SSL_SESSION node.crypto.TLSWrap.ReleaseSession (),crypto\crypto_tls.cc,"SSL_SESSION* TLSWrap::ReleaseSession() {
  return next_sess_.release();
}",359.0,361.0,1.0,1.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,SSL_SESSION
1819,59675,InvokeQueued,1,node.crypto.TLSWrap.InvokeQueued,"void node.crypto.TLSWrap.InvokeQueued (int,char*)",crypto\crypto_tls.cc,"void TLSWrap::InvokeQueued(int status, const char* error_str) {
  Debug(this, ""Invoking queued write callbacks (%d, %s)"", status, error_str);
  if (!write_callback_scheduled_)
    return;

  if (current_write_) {
    BaseObjectPtr<AsyncWrap> current_write = std::move(current_write_);
    current_write_.reset();
    WriteWrap* w = WriteWrap::FromObject(current_write);
    w->Done(status, error_str);
  }
}",363.0,374.0,1.0,1.0,12.0,9,6,16,10,0,0,3,3,0,0,,0,0,4,2,2,void
1820,59723,NewSessionDoneCb,1,node.crypto.TLSWrap.NewSessionDoneCb,void node.crypto.TLSWrap.NewSessionDoneCb (),crypto\crypto_tls.cc,"void TLSWrap::NewSessionDoneCb() {
  Debug(this, ""New session callback done"");
  Cycle();
}",376.0,379.0,1.0,1.0,4.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
1821,59731,InitSSL,1,node.crypto.TLSWrap.InitSSL,void node.crypto.TLSWrap.InitSSL (),crypto\crypto_tls.cc,"void TLSWrap::InitSSL() {
  // Initialize SSL  OpenSSL takes ownership of these.
  enc_in_ = NodeBIO::New(env()).release();
  enc_out_ = NodeBIO::New(env()).release();

  SSL_set_bio(ssl_.get(), enc_in_, enc_out_);

  // NOTE: This could be overridden in SetVerifyMode
  SSL_set_verify(ssl_.get(), SSL_VERIFY_NONE, VerifyCallback);

#ifdef SSL_MODE_RELEASE_BUFFERS
  SSL_set_mode(ssl_.get(), SSL_MODE_RELEASE_BUFFERS);
#endif  // SSL_MODE_RELEASE_BUFFERS

  // This is default in 1.1.1, but set it anyway, Cycle() doesn't currently
  // re-call ClearIn() if SSL_read() returns SSL_ERROR_WANT_READ, so data can be
  // left sitting in the incoming enc_in_ and never get processed.
  // - https://wiki.openssl.org/index.php/TLS1.3#Non-application_data_records
  SSL_set_mode(ssl_.get(), SSL_MODE_AUTO_RETRY);

#ifdef OPENSSL_IS_BORINGSSL
  // OpenSSL allows renegotiation by default, but BoringSSL disables it.
  // Configure BoringSSL to match OpenSSL's behavior.
  SSL_set_renegotiate_mode(ssl_.g...",381.0,432.0,1.0,1.0,52.0,15,3,21,11,0,0,3,3,0,0,,0,0,0,0,0,void
1822,59837,Wrap,1,node.crypto.TLSWrap.Wrap,void node.crypto.TLSWrap.Wrap (FunctionCallbackInfo<Value>),crypto\crypto_tls.cc,"void TLSWrap::Wrap(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  CHECK_EQ(args.Length(), 3);
  CHECK(args[0]->IsObject());
  CHECK(args[1]->IsObject());
  CHECK(args[2]->IsBoolean());

  Local<Object> sc = args[1].As<Object>();
  Kind kind = args[2]->IsTrue() ? Kind::kServer : Kind::kClient;

  StreamBase* stream = StreamBase::FromObject(args[0].As<Object>());
  CHECK_NOT_NULL(stream);

  Local<Object> obj;
  if (!env->tls_wrap_constructor_function()
           ->NewInstance(env->context())
           .ToLocal(&obj)) {
    return;
  }

  TLSWrap* res = new TLSWrap(env, obj, kind, stream, Unwrap<SecureContext>(sc));

  args.GetReturnValue().Set(res->object());
}",434.0,458.0,1.0,1.0,25.0,39,10,36,15,0,0,2,2,0,0,,0,0,2,1,1,void
1823,59970,Receive,1,node.crypto.TLSWrap.Receive,void node.crypto.TLSWrap.Receive (FunctionCallbackInfo<Value>),crypto\crypto_tls.cc,"void TLSWrap::Receive(const FunctionCallbackInfo<Value>& args) {
  TLSWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  ArrayBufferViewContents<char> buffer(args[0]);
  const char* data = buffer.data();
  size_t len = buffer.length();
  Debug(wrap, ""Receiving %zu bytes injected from JS"", len);

  // Copy given buffer entirely or partiall if handle becomes closed
  while (len > 0 && wrap->IsAlive() && !wrap->IsClosing()) {
    uv_buf_t buf = wrap->OnStreamAlloc(len);
    size_t copy = buf.len > len ? len : buf.len;
    memcpy(buf.base, data, copy);
    buf.len = copy;
    wrap->OnStreamRead(copy, buf);

    data += copy;
    len -= copy;
  }
}",460.0,480.0,1.0,1.0,21.0,26,11,32,7,0,0,2,2,0,0,,0,0,2,1,1,void
1824,60066,Start,1,node.crypto.TLSWrap.Start,void node.crypto.TLSWrap.Start (FunctionCallbackInfo<Value>),crypto\crypto_tls.cc,"void TLSWrap::Start(const FunctionCallbackInfo<Value>& args) {
  TLSWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  CHECK(!wrap->started_);
  wrap->started_ = true;

  // Send ClientHello handshake
  CHECK(wrap->is_client());
  // Seems odd to read when when we want to send, but SSL_read() triggers a
  // handshake if a session isn't established, and handshake will cause
  // encrypted data to become available for output.
  wrap->ClearOut();
  wrap->EncOut();
}",482.0,496.0,1.0,1.0,15.0,9,5,7,2,0,0,1,1,0,0,,0,0,2,1,1,void
1825,60102,SSLInfoCallback,1,node.crypto.TLSWrap.SSLInfoCallback,"void node.crypto.TLSWrap.SSLInfoCallback (SSL*,int,int)",crypto\crypto_tls.cc,"void TLSWrap::SSLInfoCallback(const SSL* ssl_, int where, int ret) {
  if (!(where & (SSL_CB_HANDSHAKE_START | SSL_CB_HANDSHAKE_DONE)))
    return;

  // SSL_renegotiate_pending() should take `const SSL*`, but it does not.
  SSL* ssl = const_cast<SSL*>(ssl_);
  TLSWrap* c = static_cast<TLSWrap*>(SSL_get_app_data(ssl_));
  Environment* env = c->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());
  Local<Object> object = c->object();

  if (where & SSL_CB_HANDSHAKE_START) {
    Debug(c, ""SSLInfoCallback(SSL_CB_HANDSHAKE_START);"");
    // Start is tracked to limit number and frequency of renegotiation attempts,
    // since excessive renegotiation may be an attack.
    Local<Value> callback;

    if (object->Get(env->context(), env->onhandshakestart_string())
            .ToLocal(&callback) && callback->IsFunction()) {
      Local<Value> argv[] = { env->GetNow() };
      c->MakeCallback(callback.As<Function>(), arraysize(argv), argv);
    ...",498.0,538.0,1.0,1.0,41.0,47,12,48,13,0,0,6,8,0,0,,0,0,6,3,3,void
1826,60276,EncOut,1,node.crypto.TLSWrap.EncOut,void node.crypto.TLSWrap.EncOut (),crypto\crypto_tls.cc,"void TLSWrap::EncOut() {
  Debug(this, ""Trying to write encrypted output"");

  // Ignore cycling data if ClientHello wasn't yet parsed
  if (!hello_parser_.IsEnded()) {
    Debug(this, ""Returning from EncOut(), hello_parser_ active"");
    return;
  }

  // Write in progress
  if (write_size_ != 0) {
    Debug(this, ""Returning from EncOut(), write currently in progress"");
    return;
  }

  // Wait for `newSession` callback to be invoked
  if (is_awaiting_new_session()) {
    Debug(this, ""Returning from EncOut(), awaiting new session"");
    return;
  }

  // Split-off queue
  if (established_ && current_write_) {
    Debug(this, ""EncOut() write is scheduled"");
    write_callback_scheduled_ = true;
  }

  if (ssl_ == nullptr) {
    Debug(this, ""Returning from EncOut(), ssl_ == nullptr"");
    return;
  }

  // No encrypted output ready to write to the underlying stream.
  if (BIO_pending(enc_out_) == 0) {
    Debug(this, ""No pending encrypted output"");
    if (!pending_cleartext_input_...",540.0,627.0,1.0,1.0,88.0,34,12,32,17,0,0,12,15,0,0,,0,0,0,0,0,void
1827,60484,OnStreamAfterWrite,1,node.crypto.TLSWrap.OnStreamAfterWrite,"void node.crypto.TLSWrap.OnStreamAfterWrite (WriteWrap*,int)",crypto\crypto_tls.cc,"void TLSWrap::OnStreamAfterWrite(WriteWrap* req_wrap, int status) {
  Debug(this, ""OnStreamAfterWrite(status = %d)"", status);
  if (current_empty_write_) {
    Debug(this, ""Had empty write"");
    BaseObjectPtr<AsyncWrap> current_empty_write =
        std::move(current_empty_write_);
    current_empty_write_.reset();
    WriteWrap* finishing = WriteWrap::FromObject(current_empty_write);
    finishing->Done(status);
    return;
  }

  if (ssl_ == nullptr) {
    Debug(this, ""ssl_ == nullptr, marking as cancelled"");
    status = UV_ECANCELED;
  }

  // Handle error
  if (status) {
    if (shutdown_) {
      Debug(this, ""Ignoring error after shutdown"");
      return;
    }

    // Notify about error
    InvokeQueued(status);
    return;
  }

  // Commit
  NodeBIO::FromBIO(enc_out_)->Read(nullptr, write_size_);

  // Ensure that the progress will be made and `InvokeQueued` will be called.
  ClearIn();

  // Try writing more data
  write_size_ = 0;
  EncOut();
}",629.0,667.0,1.0,1.0,39.0,13,6,23,14,0,0,5,6,0,0,,0,0,4,2,2,void
1828,60568,ClearOut,1,node.crypto.TLSWrap.ClearOut,void node.crypto.TLSWrap.ClearOut (),crypto\crypto_tls.cc,"void TLSWrap::ClearOut() {
  Debug(this, ""Trying to read cleartext output"");
  // Ignore cycling data if ClientHello wasn't yet parsed
  if (!hello_parser_.IsEnded()) {
    Debug(this, ""Returning from ClearOut(), hello_parser_ active"");
    return;
  }

  // No reads after EOF
  if (eof_) {
    Debug(this, ""Returning from ClearOut(), EOF reached"");
    return;
  }

  if (ssl_ == nullptr) {
    Debug(this, ""Returning from ClearOut(), ssl_ == nullptr"");
    return;
  }

  MarkPopErrorOnReturn mark_pop_error_on_return;

  char out[kClearOutChunkSize];
  int read;
  for (;;) {
    read = SSL_read(ssl_.get(), out, sizeof(out));
    Debug(this, ""Read %d bytes of cleartext output"", read);

    if (read <= 0)
      break;

    char* current = out;
    while (read > 0) {
      int avail = read;

      uv_buf_t buf = EmitAlloc(avail);
      if (static_cast<int>(buf.len) < avail)
        avail = buf.len;
      memcpy(buf.base, current, avail);
      EmitRead(avail, buf);

      // Caveat empto...",669.0,787.0,1.0,1.0,119.0,74,16,87,30,0,0,21,41,0,0,,0,0,0,0,0,void
1829,60926,ClearIn,1,node.crypto.TLSWrap.ClearIn,void node.crypto.TLSWrap.ClearIn (),crypto\crypto_tls.cc,"void TLSWrap::ClearIn() {
  Debug(this, ""Trying to write cleartext input"");
  // Ignore cycling data if ClientHello wasn't yet parsed
  if (!hello_parser_.IsEnded()) {
    Debug(this, ""Returning from ClearIn(), hello_parser_ active"");
    return;
  }

  if (ssl_ == nullptr) {
    Debug(this, ""Returning from ClearIn(), ssl_ == nullptr"");
    return;
  }

  if (!pending_cleartext_input_ ||
      pending_cleartext_input_->ByteLength() == 0) {
    Debug(this, ""Returning from ClearIn(), no pending data"");
    return;
  }

  std::unique_ptr<BackingStore> bs = std::move(pending_cleartext_input_);
  MarkPopErrorOnReturn mark_pop_error_on_return;

  NodeBIO::FromBIO(enc_out_)->set_allocate_tls_hint(bs->ByteLength());
  int written = SSL_write(ssl_.get(), bs->Data(), bs->ByteLength());
  Debug(this, ""Writing %zu bytes, written = %d"", bs->ByteLength(), written);
  CHECK(written == -1 || written == static_cast<int>(bs->ByteLength()));

  // All written
  if (written != -1) {
    Debug(this, ""Su...",789.0,837.0,1.0,1.0,49.0,37,11,35,14,0,0,6,6,0,0,,0,0,0,0,0,void
1830,61084,diagnostic_name,1,node.crypto.TLSWrap.diagnostic_name,string node.crypto.TLSWrap.diagnostic_name (),crypto\crypto_tls.cc,"std::string TLSWrap::diagnostic_name() const {
  std::string name = ""TLSWrap "";
  name += is_server() ? ""server ("" : ""client ("";
  name += std::to_string(static_cast<int64_t>(get_async_id())) + "")"";
  return name;
}",839.0,844.0,1.0,1.0,6.0,7,6,5,2,0,0,1,1,0,0,,0,0,0,0,0,string
1831,61111,GetAsyncWrap,1,node.crypto.TLSWrap.GetAsyncWrap,AsyncWrap node.crypto.TLSWrap.GetAsyncWrap (),crypto\crypto_tls.cc,"AsyncWrap* TLSWrap::GetAsyncWrap() {
  return static_cast<AsyncWrap*>(this);
}",846.0,848.0,1.0,1.0,3.0,1,1,0,0,0,0,1,1,0,0,,0,0,0,0,0,AsyncWrap
1832,61119,IsIPCPipe,1,node.crypto.TLSWrap.IsIPCPipe,bool node.crypto.TLSWrap.IsIPCPipe (),crypto\crypto_tls.cc,"bool TLSWrap::IsIPCPipe() {
  return underlying_stream()->IsIPCPipe();
}",850.0,852.0,1.0,1.0,3.0,1,1,0,0,0,0,1,1,0,0,,0,0,0,0,0,bool
1833,61128,GetFD,1,node.crypto.TLSWrap.GetFD,int node.crypto.TLSWrap.GetFD (),crypto\crypto_tls.cc,"int TLSWrap::GetFD() {
  return underlying_stream()->GetFD();
}",854.0,856.0,1.0,1.0,3.0,1,1,0,0,0,0,1,1,0,0,,0,0,0,0,0,int
1834,61137,IsAlive,1,node.crypto.TLSWrap.IsAlive,bool node.crypto.TLSWrap.IsAlive (),crypto\crypto_tls.cc,"bool TLSWrap::IsAlive() {
  return ssl_ &&
      underlying_stream() != nullptr &&
      underlying_stream()->IsAlive();
}",858.0,862.0,1.0,1.0,5.0,4,3,1,1,0,0,1,1,0,0,,0,0,0,0,0,bool
1835,61152,IsClosing,1,node.crypto.TLSWrap.IsClosing,bool node.crypto.TLSWrap.IsClosing (),crypto\crypto_tls.cc,"bool TLSWrap::IsClosing() {
  return underlying_stream()->IsClosing();
}",864.0,866.0,1.0,1.0,3.0,1,1,0,0,0,0,1,1,0,0,,0,0,0,0,0,bool
1836,61161,ReadStart,1,node.crypto.TLSWrap.ReadStart,int node.crypto.TLSWrap.ReadStart (),crypto\crypto_tls.cc,"int TLSWrap::ReadStart() {
  Debug(this, ""ReadStart()"");
  if (underlying_stream() != nullptr && !eof_)
    return underlying_stream()->ReadStart();
  return 0;
}",868.0,873.0,1.0,1.0,6.0,4,4,1,1,0,0,2,2,0,0,,0,0,0,0,0,int
1837,61183,ReadStop,1,node.crypto.TLSWrap.ReadStop,int node.crypto.TLSWrap.ReadStop (),crypto\crypto_tls.cc,"int TLSWrap::ReadStop() {
  Debug(this, ""ReadStop()"");
  return underlying_stream() != nullptr ? underlying_stream()->ReadStop() : 0;
}",875.0,878.0,1.0,1.0,4.0,3,3,0,0,0,0,1,1,0,0,,0,0,0,0,0,int
1838,61200,Error,1,node.crypto.TLSWrap.Error,const char* node.crypto.TLSWrap.Error (),crypto\crypto_tls.cc,"const char* TLSWrap::Error() const {
  return error_.empty() ? nullptr : error_.c_str();
}",880.0,882.0,1.0,1.0,3.0,3,2,2,1,0,0,1,1,0,0,,0,0,0,0,0,const char*
1839,61215,ClearError,1,node.crypto.TLSWrap.ClearError,void node.crypto.TLSWrap.ClearError (),crypto\crypto_tls.cc,"void TLSWrap::ClearError() {
  error_.clear();
}",884.0,886.0,1.0,1.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
1840,61223,DoWrite,1,node.crypto.TLSWrap.DoWrite,"int node.crypto.TLSWrap.DoWrite (WriteWrap*,uv_buf_t*,size_t,uv_stream_t*)",crypto\crypto_tls.cc,"int TLSWrap::DoWrite(WriteWrap* w,
                     uv_buf_t* bufs,
                     size_t count,
                     uv_stream_t* send_handle) {
  CHECK_NULL(send_handle);
  Debug(this, ""DoWrite()"");

  if (ssl_ == nullptr) {
    ClearError();
    error_ = ""Write after DestroySSL"";
    return UV_EPROTO;
  }

  size_t length = 0;
  size_t i;
  size_t nonempty_i = 0;
  size_t nonempty_count = 0;
  for (i = 0; i < count; i++) {
    length += bufs[i].len;
    if (bufs[i].len > 0) {
      nonempty_i = i;
      nonempty_count += 1;
    }
  }

  // We want to trigger a Write() on the underlying stream to drive the stream
  // system, but don't want to encrypt empty buffers into a TLS frame, so see
  // if we can find something to Write().
  // First, call ClearOut(). It does an SSL_read(), which might cause handshake
  // or other internal messages to be encrypted. If it does, write them later
  // with EncOut().
  // If there is still no encrypted output, call Write(bufs) on th...",890.0,1021.0,1.0,1.0,132.0,80,15,85,29,0,0,12,18,0,0,,0,0,8,4,4,int
1841,61614,OnStreamAlloc,1,node.crypto.TLSWrap.OnStreamAlloc,uv_buf_t node.crypto.TLSWrap.OnStreamAlloc (size_t),crypto\crypto_tls.cc,"uv_buf_t TLSWrap::OnStreamAlloc(size_t suggested_size) {
  CHECK_NOT_NULL(ssl_);

  size_t size = suggested_size;
  char* base = NodeBIO::FromBIO(enc_in_)->PeekWritable(&size);
  return uv_buf_init(base, size);
}",1023.0,1029.0,1.0,1.0,7.0,5,4,8,5,0,0,1,1,0,0,,0,0,2,1,1,uv_buf_t
1842,61641,OnStreamRead,1,node.crypto.TLSWrap.OnStreamRead,"void node.crypto.TLSWrap.OnStreamRead (ssize_t,uv_buf_t)",crypto\crypto_tls.cc,"void TLSWrap::OnStreamRead(ssize_t nread, const uv_buf_t& buf) {
  Debug(this, ""Read %zd bytes from underlying stream"", nread);

  // Ignore everything after close_notify (rfc5246#section-7.2.1)
  if (eof_)
    return;

  if (nread < 0)  {
    // Error should be emitted only after all data was read
    ClearOut();

    if (nread == UV_EOF) {
      // underlying stream already should have also called ReadStop on itself
      eof_ = true;
    }

    EmitRead(nread);
    return;
  }

  // DestroySSL() is the only thing that un-sets ssl_, but that also removes
  // this TLSWrap as a stream listener, so we should not receive OnStreamRead()
  // calls anymore.
  CHECK(ssl_);

  // Commit the amount of data actually read into the peeked/allocated buffer
  // from the underlying stream.
  NodeBIO* enc_in = NodeBIO::FromBIO(enc_in_);
  enc_in->Commit(nread);

  // Parse ClientHello first, if we need to. It's only parsed if session event
  // listeners are used on the server side.  ""ended"" is...",1031.0,1075.0,1.0,1.0,45.0,16,8,23,9,0,0,5,6,0,0,,0,0,4,2,2,void
1843,61727,CreateShutdownWrap,1,node.crypto.TLSWrap.CreateShutdownWrap,ShutdownWrap node.crypto.TLSWrap.CreateShutdownWrap (Local<Object>),crypto\crypto_tls.cc,"ShutdownWrap* TLSWrap::CreateShutdownWrap(Local<Object> req_wrap_object) {
  return underlying_stream()->CreateShutdownWrap(req_wrap_object);
}",1077.0,1079.0,1.0,1.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,ShutdownWrap
1844,61738,DoShutdown,1,node.crypto.TLSWrap.DoShutdown,int node.crypto.TLSWrap.DoShutdown (ShutdownWrap*),crypto\crypto_tls.cc,"int TLSWrap::DoShutdown(ShutdownWrap* req_wrap) {
  Debug(this, ""DoShutdown()"");
  MarkPopErrorOnReturn mark_pop_error_on_return;

  if (ssl_ && SSL_shutdown(ssl_.get()) == 0)
    SSL_shutdown(ssl_.get());

  shutdown_ = true;
  EncOut();
  return underlying_stream()->DoShutdown(req_wrap);
}",1081.0,1091.0,1.0,1.0,11.0,6,5,5,3,0,0,2,2,0,0,,0,0,2,1,1,int
1845,61773,SetVerifyMode,1,node.crypto.TLSWrap.SetVerifyMode,void node.crypto.TLSWrap.SetVerifyMode (FunctionCallbackInfo<Value>),crypto\crypto_tls.cc,"void TLSWrap::SetVerifyMode(const FunctionCallbackInfo<Value>& args) {
  TLSWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  CHECK_EQ(args.Length(), 2);
  CHECK(args[0]->IsBoolean());
  CHECK(args[1]->IsBoolean());
  CHECK_NOT_NULL(wrap->ssl_);

  int verify_mode;
  if (wrap->is_server()) {
    bool request_cert = args[0]->IsTrue();
    if (!request_cert) {
      // If no cert is requested, there will be none to reject as unauthorized.
      verify_mode = SSL_VERIFY_NONE;
    } else {
      bool reject_unauthorized = args[1]->IsTrue();
      verify_mode = SSL_VERIFY_PEER;
      if (reject_unauthorized)
        verify_mode |= SSL_VERIFY_FAIL_IF_NO_PEER_CERT;
    }
  } else {
    // Servers always send a cert if the cipher is not anonymous (anon is
    // disabled by default), so use VERIFY_NONE and check the cert after the
    // handshake has completed.
    verify_mode = SSL_VERIFY_NONE;
  }

  // Always allow a connection. We'll reject in javascript.
  SSL_set_verify...",1093.0,1123.0,1.0,1.0,31.0,16,6,15,6,0,0,3,4,0,0,,0,0,2,1,1,void
1846,61867,EnableSessionCallbacks,1,node.crypto.TLSWrap.EnableSessionCallbacks,void node.crypto.TLSWrap.EnableSessionCallbacks (FunctionCallbackInfo<Value>),crypto\crypto_tls.cc,"void TLSWrap::EnableSessionCallbacks(const FunctionCallbackInfo<Value>& args) {
  TLSWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
  CHECK_NOT_NULL(wrap->ssl_);
  wrap->enable_session_callbacks();

  // Clients don't use the HelloParser.
  if (wrap->is_client())
    return;

  NodeBIO::FromBIO(wrap->enc_in_)->set_initial(kMaxHelloLength);
  wrap->hello_parser_.Start(OnClientHello,
                            OnClientHelloParseEnd,
                            wrap);
}",1125.0,1139.0,1.0,1.0,15.0,10,3,12,6,0,0,2,2,0,0,,0,0,2,1,1,void
1847,61915,EnableKeylogCallback,1,node.crypto.TLSWrap.EnableKeylogCallback,void node.crypto.TLSWrap.EnableKeylogCallback (FunctionCallbackInfo<Value>),crypto\crypto_tls.cc,"void TLSWrap::EnableKeylogCallback(const FunctionCallbackInfo<Value>& args) {
  TLSWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
  CHECK(wrap->sc_);
  wrap->sc_->SetKeylogCallback(KeylogCallback);
}",1141.0,1146.0,1.0,1.0,6.0,5,3,5,3,0,0,1,1,0,0,,0,0,2,1,1,void
1848,61939,EnableTrace,1,node.crypto.TLSWrap.EnableTrace,void node.crypto.TLSWrap.EnableTrace (FunctionCallbackInfo<Value>),crypto\crypto_tls.cc,"void TLSWrap::EnableTrace(const FunctionCallbackInfo<Value>& args) {
  TLSWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

#if HAVE_SSL_TRACE
  if (wrap->ssl_) {
    wrap->bio_trace_.reset(BIO_new_fp(stderr,  BIO_NOCLOSE | BIO_FP_TEXT));
    SSL_set_msg_callback(wrap->ssl_.get(), [](int write_p, int version, int
          content_type, const void* buf, size_t len, SSL* ssl, void* arg)
        -> void {
        // BIO_write(), etc., called by SSL_trace, may error. The error should
        // be ignored, trace is a ""best effort"", and its usually because stderr
        // is a non-blocking pipe, and its buffer has overflowed. Leaving errors
        // on the stack that can get picked up by later SSL_ calls causes
        // unwanted failures in SSL_ calls, so keep the error stack unchanged.
        MarkPopErrorOnReturn mark_pop_error_on_return;
        SSL_trace(write_p,  version, content_type, buf, len, ssl, arg);
    });
    SSL_set_msg_callback_arg(wrap->ssl_.get(), wra...",1158.0,1179.0,1.0,4.0,22.0,12,4,10,5,0,0,2,2,0,0,,0,0,2,1,1,void
1849,61989,DestroySSL,1,node.crypto.TLSWrap.DestroySSL,void node.crypto.TLSWrap.DestroySSL (FunctionCallbackInfo<Value>),crypto\crypto_tls.cc,"void TLSWrap::DestroySSL(const FunctionCallbackInfo<Value>& args) {
  TLSWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
  wrap->Destroy();
  Debug(wrap, ""DestroySSL() finished"");
}",1181.0,1186.0,1.0,1.0,6.0,3,3,4,2,0,0,1,1,0,0,,0,0,2,1,1,void
1850,62009,Destroy,1,node.crypto.TLSWrap.Destroy,void node.crypto.TLSWrap.Destroy (),crypto\crypto_tls.cc,"void TLSWrap::Destroy() {
  if (!ssl_)
    return;

  // If there is a write happening, mark it as finished.
  write_callback_scheduled_ = true;

  // And destroy
  InvokeQueued(UV_ECANCELED, ""Canceled because of SSL destruction"");

  env()->isolate()->AdjustAmountOfExternalAllocatedMemory(-kExternalSize);
  ssl_.reset();

  enc_in_ = nullptr;
  enc_out_ = nullptr;

  if (underlying_stream() != nullptr)
    underlying_stream()->RemoveStreamListener(this);

  sc_.reset();
}",1188.0,1208.0,1.0,1.0,21.0,11,6,8,7,0,0,3,3,0,0,,0,0,0,0,0,void
1851,62057,EnableCertCb,1,node.crypto.TLSWrap.EnableCertCb,void node.crypto.TLSWrap.EnableCertCb (FunctionCallbackInfo<Value>),crypto\crypto_tls.cc,"void TLSWrap::EnableCertCb(const FunctionCallbackInfo<Value>& args) {
  TLSWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
  wrap->WaitForCertCb(OnClientHelloParseEnd, wrap);
}",1210.0,1214.0,1.0,1.0,5.0,3,3,5,3,0,0,1,1,0,0,,0,0,2,1,1,void
1852,62076,WaitForCertCb,1,node.crypto.TLSWrap.WaitForCertCb,"void node.crypto.TLSWrap.WaitForCertCb (CertCb,void*)",crypto\crypto_tls.cc,"void TLSWrap::WaitForCertCb(CertCb cb, void* arg) {
  cert_cb_ = cb;
  cert_cb_arg_ = arg;
}",1216.0,1219.0,1.0,1.0,4.0,2,1,4,4,0,0,1,1,0,0,,0,0,4,2,2,void
1853,62088,OnClientHelloParseEnd,1,node.crypto.TLSWrap.OnClientHelloParseEnd,void node.crypto.TLSWrap.OnClientHelloParseEnd (void*),crypto\crypto_tls.cc,"void TLSWrap::OnClientHelloParseEnd(void* arg) {
  TLSWrap* c = static_cast<TLSWrap*>(arg);
  Debug(c, ""OnClientHelloParseEnd()"");
  c->Cycle();
}",1221.0,1225.0,1.0,1.0,5.0,3,3,4,2,0,0,1,1,0,0,,0,0,2,1,1,void
1854,62106,GetServername,1,node.crypto.TLSWrap.GetServername,void node.crypto.TLSWrap.GetServername (FunctionCallbackInfo<Value>),crypto\crypto_tls.cc,"void TLSWrap::GetServername(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  TLSWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  CHECK_NOT_NULL(wrap->ssl_);

  const char* servername = GetServerName(wrap->ssl_.get());
  if (servername != nullptr) {
    args.GetReturnValue().Set(OneByteString(env->isolate(), servername));
  } else {
    args.GetReturnValue().Set(false);
  }
}",1227.0,1241.0,1.0,1.0,15.0,12,5,12,5,0,0,2,2,0,0,,0,0,2,1,1,void
1855,62169,SetServername,1,node.crypto.TLSWrap.SetServername,void node.crypto.TLSWrap.SetServername (FunctionCallbackInfo<Value>),crypto\crypto_tls.cc,"void TLSWrap::SetServername(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  TLSWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsString());
  CHECK(!wrap->started_);
  CHECK(wrap->is_client());

  CHECK(wrap->ssl_);

  Utf8Value servername(env->isolate(), args[0].As<String>());
  SSL_set_tlsext_host_name(wrap->ssl_.get(), *servername);
}",1243.0,1258.0,1.0,1.0,16.0,17,7,14,5,0,0,1,1,0,0,,0,0,2,1,1,void
1856,62238,SelectSNIContextCallback,1,node.crypto.TLSWrap.SelectSNIContextCallback,"int node.crypto.TLSWrap.SelectSNIContextCallback (SSL*,int*,void*)",crypto\crypto_tls.cc,"int TLSWrap::SelectSNIContextCallback(SSL* s, int* ad, void* arg) {
  TLSWrap* p = static_cast<TLSWrap*>(SSL_get_app_data(s));
  Environment* env = p->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  const char* servername = GetServerName(s);
  if (!Set(env, p->GetOwner(), env->servername_string(), servername))
    return SSL_TLSEXT_ERR_NOACK;

  Local<Value> ctx = p->object()->Get(env->context(), env->sni_context_string())
      .FromMaybe(Local<Value>());

  if (UNLIKELY(ctx.IsEmpty()) || !ctx->IsObject())
    return SSL_TLSEXT_ERR_NOACK;

  if (!env->secure_context_constructor_template()->HasInstance(ctx)) {
    // Failure: incorrect SNI context object
    Local<Value> err = Exception::TypeError(env->sni_context_err_string());
    p->MakeCallback(env->onerror_string(), 1, &err);
    return SSL_TLSEXT_ERR_NOACK;
  }

  SecureContext* sc = Unwrap<SecureContext>(ctx.As<Object>());
  CHECK_NOT_NULL(sc);
  p->sni_context_ = BaseObje...",1260.0,1292.0,1.0,1.0,33.0,48,9,49,15,0,0,4,4,0,0,,0,0,6,3,3,int
1857,62423,SetCACerts,1,node.crypto.TLSWrap.SetCACerts,int node.crypto.TLSWrap.SetCACerts (SecureContext*),crypto\crypto_tls.cc,"int TLSWrap::SetCACerts(SecureContext* sc) {
  int err = SSL_set1_verify_cert_store(ssl_.get(),
                                       SSL_CTX_get_cert_store(sc->ctx().get()));
  if (err != 1)
    return err;

  STACK_OF(X509_NAME)* list =
      SSL_dup_CA_list(SSL_CTX_get_client_CA_list(sc->ctx().get()));

  // NOTE: `SSL_set_client_CA_list` takes the ownership of `list`
  SSL_set_client_CA_list(ssl_.get(), list);
  return 1;
}",1294.0,1306.0,1.0,1.0,13.0,10,5,10,5,0,0,2,2,0,0,,0,0,2,1,1,int
1858,62473,SetPskIdentityHint,1,node.crypto.TLSWrap.SetPskIdentityHint,void node.crypto.TLSWrap.SetPskIdentityHint (FunctionCallbackInfo<Value>),crypto\crypto_tls.cc,"void TLSWrap::SetPskIdentityHint(const FunctionCallbackInfo<Value>& args) {
  TLSWrap* p;
  ASSIGN_OR_RETURN_UNWRAP(&p, args.Holder());
  CHECK_NOT_NULL(p->ssl_);

  Environment* env = p->env();
  Isolate* isolate = env->isolate();

  CHECK(args[0]->IsString());
  Utf8Value hint(isolate, args[0].As<String>());

  if (!SSL_use_psk_identity_hint(p->ssl_.get(), *hint)) {
    Local<Value> err = node::ERR_TLS_PSK_SET_IDENTIY_HINT_FAILED(isolate);
    p->MakeCallback(env->onerror_string(), 1, &err);
  }
}",1310.0,1325.0,1.0,1.0,16.0,22,9,20,9,0,0,2,2,0,0,,0,0,2,1,1,void
1859,62554,EnablePskCallback,1,node.crypto.TLSWrap.EnablePskCallback,void node.crypto.TLSWrap.EnablePskCallback (FunctionCallbackInfo<Value>),crypto\crypto_tls.cc,"void TLSWrap::EnablePskCallback(const FunctionCallbackInfo<Value>& args) {
  TLSWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
  CHECK_NOT_NULL(wrap->ssl_);

  SSL_set_psk_server_callback(wrap->ssl_.get(), PskServerCallback);
  SSL_set_psk_client_callback(wrap->ssl_.get(), PskClientCallback);
}",1327.0,1334.0,1.0,1.0,8.0,7,3,7,4,0,0,1,1,0,0,,0,0,2,1,1,void
1860,62587,PskServerCallback,1,node.crypto.TLSWrap.PskServerCallback,"unsigned int node.crypto.TLSWrap.PskServerCallback (SSL*,char*,unsigned char*,unsigned int)",crypto\crypto_tls.cc,"unsigned int TLSWrap::PskServerCallback(
    SSL* s,
    const char* identity,
    unsigned char* psk,
    unsigned int max_psk_len) {
  TLSWrap* p = static_cast<TLSWrap*>(SSL_get_app_data(s));

  Environment* env = p->env();
  HandleScope scope(env->isolate());

  Local<String> identity_str =
      String::NewFromUtf8(env->isolate(), identity).FromMaybe(Local<String>());
  if (UNLIKELY(identity_str.IsEmpty()))
    return 0;

  // Make sure there are no utf8 replacement symbols.
  Utf8Value identity_utf8(env->isolate(), identity_str);
  if (identity_utf8 != identity) return 0;

  Local<Value> argv[] = {
    identity_str,
    Integer::NewFromUnsigned(env->isolate(), max_psk_len)
  };

  Local<Value> psk_val =
      p->MakeCallback(env->onpskexchange_symbol(), arraysize(argv), argv)
          .FromMaybe(Local<Value>());
  if (UNLIKELY(psk_val.IsEmpty()) || !psk_val->IsArrayBufferView())
    return 0;

  ArrayBufferViewContents<char> psk_buf(psk_val);

  if (psk_buf.length() > max_psk_...",1336.0,1373.0,1.0,1.0,38.0,33,10,37,15,0,0,5,5,0,0,,0,0,8,4,4,unsigned int
1861,62735,PskClientCallback,1,node.crypto.TLSWrap.PskClientCallback,"unsigned int node.crypto.TLSWrap.PskClientCallback (SSL*,char*,char*,unsigned int,unsigned char*,unsigned int)",crypto\crypto_tls.cc,"unsigned int TLSWrap::PskClientCallback(
    SSL* s,
    const char* hint,
    char* identity,
    unsigned int max_identity_len,
    unsigned char* psk,
    unsigned int max_psk_len) {
  TLSWrap* p = static_cast<TLSWrap*>(SSL_get_app_data(s));

  Environment* env = p->env();
  HandleScope scope(env->isolate());

  Local<Value> argv[] = {
    Null(env->isolate()),
    Integer::NewFromUnsigned(env->isolate(), max_psk_len),
    Integer::NewFromUnsigned(env->isolate(), max_identity_len)
  };

  if (hint != nullptr) {
    Local<String> local_hint =
        String::NewFromUtf8(env->isolate(), hint).FromMaybe(Local<String>());
    if (UNLIKELY(local_hint.IsEmpty()))
      return 0;

    argv[0] = local_hint;
  }

  Local<Value> ret =
      p->MakeCallback(env->onpskexchange_symbol(), arraysize(argv), argv)
          .FromMaybe(Local<Value>());
  if (UNLIKELY(ret.IsEmpty()) || !ret->IsObject())
    return 0;

  Local<Object> obj = ret.As<Object>();

  Local<Value> psk_val = obj->Get(env->c...",1375.0,1433.0,1.0,1.0,59.0,68,12,66,21,0,0,8,9,0,0,,0,0,12,6,6,unsigned int
1862,63003,GetWriteQueueSize,1,node.crypto.TLSWrap.GetWriteQueueSize,void node.crypto.TLSWrap.GetWriteQueueSize (FunctionCallbackInfo<Value>),crypto\crypto_tls.cc,"void TLSWrap::GetWriteQueueSize(const FunctionCallbackInfo<Value>& info) {
  TLSWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, info.This());

  if (!wrap->ssl_)
    return info.GetReturnValue().Set(0);

  uint32_t write_queue_size = BIO_pending(wrap->enc_out_);
  info.GetReturnValue().Set(write_queue_size);
}",1437.0,1446.0,1.0,1.0,10.0,10,5,8,3,0,0,2,2,0,0,,0,0,2,1,1,void
1863,63046,MemoryInfo,1,node.crypto.TLSWrap.MemoryInfo,void node.crypto.TLSWrap.MemoryInfo (MemoryTracker*),crypto\crypto_tls.cc,"void TLSWrap::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackField(""ocsp_response"", ocsp_response_);
  tracker->TrackField(""sni_context"", sni_context_);
  tracker->TrackField(""error"", error_);
  if (pending_cleartext_input_)
    tracker->TrackField(""pending_cleartext_input"", pending_cleartext_input_);
  if (enc_in_ != nullptr)
    tracker->TrackField(""enc_in"", NodeBIO::FromBIO(enc_in_));
  if (enc_out_ != nullptr)
    tracker->TrackField(""enc_out"", NodeBIO::FromBIO(enc_out_));
}",1448.0,1458.0,1.0,1.0,11.0,10,3,17,8,0,0,4,4,0,0,,0,0,2,1,1,void
1864,63108,CertCbDone,1,node.crypto.TLSWrap.CertCbDone,void node.crypto.TLSWrap.CertCbDone (FunctionCallbackInfo<Value>),crypto\crypto_tls.cc,"void TLSWrap::CertCbDone(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());

  CHECK(w->is_waiting_cert_cb() && w->cert_cb_running_);

  Local<Object> object = w->object();
  Local<Value> ctx = object->Get(env->context(), env->sni_context_string())
      .FromMaybe(Local<Value>());
  if (UNLIKELY(ctx.IsEmpty()))
    return;

  Local<FunctionTemplate> cons = env->secure_context_constructor_template();
  if (cons->HasInstance(ctx)) {
    SecureContext* sc = Unwrap<SecureContext>(ctx.As<Object>());
    CHECK_NOT_NULL(sc);
    // Store the SNI context for later use.
    w->sni_context_ = BaseObjectPtr<SecureContext>(sc);

    if (UseSNIContext(w->ssl_, w->sni_context_) && !w->SetCACerts(sc)) {
      // Not clear why sometimes we throw error, and sometimes we call
      // onerror(). Both cause .destroy(), but onerror does a bit more.
      unsigned long err = ERR_get_error();  // NOLI...",1460.0,1504.0,1.0,1.0,45.0,48,8,48,18,0,0,4,5,0,0,,0,0,2,1,1,void
1865,63305,SetALPNProtocols,1,node.crypto.TLSWrap.SetALPNProtocols,void node.crypto.TLSWrap.SetALPNProtocols (FunctionCallbackInfo<Value>),crypto\crypto_tls.cc,"void TLSWrap::SetALPNProtocols(const FunctionCallbackInfo<Value>& args) {
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
  Environment* env = w->env();
  if (args.Length() < 1 || !Buffer::HasInstance(args[0]))
    return env->ThrowTypeError(""Must give a Buffer as first argument"");

  ArrayBufferViewContents<uint8_t> protos(args[0].As<ArrayBufferView>());
  SSL* ssl = w->ssl_.get();
  if (w->is_client()) {
    CHECK_EQ(0, SSL_set_alpn_protos(ssl, protos.data(), protos.length()));
  } else {
    w->alpn_protos_ = std::vector<unsigned char>(
        protos.data(), protos.data() + protos.length());
    SSL_CTX_set_alpn_select_cb(SSL_get_SSL_CTX(ssl), SelectALPNCallback, w);
  }
}",1506.0,1522.0,1.0,1.0,17.0,21,9,17,8,0,0,3,3,0,0,,0,0,2,1,1,void
1866,63414,GetPeerCertificate,1,node.crypto.TLSWrap.GetPeerCertificate,void node.crypto.TLSWrap.GetPeerCertificate (FunctionCallbackInfo<Value>),crypto\crypto_tls.cc,"void TLSWrap::GetPeerCertificate(const FunctionCallbackInfo<Value>& args) {
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
  Environment* env = w->env();

  bool abbreviated = args.Length() < 1 || !args[0]->IsTrue();

  Local<Value> ret;
  if (GetPeerCert(
          env,
          w->ssl_,
          abbreviated,
          w->is_server()).ToLocal(&ret))
    args.GetReturnValue().Set(ret);
}",1524.0,1538.0,1.0,1.0,15.0,19,9,17,7,0,0,2,2,0,0,,0,0,2,1,1,void
1867,63481,GetPeerX509Certificate,1,node.crypto.TLSWrap.GetPeerX509Certificate,void node.crypto.TLSWrap.GetPeerX509Certificate (FunctionCallbackInfo<Value>),crypto\crypto_tls.cc,"void TLSWrap::GetPeerX509Certificate(const FunctionCallbackInfo<Value>& args) {
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
  Environment* env = w->env();

  X509Certificate::GetPeerCertificateFlag flag = w->is_server()
      ? X509Certificate::GetPeerCertificateFlag::SERVER
      : X509Certificate::GetPeerCertificateFlag::NONE;

  Local<Value> ret;
  if (X509Certificate::GetPeerCert(env, w->ssl_, flag).ToLocal(&ret))
    args.GetReturnValue().Set(ret);
}",1540.0,1552.0,1.0,1.0,13.0,19,7,20,9,0,0,2,2,0,0,,0,0,2,1,1,void
1868,63548,GetCertificate,1,node.crypto.TLSWrap.GetCertificate,void node.crypto.TLSWrap.GetCertificate (FunctionCallbackInfo<Value>),crypto\crypto_tls.cc,"void TLSWrap::GetCertificate(const FunctionCallbackInfo<Value>& args) {
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
  Environment* env = w->env();

  Local<Value> ret;
  if (GetCert(env, w->ssl_).ToLocal(&ret))
    args.GetReturnValue().Set(ret);
}",1554.0,1562.0,1.0,1.0,9.0,11,6,12,6,0,0,2,2,0,0,,0,0,2,1,1,void
1869,63593,GetX509Certificate,1,node.crypto.TLSWrap.GetX509Certificate,void node.crypto.TLSWrap.GetX509Certificate (FunctionCallbackInfo<Value>),crypto\crypto_tls.cc,"void TLSWrap::GetX509Certificate(const FunctionCallbackInfo<Value>& args) {
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
  Environment* env = w->env();
  Local<Value> ret;
  if (X509Certificate::GetCert(env, w->ssl_).ToLocal(&ret))
    args.GetReturnValue().Set(ret);
}",1564.0,1571.0,1.0,1.0,8.0,12,6,13,7,0,0,2,2,0,0,,0,0,2,1,1,void
1870,63641,GetFinished,1,node.crypto.TLSWrap.GetFinished,void node.crypto.TLSWrap.GetFinished (FunctionCallbackInfo<Value>),crypto\crypto_tls.cc,"void TLSWrap::GetFinished(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());

  // We cannot just pass nullptr to SSL_get_finished()
  // because it would further be propagated to memcpy(),
  // where the standard requirements as described in ISO/IEC 9899:2011
  // sections 7.21.2.1, 7.21.1.2, and 7.1.4, would be violated.
  // Thus, we use a dummy byte.
  char dummy[1];
  size_t len = SSL_get_finished(w->ssl_.get(), dummy, sizeof dummy);
  if (len == 0)
    return;

  std::unique_ptr<BackingStore> bs;
  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), len);
  }

  CHECK_EQ(bs->ByteLength(),
           SSL_get_finished(w->ssl_.get(), bs->Data(), bs->ByteLength()));

  Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(bs));
  Local<Value> buffer;
  if (!Buffer::New(env, ab, 0, ab->ByteL...",1573.0,1602.0,1.0,1.0,30.0,36,9,39,15,0,0,3,3,0,0,,0,0,2,1,1,void
1871,63779,GetPeerFinished,1,node.crypto.TLSWrap.GetPeerFinished,void node.crypto.TLSWrap.GetPeerFinished (FunctionCallbackInfo<Value>),crypto\crypto_tls.cc,"void TLSWrap::GetPeerFinished(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());

  // We cannot just pass nullptr to SSL_get_peer_finished()
  // because it would further be propagated to memcpy(),
  // where the standard requirements as described in ISO/IEC 9899:2011
  // sections 7.21.2.1, 7.21.1.2, and 7.1.4, would be violated.
  // Thus, we use a dummy byte.
  char dummy[1];
  size_t len = SSL_get_peer_finished(w->ssl_.get(), dummy, sizeof dummy);
  if (len == 0)
    return;

  std::unique_ptr<BackingStore> bs;
  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), len);
  }

  CHECK_EQ(bs->ByteLength(),
           SSL_get_peer_finished(w->ssl_.get(), bs->Data(), bs->ByteLength()));

  Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(bs));
  Local<Value> buffer;
  if (!Buffer::New(en...",1604.0,1633.0,1.0,1.0,30.0,36,9,39,15,0,0,3,3,0,0,,0,0,2,1,1,void
1872,63917,GetSession,1,node.crypto.TLSWrap.GetSession,void node.crypto.TLSWrap.GetSession (FunctionCallbackInfo<Value>),crypto\crypto_tls.cc,"void TLSWrap::GetSession(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());

  SSL_SESSION* sess = SSL_get_session(w->ssl_.get());
  if (sess == nullptr)
    return;

  int slen = i2d_SSL_SESSION(sess, nullptr);
  if (slen <= 0)
    return;  // Invalid or malformed session.

  std::unique_ptr<BackingStore> bs;
  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), slen);
  }

  unsigned char* p = static_cast<unsigned char*>(bs->Data());
  CHECK_LT(0, i2d_SSL_SESSION(sess, &p));

  Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(bs));
  Local<Value> buffer;
  if (!Buffer::New(env, ab, 0, ab->ByteLength()).ToLocal(&buffer)) return;
  args.GetReturnValue().Set(buffer);
}",1635.0,1662.0,1.0,1.0,28.0,36,10,40,16,0,0,4,4,0,0,,0,0,2,1,1,void
1873,64058,SetSession,1,node.crypto.TLSWrap.SetSession,void node.crypto.TLSWrap.SetSession (FunctionCallbackInfo<Value>),crypto\crypto_tls.cc,"void TLSWrap::SetSession(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());

  if (args.Length() < 1)
    return THROW_ERR_MISSING_ARGS(env, ""Session argument is mandatory"");

  THROW_AND_RETURN_IF_NOT_BUFFER(env, args[0], ""Session"");
  ArrayBufferViewContents<unsigned char> sbuf(args[0]);
  SSLSessionPointer sess = GetTLSSession(sbuf.data(), sbuf.length());
  if (sess == nullptr)
    return;  // TODO(tniessen): figure out error handling

  if (!SetTLSSession(w->ssl_, sess))
    return env->ThrowError(""SSL_set_session error"");
}",1664.0,1681.0,1.0,1.0,18.0,15,8,17,6,0,0,4,4,0,0,,0,0,2,1,1,void
1874,64134,IsSessionReused,1,node.crypto.TLSWrap.IsSessionReused,void node.crypto.TLSWrap.IsSessionReused (FunctionCallbackInfo<Value>),crypto\crypto_tls.cc,"void TLSWrap::IsSessionReused(const FunctionCallbackInfo<Value>& args) {
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
  bool yes = SSL_session_reused(w->ssl_.get());
  args.GetReturnValue().Set(yes);
}",1683.0,1688.0,1.0,1.0,6.0,7,4,6,3,0,0,1,1,0,0,,0,0,2,1,1,void
1875,64165,VerifyError,1,node.crypto.TLSWrap.VerifyError,void node.crypto.TLSWrap.VerifyError (FunctionCallbackInfo<Value>),crypto\crypto_tls.cc,"void TLSWrap::VerifyError(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());

  // XXX(bnoordhuis) The UNABLE_TO_GET_ISSUER_CERT error when there is no
  // peer certificate is questionable but it's compatible with what was
  // here before.
  long x509_verify_error =  // NOLINT(runtime/int)
      VerifyPeerCertificate(
          w->ssl_,
          X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT);

  if (x509_verify_error == X509_V_OK)
    return args.GetReturnValue().SetNull();

  const char* reason = X509_verify_cert_error_string(x509_verify_error);
  const char* code = X509ErrorCode(x509_verify_error);

  Local<Object> error =
      Exception::Error(OneByteString(env->isolate(), reason))
          ->ToObject(env->isolate()->GetCurrentContext())
              .FromMaybe(Local<Object>());

  if (Set(env, error, env->code_string(), code))
    args.GetReturnValue().Set(error);
}",1690.0,1716.0,1.0,1.0,27.0,23,7,28,13,0,0,3,3,0,0,,0,0,2,1,1,void
1876,64265,GetCipher,1,node.crypto.TLSWrap.GetCipher,void node.crypto.TLSWrap.GetCipher (FunctionCallbackInfo<Value>),crypto\crypto_tls.cc,"void TLSWrap::GetCipher(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
  args.GetReturnValue().Set(
      GetCipherInfo(env, w->ssl_).FromMaybe(Local<Object>()));
}",1718.0,1724.0,1.0,1.0,7.0,8,4,8,4,0,0,1,1,0,0,,0,0,2,1,1,void
1877,64302,LoadSession,1,node.crypto.TLSWrap.LoadSession,void node.crypto.TLSWrap.LoadSession (FunctionCallbackInfo<Value>),crypto\crypto_tls.cc,"void TLSWrap::LoadSession(const FunctionCallbackInfo<Value>& args) {
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());

  // TODO(@sam-github) check arg length and types in js, and CHECK in c++
  if (args.Length() >= 1 && Buffer::HasInstance(args[0])) {
    ArrayBufferViewContents<unsigned char> sbuf(args[0]);

    const unsigned char* p = sbuf.data();
    SSL_SESSION* sess = d2i_SSL_SESSION(nullptr, &p, sbuf.length());

    // Setup next session and move hello to the BIO buffer
    w->next_sess_.reset(sess);
  }
}",1726.0,1740.0,1.0,1.0,15.0,15,7,13,6,0,0,2,2,0,0,,0,0,2,1,1,void
1878,64361,GetSharedSigalgs,1,node.crypto.TLSWrap.GetSharedSigalgs,void node.crypto.TLSWrap.GetSharedSigalgs (FunctionCallbackInfo<Value>),crypto\crypto_tls.cc,"void TLSWrap::GetSharedSigalgs(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());

  SSL* ssl = w->ssl_.get();
  int nsig = SSL_get_shared_sigalgs(ssl, 0, nullptr, nullptr, nullptr, nullptr,
                                    nullptr);
  MaybeStackBuffer<Local<Value>, 16> ret_arr(nsig);

  for (int i = 0; i < nsig; i++) {
    int hash_nid;
    int sign_nid;
    std::string sig_with_md;

    SSL_get_shared_sigalgs(ssl, i, &sign_nid, &hash_nid, nullptr, nullptr,
                           nullptr);

    switch (sign_nid) {
      case EVP_PKEY_RSA:
        sig_with_md = ""RSA+"";
        break;

      case EVP_PKEY_RSA_PSS:
        sig_with_md = ""RSA-PSS+"";
        break;

      case EVP_PKEY_DSA:
        sig_with_md = ""DSA+"";
        break;

      case EVP_PKEY_EC:
        sig_with_md = ""ECDSA+"";
        break;

      case NID_ED25519:
        sig_with_md = ""Ed25519+"";
        break;...",1742.0,1819.0,1.0,1.0,78.0,40,9,57,24,0,0,15,9,0,0,,0,0,2,1,1,void
1879,64571,ExportKeyingMaterial,1,node.crypto.TLSWrap.ExportKeyingMaterial,void node.crypto.TLSWrap.ExportKeyingMaterial (FunctionCallbackInfo<Value>),crypto\crypto_tls.cc,"void TLSWrap::ExportKeyingMaterial(const FunctionCallbackInfo<Value>& args) {
  CHECK(args[0]->IsInt32());
  CHECK(args[1]->IsString());

  Environment* env = Environment::GetCurrent(args);
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());

  uint32_t olen = args[0].As<Uint32>()->Value();
  Utf8Value label(env->isolate(), args[1]);

  std::unique_ptr<BackingStore> bs;
  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), olen);
  }

  ByteSource context;
  bool use_context = !args[2]->IsUndefined();
  if (use_context)
    context = ByteSource::FromBuffer(args[2]);

  if (SSL_export_keying_material(
          w->ssl_.get(),
          static_cast<unsigned char*>(bs->Data()),
          olen,
          *label,
          label.length(),
          context.data<unsigned char>(),
          context.size(),
          use_context) != 1) {
    return ThrowCryptoError(
         env,
         ERR_get_error(),
  ...",1821.0,1862.0,1.0,1.0,42.0,52,11,51,18,0,0,4,4,0,0,,0,0,2,1,1,void
1880,64765,EndParser,1,node.crypto.TLSWrap.EndParser,void node.crypto.TLSWrap.EndParser (FunctionCallbackInfo<Value>),crypto\crypto_tls.cc,"void TLSWrap::EndParser(const FunctionCallbackInfo<Value>& args) {
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
  w->hello_parser_.End();
}",1864.0,1868.0,1.0,1.0,5.0,4,3,3,2,0,0,1,1,0,0,,0,0,2,1,1,void
1881,64784,Renegotiate,1,node.crypto.TLSWrap.Renegotiate,void node.crypto.TLSWrap.Renegotiate (FunctionCallbackInfo<Value>),crypto\crypto_tls.cc,"void TLSWrap::Renegotiate(const FunctionCallbackInfo<Value>& args) {
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
  ClearErrorOnReturn clear_error_on_return;
  if (SSL_renegotiate(w->ssl_.get()) != 1)
    return ThrowCryptoError(w->env(), ERR_get_error());
}",1870.0,1876.0,1.0,1.0,7.0,6,4,4,2,0,0,2,2,0,0,,0,0,2,1,1,void
1882,64816,GetTLSTicket,1,node.crypto.TLSWrap.GetTLSTicket,void node.crypto.TLSWrap.GetTLSTicket (FunctionCallbackInfo<Value>),crypto\crypto_tls.cc,"void TLSWrap::GetTLSTicket(const FunctionCallbackInfo<Value>& args) {
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
  Environment* env = w->env();

  SSL_SESSION* sess = SSL_get_session(w->ssl_.get());
  if (sess == nullptr)
    return;

  const unsigned char* ticket;
  size_t length;
  SSL_SESSION_get0_ticket(sess, &ticket, &length);

  if (ticket != nullptr) {
    args.GetReturnValue().Set(
        Buffer::Copy(env, reinterpret_cast<const char*>(ticket), length)
            .FromMaybe(Local<Object>()));
  }
}",1878.0,1896.0,1.0,1.0,19.0,16,7,16,7,0,0,3,3,0,0,,0,0,2,1,1,void
1883,64885,NewSessionDone,1,node.crypto.TLSWrap.NewSessionDone,void node.crypto.TLSWrap.NewSessionDone (FunctionCallbackInfo<Value>),crypto\crypto_tls.cc,"void TLSWrap::NewSessionDone(const FunctionCallbackInfo<Value>& args) {
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
  w->awaiting_new_session_ = false;
  w->NewSessionDoneCb();
}",1898.0,1903.0,1.0,1.0,6.0,5,4,4,2,0,0,1,1,0,0,,0,0,2,1,1,void
1884,64907,SetOCSPResponse,1,node.crypto.TLSWrap.SetOCSPResponse,void node.crypto.TLSWrap.SetOCSPResponse (FunctionCallbackInfo<Value>),crypto\crypto_tls.cc,"void TLSWrap::SetOCSPResponse(const FunctionCallbackInfo<Value>& args) {
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
  Environment* env = w->env();

  if (args.Length() < 1)
    return THROW_ERR_MISSING_ARGS(env, ""OCSP response argument is mandatory"");

  THROW_AND_RETURN_IF_NOT_BUFFER(env, args[0], ""OCSP response"");

  w->ocsp_response_.Reset(args.GetIsolate(), args[0].As<ArrayBufferView>());
}",1905.0,1916.0,1.0,1.0,12.0,12,6,11,3,0,0,2,2,0,0,,0,0,2,1,1,void
1885,64961,RequestOCSP,1,node.crypto.TLSWrap.RequestOCSP,void node.crypto.TLSWrap.RequestOCSP (FunctionCallbackInfo<Value>),crypto\crypto_tls.cc,"void TLSWrap::RequestOCSP(const FunctionCallbackInfo<Value>& args) {
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());

  SSL_set_tlsext_status_type(w->ssl_.get(), TLSEXT_STATUSTYPE_ocsp);
}",1918.0,1923.0,1.0,1.0,6.0,4,3,4,3,0,0,1,1,0,0,,0,0,2,1,1,void
1886,64982,GetEphemeralKeyInfo,1,node.crypto.TLSWrap.GetEphemeralKeyInfo,void node.crypto.TLSWrap.GetEphemeralKeyInfo (FunctionCallbackInfo<Value>),crypto\crypto_tls.cc,"void TLSWrap::GetEphemeralKeyInfo(const FunctionCallbackInfo<Value>& args) {
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
  Environment* env = Environment::GetCurrent(args);

  CHECK(w->ssl_);

  // tmp key is available on only client
  if (w->is_server())
    return args.GetReturnValue().SetNull();

  args.GetReturnValue().Set(GetEphemeralKey(env, w->ssl_)
      .FromMaybe(Local<Value>()));

  // TODO(@sam-github) semver-major: else return ThrowCryptoError(env,
  // ERR_get_error())
}",1925.0,1941.0,1.0,1.0,17.0,12,4,11,4,0,0,2,2,0,0,,0,0,2,1,1,void
1887,65037,GetProtocol,1,node.crypto.TLSWrap.GetProtocol,void node.crypto.TLSWrap.GetProtocol (FunctionCallbackInfo<Value>),crypto\crypto_tls.cc,"void TLSWrap::GetProtocol(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());
  args.GetReturnValue().Set(
      OneByteString(env->isolate(), SSL_get_version(w->ssl_.get())));
}",1943.0,1949.0,1.0,1.0,7.0,9,4,8,4,0,0,1,1,0,0,,0,0,2,1,1,void
1888,65077,GetALPNNegotiatedProto,1,node.crypto.TLSWrap.GetALPNNegotiatedProto,void node.crypto.TLSWrap.GetALPNNegotiatedProto (FunctionCallbackInfo<Value>),crypto\crypto_tls.cc,"void TLSWrap::GetALPNNegotiatedProto(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  TLSWrap* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.Holder());

  const unsigned char* alpn_proto;
  unsigned int alpn_proto_len;

  SSL_get0_alpn_selected(w->ssl_.get(), &alpn_proto, &alpn_proto_len);

  Local<Value> result;
  if (alpn_proto_len == 0) {
    result = False(env->isolate());
  } else if (alpn_proto_len == sizeof(""h2"") - 1 &&
             0 == memcmp(alpn_proto, ""h2"", sizeof(""h2"") - 1)) {
    result = env->h2_string();
  } else if (alpn_proto_len == sizeof(""http/1.1"") - 1 &&
             0 == memcmp(alpn_proto, ""http/1.1"", sizeof(""http/1.1"") - 1)) {
    result = env->http_1_1_string();
  } else {
    result = OneByteString(env->isolate(), alpn_proto, alpn_proto_len);
  }

  args.GetReturnValue().Set(result);
}",1951.0,1975.0,1.0,1.0,25.0,15,7,16,9,0,0,2,2,0,0,,0,0,2,1,1,void
1889,65199,Cycle,1,node.crypto.TLSWrap.Cycle,void node.crypto.TLSWrap.Cycle (),crypto\crypto_tls.cc,"void TLSWrap::Cycle() {
  // Prevent recursion
  if (++cycle_depth_ > 1)
    return;

  for (; cycle_depth_ > 0; cycle_depth_--) {
    ClearIn();
    ClearOut();
    // EncIn() doesn't exist, it happens via stream listener callbacks.
    EncOut();
  }
}",1977.0,1988.0,1.0,1.0,12.0,3,2,2,1,0,0,3,3,0,0,,0,0,0,0,0,void
1890,65221,Initialize,1,node.crypto.TLSWrap.Initialize,"void node.crypto.TLSWrap.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)",crypto\crypto_tls.cc,"void TLSWrap::Initialize(
    Local<Object> target,
    Local<Value> unused,
    Local<Context> context,
    void* priv) {
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  SetMethod(context, target, ""wrap"", TLSWrap::Wrap);

  NODE_DEFINE_CONSTANT(target, HAVE_SSL_TRACE);

  Local<FunctionTemplate> t = BaseObject::MakeLazilyInitializedJSTemplate(env);
  Local<String> tlsWrapString =
      FIXED_ONE_BYTE_STRING(env->isolate(), ""TLSWrap"");
  t->SetClassName(tlsWrapString);
  t->InstanceTemplate()->SetInternalFieldCount(StreamBase::kInternalFieldCount);

  Local<FunctionTemplate> get_write_queue_size =
      FunctionTemplate::New(env->isolate(),
                            GetWriteQueueSize,
                            Local<Value>(),
                            Signature::New(env->isolate(), t));
  t->PrototypeTemplate()->SetAccessorProperty(
      env->write_queue_size_string(),
      get_write_queue_size,
      Local<FunctionTemplate>(),
...",2003.0,2093.0,1.0,2.0,91.0,75,7,192,62,0,0,1,1,0,0,,0,0,8,4,4,void
1891,65665,RegisterExternalReferences,1,node.crypto.TLSWrap.RegisterExternalReferences,void node.crypto.TLSWrap.RegisterExternalReferences (ExternalReferenceRegistry*),crypto\crypto_tls.cc,"void TLSWrap::RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  registry->Register(TLSWrap::Wrap);
  registry->Register(GetWriteQueueSize);

  registry->Register(CertCbDone);
  registry->Register(DestroySSL);
  registry->Register(EnableCertCb);
  registry->Register(EndParser);
  registry->Register(EnableKeylogCallback);
  registry->Register(EnableSessionCallbacks);
  registry->Register(EnableTrace);
  registry->Register(GetServername);
  registry->Register(LoadSession);
  registry->Register(NewSessionDone);
  registry->Register(Receive);
  registry->Register(Renegotiate);
  registry->Register(RequestOCSP);
  registry->Register(SetALPNProtocols);
  registry->Register(SetOCSPResponse);
  registry->Register(SetServername);
  registry->Register(SetSession);
  registry->Register(SetVerifyMode);
  registry->Register(Start);
  registry->Register(ExportKeyingMaterial);
  registry->Register(IsSessionReused);
  registry->Register(GetALPNNegotiatedProto);
  registry->Register...",2095.0,2143.0,1.0,1.0,49.0,40,2,78,40,0,0,1,1,0,0,,0,0,2,1,1,void
1892,65890,<lambda>0,1,node.crypto.ByteSource.ReleaseToBackingStore.<lambda>0,"ANY node.crypto.ByteSource.ReleaseToBackingStore.<lambda>0 (void*,size_t,void*)",crypto\crypto_util.cc,"[](void* data, size_t length, void* deleter_data) {
        OPENSSL_clear_free(deleter_data, length);
      }",358.0,360.0,7.0,7.0,3.0,0,0,2,2,0,0,1,1,0,0,,0,0,6,3,3,ANY
1893,65902,<lambda>1,1,node.crypto.anonymous_namespace_2.SecureBuffer.<lambda>1,"ANY node.crypto.anonymous_namespace_2.SecureBuffer.<lambda>1 (void*,size_t,void*)",crypto\crypto_util.cc,"[](void* data, size_t len, void* deleter_data) {
            OPENSSL_secure_clear_free(data, len);
          }",721.0,723.0,11.0,11.0,3.0,0,0,2,2,0,0,1,1,0,0,,0,0,6,3,3,ANY
1894,65950,VerifyCallback,1,node.crypto.VerifyCallback,"int node.crypto.VerifyCallback (int,X509_STORE_CTX*)",crypto\crypto_util.cc,"int VerifyCallback(int preverify_ok, X509_STORE_CTX* ctx) {
  // From https://www.openssl.org/docs/man1.1.1/man3/SSL_verify_cb:
  //
  //   If VerifyCallback returns 1, the verification process is continued. If
  //   VerifyCallback always returns 1, the TLS/SSL handshake will not be
  //   terminated with respect to verification failures and the connection will
  //   be established. The calling process can however retrieve the error code
  //   of the last verification error using SSL_get_verify_result(3) or by
  //   maintaining its own error storage managed by VerifyCallback.
  //
  // Since we cannot perform I/O quickly enough with X509_STORE_CTX_ APIs in
  // this callback, we ignore all preverify_ok errors and let the handshake
  // continue. It is imperative that the user use Connection::VerifyError after
  // the 'secure' callback has been made.
  return 1;
}",46.0,61.0,1.0,1.0,16.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
1895,65959,CSPRNG,1,node.crypto.CSPRNG,"CSPRNGResult node.crypto.CSPRNG (void*,size_t)",crypto\crypto_util.cc,"CSPRNGResult CSPRNG(void* buffer, size_t length) {
  unsigned char* buf = static_cast<unsigned char*>(buffer);
  do {
    if (1 == RAND_status()) {
#if OPENSSL_VERSION_MAJOR >= 3
      if (1 == RAND_bytes_ex(nullptr, buf, length, 0)) return {true};
#else
      while (length > INT_MAX && 1 == RAND_bytes(buf, INT_MAX)) {
        buf += INT_MAX;
        length -= INT_MAX;
      }
      if (length <= INT_MAX && 1 == RAND_bytes(buf, static_cast<int>(length)))
        return {true};
#endif
    }
#if OPENSSL_VERSION_MAJOR >= 3
    const auto code = ERR_peek_last_error();
    // A misconfigured OpenSSL 3 installation may report 1 from RAND_poll()
    // and RAND_status() but fail in RAND_bytes() if it cannot look up
    // a matching algorithm for the CSPRNG.
    if (ERR_GET_LIB(code) == ERR_LIB_RAND) {
      const auto reason = ERR_GET_REASON(code);
      if (reason == RAND_R_ERROR_INSTANTIATING_DRBG ||
          reason == RAND_R_UNABLE_TO_FETCH_DRBG ||
          reason == RAND_R_UNABLE_TO...",63.0,95.0,17.0,1.0,33.0,13,8,14,4,0,0,5,10,0,0,,0,0,4,2,2,CSPRNGResult
1896,66013,PasswordCallback,1,node.crypto.PasswordCallback,"int node.crypto.PasswordCallback (char*,int,int,void*)",crypto\crypto_util.cc,"int PasswordCallback(char* buf, int size, int rwflag, void* u) {
  const ByteSource* passphrase = *static_cast<const ByteSource**>(u);
  if (passphrase != nullptr) {
    size_t buflen = static_cast<size_t>(size);
    size_t len = passphrase->size();
    if (buflen < len)
      return -1;
    memcpy(buf, passphrase->data(), len);
    return len;
  }

  return -1;
}",97.0,109.0,1.0,1.0,13.0,12,7,13,6,0,0,3,4,0,0,,0,0,8,4,4,int
1897,66066,NoPasswordCallback,1,node.crypto.NoPasswordCallback,"int node.crypto.NoPasswordCallback (char*,int,int,void*)",crypto\crypto_util.cc,"int NoPasswordCallback(char* buf, int size, int rwflag, void* u) {
  return 0;
}",116.0,118.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,int
1898,66076,ProcessFipsOptions,1,node.crypto.ProcessFipsOptions,bool node.crypto.ProcessFipsOptions (),crypto\crypto_util.cc,"bool ProcessFipsOptions() {
  /* Override FIPS settings in configuration file, if needed. */
  if (per_process::cli_options->enable_fips_crypto ||
      per_process::cli_options->force_fips_crypto) {
#if OPENSSL_VERSION_MAJOR >= 3
    OSSL_PROVIDER* fips_provider = OSSL_PROVIDER_load(nullptr, ""fips"");
    if (fips_provider == nullptr)
      return false;
    OSSL_PROVIDER_unload(fips_provider);

    return EVP_default_properties_enable_fips(nullptr, 1) &&
           EVP_default_properties_is_fips_enabled(nullptr);
#else
    if (FIPS_mode() == 0) return FIPS_mode_set(1);

#endif
  }
  return true;
}",120.0,138.0,1.0,1.0,19.0,6,4,2,1,0,0,3,4,0,0,,0,0,0,0,0,bool
1899,66103,InitCryptoOnce,1,node.crypto.InitCryptoOnce,bool node.crypto.InitCryptoOnce (Isolate*),crypto\crypto_util.cc,"void InitCryptoOnce() {
  Mutex::ScopedLock lock(per_process::cli_options_mutex);
  Mutex::ScopedLock fips_lock(fips_mutex);
#ifndef OPENSSL_IS_BORINGSSL
  OPENSSL_INIT_SETTINGS* settings = OPENSSL_INIT_new();

#if OPENSSL_VERSION_MAJOR < 3
  // --openssl-config=...
  if (!per_process::cli_options->openssl_config.empty()) {
    const char* conf = per_process::cli_options->openssl_config.c_str();
    OPENSSL_INIT_set_config_filename(settings, conf);
  }
#endif

#if OPENSSL_VERSION_MAJOR >= 3
  // --openssl-legacy-provider
  if (per_process::cli_options->openssl_legacy_provider) {
    OSSL_PROVIDER* legacy_provider = OSSL_PROVIDER_load(nullptr, ""legacy"");
    if (legacy_provider == nullptr) {
      fprintf(stderr, ""Unable to load legacy provider.\n"");
    }
  }
#endif

  OPENSSL_init_ssl(0, settings);
  OPENSSL_INIT_free(settings);
  settings = nullptr;

#ifndef _WIN32
  if (per_process::cli_options->secure_heap != 0) {
    switch (CRYPTO_secure_malloc_init(
                per_proces...",155.0,212.0,1.0,1.0,58.0,9,6,8,4,0,0,2,2,0,0,,0,0,0,0,0,void
1900,66233,GetFipsCrypto,1,node.crypto.GetFipsCrypto,void node.crypto.GetFipsCrypto (FunctionCallbackInfo<Value>),crypto\crypto_util.cc,"void GetFipsCrypto(const FunctionCallbackInfo<Value>& args) {
  Mutex::ScopedLock lock(per_process::cli_options_mutex);
  Mutex::ScopedLock fips_lock(fips_mutex);

#if OPENSSL_VERSION_MAJOR >= 3
  args.GetReturnValue().Set(EVP_default_properties_is_fips_enabled(nullptr) ?
      1 : 0);
#else
  args.GetReturnValue().Set(FIPS_mode() ? 1 : 0);
#endif
}",214.0,224.0,1.0,1.0,11.0,4,2,3,3,0,0,1,1,0,0,,0,0,2,1,1,void
1901,66257,SetFipsCrypto,1,node.crypto.SetFipsCrypto,void node.crypto.SetFipsCrypto (FunctionCallbackInfo<Value>),crypto\crypto_util.cc,"void SetFipsCrypto(const FunctionCallbackInfo<Value>& args) {
  Mutex::ScopedLock lock(per_process::cli_options_mutex);
  Mutex::ScopedLock fips_lock(fips_mutex);

  CHECK(!per_process::cli_options->force_fips_crypto);
  Environment* env = Environment::GetCurrent(args);
  CHECK(env->owns_process_state());
  bool enable = args[0]->BooleanValue(env->isolate());

#if OPENSSL_VERSION_MAJOR >= 3
  if (enable == EVP_default_properties_is_fips_enabled(nullptr))
#else
  if (static_cast<int>(enable) == FIPS_mode())
#endif
    return;  // No action needed.

#if OPENSSL_VERSION_MAJOR >= 3
  if (!EVP_default_properties_enable_fips(nullptr, enable)) {
#else
  if (!FIPS_mode_set(enable)) {
#endif
    unsigned long err = ERR_get_error();  // NOLINT(runtime/int)
    return ThrowCryptoError(env, err);
  }
}",226.0,250.0,1.0,1.0,25.0,15,7,15,7,0,0,3,3,0,0,,0,0,2,1,1,void
1902,66324,TestFipsCrypto,1,node.crypto.TestFipsCrypto,void node.crypto.TestFipsCrypto (ANY),crypto\crypto_util.cc,"void TestFipsCrypto(const v8::FunctionCallbackInfo<v8::Value>& args) {
  Mutex::ScopedLock lock(per_process::cli_options_mutex);
  Mutex::ScopedLock fips_lock(fips_mutex);

#ifdef OPENSSL_FIPS
#if OPENSSL_VERSION_MAJOR >= 3
  OSSL_PROVIDER* fips_provider = nullptr;
  if (OSSL_PROVIDER_available(nullptr, ""fips"")) {
    fips_provider = OSSL_PROVIDER_load(nullptr, ""fips"");
  }
  const auto enabled = fips_provider == nullptr ? 0 :
      OSSL_PROVIDER_self_test(fips_provider) ? 1 : 0;
#else
  const auto enabled = FIPS_selftest() ? 1 : 0;
#endif
#else  // OPENSSL_FIPS
  const auto enabled = 0;
#endif  // OPENSSL_FIPS

  args.GetReturnValue().Set(enabled);
}",252.0,272.0,1.0,1.0,21.0,4,2,5,4,0,0,1,1,0,0,,0,0,2,1,1,void
1903,66349,Capture,1,node.crypto.CryptoErrorStore.Capture,void node.crypto.CryptoErrorStore.Capture (),crypto\crypto_util.cc,"void CryptoErrorStore::Capture() {
  errors_.clear();
  while (const uint32_t err = ERR_get_error()) {
    char buf[256];
    ERR_error_string_n(err, buf, sizeof(buf));
    errors_.emplace_back(buf);
  }
  std::reverse(std::begin(errors_), std::end(errors_));
}",274.0,282.0,1.0,1.0,9.0,6,2,11,4,0,0,2,2,0,0,,0,0,0,0,0,void
1904,66384,Empty,1,node.crypto.CryptoErrorStore.Empty,bool node.crypto.CryptoErrorStore.Empty (),crypto\crypto_util.cc,"bool CryptoErrorStore::Empty() const {
  return errors_.empty();
}",284.0,286.0,1.0,1.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,bool
1905,66393,ToException,1,node.crypto.CryptoErrorStore.ToException,"MaybeLocal<Value> node.crypto.CryptoErrorStore.ToException (Environment*,Local<String>)",crypto\crypto_util.cc,"MaybeLocal<Value> CryptoErrorStore::ToException(
    Environment* env,
    Local<String> exception_string) const {
  if (exception_string.IsEmpty()) {
    CryptoErrorStore copy(*this);
    if (copy.Empty()) {
      // But possibly a bug...
      copy.Insert(NodeCryptoError::OK);
    }
    // Use last element as the error message, everything else goes
    // into the .opensslErrorStack property on the exception object.
    const std::string& last_error_string = copy.errors_.back();
    Local<String> exception_string;
    if (!String::NewFromUtf8(
            env->isolate(),
            last_error_string.data(),
            NewStringType::kNormal,
            last_error_string.size()).ToLocal(&exception_string)) {
      return MaybeLocal<Value>();
    }
    copy.errors_.pop_back();
    return copy.ToException(env, exception_string);
  }

  Local<Value> exception_v = Exception::Error(exception_string);
  CHECK(!exception_v.IsEmpty());

  if (!Empty()) {
    CHECK(exception_v->IsObject(...",288.0,327.0,1.0,1.0,40.0,44,9,41,15,0,0,6,9,0,0,,0,0,4,2,2,MaybeLocal<Value>
1906,66554,ByteSource,1,node.crypto.ByteSource.ByteSource,ANY node.crypto.ByteSource.ByteSource (ByteSource),crypto\crypto_util.cc,"ByteSource::ByteSource(ByteSource&& other) noexcept
    : data_(other.data_),
      allocated_data_(other.allocated_data_),
      size_(other.size_) {
  other.allocated_data_ = nullptr;
}",329.0,334.0,1.0,1.0,6.0,2,2,1,1,0,0,1,1,0,0,,0,0,2,1,1,ANY
1907,66564,~ByteSource,1,node.crypto.ByteSource.~ByteSource,ANY node.crypto.ByteSource.~ByteSource (),crypto\crypto_util.cc,"ByteSource::~ByteSource() {
  OPENSSL_clear_free(allocated_data_, size_);
}",336.0,338.0,1.0,1.0,3.0,0,0,2,2,0,0,1,1,0,0,,0,0,0,0,0,ANY
1908,66571,operator =,1,node.crypto.ByteSource.operator =,ByteSource node.crypto.ByteSource.operator = (ByteSource),crypto\crypto_util.cc,"ByteSource& ByteSource::operator=(ByteSource&& other) noexcept {
  if (&other != this) {
    OPENSSL_clear_free(allocated_data_, size_);
    data_ = other.data_;
    allocated_data_ = other.allocated_data_;
    other.allocated_data_ = nullptr;
    size_ = other.size_;
  }
  return *this;
}",340.0,349.0,1.0,1.0,10.0,11,5,10,4,0,0,2,2,0,0,,0,0,2,1,1,ByteSource
1909,66608,ReleaseToBackingStore,1,node.crypto.ByteSource.ReleaseToBackingStore,unique_ptr<BackingStore> node.crypto.ByteSource.ReleaseToBackingStore (),crypto\crypto_util.cc,"std::unique_ptr<BackingStore> ByteSource::ReleaseToBackingStore() {
  // It's ok for allocated_data_ to be nullptr but
  // only if size_ is zero.
  CHECK_IMPLIES(size_ > 0, allocated_data_ != nullptr);
  std::unique_ptr<BackingStore> ptr = ArrayBuffer::NewBackingStore(
      allocated_data_,
      size(),
      [](void* data, size_t length, void* deleter_data) {
        OPENSSL_clear_free(deleter_data, length);
      }, allocated_data_);
  CHECK(ptr);
  allocated_data_ = nullptr;
  data_ = nullptr;
  size_ = 0;
  return ptr;
}",351.0,366.0,1.0,1.0,16.0,10,5,12,7,0,0,1,1,0,0,,0,0,0,0,0,unique_ptr<BackingStore>
1910,66647,ToArrayBuffer,1,node.crypto.ByteSource.ToArrayBuffer,Local<ArrayBuffer> node.crypto.ByteSource.ToArrayBuffer (Environment*),crypto\crypto_util.cc,"Local<ArrayBuffer> ByteSource::ToArrayBuffer(Environment* env) {
  std::unique_ptr<BackingStore> store = ReleaseToBackingStore();
  return ArrayBuffer::New(env->isolate(), std::move(store));
}",368.0,371.0,1.0,1.0,4.0,7,5,7,5,0,0,1,1,0,0,,0,0,2,1,1,Local<ArrayBuffer>
1911,66675,ToBuffer,1,node.crypto.ByteSource.ToBuffer,MaybeLocal<Uint8Array> node.crypto.ByteSource.ToBuffer (Environment*),crypto\crypto_util.cc,"MaybeLocal<Uint8Array> ByteSource::ToBuffer(Environment* env) {
  Local<ArrayBuffer> ab = ToArrayBuffer(env);
  return Buffer::New(env, ab, 0, ab->ByteLength());
}",373.0,376.0,1.0,1.0,4.0,5,5,8,5,0,0,1,1,0,0,,0,0,2,1,1,MaybeLocal<Uint8Array>
1912,66700,FromBIO,1,node.crypto.ByteSource.FromBIO,ByteSource node.crypto.ByteSource.FromBIO (BIOPointer),crypto\crypto_util.cc,"ByteSource ByteSource::FromBIO(const BIOPointer& bio) {
  CHECK(bio);
  BUF_MEM* bptr;
  BIO_get_mem_ptr(bio.get(), &bptr);
  ByteSource::Builder out(bptr->length);
  memcpy(out.data<void>(), bptr->data, bptr->length);
  return std::move(out).release();
}",378.0,385.0,1.0,1.0,8.0,8,3,9,4,0,0,1,1,0,0,,0,0,2,1,1,ByteSource
1913,66740,FromEncodedString,1,node.crypto.ByteSource.FromEncodedString,"ByteSource node.crypto.ByteSource.FromEncodedString (Environment*,Local<String>,encoding)",crypto\crypto_util.cc,"ByteSource ByteSource::FromEncodedString(Environment* env,
                                         Local<String> key,
                                         enum encoding enc) {
  size_t length = 0;
  ByteSource out;

  if (StringBytes::Size(env->isolate(), key, enc).To(&length) && length > 0) {
    ByteSource::Builder buf(length);
    size_t actual =
        StringBytes::Write(env->isolate(), buf.data<char>(), length, key, enc);
    out = std::move(buf).release(actual);
  }

  return out;
}",387.0,401.0,1.0,1.0,15.0,14,6,20,9,0,0,2,2,0,0,,0,0,6,3,3,ByteSource
1914,66807,FromStringOrBuffer,1,node.crypto.ByteSource.FromStringOrBuffer,"ByteSource node.crypto.ByteSource.FromStringOrBuffer (Environment*,Local<Value>)",crypto\crypto_util.cc,"ByteSource ByteSource::FromStringOrBuffer(Environment* env,
                                          Local<Value> value) {
  return IsAnyByteSource(value) ? FromBuffer(value)
                                : FromString(env, value.As<String>());
}",403.0,407.0,1.0,1.0,5.0,2,2,4,2,0,0,1,1,0,0,,0,0,4,2,2,ByteSource
1915,66825,FromString,1,node.crypto.ByteSource.FromString,"ByteSource node.crypto.ByteSource.FromString (Environment*,Local<String>,bool)",crypto\crypto_util.cc,"ByteSource ByteSource::FromString(Environment* env, Local<String> str,
                                  bool ntc) {
  CHECK(str->IsString());
  size_t size = str->Utf8Length(env->isolate());
  size_t alloc_size = ntc ? size + 1 : size;
  ByteSource::Builder out(alloc_size);
  int opts = String::NO_OPTIONS;
  if (!ntc) opts |= String::NO_NULL_TERMINATION;
  str->WriteUtf8(env->isolate(), out.data<char>(), alloc_size, nullptr, opts);
  return std::move(out).release();
}",409.0,419.0,1.0,1.0,11.0,16,6,21,9,0,0,2,2,0,0,,0,0,6,3,3,ByteSource
1916,66899,FromBuffer,1,node.crypto.ByteSource.FromBuffer,"ByteSource node.crypto.ByteSource.FromBuffer (Local<Value>,bool)",crypto\crypto_util.cc,"ByteSource ByteSource::FromBuffer(Local<Value> buffer, bool ntc) {
  ArrayBufferOrViewContents<char> buf(buffer);
  return ntc ? buf.ToNullTerminatedCopy() : buf.ToByteSource();
}",421.0,424.0,1.0,1.0,4.0,3,2,4,3,0,0,1,1,0,0,,0,0,4,2,2,ByteSource
1917,66919,FromSecretKeyBytes,1,node.crypto.ByteSource.FromSecretKeyBytes,"ByteSource node.crypto.ByteSource.FromSecretKeyBytes (Environment*,Local<Value>)",crypto\crypto_util.cc,"ByteSource ByteSource::FromSecretKeyBytes(
    Environment* env,
    Local<Value> value) {
  // A key can be passed as a string, buffer or KeyObject with type 'secret'.
  // If it is a string, we need to convert it to a buffer. We are not doing that
  // in JS to avoid creating an unprotected copy on the heap.
  return value->IsString() || IsAnyByteSource(value) ?
           ByteSource::FromStringOrBuffer(env, value) :
           ByteSource::FromSymmetricKeyObjectHandle(value);
}",426.0,435.0,1.0,1.0,10.0,5,4,7,3,0,0,1,1,0,0,,0,0,4,2,2,ByteSource
1918,66945,NullTerminatedCopy,1,node.crypto.ByteSource.NullTerminatedCopy,"ByteSource node.crypto.ByteSource.NullTerminatedCopy (Environment*,Local<Value>)",crypto\crypto_util.cc,"ByteSource ByteSource::NullTerminatedCopy(Environment* env,
                                          Local<Value> value) {
  return Buffer::HasInstance(value) ? FromBuffer(value, true)
                                    : FromString(env, value.As<String>(), true);
}",437.0,441.0,1.0,1.0,5.0,3,2,5,3,0,0,1,1,0,0,,0,0,4,2,2,ByteSource
1919,66968,FromSymmetricKeyObjectHandle,1,node.crypto.ByteSource.FromSymmetricKeyObjectHandle,ByteSource node.crypto.ByteSource.FromSymmetricKeyObjectHandle (Local<Value>),crypto\crypto_util.cc,"ByteSource ByteSource::FromSymmetricKeyObjectHandle(Local<Value> handle) {
  CHECK(handle->IsObject());
  KeyObjectHandle* key = Unwrap<KeyObjectHandle>(handle.As<Object>());
  CHECK_NOT_NULL(key);
  return Foreign(key->Data()->GetSymmetricKey(),
                 key->Data()->GetSymmetricKeySize());
}",443.0,449.0,1.0,1.0,7.0,9,5,8,4,0,0,1,1,0,0,,0,0,2,1,1,ByteSource
1920,67007,Allocated,1,node.crypto.ByteSource.Allocated,"ByteSource node.crypto.ByteSource.Allocated (void*,size_t)",crypto\crypto_util.cc,"ByteSource ByteSource::Allocated(void* data, size_t size) {
  return ByteSource(data, data, size);
}",451.0,453.0,1.0,1.0,3.0,0,0,3,2,0,0,1,1,0,0,,0,0,4,2,2,ByteSource
1921,67018,Foreign,1,node.crypto.ByteSource.Foreign,"ByteSource node.crypto.ByteSource.Foreign (void*,size_t)",crypto\crypto_util.cc,"ByteSource ByteSource::Foreign(const void* data, size_t size) {
  return ByteSource(data, nullptr, size);
}",455.0,457.0,1.0,1.0,3.0,0,0,2,2,0,0,1,1,0,0,,0,0,4,2,2,ByteSource
1922,67030,Decorate,1,node.crypto.error.Decorate,"Maybe<bool> node.crypto.error.Decorate (Environment*,Local<Object>,long unsigned)",crypto\crypto_util.cc,"Maybe<bool> Decorate(Environment* env, Local<Object> obj,
              unsigned long err) {  // NOLINT(runtime/int)
  if (err == 0) return Just(true);  // No decoration necessary.

  const char* ls = ERR_lib_error_string(err);
  const char* fs = ERR_func_error_string(err);
  const char* rs = ERR_reason_error_string(err);

  Isolate* isolate = env->isolate();
  Local<Context> context = isolate->GetCurrentContext();

  if (ls != nullptr) {
    if (obj->Set(context, env->library_string(),
                 OneByteString(isolate, ls)).IsNothing()) {
      return Nothing<bool>();
    }
  }
  if (fs != nullptr) {
    if (obj->Set(context, env->function_string(),
                 OneByteString(isolate, fs)).IsNothing()) {
      return Nothing<bool>();
    }
  }
  if (rs != nullptr) {
    if (obj->Set(context, env->reason_string(),
                 OneByteString(isolate, rs)).IsNothing()) {
      return Nothing<bool>();
    }

    // SSL has no API to recover the error name from the number,...",460.0,563.0,1.0,32.0,104.0,74,9,125,52,0,0,50,22,0,0,,0,0,6,3,3,Maybe<bool>
1923,67461,ThrowCryptoError,1,node.crypto.ThrowCryptoError,"void node.crypto.ThrowCryptoError (Environment*,long unsigned,char*)",crypto\crypto_util.cc,"void ThrowCryptoError(Environment* env,
                      unsigned long err,  // NOLINT(runtime/int)
                      // Default, only used if there is no SSL `err` which can
                      // be used to create a long-style message string.
                      const char* message) {
  char message_buffer[128] = {0};
  if (err != 0 || message == nullptr) {
    ERR_error_string_n(err, message_buffer, sizeof(message_buffer));
    message = message_buffer;
  }
  HandleScope scope(env->isolate());
  Local<String> exception_string;
  Local<Value> exception;
  Local<Object> obj;
  if (!String::NewFromUtf8(env->isolate(), message).ToLocal(&exception_string))
    return;
  CryptoErrorStore errors;
  errors.Capture();
  if (!errors.ToException(env, exception_string).ToLocal(&exception) ||
      !exception->ToObject(env->context()).ToLocal(&obj) ||
      error::Decorate(env, obj, err).IsNothing()) {
    return;
  }
  env->isolate()->ThrowException(exception);
}",566.0,590.0,1.0,1.0,25.0,35,12,36,13,0,0,4,4,0,0,,0,0,6,3,3,void
1924,67583,LoadEngineById,1,node.crypto.LoadEngineById,"EnginePointer node.crypto.LoadEngineById (char*,CryptoErrorStore*)",crypto\crypto_util.cc,"EnginePointer LoadEngineById(const char* id, CryptoErrorStore* errors) {
  MarkPopErrorOnReturn mark_pop_error_on_return;

  EnginePointer engine(ENGINE_by_id(id));
  if (!engine) {
    // Engine not found, try loading dynamically.
    engine = EnginePointer(ENGINE_by_id(""dynamic""));
    if (engine) {
      if (!ENGINE_ctrl_cmd_string(engine.get(), ""SO_PATH"", id, 0) ||
          !ENGINE_ctrl_cmd_string(engine.get(), ""LOAD"", nullptr, 0)) {
        engine.reset();
      }
    }
  }

  if (!engine && errors != nullptr) {
    errors->Capture();
    if (errors->Empty()) {
      errors->Insert(NodeCryptoError::ENGINE_NOT_FOUND, id);
    }
  }

  return engine;
}",593.0,616.0,1.0,1.0,24.0,15,7,16,4,0,0,6,10,0,0,,0,0,4,2,2,EnginePointer
1925,67659,SetEngine,1,node.crypto.SetEngine,"bool node.crypto.SetEngine (char*,uint32_t,CryptoErrorStore*)",crypto\crypto_util.cc,"void SetEngine(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  CHECK(args.Length() >= 2 && args[0]->IsString());
  uint32_t flags;
  if (!args[1]->Uint32Value(env->context()).To(&flags)) return;

  const node::Utf8Value engine_id(env->isolate(), args[0]);

  args.GetReturnValue().Set(SetEngine(*engine_id, flags));
}",633.0,642.0,1.0,1.0,10.0,6,5,8,4,0,0,4,5,0,0,,0,0,2,1,1,void
1926,67768,EncodeBignum,1,node.crypto.EncodeBignum,"MaybeLocal<Value> node.crypto.EncodeBignum (Environment*,BIGNUM*,int,Local<Value>*)",crypto\crypto_util.cc,"MaybeLocal<Value> EncodeBignum(
    Environment* env,
    const BIGNUM* bn,
    int size,
    Local<Value>* error) {
  std::vector<uint8_t> buf(size);
  CHECK_EQ(BN_bn2binpad(bn, buf.data(), size), size);
  return StringBytes::Encode(
      env->isolate(),
      reinterpret_cast<const char*>(buf.data()),
      buf.size(),
      BASE64URL,
      error);
}",645.0,658.0,1.0,1.0,14.0,9,5,13,9,0,0,1,1,0,0,,0,0,8,4,4,MaybeLocal<Value>
1927,67814,SetEncodedValue,1,node.crypto.SetEncodedValue,"Maybe<bool> node.crypto.SetEncodedValue (Environment*,Local<Object>,Local<String>,BIGNUM*,int)",crypto\crypto_util.cc,"Maybe<bool> SetEncodedValue(
    Environment* env,
    Local<Object> target,
    Local<String> name,
    const BIGNUM* bn,
    int size) {
  Local<Value> value;
  Local<Value> error;
  CHECK_NOT_NULL(bn);
  if (size == 0)
    size = BN_num_bytes(bn);
  if (!EncodeBignum(env, bn, size, &error).ToLocal(&value)) {
    if (!error.IsEmpty())
      env->isolate()->ThrowException(error);
    return Nothing<bool>();
  }
  return target->Set(env->context(), name, value);
}",660.0,677.0,1.0,1.0,18.0,16,8,22,9,0,0,4,5,0,0,,0,0,10,5,5,Maybe<bool>
1928,67886,SetRsaOaepLabel,1,node.crypto.SetRsaOaepLabel,"bool node.crypto.SetRsaOaepLabel (EVPKeyCtxPointer,ByteSource)",crypto\crypto_util.cc,"bool SetRsaOaepLabel(const EVPKeyCtxPointer& ctx, const ByteSource& label) {
  if (label.size() != 0) {
    // OpenSSL takes ownership of the label, so we need to create a copy.
    void* label_copy = OPENSSL_memdup(label.data(), label.size());
    CHECK_NOT_NULL(label_copy);
    int ret = EVP_PKEY_CTX_set0_rsa_oaep_label(
        ctx.get(), static_cast<unsigned char*>(label_copy), label.size());
    if (ret <= 0) {
      OPENSSL_free(label_copy);
      return false;
    }
  }
  return true;
}",679.0,692.0,1.0,1.0,14.0,10,5,11,4,0,0,3,4,0,0,,0,0,4,2,2,bool
1929,67940,GetCryptoJobMode,1,node.crypto.GetCryptoJobMode,CryptoJobMode node.crypto.GetCryptoJobMode (ANY),crypto\crypto_util.cc,"CryptoJobMode GetCryptoJobMode(v8::Local<v8::Value> args) {
  CHECK(args->IsUint32());
  uint32_t mode = args.As<v8::Uint32>()->Value();
  CHECK_LE(mode, kCryptoJobSync);
  return static_cast<CryptoJobMode>(mode);
}",694.0,699.0,1.0,1.0,6.0,5,4,6,3,0,0,1,1,0,0,,0,0,2,1,1,CryptoJobMode
1930,67968,SecureBuffer,1,node.crypto.anonymous_namespace_1.SecureBuffer,void node.crypto.anonymous_namespace_1.SecureBuffer (FunctionCallbackInfo<Value>),crypto\crypto_util.cc,"void SecureBuffer(const FunctionCallbackInfo<Value>& args) {
  CHECK(args[0]->IsUint32());
  Environment* env = Environment::GetCurrent(args);
  uint32_t len = args[0].As<Uint32>()->Value();
  void* data = OPENSSL_secure_zalloc(len);
  if (data == nullptr) {
    // There's no memory available for the allocation.
    // Return nothing.
    return;
  }
  std::shared_ptr<BackingStore> store =
      ArrayBuffer::NewBackingStore(
          data,
          len,
          [](void* data, size_t len, void* deleter_data) {
            OPENSSL_secure_clear_free(data, len);
          },
          data);
  Local<ArrayBuffer> buffer = ArrayBuffer::New(env->isolate(), store);
  args.GetReturnValue().Set(Uint8Array::New(buffer, 0, len));
}",707.0,727.0,1.0,1.0,21.0,23,7,26,12,0,0,2,2,0,0,,0,0,2,1,1,void
1931,68054,SecureHeapUsed,1,node.crypto.anonymous_namespace_3.SecureHeapUsed,void node.crypto.anonymous_namespace_3.SecureHeapUsed (FunctionCallbackInfo<Value>),crypto\crypto_util.cc,"void SecureHeapUsed(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  if (CRYPTO_secure_malloc_initialized())
    args.GetReturnValue().Set(
        BigInt::New(env->isolate(), CRYPTO_secure_used()));
}",729.0,734.0,1.0,1.0,6.0,6,3,6,4,0,0,2,2,0,0,,0,0,2,1,1,void
1932,68087,Initialize,1,node.crypto.Util.Initialize,"void node.crypto.Util.Initialize (Environment*,Local<Object>)",crypto\crypto_util.cc,"void Initialize(Environment* env, Local<Object> target) {
  Local<Context> context = env->context();
#ifndef OPENSSL_NO_ENGINE
  SetMethod(context, target, ""setEngine"", SetEngine);
#endif  // !OPENSSL_NO_ENGINE

  SetMethodNoSideEffect(context, target, ""getFipsCrypto"", GetFipsCrypto);
  SetMethod(context, target, ""setFipsCrypto"", SetFipsCrypto);
  SetMethodNoSideEffect(context, target, ""testFipsCrypto"", TestFipsCrypto);

  NODE_DEFINE_CONSTANT(target, kCryptoJobAsync);
  NODE_DEFINE_CONSTANT(target, kCryptoJobSync);

  SetMethod(context, target, ""secureBuffer"", SecureBuffer);
  SetMethod(context, target, ""secureHeapUsed"", SecureHeapUsed);
}",738.0,753.0,1.0,2.0,16.0,70,7,79,14,0,0,1,1,0,0,,0,0,4,2,2,void
1933,68331,RegisterExternalReferences,1,node.crypto.Util.RegisterExternalReferences,void node.crypto.Util.RegisterExternalReferences (ExternalReferenceRegistry*),crypto\crypto_util.cc,"void RegisterExternalReferences(ExternalReferenceRegistry* registry) {
#ifndef OPENSSL_NO_ENGINE
  registry->Register(SetEngine);
#endif  // !OPENSSL_NO_ENGINE

  registry->Register(GetFipsCrypto);
  registry->Register(SetFipsCrypto);
  registry->Register(TestFipsCrypto);
  registry->Register(SecureBuffer);
  registry->Register(SecureHeapUsed);
}",754.0,764.0,1.0,1.0,11.0,6,1,7,2,0,0,1,1,0,0,,0,0,2,1,1,void
1934,68454,ManagedX509,1,node.crypto.ManagedX509.ManagedX509,ANY node.crypto.ManagedX509.ManagedX509 (X509Pointer),crypto\crypto_x509.cc,"ManagedX509::ManagedX509(const ManagedX509& that) {
  *this = that;
}",35.0,37.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
1935,68468,operator =,1,node.crypto.ManagedX509.operator =,ManagedX509 node.crypto.ManagedX509.operator = (ManagedX509),crypto\crypto_x509.cc,"ManagedX509& ManagedX509::operator=(const ManagedX509& that) {
  cert_.reset(that.get());

  if (cert_)
    X509_up_ref(cert_.get());

  return *this;
}",39.0,46.0,1.0,1.0,8.0,4,2,4,2,0,0,2,2,0,0,,0,0,2,1,1,ManagedX509
1936,68492,MemoryInfo,1,node.crypto.ManagedX509.MemoryInfo,void node.crypto.ManagedX509.MemoryInfo (MemoryTracker*),crypto\crypto_x509.cc,"void ManagedX509::MemoryInfo(MemoryTracker* tracker) const {
  // This is an approximation based on the der encoding size.
  int size = i2d_X509(cert_.get(), nullptr);
  tracker->TrackFieldWithSize(""cert"", size);
}",48.0,52.0,1.0,1.0,5.0,3,3,4,3,0,0,1,1,0,0,,0,0,2,1,1,void
1937,68513,Fingerprint,1,node.crypto.anonymous_namespace_1.Fingerprint,void node.crypto.anonymous_namespace_1.Fingerprint<const EVP_MD*(*)()> (FunctionCallbackInfo<Value>),crypto\crypto_x509.cc,"void Fingerprint(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
  Local<Value> ret;
  if (GetFingerprintDigest(env, algo(), cert->get()).ToLocal(&ret))
    args.GetReturnValue().Set(ret);
}",56.0,63.0,1.0,1.0,8.0,11,6,13,7,0,0,2,2,0,0,,0,0,2,1,1,void
1938,68561,GetConstructorTemplate,1,node.crypto.X509Certificate.GetConstructorTemplate,Local<FunctionTemplate> node.crypto.X509Certificate.GetConstructorTemplate (Environment*),crypto\crypto_x509.cc,"Local<FunctionTemplate> X509Certificate::GetConstructorTemplate(
    Environment* env) {
  Local<FunctionTemplate> tmpl = env->x509_constructor_template();
  if (tmpl.IsEmpty()) {
    Isolate* isolate = env->isolate();
    tmpl = NewFunctionTemplate(isolate, nullptr);
    tmpl->InstanceTemplate()->SetInternalFieldCount(
        BaseObject::kInternalFieldCount);
    tmpl->SetClassName(
        FIXED_ONE_BYTE_STRING(env->isolate(), ""X509Certificate""));
    SetProtoMethod(isolate, tmpl, ""subject"", Subject);
    SetProtoMethod(isolate, tmpl, ""subjectAltName"", SubjectAltName);
    SetProtoMethod(isolate, tmpl, ""infoAccess"", InfoAccess);
    SetProtoMethod(isolate, tmpl, ""issuer"", Issuer);
    SetProtoMethod(isolate, tmpl, ""validTo"", ValidTo);
    SetProtoMethod(isolate, tmpl, ""validFrom"", ValidFrom);
    SetProtoMethod(isolate, tmpl, ""fingerprint"", Fingerprint<EVP_sha1>);
    SetProtoMethod(isolate, tmpl, ""fingerprint256"", Fingerprint<EVP_sha256>);
    SetProtoMethod(isolate, tmpl, ""fing...",66.0,102.0,1.0,1.0,37.0,14,5,85,29,0,0,2,2,0,0,,0,0,2,1,1,Local<FunctionTemplate>
1939,68736,HasInstance,1,node.crypto.X509Certificate.HasInstance,"bool node.crypto.X509Certificate.HasInstance (Environment*,Local<Object>)",crypto\crypto_x509.cc,"bool X509Certificate::HasInstance(Environment* env, Local<Object> object) {
  return GetConstructorTemplate(env)->HasInstance(object);
}",104.0,106.0,1.0,1.0,3.0,1,1,2,2,0,0,1,1,0,0,,0,0,4,2,2,bool
1940,68751,GetCert,1,node.crypto.X509Certificate.GetCert,"MaybeLocal<Object> node.crypto.X509Certificate.GetCert (Environment*,SSLPointer)",crypto\crypto_x509.cc,"MaybeLocal<Object> X509Certificate::GetCert(
    Environment* env,
    const SSLPointer& ssl) {
  ClearErrorOnReturn clear_error_on_return;
  X509* cert = SSL_get_certificate(ssl.get());
  if (cert == nullptr)
    return MaybeLocal<Object>();

  X509Pointer ptr(X509_dup(cert));
  return New(env, std::move(ptr));
}",133.0,143.0,1.0,1.0,11.0,4,3,7,5,0,0,2,2,0,0,,0,0,4,2,2,MaybeLocal<Object>
1941,68785,GetPeerCert,1,node.crypto.X509Certificate.GetPeerCert,"MaybeLocal<Object> node.crypto.X509Certificate.GetPeerCert (Environment*,SSLPointer,GetPeerCertificateFlag)",crypto\crypto_x509.cc,"MaybeLocal<Object> X509Certificate::GetPeerCert(
    Environment* env,
    const SSLPointer& ssl,
    GetPeerCertificateFlag flag) {
  ClearErrorOnReturn clear_error_on_return;
  MaybeLocal<Object> maybe_cert;

  bool is_server =
      static_cast<int>(flag) & static_cast<int>(GetPeerCertificateFlag::SERVER);

  X509Pointer cert(is_server ? SSL_get_peer_certificate(ssl.get()) : nullptr);
  STACK_OF(X509)* ssl_certs = SSL_get_peer_cert_chain(ssl.get());
  if (!cert && (ssl_certs == nullptr || sk_X509_num(ssl_certs) == 0))
    return MaybeLocal<Object>();

  std::vector<Local<Value>> certs;

  if (!cert) {
    cert.reset(sk_X509_value(ssl_certs, 0));
    sk_X509_delete(ssl_certs, 0);
  }

  return sk_X509_num(ssl_certs)
      ? New(env, std::move(cert), ssl_certs)
      : New(env, std::move(cert));
}",145.0,170.0,1.0,1.0,26.0,26,13,30,15,0,0,3,3,0,0,,0,0,6,3,3,MaybeLocal<Object>
1942,68887,Parse,1,node.crypto.X509Certificate.Parse,void node.crypto.X509Certificate.Parse (FunctionCallbackInfo<Value>),crypto\crypto_x509.cc,"void X509Certificate::Parse(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  CHECK(args[0]->IsArrayBufferView());
  ArrayBufferViewContents<unsigned char> buf(args[0].As<ArrayBufferView>());
  const unsigned char* data = buf.data();
  unsigned data_len = buf.length();

  ClearErrorOnReturn clear_error_on_return;
  BIOPointer bio(LoadBIO(env, args[0]));
  if (!bio)
    return ThrowCryptoError(env, ERR_get_error());

  Local<Object> cert;

  X509Pointer pem(PEM_read_bio_X509_AUX(
      bio.get(), nullptr, NoPasswordCallback, nullptr));
  if (!pem) {
    // Try as DER, but return the original PEM failure if it isn't DER.
    MarkPopErrorOnReturn mark_here;

    X509Pointer der(d2i_X509(nullptr, &data, data_len));
    if (!der)
      return ThrowCryptoError(env, ERR_get_error());

    if (!X509Certificate::New(env, std::move(der)).ToLocal(&cert))
      return;
  } else if (!X509Certificate::New(env, std::move(pem)).ToLocal(&cert)) {
    r...",172.0,204.0,1.0,1.0,33.0,25,8,30,15,0,0,5,7,0,0,,0,0,2,1,1,void
1943,69028,Subject,1,node.crypto.X509Certificate.Subject,void node.crypto.X509Certificate.Subject (FunctionCallbackInfo<Value>),crypto\crypto_x509.cc,"void X509Certificate::Subject(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
  BIOPointer bio(BIO_new(BIO_s_mem()));
  CHECK(bio);
  Local<Value> ret;
  if (GetSubject(env, bio, cert->get()).ToLocal(&ret))
    args.GetReturnValue().Set(ret);
}",206.0,215.0,1.0,1.0,10.0,11,6,15,8,0,0,2,2,0,0,,0,0,2,1,1,void
1944,69047,bio,1,node.crypto.X509Certificate.Subject.bio,BIOPointer node.crypto.X509Certificate.Subject.bio (BIO_new),crypto\crypto_x509.cc,BIOPointer bio(BIO_new(BIO_s_mem()));,210.0,210.0,14.0,38.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,BIOPointer
1945,69083,Issuer,1,node.crypto.X509Certificate.Issuer,void node.crypto.X509Certificate.Issuer (FunctionCallbackInfo<Value>),crypto\crypto_x509.cc,"void X509Certificate::Issuer(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
  BIOPointer bio(BIO_new(BIO_s_mem()));
  CHECK(bio);
  Local<Value> ret;
  if (GetIssuerString(env, bio, cert->get()).ToLocal(&ret))
    args.GetReturnValue().Set(ret);
}",217.0,226.0,1.0,1.0,10.0,11,6,15,8,0,0,2,2,0,0,,0,0,2,1,1,void
1946,69102,bio,1,node.crypto.X509Certificate.Issuer.bio,BIOPointer node.crypto.X509Certificate.Issuer.bio (BIO_new),crypto\crypto_x509.cc,BIOPointer bio(BIO_new(BIO_s_mem()));,221.0,221.0,14.0,38.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,BIOPointer
1947,69138,SubjectAltName,1,node.crypto.X509Certificate.SubjectAltName,void node.crypto.X509Certificate.SubjectAltName (FunctionCallbackInfo<Value>),crypto\crypto_x509.cc,"void X509Certificate::SubjectAltName(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
  BIOPointer bio(BIO_new(BIO_s_mem()));
  CHECK(bio);
  Local<Value> ret;
  if (GetSubjectAltNameString(env, bio, cert->get()).ToLocal(&ret))
    args.GetReturnValue().Set(ret);
}",228.0,237.0,1.0,1.0,10.0,11,6,15,8,0,0,2,2,0,0,,0,0,2,1,1,void
1948,69157,bio,1,node.crypto.X509Certificate.SubjectAltName.bio,BIOPointer node.crypto.X509Certificate.SubjectAltName.bio (BIO_new),crypto\crypto_x509.cc,BIOPointer bio(BIO_new(BIO_s_mem()));,232.0,232.0,14.0,38.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,BIOPointer
1949,69193,InfoAccess,1,node.crypto.X509Certificate.InfoAccess,void node.crypto.X509Certificate.InfoAccess (FunctionCallbackInfo<Value>),crypto\crypto_x509.cc,"void X509Certificate::InfoAccess(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
  BIOPointer bio(BIO_new(BIO_s_mem()));
  CHECK(bio);
  Local<Value> ret;
  if (GetInfoAccessString(env, bio, cert->get()).ToLocal(&ret))
    args.GetReturnValue().Set(ret);
}",239.0,248.0,1.0,1.0,10.0,11,6,15,8,0,0,2,2,0,0,,0,0,2,1,1,void
1950,69212,bio,1,node.crypto.X509Certificate.InfoAccess.bio,BIOPointer node.crypto.X509Certificate.InfoAccess.bio (BIO_new),crypto\crypto_x509.cc,BIOPointer bio(BIO_new(BIO_s_mem()));,243.0,243.0,14.0,38.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,BIOPointer
1951,69248,ValidFrom,1,node.crypto.X509Certificate.ValidFrom,void node.crypto.X509Certificate.ValidFrom (FunctionCallbackInfo<Value>),crypto\crypto_x509.cc,"void X509Certificate::ValidFrom(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
  BIOPointer bio(BIO_new(BIO_s_mem()));
  CHECK(bio);
  Local<Value> ret;
  if (GetValidFrom(env, cert->get(), bio).ToLocal(&ret))
    args.GetReturnValue().Set(ret);
}",250.0,259.0,1.0,1.0,10.0,11,6,15,8,0,0,2,2,0,0,,0,0,2,1,1,void
1952,69267,bio,1,node.crypto.X509Certificate.ValidFrom.bio,BIOPointer node.crypto.X509Certificate.ValidFrom.bio (BIO_new),crypto\crypto_x509.cc,BIOPointer bio(BIO_new(BIO_s_mem()));,254.0,254.0,14.0,38.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,BIOPointer
1953,69303,ValidTo,1,node.crypto.X509Certificate.ValidTo,void node.crypto.X509Certificate.ValidTo (FunctionCallbackInfo<Value>),crypto\crypto_x509.cc,"void X509Certificate::ValidTo(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
  BIOPointer bio(BIO_new(BIO_s_mem()));
  CHECK(bio);
  Local<Value> ret;
  if (GetValidTo(env, cert->get(), bio).ToLocal(&ret))
    args.GetReturnValue().Set(ret);
}",261.0,270.0,1.0,1.0,10.0,11,6,15,8,0,0,2,2,0,0,,0,0,2,1,1,void
1954,69322,bio,1,node.crypto.X509Certificate.ValidTo.bio,BIOPointer node.crypto.X509Certificate.ValidTo.bio (BIO_new),crypto\crypto_x509.cc,BIOPointer bio(BIO_new(BIO_s_mem()));,265.0,265.0,14.0,38.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,BIOPointer
1955,69358,KeyUsage,1,node.crypto.X509Certificate.KeyUsage,void node.crypto.X509Certificate.KeyUsage (FunctionCallbackInfo<Value>),crypto\crypto_x509.cc,"void X509Certificate::KeyUsage(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
  Local<Value> ret;
  if (GetKeyUsage(env, cert->get()).ToLocal(&ret))
    args.GetReturnValue().Set(ret);
}",272.0,279.0,1.0,1.0,8.0,11,6,13,7,0,0,2,2,0,0,,0,0,2,1,1,void
1956,69405,SerialNumber,1,node.crypto.X509Certificate.SerialNumber,void node.crypto.X509Certificate.SerialNumber (FunctionCallbackInfo<Value>),crypto\crypto_x509.cc,"void X509Certificate::SerialNumber(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
  Local<Value> ret;
  if (GetSerialNumber(env, cert->get()).ToLocal(&ret))
    args.GetReturnValue().Set(ret);
}",281.0,288.0,1.0,1.0,8.0,11,6,13,7,0,0,2,2,0,0,,0,0,2,1,1,void
1957,69452,Raw,1,node.crypto.X509Certificate.Raw,void node.crypto.X509Certificate.Raw (FunctionCallbackInfo<Value>),crypto\crypto_x509.cc,"void X509Certificate::Raw(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
  Local<Value> ret;
  if (GetRawDERCertificate(env, cert->get()).ToLocal(&ret))
    args.GetReturnValue().Set(ret);
}",290.0,297.0,1.0,1.0,8.0,11,6,13,7,0,0,2,2,0,0,,0,0,2,1,1,void
1958,69499,PublicKey,1,node.crypto.X509Certificate.PublicKey,void node.crypto.X509Certificate.PublicKey (FunctionCallbackInfo<Value>),crypto\crypto_x509.cc,"void X509Certificate::PublicKey(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());

  EVPKeyPointer pkey(X509_get_pubkey(cert->get()));
  ManagedEVPPKey epkey(std::move(pkey));
  std::shared_ptr<KeyObjectData> key_data =
      KeyObjectData::CreateAsymmetric(kKeyTypePublic, epkey);

  Local<Value> ret;
  if (KeyObjectHandle::Create(env, key_data).ToLocal(&ret))
    args.GetReturnValue().Set(ret);
}",299.0,312.0,1.0,1.0,14.0,18,6,23,14,0,0,2,2,0,0,,0,0,2,1,1,void
1959,69574,Pem,1,node.crypto.X509Certificate.Pem,void node.crypto.X509Certificate.Pem (FunctionCallbackInfo<Value>),crypto\crypto_x509.cc,"void X509Certificate::Pem(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
  BIOPointer bio(BIO_new(BIO_s_mem()));
  CHECK(bio);
  if (PEM_write_bio_X509(bio.get(), cert->get()))
    args.GetReturnValue().Set(ToV8Value(env, bio));
}",314.0,322.0,1.0,1.0,9.0,8,4,11,5,0,0,2,2,0,0,,0,0,2,1,1,void
1960,69593,bio,1,node.crypto.X509Certificate.Pem.bio,BIOPointer node.crypto.X509Certificate.Pem.bio (BIO_new),crypto\crypto_x509.cc,BIOPointer bio(BIO_new(BIO_s_mem()));,318.0,318.0,14.0,38.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,BIOPointer
1961,69623,CheckCA,1,node.crypto.X509Certificate.CheckCA,void node.crypto.X509Certificate.CheckCA (FunctionCallbackInfo<Value>),crypto\crypto_x509.cc,"void X509Certificate::CheckCA(const FunctionCallbackInfo<Value>& args) {
  X509Certificate* cert;
  ClearErrorOnReturn clear_error_on_return;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
  args.GetReturnValue().Set(X509_check_ca(cert->get()) == 1);
}",324.0,329.0,1.0,1.0,6.0,6,4,4,2,0,0,1,1,0,0,,0,0,2,1,1,void
1962,69651,CheckHost,1,node.crypto.X509Certificate.CheckHost,void node.crypto.X509Certificate.CheckHost (FunctionCallbackInfo<Value>),crypto\crypto_x509.cc,"void X509Certificate::CheckHost(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());

  CHECK(args[0]->IsString());  // name
  CHECK(args[1]->IsUint32());  // flags

  Utf8Value name(env->isolate(), args[0]);
  uint32_t flags = args[1].As<Uint32>()->Value();
  char* peername;

  switch (X509_check_host(
              cert->get(),
              *name,
              name.length(),
              flags,
              &peername)) {
    case 1:  {  // Match!
      Local<Value> ret = args[0];
      if (peername != nullptr) {
        ret = OneByteString(env->isolate(), peername);
        OPENSSL_free(peername);
      }
      return args.GetReturnValue().Set(ret);
    }
    case 0:  // No Match!
      return;  // No return value is set
    case -2:  // Error!
      return THROW_ERR_INVALID_ARG_VALUE(env, ""Invalid name"");
    default:  // Error!
      return THROW_ERR_CRYPTO_OPE...",331.0,364.0,1.0,1.0,34.0,28,10,29,10,0,0,3,4,0,0,,0,0,2,1,1,void
1963,69774,CheckEmail,1,node.crypto.X509Certificate.CheckEmail,void node.crypto.X509Certificate.CheckEmail (FunctionCallbackInfo<Value>),crypto\crypto_x509.cc,"void X509Certificate::CheckEmail(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());

  CHECK(args[0]->IsString());  // name
  CHECK(args[1]->IsUint32());  // flags

  Utf8Value name(env->isolate(), args[0]);
  uint32_t flags = args[1].As<Uint32>()->Value();

  switch (X509_check_email(
              cert->get(),
              *name,
              name.length(),
              flags)) {
    case 1:  // Match!
      return args.GetReturnValue().Set(args[0]);
    case 0:  // No Match!
      return;  // No return value is set
    case -2:  // Error!
      return THROW_ERR_INVALID_ARG_VALUE(env, ""Invalid name"");
    default:  // Error!
      return THROW_ERR_CRYPTO_OPERATION_FAILED(env);
  }
}",366.0,391.0,1.0,1.0,26.0,21,7,19,6,0,0,2,2,0,0,,0,0,2,1,1,void
1964,69871,CheckIP,1,node.crypto.X509Certificate.CheckIP,void node.crypto.X509Certificate.CheckIP (FunctionCallbackInfo<Value>),crypto\crypto_x509.cc,"void X509Certificate::CheckIP(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());

  CHECK(args[0]->IsString());  // IP
  CHECK(args[1]->IsUint32());  // flags

  Utf8Value name(env->isolate(), args[0]);
  uint32_t flags = args[1].As<Uint32>()->Value();

  switch (X509_check_ip_asc(cert->get(), *name, flags)) {
    case 1:  // Match!
      return args.GetReturnValue().Set(args[0]);
    case 0:  // No Match!
      return;  // No return value is set
    case -2:  // Error!
      return THROW_ERR_INVALID_ARG_VALUE(env, ""Invalid IP"");
    default:  // Error!
      return THROW_ERR_CRYPTO_OPERATION_FAILED(env);
  }
}",393.0,414.0,1.0,1.0,22.0,20,7,18,6,0,0,2,2,0,0,,0,0,2,1,1,void
1965,69964,CheckIssued,1,node.crypto.X509Certificate.CheckIssued,void node.crypto.X509Certificate.CheckIssued (FunctionCallbackInfo<Value>),crypto\crypto_x509.cc,"void X509Certificate::CheckIssued(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());

  CHECK(args[0]->IsObject());
  CHECK(X509Certificate::HasInstance(env, args[0].As<Object>()));

  X509Certificate* issuer;
  ASSIGN_OR_RETURN_UNWRAP(&issuer, args[0]);

  ClearErrorOnReturn clear_error_on_return;

  args.GetReturnValue().Set(
    X509_check_issued(issuer->get(), cert->get()) == X509_V_OK);
}",416.0,431.0,1.0,1.0,16.0,16,6,15,7,0,0,1,1,0,0,,0,0,2,1,1,void
1966,70030,CheckPrivateKey,1,node.crypto.X509Certificate.CheckPrivateKey,void node.crypto.X509Certificate.CheckPrivateKey (FunctionCallbackInfo<Value>),crypto\crypto_x509.cc,"void X509Certificate::CheckPrivateKey(const FunctionCallbackInfo<Value>& args) {
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());

  CHECK(args[0]->IsObject());
  KeyObjectHandle* key;
  ASSIGN_OR_RETURN_UNWRAP(&key, args[0]);
  CHECK_EQ(key->Data()->GetKeyType(), kKeyTypePrivate);

  ClearErrorOnReturn clear_error_on_return;

  args.GetReturnValue().Set(
      X509_check_private_key(
          cert->get(),
          key->Data()->GetAsymmetricKey().get()) == 1);
}",433.0,448.0,1.0,1.0,16.0,15,5,10,4,0,0,1,1,0,0,,0,0,2,1,1,void
1967,70091,Verify,1,node.crypto.X509Certificate.Verify,void node.crypto.X509Certificate.Verify (FunctionCallbackInfo<Value>),crypto\crypto_x509.cc,"void X509Certificate::Verify(const FunctionCallbackInfo<Value>& args) {
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());

  CHECK(args[0]->IsObject());
  KeyObjectHandle* key;
  ASSIGN_OR_RETURN_UNWRAP(&key, args[0]);
  CHECK_EQ(key->Data()->GetKeyType(), kKeyTypePublic);

  ClearErrorOnReturn clear_error_on_return;

  args.GetReturnValue().Set(
      X509_verify(
          cert->get(),
          key->Data()->GetAsymmetricKey().get()) > 0);
}",450.0,465.0,1.0,1.0,16.0,15,5,10,4,0,0,1,1,0,0,,0,0,2,1,1,void
1968,70152,ToLegacy,1,node.crypto.X509Certificate.ToLegacy,void node.crypto.X509Certificate.ToLegacy (FunctionCallbackInfo<Value>),crypto\crypto_x509.cc,"void X509Certificate::ToLegacy(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
  ClearErrorOnReturn clear_error_on_return;
  Local<Value> ret;
  if (X509ToObject(env, cert->get()).ToLocal(&ret))
    args.GetReturnValue().Set(ret);
}",467.0,475.0,1.0,1.0,9.0,11,6,13,7,0,0,2,2,0,0,,0,0,2,1,1,void
1969,70200,GetIssuerCert,1,node.crypto.X509Certificate.GetIssuerCert,void node.crypto.X509Certificate.GetIssuerCert (FunctionCallbackInfo<Value>),crypto\crypto_x509.cc,"void X509Certificate::GetIssuerCert(const FunctionCallbackInfo<Value>& args) {
  X509Certificate* cert;
  ASSIGN_OR_RETURN_UNWRAP(&cert, args.Holder());
  if (cert->issuer_cert_)
    args.GetReturnValue().Set(cert->issuer_cert_->object());
}",477.0,482.0,1.0,1.0,6.0,7,3,5,2,0,0,2,2,0,0,,0,0,2,1,1,void
1970,70232,MemoryInfo,1,node.crypto.X509Certificate.MemoryInfo,void node.crypto.X509Certificate.MemoryInfo (MemoryTracker*),crypto\crypto_x509.cc,"void X509Certificate::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackField(""cert"", cert_);
}",505.0,507.0,1.0,1.0,3.0,1,1,2,2,0,0,1,1,0,0,,0,0,2,1,1,void
1971,70243,Deserialize,1,node.crypto.X509Certificate.X509CertificateTransferData.Deserialize,"BaseObjectPtr<BaseObject> node.crypto.X509Certificate.X509CertificateTransferData.Deserialize (Environment*,Local<Context>,ANY)",crypto\crypto_x509.cc,"BaseObjectPtr<BaseObject>
X509Certificate::X509CertificateTransferData::Deserialize(
    Environment* env,
    Local<Context> context,
    std::unique_ptr<worker::TransferData> self) {
  if (context != env->context()) {
    THROW_ERR_MESSAGE_TARGET_CONTEXT_UNAVAILABLE(env);
    return {};
  }

  Local<Value> handle;
  if (!X509Certificate::New(env, data_).ToLocal(&handle))
    return {};

  return BaseObjectPtr<BaseObject>(
      Unwrap<X509Certificate>(handle.As<Object>()));
}",509.0,525.0,1.0,1.0,17.0,13,7,15,10,0,0,3,3,0,0,,0,0,6,3,3,BaseObjectPtr<BaseObject>
1972,70294,GetTransferMode,1,node.crypto.X509Certificate.GetTransferMode,TransferMode node.crypto.X509Certificate.GetTransferMode (),crypto\crypto_x509.cc,"BaseObject::TransferMode X509Certificate::GetTransferMode() const {
  return BaseObject::TransferMode::kCloneable;
}",528.0,530.0,1.0,1.0,3.0,2,1,2,2,0,0,1,1,0,0,,0,0,0,0,0,TransferMode
1973,70304,CloneForMessaging,1,node.crypto.X509Certificate.CloneForMessaging,unique_ptr<worker::TransferData> node.crypto.X509Certificate.CloneForMessaging (),crypto\crypto_x509.cc,"std::unique_ptr<worker::TransferData> X509Certificate::CloneForMessaging()
    const {
  return std::make_unique<X509CertificateTransferData>(cert_);
}",532.0,535.0,1.0,1.0,4.0,3,3,3,3,0,0,1,1,0,0,,0,0,0,0,0,unique_ptr<worker.TransferData>
1974,70316,Initialize,1,node.crypto.X509Certificate.Initialize,"void node.crypto.X509Certificate.Initialize (Environment*,Local<Object>)",crypto\crypto_x509.cc,"void X509Certificate::Initialize(Environment* env, Local<Object> target) {
  SetMethod(env->context(), target, ""parseX509"", X509Certificate::Parse);

  NODE_DEFINE_CONSTANT(target, X509_CHECK_FLAG_ALWAYS_CHECK_SUBJECT);
  NODE_DEFINE_CONSTANT(target, X509_CHECK_FLAG_NEVER_CHECK_SUBJECT);
  NODE_DEFINE_CONSTANT(target, X509_CHECK_FLAG_NO_WILDCARDS);
  NODE_DEFINE_CONSTANT(target, X509_CHECK_FLAG_NO_PARTIAL_WILDCARDS);
  NODE_DEFINE_CONSTANT(target, X509_CHECK_FLAG_MULTI_LABEL_WILDCARDS);
  NODE_DEFINE_CONSTANT(target, X509_CHECK_FLAG_SINGLE_LABEL_SUBDOMAINS);
}",538.0,547.0,1.0,1.0,10.0,2,2,15,9,0,0,1,1,0,0,,0,0,4,2,2,void
1975,70350,RegisterExternalReferences,1,node.crypto.X509Certificate.RegisterExternalReferences,void node.crypto.X509Certificate.RegisterExternalReferences (ExternalReferenceRegistry*),crypto\crypto_x509.cc,"void X509Certificate::RegisterExternalReferences(
    ExternalReferenceRegistry* registry) {
  registry->Register(X509Certificate::Parse);
  registry->Register(Subject);
  registry->Register(SubjectAltName);
  registry->Register(InfoAccess);
  registry->Register(Issuer);
  registry->Register(ValidTo);
  registry->Register(ValidFrom);
  registry->Register(Fingerprint<EVP_sha1>);
  registry->Register(Fingerprint<EVP_sha256>);
  registry->Register(Fingerprint<EVP_sha512>);
  registry->Register(KeyUsage);
  registry->Register(SerialNumber);
  registry->Register(Pem);
  registry->Register(Raw);
  registry->Register(PublicKey);
  registry->Register(CheckCA);
  registry->Register(CheckHost);
  registry->Register(CheckEmail);
  registry->Register(CheckIP);
  registry->Register(CheckIssued);
  registry->Register(CheckPrivateKey);
  registry->Register(Verify);
  registry->Register(ToLegacy);
  registry->Register(GetIssuerCert);
}",549.0,575.0,1.0,1.0,27.0,25,2,48,25,0,0,1,1,0,0,,0,0,2,1,1,void
1976,70495,<lambda>0,1,node.anonymous_namespace_32.IdempotentDataQueueReader.Pull.<lambda>0,ANY node.anonymous_namespace_32.IdempotentDataQueueReader.Pull.<lambda>0 (uint64_t),dataqueue\queue.cc,[](uint64_t) {},211.0,211.0,60.0,74.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
1977,70502,<lambda>1,1,node.anonymous_namespace_33.IdempotentDataQueueReader.Pull.<lambda>1,ANY node.anonymous_namespace_33.IdempotentDataQueueReader.Pull.<lambda>1 (uint64_t),dataqueue\queue.cc,[](uint64_t) {},224.0,224.0,62.0,76.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
1978,70508,<lambda>2,1,node.anonymous_namespace_35.IdempotentDataQueueReader.Pull.<lambda>2,ANY node.anonymous_namespace_35.IdempotentDataQueueReader.Pull.<lambda>2 (uint64_t),dataqueue\queue.cc,[](uint64_t) {},240.0,240.0,46.0,60.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
1979,70514,<lambda>4,1,node.anonymous_namespace_37.IdempotentDataQueueReader.Pull..<lambda>4,ANY node.anonymous_namespace_37.IdempotentDataQueueReader.Pull..<lambda>4 (uint64_t),dataqueue\queue.cc,[](uint64_t) {},272.0,272.0,49.0,63.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
1980,70520,<lambda>3,1,node.anonymous_namespace_36.IdempotentDataQueueReader.Pull.<lambda>3,"ANY node.anonymous_namespace_36.IdempotentDataQueueReader.Pull.<lambda>3 (int,ANY*,uint64_t,Done)",dataqueue\queue.cc,"[this, next = std::move(next)](
            int status, const DataQueue::Vec* vecs, uint64_t count, Done done) {
          pull_pending_ = false;
          // In each of these cases, we do not expect that the source will
          // actually have provided any actual data.
          CHECK_IMPLIES(status == bob::Status::STATUS_BLOCK ||
                            status == bob::Status::STATUS_WAIT ||
                            status == bob::Status::STATUS_EOS,
                        vecs == nullptr && count == 0);
          if (status == bob::Status::STATUS_EOS) {
            uint32_t current = current_index_.value() + 1;
            current_reader_ = nullptr;
            // We have reached the end of this entry. If this is the last entry,
            // then we are done. Otherwise, we advance the current_index_, clear
            // the current_reader_ and wait for the next read.

            if (current == data_queue_->entries_.size()) {
              // Yes, this was the final ...",247.0,277.0,9.0,9.0,31.0,29,7,31,14,0,4,3,4,0,0,,0,4,8,4,4,ANY
1981,70635,<lambda>5,1,node.anonymous_namespace_46.NonIdempotentDataQueueReader.Pull.<lambda>5,ANY node.anonymous_namespace_46.NonIdempotentDataQueueReader.Pull.<lambda>5 (uint64_t),dataqueue\queue.cc,[](uint64_t) {},364.0,364.0,60.0,74.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
1982,70642,<lambda>6,1,node.anonymous_namespace_47.NonIdempotentDataQueueReader.Pull.<lambda>6,ANY node.anonymous_namespace_47.NonIdempotentDataQueueReader.Pull.<lambda>6 (uint64_t),dataqueue\queue.cc,[](uint64_t) {},377.0,377.0,64.0,78.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
1983,70648,<lambda>7,1,node.anonymous_namespace_48.NonIdempotentDataQueueReader.Pull.<lambda>7,ANY node.anonymous_namespace_48.NonIdempotentDataQueueReader.Pull.<lambda>7 (uint64_t),dataqueue\queue.cc,[](uint64_t) {},390.0,390.0,54.0,68.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
1984,70654,<lambda>8,1,node.anonymous_namespace_49.NonIdempotentDataQueueReader.Pull.<lambda>8,ANY node.anonymous_namespace_49.NonIdempotentDataQueueReader.Pull.<lambda>8 (uint64_t),dataqueue\queue.cc,[](uint64_t) {},403.0,403.0,60.0,74.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
1985,70660,<lambda>9,1,node.anonymous_namespace_51.NonIdempotentDataQueueReader.Pull.<lambda>9,ANY node.anonymous_namespace_51.NonIdempotentDataQueueReader.Pull.<lambda>9 (uint64_t),dataqueue\queue.cc,[](uint64_t) {},409.0,409.0,46.0,60.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
1986,70666,<lambda>11,1,node.anonymous_namespace_53.NonIdempotentDataQueueReader.Pull..<lambda>11,ANY node.anonymous_namespace_53.NonIdempotentDataQueueReader.Pull..<lambda>11 (uint64_t),dataqueue\queue.cc,[](uint64_t) {},432.0,432.0,49.0,63.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
1987,70672,<lambda>10,1,node.anonymous_namespace_52.NonIdempotentDataQueueReader.Pull.<lambda>10,"ANY node.anonymous_namespace_52.NonIdempotentDataQueueReader.Pull.<lambda>10 (int,ANY*,uint64_t,Done)",dataqueue\queue.cc,"[this, next = std::move(next)](
            int status, const DataQueue::Vec* vecs, uint64_t count, Done done) {
          pull_pending_ = false;

          // In each of these cases, we do not expect that the source will
          // actually have provided any actual data.
          CHECK_IMPLIES(status == bob::Status::STATUS_BLOCK ||
                            status == bob::Status::STATUS_WAIT ||
                            status == bob::Status::STATUS_EOS,
                        vecs == nullptr && count == 0);
          if (status == bob::Status::STATUS_EOS) {
            data_queue_->entries_.erase(data_queue_->entries_.begin());
            ended_ = data_queue_->entries_.empty();
            current_reader_ = nullptr;
            if (!ended_) status = bob::Status::STATUS_CONTINUE;
            std::move(next)(status, nullptr, 0, [](uint64_t) {});
            return;
          }

          // Now that we have updated this readers state, we can forward
          // everything ...",417.0,439.0,9.0,9.0,23.0,33,7,34,12,0,4,3,4,1,0,,0,4,8,4,4,ANY
1988,70786,<lambda>12,1,node.anonymous_namespace_60.EmptyEntry.EmptyReader.Pull.<lambda>12,ANY node.anonymous_namespace_60.EmptyEntry.EmptyReader.Pull.<lambda>12 (uint64_t),dataqueue\queue.cc,[](uint64_t) {},516.0,516.0,62.0,76.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
1989,70793,<lambda>13,1,node.anonymous_namespace_61.EmptyEntry.EmptyReader.Pull.<lambda>13,ANY node.anonymous_namespace_61.EmptyEntry.EmptyReader.Pull.<lambda>13 (uint64_t),dataqueue\queue.cc,[](uint64_t) {},522.0,522.0,53.0,67.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
1990,70799,<lambda>14,1,node.anonymous_namespace_77.InMemoryEntry.InMemoryReader.Pull.<lambda>14,ANY node.anonymous_namespace_77.InMemoryEntry.InMemoryReader.Pull.<lambda>14 (uint64_t),dataqueue\queue.cc,[](uint64_t) {},586.0,586.0,62.0,76.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
1991,70806,<lambda>15,1,node.anonymous_namespace_85.InMemoryEntry.slice.<lambda>15,"unique_ptr<Entry> node.anonymous_namespace_85.InMemoryEntry.slice.<lambda>15 (uint64_t,uint64_t)",dataqueue\queue.cc,"[&](uint64_t start,
                               uint64_t len) -> std::unique_ptr<Entry> {
      if (len == 0) {
        return std::make_unique<EmptyEntry>();
      }

      return std::make_unique<InMemoryEntry>(backing_store_, start, len);
    }",637.0,644.0,28.0,5.0,8.0,7,6,7,5,0,1,2,2,0,0,,0,1,4,2,2,unique_ptr<Entry>
1992,70837,<lambda>16,1,node.anonymous_namespace_107.FdEntry.Create.<lambda>16,ANY node.anonymous_namespace_107.FdEntry.Create.<lambda>16 (),dataqueue\queue.cc,[&] { uv_fs_req_cleanup(&req); },791.0,791.0,33.0,64.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,ANY
1993,70847,<lambda>17,1,node.anonymous_namespace_117.FdEntry.CheckModified.<lambda>17,ANY node.anonymous_namespace_117.FdEntry.CheckModified.<lambda>17 (),dataqueue\queue.cc,[&] { uv_fs_req_cleanup(&req); },853.0,853.0,33.0,64.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,ANY
1994,70856,<lambda>18,1,node.anonymous_namespace_120.FdEntry.ReaderImpl.Create.<lambda>18,ANY node.anonymous_namespace_120.FdEntry.ReaderImpl.Create.<lambda>18 (),dataqueue\queue.cc,[&] { uv_fs_req_cleanup(&req); },870.0,870.0,35.0,66.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,ANY
1995,70866,<lambda>19,1,node.anonymous_namespace_131.FdEntry.ReaderImpl.OnStreamRead.<lambda>19,ANY node.anonymous_namespace_131.FdEntry.ReaderImpl.OnStreamRead.<lambda>19 (uint64_t),dataqueue\queue.cc,[](uint64_t) {},921.0,921.0,56.0,70.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
1996,70872,<lambda>20,1,node.anonymous_namespace_132.FdEntry.ReaderImpl.OnStreamRead.<lambda>20,ANY node.anonymous_namespace_132.FdEntry.ReaderImpl.OnStreamRead.<lambda>20 (uint64_t),dataqueue\queue.cc,[](uint64_t) {},927.0,927.0,64.0,78.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
1997,70878,<lambda>21,1,node.anonymous_namespace_133.FdEntry.ReaderImpl.OnStreamRead.<lambda>21,ANY node.anonymous_namespace_133.FdEntry.ReaderImpl.OnStreamRead.<lambda>21 (uint64_t),dataqueue\queue.cc,[](uint64_t) {},929.0,929.0,54.0,68.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
1998,70884,<lambda>22,1,node.anonymous_namespace_135.FdEntry.ReaderImpl.OnStreamRead.<lambda>22,ANY node.anonymous_namespace_135.FdEntry.ReaderImpl.OnStreamRead.<lambda>22 (uint64_t),dataqueue\queue.cc,[store](uint64_t) {},939.0,939.0,42.0,61.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
1999,70890,<lambda>23,1,node.anonymous_namespace_137.FdEntry.ReaderImpl.Pull.<lambda>23,ANY node.anonymous_namespace_137.FdEntry.ReaderImpl.Pull.<lambda>23 (uint64_t),dataqueue\queue.cc,[](uint64_t) {},953.0,953.0,54.0,68.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
2000,70896,<lambda>24,1,node.anonymous_namespace_139.FdEntry.ReaderImpl.Pull.<lambda>24,ANY node.anonymous_namespace_139.FdEntry.ReaderImpl.Pull.<lambda>24 (uint64_t),dataqueue\queue.cc,[](uint64_t) {},959.0,959.0,48.0,62.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
2001,70902,<lambda>25,1,node.anonymous_namespace_143.FdEntry.ReaderImpl.DrainAndClose.<lambda>25,ANY node.anonymous_namespace_143.FdEntry.ReaderImpl.DrainAndClose.<lambda>25 (uint64_t),dataqueue\queue.cc,[](uint64_t) {},1000.0,1000.0,62.0,76.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
2002,70908,<lambda>26,1,node.anonymous_namespace_145.FdEntry.ReaderImpl.DequeuePendingPull.<lambda>26,ANY node.anonymous_namespace_145.FdEntry.ReaderImpl.DequeuePendingPull.<lambda>26 (),dataqueue\queue.cc,[this] { pending_pulls_.pop_front(); },1018.0,1018.0,31.0,68.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,ANY
2003,70917,<lambda>27,1,node.DataQueue.CreateIdempotent.<lambda>27,ANY node.DataQueue.CreateIdempotent.<lambda>27 (auto),dataqueue\queue.cc,"[&size](auto& item) {
    if (item == nullptr || !item->is_idempotent()) {
      return true;  // true means the entry is not valid here.
    }

    // To keep from having to iterate over the entries
    // again, we'll try calculating the size. If any
    // of the entries are unable to provide a size, then
    // we assume we cannot safely treat this entry as
    // idempotent even if it claims to be.
    if (item->size().has_value()) {
      size += item->size().value();
    } else {
      return true;  // true means the entry is not valid here.
    }

    return false;
  }",1037.0,1054.0,26.0,3.0,18.0,9,6,5,2,0,0,3,3,0,0,,0,0,2,1,1,ANY
2004,71008,get_reader,1,node.anonymous_namespace_4.EntryImpl.get_reader,ANY node.anonymous_namespace_4.EntryImpl.get_reader (),dataqueue\queue.cc,virtual std::shared_ptr<DataQueue::Reader> get_reader() = 0;,36.0,36.0,46.0,61.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
2005,71013,DataQueueImpl,1,node.anonymous_namespace_6.DataQueueImpl.DataQueueImpl,"ANY node.anonymous_namespace_6.DataQueueImpl.DataQueueImpl (ANY,uint64_t)",dataqueue\queue.cc,"DataQueueImpl(std::vector<std::unique_ptr<Entry>>&& list, uint64_t size)
      : entries_(std::move(list)),
        idempotent_(true),
        size_(size),
        capped_size_(0) {}",43.0,47.0,3.0,26.0,5.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,ANY
2006,71019,DataQueueImpl,1,node.anonymous_namespace_7.DataQueueImpl.DataQueueImpl,ANY node.anonymous_namespace_7.DataQueueImpl.DataQueueImpl (ANY),dataqueue\queue.cc,"DataQueueImpl(std::optional<uint64_t> cap = std::nullopt)
      : idempotent_(false), size_(0), capped_size_(cap) {}",54.0,55.0,3.0,58.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
2007,71024,DataQueueImpl,1,node.anonymous_namespace_8.DataQueueImpl.DataQueueImpl,ANY node.anonymous_namespace_8.DataQueueImpl.DataQueueImpl (DataQueueImpl),dataqueue\queue.cc,DataQueueImpl(const DataQueueImpl&) = delete;,58.0,58.0,3.0,47.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
2008,71029,DataQueueImpl,1,node.anonymous_namespace_9.DataQueueImpl.DataQueueImpl,ANY node.anonymous_namespace_9.DataQueueImpl.DataQueueImpl (DataQueueImpl),dataqueue\queue.cc,DataQueueImpl(DataQueueImpl&&) = delete;,59.0,59.0,3.0,42.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
2009,71034,operator =,1,node.anonymous_namespace_10.DataQueueImpl.operator =,DataQueueImpl node.anonymous_namespace_10.DataQueueImpl.operator = (DataQueueImpl),dataqueue\queue.cc,DataQueueImpl& operator=(const DataQueueImpl&) = delete;,60.0,60.0,3.0,58.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,DataQueueImpl
2010,71039,operator =,1,node.anonymous_namespace_11.DataQueueImpl.operator =,DataQueueImpl node.anonymous_namespace_11.DataQueueImpl.operator = (DataQueueImpl),dataqueue\queue.cc,DataQueueImpl& operator=(DataQueueImpl&&) = delete;,61.0,61.0,3.0,53.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,DataQueueImpl
2011,71044,slice,1,node.anonymous_namespace_12.DataQueueImpl.slice,"shared_ptr<DataQueue> node.anonymous_namespace_12.DataQueueImpl.slice (uint64_t,ANY)",dataqueue\queue.cc,"std::shared_ptr<DataQueue> slice(
      uint64_t start,
      std::optional<uint64_t> maybeEnd = std::nullopt) override {
    // If the data queue is not idempotent, or the size cannot be determined,
    // we cannot reasonably create a slice. Therefore, return nothing.
    if (!idempotent_ || !size_.has_value()) return nullptr;

    uint64_t size = size_.value();

    // start cannot be greater than the size.
    start = std::min(start, size);

    uint64_t end = std::max(start, std::min(maybeEnd.value_or(size), size));

    DCHECK_LE(start, end);

    uint64_t len = end - start;
    uint64_t remaining = end - start;
    std::vector<std::unique_ptr<Entry>> slices;

    if (remaining > 0) {
      for (const auto& entry : entries_) {
        // The size of every entry should be known since this is an
        // idempotent queue.
        uint64_t entrySize = entry->size().value();
        if (start > entrySize) {
          start -= entrySize;
          continue;
        }

        uin...",63.0,104.0,3.0,3.0,42.0,43,14,56,16,0,4,8,11,3,0,,0,4,4,2,2,shared_ptr<DataQueue>
2012,71203,size,1,node.anonymous_namespace_13.DataQueueImpl.size,optional<uint64_t> node.anonymous_namespace_13.DataQueueImpl.size (),dataqueue\queue.cc,std::optional<uint64_t> size() const override { return size_; },106.0,106.0,3.0,65.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,optional<uint64_t>
2013,71209,is_idempotent,1,node.anonymous_namespace_14.DataQueueImpl.is_idempotent,bool node.anonymous_namespace_14.DataQueueImpl.is_idempotent (),dataqueue\queue.cc,bool is_idempotent() const override { return idempotent_; },108.0,108.0,3.0,61.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,bool
2014,71215,is_capped,1,node.anonymous_namespace_15.DataQueueImpl.is_capped,bool node.anonymous_namespace_15.DataQueueImpl.is_capped (),dataqueue\queue.cc,bool is_capped() const override { return capped_size_.has_value(); },110.0,110.0,3.0,70.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,bool
2015,71224,append,1,node.anonymous_namespace_16.DataQueueImpl.append,optional<bool> node.anonymous_namespace_16.DataQueueImpl.append (ANY),dataqueue\queue.cc,"std::optional<bool> append(std::unique_ptr<Entry> entry) override {
    if (idempotent_) return std::nullopt;
    if (!entry) return false;

    // If this entry successfully provides a size, we can add it to our size_
    // if that has a value, otherwise, we keep uint64_t empty.
    if (entry->size().has_value() && size_.has_value()) {
      uint64_t entrySize = entry->size().value();
      uint64_t size = size_.value();
      // If capped_size_ is set, size + entrySize cannot exceed capped_size_
      // or the entry cannot be added.
      if (capped_size_.has_value() &&
          (capped_size_.value() < entrySize + size)) {
        return false;
      }
      size_ = size + entrySize;
    } else {
      // This entry cannot provide a size. We can still add it but we have to
      // clear the known size.
      size_ = std::nullopt;
    }

    entries_.push_back(std::move(entry));
    return true;
  }",112.0,136.0,3.0,3.0,25.0,20,7,19,8,0,7,5,6,4,0,,0,7,2,1,1,optional<bool>
2016,71313,cap,1,node.anonymous_namespace_17.DataQueueImpl.cap,void node.anonymous_namespace_17.DataQueueImpl.cap (uint64_t),dataqueue\queue.cc,"void cap(uint64_t limit = 0) override {
    if (is_idempotent()) return;
    // If the data queue is already capped, it is possible to call
    // cap again with a smaller size.
    if (capped_size_.has_value()) {
      capped_size_ = std::min(limit, capped_size_.value());
      return;
    }

    // Otherwise just set the limit.
    capped_size_ = limit;
  }",138.0,149.0,3.0,3.0,12.0,5,2,7,3,0,4,3,3,1,0,,0,4,2,1,1,void
2017,71343,maybeCapRemaining,1,node.anonymous_namespace_19.DataQueueImpl.maybeCapRemaining,optional<uint64_t> node.anonymous_namespace_19.DataQueueImpl.maybeCapRemaining (),dataqueue\queue.cc,"std::optional<uint64_t> maybeCapRemaining() const override {
    if (capped_size_.has_value() && size_.has_value()) {
      uint64_t capped_size = capped_size_.value();
      uint64_t size = size_.value();
      return capped_size > size ? capped_size - size : 0UL;
    }
    return std::nullopt;
  }",151.0,158.0,3.0,3.0,8.0,11,6,11,5,0,4,2,2,2,0,,0,4,0,0,0,optional<uint64_t>
2018,71385,MemoryInfo,1,node.anonymous_namespace_20.DataQueueImpl.MemoryInfo,void node.anonymous_namespace_20.DataQueueImpl.MemoryInfo (ANY*),dataqueue\queue.cc,"void MemoryInfo(node::MemoryTracker* tracker) const override {
    tracker->TrackField(
        ""entries"", entries_, ""std::vector<std::unique_ptr<Entry>>"");
  }",160.0,163.0,3.0,3.0,4.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
2019,71397,get_reader,1,node.anonymous_namespace_21.DataQueueImpl.get_reader,ANY node.anonymous_namespace_21.DataQueueImpl.get_reader (),dataqueue\queue.cc,std::shared_ptr<Reader> get_reader() override;,165.0,165.0,27.0,47.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
2020,71430,IdempotentDataQueueReader,1,node.anonymous_namespace_26.IdempotentDataQueueReader.IdempotentDataQueueReader,ANY node.anonymous_namespace_26.IdempotentDataQueueReader.IdempotentDataQueueReader (ANY),dataqueue\queue.cc,"IdempotentDataQueueReader(std::shared_ptr<DataQueueImpl> data_queue)
      : data_queue_(std::move(data_queue)) {
    CHECK(data_queue_->is_idempotent());
  }",189.0,192.0,3.0,3.0,4.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,ANY
2021,71440,IdempotentDataQueueReader,1,node.anonymous_namespace_27.IdempotentDataQueueReader.IdempotentDataQueueReader,ANY node.anonymous_namespace_27.IdempotentDataQueueReader.IdempotentDataQueueReader (IdempotentDataQueueReader),dataqueue\queue.cc,IdempotentDataQueueReader(const IdempotentDataQueueReader&) = delete;,195.0,195.0,3.0,71.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
2022,71445,IdempotentDataQueueReader,1,node.anonymous_namespace_28.IdempotentDataQueueReader.IdempotentDataQueueReader,ANY node.anonymous_namespace_28.IdempotentDataQueueReader.IdempotentDataQueueReader (IdempotentDataQueueReader),dataqueue\queue.cc,IdempotentDataQueueReader(IdempotentDataQueueReader&&) = delete;,196.0,196.0,3.0,66.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
2023,71450,operator =,1,node.anonymous_namespace_29.IdempotentDataQueueReader.operator =,IdempotentDataQueueReader node.anonymous_namespace_29.IdempotentDataQueueReader.operator = (IdempotentDataQueueReader),dataqueue\queue.cc,"IdempotentDataQueueReader& operator=(const IdempotentDataQueueReader&) =
      delete;",197.0,198.0,3.0,13.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,IdempotentDataQueueReader
2024,71455,operator =,1,node.anonymous_namespace_30.IdempotentDataQueueReader.operator =,IdempotentDataQueueReader node.anonymous_namespace_30.IdempotentDataQueueReader.operator = (IdempotentDataQueueReader),dataqueue\queue.cc,IdempotentDataQueueReader& operator=(IdempotentDataQueueReader&&) = delete;,199.0,199.0,3.0,77.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,IdempotentDataQueueReader
2025,71460,Pull,1,node.anonymous_namespace_31.IdempotentDataQueueReader.Pull,"int node.anonymous_namespace_31.IdempotentDataQueueReader.Pull (Next,int,ANY*,size_t,size_t)",dataqueue\queue.cc,"int Pull(Next next,
           int options,
           DataQueue::Vec* data,
           size_t count,
           size_t max_count_hint = bob::kMaxCountHint) override {
    std::shared_ptr<DataQueue::Reader> self = shared_from_this();

    // If ended is true, this reader has already reached the end and cannot
    // provide any more data.
    if (ended_) {
      std::move(next)(bob::Status::STATUS_EOS, nullptr, 0, [](uint64_t) {});
      return bob::Status::STATUS_EOS;
    }

    // If this is the first pull from this reader, we are first going to
    // check to see if there is anything at all to actually do.
    if (!current_index_.has_value()) {
      // First, let's check the number of entries. If there are no entries,
      // we've reached the end and have nothing to do.
      // Because this is an idempotent dataqueue, we should always know the
      // size...
      if (data_queue_->entries_.empty()) {
        ended_ = true;
        std::move(next)(bob::Status::STATUS_EOS, n...",201.0,306.0,3.0,3.0,106.0,32,7,39,17,0,8,7,9,4,0,,0,8,10,5,5,int
2026,71596,getCurrentReader,1,node.anonymous_namespace_38.IdempotentDataQueueReader.getCurrentReader,Reader node.anonymous_namespace_38.IdempotentDataQueueReader.getCurrentReader (),dataqueue\queue.cc,"DataQueue::Reader* getCurrentReader() {
    CHECK(!ended_);
    CHECK(current_index_.has_value());
    if (current_reader_ == nullptr) {
      auto& entry = data_queue_->entries_[current_index_.value()];
      // Because this is an idempotent reader, let's just be sure to
      // doublecheck that the entry itself is actually idempotent
      DCHECK(entry->is_idempotent());
      current_reader_ = static_cast<EntryImpl&>(*entry).get_reader();
    }
    return current_reader_.get();
  }",308.0,319.0,3.0,3.0,12.0,13,8,10,5,0,6,2,2,1,0,,0,6,0,0,0,Reader
2027,71666,NonIdempotentDataQueueReader,1,node.anonymous_namespace_40.NonIdempotentDataQueueReader.NonIdempotentDataQueueReader,ANY node.anonymous_namespace_40.NonIdempotentDataQueueReader.NonIdempotentDataQueueReader (ANY),dataqueue\queue.cc,"NonIdempotentDataQueueReader(std::shared_ptr<DataQueueImpl> data_queue)
      : data_queue_(std::move(data_queue)) {
    CHECK(!data_queue_->is_idempotent());
  }",341.0,344.0,3.0,3.0,4.0,2,2,1,1,0,0,1,1,0,0,,0,0,2,1,1,ANY
2028,71677,NonIdempotentDataQueueReader,1,node.anonymous_namespace_41.NonIdempotentDataQueueReader.NonIdempotentDataQueueReader,ANY node.anonymous_namespace_41.NonIdempotentDataQueueReader.NonIdempotentDataQueueReader (NonIdempotentDataQueueReader),dataqueue\queue.cc,NonIdempotentDataQueueReader(const NonIdempotentDataQueueReader&) = delete;,347.0,347.0,3.0,77.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
2029,71682,NonIdempotentDataQueueReader,1,node.anonymous_namespace_42.NonIdempotentDataQueueReader.NonIdempotentDataQueueReader,ANY node.anonymous_namespace_42.NonIdempotentDataQueueReader.NonIdempotentDataQueueReader (NonIdempotentDataQueueReader),dataqueue\queue.cc,NonIdempotentDataQueueReader(NonIdempotentDataQueueReader&&) = delete;,348.0,348.0,3.0,72.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
2030,71687,operator =,1,node.anonymous_namespace_43.NonIdempotentDataQueueReader.operator =,NonIdempotentDataQueueReader node.anonymous_namespace_43.NonIdempotentDataQueueReader.operator = (NonIdempotentDataQueueReader),dataqueue\queue.cc,"NonIdempotentDataQueueReader& operator=(const NonIdempotentDataQueueReader&) =
      delete;",349.0,350.0,3.0,13.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,NonIdempotentDataQueueReader
2031,71692,operator =,1,node.anonymous_namespace_44.NonIdempotentDataQueueReader.operator =,NonIdempotentDataQueueReader node.anonymous_namespace_44.NonIdempotentDataQueueReader.operator = (NonIdempotentDataQueueReader),dataqueue\queue.cc,"NonIdempotentDataQueueReader& operator=(NonIdempotentDataQueueReader&&) =
      delete;",351.0,352.0,3.0,13.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,NonIdempotentDataQueueReader
2032,71697,Pull,1,node.anonymous_namespace_45.NonIdempotentDataQueueReader.Pull,"int node.anonymous_namespace_45.NonIdempotentDataQueueReader.Pull (Next,int,ANY*,size_t,size_t)",dataqueue\queue.cc,"int Pull(Next next,
           int options,
           DataQueue::Vec* data,
           size_t count,
           size_t max_count_hint = bob::kMaxCountHint) override {
    std::shared_ptr<DataQueue::Reader> self = shared_from_this();

    // If ended is true, this reader has already reached the end and cannot
    // provide any more data.
    if (ended_) {
      std::move(next)(bob::Status::STATUS_EOS, nullptr, 0, [](uint64_t) {});
      return bob::Status::STATUS_EOS;
    }

    // If the collection of entries is empty, there's nothing currently left to
    // read. How we respond depends on whether the data queue has been capped
    // or not.
    if (data_queue_->entries_.empty()) {
      // If the data_queue_ is empty, and not capped, then we can reasonably
      // expect more data to be provided later, but we don't know exactly when
      // that'll happe, so the proper response here is to return a blocked
      // status.
      if (!data_queue_->is_capped()) {
        std::mo...",354.0,467.0,3.0,3.0,114.0,46,7,51,17,0,7,9,14,3,0,,0,7,10,5,5,int
2033,71892,getCurrentReader,1,node.anonymous_namespace_54.NonIdempotentDataQueueReader.getCurrentReader,Reader node.anonymous_namespace_54.NonIdempotentDataQueueReader.getCurrentReader (),dataqueue\queue.cc,"DataQueue::Reader* getCurrentReader() {
    CHECK(!ended_);
    CHECK(!data_queue_->entries_.empty());
    if (current_reader_ == nullptr) {
      auto& entry = data_queue_->entries_.front();
      current_reader_ = static_cast<EntryImpl&>(*entry).get_reader();
    }
    return current_reader_.get();
  }",469.0,477.0,3.0,3.0,9.0,13,7,8,4,0,4,2,2,1,0,,0,4,0,0,0,Reader
2034,71952,get_reader,1,node.anonymous_namespace_55.DataQueueImpl.get_reader,shared_ptr<DataQueue::Reader> node.anonymous_namespace_55.DataQueueImpl.get_reader (),dataqueue\queue.cc,"std::shared_ptr<DataQueue::Reader> DataQueueImpl::get_reader() {
  if (is_idempotent()) {
    return std::make_shared<IdempotentDataQueueReader>(shared_from_this());
  }

  if (locked_to_reader_) return nullptr;
  locked_to_reader_ = true;

  return std::make_shared<NonIdempotentDataQueueReader>(shared_from_this());
}",490.0,499.0,1.0,1.0,10.0,7,4,6,4,0,0,3,3,0,0,,0,0,0,0,0,shared_ptr<DataQueue.Reader>
2035,71984,Pull,1,node.anonymous_namespace_59.EmptyEntry.EmptyReader.Pull,"int node.anonymous_namespace_59.EmptyEntry.EmptyReader.Pull (Next,int,ANY*,size_t,size_t)",dataqueue\queue.cc,"int Pull(Next next,
             int options,
             DataQueue::Vec* data,
             size_t count,
             size_t max_count_hint = bob::kMaxCountHint) override {
      auto self = shared_from_this();
      if (ended_) {
        std::move(next)(bob::Status::STATUS_EOS, nullptr, 0, [](uint64_t) {});
        return bob::Status::STATUS_EOS;
      }

      ended_ = true;
      std::move(next)(
          bob::Status::STATUS_CONTINUE, nullptr, 0, [](uint64_t) {});
      return bob::Status::STATUS_CONTINUE;
    }",509.0,524.0,5.0,5.0,16.0,12,2,15,6,0,0,2,2,0,0,,0,0,10,5,5,int
2036,72044,EmptyEntry,1,node.anonymous_namespace_62.EmptyEntry.EmptyEntry,ANY node.anonymous_namespace_62.EmptyEntry.EmptyEntry (),dataqueue\queue.cc,EmptyEntry() = default;,534.0,534.0,3.0,25.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
2037,72048,EmptyEntry,1,node.anonymous_namespace_63.EmptyEntry.EmptyEntry,ANY node.anonymous_namespace_63.EmptyEntry.EmptyEntry (EmptyEntry),dataqueue\queue.cc,EmptyEntry(const EmptyEntry&) = delete;,537.0,537.0,3.0,41.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
2038,72053,EmptyEntry,1,node.anonymous_namespace_64.EmptyEntry.EmptyEntry,ANY node.anonymous_namespace_64.EmptyEntry.EmptyEntry (EmptyEntry),dataqueue\queue.cc,EmptyEntry(EmptyEntry&&) = delete;,538.0,538.0,3.0,36.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
2039,72058,operator =,1,node.anonymous_namespace_65.EmptyEntry.operator =,EmptyEntry node.anonymous_namespace_65.EmptyEntry.operator = (EmptyEntry),dataqueue\queue.cc,EmptyEntry& operator=(const EmptyEntry&) = delete;,539.0,539.0,3.0,52.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,EmptyEntry
2040,72063,operator =,1,node.anonymous_namespace_66.EmptyEntry.operator =,EmptyEntry node.anonymous_namespace_66.EmptyEntry.operator = (EmptyEntry),dataqueue\queue.cc,EmptyEntry& operator=(EmptyEntry&&) = delete;,540.0,540.0,3.0,47.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,EmptyEntry
2041,72068,get_reader,1,node.anonymous_namespace_67.EmptyEntry.get_reader,shared_ptr<DataQueue::Reader> node.anonymous_namespace_67.EmptyEntry.get_reader (),dataqueue\queue.cc,"std::shared_ptr<DataQueue::Reader> get_reader() override {
    return std::make_shared<EmptyReader>();
  }",542.0,544.0,3.0,3.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,shared_ptr<DataQueue.Reader>
2042,72077,slice,1,node.anonymous_namespace_68.EmptyEntry.slice,"unique_ptr<Entry> node.anonymous_namespace_68.EmptyEntry.slice (uint64_t,ANY)",dataqueue\queue.cc,"std::unique_ptr<Entry> slice(
      uint64_t start,
      std::optional<uint64_t> maybeEnd = std::nullopt) override {
    if (start != 0) return nullptr;
    return std::make_unique<EmptyEntry>();
  }",546.0,551.0,3.0,3.0,6.0,2,2,2,2,0,0,2,2,0,0,,0,0,4,2,2,unique_ptr<Entry>
2043,72095,size,1,node.anonymous_namespace_69.EmptyEntry.size,optional<uint64_t> node.anonymous_namespace_69.EmptyEntry.size (),dataqueue\queue.cc,std::optional<uint64_t> size() const override { return 0; },553.0,553.0,3.0,61.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,optional<uint64_t>
2044,72101,is_idempotent,1,node.anonymous_namespace_70.EmptyEntry.is_idempotent,bool node.anonymous_namespace_70.EmptyEntry.is_idempotent (),dataqueue\queue.cc,bool is_idempotent() const override { return true; },555.0,555.0,3.0,54.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,bool
2045,72110,operator (),1,node.anonymous_namespace_73.InMemoryEntry.InMemoryFunctor.operator (),void node.anonymous_namespace_73.InMemoryEntry.InMemoryFunctor.operator () (uint64_t),dataqueue\queue.cc,void operator()(uint64_t) { backing_store = nullptr; },570.0,570.0,5.0,58.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,void
2046,72118,InMemoryReader,1,node.anonymous_namespace_75.InMemoryEntry.InMemoryReader.InMemoryReader,ANY node.anonymous_namespace_75.InMemoryEntry.InMemoryReader.InMemoryReader (InMemoryEntry),dataqueue\queue.cc,InMemoryReader(InMemoryEntry& entry) : entry_(entry) {},577.0,577.0,5.0,59.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
2047,72123,Pull,1,node.anonymous_namespace_76.InMemoryEntry.InMemoryReader.Pull,"int node.anonymous_namespace_76.InMemoryEntry.InMemoryReader.Pull (Next,int,ANY*,size_t,size_t)",dataqueue\queue.cc,"int Pull(Next next,
             int options,
             DataQueue::Vec* data,
             size_t count,
             size_t max_count_hint = bob::kMaxCountHint) override {
      auto self = shared_from_this();
      if (ended_) {
        std::move(next)(bob::Status::STATUS_EOS, nullptr, 0, [](uint64_t) {});
        return bob::Status::STATUS_EOS;
      }

      ended_ = true;
      DataQueue::Vec vec{
          reinterpret_cast<uint8_t*>(entry_.backing_store_->Data()) +
              entry_.offset_,
          entry_.byte_length_,
      };

      std::move(next)(bob::Status::STATUS_CONTINUE,
                      &vec,
                      1,
                      InMemoryFunctor({entry_.backing_store_}));
      return bob::Status::STATUS_CONTINUE;
    }",579.0,602.0,5.0,5.0,24.0,23,7,21,8,0,2,2,2,1,0,,0,2,10,5,5,int
2048,72215,InMemoryEntry,1,node.anonymous_namespace_78.InMemoryEntry.InMemoryEntry,"ANY node.anonymous_namespace_78.InMemoryEntry.InMemoryEntry (ANY,uint64_t,uint64_t)",dataqueue\queue.cc,"InMemoryEntry(std::shared_ptr<BackingStore> backing_store,
                uint64_t offset,
                uint64_t byte_length)
      : backing_store_(std::move(backing_store)),
        offset_(offset),
        byte_length_(byte_length) {
    // The offset_ + byte_length_ cannot extend beyond the size of the
    // backing store, because that would just be silly.
    CHECK_LE(offset_ + byte_length_, backing_store_->ByteLength());
  }",613.0,622.0,3.0,3.0,10.0,2,2,3,3,0,3,1,1,0,0,,0,3,6,3,3,ANY
2049,72230,InMemoryEntry,1,node.anonymous_namespace_79.InMemoryEntry.InMemoryEntry,ANY node.anonymous_namespace_79.InMemoryEntry.InMemoryEntry (InMemoryEntry),dataqueue\queue.cc,InMemoryEntry(const InMemoryEntry&) = delete;,625.0,625.0,3.0,47.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
2050,72235,InMemoryEntry,1,node.anonymous_namespace_80.InMemoryEntry.InMemoryEntry,ANY node.anonymous_namespace_80.InMemoryEntry.InMemoryEntry (InMemoryEntry),dataqueue\queue.cc,InMemoryEntry(InMemoryEntry&&) = delete;,626.0,626.0,3.0,42.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
2051,72240,operator =,1,node.anonymous_namespace_81.InMemoryEntry.operator =,InMemoryEntry node.anonymous_namespace_81.InMemoryEntry.operator = (InMemoryEntry),dataqueue\queue.cc,InMemoryEntry& operator=(const InMemoryEntry&) = delete;,627.0,627.0,3.0,58.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,InMemoryEntry
2052,72245,operator =,1,node.anonymous_namespace_82.InMemoryEntry.operator =,InMemoryEntry node.anonymous_namespace_82.InMemoryEntry.operator = (InMemoryEntry),dataqueue\queue.cc,InMemoryEntry& operator=(InMemoryEntry&&) = delete;,628.0,628.0,3.0,53.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,InMemoryEntry
2053,72250,get_reader,1,node.anonymous_namespace_83.InMemoryEntry.get_reader,shared_ptr<DataQueue::Reader> node.anonymous_namespace_83.InMemoryEntry.get_reader (),dataqueue\queue.cc,"std::shared_ptr<DataQueue::Reader> get_reader() override {
    return std::make_shared<InMemoryReader>(*this);
  }",630.0,632.0,3.0,3.0,3.0,4,4,2,2,0,0,1,1,0,0,,0,0,0,0,0,shared_ptr<DataQueue.Reader>
2054,72263,slice,1,node.anonymous_namespace_84.InMemoryEntry.slice,"unique_ptr<Entry> node.anonymous_namespace_84.InMemoryEntry.slice (uint64_t,ANY)",dataqueue\queue.cc,"std::unique_ptr<Entry> slice(
      uint64_t start,
      std::optional<uint64_t> maybeEnd = std::nullopt) override {
    const auto makeEntry = [&](uint64_t start,
                               uint64_t len) -> std::unique_ptr<Entry> {
      if (len == 0) {
        return std::make_unique<EmptyEntry>();
      }

      return std::make_unique<InMemoryEntry>(backing_store_, start, len);
    };

    start += offset_;

    // The start cannot extend beyond the maximum end point of this entry.
    start = std::min(start, offset_ + byte_length_);

    if (maybeEnd.has_value()) {
      uint64_t end = maybeEnd.value();
      // The end cannot extend beyond the maximum end point of this entry,
      // and the end must be equal to or greater than the start.
      end = std::max(start, std::min(offset_ + end, offset_ + byte_length_));

      return makeEntry(start, end - start);
    }

    // If no end is given, then the new length is the current length
    // minus the adjusted start.
    ...",634.0,663.0,3.0,3.0,30.0,15,5,25,7,0,7,2,2,0,0,,0,7,4,2,2,unique_ptr<Entry>
2055,72327,size,1,node.anonymous_namespace_86.InMemoryEntry.size,optional<uint64_t> node.anonymous_namespace_86.InMemoryEntry.size (),dataqueue\queue.cc,std::optional<uint64_t> size() const override { return byte_length_; },665.0,665.0,3.0,72.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,optional<uint64_t>
2056,72333,is_idempotent,1,node.anonymous_namespace_87.InMemoryEntry.is_idempotent,bool node.anonymous_namespace_87.InMemoryEntry.is_idempotent (),dataqueue\queue.cc,bool is_idempotent() const override { return true; },667.0,667.0,3.0,54.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,bool
2057,72339,MemoryInfo,1,node.anonymous_namespace_88.InMemoryEntry.MemoryInfo,void node.anonymous_namespace_88.InMemoryEntry.MemoryInfo (ANY*),dataqueue\queue.cc,"void MemoryInfo(node::MemoryTracker* tracker) const override {
    tracker->TrackField(
        ""store"", backing_store_, ""std::shared_ptr<v8::BackingStore>"");
  }",669.0,672.0,3.0,3.0,4.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
2058,72360,DataQueueEntry,1,node.anonymous_namespace_91.DataQueueEntry.DataQueueEntry,ANY node.anonymous_namespace_91.DataQueueEntry.DataQueueEntry (ANY),dataqueue\queue.cc,"explicit DataQueueEntry(std::shared_ptr<DataQueue> data_queue)
      : data_queue_(std::move(data_queue)) {
    CHECK(data_queue_);
  }",690.0,693.0,3.0,3.0,4.0,0,0,1,1,0,1,1,1,0,0,,0,1,2,1,1,ANY
2059,72367,DataQueueEntry,1,node.anonymous_namespace_92.DataQueueEntry.DataQueueEntry,ANY node.anonymous_namespace_92.DataQueueEntry.DataQueueEntry (DataQueueEntry),dataqueue\queue.cc,DataQueueEntry(const DataQueueEntry&) = delete;,696.0,696.0,3.0,49.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
2060,72372,DataQueueEntry,1,node.anonymous_namespace_93.DataQueueEntry.DataQueueEntry,ANY node.anonymous_namespace_93.DataQueueEntry.DataQueueEntry (DataQueueEntry),dataqueue\queue.cc,DataQueueEntry(DataQueueEntry&&) = delete;,697.0,697.0,3.0,44.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
2061,72377,operator =,1,node.anonymous_namespace_94.DataQueueEntry.operator =,DataQueueEntry node.anonymous_namespace_94.DataQueueEntry.operator = (DataQueueEntry),dataqueue\queue.cc,DataQueueEntry& operator=(const DataQueueEntry&) = delete;,698.0,698.0,3.0,60.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,DataQueueEntry
2062,72382,operator =,1,node.anonymous_namespace_95.DataQueueEntry.operator =,DataQueueEntry node.anonymous_namespace_95.DataQueueEntry.operator = (DataQueueEntry),dataqueue\queue.cc,DataQueueEntry& operator=(DataQueueEntry&&) = delete;,699.0,699.0,3.0,55.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,DataQueueEntry
2063,72387,get_reader,1,node.anonymous_namespace_96.DataQueueEntry.get_reader,shared_ptr<DataQueue::Reader> node.anonymous_namespace_96.DataQueueEntry.get_reader (),dataqueue\queue.cc,"std::shared_ptr<DataQueue::Reader> get_reader() override {
    return std::make_shared<ReaderImpl>(data_queue_->get_reader());
  }",701.0,703.0,3.0,3.0,3.0,4,4,3,3,0,1,1,1,0,0,,0,1,0,0,0,shared_ptr<DataQueue.Reader>
2064,72402,slice,1,node.anonymous_namespace_97.DataQueueEntry.slice,"unique_ptr<Entry> node.anonymous_namespace_97.DataQueueEntry.slice (uint64_t,ANY)",dataqueue\queue.cc,"std::unique_ptr<Entry> slice(
      uint64_t start, std::optional<uint64_t> end = std::nullopt) override {
    std::shared_ptr<DataQueue> sliced = data_queue_->slice(start, end);
    if (!sliced) return nullptr;

    return std::make_unique<DataQueueEntry>(std::move(sliced));
  }",705.0,711.0,3.0,3.0,7.0,10,6,11,7,0,1,2,2,0,0,,0,1,4,2,2,unique_ptr<Entry>
2065,72440,size,1,node.anonymous_namespace_98.DataQueueEntry.size,optional<uint64_t> node.anonymous_namespace_98.DataQueueEntry.size (),dataqueue\queue.cc,std::optional<uint64_t> size() const override { return data_queue_->size(); },719.0,719.0,3.0,79.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,optional<uint64_t>
2066,72449,is_idempotent,1,node.anonymous_namespace_99.DataQueueEntry.is_idempotent,bool node.anonymous_namespace_99.DataQueueEntry.is_idempotent (),dataqueue\queue.cc,bool is_idempotent() const override { return data_queue_->is_idempotent(); },727.0,727.0,3.0,78.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,bool
2067,72458,MemoryInfo,1,node.anonymous_namespace_100.DataQueueEntry.MemoryInfo,void node.anonymous_namespace_100.DataQueueEntry.MemoryInfo (ANY*),dataqueue\queue.cc,"void MemoryInfo(node::MemoryTracker* tracker) const override {
    tracker->TrackField(
        ""data_queue"", data_queue_, ""std::shared_ptr<DataQueue>"");
  }",729.0,732.0,3.0,3.0,4.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
2068,72470,getDataQueue,1,node.anonymous_namespace_101.DataQueueEntry.getDataQueue,DataQueue node.anonymous_namespace_101.DataQueueEntry.getDataQueue (),dataqueue\queue.cc,DataQueue& getDataQueue() { return *data_queue_; },734.0,734.0,3.0,52.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,DataQueue
2069,72483,ReaderImpl,1,node.anonymous_namespace_103.DataQueueEntry.ReaderImpl.ReaderImpl,ANY node.anonymous_namespace_103.DataQueueEntry.ReaderImpl.ReaderImpl (ANY),dataqueue\queue.cc,"explicit ReaderImpl(std::shared_ptr<DataQueue::Reader> inner)
        : inner_(std::move(inner)) {}",745.0,746.0,5.0,37.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
2070,72488,Pull,1,node.anonymous_namespace_104.DataQueueEntry.ReaderImpl.Pull,"int node.anonymous_namespace_104.DataQueueEntry.ReaderImpl.Pull (ANY,int,ANY*,size_t,size_t)",dataqueue\queue.cc,"int Pull(DataQueue::Reader::Next next,
             int options,
             DataQueue::Vec* data,
             size_t count,
             size_t max_count_hint) override {
      auto self = shared_from_this();
      return inner_->Pull(
          std::move(next), options, data, count, max_count_hint);
    }",748.0,756.0,5.0,5.0,9.0,3,3,8,8,0,0,1,1,0,0,,0,0,10,5,5,int
2071,72516,Create,1,node.anonymous_namespace_106.FdEntry.Create,"unique_ptr<FdEntry> node.anonymous_namespace_106.FdEntry.Create (Environment*,Local<Value>)",dataqueue\queue.cc,"static std::unique_ptr<FdEntry> Create(Environment* env, Local<Value> path) {
    // We're only going to create the FdEntry if the file exists.
    uv_fs_t req = uv_fs_t();
    auto cleanup = OnScopeLeave([&] { uv_fs_req_cleanup(&req); });

    auto buf = std::make_shared<BufferValue>(env->isolate(), path);
    if (uv_fs_stat(nullptr, &req, buf->out(), nullptr) < 0) return nullptr;

    return std::make_unique<FdEntry>(
        env, std::move(buf), req.statbuf, 0, req.statbuf.st_size);
  }",788.0,798.0,3.0,3.0,11.0,21,8,16,8,0,0,2,2,0,0,,0,0,4,2,2,unique_ptr<FdEntry>
2072,72585,FdEntry,1,node.anonymous_namespace_108.FdEntry.FdEntry,"ANY node.anonymous_namespace_108.FdEntry.FdEntry (Environment*,ANY,uv_stat_t,uint64_t,uint64_t)",dataqueue\queue.cc,"FdEntry(Environment* env,
          std::shared_ptr<BufferValue> path_,
          uv_stat_t stat,
          uint64_t start,
          uint64_t end)
      : env_(env),
        path_(std::move(path_)),
        stat_(stat),
        start_(start),
        end_(end) {}",800.0,809.0,3.0,20.0,10.0,0,0,0,0,0,0,1,1,0,0,,0,0,10,5,5,ANY
2073,72594,get_reader,1,node.anonymous_namespace_109.FdEntry.get_reader,shared_ptr<DataQueue::Reader> node.anonymous_namespace_109.FdEntry.get_reader (),dataqueue\queue.cc,"std::shared_ptr<DataQueue::Reader> get_reader() override {
    return ReaderImpl::Create(this);
  }",811.0,813.0,3.0,3.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,shared_ptr<DataQueue.Reader>
2074,72604,slice,1,node.anonymous_namespace_111.FdEntry.slice,"unique_ptr<Entry> node.anonymous_namespace_111.FdEntry.slice (uint64_t,ANY)",dataqueue\queue.cc,"std::unique_ptr<Entry> slice(
      uint64_t start, std::optional<uint64_t> end = std::nullopt) override {
    uint64_t new_start = start_ + start;
    uint64_t new_end = end_;
    if (end.has_value()) {
      new_end = std::min(end.value(), end_);
    }

    CHECK(new_start >= start_);
    CHECK(new_end <= end_);

    return std::make_unique<FdEntry>(env_, path_, stat_, new_start, new_end);
  }",815.0,827.0,3.0,3.0,13.0,14,9,21,11,0,8,2,2,0,0,,0,8,4,2,2,unique_ptr<Entry>
2075,72659,size,1,node.anonymous_namespace_112.FdEntry.size,optional<uint64_t> node.anonymous_namespace_112.FdEntry.size (),dataqueue\queue.cc,std::optional<uint64_t> size() const override { return end_ - start_; },829.0,829.0,3.0,73.0,1.0,1,1,2,2,0,2,1,1,0,0,,0,2,0,0,0,optional<uint64_t>
2076,72667,is_idempotent,1,node.anonymous_namespace_113.FdEntry.is_idempotent,bool node.anonymous_namespace_113.FdEntry.is_idempotent (),dataqueue\queue.cc,bool is_idempotent() const override { return true; },831.0,831.0,3.0,54.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,bool
2077,72673,env,1,node.anonymous_namespace_114.FdEntry.env,Environment node.anonymous_namespace_114.FdEntry.env (),dataqueue\queue.cc,Environment* env() const { return env_; },833.0,833.0,3.0,43.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,Environment
2078,72684,is_modified,1,node.anonymous_namespace_115.FdEntry.is_modified,bool node.anonymous_namespace_115.FdEntry.is_modified (uv_stat_t),dataqueue\queue.cc,"bool is_modified(const uv_stat_t& other) {
    return other.st_size != stat_.st_size ||
           other.st_mtim.tv_nsec != stat_.st_mtim.tv_nsec;
  }",846.0,849.0,3.0,3.0,4.0,9,3,4,2,0,2,1,1,0,0,,0,2,2,1,1,bool
2079,72709,CheckModified,1,node.anonymous_namespace_116.FdEntry.CheckModified,"bool node.anonymous_namespace_116.FdEntry.CheckModified (FdEntry*,int)",dataqueue\queue.cc,"static bool CheckModified(FdEntry* entry, int fd) {
    uv_fs_t req = uv_fs_t();
    auto cleanup = OnScopeLeave([&] { uv_fs_req_cleanup(&req); });
    // TODO(jasnell): Note the use of a sync fs call here is a bit unfortunate.
    // Doing this asynchronously creates a bit of a race condition tho, a file
    // could be unmodified when we call the operation but then by the time the
    // async callback is triggered to give us that answer the file is modified.
    // While such silliness is still possible here, the sync call at least makes
    // it less likely to hit the race.
    if (uv_fs_fstat(nullptr, &req, fd, nullptr) < 0) return true;
    return entry->is_modified(req.statbuf);
  }",851.0,862.0,3.0,3.0,12.0,6,5,6,4,0,0,2,2,0,0,,0,0,4,2,2,bool
2080,72743,Create,1,node.anonymous_namespace_119.FdEntry.ReaderImpl.Create,shared_ptr<ReaderImpl> node.anonymous_namespace_119.FdEntry.ReaderImpl.Create (FdEntry*),dataqueue\queue.cc,"static std::shared_ptr<ReaderImpl> Create(FdEntry* entry) {
      uv_fs_t req;
      auto cleanup = OnScopeLeave([&] { uv_fs_req_cleanup(&req); });
      int file =
          uv_fs_open(nullptr, &req, entry->path_->out(), O_RDONLY, 0, nullptr);
      if (file < 0 || FdEntry::CheckModified(entry, file)) {
        uv_fs_close(nullptr, &req, file, nullptr);
        return nullptr;
      }
      Realm* realm = entry->env()->principal_realm();
      return std::make_shared<ReaderImpl>(
          BaseObjectPtr<fs::FileHandle>(fs::FileHandle::New(
              realm->GetBindingData<fs::BindingData>(realm->context()),
              file,
              Local<Object>(),
              entry->start_,
              entry->end_ - entry->start_)),
          entry);
    }",868.0,886.0,5.0,5.0,19.0,31,10,27,12,0,4,2,2,0,0,,0,4,2,1,1,shared_ptr<ReaderImpl>
2081,72845,ReaderImpl,1,node.anonymous_namespace_122.FdEntry.ReaderImpl.ReaderImpl,"ANY node.anonymous_namespace_122.FdEntry.ReaderImpl.ReaderImpl (ANY,FdEntry*)",dataqueue\queue.cc,"explicit ReaderImpl(BaseObjectPtr<fs::FileHandle> handle, FdEntry* entry)
        : env_(handle->env()), handle_(std::move(handle)), entry_(entry) {
      handle_->PushStreamListener(this);
      handle_->env()->AddCleanupHook(cleanup, this);
    }",888.0,892.0,5.0,5.0,5.0,3,1,2,1,0,2,1,1,0,0,,0,2,4,2,2,ANY
2082,72865,~ReaderImpl,1,node.anonymous_namespace_124.FdEntry.ReaderImpl.~ReaderImpl,ANY node.anonymous_namespace_124.FdEntry.ReaderImpl.~ReaderImpl (),dataqueue\queue.cc,"~ReaderImpl() override {
      handle_->env()->RemoveCleanupHook(cleanup, this);
      DrainAndClose();
      handle_->RemoveStreamListener(this);
    }",894.0,898.0,5.0,5.0,5.0,3,1,2,1,0,2,1,1,0,0,,0,2,0,0,0,ANY
2083,72884,OnStreamAlloc,1,node.anonymous_namespace_127.FdEntry.ReaderImpl.OnStreamAlloc,uv_buf_t node.anonymous_namespace_127.FdEntry.ReaderImpl.OnStreamAlloc (size_t),dataqueue\queue.cc,"uv_buf_t OnStreamAlloc(size_t suggested_size) override {
      return env_->allocate_managed_buffer(suggested_size);
    }",900.0,902.0,5.0,5.0,3.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,uv_buf_t
2084,72895,OnStreamRead,1,node.anonymous_namespace_128.FdEntry.ReaderImpl.OnStreamRead,"void node.anonymous_namespace_128.FdEntry.ReaderImpl.OnStreamRead (ssize_t,uv_buf_t)",dataqueue\queue.cc,"void OnStreamRead(ssize_t nread, const uv_buf_t& buf) override {
      std::shared_ptr<v8::BackingStore> store =
          env_->release_managed_buffer(buf);

      if (ended_) {
        // If we got here and ended_ is true, it means we ended and drained
        // while the read was pending. We're just going to do nothing.
        CHECK(pending_pulls_.empty());
        return;
      }

      CHECK(reading_);
      auto pending = DequeuePendingPull();

      if (CheckModified(entry_, handle_->GetFD())) {
        DrainAndClose();
        // The file was modified while the read was pending. We need to error.
        std::move(pending.next)(UV_EINVAL, nullptr, 0, [](uint64_t) {});
        return;
      }

      if (nread < 0) {
        if (nread == UV_EOF) {
          std::move(pending.next)(bob::STATUS_EOS, nullptr, 0, [](uint64_t) {});
        } else {
          std::move(pending.next)(nread, nullptr, 0, [](uint64_t) {});
        }

        return DrainAndClose();
      }

      Data...",904.0,945.0,5.0,5.0,42.0,31,8,32,16,0,10,7,9,5,0,,0,10,4,2,2,void
2085,73045,Pull,1,node.anonymous_namespace_136.FdEntry.ReaderImpl.Pull,"int node.anonymous_namespace_136.FdEntry.ReaderImpl.Pull (Next,int,ANY*,size_t,size_t)",dataqueue\queue.cc,"int Pull(Next next,
             int options,
             DataQueue::Vec* data,
             size_t count,
             size_t max_count_hint = bob::kMaxCountHint) override {
      if (ended_ || !handle_->IsAlive()) {
        std::move(next)(bob::STATUS_EOS, nullptr, 0, [](uint64_t) {});
        return bob::STATUS_EOS;
      }

      if (FdEntry::CheckModified(entry_, handle_->GetFD())) {
        DrainAndClose();
        std::move(next)(UV_EINVAL, nullptr, 0, [](uint64_t) {});
        return UV_EINVAL;
      }

      pending_pulls_.emplace_back(std::move(next), shared_from_this());
      if (!reading_) {
        reading_ = true;
        handle_->ReadStart();
      }
      return bob::STATUS_WAIT;
    }",947.0,969.0,5.0,5.0,23.0,15,5,20,10,0,8,4,4,5,0,,0,8,10,5,5,int
2086,73135,cleanup,1,node.anonymous_namespace_140.FdEntry.ReaderImpl.cleanup,void node.anonymous_namespace_140.FdEntry.ReaderImpl.cleanup (void*),dataqueue\queue.cc,"static void cleanup(void* self) {
      auto ptr = static_cast<ReaderImpl*>(self);
      ptr->DrainAndClose();
    }",990.0,993.0,5.0,5.0,4.0,3,3,3,2,0,0,1,1,0,0,,0,0,2,1,1,void
2087,73150,DrainAndClose,1,node.anonymous_namespace_141.FdEntry.ReaderImpl.DrainAndClose,void node.anonymous_namespace_141.FdEntry.ReaderImpl.DrainAndClose (),dataqueue\queue.cc,"void DrainAndClose() {
      if (ended_) return;
      ended_ = true;
      while (!pending_pulls_.empty()) {
        auto pending = DequeuePendingPull();
        std::move(pending.next)(bob::STATUS_EOS, nullptr, 0, [](uint64_t) {});
      }
      handle_->ReadStop();

      // We fallback to a sync close on the raw fd here because it is the
      // easiest, simplest thing to do. All of FileHandle's close mechanisms
      // assume async close and cleanup, while DrainAndClose might be running
      // in the destructor during GC, for instance. As a todo, FileHandle could
      // provide a sync mechanism for closing the FD but, for now, this
      // approach works.
      int fd = handle_->Release();
      uv_fs_t req;
      uv_fs_close(nullptr, &req, fd, nullptr);
      uv_fs_req_cleanup(&req);
    }",995.0,1014.0,5.0,5.0,20.0,12,5,13,8,0,5,3,3,2,0,,0,5,0,0,0,void
2088,73207,DequeuePendingPull,1,node.anonymous_namespace_144.FdEntry.ReaderImpl.DequeuePendingPull,PendingPull node.anonymous_namespace_144.FdEntry.ReaderImpl.DequeuePendingPull (),dataqueue\queue.cc,"PendingPull DequeuePendingPull() {
      CHECK(!pending_pulls_.empty());
      auto pop = OnScopeLeave([this] { pending_pulls_.pop_front(); });
      return std::move(pending_pulls_.front());
    }",1016.0,1020.0,5.0,5.0,5.0,5,3,4,3,0,2,1,1,0,0,,0,2,0,0,0,PendingPull
2089,73253,CreateIdempotent,1,node.DataQueue.CreateIdempotent,shared_ptr<DataQueue> node.DataQueue.CreateIdempotent (ANY),dataqueue\queue.cc,"std::shared_ptr<DataQueue> DataQueue::CreateIdempotent(
    std::vector<std::unique_ptr<Entry>> list) {
  // Any entry is invalid for an idempotent DataQueue if any of the entries
  // are nullptr or is not idempotent.
  uint64_t size = 0;
  const auto isInvalid = [&size](auto& item) {
    if (item == nullptr || !item->is_idempotent()) {
      return true;  // true means the entry is not valid here.
    }

    // To keep from having to iterate over the entries
    // again, we'll try calculating the size. If any
    // of the entries are unable to provide a size, then
    // we assume we cannot safely treat this entry as
    // idempotent even if it claims to be.
    if (item->size().has_value()) {
      size += item->size().value();
    } else {
      return true;  // true means the entry is not valid here.
    }

    return false;
  };

  if (std::any_of(list.begin(), list.end(), isInvalid)) {
    return nullptr;
  }

  return std::make_shared<DataQueueImpl>(std::move(list), size);
}",1032.0,1061.0,1.0,1.0,30.0,11,6,11,5,0,0,2,2,0,0,,0,0,2,1,1,shared_ptr<DataQueue>
2090,73297,Create,1,node.DataQueue.Create,shared_ptr<DataQueue> node.DataQueue.Create (ANY),dataqueue\queue.cc,"std::shared_ptr<DataQueue> DataQueue::Create(std::optional<uint64_t> capped) {
  return std::make_shared<DataQueueImpl>(capped);
}",1063.0,1065.0,1.0,1.0,3.0,3,3,3,3,0,0,1,1,0,0,,0,0,2,1,1,shared_ptr<DataQueue>
2091,73310,CreateInMemoryEntryFromView,1,node.DataQueue.CreateInMemoryEntryFromView,unique_ptr<DataQueue::Entry> node.DataQueue.CreateInMemoryEntryFromView (Local<ArrayBufferView>),dataqueue\queue.cc,"std::unique_ptr<DataQueue::Entry> DataQueue::CreateInMemoryEntryFromView(
    Local<ArrayBufferView> view) {
  // If the view is not detachable, we do not want to create an InMemoryEntry
  // from it. Why? Because if we're not able to detach the backing store from
  // the underlying buffer, something else could modify the buffer while we're
  // holding the reference, which means we cannot guarantee that reads will be
  // idempotent.
  if (!view->Buffer()->IsDetachable()) {
    return nullptr;
  }
  auto store = view->Buffer()->GetBackingStore();
  auto offset = view->ByteOffset();
  auto length = view->ByteLength();
  USE(view->Buffer()->Detach(Local<Value>()));
  return CreateInMemoryEntryFromBackingStore(std::move(store), offset, length);
}",1067.0,1082.0,1.0,1.0,16.0,13,4,12,5,0,0,2,2,0,0,,0,0,2,1,1,unique_ptr<DataQueue.Entry>
2092,73369,CreateInMemoryEntryFromBackingStore,1,node.DataQueue.CreateInMemoryEntryFromBackingStore,"unique_ptr<DataQueue::Entry> node.DataQueue.CreateInMemoryEntryFromBackingStore (ANY,uint64_t,uint64_t)",dataqueue\queue.cc,"std::unique_ptr<DataQueue::Entry>
DataQueue::CreateInMemoryEntryFromBackingStore(
    std::shared_ptr<BackingStore> store, uint64_t offset, uint64_t length) {
  CHECK(store);
  if (offset + length > store->ByteLength()) {
    return nullptr;
  }
  return std::make_unique<InMemoryEntry>(std::move(store), offset, length);
}",1084.0,1092.0,1.0,1.0,9.0,9,7,10,5,0,0,2,2,0,0,,0,0,6,3,3,unique_ptr<DataQueue.Entry>
2093,73406,CreateDataQueueEntry,1,node.DataQueue.CreateDataQueueEntry,unique_ptr<DataQueue::Entry> node.DataQueue.CreateDataQueueEntry (ANY),dataqueue\queue.cc,"std::unique_ptr<DataQueue::Entry> DataQueue::CreateDataQueueEntry(
    std::shared_ptr<DataQueue> data_queue) {
  return std::make_unique<DataQueueEntry>(std::move(data_queue));
}",1094.0,1097.0,1.0,1.0,4.0,4,3,4,3,0,0,1,1,0,0,,0,0,2,1,1,unique_ptr<DataQueue.Entry>
2094,73423,CreateFdEntry,1,node.DataQueue.CreateFdEntry,"unique_ptr<DataQueue::Entry> node.DataQueue.CreateFdEntry (Environment*,Local<Value>)",dataqueue\queue.cc,"std::unique_ptr<DataQueue::Entry> DataQueue::CreateFdEntry(Environment* env,
                                                           Local<Value> path) {
  return FdEntry::Create(env, path);
}",1099.0,1102.0,1.0,1.0,4.0,1,1,3,3,0,0,1,1,0,0,,0,0,4,2,2,unique_ptr<DataQueue.Entry>
2095,73436,Initialize,1,node.DataQueue.Initialize,"void node.DataQueue.Initialize (Environment*,ANY)",dataqueue\queue.cc,"void DataQueue::Initialize(Environment* env, v8::Local<v8::Object> target) {
  // Nothing to do here currently.
}",1104.0,1106.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
2096,73442,RegisterExternalReferences,1,node.DataQueue.RegisterExternalReferences,void node.DataQueue.RegisterExternalReferences (ExternalReferenceRegistry*),dataqueue\queue.cc,"void DataQueue::RegisterExternalReferences(
    ExternalReferenceRegistry* registry) {
  // Nothing to do here currently.
}",1108.0,1111.0,1.0,1.0,4.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
2097,73486,<lambda>0,1,node.PrintLibuvHandleInformation.<lambda>0,"ANY node.PrintLibuvHandleInformation.<lambda>0 (uv_handle_t*,void*)",debug_utils.cc,"[](uv_handle_t* handle, void* arg) {
    Info* info = static_cast<Info*>(arg);
    NativeSymbolDebuggingContext* sym_ctx = info->ctx.get();
    FILE* stream = info->stream;
    info->num_handles++;

    fprintf(stream, ""[%p] %s%s\n"", handle, uv_handle_type_name(handle->type),
            uv_is_active(handle) ? "" (active)"" : """");

    void* close_cb = reinterpret_cast<void*>(handle->close_cb);
    fprintf(stream, ""\tClose callback: %p %s\n"",
        close_cb, sym_ctx->LookupSymbol(close_cb).Display().c_str());

    fprintf(stream, ""\tData: %p %s\n"",
        handle->data, sym_ctx->LookupSymbol(handle->data).Display().c_str());

    // We are also interested in the first field of what `handle->data`
    // points to, because for C++ code that is usually the virtual table pointer
    // and gives us information about the exact kind of object we're looking at.
    void* first_field = nullptr;
    // `handle->data` might be any value, including `nullptr`, or something
    // cast from a c...",338.0,368.0,17.0,3.0,31.0,33,8,31,7,0,0,3,3,0,0,,0,0,4,2,2,ANY
2098,73615,<lambda>1,1,node.FWrite.<lambda>1,ANY node.FWrite.<lambda>1 (),debug_utils.cc,"[&]() {
    // The return value is ignored because there's no good way to handle it.
    fwrite(str.data(), str.size(), 1, file);
  }",477.0,480.0,24.0,3.0,4.0,2,1,3,2,0,0,1,1,0,0,,0,0,0,0,0,ANY
2099,73681,Parse,1,node.EnabledDebugList.Parse,"void node.EnabledDebugList.Parse (ANY,ANY*)",debug_utils.cc,"void EnabledDebugList::Parse(const std::string& cats) {
  std::string debug_categories = cats;
  while (!debug_categories.empty()) {
    std::string::size_type comma_pos = debug_categories.find(',');
    std::string wanted = ToLower(debug_categories.substr(0, comma_pos));

#define V(name)                                                                \
  {                                                                            \
    static const std::string available_category = ToLower(#name);              \
    if (available_category.find(wanted) != std::string::npos)                  \
      set_enabled(DebugCategory::name);                                        \
  }

    DEBUG_CATEGORY_NAMES(V)
#undef V

    if (comma_pos == std::string::npos) break;
    // Use everything after the `,` as the list for the next iteration.
    debug_categories = debug_categories.substr(comma_pos + 1);
  }
}",69.0,89.0,1.0,1.0,21.0,2,2,5,4,0,0,1,1,0,0,,0,0,2,1,1,void
2100,73755,Win32SymbolDebuggingContext,1,node.Win32SymbolDebuggingContext.Win32SymbolDebuggingContext,ANY node.Win32SymbolDebuggingContext.Win32SymbolDebuggingContext (),debug_utils.cc,"Win32SymbolDebuggingContext() {
    current_process_ = GetCurrentProcess();
    USE(SymInitialize(current_process_, nullptr, true));
  }",153.0,156.0,3.0,3.0,4.0,1,1,2,1,0,2,1,1,0,0,,0,2,0,0,0,ANY
2101,73767,~Win32SymbolDebuggingContext,1,node.Win32SymbolDebuggingContext.~Win32SymbolDebuggingContext,ANY node.Win32SymbolDebuggingContext.~Win32SymbolDebuggingContext (),debug_utils.cc,"~Win32SymbolDebuggingContext() override {
    USE(SymCleanup(current_process_));
  }",158.0,160.0,3.0,3.0,3.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,ANY
2102,73775,WrappedSymFromAddr,1,node.Win32SymbolDebuggingContext.WrappedSymFromAddr,NameAndDisplacement node.Win32SymbolDebuggingContext.WrappedSymFromAddr (DWORD64),debug_utils.cc,"NameAndDisplacement WrappedSymFromAddr(DWORD64 dwAddress) const {
    // Refs: https://docs.microsoft.com/en-us/windows/desktop/Debug/retrieving-symbol-information-by-address
    // Patches:
    // Use `fprintf(stderr, ` instead of `printf`
    // `sym.filename = pSymbol->Name` on success
    // `current_process_` instead of `hProcess.
    DWORD64 dwDisplacement = 0;
    // Patch: made into arg - DWORD64  dwAddress = SOME_ADDRESS;

    char buffer[sizeof(SYMBOL_INFO) + MAX_SYM_NAME * sizeof(TCHAR)];
    const auto pSymbol = reinterpret_cast<PSYMBOL_INFO>(buffer);

    pSymbol->SizeOfStruct = sizeof(SYMBOL_INFO);
    pSymbol->MaxNameLen = MAX_SYM_NAME;

    if (SymFromAddr(current_process_, dwAddress, &dwDisplacement, pSymbol)) {
      // SymFromAddr returned success
      return NameAndDisplacement(pSymbol->Name, dwDisplacement);
    } else {
      // SymFromAddr failed
      const DWORD error = GetLastError();  // ""eat"" the error anyway
#ifdef DEBUG
      fprintf(stderr, ""SymFromAd...",163.0,191.0,3.0,3.0,29.0,10,5,13,7,0,1,2,2,1,0,,0,1,2,1,1,NameAndDisplacement
2103,73824,WrappedGetLine,1,node.Win32SymbolDebuggingContext.WrappedGetLine,SymbolInfo node.Win32SymbolDebuggingContext.WrappedGetLine (DWORD64),debug_utils.cc,"SymbolInfo WrappedGetLine(DWORD64 dwAddress) const {
    SymbolInfo sym{};

    // Refs: https://docs.microsoft.com/en-us/windows/desktop/Debug/retrieving-symbol-information-by-address
    // Patches:
    // Use `fprintf(stderr, ` instead of `printf`.
    // Assign values to `sym` on success.
    // `current_process_` instead of `hProcess.

    // Patch: made into arg - DWORD64  dwAddress;
    DWORD dwDisplacement;
    IMAGEHLP_LINE64 line;

    SymSetOptions(SYMOPT_LOAD_LINES);

    line.SizeOfStruct = sizeof(IMAGEHLP_LINE64);
    // Patch: made into arg - dwAddress = 0x1000000;

    if (SymGetLineFromAddr64(current_process_, dwAddress,
                             &dwDisplacement, &line)) {
      // SymGetLineFromAddr64 returned success
      sym.filename = line.FileName;
      sym.line = line.LineNumber;
    } else {
      // SymGetLineFromAddr64 failed
      const DWORD error = GetLastError();  // ""eat"" the error anyway
#ifdef DEBUG
      fprintf(stderr, ""SymGetLineFromAddr64 re...",193.0,226.0,3.0,3.0,34.0,13,5,12,6,0,1,2,2,1,0,,0,1,2,1,1,SymbolInfo
2104,73873,WrappedUnDecorateSymbolName,1,node.Win32SymbolDebuggingContext.WrappedUnDecorateSymbolName,string node.Win32SymbolDebuggingContext.WrappedUnDecorateSymbolName (char*),debug_utils.cc,"std::string WrappedUnDecorateSymbolName(const char* name) const {
    // Refs: https://docs.microsoft.com/en-us/windows/desktop/Debug/retrieving-undecorated-symbol-names
    // Patches:
    // Use `fprintf(stderr, ` instead of `printf`.
    // return `szUndName` instead of `printf` on success
    char szUndName[MAX_SYM_NAME];
    if (UnDecorateSymbolName(name, szUndName, sizeof(szUndName),
                             UNDNAME_COMPLETE)) {
      // UnDecorateSymbolName returned success
      return szUndName;
    } else {
      // UnDecorateSymbolName failed
      const DWORD error = GetLastError();  // ""eat"" the error anyway
#ifdef DEBUG
      fprintf(stderr, ""UnDecorateSymbolName returned error %lu\n"", error);
#endif
    }
    return nullptr;
  }",229.0,247.0,3.0,3.0,19.0,1,1,5,3,0,0,2,2,0,0,,0,0,2,1,1,string
2105,73897,LookupSymbol,1,node.Win32SymbolDebuggingContext.LookupSymbol,SymbolInfo node.Win32SymbolDebuggingContext.LookupSymbol (void*),debug_utils.cc,"SymbolInfo LookupSymbol(void* address) override {
    const DWORD64 dw_address = reinterpret_cast<DWORD64>(address);
    SymbolInfo ret = WrappedGetLine(dw_address);
    std::tie(ret.name, ret.dis) = WrappedSymFromAddr(dw_address);
    if (!ret.name.empty()) {
      ret.name = WrappedUnDecorateSymbolName(ret.name.c_str());
    }
    return ret;
  }",249.0,257.0,3.0,3.0,9.0,14,4,12,4,0,0,2,2,0,0,,0,0,2,1,1,SymbolInfo
2106,73948,IsMapped,1,node.Win32SymbolDebuggingContext.IsMapped,bool node.Win32SymbolDebuggingContext.IsMapped (void*),debug_utils.cc,"bool IsMapped(void* address) override {
    MEMORY_BASIC_INFORMATION info;

    if (VirtualQuery(address, &info, sizeof(info)) != sizeof(info))
      return false;

    return info.State == MEM_COMMIT && info.Protect != 0;
  }",259.0,266.0,3.0,3.0,8.0,9,6,7,3,0,0,2,2,0,0,,0,0,2,1,1,bool
2107,73979,GetStackTrace,1,node.Win32SymbolDebuggingContext.GetStackTrace,"int node.Win32SymbolDebuggingContext.GetStackTrace (void**,int)",debug_utils.cc,"int GetStackTrace(void** frames, int count) override {
    return CaptureStackBackTrace(0, count, frames, nullptr);
  }",268.0,270.0,3.0,3.0,3.0,0,0,2,2,0,0,1,1,0,0,,0,0,4,2,2,int
2108,74001,operator =,1,node.Win32SymbolDebuggingContext.operator =,Win32SymbolDebuggingContext node.Win32SymbolDebuggingContext.operator = (Win32SymbolDebuggingContext),debug_utils.cc,"Win32SymbolDebuggingContext operator=(const Win32SymbolDebuggingContext&)
    = delete;",274.0,275.0,3.0,13.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,Win32SymbolDebuggingContext
2109,74012,New,1,node.NativeSymbolDebuggingContext.New,unique_ptr<NativeSymbolDebuggingContext> node.NativeSymbolDebuggingContext.New (),debug_utils.cc,"std::unique_ptr<NativeSymbolDebuggingContext>
NativeSymbolDebuggingContext::New() {
  return std::unique_ptr<NativeSymbolDebuggingContext>(
      new Win32SymbolDebuggingContext());
}",283.0,287.0,1.0,1.0,5.0,4,4,3,3,0,0,1,1,0,0,,0,0,0,0,0,unique_ptr<NativeSymbolDebuggingContext>
2110,74025,Display,1,node.NativeSymbolDebuggingContext.SymbolInfo.Display,string node.NativeSymbolDebuggingContext.SymbolInfo.Display (),debug_utils.cc,"std::string NativeSymbolDebuggingContext::SymbolInfo::Display() const {
  std::ostringstream oss;
  oss << name;
  if (dis != 0) {
    oss << ""+"" << dis;
  }
  if (!filename.empty()) {
    oss << "" ["" << filename << ']';
  }
  if (line != 0) {
    oss << "":L"" << line;
  }
  return oss.str();
}",291.0,304.0,1.0,1.0,14.0,13,4,12,5,0,0,4,4,0,0,,0,0,0,0,0,string
2111,74072,DumpBacktrace,1,node.DumpBacktrace,void node.DumpBacktrace (FILE*),debug_utils.cc,"void DumpBacktrace(FILE* fp) {
  auto sym_ctx = NativeSymbolDebuggingContext::New();
  void* frames[256];
  const int size = sym_ctx->GetStackTrace(frames, arraysize(frames));
  for (int i = 1; i < size; i += 1) {
    void* frame = frames[i];
    NativeSymbolDebuggingContext::SymbolInfo s = sym_ctx->LookupSymbol(frame);
    fprintf(fp, ""%2d: %p %s\n"", i, frame, s.Display().c_str());
  }
}",306.0,315.0,1.0,1.0,10.0,12,5,19,8,1,0,2,2,0,0,,0,0,2,1,1,void
2112,74134,CheckedUvLoopClose,1,node.CheckedUvLoopClose,void node.CheckedUvLoopClose (uv_loop_t*),debug_utils.cc,"void CheckedUvLoopClose(uv_loop_t* loop) {
  if (uv_loop_close(loop) == 0) return;

  PrintLibuvHandleInformation(loop, stderr);

  fflush(stderr);
  // Finally, abort.
  UNREACHABLE(""uv_loop_close() while having open handles"");
}",317.0,325.0,1.0,1.0,9.0,1,1,3,2,0,0,2,2,0,0,,0,0,2,1,1,void
2113,74152,PrintLibuvHandleInformation,1,node.PrintLibuvHandleInformation,"void node.PrintLibuvHandleInformation (uv_loop_t*,FILE*)",debug_utils.cc,"void PrintLibuvHandleInformation(uv_loop_t* loop, FILE* stream) {
  struct Info {
    std::unique_ptr<NativeSymbolDebuggingContext> ctx;
    FILE* stream;
    size_t num_handles;
  };

  Info info { NativeSymbolDebuggingContext::New(), stream, 0 };

  fprintf(stream, ""uv loop at [%p] has open handles:\n"", loop);

  uv_walk(loop, [](uv_handle_t* handle, void* arg) {
    Info* info = static_cast<Info*>(arg);
    NativeSymbolDebuggingContext* sym_ctx = info->ctx.get();
    FILE* stream = info->stream;
    info->num_handles++;

    fprintf(stream, ""[%p] %s%s\n"", handle, uv_handle_type_name(handle->type),
            uv_is_active(handle) ? "" (active)"" : """");

    void* close_cb = reinterpret_cast<void*>(handle->close_cb);
    fprintf(stream, ""\tClose callback: %p %s\n"",
        close_cb, sym_ctx->LookupSymbol(close_cb).Display().c_str());

    fprintf(stream, ""\tData: %p %s\n"",
        handle->data, sym_ctx->LookupSymbol(handle->data).Display().c_str());

    // We are also interested in...",327.0,372.0,1.0,1.0,46.0,5,4,10,4,0,0,1,1,0,0,,0,0,4,2,2,void
2114,74184,GetLoadedLibraries,1,node.NativeSymbolDebuggingContext.GetLoadedLibraries,vector<std::string> node.NativeSymbolDebuggingContext.GetLoadedLibraries (),debug_utils.cc,"std::vector<std::string> NativeSymbolDebuggingContext::GetLoadedLibraries() {
  std::vector<std::string> list;
#if defined(__linux__) || defined(__FreeBSD__) || \
    defined(__OpenBSD__) || defined(__DragonFly__)
  dl_iterate_phdr(
      [](struct dl_phdr_info* info, size_t size, void* data) {
        auto list = static_cast<std::vector<std::string>*>(data);
        if (*info->dlpi_name != '\0') {
          list->emplace_back(info->dlpi_name);
        }
        return 0;
      },
      &list);
#elif __APPLE__
  uint32_t i = 0;
  for (const char* name = _dyld_get_image_name(i); name != nullptr;
       name = _dyld_get_image_name(++i)) {
    list.emplace_back(name);
  }

#elif _AIX
  // We can't tell in advance how large the buffer needs to be.
  // Retry until we reach too large a size (1Mb).
  const unsigned int kBufferGrowStep = 4096;
  MallocedBuffer<char> buffer(kBufferGrowStep);
  int rc = -1;
  do {
    rc = loadquery(L_GETINFO, buffer.data, buffer.size);
    if (rc == 0) brea...",374.0,474.0,1.0,1.0,101.0,4,3,4,2,0,0,1,1,0,0,,0,0,0,0,0,vector<std.string>
2115,74199,FWrite,1,node.FWrite,"void node.FWrite (FILE*,ANY)",debug_utils.cc,"void FWrite(FILE* file, const std::string& str) {
  auto simple_fwrite = [&]() {
    // The return value is ignored because there's no good way to handle it.
    fwrite(str.data(), str.size(), 1, file);
  };

  if (file != stderr && file != stdout) {
    simple_fwrite();
    return;
  }
#ifdef _WIN32
  HANDLE handle =
      GetStdHandle(file == stdout ? STD_OUTPUT_HANDLE : STD_ERROR_HANDLE);

  // Check if stderr is something other than a tty/console
  if (handle == INVALID_HANDLE_VALUE || handle == nullptr ||
      uv_guess_handle(_fileno(file)) != UV_TTY) {
    simple_fwrite();
    return;
  }

  // Get required wide buffer size
  int n = MultiByteToWideChar(CP_UTF8, 0, str.data(), str.size(), nullptr, 0);

  std::vector<wchar_t> wbuf(n);
  MultiByteToWideChar(CP_UTF8, 0, str.data(), str.size(), wbuf.data(), n);

  WriteConsoleW(handle, wbuf.data(), n, nullptr, nullptr);
  return;
#elif defined(__ANDROID__)
  if (file == stderr) {
    __android_log_print(ANDROID_LOG_ERROR, ""nodejs...",476.0,512.0,1.0,1.0,37.0,4,3,5,4,0,0,2,2,0,0,,0,0,4,2,2,void
2116,74219,__DumpBacktrace,1,__DumpBacktrace,void __DumpBacktrace (FILE*),debug_utils.cc,"void __DumpBacktrace(FILE* fp) {
  node::DumpBacktrace(fp);
}",516.0,518.0,12.0,1.0,3.0,1,1,2,2,0,1,1,1,0,1,,0,0,2,1,1,void
2117,74276,MemoryInfo,1,node.encoding_binding.BindingData.MemoryInfo,void node.encoding_binding.BindingData.MemoryInfo (MemoryTracker*),encoding_binding.cc,"void BindingData::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackField(""encode_into_results_buffer"",
                      encode_into_results_buffer_);
}",29.0,32.0,1.0,1.0,4.0,1,1,2,2,0,0,1,1,0,0,,0,0,2,1,1,void
2118,74287,BindingData,1,node.encoding_binding.BindingData.BindingData,"ANY node.encoding_binding.BindingData.BindingData (Realm*,ANY,InternalFieldInfo*)",encoding_binding.cc,"BindingData::BindingData(Realm* realm,
                         v8::Local<v8::Object> object,
                         InternalFieldInfo* info)
    : SnapshotableObject(realm, object, type_int),
      encode_into_results_buffer_(
          realm->isolate(),
          kEncodeIntoResultsLength,
          MAYBE_FIELD_PTR(info, encode_into_results_buffer)) {
  if (info == nullptr) {
    object
        ->Set(realm->context(),
              FIXED_ONE_BYTE_STRING(realm->isolate(), ""encodeIntoResults""),
              encode_into_results_buffer_.GetJSArray())
        .Check();
  } else {
    encode_into_results_buffer_.Deserialize(realm->context());
  }
  encode_into_results_buffer_.MakeWeak();
}",34.0,52.0,1.0,1.0,19.0,7,3,6,4,0,0,2,2,0,0,,0,0,6,3,3,ANY
2119,74334,PrepareForSerialization,1,node.encoding_binding.BindingData.PrepareForSerialization,"bool node.encoding_binding.BindingData.PrepareForSerialization (Local<Context>,ANY*)",encoding_binding.cc,"bool BindingData::PrepareForSerialization(Local<Context> context,
                                          v8::SnapshotCreator* creator) {
  DCHECK_NULL(internal_field_info_);
  internal_field_info_ = InternalFieldInfoBase::New<InternalFieldInfo>(type());
  internal_field_info_->encode_into_results_buffer =
      encode_into_results_buffer_.Serialize(context, creator);
  // Return true because we need to maintain the reference to the binding from
  // JS land.
  return true;
}",54.0,63.0,1.0,1.0,10.0,7,5,7,6,0,0,1,1,0,0,,0,0,4,2,2,bool
2120,74362,Serialize,1,node.encoding_binding.BindingData.Serialize,InternalFieldInfoBase node.encoding_binding.BindingData.Serialize (int),encoding_binding.cc,"InternalFieldInfoBase* BindingData::Serialize(int index) {
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  InternalFieldInfo* info = internal_field_info_;
  internal_field_info_ = nullptr;
  return info;
}",65.0,70.0,1.0,1.0,6.0,3,2,6,4,0,0,1,1,0,0,,0,0,2,1,1,InternalFieldInfoBase
2121,74381,Deserialize,1,node.encoding_binding.BindingData.Deserialize,"void node.encoding_binding.BindingData.Deserialize (Local<Context>,Local<Object>,int,InternalFieldInfoBase*)",encoding_binding.cc,"void BindingData::Deserialize(Local<Context> context,
                              Local<Object> holder,
                              int index,
                              InternalFieldInfoBase* info) {
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  v8::HandleScope scope(context->GetIsolate());
  Realm* realm = Realm::GetCurrent(context);
  // Recreate the buffer in the constructor.
  InternalFieldInfo* casted_info = static_cast<InternalFieldInfo*>(info);
  BindingData* binding =
      realm->AddBindingData<BindingData>(context, holder, casted_info);
  CHECK_NOT_NULL(binding);
}",72.0,84.0,1.0,1.0,13.0,12,8,15,10,0,0,1,1,0,0,,0,0,8,4,4,void
2122,74430,EncodeInto,1,node.encoding_binding.BindingData.EncodeInto,void node.encoding_binding.BindingData.EncodeInto (FunctionCallbackInfo<Value>),encoding_binding.cc,"void BindingData::EncodeInto(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();
  CHECK_GE(args.Length(), 2);
  CHECK(args[0]->IsString());
  CHECK(args[1]->IsUint8Array());
  BindingData* binding_data = Realm::GetBindingData<BindingData>(args);

  Local<String> source = args[0].As<String>();

  Local<Uint8Array> dest = args[1].As<Uint8Array>();
  Local<ArrayBuffer> buf = dest->Buffer();
  char* write_result = static_cast<char*>(buf->Data()) + dest->ByteOffset();
  size_t dest_length = dest->ByteLength();

  int nchars;
  int written = source->WriteUtf8(
      isolate,
      write_result,
      dest_length,
      &nchars,
      String::NO_NULL_TERMINATION | String::REPLACE_INVALID_UTF8);

  binding_data->encode_into_results_buffer_[0] = nchars;
  binding_data->encode_into_results_buffer_[1] = written;
}",86.0,111.0,1.0,1.0,26.0,46,10,41,18,0,0,1,1,0,0,,0,0,2,1,1,void
2123,74569,EncodeUtf8String,1,node.encoding_binding.BindingData.EncodeUtf8String,void node.encoding_binding.BindingData.EncodeUtf8String (FunctionCallbackInfo<Value>),encoding_binding.cc,"void BindingData::EncodeUtf8String(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();
  CHECK_GE(args.Length(), 1);
  CHECK(args[0]->IsString());

  Local<String> str = args[0].As<String>();
  size_t length = str->Utf8Length(isolate);

  Local<ArrayBuffer> ab;
  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    std::unique_ptr<BackingStore> bs =
        ArrayBuffer::NewBackingStore(isolate, length);

    CHECK(bs);

    str->WriteUtf8(isolate,
                   static_cast<char*>(bs->Data()),
                   -1,  // We are certain that `data` is sufficiently large
                   nullptr,
                   String::NO_NULL_TERMINATION | String::REPLACE_INVALID_UTF8);

    ab = ArrayBuffer::New(isolate, std::move(bs));
  }

  auto array = Uint8Array::New(ab, 0, length);
  args.GetReturnValue().Set(array);
}",115.0,143.0,1.0,1.0,29.0,36,9,40,15,0,0,1,1,0,0,,0,0,2,1,1,void
2124,74700,DecodeUTF8,1,node.encoding_binding.BindingData.DecodeUTF8,void node.encoding_binding.BindingData.DecodeUTF8 (FunctionCallbackInfo<Value>),encoding_binding.cc,"void BindingData::DecodeUTF8(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);  // list, flags

  CHECK_GE(args.Length(), 1);

  if (!(args[0]->IsArrayBuffer() || args[0]->IsSharedArrayBuffer() ||
        args[0]->IsArrayBufferView())) {
    return node::THROW_ERR_INVALID_ARG_TYPE(
        env->isolate(),
        ""The \""list\"" argument must be an instance of SharedArrayBuffer, ""
        ""ArrayBuffer or ArrayBufferView."");
  }

  ArrayBufferViewContents<char> buffer(args[0]);

  bool ignore_bom = args[1]->IsTrue();
  bool has_fatal = args[2]->IsTrue();

  const char* data = buffer.data();
  size_t length = buffer.length();

  if (has_fatal) {
    auto result = simdutf::validate_utf8_with_errors(data, length);

    if (result.error) {
      return node::THROW_ERR_ENCODING_INVALID_ENCODED_DATA(
          env->isolate(), ""The encoded data was not valid for encoding utf-8"");
    }
  }

  if (!ignore_bom && length >= 3) {
    if (memcmp(data, ""...",146.0,197.0,1.0,1.0,52.0,58,14,55,19,0,0,8,10,0,0,,0,0,2,1,1,void
2125,74912,ToASCII,1,node.encoding_binding.BindingData.ToASCII,void node.encoding_binding.BindingData.ToASCII (ANY),encoding_binding.cc,"void BindingData::ToASCII(const v8::FunctionCallbackInfo<v8::Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  CHECK_GE(args.Length(), 1);
  CHECK(args[0]->IsString());

  Utf8Value input(env->isolate(), args[0]);
  auto out = ada::idna::to_ascii(input.ToStringView());
  args.GetReturnValue().Set(
      String::NewFromUtf8(env->isolate(), out.c_str()).ToLocalChecked());
}",199.0,208.0,1.0,1.0,10.0,17,4,15,8,0,0,1,1,0,0,,0,0,2,1,1,void
2126,74982,ToUnicode,1,node.encoding_binding.BindingData.ToUnicode,void node.encoding_binding.BindingData.ToUnicode (ANY),encoding_binding.cc,"void BindingData::ToUnicode(const v8::FunctionCallbackInfo<v8::Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  CHECK_GE(args.Length(), 1);
  CHECK(args[0]->IsString());

  Utf8Value input(env->isolate(), args[0]);
  auto out = ada::idna::to_unicode(input.ToStringView());
  args.GetReturnValue().Set(
      String::NewFromUtf8(env->isolate(), out.c_str()).ToLocalChecked());
}",210.0,219.0,1.0,1.0,10.0,17,4,15,8,0,0,1,1,0,0,,0,0,2,1,1,void
2127,75052,CreatePerIsolateProperties,1,node.encoding_binding.BindingData.CreatePerIsolateProperties,"void node.encoding_binding.BindingData.CreatePerIsolateProperties (IsolateData*,Local<FunctionTemplate>)",encoding_binding.cc,"void BindingData::CreatePerIsolateProperties(IsolateData* isolate_data,
                                             Local<FunctionTemplate> ctor) {
  Isolate* isolate = isolate_data->isolate();
  Local<ObjectTemplate> target = ctor->InstanceTemplate();
  SetMethod(isolate, target, ""encodeInto"", EncodeInto);
  SetMethodNoSideEffect(isolate, target, ""encodeUtf8String"", EncodeUtf8String);
  SetMethodNoSideEffect(isolate, target, ""decodeUTF8"", DecodeUTF8);
  SetMethodNoSideEffect(isolate, target, ""toASCII"", ToASCII);
  SetMethodNoSideEffect(isolate, target, ""toUnicode"", ToUnicode);
}",221.0,230.0,1.0,1.0,10.0,6,4,21,11,0,0,1,1,0,0,,0,0,4,2,2,void
2128,75100,CreatePerContextProperties,1,node.encoding_binding.BindingData.CreatePerContextProperties,"void node.encoding_binding.BindingData.CreatePerContextProperties (Local<Object>,Local<Value>,Local<Context>,void*)",encoding_binding.cc,"void BindingData::CreatePerContextProperties(Local<Object> target,
                                             Local<Value> unused,
                                             Local<Context> context,
                                             void* priv) {
  Realm* realm = Realm::GetCurrent(context);
  realm->AddBindingData<BindingData>(context, target);
}",232.0,238.0,1.0,1.0,7.0,7,7,7,5,0,0,1,1,0,0,,0,0,8,4,4,void
2129,75126,RegisterTimerExternalReferences,1,node.encoding_binding.BindingData.RegisterTimerExternalReferences,void node.encoding_binding.BindingData.RegisterTimerExternalReferences (ExternalReferenceRegistry*),encoding_binding.cc,"void BindingData::RegisterTimerExternalReferences(
    ExternalReferenceRegistry* registry) {
  registry->Register(EncodeInto);
  registry->Register(EncodeUtf8String);
  registry->Register(DecodeUTF8);
  registry->Register(ToASCII);
  registry->Register(ToUnicode);
}",240.0,247.0,1.0,1.0,8.0,5,1,10,6,0,0,1,1,0,0,,0,0,2,1,1,void
2130,75206,<lambda>0,1,node.Environment.UntrackContext.<lambda>0,ANY node.Environment.UntrackContext.<lambda>0 (auto),env.cc,[&](auto&& el) { return el.IsEmpty(); },218.0,218.0,34.0,72.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,ANY
2131,75218,<lambda>1,1,node.Environment.InitializeLibuv.<lambda>1,ANY node.Environment.InitializeLibuv.<lambda>1 (uv_async_t*),env.cc,"[](uv_async_t* async) {
        Environment* env = ContainerOf(
            &Environment::task_queues_async_, async);
        HandleScope handle_scope(env->isolate());
        Context::Scope context_scope(env->context());
        env->RunAndClearNativeImmediates();
      }",948.0,954.0,7.0,7.0,7.0,6,4,6,3,0,0,1,1,0,0,,0,0,2,1,1,ANY
2132,75249,<lambda>2,1,node.Environment.ExitEnv.<lambda>2,ANY node.Environment.ExitEnv.<lambda>2 (Environment*),env.cc,"[](Environment* env) {
    env->set_can_call_into_js(false);
    uv_stop(env->event_loop());
  }",982.0,985.0,26.0,3.0,4.0,2,1,2,1,0,0,1,1,0,0,,0,0,2,1,1,ANY
2133,75265,<lambda>4,1,node.Environment.RegisterHandleCleanups..<lambda>4,ANY node.Environment.RegisterHandleCleanups..<lambda>4 (uv_handle_t*),env.cc,"[](uv_handle_t* handle) {
#ifdef DEBUG
      memset(handle, 0xab, uv_handle_size(handle->type));
#endif
    }",993.0,997.0,30.0,5.0,5.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
2134,75271,<lambda>3,1,node.Environment.RegisterHandleCleanups.<lambda>3,"ANY node.Environment.RegisterHandleCleanups.<lambda>3 (Environment*,uv_handle_t*,void*)",env.cc,"[](Environment* env, uv_handle_t* handle,
                                        void* arg) {
    handle->data = env;

    env->CloseHandle(handle, [](uv_handle_t* handle) {
#ifdef DEBUG
      memset(handle, 0xab, uv_handle_size(handle->type));
#endif
    });
  }",989.0,998.0,38.0,3.0,10.0,3,2,4,2,0,0,1,1,0,0,,0,0,6,3,3,ANY
2135,75290,<lambda>5,1,node.Environment.RegisterHandleCleanups.<lambda>5,ANY node.Environment.RegisterHandleCleanups.<lambda>5 (uv_handle_t*),env.cc,"[&](uv_handle_t* handle) {
    RegisterHandleCleanup(handle, close_and_finish, nullptr);
  }",1000.0,1002.0,26.0,3.0,3.0,0,0,2,2,0,0,1,1,0,0,,0,0,2,1,1,ANY
2136,75301,<lambda>6,1,node.Environment.StartProfilerIdleNotifier.<lambda>6,ANY node.Environment.StartProfilerIdleNotifier.<lambda>6 (uv_prepare_t*),env.cc,"[](uv_prepare_t* handle) {
    Environment* env = ContainerOf(&Environment::idle_prepare_handle_, handle);
    env->isolate()->SetIdle(true);
  }",1040.0,1043.0,43.0,3.0,4.0,5,4,4,3,0,0,1,1,0,0,,0,0,2,1,1,ANY
2137,75324,<lambda>7,1,node.Environment.StartProfilerIdleNotifier.<lambda>7,ANY node.Environment.StartProfilerIdleNotifier.<lambda>7 (uv_check_t*),env.cc,"[](uv_check_t* handle) {
    Environment* env = ContainerOf(&Environment::idle_check_handle_, handle);
    env->isolate()->SetIdle(false);
  }",1044.0,1047.0,39.0,3.0,4.0,5,4,4,3,0,0,1,1,0,0,,0,0,2,1,1,ANY
2138,75347,<lambda>8,1,node.Environment.RunAndClearNativeImmediates.<lambda>8,ANY node.Environment.RunAndClearNativeImmediates.<lambda>8 (NativeImmediateQueue*),env.cc,"[&](NativeImmediateQueue* queue) {
    TryCatchScope try_catch(this);
    DebugSealHandleScope seal_handle_scope(isolate());
    while (auto head = queue->Shift()) {
      bool is_refed = head->flags() & CallbackFlags::kRefed;
      if (is_refed)
        ref_count++;

      if (is_refed || !only_refed)
        head->Call(this);

      head.reset();  // Destroy now so that this is also observed by try_catch.

      if (UNLIKELY(try_catch.HasCaught())) {
        if (!try_catch.HasTerminated() && can_call_into_js())
          errors::TriggerUncaughtException(isolate(), try_catch);

        return true;
      }
    }
    return false;
  }",1150.0,1171.0,21.0,3.0,22.0,14,8,13,7,0,0,6,11,0,0,,0,0,2,1,1,ANY
2139,75420,<lambda>9,1,node.Environment.RequestInterruptFromV8.<lambda>9,"ANY node.Environment.RequestInterruptFromV8.<lambda>9 (Isolate*,void*)",env.cc,"[](Isolate* isolate, void* data) {
    std::unique_ptr<Environment*> env_ptr { static_cast<Environment**>(data) };
    Environment* env = *env_ptr;
    if (env == nullptr) {
      // The Environment has already been destroyed. That should be okay; any
      // callback added before the Environment shuts down would have been
      // handled during cleanup.
      return;
    }
    env->interrupt_data_.store(nullptr);
    env->RunAndClearInterrupts();
  }",1213.0,1224.0,31.0,3.0,12.0,9,7,7,3,0,0,2,2,0,0,,0,0,4,2,2,ANY
2140,75456,<lambda>10,1,node.Environment.ToggleImmediateRef.<lambda>10,ANY node.Environment.ToggleImmediateRef.<lambda>10 (uv_idle_t*),env.cc,[](uv_idle_t*){ },1333.0,1333.0,44.0,60.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
2141,75539,ResetPromiseHooks,1,node.AsyncHooks.ResetPromiseHooks,"void node.AsyncHooks.ResetPromiseHooks (Local<Function>,Local<Function>,Local<Function>,Local<Function>)",env.cc,"void AsyncHooks::ResetPromiseHooks(Local<Function> init,
                                   Local<Function> before,
                                   Local<Function> after,
                                   Local<Function> resolve) {
  js_promise_hooks_[0].Reset(env()->isolate(), init);
  js_promise_hooks_[1].Reset(env()->isolate(), before);
  js_promise_hooks_[2].Reset(env()->isolate(), after);
  js_promise_hooks_[3].Reset(env()->isolate(), resolve);
}",68.0,76.0,1.0,1.0,9.0,12,3,8,5,0,0,1,1,0,0,,0,0,8,4,4,void
2142,75591,ResetPromiseHooks,1,node.Environment.ResetPromiseHooks,"void node.Environment.ResetPromiseHooks (Local<Function>,Local<Function>,Local<Function>,Local<Function>)",env.cc,"void Environment::ResetPromiseHooks(Local<Function> init,
                                    Local<Function> before,
                                    Local<Function> after,
                                    Local<Function> resolve) {
  async_hooks()->ResetPromiseHooks(init, before, after, resolve);

  for (auto it = contexts_.begin(); it != contexts_.end(); it++) {
    if (it->IsEmpty()) {
      contexts_.erase(it--);
      continue;
    }
    PersistentToLocal::Weak(isolate_, *it)
        ->SetPromiseHooks(init, before, after, resolve);
  }
}",78.0,92.0,1.0,1.0,15.0,11,6,18,8,0,0,4,4,0,0,,0,0,8,4,4,void
2143,75652,push_async_context,1,node.AsyncHooks.push_async_context,"void node.AsyncHooks.push_async_context (double,double,Local<Object>)",env.cc,"void AsyncHooks::push_async_context(double async_id,
                                    double trigger_async_id,
                                    Local<Object> resource) {
  // Since async_hooks is experimental, do only perform the check
  // when async_hooks is enabled.
  if (fields_[kCheck] > 0) {
    CHECK_GE(async_id, -1);
    CHECK_GE(trigger_async_id, -1);
  }

  uint32_t offset = fields_[kStackLength];
  if (offset * 2 >= async_ids_stack_.Length()) grow_async_ids_stack();
  async_ids_stack_[2 * offset] = async_id_fields_[kExecutionAsyncId];
  async_ids_stack_[2 * offset + 1] = async_id_fields_[kTriggerAsyncId];
  fields_[kStackLength] += 1;
  async_id_fields_[kExecutionAsyncId] = async_id;
  async_id_fields_[kTriggerAsyncId] = trigger_async_id;

#ifdef DEBUG
  for (uint32_t i = offset; i < native_execution_async_resources_.size(); i++)
    CHECK(native_execution_async_resources_[i].IsEmpty());
#endif

  // When this call comes from JS (as a way of increasing the stack siz...",95.0,125.0,1.0,1.0,31.0,30,10,31,12,0,0,4,4,0,0,,0,0,6,3,3,void
2144,75745,pop_async_context,1,node.AsyncHooks.pop_async_context,bool node.AsyncHooks.pop_async_context (double),env.cc,"bool AsyncHooks::pop_async_context(double async_id) {
  // In case of an exception then this may have already been reset, if the
  // stack was multiple MakeCallback()'s deep.
  if (UNLIKELY(fields_[kStackLength] == 0)) return false;

  // Ask for the async_id to be restored as a check that the stack
  // hasn't been corrupted.
  if (UNLIKELY(fields_[kCheck] > 0 &&
               async_id_fields_[kExecutionAsyncId] != async_id)) {
    FailWithCorruptedAsyncStack(async_id);
  }

  uint32_t offset = fields_[kStackLength] - 1;
  async_id_fields_[kExecutionAsyncId] = async_ids_stack_[2 * offset];
  async_id_fields_[kTriggerAsyncId] = async_ids_stack_[2 * offset + 1];
  fields_[kStackLength] = offset;

  if (LIKELY(offset < native_execution_async_resources_.size() &&
             !native_execution_async_resources_[offset].IsEmpty())) {
#ifdef DEBUG
    for (uint32_t i = offset + 1; i < native_execution_async_resources_.size();
         i++) {
      CHECK(native_execution_async_resources_...",128.0,170.0,1.0,1.0,43.0,46,14,37,11,0,0,6,7,0,0,,0,0,2,1,1,bool
2145,75898,clear_async_id_stack,1,node.AsyncHooks.clear_async_id_stack,void node.AsyncHooks.clear_async_id_stack (),env.cc,"void AsyncHooks::clear_async_id_stack() {
  if (env()->can_call_into_js()) {
    Isolate* isolate = env()->isolate();
    HandleScope handle_scope(isolate);
    if (!js_execution_async_resources_.IsEmpty()) {
      USE(PersistentToLocal::Strong(js_execution_async_resources_)
              ->Set(env()->context(),
                    env()->length_string(),
                    Integer::NewFromUnsigned(isolate, 0)));
    }
  }

  native_execution_async_resources_.clear();
  native_execution_async_resources_.shrink_to_fit();

  async_id_fields_[kExecutionAsyncId] = 0;
  async_id_fields_[kTriggerAsyncId] = 0;
  fields_[kStackLength] = 0;
}",172.0,190.0,1.0,1.0,19.0,18,5,15,10,0,0,3,4,0,0,,0,0,0,0,0,void
2146,75971,InstallPromiseHooks,1,node.AsyncHooks.InstallPromiseHooks,void node.AsyncHooks.InstallPromiseHooks (Local<Context>),env.cc,"void AsyncHooks::InstallPromiseHooks(Local<Context> ctx) {
  ctx->SetPromiseHooks(js_promise_hooks_[0].IsEmpty()
                           ? Local<Function>()
                           : PersistentToLocal::Strong(js_promise_hooks_[0]),
                       js_promise_hooks_[1].IsEmpty()
                           ? Local<Function>()
                           : PersistentToLocal::Strong(js_promise_hooks_[1]),
                       js_promise_hooks_[2].IsEmpty()
                           ? Local<Function>()
                           : PersistentToLocal::Strong(js_promise_hooks_[2]),
                       js_promise_hooks_[3].IsEmpty()
                           ? Local<Function>()
                           : PersistentToLocal::Strong(js_promise_hooks_[3]));
}",192.0,205.0,1.0,1.0,14.0,21,4,13,3,0,0,1,1,0,0,,0,0,2,1,1,void
2147,76040,TrackContext,1,node.Environment.TrackContext,void node.Environment.TrackContext (Local<Context>),env.cc,"void Environment::TrackContext(Local<Context> context) {
  size_t id = contexts_.size();
  contexts_.resize(id + 1);
  contexts_[id].Reset(isolate_, context);
  contexts_[id].SetWeak();
}",207.0,212.0,1.0,1.0,6.0,8,4,10,4,0,0,1,1,0,0,,0,0,2,1,1,void
2148,76073,UntrackContext,1,node.Environment.UntrackContext,void node.Environment.UntrackContext (Local<Context>),env.cc,"void Environment::UntrackContext(Local<Context> context) {
  HandleScope handle_scope(isolate_);
  contexts_.erase(std::remove_if(contexts_.begin(),
                                 contexts_.end(),
                                 [&](auto&& el) { return el.IsEmpty(); }),
                  contexts_.end());
  for (auto it = contexts_.begin(); it != contexts_.end(); it++) {
    Local<Context> saved_context = PersistentToLocal::Weak(isolate_, *it);
    if (saved_context == context) {
      it->Reset();
      contexts_.erase(it);
      break;
    }
  }
}",214.0,228.0,1.0,1.0,15.0,17,8,21,9,0,0,4,4,0,0,,0,0,2,1,1,void
2149,76148,TrackShadowRealm,1,node.Environment.TrackShadowRealm,void node.Environment.TrackShadowRealm (ANY*),env.cc,"void Environment::TrackShadowRealm(shadow_realm::ShadowRealm* realm) {
  shadow_realms_.insert(realm);
}",230.0,232.0,1.0,1.0,3.0,1,1,2,2,0,0,1,1,0,0,,0,0,2,1,1,void
2150,76158,UntrackShadowRealm,1,node.Environment.UntrackShadowRealm,void node.Environment.UntrackShadowRealm (ANY*),env.cc,"void Environment::UntrackShadowRealm(shadow_realm::ShadowRealm* realm) {
  shadow_realms_.erase(realm);
}",234.0,236.0,1.0,1.0,3.0,1,1,2,2,0,0,1,1,0,0,,0,0,2,1,1,void
2151,76168,DefaultTriggerAsyncIdScope,1,node.AsyncHooks.DefaultTriggerAsyncIdScope.DefaultTriggerAsyncIdScope,"ANY node.AsyncHooks.DefaultTriggerAsyncIdScope.DefaultTriggerAsyncIdScope (Environment*,double)",env.cc,"AsyncHooks::DefaultTriggerAsyncIdScope::DefaultTriggerAsyncIdScope(
    AsyncWrap* async_wrap)
    : DefaultTriggerAsyncIdScope(async_wrap->env(),
                                 async_wrap->get_async_id()) {}",256.0,259.0,1.0,63.0,4.0,13,5,9,5,0,0,2,2,0,0,,0,0,2,1,1,ANY
2152,76212,~DefaultTriggerAsyncIdScope,1,node.AsyncHooks.DefaultTriggerAsyncIdScope.~DefaultTriggerAsyncIdScope,ANY node.AsyncHooks.DefaultTriggerAsyncIdScope.~DefaultTriggerAsyncIdScope (),env.cc,"AsyncHooks::DefaultTriggerAsyncIdScope::~DefaultTriggerAsyncIdScope() {
  async_hooks_->async_id_fields()[AsyncHooks::kDefaultTriggerAsyncId] =
      old_default_trigger_async_id_;
}",251.0,254.0,1.0,1.0,4.0,4,4,3,3,0,0,1,1,0,0,,0,0,0,0,0,ANY
2153,76231,operator <<,1,node.operator <<,"ostream node.operator << (ANY,ANY)",node_snapshotable.cc,"std::ostream& operator<<(std::ostream& output, const EnvSerializeInfo& i) {
  output << ""{\n""
         << ""// -- async_hooks begins --\n""
         << i.async_hooks << "",\n""
         << ""// -- async_hooks ends --\n""
         << i.tick_info << "",  // tick_info\n""
         << i.immediate_info << "",  // immediate_info\n""
         << i.timeout_info << "",  // timeout_info\n""
         << ""// -- performance_state begins --\n""
         << i.performance_state << "",\n""
         << ""// -- performance_state ends --\n""
         << i.exit_info << "",  // exit_info\n""
         << i.stream_base_state << "",  // stream_base_state\n""
         << i.should_abort_on_uncaught_toggle
         << "",  // should_abort_on_uncaught_toggle\n""
         << ""// -- principal_realm begins --\n""
         << i.principal_realm << "",\n""
         << ""// -- principal_realm ends --\n""
         << ""}"";
  return output;
}",122.0,142.0,1.0,1.0,21.0,4,1,6,3,0,0,2,2,0,0,,0,0,4,2,2,ostream
2154,76349,Serialize,1,node.IsolateData.Serialize,IsolateDataSerializeInfo node.IsolateData.Serialize (SnapshotCreator*),env.cc,"IsolateDataSerializeInfo IsolateData::Serialize(SnapshotCreator* creator) {
  Isolate* isolate = creator->GetIsolate();
  IsolateDataSerializeInfo info;
  HandleScope handle_scope(isolate);
  // XXX(joyeecheung): technically speaking, the indexes here should be
  // consecutive and we could just return a range instead of an array,
  // but that's not part of the V8 API contract so we use an array
  // just to be safe.

#define VP(PropertyName, StringValue) V(Private, PropertyName)
#define VY(PropertyName, StringValue) V(Symbol, PropertyName)
#define VS(PropertyName, StringValue) V(String, PropertyName)
#define VR(PropertyName, TypeName) V(Private, per_realm_##PropertyName)
#define V(TypeName, PropertyName)                                              \
  info.primitive_values.push_back(                                             \
      creator->AddData(PropertyName##_.Get(isolate)));
  PER_ISOLATE_PRIVATE_SYMBOL_PROPERTIES(VP)
  PER_ISOLATE_SYMBOL_PROPERTIES(VY)
  PER_ISOLATE_STRI...",299.0,344.0,1.0,1.0,46.0,6,4,8,6,0,0,2,2,0,0,,0,0,2,1,1,IsolateDataSerializeInfo
2155,76408,DeserializeProperties,1,node.IsolateData.DeserializeProperties,void node.IsolateData.DeserializeProperties (IsolateDataSerializeInfo*),env.cc,"void IsolateData::DeserializeProperties(const IsolateDataSerializeInfo* info) {
  size_t i = 0;
  HandleScope handle_scope(isolate_);

  if (per_process::enabled_debug_list.enabled(DebugCategory::MKSNAPSHOT)) {
    fprintf(stderr, ""deserializing IsolateDataSerializeInfo...\n"");
    std::cerr << *info << ""\n"";
  }

#define VP(PropertyName, StringValue) V(Private, PropertyName)
#define VY(PropertyName, StringValue) V(Symbol, PropertyName)
#define VS(PropertyName, StringValue) V(String, PropertyName)
#define VR(PropertyName, TypeName) V(Private, per_realm_##PropertyName)
#define V(TypeName, PropertyName)                                              \
  do {                                                                         \
    MaybeLocal<TypeName> maybe_field =                                         \
        isolate_->GetDataFromSnapshotOnce<TypeName>(                           \
            info->primitive_values[i++]);                                      \
    Local<TypeNam...",346.0,416.0,1.0,1.0,71.0,31,11,32,17,0,0,4,5,0,0,,0,0,2,1,1,void
2156,76523,CreateProperties,1,node.IsolateData.CreateProperties,void node.IsolateData.CreateProperties (),env.cc,"void IsolateData::CreateProperties() {
  // Create string and private symbol properties as internalized one byte
  // strings after the platform is properly initialized.
  //
  // Internalized because it makes property lookups a little faster and
  // because the string is created in the old space straight away.  It's going
  // to end up in the old space sooner or later anyway but now it doesn't go
  // through v8::Eternal's new space handling first.
  //
  // One byte because our strings are ASCII and we can safely skip V8's UTF-8
  // decoding step.

  HandleScope handle_scope(isolate_);

#define V(PropertyName, StringValue)                                           \
  PropertyName##_.Set(                                                         \
      isolate_,                                                                \
      Private::New(isolate_,                                                   \
                   String::NewFromOneByte(                                ...",418.0,501.0,1.0,1.0,84.0,10,5,10,8,0,0,1,1,0,0,,0,0,0,0,0,void
2157,76574,IsolateData,1,node.IsolateData.IsolateData,"ANY node.IsolateData.IsolateData (Isolate*,uv_loop_t*,MultiIsolatePlatform*,ArrayBufferAllocator*,SnapshotData*)",env.cc,"IsolateData::IsolateData(Isolate* isolate,
                         uv_loop_t* event_loop,
                         MultiIsolatePlatform* platform,
                         ArrayBufferAllocator* node_allocator,
                         const SnapshotData* snapshot_data)
    : isolate_(isolate),
      event_loop_(event_loop),
      node_allocator_(node_allocator == nullptr ? nullptr
                                                : node_allocator->GetImpl()),
      platform_(platform),
      snapshot_data_(snapshot_data) {
  options_.reset(
      new PerIsolateOptions(*(per_process::cli_options->per_isolate)));

  if (snapshot_data == nullptr) {
    CreateProperties();
  } else {
    DeserializeProperties(&snapshot_data->isolate_data_info);
  }
}",503.0,522.0,1.0,1.0,20.0,6,5,4,4,0,0,2,2,0,0,,0,0,10,5,5,ANY
2158,76608,MemoryInfo,1,node.IsolateData.MemoryInfo,void node.IsolateData.MemoryInfo (MemoryTracker*),env.cc,"void IsolateData::MemoryInfo(MemoryTracker* tracker) const {
#define V(PropertyName, StringValue)                                           \
  tracker->TrackField(#PropertyName, PropertyName());
  PER_ISOLATE_SYMBOL_PROPERTIES(V)

  PER_ISOLATE_STRING_PROPERTIES(V)
#undef V

  tracker->TrackField(""async_wrap_providers"", async_wrap_providers_);

  if (node_allocator_ != nullptr) {
    tracker->TrackFieldWithSize(
        ""node_allocator"", sizeof(*node_allocator_), ""NodeArrayBufferAllocator"");
  }
  tracker->TrackFieldWithSize(
      ""platform"", sizeof(*platform_), ""MultiIsolatePlatform"");
  // TODO(joyeecheung): implement MemoryRetainer in the option classes.
}",524.0,541.0,1.0,1.0,18.0,8,4,7,4,0,0,2,2,0,0,,0,0,2,1,1,void
2159,76646,UpdateTraceCategoryState,1,node.TrackingTraceStateObserver.UpdateTraceCategoryState,void node.TrackingTraceStateObserver.UpdateTraceCategoryState (),env.cc,"void TrackingTraceStateObserver::UpdateTraceCategoryState() {
  if (!env_->owns_process_state() || !env_->can_call_into_js()) {
    // Ideally, wed have a consistent story that treats all threads/Environment
    // instances equally here. However, tracing is essentially global, and this
    // callback is called from whichever thread calls `StartTracing()` or
    // `StopTracing()`. The only way to do this in a threadsafe fashion
    // seems to be only tracking this from the main thread, and only allowing
    // these state modifications from the main thread.
    return;
  }

  if (env_->principal_realm() == nullptr) {
    return;
  }

  bool async_hooks_enabled = (*(TRACE_EVENT_API_GET_CATEGORY_GROUP_ENABLED(
                                 TRACING_CATEGORY_NODE1(async_hooks)))) != 0;

  Isolate* isolate = env_->isolate();
  HandleScope handle_scope(isolate);
  Local<Function> cb = env_->trace_category_state_function();
  if (cb.IsEmpty())
    return;
  TryCatchScope try_catch(e...",543.0,570.0,1.0,1.0,28.0,23,11,24,10,0,0,4,4,0,0,,0,0,0,0,0,void
2160,76741,AssignToContext,1,node.Environment.AssignToContext,"void node.Environment.AssignToContext (ANY,Realm*,ContextInfo)",env.cc,"void Environment::AssignToContext(Local<v8::Context> context,
                                  Realm* realm,
                                  const ContextInfo& info) {
  context->SetAlignedPointerInEmbedderData(ContextEmbedderIndex::kEnvironment,
                                           this);
  context->SetAlignedPointerInEmbedderData(ContextEmbedderIndex::kRealm, realm);
  // Used to retrieve bindings
  context->SetAlignedPointerInEmbedderData(
      ContextEmbedderIndex::kBindingDataStoreIndex,
      realm->binding_data_store());

  // ContextifyContexts will update this to a pointer to the native object.
  context->SetAlignedPointerInEmbedderData(
      ContextEmbedderIndex::kContextifyContext, nullptr);

  // This must not be done before other context fields are initialized.
  ContextEmbedderTag::TagNodeContext(context);

#if HAVE_INSPECTOR
  inspector_agent()->ContextCreated(context, info);
#endif  // HAVE_INSPECTOR

  this->async_hooks()->InstallPromiseHooks(context);
  ...",572.0,596.0,1.0,1.0,25.0,12,2,14,4,0,0,1,1,0,0,,0,0,6,3,3,void
2161,76798,TryLoadAddon,1,node.Environment.TryLoadAddon,"void node.Environment.TryLoadAddon (char*,int,ANY)",env.cc,"void Environment::TryLoadAddon(
    const char* filename,
    int flags,
    const std::function<bool(binding::DLib*)>& was_loaded) {
  loaded_addons_.emplace_back(filename, flags);
  if (!was_loaded(&loaded_addons_.back())) {
    loaded_addons_.pop_back();
  }
}",598.0,606.0,1.0,1.0,9.0,5,3,5,3,0,0,2,2,0,0,,0,0,6,3,3,void
2162,76824,GetCwd,1,node.Environment.GetCwd,string node.Environment.GetCwd (),env.cc,"std::string Environment::GetCwd() {
  char cwd[PATH_MAX_BYTES];
  size_t size = PATH_MAX_BYTES;
  const int err = uv_cwd(cwd, &size);

  if (err == 0) {
    CHECK_GT(size, 0);
    return cwd;
  }

  // This can fail if the cwd is deleted. In that case, fall back to
  // exec_path.
  const std::string& exec_path = exec_path_;
  return exec_path.substr(0, exec_path.find_last_of(kPathSeparator));
}",608.0,622.0,1.0,1.0,15.0,7,4,13,7,0,0,2,2,0,0,,0,0,0,0,0,string
2163,76865,add_refs,1,node.Environment.add_refs,void node.Environment.add_refs (int64_t),env.cc,"void Environment::add_refs(int64_t diff) {
  task_queues_async_refs_ += diff;
  CHECK_GE(task_queues_async_refs_, 0);
  if (task_queues_async_refs_ == 0)
    uv_unref(reinterpret_cast<uv_handle_t*>(&task_queues_async_));
  else
    uv_ref(reinterpret_cast<uv_handle_t*>(&task_queues_async_));
}",624.0,631.0,1.0,1.0,8.0,4,4,5,3,0,0,2,2,0,0,,0,0,2,1,1,void
2164,76893,allocate_managed_buffer,1,node.Environment.allocate_managed_buffer,uv_buf_t node.Environment.allocate_managed_buffer (size_t),env.cc,"uv_buf_t Environment::allocate_managed_buffer(const size_t suggested_size) {
  NoArrayBufferZeroFillScope no_zero_fill_scope(isolate_data());
  std::unique_ptr<v8::BackingStore> bs =
      v8::ArrayBuffer::NewBackingStore(isolate(), suggested_size);
  uv_buf_t buf = uv_buf_init(static_cast<char*>(bs->Data()), bs->ByteLength());
  released_allocated_buffers_.emplace(buf.base, std::move(bs));
  return buf;
}",633.0,640.0,1.0,1.0,8.0,14,6,14,7,0,0,1,1,0,0,,0,0,2,1,1,uv_buf_t
2165,76947,release_managed_buffer,1,node.Environment.release_managed_buffer,unique_ptr<v8::BackingStore> node.Environment.release_managed_buffer (uv_buf_t),env.cc,"std::unique_ptr<v8::BackingStore> Environment::release_managed_buffer(
    const uv_buf_t& buf) {
  std::unique_ptr<v8::BackingStore> bs;
  if (buf.base != nullptr) {
    auto it = released_allocated_buffers_.find(buf.base);
    CHECK_NE(it, released_allocated_buffers_.end());
    bs = std::move(it->second);
    released_allocated_buffers_.erase(it);
  }
  return bs;
}",642.0,652.0,1.0,1.0,11.0,14,6,15,6,0,0,2,2,0,0,,0,0,2,1,1,unique_ptr<v8.BackingStore>
2166,77000,GetExecPath,1,node.GetExecPath,string node.GetExecPath (ANY),env.cc,"std::string GetExecPath(const std::vector<std::string>& argv) {
  char exec_path_buf[2 * PATH_MAX];
  size_t exec_path_len = sizeof(exec_path_buf);
  std::string exec_path;
  if (uv_exepath(exec_path_buf, &exec_path_len) == 0) {
    exec_path = std::string(exec_path_buf, exec_path_len);
  } else if (argv.size() > 0) {
    exec_path = argv[0];
  }

  // On OpenBSD process.execPath will be relative unless we
  // get the full path before process.execPath is used.
#if defined(__OpenBSD__)
  uv_fs_t req;
  req.ptr = nullptr;
  if (0 ==
      uv_fs_realpath(nullptr, &req, exec_path.c_str(), nullptr)) {
    CHECK_NOT_NULL(req.ptr);
    exec_path = std::string(static_cast<char*>(req.ptr));
  }
  uv_fs_req_cleanup(&req);
#endif

  return exec_path;
}",654.0,678.0,1.0,1.0,25.0,6,5,9,4,0,0,2,2,0,0,,0,0,2,1,1,string
2167,77045,Environment,1,node.Environment.Environment,"ANY node.Environment.Environment (IsolateData*,Isolate*,ANY,ANY,EnvSerializeInfo*,ANY,ThreadId)",env.cc,"Environment::Environment(IsolateData* isolate_data,
                         Isolate* isolate,
                         const std::vector<std::string>& args,
                         const std::vector<std::string>& exec_args,
                         const EnvSerializeInfo* env_info,
                         EnvironmentFlags::Flags flags,
                         ThreadId thread_id)
    : isolate_(isolate),
      isolate_data_(isolate_data),
      async_hooks_(isolate, MAYBE_FIELD_PTR(env_info, async_hooks)),
      immediate_info_(isolate, MAYBE_FIELD_PTR(env_info, immediate_info)),
      timeout_info_(isolate_, 1, MAYBE_FIELD_PTR(env_info, timeout_info)),
      tick_info_(isolate, MAYBE_FIELD_PTR(env_info, tick_info)),
      timer_base_(uv_now(isolate_data->event_loop())),
      exec_argv_(exec_args),
      argv_(args),
      exec_path_(GetExecPath(args)),
      exit_info_(
          isolate_, kExitInfoFieldCount, MAYBE_FIELD_PTR(env_info, exit_info)),
      should_abort_on_uncaugh...",680.0,817.0,1.0,1.0,138.0,99,16,73,31,0,0,15,25,0,0,,0,0,14,7,7,ANY
2168,77406,InitializeMainContext,1,node.Environment.InitializeMainContext,"void node.Environment.InitializeMainContext (Local<Context>,EnvSerializeInfo*)",env.cc,"void Environment::InitializeMainContext(Local<Context> context,
                                        const EnvSerializeInfo* env_info) {
  principal_realm_ = std::make_unique<PrincipalRealm>(
      this, context, MAYBE_FIELD_PTR(env_info, principal_realm));
  AssignToContext(context, principal_realm_.get(), ContextInfo(""""));
  if (env_info != nullptr) {
    DeserializeProperties(env_info);
  }

  if (!options_->force_async_hooks_checks) {
    async_hooks_.no_force_checks();
  }

  // By default, always abort when --abort-on-uncaught-exception was passed.
  should_abort_on_uncaught_toggle_[0] = 1;

  // The process is not exiting by default.
  set_exiting(false);

  performance_state_->Mark(performance::NODE_PERFORMANCE_MILESTONE_ENVIRONMENT,
                           environment_start_);
  performance_state_->Mark(performance::NODE_PERFORMANCE_MILESTONE_NODE_START,
                           per_process::node_start_time);

  if (per_process::v8_initialized) {
    performance_sta...",819.0,847.0,1.0,1.0,29.0,22,10,23,13,0,0,4,4,0,0,,0,0,4,2,2,void
2169,77492,~Environment,1,node.Environment.~Environment,ANY node.Environment.~Environment (),env.cc,"Environment::~Environment() {
  HandleScope handle_scope(isolate());
  Local<Context> ctx = context();

  if (Environment** interrupt_data = interrupt_data_.load()) {
    // There are pending RequestInterrupt() callbacks. Tell them not to run,
    // then force V8 to run interrupts by compiling and running an empty script
    // so as not to leak memory.
    *interrupt_data = nullptr;

    Isolate::AllowJavascriptExecutionScope allow_js_here(isolate());
    TryCatch try_catch(isolate());
    Context::Scope context_scope(ctx);

#ifdef DEBUG
    bool consistency_check = false;
    isolate()->RequestInterrupt([](Isolate*, void* data) {
      *static_cast<bool*>(data) = true;
    }, &consistency_check);
#endif

    Local<Script> script;
    if (Script::Compile(ctx, String::Empty(isolate())).ToLocal(&script))
      USE(script->Run(ctx));

    DCHECK(consistency_check);
  }

  // FreeEnvironment() should have set this.
  CHECK(is_stopping());

  if (heapsnapshot_near_heap_limit_callback_a...",849.0,922.0,1.0,1.0,74.0,28,8,34,19,0,0,9,12,0,0,,0,0,0,0,0,ANY
2170,77641,InitializeLibuv,1,node.Environment.InitializeLibuv,void node.Environment.InitializeLibuv (),env.cc,"void Environment::InitializeLibuv() {
  HandleScope handle_scope(isolate());
  Context::Scope context_scope(context());

  CHECK_EQ(0, uv_timer_init(event_loop(), timer_handle()));
  uv_unref(reinterpret_cast<uv_handle_t*>(timer_handle()));

  CHECK_EQ(0, uv_check_init(event_loop(), immediate_check_handle()));
  uv_unref(reinterpret_cast<uv_handle_t*>(immediate_check_handle()));

  CHECK_EQ(0, uv_idle_init(event_loop(), immediate_idle_handle()));

  CHECK_EQ(0, uv_check_start(immediate_check_handle(), CheckImmediate));

  // Inform V8's CPU profiler when we're idle.  The profiler is sampling-based
  // but not all samples are created equal; mark the wall clock time spent in
  // epoll_wait() and friends so profiling tools can filter it out.  The samples
  // still end up in v8.log but with state=IDLE rather than state=EXTERNAL.
  CHECK_EQ(0, uv_prepare_init(event_loop(), &idle_prepare_handle_));
  CHECK_EQ(0, uv_check_init(event_loop(), &idle_check_handle_));

  CHECK_EQ(0, uv_async...",924.0,975.0,1.0,1.0,52.0,17,6,11,8,0,0,2,2,0,0,,0,0,0,0,0,void
2171,77738,ExitEnv,1,node.Environment.ExitEnv,void node.Environment.ExitEnv (ANY),env.cc,"void Environment::ExitEnv(StopFlags::Flags flags) {
  // Should not access non-thread-safe methods here.
  set_stopping(true);
  if ((flags & StopFlags::kDoNotTerminateIsolate) == 0)
    isolate_->TerminateExecution();
  SetImmediateThreadsafe([](Environment* env) {
    env->set_can_call_into_js(false);
    uv_stop(env->event_loop());
  });
}",977.0,986.0,1.0,1.0,10.0,4,4,3,3,0,0,2,2,0,0,,0,0,2,1,1,void
2172,77760,RegisterHandleCleanups,1,node.Environment.RegisterHandleCleanups,void node.Environment.RegisterHandleCleanups (),env.cc,"void Environment::RegisterHandleCleanups() {
  HandleCleanupCb close_and_finish = [](Environment* env, uv_handle_t* handle,
                                        void* arg) {
    handle->data = env;

    env->CloseHandle(handle, [](uv_handle_t* handle) {
#ifdef DEBUG
      memset(handle, 0xab, uv_handle_size(handle->type));
#endif
    });
  };

  auto register_handle = [&](uv_handle_t* handle) {
    RegisterHandleCleanup(handle, close_and_finish, nullptr);
  };
  register_handle(reinterpret_cast<uv_handle_t*>(timer_handle()));
  register_handle(reinterpret_cast<uv_handle_t*>(immediate_check_handle()));
  register_handle(reinterpret_cast<uv_handle_t*>(immediate_idle_handle()));
  register_handle(reinterpret_cast<uv_handle_t*>(&idle_prepare_handle_));
  register_handle(reinterpret_cast<uv_handle_t*>(&idle_check_handle_));
  register_handle(reinterpret_cast<uv_handle_t*>(&task_queues_async_));
}",988.0,1009.0,1.0,1.0,22.0,11,3,5,5,0,0,1,1,0,0,,0,0,0,0,0,void
2173,77798,CleanupHandles,1,node.Environment.CleanupHandles,void node.Environment.CleanupHandles (),env.cc,"void Environment::CleanupHandles() {
  {
    Mutex::ScopedLock lock(native_immediates_threadsafe_mutex_);
    task_queues_async_initialized_ = false;
  }

  Isolate::DisallowJavascriptExecutionScope disallow_js(isolate(),
      Isolate::DisallowJavascriptExecutionScope::THROW_ON_FAILURE);

  RunAndClearNativeImmediates(true /* skip unrefed SetImmediate()s */);

  for (ReqWrapBase* request : req_wrap_queue_)
    request->Cancel();

  for (HandleWrap* handle : handle_wrap_queue_)
    handle->Close();

  for (HandleCleanup& hc : handle_cleanup_queue_)
    hc.cb_(this, hc.handle_, hc.arg_);
  handle_cleanup_queue_.clear();

  while (handle_cleanup_waiting_ != 0 ||
         request_waiting_ != 0 ||
         !handle_wrap_queue_.IsEmpty()) {
    uv_run(event_loop(), UV_RUN_ONCE);
  }
}",1011.0,1037.0,1.0,1.0,27.0,10,5,12,10,0,0,5,5,0,0,,0,0,0,0,0,void
2174,77869,StartProfilerIdleNotifier,1,node.Environment.StartProfilerIdleNotifier,void node.Environment.StartProfilerIdleNotifier (),env.cc,"void Environment::StartProfilerIdleNotifier() {
  uv_prepare_start(&idle_prepare_handle_, [](uv_prepare_t* handle) {
    Environment* env = ContainerOf(&Environment::idle_prepare_handle_, handle);
    env->isolate()->SetIdle(true);
  });
  uv_check_start(&idle_check_handle_, [](uv_check_t* handle) {
    Environment* env = ContainerOf(&Environment::idle_check_handle_, handle);
    env->isolate()->SetIdle(false);
  });
}",1039.0,1048.0,1.0,1.0,10.0,2,1,2,2,0,0,1,1,0,0,,0,0,0,0,0,void
2175,77881,PrintSyncTrace,1,node.Environment.PrintSyncTrace,void node.Environment.PrintSyncTrace (),env.cc,"void Environment::PrintSyncTrace() const {
  if (!trace_sync_io_) return;

  HandleScope handle_scope(isolate());

  fprintf(
      stderr, ""(node:%d) WARNING: Detected use of sync API\n"", uv_os_getpid());
  PrintStackTrace(isolate(),
                  StackTrace::CurrentStackTrace(
                      isolate(), stack_trace_limit(), StackTrace::kDetailed));
}",1050.0,1060.0,1.0,1.0,11.0,3,2,4,3,0,0,2,2,0,0,,0,0,0,0,0,void
2176,77908,RunSnapshotSerializeCallback,1,node.Environment.RunSnapshotSerializeCallback,MaybeLocal<Value> node.Environment.RunSnapshotSerializeCallback (),env.cc,"MaybeLocal<Value> Environment::RunSnapshotSerializeCallback() const {
  EscapableHandleScope handle_scope(isolate());
  if (!snapshot_serialize_callback().IsEmpty()) {
    Context::Scope context_scope(context());
    return handle_scope.EscapeMaybe(snapshot_serialize_callback()->Call(
        context(), v8::Undefined(isolate()), 0, nullptr));
  }
  return handle_scope.Escape(Undefined(isolate()));
}",1062.0,1070.0,1.0,1.0,9.0,6,3,3,2,0,0,2,2,0,0,,0,0,0,0,0,MaybeLocal<Value>
2177,77949,RunSnapshotDeserializeMain,1,node.Environment.RunSnapshotDeserializeMain,MaybeLocal<Value> node.Environment.RunSnapshotDeserializeMain (),env.cc,"MaybeLocal<Value> Environment::RunSnapshotDeserializeMain() const {
  EscapableHandleScope handle_scope(isolate());
  if (!snapshot_deserialize_main().IsEmpty()) {
    Context::Scope context_scope(context());
    return handle_scope.EscapeMaybe(snapshot_deserialize_main()->Call(
        context(), v8::Undefined(isolate()), 0, nullptr));
  }
  return handle_scope.Escape(Undefined(isolate()));
}",1072.0,1080.0,1.0,1.0,9.0,6,3,3,2,0,0,2,2,0,0,,0,0,0,0,0,MaybeLocal<Value>
2178,77990,RunCleanup,1,node.Environment.RunCleanup,void node.Environment.RunCleanup (),env.cc,"void Environment::RunCleanup() {
  started_cleanup_ = true;
  TRACE_EVENT0(TRACING_CATEGORY_NODE1(environment), ""RunCleanup"");
  // Only BaseObject's cleanups are registered as per-realm cleanup hooks now.
  // Defer the BaseObject cleanup after handles are cleaned up.
  CleanupHandles();

  while (!cleanup_queue_.empty() || principal_realm_->HasCleanupHooks() ||
         native_immediates_.size() > 0 ||
         native_immediates_threadsafe_.size() > 0 ||
         native_immediates_interrupts_.size() > 0) {
    // TODO(legendecas): cleanup handles in per-realm cleanup hooks as well.
    principal_realm_->RunCleanup();
    cleanup_queue_.Drain();
    CleanupHandles();
  }

  for (const int fd : unmanaged_fds_) {
    uv_fs_t close_req;
    uv_fs_close(nullptr, &close_req, fd, nullptr);
    uv_fs_req_cleanup(&close_req);
  }
}",1082.0,1104.0,1.0,1.0,23.0,18,7,13,10,0,0,3,3,0,0,,0,0,0,0,0,void
2179,78058,RunAtExitCallbacks,1,node.Environment.RunAtExitCallbacks,void node.Environment.RunAtExitCallbacks (),env.cc,"void Environment::RunAtExitCallbacks() {
  TRACE_EVENT0(TRACING_CATEGORY_NODE1(environment), ""AtExit"");
  for (ExitCallback at_exit : at_exit_functions_) {
    at_exit.cb_(at_exit.arg_);
  }
  at_exit_functions_.clear();
}",1106.0,1112.0,1.0,1.0,7.0,3,1,5,3,0,0,2,2,0,0,,0,0,0,0,0,void
2180,78081,AtExit,1,node.Environment.AtExit,"void node.Environment.AtExit (void,void*)",env.cc,"void Environment::AtExit(void (*cb)(void* arg), void* arg) {
  at_exit_functions_.push_front(ExitCallback{cb, arg});
}",1114.0,1116.0,1.0,1.0,3.0,2,2,3,3,0,0,1,1,0,0,,0,0,4,2,2,void
2181,78095,RunAndClearInterrupts,1,node.Environment.RunAndClearInterrupts,void node.Environment.RunAndClearInterrupts (),env.cc,"void Environment::RunAndClearInterrupts() {
  while (native_immediates_interrupts_.size() > 0) {
    NativeImmediateQueue queue;
    {
      Mutex::ScopedLock lock(native_immediates_threadsafe_mutex_);
      queue.ConcatMove(std::move(native_immediates_interrupts_));
    }
    DebugSealHandleScope seal_handle_scope(isolate());

    while (auto head = queue.Shift())
      head->Call(this);
  }
}",1118.0,1130.0,1.0,1.0,13.0,5,3,6,5,0,0,3,4,0,0,,0,0,0,0,0,void
2182,78130,RunAndClearNativeImmediates,1,node.Environment.RunAndClearNativeImmediates,void node.Environment.RunAndClearNativeImmediates (bool),env.cc,"void Environment::RunAndClearNativeImmediates(bool only_refed) {
  TRACE_EVENT0(TRACING_CATEGORY_NODE1(environment),
               ""RunAndClearNativeImmediates"");
  HandleScope handle_scope(isolate_);
  // In case the Isolate is no longer accessible just use an empty Local. This
  // is not an issue for InternalCallbackScope as this case is already handled
  // in its constructor but we avoid calls into v8 which can crash the process
  // in debug builds.
  Local<Object> obj =
      can_call_into_js() ? Object::New(isolate_) : Local<Object>();
  InternalCallbackScope cb_scope(this, obj, {0, 0});

  size_t ref_count = 0;

  // Handle interrupts first. These functions are not allowed to throw
  // exceptions, so we do not need to handle that.
  RunAndClearInterrupts();

  auto drain_list = [&](NativeImmediateQueue* queue) {
    TryCatchScope try_catch(this);
    DebugSealHandleScope seal_handle_scope(isolate());
    while (auto head = queue->Shift()) {
      bool is_refed = head->fla...",1132.0,1192.0,1.0,1.0,61.0,17,9,18,12,0,0,5,5,0,0,,0,0,2,1,1,void
2183,78216,RequestInterruptFromV8,1,node.Environment.RequestInterruptFromV8,void node.Environment.RequestInterruptFromV8 (),env.cc,"void Environment::RequestInterruptFromV8() {
  // The Isolate may outlive the Environment, so some logic to handle the
  // situation in which the Environment is destroyed before the handler runs
  // is required.

  // We allocate a new pointer to a pointer to this Environment instance, and
  // try to set it as interrupt_data_. If interrupt_data_ was already set, then
  // callbacks are already scheduled to run and we can delete our own pointer
  // and just return. If it was nullptr previously, the Environment** is stored;
  // ~Environment sets the Environment* contained in it to nullptr, so that
  // the callback can check whether ~Environment has already run and it is thus
  // not safe to access the Environment instance itself.
  Environment** interrupt_data = new Environment*(this);
  Environment** dummy = nullptr;
  if (!interrupt_data_.compare_exchange_strong(dummy, interrupt_data)) {
    delete interrupt_data;
    return;  // Already scheduled.
  }

  isolate()->RequestIn...",1194.0,1225.0,1.0,1.0,32.0,7,6,8,4,0,0,2,2,0,0,,0,0,0,0,0,void
2184,78248,ScheduleTimer,1,node.Environment.ScheduleTimer,void node.Environment.ScheduleTimer (int64_t),env.cc,"void Environment::ScheduleTimer(int64_t duration_ms) {
  if (started_cleanup_) return;
  uv_timer_start(timer_handle(), RunTimers, duration_ms, 0);
}",1227.0,1230.0,1.0,1.0,4.0,0,0,3,3,0,0,2,2,0,0,,0,0,2,1,1,void
2185,78262,ToggleTimerRef,1,node.Environment.ToggleTimerRef,void node.Environment.ToggleTimerRef (bool),env.cc,"void Environment::ToggleTimerRef(bool ref) {
  if (started_cleanup_) return;

  if (ref) {
    uv_ref(reinterpret_cast<uv_handle_t*>(timer_handle()));
  } else {
    uv_unref(reinterpret_cast<uv_handle_t*>(timer_handle()));
  }
}",1232.0,1240.0,1.0,1.0,9.0,1,1,2,2,0,0,3,3,0,0,,0,0,2,1,1,void
2186,78284,RunTimers,1,node.Environment.RunTimers,void node.Environment.RunTimers (uv_timer_t*),env.cc,"void Environment::RunTimers(uv_timer_t* handle) {
  Environment* env = Environment::from_timer_handle(handle);
  TRACE_EVENT0(TRACING_CATEGORY_NODE1(environment), ""RunTimers"");

  if (!env->can_call_into_js())
    return;

  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  Local<Object> process = env->process_object();
  InternalCallbackScope scope(env, process, {0, 0});

  Local<Function> cb = env->timers_callback_function();
  MaybeLocal<Value> ret;
  Local<Value> arg = env->GetNow();
  // This code will loop until all currently due timers will process. It is
  // impossible for us to end up in an infinite loop due to how the JS-side
  // is structured.
  do {
    TryCatchScope try_catch(env);
    try_catch.SetVerbose(true);
    ret = cb->Call(env->context(), process, 1, &arg);
  } while (ret.IsEmpty() && env->can_call_into_js());

  // NOTE(apapirovski): If it ever becomes possible that `call_into_js` above
  // is reset back to `true` ...",1242.0,1300.0,1.0,1.0,59.0,47,13,49,17,0,0,6,7,0,0,,0,0,2,1,1,void
2187,78472,CheckImmediate,1,node.Environment.CheckImmediate,void node.Environment.CheckImmediate (uv_check_t*),env.cc,"void Environment::CheckImmediate(uv_check_t* handle) {
  Environment* env = Environment::from_immediate_check_handle(handle);
  TRACE_EVENT0(TRACING_CATEGORY_NODE1(environment), ""CheckImmediate"");

  HandleScope scope(env->isolate());
  Context::Scope context_scope(env->context());

  env->RunAndClearNativeImmediates();

  if (env->immediate_info()->count() == 0 || !env->can_call_into_js())
    return;

  do {
    MakeCallback(env->isolate(),
                 env->process_object(),
                 env->immediate_callback_function(),
                 0,
                 nullptr,
                 {0, 0}).ToLocalChecked();
  } while (env->immediate_info()->has_outstanding() && env->can_call_into_js());

  if (env->immediate_info()->ref_count() == 0)
    env->ToggleImmediateRef(false);
}",1303.0,1326.0,1.0,1.0,24.0,24,8,16,4,0,0,4,4,0,0,,0,0,2,1,1,void
2188,78574,ToggleImmediateRef,1,node.Environment.ToggleImmediateRef,void node.Environment.ToggleImmediateRef (bool),env.cc,"void Environment::ToggleImmediateRef(bool ref) {
  if (started_cleanup_) return;

  if (ref) {
    // Idle handle is needed only to stop the event loop from blocking in poll.
    uv_idle_start(immediate_idle_handle(), [](uv_idle_t*){ });
  } else {
    uv_idle_stop(immediate_idle_handle());
  }
}",1328.0,1337.0,1.0,1.0,10.0,0,0,2,2,0,0,3,3,0,0,,0,0,2,1,1,void
2189,78592,GetNowUint64,1,node.Environment.GetNowUint64,uint64_t node.Environment.GetNowUint64 (),env.cc,"uint64_t Environment::GetNowUint64() {
  uv_update_time(event_loop());
  uint64_t now = uv_now(event_loop());
  CHECK_GE(now, timer_base());
  now -= timer_base();
  return now;
}",1339.0,1345.0,1.0,1.0,7.0,2,2,4,1,0,0,1,1,0,0,,0,0,0,0,0,uint64_t
2190,78610,GetNow,1,node.Environment.GetNow,Local<Value> node.Environment.GetNow (),env.cc,"Local<Value> Environment::GetNow() {
  uint64_t now = GetNowUint64();
  if (now <= 0xffffffff)
    return Integer::NewFromUnsigned(isolate(), static_cast<uint32_t>(now));
  else
    return Number::New(isolate(), static_cast<double>(now));
}",1347.0,1353.0,1.0,1.0,7.0,4,4,4,2,0,0,2,2,0,0,,0,0,0,0,0,Local<Value>
2191,78643,CollectExceptionInfo,1,node.CollectExceptionInfo,"void node.CollectExceptionInfo (Environment*,Local<Object>,int,char*,char*,char*,char*,char*)",env.cc,"void CollectExceptionInfo(Environment* env,
                          Local<Object> obj,
                          int errorno,
                          const char* err_string,
                          const char* syscall,
                          const char* message,
                          const char* path,
                          const char* dest) {
  obj->Set(env->context(),
           env->errno_string(),
           Integer::New(env->isolate(), errorno)).Check();

  obj->Set(env->context(), env->code_string(),
           OneByteString(env->isolate(), err_string)).Check();

  if (message != nullptr) {
    obj->Set(env->context(), env->message_string(),
             OneByteString(env->isolate(), message)).Check();
  }

  Local<Value> path_buffer;
  if (path != nullptr) {
    path_buffer =
      Buffer::Copy(env->isolate(), path, strlen(path)).ToLocalChecked();
    obj->Set(env->context(), env->path_string(), path_buffer).Check();
  }

  Local<Value> dest_buffer;
  if (dest...",1355.0,1393.0,1.0,1.0,39.0,45,6,49,14,1,0,5,5,0,0,,0,0,16,8,8,void
2192,78836,CollectUVExceptionInfo,1,node.Environment.CollectUVExceptionInfo,"void node.Environment.CollectUVExceptionInfo (Local<Value>,int,char*,char*,char*,char*)",env.cc,"void Environment::CollectUVExceptionInfo(Local<Value> object,
                                         int errorno,
                                         const char* syscall,
                                         const char* message,
                                         const char* path,
                                         const char* dest) {
  if (!object->IsObject() || errorno == 0)
    return;

  Local<Object> obj = object.As<Object>();
  const char* err_string = uv_err_name(errorno);

  if (message == nullptr || message[0] == '\0') {
    message = uv_strerror(errorno);
  }

  node::CollectExceptionInfo(this, obj, errorno, err_string,
                             syscall, message, path, dest);
}",1395.0,1413.0,1.0,1.0,19.0,15,9,20,11,0,1,3,3,0,1,,0,0,12,6,6,void
2193,78900,ImmediateInfo,1,node.ImmediateInfo.ImmediateInfo,"ANY node.ImmediateInfo.ImmediateInfo (Isolate*,SerializeInfo*)",env.cc,"ImmediateInfo::ImmediateInfo(Isolate* isolate, const SerializeInfo* info)
    : fields_(isolate, kFieldsCount, MAYBE_FIELD_PTR(info, fields)) {}",1415.0,1416.0,1.0,70.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,ANY
2194,78906,Serialize,1,node.ImmediateInfo.Serialize,"SerializeInfo node.ImmediateInfo.Serialize (Local<Context>,SnapshotCreator*)",env.cc,"ImmediateInfo::SerializeInfo ImmediateInfo::Serialize(
    Local<Context> context, SnapshotCreator* creator) {
  return {fields_.Serialize(context, creator)};
}",1418.0,1421.0,1.0,1.0,4.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,SerializeInfo
2195,78913,Deserialize,1,node.ImmediateInfo.Deserialize,void node.ImmediateInfo.Deserialize (Local<Context>),env.cc,"void ImmediateInfo::Deserialize(Local<Context> context) {
  fields_.Deserialize(context);
}",1423.0,1425.0,1.0,1.0,3.0,1,1,2,2,0,0,1,1,0,0,,0,0,2,1,1,void
2196,78940,MemoryInfo,1,node.ImmediateInfo.MemoryInfo,void node.ImmediateInfo.MemoryInfo (MemoryTracker*),env.cc,"void ImmediateInfo::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackField(""fields"", fields_);
}",1433.0,1435.0,1.0,1.0,3.0,1,1,2,2,0,0,1,1,0,0,,0,0,2,1,1,void
2197,78951,Serialize,1,node.TickInfo.Serialize,"SerializeInfo node.TickInfo.Serialize (Local<Context>,SnapshotCreator*)",env.cc,"TickInfo::SerializeInfo TickInfo::Serialize(Local<Context> context,
                                            SnapshotCreator* creator) {
  return {fields_.Serialize(context, creator)};
}",1437.0,1440.0,1.0,1.0,4.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,SerializeInfo
2198,78958,Deserialize,1,node.TickInfo.Deserialize,void node.TickInfo.Deserialize (Local<Context>),env.cc,"void TickInfo::Deserialize(Local<Context> context) {
  fields_.Deserialize(context);
}",1442.0,1444.0,1.0,1.0,3.0,1,1,2,2,0,0,1,1,0,0,,0,0,2,1,1,void
2199,78985,MemoryInfo,1,node.TickInfo.MemoryInfo,void node.TickInfo.MemoryInfo (MemoryTracker*),env.cc,"void TickInfo::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackField(""fields"", fields_);
}",1452.0,1454.0,1.0,1.0,3.0,1,1,2,2,0,0,1,1,0,0,,0,0,2,1,1,void
2200,78996,TickInfo,1,node.TickInfo.TickInfo,"ANY node.TickInfo.TickInfo (Isolate*,SerializeInfo*)",env.cc,"TickInfo::TickInfo(Isolate* isolate, const SerializeInfo* info)
    : fields_(
          isolate, kFieldsCount, info == nullptr ? nullptr : &(info->fields)) {}",1456.0,1458.0,1.0,80.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,ANY
2201,79002,AsyncHooks,1,node.AsyncHooks.AsyncHooks,"ANY node.AsyncHooks.AsyncHooks (Isolate*,SerializeInfo*)",env.cc,"AsyncHooks::AsyncHooks(Isolate* isolate, const SerializeInfo* info)
    : async_ids_stack_(isolate, 16 * 2, MAYBE_FIELD_PTR(info, async_ids_stack)),
      fields_(isolate, kFieldsCount, MAYBE_FIELD_PTR(info, fields)),
      async_id_fields_(
          isolate, kUidFieldsCount, MAYBE_FIELD_PTR(info, async_id_fields)),
      info_(info) {
  HandleScope handle_scope(isolate);
  if (info == nullptr) {
    clear_async_id_stack();

    // Always perform async_hooks checks, not just when async_hooks is enabled.
    // TODO(AndreasMadsen): Consider removing this for LTS releases.
    // See discussion in https://github.com/nodejs/node/pull/15454
    // When removing this, do it by reverting the commit. Otherwise the test
    // and flag changes won't be included.
    fields_[kCheck] = 1;

    // kDefaultTriggerAsyncId should be -1, this indicates that there is no
    // specified default value and it should fallback to the executionAsyncId.
    // 0 is not used as the magic value, because t...",1460.0,1487.0,1.0,1.0,28.0,10,5,8,6,0,0,2,2,0,0,,0,0,4,2,2,ANY
2202,79037,Deserialize,1,node.AsyncHooks.Deserialize,void node.AsyncHooks.Deserialize (Local<Context>),env.cc,"void AsyncHooks::Deserialize(Local<Context> context) {
  async_ids_stack_.Deserialize(context);
  fields_.Deserialize(context);
  async_id_fields_.Deserialize(context);

  Local<Array> js_execution_async_resources;
  if (info_->js_execution_async_resources != 0) {
    js_execution_async_resources =
        context->GetDataFromSnapshotOnce<Array>(
            info_->js_execution_async_resources).ToLocalChecked();
  } else {
    js_execution_async_resources = Array::New(context->GetIsolate());
  }
  js_execution_async_resources_.Reset(
      context->GetIsolate(), js_execution_async_resources);

  // The native_execution_async_resources_ field requires v8::Local<> instances
  // for async calls whose resources were on the stack as JS objects when they
  // were entered. We cannot recreate this here; however, storing these values
  // on the JS equivalent gives the same result, so we do that instead.
  for (size_t i = 0; i < info_->native_execution_async_resources.size(); ++i) {
    if...",1489.0,1518.0,1.0,1.0,30.0,34,8,35,13,0,0,5,5,0,0,,0,0,2,1,1,void
2203,79217,Serialize,1,node.AsyncHooks.Serialize,"SerializeInfo node.AsyncHooks.Serialize (Local<Context>,SnapshotCreator*)",env.cc,"AsyncHooks::SerializeInfo AsyncHooks::Serialize(Local<Context> context,
                                                SnapshotCreator* creator) {
  SerializeInfo info;
  // TODO(joyeecheung): some of these probably don't need to be serialized.
  info.async_ids_stack = async_ids_stack_.Serialize(context, creator);
  info.fields = fields_.Serialize(context, creator);
  info.async_id_fields = async_id_fields_.Serialize(context, creator);
  if (!js_execution_async_resources_.IsEmpty()) {
    info.js_execution_async_resources = creator->AddData(
        context, js_execution_async_resources_.Get(context->GetIsolate()));
    CHECK_NE(info.js_execution_async_resources, 0);
  } else {
    info.js_execution_async_resources = 0;
  }

  info.native_execution_async_resources.resize(
      native_execution_async_resources_.size());
  for (size_t i = 0; i < native_execution_async_resources_.size(); i++) {
    info.native_execution_async_resources[i] =
        native_execution_async_resources_[i...",1534.0,1567.0,1.0,1.0,34.0,39,7,38,11,0,0,3,3,0,0,,0,0,4,2,2,SerializeInfo
2204,79367,MemoryInfo,1,node.AsyncHooks.MemoryInfo,void node.AsyncHooks.MemoryInfo (MemoryTracker*),env.cc,"void AsyncHooks::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackField(""async_ids_stack"", async_ids_stack_);
  tracker->TrackField(""fields"", fields_);
  tracker->TrackField(""async_id_fields"", async_id_fields_);
  tracker->TrackField(""js_promise_hooks"", js_promise_hooks_);
}",1569.0,1574.0,1.0,1.0,6.0,4,1,8,5,0,0,1,1,0,0,,0,0,2,1,1,void
2205,79396,grow_async_ids_stack,1,node.AsyncHooks.grow_async_ids_stack,void node.AsyncHooks.grow_async_ids_stack (),env.cc,"void AsyncHooks::grow_async_ids_stack() {
  async_ids_stack_.reserve(async_ids_stack_.Length() * 3);

  env()->async_hooks_binding()->Set(
      env()->context(),
      env()->async_ids_stack_string(),
      async_ids_stack_.GetJSArray()).Check();
}",1576.0,1583.0,1.0,1.0,8.0,9,3,3,1,0,0,1,1,0,0,,0,0,0,0,0,void
2206,79432,FailWithCorruptedAsyncStack,1,node.AsyncHooks.FailWithCorruptedAsyncStack,void node.AsyncHooks.FailWithCorruptedAsyncStack (double),env.cc,"void AsyncHooks::FailWithCorruptedAsyncStack(double expected_async_id) {
  fprintf(stderr,
          ""Error: async hook stack has become corrupted (""
          ""actual: %.f, expected: %.f)\n"",
          async_id_fields_.GetValue(kExecutionAsyncId),
          expected_async_id);
  DumpBacktrace(stderr);
  fflush(stderr);
  // TODO(joyeecheung): should this exit code be more specific?
  if (!env()->abort_on_uncaught_exception()) Exit(ExitCode::kGenericUserError);
  fprintf(stderr, ""\n"");
  fflush(stderr);
  ABORT_NO_BACKTRACE();
}",1585.0,1598.0,1.0,1.0,14.0,4,3,8,5,0,0,2,2,0,0,,0,0,2,1,1,void
2207,79466,Exit,1,node.Environment.Exit,void node.Environment.Exit (ExitCode),env.cc,"void Environment::Exit(ExitCode exit_code) {
  if (options()->trace_exit) {
    HandleScope handle_scope(isolate());
    Isolate::DisallowJavascriptExecutionScope disallow_js(
        isolate(), Isolate::DisallowJavascriptExecutionScope::CRASH_ON_FAILURE);

    if (is_main_thread()) {
      fprintf(stderr, ""(node:%d) "", uv_os_getpid());
    } else {
      fprintf(stderr, ""(node:%d, thread:%"" PRIu64 "") "",
              uv_os_getpid(), thread_id());
    }

    fprintf(stderr,
            ""WARNING: Exited the environment with code %d\n"",
            static_cast<int>(exit_code));
    PrintStackTrace(isolate(),
                    StackTrace::CurrentStackTrace(
                        isolate(), stack_trace_limit(), StackTrace::kDetailed));
  }
  process_exit_handler_(this, exit_code);
}",1600.0,1621.0,1.0,1.0,22.0,6,3,8,5,0,0,3,4,0,0,,0,0,2,1,1,void
2208,79517,stop_sub_worker_contexts,1,node.Environment.stop_sub_worker_contexts,void node.Environment.stop_sub_worker_contexts (),env.cc,"void Environment::stop_sub_worker_contexts() {
  DCHECK_EQ(Isolate::GetCurrent(), isolate());

  while (!sub_worker_contexts_.empty()) {
    Worker* w = *sub_worker_contexts_.begin();
    remove_sub_worker_context(w);
    w->Exit(ExitCode::kGenericUserError);
    w->JoinThread();
  }
}",1623.0,1632.0,1.0,1.0,10.0,9,5,8,4,0,0,2,2,0,0,,0,0,0,0,0,void
2209,79555,worker_parent_env,1,node.Environment.worker_parent_env,Environment node.Environment.worker_parent_env (),env.cc,"Environment* Environment::worker_parent_env() const {
  if (worker_context() == nullptr) return nullptr;
  return worker_context()->env();
}",1634.0,1637.0,1.0,1.0,4.0,2,2,0,0,0,0,2,2,0,0,,0,0,0,0,0,Environment
2210,79571,AddUnmanagedFd,1,node.Environment.AddUnmanagedFd,void node.Environment.AddUnmanagedFd (int),env.cc,"void Environment::AddUnmanagedFd(int fd) {
  if (!tracks_unmanaged_fds()) return;
  auto result = unmanaged_fds_.insert(fd);
  if (!result.second) {
    ProcessEmitWarning(
        this, ""File descriptor %d opened in unmanaged mode twice"", fd);
  }
}",1639.0,1646.0,1.0,1.0,8.0,5,3,5,3,0,0,3,3,0,0,,0,0,2,1,1,void
2211,79599,RemoveUnmanagedFd,1,node.Environment.RemoveUnmanagedFd,void node.Environment.RemoveUnmanagedFd (int),env.cc,"void Environment::RemoveUnmanagedFd(int fd) {
  if (!tracks_unmanaged_fds()) return;
  size_t removed_count = unmanaged_fds_.erase(fd);
  if (removed_count == 0) {
    ProcessEmitWarning(
        this, ""File descriptor %d closed but not opened in unmanaged mode"", fd);
  }
}",1648.0,1655.0,1.0,1.0,8.0,4,4,5,3,0,0,3,3,0,0,,0,0,2,1,1,void
2212,79626,PrintInfoForSnapshotIfDebug,1,node.Environment.PrintInfoForSnapshotIfDebug,void node.Environment.PrintInfoForSnapshotIfDebug (),env.cc,"void Environment::PrintInfoForSnapshotIfDebug() {
  if (enabled_debug_list()->enabled(DebugCategory::MKSNAPSHOT)) {
    fprintf(stderr, ""At the exit of the Environment:\n"");
    principal_realm()->PrintInfoForSnapshot();
  }
}",1657.0,1662.0,1.0,1.0,6.0,3,2,2,2,0,0,2,2,0,0,,0,0,0,0,0,void
2213,79646,Serialize,1,node.Environment.Serialize,EnvSerializeInfo node.Environment.Serialize (SnapshotCreator*),env.cc,"EnvSerializeInfo Environment::Serialize(SnapshotCreator* creator) {
  EnvSerializeInfo info;
  Local<Context> ctx = context();

  info.async_hooks = async_hooks_.Serialize(ctx, creator);
  info.immediate_info = immediate_info_.Serialize(ctx, creator);
  info.timeout_info = timeout_info_.Serialize(ctx, creator);
  info.tick_info = tick_info_.Serialize(ctx, creator);
  info.performance_state = performance_state_->Serialize(ctx, creator);
  info.exit_info = exit_info_.Serialize(ctx, creator);
  info.stream_base_state = stream_base_state_.Serialize(ctx, creator);
  info.should_abort_on_uncaught_toggle =
      should_abort_on_uncaught_toggle_.Serialize(ctx, creator);

  info.principal_realm = principal_realm_->Serialize(creator);
  // For now we only support serialization of the main context.
  // TODO(joyeecheung): support de/serialization of vm contexts.
  CHECK_EQ(contexts_.size(), 1);
  CHECK_EQ(contexts_[0], context());
  return info;
}",1664.0,1684.0,1.0,1.0,21.0,32,6,41,15,0,0,1,1,0,0,,0,0,2,1,1,EnvSerializeInfo
2214,79761,EnqueueDeserializeRequest,1,node.Environment.EnqueueDeserializeRequest,"void node.Environment.EnqueueDeserializeRequest (DeserializeRequestCallback,Local<Object>,int,InternalFieldInfoBase*)",env.cc,"void Environment::EnqueueDeserializeRequest(DeserializeRequestCallback cb,
                                            Local<Object> holder,
                                            int index,
                                            InternalFieldInfoBase* info) {
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  DeserializeRequest request{cb, {isolate(), holder}, index, info};
  deserialize_requests_.push_back(std::move(request));
}",1686.0,1693.0,1.0,1.0,8.0,6,3,10,8,0,0,1,1,0,0,,0,0,8,4,4,void
2215,79793,RunDeserializeRequests,1,node.Environment.RunDeserializeRequests,void node.Environment.RunDeserializeRequests (),env.cc,"void Environment::RunDeserializeRequests() {
  HandleScope scope(isolate());
  Local<Context> ctx = context();
  Isolate* is = isolate();
  while (!deserialize_requests_.empty()) {
    DeserializeRequest request(std::move(deserialize_requests_.front()));
    deserialize_requests_.pop_front();
    Local<Object> holder = request.holder.Get(is);
    request.cb(ctx, holder, request.index, request.info);
    request.holder.Reset();
    request.info->Delete();
  }
}",1695.0,1707.0,1.0,1.0,13.0,21,6,20,9,0,0,2,2,0,0,,0,0,0,0,0,void
2216,79869,DeserializeProperties,1,node.Environment.DeserializeProperties,void node.Environment.DeserializeProperties (EnvSerializeInfo*),env.cc,"void Environment::DeserializeProperties(const EnvSerializeInfo* info) {
  Local<Context> ctx = context();

  if (enabled_debug_list_.enabled(DebugCategory::MKSNAPSHOT)) {
    fprintf(stderr, ""deserializing EnvSerializeInfo...\n"");
    std::cerr << *info << ""\n"";
  }

  RunDeserializeRequests();

  async_hooks_.Deserialize(ctx);
  immediate_info_.Deserialize(ctx);
  timeout_info_.Deserialize(ctx);
  tick_info_.Deserialize(ctx);
  performance_state_->Deserialize(ctx);
  exit_info_.Deserialize(ctx);
  stream_base_state_.Deserialize(ctx);
  should_abort_on_uncaught_toggle_.Deserialize(ctx);

  principal_realm_->DeserializeProperties(&info->principal_realm);
}",1709.0,1729.0,1.0,1.0,21.0,20,8,26,17,0,0,2,2,0,0,,0,0,2,1,1,void
2217,79950,GuessMemoryAvailableToTheProcess,1,node.GuessMemoryAvailableToTheProcess,uint64_t node.GuessMemoryAvailableToTheProcess (),env.cc,"uint64_t GuessMemoryAvailableToTheProcess() {
  uint64_t free_in_system = uv_get_free_memory();
  size_t allowed = uv_get_constrained_memory();
  if (allowed == 0) {
    return free_in_system;
  }
  size_t rss;
  int err = uv_resident_set_memory(&rss);
  if (err) {
    return free_in_system;
  }
  if (allowed < rss) {
    // Something is probably wrong. Fallback to the free memory.
    return free_in_system;
  }
  // There may still be room for swap, but we will just leave it here.
  return allowed - rss;
}",1731.0,1748.0,1.0,1.0,18.0,7,5,13,4,0,0,4,4,0,0,,0,0,0,0,0,uint64_t
2218,79992,BuildEmbedderGraph,1,node.Environment.BuildEmbedderGraph,"void node.Environment.BuildEmbedderGraph (Isolate*,EmbedderGraph*,void*)",env.cc,"void Environment::BuildEmbedderGraph(Isolate* isolate,
                                     EmbedderGraph* graph,
                                     void* data) {
  MemoryTracker tracker(isolate, graph);
  Environment* env = static_cast<Environment*>(data);
  // Start traversing embedder objects from the root Environment object.
  tracker.Track(env);
}",1750.0,1757.0,1.0,1.0,8.0,3,3,6,5,0,0,1,1,0,0,,0,0,6,3,3,void
2219,80014,NearHeapLimitCallback,1,node.Environment.NearHeapLimitCallback,"size_t node.Environment.NearHeapLimitCallback (void*,size_t,size_t)",env.cc,"size_t Environment::NearHeapLimitCallback(void* data,
                                          size_t current_heap_limit,
                                          size_t initial_heap_limit) {
  Environment* env = static_cast<Environment*>(data);

  Debug(env,
        DebugCategory::DIAGNOSTICS,
        ""Invoked NearHeapLimitCallback, processing=%d, ""
        ""current_limit=%"" PRIu64 "", ""
        ""initial_limit=%"" PRIu64 ""\n"",
        env->is_in_heapsnapshot_heap_limit_callback_,
        static_cast<uint64_t>(current_heap_limit),
        static_cast<uint64_t>(initial_heap_limit));

  size_t max_young_gen_size = env->isolate_data()->max_young_gen_size;
  size_t young_gen_size = 0;
  size_t old_gen_size = 0;

  HeapSpaceStatistics stats;
  size_t num_heap_spaces = env->isolate()->NumberOfHeapSpaces();
  for (size_t i = 0; i < num_heap_spaces; ++i) {
    env->isolate()->GetHeapSpaceStatistics(&stats, i);
    if (strcmp(stats.space_name(), ""new_space"") == 0 ||
        strcmp(stats.spac...",1759.0,1886.0,1.0,1.0,128.0,66,12,67,23,0,0,7,8,0,0,,0,0,6,3,3,size_t
2220,80278,SelfSize,1,node.Environment.SelfSize,size_t node.Environment.SelfSize (),env.cc,"inline size_t Environment::SelfSize() const {
  size_t size = sizeof(*this);
  // Remove non pointer fields that will be tracked in MemoryInfo()
  // TODO(joyeecheung): refactor the MemoryTracker interface so
  // this can be done for common types within the Track* calls automatically
  // if a certain scope is entered.
  size -= sizeof(async_hooks_);
  size -= sizeof(cleanup_queue_);
  size -= sizeof(tick_info_);
  size -= sizeof(immediate_info_);
  return size;
}",1888.0,1899.0,1.0,1.0,12.0,11,4,10,5,0,0,1,1,0,0,,0,0,0,0,0,size_t
2221,80306,MemoryInfo,1,node.Environment.MemoryInfo,void node.Environment.MemoryInfo (MemoryTracker*),env.cc,"void Environment::MemoryInfo(MemoryTracker* tracker) const {
  // Iteratable STLs have their own sizes subtracted from the parent
  // by default.
  tracker->TrackField(""isolate_data"", isolate_data_);
  tracker->TrackField(""destroy_async_id_list"", destroy_async_id_list_);
  tracker->TrackField(""exec_argv"", exec_argv_);
  tracker->TrackField(""exit_info"", exit_info_);
  tracker->TrackField(""should_abort_on_uncaught_toggle"",
                      should_abort_on_uncaught_toggle_);
  tracker->TrackField(""stream_base_state"", stream_base_state_);
  tracker->TrackField(""cleanup_queue"", cleanup_queue_);
  tracker->TrackField(""async_hooks"", async_hooks_);
  tracker->TrackField(""immediate_info"", immediate_info_);
  tracker->TrackField(""timeout_info"", timeout_info_);
  tracker->TrackField(""tick_info"", tick_info_);
  tracker->TrackField(""principal_realm"", principal_realm_);
  tracker->TrackField(""shadow_realms"", shadow_realms_);

  // FIXME(joyeecheung): track other fields in Environment.
  // ...",1901.0,1928.0,1.0,1.0,28.0,13,1,26,14,0,0,1,1,0,0,,0,0,2,1,1,void
2222,80389,RunWeakRefCleanup,1,node.Environment.RunWeakRefCleanup,void node.Environment.RunWeakRefCleanup (),env.cc,"void Environment::RunWeakRefCleanup() {
  isolate()->ClearKeptObjects();
}",1930.0,1932.0,1.0,1.0,3.0,1,1,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2223,80497,Initialize,1,node.anonymous_namespace_2.FSEventWrap.Initialize,"void node.anonymous_namespace_2.FSEventWrap.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)",fs_event_wrap.cc,"static void Initialize(Local<Object> target,
                         Local<Value> unused,
                         Local<Context> context,
                         void* priv);",53.0,56.0,15.0,36.0,4.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,void
2224,80505,RegisterExternalReferences,1,node.anonymous_namespace_3.FSEventWrap.RegisterExternalReferences,void node.anonymous_namespace_3.FSEventWrap.RegisterExternalReferences (ExternalReferenceRegistry*),fs_event_wrap.cc,static void RegisterExternalReferences(ExternalReferenceRegistry* registry);,57.0,57.0,15.0,77.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
2225,80510,New,1,node.anonymous_namespace_4.FSEventWrap.New,void node.anonymous_namespace_4.FSEventWrap.New (FunctionCallbackInfo<Value>),fs_event_wrap.cc,static void New(const FunctionCallbackInfo<Value>& args);,58.0,58.0,15.0,58.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
2226,80515,Start,1,node.anonymous_namespace_5.FSEventWrap.Start,void node.anonymous_namespace_5.FSEventWrap.Start (FunctionCallbackInfo<Value>),fs_event_wrap.cc,static void Start(const FunctionCallbackInfo<Value>& args);,59.0,59.0,15.0,60.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
2227,80520,GetInitialized,1,node.anonymous_namespace_6.FSEventWrap.GetInitialized,void node.anonymous_namespace_6.FSEventWrap.GetInitialized (FunctionCallbackInfo<Value>),fs_event_wrap.cc,static void GetInitialized(const FunctionCallbackInfo<Value>& args);,60.0,60.0,15.0,69.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
2228,80526,FSEventWrap,1,node.anonymous_namespace_7.FSEventWrap.FSEventWrap,"ANY node.anonymous_namespace_7.FSEventWrap.FSEventWrap (Environment*,Local<Object>)",fs_event_wrap.cc,"FSEventWrap(Environment* env, Local<Object> object);",69.0,69.0,3.0,53.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,ANY
2229,80532,~FSEventWrap,1,node.anonymous_namespace_8.FSEventWrap.~FSEventWrap,ANY node.anonymous_namespace_8.FSEventWrap.~FSEventWrap (),fs_event_wrap.cc,~FSEventWrap() override = default;,70.0,70.0,3.0,36.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
2230,80536,OnEvent,1,node.anonymous_namespace_9.FSEventWrap.OnEvent,"void node.anonymous_namespace_9.FSEventWrap.OnEvent (uv_fs_event_t*,char*,int,int)",fs_event_wrap.cc,"static void OnEvent(uv_fs_event_t* handle, const char* filename, int events,
    int status);",72.0,73.0,15.0,15.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,void
2231,80554,FSEventWrap,1,node.anonymous_namespace_11.FSEventWrap.FSEventWrap,"ANY node.anonymous_namespace_11.FSEventWrap.FSEventWrap (Environment*,Local<Object>)",fs_event_wrap.cc,"FSEventWrap::FSEventWrap(Environment* env, Local<Object> object)
    : HandleWrap(env,
                 object,
                 reinterpret_cast<uv_handle_t*>(&handle_),
                 AsyncWrap::PROVIDER_FSEVENTWRAP) {
  MarkAsUninitialized();
}",80.0,86.0,1.0,1.0,7.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,ANY
2232,80561,GetInitialized,1,node.anonymous_namespace_12.FSEventWrap.GetInitialized,void node.anonymous_namespace_12.FSEventWrap.GetInitialized (FunctionCallbackInfo<Value>),fs_event_wrap.cc,"void FSEventWrap::GetInitialized(const FunctionCallbackInfo<Value>& args) {
  FSEventWrap* wrap = Unwrap<FSEventWrap>(args.This());
  CHECK_NOT_NULL(wrap);
  args.GetReturnValue().Set(!wrap->IsHandleClosing());
}",89.0,93.0,1.0,1.0,5.0,8,6,7,4,0,0,1,1,0,0,,0,0,2,1,1,void
2233,80591,Initialize,1,node.anonymous_namespace_13.FSEventWrap.Initialize,"void node.anonymous_namespace_13.FSEventWrap.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)",fs_event_wrap.cc,"void FSEventWrap::Initialize(Local<Object> target,
                             Local<Value> unused,
                             Local<Context> context,
                             void* priv) {
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, New);
  t->InstanceTemplate()->SetInternalFieldCount(
      FSEventWrap::kInternalFieldCount);

  t->Inherit(HandleWrap::GetConstructorTemplate(env));
  SetProtoMethod(isolate, t, ""start"", Start);

  Local<FunctionTemplate> get_initialized_templ =
      FunctionTemplate::New(env->isolate(),
                            GetInitialized,
                            Local<Value>(),
                            Signature::New(env->isolate(), t));

  t->PrototypeTemplate()->SetAccessorProperty(
      FIXED_ONE_BYTE_STRING(env->isolate(), ""initialized""),
      get_initialized_templ,
      Local<FunctionTemplate>(),
      static_cast<PropertyAttribut...",95.0,122.0,1.0,1.0,28.0,25,7,34,16,0,0,1,1,0,0,,0,0,8,4,4,void
2234,80699,RegisterExternalReferences,1,node.anonymous_namespace_16.FSEventWrap.RegisterExternalReferences,void node.anonymous_namespace_16.FSEventWrap.RegisterExternalReferences (ExternalReferenceRegistry*),fs_event_wrap.cc,"void FSEventWrap::RegisterExternalReferences(
    ExternalReferenceRegistry* registry) {
  registry->Register(New);
  registry->Register(Start);
  registry->Register(GetInitialized);
}",124.0,129.0,1.0,1.0,6.0,3,1,4,2,0,0,1,1,0,0,,0,0,2,1,1,void
2235,80719,New,1,node.anonymous_namespace_19.FSEventWrap.New,void node.anonymous_namespace_19.FSEventWrap.New (FunctionCallbackInfo<Value>),fs_event_wrap.cc,"void FSEventWrap::New(const FunctionCallbackInfo<Value>& args) {
  CHECK(args.IsConstructCall());
  Environment* env = Environment::GetCurrent(args);
  new FSEventWrap(env, args.This());
}",131.0,135.0,1.0,1.0,5.0,5,3,7,4,0,0,1,1,0,0,,0,0,2,1,1,void
2236,80744,Start,1,node.anonymous_namespace_20.FSEventWrap.Start,void node.anonymous_namespace_20.FSEventWrap.Start (FunctionCallbackInfo<Value>),fs_event_wrap.cc,"void FSEventWrap::Start(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  FSEventWrap* wrap = Unwrap<FSEventWrap>(args.This());
  CHECK_NOT_NULL(wrap);
  CHECK(wrap->IsHandleClosing());  // Check that Start() has not been called.

  const int argc = args.Length();
  CHECK_GE(argc, 4);

  BufferValue path(env->isolate(), args[0]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemRead, *path);

  unsigned int flags = 0;
  if (args[2]->IsTrue())
    flags |= UV_FS_EVENT_RECURSIVE;

  wrap->encoding_ = ParseEncoding(env->isolate(), args[3], kDefaultEncoding);

  int err = uv_fs_event_init(wrap->env()->event_loop(), &wrap->handle_);
  if (err != 0) {
    return args.GetReturnValue().Set(err);
  }

  err = uv_fs_event_start(&wrap->handle_, OnEvent, *path, flags);
  wrap->MarkAsInitialized();

  if (err != 0) {
    FSEventWrap::Close(args);
    return args.GetReturnValue().Set(er...",138.0,178.0,1.0,1.0,41.0,47,11,47,14,0,4,5,5,0,0,,0,4,2,1,1,void
2237,80921,OnEvent,1,node.anonymous_namespace_22.FSEventWrap.OnEvent,"void node.anonymous_namespace_22.FSEventWrap.OnEvent (uv_fs_event_t*,char*,int,int)",fs_event_wrap.cc,"void FSEventWrap::OnEvent(uv_fs_event_t* handle, const char* filename,
    int events, int status) {
  FSEventWrap* wrap = static_cast<FSEventWrap*>(handle->data);
  Environment* env = wrap->env();

  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  CHECK_EQ(wrap->persistent().IsEmpty(), false);

  // We're in a bind here. libuv can set both UV_RENAME and UV_CHANGE but
  // the Node API only lets us pass a single event to JS land.
  //
  // The obvious solution is to run the callback twice, once for each event.
  // However, since the second event is not allowed to fire if the handle is
  // closed after the first event, and since there is no good way to detect
  // closed handles, that option is out.
  //
  // For now, ignore the UV_CHANGE event if UV_RENAME is also set. Make the
  // assumption that a rename implicitly means an attribute change. Not too
  // unreasonable, right? Still, we should revisit this before v1.0.
  Local<String> ...",181.0,238.0,1.0,1.0,58.0,42,10,48,17,0,1,4,5,0,0,,0,1,8,4,4,void
2238,81140,Ref,1,node.HandleWrap.Ref,void node.HandleWrap.Ref (FunctionCallbackInfo<Value>),handle_wrap.cc,"void HandleWrap::Ref(const FunctionCallbackInfo<Value>& args) {
  HandleWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  if (IsAlive(wrap))
    uv_ref(wrap->GetHandle());
}",40.0,46.0,1.0,1.0,7.0,3,3,4,2,0,0,2,2,0,0,,0,0,2,1,1,void
2239,81162,Unref,1,node.HandleWrap.Unref,void node.HandleWrap.Unref (FunctionCallbackInfo<Value>),handle_wrap.cc,"void HandleWrap::Unref(const FunctionCallbackInfo<Value>& args) {
  HandleWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  if (IsAlive(wrap))
    uv_unref(wrap->GetHandle());
}",49.0,55.0,1.0,1.0,7.0,3,3,4,2,0,0,2,2,0,0,,0,0,2,1,1,void
2240,81184,HasRef,1,node.HandleWrap.HasRef,void node.HandleWrap.HasRef (FunctionCallbackInfo<Value>),handle_wrap.cc,"void HandleWrap::HasRef(const FunctionCallbackInfo<Value>& args) {
  HandleWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
  args.GetReturnValue().Set(HasRef(wrap));
}",58.0,62.0,1.0,1.0,5.0,4,2,4,2,0,0,1,1,0,0,,0,0,2,1,1,void
2241,81206,Close,1,node.HandleWrap.Close,void node.HandleWrap.Close (FunctionCallbackInfo<Value>),handle_wrap.cc,"void HandleWrap::Close(Local<Value> close_callback) {
  if (state_ != kInitialized)
    return;

  uv_close(handle_, OnClose);
  state_ = kClosing;

  if (!close_callback.IsEmpty() && close_callback->IsFunction() &&
      !persistent().IsEmpty()) {
    object()->Set(env()->context(),
                  env()->handle_onclose_symbol(),
                  close_callback).Check();
  }
}",72.0,85.0,1.0,1.0,14.0,4,4,4,2,0,0,1,1,0,0,,0,0,2,1,1,void
2242,81277,OnGCCollect,1,node.HandleWrap.OnGCCollect,void node.HandleWrap.OnGCCollect (),handle_wrap.cc,"void HandleWrap::OnGCCollect() {
  // When all references to a HandleWrap are lost and the object is supposed to
  // be destroyed, we first call Close() to clean up the underlying libuv
  // handle. The OnClose callback then acquires and destroys another reference
  // to that object, and when that reference is lost, we perform the default
  // action (i.e. destroying `this`).
  if (state_ != kClosed) {
    Close();
  } else {
    BaseObject::OnGCCollect();
  }
}",88.0,99.0,1.0,1.0,12.0,1,1,2,2,0,0,2,2,0,0,,0,0,0,0,0,void
2243,81293,IsNotIndicativeOfMemoryLeakAtExit,1,node.HandleWrap.IsNotIndicativeOfMemoryLeakAtExit,bool node.HandleWrap.IsNotIndicativeOfMemoryLeakAtExit (),handle_wrap.cc,"bool HandleWrap::IsNotIndicativeOfMemoryLeakAtExit() const {
  return IsWeakOrDetached() ||
         !HandleWrap::HasRef(this) ||
         !uv_is_active(GetHandle());
}",102.0,106.0,1.0,1.0,5.0,5,3,1,1,0,0,1,1,0,0,,0,0,0,0,0,bool
2244,81310,MarkAsInitialized,1,node.HandleWrap.MarkAsInitialized,void node.HandleWrap.MarkAsInitialized (),handle_wrap.cc,"void HandleWrap::MarkAsInitialized() {
  env()->handle_wrap_queue()->PushBack(this);
  state_ = kInitialized;
}",109.0,112.0,1.0,1.0,4.0,3,2,2,2,0,0,1,1,0,0,,0,0,0,0,0,void
2245,81325,MarkAsUninitialized,1,node.HandleWrap.MarkAsUninitialized,void node.HandleWrap.MarkAsUninitialized (),handle_wrap.cc,"void HandleWrap::MarkAsUninitialized() {
  handle_wrap_queue_.Remove();
  state_ = kClosed;
}",115.0,118.0,1.0,1.0,4.0,2,2,3,3,0,0,1,1,0,0,,0,0,0,0,0,void
2246,81336,HandleWrap,1,node.HandleWrap.HandleWrap,"ANY node.HandleWrap.HandleWrap (Environment*,Local<Object>,uv_handle_t*,ANY)",handle_wrap.cc,"HandleWrap::HandleWrap(Environment* env,
                       Local<Object> object,
                       uv_handle_t* handle,
                       AsyncWrap::ProviderType provider)
    : AsyncWrap(env, object, provider),
      state_(kInitialized),
      handle_(handle) {
  handle_->data = this;
  HandleScope scope(env->isolate());
  CHECK(env->has_run_bootstrapping_code());
  env->handle_wrap_queue()->PushBack(this);
}",121.0,132.0,1.0,1.0,12.0,6,2,4,2,0,0,1,1,0,0,,0,0,8,4,4,ANY
2247,81368,OnClose,1,node.HandleWrap.OnClose,void node.HandleWrap.OnClose (uv_handle_t*),handle_wrap.cc,"void HandleWrap::OnClose(uv_handle_t* handle) {
  CHECK_NOT_NULL(handle->data);
  BaseObjectPtr<HandleWrap> wrap { static_cast<HandleWrap*>(handle->data) };
  wrap->Detach();

  Environment* env = wrap->env();
  HandleScope scope(env->isolate());
  Context::Scope context_scope(env->context());

  CHECK_EQ(wrap->state_, kClosing);

  wrap->state_ = kClosed;

  wrap->OnClose();
  wrap->handle_wrap_queue_.Remove();

  if (!wrap->persistent().IsEmpty() &&
      wrap->object()->Has(env->context(), env->handle_onclose_symbol())
      .FromMaybe(false)) {
    wrap->MakeCallback(env->handle_onclose_symbol(), 0, nullptr);
  }
}",135.0,156.0,1.0,1.0,22.0,28,9,21,7,0,0,2,2,0,0,,0,0,2,1,1,void
2248,81471,GetConstructorTemplate,1,node.HandleWrap.GetConstructorTemplate,Local<FunctionTemplate> node.HandleWrap.GetConstructorTemplate (Environment*),handle_wrap.cc,"Local<FunctionTemplate> HandleWrap::GetConstructorTemplate(
    IsolateData* isolate_data) {
  Local<FunctionTemplate> tmpl = isolate_data->handle_wrap_ctor_template();
  if (tmpl.IsEmpty()) {
    Isolate* isolate = isolate_data->isolate();
    tmpl = NewFunctionTemplate(isolate, nullptr);
    tmpl->SetClassName(
        FIXED_ONE_BYTE_STRING(isolate_data->isolate(), ""HandleWrap""));
    tmpl->Inherit(AsyncWrap::GetConstructorTemplate(isolate_data));
    SetProtoMethod(isolate, tmpl, ""close"", HandleWrap::Close);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""hasRef"", HandleWrap::HasRef);
    SetProtoMethod(isolate, tmpl, ""ref"", HandleWrap::Ref);
    SetProtoMethod(isolate, tmpl, ""unref"", HandleWrap::Unref);
    isolate_data->set_handle_wrap_ctor_template(tmpl);
  }
  return tmpl;
}",161.0,177.0,1.0,1.0,17.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,Local<FunctionTemplate>
2249,81569,RegisterExternalReferences,1,node.HandleWrap.RegisterExternalReferences,void node.HandleWrap.RegisterExternalReferences (ExternalReferenceRegistry*),handle_wrap.cc,"void HandleWrap::RegisterExternalReferences(
    ExternalReferenceRegistry* registry) {
  registry->Register(HandleWrap::Close);
  registry->Register(HandleWrap::HasRef);
  registry->Register(HandleWrap::Ref);
  registry->Register(HandleWrap::Unref);
}",179.0,185.0,1.0,1.0,7.0,8,2,8,2,0,0,1,1,0,0,,0,0,2,1,1,void
2250,81638,Name,1,node.heap.JSGraphJSNode.Name,const char* node.heap.JSGraphJSNode.Name (),heap_utils.cc,"const char* Name() override { return ""<JS Node>""; }",48.0,48.0,3.0,53.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,const char*
2251,81644,SizeInBytes,1,node.heap.JSGraphJSNode.SizeInBytes,size_t node.heap.JSGraphJSNode.SizeInBytes (),heap_utils.cc,size_t SizeInBytes() override { return 0; },49.0,49.0,3.0,45.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,size_t
2252,81650,IsEmbedderNode,1,node.heap.JSGraphJSNode.IsEmbedderNode,bool node.heap.JSGraphJSNode.IsEmbedderNode (),heap_utils.cc,bool IsEmbedderNode() override { return false; },50.0,50.0,3.0,50.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,bool
2253,81656,JSValue,1,node.heap.JSGraphJSNode.JSValue,Local<Value> node.heap.JSGraphJSNode.JSValue (),heap_utils.cc,Local<Value> JSValue() { return PersistentToLocal::Strong(persistent_); },51.0,51.0,3.0,75.0,1.0,1,1,2,2,0,1,1,1,0,0,,0,1,0,0,0,Local<Value>
2254,81666,IdentityHash,1,node.heap.JSGraphJSNode.IdentityHash,int node.heap.JSGraphJSNode.IdentityHash (),heap_utils.cc,"int IdentityHash() {
    Local<Value> v = JSValue();
    if (v->IsObject()) return v.As<Object>()->GetIdentityHash();
    if (v->IsName()) return v.As<v8::Name>()->GetIdentityHash();
    if (v->IsInt32()) return v.As<v8::Int32>()->Value();
    return 0;
  }",53.0,59.0,3.0,3.0,7.0,12,5,9,3,0,0,4,4,0,0,,0,0,0,0,0,int
2255,81721,JSGraphJSNode,1,node.heap.JSGraphJSNode.JSGraphJSNode,"ANY node.heap.JSGraphJSNode.JSGraphJSNode (Isolate*,Local<Value>)",heap_utils.cc,"JSGraphJSNode(Isolate* isolate, Local<Value> val)
      : persistent_(isolate, val) {
    CHECK(!val.IsEmpty());
  }",61.0,64.0,3.0,3.0,4.0,2,2,1,1,0,0,1,1,0,0,,0,0,4,2,2,ANY
2256,81734,operator (),1,node.heap.JSGraphJSNode.Hash.operator (),size_t node.heap.JSGraphJSNode.Hash.operator () (JSGraphJSNode*),heap_utils.cc,"inline size_t operator()(JSGraphJSNode* n) const {
      return static_cast<size_t>(n->IdentityHash());
    }",67.0,69.0,5.0,5.0,3.0,2,2,1,1,0,0,1,1,0,0,,0,0,2,1,1,size_t
2257,81747,operator (),1,node.heap.JSGraphJSNode.Equal.operator (),"bool node.heap.JSGraphJSNode.Equal.operator () (JSGraphJSNode*,JSGraphJSNode*)",heap_utils.cc,"inline bool operator()(JSGraphJSNode* a, JSGraphJSNode* b) const {
      return a->JSValue()->SameValue(b->JSValue());
    }",73.0,75.0,5.0,5.0,3.0,3,1,2,2,0,0,1,1,0,0,,0,0,4,2,2,bool
2258,81767,JSGraph,1,node.heap.JSGraph.JSGraph,ANY node.heap.JSGraph.JSGraph (Isolate*),heap_utils.cc,explicit JSGraph(Isolate* isolate) : isolate_(isolate) {},84.0,84.0,3.0,59.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
2259,81772,V8Node,1,node.heap.JSGraph.V8Node,Node node.heap.JSGraph.V8Node (Local<Value>),heap_utils.cc,"Node* V8Node(const Local<Value>& value) override {
    std::unique_ptr<JSGraphJSNode> n { new JSGraphJSNode(isolate_, value) };
    auto it = engine_nodes_.find(n.get());
    if (it != engine_nodes_.end())
      return *it;
    engine_nodes_.insert(n.get());
    return AddNode(std::unique_ptr<Node>(n.release()));
  }",86.0,93.0,3.0,3.0,8.0,15,8,15,8,0,4,2,2,1,0,,0,4,2,1,1,Node
2260,81827,AddNode,1,node.heap.JSGraph.AddNode,Node node.heap.JSGraph.AddNode (ANY),heap_utils.cc,"Node* AddNode(std::unique_ptr<Node> node) override {
    Node* n = node.get();
    nodes_.emplace(std::move(node));
    return n;
  }",95.0,99.0,3.0,3.0,5.0,4,2,6,4,0,1,1,1,0,0,,0,1,2,1,1,Node
2261,81850,AddEdge,1,node.heap.JSGraph.AddEdge,"void node.heap.JSGraph.AddEdge (Node*,Node*,char*)",heap_utils.cc,"void AddEdge(Node* from, Node* to, const char* name = nullptr) override {
    edges_[from].insert(std::make_pair(name, to));
  }",101.0,103.0,3.0,3.0,3.0,3,2,5,5,0,1,1,1,0,0,,0,1,6,3,3,void
2262,81869,CreateObject,1,node.heap.JSGraph.CreateObject,MaybeLocal<Array> node.heap.JSGraph.CreateObject (),heap_utils.cc,"MaybeLocal<Array> CreateObject() const {
    EscapableHandleScope handle_scope(isolate_);
    Local<Context> context = isolate_->GetCurrentContext();
    Environment* env = Environment::GetCurrent(context);

    std::unordered_map<Node*, Local<Object>> info_objects;
    Local<Array> nodes = Array::New(isolate_, nodes_.size());
    Local<String> edges_string = FIXED_ONE_BYTE_STRING(isolate_, ""edges"");
    Local<String> is_root_string = FIXED_ONE_BYTE_STRING(isolate_, ""isRoot"");
    Local<String> name_string = env->name_string();
    Local<String> size_string = env->size_string();
    Local<String> value_string = env->value_string();
    Local<String> wraps_string = FIXED_ONE_BYTE_STRING(isolate_, ""wraps"");
    Local<String> to_string = FIXED_ONE_BYTE_STRING(isolate_, ""to"");

    for (const std::unique_ptr<Node>& n : nodes_)
      info_objects[n.get()] = Object::New(isolate_);

    {
      HandleScope handle_scope(isolate_);
      size_t i = 0;
      for (const std::unique_ptr<Node>& ...",105.0,203.0,3.0,3.0,99.0,140,13,162,42,0,19,18,34,9,0,,0,19,0,0,0,MaybeLocal<Array>
2263,82410,BuildEmbedderGraph,1,node.heap.BuildEmbedderGraph,void node.heap.BuildEmbedderGraph (FunctionCallbackInfo<Value>),heap_utils.cc,"void BuildEmbedderGraph(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  JSGraph graph(env->isolate());
  Environment::BuildEmbedderGraph(env->isolate(), &graph, env);
  Local<Array> ret;
  if (graph.CreateObject().ToLocal(&ret))
    args.GetReturnValue().Set(ret);
}",213.0,220.0,1.0,1.0,8.0,13,6,15,7,0,0,2,2,0,0,,0,0,2,1,1,void
2264,82466,FileOutputStream,1,node.heap.anonymous_namespace_2.FileOutputStream.FileOutputStream,"ANY node.heap.anonymous_namespace_2.FileOutputStream.FileOutputStream (int,uv_fs_t*)",heap_utils.cc,"FileOutputStream(const int fd, uv_fs_t* req) : fd_(fd), req_(req) {}",225.0,225.0,3.0,70.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,ANY
2265,82472,GetChunkSize,1,node.heap.anonymous_namespace_3.FileOutputStream.GetChunkSize,int node.heap.anonymous_namespace_3.FileOutputStream.GetChunkSize (),heap_utils.cc,"int GetChunkSize() override {
    return 65536;  // big chunks == faster
  }",227.0,229.0,3.0,3.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,int
2266,82478,EndOfStream,1,node.heap.anonymous_namespace_4.FileOutputStream.EndOfStream,void node.heap.anonymous_namespace_4.FileOutputStream.EndOfStream (),heap_utils.cc,void EndOfStream() override {},231.0,231.0,3.0,32.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2267,82482,WriteAsciiChunk,1,node.heap.anonymous_namespace_5.FileOutputStream.WriteAsciiChunk,"WriteResult node.heap.anonymous_namespace_5.FileOutputStream.WriteAsciiChunk (char*,int)",heap_utils.cc,"WriteResult WriteAsciiChunk(char* data, const int size) override {
    DCHECK_EQ(status_, 0);
    int offset = 0;
    while (offset < size) {
      const uv_buf_t buf = uv_buf_init(data + offset, size - offset);
      const int num_bytes_written = uv_fs_write(nullptr,
                                                req_,
                                                fd_,
                                                &buf,
                                                1,
                                                -1,
                                                nullptr);
      uv_fs_req_cleanup(req_);
      if (num_bytes_written < 0) {
        status_ = num_bytes_written;
        return kAbort;
      }
      DCHECK_LE(static_cast<size_t>(num_bytes_written), buf.len);
      offset += num_bytes_written;
    }
    DCHECK_EQ(offset, size);
    return kContinue;
  }",233.0,255.0,3.0,3.0,23.0,13,9,25,10,0,5,3,4,0,0,,0,5,4,2,2,WriteResult
2268,82550,status,1,node.heap.anonymous_namespace_6.FileOutputStream.status,int node.heap.anonymous_namespace_6.FileOutputStream.status (),heap_utils.cc,int status() const { return status_; },257.0,257.0,3.0,40.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,int
2269,82567,HeapSnapshotStream,1,node.heap.anonymous_namespace_8.HeapSnapshotStream.HeapSnapshotStream,"ANY node.heap.anonymous_namespace_8.HeapSnapshotStream.HeapSnapshotStream (Environment*,HeapSnapshotPointer,Local<Object>)",heap_utils.cc,"HeapSnapshotStream(
      Environment* env,
      HeapSnapshotPointer&& snapshot,
      Local<Object> obj) :
      AsyncWrap(env, obj, AsyncWrap::PROVIDER_HEAPSNAPSHOT),
      StreamBase(env),
      snapshot_(std::move(snapshot)) {
    MakeWeak();
    StreamBase::AttachToObject(GetObject());
  }",269.0,278.0,3.0,3.0,10.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,ANY
2270,82576,~HeapSnapshotStream,1,node.heap.anonymous_namespace_9.HeapSnapshotStream.~HeapSnapshotStream,ANY node.heap.anonymous_namespace_9.HeapSnapshotStream.~HeapSnapshotStream (),heap_utils.cc,~HeapSnapshotStream() override {},280.0,280.0,3.0,35.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
2271,82580,GetChunkSize,1,node.heap.anonymous_namespace_10.HeapSnapshotStream.GetChunkSize,int node.heap.anonymous_namespace_10.HeapSnapshotStream.GetChunkSize (),heap_utils.cc,"int GetChunkSize() override {
    return 65536;  // big chunks == faster
  }",282.0,284.0,3.0,3.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,int
2272,82586,EndOfStream,1,node.heap.anonymous_namespace_11.HeapSnapshotStream.EndOfStream,void node.heap.anonymous_namespace_11.HeapSnapshotStream.EndOfStream (),heap_utils.cc,"void EndOfStream() override {
    EmitRead(UV_EOF);
    snapshot_.reset();
  }",286.0,289.0,3.0,3.0,4.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,void
2273,82595,WriteAsciiChunk,1,node.heap.anonymous_namespace_12.HeapSnapshotStream.WriteAsciiChunk,"WriteResult node.heap.anonymous_namespace_12.HeapSnapshotStream.WriteAsciiChunk (char*,int)",heap_utils.cc,"WriteResult WriteAsciiChunk(char* data, int size) override {
    int len = size;
    while (len != 0) {
      uv_buf_t buf = EmitAlloc(size);
      ssize_t avail = len;
      if (static_cast<ssize_t>(buf.len) < avail)
        avail = buf.len;
      memcpy(buf.base, data, avail);
      data += avail;
      len -= static_cast<int>(avail);
      EmitRead(size, buf);
    }
    return kContinue;
  }",291.0,304.0,3.0,3.0,14.0,13,7,21,6,0,0,3,4,0,0,,0,0,4,2,2,WriteResult
2274,82652,ReadStart,1,node.heap.anonymous_namespace_13.HeapSnapshotStream.ReadStart,int node.heap.anonymous_namespace_13.HeapSnapshotStream.ReadStart (),heap_utils.cc,"int ReadStart() override {
    CHECK_NE(snapshot_, nullptr);
    snapshot_->Serialize(this, HeapSnapshot::kJSON);
    return 0;
  }",306.0,310.0,3.0,3.0,5.0,2,2,3,2,0,2,1,1,0,0,,0,2,0,0,0,int
2275,82669,ReadStop,1,node.heap.anonymous_namespace_14.HeapSnapshotStream.ReadStop,int node.heap.anonymous_namespace_14.HeapSnapshotStream.ReadStop (),heap_utils.cc,"int ReadStop() override {
    return 0;
  }",312.0,314.0,3.0,3.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,int
2276,82675,DoShutdown,1,node.heap.anonymous_namespace_15.HeapSnapshotStream.DoShutdown,int node.heap.anonymous_namespace_15.HeapSnapshotStream.DoShutdown (ShutdownWrap*),heap_utils.cc,"int DoShutdown(ShutdownWrap* req_wrap) override {
    UNREACHABLE();
  }",316.0,318.0,3.0,3.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
2277,82681,DoWrite,1,node.heap.anonymous_namespace_16.HeapSnapshotStream.DoWrite,"int node.heap.anonymous_namespace_16.HeapSnapshotStream.DoWrite (WriteWrap*,uv_buf_t*,size_t,uv_stream_t*)",heap_utils.cc,"int DoWrite(WriteWrap* w,
              uv_buf_t* bufs,
              size_t count,
              uv_stream_t* send_handle) override {
    UNREACHABLE();
  }",320.0,325.0,3.0,3.0,6.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,int
2278,82690,IsAlive,1,node.heap.anonymous_namespace_17.HeapSnapshotStream.IsAlive,bool node.heap.anonymous_namespace_17.HeapSnapshotStream.IsAlive (),heap_utils.cc,bool IsAlive() override { return snapshot_ != nullptr; },327.0,327.0,3.0,58.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,bool
2279,82698,IsClosing,1,node.heap.anonymous_namespace_18.HeapSnapshotStream.IsClosing,bool node.heap.anonymous_namespace_18.HeapSnapshotStream.IsClosing (),heap_utils.cc,bool IsClosing() override { return snapshot_ == nullptr; },328.0,328.0,3.0,60.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,bool
2280,82706,GetAsyncWrap,1,node.heap.anonymous_namespace_19.HeapSnapshotStream.GetAsyncWrap,AsyncWrap node.heap.anonymous_namespace_19.HeapSnapshotStream.GetAsyncWrap (),heap_utils.cc,AsyncWrap* GetAsyncWrap() override { return this; },329.0,329.0,3.0,53.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,AsyncWrap
2281,82712,MemoryInfo,1,node.heap.anonymous_namespace_20.HeapSnapshotStream.MemoryInfo,void node.heap.anonymous_namespace_20.HeapSnapshotStream.MemoryInfo (MemoryTracker*),heap_utils.cc,"void MemoryInfo(MemoryTracker* tracker) const override {
    if (snapshot_ != nullptr) {
      tracker->TrackFieldWithSize(
          ""snapshot"", sizeof(*snapshot_), ""HeapSnapshot"");
    }
  }",331.0,336.0,3.0,3.0,6.0,4,4,3,2,0,2,2,2,1,0,,0,2,2,1,1,void
2282,82736,TakeSnapshot,1,node.heap.anonymous_namespace_21.TakeSnapshot,"void node.heap.anonymous_namespace_21.TakeSnapshot (Environment*,ANY*,ANY)",heap_utils.cc,"inline void TakeSnapshot(Environment* env,
                         v8::OutputStream* out,
                         HeapProfiler::HeapSnapshotOptions options) {
  HeapSnapshotPointer snapshot{
      env->isolate()->GetHeapProfiler()->TakeHeapSnapshot(options)};
  snapshot->Serialize(out, HeapSnapshot::kJSON);
}",345.0,351.0,1.0,1.0,7.0,7,4,6,5,0,0,1,1,0,0,,0,0,6,3,3,void
2283,82766,WriteSnapshot,1,node.heap.WriteSnapshot,"Maybe<void> node.heap.WriteSnapshot (Environment*,char*,ANY)",heap_utils.cc,"Maybe<void> WriteSnapshot(Environment* env,
                          const char* filename,
                          HeapProfiler::HeapSnapshotOptions options) {
  uv_fs_t req;
  int err;

  const int fd = uv_fs_open(nullptr,
                            &req,
                            filename,
                            O_WRONLY | O_CREAT | O_TRUNC,
                            S_IWUSR | S_IRUSR,
                            nullptr);
  uv_fs_req_cleanup(&req);
  if ((err = fd) < 0) {
    env->ThrowUVException(err, ""open"", nullptr, filename);
    return Nothing<void>();
  }

  FileOutputStream stream(fd, &req);
  TakeSnapshot(env, &stream, options);
  if ((err = stream.status()) < 0) {
    env->ThrowUVException(err, ""write"", nullptr, filename);
    return Nothing<void>();
  }

  err = uv_fs_close(nullptr, &req, fd, nullptr);
  uv_fs_req_cleanup(&req);
  if (err < 0) {
    env->ThrowUVException(err, ""close"", nullptr, filename);
    return Nothing<void>();
  }

  return JustVoid();
}",355.0,388.0,1.0,1.0,34.0,20,6,32,12,0,0,4,4,0,0,,0,0,6,3,3,Maybe<void>
2284,82870,DeleteHeapSnapshot,1,node.heap.DeleteHeapSnapshot,void node.heap.DeleteHeapSnapshot (HeapSnapshot*),heap_utils.cc,"void DeleteHeapSnapshot(const HeapSnapshot* snapshot) {
  const_cast<HeapSnapshot*>(snapshot)->Delete();
}",390.0,392.0,1.0,1.0,3.0,2,2,1,1,0,0,1,1,0,0,,0,0,2,1,1,void
2285,82881,CreateHeapSnapshotStream,1,node.heap.CreateHeapSnapshotStream,"BaseObjectPtr<AsyncWrap> node.heap.CreateHeapSnapshotStream (Environment*,HeapSnapshotPointer)",heap_utils.cc,"void CreateHeapSnapshotStream(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  CHECK_EQ(args.Length(), 1);
  auto options = GetHeapSnapshotOptions(args[0]);
  HeapSnapshotPointer snapshot{
      env->isolate()->GetHeapProfiler()->TakeHeapSnapshot(options)};
  CHECK(snapshot);
  BaseObjectPtr<AsyncWrap> stream =
      CreateHeapSnapshotStream(env, std::move(snapshot));
  if (stream)
    args.GetReturnValue().Set(stream->object());
}",435.0,446.0,1.0,1.0,12.0,33,9,35,14,0,0,3,3,0,0,,0,0,2,1,1,void
2286,83002,GetHeapSnapshotOptions,1,node.heap.GetHeapSnapshotOptions,HeapSnapshotOptions node.heap.GetHeapSnapshotOptions (Local<Value>),heap_utils.cc,"HeapProfiler::HeapSnapshotOptions GetHeapSnapshotOptions(
    Local<Value> options_value) {
  CHECK(options_value->IsUint8Array());
  Local<Uint8Array> arr = options_value.As<Uint8Array>();
  uint8_t* options =
      static_cast<uint8_t*>(arr->Buffer()->Data()) + arr->ByteOffset();
  HeapProfiler::HeapSnapshotOptions result;
  result.snapshot_mode = options[0]
                             ? HeapProfiler::HeapSnapshotMode::kExposeInternals
                             : HeapProfiler::HeapSnapshotMode::kRegular;
  result.numerics_mode = options[1]
                             ? HeapProfiler::NumericsMode::kExposeNumericValues
                             : HeapProfiler::NumericsMode::kHideNumericValues;
  return result;
}",419.0,433.0,1.0,1.0,15.0,27,9,21,9,0,0,1,1,0,0,,0,0,2,1,1,HeapSnapshotOptions
2287,83148,TriggerHeapSnapshot,1,node.heap.TriggerHeapSnapshot,void node.heap.TriggerHeapSnapshot (FunctionCallbackInfo<Value>),heap_utils.cc,"void TriggerHeapSnapshot(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = args.GetIsolate();
  CHECK_EQ(args.Length(), 2);
  Local<Value> filename_v = args[0];
  auto options = GetHeapSnapshotOptions(args[1]);

  if (filename_v->IsUndefined()) {
    DiagnosticFilename name(env, ""Heap"", ""heapsnapshot"");
    if (WriteSnapshot(env, *name, options).IsNothing()) return;
    if (String::NewFromUtf8(isolate, *name).ToLocal(&filename_v)) {
      args.GetReturnValue().Set(filename_v);
    }
    return;
  }

  BufferValue path(isolate, filename_v);
  CHECK_NOT_NULL(*path);
  if (WriteSnapshot(env, *path, options).IsNothing()) return;
  return args.GetReturnValue().Set(filename_v);
}",448.0,468.0,1.0,1.0,21.0,25,8,31,11,0,0,5,7,0,0,,0,0,2,1,1,void
2288,83262,Initialize,1,node.heap.Initialize,"void node.heap.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)",heap_utils.cc,"void Initialize(Local<Object> target,
                Local<Value> unused,
                Local<Context> context,
                void* priv) {
  SetMethod(context, target, ""buildEmbedderGraph"", BuildEmbedderGraph);
  SetMethod(context, target, ""triggerHeapSnapshot"", TriggerHeapSnapshot);
  SetMethod(
      context, target, ""createHeapSnapshotStream"", CreateHeapSnapshotStream);
}",470.0,478.0,1.0,1.0,9.0,0,0,7,3,0,0,1,1,0,0,,0,0,8,4,4,void
2289,83285,RegisterExternalReferences,1,node.heap.RegisterExternalReferences,void node.heap.RegisterExternalReferences (ExternalReferenceRegistry*),heap_utils.cc,"void RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  registry->Register(BuildEmbedderGraph);
  registry->Register(TriggerHeapSnapshot);
  registry->Register(CreateHeapSnapshotStream);
}",480.0,484.0,1.0,1.0,5.0,3,1,4,2,0,0,1,1,0,0,,0,0,2,1,1,void
2290,83318,<lambda>0,1,node.HistogramBase.GetPercentiles.<lambda>0,"ANY node.HistogramBase.GetPercentiles.<lambda>0 (double,int64_t)",histogram.cc,"[map, env](double key, int64_t value) {
    USE(map->Set(
          env->context(),
          Number::New(env->isolate(), key),
          Number::New(env->isolate(), static_cast<double>(value))));
  }",163.0,168.0,29.0,3.0,6.0,7,3,8,5,0,0,1,1,0,0,,0,0,4,2,2,ANY
2291,83356,<lambda>1,1,node.HistogramBase.GetPercentilesBigInt.<lambda>1,"ANY node.HistogramBase.GetPercentilesBigInt.<lambda>1 (double,int64_t)",histogram.cc,"[map, env](double key, int64_t value) {
    USE(map->Set(
          env->context(),
          Number::New(env->isolate(), key),
          BigInt::New(env->isolate(), value)));
  }",178.0,183.0,29.0,3.0,6.0,6,2,8,6,0,0,1,1,0,0,,0,0,4,2,2,ANY
2292,83391,<lambda>2,1,node.IntervalHistogram.GetPercentiles.<lambda>2,"ANY node.IntervalHistogram.GetPercentiles.<lambda>2 (double,int64_t)",histogram.cc,"[map, env](double key, int64_t value) {
    USE(map->Set(
          env->context(),
          Number::New(env->isolate(), key),
          Number::New(env->isolate(), static_cast<double>(value))));
  }",603.0,608.0,29.0,3.0,6.0,7,3,8,5,0,0,1,1,0,0,,0,0,4,2,2,ANY
2293,83428,<lambda>3,1,node.IntervalHistogram.GetPercentilesBigInt.<lambda>3,"ANY node.IntervalHistogram.GetPercentilesBigInt.<lambda>3 (double,int64_t)",histogram.cc,"[map, env](double key, int64_t value) {
    USE(map->Set(
          env->context(),
          Number::New(env->isolate(), key),
          BigInt::New(env->isolate(), value)));
  }",618.0,623.0,29.0,3.0,6.0,6,2,8,6,0,0,1,1,0,0,,0,0,4,2,2,ANY
2294,83479,Histogram,1,node.Histogram.Histogram,ANY node.Histogram.Histogram (Options),histogram.cc,"Histogram::Histogram(const Options& options) {
  hdr_histogram* histogram;
  CHECK_EQ(0, hdr_init(options.lowest,
                       options.highest,
                       options.figures,
                       &histogram));
  histogram_.reset(histogram);
}",24.0,31.0,1.0,1.0,8.0,5,2,6,3,0,0,1,1,0,0,,0,0,2,1,1,ANY
2295,83504,MemoryInfo,1,node.Histogram.MemoryInfo,void node.Histogram.MemoryInfo (MemoryTracker*),histogram.cc,"void Histogram::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackFieldWithSize(""histogram"", GetMemorySize());
}",33.0,35.0,1.0,1.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,void
2296,83515,HistogramImpl,1,node.HistogramImpl.HistogramImpl,ANY node.HistogramImpl.HistogramImpl (ANY),histogram.cc,"HistogramImpl::HistogramImpl(std::shared_ptr<Histogram> histogram)
    : histogram_(std::move(histogram)) {}",40.0,41.0,1.0,41.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
2297,83525,HistogramBase,1,node.HistogramBase.HistogramBase,"ANY node.HistogramBase.HistogramBase (Environment*,Local<Object>,ANY)",histogram.cc,"HistogramBase::HistogramBase(
    Environment* env,
    Local<Object> wrap,
    std::shared_ptr<Histogram> histogram)
    : BaseObject(env, wrap),
      HistogramImpl(std::move(histogram)) {
  MakeWeak();
}",52.0,59.0,1.0,1.0,8.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,ANY
2298,83541,MemoryInfo,1,node.HistogramBase.MemoryInfo,void node.HistogramBase.MemoryInfo (MemoryTracker*),histogram.cc,"void HistogramBase::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackField(""histogram"", histogram());
}",61.0,63.0,1.0,1.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,void
2299,83552,GetCount,1,node.HistogramBase.GetCount,void node.HistogramBase.GetCount (ANY),histogram.cc,"void HistogramBase::GetCount(const v8::FunctionCallbackInfo<v8::Value>& args) {
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  double value = static_cast<double>((*histogram)->Count());
  args.GetReturnValue().Set(value);
}",65.0,70.0,1.0,1.0,6.0,8,6,6,3,0,0,1,1,0,0,,0,0,2,1,1,void
2300,83583,GetCountBigInt,1,node.HistogramBase.GetCountBigInt,void node.HistogramBase.GetCountBigInt (ANY),histogram.cc,"void HistogramBase::GetCountBigInt(
    const v8::FunctionCallbackInfo<v8::Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  args.GetReturnValue().Set(
      BigInt::NewFromUnsigned(env->isolate(), (*histogram)->Count()));
}",72.0,79.0,1.0,1.0,8.0,10,5,9,5,0,0,1,1,0,0,,0,0,2,1,1,void
2301,83624,GetMin,1,node.HistogramBase.GetMin,void node.HistogramBase.GetMin (FunctionCallbackInfo<Value>),histogram.cc,"void HistogramBase::GetMin(const FunctionCallbackInfo<Value>& args) {
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  double value = static_cast<double>((*histogram)->Min());
  args.GetReturnValue().Set(value);
}",81.0,86.0,1.0,1.0,6.0,8,6,6,3,0,0,1,1,0,0,,0,0,2,1,1,void
2302,83655,GetMinBigInt,1,node.HistogramBase.GetMinBigInt,void node.HistogramBase.GetMinBigInt (FunctionCallbackInfo<Value>),histogram.cc,"void HistogramBase::GetMinBigInt(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  args.GetReturnValue().Set(BigInt::New(env->isolate(), (*histogram)->Min()));
}",88.0,93.0,1.0,1.0,6.0,10,5,9,5,0,0,1,1,0,0,,0,0,2,1,1,void
2303,83696,GetMax,1,node.HistogramBase.GetMax,void node.HistogramBase.GetMax (FunctionCallbackInfo<Value>),histogram.cc,"void HistogramBase::GetMax(const FunctionCallbackInfo<Value>& args) {
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  double value = static_cast<double>((*histogram)->Max());
  args.GetReturnValue().Set(value);
}",95.0,100.0,1.0,1.0,6.0,8,6,6,3,0,0,1,1,0,0,,0,0,2,1,1,void
2304,83727,GetMaxBigInt,1,node.HistogramBase.GetMaxBigInt,void node.HistogramBase.GetMaxBigInt (FunctionCallbackInfo<Value>),histogram.cc,"void HistogramBase::GetMaxBigInt(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  args.GetReturnValue().Set(
      BigInt::New(env->isolate(), (*histogram)->Max()));
}",102.0,108.0,1.0,1.0,7.0,10,5,9,5,0,0,1,1,0,0,,0,0,2,1,1,void
2305,83768,GetMean,1,node.HistogramBase.GetMean,void node.HistogramBase.GetMean (FunctionCallbackInfo<Value>),histogram.cc,"void HistogramBase::GetMean(const FunctionCallbackInfo<Value>& args) {
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  args.GetReturnValue().Set((*histogram)->Mean());
}",110.0,114.0,1.0,1.0,5.0,6,4,4,2,0,0,1,1,0,0,,0,0,2,1,1,void
2306,83793,GetExceeds,1,node.HistogramBase.GetExceeds,void node.HistogramBase.GetExceeds (FunctionCallbackInfo<Value>),histogram.cc,"void HistogramBase::GetExceeds(const FunctionCallbackInfo<Value>& args) {
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  double value = static_cast<double>((*histogram)->Exceeds());
  args.GetReturnValue().Set(value);
}",116.0,121.0,1.0,1.0,6.0,8,6,6,3,0,0,1,1,0,0,,0,0,2,1,1,void
2307,83824,GetExceedsBigInt,1,node.HistogramBase.GetExceedsBigInt,void node.HistogramBase.GetExceedsBigInt (FunctionCallbackInfo<Value>),histogram.cc,"void HistogramBase::GetExceedsBigInt(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  args.GetReturnValue().Set(
      BigInt::NewFromUnsigned(env->isolate(), (*histogram)->Exceeds()));
}",123.0,129.0,1.0,1.0,7.0,10,5,9,5,0,0,1,1,0,0,,0,0,2,1,1,void
2308,83865,GetStddev,1,node.HistogramBase.GetStddev,void node.HistogramBase.GetStddev (FunctionCallbackInfo<Value>),histogram.cc,"void HistogramBase::GetStddev(const FunctionCallbackInfo<Value>& args) {
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  args.GetReturnValue().Set((*histogram)->Stddev());
}",131.0,135.0,1.0,1.0,5.0,6,4,4,2,0,0,1,1,0,0,,0,0,2,1,1,void
2309,83890,GetPercentile,1,node.HistogramBase.GetPercentile,void node.HistogramBase.GetPercentile (FunctionCallbackInfo<Value>),histogram.cc,"void HistogramBase::GetPercentile(const FunctionCallbackInfo<Value>& args) {
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  CHECK(args[0]->IsNumber());
  double percentile = args[0].As<Number>()->Value();
  double value = static_cast<double>((*histogram)->Percentile(percentile));
  args.GetReturnValue().Set(value);
}",137.0,144.0,1.0,1.0,8.0,14,7,10,4,0,0,1,1,0,0,,0,0,2,1,1,void
2310,83941,GetPercentileBigInt,1,node.HistogramBase.GetPercentileBigInt,void node.HistogramBase.GetPercentileBigInt (FunctionCallbackInfo<Value>),histogram.cc,"void HistogramBase::GetPercentileBigInt(
    const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  CHECK(args[0]->IsNumber());
  double percentile = args[0].As<Number>()->Value();
  int64_t value = (*histogram)->Percentile(percentile);
  args.GetReturnValue().Set(BigInt::New(env->isolate(), value));
}",146.0,155.0,1.0,1.0,10.0,17,6,15,7,0,0,1,1,0,0,,0,0,2,1,1,void
2311,84006,GetPercentiles,1,node.HistogramBase.GetPercentiles,void node.HistogramBase.GetPercentiles (FunctionCallbackInfo<Value>),histogram.cc,"void HistogramBase::GetPercentiles(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  CHECK(args[0]->IsMap());
  Local<Map> map = args[0].As<Map>();
  (*histogram)->Percentiles([map, env](double key, int64_t value) {
    USE(map->Set(
          env->context(),
          Number::New(env->isolate(), key),
          Number::New(env->isolate(), static_cast<double>(value))));
  });
}",157.0,169.0,1.0,1.0,13.0,13,8,11,7,0,0,1,1,0,0,,0,0,2,1,1,void
2312,84051,GetPercentilesBigInt,1,node.HistogramBase.GetPercentilesBigInt,void node.HistogramBase.GetPercentilesBigInt (FunctionCallbackInfo<Value>),histogram.cc,"void HistogramBase::GetPercentilesBigInt(
    const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  CHECK(args[0]->IsMap());
  Local<Map> map = args[0].As<Map>();
  (*histogram)->Percentiles([map, env](double key, int64_t value) {
    USE(map->Set(
          env->context(),
          Number::New(env->isolate(), key),
          BigInt::New(env->isolate(), value)));
  });
}",171.0,184.0,1.0,1.0,14.0,13,8,11,7,0,0,1,1,0,0,,0,0,2,1,1,void
2313,84096,DoReset,1,node.HistogramBase.DoReset,void node.HistogramBase.DoReset (FunctionCallbackInfo<Value>),histogram.cc,"void HistogramBase::DoReset(const FunctionCallbackInfo<Value>& args) {
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  (*histogram)->Reset();
}",186.0,190.0,1.0,1.0,5.0,4,4,3,2,0,0,1,1,0,0,,0,0,2,1,1,void
2314,84114,RecordDelta,1,node.HistogramBase.RecordDelta,void node.HistogramBase.RecordDelta (FunctionCallbackInfo<Value>),histogram.cc,"void HistogramBase::RecordDelta(const FunctionCallbackInfo<Value>& args) {
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  (*histogram)->RecordDelta();
}",192.0,196.0,1.0,1.0,5.0,4,4,3,2,0,0,1,1,0,0,,0,0,2,1,1,void
2315,84132,Record,1,node.HistogramBase.Record,void node.HistogramBase.Record (FunctionCallbackInfo<Value>),histogram.cc,"void HistogramBase::Record(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  CHECK_IMPLIES(!args[0]->IsNumber(), args[0]->IsBigInt());
  bool lossless = true;
  int64_t value = args[0]->IsBigInt()
      ? args[0].As<BigInt>()->Int64Value(&lossless)
      : static_cast<int64_t>(args[0].As<Number>()->Value());
  if (!lossless || value < 1)
    return THROW_ERR_OUT_OF_RANGE(env, ""value is out of range"");
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  (*histogram)->Record(value);
}",198.0,210.0,1.0,1.0,13.0,27,11,18,6,0,0,2,2,0,0,,0,0,2,1,1,void
2316,84221,Add,1,node.HistogramBase.Add,void node.HistogramBase.Add (FunctionCallbackInfo<Value>),histogram.cc,"void HistogramBase::Add(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  HistogramBase* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());

  CHECK(GetConstructorTemplate(env->isolate_data())->HasInstance(args[0]));
  HistogramBase* other;
  ASSIGN_OR_RETURN_UNWRAP(&other, args[0]);

  double count = (*histogram)->Add(*(other->histogram()));
  args.GetReturnValue().Set(count);
}",212.0,223.0,1.0,1.0,12.0,16,6,14,6,0,0,1,1,0,0,,0,0,2,1,1,void
2317,84282,Create,1,node.HistogramBase.Create,"BaseObjectPtr<HistogramBase> node.HistogramBase.Create (Environment*,ANY)",histogram.cc,"BaseObjectPtr<HistogramBase> HistogramBase::Create(
    Environment* env,
    std::shared_ptr<Histogram> histogram) {
  Local<Object> obj;
  if (!GetConstructorTemplate(env->isolate_data())
           ->InstanceTemplate()
           ->NewInstance(env->context())
           .ToLocal(&obj)) {
    return BaseObjectPtr<HistogramBase>();
  }
  return MakeBaseObject<HistogramBase>(env, obj, std::move(histogram));
}",239.0,250.0,1.0,1.0,12.0,13,8,11,7,0,0,2,2,0,0,,0,0,4,2,2,BaseObjectPtr<HistogramBase>
2318,84378,New,1,node.HistogramBase.New,void node.HistogramBase.New (FunctionCallbackInfo<Value>),histogram.cc,"void HistogramBase::New(const FunctionCallbackInfo<Value>& args) {
  CHECK(args.IsConstructCall());
  Environment* env = Environment::GetCurrent(args);

  CHECK_IMPLIES(!args[0]->IsNumber(), args[0]->IsBigInt());
  CHECK_IMPLIES(!args[1]->IsNumber(), args[1]->IsBigInt());
  CHECK(args[2]->IsUint32());

  int64_t lowest = 1;
  int64_t highest = std::numeric_limits<int64_t>::max();

  bool lossless_ignored;

  if (args[0]->IsNumber()) {
    lowest = args[0].As<Integer>()->Value();
  } else if (args[0]->IsBigInt()) {
    lowest = args[0].As<BigInt>()->Int64Value(&lossless_ignored);
  }

  if (args[1]->IsNumber()) {
    highest = args[1].As<Integer>()->Value();
  } else if (args[1]->IsBigInt()) {
    highest = args[1].As<BigInt>()->Int64Value(&lossless_ignored);
  }

  int32_t figures = args[2].As<Uint32>()->Value();
  new HistogramBase(env, args.This(), Histogram::Options {
    lowest, highest, figures
  });
}",252.0,281.0,1.0,1.0,30.0,40,9,27,9,0,0,3,3,0,0,,0,0,2,1,1,void
2319,84557,GetConstructorTemplate,1,node.HistogramBase.GetConstructorTemplate,Local<FunctionTemplate> node.HistogramBase.GetConstructorTemplate (IsolateData*),histogram.cc,"Local<FunctionTemplate> HistogramBase::GetConstructorTemplate(
    IsolateData* isolate_data) {
  Local<FunctionTemplate> tmpl = isolate_data->histogram_ctor_template();
  if (tmpl.IsEmpty()) {
    Isolate* isolate = isolate_data->isolate();
    tmpl = NewFunctionTemplate(isolate, New);
    Local<String> classname = FIXED_ONE_BYTE_STRING(isolate, ""Histogram"");
    tmpl->SetClassName(classname);

    tmpl->InstanceTemplate()->SetInternalFieldCount(
        HistogramBase::kInternalFieldCount);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""count"", GetCount);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""countBigInt"", GetCountBigInt);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""exceeds"", GetExceeds);
    SetProtoMethodNoSideEffect(
        isolate, tmpl, ""exceedsBigInt"", GetExceedsBigInt);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""min"", GetMin);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""minBigInt"", GetMinBigInt);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""max"", GetMax...",283.0,318.0,1.0,1.0,36.0,16,5,75,27,0,0,2,2,0,0,,0,0,2,1,1,Local<FunctionTemplate>
2320,84711,RegisterExternalReferences,1,node.HistogramBase.RegisterExternalReferences,void node.HistogramBase.RegisterExternalReferences (ExternalReferenceRegistry*),histogram.cc,"void HistogramBase::RegisterExternalReferences(
    ExternalReferenceRegistry* registry) {
  registry->Register(New);
  registry->Register(GetCount);
  registry->Register(GetCountBigInt);
  registry->Register(GetExceeds);
  registry->Register(GetExceedsBigInt);
  registry->Register(GetMin);
  registry->Register(GetMinBigInt);
  registry->Register(GetMax);
  registry->Register(GetMaxBigInt);
  registry->Register(GetMean);
  registry->Register(GetStddev);
  registry->Register(GetPercentile);
  registry->Register(GetPercentileBigInt);
  registry->Register(GetPercentiles);
  registry->Register(GetPercentilesBigInt);
  registry->Register(DoReset);
  registry->Register(Record);
  registry->Register(RecordDelta);
  registry->Register(Add);
}",320.0,341.0,1.0,1.0,22.0,19,1,38,20,0,0,1,1,0,0,,0,0,2,1,1,void
2321,84811,Initialize,1,node.HistogramBase.Initialize,"void node.HistogramBase.Initialize (IsolateData*,Local<ObjectTemplate>)",histogram.cc,"void HistogramBase::Initialize(IsolateData* isolate_data,
                               Local<ObjectTemplate> target) {
  SetConstructorFunction(isolate_data->isolate(),
                         target,
                         ""Histogram"",
                         GetConstructorTemplate(isolate_data),
                         SetConstructorFunctionFlag::NONE);
}",343.0,350.0,1.0,1.0,8.0,2,2,4,3,0,0,1,1,0,0,,0,0,4,2,2,void
2322,84829,Deserialize,1,node.HistogramBase.HistogramTransferData.Deserialize,"BaseObjectPtr<BaseObject> node.HistogramBase.HistogramTransferData.Deserialize (Environment*,ANY,ANY)",histogram.cc,"BaseObjectPtr<BaseObject> HistogramBase::HistogramTransferData::Deserialize(
    Environment* env,
    v8::Local<v8::Context> context,
    std::unique_ptr<worker::TransferData> self) {
  return Create(env, std::move(histogram_));
}",352.0,357.0,1.0,1.0,6.0,1,1,3,3,0,0,1,1,0,0,,0,0,6,3,3,BaseObjectPtr<BaseObject>
2323,84844,CloneForMessaging,1,node.HistogramBase.CloneForMessaging,unique_ptr<worker::TransferData> node.HistogramBase.CloneForMessaging (),histogram.cc,"std::unique_ptr<worker::TransferData> HistogramBase::CloneForMessaging() const {
  return std::make_unique<HistogramTransferData>(this);
}",359.0,361.0,1.0,1.0,3.0,3,3,2,2,0,0,1,1,0,0,,0,0,0,0,0,unique_ptr<worker.TransferData>
2324,84856,MemoryInfo,1,node.HistogramBase.HistogramTransferData.MemoryInfo,void node.HistogramBase.HistogramTransferData.MemoryInfo (MemoryTracker*),histogram.cc,"void HistogramBase::HistogramTransferData::MemoryInfo(
    MemoryTracker* tracker) const {
  tracker->TrackField(""histogram"", histogram_);
}",363.0,366.0,1.0,1.0,4.0,1,1,2,2,0,0,1,1,0,0,,0,0,2,1,1,void
2325,84867,GetConstructorTemplate,1,node.IntervalHistogram.GetConstructorTemplate,Local<FunctionTemplate> node.IntervalHistogram.GetConstructorTemplate (Environment*),histogram.cc,"Local<FunctionTemplate> IntervalHistogram::GetConstructorTemplate(
    Environment* env) {
  Local<FunctionTemplate> tmpl = env->intervalhistogram_constructor_template();
  if (tmpl.IsEmpty()) {
    Isolate* isolate = env->isolate();
    tmpl = NewFunctionTemplate(isolate, nullptr);
    tmpl->Inherit(HandleWrap::GetConstructorTemplate(env));
    tmpl->SetClassName(OneByteString(isolate, ""Histogram""));
    tmpl->InstanceTemplate()->SetInternalFieldCount(
        HistogramBase::kInternalFieldCount);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""count"", GetCount);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""countBigInt"", GetCountBigInt);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""exceeds"", GetExceeds);
    SetProtoMethodNoSideEffect(
        isolate, tmpl, ""exceedsBigInt"", GetExceedsBigInt);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""min"", GetMin);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""minBigInt"", GetMinBigInt);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""max"", ...",368.0,401.0,1.0,1.0,34.0,15,5,70,24,0,0,2,2,0,0,,0,0,2,1,1,Local<FunctionTemplate>
2326,85018,RegisterExternalReferences,1,node.IntervalHistogram.RegisterExternalReferences,void node.IntervalHistogram.RegisterExternalReferences (ExternalReferenceRegistry*),histogram.cc,"void IntervalHistogram::RegisterExternalReferences(
    ExternalReferenceRegistry* registry) {
  registry->Register(GetCount);
  registry->Register(GetCountBigInt);
  registry->Register(GetExceeds);
  registry->Register(GetExceedsBigInt);
  registry->Register(GetMin);
  registry->Register(GetMinBigInt);
  registry->Register(GetMax);
  registry->Register(GetMaxBigInt);
  registry->Register(GetMean);
  registry->Register(GetStddev);
  registry->Register(GetPercentile);
  registry->Register(GetPercentileBigInt);
  registry->Register(GetPercentiles);
  registry->Register(GetPercentilesBigInt);
  registry->Register(DoReset);
  registry->Register(Start);
  registry->Register(Stop);
}",403.0,422.0,1.0,1.0,20.0,17,1,34,18,0,0,1,1,0,0,,0,0,2,1,1,void
2327,85108,IntervalHistogram,1,node.IntervalHistogram.IntervalHistogram,"ANY node.IntervalHistogram.IntervalHistogram (Environment*,Local<Object>,ANY,int32_t,ANY,ANY)",histogram.cc,"IntervalHistogram::IntervalHistogram(
    Environment* env,
    Local<Object> wrap,
    AsyncWrap::ProviderType type,
    int32_t interval,
    std::function<void(Histogram&)> on_interval,
    const Histogram::Options& options)
    : HandleWrap(
          env,
          wrap,
          reinterpret_cast<uv_handle_t*>(&timer_),
          type),
      HistogramImpl(options),
      interval_(interval),
      on_interval_(std::move(on_interval)) {
  MakeWeak();
  uv_timer_init(env->event_loop(), &timer_);
}",424.0,441.0,1.0,1.0,18.0,2,2,2,2,0,0,1,1,0,0,,0,0,12,6,6,ANY
2328,85126,Create,1,node.IntervalHistogram.Create,"BaseObjectPtr<IntervalHistogram> node.IntervalHistogram.Create (Environment*,int32_t,ANY,ANY)",histogram.cc,"BaseObjectPtr<IntervalHistogram> IntervalHistogram::Create(
    Environment* env,
    int32_t interval,
    std::function<void(Histogram&)> on_interval,
    const Histogram::Options& options) {
  Local<Object> obj;
  if (!GetConstructorTemplate(env)
          ->InstanceTemplate()
          ->NewInstance(env->context()).ToLocal(&obj)) {
    return BaseObjectPtr<IntervalHistogram>();
  }

  return MakeBaseObject<IntervalHistogram>(
      env,
      obj,
      AsyncWrap::PROVIDER_ELDHISTOGRAM,
      interval,
      std::move(on_interval),
      options);
}",443.0,462.0,1.0,1.0,20.0,14,8,15,11,0,0,2,2,0,0,,0,0,8,4,4,BaseObjectPtr<IntervalHistogram>
2329,85180,TimerCB,1,node.IntervalHistogram.TimerCB,void node.IntervalHistogram.TimerCB (uv_timer_t*),histogram.cc,"void IntervalHistogram::TimerCB(uv_timer_t* handle) {
  IntervalHistogram* histogram =
      ContainerOf(&IntervalHistogram::timer_, handle);

  Histogram* h = histogram->histogram().get();

  histogram->on_interval_(*h);
}",464.0,471.0,1.0,1.0,8.0,8,5,7,4,0,0,1,1,0,0,,0,0,2,1,1,void
2330,85210,MemoryInfo,1,node.IntervalHistogram.MemoryInfo,void node.IntervalHistogram.MemoryInfo (MemoryTracker*),histogram.cc,"void IntervalHistogram::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackField(""histogram"", histogram());
}",473.0,475.0,1.0,1.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,void
2331,85221,OnStart,1,node.IntervalHistogram.OnStart,void node.IntervalHistogram.OnStart (StartFlags),histogram.cc,"void IntervalHistogram::OnStart(StartFlags flags) {
  if (enabled_ || IsHandleClosing()) return;
  enabled_ = true;
  if (flags == StartFlags::RESET)
    histogram()->Reset();
  uv_timer_start(&timer_, TimerCB, interval_, interval_);
  uv_unref(reinterpret_cast<uv_handle_t*>(&timer_));
}",477.0,484.0,1.0,1.0,8.0,8,7,9,6,0,0,3,3,0,0,,0,0,2,1,1,void
2332,85257,OnStop,1,node.IntervalHistogram.OnStop,void node.IntervalHistogram.OnStop (),histogram.cc,"void IntervalHistogram::OnStop() {
  if (!enabled_ || IsHandleClosing()) return;
  enabled_ = false;
  uv_timer_stop(&timer_);
}",486.0,490.0,1.0,1.0,5.0,3,3,2,1,0,0,2,2,0,0,,0,0,0,0,0,void
2333,85272,Start,1,node.IntervalHistogram.Start,void node.IntervalHistogram.Start (FunctionCallbackInfo<Value>),histogram.cc,"void IntervalHistogram::Start(const FunctionCallbackInfo<Value>& args) {
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  histogram->OnStart(args[0]->IsTrue() ? StartFlags::RESET : StartFlags::NONE);
}",492.0,496.0,1.0,1.0,5.0,8,5,6,3,0,0,1,1,0,0,,0,0,2,1,1,void
2334,85302,Stop,1,node.IntervalHistogram.Stop,void node.IntervalHistogram.Stop (FunctionCallbackInfo<Value>),histogram.cc,"void IntervalHistogram::Stop(const FunctionCallbackInfo<Value>& args) {
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  histogram->OnStop();
}",498.0,502.0,1.0,1.0,5.0,3,3,3,2,0,0,1,1,0,0,,0,0,2,1,1,void
2335,85319,GetCount,1,node.IntervalHistogram.GetCount,void node.IntervalHistogram.GetCount (FunctionCallbackInfo<Value>),histogram.cc,"void IntervalHistogram::GetCount(const FunctionCallbackInfo<Value>& args) {
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  double value = static_cast<double>((*histogram)->Count());
  args.GetReturnValue().Set(value);
}",504.0,509.0,1.0,1.0,6.0,8,6,6,3,0,0,1,1,0,0,,0,0,2,1,1,void
2336,85350,GetCountBigInt,1,node.IntervalHistogram.GetCountBigInt,void node.IntervalHistogram.GetCountBigInt (ANY),histogram.cc,"void IntervalHistogram::GetCountBigInt(
    const v8::FunctionCallbackInfo<v8::Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  args.GetReturnValue().Set(
      BigInt::NewFromUnsigned(env->isolate(), (*histogram)->Count()));
}",511.0,518.0,1.0,1.0,8.0,10,5,9,5,0,0,1,1,0,0,,0,0,2,1,1,void
2337,85391,GetMin,1,node.IntervalHistogram.GetMin,void node.IntervalHistogram.GetMin (FunctionCallbackInfo<Value>),histogram.cc,"void IntervalHistogram::GetMin(const FunctionCallbackInfo<Value>& args) {
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  double value = static_cast<double>((*histogram)->Min());
  args.GetReturnValue().Set(value);
}",520.0,525.0,1.0,1.0,6.0,8,6,6,3,0,0,1,1,0,0,,0,0,2,1,1,void
2338,85422,GetMinBigInt,1,node.IntervalHistogram.GetMinBigInt,void node.IntervalHistogram.GetMinBigInt (FunctionCallbackInfo<Value>),histogram.cc,"void IntervalHistogram::GetMinBigInt(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  args.GetReturnValue().Set(BigInt::New(env->isolate(), (*histogram)->Min()));
}",527.0,532.0,1.0,1.0,6.0,10,5,9,5,0,0,1,1,0,0,,0,0,2,1,1,void
2339,85463,GetMax,1,node.IntervalHistogram.GetMax,void node.IntervalHistogram.GetMax (FunctionCallbackInfo<Value>),histogram.cc,"void IntervalHistogram::GetMax(const FunctionCallbackInfo<Value>& args) {
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  double value = static_cast<double>((*histogram)->Max());
  args.GetReturnValue().Set(value);
}",534.0,539.0,1.0,1.0,6.0,8,6,6,3,0,0,1,1,0,0,,0,0,2,1,1,void
2340,85494,GetMaxBigInt,1,node.IntervalHistogram.GetMaxBigInt,void node.IntervalHistogram.GetMaxBigInt (FunctionCallbackInfo<Value>),histogram.cc,"void IntervalHistogram::GetMaxBigInt(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  args.GetReturnValue().Set(BigInt::New(env->isolate(), (*histogram)->Min()));
}",541.0,546.0,1.0,1.0,6.0,10,5,9,5,0,0,1,1,0,0,,0,0,2,1,1,void
2341,85535,GetMean,1,node.IntervalHistogram.GetMean,void node.IntervalHistogram.GetMean (FunctionCallbackInfo<Value>),histogram.cc,"void IntervalHistogram::GetMean(const FunctionCallbackInfo<Value>& args) {
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  args.GetReturnValue().Set((*histogram)->Mean());
}",548.0,552.0,1.0,1.0,5.0,6,4,4,2,0,0,1,1,0,0,,0,0,2,1,1,void
2342,85560,GetExceeds,1,node.IntervalHistogram.GetExceeds,void node.IntervalHistogram.GetExceeds (FunctionCallbackInfo<Value>),histogram.cc,"void IntervalHistogram::GetExceeds(const FunctionCallbackInfo<Value>& args) {
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  double value = static_cast<double>((*histogram)->Exceeds());
  args.GetReturnValue().Set(value);
}",554.0,559.0,1.0,1.0,6.0,8,6,6,3,0,0,1,1,0,0,,0,0,2,1,1,void
2343,85591,GetExceedsBigInt,1,node.IntervalHistogram.GetExceedsBigInt,void node.IntervalHistogram.GetExceedsBigInt (FunctionCallbackInfo<Value>),histogram.cc,"void IntervalHistogram::GetExceedsBigInt(
    const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  args.GetReturnValue().Set(
      BigInt::New(env->isolate(), (*histogram)->Exceeds()));
}",561.0,568.0,1.0,1.0,8.0,10,5,9,5,0,0,1,1,0,0,,0,0,2,1,1,void
2344,85632,GetStddev,1,node.IntervalHistogram.GetStddev,void node.IntervalHistogram.GetStddev (FunctionCallbackInfo<Value>),histogram.cc,"void IntervalHistogram::GetStddev(const FunctionCallbackInfo<Value>& args) {
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  args.GetReturnValue().Set((*histogram)->Stddev());
}",570.0,574.0,1.0,1.0,5.0,6,4,4,2,0,0,1,1,0,0,,0,0,2,1,1,void
2345,85657,GetPercentile,1,node.IntervalHistogram.GetPercentile,void node.IntervalHistogram.GetPercentile (FunctionCallbackInfo<Value>),histogram.cc,"void IntervalHistogram::GetPercentile(const FunctionCallbackInfo<Value>& args) {
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  CHECK(args[0]->IsNumber());
  double percentile = args[0].As<Number>()->Value();
  double value = static_cast<double>((*histogram)->Percentile(percentile));
  args.GetReturnValue().Set(value);
}",576.0,583.0,1.0,1.0,8.0,14,7,10,4,0,0,1,1,0,0,,0,0,2,1,1,void
2346,85708,GetPercentileBigInt,1,node.IntervalHistogram.GetPercentileBigInt,void node.IntervalHistogram.GetPercentileBigInt (FunctionCallbackInfo<Value>),histogram.cc,"void IntervalHistogram::GetPercentileBigInt(
    const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  CHECK(args[0]->IsNumber());
  double percentile = args[0].As<Number>()->Value();
  int64_t value = (*histogram)->Percentile(percentile);
  args.GetReturnValue().Set(BigInt::New(env->isolate(), value));
}",585.0,594.0,1.0,1.0,10.0,17,6,15,7,0,0,1,1,0,0,,0,0,2,1,1,void
2347,85773,GetPercentiles,1,node.IntervalHistogram.GetPercentiles,void node.IntervalHistogram.GetPercentiles (FunctionCallbackInfo<Value>),histogram.cc,"void IntervalHistogram::GetPercentiles(
    const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  CHECK(args[0]->IsMap());
  Local<Map> map = args[0].As<Map>();
  (*histogram)->Percentiles([map, env](double key, int64_t value) {
    USE(map->Set(
          env->context(),
          Number::New(env->isolate(), key),
          Number::New(env->isolate(), static_cast<double>(value))));
  });
}",596.0,609.0,1.0,1.0,14.0,13,8,11,7,0,0,1,1,0,0,,0,0,2,1,1,void
2348,85818,GetPercentilesBigInt,1,node.IntervalHistogram.GetPercentilesBigInt,void node.IntervalHistogram.GetPercentilesBigInt (FunctionCallbackInfo<Value>),histogram.cc,"void IntervalHistogram::GetPercentilesBigInt(
    const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  CHECK(args[0]->IsMap());
  Local<Map> map = args[0].As<Map>();
  (*histogram)->Percentiles([map, env](double key, int64_t value) {
    USE(map->Set(
          env->context(),
          Number::New(env->isolate(), key),
          BigInt::New(env->isolate(), value)));
  });
}",611.0,624.0,1.0,1.0,14.0,13,8,11,7,0,0,1,1,0,0,,0,0,2,1,1,void
2349,85863,DoReset,1,node.IntervalHistogram.DoReset,void node.IntervalHistogram.DoReset (FunctionCallbackInfo<Value>),histogram.cc,"void IntervalHistogram::DoReset(const FunctionCallbackInfo<Value>& args) {
  IntervalHistogram* histogram;
  ASSIGN_OR_RETURN_UNWRAP(&histogram, args.Holder());
  (*histogram)->Reset();
}",626.0,630.0,1.0,1.0,5.0,4,4,3,2,0,0,1,1,0,0,,0,0,2,1,1,void
2350,85881,CloneForMessaging,1,node.IntervalHistogram.CloneForMessaging,unique_ptr<worker::TransferData> node.IntervalHistogram.CloneForMessaging (),histogram.cc,"std::unique_ptr<worker::TransferData>
IntervalHistogram::CloneForMessaging() const {
  return std::make_unique<HistogramBase::HistogramTransferData>(histogram());
}",632.0,635.0,1.0,1.0,4.0,4,3,2,2,0,0,1,1,0,0,,0,0,0,0,0,unique_ptr<worker.TransferData>
2351,85923,<lambda>0,1,node.inspector.anonymous_namespace_37.ThreadSafeDelegate.SendMessageToFrontend.<lambda>0,ANY node.inspector.anonymous_namespace_37.ThreadSafeDelegate.SendMessageToFrontend.<lambda>0 (InspectorSessionDelegate*),inspector\main_thread_interface.cc,"[m = StringBuffer::create(message)]
        (InspectorSessionDelegate* delegate) {
      delegate->SendMessageToFrontend(m->string());
    }",187.0,190.0,9.0,5.0,4.0,2,1,2,2,0,0,1,1,0,0,,0,0,2,1,1,ANY
2352,85938,<lambda>1,1,node.inspector.MainThreadInterface.Post.<lambda>1,ANY node.inspector.MainThreadInterface.Post.<lambda>1 (Environment*),inspector\main_thread_interface.cc,"[weak_self](Environment*) {
      if (auto iface = weak_self.lock()) iface->DispatchMessages();
    }",214.0,216.0,37.0,5.0,3.0,3,3,3,2,0,0,2,2,0,0,,0,0,2,1,1,ANY
2353,85979,DeletableWrapper,1,node.inspector.anonymous_namespace_4.DeletableWrapper.DeletableWrapper,ANY node.inspector.anonymous_namespace_4.DeletableWrapper.DeletableWrapper (ANY),inspector\main_thread_interface.cc,"explicit DeletableWrapper(std::unique_ptr<T> object)
                        : object_(std::move(object)) {}",20.0,21.0,3.0,55.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
2354,85984,~DeletableWrapper,1,node.inspector.anonymous_namespace_5.DeletableWrapper.~DeletableWrapper,ANY node.inspector.anonymous_namespace_5.DeletableWrapper.~DeletableWrapper (),inspector\main_thread_interface.cc,~DeletableWrapper() override = default;,22.0,22.0,3.0,41.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
2355,85988,get,1,node.inspector.anonymous_namespace_6.DeletableWrapper.get,"T node.inspector.anonymous_namespace_6.DeletableWrapper.get (MainThreadInterface*,int)",inspector\main_thread_interface.cc,"static T* get(MainThreadInterface* thread, int id) {
    return
        static_cast<DeletableWrapper<T>*>(thread->GetObject(id))->object_.get();
  }",24.0,27.0,3.0,3.0,4.0,4,3,2,2,0,0,1,1,0,0,,0,0,4,2,2,T
2356,86008,WrapInDeletable,1,node.inspector.anonymous_namespace_7.WrapInDeletable,unique_ptr<Deletable> node.inspector.anonymous_namespace_7.WrapInDeletable<T> (ANY),inspector\main_thread_interface.cc,"std::unique_ptr<Deletable> WrapInDeletable(std::unique_ptr<T> object) {
  return std::unique_ptr<DeletableWrapper<T>>(
      new DeletableWrapper<T>(std::move(object)));
}",34.0,37.0,1.0,1.0,4.0,6,4,6,5,0,0,1,1,0,0,,0,0,2,1,1,unique_ptr<Deletable>
2357,86030,CreateObjectRequest,1,node.inspector.anonymous_namespace_9.CreateObjectRequest.CreateObjectRequest,"ANY node.inspector.anonymous_namespace_9.CreateObjectRequest.CreateObjectRequest (int,Factory)",inspector\main_thread_interface.cc,"CreateObjectRequest(int object_id, Factory factory)
                      : object_id_(object_id), factory_(std::move(factory)) {}",42.0,43.0,3.0,78.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,ANY
2358,86036,Call,1,node.inspector.anonymous_namespace_10.CreateObjectRequest.Call,void node.inspector.anonymous_namespace_10.CreateObjectRequest.Call (MainThreadInterface*),inspector\main_thread_interface.cc,"void Call(MainThreadInterface* thread) override {
    thread->AddObject(object_id_, WrapInDeletable(factory_(thread)));
  }",45.0,47.0,3.0,3.0,3.0,1,1,3,2,0,1,1,1,0,0,,0,1,2,1,1,void
2359,86051,NewCreateRequest,1,node.inspector.anonymous_namespace_11.NewCreateRequest,"unique_ptr<Request> node.inspector.anonymous_namespace_11.NewCreateRequest<Factory> (int,Factory)",inspector\main_thread_interface.cc,"std::unique_ptr<Request> NewCreateRequest(int object_id, Factory factory) {
  return std::unique_ptr<Request>(
      new CreateObjectRequest<Factory>(object_id, std::move(factory)));
}",55.0,58.0,1.0,1.0,4.0,5,4,6,5,0,0,1,1,0,0,,0,0,4,2,2,unique_ptr<Request>
2360,86073,DeleteRequest,1,node.inspector.anonymous_namespace_13.DeleteRequest.DeleteRequest,ANY node.inspector.anonymous_namespace_13.DeleteRequest.DeleteRequest (int),inspector\main_thread_interface.cc,explicit DeleteRequest(int object_id) : object_id_(object_id) {},62.0,62.0,3.0,66.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
2361,86078,Call,1,node.inspector.anonymous_namespace_14.DeleteRequest.Call,void node.inspector.anonymous_namespace_14.DeleteRequest.Call (MainThreadInterface*),inspector\main_thread_interface.cc,"void Call(MainThreadInterface* thread) override {
    thread->RemoveObject(object_id_);
  }",64.0,66.0,3.0,3.0,3.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
2362,86090,CallRequest,1,node.inspector.anonymous_namespace_16.CallRequest.CallRequest,"ANY node.inspector.anonymous_namespace_16.CallRequest.CallRequest (int,Fn)",inspector\main_thread_interface.cc,"CallRequest(int id, Fn fn) : id_(id), fn_(std::move(fn)) {}",75.0,75.0,3.0,61.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,ANY
2363,86096,Call,1,node.inspector.anonymous_namespace_17.CallRequest.Call,void node.inspector.anonymous_namespace_17.CallRequest.Call (MainThreadInterface*),inspector\main_thread_interface.cc,"void Call(MainThreadInterface* thread) override {
    fn_(DeletableWrapper<Target>::get(thread, id_));
  }",77.0,79.0,3.0,3.0,3.0,1,1,3,3,0,1,1,1,0,0,,0,1,2,1,1,void
2364,86111,AnotherThreadObjectReference,1,node.inspector.anonymous_namespace_19.AnotherThreadObjectReference.AnotherThreadObjectReference,"ANY node.inspector.anonymous_namespace_19.AnotherThreadObjectReference.AnotherThreadObjectReference (ANY,int)",inspector\main_thread_interface.cc,"AnotherThreadObjectReference(
      std::shared_ptr<MainThreadHandle> thread, int object_id)
      : thread_(thread), object_id_(object_id) {}",89.0,91.0,3.0,49.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,ANY
2365,86117,AnotherThreadObjectReference,1,node.inspector.anonymous_namespace_20.AnotherThreadObjectReference.AnotherThreadObjectReference,"ANY node.inspector.anonymous_namespace_20.AnotherThreadObjectReference.AnotherThreadObjectReference<Factory> (ANY,Factory)",inspector\main_thread_interface.cc,"AnotherThreadObjectReference(
      std::shared_ptr<MainThreadHandle> thread, Factory factory)
      : AnotherThreadObjectReference(thread, thread->newObjectId()) {
    thread_->Post(NewCreateRequest(object_id_, std::move(factory)));
  }",94.0,98.0,3.0,3.0,5.0,2,2,4,4,0,2,1,1,0,0,,0,2,4,2,2,ANY
2366,86134,AnotherThreadObjectReference,1,node.inspector.anonymous_namespace_21.AnotherThreadObjectReference.AnotherThreadObjectReference,ANY node.inspector.anonymous_namespace_21.AnotherThreadObjectReference.AnotherThreadObjectReference (AnotherThreadObjectReference),inspector\main_thread_interface.cc,AnotherThreadObjectReference(AnotherThreadObjectReference&) = delete;,99.0,99.0,3.0,71.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
2367,86139,~AnotherThreadObjectReference,1,node.inspector.anonymous_namespace_22.AnotherThreadObjectReference.~AnotherThreadObjectReference,ANY node.inspector.anonymous_namespace_22.AnotherThreadObjectReference.~AnotherThreadObjectReference (),inspector\main_thread_interface.cc,"~AnotherThreadObjectReference() {
    // Disappearing thread may cause a memory leak
    thread_->Post(std::make_unique<DeleteRequest>(object_id_));
  }",101.0,104.0,3.0,3.0,4.0,4,4,4,4,0,2,1,1,0,0,,0,2,0,0,0,ANY
2368,86154,Call,1,node.inspector.anonymous_namespace_23.AnotherThreadObjectReference.Call,void node.inspector.anonymous_namespace_23.AnotherThreadObjectReference.Call<Fn> (Fn),inspector\main_thread_interface.cc,"void Call(Fn fn) const {
    using Request = CallRequest<T, Fn>;
    thread_->Post(std::unique_ptr<Request>(
        new Request(object_id_, std::move(fn))));
  }",107.0,111.0,3.0,3.0,5.0,6,5,7,5,0,2,1,1,0,0,,0,2,2,1,1,void
2369,86178,Call,1,node.inspector.anonymous_namespace_24.AnotherThreadObjectReference.Call,"void node.inspector.anonymous_namespace_24.AnotherThreadObjectReference.Call<Arg> (void,Arg)",inspector\main_thread_interface.cc,"void Call(void (T::*fn)(Arg), Arg argument) const {
    Call(std::bind(Apply<Arg>, std::placeholders::_1, fn, std::move(argument)));
  }",114.0,116.0,3.0,3.0,3.0,4,1,7,5,0,0,1,1,0,0,,0,0,4,2,2,void
2370,86201,Apply,1,node.inspector.anonymous_namespace_25.AnotherThreadObjectReference.Apply,"void node.inspector.anonymous_namespace_25.AnotherThreadObjectReference.Apply<Argument> (T*,void,Argument)",inspector\main_thread_interface.cc,"static void Apply(T* target, void (T::*fn)(Argument),
    /* NOLINT (runtime/references) */ Argument& argument) {
    (target->*fn)(std::move(argument));
  }",122.0,125.0,3.0,3.0,4.0,2,2,4,4,0,0,1,1,0,0,,0,0,6,3,3,void
2371,86220,MainThreadSessionState,1,node.inspector.anonymous_namespace_27.MainThreadSessionState.MainThreadSessionState,"ANY node.inspector.anonymous_namespace_27.MainThreadSessionState.MainThreadSessionState (MainThreadInterface*,bool)",inspector\main_thread_interface.cc,"MainThreadSessionState(MainThreadInterface* thread, bool prevent_shutdown)
                         : thread_(thread),
                           prevent_shutdown_(prevent_shutdown) {}",133.0,135.0,3.0,65.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,ANY
2372,86226,Create,1,node.inspector.anonymous_namespace_28.MainThreadSessionState.Create,"unique_ptr<MainThreadSessionState> node.inspector.anonymous_namespace_28.MainThreadSessionState.Create (MainThreadInterface*,bool)",inspector\main_thread_interface.cc,"static std::unique_ptr<MainThreadSessionState> Create(
      MainThreadInterface* thread, bool prevent_shutdown) {
    return std::make_unique<MainThreadSessionState>(thread, prevent_shutdown);
  }",137.0,140.0,3.0,3.0,4.0,5,5,4,4,0,0,1,1,0,0,,0,0,4,2,2,unique_ptr<MainThreadSessionState>
2373,86243,Connect,1,node.inspector.anonymous_namespace_29.MainThreadSessionState.Connect,void node.inspector.anonymous_namespace_29.MainThreadSessionState.Connect (ANY),inspector\main_thread_interface.cc,"void Connect(std::unique_ptr<InspectorSessionDelegate> delegate) {
    Agent* agent = thread_->inspector_agent();
    if (agent != nullptr)
      session_ = agent->Connect(std::move(delegate), prevent_shutdown_);
  }",142.0,146.0,3.0,3.0,5.0,6,4,8,6,0,3,2,2,0,0,,0,3,2,1,1,void
2374,86272,Dispatch,1,node.inspector.anonymous_namespace_30.MainThreadSessionState.Dispatch,void node.inspector.anonymous_namespace_30.MainThreadSessionState.Dispatch (ANY),inspector\main_thread_interface.cc,"void Dispatch(std::unique_ptr<StringBuffer> message) {
    session_->Dispatch(message->string());
  }",148.0,150.0,3.0,3.0,3.0,2,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
2375,86289,CrossThreadInspectorSession,1,node.inspector.anonymous_namespace_32.CrossThreadInspectorSession.CrossThreadInspectorSession,"ANY node.inspector.anonymous_namespace_32.CrossThreadInspectorSession.CrossThreadInspectorSession (int,ANY,ANY,bool)",inspector\main_thread_interface.cc,"CrossThreadInspectorSession(
      int id,
      std::shared_ptr<MainThreadHandle> thread,
      std::unique_ptr<InspectorSessionDelegate> delegate,
      bool prevent_shutdown)
      : state_(thread, std::bind(MainThreadSessionState::Create,
                                 std::placeholders::_1,
                                 prevent_shutdown)) {
    state_.Call(&MainThreadSessionState::Connect, std::move(delegate));
  }",160.0,169.0,3.0,3.0,10.0,4,2,4,4,0,1,1,1,0,0,,0,1,8,4,4,ANY
2376,86310,Dispatch,1,node.inspector.anonymous_namespace_33.CrossThreadInspectorSession.Dispatch,void node.inspector.anonymous_namespace_33.CrossThreadInspectorSession.Dispatch (StringView),inspector\main_thread_interface.cc,"void Dispatch(const StringView& message) override {
    state_.Call(&MainThreadSessionState::Dispatch,
                StringBuffer::create(message));
  }",171.0,174.0,3.0,3.0,4.0,4,2,4,4,0,1,1,1,0,0,,0,1,2,1,1,void
2377,86329,ThreadSafeDelegate,1,node.inspector.anonymous_namespace_35.ThreadSafeDelegate.ThreadSafeDelegate,"ANY node.inspector.anonymous_namespace_35.ThreadSafeDelegate.ThreadSafeDelegate (ANY,int)",inspector\main_thread_interface.cc,"ThreadSafeDelegate(std::shared_ptr<MainThreadHandle> thread, int object_id)
                     : thread_(thread), delegate_(thread, object_id) {}",182.0,183.0,3.0,71.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,ANY
2378,86335,SendMessageToFrontend,1,node.inspector.anonymous_namespace_36.ThreadSafeDelegate.SendMessageToFrontend,void node.inspector.anonymous_namespace_36.ThreadSafeDelegate.SendMessageToFrontend (ANY),inspector\main_thread_interface.cc,"void SendMessageToFrontend(const v8_inspector::StringView& message) override {
    delegate_.Call(
        [m = StringBuffer::create(message)]
        (InspectorSessionDelegate* delegate) {
      delegate->SendMessageToFrontend(m->string());
    });
  }",185.0,191.0,3.0,3.0,7.0,1,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,void
2379,86347,MainThreadInterface,1,node.inspector.MainThreadInterface.MainThreadInterface,ANY node.inspector.MainThreadInterface.MainThreadInterface (Agent*),inspector\main_thread_interface.cc,MainThreadInterface::MainThreadInterface(Agent* agent) : agent_(agent) {},200.0,200.0,1.0,73.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
2380,86352,~MainThreadInterface,1,node.inspector.MainThreadInterface.~MainThreadInterface,ANY node.inspector.MainThreadInterface.~MainThreadInterface (),inspector\main_thread_interface.cc,"MainThreadInterface::~MainThreadInterface() {
  if (handle_)
    handle_->Reset();
}",202.0,205.0,1.0,1.0,4.0,1,1,2,1,0,2,2,2,1,0,,0,2,0,0,0,ANY
2381,86363,Post,1,node.inspector.MainThreadInterface.Post,void node.inspector.MainThreadInterface.Post (ANY),inspector\main_thread_interface.cc,"void MainThreadInterface::Post(std::unique_ptr<Request> request) {
  CHECK_NOT_NULL(agent_);
  Mutex::ScopedLock scoped_lock(requests_lock_);
  bool needs_notify = requests_.empty();
  requests_.push_back(std::move(request));
  if (needs_notify) {
    std::weak_ptr<MainThreadInterface> weak_self {shared_from_this()};
    agent_->env()->RequestInterrupt([weak_self](Environment*) {
      if (auto iface = weak_self.lock()) iface->DispatchMessages();
    });
  }
  incoming_message_cond_.Broadcast(scoped_lock);
}",207.0,219.0,1.0,1.0,13.0,9,4,12,9,0,6,2,2,0,0,,0,6,2,1,1,void
2382,86409,WaitForFrontendEvent,1,node.inspector.MainThreadInterface.WaitForFrontendEvent,bool node.inspector.MainThreadInterface.WaitForFrontendEvent (),inspector\main_thread_interface.cc,"bool MainThreadInterface::WaitForFrontendEvent() {
  // We allow DispatchMessages reentry as we enter the pause. This is important
  // to support debugging the code invoked by an inspector call, such
  // as Runtime.evaluate
  dispatching_messages_ = false;
  if (dispatching_message_queue_.empty()) {
    Mutex::ScopedLock scoped_lock(requests_lock_);
    while (requests_.empty()) incoming_message_cond_.Wait(scoped_lock);
  }
  return true;
}",221.0,231.0,1.0,1.0,11.0,3,2,4,4,0,4,3,4,2,0,,0,4,0,0,0,bool
2383,86437,DispatchMessages,1,node.inspector.MainThreadInterface.DispatchMessages,void node.inspector.MainThreadInterface.DispatchMessages (),inspector\main_thread_interface.cc,"void MainThreadInterface::DispatchMessages() {
  if (dispatching_messages_)
    return;
  dispatching_messages_ = true;
  bool had_messages = false;
  do {
    if (dispatching_message_queue_.empty()) {
      Mutex::ScopedLock scoped_lock(requests_lock_);
      requests_.swap(dispatching_message_queue_);
    }
    had_messages = !dispatching_message_queue_.empty();
    while (!dispatching_message_queue_.empty()) {
      MessageQueue::value_type task;
      std::swap(dispatching_message_queue_.front(), task);
      dispatching_message_queue_.pop_front();

      v8::SealHandleScope seal_handle_scope(agent_->env()->isolate());
      task->Call(this);
    }
  } while (had_messages);
  dispatching_messages_ = false;
}",233.0,254.0,1.0,1.0,22.0,16,4,18,8,0,12,5,7,3,0,,0,12,0,0,0,void
2384,86514,GetHandle,1,node.inspector.MainThreadInterface.GetHandle,shared_ptr<MainThreadHandle> node.inspector.MainThreadInterface.GetHandle (),inspector\main_thread_interface.cc,"std::shared_ptr<MainThreadHandle> MainThreadInterface::GetHandle() {
  if (handle_ == nullptr)
    handle_ = std::make_shared<MainThreadHandle>(this);
  return handle_;
}",256.0,260.0,1.0,1.0,5.0,5,5,5,3,0,3,2,2,1,0,,0,3,0,0,0,shared_ptr<MainThreadHandle>
2385,86534,AddObject,1,node.inspector.MainThreadInterface.AddObject,"void node.inspector.MainThreadInterface.AddObject (int,ANY)",inspector\main_thread_interface.cc,"void MainThreadInterface::AddObject(int id,
                                    std::unique_ptr<Deletable> object) {
  CHECK_NOT_NULL(object);
  managed_objects_[id] = std::move(object);
}",262.0,266.0,1.0,1.0,5.0,3,3,5,4,0,1,1,1,0,0,,0,1,4,2,2,void
2386,86551,RemoveObject,1,node.inspector.MainThreadInterface.RemoveObject,void node.inspector.MainThreadInterface.RemoveObject (int),inspector\main_thread_interface.cc,"void MainThreadInterface::RemoveObject(int id) {
  CHECK_EQ(1, managed_objects_.erase(id));
}",268.0,270.0,1.0,1.0,3.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
2387,86563,GetObject,1,node.inspector.MainThreadInterface.GetObject,Deletable node.inspector.MainThreadInterface.GetObject (int),inspector\main_thread_interface.cc,"Deletable* MainThreadInterface::GetObject(int id) {
  Deletable* pointer = GetObjectIfExists(id);
  // This would mean the object is requested after it was disposed, which is
  // a coding error.
  CHECK_NOT_NULL(pointer);
  return pointer;
}",272.0,278.0,1.0,1.0,7.0,1,1,4,2,0,0,1,1,0,0,,0,0,2,1,1,Deletable
2388,86577,GetObjectIfExists,1,node.inspector.MainThreadInterface.GetObjectIfExists,Deletable node.inspector.MainThreadInterface.GetObjectIfExists (int),inspector\main_thread_interface.cc,"Deletable* MainThreadInterface::GetObjectIfExists(int id) {
  auto iterator = managed_objects_.find(id);
  if (iterator == managed_objects_.end()) {
    return nullptr;
  }
  return iterator->second.get();
}",280.0,286.0,1.0,1.0,7.0,6,4,6,3,0,2,2,2,1,0,,0,2,2,1,1,Deletable
2389,86607,Utf8ToStringView,1,node.inspector.Utf8ToStringView,unique_ptr<StringBuffer> node.inspector.Utf8ToStringView (ANY),inspector\main_thread_interface.cc,"std::unique_ptr<StringBuffer> Utf8ToStringView(const std::string_view message) {
  size_t expected_u16_length =
      simdutf::utf16_length_from_utf8(message.data(), message.length());
  MaybeStackBuffer<char16_t> buffer(expected_u16_length);
  size_t utf16_length = simdutf::convert_utf8_to_utf16(
      message.data(), message.length(), buffer.out());
  StringView view(reinterpret_cast<uint16_t*>(buffer.out()), utf16_length);
  return StringBuffer::create(view);
}",288.0,296.0,1.0,1.0,9.0,12,3,14,7,0,0,1,1,0,0,,0,0,2,1,1,unique_ptr<StringBuffer>
2390,86664,Connect,1,node.inspector.MainThreadHandle.Connect,"unique_ptr<InspectorSession> node.inspector.MainThreadHandle.Connect (ANY,bool)",inspector\main_thread_interface.cc,"std::unique_ptr<InspectorSession> MainThreadHandle::Connect(
    std::unique_ptr<InspectorSessionDelegate> delegate,
    bool prevent_shutdown) {
  return std::unique_ptr<InspectorSession>(
      new CrossThreadInspectorSession(++next_session_id_,
                                      shared_from_this(),
                                      std::move(delegate),
                                      prevent_shutdown));
}",298.0,306.0,1.0,1.0,9.0,6,5,7,6,0,1,1,1,0,0,,0,1,4,2,2,unique_ptr<InspectorSession>
2391,86688,Post,1,node.inspector.MainThreadHandle.Post,bool node.inspector.MainThreadHandle.Post (ANY),inspector\main_thread_interface.cc,"bool MainThreadHandle::Post(std::unique_ptr<Request> request) {
  Mutex::ScopedLock scoped_lock(block_lock_);
  if (!main_thread_)
    return false;
  main_thread_->Post(std::move(request));
  return true;
}",308.0,314.0,1.0,1.0,7.0,3,3,5,4,0,3,2,2,1,0,,0,3,2,1,1,bool
2392,86713,Reset,1,node.inspector.MainThreadHandle.Reset,void node.inspector.MainThreadHandle.Reset (),inspector\main_thread_interface.cc,"void MainThreadHandle::Reset() {
  Mutex::ScopedLock scoped_lock(block_lock_);
  main_thread_ = nullptr;
}",316.0,319.0,1.0,1.0,4.0,1,1,2,2,0,2,1,1,0,0,,0,2,0,0,0,void
2393,86723,MakeDelegateThreadSafe,1,node.inspector.MainThreadHandle.MakeDelegateThreadSafe,unique_ptr<InspectorSessionDelegate> node.inspector.MainThreadHandle.MakeDelegateThreadSafe (ANY),inspector\main_thread_interface.cc,"std::unique_ptr<InspectorSessionDelegate>
MainThreadHandle::MakeDelegateThreadSafe(
    std::unique_ptr<InspectorSessionDelegate> delegate) {
  int id = newObjectId();
  main_thread_->AddObject(id, WrapInDeletable(std::move(delegate)));
  return std::unique_ptr<InspectorSessionDelegate>(
      new ThreadSafeDelegate(shared_from_this(), id));
}",321.0,328.0,1.0,1.0,8.0,7,6,9,6,0,1,1,1,0,0,,0,1,2,1,1,unique_ptr<InspectorSessionDelegate>
2394,86754,Expired,1,node.inspector.MainThreadHandle.Expired,bool node.inspector.MainThreadHandle.Expired (),inspector\main_thread_interface.cc,"bool MainThreadHandle::Expired() {
  Mutex::ScopedLock scoped_lock(block_lock_);
  return main_thread_ == nullptr;
}",330.0,333.0,1.0,1.0,4.0,1,1,2,2,0,2,1,1,0,0,,0,2,0,0,0,bool
2395,86789,Call,1,node.inspector.Request.Call,void node.inspector.Request.Call (MainThreadInterface*),inspector\main_thread_interface.hpp,virtual void Call(MainThreadInterface*) = 0;,27.0,27.0,16.0,45.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
2396,86794,~Request,1,node.inspector.Request.~Request,ANY node.inspector.Request.~Request (),inspector\main_thread_interface.hpp,virtual ~Request() = default;,28.0,28.0,3.0,31.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
2397,86799,~Deletable,1,node.inspector.Deletable.~Deletable,ANY node.inspector.Deletable.~Deletable (),inspector\main_thread_interface.hpp,virtual ~Deletable() = default;,33.0,33.0,3.0,33.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
2398,86810,MainThreadHandle,1,node.inspector.MainThreadHandle.MainThreadHandle,ANY node.inspector.MainThreadHandle.MainThreadHandle (MainThreadInterface*),inspector\main_thread_interface.hpp,"explicit MainThreadHandle(MainThreadInterface* main_thread)
                            : main_thread_(main_thread) {
  }",43.0,45.0,3.0,3.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
2399,86815,~MainThreadHandle,1,node.inspector.MainThreadHandle.~MainThreadHandle,ANY node.inspector.MainThreadHandle.~MainThreadHandle (),inspector\main_thread_interface.hpp,"~MainThreadHandle() {
    Mutex::ScopedLock scoped_lock(block_lock_);
    CHECK_NULL(main_thread_);  // main_thread_ should have called Reset
  }",46.0,49.0,3.0,3.0,4.0,0,0,2,2,0,2,1,1,0,0,,0,2,0,0,0,ANY
2400,86830,newObjectId,1,node.inspector.MainThreadHandle.newObjectId,int node.inspector.MainThreadHandle.newObjectId (),inspector\main_thread_interface.hpp,"int newObjectId() {
    return ++next_object_id_;
  }",53.0,55.0,3.0,3.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,int
2401,86898,inspector_agent,1,node.inspector.MainThreadInterface.inspector_agent,Agent node.inspector.MainThreadInterface.inspector_agent (),inspector\main_thread_interface.hpp,"Agent* inspector_agent() {
    return agent_;
  }",82.0,84.0,3.0,3.0,3.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,Agent
2402,86967,builderAppendQuotedString,1,node.inspector.protocol.StringUtil.builderAppendQuotedString,"void node.inspector.protocol.StringUtil.builderAppendQuotedString (StringBuilder,ANY)",inspector\node_string.cc,"void builderAppendQuotedString(StringBuilder& builder,
                               const std::string_view string) {
  builder.put('""');
  if (!string.empty()) {
    size_t expected_utf16_length =
        simdutf::utf16_length_from_utf8(string.data(), string.length());
    MaybeStackBuffer<char16_t> buffer(expected_utf16_length);
    // simdutf::convert_utf8_to_utf16 returns zero in case of error.
    size_t utf16_length = simdutf::convert_utf8_to_utf16(
        string.data(), string.length(), buffer.out());
    // We have that utf16_length == expected_utf16_length if and only
    // if the input was a valid UTF-8 string.
    if (utf16_length != 0) {
      CHECK_EQ(expected_utf16_length, utf16_length);
      escapeWideStringForJSON(reinterpret_cast<const uint16_t*>(buffer.out()),
                              utf16_length,
                              &builder);
    }  // Otherwise, we had an invalid UTF-8 input.
  }
  builder.put('""');
}",15.0,35.0,1.0,1.0,21.0,17,6,19,6,0,0,3,4,0,0,,0,0,4,2,2,void
2403,87045,parseJSON,1,node.inspector.protocol.StringUtil.parseJSON,unique_ptr<Value> node.inspector.protocol.StringUtil.parseJSON (ANY),inspector\node_string.cc,"std::unique_ptr<Value> parseJSON(v8_inspector::StringView string) {
  if (string.length() == 0)
    return nullptr;
  if (string.is8Bit())
    return parseJSONCharacters(string.characters8(), string.length());
  return parseJSONCharacters(string.characters16(), string.length());
}",54.0,60.0,1.0,1.0,7.0,13,4,16,5,0,0,3,3,0,0,,0,0,2,1,1,unique_ptr<Value>
2404,87155,StringViewToUtf8,1,node.inspector.protocol.StringUtil.StringViewToUtf8,String node.inspector.protocol.StringUtil.StringViewToUtf8 (ANY),inspector\node_string.cc,"String StringViewToUtf8(v8_inspector::StringView view) {
  if (view.length() == 0)
    return """";
  if (view.is8Bit()) {
    return std::string(reinterpret_cast<const char*>(view.characters8()),
                       view.length());
  }
  const char16_t* source =
      reinterpret_cast<const char16_t*>(view.characters16());
  size_t expected_utf8_length =
      simdutf::utf8_length_from_utf16(source, view.length());
  MaybeStackBuffer<char> buffer(expected_utf8_length);
  // convert_utf16_to_utf8 returns zero in case of error.
  size_t utf8_length =
      simdutf::convert_utf16_to_utf8(source, view.length(), buffer.out());
  // We have that utf8_length == expected_utf8_length if and only
  // if the input was a valid UTF-16 string. Otherwise, utf8_length
  // must be zero.
  CHECK(utf8_length == 0 || utf8_length == expected_utf8_length);
  // An invalid UTF-16 input will generate the empty string:
  return String(buffer.out(), utf8_length);
}",62.0,83.0,1.0,1.0,22.0,21,5,22,7,0,0,3,3,0,0,,0,0,2,1,1,String
2405,87246,fromDouble,1,node.inspector.protocol.StringUtil.fromDouble,String node.inspector.protocol.StringUtil.fromDouble (double),inspector\node_string.cc,"String fromDouble(double d) {
  std::ostringstream stream;
  stream.imbue(std::locale::classic());  // Ignore current locale
  stream << d;
  return stream.str();
}",85.0,90.0,1.0,1.0,6.0,5,2,6,4,0,0,1,1,0,0,,0,0,2,1,1,String
2406,87270,toDouble,1,node.inspector.protocol.StringUtil.toDouble,"double node.inspector.protocol.StringUtil.toDouble (char*,size_t,bool*)",inspector\node_string.cc,"double toDouble(const char* buffer, size_t length, bool* ok) {
  std::istringstream stream(std::string(buffer, length));
  stream.imbue(std::locale::classic());  // Ignore current locale
  double d;
  stream >> d;
  *ok = !stream.fail();
  return d;
}",92.0,99.0,1.0,1.0,8.0,9,5,11,7,0,0,1,1,0,0,,0,0,6,3,3,double
2407,87309,parseMessage,1,node.inspector.protocol.StringUtil.parseMessage,"unique_ptr<Value> node.inspector.protocol.StringUtil.parseMessage (ANY,bool)",inspector\node_string.cc,"std::unique_ptr<Value> parseMessage(const std::string_view message,
                                    bool binary) {
  if (binary) {
    return Value::parseBinary(
        reinterpret_cast<const uint8_t*>(message.data()),
        message.length());
  }
  return parseJSON(message);
}",101.0,109.0,1.0,1.0,9.0,4,2,5,3,0,0,2,2,0,0,,0,0,4,2,2,unique_ptr<Value>
2408,87336,jsonToMessage,1,node.inspector.protocol.StringUtil.jsonToMessage,ProtocolMessage node.inspector.protocol.StringUtil.jsonToMessage (String),inspector\node_string.cc,"ProtocolMessage jsonToMessage(String message) {
  return message;
}",111.0,113.0,1.0,1.0,3.0,0,0,1,1,0,0,1,1,0,0,,0,0,2,1,1,ProtocolMessage
2409,87343,binaryToMessage,1,node.inspector.protocol.StringUtil.binaryToMessage,ProtocolMessage node.inspector.protocol.StringUtil.binaryToMessage (ANY),inspector\node_string.cc,"ProtocolMessage binaryToMessage(std::vector<uint8_t> message) {
  return std::string(reinterpret_cast<const char*>(message.data()),
                     message.size());
}",115.0,118.0,1.0,1.0,4.0,4,2,3,2,0,0,1,1,0,0,,0,0,2,1,1,ProtocolMessage
2410,87363,fromUTF8,1,node.inspector.protocol.StringUtil.fromUTF8,"String node.inspector.protocol.StringUtil.fromUTF8 (uint8_t*,size_t)",inspector\node_string.cc,"String fromUTF8(const uint8_t* data, size_t length) {
  return std::string(reinterpret_cast<const char*>(data), length);
}",120.0,122.0,1.0,1.0,3.0,2,2,3,3,0,0,1,1,0,0,,0,0,4,2,2,String
2411,87378,fromUTF16,1,node.inspector.protocol.StringUtil.fromUTF16,"String node.inspector.protocol.StringUtil.fromUTF16 (uint16_t*,size_t)",inspector\node_string.cc,"String fromUTF16(const uint16_t* data, size_t length) {
  auto casted_data = reinterpret_cast<const char16_t*>(data);
  size_t expected_utf8_length =
      simdutf::utf8_length_from_utf16(casted_data, length);
  MaybeStackBuffer<char> buffer(expected_utf8_length);
  // simdutf::convert_utf16_to_utf8 returns zero in case of error.
  size_t utf8_length =
      simdutf::convert_utf16_to_utf8(casted_data, length, buffer.out());
  // We have that utf8_length == expected_utf8_length if and only
  // if the input was a valid UTF-16 string. Otherwise, utf8_length
  // must be zero.
  CHECK(utf8_length == 0 || utf8_length == expected_utf8_length);
  // An invalid UTF-16 input will generate the empty string:
  return String(buffer.out(), utf8_length);
}",124.0,138.0,1.0,1.0,15.0,11,5,17,7,0,0,1,1,0,0,,0,0,4,2,2,String
2412,87430,CharactersUTF8,1,node.inspector.protocol.StringUtil.CharactersUTF8,uint8_t node.inspector.protocol.StringUtil.CharactersUTF8 (ANY),inspector\node_string.cc,"const uint8_t* CharactersUTF8(const std::string_view s) {
  return reinterpret_cast<const uint8_t*>(s.data());
}",140.0,142.0,1.0,1.0,3.0,2,2,1,1,0,0,1,1,0,0,,0,0,2,1,1,uint8_t
2413,87442,CharacterCount,1,node.inspector.protocol.StringUtil.CharacterCount,size_t node.inspector.protocol.StringUtil.CharacterCount (ANY),inspector\node_string.cc,"size_t CharacterCount(const std::string_view s) {
  // The utf32_length_from_utf8 function calls count_utf8.
  // The count_utf8 function counts the number of code points
  // (characters) in the string, assuming that the string is valid Unicode.
  // TODO(@anonrig): Test to make sure CharacterCount returns correctly.
  return simdutf::utf32_length_from_utf8(s.data(), s.length());
}",144.0,150.0,1.0,1.0,7.0,3,1,3,2,0,0,1,1,0,0,,0,0,2,1,1,size_t
2414,87483,builderAppend,1,node.inspector.protocol.StringUtil.builderAppend,"void node.inspector.protocol.StringUtil.builderAppend (StringBuilder,char)",inspector\node_string.hpp,"inline void builderAppend(StringBuilder& builder, const String& string) {
  builder << string;
}",41.0,43.0,1.0,1.0,3.0,1,1,2,2,0,0,1,1,0,0,,0,0,4,2,2,void
2415,87530,builderReserve,1,node.inspector.protocol.StringUtil.builderReserve,"void node.inspector.protocol.StringUtil.builderReserve (StringBuilder,size_t)",inspector\node_string.hpp,"inline void builderReserve(StringBuilder& builder, size_t) {
  // ostringstream does not have a counterpart
}",46.0,48.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
2416,87536,substring,1,node.inspector.protocol.StringUtil.substring,"String node.inspector.protocol.StringUtil.substring (String,size_t,size_t)",inspector\node_string.hpp,"inline String substring(const String& string, size_t start, size_t count) {
  return string.substr(start, count);
}",49.0,51.0,1.0,1.0,3.0,1,1,3,3,0,0,1,1,0,0,,0,0,6,3,3,String
2417,87550,fromInteger,1,node.inspector.protocol.StringUtil.fromInteger,String node.inspector.protocol.StringUtil.fromInteger (int),inspector\node_string.hpp,"inline String fromInteger(int n) {
  return std::to_string(n);
}",52.0,54.0,1.0,1.0,3.0,1,1,2,2,0,0,1,1,0,0,,0,0,2,1,1,String
2418,87561,builderToString,1,node.inspector.protocol.StringUtil.builderToString,String node.inspector.protocol.StringUtil.builderToString (StringBuilder),inspector\node_string.hpp,"inline String builderToString(const StringBuilder& builder) {
  return builder.str();
}",55.0,57.0,1.0,1.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,String
2419,87571,find,1,node.inspector.protocol.StringUtil.find,"size_t node.inspector.protocol.StringUtil.find (String,char*)",inspector\node_string.hpp,"inline size_t find(const String& string, const char* substring) {
  return string.find(substring);
}",58.0,60.0,1.0,1.0,3.0,1,1,2,2,0,0,1,1,0,0,,0,0,4,2,2,size_t
2420,87649,CharactersLatin1,1,node.inspector.protocol.StringUtil.CharactersLatin1,uint8_t node.inspector.protocol.StringUtil.CharactersLatin1 (ANY),inspector\node_string.hpp,"inline uint8_t* CharactersLatin1(const std::string_view s) {
  return nullptr;
}",81.0,83.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,uint8_t
2421,87656,CharactersUTF16,1,node.inspector.protocol.StringUtil.CharactersUTF16,uint16_t node.inspector.protocol.StringUtil.CharactersUTF16 (ANY),inspector\node_string.hpp,"inline const uint16_t* CharactersUTF16(const std::string_view s) {
  return nullptr;
}",84.0,86.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,uint16_t
2422,87665,data,1,node.inspector.protocol.Binary.data,uint8_t node.inspector.protocol.Binary.data (),inspector\node_string.hpp,const uint8_t* data() const { UNREACHABLE(); },97.0,97.0,3.0,48.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,uint8_t
2423,87670,size,1,node.inspector.protocol.Binary.size,size_t node.inspector.protocol.Binary.size (),inspector\node_string.hpp,size_t size() const { UNREACHABLE(); },98.0,98.0,3.0,40.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,size_t
2424,87675,toBase64,1,node.inspector.protocol.Binary.toBase64,String node.inspector.protocol.Binary.toBase64 (),inspector\node_string.hpp,String toBase64() const { UNREACHABLE(); },99.0,99.0,3.0,44.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,String
2425,87680,fromBase64,1,node.inspector.protocol.Binary.fromBase64,"Binary node.inspector.protocol.Binary.fromBase64 (ANY,bool*)",inspector\node_string.hpp,"static Binary fromBase64(const std::string_view base64, bool* success) {
    UNREACHABLE();
  }",100.0,102.0,3.0,3.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,Binary
2426,87687,fromSpan,1,node.inspector.protocol.Binary.fromSpan,"Binary node.inspector.protocol.Binary.fromSpan (uint8_t*,size_t)",inspector\node_string.hpp,"static Binary fromSpan(const uint8_t* data, size_t size) { UNREACHABLE(); }",103.0,103.0,3.0,77.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,Binary
2427,87708,RuntimeAgent,1,node.inspector.protocol.RuntimeAgent.RuntimeAgent,ANY node.inspector.protocol.RuntimeAgent.RuntimeAgent (),inspector\runtime_agent.cc,"RuntimeAgent::RuntimeAgent()
  : notify_when_waiting_for_disconnect_(false) {}",10.0,11.0,1.0,49.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
2428,87712,Wire,1,node.inspector.protocol.RuntimeAgent.Wire,void node.inspector.protocol.RuntimeAgent.Wire (UberDispatcher*),inspector\runtime_agent.cc,"void RuntimeAgent::Wire(UberDispatcher* dispatcher) {
  frontend_ = std::make_unique<NodeRuntime::Frontend>(dispatcher->channel());
  NodeRuntime::Dispatcher::wire(dispatcher, this);
}",13.0,16.0,1.0,1.0,4.0,8,5,7,5,0,1,1,1,0,0,,0,1,2,1,1,void
2429,87739,notifyWhenWaitingForDisconnect,1,node.inspector.protocol.RuntimeAgent.notifyWhenWaitingForDisconnect,DispatchResponse node.inspector.protocol.RuntimeAgent.notifyWhenWaitingForDisconnect (bool),inspector\runtime_agent.cc,"DispatchResponse RuntimeAgent::notifyWhenWaitingForDisconnect(bool enabled) {
  notify_when_waiting_for_disconnect_ = enabled;
  return DispatchResponse::OK();
}",18.0,21.0,1.0,1.0,4.0,2,2,3,3,0,1,1,1,0,0,,0,1,2,1,1,DispatchResponse
2430,87752,notifyWaitingForDisconnect,1,node.inspector.protocol.RuntimeAgent.notifyWaitingForDisconnect,bool node.inspector.protocol.RuntimeAgent.notifyWaitingForDisconnect (),inspector\runtime_agent.cc,"bool RuntimeAgent::notifyWaitingForDisconnect() {
  if (notify_when_waiting_for_disconnect_) {
    frontend_->waitingForDisconnect();
    return true;
  }
  return false;
}",23.0,29.0,1.0,1.0,7.0,1,1,2,2,0,2,2,2,1,0,,0,2,0,0,0,bool
2431,87825,DeletableFrontendWrapper,1,node.inspector.protocol.anonymous_namespace_3.DeletableFrontendWrapper.DeletableFrontendWrapper,ANY node.inspector.protocol.anonymous_namespace_3.DeletableFrontendWrapper.DeletableFrontendWrapper (ANY),inspector\tracing_agent.cc,"explicit DeletableFrontendWrapper(
      std::weak_ptr<NodeTracing::Frontend> frontend)
      : frontend_(frontend) {}",19.0,21.0,3.0,30.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
2432,87830,get,1,node.inspector.protocol.anonymous_namespace_4.DeletableFrontendWrapper.get,Frontend node.inspector.protocol.anonymous_namespace_4.DeletableFrontendWrapper.get (),inspector\tracing_agent.cc,NodeTracing::Frontend* get() { return frontend_.lock().get(); },25.0,25.0,3.0,65.0,1.0,2,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,Frontend
2433,87844,CreateFrontendWrapperRequest,1,node.inspector.protocol.anonymous_namespace_6.CreateFrontendWrapperRequest.CreateFrontendWrapperRequest,"ANY node.inspector.protocol.anonymous_namespace_6.CreateFrontendWrapperRequest.CreateFrontendWrapperRequest (int,ANY)",inspector\tracing_agent.cc,"CreateFrontendWrapperRequest(int object_id,
                               std::weak_ptr<NodeTracing::Frontend> frontend)
      : object_id_(object_id) {
    frontend_wrapper_ = std::make_unique<DeletableFrontendWrapper>(frontend);
  }",33.0,37.0,3.0,3.0,5.0,4,4,4,4,0,1,1,1,0,0,,0,1,4,2,2,ANY
2434,87859,Call,1,node.inspector.protocol.anonymous_namespace_7.CreateFrontendWrapperRequest.Call,void node.inspector.protocol.anonymous_namespace_7.CreateFrontendWrapperRequest.Call (MainThreadInterface*),inspector\tracing_agent.cc,"void Call(MainThreadInterface* thread) override {
    thread->AddObject(object_id_, std::move(frontend_wrapper_));
  }",39.0,41.0,3.0,3.0,3.0,2,2,4,4,0,2,1,1,0,0,,0,2,2,1,1,void
2435,87877,DestroyFrontendWrapperRequest,1,node.inspector.protocol.anonymous_namespace_9.DestroyFrontendWrapperRequest.DestroyFrontendWrapperRequest,ANY node.inspector.protocol.anonymous_namespace_9.DestroyFrontendWrapperRequest.DestroyFrontendWrapperRequest (int),inspector\tracing_agent.cc,"explicit DestroyFrontendWrapperRequest(int object_id)
      : object_id_(object_id) {}",50.0,51.0,3.0,32.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
2436,87882,Call,1,node.inspector.protocol.anonymous_namespace_10.DestroyFrontendWrapperRequest.Call,void node.inspector.protocol.anonymous_namespace_10.DestroyFrontendWrapperRequest.Call (MainThreadInterface*),inspector\tracing_agent.cc,"void Call(MainThreadInterface* thread) override {
    thread->RemoveObject(object_id_);
  }",53.0,55.0,3.0,3.0,3.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
2437,87894,SendMessageRequest,1,node.inspector.protocol.anonymous_namespace_12.SendMessageRequest.SendMessageRequest,"ANY node.inspector.protocol.anonymous_namespace_12.SendMessageRequest.SendMessageRequest (int,ANY)",inspector\tracing_agent.cc,"explicit SendMessageRequest(int object_id, const std::string& message)
      : object_id_(object_id), message_(message) {}",63.0,64.0,3.0,51.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,ANY
2438,87900,Call,1,node.inspector.protocol.anonymous_namespace_13.SendMessageRequest.Call,void node.inspector.protocol.anonymous_namespace_13.SendMessageRequest.Call (MainThreadInterface*),inspector\tracing_agent.cc,"void Call(MainThreadInterface* thread) override {
    DeletableFrontendWrapper* frontend_wrapper =
        static_cast<DeletableFrontendWrapper*>(
            thread->GetObjectIfExists(object_id_));
    if (frontend_wrapper == nullptr) return;
    auto frontend = frontend_wrapper->get();
    if (frontend != nullptr) {
      frontend->sendRawJSONNotification(message_);
    }
  }",66.0,75.0,3.0,3.0,10.0,8,5,9,5,0,2,3,3,0,0,,0,2,2,1,1,void
2439,87941,InspectorTraceWriter,1,node.inspector.protocol.anonymous_namespace_15.InspectorTraceWriter.InspectorTraceWriter,"ANY node.inspector.protocol.anonymous_namespace_15.InspectorTraceWriter.InspectorTraceWriter (int,ANY)",inspector\tracing_agent.cc,"explicit InspectorTraceWriter(int frontend_object_id,
                                std::shared_ptr<MainThreadHandle> main_thread)
      : frontend_object_id_(frontend_object_id), main_thread_(main_thread) {}",84.0,86.0,3.0,77.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,ANY
2440,87947,AppendTraceEvent,1,node.inspector.protocol.anonymous_namespace_16.InspectorTraceWriter.AppendTraceEvent,void node.inspector.protocol.anonymous_namespace_16.InspectorTraceWriter.AppendTraceEvent (ANY*),inspector\tracing_agent.cc,"void AppendTraceEvent(
      v8::platform::tracing::TraceObject* trace_event) override {
    if (!json_writer_)
      json_writer_.reset(TraceWriter::CreateJSONTraceWriter(stream_, ""value""));
    json_writer_->AppendTraceEvent(trace_event);
  }",88.0,93.0,3.0,3.0,6.0,4,3,6,4,0,4,2,2,1,0,,0,4,2,1,1,void
2441,87971,Flush,1,node.inspector.protocol.anonymous_namespace_17.InspectorTraceWriter.Flush,void node.inspector.protocol.anonymous_namespace_17.InspectorTraceWriter.Flush (bool),inspector\tracing_agent.cc,"void Flush(bool) override {
    if (!json_writer_)
      return;
    json_writer_.reset();
    std::ostringstream result(
        ""{\""method\"":\""NodeTracing.dataCollected\"",\""params\"":"",
        std::ostringstream::ate);
    result << stream_.str();
    result << ""}"";
    main_thread_->Post(std::make_unique<SendMessageRequest>(frontend_object_id_,
                                                            result.str()));
    stream_.str("""");
  }",95.0,107.0,3.0,3.0,13.0,15,8,13,8,0,6,2,2,1,0,,0,6,2,1,1,void
2442,88028,TracingAgent,1,node.inspector.protocol.TracingAgent.TracingAgent,"ANY node.inspector.protocol.TracingAgent.TracingAgent (Environment*,ANY)",inspector\tracing_agent.cc,"TracingAgent::TracingAgent(Environment* env,
                           std::shared_ptr<MainThreadHandle> main_thread)
    : env_(env), main_thread_(main_thread) {}",117.0,119.0,1.0,45.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,ANY
2443,88034,~TracingAgent,1,node.inspector.protocol.TracingAgent.~TracingAgent,ANY node.inspector.protocol.TracingAgent.~TracingAgent (),inspector\tracing_agent.cc,"TracingAgent::~TracingAgent() {
  trace_writer_.reset();
  main_thread_->Post(
      std::make_unique<DestroyFrontendWrapperRequest>(frontend_object_id_));
}",121.0,125.0,1.0,1.0,5.0,5,4,5,5,0,3,1,1,0,0,,0,3,0,0,0,ANY
2444,88053,Wire,1,node.inspector.protocol.TracingAgent.Wire,void node.inspector.protocol.TracingAgent.Wire (UberDispatcher*),inspector\tracing_agent.cc,"void TracingAgent::Wire(UberDispatcher* dispatcher) {
  // Note that frontend is still owned by TracingAgent
  frontend_ = std::make_shared<NodeTracing::Frontend>(dispatcher->channel());
  frontend_object_id_ = main_thread_->newObjectId();
  main_thread_->Post(std::make_unique<CreateFrontendWrapperRequest>(
      frontend_object_id_, frontend_));
  NodeTracing::Dispatcher::wire(dispatcher, this);
}",127.0,134.0,1.0,1.0,8.0,16,7,14,8,0,6,1,1,0,0,,0,6,2,1,1,void
2445,88100,start,1,node.inspector.protocol.TracingAgent.start,DispatchResponse node.inspector.protocol.TracingAgent.start (ANY),inspector\tracing_agent.cc,"DispatchResponse TracingAgent::start(
    std::unique_ptr<protocol::NodeTracing::TraceConfig> traceConfig) {
  if (!trace_writer_.empty()) {
    return DispatchResponse::Error(
        ""Call NodeTracing::end to stop tracing before updating the config"");
  }
  if (!env_->owns_process_state()) {
    return DispatchResponse::Error(
        ""Tracing properties can only be changed through main thread sessions"");
  }

  std::set<std::string> categories_set;
  protocol::Array<std::string>* categories =
      traceConfig->getIncludedCategories();
  for (size_t i = 0; i < categories->length(); i++)
    categories_set.insert(categories->get(i));

  if (categories_set.empty())
    return DispatchResponse::Error(""At least one category should be enabled"");

  tracing::AgentWriterHandle* writer = GetTracingAgentWriter();
  if (writer != nullptr) {
    trace_writer_ =
        writer->agent()->AddClient(categories_set,
                                   std::make_unique<InspectorTraceWriter>(
     ...",136.0,165.0,1.0,1.0,30.0,35,10,28,15,0,5,6,6,2,0,,0,5,2,1,1,DispatchResponse
2446,88229,stop,1,node.inspector.protocol.TracingAgent.stop,DispatchResponse node.inspector.protocol.TracingAgent.stop (),inspector\tracing_agent.cc,"DispatchResponse TracingAgent::stop() {
  trace_writer_.reset();
  frontend_->tracingComplete();
  return DispatchResponse::OK();
}",167.0,171.0,1.0,1.0,5.0,3,2,3,3,0,2,1,1,0,0,,0,2,0,0,0,DispatchResponse
2447,88246,getCategories,1,node.inspector.protocol.TracingAgent.getCategories,DispatchResponse node.inspector.protocol.TracingAgent.getCategories (ANY*),inspector\tracing_agent.cc,"DispatchResponse TracingAgent::getCategories(
    std::unique_ptr<protocol::Array<String>>* categories) {
  *categories = Array<String>::create();
  protocol::Array<String>* categories_list = categories->get();
  // In alphabetical order
  categories_list->addItem(""node"");
  categories_list->addItem(""node.async_hooks"");
  categories_list->addItem(""node.bootstrap"");
  categories_list->addItem(""node.console"");
  categories_list->addItem(""node.dns.native"");
  categories_list->addItem(""node.environment"");
  categories_list->addItem(""node.fs.async"");
  categories_list->addItem(""node.fs.sync"");
  categories_list->addItem(""node.fs_dir.async"");
  categories_list->addItem(""node.fs_dir.sync"");
  categories_list->addItem(""node.http"");
  categories_list->addItem(""node.net.native"");
  categories_list->addItem(""node.perf"");
  categories_list->addItem(""node.perf.timerify"");
  categories_list->addItem(""node.perf.usertiming"");
  categories_list->addItem(""node.promises.rejections"");
  categories_list...",173.0,199.0,1.0,1.0,27.0,32,6,28,6,0,0,1,1,0,0,,0,0,2,1,1,DispatchResponse
2448,88455,NodeWorkers,1,node.inspector.protocol.NodeWorkers.NodeWorkers,"ANY node.inspector.protocol.NodeWorkers.NodeWorkers (ANY,ANY)",inspector\worker_agent.cc,"explicit NodeWorkers(std::weak_ptr<NodeWorker::Frontend> frontend,
                      std::shared_ptr<MainThreadHandle> thread)
                      : frontend_(frontend), thread_(thread) {}",14.0,16.0,3.0,63.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,ANY
2449,88461,WorkerCreated,1,node.inspector.protocol.NodeWorkers.WorkerCreated,"void node.inspector.protocol.NodeWorkers.WorkerCreated (ANY,ANY,bool,ANY)",inspector\worker_agent.cc,"void NodeWorkers::WorkerCreated(const std::string& title,
                                const std::string& url,
                                bool waiting,
                                std::shared_ptr<MainThreadHandle> target) {
  auto frontend = frontend_.lock();
  if (!frontend)
    return;
  std::string id = std::to_string(++next_target_id_);
  auto delegate = thread_->MakeDelegateThreadSafe(
      std::unique_ptr<InspectorSessionDelegate>(
          new ParentInspectorSessionDelegate(id, shared_from_this())));
  sessions_[id] = target->Connect(std::move(delegate), true);
  frontend->attachedToWorker(id, WorkerInfo(id, title, url), waiting);
}",123.0,136.0,1.0,1.0,14.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,void
2450,88469,Receive,1,node.inspector.protocol.NodeWorkers.Receive,"void node.inspector.protocol.NodeWorkers.Receive (ANY,ANY)",inspector\worker_agent.cc,"void NodeWorkers::Receive(const std::string& id, const std::string& message) {
  auto it = sessions_.find(id);
  if (it != sessions_.end())
    it->second->Dispatch(Utf8ToStringView(message)->string());
}",144.0,148.0,1.0,1.0,5.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
2451,88475,Send,1,node.inspector.protocol.NodeWorkers.Send,"void node.inspector.protocol.NodeWorkers.Send (ANY,ANY)",inspector\worker_agent.cc,"void NodeWorkers::Send(const std::string& id, const std::string& message) {
  auto frontend = frontend_.lock();
  if (frontend)
    frontend->receivedMessageFromWorker(id, message);
}",138.0,142.0,1.0,1.0,5.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
2452,88481,Detached,1,node.inspector.protocol.NodeWorkers.Detached,void node.inspector.protocol.NodeWorkers.Detached (ANY),inspector\worker_agent.cc,"void NodeWorkers::Detached(const std::string& id) {
  if (sessions_.erase(id) == 0)
    return;
  auto frontend = frontend_.lock();
  if (frontend) {
    frontend->detachedFromWorker(id);
  }
}",150.0,157.0,1.0,1.0,8.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
2453,88499,AgentWorkerInspectorDelegate,1,node.inspector.protocol.anonymous_namespace_2.AgentWorkerInspectorDelegate.AgentWorkerInspectorDelegate,ANY node.inspector.protocol.anonymous_namespace_2.AgentWorkerInspectorDelegate.AgentWorkerInspectorDelegate (ANY),inspector\worker_agent.cc,"explicit AgentWorkerInspectorDelegate(std::shared_ptr<NodeWorkers> workers)
                                        : workers_(workers) {}",35.0,36.0,3.0,62.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
2454,88504,WorkerCreated,1,node.inspector.protocol.anonymous_namespace_3.AgentWorkerInspectorDelegate.WorkerCreated,"void node.inspector.protocol.anonymous_namespace_3.AgentWorkerInspectorDelegate.WorkerCreated (ANY,ANY,bool,ANY)",inspector\worker_agent.cc,"void WorkerCreated(const std::string& title,
                     const std::string& url,
                     bool waiting,
                     std::shared_ptr<MainThreadHandle> target) override {
    workers_->WorkerCreated(title, url, waiting, target);
  }",38.0,43.0,3.0,3.0,6.0,1,1,5,5,0,1,1,1,0,0,,0,1,8,4,4,void
2455,88522,ParentInspectorSessionDelegate,1,node.inspector.protocol.anonymous_namespace_5.ParentInspectorSessionDelegate.ParentInspectorSessionDelegate,"ANY node.inspector.protocol.anonymous_namespace_5.ParentInspectorSessionDelegate.ParentInspectorSessionDelegate (ANY,ANY)",inspector\worker_agent.cc,"ParentInspectorSessionDelegate(const std::string& id,
                                 std::shared_ptr<NodeWorkers> workers)
                                 : id_(id), workers_(workers) {}",51.0,53.0,3.0,64.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,ANY
2456,88528,~ParentInspectorSessionDelegate,1,node.inspector.protocol.anonymous_namespace_6.ParentInspectorSessionDelegate.~ParentInspectorSessionDelegate,ANY node.inspector.protocol.anonymous_namespace_6.ParentInspectorSessionDelegate.~ParentInspectorSessionDelegate (),inspector\worker_agent.cc,"~ParentInspectorSessionDelegate() override {
    workers_->Detached(id_);
  }",55.0,57.0,3.0,3.0,3.0,1,1,2,2,0,2,1,1,0,0,,0,2,0,0,0,ANY
2457,88537,SendMessageToFrontend,1,node.inspector.protocol.anonymous_namespace_7.ParentInspectorSessionDelegate.SendMessageToFrontend,void node.inspector.protocol.anonymous_namespace_7.ParentInspectorSessionDelegate.SendMessageToFrontend (ANY),inspector\worker_agent.cc,"void SendMessageToFrontend(const v8_inspector::StringView& msg) override {
    std::string message = protocol::StringUtil::StringViewToUtf8(msg);
    workers_->Send(id_, message);
  }",59.0,62.0,3.0,3.0,4.0,4,3,7,6,0,2,1,1,0,0,,0,2,2,1,1,void
2458,88560,WorkerInfo,1,node.inspector.protocol.anonymous_namespace_8.WorkerInfo,"unique_ptr<NodeWorker::WorkerInfo> node.inspector.protocol.anonymous_namespace_8.WorkerInfo (ANY,ANY,ANY)",inspector\worker_agent.cc,"std::unique_ptr<NodeWorker::WorkerInfo> WorkerInfo(const std::string& id,
                                                   const std::string& title,
                                                   const std::string& url) {
  return NodeWorker::WorkerInfo::create()
      .setWorkerId(id)
      .setTitle(title)
      .setUrl(url)
      .setType(""worker"").build();
}",69.0,77.0,1.0,1.0,9.0,7,1,5,5,0,0,1,1,0,0,,0,0,6,3,3,unique_ptr<NodeWorker.WorkerInfo>
2459,88593,WorkerAgent,1,node.inspector.protocol.WorkerAgent.WorkerAgent,ANY node.inspector.protocol.WorkerAgent.WorkerAgent (ANY),inspector\worker_agent.cc,"WorkerAgent::WorkerAgent(std::weak_ptr<WorkerManager> manager)
                         : manager_(manager) {}",80.0,81.0,1.0,47.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
2460,88598,Wire,1,node.inspector.protocol.WorkerAgent.Wire,void node.inspector.protocol.WorkerAgent.Wire (UberDispatcher*),inspector\worker_agent.cc,"void WorkerAgent::Wire(UberDispatcher* dispatcher) {
  frontend_.reset(new NodeWorker::Frontend(dispatcher->channel()));
  NodeWorker::Dispatcher::wire(dispatcher, this);
  auto manager = manager_.lock();
  CHECK_NOT_NULL(manager);
  workers_ =
      std::make_shared<NodeWorkers>(frontend_, manager->MainThread());
}",84.0,91.0,1.0,1.0,8.0,14,8,14,10,0,4,1,1,0,0,,0,4,2,1,1,void
2461,88645,sendMessageToWorker,1,node.inspector.protocol.WorkerAgent.sendMessageToWorker,"DispatchResponse node.inspector.protocol.WorkerAgent.sendMessageToWorker (String,String)",inspector\worker_agent.cc,"DispatchResponse WorkerAgent::sendMessageToWorker(const String& message,
                                                  const String& sessionId) {
  workers_->Receive(sessionId, message);
  return DispatchResponse::OK();
}",93.0,97.0,1.0,1.0,5.0,2,2,4,4,0,1,1,1,0,0,,0,1,4,2,2,DispatchResponse
2462,88662,enable,1,node.inspector.protocol.WorkerAgent.enable,DispatchResponse node.inspector.protocol.WorkerAgent.enable (bool),inspector\worker_agent.cc,"DispatchResponse WorkerAgent::enable(bool waitForDebuggerOnStart) {
  auto manager = manager_.lock();
  if (!manager) {
    return DispatchResponse::OK();
  }
  if (!event_handle_) {
    std::unique_ptr<AgentWorkerInspectorDelegate> delegate(
            new AgentWorkerInspectorDelegate(workers_));
    event_handle_ = manager->SetAutoAttach(std::move(delegate));
  }
  event_handle_->SetWaitOnStart(waitForDebuggerOnStart);
  return DispatchResponse::OK();
}",99.0,111.0,1.0,1.0,13.0,11,5,14,9,0,5,3,3,1,0,,0,5,2,1,1,DispatchResponse
2463,88713,disable,1,node.inspector.protocol.WorkerAgent.disable,DispatchResponse node.inspector.protocol.WorkerAgent.disable (),inspector\worker_agent.cc,"DispatchResponse WorkerAgent::disable() {
  event_handle_.reset();
  return DispatchResponse::OK();
}",113.0,116.0,1.0,1.0,4.0,2,1,2,2,0,1,1,1,0,0,,0,1,0,0,0,DispatchResponse
2464,88726,detach,1,node.inspector.protocol.WorkerAgent.detach,DispatchResponse node.inspector.protocol.WorkerAgent.detach (String),inspector\worker_agent.cc,"DispatchResponse WorkerAgent::detach(const String& sessionId) {
  workers_->Detached(sessionId);
  return DispatchResponse::OK();
}",118.0,121.0,1.0,1.0,4.0,2,2,3,3,0,1,1,1,0,0,,0,1,2,1,1,DispatchResponse
2465,88917,~WorkerAgent,1,node.inspector.protocol.WorkerAgent.~WorkerAgent,ANY node.inspector.protocol.WorkerAgent.~WorkerAgent (),inspector\worker_agent.hpp,~WorkerAgent() override = default;,19.0,19.0,3.0,36.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
2466,88967,WorkerStartedRequest,1,node.inspector.anonymous_namespace_2.WorkerStartedRequest.WorkerStartedRequest,"ANY node.inspector.anonymous_namespace_2.WorkerStartedRequest.WorkerStartedRequest (uint64_t,ANY,ANY,bool,ANY)",inspector\worker_inspector.cc,"WorkerStartedRequest(
      uint64_t id,
      const std::string& url,
      std::shared_ptr<node::inspector::MainThreadHandle> worker_thread,
      bool waiting,
      const std::string& name)
      : id_(id),
        info_(BuildWorkerTitle(id, name), url, worker_thread),
        waiting_(waiting) {}",13.0,21.0,3.0,28.0,9.0,0,0,0,0,0,0,1,1,0,0,,0,0,10,5,5,ANY
2467,88976,Call,1,node.inspector.anonymous_namespace_3.WorkerStartedRequest.Call,void node.inspector.anonymous_namespace_3.WorkerStartedRequest.Call (MainThreadInterface*),inspector\worker_inspector.cc,"void Call(MainThreadInterface* thread) override {
    auto manager = thread->inspector_agent()->GetWorkerManager();
    manager->WorkerStarted(id_, info_, waiting_);
  }",22.0,25.0,3.0,3.0,4.0,4,2,6,5,0,3,1,1,0,0,,0,3,2,1,1,void
2468,88998,BuildWorkerTitle,1,node.inspector.anonymous_namespace_4.WorkerStartedRequest.BuildWorkerTitle,"string node.inspector.anonymous_namespace_4.WorkerStartedRequest.BuildWorkerTitle (int,ANY)",inspector\worker_inspector.cc,"static std::string BuildWorkerTitle(int id, const std::string& name) {
    return ""[worker "" + std::to_string(id) + ""]"" +
           (name == """" ? """" : "" "" + name);
  }",28.0,31.0,3.0,3.0,4.0,7,4,4,3,0,0,1,1,0,0,,0,0,4,2,2,string
2469,89026,Report,1,node.inspector.anonymous_namespace_5.Report,"void node.inspector.anonymous_namespace_5.Report (ANY,WorkerInfo,bool)",inspector\worker_inspector.cc,"void Report(const std::unique_ptr<WorkerDelegate>& delegate,
            const WorkerInfo& info, bool waiting) {
  if (info.worker_thread)
    delegate->WorkerCreated(info.title, info.url, waiting, info.worker_thread);
}",39.0,43.0,1.0,1.0,5.0,5,2,6,3,0,4,2,2,1,0,,0,4,6,3,3,void
2470,89053,WorkerFinishedRequest,1,node.inspector.anonymous_namespace_7.WorkerFinishedRequest.WorkerFinishedRequest,ANY node.inspector.anonymous_namespace_7.WorkerFinishedRequest.WorkerFinishedRequest (uint64_t),inspector\worker_inspector.cc,explicit WorkerFinishedRequest(uint64_t worker_id) : worker_id_(worker_id) {},47.0,47.0,3.0,79.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
2471,89058,Call,1,node.inspector.anonymous_namespace_8.WorkerFinishedRequest.Call,void node.inspector.anonymous_namespace_8.WorkerFinishedRequest.Call (MainThreadInterface*),inspector\worker_inspector.cc,"void Call(MainThreadInterface* thread) override {
    thread->inspector_agent()->GetWorkerManager()->WorkerFinished(worker_id_);
  }",49.0,51.0,3.0,3.0,3.0,3,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
2472,89075,ParentInspectorHandle,1,node.inspector.ParentInspectorHandle.ParentInspectorHandle,"ANY node.inspector.ParentInspectorHandle.ParentInspectorHandle (uint64_t,ANY,ANY,bool,ANY)",inspector\worker_inspector.cc,"ParentInspectorHandle::ParentInspectorHandle(
    uint64_t id,
    const std::string& url,
    std::shared_ptr<MainThreadHandle> parent_thread,
    bool wait_for_connect,
    const std::string& name)
    : id_(id),
      url_(url),
      parent_thread_(parent_thread),
      wait_(wait_for_connect),
      name_(name) {}",58.0,68.0,1.0,20.0,11.0,0,0,0,0,0,0,1,1,0,0,,0,0,10,5,5,ANY
2473,89084,~ParentInspectorHandle,1,node.inspector.ParentInspectorHandle.~ParentInspectorHandle,ANY node.inspector.ParentInspectorHandle.~ParentInspectorHandle (),inspector\worker_inspector.cc,"ParentInspectorHandle::~ParentInspectorHandle() {
  parent_thread_->Post(
      std::unique_ptr<Request>(new WorkerFinishedRequest(id_)));
}",70.0,73.0,1.0,1.0,4.0,5,5,5,5,0,2,1,1,0,0,,0,2,0,0,0,ANY
2474,89101,WorkerStarted,1,node.inspector.ParentInspectorHandle.WorkerStarted,"void node.inspector.ParentInspectorHandle.WorkerStarted (ANY,bool)",inspector\worker_inspector.cc,"void ParentInspectorHandle::WorkerStarted(
    std::shared_ptr<MainThreadHandle> worker_thread, bool waiting) {
  std::unique_ptr<Request> request(
      new WorkerStartedRequest(id_, url_, worker_thread, waiting, name_));
  parent_thread_->Post(std::move(request));
}",75.0,80.0,1.0,1.0,6.0,3,3,9,9,0,4,1,1,0,0,,0,4,4,2,2,void
2475,89125,Connect,1,node.inspector.ParentInspectorHandle.Connect,"unique_ptr<inspector::InspectorSession> node.inspector.ParentInspectorHandle.Connect (ANY,bool)",inspector\worker_inspector.cc,"std::unique_ptr<inspector::InspectorSession> ParentInspectorHandle::Connect(
    std::unique_ptr<inspector::InspectorSessionDelegate> delegate,
    bool prevent_shutdown) {
  return parent_thread_->Connect(std::move(delegate), prevent_shutdown);
}",82.0,86.0,1.0,1.0,5.0,2,2,4,4,0,1,1,1,0,0,,0,1,4,2,2,unique_ptr<inspector.InspectorSession>
2476,89142,WorkerFinished,1,node.inspector.WorkerManager.WorkerFinished,void node.inspector.WorkerManager.WorkerFinished (uint64_t),inspector\worker_inspector.cc,"void WorkerManager::WorkerFinished(uint64_t session_id) {
  children_.erase(session_id);
}",88.0,90.0,1.0,1.0,3.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
2477,89152,WorkerStarted,1,node.inspector.WorkerManager.WorkerStarted,"void node.inspector.WorkerManager.WorkerStarted (uint64_t,WorkerInfo,bool)",inspector\worker_inspector.cc,"void WorkerManager::WorkerStarted(uint64_t session_id,
                                  const WorkerInfo& info,
                                  bool waiting) {
  if (info.worker_thread->Expired())
    return;
  children_.emplace(session_id, info);
  for (const auto& delegate : delegates_) {
    Report(delegate.second, info, waiting);
  }
}",92.0,101.0,1.0,1.0,10.0,4,2,8,6,0,3,3,3,2,0,,0,3,6,3,3,void
2478,89184,NewParentHandle,1,node.inspector.WorkerManager.NewParentHandle,"unique_ptr<ParentInspectorHandle> node.inspector.WorkerManager.NewParentHandle (uint64_t,ANY,ANY)",inspector\worker_inspector.cc,"std::unique_ptr<ParentInspectorHandle> WorkerManager::NewParentHandle(
    uint64_t thread_id, const std::string& url, const std::string& name) {
  bool wait = !delegates_waiting_on_start_.empty();
  return std::make_unique<ParentInspectorHandle>(
      thread_id, url, thread_, wait, name);
}",103.0,108.0,1.0,1.0,6.0,8,7,9,8,0,2,1,1,0,0,,0,2,6,3,3,unique_ptr<ParentInspectorHandle>
2479,89213,RemoveAttachDelegate,1,node.inspector.WorkerManager.RemoveAttachDelegate,void node.inspector.WorkerManager.RemoveAttachDelegate (int),inspector\worker_inspector.cc,"void WorkerManager::RemoveAttachDelegate(int id) {
  delegates_.erase(id);
  delegates_waiting_on_start_.erase(id);
}",110.0,113.0,1.0,1.0,4.0,2,1,4,3,0,2,1,1,0,0,,0,2,2,1,1,void
2480,89228,SetAutoAttach,1,node.inspector.WorkerManager.SetAutoAttach,unique_ptr<WorkerManagerEventHandle> node.inspector.WorkerManager.SetAutoAttach (ANY),inspector\worker_inspector.cc,"std::unique_ptr<WorkerManagerEventHandle> WorkerManager::SetAutoAttach(
    std::unique_ptr<WorkerDelegate> attach_delegate) {
  int id = ++next_delegate_id_;
  delegates_[id] = std::move(attach_delegate);
  const auto& delegate = delegates_[id];
  for (const auto& worker : children_) {
    // Waiting is only reported when a worker is started, same as browser
    Report(delegate, worker.second, false);
  }
  return std::make_unique<WorkerManagerEventHandle>(shared_from_this(), id);
}",115.0,125.0,1.0,1.0,11.0,13,8,15,9,0,4,2,2,1,0,,0,4,2,1,1,unique_ptr<WorkerManagerEventHandle>
2481,89274,SetWaitOnStartForDelegate,1,node.inspector.WorkerManager.SetWaitOnStartForDelegate,"void node.inspector.WorkerManager.SetWaitOnStartForDelegate (int,bool)",inspector\worker_inspector.cc,"void WorkerManager::SetWaitOnStartForDelegate(int id, bool wait) {
  if (wait)
    delegates_waiting_on_start_.insert(id);
  else
    delegates_waiting_on_start_.erase(id);
}",127.0,132.0,1.0,1.0,6.0,1,1,3,3,0,1,2,2,0,0,,0,1,4,2,2,void
2482,89295,SetWaitOnStart,1,node.inspector.WorkerManagerEventHandle.SetWaitOnStart,void node.inspector.WorkerManagerEventHandle.SetWaitOnStart (bool),inspector\worker_inspector.cc,"void WorkerManagerEventHandle::SetWaitOnStart(bool wait_on_start) {
    manager_->SetWaitOnStartForDelegate(id_, wait_on_start);
}",134.0,136.0,1.0,1.0,3.0,1,1,3,3,0,2,1,1,0,0,,0,2,2,1,1,void
2483,89306,~WorkerManagerEventHandle,1,node.inspector.WorkerManagerEventHandle.~WorkerManagerEventHandle,ANY node.inspector.WorkerManagerEventHandle.~WorkerManagerEventHandle (),inspector\worker_inspector.cc,"WorkerManagerEventHandle::~WorkerManagerEventHandle() {
  manager_->RemoveAttachDelegate(id_);
}",138.0,140.0,1.0,1.0,3.0,1,1,2,2,0,2,1,1,0,0,,0,2,0,0,0,ANY
2484,89335,WorkerCreated,1,node.inspector.WorkerDelegate.WorkerCreated,"void node.inspector.WorkerDelegate.WorkerCreated (ANY,ANY,bool,ANY)",inspector\worker_inspector.hpp,"virtual void WorkerCreated(const std::string& title,
                             const std::string& url,
                             bool waiting,
                             std::shared_ptr<MainThreadHandle> worker) = 0;",22.0,25.0,16.0,74.0,4.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,void
2485,89343,~WorkerDelegate,1,node.inspector.WorkerDelegate.~WorkerDelegate,ANY node.inspector.WorkerDelegate.~WorkerDelegate (),inspector\worker_inspector.hpp,virtual ~WorkerDelegate() = default;,26.0,26.0,3.0,38.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
2486,89348,WorkerManagerEventHandle,1,node.inspector.WorkerManagerEventHandle.WorkerManagerEventHandle,"ANY node.inspector.WorkerManagerEventHandle.WorkerManagerEventHandle (ANY,int)",inspector\worker_inspector.hpp,"explicit WorkerManagerEventHandle(std::shared_ptr<WorkerManager> manager,
                                    int id)
                                    : manager_(manager), id_(id) {}",31.0,33.0,3.0,67.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,ANY
2487,89366,WorkerInfo,1,node.inspector.WorkerInfo.WorkerInfo,"ANY node.inspector.WorkerInfo.WorkerInfo (ANY,ANY,ANY)",inspector\worker_inspector.hpp,"WorkerInfo(const std::string& target_title,
             const std::string& target_url,
             std::shared_ptr<MainThreadHandle> worker_thread)
             : title(target_title),
               url(target_url),
               worker_thread(worker_thread) {}",43.0,48.0,3.0,46.0,6.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,ANY
2488,89390,NewParentInspectorHandle,1,node.inspector.ParentInspectorHandle.NewParentInspectorHandle,"unique_ptr<ParentInspectorHandle> node.inspector.ParentInspectorHandle.NewParentInspectorHandle (uint64_t,ANY,ANY)",inspector\worker_inspector.hpp,"std::unique_ptr<ParentInspectorHandle> NewParentInspectorHandle(
      uint64_t thread_id, const std::string& url, const std::string& name) {
    return std::make_unique<ParentInspectorHandle>(
        thread_id, url, parent_thread_, wait_, name);
  }",62.0,66.0,3.0,3.0,5.0,5,5,7,7,0,2,1,1,0,0,,0,2,6,3,3,unique_ptr<ParentInspectorHandle>
2489,89417,WaitForConnect,1,node.inspector.ParentInspectorHandle.WaitForConnect,bool node.inspector.ParentInspectorHandle.WaitForConnect (),inspector\worker_inspector.hpp,"bool WaitForConnect() {
    return wait_;
  }",69.0,71.0,3.0,3.0,3.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,bool
2490,89423,url,1,node.inspector.ParentInspectorHandle.url,string node.inspector.ParentInspectorHandle.url (),inspector\worker_inspector.hpp,const std::string& url() const { return url_; },72.0,72.0,3.0,49.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,string
2491,89441,WorkerManager,1,node.inspector.WorkerManager.WorkerManager,ANY node.inspector.WorkerManager.WorkerManager (ANY),inspector\worker_inspector.hpp,"explicit WorkerManager(std::shared_ptr<MainThreadHandle> thread)
                         : thread_(thread) {}",87.0,88.0,3.0,45.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
2492,89481,MainThread,1,node.inspector.WorkerManager.MainThread,shared_ptr<MainThreadHandle> node.inspector.WorkerManager.MainThread (),inspector\worker_inspector.hpp,"std::shared_ptr<MainThreadHandle> MainThread() {
    return thread_;
  }",98.0,100.0,3.0,3.0,3.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,shared_ptr<MainThreadHandle>
2493,89500,<lambda>0,1,node.inspector.NodeInspectorClient.startRepeatingTimer.<lambda>0,ANY node.inspector.NodeInspectorClient.startRepeatingTimer.<lambda>0 (),inspector_agent.cc,[=]() { callback(data); },551.0,551.0,47.0,71.0,1.0,0,0,1,1,0,0,1,1,0,0,,0,0,0,0,0,ANY
2494,89509,<lambda>2,1,node.inspector.Agent.Start..<lambda>2,ANY node.inspector.Agent.Start..<lambda>2 (uv_async_t*),inspector_agent.cc,"[](uv_async_t*) {
        CHECK(start_io_thread_async_initialized.exchange(false));
      }",721.0,723.0,48.0,7.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,ANY
2495,89522,<lambda>1,1,node.inspector.Agent.Start.<lambda>1,ANY node.inspector.Agent.Start.<lambda>1 (void*),inspector_agent.cc,"[](void* data) {
      Environment* env = static_cast<Environment*>(data);

      {
        Mutex::ScopedLock lock(start_io_thread_async_mutex);
        start_io_thread_async.data = nullptr;
      }

      // This is global, will never get freed
      env->CloseHandle(&start_io_thread_async, [](uv_async_t*) {
        CHECK(start_io_thread_async_initialized.exchange(false));
      });
    }",712.0,724.0,33.0,5.0,13.0,6,5,6,4,0,0,1,1,0,0,,0,0,2,1,1,ANY
2496,89550,<lambda>3,1,node.inspector.Agent.Start.<lambda>3,ANY node.inspector.Agent.Start.<lambda>3 (void*),inspector_agent.cc,"[](void* env) {
    Agent* agent = static_cast<Environment*>(env)->inspector_agent();
    if (agent->IsActive()) {
      agent->WaitForDisconnect();
    }
  }",727.0,732.0,23.0,3.0,6.0,5,3,4,2,0,0,2,2,0,0,,0,0,2,1,1,ANY
2497,89575,<lambda>4,1,node.inspector.Agent.RequestIoThreadStart.<lambda>4,ANY node.inspector.Agent.RequestIoThreadStart.<lambda>4 (Environment*),inspector_agent.cc,"[this](Environment*) {
    StartIoThread();
  }",939.0,941.0,33.0,3.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
2498,89649,ToProtocolString,1,node.inspector.anonymous_namespace_14.ToProtocolString,"unique_ptr<StringBuffer> node.inspector.anonymous_namespace_14.ToProtocolString (Isolate*,Local<Value>)",inspector_agent.cc,"std::unique_ptr<StringBuffer> ToProtocolString(Isolate* isolate,
                                               Local<Value> value) {
  TwoByteValue buffer(isolate, value);
  return StringBuffer::create(StringView(*buffer, buffer.length()));
}",65.0,69.0,1.0,1.0,5.0,3,2,5,4,0,0,1,1,0,0,,0,0,4,2,2,unique_ptr<StringBuffer>
2499,89671,StartIoThreadAsyncCallback,1,node.inspector.anonymous_namespace_15.StartIoThreadAsyncCallback,void node.inspector.anonymous_namespace_15.StartIoThreadAsyncCallback (uv_async_t*),inspector_agent.cc,"void StartIoThreadAsyncCallback(uv_async_t* handle) {
  static_cast<Agent*>(handle->data)->StartIoThread();
}",72.0,74.0,1.0,1.0,3.0,3,2,1,1,0,0,1,1,0,0,,0,0,2,1,1,void
2500,89688,GetWorkerLabel,1,node.inspector.anonymous_namespace_16.GetWorkerLabel,string node.inspector.anonymous_namespace_16.GetWorkerLabel (ANY*),inspector_agent.cc,"std::string GetWorkerLabel(node::Environment* env) {
  std::ostringstream result;
  result << ""Worker["" << env->thread_id() << ""]"";
  return result.str();
}",205.0,209.0,1.0,1.0,5.0,5,3,3,2,0,0,1,1,0,0,,0,0,2,1,1,string
2501,89710,ChannelImpl,1,node.inspector.anonymous_namespace_18.ChannelImpl.ChannelImpl,"ANY node.inspector.anonymous_namespace_18.ChannelImpl.ChannelImpl (Environment*,ANY,ANY,ANY,ANY,bool)",inspector_agent.cc,"explicit ChannelImpl(Environment* env,
                       const std::unique_ptr<V8Inspector>& inspector,
                       std::shared_ptr<WorkerManager> worker_manager,
                       std::unique_ptr<InspectorSessionDelegate> delegate,
                       std::shared_ptr<MainThreadHandle> main_thread_,
                       bool prevent_shutdown)
      : delegate_(std::move(delegate)), prevent_shutdown_(prevent_shutdown),
        retaining_context_(false) {
    session_ = inspector->connect(CONTEXT_GROUP_ID,
                                  this,
                                  StringView(),
                                  V8Inspector::ClientTrustLevel::kFullyTrusted);
    node_dispatcher_ = std::make_unique<protocol::UberDispatcher>(this);
    tracing_agent_ =
        std::make_unique<protocol::TracingAgent>(env, main_thread_);
    tracing_agent_->Wire(node_dispatcher_.get());
    if (worker_manager) {
      worker_agent_ = std::make_unique<protocol::Work...",214.0,236.0,3.0,3.0,23.0,29,7,26,14,0,11,2,2,0,0,,0,11,12,6,6,ANY
2502,89803,~ChannelImpl,1,node.inspector.anonymous_namespace_19.ChannelImpl.~ChannelImpl,ANY node.inspector.anonymous_namespace_19.ChannelImpl.~ChannelImpl (),inspector_agent.cc,"~ChannelImpl() override {
    tracing_agent_->disable();
    tracing_agent_.reset();  // Dispose before the dispatchers
    if (worker_agent_) {
      worker_agent_->disable();
      worker_agent_.reset();  // Dispose before the dispatchers
    }
    runtime_agent_->disable();
    runtime_agent_.reset();  // Dispose before the dispatchers
  }",238.0,247.0,3.0,3.0,10.0,6,2,7,3,0,7,2,2,1,0,,0,7,0,0,0,ANY
2503,89834,dispatchProtocolMessage,1,node.inspector.anonymous_namespace_20.ChannelImpl.dispatchProtocolMessage,void node.inspector.anonymous_namespace_20.ChannelImpl.dispatchProtocolMessage (StringView),inspector_agent.cc,"void dispatchProtocolMessage(const StringView& message) {
    std::string raw_message = protocol::StringUtil::StringViewToUtf8(message);
    per_process::Debug(DebugCategory::INSPECTOR_SERVER,
                       ""[inspector received] %s\n"",
                       raw_message);
    std::unique_ptr<protocol::DictionaryValue> value =
        protocol::DictionaryValue::cast(protocol::StringUtil::parseMessage(
            raw_message, false));
    int call_id;
    std::string method;
    node_dispatcher_->parseCommand(value.get(), &call_id, &method);
    if (v8_inspector::V8InspectorSession::canDispatchMethod(
            Utf8ToStringView(method)->string())) {
      session_->dispatchProtocolMessage(message);
    } else {
      node_dispatcher_->dispatch(call_id, method, std::move(value),
                                 raw_message);
    }
  }",249.0,267.0,3.0,3.0,19.0,22,6,24,15,0,2,2,2,0,0,,0,2,2,1,1,void
2504,89928,schedulePauseOnNextStatement,1,node.inspector.anonymous_namespace_21.ChannelImpl.schedulePauseOnNextStatement,void node.inspector.anonymous_namespace_21.ChannelImpl.schedulePauseOnNextStatement (ANY),inspector_agent.cc,"void schedulePauseOnNextStatement(const std::string& reason) {
    std::unique_ptr<StringBuffer> buffer = Utf8ToStringView(reason);
    session_->schedulePauseOnNextStatement(buffer->string(), buffer->string());
  }",269.0,272.0,3.0,3.0,4.0,4,2,5,3,0,1,1,1,0,0,,0,1,2,1,1,void
2505,89950,preventShutdown,1,node.inspector.anonymous_namespace_22.ChannelImpl.preventShutdown,bool node.inspector.anonymous_namespace_22.ChannelImpl.preventShutdown (),inspector_agent.cc,"bool preventShutdown() {
    return prevent_shutdown_;
  }",274.0,276.0,3.0,3.0,3.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,bool
2506,89956,notifyWaitingForDisconnect,1,node.inspector.anonymous_namespace_23.ChannelImpl.notifyWaitingForDisconnect,bool node.inspector.anonymous_namespace_23.ChannelImpl.notifyWaitingForDisconnect (),inspector_agent.cc,"bool notifyWaitingForDisconnect() {
    retaining_context_ = runtime_agent_->notifyWaitingForDisconnect();
    return retaining_context_;
  }",278.0,281.0,3.0,3.0,4.0,2,2,3,2,0,3,1,1,0,0,,0,3,0,0,0,bool
2507,89968,retainingContext,1,node.inspector.anonymous_namespace_24.ChannelImpl.retainingContext,bool node.inspector.anonymous_namespace_24.ChannelImpl.retainingContext (),inspector_agent.cc,"bool retainingContext() {
    return retaining_context_;
  }",283.0,285.0,3.0,3.0,3.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,bool
2508,89974,sendResponse,1,node.inspector.anonymous_namespace_25.ChannelImpl.sendResponse,"void node.inspector.anonymous_namespace_25.ChannelImpl.sendResponse (int,ANY)",inspector_agent.cc,"void sendResponse(
      int callId,
      std::unique_ptr<v8_inspector::StringBuffer> message) override {
    sendMessageToFrontend(message->string());
  }",288.0,292.0,3.0,3.0,5.0,1,1,1,1,0,0,1,1,0,0,,0,0,4,2,2,void
2509,89985,sendNotification,1,node.inspector.anonymous_namespace_26.ChannelImpl.sendNotification,void node.inspector.anonymous_namespace_26.ChannelImpl.sendNotification (ANY),inspector_agent.cc,"void sendNotification(
      std::unique_ptr<v8_inspector::StringBuffer> message) override {
    sendMessageToFrontend(message->string());
  }",294.0,297.0,3.0,3.0,4.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,void
2510,89995,flushProtocolNotifications,1,node.inspector.anonymous_namespace_27.ChannelImpl.flushProtocolNotifications,void node.inspector.anonymous_namespace_27.ChannelImpl.flushProtocolNotifications (),inspector_agent.cc,void flushProtocolNotifications() override { },299.0,299.0,3.0,48.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2511,89999,sendMessageToFrontend,1,node.inspector.anonymous_namespace_28.ChannelImpl.sendMessageToFrontend,void node.inspector.anonymous_namespace_28.ChannelImpl.sendMessageToFrontend (StringView),inspector_agent.cc,"void sendMessageToFrontend(const StringView& message) {
    if (per_process::enabled_debug_list.enabled(
            DebugCategory::INSPECTOR_SERVER)) {
      std::string raw_message = protocol::StringUtil::StringViewToUtf8(message);
      per_process::Debug(DebugCategory::INSPECTOR_SERVER,
                         ""[inspector send] %s\n"",
                         raw_message);
    }
    delegate_->SendMessageToFrontend(message);
  }",301.0,310.0,3.0,3.0,10.0,9,3,11,7,0,1,2,2,0,0,,0,1,2,1,1,void
2512,90039,sendMessageToFrontend,1,node.inspector.anonymous_namespace_29.ChannelImpl.sendMessageToFrontend,void node.inspector.anonymous_namespace_29.ChannelImpl.sendMessageToFrontend (ANY),inspector_agent.cc,"void sendMessageToFrontend(const std::string& message) {
    sendMessageToFrontend(Utf8ToStringView(message)->string());
  }",312.0,314.0,3.0,3.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,void
2513,90051,sendProtocolResponse,1,node.inspector.anonymous_namespace_30.ChannelImpl.sendProtocolResponse,"void node.inspector.anonymous_namespace_30.ChannelImpl.sendProtocolResponse (int,ANY)",inspector_agent.cc,"void sendProtocolResponse(int callId,
                            std::unique_ptr<Serializable> message) override {
    sendMessageToFrontend(message->serializeToJSON());
  }",318.0,321.0,3.0,3.0,4.0,1,1,1,1,0,0,1,1,0,0,,0,0,4,2,2,void
2514,90062,sendProtocolNotification,1,node.inspector.anonymous_namespace_31.ChannelImpl.sendProtocolNotification,void node.inspector.anonymous_namespace_31.ChannelImpl.sendProtocolNotification (ANY),inspector_agent.cc,"void sendProtocolNotification(
      std::unique_ptr<Serializable> message) override {
    sendMessageToFrontend(message->serializeToJSON());
  }",322.0,325.0,3.0,3.0,4.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,void
2515,90072,fallThrough,1,node.inspector.anonymous_namespace_32.ChannelImpl.fallThrough,"void node.inspector.anonymous_namespace_32.ChannelImpl.fallThrough (int,ANY,ANY)",inspector_agent.cc,"void fallThrough(int callId,
                   const std::string& method,
                   const std::string& message) override {
    DCHECK(false);
  }",327.0,331.0,3.0,3.0,5.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,void
2516,90090,SameThreadInspectorSession,1,node.inspector.anonymous_namespace_34.SameThreadInspectorSession.SameThreadInspectorSession,"ANY node.inspector.anonymous_namespace_34.SameThreadInspectorSession.SameThreadInspectorSession (int,ANY)",inspector_agent.cc,"SameThreadInspectorSession(
      int session_id, std::shared_ptr<NodeInspectorClient> client)
      : session_id_(session_id), client_(client) {}",345.0,347.0,3.0,51.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,ANY
2517,90096,~SameThreadInspectorSession,1,node.inspector.anonymous_namespace_35.SameThreadInspectorSession.~SameThreadInspectorSession,ANY node.inspector.anonymous_namespace_35.SameThreadInspectorSession.~SameThreadInspectorSession (),inspector_agent.cc,~SameThreadInspectorSession() override;,348.0,348.0,3.0,40.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
2518,90100,Dispatch,1,node.inspector.anonymous_namespace_36.SameThreadInspectorSession.Dispatch,void node.inspector.anonymous_namespace_36.SameThreadInspectorSession.Dispatch (ANY),inspector_agent.cc,void Dispatch(const v8_inspector::StringView& message) override;,349.0,349.0,8.0,65.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
2519,90107,NotifyClusterWorkersDebugEnabled,1,node.inspector.anonymous_namespace_37.NotifyClusterWorkersDebugEnabled,void node.inspector.anonymous_namespace_37.NotifyClusterWorkersDebugEnabled (Environment*),inspector_agent.cc,"void NotifyClusterWorkersDebugEnabled(Environment* env) {
  Isolate* isolate = env->isolate();
  HandleScope handle_scope(isolate);
  Local<Context> context = env->context();

  // Send message to enable debug in cluster workers
  Local<Object> message = Object::New(isolate);
  message->Set(context, FIXED_ONE_BYTE_STRING(isolate, ""cmd""),
               FIXED_ONE_BYTE_STRING(isolate, ""NODE_DEBUG_ENABLED"")).Check();
  ProcessEmit(env, ""internalMessage"", message);
}",356.0,366.0,1.0,1.0,11.0,12,5,18,7,0,0,1,1,0,0,,0,0,2,1,1,void
2520,90161,IsFilePath,1,node.inspector.anonymous_namespace_38.IsFilePath,bool node.inspector.anonymous_namespace_38.IsFilePath (ANY),inspector_agent.cc,"bool IsFilePath(const std::string& path) {
  return !path.empty() && path[0] == '/';
}",381.0,383.0,1.0,1.0,3.0,5,5,2,1,0,0,1,1,0,0,,0,0,2,1,1,bool
2521,90178,ThrowUninitializedInspectorError,1,node.inspector.anonymous_namespace_39.ThrowUninitializedInspectorError,void node.inspector.anonymous_namespace_39.ThrowUninitializedInspectorError (Environment*),inspector_agent.cc,"void ThrowUninitializedInspectorError(Environment* env) {
  HandleScope scope(env->isolate());

  const char* msg = ""This Environment was initialized without a V8::Inspector"";
  Local<Value> exception =
    v8::String::NewFromUtf8(env->isolate(), msg).ToLocalChecked();

  env->isolate()->ThrowException(exception);
}",386.0,394.0,1.0,1.0,9.0,11,5,11,7,0,0,1,1,0,0,,0,0,2,1,1,void
2522,90221,NodeInspectorClient,1,node.inspector.NodeInspectorClient.NodeInspectorClient,"ANY node.inspector.NodeInspectorClient.NodeInspectorClient (ANY*,bool)",inspector_agent.cc,"explicit NodeInspectorClient(node::Environment* env, bool is_main)
      : env_(env), is_main_(is_main) {
    client_ = V8Inspector::create(env->isolate(), this);
    // TODO(bnoordhuis) Make name configurable from src/node.cc.
    std::string name =
        is_main_ ? GetHumanReadableProcessName() : GetWorkerLabel(env);
    ContextInfo info(name);
    info.is_default = true;
    contextCreated(env->context(), info);
  }",400.0,409.0,3.0,3.0,10.0,8,4,10,6,0,2,1,1,0,0,,0,2,4,2,2,ANY
2523,90260,runMessageLoopOnPause,1,node.inspector.NodeInspectorClient.runMessageLoopOnPause,void node.inspector.NodeInspectorClient.runMessageLoopOnPause (int),inspector_agent.cc,"void runMessageLoopOnPause(int context_group_id) override {
    waiting_for_resume_ = true;
    runMessageLoop();
  }",411.0,414.0,3.0,3.0,4.0,1,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,void
2524,90269,waitForSessionsDisconnect,1,node.inspector.NodeInspectorClient.waitForSessionsDisconnect,void node.inspector.NodeInspectorClient.waitForSessionsDisconnect (),inspector_agent.cc,"void waitForSessionsDisconnect() {
    waiting_for_sessions_disconnect_ = true;
    runMessageLoop();
  }",416.0,419.0,3.0,3.0,4.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,void
2525,90277,waitForFrontend,1,node.inspector.NodeInspectorClient.waitForFrontend,void node.inspector.NodeInspectorClient.waitForFrontend (),inspector_agent.cc,"void waitForFrontend() {
    waiting_for_frontend_ = true;
    runMessageLoop();
  }",421.0,424.0,3.0,3.0,4.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,void
2526,90285,maxAsyncCallStackDepthChanged,1,node.inspector.NodeInspectorClient.maxAsyncCallStackDepthChanged,void node.inspector.NodeInspectorClient.maxAsyncCallStackDepthChanged (int),inspector_agent.cc,"void maxAsyncCallStackDepthChanged(int depth) override {
    if (waiting_for_sessions_disconnect_) {
      // V8 isolate is mostly done and is only letting Inspector protocol
      // clients gather data.
      return;
    }
    if (auto agent = env_->inspector_agent()) {
      if (depth == 0) {
        agent->DisableAsyncHook();
      } else {
        agent->EnableAsyncHook();
      }
    }
  }",426.0,439.0,3.0,3.0,14.0,4,3,5,4,0,2,4,5,1,0,,0,2,2,1,1,void
2527,90319,contextCreated,1,node.inspector.NodeInspectorClient.contextCreated,"void node.inspector.NodeInspectorClient.contextCreated (Local<Context>,ContextInfo)",inspector_agent.cc,"void contextCreated(Local<Context> context, const ContextInfo& info) {
    auto name_buffer = Utf8ToStringView(info.name);
    auto origin_buffer = Utf8ToStringView(info.origin);
    std::unique_ptr<StringBuffer> aux_data_buffer;

    v8_inspector::V8ContextInfo v8info(
        context, CONTEXT_GROUP_ID, name_buffer->string());
    v8info.origin = origin_buffer->string();

    if (info.is_default) {
      aux_data_buffer = Utf8ToStringView(""{\""isDefault\"":true}"");
    } else {
      aux_data_buffer = Utf8ToStringView(""{\""isDefault\"":false}"");
    }
    v8info.auxData = aux_data_buffer->string();

    client_->contextCreated(v8info);
  }",441.0,458.0,3.0,3.0,18.0,14,3,15,8,0,1,2,2,0,0,,0,1,4,2,2,void
2528,90384,contextDestroyed,1,node.inspector.NodeInspectorClient.contextDestroyed,void node.inspector.NodeInspectorClient.contextDestroyed (Local<Context>),inspector_agent.cc,"void contextDestroyed(Local<Context> context) {
    client_->contextDestroyed(context);
  }",460.0,462.0,3.0,3.0,3.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
2529,90394,quitMessageLoopOnPause,1,node.inspector.NodeInspectorClient.quitMessageLoopOnPause,void node.inspector.NodeInspectorClient.quitMessageLoopOnPause (),inspector_agent.cc,"void quitMessageLoopOnPause() override {
    waiting_for_resume_ = false;
  }",464.0,466.0,3.0,3.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,void
2530,90401,runIfWaitingForDebugger,1,node.inspector.NodeInspectorClient.runIfWaitingForDebugger,void node.inspector.NodeInspectorClient.runIfWaitingForDebugger (int),inspector_agent.cc,"void runIfWaitingForDebugger(int context_group_id) override {
    waiting_for_frontend_ = false;
  }",468.0,470.0,3.0,3.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,void
2531,90409,connectFrontend,1,node.inspector.NodeInspectorClient.connectFrontend,"int node.inspector.NodeInspectorClient.connectFrontend (ANY,bool)",inspector_agent.cc,"int connectFrontend(std::unique_ptr<InspectorSessionDelegate> delegate,
                      bool prevent_shutdown) {
    int session_id = next_session_id_++;
    channels_[session_id] = std::make_unique<ChannelImpl>(env_,
                                                          client_,
                                                          getWorkerManager(),
                                                          std::move(delegate),
                                                          getThreadHandle(),
                                                          prevent_shutdown);
    return session_id;
  }",472.0,482.0,3.0,3.0,11.0,10,8,12,9,0,4,1,1,0,0,,0,4,4,2,2,int
2532,90444,disconnectFrontend,1,node.inspector.NodeInspectorClient.disconnectFrontend,void node.inspector.NodeInspectorClient.disconnectFrontend (int),inspector_agent.cc,"void disconnectFrontend(int session_id) {
    auto it = channels_.find(session_id);
    if (it == channels_.end())
      return;
    bool retaining_context = it->second->retainingContext();
    channels_.erase(it);
    if (retaining_context) {
      for (const auto& id_channel : channels_) {
        if (id_channel.second->retainingContext())
          return;
      }
      contextDestroyed(env_->context());
    }
    if (waiting_for_sessions_disconnect_ && !is_main_)
      waiting_for_sessions_disconnect_ = false;
  }",484.0,499.0,3.0,3.0,16.0,14,6,16,8,0,8,6,9,4,0,,0,8,2,1,1,void
2533,90510,dispatchMessageFromFrontend,1,node.inspector.NodeInspectorClient.dispatchMessageFromFrontend,"void node.inspector.NodeInspectorClient.dispatchMessageFromFrontend (int,StringView)",inspector_agent.cc,"void dispatchMessageFromFrontend(int session_id, const StringView& message) {
    channels_[session_id]->dispatchProtocolMessage(message);
  }",501.0,503.0,3.0,3.0,3.0,2,2,3,3,0,1,1,1,0,0,,0,1,4,2,2,void
2534,90523,ensureDefaultContextInGroup,1,node.inspector.NodeInspectorClient.ensureDefaultContextInGroup,Local<Context> node.inspector.NodeInspectorClient.ensureDefaultContextInGroup (int),inspector_agent.cc,"Local<Context> ensureDefaultContextInGroup(int contextGroupId) override {
    return env_->context();
  }",505.0,507.0,3.0,3.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,Local<Context>
2535,90533,installAdditionalCommandLineAPI,1,node.inspector.NodeInspectorClient.installAdditionalCommandLineAPI,"void node.inspector.NodeInspectorClient.installAdditionalCommandLineAPI (Local<Context>,Local<Object>)",inspector_agent.cc,"void installAdditionalCommandLineAPI(Local<Context> context,
                                       Local<Object> target) override {
    Local<Function> installer = env_->inspector_console_extension_installer();
    if (!installer.IsEmpty()) {
      Local<Value> argv[] = {target};
      // If there is an exception, proceed in JS land
      USE(installer->Call(context, target, arraysize(argv), argv));
    }
  }",509.0,517.0,3.0,3.0,9.0,9,7,12,7,0,1,2,2,0,0,,0,1,4,2,2,void
2536,90571,ReportUncaughtException,1,node.inspector.NodeInspectorClient.ReportUncaughtException,"void node.inspector.NodeInspectorClient.ReportUncaughtException (Local<Value>,Local<Message>)",inspector_agent.cc,"void ReportUncaughtException(Local<Value> error, Local<Message> message) {
    Isolate* isolate = env_->isolate();
    Local<Context> context = env_->context();

    int script_id = message->GetScriptOrigin().ScriptId();

    Local<v8::StackTrace> stack_trace = message->GetStackTrace();

    if (!stack_trace.IsEmpty() && stack_trace->GetFrameCount() > 0 &&
        script_id == stack_trace->GetFrame(isolate, 0)->GetScriptId()) {
      script_id = 0;
    }

    const uint8_t DETAILS[] = ""Uncaught"";

    client_->exceptionThrown(
        context,
        StringView(DETAILS, sizeof(DETAILS) - 1),
        error,
        ToProtocolString(isolate, message->Get())->string(),
        ToProtocolString(isolate, message->GetScriptResourceName())->string(),
        message->GetLineNumber(context).FromMaybe(0),
        message->GetStartColumn(context).FromMaybe(0),
        client_->createStackTrace(stack_trace),
        script_id);
  }",519.0,544.0,3.0,3.0,26.0,37,10,35,12,0,4,2,2,0,0,,0,4,4,2,2,void
2537,90703,startRepeatingTimer,1,node.inspector.NodeInspectorClient.startRepeatingTimer,"void node.inspector.NodeInspectorClient.startRepeatingTimer (double,TimerCallback,void*)",inspector_agent.cc,"void startRepeatingTimer(double interval_s,
                           TimerCallback callback,
                           void* data) override {
    auto result =
        timers_.emplace(std::piecewise_construct, std::make_tuple(data),
                        std::make_tuple(env_, [=]() { callback(data); }));
    CHECK(result.second);
    uint64_t interval = static_cast<uint64_t>(1000 * interval_s);
    result.first->second.Update(interval, interval);
  }",546.0,555.0,3.0,3.0,10.0,12,5,13,7,0,2,1,1,0,0,,0,2,6,3,3,void
2538,90752,cancelTimer,1,node.inspector.NodeInspectorClient.cancelTimer,void node.inspector.NodeInspectorClient.cancelTimer (void*),inspector_agent.cc,"void cancelTimer(void* data) override {
    timers_.erase(data);
  }",557.0,559.0,3.0,3.0,3.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
2539,90762,AsyncTaskScheduled,1,node.inspector.NodeInspectorClient.AsyncTaskScheduled,"void node.inspector.NodeInspectorClient.AsyncTaskScheduled (StringView,void*,bool)",inspector_agent.cc,"void AsyncTaskScheduled(const StringView& task_name, void* task,
                          bool recurring) {
    client_->asyncTaskScheduled(task_name, task, recurring);
  }",562.0,565.0,3.0,3.0,4.0,1,1,4,4,0,1,1,1,0,0,,0,1,6,3,3,void
2540,90776,AsyncTaskCanceled,1,node.inspector.NodeInspectorClient.AsyncTaskCanceled,void node.inspector.NodeInspectorClient.AsyncTaskCanceled (void*),inspector_agent.cc,"void AsyncTaskCanceled(void* task) {
    client_->asyncTaskCanceled(task);
  }",567.0,569.0,3.0,3.0,3.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
2541,90786,AsyncTaskStarted,1,node.inspector.NodeInspectorClient.AsyncTaskStarted,void node.inspector.NodeInspectorClient.AsyncTaskStarted (void*),inspector_agent.cc,"void AsyncTaskStarted(void* task) {
    client_->asyncTaskStarted(task);
  }",571.0,573.0,3.0,3.0,3.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
2542,90796,AsyncTaskFinished,1,node.inspector.NodeInspectorClient.AsyncTaskFinished,void node.inspector.NodeInspectorClient.AsyncTaskFinished (void*),inspector_agent.cc,"void AsyncTaskFinished(void* task) {
    client_->asyncTaskFinished(task);
  }",575.0,577.0,3.0,3.0,3.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
2543,90806,AllAsyncTasksCanceled,1,node.inspector.NodeInspectorClient.AllAsyncTasksCanceled,void node.inspector.NodeInspectorClient.AllAsyncTasksCanceled (),inspector_agent.cc,"void AllAsyncTasksCanceled() {
    client_->allAsyncTasksCanceled();
  }",579.0,581.0,3.0,3.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,void
2544,90814,schedulePauseOnNextStatement,1,node.inspector.NodeInspectorClient.schedulePauseOnNextStatement,void node.inspector.NodeInspectorClient.schedulePauseOnNextStatement (ANY),inspector_agent.cc,"void schedulePauseOnNextStatement(const std::string& reason) {
    for (const auto& id_channel : channels_) {
      id_channel.second->schedulePauseOnNextStatement(reason);
    }
  }",583.0,587.0,3.0,3.0,5.0,2,2,3,3,0,1,2,2,1,0,,0,1,2,1,1,void
2545,90830,hasConnectedSessions,1,node.inspector.NodeInspectorClient.hasConnectedSessions,bool node.inspector.NodeInspectorClient.hasConnectedSessions (),inspector_agent.cc,"bool hasConnectedSessions() {
    for (const auto& id_channel : channels_) {
      // Other sessions are ""invisible"" more most purposes
      if (id_channel.second->preventShutdown())
        return true;
    }
    return false;
  }",589.0,596.0,3.0,3.0,8.0,2,2,2,2,0,1,3,4,1,0,,0,1,0,0,0,bool
2546,90850,notifyWaitingForDisconnect,1,node.inspector.NodeInspectorClient.notifyWaitingForDisconnect,bool node.inspector.NodeInspectorClient.notifyWaitingForDisconnect (),inspector_agent.cc,"bool notifyWaitingForDisconnect() {
    bool retaining_context = false;
    for (const auto& id_channel : channels_) {
      if (id_channel.second->notifyWaitingForDisconnect())
        retaining_context = true;
    }
    return retaining_context;
  }",598.0,605.0,3.0,3.0,8.0,4,3,5,3,0,1,3,4,1,0,,0,1,0,0,0,bool
2547,90875,getThreadHandle,1,node.inspector.NodeInspectorClient.getThreadHandle,shared_ptr<MainThreadHandle> node.inspector.NodeInspectorClient.getThreadHandle (),inspector_agent.cc,"std::shared_ptr<MainThreadHandle> getThreadHandle() {
    if (!interface_) {
      interface_ = std::make_shared<MainThreadInterface>(
          env_->inspector_agent());
    }
    return interface_->GetHandle();
  }",607.0,613.0,3.0,3.0,7.0,7,6,6,4,0,4,2,2,1,0,,0,4,0,0,0,shared_ptr<MainThreadHandle>
2548,90900,getWorkerManager,1,node.inspector.NodeInspectorClient.getWorkerManager,shared_ptr<WorkerManager> node.inspector.NodeInspectorClient.getWorkerManager (),inspector_agent.cc,"std::shared_ptr<WorkerManager> getWorkerManager() {
    if (!is_main_) {
      return nullptr;
    }
    if (worker_manager_ == nullptr) {
      worker_manager_ =
          std::make_shared<WorkerManager>(getThreadHandle());
    }
    return worker_manager_;
  }",615.0,624.0,3.0,3.0,10.0,6,6,6,4,0,4,3,3,2,0,,0,4,0,0,0,shared_ptr<WorkerManager>
2549,90926,IsActive,1,node.inspector.NodeInspectorClient.IsActive,bool node.inspector.NodeInspectorClient.IsActive (),inspector_agent.cc,"bool IsActive() {
    return !channels_.empty();
  }",626.0,628.0,3.0,3.0,3.0,2,2,1,1,0,1,1,1,0,0,,0,1,0,0,0,bool
2550,90936,shouldRunMessageLoop,1,node.inspector.NodeInspectorClient.shouldRunMessageLoop,bool node.inspector.NodeInspectorClient.shouldRunMessageLoop (),inspector_agent.cc,"bool shouldRunMessageLoop() {
    if (waiting_for_frontend_)
      return true;
    if (waiting_for_sessions_disconnect_ || waiting_for_resume_) {
      return hasConnectedSessions();
    }
    return false;
  }",631.0,638.0,3.0,3.0,8.0,1,1,3,3,0,3,3,3,3,0,,0,3,0,0,0,bool
2551,90954,runMessageLoop,1,node.inspector.NodeInspectorClient.runMessageLoop,void node.inspector.NodeInspectorClient.runMessageLoop (),inspector_agent.cc,"void runMessageLoop() {
    if (running_nested_loop_)
      return;

    running_nested_loop_ = true;

    while (shouldRunMessageLoop()) {
      if (interface_) interface_->WaitForFrontendEvent();
      env_->RunAndClearInterrupts();
    }
    running_nested_loop_ = false;
  }",640.0,651.0,3.0,3.0,12.0,4,2,6,3,0,6,4,5,2,0,,0,6,0,0,0,void
2552,90982,currentTimeMS,1,node.inspector.NodeInspectorClient.currentTimeMS,double node.inspector.NodeInspectorClient.currentTimeMS (),inspector_agent.cc,"double currentTimeMS() override {
    return env_->isolate_data()->platform()->CurrentClockTimeMillis();
  }",653.0,655.0,3.0,3.0,3.0,3,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,double
2553,90997,resourceNameToUrl,1,node.inspector.NodeInspectorClient.resourceNameToUrl,unique_ptr<StringBuffer> node.inspector.NodeInspectorClient.resourceNameToUrl (StringView),inspector_agent.cc,"std::unique_ptr<StringBuffer> resourceNameToUrl(
      const StringView& resource_name_view) override {
    std::string resource_name =
        protocol::StringUtil::StringViewToUtf8(resource_name_view);
    if (!IsFilePath(resource_name))
      return nullptr;

    std::string url = node::url::FromFilePath(resource_name);
    return Utf8ToStringView(url);
  }",657.0,666.0,3.0,3.0,10.0,7,3,10,6,0,1,2,2,0,1,,0,1,2,1,1,unique_ptr<StringBuffer>
2554,91063,Agent,1,node.inspector.Agent.Agent,ANY node.inspector.Agent.Agent (Environment*),inspector_agent.cc,"Agent::Agent(Environment* env)
    : parent_env_(env),
      debug_options_(env->options()->debug_options()),
      host_port_(env->inspector_host_port()) {}",684.0,687.0,1.0,47.0,4.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
2555,91068,~Agent,1,node.inspector.Agent.~Agent,ANY node.inspector.Agent.~Agent (),inspector_agent.cc,Agent::~Agent() {},689.0,689.0,1.0,18.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
2556,91072,Start,1,node.inspector.Agent.Start,"bool node.inspector.Agent.Start (ANY,DebugOptions,ANY,bool)",inspector_agent.cc,"bool Agent::Start(const std::string& path,
                  const DebugOptions& options,
                  std::shared_ptr<ExclusiveAccess<HostPort>> host_port,
                  bool is_main) {
  path_ = path;
  debug_options_ = options;
  CHECK_NOT_NULL(host_port);
  host_port_ = host_port;

  client_ = std::make_shared<NodeInspectorClient>(parent_env_, is_main);
  if (parent_env_->owns_inspector()) {
    Mutex::ScopedLock lock(start_io_thread_async_mutex);
    CHECK_EQ(start_io_thread_async_initialized.exchange(true), false);
    CHECK_EQ(0, uv_async_init(parent_env_->event_loop(),
                              &start_io_thread_async,
                              StartIoThreadAsyncCallback));
    uv_unref(reinterpret_cast<uv_handle_t*>(&start_io_thread_async));
    start_io_thread_async.data = this;
    // Ignore failure, SIGUSR1 won't work, but that should not block node start.
    StartDebugSignalHandler();

    parent_env_->AddCleanupHook([](void* data) {
      Environment* ...",691.0,752.0,1.0,1.0,62.0,31,10,37,17,0,0,4,4,0,0,,0,0,8,4,4,bool
2557,91222,StartIoThread,1,node.inspector.Agent.StartIoThread,bool node.inspector.Agent.StartIoThread (),inspector_agent.cc,"bool Agent::StartIoThread() {
  if (io_ != nullptr)
    return true;

  if (!parent_env_->should_create_inspector() && !client_) {
    ThrowUninitializedInspectorError(parent_env_);
    return false;
  }

  CHECK_NOT_NULL(client_);

  io_ = InspectorIo::Start(client_->getThreadHandle(),
                           path_,
                           host_port_,
                           debug_options_.inspect_publish_uid);
  if (io_ == nullptr) {
    return false;
  }
  NotifyClusterWorkersDebugEnabled(parent_env_);
  return true;
}",754.0,774.0,1.0,1.0,21.0,10,7,10,7,0,0,4,4,0,0,,0,0,0,0,0,bool
2558,91272,Stop,1,node.inspector.Agent.Stop,void node.inspector.Agent.Stop (),inspector_agent.cc,"void Agent::Stop() {
  io_.reset();
}",776.0,778.0,1.0,1.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
2559,91280,Connect,1,node.inspector.Agent.Connect,"unique_ptr<InspectorSession> node.inspector.Agent.Connect (ANY,bool)",inspector_agent.cc,"std::unique_ptr<InspectorSession> Agent::Connect(
    std::unique_ptr<InspectorSessionDelegate> delegate,
    bool prevent_shutdown) {
  if (!parent_env_->should_create_inspector() && !client_) {
    ThrowUninitializedInspectorError(parent_env_);
    return std::unique_ptr<InspectorSession>{};
  }

  CHECK_NOT_NULL(client_);

  int session_id = client_->connectFrontend(std::move(delegate),
                                            prevent_shutdown);
  return std::unique_ptr<InspectorSession>(
      new SameThreadInspectorSession(session_id, client_));
}",780.0,794.0,1.0,1.0,15.0,12,9,12,8,0,0,2,2,0,0,,0,0,4,2,2,unique_ptr<InspectorSession>
2560,91325,ConnectToMainThread,1,node.inspector.Agent.ConnectToMainThread,"unique_ptr<InspectorSession> node.inspector.Agent.ConnectToMainThread (ANY,bool)",inspector_agent.cc,"std::unique_ptr<InspectorSession> Agent::ConnectToMainThread(
    std::unique_ptr<InspectorSessionDelegate> delegate,
    bool prevent_shutdown) {
  if (!parent_env_->should_create_inspector() && !client_) {
    ThrowUninitializedInspectorError(parent_env_);
    return std::unique_ptr<InspectorSession>{};
  }

  CHECK_NOT_NULL(parent_handle_);
  CHECK_NOT_NULL(client_);
  auto thread_safe_delegate =
      client_->getThreadHandle()->MakeDelegateThreadSafe(std::move(delegate));
  return parent_handle_->Connect(std::move(thread_safe_delegate),
                                 prevent_shutdown);
}",796.0,810.0,1.0,1.0,15.0,11,6,10,7,0,0,2,2,0,0,,0,0,4,2,2,unique_ptr<InspectorSession>
2561,91373,WaitForDisconnect,1,node.inspector.Agent.WaitForDisconnect,void node.inspector.Agent.WaitForDisconnect (),inspector_agent.cc,"void Agent::WaitForDisconnect() {
  if (!parent_env_->should_create_inspector() && !client_) {
    ThrowUninitializedInspectorError(parent_env_);
    return;
  }

  CHECK_NOT_NULL(client_);
  bool is_worker = parent_handle_ != nullptr;
  parent_handle_.reset();
  if (client_->hasConnectedSessions() && !is_worker) {
    fprintf(stderr, ""Waiting for the debugger to disconnect...\n"");
    fflush(stderr);
  }
  if (!client_->notifyWaitingForDisconnect()) {
    client_->contextDestroyed(parent_env_->context());
  } else if (is_worker) {
    client_->waitForSessionsDisconnect();
  }
  if (io_ != nullptr) {
    io_->StopAcceptingNewConnections();
    client_->waitForSessionsDisconnect();
  }
}",812.0,834.0,1.0,1.0,23.0,17,6,14,6,0,0,5,5,0,0,,0,0,0,0,0,void
2562,91450,ReportUncaughtException,1,node.inspector.Agent.ReportUncaughtException,"void node.inspector.Agent.ReportUncaughtException (Local<Value>,Local<Message>)",inspector_agent.cc,"void Agent::ReportUncaughtException(Local<Value> error,
                                    Local<Message> message) {
  if (!IsListening())
    return;
  client_->ReportUncaughtException(error, message);
  WaitForDisconnect();
}",836.0,842.0,1.0,1.0,7.0,2,2,3,3,0,0,2,2,0,0,,0,0,4,2,2,void
2563,91468,PauseOnNextJavascriptStatement,1,node.inspector.Agent.PauseOnNextJavascriptStatement,void node.inspector.Agent.PauseOnNextJavascriptStatement (ANY),inspector_agent.cc,"void Agent::PauseOnNextJavascriptStatement(const std::string& reason) {
  client_->schedulePauseOnNextStatement(reason);
}",844.0,846.0,1.0,1.0,3.0,1,1,2,2,0,0,1,1,0,0,,0,0,2,1,1,void
2564,91478,RegisterAsyncHook,1,node.inspector.Agent.RegisterAsyncHook,"void node.inspector.Agent.RegisterAsyncHook (Isolate*,Local<Function>,Local<Function>)",inspector_agent.cc,"void Agent::RegisterAsyncHook(Isolate* isolate,
                              Local<Function> enable_function,
                              Local<Function> disable_function) {
  parent_env_->set_inspector_enable_async_hooks(enable_function);
  parent_env_->set_inspector_disable_async_hooks(disable_function);
  if (pending_enable_async_hook_) {
    CHECK(!pending_disable_async_hook_);
    pending_enable_async_hook_ = false;
    EnableAsyncHook();
  } else if (pending_disable_async_hook_) {
    CHECK(!pending_enable_async_hook_);
    pending_disable_async_hook_ = false;
    DisableAsyncHook();
  }
}",848.0,862.0,1.0,1.0,15.0,4,3,7,5,0,0,2,2,0,0,,0,0,6,3,3,void
2565,91517,EnableAsyncHook,1,node.inspector.Agent.EnableAsyncHook,void node.inspector.Agent.EnableAsyncHook (),inspector_agent.cc,"void Agent::EnableAsyncHook() {
  HandleScope scope(parent_env_->isolate());
  Local<Function> enable = parent_env_->inspector_enable_async_hooks();
  if (!enable.IsEmpty()) {
    ToggleAsyncHook(parent_env_->isolate(), enable);
  } else if (pending_disable_async_hook_) {
    CHECK(!pending_enable_async_hook_);
    pending_disable_async_hook_ = false;
  } else {
    pending_enable_async_hook_ = true;
  }
}",864.0,875.0,1.0,1.0,12.0,8,6,8,4,0,0,2,2,0,0,,0,0,0,0,0,void
2566,91566,DisableAsyncHook,1,node.inspector.Agent.DisableAsyncHook,void node.inspector.Agent.DisableAsyncHook (),inspector_agent.cc,"void Agent::DisableAsyncHook() {
  HandleScope scope(parent_env_->isolate());
  Local<Function> disable = parent_env_->inspector_enable_async_hooks();
  if (!disable.IsEmpty()) {
    ToggleAsyncHook(parent_env_->isolate(), disable);
  } else if (pending_enable_async_hook_) {
    CHECK(!pending_disable_async_hook_);
    pending_enable_async_hook_ = false;
  } else {
    pending_disable_async_hook_ = true;
  }
}",877.0,888.0,1.0,1.0,12.0,8,6,8,4,0,0,2,2,0,0,,0,0,0,0,0,void
2567,91615,ToggleAsyncHook,1,node.inspector.Agent.ToggleAsyncHook,"void node.inspector.Agent.ToggleAsyncHook (Isolate*,Local<Function>)",inspector_agent.cc,"void Agent::ToggleAsyncHook(Isolate* isolate, Local<Function> fn) {
  // Guard against running this during cleanup -- no async events will be
  // emitted anyway at that point anymore, and calling into JS is not possible.
  // This should probably not be something we're attempting in the first place,
  // Refs: https://github.com/nodejs/node/pull/34362#discussion_r456006039
  if (!parent_env_->can_call_into_js()) return;
  CHECK(parent_env_->has_run_bootstrapping_code());
  HandleScope handle_scope(isolate);
  CHECK(!fn.IsEmpty());
  auto context = parent_env_->context();
  v8::TryCatch try_catch(isolate);
  USE(fn->Call(context, Undefined(isolate), 0, nullptr));
  if (try_catch.HasCaught() && !try_catch.HasTerminated()) {
    PrintCaughtException(isolate, context, try_catch);
    OnFatalError(""\nnode::inspector::Agent::ToggleAsyncHook"",
                 ""Cannot toggle Inspector's AsyncHook, please report this."");
  }
}",890.0,907.0,1.0,1.0,18.0,12,5,15,5,0,0,3,3,0,0,,0,0,4,2,2,void
2568,91682,AsyncTaskScheduled,1,node.inspector.Agent.AsyncTaskScheduled,"void node.inspector.Agent.AsyncTaskScheduled (StringView,void*,bool)",inspector_agent.cc,"void Agent::AsyncTaskScheduled(const StringView& task_name, void* task,
                               bool recurring) {
  client_->AsyncTaskScheduled(task_name, task, recurring);
}",909.0,912.0,1.0,1.0,4.0,1,1,4,4,0,0,1,1,0,0,,0,0,6,3,3,void
2569,91696,AsyncTaskCanceled,1,node.inspector.Agent.AsyncTaskCanceled,void node.inspector.Agent.AsyncTaskCanceled (void*),inspector_agent.cc,"void Agent::AsyncTaskCanceled(void* task) {
  client_->AsyncTaskCanceled(task);
}",914.0,916.0,1.0,1.0,3.0,1,1,2,2,0,0,1,1,0,0,,0,0,2,1,1,void
2570,91706,AsyncTaskStarted,1,node.inspector.Agent.AsyncTaskStarted,void node.inspector.Agent.AsyncTaskStarted (void*),inspector_agent.cc,"void Agent::AsyncTaskStarted(void* task) {
  client_->AsyncTaskStarted(task);
}",918.0,920.0,1.0,1.0,3.0,1,1,2,2,0,0,1,1,0,0,,0,0,2,1,1,void
2571,91716,AsyncTaskFinished,1,node.inspector.Agent.AsyncTaskFinished,void node.inspector.Agent.AsyncTaskFinished (void*),inspector_agent.cc,"void Agent::AsyncTaskFinished(void* task) {
  client_->AsyncTaskFinished(task);
}",922.0,924.0,1.0,1.0,3.0,1,1,2,2,0,0,1,1,0,0,,0,0,2,1,1,void
2572,91726,AllAsyncTasksCanceled,1,node.inspector.Agent.AllAsyncTasksCanceled,void node.inspector.Agent.AllAsyncTasksCanceled (),inspector_agent.cc,"void Agent::AllAsyncTasksCanceled() {
  client_->AllAsyncTasksCanceled();
}",926.0,928.0,1.0,1.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
2573,91734,RequestIoThreadStart,1,node.inspector.Agent.RequestIoThreadStart,void node.inspector.Agent.RequestIoThreadStart (),inspector_agent.cc,"void Agent::RequestIoThreadStart() {
  // We need to attempt to interrupt V8 flow (in case Node is running
  // continuous JS code) and to wake up libuv thread (in case Node is waiting
  // for IO events)
  if (!options().allow_attaching_debugger) {
    return;
  }
  CHECK(start_io_thread_async_initialized);
  uv_async_send(&start_io_thread_async);
  parent_env_->RequestInterrupt([this](Environment*) {
    StartIoThread();
  });

  CHECK(start_io_thread_async_initialized);
  uv_async_send(&start_io_thread_async);
}",930.0,945.0,1.0,1.0,16.0,4,4,3,3,0,0,2,2,0,0,,0,0,0,0,0,void
2574,91757,ContextCreated,1,node.inspector.Agent.ContextCreated,"void node.inspector.Agent.ContextCreated (Local<Context>,ContextInfo)",inspector_agent.cc,"void Agent::ContextCreated(Local<Context> context, const ContextInfo& info) {
  if (client_ == nullptr)  // This happens for a main context
    return;
  client_->contextCreated(context, info);
}",947.0,951.0,1.0,1.0,5.0,2,2,4,3,0,0,2,2,0,0,,0,0,4,2,2,void
2575,91775,IsActive,1,node.inspector.Agent.IsActive,bool node.inspector.Agent.IsActive (),inspector_agent.cc,"bool Agent::IsActive() {
  if (client_ == nullptr)
    return false;
  return io_ != nullptr || client_->IsActive();
}",953.0,957.0,1.0,1.0,5.0,4,4,3,2,0,0,2,2,0,0,,0,0,0,0,0,bool
2576,91795,SetParentHandle,1,node.inspector.Agent.SetParentHandle,void node.inspector.Agent.SetParentHandle (ANY),inspector_agent.cc,"void Agent::SetParentHandle(
    std::unique_ptr<ParentInspectorHandle> parent_handle) {
  parent_handle_ = std::move(parent_handle);
}",959.0,962.0,1.0,1.0,4.0,2,2,3,3,0,0,1,1,0,0,,0,0,2,1,1,void
2577,91807,GetParentHandle,1,node.inspector.Agent.GetParentHandle,"unique_ptr<ParentInspectorHandle> node.inspector.Agent.GetParentHandle (uint64_t,ANY,ANY)",inspector_agent.cc,"std::unique_ptr<ParentInspectorHandle> Agent::GetParentHandle(
    uint64_t thread_id, const std::string& url, const std::string& name) {
  if (!parent_env_->should_create_inspector() && !client_) {
    ThrowUninitializedInspectorError(parent_env_);
    return std::unique_ptr<ParentInspectorHandle>{};
  }

  CHECK_NOT_NULL(client_);
  if (!parent_handle_) {
    return client_->getWorkerManager()->NewParentHandle(thread_id, url, name);
  } else {
    return parent_handle_->NewParentInspectorHandle(thread_id, url, name);
  }
}",964.0,977.0,1.0,1.0,14.0,8,4,7,6,0,0,3,3,0,0,,0,0,6,3,3,unique_ptr<ParentInspectorHandle>
2578,91854,WaitForConnect,1,node.inspector.Agent.WaitForConnect,void node.inspector.Agent.WaitForConnect (),inspector_agent.cc,"void Agent::WaitForConnect() {
  if (!parent_env_->should_create_inspector() && !client_) {
    ThrowUninitializedInspectorError(parent_env_);
    return;
  }

  CHECK_NOT_NULL(client_);
  client_->waitForFrontend();
}",979.0,987.0,1.0,1.0,9.0,5,3,3,2,0,0,2,2,0,0,,0,0,0,0,0,void
2579,91875,GetWorkerManager,1,node.inspector.Agent.GetWorkerManager,shared_ptr<WorkerManager> node.inspector.Agent.GetWorkerManager (),inspector_agent.cc,"std::shared_ptr<WorkerManager> Agent::GetWorkerManager() {
  if (!parent_env_->should_create_inspector() && !client_) {
    ThrowUninitializedInspectorError(parent_env_);
    return std::unique_ptr<WorkerManager>{};
  }

  CHECK_NOT_NULL(client_);
  return client_->getWorkerManager();
}",989.0,997.0,1.0,1.0,9.0,6,4,3,2,0,0,2,2,0,0,,0,0,0,0,0,shared_ptr<WorkerManager>
2580,91899,GetWsUrl,1,node.inspector.Agent.GetWsUrl,string node.inspector.Agent.GetWsUrl (),inspector_agent.cc,"std::string Agent::GetWsUrl() const {
  if (io_ == nullptr)
    return """";
  return io_->GetWsUrl();
}",999.0,1003.0,1.0,1.0,5.0,2,2,2,1,0,0,2,2,0,0,,0,0,0,0,0,string
2581,91915,~SameThreadInspectorSession,1,node.inspector.SameThreadInspectorSession.~SameThreadInspectorSession,ANY node.inspector.SameThreadInspectorSession.~SameThreadInspectorSession (),inspector_agent.cc,"SameThreadInspectorSession::~SameThreadInspectorSession() {
  auto client = client_.lock();
  if (client)
    client->disconnectFrontend(session_id_);
}",1005.0,1009.0,1.0,1.0,5.0,3,3,5,3,0,0,2,2,0,0,,0,0,0,0,0,ANY
2582,91934,Dispatch,1,node.inspector.SameThreadInspectorSession.Dispatch,void node.inspector.SameThreadInspectorSession.Dispatch (ANY),inspector_agent.cc,"void SameThreadInspectorSession::Dispatch(
    const v8_inspector::StringView& message) {
  auto client = client_.lock();
  if (client)
    client->dispatchMessageFromFrontend(session_id_, message);
}",1011.0,1016.0,1.0,1.0,6.0,3,3,6,4,0,0,2,2,0,0,,0,0,2,1,1,void
2583,91969,<lambda>0,1,node.inspector.anonymous_namespace_11.RequestQueueData.RequestQueueData.<lambda>0,ANY node.inspector.anonymous_namespace_11.RequestQueueData.RequestQueueData.<lambda>0 (uv_async_t*),inspector_io.cc,"[](uv_async_t* async) {
      RequestQueueData* wrapper =
          node::ContainerOf(&RequestQueueData::async_, async);
      wrapper->DoDispatch();
    }",101.0,105.0,44.0,5.0,5.0,5,4,5,4,0,1,1,1,0,0,,0,1,2,1,1,ANY
2584,91992,<lambda>1,1,node.inspector.RequestQueueData.CloseAndFree.<lambda>1,ANY node.inspector.RequestQueueData.CloseAndFree.<lambda>1 (uv_handle_t*),inspector_io.cc,"[](uv_handle_t* handle) {
    uv_async_t* async = reinterpret_cast<uv_async_t*>(handle);
    RequestQueueData* wrapper =
        node::ContainerOf(&RequestQueueData::async_, async);
    delete wrapper;
  }",376.0,381.0,12.0,3.0,6.0,7,5,7,5,0,1,1,1,0,0,,0,1,2,1,1,ANY
2585,92061,ScriptPath,1,node.inspector.anonymous_namespace_4.ScriptPath,"string node.inspector.anonymous_namespace_4.ScriptPath (uv_loop_t*,ANY)",inspector_io.cc,"std::string ScriptPath(uv_loop_t* loop, const std::string& script_name) {
  std::string script_path;

  if (!script_name.empty()) {
    uv_fs_t req;
    req.ptr = nullptr;
    if (0 == uv_fs_realpath(loop, &req, script_name.c_str(), nullptr)) {
      CHECK_NOT_NULL(req.ptr);
      script_path = std::string(static_cast<char*>(req.ptr));
    }
    uv_fs_req_cleanup(&req);
  }

  return script_path;
}",29.0,43.0,1.0,1.0,15.0,13,6,11,5,0,0,3,4,0,0,,0,0,4,2,2,string
2586,92114,GenerateID,1,node.inspector.anonymous_namespace_5.GenerateID,string node.inspector.anonymous_namespace_5.GenerateID (),inspector_io.cc,"std::string GenerateID() {
  uint16_t buffer[8];
  CHECK(crypto::CSPRNG(buffer, sizeof(buffer)).is_ok());

  char uuid[256];
  snprintf(uuid, sizeof(uuid), ""%04x%04x-%04x-%04x-%04x-%04x%04x%04x"",
           buffer[0],  // time_low
           buffer[1],  // time_mid
           buffer[2],  // time_low
           (buffer[3] & 0x0fff) | 0x4000,  // time_hi_and_version
           (buffer[4] & 0x3fff) | 0x8000,  // clk_seq_hi clk_seq_low
           buffer[5],  // node
           buffer[6],
           buffer[7]);
  return uuid;
}",47.0,62.0,1.0,1.0,16.0,16,5,14,3,0,0,1,1,0,0,,0,0,0,0,0,string
2587,92171,RequestToServer,1,node.inspector.anonymous_namespace_7.RequestToServer.RequestToServer,"ANY node.inspector.anonymous_namespace_7.RequestToServer.RequestToServer (TransportAction,int,ANY)",inspector_io.cc,"RequestToServer(TransportAction action,
                  int session_id,
                  std::unique_ptr<v8_inspector::StringBuffer> message)
                  : action_(action),
                    session_id_(session_id),
                    message_(std::move(message)) {}",66.0,71.0,3.0,51.0,6.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,ANY
2588,92178,Dispatch,1,node.inspector.anonymous_namespace_8.RequestToServer.Dispatch,void node.inspector.anonymous_namespace_8.RequestToServer.Dispatch (InspectorSocketServer*),inspector_io.cc,"void Dispatch(InspectorSocketServer* server) const {
    switch (action_) {
      case TransportAction::kKill:
        server->TerminateConnections();
        [[fallthrough]];
      case TransportAction::kStop:
        server->Stop();
        break;
      case TransportAction::kSendMessage:
        server->Send(
            session_id_,
            protocol::StringUtil::StringViewToUtf8(message_->string()));
        break;
    }
  }",73.0,87.0,3.0,3.0,15.0,9,2,11,7,0,6,4,2,1,0,,0,6,2,1,1,void
2589,92227,RequestQueueData,1,node.inspector.anonymous_namespace_10.RequestQueueData.RequestQueueData,ANY node.inspector.anonymous_namespace_10.RequestQueueData.RequestQueueData (uv_loop_t*),inspector_io.cc,"explicit RequestQueueData(uv_loop_t* loop)
                            : handle_(std::make_shared<RequestQueue>(this)) {
    int err = uv_async_init(loop, &async_, [](uv_async_t* async) {
      RequestQueueData* wrapper =
          node::ContainerOf(&RequestQueueData::async_, async);
      wrapper->DoDispatch();
    });
    CHECK_EQ(0, err);
  }",99.0,107.0,3.0,3.0,9.0,2,2,4,3,0,1,1,1,0,0,,0,1,2,1,1,ANY
2590,92243,CloseAndFree,1,node.inspector.anonymous_namespace_12.RequestQueueData.CloseAndFree,void node.inspector.anonymous_namespace_12.RequestQueueData.CloseAndFree (RequestQueueData*),inspector_io.cc,static void CloseAndFree(RequestQueueData* queue);,109.0,109.0,15.0,51.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
2591,92248,Post,1,node.inspector.anonymous_namespace_13.RequestQueueData.Post,"void node.inspector.anonymous_namespace_13.RequestQueueData.Post (int,TransportAction,ANY)",inspector_io.cc,"void Post(int session_id,
            TransportAction action,
            std::unique_ptr<StringBuffer> message) {
    Mutex::ScopedLock scoped_lock(state_lock_);
    bool notify = messages_.empty();
    messages_.emplace_back(action, session_id, std::move(message));
    if (notify) {
      CHECK_EQ(0, uv_async_send(&async_));
      incoming_message_cond_.Broadcast(scoped_lock);
    }
  }",111.0,121.0,3.0,3.0,11.0,6,3,12,10,0,5,2,2,0,0,,0,5,6,3,3,void
2592,92289,Wait,1,node.inspector.anonymous_namespace_14.RequestQueueData.Wait,void node.inspector.anonymous_namespace_14.RequestQueueData.Wait (),inspector_io.cc,"void Wait() {
    Mutex::ScopedLock scoped_lock(state_lock_);
    if (messages_.empty()) {
      incoming_message_cond_.Wait(scoped_lock);
    }
  }",123.0,128.0,3.0,3.0,6.0,2,1,4,4,0,3,2,2,1,0,,0,3,0,0,0,void
2593,92307,SetServer,1,node.inspector.anonymous_namespace_15.RequestQueueData.SetServer,void node.inspector.anonymous_namespace_15.RequestQueueData.SetServer (InspectorSocketServer*),inspector_io.cc,"void SetServer(InspectorSocketServer* server) {
    server_ = server;
  }",130.0,132.0,3.0,3.0,3.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
2594,92315,handle,1,node.inspector.anonymous_namespace_16.RequestQueueData.handle,shared_ptr<RequestQueue> node.inspector.anonymous_namespace_16.RequestQueueData.handle (),inspector_io.cc,"std::shared_ptr<RequestQueue> handle() {
    return handle_;
  }",134.0,136.0,3.0,3.0,3.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,shared_ptr<RequestQueue>
2595,92321,~RequestQueueData,1,node.inspector.anonymous_namespace_17.RequestQueueData.~RequestQueueData,ANY node.inspector.anonymous_namespace_17.RequestQueueData.~RequestQueueData (),inspector_io.cc,~RequestQueueData() = default;,139.0,139.0,3.0,32.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
2596,92325,GetMessages,1,node.inspector.anonymous_namespace_18.RequestQueueData.GetMessages,MessageQueue node.inspector.anonymous_namespace_18.RequestQueueData.GetMessages (),inspector_io.cc,"MessageQueue GetMessages() {
    Mutex::ScopedLock scoped_lock(state_lock_);
    MessageQueue messages;
    messages_.swap(messages);
    return messages;
  }",141.0,146.0,3.0,3.0,6.0,1,1,4,3,0,2,1,1,0,0,,0,2,0,0,0,MessageQueue
2597,92340,DoDispatch,1,node.inspector.anonymous_namespace_19.RequestQueueData.DoDispatch,void node.inspector.anonymous_namespace_19.RequestQueueData.DoDispatch (),inspector_io.cc,"void DoDispatch() {
    if (server_ == nullptr)
      return;
    for (const auto& request : GetMessages()) {
      request.Dispatch(server_);
    }
  }",148.0,154.0,3.0,3.0,7.0,2,2,3,2,0,2,3,3,1,0,,0,2,0,0,0,void
2598,92373,RequestQueue,1,node.inspector.RequestQueue.RequestQueue,ANY node.inspector.RequestQueue.RequestQueue (RequestQueueData*),inspector_io.cc,explicit RequestQueue(RequestQueueData* data) : data_(data) {},167.0,167.0,3.0,64.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
2599,92378,Reset,1,node.inspector.RequestQueue.Reset,void node.inspector.RequestQueue.Reset (),inspector_io.cc,"void Reset() {
    Mutex::ScopedLock scoped_lock(lock_);
    data_ = nullptr;
  }",169.0,172.0,3.0,3.0,4.0,1,1,2,2,0,2,1,1,0,0,,0,2,0,0,0,void
2600,92388,Post,1,node.inspector.RequestQueue.Post,"void node.inspector.RequestQueue.Post (int,TransportAction,ANY)",inspector_io.cc,"void Post(int session_id,
            TransportAction action,
            std::unique_ptr<StringBuffer> message) {
    Mutex::ScopedLock scoped_lock(lock_);
    if (data_ != nullptr)
      data_->Post(session_id, action, std::move(message));
  }",174.0,180.0,3.0,3.0,7.0,3,3,7,6,0,3,2,2,1,0,,0,3,6,3,3,void
2601,92414,Expired,1,node.inspector.RequestQueue.Expired,bool node.inspector.RequestQueue.Expired (),inspector_io.cc,"bool Expired() {
    Mutex::ScopedLock scoped_lock(lock_);
    return data_ == nullptr;
  }",182.0,185.0,3.0,3.0,4.0,1,1,2,2,0,2,1,1,0,0,,0,2,0,0,0,bool
2602,92428,IoSessionDelegate,1,node.inspector.IoSessionDelegate.IoSessionDelegate,"ANY node.inspector.IoSessionDelegate.IoSessionDelegate (ANY,int)",inspector_io.cc,"explicit IoSessionDelegate(std::shared_ptr<RequestQueue> queue, int id)
                             : request_queue_(queue), id_(id) { }",194.0,195.0,3.0,65.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,ANY
2603,92434,SendMessageToFrontend,1,node.inspector.IoSessionDelegate.SendMessageToFrontend,void node.inspector.IoSessionDelegate.SendMessageToFrontend (ANY),inspector_io.cc,"void SendMessageToFrontend(const v8_inspector::StringView& message) override {
    request_queue_->Post(id_, TransportAction::kSendMessage,
                         StringBuffer::create(message));
  }",196.0,199.0,3.0,3.0,4.0,3,2,5,5,0,3,1,1,0,0,,0,3,2,1,1,void
2604,92455,InspectorIoDelegate,1,node.inspector.InspectorIoDelegate.InspectorIoDelegate,"ANY node.inspector.InspectorIoDelegate.InspectorIoDelegate (ANY,ANY,ANY,ANY,ANY)",inspector_io.cc,"InspectorIoDelegate::InspectorIoDelegate(
    std::shared_ptr<RequestQueueData> queue,
    std::shared_ptr<MainThreadHandle> main_thread,
    const std::string& target_id,
    const std::string& script_path,
    const std::string& script_name)
    : request_queue_(queue), main_thread_(main_thread),
      script_name_(script_name), script_path_(script_path),
      target_id_(target_id) {}",327.0,335.0,1.0,30.0,9.0,0,0,0,0,0,0,1,1,0,0,,0,0,10,5,5,ANY
2605,92464,~InspectorIoDelegate,1,node.inspector.InspectorIoDelegate.~InspectorIoDelegate,ANY node.inspector.InspectorIoDelegate.~InspectorIoDelegate (),inspector_io.cc,~InspectorIoDelegate() override = default;,215.0,215.0,3.0,44.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
2606,92468,StartSession,1,node.inspector.InspectorIoDelegate.StartSession,"void node.inspector.InspectorIoDelegate.StartSession (int,ANY)",inspector_io.cc,"void InspectorIoDelegate::StartSession(int session_id,
                                       const std::string& target_id) {
  auto session = main_thread_->Connect(
      std::unique_ptr<InspectorSessionDelegate>(
          new IoSessionDelegate(request_queue_->handle(), session_id)), true);
  if (session) {
    sessions_[session_id] = std::move(session);
    fprintf(stderr, ""Debugger attached.\n"");
  }
}",337.0,346.0,1.0,1.0,10.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
2607,92474,MessageReceived,1,node.inspector.InspectorIoDelegate.MessageReceived,"void node.inspector.InspectorIoDelegate.MessageReceived (int,ANY)",inspector_io.cc,"void InspectorIoDelegate::MessageReceived(int session_id,
                                          const std::string& message) {
  auto session = sessions_.find(session_id);
  if (session != sessions_.end())
    session->second->Dispatch(Utf8ToStringView(message)->string());
}",348.0,353.0,1.0,1.0,6.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
2608,92480,EndSession,1,node.inspector.InspectorIoDelegate.EndSession,void node.inspector.InspectorIoDelegate.EndSession (int),inspector_io.cc,"void InspectorIoDelegate::EndSession(int session_id) {
  sessions_.erase(session_id);
}",355.0,357.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
2609,92485,GetTargetIds,1,node.inspector.InspectorIoDelegate.GetTargetIds,ANY node.inspector.InspectorIoDelegate.GetTargetIds (),inspector_io.cc,"std::vector<std::string> InspectorIoDelegate::GetTargetIds() {
  return { target_id_ };
}",359.0,361.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,vector<std.string>
2610,92489,GetTargetTitle,1,node.inspector.InspectorIoDelegate.GetTargetTitle,ANY node.inspector.InspectorIoDelegate.GetTargetTitle (ANY),inspector_io.cc,"std::string InspectorIoDelegate::GetTargetTitle(const std::string& id) {
  return script_name_.empty() ? GetHumanReadableProcessName() : script_name_;
}",363.0,365.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,string
2611,92494,GetTargetUrl,1,node.inspector.InspectorIoDelegate.GetTargetUrl,ANY node.inspector.InspectorIoDelegate.GetTargetUrl (ANY),inspector_io.cc,"std::string InspectorIoDelegate::GetTargetUrl(const std::string& id) {
  return ""file://"" + script_path_;
}",367.0,369.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,string
2612,92499,AssignServer,1,node.inspector.InspectorIoDelegate.AssignServer,void node.inspector.InspectorIoDelegate.AssignServer (InspectorSocketServer*),inspector_io.cc,"void AssignServer(InspectorSocketServer* server) override {
    request_queue_->SetServer(server);
  }",224.0,226.0,3.0,3.0,3.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
2613,92515,Start,1,node.inspector.InspectorIo.Start,"unique_ptr<InspectorIo> node.inspector.InspectorIo.Start (ANY,ANY,ANY,InspectPublishUid)",inspector_io.cc,"std::unique_ptr<InspectorIo> InspectorIo::Start(
    std::shared_ptr<MainThreadHandle> main_thread,
    const std::string& path,
    std::shared_ptr<ExclusiveAccess<HostPort>> host_port,
    const InspectPublishUid& inspect_publish_uid) {
  auto io = std::unique_ptr<InspectorIo>(
      new InspectorIo(main_thread,
                      path,
                      host_port,
                      inspect_publish_uid));
  if (io->request_queue_->Expired()) {  // Thread is not running
    return nullptr;
  }
  return io;
}",238.0,252.0,1.0,1.0,15.0,7,6,10,7,0,0,2,2,0,0,,0,0,8,4,4,unique_ptr<InspectorIo>
2614,92550,InspectorIo,1,node.inspector.InspectorIo.InspectorIo,"ANY node.inspector.InspectorIo.InspectorIo (ANY,ANY,ANY,InspectPublishUid)",inspector_io.cc,"InspectorIo::InspectorIo(std::shared_ptr<MainThreadHandle> main_thread,
                         const std::string& path,
                         std::shared_ptr<ExclusiveAccess<HostPort>> host_port,
                         const InspectPublishUid& inspect_publish_uid)
    : main_thread_(main_thread),
      host_port_(host_port),
      inspect_publish_uid_(inspect_publish_uid),
      thread_(),
      script_name_(path),
      id_(GenerateID()) {
  Mutex::ScopedLock scoped_lock(thread_start_lock_);
  CHECK_EQ(uv_thread_create(&thread_, InspectorIo::ThreadMain, this), 0);
  thread_start_condition_.Wait(scoped_lock);
}",254.0,267.0,1.0,1.0,14.0,3,2,5,5,0,0,1,1,0,0,,0,0,8,4,4,ANY
2615,92575,~InspectorIo,1,node.inspector.InspectorIo.~InspectorIo,ANY node.inspector.InspectorIo.~InspectorIo (),inspector_io.cc,"InspectorIo::~InspectorIo() {
  request_queue_->Post(0, TransportAction::kKill, nullptr);
  int err = uv_thread_join(&thread_);
  CHECK_EQ(err, 0);
}",269.0,273.0,1.0,1.0,5.0,4,4,5,4,0,1,1,1,0,0,,0,1,0,0,0,ANY
2616,92597,StopAcceptingNewConnections,1,node.inspector.InspectorIo.StopAcceptingNewConnections,void node.inspector.InspectorIo.StopAcceptingNewConnections (),inspector_io.cc,"void InspectorIo::StopAcceptingNewConnections() {
  request_queue_->Post(0, TransportAction::kStop, nullptr);
}",275.0,277.0,1.0,1.0,3.0,2,2,2,2,0,1,1,1,0,0,,0,1,0,0,0,void
2617,92610,ThreadMain,1,node.inspector.InspectorIo.ThreadMain,void node.inspector.InspectorIo.ThreadMain (void*),inspector_io.cc,"void InspectorIo::ThreadMain() {
  uv_loop_t loop;
  loop.data = nullptr;
  int err = uv_loop_init(&loop);
  CHECK_EQ(err, 0);
  std::shared_ptr<RequestQueueData> queue(new RequestQueueData(&loop),
                                          RequestQueueData::CloseAndFree);
  std::string script_path = ScriptPath(&loop, script_name_);
  std::unique_ptr<InspectorIoDelegate> delegate(
      new InspectorIoDelegate(queue, main_thread_, id_,
                              script_path, script_name_));
  std::string host;
  int port;
  {
    ExclusiveAccess<HostPort>::Scoped host_port(host_port_);
    host = host_port->host();
    port = host_port->port();
  }
  InspectorSocketServer server(std::move(delegate),
                               &loop,
                               std::move(host),
                               port,
                               inspect_publish_uid_);
  request_queue_ = queue->handle();
  // Its lifetime is now that of the server delegate
  queue.reset();
  {...",284.0,320.0,1.0,1.0,37.0,2,2,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
2618,92752,GetWsUrl,1,node.inspector.InspectorIo.GetWsUrl,string node.inspector.InspectorIo.GetWsUrl (),inspector_io.cc,"std::string InspectorIo::GetWsUrl() const {
  ExclusiveAccess<HostPort>::Scoped host_port(host_port_);
  return FormatWsAddress(host_port->host(), host_port->port(), id_, true);
}",322.0,325.0,1.0,1.0,4.0,2,1,4,3,0,0,1,1,0,0,,0,0,0,0,0,string
2619,92892,CloseAndFree,1,node.inspector.RequestQueueData.CloseAndFree,void node.inspector.RequestQueueData.CloseAndFree (RequestQueueData*),inspector_io.cc,"void RequestQueueData::CloseAndFree(RequestQueueData* queue) {
  queue->handle_->Reset();
  queue->handle_.reset();
  uv_close(reinterpret_cast<uv_handle_t*>(&queue->async_),
           [](uv_handle_t* handle) {
    uv_async_t* async = reinterpret_cast<uv_async_t*>(handle);
    RequestQueueData* wrapper =
        node::ContainerOf(&RequestQueueData::async_, async);
    delete wrapper;
  });
}",372.0,382.0,1.0,1.0,11.0,7,4,3,1,0,3,1,1,0,0,,0,3,2,1,1,void
2620,92960,ToProtocolString,1,node.inspector.anonymous_namespace_17.ToProtocolString,"unique_ptr<StringBuffer> node.inspector.anonymous_namespace_17.ToProtocolString (Isolate*,Local<Value>)",inspector_js_api.cc,"std::unique_ptr<StringBuffer> ToProtocolString(Isolate* isolate,
                                               Local<Value> value) {
  TwoByteValue buffer(isolate, value);
  return StringBuffer::create(StringView(*buffer, buffer.length()));
}",35.0,39.0,1.0,1.0,5.0,3,2,5,4,0,0,1,1,0,0,,0,0,4,2,2,unique_ptr<StringBuffer>
2621,92983,Connect,1,node.inspector.anonymous_namespace_19.LocalConnection.Connect,"unique_ptr<InspectorSession> node.inspector.anonymous_namespace_19.LocalConnection.Connect (Agent*,ANY)",inspector_js_api.cc,"static std::unique_ptr<InspectorSession> Connect(
      Agent* inspector, std::unique_ptr<InspectorSessionDelegate> delegate) {
    return inspector->Connect(std::move(delegate), false);
  }",42.0,45.0,3.0,3.0,4.0,2,2,3,3,0,0,1,1,0,0,,0,0,4,2,2,unique_ptr<InspectorSession>
2622,93000,GetClassName,1,node.inspector.anonymous_namespace_20.LocalConnection.GetClassName,Local<String> node.inspector.anonymous_namespace_20.LocalConnection.GetClassName (Environment*),inspector_js_api.cc,"static Local<String> GetClassName(Environment* env) {
    return FIXED_ONE_BYTE_STRING(env->isolate(), ""Connection"");
  }",47.0,49.0,3.0,3.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,Local<String>
2623,93013,Connect,1,node.inspector.anonymous_namespace_22.MainThreadConnection.Connect,"unique_ptr<InspectorSession> node.inspector.anonymous_namespace_22.MainThreadConnection.Connect (Agent*,ANY)",inspector_js_api.cc,"static std::unique_ptr<InspectorSession> Connect(
      Agent* inspector, std::unique_ptr<InspectorSessionDelegate> delegate) {
    return inspector->ConnectToMainThread(std::move(delegate), true);
  }",53.0,56.0,3.0,3.0,4.0,2,2,3,3,0,0,1,1,0,0,,0,0,4,2,2,unique_ptr<InspectorSession>
2624,93030,GetClassName,1,node.inspector.anonymous_namespace_23.MainThreadConnection.GetClassName,Local<String> node.inspector.anonymous_namespace_23.MainThreadConnection.GetClassName (Environment*),inspector_js_api.cc,"static Local<String> GetClassName(Environment* env) {
    return FIXED_ONE_BYTE_STRING(env->isolate(), ""MainThreadConnection"");
  }",58.0,60.0,3.0,3.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,Local<String>
2625,93044,JSBindingsSessionDelegate,1,node.inspector.anonymous_namespace_26.JSBindingsConnection.JSBindingsSessionDelegate.JSBindingsSessionDelegate,"ANY node.inspector.anonymous_namespace_26.JSBindingsConnection.JSBindingsSessionDelegate.JSBindingsSessionDelegate (Environment*,JSBindingsConnection*)",inspector_js_api.cc,"JSBindingsSessionDelegate(Environment* env,
                              JSBindingsConnection* connection)
                              : env_(env),
                                connection_(connection) {
    }",68.0,72.0,5.0,5.0,5.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,ANY
2626,93050,SendMessageToFrontend,1,node.inspector.anonymous_namespace_27.JSBindingsConnection.JSBindingsSessionDelegate.SendMessageToFrontend,void node.inspector.anonymous_namespace_27.JSBindingsConnection.JSBindingsSessionDelegate.SendMessageToFrontend (ANY),inspector_js_api.cc,"void SendMessageToFrontend(const v8_inspector::StringView& message)
        override {
      Isolate* isolate = env_->isolate();
      HandleScope handle_scope(isolate);
      Context::Scope context_scope(env_->context());
      Local<Value> argument;
      if (!String::NewFromTwoByte(isolate, message.characters16(),
                                  NewStringType::kNormal,
                                  message.length()).ToLocal(&argument)) return;
      connection_->OnMessage(argument);
    }",74.0,84.0,5.0,5.0,11.0,13,7,15,9,0,3,2,2,0,0,,0,3,2,1,1,void
2627,93108,JSBindingsConnection,1,node.inspector.anonymous_namespace_28.JSBindingsConnection.JSBindingsConnection,"ANY node.inspector.anonymous_namespace_28.JSBindingsConnection.JSBindingsConnection (Environment*,Local<Object>,Local<Function>)",inspector_js_api.cc,"JSBindingsConnection(Environment* env,
                       Local<Object> wrap,
                       Local<Function> callback)
                       : AsyncWrap(env, wrap, PROVIDER_INSPECTORJSBINDING),
                         callback_(env->isolate(), callback) {
    Agent* inspector = env->inspector_agent();
    session_ = ConnectionType::Connect(
        inspector, std::make_unique<JSBindingsSessionDelegate>(env, this));
  }",91.0,99.0,3.0,3.0,9.0,9,7,8,6,0,1,1,1,0,0,,0,1,6,3,3,ANY
2628,93139,OnMessage,1,node.inspector.anonymous_namespace_29.JSBindingsConnection.OnMessage,void node.inspector.anonymous_namespace_29.JSBindingsConnection.OnMessage (Local<Value>),inspector_js_api.cc,"void OnMessage(Local<Value> value) {
    MakeCallback(callback_.Get(env()->isolate()), 1, &value);
  }",101.0,103.0,3.0,3.0,3.0,3,3,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
2629,93156,Bind,1,node.inspector.anonymous_namespace_30.JSBindingsConnection.Bind,"void node.inspector.anonymous_namespace_30.JSBindingsConnection.Bind (Environment*,Local<Object>)",inspector_js_api.cc,"static void Bind(Environment* env, Local<Object> target) {
    Isolate* isolate = env->isolate();
    Local<FunctionTemplate> tmpl =
        NewFunctionTemplate(isolate, JSBindingsConnection::New);
    tmpl->InstanceTemplate()->SetInternalFieldCount(
        JSBindingsConnection::kInternalFieldCount);
    tmpl->Inherit(AsyncWrap::GetConstructorTemplate(env));
    SetProtoMethod(isolate, tmpl, ""dispatch"", JSBindingsConnection::Dispatch);
    SetProtoMethod(
        isolate, tmpl, ""disconnect"", JSBindingsConnection::Disconnect);
    SetConstructorFunction(
        env->context(), target, ConnectionType::GetClassName(env), tmpl);
  }",105.0,117.0,3.0,3.0,13.0,15,5,23,9,0,0,1,1,0,0,,0,0,4,2,2,void
2630,93225,New,1,node.inspector.anonymous_namespace_31.JSBindingsConnection.New,void node.inspector.anonymous_namespace_31.JSBindingsConnection.New (FunctionCallbackInfo<Value>),inspector_js_api.cc,"static void New(const FunctionCallbackInfo<Value>& info) {
    Environment* env = Environment::GetCurrent(info);
    CHECK(info[0]->IsFunction());
    Local<Function> callback = info[0].As<Function>();
    new JSBindingsConnection(env, info.This(), callback);
  }",119.0,124.0,3.0,3.0,6.0,11,7,12,7,0,0,1,1,0,0,,0,0,2,1,1,void
2631,93265,Disconnect,1,node.inspector.anonymous_namespace_32.JSBindingsConnection.Disconnect,void node.inspector.anonymous_namespace_32.JSBindingsConnection.Disconnect (),inspector_js_api.cc,"void Disconnect() {
    BaseObjectPtr<JSBindingsConnection> strong_ref{this};
    session_.reset();
    Detach();
  }",127.0,131.0,3.0,3.0,5.0,4,4,3,3,0,1,1,1,0,0,,0,1,0,0,0,void
2632,93281,Disconnect,1,node.inspector.anonymous_namespace_33.JSBindingsConnection.Disconnect,void node.inspector.anonymous_namespace_33.JSBindingsConnection.Disconnect (FunctionCallbackInfo<Value>),inspector_js_api.cc,"static void Disconnect(const FunctionCallbackInfo<Value>& info) {
    JSBindingsConnection* session;
    ASSIGN_OR_RETURN_UNWRAP(&session, info.Holder());
    session->Disconnect();
  }",133.0,137.0,3.0,3.0,5.0,3,3,3,2,0,0,1,1,0,0,,0,0,2,1,1,void
2633,93298,Dispatch,1,node.inspector.anonymous_namespace_34.JSBindingsConnection.Dispatch,void node.inspector.anonymous_namespace_34.JSBindingsConnection.Dispatch (FunctionCallbackInfo<Value>),inspector_js_api.cc,"static void Dispatch(const FunctionCallbackInfo<Value>& info) {
    Environment* env = Environment::GetCurrent(info);
    JSBindingsConnection* session;
    ASSIGN_OR_RETURN_UNWRAP(&session, info.Holder());
    CHECK(info[0]->IsString());

    if (session->session_) {
      session->session_->Dispatch(
          ToProtocolString(env->isolate(), info[0])->string());
    }
  }",139.0,149.0,3.0,3.0,11.0,12,5,10,4,0,2,2,2,1,0,,0,2,2,1,1,void
2634,93348,MemoryInfo,1,node.inspector.anonymous_namespace_35.JSBindingsConnection.MemoryInfo,void node.inspector.anonymous_namespace_35.JSBindingsConnection.MemoryInfo (MemoryTracker*),inspector_js_api.cc,"void MemoryInfo(MemoryTracker* tracker) const override {
    tracker->TrackField(""callback"", callback_);
    tracker->TrackFieldWithSize(
        ""session"", sizeof(*session_), ""InspectorSession"");
  }",151.0,155.0,3.0,3.0,5.0,4,3,4,3,0,2,1,1,0,0,,0,2,2,1,1,void
2635,93372,IsNotIndicativeOfMemoryLeakAtExit,1,node.inspector.anonymous_namespace_36.JSBindingsConnection.IsNotIndicativeOfMemoryLeakAtExit,bool node.inspector.anonymous_namespace_36.JSBindingsConnection.IsNotIndicativeOfMemoryLeakAtExit (),inspector_js_api.cc,"bool IsNotIndicativeOfMemoryLeakAtExit() const override {
    return true;  // Binding connections emit events on their own.
  }",160.0,162.0,3.0,3.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,bool
2636,93380,InspectorEnabled,1,node.inspector.anonymous_namespace_37.InspectorEnabled,bool node.inspector.anonymous_namespace_37.InspectorEnabled (Environment*),inspector_js_api.cc,"static bool InspectorEnabled(Environment* env) {
  Agent* agent = env->inspector_agent();
  return agent->IsActive();
}",169.0,172.0,1.0,1.0,4.0,3,2,3,2,0,0,1,1,0,0,,0,0,2,1,1,bool
2637,93397,SetConsoleExtensionInstaller,1,node.inspector.anonymous_namespace_38.SetConsoleExtensionInstaller,void node.inspector.anonymous_namespace_38.SetConsoleExtensionInstaller (FunctionCallbackInfo<Value>),inspector_js_api.cc,"void SetConsoleExtensionInstaller(const FunctionCallbackInfo<Value>& info) {
  auto env = Environment::GetCurrent(info);

  CHECK_EQ(info.Length(), 1);
  CHECK(info[0]->IsFunction());

  env->set_inspector_console_extension_installer(info[0].As<Function>());
}",174.0,181.0,1.0,1.0,8.0,8,4,7,3,0,0,1,1,0,0,,0,0,2,1,1,void
2638,93433,CallAndPauseOnStart,1,node.inspector.anonymous_namespace_39.CallAndPauseOnStart,void node.inspector.anonymous_namespace_39.CallAndPauseOnStart (ANY),inspector_js_api.cc,"void CallAndPauseOnStart(const FunctionCallbackInfo<v8::Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  CHECK_GT(args.Length(), 1);
  CHECK(args[0]->IsFunction());
  SlicedArguments call_args(args, /* start */ 2);
  env->inspector_agent()->PauseOnNextJavascriptStatement(""Break on start"");
  v8::MaybeLocal<v8::Value> retval =
      args[0].As<v8::Function>()->Call(env->context(), args[1],
                                       call_args.length(), call_args.out());
  if (!retval.IsEmpty()) {
    args.GetReturnValue().Set(retval.ToLocalChecked());
  }
}",183.0,195.0,1.0,1.0,13.0,24,7,18,6,0,0,2,2,0,0,,0,0,2,1,1,void
2639,93523,InspectorConsoleCall,1,node.inspector.anonymous_namespace_40.InspectorConsoleCall,void node.inspector.anonymous_namespace_40.InspectorConsoleCall (FunctionCallbackInfo<Value>),inspector_js_api.cc,"void InspectorConsoleCall(const FunctionCallbackInfo<Value>& info) {
  Environment* env = Environment::GetCurrent(info);
  Isolate* isolate = env->isolate();
  Local<Context> context = isolate->GetCurrentContext();
  CHECK_GE(info.Length(), 2);
  SlicedArguments call_args(info, /* start */ 2);
  if (InspectorEnabled(env)) {
    Local<Value> inspector_method = info[0];
    CHECK(inspector_method->IsFunction());
    if (!env->is_in_inspector_console_call()) {
      env->set_is_in_inspector_console_call(true);
      MaybeLocal<Value> ret =
          inspector_method.As<Function>()->Call(context,
                                                info.Holder(),
                                                call_args.length(),
                                                call_args.out());
      env->set_is_in_inspector_console_call(false);
      if (ret.IsEmpty())
        return;
    }
  }

  Local<Value> node_method = info[1];
  CHECK(node_method->IsFunction());
  USE(node_method.As<F...",197.0,225.0,1.0,1.0,29.0,37,7,39,13,0,0,4,7,0,0,,0,0,2,1,1,void
2640,93666,GetAsyncTask,1,node.inspector.anonymous_namespace_42.GetAsyncTask,void* node.inspector.anonymous_namespace_42.GetAsyncTask (int64_t),inspector_js_api.cc,"static void* GetAsyncTask(int64_t asyncId) {
  // The inspector assumes that when other clients use its asyncTask* API,
  // they use real pointers, or at least something aligned like real pointer.
  // In general it means that our task_id should always be even.
  //
  // On 32bit platforms, the 64bit asyncId would get truncated when converted
  // to a 32bit pointer. However, the javascript part will never enable
  // the async_hook on 32bit platforms, therefore the truncation will never
  // happen in practice.
  return reinterpret_cast<void*>(asyncId << 1);
}",227.0,237.0,1.0,1.0,11.0,2,2,1,1,0,0,1,1,0,0,,0,0,2,1,1,void*
2641,93677,InvokeAsyncTaskFnWithId,1,node.inspector.anonymous_namespace_43.InvokeAsyncTaskFnWithId,void node.inspector.anonymous_namespace_43.InvokeAsyncTaskFnWithId<void(Agent::*)(void*)> (FunctionCallbackInfo<Value>),inspector_js_api.cc,"static void InvokeAsyncTaskFnWithId(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  CHECK(args[0]->IsNumber());
  int64_t task_id = args[0]->IntegerValue(env->context()).FromJust();
  (env->inspector_agent()->*asyncTaskFn)(GetAsyncTask(task_id));
}",240.0,245.0,1.0,1.0,6.0,11,4,10,5,0,0,1,1,0,0,,0,0,2,1,1,void
2642,93722,AsyncTaskScheduledWrapper,1,node.inspector.anonymous_namespace_45.AsyncTaskScheduledWrapper,void node.inspector.anonymous_namespace_45.AsyncTaskScheduledWrapper (FunctionCallbackInfo<Value>),inspector_js_api.cc,"static void AsyncTaskScheduledWrapper(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  CHECK(args[0]->IsString());
  Local<String> task_name = args[0].As<String>();
  String::Value task_name_value(args.GetIsolate(), task_name);
  StringView task_name_view(*task_name_value, task_name_value.length());

  CHECK(args[1]->IsNumber());
  int64_t task_id = args[1]->IntegerValue(env->context()).FromJust();
  void* task = GetAsyncTask(task_id);

  CHECK(args[2]->IsBoolean());
  bool recurring = args[2]->BooleanValue(args.GetIsolate());

  env->inspector_agent()->AsyncTaskScheduled(task_name_view, task, recurring);
}",247.0,263.0,1.0,1.0,17.0,28,7,26,11,0,0,1,1,0,0,,0,0,2,1,1,void
2643,93827,RegisterAsyncHookWrapper,1,node.inspector.anonymous_namespace_47.RegisterAsyncHookWrapper,void node.inspector.anonymous_namespace_47.RegisterAsyncHookWrapper (FunctionCallbackInfo<Value>),inspector_js_api.cc,"static void RegisterAsyncHookWrapper(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  CHECK(args[0]->IsFunction());
  Local<Function> enable_function = args[0].As<Function>();
  CHECK(args[1]->IsFunction());
  Local<Function> disable_function = args[1].As<Function>();
  env->inspector_agent()->RegisterAsyncHook(env->isolate(),
    enable_function, disable_function);
}",265.0,274.0,1.0,1.0,10.0,19,6,17,7,0,0,1,1,0,0,,0,0,2,1,1,void
2644,93891,IsEnabled,1,node.inspector.anonymous_namespace_48.IsEnabled,void node.inspector.anonymous_namespace_48.IsEnabled (FunctionCallbackInfo<Value>),inspector_js_api.cc,"void IsEnabled(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  args.GetReturnValue().Set(env->inspector_agent()->IsListening());
}",276.0,279.0,1.0,1.0,4.0,6,3,5,3,0,0,1,1,0,0,,0,0,2,1,1,void
2645,93918,Open,1,node.inspector.anonymous_namespace_49.Open,void node.inspector.anonymous_namespace_49.Open (FunctionCallbackInfo<Value>),inspector_js_api.cc,"void Open(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Agent* agent = env->inspector_agent();

  if (args.Length() > 0 && args[0]->IsUint32()) {
    uint32_t port = args[0].As<Uint32>()->Value();
    CHECK_LE(port, std::numeric_limits<uint16_t>::max());
    ExclusiveAccess<HostPort>::Scoped host_port(agent->host_port());
    host_port->set_port(static_cast<int>(port));
  }

  if (args.Length() > 1 && args[1]->IsString()) {
    Utf8Value host(env->isolate(), args[1].As<String>());
    ExclusiveAccess<HostPort>::Scoped host_port(agent->host_port());
    host_port->set_host(*host);
  }

  agent->StartIoThread();
}",281.0,299.0,1.0,1.0,19.0,32,9,23,9,0,0,3,3,0,0,,0,0,2,1,1,void
2646,94033,WaitForDebugger,1,node.inspector.anonymous_namespace_50.WaitForDebugger,void node.inspector.anonymous_namespace_50.WaitForDebugger (FunctionCallbackInfo<Value>),inspector_js_api.cc,"void WaitForDebugger(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Agent* agent = env->inspector_agent();
  if (agent->IsActive())
    agent->WaitForConnect();
  args.GetReturnValue().Set(agent->IsActive());
}",301.0,307.0,1.0,1.0,7.0,9,3,9,4,0,0,2,2,0,0,,0,0,2,1,1,void
2647,94074,Url,1,node.inspector.anonymous_namespace_51.Url,void node.inspector.anonymous_namespace_51.Url (FunctionCallbackInfo<Value>),inspector_js_api.cc,"void Url(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  std::string url = env->inspector_agent()->GetWsUrl();
  if (url.empty()) {
    return;
  }
  args.GetReturnValue().Set(OneByteString(env->isolate(), url.c_str()));
}",309.0,316.0,1.0,1.0,8.0,10,3,9,4,0,0,2,2,0,0,,0,0,2,1,1,void
2648,94120,Initialize,1,node.inspector.anonymous_namespace_52.Initialize,"void node.inspector.anonymous_namespace_52.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)",inspector_js_api.cc,"void Initialize(Local<Object> target, Local<Value> unused,
                Local<Context> context, void* priv) {
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  v8::Local<v8::Function> consoleCallFunc =
      NewFunctionTemplate(isolate,
                          InspectorConsoleCall,
                          v8::Local<v8::Signature>(),
                          v8::ConstructorBehavior::kThrow,
                          v8::SideEffectType::kHasSideEffect)
          ->GetFunction(context)
          .ToLocalChecked();
  auto name_string = FIXED_ONE_BYTE_STRING(isolate, ""consoleCall"");
  target->Set(context, name_string, consoleCallFunc).Check();
  consoleCallFunc->SetName(name_string);

  SetMethod(context,
            target,
            ""setConsoleExtensionInstaller"",
            SetConsoleExtensionInstaller);
  SetMethod(context, target, ""callAndPauseOnStart"", CallAndPauseOnStart);
  SetMethod(context, target, ""open"", Open);
  SetMeth...",318.0,374.0,1.0,1.0,57.0,33,5,68,20,0,0,1,1,0,0,,0,0,8,4,4,void
2649,94302,RegisterExternalReferences,1,node.inspector.RegisterExternalReferences,void node.inspector.RegisterExternalReferences (ExternalReferenceRegistry*),inspector_js_api.cc,"void RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  registry->Register(InspectorConsoleCall);
  registry->Register(SetConsoleExtensionInstaller);
  registry->Register(CallAndPauseOnStart);
  registry->Register(Open);
  registry->Register(Url);
  registry->Register(WaitForDebugger);

  registry->Register(AsyncTaskScheduledWrapper);
  registry->Register(InvokeAsyncTaskFnWithId<&Agent::AsyncTaskCanceled>);
  registry->Register(InvokeAsyncTaskFnWithId<&Agent::AsyncTaskStarted>);
  registry->Register(InvokeAsyncTaskFnWithId<&Agent::AsyncTaskFinished>);

  registry->Register(RegisterAsyncHookWrapper);
  registry->Register(IsEnabled);

  registry->Register(JSBindingsConnection<LocalConnection>::New);
  registry->Register(JSBindingsConnection<LocalConnection>::Dispatch);
  registry->Register(JSBindingsConnection<LocalConnection>::Disconnect);
  registry->Register(JSBindingsConnection<MainThreadConnection>::New);
  registry->Register(JSBindingsConnection<MainThreadConnec...",378.0,400.0,1.0,1.0,23.0,24,2,27,6,0,0,1,1,0,0,,0,0,2,1,1,void
2650,94411,<lambda>0,1,node.profiler.StartProfilers.<lambda>0,ANY node.profiler.StartProfilers.<lambda>0 (void*),inspector_profiler.cc,"[](void* env) {
    EndStartedProfilers(static_cast<Environment*>(env));
  }",417.0,419.0,15.0,3.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,ANY
2651,94454,V8ProfilerConnection,1,node.profiler.V8ProfilerConnection.V8ProfilerConnection,ANY node.profiler.V8ProfilerConnection.V8ProfilerConnection (Environment*),inspector_profiler.cc,"V8ProfilerConnection::V8ProfilerConnection(Environment* env)
    : session_(env->inspector_agent()->Connect(
          std::make_unique<V8ProfilerConnection::V8ProfilerSessionDelegate>(
              this),
          false)),
      env_(env) {}",34.0,39.0,1.0,18.0,6.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
2652,94459,DispatchMessage,1,node.profiler.V8ProfilerConnection.DispatchMessage,"uint32_t node.profiler.V8ProfilerConnection.DispatchMessage (char*,char*,bool)",inspector_profiler.cc,"uint32_t V8ProfilerConnection::DispatchMessage(const char* method,
                                               const char* params,
                                               bool is_profile_request) {
  std::stringstream ss;
  uint32_t id = next_id();
  ss << R""({ ""id"": )"" << id;
  DCHECK(method != nullptr);
  ss << R""(, ""method"": "")"" << method << '""';
  if (params != nullptr) {
    ss << R""(, ""params"": )"" << params;
  }
  ss << "" }"";
  std::string message = ss.str();
  const uint8_t* message_data =
      reinterpret_cast<const uint8_t*>(message.c_str());
  // Save the id of the profile request to identify its response.
  if (is_profile_request) {
    profile_ids_.insert(id);
  }
  Debug(env(),
        DebugCategory::INSPECTOR_PROFILER,
        ""Dispatching message %s\n"",
        message.c_str());
  session_->Dispatch(StringView(message_data, message.length()));
  return id;
}",41.0,66.0,1.0,1.0,26.0,21,6,23,10,0,0,3,3,0,0,,0,0,6,3,3,uint32_t
2653,94546,WriteResult,1,node.profiler.WriteResult,"void node.profiler.WriteResult (Environment*,char*,Local<String>)",inspector_profiler.cc,"static void WriteResult(Environment* env,
                        const char* path,
                        Local<String> result) {
  int ret = WriteFileSync(env->isolate(), path, result);
  if (ret != 0) {
    char err_buf[128];
    uv_err_name_r(ret, err_buf, sizeof(err_buf));
    fprintf(stderr, ""%s: Failed to write file %s\n"", err_buf, path);
    return;
  }
  Debug(env, DebugCategory::INSPECTOR_PROFILER, ""Written result to %s\n"", path);
}",68.0,79.0,1.0,1.0,12.0,5,5,14,7,0,0,2,2,0,0,,0,0,6,3,3,void
2654,94587,SendMessageToFrontend,1,node.profiler.V8ProfilerConnection.V8ProfilerSessionDelegate.SendMessageToFrontend,void node.profiler.V8ProfilerConnection.V8ProfilerSessionDelegate.SendMessageToFrontend (ANY),inspector_profiler.cc,"void V8ProfilerConnection::V8ProfilerSessionDelegate::SendMessageToFrontend(
    const v8_inspector::StringView& message) {
  Environment* env = connection_->env();
  Isolate* isolate = env->isolate();
  HandleScope handle_scope(isolate);
  Local<Context> context = env->context();
  Context::Scope context_scope(context);

  const char* type = connection_->type();
  // Convert StringView to a Local<String>.
  Local<String> message_str;
  if (!String::NewFromTwoByte(isolate,
                              message.characters16(),
                              NewStringType::kNormal,
                              message.length())
           .ToLocal(&message_str)) {
    fprintf(
        stderr, ""Failed to convert %s profile message to V8 string\n"", type);
    return;
  }

  Debug(env,
        DebugCategory::INSPECTOR_PROFILER,
        ""Receive %s profile message\n"",
        type);

  Local<Value> parsed;
  if (!v8::JSON::Parse(context, message_str).ToLocal(&parsed) ||
      !parsed->IsO...",81.0,153.0,1.0,1.0,73.0,62,9,78,23,0,0,7,7,0,0,,0,0,2,1,1,void
2655,94834,EnsureDirectory,1,node.profiler.EnsureDirectory,"bool node.profiler.EnsureDirectory (ANY,char*)",inspector_profiler.cc,"static bool EnsureDirectory(const std::string& directory, const char* type) {
  fs::FSReqWrapSync req_wrap_sync;
  int ret = fs::MKDirpSync(nullptr, &req_wrap_sync.req, directory, 0777,
                           nullptr);
  if (ret < 0 && ret != UV_EEXIST) {
    char err_buf[128];
    uv_err_name_r(ret, err_buf, sizeof(err_buf));
    fprintf(stderr,
            ""%s: Failed to create %s profile directory %s\n"",
            err_buf,
            type,
            directory.c_str());
    return false;
  }
  return true;
}",155.0,170.0,1.0,1.0,16.0,9,7,14,8,0,0,2,2,0,0,,0,0,4,2,2,bool
2656,94884,GetFilename,1,node.profiler.V8CoverageConnection.GetFilename,string node.profiler.V8CoverageConnection.GetFilename (),inspector_profiler.cc,"std::string V8CoverageConnection::GetFilename() const {
  uint64_t timestamp =
      static_cast<uint64_t>(GetCurrentTimeInMicroseconds() / 1000);
  return SPrintF(""coverage-%s-%s-%s.json"",
      uv_os_getpid(),
      timestamp,
      env()->thread_id());
}",172.0,179.0,1.0,1.0,8.0,4,4,2,1,0,0,1,1,0,0,,0,0,0,0,0,string
2657,94905,WriteProfile,1,node.profiler.V8ProfilerConnection.WriteProfile,void node.profiler.V8ProfilerConnection.WriteProfile (Local<Object>),inspector_profiler.cc,"void V8ProfilerConnection::WriteProfile(Local<Object> result) {
  Local<Context> context = env_->context();

  // Generate the profile output from the subclass.
  Local<Object> profile;
  if (!GetProfile(result).ToLocal(&profile)) {
    return;
  }

  Local<String> result_s;
  if (!v8::JSON::Stringify(context, profile).ToLocal(&result_s)) {
    fprintf(stderr, ""Failed to stringify %s profile result\n"", type());
    return;
  }

  // Create the directory if necessary.
  std::string directory = GetDirectory();
  DCHECK(!directory.empty());
  if (!EnsureDirectory(directory, type())) {
    return;
  }

  std::string filename = GetFilename();
  DCHECK(!filename.empty());
  std::string path = directory + kPathSeparator + filename;

  WriteResult(env_, path.c_str(), result_s);
}",181.0,208.0,1.0,1.0,28.0,27,8,30,16,0,0,4,4,0,0,,0,0,2,1,1,void
2658,95004,WriteProfile,1,node.profiler.V8CoverageConnection.WriteProfile,void node.profiler.V8CoverageConnection.WriteProfile (Local<Object>),inspector_profiler.cc,"void V8CoverageConnection::WriteProfile(Local<Object> result) {
  Isolate* isolate = env_->isolate();
  Local<Context> context = env_->context();
  HandleScope handle_scope(isolate);
  Context::Scope context_scope(context);

  // This is only set up during pre-execution (when the environment variables
  // becomes available in the JS land). If it's empty, we don't have coverage
  // directory path (which is resolved in JS land at the moment) either, so
  // the best we could to is to just discard the profile and do nothing.
  // This should only happen in half-baked Environments created using the
  // embedder API.
  if (env_->source_map_cache_getter().IsEmpty()) {
    return;
  }

  // Generate the profile output from the subclass.
  Local<Object> profile;
  if (!GetProfile(result).ToLocal(&profile)) {
    return;
  }

  // append source-map cache information to coverage object:
  Local<Value> source_map_cache_v;
  {
    TryCatchScope try_catch(env());
    {
      Isolate::AllowJav...",210.0,273.0,1.0,1.0,64.0,49,9,57,22,0,0,8,8,0,0,,0,0,2,1,1,void
2659,95202,GetProfile,1,node.profiler.V8CoverageConnection.GetProfile,MaybeLocal<Object> node.profiler.V8CoverageConnection.GetProfile (Local<Object>),inspector_profiler.cc,"MaybeLocal<Object> V8CoverageConnection::GetProfile(Local<Object> result) {
  return result;
}",275.0,277.0,1.0,1.0,3.0,0,0,1,1,0,0,1,1,0,0,,0,0,2,1,1,MaybeLocal<Object>
2660,95209,GetDirectory,1,node.profiler.V8CoverageConnection.GetDirectory,string node.profiler.V8CoverageConnection.GetDirectory (),inspector_profiler.cc,"std::string V8CoverageConnection::GetDirectory() const {
  return env()->coverage_directory();
}",279.0,281.0,1.0,1.0,3.0,1,1,0,0,0,0,1,1,0,0,,0,0,0,0,0,string
2661,95218,Start,1,node.profiler.V8CoverageConnection.Start,void node.profiler.V8CoverageConnection.Start (),inspector_profiler.cc,"void V8CoverageConnection::Start() {
  DispatchMessage(""Profiler.enable"");
  DispatchMessage(""Profiler.startPreciseCoverage"",
                  R""({ ""callCount"": true, ""detailed"": true })"");
}",283.0,287.0,1.0,1.0,5.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2662,95227,TakeCoverage,1,node.profiler.V8CoverageConnection.TakeCoverage,void node.profiler.V8CoverageConnection.TakeCoverage (),inspector_profiler.cc,"void V8CoverageConnection::TakeCoverage() {
  DispatchMessage(""Profiler.takePreciseCoverage"", nullptr, true);
}",289.0,291.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2663,95235,StopCoverage,1,node.profiler.V8CoverageConnection.StopCoverage,void node.profiler.V8CoverageConnection.StopCoverage (),inspector_profiler.cc,"void V8CoverageConnection::StopCoverage() {
  DispatchMessage(""Profiler.stopPreciseCoverage"");
}",293.0,295.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2664,95241,End,1,node.profiler.V8CoverageConnection.End,void node.profiler.V8CoverageConnection.End (),inspector_profiler.cc,"void V8CoverageConnection::End() {
  Debug(env_,
      DebugCategory::INSPECTOR_PROFILER,
      ""V8CoverageConnection::End(), ending = %d\n"", ending_);
  if (ending_) {
    return;
  }
  ending_ = true;
  TakeCoverage();
}",297.0,306.0,1.0,1.0,10.0,2,2,5,3,0,0,2,2,0,0,,0,0,0,0,0,void
2665,95260,GetDirectory,1,node.profiler.V8CpuProfilerConnection.GetDirectory,string node.profiler.V8CpuProfilerConnection.GetDirectory (),inspector_profiler.cc,"std::string V8CpuProfilerConnection::GetDirectory() const {
  return env()->cpu_prof_dir();
}",308.0,310.0,1.0,1.0,3.0,1,1,0,0,0,0,1,1,0,0,,0,0,0,0,0,string
2666,95269,GetFilename,1,node.profiler.V8CpuProfilerConnection.GetFilename,string node.profiler.V8CpuProfilerConnection.GetFilename (),inspector_profiler.cc,"std::string V8CpuProfilerConnection::GetFilename() const {
  return env()->cpu_prof_name();
}",312.0,314.0,1.0,1.0,3.0,1,1,0,0,0,0,1,1,0,0,,0,0,0,0,0,string
2667,95278,GetProfile,1,node.profiler.V8CpuProfilerConnection.GetProfile,MaybeLocal<Object> node.profiler.V8CpuProfilerConnection.GetProfile (Local<Object>),inspector_profiler.cc,"MaybeLocal<Object> V8CpuProfilerConnection::GetProfile(Local<Object> result) {
  Local<Value> profile_v;
  if (!result
           ->Get(env()->context(),
                 FIXED_ONE_BYTE_STRING(env()->isolate(), ""profile""))
           .ToLocal(&profile_v)) {
    fprintf(stderr, ""'profile' from CPU profile result is undefined\n"");
    return MaybeLocal<Object>();
  }
  if (!profile_v->IsObject()) {
    fprintf(stderr, ""'profile' from CPU profile result is not an Object\n"");
    return MaybeLocal<Object>();
  }
  return profile_v.As<Object>();
}",316.0,330.0,1.0,1.0,15.0,11,6,9,5,0,0,3,3,0,0,,0,0,2,1,1,MaybeLocal<Object>
2668,95332,Start,1,node.profiler.V8CpuProfilerConnection.Start,void node.profiler.V8CpuProfilerConnection.Start (),inspector_profiler.cc,"void V8CpuProfilerConnection::Start() {
  DispatchMessage(""Profiler.enable"");
  std::string params = R""({ ""interval"": )"";
  params += std::to_string(env()->cpu_prof_interval());
  params += "" }"";
  DispatchMessage(""Profiler.setSamplingInterval"", params.c_str());
  DispatchMessage(""Profiler.start"");
}",332.0,339.0,1.0,1.0,8.0,6,4,5,2,0,0,1,1,0,0,,0,0,0,0,0,void
2669,95363,End,1,node.profiler.V8CpuProfilerConnection.End,void node.profiler.V8CpuProfilerConnection.End (),inspector_profiler.cc,"void V8CpuProfilerConnection::End() {
  Debug(env_,
      DebugCategory::INSPECTOR_PROFILER,
      ""V8CpuProfilerConnection::End(), ending = %d\n"", ending_);
  if (ending_) {
    return;
  }
  ending_ = true;
  DispatchMessage(""Profiler.stop"", nullptr, true);
}",341.0,350.0,1.0,1.0,10.0,2,2,5,3,0,0,2,2,0,0,,0,0,0,0,0,void
2670,95385,GetDirectory,1,node.profiler.V8HeapProfilerConnection.GetDirectory,string node.profiler.V8HeapProfilerConnection.GetDirectory (),inspector_profiler.cc,"std::string V8HeapProfilerConnection::GetDirectory() const {
  return env()->heap_prof_dir();
}",352.0,354.0,1.0,1.0,3.0,1,1,0,0,0,0,1,1,0,0,,0,0,0,0,0,string
2671,95394,GetFilename,1,node.profiler.V8HeapProfilerConnection.GetFilename,string node.profiler.V8HeapProfilerConnection.GetFilename (),inspector_profiler.cc,"std::string V8HeapProfilerConnection::GetFilename() const {
  return env()->heap_prof_name();
}",356.0,358.0,1.0,1.0,3.0,1,1,0,0,0,0,1,1,0,0,,0,0,0,0,0,string
2672,95403,GetProfile,1,node.profiler.V8HeapProfilerConnection.GetProfile,MaybeLocal<Object> node.profiler.V8HeapProfilerConnection.GetProfile (Local<Object>),inspector_profiler.cc,"MaybeLocal<Object> V8HeapProfilerConnection::GetProfile(Local<Object> result) {
  Local<Value> profile_v;
  if (!result
           ->Get(env()->context(),
                 FIXED_ONE_BYTE_STRING(env()->isolate(), ""profile""))
           .ToLocal(&profile_v)) {
    fprintf(stderr, ""'profile' from heap profile result is undefined\n"");
    return MaybeLocal<Object>();
  }
  if (!profile_v->IsObject()) {
    fprintf(stderr, ""'profile' from heap profile result is not an Object\n"");
    return MaybeLocal<Object>();
  }
  return profile_v.As<Object>();
}",360.0,374.0,1.0,1.0,15.0,11,6,9,5,0,0,3,3,0,0,,0,0,2,1,1,MaybeLocal<Object>
2673,95457,Start,1,node.profiler.V8HeapProfilerConnection.Start,void node.profiler.V8HeapProfilerConnection.Start (),inspector_profiler.cc,"void V8HeapProfilerConnection::Start() {
  DispatchMessage(""HeapProfiler.enable"");
  std::string params = R""({ ""samplingInterval"": )"";
  params += std::to_string(env()->heap_prof_interval());
  params += "" }"";
  DispatchMessage(""HeapProfiler.startSampling"", params.c_str());
}",376.0,382.0,1.0,1.0,7.0,6,4,5,2,0,0,1,1,0,0,,0,0,0,0,0,void
2674,95486,End,1,node.profiler.V8HeapProfilerConnection.End,void node.profiler.V8HeapProfilerConnection.End (),inspector_profiler.cc,"void V8HeapProfilerConnection::End() {
  Debug(env_,
      DebugCategory::INSPECTOR_PROFILER,
      ""V8HeapProfilerConnection::End(), ending = %d\n"", ending_);
  if (ending_) {
    return;
  }
  ending_ = true;
  DispatchMessage(""HeapProfiler.stopSampling"", nullptr, true);
}",384.0,393.0,1.0,1.0,10.0,2,2,5,3,0,0,2,2,0,0,,0,0,0,0,0,void
2675,95508,EndStartedProfilers,1,node.profiler.EndStartedProfilers,void node.profiler.EndStartedProfilers (Environment*),inspector_profiler.cc,"static void EndStartedProfilers(Environment* env) {
  // TODO(joyeechueng): merge these connections and use one session per env.
  Debug(env, DebugCategory::INSPECTOR_PROFILER, ""EndStartedProfilers\n"");
  V8ProfilerConnection* connection = env->cpu_profiler_connection();
  if (connection != nullptr) {
    connection->End();
  }

  connection = env->heap_profiler_connection();
  if (connection != nullptr) {
    connection->End();
  }

  connection = env->coverage_connection();
  if (connection != nullptr) {
    connection->End();
  }
}",397.0,414.0,1.0,1.0,18.0,13,4,14,3,0,0,4,4,0,0,,0,0,2,1,1,void
2676,95565,StartProfilers,1,node.profiler.StartProfilers,void node.profiler.StartProfilers (Environment*),inspector_profiler.cc,"void StartProfilers(Environment* env) {
  AtExit(env, [](void* env) {
    EndStartedProfilers(static_cast<Environment*>(env));
  }, env);

  Isolate* isolate = env->isolate();
  Local<String> coverage_str = env->env_vars()->Get(
      isolate, FIXED_ONE_BYTE_STRING(isolate, ""NODE_V8_COVERAGE""))
      .FromMaybe(Local<String>());
  if ((!coverage_str.IsEmpty() && coverage_str->Length() > 0) ||
      env->options()->test_runner_coverage) {
    CHECK_NULL(env->coverage_connection());
    env->set_coverage_connection(std::make_unique<V8CoverageConnection>(env));
    env->coverage_connection()->Start();
  }
  if (env->options()->cpu_prof) {
    const std::string& dir = env->options()->cpu_prof_dir;
    env->set_cpu_prof_interval(env->options()->cpu_prof_interval);
    env->set_cpu_prof_dir(dir.empty() ? env->GetCwd() : dir);
    if (env->options()->cpu_prof_name.empty()) {
      DiagnosticFilename filename(env, ""CPU"", ""cpuprofile"");
      env->set_cpu_prof_name(*filename);
    } else {
 ...",416.0,460.0,1.0,1.0,45.0,71,10,56,11,0,0,6,8,0,0,,0,0,2,1,1,void
2677,95838,SetCoverageDirectory,1,node.profiler.SetCoverageDirectory,void node.profiler.SetCoverageDirectory (FunctionCallbackInfo<Value>),inspector_profiler.cc,"static void SetCoverageDirectory(const FunctionCallbackInfo<Value>& args) {
  CHECK(args[0]->IsString());
  Environment* env = Environment::GetCurrent(args);
  node::Utf8Value directory(env->isolate(), args[0].As<String>());
  env->set_coverage_directory(*directory);
}",462.0,467.0,1.0,1.0,6.0,9,5,8,4,0,0,1,1,0,0,,0,0,2,1,1,void
2678,95876,SetSourceMapCacheGetter,1,node.profiler.SetSourceMapCacheGetter,void node.profiler.SetSourceMapCacheGetter (FunctionCallbackInfo<Value>),inspector_profiler.cc,"static void SetSourceMapCacheGetter(const FunctionCallbackInfo<Value>& args) {
  CHECK(args[0]->IsFunction());
  Environment* env = Environment::GetCurrent(args);
  env->set_source_map_cache_getter(args[0].As<Function>());
}",470.0,474.0,1.0,1.0,5.0,7,4,6,3,0,0,1,1,0,0,,0,0,2,1,1,void
2679,95906,TakeCoverage,1,node.profiler.TakeCoverage,void node.profiler.TakeCoverage (FunctionCallbackInfo<Value>),inspector_profiler.cc,"static void TakeCoverage(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  V8CoverageConnection* connection = env->coverage_connection();

  Debug(
    env,
    DebugCategory::INSPECTOR_PROFILER,
    ""TakeCoverage, connection %s nullptr\n"",
    connection == nullptr ? ""=="" : ""!="");

  if (connection != nullptr) {
    Debug(env, DebugCategory::INSPECTOR_PROFILER, ""taking coverage\n"");
    connection->TakeCoverage();
  }
}",476.0,490.0,1.0,1.0,15.0,10,6,12,5,0,0,2,2,0,0,,0,0,2,1,1,void
2680,95953,StopCoverage,1,node.profiler.StopCoverage,void node.profiler.StopCoverage (FunctionCallbackInfo<Value>),inspector_profiler.cc,"static void StopCoverage(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  V8CoverageConnection* connection = env->coverage_connection();

  Debug(env,
        DebugCategory::INSPECTOR_PROFILER,
        ""StopCoverage, connection %s nullptr\n"",
        connection == nullptr ? ""=="" : ""!="");

  if (connection != nullptr) {
    Debug(env, DebugCategory::INSPECTOR_PROFILER, ""Stopping coverage\n"");
    connection->StopCoverage();
  }
}",492.0,505.0,1.0,1.0,14.0,10,6,12,5,0,0,2,2,0,0,,0,0,2,1,1,void
2681,96000,Initialize,1,node.profiler.Initialize,"void node.profiler.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)",inspector_profiler.cc,"static void Initialize(Local<Object> target,
                       Local<Value> unused,
                       Local<Context> context,
                       void* priv) {
  SetMethod(context, target, ""setCoverageDirectory"", SetCoverageDirectory);
  SetMethod(
      context, target, ""setSourceMapCacheGetter"", SetSourceMapCacheGetter);
  SetMethod(context, target, ""takeCoverage"", TakeCoverage);
  SetMethod(context, target, ""stopCoverage"", StopCoverage);
}",507.0,516.0,1.0,1.0,10.0,0,0,8,2,0,0,1,1,0,0,,0,0,8,4,4,void
2682,96028,RegisterExternalReferences,1,node.profiler.RegisterExternalReferences,void node.profiler.RegisterExternalReferences (ExternalReferenceRegistry*),inspector_profiler.cc,"void RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  registry->Register(SetCoverageDirectory);
  registry->Register(SetSourceMapCacheGetter);
  registry->Register(TakeCoverage);
  registry->Register(StopCoverage);
}",518.0,523.0,1.0,1.0,6.0,4,1,4,1,0,0,1,1,0,0,,0,0,2,1,1,void
2683,96064,<lambda>0,1,node.inspector.anonymous_namespace_12.IsIPAddress.<lambda>0,ANY node.inspector.anonymous_namespace_12.IsIPAddress.<lambda>0 (auto),inspector_socket.cc,[](auto b) { return b == 0; },204.0,204.0,48.0,76.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,ANY
2684,96097,DisconnectAndDispose,1,node.inspector.TcpHolder.DisconnectAndDispose,void node.inspector.TcpHolder.DisconnectAndDispose (TcpHolder*),inspector_socket.cc,"void TcpHolder::DisconnectAndDispose(TcpHolder* holder) {
  uv_handle_t* handle = reinterpret_cast<uv_handle_t*>(&holder->tcp_);
  uv_close(handle, OnClosed);
}",766.0,769.0,1.0,1.0,4.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
2685,96103,Accept,1,node.inspector.TcpHolder.Accept,"Pointer node.inspector.TcpHolder.Accept (uv_stream_t*,ANY)",inspector_socket.cc,"TcpHolder::Pointer TcpHolder::Accept(
    uv_stream_t* server,
    InspectorSocket::DelegatePointer delegate) {
  TcpHolder* result = new TcpHolder(std::move(delegate));
  uv_stream_t* tcp = reinterpret_cast<uv_stream_t*>(&result->tcp_);
  int err = uv_tcp_init(server->loop, &result->tcp_);
  if (err == 0) {
    err = uv_accept(server, tcp);
  }
  if (err == 0) {
    err = uv_read_start(tcp, allocate_buffer, OnDataReceivedCb);
  }
  if (err == 0) {
    return TcpHolder::Pointer(result);
  } else {
    delete result;
    return nullptr;
  }
}",697.0,715.0,1.0,1.0,19.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,Pointer
2686,96109,SetHandler,1,node.inspector.TcpHolder.SetHandler,void node.inspector.TcpHolder.SetHandler (ProtocolHandler*),inspector_socket.cc,"void TcpHolder::SetHandler(ProtocolHandler* handler) {
  handler_ = handler;
}",717.0,719.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
2687,96114,WriteRaw,1,node.inspector.TcpHolder.WriteRaw,"int node.inspector.TcpHolder.WriteRaw (ANY,uv_write_cb)",inspector_socket.cc,"int TcpHolder::WriteRaw(const std::vector<char>& buffer, uv_write_cb write_cb) {
#if DUMP_WRITES
  printf(""%s (%ld bytes):\n"", __FUNCTION__, buffer.size());
  dump_hex(buffer.data(), buffer.size());
  printf(""\n"");
#endif

  // Freed in write_request_cleanup
  WriteRequest* wr = new WriteRequest(handler_, buffer);
  uv_stream_t* stream = reinterpret_cast<uv_stream_t*>(&tcp_);
  int err = uv_write(&wr->req, stream, &wr->buf, 1, write_cb);
  if (err < 0)
    delete wr;
  return err < 0;
}",721.0,735.0,1.0,4.0,15.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
2688,96120,tcp,1,node.inspector.TcpHolder.tcp,uv_tcp_t node.inspector.TcpHolder.tcp (),inspector_socket.cc,"uv_tcp_t* tcp() {
    return &tcp_;
  }",30.0,32.0,3.0,3.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,uv_tcp_t
2689,96127,delegate,1,node.inspector.TcpHolder.delegate,ANY* node.inspector.TcpHolder.delegate (),inspector_socket.cc,"InspectorSocket::Delegate* TcpHolder::delegate() {
  return delegate_.get();
}",737.0,739.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,Delegate
2690,96131,From,1,node.inspector.TcpHolder.From,TcpHolder node.inspector.TcpHolder.From (void*),inspector_socket.cc,"static TcpHolder* From(void* handle) {
    return node::ContainerOf(&TcpHolder::tcp_,
                             reinterpret_cast<uv_tcp_t*>(handle));
  }",36.0,39.0,3.0,3.0,4.0,4,3,3,3,0,1,1,1,0,0,,0,1,2,1,1,TcpHolder
2691,96148,OnClosed,1,node.inspector.TcpHolder.OnClosed,void node.inspector.TcpHolder.OnClosed (uv_handle_t*),inspector_socket.cc,"void TcpHolder::OnClosed(uv_handle_t* handle) {
  delete From(handle);
}",742.0,744.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
2692,96153,OnDataReceivedCb,1,node.inspector.TcpHolder.OnDataReceivedCb,"void node.inspector.TcpHolder.OnDataReceivedCb (uv_stream_t*,ssize_t,uv_buf_t*)",inspector_socket.cc,"void TcpHolder::OnDataReceivedCb(uv_stream_t* tcp, ssize_t nread,
                                 const uv_buf_t* buf) {
#if DUMP_READS
  if (nread >= 0) {
    printf(""%s (%ld bytes)\n"", __FUNCTION__, nread);
    dump_hex(buf->base, nread);
  } else {
    printf(""[%s:%d] %s\n"", __FUNCTION__, __LINE__, uv_err_name(nread));
  }
#endif
  TcpHolder* holder = From(tcp);
  holder->ReclaimUvBuf(buf, nread);
  if (nread < 0 || nread == UV_EOF) {
    holder->handler_->OnEof();
  } else {
    holder->handler_->OnData(&holder->buffer);
  }
}",746.0,763.0,1.0,4.0,18.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,void
2693,96160,TcpHolder,1,node.inspector.TcpHolder.TcpHolder,explicit node.inspector.TcpHolder.TcpHolder (ANY),inspector_socket.cc,"TcpHolder::TcpHolder(InspectorSocket::DelegatePointer delegate)
                     : tcp_(),
                       delegate_(std::move(delegate)),
                       handler_(nullptr) { }",691.0,694.0,1.0,44.0,4.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
2694,96165,~TcpHolder,1,node.inspector.TcpHolder.~TcpHolder,ANY node.inspector.TcpHolder.~TcpHolder (),inspector_socket.cc,~TcpHolder() = default;,44.0,44.0,3.0,25.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
2695,96169,ReclaimUvBuf,1,node.inspector.TcpHolder.ReclaimUvBuf,"void node.inspector.TcpHolder.ReclaimUvBuf (uv_buf_t*,ssize_t)",inspector_socket.cc,"void TcpHolder::ReclaimUvBuf(const uv_buf_t* buf, ssize_t read) {
  if (read > 0) {
    buffer.insert(buffer.end(), buf->base, buf->base + read);
  }
  delete[] buf->base;
}",771.0,776.0,1.0,1.0,6.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
2696,96180,ProtocolHandler,1,node.inspector.ProtocolHandler.ProtocolHandler,"ANY node.inspector.ProtocolHandler.ProtocolHandler (InspectorSocket*,ANY)",inspector_socket.cc,"ProtocolHandler::ProtocolHandler(InspectorSocket* inspector,
                                 TcpHolder::Pointer tcp)
                                 : inspector_(inspector), tcp_(std::move(tcp)) {
  CHECK_NOT_NULL(tcp_);
  tcp_->SetHandler(this);
}",653.0,658.0,1.0,1.0,6.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,ANY
2697,96186,AcceptUpgrade,1,node.inspector.ProtocolHandler.AcceptUpgrade,void node.inspector.ProtocolHandler.AcceptUpgrade (ANY),inspector_socket.cc,virtual void AcceptUpgrade(const std::string& accept_key) = 0;,58.0,58.0,16.0,63.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
2698,96191,OnData,1,node.inspector.ProtocolHandler.OnData,void node.inspector.ProtocolHandler.OnData (ANY*),inspector_socket.cc,virtual void OnData(std::vector<char>* data) = 0;,59.0,59.0,16.0,50.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
2699,96196,OnEof,1,node.inspector.ProtocolHandler.OnEof,void node.inspector.ProtocolHandler.OnEof (),inspector_socket.cc,virtual void OnEof() = 0;,60.0,60.0,16.0,26.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2700,96200,Write,1,node.inspector.ProtocolHandler.Write,void node.inspector.ProtocolHandler.Write (ANY),inspector_socket.cc,virtual void Write(const std::vector<char> data) = 0;,61.0,61.0,16.0,54.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
2701,96205,CancelHandshake,1,node.inspector.ProtocolHandler.CancelHandshake,void node.inspector.ProtocolHandler.CancelHandshake (),inspector_socket.cc,virtual void CancelHandshake() = 0;,62.0,62.0,16.0,36.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2702,96209,GetHost,1,node.inspector.ProtocolHandler.GetHost,ANY node.inspector.ProtocolHandler.GetHost (),inspector_socket.cc,"std::string ProtocolHandler::GetHost() const {
  char ip[INET6_ADDRSTRLEN];
  sockaddr_storage addr;
  int len = sizeof(addr);
  int err = uv_tcp_getsockname(tcp_->tcp(),
                               reinterpret_cast<struct sockaddr*>(&addr),
                               &len);
  if (err != 0)
    return """";
  if (addr.ss_family == AF_INET6) {
    const sockaddr_in6* v6 = reinterpret_cast<const sockaddr_in6*>(&addr);
    err = uv_ip6_name(v6, ip, sizeof(ip));
  } else {
    const sockaddr_in* v4 = reinterpret_cast<const sockaddr_in*>(&addr);
    err = uv_ip4_name(v4, ip, sizeof(ip));
  }
  if (err != 0)
    return """";
  return ip;
}",669.0,688.0,1.0,1.0,20.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,string
2703,96213,inspector,1,node.inspector.ProtocolHandler.inspector,InspectorSocket node.inspector.ProtocolHandler.inspector (),inspector_socket.cc,"InspectorSocket* inspector() {
    return inspector_;
  }",66.0,68.0,3.0,3.0,3.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,InspectorSocket
2704,96219,Shutdown,1,node.inspector.ProtocolHandler.Shutdown,void node.inspector.ProtocolHandler.Shutdown (),inspector_socket.cc,virtual void Shutdown() = 0;,69.0,69.0,16.0,29.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2705,96223,~ProtocolHandler,1,node.inspector.ProtocolHandler.~ProtocolHandler,ANY node.inspector.ProtocolHandler.~ProtocolHandler (),inspector_socket.cc,virtual ~ProtocolHandler() = default;,72.0,72.0,3.0,39.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
2706,96227,WriteRaw,1,node.inspector.ProtocolHandler.WriteRaw,"int node.inspector.ProtocolHandler.WriteRaw (ANY,uv_write_cb)",inspector_socket.cc,"int ProtocolHandler::WriteRaw(const std::vector<char>& buffer,
                              uv_write_cb write_cb) {
  return tcp_->WriteRaw(buffer, write_cb);
}",660.0,663.0,1.0,1.0,4.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
2707,96233,delegate,1,node.inspector.ProtocolHandler.delegate,ANY* node.inspector.ProtocolHandler.delegate (),inspector_socket.cc,"InspectorSocket::Delegate* ProtocolHandler::delegate() {
  return tcp_->delegate();
}",665.0,667.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,Delegate
2708,96241,WriteRequest,1,node.inspector.anonymous_namespace_2.WriteRequest.WriteRequest,"ANY node.inspector.anonymous_namespace_2.WriteRequest.WriteRequest (ProtocolHandler*,ANY)",inspector_socket.cc,"WriteRequest(ProtocolHandler* handler, const std::vector<char>& buffer)
      : handler(handler)
      , storage(buffer)
      , req(uv_write_t())
      , buf(uv_buf_init(storage.data(), storage.size())) {}",110.0,114.0,3.0,59.0,5.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,ANY
2709,96247,from_write_req,1,node.inspector.anonymous_namespace_3.WriteRequest.from_write_req,WriteRequest node.inspector.anonymous_namespace_3.WriteRequest.from_write_req (uv_write_t*),inspector_socket.cc,"static WriteRequest* from_write_req(uv_write_t* req) {
    return node::ContainerOf(&WriteRequest::req, req);
  }",116.0,118.0,3.0,3.0,3.0,3,2,3,3,0,1,1,1,0,0,,0,1,2,1,1,WriteRequest
2710,96262,Cleanup,1,node.inspector.anonymous_namespace_4.WriteRequest.Cleanup,"void node.inspector.anonymous_namespace_4.WriteRequest.Cleanup (uv_write_t*,int)",inspector_socket.cc,"static void Cleanup(uv_write_t* req, int status) {
    delete WriteRequest::from_write_req(req);
  }",120.0,122.0,3.0,3.0,3.0,2,2,2,2,0,0,1,1,0,0,,0,0,4,2,2,void
2711,96278,allocate_buffer,1,node.inspector.anonymous_namespace_6.allocate_buffer,"void node.inspector.anonymous_namespace_6.allocate_buffer (uv_handle_t*,size_t,uv_buf_t*)",inspector_socket.cc,"void allocate_buffer(uv_handle_t* stream, size_t len, uv_buf_t* buf) {
  *buf = uv_buf_init(new char[len], len);
}",130.0,132.0,1.0,1.0,3.0,3,3,3,3,0,0,1,1,0,0,,0,0,6,3,3,void
2712,96292,remove_from_beginning,1,node.inspector.anonymous_namespace_7.remove_from_beginning,"void node.inspector.anonymous_namespace_7.remove_from_beginning (ANY*,size_t)",inspector_socket.cc,"static void remove_from_beginning(std::vector<char>* buffer, size_t count) {
  buffer->erase(buffer->begin(), buffer->begin() + count);
}",134.0,136.0,1.0,1.0,3.0,4,2,4,2,0,0,1,1,0,0,,0,0,4,2,2,void
2713,96323,generate_accept_string,1,node.inspector.anonymous_namespace_9.generate_accept_string,"void node.inspector.anonymous_namespace_9.generate_accept_string (ANY,char[ACCEPT_KEY_LENGTH])",inspector_socket.cc,"static void generate_accept_string(const std::string& client_key,
                                   char (*buffer)[ACCEPT_KEY_LENGTH]) {
  // Magic string from websockets spec.
  static const char ws_magic[] = ""258EAFA5-E914-47DA-95CA-C5AB0DC85B11"";
  std::string input(client_key + ws_magic);
  char hash[SHA_DIGEST_LENGTH];
  USE(SHA1(reinterpret_cast<const unsigned char*>(input.data()),
           input.size(),
           reinterpret_cast<unsigned char*>(hash)));
  node::base64_encode(hash, sizeof(hash), *buffer, sizeof(*buffer));
}",144.0,154.0,1.0,50.0,11.0,11,6,11,6,0,0,1,1,0,0,,0,0,4,2,2,void
2714,96366,TrimPort,1,node.inspector.anonymous_namespace_10.TrimPort,string node.inspector.anonymous_namespace_10.TrimPort (ANY),inspector_socket.cc,"static std::string TrimPort(const std::string& host) {
  size_t last_colon_pos = host.rfind(':');
  if (last_colon_pos == std::string::npos)
    return host;
  size_t bracket = host.rfind(']');
  if (bracket == std::string::npos || last_colon_pos > bracket)
    return host.substr(0, last_colon_pos);
  return host;
}",156.0,164.0,1.0,1.0,9.0,13,5,16,5,0,0,3,3,0,0,,0,0,2,1,1,string
2715,96420,IsIPAddress,1,node.inspector.anonymous_namespace_11.IsIPAddress,bool node.inspector.anonymous_namespace_11.IsIPAddress (ANY),inspector_socket.cc,"static bool IsIPAddress(const std::string& host) {
  // To avoid DNS rebinding attacks, we are aware of the following requirements:
  // * the host name must be an IP address (CVE-2018-7160, CVE-2022-32212),
  // * the IP address must be routable (hackerone.com/reports/1632921), and
  // * the IP address must be formatted unambiguously (CVE-2022-43548).

  // The logic below assumes that the string is null-terminated, so ensure that
  // we did not somehow end up with null characters within the string.
  if (host.find('\0') != std::string::npos) return false;

  // All IPv6 addresses must be enclosed in square brackets, and anything
  // enclosed in square brackets must be an IPv6 address.
  if (host.length() >= 4 && host.front() == '[' && host.back() == ']') {
    // INET6_ADDRSTRLEN is the maximum length of the dual format (including the
    // terminating null character), which is the longest possible representation
    // of an IPv6 address: xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:ddd.ddd...",166.0,230.0,1.0,1.0,65.0,35,10,28,9,0,0,9,13,0,0,,0,0,2,1,1,bool
2716,96636,encode_frame_hybi17,1,node.inspector.anonymous_namespace_13.encode_frame_hybi17,vector<char> node.inspector.anonymous_namespace_13.encode_frame_hybi17 (ANY),inspector_socket.cc,"static std::vector<char> encode_frame_hybi17(const std::vector<char>& message) {
  std::vector<char> frame;
  OpCode op_code = kOpCodeText;
  frame.push_back(kFinalBit | op_code);
  const size_t data_length = message.size();
  if (data_length <= kMaxSingleBytePayloadLength) {
    frame.push_back(static_cast<char>(data_length));
  } else if (data_length <= 0xFFFF) {
    frame.push_back(kTwoBytePayloadLengthField);
    frame.push_back((data_length & 0xFF00) >> 8);
    frame.push_back(data_length & 0xFF);
  } else {
    frame.push_back(kEightBytePayloadLengthField);
    char extended_payload_length[8];
    size_t remaining = data_length;
    // Fill the length into extended_payload_length in the network byte order.
    for (int i = 0; i < 8; ++i) {
      extended_payload_length[7 - i] = remaining & 0xFF;
      remaining >>= 8;
    }
    frame.insert(frame.end(), extended_payload_length,
                 extended_payload_length + 8);
    CHECK_EQ(0, remaining);
  }
  frame.insert(frame....",256.0,282.0,1.0,1.0,27.0,12,5,16,7,0,0,2,2,0,0,,0,0,2,1,1,vector<char>
2717,96769,decode_frame_hybi17,1,node.inspector.anonymous_namespace_14.decode_frame_hybi17,"ws_decode_result node.inspector.anonymous_namespace_14.decode_frame_hybi17 (ANY,bool,int*,ANY*,bool*)",inspector_socket.cc,"static ws_decode_result decode_frame_hybi17(const std::vector<char>& buffer,
                                            bool client_frame,
                                            int* bytes_consumed,
                                            std::vector<char>* output,
                                            bool* compressed) {
  *bytes_consumed = 0;
  if (buffer.size() < 2)
    return FRAME_INCOMPLETE;

  auto it = buffer.begin();

  unsigned char first_byte = *it++;
  unsigned char second_byte = *it++;

  bool final = (first_byte & kFinalBit) != 0;
  bool reserved1 = (first_byte & kReserved1Bit) != 0;
  bool reserved2 = (first_byte & kReserved2Bit) != 0;
  bool reserved3 = (first_byte & kReserved3Bit) != 0;
  int op_code = first_byte & kOpCodeMask;
  bool masked = (second_byte & kMaskBit) != 0;
  *compressed = reserved1;
  if (!final || reserved2 || reserved3)
    return FRAME_ERROR;  // Only compression extension is supported.

  bool closed = false;
  switch (op_code) ...",284.0,368.0,1.0,1.0,85.0,76,16,98,44,0,0,14,15,0,0,,0,0,10,5,5,ws_decode_result
2718,97077,WsHandler,1,node.inspector.anonymous_namespace_16.WsHandler.WsHandler,"ANY node.inspector.anonymous_namespace_16.WsHandler.WsHandler (InspectorSocket*,ANY)",inspector_socket.cc,"WsHandler(InspectorSocket* inspector, TcpHolder::Pointer tcp)
            : ProtocolHandler(inspector, std::move(tcp)),
              OnCloseSent(&WsHandler::WaitForCloseReply),
              OnCloseReceived(&WsHandler::CloseFrameReceived),
              dispose_(false) { }",373.0,377.0,3.0,33.0,5.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,ANY
2719,97083,AcceptUpgrade,1,node.inspector.anonymous_namespace_17.WsHandler.AcceptUpgrade,void node.inspector.anonymous_namespace_17.WsHandler.AcceptUpgrade (ANY),inspector_socket.cc,void AcceptUpgrade(const std::string& accept_key) override { },379.0,379.0,3.0,64.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
2720,97088,CancelHandshake,1,node.inspector.anonymous_namespace_18.WsHandler.CancelHandshake,void node.inspector.anonymous_namespace_18.WsHandler.CancelHandshake (),inspector_socket.cc,void CancelHandshake() override {},380.0,380.0,3.0,36.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2721,97092,OnEof,1,node.inspector.anonymous_namespace_19.WsHandler.OnEof,void node.inspector.anonymous_namespace_19.WsHandler.OnEof (),inspector_socket.cc,"void OnEof() override {
    tcp_.reset();
    if (dispose_)
      delete this;
  }",382.0,386.0,3.0,3.0,5.0,2,2,2,2,0,1,2,2,1,0,,0,1,0,0,0,void
2722,97105,OnData,1,node.inspector.anonymous_namespace_20.WsHandler.OnData,void node.inspector.anonymous_namespace_20.WsHandler.OnData (ANY*),inspector_socket.cc,"void OnData(std::vector<char>* data) override {
    // 1. Parse.
    int processed = 0;
    do {
      processed = ParseWsFrames(*data);
      // 2. Fix the data size & length
      if (processed > 0) {
        remove_from_beginning(data, processed);
      }
    } while (processed > 0 && !data->empty());
  }",388.0,398.0,3.0,3.0,11.0,8,6,8,2,0,0,3,4,0,0,,0,0,2,1,1,void
2723,97138,Write,1,node.inspector.anonymous_namespace_22.WsHandler.Write,void node.inspector.anonymous_namespace_22.WsHandler.Write (ANY),inspector_socket.cc,"void Write(const std::vector<char> data) override {
    std::vector<char> output = encode_frame_hybi17(data);
    WriteRaw(output, WriteRequest::Cleanup);
  }",400.0,403.0,3.0,3.0,4.0,2,2,4,3,0,0,1,1,0,0,,0,0,2,1,1,void
2724,97153,Shutdown,1,node.inspector.anonymous_namespace_24.WsHandler.Shutdown,void node.inspector.anonymous_namespace_24.WsHandler.Shutdown (),inspector_socket.cc,"void Shutdown() override {
    if (tcp_) {
      dispose_ = true;
      SendClose();
    } else {
      delete this;
    }
  }",406.0,413.0,3.0,3.0,8.0,1,1,2,2,0,1,2,2,0,0,,0,1,0,0,0,void
2725,97169,OnCloseFrameWritten,1,node.inspector.anonymous_namespace_26.WsHandler.OnCloseFrameWritten,"void node.inspector.anonymous_namespace_26.WsHandler.OnCloseFrameWritten (uv_write_t*,int)",inspector_socket.cc,"static void OnCloseFrameWritten(uv_write_t* req, int status) {
    WriteRequest* wr = WriteRequest::from_write_req(req);
    WsHandler* handler = static_cast<WsHandler*>(wr->handler);
    delete wr;
    Callback cb = handler->OnCloseSent;
    (handler->*cb)();
  }",418.0,424.0,3.0,3.0,7.0,9,5,10,5,0,2,1,1,0,0,,0,2,4,2,2,void
2726,97203,WaitForCloseReply,1,node.inspector.anonymous_namespace_28.WsHandler.WaitForCloseReply,void node.inspector.anonymous_namespace_28.WsHandler.WaitForCloseReply (),inspector_socket.cc,"void WaitForCloseReply() {
    OnCloseReceived = &WsHandler::OnEof;
  }",426.0,428.0,3.0,3.0,3.0,3,3,2,2,0,1,1,1,0,0,,0,1,0,0,0,void
2727,97213,SendClose,1,node.inspector.anonymous_namespace_29.WsHandler.SendClose,void node.inspector.anonymous_namespace_29.WsHandler.SendClose (),inspector_socket.cc,"void SendClose() {
    WriteRaw(std::vector<char>(CLOSE_FRAME, CLOSE_FRAME + sizeof(CLOSE_FRAME)),
             OnCloseFrameWritten);
  }",430.0,433.0,3.0,3.0,4.0,3,3,4,2,0,0,1,1,0,0,,0,0,0,0,0,void
2728,97228,CloseFrameReceived,1,node.inspector.anonymous_namespace_31.WsHandler.CloseFrameReceived,void node.inspector.anonymous_namespace_31.WsHandler.CloseFrameReceived (),inspector_socket.cc,"void CloseFrameReceived() {
    OnCloseSent = &WsHandler::OnEof;
    SendClose();
  }",435.0,438.0,3.0,3.0,4.0,3,3,2,2,0,1,1,1,0,0,,0,1,0,0,0,void
2729,97239,ParseWsFrames,1,node.inspector.anonymous_namespace_33.WsHandler.ParseWsFrames,int node.inspector.anonymous_namespace_33.WsHandler.ParseWsFrames (ANY),inspector_socket.cc,"int ParseWsFrames(const std::vector<char>& buffer) {
    int bytes_consumed = 0;
    std::vector<char> output;
    bool compressed = false;

    ws_decode_result r =  decode_frame_hybi17(buffer,
                                              true /* client_frame */,
                                              &bytes_consumed, &output,
                                              &compressed);
    // Compressed frame means client is ignoring the headers and misbehaves
    if (compressed || r == FRAME_ERROR) {
      OnEof();
      bytes_consumed = 0;
    } else if (r == FRAME_CLOSE) {
      (this->*OnCloseReceived)();
      bytes_consumed = 0;
    } else if (r == FRAME_OK) {
      delegate()->OnWsFrame(output);
    }
    return bytes_consumed;
  }",440.0,460.0,3.0,3.0,21.0,9,4,12,6,0,0,2,2,0,0,,0,0,2,1,1,int
2730,97308,HttpEvent,1,node.inspector.anonymous_namespace_37.HttpEvent.HttpEvent,"ANY node.inspector.anonymous_namespace_37.HttpEvent.HttpEvent (ANY,bool,bool,ANY,ANY)",inspector_socket.cc,"HttpEvent(const std::string& path, bool upgrade, bool isGET,
            const std::string& ws_key, const std::string& host)
            : path(path), upgrade(upgrade), isGET(isGET), ws_key(ws_key),
              host(host) { }",471.0,474.0,3.0,28.0,4.0,0,0,0,0,0,0,1,1,0,0,,0,0,10,5,5,ANY
2731,97323,HttpHandler,1,node.inspector.anonymous_namespace_39.HttpHandler.HttpHandler,"ANY node.inspector.anonymous_namespace_39.HttpHandler.HttpHandler (InspectorSocket*,ANY)",inspector_socket.cc,"explicit HttpHandler(InspectorSocket* inspector, TcpHolder::Pointer tcp)
                       : ProtocolHandler(inspector, std::move(tcp)),
                         parsing_value_(false) {
    llhttp_init(&parser_, HTTP_REQUEST, &parser_settings);
    llhttp_settings_init(&parser_settings);
    parser_settings.on_header_field = OnHeaderField;
    parser_settings.on_header_value = OnHeaderValue;
    parser_settings.on_message_complete = OnMessageComplete;
    parser_settings.on_url = OnPath;
  }",485.0,494.0,3.0,3.0,10.0,11,3,8,3,0,7,1,1,0,0,,0,7,4,2,2,ANY
2732,97358,AcceptUpgrade,1,node.inspector.anonymous_namespace_44.HttpHandler.AcceptUpgrade,void node.inspector.anonymous_namespace_44.HttpHandler.AcceptUpgrade (ANY),inspector_socket.cc,"void AcceptUpgrade(const std::string& accept_key) override {
    char accept_string[ACCEPT_KEY_LENGTH];
    generate_accept_string(accept_key, &accept_string);
    const char accept_ws_prefix[] = ""HTTP/1.1 101 Switching Protocols\r\n""
                                    ""Upgrade: websocket\r\n""
                                    ""Connection: Upgrade\r\n""
                                    ""Sec-WebSocket-Accept: "";
    const char accept_ws_suffix[] = ""\r\n\r\n"";
    std::vector<char> reply(accept_ws_prefix,
                            accept_ws_prefix + sizeof(accept_ws_prefix) - 1);
    reply.insert(reply.end(), accept_string,
                 accept_string + sizeof(accept_string));
    reply.insert(reply.end(), accept_ws_suffix,
                 accept_ws_suffix + sizeof(accept_ws_suffix) - 1);
    if (WriteRaw(reply, WriteRequest::Cleanup) >= 0) {
      inspector_->SwitchProtocol(new WsHandler(inspector_, std::move(tcp_)));
    } else {
      tcp_.reset();
    }
  }",496.0,515.0,3.0,23.0,20.0,20,9,24,10,0,0,2,2,0,0,,0,0,2,1,1,void
2733,97440,CancelHandshake,1,node.inspector.anonymous_namespace_46.HttpHandler.CancelHandshake,void node.inspector.anonymous_namespace_46.HttpHandler.CancelHandshake (),inspector_socket.cc,"void CancelHandshake() override {
    const char HANDSHAKE_FAILED_RESPONSE[] =
        ""HTTP/1.0 400 Bad Request\r\n""
        ""Content-Type: text/html; charset=UTF-8\r\n\r\n""
        ""WebSockets request was expected\r\n"";
    WriteRaw(std::vector<char>(HANDSHAKE_FAILED_RESPONSE,
             HANDSHAKE_FAILED_RESPONSE + sizeof(HANDSHAKE_FAILED_RESPONSE) - 1),
             ThenCloseAndReportFailure);
  }",517.0,525.0,3.0,3.0,9.0,5,5,5,2,0,0,1,1,0,0,,0,0,0,0,0,void
2734,97461,OnEof,1,node.inspector.anonymous_namespace_48.HttpHandler.OnEof,void node.inspector.anonymous_namespace_48.HttpHandler.OnEof (),inspector_socket.cc,"void OnEof() override {
    tcp_.reset();
  }",528.0,530.0,3.0,3.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
2735,97469,OnData,1,node.inspector.anonymous_namespace_49.HttpHandler.OnData,void node.inspector.anonymous_namespace_49.HttpHandler.OnData (ANY*),inspector_socket.cc,"void OnData(std::vector<char>* data) override {
    llhttp_errno_t err;
    err = llhttp_execute(&parser_, data->data(), data->size());

    if (err == HPE_PAUSED_UPGRADE) {
      err = HPE_OK;
      llhttp_resume_after_upgrade(&parser_);
    }
    data->clear();
    if (err != HPE_OK) {
      CancelHandshake();
    }
    // Event handling may delete *this
    std::vector<HttpEvent> events;
    std::swap(events, events_);
    for (const HttpEvent& event : events) {
      if (!IsAllowedHost(event.host) || !event.isGET) {
        CancelHandshake();
        return;
      } else if (!event.upgrade) {
        delegate()->OnHttpGet(event.host, event.path);
      } else if (event.ws_key.empty()) {
        CancelHandshake();
        return;
      } else {
        delegate()->OnSocketUpgrade(event.host, event.path, event.ws_key);
      }
    }
  }",532.0,560.0,3.0,3.0,29.0,15,8,18,9,0,5,5,6,2,0,,0,5,2,1,1,void
2736,97579,Write,1,node.inspector.anonymous_namespace_54.HttpHandler.Write,void node.inspector.anonymous_namespace_54.HttpHandler.Write (ANY),inspector_socket.cc,"void Write(const std::vector<char> data) override {
    WriteRaw(data, WriteRequest::Cleanup);
  }",562.0,564.0,3.0,3.0,3.0,1,1,2,2,0,0,1,1,0,0,,0,0,2,1,1,void
2737,97589,Shutdown,1,node.inspector.anonymous_namespace_55.HttpHandler.Shutdown,void node.inspector.anonymous_namespace_55.HttpHandler.Shutdown (),inspector_socket.cc,"void Shutdown() override {
    delete this;
  }",567.0,569.0,3.0,3.0,3.0,1,1,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2738,97595,ThenCloseAndReportFailure,1,node.inspector.anonymous_namespace_56.HttpHandler.ThenCloseAndReportFailure,"void node.inspector.anonymous_namespace_56.HttpHandler.ThenCloseAndReportFailure (uv_write_t*,int)",inspector_socket.cc,"static void ThenCloseAndReportFailure(uv_write_t* req, int status) {
    ProtocolHandler* handler = WriteRequest::from_write_req(req)->handler;
    WriteRequest::Cleanup(req, status);
    handler->inspector()->SwitchProtocol(nullptr);
  }",572.0,576.0,3.0,3.0,5.0,6,3,7,4,0,0,1,1,0,0,,0,0,4,2,2,void
2739,97625,OnHeaderValue,1,node.inspector.anonymous_namespace_59.HttpHandler.OnHeaderValue,"int node.inspector.anonymous_namespace_59.HttpHandler.OnHeaderValue (llhttp_t*,char*,size_t)",inspector_socket.cc,"static int OnHeaderValue(llhttp_t* parser, const char* at, size_t length) {
    HttpHandler* handler = From(parser);
    handler->parsing_value_ = true;
    handler->headers_[handler->current_header_].append(at, length);
    return 0;
  }",578.0,583.0,3.0,3.0,6.0,7,4,7,4,0,3,1,1,0,0,,0,3,6,3,3,int
2740,97656,OnHeaderField,1,node.inspector.anonymous_namespace_62.HttpHandler.OnHeaderField,"int node.inspector.anonymous_namespace_62.HttpHandler.OnHeaderField (llhttp_t*,char*,size_t)",inspector_socket.cc,"static int OnHeaderField(llhttp_t* parser, const char* at, size_t length) {
    HttpHandler* handler = From(parser);
    if (handler->parsing_value_) {
      handler->parsing_value_ = false;
      handler->current_header_.clear();
    }
    handler->current_header_.append(at, length);
    return 0;
  }",585.0,593.0,3.0,3.0,9.0,8,3,8,4,0,4,2,2,1,0,,0,4,6,3,3,int
2741,97694,OnPath,1,node.inspector.anonymous_namespace_65.HttpHandler.OnPath,"int node.inspector.anonymous_namespace_65.HttpHandler.OnPath (llhttp_t*,char*,size_t)",inspector_socket.cc,"static int OnPath(llhttp_t* parser, const char* at, size_t length) {
    HttpHandler* handler = From(parser);
    handler->path_.append(at, length);
    return 0;
  }",595.0,599.0,3.0,3.0,5.0,3,3,5,4,0,1,1,1,0,0,,0,1,6,3,3,int
2742,97716,From,1,node.inspector.anonymous_namespace_68.HttpHandler.From,HttpHandler node.inspector.anonymous_namespace_68.HttpHandler.From (llhttp_t*),inspector_socket.cc,"static HttpHandler* From(llhttp_t* parser) {
    return node::ContainerOf(&HttpHandler::parser_, parser);
  }",601.0,603.0,3.0,3.0,3.0,3,2,3,3,0,1,1,1,0,0,,0,1,2,1,1,HttpHandler
2743,97731,OnMessageComplete,1,node.inspector.anonymous_namespace_69.HttpHandler.OnMessageComplete,int node.inspector.anonymous_namespace_69.HttpHandler.OnMessageComplete (llhttp_t*),inspector_socket.cc,"static int OnMessageComplete(llhttp_t* parser) {
    // Event needs to be fired after the parser is done.
    HttpHandler* handler = From(parser);
    handler->events_.emplace_back(handler->path_,
                                  parser->upgrade,
                                  parser->method == HTTP_GET,
                                  handler->HeaderValue(""Sec-WebSocket-Key""),
                                  handler->HeaderValue(""Host""));
    handler->path_ = """";
    handler->parsing_value_ = false;
    handler->headers_.clear();
    handler->current_header_ = """";
    return 0;
  }",605.0,618.0,3.0,3.0,14.0,17,4,13,3,0,6,1,1,0,0,,0,6,2,1,1,int
2744,97791,HeaderValue,1,node.inspector.anonymous_namespace_72.HttpHandler.HeaderValue,string node.inspector.anonymous_namespace_72.HttpHandler.HeaderValue (ANY),inspector_socket.cc,"std::string HeaderValue(const std::string& header) const {
    bool header_found = false;
    std::string value;
    for (const auto& header_value : headers_) {
      if (node::StringEqualNoCaseN(header_value.first.data(), header.data(),
                                   header.length())) {
        if (header_found)
          return """";
        value = header_value.second;
        header_found = true;
      }
    }
    return value;
  }",620.0,633.0,3.0,3.0,14.0,9,2,11,6,0,1,4,7,1,0,,0,1,2,1,1,string
2745,97840,IsAllowedHost,1,node.inspector.anonymous_namespace_73.HttpHandler.IsAllowedHost,bool node.inspector.anonymous_namespace_73.HttpHandler.IsAllowedHost (ANY),inspector_socket.cc,"bool IsAllowedHost(const std::string& host_with_port) const {
    std::string host = TrimPort(host_with_port);
    return host.empty() || IsIPAddress(host)
           || node::StringEqualNoCase(host.data(), ""localhost"");
  }",635.0,639.0,3.0,3.0,5.0,6,3,6,3,0,0,1,1,0,0,,0,0,2,1,1,bool
2746,98231,~InspectorSocket,1,node.inspector.InspectorSocket.~InspectorSocket,ANY node.inspector.InspectorSocket.~InspectorSocket (),inspector_socket.cc,InspectorSocket::~InspectorSocket() = default;,778.0,778.0,1.0,46.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
2747,98235,Shutdown,1,node.inspector.InspectorSocket.Shutdown,void node.inspector.InspectorSocket.Shutdown (ProtocolHandler*),inspector_socket.cc,"void InspectorSocket::Shutdown(ProtocolHandler* handler) {
  handler->Shutdown();
}",781.0,783.0,1.0,1.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,void
2748,98244,Accept,1,node.inspector.InspectorSocket.Accept,"Pointer node.inspector.InspectorSocket.Accept (uv_stream_t*,DelegatePointer)",inspector_socket.cc,"InspectorSocket::Pointer InspectorSocket::Accept(uv_stream_t* server,
                                                 DelegatePointer delegate) {
  auto tcp = TcpHolder::Accept(server, std::move(delegate));
  if (tcp) {
    InspectorSocket* inspector = new InspectorSocket();
    inspector->SwitchProtocol(new HttpHandler(inspector, std::move(tcp)));
    return InspectorSocket::Pointer(inspector);
  } else {
    return InspectorSocket::Pointer(nullptr);
  }
}",786.0,796.0,1.0,1.0,11.0,9,4,15,8,0,0,2,2,0,0,,0,0,4,2,2,Pointer
2749,98297,AcceptUpgrade,1,node.inspector.InspectorSocket.AcceptUpgrade,void node.inspector.InspectorSocket.AcceptUpgrade (ANY),inspector_socket.cc,"void InspectorSocket::AcceptUpgrade(const std::string& ws_key) {
  protocol_handler_->AcceptUpgrade(ws_key);
}",798.0,800.0,1.0,1.0,3.0,1,1,2,2,0,0,1,1,0,0,,0,0,2,1,1,void
2750,98307,CancelHandshake,1,node.inspector.InspectorSocket.CancelHandshake,void node.inspector.InspectorSocket.CancelHandshake (),inspector_socket.cc,"void InspectorSocket::CancelHandshake() {
  protocol_handler_->CancelHandshake();
}",802.0,804.0,1.0,1.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
2751,98315,GetHost,1,node.inspector.InspectorSocket.GetHost,string node.inspector.InspectorSocket.GetHost (),inspector_socket.cc,"std::string InspectorSocket::GetHost() {
  return protocol_handler_->GetHost();
}",806.0,808.0,1.0,1.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,string
2752,98324,SwitchProtocol,1,node.inspector.InspectorSocket.SwitchProtocol,void node.inspector.InspectorSocket.SwitchProtocol (ProtocolHandler*),inspector_socket.cc,"void InspectorSocket::SwitchProtocol(ProtocolHandler* handler) {
  protocol_handler_.reset(std::move(handler));
}",810.0,812.0,1.0,1.0,3.0,2,1,3,3,0,0,1,1,0,0,,0,0,2,1,1,void
2753,98338,Write,1,node.inspector.InspectorSocket.Write,"void node.inspector.InspectorSocket.Write (char*,size_t)",inspector_socket.cc,"void InspectorSocket::Write(const char* data, size_t len) {
  protocol_handler_->Write(std::vector<char>(data, data + len));
}",814.0,816.0,1.0,1.0,3.0,3,3,5,4,0,0,1,1,0,0,,0,0,4,2,2,void
2754,98396,FormatWsAddress,1,node.inspector.FormatWsAddress,"ANY node.inspector.FormatWsAddress (ANY,int,ANY,bool)",inspector_socket_server.cc,"std::string FormatWsAddress(const std::string& host, int port,
                            const std::string& target_id,
                            bool include_protocol) {
  return FormatAddress(FormatHostPort(host, port), target_id, include_protocol);
}",148.0,152.0,1.0,1.0,5.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,string
2755,98409,Escape,1,node.inspector.anonymous_namespace_1.Escape,void node.inspector.anonymous_namespace_1.Escape (ANY*),inspector_socket_server.cc,"void Escape(std::string* string) {
  for (char& c : *string) {
    c = (c == '\""' || c == '\\') ? '_' : c;
  }
}",27.0,31.0,1.0,1.0,5.0,6,5,5,2,0,0,2,2,0,0,,0,0,2,1,1,void
2756,98431,FormatHostPort,1,node.inspector.anonymous_namespace_2.FormatHostPort,"string node.inspector.anonymous_namespace_2.FormatHostPort (ANY,int)",inspector_socket_server.cc,"std::string FormatHostPort(const std::string& host, int port) {
  // Host is valid (socket was bound) so colon means it's a v6 IP address
  bool v6 = host.find(':') != std::string::npos;
  std::ostringstream url;
  if (v6) {
    url << '[';
  }
  url << host;
  if (v6) {
    url << ']';
  }
  url << ':' << port;
  return url.str();
}",33.0,46.0,1.0,1.0,14.0,11,4,13,6,0,0,3,3,0,0,,0,0,4,2,2,string
2757,98477,FormatAddress,1,node.inspector.anonymous_namespace_3.FormatAddress,"string node.inspector.anonymous_namespace_3.FormatAddress (ANY,ANY,bool)",inspector_socket_server.cc,"std::string FormatAddress(const std::string& host,
                          const std::string& target_id,
                          bool include_protocol) {
  std::ostringstream url;
  if (include_protocol)
    url << ""ws://"";
  url << host << '/' << target_id;
  return url.str();
}",48.0,56.0,1.0,1.0,9.0,5,2,6,4,0,0,2,2,0,0,,0,0,6,3,3,string
2758,98503,MapToString,1,node.inspector.anonymous_namespace_4.MapToString,string node.inspector.anonymous_namespace_4.MapToString (ANY),inspector_socket_server.cc,"std::string MapToString(const std::map<std::string, std::string>& object) {
  bool first = true;
  std::ostringstream json;
  json << ""{\n"";
  for (const auto& name_value : object) {
    if (!first)
      json << "",\n"";
    first = false;
    json << ""  \"""" << name_value.first << ""\"": \"""";
    json << name_value.second << ""\"""";
  }
  json << ""\n} "";
  return json.str();
}",58.0,71.0,1.0,1.0,14.0,14,4,12,4,0,0,3,4,0,0,,0,0,2,1,1,string
2759,98554,MapsToString,1,node.inspector.anonymous_namespace_5.MapsToString,string node.inspector.anonymous_namespace_5.MapsToString (ANY),inspector_socket_server.cc,"std::string MapsToString(
    const std::vector<std::map<std::string, std::string>>& array) {
  bool first = true;
  std::ostringstream json;
  json << ""[ "";
  for (const auto& object : array) {
    if (!first)
      json << "", "";
    first = false;
    json << MapToString(object);
  }
  json << ""]\n\n"";
  return json.str();
}",73.0,86.0,1.0,1.0,14.0,8,4,10,4,0,0,3,4,0,0,,0,0,2,1,1,string
2760,98593,MatchPathSegment,1,node.inspector.anonymous_namespace_6.MatchPathSegment,"const char* node.inspector.anonymous_namespace_6.MatchPathSegment (char*,char*)",inspector_socket_server.cc,"const char* MatchPathSegment(const char* path, const char* expected) {
  size_t len = strlen(expected);
  if (StringEqualNoCaseN(path, expected, len)) {
    if (path[len] == '/') return path + len + 1;
    if (path[len] == '\0') return path + len;
  }
  return nullptr;
}",88.0,95.0,1.0,1.0,8.0,8,4,13,3,0,0,4,6,0,0,,0,0,4,2,2,const char*
2761,98636,SendHttpResponse,1,node.inspector.anonymous_namespace_7.SendHttpResponse,"void node.inspector.anonymous_namespace_7.SendHttpResponse (InspectorSocket*,ANY,int)",inspector_socket_server.cc,"void SendHttpResponse(InspectorSocket* socket,
                      const std::string& response,
                      int code) {
  const char HEADERS[] = ""HTTP/1.0 %d OK\r\n""
                         ""Content-Type: application/json; charset=UTF-8\r\n""
                         ""Cache-Control: no-cache\r\n""
                         ""Content-Length: %zu\r\n""
                         ""\r\n"";
  char header[sizeof(HEADERS) + 20];
  int header_len = snprintf(header,
                            sizeof(header),
                            HEADERS,
                            code,
                            response.size());
  socket->Write(header, header_len);
  socket->Write(response.data(), response.size());
}",97.0,113.0,1.0,1.0,17.0,8,4,13,6,0,0,1,1,0,0,,0,0,6,3,3,void
2762,98679,SendVersionResponse,1,node.inspector.anonymous_namespace_8.SendVersionResponse,void node.inspector.anonymous_namespace_8.SendVersionResponse (InspectorSocket*),inspector_socket_server.cc,"void SendVersionResponse(InspectorSocket* socket) {
  std::map<std::string, std::string> response;
  response[""Browser""] = ""node.js/"" NODE_VERSION;
  response[""Protocol-Version""] = ""1.1"";
  SendHttpResponse(socket, MapToString(response), 200);
}",115.0,120.0,1.0,35.0,6.0,10,6,8,3,0,0,1,1,0,0,,0,0,2,1,1,void
2763,98712,SendHttpNotFound,1,node.inspector.anonymous_namespace_9.SendHttpNotFound,void node.inspector.anonymous_namespace_9.SendHttpNotFound (InspectorSocket*),inspector_socket_server.cc,"void SendHttpNotFound(InspectorSocket* socket) {
  SendHttpResponse(socket, """", 404);
}",122.0,124.0,1.0,1.0,3.0,0,0,1,1,0,0,1,1,0,0,,0,0,2,1,1,void
2764,98721,SendProtocolJson,1,node.inspector.anonymous_namespace_10.SendProtocolJson,void node.inspector.anonymous_namespace_10.SendProtocolJson (InspectorSocket*),inspector_socket_server.cc,"void SendProtocolJson(InspectorSocket* socket) {
  z_stream strm;
  strm.zalloc = Z_NULL;
  strm.zfree = Z_NULL;
  strm.opaque = Z_NULL;
  CHECK_EQ(Z_OK, inflateInit(&strm));
  static const size_t kDecompressedSize =
      PROTOCOL_JSON[0] * 0x10000u +
      PROTOCOL_JSON[1] * 0x100u +
      PROTOCOL_JSON[2];
  strm.next_in = const_cast<uint8_t*>(PROTOCOL_JSON + 3);
  strm.avail_in = sizeof(PROTOCOL_JSON) - 3;
  std::string data(kDecompressedSize, '\0');
  strm.next_out = reinterpret_cast<Byte*>(data.data());
  strm.avail_out = data.size();
  CHECK_EQ(Z_STREAM_END, inflate(&strm, Z_FINISH));
  CHECK_EQ(0, strm.avail_out);
  CHECK_EQ(Z_OK, inflateEnd(&strm));
  SendHttpResponse(socket, data, 200);
}",126.0,145.0,1.0,1.0,20.0,33,9,29,9,0,0,1,1,0,0,,0,0,2,1,1,void
2765,98840,SocketSession,1,node.inspector.SocketSession.SocketSession,"ANY node.inspector.SocketSession.SocketSession (InspectorSocketServer*,int,int)",inspector_socket_server.cc,"SocketSession::SocketSession(InspectorSocketServer* server, int id,
                             int server_port)
    : id_(id), server_port_(server_port) {}",494.0,496.0,1.0,43.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,ANY
2766,98847,Close,1,node.inspector.SocketSession.Close,void node.inspector.SocketSession.Close (),inspector_socket_server.cc,"void Close() {
    ws_socket_.reset();
  }",157.0,159.0,3.0,3.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,void
2767,98855,Send,1,node.inspector.SocketSession.Send,void node.inspector.SocketSession.Send (ANY),inspector_socket_server.cc,"void SocketSession::Send(const std::string& message) {
  ws_socket_->Write(message.data(), message.length());
}",498.0,500.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
2768,98860,Own,1,node.inspector.SocketSession.Own,void node.inspector.SocketSession.Own (ANY),inspector_socket_server.cc,"void Own(InspectorSocket::Pointer ws_socket) {
    ws_socket_ = std::move(ws_socket);
  }",161.0,163.0,3.0,3.0,3.0,2,2,3,3,0,1,1,1,0,0,,0,1,2,1,1,void
2769,98872,id,1,node.inspector.SocketSession.id,int node.inspector.SocketSession.id (),inspector_socket_server.cc,int id() const { return id_; },164.0,164.0,3.0,32.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,int
2770,98878,server_port,1,node.inspector.SocketSession.server_port,int node.inspector.SocketSession.server_port (),inspector_socket_server.cc,"int server_port() {
    return server_port_;
  }",165.0,167.0,3.0,3.0,3.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,int
2771,98884,ws_socket,1,node.inspector.SocketSession.ws_socket,InspectorSocket node.inspector.SocketSession.ws_socket (),inspector_socket_server.cc,"InspectorSocket* ws_socket() {
    return ws_socket_.get();
  }",168.0,170.0,3.0,3.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,InspectorSocket
2772,98893,Accept,1,node.inspector.SocketSession.Accept,void node.inspector.SocketSession.Accept (ANY),inspector_socket_server.cc,"void Accept(const std::string& ws_key) {
    ws_socket_->AcceptUpgrade(ws_key);
  }",171.0,173.0,3.0,3.0,3.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
2773,98903,Decline,1,node.inspector.SocketSession.Decline,void node.inspector.SocketSession.Decline (),inspector_socket_server.cc,"void Decline() {
    ws_socket_->CancelHandshake();
  }",174.0,176.0,3.0,3.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,void
2774,98912,Delegate,1,node.inspector.SocketSession.Delegate.Delegate,"ANY node.inspector.SocketSession.Delegate.Delegate (InspectorSocketServer*,int)",inspector_socket_server.cc,"Delegate(InspectorSocketServer* server, int session_id)
             : server_(server), session_id_(session_id) { }",180.0,181.0,5.0,59.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,ANY
2775,98918,~Delegate,1,node.inspector.SocketSession.Delegate.~Delegate,ANY node.inspector.SocketSession.Delegate.~Delegate (),inspector_socket_server.cc,"~Delegate() override {
      server_->SessionTerminated(session_id_);
    }",182.0,184.0,5.0,5.0,3.0,1,1,2,2,0,2,1,1,0,0,,0,2,0,0,0,ANY
2776,98927,OnHttpGet,1,node.inspector.SocketSession.Delegate.OnHttpGet,"void node.inspector.SocketSession.Delegate.OnHttpGet (ANY,ANY)",inspector_socket_server.cc,"void SocketSession::Delegate::OnHttpGet(const std::string& host,
                                        const std::string& path) {
  if (!server_->HandleGetRequest(session_id_, host, path))
    Session()->ws_socket()->CancelHandshake();
}",502.0,506.0,1.0,1.0,5.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
2777,98933,OnSocketUpgrade,1,node.inspector.SocketSession.Delegate.OnSocketUpgrade,"void node.inspector.SocketSession.Delegate.OnSocketUpgrade (ANY,ANY,ANY)",inspector_socket_server.cc,"void SocketSession::Delegate::OnSocketUpgrade(const std::string& host,
                                              const std::string& path,
                                              const std::string& ws_key) {
  std::string id = path.empty() ? path : path.substr(1);
  server_->SessionStarted(session_id_, id, ws_key);
}",508.0,513.0,1.0,1.0,6.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,void
2778,98940,OnWsFrame,1,node.inspector.SocketSession.Delegate.OnWsFrame,void node.inspector.SocketSession.Delegate.OnWsFrame (ANY),inspector_socket_server.cc,"void SocketSession::Delegate::OnWsFrame(const std::vector<char>& data) {
  server_->MessageReceived(session_id_,
                           std::string(data.data(), data.size()));
}",515.0,518.0,1.0,1.0,4.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
2779,98945,Session,1,node.inspector.SocketSession.Delegate.Session,SocketSession node.inspector.SocketSession.Delegate.Session (),inspector_socket_server.cc,"SocketSession* Session() {
      return server_->Session(session_id_);
    }",191.0,193.0,5.0,5.0,3.0,1,1,2,2,0,2,1,1,0,0,,0,2,0,0,0,SocketSession
2780,98961,ServerSocket,1,node.inspector.ServerSocket.ServerSocket,ANY node.inspector.ServerSocket.ServerSocket (InspectorSocketServer*),inspector_socket_server.cc,"explicit ServerSocket(InspectorSocketServer* server)
                        : tcp_socket_(uv_tcp_t()), server_(server) {}",207.0,208.0,3.0,69.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
2781,98966,Listen,1,node.inspector.ServerSocket.Listen,"int node.inspector.ServerSocket.Listen (sockaddr*,uv_loop_t*)",inspector_socket_server.cc,"int ServerSocket::Listen(sockaddr* addr, uv_loop_t* loop) {
  uv_tcp_t* server = &tcp_socket_;
  CHECK_EQ(0, uv_tcp_init(loop, server));
  int err = uv_tcp_bind(server, addr, 0);
  if (err == 0) {
    // 511 is the value used by a 'net' module by default
    err = uv_listen(reinterpret_cast<uv_stream_t*>(server), 511,
                    ServerSocket::SocketConnectedCallback);
  }
  if (err == 0) {
    err = DetectPort();
  }
  return err;
}",537.0,550.0,1.0,1.0,14.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
2782,98972,Close,1,node.inspector.ServerSocket.Close,void node.inspector.ServerSocket.Close (),inspector_socket_server.cc,"void Close() {
    uv_close(reinterpret_cast<uv_handle_t*>(&tcp_socket_), FreeOnCloseCallback);
  }",210.0,212.0,3.0,3.0,3.0,2,2,1,1,0,1,1,1,0,0,,0,1,0,0,0,void
2783,98982,port,1,node.inspector.ServerSocket.port,int node.inspector.ServerSocket.port (),inspector_socket_server.cc,int port() const { return port_; },213.0,213.0,3.0,36.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,int
2784,98988,FromTcpSocket,1,node.inspector.ServerSocket.FromTcpSocket,ServerSocket node.inspector.ServerSocket.FromTcpSocket<UvHandle> (UvHandle*),inspector_socket_server.cc,"static ServerSocket* FromTcpSocket(UvHandle* socket) {
    return node::ContainerOf(&ServerSocket::tcp_socket_,
                             reinterpret_cast<uv_tcp_t*>(socket));
  }",217.0,220.0,3.0,3.0,4.0,4,3,3,3,0,1,1,1,0,0,,0,1,2,1,1,ServerSocket
2785,99005,SocketConnectedCallback,1,node.inspector.ServerSocket.SocketConnectedCallback,"void node.inspector.ServerSocket.SocketConnectedCallback (uv_stream_t*,int)",inspector_socket_server.cc,"void ServerSocket::SocketConnectedCallback(uv_stream_t* tcp_socket,
                                           int status) {
  if (status == 0) {
    ServerSocket* server_socket = ServerSocket::FromTcpSocket(tcp_socket);
    // Memory is freed when the socket closes.
    server_socket->server_->Accept(server_socket->port_, tcp_socket);
  }
}",553.0,560.0,1.0,1.0,8.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
2786,99011,FreeOnCloseCallback,1,node.inspector.ServerSocket.FreeOnCloseCallback,void node.inspector.ServerSocket.FreeOnCloseCallback (uv_handle_t*),inspector_socket_server.cc,"static void FreeOnCloseCallback(uv_handle_t* tcp_socket_) {
    delete FromTcpSocket(tcp_socket_);
  }",222.0,224.0,3.0,3.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,void
2787,99019,DetectPort,1,node.inspector.ServerSocket.DetectPort,int node.inspector.ServerSocket.DetectPort (),inspector_socket_server.cc,"int ServerSocket::DetectPort() {
  sockaddr_storage addr;
  int len = sizeof(addr);
  int err = uv_tcp_getsockname(&tcp_socket_,
                               reinterpret_cast<struct sockaddr*>(&addr), &len);
  if (err != 0)
    return err;
  int port;
  if (addr.ss_family == AF_INET6)
    port = reinterpret_cast<const sockaddr_in6*>(&addr)->sin6_port;
  else
    port = reinterpret_cast<const sockaddr_in*>(&addr)->sin_port;
  port_ = ntohs(port);
  return err;
}",521.0,535.0,1.0,1.0,15.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,int
2788,99023,~ServerSocket,1,node.inspector.ServerSocket.~ServerSocket,ANY node.inspector.ServerSocket.~ServerSocket (),inspector_socket_server.cc,~ServerSocket() = default;,226.0,226.0,3.0,28.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
2789,99038,PrintDebuggerReadyMessage,1,node.inspector.PrintDebuggerReadyMessage,"void node.inspector.PrintDebuggerReadyMessage (ANY,ANY,ANY,char*,bool,FILE*)",inspector_socket_server.cc,"void PrintDebuggerReadyMessage(
    const std::string& host,
    const std::vector<InspectorSocketServer::ServerSocketPtr>& server_sockets,
    const std::vector<std::string>& ids,
    const char* verb,
    bool publish_uid_stderr,
    FILE* out) {
  if (!publish_uid_stderr || out == nullptr) {
    return;
  }
  for (const auto& server_socket : server_sockets) {
    for (const std::string& id : ids) {
      fprintf(out, ""Debugger %s on %s\n"",
              verb,
              FormatWsAddress(host, server_socket->port(), id, true).c_str());
    }
  }
  fprintf(out, ""For help, see: %s\n"",
          ""https://nodejs.org/en/docs/inspector"");
  fflush(out);
}",233.0,253.0,1.0,1.0,21.0,5,5,11,8,0,0,4,5,0,0,,0,0,12,6,6,void
2790,99086,InspectorSocketServer,1,node.inspector.InspectorSocketServer.InspectorSocketServer,"ANY node.inspector.InspectorSocketServer.InspectorSocketServer (ANY,uv_loop_t*,ANY,int,InspectPublishUid,FILE*)",inspector_socket_server.cc,"InspectorSocketServer::InspectorSocketServer(
    std::unique_ptr<SocketServerDelegate> delegate, uv_loop_t* loop,
    const std::string& host, int port,
    const InspectPublishUid& inspect_publish_uid, FILE* out)
    : loop_(loop),
      delegate_(std::move(delegate)),
      host_(host),
      port_(port),
      inspect_publish_uid_(inspect_publish_uid),
      next_session_id_(0),
      out_(out) {
  delegate_->AssignServer(this);
  state_ = ServerState::kNew;
}",255.0,268.0,1.0,1.0,14.0,3,3,3,3,0,0,1,1,0,0,,0,0,12,6,6,ANY
2791,99106,~InspectorSocketServer,1,node.inspector.InspectorSocketServer.~InspectorSocketServer,ANY node.inspector.InspectorSocketServer.~InspectorSocketServer (),inspector_socket_server.cc,InspectorSocketServer::~InspectorSocketServer() = default;,270.0,270.0,1.0,58.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
2792,99110,Session,1,node.inspector.InspectorSocketServer.Session,SocketSession node.inspector.InspectorSocketServer.Session (int),inspector_socket_server.cc,"SocketSession* InspectorSocketServer::Session(int session_id) {
  auto it = connected_sessions_.find(session_id);
  return it == connected_sessions_.end() ? nullptr : it->second.second.get();
}",272.0,275.0,1.0,1.0,4.0,8,5,6,3,0,0,1,1,0,0,,0,0,2,1,1,SocketSession
2793,99140,SessionStarted,1,node.inspector.InspectorSocketServer.SessionStarted,"void node.inspector.InspectorSocketServer.SessionStarted (int,ANY,ANY)",inspector_socket_server.cc,"void InspectorSocketServer::SessionStarted(int session_id,
                                           const std::string& id,
                                           const std::string& ws_key) {
  SocketSession* session = Session(session_id);
  if (!TargetExists(id)) {
    session->Decline();
    return;
  }
  connected_sessions_[session_id].first = id;
  session->Accept(ws_key);
  delegate_->StartSession(session_id, id);
}",277.0,288.0,1.0,1.0,12.0,8,5,12,6,0,0,2,2,0,0,,0,0,6,3,3,void
2794,99180,SessionTerminated,1,node.inspector.InspectorSocketServer.SessionTerminated,void node.inspector.InspectorSocketServer.SessionTerminated (int),inspector_socket_server.cc,"void InspectorSocketServer::SessionTerminated(int session_id) {
  if (Session(session_id) == nullptr) {
    return;
  }
  bool was_attached = connected_sessions_[session_id].first != """";
  if (was_attached) {
    delegate_->EndSession(session_id);
  }
  connected_sessions_.erase(session_id);
  if (connected_sessions_.empty()) {
    if (was_attached && state_ == ServerState::kRunning
        && !server_sockets_.empty()) {
      PrintDebuggerReadyMessage(host_,
                                server_sockets_,
                                delegate_->GetTargetIds(),
                                ""ending"",
                                inspect_publish_uid_.console,
                                out_);
    }
    if (state_ == ServerState::kStopped) {
      delegate_.reset();
    }
  }
}",290.0,313.0,1.0,1.0,24.0,19,8,22,10,0,0,6,8,0,0,,0,0,2,1,1,void
2795,99259,HandleGetRequest,1,node.inspector.InspectorSocketServer.HandleGetRequest,"bool node.inspector.InspectorSocketServer.HandleGetRequest (int,ANY,ANY)",inspector_socket_server.cc,"bool InspectorSocketServer::HandleGetRequest(int session_id,
                                             const std::string& host,
                                             const std::string& path) {
  SocketSession* session = Session(session_id);
  InspectorSocket* socket = session->ws_socket();
  if (!inspect_publish_uid_.http) {
    SendHttpNotFound(socket);
    return true;
  }
  const char* command = MatchPathSegment(path.c_str(), ""/json"");
  if (command == nullptr)
    return false;

  if (MatchPathSegment(command, ""list"") || command[0] == '\0') {
    SendListResponse(socket, host, session);
    return true;
  } else if (MatchPathSegment(command, ""protocol"")) {
    SendProtocolJson(socket);
    return true;
  } else if (MatchPathSegment(command, ""version"")) {
    SendVersionResponse(socket);
    return true;
  }
  return false;
}",315.0,339.0,1.0,1.0,25.0,11,7,14,7,0,0,4,4,0,0,,0,0,6,3,3,bool
2796,99345,SendListResponse,1,node.inspector.InspectorSocketServer.SendListResponse,"void node.inspector.InspectorSocketServer.SendListResponse (InspectorSocket*,ANY,SocketSession*)",inspector_socket_server.cc,"void InspectorSocketServer::SendListResponse(InspectorSocket* socket,
                                             const std::string& host,
                                             SocketSession* session) {
  std::vector<std::map<std::string, std::string>> response;
  for (const std::string& id : delegate_->GetTargetIds()) {
    response.push_back(std::map<std::string, std::string>());
    std::map<std::string, std::string>& target_map = response.back();
    target_map[""description""] = ""node.js instance"";
    target_map[""faviconUrl""] =
                        ""https://nodejs.org/static/images/favicons/favicon.ico"";
    target_map[""id""] = id;
    target_map[""title""] = delegate_->GetTargetTitle(id);
    Escape(&target_map[""title""]);
    target_map[""type""] = ""node"";
    // This attribute value is a ""best effort"" URL that is passed as a JSON
    // string. It is not guaranteed to resolve to a valid resource.
    target_map[""url""] = delegate_->GetTargetUrl(id);
    Escape(&target_map...",341.0,374.0,1.0,1.0,34.0,40,8,38,10,0,0,3,4,0,0,,0,0,6,3,3,void
2797,99486,GetFrontendURL,1,node.inspector.InspectorSocketServer.GetFrontendURL,"string node.inspector.InspectorSocketServer.GetFrontendURL (bool,ANY)",inspector_socket_server.cc,"std::string InspectorSocketServer::GetFrontendURL(bool is_compat,
    const std::string &formatted_address) {
  std::ostringstream frontend_url;
  frontend_url << ""devtools://devtools/bundled/"";
  frontend_url << (is_compat ? ""inspector"" : ""js_app"");
  frontend_url << "".html?experiments=true&v8only=true&ws="";
  frontend_url << formatted_address;
  return frontend_url.str();
}",376.0,384.0,1.0,1.0,9.0,6,3,7,3,0,0,1,1,0,0,,0,0,4,2,2,string
2798,99513,Start,1,node.inspector.InspectorSocketServer.Start,bool node.inspector.InspectorSocketServer.Start (),inspector_socket_server.cc,"bool InspectorSocketServer::Start() {
  CHECK_NOT_NULL(delegate_);
  CHECK_EQ(state_, ServerState::kNew);
  std::unique_ptr<SocketServerDelegate> delegate_holder;
  // We will return it if startup is successful
  delegate_.swap(delegate_holder);
  struct addrinfo hints;
  memset(&hints, 0, sizeof(hints));
  hints.ai_flags = AI_NUMERICSERV;
  hints.ai_socktype = SOCK_STREAM;
  uv_getaddrinfo_t req;
  const std::string port_string = std::to_string(port_);
  int err = uv_getaddrinfo(loop_, &req, nullptr, host_.c_str(),
                           port_string.c_str(), &hints);
  if (err < 0) {
    if (out_ != nullptr) {
      fprintf(out_, ""Unable to resolve \""%s\"": %s\n"", host_.c_str(),
              uv_strerror(err));
    }
    return false;
  }
  for (addrinfo* address = req.addrinfo; address != nullptr;
       address = address->ai_next) {
    auto server_socket = ServerSocketPtr(new ServerSocket(this));
    err = server_socket->Listen(address->ai_addr, loop_);
    if (err == 0)
    ...",386.0,435.0,1.0,1.0,50.0,41,10,56,21,0,0,7,10,0,0,,0,0,0,0,0,bool
2799,99700,Stop,1,node.inspector.InspectorSocketServer.Stop,void node.inspector.InspectorSocketServer.Stop (),inspector_socket_server.cc,"void InspectorSocketServer::Stop() {
  if (state_ == ServerState::kStopped)
    return;
  CHECK_EQ(state_, ServerState::kRunning);
  state_ = ServerState::kStopped;
  server_sockets_.clear();
  if (done())
    delegate_.reset();
}",437.0,445.0,1.0,1.0,9.0,7,3,8,4,0,0,3,3,0,0,,0,0,0,0,0,void
2800,99733,TerminateConnections,1,node.inspector.InspectorSocketServer.TerminateConnections,void node.inspector.InspectorSocketServer.TerminateConnections (),inspector_socket_server.cc,"void InspectorSocketServer::TerminateConnections() {
  for (const auto& key_value : connected_sessions_)
    key_value.second.second->Close();
}",447.0,450.0,1.0,1.0,4.0,0,0,1,1,0,0,2,2,0,0,,0,0,0,0,0,void
2801,99748,TargetExists,1,node.inspector.InspectorSocketServer.TargetExists,bool node.inspector.InspectorSocketServer.TargetExists (ANY),inspector_socket_server.cc,"bool InspectorSocketServer::TargetExists(const std::string& id) {
  const std::vector<std::string>& target_ids = delegate_->GetTargetIds();
  const auto& found = std::find(target_ids.begin(), target_ids.end(), id);
  return found != target_ids.end();
}",452.0,456.0,1.0,1.0,5.0,8,4,9,5,0,0,1,1,0,0,,0,0,2,1,1,bool
2802,99783,Port,1,node.inspector.InspectorSocketServer.Port,int node.inspector.InspectorSocketServer.Port (),inspector_socket_server.cc,"int InspectorSocketServer::Port() const {
  if (!server_sockets_.empty()) {
    return server_sockets_[0]->port();
  }
  return port_;
}",458.0,463.0,1.0,1.0,6.0,4,4,3,2,0,0,2,2,0,0,,0,0,0,0,0,int
2803,99803,Accept,1,node.inspector.InspectorSocketServer.Accept,"void node.inspector.InspectorSocketServer.Accept (int,uv_stream_t*)",inspector_socket_server.cc,"void InspectorSocketServer::Accept(int server_port,
                                   uv_stream_t* server_socket) {
  std::unique_ptr<SocketSession> session(
      new SocketSession(this, next_session_id_++, server_port));

  InspectorSocket::DelegatePointer delegate =
      InspectorSocket::DelegatePointer(
          new SocketSession::Delegate(this, session->id()));

  InspectorSocket::Pointer inspector =
      InspectorSocket::Accept(server_socket, std::move(delegate));
  if (inspector) {
    session->Own(std::move(inspector));
    connected_sessions_[session->id()].second = std::move(session);
  }
}",465.0,480.0,1.0,1.0,16.0,19,8,22,11,0,0,2,2,0,0,,0,0,4,2,2,void
2804,99875,Send,1,node.inspector.InspectorSocketServer.Send,"void node.inspector.InspectorSocketServer.Send (int,ANY)",inspector_socket_server.cc,"void InspectorSocketServer::Send(int session_id, const std::string& message) {
  SocketSession* session = Session(session_id);
  if (session != nullptr) {
    session->Send(message);
  }
}",482.0,487.0,1.0,1.0,6.0,3,3,5,3,0,0,2,2,0,0,,0,0,4,2,2,void
2805,99896,CloseServerSocket,1,node.inspector.InspectorSocketServer.CloseServerSocket,void node.inspector.InspectorSocketServer.CloseServerSocket (ServerSocket*),inspector_socket_server.cc,"void InspectorSocketServer::CloseServerSocket(ServerSocket* server) {
  server->Close();
}",489.0,491.0,1.0,1.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,void
2806,100168,napi_get_last_error_info,1,napi_get_last_error_info,"napi_status napi_get_last_error_info (napi_env,napi_extended_error_info**)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_get_last_error_info(
    napi_env env, const napi_extended_error_info** result) {
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  // The value of the constant below must be updated to reference the last
  // message in the `napi_status` enum each time a new error message is added.
  // We don't have a napi_status_last as this would result in an ABI
  // change each time a message was added.
  const int last_status = napi_no_external_buffers_allowed;

  static_assert(NAPI_ARRAYSIZE(error_messages) == last_status + 1,
                ""Count of error messages must match count of error values"");
  CHECK_LE(env->last_error.error_code, last_status);
  // Wait until someone requests the last error information to fetch the error
  // message string
  env->last_error.error_message = error_messages[env->last_error.error_code];

  if (env->last_error.error_code == napi_ok) {
    napi_clear_last_error(env);
  }
  *result = &(env->last_error);
  return napi_ok;
}",687.0,710.0,1.0,12.0,24.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,napi_status
2807,100174,napi_get_undefined,1,napi_get_undefined,"napi_status napi_get_undefined (napi_env,napi_value*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_get_undefined(napi_env env, napi_value* result) {
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result = v8impl::JsValueFromV8LocalValue(v8::Undefined(env->isolate));

  return napi_clear_last_error(env);
}",1749.0,1756.0,1.0,12.0,8.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,napi_status
2808,100180,napi_get_null,1,napi_get_null,"napi_status napi_get_null (napi_env,napi_value*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_get_null(napi_env env, napi_value* result) {
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result = v8impl::JsValueFromV8LocalValue(v8::Null(env->isolate));

  return napi_clear_last_error(env);
}",1758.0,1765.0,1.0,12.0,8.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,napi_status
2809,100186,napi_get_global,1,napi_get_global,"napi_status napi_get_global (napi_env,napi_value*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_get_global(napi_env env, napi_value* result) {
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result = v8impl::JsValueFromV8LocalValue(env->context()->Global());

  return napi_clear_last_error(env);
}",1849.0,1856.0,1.0,12.0,8.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,napi_status
2810,100192,napi_get_boolean,1,napi_get_boolean,"napi_status napi_get_boolean (napi_env,bool,napi_value*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_get_boolean(napi_env env,
                                        bool value,
                                        napi_value* result) {
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  v8::Isolate* isolate = env->isolate;

  if (value) {
    *result = v8impl::JsValueFromV8LocalValue(v8::True(isolate));
  } else {
    *result = v8impl::JsValueFromV8LocalValue(v8::False(isolate));
  }

  return napi_clear_last_error(env);
}",1543.0,1558.0,1.0,12.0,16.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,napi_status
2811,100199,napi_create_object,1,napi_create_object,"napi_status napi_create_object (napi_env,napi_value*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_create_object(napi_env env, napi_value* result) {
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result = v8impl::JsValueFromV8LocalValue(v8::Object::New(env->isolate));

  return napi_clear_last_error(env);
}",1357.0,1364.0,1.0,12.0,8.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,napi_status
2812,100205,napi_create_array,1,napi_create_array,"napi_status napi_create_array (napi_env,napi_value*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_create_array(napi_env env, napi_value* result) {
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result = v8impl::JsValueFromV8LocalValue(v8::Array::New(env->isolate));

  return napi_clear_last_error(env);
}",1366.0,1373.0,1.0,12.0,8.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,napi_status
2813,100211,napi_create_array_with_length,1,napi_create_array_with_length,"napi_status napi_create_array_with_length (napi_env,size_t,napi_value*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_create_array_with_length(napi_env env,
                                                     size_t length,
                                                     napi_value* result) {
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result =
      v8impl::JsValueFromV8LocalValue(v8::Array::New(env->isolate, length));

  return napi_clear_last_error(env);
}",1375.0,1385.0,1.0,12.0,11.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,napi_status
2814,100218,napi_create_double,1,napi_create_double,"napi_status napi_create_double (napi_env,double,napi_value*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_create_double(napi_env env,
                                          double value,
                                          napi_value* result) {
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result =
      v8impl::JsValueFromV8LocalValue(v8::Number::New(env->isolate, value));

  return napi_clear_last_error(env);
}",1449.0,1459.0,1.0,12.0,11.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,napi_status
2815,100225,napi_create_int32,1,napi_create_int32,"napi_status napi_create_int32 (napi_env,int32_t,napi_value*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_create_int32(napi_env env,
                                         int32_t value,
                                         napi_value* result) {
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result =
      v8impl::JsValueFromV8LocalValue(v8::Integer::New(env->isolate, value));

  return napi_clear_last_error(env);
}",1461.0,1471.0,1.0,12.0,11.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,napi_status
2816,100232,napi_create_uint32,1,napi_create_uint32,"napi_status napi_create_uint32 (napi_env,uint32_t,napi_value*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_create_uint32(napi_env env,
                                          uint32_t value,
                                          napi_value* result) {
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result = v8impl::JsValueFromV8LocalValue(
      v8::Integer::NewFromUnsigned(env->isolate, value));

  return napi_clear_last_error(env);
}",1473.0,1483.0,1.0,12.0,11.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,napi_status
2817,100239,napi_create_int64,1,napi_create_int64,"napi_status napi_create_int64 (napi_env,int64_t,napi_value*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_create_int64(napi_env env,
                                         int64_t value,
                                         napi_value* result) {
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result = v8impl::JsValueFromV8LocalValue(
      v8::Number::New(env->isolate, static_cast<double>(value)));

  return napi_clear_last_error(env);
}",1485.0,1495.0,1.0,12.0,11.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,napi_status
2818,100246,napi_create_string_latin1,1,napi_create_string_latin1,"napi_status napi_create_string_latin1 (napi_env,char*,size_t,napi_value*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_create_string_latin1(napi_env env,
                                                 const char* str,
                                                 size_t length,
                                                 napi_value* result) {
  CHECK_ENV(env);
  if (length > 0) CHECK_ARG(env, str);
  CHECK_ARG(env, result);
  RETURN_STATUS_IF_FALSE(
      env, (length == NAPI_AUTO_LENGTH) || length <= INT_MAX, napi_invalid_arg);

  auto isolate = env->isolate;
  auto str_maybe =
      v8::String::NewFromOneByte(isolate,
                                 reinterpret_cast<const uint8_t*>(str),
                                 v8::NewStringType::kNormal,
                                 length);
  CHECK_MAYBE_EMPTY(env, str_maybe, napi_generic_failure);

  *result = v8impl::JsValueFromV8LocalValue(str_maybe.ToLocalChecked());
  return napi_clear_last_error(env);
}",1387.0,1407.0,1.0,12.0,21.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,napi_status
2819,100254,napi_create_string_utf8,1,napi_create_string_utf8,"napi_status napi_create_string_utf8 (napi_env,char*,size_t,napi_value*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_create_string_utf8(napi_env env,
                                               const char* str,
                                               size_t length,
                                               napi_value* result) {
  CHECK_ENV(env);
  if (length > 0) CHECK_ARG(env, str);
  CHECK_ARG(env, result);
  RETURN_STATUS_IF_FALSE(
      env, (length == NAPI_AUTO_LENGTH) || length <= INT_MAX, napi_invalid_arg);

  auto isolate = env->isolate;
  auto str_maybe = v8::String::NewFromUtf8(
      isolate, str, v8::NewStringType::kNormal, static_cast<int>(length));
  CHECK_MAYBE_EMPTY(env, str_maybe, napi_generic_failure);
  *result = v8impl::JsValueFromV8LocalValue(str_maybe.ToLocalChecked());
  return napi_clear_last_error(env);
}",1409.0,1425.0,1.0,12.0,17.0,0,0,0,0,1,0,1,1,0,0,,0,0,8,4,4,napi_status
2820,100262,napi_create_string_utf16,1,napi_create_string_utf16,"napi_status napi_create_string_utf16 (napi_env,char16_t*,size_t,napi_value*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_create_string_utf16(napi_env env,
                                                const char16_t* str,
                                                size_t length,
                                                napi_value* result) {
  CHECK_ENV(env);
  if (length > 0) CHECK_ARG(env, str);
  CHECK_ARG(env, result);
  RETURN_STATUS_IF_FALSE(
      env, (length == NAPI_AUTO_LENGTH) || length <= INT_MAX, napi_invalid_arg);

  auto isolate = env->isolate;
  auto str_maybe =
      v8::String::NewFromTwoByte(isolate,
                                 reinterpret_cast<const uint16_t*>(str),
                                 v8::NewStringType::kNormal,
                                 length);
  CHECK_MAYBE_EMPTY(env, str_maybe, napi_generic_failure);

  *result = v8impl::JsValueFromV8LocalValue(str_maybe.ToLocalChecked());
  return napi_clear_last_error(env);
}",1427.0,1447.0,1.0,12.0,21.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,napi_status
2821,100270,napi_create_symbol,1,napi_create_symbol,"napi_status napi_create_symbol (napi_env,napi_value,napi_value*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_create_symbol(napi_env env,
                                          napi_value description,
                                          napi_value* result) {
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  v8::Isolate* isolate = env->isolate;

  if (description == nullptr) {
    *result = v8impl::JsValueFromV8LocalValue(v8::Symbol::New(isolate));
  } else {
    v8::Local<v8::Value> desc = v8impl::V8LocalValueFromJsValue(description);
    RETURN_STATUS_IF_FALSE(env, desc->IsString(), napi_string_expected);

    *result = v8impl::JsValueFromV8LocalValue(
        v8::Symbol::New(isolate, desc.As<v8::String>()));
  }

  return napi_clear_last_error(env);
}",1560.0,1579.0,1.0,12.0,20.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,napi_status
2822,100277,napi_create_function,1,napi_create_function,"napi_status napi_create_function (napi_env,char*,size_t,napi_callback,void*,napi_value*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_create_function(napi_env env,
                                            const char* utf8name,
                                            size_t length,
                                            napi_callback cb,
                                            void* callback_data,
                                            napi_value* result) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);
  CHECK_ARG(env, cb);

  v8::Local<v8::Function> return_value;
  v8::EscapableHandleScope scope(env->isolate);
  v8::Local<v8::Function> fn;
  STATUS_CALL(v8impl::FunctionCallbackWrapper::NewFunction(
      env, cb, callback_data, &fn));
  return_value = scope.Escape(fn);

  if (utf8name != nullptr) {
    v8::Local<v8::String> name_string;
    CHECK_NEW_FROM_UTF8_LEN(env, name_string, utf8name, length);
    return_value->SetName(name_string);
  }

  *result = v8impl::JsValueFromV8LocalValue(return_value);

  return GET_RETURN_STATUS(env);
}",712.0,738.0,1.0,12.0,27.0,0,0,0,0,0,0,1,1,0,0,,0,0,12,6,6,napi_status
2823,100287,napi_create_error,1,napi_create_error,"napi_status napi_create_error (napi_env,napi_value,napi_value,napi_value*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_create_error(napi_env env,
                                         napi_value code,
                                         napi_value msg,
                                         napi_value* result) {
  CHECK_ENV(env);
  CHECK_ARG(env, msg);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> message_value = v8impl::V8LocalValueFromJsValue(msg);
  RETURN_STATUS_IF_FALSE(env, message_value->IsString(), napi_string_expected);

  v8::Local<v8::Value> error_obj =
      v8::Exception::Error(message_value.As<v8::String>());
  STATUS_CALL(set_error_code(env, error_obj, code, nullptr));

  *result = v8impl::JsValueFromV8LocalValue(error_obj);

  return napi_clear_last_error(env);
}",1626.0,1644.0,1.0,12.0,19.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,napi_status
2824,100295,napi_create_type_error,1,napi_create_type_error,"napi_status napi_create_type_error (napi_env,napi_value,napi_value,napi_value*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_create_type_error(napi_env env,
                                              napi_value code,
                                              napi_value msg,
                                              napi_value* result) {
  CHECK_ENV(env);
  CHECK_ARG(env, msg);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> message_value = v8impl::V8LocalValueFromJsValue(msg);
  RETURN_STATUS_IF_FALSE(env, message_value->IsString(), napi_string_expected);

  v8::Local<v8::Value> error_obj =
      v8::Exception::TypeError(message_value.As<v8::String>());
  STATUS_CALL(set_error_code(env, error_obj, code, nullptr));

  *result = v8impl::JsValueFromV8LocalValue(error_obj);

  return napi_clear_last_error(env);
}",1646.0,1664.0,1.0,12.0,19.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,napi_status
2825,100303,napi_create_range_error,1,napi_create_range_error,"napi_status napi_create_range_error (napi_env,napi_value,napi_value,napi_value*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_create_range_error(napi_env env,
                                               napi_value code,
                                               napi_value msg,
                                               napi_value* result) {
  CHECK_ENV(env);
  CHECK_ARG(env, msg);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> message_value = v8impl::V8LocalValueFromJsValue(msg);
  RETURN_STATUS_IF_FALSE(env, message_value->IsString(), napi_string_expected);

  v8::Local<v8::Value> error_obj =
      v8::Exception::RangeError(message_value.As<v8::String>());
  STATUS_CALL(set_error_code(env, error_obj, code, nullptr));

  *result = v8impl::JsValueFromV8LocalValue(error_obj);

  return napi_clear_last_error(env);
}",1666.0,1684.0,1.0,12.0,19.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,napi_status
2826,100311,napi_typeof,1,napi_typeof,"napi_status napi_typeof (napi_env,napi_value,napi_valuetype*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_typeof(napi_env env,
                                   napi_value value,
                                   napi_valuetype* result) {
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> v = v8impl::V8LocalValueFromJsValue(value);

  if (v->IsNumber()) {
    *result = napi_number;
  } else if (v->IsBigInt()) {
    *result = napi_bigint;
  } else if (v->IsString()) {
    *result = napi_string;
  } else if (v->IsFunction()) {
    // This test has to come before IsObject because IsFunction
    // implies IsObject
    *result = napi_function;
  } else if (v->IsExternal()) {
    // This test has to come before IsObject because IsExternal
    // implies IsObject
    *result = napi_external;
  } else if (v->IsObject()) {
    *result = napi_object;
  } else if (v->IsBoolean()) {
    *result = napi_boolean;
  } else if (v->I...",1706.0,1747.0,1.0,12.0,42.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,napi_status
2827,100318,napi_get_value_double,1,napi_get_value_double,"napi_status napi_get_value_double (napi_env,napi_value,double*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_get_value_double(napi_env env,
                                             napi_value value,
                                             double* result) {
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);
  RETURN_STATUS_IF_FALSE(env, val->IsNumber(), napi_number_expected);

  *result = val.As<v8::Number>()->Value();

  return napi_clear_last_error(env);
}",1957.0,1972.0,1.0,12.0,16.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,napi_status
2828,100325,napi_get_value_int32,1,napi_get_value_int32,"napi_status napi_get_value_int32 (napi_env,napi_value,int32_t*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_get_value_int32(napi_env env,
                                            napi_value value,
                                            int32_t* result) {
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);

  if (val->IsInt32()) {
    *result = val.As<v8::Int32>()->Value();
  } else {
    RETURN_STATUS_IF_FALSE(env, val->IsNumber(), napi_number_expected);

    // Empty context: https://github.com/nodejs/node/issues/14379
    v8::Local<v8::Context> context;
    *result = val->Int32Value(context).FromJust();
  }

  return napi_clear_last_error(env);
}",1974.0,1996.0,1.0,12.0,23.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,napi_status
2829,100332,napi_get_value_uint32,1,napi_get_value_uint32,"napi_status napi_get_value_uint32 (napi_env,napi_value,uint32_t*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_get_value_uint32(napi_env env,
                                             napi_value value,
                                             uint32_t* result) {
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);

  if (val->IsUint32()) {
    *result = val.As<v8::Uint32>()->Value();
  } else {
    RETURN_STATUS_IF_FALSE(env, val->IsNumber(), napi_number_expected);

    // Empty context: https://github.com/nodejs/node/issues/14379
    v8::Local<v8::Context> context;
    *result = val->Uint32Value(context).FromJust();
  }

  return napi_clear_last_error(env);
}",1998.0,2020.0,1.0,12.0,23.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,napi_status
2830,100339,napi_get_value_int64,1,napi_get_value_int64,"napi_status napi_get_value_int64 (napi_env,napi_value,int64_t*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_get_value_int64(napi_env env,
                                            napi_value value,
                                            int64_t* result) {
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);

  // This is still a fast path very likely to be taken.
  if (val->IsInt32()) {
    *result = val.As<v8::Int32>()->Value();
    return napi_clear_last_error(env);
  }

  RETURN_STATUS_IF_FALSE(env, val->IsNumber(), napi_number_expected);

  // v8::Value::IntegerValue() converts NaN, +Inf, and -Inf to INT64_MIN,
  // inconsistent with v8::Value::Int32Value() which converts those values to 0.
  // Special-case all non-finite values to match that behavior.
  double doubleValue = val.As<v8::Number>()->Value();
  if (std::isfinite(doubleValue)) {
    // Empty context: htt...",2022.0,2054.0,1.0,12.0,33.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,napi_status
2831,100346,napi_get_value_bool,1,napi_get_value_bool,"napi_status napi_get_value_bool (napi_env,napi_value,bool*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_get_value_bool(napi_env env,
                                           napi_value value,
                                           bool* result) {
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);
  RETURN_STATUS_IF_FALSE(env, val->IsBoolean(), napi_boolean_expected);

  *result = val.As<v8::Boolean>()->Value();

  return napi_clear_last_error(env);
}",2122.0,2137.0,1.0,12.0,16.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,napi_status
2832,100353,napi_get_value_string_latin1,1,napi_get_value_string_latin1,"napi_status napi_get_value_string_latin1 (napi_env,napi_value,char*,size_t,size_t*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_get_value_string_latin1(
    napi_env env, napi_value value, char* buf, size_t bufsize, size_t* result) {
  CHECK_ENV(env);
  CHECK_ARG(env, value);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);
  RETURN_STATUS_IF_FALSE(env, val->IsString(), napi_string_expected);

  if (!buf) {
    CHECK_ARG(env, result);
    *result = val.As<v8::String>()->Length();
  } else if (bufsize != 0) {
    int copied =
        val.As<v8::String>()->WriteOneByte(env->isolate,
                                           reinterpret_cast<uint8_t*>(buf),
                                           0,
                                           bufsize - 1,
                                           v8::String::NO_NULL_TERMINATION);

    buf[copied] = '\0';
    if (result != nullptr) {
      *result = copied;
    }
  } else if (result != nullptr) {
    *result = 0;
  }

  return napi_clear_last_error(env);
}",2147.0,2175.0,1.0,12.0,29.0,0,0,0,0,0,0,1,1,0,0,,0,0,10,5,5,napi_status
2833,100362,napi_get_value_string_utf8,1,napi_get_value_string_utf8,"napi_status napi_get_value_string_utf8 (napi_env,napi_value,char*,size_t,size_t*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_get_value_string_utf8(
    napi_env env, napi_value value, char* buf, size_t bufsize, size_t* result) {
  CHECK_ENV(env);
  CHECK_ARG(env, value);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);
  RETURN_STATUS_IF_FALSE(env, val->IsString(), napi_string_expected);

  if (!buf) {
    CHECK_ARG(env, result);
    *result = val.As<v8::String>()->Utf8Length(env->isolate);
  } else if (bufsize != 0) {
    int copied = val.As<v8::String>()->WriteUtf8(
        env->isolate,
        buf,
        bufsize - 1,
        nullptr,
        v8::String::REPLACE_INVALID_UTF8 | v8::String::NO_NULL_TERMINATION);

    buf[copied] = '\0';
    if (result != nullptr) {
      *result = copied;
    }
  } else if (result != nullptr) {
    *result = 0;
  }

  return napi_clear_last_error(env);
}",2185.0,2213.0,1.0,12.0,29.0,0,0,0,0,0,0,1,1,0,0,,0,0,10,5,5,napi_status
2834,100371,napi_get_value_string_utf16,1,napi_get_value_string_utf16,"napi_status napi_get_value_string_utf16 (napi_env,napi_value,char16_t*,size_t,size_t*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_get_value_string_utf16(napi_env env,
                                                   napi_value value,
                                                   char16_t* buf,
                                                   size_t bufsize,
                                                   size_t* result) {
  CHECK_ENV(env);
  CHECK_ARG(env, value);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);
  RETURN_STATUS_IF_FALSE(env, val->IsString(), napi_string_expected);

  if (!buf) {
    CHECK_ARG(env, result);
    // V8 assumes UTF-16 length is the same as the number of characters.
    *result = val.As<v8::String>()->Length();
  } else if (bufsize != 0) {
    int copied = val.As<v8::String>()->Write(env->isolate,
                                             reinterpret_cast<uint16_t*>(buf),
                                             0,
                                             bufsize - 1,
                                           ...",2223.0,2254.0,1.0,12.0,32.0,0,0,0,0,0,0,1,1,0,0,,0,0,10,5,5,napi_status
2835,100380,napi_coerce_to_bool,1,napi_coerce_to_bool,"napi_status napi_coerce_to_bool (napi_env,napi_value,napi_value*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_coerce_to_bool(napi_env env,
                                           napi_value value,
                                           napi_value* result) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  v8::Isolate* isolate = env->isolate;
  v8::Local<v8::Boolean> b =
      v8impl::V8LocalValueFromJsValue(value)->ToBoolean(isolate);
  *result = v8impl::JsValueFromV8LocalValue(b);
  return GET_RETURN_STATUS(env);
}",2256.0,2268.0,1.0,12.0,13.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,napi_status
2836,100387,napi_coerce_to_number,1,napi_coerce_to_number,"napi_status napi_coerce_to_number (napi_env,napi_value,napi_value*)",js_native_api.hpp,"napi_status napi_status (napi_env, napi_value, napi_value *);",168.0,170.0,36.0,76.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,napi_status
2837,100394,napi_coerce_to_object,1,napi_coerce_to_object,"napi_status napi_coerce_to_object (napi_env,napi_value,napi_value*)",js_native_api.hpp,"napi_status napi_status (napi_env, napi_value, napi_value *);",171.0,173.0,36.0,76.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,napi_status
2838,100401,napi_coerce_to_string,1,napi_coerce_to_string,"napi_status napi_coerce_to_string (napi_env,napi_value,napi_value*)",js_native_api.hpp,"napi_status napi_status (napi_env, napi_value, napi_value *);",174.0,176.0,36.0,76.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,napi_status
2839,100408,napi_get_prototype,1,napi_get_prototype,"napi_status napi_get_prototype (napi_env,napi_value,napi_value*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_get_prototype(napi_env env,
                                          napi_value object,
                                          napi_value* result) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);

  v8::Local<v8::Context> context = env->context();

  v8::Local<v8::Object> obj;
  CHECK_TO_OBJECT(env, context, obj, object);

  v8::Local<v8::Value> val = obj->GetPrototype();
  *result = v8impl::JsValueFromV8LocalValue(val);
  return GET_RETURN_STATUS(env);
}",1341.0,1355.0,1.0,12.0,15.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,napi_status
2840,100415,napi_get_property_names,1,napi_get_property_names,"napi_status napi_get_property_names (napi_env,napi_value,napi_value*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_get_property_names(napi_env env,
                                               napi_value object,
                                               napi_value* result) {
  return napi_get_all_property_names(
      env,
      object,
      napi_key_include_prototypes,
      static_cast<napi_key_filter>(napi_key_enumerable | napi_key_skip_symbols),
      napi_key_numbers_to_strings,
      result);
}",839.0,849.0,1.0,12.0,11.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,napi_status
2841,100422,napi_set_property,1,napi_set_property,"napi_status napi_set_property (napi_env,napi_value,napi_value,napi_value)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_set_property(napi_env env,
                                         napi_value object,
                                         napi_value key,
                                         napi_value value) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, key);
  CHECK_ARG(env, value);

  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Object> obj;

  CHECK_TO_OBJECT(env, context, obj, object);

  v8::Local<v8::Value> k = v8impl::V8LocalValueFromJsValue(key);
  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);

  v8::Maybe<bool> set_maybe = obj->Set(context, k, val);

  RETURN_STATUS_IF_FALSE(env, set_maybe.FromMaybe(false), napi_generic_failure);
  return GET_RETURN_STATUS(env);
}",926.0,946.0,1.0,12.0,21.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,napi_status
2842,100430,napi_has_property,1,napi_has_property,"napi_status napi_has_property (napi_env,napi_value,napi_value,bool*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_has_property(napi_env env,
                                         napi_value object,
                                         napi_value key,
                                         bool* result) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);
  CHECK_ARG(env, key);

  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Object> obj;

  CHECK_TO_OBJECT(env, context, obj, object);

  v8::Local<v8::Value> k = v8impl::V8LocalValueFromJsValue(key);
  v8::Maybe<bool> has_maybe = obj->Has(context, k);

  CHECK_MAYBE_NOTHING(env, has_maybe, napi_generic_failure);

  *result = has_maybe.FromMaybe(false);
  return GET_RETURN_STATUS(env);
}",948.0,968.0,1.0,12.0,21.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,napi_status
2843,100438,napi_get_property,1,napi_get_property,"napi_status napi_get_property (napi_env,napi_value,napi_value,napi_value*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_get_property(napi_env env,
                                         napi_value object,
                                         napi_value key,
                                         napi_value* result) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, key);
  CHECK_ARG(env, result);

  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Value> k = v8impl::V8LocalValueFromJsValue(key);
  v8::Local<v8::Object> obj;

  CHECK_TO_OBJECT(env, context, obj, object);

  auto get_maybe = obj->Get(context, k);

  CHECK_MAYBE_EMPTY(env, get_maybe, napi_generic_failure);

  v8::Local<v8::Value> val = get_maybe.ToLocalChecked();
  *result = v8impl::JsValueFromV8LocalValue(val);
  return GET_RETURN_STATUS(env);
}",970.0,991.0,1.0,12.0,22.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,napi_status
2844,100446,napi_delete_property,1,napi_delete_property,"napi_status napi_delete_property (napi_env,napi_value,napi_value,bool*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_delete_property(napi_env env,
                                            napi_value object,
                                            napi_value key,
                                            bool* result) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, key);

  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Value> k = v8impl::V8LocalValueFromJsValue(key);
  v8::Local<v8::Object> obj;

  CHECK_TO_OBJECT(env, context, obj, object);
  v8::Maybe<bool> delete_maybe = obj->Delete(context, k);
  CHECK_MAYBE_NOTHING(env, delete_maybe, napi_generic_failure);

  if (result != nullptr) *result = delete_maybe.FromMaybe(false);

  return GET_RETURN_STATUS(env);
}",993.0,1011.0,1.0,12.0,19.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,napi_status
2845,100454,napi_has_own_property,1,napi_has_own_property,"napi_status napi_has_own_property (napi_env,napi_value,napi_value,bool*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_has_own_property(napi_env env,
                                             napi_value object,
                                             napi_value key,
                                             bool* result) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, key);
  CHECK_ARG(env, result);

  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Object> obj;

  CHECK_TO_OBJECT(env, context, obj, object);
  v8::Local<v8::Value> k = v8impl::V8LocalValueFromJsValue(key);
  RETURN_STATUS_IF_FALSE(env, k->IsName(), napi_name_expected);
  v8::Maybe<bool> has_maybe = obj->HasOwnProperty(context, k.As<v8::Name>());
  CHECK_MAYBE_NOTHING(env, has_maybe, napi_generic_failure);
  *result = has_maybe.FromMaybe(false);

  return GET_RETURN_STATUS(env);
}",1013.0,1032.0,1.0,12.0,20.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,napi_status
2846,100462,napi_set_named_property,1,napi_set_named_property,"napi_status napi_set_named_property (napi_env,napi_value,char*,napi_value)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_set_named_property(napi_env env,
                                               napi_value object,
                                               const char* utf8name,
                                               napi_value value) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, value);

  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Object> obj;

  CHECK_TO_OBJECT(env, context, obj, object);

  v8::Local<v8::Name> key;
  CHECK_NEW_FROM_UTF8(env, key, utf8name);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);

  v8::Maybe<bool> set_maybe = obj->Set(context, key, val);

  RETURN_STATUS_IF_FALSE(env, set_maybe.FromMaybe(false), napi_generic_failure);
  return GET_RETURN_STATUS(env);
}",1034.0,1055.0,1.0,12.0,22.0,0,0,0,0,1,0,1,1,0,0,,0,0,8,4,4,napi_status
2847,100470,napi_has_named_property,1,napi_has_named_property,"napi_status napi_has_named_property (napi_env,napi_value,char*,bool*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_has_named_property(napi_env env,
                                               napi_value object,
                                               const char* utf8name,
                                               bool* result) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);

  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Object> obj;

  CHECK_TO_OBJECT(env, context, obj, object);

  v8::Local<v8::Name> key;
  CHECK_NEW_FROM_UTF8(env, key, utf8name);

  v8::Maybe<bool> has_maybe = obj->Has(context, key);

  CHECK_MAYBE_NOTHING(env, has_maybe, napi_generic_failure);

  *result = has_maybe.FromMaybe(false);
  return GET_RETURN_STATUS(env);
}",1057.0,1078.0,1.0,12.0,22.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,napi_status
2848,100478,napi_get_named_property,1,napi_get_named_property,"napi_status napi_get_named_property (napi_env,napi_value,char*,napi_value*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_get_named_property(napi_env env,
                                               napi_value object,
                                               const char* utf8name,
                                               napi_value* result) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);

  v8::Local<v8::Context> context = env->context();

  v8::Local<v8::Name> key;
  CHECK_NEW_FROM_UTF8(env, key, utf8name);

  v8::Local<v8::Object> obj;

  CHECK_TO_OBJECT(env, context, obj, object);

  auto get_maybe = obj->Get(context, key);

  CHECK_MAYBE_EMPTY(env, get_maybe, napi_generic_failure);

  v8::Local<v8::Value> val = get_maybe.ToLocalChecked();
  *result = v8impl::JsValueFromV8LocalValue(val);
  return GET_RETURN_STATUS(env);
}",1080.0,1103.0,1.0,12.0,24.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,napi_status
2849,100486,napi_set_element,1,napi_set_element,"napi_status napi_set_element (napi_env,napi_value,uint32_t,napi_value)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_set_element(napi_env env,
                                        napi_value object,
                                        uint32_t index,
                                        napi_value value) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, value);

  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Object> obj;

  CHECK_TO_OBJECT(env, context, obj, object);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);
  auto set_maybe = obj->Set(context, index, val);

  RETURN_STATUS_IF_FALSE(env, set_maybe.FromMaybe(false), napi_generic_failure);

  return GET_RETURN_STATUS(env);
}",1105.0,1123.0,1.0,12.0,19.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,napi_status
2850,100494,napi_has_element,1,napi_has_element,"napi_status napi_has_element (napi_env,napi_value,uint32_t,bool*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_has_element(napi_env env,
                                        napi_value object,
                                        uint32_t index,
                                        bool* result) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);

  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Object> obj;

  CHECK_TO_OBJECT(env, context, obj, object);

  v8::Maybe<bool> has_maybe = obj->Has(context, index);

  CHECK_MAYBE_NOTHING(env, has_maybe, napi_generic_failure);

  *result = has_maybe.FromMaybe(false);
  return GET_RETURN_STATUS(env);
}",1125.0,1143.0,1.0,12.0,19.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,napi_status
2851,100502,napi_get_element,1,napi_get_element,"napi_status napi_get_element (napi_env,napi_value,uint32_t,napi_value*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_get_element(napi_env env,
                                        napi_value object,
                                        uint32_t index,
                                        napi_value* result) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);

  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Object> obj;

  CHECK_TO_OBJECT(env, context, obj, object);

  auto get_maybe = obj->Get(context, index);

  CHECK_MAYBE_EMPTY(env, get_maybe, napi_generic_failure);

  *result = v8impl::JsValueFromV8LocalValue(get_maybe.ToLocalChecked());
  return GET_RETURN_STATUS(env);
}",1145.0,1163.0,1.0,12.0,19.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,napi_status
2852,100510,napi_delete_element,1,napi_delete_element,"napi_status napi_delete_element (napi_env,napi_value,uint32_t,bool*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_delete_element(napi_env env,
                                           napi_value object,
                                           uint32_t index,
                                           bool* result) {
  NAPI_PREAMBLE(env);

  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Object> obj;

  CHECK_TO_OBJECT(env, context, obj, object);
  v8::Maybe<bool> delete_maybe = obj->Delete(context, index);
  CHECK_MAYBE_NOTHING(env, delete_maybe, napi_generic_failure);

  if (result != nullptr) *result = delete_maybe.FromMaybe(false);

  return GET_RETURN_STATUS(env);
}",1165.0,1181.0,1.0,12.0,17.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,napi_status
2853,100518,napi_define_properties,1,napi_define_properties,"napi_status napi_define_properties (napi_env,napi_value,size_t,napi_property_descriptor*)",js_native_api_v8.cc,"napi_status NAPI_CDECL
napi_define_properties(napi_env env,
                       napi_value object,
                       size_t property_count,
                       const napi_property_descriptor* properties) {
  NAPI_PREAMBLE(env);
  if (property_count > 0) {
    CHECK_ARG(env, properties);
  }

  v8::Local<v8::Context> context = env->context();

  v8::Local<v8::Object> obj;
  CHECK_TO_OBJECT(env, context, obj, object);

  for (size_t i = 0; i < property_count; i++) {
    const napi_property_descriptor* p = &properties[i];

    v8::Local<v8::Name> property_name;
    STATUS_CALL(v8impl::V8NameFromPropertyDescriptor(env, p, &property_name));

    if (p->getter != nullptr || p->setter != nullptr) {
      v8::Local<v8::Function> local_getter;
      v8::Local<v8::Function> local_setter;

      if (p->getter != nullptr) {
        STATUS_CALL(v8impl::FunctionCallbackWrapper::NewFunction(
            env, p->getter, p->data, &local_getter));
      }
      if (p->setter != nullptr) {
...",1183.0,1260.0,1.0,12.0,78.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,napi_status
2854,100526,napi_is_array,1,napi_is_array,"napi_status napi_is_array (napi_env,napi_value,bool*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_is_array(napi_env env,
                                     napi_value value,
                                     bool* result) {
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);

  *result = val->IsArray();
  return napi_clear_last_error(env);
}",1296.0,1307.0,1.0,12.0,12.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,napi_status
2855,100533,napi_get_array_length,1,napi_get_array_length,"napi_status napi_get_array_length (napi_env,napi_value,uint32_t*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_get_array_length(napi_env env,
                                             napi_value value,
                                             uint32_t* result) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);
  RETURN_STATUS_IF_FALSE(env, val->IsArray(), napi_array_expected);

  v8::Local<v8::Array> arr = val.As<v8::Array>();
  *result = arr->Length();

  return GET_RETURN_STATUS(env);
}",1309.0,1323.0,1.0,12.0,15.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,napi_status
2856,100540,napi_strict_equals,1,napi_strict_equals,"napi_status napi_strict_equals (napi_env,napi_value,napi_value,bool*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_strict_equals(napi_env env,
                                          napi_value lhs,
                                          napi_value rhs,
                                          bool* result) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, lhs);
  CHECK_ARG(env, rhs);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> a = v8impl::V8LocalValueFromJsValue(lhs);
  v8::Local<v8::Value> b = v8impl::V8LocalValueFromJsValue(rhs);

  *result = a->StrictEquals(b);
  return GET_RETURN_STATUS(env);
}",1325.0,1339.0,1.0,12.0,15.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,napi_status
2857,100548,napi_call_function,1,napi_call_function,"napi_status napi_call_function (napi_env,napi_value,napi_value,size_t,napi_value*,napi_value*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_call_function(napi_env env,
                                          napi_value recv,
                                          napi_value func,
                                          size_t argc,
                                          const napi_value* argv,
                                          napi_value* result) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, recv);
  if (argc > 0) {
    CHECK_ARG(env, argv);
  }

  v8::Local<v8::Context> context = env->context();

  v8::Local<v8::Value> v8recv = v8impl::V8LocalValueFromJsValue(recv);

  v8::Local<v8::Function> v8func;
  CHECK_TO_FUNCTION(env, v8func, func);

  auto maybe = v8func->Call(
      context,
      v8recv,
      argc,
      reinterpret_cast<v8::Local<v8::Value>*>(const_cast<napi_value*>(argv)));

  if (try_catch.HasCaught()) {
    return napi_set_last_error(env, napi_pending_exception);
  } else {
    if (result != nullptr) {
      CHECK_MAYBE_EMPTY(env, maybe, napi_generic_failure);
   ...",1813.0,1847.0,1.0,12.0,35.0,0,0,0,0,1,0,1,1,0,0,,0,0,12,6,6,napi_status
2858,100558,napi_new_instance,1,napi_new_instance,"napi_status napi_new_instance (napi_env,napi_value,size_t,napi_value*,napi_value*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_new_instance(napi_env env,
                                         napi_value constructor,
                                         size_t argc,
                                         const napi_value* argv,
                                         napi_value* result) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, constructor);
  if (argc > 0) {
    CHECK_ARG(env, argv);
  }
  CHECK_ARG(env, result);

  v8::Local<v8::Context> context = env->context();

  v8::Local<v8::Function> ctor;
  CHECK_TO_FUNCTION(env, ctor, constructor);

  auto maybe = ctor->NewInstance(
      context,
      argc,
      reinterpret_cast<v8::Local<v8::Value>*>(const_cast<napi_value*>(argv)));

  CHECK_MAYBE_EMPTY(env, maybe, napi_pending_exception);

  *result = v8impl::JsValueFromV8LocalValue(maybe.ToLocalChecked());
  return GET_RETURN_STATUS(env);
}",2611.0,2637.0,1.0,12.0,27.0,0,0,0,0,0,0,1,1,0,0,,0,0,10,5,5,napi_status
2859,100567,napi_instanceof,1,napi_instanceof,"napi_status napi_instanceof (napi_env,napi_value,napi_value,bool*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_instanceof(napi_env env,
                                       napi_value object,
                                       napi_value constructor,
                                       bool* result) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, object);
  CHECK_ARG(env, result);

  *result = false;

  v8::Local<v8::Object> ctor;
  v8::Local<v8::Context> context = env->context();

  CHECK_TO_OBJECT(env, context, ctor, constructor);

  if (!ctor->IsFunction()) {
    napi_throw_type_error(
        env, ""ERR_NAPI_CONS_FUNCTION"", ""Constructor must be a function"");

    return napi_set_last_error(env, napi_function_expected);
  }

  napi_status status = napi_generic_failure;

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(object);
  auto maybe_result = val->InstanceOf(context, ctor);
  CHECK_MAYBE_NOTHING(env, maybe_result, status);
  *result = maybe_result.FromJust();
  return GET_RETURN_STATUS(env);
}",2639.0,2668.0,1.0,12.0,30.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,napi_status
2860,100575,napi_get_cb_info,1,napi_get_cb_info,"napi_status napi_get_cb_info (napi_env,napi_callback_info,size_t*,napi_value*,napi_value*,void**)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_get_cb_info(
    napi_env env,               // [in] NAPI environment handle
    napi_callback_info cbinfo,  // [in] Opaque callback-info handle
    size_t* argc,      // [in-out] Specifies the size of the provided argv array
                       // and receives the actual count of args.
    napi_value* argv,  // [out] Array of values
    napi_value* this_arg,  // [out] Receives the JS 'this' arg for the call
    void** data) {         // [out] Receives the data pointer for the callback.
  CHECK_ENV(env);
  CHECK_ARG(env, cbinfo);

  v8impl::CallbackWrapper* info =
      reinterpret_cast<v8impl::CallbackWrapper*>(cbinfo);

  if (argv != nullptr) {
    CHECK_ARG(env, argc);
    info->Args(argv, *argc);
  }
  if (argc != nullptr) {
    *argc = info->ArgsLength();
  }
  if (this_arg != nullptr) {
    *this_arg = info->This();
  }
  if (data != nullptr) {
    *data = info->Data();
  }

  return napi_clear_last_error(env);
}",1768.0,1797.0,1.0,12.0,30.0,0,0,0,0,0,0,1,1,0,0,,0,0,12,6,6,napi_status
2861,100585,napi_get_new_target,1,napi_get_new_target,"napi_status napi_get_new_target (napi_env,napi_callback_info,napi_value*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_get_new_target(napi_env env,
                                           napi_callback_info cbinfo,
                                           napi_value* result) {
  CHECK_ENV(env);
  CHECK_ARG(env, cbinfo);
  CHECK_ARG(env, result);

  v8impl::CallbackWrapper* info =
      reinterpret_cast<v8impl::CallbackWrapper*>(cbinfo);

  *result = info->GetNewTarget();
  return napi_clear_last_error(env);
}",1799.0,1811.0,1.0,12.0,13.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,napi_status
2862,100592,napi_define_class,1,napi_define_class,"napi_status napi_define_class (napi_env,char*,size_t,napi_callback,void*,size_t,napi_property_descriptor*,napi_value*)",js_native_api_v8.cc,"napi_status NAPI_CDECL
napi_define_class(napi_env env,
                  const char* utf8name,
                  size_t length,
                  napi_callback constructor,
                  void* callback_data,
                  size_t property_count,
                  const napi_property_descriptor* properties,
                  napi_value* result) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);
  CHECK_ARG(env, constructor);

  if (property_count > 0) {
    CHECK_ARG(env, properties);
  }

  v8::Isolate* isolate = env->isolate;

  v8::EscapableHandleScope scope(isolate);
  v8::Local<v8::FunctionTemplate> tpl;
  STATUS_CALL(v8impl::FunctionCallbackWrapper::NewTemplate(
      env, constructor, callback_data, &tpl));

  v8::Local<v8::String> name_string;
  CHECK_NEW_FROM_UTF8_LEN(env, name_string, utf8name, length);
  tpl->SetClassName(name_string);

  size_t static_property_count = 0;
  for (size_t i = 0; i < property_count; i++) {
    const napi_property_descriptor* p = properti...",740.0,837.0,1.0,12.0,98.0,0,0,0,0,0,0,1,1,0,0,,0,0,16,8,8,napi_status
2863,100604,napi_wrap,1,napi_wrap,"napi_status napi_wrap (napi_env,napi_value,void*,napi_finalize,void*,napi_ref*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_wrap(napi_env env,
                                 napi_value js_object,
                                 void* native_object,
                                 napi_finalize finalize_cb,
                                 void* finalize_hint,
                                 napi_ref* result) {
  return v8impl::Wrap(
      env, js_object, native_object, finalize_cb, finalize_hint, result);
}",2292.0,2300.0,1.0,12.0,9.0,0,0,0,0,0,0,1,1,0,0,,0,0,12,6,6,napi_status
2864,100614,napi_unwrap,1,napi_unwrap,"napi_status napi_unwrap (napi_env,napi_value,void**)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_unwrap(napi_env env,
                                   napi_value obj,
                                   void** result) {
  return v8impl::Unwrap(env, obj, result, v8impl::KeepWrap);
}",2302.0,2306.0,1.0,12.0,5.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,napi_status
2865,100621,napi_remove_wrap,1,napi_remove_wrap,"napi_status napi_remove_wrap (napi_env,napi_value,void**)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_remove_wrap(napi_env env,
                                        napi_value obj,
                                        void** result) {
  return v8impl::Unwrap(env, obj, result, v8impl::RemoveWrap);
}",2308.0,2312.0,1.0,12.0,5.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,napi_status
2866,100628,napi_create_external,1,napi_create_external,"napi_status napi_create_external (napi_env,void*,napi_finalize,void*,napi_value*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_create_external(napi_env env,
                                            void* data,
                                            napi_finalize finalize_cb,
                                            void* finalize_hint,
                                            napi_value* result) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);

  v8::Isolate* isolate = env->isolate;

  v8::Local<v8::Value> external_value = v8::External::New(isolate, data);

  if (finalize_cb) {
    // The Reference object will delete itself after invoking the finalizer
    // callback.
    v8impl::Reference::New(env,
                           external_value,
                           0,
                           v8impl::Ownership::kRuntime,
                           finalize_cb,
                           data,
                           finalize_hint);
  }

  *result = v8impl::JsValueFromV8LocalValue(external_value);

  return napi_clear_last_error(env);
}",2314.0,2341.0,1.0,12.0,28.0,0,0,0,0,0,0,1,1,0,0,,0,0,10,5,5,napi_status
2867,100637,napi_get_value_external,1,napi_get_value_external,"napi_status napi_get_value_external (napi_env,napi_value,void**)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_get_value_external(napi_env env,
                                               napi_value value,
                                               void** result) {
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);
  RETURN_STATUS_IF_FALSE(env, val->IsExternal(), napi_invalid_arg);

  v8::Local<v8::External> external_value = val.As<v8::External>();
  *result = external_value->Value();

  return napi_clear_last_error(env);
}",2411.0,2425.0,1.0,12.0,15.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,napi_status
2868,100644,napi_create_reference,1,napi_create_reference,"napi_status napi_create_reference (napi_env,napi_value,uint32_t,napi_ref*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_create_reference(napi_env env,
                                             napi_value value,
                                             uint32_t initial_refcount,
                                             napi_ref* result) {
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> v8_value = v8impl::V8LocalValueFromJsValue(value);
  if (env->module_api_version <= 8) {
    if (!(v8_value->IsObject() || v8_value->IsFunction() ||
          v8_value->IsSymbol())) {
      return napi_set_last_error(env, napi_invalid_arg);
    }
  }

  v8impl::Reference* reference = v8impl::Reference::New(
      env, v8_value, initial_refcount, v8impl::Ownership::kUserland);

  *result = reinterpret_cast<napi_ref>(reference);
  return napi_clear_last_error(env);
}",2428.0,2451.0,1.0,12.0,24.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,napi_status
2869,100652,napi_delete_reference,1,napi_delete_reference,"napi_status napi_delete_reference (napi_env,napi_ref)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_delete_reference(napi_env env, napi_ref ref) {
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, ref);

  delete reinterpret_cast<v8impl::Reference*>(ref);

  return napi_clear_last_error(env);
}",2455.0,2464.0,1.0,12.0,10.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,napi_status
2870,100658,napi_reference_ref,1,napi_reference_ref,"napi_status napi_reference_ref (napi_env,napi_ref,uint32_t*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_reference_ref(napi_env env,
                                          napi_ref ref,
                                          uint32_t* result) {
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, ref);

  v8impl::Reference* reference = reinterpret_cast<v8impl::Reference*>(ref);
  uint32_t count = reference->Ref();

  if (result != nullptr) {
    *result = count;
  }

  return napi_clear_last_error(env);
}",2471.0,2487.0,1.0,12.0,17.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,napi_status
2871,100665,napi_reference_unref,1,napi_reference_unref,"napi_status napi_reference_unref (napi_env,napi_ref,uint32_t*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_reference_unref(napi_env env,
                                            napi_ref ref,
                                            uint32_t* result) {
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, ref);

  v8impl::Reference* reference = reinterpret_cast<v8impl::Reference*>(ref);

  if (reference->RefCount() == 0) {
    return napi_set_last_error(env, napi_generic_failure);
  }

  uint32_t count = reference->Unref();

  if (result != nullptr) {
    *result = count;
  }

  return napi_clear_last_error(env);
}",2493.0,2514.0,1.0,12.0,22.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,napi_status
2872,100672,napi_get_reference_value,1,napi_get_reference_value,"napi_status napi_get_reference_value (napi_env,napi_ref,napi_value*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_get_reference_value(napi_env env,
                                                napi_ref ref,
                                                napi_value* result) {
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, ref);
  CHECK_ARG(env, result);

  v8impl::Reference* reference = reinterpret_cast<v8impl::Reference*>(ref);
  *result = v8impl::JsValueFromV8LocalValue(reference->Get());

  return napi_clear_last_error(env);
}",2519.0,2532.0,1.0,12.0,14.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,napi_status
2873,100679,napi_open_handle_scope,1,napi_open_handle_scope,"napi_status napi_open_handle_scope (napi_env,napi_handle_scope*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_open_handle_scope(napi_env env,
                                              napi_handle_scope* result) {
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result = v8impl::JsHandleScopeFromV8HandleScope(
      new v8impl::HandleScopeWrapper(env->isolate));
  env->open_handle_scopes++;
  return napi_clear_last_error(env);
}",2534.0,2545.0,1.0,12.0,12.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,napi_status
2874,100685,napi_close_handle_scope,1,napi_close_handle_scope,"napi_status napi_close_handle_scope (napi_env,napi_handle_scope)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_close_handle_scope(napi_env env,
                                               napi_handle_scope scope) {
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, scope);
  if (env->open_handle_scopes == 0) {
    return napi_handle_scope_mismatch;
  }

  env->open_handle_scopes--;
  delete v8impl::V8HandleScopeFromJsHandleScope(scope);
  return napi_clear_last_error(env);
}",2547.0,2560.0,1.0,12.0,14.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,napi_status
2875,100691,napi_open_escapable_handle_scope,1,napi_open_escapable_handle_scope,"napi_status napi_open_escapable_handle_scope (napi_env,napi_escapable_handle_scope*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_open_escapable_handle_scope(
    napi_env env, napi_escapable_handle_scope* result) {
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result = v8impl::JsEscapableHandleScopeFromV8EscapableHandleScope(
      new v8impl::EscapableHandleScopeWrapper(env->isolate));
  env->open_handle_scopes++;
  return napi_clear_last_error(env);
}",2562.0,2573.0,1.0,12.0,12.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,napi_status
2876,100697,napi_close_escapable_handle_scope,1,napi_close_escapable_handle_scope,"napi_status napi_close_escapable_handle_scope (napi_env,napi_escapable_handle_scope)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_close_escapable_handle_scope(
    napi_env env, napi_escapable_handle_scope scope) {
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, scope);
  if (env->open_handle_scopes == 0) {
    return napi_handle_scope_mismatch;
  }

  delete v8impl::V8EscapableHandleScopeFromJsEscapableHandleScope(scope);
  env->open_handle_scopes--;
  return napi_clear_last_error(env);
}",2575.0,2588.0,1.0,12.0,14.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,napi_status
2877,100703,napi_escape_handle,1,napi_escape_handle,"napi_status napi_escape_handle (napi_env,napi_escapable_handle_scope,napi_value,napi_value*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_escape_handle(napi_env env,
                                          napi_escapable_handle_scope scope,
                                          napi_value escapee,
                                          napi_value* result) {
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, scope);
  CHECK_ARG(env, escapee);
  CHECK_ARG(env, result);

  v8impl::EscapableHandleScopeWrapper* s =
      v8impl::V8EscapableHandleScopeFromJsEscapableHandleScope(scope);
  if (!s->escape_called()) {
    *result = v8impl::JsValueFromV8LocalValue(
        s->Escape(v8impl::V8LocalValueFromJsValue(escapee)));
    return napi_clear_last_error(env);
  }
  return napi_set_last_error(env, napi_escape_called_twice);
}",2590.0,2609.0,1.0,12.0,20.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,napi_status
2878,100711,napi_throw,1,napi_throw,"napi_status napi_throw (napi_env,napi_value)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_throw(napi_env env, napi_value error) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, error);

  v8::Isolate* isolate = env->isolate;

  isolate->ThrowException(v8impl::V8LocalValueFromJsValue(error));
  // any VM calls after this point and before returning
  // to the javascript invoker will fail
  return napi_clear_last_error(env);
}",1858.0,1868.0,1.0,12.0,11.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,napi_status
2879,100717,napi_throw_error,1,napi_throw_error,"napi_status napi_throw_error (napi_env,char*,char*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_throw_error(napi_env env,
                                        const char* code,
                                        const char* msg) {
  NAPI_PREAMBLE(env);

  v8::Isolate* isolate = env->isolate;
  v8::Local<v8::String> str;
  CHECK_NEW_FROM_UTF8(env, str, msg);

  v8::Local<v8::Value> error_obj = v8::Exception::Error(str);
  STATUS_CALL(set_error_code(env, error_obj, nullptr, code));

  isolate->ThrowException(error_obj);
  // any VM calls after this point and before returning
  // to the javascript invoker will fail
  return napi_clear_last_error(env);
}",1870.0,1886.0,1.0,12.0,17.0,0,0,0,0,2,0,1,1,0,0,,0,0,6,3,3,napi_status
2880,100724,napi_throw_type_error,1,napi_throw_type_error,"napi_status napi_throw_type_error (napi_env,char*,char*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_throw_type_error(napi_env env,
                                             const char* code,
                                             const char* msg) {
  NAPI_PREAMBLE(env);

  v8::Isolate* isolate = env->isolate;
  v8::Local<v8::String> str;
  CHECK_NEW_FROM_UTF8(env, str, msg);

  v8::Local<v8::Value> error_obj = v8::Exception::TypeError(str);
  STATUS_CALL(set_error_code(env, error_obj, nullptr, code));

  isolate->ThrowException(error_obj);
  // any VM calls after this point and before returning
  // to the javascript invoker will fail
  return napi_clear_last_error(env);
}",1888.0,1904.0,1.0,12.0,17.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,napi_status
2881,100731,napi_throw_range_error,1,napi_throw_range_error,"napi_status napi_throw_range_error (napi_env,char*,char*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_throw_range_error(napi_env env,
                                              const char* code,
                                              const char* msg) {
  NAPI_PREAMBLE(env);

  v8::Isolate* isolate = env->isolate;
  v8::Local<v8::String> str;
  CHECK_NEW_FROM_UTF8(env, str, msg);

  v8::Local<v8::Value> error_obj = v8::Exception::RangeError(str);
  STATUS_CALL(set_error_code(env, error_obj, nullptr, code));

  isolate->ThrowException(error_obj);
  // any VM calls after this point and before returning
  // to the javascript invoker will fail
  return napi_clear_last_error(env);
}",1906.0,1922.0,1.0,12.0,17.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,napi_status
2882,100738,napi_is_error,1,napi_is_error,"napi_status napi_is_error (napi_env,napi_value,bool*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_is_error(napi_env env,
                                     napi_value value,
                                     bool* result) {
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot
  // throw JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);
  *result = val->IsNativeError();

  return napi_clear_last_error(env);
}",1942.0,1955.0,1.0,12.0,14.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,napi_status
2883,100745,napi_is_exception_pending,1,napi_is_exception_pending,"napi_status napi_is_exception_pending (napi_env,bool*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_is_exception_pending(napi_env env, bool* result) {
  // NAPI_PREAMBLE is not used here: this function must execute when there is a
  // pending exception.
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result = !env->last_exception.IsEmpty();
  return napi_clear_last_error(env);
}",2671.0,2679.0,1.0,12.0,9.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,napi_status
2884,100751,napi_get_and_clear_last_exception,1,napi_get_and_clear_last_exception,"napi_status napi_get_and_clear_last_exception (napi_env,napi_value*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_get_and_clear_last_exception(napi_env env,
                                                         napi_value* result) {
  // NAPI_PREAMBLE is not used here: this function must execute when there is a
  // pending exception.
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  if (env->last_exception.IsEmpty()) {
    return napi_get_undefined(env, result);
  } else {
    *result = v8impl::JsValueFromV8LocalValue(
        v8::Local<v8::Value>::New(env->isolate, env->last_exception));
    env->last_exception.Reset();
  }

  return napi_clear_last_error(env);
}",2681.0,2697.0,1.0,12.0,17.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,napi_status
2885,100757,napi_is_arraybuffer,1,napi_is_arraybuffer,"napi_status napi_is_arraybuffer (napi_env,napi_value,bool*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_is_arraybuffer(napi_env env,
                                           napi_value value,
                                           bool* result) {
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);
  *result = val->IsArrayBuffer();

  return napi_clear_last_error(env);
}",2699.0,2710.0,1.0,12.0,12.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,napi_status
2886,100764,napi_create_arraybuffer,1,napi_create_arraybuffer,"napi_status napi_create_arraybuffer (napi_env,size_t,void**,napi_value*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_create_arraybuffer(napi_env env,
                                               size_t byte_length,
                                               void** data,
                                               napi_value* result) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);

  v8::Isolate* isolate = env->isolate;
  v8::Local<v8::ArrayBuffer> buffer =
      v8::ArrayBuffer::New(isolate, byte_length);

  // Optionally return a pointer to the buffer's data, to avoid another call to
  // retrieve it.
  if (data != nullptr) {
    *data = buffer->Data();
  }

  *result = v8impl::JsValueFromV8LocalValue(buffer);
  return GET_RETURN_STATUS(env);
}",2712.0,2731.0,1.0,12.0,20.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,napi_status
2887,100772,napi_create_external_arraybuffer,1,napi_create_external_arraybuffer,"napi_status napi_create_external_arraybuffer (napi_env,void*,size_t,napi_finalize,void*,napi_value*)",js_native_api_v8.cc,"napi_status NAPI_CDECL
napi_create_external_arraybuffer(napi_env env,
                                 void* external_data,
                                 size_t byte_length,
                                 napi_finalize finalize_cb,
                                 void* finalize_hint,
                                 napi_value* result) {
  // The API contract here is that the cleanup function runs on the JS thread,
  // and is able to use napi_env. Implementing that properly is hard, so use the
  // `Buffer` variant for easier implementation.
  napi_value buffer;
  STATUS_CALL(napi_create_external_buffer(
      env, byte_length, external_data, finalize_cb, finalize_hint, &buffer));
  return napi_get_typedarray_info(
      env, buffer, nullptr, nullptr, nullptr, result, nullptr);
}",2733.0,2748.0,1.0,12.0,16.0,0,0,0,0,0,0,1,1,0,0,,0,0,12,6,6,napi_status
2888,100782,napi_get_arraybuffer_info,1,napi_get_arraybuffer_info,"napi_status napi_get_arraybuffer_info (napi_env,napi_value,void**,size_t*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_get_arraybuffer_info(napi_env env,
                                                 napi_value arraybuffer,
                                                 void** data,
                                                 size_t* byte_length) {
  CHECK_ENV(env);
  CHECK_ARG(env, arraybuffer);

  v8::Local<v8::Value> value = v8impl::V8LocalValueFromJsValue(arraybuffer);
  RETURN_STATUS_IF_FALSE(env, value->IsArrayBuffer(), napi_invalid_arg);

  v8::Local<v8::ArrayBuffer> ab = value.As<v8::ArrayBuffer>();

  if (data != nullptr) {
    *data = ab->Data();
  }

  if (byte_length != nullptr) {
    *byte_length = ab->ByteLength();
  }

  return napi_clear_last_error(env);
}",2750.0,2771.0,1.0,12.0,22.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,napi_status
2889,100790,napi_is_typedarray,1,napi_is_typedarray,"napi_status napi_is_typedarray (napi_env,napi_value,bool*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_is_typedarray(napi_env env,
                                          napi_value value,
                                          bool* result) {
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);
  *result = val->IsTypedArray();

  return napi_clear_last_error(env);
}",2773.0,2784.0,1.0,12.0,12.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,napi_status
2890,100797,napi_create_typedarray,1,napi_create_typedarray,"napi_status napi_create_typedarray (napi_env,napi_typedarray_type,size_t,napi_value,size_t,napi_value*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_create_typedarray(napi_env env,
                                              napi_typedarray_type type,
                                              size_t length,
                                              napi_value arraybuffer,
                                              size_t byte_offset,
                                              napi_value* result) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, arraybuffer);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> value = v8impl::V8LocalValueFromJsValue(arraybuffer);
  RETURN_STATUS_IF_FALSE(env, value->IsArrayBuffer(), napi_invalid_arg);

  v8::Local<v8::ArrayBuffer> buffer = value.As<v8::ArrayBuffer>();
  v8::Local<v8::TypedArray> typedArray;

  switch (type) {
    case napi_int8_array:
      CREATE_TYPED_ARRAY(
          env, Int8Array, 1, buffer, byte_offset, length, typedArray);
      break;
    case napi_uint8_array:
      CREATE_TYPED_ARRAY(
          env, Uint8Array, 1, buffer, byte_offset, le...",2786.0,2853.0,1.0,12.0,68.0,0,0,0,0,0,0,1,1,0,0,,0,0,12,6,6,napi_status
2891,100807,napi_get_typedarray_info,1,napi_get_typedarray_info,"napi_status napi_get_typedarray_info (napi_env,napi_value,napi_typedarray_type*,size_t*,void**,napi_value*,size_t*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_get_typedarray_info(napi_env env,
                                                napi_value typedarray,
                                                napi_typedarray_type* type,
                                                size_t* length,
                                                void** data,
                                                napi_value* arraybuffer,
                                                size_t* byte_offset) {
  CHECK_ENV(env);
  CHECK_ARG(env, typedarray);

  v8::Local<v8::Value> value = v8impl::V8LocalValueFromJsValue(typedarray);
  RETURN_STATUS_IF_FALSE(env, value->IsTypedArray(), napi_invalid_arg);

  v8::Local<v8::TypedArray> array = value.As<v8::TypedArray>();

  if (type != nullptr) {
    if (value->IsInt8Array()) {
      *type = napi_int8_array;
    } else if (value->IsUint8Array()) {
      *type = napi_uint8_array;
    } else if (value->IsUint8ClampedArray()) {
      *type = napi_uint8_clamped_array;
    } els...",2855.0,2920.0,1.0,12.0,66.0,0,0,0,0,0,0,1,1,0,0,,0,0,14,7,7,napi_status
2892,100818,napi_create_dataview,1,napi_create_dataview,"napi_status napi_create_dataview (napi_env,size_t,napi_value,size_t,napi_value*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_create_dataview(napi_env env,
                                            size_t byte_length,
                                            napi_value arraybuffer,
                                            size_t byte_offset,
                                            napi_value* result) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, arraybuffer);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> value = v8impl::V8LocalValueFromJsValue(arraybuffer);
  RETURN_STATUS_IF_FALSE(env, value->IsArrayBuffer(), napi_invalid_arg);

  v8::Local<v8::ArrayBuffer> buffer = value.As<v8::ArrayBuffer>();
  if (byte_length + byte_offset > buffer->ByteLength()) {
    napi_throw_range_error(env,
                           ""ERR_NAPI_INVALID_DATAVIEW_ARGS"",
                           ""byte_offset + byte_length should be less than or ""
                           ""equal to the size in bytes of the array passed in"");
    return napi_set_last_error(env, napi_pending_exception);
  }
  v...",2922.0,2947.0,1.0,12.0,26.0,0,0,0,0,0,0,1,1,0,0,,0,0,10,5,5,napi_status
2893,100827,napi_is_dataview,1,napi_is_dataview,"napi_status napi_is_dataview (napi_env,napi_value,bool*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_is_dataview(napi_env env,
                                        napi_value value,
                                        bool* result) {
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);
  *result = val->IsDataView();

  return napi_clear_last_error(env);
}",2949.0,2960.0,1.0,12.0,12.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,napi_status
2894,100834,napi_get_dataview_info,1,napi_get_dataview_info,"napi_status napi_get_dataview_info (napi_env,napi_value,size_t*,void**,napi_value*,size_t*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_get_dataview_info(napi_env env,
                                              napi_value dataview,
                                              size_t* byte_length,
                                              void** data,
                                              napi_value* arraybuffer,
                                              size_t* byte_offset) {
  CHECK_ENV(env);
  CHECK_ARG(env, dataview);

  v8::Local<v8::Value> value = v8impl::V8LocalValueFromJsValue(dataview);
  RETURN_STATUS_IF_FALSE(env, value->IsDataView(), napi_invalid_arg);

  v8::Local<v8::DataView> array = value.As<v8::DataView>();

  if (byte_length != nullptr) {
    *byte_length = array->ByteLength();
  }

  v8::Local<v8::ArrayBuffer> buffer;
  if (data != nullptr || arraybuffer != nullptr) {
    // Calling Buffer() may have the side effect of allocating the buffer,
    // so only do this when its needed.
    buffer = array->Buffer();
  }

  if (data != nullptr) {
    *data ...",2962.0,3000.0,1.0,12.0,39.0,0,0,0,0,0,0,1,1,0,0,,0,0,12,6,6,napi_status
2895,100844,napi_get_version,1,napi_get_version,"napi_status napi_get_version (napi_env,uint32_t*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_get_version(napi_env env, uint32_t* result) {
  CHECK_ENV(env);
  CHECK_ARG(env, result);
  *result = NAPI_VERSION;
  return napi_clear_last_error(env);
}",3002.0,3007.0,1.0,12.0,6.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,napi_status
2896,100850,napi_create_promise,1,napi_create_promise,"napi_status napi_create_promise (napi_env,napi_deferred*,napi_value*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_create_promise(napi_env env,
                                           napi_deferred* deferred,
                                           napi_value* promise) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, deferred);
  CHECK_ARG(env, promise);

  auto maybe = v8::Promise::Resolver::New(env->context());
  CHECK_MAYBE_EMPTY(env, maybe, napi_generic_failure);

  auto v8_resolver = maybe.ToLocalChecked();
  auto v8_deferred = new v8impl::Persistent<v8::Value>();
  v8_deferred->Reset(env->isolate, v8_resolver);

  *deferred = v8impl::JsDeferredFromNodePersistent(v8_deferred);
  *promise = v8impl::JsValueFromV8LocalValue(v8_resolver->GetPromise());
  return GET_RETURN_STATUS(env);
}",3009.0,3026.0,1.0,12.0,18.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,napi_status
2897,100857,napi_resolve_deferred,1,napi_resolve_deferred,"napi_status napi_resolve_deferred (napi_env,napi_deferred,napi_value)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_resolve_deferred(napi_env env,
                                             napi_deferred deferred,
                                             napi_value resolution) {
  return v8impl::ConcludeDeferred(env, deferred, resolution, true);
}",3028.0,3032.0,1.0,12.0,5.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,napi_status
2898,100864,napi_reject_deferred,1,napi_reject_deferred,"napi_status napi_reject_deferred (napi_env,napi_deferred,napi_value)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_reject_deferred(napi_env env,
                                            napi_deferred deferred,
                                            napi_value resolution) {
  return v8impl::ConcludeDeferred(env, deferred, resolution, false);
}",3034.0,3038.0,1.0,12.0,5.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,napi_status
2899,100871,napi_is_promise,1,napi_is_promise,"napi_status napi_is_promise (napi_env,napi_value,bool*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_is_promise(napi_env env,
                                       napi_value value,
                                       bool* is_promise) {
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, is_promise);

  *is_promise = v8impl::V8LocalValueFromJsValue(value)->IsPromise();

  return napi_clear_last_error(env);
}",3040.0,3050.0,1.0,12.0,11.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,napi_status
2900,100878,napi_run_script,1,napi_run_script,"napi_status napi_run_script (napi_env,napi_value,napi_value*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_run_script(napi_env env,
                                       napi_value script,
                                       napi_value* result) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, script);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> v8_script = v8impl::V8LocalValueFromJsValue(script);

  if (!v8_script->IsString()) {
    return napi_set_last_error(env, napi_string_expected);
  }

  v8::Local<v8::Context> context = env->context();

  auto maybe_script = v8::Script::Compile(context, v8_script.As<v8::String>());
  CHECK_MAYBE_EMPTY(env, maybe_script, napi_generic_failure);

  auto script_result = maybe_script.ToLocalChecked()->Run(context);
  CHECK_MAYBE_EMPTY(env, script_result, napi_generic_failure);

  *result = v8impl::JsValueFromV8LocalValue(script_result.ToLocalChecked());
  return GET_RETURN_STATUS(env);
}",3094.0,3117.0,1.0,12.0,24.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,napi_status
2901,100885,napi_adjust_external_memory,1,napi_adjust_external_memory,"napi_status napi_adjust_external_memory (napi_env,int64_t,int64_t*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_adjust_external_memory(napi_env env,
                                                   int64_t change_in_bytes,
                                                   int64_t* adjusted_value) {
  CHECK_ENV(env);
  CHECK_ARG(env, adjusted_value);

  *adjusted_value =
      env->isolate->AdjustAmountOfExternalAllocatedMemory(change_in_bytes);

  return napi_clear_last_error(env);
}",3148.0,3158.0,1.0,12.0,11.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,napi_status
2902,100892,napi_create_date,1,napi_create_date,"napi_status napi_create_date (napi_env,double,napi_value*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_create_date(napi_env env,
                                        double time,
                                        napi_value* result) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);

  v8::MaybeLocal<v8::Value> maybe_date = v8::Date::New(env->context(), time);
  CHECK_MAYBE_EMPTY(env, maybe_date, napi_generic_failure);

  *result = v8impl::JsValueFromV8LocalValue(maybe_date.ToLocalChecked());

  return GET_RETURN_STATUS(env);
}",3052.0,3064.0,1.0,12.0,13.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,napi_status
2903,100899,napi_is_date,1,napi_is_date,"napi_status napi_is_date (napi_env,napi_value,bool*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_is_date(napi_env env,
                                    napi_value value,
                                    bool* is_date) {
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, is_date);

  *is_date = v8impl::V8LocalValueFromJsValue(value)->IsDate();

  return napi_clear_last_error(env);
}",3066.0,3076.0,1.0,12.0,11.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,napi_status
2904,100906,napi_get_date_value,1,napi_get_date_value,"napi_status napi_get_date_value (napi_env,napi_value,double*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_get_date_value(napi_env env,
                                           napi_value value,
                                           double* result) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);
  RETURN_STATUS_IF_FALSE(env, val->IsDate(), napi_date_expected);

  v8::Local<v8::Date> date = val.As<v8::Date>();
  *result = date->ValueOf();

  return GET_RETURN_STATUS(env);
}",3078.0,3092.0,1.0,12.0,15.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,napi_status
2905,100913,napi_add_finalizer,1,napi_add_finalizer,"napi_status napi_add_finalizer (napi_env,napi_value,void*,napi_finalize,void*,napi_ref*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_add_finalizer(napi_env env,
                                          napi_value js_object,
                                          void* finalize_data,
                                          napi_finalize finalize_cb,
                                          void* finalize_hint,
                                          napi_ref* result) {
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, js_object);
  CHECK_ARG(env, finalize_cb);

  v8::Local<v8::Value> v8_value = v8impl::V8LocalValueFromJsValue(js_object);
  RETURN_STATUS_IF_FALSE(env, v8_value->IsObject(), napi_invalid_arg);

  // Create a self-deleting reference if the optional out-param result is not
  // set.
  v8impl::Ownership ownership = result == nullptr
                                    ? v8impl::Ownership::kRuntime
                                    : v8impl::Ownership::kUserland;
  v8impl::Referenc...",3119.0,3146.0,1.0,12.0,28.0,0,0,0,0,0,0,1,1,0,0,,0,0,12,6,6,napi_status
2906,100923,napi_create_bigint_int64,1,napi_create_bigint_int64,"napi_status napi_create_bigint_int64 (napi_env,int64_t,napi_value*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_create_bigint_int64(napi_env env,
                                                int64_t value,
                                                napi_value* result) {
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result =
      v8impl::JsValueFromV8LocalValue(v8::BigInt::New(env->isolate, value));

  return napi_clear_last_error(env);
}",1497.0,1507.0,1.0,12.0,11.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,napi_status
2907,100930,napi_create_bigint_uint64,1,napi_create_bigint_uint64,"napi_status napi_create_bigint_uint64 (napi_env,uint64_t,napi_value*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_create_bigint_uint64(napi_env env,
                                                 uint64_t value,
                                                 napi_value* result) {
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result = v8impl::JsValueFromV8LocalValue(
      v8::BigInt::NewFromUnsigned(env->isolate, value));

  return napi_clear_last_error(env);
}",1509.0,1519.0,1.0,12.0,11.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,napi_status
2908,100937,napi_create_bigint_words,1,napi_create_bigint_words,"napi_status napi_create_bigint_words (napi_env,int,size_t,uint64_t*,napi_value*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_create_bigint_words(napi_env env,
                                                int sign_bit,
                                                size_t word_count,
                                                const uint64_t* words,
                                                napi_value* result) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, words);
  CHECK_ARG(env, result);

  v8::Local<v8::Context> context = env->context();

  RETURN_STATUS_IF_FALSE(env, word_count <= INT_MAX, napi_invalid_arg);

  v8::MaybeLocal<v8::BigInt> b =
      v8::BigInt::NewFromWords(context, sign_bit, word_count, words);

  CHECK_MAYBE_EMPTY_WITH_PREAMBLE(env, b, napi_generic_failure);

  *result = v8impl::JsValueFromV8LocalValue(b.ToLocalChecked());
  return GET_RETURN_STATUS(env);
}",1521.0,1541.0,1.0,12.0,21.0,0,0,0,0,0,0,1,1,0,0,,0,0,10,5,5,napi_status
2909,100946,napi_get_value_bigint_int64,1,napi_get_value_bigint_int64,"napi_status napi_get_value_bigint_int64 (napi_env,napi_value,int64_t*,bool*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_get_value_bigint_int64(napi_env env,
                                                   napi_value value,
                                                   int64_t* result,
                                                   bool* lossless) {
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);
  CHECK_ARG(env, lossless);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);

  RETURN_STATUS_IF_FALSE(env, val->IsBigInt(), napi_bigint_expected);

  *result = val.As<v8::BigInt>()->Int64Value(lossless);

  return napi_clear_last_error(env);
}",2056.0,2072.0,1.0,12.0,17.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,napi_status
2910,100954,napi_get_value_bigint_uint64,1,napi_get_value_bigint_uint64,"napi_status napi_get_value_bigint_uint64 (napi_env,napi_value,uint64_t*,bool*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_get_value_bigint_uint64(napi_env env,
                                                    napi_value value,
                                                    uint64_t* result,
                                                    bool* lossless) {
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);
  CHECK_ARG(env, lossless);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);

  RETURN_STATUS_IF_FALSE(env, val->IsBigInt(), napi_bigint_expected);

  *result = val.As<v8::BigInt>()->Uint64Value(lossless);

  return napi_clear_last_error(env);
}",2074.0,2090.0,1.0,12.0,17.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,napi_status
2911,100962,napi_get_value_bigint_words,1,napi_get_value_bigint_words,"napi_status napi_get_value_bigint_words (napi_env,napi_value,int*,size_t*,uint64_t*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_get_value_bigint_words(napi_env env,
                                                   napi_value value,
                                                   int* sign_bit,
                                                   size_t* word_count,
                                                   uint64_t* words) {
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, word_count);

  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);

  RETURN_STATUS_IF_FALSE(env, val->IsBigInt(), napi_bigint_expected);

  v8::Local<v8::BigInt> big = val.As<v8::BigInt>();

  int word_count_int = *word_count;

  if (sign_bit == nullptr && words == nullptr) {
    word_count_int = big->WordCount();
  } else {
    CHECK_ARG(env, sign_bit);
    CHECK_ARG(env, words);
    big->ToWordsArray(sign_bit, &word_count_int, words);
  }

  *word_count = word_count_int;

  return napi_clear_last_error(env);
}",2092.0,2120.0,1.0,12.0,29.0,0,0,0,0,0,0,1,1,0,0,,0,0,10,5,5,napi_status
2912,100971,napi_get_all_property_names,1,napi_get_all_property_names,"napi_status napi_get_all_property_names (napi_env,napi_value,napi_key_collection_mode,napi_key_filter,napi_key_conversion,napi_value*)",js_native_api_v8.cc,"napi_status NAPI_CDECL
napi_get_all_property_names(napi_env env,
                            napi_value object,
                            napi_key_collection_mode key_mode,
                            napi_key_filter key_filter,
                            napi_key_conversion key_conversion,
                            napi_value* result) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);

  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Object> obj;
  CHECK_TO_OBJECT(env, context, obj, object);

  v8::PropertyFilter filter = v8::PropertyFilter::ALL_PROPERTIES;
  if (key_filter & napi_key_writable) {
    filter = static_cast<v8::PropertyFilter>(filter |
                                             v8::PropertyFilter::ONLY_WRITABLE);
  }
  if (key_filter & napi_key_enumerable) {
    filter = static_cast<v8::PropertyFilter>(
        filter | v8::PropertyFilter::ONLY_ENUMERABLE);
  }
  if (key_filter & napi_key_configurable) {
    filter = static_cast<v8::PropertyFil...",851.0,924.0,1.0,12.0,74.0,0,0,0,0,0,0,1,1,0,0,,0,0,12,6,6,napi_status
2913,100981,napi_set_instance_data,1,napi_set_instance_data,"napi_status napi_set_instance_data (napi_env,void*,napi_finalize,void*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_set_instance_data(napi_env env,
                                              void* data,
                                              napi_finalize finalize_cb,
                                              void* finalize_hint) {
  CHECK_ENV(env);

  v8impl::RefBase* old_data = static_cast<v8impl::RefBase*>(env->instance_data);
  if (old_data != nullptr) {
    // Our contract so far has been to not finalize any old data there may be.
    // So we simply delete it.
    delete old_data;
  }

  env->instance_data = v8impl::RefBase::New(
      env, 0, v8impl::Ownership::kRuntime, finalize_cb, data, finalize_hint);

  return napi_clear_last_error(env);
}",3160.0,3177.0,1.0,12.0,18.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,napi_status
2914,100989,napi_get_instance_data,1,napi_get_instance_data,"napi_status napi_get_instance_data (napi_env,void**)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_get_instance_data(napi_env env, void** data) {
  CHECK_ENV(env);
  CHECK_ARG(env, data);

  v8impl::RefBase* idata = static_cast<v8impl::RefBase*>(env->instance_data);

  *data = (idata == nullptr ? nullptr : idata->Data());

  return napi_clear_last_error(env);
}",3179.0,3188.0,1.0,12.0,10.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,napi_status
2915,100995,napi_detach_arraybuffer,1,napi_detach_arraybuffer,"napi_status napi_detach_arraybuffer (napi_env,napi_value)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_detach_arraybuffer(napi_env env,
                                               napi_value arraybuffer) {
  CHECK_ENV(env);
  CHECK_ARG(env, arraybuffer);

  v8::Local<v8::Value> value = v8impl::V8LocalValueFromJsValue(arraybuffer);
  RETURN_STATUS_IF_FALSE(
      env, value->IsArrayBuffer(), napi_arraybuffer_expected);

  v8::Local<v8::ArrayBuffer> it = value.As<v8::ArrayBuffer>();
  RETURN_STATUS_IF_FALSE(
      env, it->IsDetachable(), napi_detachable_arraybuffer_expected);

  it->Detach(v8::Local<v8::Value>()).Check();

  return napi_clear_last_error(env);
}",3190.0,3206.0,1.0,12.0,17.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,napi_status
2916,101001,napi_is_detached_arraybuffer,1,napi_is_detached_arraybuffer,"napi_status napi_is_detached_arraybuffer (napi_env,napi_value,bool*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_is_detached_arraybuffer(napi_env env,
                                                    napi_value arraybuffer,
                                                    bool* result) {
  CHECK_ENV(env);
  CHECK_ARG(env, arraybuffer);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> value = v8impl::V8LocalValueFromJsValue(arraybuffer);

  *result =
      value->IsArrayBuffer() && value.As<v8::ArrayBuffer>()->WasDetached();

  return napi_clear_last_error(env);
}",3208.0,3221.0,1.0,12.0,14.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,napi_status
2917,101008,napi_type_tag_object,1,napi_type_tag_object,"napi_status napi_type_tag_object (napi_env,napi_value,napi_type_tag*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_type_tag_object(napi_env env,
                                            napi_value object,
                                            const napi_type_tag* type_tag) {
  NAPI_PREAMBLE(env);
  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Object> obj;
  CHECK_TO_OBJECT_WITH_PREAMBLE(env, context, obj, object);
  CHECK_ARG_WITH_PREAMBLE(env, type_tag);

  auto key = NAPI_PRIVATE_KEY(context, type_tag);
  auto maybe_has = obj->HasPrivate(context, key);
  CHECK_MAYBE_NOTHING_WITH_PREAMBLE(env, maybe_has, napi_generic_failure);
  RETURN_STATUS_IF_FALSE_WITH_PREAMBLE(
      env, !maybe_has.FromJust(), napi_invalid_arg);

  auto tag = v8::BigInt::NewFromWords(
      context, 0, 2, reinterpret_cast<const uint64_t*>(type_tag));
  CHECK_MAYBE_EMPTY_WITH_PREAMBLE(env, tag, napi_generic_failure);

  auto maybe_set = obj->SetPrivate(context, key, tag.ToLocalChecked());
  CHECK_MAYBE_NOTHING_WITH_PREAMBLE(env, maybe_set, napi_generic_failure);
  RE...",2343.0,2368.0,1.0,12.0,26.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,napi_status
2918,101015,napi_check_object_type_tag,1,napi_check_object_type_tag,"napi_status napi_check_object_type_tag (napi_env,napi_value,napi_type_tag*,bool*)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_check_object_type_tag(napi_env env,
                                                  napi_value object,
                                                  const napi_type_tag* type_tag,
                                                  bool* result) {
  NAPI_PREAMBLE(env);
  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Object> obj;
  CHECK_TO_OBJECT_WITH_PREAMBLE(env, context, obj, object);
  CHECK_ARG_WITH_PREAMBLE(env, type_tag);
  CHECK_ARG_WITH_PREAMBLE(env, result);

  auto maybe_value =
      obj->GetPrivate(context, NAPI_PRIVATE_KEY(context, type_tag));
  CHECK_MAYBE_EMPTY_WITH_PREAMBLE(env, maybe_value, napi_generic_failure);
  v8::Local<v8::Value> val = maybe_value.ToLocalChecked();

  // We consider the type check to have failed unless we reach the line below
  // where we set whether the type check succeeded or not based on the
  // comparison of the two type tags.
  *result = false;
  if (val->IsBigInt()) {
    int sign;
  ...",2370.0,2409.0,1.0,12.0,40.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,napi_status
2919,101023,napi_object_freeze,1,napi_object_freeze,"napi_status napi_object_freeze (napi_env,napi_value)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_object_freeze(napi_env env, napi_value object) {
  NAPI_PREAMBLE(env);

  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Object> obj;

  CHECK_TO_OBJECT(env, context, obj, object);

  v8::Maybe<bool> set_frozen =
      obj->SetIntegrityLevel(context, v8::IntegrityLevel::kFrozen);

  RETURN_STATUS_IF_FALSE_WITH_PREAMBLE(
      env, set_frozen.FromMaybe(false), napi_generic_failure);

  return GET_RETURN_STATUS(env);
}",1262.0,1277.0,1.0,12.0,16.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,napi_status
2920,101029,napi_object_seal,1,napi_object_seal,"napi_status napi_object_seal (napi_env,napi_value)",js_native_api_v8.cc,"napi_status NAPI_CDECL napi_object_seal(napi_env env, napi_value object) {
  NAPI_PREAMBLE(env);

  v8::Local<v8::Context> context = env->context();
  v8::Local<v8::Object> obj;

  CHECK_TO_OBJECT(env, context, obj, object);

  v8::Maybe<bool> set_sealed =
      obj->SetIntegrityLevel(context, v8::IntegrityLevel::kSealed);

  RETURN_STATUS_IF_FALSE_WITH_PREAMBLE(
      env, set_sealed.FromMaybe(false), napi_generic_failure);

  return GET_RETURN_STATUS(env);
}",1279.0,1294.0,1.0,12.0,16.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,napi_status
2921,101142,napi_callback,1,napi_callback,"napi_value napi_callback (napi_env,napi_callback_info)",js_native_api_types.hpp,"typedef napi_value(NAPI_CDECL* napi_callback)(napi_env env,
                                              napi_callback_info info);",112.0,113.0,19.0,19.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,napi_value
2922,101148,napi_finalize,1,napi_finalize,"void napi_finalize (napi_env,void*,void*)",js_native_api_types.hpp,"typedef void(NAPI_CDECL* napi_finalize)(napi_env env,
                                        void* finalize_data,
                                        void* finalize_hint);",114.0,116.0,13.0,13.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,void
2923,101172,<lambda>0,1,v8impl.anonymous_namespace_34.CallbackWrapperBase.InvokeCallback.<lambda>0,ANY v8impl.anonymous_namespace_34.CallbackWrapperBase.InvokeCallback.<lambda>0 (napi_env),js_native_api_v8.cc,"[&](napi_env env) { result = cb(env, cbinfo_wrapper); }",314.0,314.0,25.0,79.0,1.0,1,1,3,3,0,0,1,1,0,0,,0,0,2,1,1,ANY
2924,101187,<lambda>1,1,v8impl.anonymous_namespace_35.CallbackWrapperBase.InvokeCallback.<lambda>1,"ANY v8impl.anonymous_namespace_35.CallbackWrapperBase.InvokeCallback.<lambda>1 (napi_env,ANY)",js_native_api_v8.cc,"[&](napi_env env, v8::Local<v8::Value> value) {
                          exceptionOccurred = true;
                          if (env->terminatedOrTerminating()) {
                            return;
                          }
                          env->isolate->ThrowException(value);
                        }",315.0,321.0,25.0,25.0,7.0,4,2,4,3,0,0,2,2,0,0,,0,0,4,2,2,ANY
2925,101232,V8NameFromPropertyDescriptor,1,v8impl.anonymous_namespace_1.V8NameFromPropertyDescriptor,"napi_status v8impl.anonymous_namespace_1.V8NameFromPropertyDescriptor (napi_env,napi_property_descriptor*,ANY*)",js_native_api_v8.cc,"inline napi_status V8NameFromPropertyDescriptor(
    napi_env env,
    const napi_property_descriptor* p,
    v8::Local<v8::Name>* result) {
  if (p->utf8name != nullptr) {
    CHECK_NEW_FROM_UTF8(env, *result, p->utf8name);
  } else {
    v8::Local<v8::Value> property_value =
        v8impl::V8LocalValueFromJsValue(p->name);

    RETURN_STATUS_IF_FALSE(env, property_value->IsName(), napi_name_expected);
    *result = property_value.As<v8::Name>();
  }

  return napi_ok;
}",64.0,79.0,1.0,4.0,16.0,28,11,28,10,0,7,2,2,1,3,,0,4,6,3,3,napi_status
2926,101393,V8PropertyAttributesFromDescriptor,1,v8impl.anonymous_namespace_2.V8PropertyAttributesFromDescriptor,PropertyAttribute v8impl.anonymous_namespace_2.V8PropertyAttributesFromDescriptor (napi_property_descriptor*),js_native_api_v8.cc,"inline v8::PropertyAttribute V8PropertyAttributesFromDescriptor(
    const napi_property_descriptor* descriptor) {
  unsigned int attribute_flags = v8::PropertyAttribute::None;

  // The napi_writable attribute is ignored for accessor descriptors, but
  // V8 would throw `TypeError`s on assignment with nonexistence of a setter.
  if ((descriptor->getter == nullptr && descriptor->setter == nullptr) &&
      (descriptor->attributes & napi_writable) == 0) {
    attribute_flags |= v8::PropertyAttribute::ReadOnly;
  }

  if ((descriptor->attributes & napi_enumerable) == 0) {
    attribute_flags |= v8::PropertyAttribute::DontEnum;
  }
  if ((descriptor->attributes & napi_configurable) == 0) {
    attribute_flags |= v8::PropertyAttribute::DontDelete;
  }

  return static_cast<v8::PropertyAttribute>(attribute_flags);
}",82.0,101.0,1.0,1.0,20.0,25,7,21,7,0,5,4,4,5,0,,0,5,2,1,1,PropertyAttribute
2927,101470,JsDeferredFromNodePersistent,1,v8impl.anonymous_namespace_3.JsDeferredFromNodePersistent,napi_deferred v8impl.anonymous_namespace_3.JsDeferredFromNodePersistent (ANY*),js_native_api_v8.cc,"inline napi_deferred JsDeferredFromNodePersistent(
    v8impl::Persistent<v8::Value>* local) {
  return reinterpret_cast<napi_deferred>(local);
}",103.0,106.0,1.0,1.0,4.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,napi_deferred
2928,101479,NodePersistentFromJsDeferred,1,v8impl.anonymous_namespace_4.NodePersistentFromJsDeferred,Persistent<v8::Value> v8impl.anonymous_namespace_4.NodePersistentFromJsDeferred (napi_deferred),js_native_api_v8.cc,"inline v8impl::Persistent<v8::Value>* NodePersistentFromJsDeferred(
    napi_deferred local) {
  return reinterpret_cast<v8impl::Persistent<v8::Value>*>(local);
}",108.0,111.0,1.0,1.0,4.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,Persistent<v8.Value>
2929,101489,HandleScopeWrapper,1,v8impl.anonymous_namespace_6.HandleScopeWrapper.HandleScopeWrapper,ANY v8impl.anonymous_namespace_6.HandleScopeWrapper.HandleScopeWrapper (ANY*),js_native_api_v8.cc,explicit HandleScopeWrapper(v8::Isolate* isolate) : scope(isolate) {},115.0,115.0,3.0,71.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
2930,101496,EscapableHandleScopeWrapper,1,v8impl.anonymous_namespace_8.EscapableHandleScopeWrapper.EscapableHandleScopeWrapper,ANY v8impl.anonymous_namespace_8.EscapableHandleScopeWrapper.EscapableHandleScopeWrapper (ANY*),js_native_api_v8.cc,"explicit EscapableHandleScopeWrapper(v8::Isolate* isolate)
      : scope(isolate), escape_called_(false) {}",128.0,129.0,3.0,48.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
2931,101501,escape_called,1,v8impl.anonymous_namespace_9.EscapableHandleScopeWrapper.escape_called,bool v8impl.anonymous_namespace_9.EscapableHandleScopeWrapper.escape_called (),js_native_api_v8.cc,bool escape_called() const { return escape_called_; },130.0,130.0,3.0,55.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,bool
2932,101507,Escape,1,v8impl.anonymous_namespace_10.EscapableHandleScopeWrapper.Escape,Local<T> v8impl.anonymous_namespace_10.EscapableHandleScopeWrapper.Escape<T> (ANY),js_native_api_v8.cc,"v8::Local<T> Escape(v8::Local<T> handle) {
    escape_called_ = true;
    return scope.Escape(handle);
  }",132.0,135.0,3.0,3.0,4.0,2,2,3,3,0,2,1,1,0,0,,0,2,2,1,1,Local<T>
2933,101523,JsHandleScopeFromV8HandleScope,1,v8impl.anonymous_namespace_11.JsHandleScopeFromV8HandleScope,napi_handle_scope v8impl.anonymous_namespace_11.JsHandleScopeFromV8HandleScope (HandleScopeWrapper*),js_native_api_v8.cc,"inline napi_handle_scope JsHandleScopeFromV8HandleScope(HandleScopeWrapper* s) {
  return reinterpret_cast<napi_handle_scope>(s);
}",142.0,144.0,1.0,1.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,napi_handle_scope
2934,101532,V8HandleScopeFromJsHandleScope,1,v8impl.anonymous_namespace_12.V8HandleScopeFromJsHandleScope,HandleScopeWrapper v8impl.anonymous_namespace_12.V8HandleScopeFromJsHandleScope (napi_handle_scope),js_native_api_v8.cc,"inline HandleScopeWrapper* V8HandleScopeFromJsHandleScope(napi_handle_scope s) {
  return reinterpret_cast<HandleScopeWrapper*>(s);
}",146.0,148.0,1.0,1.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,HandleScopeWrapper
2935,101541,JsEscapableHandleScopeFromV8EscapableHandleScope,1,v8impl.anonymous_namespace_13.JsEscapableHandleScopeFromV8EscapableHandleScope,napi_escapable_handle_scope v8impl.anonymous_namespace_13.JsEscapableHandleScopeFromV8EscapableHandleScope (EscapableHandleScopeWrapper*),js_native_api_v8.cc,"inline napi_escapable_handle_scope
JsEscapableHandleScopeFromV8EscapableHandleScope(
    EscapableHandleScopeWrapper* s) {
  return reinterpret_cast<napi_escapable_handle_scope>(s);
}",150.0,154.0,1.0,1.0,5.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,napi_escapable_handle_scope
2936,101550,V8EscapableHandleScopeFromJsEscapableHandleScope,1,v8impl.anonymous_namespace_14.V8EscapableHandleScopeFromJsEscapableHandleScope,EscapableHandleScopeWrapper v8impl.anonymous_namespace_14.V8EscapableHandleScopeFromJsEscapableHandleScope (napi_escapable_handle_scope),js_native_api_v8.cc,"inline EscapableHandleScopeWrapper*
V8EscapableHandleScopeFromJsEscapableHandleScope(
    napi_escapable_handle_scope s) {
  return reinterpret_cast<EscapableHandleScopeWrapper*>(s);
}",156.0,160.0,1.0,1.0,5.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,EscapableHandleScopeWrapper
2937,101559,ConcludeDeferred,1,v8impl.anonymous_namespace_15.ConcludeDeferred,"napi_status v8impl.anonymous_namespace_15.ConcludeDeferred (napi_env,napi_deferred,napi_value,bool)",js_native_api_v8.cc,"inline napi_status ConcludeDeferred(napi_env env,
                                    napi_deferred deferred,
                                    napi_value result,
                                    bool is_resolved) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);

  v8::Local<v8::Context> context = env->context();
  v8impl::Persistent<v8::Value>* deferred_ref =
      NodePersistentFromJsDeferred(deferred);
  v8::Local<v8::Value> v8_deferred =
      v8::Local<v8::Value>::New(env->isolate, *deferred_ref);

  auto v8_resolver = v8_deferred.As<v8::Promise::Resolver>();

  v8::Maybe<bool> success =
      is_resolved ? v8_resolver->Resolve(
                        context, v8impl::V8LocalValueFromJsValue(result))
                  : v8_resolver->Reject(
                        context, v8impl::V8LocalValueFromJsValue(result));

  delete deferred_ref;

  RETURN_STATUS_IF_FALSE(env, success.FromMaybe(false), napi_generic_failure);

  return GET_RETURN_STATUS(env);
}",162.0,188.0,1.0,2.0,27.0,42,12,51,16,0,7,3,4,0,7,,0,2,8,4,4,napi_status
2938,101744,Unwrap,1,v8impl.anonymous_namespace_18.Unwrap,"napi_status v8impl.anonymous_namespace_18.Unwrap (napi_env,napi_value,void**,UnwrapAction)",js_native_api_v8.cc,"inline napi_status Unwrap(napi_env env,
                          napi_value js_object,
                          void** result,
                          UnwrapAction action) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, js_object);
  if (action == KeepWrap) {
    CHECK_ARG(env, result);
  }

  v8::Local<v8::Context> context = env->context();

  v8::Local<v8::Value> value = v8impl::V8LocalValueFromJsValue(js_object);
  RETURN_STATUS_IF_FALSE(env, value->IsObject(), napi_invalid_arg);
  v8::Local<v8::Object> obj = value.As<v8::Object>();

  auto val = obj->GetPrivate(context, NAPI_PRIVATE_KEY(context, wrapper))
                 .ToLocalChecked();
  RETURN_STATUS_IF_FALSE(env, val->IsExternal(), napi_invalid_arg);
  Reference* reference =
      static_cast<v8impl::Reference*>(val.As<v8::External>()->Value());

  if (result) {
    *result = reference->Data();
  }

  if (action == RemoveWrap) {
    CHECK(obj->DeletePrivate(context, NAPI_PRIVATE_KEY(context, wrapper))
              .FromJust...",192.0,230.0,1.0,2.0,39.0,61,12,74,19,0,9,7,9,1,8,,0,2,8,4,4,napi_status
2939,102023,New,1,v8impl.anonymous_namespace_20.CallbackBundle.New,"Local<v8::Value> v8impl.anonymous_namespace_20.CallbackBundle.New (napi_env,napi_callback,void*)",js_native_api_v8.cc,"static inline v8::Local<v8::Value> New(napi_env env,
                                         napi_callback cb,
                                         void* data) {
    CallbackBundle* bundle = new CallbackBundle();
    bundle->cb = cb;
    bundle->cb_data = data;
    bundle->env = env;

    v8::Local<v8::Value> cbdata = v8::External::New(env->isolate, bundle);
    Reference::New(
        env, cbdata, 0, Ownership::kRuntime, Delete, bundle, nullptr);
    return cbdata;
  }",244.0,256.0,3.0,3.0,13.0,18,6,21,10,0,4,1,1,0,0,,0,4,6,3,3,Local<v8.Value>
2940,102088,Delete,1,v8impl.anonymous_namespace_22.CallbackBundle.Delete,"void v8impl.anonymous_namespace_22.CallbackBundle.Delete (napi_env,void*,void*)",js_native_api_v8.cc,"static void Delete(napi_env env, void* data, void* hint) {
    CallbackBundle* bundle = static_cast<CallbackBundle*>(data);
    delete bundle;
  }",262.0,265.0,3.0,3.0,4.0,3,3,3,2,0,0,1,1,0,0,,0,0,6,3,3,void
2941,102104,CallbackWrapper,1,v8impl.anonymous_namespace_24.CallbackWrapper.CallbackWrapper,"ANY v8impl.anonymous_namespace_24.CallbackWrapper.CallbackWrapper (napi_value,size_t,void*)",js_native_api_v8.cc,"inline CallbackWrapper(napi_value this_arg, size_t args_length, void* data)
      : _this(this_arg), _args_length(args_length), _data(data) {}",272.0,273.0,3.0,66.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,ANY
2942,102111,GetNewTarget,1,v8impl.anonymous_namespace_25.CallbackWrapper.GetNewTarget,napi_value v8impl.anonymous_namespace_25.CallbackWrapper.GetNewTarget (),js_native_api_v8.cc,virtual napi_value GetNewTarget() = 0;,275.0,275.0,22.0,39.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,napi_value
2943,102115,Args,1,v8impl.anonymous_namespace_26.CallbackWrapper.Args,"void v8impl.anonymous_namespace_26.CallbackWrapper.Args (napi_value*,size_t)",js_native_api_v8.cc,"virtual void Args(napi_value* buffer, size_t bufferlength) = 0;",276.0,276.0,16.0,64.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
2944,102121,SetReturnValue,1,v8impl.anonymous_namespace_27.CallbackWrapper.SetReturnValue,void v8impl.anonymous_namespace_27.CallbackWrapper.SetReturnValue (napi_value),js_native_api_v8.cc,virtual void SetReturnValue(napi_value value) = 0;,277.0,277.0,16.0,51.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
2945,102126,This,1,v8impl.anonymous_namespace_28.CallbackWrapper.This,napi_value v8impl.anonymous_namespace_28.CallbackWrapper.This (),js_native_api_v8.cc,napi_value This() { return _this; },279.0,279.0,3.0,37.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,napi_value
2946,102132,ArgsLength,1,v8impl.anonymous_namespace_29.CallbackWrapper.ArgsLength,size_t v8impl.anonymous_namespace_29.CallbackWrapper.ArgsLength (),js_native_api_v8.cc,size_t ArgsLength() { return _args_length; },281.0,281.0,3.0,46.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,size_t
2947,102138,Data,1,v8impl.anonymous_namespace_30.CallbackWrapper.Data,void* v8impl.anonymous_namespace_30.CallbackWrapper.Data (),js_native_api_v8.cc,void* Data() { return _data; },283.0,283.0,3.0,32.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,void*
2948,102147,CallbackWrapperBase,1,v8impl.anonymous_namespace_32.CallbackWrapperBase.CallbackWrapperBase,"ANY v8impl.anonymous_namespace_32.CallbackWrapperBase.CallbackWrapperBase (ANY,size_t)",js_native_api_v8.cc,"inline CallbackWrapperBase(const v8::FunctionCallbackInfo<v8::Value>& cbinfo,
                             const size_t args_length)
      : CallbackWrapper(
            JsValueFromV8LocalValue(cbinfo.This()), args_length, nullptr),
        _cbinfo(cbinfo) {
    _bundle = reinterpret_cast<CallbackBundle*>(
        cbinfo.Data().As<v8::External>()->Value());
    _data = _bundle->cb_data;
  }",293.0,301.0,3.0,3.0,9.0,7,4,4,3,0,2,1,1,0,0,,0,2,4,2,2,ANY
2949,102172,InvokeCallback,1,v8impl.anonymous_namespace_33.CallbackWrapperBase.InvokeCallback,void v8impl.anonymous_namespace_33.CallbackWrapperBase.InvokeCallback (),js_native_api_v8.cc,"inline void InvokeCallback() {
    napi_callback_info cbinfo_wrapper = reinterpret_cast<napi_callback_info>(
        static_cast<CallbackWrapper*>(this));

    // All other pointers we need are stored in `_bundle`
    napi_env env = _bundle->env;
    napi_callback cb = _bundle->cb;

    napi_value result = nullptr;
    bool exceptionOccurred = false;
    env->CallIntoModule([&](napi_env env) { result = cb(env, cbinfo_wrapper); },
                        [&](napi_env env, v8::Local<v8::Value> value) {
                          exceptionOccurred = true;
                          if (env->terminatedOrTerminating()) {
                            return;
                          }
                          env->isolate->ThrowException(value);
                        });

    if (!exceptionOccurred && (result != nullptr)) {
      this->SetReturnValue(result);
    }
  }",304.0,326.0,3.0,3.0,23.0,14,6,11,6,0,2,2,2,0,0,,0,2,0,0,0,void
2950,102222,Invoke,1,v8impl.anonymous_namespace_37.FunctionCallbackWrapper.Invoke,void v8impl.anonymous_namespace_37.FunctionCallbackWrapper.Invoke (ANY),js_native_api_v8.cc,"static void Invoke(const v8::FunctionCallbackInfo<v8::Value>& info) {
    FunctionCallbackWrapper cbwrapper(info);
    cbwrapper.InvokeCallback();
  }",334.0,337.0,3.0,3.0,4.0,1,1,2,2,0,0,1,1,0,0,,0,0,2,1,1,void
2951,102234,NewFunction,1,v8impl.anonymous_namespace_38.FunctionCallbackWrapper.NewFunction,"napi_status v8impl.anonymous_namespace_38.FunctionCallbackWrapper.NewFunction (napi_env,napi_callback,void*,ANY*)",js_native_api_v8.cc,"static inline napi_status NewFunction(napi_env env,
                                        napi_callback cb,
                                        void* cb_data,
                                        v8::Local<v8::Function>* result) {
    v8::Local<v8::Value> cbdata = v8impl::CallbackBundle::New(env, cb, cb_data);
    RETURN_STATUS_IF_FALSE(env, !cbdata.IsEmpty(), napi_generic_failure);

    v8::MaybeLocal<v8::Function> maybe_function =
        v8::Function::New(env->context(), Invoke, cbdata);
    CHECK_MAYBE_EMPTY(env, maybe_function, napi_generic_failure);

    *result = maybe_function.ToLocalChecked();
    return napi_clear_last_error(env);
  }",339.0,352.0,3.0,4.0,14.0,26,7,30,11,0,3,1,1,0,3,,0,0,8,4,4,napi_status
2952,102337,NewTemplate,1,v8impl.anonymous_namespace_41.FunctionCallbackWrapper.NewTemplate,"napi_status v8impl.anonymous_namespace_41.FunctionCallbackWrapper.NewTemplate (napi_env,napi_callback,void*,ANY*,ANY)",js_native_api_v8.cc,"static inline napi_status NewTemplate(
      napi_env env,
      napi_callback cb,
      void* cb_data,
      v8::Local<v8::FunctionTemplate>* result,
      v8::Local<v8::Signature> sig = v8::Local<v8::Signature>()) {
    v8::Local<v8::Value> cbdata = v8impl::CallbackBundle::New(env, cb, cb_data);
    RETURN_STATUS_IF_FALSE(env, !cbdata.IsEmpty(), napi_generic_failure);

    *result = v8::FunctionTemplate::New(env->isolate, Invoke, cbdata, sig);
    return napi_clear_last_error(env);
  }",354.0,365.0,3.0,4.0,12.0,17,7,21,11,0,2,1,1,0,2,,0,0,10,5,5,napi_status
2953,102407,FunctionCallbackWrapper,1,v8impl.anonymous_namespace_44.FunctionCallbackWrapper.FunctionCallbackWrapper,ANY v8impl.anonymous_namespace_44.FunctionCallbackWrapper.FunctionCallbackWrapper (ANY),js_native_api_v8.cc,"explicit FunctionCallbackWrapper(
      const v8::FunctionCallbackInfo<v8::Value>& cbinfo)
      : CallbackWrapperBase(cbinfo, cbinfo.Length()) {}",367.0,369.0,3.0,55.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
2954,102412,GetNewTarget,1,v8impl.anonymous_namespace_45.FunctionCallbackWrapper.GetNewTarget,napi_value v8impl.anonymous_namespace_45.FunctionCallbackWrapper.GetNewTarget (),js_native_api_v8.cc,"napi_value GetNewTarget() override {
    if (_cbinfo.IsConstructCall()) {
      return v8impl::JsValueFromV8LocalValue(_cbinfo.NewTarget());
    } else {
      return nullptr;
    }
  }",371.0,377.0,3.0,3.0,7.0,3,1,3,2,0,1,2,2,0,1,,0,0,0,0,0,napi_value
2955,102435,Args,1,v8impl.anonymous_namespace_46.FunctionCallbackWrapper.Args,"void v8impl.anonymous_namespace_46.FunctionCallbackWrapper.Args (napi_value*,size_t)",js_native_api_v8.cc,"void Args(napi_value* buffer, size_t buffer_length) override {
    size_t i = 0;
    size_t min = std::min(buffer_length, _args_length);

    for (; i < min; i += 1) {
      buffer[i] = v8impl::JsValueFromV8LocalValue(_cbinfo[i]);
    }

    if (i < buffer_length) {
      napi_value undefined =
          v8impl::JsValueFromV8LocalValue(v8::Undefined(_cbinfo.GetIsolate()));
      for (; i < buffer_length; i += 1) {
        buffer[i] = undefined;
      }
    }
  }",380.0,395.0,3.0,3.0,16.0,16,4,23,10,0,2,4,5,0,2,,0,2,4,2,2,void
2956,102508,SetReturnValue,1,v8impl.anonymous_namespace_47.FunctionCallbackWrapper.SetReturnValue,void v8impl.anonymous_namespace_47.FunctionCallbackWrapper.SetReturnValue (napi_value),js_native_api_v8.cc,"void SetReturnValue(napi_value value) override {
    v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);
    _cbinfo.GetReturnValue().Set(val);
  }",398.0,401.0,3.0,3.0,4.0,8,4,7,5,0,1,1,1,0,1,,0,1,2,1,1,void
2957,102536,Wrap,1,v8impl.anonymous_namespace_48.Wrap,"napi_status v8impl.anonymous_namespace_48.Wrap (napi_env,napi_value,void*,napi_finalize,void*,napi_ref*)",js_native_api_v8.cc,"inline napi_status Wrap(napi_env env,
                        napi_value js_object,
                        void* native_object,
                        napi_finalize finalize_cb,
                        void* finalize_hint,
                        napi_ref* result) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, js_object);

  v8::Local<v8::Context> context = env->context();

  v8::Local<v8::Value> value = v8impl::V8LocalValueFromJsValue(js_object);
  RETURN_STATUS_IF_FALSE(env, value->IsObject(), napi_invalid_arg);
  v8::Local<v8::Object> obj = value.As<v8::Object>();

  // If we've already wrapped this object, we error out.
  RETURN_STATUS_IF_FALSE(
      env,
      !obj->HasPrivate(context, NAPI_PRIVATE_KEY(context, wrapper)).FromJust(),
      napi_invalid_arg);

  v8impl::Reference* reference = nullptr;
  if (result != nullptr) {
    // The returned reference should be deleted via napi_delete_reference()
    // ONLY in response to the finalize callback invocation. (If it is deleted
  ...",404.0,458.0,1.0,2.0,55.0,59,12,76,21,0,9,4,5,0,9,,0,2,12,6,6,napi_status
2958,102823,CanBeHeldWeakly,1,v8impl.anonymous_namespace_49.CanBeHeldWeakly,bool v8impl.anonymous_namespace_49.CanBeHeldWeakly (ANY),js_native_api_v8.cc,"inline bool CanBeHeldWeakly(v8::Local<v8::Value> value) {
  return value->IsObject() || value->IsSymbol();
}",468.0,470.0,1.0,1.0,3.0,3,2,2,1,0,0,1,1,0,0,,0,0,2,1,1,bool
2959,102838,ResetFinalizer,1,v8impl.Finalizer.ResetFinalizer,void v8impl.Finalizer.ResetFinalizer (),js_native_api_v8.cc,"void Finalizer::ResetFinalizer() {
  finalize_callback_ = nullptr;
  finalize_data_ = nullptr;
  finalize_hint_ = nullptr;
}",474.0,478.0,1.0,1.0,5.0,3,1,3,3,0,3,1,1,0,0,,0,3,0,0,0,void
2960,102851,RefBase,1,v8impl.RefBase.RefBase,"ANY v8impl.RefBase.RefBase (napi_env,uint32_t,Ownership,napi_finalize,void*,void*)",js_native_api_v8.cc,"RefBase::RefBase(napi_env env,
                 uint32_t initial_refcount,
                 Ownership ownership,
                 napi_finalize finalize_callback,
                 void* finalize_data,
                 void* finalize_hint)
    : Finalizer(env, finalize_callback, finalize_data, finalize_hint),
      refcount_(initial_refcount),
      ownership_(ownership) {
  Link(finalize_callback == nullptr ? &env->reflist : &env->finalizing_reflist);
}",481.0,491.0,1.0,1.0,11.0,6,4,3,2,0,0,1,1,0,0,,0,0,12,6,6,ANY
2961,102874,~RefBase,1,v8impl.RefBase.~RefBase,ANY v8impl.RefBase.~RefBase (),js_native_api_v8.cc,"RefBase::~RefBase() {
  // Remove from the env's tracked list.
  Unlink();
  // Try to remove the finalizer from the scheduled second pass callback.
  env_->DequeueFinalizer(this);
}",495.0,500.0,1.0,1.0,6.0,1,1,1,1,0,1,1,1,0,1,,0,0,0,0,0,ANY
2962,102884,New,1,v8impl.RefBase.New,"RefBase v8impl.RefBase.New (napi_env,uint32_t,Ownership,napi_finalize,void*,void*)",js_native_api_v8.cc,"RefBase* RefBase::New(napi_env env,
                      uint32_t initial_refcount,
                      Ownership ownership,
                      napi_finalize finalize_callback,
                      void* finalize_data,
                      void* finalize_hint) {
  return new RefBase(env,
                     initial_refcount,
                     ownership,
                     finalize_callback,
                     finalize_data,
                     finalize_hint);
}",502.0,514.0,1.0,1.0,13.0,1,1,7,7,0,0,1,1,0,0,,0,0,12,6,6,RefBase
2963,102903,Data,1,v8impl.RefBase.Data,void* v8impl.RefBase.Data (),js_native_api_v8.cc,"void* RefBase::Data() {
  return finalize_data_;
}",516.0,518.0,1.0,1.0,3.0,0,0,1,1,0,0,1,1,0,0,,0,0,0,0,0,void*
2964,102909,Ref,1,v8impl.RefBase.Ref,uint32_t v8impl.RefBase.Ref (),js_native_api_v8.cc,"uint32_t RefBase::Ref() {
  return ++refcount_;
}",520.0,522.0,1.0,1.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,uint32_t
2965,102916,Unref,1,v8impl.RefBase.Unref,uint32_t v8impl.RefBase.Unref (),js_native_api_v8.cc,"uint32_t RefBase::Unref() {
  if (refcount_ == 0) {
    return 0;
  }
  return --refcount_;
}",524.0,529.0,1.0,1.0,6.0,2,2,2,1,0,2,2,2,1,0,,0,2,0,0,0,uint32_t
2966,102930,RefCount,1,v8impl.RefBase.RefCount,uint32_t v8impl.RefBase.RefCount (),js_native_api_v8.cc,"uint32_t RefBase::RefCount() {
  return refcount_;
}",531.0,533.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,uint32_t
2967,102936,Finalize,1,v8impl.RefBase.Finalize,void v8impl.RefBase.Finalize (),js_native_api_v8.cc,"void RefBase::Finalize() {
  Ownership ownership = ownership_;
  // Swap out the field finalize_callback so that it can not be accidentally
  // called more than once.
  napi_finalize finalize_callback = finalize_callback_;
  void* finalize_data = finalize_data_;
  void* finalize_hint = finalize_hint_;
  ResetFinalizer();

  // Either the RefBase is going to be deleted in the finalize_callback or not,
  // it should be removed from the tracked list.
  Unlink();
  // 1. If the finalize_callback is present, it should either delete the
  //    RefBase, or set ownership with Ownership::kRuntime.
  // 2. If the finalizer is not present, the RefBase can be deleted after the
  //    call.
  if (finalize_callback != nullptr) {
    env_->CallFinalizer(finalize_callback, finalize_data, finalize_hint);
    // No access to `this` after finalize_callback is called.
  }

  // If the RefBase is not Ownership::kRuntime, userland code should delete it.
  // Now delete it if it is Ownership::kRuntime...",535.0,561.0,1.0,1.0,27.0,9,6,15,10,0,3,3,3,1,1,,0,2,0,0,0,void
2968,102979,Reference,1,v8impl.Reference.Reference,"ANY v8impl.Reference.Reference<Args> (napi_env,ANY,Args)",js_native_api_v8.cc,"Reference::Reference(napi_env env, v8::Local<v8::Value> value, Args&&... args)
    : RefBase(env, std::forward<Args>(args)...),
      persistent_(env->isolate, value),
      can_be_weak_(CanBeHeldWeakly(value)) {
  if (RefCount() == 0) {
    SetWeak();
  }
}",564.0,571.0,1.0,1.0,8.0,1,1,0,0,0,0,2,2,0,0,,0,0,6,3,3,ANY
2969,102992,~Reference,1,v8impl.Reference.~Reference,ANY v8impl.Reference.~Reference (),js_native_api_v8.cc,"Reference::~Reference() {
  // Reset the handle. And no weak callback will be invoked.
  persistent_.Reset();
}",573.0,576.0,1.0,1.0,4.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,ANY
2970,103000,New,1,v8impl.Reference.New,"Reference v8impl.Reference.New (napi_env,ANY,uint32_t,Ownership,napi_finalize,void*,void*)",js_native_api_v8.cc,"Reference* Reference::New(napi_env env,
                          v8::Local<v8::Value> value,
                          uint32_t initial_refcount,
                          Ownership ownership,
                          napi_finalize finalize_callback,
                          void* finalize_data,
                          void* finalize_hint) {
  return new Reference(env,
                       value,
                       initial_refcount,
                       ownership,
                       finalize_callback,
                       finalize_data,
                       finalize_hint);
}",578.0,592.0,1.0,1.0,15.0,1,1,8,8,1,0,1,1,0,0,,0,0,14,7,7,Reference
2971,103021,Ref,1,v8impl.Reference.Ref,uint32_t v8impl.Reference.Ref (),js_native_api_v8.cc,"uint32_t Reference::Ref() {
  // When the persistent_ is cleared in the WeakCallback, and a second pass
  // callback is pending, return 0 unconditionally.
  if (persistent_.IsEmpty()) {
    return 0;
  }
  uint32_t refcount = RefBase::Ref();
  if (refcount == 1 && can_be_weak_) {
    persistent_.ClearWeak();
  }
  return refcount;
}",594.0,605.0,1.0,1.0,12.0,6,4,7,4,0,3,3,3,2,0,,0,3,0,0,0,uint32_t
2972,103053,Unref,1,v8impl.Reference.Unref,uint32_t v8impl.Reference.Unref (),js_native_api_v8.cc,"uint32_t Reference::Unref() {
  // When the persistent_ is cleared in the WeakCallback, and a second pass
  // callback is pending, return 0 unconditionally.
  if (persistent_.IsEmpty()) {
    return 0;
  }
  uint32_t old_refcount = RefCount();
  uint32_t refcount = RefBase::Unref();
  if (old_refcount == 1 && refcount == 0) {
    SetWeak();
  }
  return refcount;
}",607.0,619.0,1.0,1.0,13.0,7,4,7,4,0,1,3,3,1,0,,0,1,0,0,0,uint32_t
2973,103088,Get,1,v8impl.Reference.Get,Local<v8::Value> v8impl.Reference.Get (),js_native_api_v8.cc,"v8::Local<v8::Value> Reference::Get() {
  if (persistent_.IsEmpty()) {
    return v8::Local<v8::Value>();
  } else {
    return v8::Local<v8::Value>::New(env_->isolate, persistent_);
  }
}",621.0,627.0,1.0,1.0,7.0,2,1,2,2,0,1,2,2,1,0,,0,1,0,0,0,Local<v8.Value>
2974,103122,Finalize,1,v8impl.Reference.Finalize,void v8impl.Reference.Finalize (),js_native_api_v8.cc,"void Reference::Finalize() {
  // Unconditionally reset the persistent handle so that no weak callback will
  // be invoked again.
  persistent_.Reset();

  // Chain up to perform the rest of the finalization.
  RefBase::Finalize();
}",629.0,636.0,1.0,1.0,8.0,2,1,2,2,0,1,1,1,0,0,,0,1,0,0,0,void
2975,103134,SetWeak,1,v8impl.Reference.SetWeak,void v8impl.Reference.SetWeak (),js_native_api_v8.cc,"void Reference::SetWeak() {
  if (can_be_weak_) {
    persistent_.SetWeak(this, WeakCallback, v8::WeakCallbackType::kParameter);
  } else {
    persistent_.Reset();
  }
}",640.0,646.0,1.0,1.0,7.0,3,1,5,5,0,2,2,2,1,0,,0,2,0,0,0,void
2976,103158,WeakCallback,1,v8impl.Reference.WeakCallback,void v8impl.Reference.WeakCallback (ANY),js_native_api_v8.cc,"void Reference::WeakCallback(const v8::WeakCallbackInfo<Reference>& data) {
  Reference* reference = data.GetParameter();
  // The reference must be reset during the weak callback as the API protocol.
  reference->persistent_.Reset();
  reference->env_->EnqueueFinalizer(reference);
}",651.0,656.0,1.0,1.0,6.0,6,3,5,2,0,2,1,1,0,1,,0,1,2,1,1,void
2977,110256,node_api_symbol_for,1,node_api_symbol_for,"napi_status node_api_symbol_for (napi_env,char*,size_t,napi_value*)",js_native_api_v8.cc,"napi_status NAPI_CDECL node_api_symbol_for(napi_env env,
                                           const char* utf8description,
                                           size_t length,
                                           napi_value* result) {
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  napi_value js_description_string;
  STATUS_CALL(napi_create_string_utf8(
      env, utf8description, length, &js_description_string));
  v8::Local<v8::String> description_string =
      v8impl::V8LocalValueFromJsValue(js_description_string).As<v8::String>();

  *result = v8impl::JsValueFromV8LocalValue(
      v8::Symbol::For(env->isolate, description_string));

  return napi_clear_last_error(env);
}",1581.0,1598.0,1.0,12.0,18.0,19,10,28,13,0,5,1,1,0,5,,0,3,8,4,4,napi_status
2978,110355,set_error_code,1,set_error_code,"napi_status set_error_code (napi_env,ANY,napi_value,char*)",js_native_api_v8.cc,"static inline napi_status set_error_code(napi_env env,
                                         v8::Local<v8::Value> error,
                                         napi_value code,
                                         const char* code_cstring) {
  if ((code != nullptr) || (code_cstring != nullptr)) {
    v8::Local<v8::Context> context = env->context();
    v8::Local<v8::Object> err_object = error.As<v8::Object>();

    v8::Local<v8::Value> code_value = v8impl::V8LocalValueFromJsValue(code);
    if (code != nullptr) {
      code_value = v8impl::V8LocalValueFromJsValue(code);
      RETURN_STATUS_IF_FALSE(env, code_value->IsString(), napi_string_expected);
    } else {
      CHECK_NEW_FROM_UTF8(env, code_value, code_cstring);
    }

    v8::Local<v8::Name> code_key;
    CHECK_NEW_FROM_UTF8(env, code_key, ""code"");

    v8::Maybe<bool> set_maybe = err_object->Set(context, code_key, code_value);
    RETURN_STATUS_IF_FALSE(
        env, set_maybe.FromMaybe(false), napi_generic_failure...",1600.0,1624.0,1.0,6.0,25.0,57,12,63,19,2,7,3,4,0,7,,0,2,8,4,4,napi_status
2979,111106,node_api_create_syntax_error,1,node_api_create_syntax_error,"napi_status node_api_create_syntax_error (napi_env,napi_value,napi_value,napi_value*)",js_native_api_v8.cc,"napi_status NAPI_CDECL node_api_create_syntax_error(napi_env env,
                                                    napi_value code,
                                                    napi_value msg,
                                                    napi_value* result) {
  CHECK_ENV(env);
  CHECK_ARG(env, msg);
  CHECK_ARG(env, result);

  v8::Local<v8::Value> message_value = v8impl::V8LocalValueFromJsValue(msg);
  RETURN_STATUS_IF_FALSE(env, message_value->IsString(), napi_string_expected);

  v8::Local<v8::Value> error_obj =
      v8::Exception::SyntaxError(message_value.As<v8::String>());
  STATUS_CALL(set_error_code(env, error_obj, code, nullptr));

  *result = v8impl::JsValueFromV8LocalValue(error_obj);

  return napi_clear_last_error(env);
}",1686.0,1704.0,1.0,12.0,19.0,27,9,41,14,0,7,1,1,0,7,,0,3,8,4,4,napi_status
2980,112705,node_api_throw_syntax_error,1,node_api_throw_syntax_error,"napi_status node_api_throw_syntax_error (napi_env,char*,char*)",js_native_api_v8.cc,"napi_status NAPI_CDECL node_api_throw_syntax_error(napi_env env,
                                                   const char* code,
                                                   const char* msg) {
  NAPI_PREAMBLE(env);

  v8::Isolate* isolate = env->isolate;
  v8::Local<v8::String> str;
  CHECK_NEW_FROM_UTF8(env, str, msg);

  v8::Local<v8::Value> error_obj = v8::Exception::SyntaxError(str);
  STATUS_CALL(set_error_code(env, error_obj, nullptr, code));

  isolate->ThrowException(error_obj);
  // any VM calls after this point and before returning
  // to the javascript invoker will fail
  return napi_clear_last_error(env);
}",1924.0,1940.0,1.0,12.0,17.0,43,13,56,18,0,7,3,4,0,7,,0,1,6,3,3,napi_status
2981,121063,<lambda>0,1,napi_env__.CallFinalizer.<lambda>0,ANY napi_env__.CallFinalizer.<lambda>0 (napi_env),js_native_api_v8.hpp,"[&](napi_env env) { cb(env, data, hint); }",105.0,105.0,20.0,61.0,1.0,0,0,3,3,0,0,1,1,0,0,,0,0,2,1,1,ANY
2982,121084,napi_clear_last_error,1,napi_clear_last_error,napi_status napi_clear_last_error (napi_env),js_native_api_v8.hpp,"inline napi_status napi_clear_last_error(napi_env env) {
  env->last_error.error_code = napi_ok;
  env->last_error.engine_error_code = 0;
  env->last_error.engine_reserved = nullptr;
  env->last_error.error_message = nullptr;
  return napi_ok;
}",158.0,164.0,1.0,1.0,7.0,0,0,0,0,31,0,1,1,0,0,,0,0,2,1,1,napi_status
2983,121091,RefTracker,1,v8impl.RefTracker.RefTracker,ANY v8impl.RefTracker.RefTracker (),js_native_api_v8.hpp,RefTracker() {},13.0,13.0,3.0,17.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
2984,121095,~RefTracker,1,v8impl.RefTracker.~RefTracker,ANY v8impl.RefTracker.~RefTracker (),js_native_api_v8.hpp,virtual ~RefTracker() {},14.0,14.0,3.0,26.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
2985,121099,Finalize,1,v8impl.RefTracker.Finalize,void v8impl.RefTracker.Finalize (),js_native_api_v8.hpp,virtual void Finalize() {},15.0,15.0,3.0,28.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
2986,121104,Link,1,v8impl.RefTracker.Link,void v8impl.RefTracker.Link (RefList*),js_native_api_v8.hpp,"inline void Link(RefList* list) {
    prev_ = list;
    next_ = list->next_;
    if (next_ != nullptr) {
      next_->prev_ = this;
    }
    list->next_ = this;
  }",19.0,26.0,3.0,3.0,8.0,8,3,7,3,0,5,2,2,1,0,,0,5,2,1,1,void
2987,121132,Unlink,1,v8impl.RefTracker.Unlink,void v8impl.RefTracker.Unlink (),js_native_api_v8.hpp,"inline void Unlink() {
    if (prev_ != nullptr) {
      prev_->next_ = next_;
    }
    if (next_ != nullptr) {
      next_->prev_ = prev_;
    }
    prev_ = nullptr;
    next_ = nullptr;
  }",28.0,37.0,3.0,3.0,10.0,8,3,8,2,0,10,3,3,2,0,,0,10,0,0,0,void
2988,121162,FinalizeAll,1,v8impl.RefTracker.FinalizeAll,void v8impl.RefTracker.FinalizeAll (RefList*),js_native_api_v8.hpp,"static void FinalizeAll(RefList* list) {
    while (list->next_ != nullptr) {
      list->next_->Finalize();
    }
  }",39.0,43.0,3.0,3.0,5.0,4,2,2,1,2,0,2,2,0,0,,0,0,2,1,1,void
2989,121193,napi_env__,1,napi_env__.napi_env__,"ANY napi_env__.napi_env__ (ANY,int32_t)",js_native_api_v8.hpp,"explicit napi_env__(v8::Local<v8::Context> context,
                      int32_t module_api_version)
      : isolate(context->GetIsolate()),
        context_persistent(isolate, context),
        module_api_version(module_api_version) {
    napi_clear_last_error(this);
  }",54.0,60.0,3.0,3.0,7.0,0,0,0,0,0,1,1,1,0,1,,0,0,4,2,2,ANY
2990,121201,context,1,napi_env__.context,Local<v8::Context> napi_env__.context (),js_native_api_v8.hpp,"inline v8::Local<v8::Context> context() const {
    return v8impl::PersistentToLocal::Strong(context_persistent);
  }",62.0,64.0,3.0,3.0,3.0,2,1,3,3,0,1,1,1,0,0,,0,1,0,0,0,Local<v8.Context>
2991,121213,Ref,1,napi_env__.Ref,void napi_env__.Ref (),js_native_api_v8.hpp,inline void Ref() { refs++; },66.0,66.0,3.0,31.0,1.0,1,1,1,1,1,1,1,1,0,0,,0,1,0,0,0,void
2992,121219,Unref,1,napi_env__.Unref,void napi_env__.Unref (),js_native_api_v8.hpp,"inline void Unref() {
    if (--refs == 0) DeleteMe();
  }",67.0,69.0,3.0,3.0,3.0,2,2,1,1,3,2,2,2,1,0,,0,1,0,0,0,void
2993,121230,can_call_into_js,1,napi_env__.can_call_into_js,bool napi_env__.can_call_into_js (),js_native_api_v8.hpp,virtual bool can_call_into_js() const { return true; },71.0,71.0,3.0,56.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,bool
2994,121236,HandleThrow,1,napi_env__.HandleThrow,"void napi_env__.HandleThrow (napi_env,ANY)",js_native_api_v8.hpp,"static inline void HandleThrow(napi_env env, v8::Local<v8::Value> value) {
    if (env->terminatedOrTerminating()) {
      return;
    }
    env->isolate->ThrowException(value);
  }",73.0,78.0,3.0,3.0,6.0,3,1,3,2,0,0,2,2,0,0,,0,0,4,2,2,void
2995,121256,terminatedOrTerminating,1,napi_env__.terminatedOrTerminating,bool napi_env__.terminatedOrTerminating (),js_native_api_v8.hpp,"inline bool terminatedOrTerminating() {
    return this->isolate->IsExecutionTerminating() || !can_call_into_js();
  }",81.0,83.0,3.0,3.0,3.0,4,3,0,0,0,2,1,1,0,0,,0,1,0,0,0,bool
2996,121270,CallIntoModule,1,napi_env__.CallIntoModule,"void napi_env__.CallIntoModule<T,U> (T,U)",js_native_api_v8.hpp,"inline void CallIntoModule(T&& call, U&& handle_exception = HandleThrow) {
    int open_handle_scopes_before = open_handle_scopes;
    int open_callback_scopes_before = open_callback_scopes;
    napi_clear_last_error(this);
    call(this);
    CHECK_EQ(open_handle_scopes, open_handle_scopes_before);
    CHECK_EQ(open_callback_scopes, open_callback_scopes_before);
    if (!last_exception.IsEmpty()) {
      handle_exception(this, last_exception.Get(this->isolate));
      last_exception.Reset();
    }
  }",89.0,100.0,3.0,3.0,12.0,7,4,11,5,0,9,2,2,1,1,,0,8,4,2,2,void
2997,121314,CallFinalizer,1,napi_env__.CallFinalizer,"void napi_env__.CallFinalizer (napi_finalize,void*,void*)",js_native_api_v8.hpp,"virtual void CallFinalizer(napi_finalize cb, void* data, void* hint) {
    v8::HandleScope handle_scope(isolate);
    CallIntoModule([&](napi_env env) { cb(env, data, hint); });
  }",103.0,106.0,3.0,3.0,4.0,0,0,1,1,1,1,1,1,0,0,,0,1,6,3,3,void
2998,121324,EnqueueFinalizer,1,napi_env__.EnqueueFinalizer,void napi_env__.EnqueueFinalizer (ANY*),js_native_api_v8.hpp,"virtual void EnqueueFinalizer(v8impl::RefTracker* finalizer) {
    pending_finalizers.emplace(finalizer);
  }",112.0,114.0,3.0,3.0,3.0,1,1,2,2,1,1,1,1,0,0,,0,1,2,1,1,void
2999,121334,DequeueFinalizer,1,napi_env__.DequeueFinalizer,void napi_env__.DequeueFinalizer (ANY*),js_native_api_v8.hpp,"virtual void DequeueFinalizer(v8impl::RefTracker* finalizer) {
    pending_finalizers.erase(finalizer);
  }",118.0,120.0,3.0,3.0,3.0,1,1,2,2,1,1,1,1,0,0,,0,1,2,1,1,void
3000,121344,DeleteMe,1,napi_env__.DeleteMe,void napi_env__.DeleteMe (),js_native_api_v8.hpp,"virtual void DeleteMe() {
    // First we must finalize those references that have `napi_finalizer`
    // callbacks. The reason is that addons might store other references which
    // they delete during their `napi_finalizer` callbacks. If we deleted such
    // references here first, they would be doubly deleted when the
    // `napi_finalizer` deleted them subsequently.
    v8impl::RefTracker::FinalizeAll(&finalizing_reflist);
    v8impl::RefTracker::FinalizeAll(&reflist);
    delete this;
  }",122.0,131.0,3.0,3.0,10.0,7,3,6,4,1,4,1,1,0,2,,0,2,0,0,0,void
3001,121378,~napi_env__,1,napi_env__.~napi_env__,ANY napi_env__.~napi_env__ (),js_native_api_v8.hpp,virtual ~napi_env__() = default;,155.0,155.0,3.0,34.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
3002,121438,napi_set_last_error,1,napi_set_last_error,"napi_status napi_set_last_error (napi_env,napi_status,uint32_t,void*)",js_native_api_v8.hpp,"inline napi_status napi_set_last_error(napi_env env,
                                       napi_status error_code,
                                       uint32_t engine_error_code = 0,
                                       void* engine_reserved = nullptr) {
  env->last_error.error_code = error_code;
  env->last_error.engine_error_code = engine_error_code;
  env->last_error.engine_reserved = engine_reserved;
  return error_code;
}",166.0,174.0,1.0,1.0,9.0,9,3,7,4,93,0,1,1,0,0,,0,0,8,4,4,napi_status
3003,121477,JsValueFromV8LocalValue,1,v8impl.JsValueFromV8LocalValue,napi_value v8impl.JsValueFromV8LocalValue (ANY),js_native_api_v8.hpp,"inline napi_value JsValueFromV8LocalValue(v8::Local<v8::Value> local) {
  return reinterpret_cast<napi_value>(*local);
}",294.0,296.0,1.0,1.0,3.0,2,2,1,1,12,0,1,1,0,0,,0,0,2,1,1,napi_value
3004,121487,V8LocalValueFromJsValue,1,v8impl.V8LocalValueFromJsValue,Local<v8::Value> v8impl.V8LocalValueFromJsValue (napi_value),js_native_api_v8.hpp,"inline v8::Local<v8::Value> V8LocalValueFromJsValue(napi_value v) {
  v8::Local<v8::Value> local;
  memcpy(static_cast<void*>(&local), &v, sizeof(v));
  return local;
}",298.0,302.0,1.0,1.0,5.0,8,6,7,3,12,0,1,1,0,0,,0,0,2,1,1,Local<v8.Value>
3005,121513,Finalizer,1,v8impl.Finalizer.Finalizer,"ANY v8impl.Finalizer.Finalizer (napi_env,napi_finalize,void*,void*)",js_native_api_v8.hpp,"Finalizer(napi_env env,
            napi_finalize finalize_callback,
            void* finalize_data,
            void* finalize_hint)
      : env_(env),
        finalize_callback_(finalize_callback),
        finalize_data_(finalize_data),
        finalize_hint_(finalize_hint) {}",307.0,314.0,3.0,40.0,8.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,ANY
3006,121521,~Finalizer,1,v8impl.Finalizer.~Finalizer,ANY v8impl.Finalizer.~Finalizer (),js_native_api_v8.hpp,virtual ~Finalizer() = default;,316.0,316.0,3.0,33.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
3007,121525,New,1,v8impl.Finalizer.New,"Finalizer v8impl.Finalizer.New (napi_env,napi_finalize,void*,void*)",js_native_api_v8.hpp,"static Finalizer* New(napi_env env,
                        napi_finalize finalize_callback = nullptr,
                        void* finalize_data = nullptr,
                        void* finalize_hint = nullptr) {
    return new Finalizer(env, finalize_callback, finalize_data, finalize_hint);
  }",319.0,324.0,3.0,3.0,6.0,1,1,5,5,0,0,1,1,0,0,,0,0,8,4,4,Finalizer
3008,121540,callback,1,v8impl.Finalizer.callback,napi_finalize v8impl.Finalizer.callback (),js_native_api_v8.hpp,napi_finalize callback() { return finalize_callback_; },326.0,326.0,3.0,57.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,napi_finalize
3009,121546,data,1,v8impl.Finalizer.data,void* v8impl.Finalizer.data (),js_native_api_v8.hpp,void* data() { return finalize_data_; },327.0,327.0,3.0,41.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,void*
3010,121552,hint,1,v8impl.Finalizer.hint,void* v8impl.Finalizer.hint (),js_native_api_v8.hpp,void* hint() { return finalize_hint_; },328.0,328.0,3.0,41.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,void*
3011,121567,TryCatch,1,v8impl.TryCatch.TryCatch,ANY v8impl.TryCatch.TryCatch (napi_env),js_native_api_v8.hpp,"explicit TryCatch(napi_env env) : v8::TryCatch(env->isolate), _env(env) {}",341.0,341.0,3.0,76.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
3012,121572,~TryCatch,1,v8impl.TryCatch.~TryCatch,ANY v8impl.TryCatch.~TryCatch (),js_native_api_v8.hpp,"~TryCatch() {
    if (HasCaught()) {
      _env->last_exception.Reset(_env->isolate, Exception());
    }
  }",343.0,347.0,3.0,3.0,5.0,3,2,2,1,0,2,2,2,0,0,,0,2,0,0,0,ANY
3013,121634,ownership,1,v8impl.RefBase.ownership,Ownership v8impl.RefBase.ownership (),js_native_api_v8.hpp,Ownership ownership() { return ownership_; },387.0,387.0,3.0,46.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,Ownership
3014,121732,JSStream,1,node.JSStream.JSStream,"ANY node.JSStream.JSStream (Environment*,Local<Object>)",js_stream.cc,"JSStream::JSStream(Environment* env, Local<Object> obj)
    : AsyncWrap(env, obj, AsyncWrap::PROVIDER_JSSTREAM),
      StreamBase(env) {
  MakeWeak();
  StreamBase::AttachToObject(obj);
}",26.0,31.0,1.0,1.0,6.0,1,1,2,2,0,0,1,1,0,0,,0,0,4,2,2,ANY
3015,121744,GetAsyncWrap,1,node.JSStream.GetAsyncWrap,AsyncWrap node.JSStream.GetAsyncWrap (),js_stream.cc,"AsyncWrap* JSStream::GetAsyncWrap() {
  return static_cast<AsyncWrap*>(this);
}",34.0,36.0,1.0,1.0,3.0,1,1,0,0,0,0,1,1,0,0,,0,0,0,0,0,AsyncWrap
3016,121752,IsAlive,1,node.JSStream.IsAlive,bool node.JSStream.IsAlive (),js_stream.cc,"bool JSStream::IsAlive() {
  return true;
}",39.0,41.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,bool
3017,121758,IsClosing,1,node.JSStream.IsClosing,bool node.JSStream.IsClosing (),js_stream.cc,"bool JSStream::IsClosing() {
  HandleScope scope(env()->isolate());
  Context::Scope context_scope(env()->context());
  TryCatchScope try_catch(env());
  Local<Value> value;
  if (!MakeCallback(env()->isclosing_string(), 0, nullptr).ToLocal(&value)) {
    if (try_catch.HasCaught() && !try_catch.HasTerminated())
      errors::TriggerUncaughtException(env()->isolate(), try_catch);
    return true;
  }
  return value->IsTrue();
}",44.0,55.0,1.0,1.0,12.0,15,7,9,5,0,0,3,4,0,0,,0,0,0,0,0,bool
3018,121825,ReadStart,1,node.JSStream.ReadStart,int node.JSStream.ReadStart (),js_stream.cc,"int JSStream::ReadStart() {
  HandleScope scope(env()->isolate());
  Context::Scope context_scope(env()->context());
  TryCatchScope try_catch(env());
  Local<Value> value;
  int value_int = UV_EPROTO;
  if (!MakeCallback(env()->onreadstart_string(), 0, nullptr).ToLocal(&value) ||
      !value->Int32Value(env()->context()).To(&value_int)) {
    if (try_catch.HasCaught() && !try_catch.HasTerminated())
      errors::TriggerUncaughtException(env()->isolate(), try_catch);
  }
  return value_int;
}",58.0,70.0,1.0,1.0,13.0,21,9,13,7,0,0,3,4,0,0,,0,0,0,0,0,int
3019,121906,ReadStop,1,node.JSStream.ReadStop,int node.JSStream.ReadStop (),js_stream.cc,"int JSStream::ReadStop() {
  HandleScope scope(env()->isolate());
  Context::Scope context_scope(env()->context());
  TryCatchScope try_catch(env());
  Local<Value> value;
  int value_int = UV_EPROTO;
  if (!MakeCallback(env()->onreadstop_string(), 0, nullptr).ToLocal(&value) ||
      !value->Int32Value(env()->context()).To(&value_int)) {
    if (try_catch.HasCaught() && !try_catch.HasTerminated())
      errors::TriggerUncaughtException(env()->isolate(), try_catch);
  }
  return value_int;
}",73.0,85.0,1.0,1.0,13.0,21,9,13,7,0,0,3,4,0,0,,0,0,0,0,0,int
3020,121987,DoShutdown,1,node.JSStream.DoShutdown,int node.JSStream.DoShutdown (ShutdownWrap*),js_stream.cc,"int JSStream::DoShutdown(ShutdownWrap* req_wrap) {
  HandleScope scope(env()->isolate());
  Context::Scope context_scope(env()->context());

  Local<Value> argv[] = {
    req_wrap->object()
  };

  TryCatchScope try_catch(env());
  Local<Value> value;
  int value_int = UV_EPROTO;
  if (!MakeCallback(env()->onshutdown_string(),
                    arraysize(argv),
                    argv).ToLocal(&value) ||
      !value->Int32Value(env()->context()).To(&value_int)) {
    if (try_catch.HasCaught() && !try_catch.HasTerminated())
      errors::TriggerUncaughtException(env()->isolate(), try_catch);
  }
  return value_int;
}",88.0,107.0,1.0,1.0,20.0,24,10,17,9,0,0,3,4,0,0,,0,0,2,1,1,int
3021,122078,DoWrite,1,node.JSStream.DoWrite,"int node.JSStream.DoWrite (WriteWrap*,uv_buf_t*,size_t,uv_stream_t*)",js_stream.cc,"int JSStream::DoWrite(WriteWrap* w,
                      uv_buf_t* bufs,
                      size_t count,
                      uv_stream_t* send_handle) {
  CHECK_NULL(send_handle);

  HandleScope scope(env()->isolate());
  Context::Scope context_scope(env()->context());

  MaybeStackBuffer<Local<Value>, 16> bufs_arr(count);
  for (size_t i = 0; i < count; i++) {
    bufs_arr[i] =
        Buffer::Copy(env(), bufs[i].base, bufs[i].len).ToLocalChecked();
  }

  Local<Value> argv[] = {
    w->object(),
    Array::New(env()->isolate(), bufs_arr.out(), count)
  };

  TryCatchScope try_catch(env());
  Local<Value> value;
  int value_int = UV_EPROTO;
  if (!MakeCallback(env()->onwrite_string(),
                    arraysize(argv),
                    argv).ToLocal(&value) ||
      !value->Int32Value(env()->context()).To(&value_int)) {
    if (try_catch.HasCaught() && !try_catch.HasTerminated())
      errors::TriggerUncaughtException(env()->isolate(), try_catch);
  }
  return value_int;
}",110.0,141.0,1.0,1.0,32.0,37,11,32,16,0,0,4,5,0,0,,0,0,8,4,4,int
3022,122224,New,1,node.JSStream.New,void node.JSStream.New (FunctionCallbackInfo<Value>),js_stream.cc,"void JSStream::New(const FunctionCallbackInfo<Value>& args) {
  // This constructor should not be exposed to public javascript.
  // Therefore we assert that we are not trying to call this as a
  // normal function.
  CHECK(args.IsConstructCall());
  Environment* env = Environment::GetCurrent(args);
  new JSStream(env, args.This());
}",144.0,151.0,1.0,1.0,8.0,5,3,7,4,0,0,1,1,0,0,,0,0,2,1,1,void
3023,122249,Finish,1,node.JSStream.Finish,void node.JSStream.Finish<Wrap> (FunctionCallbackInfo<Value>),js_stream.cc,"void JSStream::Finish(const FunctionCallbackInfo<Value>& args) {
  CHECK(args[0]->IsObject());
  Wrap* w = static_cast<Wrap*>(StreamReq::FromObject(args[0].As<Object>()));

  CHECK(args[1]->IsInt32());
  w->Done(args[1].As<Int32>()->Value());
}",155.0,161.0,1.0,1.0,7.0,13,5,7,3,0,0,1,1,0,0,,0,0,2,1,1,void
3024,122296,ReadBuffer,1,node.JSStream.ReadBuffer,void node.JSStream.ReadBuffer (FunctionCallbackInfo<Value>),js_stream.cc,"void JSStream::ReadBuffer(const FunctionCallbackInfo<Value>& args) {
  JSStream* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  ArrayBufferViewContents<char> buffer(args[0]);
  const char* data = buffer.data();
  int len = buffer.length();

  // Repeatedly ask the stream's owner for memory, copy the data that we
  // just read from JS into those buffers and emit them as reads.
  while (len != 0) {
    uv_buf_t buf = wrap->EmitAlloc(len);
    ssize_t avail = len;
    if (static_cast<ssize_t>(buf.len) < avail)
      avail = buf.len;

    memcpy(buf.base, data, avail);
    data += avail;
    len -= static_cast<int>(avail);
    wrap->EmitRead(avail, buf);
  }
}",164.0,185.0,1.0,1.0,22.0,21,10,27,7,0,0,3,4,0,0,,0,0,2,1,1,void
3025,122379,EmitEOF,1,node.JSStream.EmitEOF,void node.JSStream.EmitEOF (FunctionCallbackInfo<Value>),js_stream.cc,"void JSStream::EmitEOF(const FunctionCallbackInfo<Value>& args) {
  JSStream* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  wrap->EmitRead(UV_EOF);
}",188.0,193.0,1.0,1.0,6.0,3,3,4,3,0,0,1,1,0,0,,0,0,2,1,1,void
3026,122397,Initialize,1,node.JSStream.Initialize,"void node.JSStream.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)",js_stream.cc,"void JSStream::Initialize(Local<Object> target,
                          Local<Value> unused,
                          Local<Context> context,
                          void* priv) {
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, New);
  t->InstanceTemplate()
    ->SetInternalFieldCount(StreamBase::kInternalFieldCount);
  t->Inherit(AsyncWrap::GetConstructorTemplate(env));

  SetProtoMethod(isolate, t, ""finishWrite"", Finish<WriteWrap>);
  SetProtoMethod(isolate, t, ""finishShutdown"", Finish<ShutdownWrap>);
  SetProtoMethod(isolate, t, ""readBuffer"", ReadBuffer);
  SetProtoMethod(isolate, t, ""emitEOF"", EmitEOF);

  StreamBase::AddMethods(env, t);
  SetConstructorFunction(context, target, ""JSStream"", t);
}",196.0,215.0,1.0,1.0,20.0,13,5,33,15,0,0,1,1,0,0,,0,0,8,4,4,void
3027,122506,JSUDPWrap,1,node.JSUDPWrap.JSUDPWrap,"ANY node.JSUDPWrap.JSUDPWrap (Environment*,Local<Object>)",js_udp_wrap.cc,"JSUDPWrap::JSUDPWrap(Environment* env, Local<Object> obj)
  : AsyncWrap(env, obj, PROVIDER_JSUDPWRAP) {
  MakeWeak();

  obj->SetAlignedPointerInInternalField(
      kUDPWrapBaseField, static_cast<UDPWrapBase*>(this));
}",54.0,60.0,1.0,1.0,7.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,ANY
3028,122512,RecvStart,1,node.JSUDPWrap.RecvStart,int node.JSUDPWrap.RecvStart (),js_udp_wrap.cc,"int JSUDPWrap::RecvStart() {
  HandleScope scope(env()->isolate());
  Context::Scope context_scope(env()->context());
  TryCatchScope try_catch(env());
  Local<Value> value;
  int32_t value_int = JS_EXCEPTION_PENDING;
  if (!MakeCallback(env()->onreadstart_string(), 0, nullptr).ToLocal(&value) ||
      !value->Int32Value(env()->context()).To(&value_int)) {
    if (try_catch.HasCaught() && !try_catch.HasTerminated())
      errors::TriggerUncaughtException(env()->isolate(), try_catch);
  }
  return value_int;
}",62.0,74.0,1.0,22.0,13.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,int
3029,122516,RecvStop,1,node.JSUDPWrap.RecvStop,int node.JSUDPWrap.RecvStop (),js_udp_wrap.cc,"int JSUDPWrap::RecvStop() {
  HandleScope scope(env()->isolate());
  Context::Scope context_scope(env()->context());
  TryCatchScope try_catch(env());
  Local<Value> value;
  int32_t value_int = JS_EXCEPTION_PENDING;
  if (!MakeCallback(env()->onreadstop_string(), 0, nullptr).ToLocal(&value) ||
      !value->Int32Value(env()->context()).To(&value_int)) {
    if (try_catch.HasCaught() && !try_catch.HasTerminated())
      errors::TriggerUncaughtException(env()->isolate(), try_catch);
  }
  return value_int;
}",76.0,88.0,1.0,22.0,13.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,int
3030,122520,Send,1,node.JSUDPWrap.Send,"ssize_t node.JSUDPWrap.Send (uv_buf_t*,size_t,sockaddr*)",js_udp_wrap.cc,"ssize_t JSUDPWrap::Send(uv_buf_t* bufs,
                        size_t nbufs,
                        const sockaddr* addr) {
  HandleScope scope(env()->isolate());
  Context::Scope context_scope(env()->context());
  TryCatchScope try_catch(env());
  Local<Value> value;
  int64_t value_int = JS_EXCEPTION_PENDING;
  size_t total_len = 0;

  MaybeStackBuffer<Local<Value>, 16> buffers(nbufs);
  for (size_t i = 0; i < nbufs; i++) {
    buffers[i] = Buffer::Copy(env(), bufs[i].base, bufs[i].len)
        .ToLocalChecked();
    total_len += bufs[i].len;
  }

  Local<Object> address;
  if (!AddressToJS(env(), addr).ToLocal(&address)) return value_int;

  Local<Value> args[] = {
    listener()->CreateSendWrap(total_len)->object(),
    Array::New(env()->isolate(), buffers.out(), nbufs),
    address,
  };

  if (!MakeCallback(env()->onwrite_string(), arraysize(args), args)
          .ToLocal(&value) ||
      !value->IntegerValue(env()->context()).To(&value_int)) {
    if (try_catch.HasCaught()...",90.0,123.0,1.0,22.0,34.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,ssize_t
3031,122527,GetPeerName,1,node.JSUDPWrap.GetPeerName,SocketAddress node.JSUDPWrap.GetPeerName (),js_udp_wrap.cc,"SocketAddress JSUDPWrap::GetPeerName() {
  SocketAddress ret;
  CHECK(SocketAddress::New(AF_INET, ""127.0.0.1"", 1337, &ret));
  return ret;
}",125.0,129.0,1.0,1.0,5.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,SocketAddress
3032,122531,GetSockName,1,node.JSUDPWrap.GetSockName,SocketAddress node.JSUDPWrap.GetSockName (),js_udp_wrap.cc,"SocketAddress JSUDPWrap::GetSockName() {
  SocketAddress ret;
  CHECK(SocketAddress::New(AF_INET, ""127.0.0.1"", 1337, &ret));
  return ret;
}",131.0,135.0,1.0,1.0,5.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,SocketAddress
3033,122535,GetAsyncWrap,1,node.JSUDPWrap.GetAsyncWrap,AsyncWrap node.JSUDPWrap.GetAsyncWrap (),js_udp_wrap.cc,AsyncWrap* GetAsyncWrap() override { return this; },38.0,38.0,3.0,53.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,AsyncWrap
3034,122541,New,1,node.JSUDPWrap.New,void node.JSUDPWrap.New (FunctionCallbackInfo<Value>),js_udp_wrap.cc,"void JSUDPWrap::New(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  CHECK(args.IsConstructCall());
  new JSUDPWrap(env, args.Holder());
}",137.0,141.0,1.0,1.0,5.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
3035,122546,EmitReceived,1,node.JSUDPWrap.EmitReceived,void node.JSUDPWrap.EmitReceived (FunctionCallbackInfo<Value>),js_udp_wrap.cc,"void JSUDPWrap::EmitReceived(const FunctionCallbackInfo<Value>& args) {
  JSUDPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
  Environment* env = wrap->env();

  ArrayBufferViewContents<char> buffer(args[0]);
  const char* data = buffer.data();
  int len = buffer.length();

  CHECK(args[1]->IsInt32());   // family
  CHECK(args[2]->IsString());  // address
  CHECK(args[3]->IsInt32());   // port
  CHECK(args[4]->IsInt32());   // flags
  int family = args[1].As<Int32>()->Value() == 4 ? AF_INET : AF_INET6;
  Utf8Value address(env->isolate(), args[2]);
  int port = args[3].As<Int32>()->Value();
  int flags = args[3].As<Int32>()->Value();

  sockaddr_storage addr;
  CHECK_EQ(sockaddr_for_family(family, *address, port, &addr), 0);

  // Repeatedly ask the stream's owner for memory, copy the data that we
  // just read from JS into those buffers and emit them as reads.
  while (len != 0) {
    uv_buf_t buf = wrap->listener()->OnAlloc(len);
    ssize_t avail = std::min<size_t>...",143.0,175.0,1.0,1.0,33.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
3036,122551,OnSendDone,1,node.JSUDPWrap.OnSendDone,void node.JSUDPWrap.OnSendDone (FunctionCallbackInfo<Value>),js_udp_wrap.cc,"void JSUDPWrap::OnSendDone(const FunctionCallbackInfo<Value>& args) {
  JSUDPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  CHECK(args[0]->IsObject());
  CHECK(args[1]->IsInt32());
  ReqWrap<uv_udp_send_t>* req_wrap;
  ASSIGN_OR_RETURN_UNWRAP(&req_wrap, args[0].As<Object>());
  int status = args[1].As<Int32>()->Value();

  wrap->listener()->OnSendDone(req_wrap, status);
}",177.0,188.0,1.0,1.0,12.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
3037,122556,OnAfterBind,1,node.JSUDPWrap.OnAfterBind,void node.JSUDPWrap.OnAfterBind (FunctionCallbackInfo<Value>),js_udp_wrap.cc,"void JSUDPWrap::OnAfterBind(const FunctionCallbackInfo<Value>& args) {
  JSUDPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  wrap->listener()->OnAfterBind();
}",190.0,195.0,1.0,1.0,6.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
3038,122561,Initialize,1,node.JSUDPWrap.Initialize,"void node.JSUDPWrap.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)",js_udp_wrap.cc,"void JSUDPWrap::Initialize(Local<Object> target,
                           Local<Value> unused,
                           Local<Context> context,
                           void* priv) {
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, New);
  t->InstanceTemplate()
    ->SetInternalFieldCount(UDPWrapBase::kUDPWrapBaseField + 1);
  t->Inherit(AsyncWrap::GetConstructorTemplate(env));

  UDPWrapBase::AddMethods(env, t);
  SetProtoMethod(isolate, t, ""emitReceived"", EmitReceived);
  SetProtoMethod(isolate, t, ""onSendDone"", OnSendDone);
  SetProtoMethod(isolate, t, ""onAfterBind"", OnAfterBind);

  SetConstructorFunction(context, target, ""JSUDPWrap"", t);
}",197.0,215.0,1.0,1.0,19.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,void
3039,123391,FreeIsolate,1,node.JSONParser.FreeIsolate,void node.JSONParser.FreeIsolate (Isolate*),json_parser.cc,"void JSONParser::FreeIsolate(Isolate* isolate) {
  per_process::v8_platform.Platform()->UnregisterIsolate(isolate);
  isolate->Dispose();
}",26.0,29.0,1.0,1.0,4.0,4,2,3,2,0,0,1,1,0,0,,0,0,2,1,1,void
3040,123410,JSONParser,1,node.JSONParser.JSONParser,ANY node.JSONParser.JSONParser (),json_parser.cc,"JSONParser::JSONParser()
    : allocator_(ArrayBuffer::Allocator::NewDefaultAllocator()),
      isolate_(NewIsolate(allocator_.get())),
      handle_scope_(isolate_.get()),
      context_(isolate_.get(), Context::New(isolate_.get())),
      context_scope_(context_.Get(isolate_.get())) {}",31.0,36.0,1.0,53.0,6.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
3041,123414,Parse,1,node.JSONParser.Parse,bool node.JSONParser.Parse (ANY),json_parser.cc,"bool JSONParser::Parse(const std::string& content) {
  DCHECK(!parsed_);

  Isolate* isolate = isolate_.get();
  Local<Context> context = context_.Get(isolate);

  // It's not a real script, so don't print the source line.
  errors::PrinterTryCatch bootstrapCatch(
      isolate, errors::PrinterTryCatch::kDontPrintSourceLine);
  Local<Value> json_string_value;
  Local<Value> result_value;
  if (!ToV8Value(context, content).ToLocal(&json_string_value) ||
      !json_string_value->IsString() ||
      !v8::JSON::Parse(context, json_string_value.As<String>())
           .ToLocal(&result_value) ||
      !result_value->IsObject()) {
    return false;
  }
  content_.Reset(isolate, result_value.As<Object>());
  parsed_ = true;
  return true;
}",38.0,59.0,1.0,1.0,22.0,32,8,31,16,0,0,2,2,0,0,,0,0,2,1,1,bool
3042,123515,GetTopLevelStringField,1,node.JSONParser.GetTopLevelStringField,optional<std::string> node.JSONParser.GetTopLevelStringField (ANY),json_parser.cc,"std::optional<std::string> JSONParser::GetTopLevelStringField(
    std::string_view field) {
  Isolate* isolate = isolate_.get();
  Local<Context> context = context_.Get(isolate);
  Local<Object> content_object = content_.Get(isolate);
  Local<Value> value;
  // It's not a real script, so don't print the source line.
  errors::PrinterTryCatch bootstrapCatch(
      isolate, errors::PrinterTryCatch::kDontPrintSourceLine);
  Local<Value> field_local;
  if (!ToV8Value(context, field, isolate).ToLocal(&field_local)) {
    return {};
  }
  if (!content_object->Get(context, field_local).ToLocal(&value) ||
      !value->IsString()) {
    return {};
  }
  Utf8Value utf8_value(isolate, value);
  return utf8_value.ToString();
}",61.0,80.0,1.0,1.0,20.0,27,8,33,16,0,0,3,3,0,0,,0,0,2,1,1,optional<std.string>
3043,123610,GetTopLevelBoolField,1,node.JSONParser.GetTopLevelBoolField,optional<bool> node.JSONParser.GetTopLevelBoolField (ANY),json_parser.cc,"std::optional<bool> JSONParser::GetTopLevelBoolField(std::string_view field) {
  Isolate* isolate = isolate_.get();
  Local<Context> context = context_.Get(isolate);
  Local<Object> content_object = content_.Get(isolate);
  Local<Value> value;
  bool has_field;
  // It's not a real script, so don't print the source line.
  errors::PrinterTryCatch bootstrapCatch(
      isolate, errors::PrinterTryCatch::kDontPrintSourceLine);
  Local<Value> field_local;
  if (!ToV8Value(context, field, isolate).ToLocal(&field_local)) {
    return {};
  }
  if (!content_object->Has(context, field_local).To(&has_field)) {
    return {};
  }
  if (!has_field) {
    return false;
  }
  if (!content_object->Get(context, field_local).ToLocal(&value) ||
      !value->IsBoolean()) {
    return {};
  }
  return value->BooleanValue(isolate);
}",82.0,106.0,1.0,1.0,25.0,32,8,37,16,0,0,5,5,0,0,,0,0,2,1,1,optional<bool>
3044,123747,EscapeJsonChars,1,node.EscapeJsonChars,string node.EscapeJsonChars (ANY),json_utils.cc,"std::string EscapeJsonChars(std::string_view str) {
  // 'static constexpr' is slightly better than static const
  // since the initialization occurs at compile time.
  // See https://lemire.me/blog/I3Cah
  static constexpr std::string_view control_symbols[0x20] = {
      ""\\u0000"", ""\\u0001"", ""\\u0002"", ""\\u0003"", ""\\u0004"", ""\\u0005"",
      ""\\u0006"", ""\\u0007"", ""\\b"",     ""\\t"",     ""\\n"",     ""\\u000b"",
      ""\\f"",     ""\\r"",     ""\\u000e"", ""\\u000f"", ""\\u0010"", ""\\u0011"",
      ""\\u0012"", ""\\u0013"", ""\\u0014"", ""\\u0015"", ""\\u0016"", ""\\u0017"",
      ""\\u0018"", ""\\u0019"", ""\\u001a"", ""\\u001b"", ""\\u001c"", ""\\u001d"",
      ""\\u001e"", ""\\u001f""};

  std::string ret;
  size_t last_pos = 0;
  size_t pos = 0;
  for (; pos < str.size(); ++pos) {
    std::string replace;
    char ch = str[pos];
    if (ch == '\\') {
      replace = ""\\\\"";
    } else if (ch == '\""') {
      replace = ""\\\"""";
    } else {
      size_t num = static_cast<size_t>(ch);
      if (num < 0x20) replace = control...",5.0,44.0,1.0,1.0,40.0,24,11,30,7,0,0,6,10,0,0,,0,0,2,1,1,string
3045,123901,Reindent,1,node.Reindent,"string node.Reindent (ANY,int)",json_utils.cc,"std::string Reindent(const std::string& str, int indent_depth) {
  if (indent_depth <= 0) return str;
  const std::string indent(indent_depth, ' ');
  std::string out;
  std::string::size_type pos = 0;
  for (;;) {
    std::string::size_type prev_pos = pos;
    pos = str.find('\n', pos);

    out.append(indent);

    if (pos == std::string::npos) {
      out.append(str, prev_pos, std::string::npos);
      break;
    } else {
      pos++;
      out.append(str, prev_pos, pos - prev_pos);
    }
  }

  return out;
}",46.0,67.0,1.0,1.0,22.0,12,4,20,8,0,0,5,5,0,0,,0,0,4,2,2,string
3046,124032,MapStaticCodeToLargePages,1,node.MapStaticCodeToLargePages,int node.MapStaticCodeToLargePages (),large_pages\node_large_page.cc,"int MapStaticCodeToLargePages() {
#if defined(NODE_ENABLE_LARGE_CODE_PAGES) && NODE_ENABLE_LARGE_CODE_PAGES
  bool have_thp = false;
#if defined(__linux__)
  have_thp = IsTransparentHugePagesEnabled();
#elif defined(__FreeBSD__)
  have_thp = IsSuperPagesEnabled();
#elif defined(__APPLE__)
  // pse-36 flag is present in recent mac x64 products.
  have_thp = true;
#endif
  if (!have_thp)
    return EACCES;

  struct text_region r = FindNodeTextRegion();
  if (r.found_text_region == false)
    return ENOENT;

  return MoveTextRegionToLargePages(r);
#else
  return ENOTSUP;
#endif
}",417.0,439.0,1.0,1.0,23.0,0,0,1,1,1,0,1,1,0,0,,0,0,0,0,0,int
3047,124038,LargePagesError,1,node.LargePagesError,const char* node.LargePagesError (int),large_pages\node_large_page.cc,"const char* LargePagesError(int status) {
  switch (status) {
    case ENOTSUP:
      return ""Mapping to large pages is not supported."";

    case EACCES:
      return ""Large pages are not enabled."";

    case ENOENT:
      return ""failed to find text region"";

    case -1:
      return ""Mapping code to large pages failed. Reverting to default page ""
          ""size."";

    case 0:
      return ""OK"";

    default:
      return ""Unknown error"";
  }
}",441.0,462.0,1.0,1.0,22.0,1,1,4,4,1,0,2,2,0,0,,0,0,2,1,1,const char*
3048,124104,<lambda>0,1,node.loader.ModuleWrap.Evaluate.<lambda>0,ANY node.loader.ModuleWrap.Evaluate.<lambda>0 (),module_wrap.cc,"[&]() {
    MaybeLocal<Value> result = module->Evaluate(context);
    if (!result.IsEmpty() && microtask_queue)
      microtask_queue->PerformCheckpoint(isolate);
    return result;
  }",384.0,389.0,14.0,3.0,6.0,8,7,10,7,0,0,2,2,0,0,,0,0,0,0,0,ANY
3049,124167,ModuleWrap,1,node.loader.ModuleWrap.ModuleWrap,"ANY node.loader.ModuleWrap.ModuleWrap (Environment*,Local<Object>,Local<Module>,Local<String>)",module_wrap.cc,"ModuleWrap::ModuleWrap(Environment* env,
                       Local<Object> object,
                       Local<Module> module,
                       Local<String> url)
  : BaseObject(env, object),
    module_(env->isolate(), module),
    id_(env->get_next_module_id()) {
  env->id_to_module_map.emplace(id_, this);

  Local<Value> undefined = Undefined(env->isolate());
  object->SetInternalField(kURLSlot, url);
  object->SetInternalField(kSyntheticEvaluationStepsSlot, undefined);
  object->SetInternalField(kContextObjectSlot, undefined);
}",52.0,65.0,1.0,1.0,14.0,9,5,15,10,0,0,1,1,0,0,,0,0,8,4,4,ANY
3050,124212,~ModuleWrap,1,node.loader.ModuleWrap.~ModuleWrap,ANY node.loader.ModuleWrap.~ModuleWrap (),module_wrap.cc,"ModuleWrap::~ModuleWrap() {
  HandleScope scope(env()->isolate());
  Local<Module> module = module_.Get(env()->isolate());
  env()->id_to_module_map.erase(id_);
  auto range = env()->hash_to_module_map.equal_range(module->GetIdentityHash());
  for (auto it = range.first; it != range.second; ++it) {
    if (it->second == this) {
      env()->hash_to_module_map.erase(it);
      break;
    }
  }
}",67.0,78.0,1.0,1.0,12.0,20,7,13,7,0,0,4,4,0,0,,0,0,0,0,0,ANY
3051,124287,context,1,node.loader.ModuleWrap.context,Local<Context> node.loader.ModuleWrap.context (),module_wrap.cc,"Local<Context> ModuleWrap::context() const {
  Local<Value> obj = object()->GetInternalField(kContextObjectSlot);
  if (obj.IsEmpty()) return {};
  return obj.As<Object>()->GetCreationContext().ToLocalChecked();
}",80.0,84.0,1.0,1.0,5.0,8,5,6,4,0,0,2,2,0,0,,0,0,0,0,0,Local<Context>
3052,124320,GetFromModule,1,node.loader.ModuleWrap.GetFromModule,"ModuleWrap node.loader.ModuleWrap.GetFromModule (Environment*,Local<Module>)",module_wrap.cc,"ModuleWrap* ModuleWrap::GetFromModule(Environment* env,
                                      Local<Module> module) {
  auto range = env->hash_to_module_map.equal_range(module->GetIdentityHash());
  for (auto it = range.first; it != range.second; ++it) {
    if (it->second->module_ == module) {
      return it->second;
    }
  }
  return nullptr;
}",86.0,95.0,1.0,1.0,10.0,12,5,10,4,0,0,3,4,0,0,,0,0,4,2,2,ModuleWrap
3053,124370,GetFromID,1,node.loader.ModuleWrap.GetFromID,"ModuleWrap node.loader.ModuleWrap.GetFromID (Environment*,uint32_t)",module_wrap.cc,"ModuleWrap* ModuleWrap::GetFromID(Environment* env, uint32_t id) {
  auto module_wrap_it = env->id_to_module_map.find(id);
  if (module_wrap_it == env->id_to_module_map.end()) {
    return nullptr;
  }
  return module_wrap_it->second;
}",97.0,103.0,1.0,1.0,7.0,7,4,6,3,0,0,2,2,0,0,,0,0,4,2,2,ModuleWrap
3054,124402,New,1,node.loader.ModuleWrap.New,void node.loader.ModuleWrap.New (FunctionCallbackInfo<Value>),module_wrap.cc,"void ModuleWrap::New(const FunctionCallbackInfo<Value>& args) {
  CHECK(args.IsConstructCall());
  CHECK_GE(args.Length(), 3);

  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  Local<Object> that = args.This();

  CHECK(args[0]->IsString());
  Local<String> url = args[0].As<String>();

  Local<Context> context;
  ContextifyContext* contextify_context = nullptr;
  if (args[1]->IsUndefined()) {
    context = that->GetCreationContext().ToLocalChecked();
  } else {
    CHECK(args[1]->IsObject());
    contextify_context = ContextifyContext::ContextFromContextifiedSandbox(
        env, args[1].As<Object>());
    CHECK_NOT_NULL(contextify_context);
    context = contextify_context->context();
  }

  int line_offset = 0;
  int column_offset = 0;

  bool synthetic = args[2]->IsArray();
  if (synthetic) {
    // new ModuleWrap(url, context, exportNames, syntheticExecutionFunction)
    CHECK(args[3]->IsFunction());
  } else {
    // new ModuleWrap(url...",107.0,251.0,1.0,1.0,145.0,96,9,112,36,0,0,7,8,0,0,,0,0,2,1,1,void
3055,125029,createImportAssertionContainer,1,node.loader.createImportAssertionContainer,"Local<Object> node.loader.createImportAssertionContainer (Environment*,Isolate*,Local<FixedArray>)",module_wrap.cc,"static Local<Object> createImportAssertionContainer(Environment* env,
  Isolate* isolate, Local<FixedArray> raw_assertions) {
  Local<Object> assertions =
        Object::New(isolate, v8::Null(env->isolate()), nullptr, nullptr, 0);
  for (int i = 0; i < raw_assertions->Length(); i += 3) {
      assertions
          ->Set(env->context(),
                raw_assertions->Get(env->context(), i).As<String>(),
                raw_assertions->Get(env->context(), i + 1).As<Value>())
          .ToChecked();
  }

  return assertions;
}",253.0,266.0,1.0,1.0,14.0,19,6,19,8,0,0,2,2,0,0,,0,0,6,3,3,Local<Object>
3056,125113,Link,1,node.loader.ModuleWrap.Link,void node.loader.ModuleWrap.Link (FunctionCallbackInfo<Value>),module_wrap.cc,"void ModuleWrap::Link(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = args.GetIsolate();

  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsFunction());

  Local<Object> that = args.This();

  ModuleWrap* obj;
  ASSIGN_OR_RETURN_UNWRAP(&obj, that);

  if (obj->linked_)
    return;
  obj->linked_ = true;

  Local<Function> resolver_arg = args[0].As<Function>();

  Local<Context> mod_context = obj->context();
  Local<Module> module = obj->module_.Get(isolate);

  Local<FixedArray> module_requests = module->GetModuleRequests();
  const int module_requests_length = module_requests->Length();
  MaybeStackBuffer<Local<Value>, 16> promises(module_requests_length);

  // call the dependency resolve callbacks
  for (int i = 0; i < module_requests_length; i++) {
    Local<ModuleRequest> module_request =
      module_requests->Get(env->context(), i).As<ModuleRequest>();
    Local<String> specifier = module_request->GetSpecifier...",268.0,330.0,1.0,1.0,63.0,85,10,97,35,0,0,5,7,0,0,,0,0,2,1,1,void
3057,125400,Instantiate,1,node.loader.ModuleWrap.Instantiate,void node.loader.ModuleWrap.Instantiate (FunctionCallbackInfo<Value>),module_wrap.cc,"void ModuleWrap::Instantiate(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = args.GetIsolate();
  ModuleWrap* obj;
  ASSIGN_OR_RETURN_UNWRAP(&obj, args.This());
  Local<Context> context = obj->context();
  Local<Module> module = obj->module_.Get(isolate);
  TryCatchScope try_catch(env);
  USE(module->InstantiateModule(context, ResolveModuleCallback));

  // clear resolve cache on instantiate
  obj->resolve_cache_.clear();

  if (try_catch.HasCaught() && !try_catch.HasTerminated()) {
    CHECK(!try_catch.Message().IsEmpty());
    CHECK(!try_catch.Exception().IsEmpty());
    AppendExceptionLine(env, try_catch.Exception(), try_catch.Message(),
                        ErrorHandlingMode::MODULE_ERROR);
    try_catch.ReThrow();
    return;
  }
}",332.0,353.0,1.0,1.0,22.0,32,8,30,13,0,0,2,2,0,0,,0,0,2,1,1,void
3058,125515,Evaluate,1,node.loader.ModuleWrap.Evaluate,void node.loader.ModuleWrap.Evaluate (FunctionCallbackInfo<Value>),module_wrap.cc,"void ModuleWrap::Evaluate(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();
  ModuleWrap* obj;
  ASSIGN_OR_RETURN_UNWRAP(&obj, args.This());
  Local<Context> context = obj->context();
  Local<Module> module = obj->module_.Get(isolate);

  ContextifyContext* contextify_context = obj->contextify_context_;
  std::shared_ptr<MicrotaskQueue> microtask_queue;
  if (contextify_context != nullptr)
      microtask_queue = contextify_context->microtask_queue();

  // module.evaluate(timeout, breakOnSigint)
  CHECK_EQ(args.Length(), 2);

  CHECK(args[0]->IsNumber());
  int64_t timeout = args[0]->IntegerValue(env->context()).FromJust();

  CHECK(args[1]->IsBoolean());
  bool break_on_sigint = args[1]->IsTrue();

  ShouldNotAbortOnUncaughtScope no_abort_scope(env);
  TryCatchScope try_catch(env);
  Isolate::SafeForTerminationScope safe_for_termination(env->isolate());

  bool timed_out = false;
  bool received_sign...",355.0,430.0,1.0,1.0,76.0,64,12,64,23,0,0,9,12,0,0,,0,0,2,1,1,void
3059,125798,GetNamespace,1,node.loader.ModuleWrap.GetNamespace,void node.loader.ModuleWrap.GetNamespace (FunctionCallbackInfo<Value>),module_wrap.cc,"void ModuleWrap::GetNamespace(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = args.GetIsolate();
  ModuleWrap* obj;
  ASSIGN_OR_RETURN_UNWRAP(&obj, args.This());

  Local<Module> module = obj->module_.Get(isolate);

  switch (module->GetStatus()) {
    case v8::Module::Status::kUninstantiated:
    case v8::Module::Status::kInstantiating:
      return env->ThrowError(
          ""cannot get namespace, module has not been instantiated"");
    case v8::Module::Status::kInstantiated:
    case v8::Module::Status::kEvaluating:
    case v8::Module::Status::kEvaluated:
    case v8::Module::Status::kErrored:
      break;
    default:
      UNREACHABLE();
  }

  Local<Value> result = module->GetModuleNamespace();
  args.GetReturnValue().Set(result);
}",432.0,456.0,1.0,1.0,25.0,37,6,38,12,0,0,3,2,0,0,,0,0,2,1,1,void
3060,125920,GetStatus,1,node.loader.ModuleWrap.GetStatus,void node.loader.ModuleWrap.GetStatus (FunctionCallbackInfo<Value>),module_wrap.cc,"void ModuleWrap::GetStatus(const FunctionCallbackInfo<Value>& args) {
  Isolate* isolate = args.GetIsolate();
  ModuleWrap* obj;
  ASSIGN_OR_RETURN_UNWRAP(&obj, args.This());

  Local<Module> module = obj->module_.Get(isolate);

  args.GetReturnValue().Set(module->GetStatus());
}",458.0,466.0,1.0,1.0,9.0,12,6,11,6,0,0,1,1,0,0,,0,0,2,1,1,void
3061,125964,GetStaticDependencySpecifiers,1,node.loader.ModuleWrap.GetStaticDependencySpecifiers,void node.loader.ModuleWrap.GetStaticDependencySpecifiers (FunctionCallbackInfo<Value>),module_wrap.cc,"void ModuleWrap::GetStaticDependencySpecifiers(
    const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  ModuleWrap* obj;
  ASSIGN_OR_RETURN_UNWRAP(&obj, args.This());

  Local<Module> module = obj->module_.Get(env->isolate());

  Local<FixedArray> module_requests = module->GetModuleRequests();
  int count = module_requests->Length();

  MaybeStackBuffer<Local<Value>, 16> specifiers(count);

  for (int i = 0; i < count; i++) {
    Local<ModuleRequest> module_request =
      module_requests->Get(env->context(), i).As<ModuleRequest>();
    specifiers[i] = module_request->GetSpecifier();
  }

  args.GetReturnValue().Set(
      Array::New(env->isolate(), specifiers.out(), count));
}",468.0,489.0,1.0,1.0,22.0,32,7,34,15,0,0,2,2,0,0,,0,0,2,1,1,void
3062,126079,GetError,1,node.loader.ModuleWrap.GetError,void node.loader.ModuleWrap.GetError (FunctionCallbackInfo<Value>),module_wrap.cc,"void ModuleWrap::GetError(const FunctionCallbackInfo<Value>& args) {
  Isolate* isolate = args.GetIsolate();
  ModuleWrap* obj;
  ASSIGN_OR_RETURN_UNWRAP(&obj, args.This());

  Local<Module> module = obj->module_.Get(isolate);
  args.GetReturnValue().Set(module->GetException());
}",491.0,498.0,1.0,1.0,8.0,12,6,11,6,0,0,1,1,0,0,,0,0,2,1,1,void
3063,126123,ResolveModuleCallback,1,node.loader.ModuleWrap.ResolveModuleCallback,"MaybeLocal<Module> node.loader.ModuleWrap.ResolveModuleCallback (Local<Context>,Local<String>,Local<FixedArray>,Local<Module>)",module_wrap.cc,"MaybeLocal<Module> ModuleWrap::ResolveModuleCallback(
    Local<Context> context,
    Local<String> specifier,
    Local<FixedArray> import_assertions,
    Local<Module> referrer) {
  Environment* env = Environment::GetCurrent(context);
  if (env == nullptr) {
    Isolate* isolate = context->GetIsolate();
    THROW_ERR_EXECUTION_ENVIRONMENT_NOT_AVAILABLE(isolate);
    return MaybeLocal<Module>();
  }

  Isolate* isolate = env->isolate();

  Utf8Value specifier_utf8(isolate, specifier);
  std::string specifier_std(*specifier_utf8, specifier_utf8.length());

  ModuleWrap* dependent = GetFromModule(env, referrer);
  if (dependent == nullptr) {
    THROW_ERR_VM_MODULE_LINK_FAILURE(
        env, ""request for '%s' is from invalid module"", specifier_std);
    return MaybeLocal<Module>();
  }

  if (dependent->resolve_cache_.count(specifier_std) != 1) {
    THROW_ERR_VM_MODULE_LINK_FAILURE(
        env, ""request for '%s' is not in cache"", specifier_std);
    return MaybeLocal<Module>();
  }...",500.0,549.0,1.0,1.0,50.0,35,12,45,15,0,0,6,6,0,0,,0,0,8,4,4,MaybeLocal<Module>
3064,126284,ImportModuleDynamically,1,node.loader.ImportModuleDynamically,"MaybeLocal<Promise> node.loader.ImportModuleDynamically (Local<Context>,ANY,Local<Value>,Local<String>,Local<FixedArray>)",module_wrap.cc,"static MaybeLocal<Promise> ImportModuleDynamically(
    Local<Context> context,
    Local<v8::Data> host_defined_options,
    Local<Value> resource_name,
    Local<String> specifier,
    Local<FixedArray> import_assertions) {
  Isolate* isolate = context->GetIsolate();
  Environment* env = Environment::GetCurrent(context);
  if (env == nullptr) {
    THROW_ERR_EXECUTION_ENVIRONMENT_NOT_AVAILABLE(isolate);
    return MaybeLocal<Promise>();
  }

  EscapableHandleScope handle_scope(isolate);

  Local<Function> import_callback =
    env->host_import_module_dynamically_callback();

  Local<FixedArray> options = host_defined_options.As<FixedArray>();
  if (options->Length() != HostDefinedOptions::kLength) {
    Local<Promise::Resolver> resolver;
    if (!Promise::Resolver::New(context).ToLocal(&resolver)) return {};
    resolver
        ->Reject(context,
                 v8::Exception::TypeError(FIXED_ONE_BYTE_STRING(
                     context->GetIsolate(), ""Invalid host defined optio...",551.0,625.0,1.0,1.0,75.0,68,10,76,29,0,0,6,7,0,0,,0,0,10,5,5,MaybeLocal<Promise>
3065,126595,SetImportModuleDynamicallyCallback,1,node.loader.ModuleWrap.SetImportModuleDynamicallyCallback,void node.loader.ModuleWrap.SetImportModuleDynamicallyCallback (FunctionCallbackInfo<Value>),module_wrap.cc,"void ModuleWrap::SetImportModuleDynamicallyCallback(
    const FunctionCallbackInfo<Value>& args) {
  Isolate* isolate = args.GetIsolate();
  Environment* env = Environment::GetCurrent(args);
  HandleScope handle_scope(isolate);

  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsFunction());
  Local<Function> import_callback = args[0].As<Function>();
  env->set_host_import_module_dynamically_callback(import_callback);

  isolate->SetHostImportModuleDynamicallyCallback(ImportModuleDynamically);
}",627.0,639.0,1.0,1.0,13.0,14,6,16,8,0,0,1,1,0,0,,0,0,2,1,1,void
3066,126653,HostInitializeImportMetaObjectCallback,1,node.loader.ModuleWrap.HostInitializeImportMetaObjectCallback,"void node.loader.ModuleWrap.HostInitializeImportMetaObjectCallback (Local<Context>,Local<Module>,Local<Object>)",module_wrap.cc,"void ModuleWrap::HostInitializeImportMetaObjectCallback(
    Local<Context> context, Local<Module> module, Local<Object> meta) {
  Environment* env = Environment::GetCurrent(context);
  if (env == nullptr)
    return;
  ModuleWrap* module_wrap = GetFromModule(env, module);

  if (module_wrap == nullptr) {
    return;
  }

  Local<Object> wrap = module_wrap->object();
  Local<Function> callback =
      env->host_initialize_import_meta_object_callback();
  Local<Value> args[] = { wrap, meta };
  TryCatchScope try_catch(env);
  USE(callback->Call(
        context, Undefined(env->isolate()), arraysize(args), args));
  if (try_catch.HasCaught() && !try_catch.HasTerminated()) {
    try_catch.ReThrow();
  }
}",641.0,662.0,1.0,1.0,22.0,22,9,28,13,0,0,4,4,0,0,,0,0,6,3,3,void
3067,126745,SetInitializeImportMetaObjectCallback,1,node.loader.ModuleWrap.SetInitializeImportMetaObjectCallback,void node.loader.ModuleWrap.SetInitializeImportMetaObjectCallback (FunctionCallbackInfo<Value>),module_wrap.cc,"void ModuleWrap::SetInitializeImportMetaObjectCallback(
    const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsFunction());
  Local<Function> import_meta_callback = args[0].As<Function>();
  env->set_host_initialize_import_meta_object_callback(import_meta_callback);

  isolate->SetHostInitializeImportMetaObjectCallback(
      HostInitializeImportMetaObjectCallback);
}",664.0,676.0,1.0,1.0,13.0,14,6,15,8,0,0,1,1,0,0,,0,0,2,1,1,void
3068,126800,SyntheticModuleEvaluationStepsCallback,1,node.loader.ModuleWrap.SyntheticModuleEvaluationStepsCallback,"MaybeLocal<Value> node.loader.ModuleWrap.SyntheticModuleEvaluationStepsCallback (Local<Context>,Local<Module>)",module_wrap.cc,"MaybeLocal<Value> ModuleWrap::SyntheticModuleEvaluationStepsCallback(
    Local<Context> context, Local<Module> module) {
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  ModuleWrap* obj = GetFromModule(env, module);

  TryCatchScope try_catch(env);
  Local<Function> synthetic_evaluation_steps =
      obj->object()->GetInternalField(kSyntheticEvaluationStepsSlot)
          .As<Function>();
  obj->object()->SetInternalField(
      kSyntheticEvaluationStepsSlot, Undefined(isolate));
  MaybeLocal<Value> ret = synthetic_evaluation_steps->Call(context,
      obj->object(), 0, nullptr);
  if (ret.IsEmpty()) {
    CHECK(try_catch.HasCaught());
  }
  if (try_catch.HasCaught() && !try_catch.HasTerminated()) {
    CHECK(!try_catch.Message().IsEmpty());
    CHECK(!try_catch.Exception().IsEmpty());
    try_catch.ReThrow();
    return MaybeLocal<Value>();
  }

  Local<Promise::Resolver> resolver;
  if (!Promise::Resolver::New(context).ToLocal(&resolv...",678.0,710.0,1.0,1.0,33.0,42,8,41,17,0,0,4,4,0,0,,0,0,4,2,2,MaybeLocal<Value>
3069,126960,SetSyntheticExport,1,node.loader.ModuleWrap.SetSyntheticExport,void node.loader.ModuleWrap.SetSyntheticExport (FunctionCallbackInfo<Value>),module_wrap.cc,"void ModuleWrap::SetSyntheticExport(const FunctionCallbackInfo<Value>& args) {
  Isolate* isolate = args.GetIsolate();
  Local<Object> that = args.This();

  ModuleWrap* obj;
  ASSIGN_OR_RETURN_UNWRAP(&obj, that);

  CHECK(obj->synthetic_);

  CHECK_EQ(args.Length(), 2);

  CHECK(args[0]->IsString());
  Local<String> export_name = args[0].As<String>();

  Local<Value> export_value = args[1];

  Local<Module> module = obj->module_.Get(isolate);
  USE(module->SetSyntheticModuleExport(isolate, export_name, export_value));
}",712.0,730.0,1.0,1.0,19.0,26,7,28,12,0,0,1,1,0,0,,0,0,2,1,1,void
3070,127046,CreateCachedData,1,node.loader.ModuleWrap.CreateCachedData,void node.loader.ModuleWrap.CreateCachedData (FunctionCallbackInfo<Value>),module_wrap.cc,"void ModuleWrap::CreateCachedData(const FunctionCallbackInfo<Value>& args) {
  Isolate* isolate = args.GetIsolate();
  Local<Object> that = args.This();

  ModuleWrap* obj;
  ASSIGN_OR_RETURN_UNWRAP(&obj, that);

  CHECK(!obj->synthetic_);

  Local<Module> module = obj->module_.Get(isolate);

  CHECK_LT(module->GetStatus(), v8::Module::Status::kEvaluating);

  Local<UnboundModuleScript> unbound_module_script =
      module->GetUnboundModuleScript();
  std::unique_ptr<ScriptCompiler::CachedData> cached_data(
      ScriptCompiler::CreateCodeCache(unbound_module_script));
  Environment* env = Environment::GetCurrent(args);
  if (!cached_data) {
    args.GetReturnValue().Set(Buffer::New(env, 0).ToLocalChecked());
  } else {
    MaybeLocal<Object> buf =
        Buffer::Copy(env,
                     reinterpret_cast<const char*>(cached_data->data),
                     cached_data->length);
    args.GetReturnValue().Set(buf.ToLocalChecked());
  }
}",732.0,759.0,1.0,1.0,28.0,29,7,29,16,0,0,2,2,0,0,,0,0,2,1,1,void
3071,127111,cached_data,1,node.loader.ModuleWrap.CreateCachedData.cached_data,ANY node.loader.ModuleWrap.CreateCachedData.cached_data (ANY),module_wrap.cc,"std::unique_ptr<ScriptCompiler::CachedData> cached_data(
      ScriptCompiler::CreateCodeCache(unbound_module_script));",747.0,748.0,47.0,61.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
3072,127178,Initialize,1,node.loader.ModuleWrap.Initialize,"void node.loader.ModuleWrap.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)",module_wrap.cc,"void ModuleWrap::Initialize(Local<Object> target,
                            Local<Value> unused,
                            Local<Context> context,
                            void* priv) {
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  Local<FunctionTemplate> tpl = NewFunctionTemplate(isolate, New);
  tpl->InstanceTemplate()->SetInternalFieldCount(
      ModuleWrap::kInternalFieldCount);

  SetProtoMethod(isolate, tpl, ""link"", Link);
  SetProtoMethod(isolate, tpl, ""instantiate"", Instantiate);
  SetProtoMethod(isolate, tpl, ""evaluate"", Evaluate);
  SetProtoMethod(isolate, tpl, ""setExport"", SetSyntheticExport);
  SetProtoMethodNoSideEffect(
      isolate, tpl, ""createCachedData"", CreateCachedData);
  SetProtoMethodNoSideEffect(isolate, tpl, ""getNamespace"", GetNamespace);
  SetProtoMethodNoSideEffect(isolate, tpl, ""getStatus"", GetStatus);
  SetProtoMethodNoSideEffect(isolate, tpl, ""getError"", GetError);
  SetProtoMethodNoSideEffect(is...",761.0,809.0,1.0,4.0,49.0,52,5,90,27,0,0,1,1,0,0,,0,0,8,4,4,void
3073,127454,RegisterExternalReferences,1,node.loader.ModuleWrap.RegisterExternalReferences,void node.loader.ModuleWrap.RegisterExternalReferences (ExternalReferenceRegistry*),module_wrap.cc,"void ModuleWrap::RegisterExternalReferences(
    ExternalReferenceRegistry* registry) {
  registry->Register(New);

  registry->Register(Link);
  registry->Register(Instantiate);
  registry->Register(Evaluate);
  registry->Register(SetSyntheticExport);
  registry->Register(CreateCachedData);
  registry->Register(GetNamespace);
  registry->Register(GetStatus);
  registry->Register(GetError);
  registry->Register(GetStaticDependencySpecifiers);

  registry->Register(SetImportModuleDynamicallyCallback);
  registry->Register(SetInitializeImportMetaObjectCallback);
}",811.0,827.0,1.0,1.0,17.0,12,1,24,13,0,0,1,1,0,0,,0,0,2,1,1,void
3074,127534,<lambda>0,1,node.Environment.InitializeDiagnostics.<lambda>0,ANY node.Environment.InitializeDiagnostics.<lambda>0 (void*),node.cc,"[](void* data) {
      Environment* env = static_cast<Environment*>(data);
      env->isolate()->SetAtomicsWaitCallback(nullptr, nullptr);
    }",255.0,258.0,20.0,5.0,4.0,4,3,3,2,0,0,1,1,0,0,,0,0,2,1,1,ANY
3075,127556,<lambda>1,1,node.StartExecution.<lambda>1,ANY node.StartExecution.<lambda>1 (),node.cc,[&]() { env->set_embedder_entry_point({}); },284.0,284.0,22.0,65.0,1.0,2,2,1,1,0,0,1,1,0,0,,0,0,0,0,0,ANY
3076,127567,<lambda>2,1,node.StartInternal.<lambda>2,ANY node.StartInternal.<lambda>2 (),node.cc,"[&]() {
    TearDownOncePerProcess();

    if (snapshot_data != nullptr &&
        snapshot_data->data_ownership == SnapshotData::DataOwnership::kOwned) {
      delete snapshot_data;
    }
  }",1231.0,1238.0,39.0,3.0,8.0,7,6,5,3,0,0,2,2,0,0,,0,0,0,0,0,ANY
3077,127718,AtomicsWaitCallback,1,node.AtomicsWaitCallback,"void node.AtomicsWaitCallback (ANY,ANY,size_t,int64_t,double,ANY*,void*)",node.cc,"static void AtomicsWaitCallback(Isolate::AtomicsWaitEvent event,
                                Local<v8::SharedArrayBuffer> array_buffer,
                                size_t offset_in_bytes, int64_t value,
                                double timeout_in_ms,
                                Isolate::AtomicsWaitWakeHandle* stop_handle,
                                void* data) {
  Environment* env = static_cast<Environment*>(data);

  const char* message = ""(unknown event)"";
  switch (event) {
#define V(key, msg)                         \
    case Isolate::AtomicsWaitEvent::key:    \
      message = msg;                        \
      break;
    ATOMIC_WAIT_EVENTS(V)
#undef V
  }

  fprintf(stderr,
          ""(node:%d) [Thread %"" PRIu64 ""] Atomics.wait(%p + %zx, %"" PRId64
          "", %.f) %s\n"",
          static_cast<int>(uv_os_getpid()),
          env->thread_id(),
          array_buffer->Data(),
          offset_in_bytes,
          value,
          timeout_in_ms,
          ...",215.0,243.0,1.0,4.0,29.0,21,3,22,5,0,0,8,2,0,0,,0,0,14,7,7,void
3078,127805,InitializeDiagnostics,1,node.Environment.InitializeDiagnostics,void node.Environment.InitializeDiagnostics (),node.cc,"void Environment::InitializeDiagnostics() {
  isolate_->GetHeapProfiler()->AddBuildEmbedderGraphCallback(
      Environment::BuildEmbedderGraph, this);
  if (heap_snapshot_near_heap_limit_ > 0) {
    AddHeapSnapshotNearHeapLimitCallback();
  }
  if (options_->trace_uncaught)
    isolate_->SetCaptureStackTraceForUncaughtExceptions(true);
  if (options_->trace_atomics_wait) {
    isolate_->SetAtomicsWaitCallback(AtomicsWaitCallback, this);
    AddCleanupHook([](void* data) {
      Environment* env = static_cast<Environment*>(data);
      env->isolate()->SetAtomicsWaitCallback(nullptr, nullptr);
    }, this);
  }
}",245.0,260.0,1.0,1.0,16.0,8,3,8,5,0,0,4,4,0,0,,0,0,0,0,0,void
3079,127850,StartExecution,1,node.StartExecution,"MaybeLocal<Value> node.StartExecution (Environment*,char*)",node.cc,"MaybeLocal<Value> StartExecution(Environment* env, StartExecutionCallback cb) {
  InternalCallbackScope callback_scope(
      env,
      Object::New(env->isolate()),
      { 1, 0 },
      InternalCallbackScope::kSkipAsyncHooks);

  if (cb != nullptr) {
    EscapableHandleScope scope(env->isolate());
    // TODO(addaleax): pass the callback to the main script more directly,
    // e.g. by making StartExecution(env, builtin) parametrizable
    env->set_embedder_entry_point(std::move(cb));
    auto reset_entry_point =
        OnScopeLeave([&]() { env->set_embedder_entry_point({}); });

    const char* entry = env->isolate_data()->options()->build_snapshot
                            ? ""internal/main/mksnapshot""
                            : ""internal/main/embedding"";

    return scope.EscapeMaybe(StartExecution(env, entry));
  }

  // TODO(joyeecheung): move these conditions into JS land and let the
  // deserialize main function take precedence. For workers, we need to
  // move the p...",271.0,353.0,1.0,1.0,83.0,5,3,7,4,0,0,1,1,0,0,,0,0,4,2,2,MaybeLocal<Value>
3080,128137,ResetSignalHandlers,1,node.ResetSignalHandlers,void node.ResetSignalHandlers (),node.cc,"void ResetSignalHandlers() {
#ifdef __POSIX__
  // Restore signal dispositions, the parent process may have changed them.
  struct sigaction act;
  memset(&act, 0, sizeof(act));

  // The hard-coded upper limit is because NSIG is not very reliable; on Linux,
  // it evaluates to 32, 34 or 64, depending on whether RT signals are enabled.
  // Counting up to SIGRTMIN doesn't work for the same reason.
  for (unsigned nr = 1; nr < kMaxSignal; nr += 1) {
    if (nr == SIGKILL || nr == SIGSTOP)
      continue;
    act.sa_handler = (nr == SIGPIPE || nr == SIGXFSZ) ? SIG_IGN : SIG_DFL;
    if (act.sa_handler == SIG_DFL) {
      // The only bad handler value we can inhert from before exec is SIG_IGN
      // (any actual function pointer is reset to SIG_DFL during exec).
      // If that's the case, we want to reset it back to SIG_DFL.
      // However, it's also possible that an embeder (or an LD_PRELOAD-ed
      // library) has set up own signal handler for own purposes
      // (e.g. profi...",420.0,447.0,1.0,1.0,28.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
3081,128149,PlatformInit,1,node.PlatformInit,void node.PlatformInit (ANY),node.cc,"static void PlatformInit(ProcessInitializationFlags::Flags flags) {
  // init_process_flags is accessed in ResetStdio(),
  // which can be called from signal handlers.
  CHECK(init_process_flags.is_lock_free());
  init_process_flags.store(flags);

  if (!(flags & ProcessInitializationFlags::kNoStdioInitialization)) {
    atexit(ResetStdio);
  }

#ifdef __POSIX__
  if (!(flags & ProcessInitializationFlags::kNoStdioInitialization)) {
    // Disable stdio buffering, it interacts poorly with printf()
    // calls elsewhere in the program (e.g., any logging from V8.)
    setvbuf(stdout, nullptr, _IONBF, 0);
    setvbuf(stderr, nullptr, _IONBF, 0);

    // Make sure file descriptors 0-2 are valid before we start logging
    // anything.
    for (auto& s : stdio) {
      const int fd = &s - stdio;
      if (fstat(fd, &s.stat) == 0) continue;

      // Anything but EBADF means something is seriously wrong.  We don't
      // have to special-case EINTR, fstat() is not interruptible.
      if...",457.0,608.0,1.0,1.0,152.0,5,3,5,3,0,0,2,2,0,0,,0,0,2,1,1,void
3082,128173,ResetStdio,1,node.ResetStdio,void node.ResetStdio (),node.cc,"void ResetStdio() {
  if (init_process_flags.load() &
      ProcessInitializationFlags::kNoStdioInitialization) {
    return;
  }

  uv_tty_reset_mode();
#ifdef __POSIX__
  for (auto& s : stdio) {
    const int fd = &s - stdio;

    struct stat tmp;
    if (-1 == fstat(fd, &tmp)) {
      CHECK_EQ(errno, EBADF);  // Program closed file descriptor.
      continue;
    }

    bool is_same_file =
        (s.stat.st_dev == tmp.st_dev && s.stat.st_ino == tmp.st_ino);
    if (!is_same_file) continue;  // Program reopened file descriptor.

    int flags;
    do
      flags = fcntl(fd, F_GETFL);
    while (flags == -1 && errno == EINTR);  // NOLINT
    CHECK_NE(flags, -1);

    // Restore the O_NONBLOCK flag if it changed.
    if (O_NONBLOCK & (flags ^ s.flags)) {
      flags &= ~O_NONBLOCK;
      flags |= s.flags & O_NONBLOCK;

      int err;
      do
        err = fcntl(fd, F_SETFL, flags);
      while (err == -1 && errno == EINTR);  // NOLINT
      CHECK_NE(err, -1);
    }

    if (s.isat...",611.0,671.0,1.0,1.0,61.0,3,2,2,2,0,0,2,2,0,0,,0,0,0,0,0,void
3083,128189,ProcessGlobalArgsInternal,1,node.ProcessGlobalArgsInternal,"ExitCode node.ProcessGlobalArgsInternal (ANY*,ANY*,ANY*,OptionEnvvarSettings)",node.cc,"static ExitCode ProcessGlobalArgsInternal(std::vector<std::string>* args,
                                          std::vector<std::string>* exec_args,
                                          std::vector<std::string>* errors,
                                          OptionEnvvarSettings settings) {
  // Parse a few arguments which are specific to Node.
  std::vector<std::string> v8_args;

  Mutex::ScopedLock lock(per_process::cli_options_mutex);
  options_parser::Parse(
      args,
      exec_args,
      &v8_args,
      per_process::cli_options.get(),
      settings,
      errors);

  if (!errors->empty()) return ExitCode::kInvalidCommandLineArgument;

  std::string revert_error;
  for (const std::string& cve : per_process::cli_options->security_reverts) {
    Revert(cve.c_str(), &revert_error);
    if (!revert_error.empty()) {
      errors->emplace_back(std::move(revert_error));
      // TODO(joyeecheung): merge into kInvalidCommandLineArgument.
      return ExitCode::kInvalidC...",673.0,750.0,1.0,1.0,78.0,76,11,60,16,0,0,11,13,0,0,,0,0,8,4,4,ExitCode
3084,128491,ProcessGlobalArgs,1,node.ProcessGlobalArgs,"int node.ProcessGlobalArgs (ANY*,ANY*,ANY*,OptionEnvvarSettings)",node.cc,"int ProcessGlobalArgs(std::vector<std::string>* args,
                      std::vector<std::string>* exec_args,
                      std::vector<std::string>* errors,
                      OptionEnvvarSettings settings) {
  return static_cast<int>(
      ProcessGlobalArgsInternal(args, exec_args, errors, settings));
}",752.0,758.0,1.0,1.0,7.0,1,1,4,4,0,0,1,1,0,0,,0,0,8,4,4,int
3085,128512,InitializeNodeWithArgsInternal,1,node.InitializeNodeWithArgsInternal,"ExitCode node.InitializeNodeWithArgsInternal (ANY*,ANY*,ANY*,ANY)",node.cc,"static ExitCode InitializeNodeWithArgsInternal(
    std::vector<std::string>* argv,
    std::vector<std::string>* exec_argv,
    std::vector<std::string>* errors,
    ProcessInitializationFlags::Flags flags) {
  // Make sure InitializeNodeWithArgs() is called only once.
  CHECK(!init_called.exchange(true));

  // Initialize node_start_time to get relative uptime.
  per_process::node_start_time = uv_hrtime();

  // Register built-in bindings
  binding::RegisterBuiltinBindings();

  // Make inherited handles noninheritable.
  if (!(flags & ProcessInitializationFlags::kEnableStdioInheritance) &&
      !(flags & ProcessInitializationFlags::kNoStdioInitialization)) {
    uv_disable_stdio_inheritance();
  }

  // Cache the original command line to be
  // used in diagnostic reports.
  per_process::cli_options->cmdline = *argv;

  // Node provides a ""v8.setFlagsFromString"" method to dynamically change flags.
  // Hence do not freeze flags when initializing V8. In a browser setting, this
  ...",764.0,881.0,1.0,1.0,118.0,55,11,46,18,0,0,9,15,0,0,,0,0,8,4,4,ExitCode
3086,128698,InitializeNodeWithArgs,1,node.InitializeNodeWithArgs,"int node.InitializeNodeWithArgs (ANY*,ANY*,ANY*,ANY)",node.cc,"int InitializeNodeWithArgs(std::vector<std::string>* argv,
                           std::vector<std::string>* exec_argv,
                           std::vector<std::string>* errors,
                           ProcessInitializationFlags::Flags flags) {
  return static_cast<int>(
      InitializeNodeWithArgsInternal(argv, exec_argv, errors, flags));
}",883.0,889.0,1.0,1.0,7.0,1,1,4,4,0,0,1,1,0,0,,0,0,8,4,4,int
3087,128714,InitializeOncePerProcessInternal,1,node.InitializeOncePerProcessInternal,"unique_ptr<InitializationResultImpl> node.InitializeOncePerProcessInternal (ANY,ANY)",node.cc,"static std::unique_ptr<InitializationResultImpl>
InitializeOncePerProcessInternal(const std::vector<std::string>& args,
                                 ProcessInitializationFlags::Flags flags =
                                     ProcessInitializationFlags::kNoFlags) {
  auto result = std::make_unique<InitializationResultImpl>();
  result->args_ = args;

  if (!(flags & ProcessInitializationFlags::kNoParseGlobalDebugVariables)) {
    // Initialized the enabled list for Debug() calls with system
    // environment variables.
    per_process::enabled_debug_list.Parse();
  }

  PlatformInit(flags);

  // This needs to run *before* V8::Initialize().
  {
    result->exit_code_ = InitializeNodeWithArgsInternal(
        &result->args_, &result->exec_args_, &result->errors_, flags);
    if (result->exit_code_enum() != ExitCode::kNoFailure) {
      result->early_return_ = true;
      return result;
    }
  }

  if (!(flags & ProcessInitializationFlags::kNoUseLargePages) &&
      (per_proce...",891.0,1072.0,1.0,21.0,182.0,95,11,63,13,0,2,12,16,0,1,,0,1,4,2,2,unique_ptr<InitializationResultImpl>
3088,128999,InitializeOncePerProcess,1,node.InitializeOncePerProcess,"unique_ptr<InitializationResult> node.InitializeOncePerProcess (ANY,ANY)",node.hpp,"inline std::unique_ptr<InitializationResult> InitializeOncePerProcess(
    const std::vector<std::string>& args,
    std::initializer_list<ProcessInitializationFlags::Flags> list) {
  uint64_t flags_accum = ProcessInitializationFlags::kNoFlags;
  for (const auto flag : list) flags_accum |= static_cast<uint64_t>(flag);
  return InitializeOncePerProcess(
      args, static_cast<ProcessInitializationFlags::Flags>(flags_accum));
}",354.0,361.0,1.0,1.0,8.0,0,0,2,2,0,0,1,1,0,0,,0,0,4,2,2,unique_ptr<InitializationResult>
3089,129009,TearDownOncePerProcess,1,node.TearDownOncePerProcess,void node.TearDownOncePerProcess (),node.cc,"void TearDownOncePerProcess() {
  const uint32_t flags = init_process_flags.load();
  ResetStdio();
  if (!(flags & ProcessInitializationFlags::kNoDefaultSignalHandling)) {
    ResetSignalHandlers();
  }

  per_process::v8_initialized = false;
  if (!(flags & ProcessInitializationFlags::kNoInitializeV8)) {
    V8::Dispose();
  }

#if NODE_USE_V8_WASM_TRAP_HANDLER && defined(_WIN32)
  if (!(flags & ProcessInitializationFlags::kNoDefaultSignalHandling)) {
    RemoveVectoredExceptionHandler(per_process::old_vectored_exception_handler);
  }
#endif

  if (!(flags & ProcessInitializationFlags::kNoInitializeNodeV8Platform)) {
    V8::DisposePlatform();
    // uv_run cannot be called from the time before the beforeExit callback
    // runs until the program exits unless the event loop has any referenced
    // handles after beforeExit terminates. This prevents unrefed timers
    // that happen to terminate during shutdown from being run unsafely.
    // Since uv_run cannot be called, uv_asy...",1080.0,1108.0,1.0,4.0,29.0,17,4,12,5,0,0,4,4,0,0,,0,0,0,0,0,void
3090,129065,~InitializationResult,1,node.InitializationResult.~InitializationResult,ANY node.InitializationResult.~InitializationResult (),node.cc,InitializationResult::~InitializationResult() {},1110.0,1110.0,1.0,48.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
3091,129069,~InitializationResultImpl,1,node.InitializationResultImpl.~InitializationResultImpl,ANY node.InitializationResultImpl.~InitializationResultImpl (),node.cc,InitializationResultImpl::~InitializationResultImpl() {},1111.0,1111.0,1.0,56.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
3092,129073,GenerateAndWriteSnapshotData,1,node.GenerateAndWriteSnapshotData,"ExitCode node.GenerateAndWriteSnapshotData (SnapshotData**,InitializationResultImpl*)",node.cc,"ExitCode GenerateAndWriteSnapshotData(const SnapshotData** snapshot_data_ptr,
                                      const InitializationResultImpl* result) {
  ExitCode exit_code = result->exit_code_enum();
  // nullptr indicates there's no snapshot data.
  DCHECK_NULL(*snapshot_data_ptr);

  // node:embedded_snapshot_main indicates that we are using the
  // embedded snapshot and we are not supposed to clean it up.
  if (result->args()[1] == ""node:embedded_snapshot_main"") {
    *snapshot_data_ptr = SnapshotBuilder::GetEmbeddedSnapshotData();
    if (*snapshot_data_ptr == nullptr) {
      // The Node.js binary is built without embedded snapshot
      fprintf(stderr,
              ""node:embedded_snapshot_main was specified as snapshot ""
              ""entry point but Node.js was built without embedded ""
              ""snapshot.\n"");
      exit_code = ExitCode::kInvalidCommandLineArgument;
      return exit_code;
    }
  } else {
    // Otherwise, load and run the specified main scrip...",1113.0,1165.0,1.0,1.0,53.0,25,8,21,9,0,0,5,6,0,0,,0,0,4,2,2,ExitCode
3093,129235,LoadSnapshotDataAndRun,1,node.LoadSnapshotDataAndRun,"ExitCode node.LoadSnapshotDataAndRun (SnapshotData**,InitializationResultImpl*)",node.cc,"ExitCode LoadSnapshotDataAndRun(const SnapshotData** snapshot_data_ptr,
                                const InitializationResultImpl* result) {
  ExitCode exit_code = result->exit_code_enum();
  // nullptr indicates there's no snapshot data.
  DCHECK_NULL(*snapshot_data_ptr);
  // --snapshot-blob indicates that we are reading a customized snapshot.
  if (!per_process::cli_options->snapshot_blob.empty()) {
    std::string filename = per_process::cli_options->snapshot_blob;
    FILE* fp = fopen(filename.c_str(), ""rb"");
    if (fp == nullptr) {
      fprintf(stderr, ""Cannot open %s"", filename.c_str());
      exit_code = ExitCode::kStartupSnapshotFailure;
      return exit_code;
    }
    std::unique_ptr<SnapshotData> read_data = std::make_unique<SnapshotData>();
    bool ok = SnapshotData::FromFile(read_data.get(), fp);
    fclose(fp);
    if (!ok) {
      // If we fail to read the customized snapshot,
      // simply exit with kStartupSnapshotFailure.
      exit_code = ExitCode::kSt...",1167.0,1210.0,1.0,1.0,44.0,34,6,34,13,0,0,4,6,0,0,,0,0,4,2,2,ExitCode
3094,129394,StartInternal,1,node.StartInternal,"ExitCode node.StartInternal (int,char**)",node.cc,"static ExitCode StartInternal(int argc, char** argv) {
  CHECK_GT(argc, 0);

  // Hack around with the argv pointer. Used for process.title = ""blah"".
  argv = uv_setup_args(argc, argv);

  std::unique_ptr<InitializationResultImpl> result =
      InitializeOncePerProcessInternal(
          std::vector<std::string>(argv, argv + argc));
  for (const std::string& error : result->errors()) {
    FPrintF(stderr, ""%s: %s\n"", result->args().at(0), error);
  }
  if (result->early_return()) {
    return result->exit_code_enum();
  }

  DCHECK_EQ(result->exit_code_enum(), ExitCode::kNoFailure);
  const SnapshotData* snapshot_data = nullptr;

  auto cleanup_process = OnScopeLeave([&]() {
    TearDownOncePerProcess();

    if (snapshot_data != nullptr &&
        snapshot_data->data_ownership == SnapshotData::DataOwnership::kOwned) {
      delete snapshot_data;
    }
  });

  uv_loop_configure(uv_default_loop(), UV_METRICS_IDLE_TIME);

  std::string sea_config = per_process::cli_options->experime...",1212.0,1260.0,1.0,1.0,49.0,35,10,34,13,0,0,6,7,0,0,,0,0,4,2,2,ExitCode
3095,129539,Start,1,node.Start,"int node.Start (int,char**)",node.cc,"int Start(int argc, char** argv) {
#ifndef DISABLE_SINGLE_EXECUTABLE_APPLICATION
  std::tie(argc, argv) = sea::FixupArgsForSEA(argc, argv);
#endif
  return static_cast<int>(StartInternal(argc, argv));
}",1262.0,1267.0,1.0,1.0,6.0,4,3,8,4,1,0,1,1,0,0,,0,0,4,2,2,int
3096,129564,Stop,1,node.Stop,"int node.Stop (Environment*,ANY)",node.cc,"int Stop(Environment* env, StopFlags::Flags flags) {
  env->ExitEnv(flags);
  return 0;
}",1269.0,1272.0,1.0,1.0,4.0,1,1,2,2,0,0,1,1,0,0,,0,0,4,2,2,int
3097,129583,<lambda>0,1,"new CommonEnvironmentSetup( platform, errors, [&](const CommonEnvironmentSetup* setup) -> Environment* { return CreateEnvironment( setup->isolate_data(), setup->context(), std.forward<EnvironmentArgs>(env_args)...); }).<lambda>0","Environment new CommonEnvironmentSetup( platform, errors, [&](const CommonEnvironmentSetup* setup) -> Environment* { return CreateEnvironment( setup->isolate_data(), setup->context(), std.forward<EnvironmentArgs>(env_args)...); }).<lambda>0 (CommonEnvironmentSetup*)",node.hpp,"[&](const CommonEnvironmentSetup* setup) -> Environment* {
        return CreateEnvironment(
            setup->isolate_data(), setup->context(),
            std::forward<EnvironmentArgs>(env_args)...);
      }",904.0,908.0,7.0,7.0,5.0,5,4,5,4,0,0,1,1,0,0,,0,0,2,1,1,Environment
3098,129608,<lambda>1,1,"new CommonEnvironmentSetup( platform, errors, snapshot_data, Flags.kNoFlags, [&](const CommonEnvironmentSetup* setup) -> Environment* { return CreateEnvironment(setup->isolate_data(), setup->context(), std.forward<EnvironmentArgs>(env_args)...); }).<lambda>1","Environment new CommonEnvironmentSetup( platform, errors, snapshot_data, Flags.kNoFlags, [&](const CommonEnvironmentSetup* setup) -> Environment* { return CreateEnvironment(setup->isolate_data(), setup->context(), std.forward<EnvironmentArgs>(env_args)...); }).<lambda>1 (CommonEnvironmentSetup*)",node.hpp,"[&](const CommonEnvironmentSetup* setup) -> Environment* {
        return CreateEnvironment(setup->isolate_data(),
                                 setup->context(),
                                 std::forward<EnvironmentArgs>(env_args)...);
      }",926.0,930.0,7.0,7.0,5.0,5,4,5,4,0,0,1,1,0,0,,0,0,2,1,1,Environment
3099,129874,exit_code,1,node.InitializationResult.exit_code,int node.InitializationResult.exit_code (),node.hpp,virtual int exit_code() const = 0;,291.0,291.0,15.0,35.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,int
3100,129878,early_return,1,node.InitializationResult.early_return,bool node.InitializationResult.early_return (),node.hpp,virtual bool early_return() const = 0;,294.0,294.0,16.0,39.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,bool
3101,129882,args,1,node.InitializationResult.args,ANY node.InitializationResult.args (),node.hpp,virtual const std::vector<std::string>& args() const = 0;,297.0,297.0,41.0,58.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
3102,129886,exec_args,1,node.InitializationResult.exec_args,ANY node.InitializationResult.exec_args (),node.hpp,virtual const std::vector<std::string>& exec_args() const = 0;,300.0,300.0,41.0,63.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
3103,129890,errors,1,node.InitializationResult.errors,ANY node.InitializationResult.errors (),node.hpp,virtual const std::vector<std::string>& errors() const = 0;,304.0,304.0,41.0,60.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
3104,129894,platform,1,node.InitializationResult.platform,MultiIsolatePlatform* node.InitializationResult.platform (),node.hpp,virtual MultiIsolatePlatform* platform() const = 0;,308.0,308.0,31.0,52.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,MultiIsolatePlatform*
3105,129898,InitializationResult,1,node.InitializationResult.InitializationResult,ANY node.InitializationResult.InitializationResult (),node.hpp,InitializationResult() = default;,311.0,311.0,3.0,35.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
3106,129995,GetImpl,1,node.ArrayBufferAllocator.GetImpl,NodeArrayBufferAllocator* node.ArrayBufferAllocator.GetImpl (),node.hpp,virtual NodeArrayBufferAllocator* GetImpl() = 0;,406.0,406.0,35.0,49.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,NodeArrayBufferAllocator*
3107,130010,GetForegroundTaskRunner,1,node.IsolatePlatformDelegate.GetForegroundTaskRunner,ANY node.IsolatePlatformDelegate.GetForegroundTaskRunner (),node.hpp,virtual std::shared_ptr<v8::TaskRunner> GetForegroundTaskRunner() = 0;,417.0,417.0,43.0,71.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
3108,130014,IdleTasksEnabled,1,node.IsolatePlatformDelegate.IdleTasksEnabled,bool node.IsolatePlatformDelegate.IdleTasksEnabled (),node.hpp,virtual bool IdleTasksEnabled() = 0;,418.0,418.0,16.0,37.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,bool
3109,130019,~MultiIsolatePlatform,1,node.MultiIsolatePlatform.~MultiIsolatePlatform,ANY node.MultiIsolatePlatform.~MultiIsolatePlatform (),node.hpp,~MultiIsolatePlatform() override = default;,423.0,423.0,3.0,45.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
3110,130023,FlushForegroundTasks,1,node.MultiIsolatePlatform.FlushForegroundTasks,bool node.MultiIsolatePlatform.FlushForegroundTasks (ANY*),node.hpp,virtual bool FlushForegroundTasks(v8::Isolate* isolate) = 0;,427.0,427.0,16.0,61.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,bool
3111,130028,DrainTasks,1,node.MultiIsolatePlatform.DrainTasks,void node.MultiIsolatePlatform.DrainTasks (ANY*),node.hpp,virtual void DrainTasks(v8::Isolate* isolate) = 0;,428.0,428.0,16.0,51.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
3112,130033,RegisterIsolate,1,node.MultiIsolatePlatform.RegisterIsolate,"void node.MultiIsolatePlatform.RegisterIsolate (ANY*,uv_loop_s*)",node.hpp,"virtual void RegisterIsolate(v8::Isolate* isolate,
                               struct uv_loop_s* loop) = 0;",435.0,436.0,16.0,58.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
3113,130045,UnregisterIsolate,1,node.MultiIsolatePlatform.UnregisterIsolate,void node.MultiIsolatePlatform.UnregisterIsolate (ANY*),node.hpp,virtual void UnregisterIsolate(v8::Isolate* isolate) = 0;,447.0,447.0,16.0,58.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
3114,130050,AddIsolateFinishedCallback,1,node.MultiIsolatePlatform.AddIsolateFinishedCallback,"void node.MultiIsolatePlatform.AddIsolateFinishedCallback (ANY*,void,void*)",node.hpp,"virtual void AddIsolateFinishedCallback(v8::Isolate* isolate,
                                          void (*callback)(void*),
                                          void* data) = 0;",452.0,454.0,16.0,57.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,void
3115,130142,operator (),1,node.EmbedderSnapshotData.DeleteSnapshotData.operator (),void node.EmbedderSnapshotData.DeleteSnapshotData.operator () (EmbedderSnapshotData*),node.hpp,void operator()(const EmbedderSnapshotData*) const;,517.0,517.0,10.0,54.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
3116,130180,operator =,1,node.EmbedderSnapshotData.operator =,EmbedderSnapshotData node.EmbedderSnapshotData.operator = (EmbedderSnapshotData),node.hpp,EmbedderSnapshotData& operator=(const EmbedderSnapshotData&) = delete;,545.0,545.0,3.0,72.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,EmbedderSnapshotData
3117,130430,OnFatalError,1,node.OnFatalError,"void node.OnFatalError (char*,char*)",node_errors.cc,"[[noreturn]] void OnFatalError(const char* location, const char* message) {
  if (location) {
    FPrintF(stderr, ""FATAL ERROR: %s %s\n"", location, message);
  } else {
    FPrintF(stderr, ""FATAL ERROR: %s\n"", message);
  }

  Isolate* isolate = Isolate::TryGetCurrent();
  bool report_on_fatalerror;
  {
    Mutex::ScopedLock lock(node::per_process::cli_options_mutex);
    report_on_fatalerror = per_process::cli_options->report_on_fatalerror;
  }

  if (report_on_fatalerror) {
    TriggerNodeReport(isolate, message, ""FatalError"", """", Local<Object>());
  }

  fflush(stderr);
  ABORT();
}",507.0,527.0,1.0,1.0,21.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
3118,130436,PromiseRejectCallback,1,node.PromiseRejectCallback,void node.PromiseRejectCallback (ANY),node_task_queue.cc,"void PromiseRejectCallback(PromiseRejectMessage message) {
  static std::atomic<uint64_t> unhandledRejections{0};
  static std::atomic<uint64_t> rejectionsHandledAfter{0};

  Local<Promise> promise = message.GetPromise();
  Isolate* isolate = promise->GetIsolate();
  PromiseRejectEvent event = message.GetEvent();

  Environment* env = Environment::GetCurrent(isolate);

  if (env == nullptr || !env->can_call_into_js()) return;

  Local<Function> callback = env->promise_reject_callback();
  // The promise is rejected before JS land calls SetPromiseRejectCallback
  // to initializes the promise reject callback during bootstrap.
  CHECK(!callback.IsEmpty());

  Local<Value> value;
  Local<Value> type = Number::New(env->isolate(), event);

  if (event == kPromiseRejectWithNoHandler) {
    value = message.GetValue();
    unhandledRejections++;
    TRACE_COUNTER2(TRACING_CATEGORY_NODE2(promises, rejections),
                  ""rejections"",
                  ""unhandled"", unhandledRejections...",68.0,160.0,1.0,1.0,93.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
3119,130459,TriggerNodeReport,1,node.TriggerNodeReport,"ANY node.TriggerNodeReport (ANY*,char*,char*,ANY,ANY)",node_report.cc,"std::string TriggerNodeReport(Environment* env,
                              const char* message,
                              const char* trigger,
                              const std::string& name,
                              Local<Value> error) {
  return TriggerNodeReport(env != nullptr ? env->isolate() : nullptr,
                           env,
                           message,
                           trigger,
                           name,
                           error);
}",942.0,953.0,1.0,1.0,12.0,0,0,0,0,0,0,1,1,0,0,,0,0,10,5,5,string
3120,130477,GetNodeReport,1,node.GetNodeReport,"void node.GetNodeReport (ANY*,char*,char*,ANY,ANY)",node_report.cc,"void GetNodeReport(Environment* env,
                   const char* message,
                   const char* trigger,
                   Local<Value> error,
                   std::ostream& out) {
  Isolate* isolate = nullptr;
  if (env != nullptr) {
    isolate = env->isolate();
  }
  report::WriteNodeReport(
      isolate, env, message, trigger, """", out, error, false);
}",970.0,981.0,1.0,1.0,12.0,0,0,0,0,0,0,1,1,0,0,,0,0,10,5,5,void
3121,130516,GetTracingController,1,node.GetTracingController,ANY* node.GetTracingController (),tracing\trace_event.cc,"v8::TracingController* GetTracingController() {
  return tracing::TraceEventHelper::GetTracingController();
}",34.0,36.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,TracingController
3122,130520,SetTracingController,1,node.SetTracingController,void node.SetTracingController (ANY*),tracing\trace_event.cc,"void SetTracingController(v8::TracingController* controller) {
  tracing::TraceEventHelper::SetTracingController(controller);
}",38.0,40.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
3123,130562,Create,1,node.CommonEnvironmentSetup.Create,"ANY node.CommonEnvironmentSetup.Create<EnvironmentArgs> (MultiIsolatePlatform*,ANY*,EnvironmentArgs)",node.hpp,"std::unique_ptr<CommonEnvironmentSetup> CommonEnvironmentSetup::Create(
    MultiIsolatePlatform* platform,
    std::vector<std::string>* errors,
    EnvironmentArgs&&... env_args) {
  auto ret = std::unique_ptr<CommonEnvironmentSetup>(new CommonEnvironmentSetup(
      platform, errors,
      [&](const CommonEnvironmentSetup* setup) -> Environment* {
        return CreateEnvironment(
            setup->isolate_data(), setup->context(),
            std::forward<EnvironmentArgs>(env_args)...);
      }));
  if (!errors->empty()) ret.reset();
  return ret;
}",898.0,911.0,1.0,1.0,14.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,unique_ptr<CommonEnvironmentSetup>
3124,130569,CreateFromSnapshot,1,node.CommonEnvironmentSetup.CreateFromSnapshot,"ANY node.CommonEnvironmentSetup.CreateFromSnapshot<EnvironmentArgs> (MultiIsolatePlatform*,ANY*,EmbedderSnapshotData*,EnvironmentArgs)",node.hpp,"std::unique_ptr<CommonEnvironmentSetup>
CommonEnvironmentSetup::CreateFromSnapshot(
    MultiIsolatePlatform* platform,
    std::vector<std::string>* errors,
    const EmbedderSnapshotData* snapshot_data,
    EnvironmentArgs&&... env_args) {
  auto ret = std::unique_ptr<CommonEnvironmentSetup>(new CommonEnvironmentSetup(
      platform,
      errors,
      snapshot_data,
      Flags::kNoFlags,
      [&](const CommonEnvironmentSetup* setup) -> Environment* {
        return CreateEnvironment(setup->isolate_data(),
                                 setup->context(),
                                 std::forward<EnvironmentArgs>(env_args)...);
      }));
  if (!errors->empty()) ret.reset();
  return ret;
}",915.0,933.0,1.0,1.0,19.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,unique_ptr<CommonEnvironmentSetup>
3125,130620,operator =,1,node.CommonEnvironmentSetup.operator =,CommonEnvironmentSetup node.CommonEnvironmentSetup.operator = (CommonEnvironmentSetup),node.hpp,CommonEnvironmentSetup& operator=(const CommonEnvironmentSetup&) = delete;,871.0,871.0,3.0,76.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,CommonEnvironmentSetup
3126,130737,NODE_UNIXTIME_V8,1,node.NODE_UNIXTIME_V8,Local<v8::Value> node.NODE_UNIXTIME_V8 (double),node.hpp,"NODE_DEPRECATED(""Use v8::Date::New() directly"",
                inline v8::Local<v8::Value> NODE_UNIXTIME_V8(double time) {
                  return v8::Date::New(
                             v8::Isolate::GetCurrent()->GetCurrentContext(),
                             1000 * time)
                      .ToLocalChecked();
                })",936.0,942.0,1.0,18.0,7.0,7,3,5,2,0,0,1,1,0,0,,0,0,2,1,1,Local<v8.Value>
3127,130764,NODE_V8_UNIXTIME,1,node.NODE_V8_UNIXTIME,double node.NODE_V8_UNIXTIME (ANY),node.hpp,"NODE_DEPRECATED(""Use v8::Date::ValueOf() directly"",
                inline double NODE_V8_UNIXTIME(v8::Local<v8::Date> date) {
  return date->ValueOf() / 1000;
})",944.0,947.0,1.0,2.0,4.0,2,2,1,1,0,0,1,1,0,0,,0,0,2,1,1,double
3128,130776,NODE_SET_METHOD,1,node.NODE_SET_METHOD,"void node.NODE_SET_METHOD (ANY,char*,ANY)",node.hpp,"inline void NODE_SET_METHOD(v8::Local<v8::Object> recv,
                            const char* name,
                            v8::FunctionCallback callback) {
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> context = isolate->GetCurrentContext();
  v8::Local<v8::FunctionTemplate> t = v8::FunctionTemplate::New(isolate,
                                                                callback);
  v8::Local<v8::Function> fn = t->GetFunction(context).ToLocalChecked();
  v8::Local<v8::String> fn_name = v8::String::NewFromUtf8(isolate, name,
      v8::NewStringType::kInternalized).ToLocalChecked();
  fn->SetName(fn_name);
  recv->Set(context, fn_name, fn).Check();
}",1004.0,1017.0,1.0,1.0,14.0,22,5,25,11,0,0,1,1,0,0,,0,0,6,3,3,void
3129,130960,NODE_SET_PROTOTYPE_METHOD,1,node.NODE_SET_PROTOTYPE_METHOD,"void node.NODE_SET_PROTOTYPE_METHOD (ANY,char*,ANY)",node.hpp,"inline void NODE_SET_PROTOTYPE_METHOD(v8::Local<v8::FunctionTemplate> recv,
                                      const char* name,
                                      v8::FunctionCallback callback) {
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Signature> s = v8::Signature::New(isolate, recv);
  v8::Local<v8::FunctionTemplate> t =
      v8::FunctionTemplate::New(isolate, callback, v8::Local<v8::Value>(), s);
  v8::Local<v8::String> fn_name = v8::String::NewFromUtf8(isolate, name,
      v8::NewStringType::kInternalized).ToLocalChecked();
  t->SetClassName(fn_name);
  recv->PrototypeTemplate()->Set(fn_name, t);
}",1022.0,1034.0,1.0,1.0,13.0,31,5,34,13,0,0,1,1,0,0,,0,0,6,3,3,void
3130,131121,addon_register_func,1,node.addon_register_func,"void node.addon_register_func (ANY,ANY,void*)",node.hpp,"typedef void (*addon_register_func)(
    v8::Local<v8::Object> exports,
    v8::Local<v8::Value> module,
    void* priv);",1092.0,1095.0,14.0,15.0,4.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,void
3131,131128,addon_context_register_func,1,node.addon_context_register_func,"void node.addon_context_register_func (ANY,ANY,ANY,void*)",node.hpp,"typedef void (*addon_context_register_func)(
    v8::Local<v8::Object> exports,
    v8::Local<v8::Value> module,
    v8::Local<v8::Context> context,
    void* priv);",1097.0,1101.0,14.0,15.0,5.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,void
3132,131156,node_module_register,1,node.node_module_register,void node.node_module_register (void*),node_binding.cc,"void node_module_register(void* m) {
  struct node_module* mp = reinterpret_cast<struct node_module*>(m);

  if (mp->nm_flags & NM_F_INTERNAL) {
    mp->nm_link = modlist_internal;
    modlist_internal = mp;
  } else if (!node_is_initialized) {
    // ""Linked"" modules are included as part of the node project.
    // Like builtins they are registered *before* node::Init runs.
    mp->nm_flags = NM_F_LINKED;
    mp->nm_link = modlist_linked;
    modlist_linked = mp;
  } else {
    thread_local_modpending = mp;
  }
}",254.0,269.0,12.0,1.0,16.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
3133,131216,operator (),1,node.DeleteACHHandle.operator (),void node.DeleteACHHandle.operator () (ACHHandle*),node.hpp,void operator()(ACHHandle*) const;,1280.0,1280.0,43.0,70.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
3134,131322,operator =,1,node.CallbackScope.operator =,void node.CallbackScope.operator = (CallbackScope),node.hpp,void operator=(const CallbackScope&) = delete;,1376.0,1376.0,3.0,48.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
3135,131382,operator =,1,node.AsyncResource.operator =,void node.AsyncResource.operator = (AsyncResource),node.hpp,void operator=(const AsyncResource&) = delete;,1431.0,1431.0,3.0,48.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
3136,131422,RegisterSignalHandler,1,node.RegisterSignalHandler,"void node.RegisterSignalHandler (int,void,bool)",node.hpp,"void void (int, void  (*)(int, siginfo_t *, void *), bool);",1472.0,1476.0,6.0,54.0,5.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,void
3137,131430,<lambda>0,1,node_napi_env__.CallFinalizer.<lambda>0,ANY node_napi_env__.CallFinalizer.<lambda>0 (napi_env),node_api.cc,"[&](napi_env env) { cb(env, data, hint); }",48.0,48.0,7.0,48.0,1.0,0,0,3,3,0,0,1,1,0,0,,0,0,2,1,1,ANY
3138,131443,<lambda>1,1,node_napi_env__.EnqueueFinalizer.<lambda>1,ANY node_napi_env__.EnqueueFinalizer.<lambda>1 (ANY*),node_api.cc,"[this](node::Environment* node_env) {
      finalization_scheduled = false;
      Unref();
      DrainFinalizerQueue();
    }",60.0,64.0,30.0,5.0,5.0,1,1,1,1,0,1,1,1,0,0,,0,0,2,1,1,ANY
3139,131454,<lambda>2,1,node_napi_env__.CallbackIntoModule.<lambda>2,"ANY node_napi_env__.CallbackIntoModule.<lambda>2 (napi_env,ANY)",node_api.cc,"[](napi_env env_, v8::Local<v8::Value> local_err) {
    node_napi_env__* env = static_cast<node_napi_env__*>(env_);
    if (env->terminatedOrTerminating()) {
      return;
    }
    node::Environment* node_env = env->node_env();
    if (!node_env->options()->force_node_api_uncaught_exceptions_policy &&
        !enforceUncaughtExceptionPolicy) {
      ProcessEmitDeprecationWarning(
          node_env,
          ""Uncaught N-API callback exception detected, please run node ""
          ""with option --force-node-api-uncaught-exceptions-policy=true""
          ""to handle those exceptions properly."",
          ""DEP0168"");
      return;
    }
    // If there was an unhandled exception in the complete callback,
    // report it as a fatal exception. (There is no JavaScript on the
    // callstack that can possibly handle it.)
    env->trigger_fatal_exception(local_err);
  }",90.0,110.0,24.0,3.0,21.0,11,5,10,5,0,2,3,3,0,1,,0,1,4,2,2,ANY
3140,131503,<lambda>3,1,v8impl.anonymous_namespace_10.NewEnv.<lambda>3,ANY v8impl.anonymous_namespace_10.NewEnv.<lambda>3 (void*),node_api.cc,[](void* arg) { static_cast<napi_env>(arg)->Unref(); },193.0,193.0,7.0,60.0,1.0,2,2,1,1,0,1,1,1,0,0,,0,0,2,1,1,ANY
3141,131515,<lambda>4,1,v8impl.anonymous_namespace_24.ThreadSafeFunction.Init.<lambda>4,void v8impl.anonymous_namespace_24.ThreadSafeFunction.Init.<lambda>4 (uv_handle_t*),node_api.cc,"[](uv_handle_t* handle) -> void {
            ThreadSafeFunction* ts_fn =
                node::ContainerOf(&ThreadSafeFunction::async,
                                  reinterpret_cast<uv_async_t*>(handle));
            delete ts_fn;
          }",318.0,323.0,11.0,11.0,6.0,6,5,5,4,0,1,1,1,0,0,,0,1,2,1,1,void
3142,131538,<lambda>5,1,v8impl.anonymous_namespace_34.ThreadSafeFunction.DispatchOne.<lambda>5,ANY v8impl.anonymous_namespace_34.ThreadSafeFunction.DispatchOne.<lambda>5 (napi_env),node_api.cc,"[&](napi_env env) { call_js_cb(env, js_callback, context, data); }",416.0,416.0,11.0,76.0,1.0,0,0,4,4,0,2,1,1,0,0,,0,2,2,1,1,ANY
3143,131551,<lambda>6,1,v8impl.anonymous_namespace_38.ThreadSafeFunction.CloseHandlesAndMaybeDelete.<lambda>6,void v8impl.anonymous_namespace_38.ThreadSafeFunction.CloseHandlesAndMaybeDelete.<lambda>6 (uv_handle_t*),node_api.cc,"[](uv_handle_t* handle) -> void {
          ThreadSafeFunction* ts_fn =
              node::ContainerOf(&ThreadSafeFunction::async,
                                reinterpret_cast<uv_async_t*>(handle));
          ts_fn->Finalize();
        }",446.0,451.0,9.0,9.0,6.0,6,5,5,4,0,1,1,1,0,0,,0,1,2,1,1,void
3144,131575,<lambda>7,1,napi_module_register_by_symbol.<lambda>7,ANY napi_module_register_by_symbol.<lambda>7 (napi_env),node_api.cc,"[&](napi_env env) {
    _exports = init(env, v8impl::JsValueFromV8LocalValue(exports));
  }",724.0,726.0,23.0,3.0,3.0,2,2,4,4,0,1,1,1,0,1,,0,1,2,1,1,ANY
3145,131593,<lambda>8,1,napi_async_cleanup_hook_handle__.~napi_async_cleanup_hook_handle__.<lambda>8,ANY napi_async_cleanup_hook_handle__.~napi_async_cleanup_hook_handle__.<lambda>8 (ANY*),node_api.cc,[env = env_](node::Environment*) { env->Unref(); },799.0,799.0,9.0,58.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,0,2,1,1,ANY
3146,131604,<lambda>9,1,anonymous_namespace_82.uvimpl.Work.AfterThreadPoolWork.<lambda>9,ANY anonymous_namespace_82.uvimpl.Work.AfterThreadPoolWork.<lambda>9 (napi_env),node_api.cc,"[&](napi_env env) {
      _complete(env, ConvertUVErrorCode(status), _data);
    }",1193.0,1195.0,36.0,5.0,3.0,0,0,3,3,0,1,1,1,0,0,,0,1,2,1,1,ANY
3147,131656,node_napi_env__,1,node_napi_env__.node_napi_env__,"ANY node_napi_env__.node_napi_env__ (ANY,ANY,int32_t)",node_api.cc,"node_napi_env__::node_napi_env__(v8::Local<v8::Context> context,
                                 const std::string& module_filename,
                                 int32_t module_api_version)
    : napi_env__(context, module_api_version), filename(module_filename) {
  CHECK_NOT_NULL(node_env());
}",22.0,27.0,1.0,1.0,6.0,0,0,0,0,0,1,1,1,0,0,,0,0,6,3,3,ANY
3148,131665,DeleteMe,1,node_napi_env__.DeleteMe,void node_napi_env__.DeleteMe (),node_api.cc,"void node_napi_env__::DeleteMe() {
  destructing = true;
  DrainFinalizerQueue();
  napi_env__::DeleteMe();
}",29.0,33.0,1.0,1.0,5.0,2,2,2,2,0,2,1,1,0,0,,0,1,0,0,0,void
3149,131677,can_call_into_js,1,node_napi_env__.can_call_into_js,bool node_napi_env__.can_call_into_js (),node_api.cc,"bool node_napi_env__::can_call_into_js() const {
  return node_env()->can_call_into_js();
}",35.0,37.0,1.0,1.0,3.0,1,1,0,0,0,1,1,1,0,0,,0,0,0,0,0,bool
3150,131686,CallFinalizer,1,node_napi_env__.CallFinalizer,"void node_napi_env__.CallFinalizer (napi_finalize,void*,void*)",node_api.cc,"void node_napi_env__::CallFinalizer(napi_finalize cb, void* data, void* hint) {
  v8::HandleScope handle_scope(isolate);
  v8::Context::Scope context_scope(context());
  CallbackIntoModule<enforceUncaughtExceptionPolicy>(
      [&](napi_env env) { cb(env, data, hint); });
}",44.0,49.0,1.0,1.0,6.0,0,0,3,3,0,0,1,1,0,0,,0,0,6,3,3,void
3151,131710,EnqueueFinalizer,1,node_napi_env__.EnqueueFinalizer,void node_napi_env__.EnqueueFinalizer (ANY*),node_api.cc,"void node_napi_env__::EnqueueFinalizer(v8impl::RefTracker* finalizer) {
  napi_env__::EnqueueFinalizer(finalizer);
  // Schedule a second pass only when it has not been scheduled, and not
  // destructing the env.
  // When the env is being destructed, queued finalizers are drained in the
  // loop of `node_napi_env__::DrainFinalizerQueue`.
  if (!finalization_scheduled && !destructing) {
    finalization_scheduled = true;
    Ref();
    node_env()->SetImmediate([this](node::Environment* node_env) {
      finalization_scheduled = false;
      Unref();
      DrainFinalizerQueue();
    });
  }
}",51.0,66.0,1.0,1.0,16.0,6,5,5,4,0,4,2,2,2,0,,0,3,2,1,1,void
3152,131736,DrainFinalizerQueue,1,node_napi_env__.DrainFinalizerQueue,void node_napi_env__.DrainFinalizerQueue (),node_api.cc,"void node_napi_env__::DrainFinalizerQueue() {
  // As userland code can delete additional references in one finalizer,
  // the list of pending finalizers may be mutated as we execute them, so
  // we keep iterating it until it is empty.
  while (!pending_finalizers.empty()) {
    v8impl::RefTracker* ref_tracker = *pending_finalizers.begin();
    pending_finalizers.erase(ref_tracker);
    ref_tracker->Finalize();
  }
}",68.0,77.0,1.0,1.0,10.0,7,5,6,2,2,0,2,2,0,0,,0,0,0,0,0,void
3153,131764,trigger_fatal_exception,1,node_napi_env__.trigger_fatal_exception,void node_napi_env__.trigger_fatal_exception (ANY),node_api.cc,"void node_napi_env__::trigger_fatal_exception(v8::Local<v8::Value> local_err) {
  v8::Local<v8::Message> local_msg =
      v8::Exception::CreateMessage(isolate, local_err);
  node::errors::TriggerUncaughtException(isolate, local_err, local_msg);
}",79.0,83.0,1.0,1.0,5.0,9,4,12,7,2,1,1,1,0,1,,0,0,2,1,1,void
3154,131796,CallbackIntoModule,1,node_napi_env__.CallbackIntoModule,"void node_napi_env__.CallbackIntoModule<bool,T> (T)",node_api.cc,"void node_napi_env__::CallbackIntoModule(T&& call) {
  CallIntoModule(call, [](napi_env env_, v8::Local<v8::Value> local_err) {
    node_napi_env__* env = static_cast<node_napi_env__*>(env_);
    if (env->terminatedOrTerminating()) {
      return;
    }
    node::Environment* node_env = env->node_env();
    if (!node_env->options()->force_node_api_uncaught_exceptions_policy &&
        !enforceUncaughtExceptionPolicy) {
      ProcessEmitDeprecationWarning(
          node_env,
          ""Uncaught N-API callback exception detected, please run node ""
          ""with option --force-node-api-uncaught-exceptions-policy=true""
          ""to handle those exceptions properly."",
          ""DEP0168"");
      return;
    }
    // If there was an unhandled exception in the complete callback,
    // report it as a fatal exception. (There is no JavaScript on the
    // callstack that can possibly handle it.)
    env->trigger_fatal_exception(local_err);
  });
}",89.0,111.0,1.0,1.0,23.0,0,0,1,1,0,0,1,1,0,0,,0,0,2,1,1,void
3155,131807,New,1,v8impl.anonymous_namespace_2.BufferFinalizer.New,"BufferFinalizer v8impl.anonymous_namespace_2.BufferFinalizer.New (napi_env,napi_finalize,void*,void*)",node_api.cc,"static BufferFinalizer* New(napi_env env,
                              napi_finalize finalize_callback = nullptr,
                              void* finalize_data = nullptr,
                              void* finalize_hint = nullptr) {
    return new BufferFinalizer(
        env, finalize_callback, finalize_data, finalize_hint);
  }",119.0,125.0,3.0,3.0,7.0,1,1,5,5,0,0,1,1,0,0,,0,0,8,4,4,BufferFinalizer
3156,131822,FinalizeBufferCallback,1,v8impl.anonymous_namespace_3.BufferFinalizer.FinalizeBufferCallback,"void v8impl.anonymous_namespace_3.BufferFinalizer.FinalizeBufferCallback (char*,void*)",node_api.cc,"static void FinalizeBufferCallback(char* data, void* hint) {
    std::unique_ptr<BufferFinalizer, Deleter> finalizer{
        static_cast<BufferFinalizer*>(hint)};
    finalizer->finalize_data_ = data;

    // It is safe to call into JavaScript at this point.
    if (finalizer->finalize_callback_ == nullptr) return;
    finalizer->env_->CallFinalizer(finalizer->finalize_callback_,
                                   finalizer->finalize_data_,
                                   finalizer->finalize_hint_);
  }",127.0,137.0,3.0,3.0,11.0,12,5,9,3,0,0,2,2,0,0,,0,0,4,2,2,void
3157,131864,operator (),1,v8impl.anonymous_namespace_5.BufferFinalizer.Deleter.operator (),void v8impl.anonymous_namespace_5.BufferFinalizer.Deleter.operator () (BufferFinalizer*),node_api.cc,void operator()(BufferFinalizer* finalizer) { delete finalizer; },140.0,140.0,5.0,69.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,void
3158,131871,BufferFinalizer,1,v8impl.anonymous_namespace_6.BufferFinalizer.BufferFinalizer,"ANY v8impl.anonymous_namespace_6.BufferFinalizer.BufferFinalizer (napi_env,napi_finalize,void*,void*)",node_api.cc,"BufferFinalizer(napi_env env,
                  napi_finalize finalize_callback,
                  void* finalize_data,
                  void* finalize_hint)
      : Finalizer(env, finalize_callback, finalize_data, finalize_hint) {
    env_->Ref();
  }",144.0,150.0,3.0,3.0,7.0,1,1,1,1,0,1,1,1,0,0,,0,0,8,4,4,ANY
3159,131883,~BufferFinalizer,1,v8impl.anonymous_namespace_7.BufferFinalizer.~BufferFinalizer,ANY v8impl.anonymous_namespace_7.BufferFinalizer.~BufferFinalizer (),node_api.cc,~BufferFinalizer() { env_->Unref(); },152.0,152.0,3.0,39.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,0,0,0,0,ANY
3160,131891,ThrowNodeApiVersionError,1,v8impl.anonymous_namespace_8.ThrowNodeApiVersionError,"void v8impl.anonymous_namespace_8.ThrowNodeApiVersionError (ANY*,char*,int32_t)",node_api.cc,"void ThrowNodeApiVersionError(node::Environment* node_env,
                              const char* module_name,
                              int32_t module_api_version) {
  std::string error_message;
  error_message += module_name;
  error_message += "" requires Node-API version "";
  error_message += std::to_string(module_api_version);
  error_message += "", but this version of Node.js only supports version "";
  error_message += NODE_STRINGIFY(NAPI_VERSION) "" add-ons."";
  node_env->ThrowError(error_message.c_str());
}",155.0,165.0,1.0,19.0,11.0,8,3,10,5,0,0,1,1,0,0,,0,0,6,3,3,void
3161,131928,NewEnv,1,v8impl.anonymous_namespace_9.NewEnv,"napi_env v8impl.anonymous_namespace_9.NewEnv (ANY,ANY,int32_t)",node_api.cc,"inline napi_env NewEnv(v8::Local<v8::Context> context,
                       const std::string& module_filename,
                       int32_t module_api_version) {
  node_napi_env result;

  // Validate module_api_version.
  if (module_api_version < NODE_API_DEFAULT_MODULE_API_VERSION) {
    module_api_version = NODE_API_DEFAULT_MODULE_API_VERSION;
  } else if (module_api_version > NAPI_VERSION &&
             module_api_version != NAPI_VERSION_EXPERIMENTAL) {
    node::Environment* node_env = node::Environment::GetCurrent(context);
    CHECK_NOT_NULL(node_env);
    ThrowNodeApiVersionError(
        node_env, module_filename.c_str(), module_api_version);
    return nullptr;
  }

  result = new node_napi_env__(context, module_filename, module_api_version);
  // TODO(addaleax): There was previously code that tried to delete the
  // napi_env when its v8::Context was garbage collected;
  // However, as long as N-API addons using this napi_env are in place,
  // the Context needs to ...",167.0,197.0,1.0,27.0,31.0,7,5,10,5,0,0,2,2,0,0,,0,0,6,3,3,napi_env
3162,132004,ThreadSafeFunction,1,v8impl.anonymous_namespace_12.ThreadSafeFunction.ThreadSafeFunction,"ANY v8impl.anonymous_namespace_12.ThreadSafeFunction.ThreadSafeFunction (ANY,ANY,ANY,size_t,void*,size_t,node_napi_env,void*,napi_finalize,napi_threadsafe_function_call_js)",node_api.cc,"ThreadSafeFunction(v8::Local<v8::Function> func,
                     v8::Local<v8::Object> resource,
                     v8::Local<v8::String> name,
                     size_t thread_count_,
                     void* context_,
                     size_t max_queue_size_,
                     node_napi_env env_,
                     void* finalize_data_,
                     napi_finalize finalize_cb_,
                     napi_threadsafe_function_call_js call_js_cb_)
      : AsyncResource(env_->isolate,
                      resource,
                      *v8::String::Utf8Value(env_->isolate, name)),
        thread_count(thread_count_),
        is_closing(false),
        dispatch_state(kDispatchIdle),
        context(context_),
        max_queue_size(max_queue_size_),
        env(env_),
        finalize_data(finalize_data_),
        finalize_cb(finalize_cb_),
        call_js_cb(call_js_cb_ == nullptr ? CallJs : call_js_cb_),
        handles_closing(false) {
    ref.Reset(env->i...",201.0,227.0,3.0,3.0,27.0,5,2,6,4,0,5,1,1,0,1,,0,4,20,10,10,ANY
3163,132039,~ThreadSafeFunction,1,v8impl.anonymous_namespace_14.ThreadSafeFunction.~ThreadSafeFunction,ANY v8impl.anonymous_namespace_14.ThreadSafeFunction.~ThreadSafeFunction (),node_api.cc,"~ThreadSafeFunction() override {
    node::RemoveEnvironmentCleanupHook(env->isolate, Cleanup, this);
    env->Unref();
  }",229.0,232.0,3.0,3.0,4.0,3,2,3,2,0,3,1,1,0,1,,0,2,0,0,0,ANY
3164,132056,Push,1,v8impl.anonymous_namespace_16.ThreadSafeFunction.Push,"napi_status v8impl.anonymous_namespace_16.ThreadSafeFunction.Push (void*,napi_threadsafe_function_call_mode)",node_api.cc,"napi_status Push(void* data, napi_threadsafe_function_call_mode mode) {
    node::Mutex::ScopedLock lock(this->mutex);

    while (queue.size() >= max_queue_size && max_queue_size > 0 &&
           !is_closing) {
      if (mode == napi_tsfn_nonblocking) {
        return napi_queue_full;
      }
      cond->Wait(lock);
    }

    if (is_closing) {
      if (thread_count == 0) {
        return napi_invalid_arg;
      } else {
        thread_count--;
        return napi_closing;
      }
    } else {
      queue.push(data);
      Send();
      return napi_ok;
    }
  }",236.0,259.0,3.0,3.0,24.0,10,7,12,10,0,8,5,7,6,0,,0,8,4,2,2,napi_status
3165,132120,Acquire,1,v8impl.anonymous_namespace_18.ThreadSafeFunction.Acquire,napi_status v8impl.anonymous_namespace_18.ThreadSafeFunction.Acquire (),node_api.cc,"napi_status Acquire() {
    node::Mutex::ScopedLock lock(this->mutex);

    if (is_closing) {
      return napi_closing;
    }

    thread_count++;

    return napi_ok;
  }",261.0,271.0,3.0,3.0,11.0,2,2,4,4,0,3,2,2,1,0,,0,3,0,0,0,napi_status
3166,132138,Release,1,v8impl.anonymous_namespace_19.ThreadSafeFunction.Release,napi_status v8impl.anonymous_namespace_19.ThreadSafeFunction.Release (napi_threadsafe_function_release_mode),node_api.cc,"napi_status Release(napi_threadsafe_function_release_mode mode) {
    node::Mutex::ScopedLock lock(this->mutex);

    if (thread_count == 0) {
      return napi_invalid_arg;
    }

    thread_count--;

    if (thread_count == 0 || mode == napi_tsfn_abort) {
      if (!is_closing) {
        is_closing = (mode == napi_tsfn_abort);
        if (is_closing && max_queue_size > 0) {
          cond->Signal(lock);
        }
        Send();
      }
    }

    return napi_ok;
  }",273.0,293.0,3.0,3.0,21.0,12,8,15,9,0,9,5,8,5,0,,0,9,2,1,1,napi_status
3167,132190,EmptyQueueAndDelete,1,v8impl.anonymous_namespace_21.ThreadSafeFunction.EmptyQueueAndDelete,void v8impl.anonymous_namespace_21.ThreadSafeFunction.EmptyQueueAndDelete (),node_api.cc,"void EmptyQueueAndDelete() {
    for (; !queue.empty(); queue.pop()) {
      call_js_cb(nullptr, nullptr, context, queue.front());
    }
    delete this;
  }",295.0,300.0,3.0,3.0,6.0,4,3,3,2,0,3,2,2,1,0,,0,3,0,0,0,void
3168,132216,Init,1,v8impl.anonymous_namespace_22.ThreadSafeFunction.Init,napi_status v8impl.anonymous_namespace_22.ThreadSafeFunction.Init (),node_api.cc,"napi_status Init() {
    ThreadSafeFunction* ts_fn = this;
    uv_loop_t* loop = env->node_env()->event_loop();

    if (uv_async_init(loop, &async, AsyncCb) == 0) {
      if (max_queue_size > 0) {
        cond = std::make_unique<node::ConditionVariable>();
      }
      if (max_queue_size == 0 || cond) {
        return napi_ok;
      }

      env->node_env()->CloseHandle(
          reinterpret_cast<uv_handle_t*>(&async),
          [](uv_handle_t* handle) -> void {
            ThreadSafeFunction* ts_fn =
                node::ContainerOf(&ThreadSafeFunction::async,
                                  reinterpret_cast<uv_async_t*>(handle));
            delete ts_fn;
          });

      // Prevent the thread-safe function from being deleted here, because
      // the callback above will delete it.
      ts_fn = nullptr;
    }

    delete ts_fn;

    return napi_generic_failure;
  }",304.0,333.0,3.0,3.0,30.0,17,9,16,9,0,10,4,6,4,0,,0,9,0,0,0,napi_status
3169,132282,Unref,1,v8impl.anonymous_namespace_25.ThreadSafeFunction.Unref,napi_status v8impl.anonymous_namespace_25.ThreadSafeFunction.Unref (),node_api.cc,"napi_status Unref() {
    uv_unref(reinterpret_cast<uv_handle_t*>(&async));

    return napi_ok;
  }",335.0,339.0,3.0,3.0,5.0,2,2,2,2,0,1,1,1,0,0,,0,1,0,0,0,napi_status
3170,132293,Ref,1,v8impl.anonymous_namespace_26.ThreadSafeFunction.Ref,napi_status v8impl.anonymous_namespace_26.ThreadSafeFunction.Ref (),node_api.cc,"napi_status Ref() {
    uv_ref(reinterpret_cast<uv_handle_t*>(&async));

    return napi_ok;
  }",341.0,345.0,3.0,3.0,5.0,2,2,2,2,0,1,1,1,0,0,,0,1,0,0,0,napi_status
3171,132304,Context,1,v8impl.anonymous_namespace_27.ThreadSafeFunction.Context,void* v8impl.anonymous_namespace_27.ThreadSafeFunction.Context (),node_api.cc,inline void* Context() { return context; },347.0,347.0,3.0,44.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,void*
3172,132310,Dispatch,1,v8impl.anonymous_namespace_28.ThreadSafeFunction.Dispatch,void v8impl.anonymous_namespace_28.ThreadSafeFunction.Dispatch (),node_api.cc,"void Dispatch() {
    bool has_more = true;

    // Limit maximum synchronous iteration count to prevent event loop
    // starvation. See `src/node_messaging.cc` for an inspiration.
    unsigned int iterations_left = kMaxIterationCount;
    while (has_more && --iterations_left != 0) {
      dispatch_state = kDispatchRunning;
      has_more = DispatchOne();

      // Send() was called while we were executing the JS function
      if (dispatch_state.exchange(kDispatchIdle) != kDispatchRunning) {
        has_more = true;
      }
    }

    if (has_more) {
      Send();
    }
  }",350.0,369.0,3.0,3.0,20.0,10,5,13,6,0,6,4,5,3,0,,0,6,0,0,0,void
3173,132352,DispatchOne,1,v8impl.anonymous_namespace_31.ThreadSafeFunction.DispatchOne,bool v8impl.anonymous_namespace_31.ThreadSafeFunction.DispatchOne (),node_api.cc,"bool DispatchOne() {
    void* data = nullptr;
    bool popped_value = false;
    bool has_more = false;

    {
      node::Mutex::ScopedLock lock(this->mutex);
      if (is_closing) {
        CloseHandlesAndMaybeDelete();
      } else {
        size_t size = queue.size();
        if (size > 0) {
          data = queue.front();
          queue.pop();
          popped_value = true;
          if (size == max_queue_size && max_queue_size > 0) {
            cond->Signal(lock);
          }
          size--;
        }

        if (size == 0) {
          if (thread_count == 0) {
            is_closing = true;
            if (max_queue_size > 0) {
              cond->Signal(lock);
            }
            CloseHandlesAndMaybeDelete();
          }
        } else {
          has_more = true;
        }
      }
    }

    if (popped_value) {
      v8::HandleScope scope(env->isolate);
      CallbackScope cb_scope(this);
      napi_value js_callback = nullptr;
      if (!ref.IsEmpty()) {
       ...",371.0,420.0,3.0,3.0,50.0,22,6,20,10,0,8,4,5,2,1,,0,8,0,0,0,bool
3174,132510,Finalize,1,v8impl.anonymous_namespace_35.ThreadSafeFunction.Finalize,void v8impl.anonymous_namespace_35.ThreadSafeFunction.Finalize (),node_api.cc,"void Finalize() {
    v8::HandleScope scope(env->isolate);
    if (finalize_cb) {
      CallbackScope cb_scope(this);
      env->CallFinalizer<false>(finalize_cb, finalize_data, context);
    }
    EmptyQueueAndDelete();
  }",422.0,429.0,3.0,3.0,8.0,2,1,6,4,0,6,2,2,1,0,,0,6,0,0,0,void
3175,132533,CloseHandlesAndMaybeDelete,1,v8impl.anonymous_namespace_37.ThreadSafeFunction.CloseHandlesAndMaybeDelete,void v8impl.anonymous_namespace_37.ThreadSafeFunction.CloseHandlesAndMaybeDelete (bool),node_api.cc,"void CloseHandlesAndMaybeDelete(bool set_closing = false) {
    v8::HandleScope scope(env->isolate);
    if (set_closing) {
      node::Mutex::ScopedLock lock(this->mutex);
      is_closing = true;
      if (max_queue_size > 0) {
        cond->Signal(lock);
      }
    }
    if (handles_closing) {
      return;
    }
    handles_closing = true;
    env->node_env()->CloseHandle(
        reinterpret_cast<uv_handle_t*>(&async),
        [](uv_handle_t* handle) -> void {
          ThreadSafeFunction* ts_fn =
              node::ContainerOf(&ThreadSafeFunction::async,
                                reinterpret_cast<uv_async_t*>(handle));
          ts_fn->Finalize();
        });
  }",431.0,452.0,3.0,3.0,22.0,10,5,10,8,0,10,4,5,2,0,,0,9,2,1,1,void
3176,132583,Send,1,v8impl.anonymous_namespace_39.ThreadSafeFunction.Send,void v8impl.anonymous_namespace_39.ThreadSafeFunction.Send (),node_api.cc,"void Send() {
    // Ask currently running Dispatch() to make one more iteration
    unsigned char current_state = dispatch_state.fetch_or(kDispatchPending);
    if ((current_state & kDispatchRunning) == kDispatchRunning) {
      return;
    }

    CHECK_EQ(0, uv_async_send(&async));
  }",454.0,462.0,3.0,3.0,9.0,5,5,7,5,0,5,2,2,2,0,,0,5,0,0,0,void
3177,132608,CallJs,1,v8impl.anonymous_namespace_40.ThreadSafeFunction.CallJs,"void v8impl.anonymous_namespace_40.ThreadSafeFunction.CallJs (napi_env,napi_value,void*,void*)",node_api.cc,"static void CallJs(napi_env env, napi_value cb, void* context, void* data) {
    if (!(env == nullptr || cb == nullptr)) {
      napi_value recv;
      napi_status status;

      status = napi_get_undefined(env, &recv);
      if (status != napi_ok) {
        napi_throw_error(env,
                         ""ERR_NAPI_TSFN_GET_UNDEFINED"",
                         ""Failed to retrieve undefined value"");
        return;
      }

      status = napi_call_function(env, recv, cb, 0, nullptr, nullptr);
      if (status != napi_ok && status != napi_pending_exception) {
        napi_throw_error(
            env, ""ERR_NAPI_TSFN_CALL_JS"", ""Failed to call JS callback"");
        return;
      }
    }
  }",466.0,486.0,3.0,3.0,21.0,11,7,17,6,0,4,4,6,0,4,,0,2,8,4,4,void
3178,132667,AsyncCb,1,v8impl.anonymous_namespace_41.ThreadSafeFunction.AsyncCb,void v8impl.anonymous_namespace_41.ThreadSafeFunction.AsyncCb (uv_async_t*),node_api.cc,"static void AsyncCb(uv_async_t* async) {
    ThreadSafeFunction* ts_fn =
        node::ContainerOf(&ThreadSafeFunction::async, async);
    ts_fn->Dispatch();
  }",488.0,492.0,3.0,3.0,5.0,5,4,5,4,0,1,1,1,0,0,,0,1,2,1,1,void
3179,132688,Cleanup,1,v8impl.anonymous_namespace_42.ThreadSafeFunction.Cleanup,void v8impl.anonymous_namespace_42.ThreadSafeFunction.Cleanup (void*),node_api.cc,"static void Cleanup(void* data) {
    reinterpret_cast<ThreadSafeFunction*>(data)->CloseHandlesAndMaybeDelete(
        true);
  }",494.0,497.0,3.0,3.0,4.0,2,2,1,1,0,0,1,1,0,0,,0,0,2,1,1,void
3180,132740,AsyncContext,1,v8impl.anonymous_namespace_44.AsyncContext.AsyncContext,"ANY v8impl.anonymous_namespace_44.AsyncContext.AsyncContext (node_napi_env,ANY,ANY,bool)",node_api.cc,"AsyncContext(node_napi_env env,
               v8::Local<v8::Object> resource_object,
               const v8::Local<v8::String> resource_name,
               bool externally_managed_resource)
      : env_(env) {
    async_id_ = node_env()->new_async_id();
    trigger_async_id_ = node_env()->get_default_trigger_async_id();
    resource_.Reset(node_env()->isolate(), resource_object);
    lost_reference_ = false;
    if (externally_managed_resource) {
      resource_.SetWeak(
          this, AsyncContext::WeakCallback, v8::WeakCallbackType::kParameter);
    }

    node::AsyncWrap::EmitAsyncInit(node_env(),
                                   resource_object,
                                   resource_name,
                                   async_id_,
                                   trigger_async_id_);
  }",537.0,556.0,3.0,3.0,20.0,13,3,16,12,0,8,2,2,0,1,,0,7,8,4,4,ANY
3181,132799,~AsyncContext,1,v8impl.anonymous_namespace_49.AsyncContext.~AsyncContext,ANY v8impl.anonymous_namespace_49.AsyncContext.~AsyncContext (),node_api.cc,"~AsyncContext() {
    resource_.Reset();
    lost_reference_ = true;
    node::AsyncWrap::EmitDestroy(node_env(), async_id_);
  }",558.0,562.0,3.0,3.0,5.0,4,2,5,5,0,4,1,1,0,1,,0,3,0,0,0,ANY
3182,132818,MakeCallback,1,v8impl.anonymous_namespace_51.AsyncContext.MakeCallback,"MaybeLocal<v8::Value> v8impl.anonymous_namespace_51.AsyncContext.MakeCallback (ANY,ANY,int,ANY[])",node_api.cc,"inline v8::MaybeLocal<v8::Value> MakeCallback(
      v8::Local<v8::Object> recv,
      const v8::Local<v8::Function> callback,
      int argc,
      v8::Local<v8::Value> argv[]) {
    EnsureReference();
    return node::InternalMakeCallback(node_env(),
                                      resource(),
                                      recv,
                                      callback,
                                      argc,
                                      argv,
                                      {async_id_, trigger_async_id_});
  }",564.0,577.0,3.0,3.0,14.0,2,2,7,7,0,3,1,1,0,1,,0,2,8,4,4,MaybeLocal<v8.Value>
3183,132841,OpenCallbackScope,1,v8impl.anonymous_namespace_55.AsyncContext.OpenCallbackScope,napi_callback_scope v8impl.anonymous_namespace_55.AsyncContext.OpenCallbackScope (),node_api.cc,"inline napi_callback_scope OpenCallbackScope() {
    EnsureReference();
    napi_callback_scope it =
        reinterpret_cast<napi_callback_scope>(new CallbackScope(this));
    env_->open_callback_scopes++;
    return it;
  }",579.0,585.0,3.0,3.0,7.0,5,5,4,3,0,1,1,1,0,0,,0,1,0,0,0,napi_callback_scope
3184,132860,EnsureReference,1,v8impl.anonymous_namespace_57.AsyncContext.EnsureReference,void v8impl.anonymous_namespace_57.AsyncContext.EnsureReference (),node_api.cc,"inline void EnsureReference() {
    if (lost_reference_) {
      const v8::HandleScope handle_scope(node_env()->isolate());
      resource_.Reset(node_env()->isolate(),
                      v8::Object::New(node_env()->isolate()));
      lost_reference_ = false;
    }
  }",587.0,594.0,3.0,3.0,8.0,7,3,5,4,0,3,2,2,1,0,,0,3,0,0,0,void
3185,132894,node_env,1,v8impl.anonymous_namespace_61.AsyncContext.node_env,Environment v8impl.anonymous_namespace_61.AsyncContext.node_env (),node_api.cc,inline node::Environment* node_env() { return env_->node_env(); },596.0,596.0,3.0,67.0,1.0,1,1,1,1,0,2,1,1,0,0,,0,1,0,0,0,Environment
3186,132903,resource,1,v8impl.anonymous_namespace_62.AsyncContext.resource,Local<v8::Object> v8impl.anonymous_namespace_62.AsyncContext.resource (),node_api.cc,"inline v8::Local<v8::Object> resource() {
    return resource_.Get(node_env()->isolate());
  }",597.0,599.0,3.0,3.0,3.0,2,2,1,1,0,1,1,1,0,0,,0,1,0,0,0,Local<v8.Object>
3187,132916,async_context,1,v8impl.anonymous_namespace_64.AsyncContext.async_context,async_context v8impl.anonymous_namespace_64.AsyncContext.async_context (),node_api.cc,"inline node::async_context async_context() {
    return {async_id_, trigger_async_id_};
  }",600.0,602.0,3.0,3.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,async_context
3188,132921,CloseCallbackScope,1,v8impl.anonymous_namespace_65.AsyncContext.CloseCallbackScope,"void v8impl.anonymous_namespace_65.AsyncContext.CloseCallbackScope (node_napi_env,napi_callback_scope)",node_api.cc,"static inline void CloseCallbackScope(node_napi_env env,
                                        napi_callback_scope s) {
    CallbackScope* callback_scope = reinterpret_cast<CallbackScope*>(s);
    delete callback_scope;
    env->open_callback_scopes--;
  }",604.0,609.0,3.0,3.0,6.0,5,5,4,3,0,0,1,1,0,0,,0,0,4,2,2,void
3189,132939,WeakCallback,1,v8impl.anonymous_namespace_66.AsyncContext.WeakCallback,void v8impl.anonymous_namespace_66.AsyncContext.WeakCallback (ANY),node_api.cc,"static void WeakCallback(const v8::WeakCallbackInfo<AsyncContext>& data) {
    AsyncContext* async_context = data.GetParameter();
    async_context->resource_.Reset();
    async_context->lost_reference_ = true;
  }",611.0,615.0,3.0,3.0,5.0,6,3,4,2,0,2,1,1,0,0,,0,2,2,1,1,void
3190,132963,CallbackScope,1,v8impl.anonymous_namespace_68.AsyncContext.CallbackScope.CallbackScope,ANY v8impl.anonymous_namespace_68.AsyncContext.CallbackScope.CallbackScope (AsyncContext*),node_api.cc,"explicit CallbackScope(AsyncContext* async_context)
        : node::CallbackScope(async_context->node_env(),
                              async_context->resource_.Get(
                                  async_context->node_env()->isolate()),
                              async_context->async_context()) {}",620.0,624.0,5.0,64.0,5.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
3191,132973,napi_module_register_cb,1,napi_module_register_cb,"void napi_module_register_cb (ANY,ANY,ANY,void*)",node_api.cc,"static void napi_module_register_cb(v8::Local<v8::Object> exports,
                                    v8::Local<v8::Value> module,
                                    v8::Local<v8::Context> context,
                                    void* priv) {
  napi_module_register_by_symbol(
      exports,
      module,
      context,
      static_cast<const napi_module*>(priv)->nm_register_func);
}",641.0,650.0,1.0,1.0,10.0,2,2,4,4,0,1,1,1,0,1,,0,0,8,4,4,void
3192,132990,node_api_context_register_func,1,node_api_context_register_func,"void node_api_context_register_func<int32_t> (ANY,ANY,ANY,void*)",node_api.cc,"static void node_api_context_register_func(v8::Local<v8::Object> exports,
                                           v8::Local<v8::Value> module,
                                           v8::Local<v8::Context> context,
                                           void* priv) {
  napi_module_register_by_symbol(
      exports,
      module,
      context,
      reinterpret_cast<napi_addon_register_func>(priv),
      module_api_version);
}",653.0,663.0,1.0,1.0,11.0,1,1,5,5,0,1,1,1,0,1,,0,0,8,4,4,void
3193,133006,get_node_api_context_register_func,1,get_node_api_context_register_func,"addon_context_register_func get_node_api_context_register_func (ANY*,char*,int32_t)",node_api.cc,"node::addon_context_register_func get_node_api_context_register_func(
    node::Environment* node_env,
    const char* module_name,
    int32_t module_api_version) {
  static_assert(
      NAPI_VERSION == 8,
      ""New version of Node-API requires adding another else-if statement below ""
      ""for the new version and updating this assert condition."");
  if (module_api_version <= NODE_API_DEFAULT_MODULE_API_VERSION) {
    return node_api_context_register_func<NODE_API_DEFAULT_MODULE_API_VERSION>;
  } else if (module_api_version == NAPI_VERSION_EXPERIMENTAL) {
    return node_api_context_register_func<NAPI_VERSION_EXPERIMENTAL>;
  } else {
    v8impl::ThrowNodeApiVersionError(node_env, module_name, module_api_version);
    return nullptr;
  }
}",671.0,687.0,1.0,6.0,17.0,2,2,2,2,0,0,2,2,0,0,,0,0,6,3,3,addon_context_register_func
3194,133051,napi_module_register_by_symbol,1,napi_module_register_by_symbol,"void napi_module_register_by_symbol (ANY,ANY,ANY,napi_addon_register_func,int32_t)",node_api.cc,"void napi_module_register_by_symbol(v8::Local<v8::Object> exports,
                                    v8::Local<v8::Value> module,
                                    v8::Local<v8::Context> context,
                                    napi_addon_register_func init,
                                    int32_t module_api_version) {
  node::Environment* node_env = node::Environment::GetCurrent(context);
  std::string module_filename = """";
  if (init == nullptr) {
    CHECK_NOT_NULL(node_env);
    node_env->ThrowError(""Module has no declared entry point."");
    return;
  }

  // We set `env->filename` from `module.filename` here, but we could just as
  // easily add a private property to `exports` in `process.dlopen`, which
  // receives the file name from JS, and retrieve *that* here. Thus, we are not
  // endorsing commonjs here by making use of `module.filename`.
  v8::Local<v8::Value> filename_js;
  v8::Local<v8::Object> modobj;
  if (module->ToObject(context).ToLocal(&modobj) &&
 ...",689.0,736.0,1.0,1.0,48.0,39,9,45,18,2,4,4,4,1,4,,0,3,10,5,5,void
3195,133199,napi_module_to_node_module,1,node.napi_module_to_node_module,node_module node.napi_module_to_node_module (napi_module*),node_api.cc,"node_module napi_module_to_node_module(const napi_module* mod) {
  return {
      -1,
      mod->nm_flags | NM_F_DELETEME,
      nullptr,
      mod->nm_filename,
      nullptr,
      napi_module_register_cb,
      mod->nm_modname,
      const_cast<napi_module*>(mod),  // priv
      nullptr,
  };
}",739.0,751.0,1.0,1.0,13.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,node_module
3196,133205,napi_module_register,1,napi_module_register,void napi_module_register (napi_module*),node_api.cc,"void NAPI_CDECL napi_module_register(napi_module* mod) {
  node::node_module* nm =
      new node::node_module(node::napi_module_to_node_module(mod));
  node::node_module_register(nm);
}",755.0,759.0,1.0,5.0,5.0,4,3,6,4,0,2,1,1,0,2,,0,1,2,1,1,void
3197,133225,napi_add_env_cleanup_hook,1,napi_add_env_cleanup_hook,"napi_status napi_add_env_cleanup_hook (napi_env,napi_cleanup_hook,void*)",node_api.cc,"napi_status NAPI_CDECL napi_add_env_cleanup_hook(napi_env env,
                                                 napi_cleanup_hook fun,
                                                 void* arg) {
  CHECK_ENV(env);
  CHECK_ARG(env, fun);

  node::AddEnvironmentCleanupHook(env->isolate, fun, arg);

  return napi_ok;
}",761.0,770.0,1.0,12.0,10.0,5,5,13,6,0,2,1,1,0,2,,0,0,6,3,3,napi_status
3198,133273,napi_remove_env_cleanup_hook,1,napi_remove_env_cleanup_hook,"napi_status napi_remove_env_cleanup_hook (napi_env,napi_cleanup_hook,void*)",node_api.cc,"napi_status NAPI_CDECL napi_remove_env_cleanup_hook(napi_env env,
                                                    napi_cleanup_hook fun,
                                                    void* arg) {
  CHECK_ENV(env);
  CHECK_ARG(env, fun);

  node::RemoveEnvironmentCleanupHook(env->isolate, fun, arg);

  return napi_ok;
}",772.0,781.0,1.0,12.0,10.0,5,5,13,6,0,2,1,1,0,2,,0,0,6,3,3,napi_status
3199,133321,napi_async_cleanup_hook_handle__,1,napi_async_cleanup_hook_handle__.napi_async_cleanup_hook_handle__,"ANY napi_async_cleanup_hook_handle__.napi_async_cleanup_hook_handle__ (napi_env,napi_async_cleanup_hook,void*)",node_api.cc,"napi_async_cleanup_hook_handle__(napi_env env,
                                   napi_async_cleanup_hook user_hook,
                                   void* user_data)
      : env_(env), user_hook_(user_hook), user_data_(user_data) {
    handle_ = node::AddEnvironmentCleanupHook(env->isolate, Hook, this);
    env->Ref();
  }",784.0,790.0,3.0,3.0,7.0,4,3,4,3,0,2,1,1,0,1,,0,2,6,3,3,ANY
3200,133343,~napi_async_cleanup_hook_handle__,1,napi_async_cleanup_hook_handle__.~napi_async_cleanup_hook_handle__,ANY napi_async_cleanup_hook_handle__.~napi_async_cleanup_hook_handle__ (),node_api.cc,"~napi_async_cleanup_hook_handle__() {
    node::RemoveEnvironmentCleanupHook(std::move(handle_));
    if (done_cb_ != nullptr) done_cb_(done_data_);

    // Release the `env` handle asynchronously since it would be surprising if
    // a call to a N-API function would destroy `env` synchronously.
    static_cast<node_napi_env>(env_)->node_env()->SetImmediate(
        [env = env_](node::Environment*) { env->Unref(); });
  }",792.0,800.0,3.0,3.0,9.0,6,4,6,6,0,6,2,2,0,2,,0,3,0,0,0,ANY
3201,133373,Hook,1,napi_async_cleanup_hook_handle__.Hook,"void napi_async_cleanup_hook_handle__.Hook (void*,void,void*)",node_api.cc,"static void Hook(void* data, void (*done_cb)(void*), void* done_data) {
    napi_async_cleanup_hook_handle__* handle =
        static_cast<napi_async_cleanup_hook_handle__*>(data);
    handle->done_cb_ = done_cb;
    handle->done_data_ = done_data;
    handle->user_hook_(handle, handle->user_data_);
  }",802.0,808.0,3.0,3.0,7.0,8,3,9,4,0,3,1,1,0,0,,0,3,6,3,3,void
3202,133408,done_cb_,1,napi_async_cleanup_hook_handle__.done_cb_,void napi_async_cleanup_hook_handle__.done_cb_ (void*),node_api.cc,void (*done_cb_)(void*) = nullptr;,814.0,814.0,8.0,35.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
3203,133433,napi_add_async_cleanup_hook,1,napi_add_async_cleanup_hook,"napi_status napi_add_async_cleanup_hook (napi_env,napi_async_cleanup_hook,void*,napi_async_cleanup_hook_handle*)",node_api.cc,"napi_status NAPI_CDECL
napi_add_async_cleanup_hook(napi_env env,
                            napi_async_cleanup_hook hook,
                            void* arg,
                            napi_async_cleanup_hook_handle* remove_handle) {
  CHECK_ENV(env);
  CHECK_ARG(env, hook);

  napi_async_cleanup_hook_handle__* handle =
      new napi_async_cleanup_hook_handle__(env, hook, arg);

  if (remove_handle != nullptr) *remove_handle = handle;

  return napi_clear_last_error(env);
}",818.0,832.0,1.0,12.0,15.0,8,6,17,7,0,2,2,2,0,2,,0,0,8,4,4,napi_status
3204,133491,napi_remove_async_cleanup_hook,1,napi_remove_async_cleanup_hook,napi_status napi_remove_async_cleanup_hook (napi_async_cleanup_hook_handle),node_api.cc,"napi_status NAPI_CDECL
napi_remove_async_cleanup_hook(napi_async_cleanup_hook_handle remove_handle) {
  if (remove_handle == nullptr) return napi_invalid_arg;

  delete remove_handle;

  return napi_ok;
}",834.0,841.0,1.0,12.0,8.0,2,2,4,3,0,0,2,2,0,0,,0,0,2,1,1,napi_status
3205,133507,napi_fatal_exception,1,napi_fatal_exception,"napi_status napi_fatal_exception (napi_env,napi_value)",node_api.cc,"napi_status NAPI_CDECL napi_fatal_exception(napi_env env, napi_value err) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, err);

  v8::Local<v8::Value> local_err = v8impl::V8LocalValueFromJsValue(err);
  static_cast<node_napi_env>(env)->trigger_fatal_exception(local_err);

  return napi_clear_last_error(env);
}",843.0,851.0,1.0,12.0,9.0,16,10,22,7,0,6,3,4,0,6,,0,1,4,2,2,napi_status
3206,133594,napi_fatal_error,1,napi_fatal_error,"void napi_fatal_error (char*,size_t,char*,size_t)",node_api.cc,"void NAPI_CDECL napi_fatal_error(const char* location,
                                                size_t location_len,
                                                const char* message,
                                                size_t message_len) {
  std::string location_string;
  std::string message_string;

  if (location_len != NAPI_AUTO_LENGTH) {
    location_string.assign(const_cast<char*>(location), location_len);
  } else {
    location_string.assign(const_cast<char*>(location), strlen(location));
  }

  if (message_len != NAPI_AUTO_LENGTH) {
    message_string.assign(const_cast<char*>(message), message_len);
  } else {
    message_string.assign(const_cast<char*>(message), strlen(message));
  }

  node::OnFatalError(location_string.c_str(), message_string.c_str());
}",853.0,873.0,16.0,20.0,21.0,9,3,13,8,0,1,3,3,0,1,,0,0,8,4,4,void
3207,133668,napi_open_callback_scope,1,napi_open_callback_scope,"napi_status napi_open_callback_scope (napi_env,napi_value,napi_async_context,napi_callback_scope*)",node_api.cc,"napi_status NAPI_CDECL
napi_open_callback_scope(napi_env env,
                         napi_value /** ignored */,
                         napi_async_context async_context_handle,
                         napi_callback_scope* result) {
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  v8impl::AsyncContext* node_async_context =
      reinterpret_cast<v8impl::AsyncContext*>(async_context_handle);

  *result = node_async_context->OpenCallbackScope();

  return napi_clear_last_error(env);
}",875.0,891.0,1.0,12.0,17.0,8,7,13,5,0,2,1,1,0,2,,0,0,8,4,4,napi_status
3208,133722,napi_close_callback_scope,1,napi_close_callback_scope,"napi_status napi_close_callback_scope (napi_env,napi_callback_scope)",node_api.cc,"napi_status NAPI_CDECL napi_close_callback_scope(napi_env env,
                                                 napi_callback_scope scope) {
  // Omit NAPI_PREAMBLE and GET_RETURN_STATUS because V8 calls here cannot throw
  // JS exceptions.
  CHECK_ENV(env);
  CHECK_ARG(env, scope);
  if (env->open_callback_scopes == 0) {
    return napi_callback_scope_mismatch;
  }

  v8impl::AsyncContext::CloseCallbackScope(reinterpret_cast<node_napi_env>(env),
                                           scope);

  return napi_clear_last_error(env);
}",893.0,907.0,1.0,12.0,15.0,8,6,15,6,0,2,2,2,0,2,,0,0,4,2,2,napi_status
3209,133780,napi_async_init,1,napi_async_init,"napi_status napi_async_init (napi_env,napi_value,napi_value,napi_async_context*)",node_api.cc,"napi_status NAPI_CDECL napi_async_init(napi_env env,
                                       napi_value async_resource,
                                       napi_value async_resource_name,
                                       napi_async_context* result) {
  CHECK_ENV(env);
  CHECK_ARG(env, async_resource_name);
  CHECK_ARG(env, result);

  v8::Isolate* isolate = env->isolate;
  v8::Local<v8::Context> context = env->context();

  v8::Local<v8::Object> v8_resource;
  bool externally_managed_resource;
  if (async_resource != nullptr) {
    CHECK_TO_OBJECT(env, context, v8_resource, async_resource);
    externally_managed_resource = true;
  } else {
    v8_resource = v8::Object::New(isolate);
    externally_managed_resource = false;
  }

  v8::Local<v8::String> v8_resource_name;
  CHECK_TO_STRING(env, context, v8_resource_name, async_resource_name);

  v8impl::AsyncContext* async_context =
      new v8impl::AsyncContext(reinterpret_cast<node_napi_env>(env),
                          ...",909.0,942.0,1.0,12.0,34.0,49,11,68,18,0,7,2,2,0,7,,0,0,8,4,4,napi_status
3210,134028,napi_async_destroy,1,napi_async_destroy,"napi_status napi_async_destroy (napi_env,napi_async_context)",node_api.cc,"napi_status NAPI_CDECL napi_async_destroy(napi_env env,
                                          napi_async_context async_context) {
  CHECK_ENV(env);
  CHECK_ARG(env, async_context);

  v8impl::AsyncContext* node_async_context =
      reinterpret_cast<v8impl::AsyncContext*>(async_context);

  delete node_async_context;

  return napi_clear_last_error(env);
}",944.0,955.0,1.0,12.0,12.0,6,6,12,4,0,2,1,1,0,2,,0,0,4,2,2,napi_status
3211,134075,napi_make_callback,1,napi_make_callback,"napi_status napi_make_callback (napi_env,napi_async_context,napi_value,napi_value,size_t,napi_value*,napi_value*)",node_api.cc,"napi_status NAPI_CDECL napi_make_callback(napi_env env,
                                          napi_async_context async_context,
                                          napi_value recv,
                                          napi_value func,
                                          size_t argc,
                                          const napi_value* argv,
                                          napi_value* result) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, recv);
  if (argc > 0) {
    CHECK_ARG(env, argv);
  }

  v8::Local<v8::Context> context = env->context();

  v8::Local<v8::Object> v8recv;
  CHECK_TO_OBJECT(env, context, v8recv, recv);

  v8::Local<v8::Function> v8func;
  CHECK_TO_FUNCTION(env, v8func, func);

  v8::MaybeLocal<v8::Value> callback_result;

  if (async_context == nullptr) {
    callback_result = node::MakeCallback(
        env->isolate,
        v8recv,
        v8func,
        argc,
        reinterpret_cast<v8::Local<v8::Value>*>(const_cast<napi_value*...",957.0,1009.0,1.0,12.0,53.0,62,12,81,21,0,11,6,7,0,11,,0,1,14,7,7,napi_status
3212,134426,napi_create_buffer,1,napi_create_buffer,"napi_status napi_create_buffer (napi_env,size_t,void**,napi_value*)",node_api.cc,"napi_status NAPI_CDECL napi_create_buffer(napi_env env,
                                          size_t length,
                                          void** data,
                                          napi_value* result) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);

  v8::MaybeLocal<v8::Object> maybe = node::Buffer::New(env->isolate, length);

  CHECK_MAYBE_EMPTY(env, maybe, napi_generic_failure);

  v8::Local<v8::Object> buffer = maybe.ToLocalChecked();

  *result = v8impl::JsValueFromV8LocalValue(buffer);

  if (data != nullptr) {
    *data = node::Buffer::Data(buffer);
  }

  return GET_RETURN_STATUS(env);
}",1011.0,1031.0,1.0,12.0,21.0,36,11,44,15,0,8,4,5,0,8,,0,3,8,4,4,napi_status
3213,134581,napi_create_external_buffer,1,napi_create_external_buffer,"napi_status napi_create_external_buffer (napi_env,size_t,void*,napi_finalize,void*,napi_value*)",node_api.cc,"napi_status NAPI_CDECL napi_create_external_buffer(napi_env env,
                                                   size_t length,
                                                   void* data,
                                                   napi_finalize finalize_cb,
                                                   void* finalize_hint,
                                                   napi_value* result) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);

#if defined(V8_ENABLE_SANDBOX)
  return napi_set_last_error(env, napi_no_external_buffers_allowed);
#endif

  v8::Isolate* isolate = env->isolate;

  // The finalizer object will delete itself after invoking the callback.
  v8impl::BufferFinalizer* finalizer =
      v8impl::BufferFinalizer::New(env, finalize_cb, nullptr, finalize_hint);

  v8::MaybeLocal<v8::Object> maybe =
      node::Buffer::New(isolate,
                        static_cast<char*>(data),
                        length,
                        v8impl::BufferF...",1033.0,1067.0,1.0,12.0,35.0,33,12,47,19,0,7,3,4,0,7,,0,2,12,6,6,napi_status
3214,134738,napi_create_buffer_copy,1,napi_create_buffer_copy,"napi_status napi_create_buffer_copy (napi_env,size_t,void*,void**,napi_value*)",node_api.cc,"napi_status NAPI_CDECL napi_create_buffer_copy(napi_env env,
                                               size_t length,
                                               const void* data,
                                               void** result_data,
                                               napi_value* result) {
  NAPI_PREAMBLE(env);
  CHECK_ARG(env, result);

  v8::MaybeLocal<v8::Object> maybe =
      node::Buffer::Copy(env->isolate, static_cast<const char*>(data), length);

  CHECK_MAYBE_EMPTY(env, maybe, napi_generic_failure);

  v8::Local<v8::Object> buffer = maybe.ToLocalChecked();
  *result = v8impl::JsValueFromV8LocalValue(buffer);

  if (result_data != nullptr) {
    *result_data = node::Buffer::Data(buffer);
  }

  return GET_RETURN_STATUS(env);
}",1069.0,1090.0,1.0,12.0,22.0,37,12,45,16,0,8,4,5,0,8,,0,3,10,5,5,napi_status
3215,134897,napi_is_buffer,1,napi_is_buffer,"napi_status napi_is_buffer (napi_env,napi_value,bool*)",node_api.cc,"napi_status NAPI_CDECL napi_is_buffer(napi_env env,
                                      napi_value value,
                                      bool* result) {
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, result);

  *result = node::Buffer::HasInstance(v8impl::V8LocalValueFromJsValue(value));
  return napi_clear_last_error(env);
}",1092.0,1101.0,1.0,12.0,10.0,10,6,19,7,0,5,1,1,0,5,,0,2,6,3,3,napi_status
3216,134968,napi_get_buffer_info,1,napi_get_buffer_info,"napi_status napi_get_buffer_info (napi_env,napi_value,void**,size_t*)",node_api.cc,"napi_status NAPI_CDECL napi_get_buffer_info(napi_env env,
                                            napi_value value,
                                            void** data,
                                            size_t* length) {
  CHECK_ENV(env);
  CHECK_ARG(env, value);

  v8::Local<v8::Value> buffer = v8impl::V8LocalValueFromJsValue(value);

  if (data != nullptr) {
    *data = node::Buffer::Data(buffer);
  }
  if (length != nullptr) {
    *length = node::Buffer::Length(buffer);
  }

  return napi_clear_last_error(env);
}",1103.0,1120.0,1.0,12.0,18.0,19,8,24,10,0,5,3,3,0,5,,0,3,8,4,4,napi_status
3217,135054,napi_get_node_version,1,napi_get_node_version,"napi_status napi_get_node_version (napi_env,napi_node_version**)",node_api.cc,"napi_status NAPI_CDECL napi_get_node_version(napi_env env,
                                             const napi_node_version** result) {
  CHECK_ENV(env);
  CHECK_ARG(env, result);
  static const napi_node_version version = {
      NODE_MAJOR_VERSION, NODE_MINOR_VERSION, NODE_PATCH_VERSION, NODE_RELEASE};
  *result = &version;
  return napi_clear_last_error(env);
}",1122.0,1130.0,1.0,12.0,9.0,8,7,12,4,0,2,1,1,0,2,,0,0,4,2,2,napi_status
3218,135116,ConvertUVErrorCode,1,anonymous_namespace_74.uvimpl.ConvertUVErrorCode,napi_status anonymous_namespace_74.uvimpl.ConvertUVErrorCode (int),node_api.cc,"static napi_status ConvertUVErrorCode(int code) {
  switch (code) {
    case 0:
      return napi_ok;
    case UV_EINVAL:
      return napi_invalid_arg;
    case UV_ECANCELED:
      return napi_cancelled;
    default:
      return napi_generic_failure;
  }
}",1135.0,1146.0,1.0,1.0,12.0,0,0,7,7,0,0,2,2,0,0,,0,0,2,1,1,napi_status
3219,135139,Work,1,anonymous_namespace_76.uvimpl.Work.Work,"ANY anonymous_namespace_76.uvimpl.Work.Work (node_napi_env,ANY,ANY,napi_async_execute_callback,napi_async_complete_callback,void*)",node_api.cc,"explicit Work(node_napi_env env,
                v8::Local<v8::Object> async_resource,
                v8::Local<v8::String> async_resource_name,
                napi_async_execute_callback execute,
                napi_async_complete_callback complete = nullptr,
                void* data = nullptr)
      : AsyncResource(
            env->isolate,
            async_resource,
            *v8::String::Utf8Value(env->isolate, async_resource_name)),
        ThreadPoolWork(env->node_env(), ""node_api""),
        _env(env),
        _data(data),
        _execute(execute),
        _complete(complete) {}",1151.0,1165.0,3.0,30.0,15.0,0,0,0,0,0,0,1,1,0,0,,0,0,12,6,6,ANY
3220,135149,~Work,1,anonymous_namespace_77.uvimpl.Work.~Work,ANY anonymous_namespace_77.uvimpl.Work.~Work (),node_api.cc,~Work() override = default;,1167.0,1167.0,3.0,29.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
3221,135153,New,1,anonymous_namespace_78.uvimpl.Work.New,"Work anonymous_namespace_78.uvimpl.Work.New (node_napi_env,ANY,ANY,napi_async_execute_callback,napi_async_complete_callback,void*)",node_api.cc,"static Work* New(node_napi_env env,
                   v8::Local<v8::Object> async_resource,
                   v8::Local<v8::String> async_resource_name,
                   napi_async_execute_callback execute,
                   napi_async_complete_callback complete,
                   void* data) {
    return new Work(
        env, async_resource, async_resource_name, execute, complete, data);
  }",1170.0,1178.0,3.0,3.0,9.0,1,1,7,7,0,0,1,1,0,0,,0,0,12,6,6,Work
3222,135172,Delete,1,anonymous_namespace_79.uvimpl.Work.Delete,void anonymous_namespace_79.uvimpl.Work.Delete (Work*),node_api.cc,static void Delete(Work* work) { delete work; },1180.0,1180.0,3.0,49.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,void
3223,135179,DoThreadPoolWork,1,anonymous_namespace_80.uvimpl.Work.DoThreadPoolWork,void anonymous_namespace_80.uvimpl.Work.DoThreadPoolWork (),node_api.cc,"void DoThreadPoolWork() override { _execute(_env, _data); }",1182.0,1182.0,3.0,61.0,1.0,0,0,2,2,0,2,1,1,0,0,,0,2,0,0,0,void
3224,135186,AfterThreadPoolWork,1,anonymous_namespace_81.uvimpl.Work.AfterThreadPoolWork,void anonymous_namespace_81.uvimpl.Work.AfterThreadPoolWork (int),node_api.cc,"void AfterThreadPoolWork(int status) override {
    if (_complete == nullptr) return;

    // Establish a handle scope here so that every callback doesn't have to.
    // Also it is needed for the exception-handling below.
    v8::HandleScope scope(_env->isolate);

    CallbackScope callback_scope(this);

    _env->CallbackIntoModule<true>([&](napi_env env) {
      _complete(env, ConvertUVErrorCode(status), _data);
    });

    // Note: Don't access `work` after this point because it was
    // likely deleted by the complete callback.
  }",1184.0,1199.0,3.0,3.0,16.0,3,2,3,2,0,3,2,2,1,0,,0,3,2,1,1,void
3225,135213,napi_create_async_work,1,napi_create_async_work,"napi_status napi_create_async_work (napi_env,napi_value,napi_value,napi_async_execute_callback,napi_async_complete_callback,void*,napi_async_work*)",node_api.cc,"napi_status NAPI_CDECL
napi_create_async_work(napi_env env,
                       napi_value async_resource,
                       napi_value async_resource_name,
                       napi_async_execute_callback execute,
                       napi_async_complete_callback complete,
                       void* data,
                       napi_async_work* result) {
  CHECK_ENV(env);
  CHECK_ARG(env, execute);
  CHECK_ARG(env, result);

  v8::Local<v8::Context> context = env->context();

  v8::Local<v8::Object> resource;
  if (async_resource != nullptr) {
    CHECK_TO_OBJECT(env, context, resource, async_resource);
  } else {
    resource = v8::Object::New(env->isolate);
  }

  v8::Local<v8::String> resource_name;
  CHECK_TO_STRING(env, context, resource_name, async_resource_name);

  uvimpl::Work* work = uvimpl::Work::New(reinterpret_cast<node_napi_env>(env),
                                         resource,
                                         resource_name,
              ...",1220.0,1254.0,1.0,12.0,35.0,47,10,68,20,0,7,2,2,0,7,,0,0,14,7,7,napi_status
3226,135459,napi_delete_async_work,1,napi_delete_async_work,"napi_status napi_delete_async_work (napi_env,napi_async_work)",node_api.cc,"napi_status NAPI_CDECL napi_delete_async_work(napi_env env,
                                              napi_async_work work) {
  CHECK_ENV(env);
  CHECK_ARG(env, work);

  uvimpl::Work::Delete(reinterpret_cast<uvimpl::Work*>(work));

  return napi_clear_last_error(env);
}",1256.0,1264.0,1.0,12.0,9.0,6,5,12,5,0,2,1,1,0,2,,0,0,4,2,2,napi_status
3227,135507,napi_get_uv_event_loop,1,napi_get_uv_event_loop,"napi_status napi_get_uv_event_loop (napi_env,uv_loop_t**)",node_api.cc,"napi_status NAPI_CDECL napi_get_uv_event_loop(napi_env env, uv_loop_t** loop) {
  CHECK_ENV(env);
  CHECK_ARG(env, loop);
  *loop = reinterpret_cast<node_napi_env>(env)->node_env()->event_loop();
  return napi_clear_last_error(env);
}",1266.0,1271.0,1.0,12.0,6.0,8,7,11,3,1,3,1,1,0,2,,0,1,4,2,2,napi_status
3228,135558,napi_queue_async_work,1,napi_queue_async_work,"napi_status napi_queue_async_work (napi_env,napi_async_work)",node_api.cc,"napi_status NAPI_CDECL napi_queue_async_work(napi_env env,
                                             napi_async_work work) {
  CHECK_ENV(env);
  CHECK_ARG(env, work);

  uv_loop_t* event_loop = nullptr;
  STATUS_CALL(napi_get_uv_event_loop(env, &event_loop));

  uvimpl::Work* w = reinterpret_cast<uvimpl::Work*>(work);

  w->ScheduleWork();

  return napi_clear_last_error(env);
}",1273.0,1286.0,1.0,12.0,14.0,10,7,19,8,0,3,1,1,0,3,,0,1,4,2,2,napi_status
3229,135631,napi_cancel_async_work,1,napi_cancel_async_work,"napi_status napi_cancel_async_work (napi_env,napi_async_work)",node_api.cc,"napi_status NAPI_CDECL napi_cancel_async_work(napi_env env,
                                              napi_async_work work) {
  CHECK_ENV(env);
  CHECK_ARG(env, work);

  uvimpl::Work* w = reinterpret_cast<uvimpl::Work*>(work);

  CALL_UV(env, w->CancelWork());

  return napi_clear_last_error(env);
}",1288.0,1298.0,1.0,12.0,11.0,11,7,23,8,0,3,1,1,0,3,,0,0,4,2,2,napi_status
3230,135713,napi_create_threadsafe_function,1,napi_create_threadsafe_function,"napi_status napi_create_threadsafe_function (napi_env,napi_value,napi_value,napi_value,size_t,size_t,void*,napi_finalize,void*,napi_threadsafe_function_call_js,napi_threadsafe_function*)",node_api.cc,"napi_status NAPI_CDECL
napi_create_threadsafe_function(napi_env env,
                                napi_value func,
                                napi_value async_resource,
                                napi_value async_resource_name,
                                size_t max_queue_size,
                                size_t initial_thread_count,
                                void* thread_finalize_data,
                                napi_finalize thread_finalize_cb,
                                void* context,
                                napi_threadsafe_function_call_js call_js_cb,
                                napi_threadsafe_function* result) {
  CHECK_ENV(env);
  CHECK_ARG(env, async_resource_name);
  RETURN_STATUS_IF_FALSE(env, initial_thread_count > 0, napi_invalid_arg);
  CHECK_ARG(env, result);

  napi_status status = napi_ok;

  v8::Local<v8::Function> v8_func;
  if (func == nullptr) {
    CHECK_ARG(env, call_js_cb);
  } else {
    CHECK_TO_FUNCTION(env, ...",1300.0,1361.0,1.0,12.0,62.0,49,10,77,26,0,7,4,4,0,7,,0,0,22,11,11,napi_status
3231,136095,napi_get_threadsafe_function_context,1,napi_get_threadsafe_function_context,"napi_status napi_get_threadsafe_function_context (napi_threadsafe_function,void**)",node_api.cc,"napi_status NAPI_CDECL napi_get_threadsafe_function_context(
    napi_threadsafe_function func, void** result) {
  CHECK_NOT_NULL(func);
  CHECK_NOT_NULL(result);

  *result = reinterpret_cast<v8impl::ThreadSafeFunction*>(func)->Context();
  return napi_ok;
}",1363.0,1370.0,1.0,12.0,8.0,4,4,5,3,0,0,1,1,0,0,,0,0,4,2,2,napi_status
3232,136116,napi_call_threadsafe_function,1,napi_call_threadsafe_function,"napi_status napi_call_threadsafe_function (napi_threadsafe_function,void*,napi_threadsafe_function_call_mode)",node_api.cc,"napi_status NAPI_CDECL
napi_call_threadsafe_function(napi_threadsafe_function func,
                              void* data,
                              napi_threadsafe_function_call_mode is_blocking) {
  CHECK_NOT_NULL(func);
  return reinterpret_cast<v8impl::ThreadSafeFunction*>(func)->Push(data,
                                                                   is_blocking);
}",1372.0,1379.0,1.0,12.0,8.0,2,2,4,3,0,0,1,1,0,0,,0,0,6,3,3,napi_status
3233,136134,napi_acquire_threadsafe_function,1,napi_acquire_threadsafe_function,napi_status napi_acquire_threadsafe_function (napi_threadsafe_function),node_api.cc,"napi_status NAPI_CDECL
napi_acquire_threadsafe_function(napi_threadsafe_function func) {
  CHECK_NOT_NULL(func);
  return reinterpret_cast<v8impl::ThreadSafeFunction*>(func)->Acquire();
}",1381.0,1385.0,1.0,12.0,5.0,2,2,2,1,0,0,1,1,0,0,,0,0,2,1,1,napi_status
3234,136148,napi_release_threadsafe_function,1,napi_release_threadsafe_function,"napi_status napi_release_threadsafe_function (napi_threadsafe_function,napi_threadsafe_function_release_mode)",node_api.cc,"napi_status NAPI_CDECL napi_release_threadsafe_function(
    napi_threadsafe_function func, napi_threadsafe_function_release_mode mode) {
  CHECK_NOT_NULL(func);
  return reinterpret_cast<v8impl::ThreadSafeFunction*>(func)->Release(mode);
}",1387.0,1391.0,1.0,12.0,5.0,2,2,3,2,0,0,1,1,0,0,,0,0,4,2,2,napi_status
3235,136164,napi_unref_threadsafe_function,1,napi_unref_threadsafe_function,"napi_status napi_unref_threadsafe_function (napi_env,napi_threadsafe_function)",node_api.cc,"napi_status NAPI_CDECL
napi_unref_threadsafe_function(napi_env env, napi_threadsafe_function func) {
  CHECK_NOT_NULL(func);
  return reinterpret_cast<v8impl::ThreadSafeFunction*>(func)->Unref();
}",1393.0,1397.0,1.0,12.0,5.0,2,2,2,1,0,0,1,1,0,0,,0,0,4,2,2,napi_status
3236,136179,napi_ref_threadsafe_function,1,napi_ref_threadsafe_function,"napi_status napi_ref_threadsafe_function (napi_env,napi_threadsafe_function)",node_api.cc,"napi_status NAPI_CDECL
napi_ref_threadsafe_function(napi_env env, napi_threadsafe_function func) {
  CHECK_NOT_NULL(func);
  return reinterpret_cast<v8impl::ThreadSafeFunction*>(func)->Ref();
}",1399.0,1403.0,1.0,12.0,5.0,2,2,2,1,0,0,1,1,0,0,,0,0,4,2,2,napi_status
3237,136194,node_api_get_module_file_name,1,node_api_get_module_file_name,"napi_status node_api_get_module_file_name (napi_env,char**)",node_api.cc,"napi_status NAPI_CDECL node_api_get_module_file_name(napi_env env,
                                                     const char** result) {
  CHECK_ENV(env);
  CHECK_ARG(env, result);

  *result = static_cast<node_napi_env>(env)->GetFilename();
  return napi_clear_last_error(env);
}",1405.0,1412.0,1.0,12.0,8.0,7,7,11,3,0,3,1,1,0,2,,0,1,4,2,2,napi_status
3238,136252,napi_addon_register_func,1,napi_addon_register_func,"napi_value napi_addon_register_func (napi_env,napi_value)",node_api.hpp,"typedef napi_value(NAPI_CDECL* napi_addon_register_func)(napi_env env,
                                                         napi_value exports);",31.0,32.0,19.0,19.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,napi_value
3239,136258,node_api_addon_get_api_version_func,1,node_api_addon_get_api_version_func,int32_t node_api_addon_get_api_version_func (),node_api.hpp,typedef int32_t(NAPI_CDECL* node_api_addon_get_api_version_func)();,33.0,33.0,16.0,16.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,int32_t
3240,136560,node_env,1,node_napi_env__.node_env,Environment node_napi_env__.node_env (),node_api_internals.hpp,"inline node::Environment* node_env() const {
    return node::Environment::GetCurrent(context());
  }",30.0,32.0,3.0,3.0,3.0,2,1,2,2,10,0,1,1,0,0,,0,0,0,0,0,Environment
3241,136572,GetFilename,1,node_napi_env__.GetFilename,const char* node_napi_env__.GetFilename (),node_api_internals.hpp,inline const char* GetFilename() const { return filename.c_str(); },33.0,33.0,3.0,69.0,1.0,1,1,1,1,1,1,1,1,0,0,,0,1,0,0,0,const char*
3242,136608,napi_async_execute_callback,1,napi_async_execute_callback,"void napi_async_execute_callback (napi_env,void*)",node_api_types.hpp,"typedef void(NAPI_CDECL* napi_async_execute_callback)(napi_env env, void* data);",30.0,30.0,13.0,13.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
3243,136614,napi_async_complete_callback,1,napi_async_complete_callback,"void napi_async_complete_callback (napi_env,napi_status,void*)",node_api_types.hpp,"typedef void(NAPI_CDECL* napi_async_complete_callback)(napi_env env,
                                                       napi_status status,
                                                       void* data);",31.0,33.0,13.0,13.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,void
3244,136628,<lambda>0,1,node.binding.DLOpen.<lambda>0,ANY node.binding.DLOpen.<lambda>0 (DLib*),node_binding.cc,"[&](DLib* dlib) {
    static Mutex dlib_load_mutex;
    Mutex::ScopedLock lock(dlib_load_mutex);

    const bool is_opened = dlib->Open();

    // Objects containing v14 or later modules will have registered themselves
    // on the pending list.  Activate all of them now.  At present, only one
    // module per object is supported.
    node_module* mp = thread_local_modpending;
    thread_local_modpending = nullptr;

    if (!is_opened) {
      std::string errmsg = dlib->errmsg_.c_str();
      dlib->Close();
#ifdef _WIN32
      // Windows needs to add the filename into the error message
      errmsg += *filename;
#endif  // _WIN32
      THROW_ERR_DLOPEN_FAILED(env, ""%s"", errmsg.c_str());
      return false;
    }

    if (mp != nullptr) {
      if (mp->nm_context_register_func == nullptr) {
        if (env->force_context_aware()) {
          dlib->Close();
          THROW_ERR_NON_CONTEXT_AWARE_DISABLED(env);
          return false;
        }
      }
      mp->nm_dso_handle = dlib->...",455.0,553.0,39.0,3.0,99.0,36,10,45,16,0,9,8,12,4,0,,0,9,2,1,1,ANY
3245,136924,_register_async_wrap,1,_register_async_wrap,void _register_async_wrap (),node_binding.cc,void void ();,99.0,99.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
3246,136928,_register_blob,1,_register_blob,void _register_blob (),node_binding.cc,void void ();,99.0,99.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
3247,136932,_register_block_list,1,_register_block_list,void _register_block_list (),node_binding.cc,void void ();,99.0,99.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
3248,136936,_register_buffer,1,_register_buffer,void _register_buffer (),node_binding.cc,void void ();,99.0,99.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
3249,136940,_register_builtins,1,_register_builtins,void _register_builtins (),node_binding.cc,void void ();,99.0,99.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
3250,136944,_register_cares_wrap,1,_register_cares_wrap,void _register_cares_wrap (),node_binding.cc,void void ();,99.0,99.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
3251,136948,_register_config,1,_register_config,void _register_config (),node_binding.cc,void void ();,99.0,99.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
3252,136952,_register_contextify,1,_register_contextify,void _register_contextify (),node_binding.cc,void void ();,99.0,99.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
3253,136956,_register_credentials,1,_register_credentials,void _register_credentials (),node_binding.cc,void void ();,99.0,99.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
3254,136960,_register_encoding_binding,1,_register_encoding_binding,void _register_encoding_binding (),node_binding.cc,void void ();,99.0,99.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
3255,136964,_register_errors,1,_register_errors,void _register_errors (),node_binding.cc,void void ();,99.0,99.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
3256,136968,_register_fs,1,_register_fs,void _register_fs (),node_binding.cc,void void ();,99.0,99.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
3257,136972,_register_fs_dir,1,_register_fs_dir,void _register_fs_dir (),node_binding.cc,void void ();,99.0,99.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
3258,136976,_register_fs_event_wrap,1,_register_fs_event_wrap,void _register_fs_event_wrap (),node_binding.cc,void void ();,99.0,99.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
3259,136980,_register_heap_utils,1,_register_heap_utils,void _register_heap_utils (),node_binding.cc,void void ();,99.0,99.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
3260,136984,_register_http2,1,_register_http2,void _register_http2 (),node_binding.cc,void void ();,99.0,99.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
3261,136988,_register_http_parser,1,_register_http_parser,void _register_http_parser (),node_binding.cc,void void ();,99.0,99.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
3262,136992,_register_inspector,1,_register_inspector,void _register_inspector (),node_binding.cc,void void ();,99.0,99.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
3263,136996,_register_js_stream,1,_register_js_stream,void _register_js_stream (),node_binding.cc,void void ();,99.0,99.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
3264,137000,_register_js_udp_wrap,1,_register_js_udp_wrap,void _register_js_udp_wrap (),node_binding.cc,void void ();,99.0,99.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
3265,137004,_register_messaging,1,_register_messaging,void _register_messaging (),node_binding.cc,void void ();,99.0,99.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
3266,137008,_register_module_wrap,1,_register_module_wrap,void _register_module_wrap (),node_binding.cc,void void ();,99.0,99.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
3267,137012,_register_mksnapshot,1,_register_mksnapshot,void _register_mksnapshot (),node_binding.cc,void void ();,99.0,99.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
3268,137016,_register_options,1,_register_options,void _register_options (),node_binding.cc,void void ();,99.0,99.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
3269,137020,_register_os,1,_register_os,void _register_os (),node_binding.cc,void void ();,99.0,99.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
3270,137024,_register_performance,1,_register_performance,void _register_performance (),node_binding.cc,void void ();,99.0,99.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
3271,137028,_register_permission,1,_register_permission,void _register_permission (),node_binding.cc,void void ();,99.0,99.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
3272,137032,_register_pipe_wrap,1,_register_pipe_wrap,void _register_pipe_wrap (),node_binding.cc,void void ();,99.0,99.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
3273,137036,_register_process_wrap,1,_register_process_wrap,void _register_process_wrap (),node_binding.cc,void void ();,99.0,99.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
3274,137040,_register_process_methods,1,_register_process_methods,void _register_process_methods (),node_binding.cc,void void ();,99.0,99.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
3275,137044,_register_report,1,_register_report,void _register_report (),node_binding.cc,void void ();,99.0,99.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
3276,137048,_register_sea,1,_register_sea,void _register_sea (),node_binding.cc,void void ();,99.0,99.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
3277,137052,_register_serdes,1,_register_serdes,void _register_serdes (),node_binding.cc,void void ();,99.0,99.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
3278,137056,_register_signal_wrap,1,_register_signal_wrap,void _register_signal_wrap (),node_binding.cc,void void ();,99.0,99.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
3279,137060,_register_spawn_sync,1,_register_spawn_sync,void _register_spawn_sync (),node_binding.cc,void void ();,99.0,99.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
3280,137064,_register_stream_pipe,1,_register_stream_pipe,void _register_stream_pipe (),node_binding.cc,void void ();,99.0,99.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
3281,137068,_register_stream_wrap,1,_register_stream_wrap,void _register_stream_wrap (),node_binding.cc,void void ();,99.0,99.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
3282,137072,_register_string_decoder,1,_register_string_decoder,void _register_string_decoder (),node_binding.cc,void void ();,99.0,99.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
3283,137076,_register_symbols,1,_register_symbols,void _register_symbols (),node_binding.cc,void void ();,99.0,99.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
3284,137080,_register_task_queue,1,_register_task_queue,void _register_task_queue (),node_binding.cc,void void ();,99.0,99.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
3285,137084,_register_tcp_wrap,1,_register_tcp_wrap,void _register_tcp_wrap (),node_binding.cc,void void ();,99.0,99.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
3286,137088,_register_timers,1,_register_timers,void _register_timers (),node_binding.cc,void void ();,99.0,99.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
3287,137092,_register_trace_events,1,_register_trace_events,void _register_trace_events (),node_binding.cc,void void ();,99.0,99.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
3288,137096,_register_tty_wrap,1,_register_tty_wrap,void _register_tty_wrap (),node_binding.cc,void void ();,99.0,99.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
3289,137100,_register_types,1,_register_types,void _register_types (),node_binding.cc,void void ();,99.0,99.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
3290,137104,_register_udp_wrap,1,_register_udp_wrap,void _register_udp_wrap (),node_binding.cc,void void ();,99.0,99.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
3291,137108,_register_url,1,_register_url,void _register_url (),node_binding.cc,void void ();,99.0,99.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
3292,137112,_register_util,1,_register_util,void _register_util (),node_binding.cc,void void ();,99.0,99.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
3293,137116,_register_uv,1,_register_uv,void _register_uv (),node_binding.cc,void void ();,99.0,99.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
3294,137120,_register_v8,1,_register_v8,void _register_v8 (),node_binding.cc,void void ();,99.0,99.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
3295,137124,_register_wasi,1,_register_wasi,void _register_wasi (),node_binding.cc,void void ();,99.0,99.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
3296,137128,_register_wasm_web_api,1,_register_wasm_web_api,void _register_wasm_web_api (),node_binding.cc,void void ();,99.0,99.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
3297,137132,_register_watchdog,1,_register_watchdog,void _register_watchdog (),node_binding.cc,void void ();,99.0,99.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
3298,137136,_register_worker,1,_register_worker,void _register_worker (),node_binding.cc,void void ();,99.0,99.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
3299,137140,_register_zlib,1,_register_zlib,void _register_zlib (),node_binding.cc,void void ();,99.0,99.0,1.0,24.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,void
3300,137207,set,1,node.binding.global_handle_map_t.set,"void node.binding.global_handle_map_t.set (void*,node_module*)",node_binding.cc,"void set(void* handle, node_module* mod) {
    CHECK_NE(handle, nullptr);
    Mutex::ScopedLock lock(mutex_);

    map_[handle].module = mod;
    // We need to store this flag internally to avoid a chicken-and-egg problem
    // during cleanup. By the time we actually use the flag's value,
    // the shared object has been unloaded, and its memory would be gone,
    // making it impossible to access fields of `mod` --
    // unless `mod` *is* dynamically allocated, but we cannot know that
    // without checking the flag.
    map_[handle].wants_delete_module = mod->nm_flags & NM_F_DELETEME;
    map_[handle].refcount++;
  }",275.0,288.0,3.0,3.0,14.0,11,6,11,5,0,5,1,1,0,0,,0,5,4,2,2,void
3301,137243,get_and_increase_refcount,1,node.binding.global_handle_map_t.get_and_increase_refcount,node_module node.binding.global_handle_map_t.get_and_increase_refcount (void*),node_binding.cc,"node_module* get_and_increase_refcount(void* handle) {
    CHECK_NE(handle, nullptr);
    Mutex::ScopedLock lock(mutex_);

    auto it = map_.find(handle);
    if (it == map_.end()) return nullptr;
    it->second.refcount++;
    return it->second.module;
  }",290.0,298.0,3.0,3.0,9.0,9,5,9,4,0,3,2,2,1,0,,0,3,2,1,1,node_module
3302,137284,erase,1,node.binding.global_handle_map_t.erase,void node.binding.global_handle_map_t.erase (void*),node_binding.cc,"void erase(void* handle) {
    CHECK_NE(handle, nullptr);
    Mutex::ScopedLock lock(mutex_);

    auto it = map_.find(handle);
    if (it == map_.end()) return;
    CHECK_GE(it->second.refcount, 1);
    if (--it->second.refcount == 0) {
      if (it->second.wants_delete_module)
        delete it->second.module;
      map_.erase(handle);
    }
  }",300.0,312.0,3.0,3.0,13.0,16,6,13,4,0,4,4,5,1,0,,0,4,2,1,1,void
3303,137354,DLib,1,node.binding.DLib.DLib,"ANY node.binding.DLib.DLib (char*,int)",node_binding.cc,"DLib::DLib(const char* filename, int flags)
    : filename_(filename), flags_(flags), handle_(nullptr) {}",324.0,325.0,1.0,61.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,ANY
3304,137360,Open,1,node.binding.DLib.Open,bool node.binding.DLib.Open (),node_binding.cc,"bool DLib::Open() {
  int ret = uv_dlopen(filename_.c_str(), &lib_);
  if (ret == 0) {
    handle_ = static_cast<void*>(lib_.handle);
    return true;
  }
  errmsg_ = uv_dlerror(&lib_);
  uv_dlclose(&lib_);
  return false;
}",359.0,368.0,1.0,1.0,10.0,9,5,8,5,0,0,2,2,0,0,,0,0,0,0,0,bool
3305,137396,Close,1,node.binding.DLib.Close,void node.binding.DLib.Close (),node_binding.cc,"void DLib::Close() {
  if (handle_ == nullptr) return;
  if (has_entry_in_global_handle_map_)
    global_handle_map.erase(handle_);
  uv_dlclose(&lib_);
  handle_ = nullptr;
}",370.0,376.0,1.0,1.0,7.0,3,3,5,3,0,0,3,3,0,0,,0,0,0,0,0,void
3306,137418,GetSymbolAddress,1,node.binding.DLib.GetSymbolAddress,void* node.binding.DLib.GetSymbolAddress (char*),node_binding.cc,"void* DLib::GetSymbolAddress(const char* name) {
  void* address;
  if (0 == uv_dlsym(&lib_, name, &address)) return address;
  return nullptr;
}",378.0,382.0,1.0,1.0,5.0,3,2,4,3,0,0,2,2,0,0,,0,0,2,1,1,void*
3307,137438,SaveInGlobalHandleMap,1,node.binding.DLib.SaveInGlobalHandleMap,void node.binding.DLib.SaveInGlobalHandleMap (node_module*),node_binding.cc,"void DLib::SaveInGlobalHandleMap(node_module* mp) {
  has_entry_in_global_handle_map_ = true;
  global_handle_map.set(handle_, mp);
}",385.0,388.0,1.0,1.0,4.0,2,2,4,4,0,0,1,1,0,0,,0,0,2,1,1,void
3308,137452,GetSavedModuleFromGlobalHandleMap,1,node.binding.DLib.GetSavedModuleFromGlobalHandleMap,node_module node.binding.DLib.GetSavedModuleFromGlobalHandleMap (),node_binding.cc,"node_module* DLib::GetSavedModuleFromGlobalHandleMap() {
  has_entry_in_global_handle_map_ = true;
  return global_handle_map.get_and_increase_refcount(handle_);
}",390.0,393.0,1.0,1.0,4.0,2,2,3,3,0,0,1,1,0,0,,0,0,0,0,0,node_module
3309,137466,GetInitializerCallback,1,node.binding.GetInitializerCallback,InitializerCallback node.binding.GetInitializerCallback (DLib*),node_binding.cc,"inline InitializerCallback GetInitializerCallback(DLib* dlib) {
  const char* name = ""node_register_module_v"" STRINGIFY(NODE_MODULE_VERSION);
  return reinterpret_cast<InitializerCallback>(dlib->GetSymbolAddress(name));
}",399.0,402.0,1.0,1.0,4.0,3,3,3,2,0,0,1,1,0,0,,0,0,2,1,1,InitializerCallback
3310,137485,GetNapiInitializerCallback,1,node.binding.GetNapiInitializerCallback,napi_addon_register_func node.binding.GetNapiInitializerCallback (DLib*),node_binding.cc,"inline napi_addon_register_func GetNapiInitializerCallback(DLib* dlib) {
  const char* name =
      STRINGIFY(NAPI_MODULE_INITIALIZER_BASE) STRINGIFY(NAPI_MODULE_VERSION);
  return reinterpret_cast<napi_addon_register_func>(
      dlib->GetSymbolAddress(name));
}",404.0,409.0,1.0,1.0,6.0,3,3,4,3,0,0,1,1,0,0,,0,0,2,1,1,napi_addon_register_func
3311,137505,GetNapiAddonGetApiVersionCallback,1,node.binding.GetNapiAddonGetApiVersionCallback,node_api_addon_get_api_version_func node.binding.GetNapiAddonGetApiVersionCallback (DLib*),node_binding.cc,"inline node_api_addon_get_api_version_func GetNapiAddonGetApiVersionCallback(
    DLib* dlib) {
  return reinterpret_cast<node_api_addon_get_api_version_func>(
      dlib->GetSymbolAddress(STRINGIFY(NODE_API_MODULE_GET_API_VERSION)));
}",411.0,415.0,1.0,1.0,5.0,2,2,2,2,0,0,1,1,0,0,,0,0,2,1,1,node_api_addon_get_api_version_func
3312,137519,DLOpen,1,node.binding.DLOpen,void node.binding.DLOpen (FunctionCallbackInfo<Value>),node_binding.cc,"void DLOpen(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  if (env->no_native_addons()) {
    return THROW_ERR_DLOPEN_DISABLED(
      env, ""Cannot load native addon because loading addons is disabled."");
  }

  auto context = env->context();

  CHECK_NULL(thread_local_modpending);

  if (args.Length() < 2) {
    return THROW_ERR_MISSING_ARGS(
        env, ""process.dlopen needs at least 2 arguments"");
  }

  int32_t flags = DLib::kDefaultFlags;
  if (args.Length() > 2 && !args[2]->Int32Value(context).To(&flags)) {
    return THROW_ERR_INVALID_ARG_TYPE(env, ""flag argument must be an integer."");
  }

  Local<Object> module;
  Local<Object> exports;
  Local<Value> exports_v;
  if (!args[0]->ToObject(context).ToLocal(&module) ||
      !module->Get(context, env->exports_string()).ToLocal(&exports_v) ||
      !exports_v->ToObject(context).ToLocal(&exports)) {
    return;  // Exception pending.
  }

  node::Utf8Value filename(env->isolate()...",423.0,557.0,1.0,1.0,135.0,43,11,41,14,0,0,5,5,0,0,,0,0,2,1,1,void
3313,137668,FindModule,1,node.binding.FindModule,"struct node_module node.binding.FindModule (node_module*,char*,int)",node_binding.cc,"inline struct node_module* FindModule(struct node_module* list,
                                      const char* name,
                                      int flag) {
  struct node_module* mp;

  for (mp = list; mp != nullptr; mp = mp->nm_link) {
    if (strcmp(mp->nm_modname, name) == 0) break;
  }

  CHECK(mp == nullptr || (mp->nm_flags & flag) != 0);
  return mp;
}",559.0,570.0,1.0,1.0,12.0,9,6,9,4,0,2,4,4,1,0,,0,2,6,3,3,struct node_module
3314,137714,CreateInternalBindingTemplates,1,node.binding.CreateInternalBindingTemplates,void node.binding.CreateInternalBindingTemplates (IsolateData*),node_binding.cc,"void CreateInternalBindingTemplates(IsolateData* isolate_data) {
#define V(modname)                                                             \
  do {                                                                         \
    Local<FunctionTemplate> templ =                                            \
        FunctionTemplate::New(isolate_data->isolate());                        \
    templ->InstanceTemplate()->SetInternalFieldCount(                          \
        BaseObject::kInternalFieldCount);                                      \
    _register_isolate_##modname(isolate_data, templ);                          \
    isolate_data->set_##modname##_binding(templ);                              \
  } while (0);
  NODE_BINDINGS_WITH_PER_ISOLATE_INIT(V)
#undef V
}",572.0,584.0,1.0,1.0,13.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
3315,137721,GetInternalBindingExportObject,1,node.binding.GetInternalBindingExportObject,"Local<Object> node.binding.GetInternalBindingExportObject (IsolateData*,char*,Local<Context>)",node_binding.cc,"static Local<Object> GetInternalBindingExportObject(IsolateData* isolate_data,
                                                    const char* mod_name,
                                                    Local<Context> context) {
  Local<FunctionTemplate> ctor;
#define V(name)                                                                \
  if (strcmp(mod_name, #name) == 0) {                                          \
    ctor = isolate_data->name##_binding();                                     \
  } else  // NOLINT(readability/braces)
  NODE_BINDINGS_WITH_PER_ISOLATE_INIT(V)
#undef V
  {
    ctor = isolate_data->binding_data_ctor_template();
  }

  Local<Object> obj = ctor->GetFunction(context)
                          .ToLocalChecked()
                          ->NewInstance(context)
                          .ToLocalChecked();
  return obj;
}",586.0,605.0,1.0,1.0,20.0,11,5,13,8,0,0,1,1,0,0,,0,0,6,3,3,Local<Object>
3316,137766,InitInternalBinding,1,node.binding.InitInternalBinding,"Local<Object> node.binding.InitInternalBinding (Realm*,node_module*)",node_binding.cc,"static Local<Object> InitInternalBinding(Realm* realm, node_module* mod) {
  EscapableHandleScope scope(realm->isolate());
  Local<Context> context = realm->context();
  Local<Object> exports = GetInternalBindingExportObject(
      realm->isolate_data(), mod->nm_modname, context);
  CHECK_NULL(mod->nm_register_func);
  CHECK_NOT_NULL(mod->nm_context_register_func);
  Local<Value> unused = Undefined(realm->isolate());
  // Internal bindings don't have a ""module"" object, only exports.
  mod->nm_context_register_func(exports, unused, context, mod->nm_priv);
  return scope.Escape(exports);
}",607.0,618.0,1.0,1.0,12.0,19,5,24,10,0,5,1,1,0,0,,0,5,4,2,2,Local<Object>
3317,137838,GetInternalBinding,1,node.binding.GetInternalBinding,void node.binding.GetInternalBinding (FunctionCallbackInfo<Value>),node_binding.cc,"void GetInternalBinding(const FunctionCallbackInfo<Value>& args) {
  Realm* realm = Realm::GetCurrent(args);
  Isolate* isolate = realm->isolate();
  HandleScope scope(isolate);
  Local<Context> context = realm->context();

  CHECK(args[0]->IsString());

  Local<String> module = args[0].As<String>();
  node::Utf8Value module_v(isolate, module);
  Local<Object> exports;

  node_module* mod = FindModule(modlist_internal, *module_v, NM_F_INTERNAL);
  if (mod != nullptr) {
    exports = InitInternalBinding(realm, mod);
    realm->internal_bindings.insert(mod);
  } else if (!strcmp(*module_v, ""constants"")) {
    exports = Object::New(isolate);
    CHECK(exports->SetPrototype(context, Null(isolate)).FromJust());
    DefineConstants(isolate, exports);
  } else if (!strcmp(*module_v, ""natives"")) {
    exports = realm->env()->builtin_loader()->GetSourceObject(context);
    // Legacy feature: process.binding('natives').config contains stringified
    // config.gypi
    CHECK(exports
         ...",620.0,654.0,1.0,1.0,35.0,25,8,32,15,0,0,2,2,0,0,,0,0,2,1,1,void
3318,138019,GetLinkedBinding,1,node.binding.GetLinkedBinding,void node.binding.GetLinkedBinding (FunctionCallbackInfo<Value>),node_binding.cc,"void GetLinkedBinding(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  CHECK(args[0]->IsString());

  Local<String> module_name = args[0].As<String>();

  node::Utf8Value module_name_v(env->isolate(), module_name);
  const char* name = *module_name_v;
  node_module* mod = nullptr;

  // Iterate from here to the nearest non-Worker Environment to see if there's
  // a linked binding defined locally rather than through the global list.
  Environment* cur_env = env;
  while (mod == nullptr && cur_env != nullptr) {
    Mutex::ScopedLock lock(cur_env->extra_linked_bindings_mutex());
    mod = FindModule(cur_env->extra_linked_bindings_head(), name, NM_F_LINKED);
    cur_env = cur_env->worker_parent_env();
  }

  if (mod == nullptr)
    mod = FindModule(modlist_linked, name, NM_F_LINKED);

  if (mod == nullptr) {
    return THROW_ERR_INVALID_MODULE(
        env, ""No such binding was linked: %s"", *module_name_v);
  }

  Local<Object> module = ...",656.0,704.0,1.0,1.0,49.0,55,10,63,17,0,3,5,5,1,0,,0,3,2,1,1,void
3319,138246,RegisterBuiltinBindings,1,node.binding.RegisterBuiltinBindings,void node.binding.RegisterBuiltinBindings (),node_binding.cc,"void RegisterBuiltinBindings() {
#define V(modname) _register_##modname();
  NODE_BUILTIN_BINDINGS(V)
#undef V
}",708.0,712.0,1.0,2.0,5.0,0,0,0,0,0,55,1,1,0,0,,0,0,0,0,0,void
3320,138311,RegisterExternalReferences,1,node.binding.RegisterExternalReferences,void node.binding.RegisterExternalReferences (ExternalReferenceRegistry*),node_binding.cc,"void RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  registry->Register(GetLinkedBinding);
  registry->Register(GetInternalBinding);
}",714.0,717.0,1.0,1.0,4.0,2,1,2,1,0,0,1,1,0,0,,0,0,2,1,1,void
3321,138341,<lambda>0,1,node.Blob.New.<lambda>0,"ANY node.Blob.New.<lambda>0 (ANY,size_t,size_t)",node_blob.cc,"[env](v8::Local<v8::ArrayBuffer> buf,
                                            size_t byte_length,
                                            size_t byte_offset = 0) {
      if (buf->IsDetachable()) {
        std::shared_ptr<BackingStore> store = buf->GetBackingStore();
        USE(buf->Detach(Local<Value>()));
        return DataQueue::CreateInMemoryEntryFromBackingStore(
            store, byte_offset, byte_length);
      }

      // If the ArrayBuffer is not detachable, we will copy from it instead.
      std::shared_ptr<BackingStore> store =
          ArrayBuffer::NewBackingStore(env->isolate(), byte_length);
      uint8_t* ptr = static_cast<uint8_t*>(buf->Data()) + byte_offset;
      std::copy(ptr, ptr + byte_length, static_cast<uint8_t*>(store->Data()));
      return DataQueue::CreateInMemoryEntryFromBackingStore(
          store, 0, byte_length);
    }",180.0,197.0,39.0,5.0,18.0,23,7,27,10,0,0,2,2,0,0,,0,0,6,3,3,ANY
3322,138433,<lambda>1,1,node.Blob.Reader.Pull.<lambda>1,"ANY node.Blob.Reader.Pull.<lambda>1 (int,ANY*,size_t,ANY)",node_blob.cc,"[impl](int status,
                     const DataQueue::Vec* vecs,
                     size_t count,
                     bob::Done doneCb) mutable {
    auto dropMe = std::unique_ptr<Impl>(impl);
    Environment* env = impl->env;
    HandleScope handleScope(env->isolate());
    Local<Function> fn = impl->callback.Get(env->isolate());

    if (status == bob::STATUS_EOS) impl->reader->eos_ = true;

    if (count > 0) {
      // Copy the returns vectors into a single ArrayBuffer.
      size_t total = 0;
      for (size_t n = 0; n < count; n++) total += vecs[n].len;

      std::shared_ptr<BackingStore> store =
          v8::ArrayBuffer::NewBackingStore(env->isolate(), total);
      auto ptr = static_cast<uint8_t*>(store->Data());
      for (size_t n = 0; n < count; n++) {
        std::copy(vecs[n].base, vecs[n].base + vecs[n].len, ptr);
        ptr += vecs[n].len;
      }
      // Since we copied the data buffers, signal that we're done with them.
      std::move(doneCb)(0);
      Lo...",336.0,372.0,15.0,3.0,37.0,58,10,59,22,0,1,5,7,0,0,,0,1,8,4,4,ANY
3323,138665,Concat,1,node.anonymous_namespace_1.Concat,void node.anonymous_namespace_1.Concat (FunctionCallbackInfo<Value>),node_blob.cc,"void Concat(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  CHECK(args[0]->IsArray());
  Local<Array> array = args[0].As<Array>();

  struct View {
    std::shared_ptr<BackingStore> store;
    size_t length;
    size_t offset = 0;
  };

  std::vector<View> views;
  size_t total = 0;

  for (uint32_t n = 0; n < array->Length(); n++) {
    Local<Value> val;
    if (!array->Get(env->context(), n).ToLocal(&val)) return;
    if (val->IsArrayBuffer()) {
      auto ab = val.As<ArrayBuffer>();
      views.push_back(View{ab->GetBackingStore(), ab->ByteLength(), 0});
      total += ab->ByteLength();
    } else {
      CHECK(val->IsArrayBufferView());
      auto view = val.As<ArrayBufferView>();
      views.push_back(View{view->Buffer()->GetBackingStore(),
                           view->ByteLength(),
                           view->ByteOffset()});
      total += view->ByteLength();
    }
  }

  std::shared_ptr<BackingStore> store =
      Arra...",42.0,84.0,1.0,1.0,43.0,61,12,57,18,0,0,5,7,0,0,,0,0,2,1,1,void
3324,138915,BlobFromFilePath,1,node.anonymous_namespace_2.BlobFromFilePath,void node.anonymous_namespace_2.BlobFromFilePath (FunctionCallbackInfo<Value>),node_blob.cc,"void BlobFromFilePath(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  auto entry = DataQueue::CreateFdEntry(env, args[0]);
  if (entry == nullptr) {
    return THROW_ERR_INVALID_ARG_VALUE(env, ""Unabled to open file as blob"");
  }

  std::vector<std::unique_ptr<DataQueue::Entry>> entries;
  entries.push_back(std::move(entry));

  auto blob =
      Blob::Create(env, DataQueue::CreateIdempotent(std::move(entries)));

  if (blob) {
    auto array = Array::New(env->isolate(), 2);
    USE(array->Set(env->context(), 0, blob->object()));
    USE(array->Set(env->context(),
                   1,
                   Uint32::NewFromUnsigned(env->isolate(), blob->length())));

    args.GetReturnValue().Set(array);
  }
}",86.0,108.0,1.0,1.0,23.0,31,7,36,12,0,0,3,3,0,0,,0,0,2,1,1,void
3325,139046,CreatePerIsolateProperties,1,node.Blob.CreatePerIsolateProperties,"void node.Blob.CreatePerIsolateProperties (IsolateData*,Local<FunctionTemplate>)",node_blob.cc,"void Blob::CreatePerIsolateProperties(IsolateData* isolate_data,
                                      Local<FunctionTemplate> ctor) {
  Isolate* isolate = isolate_data->isolate();
  Local<ObjectTemplate> target = ctor->InstanceTemplate();

  SetMethod(isolate, target, ""createBlob"", New);
  SetMethod(isolate, target, ""storeDataObject"", StoreDataObject);
  SetMethod(isolate, target, ""getDataObject"", GetDataObject);
  SetMethod(isolate, target, ""revokeObjectURL"", RevokeObjectURL);
  SetMethod(isolate, target, ""concat"", Concat);
  SetMethod(isolate, target, ""createBlobFromFilePath"", BlobFromFilePath);
}",111.0,122.0,1.0,1.0,12.0,6,4,24,12,0,0,1,1,0,0,,0,0,4,2,2,void
3326,139099,CreatePerContextProperties,1,node.Blob.CreatePerContextProperties,"void node.Blob.CreatePerContextProperties (Local<Object>,Local<Value>,Local<Context>,void*)",node_blob.cc,"void Blob::CreatePerContextProperties(Local<Object> target,
                                      Local<Value> unused,
                                      Local<Context> context,
                                      void* priv) {
  Realm* realm = Realm::GetCurrent(context);
  realm->AddBindingData<BlobBindingData>(context, target);
}",124.0,130.0,1.0,1.0,7.0,7,7,7,5,0,0,1,1,0,0,,0,0,8,4,4,void
3327,139125,GetConstructorTemplate,1,node.Blob.GetConstructorTemplate,Local<FunctionTemplate> node.Blob.GetConstructorTemplate (Environment*),node_blob.cc,"Local<FunctionTemplate> Blob::GetConstructorTemplate(Environment* env) {
  Local<FunctionTemplate> tmpl = env->blob_constructor_template();
  if (tmpl.IsEmpty()) {
    Isolate* isolate = env->isolate();
    tmpl = NewFunctionTemplate(isolate, nullptr);
    tmpl->InstanceTemplate()->SetInternalFieldCount(
        BaseObject::kInternalFieldCount);
    tmpl->SetClassName(
        FIXED_ONE_BYTE_STRING(env->isolate(), ""Blob""));
    SetProtoMethod(isolate, tmpl, ""getReader"", GetReader);
    SetProtoMethod(isolate, tmpl, ""slice"", ToSlice);
    env->set_blob_constructor_template(tmpl);
  }
  return tmpl;
}",132.0,146.0,1.0,1.0,15.0,14,5,22,8,0,0,2,2,0,0,,0,0,2,1,1,Local<FunctionTemplate>
3328,139195,HasInstance,1,node.Blob.HasInstance,"bool node.Blob.HasInstance (Environment*,ANY)",node_blob.cc,"bool Blob::HasInstance(Environment* env, v8::Local<v8::Value> object) {
  return GetConstructorTemplate(env)->HasInstance(object);
}",148.0,150.0,1.0,1.0,3.0,1,1,2,2,0,0,1,1,0,0,,0,0,4,2,2,bool
3329,139208,Create,1,node.Blob.Create,"BaseObjectPtr<Blob> node.Blob.Create (Environment*,ANY)",node_blob.cc,"BaseObjectPtr<Blob> Blob::Create(Environment* env,
                                 std::shared_ptr<DataQueue> data_queue) {
  HandleScope scope(env->isolate());

  Local<Function> ctor;
  if (!GetConstructorTemplate(env)->GetFunction(env->context()).ToLocal(&ctor))
    return BaseObjectPtr<Blob>();

  Local<Object> obj;
  if (!ctor->NewInstance(env->context()).ToLocal(&obj))
    return BaseObjectPtr<Blob>();

  return MakeBaseObject<Blob>(env, obj, data_queue);
}",152.0,165.0,1.0,1.0,14.0,19,8,18,9,0,0,3,3,0,0,,0,0,4,2,2,BaseObjectPtr<Blob>
3330,139277,New,1,node.Blob.New,void node.Blob.New (FunctionCallbackInfo<Value>),node_blob.cc,"void Blob::New(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  CHECK(args[0]->IsArray());  // sources

  Local<Array> array = args[0].As<Array>();
  std::vector<std::unique_ptr<DataQueue::Entry>> entries(array->Length());

  for (size_t i = 0; i < array->Length(); i++) {
    Local<Value> entry;
    if (!array->Get(env->context(), i).ToLocal(&entry)) {
      return;
    }

    const auto entryFromArrayBuffer = [env](v8::Local<v8::ArrayBuffer> buf,
                                            size_t byte_length,
                                            size_t byte_offset = 0) {
      if (buf->IsDetachable()) {
        std::shared_ptr<BackingStore> store = buf->GetBackingStore();
        USE(buf->Detach(Local<Value>()));
        return DataQueue::CreateInMemoryEntryFromBackingStore(
            store, byte_offset, byte_length);
      }

      // If the ArrayBuffer is not detachable, we will copy from it instead.
      std::shared_ptr<B...",167.0,227.0,1.0,1.0,61.0,41,9,40,16,0,0,5,7,0,0,,0,0,2,1,1,void
3331,139486,GetReader,1,node.Blob.GetReader,void node.Blob.GetReader (FunctionCallbackInfo<Value>),node_blob.cc,"void Blob::GetReader(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Blob* blob;
  ASSIGN_OR_RETURN_UNWRAP(&blob, args.Holder());

  BaseObjectPtr<Blob::Reader> reader =
      Blob::Reader::Create(env, BaseObjectPtr<Blob>(blob));
  if (reader) args.GetReturnValue().Set(reader->object());
}",229.0,237.0,1.0,1.0,9.0,15,6,17,8,0,0,2,2,0,0,,0,0,2,1,1,void
3332,139541,ToSlice,1,node.Blob.ToSlice,void node.Blob.ToSlice (FunctionCallbackInfo<Value>),node_blob.cc,"void Blob::ToSlice(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Blob* blob;
  ASSIGN_OR_RETURN_UNWRAP(&blob, args.Holder());
  CHECK(args[0]->IsUint32());
  CHECK(args[1]->IsUint32());
  size_t start = args[0].As<Uint32>()->Value();
  size_t end = args[1].As<Uint32>()->Value();
  BaseObjectPtr<Blob> slice = blob->Slice(env, start, end);
  if (slice)
    args.GetReturnValue().Set(slice->object());
}",239.0,250.0,1.0,1.0,12.0,23,7,21,9,0,0,2,2,0,0,,0,0,2,1,1,void
3333,139627,MemoryInfo,1,node.Blob.MemoryInfo,void node.Blob.MemoryInfo (MemoryTracker*),node_blob.cc,"void Blob::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackField(""data_queue_"", data_queue_, ""std::shared_ptr<DataQueue>"");
}",252.0,254.0,1.0,1.0,3.0,1,1,2,2,0,0,1,1,0,0,,0,0,2,1,1,void
3334,139639,Slice,1,node.Blob.Slice,"BaseObjectPtr<Blob> node.Blob.Slice (Environment*,size_t,size_t)",node_blob.cc,"BaseObjectPtr<Blob> Blob::Slice(Environment* env, size_t start, size_t end) {
  return Create(env,
                this->data_queue_->slice(start, static_cast<uint64_t>(end)));
}",256.0,259.0,1.0,1.0,4.0,3,2,3,3,0,0,1,1,0,0,,0,0,6,3,3,BaseObjectPtr<Blob>
3335,139659,Blob,1,node.Blob.Blob,"ANY node.Blob.Blob (Environment*,ANY,ANY)",node_blob.cc,"Blob::Blob(Environment* env,
           v8::Local<v8::Object> obj,
           std::shared_ptr<DataQueue> data_queue)
    : BaseObject(env, obj), data_queue_(data_queue) {
  MakeWeak();
}",261.0,266.0,1.0,1.0,6.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,ANY
3336,139667,Reader,1,node.Blob.Reader.Reader,"ANY node.Blob.Reader.Reader (Environment*,ANY,BaseObjectPtr<Blob>)",node_blob.cc,"Blob::Reader::Reader(Environment* env,
                     v8::Local<v8::Object> obj,
                     BaseObjectPtr<Blob> strong_ptr)
    : AsyncWrap(env, obj, AsyncWrap::PROVIDER_BLOBREADER),
      inner_(strong_ptr->data_queue_->get_reader()),
      strong_ptr_(std::move(strong_ptr)) {
  MakeWeak();
}",268.0,275.0,1.0,1.0,8.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,ANY
3337,139675,HasInstance,1,node.Blob.Reader.HasInstance,"bool node.Blob.Reader.HasInstance (Environment*,ANY)",node_blob.cc,"bool Blob::Reader::HasInstance(Environment* env, v8::Local<v8::Value> value) {
  return GetConstructorTemplate(env)->HasInstance(value);
}",277.0,279.0,1.0,1.0,3.0,1,1,2,2,0,0,1,1,0,0,,0,0,4,2,2,bool
3338,139688,GetConstructorTemplate,1,node.Blob.Reader.GetConstructorTemplate,Local<FunctionTemplate> node.Blob.Reader.GetConstructorTemplate (Environment*),node_blob.cc,"Local<FunctionTemplate> Blob::Reader::GetConstructorTemplate(Environment* env) {
  Local<FunctionTemplate> tmpl = env->blob_reader_constructor_template();
  if (tmpl.IsEmpty()) {
    Isolate* isolate = env->isolate();
    tmpl = NewFunctionTemplate(isolate, nullptr);
    tmpl->InstanceTemplate()->SetInternalFieldCount(
        BaseObject::kInternalFieldCount);
    tmpl->SetClassName(FIXED_ONE_BYTE_STRING(env->isolate(), ""BlobReader""));
    SetProtoMethod(env->isolate(), tmpl, ""pull"", Pull);
    env->set_blob_reader_constructor_template(tmpl);
  }
  return tmpl;
}",281.0,293.0,1.0,1.0,13.0,15,5,19,7,0,0,2,2,0,0,,0,0,2,1,1,Local<FunctionTemplate>
3339,139756,Create,1,node.Blob.Reader.Create,"BaseObjectPtr<Blob::Reader> node.Blob.Reader.Create (Environment*,BaseObjectPtr<Blob>)",node_blob.cc,"BaseObjectPtr<Blob::Reader> Blob::Reader::Create(Environment* env,
                                                 BaseObjectPtr<Blob> blob) {
  Local<Object> obj;
  if (!GetConstructorTemplate(env)
           ->InstanceTemplate()
           ->NewInstance(env->context())
           .ToLocal(&obj)) {
    return BaseObjectPtr<Blob::Reader>();
  }

  return MakeBaseObject<Blob::Reader>(env, obj, std::move(blob));
}",295.0,306.0,1.0,1.0,12.0,14,8,13,9,0,0,2,2,0,0,,0,0,4,2,2,BaseObjectPtr<Blob.Reader>
3340,139806,Pull,1,node.Blob.Reader.Pull,void node.Blob.Reader.Pull (FunctionCallbackInfo<Value>),node_blob.cc,"void Blob::Reader::Pull(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Blob::Reader* reader;
  ASSIGN_OR_RETURN_UNWRAP(&reader, args.Holder());

  CHECK(args[0]->IsFunction());
  Local<Function> fn = args[0].As<Function>();
  CHECK(!fn->IsConstructor());

  if (reader->eos_) {
    Local<Value> arg = Int32::New(env->isolate(), bob::STATUS_EOS);
    reader->MakeCallback(fn, 1, &arg);
    return args.GetReturnValue().Set(bob::STATUS_EOS);
  }

  struct Impl {
    BaseObjectPtr<Blob::Reader> reader;
    Global<Function> callback;
    Environment* env;
  };
  // TODO(@jasnell): A unique_ptr is likely better here but making this a unique
  // pointer that is passed into the lambda causes the std::move(next) below to
  // complain about std::function needing to be copy-constructible.
  Impl* impl = new Impl();
  impl->reader = BaseObjectPtr<Blob::Reader>(reader);
  impl->callback.Reset(env->isolate(), fn);
  impl->env = env;

  auto next = ...",308.0,376.0,1.0,1.0,69.0,45,9,41,18,0,1,2,2,0,0,,0,1,2,1,1,void
3341,139953,Deserialize,1,node.Blob.BlobTransferData.Deserialize,"BaseObjectPtr<BaseObject> node.Blob.BlobTransferData.Deserialize (Environment*,Local<Context>,ANY)",node_blob.cc,"BaseObjectPtr<BaseObject>
Blob::BlobTransferData::Deserialize(
    Environment* env,
    Local<Context> context,
    std::unique_ptr<worker::TransferData> self) {
  if (context != env->context()) {
    THROW_ERR_MESSAGE_TARGET_CONTEXT_UNAVAILABLE(env);
    return {};
  }
  return Blob::Create(env, data_queue);
}",378.0,388.0,1.0,1.0,11.0,3,3,6,4,0,0,2,2,0,0,,0,0,6,3,3,BaseObjectPtr<BaseObject>
3342,139978,GetTransferMode,1,node.Blob.GetTransferMode,TransferMode node.Blob.GetTransferMode (),node_blob.cc,"BaseObject::TransferMode Blob::GetTransferMode() const {
  return BaseObject::TransferMode::kCloneable;
}",390.0,392.0,1.0,1.0,3.0,2,1,2,2,0,0,1,1,0,0,,0,0,0,0,0,TransferMode
3343,139988,CloneForMessaging,1,node.Blob.CloneForMessaging,unique_ptr<worker::TransferData> node.Blob.CloneForMessaging (),node_blob.cc,"std::unique_ptr<worker::TransferData> Blob::CloneForMessaging() const {
  return std::make_unique<BlobTransferData>(data_queue_);
}",394.0,396.0,1.0,1.0,3.0,3,3,3,3,0,0,1,1,0,0,,0,0,0,0,0,unique_ptr<worker.TransferData>
3344,140000,StoreDataObject,1,node.Blob.StoreDataObject,void node.Blob.StoreDataObject (ANY),node_blob.cc,"void Blob::StoreDataObject(const v8::FunctionCallbackInfo<v8::Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  BlobBindingData* binding_data = Realm::GetBindingData<BlobBindingData>(args);

  CHECK(args[0]->IsString());  // ID key
  CHECK(Blob::HasInstance(env, args[1]));  // Blob
  CHECK(args[2]->IsUint32());  // Length
  CHECK(args[3]->IsString());  // Type

  Utf8Value key(env->isolate(), args[0]);
  Blob* blob;
  ASSIGN_OR_RETURN_UNWRAP(&blob, args[1]);

  size_t length = args[2].As<Uint32>()->Value();
  Utf8Value type(env->isolate(), args[3]);

  binding_data->store_data_object(
      std::string(*key, key.length()),
      BlobBindingData::StoredDataObject(
        BaseObjectPtr<Blob>(blob),
        length,
        std::string(*type, type.length())));
}",398.0,420.0,1.0,1.0,23.0,34,8,33,13,0,0,1,1,0,0,,0,0,2,1,1,void
3345,140124,RevokeObjectURL,1,node.Blob.RevokeObjectURL,void node.Blob.RevokeObjectURL (FunctionCallbackInfo<Value>),node_blob.cc,"void Blob::RevokeObjectURL(const FunctionCallbackInfo<Value>& args) {
  CHECK_GE(args.Length(), 1);
  CHECK(args[0]->IsString());
  BlobBindingData* binding_data = Realm::GetBindingData<BlobBindingData>(args);
  Environment* env = Environment::GetCurrent(args);
  Utf8Value input(env->isolate(), args[0].As<String>());
  auto out = ada::parse<ada::url_aggregator>(input.ToStringView());

  if (!out) {
    return;
  }

  auto pathname = out->get_pathname();
  auto start_index = pathname.find(':');

  if (start_index != std::string_view::npos && start_index != pathname.size()) {
    auto end_index = pathname.find(':', start_index + 1);
    if (end_index == std::string_view::npos) {
      auto id = std::string(pathname.substr(start_index + 1));
      binding_data->revoke_data_object(id);
    }
  }
}",423.0,445.0,1.0,1.0,23.0,40,11,37,15,0,0,4,5,0,0,,0,0,2,1,1,void
3346,140262,GetDataObject,1,node.Blob.GetDataObject,void node.Blob.GetDataObject (ANY),node_blob.cc,"void Blob::GetDataObject(const v8::FunctionCallbackInfo<v8::Value>& args) {
  BlobBindingData* binding_data = Realm::GetBindingData<BlobBindingData>(args);

  Environment* env = Environment::GetCurrent(args);
  CHECK(args[0]->IsString());

  Utf8Value key(env->isolate(), args[0]);

  BlobBindingData::StoredDataObject stored =
      binding_data->get_data_object(std::string(*key, key.length()));
  if (stored.blob) {
    Local<Value> type;
    if (!String::NewFromUtf8(
            env->isolate(),
            stored.type.c_str(),
            v8::NewStringType::kNormal,
            static_cast<int>(stored.type.length())).ToLocal(&type)) {
      return;
    }

    Local<Value> values[] = {
      stored.blob->object(),
      Uint32::NewFromUnsigned(env->isolate(), stored.length),
      type
    };

    args.GetReturnValue().Set(
        Array::New(
            env->isolate(),
            values,
            arraysize(values)));
  }
}",447.0,479.0,1.0,1.0,33.0,41,11,37,18,0,0,3,4,0,0,,0,0,2,1,1,void
3347,140404,MemoryInfo,1,node.BlobBindingData.StoredDataObject.MemoryInfo,void node.BlobBindingData.StoredDataObject.MemoryInfo (MemoryTracker*),node_blob.cc,"void BlobBindingData::StoredDataObject::MemoryInfo(
    MemoryTracker* tracker) const {
  tracker->TrackField(""blob"", blob, ""BaseObjectPtr<Blob>"");
}",481.0,484.0,1.0,1.0,4.0,1,1,2,2,0,0,1,1,0,0,,0,0,2,1,1,void
3348,140416,StoredDataObject,1,node.BlobBindingData.StoredDataObject.StoredDataObject,"ANY node.BlobBindingData.StoredDataObject.StoredDataObject (BaseObjectPtr<Blob>,size_t,ANY)",node_blob.cc,"BlobBindingData::StoredDataObject::StoredDataObject(
    const BaseObjectPtr<Blob>& blob_,
    size_t length_,
    const std::string& type_)
    : blob(blob_),
      length(length_),
      type(type_) {}",486.0,492.0,1.0,20.0,7.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,ANY
3349,140423,BlobBindingData,1,node.BlobBindingData.BlobBindingData,"ANY node.BlobBindingData.BlobBindingData (Realm*,Local<Object>)",node_blob.cc,"BlobBindingData::BlobBindingData(Realm* realm, Local<Object> wrap)
    : SnapshotableObject(realm, wrap, type_int) {
  MakeWeak();
}",494.0,497.0,1.0,1.0,4.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,ANY
3350,140430,MemoryInfo,1,node.BlobBindingData.MemoryInfo,void node.BlobBindingData.MemoryInfo (MemoryTracker*),node_blob.cc,"void BlobBindingData::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackField(""data_objects_"",
                      data_objects_,
                      ""std::unordered_map<std::string, StoredDataObject>"");
}",499.0,503.0,1.0,1.0,5.0,1,1,2,2,0,0,1,1,0,0,,0,0,2,1,1,void
3351,140442,store_data_object,1,node.BlobBindingData.store_data_object,"void node.BlobBindingData.store_data_object (ANY,ANY)",node_blob.cc,"void BlobBindingData::store_data_object(
    const std::string& uuid,
    const BlobBindingData::StoredDataObject& object) {
  data_objects_[uuid] = object;
}",505.0,509.0,1.0,1.0,5.0,2,2,3,3,0,0,1,1,0,0,,0,0,4,2,2,void
3352,140453,revoke_data_object,1,node.BlobBindingData.revoke_data_object,void node.BlobBindingData.revoke_data_object (ANY),node_blob.cc,"void BlobBindingData::revoke_data_object(const std::string& uuid) {
  if (data_objects_.find(uuid) == data_objects_.end()) {
    return;
  }
  data_objects_.erase(uuid);
  CHECK_EQ(data_objects_.find(uuid), data_objects_.end());
}",511.0,517.0,1.0,1.0,7.0,6,2,8,2,0,0,2,2,0,0,,0,0,2,1,1,void
3353,140486,get_data_object,1,node.BlobBindingData.get_data_object,StoredDataObject node.BlobBindingData.get_data_object (ANY),node_blob.cc,"BlobBindingData::StoredDataObject BlobBindingData::get_data_object(
    const std::string& uuid) {
  auto entry = data_objects_.find(uuid);
  if (entry == data_objects_.end())
    return BlobBindingData::StoredDataObject {};
  return entry->second;
}",519.0,525.0,1.0,1.0,7.0,6,5,6,3,0,0,2,2,0,0,,0,0,2,1,1,StoredDataObject
3354,140514,Deserialize,1,node.BlobBindingData.Deserialize,"void node.BlobBindingData.Deserialize (Local<Context>,Local<Object>,int,InternalFieldInfoBase*)",node_blob.cc,"void BlobBindingData::Deserialize(Local<Context> context,
                                  Local<Object> holder,
                                  int index,
                                  InternalFieldInfoBase* info) {
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  HandleScope scope(context->GetIsolate());
  Realm* realm = Realm::GetCurrent(context);
  BlobBindingData* binding =
      realm->AddBindingData<BlobBindingData>(context, holder);
  CHECK_NOT_NULL(binding);
}",527.0,537.0,1.0,1.0,11.0,10,7,12,8,0,0,1,1,0,0,,0,0,8,4,4,void
3355,140556,PrepareForSerialization,1,node.BlobBindingData.PrepareForSerialization,"bool node.BlobBindingData.PrepareForSerialization (Local<Context>,ANY*)",node_blob.cc,"bool BlobBindingData::PrepareForSerialization(Local<Context> context,
                                              v8::SnapshotCreator* creator) {
  // Stored blob objects are not actually persisted.
  // Return true because we need to maintain the reference to the binding from
  // JS land.
  return true;
}",539.0,545.0,1.0,1.0,7.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,bool
3356,140564,Serialize,1,node.BlobBindingData.Serialize,InternalFieldInfoBase node.BlobBindingData.Serialize (int),node_blob.cc,"InternalFieldInfoBase* BlobBindingData::Serialize(int index) {
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  InternalFieldInfo* info =
      InternalFieldInfoBase::New<InternalFieldInfo>(type());
  return info;
}",547.0,552.0,1.0,1.0,6.0,5,4,6,5,0,0,1,1,0,0,,0,0,2,1,1,InternalFieldInfoBase
3357,140586,RegisterExternalReferences,1,node.Blob.RegisterExternalReferences,void node.Blob.RegisterExternalReferences (ExternalReferenceRegistry*),node_blob.cc,"void Blob::RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  registry->Register(Blob::New);
  registry->Register(Blob::GetReader);
  registry->Register(Blob::ToSlice);
  registry->Register(Blob::StoreDataObject);
  registry->Register(Blob::GetDataObject);
  registry->Register(Blob::RevokeObjectURL);
  registry->Register(Blob::Reader::Pull);
  registry->Register(Concat);
  registry->Register(BlobFromFilePath);
}",554.0,564.0,1.0,1.0,11.0,17,2,19,5,0,0,1,1,0,0,,0,0,2,1,1,void
3358,140687,<lambda>0,1,node.bob.SourceImpl<T>.Pull.<lambda>0,ANY node.bob.SourceImpl<T>.Pull.<lambda>0 (size_t),node_bob-inl.hpp,[](size_t len) {},22.0,22.0,41.0,57.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
3359,140703,Pull,1,node.bob.SourceImpl<T>.Pull,"int node.bob.SourceImpl<T>.Pull<T> (Next<T>,int,T*,size_t,size_t)",node_bob-inl.hpp,"int SourceImpl<T>::Pull(
    Next<T> next,
    int options,
    T* data,
    size_t count,
    size_t max_count_hint) {

  int status;
  if (eos_) {
    status = bob::Status::STATUS_EOS;
    std::move(next)(status, nullptr, 0, [](size_t len) {});
    return status;
  }

  status = DoPull(std::move(next), options, data, count, max_count_hint);

  if (status == bob::Status::STATUS_EOS) eos_ = true;

  return status;
}",12.0,31.0,1.0,1.0,20.0,10,3,20,10,0,0,3,3,0,0,,0,0,10,5,5,int
3360,140815,~Source,1,node.bob.Source.~Source,ANY node.bob.Source.~Source (),node_bob.hpp,virtual ~Source() = default;,70.0,70.0,3.0,30.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
3361,140819,Pull,1,node.bob.Source.Pull,"int node.bob.Source.Pull (Next<T>,int,T*,size_t,size_t)",node_bob.hpp,"virtual int Pull(
      Next<T> next,
      int options,
      T* data,
      size_t count,
      size_t max_count_hint = kMaxCountHint) = 0;",71.0,76.0,15.0,48.0,6.0,0,0,0,0,0,0,1,1,0,0,,0,0,10,5,5,int
3362,140829,Pull,1,node.bob.SourceImpl.Pull,"int node.bob.SourceImpl.Pull (Next<T>,int,T*,size_t,size_t)",node_bob.hpp,"int Pull(
      Next<T> next,
      int options,
      T* data,
      size_t count,
      size_t max_count_hint = kMaxCountHint) override;",83.0,88.0,7.0,53.0,6.0,0,0,0,0,0,0,1,1,0,0,,0,0,10,5,5,int
3363,140838,is_eos,1,node.bob.SourceImpl.is_eos,bool node.bob.SourceImpl.is_eos (),node_bob.hpp,bool is_eos() const { return eos_; },90.0,90.0,3.0,38.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,bool
3364,140844,DoPull,1,node.bob.SourceImpl.DoPull,"int node.bob.SourceImpl.DoPull (Next<T>,int,T*,size_t,size_t)",node_bob.hpp,"virtual int DoPull(
      Next<T> next,
      int options,
      T* data,
      size_t count,
      size_t max_count_hint) = 0;",93.0,98.0,15.0,32.0,6.0,0,0,0,0,0,0,1,1,0,0,,0,0,10,5,5,int
3365,140862,<lambda>0,1,node.Buffer.anonymous_namespace_10.CallbackInfo.CreateTrackedArrayBuffer.<lambda>0,"ANY node.Buffer.anonymous_namespace_10.CallbackInfo.CreateTrackedArrayBuffer.<lambda>0 (void*,size_t,void*)",node_buffer.cc,"[](void*, size_t, void* arg) {
        static_cast<CallbackInfo*>(arg)->OnBackingStoreFree();
      }",122.0,124.0,50.0,7.0,3.0,2,2,1,1,0,0,1,1,0,0,,0,0,6,3,3,ANY
3366,140877,<lambda>1,1,node.Buffer.anonymous_namespace_16.CallbackInfo.OnBackingStoreFree.<lambda>1,ANY node.Buffer.anonymous_namespace_16.CallbackInfo.OnBackingStoreFree.<lambda>1 (Environment*),node_buffer.cc,"[self = std::move(self)](Environment* env) {
    CHECK_EQ(self->env_, env);  // Consistency check.

    self->CallAndResetCallback();
  }",198.0,202.0,32.0,3.0,5.0,2,1,3,2,0,0,1,1,0,0,,0,0,2,1,1,ANY
3367,140893,<lambda>2,1,node.Buffer.New.<lambda>2,"ANY node.Buffer.New.<lambda>2 (void*,size_t,void*)",node_buffer.cc,"[](void* data, size_t length, void* deleter_data) {
    free(data);
  }",509.0,511.0,24.0,3.0,3.0,0,0,1,1,0,0,1,1,0,0,,0,0,6,3,3,ANY
3368,140904,<lambda>3,1,node.Buffer.anonymous_namespace_43.GetZeroFillToggle.<lambda>3,"ANY node.Buffer.anonymous_namespace_43.GetZeroFillToggle.<lambda>3 (void*,size_t,void*)",node_buffer.cc,"[](void*, size_t, void*) {}",1179.0,1179.0,38.0,64.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,ANY
3369,140951,CreateTrackedArrayBuffer,1,node.Buffer.anonymous_namespace_2.CallbackInfo.CreateTrackedArrayBuffer,"Local<ArrayBuffer> node.Buffer.anonymous_namespace_2.CallbackInfo.CreateTrackedArrayBuffer (Environment*,char*,size_t,FreeCallback,void*)",node_buffer.cc,"static inline Local<ArrayBuffer> CreateTrackedArrayBuffer(
      Environment* env,
      char* data,
      size_t length,
      FreeCallback callback,
      void* hint);",84.0,89.0,36.0,17.0,6.0,0,0,0,0,0,0,1,1,0,0,,0,0,10,5,5,Local<ArrayBuffer>
3370,140960,CallbackInfo,1,node.Buffer.anonymous_namespace_3.CallbackInfo.CallbackInfo,ANY node.Buffer.anonymous_namespace_3.CallbackInfo.CallbackInfo (CallbackInfo),node_buffer.cc,CallbackInfo(const CallbackInfo&) = delete;,91.0,91.0,3.0,45.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
3371,140965,operator =,1,node.Buffer.anonymous_namespace_4.CallbackInfo.operator =,CallbackInfo node.Buffer.anonymous_namespace_4.CallbackInfo.operator = (CallbackInfo),node_buffer.cc,CallbackInfo& operator=(const CallbackInfo&) = delete;,92.0,92.0,3.0,56.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,CallbackInfo
3372,140970,CleanupHook,1,node.Buffer.anonymous_namespace_5.CallbackInfo.CleanupHook,void node.Buffer.anonymous_namespace_5.CallbackInfo.CleanupHook (void*),node_buffer.cc,static void CleanupHook(void* data);,95.0,95.0,15.0,37.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
3373,140975,OnBackingStoreFree,1,node.Buffer.anonymous_namespace_6.CallbackInfo.OnBackingStoreFree,void node.Buffer.anonymous_namespace_6.CallbackInfo.OnBackingStoreFree (),node_buffer.cc,inline void OnBackingStoreFree();,96.0,96.0,15.0,34.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
3374,140979,CallAndResetCallback,1,node.Buffer.anonymous_namespace_7.CallbackInfo.CallAndResetCallback,void node.Buffer.anonymous_namespace_7.CallbackInfo.CallAndResetCallback (),node_buffer.cc,inline void CallAndResetCallback();,97.0,97.0,15.0,36.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
3375,140983,CallbackInfo,1,node.Buffer.anonymous_namespace_8.CallbackInfo.CallbackInfo,"inline node.Buffer.anonymous_namespace_8.CallbackInfo.CallbackInfo (Environment*,FreeCallback,char*,void*)",node_buffer.cc,"inline CallbackInfo(Environment* env,
                      FreeCallback callback,
                      char* data,
                      void* hint);",98.0,101.0,10.0,33.0,4.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,inline
3376,140997,CreateTrackedArrayBuffer,1,node.Buffer.anonymous_namespace_9.CallbackInfo.CreateTrackedArrayBuffer,"Local<ArrayBuffer> node.Buffer.anonymous_namespace_9.CallbackInfo.CreateTrackedArrayBuffer (Environment*,char*,size_t,FreeCallback,void*)",node_buffer.cc,"Local<ArrayBuffer> CallbackInfo::CreateTrackedArrayBuffer(
    Environment* env,
    char* data,
    size_t length,
    FreeCallback callback,
    void* hint) {
  CHECK_NOT_NULL(callback);
  CHECK_IMPLIES(data == nullptr, length == 0);

  CallbackInfo* self = new CallbackInfo(env, callback, data, hint);
  std::unique_ptr<BackingStore> bs =
      ArrayBuffer::NewBackingStore(data, length, [](void*, size_t, void* arg) {
        static_cast<CallbackInfo*>(arg)->OnBackingStoreFree();
      }, self);
  Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(bs));

  // V8 simply ignores the BackingStore deleter callback if data == nullptr,
  // but our API contract requires it being called.
  if (data == nullptr) {
    ab->Detach(Local<Value>()).Check();
    self->OnBackingStoreFree();  // This calls `callback` asynchronously.
  } else {
    // Store the ArrayBuffer so that we can detach it later.
    self->persistent_.Reset(env->isolate(), ab);
    self->persistent_.SetWeak()...",111.0,139.0,1.0,1.0,29.0,19,7,27,13,0,0,2,2,0,0,,0,0,10,5,5,Local<ArrayBuffer>
3377,141097,CallbackInfo,1,node.Buffer.anonymous_namespace_11.CallbackInfo.CallbackInfo,"ANY node.Buffer.anonymous_namespace_11.CallbackInfo.CallbackInfo (Environment*,FreeCallback,char*,void*)",node_buffer.cc,"CallbackInfo::CallbackInfo(Environment* env,
                           FreeCallback callback,
                           char* data,
                           void* hint)
    : callback_(callback),
      data_(data),
      hint_(hint),
      env_(env) {
  env->AddCleanupHook(CleanupHook, this);
  env->isolate()->AdjustAmountOfExternalAllocatedMemory(sizeof(*this));
}",142.0,152.0,1.0,1.0,11.0,5,3,3,2,0,0,1,1,0,0,,0,0,8,4,4,ANY
3378,141121,CleanupHook,1,node.Buffer.anonymous_namespace_12.CallbackInfo.CleanupHook,void node.Buffer.anonymous_namespace_12.CallbackInfo.CleanupHook (void*),node_buffer.cc,"void CallbackInfo::CleanupHook(void* data) {
  CallbackInfo* self = static_cast<CallbackInfo*>(data);

  {
    HandleScope handle_scope(self->env_->isolate());
    Local<ArrayBuffer> ab = self->persistent_.Get(self->env_->isolate());
    if (!ab.IsEmpty() && ab->IsDetachable()) {
      ab->Detach(Local<Value>()).Check();
      self->persistent_.Reset();
    }
  }

  // Call the callback in this case, but don't delete `this` yet because the
  // BackingStore deleter callback will do so later.
  self->CallAndResetCallback();
}",154.0,169.0,1.0,1.0,16.0,20,8,13,5,0,4,2,2,0,0,,0,4,2,1,1,void
3379,141189,CallAndResetCallback,1,node.Buffer.anonymous_namespace_13.CallbackInfo.CallAndResetCallback,void node.Buffer.anonymous_namespace_13.CallbackInfo.CallAndResetCallback (),node_buffer.cc,"void CallbackInfo::CallAndResetCallback() {
  FreeCallback callback;
  {
    Mutex::ScopedLock lock(mutex_);
    callback = callback_;
    callback_ = nullptr;
  }
  if (callback != nullptr) {
    // Clean up all Environment-related state and run the callback.
    env_->RemoveCleanupHook(CleanupHook, this);
    int64_t change_in_bytes = -static_cast<int64_t>(sizeof(*this));
    env_->isolate()->AdjustAmountOfExternalAllocatedMemory(change_in_bytes);

    callback(data_, hint_);
  }
}",171.0,186.0,1.0,1.0,16.0,11,7,11,7,0,0,2,2,0,0,,0,0,0,0,0,void
3380,141235,OnBackingStoreFree,1,node.Buffer.anonymous_namespace_15.CallbackInfo.OnBackingStoreFree,void node.Buffer.anonymous_namespace_15.CallbackInfo.OnBackingStoreFree (),node_buffer.cc,"void CallbackInfo::OnBackingStoreFree() {
  // This method should always release the memory for `this`.
  std::unique_ptr<CallbackInfo> self { this };
  Mutex::ScopedLock lock(mutex_);
  // If callback_ == nullptr, that means that the callback has already run from
  // the cleanup hook, and there is nothing left to do here besides to clean
  // up the memory involved. In particular, the underlying `Environment` may
  // be gone at this point, so dont attempt to call SetImmediateThreadsafe().
  if (callback_ == nullptr) return;

  env_->SetImmediateThreadsafe([self = std::move(self)](Environment* env) {
    CHECK_EQ(self->env_, env);  // Consistency check.

    self->CallAndResetCallback();
  });
}",188.0,203.0,1.0,1.0,16.0,4,4,4,4,0,0,2,2,0,0,,0,0,0,0,0,void
3381,141258,HasInstance,1,node.Buffer.HasInstance,bool node.Buffer.HasInstance (Local<Value>),node_buffer.cc,"bool HasInstance(Local<Object> obj) {
  return obj->IsArrayBufferView();
}",242.0,244.0,1.0,1.0,3.0,1,1,1,1,1,0,1,1,0,0,,0,0,2,1,1,bool
3382,141278,Data,1,node.Buffer.Data,char* node.Buffer.Data (Local<Value>),node_buffer.cc,"char* Data(Local<Object> obj) {
  return Data(obj.As<Value>());
}",254.0,256.0,1.0,1.0,3.0,10,7,7,4,3,0,1,1,0,0,,0,0,2,1,1,char*
3383,141324,Length,1,node.Buffer.Length,size_t node.Buffer.Length (Local<Value>),node_buffer.cc,"size_t Length(Local<Object> obj) {
  CHECK(obj->IsArrayBufferView());
  Local<ArrayBufferView> ui = obj.As<ArrayBufferView>();
  return ui->ByteLength();
}",266.0,270.0,1.0,1.0,5.0,6,5,6,4,1,0,1,1,0,0,,0,0,2,1,1,size_t
3384,141374,New,1,node.Buffer.New,"MaybeLocal<Uint8Array> node.Buffer.New (Environment*,Local<ArrayBuffer>,size_t,size_t)",node_buffer.cc,"MaybeLocal<Object> New(Environment* env,
                       char* data,
                       size_t length) {
  if (length > 0) {
    CHECK_NOT_NULL(data);
    // V8 currently only allows a maximum Typed Array index of max Smi.
    if (length > kMaxLength) {
      Isolate* isolate(env->isolate());
      isolate->ThrowException(ERR_BUFFER_TOO_LARGE(isolate));
      free(data);
      return Local<Object>();
    }
  }

  EscapableHandleScope handle_scope(env->isolate());

  auto free_callback = [](void* data, size_t length, void* deleter_data) {
    free(data);
  };
  std::unique_ptr<BackingStore> bs =
      v8::ArrayBuffer::NewBackingStore(data, length, free_callback, nullptr);

  Local<ArrayBuffer> ab = v8::ArrayBuffer::New(env->isolate(), std::move(bs));

  Local<Object> obj;
  if (Buffer::New(env, ab, 0, length).ToLocal(&obj))
    return handle_scope.Escape(obj);
  return Local<Object>();
}",493.0,521.0,1.0,1.0,29.0,12,6,14,8,2,0,2,2,0,0,,0,0,6,3,3,MaybeLocal<Object>
3385,141759,Copy,1,node.Buffer.Copy,"MaybeLocal<Object> node.Buffer.Copy (Isolate*,char*,size_t)",node_buffer.cc,"MaybeLocal<Object> Copy(Environment* env, const char* data, size_t length) {
  Isolate* isolate(env->isolate());
  EscapableHandleScope scope(isolate);

  // V8 currently only allows a maximum Typed Array index of max Smi.
  if (length > kMaxLength) {
    isolate->ThrowException(ERR_BUFFER_TOO_LARGE(isolate));
    return Local<Object>();
  }

  Local<ArrayBuffer> ab;
  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    std::unique_ptr<BackingStore> bs =
        ArrayBuffer::NewBackingStore(isolate, length);

    CHECK(bs);

    memcpy(bs->Data(), data, length);

    ab = ArrayBuffer::New(isolate, std::move(bs));
  }

  MaybeLocal<Object> obj =
      New(env, ab, 0, ab->ByteLength())
          .FromMaybe(Local<Uint8Array>());

  return scope.EscapeMaybe(obj);
}",398.0,426.0,1.0,1.0,29.0,9,6,16,10,1,0,3,3,0,0,,0,0,6,3,3,MaybeLocal<Object>
3386,142238,CreateFromString,1,node.Buffer.anonymous_namespace_19.CreateFromString,void node.Buffer.anonymous_namespace_19.CreateFromString (FunctionCallbackInfo<Value>),node_buffer.cc,"void CreateFromString(const FunctionCallbackInfo<Value>& args) {
  CHECK(args[0]->IsString());
  CHECK(args[1]->IsInt32());

  enum encoding enc = static_cast<enum encoding>(args[1].As<Int32>()->Value());
  Local<Object> buf;
  if (New(args.GetIsolate(), args[0].As<String>(), enc).ToLocal(&buf))
    args.GetReturnValue().Set(buf);
}",525.0,533.0,1.0,1.0,9.0,18,8,13,5,0,0,2,2,0,0,,0,0,2,1,1,void
3387,142303,StringSlice,1,node.Buffer.anonymous_namespace_20.StringSlice,void node.Buffer.anonymous_namespace_20.StringSlice<encoding> (FunctionCallbackInfo<Value>),node_buffer.cc,"void StringSlice(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  THROW_AND_RETURN_UNLESS_BUFFER(env, args.This());
  ArrayBufferViewContents<char> buffer(args.This());

  if (buffer.length() == 0)
    return args.GetReturnValue().SetEmptyString();

  size_t start = 0;
  size_t end = 0;
  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[0], 0, &start));
  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[1], buffer.length(), &end));
  if (end < start) end = start;
  THROW_AND_RETURN_IF_OOB(Just(end <= buffer.length()));
  size_t length = end - start;

  Local<Value> error;
  MaybeLocal<Value> maybe_ret =
      StringBytes::Encode(isolate,
                          buffer.data() + start,
                          length,
                          encoding,
                          &error);
  Local<Value> ret;
  if (!maybe_ret.ToLocal(&ret)) {
    CHECK(!error.IsEmpty());
    isolate->ThrowExceptio...",537.0,569.0,1.0,2.0,33.0,58,12,68,20,0,0,4,4,0,0,,0,0,2,1,1,void
3388,142557,Copy,1,node.Buffer.anonymous_namespace_21.Copy,void node.Buffer.anonymous_namespace_21.Copy (FunctionCallbackInfo<Value>),node_buffer.cc,"void Copy(const FunctionCallbackInfo<Value> &args) {
  Environment* env = Environment::GetCurrent(args);

  THROW_AND_RETURN_UNLESS_BUFFER(env, args[0]);
  THROW_AND_RETURN_UNLESS_BUFFER(env, args[1]);
  ArrayBufferViewContents<char> source(args[0]);
  Local<Object> target_obj = args[1].As<Object>();
  SPREAD_BUFFER_ARG(target_obj, target);

  size_t target_start = 0;
  size_t source_start = 0;
  size_t source_end = 0;

  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[2], 0, &target_start));
  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[3], 0, &source_start));
  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[4], source.length(),
                                          &source_end));

  // Copy 0 bytes; we're done
  if (target_start >= target_length || source_start >= source_end)
    return args.GetReturnValue().Set(0);

  if (source_start > source.length())
    return THROW_ERR_OUT_OF_RANGE(
        env, ""The value of \""sourceStart\"" is out of range."");

  if (source_e...",572.0,607.0,1.0,2.0,36.0,62,11,78,19,0,0,4,4,0,0,,0,0,2,1,1,void
3389,142831,Fill,1,node.Buffer.anonymous_namespace_22.Fill,void node.Buffer.anonymous_namespace_22.Fill (FunctionCallbackInfo<Value>),node_buffer.cc,"void Fill(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Local<Context> ctx = env->context();

  THROW_AND_RETURN_UNLESS_BUFFER(env, args[0]);
  SPREAD_BUFFER_ARG(args[0], ts_obj);

  size_t start = 0;
  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[2], 0, &start));
  size_t end;
  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[3], 0, &end));

  size_t fill_length = end - start;
  Local<String> str_obj;
  size_t str_length;
  enum encoding enc;

  // OOB Check. Throw the error in JS.
  if (start > end || fill_length + start > ts_obj_length)
    return args.GetReturnValue().Set(-2);

  // First check if Buffer has been passed.
  if (Buffer::HasInstance(args[1])) {
    SPREAD_BUFFER_ARG(args[1], fill_obj);
    str_length = fill_obj_length;
    memcpy(
        ts_obj_data + start, fill_obj_data, std::min(str_length, fill_length));
    goto start_fill;
  }

  // Then coerce everything that's not a string.
  if (!args[1]->IsString(...",610.0,700.0,1.0,2.0,91.0,86,18,111,30,0,0,11,11,0,0,,0,0,2,1,1,void
3390,143248,StringWrite,1,node.Buffer.anonymous_namespace_23.StringWrite,void node.Buffer.anonymous_namespace_23.StringWrite<encoding> (FunctionCallbackInfo<Value>),node_buffer.cc,"void StringWrite(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  THROW_AND_RETURN_UNLESS_BUFFER(env, args.This());
  SPREAD_BUFFER_ARG(args.This(), ts_obj);

  THROW_AND_RETURN_IF_NOT_STRING(env, args[0], ""argument"");

  Local<String> str = args[0]->ToString(env->context()).ToLocalChecked();

  size_t offset = 0;
  size_t max_length = 0;

  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[1], 0, &offset));
  if (offset > ts_obj_length) {
    return node::THROW_ERR_BUFFER_OUT_OF_BOUNDS(
        env, ""\""offset\"" is outside of buffer bounds"");
  }

  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[2], ts_obj_length - offset,
                                          &max_length));

  max_length = std::min(ts_obj_length - offset, max_length);

  if (max_length == 0)
    return args.GetReturnValue().Set(0);

  uint32_t written = StringBytes::Write(
      env->isolate(), ts_obj_data + offset, max_length, str, encoding);
  args.GetReturn...",704.0,734.0,1.0,2.0,31.0,44,11,57,19,0,0,3,3,0,0,,0,0,2,1,1,void
3391,143453,SlowByteLengthUtf8,1,node.Buffer.anonymous_namespace_24.SlowByteLengthUtf8,void node.Buffer.anonymous_namespace_24.SlowByteLengthUtf8 (FunctionCallbackInfo<Value>),node_buffer.cc,"void SlowByteLengthUtf8(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  CHECK(args[0]->IsString());

  // Fast case: avoid StringBytes on UTF8 string. Jump to v8.
  args.GetReturnValue().Set(args[0].As<String>()->Utf8Length(env->isolate()));
}",736.0,742.0,1.0,1.0,7.0,10,4,7,3,0,0,1,1,0,0,,0,0,2,1,1,void
3392,143493,FastByteLengthUtf8,1,node.Buffer.anonymous_namespace_25.FastByteLengthUtf8,"uint32_t node.Buffer.anonymous_namespace_25.FastByteLengthUtf8 (Local<Value>,ANY)",node_buffer.cc,"uint32_t FastByteLengthUtf8(Local<Value> receiver,
                            const v8::FastOneByteString& source) {
  uint32_t result = 0;
  uint32_t length = source.length;
  const uint8_t* data = reinterpret_cast<const uint8_t*>(source.data);
  for (uint32_t i = 0; i < length; ++i) {
    result += (data[i] >> 7);
  }
  result += length;
  return result;
}",744.0,754.0,1.0,1.0,11.0,12,7,14,5,0,0,2,2,0,0,,0,0,4,2,2,uint32_t
3393,143541,fast_byte_length_utf8,1,node.Buffer.anonymous_namespace_26.fast_byte_length_utf8,ANY node.Buffer.anonymous_namespace_26.fast_byte_length_utf8 (ANY),node_buffer.cc,"static v8::CFunction fast_byte_length_utf8(
    v8::CFunction::Make(FastByteLengthUtf8));",756.0,757.0,22.0,44.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
3394,143546,normalizeCompareVal,1,node.Buffer.anonymous_namespace_27.normalizeCompareVal,"int node.Buffer.anonymous_namespace_27.normalizeCompareVal (int,size_t,size_t)",node_buffer.cc,"static int normalizeCompareVal(int val, size_t a_length, size_t b_length) {
  if (val == 0) {
    if (a_length > b_length)
      return 1;
    else if (a_length < b_length)
      return -1;
  } else {
    if (val > 0)
      return 1;
    else
      return -1;
  }
  return val;
}",761.0,774.0,1.0,1.0,14.0,2,2,4,3,0,0,3,4,0,0,,0,0,6,3,3,int
3395,143591,CompareOffset,1,node.Buffer.anonymous_namespace_28.CompareOffset,void node.Buffer.anonymous_namespace_28.CompareOffset (FunctionCallbackInfo<Value>),node_buffer.cc,"void CompareOffset(const FunctionCallbackInfo<Value> &args) {
  Environment* env = Environment::GetCurrent(args);

  THROW_AND_RETURN_UNLESS_BUFFER(env, args[0]);
  THROW_AND_RETURN_UNLESS_BUFFER(env, args[1]);
  ArrayBufferViewContents<char> source(args[0]);
  ArrayBufferViewContents<char> target(args[1]);

  size_t target_start = 0;
  size_t source_start = 0;
  size_t source_end = 0;
  size_t target_end = 0;

  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[2], 0, &target_start));
  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[3], 0, &source_start));
  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[4], target.length(),
                                          &target_end));
  THROW_AND_RETURN_IF_OOB(ParseArrayIndex(env, args[5], source.length(),
                                          &source_end));

  if (source_start > source.length())
    return THROW_ERR_OUT_OF_RANGE(
        env, ""The value of \""sourceStart\"" is out of range."");
  if (target_start > target.lengt...",776.0,818.0,1.0,2.0,43.0,64,9,83,17,0,0,3,3,0,0,,0,0,2,1,1,void
3396,143902,Compare,1,node.Buffer.anonymous_namespace_29.Compare,void node.Buffer.anonymous_namespace_29.Compare (FunctionCallbackInfo<Value>),node_buffer.cc,"void Compare(const FunctionCallbackInfo<Value> &args) {
  Environment* env = Environment::GetCurrent(args);

  THROW_AND_RETURN_UNLESS_BUFFER(env, args[0]);
  THROW_AND_RETURN_UNLESS_BUFFER(env, args[1]);
  ArrayBufferViewContents<char> a(args[0]);
  ArrayBufferViewContents<char> b(args[1]);

  size_t cmp_length = std::min(a.length(), b.length());

  int val = normalizeCompareVal(cmp_length > 0 ?
                                memcmp(a.data(), b.data(), cmp_length) : 0,
                                a.length(), b.length());
  args.GetReturnValue().Set(val);
}",820.0,834.0,1.0,2.0,15.0,21,5,26,8,0,0,1,1,0,0,,0,0,2,1,1,void
3397,143999,IndexOfOffset,1,node.Buffer.anonymous_namespace_30.IndexOfOffset,"int64_t node.Buffer.anonymous_namespace_30.IndexOfOffset (size_t,int64_t,int64_t,bool)",node_buffer.cc,"int64_t IndexOfOffset(size_t length,
                      int64_t offset_i64,
                      int64_t needle_length,
                      bool is_forward) {
  int64_t length_i64 = static_cast<int64_t>(length);
  if (offset_i64 < 0) {
    if (offset_i64 + length_i64 >= 0) {
      // Negative offsets count backwards from the end of the buffer.
      return length_i64 + offset_i64;
    } else if (is_forward || needle_length == 0) {
      // indexOf from before the start of the buffer: search the whole buffer.
      return 0;
    } else {
      // lastIndexOf from before the start of the buffer: no match.
      return -1;
    }
  } else {
    if (offset_i64 + needle_length <= length_i64) {
      // Valid positive offset.
      return offset_i64;
    } else if (needle_length == 0) {
      // Out of buffer bounds, but empty needle: point to end of buffer.
      return length_i64;
    } else if (is_forward) {
      // indexOf from past the end of the buffer: no match.
      return ...",840.0,871.0,1.0,1.0,32.0,6,5,7,3,0,0,3,4,0,0,,0,0,8,4,4,int64_t
3398,144079,IndexOfString,1,node.Buffer.anonymous_namespace_31.IndexOfString,void node.Buffer.anonymous_namespace_31.IndexOfString (FunctionCallbackInfo<Value>),node_buffer.cc,"void IndexOfString(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  CHECK(args[1]->IsString());
  CHECK(args[2]->IsNumber());
  CHECK(args[3]->IsInt32());
  CHECK(args[4]->IsBoolean());

  enum encoding enc = static_cast<enum encoding>(args[3].As<Int32>()->Value());

  THROW_AND_RETURN_UNLESS_BUFFER(env, args[0]);
  ArrayBufferViewContents<char> buffer(args[0]);

  Local<String> needle = args[1].As<String>();
  int64_t offset_i64 = args[2].As<Integer>()->Value();
  bool is_forward = args[4]->IsTrue();

  const char* haystack = buffer.data();
  // Round down to the nearest multiple of 2 in case of UCS2.
  const size_t haystack_length = (enc == UCS2) ?
      buffer.length() &~ 1 : buffer.length();  // NOLINT(whitespace/operators)

  size_t needle_length;
  if (!StringBytes::Size(isolate, needle, enc).To(&needle_length)) return;

  int64_t opt_offset = IndexOfOffset(haystack_length,
                  ...",873.0,989.0,1.0,2.0,117.0,105,21,90,22,0,0,12,19,0,0,,0,0,2,1,1,void
3399,144571,IndexOfBuffer,1,node.Buffer.anonymous_namespace_33.IndexOfBuffer,void node.Buffer.anonymous_namespace_33.IndexOfBuffer (FunctionCallbackInfo<Value>),node_buffer.cc,"void IndexOfBuffer(const FunctionCallbackInfo<Value>& args) {
  CHECK(args[1]->IsObject());
  CHECK(args[2]->IsNumber());
  CHECK(args[3]->IsInt32());
  CHECK(args[4]->IsBoolean());

  enum encoding enc = static_cast<enum encoding>(args[3].As<Int32>()->Value());

  THROW_AND_RETURN_UNLESS_BUFFER(Environment::GetCurrent(args), args[0]);
  THROW_AND_RETURN_UNLESS_BUFFER(Environment::GetCurrent(args), args[1]);
  ArrayBufferViewContents<char> haystack_contents(args[0]);
  ArrayBufferViewContents<char> needle_contents(args[1]);
  int64_t offset_i64 = args[2].As<Integer>()->Value();
  bool is_forward = args[4]->IsTrue();

  const char* haystack = haystack_contents.data();
  const size_t haystack_length = haystack_contents.length();
  const char* needle = needle_contents.data();
  const size_t needle_length = needle_contents.length();

  int64_t opt_offset = IndexOfOffset(haystack_length,
                                     offset_i64,
                                     needle_length,
...",991.0,1062.0,1.0,2.0,72.0,83,16,74,16,0,0,7,8,0,0,,0,0,2,1,1,void
3400,144885,IndexOfNumber,1,node.Buffer.anonymous_namespace_35.IndexOfNumber,void node.Buffer.anonymous_namespace_35.IndexOfNumber (FunctionCallbackInfo<Value>),node_buffer.cc,"void IndexOfNumber(const FunctionCallbackInfo<Value>& args) {
  CHECK(args[1]->IsUint32());
  CHECK(args[2]->IsNumber());
  CHECK(args[3]->IsBoolean());

  THROW_AND_RETURN_UNLESS_BUFFER(Environment::GetCurrent(args), args[0]);
  ArrayBufferViewContents<char> buffer(args[0]);

  uint32_t needle = args[1].As<Uint32>()->Value();
  int64_t offset_i64 = args[2].As<Integer>()->Value();
  bool is_forward = args[3]->IsTrue();

  int64_t opt_offset =
      IndexOfOffset(buffer.length(), offset_i64, 1, is_forward);
  if (opt_offset <= -1 || buffer.length() == 0) {
    return args.GetReturnValue().Set(-1);
  }
  size_t offset = static_cast<size_t>(opt_offset);
  CHECK_LT(offset, buffer.length());

  const void* ptr;
  if (is_forward) {
    ptr = memchr(buffer.data() + offset, needle, buffer.length() - offset);
  } else {
    ptr = node::stringsearch::MemrchrFill(buffer.data(), needle, offset + 1);
  }
  const char* ptr_char = static_cast<const char*>(ptr);
  args.GetReturnValue().Set(ptr ? st...",1064.0,1093.0,1.0,2.0,30.0,49,12,40,10,0,0,3,3,0,0,,0,0,2,1,1,void
3401,145078,Swap16,1,node.Buffer.anonymous_namespace_36.Swap16,void node.Buffer.anonymous_namespace_36.Swap16 (FunctionCallbackInfo<Value>),node_buffer.cc,"void Swap16(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  THROW_AND_RETURN_UNLESS_BUFFER(env, args[0]);
  SPREAD_BUFFER_ARG(args[0], ts_obj);
  SwapBytes16(ts_obj_data, ts_obj_length);
  args.GetReturnValue().Set(args[0]);
}",1096.0,1102.0,1.0,2.0,7.0,8,3,13,6,0,0,1,1,0,0,,0,0,2,1,1,void
3402,145121,Swap32,1,node.Buffer.anonymous_namespace_37.Swap32,void node.Buffer.anonymous_namespace_37.Swap32 (FunctionCallbackInfo<Value>),node_buffer.cc,"void Swap32(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  THROW_AND_RETURN_UNLESS_BUFFER(env, args[0]);
  SPREAD_BUFFER_ARG(args[0], ts_obj);
  SwapBytes32(ts_obj_data, ts_obj_length);
  args.GetReturnValue().Set(args[0]);
}",1105.0,1111.0,1.0,2.0,7.0,8,3,13,6,0,0,1,1,0,0,,0,0,2,1,1,void
3403,145164,Swap64,1,node.Buffer.anonymous_namespace_38.Swap64,void node.Buffer.anonymous_namespace_38.Swap64 (FunctionCallbackInfo<Value>),node_buffer.cc,"void Swap64(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  THROW_AND_RETURN_UNLESS_BUFFER(env, args[0]);
  SPREAD_BUFFER_ARG(args[0], ts_obj);
  SwapBytes64(ts_obj_data, ts_obj_length);
  args.GetReturnValue().Set(args[0]);
}",1114.0,1120.0,1.0,2.0,7.0,8,3,13,6,0,0,1,1,0,0,,0,0,2,1,1,void
3404,145207,IsUtf8,1,node.Buffer.anonymous_namespace_39.IsUtf8,void node.Buffer.anonymous_namespace_39.IsUtf8 (FunctionCallbackInfo<Value>),node_buffer.cc,"static void IsUtf8(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsTypedArray() || args[0]->IsArrayBuffer() ||
        args[0]->IsSharedArrayBuffer());
  ArrayBufferViewContents<char> abv(args[0]);

  if (abv.WasDetached()) {
    return node::THROW_ERR_INVALID_STATE(
        env, ""Cannot validate on a detached buffer"");
  }

  args.GetReturnValue().Set(simdutf::validate_utf8(abv.data(), abv.length()));
}",1122.0,1135.0,1.0,1.0,14.0,19,5,15,6,0,0,2,2,0,0,,0,0,2,1,1,void
3405,145284,IsAscii,1,node.Buffer.anonymous_namespace_40.IsAscii,void node.Buffer.anonymous_namespace_40.IsAscii (FunctionCallbackInfo<Value>),node_buffer.cc,"static void IsAscii(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsTypedArray() || args[0]->IsArrayBuffer() ||
        args[0]->IsSharedArrayBuffer());
  ArrayBufferViewContents<char> abv(args[0]);

  if (abv.WasDetached()) {
    return node::THROW_ERR_INVALID_STATE(
        env, ""Cannot validate on a detached buffer"");
  }

  args.GetReturnValue().Set(simdutf::validate_ascii(abv.data(), abv.length()));
}",1137.0,1150.0,1.0,1.0,14.0,19,5,15,6,0,0,2,2,0,0,,0,0,2,1,1,void
3406,145361,SetBufferPrototype,1,node.Buffer.anonymous_namespace_41.SetBufferPrototype,void node.Buffer.anonymous_namespace_41.SetBufferPrototype (FunctionCallbackInfo<Value>),node_buffer.cc,"void SetBufferPrototype(const FunctionCallbackInfo<Value>& args) {
  Realm* realm = Realm::GetCurrent(args);

  // TODO(legendecas): Remove this check once the binding supports sub-realms.
  CHECK_EQ(realm->kind(), Realm::Kind::kPrincipal);

  CHECK(args[0]->IsObject());
  Local<Object> proto = args[0].As<Object>();
  realm->set_buffer_prototype_object(proto);
}",1152.0,1161.0,1.0,1.0,10.0,13,6,13,7,0,0,1,1,0,0,,0,0,2,1,1,void
3407,145408,GetZeroFillToggle,1,node.Buffer.anonymous_namespace_42.GetZeroFillToggle,void node.Buffer.anonymous_namespace_42.GetZeroFillToggle (FunctionCallbackInfo<Value>),node_buffer.cc,"void GetZeroFillToggle(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  NodeArrayBufferAllocator* allocator = env->isolate_data()->node_allocator();
  Local<ArrayBuffer> ab;
  // It can be a nullptr when running inside an isolate where we
  // do not own the ArrayBuffer allocator.
  if (allocator == nullptr) {
    // Create a dummy Uint32Array - the JS land can only toggle the C++ land
    // setting when the allocator uses our toggle. With this the toggle in JS
    // land results in no-ops.
    ab = ArrayBuffer::New(env->isolate(), sizeof(uint32_t));
  } else {
    uint32_t* zero_fill_field = allocator->zero_fill_field();
    std::unique_ptr<BackingStore> backing =
        ArrayBuffer::NewBackingStore(zero_fill_field,
                                     sizeof(*zero_fill_field),
                                     [](void*, size_t, void*) {},
                                     nullptr);
    ab = ArrayBuffer::New(env->isolate(), s...",1163.0,1190.0,1.0,1.0,28.0,20,7,20,9,0,0,2,2,0,0,,0,0,2,1,1,void
3408,145529,DetachArrayBuffer,1,node.Buffer.anonymous_namespace_44.DetachArrayBuffer,void node.Buffer.anonymous_namespace_44.DetachArrayBuffer (FunctionCallbackInfo<Value>),node_buffer.cc,"void DetachArrayBuffer(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  if (args[0]->IsArrayBuffer()) {
    Local<ArrayBuffer> buf = args[0].As<ArrayBuffer>();
    if (buf->IsDetachable()) {
      std::shared_ptr<BackingStore> store = buf->GetBackingStore();
      buf->Detach(Local<Value>()).Check();
      args.GetReturnValue().Set(ArrayBuffer::New(env->isolate(), store));
    }
  }
}",1192.0,1202.0,1.0,1.0,11.0,21,6,18,9,0,0,3,4,0,0,,0,0,2,1,1,void
3409,145605,DecomposeBufferToParts,1,node.Buffer.anonymous_namespace_47.anonymous_namespace_48.DecomposeBufferToParts,"pair<void *,size_t> node.Buffer.anonymous_namespace_47.anonymous_namespace_48.DecomposeBufferToParts (Local<Value>)",node_buffer.cc,"std::pair<void*, size_t> DecomposeBufferToParts(Local<Value> buffer) {
  void* pointer;
  size_t byte_length;
  if (buffer->IsArrayBuffer()) {
    Local<ArrayBuffer> ab = buffer.As<ArrayBuffer>();
    pointer = ab->Data();
    byte_length = ab->ByteLength();
  } else if (buffer->IsSharedArrayBuffer()) {
    Local<SharedArrayBuffer> ab = buffer.As<SharedArrayBuffer>();
    pointer = ab->Data();
    byte_length = ab->ByteLength();
  } else {
    UNREACHABLE();  // Caller must validate.
  }
  return {pointer, byte_length};
}",1206.0,1221.0,1.0,1.0,16.0,9,5,9,6,0,0,2,2,0,0,,0,0,2,1,1,"pair<void *,size_t>"
3410,145674,CopyArrayBuffer,1,node.Buffer.anonymous_namespace_49.CopyArrayBuffer,void node.Buffer.anonymous_namespace_49.CopyArrayBuffer (FunctionCallbackInfo<Value>),node_buffer.cc,"void CopyArrayBuffer(const FunctionCallbackInfo<Value>& args) {
  // args[0] == Destination ArrayBuffer
  // args[1] == Destination ArrayBuffer Offset
  // args[2] == Source ArrayBuffer
  // args[3] == Source ArrayBuffer Offset
  // args[4] == bytesToCopy

  CHECK(args[0]->IsArrayBuffer() || args[0]->IsSharedArrayBuffer());
  CHECK(args[1]->IsUint32());
  CHECK(args[2]->IsArrayBuffer() || args[2]->IsSharedArrayBuffer());
  CHECK(args[3]->IsUint32());
  CHECK(args[4]->IsUint32());

  void* destination;
  size_t destination_byte_length;
  std::tie(destination, destination_byte_length) =
      DecomposeBufferToParts(args[0]);

  void* source;
  size_t source_byte_length;
  std::tie(source, source_byte_length) = DecomposeBufferToParts(args[2]);

  uint32_t destination_offset = args[1].As<Uint32>()->Value();
  uint32_t source_offset = args[3].As<Uint32>()->Value();
  size_t bytes_to_copy = args[4].As<Uint32>()->Value();

  CHECK_GE(destination_byte_length - destination_offset, bytes_to_c...",1225.0,1257.0,1.0,1.0,33.0,42,8,36,11,0,0,1,1,0,0,,0,0,2,1,1,void
3411,145820,Initialize,1,node.Buffer.anonymous_namespace_54.Initialize,"void node.Buffer.anonymous_namespace_54.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)",node_buffer.cc,"void Initialize(Local<Object> target,
                Local<Value> unused,
                Local<Context> context,
                void* priv) {
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  SetMethod(context, target, ""setBufferPrototype"", SetBufferPrototype);
  SetMethodNoSideEffect(context, target, ""createFromString"", CreateFromString);

  SetFastMethodNoSideEffect(context,
                            target,
                            ""byteLengthUtf8"",
                            SlowByteLengthUtf8,
                            &fast_byte_length_utf8);
  SetMethod(context, target, ""copy"", Copy);
  SetMethodNoSideEffect(context, target, ""compare"", Compare);
  SetMethodNoSideEffect(context, target, ""compareOffset"", CompareOffset);
  SetMethod(context, target, ""fill"", Fill);
  SetMethodNoSideEffect(context, target, ""indexOfBuffer"", IndexOfBuffer);
  SetMethodNoSideEffect(context, target, ""indexOfNumber"", IndexOfNumber);
  SetMethodNoS...",1259.0,1322.0,1.0,1.0,64.0,12,4,96,24,0,0,1,1,0,0,,0,0,8,4,4,void
3412,146041,RegisterExternalReferences,1,node.Buffer.RegisterExternalReferences,void node.Buffer.RegisterExternalReferences (ExternalReferenceRegistry*),node_buffer.cc,"void RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  registry->Register(SetBufferPrototype);
  registry->Register(CreateFromString);

  registry->Register(SlowByteLengthUtf8);
  registry->Register(fast_byte_length_utf8.GetTypeInfo());
  registry->Register(FastByteLengthUtf8);
  registry->Register(Copy);
  registry->Register(Compare);
  registry->Register(CompareOffset);
  registry->Register(Fill);
  registry->Register(IndexOfBuffer);
  registry->Register(IndexOfNumber);
  registry->Register(IndexOfString);

  registry->Register(Swap16);
  registry->Register(Swap32);
  registry->Register(Swap64);

  registry->Register(IsUtf8);
  registry->Register(IsAscii);

  registry->Register(StringSlice<ASCII>);
  registry->Register(StringSlice<BASE64>);
  registry->Register(StringSlice<BASE64URL>);
  registry->Register(StringSlice<LATIN1>);
  registry->Register(StringSlice<HEX>);
  registry->Register(StringSlice<UCS2>);
  registry->Register(StringSlice<UTF8>);

  registry->Re...",1326.0,1367.0,1.0,1.0,42.0,35,2,50,17,0,0,1,1,0,0,,0,0,2,1,1,void
3413,146239,FreeCallback,1,node.Buffer.FreeCallback,"void node.Buffer.FreeCallback (char*,void*)",node_buffer.hpp,"typedef void (*FreeCallback)(char* data, void* hint);",34.0,34.0,14.0,52.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
3414,146304,IsWithinBounds,1,node.Buffer.IsWithinBounds,"bool node.Buffer.IsWithinBounds (size_t,size_t,size_t)",node_buffer.hpp,"static inline bool IsWithinBounds(size_t off, size_t len, size_t max) {
  // Asking to seek too far into the buffer
  // check to avoid wrapping in subsequent subtraction
  if (off > max)
    return false;

  // Asking for more than is left over in the buffer
  if (max - off < len)
    return false;

  // Otherwise we're in bounds
  return true;
}",75.0,87.0,1.0,1.0,13.0,3,3,5,3,0,0,3,3,0,0,,0,0,6,3,3,bool
3415,146352,BuiltinLoader,1,node.builtins.BuiltinLoader.BuiltinLoader,ANY node.builtins.BuiltinLoader.BuiltinLoader (),node_builtins.cc,"BuiltinLoader::BuiltinLoader()
    : config_(GetConfig()), code_cache_(std::make_shared<BuiltinCodeCache>()) {
  LoadJavaScriptSource();
#ifdef NODE_SHARED_BUILTIN_CJS_MODULE_LEXER_LEXER_PATH
  AddExternalizedBuiltin(
      ""internal/deps/cjs-module-lexer/lexer"",
      STRINGIFY(NODE_SHARED_BUILTIN_CJS_MODULE_LEXER_LEXER_PATH));
#endif  // NODE_SHARED_BUILTIN_CJS_MODULE_LEXER_LEXER_PATH

#ifdef NODE_SHARED_BUILTIN_CJS_MODULE_LEXER_DIST_LEXER_PATH
  AddExternalizedBuiltin(
      ""internal/deps/cjs-module-lexer/dist/lexer"",
      STRINGIFY(NODE_SHARED_BUILTIN_CJS_MODULE_LEXER_DIST_LEXER_PATH));
#endif  // NODE_SHARED_BUILTIN_CJS_MODULE_LEXER_DIST_LEXER_PATH

#ifdef NODE_SHARED_BUILTIN_UNDICI_UNDICI_PATH
  AddExternalizedBuiltin(""internal/deps/undici/undici"",
                         STRINGIFY(NODE_SHARED_BUILTIN_UNDICI_UNDICI_PATH));
#endif  // NODE_SHARED_BUILTIN_UNDICI_UNDICI_PATH
}",36.0,55.0,1.0,1.0,20.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
3416,146357,Exists,1,node.builtins.BuiltinLoader.Exists,bool node.builtins.BuiltinLoader.Exists (char*),node_builtins.cc,"bool BuiltinLoader::Exists(const char* id) {
  auto source = source_.read();
  return source->find(id) != source->end();
}",57.0,60.0,1.0,1.0,4.0,5,4,5,3,0,0,1,1,0,0,,0,0,2,1,1,bool
3417,146380,Add,1,node.builtins.BuiltinLoader.Add,"bool node.builtins.BuiltinLoader.Add (char*,UnionBytes)",node_builtins.cc,"bool BuiltinLoader::Add(const char* id, const UnionBytes& source) {
  auto result = source_.write()->emplace(id, source);
  return result.second;
}",62.0,65.0,1.0,1.0,4.0,4,3,5,4,0,0,1,1,0,0,,0,0,4,2,2,bool
3418,146402,GetSourceObject,1,node.builtins.BuiltinLoader.GetSourceObject,Local<Object> node.builtins.BuiltinLoader.GetSourceObject (Local<Context>),node_builtins.cc,"Local<Object> BuiltinLoader::GetSourceObject(Local<Context> context) {
  Isolate* isolate = context->GetIsolate();
  Local<Object> out = Object::New(isolate);
  auto source = source_.read();
  for (auto const& x : *source) {
    Local<String> key = OneByteString(isolate, x.first.c_str(), x.first.size());
    out->Set(context, key, x.second.ToStringChecked(isolate)).FromJust();
  }
  return out;
}",67.0,76.0,1.0,1.0,10.0,20,6,22,10,0,0,2,2,0,0,,0,0,2,1,1,Local<Object>
3419,146475,GetConfigString,1,node.builtins.BuiltinLoader.GetConfigString,Local<String> node.builtins.BuiltinLoader.GetConfigString (Isolate*),node_builtins.cc,"Local<String> BuiltinLoader::GetConfigString(Isolate* isolate) {
  return config_.ToStringChecked(isolate);
}",78.0,80.0,1.0,1.0,3.0,1,1,2,2,0,0,1,1,0,0,,0,0,2,1,1,Local<String>
3420,146486,GetBuiltinIds,1,node.builtins.BuiltinLoader.GetBuiltinIds,vector<std::string> node.builtins.BuiltinLoader.GetBuiltinIds (),node_builtins.cc,"std::vector<std::string> BuiltinLoader::GetBuiltinIds() const {
  std::vector<std::string> ids;
  auto source = source_.read();
  ids.reserve(source->size());
  for (auto const& x : *source) {
    ids.emplace_back(x.first);
  }
  return ids;
}",82.0,90.0,1.0,1.0,9.0,11,6,11,5,0,0,2,2,0,0,,0,0,0,0,0,vector<std.string>
3421,146528,GetBuiltinCategories,1,node.builtins.BuiltinLoader.GetBuiltinCategories,BuiltinCategories node.builtins.BuiltinLoader.GetBuiltinCategories (),node_builtins.cc,"void BuiltinLoader::GetBuiltinCategories(
    Local<Name> property, const PropertyCallbackInfo<Value>& info) {
  Environment* env = Environment::GetCurrent(info);
  Isolate* isolate = env->isolate();
  Local<Context> context = env->context();
  Local<Object> result = Object::New(isolate);

  BuiltinCategories builtin_categories =
      env->builtin_loader()->GetBuiltinCategories();

  if (!env->owns_process_state()) {
    builtin_categories.can_be_required.erase(""trace_events"");
    builtin_categories.cannot_be_required.insert(""trace_events"");
  }

  Local<Value> cannot_be_required_js;
  Local<Value> can_be_required_js;

  if (!ToV8Value(context, builtin_categories.cannot_be_required)
           .ToLocal(&cannot_be_required_js))
    return;
  if (result
          ->Set(context,
                OneByteString(isolate, ""cannotBeRequired""),
                cannot_be_required_js)
          .IsNothing())
    return;
  if (!ToV8Value(context, builtin_categories.can_be_required)
           ...",514.0,552.0,1.0,1.0,39.0,34,8,27,8,0,0,8,13,0,0,,0,0,4,2,2,void
3422,146671,LoadBuiltinSource,1,node.builtins.BuiltinLoader.LoadBuiltinSource,"MaybeLocal<String> node.builtins.BuiltinLoader.LoadBuiltinSource (Isolate*,char*)",node_builtins.cc,"MaybeLocal<String> BuiltinLoader::LoadBuiltinSource(Isolate* isolate,
                                                    const char* id) const {
  auto source = source_.read();
#ifndef NODE_BUILTIN_MODULES_PATH
  const auto source_it = source->find(id);
  if (UNLIKELY(source_it == source->end())) {
    fprintf(stderr, ""Cannot find native builtin: \""%s\"".\n"", id);
    ABORT();
  }
  return source_it->second.ToStringChecked(isolate);
#else   // !NODE_BUILTIN_MODULES_PATH
  std::string filename = OnDiskFileName(id);

  std::string contents;
  int r = ReadFileSync(&contents, filename.c_str());
  if (r != 0) {
    const std::string buf = SPrintF(""Cannot read local builtin. %s: %s \""%s\"""",
                                    uv_err_name(r),
                                    uv_strerror(r),
                                    filename);
    Local<String> message = OneByteString(isolate, buf.c_str());
    isolate->ThrowException(v8::Exception::Error(message));
    return MaybeLocal<Strin...",174.0,201.0,1.0,1.0,28.0,8,4,11,6,0,0,2,2,0,0,,0,0,4,2,2,MaybeLocal<String>
3423,146717,AddExternalizedBuiltin,1,node.builtins.BuiltinLoader.AddExternalizedBuiltin,"void node.builtins.BuiltinLoader.AddExternalizedBuiltin (char*,char*)",node_builtins.cc,"void BuiltinLoader::AddExternalizedBuiltin(const char* id,
                                           const char* filename) {
  StaticExternalTwoByteResource* resource;
  {
    Mutex::ScopedLock lock(externalized_builtins_mutex);
    auto it = externalized_builtin_sources.find(id);
    if (it == externalized_builtin_sources.end()) {
      std::string source;
      int r = ReadFileSync(&source, filename);
      if (r != 0) {
        fprintf(stderr,
                ""Cannot load externalized builtin: \""%s:%s\"".\n"",
                id,
                filename);
        ABORT();
      }
      size_t expected_u16_length =
          simdutf::utf16_length_from_utf8(source.data(), source.length());
      auto out = std::make_shared<std::vector<uint16_t>>(expected_u16_length);
      size_t u16_length = simdutf::convert_utf8_to_utf16(
          source.data(),
          source.length(),
          reinterpret_cast<char16_t*>(out->data()));
      out->resize(u16_length);

      auto result = ext...",209.0,248.0,1.0,1.0,40.0,39,12,44,17,0,0,3,4,0,0,,0,0,4,2,2,void
3424,146864,LookupAndCompileInternal,1,node.builtins.BuiltinLoader.LookupAndCompileInternal,"MaybeLocal<Function> node.builtins.BuiltinLoader.LookupAndCompileInternal (Local<Context>,char*,ANY*,ANY*)",node_builtins.cc,"MaybeLocal<Function> BuiltinLoader::LookupAndCompileInternal(
    Local<Context> context,
    const char* id,
    std::vector<Local<String>>* parameters,
    BuiltinLoader::Result* result) {
  Isolate* isolate = context->GetIsolate();
  EscapableHandleScope scope(isolate);

  Local<String> source;
  if (!LoadBuiltinSource(isolate, id).ToLocal(&source)) {
    return {};
  }

  std::string filename_s = std::string(""node:"") + id;
  Local<String> filename =
      OneByteString(isolate, filename_s.c_str(), filename_s.size());
  ScriptOrigin origin(isolate, filename, 0, 0, true);

  BuiltinCodeCacheData cached_data{};
  {
    // Note: The lock here should not extend into the
    // `CompileFunction()` call below, because this function may recurse if
    // there is a syntax error during bootstrap (because the fatal exception
    // handler is invoked, which may load built-in modules).
    RwLock::ScopedLock lock(code_cache_->mutex);
    auto cache_it = code_cache_->map.find(id);
    if (c...",250.0,352.0,1.0,1.0,103.0,79,14,80,29,0,0,6,6,0,0,,0,0,8,4,4,MaybeLocal<Function>
3425,147114,new_cached_data,1,node.builtins.BuiltinLoader.LookupAndCompileInternal.new_cached_data,ANY node.builtins.BuiltinLoader.LookupAndCompileInternal.new_cached_data (ANY),node_builtins.cc,"std::shared_ptr<ScriptCompiler::CachedData> new_cached_data(
        ScriptCompiler::CreateCodeCacheForFunction(fun));",340.0,341.0,49.0,56.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
3426,147148,LookupAndCompile,1,node.builtins.BuiltinLoader.LookupAndCompile,"MaybeLocal<Function> node.builtins.BuiltinLoader.LookupAndCompile (Local<Context>,char*,Realm*)",node_builtins.cc,"MaybeLocal<Function> BuiltinLoader::LookupAndCompile(Local<Context> context,
                                                     const char* id,
                                                     Realm* optional_realm) {
  Result result;
  std::vector<Local<String>> parameters;
  Isolate* isolate = context->GetIsolate();
  // Detects parameters of the scripts based on module ids.
  // internal/bootstrap/realm: process, getLinkedBinding,
  //                           getInternalBinding, primordials
  if (strcmp(id, ""internal/bootstrap/realm"") == 0) {
    parameters = {
        FIXED_ONE_BYTE_STRING(isolate, ""process""),
        FIXED_ONE_BYTE_STRING(isolate, ""getLinkedBinding""),
        FIXED_ONE_BYTE_STRING(isolate, ""getInternalBinding""),
        FIXED_ONE_BYTE_STRING(isolate, ""primordials""),
    };
  } else if (strncmp(id,
                     ""internal/per_context/"",
                     strlen(""internal/per_context/"")) == 0) {
    // internal/per_context/*: global, exports, pr...",354.0,409.0,1.0,1.0,56.0,16,9,21,12,0,0,3,3,0,0,,0,0,6,3,3,MaybeLocal<Function>
3427,147252,CompileAndCall,1,node.builtins.BuiltinLoader.CompileAndCall,"MaybeLocal<Value> node.builtins.BuiltinLoader.CompileAndCall (Local<Context>,char*,Realm*)",node_builtins.cc,"MaybeLocal<Value> BuiltinLoader::CompileAndCall(Local<Context> context,
                                                const char* id,
                                                int argc,
                                                Local<Value> argv[],
                                                Realm* optional_realm) {
  // Arguments must match the parameters specified in
  // BuiltinLoader::LookupAndCompile().
  MaybeLocal<Function> maybe_fn = LookupAndCompile(context, id, optional_realm);
  Local<Function> fn;
  if (!maybe_fn.ToLocal(&fn)) {
    return MaybeLocal<Value>();
  }
  Local<Value> undefined = Undefined(context->GetIsolate());
  return fn->Call(context, undefined, argc, argv);
}",458.0,472.0,1.0,1.0,15.0,25,10,27,11,0,0,3,4,0,0,,0,0,10,5,5,MaybeLocal<Value>
3428,147421,CompileAllBuiltins,1,node.builtins.BuiltinLoader.CompileAllBuiltins,bool node.builtins.BuiltinLoader.CompileAllBuiltins (Local<Context>),node_builtins.cc,"bool BuiltinLoader::CompileAllBuiltins(Local<Context> context) {
  std::vector<std::string> ids = GetBuiltinIds();
  bool all_succeeded = true;
  std::string v8_tools_prefix = ""internal/deps/v8/tools/"";
  for (const auto& id : ids) {
    if (id.compare(0, v8_tools_prefix.size(), v8_tools_prefix) == 0) {
      continue;
    }
    v8::TryCatch bootstrapCatch(context->GetIsolate());
    USE(LookupAndCompile(context, id.c_str(), nullptr));
    if (bootstrapCatch.HasCaught()) {
      per_process::Debug(DebugCategory::CODE_CACHE,
                         ""Failed to compile code cache for %s\n"",
                         id.c_str());
      all_succeeded = false;
      PrintCaughtException(context->GetIsolate(), context, bootstrapCatch);
    }
  }
  return all_succeeded;
}",474.0,493.0,1.0,1.0,20.0,18,6,21,9,0,0,5,6,0,0,,0,0,2,1,1,bool
3429,147508,CopyCodeCache,1,node.builtins.BuiltinLoader.CopyCodeCache,void node.builtins.BuiltinLoader.CopyCodeCache (ANY*),node_builtins.cc,"void BuiltinLoader::CopyCodeCache(std::vector<CodeCacheInfo>* out) const {
  RwLock::ScopedReadLock lock(code_cache_->mutex);
  for (auto const& item : code_cache_->map) {
    out->push_back({item.first, item.second});
  }
}",495.0,500.0,1.0,1.0,6.0,6,3,5,3,0,0,2,2,0,0,,0,0,2,1,1,void
3430,147535,RefreshCodeCache,1,node.builtins.BuiltinLoader.RefreshCodeCache,void node.builtins.BuiltinLoader.RefreshCodeCache (ANY),node_builtins.cc,"void BuiltinLoader::RefreshCodeCache(const std::vector<CodeCacheInfo>& in) {
  RwLock::ScopedLock lock(code_cache_->mutex);
  code_cache_->map.reserve(in.size());
  DCHECK(code_cache_->map.empty());
  for (auto const& item : in) {
    auto result = code_cache_->map.emplace(item.id, item.data);
    USE(result.second);
    DCHECK(result.second);
  }
  code_cache_->has_code_cache = true;
}",502.0,512.0,1.0,1.0,11.0,15,3,12,4,0,0,2,2,0,0,,0,0,2,1,1,void
3431,147743,GetCacheUsage,1,node.builtins.BuiltinLoader.GetCacheUsage,void node.builtins.BuiltinLoader.GetCacheUsage (FunctionCallbackInfo<Value>),node_builtins.cc,"void BuiltinLoader::GetCacheUsage(const FunctionCallbackInfo<Value>& args) {
  Realm* realm = Realm::GetCurrent(args);
  Isolate* isolate = realm->isolate();
  Local<Context> context = realm->context();
  Local<Object> result = Object::New(isolate);

  Local<Value> builtins_with_cache_js;
  Local<Value> builtins_without_cache_js;
  Local<Value> builtins_in_snapshot_js;
  if (!ToV8Value(context, realm->builtins_with_cache)
           .ToLocal(&builtins_with_cache_js)) {
    return;
  }
  if (result
          ->Set(context,
                OneByteString(isolate, ""compiledWithCache""),
                builtins_with_cache_js)
          .IsNothing()) {
    return;
  }

  if (!ToV8Value(context, realm->builtins_without_cache)
           .ToLocal(&builtins_without_cache_js)) {
    return;
  }
  if (result
          ->Set(context,
                OneByteString(isolate, ""compiledWithoutCache""),
                builtins_without_cache_js)
          .IsNothing()) {
    return;
  }

  if (!ToV8Va...",554.0,600.0,1.0,1.0,47.0,38,7,46,13,0,0,7,7,0,0,,0,0,2,1,1,void
3432,147894,BuiltinIdsGetter,1,node.builtins.BuiltinLoader.BuiltinIdsGetter,"void node.builtins.BuiltinLoader.BuiltinIdsGetter (Local<Name>,PropertyCallbackInfo<Value>)",node_builtins.cc,"void BuiltinLoader::BuiltinIdsGetter(Local<Name> property,
                                     const PropertyCallbackInfo<Value>& info) {
  Environment* env = Environment::GetCurrent(info);
  Isolate* isolate = env->isolate();

  std::vector<std::string> ids = env->builtin_loader()->GetBuiltinIds();
  info.GetReturnValue().Set(
      ToV8Value(isolate->GetCurrentContext(), ids).ToLocalChecked());
}",602.0,610.0,1.0,1.0,9.0,15,5,12,6,0,0,1,1,0,0,,0,0,4,2,2,void
3433,147948,ConfigStringGetter,1,node.builtins.BuiltinLoader.ConfigStringGetter,"void node.builtins.BuiltinLoader.ConfigStringGetter (Local<Name>,PropertyCallbackInfo<Value>)",node_builtins.cc,"void BuiltinLoader::ConfigStringGetter(
    Local<Name> property, const PropertyCallbackInfo<Value>& info) {
  Environment* env = Environment::GetCurrent(info);
  info.GetReturnValue().Set(
      env->builtin_loader()->GetConfigString(info.GetIsolate()));
}",612.0,617.0,1.0,1.0,6.0,7,3,6,3,0,0,1,1,0,0,,0,0,4,2,2,void
3434,147980,RecordResult,1,node.builtins.BuiltinLoader.RecordResult,"void node.builtins.BuiltinLoader.RecordResult (char*,ANY,Realm*)",node_builtins.cc,"void BuiltinLoader::RecordResult(const char* id,
                                 BuiltinLoader::Result result,
                                 Realm* realm) {
  if (result == BuiltinLoader::Result::kWithCache) {
    realm->builtins_with_cache.insert(id);
  } else {
    realm->builtins_without_cache.insert(id);
  }
}",619.0,627.0,1.0,1.0,9.0,5,3,5,5,0,0,2,2,0,0,,0,0,6,3,3,void
3435,148012,CompileFunction,1,node.builtins.BuiltinLoader.CompileFunction,void node.builtins.BuiltinLoader.CompileFunction (FunctionCallbackInfo<Value>),node_builtins.cc,"void BuiltinLoader::CompileFunction(const FunctionCallbackInfo<Value>& args) {
  Realm* realm = Realm::GetCurrent(args);
  CHECK(args[0]->IsString());
  node::Utf8Value id_v(realm->isolate(), args[0].As<String>());
  const char* id = *id_v;
  MaybeLocal<Function> maybe = realm->env()->builtin_loader()->LookupAndCompile(
      realm->context(), id, realm);
  Local<Function> fn;
  if (maybe.ToLocal(&fn)) {
    args.GetReturnValue().Set(fn);
  }
}",629.0,640.0,1.0,1.0,12.0,22,8,22,10,0,0,2,2,0,0,,0,0,2,1,1,void
3436,148092,HasCachedBuiltins,1,node.builtins.BuiltinLoader.HasCachedBuiltins,void node.builtins.BuiltinLoader.HasCachedBuiltins (FunctionCallbackInfo<Value>),node_builtins.cc,"void BuiltinLoader::HasCachedBuiltins(const FunctionCallbackInfo<Value>& args) {
  auto instance = Environment::GetCurrent(args)->builtin_loader();
  RwLock::ScopedReadLock lock(instance->code_cache_->mutex);
  args.GetReturnValue().Set(v8::Boolean::New(
      args.GetIsolate(), instance->code_cache_->has_code_cache));
}",642.0,647.0,1.0,1.0,6.0,12,3,9,5,0,0,1,1,0,0,,0,0,2,1,1,void
3437,148137,SetInternalLoaders,1,node.builtins.SetInternalLoaders,void node.builtins.SetInternalLoaders (FunctionCallbackInfo<Value>),node_builtins.cc,"void SetInternalLoaders(const FunctionCallbackInfo<Value>& args) {
  Realm* realm = Realm::GetCurrent(args);
  CHECK(args[0]->IsFunction());
  CHECK(args[1]->IsFunction());
  DCHECK(realm->internal_binding_loader().IsEmpty());
  DCHECK(realm->builtin_module_require().IsEmpty());
  realm->set_internal_binding_loader(args[0].As<Function>());
  realm->set_builtin_module_require(args[1].As<Function>());
}",649.0,657.0,1.0,1.0,9.0,16,4,11,3,0,0,1,1,0,0,,0,0,2,1,1,void
3438,148200,CopySourceAndCodeCacheReferenceFrom,1,node.builtins.BuiltinLoader.CopySourceAndCodeCacheReferenceFrom,void node.builtins.BuiltinLoader.CopySourceAndCodeCacheReferenceFrom (BuiltinLoader*),node_builtins.cc,"void BuiltinLoader::CopySourceAndCodeCacheReferenceFrom(
    const BuiltinLoader* other) {
  code_cache_ = other->code_cache_;
  source_ = other->source_;
}",659.0,663.0,1.0,1.0,5.0,4,2,4,3,0,0,1,1,0,0,,0,0,2,1,1,void
3439,148215,CreatePerIsolateProperties,1,node.builtins.BuiltinLoader.CreatePerIsolateProperties,"void node.builtins.BuiltinLoader.CreatePerIsolateProperties (IsolateData*,Local<FunctionTemplate>)",node_builtins.cc,"void BuiltinLoader::CreatePerIsolateProperties(IsolateData* isolate_data,
                                               Local<FunctionTemplate> target) {
  Isolate* isolate = isolate_data->isolate();
  Local<ObjectTemplate> proto = target->PrototypeTemplate();

  proto->SetAccessor(isolate_data->config_string(),
                     ConfigStringGetter,
                     nullptr,
                     Local<Value>(),
                     DEFAULT,
                     None,
                     SideEffectType::kHasNoSideEffect);

  proto->SetAccessor(FIXED_ONE_BYTE_STRING(isolate, ""builtinIds""),
                     BuiltinIdsGetter,
                     nullptr,
                     Local<Value>(),
                     DEFAULT,
                     None,
                     SideEffectType::kHasNoSideEffect);

  proto->SetAccessor(FIXED_ONE_BYTE_STRING(isolate, ""builtinCategories""),
                     GetBuiltinCategories,
                     nullptr,
                     Local...",665.0,698.0,1.0,1.0,34.0,15,5,36,15,0,0,1,1,0,0,,0,0,4,2,2,void
3440,148308,CreatePerContextProperties,1,node.builtins.BuiltinLoader.CreatePerContextProperties,"void node.builtins.BuiltinLoader.CreatePerContextProperties (Local<Object>,Local<Value>,Local<Context>,void*)",node_builtins.cc,"void BuiltinLoader::CreatePerContextProperties(Local<Object> target,
                                               Local<Value> unused,
                                               Local<Context> context,
                                               void* priv) {
  // internalBinding('builtins') should be frozen
  target->SetIntegrityLevel(context, IntegrityLevel::kFrozen).FromJust();
}",700.0,706.0,1.0,1.0,7.0,3,2,3,3,0,0,1,1,0,0,,0,0,8,4,4,void
3441,148327,RegisterExternalReferences,1,node.builtins.BuiltinLoader.RegisterExternalReferences,void node.builtins.BuiltinLoader.RegisterExternalReferences (ExternalReferenceRegistry*),node_builtins.cc,"void BuiltinLoader::RegisterExternalReferences(
    ExternalReferenceRegistry* registry) {
  registry->Register(ConfigStringGetter);
  registry->Register(BuiltinIdsGetter);
  registry->Register(GetBuiltinCategories);
  registry->Register(GetCacheUsage);
  registry->Register(CompileFunction);
  registry->Register(HasCachedBuiltins);
  registry->Register(SetInternalLoaders);

  RegisterExternalReferencesForInternalizedBuiltinCode(registry);
}",708.0,719.0,1.0,1.0,12.0,7,1,15,8,0,0,1,1,0,0,,0,0,2,1,1,void
3442,148419,Initialize,1,node.Initialize,"void node.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)",node_config.cc,"static void Initialize(Local<Object> target,
                       Local<Value> unused,
                       Local<Context> context,
                       void* priv) {
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

#if defined(DEBUG) && DEBUG
  READONLY_TRUE_PROPERTY(target, ""isDebugBuild"");
#else
  READONLY_FALSE_PROPERTY(target, ""isDebugBuild"");
#endif  // defined(DEBUG) && DEBUG

#if HAVE_OPENSSL
  READONLY_TRUE_PROPERTY(target, ""hasOpenSSL"");
#else
  READONLY_FALSE_PROPERTY(target, ""hasOpenSSL"");
#endif  // HAVE_OPENSSL

  READONLY_TRUE_PROPERTY(target, ""fipsMode"");

#ifdef NODE_HAVE_I18N_SUPPORT

  READONLY_TRUE_PROPERTY(target, ""hasIntl"");

#ifdef NODE_HAVE_SMALL_ICU
  READONLY_TRUE_PROPERTY(target, ""hasSmallICU"");
#endif  // NODE_HAVE_SMALL_ICU

#if NODE_USE_V8_PLATFORM
  READONLY_TRUE_PROPERTY(target, ""hasTracing"");
#endif

#if !defined(NODE_WITHOUT_NODE_OPTIONS)
  READONLY_TRUE_PROPERTY(target, ""hasNodeOptions"");
#endif

#e...",26.0,79.0,1.0,1.0,54.0,7,5,14,7,0,0,1,1,0,0,,0,0,8,4,4,void
3443,148511,DefineErrnoConstants,1,node.anonymous_namespace_1.DefineErrnoConstants,void node.anonymous_namespace_1.DefineErrnoConstants (Local<Object>),node_constants.cc,"void DefineErrnoConstants(Local<Object> target) {
#ifdef E2BIG
  NODE_DEFINE_CONSTANT(target, E2BIG);
#endif

#ifdef EACCES
  NODE_DEFINE_CONSTANT(target, EACCES);
#endif

#ifdef EADDRINUSE
  NODE_DEFINE_CONSTANT(target, EADDRINUSE);
#endif

#ifdef EADDRNOTAVAIL
  NODE_DEFINE_CONSTANT(target, EADDRNOTAVAIL);
#endif

#ifdef EAFNOSUPPORT
  NODE_DEFINE_CONSTANT(target, EAFNOSUPPORT);
#endif

#ifdef EAGAIN
  NODE_DEFINE_CONSTANT(target, EAGAIN);
#endif

#ifdef EALREADY
  NODE_DEFINE_CONSTANT(target, EALREADY);
#endif

#ifdef EBADF
  NODE_DEFINE_CONSTANT(target, EBADF);
#endif

#ifdef EBADMSG
  NODE_DEFINE_CONSTANT(target, EBADMSG);
#endif

#ifdef EBUSY
  NODE_DEFINE_CONSTANT(target, EBUSY);
#endif

#ifdef ECANCELED
  NODE_DEFINE_CONSTANT(target, ECANCELED);
#endif

#ifdef ECHILD
  NODE_DEFINE_CONSTANT(target, ECHILD);
#endif

#ifdef ECONNABORTED
  NODE_DEFINE_CONSTANT(target, ECONNABORTED);
#endif

#ifdef ECONNREFUSED
  NODE_DEFINE_CONSTANT(target, ECONNREFUSED);
#endif

#ifdef ECONNRES...",71.0,387.0,1.0,1.0,317.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
3444,148516,DefineWindowsErrorConstants,1,node.anonymous_namespace_2.DefineWindowsErrorConstants,void node.anonymous_namespace_2.DefineWindowsErrorConstants (Local<Object>),node_constants.cc,"void DefineWindowsErrorConstants(Local<Object> target) {
#ifdef WSAEINTR
  NODE_DEFINE_CONSTANT(target, WSAEINTR);
#endif

#ifdef WSAEBADF
  NODE_DEFINE_CONSTANT(target, WSAEBADF);
#endif

#ifdef WSAEACCES
  NODE_DEFINE_CONSTANT(target, WSAEACCES);
#endif

#ifdef WSAEFAULT
  NODE_DEFINE_CONSTANT(target, WSAEFAULT);
#endif

#ifdef WSAEINVAL
  NODE_DEFINE_CONSTANT(target, WSAEINVAL);
#endif

#ifdef WSAEMFILE
  NODE_DEFINE_CONSTANT(target, WSAEMFILE);
#endif

#ifdef WSAEWOULDBLOCK
  NODE_DEFINE_CONSTANT(target, WSAEWOULDBLOCK);
#endif

#ifdef WSAEINPROGRESS
  NODE_DEFINE_CONSTANT(target, WSAEINPROGRESS);
#endif

#ifdef WSAEALREADY
  NODE_DEFINE_CONSTANT(target, WSAEALREADY);
#endif

#ifdef WSAENOTSOCK
  NODE_DEFINE_CONSTANT(target, WSAENOTSOCK);
#endif

#ifdef WSAEDESTADDRREQ
  NODE_DEFINE_CONSTANT(target, WSAEDESTADDRREQ);
#endif

#ifdef WSAEMSGSIZE
  NODE_DEFINE_CONSTANT(target, WSAEMSGSIZE);
#endif

#ifdef WSAEPROTOTYPE
  NODE_DEFINE_CONSTANT(target, WSAEPROTOTYPE);
#endif

#ifdef W...",389.0,621.0,1.0,1.0,233.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
3445,148521,DefineSignalConstants,1,node.anonymous_namespace_3.DefineSignalConstants,void node.anonymous_namespace_3.DefineSignalConstants (Local<Object>),node_constants.cc,"void DefineSignalConstants(Local<Object> target) {
#ifdef SIGHUP
  NODE_DEFINE_CONSTANT(target, SIGHUP);
#endif

#ifdef SIGINT
  NODE_DEFINE_CONSTANT(target, SIGINT);
#endif

#ifdef SIGQUIT
  NODE_DEFINE_CONSTANT(target, SIGQUIT);
#endif

#ifdef SIGILL
  NODE_DEFINE_CONSTANT(target, SIGILL);
#endif

#ifdef SIGTRAP
  NODE_DEFINE_CONSTANT(target, SIGTRAP);
#endif

#ifdef SIGABRT
  NODE_DEFINE_CONSTANT(target, SIGABRT);
#endif

#ifdef SIGIOT
  NODE_DEFINE_CONSTANT(target, SIGIOT);
#endif

#ifdef SIGBUS
  NODE_DEFINE_CONSTANT(target, SIGBUS);
#endif

#ifdef SIGFPE
  NODE_DEFINE_CONSTANT(target, SIGFPE);
#endif

#ifdef SIGKILL
  NODE_DEFINE_CONSTANT(target, SIGKILL);
#endif

#ifdef SIGUSR1
  NODE_DEFINE_CONSTANT(target, SIGUSR1);
#endif

#ifdef SIGSEGV
  NODE_DEFINE_CONSTANT(target, SIGSEGV);
#endif

#ifdef SIGUSR2
  NODE_DEFINE_CONSTANT(target, SIGUSR2);
#endif

#ifdef SIGPIPE
  NODE_DEFINE_CONSTANT(target, SIGPIPE);
#endif

#ifdef SIGALRM
  NODE_DEFINE_CONSTANT(target, SIGALRM);
#endif...",623.0,770.0,1.0,1.0,148.0,0,0,2,2,0,0,1,1,0,0,,0,0,2,1,1,void
3446,148529,DefinePriorityConstants,1,node.anonymous_namespace_4.DefinePriorityConstants,void node.anonymous_namespace_4.DefinePriorityConstants (Local<Object>),node_constants.cc,"void DefinePriorityConstants(Local<Object> target) {
#ifdef UV_PRIORITY_LOW
# define PRIORITY_LOW UV_PRIORITY_LOW
  NODE_DEFINE_CONSTANT(target, PRIORITY_LOW);
# undef PRIORITY_LOW
#endif

#ifdef UV_PRIORITY_BELOW_NORMAL
# define PRIORITY_BELOW_NORMAL UV_PRIORITY_BELOW_NORMAL
  NODE_DEFINE_CONSTANT(target, PRIORITY_BELOW_NORMAL);
# undef PRIORITY_BELOW_NORMAL
#endif

#ifdef UV_PRIORITY_NORMAL
# define PRIORITY_NORMAL UV_PRIORITY_NORMAL
  NODE_DEFINE_CONSTANT(target, PRIORITY_NORMAL);
# undef PRIORITY_NORMAL
#endif

#ifdef UV_PRIORITY_ABOVE_NORMAL
# define PRIORITY_ABOVE_NORMAL UV_PRIORITY_ABOVE_NORMAL
  NODE_DEFINE_CONSTANT(target, PRIORITY_ABOVE_NORMAL);
# undef PRIORITY_ABOVE_NORMAL
#endif

#ifdef UV_PRIORITY_HIGH
# define PRIORITY_HIGH UV_PRIORITY_HIGH
  NODE_DEFINE_CONSTANT(target, PRIORITY_HIGH);
# undef PRIORITY_HIGH
#endif

#ifdef UV_PRIORITY_HIGHEST
# define PRIORITY_HIGHEST UV_PRIORITY_HIGHEST
  NODE_DEFINE_CONSTANT(target, PRIORITY_HIGHEST);
# undef PRIORITY_HIGHEST
#endif
}",772.0,808.0,1.0,1.0,37.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
3447,148534,DefineCryptoConstants,1,node.anonymous_namespace_5.DefineCryptoConstants,void node.anonymous_namespace_5.DefineCryptoConstants (Local<Object>),node_constants.cc,"void DefineCryptoConstants(Local<Object> target) {
#ifdef OPENSSL_VERSION_NUMBER
    NODE_DEFINE_CONSTANT(target, OPENSSL_VERSION_NUMBER);
#endif

#ifdef SSL_OP_ALL
    NODE_DEFINE_CONSTANT(target, SSL_OP_ALL);
#endif

#ifdef SSL_OP_ALLOW_NO_DHE_KEX
    NODE_DEFINE_CONSTANT(target, SSL_OP_ALLOW_NO_DHE_KEX);
#endif

#ifdef SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION
    NODE_DEFINE_CONSTANT(target, SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION);
#endif

#ifdef SSL_OP_CIPHER_SERVER_PREFERENCE
    NODE_DEFINE_CONSTANT(target, SSL_OP_CIPHER_SERVER_PREFERENCE);
#endif

#ifdef SSL_OP_CISCO_ANYCONNECT
    NODE_DEFINE_CONSTANT(target, SSL_OP_CISCO_ANYCONNECT);
#endif

#ifdef SSL_OP_COOKIE_EXCHANGE
    NODE_DEFINE_CONSTANT(target, SSL_OP_COOKIE_EXCHANGE);
#endif

#ifdef SSL_OP_CRYPTOPRO_TLSEXT_BUG
    NODE_DEFINE_CONSTANT(target, SSL_OP_CRYPTOPRO_TLSEXT_BUG);
#endif

#ifdef SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS
    NODE_DEFINE_CONSTANT(target, SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS);
#endif

#ifdef SSL_OP_...",810.0,1037.0,1.0,1.0,228.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
3448,148539,DefineSystemConstants,1,node.anonymous_namespace_6.DefineSystemConstants,void node.anonymous_namespace_6.DefineSystemConstants (Local<Object>),node_constants.cc,"void DefineSystemConstants(Local<Object> target) {
  NODE_DEFINE_CONSTANT(target, UV_FS_SYMLINK_DIR);
  NODE_DEFINE_CONSTANT(target, UV_FS_SYMLINK_JUNCTION);
  // file access modes
  NODE_DEFINE_CONSTANT(target, O_RDONLY);
  NODE_DEFINE_CONSTANT(target, O_WRONLY);
  NODE_DEFINE_CONSTANT(target, O_RDWR);

  // file types from readdir
  NODE_DEFINE_CONSTANT(target, UV_DIRENT_UNKNOWN);
  NODE_DEFINE_CONSTANT(target, UV_DIRENT_FILE);
  NODE_DEFINE_CONSTANT(target, UV_DIRENT_DIR);
  NODE_DEFINE_CONSTANT(target, UV_DIRENT_LINK);
  NODE_DEFINE_CONSTANT(target, UV_DIRENT_FIFO);
  NODE_DEFINE_CONSTANT(target, UV_DIRENT_SOCKET);
  NODE_DEFINE_CONSTANT(target, UV_DIRENT_CHAR);
  NODE_DEFINE_CONSTANT(target, UV_DIRENT_BLOCK);

  NODE_DEFINE_CONSTANT(target, S_IFMT);
  NODE_DEFINE_CONSTANT(target, S_IFREG);
  NODE_DEFINE_CONSTANT(target, S_IFDIR);
  NODE_DEFINE_CONSTANT(target, S_IFCHR);
#ifdef S_IFBLK
  NODE_DEFINE_CONSTANT(target, S_IFBLK);
#endif

#ifdef S_IFIFO
  NODE_DEFINE_CONSTANT(target,...",1039.0,1220.0,1.0,1.0,182.0,0,0,36,19,0,0,1,1,0,0,,0,0,2,1,1,void
3449,148598,DefineDLOpenConstants,1,node.anonymous_namespace_7.DefineDLOpenConstants,void node.anonymous_namespace_7.DefineDLOpenConstants (Local<Object>),node_constants.cc,"void DefineDLOpenConstants(Local<Object> target) {
#ifdef RTLD_LAZY
  NODE_DEFINE_CONSTANT(target, RTLD_LAZY);
#endif

#ifdef RTLD_NOW
  NODE_DEFINE_CONSTANT(target, RTLD_NOW);
#endif

#ifdef RTLD_GLOBAL
  NODE_DEFINE_CONSTANT(target, RTLD_GLOBAL);
#endif

#ifdef RTLD_LOCAL
  NODE_DEFINE_CONSTANT(target, RTLD_LOCAL);
#endif

#ifdef RTLD_DEEPBIND
  NODE_DEFINE_CONSTANT(target, RTLD_DEEPBIND);
#endif
}",1222.0,1242.0,1.0,1.0,21.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
3450,148603,DefineTraceConstants,1,node.anonymous_namespace_8.DefineTraceConstants,void node.anonymous_namespace_8.DefineTraceConstants (Local<Object>),node_constants.cc,"void DefineTraceConstants(Local<Object> target) {
  NODE_DEFINE_CONSTANT(target, TRACE_EVENT_PHASE_BEGIN);
  NODE_DEFINE_CONSTANT(target, TRACE_EVENT_PHASE_END);
  NODE_DEFINE_CONSTANT(target, TRACE_EVENT_PHASE_COMPLETE);
  NODE_DEFINE_CONSTANT(target, TRACE_EVENT_PHASE_INSTANT);
  NODE_DEFINE_CONSTANT(target, TRACE_EVENT_PHASE_ASYNC_BEGIN);
  NODE_DEFINE_CONSTANT(target, TRACE_EVENT_PHASE_ASYNC_STEP_INTO);
  NODE_DEFINE_CONSTANT(target, TRACE_EVENT_PHASE_ASYNC_STEP_PAST);
  NODE_DEFINE_CONSTANT(target, TRACE_EVENT_PHASE_ASYNC_END);
  NODE_DEFINE_CONSTANT(target, TRACE_EVENT_PHASE_NESTABLE_ASYNC_BEGIN);
  NODE_DEFINE_CONSTANT(target, TRACE_EVENT_PHASE_NESTABLE_ASYNC_END);
  NODE_DEFINE_CONSTANT(target, TRACE_EVENT_PHASE_NESTABLE_ASYNC_INSTANT);
  NODE_DEFINE_CONSTANT(target, TRACE_EVENT_PHASE_FLOW_BEGIN);
  NODE_DEFINE_CONSTANT(target, TRACE_EVENT_PHASE_FLOW_STEP);
  NODE_DEFINE_CONSTANT(target, TRACE_EVENT_PHASE_FLOW_END);
  NODE_DEFINE_CONSTANT(target, TRACE_EVENT_PHASE_METADATA);...",1244.0,1271.0,1.0,1.0,28.0,0,0,52,27,0,0,1,1,0,0,,0,0,2,1,1,void
3451,148686,DefineConstants,1,node.DefineConstants,"void node.DefineConstants (ANY*,Local<Object>)",node_constants.cc,"void DefineConstants(v8::Isolate* isolate, Local<Object> target) {
  Environment* env = Environment::GetCurrent(isolate);

  Local<Object> os_constants = Object::New(isolate);
  CHECK(os_constants->SetPrototype(env->context(),
                                   Null(env->isolate())).FromJust());

  Local<Object> err_constants = Object::New(isolate);
  CHECK(err_constants->SetPrototype(env->context(),
                                    Null(env->isolate())).FromJust());

  Local<Object> sig_constants = Object::New(isolate);
  CHECK(sig_constants->SetPrototype(env->context(),
                                    Null(env->isolate())).FromJust());

  Local<Object> priority_constants = Object::New(isolate);
  CHECK(priority_constants->SetPrototype(env->context(),
                                         Null(env->isolate())).FromJust());

  Local<Object> fs_constants = Object::New(isolate);
  CHECK(fs_constants->SetPrototype(env->context(),
                                   Null(env->i...",1275.0,1354.0,1.0,1.0,80.0,101,5,114,16,0,0,1,1,0,0,,0,0,4,2,2,void
3452,149119,<lambda>0,1,node.contextify.ContextifyContext.PropertyDefinerCallback.<lambda>0,ANY node.contextify.ContextifyContext.PropertyDefinerCallback.<lambda>0 (PropertyDescriptor*),node_contextify.cc,"[&] (PropertyDescriptor* desc_for_sandbox) {
        if (desc.has_enumerable()) {
          desc_for_sandbox->set_enumerable(desc.enumerable());
        }
        if (desc.has_configurable()) {
          desc_for_sandbox->set_configurable(desc.configurable());
        }
        // Set the property on the sandbox.
        USE(sandbox->DefineProperty(context, property, *desc_for_sandbox));
      }",597.0,606.0,7.0,7.0,10.0,8,3,10,5,0,0,3,3,0,0,,0,0,2,1,1,ANY
3453,149165,<lambda>1,1,node.contextify.ContextifyScript.EvalMachine.<lambda>1,ANY node.contextify.ContextifyScript.EvalMachine.<lambda>1 (),node_contextify.cc,"[&]() {
    MaybeLocal<Value> result = script->Run(context);
    if (!result.IsEmpty() && mtask_queue)
      mtask_queue->PerformCheckpoint(env->isolate());
    return result;
  }",1052.0,1057.0,14.0,3.0,6.0,9,7,10,7,0,0,2,2,0,0,,0,0,0,0,0,ANY
3454,149231,Uint32ToName,1,node.contextify.anonymous_namespace_1.Uint32ToName,"Local<Name> node.contextify.anonymous_namespace_1.Uint32ToName (Local<Context>,uint32_t)",node_contextify.cc,"Local<Name> Uint32ToName(Local<Context> context, uint32_t index) {
  return Uint32::New(context->GetIsolate(), index)->ToString(context)
      .ToLocalChecked();
}",105.0,108.0,1.0,1.0,4.0,4,2,4,3,0,0,1,1,0,0,,0,0,4,2,2,Local<Name>
3455,149254,New,1,node.contextify.ContextifyContext.New,"BaseObjectPtr<ContextifyContext> node.contextify.ContextifyContext.New (Environment*,Local<Object>,ContextOptions)",node_contextify.cc,"BaseObjectPtr<ContextifyContext> ContextifyContext::New(
    Local<Context> v8_context,
    Environment* env,
    Local<Object> sandbox_obj,
    const ContextOptions& options) {
  HandleScope scope(env->isolate());
  // This only initializes part of the context. The primordials are
  // only initialized when needed because even deserializing them slows
  // things down significantly and they are only needed in rare occasions
  // in the vm contexts.
  if (InitializeContextRuntime(v8_context).IsNothing()) {
    return BaseObjectPtr<ContextifyContext>();
  }

  Local<Context> main_context = env->context();
  Local<Object> new_context_global = v8_context->Global();
  v8_context->SetSecurityToken(main_context->GetSecurityToken());

  // We need to tie the lifetime of the sandbox object with the lifetime of
  // newly created context. We do this by making them hold references to each
  // other. The context can directly hold a reference to the sandbox as an
  // embedder data field. The ...",239.0,319.0,1.0,1.0,81.0,25,8,24,10,0,0,2,2,0,0,,0,0,8,4,4,BaseObjectPtr<ContextifyContext>
3456,149348,MemoryInfo,1,node.contextify.ContextifyContext.MemoryInfo,void node.contextify.ContextifyContext.MemoryInfo (MemoryTracker*),node_contextify.cc,"void ContextifyContext::MemoryInfo(MemoryTracker* tracker) const {
  if (microtask_queue_wrap_) {
    tracker->TrackField(""microtask_queue_wrap"",
                        microtask_queue_wrap_->object());
  }
}",135.0,140.0,1.0,1.0,6.0,2,1,3,2,0,0,2,2,0,0,,0,0,2,1,1,void
3457,149365,ContextifyContext,1,node.contextify.ContextifyContext.ContextifyContext,"ANY node.contextify.ContextifyContext.ContextifyContext (Environment*,Local<Object>,Local<Context>,ContextOptions)",node_contextify.cc,"ContextifyContext::ContextifyContext(Environment* env,
                                     Local<Object> wrapper,
                                     Local<Context> v8_context,
                                     const ContextOptions& options)
    : BaseObject(env, wrapper),
      microtask_queue_wrap_(options.microtask_queue_wrap) {
  context_.Reset(env->isolate(), v8_context);
  // This should only be done after the initial initializations of the context
  // global object is finished.
  DCHECK_NULL(v8_context->GetAlignedPointerFromEmbedderData(
      ContextEmbedderIndex::kContextifyContext));
  v8_context->SetAlignedPointerInEmbedderData(
      ContextEmbedderIndex::kContextifyContext, this);
  // It's okay to make this reference weak - V8 would create an internal
  // reference to this context via the constructor of the wrapper.
  // As long as the wrapper is alive, it's constructor is alive, and so
  // is the context.
  context_.SetWeak();
}",142.0,160.0,1.0,1.0,19.0,7,2,8,4,0,0,1,1,0,0,,0,0,8,4,4,ANY
3458,149402,~ContextifyContext,1,node.contextify.ContextifyContext.~ContextifyContext,ANY node.contextify.ContextifyContext.~ContextifyContext (),node_contextify.cc,"ContextifyContext::~ContextifyContext() {
  Isolate* isolate = env()->isolate();
  HandleScope scope(isolate);

  env()->UntrackContext(PersistentToLocal::Weak(isolate, context_));
  context_.Reset();
}",162.0,168.0,1.0,1.0,7.0,5,3,6,3,0,0,1,1,0,0,,0,0,0,0,0,ANY
3459,149430,InitializeGlobalTemplates,1,node.contextify.ContextifyContext.InitializeGlobalTemplates,void node.contextify.ContextifyContext.InitializeGlobalTemplates (IsolateData*),node_contextify.cc,"void ContextifyContext::InitializeGlobalTemplates(IsolateData* isolate_data) {
  DCHECK(isolate_data->contextify_wrapper_template().IsEmpty());
  Local<FunctionTemplate> global_func_template =
      FunctionTemplate::New(isolate_data->isolate());
  Local<ObjectTemplate> global_object_template =
      global_func_template->InstanceTemplate();

  NamedPropertyHandlerConfiguration config(
      PropertyGetterCallback,
      PropertySetterCallback,
      PropertyDescriptorCallback,
      PropertyDeleterCallback,
      PropertyEnumeratorCallback,
      PropertyDefinerCallback,
      {},
      PropertyHandlerFlags::kHasNoSideEffect);

  IndexedPropertyHandlerConfiguration indexed_config(
      IndexedPropertyGetterCallback,
      IndexedPropertySetterCallback,
      IndexedPropertyDescriptorCallback,
      IndexedPropertyDeleterCallback,
      PropertyEnumeratorCallback,
      IndexedPropertyDefinerCallback,
      {},
      PropertyHandlerFlags::kHasNoSideEffect);

  global_object_templat...",170.0,206.0,1.0,1.0,37.0,27,6,41,23,0,0,1,1,0,0,,0,0,2,1,1,void
3460,149532,CreateV8Context,1,node.contextify.ContextifyContext.CreateV8Context,"MaybeLocal<Context> node.contextify.ContextifyContext.CreateV8Context (Isolate*,Local<ObjectTemplate>,SnapshotData*,MicrotaskQueue*)",node_contextify.cc,"MaybeLocal<Context> ContextifyContext::CreateV8Context(
    Isolate* isolate,
    Local<ObjectTemplate> object_template,
    const SnapshotData* snapshot_data,
    MicrotaskQueue* queue) {
  EscapableHandleScope scope(isolate);

  Local<Context> ctx;
  if (snapshot_data == nullptr) {
    ctx = Context::New(isolate,
                       nullptr,  // extensions
                       object_template,
                       {},  // global object
                       {},  // deserialization callback
                       queue);
    if (ctx.IsEmpty() || InitializeBaseContextForSnapshot(ctx).IsNothing()) {
      return MaybeLocal<Context>();
    }
  } else if (!Context::FromSnapshot(isolate,
                                    SnapshotData::kNodeVMContextIndex,
                                    {},       // deserialization callback
                                    nullptr,  // extensions
                                    {},       // global object
                            ...",208.0,237.0,1.0,1.0,30.0,11,7,14,8,0,0,3,4,0,0,,0,0,8,4,4,MaybeLocal<Context>
3461,149857,CreatePerIsolateProperties,1,node.contextify.ContextifyContext.CreatePerIsolateProperties,"void node.contextify.ContextifyContext.CreatePerIsolateProperties (IsolateData*,Local<ObjectTemplate>)",node_contextify.cc,"void ContextifyContext::CreatePerIsolateProperties(
    IsolateData* isolate_data, Local<ObjectTemplate> target) {
  Isolate* isolate = isolate_data->isolate();
  SetMethod(isolate, target, ""makeContext"", MakeContext);
  SetMethod(isolate, target, ""isContext"", IsContext);
  SetMethod(isolate, target, ""compileFunction"", CompileFunction);
}",321.0,327.0,1.0,1.0,7.0,2,2,11,6,0,0,1,1,0,0,,0,0,4,2,2,void
3462,149885,RegisterExternalReferences,1,node.contextify.ContextifyContext.RegisterExternalReferences,void node.contextify.ContextifyContext.RegisterExternalReferences (ExternalReferenceRegistry*),node_contextify.cc,"void ContextifyContext::RegisterExternalReferences(
    ExternalReferenceRegistry* registry) {
  registry->Register(MakeContext);
  registry->Register(IsContext);
  registry->Register(CompileFunction);
  registry->Register(PropertyGetterCallback);
  registry->Register(PropertySetterCallback);
  registry->Register(PropertyDescriptorCallback);
  registry->Register(PropertyDeleterCallback);
  registry->Register(PropertyEnumeratorCallback);
  registry->Register(PropertyDefinerCallback);
  registry->Register(IndexedPropertyGetterCallback);
  registry->Register(IndexedPropertySetterCallback);
  registry->Register(IndexedPropertyDescriptorCallback);
  registry->Register(IndexedPropertyDeleterCallback);
  registry->Register(IndexedPropertyDefinerCallback);
}",329.0,345.0,1.0,1.0,17.0,14,1,28,15,0,0,1,1,0,0,,0,0,2,1,1,void
3463,149960,MakeContext,1,node.contextify.ContextifyContext.MakeContext,void node.contextify.ContextifyContext.MakeContext (FunctionCallbackInfo<Value>),node_contextify.cc,"void ContextifyContext::MakeContext(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  CHECK_EQ(args.Length(), 6);
  CHECK(args[0]->IsObject());
  Local<Object> sandbox = args[0].As<Object>();

  // Don't allow contextifying a sandbox multiple times.
  CHECK(
      !sandbox->HasPrivate(
          env->context(),
          env->contextify_context_private_symbol()).FromJust());

  ContextOptions options;

  CHECK(args[1]->IsString());
  options.name = args[1].As<String>();

  CHECK(args[2]->IsString() || args[2]->IsUndefined());
  if (args[2]->IsString()) {
    options.origin = args[2].As<String>();
  }

  CHECK(args[3]->IsBoolean());
  options.allow_code_gen_strings = args[3].As<Boolean>();

  CHECK(args[4]->IsBoolean());
  options.allow_code_gen_wasm = args[4].As<Boolean>();

  if (args[5]->IsObject() &&
      !env->microtask_queue_ctor_template().IsEmpty() &&
      env->microtask_queue_ctor_template()->HasInstance(args[5])) {
    optio...",348.0,393.0,1.0,1.0,46.0,68,9,45,13,0,0,5,6,0,0,,0,0,2,1,1,void
3464,150177,IsContext,1,node.contextify.ContextifyContext.IsContext,void node.contextify.ContextifyContext.IsContext (FunctionCallbackInfo<Value>),node_contextify.cc,"void ContextifyContext::IsContext(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  CHECK(args[0]->IsObject());
  Local<Object> sandbox = args[0].As<Object>();

  Maybe<bool> result =
      sandbox->HasPrivate(env->context(),
                          env->contextify_context_private_symbol());
  args.GetReturnValue().Set(result.FromJust());
}",396.0,406.0,1.0,1.0,11.0,16,6,14,7,0,0,1,1,0,0,,0,0,2,1,1,void
3465,150235,WeakCallback,1,node.contextify.ContextifyContext.WeakCallback,void node.contextify.ContextifyContext.WeakCallback (WeakCallbackInfo<ContextifyContext>),node_contextify.cc,"void ContextifyContext::WeakCallback(
    const WeakCallbackInfo<ContextifyContext>& data) {
  ContextifyContext* context = data.GetParameter();
  delete context;
}",409.0,413.0,1.0,1.0,5.0,3,3,3,2,0,0,1,1,0,0,,0,0,2,1,1,void
3466,150249,ContextFromContextifiedSandbox,1,node.contextify.ContextifyContext.ContextFromContextifiedSandbox,"ContextifyContext node.contextify.ContextifyContext.ContextFromContextifiedSandbox (Environment*,Local<Object>)",node_contextify.cc,"ContextifyContext* ContextifyContext::ContextFromContextifiedSandbox(
    Environment* env,
    const Local<Object>& sandbox) {
  Local<Value> context_global;
  if (sandbox
          ->GetPrivate(env->context(), env->contextify_context_private_symbol())
          .ToLocal(&context_global) &&
      context_global->IsObject()) {
    return Unwrap<ContextifyContext>(context_global.As<Object>());
  }
  return nullptr;
}",416.0,427.0,1.0,1.0,12.0,12,6,11,7,0,0,2,2,0,0,,0,0,4,2,2,ContextifyContext
3467,150295,Get,1,node.contextify.ContextifyContext.Get,ContextifyContext node.contextify.ContextifyContext.Get<T> (PropertyCallbackInfo<T>),node_contextify.cc,"ContextifyContext* ContextifyContext::Get(Local<Object> object) {
  Local<Context> context;
  if (!object->GetCreationContext().ToLocal(&context)) {
    return nullptr;
  }
  if (!ContextEmbedderTag::IsNodeContext(context)) {
    return nullptr;
  }
  return static_cast<ContextifyContext*>(
      context->GetAlignedPointerFromEmbedderData(
          ContextEmbedderIndex::kContextifyContext));
}",434.0,445.0,1.0,1.0,12.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,ContextifyContext
3468,150350,IsStillInitializing,1,node.contextify.ContextifyContext.IsStillInitializing,bool node.contextify.ContextifyContext.IsStillInitializing (ContextifyContext*),node_contextify.cc,"bool ContextifyContext::IsStillInitializing(const ContextifyContext* ctx) {
  return ctx == nullptr || ctx->context_.IsEmpty();
}",447.0,449.0,1.0,1.0,3.0,4,4,2,1,0,0,1,1,0,0,,0,0,2,1,1,bool
3469,150366,PropertyGetterCallback,1,node.contextify.ContextifyContext.PropertyGetterCallback,"void node.contextify.ContextifyContext.PropertyGetterCallback (Local<Name>,PropertyCallbackInfo<Value>)",node_contextify.cc,"void ContextifyContext::PropertyGetterCallback(
    Local<Name> property,
    const PropertyCallbackInfo<Value>& args) {
  ContextifyContext* ctx = ContextifyContext::Get(args);

  // Still initializing
  if (IsStillInitializing(ctx)) return;

  Local<Context> context = ctx->context();
  Local<Object> sandbox = ctx->sandbox();
  MaybeLocal<Value> maybe_rv =
      sandbox->GetRealNamedProperty(context, property);
  if (maybe_rv.IsEmpty()) {
    maybe_rv =
        ctx->global_proxy()->GetRealNamedProperty(context, property);
  }

  Local<Value> rv;
  if (maybe_rv.ToLocal(&rv)) {
    if (rv == sandbox)
      rv = ctx->global_proxy();

    args.GetReturnValue().Set(rv);
  }
}",452.0,476.0,1.0,1.0,25.0,27,7,34,13,0,0,5,6,0,0,,0,0,4,2,2,void
3470,150466,PropertySetterCallback,1,node.contextify.ContextifyContext.PropertySetterCallback,"void node.contextify.ContextifyContext.PropertySetterCallback (Local<Name>,Local<Value>,PropertyCallbackInfo<Value>)",node_contextify.cc,"void ContextifyContext::PropertySetterCallback(
    Local<Name> property,
    Local<Value> value,
    const PropertyCallbackInfo<Value>& args) {
  ContextifyContext* ctx = ContextifyContext::Get(args);

  // Still initializing
  if (IsStillInitializing(ctx)) return;

  Local<Context> context = ctx->context();
  PropertyAttribute attributes = PropertyAttribute::None;
  bool is_declared_on_global_proxy = ctx->global_proxy()
      ->GetRealNamedPropertyAttributes(context, property)
      .To(&attributes);
  bool read_only =
      static_cast<int>(attributes) &
      static_cast<int>(PropertyAttribute::ReadOnly);

  bool is_declared_on_sandbox = ctx->sandbox()
      ->GetRealNamedPropertyAttributes(context, property)
      .To(&attributes);
  read_only = read_only ||
      (static_cast<int>(attributes) &
      static_cast<int>(PropertyAttribute::ReadOnly));

  if (read_only)
    return;

  // true for x = 5
  // false for this.x = 5
  // false for Object.defineProperty(this, 'foo', ...)...",479.0,544.0,1.0,1.0,66.0,71,12,68,22,0,0,7,8,0,0,,0,0,6,3,3,void
3471,150705,PropertyDescriptorCallback,1,node.contextify.ContextifyContext.PropertyDescriptorCallback,"void node.contextify.ContextifyContext.PropertyDescriptorCallback (Local<Name>,PropertyCallbackInfo<Value>)",node_contextify.cc,"void ContextifyContext::PropertyDescriptorCallback(
    Local<Name> property,
    const PropertyCallbackInfo<Value>& args) {
  ContextifyContext* ctx = ContextifyContext::Get(args);

  // Still initializing
  if (IsStillInitializing(ctx)) return;

  Local<Context> context = ctx->context();

  Local<Object> sandbox = ctx->sandbox();

  if (sandbox->HasOwnProperty(context, property).FromMaybe(false)) {
    Local<Value> desc;
    if (sandbox->GetOwnPropertyDescriptor(context, property).ToLocal(&desc)) {
      args.GetReturnValue().Set(desc);
    }
  }
}",547.0,565.0,1.0,1.0,19.0,19,6,24,11,0,0,4,5,0,0,,0,0,4,2,2,void
3472,150782,PropertyDefinerCallback,1,node.contextify.ContextifyContext.PropertyDefinerCallback,"void node.contextify.ContextifyContext.PropertyDefinerCallback (Local<Name>,PropertyDescriptor,PropertyCallbackInfo<Value>)",node_contextify.cc,"void ContextifyContext::PropertyDefinerCallback(
    Local<Name> property,
    const PropertyDescriptor& desc,
    const PropertyCallbackInfo<Value>& args) {
  ContextifyContext* ctx = ContextifyContext::Get(args);

  // Still initializing
  if (IsStillInitializing(ctx)) return;

  Local<Context> context = ctx->context();
  Isolate* isolate = context->GetIsolate();

  PropertyAttribute attributes = PropertyAttribute::None;
  bool is_declared =
      ctx->global_proxy()->GetRealNamedPropertyAttributes(context,
                                                          property)
          .To(&attributes);
  bool read_only =
      static_cast<int>(attributes) &
          static_cast<int>(PropertyAttribute::ReadOnly);

  // If the property is set on the global as read_only, don't change it on
  // the global or sandbox.
  if (is_declared && read_only)
    return;

  Local<Object> sandbox = ctx->sandbox();

  auto define_prop_on_sandbox =
      [&] (PropertyDescriptor* desc_for_sandbox) ...",568.0,626.0,1.0,1.0,59.0,38,11,36,17,0,0,4,4,0,0,,0,0,6,3,3,void
3473,150962,PropertyDeleterCallback,1,node.contextify.ContextifyContext.PropertyDeleterCallback,"void node.contextify.ContextifyContext.PropertyDeleterCallback (Local<Name>,PropertyCallbackInfo<Boolean>)",node_contextify.cc,"void ContextifyContext::PropertyDeleterCallback(
    Local<Name> property,
    const PropertyCallbackInfo<Boolean>& args) {
  ContextifyContext* ctx = ContextifyContext::Get(args);

  // Still initializing
  if (IsStillInitializing(ctx)) return;

  Maybe<bool> success = ctx->sandbox()->Delete(ctx->context(), property);

  if (success.FromMaybe(false))
    return;

  // Delete failed on the sandbox, intercept and do not delete on
  // the global object.
  args.GetReturnValue().Set(false);
}",629.0,645.0,1.0,1.0,17.0,9,3,10,5,0,0,3,3,0,0,,0,0,4,2,2,void
3474,151012,PropertyEnumeratorCallback,1,node.contextify.ContextifyContext.PropertyEnumeratorCallback,void node.contextify.ContextifyContext.PropertyEnumeratorCallback (PropertyCallbackInfo<Array>),node_contextify.cc,"void ContextifyContext::PropertyEnumeratorCallback(
    const PropertyCallbackInfo<Array>& args) {
  ContextifyContext* ctx = ContextifyContext::Get(args);

  // Still initializing
  if (IsStillInitializing(ctx)) return;

  Local<Array> properties;

  if (!ctx->sandbox()->GetPropertyNames(ctx->context()).ToLocal(&properties))
    return;

  args.GetReturnValue().Set(properties);
}",648.0,661.0,1.0,1.0,14.0,12,7,12,6,0,0,3,3,0,0,,0,0,2,1,1,void
3475,151063,IndexedPropertyGetterCallback,1,node.contextify.ContextifyContext.IndexedPropertyGetterCallback,"void node.contextify.ContextifyContext.IndexedPropertyGetterCallback (uint32_t,PropertyCallbackInfo<Value>)",node_contextify.cc,"void ContextifyContext::IndexedPropertyGetterCallback(
    uint32_t index,
    const PropertyCallbackInfo<Value>& args) {
  ContextifyContext* ctx = ContextifyContext::Get(args);

  // Still initializing
  if (IsStillInitializing(ctx)) return;

  ContextifyContext::PropertyGetterCallback(
      Uint32ToName(ctx->context(), index), args);
}",664.0,674.0,1.0,1.0,11.0,4,3,8,4,0,0,2,2,0,0,,0,0,4,2,2,void
3476,151093,IndexedPropertySetterCallback,1,node.contextify.ContextifyContext.IndexedPropertySetterCallback,"void node.contextify.ContextifyContext.IndexedPropertySetterCallback (uint32_t,Local<Value>,PropertyCallbackInfo<Value>)",node_contextify.cc,"void ContextifyContext::IndexedPropertySetterCallback(
    uint32_t index,
    Local<Value> value,
    const PropertyCallbackInfo<Value>& args) {
  ContextifyContext* ctx = ContextifyContext::Get(args);

  // Still initializing
  if (IsStillInitializing(ctx)) return;

  ContextifyContext::PropertySetterCallback(
      Uint32ToName(ctx->context(), index), value, args);
}",677.0,688.0,1.0,1.0,12.0,4,3,9,5,0,0,2,2,0,0,,0,0,6,3,3,void
3477,151125,IndexedPropertyDescriptorCallback,1,node.contextify.ContextifyContext.IndexedPropertyDescriptorCallback,"void node.contextify.ContextifyContext.IndexedPropertyDescriptorCallback (uint32_t,PropertyCallbackInfo<Value>)",node_contextify.cc,"void ContextifyContext::IndexedPropertyDescriptorCallback(
    uint32_t index,
    const PropertyCallbackInfo<Value>& args) {
  ContextifyContext* ctx = ContextifyContext::Get(args);

  // Still initializing
  if (IsStillInitializing(ctx)) return;

  ContextifyContext::PropertyDescriptorCallback(
      Uint32ToName(ctx->context(), index), args);
}",691.0,701.0,1.0,1.0,11.0,4,3,8,4,0,0,2,2,0,0,,0,0,4,2,2,void
3478,151155,IndexedPropertyDefinerCallback,1,node.contextify.ContextifyContext.IndexedPropertyDefinerCallback,"void node.contextify.ContextifyContext.IndexedPropertyDefinerCallback (uint32_t,PropertyDescriptor,PropertyCallbackInfo<Value>)",node_contextify.cc,"void ContextifyContext::IndexedPropertyDefinerCallback(
    uint32_t index,
    const PropertyDescriptor& desc,
    const PropertyCallbackInfo<Value>& args) {
  ContextifyContext* ctx = ContextifyContext::Get(args);

  // Still initializing
  if (IsStillInitializing(ctx)) return;

  ContextifyContext::PropertyDefinerCallback(
      Uint32ToName(ctx->context(), index), desc, args);
}",704.0,715.0,1.0,1.0,12.0,4,3,9,5,0,0,2,2,0,0,,0,0,6,3,3,void
3479,151187,IndexedPropertyDeleterCallback,1,node.contextify.ContextifyContext.IndexedPropertyDeleterCallback,"void node.contextify.ContextifyContext.IndexedPropertyDeleterCallback (uint32_t,PropertyCallbackInfo<Boolean>)",node_contextify.cc,"void ContextifyContext::IndexedPropertyDeleterCallback(
    uint32_t index,
    const PropertyCallbackInfo<Boolean>& args) {
  ContextifyContext* ctx = ContextifyContext::Get(args);

  // Still initializing
  if (IsStillInitializing(ctx)) return;

  Maybe<bool> success = ctx->sandbox()->Delete(ctx->context(), index);

  if (success.FromMaybe(false))
    return;

  // Delete failed on the sandbox, intercept and do not delete on
  // the global object.
  args.GetReturnValue().Set(false);
}",718.0,734.0,1.0,1.0,17.0,9,3,10,5,0,0,3,3,0,0,,0,0,4,2,2,void
3480,151237,CreatePerIsolateProperties,1,node.contextify.ContextifyScript.CreatePerIsolateProperties,"void node.contextify.ContextifyScript.CreatePerIsolateProperties (IsolateData*,Local<ObjectTemplate>)",node_contextify.cc,"void ContextifyScript::CreatePerIsolateProperties(
    IsolateData* isolate_data, Local<ObjectTemplate> target) {
  Isolate* isolate = isolate_data->isolate();
  Local<String> class_name = FIXED_ONE_BYTE_STRING(isolate, ""ContextifyScript"");

  Local<FunctionTemplate> script_tmpl = NewFunctionTemplate(isolate, New);
  script_tmpl->InstanceTemplate()->SetInternalFieldCount(
      ContextifyScript::kInternalFieldCount);
  script_tmpl->SetClassName(class_name);
  SetProtoMethod(isolate, script_tmpl, ""createCachedData"", CreateCachedData);
  SetProtoMethod(isolate, script_tmpl, ""runInContext"", RunInContext);

  target->Set(isolate, ""ContextifyScript"", script_tmpl);
  isolate_data->set_script_context_constructor_template(script_tmpl);
}",736.0,750.0,1.0,1.0,15.0,14,5,26,12,0,0,1,1,0,0,,0,0,4,2,2,void
3481,151305,RegisterExternalReferences,1,node.contextify.ContextifyScript.RegisterExternalReferences,void node.contextify.ContextifyScript.RegisterExternalReferences (ExternalReferenceRegistry*),node_contextify.cc,"void ContextifyScript::RegisterExternalReferences(
    ExternalReferenceRegistry* registry) {
  registry->Register(New);
  registry->Register(CreateCachedData);
  registry->Register(RunInContext);
}",752.0,757.0,1.0,1.0,6.0,3,1,6,4,0,0,1,1,0,0,,0,0,2,1,1,void
3482,151325,New,1,node.contextify.ContextifyScript.New,void node.contextify.ContextifyScript.New (FunctionCallbackInfo<Value>),node_contextify.cc,"void ContextifyScript::New(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();
  Local<Context> context = env->context();

  CHECK(args.IsConstructCall());

  const int argc = args.Length();
  CHECK_GE(argc, 2);

  CHECK(args[0]->IsString());
  Local<String> code = args[0].As<String>();

  CHECK(args[1]->IsString());
  Local<String> filename = args[1].As<String>();

  int line_offset = 0;
  int column_offset = 0;
  Local<ArrayBufferView> cached_data_buf;
  bool produce_cached_data = false;
  Local<Context> parsing_context = context;

  if (argc > 2) {
    // new ContextifyScript(code, filename, lineOffset, columnOffset,
    //                      cachedData, produceCachedData, parsingContext)
    CHECK_EQ(argc, 7);
    CHECK(args[2]->IsNumber());
    line_offset = args[2].As<Int32>()->Value();
    CHECK(args[3]->IsNumber());
    column_offset = args[3].As<Int32>()->Value();
    if (!args[4]->IsUndefined...",759.0,891.0,1.0,1.0,133.0,144,14,158,46,0,0,12,15,0,0,,0,0,2,1,1,void
3483,151858,StoreCodeCacheResult,1,node.contextify.StoreCodeCacheResult,"Maybe<bool> node.contextify.StoreCodeCacheResult (Environment*,Local<Object>,ANY,ANY,bool,ANY)",node_contextify.cc,"Maybe<bool> StoreCodeCacheResult(
    Environment* env,
    Local<Object> target,
    ScriptCompiler::CompileOptions compile_options,
    const v8::ScriptCompiler::Source& source,
    bool produce_cached_data,
    std::unique_ptr<ScriptCompiler::CachedData> new_cached_data) {
  Local<Context> context;
  if (!target->GetCreationContext().ToLocal(&context)) {
    return Nothing<bool>();
  }
  if (compile_options == ScriptCompiler::kConsumeCodeCache) {
    if (target
            ->Set(
                context,
                env->cached_data_rejected_string(),
                Boolean::New(env->isolate(), source.GetCachedData()->rejected))
            .IsNothing()) {
      return Nothing<bool>();
    }
  }
  if (produce_cached_data) {
    bool cached_data_produced = new_cached_data != nullptr;
    if (cached_data_produced) {
      MaybeLocal<Object> buf =
          Buffer::Copy(env,
                       reinterpret_cast<const char*>(new_cached_data->data),
                       new_...",893.0,935.0,1.0,1.0,43.0,33,10,34,16,0,0,8,13,0,0,,0,0,12,6,6,Maybe<bool>
3484,152003,InstanceOf,1,node.contextify.ContextifyScript.InstanceOf,"bool node.contextify.ContextifyScript.InstanceOf (Environment*,Local<Value>)",node_contextify.cc,"bool ContextifyScript::InstanceOf(Environment* env,
                                  const Local<Value>& value) {
  return !value.IsEmpty() &&
         env->script_context_constructor_template()->HasInstance(value);
}",937.0,941.0,1.0,1.0,5.0,5,4,3,2,0,0,1,1,0,0,,0,0,4,2,2,bool
3485,152024,CreateCachedData,1,node.contextify.ContextifyScript.CreateCachedData,void node.contextify.ContextifyScript.CreateCachedData (FunctionCallbackInfo<Value>),node_contextify.cc,"void ContextifyScript::CreateCachedData(
    const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  ContextifyScript* wrapped_script;
  ASSIGN_OR_RETURN_UNWRAP(&wrapped_script, args.Holder());
  Local<UnboundScript> unbound_script =
      PersistentToLocal::Default(env->isolate(), wrapped_script->script_);
  std::unique_ptr<ScriptCompiler::CachedData> cached_data(
      ScriptCompiler::CreateCodeCache(unbound_script));
  if (!cached_data) {
    args.GetReturnValue().Set(Buffer::New(env, 0).ToLocalChecked());
  } else {
    MaybeLocal<Object> buf = Buffer::Copy(
        env,
        reinterpret_cast<const char*>(cached_data->data),
        cached_data->length);
    args.GetReturnValue().Set(buf.ToLocalChecked());
  }
}",943.0,961.0,1.0,1.0,19.0,15,7,15,10,0,0,2,2,0,0,,0,0,2,1,1,void
3486,152060,cached_data,1,node.contextify.ContextifyScript.CreateCachedData.cached_data,ANY node.contextify.ContextifyScript.CreateCachedData.cached_data (ANY),node_contextify.cc,"std::unique_ptr<ScriptCompiler::CachedData> cached_data(
      ScriptCompiler::CreateCodeCache(unbound_script));",950.0,951.0,47.0,54.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
3487,152119,RunInContext,1,node.contextify.ContextifyScript.RunInContext,void node.contextify.ContextifyScript.RunInContext (FunctionCallbackInfo<Value>),node_contextify.cc,"void ContextifyScript::RunInContext(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  ContextifyScript* wrapped_script;
  ASSIGN_OR_RETURN_UNWRAP(&wrapped_script, args.Holder());

  CHECK_EQ(args.Length(), 5);
  CHECK(args[0]->IsObject() || args[0]->IsNull());

  Local<Context> context;
  std::shared_ptr<MicrotaskQueue> microtask_queue;

  if (args[0]->IsObject()) {
    Local<Object> sandbox = args[0].As<Object>();
    // Get the context from the sandbox
    ContextifyContext* contextify_context =
        ContextifyContext::ContextFromContextifiedSandbox(env, sandbox);
    CHECK_NOT_NULL(contextify_context);
    CHECK_EQ(contextify_context->env(), env);

    context = contextify_context->context();
    if (context.IsEmpty()) return;

    microtask_queue = contextify_context->microtask_queue();
  } else {
    context = env->context();
  }

  TRACE_EVENT0(TRACING_CATEGORY_NODE2(vm, script), ""RunInContext"");

  CHECK(args[1]->IsNumber());...",963.0,1014.0,1.0,1.0,52.0,52,8,54,20,0,0,3,4,0,0,,0,0,2,1,1,void
3488,152321,EvalMachine,1,node.contextify.ContextifyScript.EvalMachine,"bool node.contextify.ContextifyScript.EvalMachine (Local<Context>,Environment*,int64_t,bool,bool,bool,ANY,FunctionCallbackInfo<Value>)",node_contextify.cc,"bool ContextifyScript::EvalMachine(Local<Context> context,
                                   Environment* env,
                                   const int64_t timeout,
                                   const bool display_errors,
                                   const bool break_on_sigint,
                                   const bool break_on_first_line,
                                   std::shared_ptr<MicrotaskQueue> mtask_queue,
                                   const FunctionCallbackInfo<Value>& args) {
  Context::Scope context_scope(context);

  if (!env->can_call_into_js())
    return false;
  if (!ContextifyScript::InstanceOf(env, args.Holder())) {
    THROW_ERR_INVALID_THIS(
        env,
        ""Script methods can only be called on script instances."");
    return false;
  }

  TryCatchScope try_catch(env);
  Isolate::SafeForTerminationScope safe_for_termination(env->isolate());
  ContextifyScript* wrapped_script;
  ASSIGN_OR_RETURN_UNWRAP(&wrapped_script, args.Holder...",1016.0,1106.0,1.0,1.0,91.0,51,11,54,23,0,0,10,14,0,0,,0,0,16,8,8,bool
3489,152582,ContextifyScript,1,node.contextify.ContextifyScript.ContextifyScript,"ANY node.contextify.ContextifyScript.ContextifyScript (Environment*,Local<Object>)",node_contextify.cc,"ContextifyScript::ContextifyScript(Environment* env, Local<Object> object)
    : BaseObject(env, object),
      id_(env->get_next_script_id()) {
  MakeWeak();
  env->id_to_script_map.emplace(id_, this);
}",1109.0,1114.0,1.0,1.0,6.0,2,2,2,2,0,0,1,1,0,0,,0,0,4,2,2,ANY
3490,152597,~ContextifyScript,1,node.contextify.ContextifyScript.~ContextifyScript,ANY node.contextify.ContextifyScript.~ContextifyScript (),node_contextify.cc,"ContextifyScript::~ContextifyScript() {
  env()->id_to_script_map.erase(id_);
}",1117.0,1119.0,1.0,1.0,3.0,2,2,1,1,0,0,1,1,0,0,,0,0,0,0,0,ANY
3491,152608,CompileFunction,1,node.contextify.ContextifyContext.CompileFunction,void node.contextify.ContextifyContext.CompileFunction (FunctionCallbackInfo<Value>),node_contextify.cc,"void ContextifyContext::CompileFunction(
    const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();
  Local<Context> context = env->context();

  // Argument 1: source code
  CHECK(args[0]->IsString());
  Local<String> code = args[0].As<String>();

  // Argument 2: filename
  CHECK(args[1]->IsString());
  Local<String> filename = args[1].As<String>();

  // Argument 3: line offset
  CHECK(args[2]->IsNumber());
  int line_offset = args[2].As<Int32>()->Value();

  // Argument 4: column offset
  CHECK(args[3]->IsNumber());
  int column_offset = args[3].As<Int32>()->Value();

  // Argument 5: cached data (optional)
  Local<ArrayBufferView> cached_data_buf;
  if (!args[4]->IsUndefined()) {
    CHECK(args[4]->IsArrayBufferView());
    cached_data_buf = args[4].As<ArrayBufferView>();
  }

  // Argument 6: produce cache data
  CHECK(args[5]->IsBoolean());
  bool produce_cached_data = args[5]->IsTrue();

  // Argume...",1122.0,1303.0,1.0,1.0,182.0,212,15,216,55,0,0,21,28,0,0,,0,0,2,1,1,void
3492,153359,WeakCallback,1,node.contextify.CompiledFnEntry.WeakCallback,void node.contextify.CompiledFnEntry.WeakCallback (WeakCallbackInfo<CompiledFnEntry>),node_contextify.cc,"void CompiledFnEntry::WeakCallback(
    const WeakCallbackInfo<CompiledFnEntry>& data) {
  CompiledFnEntry* entry = data.GetParameter();
  delete entry;
}",1305.0,1309.0,1.0,1.0,5.0,3,3,3,2,0,0,1,1,0,0,,0,0,2,1,1,void
3493,153373,CompiledFnEntry,1,node.contextify.CompiledFnEntry.CompiledFnEntry,"ANY node.contextify.CompiledFnEntry.CompiledFnEntry (Environment*,Local<Object>,uint32_t,Local<Function>)",node_contextify.cc,"CompiledFnEntry::CompiledFnEntry(Environment* env,
                                 Local<Object> object,
                                 uint32_t id,
                                 Local<Function> fn)
    : BaseObject(env, object), id_(id), fn_(env->isolate(), fn) {
  fn_.SetWeak(this, WeakCallback, v8::WeakCallbackType::kParameter);
}",1311.0,1317.0,1.0,1.0,7.0,3,1,4,4,0,0,1,1,0,0,,0,0,8,4,4,ANY
3494,153392,~CompiledFnEntry,1,node.contextify.CompiledFnEntry.~CompiledFnEntry,ANY node.contextify.CompiledFnEntry.~CompiledFnEntry (),node_contextify.cc,"CompiledFnEntry::~CompiledFnEntry() {
  env()->id_to_function_map.erase(id_);
  fn_.ClearWeak();
}",1319.0,1322.0,1.0,1.0,4.0,3,2,2,2,0,0,1,1,0,0,,0,0,0,0,0,ANY
3495,153407,StartSigintWatchdog,1,node.contextify.StartSigintWatchdog,void node.contextify.StartSigintWatchdog (FunctionCallbackInfo<Value>),node_contextify.cc,"static void StartSigintWatchdog(const FunctionCallbackInfo<Value>& args) {
  int ret = SigintWatchdogHelper::GetInstance()->Start();
  args.GetReturnValue().Set(ret == 0);
}",1324.0,1327.0,1.0,1.0,4.0,6,4,4,3,0,0,1,1,0,0,,0,0,2,1,1,void
3496,153432,StopSigintWatchdog,1,node.contextify.StopSigintWatchdog,void node.contextify.StopSigintWatchdog (FunctionCallbackInfo<Value>),node_contextify.cc,"static void StopSigintWatchdog(const FunctionCallbackInfo<Value>& args) {
  bool had_pending_signals = SigintWatchdogHelper::GetInstance()->Stop();
  args.GetReturnValue().Set(had_pending_signals);
}",1329.0,1332.0,1.0,1.0,4.0,5,3,4,3,0,0,1,1,0,0,,0,0,2,1,1,void
3497,153455,WatchdogHasPendingSigint,1,node.contextify.WatchdogHasPendingSigint,void node.contextify.WatchdogHasPendingSigint (FunctionCallbackInfo<Value>),node_contextify.cc,"static void WatchdogHasPendingSigint(const FunctionCallbackInfo<Value>& args) {
  bool ret = SigintWatchdogHelper::GetInstance()->HasPendingSignal();
  args.GetReturnValue().Set(ret);
}",1334.0,1337.0,1.0,1.0,4.0,5,3,4,3,0,0,1,1,0,0,,0,0,2,1,1,void
3498,153478,MeasureMemory,1,node.contextify.MeasureMemory,void node.contextify.MeasureMemory (FunctionCallbackInfo<Value>),node_contextify.cc,"static void MeasureMemory(const FunctionCallbackInfo<Value>& args) {
  CHECK(args[0]->IsInt32());
  CHECK(args[1]->IsInt32());
  int32_t mode = args[0].As<v8::Int32>()->Value();
  int32_t execution = args[1].As<v8::Int32>()->Value();
  Isolate* isolate = args.GetIsolate();

  Local<Context> current_context = isolate->GetCurrentContext();
  Local<Promise::Resolver> resolver;
  if (!Promise::Resolver::New(current_context).ToLocal(&resolver)) return;
  std::unique_ptr<v8::MeasureMemoryDelegate> delegate =
      v8::MeasureMemoryDelegate::Default(
          isolate,
          current_context,
          resolver,
          static_cast<v8::MeasureMemoryMode>(mode));
  isolate->MeasureMemory(std::move(delegate),
                         static_cast<v8::MeasureMemoryExecution>(execution));
  Local<Promise> promise = resolver->GetPromise();

  args.GetReturnValue().Set(promise);
}",1339.0,1360.0,1.0,1.0,22.0,43,9,38,15,0,0,2,2,0,0,,0,0,2,1,1,void
3499,153613,MicrotaskQueueWrap,1,node.contextify.MicrotaskQueueWrap.MicrotaskQueueWrap,"ANY node.contextify.MicrotaskQueueWrap.MicrotaskQueueWrap (Environment*,Local<Object>)",node_contextify.cc,"MicrotaskQueueWrap::MicrotaskQueueWrap(Environment* env, Local<Object> obj)
  : BaseObject(env, obj),
    microtask_queue_(
        MicrotaskQueue::New(env->isolate(), MicrotasksPolicy::kExplicit)) {
  MakeWeak();
}",1362.0,1367.0,1.0,1.0,6.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,ANY
3500,153620,microtask_queue,1,node.contextify.MicrotaskQueueWrap.microtask_queue,shared_ptr<MicrotaskQueue> node.contextify.MicrotaskQueueWrap.microtask_queue (),node_contextify.cc,"const std::shared_ptr<MicrotaskQueue>&
MicrotaskQueueWrap::microtask_queue() const {
  return microtask_queue_;
}",1369.0,1372.0,1.0,1.0,4.0,0,0,1,1,0,0,1,1,0,0,,0,0,0,0,0,shared_ptr<MicrotaskQueue>
3501,153626,New,1,node.contextify.MicrotaskQueueWrap.New,void node.contextify.MicrotaskQueueWrap.New (FunctionCallbackInfo<Value>),node_contextify.cc,"void MicrotaskQueueWrap::New(const FunctionCallbackInfo<Value>& args) {
  CHECK(args.IsConstructCall());
  new MicrotaskQueueWrap(Environment::GetCurrent(args), args.This());
}",1374.0,1377.0,1.0,1.0,4.0,4,2,5,3,0,0,1,1,0,0,,0,0,2,1,1,void
3502,153647,CreatePerIsolateProperties,1,node.contextify.MicrotaskQueueWrap.CreatePerIsolateProperties,"void node.contextify.MicrotaskQueueWrap.CreatePerIsolateProperties (IsolateData*,Local<ObjectTemplate>)",node_contextify.cc,"void MicrotaskQueueWrap::CreatePerIsolateProperties(
    IsolateData* isolate_data, Local<ObjectTemplate> target) {
  Isolate* isolate = isolate_data->isolate();
  HandleScope scope(isolate);
  Local<FunctionTemplate> tmpl = NewFunctionTemplate(isolate, New);
  tmpl->InstanceTemplate()->SetInternalFieldCount(
      ContextifyScript::kInternalFieldCount);
  isolate_data->set_microtask_queue_ctor_template(tmpl);
  SetConstructorFunction(isolate, target, ""MicrotaskQueue"", tmpl);
}",1379.0,1388.0,1.0,1.0,10.0,9,5,15,8,0,0,1,1,0,0,,0,0,4,2,2,void
3503,153692,RegisterExternalReferences,1,node.contextify.MicrotaskQueueWrap.RegisterExternalReferences,void node.contextify.MicrotaskQueueWrap.RegisterExternalReferences (ExternalReferenceRegistry*),node_contextify.cc,"void MicrotaskQueueWrap::RegisterExternalReferences(
    ExternalReferenceRegistry* registry) {
  registry->Register(New);
}",1390.0,1393.0,1.0,1.0,4.0,1,1,2,2,0,0,1,1,0,0,,0,0,2,1,1,void
3504,153702,CreatePerIsolateProperties,1,node.contextify.CreatePerIsolateProperties,"void node.contextify.CreatePerIsolateProperties (IsolateData*,Local<FunctionTemplate>)",node_contextify.cc,"void CreatePerIsolateProperties(IsolateData* isolate_data,
                                Local<FunctionTemplate> ctor) {
  Isolate* isolate = isolate_data->isolate();
  Local<ObjectTemplate> target = ctor->InstanceTemplate();
  ContextifyContext::CreatePerIsolateProperties(isolate_data, target);
  ContextifyScript::CreatePerIsolateProperties(isolate_data, target);
  MicrotaskQueueWrap::CreatePerIsolateProperties(isolate_data, target);

  SetMethod(isolate, target, ""startSigintWatchdog"", StartSigintWatchdog);
  SetMethod(isolate, target, ""stopSigintWatchdog"", StopSigintWatchdog);
  // Used in tests.
  SetMethodNoSideEffect(
      isolate, target, ""watchdogHasPendingSigint"", WatchdogHasPendingSigint);

  {
    Local<FunctionTemplate> tpl = FunctionTemplate::New(isolate);
    tpl->SetClassName(FIXED_ONE_BYTE_STRING(isolate, ""CompiledFnEntry""));
    tpl->InstanceTemplate()->SetInternalFieldCount(
        CompiledFnEntry::kInternalFieldCount);

    isolate_data->set_compiled_fn_entry_t...",1395.0,1418.0,1.0,1.0,24.0,19,5,34,12,0,0,1,1,0,0,,0,0,4,2,2,void
3505,153800,CreatePerContextProperties,1,node.contextify.CreatePerContextProperties,"void node.contextify.CreatePerContextProperties (Local<Object>,Local<Value>,Local<Context>,void*)",node_contextify.cc,"static void CreatePerContextProperties(Local<Object> target,
                                       Local<Value> unused,
                                       Local<Context> context,
                                       void* priv) {
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  Local<Object> constants = Object::New(env->isolate());
  Local<Object> measure_memory = Object::New(env->isolate());
  Local<Object> memory_execution = Object::New(env->isolate());

  {
    Local<Object> memory_mode = Object::New(env->isolate());
    MeasureMemoryMode SUMMARY = MeasureMemoryMode::kSummary;
    MeasureMemoryMode DETAILED = MeasureMemoryMode::kDetailed;
    NODE_DEFINE_CONSTANT(memory_mode, SUMMARY);
    NODE_DEFINE_CONSTANT(memory_mode, DETAILED);
    READONLY_PROPERTY(measure_memory, ""mode"", memory_mode);
  }

  {
    MeasureMemoryExecution DEFAULT = MeasureMemoryExecution::kDefault;
    MeasureMemoryExecution EAGER = MeasureMemoryExecution...",1420.0,1451.0,1.0,1.0,32.0,35,5,51,17,0,0,1,1,0,0,,0,0,8,4,4,void
3506,153942,RegisterExternalReferences,1,node.contextify.RegisterExternalReferences,void node.contextify.RegisterExternalReferences (ExternalReferenceRegistry*),node_contextify.cc,"void RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  ContextifyContext::RegisterExternalReferences(registry);
  ContextifyScript::RegisterExternalReferences(registry);
  MicrotaskQueueWrap::RegisterExternalReferences(registry);

  registry->Register(StartSigintWatchdog);
  registry->Register(StopSigintWatchdog);
  registry->Register(WatchdogHasPendingSigint);
  registry->Register(MeasureMemory);
}",1453.0,1462.0,1.0,1.0,10.0,7,2,10,4,0,0,1,1,0,0,,0,0,2,1,1,void
3507,154020,linux_at_secure,1,node.linux_at_secure,bool node.linux_at_secure (),node_credentials.cc,"bool linux_at_secure() {
  // This could reasonably be a static variable, but this way
  // we can guarantee that this function is always usable
  // and returns the correct value,  e.g. even in static
  // initialization code in other files.
#ifdef __linux__
  static const bool value = getauxval(AT_SECURE);
  return value;
#else
  return false;
#endif
}",35.0,46.0,1.0,1.0,12.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,bool
3508,154027,SafeGetenv,1,node.credentials.SafeGetenv,"bool node.credentials.SafeGetenv (char*,ANY*,ANY,ANY*)",node_credentials.cc,"static void SafeGetenv(const FunctionCallbackInfo<Value>& args) {
  CHECK(args[0]->IsString());
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();
  Utf8Value strenvtag(isolate, args[0]);
  std::string text;
  if (!SafeGetenv(*strenvtag, &text, env->env_vars(), isolate)) return;
  Local<Value> result =
      ToV8Value(isolate->GetCurrentContext(), text).ToLocalChecked();
  args.GetReturnValue().Set(result);
}",130.0,140.0,1.0,1.0,11.0,38,12,42,16,0,0,10,9,0,0,,0,0,2,1,1,void
3509,154249,RegisterExternalReferences,1,node.credentials.RegisterExternalReferences,void node.credentials.RegisterExternalReferences (ExternalReferenceRegistry*),node_credentials.cc,"void RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  registry->Register(SafeGetenv);

#ifdef NODE_IMPLEMENTS_POSIX_CREDENTIALS
  registry->Register(GetUid);
  registry->Register(GetEUid);
  registry->Register(GetGid);
  registry->Register(GetEGid);
  registry->Register(GetGroups);

  registry->Register(InitGroups);
  registry->Register(SetEGid);
  registry->Register(SetEUid);
  registry->Register(SetGid);
  registry->Register(SetUid);
  registry->Register(SetGroups);
#endif  // NODE_IMPLEMENTS_POSIX_CREDENTIALS
}",436.0,453.0,1.0,1.0,18.0,1,1,2,2,0,0,1,1,0,0,,0,0,2,1,1,void
3510,154259,Initialize,1,node.credentials.Initialize,"void node.credentials.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)",node_credentials.cc,"static void Initialize(Local<Object> target,
                       Local<Value> unused,
                       Local<Context> context,
                       void* priv) {
  SetMethod(context, target, ""safeGetenv"", SafeGetenv);

#ifdef NODE_IMPLEMENTS_POSIX_CREDENTIALS
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  READONLY_TRUE_PROPERTY(target, ""implementsPosixCredentials"");
  SetMethodNoSideEffect(context, target, ""getuid"", GetUid);
  SetMethodNoSideEffect(context, target, ""geteuid"", GetEUid);
  SetMethodNoSideEffect(context, target, ""getgid"", GetGid);
  SetMethodNoSideEffect(context, target, ""getegid"", GetEGid);
  SetMethodNoSideEffect(context, target, ""getgroups"", GetGroups);

  if (env->owns_process_state()) {
    SetMethod(context, target, ""initgroups"", InitGroups);
    SetMethod(context, target, ""setegid"", SetEGid);
    SetMethod(context, target, ""seteuid"", SetEUid);
    SetMethod(context, target, ""setgid"", SetGid);
    SetMeth...",455.0,481.0,1.0,1.0,27.0,0,0,3,3,0,0,1,1,0,0,,0,0,8,4,4,void
3511,154294,Initialize,1,node.crypto.Initialize,"void node.crypto.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)",node_crypto.cc,"void Initialize(Local<Object> target,
                Local<Value> unused,
                Local<Context> context,
                void* priv) {
  Environment* env = Environment::GetCurrent(context);

  if (!InitCryptoOnce(env->isolate())) {
    return;
  }

#define V(Namespace) Namespace::Initialize(env, target);
  CRYPTO_NAMESPACE_LIST(V)
#undef V
}",72.0,85.0,1.0,2.0,14.0,26,4,70,5,0,0,2,2,0,0,,0,0,8,4,4,void
3512,154453,RegisterExternalReferences,1,node.crypto.RegisterExternalReferences,void node.crypto.RegisterExternalReferences (ExternalReferenceRegistry*),node_crypto.cc,"void RegisterExternalReferences(ExternalReferenceRegistry* registry) {
#define V(Namespace) Namespace::RegisterExternalReferences(registry);
  CRYPTO_NAMESPACE_LIST(V)
#undef V
}",87.0,91.0,1.0,2.0,5.0,22,1,44,2,0,0,1,1,0,0,,0,0,2,1,1,void
3513,154621,<lambda>0,1,node.fs_dir.DirHandle.GCClose.<lambda>0,ANY node.fs_dir.DirHandle.GCClose.<lambda>0 (Environment*),node_dir.cc,"[detail](Environment* env) {
      const char* msg = ""Closing directory handle on garbage collection failed"";
      // This exception will end up being fatal for the process because
      // it is being thrown from within the SetImmediate handler and
      // there is no JS stack to bubble it to. In other words, tearing
      // down the process is the only reasonable thing we can do here.
      HandleScope handle_scope(env->isolate());
      env->ThrowUVException(detail.ret, ""close"", msg);
    }",152.0,160.0,25.0,5.0,9.0,4,3,5,3,0,0,1,1,0,0,,0,0,2,1,1,ANY
3514,154648,<lambda>1,1,node.fs_dir.DirHandle.GCClose.<lambda>1,ANY node.fs_dir.DirHandle.GCClose.<lambda>1 (Environment*),node_dir.cc,"[](Environment* env) {
    ProcessEmitWarning(env,
                       ""Closing directory handle on garbage collection"");
  }",168.0,171.0,23.0,3.0,4.0,0,0,1,1,0,0,1,1,0,0,,0,0,2,1,1,ANY
3515,154694,get_dir_func_name_by_type,1,node.fs_dir.get_dir_func_name_by_type,const char* node.fs_dir.get_dir_func_name_by_type (uv_fs_type),node_dir.cc,"static const char* get_dir_func_name_by_type(uv_fs_type req_type) {
  switch (req_type) {
#define FS_TYPE_TO_NAME(type, name)                                            \
  case UV_FS_##type:                                                           \
    return name;
    FS_TYPE_TO_NAME(OPENDIR, ""opendir"")
    FS_TYPE_TO_NAME(READDIR, ""readdir"")
    FS_TYPE_TO_NAME(CLOSEDIR, ""closedir"")
#undef FS_TYPE_TO_NAME
    default:
      return ""unknow"";
  }
}",46.0,58.0,1.0,4.0,13.0,0,0,4,4,0,0,2,2,0,0,,0,0,2,1,1,const char*
3516,154723,DirHandle,1,node.fs_dir.DirHandle.DirHandle,"ANY node.fs_dir.DirHandle.DirHandle (Environment*,Local<Object>,uv_dir_t*)",node_dir.cc,"DirHandle::DirHandle(Environment* env, Local<Object> obj, uv_dir_t* dir)
    : AsyncWrap(env, obj, AsyncWrap::PROVIDER_DIRHANDLE),
      dir_(dir) {
  MakeWeak();

  dir_->nentries = 0;
  dir_->dirents = nullptr;
}",98.0,105.0,1.0,1.0,8.0,4,2,2,1,0,0,1,1,0,0,,0,0,6,3,3,ANY
3517,154741,New,1,node.fs_dir.DirHandle.New,"DirHandle node.fs_dir.DirHandle.New (Environment*,uv_dir_t*)",node_dir.cc,"void DirHandle::New(const FunctionCallbackInfo<Value>& args) {
  CHECK(args.IsConstructCall());
}",118.0,120.0,1.0,1.0,3.0,9,7,10,6,0,0,2,2,0,0,,0,0,2,1,1,void
3518,154789,~DirHandle,1,node.fs_dir.DirHandle.~DirHandle,ANY node.fs_dir.DirHandle.~DirHandle (),node_dir.cc,"DirHandle::~DirHandle() {
  CHECK(!closing_);  // We should not be deleting while explicitly closing!
  GCClose();         // Close synchronously and emit warning
  CHECK(closed_);    // We have to be closed at the point
}",122.0,126.0,1.0,1.0,5.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,ANY
3519,154798,MemoryInfo,1,node.fs_dir.DirHandle.MemoryInfo,void node.fs_dir.DirHandle.MemoryInfo (MemoryTracker*),node_dir.cc,"void DirHandle::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackFieldWithSize(""dir"", sizeof(*dir_));
}",128.0,130.0,1.0,1.0,3.0,3,3,2,2,0,0,1,1,0,0,,0,0,2,1,1,void
3520,154811,GCClose,1,node.fs_dir.DirHandle.GCClose,void node.fs_dir.DirHandle.GCClose (),node_dir.cc,"inline void DirHandle::GCClose() {
  if (closed_) return;
  uv_fs_t req;
  FS_DIR_SYNC_TRACE_BEGIN(closedir);
  int ret = uv_fs_closedir(nullptr, &req, dir_, nullptr);
  FS_DIR_SYNC_TRACE_END(closedir);
  uv_fs_req_cleanup(&req);
  closing_ = false;
  closed_ = true;

  struct err_detail { int ret; };

  err_detail detail { ret };

  if (ret < 0) {
    // Do not unref this
    env()->SetImmediate([detail](Environment* env) {
      const char* msg = ""Closing directory handle on garbage collection failed"";
      // This exception will end up being fatal for the process because
      // it is being thrown from within the SetImmediate handler and
      // there is no JS stack to bubble it to. In other words, tearing
      // down the process is the only reasonable thing we can do here.
      HandleScope handle_scope(env->isolate());
      env->ThrowUVException(detail.ret, ""close"", msg);
    });
    return;
  }

  // If the close was successful, we still want to emit a process warning
  ...",136.0,172.0,1.0,2.0,37.0,69,12,69,17,0,0,3,3,0,0,,0,0,0,0,0,void
3521,155053,AfterClose,1,node.fs_dir.AfterClose,void node.fs_dir.AfterClose (uv_fs_t*),node_dir.cc,"void AfterClose(uv_fs_t* req) {
  FSReqBase* req_wrap = FSReqBase::from_req(req);
  FSReqAfterScope after(req_wrap, req);
  FS_DIR_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))
  if (after.Proceed())
    req_wrap->Resolve(Undefined(req_wrap->env()->isolate()));
}",174.0,181.0,1.0,2.0,8.0,39,11,39,13,0,0,2,2,0,0,,0,0,2,1,1,void
3522,155202,Close,1,node.fs_dir.DirHandle.Close,void node.fs_dir.DirHandle.Close (FunctionCallbackInfo<Value>),node_dir.cc,"void DirHandle::Close(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 1);

  DirHandle* dir;
  ASSIGN_OR_RETURN_UNWRAP(&dir, args.Holder());

  dir->closing_ = false;
  dir->closed_ = true;

  FSReqBase* req_wrap_async = GetReqWrap(args, 0);
  if (req_wrap_async != nullptr) {  // close(req)
    FS_DIR_ASYNC_TRACE_BEGIN0(UV_FS_CLOSEDIR, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""closedir"", UTF8, AfterClose,
              uv_fs_closedir, dir->dir());
  } else {  // close(undefined, ctx)
    CHECK_EQ(argc, 2);
    FSReqWrapSync req_wrap_sync;
    FS_DIR_SYNC_TRACE_BEGIN(closedir);
    SyncCall(env, args[1], &req_wrap_sync, ""closedir"", uv_fs_closedir,
             dir->dir());
    FS_DIR_SYNC_TRACE_END(closedir);
  }
}",183.0,208.0,1.0,4.0,26.0,40,12,49,19,0,0,2,2,0,0,,0,0,2,1,1,void
3523,155575,DirentListToArray,1,node.fs_dir.DirentListToArray,"MaybeLocal<Array> node.fs_dir.DirentListToArray (Environment*,uv_dirent_t*,int,encoding,Local<Value>*)",node_dir.cc,"static MaybeLocal<Array> DirentListToArray(
    Environment* env,
    uv_dirent_t* ents,
    int num,
    enum encoding encoding,
    Local<Value>* err_out) {
  MaybeStackBuffer<Local<Value>, 64> entries(num * 2);

  // Return an array of all read filenames.
  int j = 0;
  for (int i = 0; i < num; i++) {
    Local<Value> filename;
    Local<Value> error;
    const size_t namelen = strlen(ents[i].name);
    if (!StringBytes::Encode(env->isolate(),
                             ents[i].name,
                             namelen,
                             encoding,
                             &error).ToLocal(&filename)) {
      *err_out = error;
      return MaybeLocal<Array>();
    }

    entries[j++] = filename;
    entries[j++] = Integer::New(env->isolate(), ents[i].type);
  }

  return Array::New(env->isolate(), entries.out(), j);
}",210.0,238.0,1.0,1.0,29.0,34,11,37,16,0,0,3,4,0,0,,0,0,10,5,5,MaybeLocal<Array>
3524,155693,AfterDirRead,1,node.fs_dir.AfterDirRead,void node.fs_dir.AfterDirRead (uv_fs_t*),node_dir.cc,"static void AfterDirRead(uv_fs_t* req) {
  BaseObjectPtr<FSReqBase> req_wrap { FSReqBase::from_req(req) };
  FSReqAfterScope after(req_wrap.get(), req);
  FS_DIR_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))
  if (!after.Proceed()) {
    return;
  }

  Environment* env = req_wrap->env();
  Isolate* isolate = env->isolate();

  if (req->result == 0) {
    // Done
    Local<Value> done = Null(isolate);
    after.Clear();
    req_wrap->Resolve(done);
    return;
  }

  uv_dir_t* dir = static_cast<uv_dir_t*>(req->ptr);

  Local<Value> error;
  Local<Array> js_array;
  if (!DirentListToArray(env,
                         dir->dirents,
                         static_cast<int>(req->result),
                         req_wrap->encoding(),
                         &error)
           .ToLocal(&js_array)) {
    // Clear libuv resources *before* delivering results to JS land because
    // that can schedule another operation on the same uv_dir_t. Ditto...",240.0,278.0,1.0,2.0,39.0,70,14,70,23,0,0,4,4,0,0,,0,0,2,1,1,void
3525,155938,Read,1,node.fs_dir.DirHandle.Read,void node.fs_dir.DirHandle.Read (FunctionCallbackInfo<Value>),node_dir.cc,"void DirHandle::Read(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  const enum encoding encoding = ParseEncoding(isolate, args[0], UTF8);

  DirHandle* dir;
  ASSIGN_OR_RETURN_UNWRAP(&dir, args.Holder());

  CHECK(args[1]->IsNumber());
  uint64_t buffer_size = static_cast<uint64_t>(args[1].As<Number>()->Value());

  if (buffer_size != dir->dirents_.size()) {
    dir->dirents_.resize(buffer_size);
    dir->dir_->nentries = buffer_size;
    dir->dir_->dirents = dir->dirents_.data();
  }

  FSReqBase* req_wrap_async = GetReqWrap(args, 2);
  if (req_wrap_async != nullptr) {  // dir.read(encoding, bufferSize, req)
    FS_DIR_ASYNC_TRACE_BEGIN0(UV_FS_READDIR, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""readdir"", encoding,
              AfterDirRead, uv_fs_readdir, dir->dir());
  } else {  // dir.read(encoding, bufferSize, undefined, ...",281.0,342.0,1.0,4.0,62.0,60,13,64,22,0,0,3,3,0,0,,0,0,2,1,1,void
3526,156487,AfterOpenDir,1,node.fs_dir.AfterOpenDir,void node.fs_dir.AfterOpenDir (uv_fs_t*),node_dir.cc,"void AfterOpenDir(uv_fs_t* req) {
  FSReqBase* req_wrap = FSReqBase::from_req(req);
  FSReqAfterScope after(req_wrap, req);
  FS_DIR_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))
  if (!after.Proceed()) {
    return;
  }

  Environment* env = req_wrap->env();

  uv_dir_t* dir = static_cast<uv_dir_t*>(req->ptr);
  DirHandle* handle = DirHandle::New(env, dir);

  req_wrap->Resolve(handle->object().As<Value>());
}",344.0,359.0,1.0,2.0,16.0,47,11,47,17,0,0,2,2,0,0,,0,0,2,1,1,void
3527,156661,OpenDir,1,node.fs_dir.OpenDir,void node.fs_dir.OpenDir (FunctionCallbackInfo<Value>),node_dir.cc,"static void OpenDir(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  BufferValue path(isolate, args[0]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemRead, path.ToStringView());

  const enum encoding encoding = ParseEncoding(isolate, args[1], UTF8);

  FSReqBase* req_wrap_async = GetReqWrap(args, 2);
  if (req_wrap_async != nullptr) {  // openDir(path, encoding, req)
    FS_DIR_ASYNC_TRACE_BEGIN1(
        UV_FS_OPENDIR, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""opendir"", encoding, AfterOpenDir,
              uv_fs_opendir, *path);
  } else {  // openDir(path, encoding, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_DIR_SYNC_TRACE_BEGIN(opendir);
    int result = SyncCall(env, args[3], &req_wrap_syn...",361.0,398.0,1.0,4.0,38.0,46,13,60,22,0,0,2,2,0,0,,0,0,2,1,1,void
3528,157105,Initialize,1,node.fs_dir.Initialize,"void node.fs_dir.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)",node_dir.cc,"void Initialize(Local<Object> target,
                Local<Value> unused,
                Local<Context> context,
                void* priv) {
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  SetMethod(context, target, ""opendir"", OpenDir);

  // Create FunctionTemplate for DirHandle
  Local<FunctionTemplate> dir = NewFunctionTemplate(isolate, DirHandle::New);
  dir->Inherit(AsyncWrap::GetConstructorTemplate(env));
  SetProtoMethod(isolate, dir, ""read"", DirHandle::Read);
  SetProtoMethod(isolate, dir, ""close"", DirHandle::Close);
  Local<ObjectTemplate> dirt = dir->InstanceTemplate();
  dirt->SetInternalFieldCount(DirHandle::kInternalFieldCount);
  SetConstructorFunction(context, target, ""DirHandle"", dir);
  env->set_dir_instance_template(dirt);
}",400.0,418.0,1.0,1.0,19.0,19,5,32,12,0,0,1,1,0,0,,0,0,8,4,4,void
3529,157194,RegisterExternalReferences,1,node.fs_dir.RegisterExternalReferences,void node.fs_dir.RegisterExternalReferences (ExternalReferenceRegistry*),node_dir.cc,"void RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  registry->Register(OpenDir);
  registry->Register(DirHandle::New);
  registry->Register(DirHandle::Read);
  registry->Register(DirHandle::Close);
}",420.0,425.0,1.0,1.0,6.0,7,2,7,2,0,0,1,1,0,0,,0,0,2,1,1,void
3530,157234,<lambda>0,1,node.RealEnvStore.Enumerate.<lambda>0,ANY node.RealEnvStore.Enumerate.<lambda>0 (),node_env_var.cc,"[&]() { uv_os_free_environ(items, count); }",193.0,193.0,31.0,73.0,1.0,0,0,2,2,0,0,1,1,0,0,,0,0,0,0,0,ANY
3531,157264,Get,1,node.RealEnvStore.Get,"MaybeLocal<String> node.RealEnvStore.Get (Isolate*,Local<String>)",node_env_var.cc,"MaybeLocal<String> RealEnvStore::Get(Isolate* isolate,
                                     Local<String> property) const {
  node::Utf8Value key(isolate, property);
  Maybe<std::string> value = Get(*key);

  if (value.IsJust()) {
    std::string val = value.FromJust();
    return String::NewFromUtf8(
        isolate, val.data(), NewStringType::kNormal, val.size());
  }

  return MaybeLocal<String>();
}",124.0,136.0,1.0,1.0,13.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,MaybeLocal<String>
3532,157275,Set,1,node.RealEnvStore.Set,"void node.RealEnvStore.Set (Isolate*,Local<String>,Local<String>)",node_env_var.cc,"void RealEnvStore::Set(Isolate* isolate,
                       Local<String> property,
                       Local<String> value) {
  Mutex::ScopedLock lock(per_process::env_var_mutex);

  node::Utf8Value key(isolate, property);
  node::Utf8Value val(isolate, value);

#ifdef _WIN32
  if (key.length() > 0 && key[0] == '=') return;
#endif
  uv_os_setenv(*key, *val);
  DateTimeConfigurationChangeNotification(isolate, key, *val);
}",138.0,151.0,1.0,1.0,14.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,void
3533,157282,Query,1,node.RealEnvStore.Query,"int32_t node.RealEnvStore.Query (Isolate*,Local<String>)",node_env_var.cc,"int32_t RealEnvStore::Query(Isolate* isolate, Local<String> property) const {
  node::Utf8Value key(isolate, property);
  return Query(*key);
}",175.0,178.0,1.0,1.0,4.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int32_t
3534,157293,Delete,1,node.RealEnvStore.Delete,"void node.RealEnvStore.Delete (Isolate*,Local<String>)",node_env_var.cc,"void RealEnvStore::Delete(Isolate* isolate, Local<String> property) {
  Mutex::ScopedLock lock(per_process::env_var_mutex);

  node::Utf8Value key(isolate, property);
  uv_os_unsetenv(*key);
  DateTimeConfigurationChangeNotification(isolate, key);
}",180.0,186.0,1.0,1.0,7.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
3535,157299,Enumerate,1,node.RealEnvStore.Enumerate,Local<Array> node.RealEnvStore.Enumerate (Isolate*),node_env_var.cc,"Local<Array> RealEnvStore::Enumerate(Isolate* isolate) const {
  Mutex::ScopedLock lock(per_process::env_var_mutex);
  uv_env_item_t* items;
  int count;

  auto cleanup = OnScopeLeave([&]() { uv_os_free_environ(items, count); });
  CHECK_EQ(uv_os_environ(&items, &count), 0);

  MaybeStackBuffer<Local<Value>, 256> env_v(count);
  int env_v_index = 0;
  for (int i = 0; i < count; i++) {
#ifdef _WIN32
    // If the key starts with '=' it is a hidden environment variable.
    if (items[i].name[0] == '=') continue;
#endif
    MaybeLocal<String> str = String::NewFromUtf8(isolate, items[i].name);
    if (str.IsEmpty()) {
      isolate->ThrowException(ERR_STRING_TOO_LONG(isolate));
      return Local<Array>();
    }
    env_v[env_v_index++] = str.ToLocalChecked();
  }

  return Array::New(isolate, env_v.out(), env_v_index);
}",188.0,212.0,1.0,1.0,25.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,Local<Array>
3536,157305,Get,1,node.MapKVStore.Get,"MaybeLocal<String> node.MapKVStore.Get (Isolate*,Local<String>)",node_env_var.cc,"MaybeLocal<String> MapKVStore::Get(Isolate* isolate, Local<String> key) const {
  Utf8Value str(isolate, key);
  Maybe<std::string> value = Get(*str);
  if (value.IsNothing()) return Local<String>();
  std::string val = value.FromJust();
  return String::NewFromUtf8(
      isolate, val.data(), NewStringType::kNormal, val.size());
}",237.0,244.0,1.0,1.0,8.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,MaybeLocal<String>
3537,157316,Set,1,node.MapKVStore.Set,"void node.MapKVStore.Set (Isolate*,Local<String>,Local<String>)",node_env_var.cc,"void MapKVStore::Set(Isolate* isolate, Local<String> key, Local<String> value) {
  Mutex::ScopedLock lock(mutex_);
  Utf8Value key_str(isolate, key);
  Utf8Value value_str(isolate, value);
  if (*key_str != nullptr && key_str.length() > 0 && *value_str != nullptr) {
    map_[std::string(*key_str, key_str.length())] =
        std::string(*value_str, value_str.length());
  }
}",246.0,254.0,1.0,1.0,9.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,void
3538,157323,Query,1,node.MapKVStore.Query,"int32_t node.MapKVStore.Query (Isolate*,Local<String>)",node_env_var.cc,"int32_t MapKVStore::Query(Isolate* isolate, Local<String> key) const {
  Utf8Value str(isolate, key);
  return Query(*str);
}",261.0,264.0,1.0,1.0,4.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int32_t
3539,157334,Delete,1,node.MapKVStore.Delete,"void node.MapKVStore.Delete (Isolate*,Local<String>)",node_env_var.cc,"void MapKVStore::Delete(Isolate* isolate, Local<String> key) {
  Mutex::ScopedLock lock(mutex_);
  Utf8Value str(isolate, key);
  map_.erase(std::string(*str, str.length()));
}",266.0,270.0,1.0,1.0,5.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
3540,157340,Enumerate,1,node.MapKVStore.Enumerate,Local<Array> node.MapKVStore.Enumerate (Isolate*),node_env_var.cc,"Local<Array> MapKVStore::Enumerate(Isolate* isolate) const {
  Mutex::ScopedLock lock(mutex_);
  std::vector<Local<Value>> values;
  values.reserve(map_.size());
  for (const auto& pair : map_) {
    values.emplace_back(
        String::NewFromUtf8(isolate, pair.first.data(),
                            NewStringType::kNormal, pair.first.size())
            .ToLocalChecked());
  }
  return Array::New(isolate, values.data(), values.size());
}",272.0,283.0,1.0,1.0,12.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,Local<Array>
3541,157345,Clone,1,node.MapKVStore.Clone,ANY node.MapKVStore.Clone (Isolate*),node_env_var.cc,"std::shared_ptr<KVStore> MapKVStore::Clone(Isolate* isolate) const {
  return std::make_shared<MapKVStore>(*this);
}",285.0,287.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,shared_ptr<KVStore>
3542,157350,MapKVStore,1,node.MapKVStore.MapKVStore,ANY node.MapKVStore.MapKVStore (),node_env_var.cc,"MapKVStore(const MapKVStore& other) : KVStore(), map_(other.map_) {}",61.0,61.0,3.0,70.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
3543,157370,DateTimeConfigurationChangeNotification,1,node.DateTimeConfigurationChangeNotification,"void node.DateTimeConfigurationChangeNotification<T> (Isolate*,T,char*)",node_env_var.cc,"void DateTimeConfigurationChangeNotification(
    Isolate* isolate,
    const T& key,
    const char* val = nullptr) {
  if (key.length() == 2 && key[0] == 'T' && key[1] == 'Z') {
#ifdef __POSIX__
    tzset();
    isolate->DateTimeConfigurationChangeNotification(
        Isolate::TimeZoneDetection::kRedetect);
#else
    _tzset();

# if defined(NODE_HAVE_I18N_SUPPORT)
    isolate->DateTimeConfigurationChangeNotification(
        Isolate::TimeZoneDetection::kSkip);

    // On windows, the TZ environment is not supported out of the box.
    // By default, v8 will only be able to detect the system configured
    // timezone. This supports using the TZ environment variable to set
    // the default timezone instead.
    if (val != nullptr) i18n::SetDefaultTimeZone(val);
# else
    isolate->DateTimeConfigurationChangeNotification(
        Isolate::TimeZoneDetection::kRedetect);
# endif
#endif
  }
}",74.0,101.0,1.0,1.0,28.0,11,5,6,4,0,0,2,2,0,0,,0,0,6,3,3,void
3544,157709,Clone,1,node.KVStore.Clone,shared_ptr<KVStore> node.KVStore.Clone (Isolate*),node_env_var.cc,"std::shared_ptr<KVStore> KVStore::Clone(Isolate* isolate) const {
  HandleScope handle_scope(isolate);
  Local<Context> context = isolate->GetCurrentContext();

  std::shared_ptr<KVStore> copy = KVStore::CreateMapKVStore();
  Local<Array> keys = Enumerate(isolate);
  uint32_t keys_length = keys->Length();
  for (uint32_t i = 0; i < keys_length; i++) {
    Local<Value> key = keys->Get(context, i).ToLocalChecked();
    CHECK(key->IsString());
    copy->Set(isolate,
              key.As<String>(),
              Get(isolate, key.As<String>()).ToLocalChecked());
  }
  return copy;
}",214.0,229.0,1.0,1.0,16.0,26,5,31,13,0,0,2,2,0,0,,0,0,2,1,1,shared_ptr<KVStore>
3545,158096,CreateMapKVStore,1,node.KVStore.CreateMapKVStore,shared_ptr<KVStore> node.KVStore.CreateMapKVStore (),node_env_var.cc,"std::shared_ptr<KVStore> KVStore::CreateMapKVStore() {
  return std::make_shared<MapKVStore>();
}",289.0,291.0,1.0,1.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,shared_ptr<KVStore>
3546,158105,AssignFromObject,1,node.KVStore.AssignFromObject,"Maybe<bool> node.KVStore.AssignFromObject (Local<Context>,Local<Object>)",node_env_var.cc,"Maybe<bool> KVStore::AssignFromObject(Local<Context> context,
                                      Local<Object> entries) {
  Isolate* isolate = context->GetIsolate();
  HandleScope handle_scope(isolate);
  Local<Array> keys;
  if (!entries->GetOwnPropertyNames(context).ToLocal(&keys))
    return Nothing<bool>();
  uint32_t keys_length = keys->Length();
  for (uint32_t i = 0; i < keys_length; i++) {
    Local<Value> key;
    if (!keys->Get(context, i).ToLocal(&key))
      return Nothing<bool>();
    if (!key->IsString()) continue;

    Local<Value> value;
    Local<String> value_string;
    if (!entries->Get(context, key).ToLocal(&value) ||
        !value->ToString(context).ToLocal(&value_string)) {
      return Nothing<bool>();
    }

    Set(isolate, key.As<String>(), value_string);
  }
  return Just(true);
}",293.0,317.0,1.0,1.0,25.0,34,8,38,13,0,0,7,9,0,0,,0,0,4,2,2,Maybe<bool>
3547,158237,AssignToObject,1,node.KVStore.AssignToObject,"Maybe<bool> node.KVStore.AssignToObject (ANY*,ANY,ANY)",node_env_var.cc,"Maybe<bool> KVStore::AssignToObject(v8::Isolate* isolate,
                                    v8::Local<v8::Context> context,
                                    v8::Local<v8::Object> object) {
  HandleScope scope(isolate);
  Local<Array> keys = Enumerate(isolate);
  uint32_t keys_length = keys->Length();
  for (uint32_t i = 0; i < keys_length; i++) {
    Local<Value> key;
    Local<String> value;
    bool ok = keys->Get(context, i).ToLocal(&key);
    ok = ok && key->IsString();
    ok = ok && Get(isolate, key.As<String>()).ToLocal(&value);
    ok = ok && object->Set(context, key, value).To(&ok);
    if (!ok) return Nothing<bool>();
  }
  return Just(true);
}",321.0,337.0,1.0,1.0,17.0,29,8,37,13,0,0,3,4,0,0,,0,0,6,3,3,Maybe<bool>
3548,158346,EnvGetter,1,node.EnvGetter,"void node.EnvGetter (Local<Name>,PropertyCallbackInfo<Value>)",node_env_var.cc,"static void EnvGetter(Local<Name> property,
                      const PropertyCallbackInfo<Value>& info) {
  Environment* env = Environment::GetCurrent(info);
  CHECK(env->has_run_bootstrapping_code());
  if (property->IsSymbol()) {
    return info.GetReturnValue().SetUndefined();
  }
  CHECK(property->IsString());
  MaybeLocal<String> value_string =
      env->env_vars()->Get(env->isolate(), property.As<String>());
  if (!value_string.IsEmpty()) {
    info.GetReturnValue().Set(value_string.ToLocalChecked());
  }
}",339.0,352.0,1.0,1.0,14.0,19,6,16,7,0,0,3,3,0,0,,0,0,4,2,2,void
3549,158423,EnvSetter,1,node.EnvSetter,"void node.EnvSetter (Local<Name>,Local<Value>,PropertyCallbackInfo<Value>)",node_env_var.cc,"static void EnvSetter(Local<Name> property,
                      Local<Value> value,
                      const PropertyCallbackInfo<Value>& info) {
  Environment* env = Environment::GetCurrent(info);
  CHECK(env->has_run_bootstrapping_code());
  // calling env->EmitProcessEnvWarning() sets a variable indicating that
  // warnings have been emitted. It should be called last after other
  // conditions leading to a warning have been met.
  if (env->options()->pending_deprecation && !value->IsString() &&
      !value->IsNumber() && !value->IsBoolean() &&
      env->EmitProcessEnvWarning()) {
    if (ProcessEmitDeprecationWarning(
            env,
            ""Assigning any value other than a string, number, or boolean to a ""
            ""process.env property is deprecated. Please make sure to convert ""
            ""the ""
            ""value to a string before setting process.env with it."",
            ""DEP0104"")
            .IsNothing())
      return;
  }

  Local<String> key;
  Loca...",354.0,387.0,1.0,1.0,34.0,37,9,28,9,0,0,4,5,0,0,,0,0,6,3,3,void
3550,158547,EnvQuery,1,node.EnvQuery,"void node.EnvQuery (Local<Name>,PropertyCallbackInfo<Integer>)",node_env_var.cc,"static void EnvQuery(Local<Name> property,
                     const PropertyCallbackInfo<Integer>& info) {
  Environment* env = Environment::GetCurrent(info);
  CHECK(env->has_run_bootstrapping_code());
  if (property->IsString()) {
    int32_t rc = env->env_vars()->Query(env->isolate(), property.As<String>());
    if (rc != -1) info.GetReturnValue().Set(rc);
  }
}",389.0,397.0,1.0,1.0,9.0,13,5,12,5,0,0,3,4,0,0,,0,0,4,2,2,void
3551,158604,EnvDeleter,1,node.EnvDeleter,"void node.EnvDeleter (Local<Name>,PropertyCallbackInfo<Boolean>)",node_env_var.cc,"static void EnvDeleter(Local<Name> property,
                       const PropertyCallbackInfo<Boolean>& info) {
  Environment* env = Environment::GetCurrent(info);
  CHECK(env->has_run_bootstrapping_code());
  if (property->IsString()) {
    env->env_vars()->Delete(env->isolate(), property.As<String>());
  }

  // process.env never has non-configurable properties, so always
  // return true like the tc39 delete operator.
  info.GetReturnValue().Set(true);
}",399.0,410.0,1.0,1.0,12.0,10,3,9,4,0,0,2,2,0,0,,0,0,4,2,2,void
3552,158652,EnvEnumerator,1,node.EnvEnumerator,void node.EnvEnumerator (PropertyCallbackInfo<Array>),node_env_var.cc,"static void EnvEnumerator(const PropertyCallbackInfo<Array>& info) {
  Environment* env = Environment::GetCurrent(info);
  CHECK(env->has_run_bootstrapping_code());

  info.GetReturnValue().Set(
      env->env_vars()->Enumerate(env->isolate()));
}",412.0,418.0,1.0,1.0,7.0,8,3,7,3,0,0,1,1,0,0,,0,0,2,1,1,void
3553,158688,EnvDefiner,1,node.EnvDefiner,"void node.EnvDefiner (Local<Name>,PropertyDescriptor,PropertyCallbackInfo<Value>)",node_env_var.cc,"static void EnvDefiner(Local<Name> property,
                       const PropertyDescriptor& desc,
                       const PropertyCallbackInfo<Value>& info) {
  Environment* env = Environment::GetCurrent(info);
  if (desc.has_value()) {
    if (!desc.has_writable() ||
        !desc.has_enumerable() ||
        !desc.has_configurable()) {
      THROW_ERR_INVALID_OBJECT_DEFINE_PROPERTY(env,
                                               ""'process.env' only accepts a ""
                                               ""configurable, writable,""
                                               "" and enumerable ""
                                               ""data descriptor"");
    } else if (!desc.configurable() ||
               !desc.enumerable() ||
               !desc.writable()) {
      THROW_ERR_INVALID_OBJECT_DEFINE_PROPERTY(env,
                                               ""'process.env' only accepts a ""
                                               ""configurable, writable,""...",420.0,457.0,1.0,1.0,38.0,11,4,8,4,0,0,3,4,0,0,,0,0,6,3,3,void
3554,158786,CreateEnvProxyTemplate,1,node.CreateEnvProxyTemplate,"void node.CreateEnvProxyTemplate (Isolate*,IsolateData*)",node_env_var.cc,"void CreateEnvProxyTemplate(Isolate* isolate, IsolateData* isolate_data) {
  HandleScope scope(isolate);
  if (!isolate_data->env_proxy_template().IsEmpty()) return;
  Local<FunctionTemplate> env_proxy_ctor_template =
      FunctionTemplate::New(isolate);
  Local<ObjectTemplate> env_proxy_template =
      ObjectTemplate::New(isolate, env_proxy_ctor_template);
  env_proxy_template->SetHandler(NamedPropertyHandlerConfiguration(
      EnvGetter,
      EnvSetter,
      EnvQuery,
      EnvDeleter,
      EnvEnumerator,
      EnvDefiner,
      nullptr,
      Local<Value>(),
      PropertyHandlerFlags::kHasNoSideEffect));
  isolate_data->set_env_proxy_template(env_proxy_template);
  isolate_data->set_env_proxy_ctor_template(env_proxy_ctor_template);
}",459.0,478.0,1.0,1.0,20.0,15,6,19,8,0,0,2,2,0,0,,0,0,4,2,2,void
3555,158855,RegisterEnvVarExternalReferences,1,node.RegisterEnvVarExternalReferences,void node.RegisterEnvVarExternalReferences (ExternalReferenceRegistry*),node_env_var.cc,"void RegisterEnvVarExternalReferences(ExternalReferenceRegistry* registry) {
  registry->Register(EnvGetter);
  registry->Register(EnvSetter);
  registry->Register(EnvQuery);
  registry->Register(EnvDeleter);
  registry->Register(EnvEnumerator);
  registry->Register(EnvDefiner);
}",480.0,487.0,1.0,1.0,8.0,6,1,6,1,0,0,1,1,0,0,,0,0,2,1,1,void
3556,158892,<lambda>0,1,node.ReportFatalException.<lambda>0,ANY node.ReportFatalException.<lambda>0 (),node_errors.cc,"[&]() {
#if HAVE_INSPECTOR
    env->inspector_agent()->ReportUncaughtException(error, message);
#endif
  }",376.0,380.0,30.0,3.0,5.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
3557,158898,<lambda>1,1,node.ReportFatalException.<lambda>1,ANY node.ReportFatalException.<lambda>1 (Local<Function>),node_errors.cc,"[&](Local<Function> enhancer) {
      Local<Value> enhanced;
      Local<Value> argv[] = {err_obj};
      if (!enhancer.IsEmpty() &&
          enhancer
              ->Call(env->context(), Undefined(isolate), arraysize(argv), argv)
              .ToLocal(&enhanced)) {
        stack_trace = enhanced;
      }
    }",396.0,405.0,25.0,5.0,10.0,12,9,14,9,0,0,2,2,0,0,,0,0,2,1,1,ANY
3558,158969,IsExceptionDecorated,1,node.IsExceptionDecorated,"bool node.IsExceptionDecorated (Environment*,Local<Value>)",node_errors.cc,"bool IsExceptionDecorated(Environment* env, Local<Value> er) {
  if (!er.IsEmpty() && er->IsObject()) {
    Local<Object> err_obj = er.As<Object>();
    auto maybe_value =
        err_obj->GetPrivate(env->context(), env->decorated_private_symbol());
    Local<Value> decorated;
    return maybe_value.ToLocal(&decorated) && decorated->IsTrue();
  }
  return false;
}",37.0,46.0,1.0,1.0,10.0,18,8,16,8,0,0,2,2,0,0,,0,0,4,2,2,bool
3559,159033,GetSourceMapErrorSource,1,node.GetSourceMapErrorSource,"string node.GetSourceMapErrorSource (Isolate*,Local<Context>,Local<Message>,bool*)",node_errors.cc,"static std::string GetSourceMapErrorSource(Isolate* isolate,
                                           Local<Context> context,
                                           Local<Message> message,
                                           bool* added_exception_line) {
  v8::TryCatch try_catch(isolate);
  HandleScope handle_scope(isolate);
  Environment* env = Environment::GetCurrent(context);

  // The ScriptResourceName of the message may be different from the one we use
  // to compile the script. V8 replaces it when it detects magic comments in
  // the source texts.
  Local<Value> script_resource_name = message->GetScriptResourceName();
  int linenum = message->GetLineNumber(context).FromJust();
  int columnum = message->GetStartColumn(context).FromJust();

  Local<Value> argv[] = {script_resource_name,
                         v8::Int32::New(isolate, linenum),
                         v8::Int32::New(isolate, columnum)};
  MaybeLocal<Value> maybe_ret = env->get_source_map_error_s...",52.0,84.0,1.0,1.0,33.0,37,9,46,20,0,0,3,3,0,0,,0,0,8,4,4,string
3560,159177,GetErrorSource,1,node.GetErrorSource,"string node.GetErrorSource (Isolate*,Local<Context>,Local<Message>,bool*)",node_errors.cc,"static std::string GetErrorSource(Isolate* isolate,
                                  Local<Context> context,
                                  Local<Message> message,
                                  bool* added_exception_line) {
  MaybeLocal<String> source_line_maybe = message->GetSourceLine(context);
  node::Utf8Value encoded_source(isolate, source_line_maybe.ToLocalChecked());
  std::string sourceline(*encoded_source, encoded_source.length());
  *added_exception_line = false;

  if (sourceline.find(""node-do-not-add-exception-line"") != std::string::npos) {
    return sourceline;
  }

  // If source maps have been enabled, the exception line will instead be
  // added in the JavaScript context:
  Environment* env = Environment::GetCurrent(isolate);
  const bool has_source_map_url =
      !message->GetScriptOrigin().SourceMapUrl().IsEmpty() &&
      !message->GetScriptOrigin().SourceMapUrl()->IsUndefined();
  if (has_source_map_url && env != nullptr && env->source_maps_enabled()) ...",86.0,186.0,1.0,1.0,101.0,94,19,104,27,0,0,12,13,0,0,,0,0,8,4,4,string
3561,159516,FormatStackTrace,1,node.FormatStackTrace,"string node.FormatStackTrace (Isolate*,Local<StackTrace>)",node_errors.cc,"static std::string FormatStackTrace(Isolate* isolate, Local<StackTrace> stack) {
  std::string result;
  for (int i = 0; i < stack->GetFrameCount(); i++) {
    Local<StackFrame> stack_frame = stack->GetFrame(isolate, i);
    node::Utf8Value fn_name_s(isolate, stack_frame->GetFunctionName());
    node::Utf8Value script_name(isolate, stack_frame->GetScriptName());
    const int line_number = stack_frame->GetLineNumber();
    const int column = stack_frame->GetColumn();

    if (stack_frame->IsEval()) {
      if (stack_frame->GetScriptId() == Message::kNoScriptIdInfo) {
        result += SPrintF(""    at [eval]:%i:%i\n"", line_number, column);
      } else {
        std::vector<char> buf(script_name.length() + 64);
        snprintf(buf.data(),
                 buf.size(),
                 ""    at [eval] (%s:%i:%i)\n"",
                 *script_name,
                 line_number,
                 column);
        result += std::string(buf.data());
      }
      break;
    }

    if (fn_nam...",188.0,235.0,1.0,1.0,48.0,28,9,34,14,0,0,6,9,0,0,,0,0,4,2,2,string
3562,159718,PrintToStderrAndFlush,1,node.PrintToStderrAndFlush,void node.PrintToStderrAndFlush (ANY),node_errors.cc,"static void PrintToStderrAndFlush(const std::string& str) {
  FPrintF(stderr, ""%s\n"", str);
  fflush(stderr);
}",237.0,240.0,1.0,1.0,4.0,0,0,2,2,0,0,1,1,0,0,,0,0,2,1,1,void
3563,159728,PrintStackTrace,1,node.PrintStackTrace,"void node.PrintStackTrace (Isolate*,Local<StackTrace>)",node_errors.cc,"void PrintStackTrace(Isolate* isolate, Local<StackTrace> stack) {
  PrintToStderrAndFlush(FormatStackTrace(isolate, stack));
}",242.0,244.0,1.0,1.0,3.0,0,0,2,2,0,0,1,1,0,0,,0,0,4,2,2,void
3564,159738,FormatCaughtException,1,node.FormatCaughtException,"string node.FormatCaughtException (Isolate*,Local<Context>,Local<Value>,Local<Message>,bool)",node_errors.cc,"std::string FormatCaughtException(Isolate* isolate,
                                  Local<Context> context,
                                  const v8::TryCatch& try_catch) {
  CHECK(try_catch.HasCaught());
  return FormatCaughtException(
      isolate, context, try_catch.Exception(), try_catch.Message());
}",268.0,274.0,1.0,1.0,7.0,18,9,23,12,0,0,3,3,0,0,,0,0,6,3,3,string
3565,159839,PrintCaughtException,1,node.PrintCaughtException,"void node.PrintCaughtException (Isolate*,Local<Context>,ANY)",node_errors.cc,"void PrintCaughtException(Isolate* isolate,
                          Local<Context> context,
                          const v8::TryCatch& try_catch) {
  PrintToStderrAndFlush(FormatCaughtException(isolate, context, try_catch));
}",276.0,280.0,1.0,1.0,5.0,0,0,3,3,0,0,1,1,0,0,,0,0,6,3,3,void
3566,159851,AppendExceptionLine,1,node.AppendExceptionLine,"void node.AppendExceptionLine (Environment*,Local<Value>,Local<Message>,ErrorHandlingMode)",node_errors.cc,"void AppendExceptionLine(Environment* env,
                         Local<Value> er,
                         Local<Message> message,
                         enum ErrorHandlingMode mode) {
  if (message.IsEmpty()) return;

  HandleScope scope(env->isolate());
  Local<Object> err_obj;
  if (!er.IsEmpty() && er->IsObject()) {
    err_obj = er.As<Object>();
    // If arrow_message is already set, skip.
    auto maybe_value = err_obj->GetPrivate(env->context(),
                                          env->arrow_message_private_symbol());
    Local<Value> lvalue;
    if (!maybe_value.ToLocal(&lvalue) || lvalue->IsString())
      return;
  }

  bool added_exception_line = false;
  std::string source = GetErrorSource(
      env->isolate(), env->context(), message, &added_exception_line);
  if (!added_exception_line) {
    return;
  }
  MaybeLocal<Value> arrow_str = ToV8Value(env->context(), source);

  const bool can_set_arrow = !arrow_str.IsEmpty() && !err_obj.IsEmpty();
  // If alloca...",282.0,329.0,1.0,1.0,48.0,51,10,47,18,0,0,7,9,0,0,,0,0,8,4,4,void
3567,160038,Abort,1,node.Abort,void node.Abort (),node_process_methods.cc,"static void Abort(const FunctionCallbackInfo<Value>& args) {
  Abort();
}",67.0,69.0,1.0,1.0,3.0,0,0,1,1,0,0,1,1,0,0,,0,0,2,1,1,void
3568,160046,Assert,1,node.Assert,void node.Assert (AssertionInfo),node_errors.cc,"[[noreturn]] void Assert(const AssertionInfo& info) {
  std::string name = GetHumanReadableProcessName();

  fprintf(stderr,
          ""%s: %s:%s%s Assertion `%s' failed.\n"",
          name.c_str(),
          info.file_line,
          info.function,
          *info.function ? "":"" : """",
          info.message);
  fflush(stderr);

  Abort();
}",337.0,350.0,1.0,1.0,14.0,8,4,7,3,0,0,1,1,0,0,,0,0,2,1,1,void
3569,160083,ReportFatalException,1,node.ReportFatalException,"void node.ReportFatalException (Environment*,Local<Value>,Local<Message>,EnhanceFatalException)",node_errors.cc,"static void ReportFatalException(Environment* env,
                                 Local<Value> error,
                                 Local<Message> message,
                                 EnhanceFatalException enhance_stack) {
  if (!env->can_call_into_js())
    enhance_stack = EnhanceFatalException::kDontEnhance;

  Isolate* isolate = env->isolate();
  CHECK(!error.IsEmpty());
  CHECK(!message.IsEmpty());
  HandleScope scope(isolate);

  AppendExceptionLine(env, error, message, FATAL_ERROR);

  auto report_to_inspector = [&]() {
#if HAVE_INSPECTOR
    env->inspector_agent()->ReportUncaughtException(error, message);
#endif
  };

  Local<Value> arrow;
  Local<Value> stack_trace;
  bool decorated = IsExceptionDecorated(env, error);

  if (!error->IsObject()) {  // We can only enhance actual errors.
    report_to_inspector();
    stack_trace = Undefined(isolate);
    // If error is not an object, AppendExceptionLine() has already print the
    // source line and the arrow to stde...",362.0,505.0,1.0,1.0,144.0,46,8,51,18,0,1,9,11,0,0,,0,1,8,4,4,void
3570,160627,OOMErrorHandler,1,node.OOMErrorHandler,"void node.OOMErrorHandler (char*,ANY)",node_errors.cc,"[[noreturn]] void OOMErrorHandler(const char* location,
                                  const v8::OOMDetails& details) {
  const char* message =
      details.is_heap_oom ? ""Allocation failed - JavaScript heap out of memory""
                          : ""Allocation failed - process out of memory"";
  if (location) {
    FPrintF(stderr, ""FATAL ERROR: %s %s\n"", location, message);
  } else {
    FPrintF(stderr, ""FATAL ERROR: %s\n"", message);
  }

  Isolate* isolate = Isolate::TryGetCurrent();
  bool report_on_fatalerror;
  {
    Mutex::ScopedLock lock(node::per_process::cli_options_mutex);
    report_on_fatalerror = per_process::cli_options->report_on_fatalerror;
  }

  if (report_on_fatalerror) {
    // Trigger report with the isolate. Environment::GetCurrent may return
    // nullptr here:
    // - If the OOM is reported by a young generation space allocation,
    //   Isolate::GetCurrentContext returns an empty handle.
    // - Otherwise, Isolate::GetCurrentContext returns a non-em...",529.0,558.0,1.0,1.0,30.0,10,4,15,9,0,0,3,3,0,0,,0,0,4,2,2,void
3571,160690,ModifyCodeGenerationFromStrings,1,node.ModifyCodeGenerationFromStrings,"ModifyCodeGenerationFromStringsResult node.ModifyCodeGenerationFromStrings (ANY,ANY,bool)",node_errors.cc,"v8::ModifyCodeGenerationFromStringsResult ModifyCodeGenerationFromStrings(
    v8::Local<v8::Context> context,
    v8::Local<v8::Value> source,
    bool is_code_like) {
  HandleScope scope(context->GetIsolate());

  Environment* env = Environment::GetCurrent(context);
  if (env->source_maps_enabled()) {
    // We do not expect the maybe_cache_generated_source_map to throw any more
    // exceptions. If it does, just ignore it.
    errors::TryCatchScope try_catch(env);
    Local<Function> maybe_cache_source_map =
        env->maybe_cache_generated_source_map();
    Local<Value> argv[1] = {source};

    MaybeLocal<Value> maybe_cached = maybe_cache_source_map->Call(
        context, context->Global(), arraysize(argv), argv);
    if (maybe_cached.IsEmpty()) {
      DCHECK(try_catch.HasCaught());
    }
  }

  Local<Value> allow_code_gen = context->GetEmbedderData(
      ContextEmbedderIndex::kAllowCodeGenerationFromStrings);
  bool codegen_allowed =
      allow_code_gen->IsUndefined() ||...",560.0,590.0,1.0,1.0,31.0,28,7,31,14,0,0,3,4,0,0,,0,0,6,3,3,ModifyCodeGenerationFromStringsResult
3572,160794,~TryCatchScope,1,node.errors.TryCatchScope.~TryCatchScope,ANY node.errors.TryCatchScope.~TryCatchScope (),node_errors.cc,"TryCatchScope::~TryCatchScope() {
  if (HasCaught() && !HasTerminated() && mode_ == CatchMode::kFatal) {
    HandleScope scope(env_->isolate());
    Local<v8::Value> exception = Exception();
    Local<v8::Message> message = Message();
    EnhanceFatalException enhance = CanContinue() ?
        EnhanceFatalException::kEnhance : EnhanceFatalException::kDontEnhance;
    if (message.IsEmpty())
      message = Exception::CreateMessage(env_->isolate(), exception);
    ReportFatalException(env_, exception, message, enhance);
    env_->Exit(ExitCode::kExceptionInFatalExceptionHandler);
  }
}",594.0,606.0,1.0,1.0,13.0,24,9,23,11,0,2,3,4,0,0,,0,2,0,0,0,ANY
3573,160874,errno_string,1,node.errors.errno_string,const char* node.errors.errno_string (int),node_errors.cc,"const char* errno_string(int errorno) {
#define ERRNO_CASE(e)                                                          \
  case e:                                                                      \
    return #e;
  switch (errorno) {
#ifdef EACCES
    ERRNO_CASE(EACCES);
#endif

#ifdef EADDRINUSE
    ERRNO_CASE(EADDRINUSE);
#endif

#ifdef EADDRNOTAVAIL
    ERRNO_CASE(EADDRNOTAVAIL);
#endif

#ifdef EAFNOSUPPORT
    ERRNO_CASE(EAFNOSUPPORT);
#endif

#ifdef EAGAIN
    ERRNO_CASE(EAGAIN);
#endif

#ifdef EWOULDBLOCK
#if EAGAIN != EWOULDBLOCK
    ERRNO_CASE(EWOULDBLOCK);
#endif
#endif

#ifdef EALREADY
    ERRNO_CASE(EALREADY);
#endif

#ifdef EBADF
    ERRNO_CASE(EBADF);
#endif

#ifdef EBADMSG
    ERRNO_CASE(EBADMSG);
#endif

#ifdef EBUSY
    ERRNO_CASE(EBUSY);
#endif

#ifdef ECANCELED
    ERRNO_CASE(ECANCELED);
#endif

#ifdef ECHILD
    ERRNO_CASE(ECHILD);
#endif

#ifdef ECONNABORTED
    ERRNO_CASE(ECONNABORTED);
#endif

#ifdef ECONNREFUSED
    ERRNO_CASE(ECONNREFUSED);
#endif

#ifdef...",608.0,934.0,1.0,1.0,327.0,0,0,1,1,0,0,2,2,0,0,,0,0,2,1,1,const char*
3574,160885,PerIsolateMessageListener,1,node.errors.PerIsolateMessageListener,"void node.errors.PerIsolateMessageListener (Local<Message>,Local<Value>)",node_errors.cc,"void PerIsolateMessageListener(Local<Message> message, Local<Value> error) {
  Isolate* isolate = message->GetIsolate();
  switch (message->ErrorLevel()) {
    case Isolate::MessageErrorLevel::kMessageWarning: {
      Environment* env = Environment::GetCurrent(isolate);
      if (!env) {
        break;
      }
      Utf8Value filename(isolate, message->GetScriptOrigin().ResourceName());
      // (filename):(line) (message)
      std::stringstream warning;
      warning << *filename;
      warning << "":"";
      warning << message->GetLineNumber(env->context()).FromMaybe(-1);
      warning << "" "";
      v8::String::Utf8Value msg(isolate, message->Get());
      warning << *msg;
      USE(ProcessEmitWarningGeneric(env, warning.str().c_str(), ""V8""));
      break;
    }
    case Isolate::MessageErrorLevel::kMessageError:
      TriggerUncaughtException(isolate, error, message);
      break;
  }
}",936.0,960.0,1.0,1.0,25.0,26,7,29,10,0,0,6,4,0,0,,0,0,4,2,2,void
3575,160994,SetPrepareStackTraceCallback,1,node.errors.SetPrepareStackTraceCallback,void node.errors.SetPrepareStackTraceCallback (FunctionCallbackInfo<Value>),node_errors.cc,"void SetPrepareStackTraceCallback(const FunctionCallbackInfo<Value>& args) {
  Realm* realm = Realm::GetCurrent(args);
  CHECK(args[0]->IsFunction());
  realm->set_prepare_stack_trace_callback(args[0].As<Function>());
}",962.0,966.0,1.0,1.0,5.0,7,4,6,3,0,0,1,1,0,0,,0,0,2,1,1,void
3576,161024,SetSourceMapsEnabled,1,node.errors.SetSourceMapsEnabled,void node.errors.SetSourceMapsEnabled (FunctionCallbackInfo<Value>),node_errors.cc,"static void SetSourceMapsEnabled(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  CHECK(args[0]->IsBoolean());
  env->set_source_maps_enabled(args[0].As<Boolean>()->Value());
}",968.0,972.0,1.0,1.0,5.0,8,4,6,3,0,0,1,1,0,0,,0,0,2,1,1,void
3577,161057,SetGetSourceMapErrorSource,1,node.errors.SetGetSourceMapErrorSource,void node.errors.SetGetSourceMapErrorSource (FunctionCallbackInfo<Value>),node_errors.cc,"static void SetGetSourceMapErrorSource(
    const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  CHECK(args[0]->IsFunction());
  env->set_get_source_map_error_source(args[0].As<Function>());
}",974.0,979.0,1.0,1.0,6.0,7,4,6,3,0,0,1,1,0,0,,0,0,2,1,1,void
3578,161087,SetMaybeCacheGeneratedSourceMap,1,node.errors.SetMaybeCacheGeneratedSourceMap,void node.errors.SetMaybeCacheGeneratedSourceMap (FunctionCallbackInfo<Value>),node_errors.cc,"static void SetMaybeCacheGeneratedSourceMap(
    const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  CHECK(args[0]->IsFunction());
  env->set_maybe_cache_generated_source_map(args[0].As<Function>());
}",981.0,986.0,1.0,1.0,6.0,7,4,6,3,0,0,1,1,0,0,,0,0,2,1,1,void
3579,161117,SetEnhanceStackForFatalException,1,node.errors.SetEnhanceStackForFatalException,void node.errors.SetEnhanceStackForFatalException (FunctionCallbackInfo<Value>),node_errors.cc,"static void SetEnhanceStackForFatalException(
    const FunctionCallbackInfo<Value>& args) {
  Realm* realm = Realm::GetCurrent(args);
  CHECK(args[0]->IsFunction());
  CHECK(args[1]->IsFunction());
  realm->set_enhance_fatal_stack_before_inspector(args[0].As<Function>());
  realm->set_enhance_fatal_stack_after_inspector(args[1].As<Function>());
}",988.0,995.0,1.0,1.0,8.0,12,4,9,3,0,0,1,1,0,0,,0,0,2,1,1,void
3580,161164,NoSideEffectsToString,1,node.errors.NoSideEffectsToString,void node.errors.NoSideEffectsToString (FunctionCallbackInfo<Value>),node_errors.cc,"static void NoSideEffectsToString(const FunctionCallbackInfo<Value>& args) {
  Local<Context> context = args.GetIsolate()->GetCurrentContext();
  Local<String> detail_string;
  if (args[0]->ToDetailString(context).ToLocal(&detail_string))
    args.GetReturnValue().Set(detail_string);
}",998.0,1003.0,1.0,1.0,6.0,13,7,12,6,0,0,2,2,0,0,,0,0,2,1,1,void
3581,161209,TriggerUncaughtException,1,node.errors.TriggerUncaughtException,void node.errors.TriggerUncaughtException (FunctionCallbackInfo<Value>),node_errors.cc,"void TriggerUncaughtException(Isolate* isolate, const v8::TryCatch& try_catch) {
  // If the try_catch is verbose, the per-isolate message listener is going to
  // handle it (which is going to call into another overload of
  // TriggerUncaughtException()).
  if (try_catch.IsVerbose()) {
    return;
  }

  // If the user calls TryCatch::TerminateExecution() on this TryCatch
  // they must call CancelTerminateExecution() again before invoking
  // TriggerUncaughtException() because it will invoke
  // process._fatalException() in the JS land.
  CHECK(!try_catch.HasTerminated());
  CHECK(try_catch.HasCaught());
  HandleScope scope(isolate);
  TriggerUncaughtException(isolate,
                           try_catch.Exception(),
                           try_catch.Message(),
                           false /* from_promise */);
}",1191.0,1210.0,1.0,1.0,20.0,20,8,28,13,1,1,2,2,0,0,,0,1,4,2,2,void
3582,161285,RegisterExternalReferences,1,node.errors.RegisterExternalReferences,void node.errors.RegisterExternalReferences (ExternalReferenceRegistry*),node_errors.cc,"void RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  registry->Register(SetPrepareStackTraceCallback);
  registry->Register(SetGetSourceMapErrorSource);
  registry->Register(SetSourceMapsEnabled);
  registry->Register(SetMaybeCacheGeneratedSourceMap);
  registry->Register(SetEnhanceStackForFatalException);
  registry->Register(NoSideEffectsToString);
  registry->Register(TriggerUncaughtException);
}",1019.0,1027.0,1.0,1.0,9.0,7,1,7,1,0,0,1,1,0,0,,0,0,2,1,1,void
3583,161325,Initialize,1,node.errors.Initialize,"void node.errors.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)",node_errors.cc,"void Initialize(Local<Object> target,
                Local<Value> unused,
                Local<Context> context,
                void* priv) {
  SetMethod(context,
            target,
            ""setPrepareStackTraceCallback"",
            SetPrepareStackTraceCallback);
  SetMethod(context,
            target,
            ""setGetSourceMapErrorSource"",
            SetGetSourceMapErrorSource);
  SetMethod(context, target, ""setSourceMapsEnabled"", SetSourceMapsEnabled);
  SetMethod(context,
            target,
            ""setMaybeCacheGeneratedSourceMap"",
            SetMaybeCacheGeneratedSourceMap);
  SetMethod(context,
            target,
            ""setEnhanceStackForFatalException"",
            SetEnhanceStackForFatalException);
  SetMethodNoSideEffect(
      context, target, ""noSideEffectsToString"", NoSideEffectsToString);
  SetMethod(
      context, target, ""triggerUncaughtException"", TriggerUncaughtException);

  Isolate* isolate = context->GetIsolate();
  Local<Object> exit_...",1029.0,1065.0,1.0,1.0,37.0,6,5,23,6,0,0,1,1,0,0,,0,0,8,4,4,void
3584,161392,DecorateErrorStack,1,node.errors.DecorateErrorStack,"void node.errors.DecorateErrorStack (Environment*,ANY)",node_errors.cc,"void DecorateErrorStack(Environment* env,
                        const errors::TryCatchScope& try_catch) {
  Local<Value> exception = try_catch.Exception();

  if (!exception->IsObject()) return;

  Local<Object> err_obj = exception.As<Object>();

  if (IsExceptionDecorated(env, err_obj)) return;

  AppendExceptionLine(env, exception, try_catch.Message(), CONTEXTIFY_ERROR);
  TryCatchScope try_catch_scope(env);  // Ignore exceptions below.
  MaybeLocal<Value> stack = err_obj->Get(env->context(), env->stack_string());
  MaybeLocal<Value> maybe_value =
      err_obj->GetPrivate(env->context(), env->arrow_message_private_symbol());

  Local<Value> arrow;
  if (!(maybe_value.ToLocal(&arrow) && arrow->IsString())) {
    return;
  }

  if (stack.IsEmpty() || !stack.ToLocalChecked()->IsString()) {
    return;
  }

  Local<String> decorated_stack = String::Concat(
      env->isolate(),
      String::Concat(env->isolate(),
                     arrow.As<String>(),
                     FIXED_...",1067.0,1101.0,1.0,1.0,35.0,53,9,54,14,0,0,5,5,0,0,,0,0,4,2,2,void
3585,161843,~PrinterTryCatch,1,node.errors.PrinterTryCatch.~PrinterTryCatch,ANY node.errors.PrinterTryCatch.~PrinterTryCatch (),node_errors.cc,"PrinterTryCatch::~PrinterTryCatch() {
  if (!HasCaught()) {
    return;
  }
  std::string str =
      FormatCaughtException(isolate_,
                            isolate_->GetCurrentContext(),
                            Exception(),
                            Message(),
                            print_source_line_ == kPrintSourceLine);
  PrintToStderrAndFlush(str);
}",1212.0,1223.0,1.0,1.0,12.0,4,4,6,4,0,0,2,2,0,0,,0,0,0,0,0,ANY
3586,161903,external_references,1,node.ExternalReferenceRegistry.external_references,vector<intptr_t> node.ExternalReferenceRegistry.external_references (),node_external_reference.cc,"const std::vector<intptr_t>& ExternalReferenceRegistry::external_references() {
  if (!is_finalized_) {
    external_references_.push_back(reinterpret_cast<intptr_t>(nullptr));
    is_finalized_ = true;
  }

  return external_references_;
}",9.0,16.0,1.0,1.0,8.0,4,4,4,2,0,0,2,2,0,0,,0,0,0,0,0,vector<intptr_t>
3587,161923,ExternalReferenceRegistry,1,node.ExternalReferenceRegistry.ExternalReferenceRegistry,ANY node.ExternalReferenceRegistry.ExternalReferenceRegistry (),node_external_reference.cc,"ExternalReferenceRegistry::ExternalReferenceRegistry() {
  this->Register(BaseObject::LazilyInitializedJSTemplateConstructor);

#define V(modname) _register_external_reference_##modname(this);
  EXTERNAL_REFERENCE_BINDING_LIST(V)
#undef V
  // TODO(joyeecheung): collect more external references here.
}",18.0,25.0,1.0,1.0,8.0,2,2,1,1,0,0,1,1,0,0,,0,0,0,0,0,ANY
3588,161959,<lambda>0,1,node.fs.FileHandle.Close.<lambda>0,ANY node.fs.FileHandle.Close.<lambda>0 (Environment*),node_file.cc,"[detail](Environment* env) {
      char msg[70];
      snprintf(msg, arraysize(msg),
              ""Closing file descriptor %d on garbage collection failed"",
              detail.fd);
      // This exception will end up being fatal for the process because
      // it is being thrown from within the SetImmediate handler and
      // there is no JS stack to bubble it to. In other words, tearing
      // down the process is the only reasonable thing we can do here.
      HandleScope handle_scope(env->isolate());
      env->ThrowUVException(detail.ret, ""close"", msg);
    }",359.0,370.0,25.0,5.0,12.0,4,2,7,3,0,0,1,1,0,0,,0,0,2,1,1,ANY
3589,161991,<lambda>1,1,node.fs.FileHandle.Close.<lambda>1,ANY node.fs.FileHandle.Close.<lambda>1 (Environment*),node_file.cc,"[detail](Environment* env) {
    ProcessEmitWarning(env,
                       ""Closing file descriptor %d on garbage collection"",
                       detail.fd);
    if (env->filehandle_close_warning()) {
      env->set_filehandle_close_warning(false);
      USE(ProcessEmitDeprecationWarning(
          env,
          ""Closing a FileHandle object on garbage collection is deprecated. ""
          ""Please close FileHandle objects explicitly using ""
          ""FileHandle.prototype.close(). In the future, an error will be ""
          ""thrown if a file descriptor is closed during garbage collection."",
          ""DEP0137""));
    }
  }",378.0,392.0,23.0,3.0,15.0,3,2,5,2,0,0,2,2,0,0,,0,0,2,1,1,ANY
3590,162019,<lambda>2,1,node.fs.FileHandle.ClosePromise.<lambda>2,ANY node.fs.FileHandle.ClosePromise.<lambda>2 (uv_fs_t*),node_file.cc,"[](uv_fs_t* req) {
    CloseReq* req_wrap = CloseReq::from_req(req);
    FS_ASYNC_TRACE_END1(
        req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))
    BaseObjectPtr<CloseReq> close(req_wrap);
    CHECK(close);
    close->file_handle()->AfterClose();
    if (!close->env()->can_call_into_js()) return;
    Isolate* isolate = close->env()->isolate();
    if (req->result < 0) {
      HandleScope handle_scope(isolate);
      close->Reject(
          UVException(isolate, static_cast<int>(req->result), ""close""));
    } else {
      close->Resolve();
    }
  }",480.0,496.0,38.0,4.0,17.0,50,13,46,15,0,0,3,3,0,0,,0,0,2,1,1,ANY
3591,162211,<lambda>3,1,node.fs.FileHandle.ReadStart.<lambda>3,ANY node.fs.FileHandle.ReadStart.<lambda>3 (uv_fs_t*),node_file.cc,"[](uv_fs_t* req) {
    FileHandle* handle;
    {
      FileHandleReadWrap* req_wrap = FileHandleReadWrap::from_req(req);
      FS_ASYNC_TRACE_END1(
          req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))
      handle = req_wrap->file_handle_;
      CHECK_EQ(handle->current_read_.get(), req_wrap);
    }

    // ReadStart() checks whether current_read_ is set to determine whether
    // a read is in progress. Moving it into a local variable makes sure that
    // the ReadStart() call below doesn't think we're still actively reading.
    BaseObjectPtr<FileHandleReadWrap> read_wrap =
        std::move(handle->current_read_);

    ssize_t result = req->result;
    uv_buf_t buffer = read_wrap->buffer_;

    uv_fs_req_cleanup(req);

    // Push the read wrap back to the freelist, or let it be destroyed
    // once were exiting the current scope.
    constexpr size_t kWantedFreelistFill = 100;
    auto& freelist = handle->binding_data_->file_handle_read_wrap_freelist;
  ...",605.0,660.0,44.0,6.0,56.0,78,18,77,21,0,0,8,11,0,0,,0,0,2,1,1,ANY
3592,162484,<lambda>4,1,node.fs.FileHandle.DoShutdown.<lambda>4,ANY node.fs.FileHandle.DoShutdown.<lambda>4 (uv_fs_t*),node_file.cc,"[](uv_fs_t* req) {
    FileHandleCloseWrap* wrap = static_cast<FileHandleCloseWrap*>(
        FileHandleCloseWrap::from_req(req));
    FS_ASYNC_TRACE_END1(
        req->fs_type, wrap, ""result"", static_cast<int>(req->result))
    FileHandle* handle = static_cast<FileHandle*>(wrap->stream());
    handle->AfterClose();

    int result = static_cast<int>(req->result);
    uv_fs_req_cleanup(req);
    wrap->Done(result);
  }",685.0,696.0,53.0,4.0,12.0,44,11,42,14,0,0,1,1,0,0,,0,0,2,1,1,ANY
3593,162642,<lambda>5,1,node.fs.InternalModuleReadJSON.<lambda>5,ANY node.fs.InternalModuleReadJSON.<lambda>5 (),node_file.cc,"[fd, loop]() {
    uv_fs_t close_req;
    CHECK_EQ(0, uv_fs_close(loop, &close_req, fd, nullptr));
    uv_fs_req_cleanup(&close_req);
  }",1047.0,1051.0,35.0,3.0,5.0,2,1,4,3,0,0,1,1,0,0,,0,0,0,0,0,ANY
3594,162661,<lambda>7,1,node.fs.MKDirpAsync..<lambda>7,ANY node.fs.MKDirpAsync..<lambda>7 (uv_fs_t*),node_file.cc,"[](uv_fs_t* req) {
            FSReqBase* req_wrap = FSReqBase::from_req(req);
            int err = static_cast<int>(req->result);
            if (reinterpret_cast<intptr_t>(req->data) == UV_EEXIST &&
                  req_wrap->continuation_data()->paths().size() > 0) {
              if (err == 0 && S_ISDIR(req->statbuf.st_mode)) {
                Environment* env = req_wrap->env();
                uv_loop_t* loop = env->event_loop();
                std::string path = req->path;
                uv_fs_req_cleanup(req);
                MKDirpAsync(loop, req, path.c_str(),
                            req_wrap->continuation_data()->mode(), nullptr);
                return;
              }
              err = UV_ENOTDIR;
            }
            // verify that the path pointed to is actually a directory.
            if (err == 0 && !S_ISDIR(req->statbuf.st_mode)) err = UV_EEXIST;
            req_wrap->continuation_data()->Done(err);
          }",1722.0,1741.0,49.0,30.0,20.0,43,9,35,11,0,0,4,5,0,0,,0,0,2,1,1,ANY
3595,162803,<lambda>6,1,node.fs.MKDirpAsync.<lambda>6,ANY node.fs.MKDirpAsync.<lambda>6 (uv_fs_t*),node_file.cc,"[](uv_fs_t* req) {
    FSReqBase* req_wrap = FSReqBase::from_req(req);
    Environment* env = req_wrap->env();
    uv_loop_t* loop = env->event_loop();
    std::string path = req->path;
    int err = static_cast<int>(req->result);

    while (true) {
      switch (err) {
        // Note: uv_fs_req_cleanup in terminal paths will be called by
        // FSReqAfterScope::~FSReqAfterScope()
        case 0: {
          if (req_wrap->continuation_data()->paths().size() == 0) {
            req_wrap->continuation_data()->MaybeSetFirstPath(path);
            req_wrap->continuation_data()->Done(0);
          } else {
            req_wrap->continuation_data()->MaybeSetFirstPath(path);
            uv_fs_req_cleanup(req);
            MKDirpAsync(loop, req, path.c_str(),
                        req_wrap->continuation_data()->mode(), nullptr);
          }
          break;
        }
        case UV_EACCES:
        case UV_ENOTDIR:
        case UV_EPERM: {
          req_wrap->continuation_data()->Do...",1673.0,1747.0,42.0,30.0,75.0,43,8,48,14,0,0,11,13,0,0,,0,0,2,1,1,ANY
3596,163100,Basename,1,node.fs.Basename,"string node.fs.Basename (ANY,ANY)",node_file.cc,"std::string Basename(const std::string& str, const std::string& extension) {
  // Remove everything leading up to and including the final path separator.
  std::string::size_type pos = str.find_last_of(kPathSeparator);

  // Starting index for the resulting string
  std::size_t start_pos = 0;
  // String size to return
  std::size_t str_size = str.size();
  if (pos != std::string::npos) {
    start_pos = pos + 1;
    str_size -= start_pos;
  }

  // Strip away the extension, if any.
  if (str_size >= extension.size() &&
      str.compare(str.size() - extension.size(),
        extension.size(), extension) == 0) {
    str_size -= extension.size();
  }

  return str.substr(start_pos, str_size);
}",90.0,111.0,1.0,1.0,22.0,23,9,25,8,0,0,3,3,0,0,,0,0,4,2,2,string
3597,163184,GetOffset,1,node.fs.GetOffset,int64_t node.fs.GetOffset (Local<Value>),node_file.cc,"inline int64_t GetOffset(Local<Value> value) {
  return IsSafeJsInt(value) ? value.As<Integer>()->Value() : -1;
}",113.0,115.0,1.0,1.0,3.0,4,4,2,1,0,0,1,1,0,0,,0,0,2,1,1,int64_t
3598,163202,get_fs_func_name_by_type,1,node.fs.get_fs_func_name_by_type,const char* node.fs.get_fs_func_name_by_type (uv_fs_type),node_file.cc,"static const char* get_fs_func_name_by_type(uv_fs_type req_type) {
  switch (req_type) {
#define FS_TYPE_TO_NAME(type, name)                                            \
  case UV_FS_##type:                                                           \
    return name;
    FS_TYPE_TO_NAME(OPEN, ""open"")
    FS_TYPE_TO_NAME(CLOSE, ""close"")
    FS_TYPE_TO_NAME(READ, ""read"")
    FS_TYPE_TO_NAME(WRITE, ""write"")
    FS_TYPE_TO_NAME(SENDFILE, ""sendfile"")
    FS_TYPE_TO_NAME(STAT, ""stat"")
    FS_TYPE_TO_NAME(LSTAT, ""lstat"")
    FS_TYPE_TO_NAME(FSTAT, ""fstat"")
    FS_TYPE_TO_NAME(FTRUNCATE, ""ftruncate"")
    FS_TYPE_TO_NAME(UTIME, ""utime"")
    FS_TYPE_TO_NAME(FUTIME, ""futime"")
    FS_TYPE_TO_NAME(ACCESS, ""access"")
    FS_TYPE_TO_NAME(CHMOD, ""chmod"")
    FS_TYPE_TO_NAME(FCHMOD, ""fchmod"")
    FS_TYPE_TO_NAME(FSYNC, ""fsync"")
    FS_TYPE_TO_NAME(FDATASYNC, ""fdatasync"")
    FS_TYPE_TO_NAME(UNLINK, ""unlink"")
    FS_TYPE_TO_NAME(RMDIR, ""rmdir"")
    FS_TYPE_TO_NAME(MKDIR, ""mkdir"")
    FS_TYPE_TO_NAME(M...",117.0,159.0,1.0,4.0,43.0,0,0,34,34,0,0,2,2,0,0,,0,0,2,1,1,const char*
3599,163411,uv_fs_callback_t,1,node.fs.uv_fs_callback_t,void node.fs.uv_fs_callback_t (uv_fs_t*),node_file.cc,typedef void(*uv_fs_callback_t)(uv_fs_t*);,219.0,219.0,13.0,41.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
3600,163416,MemoryInfo,1,node.fs.FSContinuationData.MemoryInfo,void node.fs.FSContinuationData.MemoryInfo (MemoryTracker*),node_file.cc,"void FSContinuationData::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackField(""paths"", paths_);
}",222.0,224.0,1.0,1.0,3.0,1,1,2,2,0,0,1,1,0,0,,0,0,2,1,1,void
3601,163427,~FileHandleReadWrap,1,node.fs.FileHandleReadWrap.~FileHandleReadWrap,ANY node.fs.FileHandleReadWrap.~FileHandleReadWrap (),node_file.cc,FileHandleReadWrap::~FileHandleReadWrap() = default;,226.0,226.0,1.0,52.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
3602,163431,~FSReqBase,1,node.fs.FSReqBase.~FSReqBase,ANY node.fs.FSReqBase.~FSReqBase (),node_file.cc,FSReqBase::~FSReqBase() = default;,228.0,228.0,1.0,34.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
3603,163435,MemoryInfo,1,node.fs.FSReqBase.MemoryInfo,void node.fs.FSReqBase.MemoryInfo (MemoryTracker*),node_file.cc,"void FSReqBase::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackField(""continuation_data"", continuation_data_);
}",230.0,232.0,1.0,1.0,3.0,1,1,2,2,0,0,1,1,0,0,,0,0,2,1,1,void
3604,163446,FileHandle,1,node.fs.FileHandle.FileHandle,"ANY node.fs.FileHandle.FileHandle (BindingData*,Local<Object>,int)",node_file.cc,"FileHandle::FileHandle(BindingData* binding_data,
                       Local<Object> obj, int fd)
    : AsyncWrap(binding_data->env(), obj, AsyncWrap::PROVIDER_FILEHANDLE),
      StreamBase(env()),
      fd_(fd),
      binding_data_(binding_data) {
  MakeWeak();
  StreamBase::AttachToObject(GetObject());
}",237.0,245.0,1.0,1.0,9.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,ANY
3605,163455,New,1,node.fs.FileHandle.New,"FileHandle node.fs.FileHandle.New (BindingData*,int,Local<Object>,ANY,ANY)",node_file.cc,"void FileHandle::New(const FunctionCallbackInfo<Value>& args) {
  BindingData* binding_data = Realm::GetBindingData<BindingData>(args);
  Environment* env = binding_data->env();
  CHECK(args.IsConstructCall());
  CHECK(args[0]->IsInt32());

  std::optional<int64_t> maybeOffset = std::nullopt;
  std::optional<int64_t> maybeLength = std::nullopt;
  if (args[1]->IsNumber())
    maybeOffset = args[1]->IntegerValue(env->context()).FromJust();
  if (args[2]->IsNumber())
    maybeLength = args[2]->IntegerValue(env->context()).FromJust();

  FileHandle::New(binding_data,
                  args[0].As<Int32>()->Value(),
                  args.This(),
                  maybeOffset,
                  maybeLength);
}",264.0,282.0,1.0,1.0,19.0,20,7,18,8,0,0,4,4,0,0,,0,0,2,1,1,void
3606,163657,~FileHandle,1,node.fs.FileHandle.~FileHandle,ANY node.fs.FileHandle.~FileHandle (),node_file.cc,"FileHandle::~FileHandle() {
  CHECK(!closing_);  // We should not be deleting while explicitly closing!
  Close();           // Close synchronously and emit warning
  CHECK(closed_);    // We have to be closed at the point
}",284.0,288.0,1.0,1.0,5.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,ANY
3607,163666,DoWrite,1,node.fs.FileHandle.DoWrite,"int node.fs.FileHandle.DoWrite (WriteWrap*,uv_buf_t*,size_t,uv_stream_t*)",node_file.cc,"int FileHandle::DoWrite(WriteWrap* w,
                        uv_buf_t* bufs,
                        size_t count,
                        uv_stream_t* send_handle) {
  return UV_ENOSYS;  // Not implemented (yet).
}",290.0,295.0,1.0,1.0,6.0,0,0,1,1,0,0,1,1,0,0,,0,0,8,4,4,int
3608,163676,MemoryInfo,1,node.fs.FileHandle.MemoryInfo,void node.fs.FileHandle.MemoryInfo (MemoryTracker*),node_file.cc,"void FileHandle::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackField(""current_read"", current_read_);
}",297.0,299.0,1.0,1.0,3.0,1,1,2,2,0,0,1,1,0,0,,0,0,2,1,1,void
3609,163687,GetTransferMode,1,node.fs.FileHandle.GetTransferMode,TransferMode node.fs.FileHandle.GetTransferMode (),node_file.cc,"FileHandle::TransferMode FileHandle::GetTransferMode() const {
  return reading_ || closing_ || closed_ ?
      TransferMode::kUntransferable : TransferMode::kTransferable;
}",301.0,304.0,1.0,1.0,4.0,5,3,5,4,0,0,1,1,0,0,,0,0,0,0,0,TransferMode
3610,163704,TransferForMessaging,1,node.fs.FileHandle.TransferForMessaging,unique_ptr<worker::TransferData> node.fs.FileHandle.TransferForMessaging (),node_file.cc,"std::unique_ptr<worker::TransferData> FileHandle::TransferForMessaging() {
  CHECK_NE(GetTransferMode(), TransferMode::kUntransferable);
  auto ret = std::make_unique<TransferData>(fd_);
  closed_ = true;
  return ret;
}",306.0,311.0,1.0,1.0,6.0,6,4,7,6,0,0,1,1,0,0,,0,0,0,0,0,unique_ptr<worker.TransferData>
3611,163728,TransferData,1,node.fs.FileHandle.TransferData.TransferData,ANY node.fs.FileHandle.TransferData.TransferData (int),node_file.cc,FileHandle::TransferData::TransferData(int fd) : fd_(fd) {},313.0,313.0,1.0,59.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
3612,163733,~TransferData,1,node.fs.FileHandle.TransferData.~TransferData,ANY node.fs.FileHandle.TransferData.~TransferData (),node_file.cc,"FileHandle::TransferData::~TransferData() {
  if (fd_ > 0) {
    uv_fs_t close_req;
    CHECK_NE(fd_, -1);
    FS_SYNC_TRACE_BEGIN(close);
    CHECK_EQ(0, uv_fs_close(nullptr, &close_req, fd_, nullptr));
    FS_SYNC_TRACE_END(close);
    uv_fs_req_cleanup(&close_req);
  }
}",315.0,324.0,1.0,4.0,10.0,62,12,63,12,0,0,2,2,0,0,,0,0,0,0,0,ANY
3613,163950,Deserialize,1,node.fs.FileHandle.TransferData.Deserialize,"BaseObjectPtr<BaseObject> node.fs.FileHandle.TransferData.Deserialize (Environment*,ANY,ANY)",node_file.cc,"BaseObjectPtr<BaseObject> FileHandle::TransferData::Deserialize(
    Environment* env,
    v8::Local<v8::Context> context,
    std::unique_ptr<worker::TransferData> self) {
  BindingData* bd = Realm::GetBindingData<BindingData>(context);
  if (bd == nullptr) return {};

  int fd = fd_;
  fd_ = -1;
  return BaseObjectPtr<BaseObject> { FileHandle::New(bd, fd) };
}",326.0,336.0,1.0,1.0,11.0,10,7,11,7,0,0,2,2,0,0,,0,0,6,3,3,BaseObjectPtr<BaseObject>
3614,163990,Close,1,node.fs.FileHandle.Close,void node.fs.FileHandle.Close (),node_file.cc,"void FileHandle::Close(const FunctionCallbackInfo<Value>& args) {
  FileHandle* fd;
  ASSIGN_OR_RETURN_UNWRAP(&fd, args.Holder());
  Local<Promise> ret;
  if (!fd->ClosePromise().ToLocal(&ret)) return;
  args.GetReturnValue().Set(ret);
}",508.0,514.0,1.0,1.0,7.0,70,14,70,17,0,0,3,3,0,0,,0,0,2,1,1,void
3615,164237,Resolve,1,node.fs.FileHandle.CloseReq.Resolve,void node.fs.FileHandle.CloseReq.Resolve (),node_file.cc,"void FileHandle::CloseReq::Resolve() {
  Isolate* isolate = env()->isolate();
  HandleScope scope(isolate);
  Context::Scope context_scope(env()->context());
  InternalCallbackScope callback_scope(this);
  Local<Promise> promise = promise_.Get(isolate);
  Local<Promise::Resolver> resolver = promise.As<Promise::Resolver>();
  resolver->Resolve(env()->context(), Undefined(isolate)).Check();
}",395.0,403.0,1.0,1.0,9.0,15,5,13,6,0,0,1,1,0,0,,0,0,0,0,0,void
3616,164296,Reject,1,node.fs.FileHandle.CloseReq.Reject,void node.fs.FileHandle.CloseReq.Reject (Local<Value>),node_file.cc,"void FileHandle::CloseReq::Reject(Local<Value> reason) {
  Isolate* isolate = env()->isolate();
  HandleScope scope(isolate);
  Context::Scope context_scope(env()->context());
  InternalCallbackScope callback_scope(this);
  Local<Promise> promise = promise_.Get(isolate);
  Local<Promise::Resolver> resolver = promise.As<Promise::Resolver>();
  resolver->Reject(env()->context(), reason).Check();
}",405.0,413.0,1.0,1.0,9.0,15,5,13,7,0,0,1,1,0,0,,0,0,2,1,1,void
3617,164355,file_handle,1,node.fs.FileHandle.CloseReq.file_handle,FileHandle node.fs.FileHandle.CloseReq.file_handle (),node_file.cc,"FileHandle* FileHandle::CloseReq::file_handle() {
  Isolate* isolate = env()->isolate();
  HandleScope scope(isolate);
  Local<Value> val = ref_.Get(isolate);
  Local<Object> obj = val.As<Object>();
  return Unwrap<FileHandle>(obj);
}",415.0,421.0,1.0,1.0,7.0,12,5,14,9,0,0,1,1,0,0,,0,0,0,0,0,FileHandle
3618,164396,CloseReq,1,node.fs.FileHandle.CloseReq.CloseReq,"ANY node.fs.FileHandle.CloseReq.CloseReq (Environment*,Local<Object>,Local<Promise>,Local<Value>)",node_file.cc,"FileHandle::CloseReq::CloseReq(Environment* env,
                               Local<Object> obj,
                               Local<Promise> promise,
                               Local<Value> ref)
  : ReqWrap(env, obj, AsyncWrap::PROVIDER_FILEHANDLECLOSEREQ) {
  promise_.Reset(env->isolate(), promise);
  ref_.Reset(env->isolate(), ref);
}",423.0,430.0,1.0,1.0,8.0,4,2,6,5,0,0,1,1,0,0,,0,0,8,4,4,ANY
3619,164422,~CloseReq,1,node.fs.FileHandle.CloseReq.~CloseReq,ANY node.fs.FileHandle.CloseReq.~CloseReq (),node_file.cc,"FileHandle::CloseReq::~CloseReq() {
  uv_fs_req_cleanup(req());
  promise_.Reset();
  ref_.Reset();
}",432.0,436.0,1.0,1.0,5.0,2,1,2,2,0,0,1,1,0,0,,0,0,0,0,0,ANY
3620,164435,MemoryInfo,1,node.fs.FileHandle.CloseReq.MemoryInfo,void node.fs.FileHandle.CloseReq.MemoryInfo (MemoryTracker*),node_file.cc,"void FileHandle::CloseReq::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackField(""promise"", promise_);
  tracker->TrackField(""ref"", ref_);
}",438.0,441.0,1.0,1.0,4.0,2,1,4,3,0,0,1,1,0,0,,0,0,2,1,1,void
3621,164452,ClosePromise,1,node.fs.FileHandle.ClosePromise,MaybeLocal<Promise> node.fs.FileHandle.ClosePromise (),node_file.cc,"MaybeLocal<Promise> FileHandle::ClosePromise() {
  Isolate* isolate = env()->isolate();
  EscapableHandleScope scope(isolate);
  Local<Context> context = env()->context();

  Local<Value> close_resolver =
      object()->GetInternalField(FileHandle::kClosingPromiseSlot);
  if (!close_resolver.IsEmpty() && !close_resolver->IsUndefined()) {
    CHECK(close_resolver->IsPromise());
    return close_resolver.As<Promise>();
  }

  CHECK(!closed_);
  CHECK(!closing_);
  CHECK(!reading_);

  auto maybe_resolver = Promise::Resolver::New(context);
  CHECK(!maybe_resolver.IsEmpty());
  Local<Promise::Resolver> resolver = maybe_resolver.ToLocalChecked();
  Local<Promise> promise = resolver.As<Promise>();

  Local<Object> close_req_obj;
  if (!env()->fdclose_constructor_template()
          ->NewInstance(env()->context()).ToLocal(&close_req_obj)) {
    return MaybeLocal<Promise>();
  }
  closing_ = true;
  object()->SetInternalField(FileHandle::kClosingPromiseSlot, promise);

  CloseReq* req = n...",450.0,506.0,1.0,4.0,57.0,84,17,83,34,0,0,4,4,0,0,,0,0,0,0,0,MaybeLocal<Promise>
3622,164782,ReleaseFD,1,node.fs.FileHandle.ReleaseFD,void node.fs.FileHandle.ReleaseFD (FunctionCallbackInfo<Value>),node_file.cc,"void FileHandle::ReleaseFD(const FunctionCallbackInfo<Value>& args) {
  FileHandle* fd;
  ASSIGN_OR_RETURN_UNWRAP(&fd, args.Holder());
  fd->Release();
}",517.0,521.0,1.0,1.0,5.0,3,3,3,2,0,0,1,1,0,0,,0,0,2,1,1,void
3623,164799,Release,1,node.fs.FileHandle.Release,int node.fs.FileHandle.Release (),node_file.cc,"int FileHandle::Release() {
  int fd = GetFD();
  // Just pretend that Close was called and we're all done.
  AfterClose();
  return fd;
}",523.0,528.0,1.0,1.0,6.0,1,1,2,1,0,0,1,1,0,0,,0,0,0,0,0,int
3624,164810,AfterClose,1,node.fs.FileHandle.AfterClose,void node.fs.FileHandle.AfterClose (),node_file.cc,"void FileHandle::AfterClose() {
  closing_ = false;
  closed_ = true;
  fd_ = -1;
  if (reading_ && !persistent().IsEmpty())
    EmitRead(UV_EOF);
}",530.0,536.0,1.0,1.0,7.0,7,5,4,4,0,0,2,2,0,0,,0,0,0,0,0,void
3625,164834,MemoryInfo,1,node.fs.FileHandleReadWrap.MemoryInfo,void node.fs.FileHandleReadWrap.MemoryInfo (MemoryTracker*),node_file.cc,"void FileHandleReadWrap::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackField(""buffer"", buffer_);
  tracker->TrackField(""file_handle"", this->file_handle_);
}",538.0,541.0,1.0,1.0,4.0,3,1,3,2,0,0,1,1,0,0,,0,0,2,1,1,void
3626,164853,FileHandleReadWrap,1,node.fs.FileHandleReadWrap.FileHandleReadWrap,"ANY node.fs.FileHandleReadWrap.FileHandleReadWrap (FileHandle*,Local<Object>)",node_file.cc,"FileHandleReadWrap::FileHandleReadWrap(FileHandle* handle, Local<Object> obj)
  : ReqWrap(handle->env(), obj, AsyncWrap::PROVIDER_FSREQCALLBACK),
    file_handle_(handle) {}",543.0,545.0,1.0,27.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,ANY
3627,164859,ReadStart,1,node.fs.FileHandle.ReadStart,int node.fs.FileHandle.ReadStart (),node_file.cc,"int FileHandle::ReadStart() {
  if (!IsAlive() || IsClosing())
    return UV_EOF;

  reading_ = true;

  if (current_read_)
    return 0;

  BaseObjectPtr<FileHandleReadWrap> read_wrap;

  if (read_length_ == 0) {
    EmitRead(UV_EOF);
    return 0;
  }

  {
    // Create a new FileHandleReadWrap or re-use one.
    // Either way, we need these two scopes for AsyncReset() or otherwise
    // for creating the new instance.
    HandleScope handle_scope(env()->isolate());
    AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(this);

    auto& freelist = binding_data_->file_handle_read_wrap_freelist;
    if (freelist.size() > 0) {
      read_wrap = std::move(freelist.back());
      freelist.pop_back();
      // Use a fresh async resource.
      // Lifetime is ensured via AsyncWrap::resource_.
      Local<Object> resource = Object::New(env()->isolate());
      USE(resource->Set(
          env()->context(), env()->handle_string(), read_wrap->object()));
      read_wrap->AsyncReset(resou...",547.0,663.0,1.0,2.0,117.0,69,18,68,27,0,0,6,6,0,0,,0,0,0,0,0,int
3628,165159,ReadStop,1,node.fs.FileHandle.ReadStop,int node.fs.FileHandle.ReadStop (),node_file.cc,"int FileHandle::ReadStop() {
  reading_ = false;
  return 0;
}",665.0,668.0,1.0,1.0,4.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,int
3629,165169,CreateShutdownWrap,1,node.fs.FileHandle.CreateShutdownWrap,ShutdownWrap node.fs.FileHandle.CreateShutdownWrap (Local<Object>),node_file.cc,"ShutdownWrap* FileHandle::CreateShutdownWrap(Local<Object> object) {
  return new FileHandleCloseWrap(this, object);
}",672.0,674.0,1.0,1.0,3.0,1,1,2,2,0,0,1,1,0,0,,0,0,2,1,1,ShutdownWrap
3630,165179,DoShutdown,1,node.fs.FileHandle.DoShutdown,int node.fs.FileHandle.DoShutdown (ShutdownWrap*),node_file.cc,"int FileHandle::DoShutdown(ShutdownWrap* req_wrap) {
  if (closing_ || closed_) {
    req_wrap->Done(0);
    return 1;
  }
  FileHandleCloseWrap* wrap = static_cast<FileHandleCloseWrap*>(req_wrap);
  closing_ = true;
  CHECK_NE(fd_, -1);
  FS_ASYNC_TRACE_BEGIN0(UV_FS_CLOSE, wrap)
  wrap->Dispatch(uv_fs_close, fd_, uv_fs_callback_t{[](uv_fs_t* req) {
    FileHandleCloseWrap* wrap = static_cast<FileHandleCloseWrap*>(
        FileHandleCloseWrap::from_req(req));
    FS_ASYNC_TRACE_END1(
        req->fs_type, wrap, ""result"", static_cast<int>(req->result))
    FileHandle* handle = static_cast<FileHandle*>(wrap->stream());
    handle->AfterClose();

    int result = static_cast<int>(req->result);
    uv_fs_req_cleanup(req);
    wrap->Done(result);
  }});

  return 0;
}",676.0,699.0,1.0,2.0,24.0,35,13,39,16,0,0,2,2,0,0,,0,0,2,1,1,int
3631,165318,Reject,1,node.fs.FSReqCallback.Reject,void node.fs.FSReqCallback.Reject (Local<Value>),node_file.cc,"void FSReqCallback::Reject(Local<Value> reject) {
  MakeCallback(env()->oncomplete_string(), 1, &reject);
}",702.0,704.0,1.0,1.0,3.0,2,2,1,1,0,0,1,1,0,0,,0,0,2,1,1,void
3632,165331,ResolveStat,1,node.fs.FSReqCallback.ResolveStat,void node.fs.FSReqCallback.ResolveStat (uv_stat_t*),node_file.cc,"void FSReqCallback::ResolveStat(const uv_stat_t* stat) {
  Resolve(FillGlobalStatsArray(binding_data(), use_bigint(), stat));
}",706.0,708.0,1.0,1.0,3.0,0,0,1,1,0,0,1,1,0,0,,0,0,2,1,1,void
3633,165341,ResolveStatFs,1,node.fs.FSReqCallback.ResolveStatFs,void node.fs.FSReqCallback.ResolveStatFs (uv_statfs_t*),node_file.cc,"void FSReqCallback::ResolveStatFs(const uv_statfs_t* stat) {
  Resolve(FillGlobalStatFsArray(binding_data(), use_bigint(), stat));
}",710.0,712.0,1.0,1.0,3.0,0,0,1,1,0,0,1,1,0,0,,0,0,2,1,1,void
3634,165351,Resolve,1,node.fs.FSReqCallback.Resolve,void node.fs.FSReqCallback.Resolve (Local<Value>),node_file.cc,"void FSReqCallback::Resolve(Local<Value> value) {
  Local<Value> argv[2] {
    Null(env()->isolate()),
    value
  };
  MakeCallback(env()->oncomplete_string(),
               value->IsUndefined() ? 1 : arraysize(argv),
               argv);
}",714.0,722.0,1.0,1.0,9.0,6,4,5,2,0,0,1,1,0,0,,0,0,2,1,1,void
3635,165380,SetReturnValue,1,node.fs.FSReqCallback.SetReturnValue,void node.fs.FSReqCallback.SetReturnValue (FunctionCallbackInfo<Value>),node_file.cc,"void FSReqCallback::SetReturnValue(const FunctionCallbackInfo<Value>& args) {
  args.GetReturnValue().SetUndefined();
}",724.0,726.0,1.0,1.0,3.0,2,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,void
3636,165392,NewFSReqCallback,1,node.fs.NewFSReqCallback,void node.fs.NewFSReqCallback (FunctionCallbackInfo<Value>),node_file.cc,"void NewFSReqCallback(const FunctionCallbackInfo<Value>& args) {
  CHECK(args.IsConstructCall());
  BindingData* binding_data = Realm::GetBindingData<BindingData>(args);
  new FSReqCallback(binding_data, args.This(), args[0]->IsTrue());
}",728.0,732.0,1.0,1.0,5.0,9,7,9,5,0,0,1,1,0,0,,0,0,2,1,1,void
3637,165425,FSReqAfterScope,1,node.fs.FSReqAfterScope.FSReqAfterScope,"ANY node.fs.FSReqAfterScope.FSReqAfterScope (FSReqBase*,uv_fs_t*)",node_file.cc,"FSReqAfterScope::FSReqAfterScope(FSReqBase* wrap, uv_fs_t* req)
    : wrap_(wrap),
      req_(req),
      handle_scope_(wrap->env()->isolate()),
      context_scope_(wrap->env()->context()) {
  CHECK_EQ(wrap_->req(), req);
}",734.0,740.0,1.0,1.0,7.0,1,1,2,2,0,0,1,1,0,0,,0,0,4,2,2,ANY
3638,165437,~FSReqAfterScope,1,node.fs.FSReqAfterScope.~FSReqAfterScope,ANY node.fs.FSReqAfterScope.~FSReqAfterScope (),node_file.cc,"FSReqAfterScope::~FSReqAfterScope() {
  Clear();
}",742.0,744.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
3639,165442,Clear,1,node.fs.FSReqAfterScope.Clear,void node.fs.FSReqAfterScope.Clear (),node_file.cc,"void FSReqAfterScope::Clear() {
  if (!wrap_) return;

  uv_fs_req_cleanup(wrap_->req());
  wrap_->Detach();
  wrap_.reset();
}",746.0,752.0,1.0,1.0,7.0,4,3,4,1,0,0,2,2,0,0,,0,0,0,0,0,void
3640,165464,Reject,1,node.fs.FSReqAfterScope.Reject,void node.fs.FSReqAfterScope.Reject (uv_fs_t*),node_file.cc,"void FSReqAfterScope::Reject(uv_fs_t* req) {
  BaseObjectPtr<FSReqBase> wrap { wrap_ };
  Local<Value> exception = UVException(wrap_->env()->isolate(),
                                       static_cast<int>(req->result),
                                       wrap_->syscall(),
                                       nullptr,
                                       req->path,
                                       wrap_->data());
  Clear();
  wrap->Reject(exception);
}",763.0,773.0,1.0,1.0,11.0,14,6,13,8,0,0,1,1,0,0,,0,0,2,1,1,void
3641,165513,Proceed,1,node.fs.FSReqAfterScope.Proceed,bool node.fs.FSReqAfterScope.Proceed (),node_file.cc,"bool FSReqAfterScope::Proceed() {
  if (!wrap_->env()->can_call_into_js()) {
    return false;
  }

  if (req_->result < 0) {
    Reject(req_);
    return false;
  }
  return true;
}",775.0,785.0,1.0,1.0,11.0,5,3,2,2,0,0,3,3,0,0,,0,0,0,0,0,bool
3642,165541,AfterNoArgs,1,node.fs.AfterNoArgs,void node.fs.AfterNoArgs (uv_fs_t*),node_file.cc,"void AfterNoArgs(uv_fs_t* req) {
  FSReqBase* req_wrap = FSReqBase::from_req(req);
  FSReqAfterScope after(req_wrap, req);
  FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))
  if (after.Proceed())
    req_wrap->Resolve(Undefined(req_wrap->env()->isolate()));
}",787.0,794.0,1.0,2.0,8.0,39,11,39,13,0,0,2,2,0,0,,0,0,2,1,1,void
3643,165690,AfterStat,1,node.fs.AfterStat,void node.fs.AfterStat (uv_fs_t*),node_file.cc,"void AfterStat(uv_fs_t* req) {
  FSReqBase* req_wrap = FSReqBase::from_req(req);
  FSReqAfterScope after(req_wrap, req);
  FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))
  if (after.Proceed()) {
    req_wrap->ResolveStat(&req->statbuf);
  }
}",796.0,804.0,1.0,2.0,9.0,39,11,39,13,0,0,2,2,0,0,,0,0,2,1,1,void
3644,165835,AfterStatFs,1,node.fs.AfterStatFs,void node.fs.AfterStatFs (uv_fs_t*),node_file.cc,"void AfterStatFs(uv_fs_t* req) {
  FSReqBase* req_wrap = FSReqBase::from_req(req);
  FSReqAfterScope after(req_wrap, req);
  FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))
  if (after.Proceed()) {
    req_wrap->ResolveStatFs(static_cast<uv_statfs_t*>(req->ptr));
  }
}",806.0,814.0,1.0,2.0,9.0,39,11,39,13,0,0,2,2,0,0,,0,0,2,1,1,void
3645,165981,AfterInteger,1,node.fs.AfterInteger,void node.fs.AfterInteger (uv_fs_t*),node_file.cc,"void AfterInteger(uv_fs_t* req) {
  FSReqBase* req_wrap = FSReqBase::from_req(req);
  FSReqAfterScope after(req_wrap, req);
  FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))
  int result = static_cast<int>(req->result);
  if (result >= 0 && req_wrap->is_plain_open())
    req_wrap->env()->AddUnmanagedFd(result);

  if (after.Proceed())
    req_wrap->Resolve(Integer::New(req_wrap->env()->isolate(), result));
}",816.0,827.0,1.0,2.0,12.0,48,13,47,15,0,0,3,3,0,0,,0,0,2,1,1,void
3646,166160,AfterOpenFileHandle,1,node.fs.AfterOpenFileHandle,void node.fs.AfterOpenFileHandle (uv_fs_t*),node_file.cc,"void AfterOpenFileHandle(uv_fs_t* req) {
  FSReqBase* req_wrap = FSReqBase::from_req(req);
  FSReqAfterScope after(req_wrap, req);
  FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))
  if (after.Proceed()) {
    FileHandle* fd = FileHandle::New(req_wrap->binding_data(),
                                     static_cast<int>(req->result));
    if (fd == nullptr) return;
    req_wrap->Resolve(fd->object());
  }
}",829.0,840.0,1.0,2.0,12.0,44,12,44,15,0,0,3,4,0,0,,0,0,2,1,1,void
3647,166327,FromNamespacedPath,1,node.fs.FromNamespacedPath,void node.fs.FromNamespacedPath (ANY*),node_file.cc,"void FromNamespacedPath(std::string* path) {
#ifdef _WIN32
  if (path->compare(0, 8, ""\\\\?\\UNC\\"", 8) == 0) {
    *path = path->substr(8);
    path->insert(0, ""\\\\"");
  } else if (path->compare(0, 4, ""\\\\?\\"", 4) == 0) {
    *path = path->substr(4);
  }
#endif
}",844.0,853.0,1.0,1.0,10.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
3648,166332,AfterMkdirp,1,node.fs.AfterMkdirp,void node.fs.AfterMkdirp (uv_fs_t*),node_file.cc,"void AfterMkdirp(uv_fs_t* req) {
  FSReqBase* req_wrap = FSReqBase::from_req(req);
  FSReqAfterScope after(req_wrap, req);
  FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))
  if (after.Proceed()) {
    std::string first_path(req_wrap->continuation_data()->first_path());
    if (first_path.empty())
      return req_wrap->Resolve(Undefined(req_wrap->env()->isolate()));
    FromNamespacedPath(&first_path);
    Local<Value> path;
    Local<Value> error;
    if (!StringBytes::Encode(req_wrap->env()->isolate(), first_path.c_str(),
                             req_wrap->encoding(),
                             &error).ToLocal(&path)) {
      return req_wrap->Reject(error);
    }
    return req_wrap->Resolve(path);
  }
}",855.0,874.0,1.0,2.0,20.0,58,13,58,19,0,0,4,6,0,0,,0,0,2,1,1,void
3649,166551,AfterStringPath,1,node.fs.AfterStringPath,void node.fs.AfterStringPath (uv_fs_t*),node_file.cc,"void AfterStringPath(uv_fs_t* req) {
  FSReqBase* req_wrap = FSReqBase::from_req(req);
  FSReqAfterScope after(req_wrap, req);
  FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))
  MaybeLocal<Value> link;
  Local<Value> error;

  if (after.Proceed()) {
    link = StringBytes::Encode(req_wrap->env()->isolate(),
                               req->path,
                               req_wrap->encoding(),
                               &error);
    if (link.IsEmpty())
      req_wrap->Reject(error);
    else
      req_wrap->Resolve(link.ToLocalChecked());
  }
}",876.0,894.0,1.0,2.0,19.0,49,13,52,19,0,0,3,4,0,0,,0,0,2,1,1,void
3650,166741,AfterStringPtr,1,node.fs.AfterStringPtr,void node.fs.AfterStringPtr (uv_fs_t*),node_file.cc,"void AfterStringPtr(uv_fs_t* req) {
  FSReqBase* req_wrap = FSReqBase::from_req(req);
  FSReqAfterScope after(req_wrap, req);
  FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))
  MaybeLocal<Value> link;
  Local<Value> error;

  if (after.Proceed()) {
    link = StringBytes::Encode(req_wrap->env()->isolate(),
                               static_cast<const char*>(req->ptr),
                               req_wrap->encoding(),
                               &error);
    if (link.IsEmpty())
      req_wrap->Reject(error);
    else
      req_wrap->Resolve(link.ToLocalChecked());
  }
}",896.0,914.0,1.0,2.0,19.0,50,13,52,19,0,0,3,4,0,0,,0,0,2,1,1,void
3651,166933,AfterScanDir,1,node.fs.AfterScanDir,void node.fs.AfterScanDir (uv_fs_t*),node_file.cc,"void AfterScanDir(uv_fs_t* req) {
  FSReqBase* req_wrap = FSReqBase::from_req(req);
  FSReqAfterScope after(req_wrap, req);
  FS_ASYNC_TRACE_END1(
      req->fs_type, req_wrap, ""result"", static_cast<int>(req->result))
  if (!after.Proceed()) {
    return;
  }

  Environment* env = req_wrap->env();
  Isolate* isolate = env->isolate();
  Local<Value> error;
  int r;

  std::vector<Local<Value>> name_v;
  std::vector<Local<Value>> type_v;

  const bool with_file_types = req_wrap->with_file_types();

  for (;;) {
    uv_dirent_t ent;

    r = uv_fs_scandir_next(req, &ent);
    if (r == UV_EOF)
      break;
    if (r != 0) {
      return req_wrap->Reject(
          UVException(isolate, r, nullptr, req_wrap->syscall(), req->path));
    }

    Local<Value> filename;
    if (!StringBytes::Encode(isolate, ent.name, req_wrap->encoding(), &error)
             .ToLocal(&filename)) {
      return req_wrap->Reject(error);
    }
    name_v.push_back(filename);

    if (with_file_types) type_v.empl...",916.0,963.0,1.0,2.0,48.0,84,16,98,30,0,0,9,12,0,0,,0,0,2,1,1,void
3652,167271,Access,1,node.fs.Access,void node.fs.Access (FunctionCallbackInfo<Value>),node_file.cc,"void Access(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  Isolate* isolate = env->isolate();
  HandleScope scope(isolate);

  const int argc = args.Length();
  CHECK_GE(argc, 2);

  CHECK(args[1]->IsInt32());
  int mode = args[1].As<Int32>()->Value();

  BufferValue path(isolate, args[0]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemRead, path.ToStringView());

  FSReqBase* req_wrap_async = GetReqWrap(args, 2);
  if (req_wrap_async != nullptr) {  // access(path, mode, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_ACCESS, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""access"", UTF8, AfterNoArgs,
              uv_fs_access, *path, mode);
  } else {  // access(path, mode, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(access);
    SyncCall(env, args[3], &req_wrap_sync, ""access""...",965.0,995.0,1.0,4.0,31.0,50,13,61,22,0,0,2,2,0,0,,0,0,2,1,1,void
3653,167683,Close,1,node.fs.Close,void node.fs.Close (FunctionCallbackInfo<Value>),node_file.cc,"void Close(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 2);

  CHECK(args[0]->IsInt32());
  int fd = args[0].As<Int32>()->Value();
  env->RemoveUnmanagedFd(fd);

  FSReqBase* req_wrap_async = GetReqWrap(args, 1);
  if (req_wrap_async != nullptr) {  // close(fd, req)
    FS_ASYNC_TRACE_BEGIN0(UV_FS_CLOSE, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""close"", UTF8, AfterNoArgs,
              uv_fs_close, fd);
  } else {  // close(fd, undefined, ctx)
    CHECK_EQ(argc, 3);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(close);
    SyncCall(env, args[2], &req_wrap_sync, ""close"", uv_fs_close, fd);
    FS_SYNC_TRACE_END(close);
  }
}",998.0,1020.0,1.0,4.0,23.0,40,13,49,18,0,0,2,2,0,0,,0,0,2,1,1,void
3654,168056,InternalModuleReadJSON,1,node.fs.InternalModuleReadJSON,void node.fs.InternalModuleReadJSON (FunctionCallbackInfo<Value>),node_file.cc,"static void InternalModuleReadJSON(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();
  uv_loop_t* loop = env->event_loop();

  CHECK(args[0]->IsString());
  node::Utf8Value path(isolate, args[0]);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemRead, path.ToStringView());

  if (strlen(*path) != path.length()) {
    args.GetReturnValue().Set(Array::New(isolate));
    return;  // Contains a nul byte.
  }
  uv_fs_t open_req;
  const int fd = uv_fs_open(loop, &open_req, *path, O_RDONLY, 0, nullptr);
  uv_fs_req_cleanup(&open_req);

  if (fd < 0) {
    args.GetReturnValue().Set(Array::New(isolate));
    return;
  }

  auto defer_close = OnScopeLeave([fd, loop]() {
    uv_fs_t close_req;
    CHECK_EQ(0, uv_fs_close(loop, &close_req, fd, nullptr));
    uv_fs_req_cleanup(&close_req);
  });

  const size_t kBlockSize = 32 << 10;
  std::vector<char> chars;
  int64_t offse...",1024.0,1119.0,1.0,1.0,96.0,118,20,116,34,0,0,19,25,0,0,,0,0,2,1,1,void
3655,168484,InternalModuleStat,1,node.fs.InternalModuleStat,void node.fs.InternalModuleStat (FunctionCallbackInfo<Value>),node_file.cc,"static void InternalModuleStat(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  CHECK(args[0]->IsString());
  node::Utf8Value path(env->isolate(), args[0]);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemRead, path.ToStringView());

  uv_fs_t req;
  int rc = uv_fs_stat(env->event_loop(), &req, *path, nullptr);
  if (rc == 0) {
    const uv_stat_t* const s = static_cast<const uv_stat_t*>(req.ptr);
    rc = !!(s->st_mode & S_IFDIR);
  }
  uv_fs_req_cleanup(&req);

  args.GetReturnValue().Set(rc);
}",1124.0,1141.0,1.0,1.0,18.0,25,10,23,10,0,0,2,2,0,0,,0,0,2,1,1,void
3656,168571,Stat,1,node.fs.Stat,void node.fs.Stat (FunctionCallbackInfo<Value>),node_file.cc,"static void Stat(const FunctionCallbackInfo<Value>& args) {
  BindingData* binding_data = Realm::GetBindingData<BindingData>(args);
  Environment* env = binding_data->env();

  const int argc = args.Length();
  CHECK_GE(argc, 2);

  BufferValue path(env->isolate(), args[0]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemRead, path.ToStringView());

  bool use_bigint = args[1]->IsTrue();
  FSReqBase* req_wrap_async = GetReqWrap(args, 2, use_bigint);
  if (req_wrap_async != nullptr) {  // stat(path, use_bigint, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_STAT, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""stat"", UTF8, AfterStat,
              uv_fs_stat, *path);
  } else {  // stat(path, use_bigint, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(stat);
    int err = SyncCall(env, args[3], &req_wrap_sync, ""stat"", uv_fs_stat, *p...",1143.0,1176.0,1.0,4.0,34.0,50,15,60,23,0,0,2,2,0,0,,0,0,2,1,1,void
3657,169007,LStat,1,node.fs.LStat,void node.fs.LStat (FunctionCallbackInfo<Value>),node_file.cc,"static void LStat(const FunctionCallbackInfo<Value>& args) {
  BindingData* binding_data = Realm::GetBindingData<BindingData>(args);
  Environment* env = binding_data->env();

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  BufferValue path(env->isolate(), args[0]);
  CHECK_NOT_NULL(*path);

  bool use_bigint = args[1]->IsTrue();
  FSReqBase* req_wrap_async = GetReqWrap(args, 2, use_bigint);
  if (req_wrap_async != nullptr) {  // lstat(path, use_bigint, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_LSTAT, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""lstat"", UTF8, AfterStat,
              uv_fs_lstat, *path);
  } else {  // lstat(path, use_bigint, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(lstat);
    int err = SyncCall(env, args[3], &req_wrap_sync, ""lstat"", uv_fs_lstat,
                       *path);
    FS_SYNC_TRACE_END(lstat);
    if (err != 0) {
      return;  // error info...",1178.0,1210.0,1.0,4.0,33.0,47,15,56,21,0,0,2,2,0,0,,0,0,2,1,1,void
3658,169432,FStat,1,node.fs.FStat,void node.fs.FStat (FunctionCallbackInfo<Value>),node_file.cc,"static void FStat(const FunctionCallbackInfo<Value>& args) {
  BindingData* binding_data = Realm::GetBindingData<BindingData>(args);
  Environment* env = binding_data->env();

  const int argc = args.Length();
  CHECK_GE(argc, 2);

  CHECK(args[0]->IsInt32());
  int fd = args[0].As<Int32>()->Value();

  bool use_bigint = args[1]->IsTrue();
  FSReqBase* req_wrap_async = GetReqWrap(args, 2, use_bigint);
  if (req_wrap_async != nullptr) {  // fstat(fd, use_bigint, req)
    FS_ASYNC_TRACE_BEGIN0(UV_FS_FSTAT, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""fstat"", UTF8, AfterStat,
              uv_fs_fstat, fd);
  } else {  // fstat(fd, use_bigint, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(fstat);
    int err = SyncCall(env, args[3], &req_wrap_sync, ""fstat"", uv_fs_fstat, fd);
    FS_SYNC_TRACE_END(fstat);
    if (err != 0) {
      return;  // error info is in ctx
    }

    Local<Value> arr = FillGlobalStatsArray(binding_dat...",1212.0,1242.0,1.0,4.0,31.0,46,15,53,21,0,0,2,2,0,0,,0,0,2,1,1,void
3659,169852,StatFs,1,node.fs.StatFs,void node.fs.StatFs (FunctionCallbackInfo<Value>),node_file.cc,"static void StatFs(const FunctionCallbackInfo<Value>& args) {
  BindingData* binding_data = Realm::GetBindingData<BindingData>(args);
  Environment* env = binding_data->env();

  const int argc = args.Length();
  CHECK_GE(argc, 2);

  BufferValue path(env->isolate(), args[0]);
  CHECK_NOT_NULL(*path);

  bool use_bigint = args[1]->IsTrue();
  FSReqBase* req_wrap_async = GetReqWrap(args, 2, use_bigint);
  if (req_wrap_async != nullptr) {  // statfs(path, use_bigint, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_STATFS, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env,
              req_wrap_async,
              args,
              ""statfs"",
              UTF8,
              AfterStatFs,
              uv_fs_statfs,
              *path);
  } else {  // statfs(path, use_bigint, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(statfs);
    int err =
        SyncCall(env, args[3], &req_wrap_sync, ""statfs"", uv_fs_statfs, *path)...",1244.0,1284.0,1.0,4.0,41.0,47,15,56,21,0,0,2,2,0,0,,0,0,2,1,1,void
3660,170277,Symlink,1,node.fs.Symlink,void node.fs.Symlink (FunctionCallbackInfo<Value>),node_file.cc,"static void Symlink(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  const int argc = args.Length();
  CHECK_GE(argc, 4);

  BufferValue target(isolate, args[0]);
  CHECK_NOT_NULL(*target);
  auto target_view = target.ToStringView();
  // To avoid bypass the symlink target should be allowed to read and write
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemRead, target_view);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemWrite, target_view);

  BufferValue path(isolate, args[1]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemWrite, path.ToStringView());

  CHECK(args[2]->IsInt32());
  int flags = args[2].As<Int32>()->Value();

  FSReqBase* req_wrap_async = GetReqWrap(args, 3);
  if (req_wrap_async != nullptr) {  // symlink(target, path, flags, req)
    ...",1286.0,1328.0,1.0,4.0,43.0,64,13,79,24,0,0,2,2,0,0,,0,0,2,1,1,void
3661,170738,Link,1,node.fs.Link,void node.fs.Link (FunctionCallbackInfo<Value>),node_file.cc,"static void Link(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  BufferValue src(isolate, args[0]);
  CHECK_NOT_NULL(*src);

  const auto src_view = src.ToStringView();
  // To avoid bypass the link target should be allowed to read and write
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemRead, src_view);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemWrite, src_view);

  BufferValue dest(isolate, args[1]);
  CHECK_NOT_NULL(*dest);
  const auto dest_view = dest.ToStringView();
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemWrite, dest_view);

  FSReqBase* req_wrap_async = GetReqWrap(args, 2);
  if (req_wrap_async != nullptr) {  // link(src, dest, req)
    FS_ASYNC_TRACE_BEGIN2(UV_FS_LINK,
                          req_wrap...",1330.0,1371.0,1.0,4.0,42.0,59,13,77,24,0,0,2,2,0,0,,0,0,2,1,1,void
3662,171182,ReadLink,1,node.fs.ReadLink,void node.fs.ReadLink (FunctionCallbackInfo<Value>),node_file.cc,"static void ReadLink(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  BufferValue path(isolate, args[0]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemRead, path.ToStringView());

  const enum encoding encoding = ParseEncoding(isolate, args[1], UTF8);

  FSReqBase* req_wrap_async = GetReqWrap(args, 2);
  if (req_wrap_async != nullptr) {  // readlink(path, encoding, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_READLINK, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""readlink"", encoding, AfterStringPtr,
              uv_fs_readlink, *path);
  } else {
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(readlink);
    int err = SyncCall(env, args[3], &req_wrap_sync, ""readlink"",
                       uv_fs_rea...",1373.0,1418.0,1.0,4.0,46.0,46,13,60,22,0,0,2,2,0,0,,0,0,2,1,1,void
3663,171664,Rename,1,node.fs.Rename,void node.fs.Rename (FunctionCallbackInfo<Value>),node_file.cc,"static void Rename(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  BufferValue old_path(isolate, args[0]);
  CHECK_NOT_NULL(*old_path);
  auto view_old_path = old_path.ToStringView();
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemRead, view_old_path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemWrite, view_old_path);

  BufferValue new_path(isolate, args[1]);
  CHECK_NOT_NULL(*new_path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env,
      permission::PermissionScope::kFileSystemWrite,
      new_path.ToStringView());

  FSReqBase* req_wrap_async = GetReqWrap(args, 2);
  if (req_wrap_async != nullptr) {
    FS_ASYNC_TRACE_BEGIN2(UV_FS_RENAME,
                          req_wrap_async,
                          ""old_path"",
                          TRACE_STR_C...",1420.0,1461.0,1.0,4.0,42.0,58,13,75,23,0,0,2,2,0,0,,0,0,2,1,1,void
3664,172104,FTruncate,1,node.fs.FTruncate,void node.fs.FTruncate (FunctionCallbackInfo<Value>),node_file.cc,"static void FTruncate(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  CHECK(args[0]->IsInt32());
  const int fd = args[0].As<Int32>()->Value();

  CHECK(IsSafeJsInt(args[1]));
  const int64_t len = args[1].As<Integer>()->Value();

  FSReqBase* req_wrap_async = GetReqWrap(args, 2);
  if (req_wrap_async != nullptr) {
    FS_ASYNC_TRACE_BEGIN0(UV_FS_FTRUNCATE, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""ftruncate"", UTF8, AfterNoArgs,
              uv_fs_ftruncate, fd, len);
  } else {
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(ftruncate);
    SyncCall(env, args[3], &req_wrap_sync, ""ftruncate"", uv_fs_ftruncate, fd,
             len);
    FS_SYNC_TRACE_END(ftruncate);
  }
}",1463.0,1488.0,1.0,4.0,26.0,44,13,51,19,0,0,2,2,0,0,,0,0,2,1,1,void
3665,172491,Fdatasync,1,node.fs.Fdatasync,void node.fs.Fdatasync (FunctionCallbackInfo<Value>),node_file.cc,"static void Fdatasync(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 2);

  CHECK(args[0]->IsInt32());
  const int fd = args[0].As<Int32>()->Value();

  FSReqBase* req_wrap_async = GetReqWrap(args, 1);
  if (req_wrap_async != nullptr) {
    FS_ASYNC_TRACE_BEGIN0(UV_FS_FDATASYNC, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""fdatasync"", UTF8, AfterNoArgs,
              uv_fs_fdatasync, fd);
  } else {
    CHECK_EQ(argc, 3);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(fdatasync);
    SyncCall(env, args[2], &req_wrap_sync, ""fdatasync"", uv_fs_fdatasync, fd);
    FS_SYNC_TRACE_END(fdatasync);
  }
}",1490.0,1511.0,1.0,4.0,22.0,39,13,47,18,0,0,2,2,0,0,,0,0,2,1,1,void
3666,172859,Fsync,1,node.fs.Fsync,void node.fs.Fsync (FunctionCallbackInfo<Value>),node_file.cc,"static void Fsync(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 2);

  CHECK(args[0]->IsInt32());
  const int fd = args[0].As<Int32>()->Value();

  FSReqBase* req_wrap_async = GetReqWrap(args, 1);
  if (req_wrap_async != nullptr) {
    FS_ASYNC_TRACE_BEGIN0(UV_FS_FSYNC, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""fsync"", UTF8, AfterNoArgs,
              uv_fs_fsync, fd);
  } else {
    CHECK_EQ(argc, 3);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(fsync);
    SyncCall(env, args[2], &req_wrap_sync, ""fsync"", uv_fs_fsync, fd);
    FS_SYNC_TRACE_END(fsync);
  }
}",1513.0,1534.0,1.0,4.0,22.0,39,13,47,18,0,0,2,2,0,0,,0,0,2,1,1,void
3667,173227,Unlink,1,node.fs.Unlink,void node.fs.Unlink (FunctionCallbackInfo<Value>),node_file.cc,"static void Unlink(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 2);

  BufferValue path(env->isolate(), args[0]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemWrite, path.ToStringView());

  FSReqBase* req_wrap_async = GetReqWrap(args, 1);
  if (req_wrap_async != nullptr) {
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_UNLINK, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""unlink"", UTF8, AfterNoArgs,
              uv_fs_unlink, *path);
  } else {
    CHECK_EQ(argc, 3);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(unlink);
    SyncCall(env, args[2], &req_wrap_sync, ""unlink"", uv_fs_unlink, *path);
    FS_SYNC_TRACE_END(unlink);
  }
}",1536.0,1560.0,1.0,4.0,25.0,43,13,54,20,0,0,2,2,0,0,,0,0,2,1,1,void
3668,173611,RMDir,1,node.fs.RMDir,void node.fs.RMDir (FunctionCallbackInfo<Value>),node_file.cc,"static void RMDir(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 2);

  BufferValue path(env->isolate(), args[0]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemWrite, path.ToStringView());

  FSReqBase* req_wrap_async = GetReqWrap(args, 1);  // rmdir(path, req)
  if (req_wrap_async != nullptr) {
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_RMDIR, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""rmdir"", UTF8, AfterNoArgs,
              uv_fs_rmdir, *path);
  } else {  // rmdir(path, undefined, ctx)
    CHECK_EQ(argc, 3);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(rmdir);
    SyncCall(env, args[2], &req_wrap_sync, ""rmdir"",
             uv_fs_rmdir, *path);
    FS_SYNC_TRACE_END(rmdir);
  }
}",1562.0,1587.0,1.0,4.0,26.0,43,13,54,20,0,0,2,2,0,0,,0,0,2,1,1,void
3669,173995,MKDirpSync,1,node.fs.MKDirpSync,"int node.fs.MKDirpSync (uv_loop_t*,uv_fs_t*,ANY,int,uv_fs_cb)",node_file.cc,"int MKDirpSync(uv_loop_t* loop,
               uv_fs_t* req,
               const std::string& path,
               int mode,
               uv_fs_cb cb) {
  FSReqWrapSync* req_wrap = ContainerOf(&FSReqWrapSync::req, req);

  // on the first iteration of algorithm, stash state information.
  if (req_wrap->continuation_data() == nullptr) {
    req_wrap->set_continuation_data(
        std::make_unique<FSContinuationData>(req, mode, cb));
    req_wrap->continuation_data()->PushPath(std::move(path));
  }

  while (req_wrap->continuation_data()->paths().size() > 0) {
    std::string next_path = req_wrap->continuation_data()->PopPath();
    int err = uv_fs_mkdir(loop, req, next_path.c_str(), mode, nullptr);
    while (true) {
      switch (err) {
        // Note: uv_fs_req_cleanup in terminal paths will be called by
        // ~FSReqWrapSync():
        case 0:
          req_wrap->continuation_data()->MaybeSetFirstPath(next_path);
          if (req_wrap->continuation_data()->paths().size()...",1589.0,1655.0,1.0,27.0,67.0,58,13,64,22,0,0,14,29,0,0,,0,0,10,5,5,int
3670,174271,MKDirpAsync,1,node.fs.MKDirpAsync,"int node.fs.MKDirpAsync (uv_loop_t*,uv_fs_t*,char*,int,uv_fs_cb)",node_file.cc,"int MKDirpAsync(uv_loop_t* loop,
                uv_fs_t* req,
                const char* path,
                int mode,
                uv_fs_cb cb) {
  FSReqBase* req_wrap = FSReqBase::from_req(req);
  // on the first iteration of algorithm, stash state information.
  if (req_wrap->continuation_data() == nullptr) {
    req_wrap->set_continuation_data(
        std::make_unique<FSContinuationData>(req, mode, cb));
    req_wrap->continuation_data()->PushPath(std::move(path));
  }

  // on each iteration of algorithm, mkdir directory on top of stack.
  std::string next_path = req_wrap->continuation_data()->PopPath();
  int err = uv_fs_mkdir(loop, req, next_path.c_str(), mode,
                        uv_fs_callback_t{[](uv_fs_t* req) {
    FSReqBase* req_wrap = FSReqBase::from_req(req);
    Environment* env = req_wrap->env();
    uv_loop_t* loop = env->event_loop();
    std::string path = req->path;
    int err = static_cast<int>(req->result);

    while (true) {
      switch (err) {...",1657.0,1750.0,1.0,30.0,94.0,19,9,21,11,0,0,2,2,0,0,,0,0,10,5,5,int
3671,174348,CallMKDirpSync,1,node.fs.CallMKDirpSync,"int node.fs.CallMKDirpSync (Environment*,FunctionCallbackInfo<Value>,FSReqWrapSync*,char*,int)",node_file.cc,"int CallMKDirpSync(Environment* env, const FunctionCallbackInfo<Value>& args,
                   FSReqWrapSync* req_wrap, const char* path, int mode) {
  env->PrintSyncTrace();
  int err = MKDirpSync(env->event_loop(), &req_wrap->req, path, mode,
                       nullptr);
  if (err < 0) {
    v8::Local<v8::Context> context = env->context();
    v8::Local<v8::Object> ctx_obj = args[4].As<v8::Object>();
    v8::Isolate* isolate = env->isolate();
    ctx_obj->Set(context,
                 env->errno_string(),
                 v8::Integer::New(isolate, err)).Check();
    ctx_obj->Set(context,
                 env->syscall_string(),
                 OneByteString(isolate, ""mkdir"")).Check();
  }
  return err;
}",1752.0,1769.0,1.0,1.0,18.0,29,7,29,11,0,0,2,2,0,0,,0,0,10,5,5,int
3672,174455,MKDir,1,node.fs.MKDir,void node.fs.MKDir (FunctionCallbackInfo<Value>),node_file.cc,"static void MKDir(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 4);

  BufferValue path(env->isolate(), args[0]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemWrite, path.ToStringView());

  CHECK(args[1]->IsInt32());
  const int mode = args[1].As<Int32>()->Value();

  CHECK(args[2]->IsBoolean());
  bool mkdirp = args[2]->IsTrue();

  FSReqBase* req_wrap_async = GetReqWrap(args, 3);
  if (req_wrap_async != nullptr) {  // mkdir(path, mode, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_UNLINK, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""mkdir"", UTF8,
              mkdirp ? AfterMkdirp : AfterNoArgs,
              mkdirp ? MKDirpAsync : uv_fs_mkdir, *path, mode);
  } else {  // mkdir(path, mode, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync req_wrap_sync;
    FS_SY...",1771.0,1822.0,1.0,4.0,52.0,56,14,63,22,0,0,2,2,0,0,,0,0,2,1,1,void
3673,174999,RealPath,1,node.fs.RealPath,void node.fs.RealPath (FunctionCallbackInfo<Value>),node_file.cc,"static void RealPath(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  BufferValue path(isolate, args[0]);
  CHECK_NOT_NULL(*path);

  const enum encoding encoding = ParseEncoding(isolate, args[1], UTF8);

  FSReqBase* req_wrap_async = GetReqWrap(args, 2);
  if (req_wrap_async != nullptr) {  // realpath(path, encoding, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_REALPATH, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""realpath"", encoding, AfterStringPtr,
              uv_fs_realpath, *path);
  } else {  // realpath(path, encoding, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(realpath);
    int err = SyncCall(env, args[3], &req_wrap_sync, ""realpath"",
                       uv_fs_realpath, *path);
    FS_SYNC_TRACE_END(realpath);
    if (err < 0) {
    ...",1824.0,1868.0,1.0,4.0,45.0,43,13,56,20,0,0,2,2,0,0,,0,0,2,1,1,void
3674,175470,ReadDir,1,node.fs.ReadDir,void node.fs.ReadDir (FunctionCallbackInfo<Value>),node_file.cc,"static void ReadDir(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  BufferValue path(isolate, args[0]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemRead, path.ToStringView());

  const enum encoding encoding = ParseEncoding(isolate, args[1], UTF8);

  bool with_types = args[2]->IsTrue();

  FSReqBase* req_wrap_async = GetReqWrap(args, 3);
  if (req_wrap_async != nullptr) {  // readdir(path, encoding, withTypes, req)
    req_wrap_async->set_with_file_types(with_types);
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_SCANDIR, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env,
              req_wrap_async,
              args,
              ""scandir"",
              encoding,
              AfterScanDir,
              uv_fs_scandir,
              *path,
              0 /*f...",1870.0,1962.0,1.0,4.0,93.0,50,13,64,23,0,0,2,2,0,0,,0,0,2,1,1,void
3675,176139,CheckOpenPermissions,1,node.fs.CheckOpenPermissions,"Maybe<void> node.fs.CheckOpenPermissions (Environment*,BufferValue,int)",node_file.cc,"static inline Maybe<void> CheckOpenPermissions(Environment* env,
                                               const BufferValue& path,
                                               int flags) {
  // These flags capture the intention of the open() call.
  const int rwflags = flags & (UV_FS_O_RDONLY | UV_FS_O_WRONLY | UV_FS_O_RDWR);

  // These flags have write-like side effects even with O_RDONLY, at least on
  // some operating systems. On Windows, for example, O_RDONLY | O_TEMPORARY
  // can be used to delete a file. Bizarre.
  const int write_as_side_effect = flags & (UV_FS_O_APPEND | UV_FS_O_CREAT |
                                            UV_FS_O_TRUNC | UV_FS_O_TEMPORARY);

  // TODO(rafaelgss): it can be optimized to avoid two permission checks
  auto pathView = path.ToStringView();
  if (rwflags != UV_FS_O_WRONLY) {
    THROW_IF_INSUFFICIENT_PERMISSIONS(
        env,
        permission::PermissionScope::kFileSystemRead,
        pathView,
        Nothing<void>());
  }
  ...",1964.0,1993.0,1.0,1.0,30.0,18,6,26,15,0,0,3,3,0,0,,0,0,6,3,3,Maybe<void>
3676,176207,Open,1,node.fs.Open,void node.fs.Open (FunctionCallbackInfo<Value>),node_file.cc,"static void Open(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  BufferValue path(env->isolate(), args[0]);
  CHECK_NOT_NULL(*path);

  CHECK(args[1]->IsInt32());
  const int flags = args[1].As<Int32>()->Value();

  CHECK(args[2]->IsInt32());
  const int mode = args[2].As<Int32>()->Value();

  if (CheckOpenPermissions(env, path, flags).IsNothing()) return;

  FSReqBase* req_wrap_async = GetReqWrap(args, 3);
  if (req_wrap_async != nullptr) {  // open(path, flags, mode, req)
    req_wrap_async->set_is_plain_open(true);
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_OPEN, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""open"", UTF8, AfterInteger,
              uv_fs_open, *path, flags, mode);
  } else {  // open(path, flags, mode, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(open);
    int result ...",1995.0,2029.0,1.0,4.0,35.0,54,13,62,20,0,0,3,3,0,0,,0,0,2,1,1,void
3677,176658,OpenFileHandle,1,node.fs.OpenFileHandle,void node.fs.OpenFileHandle (FunctionCallbackInfo<Value>),node_file.cc,"static void OpenFileHandle(const FunctionCallbackInfo<Value>& args) {
  BindingData* binding_data = Realm::GetBindingData<BindingData>(args);
  Environment* env = binding_data->env();
  Isolate* isolate = env->isolate();

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  BufferValue path(isolate, args[0]);
  CHECK_NOT_NULL(*path);

  CHECK(args[1]->IsInt32());
  const int flags = args[1].As<Int32>()->Value();

  CHECK(args[2]->IsInt32());
  const int mode = args[2].As<Int32>()->Value();

  if (CheckOpenPermissions(env, path, flags).IsNothing()) return;

  FSReqBase* req_wrap_async = GetReqWrap(args, 3);
  if (req_wrap_async != nullptr) {  // openFileHandle(path, flags, mode, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_OPEN, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""open"", UTF8, AfterOpenFileHandle,
              uv_fs_open, *path, flags, mode);
  } else {  // openFileHandle(path, flags, mode, undefined, ctx)
    CHECK_EQ(argc,...",2031.0,2070.0,1.0,4.0,40.0,58,15,66,23,0,0,3,3,0,0,,0,0,2,1,1,void
3678,177131,CopyFile,1,node.fs.CopyFile,void node.fs.CopyFile (FunctionCallbackInfo<Value>),node_file.cc,"static void CopyFile(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  BufferValue src(isolate, args[0]);
  CHECK_NOT_NULL(*src);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemRead, src.ToStringView());

  BufferValue dest(isolate, args[1]);
  CHECK_NOT_NULL(*dest);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemWrite, dest.ToStringView());

  CHECK(args[2]->IsInt32());
  const int flags = args[2].As<Int32>()->Value();

  FSReqBase* req_wrap_async = GetReqWrap(args, 3);
  if (req_wrap_async != nullptr) {  // copyFile(src, dest, flags, req)
    FS_ASYNC_TRACE_BEGIN2(UV_FS_COPYFILE,
                          req_wrap_async,
                          ""src"",
                          TRACE_STR_COPY(*src),
                          ""dest"",
                          TR...",2072.0,2111.0,1.0,4.0,40.0,61,13,73,23,0,0,2,2,0,0,,0,0,2,1,1,void
3679,177580,WriteBuffer,1,node.fs.WriteBuffer,void node.fs.WriteBuffer (FunctionCallbackInfo<Value>),node_file.cc,"static void WriteBuffer(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 4);

  CHECK(args[0]->IsInt32());
  const int fd = args[0].As<Int32>()->Value();

  CHECK(Buffer::HasInstance(args[1]));
  Local<Object> buffer_obj = args[1].As<Object>();
  char* buffer_data = Buffer::Data(buffer_obj);
  size_t buffer_length = Buffer::Length(buffer_obj);

  CHECK(IsSafeJsInt(args[2]));
  const int64_t off_64 = args[2].As<Integer>()->Value();
  CHECK_GE(off_64, 0);
  CHECK_LE(static_cast<uint64_t>(off_64), buffer_length);
  const size_t off = static_cast<size_t>(off_64);

  CHECK(args[3]->IsInt32());
  const size_t len = static_cast<size_t>(args[3].As<Int32>()->Value());
  CHECK(Buffer::IsWithinBounds(off, len, buffer_length));
  CHECK_LE(len, buffer_length);
  CHECK_GE(off + len, off);

  const int64_t pos = GetOffset(args[4]);

  char* buf = buffer_data + off;
  uv_buf_t uvbuf = uv_buf_init(buf, ...",2123.0,2168.0,1.0,4.0,46.0,73,16,89,30,0,0,2,2,0,0,,0,0,2,1,1,void
3680,178092,WriteBuffers,1,node.fs.WriteBuffers,void node.fs.WriteBuffers (FunctionCallbackInfo<Value>),node_file.cc,"static void WriteBuffers(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  CHECK(args[0]->IsInt32());
  const int fd = args[0].As<Int32>()->Value();

  CHECK(args[1]->IsArray());
  Local<Array> chunks = args[1].As<Array>();

  int64_t pos = GetOffset(args[2]);

  MaybeStackBuffer<uv_buf_t> iovs(chunks->Length());

  for (uint32_t i = 0; i < iovs.length(); i++) {
    Local<Value> chunk = chunks->Get(env->context(), i).ToLocalChecked();
    CHECK(Buffer::HasInstance(chunk));
    iovs[i] = uv_buf_init(Buffer::Data(chunk), Buffer::Length(chunk));
  }

  FSReqBase* req_wrap_async = GetReqWrap(args, 3);
  if (req_wrap_async != nullptr) {  // writeBuffers(fd, chunks, pos, req)
    FS_ASYNC_TRACE_BEGIN0(UV_FS_WRITE, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""write"", UTF8, AfterInteger,
              uv_fs_write, fd, *iovs, iovs.length(), pos);
  } else {  // writeBuffers(fd...",2178.0,2214.0,1.0,4.0,37.0,67,15,77,29,0,0,3,3,0,0,,0,0,2,1,1,void
3681,178576,WriteString,1,node.fs.WriteString,void node.fs.WriteString (FunctionCallbackInfo<Value>),node_file.cc,"static void WriteString(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  const int argc = args.Length();
  CHECK_GE(argc, 4);
  CHECK(args[0]->IsInt32());
  const int fd = args[0].As<Int32>()->Value();

  const int64_t pos = GetOffset(args[2]);

  const auto enc = ParseEncoding(isolate, args[3], UTF8);

  Local<Value> value = args[1];
  char* buf = nullptr;
  size_t len;

  FSReqBase* req_wrap_async = GetReqWrap(args, 4);
  const bool is_async = req_wrap_async != nullptr;

  // Avoid copying the string when it is externalized but only when:
  // 1. The target encoding is compatible with the string's encoding, and
  // 2. The write is synchronous, otherwise the string might get neutered
  //    while the request is in flight, and
  // 3. For UCS2, when the host system is little-endian.  Big-endian systems
  //    need to call StringBytes::Write() to ensure proper byte swapping.
  // The const_casts ...",2225.0,2313.0,1.0,4.0,89.0,91,18,106,36,0,0,6,9,0,0,,0,0,2,1,1,void
3682,179245,Read,1,node.fs.Read,void node.fs.Read (FunctionCallbackInfo<Value>),node_file.cc,"static void Read(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 5);

  CHECK(args[0]->IsInt32());
  const int fd = args[0].As<Int32>()->Value();

  CHECK(Buffer::HasInstance(args[1]));
  Local<Object> buffer_obj = args[1].As<Object>();
  char* buffer_data = Buffer::Data(buffer_obj);
  size_t buffer_length = Buffer::Length(buffer_obj);

  CHECK(IsSafeJsInt(args[2]));
  const int64_t off_64 = args[2].As<Integer>()->Value();
  CHECK_GE(off_64, 0);
  CHECK_LT(static_cast<uint64_t>(off_64), buffer_length);
  const size_t off = static_cast<size_t>(off_64);

  CHECK(args[3]->IsInt32());
  const size_t len = static_cast<size_t>(args[3].As<Int32>()->Value());
  CHECK(Buffer::IsWithinBounds(off, len, buffer_length));

  CHECK(IsSafeJsInt(args[4]) || args[4]->IsBigInt());
  const int64_t pos = args[4]->IsNumber() ?
                      args[4].As<Integer>()->Value() :
                      args...",2327.0,2373.0,1.0,4.0,47.0,84,18,88,30,0,0,2,2,0,0,,0,0,2,1,1,void
3683,179782,ReadBuffers,1,node.fs.ReadBuffers,void node.fs.ReadBuffers (FunctionCallbackInfo<Value>),node_file.cc,"static void ReadBuffers(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  CHECK(args[0]->IsInt32());
  const int fd = args[0].As<Int32>()->Value();

  CHECK(args[1]->IsArray());
  Local<Array> buffers = args[1].As<Array>();

  int64_t pos = GetOffset(args[2]);  // -1 if not a valid JS int

  MaybeStackBuffer<uv_buf_t> iovs(buffers->Length());

  // Init uv buffers from ArrayBufferViews
  for (uint32_t i = 0; i < iovs.length(); i++) {
    Local<Value> buffer = buffers->Get(env->context(), i).ToLocalChecked();
    CHECK(Buffer::HasInstance(buffer));
    iovs[i] = uv_buf_init(Buffer::Data(buffer), Buffer::Length(buffer));
  }

  FSReqBase* req_wrap_async = GetReqWrap(args, 3);
  if (req_wrap_async != nullptr) {  // readBuffers(fd, buffers, pos, req)
    FS_ASYNC_TRACE_BEGIN0(UV_FS_READ, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""read"", UTF8, AfterInteger,
             ...",2383.0,2420.0,1.0,4.0,38.0,67,15,77,29,0,0,3,3,0,0,,0,0,2,1,1,void
3684,180266,Chmod,1,node.fs.Chmod,void node.fs.Chmod (FunctionCallbackInfo<Value>),node_file.cc,"static void Chmod(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 2);

  BufferValue path(env->isolate(), args[0]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemWrite, path.ToStringView());

  CHECK(args[1]->IsInt32());
  int mode = args[1].As<Int32>()->Value();

  FSReqBase* req_wrap_async = GetReqWrap(args, 2);
  if (req_wrap_async != nullptr) {  // chmod(path, mode, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_CHMOD, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""chmod"", UTF8, AfterNoArgs,
              uv_fs_chmod, *path, mode);
  } else {  // chmod(path, mode, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(chmod);
    SyncCall(env, args[3], &req_wrap_sync, ""chmod"",
             uv_fs_chmod, *path, mode);
    FS_SYNC_TRACE_E...",2426.0,2454.0,1.0,4.0,29.0,49,13,58,21,0,0,2,2,0,0,,0,0,2,1,1,void
3685,180671,FChmod,1,node.fs.FChmod,void node.fs.FChmod (FunctionCallbackInfo<Value>),node_file.cc,"static void FChmod(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 2);

  CHECK(args[0]->IsInt32());
  const int fd = args[0].As<Int32>()->Value();

  CHECK(args[1]->IsInt32());
  const int mode = args[1].As<Int32>()->Value();

  FSReqBase* req_wrap_async = GetReqWrap(args, 2);
  if (req_wrap_async != nullptr) {  // fchmod(fd, mode, req)
    FS_ASYNC_TRACE_BEGIN0(UV_FS_FCHMOD, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""fchmod"", UTF8, AfterNoArgs,
              uv_fs_fchmod, fd, mode);
  } else {  // fchmod(fd, mode, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(fchmod);
    SyncCall(env, args[3], &req_wrap_sync, ""fchmod"",
             uv_fs_fchmod, fd, mode);
    FS_SYNC_TRACE_END(fchmod);
  }
}",2460.0,2485.0,1.0,4.0,26.0,45,13,51,19,0,0,2,2,0,0,,0,0,2,1,1,void
3686,181060,Chown,1,node.fs.Chown,void node.fs.Chown (FunctionCallbackInfo<Value>),node_file.cc,"static void Chown(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  BufferValue path(env->isolate(), args[0]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemWrite, path.ToStringView());

  CHECK(IsSafeJsInt(args[1]));
  const uv_uid_t uid = static_cast<uv_uid_t>(args[1].As<Integer>()->Value());

  CHECK(IsSafeJsInt(args[2]));
  const uv_gid_t gid = static_cast<uv_gid_t>(args[2].As<Integer>()->Value());

  FSReqBase* req_wrap_async = GetReqWrap(args, 3);
  if (req_wrap_async != nullptr) {  // chown(path, uid, gid, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_CHOWN, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""chown"", UTF8, AfterNoArgs,
              uv_fs_chown, *path, uid, gid);
  } else {  // chown(path, uid, gid, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync...",2491.0,2522.0,1.0,4.0,32.0,55,13,62,22,0,0,2,2,0,0,,0,0,2,1,1,void
3687,181486,FChown,1,node.fs.FChown,void node.fs.FChown (FunctionCallbackInfo<Value>),node_file.cc,"static void FChown(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  CHECK(args[0]->IsInt32());
  const int fd = args[0].As<Int32>()->Value();

  CHECK(IsSafeJsInt(args[1]));
  const uv_uid_t uid = static_cast<uv_uid_t>(args[1].As<Integer>()->Value());

  CHECK(IsSafeJsInt(args[2]));
  const uv_gid_t gid = static_cast<uv_gid_t>(args[2].As<Integer>()->Value());

  FSReqBase* req_wrap_async = GetReqWrap(args, 3);
  if (req_wrap_async != nullptr) {  // fchown(fd, uid, gid, req)
    FS_ASYNC_TRACE_BEGIN0(UV_FS_FCHOWN, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""fchown"", UTF8, AfterNoArgs,
              uv_fs_fchown, fd, uid, gid);
  } else {  // fchown(fd, uid, gid, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(fchown);
    SyncCall(env, args[4], &req_wrap_sync, ""fchown"",
             uv_fs_fchown, fd, uid, gid);
    FS_S...",2528.0,2556.0,1.0,4.0,29.0,51,13,55,20,0,0,2,2,0,0,,0,0,2,1,1,void
3688,181896,LChown,1,node.fs.LChown,void node.fs.LChown (FunctionCallbackInfo<Value>),node_file.cc,"static void LChown(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  BufferValue path(env->isolate(), args[0]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemWrite, path.ToStringView());

  CHECK(IsSafeJsInt(args[1]));
  const uv_uid_t uid = static_cast<uv_uid_t>(args[1].As<Integer>()->Value());

  CHECK(IsSafeJsInt(args[2]));
  const uv_gid_t gid = static_cast<uv_gid_t>(args[2].As<Integer>()->Value());

  FSReqBase* req_wrap_async = GetReqWrap(args, 3);
  if (req_wrap_async != nullptr) {  // lchown(path, uid, gid, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_LCHOWN, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""lchown"", UTF8, AfterNoArgs,
              uv_fs_lchown, *path, uid, gid);
  } else {  // lchown(path, uid, gid, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWr...",2559.0,2590.0,1.0,4.0,32.0,55,13,62,22,0,0,2,2,0,0,,0,0,2,1,1,void
3689,182322,UTimes,1,node.fs.UTimes,void node.fs.UTimes (FunctionCallbackInfo<Value>),node_file.cc,"static void UTimes(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  BufferValue path(env->isolate(), args[0]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemWrite, path.ToStringView());

  CHECK(args[1]->IsNumber());
  const double atime = args[1].As<Number>()->Value();

  CHECK(args[2]->IsNumber());
  const double mtime = args[2].As<Number>()->Value();

  FSReqBase* req_wrap_async = GetReqWrap(args, 3);
  if (req_wrap_async != nullptr) {  // utimes(path, atime, mtime, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_UTIME, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""utime"", UTF8, AfterNoArgs,
              uv_fs_utime, *path, atime, mtime);
  } else {  // utimes(path, atime, mtime, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_B...",2593.0,2624.0,1.0,4.0,32.0,55,13,62,22,0,0,2,2,0,0,,0,0,2,1,1,void
3690,182748,FUTimes,1,node.fs.FUTimes,void node.fs.FUTimes (FunctionCallbackInfo<Value>),node_file.cc,"static void FUTimes(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  CHECK(args[0]->IsInt32());
  const int fd = args[0].As<Int32>()->Value();

  CHECK(args[1]->IsNumber());
  const double atime = args[1].As<Number>()->Value();

  CHECK(args[2]->IsNumber());
  const double mtime = args[2].As<Number>()->Value();

  FSReqBase* req_wrap_async = GetReqWrap(args, 3);
  if (req_wrap_async != nullptr) {  // futimes(fd, atime, mtime, req)
    FS_ASYNC_TRACE_BEGIN0(UV_FS_FUTIME, req_wrap_async)
    AsyncCall(env, req_wrap_async, args, ""futime"", UTF8, AfterNoArgs,
              uv_fs_futime, fd, atime, mtime);
  } else {  // futimes(fd, atime, mtime, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(futimes);
    SyncCall(env, args[4], &req_wrap_sync, ""futime"",
             uv_fs_futime, fd, atime, mtime);
    FS_SYNC_TRACE_END(futimes);
  }
}",2626.0,2654.0,1.0,4.0,29.0,51,13,55,20,0,0,2,2,0,0,,0,0,2,1,1,void
3691,183158,LUTimes,1,node.fs.LUTimes,void node.fs.LUTimes (FunctionCallbackInfo<Value>),node_file.cc,"static void LUTimes(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  const int argc = args.Length();
  CHECK_GE(argc, 3);

  BufferValue path(env->isolate(), args[0]);
  CHECK_NOT_NULL(*path);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemWrite, path.ToStringView());

  CHECK(args[1]->IsNumber());
  const double atime = args[1].As<Number>()->Value();

  CHECK(args[2]->IsNumber());
  const double mtime = args[2].As<Number>()->Value();

  FSReqBase* req_wrap_async = GetReqWrap(args, 3);
  if (req_wrap_async != nullptr) {  // lutimes(path, atime, mtime, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_LUTIME, req_wrap_async, ""path"", TRACE_STR_COPY(*path))
    AsyncCall(env, req_wrap_async, args, ""lutime"", UTF8, AfterNoArgs,
              uv_fs_lutime, *path, atime, mtime);
  } else {  // lutimes(path, atime, mtime, undefined, ctx)
    CHECK_EQ(argc, 5);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_T...",2656.0,2687.0,1.0,4.0,32.0,55,13,62,22,0,0,2,2,0,0,,0,0,2,1,1,void
3692,183584,Mkdtemp,1,node.fs.Mkdtemp,void node.fs.Mkdtemp (FunctionCallbackInfo<Value>),node_file.cc,"static void Mkdtemp(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  const int argc = args.Length();
  CHECK_GE(argc, 2);

  BufferValue tmpl(isolate, args[0]);
  CHECK_NOT_NULL(*tmpl);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kFileSystemWrite, tmpl.ToStringView());

  const enum encoding encoding = ParseEncoding(isolate, args[1], UTF8);

  FSReqBase* req_wrap_async = GetReqWrap(args, 2);
  if (req_wrap_async != nullptr) {  // mkdtemp(tmpl, encoding, req)
    FS_ASYNC_TRACE_BEGIN1(
        UV_FS_MKDTEMP, req_wrap_async, ""path"", TRACE_STR_COPY(*tmpl))
    AsyncCall(env, req_wrap_async, args, ""mkdtemp"", encoding, AfterStringPath,
              uv_fs_mkdtemp, *tmpl);
  } else {  // mkdtemp(tmpl, encoding, undefined, ctx)
    CHECK_EQ(argc, 4);
    FSReqWrapSync req_wrap_sync;
    FS_SYNC_TRACE_BEGIN(mkdtemp);
    SyncCall(env, args[3], &req_wrap_sync, ""mkdtemp"",
   ...",2689.0,2728.0,1.0,4.0,40.0,46,13,60,22,0,0,2,2,0,0,,0,0,2,1,1,void
3693,184055,MemoryInfo,1,node.fs.BindingData.MemoryInfo,void node.fs.BindingData.MemoryInfo (MemoryTracker*),node_file.cc,"void BindingData::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackField(""stats_field_array"", stats_field_array);
  tracker->TrackField(""stats_field_bigint_array"", stats_field_bigint_array);
  tracker->TrackField(""statfs_field_array"", statfs_field_array);
  tracker->TrackField(""statfs_field_bigint_array"", statfs_field_bigint_array);
  tracker->TrackField(""file_handle_read_wrap_freelist"",
                      file_handle_read_wrap_freelist);
}",2730.0,2737.0,1.0,1.0,8.0,5,1,10,6,0,0,1,1,0,0,,0,0,2,1,1,void
3694,184090,BindingData,1,node.fs.BindingData.BindingData,"ANY node.fs.BindingData.BindingData (Realm*,ANY,InternalFieldInfo*)",node_file.cc,"BindingData::BindingData(Realm* realm,
                         v8::Local<v8::Object> wrap,
                         InternalFieldInfo* info)
    : SnapshotableObject(realm, wrap, type_int),
      stats_field_array(realm->isolate(),
                        kFsStatsBufferLength,
                        MAYBE_FIELD_PTR(info, stats_field_array)),
      stats_field_bigint_array(realm->isolate(),
                               kFsStatsBufferLength,
                               MAYBE_FIELD_PTR(info, stats_field_bigint_array)),
      statfs_field_array(realm->isolate(),
                         kFsStatFsBufferLength,
                         MAYBE_FIELD_PTR(info, statfs_field_array)),
      statfs_field_bigint_array(
          realm->isolate(),
          kFsStatFsBufferLength,
          MAYBE_FIELD_PTR(info, statfs_field_bigint_array)) {
  Isolate* isolate = realm->isolate();
  Local<Context> context = realm->context();

  if (info == nullptr) {
    wrap->Set(context,
              FIXED...",2739.0,2789.0,1.0,1.0,51.0,23,6,27,11,0,0,2,2,0,0,,0,0,6,3,3,ANY
3695,184229,Deserialize,1,node.fs.BindingData.Deserialize,"void node.fs.BindingData.Deserialize (Local<Context>,Local<Object>,int,InternalFieldInfoBase*)",node_file.cc,"void BindingData::Deserialize(Local<Context> context,
                              Local<Object> holder,
                              int index,
                              InternalFieldInfoBase* info) {
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  HandleScope scope(context->GetIsolate());
  Realm* realm = Realm::GetCurrent(context);
  InternalFieldInfo* casted_info = static_cast<InternalFieldInfo*>(info);
  BindingData* binding =
      realm->AddBindingData<BindingData>(context, holder, casted_info);
  CHECK_NOT_NULL(binding);
}",2791.0,2802.0,1.0,1.0,12.0,12,8,15,10,0,0,1,1,0,0,,0,0,8,4,4,void
3696,184278,PrepareForSerialization,1,node.fs.BindingData.PrepareForSerialization,"bool node.fs.BindingData.PrepareForSerialization (Local<Context>,ANY*)",node_file.cc,"bool BindingData::PrepareForSerialization(Local<Context> context,
                                          v8::SnapshotCreator* creator) {
  CHECK(file_handle_read_wrap_freelist.empty());
  DCHECK_NULL(internal_field_info_);
  internal_field_info_ = InternalFieldInfoBase::New<InternalFieldInfo>(type());
  internal_field_info_->stats_field_array =
      stats_field_array.Serialize(context, creator);
  internal_field_info_->stats_field_bigint_array =
      stats_field_bigint_array.Serialize(context, creator);
  internal_field_info_->statfs_field_array =
      statfs_field_array.Serialize(context, creator);
  internal_field_info_->statfs_field_bigint_array =
      statfs_field_bigint_array.Serialize(context, creator);
  // Return true because we need to maintain the reference to the binding from
  // JS land.
  return true;
}",2804.0,2820.0,1.0,1.0,17.0,17,5,20,10,0,0,1,1,0,0,,0,0,4,2,2,bool
3697,184341,Serialize,1,node.fs.BindingData.Serialize,InternalFieldInfoBase node.fs.BindingData.Serialize (int),node_file.cc,"InternalFieldInfoBase* BindingData::Serialize(int index) {
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  InternalFieldInfo* info = internal_field_info_;
  internal_field_info_ = nullptr;
  return info;
}",2822.0,2827.0,1.0,1.0,6.0,3,2,6,4,0,0,1,1,0,0,,0,0,2,1,1,InternalFieldInfoBase
3698,184360,CreatePerIsolateProperties,1,node.fs.CreatePerIsolateProperties,"void node.fs.CreatePerIsolateProperties (IsolateData*,Local<FunctionTemplate>)",node_file.cc,"static void CreatePerIsolateProperties(IsolateData* isolate_data,
                                       Local<FunctionTemplate> ctor) {
  Isolate* isolate = isolate_data->isolate();
  Local<ObjectTemplate> target = ctor->InstanceTemplate();

  SetMethod(isolate, target, ""access"", Access);
  SetMethod(isolate, target, ""close"", Close);
  SetMethod(isolate, target, ""open"", Open);
  SetMethod(isolate, target, ""openFileHandle"", OpenFileHandle);
  SetMethod(isolate, target, ""read"", Read);
  SetMethod(isolate, target, ""readBuffers"", ReadBuffers);
  SetMethod(isolate, target, ""fdatasync"", Fdatasync);
  SetMethod(isolate, target, ""fsync"", Fsync);
  SetMethod(isolate, target, ""rename"", Rename);
  SetMethod(isolate, target, ""ftruncate"", FTruncate);
  SetMethod(isolate, target, ""rmdir"", RMDir);
  SetMethod(isolate, target, ""mkdir"", MKDir);
  SetMethod(isolate, target, ""readdir"", ReadDir);
  SetMethod(isolate, target, ""internalModuleReadJSON"", InternalModuleReadJSON);
  SetMethod(isolate, targe...",2829.0,2932.0,1.0,1.0,104.0,83,6,189,25,0,0,1,1,0,0,,0,0,4,2,2,void
3699,184858,CreatePerContextProperties,1,node.fs.CreatePerContextProperties,"void node.fs.CreatePerContextProperties (Local<Object>,Local<Value>,Local<Context>,void*)",node_file.cc,"static void CreatePerContextProperties(Local<Object> target,
                                       Local<Value> unused,
                                       Local<Context> context,
                                       void* priv) {
  Realm* realm = Realm::GetCurrent(context);
  realm->AddBindingData<BindingData>(context, target);
}",2934.0,2940.0,1.0,1.0,7.0,7,7,7,5,0,0,1,1,0,0,,0,0,8,4,4,void
3700,184884,binding_data,1,node.fs.FSReqBase.binding_data,BindingData node.fs.FSReqBase.binding_data (),node_file.cc,"BindingData* FSReqBase::binding_data() {
  return binding_data_.get();
}",2942.0,2944.0,1.0,1.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,BindingData
3701,184893,RegisterExternalReferences,1,node.fs.RegisterExternalReferences,void node.fs.RegisterExternalReferences (ExternalReferenceRegistry*),node_file.cc,"void RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  registry->Register(Access);
  StatWatcher::RegisterExternalReferences(registry);

  registry->Register(Close);
  registry->Register(Open);
  registry->Register(OpenFileHandle);
  registry->Register(Read);
  registry->Register(ReadBuffers);
  registry->Register(Fdatasync);
  registry->Register(Fsync);
  registry->Register(Rename);
  registry->Register(FTruncate);
  registry->Register(RMDir);
  registry->Register(MKDir);
  registry->Register(ReadDir);
  registry->Register(InternalModuleReadJSON);
  registry->Register(InternalModuleStat);
  registry->Register(Stat);
  registry->Register(LStat);
  registry->Register(FStat);
  registry->Register(StatFs);
  registry->Register(Link);
  registry->Register(Symlink);
  registry->Register(ReadLink);
  registry->Register(Unlink);
  registry->Register(WriteBuffer);
  registry->Register(WriteBuffers);
  registry->Register(WriteString);
  registry->Register(RealPath);
  regis...",2946.0,2996.0,1.0,1.0,51.0,46,2,48,4,0,0,1,1,0,0,,0,0,2,1,1,void
3702,185136,<lambda>0,1,node.http2.Http2Stream.EmitStatistics.<lambda>0,ANY node.http2.Http2Stream.EmitStatistics.<lambda>0 (Environment*),node_http2.cc,"[entry = std::move(entry)](Environment* env) {
    if (HasHttp2Observer(env))
      entry->Notify(env);
  }",646.0,649.0,23.0,3.0,4.0,1,1,3,2,0,0,2,2,0,0,,0,0,2,1,1,ANY
3703,185152,<lambda>1,1,node.http2.Http2Session.EmitStatistics.<lambda>1,ANY node.http2.Http2Session.EmitStatistics.<lambda>1 (Environment*),node_http2.cc,"[entry = std::move(entry)](Environment* env) {
    if (HasHttp2Observer(env))
      entry->Notify(env);
  }",666.0,669.0,23.0,3.0,4.0,1,1,3,2,0,0,2,2,0,0,,0,0,2,1,1,ANY
3704,185167,<lambda>2,1,node.http2.Http2Session.Close.<lambda>2,ANY node.http2.Http2Session.Close.<lambda>2 (Environment*),node_http2.cc,"[ping = std::move(ping)](Environment* env) {
          ping->Done(false);
        }",718.0,720.0,9.0,9.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,ANY
3705,185178,<lambda>3,1,node.http2.Http2Session.HandleHeadersFrame.<lambda>3,"ANY node.http2.Http2Session.HandleHeadersFrame.<lambda>3 (Http2Header,size_t)",node_http2.cc,"[&](const Http2Header& header, size_t i) {
    headers_v[i * 2] = header.GetName(this).ToLocalChecked();
    headers_v[i * 2 + 1] = header.GetValue(this).ToLocalChecked();
    if (header.flags() & NGHTTP2_NV_FLAG_NO_INDEX)
      sensitive_v[sensitive_count++] = headers_v[i * 2];
  }",1352.0,1357.0,27.0,3.0,6.0,18,7,12,6,0,0,2,2,0,0,,0,0,4,2,2,ANY
3706,185236,<lambda>4,1,node.http2.Http2Session.MaybeScheduleWrite.<lambda>4,ANY node.http2.Http2Session.MaybeScheduleWrite.<lambda>4 (Environment*),node_http2.cc,"[this, strong_ref](Environment* env) {
      if (!session_ || !is_write_scheduled()) {
        // This can happen e.g. when a stream was reset before this turn
        // of the event loop, in which case SendPendingData() is called early,
        // or the session was destroyed in the meantime.
        return;
      }

      // Sending data may call arbitrary JS code, so keep track of
      // async context.
      if (env->can_call_into_js()) {
        HandleScope handle_scope(env->isolate());
        InternalCallbackScope callback_scope(this);
        SendPendingData();
      }
    }",1628.0,1643.0,25.0,5.0,16.0,5,3,3,2,0,0,3,3,0,0,,0,0,2,1,1,ANY
3707,185266,<lambda>5,1,node.http2.Http2Stream.Destroy.<lambda>5,ANY node.http2.Http2Stream.Destroy.<lambda>5 (Environment*),node_http2.cc,"[this, strong_ref = std::move(strong_ref)](
        Environment* env) {
      // Free any remaining outgoing data chunks here. This should be done
      // here because it's possible for destroy to have been called while
      // we still have queued outbound writes.
      while (!queue_.empty()) {
        NgHttp2StreamWrite& head = queue_.front();
        if (head.req_wrap)
          WriteWrap::FromObject(head.req_wrap)->Done(UV_ECANCELED);
        queue_.pop();
      }

      // We can destroy the stream now if there are no writes for it
      // already on the socket. Otherwise, we'll wait for the garbage collector
      // to take care of cleaning up.
      if (session() == nullptr ||
          !session()->HasWritesOnSocketForStream(this)) {
        // Delete once strong_ref goes out of scope.
        Detach();
      }
    }",2140.0,2160.0,25.0,5.0,21.0,13,6,8,4,0,0,4,5,0,0,,0,0,2,1,1,ANY
3708,185319,<lambda>6,1,node.http2.Http2Stream.SubmitRstStream.<lambda>6,ANY node.http2.Http2Stream.SubmitRstStream.<lambda>6 (uint32_t),node_http2.cc,"[](const uint32_t code) {
    return code == NGHTTP2_CANCEL;
  }",2275.0,2277.0,27.0,3.0,3.0,1,1,2,2,0,0,1,1,0,0,,0,0,2,1,1,ANY
3709,185378,HasHttp2Observer,1,node.http2.anonymous_namespace_1.HasHttp2Observer,bool node.http2.anonymous_namespace_1.HasHttp2Observer (Environment*),node_http2.cc,"bool HasHttp2Observer(Environment* env) {
  AliasedUint32Array& observers = env->performance_state()->observers;
  return observers[performance::NODE_PERFORMANCE_ENTRY_TYPE_HTTP2] != 0;
}",54.0,57.0,1.0,1.0,4.0,6,5,4,3,0,0,1,1,0,0,,0,0,2,1,1,bool
3710,185408,Http2Scope,1,node.http2.Http2Scope.Http2Scope,ANY node.http2.Http2Scope.Http2Scope (Http2Stream*),node_http2.cc,"Http2Scope::Http2Scope(Http2Session* session) : session_(session) {
  if (!session_) return;

  // If there is another scope further below on the stack, or
  // a write is already scheduled, there's nothing to do.
  if (session_->is_in_scope() || session_->is_write_scheduled()) {
    session_.reset();
    return;
  }
  session_->set_in_scope();
}",81.0,91.0,1.0,1.0,11.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
3711,185443,~Http2Scope,1,node.http2.Http2Scope.~Http2Scope,ANY node.http2.Http2Scope.~Http2Scope (),node_http2.cc,"Http2Scope::~Http2Scope() {
  if (!session_) return;
  session_->set_in_scope(false);
  if (!session_->is_write_scheduled())
    session_->MaybeScheduleWrite();
}",93.0,98.0,1.0,1.0,6.0,5,2,4,1,0,0,3,3,0,0,,0,0,0,0,0,ANY
3712,185468,Http2Options,1,node.http2.Http2Options.Http2Options,"ANY node.http2.Http2Options.Http2Options (Http2State*,SessionType)",node_http2.cc,"Http2Options::Http2Options(Http2State* http2_state, SessionType type) {
  nghttp2_option* option;
  CHECK_EQ(nghttp2_option_new(&option), 0);
  CHECK_NOT_NULL(option);
  options_.reset(option);

  // Make sure closed connections aren't kept around, taking up memory.
  // Note that this breaks the priority tree, which we don't use.
  nghttp2_option_set_no_closed_streams(option, 1);

  // We manually handle flow control within a session in order to
  // implement backpressure -- that is, we only send WINDOW_UPDATE
  // frames to the remote peer as data is actually consumed by user
  // code. This ensures that the flow of data over the connection
  // does not move too quickly and limits the amount of data we
  // are required to buffer.
  nghttp2_option_set_no_auto_window_update(option, 1);

  // Enable built in support for receiving ALTSVC and ORIGIN frames (but
  // only on client side sessions
  if (type == NGHTTP2_SESSION_CLIENT) {
    nghttp2_option_set_builtin_recv_extension_typ...",104.0,209.0,1.0,1.0,106.0,42,10,65,21,0,0,12,12,0,0,,0,0,4,2,2,ANY
3713,185648,Init,1,node.http2.Http2Settings.Init,"size_t node.http2.Http2Settings.Init (Http2State*,nghttp2_settings_entry*)",node_http2.cc,"size_t Http2Settings::Init(
    Http2State* http2_state,
    nghttp2_settings_entry* entries) {
  AliasedUint32Array& buffer = http2_state->settings_buffer;
  uint32_t flags = buffer[IDX_SETTINGS_COUNT];

  size_t count = 0;

#define V(name) GRABSETTING(entries, count, name);
  HTTP2_SETTINGS(V)
#undef V

  return count;
}",219.0,232.0,1.0,1.0,14.0,5,3,7,5,0,0,1,1,0,0,,0,0,4,2,2,size_t
3714,185674,Http2Settings,1,node.http2.Http2Settings.Http2Settings,"ANY node.http2.Http2Settings.Http2Settings (Http2Session*,Local<Object>,Local<Function>,uint64_t)",node_http2.cc,"Http2Settings::Http2Settings(Http2Session* session,
                             Local<Object> obj,
                             Local<Function> callback,
                             uint64_t start_time)
    : AsyncWrap(session->env(), obj, PROVIDER_HTTP2SETTINGS),
      session_(session),
      startTime_(start_time) {
  callback_.Reset(env()->isolate(), callback);
  count_ = Init(session->http2_state(), entries_);
}",238.0,247.0,1.0,1.0,10.0,4,3,5,5,0,0,1,1,0,0,,0,0,8,4,4,ANY
3715,185699,callback,1,node.http2.Http2Settings.callback,Local<Function> node.http2.Http2Settings.callback (),node_http2.cc,"Local<Function> Http2Settings::callback() const {
  return callback_.Get(env()->isolate());
}",249.0,251.0,1.0,1.0,3.0,2,2,1,1,0,0,1,1,0,0,,0,0,0,0,0,Local<Function>
3716,185712,MemoryInfo,1,node.http2.Http2Settings.MemoryInfo,void node.http2.Http2Settings.MemoryInfo (MemoryTracker*),node_http2.cc,"void Http2Settings::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackField(""callback"", callback_);
}",253.0,255.0,1.0,1.0,3.0,1,1,2,2,0,0,1,1,0,0,,0,0,2,1,1,void
3717,185723,Pack,1,node.http2.Http2Settings.Pack,Local<Value> node.http2.Http2Settings.Pack (),node_http2.cc,"Local<Value> Http2Settings::Pack(
    Environment* env,
    size_t count,
    const nghttp2_settings_entry* entries) {
  EscapableHandleScope scope(env->isolate());
  std::unique_ptr<BackingStore> bs;
  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs = ArrayBuffer::NewBackingStore(env->isolate(), count * 6);
  }
  if (nghttp2_pack_settings_payload(static_cast<uint8_t*>(bs->Data()),
                                    bs->ByteLength(),
                                    entries,
                                    count) < 0) {
    return scope.Escape(Undefined(env->isolate()));
  }
  Local<ArrayBuffer> ab = ArrayBuffer::New(env->isolate(), std::move(bs));
  return scope.Escape(Buffer::New(env, ab, 0, ab->ByteLength())
                          .FromMaybe(Local<Value>()));
}",270.0,289.0,1.0,1.0,20.0,1,1,3,3,0,0,1,1,0,0,,0,0,6,3,3,Local<Value>
3718,185861,Update,1,node.http2.Http2Settings.Update,"void node.http2.Http2Settings.Update (Http2Session*,get_setting)",node_http2.cc,"void Http2Settings::Update(Http2Session* session, get_setting fn) {
  AliasedUint32Array& buffer = session->http2_state()->settings_buffer;

#define V(name)                                                                \
  buffer[IDX_SETTINGS_ ## name] =                                              \
      fn(session->session(), NGHTTP2_SETTINGS_ ## name);
  HTTP2_SETTINGS(V)
#undef V
}",293.0,301.0,1.0,1.0,9.0,3,2,2,2,0,0,1,1,0,0,,0,0,4,2,2,void
3719,185878,RefreshDefaults,1,node.http2.Http2Settings.RefreshDefaults,void node.http2.Http2Settings.RefreshDefaults (Http2State*),node_http2.cc,"void Http2Settings::RefreshDefaults(Http2State* http2_state) {
  AliasedUint32Array& buffer = http2_state->settings_buffer;
  uint32_t flags = 0;

#define V(name)                                                            \
  do {                                                                     \
    buffer[IDX_SETTINGS_ ## name] = DEFAULT_SETTINGS_ ## name;             \
    flags |= 1 << IDX_SETTINGS_ ## name;                                   \
  } while (0);
  HTTP2_SETTINGS(V)
#undef V

  buffer[IDX_SETTINGS_COUNT] = flags;
}",304.0,317.0,1.0,1.0,14.0,5,3,6,4,0,0,1,1,0,0,,0,0,2,1,1,void
3720,185900,Send,1,node.http2.Http2Settings.Send,void node.http2.Http2Settings.Send (),node_http2.cc,"void Http2Settings::Send() {
  Http2Scope h2scope(session_.get());
  CHECK_EQ(nghttp2_submit_settings(
      session_->session(),
      NGHTTP2_FLAG_NONE,
      &entries_[0],
      count_), 0);
}",320.0,327.0,1.0,1.0,8.0,4,4,5,4,0,0,1,1,0,0,,0,0,0,0,0,void
3721,185923,Done,1,node.http2.Http2Settings.Done,void node.http2.Http2Settings.Done (bool),node_http2.cc,"void Http2Settings::Done(bool ack) {
  uint64_t end = uv_hrtime();
  double duration = (end - startTime_) / 1e6;

  Local<Value> argv[] = {Boolean::New(env()->isolate(), ack),
                         Number::New(env()->isolate(), duration)};
  MakeCallback(callback(), arraysize(argv), argv);
}",329.0,336.0,1.0,1.0,8.0,10,6,11,7,0,0,1,1,0,0,,0,0,2,1,1,void
3722,185967,Http2Priority,1,node.http2.Http2Priority.Http2Priority,"ANY node.http2.Http2Priority.Http2Priority (Environment*,Local<Value>,Local<Value>,Local<Value>)",node_http2.cc,"Http2Priority::Http2Priority(Environment* env,
                             Local<Value> parent,
                             Local<Value> weight,
                             Local<Value> exclusive) {
  Local<Context> context = env->context();
  int32_t parent_ = parent->Int32Value(context).ToChecked();
  int32_t weight_ = weight->Int32Value(context).ToChecked();
  bool exclusive_ = exclusive->IsTrue();
  Debug(env, DebugCategory::HTTP2STREAM,
        ""Http2Priority: parent: %d, weight: %d, exclusive: %s\n"",
        parent_, weight_, exclusive_ ? ""yes"" : ""no"");
  nghttp2_priority_spec_init(this, parent_, weight_, exclusive_ ? 1 : 0);
}",341.0,353.0,1.0,1.0,13.0,15,6,20,11,0,0,1,1,0,0,,0,0,8,4,4,ANY
3723,186034,TypeName,1,node.http2.Http2Session.TypeName,const char* node.http2.Http2Session.TypeName (),node_http2.cc,"const char* Http2Session::TypeName() const {
  switch (session_type_) {
    case NGHTTP2_SESSION_SERVER: return ""server"";
    case NGHTTP2_SESSION_CLIENT: return ""client"";
    default:
      // This should never happen
      ABORT();
  }
}",356.0,364.0,1.0,1.0,9.0,0,0,3,3,0,0,2,2,0,0,,0,0,0,0,0,const char*
3724,186051,Origins,1,node.http2.Origins.Origins,"ANY node.http2.Origins.Origins (Environment*,Local<String>,size_t)",node_http2.cc,"Origins::Origins(
    Environment* env,
    Local<String> origin_string,
    size_t origin_count)
    : count_(origin_count) {
  int origin_string_len = origin_string->Length();
  if (count_ == 0) {
    CHECK_EQ(origin_string_len, 0);
    return;
  }

  {
    NoArrayBufferZeroFillScope no_zero_fill_scope(env->isolate_data());
    bs_ = ArrayBuffer::NewBackingStore(env->isolate(),
                                       alignof(nghttp2_origin_entry) - 1 +
                                       count_ * sizeof(nghttp2_origin_entry) +
                                       origin_string_len);
  }

  // Make sure the start address is aligned appropriately for an nghttp2_nv*.
  char* start = AlignUp(static_cast<char*>(bs_->Data()),
                        alignof(nghttp2_origin_entry));
  char* origin_contents = start + (count_ * sizeof(nghttp2_origin_entry));
  nghttp2_origin_entry* const nva =
      reinterpret_cast<nghttp2_origin_entry*>(start);

  CHECK_LE(origin_contents + origin_str...",366.0,417.0,1.0,1.0,52.0,57,14,53,14,0,0,4,5,0,0,,0,0,6,3,3,ANY
3725,186234,Callbacks,1,node.http2.Http2Session.Callbacks.Callbacks,ANY node.http2.Http2Session.Callbacks.Callbacks (bool),node_http2.cc,"Http2Session::Callbacks::Callbacks(bool kHasGetPaddingCallback) {
  nghttp2_session_callbacks* callbacks_;
  CHECK_EQ(nghttp2_session_callbacks_new(&callbacks_), 0);
  callbacks.reset(callbacks_);

  nghttp2_session_callbacks_set_on_begin_headers_callback(
    callbacks_, OnBeginHeadersCallback);
  nghttp2_session_callbacks_set_on_header_callback2(
    callbacks_, OnHeaderCallback);
  nghttp2_session_callbacks_set_on_frame_recv_callback(
    callbacks_, OnFrameReceive);
  nghttp2_session_callbacks_set_on_stream_close_callback(
    callbacks_, OnStreamClose);
  nghttp2_session_callbacks_set_on_data_chunk_recv_callback(
    callbacks_, OnDataChunkReceived);
  nghttp2_session_callbacks_set_on_frame_not_send_callback(
    callbacks_, OnFrameNotSent);
  nghttp2_session_callbacks_set_on_invalid_header_callback2(
    callbacks_, OnInvalidHeader);
  nghttp2_session_callbacks_set_error_callback2(callbacks_, OnNghttpError);
  nghttp2_session_callbacks_set_send_data_callback(
    callbacks_, O...",421.0,452.0,1.0,1.0,32.0,2,2,28,15,0,0,2,2,0,0,,0,0,2,1,1,ANY
3726,186289,StopTrackingRcbuf,1,node.http2.Http2Session.StopTrackingRcbuf,void node.http2.Http2Session.StopTrackingRcbuf (nghttp2_rcbuf*),node_http2.cc,"void Http2Session::StopTrackingRcbuf(nghttp2_rcbuf* buf) {
  StopTrackingMemory(buf);
}",454.0,456.0,1.0,1.0,3.0,0,0,1,1,0,0,1,1,0,0,,0,0,2,1,1,void
3727,186296,CheckAllocatedSize,1,node.http2.Http2Session.CheckAllocatedSize,void node.http2.Http2Session.CheckAllocatedSize (size_t),node_http2.cc,"void Http2Session::CheckAllocatedSize(size_t previous_size) const {
  CHECK_GE(current_nghttp2_memory_, previous_size);
}",458.0,460.0,1.0,1.0,3.0,0,0,2,2,0,0,1,1,0,0,,0,0,2,1,1,void
3728,186304,IncreaseAllocatedSize,1,node.http2.Http2Session.IncreaseAllocatedSize,void node.http2.Http2Session.IncreaseAllocatedSize (size_t),node_http2.cc,"void Http2Session::IncreaseAllocatedSize(size_t size) {
  current_nghttp2_memory_ += size;
}",462.0,464.0,1.0,1.0,3.0,1,1,2,2,0,0,1,1,0,0,,0,0,2,1,1,void
3729,186312,DecreaseAllocatedSize,1,node.http2.Http2Session.DecreaseAllocatedSize,void node.http2.Http2Session.DecreaseAllocatedSize (size_t),node_http2.cc,"void Http2Session::DecreaseAllocatedSize(size_t size) {
  current_nghttp2_memory_ -= size;
}",466.0,468.0,1.0,1.0,3.0,1,1,2,2,0,0,1,1,0,0,,0,0,2,1,1,void
3730,186320,Http2Session,1,node.http2.Http2Session.Http2Session,"ANY node.http2.Http2Session.Http2Session (Http2State*,Local<Object>,SessionType)",node_http2.cc,"Http2Session::Http2Session(Http2State* http2_state,
                           Local<Object> wrap,
                           SessionType type)
    : AsyncWrap(http2_state->env(), wrap, AsyncWrap::PROVIDER_HTTP2SESSION),
      js_fields_(http2_state->env()->isolate()),
      session_type_(type),
      http2_state_(http2_state) {
  MakeWeak();
  statistics_.session_type = type;
  statistics_.start_time = uv_hrtime();

  // Capture the configuration options for this session
  Http2Options opts(http2_state, type);

  max_session_memory_ = opts.max_session_memory();

  uint32_t maxHeaderPairs = opts.max_header_pairs();
  max_header_pairs_ =
      type == NGHTTP2_SESSION_SERVER
          ? GetServerMaxHeaderPairs(maxHeaderPairs)
          : GetClientMaxHeaderPairs(maxHeaderPairs);

  max_outstanding_pings_ = opts.max_outstanding_pings();
  max_outstanding_settings_ = opts.max_outstanding_settings();

  padding_strategy_ = opts.padding_strategy();

  bool hasGetPaddingCallback =
      pad...",470.0,526.0,1.0,1.0,57.0,41,11,46,28,0,0,1,1,0,0,,0,0,6,3,3,ANY
3731,186469,~Http2Session,1,node.http2.Http2Session.~Http2Session,ANY node.http2.Http2Session.~Http2Session (),node_http2.cc,"Http2Session::~Http2Session() {
  CHECK(!is_in_scope());
  Debug(this, ""freeing nghttp2 session"");
  // Explicitly reset session_ so the subsequent
  // current_nghttp2_memory_ check passes.
  session_.reset();
  CHECK_EQ(current_nghttp2_memory_, 0);
}",528.0,535.0,1.0,1.0,8.0,2,2,2,2,0,0,1,1,0,0,,0,0,0,0,0,ANY
3732,186486,MemoryInfo,1,node.http2.Http2Session.MemoryInfo,void node.http2.Http2Session.MemoryInfo (MemoryTracker*),node_http2.cc,"void Http2Session::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackField(""streams"", streams_);
  tracker->TrackField(""outstanding_pings"", outstanding_pings_);
  tracker->TrackField(""outstanding_settings"", outstanding_settings_);
  tracker->TrackField(""outgoing_buffers"", outgoing_buffers_);
  tracker->TrackFieldWithSize(""stream_buf"", stream_buf_.len);
  tracker->TrackFieldWithSize(""outgoing_storage"", outgoing_storage_.size());
  tracker->TrackFieldWithSize(""pending_rst_streams"",
                              pending_rst_streams_.size() * sizeof(int32_t));
  tracker->TrackFieldWithSize(""nghttp2_memory"", current_nghttp2_memory_);
}",537.0,547.0,1.0,1.0,11.0,13,4,17,10,0,0,1,1,0,0,,0,0,2,1,1,void
3733,186550,diagnostic_name,1,node.http2.Http2Session.diagnostic_name,string node.http2.Http2Session.diagnostic_name (),node_http2.cc,"std::string Http2Session::diagnostic_name() const {
  return std::string(""Http2Session "") + TypeName() + "" ("" +
      std::to_string(static_cast<int64_t>(get_async_id())) + "")"";
}",549.0,552.0,1.0,1.0,4.0,7,3,2,1,0,0,1,1,0,0,,0,0,0,0,0,string
3734,186574,GetDetails,1,node.http2.Http2StreamPerformanceEntryTraits.GetDetails,"MaybeLocal<Object> node.http2.Http2StreamPerformanceEntryTraits.GetDetails (Environment*,Http2StreamPerformanceEntry)",node_http2.cc,"MaybeLocal<Object> Http2StreamPerformanceEntryTraits::GetDetails(
    Environment* env,
    const Http2StreamPerformanceEntry& entry) {
  Local<Object> obj = Object::New(env->isolate());

#define SET(name, val)                                                         \
  if (!obj->Set(                                                               \
          env->context(),                                                      \
          env->name(),                                                         \
          Number::New(                                                         \
            env->isolate(),                                                    \
            static_cast<double>(entry.details.val))).IsJust()) {               \
    return MaybeLocal<Object>();                                               \
  }

  SET(bytes_read_string, received_bytes)
  SET(bytes_written_string, sent_bytes)
  SET(id_string, id)
#undef SET

#define SET(name, val)                    ...",554.0,591.0,1.0,2.0,38.0,74,9,45,11,0,0,1,1,0,0,,0,0,4,2,2,MaybeLocal<Object>
3735,186836,GetDetails,1,node.http2.Http2SessionPerformanceEntryTraits.GetDetails,"MaybeLocal<Object> node.http2.Http2SessionPerformanceEntryTraits.GetDetails (Environment*,Http2SessionPerformanceEntry)",node_http2.cc,"MaybeLocal<Object> Http2SessionPerformanceEntryTraits::GetDetails(
    Environment* env,
    const Http2SessionPerformanceEntry& entry) {
  Local<Object> obj = Object::New(env->isolate());

#define SET(name, val)                                                         \
  if (!obj->Set(                                                               \
          env->context(),                                                      \
          env->name(),                                                         \
          Number::New(                                                         \
            env->isolate(),                                                    \
            static_cast<double>(entry.details.val))).IsJust()) {               \
    return MaybeLocal<Object>();                                               \
  }

  SET(bytes_written_string, data_sent)
  SET(bytes_read_string, data_received)
  SET(frames_received_string, frame_count)
  SET(frames_sent_string, frame_...",593.0,629.0,1.0,2.0,37.0,95,9,60,14,0,0,2,2,0,0,,0,0,4,2,2,MaybeLocal<Object>
3736,187189,EmitStatistics,1,node.http2.Http2Stream.EmitStatistics,void node.http2.Http2Stream.EmitStatistics (),node_http2.cc,"void Http2Stream::EmitStatistics() {
  CHECK_NOT_NULL(session());
  if (LIKELY(!HasHttp2Observer(env())))
    return;

  double start = statistics_.start_time / 1e6;
  double duration = (PERFORMANCE_NOW() / 1e6) - start;

  std::unique_ptr<Http2StreamPerformanceEntry> entry =
      std::make_unique<Http2StreamPerformanceEntry>(
          ""Http2Stream"",
          start - (env()->time_origin() / 1e6),
          duration,
          statistics_);

  env()->SetImmediate([entry = std::move(entry)](Environment* env) {
    if (HasHttp2Observer(env))
      entry->Notify(env);
  });
}",631.0,650.0,1.0,1.0,20.0,20,10,12,6,0,0,2,2,0,0,,0,0,0,0,0,void
3737,187249,EmitStatistics,1,node.http2.Http2Session.EmitStatistics,void node.http2.Http2Session.EmitStatistics (),node_http2.cc,"void Http2Session::EmitStatistics() {
  if (LIKELY(!HasHttp2Observer(env())))
    return;

  double start = statistics_.start_time / 1e6;
  double duration = (PERFORMANCE_NOW() / 1e6) - start;

  std::unique_ptr<Http2SessionPerformanceEntry> entry =
      std::make_unique<Http2SessionPerformanceEntry>(
          ""Http2Session"",
          start - (env()->time_origin() / 1e6),
          duration,
          statistics_);

  env()->SetImmediate([entry = std::move(entry)](Environment* env) {
    if (HasHttp2Observer(env))
      entry->Notify(env);
  });
}",652.0,670.0,1.0,1.0,19.0,20,10,12,6,0,0,2,2,0,0,,0,0,0,0,0,void
3738,187308,Close,1,node.http2.Http2Session.Close,"void node.http2.Http2Session.Close (uint32_t,bool)",node_http2.cc,"void Http2Session::Close(uint32_t code, bool socket_closed) {
  Debug(this, ""closing session"");

  if (is_closing())
    return;
  set_closing();

  // Stop reading on the i/o stream
  if (stream_ != nullptr) {
    set_reading_stopped();
    stream_->ReadStop();
  }

  // If the socket is not closed, then attempt to send a closing GOAWAY
  // frame. There is no guarantee that this GOAWAY will be received by
  // the peer but the HTTP/2 spec recommends sending it anyway. We'll
  // make a best effort.
  if (!socket_closed) {
    Debug(this, ""terminating session with code %d"", code);
    CHECK_EQ(nghttp2_session_terminate_session(session_.get(), code), 0);
    SendPendingData();
  } else if (stream_ != nullptr) {
    stream_->RemoveStreamListener(this);
  }

  set_destroyed();

  // If we are writing we will get to make the callback in OnStreamAfterWrite.
  if (!is_write_in_progress()) {
    Debug(this, ""make done session callback"");
    HandleScope scope(env()->isolate());
    MakeCa...",673.0,725.0,1.0,1.0,53.0,16,7,13,8,0,0,7,8,0,0,,0,0,4,2,2,void
3739,187417,FindStream,1,node.http2.Http2Session.FindStream,BaseObjectPtr<Http2Stream> node.http2.Http2Session.FindStream (int32_t),node_http2.cc,"BaseObjectPtr<Http2Stream> Http2Session::FindStream(int32_t id) {
  auto s = streams_.find(id);
  return s != streams_.end() ? s->second : BaseObjectPtr<Http2Stream>();
}",729.0,732.0,1.0,1.0,4.0,6,5,6,3,0,0,1,1,0,0,,0,0,2,1,1,BaseObjectPtr<Http2Stream>
3740,187442,CanAddStream,1,node.http2.Http2Session.CanAddStream,bool node.http2.Http2Session.CanAddStream (),node_http2.cc,"bool Http2Session::CanAddStream() {
  uint32_t maxConcurrentStreams =
      nghttp2_session_get_local_settings(
          session_.get(), NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS);
  size_t maxSize =
      std::min(streams_.max_size(), static_cast<size_t>(maxConcurrentStreams));
  // We can add a new stream so long as we are less than the current
  // maximum on concurrent streams and there's enough available memory
  return streams_.size() < maxSize &&
         has_available_session_memory(sizeof(Http2Stream));
}",734.0,744.0,1.0,1.0,11.0,10,6,10,7,0,0,1,1,0,0,,0,0,0,0,0,bool
3741,187480,AddStream,1,node.http2.Http2Session.AddStream,void node.http2.Http2Session.AddStream (Http2Stream*),node_http2.cc,"void Http2Session::AddStream(Http2Stream* stream) {
  CHECK_GE(++statistics_.stream_count, 0);
  streams_[stream->id()] = BaseObjectPtr<Http2Stream>(stream);
  size_t size = streams_.size();
  if (size > statistics_.max_concurrent_streams)
    statistics_.max_concurrent_streams = size;
  IncrementCurrentSessionMemory(sizeof(*stream));
}",746.0,753.0,1.0,1.0,8.0,15,9,13,6,0,0,2,2,0,0,,0,0,2,1,1,void
3742,187526,RemoveStream,1,node.http2.Http2Session.RemoveStream,BaseObjectPtr<Http2Stream> node.http2.Http2Session.RemoveStream (int32_t),node_http2.cc,"BaseObjectPtr<Http2Stream> Http2Session::RemoveStream(int32_t id) {
  BaseObjectPtr<Http2Stream> stream;
  if (streams_.empty())
    return stream;
  stream = FindStream(id);
  if (stream) {
    streams_.erase(id);
    DecrementCurrentSessionMemory(sizeof(*stream));
  }
  return stream;
}",756.0,766.0,1.0,1.0,11.0,7,6,12,5,0,0,3,3,0,0,,0,0,2,1,1,BaseObjectPtr<Http2Stream>
3743,187562,OnDWordAlignedPadding,1,node.http2.Http2Session.OnDWordAlignedPadding,"ssize_t node.http2.Http2Session.OnDWordAlignedPadding (size_t,size_t)",node_http2.cc,"ssize_t Http2Session::OnDWordAlignedPadding(size_t frameLen,
                                            size_t maxPayloadLen) {
  size_t r = (frameLen + 9) % 8;
  if (r == 0) return frameLen;  // If already a multiple of 8, return.

  size_t pad = frameLen + (8 - r);

  // If maxPayloadLen happens to be less than the calculated pad length,
  // use the max instead, even tho this means the frame will not be
  // aligned.
  pad = std::min(maxPayloadLen, pad);
  Debug(this, ""using frame size padding: %d"", pad);
  return pad;
}",772.0,785.0,1.0,1.0,14.0,9,6,13,5,0,0,2,2,0,0,,0,0,4,2,2,ssize_t
3744,187605,OnMaxFrameSizePadding,1,node.http2.Http2Session.OnMaxFrameSizePadding,"ssize_t node.http2.Http2Session.OnMaxFrameSizePadding (size_t,size_t)",node_http2.cc,"ssize_t Http2Session::OnMaxFrameSizePadding(size_t frameLen,
                                            size_t maxPayloadLen) {
  Debug(this, ""using max frame size padding: %d"", maxPayloadLen);
  return maxPayloadLen;
}",789.0,793.0,1.0,1.0,5.0,0,0,2,1,0,0,1,1,0,0,,0,0,4,2,2,ssize_t
3745,187617,ConsumeHTTP2Data,1,node.http2.Http2Session.ConsumeHTTP2Data,void node.http2.Http2Session.ConsumeHTTP2Data (),node_http2.cc,"void Http2Session::ConsumeHTTP2Data() {
  CHECK_NOT_NULL(stream_buf_.base);
  CHECK_LE(stream_buf_offset_, stream_buf_.len);
  size_t read_len = stream_buf_.len - stream_buf_offset_;

  // multiple side effects.
  Debug(this, ""receiving %d bytes [wants data? %d]"",
        read_len,
        nghttp2_session_want_read(session_.get()));
  set_receive_paused(false);
  custom_recv_error_code_ = nullptr;
  ssize_t ret =
    nghttp2_session_mem_recv(session_.get(),
                             reinterpret_cast<uint8_t*>(stream_buf_.base) +
                                 stream_buf_offset_,
                             read_len);
  CHECK_NE(ret, NGHTTP2_ERR_NOMEM);
  CHECK_IMPLIES(custom_recv_error_code_ != nullptr, ret < 0);

  if (is_receive_paused()) {
    CHECK(is_reading_stopped());

    CHECK_GT(ret, 0);
    CHECK_LE(static_cast<size_t>(ret), read_len);

    // Mark the remainder of the data as available for later consumption.
    // Even if all bytes were received, a paused stream m...",800.0,867.0,1.0,1.0,68.0,40,15,47,14,0,0,6,6,0,0,,0,0,0,0,0,void
3746,187790,GetFrameID,1,node.http2.GetFrameID,int32_t node.http2.GetFrameID (nghttp2_frame*),node_http2.cc,"int32_t GetFrameID(const nghttp2_frame* frame) {
  // If this is a push promise, we want to grab the id of the promised stream
  return (frame->hd.type == NGHTTP2_PUSH_PROMISE) ?
      frame->push_promise.promised_stream_id :
      frame->hd.stream_id;
}",870.0,875.0,1.0,1.0,6.0,8,4,4,2,0,0,1,1,0,0,,0,0,2,1,1,int32_t
3747,187814,OnBeginHeadersCallback,1,node.http2.Http2Session.OnBeginHeadersCallback,"int node.http2.Http2Session.OnBeginHeadersCallback (nghttp2_session*,nghttp2_frame*,void*)",node_http2.cc,"int Http2Session::OnBeginHeadersCallback(nghttp2_session* handle,
                                         const nghttp2_frame* frame,
                                         void* user_data) {
  Http2Session* session = static_cast<Http2Session*>(user_data);
  int32_t id = GetFrameID(frame);
  Debug(session, ""beginning headers for stream %d"", id);

  BaseObjectPtr<Http2Stream> stream = session->FindStream(id);
  // The common case is that we're creating a new stream. The less likely
  // case is that we're receiving a set of trailers
  if (LIKELY(!stream)) {
    if (UNLIKELY(!session->CanAddStream() ||
                 Http2Stream::New(session, id, frame->headers.cat) ==
                     nullptr)) {
      if (session->rejected_stream_count_++ >
          session->js_fields_->max_rejected_streams)
        return NGHTTP2_ERR_CALLBACK_FAILURE;
      // Too many concurrent streams being opened
      nghttp2_submit_rst_stream(
          session->session(),
          NGHTTP2_FLAG_NON...",882.0,913.0,1.0,1.0,32.0,23,10,26,11,0,0,4,7,0,0,,0,0,6,3,3,int
3748,187923,OnHeaderCallback,1,node.http2.Http2Session.OnHeaderCallback,"int node.http2.Http2Session.OnHeaderCallback (nghttp2_session*,nghttp2_frame*,nghttp2_rcbuf*,nghttp2_rcbuf*,uint8_t,void*)",node_http2.cc,"int Http2Session::OnHeaderCallback(nghttp2_session* handle,
                                   const nghttp2_frame* frame,
                                   nghttp2_rcbuf* name,
                                   nghttp2_rcbuf* value,
                                   uint8_t flags,
                                   void* user_data) {
  Http2Session* session = static_cast<Http2Session*>(user_data);
  int32_t id = GetFrameID(frame);
  BaseObjectPtr<Http2Stream> stream = session->FindStream(id);
  // If stream is null at this point, either something odd has happened
  // or the stream was closed locally while header processing was occurring.
  // either way, do not proceed and close the stream.
  if (UNLIKELY(!stream))
    return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;

  // If the stream has already been destroyed, ignore.
  if (!stream->is_destroyed() && !stream->AddHeader(name, value, flags)) {
    // This will only happen if the connected peer sends us more
    // than the allow...",918.0,941.0,1.0,1.0,24.0,14,7,19,12,0,0,3,3,0,0,,0,0,12,6,6,int
3749,187987,OnFrameReceive,1,node.http2.Http2Session.OnFrameReceive,"int node.http2.Http2Session.OnFrameReceive (nghttp2_session*,nghttp2_frame*,void*)",node_http2.cc,"int Http2Session::OnFrameReceive(nghttp2_session* handle,
                                 const nghttp2_frame* frame,
                                 void* user_data) {
  Http2Session* session = static_cast<Http2Session*>(user_data);
  session->statistics_.frame_count++;
  Debug(session, ""complete frame received: type: %d"",
        frame->hd.type);
  switch (frame->hd.type) {
    case NGHTTP2_DATA:
      return session->HandleDataFrame(frame);
    case NGHTTP2_PUSH_PROMISE:
      // Intentional fall-through, handled just like headers frames
    case NGHTTP2_HEADERS:
      session->HandleHeadersFrame(frame);
      break;
    case NGHTTP2_SETTINGS:
      session->HandleSettingsFrame(frame);
      break;
    case NGHTTP2_PRIORITY:
      session->HandlePriorityFrame(frame);
      break;
    case NGHTTP2_GOAWAY:
      session->HandleGoawayFrame(frame);
      break;
    case NGHTTP2_PING:
      session->HandlePingFrame(frame);
      break;
    case NGHTTP2_ALTSVC:
      session->HandleA...",946.0,983.0,1.0,1.0,38.0,17,5,31,12,0,0,10,2,0,0,,0,0,6,3,3,int
3750,188091,OnInvalidFrame,1,node.http2.Http2Session.OnInvalidFrame,"int node.http2.Http2Session.OnInvalidFrame (nghttp2_session*,nghttp2_frame*,int,void*)",node_http2.cc,"int Http2Session::OnInvalidFrame(nghttp2_session* handle,
                                 const nghttp2_frame* frame,
                                 int lib_error_code,
                                 void* user_data) {
  Http2Session* session = static_cast<Http2Session*>(user_data);
  const uint32_t max_invalid_frames = session->js_fields_->max_invalid_frames;

  Debug(session,
        ""invalid frame received (%u/%u), code: %d"",
        session->invalid_frame_count_,
        max_invalid_frames,
        lib_error_code);
  if (session->invalid_frame_count_++ > max_invalid_frames) {
    session->custom_recv_error_code_ = ""ERR_HTTP2_TOO_MANY_INVALID_FRAMES"";
    return 1;
  }

  // If the error is fatal or if error code is ERR_STREAM_CLOSED... emit error
  if (nghttp2_is_fatal(lib_error_code) ||
      lib_error_code == NGHTTP2_ERR_STREAM_CLOSED) {
    Environment* env = session->env();
    Isolate* isolate = env->isolate();
    HandleScope scope(isolate);
    Local<Context> context...",985.0,1014.0,1.0,1.0,30.0,28,10,33,13,0,0,3,3,0,0,,0,0,8,4,4,int
3751,188199,DecrefHeaders,1,node.http2.Http2Session.DecrefHeaders,void node.http2.Http2Session.DecrefHeaders (nghttp2_frame*),node_http2.cc,"void Http2Session::DecrefHeaders(const nghttp2_frame* frame) {
  int32_t id = GetFrameID(frame);
  BaseObjectPtr<Http2Stream> stream = FindStream(id);

  if (stream && !stream->is_destroyed() && stream->headers_count() > 0) {
    Debug(this, ""freeing headers for stream %d"", id);
    stream->ClearHeaders();
    CHECK_EQ(stream->headers_count(), 0);
    DecrementCurrentSessionMemory(stream->current_headers_length_);
    stream->current_headers_length_ = 0;
  }
}",1018.0,1029.0,1.0,1.0,12.0,15,6,14,5,0,0,2,2,0,0,,0,0,2,1,1,void
3752,188256,TranslateNghttp2ErrorCode,1,node.http2.TranslateNghttp2ErrorCode,uint32_t node.http2.TranslateNghttp2ErrorCode (int),node_http2.cc,"uint32_t TranslateNghttp2ErrorCode(const int libErrorCode) {
  switch (libErrorCode) {
  case NGHTTP2_ERR_STREAM_CLOSED:
    return NGHTTP2_STREAM_CLOSED;
  case NGHTTP2_ERR_HEADER_COMP:
    return NGHTTP2_COMPRESSION_ERROR;
  case NGHTTP2_ERR_FRAME_SIZE_ERROR:
    return NGHTTP2_FRAME_SIZE_ERROR;
  case NGHTTP2_ERR_FLOW_CONTROL:
    return NGHTTP2_FLOW_CONTROL_ERROR;
  case NGHTTP2_ERR_REFUSED_STREAM:
    return NGHTTP2_REFUSED_STREAM;
  case NGHTTP2_ERR_PROTO:
  case NGHTTP2_ERR_HTTP_HEADER:
  case NGHTTP2_ERR_HTTP_MESSAGING:
    return NGHTTP2_PROTOCOL_ERROR;
  default:
    return NGHTTP2_INTERNAL_ERROR;
  }
}",1031.0,1050.0,1.0,1.0,20.0,0,0,16,16,0,0,2,2,0,0,,0,0,2,1,1,uint32_t
3753,188295,OnFrameNotSent,1,node.http2.Http2Session.OnFrameNotSent,"int node.http2.Http2Session.OnFrameNotSent (nghttp2_session*,nghttp2_frame*,int,void*)",node_http2.cc,"int Http2Session::OnFrameNotSent(nghttp2_session* handle,
                                 const nghttp2_frame* frame,
                                 int error_code,
                                 void* user_data) {
  Http2Session* session = static_cast<Http2Session*>(user_data);
  Environment* env = session->env();
  Debug(session, ""frame type %d was not sent, code: %d"",
        frame->hd.type, error_code);

  // Do not report if the frame was not sent due to the session closing
  if (error_code == NGHTTP2_ERR_SESSION_CLOSING ||
      error_code == NGHTTP2_ERR_STREAM_CLOSED ||
      error_code == NGHTTP2_ERR_STREAM_CLOSING) {
    // Nghttp2 contains header limit of 65536. When this value is exceeded the
    // pipeline is stopped and we should remove the current headers reference
    // to destroy the session completely.
    // Further information see: https://github.com/nodejs/node/issues/35233
    session->DecrefHeaders(frame);
    return 0;
  }

  Isolate* isolate = env->iso...",1058.0,1093.0,1.0,1.0,36.0,24,9,30,14,0,0,2,2,0,0,,0,0,8,4,4,int
3754,188389,OnFrameSent,1,node.http2.Http2Session.OnFrameSent,"int node.http2.Http2Session.OnFrameSent (nghttp2_session*,nghttp2_frame*,void*)",node_http2.cc,"int Http2Session::OnFrameSent(nghttp2_session* handle,
                              const nghttp2_frame* frame,
                              void* user_data) {
  Http2Session* session = static_cast<Http2Session*>(user_data);
  session->statistics_.frame_sent += 1;
  return 0;
}",1095.0,1101.0,1.0,1.0,7.0,5,5,3,2,0,0,1,1,0,0,,0,0,6,3,3,int
3755,188411,OnStreamClose,1,node.http2.Http2Session.OnStreamClose,"int node.http2.Http2Session.OnStreamClose (nghttp2_session*,int32_t,uint32_t,void*)",node_http2.cc,"int Http2Session::OnStreamClose(nghttp2_session* handle,
                                int32_t id,
                                uint32_t code,
                                void* user_data) {
  Http2Session* session = static_cast<Http2Session*>(user_data);
  Environment* env = session->env();
  Isolate* isolate = env->isolate();
  HandleScope scope(isolate);
  Local<Context> context = env->context();
  Context::Scope context_scope(context);
  Debug(session, ""stream %d closed with code: %d"", id, code);
  BaseObjectPtr<Http2Stream> stream = session->FindStream(id);
  // Intentionally ignore the callback if the stream does not exist or has
  // already been destroyed
  if (!stream || stream->is_destroyed())
    return 0;

  stream->Close(code);

  // It is possible for the stream close to occur before the stream is
  // ever passed on to the javascript side. If that happens, the callback
  // will return false.
  if (env->can_call_into_js()) {
    Local<Value> arg = Integer::New...",1104.0,1136.0,1.0,1.0,33.0,34,9,40,17,0,0,4,5,0,0,,0,0,8,4,4,int
3756,188542,OnInvalidHeader,1,node.http2.Http2Session.OnInvalidHeader,"int node.http2.Http2Session.OnInvalidHeader (nghttp2_session*,nghttp2_frame*,nghttp2_rcbuf*,nghttp2_rcbuf*,uint8_t,void*)",node_http2.cc,"int Http2Session::OnInvalidHeader(nghttp2_session* session,
                                  const nghttp2_frame* frame,
                                  nghttp2_rcbuf* name,
                                  nghttp2_rcbuf* value,
                                  uint8_t flags,
                                  void* user_data) {
  // Ignore invalid header fields by default.
  return 0;
}",1142.0,1150.0,1.0,1.0,9.0,0,0,0,0,0,0,1,1,0,0,,0,0,12,6,6,int
3757,188554,OnDataChunkReceived,1,node.http2.Http2Session.OnDataChunkReceived,"int node.http2.Http2Session.OnDataChunkReceived (nghttp2_session*,uint8_t,int32_t,uint8_t*,size_t,void*)",node_http2.cc,"int Http2Session::OnDataChunkReceived(nghttp2_session* handle,
                                      uint8_t flags,
                                      int32_t id,
                                      const uint8_t* data,
                                      size_t len,
                                      void* user_data) {
  Http2Session* session = static_cast<Http2Session*>(user_data);
  Debug(session, ""buffering data chunk for stream %d, size: ""
        ""%d, flags: %d"", id, len, flags);
  Environment* env = session->env();
  HandleScope scope(env->isolate());

  // We should never actually get a 0-length chunk so this check is
  // only a precaution at this point.
  if (len == 0)
    return 0;

  // Notify nghttp2 that we've consumed a chunk of data on the connection
  // so that it can send a WINDOW_UPDATE frame. This is a critical part of
  // the flow control process in http2
  CHECK_EQ(nghttp2_session_consume_connection(handle, len), 0);
  BaseObjectPtr<Http2Stream> str...",1156.0,1234.0,1.0,1.0,79.0,44,12,53,14,0,0,9,13,0,0,,0,0,12,6,6,int
3758,188754,OnSelectPadding,1,node.http2.Http2Session.OnSelectPadding,"ssize_t node.http2.Http2Session.OnSelectPadding (nghttp2_session*,nghttp2_frame*,size_t,void*)",node_http2.cc,"ssize_t Http2Session::OnSelectPadding(nghttp2_session* handle,
                                      const nghttp2_frame* frame,
                                      size_t maxPayloadLen,
                                      void* user_data) {
  Http2Session* session = static_cast<Http2Session*>(user_data);
  ssize_t padding = frame->hd.length;

  switch (session->padding_strategy_) {
    case PADDING_STRATEGY_NONE:
      // Fall-through
      break;
    case PADDING_STRATEGY_MAX:
      padding = session->OnMaxFrameSizePadding(padding, maxPayloadLen);
      break;
    case PADDING_STRATEGY_ALIGNED:
      padding = session->OnDWordAlignedPadding(padding, maxPayloadLen);
      break;
  }
  return padding;
}",1238.0,1257.0,1.0,1.0,20.0,10,4,17,8,0,0,5,2,0,0,,0,0,8,4,4,ssize_t
3759,188808,OnNghttpError,1,node.http2.Http2Session.OnNghttpError,"int node.http2.Http2Session.OnNghttpError (nghttp2_session*,int,char*,size_t,void*)",node_http2.cc,"int Http2Session::OnNghttpError(nghttp2_session* handle,
                                int lib_error_code,
                                const char* message,
                                size_t len,
                                void* user_data) {
  // Unfortunately, this is currently the only way for us to know if
  // the session errored because the peer is not an http2 peer.
  Http2Session* session = static_cast<Http2Session*>(user_data);
  Debug(session, ""Error '%s'"", message);
  if (lib_error_code == NGHTTP2_ERR_SETTINGS_EXPECTED) {
    Environment* env = session->env();
    Isolate* isolate = env->isolate();
    HandleScope scope(isolate);
    Local<Context> context = env->context();
    Context::Scope context_scope(context);
    Local<Value> arg = Integer::New(isolate, NGHTTP2_ERR_PROTO);
    session->MakeCallback(env->http2session_on_error_function(), 1, &arg);
  }
  return 0;
}",1261.0,1280.0,1.0,1.0,20.0,18,8,25,14,0,0,2,2,0,0,,0,0,10,5,5,int
3760,188887,OnStreamAlloc,1,node.http2.Http2StreamListener.OnStreamAlloc,uv_buf_t node.http2.Http2StreamListener.OnStreamAlloc (size_t),node_http2.cc,"uv_buf_t Http2StreamListener::OnStreamAlloc(size_t size) {
  // See the comments in Http2Session::OnDataChunkReceived
  // (which is the only possible call site for this method).
  return uv_buf_init(nullptr, size);
}",1282.0,1286.0,1.0,1.0,5.0,0,0,1,1,0,0,1,1,0,0,,0,0,2,1,1,uv_buf_t
3761,188896,OnStreamRead,1,node.http2.Http2StreamListener.OnStreamRead,"void node.http2.Http2StreamListener.OnStreamRead (ssize_t,uv_buf_t)",node_http2.cc,"void Http2StreamListener::OnStreamRead(ssize_t nread, const uv_buf_t& buf) {
  Http2Stream* stream = static_cast<Http2Stream*>(stream_);
  Http2Session* session = stream->session();
  Environment* env = stream->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  if (nread < 0) {
    PassReadErrorToPreviousListener(nread);
    return;
  }

  Local<ArrayBuffer> ab;
  if (session->stream_buf_ab_.IsEmpty()) {
    ab = ArrayBuffer::New(env->isolate(),
                          std::move(session->stream_buf_allocation_));
    session->stream_buf_ab_.Reset(env->isolate(), ab);
  } else {
    ab = PersistentToLocal::Strong(session->stream_buf_ab_);
  }

  // There is a single large array buffer for the entire data read from the
  // network; create a slice of that array buffer and emit it as the
  // received data buffer.
  size_t offset = buf.base - session->stream_buf_.base;

  // Verify that the data offset is inside the current read buff...",1288.0,1320.0,1.0,1.0,33.0,34,8,36,11,0,0,3,3,0,0,,0,0,4,2,2,void
3762,189036,HandleHeadersFrame,1,node.http2.Http2Session.HandleHeadersFrame,void node.http2.Http2Session.HandleHeadersFrame (nghttp2_frame*),node_http2.cc,"void Http2Session::HandleHeadersFrame(const nghttp2_frame* frame) {
  Isolate* isolate = env()->isolate();
  HandleScope scope(isolate);
  Local<Context> context = env()->context();
  Context::Scope context_scope(context);

  int32_t id = GetFrameID(frame);
  Debug(this, ""handle headers frame for stream %d"", id);
  BaseObjectPtr<Http2Stream> stream = FindStream(id);

  // If the stream has already been destroyed, ignore.
  if (!stream || stream->is_destroyed())
    return;

  // The headers are stored as a vector of Http2Header instances.
  // The following converts that into a JS array with the structure:
  // [name1, value1, name2, value2, name3, value3, name3, value4] and so on.
  // That array is passed up to the JS layer and converted into an Object form
  // like {name1: value1, name2: value2, name3: [value3, value4]}. We do it
  // this way for performance reasons (it's faster to generate and pass an
  // array than it is to generate and pass the object).

  MaybeStackBuffer<...",1326.0,1373.0,1.0,1.0,48.0,37,9,43,15,0,0,2,2,0,0,,0,0,2,1,1,void
3763,189190,HandlePriorityFrame,1,node.http2.Http2Session.HandlePriorityFrame,void node.http2.Http2Session.HandlePriorityFrame (nghttp2_frame*),node_http2.cc,"void Http2Session::HandlePriorityFrame(const nghttp2_frame* frame) {
  if (js_fields_->priority_listener_count == 0) return;
  Isolate* isolate = env()->isolate();
  HandleScope scope(isolate);
  Local<Context> context = env()->context();
  Context::Scope context_scope(context);

  nghttp2_priority priority_frame = frame->priority;
  int32_t id = GetFrameID(frame);
  Debug(this, ""handle priority frame for stream %d"", id);
  // Priority frame stream ID should never be <= 0. nghttp2 handles this for us
  nghttp2_priority_spec spec = priority_frame.pri_spec;

  Local<Value> argv[4] = {
    Integer::New(isolate, id),
    Integer::New(isolate, spec.stream_id),
    Integer::New(isolate, spec.weight),
    Boolean::New(isolate, spec.exclusive)
  };
  MakeCallback(env()->http2session_on_priority_function(),
               arraysize(argv), argv);
}",1380.0,1401.0,1.0,1.0,22.0,18,7,19,11,0,0,2,2,0,0,,0,0,2,1,1,void
3764,189263,HandleDataFrame,1,node.http2.Http2Session.HandleDataFrame,int node.http2.Http2Session.HandleDataFrame (nghttp2_frame*),node_http2.cc,"int Http2Session::HandleDataFrame(const nghttp2_frame* frame) {
  int32_t id = GetFrameID(frame);
  Debug(this, ""handling data frame for stream %d"", id);
  BaseObjectPtr<Http2Stream> stream = FindStream(id);

  if (stream &&
      !stream->is_destroyed() &&
      frame->hd.flags & NGHTTP2_FLAG_END_STREAM) {
    stream->EmitRead(UV_EOF);
  } else if (frame->hd.length == 0) {
    if (invalid_frame_count_++ > js_fields_->max_invalid_frames) {
      custom_recv_error_code_ = ""ERR_HTTP2_TOO_MANY_INVALID_FRAMES"";
      Debug(this, ""rejecting empty-frame-without-END_STREAM flood\n"");
      // Consider a flood of 0-length frames without END_STREAM an error.
      return 1;
    }
  }
  return 0;
}",1407.0,1425.0,1.0,1.0,19.0,12,8,13,7,0,0,2,2,0,0,,0,0,2,1,1,int
3765,189336,HandleGoawayFrame,1,node.http2.Http2Session.HandleGoawayFrame,void node.http2.Http2Session.HandleGoawayFrame (nghttp2_frame*),node_http2.cc,"void Http2Session::HandleGoawayFrame(const nghttp2_frame* frame) {
  Isolate* isolate = env()->isolate();
  HandleScope scope(isolate);
  Local<Context> context = env()->context();
  Context::Scope context_scope(context);

  nghttp2_goaway goaway_frame = frame->goaway;
  Debug(this, ""handling goaway frame"");

  Local<Value> argv[3] = {
    Integer::NewFromUnsigned(isolate, goaway_frame.error_code),
    Integer::New(isolate, goaway_frame.last_stream_id),
    Undefined(isolate)
  };

  size_t length = goaway_frame.opaque_data_len;
  if (length > 0) {
    // If the copy fails for any reason here, we just ignore it.
    // The additional goaway data is completely optional and we
    // shouldn't fail if we're not able to process it.
    argv[2] = Buffer::Copy(isolate,
                           reinterpret_cast<char*>(goaway_frame.opaque_data),
                           length).ToLocalChecked();
  }

  MakeCallback(env()->http2session_on_goaway_data_function(),
               arraysize...",1429.0,1456.0,1.0,1.0,28.0,22,7,21,10,0,0,2,2,0,0,,0,0,2,1,1,void
3766,189418,HandleAltSvcFrame,1,node.http2.Http2Session.HandleAltSvcFrame,void node.http2.Http2Session.HandleAltSvcFrame (nghttp2_frame*),node_http2.cc,"void Http2Session::HandleAltSvcFrame(const nghttp2_frame* frame) {
  if (!(js_fields_->bitfield & (1 << kSessionHasAltsvcListeners))) return;
  Isolate* isolate = env()->isolate();
  HandleScope scope(isolate);
  Local<Context> context = env()->context();
  Context::Scope context_scope(context);

  int32_t id = GetFrameID(frame);

  nghttp2_extension ext = frame->ext;
  nghttp2_ext_altsvc* altsvc = static_cast<nghttp2_ext_altsvc*>(ext.payload);
  Debug(this, ""handling altsvc frame"");

  Local<Value> argv[3] = {
    Integer::New(isolate, id),
    OneByteString(isolate, altsvc->origin, altsvc->origin_len),
    OneByteString(isolate, altsvc->field_value, altsvc->field_value_len)
  };

  MakeCallback(env()->http2session_on_altsvc_function(),
               arraysize(argv), argv);
}",1459.0,1480.0,1.0,1.0,22.0,21,10,19,12,0,0,2,2,0,0,,0,0,2,1,1,void
3767,189495,HandleOriginFrame,1,node.http2.Http2Session.HandleOriginFrame,void node.http2.Http2Session.HandleOriginFrame (nghttp2_frame*),node_http2.cc,"void Http2Session::HandleOriginFrame(const nghttp2_frame* frame) {
  Isolate* isolate = env()->isolate();
  HandleScope scope(isolate);
  Local<Context> context = env()->context();
  Context::Scope context_scope(context);

  Debug(this, ""handling origin frame"");

  nghttp2_extension ext = frame->ext;
  nghttp2_ext_origin* origin = static_cast<nghttp2_ext_origin*>(ext.payload);

  size_t nov = origin->nov;
  std::vector<Local<Value>> origin_v(nov);

  for (size_t i = 0; i < nov; ++i) {
    const nghttp2_origin_entry& entry = origin->ov[i];
    origin_v[i] = OneByteString(isolate, entry.origin, entry.origin_len);
  }
  Local<Value> holder = Array::New(isolate, origin_v.data(), origin_v.size());
  MakeCallback(env()->http2session_on_origin_function(), 1, &holder);
}",1482.0,1502.0,1.0,1.0,21.0,34,9,35,15,0,0,2,2,0,0,,0,0,2,1,1,void
3768,189615,HandlePingFrame,1,node.http2.Http2Session.HandlePingFrame,void node.http2.Http2Session.HandlePingFrame (nghttp2_frame*),node_http2.cc,"void Http2Session::HandlePingFrame(const nghttp2_frame* frame) {
  Isolate* isolate = env()->isolate();
  HandleScope scope(isolate);
  Local<Context> context = env()->context();
  Context::Scope context_scope(context);
  Local<Value> arg;
  bool ack = frame->hd.flags & NGHTTP2_FLAG_ACK;
  if (ack) {
    BaseObjectPtr<Http2Ping> ping = PopPing();

    if (!ping) {
      // PING Ack is unsolicited. Treat as a connection error. The HTTP/2
      // spec does not require this, but there is no legitimate reason to
      // receive an unsolicited PING ack on a connection. Either the peer
      // is buggy or malicious, and we're not going to tolerate such
      // nonsense.
      arg = Integer::New(isolate, NGHTTP2_ERR_PROTO);
      MakeCallback(env()->http2session_on_error_function(), 1, &arg);
      return;
    }

    ping->Done(true, frame->ping.opaque_data);
    return;
  }

  if (!(js_fields_->bitfield & (1 << kSessionHasPingListeners))) return;
  // Notify the session that a ping oc...",1505.0,1537.0,1.0,1.0,33.0,35,10,30,17,0,0,4,5,0,0,,0,0,2,1,1,void
3769,189737,HandleSettingsFrame,1,node.http2.Http2Session.HandleSettingsFrame,void node.http2.Http2Session.HandleSettingsFrame (nghttp2_frame*),node_http2.cc,"void Http2Session::HandleSettingsFrame(const nghttp2_frame* frame) {
  bool ack = frame->hd.flags & NGHTTP2_FLAG_ACK;
  if (!ack) {
    js_fields_->bitfield &= ~(1 << kSessionRemoteSettingsIsUpToDate);
    if (!(js_fields_->bitfield & (1 << kSessionHasRemoteSettingsListeners)))
      return;
    // This is not a SETTINGS acknowledgement, notify and return
    MakeCallback(env()->http2session_on_settings_function(), 0, nullptr);
    return;
  }

  // If this is an acknowledgement, we should have an Http2Settings
  // object for it.
  BaseObjectPtr<Http2Settings> settings = PopSettings();
  if (settings) {
    settings->Done(true);
    return;
  }
  // SETTINGS Ack is unsolicited. Treat as a connection error. The HTTP/2
  // spec does not require this, but there is no legitimate reason to
  // receive an unsolicited SETTINGS ack on a connection. Either the peer
  // is buggy or malicious, and we're not going to tolerate such
  // nonsense.
  // Note that nghttp2 currently prevents thi...",1540.0,1573.0,1.0,1.0,34.0,29,10,26,17,0,0,4,5,0,0,,0,0,2,1,1,void
3770,189842,OnStreamAfterWrite,1,node.http2.Http2Session.OnStreamAfterWrite,"void node.http2.Http2Session.OnStreamAfterWrite (WriteWrap*,int)",node_http2.cc,"void Http2Session::OnStreamAfterWrite(WriteWrap* w, int status) {
  Debug(this, ""write finished with status %d"", status);

  CHECK(is_write_in_progress());
  set_write_in_progress(false);

  // Inform all pending writes about their completion.
  ClearOutgoing(status);

  if (is_reading_stopped() &&
      !is_write_in_progress() &&
      nghttp2_session_want_read(session_.get())) {
    set_reading_stopped(false);
    stream_->ReadStart();
  }

  if (is_destroyed()) {
    HandleScope scope(env()->isolate());
    MakeCallback(env()->ondone_string(), 0, nullptr);
    if (stream_ != nullptr) {
      // Start reading again to detect the other end finishing.
      set_reading_stopped(false);
      stream_->ReadStart();
    }
    return;
  }

  // If there is more incoming data queued up, consume it.
  if (stream_buf_offset_ > 0) {
    ConsumeHTTP2Data();
  }

  if (!is_write_scheduled() && !is_destroyed()) {
    // Schedule a new write if nghttp2 wants to send data.
    MaybeScheduleWrite(...",1576.0,1612.0,1.0,1.0,37.0,13,6,7,4,0,0,6,7,0,0,,0,0,4,2,2,void
3771,189917,MaybeScheduleWrite,1,node.http2.Http2Session.MaybeScheduleWrite,void node.http2.Http2Session.MaybeScheduleWrite (),node_http2.cc,"void Http2Session::MaybeScheduleWrite() {
  CHECK(!is_write_scheduled());
  if (UNLIKELY(!session_))
    return;

  if (nghttp2_session_want_write(session_.get())) {
    HandleScope handle_scope(env()->isolate());
    Debug(this, ""scheduling write"");
    set_write_scheduled();
    BaseObjectPtr<Http2Session> strong_ref{this};
    env()->SetImmediate([this, strong_ref](Environment* env) {
      if (!session_ || !is_write_scheduled()) {
        // This can happen e.g. when a stream was reset before this turn
        // of the event loop, in which case SendPendingData() is called early,
        // or the session was destroyed in the meantime.
        return;
      }

      // Sending data may call arbitrary JS code, so keep track of
      // async context.
      if (env->can_call_into_js()) {
        HandleScope handle_scope(env->isolate());
        InternalCallbackScope callback_scope(this);
        SendPendingData();
      }
    });
  }
}",1618.0,1645.0,1.0,1.0,28.0,8,6,4,3,0,0,3,3,0,0,,0,0,0,0,0,void
3772,189959,MaybeStopReading,1,node.http2.Http2Session.MaybeStopReading,void node.http2.Http2Session.MaybeStopReading (),node_http2.cc,"void Http2Session::MaybeStopReading() {
  // If the session is already closing we don't want to stop reading as we want
  // to detect when the other peer is actually closed.
  if (is_reading_stopped() || is_closing()) return;
  int want_read = nghttp2_session_want_read(session_.get());
  Debug(this, ""wants read? %d"", want_read);
  if (want_read == 0 || is_write_in_progress()) {
    set_reading_stopped();
    stream_->ReadStop();
  }
}",1647.0,1657.0,1.0,1.0,11.0,6,5,5,3,0,0,3,3,0,0,,0,0,0,0,0,void
3773,189993,ClearOutgoing,1,node.http2.Http2Session.ClearOutgoing,void node.http2.Http2Session.ClearOutgoing (int),node_http2.cc,"void Http2Session::ClearOutgoing(int status) {
  CHECK(is_sending());

  set_sending(false);

  if (!outgoing_buffers_.empty()) {
    outgoing_storage_.clear();
    outgoing_length_ = 0;

    std::vector<NgHttp2StreamWrite> current_outgoing_buffers_;
    current_outgoing_buffers_.swap(outgoing_buffers_);
    for (const NgHttp2StreamWrite& wr : current_outgoing_buffers_) {
      BaseObjectPtr<AsyncWrap> wrap = std::move(wr.req_wrap);
      if (wrap) {
        // TODO(addaleax): Pass `status` instead of 0, so that we actually error
        // out with the error from the write to the underlying protocol,
        // if one occurred.
        WriteWrap::FromObject(wrap)->Done(0);
      }
    }
  }

  // Now that we've finished sending queued data, if there are any pending
  // RstStreams we should try sending again and then flush them one by one.
  if (!pending_rst_streams_.empty()) {
    std::vector<int32_t> current_pending_rst_streams;
    pending_rst_streams_.swap(current_pending_rst_s...",1661.0,1697.0,1.0,1.0,37.0,25,6,29,17,0,0,7,13,0,0,,0,0,2,1,1,void
3774,190096,PushOutgoingBuffer,1,node.http2.Http2Session.PushOutgoingBuffer,void node.http2.Http2Session.PushOutgoingBuffer (NgHttp2StreamWrite),node_http2.cc,"void Http2Session::PushOutgoingBuffer(NgHttp2StreamWrite&& write) {
  outgoing_length_ += write.buf.len;
  outgoing_buffers_.emplace_back(std::move(write));
}",1699.0,1702.0,1.0,1.0,4.0,5,2,5,4,0,0,1,1,0,0,,0,0,2,1,1,void
3775,190117,CopyDataIntoOutgoing,1,node.http2.Http2Session.CopyDataIntoOutgoing,"void node.http2.Http2Session.CopyDataIntoOutgoing (uint8_t*,size_t)",node_http2.cc,"void Http2Session::CopyDataIntoOutgoing(const uint8_t* src, size_t src_length) {
  size_t offset = outgoing_storage_.size();
  outgoing_storage_.resize(offset + src_length);
  memcpy(&outgoing_storage_[offset], src, src_length);

  // Store with a base of `nullptr` initially, since future resizes
  // of the outgoing_buffers_ vector may invalidate the pointer.
  // The correct base pointers will be set later, before writing to the
  // underlying socket.
  PushOutgoingBuffer(NgHttp2StreamWrite {
    uv_buf_init(nullptr, src_length)
  });
}",1707.0,1719.0,1.0,1.0,13.0,7,6,10,4,0,0,1,1,0,0,,0,0,4,2,2,void
3776,190150,SendPendingData,1,node.http2.Http2Session.SendPendingData,uint8_t node.http2.Http2Session.SendPendingData (),node_http2.cc,"uint8_t Http2Session::SendPendingData() {
  Debug(this, ""sending pending data"");
  // Do not attempt to send data on the socket if the destroying flag has
  // been set. That means everything is shutting down and the socket
  // will not be usable.
  if (is_destroyed())
    return 0;
  set_write_scheduled(false);

  // SendPendingData should not be called recursively.
  if (is_sending())
    return 1;
  // This is cleared by ClearOutgoing().
  set_sending();

  ssize_t src_length;
  const uint8_t* src;

  CHECK(outgoing_buffers_.empty());
  CHECK(outgoing_storage_.empty());

  // Part One: Gather data from nghttp2

  while ((src_length = nghttp2_session_mem_send(session_.get(), &src)) > 0) {
    Debug(this, ""nghttp2 has %d bytes to send"", src_length);
    CopyDataIntoOutgoing(src, src_length);
  }

  CHECK_NE(src_length, NGHTTP2_ERR_NOMEM);

  if (stream_ == nullptr) {
    // It would seem nice to bail out earlier, but `nghttp2_session_mem_send()`
    // does take care of things lik...",1726.0,1804.0,1.0,1.0,79.0,42,15,38,17,0,0,9,10,0,0,,0,0,0,0,0,uint8_t
3777,190338,OnSendData,1,node.http2.Http2Session.OnSendData,"int node.http2.Http2Session.OnSendData (nghttp2_session*,nghttp2_frame*,uint8_t*,size_t,nghttp2_data_source*,void*)",node_http2.cc,"int Http2Session::OnSendData(
      nghttp2_session* session_,
      nghttp2_frame* frame,
      const uint8_t* framehd,
      size_t length,
      nghttp2_data_source* source,
      void* user_data) {
  Http2Session* session = static_cast<Http2Session*>(user_data);
  BaseObjectPtr<Http2Stream> stream = session->FindStream(frame->hd.stream_id);
  if (!stream) return 0;

  // Send the frame header + a byte that indicates padding length.
  session->CopyDataIntoOutgoing(framehd, 9);
  if (frame->data.padlen > 0) {
    uint8_t padding_byte = frame->data.padlen - 1;
    CHECK_EQ(padding_byte, frame->data.padlen - 1);
    session->CopyDataIntoOutgoing(&padding_byte, 1);
  }

  Debug(session, ""nghttp2 has %d bytes to send directly"", length);
  while (length > 0) {
    // nghttp2 thinks that there is data available (length > 0), which means
    // we told it so, which means that we *should* have data available.
    CHECK(!stream->queue_.empty());

    NgHttp2StreamWrite& write = stream->que...",1811.0,1862.0,1.0,1.0,52.0,58,13,42,12,0,0,8,7,0,0,,0,0,12,6,6,int
3778,190530,SubmitRequest,1,node.http2.Http2Session.SubmitRequest,"Http2Stream node.http2.Http2Session.SubmitRequest (Http2Priority,Http2Headers,int32_t*,int)",node_http2.cc,"Http2Stream* Http2Session::SubmitRequest(
    const Http2Priority& priority,
    const Http2Headers& headers,
    int32_t* ret,
    int options) {
  Debug(this, ""submitting request"");
  Http2Scope h2scope(this);
  Http2Stream* stream = nullptr;
  Http2Stream::Provider::Stream prov(options);
  *ret = nghttp2_submit_request(
      session_.get(),
      &priority,
      headers.data(),
      headers.length(),
      *prov,
      nullptr);
  CHECK_NE(*ret, NGHTTP2_ERR_NOMEM);
  if (LIKELY(*ret > 0))
    stream = Http2Stream::New(this, *ret, NGHTTP2_HCAT_HEADERS, options);
  return stream;
}",1865.0,1885.0,1.0,1.0,21.0,14,5,17,10,0,0,2,2,0,0,,0,0,8,4,4,Http2Stream
3779,190596,OnStreamAlloc,1,node.http2.Http2Session.OnStreamAlloc,uv_buf_t node.http2.Http2Session.OnStreamAlloc (size_t),node_http2.cc,"uv_buf_t Http2Session::OnStreamAlloc(size_t suggested_size) {
  return env()->allocate_managed_buffer(suggested_size);
}",1887.0,1889.0,1.0,1.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,uv_buf_t
3780,190607,OnStreamRead,1,node.http2.Http2Session.OnStreamRead,"void node.http2.Http2Session.OnStreamRead (ssize_t,uv_buf_t)",node_http2.cc,"void Http2Session::OnStreamRead(ssize_t nread, const uv_buf_t& buf_) {
  HandleScope handle_scope(env()->isolate());
  Context::Scope context_scope(env()->context());
  Http2Scope h2scope(this);
  CHECK_NOT_NULL(stream_);
  Debug(this, ""receiving %d bytes, offset %d"", nread, stream_buf_offset_);
  std::unique_ptr<BackingStore> bs = env()->release_managed_buffer(buf_);

  // Only pass data on if nread > 0
  if (nread <= 0) {
    if (nread < 0) {
      PassReadErrorToPreviousListener(nread);
    }
    return;
  }

  CHECK_LE(static_cast<size_t>(nread), bs->ByteLength());

  statistics_.data_received += nread;

  if (LIKELY(stream_buf_offset_ == 0)) {
    // Shrink to the actual amount of used data.
    bs = BackingStore::Reallocate(env()->isolate(), std::move(bs), nread);
  } else {
    // This is a very unlikely case, and should only happen if the ReadStart()
    // call in OnStreamAfterWrite() immediately provides data. If that does
    // happen, we concatenate the data we received...",1892.0,1959.0,1.0,1.0,68.0,24,9,26,9,0,0,4,5,0,0,,0,0,4,2,2,void
3781,190806,HasWritesOnSocketForStream,1,node.http2.Http2Session.HasWritesOnSocketForStream,bool node.http2.Http2Session.HasWritesOnSocketForStream (Http2Stream*),node_http2.cc,"bool Http2Session::HasWritesOnSocketForStream(Http2Stream* stream) {
  for (const NgHttp2StreamWrite& wr : outgoing_buffers_) {
    if (wr.req_wrap && WriteWrap::FromObject(wr.req_wrap)->stream() == stream)
      return true;
  }
  return false;
}",1961.0,1967.0,1.0,1.0,7.0,6,4,5,4,0,0,3,4,0,0,,0,0,2,1,1,bool
3782,190837,Consume,1,node.http2.Http2Session.Consume,void node.http2.Http2Session.Consume (Local<Object>),node_http2.cc,"void Http2Session::Consume(const FunctionCallbackInfo<Value>& args) {
  Http2Session* session;
  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());
  CHECK(args[0]->IsObject());
  session->Consume(args[0].As<Object>());
}",2665.0,2670.0,1.0,1.0,6.0,3,3,4,3,0,0,1,1,0,0,,0,0,2,1,1,void
3783,190858,Receive,1,node.http2.Http2Session.Receive,void node.http2.Http2Session.Receive (FunctionCallbackInfo<Value>),node_http2.cc,"void Http2Session::Receive(const FunctionCallbackInfo<Value>& args) {
  Http2Session* session;
  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());
  CHECK(args[0]->IsObject());

  ArrayBufferViewContents<char> buffer(args[0]);
  const char* data = buffer.data();
  size_t len = buffer.length();
  Debug(session, ""Receiving %zu bytes injected from JS"", len);

  // Copy given buffer
  while (len > 0) {
    uv_buf_t buf = session->OnStreamAlloc(len);
    size_t copy = buf.len > len ? len : buf.len;
    memcpy(buf.base, data, copy);
    buf.len = copy;
    session->OnStreamRead(copy, buf);

    data += copy;
    len -= copy;
  }
}",1983.0,2004.0,1.0,1.0,22.0,23,9,31,7,0,0,2,2,0,0,,0,0,2,1,1,void
3784,190950,New,1,node.http2.Http2Stream.New,"Http2Stream node.http2.Http2Stream.New (Http2Session*,int32_t,nghttp2_headers_category,int)",node_http2.cc,"Http2Stream* Http2Stream::New(Http2Session* session,
                              int32_t id,
                              nghttp2_headers_category category,
                              int options) {
  Local<Object> obj;
  if (!session->env()
           ->http2stream_constructor_template()
           ->NewInstance(session->env()->context())
           .ToLocal(&obj)) {
    return nullptr;
  }
  return new Http2Stream(session, obj, id, category, options);
}",2006.0,2018.0,1.0,1.0,13.0,11,7,12,8,0,0,2,2,0,0,,0,0,8,4,4,Http2Stream
3785,190998,Http2Stream,1,node.http2.Http2Stream.Http2Stream,"ANY node.http2.Http2Stream.Http2Stream (Http2Session*,Local<Object>,int32_t,nghttp2_headers_category,int)",node_http2.cc,"Http2Stream::Http2Stream(Http2Session* session,
                         Local<Object> obj,
                         int32_t id,
                         nghttp2_headers_category category,
                         int options)
    : AsyncWrap(session->env(), obj, AsyncWrap::PROVIDER_HTTP2STREAM),
      StreamBase(session->env()),
      session_(session),
      id_(id),
      current_headers_category_(category) {
  MakeWeak();
  StreamBase::AttachToObject(GetObject());
  statistics_.id = id;
  statistics_.start_time = uv_hrtime();

  // Limit the number of header pairs
  max_header_pairs_ = session->max_header_pairs();
  if (max_header_pairs_ == 0) {
    max_header_pairs_ = DEFAULT_MAX_HEADER_LIST_PAIRS;
  }
  current_headers_.reserve(std::min(max_header_pairs_, 12u));

  // Limit the number of header octets
  max_header_length_ =
      std::min(
        nghttp2_session_get_local_settings(
          session->session(),
          NGHTTP2_SETTINGS_MAX_HEADER_LIST_SIZE),
      MAX_MAX_H...",2020.0,2058.0,1.0,1.0,39.0,16,5,21,13,0,0,4,4,0,0,,0,0,10,5,5,ANY
3786,191074,~Http2Stream,1,node.http2.Http2Stream.~Http2Stream,ANY node.http2.Http2Stream.~Http2Stream (),node_http2.cc,"Http2Stream::~Http2Stream() {
  Debug(this, ""tearing down stream"");
}",2060.0,2062.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
3787,191081,MemoryInfo,1,node.http2.Http2Stream.MemoryInfo,void node.http2.Http2Stream.MemoryInfo (MemoryTracker*),node_http2.cc,"void Http2Stream::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackField(""current_headers"", current_headers_);
  tracker->TrackField(""queue"", queue_);
}",2064.0,2067.0,1.0,1.0,4.0,2,1,4,3,0,0,1,1,0,0,,0,0,2,1,1,void
3788,191098,diagnostic_name,1,node.http2.Http2Stream.diagnostic_name,string node.http2.Http2Stream.diagnostic_name (),node_http2.cc,"std::string Http2Stream::diagnostic_name() const {
  const Http2Session* sess = session();
  const std::string sname =
      sess ? sess->diagnostic_name() : ""session already destroyed"";
  return ""HttpStream "" + std::to_string(id()) + "" ("" +
         std::to_string(static_cast<int64_t>(get_async_id())) + "") ["" + sname +
         ""]"";
}",2069.0,2076.0,1.0,1.0,8.0,13,6,7,3,0,0,1,1,0,0,,0,0,0,0,0,string
3789,191140,StartHeaders,1,node.http2.Http2Stream.StartHeaders,void node.http2.Http2Stream.StartHeaders (nghttp2_headers_category),node_http2.cc,"void Http2Stream::StartHeaders(nghttp2_headers_category category) {
  Debug(this, ""starting headers, category: %d"", category);
  CHECK(!this->is_destroyed());
  session_->DecrementCurrentSessionMemory(current_headers_length_);
  current_headers_length_ = 0;
  current_headers_.clear();
  current_headers_category_ = category;
}",2079.0,2086.0,1.0,1.0,8.0,6,4,7,5,0,0,1,1,0,0,,0,0,2,1,1,void
3790,191170,operator *,1,node.http2.Http2Stream.operator *,nghttp2_stream node.http2.Http2Stream.operator * (),node_http2.cc,nghttp2_stream* Http2Stream::operator*() const { return stream(); },2089.0,2089.0,1.0,67.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,nghttp2_stream
3791,191176,stream,1,node.http2.Http2Stream.stream,nghttp2_stream node.http2.Http2Stream.stream (),node_http2.cc,"nghttp2_stream* Http2Stream::stream() const {
  return nghttp2_session_find_stream(session_->session(), id_);
}",2091.0,2093.0,1.0,1.0,3.0,1,1,2,2,0,0,1,1,0,0,,0,0,0,0,0,nghttp2_stream
3792,191187,Close,1,node.http2.Http2Stream.Close,void node.http2.Http2Stream.Close (int32_t),node_http2.cc,"void Http2Stream::Close(int32_t code) {
  CHECK(!this->is_destroyed());
  set_closed();
  code_ = code;
  Debug(this, ""closed with code %d"", code);
}",2095.0,2100.0,1.0,1.0,6.0,3,3,3,2,0,0,1,1,0,0,,0,0,2,1,1,void
3793,191206,CreateShutdownWrap,1,node.http2.Http2Stream.CreateShutdownWrap,ShutdownWrap node.http2.Http2Stream.CreateShutdownWrap (Local<Object>),node_http2.cc,"ShutdownWrap* Http2Stream::CreateShutdownWrap(Local<Object> object) {
  // DoShutdown() always finishes synchronously, so there's no need to create
  // a structure to store asynchronous context.
  return nullptr;
}",2102.0,2106.0,1.0,1.0,5.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ShutdownWrap
3794,191213,DoShutdown,1,node.http2.Http2Stream.DoShutdown,int node.http2.Http2Stream.DoShutdown (ShutdownWrap*),node_http2.cc,"int Http2Stream::DoShutdown(ShutdownWrap* req_wrap) {
  if (is_destroyed())
    return UV_EPIPE;

  {
    Http2Scope h2scope(this);
    set_not_writable();
    CHECK_NE(nghttp2_session_resume_data(
        session_->session(), id_),
        NGHTTP2_ERR_NOMEM);
    Debug(this, ""writable side shutdown"");
  }
  return 1;
}",2108.0,2121.0,1.0,1.0,14.0,1,1,4,4,0,0,2,2,0,0,,0,0,2,1,1,int
3795,191241,Destroy,1,node.http2.Http2Stream.Destroy,void node.http2.Http2Stream.Destroy (),node_http2.cc,"void Http2Stream::Destroy(const FunctionCallbackInfo<Value>& args) {
  Http2Stream* stream;
  ASSIGN_OR_RETURN_UNWRAP(&stream, args.Holder());
  Debug(stream, ""destroying stream"");
  stream->Destroy();
}",2832.0,2837.0,1.0,1.0,6.0,18,7,13,6,0,0,4,4,0,0,,0,0,2,1,1,void
3796,191307,SubmitResponse,1,node.http2.Http2Stream.SubmitResponse,"int node.http2.Http2Stream.SubmitResponse (Http2Headers,int)",node_http2.cc,"int Http2Stream::SubmitResponse(const Http2Headers& headers, int options) {
  CHECK(!this->is_destroyed());
  Http2Scope h2scope(this);
  Debug(this, ""submitting response"");
  if (options & STREAM_OPTION_GET_TRAILERS)
    set_has_trailers();

  if (!is_writable())
    options |= STREAM_OPTION_EMPTY_PAYLOAD;

  Http2Stream::Provider::Stream prov(this, options);
  int ret = nghttp2_submit_response(
      session_->session(),
      id_,
      headers.data(),
      headers.length(),
      *prov);
  CHECK_NE(ret, NGHTTP2_ERR_NOMEM);
  return ret;
}",2173.0,2192.0,1.0,1.0,20.0,9,6,14,9,0,0,3,3,0,0,,0,0,4,2,2,int
3797,191366,SubmitInfo,1,node.http2.Http2Stream.SubmitInfo,int node.http2.Http2Stream.SubmitInfo (Http2Headers),node_http2.cc,"int Http2Stream::SubmitInfo(const Http2Headers& headers) {
  CHECK(!this->is_destroyed());
  Http2Scope h2scope(this);
  Debug(this, ""sending %d informational headers"", headers.length());
  int ret = nghttp2_submit_headers(
      session_->session(),
      NGHTTP2_FLAG_NONE,
      id_,
      nullptr,
      headers.data(),
      headers.length(),
      nullptr);
  CHECK_NE(ret, NGHTTP2_ERR_NOMEM);
  return ret;
}",2196.0,2210.0,1.0,1.0,15.0,7,4,10,6,0,0,1,1,0,0,,0,0,2,1,1,int
3798,191412,OnTrailers,1,node.http2.Http2Stream.OnTrailers,void node.http2.Http2Stream.OnTrailers (),node_http2.cc,"void Http2Stream::OnTrailers() {
  Debug(this, ""let javascript know we are ready for trailers"");
  CHECK(!this->is_destroyed());
  Isolate* isolate = env()->isolate();
  HandleScope scope(isolate);
  Local<Context> context = env()->context();
  Context::Scope context_scope(context);
  set_has_trailers(false);
  MakeCallback(env()->http2session_on_stream_trailers_function(), 0, nullptr);
}",2212.0,2221.0,1.0,1.0,10.0,9,5,6,4,0,0,1,1,0,0,,0,0,0,0,0,void
3799,191457,SubmitTrailers,1,node.http2.Http2Stream.SubmitTrailers,int node.http2.Http2Stream.SubmitTrailers (Http2Headers),node_http2.cc,"int Http2Stream::SubmitTrailers(const Http2Headers& headers) {
  CHECK(!this->is_destroyed());
  Http2Scope h2scope(this);
  Debug(this, ""sending %d trailers"", headers.length());
  int ret;
  // Sending an empty trailers frame poses problems in Safari, Edge & IE.
  // Instead we can just send an empty data frame with NGHTTP2_FLAG_END_STREAM
  // to indicate that the stream is ready to be closed.
  if (headers.length() == 0) {
    Http2Stream::Provider::Stream prov(this, 0);
    ret = nghttp2_submit_data(
        session_->session(),
        NGHTTP2_FLAG_END_STREAM,
        id_,
        *prov);
  } else {
    ret = nghttp2_submit_trailer(
        session_->session(),
        id_,
        headers.data(),
        headers.length());
  }
  CHECK_NE(ret, NGHTTP2_ERR_NOMEM);
  return ret;
}",2224.0,2248.0,1.0,1.0,25.0,8,6,10,7,0,0,2,2,0,0,,0,0,2,1,1,int
3800,191525,SubmitPriority,1,node.http2.Http2Stream.SubmitPriority,"int node.http2.Http2Stream.SubmitPriority (Http2Priority,bool)",node_http2.cc,"int Http2Stream::SubmitPriority(const Http2Priority& priority,
                                bool silent) {
  CHECK(!this->is_destroyed());
  Http2Scope h2scope(this);
  Debug(this, ""sending priority spec"");
  int ret = silent ?
      nghttp2_session_change_stream_priority(
          session_->session(),
          id_,
          &priority) :
      nghttp2_submit_priority(
          session_->session(),
          NGHTTP2_FLAG_NONE,
          id_, &priority);
  CHECK_NE(ret, NGHTTP2_ERR_NOMEM);
  return ret;
}",2251.0,2267.0,1.0,1.0,17.0,8,5,12,7,0,0,1,1,0,0,,0,0,4,2,2,int
3801,191570,SubmitRstStream,1,node.http2.Http2Stream.SubmitRstStream,void node.http2.Http2Stream.SubmitRstStream (uint32_t),node_http2.cc,"void Http2Stream::SubmitRstStream(const uint32_t code) {
  CHECK(!this->is_destroyed());
  code_ = code;

  auto is_stream_cancel = [](const uint32_t code) {
    return code == NGHTTP2_CANCEL;
  };

  // If RST_STREAM frame is received with error code NGHTTP2_CANCEL,
  // add it to the pending list and don't force purge the data. It is
  // to avoids the double free error due to unwanted behavior of nghttp2.

  // Add stream to the pending list only if it is received with scope
  // below in the stack. The pending list may not get processed
  // if RST_STREAM received is not in scope and added to the list
  // causing endpoint to hang.
  if (session_->is_in_scope() && is_stream_cancel(code)) {
      session_->AddPendingRstStream(id_);
      return;
  }


  // If possible, force a purge of any currently pending data here to make sure
  // it is sent before closing the stream. If it returns non-zero then we need
  // to wait until the current write finishes and try again to avoid nght...",2271.0,2303.0,1.0,1.0,33.0,10,5,10,5,0,0,3,3,0,0,,0,0,2,1,1,void
3802,191617,FlushRstStream,1,node.http2.Http2Stream.FlushRstStream,void node.http2.Http2Stream.FlushRstStream (),node_http2.cc,"void Http2Stream::FlushRstStream() {
  if (is_destroyed())
    return;
  Http2Scope h2scope(this);
  CHECK_EQ(nghttp2_submit_rst_stream(
      session_->session(),
      NGHTTP2_FLAG_NONE,
      id_,
      code_), 0);
}",2305.0,2314.0,1.0,1.0,10.0,1,1,4,4,0,0,2,2,0,0,,0,0,0,0,0,void
3803,191638,SubmitPushPromise,1,node.http2.Http2Stream.SubmitPushPromise,"Http2Stream node.http2.Http2Stream.SubmitPushPromise (Http2Headers,int32_t*,int)",node_http2.cc,"Http2Stream* Http2Stream::SubmitPushPromise(const Http2Headers& headers,
                                            int32_t* ret,
                                            int options) {
  CHECK(!this->is_destroyed());
  Http2Scope h2scope(this);
  Debug(this, ""sending push promise"");
  *ret = nghttp2_submit_push_promise(
      session_->session(),
      NGHTTP2_FLAG_NONE,
      id_,
      headers.data(),
      headers.length(),
      nullptr);
  CHECK_NE(*ret, NGHTTP2_ERR_NOMEM);
  Http2Stream* stream = nullptr;
  if (*ret > 0) {
    stream = Http2Stream::New(
        session_.get(), *ret, NGHTTP2_HCAT_HEADERS, options);
  }

  return stream;
}",2318.0,2339.0,1.0,1.0,22.0,15,6,17,10,0,0,2,2,0,0,,0,0,6,3,3,Http2Stream
3804,191706,ReadStart,1,node.http2.Http2Stream.ReadStart,int node.http2.Http2Stream.ReadStart (),node_http2.cc,"int Http2Stream::ReadStart() {
  Http2Scope h2scope(this);
  CHECK(!this->is_destroyed());
  set_reading();

  Debug(this, ""reading starting"");

  // Tell nghttp2 about our consumption of the data that was handed
  // off to JS land.
  nghttp2_session_consume_stream(
      session_->session(),
      id_,
      inbound_consumed_data_while_paused_);
  inbound_consumed_data_while_paused_ = 0;

  return 0;
}",2343.0,2359.0,1.0,1.0,17.0,4,3,4,3,0,0,1,1,0,0,,0,0,0,0,0,int
3805,191735,ReadStop,1,node.http2.Http2Stream.ReadStop,int node.http2.Http2Stream.ReadStop (),node_http2.cc,"int Http2Stream::ReadStop() {
  CHECK(!this->is_destroyed());
  if (!is_reading())
    return 0;
  set_paused();
  Debug(this, ""reading stopped"");
  return 0;
}",2362.0,2369.0,1.0,1.0,8.0,3,2,0,0,0,0,2,2,0,0,,0,0,0,0,0,int
3806,191757,DoWrite,1,node.http2.Http2Stream.DoWrite,"int node.http2.Http2Stream.DoWrite (WriteWrap*,uv_buf_t*,size_t,uv_stream_t*)",node_http2.cc,"int Http2Stream::DoWrite(WriteWrap* req_wrap,
                         uv_buf_t* bufs,
                         size_t nbufs,
                         uv_stream_t* send_handle) {
  CHECK_NULL(send_handle);
  Http2Scope h2scope(this);
  if (!is_writable() || is_destroyed()) {
    return UV_EOF;
  }
  Debug(this, ""queuing %d buffers to send"", nbufs);
  for (size_t i = 0; i < nbufs; ++i) {
    // Store the req_wrap on the last write info in the queue, so that it is
    // only marked as finished once all buffers associated with it are finished.
    queue_.emplace(NgHttp2StreamWrite {
      BaseObjectPtr<AsyncWrap>(
          i == nbufs - 1 ? req_wrap->GetAsyncWrap() : nullptr),
      bufs[i]
    });
    IncrementAvailableOutboundLength(bufs[i].len);
  }
  CHECK_NE(nghttp2_session_resume_data(
      session_->session(),
      id_), NGHTTP2_ERR_NOMEM);
  return 0;
}",2381.0,2405.0,1.0,1.0,25.0,16,12,19,12,0,0,3,3,0,0,,0,0,8,4,4,int
3807,191834,AddHeader,1,node.http2.Http2Stream.AddHeader,"bool node.http2.Http2Stream.AddHeader (nghttp2_rcbuf*,nghttp2_rcbuf*,uint8_t)",node_http2.cc,"bool Http2Stream::AddHeader(nghttp2_rcbuf* name,
                            nghttp2_rcbuf* value,
                            uint8_t flags) {
  CHECK(!this->is_destroyed());

  if (Http2RcBufferPointer::IsZeroLength(name))
    return true;  // Ignore empty headers.

  Http2Header header(env(), name, value, flags);
  size_t length = header.length() + 32;
  // A header can only be added if we have not exceeded the maximum number
  // of headers and the session has memory available for it.
  if (!session_->has_available_session_memory(length) ||
      current_headers_.size() == max_header_pairs_ ||
      current_headers_length_ + length > max_header_length_) {
    return false;
  }

  if (statistics_.first_header == 0)
    statistics_.first_header = uv_hrtime();

  current_headers_.push_back(std::move(header));

  current_headers_length_ += length;
  session_->IncrementCurrentSessionMemory(length);
  return true;
}",2412.0,2438.0,1.0,1.0,27.0,22,9,23,13,0,0,4,4,0,0,,0,0,6,3,3,bool
3808,191925,Provider,1,node.http2.Http2Stream.Provider.Provider,"ANY node.http2.Http2Stream.Provider.Provider (Http2Stream*,int)",node_http2.cc,"Http2Stream::Provider::Provider(int options) {
  provider_.source.ptr = nullptr;
  empty_ = options & STREAM_OPTION_EMPTY_PAYLOAD;
}",2447.0,2450.0,1.0,1.0,4.0,7,5,6,5,0,0,1,1,0,0,,0,0,2,1,1,ANY
3809,191966,~Provider,1,node.http2.Http2Stream.Provider.~Provider,ANY node.http2.Http2Stream.Provider.~Provider (),node_http2.cc,"Http2Stream::Provider::~Provider() {
  provider_.source.ptr = nullptr;
}",2452.0,2454.0,1.0,1.0,3.0,3,2,1,1,0,0,1,1,0,0,,0,0,0,0,0,ANY
3810,191977,Stream,1,node.http2.Http2Stream.Provider.Stream.Stream,ANY node.http2.Http2Stream.Provider.Stream.Stream (int),node_http2.cc,"Http2Stream::Provider::Stream::Stream(Http2Stream* stream, int options)
    : Http2Stream::Provider(stream, options) {
  provider_.read_callback = Http2Stream::Provider::Stream::OnRead;
}",2463.0,2466.0,1.0,1.0,4.0,5,2,4,4,0,0,1,1,0,0,,0,0,4,2,2,ANY
3811,192010,OnRead,1,node.http2.Http2Stream.Provider.Stream.OnRead,"ssize_t node.http2.Http2Stream.Provider.Stream.OnRead (nghttp2_session*,int32_t,uint8_t*,size_t,uint32_t*,nghttp2_data_source*,void*)",node_http2.cc,"ssize_t Http2Stream::Provider::Stream::OnRead(nghttp2_session* handle,
                                              int32_t id,
                                              uint8_t* buf,
                                              size_t length,
                                              uint32_t* flags,
                                              nghttp2_data_source* source,
                                              void* user_data) {
  Http2Session* session = static_cast<Http2Session*>(user_data);
  Debug(session, ""reading outbound data for stream %d"", id);
  BaseObjectPtr<Http2Stream> stream = session->FindStream(id);
  if (!stream) return 0;
  if (stream->statistics_.first_byte_sent == 0)
    stream->statistics_.first_byte_sent = uv_hrtime();
  CHECK_EQ(id, stream->id());

  size_t amount = 0;          // amount of data being sent in this data frame.

  // Remove all empty chunks from the head of the queue.
  // This is done here so that .write('', cb) is still a me...",2468.0,2531.0,1.0,1.0,64.0,67,12,71,20,0,0,11,15,0,0,,0,0,14,7,7,ssize_t
3812,192268,IncrementAvailableOutboundLength,1,node.http2.Http2Stream.IncrementAvailableOutboundLength,void node.http2.Http2Stream.IncrementAvailableOutboundLength (size_t),node_http2.cc,"void Http2Stream::IncrementAvailableOutboundLength(size_t amount) {
  available_outbound_length_ += amount;
  session_->IncrementCurrentSessionMemory(amount);
}",2533.0,2536.0,1.0,1.0,4.0,2,2,4,3,0,0,1,1,0,0,,0,0,2,1,1,void
3813,192281,DecrementAvailableOutboundLength,1,node.http2.Http2Stream.DecrementAvailableOutboundLength,void node.http2.Http2Stream.DecrementAvailableOutboundLength (size_t),node_http2.cc,"void Http2Stream::DecrementAvailableOutboundLength(size_t amount) {
  available_outbound_length_ -= amount;
  session_->DecrementCurrentSessionMemory(amount);
}",2538.0,2541.0,1.0,1.0,4.0,2,2,4,3,0,0,1,1,0,0,,0,0,2,1,1,void
3814,192294,HttpErrorString,1,node.http2.HttpErrorString,void node.http2.HttpErrorString (FunctionCallbackInfo<Value>),node_http2.cc,"void HttpErrorString(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  uint32_t val = args[0]->Uint32Value(env->context()).ToChecked();
  args.GetReturnValue().Set(
      OneByteString(
          env->isolate(),
          reinterpret_cast<const uint8_t*>(nghttp2_strerror(val))));
}",2548.0,2555.0,1.0,1.0,8.0,11,5,9,4,0,0,1,1,0,0,,0,0,2,1,1,void
3815,192339,PackSettings,1,node.http2.PackSettings,void node.http2.PackSettings (FunctionCallbackInfo<Value>),node_http2.cc,"void PackSettings(const FunctionCallbackInfo<Value>& args) {
  Http2State* state = Realm::GetBindingData<Http2State>(args);
  args.GetReturnValue().Set(Http2Settings::Pack(state));
}",2561.0,2564.0,1.0,1.0,4.0,7,4,7,5,0,0,1,1,0,0,,0,0,2,1,1,void
3816,192366,RefreshDefaultSettings,1,node.http2.RefreshDefaultSettings,void node.http2.RefreshDefaultSettings (FunctionCallbackInfo<Value>),node_http2.cc,"void RefreshDefaultSettings(const FunctionCallbackInfo<Value>& args) {
  Http2State* state = Realm::GetBindingData<Http2State>(args);
  Http2Settings::RefreshDefaults(state);
}",2569.0,2572.0,1.0,1.0,4.0,5,4,6,5,0,0,1,1,0,0,,0,0,2,1,1,void
3817,192386,SetNextStreamID,1,node.http2.Http2Session.SetNextStreamID,void node.http2.Http2Session.SetNextStreamID (FunctionCallbackInfo<Value>),node_http2.cc,"void Http2Session::SetNextStreamID(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Http2Session* session;
  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());
  int32_t id = args[0]->Int32Value(env->context()).ToChecked();
  if (nghttp2_session_set_next_stream_id(session->session(), id) < 0) {
    Debug(session, ""failed to set next stream id to %d"", id);
    return args.GetReturnValue().Set(false);
  }
  args.GetReturnValue().Set(true);
  Debug(session, ""set next stream id to %d"", id);
}",2575.0,2586.0,1.0,1.0,12.0,15,6,16,5,0,0,2,2,0,0,,0,0,2,1,1,void
3818,192458,SetLocalWindowSize,1,node.http2.Http2Session.SetLocalWindowSize,void node.http2.Http2Session.SetLocalWindowSize (FunctionCallbackInfo<Value>),node_http2.cc,"void Http2Session::SetLocalWindowSize(
    const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Http2Session* session;
  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());

  int32_t window_size = args[0]->Int32Value(env->context()).ToChecked();

  int result = nghttp2_session_set_local_window_size(
      session->session(), NGHTTP2_FLAG_NONE, 0, window_size);

  args.GetReturnValue().Set(result);

  Debug(session, ""set local window size to %d"", window_size);
}",2591.0,2605.0,1.0,1.0,15.0,13,5,16,7,0,0,1,1,0,0,,0,0,2,1,1,void
3819,192518,RefreshSettings,1,node.http2.Http2Session.RefreshSettings,void node.http2.Http2Session.RefreshSettings<get_setting> (FunctionCallbackInfo<Value>),node_http2.cc,"void Http2Session::RefreshSettings(const FunctionCallbackInfo<Value>& args) {
  Http2Session* session;
  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());
  Http2Settings::Update(session, fn);
  Debug(session, ""settings refreshed for session"");
}",2611.0,2616.0,1.0,1.0,6.0,3,2,6,4,0,0,1,1,0,0,,0,0,2,1,1,void
3820,192540,RefreshState,1,node.http2.Http2Session.RefreshState,void node.http2.Http2Session.RefreshState (FunctionCallbackInfo<Value>),node_http2.cc,"void Http2Session::RefreshState(const FunctionCallbackInfo<Value>& args) {
  Http2Session* session;
  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());
  Debug(session, ""refreshing state"");

  AliasedFloat64Array& buffer = session->http2_state()->session_state_buffer;

  nghttp2_session* s = session->session();

  buffer[IDX_SESSION_STATE_EFFECTIVE_LOCAL_WINDOW_SIZE] =
      nghttp2_session_get_effective_local_window_size(s);
  buffer[IDX_SESSION_STATE_EFFECTIVE_RECV_DATA_LENGTH] =
      nghttp2_session_get_effective_recv_data_length(s);
  buffer[IDX_SESSION_STATE_NEXT_STREAM_ID] =
      nghttp2_session_get_next_stream_id(s);
  buffer[IDX_SESSION_STATE_LOCAL_WINDOW_SIZE] =
      nghttp2_session_get_local_window_size(s);
  buffer[IDX_SESSION_STATE_LAST_PROC_STREAM_ID] =
      nghttp2_session_get_last_proc_stream_id(s);
  buffer[IDX_SESSION_STATE_REMOTE_WINDOW_SIZE] =
      nghttp2_session_get_remote_window_size(s);
  buffer[IDX_SESSION_STATE_OUTBOUND_QUEUE_SIZE] =
      static_cast<d...",2621.0,2648.0,1.0,1.0,28.0,28,6,34,13,0,0,1,1,0,0,,0,0,2,1,1,void
3821,192632,New,1,node.http2.Http2Session.New,void node.http2.Http2Session.New (FunctionCallbackInfo<Value>),node_http2.cc,"void Http2Session::New(const FunctionCallbackInfo<Value>& args) {
  Http2State* state = Realm::GetBindingData<Http2State>(args);
  Environment* env = state->env();
  CHECK(args.IsConstructCall());
  SessionType type =
      static_cast<SessionType>(
          args[0]->Int32Value(env->context()).ToChecked());
  Http2Session* session = new Http2Session(state, args.This(), type);
  Debug(session, ""session created"");
}",2652.0,2661.0,1.0,1.0,10.0,16,8,16,8,0,0,1,1,0,0,,0,0,2,1,1,void
3822,192721,Destroy,1,node.http2.Http2Session.Destroy,void node.http2.Http2Session.Destroy (FunctionCallbackInfo<Value>),node_http2.cc,"void Http2Session::Destroy(const FunctionCallbackInfo<Value>& args) {
  Http2Session* session;
  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());
  Debug(session, ""destroying session"");
  Environment* env = Environment::GetCurrent(args);
  Local<Context> context = env->context();

  uint32_t code = args[0]->Uint32Value(context).ToChecked();
  session->Close(code, args[1]->IsTrue());
}",2673.0,2682.0,1.0,1.0,10.0,15,7,16,8,0,0,1,1,0,0,,0,0,2,1,1,void
3823,192779,Request,1,node.http2.Http2Session.Request,void node.http2.Http2Session.Request (FunctionCallbackInfo<Value>),node_http2.cc,"void Http2Session::Request(const FunctionCallbackInfo<Value>& args) {
  Http2Session* session;
  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());
  Environment* env = session->env();

  Local<Array> headers = args[0].As<Array>();
  int32_t options = args[1]->Int32Value(env->context()).ToChecked();

  Debug(session, ""request submitted"");

  int32_t ret = 0;
  Http2Stream* stream =
      session->Http2Session::SubmitRequest(
          Http2Priority(env, args[2], args[3], args[4]),
          Http2Headers(env, headers),
          &ret,
          static_cast<int>(options));

  if (ret <= 0 || stream == nullptr) {
    Debug(session, ""could not submit request: %s"", nghttp2_strerror(ret));
    return args.GetReturnValue().Set(ret);
  }

  Debug(session, ""request submitted, new stream id %d"", stream->id());
  args.GetReturnValue().Set(stream->object());
}",2686.0,2711.0,1.0,1.0,26.0,31,11,33,9,0,0,2,2,0,0,,0,0,2,1,1,void
3824,192901,Goaway,1,node.http2.Http2Session.Goaway,"void node.http2.Http2Session.Goaway (uint32_t,int32_t,uint8_t*,size_t)",node_http2.cc,"void Http2Session::Goaway(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Local<Context> context = env->context();
  Http2Session* session;
  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());

  uint32_t code = args[0]->Uint32Value(context).ToChecked();
  int32_t lastStreamID = args[1]->Int32Value(context).ToChecked();
  ArrayBufferViewContents<uint8_t> opaque_data;

  if (args[2]->IsArrayBufferView()) {
    opaque_data.Read(args[2].As<ArrayBufferView>());
  }

  session->Goaway(code, lastStreamID, opaque_data.data(), opaque_data.length());
}",2735.0,2750.0,1.0,1.0,16.0,4,3,9,6,0,0,3,3,0,0,,0,0,2,1,1,void
3825,193035,UpdateChunksSent,1,node.http2.Http2Session.UpdateChunksSent,void node.http2.Http2Session.UpdateChunksSent (FunctionCallbackInfo<Value>),node_http2.cc,"void Http2Session::UpdateChunksSent(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();
  HandleScope scope(isolate);
  Http2Session* session;
  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());

  uint32_t length = session->chunks_sent_since_last_write_;

  session->object()->Set(env->context(),
                         env->chunks_sent_since_last_write_string(),
                         Integer::NewFromUnsigned(isolate, length)).Check();

  args.GetReturnValue().Set(length);
}",2754.0,2768.0,1.0,1.0,15.0,16,4,18,7,0,0,1,1,0,0,,0,0,2,1,1,void
3826,193104,RstStream,1,node.http2.Http2Stream.RstStream,void node.http2.Http2Stream.RstStream (FunctionCallbackInfo<Value>),node_http2.cc,"void Http2Stream::RstStream(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Local<Context> context = env->context();
  Http2Stream* stream;
  ASSIGN_OR_RETURN_UNWRAP(&stream, args.Holder());
  uint32_t code = args[0]->Uint32Value(context).ToChecked();
  Debug(stream, ""sending rst_stream with code %d"", code);
  stream->SubmitRstStream(code);
}",2773.0,2781.0,1.0,1.0,9.0,13,7,16,8,0,0,1,1,0,0,,0,0,2,1,1,void
3827,193157,Respond,1,node.http2.Http2Stream.Respond,void node.http2.Http2Stream.Respond (FunctionCallbackInfo<Value>),node_http2.cc,"void Http2Stream::Respond(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Http2Stream* stream;
  ASSIGN_OR_RETURN_UNWRAP(&stream, args.Holder());

  Local<Array> headers = args[0].As<Array>();
  int32_t options = args[1]->Int32Value(env->context()).ToChecked();

  args.GetReturnValue().Set(
      stream->SubmitResponse(
          Http2Headers(env, headers),
          static_cast<int>(options)));
  Debug(stream, ""response submitted"");
}",2785.0,2798.0,1.0,1.0,14.0,18,8,18,8,0,0,1,1,0,0,,0,0,2,1,1,void
3828,193226,Info,1,node.http2.Http2Stream.Info,void node.http2.Http2Stream.Info (FunctionCallbackInfo<Value>),node_http2.cc,"void Http2Stream::Info(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Http2Stream* stream;
  ASSIGN_OR_RETURN_UNWRAP(&stream, args.Holder());

  Local<Array> headers = args[0].As<Array>();

  args.GetReturnValue().Set(stream->SubmitInfo(Http2Headers(env, headers)));
}",2802.0,2810.0,1.0,1.0,9.0,12,7,13,7,0,0,1,1,0,0,,0,0,2,1,1,void
3829,193273,Trailers,1,node.http2.Http2Stream.Trailers,void node.http2.Http2Stream.Trailers (FunctionCallbackInfo<Value>),node_http2.cc,"void Http2Stream::Trailers(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Http2Stream* stream;
  ASSIGN_OR_RETURN_UNWRAP(&stream, args.Holder());

  Local<Array> headers = args[0].As<Array>();

  args.GetReturnValue().Set(
      stream->SubmitTrailers(Http2Headers(env, headers)));
}",2813.0,2822.0,1.0,1.0,10.0,12,7,13,7,0,0,1,1,0,0,,0,0,2,1,1,void
3830,193320,GetID,1,node.http2.Http2Stream.GetID,void node.http2.Http2Stream.GetID (FunctionCallbackInfo<Value>),node_http2.cc,"void Http2Stream::GetID(const FunctionCallbackInfo<Value>& args) {
  Http2Stream* stream;
  ASSIGN_OR_RETURN_UNWRAP(&stream, args.Holder());
  args.GetReturnValue().Set(stream->id());
}",2825.0,2829.0,1.0,1.0,5.0,5,3,4,2,0,0,1,1,0,0,,0,0,2,1,1,void
3831,193364,PushPromise,1,node.http2.Http2Stream.PushPromise,void node.http2.Http2Stream.PushPromise (FunctionCallbackInfo<Value>),node_http2.cc,"void Http2Stream::PushPromise(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Http2Stream* parent;
  ASSIGN_OR_RETURN_UNWRAP(&parent, args.Holder());

  Local<Array> headers = args[0].As<Array>();
  int32_t options = args[1]->Int32Value(env->context()).ToChecked();

  Debug(parent, ""creating push promise"");

  int32_t ret = 0;
  Http2Stream* stream =
      parent->SubmitPushPromise(
          Http2Headers(env, headers),
          &ret,
          static_cast<int>(options));

  if (ret <= 0 || stream == nullptr) {
    Debug(parent, ""failed to create push stream: %d"", ret);
    return args.GetReturnValue().Set(ret);
  }
  Debug(parent, ""push stream %d created"", stream->id());
  args.GetReturnValue().Set(stream->object());
}",2840.0,2863.0,1.0,1.0,24.0,28,11,30,10,0,0,2,2,0,0,,0,0,2,1,1,void
3832,193475,Priority,1,node.http2.Http2Stream.Priority,void node.http2.Http2Stream.Priority (FunctionCallbackInfo<Value>),node_http2.cc,"void Http2Stream::Priority(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Http2Stream* stream;
  ASSIGN_OR_RETURN_UNWRAP(&stream, args.Holder());

  CHECK_EQ(stream->SubmitPriority(
      Http2Priority(env, args[0], args[1], args[2]),
      args[3]->IsTrue()), 0);
  Debug(stream, ""priority submitted"");
}",2866.0,2875.0,1.0,1.0,10.0,10,5,12,4,0,0,1,1,0,0,,0,0,2,1,1,void
3833,193522,RefreshState,1,node.http2.Http2Stream.RefreshState,void node.http2.Http2Stream.RefreshState (FunctionCallbackInfo<Value>),node_http2.cc,"void Http2Stream::RefreshState(const FunctionCallbackInfo<Value>& args) {
  Http2Stream* stream;
  ASSIGN_OR_RETURN_UNWRAP(&stream, args.Holder());

  Debug(stream, ""refreshing state"");

  CHECK_NOT_NULL(stream->session());
  AliasedFloat64Array& buffer =
      stream->session()->http2_state()->stream_state_buffer;

  nghttp2_stream* str = stream->stream();
  nghttp2_session* s = stream->session()->session();

  if (str == nullptr) {
    buffer[IDX_STREAM_STATE] = NGHTTP2_STREAM_STATE_IDLE;
    buffer[IDX_STREAM_STATE_WEIGHT] =
        buffer[IDX_STREAM_STATE_SUM_DEPENDENCY_WEIGHT] =
        buffer[IDX_STREAM_STATE_LOCAL_CLOSE] =
        buffer[IDX_STREAM_STATE_REMOTE_CLOSE] =
        buffer[IDX_STREAM_STATE_LOCAL_WINDOW_SIZE] = 0;
  } else {
    buffer[IDX_STREAM_STATE] =
        nghttp2_stream_get_state(str);
    buffer[IDX_STREAM_STATE_WEIGHT] =
        nghttp2_stream_get_weight(str);
    buffer[IDX_STREAM_STATE_SUM_DEPENDENCY_WEIGHT] =
        nghttp2_stream_get_sum_dependency_w...",2880.0,2914.0,1.0,1.0,35.0,25,6,24,12,0,0,2,2,0,0,,0,0,2,1,1,void
3834,193653,AltSvc,1,node.http2.Http2Session.AltSvc,"void node.http2.Http2Session.AltSvc (int32_t,uint8_t*,size_t,uint8_t*,size_t)",node_http2.cc,"void Http2Session::AltSvc(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Http2Session* session;
  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());

  int32_t id = args[0]->Int32Value(env->context()).ToChecked();

  // origin and value are both required to be ASCII, handle them as such.
  Local<String> origin_str = args[1]->ToString(env->context()).ToLocalChecked();
  Local<String> value_str = args[2]->ToString(env->context()).ToLocalChecked();

  if (origin_str.IsEmpty() || value_str.IsEmpty())
    return;

  size_t origin_len = origin_str->Length();
  size_t value_len = value_str->Length();

  CHECK_LE(origin_len + value_len, 16382);  // Max permitted for ALTSVC
  // Verify that origin len != 0 if stream id == 0, or
  // that origin len == 0 if stream id != 0
  CHECK((origin_len != 0 && id == 0) || (origin_len == 0 && id != 0));

  MaybeStackBuffer<uint8_t> origin(origin_len);
  MaybeStackBuffer<uint8_t> value(value_len);
  origin_...",2936.0,2964.0,1.0,1.0,29.0,1,1,7,7,0,0,1,1,0,0,,0,0,2,1,1,void
3835,193678,Origin,1,node.http2.Http2Session.Origin,void node.http2.Http2Session.Origin (Origins),node_http2.cc,"void Http2Session::Origin(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Local<Context> context = env->context();
  Http2Session* session;
  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());

  Local<String> origin_string = args[0].As<String>();
  size_t count = args[1]->Int32Value(context).ToChecked();

  session->Origin(Origins(env, origin_string, count));
}",2966.0,2976.0,1.0,1.0,11.0,3,2,4,3,0,0,1,1,0,0,,0,0,2,1,1,void
3836,193929,Ping,1,node.http2.Http2Session.Ping,void node.http2.Http2Session.Ping (FunctionCallbackInfo<Value>),node_http2.cc,"void Http2Session::Ping(const FunctionCallbackInfo<Value>& args) {
  Http2Session* session;
  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());

  // A PING frame may have exactly 8 bytes of payload data. If not provided,
  // then the current hrtime will be used as the payload.
  ArrayBufferViewContents<uint8_t, 8> payload;
  if (args[0]->IsArrayBufferView()) {
    payload.Read(args[0].As<ArrayBufferView>());
    CHECK_EQ(payload.length(), 8);
  }

  CHECK(args[1]->IsFunction());
  args.GetReturnValue().Set(
      session->AddPing(payload.data(), args[1].As<Function>()));
}",2979.0,2994.0,1.0,1.0,16.0,19,7,14,5,0,0,2,2,0,0,,0,0,2,1,1,void
3837,194001,Settings,1,node.http2.Http2Session.Settings,void node.http2.Http2Session.Settings (FunctionCallbackInfo<Value>),node_http2.cc,"void Http2Session::Settings(const FunctionCallbackInfo<Value>& args) {
  Http2Session* session;
  ASSIGN_OR_RETURN_UNWRAP(&session, args.Holder());
  CHECK(args[0]->IsFunction());
  args.GetReturnValue().Set(session->AddSettings(args[0].As<Function>()));
}",2997.0,3002.0,1.0,1.0,6.0,9,4,6,2,0,0,1,1,0,0,,0,0,2,1,1,void
3838,194038,PopPing,1,node.http2.Http2Session.PopPing,BaseObjectPtr<Http2Ping> node.http2.Http2Session.PopPing (),node_http2.cc,"BaseObjectPtr<Http2Ping> Http2Session::PopPing() {
  BaseObjectPtr<Http2Ping> ping;
  if (!outstanding_pings_.empty()) {
    ping = std::move(outstanding_pings_.front());
    outstanding_pings_.pop();
    DecrementCurrentSessionMemory(sizeof(*ping));
  }
  return ping;
}",3004.0,3012.0,1.0,1.0,9.0,10,7,10,5,0,0,2,2,0,0,,0,0,0,0,0,BaseObjectPtr<Http2Ping>
3839,194074,AddPing,1,node.http2.Http2Session.AddPing,"bool node.http2.Http2Session.AddPing (uint8_t*,Local<Function>)",node_http2.cc,"bool Http2Session::AddPing(const uint8_t* payload, Local<Function> callback) {
  Local<Object> obj;
  if (!env()->http2ping_constructor_template()
          ->NewInstance(env()->context())
              .ToLocal(&obj)) {
    return false;
  }

  BaseObjectPtr<Http2Ping> ping =
      MakeDetachedBaseObject<Http2Ping>(this, obj, callback);
  if (!ping)
    return false;

  if (outstanding_pings_.size() == max_outstanding_pings_) {
    ping->Done(false);
    return false;
  }

  IncrementCurrentSessionMemory(sizeof(*ping));
  // The Ping itself is an Async resource. When the acknowledgement is received,
  // the callback will be invoked and a notification sent out to JS land. The
  // notification will include the duration of the ping, allowing the round
  // trip to be measured.
  ping->Send(payload);

  outstanding_pings_.emplace(std::move(ping));
  return true;
}",3014.0,3041.0,1.0,1.0,28.0,24,12,21,12,0,0,4,4,0,0,,0,0,4,2,2,bool
3840,194162,PopSettings,1,node.http2.Http2Session.PopSettings,BaseObjectPtr<Http2Settings> node.http2.Http2Session.PopSettings (),node_http2.cc,"BaseObjectPtr<Http2Settings> Http2Session::PopSettings() {
  BaseObjectPtr<Http2Settings> settings;
  if (!outstanding_settings_.empty()) {
    settings = std::move(outstanding_settings_.front());
    outstanding_settings_.pop();
    DecrementCurrentSessionMemory(sizeof(*settings));
  }
  return settings;
}",3043.0,3051.0,1.0,1.0,9.0,10,7,10,5,0,0,2,2,0,0,,0,0,0,0,0,BaseObjectPtr<Http2Settings>
3841,194198,AddSettings,1,node.http2.Http2Session.AddSettings,bool node.http2.Http2Session.AddSettings (Local<Function>),node_http2.cc,"bool Http2Session::AddSettings(Local<Function> callback) {
  Local<Object> obj;
  if (!env()->http2settings_constructor_template()
          ->NewInstance(env()->context())
              .ToLocal(&obj)) {
    return false;
  }

  BaseObjectPtr<Http2Settings> settings =
      MakeDetachedBaseObject<Http2Settings>(this, obj, callback, 0);
  if (!settings)
    return false;

  if (outstanding_settings_.size() == max_outstanding_settings_) {
    settings->Done(false);
    return false;
  }

  IncrementCurrentSessionMemory(sizeof(*settings));
  settings->Send();
  outstanding_settings_.emplace(std::move(settings));
  return true;
}",3053.0,3075.0,1.0,1.0,23.0,24,12,20,11,0,0,4,4,0,0,,0,0,2,1,1,bool
3842,194285,Http2Ping,1,node.http2.Http2Ping.Http2Ping,"ANY node.http2.Http2Ping.Http2Ping (Http2Session*,Local<Object>,Local<Function>)",node_http2.cc,"Http2Ping::Http2Ping(
    Http2Session* session,
    Local<Object> obj,
    Local<Function> callback)
    : AsyncWrap(session->env(), obj, AsyncWrap::PROVIDER_HTTP2PING),
      session_(session),
      startTime_(uv_hrtime()) {
  callback_.Reset(env()->isolate(), callback);
}",3077.0,3085.0,1.0,1.0,9.0,2,2,2,2,0,0,1,1,0,0,,0,0,6,3,3,ANY
3843,194301,MemoryInfo,1,node.http2.Http2Ping.MemoryInfo,void node.http2.Http2Ping.MemoryInfo (MemoryTracker*),node_http2.cc,"void Http2Ping::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackField(""callback"", callback_);
}",3087.0,3089.0,1.0,1.0,3.0,1,1,2,2,0,0,1,1,0,0,,0,0,2,1,1,void
3844,194312,callback,1,node.http2.Http2Ping.callback,Local<Function> node.http2.Http2Ping.callback (),node_http2.cc,"Local<Function> Http2Ping::callback() const {
  return callback_.Get(env()->isolate());
}",3091.0,3093.0,1.0,1.0,3.0,2,2,1,1,0,0,1,1,0,0,,0,0,0,0,0,Local<Function>
3845,194325,Send,1,node.http2.Http2Ping.Send,void node.http2.Http2Ping.Send (uint8_t*),node_http2.cc,"void Http2Ping::Send(const uint8_t* payload) {
  CHECK(session_);
  uint8_t data[8];
  if (payload == nullptr) {
    memcpy(&data, &startTime_, arraysize(data));
    payload = data;
  }
  Http2Scope h2scope(session_.get());
  CHECK_EQ(nghttp2_submit_ping(
      session_->session(),
      NGHTTP2_FLAG_NONE,
      payload), 0);
}",3095.0,3107.0,1.0,1.0,13.0,6,5,10,5,0,0,2,2,0,0,,0,0,2,1,1,void
3846,194362,Done,1,node.http2.Http2Ping.Done,"void node.http2.Http2Ping.Done (bool,uint8_t*)",node_http2.cc,"void Http2Ping::Done(bool ack, const uint8_t* payload) {
  uint64_t duration_ns = uv_hrtime() - startTime_;
  double duration_ms = duration_ns / 1e6;
  if (session_) session_->statistics_.ping_rtt = duration_ns;

  Isolate* isolate = env()->isolate();
  HandleScope handle_scope(isolate);
  Context::Scope context_scope(env()->context());

  Local<Value> buf = Undefined(isolate);
  if (payload != nullptr) {
    buf = Buffer::Copy(isolate,
                       reinterpret_cast<const char*>(payload),
                       8).ToLocalChecked();
  }

  Local<Value> argv[] = {
      Boolean::New(isolate, ack), Number::New(isolate, duration_ms), buf};
  MakeCallback(callback(), arraysize(argv), argv);
}",3109.0,3128.0,1.0,1.0,20.0,22,10,28,14,0,0,3,3,0,0,,0,0,4,2,2,void
3847,194455,DetachFromSession,1,node.http2.Http2Ping.DetachFromSession,void node.http2.Http2Ping.DetachFromSession (),node_http2.cc,"void Http2Ping::DetachFromSession() {
  session_.reset();
}",3130.0,3132.0,1.0,1.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
3848,194463,MemoryInfo,1,node.http2.NgHttp2StreamWrite.MemoryInfo,void node.http2.NgHttp2StreamWrite.MemoryInfo (MemoryTracker*),node_http2.cc,"void NgHttp2StreamWrite::MemoryInfo(MemoryTracker* tracker) const {
  if (req_wrap)
    tracker->TrackField(""req_wrap"", req_wrap);
  tracker->TrackField(""buf"", buf);
}",3134.0,3138.0,1.0,1.0,5.0,2,1,5,3,0,0,2,2,0,0,,0,0,2,1,1,void
3849,194483,SetCallbackFunctions,1,node.http2.SetCallbackFunctions,void node.http2.SetCallbackFunctions (FunctionCallbackInfo<Value>),node_http2.cc,"void SetCallbackFunctions(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  CHECK_EQ(args.Length(), 11);

#define SET_FUNCTION(arg, name)                                               \
  CHECK(args[arg]->IsFunction());                                             \
  env->set_http2session_on_ ## name ## _function(args[arg].As<Function>());

  SET_FUNCTION(0, error)
  SET_FUNCTION(1, priority)
  SET_FUNCTION(2, settings)
  SET_FUNCTION(3, ping)
  SET_FUNCTION(4, headers)
  SET_FUNCTION(5, frame_error)
  SET_FUNCTION(6, goaway_data)
  SET_FUNCTION(7, altsvc)
  SET_FUNCTION(8, origin)
  SET_FUNCTION(9, stream_trailers)
  SET_FUNCTION(10, stream_close)

#undef SET_FUNCTION
}",3140.0,3161.0,1.0,2.0,22.0,58,4,37,3,0,0,1,1,0,0,,0,0,2,1,1,void
3850,194722,MemoryInfo,1,node.http2.Http2State.MemoryInfo,void node.http2.Http2State.MemoryInfo (MemoryTracker*),node_http2.cc,"void Http2State::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackField(""root_buffer"", root_buffer);
}",3169.0,3171.0,1.0,1.0,3.0,1,1,2,2,0,0,1,1,0,0,,0,0,2,1,1,void
3851,194733,Initialize,1,node.http2.Initialize,"void node.http2.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)",node_http2.cc,"void Initialize(Local<Object> target,
                Local<Value> unused,
                Local<Context> context,
                void* priv) {
  Realm* realm = Realm::GetCurrent(context);
  Environment* env = realm->env();
  Isolate* isolate = env->isolate();
  HandleScope handle_scope(isolate);

  Http2State* const state = realm->AddBindingData<Http2State>(context, target);
  if (state == nullptr) return;

#define SET_STATE_TYPEDARRAY(name, field)             \
  target->Set(context,                                \
              FIXED_ONE_BYTE_STRING(isolate, (name)), \
              (field)).FromJust()

  // Initialize the buffer used to store the session state
  SET_STATE_TYPEDARRAY(
    ""sessionState"", state->session_state_buffer.GetJSArray());
  // Initialize the buffer used to store the stream state
  SET_STATE_TYPEDARRAY(
    ""streamState"", state->stream_state_buffer.GetJSArray());
  SET_STATE_TYPEDARRAY(
    ""settingsBuffer"", state->settings_buffer.GetJSArray());
  SET_ST...",3174.0,3339.0,1.0,2.0,166.0,505,11,556,54,0,0,2,2,0,0,,0,0,8,4,4,void
3852,196530,NgHeaders,1,node.NgHeaders<T>.NgHeaders,"ANY node.NgHeaders<T>.NgHeaders<T> (Environment*,ANY)",node_http_common-inl.hpp,"NgHeaders<T>::NgHeaders(Environment* env, v8::Local<v8::Array> headers) {
  v8::Local<v8::Value> header_string =
      headers->Get(env->context(), 0).ToLocalChecked();
  v8::Local<v8::Value> header_count =
      headers->Get(env->context(), 1).ToLocalChecked();
  CHECK(header_count->IsUint32());
  CHECK(header_string->IsString());
  count_ = header_count.As<v8::Uint32>()->Value();
  int header_string_len = header_string.As<v8::String>()->Length();

  if (count_ == 0) {
    CHECK_EQ(header_string_len, 0);
    return;
  }

  buf_.AllocateSufficientStorage((alignof(nv_t) - 1) +
                                 count_ * sizeof(nv_t) +
                                 header_string_len);

  char* start = AlignUp(buf_.out(), alignof(nv_t));
  char* header_contents = start + (count_ * sizeof(nv_t));
  nv_t* const nva = reinterpret_cast<nv_t*>(start);

  CHECK_LE(header_contents + header_string_len, *buf_ + buf_.length());
  CHECK_EQ(header_string.As<v8::String>()->WriteOneByte(
          ...",15.0,67.0,1.0,1.0,53.0,98,17,80,16,0,0,4,5,0,0,,0,0,4,2,2,ANY
3853,196812,GetClientMaxHeaderPairs,1,node.GetClientMaxHeaderPairs,size_t node.GetClientMaxHeaderPairs (size_t),node_http_common-inl.hpp,"size_t GetClientMaxHeaderPairs(size_t max_header_pairs) {
  static constexpr size_t min_header_pairs = 1;
  return std::max(max_header_pairs, min_header_pairs);
}",69.0,72.0,1.0,1.0,4.0,2,2,4,3,0,0,1,1,0,0,,0,0,2,1,1,size_t
3854,196828,GetServerMaxHeaderPairs,1,node.GetServerMaxHeaderPairs,size_t node.GetServerMaxHeaderPairs (size_t),node_http_common-inl.hpp,"size_t GetServerMaxHeaderPairs(size_t max_header_pairs) {
  static constexpr size_t min_header_pairs = 4;
  return std::max(max_header_pairs, min_header_pairs);
}",74.0,77.0,1.0,1.0,4.0,2,2,4,3,0,0,1,1,0,0,,0,0,2,1,1,size_t
3855,196844,ToString,1,node.NgHeaderBase<allocator_t>.ToString,string node.NgHeaderBase<allocator_t>.ToString<allocator_t> (),node_http_common-inl.hpp,"std::string NgHeaderBase<allocator_t>::ToString() const {
  std::string ret = name();
  ret += "" = "";
  ret += value();
  return ret;
}",80.0,85.0,1.0,1.0,6.0,3,2,4,1,0,0,1,1,0,0,,0,0,0,0,0,string
3856,196860,IsZeroLength,1,node.NgHeader<T>.IsZeroLength,"bool node.NgHeader<T>.IsZeroLength<T> (ANY*,ANY*)",node_http_common-inl.hpp,"bool NgHeader<T>::IsZeroLength(
    int32_t token,
    NgHeader<T>::rcbuf_t* name,
    NgHeader<T>::rcbuf_t* value) {

  if (NgHeader<T>::rcbufferpointer_t::IsZeroLength(value))
    return true;

  const char* header_name = T::ToHttpHeaderName(token);
  return header_name != nullptr ||
      NgHeader<T>::rcbufferpointer_t::IsZeroLength(name);
}",95.0,106.0,1.0,1.0,12.0,1,1,2,2,0,0,1,1,0,0,,0,0,6,3,3,bool
3857,196914,NgHeader,1,node.NgHeader<T>.NgHeader,"ANY node.NgHeader<T>.NgHeader<T> (Environment*,ANY*,ANY*,uint8_t)",node_http_common-inl.hpp,"NgHeader<T>::NgHeader(NgHeader<T>&& other) noexcept
    : env_(other.env_),
      name_(std::move(other.name_)),
      value_(std::move(other.value_)),
      token_(other.token_),
      flags_(other.flags_) {
  other.token_ = -1;
  other.flags_ = 0;
  other.env_ = nullptr;
}",133.0,142.0,1.0,1.0,10.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
3858,196979,MemoryInfo,1,node.NgHeader<T>.MemoryInfo,void node.NgHeader<T>.MemoryInfo<T> (MemoryTracker*),node_http_common-inl.hpp,"void NgHeader<T>::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackField(""name"", name_);
  tracker->TrackField(""value"", value_);
}",145.0,148.0,1.0,1.0,4.0,2,1,4,3,0,0,1,1,0,0,,0,0,2,1,1,void
3859,196996,GetName,1,node.NgHeader<T>.GetName,MaybeLocal<v8::String> node.NgHeader<T>.GetName<T> (ANY*),node_http_common-inl.hpp,"v8::MaybeLocal<v8::String> NgHeader<T>::GetName(
    NgHeader<T>::allocator_t* allocator) const {

  // Not all instances will support using token id's for header names.
  // HTTP/2 specifically does not support it.
  const char* header_name = T::ToHttpHeaderName(token_);

  // If header_name is not nullptr, then it is a known header with
  // a statically defined name. We can safely internalize it here.
  if (header_name != nullptr) {
    auto& static_str_map = env_->isolate_data()->static_str_map;
    v8::Eternal<v8::String> eternal = static_str_map[header_name];
    if (eternal.IsEmpty()) {
      v8::Local<v8::String> str = OneByteString(env_->isolate(), header_name);
      eternal.Set(env_->isolate(), str);
      return str;
    }
    return eternal.Get(env_->isolate());
  }
  return rcbufferpointer_t::External::New(allocator, name_);
}",151.0,171.0,1.0,1.0,21.0,25,7,27,12,0,0,3,4,0,0,,0,0,2,1,1,MaybeLocal<v8.String>
3860,197087,GetValue,1,node.NgHeader<T>.GetValue,MaybeLocal<v8::String> node.NgHeader<T>.GetValue<T> (ANY*),node_http_common-inl.hpp,"v8::MaybeLocal<v8::String> NgHeader<T>::GetValue(
    NgHeader<T>::allocator_t* allocator) const {
  return rcbufferpointer_t::External::New(allocator, value_);
}",174.0,177.0,1.0,1.0,4.0,2,1,4,4,0,0,1,1,0,0,,0,0,2,1,1,MaybeLocal<v8.String>
3861,197101,name,1,node.NgHeader<T>.name,string node.NgHeader<T>.name<T> (),node_http_common-inl.hpp,"std::string NgHeader<T>::name() const {
  return name_.str();
}",180.0,182.0,1.0,1.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,string
3862,197110,value,1,node.NgHeader<T>.value,string node.NgHeader<T>.value<T> (),node_http_common-inl.hpp,"std::string NgHeader<T>::value() const {
  return value_.str();
}",185.0,187.0,1.0,1.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,string
3863,197119,length,1,node.NgHeader<T>.length,size_t node.NgHeader<T>.length<T> (),node_http_common-inl.hpp,"size_t NgHeader<T>::length() const {
  return name_.len() + value_.len();
}",190.0,192.0,1.0,1.0,3.0,3,2,2,2,0,0,1,1,0,0,,0,0,0,0,0,size_t
3864,197133,flags,1,node.NgHeader<T>.flags,uint8_t node.NgHeader<T>.flags<T> (),node_http_common-inl.hpp,"uint8_t NgHeader<T>::flags() const {
  return flags_;
}",195.0,197.0,1.0,1.0,3.0,0,0,1,1,0,0,1,1,0,0,,0,0,0,0,0,uint8_t
3865,197151,<lambda>0,1,node.anonymous_namespace_86.Parser.OnStreamRead.<lambda>0,ANY node.anonymous_namespace_86.Parser.OnStreamRead.<lambda>0 (),node_http_parser.cc,"[&]() {
      if (buf.base == binding_data_->parser_buffer.data())
        binding_data_->parser_buffer_in_use = false;
      else
        free(buf.base);
    }",761.0,766.0,40.0,5.0,6.0,6,4,3,2,0,2,2,2,1,0,,0,2,0,0,0,ANY
3866,197271,IsOWS,1,node.anonymous_namespace_21.IsOWS,bool node.anonymous_namespace_21.IsOWS (char),node_http_parser.cc,"inline bool IsOWS(char c) {
  return c == ' ' || c == '\t';
}",90.0,92.0,1.0,1.0,3.0,3,2,2,1,0,0,1,1,0,0,,0,0,2,1,1,bool
3867,197285,BindingData,1,node.anonymous_namespace_23.BindingData.BindingData,"ANY node.anonymous_namespace_23.BindingData.BindingData (Realm*,Local<Object>)",node_http_parser.cc,"BindingData(Realm* realm, Local<Object> obj) : BaseObject(realm, obj) {}",96.0,96.0,3.0,74.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,ANY
3868,197295,MemoryInfo,1,node.anonymous_namespace_24.BindingData.MemoryInfo,void node.anonymous_namespace_24.BindingData.MemoryInfo (MemoryTracker*),node_http_parser.cc,"void MemoryInfo(MemoryTracker* tracker) const override {
    tracker->TrackField(""parser_buffer"", parser_buffer);
  }",103.0,105.0,3.0,3.0,3.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
3869,197318,StringPtr,1,node.anonymous_namespace_26.StringPtr.StringPtr,ANY node.anonymous_namespace_26.StringPtr.StringPtr (),node_http_parser.cc,"StringPtr() {
    on_heap_ = false;
    Reset();
  }",112.0,115.0,3.0,3.0,4.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,ANY
3870,197326,~StringPtr,1,node.anonymous_namespace_28.StringPtr.~StringPtr,ANY node.anonymous_namespace_28.StringPtr.~StringPtr (),node_http_parser.cc,"~StringPtr() {
    Reset();
  }",118.0,120.0,3.0,3.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
3871,197331,Save,1,node.anonymous_namespace_30.StringPtr.Save,void node.anonymous_namespace_30.StringPtr.Save (),node_http_parser.cc,"void Save() {
    if (!on_heap_ && size_ > 0) {
      char* s = new char[size_];
      memcpy(s, str_, size_);
      str_ = s;
      on_heap_ = true;
    }
  }",126.0,133.0,3.0,3.0,8.0,7,5,10,5,0,6,2,2,2,0,,0,6,0,0,0,void
3872,197358,Reset,1,node.anonymous_namespace_31.StringPtr.Reset,void node.anonymous_namespace_31.StringPtr.Reset (),node_http_parser.cc,"void Reset() {
    if (on_heap_) {
      delete[] str_;
      on_heap_ = false;
    }

    str_ = nullptr;
    size_ = 0;
  }",136.0,144.0,3.0,3.0,9.0,4,2,5,3,0,5,2,2,1,0,,0,5,0,0,0,void
3873,197376,Update,1,node.anonymous_namespace_32.StringPtr.Update,"void node.anonymous_namespace_32.StringPtr.Update (char*,size_t)",node_http_parser.cc,"void Update(const char* str, size_t size) {
    if (str_ == nullptr) {
      str_ = str;
    } else if (on_heap_ || str_ + size_ != str) {
      // Non-consecutive input, make a copy on the heap.
      // TODO(bnoordhuis) Use slab allocation, O(n) allocs is bad.
      char* s = new char[size_ + size];
      memcpy(s, str_, size_);
      memcpy(s + size_, str, size);

      if (on_heap_)
        delete[] str_;
      else
        on_heap_ = true;

      str_ = s;
    }
    size_ += size;
  }",147.0,165.0,3.0,3.0,19.0,3,3,5,4,0,3,2,2,1,0,,0,3,4,2,2,void
3874,197432,ToString,1,node.anonymous_namespace_33.StringPtr.ToString,Local<String> node.anonymous_namespace_33.StringPtr.ToString (Environment*),node_http_parser.cc,"Local<String> ToString(Environment* env) const {
    if (size_ != 0)
      return OneByteString(env->isolate(), str_, size_);
    else
      return String::Empty(env->isolate());
  }",168.0,173.0,3.0,3.0,6.0,2,2,4,3,0,3,2,2,1,0,,0,3,2,1,1,Local<String>
3875,197461,ToTrimmedString,1,node.anonymous_namespace_34.StringPtr.ToTrimmedString,Local<String> node.anonymous_namespace_34.StringPtr.ToTrimmedString (Environment*),node_http_parser.cc,"Local<String> ToTrimmedString(Environment* env) {
    while (size_ > 0 && IsOWS(str_[size_ - 1])) {
      size_--;
    }
    return ToString(env);
  }",177.0,182.0,3.0,3.0,6.0,5,5,5,3,0,4,2,2,3,0,,0,4,2,1,1,Local<String>
3876,197488,operator (),1,node.anonymous_namespace_38.ParserComparator.operator (),"bool node.anonymous_namespace_38.ParserComparator.operator () (Parser*,Parser*)",node_http_parser.cc,"bool operator()(const Parser* lhs, const Parser* rhs) const;",193.0,193.0,8.0,61.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,bool
3877,197495,New,1,node.anonymous_namespace_40.ConnectionsList.New,void node.anonymous_namespace_40.ConnectionsList.New (FunctionCallbackInfo<Value>),node_http_parser.cc,static void New(const FunctionCallbackInfo<Value>& args);,198.0,198.0,17.0,60.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
3878,197500,All,1,node.anonymous_namespace_41.ConnectionsList.All,void node.anonymous_namespace_41.ConnectionsList.All (FunctionCallbackInfo<Value>),node_http_parser.cc,static void All(const FunctionCallbackInfo<Value>& args);,200.0,200.0,17.0,60.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
3879,197505,Idle,1,node.anonymous_namespace_42.ConnectionsList.Idle,void node.anonymous_namespace_42.ConnectionsList.Idle (FunctionCallbackInfo<Value>),node_http_parser.cc,static void Idle(const FunctionCallbackInfo<Value>& args);,202.0,202.0,17.0,61.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
3880,197510,Active,1,node.anonymous_namespace_43.ConnectionsList.Active,void node.anonymous_namespace_43.ConnectionsList.Active (FunctionCallbackInfo<Value>),node_http_parser.cc,static void Active(const FunctionCallbackInfo<Value>& args);,204.0,204.0,17.0,63.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
3881,197515,Expired,1,node.anonymous_namespace_44.ConnectionsList.Expired,void node.anonymous_namespace_44.ConnectionsList.Expired (FunctionCallbackInfo<Value>),node_http_parser.cc,static void Expired(const FunctionCallbackInfo<Value>& args);,206.0,206.0,17.0,64.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
3882,197520,Push,1,node.anonymous_namespace_45.ConnectionsList.Push,void node.anonymous_namespace_45.ConnectionsList.Push (Parser*),node_http_parser.cc,"void Push(Parser* parser) {
      all_connections_.insert(parser);
    }",208.0,210.0,5.0,5.0,3.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
3883,197530,Pop,1,node.anonymous_namespace_46.ConnectionsList.Pop,void node.anonymous_namespace_46.ConnectionsList.Pop (Parser*),node_http_parser.cc,"void Pop(Parser* parser) {
      all_connections_.erase(parser);
    }",212.0,214.0,5.0,5.0,3.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
3884,197540,PushActive,1,node.anonymous_namespace_47.ConnectionsList.PushActive,void node.anonymous_namespace_47.ConnectionsList.PushActive (Parser*),node_http_parser.cc,"void PushActive(Parser* parser) {
      active_connections_.insert(parser);
    }",216.0,218.0,5.0,5.0,3.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
3885,197550,PopActive,1,node.anonymous_namespace_48.ConnectionsList.PopActive,void node.anonymous_namespace_48.ConnectionsList.PopActive (Parser*),node_http_parser.cc,"void PopActive(Parser* parser) {
      active_connections_.erase(parser);
    }",220.0,222.0,5.0,5.0,3.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
3886,197565,Parser,1,node.anonymous_namespace_52.Parser.Parser,"ANY node.anonymous_namespace_52.Parser.Parser (BindingData*,Local<Object>)",node_http_parser.cc,"Parser(BindingData* binding_data, Local<Object> wrap)
      : AsyncWrap(binding_data->env(), wrap),
        current_buffer_len_(0),
        current_buffer_data_(nullptr),
        binding_data_(binding_data) {
  }",243.0,248.0,3.0,3.0,6.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,ANY
3887,197572,on_url,1,node.anonymous_namespace_53.Parser.on_url,"int node.anonymous_namespace_53.Parser.on_url (char*,size_t)",node_http_parser.cc,"int on_url(const char* at, size_t length) {
    int rv = TrackHeader(length);
    if (rv != 0) {
      return rv;
    }

    url_.Update(at, length);
    return 0;
  }",289.0,297.0,3.0,3.0,9.0,3,3,7,4,0,1,2,2,0,0,,0,1,4,2,2,int
3888,197598,on_status,1,node.anonymous_namespace_55.Parser.on_status,"int node.anonymous_namespace_55.Parser.on_status (char*,size_t)",node_http_parser.cc,"int on_status(const char* at, size_t length) {
    int rv = TrackHeader(length);
    if (rv != 0) {
      return rv;
    }

    status_message_.Update(at, length);
    return 0;
  }",300.0,308.0,3.0,3.0,9.0,3,3,7,4,0,1,2,2,0,0,,0,1,4,2,2,int
3889,197624,on_header_field,1,node.anonymous_namespace_57.Parser.on_header_field,"int node.anonymous_namespace_57.Parser.on_header_field (char*,size_t)",node_http_parser.cc,"int on_header_field(const char* at, size_t length) {
    int rv = TrackHeader(length);
    if (rv != 0) {
      return rv;
    }

    if (num_fields_ == num_values_) {
      // start of new field name
      num_fields_++;
      if (num_fields_ == kMaxHeaderFieldsCount) {
        // ran out of space - flush to javascript land
        Flush();
        num_fields_ = 1;
        num_values_ = 0;
      }
      fields_[num_fields_ - 1].Reset();
    }

    CHECK_LT(num_fields_, kMaxHeaderFieldsCount);
    CHECK_EQ(num_fields_, num_values_ + 1);

    fields_[num_fields_ - 1].Update(at, length);

    return 0;
  }",311.0,335.0,3.0,3.0,25.0,14,8,21,7,0,13,4,5,3,0,,0,13,4,2,2,int
3890,197689,on_header_value,1,node.anonymous_namespace_60.Parser.on_header_value,"int node.anonymous_namespace_60.Parser.on_header_value (char*,size_t)",node_http_parser.cc,"int on_header_value(const char* at, size_t length) {
    int rv = TrackHeader(length);
    if (rv != 0) {
      return rv;
    }

    if (num_values_ != num_fields_) {
      // start of new header value
      num_values_++;
      values_[num_values_ - 1].Reset();
    }

    CHECK_LT(num_values_, arraysize(values_));
    CHECK_EQ(num_values_, num_fields_);

    values_[num_values_ - 1].Update(at, length);

    return 0;
  }",338.0,356.0,3.0,3.0,19.0,10,6,17,6,0,11,3,3,2,0,,0,11,4,2,2,int
3891,197741,on_headers_complete,1,node.anonymous_namespace_62.Parser.on_headers_complete,int node.anonymous_namespace_62.Parser.on_headers_complete (),node_http_parser.cc,"int on_headers_complete() {
    headers_completed_ = true;
    header_nread_ = 0;

    // Arguments for the on-headers-complete javascript callback. This
    // list needs to be kept in sync with the actual argument list for
    // `parserOnHeadersComplete` in lib/_http_common.js.
    enum on_headers_complete_arg_index {
      A_VERSION_MAJOR = 0,
      A_VERSION_MINOR,
      A_HEADERS,
      A_METHOD,
      A_URL,
      A_STATUS_CODE,
      A_STATUS_MESSAGE,
      A_UPGRADE,
      A_SHOULD_KEEP_ALIVE,
      A_MAX
    };

    Local<Value> argv[A_MAX];
    Local<Object> obj = object();
    Local<Value> cb = obj->Get(env()->context(),
                               kOnHeadersComplete).ToLocalChecked();

    if (!cb->IsFunction())
      return 0;

    Local<Value> undefined = Undefined(env()->isolate());
    for (size_t i = 0; i < arraysize(argv); i++)
      argv[i] = undefined;

    if (have_flushed_) {
      // Slow case, flush remaining headers.
      Flush();
    } else {
      // ...",359.0,448.0,3.0,3.0,90.0,82,12,72,36,0,15,8,8,3,0,,0,15,0,0,0,int
3892,198044,on_body,1,node.anonymous_namespace_65.Parser.on_body,"int node.anonymous_namespace_65.Parser.on_body (char*,size_t)",node_http_parser.cc,"int on_body(const char* at, size_t length) {
    if (length == 0)
      return 0;

    Environment* env = this->env();
    HandleScope handle_scope(env->isolate());

    Local<Value> cb = object()->Get(env->context(), kOnBody).ToLocalChecked();

    if (!cb->IsFunction())
      return 0;

    Local<Value> buffer = Buffer::Copy(env, at, length).ToLocalChecked();

    MaybeLocal<Value> r = MakeCallback(cb.As<Function>(), 1, &buffer);

    if (r.IsEmpty()) {
      got_exception_ = true;
      llhttp_set_error_reason(&parser_, ""HPE_JS_EXCEPTION:JS Exception"");
      return HPE_USER;
    }

    return 0;
  }",451.0,474.0,3.0,3.0,24.0,25,8,25,14,0,2,4,4,0,0,,0,2,4,2,2,int
3893,198144,on_message_complete,1,node.anonymous_namespace_66.Parser.on_message_complete,int node.anonymous_namespace_66.Parser.on_message_complete (),node_http_parser.cc,"int on_message_complete() {
    HandleScope scope(env()->isolate());

    // Important: Pop from the lists BEFORE resetting the last_message_start_
    // otherwise std::set.erase will fail.
    if (connectionsList_ != nullptr) {
      connectionsList_->Pop(this);
      connectionsList_->PopActive(this);
    }

    last_message_start_ = 0;

    if (connectionsList_ != nullptr) {
      connectionsList_->Push(this);
    }

    if (num_fields_)
      Flush();  // Flush trailing HTTP headers.

    Local<Object> obj = object();
    Local<Value> cb = obj->Get(env()->context(),
                               kOnMessageComplete).ToLocalChecked();

    if (!cb->IsFunction())
      return 0;

    MaybeLocal<Value> r;
    {
      InternalCallbackScope callback_scope(
          this, InternalCallbackScope::kSkipTaskQueues);
      r = cb.As<Function>()->Call(env()->context(), object(), 0, nullptr);
      if (r.IsEmpty()) callback_scope.MarkAsFailed();
    }

    if (r.IsEmpty()) {
      got_exce...",477.0,517.0,3.0,3.0,41.0,30,8,26,14,0,8,7,7,3,0,,0,8,0,0,0,int
3894,198272,on_chunk_header,1,node.anonymous_namespace_68.Parser.on_chunk_header,int node.anonymous_namespace_68.Parser.on_chunk_header (),node_http_parser.cc,"int on_chunk_header() {
    header_nread_ = 0;
    return 0;
  }",520.0,523.0,3.0,3.0,4.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,int
3895,198281,on_chunk_complete,1,node.anonymous_namespace_69.Parser.on_chunk_complete,int node.anonymous_namespace_69.Parser.on_chunk_complete (),node_http_parser.cc,"int on_chunk_complete() {
    header_nread_ = 0;
    return 0;
  }",527.0,530.0,3.0,3.0,4.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,int
3896,198290,New,1,node.anonymous_namespace_70.Parser.New,void node.anonymous_namespace_70.Parser.New (FunctionCallbackInfo<Value>),node_http_parser.cc,"static void New(const FunctionCallbackInfo<Value>& args) {
    BindingData* binding_data = Realm::GetBindingData<BindingData>(args);
    new Parser(binding_data, args.This());
  }",532.0,535.0,3.0,3.0,4.0,6,5,7,5,0,0,1,1,0,0,,0,0,2,1,1,void
3897,198312,Close,1,node.anonymous_namespace_71.Parser.Close,void node.anonymous_namespace_71.Parser.Close (FunctionCallbackInfo<Value>),node_http_parser.cc,"static void Close(const FunctionCallbackInfo<Value>& args) {
    Parser* parser;
    ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder());

    delete parser;
  }",538.0,543.0,3.0,3.0,6.0,3,3,3,2,0,0,1,1,0,0,,0,0,2,1,1,void
3898,198327,Free,1,node.anonymous_namespace_72.Parser.Free,void node.anonymous_namespace_72.Parser.Free (FunctionCallbackInfo<Value>),node_http_parser.cc,"static void Free(const FunctionCallbackInfo<Value>& args) {
    Parser* parser;
    ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder());

    // Since the Parser destructor isn't going to run the destroy() callbacks
    // it needs to be triggered manually.
    parser->EmitTraceEventDestroy();
    parser->EmitDestroy();
  }",546.0,554.0,3.0,3.0,9.0,4,3,4,2,0,0,1,1,0,0,,0,0,2,1,1,void
3899,198348,Remove,1,node.anonymous_namespace_73.Parser.Remove,void node.anonymous_namespace_73.Parser.Remove (FunctionCallbackInfo<Value>),node_http_parser.cc,"static void Remove(const FunctionCallbackInfo<Value>& args) {
    Parser* parser;
    ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder());

    if (parser->connectionsList_ != nullptr) {
      parser->connectionsList_->Pop(parser);
      parser->connectionsList_->PopActive(parser);
    }
  }",556.0,564.0,3.0,3.0,9.0,8,4,7,2,0,3,2,2,1,0,,0,3,2,1,1,void
3900,198382,Save,1,node.anonymous_namespace_74.Parser.Save,void node.anonymous_namespace_74.Parser.Save (),node_http_parser.cc,"void Save() {
    url_.Save();
    status_message_.Save();

    for (size_t i = 0; i < num_fields_; i++) {
      fields_[i].Save();
    }

    for (size_t i = 0; i < num_values_; i++) {
      values_[i].Save();
    }
  }",566.0,577.0,3.0,3.0,12.0,10,4,12,7,0,6,3,3,2,0,,0,6,0,0,0,void
3901,198430,Execute,1,node.anonymous_namespace_75.Parser.Execute,void node.anonymous_namespace_75.Parser.Execute (FunctionCallbackInfo<Value>),node_http_parser.cc,"static void Execute(const FunctionCallbackInfo<Value>& args) {
    Parser* parser;
    ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder());

    ArrayBufferViewContents<char> buffer(args[0]);

    Local<Value> ret = parser->Execute(buffer.data(), buffer.length());

    if (!ret.IsEmpty())
      args.GetReturnValue().Set(ret);
  }",580.0,590.0,3.0,3.0,11.0,13,8,12,6,0,0,2,2,0,0,,0,0,2,1,1,void
3902,198481,Finish,1,node.anonymous_namespace_76.Parser.Finish,void node.anonymous_namespace_76.Parser.Finish (FunctionCallbackInfo<Value>),node_http_parser.cc,"static void Finish(const FunctionCallbackInfo<Value>& args) {
    Parser* parser;
    ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder());

    Local<Value> ret = parser->Execute(nullptr, 0);

    if (!ret.IsEmpty())
      args.GetReturnValue().Set(ret);
  }",593.0,601.0,3.0,3.0,9.0,10,7,9,5,0,0,2,2,0,0,,0,0,2,1,1,void
3903,198521,Initialize,1,node.anonymous_namespace_77.Parser.Initialize,void node.anonymous_namespace_77.Parser.Initialize (FunctionCallbackInfo<Value>),node_http_parser.cc,"static void Initialize(const FunctionCallbackInfo<Value>& args) {
    Environment* env = Environment::GetCurrent(args);

    uint64_t max_http_header_size = 0;
    uint32_t lenient_flags = kLenientNone;
    ConnectionsList* connectionsList = nullptr;

    CHECK(args[0]->IsInt32());
    CHECK(args[1]->IsObject());

    if (args.Length() > 2) {
      CHECK(args[2]->IsNumber());
      max_http_header_size =
          static_cast<uint64_t>(args[2].As<Number>()->Value());
    }
    if (max_http_header_size == 0) {
      max_http_header_size = env->options()->max_http_header_size;
    }

    if (args.Length() > 3) {
      CHECK(args[3]->IsInt32());
      lenient_flags = args[3].As<Int32>()->Value();
    }

    if (args.Length() > 4 && !args[4]->IsNullOrUndefined()) {
      CHECK(args[4]->IsObject());
      ASSIGN_OR_RETURN_UNWRAP(&connectionsList, args[4]);
    }

    llhttp_type_t type =
        static_cast<llhttp_type_t>(args[0].As<Int32>()->Value());

    CHECK(type == HTTP_REQUEST || ...",604.0,666.0,3.0,3.0,63.0,70,13,56,13,0,4,6,6,0,0,,0,4,2,1,1,void
3904,198763,Pause,1,node.anonymous_namespace_78.Parser.Pause,void node.anonymous_namespace_78.Parser.Pause<bool> (FunctionCallbackInfo<Value>),node_http_parser.cc,"static void Pause(const FunctionCallbackInfo<Value>& args) {
    Environment* env = Environment::GetCurrent(args);
    Parser* parser;
    ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder());
    // Should always be called from the same context.
    CHECK_EQ(env, parser->env());

    if constexpr (should_pause) {
      llhttp_pause(&parser->parser_);
    } else {
      llhttp_resume(&parser->parser_);
    }
  }",669.0,681.0,3.0,3.0,13.0,7,4,9,5,0,1,2,2,0,0,,0,1,2,1,1,void
3905,198805,Consume,1,node.anonymous_namespace_79.Parser.Consume,void node.anonymous_namespace_79.Parser.Consume (FunctionCallbackInfo<Value>),node_http_parser.cc,"static void Consume(const FunctionCallbackInfo<Value>& args) {
    Parser* parser;
    ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder());
    CHECK(args[0]->IsObject());
    StreamBase* stream = StreamBase::FromObject(args[0].As<Object>());
    CHECK_NOT_NULL(stream);
    stream->PushStreamListener(parser);
  }",684.0,691.0,3.0,3.0,8.0,9,5,9,4,0,0,1,1,0,0,,0,0,2,1,1,void
3906,198845,Unconsume,1,node.anonymous_namespace_80.Parser.Unconsume,void node.anonymous_namespace_80.Parser.Unconsume (FunctionCallbackInfo<Value>),node_http_parser.cc,"static void Unconsume(const FunctionCallbackInfo<Value>& args) {
    Parser* parser;
    ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder());

    // Already unconsumed
    if (parser->stream_ == nullptr)
      return;

    parser->stream_->RemoveStreamListener(parser);
  }",694.0,703.0,3.0,3.0,10.0,6,4,5,2,0,0,2,2,0,0,,0,0,2,1,1,void
3907,198873,GetCurrentBuffer,1,node.anonymous_namespace_81.Parser.GetCurrentBuffer,void node.anonymous_namespace_81.Parser.GetCurrentBuffer (FunctionCallbackInfo<Value>),node_http_parser.cc,"static void GetCurrentBuffer(const FunctionCallbackInfo<Value>& args) {
    Parser* parser;
    ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder());

    Local<Object> ret = Buffer::Copy(
        parser->env(),
        parser->current_buffer_data_,
        parser->current_buffer_len_).ToLocalChecked();

    args.GetReturnValue().Set(ret);
  }",706.0,716.0,3.0,3.0,11.0,12,6,11,6,0,2,1,1,0,0,,0,2,2,1,1,void
3908,198917,Duration,1,node.anonymous_namespace_82.Parser.Duration,void node.anonymous_namespace_82.Parser.Duration (FunctionCallbackInfo<Value>),node_http_parser.cc,"static void Duration(const FunctionCallbackInfo<Value>& args) {
    Parser* parser;
    ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder());

    if (parser->last_message_start_ == 0) {
      args.GetReturnValue().Set(0);
      return;
    }

    double duration = (uv_hrtime() - parser->last_message_start_) / 1e6;
    args.GetReturnValue().Set(duration);
  }",718.0,729.0,3.0,3.0,12.0,12,7,8,3,0,2,2,2,1,0,,0,2,2,1,1,void
3909,198964,HeadersCompleted,1,node.anonymous_namespace_83.Parser.HeadersCompleted,void node.anonymous_namespace_83.Parser.HeadersCompleted (FunctionCallbackInfo<Value>),node_http_parser.cc,"static void HeadersCompleted(const FunctionCallbackInfo<Value>& args) {
    Parser* parser;
    ASSIGN_OR_RETURN_UNWRAP(&parser, args.Holder());

    args.GetReturnValue().Set(parser->headers_completed_);
  }",731.0,736.0,3.0,3.0,6.0,5,3,4,2,0,1,1,1,0,0,,0,1,2,1,1,void
3910,198988,OnStreamAlloc,1,node.anonymous_namespace_84.Parser.OnStreamAlloc,uv_buf_t node.anonymous_namespace_84.Parser.OnStreamAlloc (size_t),node_http_parser.cc,"uv_buf_t OnStreamAlloc(size_t suggested_size) override {
    // For most types of streams, OnStreamRead will be immediately after
    // OnStreamAlloc, and will consume all data, so using a static buffer for
    // reading is more efficient. For other streams, just use Malloc() directly.
    if (binding_data_->parser_buffer_in_use)
      return uv_buf_init(Malloc(suggested_size), suggested_size);
    binding_data_->parser_buffer_in_use = true;

    if (binding_data_->parser_buffer.empty())
      binding_data_->parser_buffer.resize(kAllocBufferSize);

    return uv_buf_init(binding_data_->parser_buffer.data(), kAllocBufferSize);
  }",741.0,753.0,3.0,3.0,13.0,9,3,9,3,0,7,3,3,2,0,,0,7,2,1,1,uv_buf_t
3911,199032,OnStreamRead,1,node.anonymous_namespace_85.Parser.OnStreamRead,"void node.anonymous_namespace_85.Parser.OnStreamRead (ssize_t,uv_buf_t)",node_http_parser.cc,"void OnStreamRead(ssize_t nread, const uv_buf_t& buf) override {
    HandleScope scope(env()->isolate());
    // Once were done here, either indicate that the HTTP parser buffer
    // is free for re-use, or free() the data if it didnt come from there
    // in the first place.
    auto on_scope_leave = OnScopeLeave([&]() {
      if (buf.base == binding_data_->parser_buffer.data())
        binding_data_->parser_buffer_in_use = false;
      else
        free(buf.base);
    });

    if (nread < 0) {
      PassReadErrorToPreviousListener(nread);
      return;
    }

    // Ignore, empty reads have special meaning in http parser
    if (nread == 0)
      return;

    Local<Value> ret = Execute(buf.base, nread);

    // Exception
    if (ret.IsEmpty())
      return;

    Local<Value> cb =
        object()->Get(env()->context(), kOnExecute).ToLocalChecked();

    if (!cb->IsFunction())
      return;

    // Hooks for GetCurrentBuffer
    current_buffer_len_ = nread;
    current_buffer_d...",756.0,797.0,3.0,3.0,42.0,24,8,23,10,0,4,5,5,0,0,,0,4,4,2,2,void
3912,199128,Execute,1,node.anonymous_namespace_87.Parser.Execute,"Local<Value> node.anonymous_namespace_87.Parser.Execute (char*,size_t)",node_http_parser.cc,"Local<Value> Execute(const char* data, size_t len) {
    EscapableHandleScope scope(env()->isolate());

    current_buffer_len_ = len;
    current_buffer_data_ = data;
    got_exception_ = false;

    llhttp_errno_t err;

    if (data == nullptr) {
      err = llhttp_finish(&parser_);
    } else {
      err = llhttp_execute(&parser_, data, len);
      Save();
    }

    // Calculate bytes read and resume after Upgrade/CONNECT pause
    size_t nread = len;
    if (err != HPE_OK) {
      nread = llhttp_get_error_pos(&parser_) - data;

      // This isn't a real pause, just a way to stop parsing early.
      if (err == HPE_PAUSED_UPGRADE) {
        err = HPE_OK;
        llhttp_resume_after_upgrade(&parser_);
      }
    }

    // Apply pending pause
    if (pending_pause_) {
      pending_pause_ = false;
      llhttp_pause(&parser_);
    }

    current_buffer_len_ = 0;
    current_buffer_data_ = nullptr;

    // If there was an exception in one of the callbacks
    if (got_exception_)
...",800.0,878.0,3.0,3.0,79.0,72,13,74,26,0,14,9,11,3,0,,0,14,4,2,2,Local<Value>
3913,199422,CreateHeaders,1,node.anonymous_namespace_89.Parser.CreateHeaders,Local<Array> node.anonymous_namespace_89.Parser.CreateHeaders (),node_http_parser.cc,"Local<Array> CreateHeaders() {
    // There could be extra entries but the max size should be fixed
    Local<Value> headers_v[kMaxHeaderFieldsCount * 2];

    for (size_t i = 0; i < num_values_; ++i) {
      headers_v[i * 2] = fields_[i].ToString(env());
      headers_v[i * 2 + 1] = values_[i].ToTrimmedString(env());
    }

    return Array::New(env()->isolate(), headers_v, num_values_ * 2);
  }",880.0,890.0,3.0,3.0,11.0,20,8,18,9,0,4,2,2,1,0,,0,4,0,0,0,Local<Array>
3914,199488,Flush,1,node.anonymous_namespace_90.Parser.Flush,void node.anonymous_namespace_90.Parser.Flush (),node_http_parser.cc,"void Flush() {
    HandleScope scope(env()->isolate());

    Local<Object> obj = object();
    Local<Value> cb = obj->Get(env()->context(), kOnHeaders).ToLocalChecked();

    if (!cb->IsFunction())
      return;

    Local<Value> argv[2] = {
      CreateHeaders(),
      url_.ToString(env())
    };

    MaybeLocal<Value> r = MakeCallback(cb.As<Function>(),
                                       arraysize(argv),
                                       argv);

    if (r.IsEmpty())
      got_exception_ = true;

    url_.Reset();
    have_flushed_ = true;
  }",894.0,917.0,3.0,3.0,24.0,24,7,22,12,0,3,3,3,0,0,,0,3,0,0,0,void
3915,199569,Init,1,node.anonymous_namespace_91.Parser.Init,"void node.anonymous_namespace_91.Parser.Init (llhttp_type_t,uint64_t,uint32_t)",node_http_parser.cc,"void Init(llhttp_type_t type, uint64_t max_http_header_size,
            uint32_t lenient_flags) {
    llhttp_init(&parser_, type, &settings);

    if (lenient_flags & kLenientHeaders) {
      llhttp_set_lenient_headers(&parser_, 1);
    }
    if (lenient_flags & kLenientChunkedLength) {
      llhttp_set_lenient_chunked_length(&parser_, 1);
    }
    if (lenient_flags & kLenientKeepAlive) {
      llhttp_set_lenient_keep_alive(&parser_, 1);
    }

    header_nread_ = 0;
    url_.Reset();
    status_message_.Reset();
    num_fields_ = 0;
    num_values_ = 0;
    have_flushed_ = false;
    got_exception_ = false;
    headers_completed_ = false;
    max_http_header_size_ = max_http_header_size;
  }",920.0,943.0,3.0,3.0,24.0,17,4,22,17,0,14,4,4,0,0,,0,14,6,3,3,void
3916,199638,TrackHeader,1,node.anonymous_namespace_92.Parser.TrackHeader,int node.anonymous_namespace_92.Parser.TrackHeader (size_t),node_http_parser.cc,"int TrackHeader(size_t len) {
    header_nread_ += len;
    if (header_nread_ >= max_http_header_size_) {
      llhttp_set_error_reason(&parser_, ""HPE_HEADER_OVERFLOW:Header overflow"");
      return HPE_USER;
    }
    return 0;
  }",946.0,953.0,3.0,3.0,8.0,3,3,6,5,0,4,2,2,2,0,,0,4,2,1,1,int
3917,199659,MaybePause,1,node.anonymous_namespace_93.Parser.MaybePause,int node.anonymous_namespace_93.Parser.MaybePause (),node_http_parser.cc,"int MaybePause() {
    if (!pending_pause_) {
      return 0;
    }

    pending_pause_ = false;
    llhttp_set_error_reason(&parser_, ""Paused in callback"");
    return HPE_PAUSED;
  }",956.0,964.0,3.0,3.0,9.0,3,3,4,3,0,3,2,2,1,0,,0,3,0,0,0,int
3918,199678,IsNotIndicativeOfMemoryLeakAtExit,1,node.anonymous_namespace_94.Parser.IsNotIndicativeOfMemoryLeakAtExit,bool node.anonymous_namespace_94.Parser.IsNotIndicativeOfMemoryLeakAtExit (),node_http_parser.cc,"bool IsNotIndicativeOfMemoryLeakAtExit() const override {
    // HTTP parsers are able to emit events without any GC root referring
    // to them, because they receive events directly from the underlying
    // libuv resource.
    return true;
  }",967.0,972.0,3.0,3.0,6.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,bool
3919,199704,Raw,1,"node.anonymous_namespace_97.Parser.Proxy<int (Parser.*)(Args...),Member>.Raw","int node.anonymous_namespace_97.Parser.Proxy<int (Parser.*)(Args...),Member>.Raw (llhttp_t*,Args)",node_http_parser.cc,"static int Raw(llhttp_t* p, Args ... args) {
      Parser* parser = ContainerOf(&Parser::parser_, p);
      int rv = (parser->*Member)(std::forward<Args>(args)...);
      if (rv == 0) {
        rv = parser->MaybePause();
      }
      return rv;
    }",1000.0,1007.0,5.0,5.0,8.0,11,7,13,8,0,1,2,2,0,0,,0,1,4,2,2,int
3920,199746,Call,1,node.anonymous_namespace_98.Parser.Call,int node.anonymous_namespace_98.Parser.Call (),node_http_parser.cc,typedef int (Parser::*Call)();,1010.0,1010.0,15.0,31.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,int
3921,199750,DataCall,1,node.anonymous_namespace_99.Parser.DataCall,"int node.anonymous_namespace_99.Parser.DataCall (char*,size_t)",node_http_parser.cc,"typedef int (Parser::*DataCall)(const char* at, size_t length);",1011.0,1011.0,15.0,64.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
3922,199779,operator (),1,node.anonymous_namespace_100.ParserComparator.operator (),"bool node.anonymous_namespace_100.ParserComparator.operator () (Parser*,Parser*)",node_http_parser.cc,"bool ParserComparator::operator()(const Parser* lhs, const Parser* rhs) const {
  if (lhs->last_message_start_ == 0 && rhs->last_message_start_ == 0) {
    // When both parsers are idle, guarantee strict order by
    // comparing pointers as ints.
    return lhs < rhs;
  } else if (lhs->last_message_start_ == 0) {
    return true;
  } else if (rhs->last_message_start_ == 0) {
    return false;
  }

  return lhs->last_message_start_ < rhs->last_message_start_;
}",1016.0,1028.0,1.0,1.0,13.0,9,4,6,2,0,4,2,2,2,0,,0,4,4,2,2,bool
3923,199832,New,1,node.anonymous_namespace_101.ConnectionsList.New,void node.anonymous_namespace_101.ConnectionsList.New (FunctionCallbackInfo<Value>),node_http_parser.cc,"void ConnectionsList::New(const FunctionCallbackInfo<Value>& args) {
  Local<Context> context = args.GetIsolate()->GetCurrentContext();
  Environment* env = Environment::GetCurrent(context);

  new ConnectionsList(env, args.This());
}",1030.0,1035.0,1.0,1.0,6.0,9,6,10,7,0,0,1,1,0,0,,0,0,2,1,1,void
3924,199865,All,1,node.anonymous_namespace_102.ConnectionsList.All,void node.anonymous_namespace_102.ConnectionsList.All (FunctionCallbackInfo<Value>),node_http_parser.cc,"void ConnectionsList::All(const FunctionCallbackInfo<Value>& args) {
  Isolate* isolate = args.GetIsolate();

  ConnectionsList* list;

  ASSIGN_OR_RETURN_UNWRAP(&list, args.Holder());

  std::vector<Local<Value>> result;
  result.reserve(list->all_connections_.size());
  for (auto parser : list->all_connections_) {
    result.emplace_back(parser->object());
  }

  return args.GetReturnValue().Set(
      Array::New(isolate, result.data(), result.size()));
}",1037.0,1052.0,1.0,1.0,16.0,19,6,18,9,0,2,2,2,1,0,,0,2,2,1,1,void
3925,199939,Idle,1,node.anonymous_namespace_103.ConnectionsList.Idle,void node.anonymous_namespace_103.ConnectionsList.Idle (FunctionCallbackInfo<Value>),node_http_parser.cc,"void ConnectionsList::Idle(const FunctionCallbackInfo<Value>& args) {
  Isolate* isolate = args.GetIsolate();

  ConnectionsList* list;

  ASSIGN_OR_RETURN_UNWRAP(&list, args.Holder());

  std::vector<Local<Value>> result;
  result.reserve(list->all_connections_.size());
  for (auto parser : list->all_connections_) {
    if (parser->last_message_start_ == 0) {
      result.emplace_back(parser->object());
    }
  }

  return args.GetReturnValue().Set(
      Array::New(isolate, result.data(), result.size()));
}",1054.0,1071.0,1.0,1.0,18.0,21,7,19,9,0,2,3,4,1,0,,0,2,2,1,1,void
3926,200020,Active,1,node.anonymous_namespace_104.ConnectionsList.Active,void node.anonymous_namespace_104.ConnectionsList.Active (FunctionCallbackInfo<Value>),node_http_parser.cc,"void ConnectionsList::Active(const FunctionCallbackInfo<Value>& args) {
  Isolate* isolate = args.GetIsolate();

  ConnectionsList* list;

  ASSIGN_OR_RETURN_UNWRAP(&list, args.Holder());

  std::vector<Local<Value>> result;
  result.reserve(list->active_connections_.size());
  for (auto parser : list->active_connections_) {
    result.emplace_back(parser->object());
  }

  return args.GetReturnValue().Set(
      Array::New(isolate, result.data(), result.size()));
}",1073.0,1088.0,1.0,1.0,16.0,19,6,18,9,0,2,2,2,1,0,,0,2,2,1,1,void
3927,200094,Expired,1,node.anonymous_namespace_105.ConnectionsList.Expired,void node.anonymous_namespace_105.ConnectionsList.Expired (FunctionCallbackInfo<Value>),node_http_parser.cc,"void ConnectionsList::Expired(const FunctionCallbackInfo<Value>& args) {
  Isolate* isolate = args.GetIsolate();

  ConnectionsList* list;

  ASSIGN_OR_RETURN_UNWRAP(&list, args.Holder());
  CHECK(args[0]->IsNumber());
  CHECK(args[1]->IsNumber());
  uint64_t headers_timeout =
    static_cast<uint64_t>(args[0].As<Uint32>()->Value()) * 1000000;
  uint64_t request_timeout =
    static_cast<uint64_t>(args[1].As<Uint32>()->Value()) * 1000000;

  if (headers_timeout == 0 && request_timeout == 0) {
    return args.GetReturnValue().Set(Array::New(isolate, 0));
  } else if (request_timeout > 0 && headers_timeout > request_timeout) {
    std::swap(headers_timeout, request_timeout);
  }

  const uint64_t now = uv_hrtime();
  const uint64_t headers_deadline =
    headers_timeout > 0 ? now - headers_timeout : 0;
  const uint64_t request_deadline =
    request_timeout > 0 ? now - request_timeout : 0;

  auto iter = list->active_connections_.begin();
  auto end = list->active_connections_.end();
...",1090.0,1140.0,1.0,1.0,51.0,73,19,55,16,0,7,4,5,3,0,,0,7,2,1,1,void
3928,200384,InitializeHttpParser,1,node.anonymous_namespace_106.InitializeHttpParser,"void node.anonymous_namespace_106.InitializeHttpParser (Local<Object>,Local<Value>,Local<Context>,void*)",node_http_parser.cc,"void InitializeHttpParser(Local<Object> target,
                          Local<Value> unused,
                          Local<Context> context,
                          void* priv) {
  Realm* realm = Realm::GetCurrent(context);
  Environment* env = realm->env();
  Isolate* isolate = env->isolate();
  BindingData* const binding_data =
      realm->AddBindingData<BindingData>(context, target);
  if (binding_data == nullptr) return;

  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, Parser::New);
  t->InstanceTemplate()->SetInternalFieldCount(Parser::kInternalFieldCount);

  t->Set(FIXED_ONE_BYTE_STRING(env->isolate(), ""REQUEST""),
         Integer::New(env->isolate(), HTTP_REQUEST));
  t->Set(FIXED_ONE_BYTE_STRING(env->isolate(), ""RESPONSE""),
         Integer::New(env->isolate(), HTTP_RESPONSE));
  t->Set(FIXED_ONE_BYTE_STRING(env->isolate(), ""kOnMessageBegin""),
         Integer::NewFromUnsigned(env->isolate(), kOnMessageBegin));
  t->Set(FIXED_ONE_BYTE_STRING(env->isolate()...",1188.0,1268.0,1.0,1.0,81.0,111,8,166,32,0,0,2,2,0,0,,0,0,8,4,4,void
3929,201028,main,1,main,"int main (int,char[]*)",node_main.cc,"int main(int argc, char* argv[]) {
  return node::Start(argc, argv);
}",96.0,98.0,1.0,1.0,3.0,1,1,3,3,0,1,1,1,0,1,,0,0,4,2,2,int
3930,201079,NodeMainInstance,1,node.NodeMainInstance.NodeMainInstance,"ANY node.NodeMainInstance.NodeMainInstance (SnapshotData*,uv_loop_t*,MultiIsolatePlatform*,ANY,ANY)",node_main_instance.cc,"NodeMainInstance::NodeMainInstance(const SnapshotData* snapshot_data,
                                   uv_loop_t* event_loop,
                                   MultiIsolatePlatform* platform,
                                   const std::vector<std::string>& args,
                                   const std::vector<std::string>& exec_args)
    : args_(args),
      exec_args_(exec_args),
      array_buffer_allocator_(ArrayBufferAllocator::Create()),
      isolate_(nullptr),
      platform_(platform),
      isolate_data_(),
      isolate_params_(std::make_unique<Isolate::CreateParams>()),
      snapshot_data_(snapshot_data) {
  isolate_params_->array_buffer_allocator = array_buffer_allocator_.get();

  isolate_ =
      NewIsolate(isolate_params_.get(), event_loop, platform, snapshot_data);
  CHECK_NOT_NULL(isolate_);

  // If the indexes are not nullptr, we are not deserializing
  isolate_data_.reset(
      CreateIsolateData(isolate_,
                        event_loop,
          ...",33.0,62.0,1.0,1.0,30.0,13,3,15,7,0,0,1,1,0,0,,0,0,10,5,5,ANY
3931,201136,~NodeMainInstance,1,node.NodeMainInstance.~NodeMainInstance,ANY node.NodeMainInstance.~NodeMainInstance (),node_main_instance.cc,"NodeMainInstance::~NodeMainInstance() {
  if (isolate_params_ == nullptr) {
    return;
  }
  // This should only be done on a main instance that owns its isolate.
  platform_->UnregisterIsolate(isolate_);
  isolate_->Dispose();
}",64.0,71.0,1.0,1.0,8.0,3,2,4,3,0,0,2,2,0,0,,0,0,0,0,0,ANY
3932,201155,Run,1,node.NodeMainInstance.Run,ExitCode node.NodeMainInstance.Run (),node_main_instance.cc,"void NodeMainInstance::Run(ExitCode* exit_code, Environment* env) {
  if (*exit_code == ExitCode::kNoFailure) {
    bool is_sea = false;
#ifndef DISABLE_SINGLE_EXECUTABLE_APPLICATION
    if (sea::IsSingleExecutable()) {
      is_sea = true;
      LoadEnvironment(env, sea::FindSingleExecutableCode());
    }
#endif
    if (!is_sea) {
      LoadEnvironment(env, StartExecutionCallback{});
    }

    *exit_code =
        SpinEventLoopInternal(env).FromMaybe(ExitCode::kGenericUserError);
  }

#if defined(LEAK_SANITIZER)
  __lsan_do_leak_check();
#endif
}",88.0,108.0,1.0,1.0,21.0,10,7,14,7,0,0,1,1,0,0,,0,0,4,2,2,void
3933,201253,CreateMainEnvironment,1,node.NodeMainInstance.CreateMainEnvironment,"DeleteFnPtr<Environment,FreeEnvironment> node.NodeMainInstance.CreateMainEnvironment (ExitCode*)",node_main_instance.cc,"DeleteFnPtr<Environment, FreeEnvironment>
NodeMainInstance::CreateMainEnvironment(ExitCode* exit_code) {
  *exit_code = ExitCode::kNoFailure;  // Reset the exit code to 0

  HandleScope handle_scope(isolate_);

  // TODO(addaleax): This should load a real per-Isolate option, currently
  // this is still effectively per-process.
  if (isolate_data_->options()->track_heap_objects) {
    isolate_->GetHeapProfiler()->StartTrackingHeapObjects(true);
  }

  Local<Context> context;
  DeleteFnPtr<Environment, FreeEnvironment> env;

  if (snapshot_data_ != nullptr) {
    env.reset(CreateEnvironment(isolate_data_.get(),
                                Local<Context>(),  // read from snapshot
                                args_,
                                exec_args_));
#if HAVE_OPENSSL
    crypto::InitCryptoOnce(isolate_);
#endif  // HAVE_OPENSSL
  } else {
    context = NewContext(isolate_);
    CHECK(!context.IsEmpty());
    Context::Scope context_scope(context);
    env.reset(
      ...",110.0,142.0,1.0,1.0,33.0,15,8,18,14,0,0,3,3,0,0,,0,0,2,1,1,"DeleteFnPtr<Environment,FreeEnvironment>"
3934,201377,<lambda>0,1,node.worker.Message.Deserialize.<lambda>0,ANY node.worker.Message.Deserialize.<lambda>0 (),node_messaging.cc,"[&]() {
    for (BaseObjectPtr<BaseObject> object : host_objects) {
      if (!object) continue;

      // If the function did not finish successfully, host_objects will contain
      // a list of objects that will never be passed to JS. Therefore, we
      // destroy them here.
      object->Detach();
    }
  }",166.0,175.0,31.0,3.0,10.0,2,2,3,2,0,0,4,4,0,0,,0,0,0,0,0,ANY
3935,201396,<lambda>1,1,node.worker.MessagePort.MessagePort.<lambda>1,ANY node.worker.MessagePort.MessagePort.<lambda>1 (uv_async_t*),node_messaging.cc,"[](uv_async_t* handle) {
    // Called when data has been put into the queue.
    MessagePort* channel = ContainerOf(&MessagePort::async_, handle);
    channel->OnMessage(MessageProcessingMode::kNormalOperation);
  }",641.0,645.0,20.0,3.0,5.0,5,4,5,4,0,0,1,1,0,0,,0,0,2,1,1,ANY
3936,201418,<lambda>2,1,node.worker.MessagePort.MessagePort.<lambda>2,ANY node.worker.MessagePort.MessagePort.<lambda>2 (),node_messaging.cc,[&]() { if (!succeeded) Close(); },652.0,652.0,31.0,64.0,1.0,1,1,1,1,0,0,2,2,0,0,,0,0,0,0,0,ANY
3937,201461,GetTransferMode,1,node.BaseObject.GetTransferMode,TransferMode node.BaseObject.GetTransferMode (),node_messaging.cc,"BaseObject::TransferMode BaseObject::GetTransferMode() const {
  return BaseObject::TransferMode::kUntransferable;
}",50.0,52.0,1.0,1.0,3.0,2,1,2,2,0,0,1,1,0,0,,0,0,0,0,0,TransferMode
3938,201471,TransferForMessaging,1,node.BaseObject.TransferForMessaging,unique_ptr<worker::TransferData> node.BaseObject.TransferForMessaging (),node_messaging.cc,"std::unique_ptr<worker::TransferData> BaseObject::TransferForMessaging() {
  return CloneForMessaging();
}",54.0,56.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,unique_ptr<worker.TransferData>
3939,201477,CloneForMessaging,1,node.BaseObject.CloneForMessaging,unique_ptr<worker::TransferData> node.BaseObject.CloneForMessaging (),node_messaging.cc,"std::unique_ptr<worker::TransferData> BaseObject::CloneForMessaging() const {
  return {};
}",58.0,60.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,unique_ptr<worker.TransferData>
3940,201482,NestedTransferables,1,node.BaseObject.NestedTransferables,Maybe<BaseObjectList> node.BaseObject.NestedTransferables (),node_messaging.cc,"Maybe<BaseObjectList> BaseObject::NestedTransferables() const {
  return Just(BaseObjectList {});
}",62.0,64.0,1.0,1.0,3.0,1,1,0,0,0,0,1,1,0,0,,0,0,0,0,0,Maybe<BaseObjectList>
3941,201490,FinalizeTransferRead,1,node.BaseObject.FinalizeTransferRead,"Maybe<bool> node.BaseObject.FinalizeTransferRead (Local<Context>,ValueDeserializer*)",node_messaging.cc,"Maybe<bool> BaseObject::FinalizeTransferRead(
    Local<Context> context, ValueDeserializer* deserializer) {
  return Just(true);
}",66.0,69.0,1.0,1.0,4.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,Maybe<bool>
3942,201500,FinalizeTransferWrite,1,node.worker.TransferData.FinalizeTransferWrite,"Maybe<bool> node.worker.TransferData.FinalizeTransferWrite (Local<Context>,ValueSerializer*)",node_messaging.cc,"Maybe<bool> TransferData::FinalizeTransferWrite(
    Local<Context> context, ValueSerializer* serializer) {
  return Just(true);
}",73.0,76.0,1.0,1.0,4.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,Maybe<bool>
3943,201509,Message,1,node.worker.Message.Message,ANY node.worker.Message.Message (MallocedBuffer<char>),node_messaging.cc,"Message::Message(MallocedBuffer<char>&& buffer)
    : main_message_buf_(std::move(buffer)) {}",78.0,79.0,1.0,45.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
3944,201514,IsCloseMessage,1,node.worker.Message.IsCloseMessage,bool node.worker.Message.IsCloseMessage (),node_messaging.cc,"bool Message::IsCloseMessage() const {
  return main_message_buf_.data == nullptr;
}",81.0,83.0,1.0,1.0,3.0,2,2,1,1,0,0,1,1,0,0,,0,0,0,0,0,bool
3945,201526,DeserializerDelegate,1,node.worker.anonymous_namespace_2.DeserializerDelegate.DeserializerDelegate,"ANY node.worker.anonymous_namespace_2.DeserializerDelegate.DeserializerDelegate (Message*,Environment*,ANY,ANY,ANY,ANY)",node_messaging.cc,"DeserializerDelegate(
      Message* m,
      Environment* env,
      const std::vector<BaseObjectPtr<BaseObject>>& host_objects,
      const std::vector<Local<SharedArrayBuffer>>& shared_array_buffers,
      const std::vector<CompiledWasmModule>& wasm_modules,
      const std::optional<SharedValueConveyor>& shared_value_conveyor)
      : host_objects_(host_objects),
        shared_array_buffers_(shared_array_buffers),
        wasm_modules_(wasm_modules),
        shared_value_conveyor_(shared_value_conveyor) {}",91.0,101.0,3.0,56.0,11.0,0,0,0,0,0,0,1,1,0,0,,0,0,12,6,6,ANY
3946,201536,ReadHostObject,1,node.worker.anonymous_namespace_3.DeserializerDelegate.ReadHostObject,MaybeLocal<Object> node.worker.anonymous_namespace_3.DeserializerDelegate.ReadHostObject (Isolate*),node_messaging.cc,"MaybeLocal<Object> ReadHostObject(Isolate* isolate) override {
    // Identifying the index in the message's BaseObject array is sufficient.
    uint32_t id;
    if (!deserializer->ReadUint32(&id))
      return MaybeLocal<Object>();
    if (id != kNormalObject) {
      CHECK_LT(id, host_objects_.size());
      return host_objects_[id]->object(isolate);
    }
    EscapableHandleScope scope(isolate);
    Local<Context> context = isolate->GetCurrentContext();
    Local<Value> object;
    if (!deserializer->ReadValue(context).ToLocal(&object))
      return MaybeLocal<Object>();
    CHECK(object->IsObject());
    return scope.Escape(object.As<Object>());
  }",103.0,119.0,3.0,3.0,17.0,20,9,23,11,0,4,4,4,2,0,,0,4,2,1,1,MaybeLocal<Object>
3947,201619,GetSharedArrayBufferFromId,1,node.worker.anonymous_namespace_4.DeserializerDelegate.GetSharedArrayBufferFromId,"MaybeLocal<SharedArrayBuffer> node.worker.anonymous_namespace_4.DeserializerDelegate.GetSharedArrayBufferFromId (Isolate*,uint32_t)",node_messaging.cc,"MaybeLocal<SharedArrayBuffer> GetSharedArrayBufferFromId(
      Isolate* isolate, uint32_t clone_id) override {
    CHECK_LT(clone_id, shared_array_buffers_.size());
    return shared_array_buffers_[clone_id];
  }",121.0,125.0,3.0,3.0,5.0,2,2,4,2,0,2,1,1,0,0,,0,2,4,2,2,MaybeLocal<SharedArrayBuffer>
3948,201635,GetWasmModuleFromId,1,node.worker.anonymous_namespace_5.DeserializerDelegate.GetWasmModuleFromId,"MaybeLocal<WasmModuleObject> node.worker.anonymous_namespace_5.DeserializerDelegate.GetWasmModuleFromId (Isolate*,uint32_t)",node_messaging.cc,"MaybeLocal<WasmModuleObject> GetWasmModuleFromId(
      Isolate* isolate, uint32_t transfer_id) override {
    CHECK_LT(transfer_id, wasm_modules_.size());
    return WasmModuleObject::FromCompiledModule(
        isolate, wasm_modules_[transfer_id]);
  }",127.0,132.0,3.0,3.0,6.0,3,2,6,4,0,2,1,1,0,0,,0,2,4,2,2,MaybeLocal<WasmModuleObject>
3949,201656,GetSharedValueConveyor,1,node.worker.anonymous_namespace_6.DeserializerDelegate.GetSharedValueConveyor,SharedValueConveyor node.worker.anonymous_namespace_6.DeserializerDelegate.GetSharedValueConveyor (Isolate*),node_messaging.cc,"const SharedValueConveyor* GetSharedValueConveyor(Isolate* isolate) override {
    CHECK(shared_value_conveyor_.has_value());
    return &shared_value_conveyor_.value();
  }",134.0,137.0,3.0,3.0,4.0,3,2,2,1,0,2,1,1,0,0,,0,2,2,1,1,SharedValueConveyor
3950,201684,Deserialize,1,node.worker.Message.Deserialize,"MaybeLocal<Value> node.worker.Message.Deserialize (Environment*,Local<Context>,Local<Value>*)",node_messaging.cc,"MaybeLocal<Value> Message::Deserialize(Environment* env,
                                       Local<Context> context,
                                       Local<Value>* port_list) {
  Context::Scope context_scope(context);

  CHECK(!IsCloseMessage());
  if (port_list != nullptr && !transferables_.empty()) {
    // Need to create this outside of the EscapableHandleScope, but inside
    // the Context::Scope.
    *port_list = Array::New(env->isolate());
  }

  EscapableHandleScope handle_scope(env->isolate());

  // Create all necessary objects for transferables, e.g. MessagePort handles.
  std::vector<BaseObjectPtr<BaseObject>> host_objects(transferables_.size());
  auto cleanup = OnScopeLeave([&]() {
    for (BaseObjectPtr<BaseObject> object : host_objects) {
      if (!object) continue;

      // If the function did not finish successfully, host_objects will contain
      // a list of objects that will never be passed to JS. Therefore, we
      // destroy them here.
      objec...",150.0,243.0,1.0,1.0,94.0,94,13,103,32,0,1,13,21,0,0,,0,1,6,3,3,MaybeLocal<Value>
3951,202035,AddSharedArrayBuffer,1,node.worker.Message.AddSharedArrayBuffer,void node.worker.Message.AddSharedArrayBuffer (ANY),node_messaging.cc,"void Message::AddSharedArrayBuffer(
    std::shared_ptr<BackingStore> backing_store) {
  shared_array_buffers_.emplace_back(std::move(backing_store));
}",245.0,248.0,1.0,1.0,4.0,2,1,3,3,0,0,1,1,0,0,,0,0,2,1,1,void
3952,202049,AddTransferable,1,node.worker.Message.AddTransferable,void node.worker.Message.AddTransferable (ANY),node_messaging.cc,"void Message::AddTransferable(std::unique_ptr<TransferData>&& data) {
  transferables_.emplace_back(std::move(data));
}",250.0,252.0,1.0,1.0,3.0,2,1,3,3,0,0,1,1,0,0,,0,0,2,1,1,void
3953,202063,AddWASMModule,1,node.worker.Message.AddWASMModule,uint32_t node.worker.Message.AddWASMModule (CompiledWasmModule),node_messaging.cc,"uint32_t Message::AddWASMModule(CompiledWasmModule&& mod) {
  wasm_modules_.emplace_back(std::move(mod));
  return wasm_modules_.size() - 1;
}",254.0,257.0,1.0,1.0,4.0,4,2,4,3,0,0,1,1,0,0,,0,0,2,1,1,uint32_t
3954,202084,AdoptSharedValueConveyor,1,node.worker.Message.AdoptSharedValueConveyor,void node.worker.Message.AdoptSharedValueConveyor (SharedValueConveyor),node_messaging.cc,"void Message::AdoptSharedValueConveyor(SharedValueConveyor&& conveyor) {
  shared_value_conveyor_.emplace(std::move(conveyor));
}",259.0,261.0,1.0,1.0,3.0,2,1,3,3,0,0,1,1,0,0,,0,0,2,1,1,void
3955,202099,GetEmitMessageFunction,1,node.worker.anonymous_namespace_8.GetEmitMessageFunction,MaybeLocal<Function> node.worker.anonymous_namespace_8.GetEmitMessageFunction (Local<Context>),node_messaging.cc,"MaybeLocal<Function> GetEmitMessageFunction(Local<Context> context) {
  Isolate* isolate = context->GetIsolate();
  Local<Object> per_context_bindings;
  Local<Value> emit_message_val;
  if (!GetPerContextExports(context).ToLocal(&per_context_bindings) ||
      !per_context_bindings->Get(context,
                                FIXED_ONE_BYTE_STRING(isolate, ""emitMessage""))
          .ToLocal(&emit_message_val)) {
    return MaybeLocal<Function>();
  }
  CHECK(emit_message_val->IsFunction());
  return emit_message_val.As<Function>();
}",265.0,277.0,1.0,1.0,13.0,16,8,16,7,0,0,2,2,0,0,,0,0,2,1,1,MaybeLocal<Function>
3956,202158,GetDOMException,1,node.worker.anonymous_namespace_9.GetDOMException,MaybeLocal<Function> node.worker.anonymous_namespace_9.GetDOMException (Local<Context>),node_messaging.cc,"MaybeLocal<Function> GetDOMException(Local<Context> context) {
  Isolate* isolate = context->GetIsolate();
  Local<Object> per_context_bindings;
  Local<Value> domexception_ctor_val;
  if (!GetPerContextExports(context).ToLocal(&per_context_bindings) ||
      !per_context_bindings->Get(context,
                                FIXED_ONE_BYTE_STRING(isolate, ""DOMException""))
          .ToLocal(&domexception_ctor_val)) {
    return MaybeLocal<Function>();
  }
  CHECK(domexception_ctor_val->IsFunction());
  Local<Function> domexception_ctor = domexception_ctor_val.As<Function>();
  return domexception_ctor;
}",279.0,292.0,1.0,1.0,14.0,19,8,20,9,0,0,2,2,0,0,,0,0,2,1,1,MaybeLocal<Function>
3957,202224,ThrowDataCloneException,1,node.worker.anonymous_namespace_10.ThrowDataCloneException,"void node.worker.anonymous_namespace_10.ThrowDataCloneException (Local<Context>,Local<String>)",node_messaging.cc,"void ThrowDataCloneException(Local<Context> context, Local<String> message) {
  Isolate* isolate = context->GetIsolate();
  Local<Value> argv[] = {message,
                         FIXED_ONE_BYTE_STRING(isolate, ""DataCloneError"")};
  Local<Value> exception;
  Local<Function> domexception_ctor;
  if (!GetDOMException(context).ToLocal(&domexception_ctor) ||
      !domexception_ctor->NewInstance(context, arraysize(argv), argv)
           .ToLocal(&exception)) {
    return;
  }
  isolate->ThrowException(exception);
}",294.0,306.0,1.0,1.0,13.0,17,9,20,9,0,0,2,2,0,0,,0,0,4,2,2,void
3958,202287,SerializerDelegate,1,node.worker.anonymous_namespace_13.SerializerDelegate.SerializerDelegate,"ANY node.worker.anonymous_namespace_13.SerializerDelegate.SerializerDelegate (Environment*,Local<Context>,Message*)",node_messaging.cc,"SerializerDelegate(Environment* env, Local<Context> context, Message* m)
      : env_(env), context_(context), msg_(m) {}",313.0,314.0,3.0,48.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,ANY
3959,202294,ThrowDataCloneError,1,node.worker.anonymous_namespace_14.SerializerDelegate.ThrowDataCloneError,void node.worker.anonymous_namespace_14.SerializerDelegate.ThrowDataCloneError (Local<String>),node_messaging.cc,"void ThrowDataCloneError(Local<String> message) override {
    ThrowDataCloneException(context_, message);
  }",316.0,318.0,3.0,3.0,3.0,0,0,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
3960,202302,WriteHostObject,1,node.worker.anonymous_namespace_16.SerializerDelegate.WriteHostObject,"Maybe<bool> node.worker.anonymous_namespace_16.SerializerDelegate.WriteHostObject (Isolate*,Local<Object>)",node_messaging.cc,"Maybe<bool> WriteHostObject(Isolate* isolate, Local<Object> object) override {
    if (BaseObject::IsBaseObject(object)) {
      return WriteHostObject(
          BaseObjectPtr<BaseObject> { Unwrap<BaseObject>(object) });
    }

    // Convert process.env to a regular object.
    auto env_proxy_ctor_template = env_->env_proxy_ctor_template();
    if (!env_proxy_ctor_template.IsEmpty() &&
        env_proxy_ctor_template->HasInstance(object)) {
      HandleScope scope(isolate);
      // TODO(bnoordhuis) Prototype-less object in case process.env contains
      // a ""__proto__"" key? process.env has a prototype with concomitant
      // methods like toString(). It's probably confusing if that gets lost
      // in transmission.
      Local<Object> normal_object = Object::New(isolate);
      env_->env_vars()->AssignToObject(isolate, env_->context(), normal_object);
      serializer->WriteUint32(kNormalObject);  // Instead of a BaseObject.
      return serializer->WriteValue(env_->context(...",320.0,343.0,3.0,3.0,24.0,21,8,26,11,0,7,3,3,0,0,,0,7,4,2,2,Maybe<bool>
3961,202393,GetSharedArrayBufferId,1,node.worker.anonymous_namespace_18.SerializerDelegate.GetSharedArrayBufferId,"Maybe<uint32_t> node.worker.anonymous_namespace_18.SerializerDelegate.GetSharedArrayBufferId (Isolate*,Local<SharedArrayBuffer>)",node_messaging.cc,"Maybe<uint32_t> GetSharedArrayBufferId(
      Isolate* isolate,
      Local<SharedArrayBuffer> shared_array_buffer) override {
    uint32_t i;
    for (i = 0; i < seen_shared_array_buffers_.size(); ++i) {
      if (PersistentToLocal::Strong(seen_shared_array_buffers_[i]) ==
          shared_array_buffer) {
        return Just(i);
      }
    }

    seen_shared_array_buffers_.emplace_back(
      Global<SharedArrayBuffer> { isolate, shared_array_buffer });
    msg_->AddSharedArrayBuffer(shared_array_buffer->GetBackingStore());
    return Just(i);
  }",345.0,360.0,3.0,3.0,16.0,10,7,14,6,0,4,3,4,2,0,,0,4,4,2,2,Maybe<uint32_t>
3962,202447,GetWasmModuleTransferId,1,node.worker.anonymous_namespace_19.SerializerDelegate.GetWasmModuleTransferId,"Maybe<uint32_t> node.worker.anonymous_namespace_19.SerializerDelegate.GetWasmModuleTransferId (Isolate*,Local<WasmModuleObject>)",node_messaging.cc,"Maybe<uint32_t> GetWasmModuleTransferId(
      Isolate* isolate, Local<WasmModuleObject> module) override {
    return Just(msg_->AddWASMModule(module->GetCompiledModule()));
  }",362.0,365.0,3.0,3.0,4.0,2,1,2,2,0,1,1,1,0,0,,0,1,4,2,2,Maybe<uint32_t>
3963,202463,AdoptSharedValueConveyor,1,node.worker.anonymous_namespace_20.SerializerDelegate.AdoptSharedValueConveyor,"bool node.worker.anonymous_namespace_20.SerializerDelegate.AdoptSharedValueConveyor (Isolate*,SharedValueConveyor)",node_messaging.cc,"bool AdoptSharedValueConveyor(Isolate* isolate,
                                SharedValueConveyor&& conveyor) override {
    msg_->AdoptSharedValueConveyor(std::move(conveyor));
    return true;
  }",367.0,371.0,3.0,3.0,5.0,2,2,3,3,0,1,1,1,0,0,,0,1,4,2,2,bool
3964,202480,Finish,1,node.worker.anonymous_namespace_21.SerializerDelegate.Finish,Maybe<bool> node.worker.anonymous_namespace_21.SerializerDelegate.Finish (Local<Context>),node_messaging.cc,"Maybe<bool> Finish(Local<Context> context) {
    for (uint32_t i = 0; i < host_objects_.size(); i++) {
      BaseObjectPtr<BaseObject> host_object = std::move(host_objects_[i]);
      std::unique_ptr<TransferData> data;
      if (i < first_cloned_object_index_)
        data = host_object->TransferForMessaging();
      if (!data)
        data = host_object->CloneForMessaging();
      if (!data) return Nothing<bool>();
      if (data->FinalizeTransferWrite(context, serializer).IsNothing())
        return Nothing<bool>();
      msg_->AddTransferable(std::move(data));
    }
    return Just(true);
  }",373.0,387.0,3.0,3.0,15.0,22,7,26,12,0,5,6,10,3,0,,0,5,2,1,1,Maybe<bool>
3965,202572,AddHostObject,1,node.worker.anonymous_namespace_22.SerializerDelegate.AddHostObject,void node.worker.anonymous_namespace_22.SerializerDelegate.AddHostObject (BaseObjectPtr<BaseObject>),node_messaging.cc,"inline void AddHostObject(BaseObjectPtr<BaseObject> host_object) {
    // Make sure we have not started serializing the value itself yet.
    CHECK_EQ(first_cloned_object_index_, SIZE_MAX);
    host_objects_.emplace_back(std::move(host_object));
  }",389.0,393.0,3.0,3.0,5.0,2,1,5,5,0,2,1,1,0,0,,0,2,2,1,1,void
3966,202589,AddNestedHostObjects,1,node.worker.anonymous_namespace_23.SerializerDelegate.AddNestedHostObjects,Maybe<bool> node.worker.anonymous_namespace_23.SerializerDelegate.AddNestedHostObjects (),node_messaging.cc,"inline Maybe<bool> AddNestedHostObjects() {
    for (size_t i = 0; i < host_objects_.size(); i++) {
      std::vector<BaseObjectPtr<BaseObject>> nested_transferables;
      if (!host_objects_[i]->NestedTransferables().To(&nested_transferables))
        return Nothing<bool>();
      for (auto& nested_transferable : nested_transferables) {
        if (std::find(host_objects_.begin(),
                      host_objects_.end(),
                      nested_transferable) == host_objects_.end()) {
          AddHostObject(nested_transferable);
        }
      }
    }
    return Just(true);
  }",398.0,412.0,3.0,3.0,15.0,17,9,17,7,0,5,5,9,5,0,,0,5,0,0,0,Maybe<bool>
3967,202663,WriteHostObject,1,node.worker.anonymous_namespace_24.SerializerDelegate.WriteHostObject,Maybe<bool> node.worker.anonymous_namespace_24.SerializerDelegate.WriteHostObject (BaseObjectPtr<BaseObject>),node_messaging.cc,"Maybe<bool> WriteHostObject(BaseObjectPtr<BaseObject> host_object) {
    BaseObject::TransferMode mode = host_object->GetTransferMode();
    if (mode == BaseObject::TransferMode::kUntransferable) {
      ThrowDataCloneError(env_->clone_unsupported_type_str());
      return Nothing<bool>();
    }

    for (uint32_t i = 0; i < host_objects_.size(); i++) {
      if (host_objects_[i] == host_object) {
        serializer->WriteUint32(i);
        return Just(true);
      }
    }

    if (mode == BaseObject::TransferMode::kTransferable) {
      THROW_ERR_MISSING_TRANSFERABLE_IN_TRANSFER_LIST(env_);
      return Nothing<bool>();
    }

    CHECK_EQ(mode, BaseObject::TransferMode::kCloneable);
    uint32_t index = host_objects_.size();
    if (first_cloned_object_index_ == SIZE_MAX)
      first_cloned_object_index_ = index;
    serializer->WriteUint32(index);
    host_objects_.push_back(host_object);
    return Just(true);
  }",417.0,443.0,3.0,3.0,27.0,23,6,31,11,0,10,6,7,3,0,,0,10,2,1,1,Maybe<bool>
3968,202786,Serialize,1,node.worker.Message.Serialize,"Maybe<bool> node.worker.Message.Serialize (Environment*,Local<Context>,Local<Value>,TransferList,Local<Object>)",node_messaging.cc,"Maybe<bool> Message::Serialize(Environment* env,
                               Local<Context> context,
                               Local<Value> input,
                               const TransferList& transfer_list_v,
                               Local<Object> source_port) {
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(context);

  // Verify that we're not silently overwriting an existing message.
  CHECK(main_message_buf_.is_empty());

  SerializerDelegate delegate(env, context, this);
  ValueSerializer serializer(env->isolate(), &delegate);
  delegate.serializer = &serializer;

  std::vector<Local<ArrayBuffer>> array_buffers;
  for (uint32_t i = 0; i < transfer_list_v.length(); ++i) {
    Local<Value> entry = transfer_list_v[i];
    if (entry->IsObject()) {
      // See https://github.com/nodejs/node/pull/30339#issuecomment-552225353
      // for details.
      bool untransferable;
      if (!entry.As<Object>()->HasPrivate(
              contex...",457.0,585.0,1.0,1.0,129.0,65,11,70,21,0,1,15,22,0,0,,0,1,10,5,5,Maybe<bool>
3969,203225,MemoryInfo,1,node.worker.Message.MemoryInfo,void node.worker.Message.MemoryInfo (MemoryTracker*),node_messaging.cc,"void Message::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackField(""array_buffers_"", array_buffers_);
  tracker->TrackField(""shared_array_buffers"", shared_array_buffers_);
  tracker->TrackField(""transferables"", transferables_);
}",587.0,591.0,1.0,1.0,5.0,3,1,6,4,0,0,1,1,0,0,,0,0,2,1,1,void
3970,203248,MessagePortData,1,node.worker.MessagePortData.MessagePortData,ANY node.worker.MessagePortData.MessagePortData (MessagePort*),node_messaging.cc,"MessagePortData::MessagePortData(MessagePort* owner)
    : owner_(owner) {
}",593.0,595.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
3971,203253,~MessagePortData,1,node.worker.MessagePortData.~MessagePortData,ANY node.worker.MessagePortData.~MessagePortData (),node_messaging.cc,"MessagePortData::~MessagePortData() {
  CHECK_NULL(owner_);
  Disentangle();
}",597.0,600.0,1.0,1.0,4.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
3972,203259,MemoryInfo,1,node.worker.MessagePortData.MemoryInfo,void node.worker.MessagePortData.MemoryInfo (MemoryTracker*),node_messaging.cc,"void MessagePortData::MemoryInfo(MemoryTracker* tracker) const {
  Mutex::ScopedLock lock(mutex_);
  tracker->TrackField(""incoming_messages"", incoming_messages_);
}",602.0,605.0,1.0,1.0,4.0,1,1,3,3,0,0,1,1,0,0,,0,0,2,1,1,void
3973,203273,AddToIncomingQueue,1,node.worker.MessagePortData.AddToIncomingQueue,void node.worker.MessagePortData.AddToIncomingQueue (ANY),node_messaging.cc,"void MessagePortData::AddToIncomingQueue(std::shared_ptr<Message> message) {
  // This function will be called by other threads.
  Mutex::ScopedLock lock(mutex_);
  incoming_messages_.emplace_back(std::move(message));

  if (owner_ != nullptr) {
    Debug(owner_, ""Adding message to incoming queue"");
    owner_->TriggerAsync();
  }
}",607.0,616.0,1.0,1.0,10.0,4,3,7,5,0,0,2,2,0,0,,0,0,2,1,1,void
3974,203302,Entangle,1,node.worker.MessagePortData.Entangle,"void node.worker.MessagePortData.Entangle (MessagePortData*,MessagePortData*)",node_messaging.cc,"void MessagePortData::Entangle(MessagePortData* a, MessagePortData* b) {
  auto group = std::make_shared<SiblingGroup>();
  group->Entangle({a, b});
}",618.0,621.0,1.0,1.0,4.0,4,4,5,4,0,0,1,1,0,0,,0,0,4,2,2,void
3975,203322,Disentangle,1,node.worker.MessagePortData.Disentangle,void node.worker.MessagePortData.Disentangle (),node_messaging.cc,"void MessagePortData::Disentangle() {
  if (group_) {
    group_->Disentangle(this);
  }
}",623.0,627.0,1.0,1.0,5.0,1,1,2,1,0,0,2,2,0,0,,0,0,0,0,0,void
3976,203334,~MessagePort,1,node.worker.MessagePort.~MessagePort,ANY node.worker.MessagePort.~MessagePort (),node_messaging.cc,"MessagePort::~MessagePort() {
  if (data_) Detach();
}",629.0,631.0,1.0,1.0,3.0,0,0,1,1,0,0,2,2,0,0,,0,0,0,0,0,ANY
3977,203342,MessagePort,1,node.worker.MessagePort.MessagePort,"ANY node.worker.MessagePort.MessagePort (Environment*,Local<Context>,Local<Object>)",node_messaging.cc,"MessagePort::MessagePort(Environment* env,
                         Local<Context> context,
                         Local<Object> wrap)
  : HandleWrap(env,
               wrap,
               reinterpret_cast<uv_handle_t*>(&async_),
               AsyncWrap::PROVIDER_MESSAGEPORT),
    data_(new MessagePortData(this)) {
  auto onmessage = [](uv_async_t* handle) {
    // Called when data has been put into the queue.
    MessagePort* channel = ContainerOf(&MessagePort::async_, handle);
    channel->OnMessage(MessageProcessingMode::kNormalOperation);
  };

  CHECK_EQ(uv_async_init(env->event_loop(),
                         &async_,
                         onmessage), 0);
  // Reset later to indicate success of the constructor.
  bool succeeded = false;
  auto cleanup = OnScopeLeave([&]() { if (!succeeded) Close(); });

  Local<Value> fn;
  if (!wrap->Get(context, env->oninit_symbol()).ToLocal(&fn))
    return;

  if (fn->IsFunction()) {
    Local<Function> init = fn.As<Function>();
 ...",633.0,671.0,1.0,1.0,39.0,27,7,30,14,0,0,5,6,0,0,,0,0,6,3,3,ANY
3978,203455,IsDetached,1,node.worker.MessagePort.IsDetached,bool node.worker.MessagePort.IsDetached (),node_messaging.cc,"bool MessagePort::IsDetached() const {
  return data_ == nullptr || IsHandleClosing();
}",673.0,675.0,1.0,1.0,3.0,2,2,1,1,0,0,1,1,0,0,,0,0,0,0,0,bool
3979,203465,TriggerAsync,1,node.worker.MessagePort.TriggerAsync,void node.worker.MessagePort.TriggerAsync (),node_messaging.cc,"void MessagePort::TriggerAsync() {
  if (IsHandleClosing()) return;
  CHECK_EQ(uv_async_send(&async_), 0);
}",677.0,680.0,1.0,1.0,4.0,1,1,1,1,0,0,2,2,0,0,,0,0,0,0,0,void
3980,203478,Close,1,node.worker.MessagePort.Close,void node.worker.MessagePort.Close (ANY),node_messaging.cc,"void MessagePort::Close(v8::Local<v8::Value> close_callback) {
  Debug(this, ""Closing message port, data set = %d"", static_cast<int>(!!data_));

  if (data_) {
    // Wrap this call with accessing the mutex, so that TriggerAsync()
    // can check IsHandleClosing() without race conditions.
    Mutex::ScopedLock sibling_lock(data_->mutex_);
    HandleWrap::Close(close_callback);
  } else {
    HandleWrap::Close(close_callback);
  }
}",682.0,693.0,1.0,1.0,12.0,5,4,5,3,0,0,2,2,0,0,,0,0,2,1,1,void
3981,203511,New,1,node.worker.MessagePort.New,void node.worker.MessagePort.New (FunctionCallbackInfo<Value>),node_messaging.cc,"MessagePort* MessagePort::New(
    Environment* env,
    Local<Context> context,
    std::unique_ptr<MessagePortData> data,
    std::shared_ptr<SiblingGroup> sibling_group) {
  Context::Scope context_scope(context);
  Local<FunctionTemplate> ctor_templ = GetMessagePortConstructorTemplate(env);

  // Construct a new instance, then assign the listener instance and possibly
  // the MessagePortData to it.
  Local<Object> instance;
  if (!ctor_templ->InstanceTemplate()->NewInstance(context).ToLocal(&instance))
    return nullptr;
  MessagePort* port = new MessagePort(env, context, instance);
  CHECK_NOT_NULL(port);
  if (port->IsHandleClosing()) {
    // Construction failed with an exception.
    return nullptr;
  }

  if (data) {
    CHECK(!sibling_group);
    port->Detach();
    port->data_ = std::move(data);

    // This lock is here to avoid race conditions with the `owner_` read
    // in AddToIncomingQueue(). (This would likely be unproblematic without it,
    // but it's better t...",703.0,740.0,1.0,1.0,38.0,2,2,4,3,0,0,1,1,0,0,,0,0,8,4,4,MessagePort
3982,203640,ReceiveMessage,1,node.worker.MessagePort.ReceiveMessage,"MaybeLocal<Value> node.worker.MessagePort.ReceiveMessage (Local<Context>,MessageProcessingMode,Local<Value>*)",node_messaging.cc,"void MessagePort::ReceiveMessage(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  if (!args[0]->IsObject() ||
      !env->message_port_constructor_template()->HasInstance(args[0])) {
    return THROW_ERR_INVALID_ARG_TYPE(env,
        ""The \""port\"" argument must be a MessagePort instance"");
  }
  MessagePort* port = Unwrap<MessagePort>(args[0].As<Object>());
  if (port == nullptr) {
    // Return 'no messages' for a closed port.
    args.GetReturnValue().Set(
        Environment::GetCurrent(args)->no_message_symbol());
    return;
  }

  MaybeLocal<Value> payload = port->ReceiveMessage(
      port->object()->GetCreationContext().ToLocalChecked(),
      MessageProcessingMode::kForceReadMessages);
  if (!payload.IsEmpty())
    args.GetReturnValue().Set(payload.ToLocalChecked());
}",1090.0,1110.0,1.0,1.0,21.0,28,9,18,10,0,0,4,4,0,0,,0,0,2,1,1,void
3983,203743,OnMessage,1,node.worker.MessagePort.OnMessage,void node.worker.MessagePort.OnMessage (MessageProcessingMode),node_messaging.cc,"void MessagePort::OnMessage(MessageProcessingMode mode) {
  Debug(this, ""Running MessagePort::OnMessage()"");
  HandleScope handle_scope(env()->isolate());
  Local<Context> context =
      object(env()->isolate())->GetCreationContext().ToLocalChecked();

  size_t processing_limit;
  if (mode == MessageProcessingMode::kNormalOperation) {
    Mutex::ScopedLock(data_->mutex_);
    processing_limit = std::max(data_->incoming_messages_.size(),
                                static_cast<size_t>(1000));
  } else {
    processing_limit = std::numeric_limits<size_t>::max();
  }

  // data_ can only ever be modified by the owner thread, so no need to lock.
  // However, the message port may be transferred while it is processing
  // messages, so we need to check that this handle still owns its `data_` field
  // on every iteration.
  while (data_) {
    if (processing_limit-- == 0) {
      // Prevent event loop starvation by only processing those messages without
      // interruption that we...",779.0,857.0,1.0,1.0,79.0,66,12,53,19,0,0,14,22,0,0,,0,0,2,1,1,void
3984,203997,OnClose,1,node.worker.MessagePort.OnClose,void node.worker.MessagePort.OnClose (),node_messaging.cc,"void MessagePort::OnClose() {
  Debug(this, ""MessagePort::OnClose()"");
  if (data_) {
    // Detach() returns move(data_).
    Detach()->Disentangle();
  }
}",859.0,865.0,1.0,1.0,7.0,1,1,1,1,0,0,2,2,0,0,,0,0,0,0,0,void
3985,204011,Detach,1,node.worker.MessagePort.Detach,unique_ptr<MessagePortData> node.worker.MessagePort.Detach (),node_messaging.cc,"std::unique_ptr<MessagePortData> MessagePort::Detach() {
  CHECK(data_);
  Mutex::ScopedLock lock(data_->mutex_);
  data_->owner_ = nullptr;
  return std::move(data_);
}",867.0,872.0,1.0,1.0,6.0,4,3,4,2,0,0,1,1,0,0,,0,0,0,0,0,unique_ptr<MessagePortData>
3986,204032,GetTransferMode,1,node.worker.MessagePort.GetTransferMode,TransferMode node.worker.MessagePort.GetTransferMode (),node_messaging.cc,"BaseObject::TransferMode MessagePort::GetTransferMode() const {
  if (IsDetached())
    return BaseObject::TransferMode::kUntransferable;
  return BaseObject::TransferMode::kTransferable;
}",874.0,878.0,1.0,1.0,5.0,4,1,4,2,0,0,2,2,0,0,,0,0,0,0,0,TransferMode
3987,204051,TransferForMessaging,1,node.worker.MessagePort.TransferForMessaging,unique_ptr<TransferData> node.worker.MessagePort.TransferForMessaging (),node_messaging.cc,"std::unique_ptr<TransferData> MessagePort::TransferForMessaging() {
  Close();
  return Detach();
}",880.0,883.0,1.0,1.0,4.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,unique_ptr<TransferData>
3988,204058,Deserialize,1,node.worker.MessagePortData.Deserialize,"BaseObjectPtr<BaseObject> node.worker.MessagePortData.Deserialize (Environment*,Local<Context>,ANY)",node_messaging.cc,"BaseObjectPtr<BaseObject> MessagePortData::Deserialize(
    Environment* env,
    Local<Context> context,
    std::unique_ptr<TransferData> self) {
  return BaseObjectPtr<MessagePort> { MessagePort::New(
      env, context,
      static_unique_pointer_cast<MessagePortData>(std::move(self))) };
}",885.0,892.0,1.0,1.0,8.0,5,4,7,7,0,0,1,1,0,0,,0,0,6,3,3,BaseObjectPtr<BaseObject>
3989,204083,PostMessage,1,node.worker.MessagePort.PostMessage,"Maybe<bool> node.worker.MessagePort.PostMessage (Environment*,Local<Context>,Local<Value>,TransferList)",node_messaging.cc,"void MessagePort::PostMessage(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Local<Object> obj = args.This();
  Local<Context> context = obj->GetCreationContext().ToLocalChecked();

  if (args.Length() == 0) {
    return THROW_ERR_MISSING_ARGS(env, ""Not enough arguments to ""
                                       ""MessagePort.postMessage"");
  }

  if (!args[1]->IsNullOrUndefined() && !args[1]->IsObject()) {
    // Browsers ignore null or undefined, and otherwise accept an array or an
    // options object.
    return THROW_ERR_INVALID_ARG_TYPE(env,
        ""Optional transferList argument must be an iterable"");
  }

  TransferList transfer_list;
  if (args[1]->IsObject()) {
    bool was_iterable;
    if (!ReadIterable(env, context, transfer_list, args[1]).To(&was_iterable))
      return;
    if (!was_iterable) {
      Local<Value> transfer_option;
      if (!args[1].As<Object>()->Get(context, env->transfer_string())
          .ToLocal...",994.0,1044.0,1.0,1.0,51.0,21,8,30,15,0,0,5,5,0,0,,0,0,2,1,1,void
3990,204179,Dispatch,1,node.worker.MessagePortData.Dispatch,"Maybe<bool> node.worker.MessagePortData.Dispatch (ANY,ANY*)",node_messaging.cc,"Maybe<bool> MessagePortData::Dispatch(
    std::shared_ptr<Message> message,
    std::string* error) {
  if (!group_) {
    if (error != nullptr)
      *error = ""MessagePortData is not entangled."";
    return Nothing<bool>();
  }
  return group_->Dispatch(this, message, error);
}",926.0,935.0,1.0,1.0,10.0,5,5,6,3,0,0,3,4,0,0,,0,0,4,2,2,Maybe<bool>
3991,204208,ReadIterable,1,node.worker.ReadIterable,"Maybe<bool> node.worker.ReadIterable (Environment*,Local<Context>,TransferList,Local<Value>)",node_messaging.cc,"static Maybe<bool> ReadIterable(Environment* env,
                                Local<Context> context,
                                // NOLINTNEXTLINE(runtime/references)
                                TransferList& transfer_list,
                                Local<Value> object) {
  if (!object->IsObject()) return Just(false);

  if (object->IsArray()) {
    Local<Array> arr = object.As<Array>();
    size_t length = arr->Length();
    transfer_list.AllocateSufficientStorage(length);
    for (size_t i = 0; i < length; i++) {
      if (!arr->Get(context, i).ToLocal(&transfer_list[i]))
        return Nothing<bool>();
    }
    return Just(true);
  }

  Isolate* isolate = env->isolate();
  Local<Value> iterator_method;
  if (!object.As<Object>()->Get(context, Symbol::GetIterator(isolate))
      .ToLocal(&iterator_method)) return Nothing<bool>();
  if (!iterator_method->IsFunction()) return Just(false);

  Local<Value> iterator;
  if (!iterator_method.As<Function>()->Call(conte...",937.0,992.0,1.0,1.0,56.0,87,9,82,20,0,0,18,25,0,0,,0,0,8,4,4,Maybe<bool>
3992,204771,Start,1,node.worker.MessagePort.Start,void node.worker.MessagePort.Start (),node_messaging.cc,"void MessagePort::Start(const FunctionCallbackInfo<Value>& args) {
  MessagePort* port;
  ASSIGN_OR_RETURN_UNWRAP(&port, args.This());
  if (!port->data_) {
    return;
  }
  port->Start();
}",1059.0,1066.0,1.0,1.0,8.0,5,4,3,2,0,0,2,2,0,0,,0,0,2,1,1,void
3993,204796,Stop,1,node.worker.MessagePort.Stop,void node.worker.MessagePort.Stop (),node_messaging.cc,"void MessagePort::Stop(const FunctionCallbackInfo<Value>& args) {
  MessagePort* port;
  CHECK(args[0]->IsObject());
  ASSIGN_OR_RETURN_UNWRAP(&port, args[0].As<Object>());
  if (!port->data_) {
    return;
  }
  port->Stop();
}",1068.0,1076.0,1.0,1.0,9.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,void
3994,204863,CheckType,1,node.worker.MessagePort.CheckType,void node.worker.MessagePort.CheckType (FunctionCallbackInfo<Value>),node_messaging.cc,"void MessagePort::CheckType(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  args.GetReturnValue().Set(
      GetMessagePortConstructorTemplate(env)->HasInstance(args[0]));
}",1078.0,1082.0,1.0,1.0,5.0,6,4,6,3,0,0,1,1,0,0,,0,0,2,1,1,void
3995,204891,Drain,1,node.worker.MessagePort.Drain,void node.worker.MessagePort.Drain (FunctionCallbackInfo<Value>),node_messaging.cc,"void MessagePort::Drain(const FunctionCallbackInfo<Value>& args) {
  MessagePort* port;
  ASSIGN_OR_RETURN_UNWRAP(&port, args[0].As<Object>());
  port->OnMessage(MessageProcessingMode::kForceReadMessages);
}",1084.0,1088.0,1.0,1.0,5.0,5,4,4,3,0,0,1,1,0,0,,0,0,2,1,1,void
3996,205026,MoveToContext,1,node.worker.MessagePort.MoveToContext,void node.worker.MessagePort.MoveToContext (FunctionCallbackInfo<Value>),node_messaging.cc,"void MessagePort::MoveToContext(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  if (!args[0]->IsObject() ||
      !env->message_port_constructor_template()->HasInstance(args[0])) {
    return THROW_ERR_INVALID_ARG_TYPE(env,
        ""The \""port\"" argument must be a MessagePort instance"");
  }
  MessagePort* port = Unwrap<MessagePort>(args[0].As<Object>());
  if (port == nullptr || port->IsHandleClosing()) {
    Isolate* isolate = env->isolate();
    THROW_ERR_CLOSED_MESSAGE_PORT(isolate);
    return;
  }

  Local<Value> context_arg = args[1];
  ContextifyContext* context_wrapper;
  if (!context_arg->IsObject() ||
      (context_wrapper = ContextifyContext::ContextFromContextifiedSandbox(
          env, context_arg.As<Object>())) == nullptr) {
    return THROW_ERR_INVALID_ARG_TYPE(env, ""Invalid context argument"");
  }

  std::unique_ptr<MessagePortData> data;
  if (!port->IsDetached())
    data = port->Detach();

  Context::Scope contex...",1112.0,1143.0,1.0,1.0,32.0,47,10,42,16,0,0,6,6,0,0,,0,0,2,1,1,void
3997,205191,Entangle,1,node.worker.MessagePort.Entangle,"void node.worker.MessagePort.Entangle (MessagePort*,MessagePort*)",node_messaging.cc,"void MessagePort::Entangle(MessagePort* a, MessagePortData* b) {
  MessagePortData::Entangle(a->data_.get(), b);
}",1149.0,1151.0,1.0,1.0,3.0,5,2,3,3,0,0,1,1,0,0,,0,0,4,2,2,void
3998,205230,MemoryInfo,1,node.worker.MessagePort.MemoryInfo,void node.worker.MessagePort.MemoryInfo (MemoryTracker*),node_messaging.cc,"void MessagePort::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackField(""data"", data_);
  tracker->TrackField(""emit_message_fn"", emit_message_fn_);
}",1153.0,1156.0,1.0,1.0,4.0,2,1,4,3,0,0,1,1,0,0,,0,0,2,1,1,void
3999,205247,GetMessagePortConstructorTemplate,1,node.worker.GetMessagePortConstructorTemplate,Local<FunctionTemplate> node.worker.GetMessagePortConstructorTemplate (Environment*),node_messaging.cc,"Local<FunctionTemplate> GetMessagePortConstructorTemplate(Environment* env) {
  // Factor generating the MessagePort JS constructor into its own piece
  // of code, because it is needed early on in the child environment setup.
  Local<FunctionTemplate> templ = env->message_port_constructor_template();
  if (!templ.IsEmpty())
    return templ;

  {
    Isolate* isolate = env->isolate();
    Local<FunctionTemplate> m = NewFunctionTemplate(isolate, MessagePort::New);
    m->SetClassName(env->message_port_constructor_string());
    m->InstanceTemplate()->SetInternalFieldCount(
        MessagePort::kInternalFieldCount);
    m->Inherit(HandleWrap::GetConstructorTemplate(env));

    SetProtoMethod(isolate, m, ""postMessage"", MessagePort::PostMessage);
    SetProtoMethod(isolate, m, ""start"", MessagePort::Start);

    env->set_message_port_constructor_template(m);
  }

  return GetMessagePortConstructorTemplate(env);
}",1158.0,1180.0,1.0,1.0,23.0,22,6,29,8,0,0,2,2,0,0,,0,0,2,1,1,Local<FunctionTemplate>
4000,205339,JSTransferable,1,node.worker.JSTransferable.JSTransferable,"ANY node.worker.JSTransferable.JSTransferable (Environment*,Local<Object>)",node_messaging.cc,"JSTransferable::JSTransferable(Environment* env, Local<Object> obj)
    : BaseObject(env, obj) {
  MakeWeak();
}",1182.0,1185.0,1.0,1.0,4.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,ANY
4001,205346,New,1,node.worker.JSTransferable.New,void node.worker.JSTransferable.New (FunctionCallbackInfo<Value>),node_messaging.cc,"void JSTransferable::New(const FunctionCallbackInfo<Value>& args) {
  CHECK(args.IsConstructCall());
  new JSTransferable(Environment::GetCurrent(args), args.This());
}",1187.0,1190.0,1.0,1.0,4.0,4,2,5,3,0,0,1,1,0,0,,0,0,2,1,1,void
4002,205367,GetTransferMode,1,node.worker.JSTransferable.GetTransferMode,TransferMode node.worker.JSTransferable.GetTransferMode (),node_messaging.cc,"JSTransferable::TransferMode JSTransferable::GetTransferMode() const {
  // Implement `kClone in this ? kCloneable : kTransferable`.
  HandleScope handle_scope(env()->isolate());
  errors::TryCatchScope ignore_exceptions(env());

  bool has_clone;
  if (!object()->Has(env()->context(),
                     env()->messaging_clone_symbol()).To(&has_clone)) {
    return TransferMode::kUntransferable;
  }

  return has_clone ? TransferMode::kCloneable : TransferMode::kTransferable;
}",1192.0,1204.0,1.0,1.0,13.0,11,5,5,2,0,0,2,2,0,0,,0,0,0,0,0,TransferMode
4003,205414,TransferForMessaging,1,node.worker.JSTransferable.TransferForMessaging,unique_ptr<TransferData> node.worker.JSTransferable.TransferForMessaging (),node_messaging.cc,"std::unique_ptr<TransferData> JSTransferable::TransferForMessaging() {
  return TransferOrClone(TransferMode::kTransferable);
}",1206.0,1208.0,1.0,1.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,unique_ptr<TransferData>
4004,205423,CloneForMessaging,1,node.worker.JSTransferable.CloneForMessaging,unique_ptr<TransferData> node.worker.JSTransferable.CloneForMessaging (),node_messaging.cc,"std::unique_ptr<TransferData> JSTransferable::CloneForMessaging() const {
  return TransferOrClone(TransferMode::kCloneable);
}",1210.0,1212.0,1.0,1.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,unique_ptr<TransferData>
4005,205432,TransferOrClone,1,node.worker.JSTransferable.TransferOrClone,unique_ptr<TransferData> node.worker.JSTransferable.TransferOrClone (TransferMode),node_messaging.cc,"std::unique_ptr<TransferData> JSTransferable::TransferOrClone(
    TransferMode mode) const {
  // Call `this[symbol]()` where `symbol` is `kClone` or `kTransfer`,
  // which should return an object with `data` and `deserializeInfo` properties;
  // `data` is written to the serializer later, and `deserializeInfo` is stored
  // on the `TransferData` instance as a string.
  HandleScope handle_scope(env()->isolate());
  Local<Context> context = env()->isolate()->GetCurrentContext();
  Local<Symbol> method_name = mode == TransferMode::kCloneable ?
      env()->messaging_clone_symbol() : env()->messaging_transfer_symbol();

  Local<Value> method;
  if (!object()->Get(context, method_name).ToLocal(&method)) {
    return {};
  }
  if (method->IsFunction()) {
    Local<Value> result_v;
    if (!method.As<Function>()->Call(
            context, object(), 0, nullptr).ToLocal(&result_v)) {
      return {};
    }

    if (result_v->IsObject()) {
      Local<Object> result = result_v.As<Object>...",1214.0,1256.0,1.0,1.0,43.0,65,13,49,18,0,0,8,14,0,0,,0,0,2,1,1,unique_ptr<TransferData>
4006,205638,NestedTransferables,1,node.worker.JSTransferable.NestedTransferables,Maybe<BaseObjectList> node.worker.JSTransferable.NestedTransferables (),node_messaging.cc,"Maybe<BaseObjectList>
JSTransferable::NestedTransferables() const {
  // Call `this[kTransferList]()` and return the resulting list of BaseObjects.
  HandleScope handle_scope(env()->isolate());
  Local<Context> context = env()->isolate()->GetCurrentContext();
  Local<Symbol> method_name = env()->messaging_transfer_list_symbol();

  Local<Value> method;
  if (!object()->Get(context, method_name).ToLocal(&method)) {
    return Nothing<BaseObjectList>();
  }
  if (!method->IsFunction()) return Just(BaseObjectList {});

  Local<Value> list_v;
  if (!method.As<Function>()->Call(
          context, object(), 0, nullptr).ToLocal(&list_v)) {
    return Nothing<BaseObjectList>();
  }
  if (!list_v->IsArray()) return Just(BaseObjectList {});
  Local<Array> list = list_v.As<Array>();

  BaseObjectList ret;
  for (size_t i = 0; i < list->Length(); i++) {
    Local<Value> value;
    if (!list->Get(context, i).ToLocal(&value))
      return Nothing<BaseObjectList>();
    if (value->IsObject() && B...",1258.0,1288.0,1.0,1.0,31.0,49,9,42,15,0,0,8,10,0,0,,0,0,0,0,0,Maybe<BaseObjectList>
4007,205814,FinalizeTransferRead,1,node.worker.JSTransferable.FinalizeTransferRead,"Maybe<bool> node.worker.JSTransferable.FinalizeTransferRead (Local<Context>,ValueDeserializer*)",node_messaging.cc,"Maybe<bool> JSTransferable::FinalizeTransferRead(
    Local<Context> context, ValueDeserializer* deserializer) {
  // Call `this[kDeserialize](data)` where `data` comes from the return value
  // of `this[kTransfer]()` or `this[kClone]()`.
  HandleScope handle_scope(env()->isolate());
  Local<Value> data;
  if (!deserializer->ReadValue(context).ToLocal(&data)) return Nothing<bool>();

  Local<Symbol> method_name = env()->messaging_deserialize_symbol();
  Local<Value> method;
  if (!object()->Get(context, method_name).ToLocal(&method)) {
    return Nothing<bool>();
  }
  if (!method->IsFunction()) return Just(true);

  if (method.As<Function>()->Call(context, object(), 1, &data).IsEmpty()) {
    return Nothing<bool>();
  }
  return Just(true);
}",1290.0,1309.0,1.0,1.0,20.0,23,7,19,8,0,0,5,5,0,0,,0,0,4,2,2,Maybe<bool>
4008,205909,Data,1,node.worker.JSTransferable.Data.Data,"ANY node.worker.JSTransferable.Data.Data (ANY,ANY)",node_messaging.cc,"JSTransferable::Data::Data(std::string&& deserialize_info,
                           v8::Global<v8::Value>&& data)
    : deserialize_info_(std::move(deserialize_info)),
      data_(std::move(data)) {}",1311.0,1314.0,1.0,31.0,4.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,ANY
4009,205915,Deserialize,1,node.worker.JSTransferable.Data.Deserialize,"BaseObjectPtr<BaseObject> node.worker.JSTransferable.Data.Deserialize (Environment*,Local<Context>,ANY)",node_messaging.cc,"BaseObjectPtr<BaseObject> JSTransferable::Data::Deserialize(
    Environment* env,
    Local<Context> context,
    std::unique_ptr<TransferData> self) {
  // Create the JS wrapper object that will later be filled with data passed to
  // the `[kDeserialize]()` method on it. This split is necessary, because here
  // we need to create an object with the right prototype and internal fields,
  // but the actual JS data stored in the serialized data can only be read at
  // the end of the stream, after the main message has been read.

  if (context != env->context()) {
    THROW_ERR_MESSAGE_TARGET_CONTEXT_UNAVAILABLE(env);
    return {};
  }
  HandleScope handle_scope(env->isolate());
  Local<Value> info;
  if (!ToV8Value(context, deserialize_info_).ToLocal(&info)) return {};

  Local<Value> ret;
  CHECK(!env->messaging_deserialize_create_object().IsEmpty());
  if (!env->messaging_deserialize_create_object()
           ->Call(context, Null(env->isolate()), 1, &info)
           .ToLocal(...",1316.0,1344.0,1.0,1.0,29.0,30,9,25,9,0,0,4,4,0,0,,0,0,6,3,3,BaseObjectPtr<BaseObject>
4010,206019,FinalizeTransferWrite,1,node.worker.JSTransferable.Data.FinalizeTransferWrite,"Maybe<bool> node.worker.JSTransferable.Data.FinalizeTransferWrite (Local<Context>,ValueSerializer*)",node_messaging.cc,"Maybe<bool> JSTransferable::Data::FinalizeTransferWrite(
    Local<Context> context, ValueSerializer* serializer) {
  HandleScope handle_scope(context->GetIsolate());
  auto ret = serializer->WriteValue(context, PersistentToLocal::Strong(data_));
  data_.Reset();
  return ret;
}",1346.0,1352.0,1.0,1.0,7.0,5,3,8,5,0,0,1,1,0,0,,0,0,4,2,2,Maybe<bool>
4011,206050,Get,1,node.worker.SiblingGroup.Get,shared_ptr<SiblingGroup> node.worker.SiblingGroup.Get (ANY),node_messaging.cc,"std::shared_ptr<SiblingGroup> SiblingGroup::Get(const std::string& name) {
  Mutex::ScopedLock lock(SiblingGroup::groups_mutex_);
  std::shared_ptr<SiblingGroup> group;
  auto i = groups_.find(name);
  if (i == groups_.end() || i->second.expired()) {
    group = std::make_shared<SiblingGroup>(name);
    groups_[name] = group;
  } else {
    group = i->second.lock();
  }
  return group;
}",1354.0,1365.0,1.0,1.0,12.0,17,8,18,6,0,0,2,2,0,0,,0,0,2,1,1,shared_ptr<SiblingGroup>
4012,206116,CheckSiblingGroup,1,node.worker.SiblingGroup.CheckSiblingGroup,void node.worker.SiblingGroup.CheckSiblingGroup (ANY),node_messaging.cc,"void SiblingGroup::CheckSiblingGroup(const std::string& name) {
  Mutex::ScopedLock lock(SiblingGroup::groups_mutex_);
  auto i = groups_.find(name);
  if (i != groups_.end() && i->second.expired())
    groups_.erase(name);
}",1367.0,1372.0,1.0,1.0,6.0,9,5,9,4,0,0,2,2,0,0,,0,0,2,1,1,void
4013,206154,SiblingGroup,1,node.worker.SiblingGroup.SiblingGroup,ANY node.worker.SiblingGroup.SiblingGroup (ANY),node_messaging.cc,"SiblingGroup::SiblingGroup(const std::string& name)
    : name_(name) { }",1374.0,1375.0,1.0,21.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
4014,206159,~SiblingGroup,1,node.worker.SiblingGroup.~SiblingGroup,ANY node.worker.SiblingGroup.~SiblingGroup (),node_messaging.cc,"SiblingGroup::~SiblingGroup() {
  // If this is a named group, check to see if we can remove the group
  if (!name_.empty())
    CheckSiblingGroup(name_);
}",1377.0,1381.0,1.0,1.0,5.0,2,2,1,1,0,0,2,2,0,0,,0,0,0,0,0,ANY
4015,206171,Dispatch,1,node.worker.SiblingGroup.Dispatch,"Maybe<bool> node.worker.SiblingGroup.Dispatch (MessagePortData*,ANY,ANY*)",node_messaging.cc,"Maybe<bool> SiblingGroup::Dispatch(
    MessagePortData* source,
    std::shared_ptr<Message> message,
    std::string* error) {

  RwLock::ScopedReadLock lock(group_mutex_);

  // The source MessagePortData is not part of this group.
  if (ports_.find(source) == ports_.end()) {
    if (error != nullptr)
      *error = ""Source MessagePort is not entangled with this group."";
    return Nothing<bool>();
  }

  // There are no destination ports.
  if (size() <= 1)
    return Just(false);

  // Transferables cannot be used when there is more
  // than a single destination.
  if (size() > 2 && message->has_transferables()) {
    if (error != nullptr)
      *error = ""Transferables cannot be used with multiple destinations."";
    return Nothing<bool>();
  }

  for (MessagePortData* port : ports_) {
    if (port == source)
      continue;
    // This loop should only be entered if there's only a single destination
    for (const auto& transferable : message->transferables()) {
      if (por...",1383.0,1426.0,1.0,1.0,44.0,21,9,19,7,0,0,12,20,0,0,,0,0,6,3,3,Maybe<bool>
4016,206278,Entangle,1,node.worker.SiblingGroup.Entangle,void node.worker.SiblingGroup.Entangle (MessagePortData*),node_messaging.cc,"void SiblingGroup::Entangle(std::initializer_list<MessagePortData*> ports) {
  RwLock::ScopedWriteLock lock(group_mutex_);
  for (MessagePortData* data : ports) {
    ports_.insert(data);
    CHECK(!data->group_);
    data->group_ = shared_from_this();
  }
}",1432.0,1439.0,1.0,1.0,8.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,void
4017,206313,Disentangle,1,node.worker.SiblingGroup.Disentangle,void node.worker.SiblingGroup.Disentangle (MessagePortData*),node_messaging.cc,"void SiblingGroup::Disentangle(MessagePortData* data) {
  auto self = shared_from_this();  // Keep alive until end of function.
  RwLock::ScopedWriteLock lock(group_mutex_);
  ports_.erase(data);
  data->group_.reset();

  data->AddToIncomingQueue(std::make_shared<Message>());
  // If this is an anonymous group and there's another port, close it.
  if (size() == 1 && name_.empty())
    (*(ports_.begin()))->AddToIncomingQueue(std::make_shared<Message>());
}",1441.0,1451.0,1.0,1.0,11.0,13,6,10,6,0,0,2,2,0,0,,0,0,2,1,1,void
4018,206369,SetDeserializerCreateObjectFunction,1,node.worker.anonymous_namespace_27.SetDeserializerCreateObjectFunction,void node.worker.anonymous_namespace_27.SetDeserializerCreateObjectFunction (FunctionCallbackInfo<Value>),node_messaging.cc,"static void SetDeserializerCreateObjectFunction(
    const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  CHECK(args[0]->IsFunction());
  env->set_messaging_deserialize_create_object(args[0].As<Function>());
}",1458.0,1463.0,1.0,1.0,6.0,7,4,6,3,0,0,1,1,0,0,,0,0,2,1,1,void
4019,206399,MessageChannel,1,node.worker.anonymous_namespace_28.MessageChannel,void node.worker.anonymous_namespace_28.MessageChannel (FunctionCallbackInfo<Value>),node_messaging.cc,"static void MessageChannel(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  if (!args.IsConstructCall()) {
    THROW_ERR_CONSTRUCT_CALL_REQUIRED(env);
    return;
  }

  Local<Context> context = args.This()->GetCreationContext().ToLocalChecked();
  Context::Scope context_scope(context);

  MessagePort* port1 = MessagePort::New(env, context);
  if (port1 == nullptr) return;
  MessagePort* port2 = MessagePort::New(env, context);
  if (port2 == nullptr) {
    port1->Close();
    return;
  }

  MessagePort::Entangle(port1, port2);

  args.This()->Set(context, env->port1_string(), port1->object())
      .Check();
  args.This()->Set(context, env->port2_string(), port2->object())
      .Check();
}",1465.0,1489.0,1.0,1.0,25.0,28,7,32,9,0,0,4,4,0,0,,0,0,2,1,1,void
4020,206519,BroadcastChannel,1,node.worker.anonymous_namespace_29.BroadcastChannel,void node.worker.anonymous_namespace_29.BroadcastChannel (FunctionCallbackInfo<Value>),node_messaging.cc,"static void BroadcastChannel(const FunctionCallbackInfo<Value>& args) {
  CHECK(args[0]->IsString());
  Environment* env = Environment::GetCurrent(args);
  Context::Scope context_scope(env->context());
  Utf8Value name(env->isolate(), args[0]);
  MessagePort* port =
      MessagePort::New(env, env->context(), {}, SiblingGroup::Get(*name));
  if (port != nullptr) {
    args.GetReturnValue().Set(port->object());
  }
}",1491.0,1501.0,1.0,1.0,11.0,17,7,16,7,0,0,2,2,0,0,,0,0,2,1,1,void
4021,206589,InitMessaging,1,node.worker.anonymous_namespace_30.InitMessaging,"void node.worker.anonymous_namespace_30.InitMessaging (Local<Object>,Local<Value>,Local<Context>,void*)",node_messaging.cc,"static void InitMessaging(Local<Object> target,
                          Local<Value> unused,
                          Local<Context> context,
                          void* priv) {
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  {
    SetConstructorFunction(context,
                           target,
                           ""MessageChannel"",
                           NewFunctionTemplate(isolate, MessageChannel));
  }

  {
    Local<FunctionTemplate> t =
        NewFunctionTemplate(isolate, JSTransferable::New);
    t->InstanceTemplate()->SetInternalFieldCount(
        JSTransferable::kInternalFieldCount);
    t->SetClassName(OneByteString(isolate, ""JSTransferable""));
    SetConstructorFunction(
        context, target, ""JSTransferable"", t, SetConstructorFunctionFlag::NONE);
  }

  SetConstructorFunction(context,
                         target,
                         env->message_port_constructor_string(),
                    ...",1503.0,1556.0,1.0,1.0,54.0,27,5,53,13,0,0,1,1,0,0,,0,0,8,4,4,void
4022,206741,RegisterExternalReferences,1,node.worker.anonymous_namespace_35.RegisterExternalReferences,void node.worker.anonymous_namespace_35.RegisterExternalReferences (ExternalReferenceRegistry*),node_messaging.cc,"static void RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  registry->Register(MessageChannel);
  registry->Register(BroadcastChannel);
  registry->Register(JSTransferable::New);
  registry->Register(MessagePort::New);
  registry->Register(MessagePort::PostMessage);
  registry->Register(MessagePort::Start);
  registry->Register(MessagePort::Stop);
  registry->Register(MessagePort::CheckType);
  registry->Register(MessagePort::Drain);
  registry->Register(MessagePort::ReceiveMessage);
  registry->Register(MessagePort::MoveToContext);
  registry->Register(SetDeserializerCreateObjectFunction);
}",1558.0,1571.0,1.0,1.0,14.0,21,2,21,3,0,0,1,1,0,0,,0,0,2,1,1,void
4023,206902,Versions,1,node.Metadata.Versions.Versions,ANY node.Metadata.Versions.Versions (),node_metadata.cc,"Metadata::Versions::Versions() {
  node = NODE_VERSION_STRING;
  v8 = v8::V8::GetVersion();
  uv = uv_version_string();
  zlib = ZLIB_VERSION;
  ares = ARES_VERSION_STR;
  modules = NODE_STRINGIFY(NODE_MODULE_VERSION);
  nghttp2 = NGHTTP2_VERSION;
  napi = NODE_STRINGIFY(NAPI_VERSION);
  llhttp =
      NODE_STRINGIFY(LLHTTP_VERSION_MAJOR)
      "".""
      NODE_STRINGIFY(LLHTTP_VERSION_MINOR)
      "".""
      NODE_STRINGIFY(LLHTTP_VERSION_PATCH);

  brotli =
    std::to_string(BrotliEncoderVersion() >> 24) +
    ""."" +
    std::to_string((BrotliEncoderVersion() & 0xFFF000) >> 12) +
    ""."" +
    std::to_string(BrotliEncoderVersion() & 0xFFF);
#ifndef NODE_SHARED_BUILTIN_UNDICI_UNDICI_PATH
  undici = UNDICI_VERSION;
#endif

  acorn = ACORN_VERSION;
  cjs_module_lexer = CJS_MODULE_LEXER_VERSION;
  base64 = BASE64_VERSION;
  uvwasi = UVWASI_VERSION_STRING;

#if HAVE_OPENSSL
  openssl = GetOpenSSLVersion();
#endif

#ifdef NODE_HAVE_I18N_SUPPORT
  icu = U_ICU_VERSION;
  unicode = U_UNICODE_V...",77.0,124.0,1.0,9.0,48.0,30,5,28,25,0,0,1,1,0,0,,0,0,0,0,0,ANY
4024,207006,Release,1,node.Metadata.Release.Release,ANY node.Metadata.Release.Release (),node_metadata.cc,"Metadata::Release::Release() : name(NODE_RELEASE) {
#if NODE_VERSION_IS_LTS
  lts = NODE_VERSION_LTS_CODENAME;
#endif  // NODE_VERSION_IS_LTS

#ifdef NODE_HAS_RELEASE_URLS
#define NODE_RELEASE_URLPFX NODE_RELEASE_URLBASE ""v"" NODE_VERSION_STRING ""/""
#define NODE_RELEASE_URLFPFX NODE_RELEASE_URLPFX ""node-v"" NODE_VERSION_STRING

  source_url = NODE_RELEASE_URLFPFX "".tar.gz"";
  headers_url = NODE_RELEASE_URLFPFX ""-headers.tar.gz"";
#ifdef _WIN32
  lib_url = strcmp(NODE_ARCH, ""ia32"") ? NODE_RELEASE_URLPFX ""win-"" NODE_ARCH
                                                           ""/node.lib""
                                     : NODE_RELEASE_URLPFX ""win-x86/node.lib"";
#endif  // _WIN32

#endif  // NODE_HAS_RELEASE_URLS
}",126.0,144.0,1.0,36.0,19.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
4025,207010,Metadata,1,node.Metadata.Metadata,ANY node.Metadata.Metadata (),node_metadata.cc,"Metadata::Metadata() : arch(NODE_ARCH), platform(NODE_PLATFORM) {}",146.0,146.0,1.0,66.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
4026,207051,ObjectWrap,1,node.ObjectWrap.ObjectWrap,ANY node.ObjectWrap.ObjectWrap (),node_object_wrap.hpp,"ObjectWrap() {
    refs_ = 0;
  }",33.0,35.0,3.0,3.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,ANY
4027,207058,~ObjectWrap,1,node.ObjectWrap.~ObjectWrap,ANY node.ObjectWrap.~ObjectWrap (),node_object_wrap.hpp,"virtual ~ObjectWrap() {
    if (persistent().IsEmpty())
      return;
    persistent().ClearWeak();
    persistent().Reset();
  }",38.0,43.0,3.0,3.0,6.0,3,1,0,0,0,0,2,2,0,0,,0,0,0,0,0,ANY
4028,207077,Unwrap,1,node.ObjectWrap.Unwrap,T node.ObjectWrap.Unwrap<T> (ANY),node_object_wrap.hpp,"static inline T* Unwrap(v8::Local<v8::Object> handle) {
    assert(!handle.IsEmpty());
    assert(handle->InternalFieldCount() > 0);
    // Cast to ObjectWrap before casting to T.  A direct cast from void
    // to T won't work right when T has more than one base class.
    void* ptr = handle->GetAlignedPointerFromInternalField(0);
    ObjectWrap* wrap = static_cast<ObjectWrap*>(ptr);
    return static_cast<T*>(wrap);
  }",47.0,55.0,3.0,3.0,9.0,9,6,7,3,0,0,1,1,0,0,,0,0,2,1,1,T
4029,207113,handle,1,node.ObjectWrap.handle,Local<v8::Object> node.ObjectWrap.handle (),node_object_wrap.hpp,"inline v8::Local<v8::Object> handle(v8::Isolate* isolate) {
    return v8::Local<v8::Object>::New(isolate, persistent());
  }",63.0,65.0,3.0,3.0,3.0,2,1,2,2,0,0,1,1,0,0,,0,0,2,1,1,Local<v8.Object>
4030,207145,persistent,1,node.ObjectWrap.persistent,Persistent<v8::Object> node.ObjectWrap.persistent (),node_object_wrap.hpp,"inline v8::Persistent<v8::Object>& persistent() {
    return handle_;
  }",69.0,71.0,3.0,3.0,3.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,Persistent<v8.Object>
4031,207151,Wrap,1,node.ObjectWrap.Wrap,void node.ObjectWrap.Wrap (ANY),node_object_wrap.hpp,"inline void Wrap(v8::Local<v8::Object> handle) {
    assert(persistent().IsEmpty());
    assert(handle->InternalFieldCount() > 0);
    handle->SetAlignedPointerInInternalField(0, this);
    persistent().Reset(v8::Isolate::GetCurrent(), handle);
    MakeWeak();
  }",75.0,81.0,3.0,3.0,7.0,7,3,5,3,0,0,1,1,0,0,,0,0,2,1,1,void
4032,207186,MakeWeak,1,node.ObjectWrap.MakeWeak,void node.ObjectWrap.MakeWeak (),node_object_wrap.hpp,"inline void MakeWeak() {
    persistent().SetWeak(this, WeakCallback, v8::WeakCallbackType::kParameter);
  }",84.0,86.0,3.0,3.0,3.0,3,1,2,2,0,0,1,1,0,0,,0,0,0,0,0,void
4033,207201,Ref,1,node.ObjectWrap.Ref,void node.ObjectWrap.Ref (),node_object_wrap.hpp,"virtual void Ref() {
    assert(!persistent().IsEmpty());
    persistent().ClearWeak();
    refs_++;
  }",92.0,96.0,3.0,3.0,5.0,4,3,1,1,0,1,1,1,0,0,,0,1,0,0,0,void
4034,207217,Unref,1,node.ObjectWrap.Unref,void node.ObjectWrap.Unref (),node_object_wrap.hpp,"virtual void Unref() {
    assert(!persistent().IsEmpty());
    assert(!persistent().IsWeak());
    assert(refs_ > 0);
    if (--refs_ == 0)
      MakeWeak();
  }",107.0,113.0,3.0,3.0,7.0,7,5,2,1,0,2,2,2,1,0,,0,2,0,0,0,void
4035,207245,WeakCallback,1,node.ObjectWrap.WeakCallback,void node.ObjectWrap.WeakCallback (ANY),node_object_wrap.hpp,"static void WeakCallback(
      const v8::WeakCallbackInfo<ObjectWrap>& data) {
    ObjectWrap* wrap = data.GetParameter();
    assert(wrap->refs_ == 0);
    wrap->handle_.Reset();
    delete wrap;
  }",118.0,124.0,3.0,3.0,7.0,7,5,5,2,0,2,1,1,0,0,,0,2,2,1,1,void
4036,207284,<lambda>0,1,node.options_parser.GetCLIOptions.<lambda>0,ANY node.options_parser.GetCLIOptions.<lambda>0 (),node_options.cc,"[&]() {
    per_process::cli_options->per_isolate->per_env = original_per_env;
    per_process::cli_options->per_isolate = original_per_isolate;
  }",1098.0,1101.0,38.0,3.0,4.0,7,3,4,3,0,0,1,1,0,0,,0,0,0,0,0,ANY
4037,207308,<lambda>1,1,node.HandleEnvOptions.<lambda>1,ANY node.HandleEnvOptions.<lambda>1 (char*),node_options.cc,"[](const char* name) {
    std::string text;
    return credentials::SafeGetenv(name, &text) ? text : """";
  }",1281.0,1284.0,33.0,3.0,4.0,3,3,4,3,0,0,1,1,0,0,,0,0,2,1,1,ANY
4038,207364,CheckOptions,1,node.DebugOptions.CheckOptions,"void node.DebugOptions.CheckOptions (ANY*,ANY*)",node_options.cc,"void DebugOptions::CheckOptions(std::vector<std::string>* errors,
                                std::vector<std::string>* argv) {
#if !NODE_USE_V8_PLATFORM && !HAVE_INSPECTOR
  if (inspector_enabled) {
    errors->push_back(""Inspector is not available when Node is compiled ""
                      ""--without-v8-platform and --without-inspector."");
  }
#endif

  if (deprecated_debug) {
    errors->push_back(""[DEP0062]: `node --debug` and `node --debug-brk` ""
                      ""are invalid. Please use `node --inspect` and ""
                      ""`node --inspect-brk` instead."");
  }

  std::vector<std::string> destinations =
      SplitString(inspect_publish_uid_string, ',');
  inspect_publish_uid.console = false;
  inspect_publish_uid.http = false;
  for (const std::string& destination : destinations) {
    if (destination == ""stderr"") {
      inspect_publish_uid.console = true;
    } else if (destination == ""http"") {
      inspect_publish_uid.http = true;
    } else {
      err...",38.0,67.0,1.0,1.0,30.0,14,6,13,8,0,0,5,6,0,0,,0,0,4,2,2,void
4039,207442,CheckOptions,1,node.PerProcessOptions.CheckOptions,"void node.PerProcessOptions.CheckOptions (ANY*,ANY*)",node_options.cc,"void PerProcessOptions::CheckOptions(std::vector<std::string>* errors,
                                     std::vector<std::string>* argv) {
#if HAVE_OPENSSL
  if (use_openssl_ca && use_bundled_ca) {
    errors->push_back(""either --use-openssl-ca or --use-bundled-ca can be ""
                      ""used, not both"");
  }

  // Any value less than 2 disables use of the secure heap.
  if (secure_heap >= 2) {
    if ((secure_heap & (secure_heap - 1)) != 0)
      errors->push_back(""--secure-heap must be a power of 2"");
    secure_heap_min =
        std::min({
            secure_heap,
            secure_heap_min,
            static_cast<int64_t>(std::numeric_limits<int>::max())});
    secure_heap_min = std::max(static_cast<int64_t>(2), secure_heap_min);
    if ((secure_heap_min & (secure_heap_min - 1)) != 0)
      errors->push_back(""--secure-heap-min must be a power of 2"");
  }
#endif  // HAVE_OPENSSL

  if (use_largepages != ""off"" &&
      use_largepages != ""on"" &&
      use_largepages !...",69.0,98.0,1.0,1.0,30.0,7,3,7,4,0,0,2,2,0,0,,0,0,4,2,2,void
4040,207472,CheckOptions,1,node.PerIsolateOptions.CheckOptions,"void node.PerIsolateOptions.CheckOptions (ANY*,ANY*)",node_options.cc,"void PerIsolateOptions::CheckOptions(std::vector<std::string>* errors,
                                     std::vector<std::string>* argv) {
  per_env->CheckOptions(errors, argv);
}",100.0,103.0,1.0,1.0,4.0,1,1,3,3,0,0,1,1,0,0,,0,0,4,2,2,void
4041,207484,CheckOptions,1,node.EnvironmentOptions.CheckOptions,"void node.EnvironmentOptions.CheckOptions (ANY*,ANY*)",node_options.cc,"void EnvironmentOptions::CheckOptions(std::vector<std::string>* errors,
                                      std::vector<std::string>* argv) {
  if (has_policy_integrity_string && experimental_policy.empty()) {
    errors->push_back(""--policy-integrity requires ""
                      ""--experimental-policy be enabled"");
  }
  if (has_policy_integrity_string && experimental_policy_integrity.empty()) {
    errors->push_back(""--policy-integrity cannot be empty"");
  }

  if (!module_type.empty()) {
    if (module_type != ""commonjs"" && module_type != ""module"") {
      errors->push_back(""--input-type must be \""module\"" or \""commonjs\"""");
    }
  }

  if (syntax_check_only && has_eval_string) {
    errors->push_back(""either --check or --eval can be used, not both"");
  }

  if (!unhandled_rejections.empty() &&
      unhandled_rejections != ""warn-with-error-code"" &&
      unhandled_rejections != ""throw"" &&
      unhandled_rejections != ""strict"" &&
      unhandled_rejections != ""warn"" &&
  ...",105.0,222.0,1.0,1.0,118.0,40,8,35,14,0,0,16,22,0,0,,0,0,4,2,2,void
4042,207703,DebugOptionsParser,1,node.options_parser.DebugOptionsParser.DebugOptionsParser,ANY node.options_parser.DebugOptionsParser.DebugOptionsParser (),node_options.cc,"DebugOptionsParser::DebugOptionsParser() {
#ifndef DISABLE_SINGLE_EXECUTABLE_APPLICATION
  if (sea::IsSingleExecutable()) return;
#endif

  AddOption(""--inspect-port"",
            ""set host:port for inspector"",
            &DebugOptions::host_port,
            kAllowedInEnvvar);
  AddAlias(""--debug-port"", ""--inspect-port"");

  AddOption(""--inspect"",
            ""activate inspector on host:port (default: 127.0.0.1:9229)"",
            &DebugOptions::inspector_enabled,
            kAllowedInEnvvar);
  AddAlias(""--inspect="", { ""--inspect-port"", ""--inspect"" });

  AddOption(""--debug"", """", &DebugOptions::deprecated_debug);
  AddAlias(""--debug="", ""--debug"");
  AddOption(""--debug-brk"", """", &DebugOptions::deprecated_debug);
  AddAlias(""--debug-brk="", ""--debug-brk"");

  AddOption(""--inspect-brk"",
            ""activate inspector on host:port and break at start of user script"",
            &DebugOptions::break_first_line,
            kAllowedInEnvvar);
  Implies(""--inspect-brk"", ""--inspect"");
 ...",296.0,334.0,1.0,1.0,39.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
4043,207708,EnvironmentOptionsParser,1,node.options_parser.EnvironmentOptionsParser.EnvironmentOptionsParser,ANY node.options_parser.EnvironmentOptionsParser.EnvironmentOptionsParser (),node_options.cc,"EnvironmentOptionsParser::EnvironmentOptionsParser() {
  AddOption(""--conditions"",
            ""additional user conditions for conditional exports and imports"",
            &EnvironmentOptions::conditions,
            kAllowedInEnvvar);
  AddAlias(""-C"", ""--conditions"");
  AddOption(""--diagnostic-dir"",
            ""set dir for all output files""
            "" (default: current working directory)"",
            &EnvironmentOptions::diagnostic_dir,
            kAllowedInEnvvar);
  AddOption(""--dns-result-order"",
            ""set default value of verbatim in dns.lookup. Options are ""
            ""'ipv4first' (IPv4 addresses are placed before IPv6 addresses) ""
            ""'verbatim' (addresses are in the order the DNS resolver ""
            ""returned)"",
            &EnvironmentOptions::dns_result_order,
            kAllowedInEnvvar);
  AddOption(""--network-family-autoselection"",
            ""Disable network address family autodetection algorithm"",
            &EnvironmentOptions::network_...",336.0,733.0,1.0,1.0,398.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
4044,207724,PerIsolateOptionsParser,1,node.options_parser.PerIsolateOptionsParser.PerIsolateOptionsParser,ANY node.options_parser.PerIsolateOptionsParser.PerIsolateOptionsParser (),node_options.cc,"PerIsolateOptionsParser::PerIsolateOptionsParser(
  const EnvironmentOptionsParser& eop) {
  AddOption(""--track-heap-objects"",
            ""track heap object allocations for heap snapshots"",
            &PerIsolateOptions::track_heap_objects,
            kAllowedInEnvvar);

  // Explicitly add some V8 flags to mark them as allowed in NODE_OPTIONS.
  AddOption(""--abort-on-uncaught-exception"",
            ""aborting instead of exiting causes a core file to be generated ""
            ""for analysis"",
            V8Option{},
            kAllowedInEnvvar);
  AddOption(""--interpreted-frames-native-stack"",
            ""help system profilers to translate JavaScript interpreted frames"",
            V8Option{},
            kAllowedInEnvvar);
  AddOption(""--max-old-space-size"", """", V8Option{}, kAllowedInEnvvar);
  AddOption(""--max-semi-space-size"", """", V8Option{}, kAllowedInEnvvar);
  AddOption(""--perf-basic-prof"", """", V8Option{}, kAllowedInEnvvar);
  AddOption(
      ""--perf-basic-prof-only-fun...",735.0,808.0,1.0,1.0,74.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
4045,207734,PerProcessOptionsParser,1,node.options_parser.PerProcessOptionsParser.PerProcessOptionsParser,ANY node.options_parser.PerProcessOptionsParser.PerProcessOptionsParser (),node_options.cc,"PerProcessOptionsParser::PerProcessOptionsParser(
  const PerIsolateOptionsParser& iop) {
  AddOption(""--title"",
            ""the process title to use on startup"",
            &PerProcessOptions::title,
            kAllowedInEnvvar);
  AddOption(""--trace-event-categories"",
            ""comma separated list of trace event categories to record"",
            &PerProcessOptions::trace_event_categories,
            kAllowedInEnvvar);
  AddOption(""--trace-event-file-pattern"",
            ""Template string specifying the filepath for the trace-events ""
            ""data, it supports ${rotation} and ${pid}."",
            &PerProcessOptions::trace_event_file_pattern,
            kAllowedInEnvvar);
  AddAlias(""--trace-events-enabled"", {
    ""--trace-event-categories"", ""v8,node,node.async_hooks"" });
  AddOption(""--v8-pool-size"",
            ""set V8's thread pool size"",
            &PerProcessOptions::v8_thread_pool_size,
            kAllowedInEnvvar);
  AddOption(""--zero-fill-buffers"",
        ...",810.0,992.0,1.0,1.0,183.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
4046,207757,Parse,1,node.options_parser.Parse,"void node.options_parser.Parse<> (StringVector*,StringVector*,StringVector*,PerIsolateOptions*,OptionEnvvarSettings,StringVector*)",node_options.cc,"void Parse(
  StringVector* const args, StringVector* const exec_args,
  StringVector* const v8_args,
  PerProcessOptions* const options,
  OptionEnvvarSettings required_env_settings, StringVector* const errors) {
  _ppop_instance.Parse(
    args, exec_args, v8_args, options, required_env_settings, errors);
}",283.0,290.0,1.0,1.0,8.0,1,1,7,7,0,0,1,1,0,0,,0,0,12,6,6,void
4047,208974,RemoveBrackets,1,node.options_parser.RemoveBrackets,string node.options_parser.RemoveBrackets (ANY),node_options.cc,"inline std::string RemoveBrackets(const std::string& host) {
  if (!host.empty() && host.front() == '[' && host.back() == ']')
    return host.substr(1, host.size() - 2);
  else
    return host;
}",994.0,999.0,1.0,1.0,6.0,11,5,5,1,0,0,2,2,0,0,,0,0,2,1,1,string
4048,209016,ParseAndValidatePort,1,node.options_parser.ParseAndValidatePort,"int node.options_parser.ParseAndValidatePort (ANY,ANY*)",node_options.cc,"inline int ParseAndValidatePort(const std::string& port,
                                std::vector<std::string>* errors) {
  char* endptr;
  errno = 0;
  const unsigned long result =                 // NOLINT(runtime/int)
    strtoul(port.c_str(), &endptr, 10);
  if (errno != 0 || *endptr != '\0'||
      (result != 0 && result < 1024) || result > 65535) {
    errors->push_back("" must be 0 or in range 1024 to 65535."");
  }
  return static_cast<int>(result);
}",1001.0,1012.0,1.0,1.0,12.0,16,11,11,5,0,0,2,2,0,0,,0,0,4,2,2,int
4049,209068,SplitHostPort,1,node.options_parser.SplitHostPort,"HostPort node.options_parser.SplitHostPort (ANY,ANY*)",node_options.cc,"HostPort SplitHostPort(const std::string& arg,
                      std::vector<std::string>* errors) {
  // remove_brackets only works if no port is specified
  // so if it has an effect only an IPv6 address was specified.
  std::string host = RemoveBrackets(arg);
  if (host.length() < arg.length())
    return HostPort{host, DebugOptions::kDefaultInspectorPort};

  size_t colon = arg.rfind(':');
  if (colon == std::string::npos) {
    // Either a port number or a host name.  Assume that
    // if it's not all decimal digits, it's a host name.
    for (char c : arg) {
      if (c < '0' || c > '9') {
        return HostPort{arg, DebugOptions::kDefaultInspectorPort};
      }
    }
    return HostPort { """", ParseAndValidatePort(arg, errors) };
  }
  // Host and port found:
  return HostPort { RemoveBrackets(arg.substr(0, colon)),
                    ParseAndValidatePort(arg.substr(colon + 1), errors) };
}",1014.0,1036.0,1.0,1.0,23.0,21,8,23,8,0,0,5,8,0,0,,0,0,4,2,2,HostPort
4050,209160,GetBashCompletion,1,node.options_parser.GetBashCompletion,string node.options_parser.GetBashCompletion (),node_options.cc,"std::string GetBashCompletion() {
  Mutex::ScopedLock lock(per_process::cli_options_mutex);
  const auto& parser = _ppop_instance;

  std::ostringstream out;

  out << ""_node_complete() {\n""
         ""  local cur_word options\n""
         ""  cur_word=\""${COMP_WORDS[COMP_CWORD]}\""\n""
         ""  if [[ \""${cur_word}\"" == -* ]] ; then\n""
         ""    COMPREPLY=( $(compgen -W '"";

  for (const auto& item : parser.options_) {
    if (item.first[0] != '[') {
      out << item.first << "" "";
    }
  }
  for (const auto& item : parser.aliases_) {
    if (item.first[0] != '[') {
      out << item.first << "" "";
    }
  }
  if (parser.aliases_.size() > 0) {
    out.seekp(-1, out.cur);  // Strip the trailing space
  }

  out << ""' -- \""${cur_word}\"") )\n""
         ""    return 0\n""
         ""  else\n""
         ""    COMPREPLY=( $(compgen -f \""${cur_word}\"") )\n""
         ""    return 0\n""
         ""  fi\n""
         ""}\n""
         ""complete -o filenames -o nospace -o bashdefault ""
         ""-F _node...",1038.0,1074.0,1.0,1.0,37.0,25,7,17,5,0,0,6,8,0,0,,0,0,0,0,0,string
4051,209248,GetCLIOptions,1,node.options_parser.GetCLIOptions,void node.options_parser.GetCLIOptions (FunctionCallbackInfo<Value>),node_options.cc,"void GetCLIOptions(const FunctionCallbackInfo<Value>& args) {
  Mutex::ScopedLock lock(per_process::cli_options_mutex);
  Environment* env = Environment::GetCurrent(args);
  if (!env->has_run_bootstrapping_code()) {
    // No code because this is an assertion.
    return env->ThrowError(
        ""Should not query options before bootstrapping is done"");
  }
  env->set_has_serialized_options(true);

  Isolate* isolate = env->isolate();
  Local<Context> context = env->context();

  // Temporarily act as if the current Environment's/IsolateData's options were
  // the default options, i.e. like they are the ones we'd access for global
  // options parsing, so that all options are available from the main parser.
  auto original_per_isolate = per_process::cli_options->per_isolate;
  per_process::cli_options->per_isolate = env->isolate_data()->options();
  auto original_per_env = per_process::cli_options->per_isolate->per_env;
  per_process::cli_options->per_isolate->per_env = env->options...",1078.0,1217.0,1.0,1.0,140.0,198,13,185,45,0,0,20,23,0,0,,0,0,2,1,1,void
4052,209893,GetEmbedderOptions,1,node.options_parser.GetEmbedderOptions,void node.options_parser.GetEmbedderOptions (FunctionCallbackInfo<Value>),node_options.cc,"void GetEmbedderOptions(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  if (!env->has_run_bootstrapping_code()) {
    // No code because this is an assertion.
    return env->ThrowError(
        ""Should not query options before bootstrapping is done"");
  }
  Isolate* isolate = args.GetIsolate();
  Local<Context> context = env->context();
  Local<Object> ret = Object::New(isolate);

  if (ret->Set(context,
           FIXED_ONE_BYTE_STRING(env->isolate(), ""shouldNotRegisterESMLoader""),
           Boolean::New(isolate, env->should_not_register_esm_loader()))
      .IsNothing()) return;

  if (ret->Set(context,
           FIXED_ONE_BYTE_STRING(env->isolate(), ""noGlobalSearchPaths""),
           Boolean::New(isolate, env->no_global_search_paths()))
      .IsNothing()) return;

  args.GetReturnValue().Set(ret);
}",1219.0,1241.0,1.0,1.0,23.0,27,6,30,10,0,0,4,4,0,0,,0,0,2,1,1,void
4053,210007,Initialize,1,node.options_parser.Initialize,"void node.options_parser.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)",node_options.cc,"void Initialize(Local<Object> target,
                Local<Value> unused,
                Local<Context> context,
                void* priv) {
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();
  SetMethodNoSideEffect(context, target, ""getCLIOptions"", GetCLIOptions);
  SetMethodNoSideEffect(
      context, target, ""getEmbedderOptions"", GetEmbedderOptions);

  Local<Object> env_settings = Object::New(isolate);
  NODE_DEFINE_CONSTANT(env_settings, kAllowedInEnvvar);
  NODE_DEFINE_CONSTANT(env_settings, kDisallowedInEnvvar);
  target
      ->Set(
          context, FIXED_ONE_BYTE_STRING(isolate, ""envSettings""), env_settings)
      .Check();

  Local<Object> types = Object::New(isolate);
  NODE_DEFINE_CONSTANT(types, kNoOp);
  NODE_DEFINE_CONSTANT(types, kV8Option);
  NODE_DEFINE_CONSTANT(types, kBoolean);
  NODE_DEFINE_CONSTANT(types, kInteger);
  NODE_DEFINE_CONSTANT(types, kUInteger);
  NODE_DEFINE_CONSTANT(types, kString);
  NODE_DEFINE_CON...",1243.0,1272.0,1.0,1.0,30.0,16,5,47,19,0,0,1,1,0,0,,0,0,8,4,4,void
4054,210116,RegisterExternalReferences,1,node.options_parser.RegisterExternalReferences,void node.options_parser.RegisterExternalReferences (ExternalReferenceRegistry*),node_options.cc,"void RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  registry->Register(GetCLIOptions);
  registry->Register(GetEmbedderOptions);
}",1274.0,1277.0,1.0,1.0,4.0,2,1,2,1,0,0,1,1,0,0,,0,0,2,1,1,void
4055,210131,HandleEnvOptions,1,node.HandleEnvOptions,void node.HandleEnvOptions (ANY),node_options.cc,"void HandleEnvOptions(std::shared_ptr<EnvironmentOptions> env_options,
                      std::function<std::string(const char*)> opt_getter) {
  env_options->pending_deprecation =
      opt_getter(""NODE_PENDING_DEPRECATION"") == ""1"";

  env_options->preserve_symlinks = opt_getter(""NODE_PRESERVE_SYMLINKS"") == ""1"";

  env_options->preserve_symlinks_main =
      opt_getter(""NODE_PRESERVE_SYMLINKS_MAIN"") == ""1"";

  if (env_options->redirect_warnings.empty())
    env_options->redirect_warnings = opt_getter(""NODE_REDIRECT_WARNINGS"");
}",1287.0,1299.0,1.0,1.0,13.0,0,0,1,1,0,0,1,1,0,0,,0,0,4,2,2,void
4056,210183,ParseNodeOptionsEnvVar,1,node.ParseNodeOptionsEnvVar,"vector<std::string> node.ParseNodeOptionsEnvVar (ANY,ANY*)",node_options.cc,"std::vector<std::string> ParseNodeOptionsEnvVar(
    const std::string& node_options, std::vector<std::string>* errors) {
  std::vector<std::string> env_argv;

  bool is_in_string = false;
  bool will_start_new_arg = true;
  for (std::string::size_type index = 0; index < node_options.size(); ++index) {
    char c = node_options.at(index);

    // Backslashes escape the following character
    if (c == '\\' && is_in_string) {
      if (index + 1 == node_options.size()) {
        errors->push_back(""invalid value for NODE_OPTIONS ""
                          ""(invalid escape)\n"");
        return env_argv;
      } else {
        c = node_options.at(++index);
      }
    } else if (c == ' ' && !is_in_string) {
      will_start_new_arg = true;
      continue;
    } else if (c == '""') {
      is_in_string = !is_in_string;
      continue;
    }

    if (will_start_new_arg) {
      env_argv.emplace_back(std::string(1, c));
      will_start_new_arg = false;
    } else {
      env_argv.back() +...",1301.0,1340.0,1.0,1.0,40.0,21,8,25,8,0,0,6,10,0,0,,0,0,4,2,2,vector<std.string>
4057,210346,<lambda>0,1,node.os.GetUserInfo.<lambda>0,ANY node.os.GetUserInfo.<lambda>0 (),node_os.cc,[&]() { uv_os_free_passwd(&pwd); },299.0,299.0,35.0,68.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,ANY
4058,210377,GetHostname,1,node.os.GetHostname,void node.os.GetHostname (FunctionCallbackInfo<Value>),node_os.cc,"static void GetHostname(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  char buf[UV_MAXHOSTNAMESIZE];
  size_t size = sizeof(buf);
  int r = uv_os_gethostname(buf, &size);

  if (r != 0) {
    CHECK_GE(args.Length(), 1);
    env->CollectUVExceptionInfo(args[args.Length() - 1], r,
                                ""uv_os_gethostname"");
    return args.GetReturnValue().SetUndefined();
  }

  args.GetReturnValue().Set(
      String::NewFromUtf8(env->isolate(), buf).ToLocalChecked());
}",60.0,75.0,1.0,1.0,16.0,19,8,19,7,0,0,2,2,0,0,,0,0,2,1,1,void
4059,210455,GetOSInformation,1,node.os.GetOSInformation,void node.os.GetOSInformation (FunctionCallbackInfo<Value>),node_os.cc,"static void GetOSInformation(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  uv_utsname_t info;
  int err = uv_os_uname(&info);

  if (err != 0) {
    CHECK_GE(args.Length(), 1);
    env->CollectUVExceptionInfo(args[args.Length() - 1], err, ""uv_os_uname"");
    return args.GetReturnValue().SetUndefined();
  }

  // [sysname, version, release, machine]
  Local<Value> osInformation[] = {
      String::NewFromUtf8(env->isolate(), info.sysname).ToLocalChecked(),
      String::NewFromUtf8(env->isolate(), info.version).ToLocalChecked(),
      String::NewFromUtf8(env->isolate(), info.release).ToLocalChecked(),
      String::NewFromUtf8(env->isolate(), info.machine).ToLocalChecked()};

  args.GetReturnValue().Set(Array::New(env->isolate(),
                                       osInformation,
                                       arraysize(osInformation)));
}",77.0,98.0,1.0,1.0,22.0,34,8,30,8,0,0,2,2,0,0,,0,0,2,1,1,void
4060,210586,GetCPUInfo,1,node.os.GetCPUInfo,void node.os.GetCPUInfo (FunctionCallbackInfo<Value>),node_os.cc,"static void GetCPUInfo(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  uv_cpu_info_t* cpu_infos;
  int count;

  int err = uv_cpu_info(&cpu_infos, &count);
  if (err)
    return;

  // It's faster to create an array packed with all the data and
  // assemble them into objects in JS than to call Object::Set() repeatedly
  // The array is in the format
  // [model, speed, (5 entries of cpu_times), model2, speed2, ...]
  std::vector<Local<Value>> result;
  result.reserve(count * 7);
  for (int i = 0; i < count; i++) {
    uv_cpu_info_t* ci = cpu_infos + i;
    result.emplace_back(OneByteString(isolate, ci->model));
    result.emplace_back(Number::New(isolate, ci->speed));
    result.emplace_back(
        Number::New(isolate, static_cast<double>(ci->cpu_times.user)));
    result.emplace_back(
        Number::New(isolate, static_cast<double>(ci->cpu_times.nice)));
    result.emplace_back(
        Numbe...",100.0,135.0,1.0,1.0,36.0,52,9,55,15,0,0,3,3,0,0,,0,0,2,1,1,void
4061,210778,GetFreeMemory,1,node.os.GetFreeMemory,void node.os.GetFreeMemory (FunctionCallbackInfo<Value>),node_os.cc,"static void GetFreeMemory(const FunctionCallbackInfo<Value>& args) {
  double amount = static_cast<double>(uv_get_free_memory());
  args.GetReturnValue().Set(amount);
}",138.0,141.0,1.0,1.0,4.0,4,3,3,2,0,0,1,1,0,0,,0,0,2,1,1,void
4062,210797,GetTotalMemory,1,node.os.GetTotalMemory,void node.os.GetTotalMemory (FunctionCallbackInfo<Value>),node_os.cc,"static void GetTotalMemory(const FunctionCallbackInfo<Value>& args) {
  double amount = static_cast<double>(uv_get_total_memory());
  args.GetReturnValue().Set(amount);
}",144.0,147.0,1.0,1.0,4.0,4,3,3,2,0,0,1,1,0,0,,0,0,2,1,1,void
4063,210816,GetUptime,1,node.os.GetUptime,void node.os.GetUptime (FunctionCallbackInfo<Value>),node_os.cc,"static void GetUptime(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  double uptime;
  int err = uv_uptime(&uptime);
  if (err != 0) {
    env->CollectUVExceptionInfo(args[args.Length() - 1], err, ""uv_uptime"");
    return args.GetReturnValue().SetUndefined();
  }

  args.GetReturnValue().Set(uptime);
}",150.0,160.0,1.0,1.0,11.0,13,7,13,5,0,0,2,2,0,0,,0,0,2,1,1,void
4064,210871,GetLoadAvg,1,node.os.GetLoadAvg,void node.os.GetLoadAvg (FunctionCallbackInfo<Value>),node_os.cc,"static void GetLoadAvg(const FunctionCallbackInfo<Value>& args) {
  CHECK(args[0]->IsFloat64Array());
  Local<Float64Array> array = args[0].As<Float64Array>();
  CHECK_EQ(array->Length(), 3);
  Local<ArrayBuffer> ab = array->Buffer();
  double* loadavg = static_cast<double*>(ab->Data());
  uv_loadavg(loadavg);
}",163.0,170.0,1.0,1.0,8.0,15,7,13,7,0,0,1,1,0,0,,0,0,2,1,1,void
4065,210922,GetInterfaceAddresses,1,node.os.GetInterfaceAddresses,void node.os.GetInterfaceAddresses (FunctionCallbackInfo<Value>),node_os.cc,"static void GetInterfaceAddresses(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();
  uv_interface_address_t* interfaces;
  int count, i;
  char ip[INET6_ADDRSTRLEN];
  char netmask[INET6_ADDRSTRLEN];
  std::array<char, 18> mac;
  Local<String> name, family;

  int err = uv_interface_addresses(&interfaces, &count);

  if (err == UV_ENOSYS)
    return args.GetReturnValue().SetUndefined();

  if (err) {
    CHECK_GE(args.Length(), 1);
    env->CollectUVExceptionInfo(args[args.Length() - 1], errno,
                                ""uv_interface_addresses"");
    return args.GetReturnValue().SetUndefined();
  }

  Local<Value> no_scope_id = Integer::New(isolate, -1);
  std::vector<Local<Value>> result;
  result.reserve(count * 7);
  for (i = 0; i < count; i++) {
    const char* const raw_name = interfaces[i].name;

    // Use UTF-8 on both Windows and Unixes (While it may be true that UNIX
    // systems are...",173.0,248.0,1.0,1.0,76.0,106,14,101,28,0,0,6,8,0,0,,0,0,2,1,1,void
4066,211338,GetHomeDirectory,1,node.os.GetHomeDirectory,void node.os.GetHomeDirectory (FunctionCallbackInfo<Value>),node_os.cc,"static void GetHomeDirectory(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  char buf[PATH_MAX];

  size_t len = sizeof(buf);
  const int err = uv_os_homedir(buf, &len);

  if (err) {
    CHECK_GE(args.Length(), 1);
    env->CollectUVExceptionInfo(args[args.Length() - 1], err, ""uv_os_homedir"");
    return args.GetReturnValue().SetUndefined();
  }

  Local<String> home = String::NewFromUtf8(env->isolate(),
                                           buf,
                                           NewStringType::kNormal,
                                           len).ToLocalChecked();
  args.GetReturnValue().Set(home);
}",251.0,269.0,1.0,1.0,19.0,22,9,25,10,0,0,2,2,0,0,,0,0,2,1,1,void
4067,211425,GetUserInfo,1,node.os.GetUserInfo,void node.os.GetUserInfo (FunctionCallbackInfo<Value>),node_os.cc,"static void GetUserInfo(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  uv_passwd_t pwd;
  enum encoding encoding;

  if (args[0]->IsObject()) {
    Local<Object> options = args[0].As<Object>();
    MaybeLocal<Value> maybe_encoding = options->Get(env->context(),
                                                    env->encoding_string());
    Local<Value> encoding_opt;
    if (!maybe_encoding.ToLocal(&encoding_opt))
        return;

    encoding = ParseEncoding(env->isolate(), encoding_opt, UTF8);
  } else {
    encoding = UTF8;
  }

  const int err = uv_os_get_passwd(&pwd);

  if (err) {
    CHECK_GE(args.Length(), 2);
    env->CollectUVExceptionInfo(args[args.Length() - 1], err,
                                ""uv_os_get_passwd"");
    return args.GetReturnValue().SetUndefined();
  }

  auto free_passwd = OnScopeLeave([&]() { uv_os_free_passwd(&pwd); });

  Local<Value> error;

  Local<Value> uid = Number::New(env->isolate(), pwd.uid)...",272.0,341.0,1.0,1.0,70.0,105,11,103,24,0,0,6,7,0,0,,0,0,2,1,1,void
4068,211806,SetPriority,1,node.os.SetPriority,void node.os.SetPriority (FunctionCallbackInfo<Value>),node_os.cc,"static void SetPriority(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  CHECK_EQ(args.Length(), 3);
  CHECK(args[0]->IsInt32());
  CHECK(args[1]->IsInt32());

  const int pid = args[0].As<Int32>()->Value();
  const int priority = args[1].As<Int32>()->Value();
  const int err = uv_os_setpriority(pid, priority);

  if (err) {
    CHECK(args[2]->IsObject());
    env->CollectUVExceptionInfo(args[2], err, ""uv_os_setpriority"");
  }

  args.GetReturnValue().Set(err);
}",344.0,361.0,1.0,1.0,18.0,22,4,20,6,0,0,2,2,0,0,,0,0,2,1,1,void
4069,211896,GetPriority,1,node.os.GetPriority,void node.os.GetPriority (FunctionCallbackInfo<Value>),node_os.cc,"static void GetPriority(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  CHECK_EQ(args.Length(), 2);
  CHECK(args[0]->IsInt32());

  const int pid = args[0].As<Int32>()->Value();
  int priority;
  const int err = uv_os_getpriority(pid, &priority);

  if (err) {
    CHECK(args[1]->IsObject());
    env->CollectUVExceptionInfo(args[1], err, ""uv_os_getpriority"");
    return;
  }

  args.GetReturnValue().Set(priority);
}",364.0,381.0,1.0,1.0,18.0,17,5,17,6,0,0,2,2,0,0,,0,0,2,1,1,void
4070,211970,GetAvailableParallelism,1,node.os.GetAvailableParallelism,void node.os.GetAvailableParallelism (FunctionCallbackInfo<Value>),node_os.cc,"static void GetAvailableParallelism(const FunctionCallbackInfo<Value>& args) {
  unsigned int parallelism = uv_available_parallelism();
  args.GetReturnValue().Set(parallelism);
}",383.0,386.0,1.0,1.0,4.0,3,2,3,2,0,0,1,1,0,0,,0,0,2,1,1,void
4071,211987,Initialize,1,node.os.Initialize,"void node.os.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)",node_os.cc,"void Initialize(Local<Object> target,
                Local<Value> unused,
                Local<Context> context,
                void* priv) {
  Environment* env = Environment::GetCurrent(context);
  SetMethod(context, target, ""getHostname"", GetHostname);
  SetMethod(context, target, ""getLoadAvg"", GetLoadAvg);
  SetMethod(context, target, ""getUptime"", GetUptime);
  SetMethod(context, target, ""getTotalMem"", GetTotalMemory);
  SetMethod(context, target, ""getFreeMem"", GetFreeMemory);
  SetMethod(context, target, ""getCPUs"", GetCPUInfo);
  SetMethod(context, target, ""getInterfaceAddresses"", GetInterfaceAddresses);
  SetMethod(context, target, ""getHomeDirectory"", GetHomeDirectory);
  SetMethod(context, target, ""getUserInfo"", GetUserInfo);
  SetMethod(context, target, ""setPriority"", SetPriority);
  SetMethod(context, target, ""getPriority"", GetPriority);
  SetMethod(
      context, target, ""getAvailableParallelism"", GetAvailableParallelism);
  SetMethod(context, target, ""getOSInformation""...",388.0,412.0,1.0,1.0,25.0,7,3,34,5,0,0,1,1,0,0,,0,0,8,4,4,void
4072,212091,RegisterExternalReferences,1,node.os.RegisterExternalReferences,void node.os.RegisterExternalReferences (ExternalReferenceRegistry*),node_os.cc,"void RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  registry->Register(GetHostname);
  registry->Register(GetLoadAvg);
  registry->Register(GetUptime);
  registry->Register(GetTotalMemory);
  registry->Register(GetFreeMemory);
  registry->Register(GetCPUInfo);
  registry->Register(GetInterfaceAddresses);
  registry->Register(GetHomeDirectory);
  registry->Register(GetUserInfo);
  registry->Register(SetPriority);
  registry->Register(GetPriority);
  registry->Register(GetAvailableParallelism);
  registry->Register(GetOSInformation);
}",414.0,428.0,1.0,1.0,15.0,13,1,13,1,0,0,1,1,0,0,,0,0,2,1,1,void
4073,212163,<lambda>0,1,node.performance.MarkGarbageCollectionEnd.<lambda>0,ANY node.performance.MarkGarbageCollectionEnd.<lambda>0 (Environment*),node_perf.cc,"[entry = std::move(entry)](Environment* env) {
    entry->Notify(env);
  }",192.0,194.0,21.0,3.0,3.0,1,1,2,2,0,0,1,1,0,0,,0,0,2,1,1,ANY
4074,212176,<lambda>1,1,node.performance.CreateELDHistogram.<lambda>1,ANY node.performance.CreateELDHistogram.<lambda>1 (Histogram),node_perf.cc,"[](Histogram& histogram) {
        uint64_t delta = histogram.RecordDelta();
        TRACE_COUNTER1(TRACING_CATEGORY_NODE2(perf, event_loop),
                        ""delay"", delta);
        TRACE_COUNTER1(TRACING_CATEGORY_NODE2(perf, event_loop),
                      ""min"", histogram.Min());
        TRACE_COUNTER1(TRACING_CATEGORY_NODE2(perf, event_loop),
                      ""max"", histogram.Max());
        TRACE_COUNTER1(TRACING_CATEGORY_NODE2(perf, event_loop),
                      ""mean"", histogram.Mean());
        TRACE_COUNTER1(TRACING_CATEGORY_NODE2(perf, event_loop),
                      ""stddev"", histogram.Stddev());
      }",263.0,275.0,48.0,7.0,13.0,6,2,17,4,0,0,1,1,0,0,,0,0,2,1,1,ANY
4075,212267,PerformanceState,1,node.performance.PerformanceState.PerformanceState,"ANY node.performance.PerformanceState.PerformanceState (Isolate*,ANY*)",node_perf.cc,"PerformanceState::PerformanceState(Isolate* isolate,
                                   const PerformanceState::SerializeInfo* info)
    : root(isolate,
           sizeof(performance_state_internal),
           MAYBE_FIELD_PTR(info, root)),
      milestones(isolate,
                 offsetof(performance_state_internal, milestones),
                 NODE_PERFORMANCE_MILESTONE_INVALID,
                 root,
                 MAYBE_FIELD_PTR(info, milestones)),
      observers(isolate,
                offsetof(performance_state_internal, observers),
                NODE_PERFORMANCE_ENTRY_TYPE_INVALID,
                root,
                MAYBE_FIELD_PTR(info, observers)) {
  if (info == nullptr) {
    for (size_t i = 0; i < milestones.Length(); i++) milestones[i] = -1.;
  }
}",46.0,64.0,1.0,1.0,19.0,4,4,4,3,0,0,3,4,0,0,,0,0,4,2,2,ANY
4076,212298,Serialize,1,node.performance.PerformanceState.Serialize,"SerializeInfo node.performance.PerformanceState.Serialize (ANY,ANY*)",node_perf.cc,"PerformanceState::SerializeInfo PerformanceState::Serialize(
    v8::Local<v8::Context> context, v8::SnapshotCreator* creator) {
  SerializeInfo info{root.Serialize(context, creator),
                     milestones.Serialize(context, creator),
                     observers.Serialize(context, creator)};
  return info;
}",66.0,72.0,1.0,1.0,7.0,5,3,11,6,0,0,1,1,0,0,,0,0,4,2,2,SerializeInfo
4077,212328,Deserialize,1,node.performance.PerformanceState.Deserialize,void node.performance.PerformanceState.Deserialize (ANY),node_perf.cc,"void PerformanceState::Deserialize(v8::Local<v8::Context> context) {
  root.Deserialize(context);
  // This is just done to set up the pointers, we will actually reset
  // all the milestones after deserialization.
  milestones.Deserialize(context);
  observers.Deserialize(context);
}",74.0,80.0,1.0,1.0,7.0,3,1,6,4,0,0,1,1,0,0,,0,0,2,1,1,void
4078,212348,operator <<,1,node.performance.operator <<,"ostream node.performance.operator << (ANY,ANY)",node_perf.cc,"std::ostream& operator<<(std::ostream& o,
                         const PerformanceState::SerializeInfo& i) {
  o << ""{\n""
    << ""  "" << i.root << "",  // root\n""
    << ""  "" << i.milestones << "",  // milestones\n""
    << ""  "" << i.observers << "",  // observers\n""
    << ""}"";
  return o;
}",82.0,90.0,1.0,1.0,9.0,14,2,5,2,0,0,1,1,0,0,,0,0,4,2,2,ostream
4079,212385,Mark,1,node.performance.PerformanceState.Mark,"void node.performance.PerformanceState.Mark (PerformanceMilestone,uint64_t)",node_perf.cc,"void PerformanceState::Mark(PerformanceMilestone milestone, uint64_t ts) {
  this->milestones[milestone] = static_cast<double>(ts);
  TRACE_EVENT_INSTANT_WITH_TIMESTAMP0(
      TRACING_CATEGORY_NODE1(bootstrap),
      GetPerformanceMilestoneName(milestone),
      TRACE_EVENT_SCOPE_THREAD, ts / 1000);
}",92.0,98.0,1.0,1.0,7.0,5,5,6,4,0,0,1,1,0,0,,0,0,4,2,2,void
4080,212409,MarkMilestone,1,node.performance.MarkMilestone,void node.performance.MarkMilestone (FunctionCallbackInfo<Value>),node_perf.cc,"void MarkMilestone(const FunctionCallbackInfo<Value>& args) {
  Realm* realm = Realm::GetCurrent(args);
  // TODO(legendecas): Remove this check once the sub-realms are supported.
  CHECK_EQ(realm->kind(), Realm::Kind::kPrincipal);
  Environment* env = realm->env();
  PerformanceMilestone milestone =
      static_cast<PerformanceMilestone>(args[0].As<Int32>()->Value());
  if (milestone != NODE_PERFORMANCE_MILESTONE_INVALID)
    env->performance_state()->Mark(milestone);
}",101.0,110.0,1.0,1.0,10.0,15,6,14,7,0,0,2,2,0,0,,0,0,2,1,1,void
4081,212466,SetupPerformanceObservers,1,node.performance.SetupPerformanceObservers,void node.performance.SetupPerformanceObservers (FunctionCallbackInfo<Value>),node_perf.cc,"void SetupPerformanceObservers(const FunctionCallbackInfo<Value>& args) {
  Realm* realm = Realm::GetCurrent(args);
  // TODO(legendecas): Remove this check once the sub-realms are supported.
  CHECK_EQ(realm->kind(), Realm::Kind::kPrincipal);
  CHECK(args[0]->IsFunction());
  realm->set_performance_entry_callback(args[0].As<Function>());
}",112.0,118.0,1.0,1.0,7.0,10,4,9,4,0,0,1,1,0,0,,0,0,2,1,1,void
4082,212506,MarkGarbageCollectionStart,1,node.performance.MarkGarbageCollectionStart,"void node.performance.MarkGarbageCollectionStart (Isolate*,GCType,GCCallbackFlags,void*)",node_perf.cc,"void MarkGarbageCollectionStart(
    Isolate* isolate,
    GCType type,
    GCCallbackFlags flags,
    void* data) {
  Environment* env = static_cast<Environment*>(data);
  // Prevent gc callback from reentering with different type
  // See https://github.com/nodejs/node/issues/44046
  if (env->performance_state()->current_gc_type != 0) {
    return;
  }
  env->performance_state()->performance_last_gc_start_mark = PERFORMANCE_NOW();
  env->performance_state()->current_gc_type = type;
}",121.0,134.0,1.0,1.0,14.0,11,4,6,3,0,0,2,2,0,0,,0,0,8,4,4,void
4083,212547,GetDetails,1,node.performance.GCPerformanceEntryTraits.GetDetails,"MaybeLocal<Object> node.performance.GCPerformanceEntryTraits.GetDetails (Environment*,GCPerformanceEntry)",node_perf.cc,"MaybeLocal<Object> GCPerformanceEntryTraits::GetDetails(
    Environment* env,
    const GCPerformanceEntry& entry) {
  Local<Object> obj = Object::New(env->isolate());

  if (!obj->Set(
          env->context(),
          env->kind_string(),
          Integer::NewFromUnsigned(
              env->isolate(),
              entry.details.kind)).IsJust()) {
    return MaybeLocal<Object>();
  }

  if (!obj->Set(
          env->context(),
          env->flags_string(),
          Integer::NewFromUnsigned(
              env->isolate(),
              entry.details.flags)).IsJust()) {
    return MaybeLocal<Object>();
  }

  return obj;
}",136.0,160.0,1.0,1.0,25.0,23,6,18,6,0,0,3,3,0,0,,0,0,4,2,2,MaybeLocal<Object>
4084,212635,MarkGarbageCollectionEnd,1,node.performance.MarkGarbageCollectionEnd,"void node.performance.MarkGarbageCollectionEnd (Isolate*,GCType,GCCallbackFlags,void*)",node_perf.cc,"void MarkGarbageCollectionEnd(
    Isolate* isolate,
    GCType type,
    GCCallbackFlags flags,
    void* data) {
  Environment* env = static_cast<Environment*>(data);
  PerformanceState* state = env->performance_state();
  if (type != state->current_gc_type) {
    return;
  }
  env->performance_state()->current_gc_type = 0;
  // If no one is listening to gc performance entries, do not create them.
  if (LIKELY(!state->observers[NODE_PERFORMANCE_ENTRY_TYPE_GC]))
    return;

  double start_time =
      (state->performance_last_gc_start_mark - env->time_origin()) /
      NANOS_PER_MILLIS;
  double duration = (PERFORMANCE_NOW() / NANOS_PER_MILLIS) -
                    (state->performance_last_gc_start_mark / NANOS_PER_MILLIS);

  std::unique_ptr<GCPerformanceEntry> entry =
      std::make_unique<GCPerformanceEntry>(
          ""gc"",
          start_time,
          duration,
          GCPerformanceEntry::Details(static_cast<PerformanceGCKind>(type),
                                   ...",163.0,195.0,1.0,6.0,33.0,36,13,26,12,0,0,3,3,0,0,,0,0,8,4,4,void
4085,212749,GarbageCollectionCleanupHook,1,node.performance.GarbageCollectionCleanupHook,void node.performance.GarbageCollectionCleanupHook (void*),node_perf.cc,"void GarbageCollectionCleanupHook(void* data) {
  Environment* env = static_cast<Environment*>(data);
  // Reset current_gc_type to 0
  env->performance_state()->current_gc_type = 0;
  env->isolate()->RemoveGCPrologueCallback(MarkGarbageCollectionStart, data);
  env->isolate()->RemoveGCEpilogueCallback(MarkGarbageCollectionEnd, data);
}",197.0,203.0,1.0,1.0,7.0,9,3,7,2,0,0,1,1,0,0,,0,0,2,1,1,void
4086,212786,InstallGarbageCollectionTracking,1,node.performance.InstallGarbageCollectionTracking,void node.performance.InstallGarbageCollectionTracking (FunctionCallbackInfo<Value>),node_perf.cc,"static void InstallGarbageCollectionTracking(
    const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  // Reset current_gc_type to 0
  env->performance_state()->current_gc_type = 0;
  env->isolate()->AddGCPrologueCallback(MarkGarbageCollectionStart,
                                        static_cast<void*>(env));
  env->isolate()->AddGCEpilogueCallback(MarkGarbageCollectionEnd,
                                        static_cast<void*>(env));
  env->AddCleanupHook(GarbageCollectionCleanupHook, env);
}",205.0,215.0,1.0,1.0,11.0,12,4,10,3,0,0,1,1,0,0,,0,0,2,1,1,void
4087,212835,RemoveGarbageCollectionTracking,1,node.performance.RemoveGarbageCollectionTracking,void node.performance.RemoveGarbageCollectionTracking (FunctionCallbackInfo<Value>),node_perf.cc,"static void RemoveGarbageCollectionTracking(
  const FunctionCallbackInfo<Value> &args) {
  Environment* env = Environment::GetCurrent(args);

  env->RemoveCleanupHook(GarbageCollectionCleanupHook, env);
  GarbageCollectionCleanupHook(env);
}",217.0,223.0,1.0,1.0,7.0,3,3,6,3,0,0,1,1,0,0,,0,0,2,1,1,void
4088,212856,GetName,1,node.performance.GetName,Local<Value> node.performance.GetName (Local<Function>),node_perf.cc,"inline Local<Value> GetName(Local<Function> fn) {
  Local<Value> val = fn->GetDebugName();
  if (val.IsEmpty() || val->IsUndefined()) {
    Local<Value> boundFunction = fn->GetBoundFunction();
    if (!boundFunction.IsEmpty() && !boundFunction->IsUndefined()) {
      val = GetName(boundFunction.As<Function>());
    }
  }
  return val;
}",226.0,235.0,1.0,1.0,10.0,18,8,15,5,0,0,3,4,0,0,,0,0,2,1,1,Local<Value>
4089,212914,Notify,1,node.performance.Notify,void node.performance.Notify (FunctionCallbackInfo<Value>),node_perf.cc,"void Notify(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Utf8Value type(env->isolate(), args[0]);
  Local<Value> entry = args[1];
  PerformanceEntryType entry_type = ToPerformanceEntryTypeEnum(*type);
  AliasedUint32Array& observers = env->performance_state()->observers;
  if (entry_type != NODE_PERFORMANCE_ENTRY_TYPE_INVALID &&
      observers[entry_type]) {
    USE(env->performance_entry_callback()->
      Call(env->context(), Undefined(env->isolate()), 1, &entry));
  }
}",238.0,249.0,1.0,1.0,12.0,21,10,21,10,0,0,2,2,0,0,,0,0,2,1,1,void
4090,212989,LoopIdleTime,1,node.performance.LoopIdleTime,void node.performance.LoopIdleTime (FunctionCallbackInfo<Value>),node_perf.cc,"void LoopIdleTime(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  uint64_t idle_time = uv_metrics_idle_time(env->event_loop());
  args.GetReturnValue().Set(1.0 * idle_time / 1e6);
}",252.0,256.0,1.0,1.0,5.0,8,5,7,4,0,0,1,1,0,0,,0,0,2,1,1,void
4091,213022,CreateELDHistogram,1,node.performance.CreateELDHistogram,void node.performance.CreateELDHistogram (FunctionCallbackInfo<Value>),node_perf.cc,"void CreateELDHistogram(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  int64_t interval = args[0].As<Integer>()->Value();
  CHECK_GT(interval, 0);
  BaseObjectPtr<IntervalHistogram> histogram =
      IntervalHistogram::Create(env, interval, [](Histogram& histogram) {
        uint64_t delta = histogram.RecordDelta();
        TRACE_COUNTER1(TRACING_CATEGORY_NODE2(perf, event_loop),
                        ""delay"", delta);
        TRACE_COUNTER1(TRACING_CATEGORY_NODE2(perf, event_loop),
                      ""min"", histogram.Min());
        TRACE_COUNTER1(TRACING_CATEGORY_NODE2(perf, event_loop),
                      ""max"", histogram.Max());
        TRACE_COUNTER1(TRACING_CATEGORY_NODE2(perf, event_loop),
                      ""mean"", histogram.Mean());
        TRACE_COUNTER1(TRACING_CATEGORY_NODE2(perf, event_loop),
                      ""stddev"", histogram.Stddev());
      }, Histogram::Options { 1000 });
  args.GetReturnValue().Set(...",258.0,277.0,1.0,1.0,20.0,14,7,14,7,0,0,1,1,0,0,,0,0,2,1,1,void
4092,213077,GetTimeOrigin,1,node.performance.GetTimeOrigin,void node.performance.GetTimeOrigin (FunctionCallbackInfo<Value>),node_perf.cc,"void GetTimeOrigin(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  args.GetReturnValue().Set(
      Number::New(args.GetIsolate(), env->time_origin() / NANOS_PER_MILLIS));
}",279.0,283.0,1.0,58.0,5.0,8,4,7,4,0,0,1,1,0,0,,0,0,2,1,1,void
4093,213113,GetTimeOriginTimeStamp,1,node.performance.GetTimeOriginTimeStamp,void node.performance.GetTimeOriginTimeStamp (FunctionCallbackInfo<Value>),node_perf.cc,"void GetTimeOriginTimeStamp(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  args.GetReturnValue().Set(Number::New(
      args.GetIsolate(), env->time_origin_timestamp() / MICROS_PER_MILLIS));
}",285.0,289.0,1.0,56.0,5.0,8,4,7,4,0,0,1,1,0,0,,0,0,2,1,1,void
4094,213149,MarkBootstrapComplete,1,node.performance.MarkBootstrapComplete,void node.performance.MarkBootstrapComplete (FunctionCallbackInfo<Value>),node_perf.cc,"void MarkBootstrapComplete(const FunctionCallbackInfo<Value>& args) {
  Realm* realm = Realm::GetCurrent(args);
  CHECK_EQ(realm->kind(), Realm::Kind::kPrincipal);
  realm->env()->performance_state()->Mark(
      performance::NODE_PERFORMANCE_MILESTONE_BOOTSTRAP_COMPLETE);
}",291.0,296.0,1.0,1.0,6.0,9,3,8,5,0,0,1,1,0,0,,0,0,2,1,1,void
4095,213185,CreatePerIsolateProperties,1,node.performance.CreatePerIsolateProperties,"void node.performance.CreatePerIsolateProperties (IsolateData*,Local<FunctionTemplate>)",node_perf.cc,"static void CreatePerIsolateProperties(IsolateData* isolate_data,
                                       Local<FunctionTemplate> target) {
  Isolate* isolate = isolate_data->isolate();
  Local<ObjectTemplate> proto = target->PrototypeTemplate();

  HistogramBase::Initialize(isolate_data, proto);

  SetMethod(isolate, proto, ""markMilestone"", MarkMilestone);
  SetMethod(isolate, proto, ""setupObservers"", SetupPerformanceObservers);
  SetMethod(isolate,
            proto,
            ""installGarbageCollectionTracking"",
            InstallGarbageCollectionTracking);
  SetMethod(isolate,
            proto,
            ""removeGarbageCollectionTracking"",
            RemoveGarbageCollectionTracking);
  SetMethod(isolate, proto, ""notify"", Notify);
  SetMethod(isolate, proto, ""loopIdleTime"", LoopIdleTime);
  SetMethod(isolate, proto, ""getTimeOrigin"", GetTimeOrigin);
  SetMethod(isolate, proto, ""getTimeOriginTimestamp"", GetTimeOriginTimeStamp);
  SetMethod(isolate, proto, ""createELDHistogram"", ...",298.0,321.0,1.0,1.0,24.0,7,5,29,7,0,0,1,1,0,0,,0,0,4,2,2,void
4096,213264,CreatePerContextProperties,1,node.performance.CreatePerContextProperties,"void node.performance.CreatePerContextProperties (Local<Object>,Local<Value>,Local<Context>,void*)",node_perf.cc,"void CreatePerContextProperties(Local<Object> target,
                                Local<Value> unused,
                                Local<Context> context,
                                void* priv) {
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();
  PerformanceState* state = env->performance_state();

  target->Set(context,
              FIXED_ONE_BYTE_STRING(isolate, ""observerCounts""),
              state->observers.GetJSArray()).Check();
  target->Set(context,
              FIXED_ONE_BYTE_STRING(isolate, ""milestones""),
              state->milestones.GetJSArray()).Check();

  Local<Object> constants = Object::New(isolate);

  NODE_DEFINE_CONSTANT(constants, NODE_PERFORMANCE_GC_MAJOR);
  NODE_DEFINE_CONSTANT(constants, NODE_PERFORMANCE_GC_MINOR);
  NODE_DEFINE_CONSTANT(constants, NODE_PERFORMANCE_GC_INCREMENTAL);
  NODE_DEFINE_CONSTANT(constants, NODE_PERFORMANCE_GC_WEAKCB);

  NODE_DEFINE_CONSTANT(
    constants, NODE_PERFORMANC...",323.0,375.0,1.0,2.0,53.0,387,7,369,37,0,0,1,1,0,0,,0,0,8,4,4,void
4097,214454,RegisterExternalReferences,1,node.performance.RegisterExternalReferences,void node.performance.RegisterExternalReferences (ExternalReferenceRegistry*),node_perf.cc,"void RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  registry->Register(MarkMilestone);
  registry->Register(SetupPerformanceObservers);
  registry->Register(InstallGarbageCollectionTracking);
  registry->Register(RemoveGarbageCollectionTracking);
  registry->Register(Notify);
  registry->Register(LoopIdleTime);
  registry->Register(GetTimeOrigin);
  registry->Register(GetTimeOriginTimeStamp);
  registry->Register(CreateELDHistogram);
  registry->Register(MarkBootstrapComplete);
  HistogramBase::RegisterExternalReferences(registry);
  IntervalHistogram::RegisterExternalReferences(registry);
}",377.0,390.0,1.0,1.0,14.0,12,2,14,3,0,0,1,1,0,0,,0,0,2,1,1,void
4098,214563,<lambda>0,1,node.DelayedTaskScheduler.Start.<lambda>0,ANY node.DelayedTaskScheduler.Start.<lambda>0 (void*),node_platform.cc,"[](void* data) {
      static_cast<DelayedTaskScheduler*>(data)->Run();
    }",63.0,65.0,25.0,5.0,3.0,2,2,1,1,0,0,1,1,0,0,,0,0,2,1,1,ANY
4099,214576,<lambda>1,1,node.DelayedTaskScheduler.StopTask.Run.<lambda>1,ANY node.DelayedTaskScheduler.StopTask.Run.<lambda>1 (uv_handle_t*),node_platform.cc,[](uv_handle_t* handle) {},117.0,117.0,16.0,41.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
4100,214583,<lambda>2,1,node.DelayedTaskScheduler.TakeTimerTask.<lambda>2,ANY node.DelayedTaskScheduler.TakeTimerTask.<lambda>2 (uv_handle_t*),node_platform.cc,"[](uv_handle_t* handle) {
      delete reinterpret_cast<uv_timer_t*>(handle);
    }",157.0,159.0,53.0,5.0,3.0,2,2,1,1,0,0,1,1,0,0,,0,0,2,1,1,ANY
4101,214593,<lambda>3,1,node.PerIsolatePlatformData.Shutdown.<lambda>3,ANY node.PerIsolatePlatformData.Shutdown.<lambda>3 (uv_handle_t*),node_platform.cc,"[](uv_handle_t* handle) {
    std::unique_ptr<uv_async_t> flush_tasks {
        reinterpret_cast<uv_async_t*>(handle) };
    PerIsolatePlatformData* platform_data =
        static_cast<PerIsolatePlatformData*>(flush_tasks->data);
    platform_data->DecreaseHandleCount();
    platform_data->self_reference_.reset();
  }",314.0,321.0,12.0,3.0,8.0,11,7,7,5,0,0,1,1,0,0,,0,0,2,1,1,ANY
4102,214629,<lambda>4,1,node.PerIsolatePlatformData.DeleteFromScheduledTasks.<lambda>4,bool node.PerIsolatePlatformData.DeleteFromScheduledTasks.<lambda>4 (DelayedTaskPointer),node_platform.cc,"[task](const DelayedTaskPointer& delayed) -> bool {
          return delayed.get() == task;
      }",437.0,439.0,26.0,7.0,3.0,2,2,2,2,0,0,1,1,0,0,,0,0,2,1,1,bool
4103,214643,<lambda>6,1,node.PerIsolatePlatformData.FlushForegroundTasksInternal..<lambda>6,ANY node.PerIsolatePlatformData.FlushForegroundTasksInternal..<lambda>6 (uv_handle_t*),node_platform.cc,"[](uv_handle_t* handle) {
        std::unique_ptr<DelayedTask> task {
            static_cast<DelayedTask*>(handle->data) };
        task->platform_data->DecreaseHandleCount();
      }",479.0,483.0,16.0,7.0,5.0,8,6,4,4,0,0,1,1,0,0,,0,0,2,1,1,ANY
4104,214668,<lambda>5,1,node.PerIsolatePlatformData.FlushForegroundTasksInternal.<lambda>5,ANY node.PerIsolatePlatformData.FlushForegroundTasksInternal.<lambda>5 (DelayedTask*),node_platform.cc,"[](DelayedTask* delayed) {
      uv_close(reinterpret_cast<uv_handle_t*>(&delayed->timer),
               [](uv_handle_t* handle) {
        std::unique_ptr<DelayedTask> task {
            static_cast<DelayedTask*>(handle->data) };
        task->platform_data->DecreaseHandleCount();
      });
    }",477.0,484.0,43.0,5.0,8.0,3,3,1,1,0,0,1,1,0,0,,0,0,2,1,1,ANY
4105,214682,<lambda>7,1,node.NodePlatform.GetStackTracePrinter.<lambda>7,ANY node.NodePlatform.GetStackTracePrinter.<lambda>7 (),node_platform.cc,"[]() {
    fprintf(stderr, ""\n"");
    DumpBacktrace(stderr);
    fflush(stderr);
  }",561.0,565.0,10.0,3.0,5.0,0,0,2,1,0,0,1,1,0,0,,0,0,0,0,0,ANY
4106,214718,PlatformWorkerThread,1,node.anonymous_namespace_2.PlatformWorkerThread,void node.anonymous_namespace_2.PlatformWorkerThread (void*),node_platform.cc,"static void PlatformWorkerThread(void* data) {
  std::unique_ptr<PlatformWorkerData>
      worker_data(static_cast<PlatformWorkerData*>(data));

  TaskQueue<Task>* pending_worker_tasks = worker_data->task_queue;
  TRACE_EVENT_METADATA1(""__metadata"", ""thread_name"", ""name"",
                        ""PlatformWorkerThread"");

  // Notify the main thread that the platform worker is ready.
  {
    Mutex::ScopedLock lock(*worker_data->platform_workers_mutex);
    (*worker_data->pending_platform_workers)--;
    worker_data->platform_workers_ready->Signal(lock);
  }

  while (std::unique_ptr<Task> task = pending_worker_tasks->BlockingPop()) {
    task->Run();
    pending_worker_tasks->NotifyOfCompletion();
  }
}",27.0,46.0,1.0,1.0,20.0,20,8,15,8,0,0,2,2,0,0,,0,0,2,1,1,void
4107,214784,GetActualThreadPoolSize,1,node.anonymous_namespace_3.GetActualThreadPoolSize,int node.anonymous_namespace_3.GetActualThreadPoolSize (int),node_platform.cc,"static int GetActualThreadPoolSize(int thread_pool_size) {
  if (thread_pool_size < 1) {
    thread_pool_size = uv_available_parallelism() - 1;
  }
  return std::max(thread_pool_size, 1);
}",48.0,53.0,1.0,1.0,6.0,4,4,4,2,0,0,2,2,0,0,,0,0,2,1,1,int
4108,214806,DelayedTaskScheduler,1,node.DelayedTaskScheduler.DelayedTaskScheduler,ANY node.DelayedTaskScheduler.DelayedTaskScheduler (TaskQueue<Task>*),node_platform.cc,"explicit DelayedTaskScheduler(TaskQueue<Task>* tasks)
    : pending_worker_tasks_(tasks) {}",59.0,60.0,3.0,37.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
4109,214811,Start,1,node.DelayedTaskScheduler.Start,unique_ptr<uv_thread_t> node.DelayedTaskScheduler.Start (),node_platform.cc,"std::unique_ptr<uv_thread_t> Start() {
    auto start_thread = [](void* data) {
      static_cast<DelayedTaskScheduler*>(data)->Run();
    };
    std::unique_ptr<uv_thread_t> t { new uv_thread_t() };
    uv_sem_init(&ready_, 0);
    CHECK_EQ(0, uv_thread_create(t.get(), start_thread, this));
    uv_sem_wait(&ready_);
    uv_sem_destroy(&ready_);
    return t;
  }",62.0,72.0,3.0,3.0,11.0,10,7,10,5,0,3,1,1,0,0,,0,3,0,0,0,unique_ptr<uv_thread_t>
4110,214850,PostDelayedTask,1,node.DelayedTaskScheduler.PostDelayedTask,"void node.DelayedTaskScheduler.PostDelayedTask (ANY,double)",node_platform.cc,"void PostDelayedTask(std::unique_ptr<Task> task, double delay_in_seconds) {
    tasks_.Push(std::make_unique<ScheduleTask>(this, std::move(task),
                                               delay_in_seconds));
    uv_async_send(&flush_tasks_);
  }",74.0,78.0,3.0,3.0,5.0,8,6,7,6,0,2,1,1,0,0,,0,2,4,2,2,void
4111,214878,Stop,1,node.DelayedTaskScheduler.Stop,void node.DelayedTaskScheduler.Stop (),node_platform.cc,"void Stop() {
    tasks_.Push(std::make_unique<StopTask>(this));
    uv_async_send(&flush_tasks_);
  }",80.0,83.0,3.0,3.0,4.0,5,4,4,4,0,2,1,1,0,0,,0,2,0,0,0,void
4112,214896,Run,1,node.DelayedTaskScheduler.Run,void node.DelayedTaskScheduler.Run (),node_platform.cc,"void Run() {
    TRACE_EVENT_METADATA1(""__metadata"", ""thread_name"", ""name"",
                          ""WorkerThreadsTaskRunner::DelayedTaskScheduler"");
    loop_.data = this;
    CHECK_EQ(0, uv_loop_init(&loop_));
    flush_tasks_.data = this;
    CHECK_EQ(0, uv_async_init(&loop_, &flush_tasks_, FlushTasks));
    uv_sem_post(&ready_);

    uv_run(&loop_, UV_RUN_DEFAULT);
    CheckedUvLoopClose(&loop_);
  }",86.0,97.0,3.0,3.0,12.0,10,3,9,4,0,8,1,1,0,0,,0,8,0,0,0,void
4113,214938,FlushTasks,1,node.DelayedTaskScheduler.FlushTasks,void node.DelayedTaskScheduler.FlushTasks (uv_async_t*),node_platform.cc,"static void FlushTasks(uv_async_t* flush_tasks) {
    DelayedTaskScheduler* scheduler =
        ContainerOf(&DelayedTaskScheduler::loop_, flush_tasks->loop);
    while (std::unique_ptr<Task> task = scheduler->tasks_.Pop())
      task->Run();
  }",99.0,104.0,3.0,3.0,6.0,10,6,7,6,0,2,2,2,1,0,,0,2,2,1,1,void
4114,214973,StopTask,1,node.DelayedTaskScheduler.StopTask.StopTask,ANY node.DelayedTaskScheduler.StopTask.StopTask (DelayedTaskScheduler*),node_platform.cc,explicit StopTask(DelayedTaskScheduler* scheduler): scheduler_(scheduler) {},108.0,108.0,5.0,80.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
4115,214978,Run,1,node.DelayedTaskScheduler.StopTask.Run,void node.DelayedTaskScheduler.StopTask.Run (),node_platform.cc,"void Run() override {
      std::vector<uv_timer_t*> timers;
      for (uv_timer_t* timer : scheduler_->timers_)
        timers.push_back(timer);
      for (uv_timer_t* timer : timers)
        scheduler_->TakeTimerTask(timer);
      uv_close(reinterpret_cast<uv_handle_t*>(&scheduler_->flush_tasks_),
               [](uv_handle_t* handle) {});
    }",110.0,118.0,5.0,5.0,9.0,4,3,3,2,0,2,3,3,1,0,,0,2,0,0,0,void
4116,215011,ScheduleTask,1,node.DelayedTaskScheduler.ScheduleTask.ScheduleTask,"ANY node.DelayedTaskScheduler.ScheduleTask.ScheduleTask (DelayedTaskScheduler*,ANY,double)",node_platform.cc,"ScheduleTask(DelayedTaskScheduler* scheduler,
                 std::unique_ptr<Task> task,
                 double delay_in_seconds)
      : scheduler_(scheduler),
        task_(std::move(task)),
        delay_in_seconds_(delay_in_seconds) {}",126.0,131.0,5.0,46.0,6.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,ANY
4117,215018,Run,1,node.DelayedTaskScheduler.ScheduleTask.Run,void node.DelayedTaskScheduler.ScheduleTask.Run (),node_platform.cc,"void Run() override {
      uint64_t delay_millis = llround(delay_in_seconds_ * 1000);
      std::unique_ptr<uv_timer_t> timer(new uv_timer_t());
      CHECK_EQ(0, uv_timer_init(&scheduler_->loop_, timer.get()));
      timer->data = task_.release();
      CHECK_EQ(0, uv_timer_start(timer.get(), RunTask, delay_millis, 0));
      scheduler_->timers_.insert(timer.release());
    }",133.0,140.0,5.0,5.0,8.0,16,8,13,7,0,4,1,1,0,0,,0,4,0,0,0,void
4118,215080,RunTask,1,node.DelayedTaskScheduler.RunTask,void node.DelayedTaskScheduler.RunTask (uv_timer_t*),node_platform.cc,"static void RunTask(uv_timer_t* timer) {
    DelayedTaskScheduler* scheduler =
        ContainerOf(&DelayedTaskScheduler::loop_, timer->loop);
    scheduler->pending_worker_tasks_->Push(scheduler->TakeTimerTask(timer));
  }",148.0,152.0,3.0,3.0,5.0,7,4,6,3,0,2,1,1,0,0,,0,2,2,1,1,void
4119,215107,TakeTimerTask,1,node.DelayedTaskScheduler.TakeTimerTask,unique_ptr<Task> node.DelayedTaskScheduler.TakeTimerTask (uv_timer_t*),node_platform.cc,"std::unique_ptr<Task> TakeTimerTask(uv_timer_t* timer) {
    std::unique_ptr<Task> task(static_cast<Task*>(timer->data));
    uv_timer_stop(timer);
    uv_close(reinterpret_cast<uv_handle_t*>(timer), [](uv_handle_t* handle) {
      delete reinterpret_cast<uv_timer_t*>(handle);
    });
    timers_.erase(timer);
    return task;
  }",154.0,162.0,3.0,3.0,9.0,7,5,8,5,0,1,1,1,0,0,,0,1,2,1,1,unique_ptr<Task>
4120,215144,WorkerThreadsTaskRunner,1,node.WorkerThreadsTaskRunner.WorkerThreadsTaskRunner,ANY node.WorkerThreadsTaskRunner.WorkerThreadsTaskRunner (int),node_platform.cc,"WorkerThreadsTaskRunner::WorkerThreadsTaskRunner(int thread_pool_size) {
  Mutex platform_workers_mutex;
  ConditionVariable platform_workers_ready;

  Mutex::ScopedLock lock(platform_workers_mutex);
  int pending_platform_workers = thread_pool_size;

  delayed_task_scheduler_ = std::make_unique<DelayedTaskScheduler>(
      &pending_worker_tasks_);
  threads_.push_back(delayed_task_scheduler_->Start());

  for (int i = 0; i < thread_pool_size; i++) {
    PlatformWorkerData* worker_data = new PlatformWorkerData{
      &pending_worker_tasks_, &platform_workers_mutex,
      &platform_workers_ready, &pending_platform_workers, i
    };
    std::unique_ptr<uv_thread_t> t { new uv_thread_t() };
    if (uv_thread_create(t.get(), PlatformWorkerThread,
                         worker_data) != 0) {
      break;
    }
    threads_.push_back(std::move(t));
  }

  // Wait for platform workers to initialize before continuing with the
  // bootstrap.
  while (pending_platform_workers > 0) {
    pla...",173.0,202.0,1.0,1.0,30.0,23,9,26,16,0,0,5,5,0,0,,0,0,2,1,1,ANY
4121,215234,PostTask,1,node.WorkerThreadsTaskRunner.PostTask,void node.WorkerThreadsTaskRunner.PostTask (ANY),node_platform.cc,"void WorkerThreadsTaskRunner::PostTask(std::unique_ptr<Task> task) {
  pending_worker_tasks_.Push(std::move(task));
}",204.0,206.0,1.0,1.0,3.0,2,1,3,3,0,0,1,1,0,0,,0,0,2,1,1,void
4122,215248,PostDelayedTask,1,node.WorkerThreadsTaskRunner.PostDelayedTask,"void node.WorkerThreadsTaskRunner.PostDelayedTask (ANY,double)",node_platform.cc,"void WorkerThreadsTaskRunner::PostDelayedTask(std::unique_ptr<Task> task,
                                              double delay_in_seconds) {
  delayed_task_scheduler_->PostDelayedTask(std::move(task), delay_in_seconds);
}",208.0,211.0,1.0,1.0,4.0,2,2,4,4,0,0,1,1,0,0,,0,0,4,2,2,void
4123,215264,BlockingDrain,1,node.WorkerThreadsTaskRunner.BlockingDrain,void node.WorkerThreadsTaskRunner.BlockingDrain (),node_platform.cc,"void WorkerThreadsTaskRunner::BlockingDrain() {
  pending_worker_tasks_.BlockingDrain();
}",213.0,215.0,1.0,1.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
4124,215272,Shutdown,1,node.WorkerThreadsTaskRunner.Shutdown,void node.WorkerThreadsTaskRunner.Shutdown (),node_platform.cc,"void WorkerThreadsTaskRunner::Shutdown() {
  pending_worker_tasks_.Stop();
  delayed_task_scheduler_->Stop();
  for (size_t i = 0; i < threads_.size(); i++) {
    CHECK_EQ(0, uv_thread_join(threads_[i].get()));
  }
}",217.0,223.0,1.0,1.0,7.0,7,5,7,4,0,0,2,2,0,0,,0,0,0,0,0,void
4125,215308,NumberOfWorkerThreads,1,node.WorkerThreadsTaskRunner.NumberOfWorkerThreads,int node.WorkerThreadsTaskRunner.NumberOfWorkerThreads (),node_platform.cc,"int WorkerThreadsTaskRunner::NumberOfWorkerThreads() const {
  return threads_.size();
}",225.0,227.0,1.0,1.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,int
4126,215317,PerIsolatePlatformData,1,node.PerIsolatePlatformData.PerIsolatePlatformData,"ANY node.PerIsolatePlatformData.PerIsolatePlatformData (Isolate*,uv_loop_t*)",node_platform.cc,"PerIsolatePlatformData::PerIsolatePlatformData(
    Isolate* isolate, uv_loop_t* loop)
  : isolate_(isolate), loop_(loop) {
  flush_tasks_ = new uv_async_t();
  CHECK_EQ(0, uv_async_init(loop, flush_tasks_, FlushTasks));
  flush_tasks_->data = static_cast<void*>(this);
  uv_unref(reinterpret_cast<uv_handle_t*>(flush_tasks_));
}",229.0,236.0,1.0,1.0,8.0,6,4,7,4,0,0,1,1,0,0,,0,0,4,2,2,ANY
4127,215344,GetForegroundTaskRunner,1,node.PerIsolatePlatformData.GetForegroundTaskRunner,shared_ptr<v8::TaskRunner> node.PerIsolatePlatformData.GetForegroundTaskRunner (),node_platform.cc,"std::shared_ptr<v8::TaskRunner>
PerIsolatePlatformData::GetForegroundTaskRunner() {
  return shared_from_this();
}",238.0,241.0,1.0,1.0,4.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,shared_ptr<v8.TaskRunner>
4128,215350,FlushTasks,1,node.PerIsolatePlatformData.FlushTasks,void node.PerIsolatePlatformData.FlushTasks (uv_async_t*),node_platform.cc,"void PerIsolatePlatformData::FlushTasks(uv_async_t* handle) {
  auto platform_data = static_cast<PerIsolatePlatformData*>(handle->data);
  platform_data->FlushForegroundTasksInternal();
}",243.0,246.0,1.0,1.0,4.0,4,3,3,2,0,0,1,1,0,0,,0,0,2,1,1,void
4129,215367,PostIdleTask,1,node.PerIsolatePlatformData.PostIdleTask,void node.PerIsolatePlatformData.PostIdleTask (ANY),node_platform.cc,"void PerIsolatePlatformData::PostIdleTask(std::unique_ptr<v8::IdleTask> task) {
  UNREACHABLE();
}",248.0,250.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
4130,215373,PostTask,1,node.PerIsolatePlatformData.PostTask,void node.PerIsolatePlatformData.PostTask (ANY),node_platform.cc,"void PerIsolatePlatformData::PostTask(std::unique_ptr<Task> task) {
  if (flush_tasks_ == nullptr) {
    // V8 may post tasks during Isolate disposal. In that case, the only
    // sensible path forward is to discard the task.
    return;
  }
  foreground_tasks_.Push(std::move(task));
  uv_async_send(flush_tasks_);
}",252.0,260.0,1.0,1.0,9.0,3,2,4,4,0,0,2,2,0,0,,0,0,2,1,1,void
4131,215394,PostDelayedTask,1,node.PerIsolatePlatformData.PostDelayedTask,"void node.PerIsolatePlatformData.PostDelayedTask (ANY,double)",node_platform.cc,"void PerIsolatePlatformData::PostDelayedTask(
    std::unique_ptr<Task> task, double delay_in_seconds) {
  if (flush_tasks_ == nullptr) {
    // V8 may post tasks during Isolate disposal. In that case, the only
    // sensible path forward is to discard the task.
    return;
  }
  std::unique_ptr<DelayedTask> delayed(new DelayedTask());
  delayed->task = std::move(task);
  delayed->platform_data = shared_from_this();
  delayed->timeout = delay_in_seconds;
  foreground_delayed_tasks_.Push(std::move(delayed));
  uv_async_send(flush_tasks_);
}",262.0,275.0,1.0,1.0,14.0,14,7,13,7,0,0,2,2,0,0,,0,0,4,2,2,void
4132,215444,PostNonNestableTask,1,node.PerIsolatePlatformData.PostNonNestableTask,void node.PerIsolatePlatformData.PostNonNestableTask (ANY),node_platform.cc,"void PerIsolatePlatformData::PostNonNestableTask(std::unique_ptr<Task> task) {
  PostTask(std::move(task));
}",277.0,279.0,1.0,1.0,3.0,1,1,2,2,0,0,1,1,0,0,,0,0,2,1,1,void
4133,215455,PostNonNestableDelayedTask,1,node.PerIsolatePlatformData.PostNonNestableDelayedTask,"void node.PerIsolatePlatformData.PostNonNestableDelayedTask (ANY,double)",node_platform.cc,"void PerIsolatePlatformData::PostNonNestableDelayedTask(
    std::unique_ptr<Task> task,
    double delay_in_seconds) {
  PostDelayedTask(std::move(task), delay_in_seconds);
}",281.0,285.0,1.0,1.0,5.0,1,1,3,3,0,0,1,1,0,0,,0,0,4,2,2,void
4134,215468,~PerIsolatePlatformData,1,node.PerIsolatePlatformData.~PerIsolatePlatformData,ANY node.PerIsolatePlatformData.~PerIsolatePlatformData (),node_platform.cc,"PerIsolatePlatformData::~PerIsolatePlatformData() {
  CHECK(!flush_tasks_);
}",287.0,289.0,1.0,1.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,ANY
4135,215475,AddShutdownCallback,1,node.PerIsolatePlatformData.AddShutdownCallback,"void node.PerIsolatePlatformData.AddShutdownCallback (void,void*)",node_platform.cc,"void PerIsolatePlatformData::AddShutdownCallback(void (*callback)(void*),
                                                 void* data) {
  shutdown_callbacks_.emplace_back(ShutdownCallback { callback, data });
}",291.0,294.0,1.0,1.0,4.0,2,2,3,3,0,0,1,1,0,0,,0,0,4,2,2,void
4136,215489,Shutdown,1,node.PerIsolatePlatformData.Shutdown,void node.PerIsolatePlatformData.Shutdown (),node_platform.cc,"void PerIsolatePlatformData::Shutdown() {
  if (flush_tasks_ == nullptr)
    return;

  // While there should be no V8 tasks in the queues at this point, it is
  // possible that Node.js-internal tasks from e.g. the inspector are still
  // lying around. We clear these queues and ignore the return value,
  // effectively deleting the tasks instead of running them.
  foreground_delayed_tasks_.PopAll();
  foreground_tasks_.PopAll();
  scheduled_delayed_tasks_.clear();

  // Both destroying the scheduled_delayed_tasks_ lists and closing
  // flush_tasks_ handle add tasks to the event loop. We keep a count of all
  // non-closed handles, and when that reaches zero, we inform any shutdown
  // callbacks that the platform is done as far as this Isolate is concerned.
  self_reference_ = shared_from_this();
  uv_close(reinterpret_cast<uv_handle_t*>(flush_tasks_),
           [](uv_handle_t* handle) {
    std::unique_ptr<uv_async_t> flush_tasks {
        reinterpret_cast<uv_async_t*>(handle) ...",296.0,323.0,1.0,1.0,28.0,7,4,7,5,0,0,2,2,0,0,,0,0,0,0,0,void
4137,215522,DecreaseHandleCount,1,node.PerIsolatePlatformData.DecreaseHandleCount,void node.PerIsolatePlatformData.DecreaseHandleCount (),node_platform.cc,"void PerIsolatePlatformData::DecreaseHandleCount() {
  CHECK_GE(uv_handle_count_, 1);
  if (--uv_handle_count_ == 0) {
    for (const auto& callback : shutdown_callbacks_)
      callback.cb(callback.data);
  }
}",325.0,331.0,1.0,1.0,7.0,2,2,3,2,0,0,3,4,0,0,,0,0,0,0,0,void
4138,215545,NodePlatform,1,node.NodePlatform.NodePlatform,"ANY node.NodePlatform.NodePlatform (int,ANY*,ANY*)",node_platform.cc,"NodePlatform::NodePlatform(int thread_pool_size,
                           v8::TracingController* tracing_controller,
                           v8::PageAllocator* page_allocator) {
  if (tracing_controller != nullptr) {
    tracing_controller_ = tracing_controller;
  } else {
    tracing_controller_ = new v8::TracingController();
  }

  // V8 will default to its built in allocator if none is provided.
  page_allocator_ = page_allocator;

  // TODO(addaleax): It's a bit icky that we use global state here, but we can't
  // really do anything about it unless V8 starts exposing a way to access the
  // current v8::Platform instance.
  SetTracingController(tracing_controller_);
  DCHECK_EQ(GetTracingController(), tracing_controller_);

  thread_pool_size = GetActualThreadPoolSize(thread_pool_size);
  worker_thread_task_runner_ =
      std::make_shared<WorkerThreadsTaskRunner>(thread_pool_size);
}",333.0,354.0,1.0,1.0,22.0,8,5,12,8,0,0,2,2,0,0,,0,0,6,3,3,ANY
4139,215586,~NodePlatform,1,node.NodePlatform.~NodePlatform,ANY node.NodePlatform.~NodePlatform (),node_platform.cc,"NodePlatform::~NodePlatform() {
  Shutdown();
}",356.0,358.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
4140,215591,RegisterIsolate,1,node.NodePlatform.RegisterIsolate,"void node.NodePlatform.RegisterIsolate (Isolate*,uv_loop_t*)",node_platform.cc,"void NodePlatform::RegisterIsolate(Isolate* isolate,
                                   IsolatePlatformDelegate* delegate) {
  Mutex::ScopedLock lock(per_isolate_mutex_);
  auto insertion = per_isolate_.emplace(
    isolate,
    std::make_pair(delegate, std::shared_ptr<PerIsolatePlatformData>{}));
  CHECK(insertion.second);
}",370.0,377.0,1.0,1.0,8.0,13,6,16,9,0,0,1,1,0,0,,0,0,4,2,2,void
4141,215670,UnregisterIsolate,1,node.NodePlatform.UnregisterIsolate,void node.NodePlatform.UnregisterIsolate (Isolate*),node_platform.cc,"void NodePlatform::UnregisterIsolate(Isolate* isolate) {
  Mutex::ScopedLock lock(per_isolate_mutex_);
  auto existing_it = per_isolate_.find(isolate);
  CHECK_NE(existing_it, per_isolate_.end());
  auto& existing = existing_it->second;
  if (existing.second) {
    existing.second->Shutdown();
  }
  per_isolate_.erase(existing_it);
}",379.0,388.0,1.0,1.0,10.0,9,3,12,5,0,0,2,2,0,0,,0,0,2,1,1,void
4142,215714,AddIsolateFinishedCallback,1,node.NodePlatform.AddIsolateFinishedCallback,"void node.NodePlatform.AddIsolateFinishedCallback (Isolate*,void,void*)",node_platform.cc,"void NodePlatform::AddIsolateFinishedCallback(Isolate* isolate,
                                              void (*cb)(void*), void* data) {
  Mutex::ScopedLock lock(per_isolate_mutex_);
  auto it = per_isolate_.find(isolate);
  if (it == per_isolate_.end()) {
    cb(data);
    return;
  }
  CHECK(it->second.second);
  it->second.second->AddShutdownCallback(cb, data);
}",390.0,400.0,1.0,1.0,11.0,9,4,11,6,0,0,2,2,0,0,,0,0,6,3,3,void
4143,215759,Shutdown,1,node.NodePlatform.Shutdown,void node.NodePlatform.Shutdown (),node_platform.cc,"void NodePlatform::Shutdown() {
  if (has_shut_down_) return;
  has_shut_down_ = true;
  worker_thread_task_runner_->Shutdown();

  {
    Mutex::ScopedLock lock(per_isolate_mutex_);
    per_isolate_.clear();
  }
}",402.0,411.0,1.0,1.0,10.0,3,3,5,4,0,0,2,2,0,0,,0,0,0,0,0,void
4144,215782,NumberOfWorkerThreads,1,node.NodePlatform.NumberOfWorkerThreads,int node.NodePlatform.NumberOfWorkerThreads (),node_platform.cc,"int NodePlatform::NumberOfWorkerThreads() {
  return worker_thread_task_runner_->NumberOfWorkerThreads();
}",413.0,415.0,1.0,1.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,int
4145,215791,RunForegroundTask,1,node.PerIsolatePlatformData.RunForegroundTask,void node.PerIsolatePlatformData.RunForegroundTask (ANY),node_platform.cc,"void PerIsolatePlatformData::RunForegroundTask(uv_timer_t* handle) {
  DelayedTask* delayed = ContainerOf(&DelayedTask::timer, handle);
  delayed->platform_data->RunForegroundTask(std::move(delayed->task));
  delayed->platform_data->DeleteFromScheduledTasks(delayed);
}",444.0,448.0,1.0,1.0,5.0,8,5,12,6,0,0,3,3,0,0,,0,0,2,1,1,void
4146,215846,DeleteFromScheduledTasks,1,node.PerIsolatePlatformData.DeleteFromScheduledTasks,void node.PerIsolatePlatformData.DeleteFromScheduledTasks (DelayedTask*),node_platform.cc,"void PerIsolatePlatformData::DeleteFromScheduledTasks(DelayedTask* task) {
  auto it = std::find_if(scheduled_delayed_tasks_.begin(),
                         scheduled_delayed_tasks_.end(),
                         [task](const DelayedTaskPointer& delayed) -> bool {
          return delayed.get() == task;
      });
  CHECK_NE(it, scheduled_delayed_tasks_.end());
  scheduled_delayed_tasks_.erase(it);
}",434.0,442.0,1.0,1.0,9.0,6,2,8,3,0,0,1,1,0,0,,0,0,2,1,1,void
4147,215911,DrainTasks,1,node.NodePlatform.DrainTasks,void node.NodePlatform.DrainTasks (Isolate*),node_platform.cc,"void NodePlatform::DrainTasks(Isolate* isolate) {
  std::shared_ptr<PerIsolatePlatformData> per_isolate = ForNodeIsolate(isolate);
  if (!per_isolate) return;

  do {
    // Worker tasks aren't associated with an Isolate.
    worker_thread_task_runner_->BlockingDrain();
  } while (per_isolate->FlushForegroundTasksInternal());
}",450.0,458.0,1.0,1.0,9.0,7,6,7,5,0,0,3,3,0,0,,0,0,2,1,1,void
4148,215941,FlushForegroundTasksInternal,1,node.PerIsolatePlatformData.FlushForegroundTasksInternal,bool node.PerIsolatePlatformData.FlushForegroundTasksInternal (),node_platform.cc,"bool PerIsolatePlatformData::FlushForegroundTasksInternal() {
  bool did_work = false;

  while (std::unique_ptr<DelayedTask> delayed =
      foreground_delayed_tasks_.Pop()) {
    did_work = true;
    uint64_t delay_millis = llround(delayed->timeout * 1000);

    delayed->timer.data = static_cast<void*>(delayed.get());
    uv_timer_init(loop_, &delayed->timer);
    // Timers may not guarantee queue ordering of events with the same delay if
    // the delay is non-zero. This should not be a problem in practice.
    uv_timer_start(&delayed->timer, RunForegroundTask, delay_millis, 0);
    uv_unref(reinterpret_cast<uv_handle_t*>(&delayed->timer));
    uv_handle_count_++;

    scheduled_delayed_tasks_.emplace_back(delayed.release(),
                                          [](DelayedTask* delayed) {
      uv_close(reinterpret_cast<uv_handle_t*>(&delayed->timer),
               [](uv_handle_t* handle) {
        std::unique_ptr<DelayedTask> task {
            static_cast<DelayedTask*>(ha...",460.0,497.0,1.0,1.0,38.0,43,11,35,14,0,0,3,3,0,0,,0,0,0,0,0,bool
4149,216073,CallOnWorkerThread,1,node.NodePlatform.CallOnWorkerThread,void node.NodePlatform.CallOnWorkerThread (ANY),node_platform.cc,"void NodePlatform::CallOnWorkerThread(std::unique_ptr<Task> task) {
  worker_thread_task_runner_->PostTask(std::move(task));
}",499.0,501.0,1.0,1.0,3.0,2,2,3,3,0,0,1,1,0,0,,0,0,2,1,1,void
4150,216087,CallDelayedOnWorkerThread,1,node.NodePlatform.CallDelayedOnWorkerThread,"void node.NodePlatform.CallDelayedOnWorkerThread (ANY,double)",node_platform.cc,"void NodePlatform::CallDelayedOnWorkerThread(std::unique_ptr<Task> task,
                                             double delay_in_seconds) {
  worker_thread_task_runner_->PostDelayedTask(std::move(task),
                                              delay_in_seconds);
}",503.0,507.0,1.0,1.0,5.0,2,2,4,4,0,0,1,1,0,0,,0,0,4,2,2,void
4151,216103,ForIsolate,1,node.NodePlatform.ForIsolate,IsolatePlatformDelegate node.NodePlatform.ForIsolate (Isolate*),node_platform.cc,"IsolatePlatformDelegate* NodePlatform::ForIsolate(Isolate* isolate) {
  Mutex::ScopedLock lock(per_isolate_mutex_);
  auto data = per_isolate_[isolate];
  CHECK_NOT_NULL(data.first);
  return data.first;
}",510.0,515.0,1.0,1.0,6.0,4,3,6,4,0,0,1,1,0,0,,0,0,2,1,1,IsolatePlatformDelegate
4152,216125,ForNodeIsolate,1,node.NodePlatform.ForNodeIsolate,shared_ptr<PerIsolatePlatformData> node.NodePlatform.ForNodeIsolate (Isolate*),node_platform.cc,"std::shared_ptr<PerIsolatePlatformData>
NodePlatform::ForNodeIsolate(Isolate* isolate) {
  Mutex::ScopedLock lock(per_isolate_mutex_);
  auto data = per_isolate_[isolate];
  CHECK_NOT_NULL(data.first);
  return data.second;
}",517.0,523.0,1.0,1.0,7.0,4,3,6,4,0,0,1,1,0,0,,0,0,2,1,1,shared_ptr<PerIsolatePlatformData>
4153,216147,FlushForegroundTasks,1,node.NodePlatform.FlushForegroundTasks,bool node.NodePlatform.FlushForegroundTasks (Isolate*),node_platform.cc,"bool NodePlatform::FlushForegroundTasks(Isolate* isolate) {
  std::shared_ptr<PerIsolatePlatformData> per_isolate = ForNodeIsolate(isolate);
  if (!per_isolate) return false;
  return per_isolate->FlushForegroundTasksInternal();
}",525.0,529.0,1.0,1.0,5.0,6,6,6,4,0,0,2,2,0,0,,0,0,2,1,1,bool
4154,216173,CreateJob,1,node.NodePlatform.CreateJob,"unique_ptr<v8::JobHandle> node.NodePlatform.CreateJob (ANY,ANY)",node_platform.cc,"std::unique_ptr<v8::JobHandle> NodePlatform::CreateJob(
    v8::TaskPriority priority, std::unique_ptr<v8::JobTask> job_task) {
  return v8::platform::NewDefaultJobHandle(
      this, priority, std::move(job_task), NumberOfWorkerThreads());
}",531.0,535.0,1.0,1.0,5.0,3,1,5,5,0,0,1,1,0,0,,0,0,4,2,2,unique_ptr<v8.JobHandle>
4155,216194,IdleTasksEnabled,1,node.NodePlatform.IdleTasksEnabled,bool node.NodePlatform.IdleTasksEnabled (Isolate*),node_platform.cc,"bool NodePlatform::IdleTasksEnabled(Isolate* isolate) {
  return ForIsolate(isolate)->IdleTasksEnabled();
}",537.0,539.0,1.0,1.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,bool
4156,216205,GetForegroundTaskRunner,1,node.NodePlatform.GetForegroundTaskRunner,shared_ptr<v8::TaskRunner> node.NodePlatform.GetForegroundTaskRunner (Isolate*),node_platform.cc,"std::shared_ptr<v8::TaskRunner>
NodePlatform::GetForegroundTaskRunner(Isolate* isolate) {
  return ForIsolate(isolate)->GetForegroundTaskRunner();
}",541.0,544.0,1.0,1.0,4.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,shared_ptr<v8.TaskRunner>
4157,216216,MonotonicallyIncreasingTime,1,node.NodePlatform.MonotonicallyIncreasingTime,double node.NodePlatform.MonotonicallyIncreasingTime (),node_platform.cc,"double NodePlatform::MonotonicallyIncreasingTime() {
  // Convert nanos to seconds.
  return uv_hrtime() / 1e9;
}",546.0,549.0,1.0,1.0,4.0,1,1,0,0,0,0,1,1,0,0,,0,0,0,0,0,double
4158,216224,CurrentClockTimeMillis,1,node.NodePlatform.CurrentClockTimeMillis,double node.NodePlatform.CurrentClockTimeMillis (),node_platform.cc,"double NodePlatform::CurrentClockTimeMillis() {
  return SystemClockTimeMillis();
}",551.0,553.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,double
4159,216230,GetTracingController,1,node.NodePlatform.GetTracingController,TracingController node.NodePlatform.GetTracingController (),node_platform.cc,"v8::TracingController* NodePlatform::GetTracingController() {
  CHECK_NOT_NULL(tracing_controller_);
  return tracing_controller_;
}",555.0,558.0,1.0,1.0,4.0,0,0,1,1,0,0,1,1,0,0,,0,0,0,0,0,TracingController
4160,216237,GetStackTracePrinter,1,node.NodePlatform.GetStackTracePrinter,StackTracePrinter node.NodePlatform.GetStackTracePrinter (),node_platform.cc,"Platform::StackTracePrinter NodePlatform::GetStackTracePrinter() {
  return []() {
    fprintf(stderr, ""\n"");
    DumpBacktrace(stderr);
    fflush(stderr);
  };
}",560.0,566.0,1.0,1.0,7.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,StackTracePrinter
4161,216243,GetPageAllocator,1,node.NodePlatform.GetPageAllocator,PageAllocator node.NodePlatform.GetPageAllocator (),node_platform.cc,"v8::PageAllocator* NodePlatform::GetPageAllocator() {
  return page_allocator_;
}",568.0,570.0,1.0,1.0,3.0,0,0,1,1,0,0,1,1,0,0,,0,0,0,0,0,PageAllocator
4162,216249,TaskQueue,1,node.TaskQueue<T>.TaskQueue,ANY node.TaskQueue<T>.TaskQueue<T> (),node_platform.cc,"TaskQueue<T>::TaskQueue()
    : lock_(), tasks_available_(), tasks_drained_(),
      outstanding_tasks_(0), stopped_(false), task_queue_() { }",573.0,575.0,1.0,63.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
4163,216253,Push,1,node.TaskQueue<T>.Push,void node.TaskQueue<T>.Push<T> (ANY),node_platform.cc,"void TaskQueue<T>::Push(std::unique_ptr<T> task) {
  Mutex::ScopedLock scoped_lock(lock_);
  outstanding_tasks_++;
  task_queue_.push(std::move(task));
  tasks_available_.Signal(scoped_lock);
}",578.0,583.0,1.0,1.0,6.0,4,2,7,7,0,0,1,1,0,0,,0,0,2,1,1,void
4164,216277,Pop,1,node.TaskQueue<T>.Pop,unique_ptr<T> node.TaskQueue<T>.Pop<T> (),node_platform.cc,"std::unique_ptr<T> TaskQueue<T>::Pop() {
  Mutex::ScopedLock scoped_lock(lock_);
  if (task_queue_.empty()) {
    return std::unique_ptr<T>(nullptr);
  }
  std::unique_ptr<T> result = std::move(task_queue_.front());
  task_queue_.pop();
  return result;
}",586.0,594.0,1.0,1.0,9.0,11,4,11,5,0,0,2,2,0,0,,0,0,0,0,0,unique_ptr<T>
4165,216320,BlockingPop,1,node.TaskQueue<T>.BlockingPop,unique_ptr<T> node.TaskQueue<T>.BlockingPop<T> (),node_platform.cc,"std::unique_ptr<T> TaskQueue<T>::BlockingPop() {
  Mutex::ScopedLock scoped_lock(lock_);
  while (task_queue_.empty() && !stopped_) {
    tasks_available_.Wait(scoped_lock);
  }
  if (stopped_) {
    return std::unique_ptr<T>(nullptr);
  }
  std::unique_ptr<T> result = std::move(task_queue_.front());
  task_queue_.pop();
  return result;
}",597.0,608.0,1.0,1.0,12.0,14,6,15,8,0,0,3,3,0,0,,0,0,0,0,0,unique_ptr<T>
4166,216374,NotifyOfCompletion,1,node.TaskQueue<T>.NotifyOfCompletion,void node.TaskQueue<T>.NotifyOfCompletion<T> (),node_platform.cc,"void TaskQueue<T>::NotifyOfCompletion() {
  Mutex::ScopedLock scoped_lock(lock_);
  if (--outstanding_tasks_ == 0) {
    tasks_drained_.Broadcast(scoped_lock);
  }
}",611.0,616.0,1.0,1.0,6.0,3,3,4,4,0,0,2,2,0,0,,0,0,0,0,0,void
4167,216392,BlockingDrain,1,node.TaskQueue<T>.BlockingDrain,void node.TaskQueue<T>.BlockingDrain<T> (),node_platform.cc,"void TaskQueue<T>::BlockingDrain() {
  Mutex::ScopedLock scoped_lock(lock_);
  while (outstanding_tasks_ > 0) {
    tasks_drained_.Wait(scoped_lock);
  }
}",619.0,624.0,1.0,1.0,6.0,2,2,4,4,0,0,2,2,0,0,,0,0,0,0,0,void
4168,216409,Stop,1,node.TaskQueue<T>.Stop,void node.TaskQueue<T>.Stop<T> (),node_platform.cc,"void TaskQueue<T>::Stop() {
  Mutex::ScopedLock scoped_lock(lock_);
  stopped_ = true;
  tasks_available_.Broadcast(scoped_lock);
}",627.0,631.0,1.0,1.0,5.0,2,2,4,4,0,0,1,1,0,0,,0,0,0,0,0,void
4169,216424,PopAll,1,node.TaskQueue<T>.PopAll,queue<std::unique_ptr<T>> node.TaskQueue<T>.PopAll<T> (),node_platform.cc,"std::queue<std::unique_ptr<T>> TaskQueue<T>::PopAll() {
  Mutex::ScopedLock scoped_lock(lock_);
  std::queue<std::unique_ptr<T>> result;
  result.swap(task_queue_);
  return result;
}",634.0,639.0,1.0,1.0,6.0,6,3,8,5,0,0,1,1,0,0,,0,0,0,0,0,queue<std.unique_ptr<T>>
4170,216512,GenDebugSymbols,1,node.GenDebugSymbols,int node.GenDebugSymbols (),node_postmortem_metadata.cc,"int GenDebugSymbols() {
  nodedbg_const_ContextEmbedderIndex__kEnvironment__int =
      ContextEmbedderIndex::kEnvironment;
  nodedbg_const_BaseObject__kInternalFieldCount__int =
      BaseObject::kInternalFieldCount;

  nodedbg_offset_ExternalString__data__uintptr_t = NODE_OFF_EXTSTR_DATA;
  nodedbg_offset_ReqWrap__req_wrap_queue___ListNode_ReqWrapQueue =
      OffsetOf<ListNode<ReqWrapBase>, ReqWrap<uv_req_t>>(
          &ReqWrap<uv_req_t>::req_wrap_queue_);

  #define V(Class, Member, Type, Accessor)                                    \
    NODEDBG_OFFSET(Class, Member, Type) = OffsetOf(&Accessor);
    NODE_OFFSET_POSTMORTEM_METADATA(V)
  #undef V

  return 1;
}",52.0,69.0,1.0,51.0,18.0,51,6,35,23,0,14,1,1,0,0,,0,14,0,0,0,int
4171,216677,ProcessEmit,1,node.ProcessEmit,"MaybeLocal<Value> node.ProcessEmit (Environment*,char*,Local<Value>)",node_process_events.cc,"MaybeLocal<Value> ProcessEmit(Environment* env,
                              const char* event,
                              Local<Value> message) {
  Isolate* isolate = env->isolate();

  Local<String> event_string;
  if (!String::NewFromOneByte(isolate, reinterpret_cast<const uint8_t*>(event))
      .ToLocal(&event_string)) return MaybeLocal<Value>();

  Local<Object> process = env->process_object();
  Local<Value> argv[] = {event_string, message};
  return MakeCallback(isolate, process, ""emit"", arraysize(argv), argv, {0, 0});
}",21.0,33.0,1.0,1.0,13.0,16,9,20,10,0,0,2,2,0,0,,0,0,6,3,3,MaybeLocal<Value>
4172,216741,ProcessEmitWarningGeneric,1,node.ProcessEmitWarningGeneric,"Maybe<bool> node.ProcessEmitWarningGeneric (Environment*,char*,char*,char*)",node_process_events.cc,"Maybe<bool> ProcessEmitWarningGeneric(Environment* env,
                                      const char* warning,
                                      const char* type,
                                      const char* code) {
  if (!env->can_call_into_js()) return Just(false);

  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  Local<Object> process = env->process_object();
  Local<Value> emit_warning;
  if (!process->Get(env->context(), env->emit_warning_string())
           .ToLocal(&emit_warning)) {
    return Nothing<bool>();
  }

  if (!emit_warning->IsFunction()) return Just(false);

  int argc = 0;
  Local<Value> args[3];  // warning, type, code

  // The caller has to be able to handle a failure anyway, so we might as well
  // do proper error checking for string creation.
  if (!String::NewFromUtf8(env->isolate(), warning).ToLocal(&args[argc++]))
    return Nothing<bool>();

  if (type != nullptr) {
    if (!String::NewFromOneB...",35.0,83.0,1.0,1.0,49.0,52,12,41,12,0,0,9,11,0,0,,0,0,8,4,4,Maybe<bool>
4173,216933,ProcessEmitExperimentalWarning,1,node.ProcessEmitExperimentalWarning,"Maybe<bool> node.ProcessEmitExperimentalWarning (Environment*,char*)",node_process_events.cc,"Maybe<bool> ProcessEmitExperimentalWarning(Environment* env,
                                          const char* warning) {
  if (experimental_warnings.find(warning) != experimental_warnings.end())
    return Nothing<bool>();

  experimental_warnings.insert(warning);
  std::string message(warning);
  message.append("" is an experimental feature and might change at any time"");
  return ProcessEmitWarningGeneric(env, message.c_str(), ""ExperimentalWarning"");
}",88.0,97.0,1.0,1.0,10.0,6,2,9,4,0,0,2,2,0,0,,0,0,4,2,2,Maybe<bool>
4174,216974,ProcessEmitDeprecationWarning,1,node.ProcessEmitDeprecationWarning,"Maybe<bool> node.ProcessEmitDeprecationWarning (Environment*,char*,char*)",node_process_events.cc,"Maybe<bool> ProcessEmitDeprecationWarning(Environment* env,
                                          const char* warning,
                                          const char* deprecation_code) {
  return ProcessEmitWarningGeneric(
      env, warning, ""DeprecationWarning"", deprecation_code);
}",99.0,104.0,1.0,1.0,6.0,0,0,3,3,0,0,1,1,0,0,,0,0,6,3,3,Maybe<bool>
4175,217047,CauseSegfault,1,node.CauseSegfault,void node.CauseSegfault (FunctionCallbackInfo<Value>),node_process_methods.cc,"static void CauseSegfault(const FunctionCallbackInfo<Value>& args) {
  // This should crash hard all platforms.
  volatile void** d = static_cast<volatile void**>(nullptr);
  *d = nullptr;
}",72.0,76.0,1.0,1.0,5.0,4,3,2,1,0,0,1,1,0,0,,0,0,2,1,1,void
4176,217062,Chdir,1,node.Chdir,void node.Chdir (FunctionCallbackInfo<Value>),node_process_methods.cc,"static void Chdir(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  CHECK(env->owns_process_state());

  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsString());
  Utf8Value path(env->isolate(), args[0]);
  int err = uv_chdir(*path);
  if (err) {
    // Also include the original working directory, since that will usually
    // be helpful information when debugging a `chdir()` failure.
    char buf[PATH_MAX_BYTES];
    size_t cwd_len = sizeof(buf);
    uv_cwd(buf, &cwd_len);
    return env->ThrowUVException(err, ""chdir"", nullptr, buf, *path);
  }
}",78.0,94.0,1.0,1.0,17.0,15,7,19,7,0,0,2,2,0,0,,0,0,2,1,1,void
4177,217132,get_fields_array_buffer,1,node.get_fields_array_buffer,"Local<ArrayBuffer> node.get_fields_array_buffer (FunctionCallbackInfo<Value>,size_t,size_t)",node_process_methods.cc,"inline Local<ArrayBuffer> get_fields_array_buffer(
    const FunctionCallbackInfo<Value>& args,
    size_t index,
    size_t array_length) {
  CHECK(args[index]->IsFloat64Array());
  Local<Float64Array> arr = args[index].As<Float64Array>();
  CHECK_EQ(arr->Length(), array_length);
  return arr->Buffer();
}",96.0,104.0,1.0,1.0,9.0,9,6,10,6,0,0,1,1,0,0,,0,0,6,3,3,Local<ArrayBuffer>
4178,217169,CPUUsage,1,node.CPUUsage,void node.CPUUsage (FunctionCallbackInfo<Value>),node_process_methods.cc,"static void CPUUsage(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  uv_rusage_t rusage;

  // Call libuv to get the values we'll return.
  int err = uv_getrusage(&rusage);
  if (err)
    return env->ThrowUVException(err, ""uv_getrusage"");

  // Get the double array pointer from the Float64Array argument.
  Local<ArrayBuffer> ab = get_fields_array_buffer(args, 0, 2);
  double* fields = static_cast<double*>(ab->Data());

  // Set the Float64Array elements to be user / system values in microseconds.
  fields[0] = MICROS_PER_SEC * rusage.ru_utime.tv_sec + rusage.ru_utime.tv_usec;
  fields[1] = MICROS_PER_SEC * rusage.ru_stime.tv_sec + rusage.ru_stime.tv_usec;
}",111.0,127.0,1.0,14.0,17.0,27,10,20,9,0,0,2,2,0,0,,0,0,2,1,1,void
4179,217256,Cwd,1,node.Cwd,void node.Cwd (FunctionCallbackInfo<Value>),node_process_methods.cc,"static void Cwd(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  CHECK(env->has_run_bootstrapping_code());
  char buf[PATH_MAX_BYTES];
  size_t cwd_len = sizeof(buf);
  int err = uv_cwd(buf, &cwd_len);
  if (err)
    return env->ThrowUVException(err, ""uv_cwd"");

  Local<String> cwd = String::NewFromUtf8(env->isolate(),
                                          buf,
                                          NewStringType::kNormal,
                                          cwd_len).ToLocalChecked();
  args.GetReturnValue().Set(cwd);
}",129.0,143.0,1.0,1.0,15.0,17,7,22,10,0,0,2,2,0,0,,0,0,2,1,1,void
4180,217327,Kill,1,node.Kill,void node.Kill (FunctionCallbackInfo<Value>),node_process_methods.cc,"static void Kill(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Local<Context> context = env->context();

  if (args.Length() < 2) {
    THROW_ERR_MISSING_ARGS(env, ""Bad argument."");
  }

  int pid;
  if (!args[0]->Int32Value(context).To(&pid)) return;
  int sig;
  if (!args[1]->Int32Value(context).To(&sig)) return;

  uv_pid_t own_pid = uv_os_getpid();
  if (sig > 0 &&
      (pid == 0 || pid == -1 || pid == own_pid || pid == -own_pid) &&
      !HasSignalJSHandler(sig)) {
    // This is most likely going to terminate this process.
    // It's not an exact method but it might be close enough.
    RunAtExit(env);
  }

  int err = uv_kill(pid, sig);
  args.GetReturnValue().Set(err);
}",145.0,169.0,1.0,1.0,25.0,35,12,30,10,0,0,5,5,0,0,,0,0,2,1,1,void
4181,217442,Rss,1,node.Rss,void node.Rss (FunctionCallbackInfo<Value>),node_process_methods.cc,"static void Rss(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  size_t rss;
  int err = uv_resident_set_memory(&rss);
  if (err)
    return env->ThrowUVException(err, ""uv_resident_set_memory"");

  args.GetReturnValue().Set(static_cast<double>(rss));
}",171.0,180.0,1.0,1.0,10.0,8,5,10,5,0,0,2,2,0,0,,0,0,2,1,1,void
4182,217482,MemoryUsage,1,node.MemoryUsage,void node.MemoryUsage (FunctionCallbackInfo<Value>),node_process_methods.cc,"static void MemoryUsage(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  Isolate* isolate = env->isolate();
  // V8 memory usage
  HeapStatistics v8_heap_stats;
  isolate->GetHeapStatistics(&v8_heap_stats);

  NodeArrayBufferAllocator* array_buffer_allocator =
      env->isolate_data()->node_allocator();

  // Get the double array pointer from the Float64Array argument.
  Local<ArrayBuffer> ab = get_fields_array_buffer(args, 0, 5);
  double* fields = static_cast<double*>(ab->Data());

  size_t rss;
  int err = uv_resident_set_memory(&rss);
  if (err)
    return env->ThrowUVException(err, ""uv_resident_set_memory"");

  fields[0] = static_cast<double>(rss);
  fields[1] = static_cast<double>(v8_heap_stats.total_heap_size());
  fields[2] = static_cast<double>(v8_heap_stats.used_heap_size());
  fields[3] = static_cast<double>(v8_heap_stats.external_memory());
  fields[4] =
      array_buffer_allocator == nullptr
          ? 0
          : st...",182.0,210.0,1.0,1.0,29.0,39,10,31,12,0,0,2,2,0,0,,0,0,2,1,1,void
4183,217607,GetConstrainedMemory,1,node.GetConstrainedMemory,void node.GetConstrainedMemory (FunctionCallbackInfo<Value>),node_process_methods.cc,"static void GetConstrainedMemory(const FunctionCallbackInfo<Value>& args) {
  uint64_t value = uv_get_constrained_memory();
  if (value != 0) {
    args.GetReturnValue().Set(static_cast<double>(value));
  }
}",212.0,217.0,1.0,1.0,6.0,5,4,4,2,0,0,2,2,0,0,,0,0,2,1,1,void
4184,217631,RawDebug,1,node.RawDebug,void node.RawDebug (FunctionCallbackInfo<Value>),node_process_methods.cc,"void RawDebug(const FunctionCallbackInfo<Value>& args) {
  CHECK(args.Length() == 1 && args[0]->IsString() &&
        ""must be called with a single string"");
  Utf8Value message(args.GetIsolate(), args[0]);
  FPrintF(stderr, ""%s\n"", message);
  fflush(stderr);
}",219.0,225.0,1.0,1.0,7.0,8,5,6,3,0,0,1,1,0,0,,0,0,2,1,1,void
4185,217666,Umask,1,node.Umask,void node.Umask (FunctionCallbackInfo<Value>),node_process_methods.cc,"static void Umask(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  CHECK(env->has_run_bootstrapping_code());
  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsUndefined() || args[0]->IsUint32());
  Mutex::ScopedLock scoped_lock(per_process::umask_mutex);

  uint32_t old;
  if (args[0]->IsUndefined()) {
    old = umask(0);
    umask(static_cast<mode_t>(old));
  } else {
    int oct = args[0].As<Uint32>()->Value();
    old = umask(static_cast<mode_t>(oct));
  }

  args.GetReturnValue().Set(old);
}",227.0,244.0,1.0,1.0,18.0,16,6,13,5,0,0,2,2,0,0,,0,0,2,1,1,void
4186,217754,Uptime,1,node.Uptime,void node.Uptime (FunctionCallbackInfo<Value>),node_process_methods.cc,"static void Uptime(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  uv_update_time(env->event_loop());
  double uptime =
      static_cast<double>(uv_hrtime() - per_process::node_start_time);
  Local<Number> result = Number::New(env->isolate(), uptime / NANOS_PER_SEC);
  args.GetReturnValue().Set(result);
}",246.0,254.0,1.0,62.0,9.0,15,8,14,8,0,0,1,1,0,0,,0,0,2,1,1,void
4187,217809,GetActiveRequests,1,node.GetActiveRequests,void node.GetActiveRequests (FunctionCallbackInfo<Value>),node_process_methods.cc,"static void GetActiveRequests(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  std::vector<Local<Value>> request_v;
  for (ReqWrapBase* req_wrap : *env->req_wrap_queue()) {
    AsyncWrap* w = req_wrap->GetAsyncWrap();
    if (w->persistent().IsEmpty())
      continue;
    request_v.emplace_back(w->GetOwner());
  }

  args.GetReturnValue().Set(
      Array::New(env->isolate(), request_v.data(), request_v.size()));
}",256.0,269.0,1.0,1.0,14.0,20,6,18,10,0,0,4,4,0,0,,0,0,2,1,1,void
4188,217887,GetActiveHandles,1,node.GetActiveHandles,void node.GetActiveHandles (FunctionCallbackInfo<Value>),node_process_methods.cc,"void GetActiveHandles(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  std::vector<Local<Value>> handle_v;
  for (auto w : *env->handle_wrap_queue()) {
    if (!HandleWrap::HasRef(w))
      continue;
    handle_v.emplace_back(w->GetOwner());
  }
  args.GetReturnValue().Set(
      Array::New(env->isolate(), handle_v.data(), handle_v.size()));
}",273.0,284.0,1.0,1.0,12.0,18,7,17,10,0,0,4,4,0,0,,0,0,2,1,1,void
4189,217957,GetActiveResourcesInfo,1,node.GetActiveResourcesInfo,void node.GetActiveResourcesInfo (FunctionCallbackInfo<Value>),node_process_methods.cc,"static void GetActiveResourcesInfo(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  std::vector<Local<Value>> resources_info;

  // Active requests
  for (ReqWrapBase* req_wrap : *env->req_wrap_queue()) {
    AsyncWrap* w = req_wrap->GetAsyncWrap();
    if (w->persistent().IsEmpty()) continue;
    resources_info.emplace_back(
        OneByteString(env->isolate(), w->MemoryInfoName()));
  }

  // Active handles
  for (HandleWrap* w : *env->handle_wrap_queue()) {
    if (w->persistent().IsEmpty() || !HandleWrap::HasRef(w)) continue;
    resources_info.emplace_back(
        OneByteString(env->isolate(), w->MemoryInfoName()));
  }

  // Active timeouts
  resources_info.insert(resources_info.end(),
                        env->timeout_info()[0],
                        OneByteString(env->isolate(), ""Timeout""));

  // Active immediates
  resources_info.insert(resources_info.end(),
                        env->immediate_info()->ref_count(),
 ...",286.0,317.0,1.0,1.0,32.0,41,9,34,11,0,0,7,7,0,0,,0,0,2,1,1,void
4190,218119,ResourceUsage,1,node.ResourceUsage,void node.ResourceUsage (FunctionCallbackInfo<Value>),node_process_methods.cc,"static void ResourceUsage(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  uv_rusage_t rusage;
  int err = uv_getrusage(&rusage);
  if (err)
    return env->ThrowUVException(err, ""uv_getrusage"");

  Local<ArrayBuffer> ab = get_fields_array_buffer(args, 0, 16);
  double* fields = static_cast<double*>(ab->Data());

  fields[0] = MICROS_PER_SEC * rusage.ru_utime.tv_sec + rusage.ru_utime.tv_usec;
  fields[1] = MICROS_PER_SEC * rusage.ru_stime.tv_sec + rusage.ru_stime.tv_usec;
  fields[2] = static_cast<double>(rusage.ru_maxrss);
  fields[3] = static_cast<double>(rusage.ru_ixrss);
  fields[4] = static_cast<double>(rusage.ru_idrss);
  fields[5] = static_cast<double>(rusage.ru_isrss);
  fields[6] = static_cast<double>(rusage.ru_minflt);
  fields[7] = static_cast<double>(rusage.ru_majflt);
  fields[8] = static_cast<double>(rusage.ru_nswap);
  fields[9] = static_cast<double>(rusage.ru_inblock);
  fields[10] = static_cast<double>(rusage.ru_oublo...",319.0,346.0,1.0,14.0,28.0,83,10,48,9,0,0,2,2,0,0,,0,0,2,1,1,void
4191,218332,DebugEnd,1,node.DebugEnd,void node.DebugEnd (FunctionCallbackInfo<Value>),node_process_methods.cc,"static void DebugEnd(const FunctionCallbackInfo<Value>& args) {
#if HAVE_INSPECTOR
  Environment* env = Environment::GetCurrent(args);
  if (env->inspector_agent()->IsListening()) {
    env->inspector_agent()->Stop();
  }
#endif
}",447.0,454.0,1.0,1.0,8.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
4192,218337,ReallyExit,1,node.ReallyExit,void node.ReallyExit (FunctionCallbackInfo<Value>),node_process_methods.cc,"static void ReallyExit(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  RunAtExit(env);
  ExitCode code = ExitCode::kNoFailure;
  Maybe<int32_t> code_int = args[0]->Int32Value(env->context());
  if (!code_int.IsNothing()) {
    code = static_cast<ExitCode>(code_int.FromJust());
  }
  env->Exit(code);
}",456.0,465.0,1.0,1.0,10.0,16,8,16,8,0,0,2,2,0,0,,0,0,2,1,1,void
4193,218395,BindingData,1,node.process.BindingData.BindingData,"ANY node.process.BindingData.BindingData (Realm*,ANY)",node_process_methods.cc,"BindingData::BindingData(Realm* realm, v8::Local<v8::Object> object)
    : SnapshotableObject(realm, object, type_int) {
  Isolate* isolate = realm->isolate();
  Local<Context> context = realm->context();
  Local<ArrayBuffer> ab = ArrayBuffer::New(isolate, kBufferSize);
  array_buffer_.Reset(isolate, ab);
  object->Set(context, FIXED_ONE_BYTE_STRING(isolate, ""hrtimeBuffer""), ab)
      .ToChecked();
  backing_store_ = ab->GetBackingStore();
}",469.0,478.0,1.0,1.0,10.0,15,5,21,11,0,0,1,1,0,0,,0,0,4,2,2,ANY
4194,218454,fast_number_,1,node.process.fast_number_,ANY node.process.fast_number_ (ANY),node_process_methods.cc,v8::CFunction BindingData::fast_number_(v8::CFunction::Make(FastNumber));,480.0,480.0,15.0,72.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
4195,218459,fast_bigint_,1,node.process.fast_bigint_,ANY node.process.fast_bigint_ (ANY),node_process_methods.cc,v8::CFunction BindingData::fast_bigint_(v8::CFunction::Make(FastBigInt));,481.0,481.0,15.0,72.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
4196,218464,AddMethods,1,node.process.BindingData.AddMethods,"void node.process.BindingData.AddMethods (Isolate*,Local<ObjectTemplate>)",node_process_methods.cc,"void BindingData::AddMethods(Isolate* isolate, Local<ObjectTemplate> target) {
  SetFastMethodNoSideEffect(
      isolate, target, ""hrtime"", SlowNumber, &fast_number_);
  SetFastMethodNoSideEffect(
      isolate, target, ""hrtimeBigInt"", SlowBigInt, &fast_bigint_);
}",483.0,488.0,1.0,1.0,6.0,2,1,8,6,0,0,1,1,0,0,,0,0,4,2,2,void
4197,218484,RegisterExternalReferences,1,node.process.BindingData.RegisterExternalReferences,void node.process.BindingData.RegisterExternalReferences (ExternalReferenceRegistry*),node_process_methods.cc,"void BindingData::RegisterExternalReferences(
    ExternalReferenceRegistry* registry) {
  registry->Register(SlowNumber);
  registry->Register(SlowBigInt);
  registry->Register(FastNumber);
  registry->Register(FastBigInt);
  registry->Register(fast_number_.GetTypeInfo());
  registry->Register(fast_bigint_.GetTypeInfo());
}",490.0,498.0,1.0,1.0,9.0,8,2,12,7,0,0,1,1,0,0,,0,0,2,1,1,void
4198,218525,FromV8Value,1,node.process.BindingData.FromV8Value,BindingData node.process.BindingData.FromV8Value (Local<Value>),node_process_methods.cc,"BindingData* BindingData::FromV8Value(Local<Value> value) {
  Local<Object> v8_object = value.As<Object>();
  return static_cast<BindingData*>(
      v8_object->GetAlignedPointerFromInternalField(BaseObject::kSlot));
}",500.0,504.0,1.0,1.0,5.0,7,6,6,5,0,0,1,1,0,0,,0,0,2,1,1,BindingData
4199,218550,MemoryInfo,1,node.process.BindingData.MemoryInfo,void node.process.BindingData.MemoryInfo (MemoryTracker*),node_process_methods.cc,"void BindingData::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackField(""array_buffer"", array_buffer_);
}",506.0,508.0,1.0,1.0,3.0,1,1,2,2,0,0,1,1,0,0,,0,0,2,1,1,void
4200,218561,NumberImpl,1,node.process.BindingData.NumberImpl,void node.process.BindingData.NumberImpl (BindingData*),node_process_methods.cc,"void BindingData::NumberImpl(BindingData* receiver) {
  // Make sure we don't accidentally access buffers wiped for snapshot.
  CHECK(!receiver->array_buffer_.IsEmpty());
  uint64_t t = uv_hrtime();
  uint32_t* fields = static_cast<uint32_t*>(receiver->backing_store_->Data());
  fields[0] = (t / NANOS_PER_SEC) >> 32;
  fields[1] = (t / NANOS_PER_SEC) & 0xffffffff;
  fields[2] = t % NANOS_PER_SEC;
}",519.0,527.0,1.0,19.0,9.0,19,10,10,3,0,0,1,1,0,0,,0,0,2,1,1,void
4201,218620,BigIntImpl,1,node.process.BindingData.BigIntImpl,void node.process.BindingData.BigIntImpl (BindingData*),node_process_methods.cc,"void BindingData::BigIntImpl(BindingData* receiver) {
  // Make sure we don't accidentally access buffers wiped for snapshot.
  CHECK(!receiver->array_buffer_.IsEmpty());
  uint64_t t = uv_hrtime();
  uint64_t* fields = static_cast<uint64_t*>(receiver->backing_store_->Data());
  fields[0] = t;
}",529.0,535.0,1.0,1.0,7.0,10,6,6,3,0,0,1,1,0,0,,0,0,2,1,1,void
4202,218653,SlowBigInt,1,node.process.BindingData.SlowBigInt,void node.process.BindingData.SlowBigInt (FunctionCallbackInfo<Value>),node_process_methods.cc,"void BindingData::SlowBigInt(const FunctionCallbackInfo<Value>& args) {
  BigIntImpl(FromJSObject<BindingData>(args.Holder()));
}",537.0,539.0,1.0,1.0,3.0,3,3,3,3,0,0,1,1,0,0,,0,0,2,1,1,void
4203,218667,SlowNumber,1,node.process.BindingData.SlowNumber,void node.process.BindingData.SlowNumber (ANY),node_process_methods.cc,"void BindingData::SlowNumber(const v8::FunctionCallbackInfo<v8::Value>& args) {
  NumberImpl(FromJSObject<BindingData>(args.Holder()));
}",541.0,543.0,1.0,1.0,3.0,3,3,3,3,0,0,1,1,0,0,,0,0,2,1,1,void
4204,218681,PrepareForSerialization,1,node.process.BindingData.PrepareForSerialization,"bool node.process.BindingData.PrepareForSerialization (Local<Context>,ANY*)",node_process_methods.cc,"bool BindingData::PrepareForSerialization(Local<Context> context,
                                          v8::SnapshotCreator* creator) {
  // It's not worth keeping.
  // Release it, we will recreate it when the instance is dehydrated.
  array_buffer_.Reset();
  // Return true because we need to maintain the reference to the binding from
  // JS land.
  return true;
}",545.0,553.0,1.0,1.0,9.0,1,1,1,1,0,0,1,1,0,0,,0,0,4,2,2,bool
4205,218693,Serialize,1,node.process.BindingData.Serialize,InternalFieldInfoBase node.process.BindingData.Serialize (int),node_process_methods.cc,"InternalFieldInfoBase* BindingData::Serialize(int index) {
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  InternalFieldInfo* info =
      InternalFieldInfoBase::New<InternalFieldInfo>(type());
  return info;
}",555.0,560.0,1.0,1.0,6.0,5,4,6,5,0,0,1,1,0,0,,0,0,2,1,1,InternalFieldInfoBase
4206,218715,Deserialize,1,node.process.BindingData.Deserialize,"void node.process.BindingData.Deserialize (Local<Context>,Local<Object>,int,InternalFieldInfoBase*)",node_process_methods.cc,"void BindingData::Deserialize(Local<Context> context,
                              Local<Object> holder,
                              int index,
                              InternalFieldInfoBase* info) {
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  v8::HandleScope scope(context->GetIsolate());
  Realm* realm = Realm::GetCurrent(context);
  // Recreate the buffer in the constructor.
  BindingData* binding = realm->AddBindingData<BindingData>(context, holder);
  CHECK_NOT_NULL(binding);
}",562.0,572.0,1.0,1.0,11.0,10,7,12,8,0,0,1,1,0,0,,0,0,8,4,4,void
4207,218757,CreatePerIsolateProperties,1,node.process.CreatePerIsolateProperties,"void node.process.CreatePerIsolateProperties (IsolateData*,Local<FunctionTemplate>)",node_process_methods.cc,"static void CreatePerIsolateProperties(IsolateData* isolate_data,
                                       Local<FunctionTemplate> ctor) {
  Isolate* isolate = isolate_data->isolate();
  Local<ObjectTemplate> target = ctor->InstanceTemplate();

  BindingData::AddMethods(isolate, target);
  // define various internal methods
  SetMethod(isolate, target, ""_debugProcess"", DebugProcess);
  SetMethod(isolate, target, ""abort"", Abort);
  SetMethod(isolate, target, ""causeSegfault"", CauseSegfault);
  SetMethod(isolate, target, ""chdir"", Chdir);

  SetMethod(isolate, target, ""umask"", Umask);
  SetMethod(isolate, target, ""memoryUsage"", MemoryUsage);
  SetMethod(isolate, target, ""constrainedMemory"", GetConstrainedMemory);
  SetMethod(isolate, target, ""rss"", Rss);
  SetMethod(isolate, target, ""cpuUsage"", CPUUsage);
  SetMethod(isolate, target, ""resourceUsage"", ResourceUsage);

  SetMethod(isolate, target, ""_debugEnd"", DebugEnd);
  SetMethod(isolate, target, ""_getActiveRequests"", GetActiveRequests);...",574.0,605.0,1.0,1.0,32.0,8,5,54,10,0,0,1,1,0,0,,0,0,4,2,2,void
4208,218893,CreatePerContextProperties,1,node.process.CreatePerContextProperties,"void node.process.CreatePerContextProperties (Local<Object>,Local<Value>,Local<Context>,void*)",node_process_methods.cc,"static void CreatePerContextProperties(Local<Object> target,
                                       Local<Value> unused,
                                       Local<Context> context,
                                       void* priv) {
  Realm* realm = Realm::GetCurrent(context);
  realm->AddBindingData<BindingData>(context, target);
}",607.0,613.0,1.0,1.0,7.0,7,7,7,5,0,0,1,1,0,0,,0,0,8,4,4,void
4209,218919,RegisterExternalReferences,1,node.process.RegisterExternalReferences,void node.process.RegisterExternalReferences (ExternalReferenceRegistry*),node_process_methods.cc,"void RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  BindingData::RegisterExternalReferences(registry);

  registry->Register(DebugProcess);
  registry->Register(DebugEnd);
  registry->Register(Abort);
  registry->Register(CauseSegfault);
  registry->Register(Chdir);

  registry->Register(Umask);
  registry->Register(RawDebug);
  registry->Register(MemoryUsage);
  registry->Register(GetConstrainedMemory);
  registry->Register(Rss);
  registry->Register(CPUUsage);
  registry->Register(ResourceUsage);

  registry->Register(GetActiveRequests);
  registry->Register(GetActiveHandles);
  registry->Register(GetActiveResourcesInfo);
  registry->Register(Kill);

  registry->Register(Cwd);
  registry->Register(binding::DLOpen);
  registry->Register(ReallyExit);
  registry->Register(Uptime);
  registry->Register(PatchProcessObject);
}",615.0,642.0,1.0,1.0,28.0,23,2,26,5,0,0,1,1,0,0,,0,0,2,1,1,void
4210,219038,<lambda>0,1,node.CreateProcessObject.<lambda>0,"ANY node.CreateProcessObject.<lambda>0 (auto,auto)",node_process_object.cc,"[](auto& a, auto& b) { return a.first < b.first; }",129.0,129.0,13.0,62.0,1.0,3,2,2,2,0,0,1,1,0,0,,0,0,4,2,2,ANY
4211,219080,ProcessTitleGetter,1,node.ProcessTitleGetter,"void node.ProcessTitleGetter (Local<Name>,PropertyCallbackInfo<Value>)",node_process_object.cc,"static void ProcessTitleGetter(Local<Name> property,
                               const PropertyCallbackInfo<Value>& info) {
  std::string title = GetProcessTitle(""node"");
  info.GetReturnValue().Set(
      String::NewFromUtf8(info.GetIsolate(), title.data(),
                          NewStringType::kNormal, title.size())
      .ToLocalChecked());
}",34.0,41.0,1.0,1.0,8.0,9,2,7,4,0,0,1,1,0,0,,0,0,4,2,2,void
4212,219120,ProcessTitleSetter,1,node.ProcessTitleSetter,"void node.ProcessTitleSetter (Local<Name>,Local<Value>,PropertyCallbackInfo<void>)",node_process_object.cc,"static void ProcessTitleSetter(Local<Name> property,
                               Local<Value> value,
                               const PropertyCallbackInfo<void>& info) {
  node::Utf8Value title(info.GetIsolate(), value);
  TRACE_EVENT_METADATA1(
      ""__metadata"", ""process_name"", ""name"", TRACE_STR_COPY(*title));
  uv_set_process_title(*title);
}",43.0,50.0,1.0,1.0,8.0,3,2,4,3,0,0,1,1,0,0,,0,0,6,3,3,void
4213,219144,DebugPortGetter,1,node.DebugPortGetter,"void node.DebugPortGetter (Local<Name>,PropertyCallbackInfo<Value>)",node_process_object.cc,"static void DebugPortGetter(Local<Name> property,
                            const PropertyCallbackInfo<Value>& info) {
  Environment* env = Environment::GetCurrent(info);
  ExclusiveAccess<HostPort>::Scoped host_port(env->inspector_host_port());
  int port = host_port->port();
  info.GetReturnValue().Set(port);
}",52.0,58.0,1.0,1.0,7.0,7,3,8,5,0,0,1,1,0,0,,0,0,4,2,2,void
4214,219179,DebugPortSetter,1,node.DebugPortSetter,"void node.DebugPortSetter (Local<Name>,Local<Value>,PropertyCallbackInfo<void>)",node_process_object.cc,"static void DebugPortSetter(Local<Name> property,
                            Local<Value> value,
                            const PropertyCallbackInfo<void>& info) {
  Environment* env = Environment::GetCurrent(info);
  int32_t port = value->Int32Value(env->context()).FromMaybe(0);

  if ((port != 0 && port < 1024) || port > 65535) {
    return THROW_ERR_OUT_OF_RANGE(
      env,
      ""process.debugPort must be 0 or in range 1024 to 65535"");
  }

  ExclusiveAccess<HostPort>::Scoped host_port(env->inspector_host_port());
  host_port->set_port(static_cast<int>(port));
}",60.0,74.0,1.0,1.0,15.0,14,9,13,6,0,0,2,2,0,0,,0,0,6,3,3,void
4215,219239,GetParentProcessId,1,node.GetParentProcessId,"void node.GetParentProcessId (Local<Name>,PropertyCallbackInfo<Value>)",node_process_object.cc,"static void GetParentProcessId(Local<Name> property,
                               const PropertyCallbackInfo<Value>& info) {
  info.GetReturnValue().Set(uv_os_getppid());
}",76.0,79.0,1.0,1.0,4.0,2,1,1,1,0,0,1,1,0,0,,0,0,4,2,2,void
4216,219253,CreateProcessObject,1,node.CreateProcessObject,MaybeLocal<Object> node.CreateProcessObject (Realm*),node_process_object.cc,"MaybeLocal<Object> CreateProcessObject(Realm* realm) {
  Isolate* isolate = realm->isolate();
  EscapableHandleScope scope(isolate);
  Local<Context> context = realm->context();

  Local<FunctionTemplate> process_template = FunctionTemplate::New(isolate);
  process_template->SetClassName(realm->env()->process_string());
  Local<Function> process_ctor;
  Local<Object> process;
  if (!process_template->GetFunction(context).ToLocal(&process_ctor) ||
      !process_ctor->NewInstance(context).ToLocal(&process)) {
    return MaybeLocal<Object>();
  }

  // process[exit_info_private_symbol]
  if (process
          ->SetPrivate(context,
                       realm->env()->exit_info_private_symbol(),
                       realm->env()->exit_info().GetJSArray())
          .IsNothing()) {
    return {};
  }

  // process.version
  READONLY_PROPERTY(
      process, ""version"", FIXED_ONE_BYTE_STRING(isolate, NODE_VERSION));

  Local<Object> versions = Object::New(isolate);
  // Node.js version ...",81.0,175.0,1.0,1.0,95.0,78,10,81,23,1,0,4,4,0,0,,0,0,2,1,1,MaybeLocal<Object>
4217,219530,PatchProcessObject,1,node.PatchProcessObject,void node.PatchProcessObject (FunctionCallbackInfo<Value>),node_process_object.cc,"void PatchProcessObject(const FunctionCallbackInfo<Value>& args) {
  Isolate* isolate = args.GetIsolate();
  Local<Context> context = isolate->GetCurrentContext();
  Environment* env = Environment::GetCurrent(context);
  CHECK(args[0]->IsObject());
  Local<Object> process = args[0].As<Object>();

  // process.title
  CHECK(process
            ->SetAccessor(
                context,
                FIXED_ONE_BYTE_STRING(isolate, ""title""),
                ProcessTitleGetter,
                env->owns_process_state() ? ProcessTitleSetter : nullptr,
                Local<Value>(),
                DEFAULT,
                None,
                SideEffectType::kHasNoSideEffect)
            .FromJust());

  // process.argv
  process->Set(context,
               FIXED_ONE_BYTE_STRING(isolate, ""argv""),
               ToV8Value(context, env->argv()).ToLocalChecked()).Check();

  // process.execArgv
  process->Set(context,
               FIXED_ONE_BYTE_STRING(isolate, ""execArgv""),
            ...",177.0,244.0,1.0,1.0,68.0,44,7,49,15,0,0,1,1,0,0,,0,0,2,1,1,void
4218,219726,RegisterProcessExternalReferences,1,node.RegisterProcessExternalReferences,void node.RegisterProcessExternalReferences (ExternalReferenceRegistry*),node_process_object.cc,"void RegisterProcessExternalReferences(ExternalReferenceRegistry* registry) {
  registry->Register(RawDebug);
  registry->Register(GetParentProcessId);
  registry->Register(DebugPortSetter);
  registry->Register(DebugPortGetter);
  registry->Register(ProcessTitleSetter);
  registry->Register(ProcessTitleGetter);
}",246.0,253.0,1.0,1.0,8.0,6,1,7,2,0,0,1,1,0,0,,0,0,2,1,1,void
4219,219772,<lambda>0,1,node.Realm.PrintInfoForSnapshot.<lambda>0,ANY node.Realm.PrintInfoForSnapshot.<lambda>0 (BaseObject*),node_realm.cc,"[&](BaseObject* obj) {
    std::cout << ""#"" << i++ << "" "" << obj << "": "" << obj->MemoryInfoName()
              << ""\n"";
  }",224.0,227.0,21.0,3.0,4.0,10,4,4,3,0,0,1,1,0,0,,0,0,2,1,1,ANY
4220,219801,<lambda>1,1,node.Realm.VerifyNoStrongBaseObjects.<lambda>1,ANY node.Realm.VerifyNoStrongBaseObjects.<lambda>1 (BaseObject*),node_realm.cc,"[](BaseObject* obj) {
    if (obj->IsNotIndicativeOfMemoryLeakAtExit()) return;
    fprintf(stderr,
            ""Found bad BaseObject during clean exit: %s\n"",
            obj->MemoryInfoName());
    fflush(stderr);
    ABORT();
  }",267.0,274.0,21.0,3.0,8.0,2,1,3,2,0,0,2,2,0,0,,0,0,2,1,1,ANY
4221,219839,Realm,1,node.Realm.Realm,"ANY node.Realm.Realm (Environment*,ANY,Kind)",node_realm.cc,"Realm::Realm(Environment* env, v8::Local<v8::Context> context, Kind kind)
    : env_(env), isolate_(context->GetIsolate()), kind_(kind) {
  context_.Reset(isolate_, context);
}",21.0,24.0,1.0,1.0,4.0,1,1,3,3,0,0,1,1,0,0,,0,0,6,3,3,ANY
4222,219852,~Realm,1,node.Realm.~Realm,ANY node.Realm.~Realm (),node_realm.cc,"Realm::~Realm() {
  CHECK_EQ(base_object_count_, 0);
}",26.0,28.0,1.0,1.0,3.0,0,0,1,1,0,0,1,1,0,0,,0,0,0,0,0,ANY
4223,219859,MemoryInfo,1,node.Realm.MemoryInfo,void node.Realm.MemoryInfo (MemoryTracker*),node_realm.cc,"void Realm::MemoryInfo(MemoryTracker* tracker) const {
#define V(PropertyName, TypeName)                                              \
  tracker->TrackField(#PropertyName, PropertyName());
  PER_REALM_STRONG_PERSISTENT_VALUES(V)
#undef V

  tracker->TrackField(""cleanup_queue"", cleanup_queue_);
  tracker->TrackField(""builtins_with_cache"", builtins_with_cache);
  tracker->TrackField(""builtins_without_cache"", builtins_without_cache);
}",30.0,39.0,1.0,1.0,10.0,3,1,6,4,0,0,1,1,0,0,,0,0,2,1,1,void
4224,219884,CreateProperties,1,node.Realm.CreateProperties,void node.Realm.CreateProperties (),node_realm.cc,"void Realm::CreateProperties() {
  HandleScope handle_scope(isolate_);
  Local<Context> ctx = context();

  // Store primordials setup by the per-context script in the environment.
  Local<Object> per_context_bindings =
      GetPerContextExports(ctx).ToLocalChecked();
  Local<Value> primordials =
      per_context_bindings->Get(ctx, env_->primordials_string())
          .ToLocalChecked();
  CHECK(primordials->IsObject());
  set_primordials(primordials.As<Object>());

  Local<String> prototype_string =
      FIXED_ONE_BYTE_STRING(isolate(), ""prototype"");

#define V(EnvPropertyName, PrimordialsPropertyName)                            \
  {                                                                            \
    Local<Value> ctor =                                                        \
        primordials.As<Object>()                                               \
            ->Get(ctx,                                                         \
                  FIXED_ONE_BY...",41.0,83.0,1.0,2.0,43.0,83,5,79,15,0,1,1,1,0,1,,0,1,0,0,0,void
4225,220186,Serialize,1,node.Realm.Serialize,RealmSerializeInfo node.Realm.Serialize (SnapshotCreator*),node_realm.cc,"RealmSerializeInfo Realm::Serialize(SnapshotCreator* creator) {
  RealmSerializeInfo info;
  Local<Context> ctx = context();

  // Currently all modules are compiled without cache in builtin snapshot
  // builder.
  info.builtins = std::vector<std::string>(builtins_without_cache.begin(),
                                           builtins_without_cache.end());

  uint32_t id = 0;
#define V(PropertyName, TypeName)                                              \
  do {                                                                         \
    Local<TypeName> field = PropertyName();                                    \
    if (!field.IsEmpty()) {                                                    \
      size_t index = creator->AddData(ctx, field);                             \
      info.persistent_values.push_back({#PropertyName, id, index});            \
    }                                                                          \
    id++;                                      ...",85.0,113.0,1.0,1.0,29.0,18,8,16,8,0,0,1,1,0,0,,0,0,2,1,1,RealmSerializeInfo
4226,220244,DeserializeProperties,1,node.Realm.DeserializeProperties,void node.Realm.DeserializeProperties (RealmSerializeInfo*),node_realm.cc,"void Realm::DeserializeProperties(const RealmSerializeInfo* info) {
  Local<Context> ctx = context();

  builtins_in_snapshot = info->builtins;

  const std::vector<PropInfo>& values = info->persistent_values;
  size_t i = 0;  // index to the array
  uint32_t id = 0;
#define V(PropertyName, TypeName)                                              \
  do {                                                                         \
    if (values.size() > i && id == values[i].id) {                             \
      const PropInfo& d = values[i];                                           \
      DCHECK_EQ(d.name, #PropertyName);                                        \
      MaybeLocal<TypeName> maybe_field =                                       \
          ctx->GetDataFromSnapshotOnce<TypeName>(d.index);                     \
      Local<TypeName> field;                                                   \
      if (!maybe_field.ToLocal(&field)) {                                      \
...",115.0,154.0,1.0,1.0,40.0,21,7,23,12,0,0,2,2,0,0,,0,0,2,1,1,void
4227,220312,ExecuteBootstrapper,1,node.Realm.ExecuteBootstrapper,MaybeLocal<Value> node.Realm.ExecuteBootstrapper (char*),node_realm.cc,"MaybeLocal<Value> Realm::ExecuteBootstrapper(const char* id) {
  EscapableHandleScope scope(isolate());
  Local<Context> ctx = context();
  MaybeLocal<Value> result =
      env()->builtin_loader()->CompileAndCall(ctx, id, this);

  // If there was an error during bootstrap, it must be unrecoverable
  // (e.g. max call stack exceeded). Clear the stack so that the
  // AsyncCallbackScope destructor doesn't fail on the id check.
  // There are only two ways to have a stack size > 1: 1) the user manually
  // called MakeCallback or 2) user awaited during bootstrap, which triggered
  // _tickCallback().
  if (result.IsEmpty()) {
    env()->async_hooks()->clear_async_id_stack();
  }

  return scope.EscapeMaybe(result);
}",156.0,173.0,1.0,1.0,18.0,12,5,11,8,0,0,2,2,0,0,,0,0,2,1,1,MaybeLocal<Value>
4228,220362,RunBootstrapping,1,node.Realm.RunBootstrapping,MaybeLocal<Value> node.Realm.RunBootstrapping (),node_realm.cc,"MaybeLocal<Value> Realm::RunBootstrapping() {
  EscapableHandleScope scope(isolate_);

  CHECK(!has_run_bootstrapping_code());

  Local<Value> result;
  if (!ExecuteBootstrapper(""internal/bootstrap/realm"").ToLocal(&result) ||
      !BootstrapRealm().ToLocal(&result)) {
    return MaybeLocal<Value>();
  }

  DoneBootstrapping();

  return scope.Escape(result);
}",175.0,189.0,1.0,1.0,15.0,11,6,8,5,0,0,2,2,0,0,,0,0,0,0,0,MaybeLocal<Value>
4229,220404,DoneBootstrapping,1,node.Realm.DoneBootstrapping,void node.Realm.DoneBootstrapping (),node_realm.cc,"void Realm::DoneBootstrapping() {
  // Make sure that no request or handle is created during bootstrap -
  // if necessary those should be done in pre-execution.
  // Usually, doing so would trigger the checks present in the ReqWrap and
  // HandleWrap classes, so this is only a consistency check.

  // TODO(legendecas): track req_wrap and handle_wrap by realms instead of
  // environments.
  if (kind_ == kPrincipal) {
    CHECK(env_->req_wrap_queue()->IsEmpty());
    CHECK(env_->handle_wrap_queue()->IsEmpty());
  }

  has_run_bootstrapping_code_ = true;

  // This adjusts the return value of base_object_created_after_bootstrap() so
  // that tests that check the count do not have to account for internally
  // created BaseObjects.
  base_object_created_by_bootstrap_ = base_object_count_;
}",191.0,210.0,1.0,1.0,20.0,7,3,7,6,0,0,2,2,0,0,,0,0,0,0,0,void
4230,220435,RunCleanup,1,node.Realm.RunCleanup,void node.Realm.RunCleanup (),node_realm.cc,"void Realm::RunCleanup() {
  TRACE_EVENT0(TRACING_CATEGORY_NODE1(realm), ""RunCleanup"");
  for (size_t i = 0; i < binding_data_store_.size(); ++i) {
    binding_data_store_[i].reset();
  }
  cleanup_queue_.Drain();
}",212.0,218.0,1.0,1.0,7.0,6,4,7,4,0,0,2,2,0,0,,0,0,0,0,0,void
4231,220468,PrintInfoForSnapshot,1,node.Realm.PrintInfoForSnapshot,void node.Realm.PrintInfoForSnapshot (),node_realm.cc,"void Realm::PrintInfoForSnapshot() {
  fprintf(stderr, ""Realm = %p\n"", this);
  fprintf(stderr, ""BaseObjects of the Realm:\n"");
  size_t i = 0;
  ForEachBaseObject([&](BaseObject* obj) {
    std::cout << ""#"" << i++ << "" "" << obj << "": "" << obj->MemoryInfoName()
              << ""\n"";
  });

  fprintf(stderr, ""\nBuiltins without cache:\n"");
  for (const auto& s : builtins_without_cache) {
    fprintf(stderr, ""%s\n"", s.c_str());
  }
  fprintf(stderr, ""\nBuiltins with cache:\n"");
  for (const auto& s : builtins_with_cache) {
    fprintf(stderr, ""%s\n"", s.c_str());
  }
  fprintf(stderr, ""\nStatic bindings (need to be registered):\n"");
  for (const auto mod : internal_bindings) {
    fprintf(stderr, ""%s:%s\n"", mod->nm_filename, mod->nm_modname);
  }

  fprintf(stderr, ""End of the Realm.\n"");
}",220.0,243.0,1.0,1.0,24.0,5,3,17,7,0,0,4,4,0,0,,0,0,0,0,0,void
4232,220531,VerifyNoStrongBaseObjects,1,node.Realm.VerifyNoStrongBaseObjects,void node.Realm.VerifyNoStrongBaseObjects (),node_realm.cc,"void Realm::VerifyNoStrongBaseObjects() {
  // When a process exits cleanly, i.e. because the event loop ends up without
  // things to wait for, the Node.js objects that are left on the heap should
  // be:
  //
  //   1. weak, i.e. ready for garbage collection once no longer referenced, or
  //   2. detached, i.e. scheduled for destruction once no longer referenced, or
  //   3. an unrefed libuv handle, i.e. does not keep the event loop alive, or
  //   4. an inactive libuv handle (essentially the same here)
  //
  // There are a few exceptions to this rule, but generally, if there are
  // C++-backed Node.js objects on the heap that do not fall into the above
  // categories, we may be looking at a potential memory leak. Most likely,
  // the cause is a missing MakeWeak() call on the corresponding object.
  //
  // In order to avoid this kind of problem, we check the list of BaseObjects
  // for these criteria. Currently, we only do so when explicitly instructed to
  // or when i...",245.0,275.0,1.0,1.0,31.0,3,2,0,0,0,0,2,2,0,0,,0,0,0,0,0,void
4233,220547,context,1,node.Realm.context,Local<v8::Context> node.Realm.context (),node_realm.cc,"v8::Local<v8::Context> Realm::context() const {
  return PersistentToLocal::Strong(context_);
}",277.0,279.0,1.0,1.0,3.0,1,1,2,2,0,0,1,1,0,0,,0,0,0,0,0,Local<v8.Context>
4234,220559,PrincipalRealm,1,node.PrincipalRealm.PrincipalRealm,"ANY node.PrincipalRealm.PrincipalRealm (Environment*,ANY,RealmSerializeInfo*)",node_realm.cc,"PrincipalRealm::PrincipalRealm(Environment* env,
                               v8::Local<v8::Context> context,
                               const RealmSerializeInfo* realm_info)
    : Realm(env, context, kPrincipal) {
  // Create properties if not deserializing from snapshot.
  // Or the properties are deserialized with DeserializeProperties() when the
  // env drained the deserialize requests.
  if (realm_info == nullptr) {
    CreateProperties();
  }
}",291.0,301.0,1.0,1.0,11.0,1,1,1,1,0,0,2,2,0,0,,0,0,6,3,3,ANY
4235,220572,BootstrapRealm,1,node.PrincipalRealm.BootstrapRealm,MaybeLocal<Value> node.PrincipalRealm.BootstrapRealm (),node_realm.cc,"MaybeLocal<Value> PrincipalRealm::BootstrapRealm() {
  HandleScope scope(isolate_);

  if (ExecuteBootstrapper(""internal/bootstrap/node"").IsEmpty()) {
    return MaybeLocal<Value>();
  }

  if (!env_->no_browser_globals()) {
    if (ExecuteBootstrapper(""internal/bootstrap/web/exposed-wildcard"")
            .IsEmpty() ||
        ExecuteBootstrapper(""internal/bootstrap/web/exposed-window-or-worker"")
            .IsEmpty()) {
      return MaybeLocal<Value>();
    }
  }

  // TODO(joyeecheung): skip these in the snapshot building for workers.
  auto thread_switch_id =
      env_->is_main_thread() ? ""internal/bootstrap/switches/is_main_thread""
                             : ""internal/bootstrap/switches/is_not_main_thread"";
  if (ExecuteBootstrapper(thread_switch_id).IsEmpty()) {
    return MaybeLocal<Value>();
  }

  auto process_state_switch_id =
      env_->owns_process_state()
          ? ""internal/bootstrap/switches/does_own_process_state""
          : ""internal/bootstrap/switches/doe...",303.0,344.0,1.0,1.0,42.0,29,9,23,10,0,0,7,8,0,0,,0,0,0,0,0,MaybeLocal<Value>
4236,220721,<lambda>1,1,node.report.WriteNodeReport..<lambda>1,ANY node.report.WriteNodeReport..<lambda>1 (Environment*),node_report.cc,"[&](Environment* env) {
        std::ostringstream os;

        GetNodeReport(
            env, ""Worker thread subreport"", trigger, Local<Value>(), os);

        Mutex::ScopedLock lock(workers_mutex);
        worker_infos.emplace_back(os.str());
        notify.Signal(lock);
      }",222.0,231.0,47.0,7.0,10.0,3,1,8,7,0,0,1,1,0,0,,0,0,2,1,1,ANY
4237,220755,<lambda>0,1,node.report.WriteNodeReport.<lambda>0,ANY node.report.WriteNodeReport.<lambda>0 (Worker*),node_report.cc,"[&](Worker* w) {
      expected_results += w->RequestInterrupt([&](Environment* env) {
        std::ostringstream os;

        GetNodeReport(
            env, ""Worker thread subreport"", trigger, Local<Value>(), os);

        Mutex::ScopedLock lock(workers_mutex);
        worker_infos.emplace_back(os.str());
        notify.Signal(lock);
      });
    }",221.0,232.0,24.0,5.0,12.0,2,2,2,2,0,0,1,1,0,0,,0,0,2,1,1,ANY
4238,220769,<lambda>2,1,node.report.PrintJavaScriptErrorStack.<lambda>2,ANY node.report.PrintJavaScriptErrorStack.<lambda>2 (int),node_report.cc,"[](int ch) {
                return !std::iswspace(ch);
              }",532.0,534.0,59.0,15.0,3.0,2,2,2,2,0,0,1,1,0,0,,0,0,2,1,1,ANY
4239,220782,<lambda>3,1,node.report.PrintComponentVersions.<lambda>3,"ANY node.report.PrintComponentVersions.<lambda>3 (auto,auto)",node_report.cc,"[](auto& a, auto& b) { return a.first < b.first; }",811.0,811.0,13.0,62.0,1.0,3,2,2,2,0,0,1,1,0,0,,0,0,4,2,2,ANY
4240,220860,WriteNodeReport,1,node.report.WriteNodeReport,"void node.report.WriteNodeReport (Isolate*,Environment*,char*,char*,ANY,ANY,Local<Value>,bool)",node_report.cc,"static void WriteNodeReport(Isolate* isolate,
                            Environment* env,
                            const char* message,
                            const char* trigger,
                            const std::string& filename,
                            std::ostream& out,
                            Local<Value> error,
                            bool compact) {
  // Obtain the current time and the pid.
  TIME_TYPE tm_struct;
  DiagnosticFilename::LocalTime(&tm_struct);
  uv_pid_t pid = uv_os_getpid();

  // Save formatting for output stream.
  std::ios old_state(nullptr);
  old_state.copyfmt(out);

  // File stream opened OK, now start printing the report content:
  // the title and header information (event, filename, timestamp and pid)

  JSONWriter writer(out, compact);
  writer.json_start();
  writer.json_objectstart(""header"");
  writer.json_keyvalue(""reportVersion"", NODE_REPORT_VERSION);
  writer.json_keyvalue(""event"", message);
  writer.json_keyvalue(""tri...",87.0,250.0,1.0,1.0,164.0,0,0,0,0,0,0,1,1,0,0,,0,0,16,8,8,void
4241,220872,PrintVersionInformation,1,node.report.PrintVersionInformation,void node.report.PrintVersionInformation (JSONWriter*),node_report.cc,"static void PrintVersionInformation(JSONWriter* writer) {
  std::ostringstream buf;
  // Report Node version
  buf << ""v"" << NODE_VERSION_STRING;
  writer->json_keyvalue(""nodejsVersion"", buf.str());
  buf.str("""");

#ifndef _WIN32
  // Report compiler and runtime glibc versions where possible.
  const char* (*libc_version)();
  *(reinterpret_cast<void**>(&libc_version)) =
      dlsym(RTLD_DEFAULT, ""gnu_get_libc_version"");
  if (libc_version != nullptr)
    writer->json_keyvalue(""glibcVersionRuntime"", (*libc_version)());
#endif /* _WIN32 */

#ifdef __GLIBC__
  buf << __GLIBC__ << ""."" << __GLIBC_MINOR__;
  writer->json_keyvalue(""glibcVersionCompiler"", buf.str());
  buf.str("""");
#endif

  // Report Process word size
  writer->json_keyvalue(""wordSize"", sizeof(void*) * 8);
  writer->json_keyvalue(""arch"", per_process::metadata.arch);
  writer->json_keyvalue(""platform"", per_process::metadata.platform);

  // Report deps component versions
  PrintComponentVersions(writer);

  // Report relea...",253.0,304.0,1.0,1.0,52.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
4242,220877,PrintJavaScriptErrorStack,1,node.report.PrintJavaScriptErrorStack,"void node.report.PrintJavaScriptErrorStack (JSONWriter*,Isolate*,Local<Value>,char*)",node_report.cc,"static void PrintJavaScriptErrorStack(JSONWriter* writer,
                                      Isolate* isolate,
                                      Local<Value> error,
                                      const char* trigger) {
  if (error.IsEmpty()) {
    return PrintJavaScriptStack(writer, isolate, trigger);
  }

  TryCatch try_catch(isolate);
  HandleScope scope(isolate);
  Local<Context> context = isolate->GetCurrentContext();
  std::string ss = """";
  if (!ErrorToString(isolate, context, error).To(&ss)) {
    PrintEmptyJavaScriptStack(writer);
    return;
  }

  int line = ss.find('\n');
  if (line == -1) {
    writer->json_keyvalue(""message"", ss);
  } else {
    std::string l = ss.substr(0, line);
    writer->json_keyvalue(""message"", l);
    writer->json_arraystart(""stack"");
    ss = ss.substr(line + 1);
    line = ss.find('\n');
    while (line != -1) {
      l = ss.substr(0, line);
      l.erase(l.begin(), std::find_if(l.begin(), l.end(), [](int ch) {
                ret...",504.0,544.0,1.0,1.0,41.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,void
4243,220885,PrintJavaScriptStack,1,node.report.PrintJavaScriptStack,"void node.report.PrintJavaScriptStack (JSONWriter*,Isolate*,char*)",node_report.cc,"static void PrintJavaScriptStack(JSONWriter* writer,
                                 Isolate* isolate,
                                 const char* trigger) {
  // Can not capture the stacktrace when the isolate is in a OOM state.
  if (!strcmp(trigger, ""OOMError"")) {
    PrintEmptyJavaScriptStack(writer);
    return;
  }

  HandleScope scope(isolate);
  RegisterState state;
  state.pc = nullptr;
  state.fp = &state;
  state.sp = &state;

  // in-out params
  SampleInfo info;
  void* samples[MAX_FRAME_COUNT];
  isolate->GetStackSample(state, samples, MAX_FRAME_COUNT, &info);

  constexpr StackTrace::StackTraceOptions stack_trace_options =
      static_cast<StackTrace::StackTraceOptions>(
          StackTrace::kDetailed |
          StackTrace::kExposeFramesAcrossSecurityOrigins);
  Local<StackTrace> stack = StackTrace::CurrentStackTrace(
      isolate, MAX_FRAME_COUNT, stack_trace_options);

  if (stack->GetFrameCount() == 0) {
    PrintEmptyJavaScriptStack(writer);
    return;
  }
...",452.0,501.0,1.0,1.0,50.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,void
4244,220892,PrintJavaScriptErrorProperties,1,node.report.PrintJavaScriptErrorProperties,"void node.report.PrintJavaScriptErrorProperties (JSONWriter*,Isolate*,Local<Value>)",node_report.cc,"static void PrintJavaScriptErrorProperties(JSONWriter* writer,
                                           Isolate* isolate,
                                           Local<Value> error) {
  writer->json_objectstart(""errorProperties"");
  if (!error.IsEmpty() && error->IsObject()) {
    TryCatch try_catch(isolate);
    Local<Object> error_obj = error.As<Object>();
    Local<Context> context = error_obj->GetIsolate()->GetCurrentContext();
    Local<Array> keys;
    if (!error_obj->GetOwnPropertyNames(context).ToLocal(&keys)) {
      return writer->json_objectend();  // the end of 'errorProperties'
    }
    uint32_t keys_length = keys->Length();
    for (uint32_t i = 0; i < keys_length; i++) {
      Local<Value> key;
      if (!keys->Get(context, i).ToLocal(&key) || !key->IsString()) {
        continue;
      }
      Local<Value> value;
      Local<String> value_string;
      if (!error_obj->Get(context, key).ToLocal(&value) ||
          !value->ToString(context).ToLocal(&value_string...",379.0,410.0,1.0,1.0,32.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,void
4245,220899,PrintNativeStack,1,node.report.PrintNativeStack,void node.report.PrintNativeStack (JSONWriter*),node_report.cc,"static void PrintNativeStack(JSONWriter* writer) {
  auto sym_ctx = NativeSymbolDebuggingContext::New();
  void* frames[256];
  const int size = sym_ctx->GetStackTrace(frames, arraysize(frames));
  writer->json_arraystart(""nativeStack"");
  int i;
  for (i = 1; i < size; i++) {
    void* frame = frames[i];
    writer->json_start();
    writer->json_keyvalue(""pc"",
                          ValueToHexString(reinterpret_cast<uintptr_t>(frame)));
    writer->json_keyvalue(""symbol"", sym_ctx->LookupSymbol(frame).Display());
    writer->json_end();
  }
  writer->json_arrayend();
}",547.0,562.0,1.0,1.0,16.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
4246,220904,PrintResourceUsage,1,node.report.PrintResourceUsage,void node.report.PrintResourceUsage (JSONWriter*),node_report.cc,"static void PrintResourceUsage(JSONWriter* writer) {
  // Get process uptime in seconds
  uint64_t uptime =
      (uv_hrtime() - per_process::node_start_time) / (NANOS_PER_SEC);
  if (uptime == 0) uptime = 1;  // avoid division by zero.

  // Process and current thread usage statistics
  uv_rusage_t rusage;
  writer->json_objectstart(""resourceUsage"");

  uint64_t free_memory = uv_get_free_memory();
  uint64_t total_memory = uv_get_total_memory();

  writer->json_keyvalue(""free_memory"", free_memory);
  writer->json_keyvalue(""total_memory"", total_memory);

  size_t rss;
  int err = uv_resident_set_memory(&rss);
  if (!err) {
    writer->json_keyvalue(""rss"", rss);
  }

  uint64_t constrained_memory = uv_get_constrained_memory();
  if (constrained_memory) {
    writer->json_keyvalue(""constrained_memory"", constrained_memory);
  }

  // See GuessMemoryAvailableToTheProcess
  if (!err && constrained_memory && constrained_memory >= rss) {
    uint64_t available_memory = constrained_memory -...",620.0,704.0,1.0,1.0,85.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
4247,220909,PrintGCStatistics,1,node.report.PrintGCStatistics,"void node.report.PrintGCStatistics (JSONWriter*,Isolate*)",node_report.cc,"static void PrintGCStatistics(JSONWriter* writer, Isolate* isolate) {
  HeapStatistics v8_heap_stats;
  isolate->GetHeapStatistics(&v8_heap_stats);
  HeapSpaceStatistics v8_heap_space_stats;

  writer->json_objectstart(""javascriptHeap"");
  writer->json_keyvalue(""totalMemory"", v8_heap_stats.total_heap_size());
  writer->json_keyvalue(""executableMemory"",
                        v8_heap_stats.total_heap_size_executable());
  writer->json_keyvalue(""totalCommittedMemory"",
                        v8_heap_stats.total_physical_size());
  writer->json_keyvalue(""availableMemory"",
                        v8_heap_stats.total_available_size());
  writer->json_keyvalue(""totalGlobalHandlesMemory"",
                        v8_heap_stats.total_global_handles_size());
  writer->json_keyvalue(""usedGlobalHandlesMemory"",
                        v8_heap_stats.used_global_handles_size());
  writer->json_keyvalue(""usedMemory"", v8_heap_stats.used_heap_size());
  writer->json_keyvalue(""memoryLimit"", v8_heap_s...",568.0,618.0,1.0,1.0,51.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
4248,220915,PrintSystemInformation,1,node.report.PrintSystemInformation,void node.report.PrintSystemInformation (JSONWriter*),node_report.cc,"static void PrintSystemInformation(JSONWriter* writer) {
  uv_env_item_t* envitems;
  int envcount;
  int r;

  writer->json_objectstart(""environmentVariables"");

  {
    Mutex::ScopedLock lock(per_process::env_var_mutex);
    r = uv_os_environ(&envitems, &envcount);
  }

  if (r == 0) {
    for (int i = 0; i < envcount; i++)
      writer->json_keyvalue(envitems[i].name, envitems[i].value);

    uv_os_free_environ(envitems, envcount);
  }

  writer->json_objectend();

#ifndef _WIN32
  static struct {
    const char* description;
    int id;
  } rlimit_strings[] = {
    {""core_file_size_blocks"", RLIMIT_CORE},
    {""data_seg_size_kbytes"", RLIMIT_DATA},
    {""file_size_blocks"", RLIMIT_FSIZE},
#if !(defined(_AIX) || defined(__sun))
    {""max_locked_memory_bytes"", RLIMIT_MEMLOCK},
#endif
#ifndef __sun
    {""max_memory_size_kbytes"", RLIMIT_RSS},
#endif
    {""open_files"", RLIMIT_NOFILE},
    {""stack_size_bytes"", RLIMIT_STACK},
    {""cpu_time_seconds"", RLIMIT_CPU},
#ifndef __sun
    {""max_u...",707.0,778.0,1.0,1.0,72.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
4249,220920,PrintLoadedLibraries,1,node.report.PrintLoadedLibraries,void node.report.PrintLoadedLibraries (JSONWriter*),node_report.cc,"static void PrintLoadedLibraries(JSONWriter* writer) {
  writer->json_arraystart(""sharedObjects"");
  std::vector<std::string> modules =
      NativeSymbolDebuggingContext::GetLoadedLibraries();
  for (auto const& module_name : modules) writer->json_element(module_name);
  writer->json_arrayend();
}",781.0,787.0,1.0,1.0,7.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
4250,220925,PrintComponentVersions,1,node.report.PrintComponentVersions,void node.report.PrintComponentVersions (JSONWriter*),node_report.cc,"static void PrintComponentVersions(JSONWriter* writer) {
  std::stringstream buf;

  writer->json_objectstart(""componentVersions"");

#define V(key) +1
  std::pair<std::string_view, std::string_view>
      versions_array[NODE_VERSIONS_KEYS(V)];
#undef V
  auto* slot = &versions_array[0];

#define V(key)                                                                 \
  do {                                                                         \
    *slot++ = std::pair<std::string_view, std::string_view>(                   \
        #key, per_process::metadata.versions.key);                             \
  } while (0);
  NODE_VERSIONS_KEYS(V)
#undef V

  std::sort(&versions_array[0],
            &versions_array[arraysize(versions_array)],
            [](auto& a, auto& b) { return a.first < b.first; });

  for (const auto& version : versions_array) {
    writer->json_keyvalue(version.first, version.second);
  }

  writer->json_objectend();
}",790.0,818.0,1.0,1.0,29.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
4251,220930,PrintRelease,1,node.report.PrintRelease,void node.report.PrintRelease (JSONWriter*),node_report.cc,"static void PrintRelease(JSONWriter* writer) {
  writer->json_objectstart(""release"");
  writer->json_keyvalue(""name"", per_process::metadata.release.name);
#if NODE_VERSION_IS_LTS
  writer->json_keyvalue(""lts"", per_process::metadata.release.lts);
#endif

#ifdef NODE_HAS_RELEASE_URLS
  writer->json_keyvalue(""headersUrl"",
                        per_process::metadata.release.headers_url);
  writer->json_keyvalue(""sourceUrl"", per_process::metadata.release.source_url);
#ifdef _WIN32
  writer->json_keyvalue(""libUrl"", per_process::metadata.release.lib_url);
#endif  // _WIN32
#endif  // NODE_HAS_RELEASE_URLS

  writer->json_objectend();
}",821.0,838.0,1.0,1.0,18.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
4252,220935,PrintCpuInfo,1,node.report.PrintCpuInfo,void node.report.PrintCpuInfo (JSONWriter*),node_report.cc,"static void PrintCpuInfo(JSONWriter* writer) {
  uv_cpu_info_t* cpu_info;
  int count;
  if (uv_cpu_info(&cpu_info, &count) == 0) {
    writer->json_arraystart(""cpus"");
    for (int i = 0; i < count; i++) {
      writer->json_start();
      writer->json_keyvalue(""model"", cpu_info[i].model);
      writer->json_keyvalue(""speed"", cpu_info[i].speed);
      writer->json_keyvalue(""user"", cpu_info[i].cpu_times.user);
      writer->json_keyvalue(""nice"", cpu_info[i].cpu_times.nice);
      writer->json_keyvalue(""sys"", cpu_info[i].cpu_times.sys);
      writer->json_keyvalue(""idle"", cpu_info[i].cpu_times.idle);
      writer->json_keyvalue(""irq"", cpu_info[i].cpu_times.irq);
      writer->json_end();
    }
    writer->json_arrayend();
    uv_free_cpu_info(cpu_info, count);
  }
}",307.0,326.0,1.0,1.0,20.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
4253,220940,PrintNetworkInterfaceInfo,1,node.report.PrintNetworkInterfaceInfo,void node.report.PrintNetworkInterfaceInfo (JSONWriter*),node_report.cc,"static void PrintNetworkInterfaceInfo(JSONWriter* writer) {
  uv_interface_address_t* interfaces;
  char ip[INET6_ADDRSTRLEN];
  char netmask[INET6_ADDRSTRLEN];
  char mac[18];
  int count;

  if (uv_interface_addresses(&interfaces, &count) == 0) {
    writer->json_arraystart(""networkInterfaces"");

    for (int i = 0; i < count; i++) {
      writer->json_start();
      writer->json_keyvalue(""name"", interfaces[i].name);
      writer->json_keyvalue(""internal"", !!interfaces[i].is_internal);
      snprintf(mac,
               sizeof(mac),
               ""%02x:%02x:%02x:%02x:%02x:%02x"",
               static_cast<unsigned char>(interfaces[i].phys_addr[0]),
               static_cast<unsigned char>(interfaces[i].phys_addr[1]),
               static_cast<unsigned char>(interfaces[i].phys_addr[2]),
               static_cast<unsigned char>(interfaces[i].phys_addr[3]),
               static_cast<unsigned char>(interfaces[i].phys_addr[4]),
               static_cast<unsigned char>(interfaces[...",328.0,377.0,1.0,1.0,50.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
4254,221385,libc_version,1,node.report.PrintVersionInformation.libc_version,char* node.report.PrintVersionInformation.libc_version (),node_report.cc,const char* (*libc_version)();,262.0,262.0,13.0,31.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,char*
4255,222099,ErrorToString,1,node.report.ErrorToString,"Maybe<std::string> node.report.ErrorToString (Isolate*,Local<Context>,Local<Value>)",node_report.cc,"static Maybe<std::string> ErrorToString(Isolate* isolate,
                                        Local<Context> context,
                                        Local<Value> error) {
  if (error.IsEmpty()) {
    return Nothing<std::string>();
  }

  MaybeLocal<String> maybe_str;
  // `ToString` is not available to Symbols.
  if (error->IsSymbol()) {
    maybe_str = error.As<v8::Symbol>()->ToDetailString(context);
  } else if (!error->IsObject()) {
    maybe_str = error->ToString(context);
  } else if (error->IsObject()) {
    MaybeLocal<Value> stack = error.As<Object>()->Get(
        context, FIXED_ONE_BYTE_STRING(isolate, ""stack""));
    if (!stack.IsEmpty() && stack.ToLocalChecked()->IsString()) {
      maybe_str = stack.ToLocalChecked().As<String>();
    }
  }

  Local<String> js_str;
  if (!maybe_str.ToLocal(&js_str)) {
    return Nothing<std::string>();
  }
  String::Utf8Value sv(isolate, js_str);
  return Just<>(std::string(*sv, sv.length()));
}",412.0,439.0,1.0,1.0,28.0,15,8,20,11,0,0,4,4,0,0,,0,0,6,3,3,Maybe<std.string>
4256,222234,PrintEmptyJavaScriptStack,1,node.report.PrintEmptyJavaScriptStack,void node.report.PrintEmptyJavaScriptStack (JSONWriter*),node_report.cc,"static void PrintEmptyJavaScriptStack(JSONWriter* writer) {
  writer->json_keyvalue(""message"", ""No stack."");
  writer->json_arraystart(""stack"");
  writer->json_element(""Unavailable."");
  writer->json_arrayend();

  writer->json_objectstart(""errorProperties"");
  writer->json_objectend();
}",441.0,449.0,1.0,1.0,9.0,6,1,6,1,0,0,1,1,0,0,,0,0,2,1,1,void
4257,223996,WriteReport,1,node.report.WriteReport,void node.report.WriteReport (FunctionCallbackInfo<Value>),node_report_module.cc,"void WriteReport(const FunctionCallbackInfo<Value>& info) {
  Environment* env = Environment::GetCurrent(info);
  Isolate* isolate = env->isolate();
  HandleScope scope(isolate);
  std::string filename;
  Local<Value> error;

  CHECK_EQ(info.Length(), 4);
  String::Utf8Value message(isolate, info[0].As<String>());
  String::Utf8Value trigger(isolate, info[1].As<String>());

  if (info[2]->IsString())
    filename = *String::Utf8Value(isolate, info[2]);
  if (!info[3].IsEmpty())
    error = info[3];
  else
    error = Local<Value>();

  filename = TriggerNodeReport(env, *message, *trigger, filename, error);
  // Return value is the report filename
  info.GetReturnValue().Set(
      String::NewFromUtf8(isolate, filename.c_str()).ToLocalChecked());
}",29.0,51.0,1.0,1.0,23.0,30,8,32,11,0,0,3,3,0,0,,0,0,2,1,1,void
4258,224116,GetReport,1,node.report.GetReport,void node.report.GetReport (FunctionCallbackInfo<Value>),node_report_module.cc,"void GetReport(const FunctionCallbackInfo<Value>& info) {
  Environment* env = Environment::GetCurrent(info);
  Isolate* isolate = env->isolate();
  HandleScope scope(isolate);
  Local<Object> error;
  std::ostringstream out;

  CHECK_EQ(info.Length(), 1);
  if (!info[0].IsEmpty() && info[0]->IsObject())
    error = info[0].As<Object>();
  else
    error = Local<Object>();

  GetNodeReport(env, ""JavaScript API"", __func__, error, out);

  // Return value is the contents of a report as a string.
  info.GetReturnValue().Set(
      String::NewFromUtf8(isolate, out.str().c_str()).ToLocalChecked());
}",54.0,72.0,1.0,1.0,19.0,22,8,22,10,0,0,2,2,0,0,,0,0,2,1,1,void
4259,224208,GetCompact,1,node.report.GetCompact,void node.report.GetCompact (FunctionCallbackInfo<Value>),node_report_module.cc,"static void GetCompact(const FunctionCallbackInfo<Value>& info) {
  Mutex::ScopedLock lock(per_process::cli_options_mutex);
  info.GetReturnValue().Set(per_process::cli_options->report_compact);
}",74.0,77.0,1.0,1.0,4.0,5,2,3,2,0,0,1,1,0,0,,0,0,2,1,1,void
4260,224230,SetCompact,1,node.report.SetCompact,void node.report.SetCompact (FunctionCallbackInfo<Value>),node_report_module.cc,"static void SetCompact(const FunctionCallbackInfo<Value>& info) {
  Mutex::ScopedLock lock(per_process::cli_options_mutex);
  Environment* env = Environment::GetCurrent(info);
  Isolate* isolate = env->isolate();
  bool compact = info[0]->ToBoolean(isolate)->Value();
  per_process::cli_options->report_compact = compact;
}",79.0,85.0,1.0,1.0,7.0,12,4,11,6,0,0,1,1,0,0,,0,0,2,1,1,void
4261,224275,GetDirectory,1,node.report.GetDirectory,void node.report.GetDirectory (FunctionCallbackInfo<Value>),node_report_module.cc,"static void GetDirectory(const FunctionCallbackInfo<Value>& info) {
  Mutex::ScopedLock lock(per_process::cli_options_mutex);
  Environment* env = Environment::GetCurrent(info);
  std::string directory = per_process::cli_options->report_directory;
  auto result = String::NewFromUtf8(env->isolate(), directory.c_str());
  info.GetReturnValue().Set(result.ToLocalChecked());
}",87.0,93.0,1.0,1.0,7.0,13,3,12,7,0,0,1,1,0,0,,0,0,2,1,1,void
4262,224327,SetDirectory,1,node.report.SetDirectory,void node.report.SetDirectory (FunctionCallbackInfo<Value>),node_report_module.cc,"static void SetDirectory(const FunctionCallbackInfo<Value>& info) {
  Mutex::ScopedLock lock(per_process::cli_options_mutex);
  Environment* env = Environment::GetCurrent(info);
  CHECK(info[0]->IsString());
  Utf8Value dir(env->isolate(), info[0].As<String>());
  per_process::cli_options->report_directory = *dir;
}",95.0,101.0,1.0,1.0,7.0,12,5,9,5,0,0,1,1,0,0,,0,0,2,1,1,void
4263,224372,GetFilename,1,node.report.GetFilename,void node.report.GetFilename (FunctionCallbackInfo<Value>),node_report_module.cc,"static void GetFilename(const FunctionCallbackInfo<Value>& info) {
  Mutex::ScopedLock lock(per_process::cli_options_mutex);
  Environment* env = Environment::GetCurrent(info);
  std::string filename = per_process::cli_options->report_filename;
  auto result = String::NewFromUtf8(env->isolate(), filename.c_str());
  info.GetReturnValue().Set(result.ToLocalChecked());
}",103.0,109.0,1.0,1.0,7.0,13,3,12,7,0,0,1,1,0,0,,0,0,2,1,1,void
4264,224424,SetFilename,1,node.report.SetFilename,void node.report.SetFilename (FunctionCallbackInfo<Value>),node_report_module.cc,"static void SetFilename(const FunctionCallbackInfo<Value>& info) {
  Mutex::ScopedLock lock(per_process::cli_options_mutex);
  Environment* env = Environment::GetCurrent(info);
  CHECK(info[0]->IsString());
  Utf8Value name(env->isolate(), info[0].As<String>());
  per_process::cli_options->report_filename = *name;
}",111.0,117.0,1.0,1.0,7.0,12,5,9,5,0,0,1,1,0,0,,0,0,2,1,1,void
4265,224469,GetSignal,1,node.report.GetSignal,void node.report.GetSignal (FunctionCallbackInfo<Value>),node_report_module.cc,"static void GetSignal(const FunctionCallbackInfo<Value>& info) {
  Environment* env = Environment::GetCurrent(info);
  std::string signal = env->isolate_data()->options()->report_signal;
  auto result = String::NewFromUtf8(env->isolate(), signal.c_str());
  info.GetReturnValue().Set(result.ToLocalChecked());
}",119.0,124.0,1.0,1.0,6.0,13,3,11,6,0,0,1,1,0,0,,0,0,2,1,1,void
4266,224520,SetSignal,1,node.report.SetSignal,void node.report.SetSignal (FunctionCallbackInfo<Value>),node_report_module.cc,"static void SetSignal(const FunctionCallbackInfo<Value>& info) {
  Environment* env = Environment::GetCurrent(info);
  CHECK(info[0]->IsString());
  Utf8Value signal(env->isolate(), info[0].As<String>());
  env->isolate_data()->options()->report_signal = *signal;
}",126.0,131.0,1.0,1.0,6.0,12,5,8,4,0,0,1,1,0,0,,0,0,2,1,1,void
4267,224564,ShouldReportOnFatalError,1,node.report.ShouldReportOnFatalError,void node.report.ShouldReportOnFatalError (FunctionCallbackInfo<Value>),node_report_module.cc,"static void ShouldReportOnFatalError(const FunctionCallbackInfo<Value>& info) {
  Mutex::ScopedLock lock(per_process::cli_options_mutex);
  info.GetReturnValue().Set(per_process::cli_options->report_on_fatalerror);
}",133.0,136.0,1.0,1.0,4.0,5,2,3,2,0,0,1,1,0,0,,0,0,2,1,1,void
4268,224586,SetReportOnFatalError,1,node.report.SetReportOnFatalError,void node.report.SetReportOnFatalError (FunctionCallbackInfo<Value>),node_report_module.cc,"static void SetReportOnFatalError(const FunctionCallbackInfo<Value>& info) {
  CHECK(info[0]->IsBoolean());
  Mutex::ScopedLock lock(per_process::cli_options_mutex);
  per_process::cli_options->report_on_fatalerror = info[0]->IsTrue();
}",138.0,142.0,1.0,1.0,5.0,8,4,4,2,0,0,1,1,0,0,,0,0,2,1,1,void
4269,224615,ShouldReportOnSignal,1,node.report.ShouldReportOnSignal,void node.report.ShouldReportOnSignal (FunctionCallbackInfo<Value>),node_report_module.cc,"static void ShouldReportOnSignal(const FunctionCallbackInfo<Value>& info) {
  Environment* env = Environment::GetCurrent(info);
  info.GetReturnValue().Set(env->isolate_data()->options()->report_on_signal);
}",144.0,147.0,1.0,1.0,4.0,7,3,5,3,0,0,1,1,0,0,,0,0,2,1,1,void
4270,224644,SetReportOnSignal,1,node.report.SetReportOnSignal,void node.report.SetReportOnSignal (FunctionCallbackInfo<Value>),node_report_module.cc,"static void SetReportOnSignal(const FunctionCallbackInfo<Value>& info) {
  Environment* env = Environment::GetCurrent(info);
  CHECK(info[0]->IsBoolean());
  env->isolate_data()->options()->report_on_signal = info[0]->IsTrue();
}",149.0,153.0,1.0,1.0,5.0,10,4,6,3,0,0,1,1,0,0,,0,0,2,1,1,void
4271,224680,ShouldReportOnUncaughtException,1,node.report.ShouldReportOnUncaughtException,void node.report.ShouldReportOnUncaughtException (FunctionCallbackInfo<Value>),node_report_module.cc,"static void ShouldReportOnUncaughtException(
    const FunctionCallbackInfo<Value>& info) {
  Environment* env = Environment::GetCurrent(info);
  info.GetReturnValue().Set(
      env->isolate_data()->options()->report_uncaught_exception);
}",155.0,160.0,1.0,1.0,6.0,7,3,5,3,0,0,1,1,0,0,,0,0,2,1,1,void
4272,224709,SetReportOnUncaughtException,1,node.report.SetReportOnUncaughtException,void node.report.SetReportOnUncaughtException (FunctionCallbackInfo<Value>),node_report_module.cc,"static void SetReportOnUncaughtException(
    const FunctionCallbackInfo<Value>& info) {
  Environment* env = Environment::GetCurrent(info);
  CHECK(info[0]->IsBoolean());
  env->isolate_data()->options()->report_uncaught_exception = info[0]->IsTrue();
}",162.0,167.0,1.0,1.0,6.0,10,4,6,3,0,0,1,1,0,0,,0,0,2,1,1,void
4273,224745,Initialize,1,node.report.Initialize,"void node.report.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)",node_report_module.cc,"static void Initialize(Local<Object> exports,
                       Local<Value> unused,
                       Local<Context> context,
                       void* priv) {
  SetMethod(context, exports, ""writeReport"", WriteReport);
  SetMethod(context, exports, ""getReport"", GetReport);
  SetMethod(context, exports, ""getCompact"", GetCompact);
  SetMethod(context, exports, ""setCompact"", SetCompact);
  SetMethod(context, exports, ""getDirectory"", GetDirectory);
  SetMethod(context, exports, ""setDirectory"", SetDirectory);
  SetMethod(context, exports, ""getFilename"", GetFilename);
  SetMethod(context, exports, ""setFilename"", SetFilename);
  SetMethod(context, exports, ""getSignal"", GetSignal);
  SetMethod(context, exports, ""setSignal"", SetSignal);
  SetMethod(
      context, exports, ""shouldReportOnFatalError"", ShouldReportOnFatalError);
  SetMethod(context, exports, ""setReportOnFatalError"", SetReportOnFatalError);
  SetMethod(context, exports, ""shouldReportOnSignal"", ShouldReportOnSignal...",169.0,196.0,1.0,1.0,28.0,0,0,32,2,0,0,1,1,0,0,,0,0,8,4,4,void
4274,224833,RegisterExternalReferences,1,node.report.RegisterExternalReferences,void node.report.RegisterExternalReferences (ExternalReferenceRegistry*),node_report_module.cc,"void RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  registry->Register(WriteReport);
  registry->Register(GetReport);
  registry->Register(GetCompact);
  registry->Register(SetCompact);
  registry->Register(GetDirectory);
  registry->Register(SetDirectory);
  registry->Register(GetFilename);
  registry->Register(SetFilename);
  registry->Register(GetSignal);
  registry->Register(SetSignal);
  registry->Register(ShouldReportOnFatalError);
  registry->Register(SetReportOnFatalError);
  registry->Register(ShouldReportOnSignal);
  registry->Register(SetReportOnSignal);
  registry->Register(ShouldReportOnUncaughtException);
  registry->Register(SetReportOnUncaughtException);
}",198.0,215.0,1.0,1.0,18.0,16,1,16,1,0,0,1,1,0,0,,0,0,2,1,1,void
4275,224939,ReportEndpoint,1,node.report.ReportEndpoint,"void node.report.ReportEndpoint (uv_handle_t*,sockaddr*,char*,JSONWriter*)",node_report_utils.cc,"static void ReportEndpoint(uv_handle_t* h,
                           struct sockaddr* addr,
                           const char* name,
                           JSONWriter* writer) {
  if (addr == nullptr) {
    writer->json_keyvalue(name, null);
    return;
  }

  uv_getnameinfo_t endpoint;
  char* host = nullptr;
  char hostbuf[INET6_ADDRSTRLEN];
  const int family = addr->sa_family;
  const int port = ntohs(family == AF_INET ?
                         reinterpret_cast<sockaddr_in*>(addr)->sin_port :
                         reinterpret_cast<sockaddr_in6*>(addr)->sin6_port);

  if (uv_getnameinfo(h->loop, &endpoint, nullptr, addr, NI_NUMERICSERV) == 0) {
    host = endpoint.host;
    DCHECK_EQ(port, std::stoi(endpoint.service));
  } else {
    const void* src = family == AF_INET ?
                      static_cast<void*>(
                        &(reinterpret_cast<sockaddr_in*>(addr)->sin_addr)) :
                      static_cast<void*>(
                        &(reinterpret_...",12.0,48.0,1.0,1.0,37.0,24,8,29,12,0,0,4,4,0,0,,0,0,8,4,4,void
4276,225080,ReportEndpoints,1,node.report.ReportEndpoints,"void node.report.ReportEndpoints (uv_handle_t*,JSONWriter*)",node_report_utils.cc,"static void ReportEndpoints(uv_handle_t* h, JSONWriter* writer) {
  struct sockaddr_storage addr_storage;
  struct sockaddr* addr = reinterpret_cast<sockaddr*>(&addr_storage);
  uv_any_handle* handle = reinterpret_cast<uv_any_handle*>(h);
  int addr_size = sizeof(addr_storage);
  int rc = -1;

  switch (h->type) {
    case UV_UDP:
      rc = uv_udp_getsockname(&handle->udp, addr, &addr_size);
      break;
    case UV_TCP:
      rc = uv_tcp_getsockname(&handle->tcp, addr, &addr_size);
      break;
    default:
      break;
  }
  ReportEndpoint(h, rc == 0 ? addr : nullptr,  ""localEndpoint"", writer);

  switch (h->type) {
    case UV_UDP:
      rc = uv_udp_getpeername(&handle->udp, addr, &addr_size);
      break;
    case UV_TCP:
      rc = uv_tcp_getpeername(&handle->tcp, addr, &addr_size);
      break;
    default:
      break;
  }
  ReportEndpoint(h, rc == 0 ? addr : nullptr, ""remoteEndpoint"", writer);
}",51.0,81.0,1.0,1.0,31.0,31,8,37,9,0,0,9,3,0,0,,0,0,4,2,2,void
4277,225196,ReportPipeEndpoints,1,node.report.ReportPipeEndpoints,"void node.report.ReportPipeEndpoints (uv_handle_t*,JSONWriter*)",node_report_utils.cc,"static void ReportPipeEndpoints(uv_handle_t* h, JSONWriter* writer) {
  uv_any_handle* handle = reinterpret_cast<uv_any_handle*>(h);
  MaybeStackBuffer<char> buffer;
  size_t buffer_size = buffer.capacity();
  int rc = -1;

  // First call to get required buffer size.
  rc = uv_pipe_getsockname(&handle->pipe, buffer.out(), &buffer_size);
  if (rc == UV_ENOBUFS) {
    buffer.AllocateSufficientStorage(buffer_size);
    rc = uv_pipe_getsockname(&handle->pipe, buffer.out(), &buffer_size);
  }
  if (rc == 0 && buffer_size != 0) {
    buffer.SetLength(buffer_size);
    writer->json_keyvalue(""localEndpoint"", buffer.ToStringView());
  } else {
    writer->json_keyvalue(""localEndpoint"", null);
  }

  // First call to get required buffer size.
  buffer_size = buffer.capacity();
  rc = uv_pipe_getpeername(&handle->pipe, buffer.out(), &buffer_size);
  if (rc == UV_ENOBUFS) {
    buffer.AllocateSufficientStorage(buffer_size);
    rc = uv_pipe_getpeername(&handle->pipe, buffer.out(), &buffer_size...",84.0,116.0,1.0,1.0,33.0,44,9,43,7,0,0,5,5,0,0,,0,0,4,2,2,void
4278,225361,ReportPath,1,node.report.ReportPath,"void node.report.ReportPath (uv_handle_t*,JSONWriter*)",node_report_utils.cc,"static void ReportPath(uv_handle_t* h, JSONWriter* writer) {
  MaybeStackBuffer<char> buffer;
  int rc = -1;
  size_t size = buffer.capacity();
  uv_any_handle* handle = reinterpret_cast<uv_any_handle*>(h);
  // First call to get required buffer size.
  switch (h->type) {
    case UV_FS_EVENT:
      rc = uv_fs_event_getpath(&(handle->fs_event), buffer.out(), &size);
      break;
    case UV_FS_POLL:
      rc = uv_fs_poll_getpath(&(handle->fs_poll), buffer.out(), &size);
      break;
    default:
      break;
  }
  if (rc == UV_ENOBUFS) {
    buffer.AllocateSufficientStorage(size);
    switch (h->type) {
      case UV_FS_EVENT:
        rc = uv_fs_event_getpath(&(handle->fs_event), buffer.out(), &size);
        break;
      case UV_FS_POLL:
        rc = uv_fs_poll_getpath(&(handle->fs_poll), buffer.out(), &size);
        break;
      default:
        break;
    }
  }

  if (rc == 0 && size > 0) {
    buffer.SetLength(size);
    writer->json_keyvalue(""filename"", buffer.ToStringView());...",119.0,155.0,1.0,1.0,37.0,36,9,37,9,0,0,11,6,0,0,,0,0,4,2,2,void
4279,225505,WalkHandle,1,node.report.WalkHandle,"void node.report.WalkHandle (uv_handle_t*,void*)",node_report_utils.cc,"void WalkHandle(uv_handle_t* h, void* arg) {
  const char* type = uv_handle_type_name(h->type);
  JSONWriter* writer = static_cast<JSONWriter*>(arg);
  uv_any_handle* handle = reinterpret_cast<uv_any_handle*>(h);

  writer->json_start();
  writer->json_keyvalue(""type"", type);
  writer->json_keyvalue(""is_active"", static_cast<bool>(uv_is_active(h)));
  writer->json_keyvalue(""is_referenced"", static_cast<bool>(uv_has_ref(h)));
  writer->json_keyvalue(""address"",
                        ValueToHexString(reinterpret_cast<uint64_t>(h)));

  switch (h->type) {
    case UV_FS_EVENT:
    case UV_FS_POLL:
      ReportPath(h, writer);
      break;
    case UV_PROCESS:
      writer->json_keyvalue(""pid"", handle->process.pid);
      break;
    case UV_TCP:
    case UV_UDP:
      ReportEndpoints(h, writer);
      break;
    case UV_NAMED_PIPE:
      ReportPipeEndpoints(h, writer);
      break;
    case UV_TIMER: {
      uint64_t due = handle->timer.timeout;
      uint64_t now = uv_now(handle->timer....",158.0,269.0,1.0,1.0,112.0,108,9,116,26,0,0,21,13,0,0,,0,0,4,2,2,void
4280,225943,<lambda>0,1,node.sea.anonymous_namespace_7.FindSingleExecutableResource.<lambda>0,SeaResource node.sea.anonymous_namespace_7.FindSingleExecutableResource.<lambda>0 (),node_sea.cc,"[]() -> SeaResource {
    size_t size;
#ifdef __APPLE__
    postject_options options;
    postject_options_init(&options);
    options.macho_segment_name = ""NODE_SEA"";
    const char* code = static_cast<const char*>(
        postject_find_resource(""NODE_SEA_BLOB"", &size, &options));
#else
    const char* code = static_cast<const char*>(
        postject_find_resource(""NODE_SEA_BLOB"", &size, nullptr));
#endif
    uint32_t first_word = reinterpret_cast<const uint32_t*>(code)[0];
    CHECK_EQ(first_word, kMagic);
    SeaFlags flags{
        reinterpret_cast<const SeaFlags*>(code + sizeof(first_word))[0]};
    // TODO(joyeecheung): do more checks here e.g. matching the versions.
    return {
        flags,
        {
            code + SeaResource::kHeaderSize,
            size - SeaResource::kHeaderSize,
        },
    };
  }",70.0,94.0,43.0,3.0,25.0,12,7,9,5,1,0,1,1,0,0,,0,0,0,0,0,SeaResource
4281,226033,operator |,1,node.sea.anonymous_namespace_2.operator |,"SeaFlags node.sea.anonymous_namespace_2.operator | (SeaFlags,SeaFlags)",node_sea.cc,"SeaFlags operator|(SeaFlags x, SeaFlags y) {
  return static_cast<SeaFlags>(static_cast<uint32_t>(x) |
                               static_cast<uint32_t>(y));
}",48.0,51.0,1.0,1.0,4.0,4,2,2,2,0,0,1,1,0,0,,0,0,4,2,2,SeaFlags
4282,226049,operator &,1,node.sea.anonymous_namespace_3.operator &,"SeaFlags node.sea.anonymous_namespace_3.operator & (SeaFlags,SeaFlags)",node_sea.cc,"SeaFlags operator&(SeaFlags x, SeaFlags y) {
  return static_cast<SeaFlags>(static_cast<uint32_t>(x) &
                               static_cast<uint32_t>(y));
}",53.0,56.0,1.0,1.0,4.0,4,2,2,2,0,0,1,1,0,0,,0,0,4,2,2,SeaFlags
4283,226065,operator |=,1,node.sea.anonymous_namespace_4.operator |=,"SeaFlags node.sea.anonymous_namespace_4.operator |= (SeaFlags,SeaFlags)",node_sea.cc,"SeaFlags operator|=(/* NOLINT (runtime/references) */ SeaFlags& x, SeaFlags y) {
  return x = x | y;
}",58.0,60.0,1.0,1.0,3.0,2,2,3,2,0,0,1,1,0,0,,0,0,4,2,2,SeaFlags
4284,226097,FindSingleExecutableResource,1,node.sea.anonymous_namespace_6.FindSingleExecutableResource,SeaResource node.sea.anonymous_namespace_6.FindSingleExecutableResource (),node_sea.cc,"SeaResource FindSingleExecutableResource() {
  CHECK(IsSingleExecutable());
  static const SeaResource sea_resource = []() -> SeaResource {
    size_t size;
#ifdef __APPLE__
    postject_options options;
    postject_options_init(&options);
    options.macho_segment_name = ""NODE_SEA"";
    const char* code = static_cast<const char*>(
        postject_find_resource(""NODE_SEA_BLOB"", &size, &options));
#else
    const char* code = static_cast<const char*>(
        postject_find_resource(""NODE_SEA_BLOB"", &size, nullptr));
#endif
    uint32_t first_word = reinterpret_cast<const uint32_t*>(code)[0];
    CHECK_EQ(first_word, kMagic);
    SeaFlags flags{
        reinterpret_cast<const SeaFlags*>(code + sizeof(first_word))[0]};
    // TODO(joyeecheung): do more checks here e.g. matching the versions.
    return {
        flags,
        {
            code + SeaResource::kHeaderSize,
            size - SeaResource::kHeaderSize,
        },
    };
  }();
  return sea_resource;
}",68.0,96.0,1.0,1.0,29.0,1,1,2,1,0,1,1,1,0,0,,0,1,0,0,0,SeaResource
4285,226109,FindSingleExecutableCode,1,node.sea.FindSingleExecutableCode,string_view node.sea.FindSingleExecutableCode (),node_sea.cc,"std::string_view FindSingleExecutableCode() {
  SeaResource sea_resource = FindSingleExecutableResource();
  return sea_resource.code;
}",100.0,103.0,1.0,1.0,4.0,2,2,2,1,0,1,1,1,0,0,,0,1,0,0,0,string_view
4286,226121,IsSingleExecutable,1,node.sea.IsSingleExecutable,bool node.sea.IsSingleExecutable (),node_sea.cc,"bool IsSingleExecutable() {
  return postject_has_resource();
}",105.0,107.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,bool
4287,226127,IsExperimentalSeaWarningNeeded,1,node.sea.IsExperimentalSeaWarningNeeded,void node.sea.IsExperimentalSeaWarningNeeded (FunctionCallbackInfo<Value>),node_sea.cc,"void IsExperimentalSeaWarningNeeded(const FunctionCallbackInfo<Value>& args) {
  if (!IsSingleExecutable()) {
    args.GetReturnValue().Set(false);
    return;
  }

  SeaResource sea_resource = FindSingleExecutableResource();
  args.GetReturnValue().Set(!static_cast<bool>(
      sea_resource.flags & SeaFlags::kDisableExperimentalSeaWarning));
}",109.0,118.0,1.0,1.0,10.0,11,5,5,3,0,2,2,2,0,0,,0,2,2,1,1,void
4288,226166,FixupArgsForSEA,1,node.sea.FixupArgsForSEA,"tuple<int,char **> node.sea.FixupArgsForSEA (int,char**)",node_sea.cc,"std::tuple<int, char**> FixupArgsForSEA(int argc, char** argv) {
  // Repeats argv[0] at position 1 on argv as a replacement for the missing
  // entry point file path.
  if (IsSingleExecutable()) {
    static std::vector<char*> new_argv;
    new_argv.reserve(argc + 2);
    new_argv.emplace_back(argv[0]);
    new_argv.insert(new_argv.end(), argv, argv + argc);
    new_argv.emplace_back(nullptr);
    argc = new_argv.size() - 1;
    argv = new_argv.data();
  }

  return {argc, argv};
}",120.0,134.0,1.0,1.0,15.0,13,5,14,3,0,0,2,2,0,0,,0,0,4,2,2,"tuple<int,char **>"
4289,226236,ParseSingleExecutableConfig,1,node.sea.anonymous_namespace_12.ParseSingleExecutableConfig,optional<SeaConfig> node.sea.anonymous_namespace_12.ParseSingleExecutableConfig (ANY),node_sea.cc,"std::optional<SeaConfig> ParseSingleExecutableConfig(
    const std::string& config_path) {
  std::string config;
  int r = ReadFileSync(&config, config_path.c_str());
  if (r != 0) {
    const char* err = uv_strerror(r);
    FPrintF(stderr,
            ""Cannot read single executable configuration from %s: %s\n"",
            config_path,
            err);
    return std::nullopt;
  }

  SeaConfig result;
  JSONParser parser;
  if (!parser.Parse(config)) {
    FPrintF(stderr, ""Cannot parse JSON from %s\n"", config_path);
    return std::nullopt;
  }

  result.main_path =
      parser.GetTopLevelStringField(""main"").value_or(std::string());
  if (result.main_path.empty()) {
    FPrintF(stderr,
            ""\""main\"" field of %s is not a non-empty string\n"",
            config_path);
    return std::nullopt;
  }

  result.output_path =
      parser.GetTopLevelStringField(""output"").value_or(std::string());
  if (result.output_path.empty()) {
    FPrintF(stderr,
            ""\""output\"" fiel...",144.0,195.0,1.0,1.0,52.0,33,5,39,10,0,6,7,7,2,0,,0,6,2,1,1,optional<SeaConfig>
4290,226391,GenerateSingleExecutableBlob,1,node.sea.anonymous_namespace_13.GenerateSingleExecutableBlob,bool node.sea.anonymous_namespace_13.GenerateSingleExecutableBlob (SeaConfig),node_sea.cc,"bool GenerateSingleExecutableBlob(const SeaConfig& config) {
  std::string main_script;
  // TODO(joyeecheung): unify the file utils.
  int r = ReadFileSync(&main_script, config.main_path.c_str());
  if (r != 0) {
    const char* err = uv_strerror(r);
    FPrintF(stderr, ""Cannot read main script %s:%s\n"", config.main_path, err);
    return false;
  }

  std::vector<char> sink;
  // TODO(joyeecheung): reuse the SnapshotSerializerDeserializer for this.
  sink.reserve(SeaResource::kHeaderSize + main_script.size());
  const char* pos = reinterpret_cast<const char*>(&kMagic);
  sink.insert(sink.end(), pos, pos + sizeof(kMagic));
  pos = reinterpret_cast<const char*>(&(config.flags));
  sink.insert(sink.end(), pos, pos + sizeof(SeaFlags));
  sink.insert(
      sink.end(), main_script.data(), main_script.data() + main_script.size());

  uv_buf_t buf = uv_buf_init(sink.data(), sink.size());
  r = WriteFileSync(config.output_path.c_str(), buf);
  if (r != 0) {
    const char* err = uv_strerr...",197.0,229.0,1.0,1.0,33.0,42,7,45,11,0,7,3,3,0,0,,0,7,2,1,1,bool
4291,226552,BuildSingleExecutableBlob,1,node.sea.BuildSingleExecutableBlob,ExitCode node.sea.BuildSingleExecutableBlob (ANY),node_sea.cc,"ExitCode BuildSingleExecutableBlob(const std::string& config_path) {
  std::optional<SeaConfig> config_opt =
      ParseSingleExecutableConfig(config_path);
  if (!config_opt.has_value() ||
      !GenerateSingleExecutableBlob(config_opt.value())) {
    return ExitCode::kGenericUserError;
  }

  return ExitCode::kNoFailure;
}",233.0,242.0,1.0,1.0,10.0,8,4,6,3,0,0,2,2,0,0,,0,0,2,1,1,ExitCode
4292,226584,Initialize,1,node.sea.Initialize,"void node.sea.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)",node_sea.cc,"void Initialize(Local<Object> target,
                Local<Value> unused,
                Local<Context> context,
                void* priv) {
  SetMethod(context,
            target,
            ""isExperimentalSeaWarningNeeded"",
            IsExperimentalSeaWarningNeeded);
}",244.0,252.0,1.0,1.0,9.0,0,0,2,2,0,0,1,1,0,0,,0,0,8,4,4,void
4293,226597,RegisterExternalReferences,1,node.sea.RegisterExternalReferences,void node.sea.RegisterExternalReferences (ExternalReferenceRegistry*),node_sea.cc,"void RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  registry->Register(IsExperimentalSeaWarningNeeded);
}",254.0,256.0,1.0,1.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,void
4294,226639,SerializerContext,1,node.serdes.SerializerContext.SerializerContext,"ANY node.serdes.SerializerContext.SerializerContext (Environment*,Local<Object>)",node_serdes.cc,"SerializerContext::SerializerContext(Environment* env, Local<Object> wrap)
  : BaseObject(env, wrap),
    serializer_(env->isolate(), this) {
  MakeWeak();
}",98.0,102.0,1.0,1.0,5.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,ANY
4295,226645,~SerializerContext,1,node.serdes.SerializerContext.~SerializerContext,ANY node.serdes.SerializerContext.~SerializerContext (),node_serdes.cc,~SerializerContext() override = default;,38.0,38.0,3.0,42.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
4296,226649,ThrowDataCloneError,1,node.serdes.SerializerContext.ThrowDataCloneError,void node.serdes.SerializerContext.ThrowDataCloneError (Local<String>),node_serdes.cc,"void SerializerContext::ThrowDataCloneError(Local<String> message) {
  Local<Value> args[1] = { message };
  Local<Value> get_data_clone_error =
      object()->Get(env()->context(),
                    env()->get_data_clone_error_string())
                      .ToLocalChecked();

  CHECK(get_data_clone_error->IsFunction());
  MaybeLocal<Value> error =
      get_data_clone_error.As<Function>()->Call(env()->context(),
                                                object(),
                                                arraysize(args),
                                                args);

  if (error.IsEmpty()) return;

  env()->isolate()->ThrowException(error.ToLocalChecked());
}",104.0,121.0,1.0,1.0,18.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
4297,226654,WriteHostObject,1,node.serdes.SerializerContext.WriteHostObject,"Maybe<bool> node.serdes.SerializerContext.WriteHostObject (Isolate*,Local<Object>)",node_serdes.cc,"Maybe<bool> SerializerContext::WriteHostObject(Isolate* isolate,
                                               Local<Object> input) {
  MaybeLocal<Value> ret;
  Local<Value> args[1] = { input };

  Local<Value> write_host_object =
      object()->Get(env()->context(),
                    env()->write_host_object_string()).ToLocalChecked();

  if (!write_host_object->IsFunction()) {
    return ValueSerializer::Delegate::WriteHostObject(isolate, input);
  }

  ret = write_host_object.As<Function>()->Call(env()->context(),
                                               object(),
                                               arraysize(args),
                                               args);

  if (ret.IsEmpty())
    return Nothing<bool>();

  return Just(true);
}",147.0,169.0,1.0,1.0,23.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,Maybe<bool>
4298,226660,GetSharedArrayBufferId,1,node.serdes.SerializerContext.GetSharedArrayBufferId,"Maybe<uint32_t> node.serdes.SerializerContext.GetSharedArrayBufferId (Isolate*,Local<SharedArrayBuffer>)",node_serdes.cc,"Maybe<uint32_t> SerializerContext::GetSharedArrayBufferId(
    Isolate* isolate, Local<SharedArrayBuffer> shared_array_buffer) {
  Local<Value> args[1] = { shared_array_buffer };
  Local<Value> get_shared_array_buffer_id =
      object()->Get(env()->context(),
                    env()->get_shared_array_buffer_id_string())
                      .ToLocalChecked();

  if (!get_shared_array_buffer_id->IsFunction()) {
    return ValueSerializer::Delegate::GetSharedArrayBufferId(
        isolate, shared_array_buffer);
  }

  MaybeLocal<Value> id =
      get_shared_array_buffer_id.As<Function>()->Call(env()->context(),
                                                      object(),
                                                      arraysize(args),
                                                      args);

  if (id.IsEmpty()) return Nothing<uint32_t>();

  return id.ToLocalChecked()->Uint32Value(env()->context());
}",123.0,145.0,1.0,1.0,23.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,Maybe<uint32_t>
4299,226666,SetTreatArrayBufferViewsAsHostObjects,1,node.serdes.SerializerContext.SetTreatArrayBufferViewsAsHostObjects,void node.serdes.SerializerContext.SetTreatArrayBufferViewsAsHostObjects (FunctionCallbackInfo<Value>),node_serdes.cc,"void SerializerContext::SetTreatArrayBufferViewsAsHostObjects(
    const FunctionCallbackInfo<Value>& args) {
  SerializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());

  bool value = args[0]->BooleanValue(ctx->env()->isolate());
  ctx->serializer_.SetTreatArrayBufferViewsAsHostObjects(value);
}",196.0,203.0,1.0,1.0,8.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
4300,226671,New,1,node.serdes.SerializerContext.New,void node.serdes.SerializerContext.New (FunctionCallbackInfo<Value>),node_serdes.cc,"void SerializerContext::New(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  if (!args.IsConstructCall()) {
    return THROW_ERR_CONSTRUCT_CALL_REQUIRED(
        env, ""Class constructor Serializer cannot be invoked without 'new'"");
  }

  new SerializerContext(env, args.This());
}",171.0,179.0,1.0,1.0,9.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
4301,226676,WriteHeader,1,node.serdes.SerializerContext.WriteHeader,void node.serdes.SerializerContext.WriteHeader (FunctionCallbackInfo<Value>),node_serdes.cc,"void SerializerContext::WriteHeader(const FunctionCallbackInfo<Value>& args) {
  SerializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());
  ctx->serializer_.WriteHeader();
}",181.0,185.0,1.0,1.0,5.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
4302,226681,WriteValue,1,node.serdes.SerializerContext.WriteValue,void node.serdes.SerializerContext.WriteValue (FunctionCallbackInfo<Value>),node_serdes.cc,"void SerializerContext::WriteValue(const FunctionCallbackInfo<Value>& args) {
  SerializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());
  Maybe<bool> ret =
      ctx->serializer_.WriteValue(ctx->env()->context(), args[0]);

  if (ret.IsJust()) args.GetReturnValue().Set(ret.FromJust());
}",187.0,194.0,1.0,1.0,8.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
4303,226686,ReleaseBuffer,1,node.serdes.SerializerContext.ReleaseBuffer,void node.serdes.SerializerContext.ReleaseBuffer (FunctionCallbackInfo<Value>),node_serdes.cc,"void SerializerContext::ReleaseBuffer(const FunctionCallbackInfo<Value>& args) {
  SerializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());

  // Note: Both ValueSerializer and this Buffer::New() variant use malloc()
  // as the underlying allocator.
  std::pair<uint8_t*, size_t> ret = ctx->serializer_.Release();
  auto buf = Buffer::New(ctx->env(),
                         reinterpret_cast<char*>(ret.first),
                         ret.second);

  if (!buf.IsEmpty()) {
    args.GetReturnValue().Set(buf.ToLocalChecked());
  }
}",205.0,219.0,1.0,1.0,15.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
4304,226691,TransferArrayBuffer,1,node.serdes.SerializerContext.TransferArrayBuffer,void node.serdes.SerializerContext.TransferArrayBuffer (FunctionCallbackInfo<Value>),node_serdes.cc,"void SerializerContext::TransferArrayBuffer(
    const FunctionCallbackInfo<Value>& args) {
  SerializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());

  Maybe<uint32_t> id = args[0]->Uint32Value(ctx->env()->context());
  if (id.IsNothing()) return;

  if (!args[1]->IsArrayBuffer())
    return node::THROW_ERR_INVALID_ARG_TYPE(
        ctx->env(), ""arrayBuffer must be an ArrayBuffer"");

  Local<ArrayBuffer> ab = args[1].As<ArrayBuffer>();
  ctx->serializer_.TransferArrayBuffer(id.FromJust(), ab);
  return;
}",221.0,236.0,1.0,1.0,16.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
4305,226696,WriteUint32,1,node.serdes.SerializerContext.WriteUint32,void node.serdes.SerializerContext.WriteUint32 (FunctionCallbackInfo<Value>),node_serdes.cc,"void SerializerContext::WriteUint32(const FunctionCallbackInfo<Value>& args) {
  SerializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());

  Maybe<uint32_t> value = args[0]->Uint32Value(ctx->env()->context());
  if (value.IsNothing()) return;

  ctx->serializer_.WriteUint32(value.FromJust());
}",238.0,246.0,1.0,1.0,9.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
4306,226701,WriteUint64,1,node.serdes.SerializerContext.WriteUint64,void node.serdes.SerializerContext.WriteUint64 (FunctionCallbackInfo<Value>),node_serdes.cc,"void SerializerContext::WriteUint64(const FunctionCallbackInfo<Value>& args) {
  SerializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());

  Maybe<uint32_t> arg0 = args[0]->Uint32Value(ctx->env()->context());
  Maybe<uint32_t> arg1 = args[1]->Uint32Value(ctx->env()->context());
  if (arg0.IsNothing() || arg1.IsNothing())
    return;

  uint64_t hi = arg0.FromJust();
  uint64_t lo = arg1.FromJust();
  ctx->serializer_.WriteUint64((hi << 32) | lo);
}",248.0,260.0,1.0,1.0,13.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
4307,226706,WriteDouble,1,node.serdes.SerializerContext.WriteDouble,void node.serdes.SerializerContext.WriteDouble (FunctionCallbackInfo<Value>),node_serdes.cc,"void SerializerContext::WriteDouble(const FunctionCallbackInfo<Value>& args) {
  SerializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());

  Maybe<double> value = args[0]->NumberValue(ctx->env()->context());
  if (value.IsNothing()) return;

  ctx->serializer_.WriteDouble(value.FromJust());
}",262.0,270.0,1.0,1.0,9.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
4308,226711,WriteRawBytes,1,node.serdes.SerializerContext.WriteRawBytes,void node.serdes.SerializerContext.WriteRawBytes (FunctionCallbackInfo<Value>),node_serdes.cc,"void SerializerContext::WriteRawBytes(const FunctionCallbackInfo<Value>& args) {
  SerializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());

  if (!args[0]->IsArrayBufferView()) {
    return node::THROW_ERR_INVALID_ARG_TYPE(
        ctx->env(), ""source must be a TypedArray or a DataView"");
  }

  ArrayBufferViewContents<char> bytes(args[0]);
  ctx->serializer_.WriteRawBytes(bytes.data(), bytes.length());
}",272.0,283.0,1.0,1.0,12.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
4309,226718,DeserializerContext,1,node.serdes.DeserializerContext.DeserializerContext,"ANY node.serdes.DeserializerContext.DeserializerContext (Environment*,Local<Object>,Local<Value>)",node_serdes.cc,"DeserializerContext::DeserializerContext(Environment* env,
                                         Local<Object> wrap,
                                         Local<Value> buffer)
  : BaseObject(env, wrap),
    data_(reinterpret_cast<const uint8_t*>(Buffer::Data(buffer))),
    length_(Buffer::Length(buffer)),
    deserializer_(env->isolate(), data_, length_, this) {
  object()->Set(env->context(), env->buffer_string(), buffer).Check();

  MakeWeak();
}",285.0,295.0,1.0,1.0,11.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,ANY
4310,226725,~DeserializerContext,1,node.serdes.DeserializerContext.~DeserializerContext,ANY node.serdes.DeserializerContext.~DeserializerContext (),node_serdes.cc,~DeserializerContext() override = default;,73.0,73.0,3.0,44.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
4311,226729,ReadHostObject,1,node.serdes.DeserializerContext.ReadHostObject,MaybeLocal<Object> node.serdes.DeserializerContext.ReadHostObject (Isolate*),node_serdes.cc,"MaybeLocal<Object> DeserializerContext::ReadHostObject(Isolate* isolate) {
  Local<Value> read_host_object =
      object()->Get(env()->context(),
                    env()->read_host_object_string()).ToLocalChecked();

  if (!read_host_object->IsFunction()) {
    return ValueDeserializer::Delegate::ReadHostObject(isolate);
  }

  Isolate::AllowJavascriptExecutionScope allow_js(isolate);
  MaybeLocal<Value> ret =
      read_host_object.As<Function>()->Call(env()->context(),
                                            object(),
                                            0,
                                            nullptr);

  if (ret.IsEmpty())
    return MaybeLocal<Object>();

  Local<Value> return_value = ret.ToLocalChecked();
  if (!return_value->IsObject()) {
    env()->ThrowTypeError(""readHostObject must return an object"");
    return MaybeLocal<Object>();
  }

  return return_value.As<Object>();
}",297.0,323.0,1.0,1.0,27.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,MaybeLocal<Object>
4312,226734,New,1,node.serdes.DeserializerContext.New,void node.serdes.DeserializerContext.New (FunctionCallbackInfo<Value>),node_serdes.cc,"void DeserializerContext::New(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  if (!args.IsConstructCall()) {
    return THROW_ERR_CONSTRUCT_CALL_REQUIRED(
        env, ""Class constructor Deserializer cannot be invoked without 'new'"");
  }

  if (!args[0]->IsArrayBufferView()) {
    return node::THROW_ERR_INVALID_ARG_TYPE(
        env, ""buffer must be a TypedArray or a DataView"");
  }

  new DeserializerContext(env, args.This(), args[0]);
}",325.0,338.0,1.0,1.0,14.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
4313,226739,ReadHeader,1,node.serdes.DeserializerContext.ReadHeader,void node.serdes.DeserializerContext.ReadHeader (FunctionCallbackInfo<Value>),node_serdes.cc,"void DeserializerContext::ReadHeader(const FunctionCallbackInfo<Value>& args) {
  DeserializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());

  Maybe<bool> ret = ctx->deserializer_.ReadHeader(ctx->env()->context());

  if (ret.IsJust()) args.GetReturnValue().Set(ret.FromJust());
}",340.0,347.0,1.0,1.0,8.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
4314,226744,ReadValue,1,node.serdes.DeserializerContext.ReadValue,void node.serdes.DeserializerContext.ReadValue (FunctionCallbackInfo<Value>),node_serdes.cc,"void DeserializerContext::ReadValue(const FunctionCallbackInfo<Value>& args) {
  DeserializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());

  MaybeLocal<Value> ret = ctx->deserializer_.ReadValue(ctx->env()->context());

  if (!ret.IsEmpty()) args.GetReturnValue().Set(ret.ToLocalChecked());
}",349.0,356.0,1.0,1.0,8.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
4315,226749,TransferArrayBuffer,1,node.serdes.DeserializerContext.TransferArrayBuffer,void node.serdes.DeserializerContext.TransferArrayBuffer (FunctionCallbackInfo<Value>),node_serdes.cc,"void DeserializerContext::TransferArrayBuffer(
    const FunctionCallbackInfo<Value>& args) {
  DeserializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());

  Maybe<uint32_t> id = args[0]->Uint32Value(ctx->env()->context());
  if (id.IsNothing()) return;

  if (args[1]->IsArrayBuffer()) {
    Local<ArrayBuffer> ab = args[1].As<ArrayBuffer>();
    ctx->deserializer_.TransferArrayBuffer(id.FromJust(), ab);
    return;
  }

  if (args[1]->IsSharedArrayBuffer()) {
    Local<SharedArrayBuffer> sab = args[1].As<SharedArrayBuffer>();
    ctx->deserializer_.TransferSharedArrayBuffer(id.FromJust(), sab);
    return;
  }

  return node::THROW_ERR_INVALID_ARG_TYPE(
      ctx->env(), ""arrayBuffer must be an ArrayBuffer or SharedArrayBuffer"");
}",358.0,380.0,1.0,1.0,23.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
4316,226754,GetWireFormatVersion,1,node.serdes.DeserializerContext.GetWireFormatVersion,void node.serdes.DeserializerContext.GetWireFormatVersion (FunctionCallbackInfo<Value>),node_serdes.cc,"void DeserializerContext::GetWireFormatVersion(
    const FunctionCallbackInfo<Value>& args) {
  DeserializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());

  args.GetReturnValue().Set(ctx->deserializer_.GetWireFormatVersion());
}",382.0,388.0,1.0,1.0,7.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
4317,226759,ReadUint32,1,node.serdes.DeserializerContext.ReadUint32,void node.serdes.DeserializerContext.ReadUint32 (FunctionCallbackInfo<Value>),node_serdes.cc,"void DeserializerContext::ReadUint32(const FunctionCallbackInfo<Value>& args) {
  DeserializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());

  uint32_t value;
  bool ok = ctx->deserializer_.ReadUint32(&value);
  if (!ok) return ctx->env()->ThrowError(""ReadUint32() failed"");
  return args.GetReturnValue().Set(value);
}",390.0,398.0,1.0,1.0,9.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
4318,226764,ReadUint64,1,node.serdes.DeserializerContext.ReadUint64,void node.serdes.DeserializerContext.ReadUint64 (FunctionCallbackInfo<Value>),node_serdes.cc,"void DeserializerContext::ReadUint64(const FunctionCallbackInfo<Value>& args) {
  DeserializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());

  uint64_t value;
  bool ok = ctx->deserializer_.ReadUint64(&value);
  if (!ok) return ctx->env()->ThrowError(""ReadUint64() failed"");

  uint32_t hi = static_cast<uint32_t>(value >> 32);
  uint32_t lo = static_cast<uint32_t>(value);

  Isolate* isolate = ctx->env()->isolate();

  Local<Value> ret[] = {
    Integer::NewFromUnsigned(isolate, hi),
    Integer::NewFromUnsigned(isolate, lo)
  };
  return args.GetReturnValue().Set(Array::New(isolate, ret, arraysize(ret)));
}",400.0,418.0,1.0,1.0,19.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
4319,226769,ReadDouble,1,node.serdes.DeserializerContext.ReadDouble,void node.serdes.DeserializerContext.ReadDouble (FunctionCallbackInfo<Value>),node_serdes.cc,"void DeserializerContext::ReadDouble(const FunctionCallbackInfo<Value>& args) {
  DeserializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());

  double value;
  bool ok = ctx->deserializer_.ReadDouble(&value);
  if (!ok) return ctx->env()->ThrowError(""ReadDouble() failed"");
  return args.GetReturnValue().Set(value);
}",420.0,428.0,1.0,1.0,9.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
4320,226774,ReadRawBytes,1,node.serdes.DeserializerContext.ReadRawBytes,void node.serdes.DeserializerContext.ReadRawBytes (FunctionCallbackInfo<Value>),node_serdes.cc,"void DeserializerContext::ReadRawBytes(
    const FunctionCallbackInfo<Value>& args) {
  DeserializerContext* ctx;
  ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());

  Maybe<int64_t> length_arg = args[0]->IntegerValue(ctx->env()->context());
  if (length_arg.IsNothing()) return;
  size_t length = length_arg.FromJust();

  const void* data;
  bool ok = ctx->deserializer_.ReadRawBytes(length, &data);
  if (!ok) return ctx->env()->ThrowError(""ReadRawBytes() failed"");

  const uint8_t* position = reinterpret_cast<const uint8_t*>(data);
  CHECK_GE(position, ctx->data_);
  CHECK_LE(position + length, ctx->data_ + ctx->length_);

  const uint32_t offset = static_cast<uint32_t>(position - ctx->data_);
  CHECK_EQ(ctx->data_ + offset, position);

  args.GetReturnValue().Set(offset);
}",430.0,451.0,1.0,1.0,22.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
4321,228270,Initialize,1,node.serdes.Initialize,"void node.serdes.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)",node_serdes.cc,"void Initialize(Local<Object> target,
                Local<Value> unused,
                Local<Context> context,
                void* priv) {
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  Local<FunctionTemplate> ser =
      NewFunctionTemplate(isolate, SerializerContext::New);

  ser->InstanceTemplate()->SetInternalFieldCount(
      SerializerContext::kInternalFieldCount);

  SetProtoMethod(isolate, ser, ""writeHeader"", SerializerContext::WriteHeader);
  SetProtoMethod(isolate, ser, ""writeValue"", SerializerContext::WriteValue);
  SetProtoMethod(
      isolate, ser, ""releaseBuffer"", SerializerContext::ReleaseBuffer);
  SetProtoMethod(isolate,
                 ser,
                 ""transferArrayBuffer"",
                 SerializerContext::TransferArrayBuffer);
  SetProtoMethod(isolate, ser, ""writeUint32"", SerializerContext::WriteUint32);
  SetProtoMethod(isolate, ser, ""writeUint64"", SerializerContext::WriteUint64);
  SetProtoMethod(i...",453.0,512.0,1.0,1.0,60.0,38,5,79,11,0,0,1,1,0,0,,0,0,8,4,4,void
4322,228477,RegisterExternalReferences,1,node.serdes.RegisterExternalReferences,void node.serdes.RegisterExternalReferences (ExternalReferenceRegistry*),node_serdes.cc,"void RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  registry->Register(SerializerContext::New);

  registry->Register(SerializerContext::WriteHeader);
  registry->Register(SerializerContext::WriteValue);
  registry->Register(SerializerContext::ReleaseBuffer);
  registry->Register(SerializerContext::TransferArrayBuffer);
  registry->Register(SerializerContext::WriteUint32);
  registry->Register(SerializerContext::WriteUint64);
  registry->Register(SerializerContext::WriteDouble);
  registry->Register(SerializerContext::WriteRawBytes);
  registry->Register(SerializerContext::SetTreatArrayBufferViewsAsHostObjects);

  registry->Register(DeserializerContext::New);
  registry->Register(DeserializerContext::ReadHeader);
  registry->Register(DeserializerContext::ReadValue);
  registry->Register(DeserializerContext::GetWireFormatVersion);
  registry->Register(DeserializerContext::TransferArrayBuffer);
  registry->Register(DeserializerContext::ReadUint32);
  registry->Re...",514.0,536.0,1.0,1.0,23.0,38,2,38,3,0,0,1,1,0,0,,0,0,2,1,1,void
4323,228630,New,1,node.shadow_realm.ShadowRealm.New,ShadowRealm node.shadow_realm.ShadowRealm.New (Environment*),node_shadow_realm.cc,"ShadowRealm* ShadowRealm::New(Environment* env) {
  ShadowRealm* realm = new ShadowRealm(env);
  env->AssignToContext(realm->context(), realm, ContextInfo(""""));

  // We do not expect the realm bootstrapping to throw any
  // exceptions. If it does, exit the current Node.js instance.
  TryCatchScope try_catch(env, TryCatchScope::CatchMode::kFatal);
  if (realm->RunBootstrapping().IsEmpty()) {
    delete realm;
    return nullptr;
  }
  return realm;
}",16.0,28.0,1.0,1.0,13.0,9,5,12,5,0,0,2,2,0,0,,0,0,2,1,1,ShadowRealm
4324,228675,HostCreateShadowRealmContextCallback,1,node.shadow_realm.HostCreateShadowRealmContextCallback,MaybeLocal<Context> node.shadow_realm.HostCreateShadowRealmContextCallback (Local<Context>),node_shadow_realm.cc,"MaybeLocal<Context> HostCreateShadowRealmContextCallback(
    Local<Context> initiator_context) {
  Environment* env = Environment::GetCurrent(initiator_context);
  ShadowRealm* realm = ShadowRealm::New(env);
  if (realm != nullptr) {
    return realm->context();
  }
  return MaybeLocal<Context>();
}",31.0,39.0,1.0,1.0,9.0,6,4,8,5,0,0,2,2,0,0,,0,0,2,1,1,MaybeLocal<Context>
4325,228708,WeakCallback,1,node.shadow_realm.ShadowRealm.WeakCallback,void node.shadow_realm.ShadowRealm.WeakCallback (ANY),node_shadow_realm.cc,"void ShadowRealm::WeakCallback(const v8::WeakCallbackInfo<ShadowRealm>& data) {
  ShadowRealm* realm = data.GetParameter();
  delete realm;
}",42.0,45.0,1.0,1.0,4.0,3,3,3,2,0,0,1,1,0,0,,0,0,2,1,1,void
4326,228722,ShadowRealm,1,node.shadow_realm.ShadowRealm.ShadowRealm,ANY node.shadow_realm.ShadowRealm.ShadowRealm (Environment*),node_shadow_realm.cc,"ShadowRealm::ShadowRealm(Environment* env)
    : Realm(env, NewContext(env->isolate()), kShadowRealm) {
  env->TrackShadowRealm(this);
  context_.SetWeak(this, WeakCallback, v8::WeakCallbackType::kParameter);
  CreateProperties();
}",47.0,52.0,1.0,1.0,6.0,4,2,5,5,0,0,1,1,0,0,,0,0,2,1,1,ANY
4327,228744,~ShadowRealm,1,node.shadow_realm.ShadowRealm.~ShadowRealm,ANY node.shadow_realm.ShadowRealm.~ShadowRealm (),node_shadow_realm.cc,"ShadowRealm::~ShadowRealm() {
  while (HasCleanupHooks()) {
    RunCleanup();
  }
  if (env_ != nullptr) {
    env_->UntrackShadowRealm(this);
  }
}",54.0,61.0,1.0,1.0,8.0,2,2,2,1,0,0,3,3,0,0,,0,0,0,0,0,ANY
4328,228762,OnEnvironmentDestruct,1,node.shadow_realm.ShadowRealm.OnEnvironmentDestruct,void node.shadow_realm.ShadowRealm.OnEnvironmentDestruct (),node_shadow_realm.cc,"void ShadowRealm::OnEnvironmentDestruct() {
  CHECK_NOT_NULL(env_);
  env_ = nullptr;  // This means that the shadow realm has out-lived the
                   // environment.
}",63.0,67.0,1.0,1.0,5.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,void
4329,228770,context,1,node.shadow_realm.ShadowRealm.context,Local<v8::Context> node.shadow_realm.ShadowRealm.context (),node_shadow_realm.cc,"v8::Local<v8::Context> ShadowRealm::context() const {
  Local<Context> ctx = PersistentToLocal::Default(isolate_, context_);
  DCHECK(!ctx.IsEmpty());
  return ctx;
}",69.0,73.0,1.0,1.0,5.0,6,5,8,6,0,0,1,1,0,0,,0,0,0,0,0,Local<v8.Context>
4330,228796,BootstrapRealm,1,node.shadow_realm.ShadowRealm.BootstrapRealm,MaybeLocal<v8::Value> node.shadow_realm.ShadowRealm.BootstrapRealm (),node_shadow_realm.cc,"v8::MaybeLocal<v8::Value> ShadowRealm::BootstrapRealm() {
  HandleScope scope(isolate_);

  // Skip ""internal/bootstrap/node"" as it installs node globals and per-isolate
  // callbacks.

  if (!env_->no_browser_globals()) {
    if (ExecuteBootstrapper(""internal/bootstrap/web/exposed-wildcard"")
            .IsEmpty()) {
      return MaybeLocal<Value>();
    }
  }

  return v8::True(isolate_);
}",104.0,118.0,1.0,1.0,15.0,4,3,4,3,0,0,3,4,0,0,,0,0,0,0,0,MaybeLocal<v8.Value>
4331,228855,GetEmbeddedSnapshotData,1,node.SnapshotBuilder.GetEmbeddedSnapshotData,SnapshotData node.SnapshotBuilder.GetEmbeddedSnapshotData (),node_snapshot_stub.cc,"const SnapshotData* SnapshotBuilder::GetEmbeddedSnapshotData() {
  return nullptr;
}",9.0,11.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,SnapshotData
4332,228862,<lambda>0,1,node.SnapshotBuilder.Generate.<lambda>0,ANY node.SnapshotBuilder.Generate.<lambda>0 (),node_snapshotable.cc,"[&]() {
      if (bootstrapCatch.HasCaught()) {
        PrintCaughtException(
            isolate, isolate->GetCurrentContext(), bootstrapCatch);
      }
    }",867.0,872.0,41.0,5.0,6.0,2,2,4,2,0,0,2,2,0,0,,0,0,0,0,0,ANY
4333,228883,<lambda>1,1,node.SnapshotBuilder.CreateSnapshot.<lambda>1,ANY node.SnapshotBuilder.CreateSnapshot.<lambda>1 (Realm*),node_snapshotable.cc,[](Realm* realm) { realm->PrintInfoForSnapshot(); },948.0,948.0,27.0,77.0,1.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,ANY
4334,228893,<lambda>2,1,node.SerializeSnapshotableObjects.<lambda>2,ANY node.SerializeSnapshotableObjects.<lambda>2 (BaseObject*),node_snapshotable.cc,"[&](BaseObject* obj) {
    // If there are any BaseObjects that are not snapshotable left
    // during context serialization, V8 would crash due to unregistered
    // global handles and print detailed information about them.
    if (!obj->is_snapshotable()) {
      return;
    }
    SnapshotableObject* ptr = static_cast<SnapshotableObject*>(obj);

    std::string type_name = ptr->GetTypeName();
    per_process::Debug(DebugCategory::MKSNAPSHOT,
                       ""Serialize snapshotable object %i (%p), ""
                       ""object=%p, type=%s\n"",
                       static_cast<int>(i),
                       ptr,
                       *(ptr->object()),
                       type_name);

    if (ptr->PrepareForSerialization(context, creator)) {
      SnapshotIndex index = creator->AddData(context, obj->object());
      per_process::Debug(DebugCategory::MKSNAPSHOT,
                         ""Serialized with index=%d\n"",
                         static_cast<int>(index));
...",1147.0,1173.0,28.0,3.0,27.0,22,8,26,10,0,0,3,3,0,0,,0,0,2,1,1,ANY
4335,228984,<lambda>3,1,node.mksnapshot.GetEmbedderEntryFunction.<lambda>3,ANY node.mksnapshot.GetEmbedderEntryFunction.<lambda>3 (FunctionCallbackInfo<Value>),node_snapshotable.cc,"[](const FunctionCallbackInfo<Value>& args) {
                      Environment* env = Environment::GetCurrent(args);
                      Local<Value> require_fn = args[0];
                      Local<Value> runcjs_fn = args[1];
                      CHECK(require_fn->IsFunction());
                      CHECK(runcjs_fn->IsFunction());
                      MaybeLocal<Value> retval = env->embedder_entry_point()(
                          {env->process_object(),
                           require_fn.As<Function>(),
                           runcjs_fn.As<Function>()});
                      if (!retval.IsEmpty())
                        args.GetReturnValue().Set(retval.ToLocalChecked());
                    }",1185.0,1197.0,21.0,21.0,13.0,25,8,23,9,0,0,2,2,0,0,,0,0,2,1,1,ANY
4336,229411,SnapshotDeserializer,1,node.SnapshotDeserializer.SnapshotDeserializer,ANY node.SnapshotDeserializer.SnapshotDeserializer (ANY),node_snapshotable.cc,"explicit SnapshotDeserializer(std::string_view v)
      : BlobDeserializer<SnapshotDeserializer>(
            per_process::enabled_debug_list.enabled(DebugCategory::MKSNAPSHOT),
            v) {}",146.0,149.0,3.0,17.0,4.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
4337,229416,Read,1,node.SnapshotDeserializer.Read,"T node.SnapshotDeserializer.Read<T,std::enable_if_t<!std::is_same<T,std::string>::value>*=nullptr,std::enable_if_t<!std::is_arithmetic<T>::value>*=nullptr> ()",node_snapshotable.cc,"SnapshotMetadata SnapshotDeserializer::Read() {
  Debug(""Read<SnapshotMetadata>()\n"");

  SnapshotMetadata result;
  result.type = static_cast<SnapshotMetadata::Type>(ReadArithmetic<uint8_t>());
  result.node_version = ReadString();
  result.node_arch = ReadString();
  result.node_platform = ReadString();
  result.v8_cache_version_tag = ReadArithmetic<uint32_t>();

  if (is_debug) {
    std::string str = ToStr(result);
    Debug(""Read<SnapshotMetadata>() %s\n"", str.c_str());
  }
  return result;
}",530.0,545.0,1.0,1.0,16.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,SnapshotMetadata
4338,229421,SnapshotSerializer,1,node.SnapshotSerializer.SnapshotSerializer,ANY node.SnapshotSerializer.SnapshotSerializer (),node_snapshotable.cc,"SnapshotSerializer()
      : BlobSerializer<SnapshotSerializer>(
            per_process::enabled_debug_list.enabled(
                DebugCategory::MKSNAPSHOT)) {}",159.0,162.0,3.0,46.0,4.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
4339,229425,Write,1,node.SnapshotSerializer.Write,"size_t node.SnapshotSerializer.Write<T,std::enable_if_t<!std::is_same<T,std::string>::value>*=nullptr,std::enable_if_t<!std::is_arithmetic<T>::value>*=nullptr> (T)",node_snapshotable.cc,"size_t SnapshotSerializer::Write(const SnapshotMetadata& data) {
  if (is_debug) {
    std::string str = ToStr(data);
    Debug(""\nWrite<SnapshotMetadata>() %s\n"", str.c_str());
  }
  size_t written_total = 0;
  // We need the Node.js version, platform and arch to match because
  // Node.js may perform synchronizations that are platform-specific and they
  // can be changed in semver-patches.
  Debug(""Write snapshot type %"" PRIu8 ""\n"", static_cast<uint8_t>(data.type));
  written_total += WriteArithmetic<uint8_t>(static_cast<uint8_t>(data.type));
  Debug(""Write Node.js version %s\n"", data.node_version.c_str());
  written_total += WriteString(data.node_version);
  Debug(""Write Node.js arch %s\n"", data.node_arch);
  written_total += WriteString(data.node_arch);
  Debug(""Write Node.js platform %s\n"", data.node_platform);
  written_total += WriteString(data.node_platform);
  Debug(""Write V8 cached data version tag %"" PRIx32 ""\n"",
        data.v8_cache_version_tag);
  written_total += Wri...",548.0,569.0,1.0,1.0,22.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,size_t
4340,230490,ToBlob,1,node.SnapshotData.ToBlob,vector<char> node.SnapshotData.ToBlob (),node_snapshotable.cc,"std::vector<char> SnapshotData::ToBlob() const {
  SnapshotSerializer w;
  w.Debug(""SnapshotData::ToBlob()\n"");

  size_t written_total = 0;

  // Metadata
  w.Debug(""Write magic %"" PRIx32 ""\n"", kMagic);
  written_total += w.WriteArithmetic<uint32_t>(kMagic);
  w.Debug(""Write metadata\n"");
  written_total += w.Write<SnapshotMetadata>(metadata);

  written_total += w.Write<v8::StartupData>(v8_snapshot_blob_data);
  w.Debug(""Write isolate_data_indices\n"");
  written_total += w.Write<IsolateDataSerializeInfo>(isolate_data_info);
  written_total += w.Write<EnvSerializeInfo>(env_info);
  w.Debug(""Write code_cache\n"");
  written_total += w.WriteVector<builtins::CodeCacheInfo>(code_cache);
  w.Debug(""SnapshotData::ToBlob() Wrote %d bytes\n"", written_total);
  return w.sink;
}",582.0,602.0,1.0,1.0,21.0,33,5,32,14,0,0,1,1,0,0,,0,0,0,0,0,vector<char>
4341,230588,ToFile,1,node.SnapshotData.ToFile,void node.SnapshotData.ToFile (FILE*),node_snapshotable.cc,"void SnapshotData::ToFile(FILE* out) const {
  const std::vector<char> sink = ToBlob();
  size_t num_written = fwrite(sink.data(), sink.size(), 1, out);
  CHECK_EQ(num_written, 1);
  CHECK_EQ(fflush(out), 0);
}",604.0,609.0,1.0,1.0,6.0,4,2,7,3,0,0,1,1,0,0,,0,0,2,1,1,void
4342,230618,FromEmbedderWrapper,1,node.SnapshotData.FromEmbedderWrapper,SnapshotData node.SnapshotData.FromEmbedderWrapper (EmbedderSnapshotData*),node_snapshotable.cc,"const SnapshotData* SnapshotData::FromEmbedderWrapper(
    const EmbedderSnapshotData* data) {
  return data != nullptr ? data->impl_ : nullptr;
}",611.0,614.0,1.0,1.0,4.0,3,3,2,1,0,1,1,1,0,0,,0,1,2,1,1,SnapshotData
4343,230632,AsEmbedderWrapper,1,node.SnapshotData.AsEmbedderWrapper,Pointer node.SnapshotData.AsEmbedderWrapper (),node_snapshotable.cc,"EmbedderSnapshotData::Pointer SnapshotData::AsEmbedderWrapper() const {
  return EmbedderSnapshotData::Pointer{new EmbedderSnapshotData(this, false)};
}",616.0,618.0,1.0,1.0,3.0,2,2,1,1,0,0,1,1,0,0,,0,0,0,0,0,Pointer
4344,230643,FromFile,1,node.SnapshotData.FromFile,"bool node.SnapshotData.FromFile (SnapshotData*,FILE*)",node_snapshotable.cc,"bool SnapshotData::FromFile(SnapshotData* out, FILE* in) {
  return FromBlob(out, ReadFileSync(in));
}",620.0,622.0,1.0,1.0,3.0,0,0,2,2,0,0,1,1,0,0,,0,0,4,2,2,bool
4345,230654,FromBlob,1,node.SnapshotData.FromBlob,"bool node.SnapshotData.FromBlob (SnapshotData*,ANY)",node_snapshotable.cc,"bool SnapshotData::FromBlob(SnapshotData* out, std::string_view in) {
  SnapshotDeserializer r(in);
  r.Debug(""SnapshotData::FromBlob()\n"");

  DCHECK_EQ(out->data_ownership, SnapshotData::DataOwnership::kOwned);

  // Metadata
  uint32_t magic = r.ReadArithmetic<uint32_t>();
  r.Debug(""Read magic %"" PRIx32 ""\n"", magic);
  CHECK_EQ(magic, kMagic);
  out->metadata = r.Read<SnapshotMetadata>();
  r.Debug(""Read metadata\n"");
  if (!out->Check()) {
    return false;
  }

  out->v8_snapshot_blob_data = r.Read<v8::StartupData>();
  r.Debug(""Read isolate_data_info\n"");
  out->isolate_data_info = r.Read<IsolateDataSerializeInfo>();
  out->env_info = r.Read<EnvSerializeInfo>();
  r.Debug(""Read code_cache\n"");
  out->code_cache = r.ReadVector<builtins::CodeCacheInfo>();

  r.Debug(""SnapshotData::FromBlob() read %d bytes\n"", r.read_total);
  return true;
}",628.0,653.0,1.0,1.0,26.0,3,1,4,3,0,0,1,1,0,0,,0,0,4,2,2,bool
4346,230783,Check,1,node.SnapshotData.Check,bool node.SnapshotData.Check (),node_snapshotable.cc,"bool SnapshotData::Check() const {
  if (metadata.node_version != per_process::metadata.versions.node) {
    fprintf(stderr,
            ""Failed to load the startup snapshot because it was built with""
            ""Node.js version %s and the current Node.js version is %s.\n"",
            metadata.node_version.c_str(),
            NODE_VERSION);
    return false;
  }

  if (metadata.node_arch != per_process::metadata.arch) {
    fprintf(stderr,
            ""Failed to load the startup snapshot because it was built with""
            ""architecture %s and the architecture is %s.\n"",
            metadata.node_arch.c_str(),
            NODE_ARCH);
    return false;
  }

  if (metadata.node_platform != per_process::metadata.platform) {
    fprintf(stderr,
            ""Failed to load the startup snapshot because it was built with""
            ""platform %s and the current platform is %s.\n"",
            metadata.node_platform.c_str(),
            NODE_PLATFORM);
    return false;
  }

  uint32...",655.0,700.0,1.0,1.0,46.0,29,5,23,11,0,0,5,5,0,0,,0,0,0,0,0,bool
4347,230889,~SnapshotData,1,node.SnapshotData.~SnapshotData,ANY node.SnapshotData.~SnapshotData (),node_snapshotable.cc,"SnapshotData::~SnapshotData() {
  if (data_ownership == DataOwnership::kOwned &&
      v8_snapshot_blob_data.data != nullptr) {
    delete[] v8_snapshot_blob_data.data;
  }
}",702.0,707.0,1.0,1.0,6.0,7,5,4,3,0,0,2,2,0,0,,0,0,0,0,0,ANY
4348,230910,WriteVector,1,node.WriteVector,"void node.WriteVector<T> (ANY*,T*,size_t)",node_snapshotable.cc,"void WriteVector(std::ostream* ss, const T* vec, size_t size) {
  for (size_t i = 0; i < size; i++) {
    *ss << std::to_string(vec[i]) << (i == size - 1 ? '\n' : ',');
  }
}",710.0,714.0,1.0,1.0,5.0,10,9,9,5,0,0,2,2,0,0,,0,0,6,3,3,void
4349,230948,GetCodeCacheDefName,1,node.GetCodeCacheDefName,string node.GetCodeCacheDefName (ANY),node_snapshotable.cc,"static std::string GetCodeCacheDefName(const std::string& id) {
  char buf[64] = {0};
  size_t size = id.size();
  CHECK_LT(size, sizeof(buf));
  for (size_t i = 0; i < size; ++i) {
    char ch = id[i];
    buf[i] = (ch == '-' || ch == '/') ? '_' : ch;
  }
  return std::string(buf) + std::string(""_cache_data"");
}",716.0,725.0,1.0,1.0,10.0,18,10,19,6,0,0,2,2,0,0,,0,0,2,1,1,string
4350,231013,FormatSize,1,node.FormatSize,string node.FormatSize (size_t),node_snapshotable.cc,"static std::string FormatSize(size_t size) {
  char buf[64] = {0};
  if (size < 1024) {
    snprintf(buf, sizeof(buf), ""%.2fB"", static_cast<double>(size));
  } else if (size < 1024 * 1024) {
    snprintf(buf, sizeof(buf), ""%.2fKB"", static_cast<double>(size / 1024));
  } else {
    snprintf(
        buf, sizeof(buf), ""%.2fMB"", static_cast<double>(size / 1024 / 1024));
  }
  return buf;
}",727.0,738.0,1.0,1.0,12.0,5,5,6,2,0,0,2,2,0,0,,0,0,2,1,1,string
4351,231071,WriteStaticCodeCacheData,1,node.WriteStaticCodeCacheData,"void node.WriteStaticCodeCacheData (ANY*,ANY)",node_snapshotable.cc,"static void WriteStaticCodeCacheData(std::ostream* ss,
                                     const builtins::CodeCacheInfo& info) {
  *ss << ""static const uint8_t "" << GetCodeCacheDefName(info.id) << ""[] = {\n"";
  WriteVector(ss, info.data.data, info.data.length);
  *ss << ""};"";
}",740.0,745.0,1.0,1.0,6.0,11,3,6,2,0,0,1,1,0,0,,0,0,4,2,2,void
4352,231104,WriteCodeCacheInitializer,1,node.WriteCodeCacheInitializer,"void node.WriteCodeCacheInitializer (ANY*,ANY)",node_snapshotable.cc,"static void WriteCodeCacheInitializer(std::ostream* ss, const std::string& id) {
  std::string def_name = GetCodeCacheDefName(id);
  *ss << ""    { \"""" << id << ""\"",\n"";
  *ss << ""      {"" << def_name << "",\n"";
  *ss << ""       arraysize("" << def_name << ""),\n"";
  *ss << ""      }\n"";
  *ss << ""    },\n"";
}",747.0,754.0,1.0,1.0,8.0,17,3,10,3,0,0,1,1,0,0,,0,0,4,2,2,void
4353,231147,FormatBlob,1,node.FormatBlob,"void node.FormatBlob (ANY,SnapshotData*)",node_snapshotable.cc,"void FormatBlob(std::ostream& ss, const SnapshotData* data) {
  ss << R""(#include <cstddef>
#include ""env.hpp""
#include ""node_snapshot_builder.hpp""
#include ""v8.hpp""

// This file is generated by tools/snapshot. Do not edit.

namespace node {

static const char v8_snapshot_blob_data[] = {
)"";
  WriteVector(&ss,
              data->v8_snapshot_blob_data.data,
              data->v8_snapshot_blob_data.raw_size);
  ss << R""(};

static const int v8_snapshot_blob_size = )""
     << data->v8_snapshot_blob_data.raw_size << "";"";

  // Windows can't deal with too many large vector initializers.
  // Store the data into static arrays first.
  for (const auto& item : data->code_cache) {
    WriteStaticCodeCacheData(&ss, item);
  }

  ss << R""(const SnapshotData snapshot_data {
  // -- data_ownership begins --
  SnapshotData::DataOwnership::kNotOwned,
  // -- data_ownership ends --
  // -- metadata begins --
)"" << data->metadata
     << R""(,
  // -- metadata ends --
  // -- v8_snapshot_blob_data...",756.0,818.0,1.0,1.0,63.0,27,4,17,3,0,0,3,3,0,0,,0,0,4,2,2,void
4354,231226,ResetContextSettingsBeforeSnapshot,1,node.ResetContextSettingsBeforeSnapshot,void node.ResetContextSettingsBeforeSnapshot (Local<Context>),node_snapshotable.cc,"static void ResetContextSettingsBeforeSnapshot(Local<Context> context) {
  // Reset the AllowCodeGenerationFromStrings flag to true (default value) so
  // that it can be re-initialized with v8 flag
  // --disallow-code-generation-from-strings and recognized in
  // node::InitializeContextRuntime.
  context->AllowCodeGenerationFromStrings(true);
}",822.0,828.0,1.0,1.0,7.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,void
4355,231236,CollectExternalReferences,1,node.SnapshotBuilder.CollectExternalReferences,vector<intptr_t> node.SnapshotBuilder.CollectExternalReferences (),node_snapshotable.cc,"const std::vector<intptr_t>& SnapshotBuilder::CollectExternalReferences() {
  static auto registry = std::make_unique<ExternalReferenceRegistry>();
  return registry->external_references();
}",830.0,833.0,1.0,1.0,4.0,3,3,3,2,0,0,1,1,0,0,,0,0,0,0,0,vector<intptr_t>
4356,231252,InitializeIsolateParams,1,node.SnapshotBuilder.InitializeIsolateParams,"void node.SnapshotBuilder.InitializeIsolateParams (SnapshotData*,ANY*)",node_snapshotable.cc,"void SnapshotBuilder::InitializeIsolateParams(const SnapshotData* data,
                                              Isolate::CreateParams* params) {
  CHECK_NULL(params->external_references);
  CHECK_NULL(params->snapshot_blob);
  params->external_references = CollectExternalReferences().data();
  params->snapshot_blob =
      const_cast<v8::StartupData*>(&(data->v8_snapshot_blob_data));
}",835.0,842.0,1.0,1.0,8.0,10,5,5,2,0,0,1,1,0,0,,0,0,4,2,2,void
4357,231284,Generate,1,node.SnapshotBuilder.Generate,"ExitCode node.SnapshotBuilder.Generate (SnapshotData*,ANY,ANY)",node_snapshotable.cc,"ExitCode SnapshotBuilder::Generate(std::ostream& out,
                                   const std::vector<std::string> args,
                                   const std::vector<std::string> exec_args) {
  SnapshotData data;
  ExitCode exit_code = Generate(&data, args, exec_args);
  if (exit_code != ExitCode::kNoFailure) {
    return exit_code;
  }
  FormatBlob(out, &data);
  return exit_code;
}",1018.0,1028.0,1.0,1.0,11.0,39,12,40,16,0,0,6,9,0,0,,0,0,6,3,3,ExitCode
4358,231445,CreateSnapshot,1,node.SnapshotBuilder.CreateSnapshot,"ExitCode node.SnapshotBuilder.CreateSnapshot (SnapshotData*,CommonEnvironmentSetup*,uint8_t)",node_snapshotable.cc,"ExitCode SnapshotBuilder::CreateSnapshot(SnapshotData* out,
                                         CommonEnvironmentSetup* setup,
                                         uint8_t snapshot_type_u8) {
  SnapshotMetadata::Type snapshot_type =
      static_cast<SnapshotMetadata::Type>(snapshot_type_u8);
  Isolate* isolate = setup->isolate();
  Environment* env = setup->env();
  SnapshotCreator* creator = setup->snapshot_creator();

  {
    HandleScope scope(isolate);
    Local<Context> main_context = setup->context();

    // The default context with only things created by V8.
    Local<Context> default_context = Context::New(isolate);

    // The context used by the vm module.
    Local<Context> vm_context;
    {
      Local<ObjectTemplate> global_template =
          setup->isolate_data()->contextify_global_template();
      CHECK(!global_template.IsEmpty());
      if (!contextify::ContextifyContext::CreateV8Context(
               isolate, global_template, nullptr, nullptr)
       ...",906.0,1016.0,1.0,1.0,111.0,94,11,92,29,0,0,7,7,0,0,,0,0,6,3,3,ExitCode
4359,231797,SnapshotableObject,1,node.SnapshotableObject.SnapshotableObject,"ANY node.SnapshotableObject.SnapshotableObject (Realm*,Local<Object>,EmbedderObjectType)",node_snapshotable.cc,"SnapshotableObject::SnapshotableObject(Realm* realm,
                                       Local<Object> wrap,
                                       EmbedderObjectType type)
    : BaseObject(realm, wrap), type_(type) {}",1030.0,1033.0,1.0,45.0,4.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,ANY
4360,231804,GetTypeName,1,node.SnapshotableObject.GetTypeName,string node.SnapshotableObject.GetTypeName (),node_snapshotable.cc,"std::string SnapshotableObject::GetTypeName() const {
  switch (type_) {
#define V(PropertyName, NativeTypeName)                                        \
  case EmbedderObjectType::k_##PropertyName: {                                 \
    return #NativeTypeName;                                                    \
  }
    SERIALIZABLE_OBJECT_TYPES(V)
#undef V
    default: { UNREACHABLE(); }
  }
}",1035.0,1045.0,1.0,1.0,11.0,0,0,1,1,0,0,2,2,0,0,,0,0,0,0,0,string
4361,231816,DeserializeNodeInternalFields,1,node.DeserializeNodeInternalFields,"void node.DeserializeNodeInternalFields (Local<Object>,int,StartupData,void*)",node_snapshotable.cc,"void DeserializeNodeInternalFields(Local<Object> holder,
                                   int index,
                                   StartupData payload,
                                   void* env) {
  if (payload.raw_size == 0) {
    holder->SetAlignedPointerInInternalField(index, nullptr);
    return;
  }
  per_process::Debug(DebugCategory::MKSNAPSHOT,
                     ""Deserialize internal field %d of %p, size=%d\n"",
                     static_cast<int>(index),
                     (*holder),
                     static_cast<int>(payload.raw_size));

  if (payload.raw_size == 0) {
    holder->SetAlignedPointerInInternalField(index, nullptr);
    return;
  }

  DCHECK_EQ(index, BaseObject::kEmbedderType);

  Environment* env_ptr = static_cast<Environment*>(env);
  const InternalFieldInfoBase* info =
      reinterpret_cast<const InternalFieldInfoBase*>(payload.data);
  // TODO(joyeecheung): we can add a constant kNodeEmbedderId to the
  // beginning of every InternalFie...",1047.0,1102.0,1.0,1.0,56.0,19,6,18,9,0,0,4,4,0,0,,0,0,8,4,4,void
4362,231900,SerializeNodeContextInternalFields,1,node.SerializeNodeContextInternalFields,"StartupData node.SerializeNodeContextInternalFields (Local<Object>,int,void*)",node_snapshotable.cc,"StartupData SerializeNodeContextInternalFields(Local<Object> holder,
                                               int index,
                                               void* env) {
  // We only do one serialization for the kEmbedderType slot, the result
  // contains everything necessary for deserializing the entire object,
  // including the fields whose index is bigger than kEmbedderType
  // (most importantly, BaseObject::kSlot).
  // For Node.js this design is enough for all the native binding that are
  // serializable.
  if (index != BaseObject::kEmbedderType || !BaseObject::IsBaseObject(holder)) {
    return StartupData{nullptr, 0};
  }

  per_process::Debug(DebugCategory::MKSNAPSHOT,
                     ""Serialize internal field, index=%d, holder=%p\n"",
                     static_cast<int>(index),
                     *holder);

  void* native_ptr =
      holder->GetAlignedPointerFromInternalField(BaseObject::kSlot);
  per_process::Debug(DebugCategory::MKSNAPSHOT, ""n...",1104.0,1139.0,1.0,1.0,36.0,33,9,29,8,0,0,2,2,0,0,,0,0,6,3,3,StartupData
4363,232017,SerializeSnapshotableObjects,1,node.SerializeSnapshotableObjects,"void node.SerializeSnapshotableObjects (Realm*,SnapshotCreator*,RealmSerializeInfo*)",node_snapshotable.cc,"void SerializeSnapshotableObjects(Realm* realm,
                                  SnapshotCreator* creator,
                                  RealmSerializeInfo* info) {
  HandleScope scope(realm->isolate());
  Local<Context> context = realm->context();
  uint32_t i = 0;
  realm->ForEachBaseObject([&](BaseObject* obj) {
    // If there are any BaseObjects that are not snapshotable left
    // during context serialization, V8 would crash due to unregistered
    // global handles and print detailed information about them.
    if (!obj->is_snapshotable()) {
      return;
    }
    SnapshotableObject* ptr = static_cast<SnapshotableObject*>(obj);

    std::string type_name = ptr->GetTypeName();
    per_process::Debug(DebugCategory::MKSNAPSHOT,
                       ""Serialize snapshotable object %i (%p), ""
                       ""object=%p, type=%s\n"",
                       static_cast<int>(i),
                       ptr,
                       *(ptr->object()),
                       ...",1141.0,1174.0,1.0,1.0,34.0,7,4,7,5,0,0,1,1,0,0,,0,0,6,3,3,void
4364,232047,GetEmbedderEntryFunction,1,node.mksnapshot.GetEmbedderEntryFunction,void node.mksnapshot.GetEmbedderEntryFunction (FunctionCallbackInfo<Value>),node_snapshotable.cc,"void GetEmbedderEntryFunction(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();
  if (!env->embedder_entry_point()) return;
  MaybeLocal<Function> jsfn =
      Function::New(isolate->GetCurrentContext(),
                    [](const FunctionCallbackInfo<Value>& args) {
                      Environment* env = Environment::GetCurrent(args);
                      Local<Value> require_fn = args[0];
                      Local<Value> runcjs_fn = args[1];
                      CHECK(require_fn->IsFunction());
                      CHECK(runcjs_fn->IsFunction());
                      MaybeLocal<Value> retval = env->embedder_entry_point()(
                          {env->process_object(),
                           require_fn.As<Function>(),
                           runcjs_fn.As<Function>()});
                      if (!retval.IsEmpty())
                        args.GetReturnValue().Set(retval.ToLocalCheck...",1179.0,1199.0,1.0,1.0,21.0,16,6,14,7,0,0,3,3,0,0,,0,0,2,1,1,void
4365,232107,CompileSerializeMain,1,node.mksnapshot.CompileSerializeMain,void node.mksnapshot.CompileSerializeMain (FunctionCallbackInfo<Value>),node_snapshotable.cc,"void CompileSerializeMain(const FunctionCallbackInfo<Value>& args) {
  CHECK(args[0]->IsString());
  Local<String> filename = args[0].As<String>();
  Local<String> source = args[1].As<String>();
  Isolate* isolate = args.GetIsolate();
  Local<Context> context = isolate->GetCurrentContext();
  ScriptOrigin origin(isolate, filename, 0, 0, true);
  // TODO(joyeecheung): do we need all of these? Maybe we would want a less
  // internal version of them.
  std::vector<Local<String>> parameters = {
      FIXED_ONE_BYTE_STRING(isolate, ""require""),
      FIXED_ONE_BYTE_STRING(isolate, ""__filename""),
      FIXED_ONE_BYTE_STRING(isolate, ""__dirname""),
  };
  ScriptCompiler::Source script_source(source, origin);
  Local<Function> fn;
  if (ScriptCompiler::CompileFunction(context,
                                      &script_source,
                                      parameters.size(),
                                      parameters.data(),
                                      0,
         ...",1201.0,1227.0,1.0,1.0,27.0,34,8,35,15,0,0,2,2,0,0,,0,0,2,1,1,void
4366,232221,SetSerializeCallback,1,node.mksnapshot.SetSerializeCallback,void node.mksnapshot.SetSerializeCallback (FunctionCallbackInfo<Value>),node_snapshotable.cc,"void SetSerializeCallback(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  CHECK(env->snapshot_serialize_callback().IsEmpty());
  CHECK(args[0]->IsFunction());
  env->set_snapshot_serialize_callback(args[0].As<Function>());
}",1229.0,1234.0,1.0,1.0,6.0,9,4,7,3,0,0,1,1,0,0,,0,0,2,1,1,void
4367,232259,SetDeserializeCallback,1,node.mksnapshot.SetDeserializeCallback,void node.mksnapshot.SetDeserializeCallback (FunctionCallbackInfo<Value>),node_snapshotable.cc,"void SetDeserializeCallback(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  CHECK(env->snapshot_deserialize_callback().IsEmpty());
  CHECK(args[0]->IsFunction());
  env->set_snapshot_deserialize_callback(args[0].As<Function>());
}",1236.0,1241.0,1.0,1.0,6.0,9,4,7,3,0,0,1,1,0,0,,0,0,2,1,1,void
4368,232297,SetDeserializeMainFunction,1,node.mksnapshot.SetDeserializeMainFunction,void node.mksnapshot.SetDeserializeMainFunction (FunctionCallbackInfo<Value>),node_snapshotable.cc,"void SetDeserializeMainFunction(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  CHECK(env->snapshot_deserialize_main().IsEmpty());
  CHECK(args[0]->IsFunction());
  env->set_snapshot_deserialize_main(args[0].As<Function>());
}",1243.0,1248.0,1.0,1.0,6.0,9,4,7,3,0,0,1,1,0,0,,0,0,2,1,1,void
4369,232335,Initialize,1,node.mksnapshot.Initialize,"void node.mksnapshot.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)",node_snapshotable.cc,"void Initialize(Local<Object> target,
                Local<Value> unused,
                Local<Context> context,
                void* priv) {
  SetMethod(
      context, target, ""getEmbedderEntryFunction"", GetEmbedderEntryFunction);
  SetMethod(context, target, ""compileSerializeMain"", CompileSerializeMain);
  SetMethod(context, target, ""setSerializeCallback"", SetSerializeCallback);
  SetMethod(context, target, ""setDeserializeCallback"", SetDeserializeCallback);
  SetMethod(context,
            target,
            ""setDeserializeMainFunction"",
            SetDeserializeMainFunction);
}",1250.0,1263.0,1.0,1.0,14.0,0,0,10,2,0,0,1,1,0,0,,0,0,8,4,4,void
4370,232368,RegisterExternalReferences,1,node.mksnapshot.RegisterExternalReferences,void node.mksnapshot.RegisterExternalReferences (ExternalReferenceRegistry*),node_snapshotable.cc,"void RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  registry->Register(GetEmbedderEntryFunction);
  registry->Register(CompileSerializeMain);
  registry->Register(SetSerializeCallback);
  registry->Register(SetDeserializeCallback);
  registry->Register(SetDeserializeMainFunction);
}",1265.0,1271.0,1.0,1.0,7.0,5,1,5,1,0,0,1,1,0,0,,0,0,2,1,1,void
4371,232454,FromUVHandle,1,node.anonymous_namespace_1.FromUVHandle,"SocketAddress node.anonymous_namespace_1.FromUVHandle<T,F> (F,T)",node_sockaddr.cc,"SocketAddress FromUVHandle(F fn, const T& handle) {
  SocketAddress addr;
  int len = sizeof(sockaddr_storage);
  if (fn(&handle, addr.storage(), &len) == 0)
    CHECK_EQ(static_cast<size_t>(len), addr.length());
  else
    addr.storage()->sa_family = 0;
  return addr;
}",29.0,37.0,1.0,1.0,9.0,8,6,8,4,0,0,2,2,0,0,,0,0,4,2,2,SocketAddress
4372,232499,ToSockAddr,1,node.SocketAddress.ToSockAddr,"bool node.SocketAddress.ToSockAddr (int32_t,char*,uint32_t,sockaddr_storage*)",node_sockaddr.cc,"bool SocketAddress::ToSockAddr(
    int32_t family,
    const char* host,
    uint32_t port,
    sockaddr_storage* addr) {
  switch (family) {
    case AF_INET:
      return uv_ip4_addr(
          host,
          port,
          reinterpret_cast<sockaddr_in*>(addr)) == 0;
    case AF_INET6:
      return uv_ip6_addr(
          host,
          port,
          reinterpret_cast<sockaddr_in6*>(addr)) == 0;
    default:
      UNREACHABLE();
  }
}",40.0,59.0,1.0,1.0,20.0,4,2,9,6,0,0,2,2,0,0,,0,0,8,4,4,bool
4373,232534,New,1,node.SocketAddress.New,"bool node.SocketAddress.New (char*,uint32_t,SocketAddress*)",node_sockaddr.cc,"bool SocketAddress::New(
    int32_t family,
    const char* host,
    uint32_t port,
    SocketAddress* addr) {
  return ToSockAddr(family, host, port,
                    reinterpret_cast<sockaddr_storage*>(addr->storage()));
}",68.0,75.0,1.0,1.0,8.0,1,1,8,5,0,0,1,1,0,0,,0,0,8,4,4,bool
4374,232572,operator (),1,node.SocketAddress.Hash.operator (),size_t node.SocketAddress.Hash.operator () (SocketAddress),node_sockaddr.cc,"size_t SocketAddress::Hash::operator()(const SocketAddress& addr) const {
  size_t hash = 0;
  switch (addr.family()) {
    case AF_INET: {
      const sockaddr_in* ipv4 =
          reinterpret_cast<const sockaddr_in*>(addr.raw());
      hash_combine(&hash, ipv4->sin_port, ipv4->sin_addr.s_addr);
      break;
    }
    case AF_INET6: {
      const sockaddr_in6* ipv6 =
          reinterpret_cast<const sockaddr_in6*>(addr.raw());
      const uint64_t* a =
          reinterpret_cast<const uint64_t*>(&ipv6->sin6_addr);
      hash_combine(&hash, ipv6->sin6_port, a[0], a[1]);
      break;
    }
    default:
      UNREACHABLE();
  }
  return hash;
}",77.0,98.0,1.0,1.0,22.0,20,6,18,7,0,0,4,2,0,0,,0,0,2,1,1,size_t
4375,232649,FromSockName,1,node.SocketAddress.FromSockName,SocketAddress node.SocketAddress.FromSockName (uv_tcp_t),node_sockaddr.cc,"SocketAddress SocketAddress::FromSockName(const uv_udp_t& handle) {
  return FromUVHandle(uv_udp_getsockname, handle);
}",104.0,106.0,1.0,1.0,3.0,0,0,2,2,0,0,1,1,0,0,,0,0,2,1,1,SocketAddress
4376,232667,FromPeerName,1,node.SocketAddress.FromPeerName,SocketAddress node.SocketAddress.FromPeerName (uv_tcp_t),node_sockaddr.cc,"SocketAddress SocketAddress::FromPeerName(const uv_udp_t& handle) {
  return FromUVHandle(uv_udp_getpeername, handle);
}",112.0,114.0,1.0,1.0,3.0,0,0,2,2,0,0,1,1,0,0,,0,0,2,1,1,SocketAddress
4377,232702,is_match_ipv4,1,node.anonymous_namespace_3.is_match_ipv4,"bool node.anonymous_namespace_3.is_match_ipv4 (SocketAddress,SocketAddress)",node_sockaddr.cc,"bool is_match_ipv4(
    const SocketAddress& one,
    const SocketAddress& two) {
  const sockaddr_in* one_in =
      reinterpret_cast<const sockaddr_in*>(one.data());
  const sockaddr_in* two_in =
      reinterpret_cast<const sockaddr_in*>(two.data());
  return memcmp(&one_in->sin_addr, &two_in->sin_addr, sizeof(uint32_t)) == 0;
}",119.0,127.0,1.0,1.0,9.0,12,7,7,5,0,0,1,1,0,0,,0,0,4,2,2,bool
4378,232740,is_match_ipv6,1,node.anonymous_namespace_4.is_match_ipv6,"bool node.anonymous_namespace_4.is_match_ipv6 (SocketAddress,SocketAddress)",node_sockaddr.cc,"bool is_match_ipv6(
    const SocketAddress& one,
    const SocketAddress& two) {
  const sockaddr_in6* one_in =
      reinterpret_cast<const sockaddr_in6*>(one.data());
  const sockaddr_in6* two_in =
      reinterpret_cast<const sockaddr_in6*>(two.data());
  return memcmp(&one_in->sin6_addr, &two_in->sin6_addr, 16) == 0;
}",129.0,137.0,1.0,1.0,9.0,11,6,6,4,0,0,1,1,0,0,,0,0,4,2,2,bool
4379,232777,is_match_ipv4_ipv6,1,node.anonymous_namespace_5.is_match_ipv4_ipv6,"bool node.anonymous_namespace_5.is_match_ipv4_ipv6 (SocketAddress,SocketAddress)",node_sockaddr.cc,"bool is_match_ipv4_ipv6(
    const SocketAddress& ipv4,
    const SocketAddress& ipv6) {
  const sockaddr_in* check_ipv4 =
      reinterpret_cast<const sockaddr_in*>(ipv4.data());
  const sockaddr_in6* check_ipv6 =
      reinterpret_cast<const sockaddr_in6*>(ipv6.data());

  const uint8_t* ptr =
      reinterpret_cast<const uint8_t*>(&check_ipv6->sin6_addr);

  return memcmp(ptr, mask, sizeof(mask)) == 0 &&
         memcmp(ptr + sizeof(mask),
                &check_ipv4->sin_addr,
                sizeof(uint32_t)) == 0;
}",139.0,154.0,1.0,1.0,16.0,19,9,13,7,0,0,1,1,0,0,,0,0,4,2,2,bool
4380,232832,compare_ipv4,1,node.anonymous_namespace_6.compare_ipv4,"CompareResult node.anonymous_namespace_6.compare_ipv4 (SocketAddress,SocketAddress)",node_sockaddr.cc,"SocketAddress::CompareResult compare_ipv4(
    const SocketAddress& one,
    const SocketAddress& two) {
  const sockaddr_in* one_in =
      reinterpret_cast<const sockaddr_in*>(one.data());
  const sockaddr_in* two_in =
      reinterpret_cast<const sockaddr_in*>(two.data());
  const uint32_t s_addr_one = ntohl(one_in->sin_addr.s_addr);
  const uint32_t s_addr_two = ntohl(two_in->sin_addr.s_addr);

  if (s_addr_one < s_addr_two)
    return SocketAddress::CompareResult::LESS_THAN;
  else if (s_addr_one == s_addr_two)
    return SocketAddress::CompareResult::SAME;
  else
    return SocketAddress::CompareResult::GREATER_THAN;
}",156.0,172.0,1.0,1.0,17.0,15,5,12,8,0,0,2,2,0,0,,0,0,4,2,2,CompareResult
4381,232906,compare_ipv6,1,node.anonymous_namespace_7.compare_ipv6,"CompareResult node.anonymous_namespace_7.compare_ipv6 (SocketAddress,SocketAddress)",node_sockaddr.cc,"SocketAddress::CompareResult compare_ipv6(
    const SocketAddress& one,
    const SocketAddress& two) {
  const sockaddr_in6* one_in =
      reinterpret_cast<const sockaddr_in6*>(one.data());
  const sockaddr_in6* two_in =
      reinterpret_cast<const sockaddr_in6*>(two.data());
  int ret = memcmp(&one_in->sin6_addr, &two_in->sin6_addr, 16);
  if (ret < 0)
    return SocketAddress::CompareResult::LESS_THAN;
  else if (ret > 0)
    return SocketAddress::CompareResult::GREATER_THAN;
  return SocketAddress::CompareResult::SAME;
}",174.0,187.0,1.0,1.0,14.0,16,6,12,7,0,0,2,2,0,0,,0,0,4,2,2,CompareResult
4382,232973,compare_ipv4_ipv6,1,node.anonymous_namespace_8.compare_ipv4_ipv6,"CompareResult node.anonymous_namespace_8.compare_ipv4_ipv6 (SocketAddress,SocketAddress)",node_sockaddr.cc,"SocketAddress::CompareResult compare_ipv4_ipv6(
    const SocketAddress& ipv4,
    const SocketAddress& ipv6) {
  const sockaddr_in* ipv4_in =
      reinterpret_cast<const sockaddr_in*>(ipv4.data());
  const sockaddr_in6 * ipv6_in =
      reinterpret_cast<const sockaddr_in6*>(ipv6.data());

  const uint8_t* ptr =
      reinterpret_cast<const uint8_t*>(&ipv6_in->sin6_addr);

  if (memcmp(ptr, mask, sizeof(mask)) != 0)
    return SocketAddress::CompareResult::NOT_COMPARABLE;

  int ret = memcmp(
      &ipv4_in->sin_addr,
      ptr + sizeof(mask),
      sizeof(uint32_t));

  if (ret < 0)
    return SocketAddress::CompareResult::LESS_THAN;
  else if (ret > 0)
    return SocketAddress::CompareResult::GREATER_THAN;
  return SocketAddress::CompareResult::SAME;
}",189.0,213.0,1.0,1.0,25.0,25,9,21,10,0,0,3,3,0,0,,0,0,4,2,2,CompareResult
4383,233065,in_network_ipv4,1,node.anonymous_namespace_9.in_network_ipv4,"bool node.anonymous_namespace_9.in_network_ipv4 (SocketAddress,SocketAddress,int)",node_sockaddr.cc,"bool in_network_ipv4(
    const SocketAddress& ip,
    const SocketAddress& net,
    int prefix) {
  uint32_t mask = ((1ull << prefix) - 1) << (32 - prefix);

  const sockaddr_in* ip_in =
      reinterpret_cast<const sockaddr_in*>(ip.data());
  const sockaddr_in* net_in =
      reinterpret_cast<const sockaddr_in*>(net.data());

  return (htonl(ip_in->sin_addr.s_addr) & mask) ==
         (htonl(net_in->sin_addr.s_addr) & mask);
}",215.0,228.0,1.0,1.0,14.0,18,8,11,6,0,0,1,1,0,0,,0,0,6,3,3,bool
4384,233120,in_network_ipv6,1,node.anonymous_namespace_10.in_network_ipv6,"bool node.anonymous_namespace_10.in_network_ipv6 (SocketAddress,SocketAddress,int)",node_sockaddr.cc,"bool in_network_ipv6(
    const SocketAddress& ip,
    const SocketAddress& net,
    int prefix) {
  // Special case, if prefix == 128, then just do a
  // straight comparison.
  if (prefix == 128)
    return compare_ipv6(ip, net) == SocketAddress::CompareResult::SAME;

  uint8_t r = prefix % 8;
  int len = (prefix - r) / 8;
  uint8_t mask = ((1 << r) - 1) << (8 - r);

  const sockaddr_in6* ip_in =
      reinterpret_cast<const sockaddr_in6*>(ip.data());
  const sockaddr_in6* net_in =
      reinterpret_cast<const sockaddr_in6*>(net.data());

  if (memcmp(&ip_in->sin6_addr, &net_in->sin6_addr, len) != 0)
    return false;

  const uint8_t* p1 = reinterpret_cast<const uint8_t*>(
      ip_in->sin6_addr.s6_addr);
  const uint8_t* p2 = reinterpret_cast<const uint8_t*>(
      net_in->sin6_addr.s6_addr);

  return (p1[len] & mask) == (p2[len] & mask);
}",230.0,257.0,1.0,1.0,28.0,38,13,30,12,0,0,3,3,0,0,,0,0,6,3,3,bool
4385,233234,in_network_ipv4_ipv6,1,node.anonymous_namespace_12.in_network_ipv4_ipv6,"bool node.anonymous_namespace_12.in_network_ipv4_ipv6 (SocketAddress,SocketAddress,int)",node_sockaddr.cc,"bool in_network_ipv4_ipv6(
    const SocketAddress& ip,
    const SocketAddress& net,
    int prefix) {

  if (prefix == 128)
    return compare_ipv4_ipv6(ip, net) == SocketAddress::CompareResult::SAME;

  uint8_t r = prefix % 8;
  int len = (prefix - r) / 8;
  uint8_t mask = ((1 << r) - 1) << (8 - r);

  const sockaddr_in* ip_in =
      reinterpret_cast<const sockaddr_in*>(ip.data());
  const sockaddr_in6* net_in =
      reinterpret_cast<const sockaddr_in6*>(net.data());

  uint8_t ip_mask[16] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff, 0, 0, 0, 0};
  uint8_t* ptr = ip_mask;
  memcpy(ptr + 12, &ip_in->sin_addr, 4);

  if (memcmp(ptr, &net_in->sin6_addr, len) != 0)
    return false;

  ptr += len;
  const uint8_t* p2 = reinterpret_cast<const uint8_t*>(
      net_in->sin6_addr.s6_addr);

  return (ptr[0] & mask) == (p2[len] & mask);
}",259.0,288.0,1.0,1.0,30.0,39,16,34,13,0,0,3,3,0,0,,0,0,6,3,3,bool
4386,233371,in_network_ipv6_ipv4,1,node.anonymous_namespace_14.in_network_ipv6_ipv4,"bool node.anonymous_namespace_14.in_network_ipv6_ipv4 (SocketAddress,SocketAddress,int)",node_sockaddr.cc,"bool in_network_ipv6_ipv4(
    const SocketAddress& ip,
    const SocketAddress& net,
    int prefix) {
  if (prefix == 32)
    return compare_ipv4_ipv6(net, ip) == SocketAddress::CompareResult::SAME;

  uint32_t m = ((1ull << prefix) - 1) << (32 - prefix);

  const sockaddr_in6* ip_in =
      reinterpret_cast<const sockaddr_in6*>(ip.data());
  const sockaddr_in* net_in =
      reinterpret_cast<const sockaddr_in*>(net.data());

  const uint8_t* ptr =
      reinterpret_cast<const uint8_t*>(&ip_in->sin6_addr);

  if (memcmp(ptr, mask, sizeof(mask)) != 0)
    return false;

  ptr += sizeof(mask);
  uint32_t check = ReadUint32BE(ptr);

  return (check & m) == (htonl(net_in->sin_addr.s_addr) & m);
}",290.0,314.0,1.0,1.0,25.0,29,12,25,11,0,0,3,3,0,0,,0,0,6,3,3,bool
4387,233465,is_match,1,node.SocketAddress.is_match,bool node.SocketAddress.is_match (SocketAddress),node_sockaddr.cc,"bool SocketAddress::is_match(const SocketAddress& other) const {
  switch (family()) {
    case AF_INET:
      switch (other.family()) {
        case AF_INET: return is_match_ipv4(*this, other);
        case AF_INET6: return is_match_ipv4_ipv6(*this, other);
      }
      break;
    case AF_INET6:
      switch (other.family()) {
        case AF_INET: return is_match_ipv4_ipv6(other, *this);
        case AF_INET6: return is_match_ipv6(*this, other);
      }
      break;
  }
  return false;
}",321.0,337.0,1.0,1.0,17.0,6,2,12,3,0,0,6,6,0,0,,0,0,2,1,1,bool
4388,233521,compare,1,node.SocketAddress.compare,CompareResult node.SocketAddress.compare (SocketAddress),node_sockaddr.cc,"SocketAddress::CompareResult SocketAddress::compare(
    const SocketAddress& other) const {
  switch (family()) {
    case AF_INET:
      switch (other.family()) {
        case AF_INET: return compare_ipv4(*this, other);
        case AF_INET6: return compare_ipv4_ipv6(*this, other);
      }
      break;
    case AF_INET6:
      switch (other.family()) {
        case AF_INET: {
          CompareResult c = compare_ipv4_ipv6(other, *this);
          switch (c) {
            case SocketAddress::CompareResult::NOT_COMPARABLE:
              // Fall through
            case SocketAddress::CompareResult::SAME:
              return c;
            case SocketAddress::CompareResult::GREATER_THAN:
              return SocketAddress::CompareResult::LESS_THAN;
            case SocketAddress::CompareResult::LESS_THAN:
              return SocketAddress::CompareResult::GREATER_THAN;
          }
          break;
        }
        case AF_INET6: return compare_ipv6(*this, other);
      }
      break...",339.0,369.0,1.0,1.0,31.0,21,3,29,6,0,0,8,9,0,0,,0,0,2,1,1,CompareResult
4389,233626,is_in_network,1,node.SocketAddress.is_in_network,"bool node.SocketAddress.is_in_network (SocketAddress,int)",node_sockaddr.cc,"bool SocketAddress::is_in_network(
    const SocketAddress& other,
    int prefix) const {

  switch (family()) {
    case AF_INET:
      switch (other.family()) {
        case AF_INET: return in_network_ipv4(*this, other, prefix);
        case AF_INET6: return in_network_ipv4_ipv6(*this, other, prefix);
      }
      break;
    case AF_INET6:
      switch (other.family()) {
        case AF_INET: return in_network_ipv6_ipv4(*this, other, prefix);
        case AF_INET6: return in_network_ipv6(*this, other, prefix);
      }
      break;
  }

  return false;
}",371.0,391.0,1.0,1.0,21.0,6,2,16,4,0,0,6,6,0,0,,0,0,4,2,2,bool
4390,233687,SocketAddressBlockList,1,node.SocketAddressBlockList.SocketAddressBlockList,ANY node.SocketAddressBlockList.SocketAddressBlockList (ANY),node_sockaddr.cc,"SocketAddressBlockList::SocketAddressBlockList(
    std::shared_ptr<SocketAddressBlockList> parent)
    : parent_(parent) {}",393.0,395.0,1.0,24.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
4391,233692,AddSocketAddress,1,node.SocketAddressBlockList.AddSocketAddress,void node.SocketAddressBlockList.AddSocketAddress (ANY),node_sockaddr.cc,"void SocketAddressBlockList::AddSocketAddress(
    const std::shared_ptr<SocketAddress>& address) {
  Mutex::ScopedLock lock(mutex_);
  std::unique_ptr<Rule> rule =
      std::make_unique<SocketAddressRule>(address);
  rules_.emplace_front(std::move(rule));
  address_rules_[*address.get()] = rules_.begin();
}",397.0,404.0,1.0,1.0,8.0,14,6,13,8,0,0,1,1,0,0,,0,0,2,1,1,void
4392,233736,RemoveSocketAddress,1,node.SocketAddressBlockList.RemoveSocketAddress,void node.SocketAddressBlockList.RemoveSocketAddress (ANY),node_sockaddr.cc,"void SocketAddressBlockList::RemoveSocketAddress(
    const std::shared_ptr<SocketAddress>& address) {
  Mutex::ScopedLock lock(mutex_);
  auto it = address_rules_.find(*address.get());
  if (it != std::end(address_rules_)) {
    rules_.erase(it->second);
    address_rules_.erase(it);
  }
}",406.0,414.0,1.0,1.0,9.0,9,5,11,6,0,0,2,2,0,0,,0,0,2,1,1,void
4393,233777,AddSocketAddressRange,1,node.SocketAddressBlockList.AddSocketAddressRange,"void node.SocketAddressBlockList.AddSocketAddressRange (ANY,ANY)",node_sockaddr.cc,"void SocketAddressBlockList::AddSocketAddressRange(
    const std::shared_ptr<SocketAddress>& start,
    const std::shared_ptr<SocketAddress>& end) {
  Mutex::ScopedLock lock(mutex_);
  std::unique_ptr<Rule> rule =
      std::make_unique<SocketAddressRangeRule>(start, end);
  rules_.emplace_front(std::move(rule));
}",416.0,423.0,1.0,1.0,8.0,11,6,11,8,0,0,1,1,0,0,,0,0,4,2,2,void
4394,233813,AddSocketAddressMask,1,node.SocketAddressBlockList.AddSocketAddressMask,"void node.SocketAddressBlockList.AddSocketAddressMask (ANY,int)",node_sockaddr.cc,"void SocketAddressBlockList::AddSocketAddressMask(
    const std::shared_ptr<SocketAddress>& network,
    int prefix) {
  Mutex::ScopedLock lock(mutex_);
  std::unique_ptr<Rule> rule =
      std::make_unique<SocketAddressMaskRule>(network, prefix);
  rules_.emplace_front(std::move(rule));
}",425.0,432.0,1.0,1.0,8.0,11,6,11,8,0,0,1,1,0,0,,0,0,4,2,2,void
4395,233849,Apply,1,node.SocketAddressBlockList.Apply,bool node.SocketAddressBlockList.Apply (ANY),node_sockaddr.cc,"bool SocketAddressBlockList::Apply(
    const std::shared_ptr<SocketAddress>& address) {
  Mutex::ScopedLock lock(mutex_);
  for (const auto& rule : rules_) {
    if (rule->Apply(address))
      return true;
  }
  return parent_ ? parent_->Apply(address) : false;
}",434.0,442.0,1.0,1.0,9.0,3,2,7,5,0,0,3,4,0,0,,0,0,2,1,1,bool
4396,233879,SocketAddressRule,1,node.SocketAddressBlockList.SocketAddressRule.SocketAddressRule,ANY node.SocketAddressBlockList.SocketAddressRule.SocketAddressRule (ANY),node_sockaddr.cc,"SocketAddressBlockList::SocketAddressRule::SocketAddressRule(
    const std::shared_ptr<SocketAddress>& address_)
    : address(address_) {}",444.0,446.0,1.0,26.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
4397,233884,SocketAddressRangeRule,1,node.SocketAddressBlockList.SocketAddressRangeRule.SocketAddressRangeRule,"ANY node.SocketAddressBlockList.SocketAddressRangeRule.SocketAddressRangeRule (ANY,ANY)",node_sockaddr.cc,"SocketAddressBlockList::SocketAddressRangeRule::SocketAddressRangeRule(
    const std::shared_ptr<SocketAddress>& start_,
    const std::shared_ptr<SocketAddress>& end_)
    : start(start_),
      end(end_) {}",448.0,452.0,1.0,18.0,5.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,ANY
4398,233890,SocketAddressMaskRule,1,node.SocketAddressBlockList.SocketAddressMaskRule.SocketAddressMaskRule,"ANY node.SocketAddressBlockList.SocketAddressMaskRule.SocketAddressMaskRule (ANY,int)",node_sockaddr.cc,"SocketAddressBlockList::SocketAddressMaskRule::SocketAddressMaskRule(
    const std::shared_ptr<SocketAddress>& network_,
    int prefix_)
    : network(network_),
      prefix(prefix_) {}",454.0,458.0,1.0,24.0,5.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,ANY
4399,233896,Apply,1,node.SocketAddressBlockList.SocketAddressRule.Apply,bool node.SocketAddressBlockList.SocketAddressRule.Apply (ANY),node_sockaddr.cc,"bool SocketAddressBlockList::SocketAddressRule::Apply(
    const std::shared_ptr<SocketAddress>& address) {
  return this->address->is_match(*address.get());
}",460.0,463.0,1.0,1.0,4.0,4,3,1,1,0,0,1,1,0,0,,0,0,2,1,1,bool
4400,233913,ToString,1,node.SocketAddressBlockList.SocketAddressRule.ToString,string node.SocketAddressBlockList.SocketAddressRule.ToString (),node_sockaddr.cc,"std::string SocketAddressBlockList::SocketAddressRule::ToString() {
  std::string ret = ""Address: "";
  ret += address->family() == AF_INET ? ""IPv4"" : ""IPv6"";
  ret += "" "";
  ret += address->address();
  return ret;
}",465.0,471.0,1.0,1.0,7.0,8,5,8,3,0,0,1,1,0,0,,0,0,0,0,0,string
4401,233943,Apply,1,node.SocketAddressBlockList.SocketAddressRangeRule.Apply,bool node.SocketAddressBlockList.SocketAddressRangeRule.Apply (ANY),node_sockaddr.cc,"bool SocketAddressBlockList::SocketAddressRangeRule::Apply(
    const std::shared_ptr<SocketAddress>& address) {
  return *address.get() >= *start.get() &&
         *address.get() <= *end.get();
}",473.0,477.0,1.0,1.0,5.0,11,5,4,3,0,0,1,1,0,0,,0,0,2,1,1,bool
4402,233972,ToString,1,node.SocketAddressBlockList.SocketAddressRangeRule.ToString,string node.SocketAddressBlockList.SocketAddressRangeRule.ToString (),node_sockaddr.cc,"std::string SocketAddressBlockList::SocketAddressRangeRule::ToString() {
  std::string ret = ""Range: "";
  ret += start->family() == AF_INET ? ""IPv4"" : ""IPv6"";
  ret += "" "";
  ret += start->address();
  ret += ""-"";
  ret += end->address();
  return ret;
}",479.0,487.0,1.0,1.0,9.0,11,5,11,4,0,0,1,1,0,0,,0,0,0,0,0,string
4403,234011,Apply,1,node.SocketAddressBlockList.SocketAddressMaskRule.Apply,bool node.SocketAddressBlockList.SocketAddressMaskRule.Apply (ANY),node_sockaddr.cc,"bool SocketAddressBlockList::SocketAddressMaskRule::Apply(
    const std::shared_ptr<SocketAddress>& address) {
  return address->is_in_network(*network.get(), prefix);
}",489.0,492.0,1.0,1.0,4.0,3,3,3,3,0,0,1,1,0,0,,0,0,2,1,1,bool
4404,234027,ToString,1,node.SocketAddressBlockList.SocketAddressMaskRule.ToString,string node.SocketAddressBlockList.SocketAddressMaskRule.ToString (),node_sockaddr.cc,"std::string SocketAddressBlockList::SocketAddressMaskRule::ToString() {
  std::string ret = ""Subnet: "";
  ret += network->family() == AF_INET ? ""IPv4"" : ""IPv6"";
  ret += "" "";
  ret += network->address();
  ret += ""/"" + std::to_string(prefix);
  return ret;
}",494.0,501.0,1.0,1.0,8.0,11,7,11,5,0,0,1,1,0,0,,0,0,0,0,0,string
4405,234066,ListRules,1,node.SocketAddressBlockList.ListRules,MaybeLocal<Array> node.SocketAddressBlockList.ListRules (Environment*),node_sockaddr.cc,"bool SocketAddressBlockList::ListRules(
    Environment* env,
    std::vector<v8::Local<v8::Value>>* rules) {
  if (parent_ && !parent_->ListRules(env, rules))
    return false;
  for (const auto& rule : rules_) {
    Local<Value> str;
    if (!rule->ToV8String(env).ToLocal(&str))
      return false;
    rules->push_back(str);
  }
  return true;
}",511.0,523.0,1.0,1.0,13.0,10,6,11,7,0,0,2,2,0,0,,0,0,4,2,2,bool
4406,234159,MemoryInfo,1,node.SocketAddressBlockList.MemoryInfo,void node.SocketAddressBlockList.MemoryInfo (ANY*),node_sockaddr.cc,"void SocketAddressBlockList::MemoryInfo(node::MemoryTracker* tracker) const {
  tracker->TrackField(""rules"", rules_);
}",525.0,527.0,1.0,1.0,3.0,1,1,2,2,0,0,1,1,0,0,,0,0,2,1,1,void
4407,234170,MemoryInfo,1,node.SocketAddressBlockList.SocketAddressRule.MemoryInfo,void node.SocketAddressBlockList.SocketAddressRule.MemoryInfo (ANY*),node_sockaddr.cc,"void SocketAddressBlockList::SocketAddressRule::MemoryInfo(
    node::MemoryTracker* tracker) const {
  tracker->TrackField(""address"", address);
}",529.0,532.0,1.0,1.0,4.0,1,1,2,2,0,0,1,1,0,0,,0,0,2,1,1,void
4408,234181,MemoryInfo,1,node.SocketAddressBlockList.SocketAddressRangeRule.MemoryInfo,void node.SocketAddressBlockList.SocketAddressRangeRule.MemoryInfo (ANY*),node_sockaddr.cc,"void SocketAddressBlockList::SocketAddressRangeRule::MemoryInfo(
    node::MemoryTracker* tracker) const {
  tracker->TrackField(""start"", start);
  tracker->TrackField(""end"", end);
}",534.0,538.0,1.0,1.0,5.0,2,1,4,3,0,0,1,1,0,0,,0,0,2,1,1,void
4409,234198,MemoryInfo,1,node.SocketAddressBlockList.SocketAddressMaskRule.MemoryInfo,void node.SocketAddressBlockList.SocketAddressMaskRule.MemoryInfo (ANY*),node_sockaddr.cc,"void SocketAddressBlockList::SocketAddressMaskRule::MemoryInfo(
    node::MemoryTracker* tracker) const {
  tracker->TrackField(""network"", network);
}",540.0,543.0,1.0,1.0,4.0,1,1,2,2,0,0,1,1,0,0,,0,0,2,1,1,void
4410,234209,SocketAddressBlockListWrap,1,node.SocketAddressBlockListWrap.SocketAddressBlockListWrap,"ANY node.SocketAddressBlockListWrap.SocketAddressBlockListWrap (Environment*,Local<Object>,ANY)",node_sockaddr.cc,"SocketAddressBlockListWrap::SocketAddressBlockListWrap(
    Environment* env,
    Local<Object> wrap,
    std::shared_ptr<SocketAddressBlockList> blocklist)
    : BaseObject(env, wrap),
      blocklist_(std::move(blocklist)) {
  MakeWeak();
}",545.0,552.0,1.0,1.0,8.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,ANY
4411,234217,New,1,node.SocketAddressBlockListWrap.New,BaseObjectPtr<SocketAddressBlockListWrap> node.SocketAddressBlockListWrap.New (Environment*),node_sockaddr.cc,"void SocketAddressBlockListWrap::New(
    const FunctionCallbackInfo<Value>& args) {
  CHECK(args.IsConstructCall());
  Environment* env = Environment::GetCurrent(args);
  new SocketAddressBlockListWrap(env, args.This());
}",586.0,591.0,1.0,1.0,6.0,16,9,14,8,0,0,2,2,0,0,,0,0,2,1,1,void
4412,234350,AddAddress,1,node.SocketAddressBlockListWrap.AddAddress,void node.SocketAddressBlockListWrap.AddAddress (FunctionCallbackInfo<Value>),node_sockaddr.cc,"void SocketAddressBlockListWrap::AddAddress(
    const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  SocketAddressBlockListWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  CHECK(SocketAddressBase::HasInstance(env, args[0]));
  SocketAddressBase* addr;
  ASSIGN_OR_RETURN_UNWRAP(&addr, args[0]);

  wrap->blocklist_->AddSocketAddress(addr->address());

  args.GetReturnValue().Set(true);
}",593.0,606.0,1.0,1.0,14.0,13,5,13,6,0,0,1,1,0,0,,0,0,2,1,1,void
4413,234405,AddRange,1,node.SocketAddressBlockListWrap.AddRange,void node.SocketAddressBlockListWrap.AddRange (FunctionCallbackInfo<Value>),node_sockaddr.cc,"void SocketAddressBlockListWrap::AddRange(
    const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  SocketAddressBlockListWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  CHECK(SocketAddressBase::HasInstance(env, args[0]));
  CHECK(SocketAddressBase::HasInstance(env, args[1]));

  SocketAddressBase* start_addr;
  SocketAddressBase* end_addr;
  ASSIGN_OR_RETURN_UNWRAP(&start_addr, args[0]);
  ASSIGN_OR_RETURN_UNWRAP(&end_addr, args[1]);

  // Starting address must come before the end address
  if (*start_addr->address().get() > *end_addr->address().get())
    return args.GetReturnValue().Set(false);

  wrap->blocklist_->AddSocketAddressRange(
      start_addr->address(),
      end_addr->address());

  args.GetReturnValue().Set(true);
}",608.0,631.0,1.0,1.0,24.0,27,7,22,7,0,0,2,2,0,0,,0,0,2,1,1,void
4414,234508,AddSubnet,1,node.SocketAddressBlockListWrap.AddSubnet,void node.SocketAddressBlockListWrap.AddSubnet (FunctionCallbackInfo<Value>),node_sockaddr.cc,"void SocketAddressBlockListWrap::AddSubnet(
    const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  SocketAddressBlockListWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  CHECK(SocketAddressBase::HasInstance(env, args[0]));
  CHECK(args[1]->IsInt32());

  SocketAddressBase* addr;
  ASSIGN_OR_RETURN_UNWRAP(&addr, args[0]);

  int32_t prefix;
  if (!args[1]->Int32Value(env->context()).To(&prefix)) {
    return;
  }

  CHECK_IMPLIES(addr->address()->family() == AF_INET, prefix <= 32);
  CHECK_IMPLIES(addr->address()->family() == AF_INET6, prefix <= 128);
  CHECK_GE(prefix, 0);

  wrap->blocklist_->AddSocketAddressMask(addr->address(), prefix);

  args.GetReturnValue().Set(true);
}",633.0,657.0,1.0,1.0,25.0,29,8,25,9,0,0,2,2,0,0,,0,0,2,1,1,void
4415,234620,Check,1,node.SocketAddressBlockListWrap.Check,void node.SocketAddressBlockListWrap.Check (FunctionCallbackInfo<Value>),node_sockaddr.cc,"void SocketAddressBlockListWrap::Check(
    const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  SocketAddressBlockListWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  CHECK(SocketAddressBase::HasInstance(env, args[0]));
  SocketAddressBase* addr;
  ASSIGN_OR_RETURN_UNWRAP(&addr, args[0]);

  args.GetReturnValue().Set(wrap->blocklist_->Apply(addr->address()));
}",659.0,670.0,1.0,1.0,12.0,13,5,13,6,0,0,1,1,0,0,,0,0,2,1,1,void
4416,234674,GetRules,1,node.SocketAddressBlockListWrap.GetRules,void node.SocketAddressBlockListWrap.GetRules (FunctionCallbackInfo<Value>),node_sockaddr.cc,"void SocketAddressBlockListWrap::GetRules(
    const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  SocketAddressBlockListWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
  Local<Array> rules;
  if (wrap->blocklist_->ListRules(env).ToLocal(&rules))
    args.GetReturnValue().Set(rules);
}",672.0,680.0,1.0,1.0,9.0,12,6,13,7,0,0,2,2,0,0,,0,0,2,1,1,void
4417,234722,MemoryInfo,1,node.SocketAddressBlockListWrap.MemoryInfo,void node.SocketAddressBlockListWrap.MemoryInfo (MemoryTracker*),node_sockaddr.cc,"void SocketAddressBlockListWrap::MemoryInfo(MemoryTracker* tracker) const {
  blocklist_->MemoryInfo(tracker);
}",682.0,684.0,1.0,1.0,3.0,1,1,2,2,0,0,1,1,0,0,,0,0,2,1,1,void
4418,234732,CloneForMessaging,1,node.SocketAddressBlockListWrap.CloneForMessaging,unique_ptr<worker::TransferData> node.SocketAddressBlockListWrap.CloneForMessaging (),node_sockaddr.cc,"std::unique_ptr<worker::TransferData>
SocketAddressBlockListWrap::CloneForMessaging() const {
  return std::make_unique<TransferData>(this);
}",686.0,689.0,1.0,1.0,4.0,3,3,2,2,0,0,1,1,0,0,,0,0,0,0,0,unique_ptr<worker.TransferData>
4419,234744,HasInstance,1,node.SocketAddressBlockListWrap.HasInstance,"bool node.SocketAddressBlockListWrap.HasInstance (Environment*,Local<Value>)",node_sockaddr.cc,"bool SocketAddressBlockListWrap::HasInstance(
    Environment* env,
    Local<Value> value) {
  return GetConstructorTemplate(env)->HasInstance(value);
}",691.0,695.0,1.0,1.0,5.0,1,1,2,2,0,0,1,1,0,0,,0,0,4,2,2,bool
4420,234757,GetConstructorTemplate,1,node.SocketAddressBlockListWrap.GetConstructorTemplate,Local<FunctionTemplate> node.SocketAddressBlockListWrap.GetConstructorTemplate (Environment*),node_sockaddr.cc,"Local<FunctionTemplate> SocketAddressBlockListWrap::GetConstructorTemplate(
    Environment* env) {
  Local<FunctionTemplate> tmpl = env->blocklist_constructor_template();
  if (tmpl.IsEmpty()) {
    Isolate* isolate = env->isolate();
    tmpl = NewFunctionTemplate(isolate, SocketAddressBlockListWrap::New);
    tmpl->SetClassName(FIXED_ONE_BYTE_STRING(env->isolate(), ""BlockList""));
    tmpl->InstanceTemplate()->SetInternalFieldCount(kInternalFieldCount);
    SetProtoMethod(isolate, tmpl, ""addAddress"", AddAddress);
    SetProtoMethod(isolate, tmpl, ""addRange"", AddRange);
    SetProtoMethod(isolate, tmpl, ""addSubnet"", AddSubnet);
    SetProtoMethod(isolate, tmpl, ""check"", Check);
    SetProtoMethod(isolate, tmpl, ""getRules"", GetRules);
    env->set_blocklist_constructor_template(tmpl);
  }
  return tmpl;
}",697.0,713.0,1.0,1.0,17.0,14,5,32,12,0,0,2,2,0,0,,0,0,2,1,1,Local<FunctionTemplate>
4421,234842,Initialize,1,node.SocketAddressBlockListWrap.Initialize,"void node.SocketAddressBlockListWrap.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)",node_sockaddr.cc,"void SocketAddressBlockListWrap::Initialize(
    Local<Object> target,
    Local<Value> unused,
    Local<Context> context,
    void* priv) {
  Environment* env = Environment::GetCurrent(context);

  SetConstructorFunction(context,
                         target,
                         ""BlockList"",
                         GetConstructorTemplate(env),
                         SetConstructorFunctionFlag::NONE);

  SocketAddressBase::Initialize(env, target);

  NODE_DEFINE_CONSTANT(target, AF_INET);
  NODE_DEFINE_CONSTANT(target, AF_INET6);
}",715.0,732.0,1.0,1.0,18.0,4,2,14,8,0,0,1,1,0,0,,0,0,8,4,4,void
4422,234879,Deserialize,1,node.SocketAddressBlockListWrap.TransferData.Deserialize,"BaseObjectPtr<BaseObject> node.SocketAddressBlockListWrap.TransferData.Deserialize (Environment*,Local<Context>,ANY)",node_sockaddr.cc,"BaseObjectPtr<BaseObject> SocketAddressBlockListWrap::TransferData::Deserialize(
    Environment* env,
    Local<Context> context,
    std::unique_ptr<worker::TransferData> self) {
  return New(env, std::move(blocklist_));
}",734.0,739.0,1.0,1.0,6.0,1,1,3,3,0,0,1,1,0,0,,0,0,6,3,3,BaseObjectPtr<BaseObject>
4423,234894,MemoryInfo,1,node.SocketAddressBlockListWrap.TransferData.MemoryInfo,void node.SocketAddressBlockListWrap.TransferData.MemoryInfo (MemoryTracker*),node_sockaddr.cc,"void SocketAddressBlockListWrap::TransferData::MemoryInfo(
    MemoryTracker* tracker) const {
  blocklist_->MemoryInfo(tracker);
}",741.0,744.0,1.0,1.0,4.0,1,1,2,2,0,0,1,1,0,0,,0,0,2,1,1,void
4424,234904,HasInstance,1,node.SocketAddressBase.HasInstance,"bool node.SocketAddressBase.HasInstance (Environment*,Local<Value>)",node_sockaddr.cc,"bool SocketAddressBase::HasInstance(Environment* env, Local<Value> value) {
  return GetConstructorTemplate(env)->HasInstance(value);
}",746.0,748.0,1.0,1.0,3.0,1,1,2,2,0,0,1,1,0,0,,0,0,4,2,2,bool
4425,234917,GetConstructorTemplate,1,node.SocketAddressBase.GetConstructorTemplate,Local<FunctionTemplate> node.SocketAddressBase.GetConstructorTemplate (Environment*),node_sockaddr.cc,"Local<FunctionTemplate> SocketAddressBase::GetConstructorTemplate(
    Environment* env) {
  Local<FunctionTemplate> tmpl = env->socketaddress_constructor_template();
  if (tmpl.IsEmpty()) {
    Isolate* isolate = env->isolate();
    tmpl = NewFunctionTemplate(isolate, New);
    tmpl->SetClassName(FIXED_ONE_BYTE_STRING(env->isolate(), ""SocketAddress""));
    tmpl->InstanceTemplate()->SetInternalFieldCount(
        SocketAddressBase::kInternalFieldCount);
    SetProtoMethod(isolate, tmpl, ""detail"", Detail);
    SetProtoMethod(isolate, tmpl, ""legacyDetail"", LegacyDetail);
    SetProtoMethodNoSideEffect(isolate, tmpl, ""flowlabel"", GetFlowLabel);
    env->set_socketaddress_constructor_template(tmpl);
  }
  return tmpl;
}",750.0,765.0,1.0,1.0,16.0,14,5,26,10,0,0,2,2,0,0,,0,0,2,1,1,Local<FunctionTemplate>
4426,234992,Initialize,1,node.SocketAddressBase.Initialize,"void node.SocketAddressBase.Initialize (Environment*,Local<Object>)",node_sockaddr.cc,"void SocketAddressBase::Initialize(Environment* env, Local<Object> target) {
  SetConstructorFunction(env->context(),
                         target,
                         ""SocketAddress"",
                         GetConstructorTemplate(env),
                         SetConstructorFunctionFlag::NONE);
}",767.0,773.0,1.0,1.0,7.0,2,2,4,3,0,0,1,1,0,0,,0,0,4,2,2,void
4427,235010,Create,1,node.SocketAddressBase.Create,"BaseObjectPtr<SocketAddressBase> node.SocketAddressBase.Create (Environment*,ANY)",node_sockaddr.cc,"BaseObjectPtr<SocketAddressBase> SocketAddressBase::Create(
    Environment* env,
    std::shared_ptr<SocketAddress> address) {
  Local<Object> obj;
  if (!GetConstructorTemplate(env)
          ->InstanceTemplate()
          ->NewInstance(env->context()).ToLocal(&obj)) {
    return BaseObjectPtr<SocketAddressBase>();
  }

  return MakeBaseObject<SocketAddressBase>(env, obj, std::move(address));
}",775.0,786.0,1.0,1.0,12.0,13,8,12,8,0,0,2,2,0,0,,0,0,4,2,2,BaseObjectPtr<SocketAddressBase>
4428,235057,New,1,node.SocketAddressBase.New,void node.SocketAddressBase.New (FunctionCallbackInfo<Value>),node_sockaddr.cc,"void SocketAddressBase::New(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  CHECK(args.IsConstructCall());
  CHECK(args[0]->IsString());  // address
  CHECK(args[1]->IsInt32());  // port
  CHECK(args[2]->IsInt32());  // family
  CHECK(args[3]->IsUint32());  // flow label

  Utf8Value address(env->isolate(), args[0]);
  int32_t port = args[1].As<Int32>()->Value();
  int32_t family = args[2].As<Int32>()->Value();
  uint32_t flow_label = args[3].As<Uint32>()->Value();

  std::shared_ptr<SocketAddress> addr = std::make_shared<SocketAddress>();

  if (!SocketAddress::New(family, *address, port, addr.get()))
    return THROW_ERR_INVALID_ADDRESS(env);

  addr->set_flow_label(flow_label);

  new SocketAddressBase(env, args.This(), std::move(addr));
}",788.0,809.0,1.0,1.0,22.0,38,9,33,11,0,0,2,2,0,0,,0,0,2,1,1,void
4429,235195,Detail,1,node.SocketAddressBase.Detail,void node.SocketAddressBase.Detail (FunctionCallbackInfo<Value>),node_sockaddr.cc,"void SocketAddressBase::Detail(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  CHECK(args[0]->IsObject());
  Local<Object> detail = args[0].As<Object>();

  SocketAddressBase* base;
  ASSIGN_OR_RETURN_UNWRAP(&base, args.Holder());

  Local<Value> address;
  if (!ToV8Value(env->context(), base->address_->address()).ToLocal(&address))
    return;

  if (detail->Set(env->context(), env->address_string(), address).IsJust() &&
      detail->Set(
          env->context(),
          env->port_string(),
          Int32::New(env->isolate(), base->address_->port())).IsJust() &&
      detail->Set(
          env->context(),
          env->family_string(),
          Int32::New(env->isolate(), base->address_->family())).IsJust() &&
      detail->Set(
          env->context(),
          env->flowlabel_string(),
          Uint32::New(env->isolate(), base->address_->flow_label()))
              .IsJust()) {
    args.GetReturnValue().Set(detail);
  }
}",811.0,839.0,1.0,1.0,29.0,52,9,40,11,0,0,3,3,0,0,,0,0,2,1,1,void
4430,235376,GetFlowLabel,1,node.SocketAddressBase.GetFlowLabel,void node.SocketAddressBase.GetFlowLabel (FunctionCallbackInfo<Value>),node_sockaddr.cc,"void SocketAddressBase::GetFlowLabel(const FunctionCallbackInfo<Value>& args) {
  SocketAddressBase* base;
  ASSIGN_OR_RETURN_UNWRAP(&base, args.Holder());
  args.GetReturnValue().Set(base->address_->flow_label());
}",841.0,845.0,1.0,1.0,5.0,6,3,4,2,0,0,1,1,0,0,,0,0,2,1,1,void
4431,235402,LegacyDetail,1,node.SocketAddressBase.LegacyDetail,void node.SocketAddressBase.LegacyDetail (FunctionCallbackInfo<Value>),node_sockaddr.cc,"void SocketAddressBase::LegacyDetail(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  SocketAddressBase* base;
  ASSIGN_OR_RETURN_UNWRAP(&base, args.Holder());
  Local<Object> address;
  if (!base->address_->ToJS(env).ToLocal(&address)) return;
  args.GetReturnValue().Set(address);
}",847.0,854.0,1.0,1.0,8.0,13,7,13,7,0,0,2,2,0,0,,0,0,2,1,1,void
4432,235452,SocketAddressBase,1,node.SocketAddressBase.SocketAddressBase,"ANY node.SocketAddressBase.SocketAddressBase (Environment*,Local<Object>,ANY)",node_sockaddr.cc,"SocketAddressBase::SocketAddressBase(
    Environment* env,
    Local<Object> wrap,
    std::shared_ptr<SocketAddress> address)
    : BaseObject(env, wrap),
      address_(std::move(address)) {
  MakeWeak();
}",856.0,863.0,1.0,1.0,8.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,ANY
4433,235460,MemoryInfo,1,node.SocketAddressBase.MemoryInfo,void node.SocketAddressBase.MemoryInfo (MemoryTracker*),node_sockaddr.cc,"void SocketAddressBase::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackField(""address"", address_);
}",865.0,867.0,1.0,1.0,3.0,1,1,2,2,0,0,1,1,0,0,,0,0,2,1,1,void
4434,235471,CloneForMessaging,1,node.SocketAddressBase.CloneForMessaging,unique_ptr<worker::TransferData> node.SocketAddressBase.CloneForMessaging (),node_sockaddr.cc,"std::unique_ptr<worker::TransferData>
SocketAddressBase::CloneForMessaging() const {
  return std::make_unique<TransferData>(this);
}",869.0,872.0,1.0,1.0,4.0,3,3,2,2,0,0,1,1,0,0,,0,0,0,0,0,unique_ptr<worker.TransferData>
4435,235483,MemoryInfo,1,node.SocketAddressBase.TransferData.MemoryInfo,void node.SocketAddressBase.TransferData.MemoryInfo (MemoryTracker*),node_sockaddr.cc,"void SocketAddressBase::TransferData::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackField(""address"", address_);
}",874.0,876.0,1.0,1.0,3.0,1,1,2,2,0,0,1,1,0,0,,0,0,2,1,1,void
4436,235494,Deserialize,1,node.SocketAddressBase.TransferData.Deserialize,"BaseObjectPtr<BaseObject> node.SocketAddressBase.TransferData.Deserialize (Environment*,ANY,ANY)",node_sockaddr.cc,"BaseObjectPtr<BaseObject> SocketAddressBase::TransferData::Deserialize(
    Environment* env,
    v8::Local<v8::Context> context,
    std::unique_ptr<worker::TransferData> self) {
  return SocketAddressBase::Create(env, std::move(address_));
}",878.0,883.0,1.0,1.0,6.0,2,1,4,4,0,0,1,1,0,0,,0,0,6,3,3,BaseObjectPtr<BaseObject>
4437,235564,CreatePerIsolateProperties,1,node.StatWatcher.CreatePerIsolateProperties,"void node.StatWatcher.CreatePerIsolateProperties (IsolateData*,Local<FunctionTemplate>)",node_stat_watcher.cc,"void StatWatcher::CreatePerIsolateProperties(IsolateData* isolate_data,
                                             Local<FunctionTemplate> ctor) {
  Isolate* isolate = isolate_data->isolate();
  Local<ObjectTemplate> target = ctor->InstanceTemplate();

  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, StatWatcher::New);
  t->InstanceTemplate()->SetInternalFieldCount(
      StatWatcher::kInternalFieldCount);
  t->Inherit(HandleWrap::GetConstructorTemplate(isolate_data));
  SetProtoMethod(isolate, t, ""start"", StatWatcher::Start);

  SetConstructorFunction(isolate, target, ""StatWatcher"", t);
}",47.0,59.0,1.0,1.0,13.0,16,5,22,10,0,0,1,1,0,0,,0,0,4,2,2,void
4438,235629,RegisterExternalReferences,1,node.StatWatcher.RegisterExternalReferences,void node.StatWatcher.RegisterExternalReferences (ExternalReferenceRegistry*),node_stat_watcher.cc,"void StatWatcher::RegisterExternalReferences(
    ExternalReferenceRegistry* registry) {
  registry->Register(StatWatcher::New);
  registry->Register(StatWatcher::Start);
}",61.0,65.0,1.0,1.0,5.0,4,2,4,2,0,0,1,1,0,0,,0,0,2,1,1,void
4439,235648,StatWatcher,1,node.StatWatcher.StatWatcher,"ANY node.StatWatcher.StatWatcher (ANY*,Local<Object>,bool)",node_stat_watcher.cc,"StatWatcher::StatWatcher(fs::BindingData* binding_data,
                         Local<Object> wrap,
                         bool use_bigint)
    : HandleWrap(binding_data->env(),
                 wrap,
                 reinterpret_cast<uv_handle_t*>(&watcher_),
                 AsyncWrap::PROVIDER_STATWATCHER),
      use_bigint_(use_bigint),
      binding_data_(binding_data) {
  CHECK_EQ(0, uv_fs_poll_init(env()->event_loop(), &watcher_));
}",67.0,77.0,1.0,1.0,11.0,2,2,1,1,0,0,1,1,0,0,,0,0,6,3,3,ANY
4440,235664,Callback,1,node.StatWatcher.Callback,"void node.StatWatcher.Callback (uv_fs_poll_t*,int,uv_stat_t*,uv_stat_t*)",node_stat_watcher.cc,"void StatWatcher::Callback(uv_fs_poll_t* handle,
                           int status,
                           const uv_stat_t* prev,
                           const uv_stat_t* curr) {
  StatWatcher* wrap = ContainerOf(&StatWatcher::watcher_, handle);
  Environment* env = wrap->env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  Local<Value> arr = fs::FillGlobalStatsArray(
      wrap->binding_data_.get(), wrap->use_bigint_, curr);
  USE(fs::FillGlobalStatsArray(
      wrap->binding_data_.get(), wrap->use_bigint_, prev, true));

  Local<Value> argv[2] = { Integer::New(env->isolate(), status), arr };
  wrap->MakeCallback(env->onchange_string(), arraysize(argv), argv);
}",80.0,96.0,1.0,1.0,17.0,24,7,25,11,0,0,1,1,0,0,,0,0,8,4,4,void
4441,235755,New,1,node.StatWatcher.New,void node.StatWatcher.New (FunctionCallbackInfo<Value>),node_stat_watcher.cc,"void StatWatcher::New(const FunctionCallbackInfo<Value>& args) {
  CHECK(args.IsConstructCall());
  fs::BindingData* binding_data = Realm::GetBindingData<fs::BindingData>(args);
  new StatWatcher(binding_data, args.This(), args[0]->IsTrue());
}",99.0,103.0,1.0,1.0,5.0,10,7,9,5,0,0,1,1,0,0,,0,0,2,1,1,void
4442,235790,Start,1,node.StatWatcher.Start,void node.StatWatcher.Start (FunctionCallbackInfo<Value>),node_stat_watcher.cc,"void StatWatcher::Start(const FunctionCallbackInfo<Value>& args) {
  CHECK_EQ(args.Length(), 2);

  StatWatcher* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
  CHECK(!uv_is_active(wrap->GetHandle()));

  node::Utf8Value path(args.GetIsolate(), args[0]);
  CHECK_NOT_NULL(*path);

  CHECK(args[1]->IsUint32());
  const uint32_t interval = args[1].As<Uint32>()->Value();

  // Note that uv_fs_poll_start does not return ENOENT, we are handling
  // mostly memory errors here.
  const int err = uv_fs_poll_start(&wrap->watcher_, Callback, *path, interval);
  if (err != 0) {
    args.GetReturnValue().Set(err);
  }
}",106.0,125.0,1.0,1.0,20.0,21,8,18,6,0,0,2,2,0,0,,0,0,2,1,1,void
4443,235898,Initialize,1,node.symbols.Initialize,"void node.symbols.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)",node_symbols.cc,"static void Initialize(Local<Object> target,
                       Local<Value> unused,
                       Local<Context> context,
                       void* priv) {
  Environment* env = Environment::GetCurrent(context);
#define V(PropertyName, StringValue)                                           \
  target                                                                       \
      ->Set(env->context(),                                                    \
            env->PropertyName()->Description(env->isolate()),                  \
            env->PropertyName())                                               \
      .Check();
  PER_ISOLATE_SYMBOL_PROPERTIES(V)
#undef V
}",14.0,27.0,1.0,1.0,14.0,2,2,3,3,0,0,1,1,0,0,,0,0,8,4,4,void
4444,235943,GetAssignedPromiseAsyncId,1,node.GetAssignedPromiseAsyncId,"Maybe<double> node.GetAssignedPromiseAsyncId (Environment*,Local<Promise>,Local<Value>)",node_task_queue.cc,"static Maybe<double> GetAssignedPromiseAsyncId(Environment* env,
                                               Local<Promise> promise,
                                               Local<Value> id_symbol) {
  Local<Value> maybe_async_id;
  if (!promise->Get(env->context(), id_symbol).ToLocal(&maybe_async_id)) {
    return v8::Just(AsyncWrap::kInvalidAsyncId);
  }
  return maybe_async_id->IsNumber()
      ? maybe_async_id->NumberValue(env->context())
      : v8::Just(AsyncWrap::kInvalidAsyncId);
}",34.0,44.0,1.0,1.0,11.0,15,7,14,8,0,0,2,2,0,0,,0,0,6,3,3,Maybe<double>
4445,236001,GetAssignedPromiseWrapAsyncId,1,node.GetAssignedPromiseWrapAsyncId,"Maybe<double> node.GetAssignedPromiseWrapAsyncId (Environment*,Local<Promise>,Local<Value>)",node_task_queue.cc,"static Maybe<double> GetAssignedPromiseWrapAsyncId(Environment* env,
                                                   Local<Promise> promise,
                                                   Local<Value> id_symbol) {
  // This check is imperfect. If the internal field is set, it should
  // be an object. If it's not, we just ignore it. Ideally v8 would
  // have had GetInternalField returning a MaybeLocal but this works
  // for now.
  Local<Value> promiseWrap = promise->GetInternalField(0);
  if (promiseWrap->IsObject()) {
        Local<Value> maybe_async_id;
    if (!promiseWrap.As<Object>()->Get(env->context(), id_symbol)
        .ToLocal(&maybe_async_id)) {
      return v8::Just(AsyncWrap::kInvalidAsyncId);
    }
    return maybe_async_id->IsNumber()
        ? maybe_async_id->NumberValue(env->context())
        : v8::Just(AsyncWrap::kInvalidAsyncId);
  } else {
      return v8::Just(AsyncWrap::kInvalidAsyncId);
  }
}",46.0,66.0,1.0,1.0,21.0,21,8,19,9,0,0,3,4,0,0,,0,0,6,3,3,Maybe<double>
4446,236454,EnqueueMicrotask,1,node.task_queue.EnqueueMicrotask,void node.task_queue.EnqueueMicrotask (FunctionCallbackInfo<Value>),node_task_queue.cc,"static void EnqueueMicrotask(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  CHECK(args[0]->IsFunction());

  isolate->GetCurrentContext()->GetMicrotaskQueue()
      ->EnqueueMicrotask(isolate, args[0].As<Function>());
}",163.0,171.0,1.0,1.0,9.0,11,4,9,4,0,0,1,1,0,0,,0,0,2,1,1,void
4447,236498,RunMicrotasks,1,node.task_queue.RunMicrotasks,void node.task_queue.RunMicrotasks (FunctionCallbackInfo<Value>),node_task_queue.cc,"static void RunMicrotasks(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  env->context()->GetMicrotaskQueue()->PerformCheckpoint(env->isolate());
}",173.0,176.0,1.0,1.0,4.0,6,3,5,3,0,0,1,1,0,0,,0,0,2,1,1,void
4448,236525,SetTickCallback,1,node.task_queue.SetTickCallback,void node.task_queue.SetTickCallback (FunctionCallbackInfo<Value>),node_task_queue.cc,"static void SetTickCallback(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  CHECK(args[0]->IsFunction());
  env->set_tick_callback_function(args[0].As<Function>());
}",178.0,182.0,1.0,1.0,5.0,7,4,6,3,0,0,1,1,0,0,,0,0,2,1,1,void
4449,236555,SetPromiseRejectCallback,1,node.task_queue.SetPromiseRejectCallback,void node.task_queue.SetPromiseRejectCallback (FunctionCallbackInfo<Value>),node_task_queue.cc,"static void SetPromiseRejectCallback(
    const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  CHECK(args[0]->IsFunction());
  env->set_promise_reject_callback(args[0].As<Function>());
}",184.0,190.0,1.0,1.0,7.0,7,4,6,3,0,0,1,1,0,0,,0,0,2,1,1,void
4450,236585,Initialize,1,node.task_queue.Initialize,"void node.task_queue.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)",node_task_queue.cc,"static void Initialize(Local<Object> target,
                       Local<Value> unused,
                       Local<Context> context,
                       void* priv) {
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  SetMethod(context, target, ""enqueueMicrotask"", EnqueueMicrotask);
  SetMethod(context, target, ""setTickCallback"", SetTickCallback);
  SetMethod(context, target, ""runMicrotasks"", RunMicrotasks);
  target->Set(env->context(),
              FIXED_ONE_BYTE_STRING(isolate, ""tickInfo""),
              env->tick_info()->fields().GetJSArray()).Check();

  Local<Object> events = Object::New(isolate);
  NODE_DEFINE_CONSTANT(events, kPromiseRejectWithNoHandler);
  NODE_DEFINE_CONSTANT(events, kPromiseHandlerAddedAfterReject);
  NODE_DEFINE_CONSTANT(events, kPromiseResolveAfterResolved);
  NODE_DEFINE_CONSTANT(events, kPromiseRejectAfterResolved);

  target->Set(env->context(),
              FIXED_ONE_BYTE_STRING(isolate, ""promiseRe...",192.0,217.0,1.0,2.0,26.0,149,7,150,19,0,0,1,1,0,0,,0,0,8,4,4,void
4451,237074,RegisterExternalReferences,1,node.task_queue.RegisterExternalReferences,void node.task_queue.RegisterExternalReferences (ExternalReferenceRegistry*),node_task_queue.cc,"void RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  registry->Register(EnqueueMicrotask);
  registry->Register(SetTickCallback);
  registry->Register(RunMicrotasks);
  registry->Register(SetPromiseRejectCallback);
}",219.0,224.0,1.0,1.0,6.0,4,1,4,1,0,0,1,1,0,0,,0,0,2,1,1,void
4452,237148,Initialize,1,node.NodeCategorySet.Initialize,"void node.NodeCategorySet.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)",node_trace_events.cc,"void NodeCategorySet::Initialize(Local<Object> target,
                Local<Value> unused,
                Local<Context> context,
                void* priv) {
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  SetMethod(context, target, ""getEnabledCategories"", GetEnabledCategories);
  SetMethod(context,
            target,
            ""setTraceCategoryStateUpdateHandler"",
            SetTraceCategoryStateUpdateHandler);

  Local<FunctionTemplate> category_set =
      NewFunctionTemplate(isolate, NodeCategorySet::New);
  category_set->InstanceTemplate()->SetInternalFieldCount(
      NodeCategorySet::kInternalFieldCount);
  SetProtoMethod(isolate, category_set, ""enable"", NodeCategorySet::Enable);
  SetProtoMethod(isolate, category_set, ""disable"", NodeCategorySet::Disable);

  SetConstructorFunction(context, target, ""CategorySet"", category_set);

  Local<String> isTraceCategoryEnabled =
      FIXED_ONE_BYTE_STRING(env->isolate(), ""isTraceC...",123.0,157.0,1.0,1.0,35.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,void
4453,237156,RegisterExternalReferences,1,node.NodeCategorySet.RegisterExternalReferences,void node.NodeCategorySet.RegisterExternalReferences (ExternalReferenceRegistry*),node_trace_events.cc,"void NodeCategorySet::RegisterExternalReferences(
    ExternalReferenceRegistry* registry) {
  registry->Register(GetEnabledCategories);
  registry->Register(SetTraceCategoryStateUpdateHandler);
  registry->Register(NodeCategorySet::New);
  registry->Register(NodeCategorySet::Enable);
  registry->Register(NodeCategorySet::Disable);
}",159.0,166.0,1.0,1.0,8.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
4454,237161,New,1,node.NodeCategorySet.New,void node.NodeCategorySet.New (FunctionCallbackInfo<Value>),node_trace_events.cc,"void NodeCategorySet::New(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  std::set<std::string> categories;
  CHECK(args[0]->IsArray());
  Local<Array> cats = args[0].As<Array>();
  for (size_t n = 0; n < cats->Length(); n++) {
    Local<Value> category;
    if (!cats->Get(env->context(), n).ToLocal(&category)) return;
    Utf8Value val(env->isolate(), category);
    if (!*val) return;
    categories.emplace(*val);
  }
  CHECK_NOT_NULL(GetTracingAgentWriter());
  new NodeCategorySet(env, args.This(), std::move(categories));
}",62.0,76.0,1.0,1.0,15.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
4455,237166,Enable,1,node.NodeCategorySet.Enable,void node.NodeCategorySet.Enable (FunctionCallbackInfo<Value>),node_trace_events.cc,"void NodeCategorySet::Enable(const FunctionCallbackInfo<Value>& args) {
  NodeCategorySet* category_set;
  ASSIGN_OR_RETURN_UNWRAP(&category_set, args.Holder());
  CHECK_NOT_NULL(category_set);
  const auto& categories = category_set->GetCategories();
  if (!category_set->enabled_ && !categories.empty()) {
    // Starts the Tracing Agent if it wasn't started already (e.g. through
    // a command line flag.)
    StartTracingAgent();
    GetTracingAgentWriter()->Enable(categories);
    category_set->enabled_ = true;
  }
}",78.0,90.0,1.0,1.0,13.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
4456,237171,Disable,1,node.NodeCategorySet.Disable,void node.NodeCategorySet.Disable (FunctionCallbackInfo<Value>),node_trace_events.cc,"void NodeCategorySet::Disable(const FunctionCallbackInfo<Value>& args) {
  NodeCategorySet* category_set;
  ASSIGN_OR_RETURN_UNWRAP(&category_set, args.Holder());
  CHECK_NOT_NULL(category_set);
  const auto& categories = category_set->GetCategories();
  if (category_set->enabled_ && !categories.empty()) {
    GetTracingAgentWriter()->Disable(categories);
    category_set->enabled_ = false;
  }
}",92.0,101.0,1.0,1.0,10.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
4457,237176,GetCategories,1,node.NodeCategorySet.GetCategories,set<std::string> node.NodeCategorySet.GetCategories (),node_trace_events.cc,const std::set<std::string>& GetCategories() const { return categories_; },41.0,41.0,3.0,76.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,set<std.string>
4458,237182,MemoryInfo,1,node.NodeCategorySet.MemoryInfo,void node.NodeCategorySet.MemoryInfo (MemoryTracker*),node_trace_events.cc,"void MemoryInfo(MemoryTracker* tracker) const override {
    tracker->TrackField(""categories"", categories_);
  }",43.0,45.0,3.0,3.0,3.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
4459,237197,NodeCategorySet,1,node.NodeCategorySet.NodeCategorySet,"ANY node.NodeCategorySet.NodeCategorySet (Environment*,Local<Object>,ANY)",node_trace_events.cc,"NodeCategorySet(Environment* env,
                  Local<Object> wrap,
                  std::set<std::string>&& categories) :
        BaseObject(env, wrap), categories_(std::move(categories)) {
    MakeWeak();
  }",51.0,56.0,3.0,3.0,6.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,ANY
4460,237413,GetEnabledCategories,1,node.GetEnabledCategories,void node.GetEnabledCategories (FunctionCallbackInfo<Value>),node_trace_events.cc,"void GetEnabledCategories(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  std::string categories =
      GetTracingAgentWriter()->agent()->GetEnabledCategories();
  if (!categories.empty()) {
    args.GetReturnValue().Set(
      String::NewFromUtf8(env->isolate(),
                          categories.c_str(),
                          NewStringType::kNormal,
                          categories.size()).ToLocalChecked());
  }
}",103.0,114.0,1.0,1.0,12.0,15,4,11,6,0,0,2,2,0,0,,0,0,2,1,1,void
4461,237472,SetTraceCategoryStateUpdateHandler,1,node.SetTraceCategoryStateUpdateHandler,void node.SetTraceCategoryStateUpdateHandler (FunctionCallbackInfo<Value>),node_trace_events.cc,"static void SetTraceCategoryStateUpdateHandler(
    const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  CHECK(args[0]->IsFunction());
  env->set_trace_category_state_function(args[0].As<Function>());
}",116.0,121.0,1.0,1.0,6.0,7,4,6,3,0,0,1,1,0,0,,0,0,2,1,1,void
4462,237695,IsExternal,1,node.anonymous_namespace_1.IsExternal,void node.anonymous_namespace_1.IsExternal (FunctionCallbackInfo<Value>),node_types.cc,VALUE_METHOD_MAP(V),47.0,47.0,3.0,21.0,1.0,4,3,2,1,0,0,1,1,0,0,,0,0,2,1,1,void
4463,237713,IsDate,1,node.anonymous_namespace_2.IsDate,void node.anonymous_namespace_2.IsDate (FunctionCallbackInfo<Value>),node_types.cc,VALUE_METHOD_MAP(V),47.0,47.0,3.0,21.0,1.0,4,3,2,1,0,0,1,1,0,0,,0,0,2,1,1,void
4464,237731,IsArgumentsObject,1,node.anonymous_namespace_3.IsArgumentsObject,void node.anonymous_namespace_3.IsArgumentsObject (FunctionCallbackInfo<Value>),node_types.cc,VALUE_METHOD_MAP(V),47.0,47.0,3.0,21.0,1.0,4,3,2,1,0,0,1,1,0,0,,0,0,2,1,1,void
4465,237749,IsBigIntObject,1,node.anonymous_namespace_4.IsBigIntObject,void node.anonymous_namespace_4.IsBigIntObject (FunctionCallbackInfo<Value>),node_types.cc,VALUE_METHOD_MAP(V),47.0,47.0,3.0,21.0,1.0,4,3,2,1,0,0,1,1,0,0,,0,0,2,1,1,void
4466,237767,IsBooleanObject,1,node.anonymous_namespace_5.IsBooleanObject,void node.anonymous_namespace_5.IsBooleanObject (FunctionCallbackInfo<Value>),node_types.cc,VALUE_METHOD_MAP(V),47.0,47.0,3.0,21.0,1.0,4,3,2,1,0,0,1,1,0,0,,0,0,2,1,1,void
4467,237785,IsNumberObject,1,node.anonymous_namespace_6.IsNumberObject,void node.anonymous_namespace_6.IsNumberObject (FunctionCallbackInfo<Value>),node_types.cc,VALUE_METHOD_MAP(V),47.0,47.0,3.0,21.0,1.0,4,3,2,1,0,0,1,1,0,0,,0,0,2,1,1,void
4468,237803,IsStringObject,1,node.anonymous_namespace_7.IsStringObject,void node.anonymous_namespace_7.IsStringObject (FunctionCallbackInfo<Value>),node_types.cc,VALUE_METHOD_MAP(V),47.0,47.0,3.0,21.0,1.0,4,3,2,1,0,0,1,1,0,0,,0,0,2,1,1,void
4469,237821,IsSymbolObject,1,node.anonymous_namespace_8.IsSymbolObject,void node.anonymous_namespace_8.IsSymbolObject (FunctionCallbackInfo<Value>),node_types.cc,VALUE_METHOD_MAP(V),47.0,47.0,3.0,21.0,1.0,4,3,2,1,0,0,1,1,0,0,,0,0,2,1,1,void
4470,237839,IsNativeError,1,node.anonymous_namespace_9.IsNativeError,void node.anonymous_namespace_9.IsNativeError (FunctionCallbackInfo<Value>),node_types.cc,VALUE_METHOD_MAP(V),47.0,47.0,3.0,21.0,1.0,4,3,2,1,0,0,1,1,0,0,,0,0,2,1,1,void
4471,237857,IsRegExp,1,node.anonymous_namespace_10.IsRegExp,void node.anonymous_namespace_10.IsRegExp (FunctionCallbackInfo<Value>),node_types.cc,VALUE_METHOD_MAP(V),47.0,47.0,3.0,21.0,1.0,4,3,2,1,0,0,1,1,0,0,,0,0,2,1,1,void
4472,237875,IsAsyncFunction,1,node.anonymous_namespace_11.IsAsyncFunction,void node.anonymous_namespace_11.IsAsyncFunction (FunctionCallbackInfo<Value>),node_types.cc,VALUE_METHOD_MAP(V),47.0,47.0,3.0,21.0,1.0,4,3,2,1,0,0,1,1,0,0,,0,0,2,1,1,void
4473,237893,IsGeneratorFunction,1,node.anonymous_namespace_12.IsGeneratorFunction,void node.anonymous_namespace_12.IsGeneratorFunction (FunctionCallbackInfo<Value>),node_types.cc,VALUE_METHOD_MAP(V),47.0,47.0,3.0,21.0,1.0,4,3,2,1,0,0,1,1,0,0,,0,0,2,1,1,void
4474,237911,IsGeneratorObject,1,node.anonymous_namespace_13.IsGeneratorObject,void node.anonymous_namespace_13.IsGeneratorObject (FunctionCallbackInfo<Value>),node_types.cc,VALUE_METHOD_MAP(V),47.0,47.0,3.0,21.0,1.0,4,3,2,1,0,0,1,1,0,0,,0,0,2,1,1,void
4475,237929,IsPromise,1,node.anonymous_namespace_14.IsPromise,void node.anonymous_namespace_14.IsPromise (FunctionCallbackInfo<Value>),node_types.cc,VALUE_METHOD_MAP(V),47.0,47.0,3.0,21.0,1.0,4,3,2,1,0,0,1,1,0,0,,0,0,2,1,1,void
4476,237947,IsMap,1,node.anonymous_namespace_15.IsMap,void node.anonymous_namespace_15.IsMap (FunctionCallbackInfo<Value>),node_types.cc,VALUE_METHOD_MAP(V),47.0,47.0,3.0,21.0,1.0,4,3,2,1,0,0,1,1,0,0,,0,0,2,1,1,void
4477,237965,IsSet,1,node.anonymous_namespace_16.IsSet,void node.anonymous_namespace_16.IsSet (FunctionCallbackInfo<Value>),node_types.cc,VALUE_METHOD_MAP(V),47.0,47.0,3.0,21.0,1.0,4,3,2,1,0,0,1,1,0,0,,0,0,2,1,1,void
4478,237983,IsMapIterator,1,node.anonymous_namespace_17.IsMapIterator,void node.anonymous_namespace_17.IsMapIterator (FunctionCallbackInfo<Value>),node_types.cc,VALUE_METHOD_MAP(V),47.0,47.0,3.0,21.0,1.0,4,3,2,1,0,0,1,1,0,0,,0,0,2,1,1,void
4479,238001,IsSetIterator,1,node.anonymous_namespace_18.IsSetIterator,void node.anonymous_namespace_18.IsSetIterator (FunctionCallbackInfo<Value>),node_types.cc,VALUE_METHOD_MAP(V),47.0,47.0,3.0,21.0,1.0,4,3,2,1,0,0,1,1,0,0,,0,0,2,1,1,void
4480,238019,IsWeakMap,1,node.anonymous_namespace_19.IsWeakMap,void node.anonymous_namespace_19.IsWeakMap (FunctionCallbackInfo<Value>),node_types.cc,VALUE_METHOD_MAP(V),47.0,47.0,3.0,21.0,1.0,4,3,2,1,0,0,1,1,0,0,,0,0,2,1,1,void
4481,238037,IsWeakSet,1,node.anonymous_namespace_20.IsWeakSet,void node.anonymous_namespace_20.IsWeakSet (FunctionCallbackInfo<Value>),node_types.cc,VALUE_METHOD_MAP(V),47.0,47.0,3.0,21.0,1.0,4,3,2,1,0,0,1,1,0,0,,0,0,2,1,1,void
4482,238055,IsArrayBuffer,1,node.anonymous_namespace_21.IsArrayBuffer,void node.anonymous_namespace_21.IsArrayBuffer (FunctionCallbackInfo<Value>),node_types.cc,VALUE_METHOD_MAP(V),47.0,47.0,3.0,21.0,1.0,4,3,2,1,0,0,1,1,0,0,,0,0,2,1,1,void
4483,238073,IsDataView,1,node.anonymous_namespace_22.IsDataView,void node.anonymous_namespace_22.IsDataView (FunctionCallbackInfo<Value>),node_types.cc,VALUE_METHOD_MAP(V),47.0,47.0,3.0,21.0,1.0,4,3,2,1,0,0,1,1,0,0,,0,0,2,1,1,void
4484,238091,IsSharedArrayBuffer,1,node.anonymous_namespace_23.IsSharedArrayBuffer,void node.anonymous_namespace_23.IsSharedArrayBuffer (FunctionCallbackInfo<Value>),node_types.cc,VALUE_METHOD_MAP(V),47.0,47.0,3.0,21.0,1.0,4,3,2,1,0,0,1,1,0,0,,0,0,2,1,1,void
4485,238109,IsProxy,1,node.anonymous_namespace_24.IsProxy,void node.anonymous_namespace_24.IsProxy (FunctionCallbackInfo<Value>),node_types.cc,VALUE_METHOD_MAP(V),47.0,47.0,3.0,21.0,1.0,4,3,2,1,0,0,1,1,0,0,,0,0,2,1,1,void
4486,238127,IsModuleNamespaceObject,1,node.anonymous_namespace_25.IsModuleNamespaceObject,void node.anonymous_namespace_25.IsModuleNamespaceObject (FunctionCallbackInfo<Value>),node_types.cc,VALUE_METHOD_MAP(V),47.0,47.0,3.0,21.0,1.0,4,3,2,1,0,0,1,1,0,0,,0,0,2,1,1,void
4487,238145,IsAnyArrayBuffer,1,node.anonymous_namespace_26.IsAnyArrayBuffer,void node.anonymous_namespace_26.IsAnyArrayBuffer (FunctionCallbackInfo<Value>),node_types.cc,"static void IsAnyArrayBuffer(const FunctionCallbackInfo<Value>& args) {
  args.GetReturnValue().Set(
    args[0]->IsArrayBuffer() || args[0]->IsSharedArrayBuffer());
}",50.0,53.0,1.0,1.0,4.0,7,4,3,1,0,0,1,1,0,0,,0,0,2,1,1,void
4488,238170,IsBoxedPrimitive,1,node.anonymous_namespace_27.IsBoxedPrimitive,void node.anonymous_namespace_27.IsBoxedPrimitive (FunctionCallbackInfo<Value>),node_types.cc,"static void IsBoxedPrimitive(const FunctionCallbackInfo<Value>& args) {
  args.GetReturnValue().Set(
    args[0]->IsNumberObject() ||
    args[0]->IsStringObject() ||
    args[0]->IsBooleanObject() ||
    args[0]->IsBigIntObject() ||
    args[0]->IsSymbolObject());
}",55.0,62.0,1.0,1.0,8.0,16,4,6,1,0,0,1,1,0,0,,0,0,2,1,1,void
4489,238216,InitializeTypes,1,node.anonymous_namespace_28.InitializeTypes,"void node.anonymous_namespace_28.InitializeTypes (Local<Object>,Local<Value>,Local<Context>,void*)",node_types.cc,"void InitializeTypes(Local<Object> target,
                     Local<Value> unused,
                     Local<Context> context,
                     void* priv) {
#define V(type) SetMethodNoSideEffect(context, target, ""is"" #type, Is##type);
  VALUE_METHOD_MAP(V)
#undef V

  SetMethodNoSideEffect(context, target, ""isAnyArrayBuffer"", IsAnyArrayBuffer);
  SetMethodNoSideEffect(context, target, ""isBoxedPrimitive"", IsBoxedPrimitive);
}",64.0,74.0,1.0,2.0,11.0,0,0,54,2,0,0,1,1,0,0,,0,0,8,4,4,void
4490,238363,RegisterTypesExternalReferences,1,node.RegisterTypesExternalReferences,void node.RegisterTypesExternalReferences (ExternalReferenceRegistry*),node_types.cc,"void RegisterTypesExternalReferences(ExternalReferenceRegistry* registry) {
#define V(type) registry->Register(Is##type);
  VALUE_METHOD_MAP(V)
#undef V

  registry->Register(IsAnyArrayBuffer);
  registry->Register(IsBoxedPrimitive);
}",78.0,85.0,1.0,2.0,8.0,27,1,27,1,0,0,1,1,0,0,,0,0,2,1,1,void
4491,238544,MemoryInfo,1,node.url.BindingData.MemoryInfo,void node.url.BindingData.MemoryInfo (MemoryTracker*),node_url.cc,"void BindingData::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackField(""url_components_buffer"", url_components_buffer_);
}",32.0,34.0,1.0,1.0,3.0,1,1,2,2,0,0,1,1,0,0,,0,0,2,1,1,void
4492,238555,BindingData,1,node.url.BindingData.BindingData,"ANY node.url.BindingData.BindingData (Realm*,ANY)",node_url.cc,"BindingData::BindingData(Realm* realm, v8::Local<v8::Object> object)
    : SnapshotableObject(realm, object, type_int),
      url_components_buffer_(realm->isolate(), kURLComponentsLength) {
  object
      ->Set(realm->context(),
            FIXED_ONE_BYTE_STRING(realm->isolate(), ""urlComponents""),
            url_components_buffer_.GetJSArray())
      .Check();
}",36.0,44.0,1.0,1.0,9.0,5,2,4,3,0,0,1,1,0,0,,0,0,4,2,2,ANY
4493,238582,PrepareForSerialization,1,node.url.BindingData.PrepareForSerialization,"bool node.url.BindingData.PrepareForSerialization (ANY,ANY*)",node_url.cc,"bool BindingData::PrepareForSerialization(v8::Local<v8::Context> context,
                                          v8::SnapshotCreator* creator) {
  // We'll just re-initialize the buffers in the constructor since their
  // contents can be thrown away once consumed in the previous call.
  url_components_buffer_.Release();
  // Return true because we need to maintain the reference to the binding from
  // JS land.
  return true;
}",46.0,54.0,1.0,1.0,9.0,1,1,1,1,0,0,1,1,0,0,,0,0,4,2,2,bool
4494,238594,Serialize,1,node.url.BindingData.Serialize,InternalFieldInfoBase node.url.BindingData.Serialize (int),node_url.cc,"InternalFieldInfoBase* BindingData::Serialize(int index) {
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  InternalFieldInfo* info =
      InternalFieldInfoBase::New<InternalFieldInfo>(type());
  return info;
}",56.0,61.0,1.0,1.0,6.0,5,4,6,5,0,0,1,1,0,0,,0,0,2,1,1,InternalFieldInfoBase
4495,238616,Deserialize,1,node.url.BindingData.Deserialize,"void node.url.BindingData.Deserialize (ANY,ANY,int,InternalFieldInfoBase*)",node_url.cc,"void BindingData::Deserialize(v8::Local<v8::Context> context,
                              v8::Local<v8::Object> holder,
                              int index,
                              InternalFieldInfoBase* info) {
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  v8::HandleScope scope(context->GetIsolate());
  Realm* realm = Realm::GetCurrent(context);
  BindingData* binding = realm->AddBindingData<BindingData>(context, holder);
  CHECK_NOT_NULL(binding);
}",63.0,72.0,1.0,1.0,10.0,10,7,12,8,0,0,1,1,0,0,,0,0,8,4,4,void
4496,238658,DomainToASCII,1,node.url.BindingData.DomainToASCII,void node.url.BindingData.DomainToASCII (FunctionCallbackInfo<Value>),node_url.cc,"void BindingData::DomainToASCII(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  CHECK_GE(args.Length(), 1);
  CHECK(args[0]->IsString());

  std::string input = Utf8Value(env->isolate(), args[0]).ToString();
  if (input.empty()) {
    return args.GetReturnValue().Set(FIXED_ONE_BYTE_STRING(env->isolate(), """"));
  }

  // It is important to have an initial value that contains a special scheme.
  // Since it will change the implementation of `set_hostname` according to URL
  // spec.
  auto out = ada::parse<ada::url>(""ws://x"");
  DCHECK(out);
  if (!out->set_hostname(input)) {
    return args.GetReturnValue().Set(FIXED_ONE_BYTE_STRING(env->isolate(), """"));
  }
  std::string host = out->get_hostname();
  args.GetReturnValue().Set(
      String::NewFromUtf8(env->isolate(), host.c_str()).ToLocalChecked());
}",74.0,95.0,1.0,1.0,22.0,31,7,25,8,0,0,3,3,0,0,,0,0,2,1,1,void
4497,238783,DomainToUnicode,1,node.url.BindingData.DomainToUnicode,void node.url.BindingData.DomainToUnicode (FunctionCallbackInfo<Value>),node_url.cc,"void BindingData::DomainToUnicode(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  CHECK_GE(args.Length(), 1);
  CHECK(args[0]->IsString());

  std::string input = Utf8Value(env->isolate(), args[0]).ToString();
  // It is important to have an initial value that contains a special scheme.
  // Since it will change the implementation of `set_hostname` according to URL
  // spec.
  auto out = ada::parse<ada::url>(""ws://x"");
  DCHECK(out);
  if (!out->set_hostname(input)) {
    return args.GetReturnValue().Set(
        String::NewFromUtf8(env->isolate(), """").ToLocalChecked());
  }
  std::string result = ada::unicode::to_unicode(out->get_hostname());

  args.GetReturnValue().Set(String::NewFromUtf8(env->isolate(),
                                                result.c_str(),
                                                NewStringType::kNormal,
                                                result.length())
                             ...",97.0,119.0,1.0,1.0,23.0,33,7,27,10,0,0,2,2,0,0,,0,0,2,1,1,void
4498,238907,CanParse,1,node.url.BindingData.CanParse,void node.url.BindingData.CanParse (FunctionCallbackInfo<Value>),node_url.cc,"void BindingData::CanParse(const FunctionCallbackInfo<Value>& args) {
  CHECK_GE(args.Length(), 1);
  CHECK(args[0]->IsString());  // input
  // args[1] // base url

  Environment* env = Environment::GetCurrent(args);
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  Utf8Value input(env->isolate(), args[0]);
  ada::result<ada::url_aggregator> base;
  ada::url_aggregator* base_pointer = nullptr;
  if (args[1]->IsString()) {
    base = ada::parse<ada::url_aggregator>(
        Utf8Value(env->isolate(), args[1]).ToString());
    if (!base) {
      return args.GetReturnValue().Set(false);
    }
    base_pointer = &base.value();
  }
  auto out =
      ada::parse<ada::url_aggregator>(input.ToStringView(), base_pointer);

  args.GetReturnValue().Set(out.has_value());
}",121.0,145.0,1.0,1.0,25.0,41,10,30,8,0,0,3,4,0,0,,0,0,2,1,1,void
4499,239045,FastCanParse,1,node.url.BindingData.FastCanParse,"bool node.url.BindingData.FastCanParse (Local<Value>,FastOneByteString)",node_url.cc,"bool BindingData::FastCanParse(Local<Value> receiver,
                               const FastOneByteString& input) {
  std::string_view input_view(input.data, input.length);

  auto output = ada::parse<ada::url_aggregator>(input_view);

  return output.has_value();
}",147.0,154.0,1.0,1.0,8.0,8,4,7,4,0,0,1,1,0,0,,0,0,4,2,2,bool
4500,239076,fast_can_parse_,1,node.url.fast_can_parse_,CFunction node.url.fast_can_parse_ (ANY),node_url.cc,CFunction BindingData::fast_can_parse_(CFunction::Make(FastCanParse));,156.0,156.0,11.0,69.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,CFunction
4501,239081,Format,1,node.url.BindingData.Format,void node.url.BindingData.Format (FunctionCallbackInfo<Value>),node_url.cc,"void BindingData::Format(const FunctionCallbackInfo<Value>& args) {
  CHECK_GT(args.Length(), 4);
  CHECK(args[0]->IsString());  // url href

  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  Utf8Value href(isolate, args[0].As<String>());
  const bool hash = args[1]->IsTrue();
  const bool unicode = args[2]->IsTrue();
  const bool search = args[3]->IsTrue();
  const bool auth = args[4]->IsTrue();

  // ada::url provides a faster alternative to ada::url_aggregator if we
  // directly want to manipulate the url components without using the respective
  // setters. therefore we are using ada::url here.
  auto out = ada::parse<ada::url>(href.ToStringView());
  CHECK(out);

  if (!hash) {
    out->hash = std::nullopt;
  }

  if (unicode) {
    out->host = ada::idna::to_unicode(out->get_hostname());
  }

  if (!search) {
    out->query = std::nullopt;
  }

  if (!auth) {
    out->username = """";
    out->password = """";
  }

  std::string result = o...",158.0,200.0,1.0,1.0,43.0,55,7,44,16,0,0,5,5,0,0,,0,0,2,1,1,void
4502,239265,Parse,1,node.url.BindingData.Parse,void node.url.BindingData.Parse (FunctionCallbackInfo<Value>),node_url.cc,"void BindingData::Parse(const FunctionCallbackInfo<Value>& args) {
  CHECK_GE(args.Length(), 1);
  CHECK(args[0]->IsString());  // input
  // args[1] // base url

  BindingData* binding_data = Realm::GetBindingData<BindingData>(args);
  Environment* env = Environment::GetCurrent(args);
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  Utf8Value input(env->isolate(), args[0]);
  ada::result<ada::url_aggregator> base;
  ada::url_aggregator* base_pointer = nullptr;
  if (args[1]->IsString()) {
    base = ada::parse<ada::url_aggregator>(
        Utf8Value(env->isolate(), args[1]).ToString());
    if (!base) {
      return args.GetReturnValue().Set(false);
    }
    base_pointer = &base.value();
  }
  auto out =
      ada::parse<ada::url_aggregator>(input.ToStringView(), base_pointer);

  if (!out) {
    return args.GetReturnValue().Set(false);
  }

  binding_data->UpdateComponents(out->get_components(), out->type);

  args.GetReturnValue().Se...",202.0,235.0,1.0,1.0,34.0,54,10,41,11,0,0,4,5,0,0,,0,0,2,1,1,void
4503,239449,Update,1,node.url.BindingData.Update,void node.url.BindingData.Update (FunctionCallbackInfo<Value>),node_url.cc,"void BindingData::Update(const FunctionCallbackInfo<Value>& args) {
  CHECK(args[0]->IsString());    // href
  CHECK(args[1]->IsNumber());    // action type
  CHECK(args[2]->IsString());    // new value

  BindingData* binding_data = Realm::GetBindingData<BindingData>(args);
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();

  enum url_update_action action = static_cast<enum url_update_action>(
      args[1]->Uint32Value(env->context()).FromJust());
  Utf8Value input(isolate, args[0].As<String>());
  Utf8Value new_value(isolate, args[2].As<String>());

  std::string_view new_value_view = new_value.ToStringView();
  auto out = ada::parse<ada::url_aggregator>(input.ToStringView());
  CHECK(out);

  bool result{true};

  switch (action) {
    case kPathname: {
      result = out->set_pathname(new_value_view);
      break;
    }
    case kHash: {
      out->set_hash(new_value_view);
      break;
    }
    case kHost: {
      result = out->set_host(...",237.0,310.0,1.0,1.0,74.0,64,9,75,24,0,0,13,3,0,0,,0,0,2,1,1,void
4504,239724,UpdateComponents,1,node.url.BindingData.UpdateComponents,"void node.url.BindingData.UpdateComponents (ANY,ANY)",node_url.cc,"void BindingData::UpdateComponents(const ada::url_components& components,
                                   const ada::scheme::type type) {
  url_components_buffer_[0] = components.protocol_end;
  url_components_buffer_[1] = components.username_end;
  url_components_buffer_[2] = components.host_start;
  url_components_buffer_[3] = components.host_end;
  url_components_buffer_[4] = components.port;
  url_components_buffer_[5] = components.pathname_start;
  url_components_buffer_[6] = components.search_start;
  url_components_buffer_[7] = components.hash_start;
  url_components_buffer_[8] = type;
  static_assert(kURLComponentsLength == 9,
                ""kURLComponentsLength should be up-to-date"");
}",312.0,325.0,1.0,1.0,14.0,27,4,19,4,0,0,1,1,0,0,,0,0,4,2,2,void
4505,239796,CreatePerIsolateProperties,1,node.url.BindingData.CreatePerIsolateProperties,"void node.url.BindingData.CreatePerIsolateProperties (IsolateData*,Local<FunctionTemplate>)",node_url.cc,"void BindingData::CreatePerIsolateProperties(IsolateData* isolate_data,
                                             Local<FunctionTemplate> ctor) {
  Isolate* isolate = isolate_data->isolate();
  Local<ObjectTemplate> target = ctor->InstanceTemplate();
  SetMethodNoSideEffect(isolate, target, ""domainToASCII"", DomainToASCII);
  SetMethodNoSideEffect(isolate, target, ""domainToUnicode"", DomainToUnicode);
  SetMethodNoSideEffect(isolate, target, ""format"", Format);
  SetMethod(isolate, target, ""parse"", Parse);
  SetMethod(isolate, target, ""update"", Update);
  SetFastMethodNoSideEffect(
      isolate, target, ""canParse"", CanParse, &fast_can_parse_);
}",327.0,338.0,1.0,1.0,12.0,7,5,25,13,0,0,1,1,0,0,,0,0,4,2,2,void
4506,239851,CreatePerContextProperties,1,node.url.BindingData.CreatePerContextProperties,"void node.url.BindingData.CreatePerContextProperties (Local<Object>,Local<Value>,Local<Context>,void*)",node_url.cc,"void BindingData::CreatePerContextProperties(Local<Object> target,
                                             Local<Value> unused,
                                             Local<Context> context,
                                             void* priv) {
  Realm* realm = Realm::GetCurrent(context);
  realm->AddBindingData<BindingData>(context, target);
}",340.0,346.0,1.0,1.0,7.0,7,7,7,5,0,0,1,1,0,0,,0,0,8,4,4,void
4507,239877,RegisterExternalReferences,1,node.url.BindingData.RegisterExternalReferences,void node.url.BindingData.RegisterExternalReferences (ExternalReferenceRegistry*),node_url.cc,"void BindingData::RegisterExternalReferences(
    ExternalReferenceRegistry* registry) {
  registry->Register(DomainToASCII);
  registry->Register(DomainToUnicode);
  registry->Register(Format);
  registry->Register(Parse);
  registry->Register(Update);
  registry->Register(CanParse);
  registry->Register(FastCanParse);
  registry->Register(fast_can_parse_.GetTypeInfo());
}",348.0,358.0,1.0,1.0,11.0,9,2,16,9,0,0,1,1,0,0,,0,0,2,1,1,void
4508,239925,FromFilePath,1,node.url.FromFilePath,string node.url.FromFilePath (ANY),node_url.cc,"std::string FromFilePath(const std::string_view file_path) {
  std::string escaped_file_path;
  for (size_t i = 0; i < file_path.length(); ++i) {
    escaped_file_path += file_path[i];
    if (file_path[i] == '%') escaped_file_path += ""25"";
  }
  return ada::href_from_file(escaped_file_path);
}",360.0,367.0,1.0,1.0,8.0,9,6,11,4,2,0,3,4,0,0,,0,0,2,1,1,string
4509,240013,GetConstructorName,1,node.util.GetConstructorName,void node.util.GetConstructorName (FunctionCallbackInfo<Value>),node_util.cc,"static void GetConstructorName(
    const FunctionCallbackInfo<Value>& args) {
  CHECK(args[0]->IsObject());

  Local<Object> object = args[0].As<Object>();
  Local<String> name = object->GetConstructorName();

  args.GetReturnValue().Set(name);
}",76.0,84.0,1.0,1.0,9.0,13,6,11,6,0,0,1,1,0,0,,0,0,2,1,1,void
4510,240055,GetExternalValue,1,node.util.GetExternalValue,void node.util.GetExternalValue (FunctionCallbackInfo<Value>),node_util.cc,"static void GetExternalValue(
    const FunctionCallbackInfo<Value>& args) {
  CHECK(args[0]->IsExternal());
  Isolate* isolate = args.GetIsolate();
  Local<External> external = args[0].As<External>();

  void* ptr = external->Value();
  uint64_t value = reinterpret_cast<uint64_t>(ptr);
  Local<BigInt> ret = BigInt::NewFromUnsigned(isolate, value);
  args.GetReturnValue().Set(ret);
}",86.0,96.0,1.0,1.0,11.0,19,7,19,9,0,0,1,1,0,0,,0,0,2,1,1,void
4511,240119,GetPromiseDetails,1,node.util.GetPromiseDetails,void node.util.GetPromiseDetails (FunctionCallbackInfo<Value>),node_util.cc,"static void GetPromiseDetails(const FunctionCallbackInfo<Value>& args) {
  // Return undefined if it's not a Promise.
  if (!args[0]->IsPromise())
    return;

  auto isolate = args.GetIsolate();

  Local<Promise> promise = args[0].As<Promise>();

  int state = promise->State();
  Local<Value> values[2] = { Integer::New(isolate, state) };
  size_t number_of_values = 1;
  if (state != Promise::PromiseState::kPending)
    values[number_of_values++] = promise->Result();
  Local<Array> ret = Array::New(isolate, values, number_of_values);
  args.GetReturnValue().Set(ret);
}",98.0,114.0,1.0,1.0,17.0,30,9,28,12,0,0,3,3,0,0,,0,0,2,1,1,void
4512,240211,GetProxyDetails,1,node.util.GetProxyDetails,void node.util.GetProxyDetails (FunctionCallbackInfo<Value>),node_util.cc,"static void GetProxyDetails(const FunctionCallbackInfo<Value>& args) {
  // Return undefined if it's not a proxy.
  if (!args[0]->IsProxy())
    return;

  Local<Proxy> proxy = args[0].As<Proxy>();

  // TODO(BridgeAR): Remove the length check as soon as we prohibit access to
  // the util binding layer. It's accessed in the wild and `esm` would break in
  // case the check is removed.
  if (args.Length() == 1 || args[1]->IsTrue()) {
    Local<Value> ret[] = {
      proxy->GetTarget(),
      proxy->GetHandler()
    };

    args.GetReturnValue().Set(
        Array::New(args.GetIsolate(), ret, arraysize(ret)));
  } else {
    Local<Value> ret = proxy->GetTarget();

    args.GetReturnValue().Set(ret);
  }
}",116.0,139.0,1.0,1.0,24.0,21,10,15,6,0,0,3,3,0,0,,0,0,2,1,1,void
4513,240303,IsArrayBufferDetached,1,node.util.IsArrayBufferDetached,void node.util.IsArrayBufferDetached (FunctionCallbackInfo<Value>),node_util.cc,"static void IsArrayBufferDetached(const FunctionCallbackInfo<Value>& args) {
  if (args[0]->IsArrayBuffer()) {
    auto buffer = args[0].As<v8::ArrayBuffer>();
    args.GetReturnValue().Set(buffer->WasDetached());
    return;
  }
  args.GetReturnValue().Set(false);
}",141.0,148.0,1.0,1.0,8.0,10,4,6,2,0,0,2,2,0,0,,0,0,2,1,1,void
4514,240345,PreviewEntries,1,node.util.PreviewEntries,void node.util.PreviewEntries (FunctionCallbackInfo<Value>),node_util.cc,"static void PreviewEntries(const FunctionCallbackInfo<Value>& args) {
  if (!args[0]->IsObject())
    return;

  Environment* env = Environment::GetCurrent(args);
  bool is_key_value;
  Local<Array> entries;
  if (!args[0].As<Object>()->PreviewEntries(&is_key_value).ToLocal(&entries))
    return;
  // Fast path for WeakMap and WeakSet.
  if (args.Length() == 1)
    return args.GetReturnValue().Set(entries);

  Local<Value> ret[] = {
    entries,
    Boolean::New(env->isolate(), is_key_value)
  };
  return args.GetReturnValue().Set(
      Array::New(env->isolate(), ret, arraysize(ret)));
}",150.0,169.0,1.0,1.0,20.0,26,10,23,9,0,0,4,4,0,0,,0,0,2,1,1,void
4515,240444,Sleep,1,node.util.Sleep,void node.util.Sleep (FunctionCallbackInfo<Value>),node_util.cc,"static void Sleep(const FunctionCallbackInfo<Value>& args) {
  CHECK(args[0]->IsUint32());
  uint32_t msec = args[0].As<Uint32>()->Value();
  uv_sleep(msec);
}",171.0,175.0,1.0,1.0,5.0,6,4,4,2,0,0,1,1,0,0,,0,0,2,1,1,void
4516,240470,ArrayBufferViewHasBuffer,1,node.util.ArrayBufferViewHasBuffer,void node.util.ArrayBufferViewHasBuffer (FunctionCallbackInfo<Value>),node_util.cc,"void ArrayBufferViewHasBuffer(const FunctionCallbackInfo<Value>& args) {
  CHECK(args[0]->IsArrayBufferView());
  args.GetReturnValue().Set(args[0].As<ArrayBufferView>()->HasBuffer());
}",177.0,180.0,1.0,1.0,4.0,7,3,3,1,0,0,1,1,0,0,,0,0,2,1,1,void
4517,240498,WeakReference,1,node.util.WeakReference.WeakReference,"ANY node.util.WeakReference.WeakReference (Realm*,Local<Object>,Local<Object>)",node_util.cc,"WeakReference::WeakReference(Realm* realm,
                             Local<Object> object,
                             Local<Object> target,
                             uint64_t reference_count)
    : SnapshotableObject(realm, object, type_int),
      reference_count_(reference_count) {
  MakeWeak();
  if (!target.IsEmpty()) {
    target_.Reset(realm->isolate(), target);
    if (reference_count_ == 0) {
      target_.SetWeak();
    }
  }
}",187.0,200.0,1.0,1.0,14.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,ANY
4518,240539,PrepareForSerialization,1,node.util.WeakReference.PrepareForSerialization,"bool node.util.WeakReference.PrepareForSerialization (Local<Context>,ANY*)",node_util.cc,"bool WeakReference::PrepareForSerialization(Local<Context> context,
                                            v8::SnapshotCreator* creator) {
  if (target_.IsEmpty()) {
    target_index_ = 0;
    return true;
  }

  // Users can still hold strong references to target in addition to the
  // reference that we manage here, and they could expect that the referenced
  // object remains the same as long as that external strong reference
  // is alive. Since we have no way to know if there is any other reference
  // keeping the target alive, the best we can do to maintain consistency is to
  // simply save a reference to the target in the snapshot (effectively making
  // it strong) during serialization, and restore it during deserialization.
  // If there's no known counted reference from our side, we'll make the
  // reference here weak upon deserialization so that it can be GC'ed if users
  // do not hold additional references to it.
  Local<Object> target = target_.Get(context->Get...",202.0,224.0,1.0,1.0,23.0,10,5,13,7,0,0,2,2,0,0,,0,0,4,2,2,bool
4519,240587,Serialize,1,node.util.WeakReference.Serialize,InternalFieldInfoBase node.util.WeakReference.Serialize (int),node_util.cc,"InternalFieldInfoBase* WeakReference::Serialize(int index) {
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  InternalFieldInfo* info =
      InternalFieldInfoBase::New<InternalFieldInfo>(type());
  info->target = target_index_;
  info->reference_count = reference_count_;
  return info;
}",226.0,233.0,1.0,1.0,8.0,9,5,10,7,0,0,1,1,0,0,,0,0,2,1,1,InternalFieldInfoBase
4520,240619,Deserialize,1,node.util.WeakReference.Deserialize,"void node.util.WeakReference.Deserialize (Local<Context>,Local<Object>,int,InternalFieldInfoBase*)",node_util.cc,"void WeakReference::Deserialize(Local<Context> context,
                                Local<Object> holder,
                                int index,
                                InternalFieldInfoBase* info) {
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  HandleScope scope(context->GetIsolate());

  InternalFieldInfo* weak_info = reinterpret_cast<InternalFieldInfo*>(info);
  Local<Object> target;
  if (weak_info->target != 0) {
    target = context->GetDataFromSnapshotOnce<Object>(weak_info->target)
                 .ToLocalChecked();
  }
  new WeakReference(
      Realm::GetCurrent(context), holder, target, weak_info->reference_count);
}",235.0,250.0,1.0,1.0,16.0,17,8,19,11,0,0,2,2,0,0,,0,0,8,4,4,void
4521,240682,New,1,node.util.WeakReference.New,void node.util.WeakReference.New (FunctionCallbackInfo<Value>),node_util.cc,"void WeakReference::New(const FunctionCallbackInfo<Value>& args) {
  Realm* realm = Realm::GetCurrent(args);
  CHECK(args.IsConstructCall());
  CHECK(args[0]->IsObject());
  new WeakReference(realm, args.This(), args[0].As<Object>());
}",252.0,257.0,1.0,1.0,6.0,9,5,9,4,0,0,1,1,0,0,,0,0,2,1,1,void
4522,240720,Get,1,node.util.WeakReference.Get,void node.util.WeakReference.Get (FunctionCallbackInfo<Value>),node_util.cc,"void WeakReference::Get(const FunctionCallbackInfo<Value>& args) {
  WeakReference* weak_ref = Unwrap<WeakReference>(args.Holder());
  Isolate* isolate = args.GetIsolate();
  if (!weak_ref->target_.IsEmpty())
    args.GetReturnValue().Set(weak_ref->target_.Get(isolate));
}",259.0,264.0,1.0,1.0,6.0,13,6,10,5,0,0,2,2,0,0,,0,0,2,1,1,void
4523,240766,IncRef,1,node.util.WeakReference.IncRef,void node.util.WeakReference.IncRef (FunctionCallbackInfo<Value>),node_util.cc,"void WeakReference::IncRef(const FunctionCallbackInfo<Value>& args) {
  WeakReference* weak_ref = Unwrap<WeakReference>(args.Holder());
  weak_ref->reference_count_++;
  if (weak_ref->target_.IsEmpty()) return;
  if (weak_ref->reference_count_ == 1) weak_ref->target_.ClearWeak();
  args.GetReturnValue().Set(
      v8::Number::New(args.GetIsolate(), weak_ref->reference_count_));
}",266.0,273.0,1.0,1.0,8.0,18,7,13,6,0,0,3,3,0,0,,0,0,2,1,1,void
4524,240828,DecRef,1,node.util.WeakReference.DecRef,void node.util.WeakReference.DecRef (FunctionCallbackInfo<Value>),node_util.cc,"void WeakReference::DecRef(const FunctionCallbackInfo<Value>& args) {
  WeakReference* weak_ref = Unwrap<WeakReference>(args.Holder());
  CHECK_GE(weak_ref->reference_count_, 1);
  weak_ref->reference_count_--;
  if (weak_ref->target_.IsEmpty()) return;
  if (weak_ref->reference_count_ == 0) weak_ref->target_.SetWeak();
  args.GetReturnValue().Set(
      v8::Number::New(args.GetIsolate(), weak_ref->reference_count_));
}",275.0,283.0,1.0,1.0,9.0,19,7,14,6,0,0,3,3,0,0,,0,0,2,1,1,void
4525,240895,GuessHandleType,1,node.util.GuessHandleType,void node.util.GuessHandleType (FunctionCallbackInfo<Value>),node_util.cc,"static void GuessHandleType(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  int fd;
  if (!args[0]->Int32Value(env->context()).To(&fd)) return;
  CHECK_GE(fd, 0);

  uv_handle_type t = uv_guess_handle(fd);
  const char* type = nullptr;

  switch (t) {
    case UV_TCP:
      type = ""TCP"";
      break;
    case UV_TTY:
      type = ""TTY"";
      break;
    case UV_UDP:
      type = ""UDP"";
      break;
    case UV_FILE:
      type = ""FILE"";
      break;
    case UV_NAMED_PIPE:
      type = ""PIPE"";
      break;
    case UV_UNKNOWN_HANDLE:
      type = ""UNKNOWN"";
      break;
    default:
      ABORT();
  }

  args.GetReturnValue().Set(OneByteString(env->isolate(), type));
}",285.0,318.0,1.0,1.0,34.0,19,6,26,12,0,0,9,3,0,0,,0,0,2,1,1,void
4526,240994,ToUSVString,1,node.util.ToUSVString,void node.util.ToUSVString (FunctionCallbackInfo<Value>),node_util.cc,"static void ToUSVString(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  CHECK_GE(args.Length(), 2);
  CHECK(args[0]->IsString());
  CHECK(args[1]->IsNumber());

  TwoByteValue value(env->isolate(), args[0]);

  int64_t start = args[1]->IntegerValue(env->context()).FromJust();
  CHECK_GE(start, 0);

  for (size_t i = start; i < value.length(); i++) {
    char16_t c = value[i];
    if (!IsUnicodeSurrogate(c)) {
      continue;
    } else if (IsUnicodeSurrogateTrail(c) || i == value.length() - 1) {
      value[i] = kUnicodeReplacementCharacter;
    } else {
      char16_t d = value[i + 1];
      if (IsUnicodeTrail(d)) {
        i++;
      } else {
        value[i] = kUnicodeReplacementCharacter;
      }
    }
  }

  args.GetReturnValue().Set(
      String::NewFromTwoByte(env->isolate(),
                             *value,
                             v8::NewStringType::kNormal,
                             value.length()).ToLocalChecked...",320.0,352.0,1.0,1.0,33.0,29,7,27,10,0,0,4,4,0,0,,0,0,2,1,1,void
4527,241154,RegisterExternalReferences,1,node.util.RegisterExternalReferences,void node.util.RegisterExternalReferences (ExternalReferenceRegistry*),node_util.cc,"void RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  registry->Register(GetPromiseDetails);
  registry->Register(GetProxyDetails);
  registry->Register(IsArrayBufferDetached);
  registry->Register(PreviewEntries);
  registry->Register(GetOwnNonIndexProperties);
  registry->Register(GetConstructorName);
  registry->Register(GetExternalValue);
  registry->Register(Sleep);
  registry->Register(ArrayBufferViewHasBuffer);
  registry->Register(WeakReference::New);
  registry->Register(WeakReference::Get);
  registry->Register(WeakReference::IncRef);
  registry->Register(WeakReference::DecRef);
  registry->Register(GuessHandleType);
  registry->Register(ToUSVString);
}",354.0,370.0,1.0,1.0,17.0,19,2,20,3,0,0,1,1,0,0,,0,0,2,1,1,void
4528,241242,Initialize,1,node.util.Initialize,"void node.util.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)",node_util.cc,"void Initialize(Local<Object> target,
                Local<Value> unused,
                Local<Context> context,
                void* priv) {
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  {
    Local<ObjectTemplate> tmpl = ObjectTemplate::New(isolate);
#define V(PropertyName, _)                                                     \
  tmpl->Set(FIXED_ONE_BYTE_STRING(env->isolate(), #PropertyName),              \
            env->PropertyName());

    PER_ISOLATE_PRIVATE_SYMBOL_PROPERTIES(V)
#undef V

    target
        ->Set(context,
              FIXED_ONE_BYTE_STRING(isolate, ""privateSymbols""),
              tmpl->NewInstance(context).ToLocalChecked())
        .Check();
  }

  {
    Local<Object> constants = Object::New(isolate);
#define V(name)                                                                \
  constants                                                                    \
      ->Set(context,                      ...",372.0,475.0,1.0,4.0,104.0,91,5,152,28,0,0,1,1,0,0,,0,0,8,4,4,void
4529,241814,BindingData,1,node.v8_utils.BindingData.BindingData,"ANY node.v8_utils.BindingData.BindingData (Realm*,Local<Object>,InternalFieldInfo*)",node_v8.cc,"BindingData::BindingData(Realm* realm,
                         Local<Object> obj,
                         InternalFieldInfo* info)
    : SnapshotableObject(realm, obj, type_int),
      heap_statistics_buffer(realm->isolate(),
                             kHeapStatisticsPropertiesCount,
                             MAYBE_FIELD_PTR(info, heap_statistics_buffer)),
      heap_space_statistics_buffer(
          realm->isolate(),
          kHeapSpaceStatisticsPropertiesCount,
          MAYBE_FIELD_PTR(info, heap_space_statistics_buffer)),
      heap_code_statistics_buffer(
          realm->isolate(),
          kHeapCodeStatisticsPropertiesCount,
          MAYBE_FIELD_PTR(info, heap_code_statistics_buffer)) {
  Local<Context> context = realm->context();
  if (info == nullptr) {
    obj->Set(context,
             FIXED_ONE_BYTE_STRING(realm->isolate(), ""heapStatisticsBuffer""),
             heap_statistics_buffer.GetJSArray())
        .Check();
    obj->Set(
           context,
           ...",95.0,134.0,1.0,1.0,40.0,20,6,20,9,0,0,2,2,0,0,,0,0,6,3,3,ANY
4530,241928,PrepareForSerialization,1,node.v8_utils.BindingData.PrepareForSerialization,"bool node.v8_utils.BindingData.PrepareForSerialization (Local<Context>,ANY*)",node_v8.cc,"bool BindingData::PrepareForSerialization(Local<Context> context,
                                          v8::SnapshotCreator* creator) {
  DCHECK_NULL(internal_field_info_);
  internal_field_info_ = InternalFieldInfoBase::New<InternalFieldInfo>(type());
  internal_field_info_->heap_statistics_buffer =
      heap_statistics_buffer.Serialize(context, creator);
  internal_field_info_->heap_space_statistics_buffer =
      heap_space_statistics_buffer.Serialize(context, creator);
  internal_field_info_->heap_code_statistics_buffer =
      heap_code_statistics_buffer.Serialize(context, creator);
  // Return true because we need to maintain the reference to the binding from
  // JS land.
  return true;
}",136.0,149.0,1.0,1.0,14.0,13,5,15,8,0,0,1,1,0,0,,0,0,4,2,2,bool
4531,241976,Deserialize,1,node.v8_utils.BindingData.Deserialize,"void node.v8_utils.BindingData.Deserialize (Local<Context>,Local<Object>,int,InternalFieldInfoBase*)",node_v8.cc,"void BindingData::Deserialize(Local<Context> context,
                              Local<Object> holder,
                              int index,
                              InternalFieldInfoBase* info) {
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  HandleScope scope(context->GetIsolate());
  Realm* realm = Realm::GetCurrent(context);
  // Recreate the buffer in the constructor.
  InternalFieldInfo* casted_info = static_cast<InternalFieldInfo*>(info);
  BindingData* binding =
      realm->AddBindingData<BindingData>(context, holder, casted_info);
  CHECK_NOT_NULL(binding);
}",151.0,163.0,1.0,1.0,13.0,12,8,15,10,0,0,1,1,0,0,,0,0,8,4,4,void
4532,242025,Serialize,1,node.v8_utils.BindingData.Serialize,InternalFieldInfoBase node.v8_utils.BindingData.Serialize (int),node_v8.cc,"InternalFieldInfoBase* BindingData::Serialize(int index) {
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  InternalFieldInfo* info = internal_field_info_;
  internal_field_info_ = nullptr;
  return info;
}",165.0,170.0,1.0,1.0,6.0,3,2,6,4,0,0,1,1,0,0,,0,0,2,1,1,InternalFieldInfoBase
4533,242044,MemoryInfo,1,node.v8_utils.BindingData.MemoryInfo,void node.v8_utils.BindingData.MemoryInfo (MemoryTracker*),node_v8.cc,"void BindingData::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackField(""heap_statistics_buffer"", heap_statistics_buffer);
  tracker->TrackField(""heap_space_statistics_buffer"",
                      heap_space_statistics_buffer);
  tracker->TrackField(""heap_code_statistics_buffer"",
                      heap_code_statistics_buffer);
}",172.0,178.0,1.0,1.0,7.0,3,1,6,4,0,0,1,1,0,0,,0,0,2,1,1,void
4534,242067,CachedDataVersionTag,1,node.v8_utils.CachedDataVersionTag,void node.v8_utils.CachedDataVersionTag (FunctionCallbackInfo<Value>),node_v8.cc,"void CachedDataVersionTag(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Local<Integer> result =
      Integer::NewFromUnsigned(env->isolate(),
                               ScriptCompiler::CachedDataVersionTag());
  args.GetReturnValue().Set(result);
}",180.0,186.0,1.0,1.0,7.0,10,5,11,7,0,0,1,1,0,0,,0,0,2,1,1,void
4535,242106,SetHeapSnapshotNearHeapLimit,1,node.v8_utils.SetHeapSnapshotNearHeapLimit,void node.v8_utils.SetHeapSnapshotNearHeapLimit (FunctionCallbackInfo<Value>),node_v8.cc,"void SetHeapSnapshotNearHeapLimit(const FunctionCallbackInfo<Value>& args) {
  CHECK(args[0]->IsUint32());
  Environment* env = Environment::GetCurrent(args);
  uint32_t limit = args[0].As<v8::Uint32>()->Value();
  CHECK_GT(limit, 0);
  env->AddHeapSnapshotNearHeapLimitCallback();
  env->set_heap_snapshot_near_heap_limit(limit);
}",188.0,195.0,1.0,1.0,8.0,10,4,10,4,0,0,1,1,0,0,,0,0,2,1,1,void
4536,242150,UpdateHeapStatisticsBuffer,1,node.v8_utils.UpdateHeapStatisticsBuffer,void node.v8_utils.UpdateHeapStatisticsBuffer (FunctionCallbackInfo<Value>),node_v8.cc,"void UpdateHeapStatisticsBuffer(const FunctionCallbackInfo<Value>& args) {
  BindingData* data = Realm::GetBindingData<BindingData>(args);
  HeapStatistics s;
  args.GetIsolate()->GetHeapStatistics(&s);
  AliasedFloat64Array& buffer = data->heap_statistics_buffer;
#define V(index, name, _) buffer[index] = static_cast<double>(s.name());
  HEAP_STATISTICS_PROPERTIES(V)
#undef V
}",197.0,205.0,1.0,2.0,9.0,65,8,36,6,0,0,1,1,0,0,,0,0,2,1,1,void
4537,242323,UpdateHeapSpaceStatisticsBuffer,1,node.v8_utils.UpdateHeapSpaceStatisticsBuffer,void node.v8_utils.UpdateHeapSpaceStatisticsBuffer (FunctionCallbackInfo<Value>),node_v8.cc,"void UpdateHeapSpaceStatisticsBuffer(const FunctionCallbackInfo<Value>& args) {
  BindingData* data = Realm::GetBindingData<BindingData>(args);
  HeapSpaceStatistics s;
  Isolate* const isolate = args.GetIsolate();
  CHECK(args[0]->IsUint32());
  size_t space_index = static_cast<size_t>(args[0].As<v8::Uint32>()->Value());
  isolate->GetHeapSpaceStatistics(&s, space_index);

  AliasedFloat64Array& buffer = data->heap_space_statistics_buffer;

#define V(index, name, _) buffer[index] = static_cast<double>(s.name());
  HEAP_SPACE_STATISTICS_PROPERTIES(V)
#undef V
}",208.0,221.0,1.0,2.0,14.0,33,8,22,8,0,0,1,1,0,0,,0,0,2,1,1,void
4538,242422,UpdateHeapCodeStatisticsBuffer,1,node.v8_utils.UpdateHeapCodeStatisticsBuffer,void node.v8_utils.UpdateHeapCodeStatisticsBuffer (FunctionCallbackInfo<Value>),node_v8.cc,"void UpdateHeapCodeStatisticsBuffer(const FunctionCallbackInfo<Value>& args) {
  BindingData* data = Realm::GetBindingData<BindingData>(args);
  HeapCodeStatistics s;
  args.GetIsolate()->GetHeapCodeAndMetadataStatistics(&s);
  AliasedFloat64Array& buffer = data->heap_code_statistics_buffer;

#define V(index, name, _) buffer[index] = static_cast<double>(s.name());
  HEAP_CODE_STATISTICS_PROPERTIES(V)
#undef V
}",223.0,232.0,1.0,2.0,10.0,25,8,16,6,0,0,1,1,0,0,,0,0,2,1,1,void
4539,242495,SetFlagsFromString,1,node.v8_utils.SetFlagsFromString,void node.v8_utils.SetFlagsFromString (FunctionCallbackInfo<Value>),node_v8.cc,"void SetFlagsFromString(const FunctionCallbackInfo<Value>& args) {
  CHECK(args[0]->IsString());
  String::Utf8Value flags(args.GetIsolate(), args[0]);
  V8::SetFlagsFromString(*flags, static_cast<size_t>(flags.length()));
}",235.0,239.0,1.0,1.0,5.0,8,5,6,3,0,0,1,1,0,0,,0,0,2,1,1,void
4540,242528,GetGCTypeName,1,node.v8_utils.GetGCTypeName,const char* node.v8_utils.GetGCTypeName (ANY),node_v8.cc,"static const char* GetGCTypeName(v8::GCType gc_type) {
  switch (gc_type) {
    case v8::GCType::kGCTypeScavenge:
      return ""Scavenge"";
    case v8::GCType::kGCTypeMarkSweepCompact:
      return ""MarkSweepCompact"";
    case v8::GCType::kGCTypeIncrementalMarking:
      return ""IncrementalMarking"";
    case v8::GCType::kGCTypeProcessWeakCallbacks:
      return ""ProcessWeakCallbacks"";
    default:
      return ""Unknown"";
  }
}",241.0,254.0,1.0,1.0,14.0,8,1,9,3,0,0,2,2,0,0,,0,0,2,1,1,const char*
4541,242571,SetHeapStatistics,1,node.v8_utils.SetHeapStatistics,"void node.v8_utils.SetHeapStatistics (JSONWriter*,Isolate*)",node_v8.cc,"static void SetHeapStatistics(JSONWriter* writer, Isolate* isolate) {
  HeapStatistics heap_statistics;
  isolate->GetHeapStatistics(&heap_statistics);
  writer->json_objectstart(""heapStatistics"");
  writer->json_keyvalue(""totalHeapSize"", heap_statistics.total_heap_size());
  writer->json_keyvalue(""totalHeapSizeExecutable"",
                        heap_statistics.total_heap_size_executable());
  writer->json_keyvalue(""totalPhysicalSize"",
                        heap_statistics.total_physical_size());
  writer->json_keyvalue(""totalAvailableSize"",
                        heap_statistics.total_available_size());
  writer->json_keyvalue(""totalGlobalHandlesSize"",
                        heap_statistics.total_global_handles_size());
  writer->json_keyvalue(""usedGlobalHandlesSize"",
                        heap_statistics.used_global_handles_size());
  writer->json_keyvalue(""usedHeapSize"", heap_statistics.used_heap_size());
  writer->json_keyvalue(""heapSizeLimit"", heap_statistics.heap_size_...",256.0,296.0,1.0,1.0,41.0,46,5,48,6,0,0,2,2,0,0,,0,0,4,2,2,void
4542,242781,BeforeGCCallback,1,node.v8_utils.BeforeGCCallback,"void node.v8_utils.BeforeGCCallback (Isolate*,ANY,ANY,void*)",node_v8.cc,"static void BeforeGCCallback(Isolate* isolate,
                             v8::GCType gc_type,
                             v8::GCCallbackFlags flags,
                             void* data) {
  GCProfiler* profiler = static_cast<GCProfiler*>(data);
  if (profiler->current_gc_type != 0) {
    return;
  }
  JSONWriter* writer = profiler->writer();
  writer->json_start();
  writer->json_keyvalue(""gcType"", GetGCTypeName(gc_type));
  writer->json_objectstart(""beforeGC"");
  SetHeapStatistics(writer, isolate);
  writer->json_objectend();
  profiler->current_gc_type = gc_type;
  profiler->start_time = uv_hrtime();
}",298.0,314.0,1.0,1.0,17.0,14,4,15,5,0,0,2,2,0,0,,0,0,8,4,4,void
4543,242843,AfterGCCallback,1,node.v8_utils.AfterGCCallback,"void node.v8_utils.AfterGCCallback (Isolate*,ANY,ANY,void*)",node_v8.cc,"static void AfterGCCallback(Isolate* isolate,
                            v8::GCType gc_type,
                            v8::GCCallbackFlags flags,
                            void* data) {
  GCProfiler* profiler = static_cast<GCProfiler*>(data);
  if (profiler->current_gc_type != gc_type) {
    return;
  }
  JSONWriter* writer = profiler->writer();
  profiler->current_gc_type = 0;
  writer->json_keyvalue(""cost"", (uv_hrtime() - profiler->start_time) / 1e3);
  profiler->start_time = 0;
  writer->json_objectstart(""afterGC"");
  SetHeapStatistics(writer, isolate);
  writer->json_objectend();
  writer->json_end();
}",316.0,332.0,1.0,1.0,17.0,17,6,15,5,0,0,2,2,0,0,,0,0,8,4,4,void
4544,242910,GCProfiler,1,node.v8_utils.GCProfiler.GCProfiler,"ANY node.v8_utils.GCProfiler.GCProfiler (Environment*,Local<Object>)",node_v8.cc,"GCProfiler::GCProfiler(Environment* env, Local<Object> object)
    : BaseObject(env, object),
      start_time(0),
      current_gc_type(0),
      state(GCProfilerState::kInitialized),
      writer_(out_stream_, false) {
  MakeWeak();
}",334.0,341.0,1.0,1.0,8.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,ANY
4545,242917,~GCProfiler,1,node.v8_utils.GCProfiler.~GCProfiler,ANY node.v8_utils.GCProfiler.~GCProfiler (),node_v8.cc,"GCProfiler::~GCProfiler() {
  if (state != GCProfiler::GCProfilerState::kInitialized) {
    env()->isolate()->RemoveGCPrologueCallback(BeforeGCCallback, this);
    env()->isolate()->RemoveGCEpilogueCallback(AfterGCCallback, this);
  }
}",348.0,353.0,1.0,1.0,6.0,7,3,5,5,0,0,2,2,0,0,,0,0,0,0,0,ANY
4546,242948,writer,1,node.v8_utils.GCProfiler.writer,JSONWriter node.v8_utils.GCProfiler.writer (),node_v8.cc,"JSONWriter* GCProfiler::writer() {
  return &writer_;
}",355.0,357.0,1.0,1.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,JSONWriter
4547,242955,out_stream,1,node.v8_utils.GCProfiler.out_stream,ostringstream node.v8_utils.GCProfiler.out_stream (),node_v8.cc,"std::ostringstream* GCProfiler::out_stream() {
  return &out_stream_;
}",359.0,361.0,1.0,1.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,ostringstream
4548,242962,New,1,node.v8_utils.GCProfiler.New,void node.v8_utils.GCProfiler.New (FunctionCallbackInfo<Value>),node_v8.cc,"void GCProfiler::New(const FunctionCallbackInfo<Value>& args) {
  CHECK(args.IsConstructCall());
  Environment* env = Environment::GetCurrent(args);
  new GCProfiler(env, args.This());
}",363.0,367.0,1.0,1.0,5.0,5,3,7,4,0,0,1,1,0,0,,0,0,2,1,1,void
4549,242987,Start,1,node.v8_utils.GCProfiler.Start,void node.v8_utils.GCProfiler.Start (FunctionCallbackInfo<Value>),node_v8.cc,"void GCProfiler::Start(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  GCProfiler* profiler;
  ASSIGN_OR_RETURN_UNWRAP(&profiler, args.Holder());
  if (profiler->state != GCProfiler::GCProfilerState::kInitialized) {
    return;
  }
  profiler->writer()->json_start();
  profiler->writer()->json_keyvalue(""version"", 1);

  uv_timeval64_t ts;
  if (uv_gettimeofday(&ts) == 0) {
    profiler->writer()->json_keyvalue(""startTime"",
                                      ts.tv_sec * 1000 + ts.tv_usec / 1000);
  } else {
    profiler->writer()->json_keyvalue(""startTime"", 0);
  }
  profiler->writer()->json_arraystart(""statistics"");
  env->isolate()->AddGCPrologueCallback(BeforeGCCallback,
                                        static_cast<void*>(profiler));
  env->isolate()->AddGCEpilogueCallback(AfterGCCallback,
                                        static_cast<void*>(profiler));
  profiler->state = GCProfiler::GCProfilerState::kStarted;
}",369.0,392.0,1.0,1.0,24.0,33,10,24,9,0,0,3,3,0,0,,0,0,2,1,1,void
4550,243113,Stop,1,node.v8_utils.GCProfiler.Stop,void node.v8_utils.GCProfiler.Stop (ANY),node_v8.cc,"void GCProfiler::Stop(const FunctionCallbackInfo<v8::Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  GCProfiler* profiler;
  ASSIGN_OR_RETURN_UNWRAP(&profiler, args.Holder());
  if (profiler->state != GCProfiler::GCProfilerState::kStarted) {
    return;
  }
  profiler->writer()->json_arrayend();
  uv_timeval64_t ts;
  if (uv_gettimeofday(&ts) == 0) {
    profiler->writer()->json_keyvalue(""endTime"",
                                      ts.tv_sec * 1000 + ts.tv_usec / 1000);
  } else {
    profiler->writer()->json_keyvalue(""endTime"", 0);
  }
  profiler->writer()->json_end();
  profiler->state = GCProfiler::GCProfilerState::kStopped;
  auto string = profiler->out_stream()->str();
  args.GetReturnValue().Set(String::NewFromUtf8(env->isolate(),
                                                string.data(),
                                                v8::NewStringType::kNormal,
                                                string.size())
                      ...",394.0,417.0,1.0,1.0,24.0,37,9,26,11,0,0,3,3,0,0,,0,0,2,1,1,void
4551,243248,Initialize,1,node.v8_utils.Initialize,"void node.v8_utils.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)",node_v8.cc,"void Initialize(Local<Object> target,
                Local<Value> unused,
                Local<Context> context,
                void* priv) {
  Realm* realm = Realm::GetCurrent(context);
  Environment* env = realm->env();
  BindingData* const binding_data =
      realm->AddBindingData<BindingData>(context, target);
  if (binding_data == nullptr) return;

  SetMethodNoSideEffect(
      context, target, ""cachedDataVersionTag"", CachedDataVersionTag);
  SetMethodNoSideEffect(context,
                        target,
                        ""setHeapSnapshotNearHeapLimit"",
                        SetHeapSnapshotNearHeapLimit);
  SetMethod(context,
            target,
            ""updateHeapStatisticsBuffer"",
            UpdateHeapStatisticsBuffer);

  SetMethod(context,
            target,
            ""updateHeapCodeStatisticsBuffer"",
            UpdateHeapCodeStatisticsBuffer);

  size_t number_of_heap_spaces = env->isolate()->NumberOfHeapSpaces();

  // Heap space names are extracted ...",419.0,490.0,1.0,2.0,72.0,153,10,170,21,0,0,3,3,0,0,,0,0,8,4,4,void
4552,243963,RegisterExternalReferences,1,node.v8_utils.RegisterExternalReferences,void node.v8_utils.RegisterExternalReferences (ExternalReferenceRegistry*),node_v8.cc,"void RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  registry->Register(CachedDataVersionTag);
  registry->Register(UpdateHeapStatisticsBuffer);
  registry->Register(UpdateHeapCodeStatisticsBuffer);
  registry->Register(UpdateHeapSpaceStatisticsBuffer);
  registry->Register(SetFlagsFromString);
  registry->Register(SetHeapSnapshotNearHeapLimit);
  registry->Register(GCProfiler::New);
  registry->Register(GCProfiler::Start);
  registry->Register(GCProfiler::Stop);
}",492.0,502.0,1.0,1.0,11.0,12,2,12,2,0,0,1,1,0,0,,0,0,2,1,1,void
4553,244098,Debug,1,node.wasi.Debug,"void node.wasi.Debug<Args> (WASI,Args)",node_wasi.cc,"inline void Debug(const WASI& wasi, Args&&... args) {
  Debug(wasi.env(), DebugCategory::WASI, std::forward<Args>(args)...);
}",17.0,19.0,1.0,1.0,3.0,5,3,5,5,0,0,1,1,0,0,,0,0,4,2,2,void
4554,244119,WASIException,1,node.wasi.WASIException,"MaybeLocal<Value> node.wasi.WASIException (Local<Context>,int,char*)",node_wasi.cc,"static MaybeLocal<Value> WASIException(Local<Context> context,
                                       int errorno,
                                       const char* syscall) {
  Isolate* isolate = context->GetIsolate();
  Environment* env = Environment::GetCurrent(context);
  CHECK_NOT_NULL(env);
  const char* err_name = uvwasi_embedder_err_code_to_string(errorno);
  Local<String> js_code = OneByteString(isolate, err_name);
  Local<String> js_syscall = OneByteString(isolate, syscall);
  Local<String> js_msg = js_code;
  js_msg =
      String::Concat(isolate, js_msg, FIXED_ONE_BYTE_STRING(isolate, "", ""));
  js_msg = String::Concat(isolate, js_msg, js_syscall);
  Local<Object> e;
  if (!Exception::Error(js_msg)->ToObject(context).ToLocal(&e))
    return MaybeLocal<Value>();

  if (e->Set(context,
             env->errno_string(),
             Integer::New(isolate, errorno)).IsNothing() ||
      e->Set(context, env->code_string(), js_code).IsNothing() ||
      e->Set(context, env->sys...",48.0,74.0,1.0,1.0,27.0,37,8,54,16,0,0,3,3,0,0,,0,0,6,3,3,MaybeLocal<Value>
4555,244269,WASI,1,node.wasi.WASI.WASI,"ANY node.wasi.WASI.WASI (Environment*,Local<Object>,uvwasi_options_t*)",node_wasi.cc,"WASI::WASI(Environment* env,
           Local<Object> object,
           uvwasi_options_t* options) : BaseObject(env, object) {
  MakeWeak();
  alloc_info_ = MakeAllocator();
  options->allocator = &alloc_info_;
  int err = uvwasi_init(&uvw_, options);
  if (err != UVWASI_ESUCCESS) {
    Local<Value> exception;
    if (!WASIException(env->context(), err, ""uvwasi_init"").ToLocal(&exception))
      return;

    env->isolate()->ThrowException(exception);
  }
}",77.0,91.0,1.0,1.0,15.0,15,8,16,9,0,0,3,4,0,0,,0,0,6,3,3,ANY
4556,244327,~WASI,1,node.wasi.WASI.~WASI,ANY node.wasi.WASI.~WASI (),node_wasi.cc,"WASI::~WASI() {
  uvwasi_destroy(&uvw_);
  CHECK_EQ(current_uvwasi_memory_, 0);
}",94.0,97.0,1.0,1.0,4.0,0,0,1,1,0,0,1,1,0,0,,0,0,0,0,0,ANY
4557,244335,MemoryInfo,1,node.wasi.WASI.MemoryInfo,void node.wasi.WASI.MemoryInfo (MemoryTracker*),node_wasi.cc,"void WASI::MemoryInfo(MemoryTracker* tracker) const {
  tracker->TrackField(""memory"", memory_);
  tracker->TrackFieldWithSize(""uvwasi_memory"", current_uvwasi_memory_);
}",99.0,102.0,1.0,1.0,4.0,2,1,4,3,0,0,1,1,0,0,,0,0,2,1,1,void
4558,244352,CheckAllocatedSize,1,node.wasi.WASI.CheckAllocatedSize,void node.wasi.WASI.CheckAllocatedSize (size_t),node_wasi.cc,"void WASI::CheckAllocatedSize(size_t previous_size) const {
  CHECK_GE(current_uvwasi_memory_, previous_size);
}",104.0,106.0,1.0,1.0,3.0,0,0,2,2,0,0,1,1,0,0,,0,0,2,1,1,void
4559,244360,IncreaseAllocatedSize,1,node.wasi.WASI.IncreaseAllocatedSize,void node.wasi.WASI.IncreaseAllocatedSize (size_t),node_wasi.cc,"void WASI::IncreaseAllocatedSize(size_t size) {
  current_uvwasi_memory_ += size;
}",108.0,110.0,1.0,1.0,3.0,1,1,2,2,0,0,1,1,0,0,,0,0,2,1,1,void
4560,244368,DecreaseAllocatedSize,1,node.wasi.WASI.DecreaseAllocatedSize,void node.wasi.WASI.DecreaseAllocatedSize (size_t),node_wasi.cc,"void WASI::DecreaseAllocatedSize(size_t size) {
  current_uvwasi_memory_ -= size;
}",112.0,114.0,1.0,1.0,3.0,1,1,2,2,0,0,1,1,0,0,,0,0,2,1,1,void
4561,244376,New,1,node.wasi.WASI.New,void node.wasi.WASI.New (FunctionCallbackInfo<Value>),node_wasi.cc,"void WASI::New(const FunctionCallbackInfo<Value>& args) {
  CHECK(args.IsConstructCall());
  CHECK_EQ(args.Length(), 4);
  CHECK(args[0]->IsArray());
  CHECK(args[1]->IsArray());
  CHECK(args[2]->IsArray());
  CHECK(args[3]->IsArray());

  Environment* env = Environment::GetCurrent(args);
  Local<Context> context = env->context();
  Local<Array> argv = args[0].As<Array>();
  const uint32_t argc = argv->Length();
  uvwasi_options_t options;

  uvwasi_options_init(&options);

  Local<Array> stdio = args[3].As<Array>();
  CHECK_EQ(stdio->Length(), 3);
  options.in = stdio->Get(context, 0).ToLocalChecked()->
    Int32Value(context).FromJust();
  options.out = stdio->Get(context, 1).ToLocalChecked()->
    Int32Value(context).FromJust();
  options.err = stdio->Get(context, 2).ToLocalChecked()->
    Int32Value(context).FromJust();

  options.fd_table_size = 3;
  options.argc = argc;
  options.argv =
    const_cast<const char**>(argc == 0 ? nullptr : new char*[argc]);

  for (uint32_t i = 0...",116.0,205.0,1.0,1.0,90.0,174,18,145,27,0,0,9,11,0,0,,0,0,2,1,1,void
4562,244958,SetFunction,1,"node.wasi.WASI.WasiFunction<FT,F,R,Args...>.SetFunction","void node.wasi.WASI.WasiFunction<FT,F,R,Args...>.SetFunction<FT,FT,R,Args> (Environment*,char*,Local<FunctionTemplate>)",node_wasi.cc,"void WASI::WasiFunction<FT, F, R, Args...>::SetFunction(
    Environment* env, const char* name, Local<FunctionTemplate> tmpl) {
  auto c_function = CFunction::Make(FastCallback);
  Local<FunctionTemplate> t =
      FunctionTemplate::New(env->isolate(),
                            SlowCallback,
                            Local<Value>(),
                            Local<Signature>(),
                            sizeof...(Args),
                            v8::ConstructorBehavior::kThrow,
                            v8::SideEffectType::kHasSideEffect,
                            &c_function);
  const v8::NewStringType type = v8::NewStringType::kInternalized;
  Local<String> name_string =
      String::NewFromUtf8(env->isolate(), name, type).ToLocalChecked();
  tmpl->PrototypeTemplate()->Set(name_string, t);
  t->SetClassName(name_string);
}",208.0,225.0,1.0,1.0,18.0,25,7,30,18,0,0,1,1,0,0,,0,0,6,3,3,void
4563,245046,EinvalError,1,node.wasi.anonymous_namespace_1.EinvalError,R node.wasi.anonymous_namespace_1.EinvalError<R> (),node_wasi.cc,inline R EinvalError();,229.0,229.0,10.0,22.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,R
4564,245050,EinvalError,1,node.wasi.anonymous_namespace_2.EinvalError,uint32_t node.wasi.anonymous_namespace_2.EinvalError<> (),node_wasi.cc,"inline uint32_t EinvalError() {
  return UVWASI_EINVAL;
}",232.0,234.0,1.0,1.0,3.0,0,0,1,1,0,0,1,1,0,0,,0,0,0,0,0,uint32_t
4565,245056,EinvalError,1,node.wasi.anonymous_namespace_3.EinvalError,void node.wasi.anonymous_namespace_3.EinvalError<> (),node_wasi.cc,inline void EinvalError() {},237.0,237.0,1.0,28.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
4566,245060,FastCallback,1,"node.wasi.WASI.WasiFunction<FT,F,R,Args...>.FastCallback","R node.wasi.WASI.WasiFunction<FT,F,R,Args...>.FastCallback<FT,FT,R,Args> (Local<Object>,Args,FastApiCallbackOptions)",node_wasi.cc,"R WASI::WasiFunction<FT, F, R, Args...>::FastCallback(
    Local<Object> receiver,
    Args... args,
    // NOLINTNEXTLINE(runtime/references) This is V8 api.
    FastApiCallbackOptions& options) {
  WASI* wasi = reinterpret_cast<WASI*>(BaseObject::FromJSObject(receiver));
  if (UNLIKELY(wasi == nullptr)) return EinvalError<R>();

  if (UNLIKELY(options.wasm_memory == nullptr || wasi->memory_.IsEmpty())) {
    // fallback to slow path which to throw an error about missing memory.
    options.fallback = true;
    return EinvalError<R>();
  }
  uint8_t* memory = nullptr;
  CHECK(LIKELY(options.wasm_memory->getStorageIfAligned(&memory)));

  return F(*wasi,
           {reinterpret_cast<char*>(memory), options.wasm_memory->length()},
           args...);
}",241.0,260.0,1.0,1.0,20.0,20,9,14,6,0,0,3,3,0,0,,0,0,6,3,3,R
4567,245137,CheckType,1,node.wasi.anonymous_namespace_5.CheckType,bool node.wasi.anonymous_namespace_5.CheckType<VT> (Local<Value>),node_wasi.cc,static bool CheckType(Local<Value> v);,264.0,264.0,13.0,37.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,bool
4568,245142,ConvertType,1,node.wasi.anonymous_namespace_6.ConvertType,VT node.wasi.anonymous_namespace_6.ConvertType<VT> (Local<Value>),node_wasi.cc,static VT ConvertType(Local<Value> V);,267.0,267.0,11.0,37.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,VT
4569,245147,CheckType,1,node.wasi.anonymous_namespace_7.CheckType<uint32_t>,bool node.wasi.anonymous_namespace_7.CheckType<uint32_t><> (Local<Value>),node_wasi.cc,"bool CheckType<uint32_t>(Local<Value> value) {
  return value->IsUint32();
}",270.0,272.0,1.0,1.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,bool
4570,245157,ConvertType,1,node.wasi.anonymous_namespace_8.ConvertType,uint32_t node.wasi.anonymous_namespace_8.ConvertType<> (Local<Value>),node_wasi.cc,"uint32_t ConvertType(Local<Value> value) {
  return value.As<Uint32>()->Value();
}",275.0,277.0,1.0,1.0,3.0,2,2,1,1,0,0,1,1,0,0,,0,0,2,1,1,uint32_t
4571,245170,CheckType,1,node.wasi.anonymous_namespace_9.CheckType<uint64_t>,bool node.wasi.anonymous_namespace_9.CheckType<uint64_t><> (Local<Value>),node_wasi.cc,"bool CheckType<uint64_t>(Local<Value> value) {
  return value->IsBigInt();
}",280.0,282.0,1.0,1.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,bool
4572,245180,ConvertType,1,node.wasi.anonymous_namespace_10.ConvertType,uint64_t node.wasi.anonymous_namespace_10.ConvertType<> (Local<Value>),node_wasi.cc,"uint64_t ConvertType(Local<Value> value) {
  Local<BigInt> js_value = value.As<BigInt>();
  bool lossless;
  return js_value->Uint64Value(&lossless);
}",285.0,289.0,1.0,1.0,5.0,6,6,6,5,0,0,1,1,0,0,,0,0,2,1,1,uint64_t
4573,245203,CheckType,1,node.wasi.anonymous_namespace_11.CheckType<int64_t>,bool node.wasi.anonymous_namespace_11.CheckType<int64_t><> (Local<Value>),node_wasi.cc,"bool CheckType<int64_t>(Local<Value> value) {
  return value->IsBigInt();
}",292.0,294.0,1.0,1.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,bool
4574,245213,ConvertType,1,node.wasi.anonymous_namespace_12.ConvertType,int64_t node.wasi.anonymous_namespace_12.ConvertType<> (Local<Value>),node_wasi.cc,"int64_t ConvertType(Local<Value> value) {
  Local<BigInt> js_value = value.As<BigInt>();
  bool lossless;
  return js_value->Int64Value(&lossless);
}",297.0,301.0,1.0,1.0,5.0,6,6,6,5,0,0,1,1,0,0,,0,0,2,1,1,int64_t
4575,245236,CheckTypes,1,node.wasi.anonymous_namespace_13.CheckTypes,"bool node.wasi.anonymous_namespace_13.CheckTypes<T> (FunctionCallbackInfo<Value>,int,T)",node_wasi.cc,"bool CheckTypes(const FunctionCallbackInfo<Value>& info, int i, T) {
  return CheckType<T>(info[i]);
}",304.0,306.0,1.0,1.0,3.0,1,1,2,2,0,0,1,1,0,0,,0,0,6,3,3,bool
4576,245248,CheckTypes,1,node.wasi.anonymous_namespace_14.CheckTypes,"bool node.wasi.anonymous_namespace_14.CheckTypes<T,Ts> (FunctionCallbackInfo<Value>,int,T,Ts)",node_wasi.cc,"bool CheckTypes(const FunctionCallbackInfo<Value>& info,
                int i,
                T arg,
                Ts... args) {
  if (!CheckTypes<T>(info, i, arg)) return false;
  return CheckTypes<Ts...>(info, i + 1, args...);
}",309.0,315.0,1.0,1.0,7.0,2,2,6,4,0,0,2,2,0,0,,0,0,8,4,4,bool
4577,245272,CheckTypes,1,node.wasi.anonymous_namespace_15.CheckTypes,bool node.wasi.anonymous_namespace_15.CheckTypes<Args> (FunctionCallbackInfo<Value>),node_wasi.cc,"bool CheckTypes(const FunctionCallbackInfo<Value>& info) {
  return CheckTypes<Args...>(info, 0, Args()...);
}",318.0,320.0,1.0,1.0,3.0,0,0,1,1,0,0,1,1,0,0,,0,0,2,1,1,bool
4578,245282,CheckTypes,1,node.wasi.anonymous_namespace_16.CheckTypes,bool node.wasi.anonymous_namespace_16.CheckTypes<> (FunctionCallbackInfo<Value>),node_wasi.cc,"bool CheckTypes(const FunctionCallbackInfo<Value>& info) {
  return true;
}",323.0,325.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,bool
4579,245289,CallAndSetReturn,1,node.wasi.anonymous_namespace_17.CallAndSetReturn,"void node.wasi.anonymous_namespace_17.CallAndSetReturn<FT,FT,R,Args,std::size_t...,std::enable_if_t<!std::is_void<R>::value,bool>=true> (ANY,FunctionCallbackInfo<Value>,WASI*,WasmMemory)",node_wasi.cc,"inline void CallAndSetReturn(std::index_sequence<Indices...>,
                             const FunctionCallbackInfo<Value>& args,
                             WASI* wasi,
                             WasmMemory memory) {
  args.GetReturnValue().Set(
      F(*wasi, memory, ConvertType<Args>(args[Indices])...));
}",333.0,339.0,1.0,1.0,7.0,4,3,5,4,0,0,1,1,0,0,,0,0,8,4,4,void
4580,245312,CallAndSetReturn,1,node.wasi.anonymous_namespace_18.CallAndSetReturn,"void node.wasi.anonymous_namespace_18.CallAndSetReturn<FT,FT,R,Args,std::size_t...,std::enable_if_t<std::is_void<R>::value,bool>=true> (ANY,FunctionCallbackInfo<Value>,WASI*,WasmMemory)",node_wasi.cc,"inline void CallAndSetReturn(std::index_sequence<Indices...>,
                             const FunctionCallbackInfo<Value>& args,
                             WASI* wasi,
                             WasmMemory memory) {
  F(*wasi, memory, ConvertType<Args>(args[Indices])...);
}",347.0,352.0,1.0,1.0,6.0,2,2,4,4,0,0,1,1,0,0,,0,0,8,4,4,void
4581,245328,SlowCallback,1,"node.wasi.WASI.WasiFunction<FT,F,R,Args...>.SlowCallback","void node.wasi.WASI.WasiFunction<FT,F,R,Args...>.SlowCallback<FT,FT,R,Args> (FunctionCallbackInfo<Value>)",node_wasi.cc,"void WASI::WasiFunction<FT, F, R, Args...>::SlowCallback(
    const FunctionCallbackInfo<Value>& args) {
  if (args.Length() != sizeof...(Args)) {
    args.GetReturnValue().Set(UVWASI_EINVAL);
    return;
  }
  if (!CheckTypes<Args...>(args)) {
    args.GetReturnValue().Set(UVWASI_EINVAL);
    return;
  }

  WASI* wasi;
  ASSIGN_OR_RETURN_UNWRAP(&wasi, args.This());
  if (wasi->memory_.IsEmpty()) {
    THROW_ERR_WASI_NOT_STARTED(Environment::GetCurrent(args));
    return;
  }

  Local<WasmMemoryObject> memory = PersistentToLocal::Strong(wasi->memory_);
  Local<ArrayBuffer> ab = memory->Buffer();
  size_t mem_size = ab->ByteLength();
  char* mem_data = static_cast<char*>(ab->Data());
  CHECK_NOT_NULL(mem_data);

  CallAndSetReturn<FT, F, R, Args...>(
      std::make_index_sequence<sizeof...(Args)>{},
      args,
      wasi,
      {mem_data, mem_size});
}",357.0,386.0,1.0,1.0,30.0,29,11,30,13,0,0,4,4,0,0,,0,0,2,1,1,void
4582,245437,SetFunction,1,node.wasi.SetFunction,"void node.wasi.SetFunction<FT,FT,R,Args> (R,Environment*,char*,Local<FunctionTemplate>)",node_wasi.cc,"static void SetFunction(R (*f)(WASI&, WasmMemory, Args...),
                        Environment* env,
                        const char* name,
                        Local<FunctionTemplate> tmpl) {
  WASI::WasiFunction<FT, F, R, Args...>::SetFunction(env, name, tmpl);
}",389.0,394.0,1.0,1.0,6.0,2,1,5,5,0,0,1,1,0,0,,0,0,8,4,4,void
4583,245454,ArgsGet,1,node.wasi.WASI.ArgsGet,"uint32_t node.wasi.WASI.ArgsGet (WASI,WasmMemory,uint32_t,uint32_t)",node_wasi.cc,"uint32_t WASI::ArgsGet(WASI& wasi,
                       WasmMemory memory,
                       uint32_t argv_offset,
                       uint32_t argv_buf_offset) {
  Debug(wasi, ""args_get(%d, %d)\n"", argv_offset, argv_buf_offset);

  CHECK_BOUNDS_OR_RETURN(memory.size, argv_buf_offset, wasi.uvw_.argv_buf_size);
  CHECK_BOUNDS_OR_RETURN(
      memory.size, argv_offset, wasi.uvw_.argc * UVWASI_SERDES_SIZE_uint32_t);
  std::vector<char*> argv(wasi.uvw_.argc);
  char* argv_buf = &memory.data[argv_buf_offset];
  uvwasi_errno_t err = uvwasi_args_get(&wasi.uvw_, argv.data(), argv_buf);

  if (err == UVWASI_ESUCCESS) {
    for (size_t i = 0; i < wasi.uvw_.argc; i++) {
      uint32_t offset =
          static_cast<uint32_t>(argv_buf_offset + (argv[i] - argv[0]));
      uvwasi_serdes_write_uint32_t(
          memory.data, argv_offset + (i * UVWASI_SERDES_SIZE_uint32_t), offset);
    }
  }

  return err;
}",396.0,419.0,1.0,2.0,24.0,37,11,41,12,0,0,3,4,0,0,,0,0,8,4,4,uint32_t
4584,245598,ArgsSizesGet,1,node.wasi.WASI.ArgsSizesGet,"uint32_t node.wasi.WASI.ArgsSizesGet (WASI,WasmMemory,uint32_t,uint32_t)",node_wasi.cc,"uint32_t WASI::ArgsSizesGet(WASI& wasi,
                            WasmMemory memory,
                            uint32_t argc_offset,
                            uint32_t argv_buf_offset) {
  Debug(wasi, ""args_sizes_get(%d, %d)\n"", argc_offset, argv_buf_offset);
  CHECK_BOUNDS_OR_RETURN(memory.size, argc_offset, UVWASI_SERDES_SIZE_size_t);
  CHECK_BOUNDS_OR_RETURN(
      memory.size, argv_buf_offset, UVWASI_SERDES_SIZE_size_t);
  uvwasi_size_t argc;
  uvwasi_size_t argv_buf_size;
  uvwasi_errno_t err = uvwasi_args_sizes_get(&wasi.uvw_, &argc, &argv_buf_size);
  if (err == UVWASI_ESUCCESS) {
    uvwasi_serdes_write_size_t(memory.data, argc_offset, argc);
    uvwasi_serdes_write_size_t(memory.data, argv_buf_offset, argv_buf_size);
  }

  return err;
}",421.0,438.0,1.0,2.0,18.0,14,5,30,10,0,0,2,2,0,0,,0,0,8,4,4,uint32_t
4585,245686,ClockResGet,1,node.wasi.WASI.ClockResGet,"uint32_t node.wasi.WASI.ClockResGet (WASI,WasmMemory,uint32_t,uint32_t)",node_wasi.cc,"uint32_t WASI::ClockResGet(WASI& wasi,
                           WasmMemory memory,
                           uint32_t clock_id,
                           uint32_t resolution_ptr) {
  Debug(wasi, ""clock_res_get(%d, %d)\n"", clock_id, resolution_ptr);
  CHECK_BOUNDS_OR_RETURN(
      memory.size, resolution_ptr, UVWASI_SERDES_SIZE_timestamp_t);
  uvwasi_timestamp_t resolution;
  uvwasi_errno_t err = uvwasi_clock_res_get(&wasi.uvw_, clock_id, &resolution);
  if (err == UVWASI_ESUCCESS)
    uvwasi_serdes_write_timestamp_t(memory.data, resolution_ptr, resolution);

  return err;
}",440.0,453.0,1.0,2.0,14.0,9,5,20,9,0,0,2,2,0,0,,0,0,8,4,4,uint32_t
4586,245745,ClockTimeGet,1,node.wasi.WASI.ClockTimeGet,"uint32_t node.wasi.WASI.ClockTimeGet (WASI,WasmMemory,uint32_t,uint64_t,uint32_t)",node_wasi.cc,"uint32_t WASI::ClockTimeGet(WASI& wasi,
                            WasmMemory memory,
                            uint32_t clock_id,
                            uint64_t precision,
                            uint32_t time_ptr) {
  Debug(wasi, ""clock_time_get(%d, %d, %d)\n"", clock_id, precision, time_ptr);
  CHECK_BOUNDS_OR_RETURN(memory.size, time_ptr, UVWASI_SERDES_SIZE_timestamp_t);
  uvwasi_timestamp_t time;
  uvwasi_errno_t err =
      uvwasi_clock_time_get(&wasi.uvw_, clock_id, precision, &time);
  if (err == UVWASI_ESUCCESS)
    uvwasi_serdes_write_timestamp_t(memory.data, time_ptr, time);

  return err;
}",455.0,469.0,1.0,2.0,15.0,9,5,22,10,0,0,2,2,0,0,,0,0,10,5,5,uint32_t
4587,245807,EnvironGet,1,node.wasi.WASI.EnvironGet,"uint32_t node.wasi.WASI.EnvironGet (WASI,WasmMemory,uint32_t,uint32_t)",node_wasi.cc,"uint32_t WASI::EnvironGet(WASI& wasi,
                          WasmMemory memory,
                          uint32_t environ_offset,
                          uint32_t environ_buf_offset) {
  Debug(wasi, ""environ_get(%d, %d)\n"", environ_offset, environ_buf_offset);
  CHECK_BOUNDS_OR_RETURN(
      memory.size, environ_buf_offset, wasi.uvw_.env_buf_size);
  CHECK_BOUNDS_OR_RETURN(memory.size,
                         environ_offset,
                         wasi.uvw_.envc * UVWASI_SERDES_SIZE_uint32_t);
  std::vector<char*> environment(wasi.uvw_.envc);
  char* environ_buf = &memory.data[environ_buf_offset];
  uvwasi_errno_t err =
      uvwasi_environ_get(&wasi.uvw_, environment.data(), environ_buf);

  if (err == UVWASI_ESUCCESS) {
    for (size_t i = 0; i < wasi.uvw_.envc; i++) {
      uint32_t offset = static_cast<uint32_t>(
          environ_buf_offset + (environment[i] - environment[0]));

      uvwasi_serdes_write_uint32_t(
          memory.data,
          environ_offset + (i * ...",471.0,499.0,1.0,2.0,29.0,37,11,41,12,0,0,3,4,0,0,,0,0,8,4,4,uint32_t
4588,245951,EnvironSizesGet,1,node.wasi.WASI.EnvironSizesGet,"uint32_t node.wasi.WASI.EnvironSizesGet (WASI,WasmMemory,uint32_t,uint32_t)",node_wasi.cc,"uint32_t WASI::EnvironSizesGet(WASI& wasi,
                               WasmMemory memory,
                               uint32_t envc_offset,
                               uint32_t env_buf_offset) {
  Debug(wasi, ""environ_sizes_get(%d, %d)\n"", envc_offset, env_buf_offset);
  CHECK_BOUNDS_OR_RETURN(memory.size, envc_offset, UVWASI_SERDES_SIZE_size_t);
  CHECK_BOUNDS_OR_RETURN(
      memory.size, env_buf_offset, UVWASI_SERDES_SIZE_size_t);
  uvwasi_size_t envc;
  uvwasi_size_t env_buf_size;
  uvwasi_errno_t err =
      uvwasi_environ_sizes_get(&wasi.uvw_, &envc, &env_buf_size);
  if (err == UVWASI_ESUCCESS) {
    uvwasi_serdes_write_size_t(memory.data, envc_offset, envc);
    uvwasi_serdes_write_size_t(memory.data, env_buf_offset, env_buf_size);
  }

  return err;
}",501.0,519.0,1.0,2.0,19.0,14,5,30,10,0,0,2,2,0,0,,0,0,8,4,4,uint32_t
4589,246039,FdAdvise,1,node.wasi.WASI.FdAdvise,"uint32_t node.wasi.WASI.FdAdvise (WASI,WasmMemory,uint32_t,uint64_t,uint64_t,uint32_t)",node_wasi.cc,"uint32_t WASI::FdAdvise(WASI& wasi,
                        WasmMemory,
                        uint32_t fd,
                        uint64_t offset,
                        uint64_t len,
                        uint32_t advice) {
  Debug(wasi, ""fd_advise(%d, %d, %d, %d)\n"", fd, offset, len, advice);
  return uvwasi_fd_advise(&wasi.uvw_, fd, offset, len, advice);
}",521.0,529.0,1.0,1.0,9.0,2,2,10,5,0,0,1,1,0,0,,0,0,12,6,6,uint32_t
4590,246066,FdAllocate,1,node.wasi.WASI.FdAllocate,"uint32_t node.wasi.WASI.FdAllocate (WASI,WasmMemory,uint32_t,uint64_t,uint64_t)",node_wasi.cc,"uint32_t WASI::FdAllocate(
    WASI& wasi, WasmMemory, uint32_t fd, uint64_t offset, uint64_t len) {
  Debug(wasi, ""fd_allocate(%d, %d, %d)\n"", fd, offset, len);
  return uvwasi_fd_allocate(&wasi.uvw_, fd, offset, len);
}",531.0,535.0,1.0,1.0,5.0,2,2,8,4,0,0,1,1,0,0,,0,0,10,5,5,uint32_t
4591,246090,FdClose,1,node.wasi.WASI.FdClose,"uint32_t node.wasi.WASI.FdClose (WASI,WasmMemory,uint32_t)",node_wasi.cc,"uint32_t WASI::FdClose(WASI& wasi, WasmMemory, uint32_t fd) {
  Debug(wasi, ""fd_close(%d)\n"", fd);
  return uvwasi_fd_close(&wasi.uvw_, fd);
}",537.0,540.0,1.0,1.0,4.0,2,2,4,2,0,0,1,1,0,0,,0,0,6,3,3,uint32_t
4592,246108,FdDatasync,1,node.wasi.WASI.FdDatasync,"uint32_t node.wasi.WASI.FdDatasync (WASI,WasmMemory,uint32_t)",node_wasi.cc,"uint32_t WASI::FdDatasync(WASI& wasi, WasmMemory, uint32_t fd) {
  Debug(wasi, ""fd_datasync(%d)\n"", fd);
  return uvwasi_fd_datasync(&wasi.uvw_, fd);
}",542.0,545.0,1.0,1.0,4.0,2,2,4,2,0,0,1,1,0,0,,0,0,6,3,3,uint32_t
4593,246126,FdFdstatGet,1,node.wasi.WASI.FdFdstatGet,"uint32_t node.wasi.WASI.FdFdstatGet (WASI,WasmMemory,uint32_t,uint32_t)",node_wasi.cc,"uint32_t WASI::FdFdstatGet(WASI& wasi,
                           WasmMemory memory,
                           uint32_t fd,
                           uint32_t buf) {
  Debug(wasi, ""fd_fdstat_get(%d, %d)\n"", fd, buf);
  CHECK_BOUNDS_OR_RETURN(memory.size, buf, UVWASI_SERDES_SIZE_fdstat_t);
  uvwasi_fdstat_t stats;
  uvwasi_errno_t err = uvwasi_fd_fdstat_get(&wasi.uvw_, fd, &stats);

  if (err == UVWASI_ESUCCESS)
    uvwasi_serdes_write_fdstat_t(memory.data, buf, &stats);

  return err;
}",547.0,560.0,1.0,2.0,14.0,10,5,20,9,0,0,2,2,0,0,,0,0,8,4,4,uint32_t
4594,246186,FdFdstatSetFlags,1,node.wasi.WASI.FdFdstatSetFlags,"uint32_t node.wasi.WASI.FdFdstatSetFlags (WASI,WasmMemory,uint32_t,uint32_t)",node_wasi.cc,"uint32_t WASI::FdFdstatSetFlags(WASI& wasi,
                                WasmMemory,
                                uint32_t fd,
                                uint32_t flags) {
  Debug(wasi, ""fd_fdstat_set_flags(%d, %d)\n"", fd, flags);
  return uvwasi_fd_fdstat_set_flags(&wasi.uvw_, fd, flags);
}",562.0,568.0,1.0,1.0,7.0,2,2,6,3,0,0,1,1,0,0,,0,0,8,4,4,uint32_t
4595,246207,FdFdstatSetRights,1,node.wasi.WASI.FdFdstatSetRights,"uint32_t node.wasi.WASI.FdFdstatSetRights (WASI,WasmMemory,uint32_t,uint64_t,uint64_t)",node_wasi.cc,"uint32_t WASI::FdFdstatSetRights(WASI& wasi,
                                 WasmMemory,
                                 uint32_t fd,
                                 uint64_t fs_rights_base,
                                 uint64_t fs_rights_inheriting) {
  Debug(wasi,
        ""fd_fdstat_set_rights(%d, %d, %d)\n"",
        fd,
        fs_rights_base,
        fs_rights_inheriting);
  return uvwasi_fd_fdstat_set_rights(
      &wasi.uvw_, fd, fs_rights_base, fs_rights_inheriting);
}",570.0,582.0,1.0,1.0,13.0,2,2,8,4,0,0,1,1,0,0,,0,0,10,5,5,uint32_t
4596,246231,FdFilestatGet,1,node.wasi.WASI.FdFilestatGet,"uint32_t node.wasi.WASI.FdFilestatGet (WASI,WasmMemory,uint32_t,uint32_t)",node_wasi.cc,"uint32_t WASI::FdFilestatGet(WASI& wasi,
                             WasmMemory memory,
                             uint32_t fd,
                             uint32_t buf) {
  Debug(wasi, ""fd_filestat_get(%d, %d)\n"", fd, buf);
  CHECK_BOUNDS_OR_RETURN(memory.size, buf, UVWASI_SERDES_SIZE_filestat_t);
  uvwasi_filestat_t stats;
  uvwasi_errno_t err = uvwasi_fd_filestat_get(&wasi.uvw_, fd, &stats);

  if (err == UVWASI_ESUCCESS)
    uvwasi_serdes_write_filestat_t(memory.data, buf, &stats);

  return err;
}",584.0,597.0,1.0,2.0,14.0,10,5,20,9,0,0,2,2,0,0,,0,0,8,4,4,uint32_t
4597,246291,FdFilestatSetSize,1,node.wasi.WASI.FdFilestatSetSize,"uint32_t node.wasi.WASI.FdFilestatSetSize (WASI,WasmMemory,uint32_t,uint64_t)",node_wasi.cc,"uint32_t WASI::FdFilestatSetSize(WASI& wasi,
                                 WasmMemory,
                                 uint32_t fd,
                                 uint64_t st_size) {
  Debug(wasi, ""fd_filestat_set_size(%d, %d)\n"", fd, st_size);
  return uvwasi_fd_filestat_set_size(&wasi.uvw_, fd, st_size);
}",599.0,605.0,1.0,1.0,7.0,2,2,6,3,0,0,1,1,0,0,,0,0,8,4,4,uint32_t
4598,246312,FdFilestatSetTimes,1,node.wasi.WASI.FdFilestatSetTimes,"uint32_t node.wasi.WASI.FdFilestatSetTimes (WASI,WasmMemory,uint32_t,uint64_t,uint64_t,uint32_t)",node_wasi.cc,"uint32_t WASI::FdFilestatSetTimes(WASI& wasi,
                                  WasmMemory,
                                  uint32_t fd,
                                  uint64_t st_atim,
                                  uint64_t st_mtim,
                                  uint32_t fst_flags) {
  Debug(wasi,
        ""fd_filestat_set_times(%d, %d, %d, %d)\n"",
        fd,
        st_atim,
        st_mtim,
        fst_flags);
  return uvwasi_fd_filestat_set_times(
      &wasi.uvw_, fd, st_atim, st_mtim, fst_flags);
}",607.0,621.0,1.0,1.0,15.0,2,2,10,5,0,0,1,1,0,0,,0,0,12,6,6,uint32_t
4599,246339,FdPread,1,node.wasi.WASI.FdPread,"uint32_t node.wasi.WASI.FdPread (WASI,WasmMemory,uint32_t,uint32_t,uint32_t,uint64_t,uint32_t)",node_wasi.cc,"uint32_t WASI::FdPread(WASI& wasi,
                       WasmMemory memory,
                       uint32_t fd,
                       uint32_t iovs_ptr,
                       uint32_t iovs_len,
                       uint64_t offset,
                       uint32_t nread_ptr) {
  Debug(wasi,
        ""uvwasi_fd_pread(%d, %d, %d, %d, %d)\n"",
        fd,
        iovs_ptr,
        iovs_len,
        offset,
        nread_ptr);
  CHECK_BOUNDS_OR_RETURN(
      memory.size, iovs_ptr, iovs_len * UVWASI_SERDES_SIZE_iovec_t);
  CHECK_BOUNDS_OR_RETURN(memory.size, nread_ptr, UVWASI_SERDES_SIZE_size_t);
  std::vector<uvwasi_iovec_t> iovs(iovs_len);
  uvwasi_errno_t err;

  err = uvwasi_serdes_readv_iovec_t(
      memory.data, memory.size, iovs_ptr, iovs.data(), iovs_len);
  if (err != UVWASI_ESUCCESS) {
    return err;
  }

  uvwasi_size_t nread;
  err = uvwasi_fd_pread(&wasi.uvw_, fd, iovs.data(), iovs_len, offset, &nread);
  if (err == UVWASI_ESUCCESS)
    uvwasi_serdes_write_size_t(memory....",623.0,655.0,1.0,2.0,33.0,22,9,45,16,0,0,3,3,0,0,,0,0,14,7,7,uint32_t
4600,246462,FdPrestatGet,1,node.wasi.WASI.FdPrestatGet,"uint32_t node.wasi.WASI.FdPrestatGet (WASI,WasmMemory,uint32_t,uint32_t)",node_wasi.cc,"uint32_t WASI::FdPrestatGet(WASI& wasi,
                            WasmMemory memory,
                            uint32_t fd,
                            uint32_t buf) {
  Debug(wasi, ""fd_prestat_get(%d, %d)\n"", fd, buf);
  CHECK_BOUNDS_OR_RETURN(memory.size, buf, UVWASI_SERDES_SIZE_prestat_t);
  uvwasi_prestat_t prestat;
  uvwasi_errno_t err = uvwasi_fd_prestat_get(&wasi.uvw_, fd, &prestat);

  if (err == UVWASI_ESUCCESS)
    uvwasi_serdes_write_prestat_t(memory.data, buf, &prestat);

  return err;
}",657.0,670.0,1.0,2.0,14.0,10,5,20,9,0,0,2,2,0,0,,0,0,8,4,4,uint32_t
4601,246522,FdPrestatDirName,1,node.wasi.WASI.FdPrestatDirName,"uint32_t node.wasi.WASI.FdPrestatDirName (WASI,WasmMemory,uint32_t,uint32_t,uint32_t)",node_wasi.cc,"uint32_t WASI::FdPrestatDirName(WASI& wasi,
                                WasmMemory memory,
                                uint32_t fd,
                                uint32_t path_ptr,
                                uint32_t path_len) {
  Debug(wasi, ""fd_prestat_dir_name(%d, %d, %d)\n"", fd, path_ptr, path_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len);
  return uvwasi_fd_prestat_dir_name(
      &wasi.uvw_, fd, &memory.data[path_ptr], path_len);
}",672.0,681.0,1.0,2.0,10.0,8,4,16,6,0,0,1,1,0,0,,0,0,10,5,5,uint32_t
4602,246572,FdPwrite,1,node.wasi.WASI.FdPwrite,"uint32_t node.wasi.WASI.FdPwrite (WASI,WasmMemory,uint32_t,uint32_t,uint32_t,uint64_t,uint32_t)",node_wasi.cc,"uint32_t WASI::FdPwrite(WASI& wasi,
                        WasmMemory memory,
                        uint32_t fd,
                        uint32_t iovs_ptr,
                        uint32_t iovs_len,
                        uint64_t offset,
                        uint32_t nwritten_ptr) {
  Debug(wasi,
        ""uvwasi_fd_pwrite(%d, %d, %d, %d, %d)\n"",
        fd,
        iovs_ptr,
        iovs_len,
        offset,
        nwritten_ptr);
  CHECK_BOUNDS_OR_RETURN(
      memory.size, iovs_ptr, iovs_len * UVWASI_SERDES_SIZE_ciovec_t);
  CHECK_BOUNDS_OR_RETURN(memory.size, nwritten_ptr, UVWASI_SERDES_SIZE_size_t);
  std::vector<uvwasi_ciovec_t> iovs(iovs_len);
  uvwasi_errno_t err;

  err = uvwasi_serdes_readv_ciovec_t(
      memory.data, memory.size, iovs_ptr, iovs.data(), iovs_len);
  if (err != UVWASI_ESUCCESS) {
    return err;
  }

  uvwasi_size_t nwritten;
  err = uvwasi_fd_pwrite(
      &wasi.uvw_, fd, iovs.data(), iovs_len, offset, &nwritten);
  if (err == UVWASI_ESUCCESS)
    ...",683.0,716.0,1.0,2.0,34.0,22,9,45,16,0,0,3,3,0,0,,0,0,14,7,7,uint32_t
4603,246695,FdRead,1,node.wasi.WASI.FdRead,"uint32_t node.wasi.WASI.FdRead (WASI,WasmMemory,uint32_t,uint32_t,uint32_t,uint32_t)",node_wasi.cc,"uint32_t WASI::FdRead(WASI& wasi,
                      WasmMemory memory,
                      uint32_t fd,
                      uint32_t iovs_ptr,
                      uint32_t iovs_len,
                      uint32_t nread_ptr) {
  Debug(wasi, ""fd_read(%d, %d, %d, %d)\n"", fd, iovs_ptr, iovs_len, nread_ptr);
  CHECK_BOUNDS_OR_RETURN(
      memory.size, iovs_ptr, iovs_len * UVWASI_SERDES_SIZE_iovec_t);
  CHECK_BOUNDS_OR_RETURN(memory.size, nread_ptr, UVWASI_SERDES_SIZE_size_t);
  std::vector<uvwasi_iovec_t> iovs(iovs_len);
  uvwasi_errno_t err;

  err = uvwasi_serdes_readv_iovec_t(
      memory.data, memory.size, iovs_ptr, iovs.data(), iovs_len);
  if (err != UVWASI_ESUCCESS) {
    return err;
  }

  uvwasi_size_t nread;
  err = uvwasi_fd_read(&wasi.uvw_, fd, iovs.data(), iovs_len, &nread);
  if (err == UVWASI_ESUCCESS)
    uvwasi_serdes_write_size_t(memory.data, nread_ptr, nread);

  return err;
}",718.0,743.0,1.0,2.0,26.0,22,9,43,15,0,0,3,3,0,0,,0,0,12,6,6,uint32_t
4604,246815,FdReaddir,1,node.wasi.WASI.FdReaddir,"uint32_t node.wasi.WASI.FdReaddir (WASI,WasmMemory,uint32_t,uint32_t,uint32_t,uint64_t,uint32_t)",node_wasi.cc,"uint32_t WASI::FdReaddir(WASI& wasi,
                         WasmMemory memory,
                         uint32_t fd,
                         uint32_t buf_ptr,
                         uint32_t buf_len,
                         uint64_t cookie,
                         uint32_t bufused_ptr) {
  Debug(wasi,
        ""uvwasi_fd_readdir(%d, %d, %d, %d, %d)\n"",
        fd,
        buf_ptr,
        buf_len,
        cookie,
        bufused_ptr);
  CHECK_BOUNDS_OR_RETURN(memory.size, buf_ptr, buf_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, bufused_ptr, UVWASI_SERDES_SIZE_size_t);
  uvwasi_size_t bufused;
  uvwasi_errno_t err = uvwasi_fd_readdir(
      &wasi.uvw_, fd, &memory.data[buf_ptr], buf_len, cookie, &bufused);
  if (err == UVWASI_ESUCCESS)
    uvwasi_serdes_write_size_t(memory.data, bufused_ptr, bufused);

  return err;
}",745.0,768.0,1.0,2.0,24.0,15,6,34,12,0,0,2,2,0,0,,0,0,14,7,7,uint32_t
4605,246909,FdRenumber,1,node.wasi.WASI.FdRenumber,"uint32_t node.wasi.WASI.FdRenumber (WASI,WasmMemory,uint32_t,uint32_t)",node_wasi.cc,"uint32_t WASI::FdRenumber(WASI& wasi, WasmMemory, uint32_t from, uint32_t to) {
  Debug(wasi, ""fd_renumber(%d, %d)\n"", from, to);
  return uvwasi_fd_renumber(&wasi.uvw_, from, to);
}",770.0,773.0,1.0,1.0,4.0,2,2,6,3,0,0,1,1,0,0,,0,0,8,4,4,uint32_t
4606,246930,FdSeek,1,node.wasi.WASI.FdSeek,"uint32_t node.wasi.WASI.FdSeek (WASI,WasmMemory,uint32_t,int64_t,uint32_t,uint32_t)",node_wasi.cc,"uint32_t WASI::FdSeek(WASI& wasi,
                      WasmMemory memory,
                      uint32_t fd,
                      int64_t offset,
                      uint32_t whence,
                      uint32_t newoffset_ptr) {
  Debug(wasi, ""fd_seek(%d, %d, %d, %d)\n"", fd, offset, whence, newoffset_ptr);
  CHECK_BOUNDS_OR_RETURN(
      memory.size, newoffset_ptr, UVWASI_SERDES_SIZE_filesize_t);
  uvwasi_filesize_t newoffset;
  uvwasi_errno_t err =
      uvwasi_fd_seek(&wasi.uvw_, fd, offset, whence, &newoffset);
  if (err == UVWASI_ESUCCESS)
    uvwasi_serdes_write_filesize_t(memory.data, newoffset_ptr, newoffset);

  return err;
}",775.0,791.0,1.0,2.0,17.0,9,5,24,11,0,0,2,2,0,0,,0,0,12,6,6,uint32_t
4607,246995,FdSync,1,node.wasi.WASI.FdSync,"uint32_t node.wasi.WASI.FdSync (WASI,WasmMemory,uint32_t)",node_wasi.cc,"uint32_t WASI::FdSync(WASI& wasi, WasmMemory, uint32_t fd) {
  Debug(wasi, ""fd_sync(%d)\n"", fd);
  return uvwasi_fd_sync(&wasi.uvw_, fd);
}",793.0,796.0,1.0,1.0,4.0,2,2,4,2,0,0,1,1,0,0,,0,0,6,3,3,uint32_t
4608,247013,FdTell,1,node.wasi.WASI.FdTell,"uint32_t node.wasi.WASI.FdTell (WASI,WasmMemory,uint32_t,uint32_t)",node_wasi.cc,"uint32_t WASI::FdTell(WASI& wasi,
                      WasmMemory memory,
                      uint32_t fd,
                      uint32_t offset_ptr) {
  Debug(wasi, ""fd_tell(%d, %d)\n"", fd, offset_ptr);
  CHECK_BOUNDS_OR_RETURN(
      memory.size, offset_ptr, UVWASI_SERDES_SIZE_filesize_t);
  uvwasi_filesize_t offset;
  uvwasi_errno_t err = uvwasi_fd_tell(&wasi.uvw_, fd, &offset);

  if (err == UVWASI_ESUCCESS)
    uvwasi_serdes_write_filesize_t(memory.data, offset_ptr, offset);

  return err;
}",798.0,812.0,1.0,2.0,15.0,9,5,20,9,0,0,2,2,0,0,,0,0,8,4,4,uint32_t
4609,247072,FdWrite,1,node.wasi.WASI.FdWrite,"uint32_t node.wasi.WASI.FdWrite (WASI,WasmMemory,uint32_t,uint32_t,uint32_t,uint32_t)",node_wasi.cc,"uint32_t WASI::FdWrite(WASI& wasi,
                       WasmMemory memory,
                       uint32_t fd,
                       uint32_t iovs_ptr,
                       uint32_t iovs_len,
                       uint32_t nwritten_ptr) {
  Debug(wasi,
        ""fd_write(%d, %d, %d, %d)\n"",
        fd,
        iovs_ptr,
        iovs_len,
        nwritten_ptr);
  CHECK_BOUNDS_OR_RETURN(
      memory.size, iovs_ptr, iovs_len * UVWASI_SERDES_SIZE_ciovec_t);
  CHECK_BOUNDS_OR_RETURN(memory.size, nwritten_ptr, UVWASI_SERDES_SIZE_size_t);
  std::vector<uvwasi_ciovec_t> iovs(iovs_len);
  uvwasi_errno_t err;

  err = uvwasi_serdes_readv_ciovec_t(
      memory.data, memory.size, iovs_ptr, iovs.data(), iovs_len);
  if (err != UVWASI_ESUCCESS) {
    return err;
  }

  uvwasi_size_t nwritten;
  err = uvwasi_fd_write(&wasi.uvw_, fd, iovs.data(), iovs_len, &nwritten);
  if (err == UVWASI_ESUCCESS)
    uvwasi_serdes_write_size_t(memory.data, nwritten_ptr, nwritten);

  return err;
}",814.0,844.0,1.0,2.0,31.0,22,9,43,15,0,0,3,3,0,0,,0,0,12,6,6,uint32_t
4610,247192,PathCreateDirectory,1,node.wasi.WASI.PathCreateDirectory,"uint32_t node.wasi.WASI.PathCreateDirectory (WASI,WasmMemory,uint32_t,uint32_t,uint32_t)",node_wasi.cc,"uint32_t WASI::PathCreateDirectory(WASI& wasi,
                                   WasmMemory memory,
                                   uint32_t fd,
                                   uint32_t path_ptr,
                                   uint32_t path_len) {
  Debug(wasi, ""path_create_directory(%d, %d, %d)\n"", fd, path_ptr, path_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len);
  uvwasi_errno_t err = uvwasi_path_create_directory(
      &wasi.uvw_, fd, &memory.data[path_ptr], path_len);
  return err;
}",846.0,856.0,1.0,2.0,11.0,9,5,18,7,0,0,1,1,0,0,,0,0,10,5,5,uint32_t
4611,247246,PathFilestatGet,1,node.wasi.WASI.PathFilestatGet,"uint32_t node.wasi.WASI.PathFilestatGet (WASI,WasmMemory,uint32_t,uint32_t,uint32_t,uint32_t,uint32_t)",node_wasi.cc,"uint32_t WASI::PathFilestatGet(WASI& wasi,
                               WasmMemory memory,
                               uint32_t fd,
                               uint32_t flags,
                               uint32_t path_ptr,
                               uint32_t path_len,
                               uint32_t buf_ptr) {
  Debug(wasi,
        ""path_filestat_get(%d, %d, %d)\n"",
        fd,
        path_ptr,
        path_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, buf_ptr, UVWASI_SERDES_SIZE_filestat_t);
  uvwasi_filestat_t stats;
  uvwasi_errno_t err = uvwasi_path_filestat_get(
      &wasi.uvw_, fd, flags, &memory.data[path_ptr], path_len, &stats);
  if (err == UVWASI_ESUCCESS)
    uvwasi_serdes_write_filestat_t(memory.data, buf_ptr, &stats);

  return err;
}",858.0,879.0,1.0,2.0,22.0,16,6,32,12,0,0,2,2,0,0,,0,0,14,7,7,uint32_t
4612,247339,PathFilestatSetTimes,1,node.wasi.WASI.PathFilestatSetTimes,"uint32_t node.wasi.WASI.PathFilestatSetTimes (WASI,WasmMemory,uint32_t,uint32_t,uint32_t,uint32_t,uint64_t,uint64_t,uint32_t)",node_wasi.cc,"uint32_t WASI::PathFilestatSetTimes(WASI& wasi,
                                    WasmMemory memory,
                                    uint32_t fd,
                                    uint32_t flags,
                                    uint32_t path_ptr,
                                    uint32_t path_len,
                                    uint64_t st_atim,
                                    uint64_t st_mtim,
                                    uint32_t fst_flags) {
  Debug(wasi,
        ""path_filestat_set_times(%d, %d, %d, %d, %d, %d, %d)\n"",
        fd,
        flags,
        path_ptr,
        path_len,
        st_atim,
        st_mtim,
        fst_flags);
  CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len);
  return uvwasi_path_filestat_set_times(&wasi.uvw_,
                                        fd,
                                        flags,
                                        &memory.data[path_ptr],
                                        path_len,
     ...",881.0,908.0,1.0,2.0,28.0,8,4,24,10,0,0,1,1,0,0,,0,0,18,9,9,uint32_t
4613,247401,PathLink,1,node.wasi.WASI.PathLink,"uint32_t node.wasi.WASI.PathLink (WASI,WasmMemory,uint32_t,uint32_t,uint32_t,uint32_t,uint32_t,uint32_t,uint32_t)",node_wasi.cc,"uint32_t WASI::PathLink(WASI& wasi,
                        WasmMemory memory,
                        uint32_t old_fd,
                        uint32_t old_flags,
                        uint32_t old_path_ptr,
                        uint32_t old_path_len,
                        uint32_t new_fd,
                        uint32_t new_path_ptr,
                        uint32_t new_path_len) {
  Debug(wasi,
        ""path_link(%d, %d, %d, %d, %d, %d, %d)\n"",
        old_fd,
        old_flags,
        old_path_ptr,
        old_path_len,
        new_fd,
        new_path_ptr,
        new_path_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, old_path_ptr, old_path_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, new_path_ptr, new_path_len);
  return uvwasi_path_link(&wasi.uvw_,
                          old_fd,
                          old_flags,
                          &memory.data[old_path_ptr],
                          old_path_len,
                          new_fd,
                          ...",910.0,938.0,1.0,2.0,29.0,14,4,32,10,0,0,1,1,0,0,,0,0,18,9,9,uint32_t
4614,247489,PathOpen,1,node.wasi.WASI.PathOpen,"uint32_t node.wasi.WASI.PathOpen (WASI,WasmMemory,uint32_t,uint32_t,uint32_t,uint32_t,uint32_t,uint64_t,uint64_t,uint32_t,uint32_t)",node_wasi.cc,"uint32_t WASI::PathOpen(WASI& wasi,
                        WasmMemory memory,
                        uint32_t dirfd,
                        uint32_t dirflags,
                        uint32_t path_ptr,
                        uint32_t path_len,
                        uint32_t o_flags,
                        uint64_t fs_rights_base,
                        uint64_t fs_rights_inheriting,
                        uint32_t fs_flags,
                        uint32_t fd_ptr) {
  Debug(wasi,
        ""path_open(%d, %d, %d, %d, %d, %d, %d, %d, %d)\n"",
        dirfd,
        dirflags,
        path_ptr,
        path_len,
        o_flags,
        fs_rights_base,
        fs_rights_inheriting,
        fs_flags,
        fd_ptr);
  CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, fd_ptr, UVWASI_SERDES_SIZE_fd_t);
  uvwasi_fd_t fd;
  uvwasi_errno_t err = uvwasi_path_open(&wasi.uvw_,
                                        dirfd,
                     ...",940.0,979.0,1.0,2.0,40.0,17,7,42,16,0,0,2,2,0,0,,0,0,22,11,11,uint32_t
4615,247599,PathReadlink,1,node.wasi.WASI.PathReadlink,"uint32_t node.wasi.WASI.PathReadlink (WASI,WasmMemory,uint32_t,uint32_t,uint32_t,uint32_t,uint32_t,uint32_t)",node_wasi.cc,"uint32_t WASI::PathReadlink(WASI& wasi,
                            WasmMemory memory,
                            uint32_t fd,
                            uint32_t path_ptr,
                            uint32_t path_len,
                            uint32_t buf_ptr,
                            uint32_t buf_len,
                            uint32_t bufused_ptr) {
  Debug(wasi,
        ""path_readlink(%d, %d, %d, %d, %d, %d)\n"",
        fd,
        path_ptr,
        path_len,
        buf_ptr,
        buf_len,
        bufused_ptr);
  CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, buf_ptr, buf_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, bufused_ptr, UVWASI_SERDES_SIZE_size_t);
  uvwasi_size_t bufused;
  uvwasi_errno_t err = uvwasi_path_readlink(&wasi.uvw_,
                                            fd,
                                            &memory.data[path_ptr],
                                            path_len,
                ...",981.0,1012.0,1.0,2.0,32.0,21,6,44,13,0,0,2,2,0,0,,0,0,16,8,8,uint32_t
4616,247722,PathRemoveDirectory,1,node.wasi.WASI.PathRemoveDirectory,"uint32_t node.wasi.WASI.PathRemoveDirectory (WASI,WasmMemory,uint32_t,uint32_t,uint32_t)",node_wasi.cc,"uint32_t WASI::PathRemoveDirectory(WASI& wasi,
                                   WasmMemory memory,
                                   uint32_t fd,
                                   uint32_t path_ptr,
                                   uint32_t path_len) {
  Debug(wasi, ""path_remove_directory(%d, %d, %d)\n"", fd, path_ptr, path_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len);
  return uvwasi_path_remove_directory(
      &wasi.uvw_, fd, &memory.data[path_ptr], path_len);
}",1014.0,1023.0,1.0,2.0,10.0,8,4,16,6,0,0,1,1,0,0,,0,0,10,5,5,uint32_t
4617,247772,PathRename,1,node.wasi.WASI.PathRename,"uint32_t node.wasi.WASI.PathRename (WASI,WasmMemory,uint32_t,uint32_t,uint32_t,uint32_t,uint32_t,uint32_t)",node_wasi.cc,"uint32_t WASI::PathRename(WASI& wasi,
                          WasmMemory memory,
                          uint32_t old_fd,
                          uint32_t old_path_ptr,
                          uint32_t old_path_len,
                          uint32_t new_fd,
                          uint32_t new_path_ptr,
                          uint32_t new_path_len) {
  Debug(wasi,
        ""path_rename(%d, %d, %d, %d, %d, %d)\n"",
        old_fd,
        old_path_ptr,
        old_path_len,
        new_fd,
        new_path_ptr,
        new_path_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, old_path_ptr, old_path_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, new_path_ptr, new_path_len);
  return uvwasi_path_rename(&wasi.uvw_,
                            old_fd,
                            &memory.data[old_path_ptr],
                            old_path_len,
                            new_fd,
                            &memory.data[new_path_ptr],
                            new_path_len);
}",1025.0,1050.0,1.0,2.0,26.0,14,4,30,9,0,0,1,1,0,0,,0,0,16,8,8,uint32_t
4618,247857,PathSymlink,1,node.wasi.WASI.PathSymlink,"uint32_t node.wasi.WASI.PathSymlink (WASI,WasmMemory,uint32_t,uint32_t,uint32_t,uint32_t,uint32_t)",node_wasi.cc,"uint32_t WASI::PathSymlink(WASI& wasi,
                           WasmMemory memory,
                           uint32_t old_path_ptr,
                           uint32_t old_path_len,
                           uint32_t fd,
                           uint32_t new_path_ptr,
                           uint32_t new_path_len) {
  Debug(wasi,
        ""path_symlink(%d, %d, %d, %d, %d)\n"",
        old_path_ptr,
        old_path_len,
        fd,
        new_path_ptr,
        new_path_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, old_path_ptr, old_path_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, new_path_ptr, new_path_len);
  return uvwasi_path_symlink(&wasi.uvw_,
                             &memory.data[old_path_ptr],
                             old_path_len,
                             fd,
                             &memory.data[new_path_ptr],
                             new_path_len);
}",1052.0,1074.0,1.0,2.0,23.0,14,4,28,8,0,0,1,1,0,0,,0,0,14,7,7,uint32_t
4619,247939,PathUnlinkFile,1,node.wasi.WASI.PathUnlinkFile,"uint32_t node.wasi.WASI.PathUnlinkFile (WASI,WasmMemory,uint32_t,uint32_t,uint32_t)",node_wasi.cc,"uint32_t WASI::PathUnlinkFile(WASI& wasi,
                              WasmMemory memory,
                              uint32_t fd,
                              uint32_t path_ptr,
                              uint32_t path_len) {
  Debug(wasi, ""path_unlink_file(%d, %d, %d)\n"", fd, path_ptr, path_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, path_ptr, path_len);
  return uvwasi_path_unlink_file(
      &wasi.uvw_, fd, &memory.data[path_ptr], path_len);
}",1076.0,1085.0,1.0,2.0,10.0,8,4,16,6,0,0,1,1,0,0,,0,0,10,5,5,uint32_t
4620,247989,PollOneoff,1,node.wasi.WASI.PollOneoff,"uint32_t node.wasi.WASI.PollOneoff (WASI,WasmMemory,uint32_t,uint32_t,uint32_t,uint32_t)",node_wasi.cc,"uint32_t WASI::PollOneoff(WASI& wasi,
                          WasmMemory memory,
                          uint32_t in_ptr,
                          uint32_t out_ptr,
                          uint32_t nsubscriptions,
                          uint32_t nevents_ptr) {
  Debug(wasi,
        ""poll_oneoff(%d, %d, %d, %d)\n"",
        in_ptr,
        out_ptr,
        nsubscriptions,
        nevents_ptr);
  CHECK_BOUNDS_OR_RETURN(
      memory.size, in_ptr, nsubscriptions * UVWASI_SERDES_SIZE_subscription_t);
  CHECK_BOUNDS_OR_RETURN(
      memory.size, out_ptr, nsubscriptions * UVWASI_SERDES_SIZE_event_t);
  CHECK_BOUNDS_OR_RETURN(memory.size, nevents_ptr, UVWASI_SERDES_SIZE_size_t);
  std::vector<uvwasi_subscription_t> in(nsubscriptions);
  std::vector<uvwasi_event_t> out(nsubscriptions);

  for (uint32_t i = 0; i < nsubscriptions; ++i) {
    uvwasi_serdes_read_subscription_t(memory.data, in_ptr, &in[i]);
    in_ptr += UVWASI_SERDES_SIZE_subscription_t;
  }

  uvwasi_size_t nevents;
 ...",1087.0,1125.0,1.0,2.0,39.0,37,10,62,19,0,0,4,5,0,0,,0,0,12,6,6,uint32_t
4621,248168,ProcExit,1,node.wasi.WASI.ProcExit,"void node.wasi.WASI.ProcExit (WASI,WasmMemory,uint32_t)",node_wasi.cc,"void WASI::ProcExit(WASI& wasi, WasmMemory, uint32_t code) {
  Debug(wasi, ""proc_exit(%d)\n"", code);
  uvwasi_proc_exit(&wasi.uvw_, code);
}",1127.0,1130.0,1.0,1.0,4.0,2,2,4,2,0,0,1,1,0,0,,0,0,6,3,3,void
4622,248185,ProcRaise,1,node.wasi.WASI.ProcRaise,"uint32_t node.wasi.WASI.ProcRaise (WASI,WasmMemory,uint32_t)",node_wasi.cc,"uint32_t WASI::ProcRaise(WASI& wasi, WasmMemory, uint32_t sig) {
  Debug(wasi, ""proc_raise(%d)\n"", sig);
  return uvwasi_proc_raise(&wasi.uvw_, sig);
}",1132.0,1135.0,1.0,1.0,4.0,2,2,4,2,0,0,1,1,0,0,,0,0,6,3,3,uint32_t
4623,248203,RandomGet,1,node.wasi.WASI.RandomGet,"uint32_t node.wasi.WASI.RandomGet (WASI,WasmMemory,uint32_t,uint32_t)",node_wasi.cc,"uint32_t WASI::RandomGet(WASI& wasi,
                         WasmMemory memory,
                         uint32_t buf_ptr,
                         uint32_t buf_len) {
  Debug(wasi, ""random_get(%d, %d)\n"", buf_ptr, buf_len);
  CHECK_BOUNDS_OR_RETURN(memory.size, buf_ptr, buf_len);
  return uvwasi_random_get(&wasi.uvw_, &memory.data[buf_ptr], buf_len);
}",1137.0,1144.0,1.0,2.0,8.0,8,4,14,5,0,0,1,1,0,0,,0,0,8,4,4,uint32_t
4624,248250,SchedYield,1,node.wasi.WASI.SchedYield,"uint32_t node.wasi.WASI.SchedYield (WASI,WasmMemory)",node_wasi.cc,"uint32_t WASI::SchedYield(WASI& wasi, WasmMemory) {
  Debug(wasi, ""sched_yield()\n"");
  return uvwasi_sched_yield(&wasi.uvw_);
}",1146.0,1149.0,1.0,1.0,4.0,2,2,2,1,0,0,1,1,0,0,,0,0,4,2,2,uint32_t
4625,248265,SockAccept,1,node.wasi.WASI.SockAccept,"uint32_t node.wasi.WASI.SockAccept (WASI,WasmMemory,uint32_t,uint32_t,uint32_t)",node_wasi.cc,"uint32_t WASI::SockAccept(WASI& wasi,
                          WasmMemory memory,
                          uint32_t sock,
                          uint32_t flags,
                          uint32_t fd_ptr) {
  Debug(wasi, ""sock_accept(%d, %d, %d)\n"", sock, flags, fd_ptr);
  uvwasi_fd_t fd;
  uvwasi_errno_t err = uvwasi_sock_accept(&wasi.uvw_, sock, flags, &fd);

  if (err == UVWASI_ESUCCESS)
    uvwasi_serdes_write_size_t(memory.data, fd_ptr, fd);

  return err;
}",1151.0,1164.0,1.0,1.0,14.0,6,4,15,8,0,0,2,2,0,0,,0,0,10,5,5,uint32_t
4626,248306,SockRecv,1,node.wasi.WASI.SockRecv,"uint32_t node.wasi.WASI.SockRecv (WASI,WasmMemory,uint32_t,uint32_t,uint32_t,uint32_t,uint32_t,uint32_t)",node_wasi.cc,"uint32_t WASI::SockRecv(WASI& wasi,
                        WasmMemory memory,
                        uint32_t sock,
                        uint32_t ri_data_ptr,
                        uint32_t ri_data_len,
                        uint32_t ri_flags,
                        uint32_t ro_datalen_ptr,
                        uint32_t ro_flags_ptr) {
  Debug(wasi,
        ""sock_recv(%d, %d, %d, %d, %d, %d)\n"",
        sock,
        ri_data_ptr,
        ri_data_len,
        ri_flags,
        ro_datalen_ptr,
        ro_flags_ptr);
  CHECK_BOUNDS_OR_RETURN(
      memory.size, ri_data_ptr, ri_data_len * UVWASI_SERDES_SIZE_iovec_t);
  CHECK_BOUNDS_OR_RETURN(memory.size, ro_datalen_ptr, 4);
  CHECK_BOUNDS_OR_RETURN(memory.size, ro_flags_ptr, 4);
  std::vector<uvwasi_iovec_t> ri_data(ri_data_len);
  uvwasi_errno_t err = uvwasi_serdes_readv_iovec_t(
      memory.data, memory.size, ri_data_ptr, ri_data.data(), ri_data_len);
  if (err != UVWASI_ESUCCESS) {
    return err;
  }

  uvwasi_size_t r...",1166.0,1208.0,1.0,2.0,43.0,27,9,53,17,0,0,3,3,0,0,,0,0,16,8,8,uint32_t
4627,248461,SockSend,1,node.wasi.WASI.SockSend,"uint32_t node.wasi.WASI.SockSend (WASI,WasmMemory,uint32_t,uint32_t,uint32_t,uint32_t,uint32_t)",node_wasi.cc,"uint32_t WASI::SockSend(WASI& wasi,
                        WasmMemory memory,
                        uint32_t sock,
                        uint32_t si_data_ptr,
                        uint32_t si_data_len,
                        uint32_t si_flags,
                        uint32_t so_datalen_ptr) {
  Debug(wasi,
        ""sock_send(%d, %d, %d, %d, %d)\n"",
        sock,
        si_data_ptr,
        si_data_len,
        si_flags,
        so_datalen_ptr);
  CHECK_BOUNDS_OR_RETURN(
      memory.size, si_data_ptr, si_data_len * UVWASI_SERDES_SIZE_ciovec_t);
  CHECK_BOUNDS_OR_RETURN(
      memory.size, so_datalen_ptr, UVWASI_SERDES_SIZE_size_t);
  std::vector<uvwasi_ciovec_t> si_data(si_data_len);
  uvwasi_errno_t err = uvwasi_serdes_readv_ciovec_t(
      memory.data, memory.size, si_data_ptr, si_data.data(), si_data_len);
  if (err != UVWASI_ESUCCESS) {
    return err;
  }

  uvwasi_size_t so_datalen;
  err = uvwasi_sock_send(
      &wasi.uvw_, sock, si_data.data(), si_data_len, si_fl...",1210.0,1242.0,1.0,2.0,33.0,22,9,45,16,0,0,3,3,0,0,,0,0,14,7,7,uint32_t
4628,248584,SockShutdown,1,node.wasi.WASI.SockShutdown,"uint32_t node.wasi.WASI.SockShutdown (WASI,WasmMemory,uint32_t,uint32_t)",node_wasi.cc,"uint32_t WASI::SockShutdown(WASI& wasi,
                            WasmMemory,
                            uint32_t sock,
                            uint32_t how) {
  Debug(wasi, ""sock_shutdown(%d, %d)\n"", sock, how);
  return uvwasi_sock_shutdown(&wasi.uvw_, sock, how);
}",1244.0,1250.0,1.0,1.0,7.0,2,2,6,3,0,0,1,1,0,0,,0,0,8,4,4,uint32_t
4629,248605,_SetMemory,1,node.wasi.WASI._SetMemory,void node.wasi.WASI._SetMemory (FunctionCallbackInfo<Value>),node_wasi.cc,"void WASI::_SetMemory(const FunctionCallbackInfo<Value>& args) {
  WASI* wasi;
  ASSIGN_OR_RETURN_UNWRAP(&wasi, args.This());
  CHECK_EQ(args.Length(), 1);
  if (!args[0]->IsWasmMemoryObject()) {
    return node::THROW_ERR_INVALID_ARG_TYPE(
        wasi->env(),
        ""\""instance.exports.memory\"" property must be a WebAssembly.Memory ""
        ""object"");
  }
  wasi->memory_.Reset(wasi->env()->isolate(), args[0].As<WasmMemoryObject>());
}",1252.0,1263.0,1.0,1.0,12.0,14,5,9,3,0,0,2,2,0,0,,0,0,2,1,1,void
4630,248662,InitializePreview1,1,node.wasi.InitializePreview1,"void node.wasi.InitializePreview1 (Local<Object>,Local<Value>,Local<Context>,void*)",node_wasi.cc,"static void InitializePreview1(Local<Object> target,
                               Local<Value> unused,
                               Local<Context> context,
                               void* priv) {
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  Local<FunctionTemplate> tmpl = NewFunctionTemplate(isolate, WASI::New);
  tmpl->InstanceTemplate()->SetInternalFieldCount(WASI::kInternalFieldCount);

#define V(F, name)                                                             \
  SetFunction<decltype(&WASI::F), WASI::F>(WASI::F, env, name, tmpl);

  V(ArgsGet, ""args_get"")
  V(ArgsSizesGet, ""args_sizes_get"")
  V(ClockResGet, ""clock_res_get"")
  V(ClockTimeGet, ""clock_time_get"")
  V(EnvironGet, ""environ_get"")
  V(EnvironSizesGet, ""environ_sizes_get"")
  V(FdAdvise, ""fd_advise"")
  V(FdAllocate, ""fd_allocate"")
  V(FdClose, ""fd_close"")
  V(FdDatasync, ""fd_datasync"")
  V(FdFdstatGet, ""fd_fdstat_get"")
  V(FdFdstatSetFlags, ""fd_fdstat_set_flags...",1265.0,1329.0,1.0,2.0,65.0,58,5,202,101,0,0,1,1,0,0,,0,0,8,4,4,void
4631,249253,Initialize,1,node.wasm_web_api.WasmStreamingObject.Initialize,Local<Function> node.wasm_web_api.WasmStreamingObject.Initialize (Environment*),node_wasm_web_api.cc,"Local<Function> WasmStreamingObject::Initialize(Environment* env) {
  Local<Function> templ = env->wasm_streaming_object_constructor();
  if (!templ.IsEmpty()) {
    return templ;
  }

  Isolate* isolate = env->isolate();
  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, New);
  t->InstanceTemplate()->SetInternalFieldCount(
      WasmStreamingObject::kInternalFieldCount);

  SetProtoMethod(isolate, t, ""setURL"", SetURL);
  SetProtoMethod(isolate, t, ""push"", Push);
  SetProtoMethod(isolate, t, ""finish"", Finish);
  SetProtoMethod(isolate, t, ""abort"", Abort);

  auto function = t->GetFunction(env->context()).ToLocalChecked();
  env->set_wasm_streaming_object_constructor(function);
  return function;
}",23.0,42.0,1.0,1.0,20.0,19,6,33,14,0,0,2,2,0,0,,0,0,2,1,1,Local<Function>
4632,249344,RegisterExternalReferences,1,node.wasm_web_api.WasmStreamingObject.RegisterExternalReferences,void node.wasm_web_api.WasmStreamingObject.RegisterExternalReferences (ExternalReferenceRegistry*),node_wasm_web_api.cc,"void WasmStreamingObject::RegisterExternalReferences(
    ExternalReferenceRegistry* registry) {
  registry->Register(New);
  registry->Register(Push);
  registry->Register(Finish);
  registry->Register(Abort);
}",44.0,50.0,1.0,1.0,7.0,4,1,8,5,0,0,1,1,0,0,,0,0,2,1,1,void
4633,249369,MemoryInfo,1,node.wasm_web_api.WasmStreamingObject.MemoryInfo,void node.wasm_web_api.WasmStreamingObject.MemoryInfo (MemoryTracker*),node_wasm_web_api.cc,"void WasmStreamingObject::MemoryInfo(MemoryTracker* tracker) const {
  // v8::WasmStreaming is opaque. We assume that the size of the WebAssembly
  // module that is being compiled is roughly what V8 allocates (as in, off by
  // only a small factor).
  tracker->TrackFieldWithSize(""streaming"", wasm_size_);
}",52.0,57.0,1.0,1.0,6.0,1,1,2,2,0,0,1,1,0,0,,0,0,2,1,1,void
4634,249380,Create,1,node.wasm_web_api.WasmStreamingObject.Create,"MaybeLocal<Object> node.wasm_web_api.WasmStreamingObject.Create (Environment*,ANY)",node_wasm_web_api.cc,"MaybeLocal<Object> WasmStreamingObject::Create(
    Environment* env, std::shared_ptr<WasmStreaming> streaming) {
  Local<Function> ctor = Initialize(env);
  Local<Object> obj;
  if (!ctor->NewInstance(env->context(), 0, nullptr).ToLocal(&obj)) {
    return MaybeLocal<Object>();
  }

  CHECK(streaming);

  WasmStreamingObject* ptr = Unwrap<WasmStreamingObject>(obj);
  CHECK_NOT_NULL(ptr);
  ptr->streaming_ = streaming;
  ptr->wasm_size_ = 0;
  return obj;
}",59.0,74.0,1.0,1.0,16.0,17,7,20,10,0,0,2,2,0,0,,0,0,4,2,2,MaybeLocal<Object>
4635,249443,New,1,node.wasm_web_api.WasmStreamingObject.New,void node.wasm_web_api.WasmStreamingObject.New (FunctionCallbackInfo<Value>),node_wasm_web_api.cc,"void WasmStreamingObject::New(const FunctionCallbackInfo<Value>& args) {
  CHECK(args.IsConstructCall());
  Environment* env = Environment::GetCurrent(args);
  new WasmStreamingObject(env, args.This());
}",76.0,80.0,1.0,1.0,5.0,5,3,7,4,0,0,1,1,0,0,,0,0,2,1,1,void
4636,249468,SetURL,1,node.wasm_web_api.WasmStreamingObject.SetURL,void node.wasm_web_api.WasmStreamingObject.SetURL (FunctionCallbackInfo<Value>),node_wasm_web_api.cc,"void WasmStreamingObject::SetURL(const FunctionCallbackInfo<Value>& args) {
  WasmStreamingObject* obj;
  ASSIGN_OR_RETURN_UNWRAP(&obj, args.Holder());
  CHECK(obj->streaming_);

  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsString());
  Utf8Value url(Environment::GetCurrent(args)->isolate(), args[0]);
  obj->streaming_->SetUrl(url.out(), url.length());
}",82.0,91.0,1.0,1.0,10.0,13,4,11,4,0,0,1,1,0,0,,0,0,2,1,1,void
4637,249525,Push,1,node.wasm_web_api.WasmStreamingObject.Push,void node.wasm_web_api.WasmStreamingObject.Push (FunctionCallbackInfo<Value>),node_wasm_web_api.cc,"void WasmStreamingObject::Push(const FunctionCallbackInfo<Value>& args) {
  WasmStreamingObject* obj;
  ASSIGN_OR_RETURN_UNWRAP(&obj, args.Holder());
  CHECK(obj->streaming_);

  CHECK_EQ(args.Length(), 1);
  Local<Value> chunk = args[0];

  // The start of the memory section backing the ArrayBuffer(View), the offset
  // of the ArrayBuffer(View) within the memory section, and its size in bytes.
  const void* bytes;
  size_t offset;
  size_t size;

  if (LIKELY(chunk->IsArrayBufferView())) {
    Local<ArrayBufferView> view = chunk.As<ArrayBufferView>();
    bytes = view->Buffer()->Data();
    offset = view->ByteOffset();
    size = view->ByteLength();
  } else if (LIKELY(chunk->IsArrayBuffer())) {
    Local<ArrayBuffer> buffer = chunk.As<ArrayBuffer>();
    bytes = buffer->Data();
    offset = 0;
    size = buffer->ByteLength();
  } else {
    return node::THROW_ERR_INVALID_ARG_TYPE(
        Environment::GetCurrent(args),
        ""chunk must be an ArrayBufferView or an ArrayBuffer"")...",93.0,127.0,1.0,1.0,35.0,26,10,25,10,0,0,2,2,0,0,,0,0,2,1,1,void
4638,249662,Finish,1,node.wasm_web_api.WasmStreamingObject.Finish,void node.wasm_web_api.WasmStreamingObject.Finish (FunctionCallbackInfo<Value>),node_wasm_web_api.cc,"void WasmStreamingObject::Finish(const FunctionCallbackInfo<Value>& args) {
  WasmStreamingObject* obj;
  ASSIGN_OR_RETURN_UNWRAP(&obj, args.Holder());
  CHECK(obj->streaming_);

  CHECK_EQ(args.Length(), 0);
  obj->streaming_->Finish();
}",129.0,136.0,1.0,1.0,8.0,6,3,5,2,0,0,1,1,0,0,,0,0,2,1,1,void
4639,249691,Abort,1,node.wasm_web_api.WasmStreamingObject.Abort,void node.wasm_web_api.WasmStreamingObject.Abort (FunctionCallbackInfo<Value>),node_wasm_web_api.cc,"void WasmStreamingObject::Abort(const FunctionCallbackInfo<Value>& args) {
  WasmStreamingObject* obj;
  ASSIGN_OR_RETURN_UNWRAP(&obj, args.Holder());
  CHECK(obj->streaming_);

  CHECK_EQ(args.Length(), 1);
  obj->streaming_->Abort(args[0]);
}",138.0,145.0,1.0,1.0,8.0,7,4,6,2,0,0,1,1,0,0,,0,0,2,1,1,void
4640,249723,StartStreamingCompilation,1,node.wasm_web_api.StartStreamingCompilation,void node.wasm_web_api.StartStreamingCompilation (FunctionCallbackInfo<Value>),node_wasm_web_api.cc,"void StartStreamingCompilation(const FunctionCallbackInfo<Value>& info) {
  // V8 passes an instance of v8::WasmStreaming to this callback, which we can
  // use to pass the WebAssembly module bytes to V8 as we receive them.
  // Unfortunately, our fetch() implementation is a JavaScript dependency, so it
  // is difficult to implement the required logic here. Instead, we create a
  // a WasmStreamingObject that encapsulates v8::WasmStreaming and that we can
  // pass to the JavaScript implementation. The JavaScript implementation can
  // then push() bytes from the Response and eventually either finish() or
  // abort() the operation.

  // Create the wrapper object.
  std::shared_ptr<WasmStreaming> streaming =
      WasmStreaming::Unpack(info.GetIsolate(), info.Data());
  Environment* env = Environment::GetCurrent(info);
  Local<Object> obj;
  if (!WasmStreamingObject::Create(env, streaming).ToLocal(&obj)) {
    // A JavaScript exception is pending. Let V8 deal with it.
    return;...",147.0,186.0,1.0,1.0,40.0,36,9,38,17,0,0,2,2,0,0,,0,0,2,1,1,void
4641,249842,SetImplementation,1,node.wasm_web_api.SetImplementation,void node.wasm_web_api.SetImplementation (FunctionCallbackInfo<Value>),node_wasm_web_api.cc,"void SetImplementation(const FunctionCallbackInfo<Value>& info) {
  Environment* env = Environment::GetCurrent(info);
  env->set_wasm_streaming_compilation_impl(info[0].As<Function>());
}",189.0,192.0,1.0,1.0,4.0,5,4,5,3,0,0,1,1,0,0,,0,0,2,1,1,void
4642,249865,Initialize,1,node.wasm_web_api.Initialize,"void node.wasm_web_api.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)",node_wasm_web_api.cc,"void Initialize(Local<Object> target,
                Local<Value>,
                Local<Context> context,
                void*) {
  SetMethod(context, target, ""setImplementation"", SetImplementation);
}",194.0,199.0,1.0,1.0,6.0,0,0,2,2,0,0,1,1,0,0,,0,0,8,4,4,void
4643,249878,RegisterExternalReferences,1,node.wasm_web_api.RegisterExternalReferences,void node.wasm_web_api.RegisterExternalReferences (ExternalReferenceRegistry*),node_wasm_web_api.cc,"void RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  registry->Register(SetImplementation);
  registry->Register(StartStreamingCompilation);
  WasmStreamingObject::RegisterExternalReferences(registry);
}",201.0,205.0,1.0,1.0,5.0,3,2,4,2,0,0,1,1,0,0,,0,0,2,1,1,void
4644,249909,<lambda>0,1,node.Watchdog.Watchdog.<lambda>0,ANY node.Watchdog.Watchdog.<lambda>0 (uv_async_t*),node_watchdog.cc,"[](uv_async_t* signal) {
    Watchdog* w = ContainerOf(&Watchdog::async_, signal);
    uv_stop(&w->loop_);
  }",51.0,54.0,39.0,3.0,4.0,5,4,4,3,0,0,1,1,0,0,,0,0,2,1,1,ANY
4645,249930,<lambda>1,1,node.TraceSigintWatchdog.TraceSigintWatchdog.<lambda>1,ANY node.TraceSigintWatchdog.TraceSigintWatchdog.<lambda>1 (uv_async_t*),node_watchdog.cc,"[](uv_async_t* handle) {
    TraceSigintWatchdog* watchdog =
        ContainerOf(&TraceSigintWatchdog::handle_, handle);
    watchdog->signal_flag_ = SignalFlags::FromIdle;
    watchdog->HandleInterrupt();
  }",172.0,177.0,54.0,3.0,6.0,7,4,6,4,0,0,1,1,0,0,,0,0,2,1,1,ANY
4646,249956,<lambda>2,1,node.TraceSigintWatchdog.HandleSigint.<lambda>2,"ANY node.TraceSigintWatchdog.HandleSigint.<lambda>2 (ANY*,void*)",node_watchdog.cc,"[](v8::Isolate* isolate, void* data) {
        TraceSigintWatchdog* self = static_cast<TraceSigintWatchdog*>(data);
        if (self->signal_flag_ == SignalFlags::None) {
          self->signal_flag_ = SignalFlags::FromInterrupt;
        }
        self->HandleInterrupt();
      }",189.0,195.0,7.0,7.0,7.0,9,5,7,3,0,0,2,2,0,0,,0,0,4,2,2,ANY
4647,250009,Watchdog,1,node.Watchdog.Watchdog,"ANY node.Watchdog.Watchdog (ANY*,uint64_t,bool*)",node_watchdog.cc,"Watchdog::Watchdog(v8::Isolate* isolate, uint64_t ms, bool* timed_out)
    : isolate_(isolate), timed_out_(timed_out) {

  int rc;
  rc = uv_loop_init(&loop_);
  if (rc != 0) {
    OnFatalError(""node::Watchdog::Watchdog()"", ""Failed to initialize uv loop."");
  }

  rc = uv_async_init(&loop_, &async_, [](uv_async_t* signal) {
    Watchdog* w = ContainerOf(&Watchdog::async_, signal);
    uv_stop(&w->loop_);
  });

  CHECK_EQ(0, rc);

  rc = uv_timer_init(&loop_, &timer_);
  CHECK_EQ(0, rc);

  rc = uv_timer_start(&timer_, &Watchdog::Timer, ms, 0);
  CHECK_EQ(0, rc);

  rc = uv_thread_create(&thread_, &Watchdog::Run, this);
  CHECK_EQ(0, rc);
}",42.0,66.0,1.0,1.0,25.0,17,4,20,7,0,0,2,2,0,0,,0,0,6,3,3,ANY
4648,250078,~Watchdog,1,node.Watchdog.~Watchdog,ANY node.Watchdog.~Watchdog (),node_watchdog.cc,"Watchdog::~Watchdog() {
  uv_async_send(&async_);
  uv_thread_join(&thread_);

  uv_close(reinterpret_cast<uv_handle_t*>(&async_), nullptr);

  // UV_RUN_DEFAULT so that libuv has a chance to clean up.
  uv_run(&loop_, UV_RUN_DEFAULT);

  CheckedUvLoopClose(&loop_);
}",69.0,79.0,1.0,1.0,11.0,3,2,3,3,0,0,1,1,0,0,,0,0,0,0,0,ANY
4649,250095,Run,1,node.Watchdog.Run,void node.Watchdog.Run (void*),node_watchdog.cc,"void Watchdog::Run(void* arg) {
  Watchdog* wd = static_cast<Watchdog*>(arg);

  // UV_RUN_DEFAULT the loop will be stopped either by the async or the
  // timer handle.
  uv_run(&wd->loop_, UV_RUN_DEFAULT);

  // Loop ref count reaches zero when both handles are closed.
  // Close the timer handle on this side and let ~Watchdog() close async_
  uv_close(reinterpret_cast<uv_handle_t*>(&wd->timer_), nullptr);
}",82.0,92.0,1.0,1.0,11.0,7,4,5,3,0,0,1,1,0,0,,0,0,2,1,1,void
4650,250120,Timer,1,node.Watchdog.Timer,void node.Watchdog.Timer (uv_timer_t*),node_watchdog.cc,"void Watchdog::Timer(uv_timer_t* timer) {
  Watchdog* w = ContainerOf(&Watchdog::timer_, timer);
  *w->timed_out_ = true;
  w->isolate()->TerminateExecution();
  uv_stop(&w->loop_);
}",94.0,99.0,1.0,1.0,6.0,10,5,6,3,0,0,1,1,0,0,,0,0,2,1,1,void
4651,250152,SigintWatchdog,1,node.SigintWatchdog.SigintWatchdog,"ANY node.SigintWatchdog.SigintWatchdog (ANY*,bool*)",node_watchdog.cc,"SigintWatchdog::SigintWatchdog(
  v8::Isolate* isolate, bool* received_signal)
    : isolate_(isolate), received_signal_(received_signal) {
  Mutex::ScopedLock lock(SigintWatchdogHelper::GetInstanceActionMutex());
  // Register this watchdog with the global SIGINT/Ctrl+C listener.
  SigintWatchdogHelper::GetInstance()->Register(this);
  // Start the helper thread, if that has not already happened.
  SigintWatchdogHelper::GetInstance()->Start();
}",102.0,110.0,1.0,1.0,9.0,5,2,3,1,0,0,1,1,0,0,,0,0,4,2,2,ANY
4652,250179,~SigintWatchdog,1,node.SigintWatchdog.~SigintWatchdog,ANY node.SigintWatchdog.~SigintWatchdog (),node_watchdog.cc,"SigintWatchdog::~SigintWatchdog() {
  Mutex::ScopedLock lock(SigintWatchdogHelper::GetInstanceActionMutex());
  SigintWatchdogHelper::GetInstance()->Unregister(this);
  SigintWatchdogHelper::GetInstance()->Stop();
}",113.0,117.0,1.0,1.0,5.0,5,2,3,1,0,0,1,1,0,0,,0,0,0,0,0,ANY
4653,250204,HandleSigint,1,node.SigintWatchdog.HandleSigint,SignalPropagation node.SigintWatchdog.HandleSigint (),node_watchdog.cc,"SignalPropagation SigintWatchdog::HandleSigint() {
  *received_signal_ = true;
  isolate_->TerminateExecution();
  return SignalPropagation::kStopPropagation;
}",119.0,123.0,1.0,1.0,5.0,4,4,3,3,0,0,1,1,0,0,,0,0,0,0,0,SignalPropagation
4654,250220,Init,1,node.TraceSigintWatchdog.Init,"void node.TraceSigintWatchdog.Init (Environment*,Local<Object>)",node_watchdog.cc,"void TraceSigintWatchdog::Init(Environment* env, Local<Object> target) {
  Isolate* isolate = env->isolate();
  Local<FunctionTemplate> constructor = NewFunctionTemplate(isolate, New);
  constructor->InstanceTemplate()->SetInternalFieldCount(
      TraceSigintWatchdog::kInternalFieldCount);
  constructor->Inherit(HandleWrap::GetConstructorTemplate(env));

  SetProtoMethod(isolate, constructor, ""start"", Start);
  SetProtoMethod(isolate, constructor, ""stop"", Stop);

  SetConstructorFunction(
      env->context(), target, ""TraceSigintWatchdog"", constructor);
}",125.0,137.0,1.0,1.0,13.0,11,5,21,11,0,0,1,1,0,0,,0,0,4,2,2,void
4655,250279,New,1,node.TraceSigintWatchdog.New,void node.TraceSigintWatchdog.New (FunctionCallbackInfo<Value>),node_watchdog.cc,"void TraceSigintWatchdog::New(const FunctionCallbackInfo<Value>& args) {
  // This constructor should not be exposed to public javascript.
  // Therefore we assert that we are not trying to call this as a
  // normal function.
  CHECK(args.IsConstructCall());
  Environment* env = Environment::GetCurrent(args);
  new TraceSigintWatchdog(env, args.This());
}",139.0,146.0,1.0,1.0,8.0,5,3,7,4,0,0,1,1,0,0,,0,0,2,1,1,void
4656,250304,Start,1,node.TraceSigintWatchdog.Start,void node.TraceSigintWatchdog.Start (FunctionCallbackInfo<Value>),node_watchdog.cc,"void TraceSigintWatchdog::Start(const FunctionCallbackInfo<Value>& args) {
  TraceSigintWatchdog* watchdog;
  ASSIGN_OR_RETURN_UNWRAP(&watchdog, args.Holder());
  Mutex::ScopedLock lock(SigintWatchdogHelper::GetInstanceActionMutex());
  // Register this watchdog with the global SIGINT/Ctrl+C listener.
  SigintWatchdogHelper::GetInstance()->Register(watchdog);
  // Start the helper thread, if that has not already happened.
  int r = SigintWatchdogHelper::GetInstance()->Start();
  CHECK_EQ(r, 0);
}",148.0,157.0,1.0,1.0,10.0,8,4,8,4,0,0,1,1,0,0,,0,0,2,1,1,void
4657,250344,Stop,1,node.TraceSigintWatchdog.Stop,void node.TraceSigintWatchdog.Stop (FunctionCallbackInfo<Value>),node_watchdog.cc,"void TraceSigintWatchdog::Stop(const FunctionCallbackInfo<Value>& args) {
  TraceSigintWatchdog* watchdog;
  ASSIGN_OR_RETURN_UNWRAP(&watchdog, args.Holder());
  Mutex::ScopedLock lock(SigintWatchdogHelper::GetInstanceActionMutex());
  SigintWatchdogHelper::GetInstance()->Unregister(watchdog);
  SigintWatchdogHelper::GetInstance()->Stop();
}",159.0,165.0,1.0,1.0,7.0,7,3,6,3,0,0,1,1,0,0,,0,0,2,1,1,void
4658,250378,TraceSigintWatchdog,1,node.TraceSigintWatchdog.TraceSigintWatchdog,"ANY node.TraceSigintWatchdog.TraceSigintWatchdog (Environment*,Local<Object>)",node_watchdog.cc,"TraceSigintWatchdog::TraceSigintWatchdog(Environment* env, Local<Object> object)
    : HandleWrap(env,
                 object,
                 reinterpret_cast<uv_handle_t*>(&handle_),
                 AsyncWrap::PROVIDER_SIGINTWATCHDOG) {
  int r = uv_async_init(env->event_loop(), &handle_, [](uv_async_t* handle) {
    TraceSigintWatchdog* watchdog =
        ContainerOf(&TraceSigintWatchdog::handle_, handle);
    watchdog->signal_flag_ = SignalFlags::FromIdle;
    watchdog->HandleInterrupt();
  });
  CHECK_EQ(r, 0);
  uv_unref(reinterpret_cast<uv_handle_t*>(&handle_));
}",167.0,180.0,1.0,1.0,14.0,5,4,5,3,0,0,1,1,0,0,,0,0,4,2,2,ANY
4659,250403,HandleSigint,1,node.TraceSigintWatchdog.HandleSigint,SignalPropagation node.TraceSigintWatchdog.HandleSigint (),node_watchdog.cc,"SignalPropagation TraceSigintWatchdog::HandleSigint() {
  /**
   * In case of uv loop polling, i.e. no JS currently running, activate the
   * loop to run a piece of JS code to trigger interruption.
   */
  CHECK_EQ(uv_async_send(&handle_), 0);
  env()->isolate()->RequestInterrupt(
      [](v8::Isolate* isolate, void* data) {
        TraceSigintWatchdog* self = static_cast<TraceSigintWatchdog*>(data);
        if (self->signal_flag_ == SignalFlags::None) {
          self->signal_flag_ = SignalFlags::FromInterrupt;
        }
        self->HandleInterrupt();
      },
      this);
  return SignalPropagation::kContinuePropagation;
}",182.0,198.0,1.0,1.0,17.0,4,3,2,2,0,0,1,1,0,0,,0,0,0,0,0,SignalPropagation
4660,250425,HandleInterrupt,1,node.TraceSigintWatchdog.HandleInterrupt,void node.TraceSigintWatchdog.HandleInterrupt (),node_watchdog.cc,"void TraceSigintWatchdog::HandleInterrupt() {
  // Do not nest interrupts.
  if (interrupting) {
    return;
  }
  interrupting = true;
  if (signal_flag_ == SignalFlags::None) {
    return;
  }
  Environment* env_ = env();
  // FIXME: Before
  // https://github.com/nodejs/node/pull/29207#issuecomment-527667993 get
  // fixed, additional JavaScript code evaluation shall be prevented from
  // running during interruption.
  FPrintF(stderr,
      ""KEYBOARD_INTERRUPT: Script execution was interrupted by `SIGINT`\n"");
  if (signal_flag_ == SignalFlags::FromInterrupt) {
    PrintStackTrace(env_->isolate(),
                    v8::StackTrace::CurrentStackTrace(
                        env_->isolate(), 10, v8::StackTrace::kDetailed));
  }
  signal_flag_ = SignalFlags::None;
  interrupting = false;

  Mutex::ScopedLock lock(SigintWatchdogHelper::GetInstanceActionMutex());
  SigintWatchdogHelper::GetInstance()->Unregister(this);
  SigintWatchdogHelper::GetInstance()->Stop();
  raise(SIGINT);
}",200.0,228.0,1.0,1.0,29.0,20,4,20,8,0,0,4,4,0,0,,0,0,0,0,0,void
4661,250510,WinCtrlCHandlerRoutine,1,node.SigintWatchdogHelper.WinCtrlCHandlerRoutine,WINAPI node.SigintWatchdogHelper.WinCtrlCHandlerRoutine (DWORD),node_watchdog.cc,"WINAPI SigintWatchdogHelper::WinCtrlCHandlerRoutine(DWORD dwCtrlType) {
  if (!instance.watchdog_disabled_ &&
      (dwCtrlType == CTRL_C_EVENT || dwCtrlType == CTRL_BREAK_EVENT)) {
    InformWatchdogsAboutSignal();

    // Return true because the signal has been handled.
    return TRUE;
  } else {
    return FALSE;
  }
}",253.0,263.0,6.0,1.0,11.0,6,5,6,5,0,0,2,2,0,0,,0,0,2,1,1,WINAPI
4662,250536,InformWatchdogsAboutSignal,1,node.SigintWatchdogHelper.InformWatchdogsAboutSignal,bool node.SigintWatchdogHelper.InformWatchdogsAboutSignal (),node_watchdog.cc,"bool SigintWatchdogHelper::InformWatchdogsAboutSignal() {
  Mutex::ScopedLock list_lock(instance.list_mutex_);

  bool is_stopping = false;
#ifdef __POSIX__
  is_stopping = instance.stopping_;
#endif

  // If there are no listeners and the helper thread has been awoken by a signal
  // (= not when stopping it), indicate that by setting has_pending_signal_.
  if (instance.watchdogs_.empty() && !is_stopping) {
    instance.has_pending_signal_ = true;
  }

  for (auto it = instance.watchdogs_.rbegin(); it != instance.watchdogs_.rend();
       it++) {
    SignalPropagation wp = (*it)->HandleSigint();
    if (wp == SignalPropagation::kStopPropagation) {
      break;
    }
  }

  return is_stopping;
}",267.0,290.0,1.0,1.0,24.0,19,8,14,5,0,0,5,5,0,0,,0,0,0,0,0,bool
4663,250605,Start,1,node.SigintWatchdogHelper.Start,int node.SigintWatchdogHelper.Start (),node_watchdog.cc,"int SigintWatchdogHelper::Start() {
  Mutex::ScopedLock lock(mutex_);

  if (start_stop_count_++ > 0) {
    return 0;
  }

#ifdef __POSIX__
  CHECK_EQ(has_running_thread_, false);
  has_pending_signal_ = false;
  stopping_ = false;

  sigset_t sigmask;
  sigfillset(&sigmask);
  sigset_t savemask;
  CHECK_EQ(0, pthread_sigmask(SIG_SETMASK, &sigmask, &savemask));
  sigmask = savemask;
  int ret = pthread_create(&thread_, nullptr, RunSigintWatchdog, nullptr);
  CHECK_EQ(0, pthread_sigmask(SIG_SETMASK, &sigmask, nullptr));
  if (ret != 0) {
    return ret;
  }
  has_running_thread_ = true;

  RegisterSignalHandler(SIGINT, HandleSignal);
#else
  if (watchdog_disabled_) {
    watchdog_disabled_ = false;
  } else {
    SetConsoleCtrlHandler(WinCtrlCHandlerRoutine, TRUE);
  }
#endif

  return 0;
}",293.0,327.0,1.0,1.0,35.0,3,3,4,3,0,0,3,3,0,0,,0,0,0,0,0,int
4664,250633,Stop,1,node.SigintWatchdogHelper.Stop,bool node.SigintWatchdogHelper.Stop (),node_watchdog.cc,"bool SigintWatchdogHelper::Stop() {
  bool had_pending_signal;
  Mutex::ScopedLock lock(mutex_);

  {
    Mutex::ScopedLock list_lock(list_mutex_);

    had_pending_signal = has_pending_signal_;

    if (--start_stop_count_ > 0) {
      has_pending_signal_ = false;
      return had_pending_signal;
    }

#ifdef __POSIX__
    // Set stopping now because it's only protected by list_mutex_.
    stopping_ = true;
#endif

    watchdogs_.clear();
  }

#ifdef __POSIX__
  if (!has_running_thread_) {
    has_pending_signal_ = false;
    return had_pending_signal;
  }

  // Wake up the helper thread.
  uv_sem_post(&sem_);

  // Wait for the helper thread to finish.
  CHECK_EQ(0, pthread_join(thread_, nullptr));
  has_running_thread_ = false;

  RegisterSignalHandler(SIGINT, SignalExit, true);
#else
  watchdog_disabled_ = true;
#endif

  had_pending_signal = has_pending_signal_;
  has_pending_signal_ = false;

  return had_pending_signal;
}",330.0,374.0,1.0,1.0,45.0,8,4,13,7,0,0,2,2,0,0,,0,0,0,0,0,bool
4665,250674,HasPendingSignal,1,node.SigintWatchdogHelper.HasPendingSignal,bool node.SigintWatchdogHelper.HasPendingSignal (),node_watchdog.cc,"bool SigintWatchdogHelper::HasPendingSignal() {
  Mutex::ScopedLock lock(list_mutex_);

  return has_pending_signal_;
}",377.0,381.0,1.0,1.0,5.0,0,0,2,2,0,0,1,1,0,0,,0,0,0,0,0,bool
4666,250683,Register,1,node.SigintWatchdogHelper.Register,void node.SigintWatchdogHelper.Register (SigintWatchdogBase*),node_watchdog.cc,"void SigintWatchdogHelper::Register(SigintWatchdogBase* wd) {
  Mutex::ScopedLock lock(list_mutex_);

  watchdogs_.push_back(wd);
}",383.0,387.0,1.0,1.0,5.0,1,1,3,3,0,0,1,1,0,0,,0,0,2,1,1,void
4667,250696,Unregister,1,node.SigintWatchdogHelper.Unregister,void node.SigintWatchdogHelper.Unregister (SigintWatchdogBase*),node_watchdog.cc,"void SigintWatchdogHelper::Unregister(SigintWatchdogBase* wd) {
  Mutex::ScopedLock lock(list_mutex_);

  auto it = std::find(watchdogs_.begin(), watchdogs_.end(), wd);

  CHECK_NE(it, watchdogs_.end());
  watchdogs_.erase(it);
}",389.0,396.0,1.0,1.0,8.0,6,2,10,5,0,0,1,1,0,0,,0,0,2,1,1,void
4668,250731,SigintWatchdogHelper,1,node.SigintWatchdogHelper.SigintWatchdogHelper,ANY node.SigintWatchdogHelper.SigintWatchdogHelper (),node_watchdog.cc,"SigintWatchdogHelper::SigintWatchdogHelper()
    : start_stop_count_(0),
      has_pending_signal_(false) {
#ifdef __POSIX__
  has_running_thread_ = false;
  stopping_ = false;
  CHECK_EQ(0, uv_sem_init(&sem_, 0));
#else
  watchdog_disabled_ = false;
#endif
}",399.0,409.0,1.0,1.0,11.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,ANY
4669,250738,~SigintWatchdogHelper,1,node.SigintWatchdogHelper.~SigintWatchdogHelper,ANY node.SigintWatchdogHelper.~SigintWatchdogHelper (),node_watchdog.cc,"SigintWatchdogHelper::~SigintWatchdogHelper() {
  start_stop_count_ = 0;
  Stop();

#ifdef __POSIX__
  CHECK_EQ(has_running_thread_, false);
  uv_sem_destroy(&sem_);
#endif
}",412.0,420.0,1.0,1.0,9.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,ANY
4670,250749,Initialize,1,node.watchdog.Initialize,"void node.watchdog.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)",node_watchdog.cc,"static void Initialize(Local<Object> target,
                       Local<Value> unused,
                       Local<Context> context,
                       void* priv) {
  Environment* env = Environment::GetCurrent(context);
  TraceSigintWatchdog::Init(env, target);
}",426.0,432.0,1.0,1.0,7.0,3,2,6,5,0,0,1,1,0,0,,0,0,8,4,4,void
4671,250792,<lambda>0,1,node.worker.WorkerThreadData.~WorkerThreadData.<lambda>0,ANY node.worker.WorkerThreadData.~WorkerThreadData.<lambda>0 (void*),node_worker.cc,"[](void* data) {
        *static_cast<bool*>(data) = true;
      }",215.0,217.0,58.0,7.0,3.0,3,3,1,1,0,0,1,1,0,0,,0,0,2,1,1,ANY
4672,250805,<lambda>1,1,node.worker.Worker.Run.<lambda>1,ANY node.worker.Worker.Run.<lambda>1 (),node_worker.cc,"[&]() {
      // TODO(addaleax): This call is harmless but should not be necessary.
      // Figure out why V8 is raising a DCHECK() here without it
      // (in test/parallel/test-async-hooks-worker-asyncfn-terminate-4.js).
      isolate_->CancelTerminateExecution();

      if (!env_) return;
      env_->set_can_call_into_js(false);

      {
        Mutex::ScopedLock lock(mutex_);
        stopped_ = true;
        this->env_ = nullptr;
      }

      env_.reset();
    }",291.0,307.0,37.0,5.0,17.0,7,4,6,4,0,0,2,2,0,0,,0,0,0,0,0,ANY
4673,250841,<lambda>2,1,node.worker.Worker.Run.<lambda>2,"ANY node.worker.Worker.Run.<lambda>2 (Environment*,int)",node_worker.cc,"[this](Environment*, int exit_code) {
          Exit(static_cast<ExitCode>(exit_code));
        }",360.0,362.0,43.0,9.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,4,2,2,ANY
4674,250852,<lambda>3,1,node.worker.Worker.New.<lambda>3,ANY node.worker.Worker.New.<lambda>3 (char*),node_worker.cc,"[&env_vars](const char* name) {
      return env_vars->Get(name).FromMaybe("""");
    }",521.0,523.0,49.0,5.0,3.0,2,2,2,2,0,0,1,1,0,0,,0,0,2,1,1,ANY
4675,250869,<lambda>5,1,node.worker.Worker.StartThread..<lambda>5,ANY node.worker.Worker.StartThread..<lambda>5 (Environment*),node_worker.cc,"[w = std::unique_ptr<Worker>(w)](Environment* env) {
          if (w->has_ref_)
            env->add_refs(-1);
          w->JoinThread();
          // implicitly delete w
        }",679.0,684.0,9.0,9.0,6.0,4,2,3,2,0,0,2,2,0,0,,0,0,2,1,1,ANY
4676,250891,<lambda>4,1,node.worker.Worker.StartThread.<lambda>4,ANY node.worker.Worker.StartThread.<lambda>4 (void*),node_worker.cc,"[](void* arg) {
    // XXX: This could become a std::unique_ptr, but that makes at least
    // gcc 6.3 detect undefined behaviour when there shouldn't be any.
    // gcc 7+ handles this well.
    Worker* w = static_cast<Worker*>(arg);
    const uintptr_t stack_top = reinterpret_cast<uintptr_t>(&arg);

    // Leave a few kilobytes just to make sure we're within limits and have
    // some space to do work in C++ land.
    w->stack_base_ = stack_top - (w->stack_size_ - kStackBufferSize);

    w->Run();

    Mutex::ScopedLock lock(w->mutex_);
    w->env()->SetImmediateThreadsafe(
        [w = std::unique_ptr<Worker>(w)](Environment* env) {
          if (w->has_ref_)
            env->add_refs(-1);
          w->JoinThread();
          // implicitly delete w
        });
  }",664.0,685.0,55.0,3.0,22.0,14,5,11,4,0,0,1,1,0,0,,0,0,2,1,1,ANY
4677,250937,<lambda>7,1,node.worker.Worker.TakeHeapSnapshot..<lambda>7,ANY node.worker.Worker.TakeHeapSnapshot..<lambda>7 (Environment*),node_worker.cc,"[taker = std::move(taker),
         snapshot = std::move(snapshot)](Environment* env) mutable {
          HandleScope handle_scope(env->isolate());
          Context::Scope context_scope(env->context());

          AsyncHooks::DefaultTriggerAsyncIdScope trigger_id_scope(taker->get());
          BaseObjectPtr<AsyncWrap> stream =
              heap::CreateHeapSnapshotStream(env, std::move(snapshot));
          Local<Value> args[] = {stream->object()};
          taker->get()->MakeCallback(
              env->ondone_string(), arraysize(args), args);
          // implicitly delete `taker`
        }",829.0,841.0,9.0,9.0,13.0,14,6,16,9,0,0,1,1,0,0,,0,0,2,1,1,ANY
4678,251001,<lambda>6,1,node.worker.Worker.TakeHeapSnapshot.<lambda>6,ANY node.worker.Worker.TakeHeapSnapshot.<lambda>6 (Environment*),node_worker.cc,"[taker = std::move(taker), env, options](
                                           Environment* worker_env) mutable {
    heap::HeapSnapshotPointer snapshot{
        worker_env->isolate()->GetHeapProfiler()->TakeHeapSnapshot(options)};
    CHECK(snapshot);

    // Here, the worker thread temporarily owns the WorkerHeapSnapshotTaker
    // object.

    env->SetImmediateThreadsafe(
        [taker = std::move(taker),
         snapshot = std::move(snapshot)](Environment* env) mutable {
          HandleScope handle_scope(env->isolate());
          Context::Scope context_scope(env->context());

          AsyncHooks::DefaultTriggerAsyncIdScope trigger_id_scope(taker->get());
          BaseObjectPtr<AsyncWrap> stream =
              heap::CreateHeapSnapshotStream(env, std::move(snapshot));
          Local<Value> args[] = {stream->object()};
          taker->get()->MakeCallback(
              env->ondone_string(), arraysize(args), args);
          // implicitly delete `taker`
        },
  ...",819.0,846.0,40.0,3.0,28.0,7,4,6,5,0,0,1,1,0,0,,0,0,2,1,1,ANY
4679,251075,Worker,1,node.worker.Worker.Worker,"ANY node.worker.Worker.Worker (Environment*,Local<Object>,ANY,ANY,ANY,ANY,ANY,SnapshotData*)",node_worker.cc,"Worker::Worker(Environment* env,
               Local<Object> wrap,
               const std::string& url,
               const std::string& name,
               std::shared_ptr<PerIsolateOptions> per_isolate_opts,
               std::vector<std::string>&& exec_argv,
               std::shared_ptr<KVStore> env_vars,
               const SnapshotData* snapshot_data)
    : AsyncWrap(env, wrap, AsyncWrap::PROVIDER_WORKER),
      per_isolate_opts_(per_isolate_opts),
      exec_argv_(exec_argv),
      platform_(env->isolate_data()->platform()),
      thread_id_(AllocateEnvironmentThreadId()),
      name_(name),
      env_vars_(env_vars),
      snapshot_data_(snapshot_data) {
  Debug(this, ""Creating new worker instance with thread id %llu"",
        thread_id_.id);

  // Set up everything that needs to be set up in the parent environment.
  MessagePort* parent_port = MessagePort::New(env, env->context());
  if (parent_port == nullptr) {
    // This can happen e.g. because execution is term...",50.0,96.0,1.0,1.0,47.0,32,9,28,12,0,0,2,2,0,0,,0,0,16,8,8,ANY
4680,251206,is_stopped,1,node.worker.Worker.is_stopped,bool node.worker.Worker.is_stopped (),node_worker.cc,"bool Worker::is_stopped() const {
  Mutex::ScopedLock lock(mutex_);
  if (env_ != nullptr)
    return env_->is_stopping();
  return stopped_;
}",98.0,103.0,1.0,1.0,6.0,2,2,4,3,0,0,2,2,0,0,,0,0,0,0,0,bool
4681,251225,UpdateResourceConstraints,1,node.worker.Worker.UpdateResourceConstraints,void node.worker.Worker.UpdateResourceConstraints (ResourceConstraints*),node_worker.cc,"void Worker::UpdateResourceConstraints(ResourceConstraints* constraints) {
  constraints->set_stack_limit(reinterpret_cast<uint32_t*>(stack_base_));

  if (resource_limits_[kMaxYoungGenerationSizeMb] > 0) {
    constraints->set_max_young_generation_size_in_bytes(
        static_cast<size_t>(resource_limits_[kMaxYoungGenerationSizeMb] * kMB));
  } else {
    resource_limits_[kMaxYoungGenerationSizeMb] =
        constraints->max_young_generation_size_in_bytes() / kMB;
  }

  if (resource_limits_[kMaxOldGenerationSizeMb] > 0) {
    constraints->set_max_old_generation_size_in_bytes(
        static_cast<size_t>(resource_limits_[kMaxOldGenerationSizeMb] * kMB));
  } else {
    resource_limits_[kMaxOldGenerationSizeMb] =
        constraints->max_old_generation_size_in_bytes() / kMB;
  }

  if (resource_limits_[kCodeRangeSizeMb] > 0) {
    constraints->set_code_range_size_in_bytes(
        static_cast<size_t>(resource_limits_[kCodeRangeSizeMb] * kMB));
  } else {
    resource_limits_[kCodeR...",105.0,131.0,1.0,1.0,27.0,20,5,20,7,0,0,4,4,0,0,,0,0,2,1,1,void
4682,251327,WorkerThreadData,1,node.worker.WorkerThreadData.WorkerThreadData,ANY node.worker.WorkerThreadData.WorkerThreadData (Worker*),node_worker.cc,"explicit WorkerThreadData(Worker* w)
    : w_(w) {
    int ret = uv_loop_init(&loop_);
    if (ret != 0) {
      char err_buf[128];
      uv_err_name_r(ret, err_buf, sizeof(err_buf));
      // TODO(joyeecheung): maybe this should be kBootstrapFailure instead?
      w->Exit(ExitCode::kGenericUserError, ""ERR_WORKER_INIT_FAILED"", err_buf);
      return;
    }
    loop_init_failed_ = false;
    uv_loop_configure(&loop_, UV_METRICS_IDLE_TIME);

    std::shared_ptr<ArrayBufferAllocator> allocator =
        ArrayBufferAllocator::Create();
    Isolate::CreateParams params;
    SetIsolateCreateParamsForNode(&params);
    w->UpdateResourceConstraints(&params.constraints);
    params.array_buffer_allocator_shared = allocator;
    Isolate* isolate =
        NewIsolate(&params, &loop_, w->platform_, w->snapshot_data());
    if (isolate == nullptr) {
      // TODO(joyeecheung): maybe this should be kBootstrapFailure instead?
      w->Exit(ExitCode::kGenericUserError,
              ""ERR_WORKER_INI...",138.0,198.0,3.0,3.0,61.0,47,7,54,15,0,16,4,4,1,0,,0,16,2,1,1,ANY
4683,251515,~WorkerThreadData,1,node.worker.WorkerThreadData.~WorkerThreadData,ANY node.worker.WorkerThreadData.~WorkerThreadData (),node_worker.cc,"~WorkerThreadData() {
    Debug(w_, ""Worker %llu dispose isolate"", w_->thread_id_.id);
    Isolate* isolate;
    {
      Mutex::ScopedLock lock(w_->mutex_);
      isolate = w_->isolate_;
      w_->isolate_ = nullptr;
    }

    if (isolate != nullptr) {
      CHECK(!loop_init_failed_);
      bool platform_finished = false;

      isolate_data_.reset();

      w_->platform_->AddIsolateFinishedCallback(isolate, [](void* data) {
        *static_cast<bool*>(data) = true;
      }, &platform_finished);

      // The order of these calls is important; if the Isolate is first disposed
      // and then unregistered, there is a race condition window in which no
      // new Isolate at the same address can successfully be registered with
      // the platform.
      // (Refs: https://github.com/nodejs/node/issues/30846)
      w_->platform_->UnregisterIsolate(isolate);
      isolate->Dispose();

      // Wait until the platform has cleaned up all relevant resources.
      while (!platform_fini...",200.0,235.0,3.0,3.0,36.0,21,6,21,7,0,12,4,5,1,0,,0,12,0,0,0,ANY
4684,251596,loop_is_usable,1,node.worker.WorkerThreadData.loop_is_usable,bool node.worker.WorkerThreadData.loop_is_usable (),node_worker.cc,bool loop_is_usable() const { return !loop_init_failed_; },237.0,237.0,3.0,60.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,bool
4685,251619,NearHeapLimit,1,node.worker.Worker.NearHeapLimit,"size_t node.worker.Worker.NearHeapLimit (void*,size_t,size_t)",node_worker.cc,"size_t Worker::NearHeapLimit(void* data, size_t current_heap_limit,
                             size_t initial_heap_limit) {
  Worker* worker = static_cast<Worker*>(data);
  // Give the current GC some extra leeway to let it finish rather than
  // crash hard. We are not going to perform further allocations anyway.
  constexpr size_t kExtraHeapAllowance = 16 * 1024 * 1024;
  size_t new_limit = current_heap_limit + kExtraHeapAllowance;
  Environment* env = worker->env();
  if (env != nullptr) {
    DCHECK(!env->is_in_heapsnapshot_heap_limit_callback());
    Debug(env,
          DebugCategory::DIAGNOSTICS,
          ""Throwing ERR_WORKER_OUT_OF_MEMORY, ""
          ""new_limit=%"" PRIu64 ""\n"",
          static_cast<uint64_t>(new_limit));
  }
  // TODO(joyeecheung): maybe this should be kV8FatalError instead?
  worker->Exit(ExitCode::kGenericUserError,
               ""ERR_WORKER_OUT_OF_MEMORY"",
               ""JS heap out of memory"");
  return new_limit;
}",248.0,269.0,1.0,1.0,22.0,14,8,13,7,0,0,2,2,0,0,,0,0,6,3,3,size_t
4686,251676,Run,1,node.worker.Worker.Run,void node.worker.Worker.Run (),node_worker.cc,"void Worker::Run() {
  std::string trace_name = ""[worker "" + std::to_string(thread_id_.id) + ""]"" +
                           (name_ == """" ? """" : "" "" + name_);
  TRACE_EVENT_METADATA1(
      ""__metadata"", ""thread_name"", ""name"", TRACE_STR_COPY(trace_name.c_str()));
  CHECK_NOT_NULL(platform_);

  Debug(this, ""Creating isolate for worker with id %llu"", thread_id_.id);

  WorkerThreadData data(this);
  if (isolate_ == nullptr) return;
  CHECK(data.loop_is_usable());

  Debug(this, ""Starting worker with id %llu"", thread_id_.id);
  {
    Locker locker(isolate_);
    Isolate::Scope isolate_scope(isolate_);
    SealHandleScope outer_seal(isolate_);

    DeleteFnPtr<Environment, FreeEnvironment> env_;
    auto cleanup_env = OnScopeLeave([&]() {
      // TODO(addaleax): This call is harmless but should not be necessary.
      // Figure out why V8 is raising a DCHECK() here without it
      // (in test/parallel/test-async-hooks-worker-asyncfn-terminate-4.js).
      isolate_->CancelTerminateEx...",271.0,399.0,1.0,1.0,129.0,72,14,73,27,0,1,13,14,0,0,,0,1,0,0,0,void
4687,252023,CreateEnvMessagePort,1,node.worker.Worker.CreateEnvMessagePort,bool node.worker.Worker.CreateEnvMessagePort (Environment*),node_worker.cc,"bool Worker::CreateEnvMessagePort(Environment* env) {
  HandleScope handle_scope(isolate_);
  std::unique_ptr<MessagePortData> data;
  {
    Mutex::ScopedLock lock(mutex_);
    data = std::move(child_port_data_);
  }

  // Set up the message channel for receiving messages in the child.
  MessagePort* child_port = MessagePort::New(env,
                                             env->context(),
                                             std::move(data));
  // MessagePort::New() may return nullptr if execution is terminated
  // within it.
  if (child_port != nullptr)
    env->set_message_port(child_port->object(isolate_));

  return child_port;
}",401.0,419.0,1.0,1.0,19.0,12,6,19,9,0,0,2,2,0,0,,0,0,2,1,1,bool
4688,252082,JoinThread,1,node.worker.Worker.JoinThread,void node.worker.Worker.JoinThread (),node_worker.cc,"void Worker::JoinThread() {
  if (!tid_.has_value())
    return;
  CHECK_EQ(uv_thread_join(&tid_.value()), 0);
  tid_.reset();

  env()->remove_sub_worker_context(this);

  {
    HandleScope handle_scope(env()->isolate());
    Context::Scope context_scope(env()->context());

    // Reset the parent port as we're closing it now anyway.
    object()->Set(env()->context(),
                  env()->message_port_string(),
                  Undefined(env()->isolate())).Check();

    Local<Value> args[] = {
        Integer::New(env()->isolate(), static_cast<int>(exit_code_)),
        custom_error_ != nullptr
            ? OneByteString(env()->isolate(), custom_error_).As<Value>()
            : Null(env()->isolate()).As<Value>(),
        !custom_error_str_.empty()
            ? OneByteString(env()->isolate(), custom_error_str_.c_str())
                  .As<Value>()
            : Null(env()->isolate()).As<Value>(),
    };

    MakeCallback(env()->onexit_string(), arraysize(args), args);
  }...",421.0,456.0,1.0,1.0,36.0,33,9,12,6,0,0,2,2,0,0,,0,0,0,0,0,void
4689,252214,~Worker,1,node.worker.Worker.~Worker,ANY node.worker.Worker.~Worker (),node_worker.cc,"Worker::~Worker() {
  Mutex::ScopedLock lock(mutex_);

  CHECK(stopped_);
  CHECK_NULL(env_);
  CHECK(!tid_.has_value());

  Debug(this, ""Worker %llu destroyed"", thread_id_.id);
}",458.0,466.0,1.0,1.0,9.0,3,2,3,3,0,0,1,1,0,0,,0,0,0,0,0,ANY
4690,252235,New,1,node.worker.Worker.New,void node.worker.Worker.New (FunctionCallbackInfo<Value>),node_worker.cc,"void Worker::New(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  auto is_internal = args[5];
  CHECK(is_internal->IsBoolean());
  if (is_internal->IsFalse()) {
    THROW_IF_INSUFFICIENT_PERMISSIONS(
        env, permission::PermissionScope::kWorkerThreads, """");
  }
  Isolate* isolate = args.GetIsolate();

  CHECK(args.IsConstructCall());

  if (env->isolate_data()->platform() == nullptr) {
    THROW_ERR_MISSING_PLATFORM_FOR_WORKER(env);
    return;
  }

  std::string url;
  std::string name;
  std::shared_ptr<PerIsolateOptions> per_isolate_opts = nullptr;
  std::shared_ptr<KVStore> env_vars = nullptr;

  std::vector<std::string> exec_argv_out;

  // Argument might be a string or URL
  if (!args[0]->IsNullOrUndefined()) {
    Utf8Value value(
        isolate, args[0]->ToString(env->context()).FromMaybe(Local<String>()));
    url.append(value.out(), value.length());
  }

  if (!args[6]->IsNullOrUndefined()) {
    Utf8Value value(
      ...",468.0,638.0,1.0,1.0,171.0,222,16,197,47,0,0,21,35,0,0,,0,0,2,1,1,void
4691,253025,StartThread,1,node.worker.Worker.StartThread,void node.worker.Worker.StartThread (FunctionCallbackInfo<Value>),node_worker.cc,"void Worker::StartThread(const FunctionCallbackInfo<Value>& args) {
  Worker* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.This());
  Mutex::ScopedLock lock(w->mutex_);

  w->stopped_ = false;

  if (w->resource_limits_[kStackSizeMb] > 0) {
    if (w->resource_limits_[kStackSizeMb] * kMB < kStackBufferSize) {
      w->resource_limits_[kStackSizeMb] = kStackBufferSize / kMB;
      w->stack_size_ = kStackBufferSize;
    } else {
      w->stack_size_ =
          static_cast<size_t>(w->resource_limits_[kStackSizeMb] * kMB);
    }
  } else {
    w->resource_limits_[kStackSizeMb] = w->stack_size_ / kMB;
  }

  uv_thread_options_t thread_options;
  thread_options.flags = UV_THREAD_HAS_STACK_SIZE;
  thread_options.stack_size = w->stack_size_;

  uv_thread_t* tid = &w->tid_.emplace();  // Create uv_thread_t instance
  int ret = uv_thread_create_ex(tid, &thread_options, [](void* arg) {
    // XXX: This could become a std::unique_ptr, but that makes at least
    // gcc 6.3 detect undefined behaviour ...",640.0,708.0,1.0,1.0,69.0,37,11,32,9,0,0,5,7,0,0,,0,0,2,1,1,void
4692,253210,StopThread,1,node.worker.Worker.StopThread,void node.worker.Worker.StopThread (FunctionCallbackInfo<Value>),node_worker.cc,"void Worker::StopThread(const FunctionCallbackInfo<Value>& args) {
  Worker* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.This());

  Debug(w, ""Worker %llu is getting stopped by parent"", w->thread_id_.id);
  w->Exit(ExitCode::kGenericUserError);
}",710.0,716.0,1.0,1.0,7.0,6,3,6,3,0,0,1,1,0,0,,0,0,2,1,1,void
4693,253238,Ref,1,node.worker.Worker.Ref,void node.worker.Worker.Ref (FunctionCallbackInfo<Value>),node_worker.cc,"void Worker::Ref(const FunctionCallbackInfo<Value>& args) {
  Worker* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.This());
  if (!w->has_ref_ && w->tid_.has_value()) {
    w->has_ref_ = true;
    w->env()->add_refs(1);
  }
}",718.0,725.0,1.0,1.0,8.0,11,6,6,2,0,0,2,2,0,0,,0,0,2,1,1,void
4694,253277,HasRef,1,node.worker.Worker.HasRef,void node.worker.Worker.HasRef (FunctionCallbackInfo<Value>),node_worker.cc,"void Worker::HasRef(const FunctionCallbackInfo<Value>& args) {
  Worker* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.This());
  args.GetReturnValue().Set(w->has_ref_);
}",727.0,731.0,1.0,1.0,5.0,5,3,4,2,0,0,1,1,0,0,,0,0,2,1,1,void
4695,253300,Unref,1,node.worker.Worker.Unref,void node.worker.Worker.Unref (FunctionCallbackInfo<Value>),node_worker.cc,"void Worker::Unref(const FunctionCallbackInfo<Value>& args) {
  Worker* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.This());
  if (w->has_ref_ && w->tid_.has_value()) {
    w->has_ref_ = false;
    w->env()->add_refs(-1);
  }
}",733.0,740.0,1.0,1.0,8.0,11,6,6,2,0,0,2,2,0,0,,0,0,2,1,1,void
4696,253339,GetResourceLimits,1,node.worker.Worker.GetResourceLimits,void node.worker.Worker.GetResourceLimits (FunctionCallbackInfo<Value>),node_worker.cc,"Local<Float64Array> Worker::GetResourceLimits(Isolate* isolate) const {
  Local<ArrayBuffer> ab = ArrayBuffer::New(isolate, sizeof(resource_limits_));

  memcpy(ab->Data(), resource_limits_, sizeof(resource_limits_));
  return Float64Array::New(ab, 0, kTotalResourceLimitCount);
}",748.0,753.0,1.0,1.0,6.0,6,3,5,2,0,0,1,1,0,0,,0,0,2,1,1,Local<Float64Array>
4697,253401,Exit,1,node.worker.Worker.Exit,"void node.worker.Worker.Exit (ExitCode,char*,char*)",node_worker.cc,"void Worker::Exit(ExitCode code,
                  const char* error_code,
                  const char* error_message) {
  Mutex::ScopedLock lock(mutex_);
  Debug(this,
        ""Worker %llu called Exit(%d, %s, %s)"",
        thread_id_.id,
        static_cast<int>(code),
        error_code,
        error_message);

  if (error_code != nullptr) {
    custom_error_ = error_code;
    custom_error_str_ = error_message;
  }

  if (env_ != nullptr) {
    exit_code_ = code;
    Stop(env_);
  } else {
    stopped_ = true;
  }
}",755.0,777.0,1.0,1.0,23.0,7,4,13,9,0,0,3,3,0,0,,0,0,6,3,3,void
4698,253447,IsNotIndicativeOfMemoryLeakAtExit,1,node.worker.Worker.IsNotIndicativeOfMemoryLeakAtExit,bool node.worker.Worker.IsNotIndicativeOfMemoryLeakAtExit (),node_worker.cc,"bool Worker::IsNotIndicativeOfMemoryLeakAtExit() const {
  // Worker objects always stay alive as long as the child thread, regardless
  // of whether they are being referenced in the parent thread.
  return true;
}",779.0,783.0,1.0,1.0,5.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,bool
4699,253454,WorkerHeapSnapshotTaker,1,node.worker.WorkerHeapSnapshotTaker.WorkerHeapSnapshotTaker,"ANY node.worker.WorkerHeapSnapshotTaker.WorkerHeapSnapshotTaker (Environment*,Local<Object>)",node_worker.cc,"WorkerHeapSnapshotTaker(Environment* env, Local<Object> obj)
    : AsyncWrap(env, obj, AsyncWrap::PROVIDER_WORKERHEAPSNAPSHOT) {}",787.0,788.0,3.0,68.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,ANY
4700,253461,TakeHeapSnapshot,1,node.worker.Worker.TakeHeapSnapshot,void node.worker.Worker.TakeHeapSnapshot (FunctionCallbackInfo<Value>),node_worker.cc,"void Worker::TakeHeapSnapshot(const FunctionCallbackInfo<Value>& args) {
  Worker* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.This());
  CHECK_EQ(args.Length(), 1);
  auto options = heap::GetHeapSnapshotOptions(args[0]);

  Debug(w, ""Worker %llu taking heap snapshot"", w->thread_id_.id);

  Environment* env = w->env();
  AsyncHooks::DefaultTriggerAsyncIdScope trigger_id_scope(w);
  Local<Object> wrap;
  if (!env->worker_heap_snapshot_taker_template()
      ->NewInstance(env->context()).ToLocal(&wrap)) {
    return;
  }

  // The created WorkerHeapSnapshotTaker is an object owned by main
  // thread's Isolate, it can not be accessed by worker thread
  std::unique_ptr<BaseObjectPtr<WorkerHeapSnapshotTaker>> taker =
      std::make_unique<BaseObjectPtr<WorkerHeapSnapshotTaker>>(
          MakeDetachedBaseObject<WorkerHeapSnapshotTaker>(env, wrap));

  // Interrupt the worker thread and take a snapshot, then schedule a call
  // on the parent thread that turns that snapshot into a readable st...",795.0,853.0,1.0,1.0,59.0,35,11,33,14,0,0,3,3,0,0,,0,0,2,1,1,void
4701,253586,LoopIdleTime,1,node.worker.Worker.LoopIdleTime,void node.worker.Worker.LoopIdleTime (FunctionCallbackInfo<Value>),node_worker.cc,"void Worker::LoopIdleTime(const FunctionCallbackInfo<Value>& args) {
  Worker* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.This());

  Mutex::ScopedLock lock(w->mutex_);
  // Using w->is_stopped() here leads to a deadlock, and checking is_stopped()
  // before locking the mutex is a race condition. So manually do the same
  // check.
  if (w->stopped_ || w->env_ == nullptr)
    return args.GetReturnValue().Set(-1);

  uint64_t idle_time = uv_metrics_idle_time(w->env_->event_loop());
  args.GetReturnValue().Set(1.0 * idle_time / 1e6);
}",855.0,868.0,1.0,1.0,14.0,17,9,10,3,0,0,2,2,0,0,,0,0,2,1,1,void
4702,253647,LoopStartTime,1,node.worker.Worker.LoopStartTime,void node.worker.Worker.LoopStartTime (FunctionCallbackInfo<Value>),node_worker.cc,"void Worker::LoopStartTime(const FunctionCallbackInfo<Value>& args) {
  Worker* w;
  ASSIGN_OR_RETURN_UNWRAP(&w, args.This());

  Mutex::ScopedLock lock(w->mutex_);
  // Using w->is_stopped() here leads to a deadlock, and checking is_stopped()
  // before locking the mutex is a race condition. So manually do the same
  // check.
  if (w->stopped_ || w->env_ == nullptr)
    return args.GetReturnValue().Set(-1);

  double loop_start_time = w->env_->performance_state()->milestones[
      node::performance::NODE_PERFORMANCE_MILESTONE_LOOP_START];
  CHECK_GE(loop_start_time, 0);
  args.GetReturnValue().Set(loop_start_time / 1e6);
}",870.0,885.0,1.0,1.0,16.0,20,9,13,5,0,0,2,2,0,0,,0,0,2,1,1,void
4703,253717,GetEnvMessagePort,1,node.worker.anonymous_namespace_1.GetEnvMessagePort,void node.worker.anonymous_namespace_1.GetEnvMessagePort (FunctionCallbackInfo<Value>),node_worker.cc,"void GetEnvMessagePort(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Local<Object> port = env->message_port();
  CHECK_IMPLIES(!env->is_main_thread(), !port.IsEmpty());
  if (!port.IsEmpty()) {
    CHECK_EQ(port->GetCreationContext().ToLocalChecked()->GetIsolate(),
             args.GetIsolate());
    args.GetReturnValue().Set(port);
  }
}",891.0,900.0,1.0,1.0,10.0,18,6,14,6,0,0,2,2,0,0,,0,0,2,1,1,void
4704,253781,CreateWorkerPerIsolateProperties,1,node.worker.anonymous_namespace_2.CreateWorkerPerIsolateProperties,"void node.worker.anonymous_namespace_2.CreateWorkerPerIsolateProperties (IsolateData*,Local<FunctionTemplate>)",node_worker.cc,"void CreateWorkerPerIsolateProperties(IsolateData* isolate_data,
                                      Local<FunctionTemplate> target) {
  Isolate* isolate = isolate_data->isolate();
  Local<ObjectTemplate> proto = target->PrototypeTemplate();

  {
    Local<FunctionTemplate> w = NewFunctionTemplate(isolate, Worker::New);

    w->InstanceTemplate()->SetInternalFieldCount(
        Worker::kInternalFieldCount);
    w->Inherit(AsyncWrap::GetConstructorTemplate(isolate_data));

    SetProtoMethod(isolate, w, ""startThread"", Worker::StartThread);
    SetProtoMethod(isolate, w, ""stopThread"", Worker::StopThread);
    SetProtoMethod(isolate, w, ""hasRef"", Worker::HasRef);
    SetProtoMethod(isolate, w, ""ref"", Worker::Ref);
    SetProtoMethod(isolate, w, ""unref"", Worker::Unref);
    SetProtoMethod(isolate, w, ""getResourceLimits"", Worker::GetResourceLimits);
    SetProtoMethod(isolate, w, ""takeHeapSnapshot"", Worker::TakeHeapSnapshot);
    SetProtoMethod(isolate, w, ""loopIdleTime"", Worker::LoopI...",902.0,942.0,1.0,1.0,41.0,38,5,65,14,0,0,1,1,0,0,,0,0,4,2,2,void
4705,253959,CreateWorkerPerContextProperties,1,node.worker.anonymous_namespace_4.CreateWorkerPerContextProperties,"void node.worker.anonymous_namespace_4.CreateWorkerPerContextProperties (Local<Object>,Local<Value>,Local<Context>,void*)",node_worker.cc,"void CreateWorkerPerContextProperties(Local<Object> target,
                                      Local<Value> unused,
                                      Local<Context> context,
                                      void* priv) {
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  target
      ->Set(env->context(),
            env->thread_id_string(),
            Number::New(isolate, static_cast<double>(env->thread_id())))
      .Check();

  target
      ->Set(env->context(),
            FIXED_ONE_BYTE_STRING(isolate, ""isMainThread""),
            Boolean::New(isolate, env->is_main_thread()))
      .Check();

  target
      ->Set(env->context(),
            FIXED_ONE_BYTE_STRING(isolate, ""ownsProcessState""),
            Boolean::New(isolate, env->owns_process_state()))
      .Check();

  if (!env->is_main_thread()) {
    target
        ->Set(env->context(),
              FIXED_ONE_BYTE_STRING(isolate, ""resourceLimits""),
              env-...",944.0,982.0,1.0,2.0,39.0,193,8,184,20,0,0,2,2,0,0,,0,0,8,4,4,void
4706,254578,RegisterExternalReferences,1,node.worker.anonymous_namespace_5.RegisterExternalReferences,void node.worker.anonymous_namespace_5.RegisterExternalReferences (ExternalReferenceRegistry*),node_worker.cc,"void RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  registry->Register(GetEnvMessagePort);
  registry->Register(Worker::New);
  registry->Register(Worker::StartThread);
  registry->Register(Worker::StopThread);
  registry->Register(Worker::HasRef);
  registry->Register(Worker::Ref);
  registry->Register(Worker::Unref);
  registry->Register(Worker::GetResourceLimits);
  registry->Register(Worker::TakeHeapSnapshot);
  registry->Register(Worker::LoopIdleTime);
  registry->Register(Worker::LoopStartTime);
}",984.0,996.0,1.0,1.0,13.0,21,2,21,2,0,0,1,1,0,0,,0,0,2,1,1,void
4707,254675,<lambda>0,1,node.anonymous_namespace_73.CompressionStream.AfterThreadPoolWork.<lambda>0,ANY node.anonymous_namespace_73.CompressionStream.AfterThreadPoolWork.<lambda>0 (),node_zlib.cc,[&]() { Unref(); },405.0,405.0,40.0,57.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
4708,254722,ZlibStrerror,1,node.anonymous_namespace_1.ZlibStrerror,const char* node.anonymous_namespace_1.ZlibStrerror (int),node_zlib.cc,"inline const char* ZlibStrerror(int err) {
#define V(code) if (err == code) return #code;
  ZLIB_ERROR_CODES(V)
#undef V
  return ""Z_UNKNOWN_ERROR"";
}",90.0,95.0,1.0,2.0,6.0,9,1,18,10,0,0,9,9,0,0,,0,0,2,1,1,const char*
4709,254814,CompressionError,1,node.anonymous_namespace_4.CompressionError.CompressionError,"ANY node.anonymous_namespace_4.CompressionError.CompressionError (char*,char*,int)",node_zlib.cc,"CompressionError(const char* message, const char* code, int err)
      : message(message),
        code(code),
        err(err) {
    CHECK_NOT_NULL(message);
  }",114.0,119.0,3.0,3.0,6.0,0,0,1,1,0,0,1,1,0,0,,0,0,6,3,3,ANY
4710,254823,CompressionError,1,node.anonymous_namespace_5.CompressionError.CompressionError,ANY node.anonymous_namespace_5.CompressionError.CompressionError (),node_zlib.cc,CompressionError() = default;,121.0,121.0,3.0,31.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
4711,254830,IsError,1,node.anonymous_namespace_6.CompressionError.IsError,bool node.anonymous_namespace_6.CompressionError.IsError (),node_zlib.cc,inline bool IsError() const { return code != nullptr; },127.0,127.0,3.0,57.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,bool
4712,254852,ZlibContext,1,node.anonymous_namespace_8.ZlibContext.ZlibContext,ANY node.anonymous_namespace_8.ZlibContext.ZlibContext (),node_zlib.cc,ZlibContext() = default;,132.0,132.0,3.0,26.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
4713,254856,Close,1,node.anonymous_namespace_9.ZlibContext.Close,void node.anonymous_namespace_9.ZlibContext.Close (),node_zlib.cc,void Close();,135.0,135.0,8.0,14.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
4714,254860,DoThreadPoolWork,1,node.anonymous_namespace_10.ZlibContext.DoThreadPoolWork,void node.anonymous_namespace_10.ZlibContext.DoThreadPoolWork (),node_zlib.cc,void DoThreadPoolWork();,136.0,136.0,8.0,25.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
4715,254864,SetBuffers,1,node.anonymous_namespace_11.ZlibContext.SetBuffers,"void node.anonymous_namespace_11.ZlibContext.SetBuffers (char*,uint32_t,char*,uint32_t)",node_zlib.cc,"void SetBuffers(const char* in, uint32_t in_len, char* out, uint32_t out_len);",137.0,137.0,8.0,79.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,void
4716,254872,SetFlush,1,node.anonymous_namespace_12.ZlibContext.SetFlush,void node.anonymous_namespace_12.ZlibContext.SetFlush (int),node_zlib.cc,void SetFlush(int flush);,138.0,138.0,8.0,26.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
4717,254877,GetAfterWriteOffsets,1,node.anonymous_namespace_13.ZlibContext.GetAfterWriteOffsets,"void node.anonymous_namespace_13.ZlibContext.GetAfterWriteOffsets (uint32_t*,uint32_t*)",node_zlib.cc,"void GetAfterWriteOffsets(uint32_t* avail_in, uint32_t* avail_out) const;",139.0,139.0,8.0,74.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
4718,254883,GetErrorInfo,1,node.anonymous_namespace_14.ZlibContext.GetErrorInfo,CompressionError node.anonymous_namespace_14.ZlibContext.GetErrorInfo (),node_zlib.cc,CompressionError GetErrorInfo() const;,140.0,140.0,20.0,39.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,CompressionError
4719,254887,SetMode,1,node.anonymous_namespace_15.ZlibContext.SetMode,void node.anonymous_namespace_15.ZlibContext.SetMode (node_zlib_mode),node_zlib.cc,inline void SetMode(node_zlib_mode mode) { mode_ = mode; },141.0,141.0,3.0,60.0,1.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
4720,254895,ResetStream,1,node.anonymous_namespace_16.ZlibContext.ResetStream,CompressionError node.anonymous_namespace_16.ZlibContext.ResetStream (),node_zlib.cc,CompressionError ResetStream();,142.0,142.0,20.0,32.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,CompressionError
4721,254899,Init,1,node.anonymous_namespace_17.ZlibContext.Init,"void node.anonymous_namespace_17.ZlibContext.Init (int,int,int,int,ANY)",node_zlib.cc,"void Init(int level, int window_bits, int mem_level, int strategy,
            std::vector<unsigned char>&& dictionary);",145.0,146.0,8.0,52.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,10,5,5,void
4722,254908,SetAllocationFunctions,1,node.anonymous_namespace_18.ZlibContext.SetAllocationFunctions,"void node.anonymous_namespace_18.ZlibContext.SetAllocationFunctions (alloc_func,free_func,void*)",node_zlib.cc,"void SetAllocationFunctions(alloc_func alloc, free_func free, void* opaque);",147.0,147.0,8.0,77.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,void
4723,254915,SetParams,1,node.anonymous_namespace_19.ZlibContext.SetParams,"CompressionError node.anonymous_namespace_19.ZlibContext.SetParams (int,int)",node_zlib.cc,"CompressionError SetParams(int level, int strategy);",148.0,148.0,20.0,53.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,CompressionError
4724,254925,MemoryInfo,1,node.anonymous_namespace_20.ZlibContext.MemoryInfo,void node.anonymous_namespace_20.ZlibContext.MemoryInfo (MemoryTracker*),node_zlib.cc,"void MemoryInfo(MemoryTracker* tracker) const override {
    tracker->TrackField(""dictionary"", dictionary_);
  }",153.0,155.0,3.0,3.0,3.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
4725,254936,ZlibContext,1,node.anonymous_namespace_21.ZlibContext.ZlibContext,ANY node.anonymous_namespace_21.ZlibContext.ZlibContext (ZlibContext),node_zlib.cc,ZlibContext(const ZlibContext&) = delete;,157.0,157.0,3.0,43.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
4726,254941,operator =,1,node.anonymous_namespace_22.ZlibContext.operator =,ZlibContext node.anonymous_namespace_22.ZlibContext.operator = (ZlibContext),node_zlib.cc,ZlibContext& operator=(const ZlibContext&) = delete;,158.0,158.0,3.0,54.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ZlibContext
4727,254946,ErrorForMessage,1,node.anonymous_namespace_23.ZlibContext.ErrorForMessage,CompressionError node.anonymous_namespace_23.ZlibContext.ErrorForMessage (char*),node_zlib.cc,CompressionError ErrorForMessage(const char* message) const;,161.0,161.0,20.0,61.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,CompressionError
4728,254951,SetDictionary,1,node.anonymous_namespace_24.ZlibContext.SetDictionary,CompressionError node.anonymous_namespace_24.ZlibContext.SetDictionary (),node_zlib.cc,CompressionError SetDictionary();,162.0,162.0,20.0,34.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,CompressionError
4729,254955,InitZlib,1,node.anonymous_namespace_25.ZlibContext.InitZlib,bool node.anonymous_namespace_25.ZlibContext.InitZlib (),node_zlib.cc,bool InitZlib();,163.0,163.0,8.0,17.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,bool
4730,255003,BrotliContext,1,node.anonymous_namespace_27.BrotliContext.BrotliContext,ANY node.anonymous_namespace_27.BrotliContext.BrotliContext (),node_zlib.cc,BrotliContext() = default;,184.0,184.0,3.0,28.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
4731,255007,SetBuffers,1,node.anonymous_namespace_28.BrotliContext.SetBuffers,"void node.anonymous_namespace_28.BrotliContext.SetBuffers (char*,uint32_t,char*,uint32_t)",node_zlib.cc,"void SetBuffers(const char* in, uint32_t in_len, char* out, uint32_t out_len);",186.0,186.0,8.0,79.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,void
4732,255015,SetFlush,1,node.anonymous_namespace_29.BrotliContext.SetFlush,void node.anonymous_namespace_29.BrotliContext.SetFlush (int),node_zlib.cc,void SetFlush(int flush);,187.0,187.0,8.0,26.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
4733,255020,GetAfterWriteOffsets,1,node.anonymous_namespace_30.BrotliContext.GetAfterWriteOffsets,"void node.anonymous_namespace_30.BrotliContext.GetAfterWriteOffsets (uint32_t*,uint32_t*)",node_zlib.cc,"void GetAfterWriteOffsets(uint32_t* avail_in, uint32_t* avail_out) const;",188.0,188.0,8.0,74.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
4734,255026,SetMode,1,node.anonymous_namespace_31.BrotliContext.SetMode,void node.anonymous_namespace_31.BrotliContext.SetMode (node_zlib_mode),node_zlib.cc,inline void SetMode(node_zlib_mode mode) { mode_ = mode; },189.0,189.0,3.0,60.0,1.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
4735,255034,BrotliContext,1,node.anonymous_namespace_32.BrotliContext.BrotliContext,ANY node.anonymous_namespace_32.BrotliContext.BrotliContext (BrotliContext),node_zlib.cc,BrotliContext(const BrotliContext&) = delete;,191.0,191.0,3.0,47.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
4736,255039,operator =,1,node.anonymous_namespace_33.BrotliContext.operator =,BrotliContext node.anonymous_namespace_33.BrotliContext.operator = (BrotliContext),node_zlib.cc,BrotliContext& operator=(const BrotliContext&) = delete;,192.0,192.0,3.0,58.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,BrotliContext
4737,255085,Close,1,node.anonymous_namespace_35.BrotliEncoderContext.Close,void node.anonymous_namespace_35.BrotliEncoderContext.Close (),node_zlib.cc,void Close();,211.0,211.0,8.0,14.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
4738,255089,DoThreadPoolWork,1,node.anonymous_namespace_36.BrotliEncoderContext.DoThreadPoolWork,void node.anonymous_namespace_36.BrotliEncoderContext.DoThreadPoolWork (),node_zlib.cc,void DoThreadPoolWork();,212.0,212.0,8.0,25.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
4739,255093,Init,1,node.anonymous_namespace_37.BrotliEncoderContext.Init,"CompressionError node.anonymous_namespace_37.BrotliEncoderContext.Init (brotli_alloc_func,brotli_free_func,void*)",node_zlib.cc,"CompressionError Init(brotli_alloc_func alloc,
                        brotli_free_func free,
                        void* opaque);",213.0,215.0,20.0,37.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,CompressionError
4740,255100,ResetStream,1,node.anonymous_namespace_38.BrotliEncoderContext.ResetStream,CompressionError node.anonymous_namespace_38.BrotliEncoderContext.ResetStream (),node_zlib.cc,CompressionError ResetStream();,216.0,216.0,20.0,32.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,CompressionError
4741,255104,SetParams,1,node.anonymous_namespace_39.BrotliEncoderContext.SetParams,"CompressionError node.anonymous_namespace_39.BrotliEncoderContext.SetParams (int,uint32_t)",node_zlib.cc,"CompressionError SetParams(int key, uint32_t value);",217.0,217.0,20.0,53.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,CompressionError
4742,255110,GetErrorInfo,1,node.anonymous_namespace_40.BrotliEncoderContext.GetErrorInfo,CompressionError node.anonymous_namespace_40.BrotliEncoderContext.GetErrorInfo (),node_zlib.cc,CompressionError GetErrorInfo() const;,218.0,218.0,20.0,39.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,CompressionError
4743,255121,Close,1,node.anonymous_namespace_42.BrotliDecoderContext.Close,void node.anonymous_namespace_42.BrotliDecoderContext.Close (),node_zlib.cc,void Close();,231.0,231.0,8.0,14.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
4744,255125,DoThreadPoolWork,1,node.anonymous_namespace_43.BrotliDecoderContext.DoThreadPoolWork,void node.anonymous_namespace_43.BrotliDecoderContext.DoThreadPoolWork (),node_zlib.cc,void DoThreadPoolWork();,232.0,232.0,8.0,25.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
4745,255129,Init,1,node.anonymous_namespace_44.BrotliDecoderContext.Init,"CompressionError node.anonymous_namespace_44.BrotliDecoderContext.Init (brotli_alloc_func,brotli_free_func,void*)",node_zlib.cc,"CompressionError Init(brotli_alloc_func alloc,
                        brotli_free_func free,
                        void* opaque);",233.0,235.0,20.0,37.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,CompressionError
4746,255136,ResetStream,1,node.anonymous_namespace_45.BrotliDecoderContext.ResetStream,CompressionError node.anonymous_namespace_45.BrotliDecoderContext.ResetStream (),node_zlib.cc,CompressionError ResetStream();,236.0,236.0,20.0,32.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,CompressionError
4747,255140,SetParams,1,node.anonymous_namespace_46.BrotliDecoderContext.SetParams,"CompressionError node.anonymous_namespace_46.BrotliDecoderContext.SetParams (int,uint32_t)",node_zlib.cc,"CompressionError SetParams(int key, uint32_t value);",237.0,237.0,20.0,53.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,CompressionError
4748,255146,GetErrorInfo,1,node.anonymous_namespace_47.BrotliDecoderContext.GetErrorInfo,CompressionError node.anonymous_namespace_47.BrotliDecoderContext.GetErrorInfo (),node_zlib.cc,CompressionError GetErrorInfo() const;,238.0,238.0,20.0,39.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,CompressionError
4749,255178,CompressionStream,1,node.anonymous_namespace_50.CompressionStream.CompressionStream,"ANY node.anonymous_namespace_50.CompressionStream.CompressionStream (Environment*,Local<Object>)",node_zlib.cc,"CompressionStream(Environment* env, Local<Object> wrap)
      : AsyncWrap(env, wrap, AsyncWrap::PROVIDER_ZLIB),
        ThreadPoolWork(env, ""zlib""),
        write_result_(nullptr) {
    MakeWeak();
  }",260.0,265.0,3.0,3.0,6.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,ANY
4750,255185,~CompressionStream,1,node.anonymous_namespace_51.CompressionStream.~CompressionStream,ANY node.anonymous_namespace_51.CompressionStream.~CompressionStream (),node_zlib.cc,"~CompressionStream() override {
    CHECK(!write_in_progress_);
    Close();
    CHECK_EQ(zlib_memory_, 0);
    CHECK_EQ(unreported_allocations_, 0);
  }",267.0,272.0,3.0,3.0,6.0,1,1,3,3,0,3,1,1,0,0,,0,3,0,0,0,ANY
4751,255199,Close,1,node.anonymous_namespace_53.CompressionStream.Close,void node.anonymous_namespace_53.CompressionStream.Close (),node_zlib.cc,"void Close() {
    if (write_in_progress_) {
      pending_close_ = true;
      return;
    }

    pending_close_ = false;
    closed_ = true;
    CHECK(init_done_ && ""close before init"");

    AllocScope alloc_scope(this);
    ctx_.Close();
  }",274.0,286.0,3.0,3.0,13.0,5,3,6,5,0,6,2,2,1,0,,0,6,0,0,0,void
4752,255227,Close,1,node.anonymous_namespace_54.CompressionStream.Close,void node.anonymous_namespace_54.CompressionStream.Close (FunctionCallbackInfo<Value>),node_zlib.cc,"static void Close(const FunctionCallbackInfo<Value>& args) {
    CompressionStream* ctx;
    ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());
    ctx->Close();
  }",289.0,293.0,3.0,3.0,5.0,3,3,3,2,0,0,1,1,0,0,,0,0,2,1,1,void
4753,255244,Write,1,node.anonymous_namespace_55.CompressionStream.Write,void node.anonymous_namespace_55.CompressionStream.Write<bool> (FunctionCallbackInfo<Value>),node_zlib.cc,"static void Write(const FunctionCallbackInfo<Value>& args) {
    Environment* env = Environment::GetCurrent(args);
    Local<Context> context = env->context();
    CHECK_EQ(args.Length(), 7);

    uint32_t in_off, in_len, out_off, out_len, flush;
    const char* in;
    char* out;

    CHECK_EQ(false, args[0]->IsUndefined() && ""must provide flush value"");
    if (!args[0]->Uint32Value(context).To(&flush)) return;

    if (flush != Z_NO_FLUSH &&
        flush != Z_PARTIAL_FLUSH &&
        flush != Z_SYNC_FLUSH &&
        flush != Z_FULL_FLUSH &&
        flush != Z_FINISH &&
        flush != Z_BLOCK) {
      UNREACHABLE(""Invalid flush value"");
    }

    if (args[1]->IsNull()) {
      // just a flush
      in = nullptr;
      in_len = 0;
      in_off = 0;
    } else {
      CHECK(Buffer::HasInstance(args[1]));
      Local<Object> in_buf = args[1].As<Object>();
      if (!args[2]->Uint32Value(context).To(&in_off)) return;
      if (!args[3]->Uint32Value(context).To(&in_len)) return;

 ...",298.0,345.0,3.0,3.0,48.0,56,11,53,22,0,0,6,6,0,0,,0,0,2,1,1,void
4754,255515,Write,1,node.anonymous_namespace_62.CompressionStream.Write,"void node.anonymous_namespace_62.CompressionStream.Write<bool> (uint32_t,char*,uint32_t,char*,uint32_t)",node_zlib.cc,"void Write(uint32_t flush,
             const char* in, uint32_t in_len,
             char* out, uint32_t out_len) {
    AllocScope alloc_scope(this);

    CHECK(init_done_ && ""write before init"");
    CHECK(!closed_ && ""already finalized"");

    CHECK_EQ(false, write_in_progress_);
    CHECK_EQ(false, pending_close_);
    write_in_progress_ = true;
    Ref();

    ctx_.SetBuffers(in, in_len, out, out_len);
    ctx_.SetFlush(flush);

    if constexpr (!async) {
      // sync version
      AsyncWrap::env()->PrintSyncTrace();
      DoThreadPoolWork();
      if (CheckError()) {
        UpdateWriteResult();
        write_in_progress_ = false;
      }
      Unref();
      return;
    }

    // async version
    ScheduleWork();
  }",348.0,378.0,3.0,3.0,31.0,10,5,15,12,0,8,3,4,0,0,,0,8,10,5,5,void
4755,255581,UpdateWriteResult,1,node.anonymous_namespace_68.CompressionStream.UpdateWriteResult,void node.anonymous_namespace_68.CompressionStream.UpdateWriteResult (),node_zlib.cc,"void UpdateWriteResult() {
    ctx_.GetAfterWriteOffsets(&write_result_[1], &write_result_[0]);
  }",380.0,382.0,3.0,3.0,3.0,5,3,3,2,0,3,1,1,0,0,,0,3,0,0,0,void
4756,255597,DoThreadPoolWork,1,node.anonymous_namespace_69.CompressionStream.DoThreadPoolWork,void node.anonymous_namespace_69.CompressionStream.DoThreadPoolWork (),node_zlib.cc,"void DoThreadPoolWork() override {
    ctx_.DoThreadPoolWork();
  }",388.0,390.0,3.0,3.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,void
4757,255605,CheckError,1,node.anonymous_namespace_70.CompressionStream.CheckError,bool node.anonymous_namespace_70.CompressionStream.CheckError (),node_zlib.cc,"bool CheckError() {
    const CompressionError err = ctx_.GetErrorInfo();
    if (!err.IsError()) return true;
    EmitError(err);
    return false;
  }",393.0,398.0,3.0,3.0,6.0,4,3,4,2,0,1,2,2,0,0,,0,1,0,0,0,bool
4758,255629,AfterThreadPoolWork,1,node.anonymous_namespace_72.CompressionStream.AfterThreadPoolWork,void node.anonymous_namespace_72.CompressionStream.AfterThreadPoolWork (int),node_zlib.cc,"void AfterThreadPoolWork(int status) override {
    DCHECK(init_done_);
    AllocScope alloc_scope(this);
    auto on_scope_leave = OnScopeLeave([&]() { Unref(); });

    write_in_progress_ = false;

    if (status == UV_ECANCELED) {
      Close();
      return;
    }

    CHECK_EQ(status, 0);

    Environment* env = AsyncWrap::env();
    HandleScope handle_scope(env->isolate());
    Context::Scope context_scope(env->context());

    if (!CheckError())
      return;

    UpdateWriteResult();

    // call the write() cb
    Local<Value> cb = object()->GetInternalField(kWriteJSCallback);
    MakeCallback(cb.As<Function>(), 0, nullptr);

    if (pending_close_)
      Close();
  }",402.0,431.0,3.0,3.0,30.0,13,7,16,12,0,4,4,4,1,0,,0,4,2,1,1,void
4759,255704,EmitError,1,node.anonymous_namespace_79.CompressionStream.EmitError,void node.anonymous_namespace_79.CompressionStream.EmitError (CompressionError),node_zlib.cc,"void EmitError(const CompressionError& err) {
    Environment* env = AsyncWrap::env();
    // If you hit this assertion, you forgot to enter the v8::Context first.
    CHECK_EQ(env->context(), env->isolate()->GetCurrentContext());

    HandleScope scope(env->isolate());
    Local<Value> args[] = {
      OneByteString(env->isolate(), err.message),
      Integer::New(env->isolate(), err.err),
      OneByteString(env->isolate(), err.code)
    };
    MakeCallback(env->onerror_string(), arraysize(args), args);

    // no hope of rescue.
    write_in_progress_ = false;
    if (pending_close_)
      Close();
  }",434.0,451.0,3.0,3.0,18.0,17,4,18,7,0,5,2,2,1,0,,0,5,2,1,1,void
4760,255780,Reset,1,node.anonymous_namespace_81.CompressionStream.Reset,void node.anonymous_namespace_81.CompressionStream.Reset (FunctionCallbackInfo<Value>),node_zlib.cc,"static void Reset(const FunctionCallbackInfo<Value> &args) {
    CompressionStream* wrap;
    ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

    AllocScope alloc_scope(wrap);
    const CompressionError err = wrap->context()->ResetStream();
    if (err.IsError())
      wrap->EmitError(err);
  }",453.0,461.0,3.0,3.0,9.0,7,4,8,3,0,0,2,2,0,0,,0,0,2,1,1,void
4761,255817,MemoryInfo,1,node.anonymous_namespace_82.CompressionStream.MemoryInfo,void node.anonymous_namespace_82.CompressionStream.MemoryInfo (MemoryTracker*),node_zlib.cc,"void MemoryInfo(MemoryTracker* tracker) const override {
    tracker->TrackField(""compression context"", ctx_);
    tracker->TrackFieldWithSize(""zlib_memory"",
                                zlib_memory_ + unreported_allocations_);
  }",463.0,467.0,3.0,3.0,5.0,3,2,5,4,0,3,1,1,0,0,,0,3,2,1,1,void
4762,255836,context,1,node.anonymous_namespace_83.CompressionStream.context,CompressionContext node.anonymous_namespace_83.CompressionStream.context (),node_zlib.cc,CompressionContext* context() { return &ctx_; },470.0,470.0,3.0,49.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,CompressionContext
4763,255843,InitStream,1,node.anonymous_namespace_84.CompressionStream.InitStream,"void node.anonymous_namespace_84.CompressionStream.InitStream (uint32_t*,Local<Function>)",node_zlib.cc,"void InitStream(uint32_t* write_result, Local<Function> write_js_callback) {
    write_result_ = write_result;
    object()->SetInternalField(kWriteJSCallback, write_js_callback);
    init_done_ = true;
  }",472.0,476.0,3.0,3.0,5.0,3,2,5,5,0,3,1,1,0,0,,0,3,4,2,2,void
4764,255861,AllocForZlib,1,node.anonymous_namespace_85.CompressionStream.AllocForZlib,"void* node.anonymous_namespace_85.CompressionStream.AllocForZlib (void*,uInt,uInt)",node_zlib.cc,"static void* AllocForZlib(void* data, uInt items, uInt size) {
    size_t real_size =
        MultiplyWithOverflowCheck(static_cast<size_t>(items),
                                  static_cast<size_t>(size));
    return AllocForBrotli(data, real_size);
  }",484.0,489.0,3.0,3.0,6.0,3,2,5,4,0,0,1,1,0,0,,0,0,6,3,3,void*
4765,255882,AllocForBrotli,1,node.anonymous_namespace_88.CompressionStream.AllocForBrotli,"void* node.anonymous_namespace_88.CompressionStream.AllocForBrotli (void*,size_t)",node_zlib.cc,"static void* AllocForBrotli(void* data, size_t size) {
    size += sizeof(size_t);
    CompressionStream* ctx = static_cast<CompressionStream*>(data);
    char* memory = UncheckedMalloc(size);
    if (UNLIKELY(memory == nullptr)) return nullptr;
    *reinterpret_cast<size_t*>(memory) = size;
    ctx->unreported_allocations_.fetch_add(size,
                                           std::memory_order_relaxed);
    return memory + sizeof(size_t);
  }",491.0,500.0,3.0,3.0,10.0,14,9,14,6,0,1,2,2,0,0,,0,1,4,2,2,void*
4766,255932,FreeForZlib,1,node.anonymous_namespace_89.CompressionStream.FreeForZlib,"void node.anonymous_namespace_89.CompressionStream.FreeForZlib (void*,void*)",node_zlib.cc,"static void FreeForZlib(void* data, void* pointer) {
    if (UNLIKELY(pointer == nullptr)) return;
    CompressionStream* ctx = static_cast<CompressionStream*>(data);
    char* real_pointer = static_cast<char*>(pointer) - sizeof(size_t);
    size_t real_size = *reinterpret_cast<size_t*>(real_pointer);
    ctx->unreported_allocations_.fetch_sub(real_size,
                                           std::memory_order_relaxed);
    free(real_pointer);
  }",502.0,510.0,3.0,3.0,9.0,13,8,12,7,0,1,2,2,0,0,,0,1,4,2,2,void
4767,255979,AdjustAmountOfExternalAllocatedMemory,1,node.anonymous_namespace_90.CompressionStream.AdjustAmountOfExternalAllocatedMemory,void node.anonymous_namespace_90.CompressionStream.AdjustAmountOfExternalAllocatedMemory (),node_zlib.cc,"void AdjustAmountOfExternalAllocatedMemory() {
    ssize_t report =
        unreported_allocations_.exchange(0, std::memory_order_relaxed);
    if (report == 0) return;
    CHECK_IMPLIES(report < 0, zlib_memory_ >= static_cast<size_t>(-report));
    zlib_memory_ += report;
    AsyncWrap::env()->isolate()->AdjustAmountOfExternalAllocatedMemory(report);
  }",514.0,521.0,3.0,3.0,8.0,12,9,11,5,0,3,2,2,0,0,,0,3,0,0,0,void
4768,256025,AllocScope,1,node.anonymous_namespace_92.CompressionStream.AllocScope.AllocScope,ANY node.anonymous_namespace_92.CompressionStream.AllocScope.AllocScope (CompressionStream*),node_zlib.cc,explicit AllocScope(CompressionStream* stream) : stream(stream) {},524.0,524.0,5.0,70.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
4769,256030,~AllocScope,1,node.anonymous_namespace_93.CompressionStream.AllocScope.~AllocScope,ANY node.anonymous_namespace_93.CompressionStream.AllocScope.~AllocScope (),node_zlib.cc,~AllocScope() { stream->AdjustAmountOfExternalAllocatedMemory(); },525.0,525.0,5.0,70.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,ANY
4770,256039,Ref,1,node.anonymous_namespace_94.CompressionStream.Ref,void node.anonymous_namespace_94.CompressionStream.Ref (),node_zlib.cc,"void Ref() {
    if (++refs_ == 1) {
      ClearWeak();
    }
  }",530.0,534.0,3.0,3.0,5.0,2,2,1,1,0,1,2,2,1,0,,0,1,0,0,0,void
4771,256050,Unref,1,node.anonymous_namespace_95.CompressionStream.Unref,void node.anonymous_namespace_95.CompressionStream.Unref (),node_zlib.cc,"void Unref() {
    CHECK_GT(refs_, 0);
    if (--refs_ == 0) {
      MakeWeak();
    }
  }",536.0,541.0,3.0,3.0,6.0,2,2,2,1,0,2,2,2,1,0,,0,2,0,0,0,void
4772,256103,ZlibStream,1,node.anonymous_namespace_97.ZlibStream.ZlibStream,"ANY node.anonymous_namespace_97.ZlibStream.ZlibStream (Environment*,Local<Object>,node_zlib_mode)",node_zlib.cc,"ZlibStream(Environment* env, Local<Object> wrap, node_zlib_mode mode)
    : CompressionStream(env, wrap) {
    context()->SetMode(mode);
  }",557.0,560.0,3.0,3.0,4.0,1,1,1,1,0,0,1,1,0,0,,0,0,6,3,3,ANY
4773,256115,New,1,node.anonymous_namespace_98.ZlibStream.New,void node.anonymous_namespace_98.ZlibStream.New (FunctionCallbackInfo<Value>),node_zlib.cc,"static void New(const FunctionCallbackInfo<Value>& args) {
    Environment* env = Environment::GetCurrent(args);
    CHECK(args[0]->IsInt32());
    node_zlib_mode mode =
        static_cast<node_zlib_mode>(args[0].As<Int32>()->Value());
    new ZlibStream(env, args.This(), mode);
  }",562.0,568.0,3.0,3.0,7.0,11,6,10,5,0,0,1,1,0,0,,0,0,2,1,1,void
4774,256157,Init,1,node.anonymous_namespace_99.ZlibStream.Init,void node.anonymous_namespace_99.ZlibStream.Init (FunctionCallbackInfo<Value>),node_zlib.cc,"static void Init(const FunctionCallbackInfo<Value>& args) {
    // Refs: https://github.com/nodejs/node/issues/16649
    // Refs: https://github.com/nodejs/node/issues/14161
    if (args.Length() == 5) {
      fprintf(stderr,
          ""WARNING: You are likely using a version of node-tar or npm that ""
          ""is incompatible with this version of Node.js.\nPlease use ""
          ""either the version of npm that is bundled with Node.js, or ""
          ""a version of npm (> 5.5.1 or < 5.4.0) or node-tar (> 4.0.1) ""
          ""that is compatible with Node.js 9 and above.\n"");
    }
    CHECK(args.Length() == 7 &&
      ""init(windowBits, level, memLevel, strategy, writeResult, writeCallback,""
      "" dictionary)"");

    ZlibStream* wrap;
    ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

    Local<Context> context = args.GetIsolate()->GetCurrentContext();

    // windowBits is special. On the compression side, 0 is an invalid value.
    // But on the decompression side, a value of 0 fo...",571.0,630.0,3.0,3.0,60.0,71,12,63,23,0,0,7,7,0,0,,0,0,2,1,1,void
4775,256403,Params,1,node.anonymous_namespace_100.ZlibStream.Params,void node.anonymous_namespace_100.ZlibStream.Params (FunctionCallbackInfo<Value>),node_zlib.cc,"static void Params(const FunctionCallbackInfo<Value>& args) {
    CHECK(args.Length() == 2 && ""params(level, strategy)"");
    ZlibStream* wrap;
    ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
    Local<Context> context = args.GetIsolate()->GetCurrentContext();
    int level;
    if (!args[0]->Int32Value(context).To(&level)) return;
    int strategy;
    if (!args[1]->Int32Value(context).To(&strategy)) return;

    AllocScope alloc_scope(wrap);
    const CompressionError err = wrap->context()->SetParams(level, strategy);
    if (err.IsError())
      wrap->EmitError(err);
  }",632.0,646.0,3.0,3.0,15.0,25,10,21,8,0,0,4,4,0,0,,0,0,2,1,1,void
4776,256503,BrotliCompressionStream,1,node.anonymous_namespace_102.BrotliCompressionStream.BrotliCompressionStream,"ANY node.anonymous_namespace_102.BrotliCompressionStream.BrotliCompressionStream (Environment*,Local<Object>,node_zlib_mode)",node_zlib.cc,"BrotliCompressionStream(Environment* env,
                          Local<Object> wrap,
                          node_zlib_mode mode)
    : CompressionStream<CompressionContext>(env, wrap) {
    context()->SetMode(mode);
  }",656.0,661.0,3.0,3.0,6.0,1,1,1,1,0,0,1,1,0,0,,0,0,6,3,3,ANY
4777,256515,context,1,node.anonymous_namespace_104.BrotliCompressionStream.context,CompressionContext node.anonymous_namespace_104.BrotliCompressionStream.context (),node_zlib.cc,"inline CompressionContext* context() {
    return this->CompressionStream<CompressionContext>::context();
  }",663.0,665.0,3.0,3.0,3.0,1,1,0,0,0,0,1,1,0,0,,0,0,0,0,0,CompressionContext
4778,256525,New,1,node.anonymous_namespace_105.BrotliCompressionStream.New,void node.anonymous_namespace_105.BrotliCompressionStream.New (FunctionCallbackInfo<Value>),node_zlib.cc,"static void New(const FunctionCallbackInfo<Value>& args) {
    Environment* env = Environment::GetCurrent(args);
    CHECK(args[0]->IsInt32());
    node_zlib_mode mode =
        static_cast<node_zlib_mode>(args[0].As<Int32>()->Value());
    new BrotliCompressionStream(env, args.This(), mode);
  }",668.0,674.0,3.0,3.0,7.0,11,6,10,5,0,0,1,1,0,0,,0,0,2,1,1,void
4779,256567,Init,1,node.anonymous_namespace_106.BrotliCompressionStream.Init,void node.anonymous_namespace_106.BrotliCompressionStream.Init (FunctionCallbackInfo<Value>),node_zlib.cc,"static void Init(const FunctionCallbackInfo<Value>& args) {
    BrotliCompressionStream* wrap;
    ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
    CHECK(args.Length() == 3 && ""init(params, writeResult, writeCallback)"");

    CHECK(args[1]->IsUint32Array());
    uint32_t* write_result = reinterpret_cast<uint32_t*>(Buffer::Data(args[1]));

    CHECK(args[2]->IsFunction());
    Local<Function> write_js_callback = args[2].As<Function>();
    wrap->InitStream(write_result, write_js_callback);

    AllocScope alloc_scope(wrap);
    CompressionError err =
        wrap->context()->Init(
          CompressionStream<CompressionContext>::AllocForBrotli,
          CompressionStream<CompressionContext>::FreeForZlib,
          static_cast<CompressionStream<CompressionContext>*>(wrap));
    if (err.IsError()) {
      wrap->EmitError(err);
      args.GetReturnValue().Set(false);
      return;
    }

    CHECK(args[0]->IsUint32Array());
    const uint32_t* data = reinterpret_cast<uint32_t*>(Buffe...",676.0,716.0,3.0,3.0,41.0,57,12,48,13,0,0,6,7,0,0,,0,0,2,1,1,void
4780,256774,Params,1,node.anonymous_namespace_107.BrotliCompressionStream.Params,void node.anonymous_namespace_107.BrotliCompressionStream.Params (FunctionCallbackInfo<Value>),node_zlib.cc,"static void Params(const FunctionCallbackInfo<Value>& args) {
    // Currently a no-op, and not accessed from JS land.
    // At some point Brotli may support changing parameters on the fly,
    // in which case we can implement this and a JS equivalent similar to
    // the zlib Params() function.
  }",718.0,723.0,3.0,3.0,6.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
4781,256785,Close,1,node.anonymous_namespace_108.ZlibContext.Close,void node.anonymous_namespace_108.ZlibContext.Close (),node_zlib.cc,"void ZlibContext::Close() {
  {
    Mutex::ScopedLock lock(mutex_);
    if (!zlib_init_done_) {
      dictionary_.clear();
      mode_ = NONE;
      return;
    }
  }

  CHECK_LE(mode_, UNZIP);

  int status = Z_OK;
  if (mode_ == DEFLATE || mode_ == GZIP || mode_ == DEFLATERAW) {
    status = deflateEnd(&strm_);
  } else if (mode_ == INFLATE || mode_ == GUNZIP || mode_ == INFLATERAW ||
             mode_ == UNZIP) {
    status = inflateEnd(&strm_);
  }

  CHECK(status == Z_OK || status == Z_DATA_ERROR);
  mode_ = NONE;

  dictionary_.clear();
}",732.0,756.0,1.0,1.0,25.0,16,6,24,13,0,0,3,3,0,0,,0,0,0,0,0,void
4782,256869,DoThreadPoolWork,1,node.anonymous_namespace_109.ZlibContext.DoThreadPoolWork,void node.anonymous_namespace_109.ZlibContext.DoThreadPoolWork (),node_zlib.cc,"void ZlibContext::DoThreadPoolWork() {
  bool first_init_call = InitZlib();
  if (first_init_call && err_ != Z_OK) {
    return;
  }

  const Bytef* next_expected_header_byte = nullptr;

  // If the avail_out is left at 0, then it means that it ran out
  // of room.  If there was avail_out left over, then it means
  // that all of the input was consumed.
  switch (mode_) {
    case DEFLATE:
    case GZIP:
    case DEFLATERAW:
      err_ = deflate(&strm_, flush_);
      break;
    case UNZIP:
      if (strm_.avail_in > 0) {
        next_expected_header_byte = strm_.next_in;
      }

      switch (gzip_id_bytes_read_) {
        case 0:
          if (next_expected_header_byte == nullptr) {
            break;
          }

          if (*next_expected_header_byte == GZIP_HEADER_ID1) {
            gzip_id_bytes_read_ = 1;
            next_expected_header_byte++;

            if (strm_.avail_in == 1) {
              // The only available byte was already read.
              break;
        ...",759.0,862.0,1.0,1.0,104.0,49,11,58,20,0,0,19,30,0,0,,0,0,0,0,0,void
4783,257078,SetBuffers,1,node.anonymous_namespace_110.ZlibContext.SetBuffers,"void node.anonymous_namespace_110.ZlibContext.SetBuffers (char*,uint32_t,char*,uint32_t)",node_zlib.cc,"void ZlibContext::SetBuffers(const char* in, uint32_t in_len,
                             char* out, uint32_t out_len) {
  strm_.avail_in = in_len;
  strm_.next_in = const_cast<Bytef*>(reinterpret_cast<const Bytef*>(in));
  strm_.avail_out = out_len;
  strm_.next_out = reinterpret_cast<Bytef*>(out);
}",865.0,871.0,1.0,1.0,7.0,11,3,8,5,0,0,1,1,0,0,,0,0,8,4,4,void
4784,257112,SetFlush,1,node.anonymous_namespace_111.ZlibContext.SetFlush,void node.anonymous_namespace_111.ZlibContext.SetFlush (int),node_zlib.cc,"void ZlibContext::SetFlush(int flush) {
  flush_ = flush;
}",874.0,876.0,1.0,1.0,3.0,1,1,2,2,0,0,1,1,0,0,,0,0,2,1,1,void
4785,257120,GetAfterWriteOffsets,1,node.anonymous_namespace_112.ZlibContext.GetAfterWriteOffsets,"void node.anonymous_namespace_112.ZlibContext.GetAfterWriteOffsets (uint32_t*,uint32_t*)",node_zlib.cc,"void ZlibContext::GetAfterWriteOffsets(uint32_t* avail_in,
                                       uint32_t* avail_out) const {
  *avail_in = strm_.avail_in;
  *avail_out = strm_.avail_out;
}",879.0,883.0,1.0,1.0,5.0,6,3,4,3,0,0,1,1,0,0,,0,0,4,2,2,void
4786,257138,ErrorForMessage,1,node.anonymous_namespace_113.ZlibContext.ErrorForMessage,CompressionError node.anonymous_namespace_113.ZlibContext.ErrorForMessage (char*),node_zlib.cc,"CompressionError ZlibContext::ErrorForMessage(const char* message) const {
  if (strm_.msg != nullptr)
    message = strm_.msg;

  return CompressionError { message, ZlibStrerror(err_), err_ };
}",886.0,891.0,1.0,1.0,6.0,5,4,6,3,0,0,2,2,0,0,,0,0,2,1,1,CompressionError
4787,257162,GetErrorInfo,1,node.anonymous_namespace_115.ZlibContext.GetErrorInfo,CompressionError node.anonymous_namespace_115.ZlibContext.GetErrorInfo (),node_zlib.cc,"CompressionError ZlibContext::GetErrorInfo() const {
  // Acceptable error states depend on the type of zlib stream.
  switch (err_) {
  case Z_OK:
  case Z_BUF_ERROR:
    if (strm_.avail_out != 0 && flush_ == Z_FINISH) {
      return ErrorForMessage(""unexpected end of file"");
    }
  case Z_STREAM_END:
    // normal statuses, not fatal
    break;
  case Z_NEED_DICT:
    if (dictionary_.empty())
      return ErrorForMessage(""Missing dictionary"");
    else
      return ErrorForMessage(""Bad dictionary"");
  default:
    // something else.
    return ErrorForMessage(""Zlib error"");
  }

  return CompressionError {};
}",894.0,916.0,1.0,1.0,23.0,6,5,9,9,0,0,5,6,0,0,,0,0,0,0,0,CompressionError
4788,257213,ResetStream,1,node.anonymous_namespace_120.ZlibContext.ResetStream,CompressionError node.anonymous_namespace_120.ZlibContext.ResetStream (),node_zlib.cc,"CompressionError ZlibContext::ResetStream() {
  bool first_init_call = InitZlib();
  if (first_init_call && err_ != Z_OK) {
    return ErrorForMessage(""Failed to init stream before reset"");
  }

  err_ = Z_OK;

  switch (mode_) {
    case DEFLATE:
    case DEFLATERAW:
    case GZIP:
      err_ = deflateReset(&strm_);
      break;
    case INFLATE:
    case INFLATERAW:
    case GUNZIP:
      err_ = inflateReset(&strm_);
      break;
    default:
      break;
  }

  if (err_ != Z_OK)
    return ErrorForMessage(""Failed to reset stream"");

  return SetDictionary();
}",919.0,946.0,1.0,1.0,28.0,9,4,19,11,0,0,7,4,0,0,,0,0,0,0,0,CompressionError
4789,257273,SetAllocationFunctions,1,node.anonymous_namespace_123.ZlibContext.SetAllocationFunctions,"void node.anonymous_namespace_123.ZlibContext.SetAllocationFunctions (alloc_func,free_func,void*)",node_zlib.cc,"void ZlibContext::SetAllocationFunctions(alloc_func alloc,
                                         free_func free,
                                         void* opaque) {
  strm_.zalloc = alloc;
  strm_.zfree = free;
  strm_.opaque = opaque;
}",949.0,955.0,1.0,1.0,7.0,6,2,6,4,0,0,1,1,0,0,,0,0,6,3,3,void
4790,257295,Init,1,node.anonymous_namespace_124.ZlibContext.Init,"void node.anonymous_namespace_124.ZlibContext.Init (int,int,int,int,ANY)",node_zlib.cc,"void ZlibContext::Init(
    int level, int window_bits, int mem_level, int strategy,
    std::vector<unsigned char>&& dictionary) {
  if (!((window_bits == 0) &&
        (mode_ == INFLATE ||
         mode_ == GUNZIP ||
         mode_ == UNZIP))) {
    CHECK(
        (window_bits >= Z_MIN_WINDOWBITS && window_bits <= Z_MAX_WINDOWBITS) &&
        ""invalid windowBits"");
  }

  CHECK((level >= Z_MIN_LEVEL && level <= Z_MAX_LEVEL) &&
    ""invalid compression level"");

  CHECK((mem_level >= Z_MIN_MEMLEVEL && mem_level <= Z_MAX_MEMLEVEL) &&
        ""invalid memlevel"");

  CHECK((strategy == Z_FILTERED || strategy == Z_HUFFMAN_ONLY ||
         strategy == Z_RLE || strategy == Z_FIXED ||
         strategy == Z_DEFAULT_STRATEGY) &&
        ""invalid strategy"");

  level_ = level;
  window_bits_ = window_bits;
  mem_level_ = mem_level;
  strategy_ = strategy;

  flush_ = Z_NO_FLUSH;

  err_ = Z_OK;

  if (mode_ == GZIP || mode_ == GUNZIP) {
    window_bits_ += 16;
  }

  if (mode_ == UNZIP) {
 ...",958.0,1003.0,1.0,24.0,46.0,50,11,51,27,0,0,5,5,0,0,,0,0,10,5,5,void
4791,257445,InitZlib,1,node.anonymous_namespace_125.ZlibContext.InitZlib,bool node.anonymous_namespace_125.ZlibContext.InitZlib (),node_zlib.cc,"bool ZlibContext::InitZlib() {
  Mutex::ScopedLock lock(mutex_);
  if (zlib_init_done_) {
    return false;
  }

  switch (mode_) {
    case DEFLATE:
    case GZIP:
    case DEFLATERAW:
      err_ = deflateInit2(&strm_,
                          level_,
                          Z_DEFLATED,
                          window_bits_,
                          mem_level_,
                          strategy_);
      break;
    case INFLATE:
    case GUNZIP:
    case INFLATERAW:
    case UNZIP:
      err_ = inflateInit2(&strm_, window_bits_);
      break;
    default:
      UNREACHABLE();
  }

  if (err_ != Z_OK) {
    dictionary_.clear();
    mode_ = NONE;
    return true;
  }

  SetDictionary();
  zlib_init_done_ = true;
  return true;
}",1005.0,1041.0,1.0,1.0,37.0,8,4,26,20,0,0,6,4,0,0,,0,0,0,0,0,bool
4792,257514,SetDictionary,1,node.anonymous_namespace_126.ZlibContext.SetDictionary,CompressionError node.anonymous_namespace_126.ZlibContext.SetDictionary (),node_zlib.cc,"CompressionError ZlibContext::SetDictionary() {
  if (dictionary_.empty())
    return CompressionError {};

  err_ = Z_OK;

  switch (mode_) {
    case DEFLATE:
    case DEFLATERAW:
      err_ = deflateSetDictionary(&strm_,
                                  dictionary_.data(),
                                  dictionary_.size());
      break;
    case INFLATERAW:
      // The other inflate cases will have the dictionary set when inflate()
      // returns Z_NEED_DICT in Process()
      err_ = inflateSetDictionary(&strm_,
                                  dictionary_.data(),
                                  dictionary_.size());
      break;
    default:
      break;
  }

  if (err_ != Z_OK) {
    return ErrorForMessage(""Failed to set dictionary"");
  }

  return CompressionError {};
}",1044.0,1073.0,1.0,1.0,30.0,13,5,17,8,0,0,7,4,0,0,,0,0,0,0,0,CompressionError
4793,257580,SetParams,1,node.anonymous_namespace_128.ZlibContext.SetParams,"CompressionError node.anonymous_namespace_128.ZlibContext.SetParams (int,int)",node_zlib.cc,"CompressionError ZlibContext::SetParams(int level, int strategy) {
  bool first_init_call = InitZlib();
  if (first_init_call && err_ != Z_OK) {
    return ErrorForMessage(""Failed to init stream before set parameters"");
  }

  err_ = Z_OK;

  switch (mode_) {
    case DEFLATE:
    case DEFLATERAW:
      err_ = deflateParams(&strm_, level, strategy);
      break;
    default:
      break;
  }

  if (err_ != Z_OK && err_ != Z_BUF_ERROR) {
    return ErrorForMessage(""Failed to set parameters"");
  }

  return CompressionError {};
}",1076.0,1098.0,1.0,1.0,23.0,10,5,17,10,0,0,6,4,0,0,,0,0,4,2,2,CompressionError
4794,257635,SetBuffers,1,node.anonymous_namespace_132.BrotliContext.SetBuffers,"void node.anonymous_namespace_132.BrotliContext.SetBuffers (char*,uint32_t,char*,uint32_t)",node_zlib.cc,"void BrotliContext::SetBuffers(const char* in, uint32_t in_len,
                               char* out, uint32_t out_len) {
  next_in_ = reinterpret_cast<const uint8_t*>(in);
  next_out_ = reinterpret_cast<uint8_t*>(out);
  avail_in_ = in_len;
  avail_out_ = out_len;
}",1101.0,1107.0,1.0,1.0,7.0,6,2,8,8,0,0,1,1,0,0,,0,0,8,4,4,void
4795,257659,SetFlush,1,node.anonymous_namespace_133.BrotliContext.SetFlush,void node.anonymous_namespace_133.BrotliContext.SetFlush (int),node_zlib.cc,"void BrotliContext::SetFlush(int flush) {
  flush_ = static_cast<BrotliEncoderOperation>(flush);
}",1110.0,1112.0,1.0,1.0,3.0,2,2,2,2,0,0,1,1,0,0,,0,0,2,1,1,void
4796,257669,GetAfterWriteOffsets,1,node.anonymous_namespace_134.BrotliContext.GetAfterWriteOffsets,"void node.anonymous_namespace_134.BrotliContext.GetAfterWriteOffsets (uint32_t*,uint32_t*)",node_zlib.cc,"void BrotliContext::GetAfterWriteOffsets(uint32_t* avail_in,
                                         uint32_t* avail_out) const {
  *avail_in = avail_in_;
  *avail_out = avail_out_;
}",1115.0,1119.0,1.0,1.0,5.0,4,2,4,4,0,0,1,1,0,0,,0,0,4,2,2,void
4797,257683,DoThreadPoolWork,1,node.anonymous_namespace_135.BrotliEncoderContext.DoThreadPoolWork,void node.anonymous_namespace_135.BrotliEncoderContext.DoThreadPoolWork (),node_zlib.cc,"void BrotliEncoderContext::DoThreadPoolWork() {
  CHECK_EQ(mode_, BROTLI_ENCODE);
  CHECK(state_);
  const uint8_t* next_in = next_in_;
  last_result_ = BrotliEncoderCompressStream(state_.get(),
                                             flush_,
                                             &avail_in_,
                                             &next_in,
                                             &avail_out_,
                                             &next_out_,
                                             nullptr);
  next_in_ += next_in - next_in_;
}",1122.0,1134.0,1.0,1.0,13.0,9,5,15,10,0,0,1,1,0,0,,0,0,0,0,0,void
4798,257718,Close,1,node.anonymous_namespace_136.BrotliEncoderContext.Close,void node.anonymous_namespace_136.BrotliEncoderContext.Close (),node_zlib.cc,"void BrotliEncoderContext::Close() {
  state_.reset();
  mode_ = NONE;
}",1137.0,1140.0,1.0,1.0,4.0,2,2,3,3,0,0,1,1,0,0,,0,0,0,0,0,void
4799,257729,Init,1,node.anonymous_namespace_137.BrotliEncoderContext.Init,"CompressionError node.anonymous_namespace_137.BrotliEncoderContext.Init (brotli_alloc_func,brotli_free_func,void*)",node_zlib.cc,"CompressionError BrotliEncoderContext::Init(brotli_alloc_func alloc,
                                            brotli_free_func free,
                                            void* opaque) {
  alloc_ = alloc;
  free_ = free;
  alloc_opaque_ = opaque;
  state_.reset(BrotliEncoderCreateInstance(alloc, free, opaque));
  if (!state_) {
    return CompressionError(""Could not initialize Brotli instance"",
                            ""ERR_ZLIB_INITIALIZATION_FAILED"",
                            -1);
  } else {
    return CompressionError {};
  }
}",1142.0,1156.0,1.0,1.0,15.0,6,4,11,7,0,0,2,2,0,0,,0,0,6,3,3,CompressionError
4800,257768,ResetStream,1,node.anonymous_namespace_138.BrotliEncoderContext.ResetStream,CompressionError node.anonymous_namespace_138.BrotliEncoderContext.ResetStream (),node_zlib.cc,"CompressionError BrotliEncoderContext::ResetStream() {
  return Init(alloc_, free_, alloc_opaque_);
}",1158.0,1160.0,1.0,1.0,3.0,0,0,3,3,0,0,1,1,0,0,,0,0,0,0,0,CompressionError
4801,257777,SetParams,1,node.anonymous_namespace_140.BrotliEncoderContext.SetParams,"CompressionError node.anonymous_namespace_140.BrotliEncoderContext.SetParams (int,uint32_t)",node_zlib.cc,"CompressionError BrotliEncoderContext::SetParams(int key, uint32_t value) {
  if (!BrotliEncoderSetParameter(state_.get(),
                                 static_cast<BrotliEncoderParameter>(key),
                                 value)) {
    return CompressionError(""Setting parameter failed"",
                            ""ERR_BROTLI_PARAM_SET_FAILED"",
                            -1);
  } else {
    return CompressionError {};
  }
}",1162.0,1172.0,1.0,1.0,11.0,4,4,3,3,0,0,2,2,0,0,,0,0,4,2,2,CompressionError
4802,257806,GetErrorInfo,1,node.anonymous_namespace_141.BrotliEncoderContext.GetErrorInfo,CompressionError node.anonymous_namespace_141.BrotliEncoderContext.GetErrorInfo (),node_zlib.cc,"CompressionError BrotliEncoderContext::GetErrorInfo() const {
  if (!last_result_) {
    return CompressionError(""Compression failed"",
                            ""ERR_BROTLI_COMPRESSION_FAILED"",
                            -1);
  } else {
    return CompressionError {};
  }
}",1174.0,1182.0,1.0,1.0,9.0,2,2,1,1,0,0,2,2,0,0,,0,0,0,0,0,CompressionError
4803,257825,Close,1,node.anonymous_namespace_142.BrotliDecoderContext.Close,void node.anonymous_namespace_142.BrotliDecoderContext.Close (),node_zlib.cc,"void BrotliDecoderContext::Close() {
  state_.reset();
  mode_ = NONE;
}",1185.0,1188.0,1.0,1.0,4.0,2,2,3,3,0,0,1,1,0,0,,0,0,0,0,0,void
4804,257836,DoThreadPoolWork,1,node.anonymous_namespace_143.BrotliDecoderContext.DoThreadPoolWork,void node.anonymous_namespace_143.BrotliDecoderContext.DoThreadPoolWork (),node_zlib.cc,"void BrotliDecoderContext::DoThreadPoolWork() {
  CHECK_EQ(mode_, BROTLI_DECODE);
  CHECK(state_);
  const uint8_t* next_in = next_in_;
  last_result_ = BrotliDecoderDecompressStream(state_.get(),
                                               &avail_in_,
                                               &next_in,
                                               &avail_out_,
                                               &next_out_,
                                               nullptr);
  next_in_ += next_in - next_in_;
  if (last_result_ == BROTLI_DECODER_RESULT_ERROR) {
    error_ = BrotliDecoderGetErrorCode(state_.get());
    error_string_ = std::string(""ERR_"") + BrotliDecoderErrorString(error_);
  }
}",1190.0,1205.0,1.0,1.0,16.0,15,7,21,13,0,0,2,2,0,0,,0,0,0,0,0,void
4805,257892,Init,1,node.anonymous_namespace_144.BrotliDecoderContext.Init,"CompressionError node.anonymous_namespace_144.BrotliDecoderContext.Init (brotli_alloc_func,brotli_free_func,void*)",node_zlib.cc,"CompressionError BrotliDecoderContext::Init(brotli_alloc_func alloc,
                                            brotli_free_func free,
                                            void* opaque) {
  alloc_ = alloc;
  free_ = free;
  alloc_opaque_ = opaque;
  state_.reset(BrotliDecoderCreateInstance(alloc, free, opaque));
  if (!state_) {
    return CompressionError(""Could not initialize Brotli instance"",
                            ""ERR_ZLIB_INITIALIZATION_FAILED"",
                            -1);
  } else {
    return CompressionError {};
  }
}",1207.0,1221.0,1.0,1.0,15.0,6,4,11,7,0,0,2,2,0,0,,0,0,6,3,3,CompressionError
4806,257931,ResetStream,1,node.anonymous_namespace_145.BrotliDecoderContext.ResetStream,CompressionError node.anonymous_namespace_145.BrotliDecoderContext.ResetStream (),node_zlib.cc,"CompressionError BrotliDecoderContext::ResetStream() {
  return Init(alloc_, free_, alloc_opaque_);
}",1223.0,1225.0,1.0,1.0,3.0,0,0,3,3,0,0,1,1,0,0,,0,0,0,0,0,CompressionError
4807,257940,SetParams,1,node.anonymous_namespace_147.BrotliDecoderContext.SetParams,"CompressionError node.anonymous_namespace_147.BrotliDecoderContext.SetParams (int,uint32_t)",node_zlib.cc,"CompressionError BrotliDecoderContext::SetParams(int key, uint32_t value) {
  if (!BrotliDecoderSetParameter(state_.get(),
                                 static_cast<BrotliDecoderParameter>(key),
                                 value)) {
    return CompressionError(""Setting parameter failed"",
                            ""ERR_BROTLI_PARAM_SET_FAILED"",
                            -1);
  } else {
    return CompressionError {};
  }
}",1227.0,1237.0,1.0,1.0,11.0,4,4,3,3,0,0,2,2,0,0,,0,0,4,2,2,CompressionError
4808,257969,GetErrorInfo,1,node.anonymous_namespace_148.BrotliDecoderContext.GetErrorInfo,CompressionError node.anonymous_namespace_148.BrotliDecoderContext.GetErrorInfo (),node_zlib.cc,"CompressionError BrotliDecoderContext::GetErrorInfo() const {
  if (error_ != BROTLI_DECODER_NO_ERROR) {
    return CompressionError(""Decompression failed"",
                            error_string_.c_str(),
                            static_cast<int>(error_));
  } else if (flush_ == BROTLI_OPERATION_FINISH &&
             last_result_ == BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT) {
    // Match zlib's behaviour, as brotli doesn't have its own code for this.
    return CompressionError(""unexpected end of file"",
                            ""Z_BUF_ERROR"",
                            Z_BUF_ERROR);
  } else {
    return CompressionError {};
  }
}",1239.0,1253.0,1.0,1.0,15.0,3,3,4,3,0,0,2,2,0,0,,0,0,0,0,0,CompressionError
4809,258010,Make,1,node.anonymous_namespace_150.MakeClass.Make,"void node.anonymous_namespace_150.MakeClass.Make (Environment*,Local<Object>,char*)",node_zlib.cc,"static void Make(Environment* env, Local<Object> target, const char* name) {
    Isolate* isolate = env->isolate();
    Local<FunctionTemplate> z = NewFunctionTemplate(isolate, Stream::New);

    z->InstanceTemplate()->SetInternalFieldCount(
        Stream::kInternalFieldCount);
    z->Inherit(AsyncWrap::GetConstructorTemplate(env));

    SetProtoMethod(isolate, z, ""write"", Stream::template Write<true>);
    SetProtoMethod(isolate, z, ""writeSync"", Stream::template Write<false>);
    SetProtoMethod(isolate, z, ""close"", Stream::Close);

    SetProtoMethod(isolate, z, ""init"", Stream::Init);
    SetProtoMethod(isolate, z, ""params"", Stream::Params);
    SetProtoMethod(isolate, z, ""reset"", Stream::Reset);

    SetConstructorFunction(env->context(), target, name, z);
  }",1258.0,1275.0,3.0,3.0,18.0,18,5,34,9,0,0,1,1,0,0,,0,0,6,3,3,void
4810,258104,Make,1,node.anonymous_namespace_151.MakeClass.Make,void node.anonymous_namespace_151.MakeClass.Make (ExternalReferenceRegistry*),node_zlib.cc,"static void Make(ExternalReferenceRegistry* registry) {
    registry->Register(Stream::New);
    registry->Register(Stream::template Write<true>);
    registry->Register(Stream::template Write<false>);
    registry->Register(Stream::Close);
    registry->Register(Stream::Init);
    registry->Register(Stream::Params);
    registry->Register(Stream::Reset);
  }",1277.0,1285.0,3.0,3.0,9.0,14,2,14,2,0,0,1,1,0,0,,0,0,2,1,1,void
4811,258158,Initialize,1,node.anonymous_namespace_152.Initialize,"void node.anonymous_namespace_152.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)",node_zlib.cc,"void Initialize(Local<Object> target,
                Local<Value> unused,
                Local<Context> context,
                void* priv) {
  Environment* env = Environment::GetCurrent(context);

  MakeClass<ZlibStream>::Make(env, target, ""Zlib"");
  MakeClass<BrotliEncoderStream>::Make(env, target, ""BrotliEncoder"");
  MakeClass<BrotliDecoderStream>::Make(env, target, ""BrotliDecoder"");

  target->Set(env->context(),
              FIXED_ONE_BYTE_STRING(env->isolate(), ""ZLIB_VERSION""),
              FIXED_ONE_BYTE_STRING(env->isolate(), ZLIB_VERSION)).Check();
}",1288.0,1301.0,1.0,1.0,14.0,10,3,17,8,0,0,1,1,0,0,,0,0,8,4,4,void
4812,258218,RegisterExternalReferences,1,node.anonymous_namespace_153.RegisterExternalReferences,void node.anonymous_namespace_153.RegisterExternalReferences (ExternalReferenceRegistry*),node_zlib.cc,"void RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  MakeClass<ZlibStream>::Make(registry);
  MakeClass<BrotliEncoderStream>::Make(registry);
  MakeClass<BrotliDecoderStream>::Make(registry);
}",1303.0,1307.0,1.0,1.0,5.0,3,1,6,4,0,0,1,1,0,0,,0,0,2,1,1,void
4813,258238,DefineZlibConstants,1,node.DefineZlibConstants,void node.DefineZlibConstants (Local<Object>),node_zlib.cc,"void DefineZlibConstants(Local<Object> target) {
  NODE_DEFINE_CONSTANT(target, Z_NO_FLUSH);
  NODE_DEFINE_CONSTANT(target, Z_PARTIAL_FLUSH);
  NODE_DEFINE_CONSTANT(target, Z_SYNC_FLUSH);
  NODE_DEFINE_CONSTANT(target, Z_FULL_FLUSH);
  NODE_DEFINE_CONSTANT(target, Z_FINISH);
  NODE_DEFINE_CONSTANT(target, Z_BLOCK);

  // return/error codes
  NODE_DEFINE_CONSTANT(target, Z_OK);
  NODE_DEFINE_CONSTANT(target, Z_STREAM_END);
  NODE_DEFINE_CONSTANT(target, Z_NEED_DICT);
  NODE_DEFINE_CONSTANT(target, Z_ERRNO);
  NODE_DEFINE_CONSTANT(target, Z_STREAM_ERROR);
  NODE_DEFINE_CONSTANT(target, Z_DATA_ERROR);
  NODE_DEFINE_CONSTANT(target, Z_MEM_ERROR);
  NODE_DEFINE_CONSTANT(target, Z_BUF_ERROR);
  NODE_DEFINE_CONSTANT(target, Z_VERSION_ERROR);

  NODE_DEFINE_CONSTANT(target, Z_NO_COMPRESSION);
  NODE_DEFINE_CONSTANT(target, Z_BEST_SPEED);
  NODE_DEFINE_CONSTANT(target, Z_BEST_COMPRESSION);
  NODE_DEFINE_CONSTANT(target, Z_DEFAULT_COMPRESSION);
  NODE_DEFINE_CONSTANT(target, Z_FILTERED);
  NO...",1311.0,1429.0,1.0,2.0,119.0,3535,9,3296,208,0,0,1,1,0,0,,0,0,2,1,1,void
4814,268846,Apply,1,node.permission.ChildProcessPermission.Apply,"void node.permission.ChildProcessPermission.Apply (ANY,PermissionScope)",permission\child_process_permission.cc,"void ChildProcessPermission::Apply(const std::string& allow,
                                   PermissionScope scope) {
  deny_all_ = true;
}",12.0,15.0,1.0,1.0,4.0,1,1,1,1,0,0,1,1,0,0,,0,0,4,2,2,void
4815,268855,is_granted,1,node.permission.ChildProcessPermission.is_granted,"bool node.permission.ChildProcessPermission.is_granted (PermissionScope,ANY)",permission\child_process_permission.cc,"bool ChildProcessPermission::is_granted(PermissionScope perm,
                                        const std::string_view& param) {
  return deny_all_ == false;
}",17.0,20.0,1.0,1.0,4.0,1,1,1,1,0,0,1,1,0,0,,0,0,4,2,2,bool
4816,268902,WildcardIfDir,1,anonymous_namespace_1.WildcardIfDir,string anonymous_namespace_1.WildcardIfDir (ANY),permission\fs_permission.cc,"std::string WildcardIfDir(const std::string& res) noexcept {
  uv_fs_t req;
  int rc = uv_fs_stat(nullptr, &req, res.c_str(), nullptr);
  if (rc == 0) {
    const uv_stat_t* const s = static_cast<const uv_stat_t*>(req.ptr);
    if (s->st_mode & S_IFDIR) {
      // add wildcard when directory
      if (res.back() == node::kPathSeparator) {
        return res + ""*"";
      }
      return res + node::kPathSeparator + ""*"";
    }
  }
  uv_fs_req_cleanup(&req);
  return res;
}",16.0,31.0,1.0,1.0,16.0,17,8,15,6,0,0,4,7,0,0,,0,0,2,1,1,string
4817,268967,FreeRecursivelyNode,1,anonymous_namespace_2.FreeRecursivelyNode,void anonymous_namespace_2.FreeRecursivelyNode (ANY*),permission\fs_permission.cc,"void FreeRecursivelyNode(
    node::permission::FSPermission::RadixTree::Node* node) {
  if (node == nullptr) {
    return;
  }

  if (node->children.size()) {
    for (auto& c : node->children) {
      FreeRecursivelyNode(c.second);
    }
  }

  if (node->wildcard_child != nullptr) {
    delete node->wildcard_child;
  }
  delete node;
}",33.0,49.0,1.0,1.0,17.0,10,5,7,2,0,0,5,6,0,0,,0,0,2,1,1,void
4818,269009,is_tree_granted,1,anonymous_namespace_3.is_tree_granted,"bool anonymous_namespace_3.is_tree_granted (ANY*,ANY)",permission\fs_permission.cc,"bool is_tree_granted(node::permission::FSPermission::RadixTree* granted_tree,
                     const std::string_view& param) {
#ifdef _WIN32
  // is UNC file path
  if (param.rfind(""\\\\"", 0) == 0) {
    // return lookup with normalized param
    int starting_pos = 4;  // ""\\?\""
    if (param.rfind(""\\\\?\\UNC\\"") == 0) {
      starting_pos += 4;  // ""UNC\""
    }
    auto normalized = param.substr(starting_pos);
    return granted_tree->Lookup(normalized, true);
  }
#endif
  return granted_tree->Lookup(param, true);
}",51.0,66.0,1.0,1.0,16.0,1,1,2,2,0,0,1,1,0,0,,0,0,4,2,2,bool
4819,269024,Apply,1,node.permission.FSPermission.Apply,"void node.permission.FSPermission.Apply (ANY,PermissionScope)",permission\fs_permission.cc,"void FSPermission::Apply(const std::string& allow, PermissionScope scope) {
  for (const auto& res : SplitString(allow, ',')) {
    if (res == ""*"") {
      if (scope == PermissionScope::kFileSystemRead) {
        deny_all_in_ = false;
        allow_all_in_ = true;
      } else {
        deny_all_out_ = false;
        allow_all_out_ = true;
      }
      return;
    }
    GrantAccess(scope, res);
  }
}",76.0,90.0,1.0,1.0,15.0,5,3,8,6,0,0,4,7,0,0,,0,0,4,2,2,void
4820,269066,GrantAccess,1,node.permission.FSPermission.GrantAccess,"void node.permission.FSPermission.GrantAccess (PermissionScope,ANY)",permission\fs_permission.cc,"void FSPermission::GrantAccess(PermissionScope perm, const std::string& res) {
  const std::string path = WildcardIfDir(res);
  if (perm == PermissionScope::kFileSystemRead) {
    granted_in_fs_.Insert(path);
    deny_all_in_ = false;
  } else if (perm == PermissionScope::kFileSystemWrite) {
    granted_out_fs_.Insert(path);
    deny_all_out_ = false;
  }
}",92.0,101.0,1.0,1.0,10.0,5,3,7,6,0,0,2,2,0,0,,0,0,4,2,2,void
4821,269109,is_granted,1,node.permission.FSPermission.is_granted,"bool node.permission.FSPermission.is_granted (PermissionScope,ANY)",permission\fs_permission.cc,"bool FSPermission::is_granted(PermissionScope perm,
                              const std::string_view& param = """") {
  switch (perm) {
    case PermissionScope::kFileSystem:
      return allow_all_in_ && allow_all_out_;
    case PermissionScope::kFileSystemRead:
      return !deny_all_in_ &&
             ((param.empty() && allow_all_in_) || allow_all_in_ ||
              is_tree_granted(&granted_in_fs_, param));
    case PermissionScope::kFileSystemWrite:
      return !deny_all_out_ &&
             ((param.empty() && allow_all_out_) || allow_all_out_ ||
              is_tree_granted(&granted_out_fs_, param));
    default:
      return false;
  }
}",103.0,119.0,1.0,1.0,17.0,18,5,18,9,0,0,2,2,0,0,,0,0,4,2,2,bool
4822,269171,RadixTree,1,node.permission.FSPermission.RadixTree.RadixTree,ANY node.permission.FSPermission.RadixTree.RadixTree (),permission\fs_permission.cc,"FSPermission::RadixTree::RadixTree() : root_node_(new Node("""")) {}",121.0,121.0,1.0,66.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
4823,269175,~RadixTree,1,node.permission.FSPermission.RadixTree.~RadixTree,ANY node.permission.FSPermission.RadixTree.~RadixTree (),permission\fs_permission.cc,"FSPermission::RadixTree::~RadixTree() {
  FreeRecursivelyNode(root_node_);
}",123.0,125.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
4824,269180,Lookup,1,node.permission.FSPermission.RadixTree.Lookup,"bool node.permission.FSPermission.RadixTree.Lookup (ANY,bool)",permission\fs_permission.cc,"bool FSPermission::RadixTree::Lookup(const std::string_view& s,
                                     bool when_empty_return = false) {
  FSPermission::RadixTree::Node* current_node = root_node_;
  if (current_node->children.size() == 0) {
    return when_empty_return;
  }

  unsigned int parent_node_prefix_len = current_node->prefix.length();
  const std::string path(s);
  auto path_len = path.length();

  while (true) {
    if (parent_node_prefix_len == path_len && current_node->IsEndNode()) {
      return true;
    }

    auto node = current_node->NextNode(path, parent_node_prefix_len);
    if (node == nullptr) {
      return false;
    }

    current_node = node;
    parent_node_prefix_len += current_node->prefix.length();
    if (current_node->wildcard_child != nullptr &&
        path_len >= (parent_node_prefix_len - 2 /* slash* */)) {
      return true;
    }
  }
}",127.0,155.0,1.0,1.0,29.0,24,9,24,8,0,0,6,9,0,0,,0,0,4,2,2,bool
4825,269278,Insert,1,node.permission.FSPermission.RadixTree.Insert,void node.permission.FSPermission.RadixTree.Insert (ANY),permission\fs_permission.cc,"void FSPermission::RadixTree::Insert(const std::string& path) {
  FSPermission::RadixTree::Node* current_node = root_node_;

  unsigned int parent_node_prefix_len = current_node->prefix.length();
  int path_len = path.length();

  for (int i = 1; i <= path_len; ++i) {
    bool is_wildcard_node = path[i - 1] == '*';
    bool is_last_char = i == path_len;

    if (is_wildcard_node || is_last_char) {
      std::string node_path = path.substr(parent_node_prefix_len, i);
      current_node = current_node->CreateChild(node_path);
    }

    if (is_wildcard_node) {
      current_node = current_node->CreateWildcardChild();
      parent_node_prefix_len = i;
    }
  }
}",157.0,177.0,1.0,1.0,21.0,22,8,29,9,0,0,4,6,0,0,,0,0,2,1,1,void
4826,269407,Has,1,node.permission.anonymous_namespace_1.Has,void node.permission.anonymous_namespace_1.Has (FunctionCallbackInfo<Value>),permission\permission.cc,"static void Has(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  v8::Isolate* isolate = env->isolate();
  CHECK(args[0]->IsString());

  String::Utf8Value utf8_deny_scope(isolate, args[0]);
  if (*utf8_deny_scope == nullptr) {
    return;
  }

  const std::string deny_scope = *utf8_deny_scope;
  PermissionScope scope = Permission::StringToPermission(deny_scope);
  if (scope == PermissionScope::kPermissionsRoot) {
    return args.GetReturnValue().Set(false);
  }

  if (args.Length() > 1 && !args[1]->IsUndefined()) {
    String::Utf8Value utf8_arg(isolate, args[1]);
    if (*utf8_arg == nullptr) {
      return;
    }
    return args.GetReturnValue().Set(
        env->permission()->is_granted(scope, *utf8_arg));
  }

  return args.GetReturnValue().Set(env->permission()->is_granted(scope));
}",30.0,56.0,1.0,1.0,27.0,35,9,29,10,0,0,5,6,0,0,,0,0,2,1,1,void
4827,269539,PermissionToString,1,node.permission.Permission.PermissionToString,const char* node.permission.Permission.PermissionToString (PermissionScope),permission\permission.cc,"const char* Permission::PermissionToString(const PermissionScope perm) {
  PERMISSIONS(V)
  return nullptr;
}",62.0,65.0,1.0,1.0,4.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,const char*
4828,269548,StringToPermission,1,node.permission.Permission.StringToPermission,PermissionScope node.permission.Permission.StringToPermission (ANY),permission\permission.cc,"PermissionScope Permission::StringToPermission(const std::string& perm) {
  PERMISSIONS(V)
  return PermissionScope::kPermissionsRoot;
}",70.0,73.0,1.0,1.0,4.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,PermissionScope
4829,269559,Permission,1,node.permission.Permission.Permission,ANY node.permission.Permission.Permission (),permission\permission.cc,"Permission::Permission() : enabled_(false) {
  std::shared_ptr<PermissionBase> fs = std::make_shared<FSPermission>();
  std::shared_ptr<PermissionBase> child_p =
      std::make_shared<ChildProcessPermission>();
  std::shared_ptr<PermissionBase> worker_t =
      std::make_shared<WorkerPermission>();
#define V(Name, _, __)                                                         \
  nodes_.insert(std::make_pair(PermissionScope::k##Name, fs));
  FILESYSTEM_PERMISSIONS(V)
#undef V
#define V(Name, _, __)                                                         \
  nodes_.insert(std::make_pair(PermissionScope::k##Name, child_p));
  CHILD_PROCESS_PERMISSIONS(V)
#undef V
#define V(Name, _, __)                                                         \
  nodes_.insert(std::make_pair(PermissionScope::k##Name, worker_t));
  WORKER_THREADS_PERMISSIONS(V)
#undef V
}",76.0,94.0,1.0,1.0,19.0,15,4,12,5,0,0,1,1,0,0,,0,0,0,0,0,ANY
4830,269605,ThrowAccessDenied,1,node.permission.Permission.ThrowAccessDenied,"void node.permission.Permission.ThrowAccessDenied (Environment*,PermissionScope,ANY)",permission\permission.cc,"void Permission::ThrowAccessDenied(Environment* env,
                                   PermissionScope perm,
                                   const std::string_view& res) {
  Local<Value> err = ERR_ACCESS_DENIED(env->isolate());
  CHECK(err->IsObject());
  if (err.As<Object>()
          ->Set(env->context(),
                env->permission_string(),
                v8::String::NewFromUtf8(env->isolate(),
                                        PermissionToString(perm),
                                        v8::NewStringType::kNormal)
                    .ToLocalChecked())
          .IsNothing() ||
      err.As<Object>()
          ->Set(env->context(),
                env->resource_string(),
                v8::String::NewFromUtf8(env->isolate(),
                                        std::string(res).c_str(),
                                        v8::NewStringType::kNormal)
                    .ToLocalChecked())
          .IsNothing())
    return;
  env->isolate()->ThrowExce...",96.0,119.0,1.0,1.0,24.0,32,6,26,10,0,0,2,2,0,0,,0,0,6,3,3,void
4831,269722,EnablePermissions,1,node.permission.Permission.EnablePermissions,void node.permission.Permission.EnablePermissions (),permission\permission.cc,"void Permission::EnablePermissions() {
  if (!enabled_) {
    enabled_ = true;
  }
}",121.0,125.0,1.0,1.0,5.0,2,2,2,1,0,0,2,2,0,0,,0,0,0,0,0,void
4832,269733,Apply,1,node.permission.Permission.Apply,"void node.permission.Permission.Apply (ANY,PermissionScope)",permission\permission.cc,"void Permission::Apply(const std::string& allow, PermissionScope scope) {
  auto permission = nodes_.find(scope);
  if (permission != nodes_.end()) {
    permission->second->Apply(allow, scope);
  }
}",127.0,132.0,1.0,1.0,6.0,6,4,8,4,0,0,2,2,0,0,,0,0,4,2,2,void
4833,269763,Initialize,1,node.permission.Initialize,"void node.permission.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)",permission\permission.cc,"void Initialize(Local<Object> target,
                Local<Value> unused,
                Local<Context> context,
                void* priv) {
  SetMethodNoSideEffect(context, target, ""has"", Has);

  target->SetIntegrityLevel(context, v8::IntegrityLevel::kFrozen).FromJust();
}",134.0,141.0,1.0,1.0,8.0,4,2,6,4,0,0,1,1,0,0,,0,0,8,4,4,void
4834,269789,RegisterExternalReferences,1,node.permission.RegisterExternalReferences,void node.permission.RegisterExternalReferences (ExternalReferenceRegistry*),permission\permission.cc,"void RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  registry->Register(Has);
}",143.0,145.0,1.0,1.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,void
4835,269849,Apply,1,node.permission.WorkerPermission.Apply,"void node.permission.WorkerPermission.Apply (ANY,PermissionScope)",permission\worker_permission.cc,"void WorkerPermission::Apply(const std::string& allow, PermissionScope scope) {
  deny_all_ = true;
}",12.0,14.0,1.0,1.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,4,2,2,void
4836,269858,is_granted,1,node.permission.WorkerPermission.is_granted,"bool node.permission.WorkerPermission.is_granted (PermissionScope,ANY)",permission\worker_permission.cc,"bool WorkerPermission::is_granted(PermissionScope perm,
                                  const std::string_view& param) {
  return deny_all_ == false;
}",16.0,19.0,1.0,1.0,4.0,1,1,1,1,0,0,1,1,0,0,,0,0,4,2,2,bool
4837,269907,Instantiate,1,node.PipeWrap.Instantiate,"MaybeLocal<Object> node.PipeWrap.Instantiate (Environment*,AsyncWrap*,ANY)",pipe_wrap.cc,"MaybeLocal<Object> PipeWrap::Instantiate(Environment* env,
                                         AsyncWrap* parent,
                                         PipeWrap::SocketType type) {
  EscapableHandleScope handle_scope(env->isolate());
  AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(parent);
  CHECK_EQ(false, env->pipe_constructor_template().IsEmpty());
  Local<Function> constructor = env->pipe_constructor_template()
                                    ->GetFunction(env->context())
                                    .ToLocalChecked();
  CHECK_EQ(false, constructor.IsEmpty());
  Local<Value> type_value = Int32::New(env->isolate(), type);
  return handle_scope.EscapeMaybe(
      constructor->NewInstance(env->context(), 1, &type_value));
}",50.0,63.0,1.0,1.0,14.0,20,6,19,10,0,0,1,1,0,0,,0,0,6,3,3,MaybeLocal<Object>
4838,269989,Initialize,1,node.PipeWrap.Initialize,"void node.PipeWrap.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)",pipe_wrap.cc,"void PipeWrap::Initialize(Local<Object> target,
                          Local<Value> unused,
                          Local<Context> context,
                          void* priv) {
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, New);
  t->InstanceTemplate()
    ->SetInternalFieldCount(StreamBase::kInternalFieldCount);

  t->Inherit(LibuvStreamWrap::GetConstructorTemplate(env));

  SetProtoMethod(isolate, t, ""bind"", Bind);
  SetProtoMethod(isolate, t, ""listen"", Listen);
  SetProtoMethod(isolate, t, ""connect"", Connect);
  SetProtoMethod(isolate, t, ""open"", Open);

#ifdef _WIN32
  SetProtoMethod(isolate, t, ""setPendingInstances"", SetPendingInstances);
#endif

  SetProtoMethod(isolate, t, ""fchmod"", Fchmod);

  SetConstructorFunction(context, target, ""Pipe"", t);
  env->set_pipe_constructor_template(t);

  // Create FunctionTemplate for PipeConnectWrap.
  auto cwt = BaseObject::Mak...",66.0,108.0,1.0,2.0,43.0,190,7,208,34,0,0,1,1,0,0,,0,0,8,4,4,void
4839,270619,RegisterExternalReferences,1,node.PipeWrap.RegisterExternalReferences,void node.PipeWrap.RegisterExternalReferences (ExternalReferenceRegistry*),pipe_wrap.cc,"void PipeWrap::RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  registry->Register(New);
  registry->Register(Bind);
  registry->Register(Listen);
  registry->Register(Connect);
  registry->Register(Open);
#ifdef _WIN32
  registry->Register(SetPendingInstances);
#endif
  registry->Register(Fchmod);
}",110.0,120.0,1.0,1.0,11.0,6,1,12,7,0,0,1,1,0,0,,0,0,2,1,1,void
4840,270654,New,1,node.PipeWrap.New,void node.PipeWrap.New (FunctionCallbackInfo<Value>),pipe_wrap.cc,"void PipeWrap::New(const FunctionCallbackInfo<Value>& args) {
  // This constructor should not be exposed to public javascript.
  // Therefore we assert that we are not trying to call this as a
  // normal function.
  CHECK(args.IsConstructCall());
  CHECK(args[0]->IsInt32());
  Environment* env = Environment::GetCurrent(args);

  int type_value = args[0].As<Int32>()->Value();
  PipeWrap::SocketType type = static_cast<PipeWrap::SocketType>(type_value);

  bool ipc;
  ProviderType provider;
  switch (type) {
    case SOCKET:
      provider = PROVIDER_PIPEWRAP;
      ipc = false;
      break;
    case SERVER:
      provider = PROVIDER_PIPESERVERWRAP;
      ipc = false;
      break;
    case IPC:
      provider = PROVIDER_PIPEWRAP;
      ipc = true;
      break;
    default:
      UNREACHABLE();
  }

  new PipeWrap(env, args.This(), provider, ipc);
}",122.0,153.0,1.0,1.0,32.0,19,6,27,13,0,0,5,2,0,0,,0,0,2,1,1,void
4841,270740,PipeWrap,1,node.PipeWrap.PipeWrap,"ANY node.PipeWrap.PipeWrap (Environment*,Local<Object>,ProviderType,bool)",pipe_wrap.cc,"PipeWrap::PipeWrap(Environment* env,
                   Local<Object> object,
                   ProviderType provider,
                   bool ipc)
    : ConnectionWrap(env, object, provider) {
  int r = uv_pipe_init(env->event_loop(), &handle_, ipc);
  CHECK_EQ(r, 0);  // How do we proxy this error up to javascript?
                   // Suggestion: uv_pipe_init() returns void.
}",156.0,164.0,1.0,1.0,9.0,3,3,5,4,0,0,1,1,0,0,,0,0,8,4,4,ANY
4842,270762,Bind,1,node.PipeWrap.Bind,void node.PipeWrap.Bind (FunctionCallbackInfo<Value>),pipe_wrap.cc,"void PipeWrap::Bind(const FunctionCallbackInfo<Value>& args) {
  PipeWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
  node::Utf8Value name(args.GetIsolate(), args[0]);
  int err = uv_pipe_bind(&wrap->handle_, *name);
  args.GetReturnValue().Set(err);
}",167.0,173.0,1.0,1.0,7.0,10,6,9,4,0,0,1,1,0,0,,0,0,2,1,1,void
4843,270802,Fchmod,1,node.PipeWrap.Fchmod,void node.PipeWrap.Fchmod (ANY),pipe_wrap.cc,"void PipeWrap::Fchmod(const v8::FunctionCallbackInfo<v8::Value>& args) {
  PipeWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
  CHECK(args[0]->IsInt32());
  int mode = args[0].As<Int32>()->Value();
  int err = uv_pipe_chmod(&wrap->handle_, mode);
  args.GetReturnValue().Set(err);
}",187.0,194.0,1.0,1.0,8.0,13,5,10,4,0,0,1,1,0,0,,0,0,2,1,1,void
4844,270851,Listen,1,node.PipeWrap.Listen,void node.PipeWrap.Listen (FunctionCallbackInfo<Value>),pipe_wrap.cc,"void PipeWrap::Listen(const FunctionCallbackInfo<Value>& args) {
  PipeWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
  Environment* env = wrap->env();
  int backlog;
  if (!args[0]->Int32Value(env->context()).To(&backlog)) return;
  int err = uv_listen(reinterpret_cast<uv_stream_t*>(&wrap->handle_),
                      backlog,
                      OnConnection);
  args.GetReturnValue().Set(err);
}",197.0,207.0,1.0,1.0,11.0,16,7,13,6,0,0,2,2,0,0,,0,0,2,1,1,void
4845,270911,Open,1,node.PipeWrap.Open,void node.PipeWrap.Open (FunctionCallbackInfo<Value>),pipe_wrap.cc,"void PipeWrap::Open(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  PipeWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  int fd;
  if (!args[0]->Int32Value(env->context()).To(&fd)) return;

  int err = uv_pipe_open(&wrap->handle_, fd);
  if (err == 0) wrap->set_fd(fd);

  args.GetReturnValue().Set(err);
}",210.0,223.0,1.0,1.0,14.0,17,7,16,6,0,0,3,3,0,0,,0,0,2,1,1,void
4846,270979,Connect,1,node.PipeWrap.Connect,void node.PipeWrap.Connect (FunctionCallbackInfo<Value>),pipe_wrap.cc,"void PipeWrap::Connect(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  PipeWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  CHECK(args[0]->IsObject());
  CHECK(args[1]->IsString());

  Local<Object> req_wrap_obj = args[0].As<Object>();
  node::Utf8Value name(env->isolate(), args[1]);

  ConnectWrap* req_wrap =
      new ConnectWrap(env, req_wrap_obj, AsyncWrap::PROVIDER_PIPECONNECTWRAP);
  req_wrap->Dispatch(uv_pipe_connect,
                     &wrap->handle_,
                     *name,
                     AfterConnect);

  TRACE_EVENT_NESTABLE_ASYNC_BEGIN1(TRACING_CATEGORY_NODE2(net, native),
                                    ""connect"",
                                    req_wrap,
                                    ""pipe_path"",
                                    TRACE_STR_COPY(*name));

  args.GetReturnValue().Set(0);  // uv_pipe_connect() doesn't return errors.
}",226.0,252.0,1.0,1.0,27.0,25,9,28,15,0,0,1,1,0,0,,0,0,2,1,1,void
4847,271109,Initialize,1,node.anonymous_namespace_2.ProcessWrap.Initialize,"void node.anonymous_namespace_2.ProcessWrap.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)",process_wrap.cc,"static void Initialize(Local<Object> target,
                         Local<Value> unused,
                         Local<Context> context,
                         void* priv) {
    Environment* env = Environment::GetCurrent(context);
    Isolate* isolate = env->isolate();
    Local<FunctionTemplate> constructor = NewFunctionTemplate(isolate, New);
    constructor->InstanceTemplate()->SetInternalFieldCount(
        ProcessWrap::kInternalFieldCount);

    constructor->Inherit(HandleWrap::GetConstructorTemplate(env));

    SetProtoMethod(isolate, constructor, ""spawn"", Spawn);
    SetProtoMethod(isolate, constructor, ""kill"", Kill);

    SetConstructorFunction(context, target, ""Process"", constructor);
  }",52.0,68.0,3.0,3.0,17.0,12,5,22,11,0,0,1,1,0,0,,0,0,8,4,4,void
4848,271176,ProcessWrap,1,node.anonymous_namespace_5.ProcessWrap.ProcessWrap,"ANY node.anonymous_namespace_5.ProcessWrap.ProcessWrap (Environment*,Local<Object>)",process_wrap.cc,"ProcessWrap(Environment* env, Local<Object> object)
      : HandleWrap(env,
                   object,
                   reinterpret_cast<uv_handle_t*>(&process_),
                   AsyncWrap::PROVIDER_PROCESSWRAP) {
    MarkAsUninitialized();
  }",84.0,90.0,3.0,3.0,7.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,ANY
4849,271183,StreamForWrap,1,node.anonymous_namespace_6.ProcessWrap.StreamForWrap,"uv_stream_t node.anonymous_namespace_6.ProcessWrap.StreamForWrap (Environment*,Local<Object>)",process_wrap.cc,"static uv_stream_t* StreamForWrap(Environment* env, Local<Object> stdio) {
    Local<String> handle_key = env->handle_string();
    // This property has always been set by JS land if we are in this code path.
    Local<Object> handle =
        stdio->Get(env->context(), handle_key).ToLocalChecked().As<Object>();

    uv_stream_t* stream = LibuvStreamWrap::From(env, handle)->stream();
    CHECK_NOT_NULL(stream);
    return stream;
  }",92.0,101.0,3.0,3.0,10.0,14,5,16,9,0,0,1,1,0,0,,0,0,4,2,2,uv_stream_t
4850,271236,ParseStdioOptions,1,node.anonymous_namespace_7.ProcessWrap.ParseStdioOptions,"void node.anonymous_namespace_7.ProcessWrap.ParseStdioOptions (Environment*,Local<Object>,uv_process_options_t*)",process_wrap.cc,"static void ParseStdioOptions(Environment* env,
                                Local<Object> js_options,
                                uv_process_options_t* options) {
    Local<Context> context = env->context();
    Local<String> stdio_key = env->stdio_string();
    Local<Array> stdios =
        js_options->Get(context, stdio_key).ToLocalChecked().As<Array>();

    uint32_t len = stdios->Length();
    options->stdio = new uv_stdio_container_t[len];
    options->stdio_count = len;

    for (uint32_t i = 0; i < len; i++) {
      Local<Object> stdio =
          stdios->Get(context, i).ToLocalChecked().As<Object>();
      Local<Value> type =
          stdio->Get(context, env->type_string()).ToLocalChecked();

      if (type->StrictEquals(env->ignore_string())) {
        options->stdio[i].flags = UV_IGNORE;
      } else if (type->StrictEquals(env->pipe_string())) {
        options->stdio[i].flags = static_cast<uv_stdio_flags>(
            UV_CREATE_PIPE | UV_READABLE_PIPE | UV_WRITAB...",103.0,144.0,3.0,3.0,42.0,41,7,40,18,0,0,3,4,0,0,,0,0,6,3,3,void
4851,271546,Spawn,1,node.anonymous_namespace_8.ProcessWrap.Spawn,void node.anonymous_namespace_8.ProcessWrap.Spawn (FunctionCallbackInfo<Value>),process_wrap.cc,"static void Spawn(const FunctionCallbackInfo<Value>& args) {
    Environment* env = Environment::GetCurrent(args);
    Local<Context> context = env->context();
    ProcessWrap* wrap;
    ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
    THROW_IF_INSUFFICIENT_PERMISSIONS(
        env, permission::PermissionScope::kChildProcess, """");

    Local<Object> js_options =
        args[0]->ToObject(env->context()).ToLocalChecked();

    uv_process_options_t options;
    memset(&options, 0, sizeof(uv_process_options_t));

    options.exit_cb = OnExit;

    // options.uid
    Local<Value> uid_v =
        js_options->Get(context, env->uid_string()).ToLocalChecked();
    if (!uid_v->IsUndefined() && !uid_v->IsNull()) {
      CHECK(uid_v->IsInt32());
      const int32_t uid = uid_v.As<Int32>()->Value();
      options.flags |= UV_PROCESS_SETUID;
      options.uid = static_cast<uv_uid_t>(uid);
    }

    // options.gid
    Local<Value> gid_v =
        js_options->Get(context, env->gid_string()).ToL...",146.0,291.0,3.0,3.0,146.0,210,16,197,45,0,3,17,21,0,0,,0,3,2,1,1,void
4852,272252,Kill,1,node.anonymous_namespace_10.ProcessWrap.Kill,void node.anonymous_namespace_10.ProcessWrap.Kill (FunctionCallbackInfo<Value>),process_wrap.cc,"static void Kill(const FunctionCallbackInfo<Value>& args) {
    Environment* env = Environment::GetCurrent(args);
    ProcessWrap* wrap;
    ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
    int signal = args[0]->Int32Value(env->context()).FromJust();
    int err = uv_process_kill(&wrap->process_, signal);
    args.GetReturnValue().Set(err);
  }",293.0,300.0,3.0,3.0,8.0,14,5,13,6,0,1,1,1,0,0,,0,1,2,1,1,void
4853,272306,OnExit,1,node.anonymous_namespace_11.ProcessWrap.OnExit,"void node.anonymous_namespace_11.ProcessWrap.OnExit (uv_process_t*,int64_t,int)",process_wrap.cc,"static void OnExit(uv_process_t* handle,
                     int64_t exit_status,
                     int term_signal) {
    ProcessWrap* wrap = ContainerOf(&ProcessWrap::process_, handle);
    CHECK_EQ(&wrap->process_, handle);

    Environment* env = wrap->env();
    HandleScope handle_scope(env->isolate());
    Context::Scope context_scope(env->context());

    Local<Value> argv[] = {
      Number::New(env->isolate(), static_cast<double>(exit_status)),
      OneByteString(env->isolate(), signo_string(term_signal))
    };

    wrap->MakeCallback(env->onexit_string(), arraysize(argv), argv);
  }",302.0,318.0,3.0,3.0,17.0,17,6,19,8,0,2,1,1,0,0,,0,2,6,3,3,void
4854,272517,SetOption,1,node.quic.SetOption,"bool node.quic.SetOption<Opt,std::stringOpt::*> (Environment*,Opt*,ANY,ANY)",quic\defs.hpp,"bool SetOption(Environment* env,
               Opt* options,
               const v8::Local<v8::Object>& object,
               const v8::Local<v8::String>& name) {
  v8::Local<v8::Value> value;
  if (!object->Get(env->context(), name).ToLocal(&value)) return false;

  if (!value->IsUndefined()) {
    CHECK_IMPLIES(!value->IsBigInt(), value->IsNumber());

    uint64_t val = 0;
    if (value->IsBigInt()) {
      bool lossless = true;
      val = value.As<v8::BigInt>()->Uint64Value(&lossless);
      if (!lossless) {
        Utf8Value label(env->isolate(), name);
        THROW_ERR_OUT_OF_RANGE(
            env, (""options."" + label.ToString() + "" is out of range"").c_str());
        return false;
      }
    } else {
      val = static_cast<int64_t>(value.As<v8::Number>()->Value());
    }
    options->*member = val;
  }
  return true;
}",41.0,67.0,1.0,1.0,27.0,15,8,13,8,0,0,3,3,0,0,,0,0,8,4,4,bool
4855,272757,IncrementStat,1,node.quic.IncrementStat,"void node.quic.IncrementStat<Stats,uint64_tStats::*> (Stats*,uint64_t)",quic\defs.hpp,"void IncrementStat(Stats* stats, uint64_t amt = 1) {
  stats->*member += amt;
}",74.0,76.0,1.0,1.0,3.0,2,2,3,3,0,0,1,1,0,0,,0,0,4,2,2,void
4856,272768,RecordTimestampStat,1,node.quic.RecordTimestampStat,"void node.quic.RecordTimestampStat<Stats,uint64_tStats::*> (Stats*)",quic\defs.hpp,"void RecordTimestampStat(Stats* stats) {
  stats->*member = uv_hrtime();
}",79.0,81.0,1.0,1.0,3.0,2,2,2,2,0,0,1,1,0,0,,0,0,2,1,1,void
4857,272778,SetStat,1,node.quic.SetStat,"void node.quic.SetStat<Stats,uint64_tStats::*> (Stats*,uint64_t)",quic\defs.hpp,"void SetStat(Stats* stats, uint64_t val) {
  stats->*member = val;
}",84.0,86.0,1.0,1.0,3.0,2,2,3,3,0,0,1,1,0,0,,0,0,4,2,2,void
4858,272789,GetStat,1,node.quic.GetStat,"uint64_t node.quic.GetStat<Stats,uint64_tStats::*> (Stats*)",quic\defs.hpp,"uint64_t GetStat(Stats* stats) {
  return stats->*member;
}",89.0,91.0,1.0,1.0,3.0,1,1,2,2,0,0,1,1,0,0,,0,0,2,1,1,uint64_t
4859,273123,<lambda>0,1,node.anonymous_namespace_11.SignalWrap.Start.<lambda>0,"ANY node.anonymous_namespace_11.SignalWrap.Start.<lambda>0 (uv_signal_t*,int)",signal_wrap.cc,"[](uv_signal_t* handle, int signum) {
          SignalWrap* wrap = ContainerOf(&SignalWrap::handle_, handle);
          Environment* env = wrap->env();
          HandleScope handle_scope(env->isolate());
          Context::Scope context_scope(env->context());
          Local<Value> arg = Integer::New(env->isolate(), signum);
          wrap->MakeCallback(env->onsignal_string(), 1, &arg);
        }",123.0,130.0,9.0,9.0,8.0,15,6,16,9,0,1,1,1,0,0,,0,1,4,2,2,ANY
4860,273205,DecreaseSignalHandlerCount,1,node.DecreaseSignalHandlerCount,void node.DecreaseSignalHandlerCount (int),signal_wrap.cc,"void DecreaseSignalHandlerCount(int signum) {
  Mutex::ScopedLock lock(handled_signals_mutex);
  int64_t new_handler_count = --handled_signals[signum];
  CHECK_GE(new_handler_count, 0);
  if (new_handler_count == 0)
    handled_signals.erase(signum);
}",163.0,169.0,1.0,1.0,7.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
4861,273213,Initialize,1,node.anonymous_namespace_2.SignalWrap.Initialize,"void node.anonymous_namespace_2.SignalWrap.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)",signal_wrap.cc,"static void Initialize(Local<Object> target,
                         Local<Value> unused,
                         Local<Context> context,
                         void* priv) {
    Environment* env = Environment::GetCurrent(context);
    Isolate* isolate = env->isolate();
    Local<FunctionTemplate> constructor = NewFunctionTemplate(isolate, New);
    constructor->InstanceTemplate()->SetInternalFieldCount(
        SignalWrap::kInternalFieldCount);
    constructor->Inherit(HandleWrap::GetConstructorTemplate(env));

    SetProtoMethod(isolate, constructor, ""start"", Start);
    SetProtoMethod(isolate, constructor, ""stop"", Stop);

    SetConstructorFunction(context, target, ""Signal"", constructor);
  }",51.0,66.0,3.0,3.0,16.0,12,5,22,11,0,0,1,1,0,0,,0,0,8,4,4,void
4862,273279,RegisterExternalReferences,1,node.anonymous_namespace_5.SignalWrap.RegisterExternalReferences,void node.anonymous_namespace_5.SignalWrap.RegisterExternalReferences (ExternalReferenceRegistry*),signal_wrap.cc,"static void RegisterExternalReferences(ExternalReferenceRegistry* registry) {
    registry->Register(New);
    registry->Register(Start);
    registry->Register(Stop);
  }",68.0,72.0,3.0,3.0,5.0,3,1,4,2,0,0,1,1,0,0,,0,0,2,1,1,void
4863,273300,SignalWrap,1,node.anonymous_namespace_8.SignalWrap.SignalWrap,"ANY node.anonymous_namespace_8.SignalWrap.SignalWrap (Environment*,Local<Object>)",signal_wrap.cc,"SignalWrap(Environment* env, Local<Object> object)
      : HandleWrap(env,
                   object,
                   reinterpret_cast<uv_handle_t*>(&handle_),
                   AsyncWrap::PROVIDER_SIGNALWRAP) {
    int r = uv_signal_init(env->event_loop(), &handle_);
    CHECK_EQ(r, 0);
  }",88.0,95.0,3.0,3.0,8.0,3,3,4,3,0,1,1,1,0,0,,0,1,4,2,2,ANY
4864,273319,Close,1,node.anonymous_namespace_9.SignalWrap.Close,void node.anonymous_namespace_9.SignalWrap.Close (ANY),signal_wrap.cc,"void Close(v8::Local<v8::Value> close_callback) override {
    if (active_) {
      DecreaseSignalHandlerCount(handle_.signum);
      active_ = false;
    }
    HandleWrap::Close(close_callback);
  }",97.0,103.0,3.0,3.0,7.0,3,2,5,4,0,3,2,2,1,0,,0,3,2,1,1,void
4865,273339,Start,1,node.anonymous_namespace_10.SignalWrap.Start,void node.anonymous_namespace_10.SignalWrap.Start (FunctionCallbackInfo<Value>),signal_wrap.cc,"static void Start(const FunctionCallbackInfo<Value>& args) {
    SignalWrap* wrap;
    ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
    Environment* env = wrap->env();
    int signum;
    if (!args[0]->Int32Value(env->context()).To(&signum)) return;
#if defined(__POSIX__) && HAVE_INSPECTOR
    if (signum == SIGPROF) {
      Environment* env = Environment::GetCurrent(args);
      if (env->inspector_agent()->IsListening()) {
        ProcessEmitWarning(env,
                           ""process.on(SIGPROF) is reserved while debugging"");
        return;
      }
    }
#endif
    int err = uv_signal_start(
        &wrap->handle_,
        [](uv_signal_t* handle, int signum) {
          SignalWrap* wrap = ContainerOf(&SignalWrap::handle_, handle);
          Environment* env = wrap->env();
          HandleScope handle_scope(env->isolate());
          Context::Scope context_scope(env->context());
          Local<Value> arg = Integer::New(env->isolate(), signum);
          wrap->MakeCallback(e...",105.0,141.0,3.0,3.0,37.0,22,8,18,7,0,3,3,3,0,0,,0,3,2,1,1,void
4866,273418,Stop,1,node.anonymous_namespace_12.SignalWrap.Stop,void node.anonymous_namespace_12.SignalWrap.Stop (FunctionCallbackInfo<Value>),signal_wrap.cc,"static void Stop(const FunctionCallbackInfo<Value>& args) {
    SignalWrap* wrap;
    ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

    if (wrap->active_)  {
      wrap->active_ = false;
      DecreaseSignalHandlerCount(wrap->handle_.signum);
    }

    int err = uv_signal_stop(&wrap->handle_);
    args.GetReturnValue().Set(err);
  }",143.0,154.0,3.0,3.0,12.0,12,4,9,3,0,4,2,2,1,0,,0,4,2,1,1,void
4867,273500,HasSignalJSHandler,1,node.HasSignalJSHandler,bool node.HasSignalJSHandler (int),signal_wrap.cc,"bool HasSignalJSHandler(int signum) {
  Mutex::ScopedLock lock(handled_signals_mutex);
  return handled_signals.find(signum) != handled_signals.end();
}",171.0,174.0,1.0,1.0,4.0,3,2,4,3,0,0,1,1,0,0,,0,0,2,1,1,bool
4868,273540,OnAlloc,1,node.SyncProcessOutputBuffer.OnAlloc,"void node.SyncProcessOutputBuffer.OnAlloc (size_t,uv_buf_t*)",spawn_sync.cc,"void SyncProcessOutputBuffer::OnAlloc(size_t suggested_size,
                                      uv_buf_t* buf) const {
  if (used() == kBufferSize)
    *buf = uv_buf_init(nullptr, 0);
  else
    *buf = uv_buf_init(data_ + used(), available());
}",53.0,59.0,1.0,1.0,7.0,3,3,2,2,0,0,2,2,0,0,,0,0,4,2,2,void
4869,273567,OnRead,1,node.SyncProcessOutputBuffer.OnRead,"void node.SyncProcessOutputBuffer.OnRead (uv_buf_t*,size_t)",spawn_sync.cc,"void SyncProcessOutputBuffer::OnRead(const uv_buf_t* buf, size_t nread) {
  // If we hand out the same chunk twice, this should catch it.
  CHECK_EQ(buf->base, data_ + used());
  used_ += static_cast<unsigned int>(nread);
}",62.0,66.0,1.0,1.0,5.0,4,4,4,4,0,0,1,1,0,0,,0,0,4,2,2,void
4870,273585,Copy,1,node.SyncProcessOutputBuffer.Copy,size_t node.SyncProcessOutputBuffer.Copy (char*),spawn_sync.cc,"size_t SyncProcessOutputBuffer::Copy(char* dest) const {
  memcpy(dest, data_, used());
  return used();
}",69.0,72.0,1.0,1.0,4.0,0,0,2,2,0,0,1,1,0,0,,0,0,2,1,1,size_t
4871,273596,available,1,node.SyncProcessOutputBuffer.available,unsigned int node.SyncProcessOutputBuffer.available (),spawn_sync.cc,"unsigned int SyncProcessOutputBuffer::available() const {
  return sizeof data_ - used();
}",75.0,77.0,1.0,1.0,3.0,2,2,1,1,0,0,1,1,0,0,,0,0,0,0,0,unsigned int
4872,273605,used,1,node.SyncProcessOutputBuffer.used,unsigned int node.SyncProcessOutputBuffer.used (),spawn_sync.cc,"unsigned int SyncProcessOutputBuffer::used() const {
  return used_;
}",80.0,82.0,1.0,1.0,3.0,0,0,1,1,0,0,1,1,0,0,,0,0,0,0,0,unsigned int
4873,273611,next,1,node.SyncProcessOutputBuffer.next,SyncProcessOutputBuffer node.SyncProcessOutputBuffer.next (),spawn_sync.cc,"SyncProcessOutputBuffer* SyncProcessOutputBuffer::next() const {
  return next_;
}",85.0,87.0,1.0,1.0,3.0,0,0,1,1,0,0,1,1,0,0,,0,0,0,0,0,SyncProcessOutputBuffer
4874,273617,set_next,1,node.SyncProcessOutputBuffer.set_next,void node.SyncProcessOutputBuffer.set_next (SyncProcessOutputBuffer*),spawn_sync.cc,"void SyncProcessOutputBuffer::set_next(SyncProcessOutputBuffer* next) {
  next_ = next;
}",90.0,92.0,1.0,1.0,3.0,1,1,2,2,0,0,1,1,0,0,,0,0,2,1,1,void
4875,273625,SyncProcessStdioPipe,1,node.SyncProcessStdioPipe.SyncProcessStdioPipe,"ANY node.SyncProcessStdioPipe.SyncProcessStdioPipe (SyncProcessRunner*,bool,bool,uv_buf_t)",spawn_sync.cc,"SyncProcessStdioPipe::SyncProcessStdioPipe(SyncProcessRunner* process_handler,
                                           bool readable,
                                           bool writable,
                                           uv_buf_t input_buffer)
    : process_handler_(process_handler),
      readable_(readable),
      writable_(writable),
      input_buffer_(input_buffer),

      first_output_buffer_(nullptr),
      last_output_buffer_(nullptr),

      uv_pipe_(),
      write_req_(),
      shutdown_req_(),

      lifecycle_(kUninitialized) {
  CHECK(readable || writable);
}",95.0,113.0,1.0,1.0,19.0,1,1,2,2,0,0,1,1,0,0,,0,0,8,4,4,ANY
4876,273637,~SyncProcessStdioPipe,1,node.SyncProcessStdioPipe.~SyncProcessStdioPipe,ANY node.SyncProcessStdioPipe.~SyncProcessStdioPipe (),spawn_sync.cc,"SyncProcessStdioPipe::~SyncProcessStdioPipe() {
  CHECK(lifecycle_ == kUninitialized || lifecycle_ == kClosed);

  SyncProcessOutputBuffer* buf;
  SyncProcessOutputBuffer* next;

  for (buf = first_output_buffer_; buf != nullptr; buf = next) {
    next = buf->next();
    delete buf;
  }
}",116.0,126.0,1.0,1.0,11.0,8,6,10,6,0,0,2,2,0,0,,0,0,0,0,0,ANY
4877,273671,Initialize,1,node.SyncProcessStdioPipe.Initialize,int node.SyncProcessStdioPipe.Initialize (uv_loop_t*),spawn_sync.cc,"int SyncProcessStdioPipe::Initialize(uv_loop_t* loop) {
  CHECK_EQ(lifecycle_, kUninitialized);

  int r = uv_pipe_init(loop, uv_pipe(), 0);
  if (r < 0)
    return r;

  uv_pipe()->data = this;

  lifecycle_ = kInitialized;
  return 0;
}",129.0,140.0,1.0,1.0,12.0,5,3,8,5,0,0,2,2,0,0,,0,0,2,1,1,int
4878,273703,Start,1,node.SyncProcessStdioPipe.Start,int node.SyncProcessStdioPipe.Start (),spawn_sync.cc,"int SyncProcessStdioPipe::Start() {
  CHECK_EQ(lifecycle_, kInitialized);

  // Set the busy flag already. If this function fails no recovery is
  // possible.
  lifecycle_ = kStarted;

  if (readable()) {
    if (input_buffer_.len > 0) {
      CHECK_NOT_NULL(input_buffer_.base);

      int r = uv_write(&write_req_,
                       uv_stream(),
                       &input_buffer_,
                       1,
                       WriteCallback);
      if (r < 0)
        return r;
    }

    int r = uv_shutdown(&shutdown_req_, uv_stream(), ShutdownCallback);
    if (r < 0)
      return r;
  }

  if (writable()) {
    int r = uv_read_start(uv_stream(), AllocCallback, ReadCallback);
    if (r < 0)
      return r;
  }

  return 0;
}",143.0,175.0,1.0,1.0,33.0,13,5,22,11,0,0,7,12,0,0,,0,0,0,0,0,int
4879,273779,Close,1,node.SyncProcessStdioPipe.Close,void node.SyncProcessStdioPipe.Close (),spawn_sync.cc,"void SyncProcessStdioPipe::Close() {
  CHECK(lifecycle_ == kInitialized || lifecycle_ == kStarted);

  uv_close(uv_handle(), CloseCallback);

  lifecycle_ = kClosing;
}",178.0,184.0,1.0,1.0,7.0,4,3,7,5,0,0,1,1,0,0,,0,0,0,0,0,void
4880,273797,GetOutputAsBuffer,1,node.SyncProcessStdioPipe.GetOutputAsBuffer,Local<Object> node.SyncProcessStdioPipe.GetOutputAsBuffer (Environment*),spawn_sync.cc,"Local<Object> SyncProcessStdioPipe::GetOutputAsBuffer(Environment* env) const {
  size_t length = OutputLength();
  Local<Object> js_buffer = Buffer::New(env, length).ToLocalChecked();
  CopyOutput(Buffer::Data(js_buffer));
  return js_buffer;
}",187.0,192.0,1.0,1.0,6.0,7,4,10,6,0,0,1,1,0,0,,0,0,2,1,1,Local<Object>
4881,273829,readable,1,node.SyncProcessStdioPipe.readable,bool node.SyncProcessStdioPipe.readable (),spawn_sync.cc,"bool SyncProcessStdioPipe::readable() const {
  return readable_;
}",195.0,197.0,1.0,1.0,3.0,0,0,1,1,0,0,1,1,0,0,,0,0,0,0,0,bool
4882,273835,writable,1,node.SyncProcessStdioPipe.writable,bool node.SyncProcessStdioPipe.writable (),spawn_sync.cc,"bool SyncProcessStdioPipe::writable() const {
  return writable_;
}",200.0,202.0,1.0,1.0,3.0,0,0,1,1,0,0,1,1,0,0,,0,0,0,0,0,bool
4883,273841,uv_flags,1,node.SyncProcessStdioPipe.uv_flags,uv_stdio_flags node.SyncProcessStdioPipe.uv_flags (),spawn_sync.cc,"uv_stdio_flags SyncProcessStdioPipe::uv_flags() const {
  unsigned int flags;

  flags = UV_CREATE_PIPE;
  if (readable())
    flags |= UV_READABLE_PIPE;
  if (writable())
    flags |= UV_WRITABLE_PIPE;

  return static_cast<uv_stdio_flags>(flags);
}",205.0,215.0,1.0,1.0,11.0,2,2,7,4,0,0,3,3,0,0,,0,0,0,0,0,uv_stdio_flags
4884,273865,uv_pipe,1,node.SyncProcessStdioPipe.uv_pipe,uv_pipe_t node.SyncProcessStdioPipe.uv_pipe (),spawn_sync.cc,"uv_pipe_t* SyncProcessStdioPipe::uv_pipe() const {
  CHECK_LT(lifecycle_, kClosing);
  return &uv_pipe_;
}",218.0,221.0,1.0,1.0,4.0,1,1,3,3,0,0,1,1,0,0,,0,0,0,0,0,uv_pipe_t
4885,273875,uv_stream,1,node.SyncProcessStdioPipe.uv_stream,uv_stream_t node.SyncProcessStdioPipe.uv_stream (),spawn_sync.cc,"uv_stream_t* SyncProcessStdioPipe::uv_stream() const {
  return reinterpret_cast<uv_stream_t*>(uv_pipe());
}",224.0,226.0,1.0,1.0,3.0,1,1,0,0,0,0,1,1,0,0,,0,0,0,0,0,uv_stream_t
4886,273883,uv_handle,1,node.SyncProcessStdioPipe.uv_handle,uv_handle_t node.SyncProcessStdioPipe.uv_handle (),spawn_sync.cc,"uv_handle_t* SyncProcessStdioPipe::uv_handle() const {
  return reinterpret_cast<uv_handle_t*>(uv_pipe());
}",229.0,231.0,1.0,1.0,3.0,1,1,0,0,0,0,1,1,0,0,,0,0,0,0,0,uv_handle_t
4887,273891,OutputLength,1,node.SyncProcessStdioPipe.OutputLength,size_t node.SyncProcessStdioPipe.OutputLength (),spawn_sync.cc,"size_t SyncProcessStdioPipe::OutputLength() const {
  SyncProcessOutputBuffer* buf;
  size_t size = 0;

  for (buf = first_output_buffer_; buf != nullptr; buf = buf->next())
    size += buf->used();

  return size;
}",234.0,242.0,1.0,1.0,9.0,3,2,5,3,0,0,2,2,0,0,,0,0,0,0,0,size_t
4888,273922,CopyOutput,1,node.SyncProcessStdioPipe.CopyOutput,void node.SyncProcessStdioPipe.CopyOutput (char*),spawn_sync.cc,"void SyncProcessStdioPipe::CopyOutput(char* dest) const {
  SyncProcessOutputBuffer* buf;
  size_t offset = 0;

  for (buf = first_output_buffer_; buf != nullptr; buf = buf->next())
    offset += buf->Copy(dest + offset);
}",245.0,251.0,1.0,1.0,7.0,3,2,4,3,0,0,2,2,0,0,,0,0,2,1,1,void
4889,273955,OnAlloc,1,node.SyncProcessStdioPipe.OnAlloc,"void node.SyncProcessStdioPipe.OnAlloc (size_t,uv_buf_t*)",spawn_sync.cc,"void SyncProcessStdioPipe::OnAlloc(size_t suggested_size, uv_buf_t* buf) {
  // This function assumes that libuv will never allocate two buffers for the
  // same stream at the same time. There's an assert in
  // SyncProcessOutputBuffer::OnRead that would fail if this assumption was
  // ever violated.

  if (last_output_buffer_ == nullptr) {
    // Allocate the first capture buffer.
    first_output_buffer_ = new SyncProcessOutputBuffer();
    last_output_buffer_ = first_output_buffer_;

  } else if (last_output_buffer_->available() == 0) {
    // The current capture buffer is full so get us a new one.
    SyncProcessOutputBuffer* buf = new SyncProcessOutputBuffer();
    last_output_buffer_->set_next(buf);
    last_output_buffer_ = buf;
  }

  last_output_buffer_->OnAlloc(suggested_size, buf);
}",254.0,273.0,1.0,1.0,20.0,5,4,8,5,0,0,2,2,0,0,,0,0,4,2,2,void
4890,274002,OnRead,1,node.SyncProcessStdioPipe.OnRead,"void node.SyncProcessStdioPipe.OnRead (uv_buf_t*,ssize_t)",spawn_sync.cc,"void SyncProcessStdioPipe::OnRead(const uv_buf_t* buf, ssize_t nread) {
  if (nread == UV_EOF) {
    // Libuv implicitly stops reading on EOF.

  } else if (nread < 0) {
    SetError(static_cast<int>(nread));
    // At some point libuv should really implicitly stop reading on error.
    uv_read_stop(uv_stream());

  } else {
    last_output_buffer_->OnRead(buf, nread);
    process_handler_->IncrementBufferSizeAndCheckOverflow(nread);
  }
}",276.0,289.0,1.0,1.0,14.0,1,1,2,2,0,0,2,2,0,0,,0,0,4,2,2,void
4891,274038,OnWriteDone,1,node.SyncProcessStdioPipe.OnWriteDone,void node.SyncProcessStdioPipe.OnWriteDone (int),spawn_sync.cc,"void SyncProcessStdioPipe::OnWriteDone(int result) {
  if (result < 0)
    SetError(result);
}",292.0,295.0,1.0,1.0,4.0,1,1,2,1,0,0,2,2,0,0,,0,0,2,1,1,void
4892,274050,OnShutdownDone,1,node.SyncProcessStdioPipe.OnShutdownDone,void node.SyncProcessStdioPipe.OnShutdownDone (int),spawn_sync.cc,"void SyncProcessStdioPipe::OnShutdownDone(int result) {
  if (result < 0)
    SetError(result);
}",298.0,301.0,1.0,1.0,4.0,1,1,2,1,0,0,2,2,0,0,,0,0,2,1,1,void
4893,274062,OnClose,1,node.SyncProcessStdioPipe.OnClose,void node.SyncProcessStdioPipe.OnClose (),spawn_sync.cc,"void SyncProcessStdioPipe::OnClose() {
  lifecycle_ = kClosed;
}",304.0,306.0,1.0,1.0,3.0,1,1,2,2,0,0,1,1,0,0,,0,0,0,0,0,void
4894,274069,SetError,1,node.SyncProcessStdioPipe.SetError,void node.SyncProcessStdioPipe.SetError (int),spawn_sync.cc,"void SyncProcessStdioPipe::SetError(int error) {
  CHECK_NE(error, 0);
  process_handler_->SetPipeError(error);
}",309.0,312.0,1.0,1.0,4.0,1,1,3,2,0,0,1,1,0,0,,0,0,2,1,1,void
4895,274082,AllocCallback,1,node.SyncProcessStdioPipe.AllocCallback,"void node.SyncProcessStdioPipe.AllocCallback (uv_handle_t*,size_t,uv_buf_t*)",spawn_sync.cc,"void SyncProcessStdioPipe::AllocCallback(uv_handle_t* handle,
                                         size_t suggested_size,
                                         uv_buf_t* buf) {
  SyncProcessStdioPipe* self =
      reinterpret_cast<SyncProcessStdioPipe*>(handle->data);
  self->OnAlloc(suggested_size, buf);
}",315.0,321.0,1.0,1.0,7.0,4,3,5,4,0,0,1,1,0,0,,0,0,6,3,3,void
4896,274103,ReadCallback,1,node.SyncProcessStdioPipe.ReadCallback,"void node.SyncProcessStdioPipe.ReadCallback (uv_stream_t*,ssize_t,uv_buf_t*)",spawn_sync.cc,"void SyncProcessStdioPipe::ReadCallback(uv_stream_t* stream,
                                        ssize_t nread,
                                        const uv_buf_t* buf) {
  SyncProcessStdioPipe* self =
        reinterpret_cast<SyncProcessStdioPipe*>(stream->data);
  self->OnRead(buf, nread);
}",324.0,330.0,1.0,1.0,7.0,4,3,5,4,0,0,1,1,0,0,,0,0,6,3,3,void
4897,274124,WriteCallback,1,node.SyncProcessStdioPipe.WriteCallback,"void node.SyncProcessStdioPipe.WriteCallback (uv_write_t*,int)",spawn_sync.cc,"void SyncProcessStdioPipe::WriteCallback(uv_write_t* req, int result) {
  SyncProcessStdioPipe* self =
      reinterpret_cast<SyncProcessStdioPipe*>(req->handle->data);
  self->OnWriteDone(result);
}",333.0,337.0,1.0,1.0,5.0,5,3,4,3,0,0,1,1,0,0,,0,0,4,2,2,void
4898,274145,ShutdownCallback,1,node.SyncProcessStdioPipe.ShutdownCallback,"void node.SyncProcessStdioPipe.ShutdownCallback (uv_shutdown_t*,int)",spawn_sync.cc,"void SyncProcessStdioPipe::ShutdownCallback(uv_shutdown_t* req, int result) {
  SyncProcessStdioPipe* self =
      reinterpret_cast<SyncProcessStdioPipe*>(req->handle->data);

  // On AIX, OS X and the BSDs, calling shutdown() on one end of a pipe
  // when the other end has closed the connection fails with ENOTCONN.
  // Libuv is not the right place to handle that because it can't tell
  // if the error is genuine but we here can.
  if (result == UV_ENOTCONN)
    result = 0;

  self->OnShutdownDone(result);
}",340.0,352.0,1.0,1.0,13.0,7,4,7,4,0,0,2,2,0,0,,0,0,4,2,2,void
4899,274174,CloseCallback,1,node.SyncProcessStdioPipe.CloseCallback,void node.SyncProcessStdioPipe.CloseCallback (uv_handle_t*),spawn_sync.cc,"void SyncProcessStdioPipe::CloseCallback(uv_handle_t* handle) {
  SyncProcessStdioPipe* self =
      reinterpret_cast<SyncProcessStdioPipe*>(handle->data);
  self->OnClose();
}",355.0,359.0,1.0,1.0,5.0,4,3,3,2,0,0,1,1,0,0,,0,0,2,1,1,void
4900,274191,Initialize,1,node.SyncProcessRunner.Initialize,"void node.SyncProcessRunner.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)",spawn_sync.cc,"void SyncProcessRunner::Initialize(Local<Object> target,
                                   Local<Value> unused,
                                   Local<Context> context,
                                   void* priv) {
  SetMethod(context, target, ""spawn"", Spawn);
}",362.0,367.0,1.0,1.0,6.0,0,0,3,3,0,0,1,1,0,0,,0,0,8,4,4,void
4901,274204,Spawn,1,node.SyncProcessRunner.Spawn,void node.SyncProcessRunner.Spawn (FunctionCallbackInfo<Value>),spawn_sync.cc,"void SyncProcessRunner::Spawn(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  THROW_IF_INSUFFICIENT_PERMISSIONS(
      env, permission::PermissionScope::kChildProcess, """");
  env->PrintSyncTrace();
  SyncProcessRunner p(env);
  Local<Value> result;
  if (!p.Run(args[0]).ToLocal(&result)) return;
  args.GetReturnValue().Set(result);
}",370.0,379.0,1.0,1.0,10.0,14,8,16,9,0,0,2,2,0,0,,0,0,2,1,1,void
4902,274261,SyncProcessRunner,1,node.SyncProcessRunner.SyncProcessRunner,ANY node.SyncProcessRunner.SyncProcessRunner (Environment*),spawn_sync.cc,"SyncProcessRunner::SyncProcessRunner(Environment* env)
    : max_buffer_(0),
      timeout_(0),
      kill_signal_(SIGTERM),

      uv_loop_(nullptr),

      stdio_count_(0),
      uv_stdio_containers_(nullptr),
      stdio_pipes_initialized_(false),

      uv_process_options_(),
      file_buffer_(nullptr),
      args_buffer_(nullptr),
      env_buffer_(nullptr),
      cwd_buffer_(nullptr),

      uv_process_(),
      killed_(false),

      buffered_output_size_(0),
      exit_status_(-1),
      term_signal_(-1),

      uv_timer_(),
      kill_timer_initialized_(false),

      error_(0),
      pipe_error_(0),

      lifecycle_(kUninitialized),

      env_(env) {
}",382.0,415.0,1.0,1.0,34.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
4903,274266,~SyncProcessRunner,1,node.SyncProcessRunner.~SyncProcessRunner,ANY node.SyncProcessRunner.~SyncProcessRunner (),spawn_sync.cc,"SyncProcessRunner::~SyncProcessRunner() {
  CHECK_EQ(lifecycle_, kHandlesClosed);

  stdio_pipes_.clear();
  delete[] file_buffer_;
  delete[] args_buffer_;
  delete[] cwd_buffer_;
  delete[] env_buffer_;
  delete[] uv_stdio_containers_;
}",418.0,427.0,1.0,1.0,10.0,6,2,8,8,0,0,1,1,0,0,,0,0,0,0,0,ANY
4904,274287,env,1,node.SyncProcessRunner.env,Environment node.SyncProcessRunner.env (),spawn_sync.cc,"Environment* SyncProcessRunner::env() const {
  return env_;
}",430.0,432.0,1.0,1.0,3.0,0,0,1,1,0,0,1,1,0,0,,0,0,0,0,0,Environment
4905,274293,Run,1,node.SyncProcessRunner.Run,MaybeLocal<Object> node.SyncProcessRunner.Run (Local<Value>),spawn_sync.cc,"MaybeLocal<Object> SyncProcessRunner::Run(Local<Value> options) {
  EscapableHandleScope scope(env()->isolate());

  CHECK_EQ(lifecycle_, kUninitialized);

  Maybe<bool> r = TryInitializeAndRunLoop(options);
  CloseHandlesAndDeleteLoop();
  if (r.IsNothing()) return MaybeLocal<Object>();

  Local<Object> result = BuildResultObject();

  return scope.Escape(result);
}",434.0,446.0,1.0,1.0,13.0,7,5,10,8,0,0,2,2,0,0,,0,0,2,1,1,MaybeLocal<Object>
4906,274334,TryInitializeAndRunLoop,1,node.SyncProcessRunner.TryInitializeAndRunLoop,Maybe<bool> node.SyncProcessRunner.TryInitializeAndRunLoop (Local<Value>),spawn_sync.cc,"Maybe<bool> SyncProcessRunner::TryInitializeAndRunLoop(Local<Value> options) {
  int r;

  // There is no recovery from failure inside TryInitializeAndRunLoop - the
  // only option we'd have is to close all handles and destroy the loop.
  CHECK_EQ(lifecycle_, kUninitialized);
  lifecycle_ = kInitialized;

  uv_loop_ = new uv_loop_t;
  if (uv_loop_ == nullptr) {
    SetError(UV_ENOMEM);
    return Just(false);
  }

  r = uv_loop_init(uv_loop_);
  if (r < 0) {
    delete uv_loop_;
    uv_loop_ = nullptr;
    SetError(r);
    return Just(false);
  }

  if (!ParseOptions(options).To(&r)) return Nothing<bool>();

  if (r < 0) {
    SetError(r);
    return Just(false);
  }

  if (timeout_ > 0) {
    r = uv_timer_init(uv_loop_, &uv_timer_);
    if (r < 0) {
      SetError(r);
      return Just(false);
    }

    uv_unref(reinterpret_cast<uv_handle_t*>(&uv_timer_));

    uv_timer_.data = this;
    kill_timer_initialized_ = true;

    // Start the timer immediately. If uv_spawn fails then
 ...",448.0,526.0,1.0,1.0,79.0,38,12,52,18,0,0,13,18,0,0,,0,0,2,1,1,Maybe<bool>
4907,274522,CloseHandlesAndDeleteLoop,1,node.SyncProcessRunner.CloseHandlesAndDeleteLoop,void node.SyncProcessRunner.CloseHandlesAndDeleteLoop (),spawn_sync.cc,"void SyncProcessRunner::CloseHandlesAndDeleteLoop() {
  CHECK_LT(lifecycle_, kHandlesClosed);

  if (uv_loop_ != nullptr) {
    CloseStdioPipes();
    CloseKillTimer();
    // Close the process handle when ExitCallback was not called.
    uv_handle_t* uv_process_handle =
        reinterpret_cast<uv_handle_t*>(&uv_process_);

    // Close the process handle if it is still open. The handle type also
    // needs to be checked because TryInitializeAndRunLoop() won't spawn a
    // process if input validation fails.
    if (uv_process_handle->type == UV_PROCESS &&
        !uv_is_closing(uv_process_handle))
      uv_close(uv_process_handle, nullptr);

    // Give closing watchers a chance to finish closing and get their close
    // callbacks called.
    int r = uv_run(uv_loop_, UV_RUN_DEFAULT);
    if (r < 0)
      ABORT();

    CheckedUvLoopClose(uv_loop_);
    delete uv_loop_;
    uv_loop_ = nullptr;

  } else {
    // If the loop doesn't exist, neither should any pipes or timers.
   ...",529.0,563.0,1.0,1.0,35.0,13,10,17,8,0,0,4,6,0,0,,0,0,0,0,0,void
4908,274586,CloseStdioPipes,1,node.SyncProcessRunner.CloseStdioPipes,void node.SyncProcessRunner.CloseStdioPipes (),spawn_sync.cc,"void SyncProcessRunner::CloseStdioPipes() {
  CHECK_LT(lifecycle_, kHandlesClosed);

  if (stdio_pipes_initialized_) {
    CHECK(!stdio_pipes_.empty());
    CHECK_NOT_NULL(uv_loop_);

    for (const auto& pipe : stdio_pipes_) {
      if (pipe)
        pipe->Close();
    }

    stdio_pipes_initialized_ = false;
  }
}",566.0,580.0,1.0,1.0,15.0,4,4,8,5,0,0,4,7,0,0,,0,0,0,0,0,void
4909,274617,CloseKillTimer,1,node.SyncProcessRunner.CloseKillTimer,void node.SyncProcessRunner.CloseKillTimer (),spawn_sync.cc,"void SyncProcessRunner::CloseKillTimer() {
  CHECK_LT(lifecycle_, kHandlesClosed);

  if (kill_timer_initialized_) {
    CHECK_GT(timeout_, 0);
    CHECK_NOT_NULL(uv_loop_);

    uv_handle_t* uv_timer_handle = reinterpret_cast<uv_handle_t*>(&uv_timer_);
    uv_ref(uv_timer_handle);
    uv_close(uv_timer_handle, KillTimerCloseCallback);

    kill_timer_initialized_ = false;
  }
}",583.0,596.0,1.0,1.0,14.0,4,3,10,7,0,0,2,2,0,0,,0,0,0,0,0,void
4910,274646,Kill,1,node.SyncProcessRunner.Kill,void node.SyncProcessRunner.Kill (),spawn_sync.cc,"void SyncProcessRunner::Kill() {
  // Only attempt to kill once.
  if (killed_)
    return;
  killed_ = true;

  // We might get here even if the process we spawned has already exited. This
  // could happen when our child process spawned another process which
  // inherited (one of) the stdio pipes. In this case we won't attempt to send
  // a signal to the process, however we will still close our end of the stdio
  // pipes so this situation won't make us hang.
  if (exit_status_ < 0) {
    int r = uv_process_kill(&uv_process_, kill_signal_);

    // If uv_kill failed with an error that isn't ESRCH, the user probably
    // specified an invalid or unsupported signal. Signal this to the user as
    // and error and kill the process with SIGKILL instead.
    if (r < 0 && r != UV_ESRCH) {
      SetError(r);

      // Deliberately ignore the return value, we might not have
      // sufficient privileges to signal the child process.
      USE(uv_process_kill(&uv_process_, SIGKILL));
  ...",599.0,630.0,1.0,1.0,32.0,8,5,12,7,0,0,4,5,0,0,,0,0,0,0,0,void
4911,274687,IncrementBufferSizeAndCheckOverflow,1,node.SyncProcessRunner.IncrementBufferSizeAndCheckOverflow,void node.SyncProcessRunner.IncrementBufferSizeAndCheckOverflow (ssize_t),spawn_sync.cc,"void SyncProcessRunner::IncrementBufferSizeAndCheckOverflow(ssize_t length) {
  buffered_output_size_ += length;

  if (max_buffer_ > 0 && buffered_output_size_ > max_buffer_) {
    SetError(UV_ENOBUFS);
    Kill();
  }
}",633.0,640.0,1.0,1.0,8.0,4,3,5,3,0,0,2,2,0,0,,0,0,2,1,1,void
4912,274706,OnExit,1,node.SyncProcessRunner.OnExit,"void node.SyncProcessRunner.OnExit (int64_t,int)",spawn_sync.cc,"void SyncProcessRunner::OnExit(int64_t exit_status, int term_signal) {
  if (exit_status < 0)
    return SetError(static_cast<int>(exit_status));

  exit_status_ = exit_status;
  term_signal_ = term_signal;
}",643.0,649.0,1.0,1.0,7.0,4,3,6,4,0,0,2,2,0,0,,0,0,4,2,2,void
4913,274728,OnKillTimerTimeout,1,node.SyncProcessRunner.OnKillTimerTimeout,void node.SyncProcessRunner.OnKillTimerTimeout (),spawn_sync.cc,"void SyncProcessRunner::OnKillTimerTimeout() {
  SetError(UV_ETIMEDOUT);
  Kill();
}",652.0,655.0,1.0,1.0,4.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
4914,274734,GetError,1,node.SyncProcessRunner.GetError,int node.SyncProcessRunner.GetError (),spawn_sync.cc,"int SyncProcessRunner::GetError() {
  if (error_ != 0)
    return error_;
  else
    return pipe_error_;
}",658.0,663.0,1.0,1.0,6.0,1,1,2,1,0,0,2,2,0,0,,0,0,0,0,0,int
4915,274749,SetError,1,node.SyncProcessRunner.SetError,void node.SyncProcessRunner.SetError (int),spawn_sync.cc,"void SyncProcessRunner::SetError(int error) {
  if (error_ == 0)
    error_ = error;
}",666.0,669.0,1.0,1.0,4.0,2,2,3,2,0,0,2,2,0,0,,0,0,2,1,1,void
4916,274762,SetPipeError,1,node.SyncProcessRunner.SetPipeError,void node.SyncProcessRunner.SetPipeError (int),spawn_sync.cc,"void SyncProcessRunner::SetPipeError(int pipe_error) {
  if (pipe_error_ == 0)
    pipe_error_ = pipe_error;
}",672.0,675.0,1.0,1.0,4.0,2,2,3,2,0,0,2,2,0,0,,0,0,2,1,1,void
4917,274775,BuildResultObject,1,node.SyncProcessRunner.BuildResultObject,Local<Object> node.SyncProcessRunner.BuildResultObject (),spawn_sync.cc,"Local<Object> SyncProcessRunner::BuildResultObject() {
  EscapableHandleScope scope(env()->isolate());
  Local<Context> context = env()->context();

  Local<Object> js_result = Object::New(env()->isolate());

  if (GetError() != 0) {
    js_result->Set(context, env()->error_string(),
                   Integer::New(env()->isolate(), GetError())).Check();
  }

  if (exit_status_ >= 0) {
    if (term_signal_ > 0) {
      js_result->Set(context, env()->status_string(),
                     Null(env()->isolate())).Check();
    } else {
      js_result->Set(context, env()->status_string(),
                     Number::New(env()->isolate(),
                                 static_cast<double>(exit_status_))).Check();
    }
  } else {
    // If exit_status_ < 0 the process was never started because of some error.
    js_result->Set(context, env()->status_string(),
                   Null(env()->isolate())).Check();
  }

  if (term_signal_ > 0)
    js_result->Set(context, env()->signal_stri...",678.0,725.0,1.0,1.0,48.0,40,7,28,12,0,0,6,7,0,0,,0,0,0,0,0,Local<Object>
4918,275021,BuildOutputArray,1,node.SyncProcessRunner.BuildOutputArray,Local<Array> node.SyncProcessRunner.BuildOutputArray (),spawn_sync.cc,"Local<Array> SyncProcessRunner::BuildOutputArray() {
  CHECK_GE(lifecycle_, kInitialized);
  CHECK(!stdio_pipes_.empty());

  EscapableHandleScope scope(env()->isolate());
  MaybeStackBuffer<Local<Value>, 8> js_output(stdio_pipes_.size());

  for (uint32_t i = 0; i < stdio_pipes_.size(); i++) {
    SyncProcessStdioPipe* h = stdio_pipes_[i].get();
    if (h != nullptr && h->writable())
      js_output[i] = h->GetOutputAsBuffer(env());
    else
      js_output[i] = Null(env()->isolate());
  }

  return scope.Escape(
      Array::New(env()->isolate(), js_output.out(), js_output.length()));
}",728.0,745.0,1.0,1.0,18.0,21,8,19,8,0,0,3,4,0,0,,0,0,0,0,0,Local<Array>
4919,275121,ParseOptions,1,node.SyncProcessRunner.ParseOptions,Maybe<int> node.SyncProcessRunner.ParseOptions (Local<Value>),spawn_sync.cc,"Maybe<int> SyncProcessRunner::ParseOptions(Local<Value> js_value) {
  Isolate* isolate = env()->isolate();
  HandleScope scope(isolate);
  int r;

  if (!js_value->IsObject()) return Just<int>(UV_EINVAL);

  Local<Context> context = env()->context();
  Local<Object> js_options = js_value.As<Object>();

  Local<Value> js_file =
      js_options->Get(context, env()->file_string()).ToLocalChecked();
  if (!CopyJsString(js_file, &file_buffer_).To(&r)) return Nothing<int>();
  if (r < 0) return Just(r);
  uv_process_options_.file = file_buffer_;

  Local<Value> js_args =
      js_options->Get(context, env()->args_string()).ToLocalChecked();
  if (!CopyJsStringArray(js_args, &args_buffer_).To(&r)) return Nothing<int>();
  if (r < 0) return Just(r);
  uv_process_options_.args = reinterpret_cast<char**>(args_buffer_);

  Local<Value> js_cwd =
      js_options->Get(context, env()->cwd_string()).ToLocalChecked();
  if (IsSet(js_cwd)) {
    if (!CopyJsString(js_cwd, &cwd_buffer_).To(&r)) retur...",747.0,852.0,1.0,1.0,106.0,160,8,149,40,0,0,22,26,0,0,,0,0,2,1,1,Maybe<int>
4920,275707,ParseStdioOptions,1,node.SyncProcessRunner.ParseStdioOptions,int node.SyncProcessRunner.ParseStdioOptions (Local<Value>),spawn_sync.cc,"int SyncProcessRunner::ParseStdioOptions(Local<Value> js_value) {
  HandleScope scope(env()->isolate());
  Local<Array> js_stdio_options;

  if (!js_value->IsArray())
    return UV_EINVAL;

  Local<Context> context = env()->context();
  js_stdio_options = js_value.As<Array>();

  stdio_count_ = js_stdio_options->Length();
  uv_stdio_containers_ = new uv_stdio_container_t[stdio_count_];

  stdio_pipes_.clear();
  stdio_pipes_.resize(stdio_count_);
  stdio_pipes_initialized_ = true;

  for (uint32_t i = 0; i < stdio_count_; i++) {
    Local<Value> js_stdio_option =
        js_stdio_options->Get(context, i).ToLocalChecked();

    if (!js_stdio_option->IsObject())
      return UV_EINVAL;

    int r = ParseStdioOption(i, js_stdio_option.As<Object>());
    if (r < 0)
      return r;
  }

  uv_process_options_.stdio = uv_stdio_containers_;
  uv_process_options_.stdio_count = stdio_count_;

  return 0;
}",855.0,888.0,1.0,1.0,34.0,34,7,38,17,0,0,5,7,0,0,,0,0,2,1,1,int
4921,275834,ParseStdioOption,1,node.SyncProcessRunner.ParseStdioOption,"int node.SyncProcessRunner.ParseStdioOption (int,Local<Object>)",spawn_sync.cc,"int SyncProcessRunner::ParseStdioOption(int child_fd,
                                        Local<Object> js_stdio_option) {
  Local<Context> context = env()->context();
  Local<Value> js_type =
      js_stdio_option->Get(context, env()->type_string()).ToLocalChecked();

  if (js_type->StrictEquals(env()->ignore_string())) {
    return AddStdioIgnore(child_fd);

  } else if (js_type->StrictEquals(env()->pipe_string())) {
    Isolate* isolate = env()->isolate();
    Local<String> rs = env()->readable_string();
    Local<String> ws = env()->writable_string();

    bool readable = js_stdio_option->Get(context, rs)
        .ToLocalChecked()->BooleanValue(isolate);
    bool writable =
        js_stdio_option->Get(context, ws)
        .ToLocalChecked()->BooleanValue(isolate);

    uv_buf_t buf = uv_buf_init(nullptr, 0);

    if (readable) {
      Local<Value> input =
          js_stdio_option->Get(context, env()->input_string()).ToLocalChecked();
      if (Buffer::HasInstance(input)) {
...",891.0,938.0,1.0,1.0,48.0,12,5,10,7,0,0,2,2,0,0,,0,0,4,2,2,int
4922,276072,AddStdioIgnore,1,node.SyncProcessRunner.AddStdioIgnore,int node.SyncProcessRunner.AddStdioIgnore (uint32_t),spawn_sync.cc,"int SyncProcessRunner::AddStdioIgnore(uint32_t child_fd) {
  CHECK_LT(child_fd, stdio_count_);
  CHECK(!stdio_pipes_[child_fd]);

  uv_stdio_containers_[child_fd].flags = UV_IGNORE;

  return 0;
}",941.0,948.0,1.0,1.0,8.0,5,4,7,5,0,0,1,1,0,0,,0,0,2,1,1,int
4923,276094,AddStdioPipe,1,node.SyncProcessRunner.AddStdioPipe,"int node.SyncProcessRunner.AddStdioPipe (uint32_t,bool,bool,uv_buf_t)",spawn_sync.cc,"int SyncProcessRunner::AddStdioPipe(uint32_t child_fd,
                                    bool readable,
                                    bool writable,
                                    uv_buf_t input_buffer) {
  CHECK_LT(child_fd, stdio_count_);
  CHECK(!stdio_pipes_[child_fd]);

  std::unique_ptr<SyncProcessStdioPipe> h(
      new SyncProcessStdioPipe(this, readable, writable, input_buffer));

  int r = h->Initialize(uv_loop_);
  if (r < 0) {
    h.reset();
    return r;
  }

  uv_stdio_containers_[child_fd].flags = h->uv_flags();
  uv_stdio_containers_[child_fd].data.stream = h->uv_stream();

  stdio_pipes_[child_fd] = std::move(h);

  return 0;
}",951.0,973.0,1.0,1.0,23.0,22,8,26,12,0,0,2,2,0,0,,0,0,8,4,4,int
4924,276175,AddStdioInheritFD,1,node.SyncProcessRunner.AddStdioInheritFD,"int node.SyncProcessRunner.AddStdioInheritFD (uint32_t,int)",spawn_sync.cc,"int SyncProcessRunner::AddStdioInheritFD(uint32_t child_fd, int inherit_fd) {
  CHECK_LT(child_fd, stdio_count_);
  CHECK(!stdio_pipes_[child_fd]);

  uv_stdio_containers_[child_fd].flags = UV_INHERIT_FD;
  uv_stdio_containers_[child_fd].data.fd = inherit_fd;

  return 0;
}",976.0,984.0,1.0,1.0,9.0,9,4,10,6,0,0,1,1,0,0,,0,0,4,2,2,int
4925,276207,IsSet,1,node.SyncProcessRunner.IsSet,bool node.SyncProcessRunner.IsSet (Local<Value>),spawn_sync.cc,"bool SyncProcessRunner::IsSet(Local<Value> value) {
  return !value->IsUndefined() && !value->IsNull();
}",987.0,989.0,1.0,1.0,3.0,5,3,2,1,0,0,1,1,0,0,,0,0,2,1,1,bool
4926,276224,CopyJsString,1,node.SyncProcessRunner.CopyJsString,"Maybe<int> node.SyncProcessRunner.CopyJsString (Local<Value>,char**)",spawn_sync.cc,"Maybe<int> SyncProcessRunner::CopyJsString(Local<Value> js_value,
                                           const char** target) {
  Isolate* isolate = env()->isolate();
  Local<String> js_string;
  size_t size, written;
  char* buffer;

  if (js_value->IsString())
    js_string = js_value.As<String>();
  else if (!js_value->ToString(env()->isolate()->GetCurrentContext())
                .ToLocal(&js_string))
    return Nothing<int>();

  // Include space for null terminator byte.
  if (!StringBytes::StorageSize(isolate, js_string, UTF8).To(&size))
    return Nothing<int>();
  size += 1;

  buffer = new char[size];

  written = StringBytes::Write(isolate, buffer, -1, js_string, UTF8);
  buffer[written] = '\0';

  *target = buffer;
  return Just(0);
}",991.0,1016.0,1.0,1.0,26.0,21,12,25,12,0,0,3,3,0,0,,0,0,4,2,2,Maybe<int>
4927,276328,CopyJsStringArray,1,node.SyncProcessRunner.CopyJsStringArray,"Maybe<int> node.SyncProcessRunner.CopyJsStringArray (Local<Value>,char**)",spawn_sync.cc,"Maybe<int> SyncProcessRunner::CopyJsStringArray(Local<Value> js_value,
                                                char** target) {
  Isolate* isolate = env()->isolate();
  Local<Array> js_array;
  uint32_t length;
  size_t list_size, data_size, data_offset;
  char** list;
  char* buffer;

  if (!js_value->IsArray()) return Just<int>(UV_EINVAL);

  Local<Context> context = env()->context();
  js_array = js_value.As<Array>()->Clone().As<Array>();
  length = js_array->Length();
  data_size = 0;

  // Index has a pointer to every string element, plus one more for a final
  // null pointer.
  list_size = (length + 1) * sizeof *list;

  // Convert all array elements to string. Modify the js object itself if
  // needed - it's okay since we cloned the original object. Also compute the
  // length of all strings, including room for a null terminator after every
  // string. Align strings to cache lines.
  for (uint32_t i = 0; i < length; i++) {
    auto value = js_array->Get(context, i...",1018.0,1084.0,1.0,1.0,67.0,75,17,80,26,0,0,7,11,0,0,,0,0,4,2,2,Maybe<int>
4928,276585,ExitCallback,1,node.SyncProcessRunner.ExitCallback,"void node.SyncProcessRunner.ExitCallback (uv_process_t*,int64_t,int)",spawn_sync.cc,"void SyncProcessRunner::ExitCallback(uv_process_t* handle,
                                     int64_t exit_status,
                                     int term_signal) {
  SyncProcessRunner* self = reinterpret_cast<SyncProcessRunner*>(handle->data);
  uv_close(reinterpret_cast<uv_handle_t*>(handle), nullptr);
  self->OnExit(exit_status, term_signal);
}",1087.0,1093.0,1.0,1.0,7.0,5,3,6,4,0,0,1,1,0,0,,0,0,6,3,3,void
4929,276611,KillTimerCallback,1,node.SyncProcessRunner.KillTimerCallback,void node.SyncProcessRunner.KillTimerCallback (uv_timer_t*),spawn_sync.cc,"void SyncProcessRunner::KillTimerCallback(uv_timer_t* handle) {
  SyncProcessRunner* self = reinterpret_cast<SyncProcessRunner*>(handle->data);
  self->OnKillTimerTimeout();
}",1096.0,1099.0,1.0,1.0,4.0,4,3,3,2,0,0,1,1,0,0,,0,0,2,1,1,void
4930,276628,KillTimerCloseCallback,1,node.SyncProcessRunner.KillTimerCloseCallback,void node.SyncProcessRunner.KillTimerCloseCallback (uv_handle_t*),spawn_sync.cc,"void SyncProcessRunner::KillTimerCloseCallback(uv_handle_t* handle) {
  // No-op.
}",1102.0,1104.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
4931,276692,Shutdown,1,node.StreamBase.Shutdown,int node.StreamBase.Shutdown (ANY),stream_base.cc,"int StreamBase::Shutdown(const FunctionCallbackInfo<Value>& args) {
  CHECK(args[0]->IsObject());
  Local<Object> req_wrap_obj = args[0].As<Object>();

  return Shutdown(req_wrap_obj);
}",167.0,172.0,1.0,1.0,6.0,28,9,31,10,0,0,7,9,0,0,,0,0,2,1,1,int
4932,276820,Write,1,node.StreamBase.Write,"StreamWriteResult node.StreamBase.Write (uv_buf_t*,size_t,uv_stream_t*,ANY,bool)",stream_base.cc,"StreamWriteResult StreamBase::Write(uv_buf_t* bufs,
                                    size_t count,
                                    uv_stream_t* send_handle,
                                    v8::Local<v8::Object> req_wrap_obj,
                                    bool skip_try_write) {
  Environment* env = stream_env();
  int err;

  size_t total_bytes = 0;
  for (size_t i = 0; i < count; ++i) total_bytes += bufs[i].len;
  bytes_written_ += total_bytes;

  if (send_handle == nullptr && !skip_try_write) {
    err = DoTryWrite(&bufs, &count);
    if (err != 0 || count == 0) {
      return StreamWriteResult{false, err, nullptr, total_bytes, {}};
    }
  }

  v8::HandleScope handle_scope(env->isolate());

  if (req_wrap_obj.IsEmpty()) {
    if (!env->write_wrap_template()
             ->NewInstance(env->context())
             .ToLocal(&req_wrap_obj)) {
      return StreamWriteResult{false, UV_EBUSY, nullptr, 0, {}};
    }
    StreamReq::ResetObject(req_wrap_obj);
  }

  AsyncHo...",82.0,138.0,1.0,1.0,57.0,48,13,53,19,0,0,9,12,0,0,,0,0,10,5,5,StreamWriteResult
4933,277029,ReadStartJS,1,node.StreamBase.ReadStartJS,int node.StreamBase.ReadStartJS (FunctionCallbackInfo<Value>),stream_base.cc,"int StreamBase::ReadStartJS(const FunctionCallbackInfo<Value>& args) {
  return ReadStart();
}",150.0,152.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
4934,277036,ReadStopJS,1,node.StreamBase.ReadStopJS,int node.StreamBase.ReadStopJS (FunctionCallbackInfo<Value>),stream_base.cc,"int StreamBase::ReadStopJS(const FunctionCallbackInfo<Value>& args) {
  return ReadStop();
}",155.0,157.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
4935,277043,UseUserBuffer,1,node.StreamBase.UseUserBuffer,int node.StreamBase.UseUserBuffer (FunctionCallbackInfo<Value>),stream_base.cc,"int StreamBase::UseUserBuffer(const FunctionCallbackInfo<Value>& args) {
  CHECK(Buffer::HasInstance(args[0]));

  uv_buf_t buf = uv_buf_init(Buffer::Data(args[0]), Buffer::Length(args[0]));
  PushStreamListener(new CustomBufferJSListener(buf));
  return 0;
}",159.0,165.0,1.0,1.0,7.0,8,4,9,4,0,0,1,1,0,0,,0,0,2,1,1,int
4936,277107,SetWriteResult,1,node.StreamBase.SetWriteResult,void node.StreamBase.SetWriteResult (StreamWriteResult),stream_base.cc,"void StreamBase::SetWriteResult(const StreamWriteResult& res) {
  env_->stream_base_state()[kBytesWritten] = res.bytes;
  env_->stream_base_state()[kLastWriteWasAsync] = res.async;
}",174.0,177.0,1.0,1.0,4.0,8,4,6,4,0,0,1,1,0,0,,0,0,2,1,1,void
4937,277132,Writev,1,node.StreamBase.Writev,int node.StreamBase.Writev (FunctionCallbackInfo<Value>),stream_base.cc,"int StreamBase::Writev(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();
  Local<Context> context = env->context();

  CHECK(args[0]->IsObject());
  CHECK(args[1]->IsArray());

  Local<Object> req_wrap_obj = args[0].As<Object>();
  Local<Array> chunks = args[1].As<Array>();
  bool all_buffers = args[2]->IsTrue();

  size_t count;
  if (all_buffers)
    count = chunks->Length();
  else
    count = chunks->Length() >> 1;

  MaybeStackBuffer<uv_buf_t, 16> bufs(count);

  size_t storage_size = 0;
  size_t offset;

  if (!all_buffers) {
    // Determine storage size first
    for (size_t i = 0; i < count; i++) {
      Local<Value> chunk;
      if (!chunks->Get(context, i * 2).ToLocal(&chunk))
        return -1;

      if (Buffer::HasInstance(chunk))
        continue;
        // Buffer chunk, no additional storage required

      // String chunk
      Local<String> string;
      if (!chunk->ToString(context)...",179.0,293.0,1.0,1.0,115.0,148,21,154,38,0,0,20,39,0,0,,0,0,2,1,1,int
4938,277695,WriteBuffer,1,node.StreamBase.WriteBuffer,int node.StreamBase.WriteBuffer (FunctionCallbackInfo<Value>),stream_base.cc,"int StreamBase::WriteBuffer(const FunctionCallbackInfo<Value>& args) {
  CHECK(args[0]->IsObject());

  Environment* env = Environment::GetCurrent(args);

  if (!args[1]->IsUint8Array()) {
    node::THROW_ERR_INVALID_ARG_TYPE(env, ""Second argument must be a buffer"");
    return 0;
  }

  Local<Object> req_wrap_obj = args[0].As<Object>();
  uv_buf_t buf;
  buf.base = Buffer::Data(args[1]);
  buf.len = Buffer::Length(args[1]);

  uv_stream_t* send_handle = nullptr;

  if (args[2]->IsObject() && IsIPCPipe()) {
    Local<Object> send_handle_obj = args[2].As<Object>();

    HandleWrap* wrap;
    ASSIGN_OR_RETURN_UNWRAP(&wrap, send_handle_obj, UV_EINVAL);
    send_handle = reinterpret_cast<uv_stream_t*>(wrap->GetHandle());
    // Reference LibuvStreamWrap instance to prevent it from being garbage
    // collected before `AfterWrite` is called.
    if (req_wrap_obj->Set(env->context(),
                          env->handle_string(),
                          send_handle_obj).IsNothing()) {...",296.0,332.0,1.0,1.0,37.0,42,11,38,14,0,0,4,5,0,0,,0,0,2,1,1,int
4939,277843,WriteString,1,node.StreamBase.WriteString,int node.StreamBase.WriteString<enum encoding> (FunctionCallbackInfo<Value>),stream_base.cc,"int StreamBase::WriteString(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();
  CHECK(args[0]->IsObject());
  CHECK(args[1]->IsString());

  Local<Object> req_wrap_obj = args[0].As<Object>();
  Local<String> string = args[1].As<String>();
  Local<Object> send_handle_obj;
  if (args[2]->IsObject())
    send_handle_obj = args[2].As<Object>();

  // Compute the size of the storage that the string will be flattened into.
  // For UTF8 strings that are very long, go ahead and take the hit for
  // computing their actual size, rather than tripling the storage.
  size_t storage_size;
  if ((enc == UTF8 &&
         string->Length() > 65535 &&
         !StringBytes::Size(isolate, string, enc).To(&storage_size)) ||
          !StringBytes::StorageSize(isolate, string, enc).To(&storage_size)) {
    return -1;
  }

  if (storage_size > INT_MAX)
    return UV_ENOBUFS;

  // Try writing immediately if write size isn'...",336.0,443.0,1.0,1.0,108.0,108,20,115,33,0,0,10,12,0,0,,0,0,2,1,1,int
4940,278244,CallJSOnreadMethod,1,node.StreamBase.CallJSOnreadMethod,"MaybeLocal<Value> node.StreamBase.CallJSOnreadMethod (ssize_t,Local<ArrayBuffer>,size_t,StreamBaseJSChecks)",stream_base.cc,"MaybeLocal<Value> StreamBase::CallJSOnreadMethod(ssize_t nread,
                                                 Local<ArrayBuffer> ab,
                                                 size_t offset,
                                                 StreamBaseJSChecks checks) {
  Environment* env = env_;

  DCHECK_EQ(static_cast<int32_t>(nread), nread);
  DCHECK_LE(offset, INT32_MAX);

  if (checks == DONT_SKIP_NREAD_CHECKS) {
    if (ab.IsEmpty()) {
      DCHECK_EQ(offset, 0);
      DCHECK_LE(nread, 0);
    } else {
      DCHECK_GE(nread, 0);
    }
  }

  env->stream_base_state()[kReadBytesOrError] = static_cast<int32_t>(nread);
  env->stream_base_state()[kArrayBufferOffset] = offset;

  Local<Value> argv[] = {
    ab.IsEmpty() ? Undefined(env->isolate()).As<Value>() : ab.As<Value>()
  };

  AsyncWrap* wrap = GetAsyncWrap();
  CHECK_NOT_NULL(wrap);
  Local<Value> onread = wrap->object()->GetInternalField(
      StreamBase::kOnReadFunctionField);
  CHECK(onread->IsFunction());
  retu...",446.0,477.0,1.0,1.0,32.0,28,10,33,16,0,0,3,4,0,0,,0,0,8,4,4,MaybeLocal<Value>
4941,278364,IsIPCPipe,1,node.StreamBase.IsIPCPipe,bool node.StreamBase.IsIPCPipe (),stream_base.cc,"bool StreamBase::IsIPCPipe() {
  return false;
}",480.0,482.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,bool
4942,278370,GetFD,1,node.StreamBase.GetFD,int node.StreamBase.GetFD (),stream_base.cc,"void StreamBase::GetFD(const FunctionCallbackInfo<Value>& args) {
  // Mimic implementation of StreamBase::GetFD() and UDPWrap::GetFD().
  StreamBase* wrap = StreamBase::FromObject(args.This().As<Object>());
  if (wrap == nullptr) return args.GetReturnValue().Set(UV_EINVAL);

  if (!wrap->IsAlive()) return args.GetReturnValue().Set(UV_EINVAL);

  args.GetReturnValue().Set(wrap->GetFD());
}",598.0,606.0,1.0,1.0,9.0,1,1,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
4943,278377,GetObject,1,node.StreamBase.GetObject,Local<Object> node.StreamBase.GetObject (),stream_base.cc,"Local<Object> StreamBase::GetObject() {
  return GetAsyncWrap()->object();
}",490.0,492.0,1.0,1.0,3.0,1,1,0,0,0,0,1,1,0,0,,0,0,0,0,0,Local<Object>
4944,278386,AddMethod,1,node.StreamBase.AddMethod,"void node.StreamBase.AddMethod (Isolate*,Local<Signature>,PropertyAttribute,Local<FunctionTemplate>,JSMethodFunction*,Local<String>)",stream_base.cc,"void StreamBase::AddMethod(Isolate* isolate,
                           Local<Signature> signature,
                           enum PropertyAttribute attributes,
                           Local<FunctionTemplate> t,
                           JSMethodFunction* stream_method,
                           Local<String> string) {
  Local<FunctionTemplate> templ =
      NewFunctionTemplate(isolate,
                          stream_method,
                          signature,
                          ConstructorBehavior::kThrow,
                          SideEffectType::kHasNoSideEffect);
  t->PrototypeTemplate()->SetAccessorProperty(
      string, templ, Local<FunctionTemplate>(), attributes);
}",494.0,508.0,1.0,1.0,15.0,7,5,12,11,0,0,1,1,0,0,,0,0,12,6,6,void
4945,278423,AddMethods,1,node.StreamBase.AddMethods,"void node.StreamBase.AddMethods (Environment*,Local<FunctionTemplate>)",stream_base.cc,"void StreamBase::AddMethods(IsolateData* isolate_data,
                            Local<FunctionTemplate> t) {
  Isolate* isolate = isolate_data->isolate();
  HandleScope scope(isolate);

  enum PropertyAttribute attributes =
      static_cast<PropertyAttribute>(ReadOnly | DontDelete | DontEnum);
  Local<Signature> sig = Signature::New(isolate, t);

  AddMethod(isolate, sig, attributes, t, GetFD, isolate_data->fd_string());
  AddMethod(isolate,
            sig,
            attributes,
            t,
            GetExternal,
            isolate_data->external_stream_string());
  AddMethod(isolate,
            sig,
            attributes,
            t,
            GetBytesRead,
            isolate_data->bytes_read_string());
  AddMethod(isolate,
            sig,
            attributes,
            t,
            GetBytesWritten,
            isolate_data->bytes_written_string());
  SetProtoMethod(isolate, t, ""readStart"", JSMethod<&StreamBase::ReadStartJS>);
  SetProtoMethod(isolate, ...",514.0,568.0,1.0,1.0,55.0,1,1,2,2,0,0,1,1,0,0,,0,0,4,2,2,void
4946,278591,RegisterExternalReferences,1,node.StreamBase.RegisterExternalReferences,void node.StreamBase.RegisterExternalReferences (ExternalReferenceRegistry*),stream_base.cc,"void StreamBase::RegisterExternalReferences(
    ExternalReferenceRegistry* registry) {
  // This function is called by a single thread during start up, so it is safe
  // to use a local static variable here.
  static bool is_registered = false;
  if (is_registered) return;
  registry->Register(GetFD);
  registry->Register(GetExternal);
  registry->Register(GetBytesRead);
  registry->Register(GetBytesWritten);
  registry->Register(JSMethod<&StreamBase::ReadStartJS>);
  registry->Register(JSMethod<&StreamBase::ReadStopJS>);
  registry->Register(JSMethod<&StreamBase::Shutdown>);
  registry->Register(JSMethod<&StreamBase::UseUserBuffer>);
  registry->Register(JSMethod<&StreamBase::Writev>);
  registry->Register(JSMethod<&StreamBase::WriteBuffer>);
  registry->Register(JSMethod<&StreamBase::WriteString<ASCII>>);
  registry->Register(JSMethod<&StreamBase::WriteString<UTF8>>);
  registry->Register(JSMethod<&StreamBase::WriteString<UCS2>>);
  registry->Register(JSMethod<&StreamBase::WriteS...",570.0,596.0,1.0,1.0,27.0,20,3,35,17,0,0,2,2,0,0,,0,0,2,1,1,void
4947,278751,GetBytesRead,1,node.StreamBase.GetBytesRead,void node.StreamBase.GetBytesRead (FunctionCallbackInfo<Value>),stream_base.cc,"void StreamBase::GetBytesRead(const FunctionCallbackInfo<Value>& args) {
  StreamBase* wrap = StreamBase::FromObject(args.This().As<Object>());
  if (wrap == nullptr) return args.GetReturnValue().Set(0);

  // uint64_t -> double. 53bits is enough for all real cases.
  args.GetReturnValue().Set(static_cast<double>(wrap->bytes_read_));
}",608.0,614.0,1.0,1.0,7.0,11,5,7,3,0,0,2,2,0,0,,0,0,2,1,1,void
4948,278796,GetBytesWritten,1,node.StreamBase.GetBytesWritten,void node.StreamBase.GetBytesWritten (FunctionCallbackInfo<Value>),stream_base.cc,"void StreamBase::GetBytesWritten(const FunctionCallbackInfo<Value>& args) {
  StreamBase* wrap = StreamBase::FromObject(args.This().As<Object>());
  if (wrap == nullptr) return args.GetReturnValue().Set(0);

  // uint64_t -> double. 53bits is enough for all real cases.
  args.GetReturnValue().Set(static_cast<double>(wrap->bytes_written_));
}",616.0,622.0,1.0,1.0,7.0,11,5,7,3,0,0,2,2,0,0,,0,0,2,1,1,void
4949,278841,GetExternal,1,node.StreamBase.GetExternal,void node.StreamBase.GetExternal (FunctionCallbackInfo<Value>),stream_base.cc,"void StreamBase::GetExternal(const FunctionCallbackInfo<Value>& args) {
  StreamBase* wrap = StreamBase::FromObject(args.This().As<Object>());
  if (wrap == nullptr) return;

  Local<External> ext = External::New(args.GetIsolate(), wrap);
  args.GetReturnValue().Set(ext);
}",624.0,630.0,1.0,1.0,7.0,12,5,12,6,0,0,2,2,0,0,,0,0,2,1,1,void
4950,278889,JSMethod,1,node.StreamBase.JSMethod,void node.StreamBase.JSMethod<int(StreamBase::*)(const FunctionCallbackInfo<Value>&)> (FunctionCallbackInfo<Value>),stream_base.cc,"void StreamBase::JSMethod(const FunctionCallbackInfo<Value>& args) {
  StreamBase* wrap = StreamBase::FromObject(args.Holder().As<Object>());
  if (wrap == nullptr) return;

  if (!wrap->IsAlive()) return args.GetReturnValue().Set(UV_EINVAL);

  AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(wrap->GetAsyncWrap());
  args.GetReturnValue().Set((wrap->*Method)(args));
}",633.0,641.0,1.0,1.0,9.0,13,5,12,5,0,0,3,3,0,0,,0,0,2,1,1,void
4951,278948,DoTryWrite,1,node.StreamResource.DoTryWrite,"int node.StreamResource.DoTryWrite (uv_buf_t**,size_t*)",stream_base.cc,"int StreamResource::DoTryWrite(uv_buf_t** bufs, size_t* count) {
  // No TryWrite by default
  return 0;
}",643.0,646.0,1.0,1.0,4.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
4952,278956,Error,1,node.StreamResource.Error,const char* node.StreamResource.Error (),stream_base.cc,"const char* StreamResource::Error() const {
  return nullptr;
}",649.0,651.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,const char*
4953,278962,ClearError,1,node.StreamResource.ClearError,void node.StreamResource.ClearError (),stream_base.cc,"void StreamResource::ClearError() {
  // No-op
}",654.0,656.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
4954,278966,OnStreamAlloc,1,node.EmitToJSStreamListener.OnStreamAlloc,uv_buf_t node.EmitToJSStreamListener.OnStreamAlloc (size_t),stream_base.cc,"uv_buf_t EmitToJSStreamListener::OnStreamAlloc(size_t suggested_size) {
  CHECK_NOT_NULL(stream_);
  Environment* env = static_cast<StreamBase*>(stream_)->stream_env();
  return env->allocate_managed_buffer(suggested_size);
}",659.0,663.0,1.0,1.0,5.0,4,3,4,3,0,0,1,1,0,0,,0,0,2,1,1,uv_buf_t
4955,278987,OnStreamRead,1,node.EmitToJSStreamListener.OnStreamRead,"void node.EmitToJSStreamListener.OnStreamRead (ssize_t,uv_buf_t)",stream_base.cc,"void EmitToJSStreamListener::OnStreamRead(ssize_t nread, const uv_buf_t& buf_) {
  CHECK_NOT_NULL(stream_);
  StreamBase* stream = static_cast<StreamBase*>(stream_);
  Environment* env = stream->stream_env();
  Isolate* isolate = env->isolate();
  HandleScope handle_scope(isolate);
  Context::Scope context_scope(env->context());
  std::unique_ptr<BackingStore> bs = env->release_managed_buffer(buf_);

  if (nread <= 0)  {
    if (nread < 0)
      stream->CallJSOnreadMethod(nread, Local<ArrayBuffer>());
    return;
  }

  CHECK_LE(static_cast<size_t>(nread), bs->ByteLength());
  bs = BackingStore::Reallocate(isolate, std::move(bs), nread);

  stream->CallJSOnreadMethod(nread, ArrayBuffer::New(isolate, std::move(bs)));
}",665.0,684.0,1.0,1.0,20.0,23,7,31,10,0,0,3,4,0,0,,0,0,4,2,2,void
4956,279089,OnStreamAlloc,1,node.CustomBufferJSListener.OnStreamAlloc,uv_buf_t node.CustomBufferJSListener.OnStreamAlloc (size_t),stream_base.cc,"uv_buf_t CustomBufferJSListener::OnStreamAlloc(size_t suggested_size) {
  return buffer_;
}",687.0,689.0,1.0,1.0,3.0,0,0,1,1,0,0,1,1,0,0,,0,0,2,1,1,uv_buf_t
4957,279096,OnStreamRead,1,node.CustomBufferJSListener.OnStreamRead,"void node.CustomBufferJSListener.OnStreamRead (ssize_t,uv_buf_t)",stream_base.cc,"void CustomBufferJSListener::OnStreamRead(ssize_t nread, const uv_buf_t& buf) {
  CHECK_NOT_NULL(stream_);

  StreamBase* stream = static_cast<StreamBase*>(stream_);
  Environment* env = stream->stream_env();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());

  // In the case that there's an error and buf is null, return immediately.
  // This can happen on unices when POLLHUP is received and UV_EOF is returned
  // or when getting an error while performing a UV_HANDLE_ZERO_READ on Windows.
  if (buf.base == nullptr && nread < 0) {
    stream->CallJSOnreadMethod(nread, Local<ArrayBuffer>());
    return;
  }

  CHECK_EQ(buf.base, buffer_.base);

  MaybeLocal<Value> ret = stream->CallJSOnreadMethod(nread,
                             Local<ArrayBuffer>(),
                             0,
                             StreamBase::SKIP_NREAD_CHECKS);
  Local<Value> next_buf_v;
  if (ret.ToLocal(&next_buf_v) && !next_buf_v->IsUndefined()) {
    buf...",692.0,719.0,1.0,1.0,28.0,31,10,30,13,0,0,3,3,0,0,,0,0,4,2,2,void
4958,279206,OnStreamAfterReqFinished,1,node.ReportWritesToJSStreamListener.OnStreamAfterReqFinished,"void node.ReportWritesToJSStreamListener.OnStreamAfterReqFinished (StreamReq*,int)",stream_base.cc,"void ReportWritesToJSStreamListener::OnStreamAfterReqFinished(
    StreamReq* req_wrap, int status) {
  StreamBase* stream = static_cast<StreamBase*>(stream_);
  Environment* env = stream->stream_env();
  if (!env->can_call_into_js()) return;
  AsyncWrap* async_wrap = req_wrap->GetAsyncWrap();
  HandleScope handle_scope(env->isolate());
  Context::Scope context_scope(env->context());
  CHECK(!async_wrap->persistent().IsEmpty());
  Local<Object> req_wrap_obj = async_wrap->object();

  Local<Value> argv[] = {
    Integer::New(env->isolate(), status),
    stream->GetObject(),
    Undefined(env->isolate())
  };

  const char* msg = stream->Error();
  if (msg != nullptr) {
    argv[2] = OneByteString(env->isolate(), msg);
    stream->ClearError();
  }

  if (req_wrap_obj->Has(env->context(), env->oncomplete_string()).FromJust())
    async_wrap->MakeCallback(env->oncomplete_string(), arraysize(argv), argv);
}",722.0,747.0,1.0,1.0,26.0,36,10,34,12,0,0,4,4,0,0,,0,0,4,2,2,void
4959,279347,OnStreamAfterWrite,1,node.ReportWritesToJSStreamListener.OnStreamAfterWrite,"void node.ReportWritesToJSStreamListener.OnStreamAfterWrite (WriteWrap*,int)",stream_base.cc,"void ReportWritesToJSStreamListener::OnStreamAfterWrite(
    WriteWrap* req_wrap, int status) {
  OnStreamAfterReqFinished(req_wrap, status);
}",749.0,752.0,1.0,1.0,4.0,0,0,2,2,0,0,1,1,0,0,,0,0,4,2,2,void
4960,279356,OnStreamAfterShutdown,1,node.ReportWritesToJSStreamListener.OnStreamAfterShutdown,"void node.ReportWritesToJSStreamListener.OnStreamAfterShutdown (ShutdownWrap*,int)",stream_base.cc,"void ReportWritesToJSStreamListener::OnStreamAfterShutdown(
    ShutdownWrap* req_wrap, int status) {
  OnStreamAfterReqFinished(req_wrap, status);
}",754.0,757.0,1.0,1.0,4.0,0,0,2,2,0,0,1,1,0,0,,0,0,4,2,2,void
4961,279365,OnDone,1,node.ShutdownWrap.OnDone,void node.ShutdownWrap.OnDone (int),stream_base.cc,"void ShutdownWrap::OnDone(int status) {
  stream()->EmitAfterShutdown(this, status);
  Dispose();
}",759.0,762.0,1.0,1.0,4.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,void
4962,279377,OnDone,1,node.WriteWrap.OnDone,void node.WriteWrap.OnDone (int),stream_base.cc,"void WriteWrap::OnDone(int status) {
  stream()->EmitAfterWrite(this, status);
  Dispose();
}",764.0,767.0,1.0,1.0,4.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,void
4963,279389,~StreamListener,1,node.StreamListener.~StreamListener,ANY node.StreamListener.~StreamListener (),stream_base.cc,"StreamListener::~StreamListener() {
  if (stream_ != nullptr)
    stream_->RemoveStreamListener(this);
}",769.0,772.0,1.0,1.0,4.0,2,2,2,1,0,0,2,2,0,0,,0,0,0,0,0,ANY
4964,279403,OnStreamAfterShutdown,1,node.StreamListener.OnStreamAfterShutdown,"void node.StreamListener.OnStreamAfterShutdown (ShutdownWrap*,int)",stream_base.cc,"void StreamListener::OnStreamAfterShutdown(ShutdownWrap* w, int status) {
  CHECK_NOT_NULL(previous_listener_);
  previous_listener_->OnStreamAfterShutdown(w, status);
}",774.0,777.0,1.0,1.0,4.0,1,1,3,3,0,0,1,1,0,0,,0,0,4,2,2,void
4965,279416,OnStreamAfterWrite,1,node.StreamListener.OnStreamAfterWrite,"void node.StreamListener.OnStreamAfterWrite (WriteWrap*,int)",stream_base.cc,"void StreamListener::OnStreamAfterWrite(WriteWrap* w, int status) {
  CHECK_NOT_NULL(previous_listener_);
  previous_listener_->OnStreamAfterWrite(w, status);
}",779.0,782.0,1.0,1.0,4.0,1,1,3,3,0,0,1,1,0,0,,0,0,4,2,2,void
4966,279429,~StreamResource,1,node.StreamResource.~StreamResource,ANY node.StreamResource.~StreamResource (),stream_base.cc,"StreamResource::~StreamResource() {
  while (listener_ != nullptr) {
    StreamListener* listener = listener_;
    listener->OnStreamDestroy();
    // Remove the listener if it didnt remove itself. This makes the logic
    // in `OnStreamDestroy()` implementations easier, because they
    // may call generic cleanup functions which can just remove the
    // listener unconditionally.
    if (listener == listener_)
      RemoveStreamListener(listener_);
  }
}",784.0,795.0,1.0,1.0,12.0,4,4,6,2,0,0,3,4,0,0,,0,0,0,0,0,ANY
4967,279452,RemoveStreamListener,1,node.StreamResource.RemoveStreamListener,void node.StreamResource.RemoveStreamListener (StreamListener*),stream_base.cc,"void StreamResource::RemoveStreamListener(StreamListener* listener) {
  CHECK_NOT_NULL(listener);

  StreamListener* previous;
  StreamListener* current;

  // Remove from the linked list.
  // No loop condition because we want a crash if listener is not found.
  for (current = listener_, previous = nullptr;;
       previous = current, current = current->previous_listener_) {
    CHECK_NOT_NULL(current);
    if (current == listener) {
      if (previous != nullptr)
        previous->previous_listener_ = current->previous_listener_;
      else
        listener_ = listener->previous_listener_;
      break;
    }
  }

  listener->stream_ = nullptr;
  listener->previous_listener_ = nullptr;
}",797.0,819.0,1.0,1.0,23.0,16,5,16,4,0,0,5,7,0,0,,0,0,2,1,1,void
4968,279517,CreateShutdownWrap,1,node.StreamBase.CreateShutdownWrap,ShutdownWrap node.StreamBase.CreateShutdownWrap (Local<Object>),stream_base.cc,"ShutdownWrap* StreamBase::CreateShutdownWrap(
    Local<Object> object) {
  auto* wrap = new SimpleShutdownWrap<AsyncWrap>(this, object);
  wrap->MakeWeak();
  return wrap;
}",821.0,826.0,1.0,1.0,6.0,3,3,5,3,0,0,1,1,0,0,,0,0,2,1,1,ShutdownWrap
4969,279535,CreateWriteWrap,1,node.StreamBase.CreateWriteWrap,WriteWrap node.StreamBase.CreateWriteWrap (Local<Object>),stream_base.cc,"WriteWrap* StreamBase::CreateWriteWrap(
    Local<Object> object) {
  auto* wrap = new SimpleWriteWrap<AsyncWrap>(this, object);
  wrap->MakeWeak();
  return wrap;
}",828.0,833.0,1.0,1.0,6.0,3,3,5,3,0,0,1,1,0,0,,0,0,2,1,1,WriteWrap
4970,279553,Done,1,node.StreamReq.Done,"void node.StreamReq.Done (int,char*)",stream_base.cc,"void StreamReq::Done(int status, const char* error_str) {
  AsyncWrap* async_wrap = GetAsyncWrap();
  Environment* env = async_wrap->env();
  if (error_str != nullptr) {
    v8::HandleScope handle_scope(env->isolate());
    if (async_wrap->object()
            ->Set(env->context(),
                  env->error_string(),
                  OneByteString(env->isolate(), error_str))
            .IsNothing()) {
      return;
    }
  }

  OnDone(status);
}",835.0,850.0,1.0,1.0,16.0,11,4,11,4,0,0,3,4,0,0,,0,0,4,2,2,void
4971,279626,<lambda>0,1,node.StreamPipe.Unpipe.<lambda>0,ANY node.StreamPipe.Unpipe.<lambda>0 (Environment*),stream_pipe.cc,"[this, strong_ref](Environment* env) {
    HandleScope handle_scope(env->isolate());
    Context::Scope context_scope(env->context());
    Local<Object> object = this->object();

    Local<Value> onunpipe;
    if (!object->Get(env->context(), env->onunpipe_string()).ToLocal(&onunpipe))
      return;
    if (onunpipe->IsFunction() &&
        MakeCallback(onunpipe.As<Function>(), 0, nullptr).IsEmpty()) {
      return;
    }

    // Set all the links established in the constructor to `null`.
    Local<Value> null = Null(env->isolate());

    Local<Value> source_v;
    Local<Value> sink_v;
    if (!object->Get(env->context(), env->source_string()).ToLocal(&source_v) ||
        !object->Get(env->context(), env->sink_string()).ToLocal(&sink_v) ||
        !source_v->IsObject() || !sink_v->IsObject()) {
      return;
    }

    if (object->Set(env->context(), env->source_string(), null).IsNothing() ||
        object->Set(env->context(), env->sink_string(), null).IsNothing() ||
        sourc...",71.0,105.0,23.0,3.0,35.0,66,9,50,9,0,0,5,5,0,0,,0,0,2,1,1,ANY
4972,279860,StreamPipe,1,node.StreamPipe.StreamPipe,"ANY node.StreamPipe.StreamPipe (StreamBase*,StreamBase*,Local<Object>)",stream_pipe.cc,"StreamPipe::StreamPipe(StreamBase* source,
                       StreamBase* sink,
                       Local<Object> obj)
    : AsyncWrap(source->stream_env(), obj, AsyncWrap::PROVIDER_STREAMPIPE) {
  MakeWeak();

  CHECK_NOT_NULL(sink);
  CHECK_NOT_NULL(source);

  source->PushStreamListener(&readable_listener_);
  sink->PushStreamListener(&writable_listener_);

  uses_wants_write_ = sink->HasWantsWrite();
}",22.0,35.0,1.0,1.0,14.0,6,3,8,5,0,0,1,1,0,0,,0,0,6,3,3,ANY
4973,279890,~StreamPipe,1,node.StreamPipe.~StreamPipe,ANY node.StreamPipe.~StreamPipe (),stream_pipe.cc,"StreamPipe::~StreamPipe() {
  Unpipe(true);
}",37.0,39.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
4974,279896,source,1,node.StreamPipe.source,StreamBase node.StreamPipe.source (),stream_pipe.cc,"StreamBase* StreamPipe::source() {
  return static_cast<StreamBase*>(readable_listener_.stream());
}",41.0,43.0,1.0,1.0,3.0,2,2,1,1,0,0,1,1,0,0,,0,0,0,0,0,StreamBase
4975,279907,sink,1,node.StreamPipe.sink,StreamBase node.StreamPipe.sink (),stream_pipe.cc,"StreamBase* StreamPipe::sink() {
  return static_cast<StreamBase*>(writable_listener_.stream());
}",45.0,47.0,1.0,1.0,3.0,2,2,1,1,0,0,1,1,0,0,,0,0,0,0,0,StreamBase
4976,279918,Unpipe,1,node.StreamPipe.Unpipe,void node.StreamPipe.Unpipe (bool),stream_pipe.cc,"void StreamPipe::Unpipe(const FunctionCallbackInfo<Value>& args) {
  StreamPipe* pipe;
  ASSIGN_OR_RETURN_UNWRAP(&pipe, args.Holder());
  pipe->Unpipe();
}",292.0,296.0,1.0,1.0,5.0,14,8,10,9,0,0,5,5,0,0,,0,0,2,1,1,void
4977,279980,OnStreamAlloc,1,node.StreamPipe.ReadableListener.OnStreamAlloc,uv_buf_t node.StreamPipe.ReadableListener.OnStreamAlloc (size_t),stream_pipe.cc,"uv_buf_t StreamPipe::ReadableListener::OnStreamAlloc(size_t suggested_size) {
  StreamPipe* pipe = ContainerOf(&StreamPipe::readable_listener_, this);
  size_t size = std::min(suggested_size, pipe->wanted_data_);
  CHECK_GT(size, 0);
  return pipe->env()->allocate_managed_buffer(size);
}",108.0,113.0,1.0,1.0,6.0,8,4,9,5,0,0,1,1,0,0,,0,0,2,1,1,uv_buf_t
4978,280017,OnStreamRead,1,node.StreamPipe.ReadableListener.OnStreamRead,"void node.StreamPipe.ReadableListener.OnStreamRead (ssize_t,uv_buf_t)",stream_pipe.cc,"void StreamPipe::ReadableListener::OnStreamRead(ssize_t nread,
                                                const uv_buf_t& buf_) {
  StreamPipe* pipe = ContainerOf(&StreamPipe::readable_listener_, this);
  std::unique_ptr<BackingStore> bs = pipe->env()->release_managed_buffer(buf_);
  if (nread < 0) {
    // EOF or error; stop reading and pass the error to the previous listener
    // (which might end up in JS).
    pipe->is_eof_ = true;
    // Cache `sink()` here because the previous listener might do things
    // that eventually lead to an `Unpipe()` call.
    StreamBase* sink = pipe->sink();
    stream()->ReadStop();
    CHECK_NOT_NULL(previous_listener_);
    previous_listener_->OnStreamRead(nread, uv_buf_init(nullptr, 0));
    // If were not writing, close now. Otherwise, well do that in
    // `OnStreamAfterWrite()`.
    if (pipe->pending_writes_ == 0) {
      sink->Shutdown();
      pipe->Unpipe();
    }
    return;
  }

  pipe->ProcessData(nread, std::move(bs));
}",115.0,139.0,1.0,1.0,25.0,22,7,20,9,0,0,3,4,0,0,,0,0,4,2,2,void
4979,280104,ProcessData,1,node.StreamPipe.ProcessData,"void node.StreamPipe.ProcessData (size_t,ANY)",stream_pipe.cc,"void StreamPipe::ProcessData(size_t nread,
                             std::unique_ptr<BackingStore> bs) {
  CHECK(uses_wants_write_ || pending_writes_ == 0);
  uv_buf_t buffer = uv_buf_init(static_cast<char*>(bs->Data()), nread);
  StreamWriteResult res = sink()->Write(&buffer, 1);
  pending_writes_++;
  if (!res.async) {
    writable_listener_.OnStreamAfterWrite(nullptr, res.err);
  } else {
    is_reading_ = false;
    res.wrap->SetBackingStore(std::move(bs));
    if (source() != nullptr)
      source()->ReadStop();
  }
}",141.0,155.0,1.0,1.0,15.0,13,9,11,7,0,0,2,2,0,0,,0,0,4,2,2,void
4980,280178,OnStreamAfterWrite,1,node.StreamPipe.WritableListener.OnStreamAfterWrite,"void node.StreamPipe.WritableListener.OnStreamAfterWrite (WriteWrap*,int)",stream_pipe.cc,"void StreamPipe::WritableListener::OnStreamAfterWrite(WriteWrap* w,
                                                      int status) {
  StreamPipe* pipe = ContainerOf(&StreamPipe::writable_listener_, this);
  pipe->pending_writes_--;
  if (pipe->is_closed_) {
    if (pipe->pending_writes_ == 0) {
      Environment* env = pipe->env();
      HandleScope handle_scope(env->isolate());
      Context::Scope context_scope(env->context());
      if (pipe->MakeCallback(env->oncomplete_string(), 0, nullptr).IsEmpty())
        return;
      stream()->RemoveStreamListener(this);
    }
    return;
  }

  if (pipe->is_eof_) {
    HandleScope handle_scope(pipe->env()->isolate());
    InternalCallbackScope callback_scope(pipe,
        InternalCallbackScope::kSkipTaskQueues);
    pipe->sink()->Shutdown();
    pipe->Unpipe();
    return;
  }

  if (status != 0) {
    CHECK_NOT_NULL(previous_listener_);
    StreamListener* prev = previous_listener_;
    pipe->Unpipe();
    prev->OnStreamAfterWrite(w...",157.0,193.0,1.0,1.0,37.0,29,8,25,8,0,0,7,10,0,0,,0,0,4,2,2,void
4981,280311,OnStreamAfterShutdown,1,node.StreamPipe.WritableListener.OnStreamAfterShutdown,"void node.StreamPipe.WritableListener.OnStreamAfterShutdown (ShutdownWrap*,int)",stream_pipe.cc,"void StreamPipe::WritableListener::OnStreamAfterShutdown(ShutdownWrap* w,
                                                         int status) {
  StreamPipe* pipe = ContainerOf(&StreamPipe::writable_listener_, this);
  CHECK_NOT_NULL(previous_listener_);
  StreamListener* prev = previous_listener_;
  pipe->Unpipe();
  prev->OnStreamAfterShutdown(w, status);
}",195.0,202.0,1.0,1.0,8.0,6,4,8,6,0,0,1,1,0,0,,0,0,4,2,2,void
4982,280341,OnStreamDestroy,1,node.StreamPipe.ReadableListener.OnStreamDestroy,void node.StreamPipe.ReadableListener.OnStreamDestroy (),stream_pipe.cc,"void StreamPipe::ReadableListener::OnStreamDestroy() {
  StreamPipe* pipe = ContainerOf(&StreamPipe::readable_listener_, this);
  pipe->source_destroyed_ = true;
  if (!pipe->is_eof_) {
    OnStreamRead(UV_EPIPE, uv_buf_init(nullptr, 0));
  }
}",204.0,210.0,1.0,1.0,7.0,7,5,5,3,0,0,2,2,0,0,,0,0,0,0,0,void
4983,280370,OnStreamDestroy,1,node.StreamPipe.WritableListener.OnStreamDestroy,void node.StreamPipe.WritableListener.OnStreamDestroy (),stream_pipe.cc,"void StreamPipe::WritableListener::OnStreamDestroy() {
  StreamPipe* pipe = ContainerOf(&StreamPipe::writable_listener_, this);
  pipe->sink_destroyed_ = true;
  pipe->is_eof_ = true;
  pipe->pending_writes_ = 0;
  pipe->Unpipe();
}",212.0,218.0,1.0,1.0,7.0,10,4,6,2,0,0,1,1,0,0,,0,0,0,0,0,void
4984,280402,OnStreamWantsWrite,1,node.StreamPipe.WritableListener.OnStreamWantsWrite,void node.StreamPipe.WritableListener.OnStreamWantsWrite (size_t),stream_pipe.cc,"void StreamPipe::WritableListener::OnStreamWantsWrite(size_t suggested_size) {
  StreamPipe* pipe = ContainerOf(&StreamPipe::writable_listener_, this);
  pipe->wanted_data_ = suggested_size;
  if (pipe->is_reading_ || pipe->is_closed_)
    return;
  HandleScope handle_scope(pipe->env()->isolate());
  InternalCallbackScope callback_scope(pipe,
      InternalCallbackScope::kSkipTaskQueues);
  pipe->is_reading_ = true;
  pipe->source()->ReadStart();
}",220.0,230.0,1.0,1.0,11.0,15,5,11,4,0,0,2,2,0,0,,0,0,2,1,1,void
4985,280458,OnStreamAlloc,1,node.StreamPipe.WritableListener.OnStreamAlloc,uv_buf_t node.StreamPipe.WritableListener.OnStreamAlloc (size_t),stream_pipe.cc,"uv_buf_t StreamPipe::WritableListener::OnStreamAlloc(size_t suggested_size) {
  CHECK_NOT_NULL(previous_listener_);
  return previous_listener_->OnStreamAlloc(suggested_size);
}",232.0,235.0,1.0,1.0,4.0,1,1,2,2,0,0,1,1,0,0,,0,0,2,1,1,uv_buf_t
4986,280470,OnStreamRead,1,node.StreamPipe.WritableListener.OnStreamRead,"void node.StreamPipe.WritableListener.OnStreamRead (ssize_t,uv_buf_t)",stream_pipe.cc,"void StreamPipe::WritableListener::OnStreamRead(ssize_t nread,
                                                const uv_buf_t& buf) {
  CHECK_NOT_NULL(previous_listener_);
  return previous_listener_->OnStreamRead(nread, buf);
}",237.0,241.0,1.0,1.0,5.0,1,1,3,3,0,0,1,1,0,0,,0,0,4,2,2,void
4987,280484,New,1,node.StreamPipe.New,"Maybe<StreamPipe*> node.StreamPipe.New (StreamBase*,StreamBase*,Local<Object>)",stream_pipe.cc,"void StreamPipe::New(const FunctionCallbackInfo<Value>& args) {
  CHECK(args.IsConstructCall());
  CHECK(args[0]->IsObject());
  CHECK(args[1]->IsObject());
  StreamBase* source = StreamBase::FromObject(args[0].As<Object>());
  StreamBase* sink = StreamBase::FromObject(args[1].As<Object>());

  if (StreamPipe::New(source, sink, args.This()).IsNothing()) return;
}",275.0,283.0,1.0,1.0,9.0,27,6,25,7,0,0,5,5,0,0,,0,0,2,1,1,void
4988,280674,Start,1,node.StreamPipe.Start,void node.StreamPipe.Start (FunctionCallbackInfo<Value>),stream_pipe.cc,"void StreamPipe::Start(const FunctionCallbackInfo<Value>& args) {
  StreamPipe* pipe;
  ASSIGN_OR_RETURN_UNWRAP(&pipe, args.Holder());
  pipe->is_closed_ = false;
  pipe->writable_listener_.OnStreamWantsWrite(65536);
}",285.0,290.0,1.0,1.0,6.0,6,4,4,2,0,0,1,1,0,0,,0,0,2,1,1,void
4989,280716,IsClosed,1,node.StreamPipe.IsClosed,void node.StreamPipe.IsClosed (FunctionCallbackInfo<Value>),stream_pipe.cc,"void StreamPipe::IsClosed(const FunctionCallbackInfo<Value>& args) {
  StreamPipe* pipe;
  ASSIGN_OR_RETURN_UNWRAP(&pipe, args.Holder());
  args.GetReturnValue().Set(pipe->is_closed_);
}",298.0,302.0,1.0,1.0,5.0,5,3,4,2,0,0,1,1,0,0,,0,0,2,1,1,void
4990,280739,PendingWrites,1,node.StreamPipe.PendingWrites,void node.StreamPipe.PendingWrites (FunctionCallbackInfo<Value>),stream_pipe.cc,"void StreamPipe::PendingWrites(const FunctionCallbackInfo<Value>& args) {
  StreamPipe* pipe;
  ASSIGN_OR_RETURN_UNWRAP(&pipe, args.Holder());
  args.GetReturnValue().Set(pipe->pending_writes_);
}",304.0,308.0,1.0,1.0,5.0,5,3,4,2,0,0,1,1,0,0,,0,0,2,1,1,void
4991,280763,InitializeStreamPipe,1,node.anonymous_namespace_1.InitializeStreamPipe,"void node.anonymous_namespace_1.InitializeStreamPipe (Local<Object>,Local<Value>,Local<Context>,void*)",stream_pipe.cc,"void InitializeStreamPipe(Local<Object> target,
                          Local<Value> unused,
                          Local<Context> context,
                          void* priv) {
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  // Create FunctionTemplate for FileHandle::CloseReq
  Local<FunctionTemplate> pipe = NewFunctionTemplate(isolate, StreamPipe::New);
  SetProtoMethod(isolate, pipe, ""unpipe"", StreamPipe::Unpipe);
  SetProtoMethod(isolate, pipe, ""start"", StreamPipe::Start);
  SetProtoMethod(isolate, pipe, ""isClosed"", StreamPipe::IsClosed);
  SetProtoMethod(isolate, pipe, ""pendingWrites"", StreamPipe::PendingWrites);
  pipe->Inherit(AsyncWrap::GetConstructorTemplate(env));
  pipe->InstanceTemplate()->SetInternalFieldCount(
      StreamPipe::kInternalFieldCount);
  SetConstructorFunction(context, target, ""StreamPipe"", pipe);
}",312.0,329.0,1.0,1.0,18.0,17,5,30,10,0,0,1,1,0,0,,0,0,8,4,4,void
4992,280858,<lambda>0,1,node.LibuvStreamWrap.ReadStart.<lambda>0,"ANY node.LibuvStreamWrap.ReadStart.<lambda>0 (uv_handle_t*,size_t,uv_buf_t*)",stream_wrap.cc,"[](uv_handle_t* handle, size_t suggested_size, uv_buf_t* buf) {
        static_cast<LibuvStreamWrap*>(handle->data)
            ->OnUvAlloc(suggested_size, buf);
      }",205.0,208.0,7.0,7.0,4.0,3,2,3,3,0,0,1,1,0,0,,0,0,6,3,3,ANY
4993,280877,<lambda>1,1,node.LibuvStreamWrap.ReadStart.<lambda>1,"ANY node.LibuvStreamWrap.ReadStart.<lambda>1 (uv_stream_t*,ssize_t,uv_buf_t*)",stream_wrap.cc,"[](uv_stream_t* stream, ssize_t nread, const uv_buf_t* buf) {
        LibuvStreamWrap* wrap = static_cast<LibuvStreamWrap*>(stream->data);
        TryCatchScope try_catch(wrap->env());
        try_catch.SetVerbose(true);
        wrap->OnUvRead(nread, buf);
      }",209.0,214.0,7.0,7.0,6.0,6,4,7,5,0,0,1,1,0,0,,0,0,6,3,3,ANY
4994,280942,IsConstructCallCallback,1,node.IsConstructCallCallback,void node.IsConstructCallCallback (FunctionCallbackInfo<Value>),stream_wrap.cc,"void IsConstructCallCallback(const FunctionCallbackInfo<Value>& args) {
  CHECK(args.IsConstructCall());
  StreamReq::ResetObject(args.This());
}",61.0,64.0,1.0,1.0,4.0,3,1,3,2,0,0,1,1,0,0,,0,0,2,1,1,void
4995,280960,Initialize,1,node.LibuvStreamWrap.Initialize,"void node.LibuvStreamWrap.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)",stream_wrap.cc,"void LibuvStreamWrap::Initialize(Local<Object> target,
                                 Local<Value> unused,
                                 Local<Context> context,
                                 void* priv) {
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  Local<FunctionTemplate> sw =
      NewFunctionTemplate(isolate, IsConstructCallCallback);
  sw->InstanceTemplate()->SetInternalFieldCount(StreamReq::kInternalFieldCount);

  // we need to set handle and callback to null,
  // so that those fields are created and functions
  // do not become megamorphic
  // Fields:
  // - oncomplete
  // - callback
  // - handle
  sw->InstanceTemplate()->Set(env->oncomplete_string(), v8::Null(isolate));
  sw->InstanceTemplate()->Set(FIXED_ONE_BYTE_STRING(isolate, ""callback""),
                              v8::Null(isolate));
  sw->InstanceTemplate()->Set(FIXED_ONE_BYTE_STRING(isolate, ""handle""),
                              v8::Null(isolate));

 ...",66.0,112.0,1.0,2.0,47.0,171,7,176,24,0,0,1,1,0,0,,0,0,8,4,4,void
4996,281528,RegisterExternalReferences,1,node.LibuvStreamWrap.RegisterExternalReferences,void node.LibuvStreamWrap.RegisterExternalReferences (ExternalReferenceRegistry*),stream_wrap.cc,"void LibuvStreamWrap::RegisterExternalReferences(
    ExternalReferenceRegistry* registry) {
  registry->Register(IsConstructCallCallback);
  registry->Register(GetWriteQueueSize);
  registry->Register(SetBlocking);
  StreamBase::RegisterExternalReferences(registry);
}",114.0,120.0,1.0,1.0,7.0,4,2,8,5,0,0,1,1,0,0,,0,0,2,1,1,void
4997,281553,LibuvStreamWrap,1,node.LibuvStreamWrap.LibuvStreamWrap,"ANY node.LibuvStreamWrap.LibuvStreamWrap (Environment*,Local<Object>,uv_stream_t*,ANY)",stream_wrap.cc,"LibuvStreamWrap::LibuvStreamWrap(Environment* env,
                                 Local<Object> object,
                                 uv_stream_t* stream,
                                 AsyncWrap::ProviderType provider)
    : HandleWrap(env,
                 object,
                 reinterpret_cast<uv_handle_t*>(stream),
                 provider),
      StreamBase(env),
      stream_(stream) {
  StreamBase::AttachToObject(object);
}",122.0,133.0,1.0,1.0,12.0,1,1,2,2,0,0,1,1,0,0,,0,0,8,4,4,ANY
4998,281566,GetConstructorTemplate,1,node.LibuvStreamWrap.GetConstructorTemplate,Local<FunctionTemplate> node.LibuvStreamWrap.GetConstructorTemplate (Environment*),stream_wrap.cc,"Local<FunctionTemplate> LibuvStreamWrap::GetConstructorTemplate(
    Environment* env) {
  Local<FunctionTemplate> tmpl = env->libuv_stream_wrap_ctor_template();
  if (tmpl.IsEmpty()) {
    Isolate* isolate = env->isolate();
    tmpl = NewFunctionTemplate(isolate, nullptr);
    tmpl->SetClassName(FIXED_ONE_BYTE_STRING(isolate, ""LibuvStreamWrap""));
    tmpl->Inherit(HandleWrap::GetConstructorTemplate(env));
    tmpl->InstanceTemplate()->SetInternalFieldCount(
        StreamBase::kInternalFieldCount);
    Local<FunctionTemplate> get_write_queue_size =
        FunctionTemplate::New(isolate,
                              GetWriteQueueSize,
                              Local<Value>(),
                              Signature::New(isolate, tmpl));
    tmpl->PrototypeTemplate()->SetAccessorProperty(
        env->write_queue_size_string(),
        get_write_queue_size,
        Local<FunctionTemplate>(),
        static_cast<PropertyAttribute>(ReadOnly | DontDelete));
    SetProtoMethod(isola...",136.0,161.0,1.0,1.0,26.0,26,7,39,13,0,0,2,2,0,0,,0,0,2,1,1,Local<FunctionTemplate>
4999,281680,From,1,node.LibuvStreamWrap.From,"LibuvStreamWrap node.LibuvStreamWrap.From (Environment*,Local<Object>)",stream_wrap.cc,"LibuvStreamWrap* LibuvStreamWrap::From(Environment* env, Local<Object> object) {
  Local<FunctionTemplate> sw = env->libuv_stream_wrap_ctor_template();
  CHECK(!sw.IsEmpty() && sw->HasInstance(object));
  return Unwrap<LibuvStreamWrap>(object);
}",164.0,168.0,1.0,1.0,5.0,10,7,10,7,0,0,1,1,0,0,,0,0,4,2,2,LibuvStreamWrap
5000,281714,GetFD,1,node.LibuvStreamWrap.GetFD,int node.LibuvStreamWrap.GetFD (),stream_wrap.cc,"int LibuvStreamWrap::GetFD() {
#ifdef _WIN32
  return fd_;
#else
  int fd = -1;
  if (stream() != nullptr)
    uv_fileno(reinterpret_cast<uv_handle_t*>(stream()), &fd);
  return fd;
#endif
}",171.0,180.0,1.0,1.0,10.0,5,5,3,1,0,0,2,2,0,0,,0,0,0,0,0,int
5001,281736,IsAlive,1,node.LibuvStreamWrap.IsAlive,bool node.LibuvStreamWrap.IsAlive (),stream_wrap.cc,"bool LibuvStreamWrap::IsAlive() {
  return HandleWrap::IsAlive(this);
}",183.0,185.0,1.0,1.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,bool
5002,281746,IsClosing,1,node.LibuvStreamWrap.IsClosing,bool node.LibuvStreamWrap.IsClosing (),stream_wrap.cc,"bool LibuvStreamWrap::IsClosing() {
  return uv_is_closing(reinterpret_cast<uv_handle_t*>(stream()));
}",188.0,190.0,1.0,1.0,3.0,1,1,0,0,0,0,1,1,0,0,,0,0,0,0,0,bool
5003,281755,GetAsyncWrap,1,node.LibuvStreamWrap.GetAsyncWrap,AsyncWrap node.LibuvStreamWrap.GetAsyncWrap (),stream_wrap.cc,"AsyncWrap* LibuvStreamWrap::GetAsyncWrap() {
  return static_cast<AsyncWrap*>(this);
}",193.0,195.0,1.0,1.0,3.0,1,1,0,0,0,0,1,1,0,0,,0,0,0,0,0,AsyncWrap
5004,281763,IsIPCPipe,1,node.LibuvStreamWrap.IsIPCPipe,bool node.LibuvStreamWrap.IsIPCPipe (),stream_wrap.cc,"bool LibuvStreamWrap::IsIPCPipe() {
  return is_named_pipe_ipc();
}",198.0,200.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,bool
5005,281769,ReadStart,1,node.LibuvStreamWrap.ReadStart,int node.LibuvStreamWrap.ReadStart (),stream_wrap.cc,"int LibuvStreamWrap::ReadStart() {
  return uv_read_start(
      stream(),
      [](uv_handle_t* handle, size_t suggested_size, uv_buf_t* buf) {
        static_cast<LibuvStreamWrap*>(handle->data)
            ->OnUvAlloc(suggested_size, buf);
      },
      [](uv_stream_t* stream, ssize_t nread, const uv_buf_t* buf) {
        LibuvStreamWrap* wrap = static_cast<LibuvStreamWrap*>(stream->data);
        TryCatchScope try_catch(wrap->env());
        try_catch.SetVerbose(true);
        wrap->OnUvRead(nread, buf);
      });
}",202.0,215.0,1.0,1.0,14.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,int
5006,281778,ReadStop,1,node.LibuvStreamWrap.ReadStop,int node.LibuvStreamWrap.ReadStop (),stream_wrap.cc,"int LibuvStreamWrap::ReadStop() {
  return uv_read_stop(stream());
}",218.0,220.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,int
5007,281785,OnUvAlloc,1,node.LibuvStreamWrap.OnUvAlloc,"void node.LibuvStreamWrap.OnUvAlloc (size_t,uv_buf_t*)",stream_wrap.cc,"void LibuvStreamWrap::OnUvAlloc(size_t suggested_size, uv_buf_t* buf) {
  HandleScope scope(env()->isolate());
  Context::Scope context_scope(env()->context());

  *buf = EmitAlloc(suggested_size);
}",223.0,228.0,1.0,1.0,6.0,4,3,2,2,0,0,1,1,0,0,,0,0,4,2,2,void
5008,281808,AcceptHandle,1,node.AcceptHandle,"MaybeLocal<Object> node.AcceptHandle<WrapType> (Environment*,LibuvStreamWrap*)",stream_wrap.cc,"static MaybeLocal<Object> AcceptHandle(Environment* env,
                                       LibuvStreamWrap* parent) {
  static_assert(std::is_base_of<LibuvStreamWrap, WrapType>::value ||
                std::is_base_of<UDPWrap, WrapType>::value,
                ""Can only accept stream handles"");

  EscapableHandleScope scope(env->isolate());
  Local<Object> wrap_obj;

  if (!WrapType::Instantiate(env, parent, WrapType::SOCKET).ToLocal(&wrap_obj))
    return Local<Object>();

  HandleWrap* wrap = Unwrap<HandleWrap>(wrap_obj);
  CHECK_NOT_NULL(wrap);
  uv_stream_t* stream = reinterpret_cast<uv_stream_t*>(wrap->GetHandle());
  CHECK_NOT_NULL(stream);

  if (uv_accept(parent->stream(), stream))
    ABORT();

  return scope.Escape(wrap_obj);
}",231.0,252.0,1.0,1.0,22.0,21,9,25,14,0,0,3,3,0,0,,0,0,4,2,2,MaybeLocal<Object>
5009,281893,OnUvRead,1,node.LibuvStreamWrap.OnUvRead,"Maybe<void> node.LibuvStreamWrap.OnUvRead (ssize_t,uv_buf_t*)",stream_wrap.cc,"Maybe<void> LibuvStreamWrap::OnUvRead(ssize_t nread, const uv_buf_t* buf) {
  HandleScope scope(env()->isolate());
  Context::Scope context_scope(env()->context());
  uv_handle_type type = UV_UNKNOWN_HANDLE;

  if (is_named_pipe_ipc() &&
      uv_pipe_pending_count(reinterpret_cast<uv_pipe_t*>(stream())) > 0) {
    type = uv_pipe_pending_type(reinterpret_cast<uv_pipe_t*>(stream()));
  }

  // We should not be getting this callback if someone has already called
  // uv_close() on the handle.
  CHECK_EQ(persistent().IsEmpty(), false);

  if (nread > 0) {
    MaybeLocal<Object> pending_obj;

    if (type == UV_TCP) {
      pending_obj = AcceptHandle<TCPWrap>(env(), this);
    } else if (type == UV_NAMED_PIPE) {
      pending_obj = AcceptHandle<PipeWrap>(env(), this);
    } else if (type == UV_UDP) {
      pending_obj = AcceptHandle<UDPWrap>(env(), this);
    } else {
      CHECK_EQ(type, UV_UNKNOWN_HANDLE);
    }

    Local<Object> local_pending_obj;
    if (type != UV_UNKNOWN_HANDLE &...",254.0,295.0,1.0,1.0,42.0,31,15,22,12,0,0,5,7,0,0,,0,0,4,2,2,Maybe<void>
5010,282044,GetWriteQueueSize,1,node.LibuvStreamWrap.GetWriteQueueSize,void node.LibuvStreamWrap.GetWriteQueueSize (FunctionCallbackInfo<Value>),stream_wrap.cc,"void LibuvStreamWrap::GetWriteQueueSize(
    const FunctionCallbackInfo<Value>& info) {
  LibuvStreamWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, info.This());

  if (wrap->stream() == nullptr) {
    info.GetReturnValue().Set(0);
    return;
  }

  uint32_t write_queue_size = wrap->stream()->write_queue_size;
  info.GetReturnValue().Set(write_queue_size);
}",297.0,309.0,1.0,1.0,13.0,11,5,8,3,0,0,2,2,0,0,,0,0,2,1,1,void
5011,282091,SetBlocking,1,node.LibuvStreamWrap.SetBlocking,void node.LibuvStreamWrap.SetBlocking (FunctionCallbackInfo<Value>),stream_wrap.cc,"void LibuvStreamWrap::SetBlocking(const FunctionCallbackInfo<Value>& args) {
  LibuvStreamWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());

  CHECK_GT(args.Length(), 0);
  if (!wrap->IsAlive())
    return args.GetReturnValue().Set(UV_EINVAL);

  bool enable = args[0]->IsTrue();
  args.GetReturnValue().Set(uv_stream_set_blocking(wrap->stream(), enable));
}",312.0,322.0,1.0,1.0,11.0,13,6,11,4,0,0,2,2,0,0,,0,0,2,1,1,void
5012,282150,CreateShutdownWrap,1,node.LibuvStreamWrap.CreateShutdownWrap,ShutdownWrap node.LibuvStreamWrap.CreateShutdownWrap (Local<Object>),stream_wrap.cc,"ShutdownWrap* LibuvStreamWrap::CreateShutdownWrap(Local<Object> object) {
  return new LibuvShutdownWrap(this, object);
}",327.0,329.0,1.0,1.0,3.0,1,1,2,2,0,0,1,1,0,0,,0,0,2,1,1,ShutdownWrap
5013,282160,CreateWriteWrap,1,node.LibuvStreamWrap.CreateWriteWrap,WriteWrap node.LibuvStreamWrap.CreateWriteWrap (Local<Object>),stream_wrap.cc,"WriteWrap* LibuvStreamWrap::CreateWriteWrap(Local<Object> object) {
  return new LibuvWriteWrap(this, object);
}",331.0,333.0,1.0,1.0,3.0,1,1,2,2,0,0,1,1,0,0,,0,0,2,1,1,WriteWrap
5014,282170,DoShutdown,1,node.LibuvStreamWrap.DoShutdown,int node.LibuvStreamWrap.DoShutdown (ShutdownWrap*),stream_wrap.cc,"int LibuvStreamWrap::DoShutdown(ShutdownWrap* req_wrap_) {
  LibuvShutdownWrap* req_wrap = static_cast<LibuvShutdownWrap*>(req_wrap_);
  return req_wrap->Dispatch(uv_shutdown, stream(), AfterUvShutdown);
}",336.0,339.0,1.0,1.0,4.0,3,3,5,4,0,0,1,1,0,0,,0,0,2,1,1,int
5015,282189,AfterUvShutdown,1,node.LibuvStreamWrap.AfterUvShutdown,"void node.LibuvStreamWrap.AfterUvShutdown (uv_shutdown_t*,int)",stream_wrap.cc,"void LibuvStreamWrap::AfterUvShutdown(uv_shutdown_t* req, int status) {
  LibuvShutdownWrap* req_wrap = static_cast<LibuvShutdownWrap*>(
      LibuvShutdownWrap::from_req(req));
  CHECK_NOT_NULL(req_wrap);
  HandleScope scope(req_wrap->env()->isolate());
  Context::Scope context_scope(req_wrap->env()->context());
  req_wrap->Done(status);
}",342.0,349.0,1.0,1.0,8.0,8,4,8,4,0,0,1,1,0,0,,0,0,4,2,2,void
5016,282230,DoTryWrite,1,node.LibuvStreamWrap.DoTryWrite,"int node.LibuvStreamWrap.DoTryWrite (uv_buf_t**,size_t*)",stream_wrap.cc,"int LibuvStreamWrap::DoTryWrite(uv_buf_t** bufs, size_t* count) {
  int err;
  size_t written;
  uv_buf_t* vbufs = *bufs;
  size_t vcount = *count;

  err = uv_try_write(stream(), vbufs, vcount);
  if (err == UV_ENOSYS || err == UV_EAGAIN)
    return 0;
  if (err < 0)
    return err;

  // Slice off the buffers: skip all written buffers and slice the one that
  // was partially written.
  written = err;
  for (; vcount > 0; vbufs++, vcount--) {
    // Slice
    if (vbufs[0].len > written) {
      vbufs[0].base += written;
      vbufs[0].len -= written;
      written = 0;
      break;

    // Discard
    } else {
      written -= vbufs[0].len;
    }
  }

  *bufs = vbufs;
  *count = vcount;

  return 0;
}",356.0,389.0,1.0,1.0,34.0,25,10,27,8,0,0,6,6,0,0,,0,0,4,2,2,int
5017,282332,DoWrite,1,node.LibuvStreamWrap.DoWrite,"int node.LibuvStreamWrap.DoWrite (WriteWrap*,uv_buf_t*,size_t,uv_stream_t*)",stream_wrap.cc,"int LibuvStreamWrap::DoWrite(WriteWrap* req_wrap,
                             uv_buf_t* bufs,
                             size_t count,
                             uv_stream_t* send_handle) {
  LibuvWriteWrap* w = static_cast<LibuvWriteWrap*>(req_wrap);
  return w->Dispatch(uv_write2,
                     stream(),
                     bufs,
                     count,
                     send_handle,
                     AfterUvWrite);
}",392.0,403.0,1.0,1.0,12.0,3,3,8,7,0,0,1,1,0,0,,0,0,8,4,4,int
5018,282357,AfterUvWrite,1,node.LibuvStreamWrap.AfterUvWrite,"void node.LibuvStreamWrap.AfterUvWrite (uv_write_t*,int)",stream_wrap.cc,"void LibuvStreamWrap::AfterUvWrite(uv_write_t* req, int status) {
  LibuvWriteWrap* req_wrap = static_cast<LibuvWriteWrap*>(
      LibuvWriteWrap::from_req(req));
  CHECK_NOT_NULL(req_wrap);
  HandleScope scope(req_wrap->env()->isolate());
  Context::Scope context_scope(req_wrap->env()->context());
  req_wrap->Done(status);
}",407.0,414.0,1.0,1.0,8.0,8,4,8,4,0,0,1,1,0,0,,0,0,4,2,2,void
5019,282438,~ExternString,1,node.anonymous_namespace_2.ExternString.~ExternString,ANY node.anonymous_namespace_2.ExternString.~ExternString (),string_bytes.cc,"~ExternString() override {
    free(const_cast<TypeName*>(data_));
    isolate()->AdjustAmountOfExternalAllocatedMemory(-byte_length());
  }",58.0,61.0,3.0,3.0,4.0,3,3,1,1,0,1,1,1,0,0,,0,1,0,0,0,ANY
5020,282452,data,1,node.anonymous_namespace_5.ExternString.data,TypeName node.anonymous_namespace_5.ExternString.data (),string_bytes.cc,"const TypeName* data() const override {
    return data_;
  }",63.0,65.0,3.0,3.0,3.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,TypeName
5021,282458,length,1,node.anonymous_namespace_6.ExternString.length,size_t node.anonymous_namespace_6.ExternString.length (),string_bytes.cc,"size_t length() const override {
    return length_;
  }",67.0,69.0,3.0,3.0,3.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,size_t
5022,282464,byte_length,1,node.anonymous_namespace_7.ExternString.byte_length,int64_t node.anonymous_namespace_7.ExternString.byte_length (),string_bytes.cc,"int64_t byte_length() const {
    return length() * sizeof(*data());
  }",71.0,73.0,3.0,3.0,3.0,3,3,0,0,0,0,1,1,0,0,,0,0,0,0,0,int64_t
5023,282474,NewFromCopy,1,node.anonymous_namespace_10.ExternString.NewFromCopy,"MaybeLocal<Value> node.anonymous_namespace_10.ExternString.NewFromCopy (Isolate*,TypeName*,size_t,Local<Value>*)",string_bytes.cc,"static MaybeLocal<Value> NewFromCopy(Isolate* isolate,
                                       const TypeName* data,
                                       size_t length,
                                       Local<Value>* error) {
    if (length == 0)
      return String::Empty(isolate);

    if (length < EXTERN_APEX)
      return NewSimpleFromCopy(isolate, data, length, error);

    TypeName* new_data = node::UncheckedMalloc<TypeName>(length);
    if (new_data == nullptr) {
      *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
      return MaybeLocal<Value>();
    }
    memcpy(new_data, data, length * sizeof(*new_data));

    return ExternString<ResourceType, TypeName>::New(isolate,
                                                     new_data,
                                                     length,
                                                     error);
  }",75.0,96.0,3.0,17.0,22.0,15,8,25,9,0,0,4,4,0,0,,0,0,8,4,4,MaybeLocal<Value>
5024,282548,New,1,node.anonymous_namespace_11.ExternString.New,"MaybeLocal<Value> node.anonymous_namespace_11.ExternString.New (Isolate*,TypeName*,size_t,Local<Value>*)",string_bytes.cc,"static MaybeLocal<Value> New(Isolate* isolate,
                               TypeName* data,
                               size_t length,
                               Local<Value>* error) {
    if (length == 0)
      return String::Empty(isolate);

    if (length < EXTERN_APEX) {
      MaybeLocal<Value> str = NewSimpleFromCopy(isolate, data, length, error);
      free(data);
      return str;
    }

    ExternString* h_str = new ExternString<ResourceType, TypeName>(isolate,
                                                                   data,
                                                                   length);
    MaybeLocal<Value> str = NewExternal(isolate, h_str);
    isolate->AdjustAmountOfExternalAllocatedMemory(h_str->byte_length());

    if (str.IsEmpty()) {
      delete h_str;
      *error = node::ERR_STRING_TOO_LONG(isolate);
      return MaybeLocal<Value>();
    }

    return str.ToLocalChecked();
  }",99.0,125.0,3.0,17.0,27.0,19,9,31,11,0,0,4,4,0,0,,0,0,8,4,4,MaybeLocal<Value>
5025,282637,isolate,1,node.anonymous_namespace_12.ExternString.isolate,Isolate node.anonymous_namespace_12.ExternString.isolate (),string_bytes.cc,inline Isolate* isolate() const { return isolate_; },127.0,127.0,3.0,54.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,Isolate
5026,282643,ExternString,1,node.anonymous_namespace_13.ExternString.ExternString,"ANY node.anonymous_namespace_13.ExternString.ExternString (Isolate*,TypeName*,size_t)",string_bytes.cc,"ExternString(Isolate* isolate, const TypeName* data, size_t length)
    : isolate_(isolate), data_(data), length_(length) { }",130.0,131.0,3.0,57.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,ANY
5027,282650,NewExternal,1,node.anonymous_namespace_14.ExternString.NewExternal,"MaybeLocal<Value> node.anonymous_namespace_14.ExternString.NewExternal (Isolate*,ExternString*)",string_bytes.cc,"static MaybeLocal<Value> NewExternal(Isolate* isolate,
                                       ExternString* h_str);",132.0,133.0,28.0,59.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,MaybeLocal<Value>
5028,282656,NewSimpleFromCopy,1,node.anonymous_namespace_15.ExternString.NewSimpleFromCopy,"MaybeLocal<Value> node.anonymous_namespace_15.ExternString.NewSimpleFromCopy (Isolate*,TypeName*,size_t,Local<Value>*)",string_bytes.cc,"static MaybeLocal<Value> NewSimpleFromCopy(Isolate* isolate,
                                             const TypeName* data,
                                             size_t length,
                                             Local<Value>* error);",136.0,139.0,28.0,65.0,4.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,MaybeLocal<Value>
5029,282669,NewExternal,1,node.anonymous_namespace_16.ExternOneByteString.NewExternal,"MaybeLocal<Value> node.anonymous_namespace_16.ExternOneByteString.NewExternal<> (Isolate*,ExternOneByteString*)",string_bytes.cc,"MaybeLocal<Value> ExternOneByteString::NewExternal(
    Isolate* isolate, ExternOneByteString* h_str) {
  return String::NewExternalOneByte(isolate, h_str).FromMaybe(Local<Value>());
}",154.0,157.0,1.0,1.0,4.0,2,1,3,3,0,0,1,1,0,0,,0,0,4,2,2,MaybeLocal<Value>
5030,282686,NewExternal,1,node.anonymous_namespace_17.ExternTwoByteString.NewExternal,"MaybeLocal<Value> node.anonymous_namespace_17.ExternTwoByteString.NewExternal<> (Isolate*,ExternTwoByteString*)",string_bytes.cc,"MaybeLocal<Value> ExternTwoByteString::NewExternal(
    Isolate* isolate, ExternTwoByteString* h_str) {
  return String::NewExternalTwoByte(isolate, h_str).FromMaybe(Local<Value>());
}",161.0,164.0,1.0,1.0,4.0,2,1,3,3,0,0,1,1,0,0,,0,0,4,2,2,MaybeLocal<Value>
5031,282703,NewSimpleFromCopy,1,node.anonymous_namespace_18.ExternOneByteString.NewSimpleFromCopy,"MaybeLocal<Value> node.anonymous_namespace_18.ExternOneByteString.NewSimpleFromCopy<> (Isolate*,char*,size_t,Local<Value>*)",string_bytes.cc,"MaybeLocal<Value> ExternOneByteString::NewSimpleFromCopy(Isolate* isolate,
                                                         const char* data,
                                                         size_t length,
                                                         Local<Value>* error) {
  MaybeLocal<String> str =
      String::NewFromOneByte(isolate,
                             reinterpret_cast<const uint8_t*>(data),
                             v8::NewStringType::kNormal,
                             length);
  if (str.IsEmpty()) {
    *error = node::ERR_STRING_TOO_LONG(isolate);
    return MaybeLocal<Value>();
  }
  return str.ToLocalChecked();
}",167.0,181.0,1.0,1.0,15.0,12,6,14,10,0,0,2,2,0,0,,0,0,8,4,4,MaybeLocal<Value>
5032,282752,NewSimpleFromCopy,1,node.anonymous_namespace_19.ExternTwoByteString.NewSimpleFromCopy,"MaybeLocal<Value> node.anonymous_namespace_19.ExternTwoByteString.NewSimpleFromCopy<> (Isolate*,uint16_t*,size_t,Local<Value>*)",string_bytes.cc,"MaybeLocal<Value> ExternTwoByteString::NewSimpleFromCopy(Isolate* isolate,
                                                         const uint16_t* data,
                                                         size_t length,
                                                         Local<Value>* error) {
  MaybeLocal<String> str =
      String::NewFromTwoByte(isolate,
                             data,
                             v8::NewStringType::kNormal,
                             length);
  if (str.IsEmpty()) {
    *error = node::ERR_STRING_TOO_LONG(isolate);
    return MaybeLocal<Value>();
  }
  return str.ToLocalChecked();
}",185.0,199.0,1.0,1.0,15.0,11,5,14,10,0,0,2,2,0,0,,0,0,8,4,4,MaybeLocal<Value>
5033,283743,unhex,1,node.unhex,unsigned node.unhex (uint8_t),string_bytes.cc,"static inline unsigned unhex(uint8_t x) {
  return unhex_table[x];
}",243.0,245.0,1.0,1.0,3.0,1,1,2,2,0,0,1,1,0,0,,0,0,2,1,1,unsigned
5034,283752,hex_decode,1,node.hex_decode,"size_t node.hex_decode<TypeName> (char*,size_t,TypeName*,size_t)",string_bytes.cc,"static size_t hex_decode(char* buf,
                         size_t len,
                         const TypeName* src,
                         const size_t srcLen) {
  size_t i;
  for (i = 0; i < len && i * 2 + 1 < srcLen; ++i) {
    unsigned a = unhex(static_cast<uint8_t>(src[i * 2 + 0]));
    unsigned b = unhex(static_cast<uint8_t>(src[i * 2 + 1]));
    if (!~a || !~b)
      return i;
    buf[i] = (a << 4) | b;
  }

  return i;
}",248.0,262.0,1.0,1.0,15.0,25,12,19,7,0,0,3,4,0,0,,0,0,8,4,4,size_t
5035,283828,WriteUCS2,1,node.StringBytes.WriteUCS2,"size_t node.StringBytes.WriteUCS2 (Isolate*,char*,size_t,Local<String>,int)",string_bytes.cc,"size_t StringBytes::WriteUCS2(
    Isolate* isolate, char* buf, size_t buflen, Local<String> str, int flags) {
  uint16_t* const dst = reinterpret_cast<uint16_t*>(buf);

  size_t max_chars = buflen / sizeof(*dst);
  if (max_chars == 0) {
    return 0;
  }

  uint16_t* const aligned_dst = AlignUp(dst, sizeof(*dst));
  size_t nchars;
  if (aligned_dst == dst) {
    nchars = str->Write(isolate, dst, 0, max_chars, flags);
    return nchars * sizeof(*dst);
  }

  CHECK_EQ(reinterpret_cast<uintptr_t>(aligned_dst) % sizeof(*dst), 0);

  // Write all but the last char
  max_chars = std::min(max_chars, static_cast<size_t>(str->Length()));
  if (max_chars == 0) {
    return 0;
  }
  nchars = str->Write(isolate, aligned_dst, 0, max_chars - 1, flags);
  CHECK_EQ(nchars, max_chars - 1);

  // Shift everything to unaligned-left
  memmove(dst, aligned_dst, nchars * sizeof(*dst));

  // One more char to be written
  uint16_t last;
  CHECK_EQ(str->Write(isolate, &last, nchars, 1, flags), 1);
  memcp...",264.0,300.0,1.0,1.0,37.0,44,14,51,11,0,0,4,4,0,0,,0,0,10,5,5,size_t
5036,283977,Write,1,node.StringBytes.Write,"size_t node.StringBytes.Write (Isolate*,char*,size_t,Local<Value>,encoding)",string_bytes.cc,"size_t StringBytes::Write(Isolate* isolate,
                          char* buf,
                          size_t buflen,
                          Local<Value> val,
                          enum encoding encoding) {
  HandleScope scope(isolate);
  size_t nbytes;

  CHECK(val->IsString() == true);
  Local<String> str = val.As<String>();

  int flags = String::HINT_MANY_WRITES_EXPECTED |
              String::NO_NULL_TERMINATION |
              String::REPLACE_INVALID_UTF8;

  switch (encoding) {
    case ASCII:
    case LATIN1:
      if (str->IsExternalOneByte()) {
        auto ext = str->GetExternalOneByteStringResource();
        nbytes = std::min(buflen, ext->length());
        memcpy(buf, ext->data(), nbytes);
      } else {
        uint8_t* const dst = reinterpret_cast<uint8_t*>(buf);
        nbytes = str->WriteOneByte(isolate, dst, 0, buflen, flags);
      }
      break;

    case BUFFER:
    case UTF8:
      nbytes = str->WriteUtf8(isolate, buf, buflen, nullptr, flags);
    ...",302.0,375.0,1.0,1.0,74.0,34,7,60,20,0,0,11,10,0,0,,0,0,10,5,5,size_t
5037,284212,StorageSize,1,node.StringBytes.StorageSize,"Maybe<size_t> node.StringBytes.StorageSize (Isolate*,Local<Value>,encoding)",string_bytes.cc,"Maybe<size_t> StringBytes::StorageSize(Isolate* isolate,
                                       Local<Value> val,
                                       enum encoding encoding) {
  HandleScope scope(isolate);
  size_t data_size = 0;
  bool is_buffer = Buffer::HasInstance(val);

  if (is_buffer && (encoding == BUFFER || encoding == LATIN1)) {
    return Just(Buffer::Length(val));
  }

  Local<String> str;
  if (!val->ToString(isolate->GetCurrentContext()).ToLocal(&str))
    return Nothing<size_t>();

  switch (encoding) {
    case ASCII:
    case LATIN1:
      data_size = str->Length();
      break;

    case BUFFER:
    case UTF8:
      // A single UCS2 codepoint never takes up more than 3 utf8 bytes.
      // It is an exercise for the caller to decide when a string is
      // long enough to justify calling Size() instead of StorageSize()
      data_size = 3 * str->Length();
      break;

    case UCS2:
      data_size = str->Length() * sizeof(uint16_t);
      break;

    case BASE...",380.0,429.0,1.0,1.0,50.0,33,14,40,18,0,0,9,4,0,0,,0,0,6,3,3,Maybe<size_t>
5038,284354,Size,1,node.StringBytes.Size,"Maybe<size_t> node.StringBytes.Size (Isolate*,Local<Value>,encoding)",string_bytes.cc,"Maybe<size_t> StringBytes::Size(Isolate* isolate,
                                Local<Value> val,
                                enum encoding encoding) {
  HandleScope scope(isolate);

  if (Buffer::HasInstance(val) && (encoding == BUFFER || encoding == LATIN1))
    return Just(Buffer::Length(val));

  Local<String> str;
  if (!val->ToString(isolate->GetCurrentContext()).ToLocal(&str))
    return Nothing<size_t>();

  switch (encoding) {
    case ASCII:
    case LATIN1:
      return Just<size_t>(str->Length());

    case BUFFER:
    case UTF8:
      return Just<size_t>(str->Utf8Length(isolate));

    case UCS2:
      return Just(str->Length() * sizeof(uint16_t));

    case BASE64URL:
      // Fall through
    case BASE64: {
      String::Value value(isolate, str);
      return Just(base64_decoded_size(*value, value.length()));
    }

    case HEX:
      return Just<size_t>(str->Length() / 2);
  }

  UNREACHABLE();
}",431.0,467.0,1.0,1.0,37.0,28,13,40,19,0,0,4,4,0,0,,0,0,6,3,3,Maybe<size_t>
5039,284482,force_ascii_slow,1,node.force_ascii_slow,"void node.force_ascii_slow (char*,char*,size_t)",string_bytes.cc,"static void force_ascii_slow(const char* src, char* dst, size_t len) {
  for (size_t i = 0; i < len; ++i) {
    dst[i] = src[i] & 0x7f;
  }
}",469.0,473.0,1.0,1.0,5.0,6,4,7,4,0,0,2,2,0,0,,0,0,6,3,3,void
5040,284510,force_ascii,1,node.force_ascii,"void node.force_ascii (char*,char*,size_t)",string_bytes.cc,"static void force_ascii(const char* src, char* dst, size_t len) {
  if (len < 16) {
    force_ascii_slow(src, dst, len);
    return;
  }

  const unsigned bytes_per_word = sizeof(uintptr_t);
  const unsigned align_mask = bytes_per_word - 1;
  const unsigned src_unalign = reinterpret_cast<uintptr_t>(src) & align_mask;
  const unsigned dst_unalign = reinterpret_cast<uintptr_t>(dst) & align_mask;

  if (src_unalign > 0) {
    if (src_unalign == dst_unalign) {
      const unsigned unalign = bytes_per_word - src_unalign;
      force_ascii_slow(src, dst, unalign);
      src += unalign;
      dst += unalign;
      len -= src_unalign;
    } else {
      force_ascii_slow(src, dst, len);
      return;
    }
  }

#if defined(_WIN64) || defined(_LP64)
  const uintptr_t mask = ~0x8080808080808080ll;
#else
  const uintptr_t mask = ~0x80808080l;
#endif

  const uintptr_t* srcw = reinterpret_cast<const uintptr_t*>(src);
  uintptr_t* dstw = reinterpret_cast<uintptr_t*>(dst);

  for (size_t i = 0, n ...",476.0,518.0,1.0,1.0,43.0,39,14,57,16,0,0,6,7,0,0,,0,0,6,3,3,void
5041,284659,hex_encode,1,node.StringBytes.hex_encode,"size_t node.StringBytes.hex_encode (char*,size_t,char*,size_t)",string_bytes.cc,"std::string StringBytes::hex_encode(const char* src, size_t slen) {
  size_t dlen = slen * 2;
  std::string dst(dlen, '\0');
  hex_encode(src, slen, dst.data(), dlen);
  return dst;
}",541.0,546.0,1.0,1.0,6.0,22,10,21,8,0,0,2,2,0,0,,0,0,4,2,2,string
5042,284763,Encode,1,node.StringBytes.Encode,"MaybeLocal<Value> node.StringBytes.Encode (Isolate*,char*,size_t,encoding,Local<Value>*)",string_bytes.cc,"MaybeLocal<Value> StringBytes::Encode(Isolate* isolate,
                                      const char* buf,
                                      enum encoding encoding,
                                      Local<Value>* error) {
  const size_t len = strlen(buf);
  return Encode(isolate, buf, len, encoding, error);
}",716.0,722.0,1.0,1.0,7.0,116,18,192,38,0,0,15,31,0,0,,0,0,8,4,4,MaybeLocal<Value>
5043,285457,MakeString,1,node.anonymous_namespace_1.MakeString,"MaybeLocal<String> node.anonymous_namespace_1.MakeString (Isolate*,char*,size_t,encoding)",string_decoder.cc,"MaybeLocal<String> MakeString(Isolate* isolate,
                              const char* data,
                              size_t length,
                              enum encoding encoding) {
  Local<Value> error;
  MaybeLocal<Value> ret;
  if (encoding == UTF8) {
    MaybeLocal<String> utf8_string = String::NewFromUtf8(
        isolate,
        data,
        v8::NewStringType::kNormal,
        length);
    if (utf8_string.IsEmpty()) {
      isolate->ThrowException(node::ERR_STRING_TOO_LONG(isolate));
      return MaybeLocal<String>();
    } else {
      return utf8_string;
    }
  } else {
    ret = StringBytes::Encode(
        isolate,
        data,
        length,
        encoding,
        &error);
  }

  if (ret.IsEmpty()) {
    CHECK(!error.IsEmpty());
    isolate->ThrowException(error);
  }

  DCHECK(ret.IsEmpty() || ret.ToLocalChecked()->IsString());
  return ret.FromMaybe(Local<Value>()).As<String>();
}",27.0,61.0,1.0,1.0,35.0,24,8,28,15,0,0,4,5,0,0,,0,0,8,4,4,MaybeLocal<String>
5044,285572,DecodeData,1,node.StringDecoder.DecodeData,"MaybeLocal<String> node.StringDecoder.DecodeData (Isolate*,char*,size_t*)",string_decoder.cc,"MaybeLocal<String> StringDecoder::DecodeData(Isolate* isolate,
                                             const char* data,
                                             size_t* nread_ptr) {
  Local<String> prepend, body;

  size_t nread = *nread_ptr;

  if (Encoding() == UTF8 ||
      Encoding() == UCS2 ||
      Encoding() == BASE64 ||
      Encoding() == BASE64URL) {
    // See if we want bytes to finish a character from the previous
    // chunk; if so, copy the new bytes to the missing bytes buffer
    // and create a small string from it that is to be prepended to the
    // main body.
    if (MissingBytes() > 0) {
      // There are never more bytes missing than the pre-calculated maximum.
      CHECK_LE(MissingBytes() + BufferedBytes(),
               kIncompleteCharactersEnd);
      if (Encoding() == UTF8) {
        // For UTF-8, we need special treatment to align with the V8 decoder:
        // If an incomplete character is found at a chunk boundary, we use
        // its ...",66.0,235.0,1.0,1.0,170.0,52,18,54,18,0,0,11,27,0,0,,0,0,6,3,3,MaybeLocal<String>
5045,286060,FlushData,1,node.StringDecoder.FlushData,MaybeLocal<String> node.StringDecoder.FlushData (Isolate*),string_decoder.cc,"MaybeLocal<String> StringDecoder::FlushData(Isolate* isolate) {
  if (Encoding() == ASCII || Encoding() == HEX || Encoding() == LATIN1) {
    CHECK_EQ(MissingBytes(), 0);
    CHECK_EQ(BufferedBytes(), 0);
  }

  if (Encoding() == UCS2 && BufferedBytes() % 2 == 1) {
    // Ignore a single trailing byte, like the JS decoder does.
    state_[kMissingBytes]--;
    state_[kBufferedBytes]--;
  }

  if (BufferedBytes() == 0)
    return String::Empty(isolate);

  MaybeLocal<String> ret =
      MakeString(isolate,
                 IncompleteCharacterBuffer(),
                 BufferedBytes(),
                 Encoding());

  state_[kMissingBytes] = 0;
  state_[kBufferedBytes] = 0;

  return ret;
}",237.0,262.0,1.0,1.0,26.0,22,10,19,11,0,0,4,4,0,0,,0,0,2,1,1,MaybeLocal<String>
5046,286138,DecodeData,1,node.anonymous_namespace_3.DecodeData,void node.anonymous_namespace_3.DecodeData (FunctionCallbackInfo<Value>),string_decoder.cc,"void DecodeData(const FunctionCallbackInfo<Value>& args) {
  StringDecoder* decoder =
      reinterpret_cast<StringDecoder*>(Buffer::Data(args[0]));
  CHECK_NOT_NULL(decoder);

  CHECK(args[1]->IsArrayBufferView());
  ArrayBufferViewContents<char> content(args[1].As<ArrayBufferView>());
  size_t length = content.length();

  MaybeLocal<String> ret =
      decoder->DecodeData(args.GetIsolate(), content.data(), &length);
  if (!ret.IsEmpty())
    args.GetReturnValue().Set(ret.ToLocalChecked());
}",266.0,279.0,1.0,1.0,14.0,22,9,18,8,0,0,2,2,0,0,,0,0,2,1,1,void
5047,286217,FlushData,1,node.anonymous_namespace_4.FlushData,void node.anonymous_namespace_4.FlushData (FunctionCallbackInfo<Value>),string_decoder.cc,"void FlushData(const FunctionCallbackInfo<Value>& args) {
  StringDecoder* decoder =
      reinterpret_cast<StringDecoder*>(Buffer::Data(args[0]));
  CHECK_NOT_NULL(decoder);
  MaybeLocal<String> ret = decoder->FlushData(args.GetIsolate());
  if (!ret.IsEmpty())
    args.GetReturnValue().Set(ret.ToLocalChecked());
}",281.0,288.0,1.0,1.0,8.0,14,8,12,6,0,0,2,2,0,0,,0,0,2,1,1,void
5048,286268,InitializeStringDecoder,1,node.anonymous_namespace_5.InitializeStringDecoder,"void node.anonymous_namespace_5.InitializeStringDecoder (Local<Object>,Local<Value>,Local<Context>,void*)",string_decoder.cc,"void InitializeStringDecoder(Local<Object> target,
                             Local<Value> unused,
                             Local<Context> context,
                             void* priv) {
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

#define SET_DECODER_CONSTANT(name)                                            \
  target->Set(context,                                                        \
              FIXED_ONE_BYTE_STRING(isolate, #name),                          \
              Integer::New(isolate, StringDecoder::name)).FromJust()

  SET_DECODER_CONSTANT(kIncompleteCharactersStart);
  SET_DECODER_CONSTANT(kIncompleteCharactersEnd);
  SET_DECODER_CONSTANT(kMissingBytes);
  SET_DECODER_CONSTANT(kBufferedBytes);
  SET_DECODER_CONSTANT(kEncodingField);
  SET_DECODER_CONSTANT(kNumFields);

  Local<Array> encodings = Array::New(isolate);
#define ADD_TO_ENCODINGS_ARRAY(cname, jsname)                                 \
  encodings...",290.0,333.0,1.0,2.0,44.0,62,7,100,24,0,0,1,1,0,0,,0,0,8,4,4,void
5049,286612,RegisterStringDecoderExternalReferences,1,node.RegisterStringDecoderExternalReferences,void node.RegisterStringDecoderExternalReferences (ExternalReferenceRegistry*),string_decoder.cc,"void RegisterStringDecoderExternalReferences(
    ExternalReferenceRegistry* registry) {
  registry->Register(DecodeData);
  registry->Register(FlushData);
}",337.0,341.0,1.0,1.0,5.0,2,1,2,1,0,0,1,1,0,0,,0,0,2,1,1,void
5050,286647,<lambda>0,1,"args, [port](const char* ip_address, sockaddr_in* addr) { return uv_ip4_addr(ip_address, port, addr); }.<lambda>0","ANY args, [port](const char* ip_address, sockaddr_in* addr) { return uv_ip4_addr(ip_address, port, addr); }.<lambda>0 (char*,sockaddr_in*)",tcp_wrap.cc,"[port](const char* ip_address, sockaddr_in* addr) {
      return uv_ip4_addr(ip_address, port, addr);
  }",300.0,302.0,24.0,3.0,3.0,0,0,3,3,0,0,1,1,0,0,,0,0,4,2,2,ANY
5051,286661,<lambda>1,1,"args, [port](const char* ip_address, sockaddr_in6* addr) { return uv_ip6_addr(ip_address, port, addr); }.<lambda>1","ANY args, [port](const char* ip_address, sockaddr_in6* addr) { return uv_ip6_addr(ip_address, port, addr); }.<lambda>1 (char*,sockaddr_in6*)",tcp_wrap.cc,"[port](const char* ip_address, sockaddr_in6* addr) {
      return uv_ip6_addr(ip_address, port, addr);
  }",312.0,314.0,25.0,3.0,3.0,0,0,3,3,0,0,1,1,0,0,,0,0,4,2,2,ANY
5052,286702,Instantiate,1,node.TCPWrap.Instantiate,"MaybeLocal<Object> node.TCPWrap.Instantiate (Environment*,AsyncWrap*,ANY)",tcp_wrap.cc,"MaybeLocal<Object> TCPWrap::Instantiate(Environment* env,
                                        AsyncWrap* parent,
                                        TCPWrap::SocketType type) {
  EscapableHandleScope handle_scope(env->isolate());
  AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(parent);
  CHECK_EQ(env->tcp_constructor_template().IsEmpty(), false);
  Local<Function> constructor = env->tcp_constructor_template()
                                    ->GetFunction(env->context())
                                    .ToLocalChecked();
  CHECK_EQ(constructor.IsEmpty(), false);
  Local<Value> type_value = Int32::New(env->isolate(), type);
  return handle_scope.EscapeMaybe(
      constructor->NewInstance(env->context(), 1, &type_value));
}",56.0,69.0,1.0,1.0,14.0,20,6,19,10,0,0,1,1,0,0,,0,0,6,3,3,MaybeLocal<Object>
5053,286784,Initialize,1,node.TCPWrap.Initialize,"void node.TCPWrap.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)",tcp_wrap.cc,"void TCPWrap::Initialize(Local<Object> target,
                         Local<Value> unused,
                         Local<Context> context,
                         void* priv) {
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, New);
  t->InstanceTemplate()->SetInternalFieldCount(StreamBase::kInternalFieldCount);

  // Init properties
  t->InstanceTemplate()->Set(FIXED_ONE_BYTE_STRING(env->isolate(), ""reading""),
                             Boolean::New(env->isolate(), false));
  t->InstanceTemplate()->Set(env->owner_symbol(), Null(env->isolate()));
  t->InstanceTemplate()->Set(env->onconnection_string(), Null(env->isolate()));

  t->Inherit(LibuvStreamWrap::GetConstructorTemplate(env));

  SetProtoMethod(isolate, t, ""open"", Open);
  SetProtoMethod(isolate, t, ""bind"", Bind);
  SetProtoMethod(isolate, t, ""listen"", Listen);
  SetProtoMethod(isolate, t, ""connect"", Connect);
  SetPro...",72.0,129.0,1.0,2.0,58.0,139,7,176,37,0,0,1,1,0,0,,0,0,8,4,4,void
5054,287303,RegisterExternalReferences,1,node.TCPWrap.RegisterExternalReferences,void node.TCPWrap.RegisterExternalReferences (ExternalReferenceRegistry*),tcp_wrap.cc,"void TCPWrap::RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  registry->Register(New);
  registry->Register(Open);
  registry->Register(Bind);
  registry->Register(Listen);
  registry->Register(Connect);
  registry->Register(Bind6);
  registry->Register(Connect6);

  registry->Register(GetSockOrPeerName<TCPWrap, uv_tcp_getsockname>);
  registry->Register(GetSockOrPeerName<TCPWrap, uv_tcp_getpeername>);
  registry->Register(SetNoDelay);
  registry->Register(SetKeepAlive);
  registry->Register(Reset);
#ifdef _WIN32
  registry->Register(SetSimultaneousAccepts);
#endif
}",131.0,148.0,1.0,1.0,18.0,12,1,24,13,0,0,1,1,0,0,,0,0,2,1,1,void
5055,287368,New,1,node.TCPWrap.New,void node.TCPWrap.New (FunctionCallbackInfo<Value>),tcp_wrap.cc,"void TCPWrap::New(const FunctionCallbackInfo<Value>& args) {
  // This constructor should not be exposed to public javascript.
  // Therefore we assert that we are not trying to call this as a
  // normal function.
  CHECK(args.IsConstructCall());
  CHECK(args[0]->IsInt32());
  Environment* env = Environment::GetCurrent(args);

  int type_value = args[0].As<Int32>()->Value();
  TCPWrap::SocketType type = static_cast<TCPWrap::SocketType>(type_value);

  ProviderType provider;
  switch (type) {
    case SOCKET:
      provider = PROVIDER_TCPWRAP;
      break;
    case SERVER:
      provider = PROVIDER_TCPSERVERWRAP;
      break;
    default:
      UNREACHABLE();
  }

  new TCPWrap(env, args.This(), provider);
}",150.0,174.0,1.0,1.0,25.0,15,6,20,11,0,0,4,2,0,0,,0,0,2,1,1,void
5056,287437,TCPWrap,1,node.TCPWrap.TCPWrap,"ANY node.TCPWrap.TCPWrap (Environment*,Local<Object>,ProviderType)",tcp_wrap.cc,"TCPWrap::TCPWrap(Environment* env, Local<Object> object, ProviderType provider)
    : ConnectionWrap(env, object, provider) {
  int r = uv_tcp_init(env->event_loop(), &handle_);
  CHECK_EQ(r, 0);  // How do we proxy this error up to javascript?
                   // Suggestion: uv_tcp_init() returns void.
}",177.0,182.0,1.0,1.0,6.0,3,3,4,3,0,0,1,1,0,0,,0,0,6,3,3,ANY
5057,287457,SetNoDelay,1,node.TCPWrap.SetNoDelay,void node.TCPWrap.SetNoDelay (FunctionCallbackInfo<Value>),tcp_wrap.cc,"void TCPWrap::SetNoDelay(const FunctionCallbackInfo<Value>& args) {
  TCPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));
  int enable = static_cast<int>(args[0]->IsTrue());
  int err = uv_tcp_nodelay(&wrap->handle_, enable);
  args.GetReturnValue().Set(err);
}",185.0,193.0,1.0,1.0,9.0,13,6,11,5,0,0,1,1,0,0,,0,0,2,1,1,void
5058,287506,SetKeepAlive,1,node.TCPWrap.SetKeepAlive,void node.TCPWrap.SetKeepAlive (FunctionCallbackInfo<Value>),tcp_wrap.cc,"void TCPWrap::SetKeepAlive(const FunctionCallbackInfo<Value>& args) {
  TCPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));
  Environment* env = wrap->env();
  int enable;
  if (!args[0]->Int32Value(env->context()).To(&enable)) return;
  unsigned int delay = static_cast<unsigned int>(args[1].As<Uint32>()->Value());
  int err = uv_tcp_keepalive(&wrap->handle_, enable, delay);
  args.GetReturnValue().Set(err);
}",196.0,207.0,1.0,1.0,12.0,22,7,17,7,0,0,2,2,0,0,,0,0,2,1,1,void
5059,287586,Open,1,node.TCPWrap.Open,void node.TCPWrap.Open (FunctionCallbackInfo<Value>),tcp_wrap.cc,"void TCPWrap::Open(const FunctionCallbackInfo<Value>& args) {
  TCPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));
  int64_t val;
  if (!args[0]->IntegerValue(args.GetIsolate()->GetCurrentContext()).To(&val))
    return;
  int fd = static_cast<int>(val);
  int err = uv_tcp_open(&wrap->handle_, fd);

  if (err == 0)
    wrap->set_fd(fd);

  args.GetReturnValue().Set(err);
}",223.0,238.0,1.0,1.0,16.0,20,8,17,6,0,0,3,3,0,0,,0,0,2,1,1,void
5060,287663,Bind,1,node.TCPWrap.Bind,"void node.TCPWrap.Bind<T> (FunctionCallbackInfo<Value>,int,ANY)",tcp_wrap.cc,"void TCPWrap::Bind(const FunctionCallbackInfo<Value>& args) {
  Bind<sockaddr_in>(args, AF_INET, uv_ip4_addr);
}",270.0,272.0,1.0,1.0,3.0,34,10,28,11,0,0,4,4,0,0,,0,0,2,1,1,void
5061,287798,Bind6,1,node.TCPWrap.Bind6,void node.TCPWrap.Bind6 (FunctionCallbackInfo<Value>),tcp_wrap.cc,"void TCPWrap::Bind6(const FunctionCallbackInfo<Value>& args) {
  Bind<sockaddr_in6>(args, AF_INET6, uv_ip6_addr);
}",275.0,277.0,1.0,1.0,3.0,4,4,5,5,0,0,1,1,0,0,,0,0,2,1,1,void
5062,287812,Listen,1,node.TCPWrap.Listen,void node.TCPWrap.Listen (FunctionCallbackInfo<Value>),tcp_wrap.cc,"void TCPWrap::Listen(const FunctionCallbackInfo<Value>& args) {
  TCPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));
  Environment* env = wrap->env();
  int backlog;
  if (!args[0]->Int32Value(env->context()).To(&backlog)) return;
  int err = uv_listen(reinterpret_cast<uv_stream_t*>(&wrap->handle_),
                      backlog,
                      OnConnection);
  args.GetReturnValue().Set(err);
}",280.0,292.0,1.0,1.0,13.0,18,7,15,7,0,0,2,2,0,0,,0,0,2,1,1,void
5063,287880,Connect,1,node.TCPWrap.Connect,void node.TCPWrap.Connect (FunctionCallbackInfo<Value>),tcp_wrap.cc,"void TCPWrap::Connect(const FunctionCallbackInfo<Value>& args,
    std::function<int(const char* ip_address, T* addr)> uv_ip_addr) {
  Environment* env = Environment::GetCurrent(args);

  TCPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));

  CHECK(args[0]->IsObject());
  CHECK(args[1]->IsString());

  Local<Object> req_wrap_obj = args[0].As<Object>();
  node::Utf8Value ip_address(env->isolate(), args[1]);

  T addr;
  int err = uv_ip_addr(*ip_address, &addr);

  if (err == 0) {
    AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(wrap);
    ConnectWrap* req_wrap =
        new ConnectWrap(env, req_wrap_obj, AsyncWrap::PROVIDER_TCPCONNECTWRAP);
    err = req_wrap->Dispatch(uv_tcp_connect,
                             &wrap->handle_,
                             reinterpret_cast<const sockaddr*>(&addr),
                             AfterConnect);
    if (err) {
      delete req_wra...",318.0,360.0,1.0,1.0,43.0,11,9,6,4,0,0,1,1,0,0,,0,0,4,2,2,void
5064,287913,Connect6,1,node.TCPWrap.Connect6,void node.TCPWrap.Connect6 (FunctionCallbackInfo<Value>),tcp_wrap.cc,"void TCPWrap::Connect6(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  CHECK(args[2]->IsUint32());
  int port;
  if (!args[2]->Int32Value(env->context()).To(&port)) return;
  Connect<sockaddr_in6>(args,
                        [port](const char* ip_address, sockaddr_in6* addr) {
      return uv_ip6_addr(ip_address, port, addr);
  });
}",306.0,315.0,1.0,1.0,10.0,14,10,10,6,0,0,2,2,0,0,,0,0,2,1,1,void
5065,288125,Reset,1,node.TCPWrap.Reset,void node.TCPWrap.Reset (FunctionCallbackInfo<Value>),tcp_wrap.cc,"int TCPWrap::Reset(Local<Value> close_callback) {
  if (state_ != kInitialized) return 0;

  int err = uv_tcp_close_reset(&handle_, OnClose);
  state_ = kClosing;
  if (!err & !close_callback.IsEmpty() && close_callback->IsFunction() &&
      !persistent().IsEmpty()) {
    object()
        ->Set(env()->context(), env()->handle_onclose_symbol(), close_callback)
        .Check();
  }
  return err;
}",371.0,383.0,1.0,1.0,13.0,9,5,9,4,0,0,1,1,0,0,,0,0,2,1,1,int
5066,288225,AddressToJS,1,node.AddressToJS,"MaybeLocal<Object> node.AddressToJS (Environment*,sockaddr*,Local<Object>)",tcp_wrap.cc,"MaybeLocal<Object> AddressToJS(Environment* env,
                               const sockaddr* addr,
                               Local<Object> info) {
  EscapableHandleScope scope(env->isolate());
  char ip[INET6_ADDRSTRLEN + UV_IF_NAMESIZE];
  const sockaddr_in* a4;
  const sockaddr_in6* a6;

  int port;

  if (info.IsEmpty())
    info = Object::New(env->isolate());

  switch (addr->sa_family) {
  case AF_INET6:
    a6 = reinterpret_cast<const sockaddr_in6*>(addr);
    uv_inet_ntop(AF_INET6, &a6->sin6_addr, ip, sizeof ip);
    // Add an interface identifier to a link local address.
    if (IN6_IS_ADDR_LINKLOCAL(&a6->sin6_addr) && a6->sin6_scope_id > 0) {
      const size_t addrlen = strlen(ip);
      CHECK_LT(addrlen, sizeof(ip));
      ip[addrlen] = '%';
      size_t scopeidlen = sizeof(ip) - addrlen - 1;
      CHECK_GE(scopeidlen, UV_IF_NAMESIZE);
      const int r = uv_if_indextoiid(a6->sin6_scope_id,
                                     ip + addrlen + 1,
                   ...",386.0,448.0,1.0,1.0,63.0,78,11,82,17,0,0,7,8,0,0,,0,0,6,3,3,MaybeLocal<Object>
5067,288580,Stop,1,node.TimerWrap.Stop,void node.TimerWrap.Stop (),timer_wrap.cc,"void TimerWrap::Stop() {
  if (timer_.data == nullptr) return;
  uv_timer_stop(&timer_);
}",10.0,13.0,1.0,1.0,4.0,2,2,1,1,0,0,2,2,0,0,,0,0,0,0,0,void
5068,288593,Close,1,node.TimerWrap.Close,void node.TimerWrap.Close (),timer_wrap.cc,"void TimerWrap::Close() {
  timer_.data = nullptr;
  env_->CloseHandle(reinterpret_cast<uv_handle_t*>(&timer_), TimerClosedCb);
}",15.0,18.0,1.0,1.0,4.0,5,5,4,3,0,0,1,1,0,0,,0,0,0,0,0,void
5069,288611,TimerClosedCb,1,node.TimerWrap.TimerClosedCb,void node.TimerWrap.TimerClosedCb (uv_handle_t*),timer_wrap.cc,"void TimerWrap::TimerClosedCb(uv_handle_t* handle) {
  std::unique_ptr<TimerWrap> ptr(
      ContainerOf(&TimerWrap::timer_,
                  reinterpret_cast<uv_timer_t*>(handle)));
}",20.0,24.0,1.0,1.0,5.0,6,5,4,3,0,0,1,1,0,0,,0,0,2,1,1,void
5070,288631,Update,1,node.TimerWrap.Update,"void node.TimerWrap.Update (uint64_t,uint64_t)",timer_wrap.cc,"void TimerWrap::Update(uint64_t interval, uint64_t repeat) {
  if (timer_.data == nullptr) return;
  uv_timer_start(&timer_, OnTimeout, interval, repeat);
}",26.0,29.0,1.0,1.0,4.0,3,3,5,4,0,0,2,2,0,0,,0,0,4,2,2,void
5071,288651,Ref,1,node.TimerWrap.Ref,void node.TimerWrap.Ref (),timer_wrap.cc,"void TimerWrap::Ref() {
  if (timer_.data == nullptr) return;
  uv_ref(reinterpret_cast<uv_handle_t*>(&timer_));
}",31.0,34.0,1.0,1.0,4.0,4,4,2,1,0,0,2,2,0,0,,0,0,0,0,0,void
5072,288668,Unref,1,node.TimerWrap.Unref,void node.TimerWrap.Unref (),timer_wrap.cc,"void TimerWrap::Unref() {
  if (timer_.data == nullptr) return;
  uv_unref(reinterpret_cast<uv_handle_t*>(&timer_));
}",36.0,39.0,1.0,1.0,4.0,4,4,2,1,0,0,2,2,0,0,,0,0,0,0,0,void
5073,288685,OnTimeout,1,node.TimerWrap.OnTimeout,void node.TimerWrap.OnTimeout (uv_timer_t*),timer_wrap.cc,"void TimerWrap::OnTimeout(uv_timer_t* timer) {
  TimerWrap* t = ContainerOf(&TimerWrap::timer_, timer);
  t->fn_();
}",41.0,44.0,1.0,1.0,4.0,4,4,4,3,0,0,1,1,0,0,,0,0,2,1,1,void
5074,288703,Stop,1,node.TimerWrapHandle.Stop,void node.TimerWrapHandle.Stop (),timer_wrap.cc,"void TimerWrapHandle::Stop() {
  if (timer_ != nullptr)
    return timer_->Stop();
}",46.0,49.0,1.0,1.0,4.0,2,2,2,1,0,0,2,2,0,0,,0,0,0,0,0,void
5075,288717,Close,1,node.TimerWrapHandle.Close,void node.TimerWrapHandle.Close (),timer_wrap.cc,"void TimerWrapHandle::Close() {
  if (timer_ != nullptr) {
    timer_->env()->RemoveCleanupHook(CleanupHook, this);
    timer_->Close();
  }
  timer_ = nullptr;
}",51.0,57.0,1.0,1.0,7.0,5,3,5,2,0,0,2,2,0,0,,0,0,0,0,0,void
5076,288742,Ref,1,node.TimerWrapHandle.Ref,void node.TimerWrapHandle.Ref (),timer_wrap.cc,"void TimerWrapHandle::Ref() {
  if (timer_ != nullptr)
    timer_->Ref();
}",59.0,62.0,1.0,1.0,4.0,2,2,2,1,0,0,2,2,0,0,,0,0,0,0,0,void
5077,288755,Unref,1,node.TimerWrapHandle.Unref,void node.TimerWrapHandle.Unref (),timer_wrap.cc,"void TimerWrapHandle::Unref() {
  if (timer_ != nullptr)
    timer_->Unref();
}",64.0,67.0,1.0,1.0,4.0,2,2,2,1,0,0,2,2,0,0,,0,0,0,0,0,void
5078,288768,Update,1,node.TimerWrapHandle.Update,"void node.TimerWrapHandle.Update (uint64_t,uint64_t)",timer_wrap.cc,"void TimerWrapHandle::Update(uint64_t interval, uint64_t repeat) {
  if (timer_ != nullptr)
    timer_->Update(interval, repeat);
}",69.0,72.0,1.0,1.0,4.0,2,2,4,3,0,0,2,2,0,0,,0,0,4,2,2,void
5079,288785,MemoryInfo,1,node.TimerWrapHandle.MemoryInfo,void node.TimerWrapHandle.MemoryInfo (MemoryTracker*),timer_wrap.cc,"void TimerWrapHandle::MemoryInfo(MemoryTracker* tracker) const {
  if (timer_ != nullptr)
    tracker->TrackField(""timer"", *timer_);
}",74.0,77.0,1.0,1.0,4.0,3,3,3,2,0,0,2,2,0,0,,0,0,2,1,1,void
5080,288802,CleanupHook,1,node.TimerWrapHandle.CleanupHook,void node.TimerWrapHandle.CleanupHook (void*),timer_wrap.cc,"void TimerWrapHandle::CleanupHook(void* data) {
  static_cast<TimerWrapHandle*>(data)->Close();
}",79.0,81.0,1.0,1.0,3.0,2,2,1,1,0,0,1,1,0,0,,0,0,2,1,1,void
5081,288845,SetupTimers,1,node.timers.BindingData.SetupTimers,void node.timers.BindingData.SetupTimers (FunctionCallbackInfo<Value>),timers.cc,"void BindingData::SetupTimers(const FunctionCallbackInfo<Value>& args) {
  CHECK(args[0]->IsFunction());
  CHECK(args[1]->IsFunction());
  auto env = Environment::GetCurrent(args);

  env->set_immediate_callback_function(args[0].As<Function>());
  env->set_timers_callback_function(args[1].As<Function>());
}",23.0,30.0,1.0,1.0,8.0,12,4,9,3,0,0,1,1,0,0,,0,0,2,1,1,void
5082,288892,SlowGetLibuvNow,1,node.timers.BindingData.SlowGetLibuvNow,void node.timers.BindingData.SlowGetLibuvNow (FunctionCallbackInfo<Value>),timers.cc,"void BindingData::SlowGetLibuvNow(const FunctionCallbackInfo<Value>& args) {
  double now = GetLibuvNowImpl(Realm::GetBindingData<BindingData>(args));
  args.GetReturnValue().Set(Number::New(args.GetIsolate(), now));
}",32.0,35.0,1.0,1.0,4.0,8,4,8,5,0,0,1,1,0,0,,0,0,2,1,1,void
5083,288924,FastGetLibuvNow,1,node.timers.BindingData.FastGetLibuvNow,double node.timers.BindingData.FastGetLibuvNow (Local<Object>),timers.cc,"double BindingData::FastGetLibuvNow(Local<Object> receiver) {
  return GetLibuvNowImpl(FromJSObject<BindingData>(receiver));
}",37.0,39.0,1.0,1.0,3.0,2,2,3,3,0,0,1,1,0,0,,0,0,2,1,1,double
5084,288936,GetLibuvNowImpl,1,node.timers.BindingData.GetLibuvNowImpl,double node.timers.BindingData.GetLibuvNowImpl (BindingData*),timers.cc,"double BindingData::GetLibuvNowImpl(BindingData* data) {
  return static_cast<double>(data->env()->GetNowUint64());
}",41.0,43.0,1.0,1.0,3.0,3,2,1,1,0,0,1,1,0,0,,0,0,2,1,1,double
5085,288951,SlowScheduleTimer,1,node.timers.BindingData.SlowScheduleTimer,void node.timers.BindingData.SlowScheduleTimer (FunctionCallbackInfo<Value>),timers.cc,"void BindingData::SlowScheduleTimer(const FunctionCallbackInfo<Value>& args) {
  int64_t duration =
      args[0]->IntegerValue(args.GetIsolate()->GetCurrentContext()).FromJust();
  ScheduleTimerImpl(Realm::GetBindingData<BindingData>(args), duration);
}",45.0,49.0,1.0,1.0,5.0,9,6,7,4,0,0,1,1,0,0,,0,0,2,1,1,void
5086,288984,FastScheduleTimer,1,node.timers.BindingData.FastScheduleTimer,"void node.timers.BindingData.FastScheduleTimer (Local<Object>,int64_t)",timers.cc,"void BindingData::FastScheduleTimer(Local<Object> receiver, int64_t duration) {
  ScheduleTimerImpl(FromJSObject<BindingData>(receiver), duration);
}",51.0,53.0,1.0,1.0,3.0,2,2,4,4,0,0,1,1,0,0,,0,0,4,2,2,void
5087,288997,ScheduleTimerImpl,1,node.timers.BindingData.ScheduleTimerImpl,"void node.timers.BindingData.ScheduleTimerImpl (BindingData*,int64_t)",timers.cc,"void BindingData::ScheduleTimerImpl(BindingData* data, int64_t duration) {
  data->env()->ScheduleTimer(duration);
}",55.0,57.0,1.0,1.0,3.0,2,1,2,2,0,0,1,1,0,0,,0,0,4,2,2,void
5088,289011,SlowToggleTimerRef,1,node.timers.BindingData.SlowToggleTimerRef,void node.timers.BindingData.SlowToggleTimerRef (ANY),timers.cc,"void BindingData::SlowToggleTimerRef(
    const v8::FunctionCallbackInfo<v8::Value>& args) {
  ToggleTimerRefImpl(Realm::GetBindingData<BindingData>(args),
                     args[0]->IsTrue());
}",59.0,63.0,1.0,1.0,5.0,5,5,4,3,0,0,1,1,0,0,,0,0,2,1,1,void
5089,289030,FastToggleTimerRef,1,node.timers.BindingData.FastToggleTimerRef,"void node.timers.BindingData.FastToggleTimerRef (Local<Object>,bool)",timers.cc,"void BindingData::FastToggleTimerRef(Local<Object> receiver, bool ref) {
  ToggleTimerRefImpl(FromJSObject<BindingData>(receiver), ref);
}",65.0,67.0,1.0,1.0,3.0,2,2,4,4,0,0,1,1,0,0,,0,0,4,2,2,void
5090,289043,ToggleTimerRefImpl,1,node.timers.BindingData.ToggleTimerRefImpl,"void node.timers.BindingData.ToggleTimerRefImpl (BindingData*,bool)",timers.cc,"void BindingData::ToggleTimerRefImpl(BindingData* data, bool ref) {
  data->env()->ToggleTimerRef(ref);
}",69.0,71.0,1.0,1.0,3.0,2,1,2,2,0,0,1,1,0,0,,0,0,4,2,2,void
5091,289057,SlowToggleImmediateRef,1,node.timers.BindingData.SlowToggleImmediateRef,void node.timers.BindingData.SlowToggleImmediateRef (ANY),timers.cc,"void BindingData::SlowToggleImmediateRef(
    const v8::FunctionCallbackInfo<v8::Value>& args) {
  ToggleImmediateRefImpl(Realm::GetBindingData<BindingData>(args),
                         args[0]->IsTrue());
}",73.0,77.0,1.0,1.0,5.0,5,5,4,3,0,0,1,1,0,0,,0,0,2,1,1,void
5092,289076,FastToggleImmediateRef,1,node.timers.BindingData.FastToggleImmediateRef,"void node.timers.BindingData.FastToggleImmediateRef (Local<Object>,bool)",timers.cc,"void BindingData::FastToggleImmediateRef(Local<Object> receiver, bool ref) {
  ToggleImmediateRefImpl(FromJSObject<BindingData>(receiver), ref);
}",79.0,81.0,1.0,1.0,3.0,2,2,4,4,0,0,1,1,0,0,,0,0,4,2,2,void
5093,289089,ToggleImmediateRefImpl,1,node.timers.BindingData.ToggleImmediateRefImpl,"void node.timers.BindingData.ToggleImmediateRefImpl (BindingData*,bool)",timers.cc,"void BindingData::ToggleImmediateRefImpl(BindingData* data, bool ref) {
  data->env()->ToggleImmediateRef(ref);
}",83.0,85.0,1.0,1.0,3.0,2,1,2,2,0,0,1,1,0,0,,0,0,4,2,2,void
5094,289103,BindingData,1,node.timers.BindingData.BindingData,"ANY node.timers.BindingData.BindingData (Realm*,Local<Object>)",timers.cc,"BindingData::BindingData(Realm* realm, Local<Object> object)
    : SnapshotableObject(realm, object, type_int) {}",87.0,88.0,1.0,52.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,ANY
5095,289109,PrepareForSerialization,1,node.timers.BindingData.PrepareForSerialization,"bool node.timers.BindingData.PrepareForSerialization (Local<Context>,ANY*)",timers.cc,"bool BindingData::PrepareForSerialization(Local<Context> context,
                                          v8::SnapshotCreator* creator) {
  // Return true because we need to maintain the reference to the binding from
  // JS land.
  return true;
}",90.0,95.0,1.0,1.0,6.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,bool
5096,289117,Serialize,1,node.timers.BindingData.Serialize,InternalFieldInfoBase node.timers.BindingData.Serialize (int),timers.cc,"InternalFieldInfoBase* BindingData::Serialize(int index) {
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  InternalFieldInfo* info =
      InternalFieldInfoBase::New<InternalFieldInfo>(type());
  return info;
}",97.0,102.0,1.0,1.0,6.0,5,4,6,5,0,0,1,1,0,0,,0,0,2,1,1,InternalFieldInfoBase
5097,289139,Deserialize,1,node.timers.BindingData.Deserialize,"void node.timers.BindingData.Deserialize (Local<Context>,Local<Object>,int,InternalFieldInfoBase*)",timers.cc,"void BindingData::Deserialize(Local<Context> context,
                              Local<Object> holder,
                              int index,
                              InternalFieldInfoBase* info) {
  DCHECK_EQ(index, BaseObject::kEmbedderType);
  v8::HandleScope scope(context->GetIsolate());
  Realm* realm = Realm::GetCurrent(context);
  // Recreate the buffer in the constructor.
  BindingData* binding = realm->AddBindingData<BindingData>(context, holder);
  CHECK_NOT_NULL(binding);
}",104.0,114.0,1.0,1.0,11.0,10,7,12,8,0,0,1,1,0,0,,0,0,8,4,4,void
5098,289181,fast_get_libuv_now_,1,node.timers.fast_get_libuv_now_,ANY node.timers.fast_get_libuv_now_ (ANY),timers.cc,"v8::CFunction BindingData::fast_get_libuv_now_(
    v8::CFunction::Make(FastGetLibuvNow));",116.0,117.0,15.0,41.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
5099,289186,fast_schedule_timers_,1,node.timers.fast_schedule_timers_,ANY node.timers.fast_schedule_timers_ (ANY),timers.cc,"v8::CFunction BindingData::fast_schedule_timers_(
    v8::CFunction::Make(FastScheduleTimer));",118.0,119.0,15.0,43.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
5100,289191,fast_toggle_timer_ref_,1,node.timers.fast_toggle_timer_ref_,ANY node.timers.fast_toggle_timer_ref_ (ANY),timers.cc,"v8::CFunction BindingData::fast_toggle_timer_ref_(
    v8::CFunction::Make(FastToggleTimerRef));",120.0,121.0,15.0,44.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
5101,289196,fast_toggle_immediate_ref_,1,node.timers.fast_toggle_immediate_ref_,ANY node.timers.fast_toggle_immediate_ref_ (ANY),timers.cc,"v8::CFunction BindingData::fast_toggle_immediate_ref_(
    v8::CFunction::Make(FastToggleImmediateRef));",122.0,123.0,15.0,48.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
5102,289201,CreatePerIsolateProperties,1,node.timers.BindingData.CreatePerIsolateProperties,"void node.timers.BindingData.CreatePerIsolateProperties (IsolateData*,Local<FunctionTemplate>)",timers.cc,"void BindingData::CreatePerIsolateProperties(IsolateData* isolate_data,
                                             Local<FunctionTemplate> ctor) {
  Isolate* isolate = isolate_data->isolate();
  Local<ObjectTemplate> target = ctor->InstanceTemplate();

  SetMethod(isolate, target, ""setupTimers"", SetupTimers);
  SetFastMethod(
      isolate, target, ""getLibuvNow"", SlowGetLibuvNow, &fast_get_libuv_now_);
  SetFastMethod(isolate,
                target,
                ""scheduleTimer"",
                SlowScheduleTimer,
                &fast_schedule_timers_);
  SetFastMethod(isolate,
                target,
                ""toggleTimerRef"",
                SlowToggleTimerRef,
                &fast_toggle_timer_ref_);
  SetFastMethod(isolate,
                target,
                ""toggleImmediateRef"",
                SlowToggleImmediateRef,
                &fast_toggle_immediate_ref_);
}",125.0,148.0,1.0,1.0,24.0,10,5,25,15,0,0,1,1,0,0,,0,0,4,2,2,void
5103,289257,CreatePerContextProperties,1,node.timers.BindingData.CreatePerContextProperties,"void node.timers.BindingData.CreatePerContextProperties (Local<Object>,Local<Value>,Local<Context>,void*)",timers.cc,"void BindingData::CreatePerContextProperties(Local<Object> target,
                                             Local<Value> unused,
                                             Local<Context> context,
                                             void* priv) {
  Realm* realm = Realm::GetCurrent(context);
  Environment* env = realm->env();
  BindingData* const binding_data =
      realm->AddBindingData<BindingData>(context, target);
  if (binding_data == nullptr) return;

  // TODO(joyeecheung): move these into BindingData.
  target
      ->Set(context,
            FIXED_ONE_BYTE_STRING(realm->isolate(), ""immediateInfo""),
            env->immediate_info()->fields().GetJSArray())
      .Check();

  target
      ->Set(context,
            FIXED_ONE_BYTE_STRING(realm->isolate(), ""timeoutInfo""),
            env->timeout_info().GetJSArray())
      .Check();
}",150.0,172.0,1.0,1.0,23.0,22,8,19,7,0,0,2,2,0,0,,0,0,8,4,4,void
5104,289344,RegisterTimerExternalReferences,1,node.timers.BindingData.RegisterTimerExternalReferences,void node.timers.BindingData.RegisterTimerExternalReferences (ExternalReferenceRegistry*),timers.cc,"void BindingData::RegisterTimerExternalReferences(
    ExternalReferenceRegistry* registry) {
  registry->Register(SetupTimers);

  registry->Register(SlowGetLibuvNow);
  registry->Register(FastGetLibuvNow);
  registry->Register(fast_get_libuv_now_.GetTypeInfo());

  registry->Register(SlowScheduleTimer);
  registry->Register(FastScheduleTimer);
  registry->Register(fast_schedule_timers_.GetTypeInfo());

  registry->Register(SlowToggleTimerRef);
  registry->Register(FastToggleTimerRef);
  registry->Register(fast_toggle_timer_ref_.GetTypeInfo());

  registry->Register(SlowToggleImmediateRef);
  registry->Register(FastToggleImmediateRef);
  registry->Register(fast_toggle_immediate_ref_.GetTypeInfo());
}",174.0,193.0,1.0,1.0,20.0,17,2,26,14,0,0,1,1,0,0,,0,0,2,1,1,void
5105,289437,<lambda>0,1,node.tracing.Agent.Agent.<lambda>0,ANY node.tracing.Agent.Agent.<lambda>0 (uv_async_t*),tracing\agent.cc,"[](uv_async_t* async) {
    Agent* agent = ContainerOf(&Agent::initialize_writer_async_, async);
    agent->InitializeWritersOnThread();
  }",58.0,61.0,26.0,3.0,4.0,4,4,4,3,0,1,1,1,0,0,,0,1,2,1,1,ANY
5106,289457,<lambda>1,1,node.tracing.Agent.Start.<lambda>1,ANY node.tracing.Agent.Start.<lambda>1 (void*),tracing\agent.cc,"[](void* arg) {
    Agent* agent = static_cast<Agent*>(arg);
    uv_run(&agent->tracing_loop_, UV_RUN_DEFAULT);
  }",97.0,100.0,42.0,3.0,4.0,4,4,4,3,0,1,1,1,0,0,,0,1,2,1,1,ANY
5107,289493,ScopedSuspendTracing,1,node.tracing.ScopedSuspendTracing.ScopedSuspendTracing,"ANY node.tracing.ScopedSuspendTracing.ScopedSuspendTracing (TracingController*,Agent*,bool)",tracing\agent.cc,"ScopedSuspendTracing(TracingController* controller, Agent* agent,
                       bool do_suspend = true)
    : controller_(controller), agent_(do_suspend ? agent : nullptr) {
    if (do_suspend) {
      CHECK(agent_->started_);
      controller->StopTracing();
    }
  }",14.0,21.0,3.0,3.0,8.0,2,1,3,3,0,1,2,2,0,0,,0,1,6,3,3,ANY
5108,289511,~ScopedSuspendTracing,1,node.tracing.ScopedSuspendTracing.~ScopedSuspendTracing,ANY node.tracing.ScopedSuspendTracing.~ScopedSuspendTracing (),tracing\agent.cc,"~ScopedSuspendTracing() {
    if (agent_ == nullptr) return;
    TraceConfig* config = agent_->CreateTraceConfig();
    if (config != nullptr) {
      controller_->StartTracing(config);
    }
  }",23.0,29.0,3.0,3.0,7.0,5,4,6,3,0,3,3,3,1,0,,0,3,0,0,0,ANY
5109,289541,flatten,1,node.tracing.anonymous_namespace_1.flatten,set<std::string> node.tracing.anonymous_namespace_1.flatten (ANY),tracing\agent.cc,"std::set<std::string> flatten(
    const std::unordered_map<int, std::multiset<std::string>>& map) {
  std::set<std::string> result;
  for (const auto& id_value : map)
    result.insert(id_value.second.begin(), id_value.second.end());
  return result;
}",38.0,44.0,1.0,1.0,7.0,4,3,5,3,0,0,2,2,0,0,,0,0,2,1,1,set<std.string>
5110,289576,Agent,1,node.tracing.Agent.Agent,ANY node.tracing.Agent.Agent (),tracing\agent.cc,"Agent::Agent() : tracing_controller_(new TracingController()) {
  tracing_controller_->Initialize(nullptr);

  CHECK_EQ(uv_loop_init(&tracing_loop_), 0);
  CHECK_EQ(uv_async_init(&tracing_loop_,
                         &initialize_writer_async_,
                         [](uv_async_t* async) {
    Agent* agent = ContainerOf(&Agent::initialize_writer_async_, async);
    agent->InitializeWritersOnThread();
  }), 0);
  uv_unref(reinterpret_cast<uv_handle_t*>(&initialize_writer_async_));
}",52.0,63.0,1.0,1.0,12.0,6,3,5,3,0,5,1,1,0,0,,0,5,0,0,0,ANY
5111,289603,InitializeWritersOnThread,1,node.tracing.Agent.InitializeWritersOnThread,void node.tracing.Agent.InitializeWritersOnThread (),tracing\agent.cc,"void Agent::InitializeWritersOnThread() {
  Mutex::ScopedLock lock(initialize_writer_mutex_);
  while (!to_be_initialized_.empty()) {
    AsyncTraceWriter* head = *to_be_initialized_.begin();
    head->InitializeOnThread(&tracing_loop_);
    to_be_initialized_.erase(head);
  }
  initialize_writer_condvar_.Broadcast(lock);
}",65.0,73.0,1.0,1.0,9.0,9,6,10,6,0,6,2,2,1,0,,0,6,0,0,0,void
5112,289641,~Agent,1,node.tracing.Agent.~Agent,ANY node.tracing.Agent.~Agent (),tracing\agent.cc,"Agent::~Agent() {
  categories_.clear();
  writers_.clear();

  StopTracing();

  uv_close(reinterpret_cast<uv_handle_t*>(&initialize_writer_async_), nullptr);
  uv_run(&tracing_loop_, UV_RUN_ONCE);
  CheckedUvLoopClose(&tracing_loop_);
}",75.0,84.0,1.0,1.0,10.0,6,3,6,5,0,5,1,1,0,0,,0,5,0,0,0,ANY
5113,289667,Start,1,node.tracing.Agent.Start,void node.tracing.Agent.Start (),tracing\agent.cc,"void Agent::Start() {
  if (started_)
    return;

  NodeTraceBuffer* trace_buffer_ = new NodeTraceBuffer(
      NodeTraceBuffer::kBufferChunks, this, &tracing_loop_);
  tracing_controller_->Initialize(trace_buffer_);

  // This thread should be created *after* async handles are created
  // (within NodeTraceWriter and NodeTraceBuffer constructors).
  // Otherwise the thread could shut down prematurely.
  CHECK_EQ(0, uv_thread_create(&thread_, [](void* arg) {
    Agent* agent = static_cast<Agent*>(arg);
    uv_run(&agent->tracing_loop_, UV_RUN_DEFAULT);
  }, this));
  started_ = true;
}",86.0,102.0,1.0,1.0,17.0,7,5,9,6,0,6,2,2,1,0,,0,6,0,0,0,void
5114,289701,AddClient,1,node.tracing.Agent.AddClient,"AgentWriterHandle node.tracing.Agent.AddClient (ANY,ANY,UseDefaultCategoryMode)",tracing\agent.cc,"AgentWriterHandle Agent::AddClient(
    const std::set<std::string>& categories,
    std::unique_ptr<AsyncTraceWriter> writer,
    enum UseDefaultCategoryMode mode) {
  Start();

  const std::set<std::string>* use_categories = &categories;

  std::set<std::string> categories_with_default;
  if (mode == kUseDefaultCategories) {
    categories_with_default.insert(categories.begin(), categories.end());
    categories_with_default.insert(categories_[kDefaultHandleId].begin(),
                                   categories_[kDefaultHandleId].end());
    use_categories = &categories_with_default;
  }

  ScopedSuspendTracing suspend(tracing_controller_.get(), this);
  int id = next_writer_id_++;
  AsyncTraceWriter* raw = writer.get();
  writers_[id] = std::move(writer);
  categories_[id] = { use_categories->begin(), use_categories->end() };

  {
    Mutex::ScopedLock lock(initialize_writer_mutex_);
    to_be_initialized_.insert(raw);
    uv_async_send(&initialize_writer_async_);
    while (...",104.0,135.0,1.0,1.0,32.0,31,8,35,17,0,13,3,3,2,0,,0,13,6,3,3,AgentWriterHandle
5115,289821,DefaultHandle,1,node.tracing.Agent.DefaultHandle,AgentWriterHandle node.tracing.Agent.DefaultHandle (),tracing\agent.cc,"AgentWriterHandle Agent::DefaultHandle() {
  return AgentWriterHandle(this, kDefaultHandleId);
}",137.0,139.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,AgentWriterHandle
5116,289829,StopTracing,1,node.tracing.Agent.StopTracing,void node.tracing.Agent.StopTracing (),tracing\agent.cc,"void Agent::StopTracing() {
  if (!started_)
    return;
  // Perform final Flush on TraceBuffer. We don't want the tracing controller
  // to flush the buffer again on destruction of the V8::Platform.
  tracing_controller_->StopTracing();
  tracing_controller_->Initialize(nullptr);
  started_ = false;

  // Thread should finish when the tracing loop is stopped.
  uv_thread_join(&thread_);
}",141.0,152.0,1.0,1.0,12.0,5,4,5,3,0,5,2,2,1,0,,0,5,0,0,0,void
5117,289853,Disconnect,1,node.tracing.Agent.Disconnect,void node.tracing.Agent.Disconnect (int),tracing\agent.cc,"void Agent::Disconnect(int client) {
  if (client == kDefaultHandleId) return;
  {
    Mutex::ScopedLock lock(initialize_writer_mutex_);
    to_be_initialized_.erase(writers_[client].get());
  }
  ScopedSuspendTracing suspend(tracing_controller_.get(), this);
  writers_.erase(client);
  categories_.erase(client);
}",154.0,163.0,1.0,1.0,10.0,7,3,11,7,0,7,2,2,1,0,,0,7,2,1,1,void
5118,289895,Enable,1,node.tracing.Agent.Enable,"void node.tracing.Agent.Enable (int,ANY)",tracing\agent.cc,"void Agent::Enable(int id, const std::set<std::string>& categories) {
  if (categories.empty())
    return;

  ScopedSuspendTracing suspend(tracing_controller_.get(), this,
                               id != kDefaultHandleId);
  categories_[id].insert(categories.begin(), categories.end());
}",165.0,172.0,1.0,1.0,8.0,7,3,8,5,0,3,2,2,0,0,,0,3,4,2,2,void
5119,289932,Disable,1,node.tracing.Agent.Disable,"void node.tracing.Agent.Disable (int,ANY)",tracing\agent.cc,"void Agent::Disable(int id, const std::set<std::string>& categories) {
  ScopedSuspendTracing suspend(tracing_controller_.get(), this,
                               id != kDefaultHandleId);
  std::multiset<std::string>& writer_categories = categories_[id];
  for (const std::string& category : categories) {
    auto it = writer_categories.find(category);
    if (it != writer_categories.end())
      writer_categories.erase(it);
  }
}",174.0,183.0,1.0,1.0,10.0,14,7,16,9,0,3,3,4,0,0,,0,3,4,2,2,void
5120,289987,CreateTraceConfig,1,node.tracing.Agent.CreateTraceConfig,TraceConfig node.tracing.Agent.CreateTraceConfig (),tracing\agent.cc,"TraceConfig* Agent::CreateTraceConfig() const {
  if (categories_.empty())
    return nullptr;
  TraceConfig* trace_config = new TraceConfig();
  for (const auto& category : flatten(categories_)) {
    trace_config->AddIncludedCategory(category.c_str());
  }
  return trace_config;
}",185.0,193.0,1.0,1.0,9.0,5,4,7,4,0,2,3,3,2,0,,0,2,0,0,0,TraceConfig
5121,290019,GetEnabledCategories,1,node.tracing.Agent.GetEnabledCategories,string node.tracing.Agent.GetEnabledCategories (),tracing\agent.cc,"std::string Agent::GetEnabledCategories() const {
  std::string categories;
  for (const std::string& category : flatten(categories_)) {
    if (!categories.empty())
      categories += ',';
    categories += category;
  }
  return categories;
}",195.0,203.0,1.0,1.0,9.0,4,3,6,3,0,1,3,4,1,0,,0,1,0,0,0,string
5122,290044,AppendTraceEvent,1,node.tracing.Agent.AppendTraceEvent,void node.tracing.Agent.AppendTraceEvent (TraceObject*),tracing\agent.cc,"void Agent::AppendTraceEvent(TraceObject* trace_event) {
  for (const auto& id_writer : writers_)
    id_writer.second->AppendTraceEvent(trace_event);
}",205.0,208.0,1.0,1.0,4.0,0,0,1,1,0,1,2,2,1,0,,0,1,2,1,1,void
5123,290059,AddMetadataEvent,1,node.tracing.Agent.AddMetadataEvent,void node.tracing.Agent.AddMetadataEvent (ANY),tracing\agent.cc,"void Agent::AddMetadataEvent(std::unique_ptr<TraceObject> event) {
  Mutex::ScopedLock lock(metadata_events_mutex_);
  metadata_events_.push_back(std::move(event));
}",210.0,213.0,1.0,1.0,4.0,2,1,4,4,0,2,1,1,0,0,,0,2,2,1,1,void
5124,290076,Flush,1,node.tracing.Agent.Flush,void node.tracing.Agent.Flush (bool),tracing\agent.cc,"void Agent::Flush(bool blocking) {
  {
    Mutex::ScopedLock lock(metadata_events_mutex_);
    for (const auto& event : metadata_events_)
      AppendTraceEvent(event.get());
  }

  for (const auto& id_writer : writers_)
    id_writer.second->Flush(blocking);
}",215.0,224.0,1.0,1.0,10.0,0,0,3,3,0,3,3,3,2,0,,0,3,2,1,1,void
5125,290103,AddMetadataEvent,1,node.tracing.TracingController.AddMetadataEvent,"void node.tracing.TracingController.AddMetadataEvent (unsigned char*,char*,int,char**,unsigned char*,uint64_t*,ANY*,unsigned int)",tracing\agent.cc,"void TracingController::AddMetadataEvent(
    const unsigned char* category_group_enabled,
    const char* name,
    int num_args,
    const char** arg_names,
    const unsigned char* arg_types,
    const uint64_t* arg_values,
    std::unique_ptr<v8::ConvertableToTraceFormat>* convertable_values,
    unsigned int flags) {
  std::unique_ptr<TraceObject> trace_event(new TraceObject);
  trace_event->Initialize(
      TRACE_EVENT_PHASE_METADATA, category_group_enabled, name,
      node::tracing::kGlobalScope,  // scope
      node::tracing::kNoId,         // id
      node::tracing::kNoId,         // bind_id
      num_args, arg_names, arg_types, arg_values, convertable_values,
      TRACE_EVENT_FLAG_NONE,
      CurrentTimestampMicroseconds(),
      CurrentCpuTimestampMicroseconds());
  Agent* node_agent = node::tracing::TraceEventHelper::GetAgent();
  if (node_agent != nullptr)
    node_agent->AddMetadataEvent(std::move(trace_event));
}",226.0,248.0,1.0,6.0,23.0,19,8,25,14,0,1,2,2,0,0,,0,1,16,8,8,void
5126,290213,~AsyncTraceWriter,1,node.tracing.AsyncTraceWriter.~AsyncTraceWriter,ANY node.tracing.AsyncTraceWriter.~AsyncTraceWriter (),tracing\agent.hpp,virtual ~AsyncTraceWriter() = default;,29.0,29.0,3.0,40.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
5127,290217,AppendTraceEvent,1,node.tracing.AsyncTraceWriter.AppendTraceEvent,void node.tracing.AsyncTraceWriter.AppendTraceEvent (TraceObject*),tracing\agent.hpp,virtual void AppendTraceEvent(TraceObject* trace_event) = 0;,30.0,30.0,16.0,61.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
5128,290222,Flush,1,node.tracing.AsyncTraceWriter.Flush,void node.tracing.AsyncTraceWriter.Flush (bool),tracing\agent.hpp,virtual void Flush(bool blocking) = 0;,31.0,31.0,16.0,39.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
5129,290227,InitializeOnThread,1,node.tracing.AsyncTraceWriter.InitializeOnThread,void node.tracing.AsyncTraceWriter.InitializeOnThread (uv_loop_t*),tracing\agent.hpp,virtual void InitializeOnThread(uv_loop_t* loop) {},32.0,32.0,3.0,53.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
5130,290233,TracingController,1,node.tracing.TracingController.TracingController,ANY node.tracing.TracingController.TracingController (),tracing\agent.hpp,TracingController() : v8::platform::tracing::TracingController() {},37.0,37.0,3.0,69.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
5131,290237,CurrentTimestampMicroseconds,1,node.tracing.TracingController.CurrentTimestampMicroseconds,int64_t node.tracing.TracingController.CurrentTimestampMicroseconds (),tracing\agent.hpp,"int64_t CurrentTimestampMicroseconds() override {
    return uv_hrtime() / 1000;
  }",39.0,41.0,3.0,3.0,3.0,1,1,0,0,0,0,1,1,0,0,,0,0,0,0,0,int64_t
5132,290258,AgentWriterHandle,1,node.tracing.AgentWriterHandle.AgentWriterHandle,ANY node.tracing.AgentWriterHandle.AgentWriterHandle (),tracing\agent.hpp,"AgentWriterHandle::AgentWriterHandle(AgentWriterHandle&& other) {
  *this = std::move(other);
}",172.0,174.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
5133,290262,~AgentWriterHandle,1,node.tracing.AgentWriterHandle.~AgentWriterHandle,ANY node.tracing.AgentWriterHandle.~AgentWriterHandle (),tracing\agent.hpp,inline ~AgentWriterHandle() { reset(); },56.0,56.0,3.0,42.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
5134,290272,operator =,1,node.tracing.AgentWriterHandle.operator =,AgentWriterHandle node.tracing.AgentWriterHandle.operator = (AgentWriterHandle),tracing\agent.hpp,"AgentWriterHandle& AgentWriterHandle::operator=(AgentWriterHandle&& other) {
  reset();
  agent_ = other.agent_;
  id_ = other.id_;
  other.agent_ = nullptr;
  return *this;
}",164.0,170.0,1.0,1.0,7.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,AgentWriterHandle
5135,290277,empty,1,node.tracing.AgentWriterHandle.empty,bool node.tracing.AgentWriterHandle.empty (),tracing\agent.hpp,inline bool empty() const { return agent_ == nullptr; },60.0,60.0,3.0,57.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,bool
5136,290285,reset,1,node.tracing.AgentWriterHandle.reset,void node.tracing.AgentWriterHandle.reset (),tracing\agent.hpp,"void AgentWriterHandle::reset() {
  if (agent_ != nullptr)
    agent_->Disconnect(id_);
  agent_ = nullptr;
}",158.0,162.0,1.0,1.0,5.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,void
5137,290289,Enable,1,node.tracing.AgentWriterHandle.Enable,void node.tracing.AgentWriterHandle.Enable (ANY),tracing\agent.hpp,"void AgentWriterHandle::Enable(const std::set<std::string>& categories) {
  if (agent_ != nullptr) agent_->Enable(id_, categories);
}",176.0,178.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
5138,290294,Disable,1,node.tracing.AgentWriterHandle.Disable,void node.tracing.AgentWriterHandle.Disable (ANY),tracing\agent.hpp,"void AgentWriterHandle::Disable(const std::set<std::string>& categories) {
  if (agent_ != nullptr) agent_->Disable(id_, categories);
}",180.0,182.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
5139,290299,IsDefaultHandle,1,node.tracing.AgentWriterHandle.IsDefaultHandle,bool node.tracing.AgentWriterHandle.IsDefaultHandle (),tracing\agent.hpp,"bool AgentWriterHandle::IsDefaultHandle() {
  return agent_ != nullptr && id_ == Agent::kDefaultHandleId;
}",184.0,186.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,bool
5140,290303,agent,1,node.tracing.AgentWriterHandle.agent,Agent node.tracing.AgentWriterHandle.agent (),tracing\agent.hpp,inline Agent* agent() { return agent_; },68.0,68.0,3.0,42.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,Agent
5141,290309,GetTracingController,1,node.tracing.AgentWriterHandle.GetTracingController,ANY* node.tracing.AgentWriterHandle.GetTracingController (),tracing\agent.hpp,"inline v8::TracingController* AgentWriterHandle::GetTracingController() {
  return agent_ != nullptr ? agent_->GetTracingController() : nullptr;
}",188.0,190.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,TracingController
5142,290351,GetTracingController,1,node.tracing.Agent.GetTracingController,TracingController node.tracing.Agent.GetTracingController (),tracing\agent.hpp,"TracingController* GetTracingController() {
    TracingController* controller = tracing_controller_.get();
    CHECK_NOT_NULL(controller);
    return controller;
  }",89.0,93.0,3.0,3.0,5.0,2,2,4,2,0,1,1,1,0,0,,0,1,0,0,0,TracingController
5143,290582,<lambda>1,1,node.tracing.NodeTraceBuffer.ExitSignalCb..<lambda>1,ANY node.tracing.NodeTraceBuffer.ExitSignalCb..<lambda>1 (uv_handle_t*),tracing\node_trace_buffer.cc,"[](uv_handle_t* signal) {
      NodeTraceBuffer* buffer =
          ContainerOf(&NodeTraceBuffer::exit_signal_,
                      reinterpret_cast<uv_async_t*>(signal));
        Mutex::ScopedLock scoped_lock(buffer->exit_mutex_);
        buffer->exited_ = true;
        buffer->exit_cond_.Signal(scoped_lock);
    }",187.0,194.0,14.0,5.0,8.0,9,5,7,4,0,4,1,1,0,0,,0,4,2,1,1,ANY
5144,290618,<lambda>0,1,node.tracing.NodeTraceBuffer.ExitSignalCb.<lambda>0,ANY node.tracing.NodeTraceBuffer.ExitSignalCb.<lambda>0 (uv_handle_t*),tracing\node_trace_buffer.cc,"[](uv_handle_t* signal) {
    NodeTraceBuffer* buffer =
        ContainerOf(&NodeTraceBuffer::flush_signal_,
                    reinterpret_cast<uv_async_t*>(signal));

    uv_close(reinterpret_cast<uv_handle_t*>(&buffer->exit_signal_),
             [](uv_handle_t* signal) {
      NodeTraceBuffer* buffer =
          ContainerOf(&NodeTraceBuffer::exit_signal_,
                      reinterpret_cast<uv_async_t*>(signal));
        Mutex::ScopedLock scoped_lock(buffer->exit_mutex_);
        buffer->exited_ = true;
        buffer->exit_cond_.Signal(scoped_lock);
    });
  }",181.0,195.0,12.0,3.0,15.0,7,5,4,3,0,2,1,1,0,0,,0,2,2,1,1,ANY
5145,290654,InternalTraceBuffer,1,node.tracing.InternalTraceBuffer.InternalTraceBuffer,"ANY node.tracing.InternalTraceBuffer.InternalTraceBuffer (size_t,uint32_t,Agent*)",tracing\node_trace_buffer.cc,"InternalTraceBuffer::InternalTraceBuffer(size_t max_chunks, uint32_t id,
                                         Agent* agent)
    : flushing_(false), max_chunks_(max_chunks),
      agent_(agent), id_(id) {
  chunks_.resize(max_chunks);
}",9.0,14.0,1.0,1.0,6.0,1,1,2,2,0,1,1,1,0,0,,0,1,6,3,3,ANY
5146,290666,AddTraceEvent,1,node.tracing.InternalTraceBuffer.AddTraceEvent,TraceObject node.tracing.InternalTraceBuffer.AddTraceEvent (uint64_t*),tracing\node_trace_buffer.cc,"TraceObject* InternalTraceBuffer::AddTraceEvent(uint64_t* handle) {
  Mutex::ScopedLock scoped_lock(mutex_);
  // Create new chunk if last chunk is full or there is no chunk.
  if (total_chunks_ == 0 || chunks_[total_chunks_ - 1]->IsFull()) {
    auto& chunk = chunks_[total_chunks_++];
    if (chunk) {
      chunk->Reset(current_chunk_seq_++);
    } else {
      chunk = std::make_unique<TraceBufferChunk>(current_chunk_seq_++);
    }
  }
  auto& chunk = chunks_[total_chunks_ - 1];
  size_t event_index;
  TraceObject* trace_object = chunk->AddTraceEvent(&event_index);
  *handle = MakeHandle(total_chunks_ - 1, chunk->seq(), event_index);
  return trace_object;
}",16.0,32.0,1.0,1.0,17.0,20,9,21,8,0,10,3,4,3,0,,0,10,2,1,1,TraceObject
5147,290748,GetEventByHandle,1,node.tracing.InternalTraceBuffer.GetEventByHandle,TraceObject node.tracing.InternalTraceBuffer.GetEventByHandle (uint64_t),tracing\node_trace_buffer.cc,"TraceObject* InternalTraceBuffer::GetEventByHandle(uint64_t handle) {
  Mutex::ScopedLock scoped_lock(mutex_);
  if (handle == 0) {
    // A handle value of zero never has a trace event associated with it.
    return nullptr;
  }
  size_t chunk_index, event_index;
  uint32_t buffer_id, chunk_seq;
  ExtractHandle(handle, &buffer_id, &chunk_index, &chunk_seq, &event_index);
  if (buffer_id != id_ || chunk_index >= total_chunks_) {
    // Either the chunk belongs to the other buffer, or is outside the current
    // range of chunks loaded in memory (the latter being true suggests that
    // the chunk has already been flushed and is no longer in memory.)
    return nullptr;
  }
  auto& chunk = chunks_[chunk_index];
  if (chunk->seq() != chunk_seq) {
    // Chunk is no longer in memory.
    return nullptr;
  }
  return chunk->GetEventAt(event_index);
}",34.0,55.0,1.0,1.0,22.0,13,8,18,10,0,4,4,4,2,0,,0,4,2,1,1,TraceObject
5148,290810,Flush,1,node.tracing.InternalTraceBuffer.Flush,void node.tracing.InternalTraceBuffer.Flush (bool),tracing\node_trace_buffer.cc,"void InternalTraceBuffer::Flush(bool blocking) {
  {
    Mutex::ScopedLock scoped_lock(mutex_);
    if (total_chunks_ > 0) {
      flushing_ = true;
      for (size_t i = 0; i < total_chunks_; ++i) {
        auto& chunk = chunks_[i];
        for (size_t j = 0; j < chunk->size(); ++j) {
          TraceObject* trace_event = chunk->GetEventAt(j);
          // Another thread may have added a trace that is yet to be
          // initialized. Skip such traces.
          // https://github.com/nodejs/node/issues/21038.
          if (trace_event->name()) {
            agent_->AppendTraceEvent(trace_event);
          }
        }
      }
      total_chunks_ = 0;
      flushing_ = false;
    }
  }
  agent_->Flush(blocking);
}",57.0,79.0,1.0,1.0,23.0,16,5,22,10,0,9,5,11,2,0,,0,9,2,1,1,void
5149,290890,MakeHandle,1,node.tracing.InternalTraceBuffer.MakeHandle,"uint64_t node.tracing.InternalTraceBuffer.MakeHandle (size_t,uint32_t,size_t)",tracing\node_trace_buffer.cc,"uint64_t InternalTraceBuffer::MakeHandle(
    size_t chunk_index, uint32_t chunk_seq, size_t event_index) const {
  return ((static_cast<uint64_t>(chunk_seq) * Capacity() +
          chunk_index * TraceBufferChunk::kChunkSize + event_index) << 1) + id_;
}",81.0,85.0,1.0,1.0,5.0,8,5,5,5,0,1,1,1,0,0,,0,1,6,3,3,uint64_t
5150,290915,ExtractHandle,1,node.tracing.InternalTraceBuffer.ExtractHandle,"void node.tracing.InternalTraceBuffer.ExtractHandle (uint64_t,uint32_t*,size_t*,uint32_t*,size_t*)",tracing\node_trace_buffer.cc,"void InternalTraceBuffer::ExtractHandle(
    uint64_t handle, uint32_t* buffer_id, size_t* chunk_index,
    uint32_t* chunk_seq, size_t* event_index) const {
  *buffer_id = static_cast<uint32_t>(handle & 0x1);
  handle >>= 1;
  *chunk_seq = static_cast<uint32_t>(handle / Capacity());
  size_t indices = handle % Capacity();
  *chunk_index = indices / TraceBufferChunk::kChunkSize;
  *event_index = indices % TraceBufferChunk::kChunkSize;
}",87.0,96.0,1.0,1.0,10.0,18,7,13,7,0,0,1,1,0,0,,0,0,10,5,5,void
5151,290965,NodeTraceBuffer,1,node.tracing.NodeTraceBuffer.NodeTraceBuffer,"ANY node.tracing.NodeTraceBuffer.NodeTraceBuffer (size_t,Agent*,uv_loop_t*)",tracing\node_trace_buffer.cc,"NodeTraceBuffer::NodeTraceBuffer(size_t max_chunks,
    Agent* agent, uv_loop_t* tracing_loop)
    : tracing_loop_(tracing_loop),
      buffer1_(max_chunks, 0, agent),
      buffer2_(max_chunks, 1, agent) {
  current_buf_.store(&buffer1_);

  flush_signal_.data = this;
  int err = uv_async_init(tracing_loop_, &flush_signal_,
                          NonBlockingFlushSignalCb);
  CHECK_EQ(err, 0);

  exit_signal_.data = this;
  err = uv_async_init(tracing_loop_, &exit_signal_, ExitSignalCb);
  CHECK_EQ(err, 0);
}",98.0,113.0,1.0,1.0,16.0,10,3,14,8,0,8,1,1,0,0,,0,8,6,3,3,ANY
5152,291009,~NodeTraceBuffer,1,node.tracing.NodeTraceBuffer.~NodeTraceBuffer,ANY node.tracing.NodeTraceBuffer.~NodeTraceBuffer (),tracing\node_trace_buffer.cc,"NodeTraceBuffer::~NodeTraceBuffer() {
  uv_async_send(&exit_signal_);
  Mutex::ScopedLock scoped_lock(exit_mutex_);
  while (!exited_) {
    exit_cond_.Wait(scoped_lock);
  }
}",115.0,121.0,1.0,1.0,7.0,3,3,5,5,0,4,2,2,1,0,,0,4,0,0,0,ANY
5153,291028,AddTraceEvent,1,node.tracing.NodeTraceBuffer.AddTraceEvent,TraceObject node.tracing.NodeTraceBuffer.AddTraceEvent (uint64_t*),tracing\node_trace_buffer.cc,"TraceObject* NodeTraceBuffer::AddTraceEvent(uint64_t* handle) {
  // If the buffer is full, attempt to perform a flush.
  if (!TryLoadAvailableBuffer()) {
    // Assign a value of zero as the trace event handle.
    // This is equivalent to calling InternalTraceBuffer::MakeHandle(0, 0, 0),
    // and will cause GetEventByHandle to return NULL if passed as an argument.
    *handle = 0;
    return nullptr;
  }
  return current_buf_.load()->AddTraceEvent(handle);
}",123.0,133.0,1.0,1.0,11.0,5,5,3,2,0,1,2,2,0,0,,0,1,2,1,1,TraceObject
5154,291052,GetEventByHandle,1,node.tracing.NodeTraceBuffer.GetEventByHandle,TraceObject node.tracing.NodeTraceBuffer.GetEventByHandle (uint64_t),tracing\node_trace_buffer.cc,"TraceObject* NodeTraceBuffer::GetEventByHandle(uint64_t handle) {
  return current_buf_.load()->GetEventByHandle(handle);
}",135.0,137.0,1.0,1.0,3.0,2,2,2,2,0,1,1,1,0,0,,0,1,2,1,1,TraceObject
5155,291066,Flush,1,node.tracing.NodeTraceBuffer.Flush,bool node.tracing.NodeTraceBuffer.Flush (),tracing\node_trace_buffer.cc,"bool NodeTraceBuffer::Flush() {
  buffer1_.Flush(true);
  buffer2_.Flush(true);
  return true;
}",139.0,143.0,1.0,1.0,5.0,2,1,2,2,0,2,1,1,0,0,,0,2,0,0,0,bool
5156,291082,TryLoadAvailableBuffer,1,node.tracing.NodeTraceBuffer.TryLoadAvailableBuffer,bool node.tracing.NodeTraceBuffer.TryLoadAvailableBuffer (),tracing\node_trace_buffer.cc,"bool NodeTraceBuffer::TryLoadAvailableBuffer() {
  InternalTraceBuffer* prev_buf = current_buf_.load();
  if (prev_buf->IsFull()) {
    uv_async_send(&flush_signal_);  // trigger flush on a separate thread
    InternalTraceBuffer* other_buf = prev_buf == &buffer1_ ?
      &buffer2_ : &buffer1_;
    if (!other_buf->IsFull()) {
      current_buf_.store(other_buf);
    } else {
      return false;
    }
  }
  return true;
}",148.0,161.0,1.0,1.0,14.0,13,7,12,6,0,6,3,4,0,0,,0,6,0,0,0,bool
5157,291132,NonBlockingFlushSignalCb,1,node.tracing.NodeTraceBuffer.NonBlockingFlushSignalCb,void node.tracing.NodeTraceBuffer.NonBlockingFlushSignalCb (uv_async_t*),tracing\node_trace_buffer.cc,"void NodeTraceBuffer::NonBlockingFlushSignalCb(uv_async_t* signal) {
  NodeTraceBuffer* buffer = static_cast<NodeTraceBuffer*>(signal->data);
  if (buffer->buffer1_.IsFull() && !buffer->buffer1_.IsFlushing()) {
    buffer->buffer1_.Flush(false);
  }
  if (buffer->buffer2_.IsFull() && !buffer->buffer2_.IsFlushing()) {
    buffer->buffer2_.Flush(false);
  }
}",164.0,172.0,1.0,1.0,9.0,19,6,8,2,0,6,3,3,4,0,,0,6,2,1,1,void
5158,291191,ExitSignalCb,1,node.tracing.NodeTraceBuffer.ExitSignalCb,void node.tracing.NodeTraceBuffer.ExitSignalCb (uv_async_t*),tracing\node_trace_buffer.cc,"void NodeTraceBuffer::ExitSignalCb(uv_async_t* signal) {
  NodeTraceBuffer* buffer =
      ContainerOf(&NodeTraceBuffer::exit_signal_, signal);

  // Close both flush_signal_ and exit_signal_.
  uv_close(reinterpret_cast<uv_handle_t*>(&buffer->flush_signal_),
           [](uv_handle_t* signal) {
    NodeTraceBuffer* buffer =
        ContainerOf(&NodeTraceBuffer::flush_signal_,
                    reinterpret_cast<uv_async_t*>(signal));

    uv_close(reinterpret_cast<uv_handle_t*>(&buffer->exit_signal_),
             [](uv_handle_t* signal) {
      NodeTraceBuffer* buffer =
          ContainerOf(&NodeTraceBuffer::exit_signal_,
                      reinterpret_cast<uv_async_t*>(signal));
        Mutex::ScopedLock scoped_lock(buffer->exit_mutex_);
        buffer->exited_ = true;
        buffer->exit_cond_.Signal(scoped_lock);
    });
  });
}",175.0,196.0,1.0,1.0,22.0,6,5,4,3,0,2,1,1,0,0,,0,2,2,1,1,void
5159,291251,IsFull,1,node.tracing.InternalTraceBuffer.IsFull,bool node.tracing.InternalTraceBuffer.IsFull (),tracing\node_trace_buffer.hpp,"bool IsFull() const {
    return total_chunks_ == max_chunks_ && chunks_[total_chunks_ - 1]->IsFull();
  }",27.0,29.0,3.0,3.0,3.0,5,5,4,3,0,4,1,1,0,0,,0,4,0,0,0,bool
5160,291268,IsFlushing,1,node.tracing.InternalTraceBuffer.IsFlushing,bool node.tracing.InternalTraceBuffer.IsFlushing (),tracing\node_trace_buffer.hpp,"bool IsFlushing() const {
    return flushing_;
  }",30.0,32.0,3.0,3.0,3.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,bool
5161,291290,Capacity,1,node.tracing.InternalTraceBuffer.Capacity,size_t node.tracing.InternalTraceBuffer.Capacity (),tracing\node_trace_buffer.hpp,size_t Capacity() const { return max_chunks_ * TraceBufferChunk::kChunkSize; },39.0,39.0,3.0,80.0,1.0,2,2,2,2,0,1,1,1,0,0,,0,1,0,0,0,size_t
5162,291379,<lambda>0,1,node.tracing.NodeTraceWriter.InitializeOnThread.<lambda>0,ANY node.tracing.NodeTraceWriter.InitializeOnThread.<lambda>0 (uv_async_t*),tracing\node_trace_writer.cc,"[](uv_async_t* signal) {
    NodeTraceWriter* trace_writer =
        ContainerOf(&NodeTraceWriter::flush_signal_, signal);
    trace_writer->FlushPrivate();
  }",20.0,24.0,27.0,3.0,5.0,4,4,4,3,0,1,1,1,0,0,,0,1,2,1,1,ANY
5163,291399,<lambda>1,1,node.tracing.NodeTraceWriter.StartWrite.<lambda>1,ANY node.tracing.NodeTraceWriter.StartWrite.<lambda>1 (uv_fs_t*),tracing\node_trace_writer.cc,"[](uv_fs_t* req) {
        NodeTraceWriter* writer =
            ContainerOf(&NodeTraceWriter::write_req_, req);
        writer->AfterWrite();
      }",187.0,191.0,7.0,7.0,5.0,4,4,4,3,0,1,1,1,0,0,,0,1,2,1,1,ANY
5164,291418,<lambda>3,1,node.tracing.NodeTraceWriter.ExitSignalCb..<lambda>3,ANY node.tracing.NodeTraceWriter.ExitSignalCb..<lambda>3 (uv_handle_t*),tracing\node_trace_writer.cc,"[](uv_handle_t* signal) {
                   NodeTraceWriter* trace_writer =
                       ContainerOf(&NodeTraceWriter::exit_signal_,
                                   reinterpret_cast<uv_async_t*>(signal));
                   Mutex::ScopedLock scoped_lock(trace_writer->request_mutex_);
                   trace_writer->exited_ = true;
                   trace_writer->exit_cond_.Signal(scoped_lock);
                 }",229.0,236.0,18.0,18.0,8.0,9,5,7,4,0,4,1,1,0,0,,0,4,2,1,1,ANY
5165,291453,<lambda>2,1,node.tracing.NodeTraceWriter.ExitSignalCb.<lambda>2,ANY node.tracing.NodeTraceWriter.ExitSignalCb.<lambda>2 (uv_handle_t*),tracing\node_trace_writer.cc,"[](uv_handle_t* signal) {
             NodeTraceWriter* trace_writer =
                 ContainerOf(&NodeTraceWriter::flush_signal_,
                             reinterpret_cast<uv_async_t*>(signal));
             uv_close(
                 reinterpret_cast<uv_handle_t*>(&trace_writer->exit_signal_),
                 [](uv_handle_t* signal) {
                   NodeTraceWriter* trace_writer =
                       ContainerOf(&NodeTraceWriter::exit_signal_,
                                   reinterpret_cast<uv_async_t*>(signal));
                   Mutex::ScopedLock scoped_lock(trace_writer->request_mutex_);
                   trace_writer->exited_ = true;
                   trace_writer->exit_cond_.Signal(scoped_lock);
                 });
           }",223.0,237.0,12.0,12.0,15.0,7,5,4,3,0,2,1,1,0,0,,0,2,2,1,1,ANY
5166,291491,NodeTraceWriter,1,node.tracing.NodeTraceWriter.NodeTraceWriter,ANY node.tracing.NodeTraceWriter.NodeTraceWriter (ANY),tracing\node_trace_writer.cc,"NodeTraceWriter::NodeTraceWriter(const std::string& log_file_pattern)
    : log_file_pattern_(log_file_pattern) {}",11.0,12.0,1.0,44.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
5167,291496,InitializeOnThread,1,node.tracing.NodeTraceWriter.InitializeOnThread,void node.tracing.NodeTraceWriter.InitializeOnThread (uv_loop_t*),tracing\node_trace_writer.cc,"void NodeTraceWriter::InitializeOnThread(uv_loop_t* loop) {
  CHECK_NULL(tracing_loop_);
  tracing_loop_ = loop;

  flush_signal_.data = this;
  int err = uv_async_init(tracing_loop_, &flush_signal_,
                          [](uv_async_t* signal) {
    NodeTraceWriter* trace_writer =
        ContainerOf(&NodeTraceWriter::flush_signal_, signal);
    trace_writer->FlushPrivate();
  });
  CHECK_EQ(err, 0);

  exit_signal_.data = this;
  err = uv_async_init(tracing_loop_, &exit_signal_, ExitSignalCb);
  CHECK_EQ(err, 0);
}",14.0,30.0,1.0,1.0,17.0,9,3,14,6,0,8,1,1,0,0,,0,8,2,1,1,void
5168,291537,WriteSuffix,1,node.tracing.NodeTraceWriter.WriteSuffix,void node.tracing.NodeTraceWriter.WriteSuffix (),tracing\node_trace_writer.cc,"void NodeTraceWriter::WriteSuffix() {
  // If our final log file has traces, then end the file appropriately.
  // This means that if no trace events are recorded, then no trace file is
  // produced.
  bool should_flush = false;
  {
    Mutex::ScopedLock scoped_lock(stream_mutex_);
    if (total_traces_ > 0) {
      total_traces_ = kTracesPerFile;  // Act as if we reached the file limit.
      should_flush = true;
    }
  }
  if (should_flush) {
    Flush(true);
  }
}",32.0,47.0,1.0,1.0,16.0,4,2,7,4,0,4,3,3,1,0,,0,4,0,0,0,void
5169,291565,~NodeTraceWriter,1,node.tracing.NodeTraceWriter.~NodeTraceWriter,ANY node.tracing.NodeTraceWriter.~NodeTraceWriter (),tracing\node_trace_writer.cc,"NodeTraceWriter::~NodeTraceWriter() {
  WriteSuffix();
  uv_fs_t req;
  if (fd_ != -1) {
    CHECK_EQ(0, uv_fs_close(nullptr, &req, fd_, nullptr));
    uv_fs_req_cleanup(&req);
  }
  uv_async_send(&exit_signal_);
  Mutex::ScopedLock scoped_lock(request_mutex_);
  while (!exited_) {
    exit_cond_.Wait(scoped_lock);
  }
}",49.0,61.0,1.0,1.0,13.0,7,5,9,7,0,6,3,3,2,0,,0,6,0,0,0,ANY
5170,291603,replace_substring,1,node.tracing.replace_substring,"void node.tracing.replace_substring (ANY*,ANY,ANY)",tracing\node_trace_writer.cc,"void replace_substring(std::string* target,
                       const std::string& search,
                       const std::string& insert) {
  size_t pos = target->find(search);
  for (; pos != std::string::npos; pos = target->find(search, pos)) {
    target->replace(pos, search.size(), insert);
    pos += insert.size();
  }
}",63.0,71.0,1.0,1.0,9.0,9,5,12,6,0,0,2,2,0,0,,0,0,6,3,3,void
5171,291652,OpenNewFileForStreaming,1,node.tracing.NodeTraceWriter.OpenNewFileForStreaming,void node.tracing.NodeTraceWriter.OpenNewFileForStreaming (),tracing\node_trace_writer.cc,"void NodeTraceWriter::OpenNewFileForStreaming() {
  ++file_num_;
  uv_fs_t req;

  // Evaluate a JS-style template string, it accepts the values ${pid} and
  // ${rotation}
  std::string filepath(log_file_pattern_);
  replace_substring(&filepath, ""${pid}"", std::to_string(uv_os_getpid()));
  replace_substring(&filepath, ""${rotation}"", std::to_string(file_num_));

  if (fd_ != -1) {
    CHECK_EQ(uv_fs_close(nullptr, &req, fd_, nullptr), 0);
    uv_fs_req_cleanup(&req);
  }

  fd_ = uv_fs_open(nullptr, &req, filepath.c_str(),
      O_CREAT | O_WRONLY | O_TRUNC, 0644, nullptr);
  uv_fs_req_cleanup(&req);
  if (fd_ < 0) {
    fprintf(stderr, ""Could not open trace file %s: %s\n"",
                    filepath.c_str(),
                    uv_strerror(fd_));
    fd_ = -1;
  }
}",73.0,97.0,1.0,1.0,25.0,19,8,23,10,0,9,3,3,2,0,,0,9,0,0,0,void
5172,291735,AppendTraceEvent,1,node.tracing.NodeTraceWriter.AppendTraceEvent,void node.tracing.NodeTraceWriter.AppendTraceEvent (TraceObject*),tracing\node_trace_writer.cc,"void NodeTraceWriter::AppendTraceEvent(TraceObject* trace_event) {
  Mutex::ScopedLock scoped_lock(stream_mutex_);
  // If this is the first trace event, open a new file for streaming.
  if (total_traces_ == 0) {
    OpenNewFileForStreaming();
    // Constructing a new JSONTraceWriter object appends ""{\""traceEvents\"":[""
    // to stream_.
    // In other words, the constructor initializes the serialization stream
    // to a state where we can start writing trace events to it.
    // Repeatedly constructing and destroying json_trace_writer_ allows
    // us to use V8's JSON writer instead of implementing our own.
    json_trace_writer_.reset(TraceWriter::CreateJSONTraceWriter(stream_));
  }
  ++total_traces_;
  json_trace_writer_->AppendTraceEvent(trace_event);
}",99.0,114.0,1.0,1.0,16.0,5,4,8,6,0,6,2,2,1,0,,0,6,2,1,1,void
5173,291765,FlushPrivate,1,node.tracing.NodeTraceWriter.FlushPrivate,void node.tracing.NodeTraceWriter.FlushPrivate (),tracing\node_trace_writer.cc,"void NodeTraceWriter::FlushPrivate() {
  std::string str;
  int highest_request_id;
  {
    Mutex::ScopedLock stream_scoped_lock(stream_mutex_);
    if (total_traces_ >= kTracesPerFile) {
      total_traces_ = 0;
      // Destroying the member JSONTraceWriter object appends ""]}"" to
      // stream_ - in other words, ending a JSON file.
      json_trace_writer_.reset();
    }
    // str() makes a copy of the contents of the stream.
    str = stream_.str();
    stream_.str("""");
    stream_.clear();
  }
  {
    Mutex::ScopedLock request_scoped_lock(request_mutex_);
    highest_request_id = num_write_requests_;
  }
  WriteToFile(std::move(str), highest_request_id);
}",116.0,137.0,1.0,1.0,22.0,9,3,15,10,0,12,2,2,2,0,,0,12,0,0,0,void
5174,291816,Flush,1,node.tracing.NodeTraceWriter.Flush,void node.tracing.NodeTraceWriter.Flush (bool),tracing\node_trace_writer.cc,"void NodeTraceWriter::Flush(bool blocking) {
  Mutex::ScopedLock scoped_lock(request_mutex_);
  {
    // We need to lock the mutexes here in a nested fashion; stream_mutex_
    // protects json_trace_writer_, and without request_mutex_ there might be
    // a time window in which the stream state changes?
    Mutex::ScopedLock stream_mutex_lock(stream_mutex_);
    if (!json_trace_writer_)
      return;
  }
  int request_id = ++num_write_requests_;
  int err = uv_async_send(&flush_signal_);
  CHECK_EQ(err, 0);
  if (blocking) {
    // Wait until data associated with this request id has been written to disk.
    // This guarantees that data from all earlier requests have also been
    // written.
    while (request_id > highest_request_id_completed_) {
      request_cond_.Wait(scoped_lock);
    }
  }
}",139.0,160.0,1.0,1.0,22.0,7,6,13,11,0,7,4,5,2,0,,0,7,2,1,1,void
5175,291860,WriteToFile,1,node.tracing.NodeTraceWriter.WriteToFile,"void node.tracing.NodeTraceWriter.WriteToFile (ANY,int)",tracing\node_trace_writer.cc,"void NodeTraceWriter::WriteToFile(std::string&& str, int highest_request_id) {
  if (fd_ == -1) return;

  uv_buf_t buf = uv_buf_init(nullptr, 0);
  {
    Mutex::ScopedLock lock(request_mutex_);
    write_req_queue_.emplace(WriteRequest {
      std::move(str), highest_request_id
    });
    if (write_req_queue_.size() == 1) {
      buf = uv_buf_init(
          const_cast<char*>(write_req_queue_.front().str.c_str()),
          write_req_queue_.front().str.length());
    }
  }
  // Only one write request for the same file descriptor should be active at
  // a time.
  if (buf.base != nullptr && fd_ != -1) {
    StartWrite(buf);
  }
}",162.0,182.0,1.0,1.0,21.0,21,8,14,7,0,7,4,4,3,0,,0,7,4,2,2,void
5176,291940,StartWrite,1,node.tracing.NodeTraceWriter.StartWrite,void node.tracing.NodeTraceWriter.StartWrite (uv_buf_t),tracing\node_trace_writer.cc,"void NodeTraceWriter::StartWrite(uv_buf_t buf) {
  int err = uv_fs_write(
      tracing_loop_, &write_req_, fd_, &buf, 1, -1,
      [](uv_fs_t* req) {
        NodeTraceWriter* writer =
            ContainerOf(&NodeTraceWriter::write_req_, req);
        writer->AfterWrite();
      });
  CHECK_EQ(err, 0);
}",184.0,193.0,1.0,1.0,10.0,4,3,6,5,0,3,1,1,0,0,,0,3,2,1,1,void
5177,291962,AfterWrite,1,node.tracing.NodeTraceWriter.AfterWrite,void node.tracing.NodeTraceWriter.AfterWrite (),tracing\node_trace_writer.cc,"void NodeTraceWriter::AfterWrite() {
  CHECK_GE(write_req_.result, 0);
  uv_fs_req_cleanup(&write_req_);

  uv_buf_t buf = uv_buf_init(nullptr, 0);
  {
    Mutex::ScopedLock scoped_lock(request_mutex_);
    int highest_request_id = write_req_queue_.front().highest_request_id;
    write_req_queue_.pop();
    highest_request_id_completed_ = highest_request_id;
    request_cond_.Broadcast(scoped_lock);
    if (!write_req_queue_.empty()) {
      buf = uv_buf_init(
          const_cast<char*>(write_req_queue_.front().str.c_str()),
          write_req_queue_.front().str.length());
    }
  }
  if (buf.base != nullptr && fd_ != -1) {
    StartWrite(buf);
  }
}",195.0,215.0,1.0,1.0,21.0,24,8,18,9,0,11,3,3,2,0,,0,11,0,0,0,void
5178,292049,ExitSignalCb,1,node.tracing.NodeTraceWriter.ExitSignalCb,void node.tracing.NodeTraceWriter.ExitSignalCb (uv_async_t*),tracing\node_trace_writer.cc,"void NodeTraceWriter::ExitSignalCb(uv_async_t* signal) {
  NodeTraceWriter* trace_writer =
      ContainerOf(&NodeTraceWriter::exit_signal_, signal);
  // Close both flush_signal_ and exit_signal_.
  uv_close(reinterpret_cast<uv_handle_t*>(&trace_writer->flush_signal_),
           [](uv_handle_t* signal) {
             NodeTraceWriter* trace_writer =
                 ContainerOf(&NodeTraceWriter::flush_signal_,
                             reinterpret_cast<uv_async_t*>(signal));
             uv_close(
                 reinterpret_cast<uv_handle_t*>(&trace_writer->exit_signal_),
                 [](uv_handle_t* signal) {
                   NodeTraceWriter* trace_writer =
                       ContainerOf(&NodeTraceWriter::exit_signal_,
                                   reinterpret_cast<uv_async_t*>(signal));
                   Mutex::ScopedLock scoped_lock(trace_writer->request_mutex_);
                   trace_writer->exited_ = true;
                   trace_writer->exit_cond_.Sig...",218.0,238.0,1.0,1.0,21.0,6,5,4,3,0,2,1,1,0,0,,0,2,2,1,1,void
5179,292216,SetAgent,1,node.tracing.TraceEventHelper.SetAgent,void node.tracing.TraceEventHelper.SetAgent (Agent*),tracing\trace_event.cc,"void TraceEventHelper::SetAgent(Agent* agent) {
  if (agent) {
    g_agent = agent;
    g_controller = agent->GetTracingController();
  } else {
    g_agent = nullptr;
    g_controller = nullptr;
  }
}",10.0,18.0,1.0,1.0,9.0,3,2,5,3,0,0,2,2,0,0,,0,0,2,1,1,void
5180,292241,GetAgent,1,node.tracing.TraceEventHelper.GetAgent,Agent node.tracing.TraceEventHelper.GetAgent (),tracing\trace_event.cc,"Agent* TraceEventHelper::GetAgent() {
  return g_agent;
}",20.0,22.0,1.0,1.0,3.0,0,0,1,1,1,0,1,1,0,0,,0,0,0,0,0,Agent
5181,292247,GetTracingController,1,node.tracing.TraceEventHelper.GetTracingController,TracingController node.tracing.TraceEventHelper.GetTracingController (),tracing\trace_event.cc,"v8::TracingController* TraceEventHelper::GetTracingController() {
  return g_controller;
}",24.0,26.0,1.0,1.0,3.0,0,0,1,1,1,0,1,1,0,0,,0,0,0,0,0,TracingController
5182,292253,SetTracingController,1,node.tracing.TraceEventHelper.SetTracingController,void node.tracing.TraceEventHelper.SetTracingController (ANY*),tracing\trace_event.cc,"void TraceEventHelper::SetTracingController(v8::TracingController* controller) {
  g_controller = controller;
}",28.0,30.0,1.0,1.0,3.0,1,1,2,2,0,0,1,1,0,0,,0,0,2,1,1,void
5183,292353,GetCategoryGroupEnabled,1,node.tracing.TraceEventHelper.GetCategoryGroupEnabled,uint8_t node.tracing.TraceEventHelper.GetCategoryGroupEnabled (char*),tracing\trace_event.hpp,"static inline const uint8_t* GetCategoryGroupEnabled(const char* group) {
    v8::TracingController* controller = GetTracingController();
    static const uint8_t disabled = 0;
    if (UNLIKELY(controller == nullptr)) return &disabled;
    return controller->GetCategoryGroupEnabled(group);
  }",321.0,326.0,3.0,3.0,6.0,5,4,6,3,0,0,2,2,0,0,,0,0,2,1,1,uint8_t
5184,292383,WithScope,1,node.tracing.TraceID.WithScope.WithScope,"ANY node.tracing.TraceID.WithScope.WithScope (char*,uint64_t)",tracing\trace_event.hpp,"WithScope(const char* scope, uint64_t raw_id)
        : scope_(scope), raw_id_(raw_id) {}",336.0,337.0,5.0,43.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,ANY
5185,292389,raw_id,1,node.tracing.TraceID.WithScope.raw_id,uint64_t node.tracing.TraceID.WithScope.raw_id (),tracing\trace_event.hpp,uint64_t raw_id() const { return raw_id_; },338.0,338.0,5.0,47.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,uint64_t
5186,292395,scope,1,node.tracing.TraceID.WithScope.scope,const char* node.tracing.TraceID.WithScope.scope (),tracing\trace_event.hpp,const char* scope() const { return scope_; },339.0,339.0,5.0,48.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,const char*
5187,292411,DontMangle,1,node.tracing.TraceID.DontMangle.DontMangle,ANY node.tracing.TraceID.DontMangle.DontMangle (void*),tracing\trace_event.hpp,"explicit DontMangle(WithScope scoped_id)
        : scope_(scoped_id.scope()), raw_id_(scoped_id.raw_id()) {}",361.0,362.0,5.0,67.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
5188,292461,scope,1,node.tracing.TraceID.DontMangle.scope,const char* node.tracing.TraceID.DontMangle.scope (),tracing\trace_event.hpp,const char* scope() const { return scope_; },363.0,363.0,5.0,48.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,const char*
5189,292467,raw_id,1,node.tracing.TraceID.DontMangle.raw_id,uint64_t node.tracing.TraceID.DontMangle.raw_id (),tracing\trace_event.hpp,uint64_t raw_id() const { return raw_id_; },364.0,364.0,5.0,47.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,uint64_t
5190,292483,ForceMangle,1,node.tracing.TraceID.ForceMangle.ForceMangle,ANY node.tracing.TraceID.ForceMangle.ForceMangle (uint64_t),tracing\trace_event.hpp,"explicit ForceMangle(signed char raw_id)
        : raw_id_(static_cast<uint64_t>(raw_id)) {}",382.0,383.0,5.0,51.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
5191,292523,raw_id,1,node.tracing.TraceID.ForceMangle.raw_id,uint64_t node.tracing.TraceID.ForceMangle.raw_id (),tracing\trace_event.hpp,uint64_t raw_id() const { return raw_id_; },384.0,384.0,5.0,47.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,uint64_t
5192,292530,TraceID,1,node.tracing.TraceID.TraceID,"ANY node.tracing.TraceID.TraceID (void*,unsigned int*)",tracing\trace_event.hpp,"TraceID(WithScope scoped_id, unsigned int* flags)
      : scope_(scoped_id.scope()), raw_id_(scoped_id.raw_id()) {}",427.0,428.0,3.0,65.0,2.0,3,3,1,1,0,0,1,1,0,0,,0,0,4,2,2,ANY
5193,292646,raw_id,1,node.tracing.TraceID.raw_id,uint64_t node.tracing.TraceID.raw_id (),tracing\trace_event.hpp,uint64_t raw_id() const { return raw_id_; },430.0,430.0,3.0,45.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,uint64_t
5194,292652,scope,1,node.tracing.TraceID.scope,const char* node.tracing.TraceID.scope (),tracing\trace_event.hpp,const char* scope() const { return scope_; },431.0,431.0,3.0,46.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,const char*
5195,292675,TraceStringWithCopy,1,node.tracing.TraceStringWithCopy.TraceStringWithCopy,ANY node.tracing.TraceStringWithCopy.TraceStringWithCopy (char*),tracing\trace_event.hpp,explicit TraceStringWithCopy(const char* str) : str_(str) {},451.0,451.0,3.0,62.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
5196,292680,operator const char *,1,node.tracing.TraceStringWithCopy.operator const char *,ANY node.tracing.TraceStringWithCopy.operator const char * (),tracing\trace_event.hpp,operator const char*() const { return str_; },452.0,452.0,3.0,47.0,1.0,0,0,1,1,0,0,1,1,0,0,,0,0,0,0,0,ANY
5197,292687,AddTraceEventImpl,1,node.tracing.AddTraceEventImpl,"uint64_t node.tracing.AddTraceEventImpl (char,uint8_t*,char*,char*,uint64_t,uint64_t,int32_t,char**,uint8_t*,uint64_t*,unsigned int)",tracing\trace_event.hpp,"static inline uint64_t AddTraceEventImpl(
    char phase, const uint8_t* category_group_enabled, const char* name,
    const char* scope, uint64_t id, uint64_t bind_id, int32_t num_args,
    const char** arg_names, const uint8_t* arg_types,
    const uint64_t* arg_values, unsigned int flags) {
  std::unique_ptr<v8::ConvertableToTraceFormat> arg_convertibles[2];
  if (num_args > 0 && arg_types[0] == TRACE_VALUE_TYPE_CONVERTABLE) {
    arg_convertibles[0].reset(reinterpret_cast<v8::ConvertableToTraceFormat*>(
        static_cast<intptr_t>(arg_values[0])));
  }
  if (num_args > 1 && arg_types[1] == TRACE_VALUE_TYPE_CONVERTABLE) {
    arg_convertibles[1].reset(reinterpret_cast<v8::ConvertableToTraceFormat*>(
        static_cast<intptr_t>(arg_values[1])));
  }
  // DCHECK(num_args, 2);
  v8::TracingController* controller =
      node::tracing::TraceEventHelper::GetTracingController();
  if (controller == nullptr) return 0;
  return controller->AddTraceEvent(phase, category_group_enabled,...",458.0,479.0,1.0,38.0,22.0,26,8,26,16,0,1,4,4,0,0,,0,1,22,11,11,uint64_t
5198,292796,SetTraceValue,1,node.tracing.SetTraceValue,"void node.tracing.SetTraceValue (uint64_t,unsigned char*,uint64_t*)",tracing\trace_event.hpp,"static inline typename std::enable_if<
    std::is_convertible<T*, v8::ConvertableToTraceFormat*>::value>::type
SetTraceValue(std::unique_ptr<T> ptr, unsigned char* type, uint64_t* value) {
  SetTraceValue(ptr.release(), type, value);
}",572.0,576.0,1.0,1.0,5.0,6,3,3,3,0,0,1,1,0,0,,0,0,6,3,3,type
5199,293110,AddTraceEvent,1,node.tracing.AddTraceEvent,"uint64_t node.tracing.AddTraceEvent (char,uint8_t*,char*,char*,uint64_t,uint64_t,unsigned int)",tracing\trace_event.hpp,"static inline uint64_t AddTraceEvent(
    char phase, const uint8_t* category_group_enabled, const char* name,
    const char* scope, uint64_t id, uint64_t bind_id, unsigned int flags,
    const char* arg1_name, ARG1_TYPE&& arg1_val, const char* arg2_name,
    ARG2_TYPE&& arg2_val) {
  const int num_args = 2;
  const char* arg_names[2] = {arg1_name, arg2_name};
  unsigned char arg_types[2];
  uint64_t arg_values[2];
  SetTraceValue(std::forward<ARG1_TYPE>(arg1_val), &arg_types[0],
                &arg_values[0]);
  SetTraceValue(std::forward<ARG2_TYPE>(arg2_val), &arg_types[1],
                &arg_values[1]);
  return TRACE_EVENT_API_ADD_TRACE_EVENT(
      phase, category_group_enabled, name, scope, id, bind_id, num_args,
      arg_names, arg_types, arg_values, flags);
}",609.0,625.0,1.0,9.0,17.0,2,1,10,9,0,0,1,1,0,0,,0,0,22,11,11,uint64_t
5200,293279,ScopedTracer,1,node.tracing.ScopedTracer.ScopedTracer,ANY node.tracing.ScopedTracer.ScopedTracer (),tracing\trace_event.hpp,ScopedTracer() : p_data_(nullptr) {},686.0,686.0,3.0,38.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
5201,293283,~ScopedTracer,1,node.tracing.ScopedTracer.~ScopedTracer,ANY node.tracing.ScopedTracer.~ScopedTracer (),tracing\trace_event.hpp,"~ScopedTracer() {
    if (p_data_ && *data_.category_group_enabled)
      TRACE_EVENT_API_UPDATE_TRACE_EVENT_DURATION(
          data_.category_group_enabled, data_.name, data_.event_handle);
  }",688.0,692.0,3.0,6.0,5.0,11,5,10,4,0,9,2,2,3,0,,0,9,0,0,0,ANY
5202,293324,Initialize,1,node.tracing.ScopedTracer.Initialize,"void node.tracing.ScopedTracer.Initialize (uint8_t*,char*,uint64_t)",tracing\trace_event.hpp,"void Initialize(const uint8_t* category_group_enabled, const char* name,
                  uint64_t event_handle) {
    data_.category_group_enabled = category_group_enabled;
    data_.name = name;
    data_.event_handle = event_handle;
    p_data_ = &data_;
  }",694.0,700.0,3.0,3.0,7.0,8,3,8,5,0,8,1,1,0,0,,0,8,6,3,3,void
5203,293383,EscapeString,1,node.tracing.anonymous_namespace_1.EscapeString,string node.tracing.anonymous_namespace_1.EscapeString (char*),tracing\traced_value.cc,"std::string EscapeString(const char* value) {
  std::string result;
  result += '""';
  char number_buffer[10];
#if defined(NODE_HAVE_I18N_SUPPORT)
  int32_t len = strlen(value);
  int32_t p = 0;
  int32_t i = 0;
  for (; i < len; p = i) {
    UChar32 c;
    U8_NEXT_OR_FFFD(value, i, len, c);
    switch (c) {
      case '\b': result += ""\\b""; break;
      case '\f': result += ""\\f""; break;
      case '\n': result += ""\\n""; break;
      case '\r': result += ""\\r""; break;
      case '\t': result += ""\\t""; break;
      case '\\': result += ""\\\\""; break;
      case '""': result += ""\\\""""; break;
      default:
        if (c < 32 || c > 126) {
          snprintf(
              number_buffer, arraysize(number_buffer), ""\\u%04X"",
              static_cast<uint16_t>(static_cast<uint16_t>(c)));
          result += number_buffer;
        } else {
          result.append(value + p, i - p);
        }
    }
  }
#else
  // If we do not have ICU, use a modified version of the non-UTF8 aware
  // co...",29.0,87.0,1.0,1.0,59.0,17,6,20,4,0,0,11,7,0,0,,0,0,2,1,1,string
5204,293477,DoubleToCString,1,node.tracing.anonymous_namespace_2.DoubleToCString,string node.tracing.anonymous_namespace_2.DoubleToCString (double),tracing\traced_value.cc,"std::string DoubleToCString(double v) {
  switch (FPCLASSIFY_NAMESPACE::fpclassify(v)) {
    case FP_NAN: return ""\""NaN\"""";
    case FP_INFINITE: return (v < 0.0 ? ""\""-Infinity\"""" : ""\""Infinity\"""");
    case FP_ZERO: return ""0"";
    default:
      // This is a far less sophisticated version than the one used inside v8.
      std::ostringstream stream;
      stream.imbue(std::locale::classic());  // Ignore current locale
      stream << v;
      return stream.str();
  }
}",89.0,101.0,1.0,10.0,13.0,8,4,12,8,0,0,2,2,0,0,,0,0,2,1,1,string
5205,293528,Create,1,node.tracing.TracedValue.Create,unique_ptr<TracedValue> node.tracing.TracedValue.Create (),tracing\traced_value.cc,"std::unique_ptr<TracedValue> TracedValue::Create() {
  return std::unique_ptr<TracedValue>(new TracedValue(false));
}",105.0,107.0,1.0,1.0,3.0,4,4,3,2,0,0,1,1,0,0,,0,0,0,0,0,unique_ptr<TracedValue>
5206,293542,CreateArray,1,node.tracing.TracedValue.CreateArray,unique_ptr<TracedValue> node.tracing.TracedValue.CreateArray (),tracing\traced_value.cc,"std::unique_ptr<TracedValue> TracedValue::CreateArray() {
  return std::unique_ptr<TracedValue>(new TracedValue(true));
}",109.0,111.0,1.0,1.0,3.0,4,4,3,2,0,0,1,1,0,0,,0,0,0,0,0,unique_ptr<TracedValue>
5207,293556,TracedValue,1,node.tracing.TracedValue.TracedValue,ANY node.tracing.TracedValue.TracedValue (bool),tracing\traced_value.cc,"TracedValue::TracedValue(bool root_is_array) :
    first_item_(true), root_is_array_(root_is_array) {}",113.0,114.0,1.0,55.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ANY
5208,293561,SetInteger,1,node.tracing.TracedValue.SetInteger,"void node.tracing.TracedValue.SetInteger (char*,int)",tracing\traced_value.cc,"void TracedValue::SetInteger(const char* name, int value) {
  WriteName(name);
  data_ += std::to_string(value);
}",116.0,119.0,1.0,1.0,4.0,2,2,4,4,0,1,1,1,0,0,,0,1,4,2,2,void
5209,293576,SetDouble,1,node.tracing.TracedValue.SetDouble,"void node.tracing.TracedValue.SetDouble (char*,double)",tracing\traced_value.cc,"void TracedValue::SetDouble(const char* name, double value) {
  WriteName(name);
  data_ += DoubleToCString(value);
}",121.0,124.0,1.0,1.0,4.0,1,1,3,3,0,1,1,1,0,0,,0,1,4,2,2,void
5210,293588,SetBoolean,1,node.tracing.TracedValue.SetBoolean,"void node.tracing.TracedValue.SetBoolean (char*,bool)",tracing\traced_value.cc,"void TracedValue::SetBoolean(const char* name, bool value) {
  WriteName(name);
  data_ += value ? ""true"" : ""false"";
}",126.0,129.0,1.0,1.0,4.0,2,2,3,3,0,1,1,1,0,0,,0,1,4,2,2,void
5211,293602,SetNull,1,node.tracing.TracedValue.SetNull,void node.tracing.TracedValue.SetNull (char*),tracing\traced_value.cc,"void TracedValue::SetNull(const char* name) {
  WriteName(name);
  data_ += ""null"";
}",131.0,134.0,1.0,1.0,4.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
5212,293612,SetString,1,node.tracing.TracedValue.SetString,"void node.tracing.TracedValue.SetString (char*,char*)",tracing\traced_value.hpp,"void SetString(const char* name, const std::string& value) {
    SetString(name, value.c_str());
  }",35.0,37.0,3.0,3.0,3.0,1,1,3,3,0,1,1,1,0,0,,0,1,4,2,2,void
5213,293624,BeginDictionary,1,node.tracing.TracedValue.BeginDictionary,void node.tracing.TracedValue.BeginDictionary (char*),tracing\traced_value.cc,"void TracedValue::BeginDictionary() {
  WriteComma();
  data_ += '{';
  first_item_ = true;
}",178.0,182.0,1.0,1.0,5.0,2,2,3,3,0,2,1,1,0,0,,0,2,0,0,0,void
5214,293637,BeginArray,1,node.tracing.TracedValue.BeginArray,void node.tracing.TracedValue.BeginArray (char*),tracing\traced_value.cc,"void TracedValue::BeginArray() {
  WriteComma();
  data_ += '[';
  first_item_ = true;
}",184.0,188.0,1.0,1.0,5.0,2,2,3,3,0,2,1,1,0,0,,0,2,0,0,0,void
5215,293650,AppendInteger,1,node.tracing.TracedValue.AppendInteger,void node.tracing.TracedValue.AppendInteger (int),tracing\traced_value.cc,"void TracedValue::AppendInteger(int value) {
  WriteComma();
  data_ += std::to_string(value);
}",153.0,156.0,1.0,1.0,4.0,2,2,3,3,0,1,1,1,0,0,,0,1,2,1,1,void
5216,293663,AppendDouble,1,node.tracing.TracedValue.AppendDouble,void node.tracing.TracedValue.AppendDouble (double),tracing\traced_value.cc,"void TracedValue::AppendDouble(double value) {
  WriteComma();
  data_ += DoubleToCString(value);
}",158.0,161.0,1.0,1.0,4.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
5217,293673,AppendBoolean,1,node.tracing.TracedValue.AppendBoolean,void node.tracing.TracedValue.AppendBoolean (bool),tracing\traced_value.cc,"void TracedValue::AppendBoolean(bool value) {
  WriteComma();
  data_ += value ? ""true"" : ""false"";
}",163.0,166.0,1.0,1.0,4.0,2,2,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
5218,293685,AppendNull,1,node.tracing.TracedValue.AppendNull,void node.tracing.TracedValue.AppendNull (),tracing\traced_value.cc,"void TracedValue::AppendNull() {
  WriteComma();
  data_ += ""null"";
}",168.0,171.0,1.0,1.0,4.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,void
5219,293693,AppendString,1,node.tracing.TracedValue.AppendString,void node.tracing.TracedValue.AppendString (char*),tracing\traced_value.hpp,void AppendString(const std::string& value) { AppendString(value.c_str()); },46.0,46.0,3.0,78.0,1.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
5220,293725,EndDictionary,1,node.tracing.TracedValue.EndDictionary,void node.tracing.TracedValue.EndDictionary (),tracing\traced_value.cc,"void TracedValue::EndDictionary() {
  data_ += '}';
  first_item_ = false;
}",190.0,193.0,1.0,1.0,4.0,2,2,2,2,0,2,1,1,0,0,,0,2,0,0,0,void
5221,293735,EndArray,1,node.tracing.TracedValue.EndArray,void node.tracing.TracedValue.EndArray (),tracing\traced_value.cc,"void TracedValue::EndArray() {
  data_ += ']';
  first_item_ = false;
}",195.0,198.0,1.0,1.0,4.0,2,2,2,2,0,2,1,1,0,0,,0,2,0,0,0,void
5222,293745,WriteComma,1,node.tracing.TracedValue.WriteComma,void node.tracing.TracedValue.WriteComma (),tracing\traced_value.cc,"void TracedValue::WriteComma() {
  if (first_item_) {
    first_item_ = false;
  } else {
    data_ += ',';
  }
}",200.0,206.0,1.0,1.0,7.0,1,1,2,1,0,2,2,2,1,0,,0,2,0,0,0,void
5223,293760,WriteName,1,node.tracing.TracedValue.WriteName,void node.tracing.TracedValue.WriteName (char*),tracing\traced_value.cc,"void TracedValue::WriteName(const char* name) {
  WriteComma();
  data_ += '""';
  data_ += name;
  data_ += ""\"":"";
}",208.0,213.0,1.0,1.0,6.0,3,1,4,2,0,3,1,1,0,0,,0,3,2,1,1,void
5224,293775,AppendAsTraceFormat,1,node.tracing.TracedValue.AppendAsTraceFormat,void node.tracing.TracedValue.AppendAsTraceFormat (ANY*),tracing\traced_value.cc,"void TracedValue::AppendAsTraceFormat(std::string* out) const {
  *out += root_is_array_ ? '[' : '{';
  *out += data_;
  *out += root_is_array_ ? ']' : '}';
}",215.0,219.0,1.0,1.0,5.0,8,3,6,3,0,3,1,1,0,0,,0,3,2,1,1,void
5225,293818,~TracedValue,1,node.tracing.TracedValue.~TracedValue,ANY node.tracing.TracedValue.~TracedValue (),tracing\traced_value.hpp,~TracedValue() override = default;,21.0,21.0,3.0,36.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
5226,293941,operator =,1,node.tracing.TracedValue.operator =,TracedValue node.tracing.TracedValue.operator = (TracedValue),tracing\traced_value.hpp,TracedValue& operator=(const TracedValue&) = delete;,54.0,54.0,3.0,54.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,TracedValue
5227,293985,RegisterExternalReferences,1,node.TTYWrap.RegisterExternalReferences,void node.TTYWrap.RegisterExternalReferences (ExternalReferenceRegistry*),tty_wrap.cc,"void TTYWrap::RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  registry->Register(New);
  registry->Register(GetWindowSize);
  registry->Register(SetRawMode);
  registry->Register(IsTTY);
}",45.0,50.0,1.0,1.0,6.0,4,1,8,5,0,0,1,1,0,0,,0,0,2,1,1,void
5228,294010,Initialize,1,node.TTYWrap.Initialize,"void node.TTYWrap.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)",tty_wrap.cc,"void TTYWrap::Initialize(Local<Object> target,
                         Local<Value> unused,
                         Local<Context> context,
                         void* priv) {
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  Local<String> ttyString = FIXED_ONE_BYTE_STRING(env->isolate(), ""TTY"");

  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, New);
  t->SetClassName(ttyString);
  t->InstanceTemplate()->SetInternalFieldCount(StreamBase::kInternalFieldCount);
  t->Inherit(LibuvStreamWrap::GetConstructorTemplate(env));

  SetProtoMethodNoSideEffect(
      isolate, t, ""getWindowSize"", TTYWrap::GetWindowSize);
  SetProtoMethod(isolate, t, ""setRawMode"", SetRawMode);

  SetMethodNoSideEffect(context, target, ""isTTY"", IsTTY);

  Local<Value> func;
  if (t->GetFunction(context).ToLocal(&func) &&
      target->Set(context, ttyString, func).IsJust()) {
    env->set_tty_constructor_template(t);
  }
}",52.0,77.0,1.0,1.0,26.0,27,7,42,18,0,0,2,2,0,0,,0,0,8,4,4,void
5229,294128,IsTTY,1,node.TTYWrap.IsTTY,void node.TTYWrap.IsTTY (FunctionCallbackInfo<Value>),tty_wrap.cc,"void TTYWrap::IsTTY(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  int fd;
  if (!args[0]->Int32Value(env->context()).To(&fd)) return;
  CHECK_GE(fd, 0);
  bool rc = uv_guess_handle(fd) == UV_TTY;
  args.GetReturnValue().Set(rc);
}",80.0,87.0,1.0,1.0,8.0,12,7,12,6,0,0,2,2,0,0,,0,0,2,1,1,void
5230,294179,GetWindowSize,1,node.TTYWrap.GetWindowSize,void node.TTYWrap.GetWindowSize (FunctionCallbackInfo<Value>),tty_wrap.cc,"void TTYWrap::GetWindowSize(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  TTYWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));
  CHECK(args[0]->IsArray());

  int width, height;
  int err = uv_tty_get_winsize(&wrap->handle_, &width, &height);

  if (err == 0) {
    Local<Array> a = args[0].As<Array>();
    a->Set(env->context(), 0, Integer::New(env->isolate(), width)).Check();
    a->Set(env->context(), 1, Integer::New(env->isolate(), height)).Check();
  }

  args.GetReturnValue().Set(err);
}",90.0,109.0,1.0,1.0,20.0,31,8,29,12,0,0,2,2,0,0,,0,0,2,1,1,void
5231,294296,SetRawMode,1,node.TTYWrap.SetRawMode,void node.TTYWrap.SetRawMode (FunctionCallbackInfo<Value>),tty_wrap.cc,"void TTYWrap::SetRawMode(const FunctionCallbackInfo<Value>& args) {
  TTYWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));
  int err = uv_tty_set_mode(&wrap->handle_, args[0]->IsTrue());
  args.GetReturnValue().Set(err);
}",112.0,119.0,1.0,1.0,8.0,11,5,9,4,0,0,1,1,0,0,,0,0,2,1,1,void
5232,294339,New,1,node.TTYWrap.New,void node.TTYWrap.New (FunctionCallbackInfo<Value>),tty_wrap.cc,"void TTYWrap::New(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  // This constructor should not be exposed to public javascript.
  // Therefore we assert that we are not trying to call this as a
  // normal function.
  CHECK(args.IsConstructCall());

  int fd;
  if (!args[0]->Int32Value(env->context()).To(&fd)) return;
  CHECK_GE(fd, 0);

  int err = 0;
  new TTYWrap(env, args.This(), fd, &err);
  if (err != 0) {
    env->CollectUVExceptionInfo(args[1], err, ""uv_tty_init"");
    args.GetReturnValue().SetUndefined();
  }
}",122.0,140.0,1.0,1.0,19.0,18,8,19,6,0,0,3,3,0,0,,0,0,2,1,1,void
5233,294415,TTYWrap,1,node.TTYWrap.TTYWrap,"ANY node.TTYWrap.TTYWrap (Environment*,Local<Object>,int,int*)",tty_wrap.cc,"TTYWrap::TTYWrap(Environment* env,
                 Local<Object> object,
                 int fd,
                 int* init_err)
    : LibuvStreamWrap(env,
                      object,
                      reinterpret_cast<uv_stream_t*>(&handle_),
                      AsyncWrap::PROVIDER_TTYWRAP) {
  *init_err = uv_tty_init(env->event_loop(), &handle_, fd, 0);
  set_fd(fd);
  if (*init_err != 0)
    MarkAsUninitialized();
}",143.0,155.0,1.0,1.0,13.0,6,5,6,4,0,0,2,2,0,0,,0,0,8,4,4,ANY
5234,294455,<lambda>0,1,node.UDPWrap.Send.<lambda>0,"ANY node.UDPWrap.Send.<lambda>0 (uv_udp_send_t*,int)",udp_wrap.cc,"[](uv_udp_send_t* req, int status) {
          UDPWrap* self = ContainerOf(&UDPWrap::handle_, req->handle);
          self->listener()->OnSendDone(
              ReqWrap<uv_udp_send_t>::from_req(req), status);
        }",601.0,605.0,24.0,9.0,5.0,9,6,8,6,0,0,1,1,0,0,,0,0,4,2,2,ANY
5235,294512,SetLibuvInt32,1,node.anonymous_namespace_1.SetLibuvInt32,"void node.anonymous_namespace_1.SetLibuvInt32<int(*)(uv_udp_t*, int)> (FunctionCallbackInfo<Value>)",udp_wrap.cc,"void SetLibuvInt32(const FunctionCallbackInfo<Value>& args) {
  UDPWrap* wrap = Unwrap<UDPWrap>(args.Holder());
  if (wrap == nullptr) {
    args.GetReturnValue().Set(UV_EBADF);
    return;
  }
  Environment* env = wrap->env();
  CHECK_EQ(args.Length(), 1);
  int flag;
  if (!args[0]->Int32Value(env->context()).To(&flag)) {
    return;
  }
  int err = fn(wrap->GetLibuvHandle(), flag);
  args.GetReturnValue().Set(err);
}",57.0,71.0,1.0,1.0,15.0,20,9,18,8,0,0,3,3,0,0,,0,0,2,1,1,void
5236,294593,SendWrap,1,node.SendWrap.SendWrap,"ANY node.SendWrap.SendWrap (Environment*,Local<Object>,bool)",udp_wrap.cc,"SendWrap::SendWrap(Environment* env,
                   Local<Object> req_wrap_obj,
                   bool have_callback)
    : ReqWrap(env, req_wrap_obj, AsyncWrap::PROVIDER_UDPSENDWRAP),
      have_callback_(have_callback) {
}",89.0,94.0,1.0,1.0,6.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,ANY
5237,294600,have_callback,1,node.SendWrap.have_callback,bool node.SendWrap.have_callback (),udp_wrap.cc,"bool SendWrap::have_callback() const {
  return have_callback_;
}",97.0,99.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,bool
5238,294619,~UDPListener,1,node.UDPListener.~UDPListener,ANY node.UDPListener.~UDPListener (),udp_wrap.cc,"UDPListener::~UDPListener() {
  if (wrap_ != nullptr)
    wrap_->set_listener(nullptr);
}",101.0,104.0,1.0,1.0,4.0,2,2,2,1,0,0,2,2,0,0,,0,0,0,0,0,ANY
5239,294633,~UDPWrapBase,1,node.UDPWrapBase.~UDPWrapBase,ANY node.UDPWrapBase.~UDPWrapBase (),udp_wrap.cc,"UDPWrapBase::~UDPWrapBase() {
  set_listener(nullptr);
}",106.0,108.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,ANY
5240,294639,listener,1,node.UDPWrapBase.listener,UDPListener node.UDPWrapBase.listener (),udp_wrap.cc,"UDPListener* UDPWrapBase::listener() const {
  CHECK_NOT_NULL(listener_);
  return listener_;
}",110.0,113.0,1.0,1.0,4.0,0,0,1,1,0,0,1,1,0,0,,0,0,0,0,0,UDPListener
5241,294646,set_listener,1,node.UDPWrapBase.set_listener,void node.UDPWrapBase.set_listener (UDPListener*),udp_wrap.cc,"void UDPWrapBase::set_listener(UDPListener* listener) {
  if (listener_ != nullptr)
    listener_->wrap_ = nullptr;
  listener_ = listener;
  if (listener_ != nullptr) {
    CHECK_NULL(listener_->wrap_);
    listener_->wrap_ = this;
  }
}",115.0,123.0,1.0,1.0,9.0,8,3,7,2,0,0,3,3,0,0,,0,0,2,1,1,void
5242,294678,FromObject,1,node.UDPWrapBase.FromObject,UDPWrapBase node.UDPWrapBase.FromObject (Local<Object>),udp_wrap.cc,"UDPWrapBase* UDPWrapBase::FromObject(Local<Object> obj) {
  CHECK_GT(obj->InternalFieldCount(), UDPWrapBase::kUDPWrapBaseField);
  return static_cast<UDPWrapBase*>(
      obj->GetAlignedPointerFromInternalField(UDPWrapBase::kUDPWrapBaseField));
}",125.0,129.0,1.0,1.0,5.0,5,3,4,2,0,0,1,1,0,0,,0,0,2,1,1,UDPWrapBase
5243,294701,AddMethods,1,node.UDPWrapBase.AddMethods,"void node.UDPWrapBase.AddMethods (Environment*,Local<FunctionTemplate>)",udp_wrap.cc,"void UDPWrapBase::AddMethods(Environment* env, Local<FunctionTemplate> t) {
  SetProtoMethod(env->isolate(), t, ""recvStart"", RecvStart);
  SetProtoMethod(env->isolate(), t, ""recvStop"", RecvStop);
}",131.0,134.0,1.0,1.0,4.0,2,1,6,4,0,0,1,1,0,0,,0,0,4,2,2,void
5244,294723,UDPWrap,1,node.UDPWrap.UDPWrap,"ANY node.UDPWrap.UDPWrap (Environment*,Local<Object>)",udp_wrap.cc,"UDPWrap::UDPWrap(Environment* env, Local<Object> object)
    : HandleWrap(env,
                 object,
                 reinterpret_cast<uv_handle_t*>(&handle_),
                 AsyncWrap::PROVIDER_UDPWRAP) {
  object->SetAlignedPointerInInternalField(
      UDPWrapBase::kUDPWrapBaseField, static_cast<UDPWrapBase*>(this));

  int r = uv_udp_init(env->event_loop(), &handle_);
  CHECK_EQ(r, 0);  // can't fail anyway

  set_listener(this);
}",136.0,148.0,1.0,1.0,13.0,6,5,6,5,0,0,1,1,0,0,,0,0,4,2,2,ANY
5245,294754,Initialize,1,node.UDPWrap.Initialize,"void node.UDPWrap.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)",udp_wrap.cc,"void UDPWrap::Initialize(Local<Object> target,
                         Local<Value> unused,
                         Local<Context> context,
                         void* priv) {
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, New);
  t->InstanceTemplate()->SetInternalFieldCount(
      UDPWrapBase::kInternalFieldCount);

  enum PropertyAttribute attributes =
      static_cast<PropertyAttribute>(ReadOnly | DontDelete);

  Local<Signature> signature = Signature::New(isolate, t);

  Local<FunctionTemplate> get_fd_templ =
      FunctionTemplate::New(isolate, UDPWrap::GetFD, Local<Value>(), signature);

  t->PrototypeTemplate()->SetAccessorProperty(env->fd_string(),
                                              get_fd_templ,
                                              Local<FunctionTemplate>(),
                                              attributes);

  UDPWrapBase::AddMethods(en...",151.0,230.0,1.0,2.0,80.0,110,7,192,52,0,0,1,1,0,0,,0,0,8,4,4,void
5246,295235,New,1,node.UDPWrap.New,void node.UDPWrap.New (FunctionCallbackInfo<Value>),udp_wrap.cc,"void UDPWrap::New(const FunctionCallbackInfo<Value>& args) {
  CHECK(args.IsConstructCall());
  Environment* env = Environment::GetCurrent(args);
  new UDPWrap(env, args.This());
}",233.0,237.0,1.0,1.0,5.0,5,3,7,4,0,0,1,1,0,0,,0,0,2,1,1,void
5247,295260,GetFD,1,node.UDPWrap.GetFD,void node.UDPWrap.GetFD (FunctionCallbackInfo<Value>),udp_wrap.cc,"void UDPWrap::GetFD(const FunctionCallbackInfo<Value>& args) {
  int fd = UV_EBADF;
#if !defined(_WIN32)
  UDPWrap* wrap = Unwrap<UDPWrap>(args.This());
  if (wrap != nullptr)
    uv_fileno(reinterpret_cast<uv_handle_t*>(&wrap->handle_), &fd);
#endif
  args.GetReturnValue().Set(fd);
}",240.0,248.0,1.0,1.0,9.0,12,8,11,6,0,0,2,2,0,0,,0,0,2,1,1,void
5248,295302,sockaddr_for_family,1,node.sockaddr_for_family,"int node.sockaddr_for_family (int,char*,short unsigned,sockaddr_storage*)",udp_wrap.cc,"int sockaddr_for_family(int address_family,
                        const char* address,
                        const unsigned short port,
                        struct sockaddr_storage* addr) {
  switch (address_family) {
    case AF_INET:
      return uv_ip4_addr(address, port, reinterpret_cast<sockaddr_in*>(addr));
    case AF_INET6:
      return uv_ip6_addr(address, port, reinterpret_cast<sockaddr_in6*>(addr));
    default:
      UNREACHABLE(""unexpected address family"");
  }
}",250.0,262.0,1.0,1.0,13.0,2,1,9,6,0,0,2,2,0,0,,0,0,8,4,4,int
5249,295334,DoBind,1,node.UDPWrap.DoBind,"void node.UDPWrap.DoBind (FunctionCallbackInfo<Value>,int)",udp_wrap.cc,"void UDPWrap::DoBind(const FunctionCallbackInfo<Value>& args, int family) {
  UDPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));

  // bind(ip, port, flags)
  CHECK_EQ(args.Length(), 3);

  node::Utf8Value address(args.GetIsolate(), args[0]);
  Local<Context> ctx = args.GetIsolate()->GetCurrentContext();
  uint32_t port, flags;
  if (!args[1]->Uint32Value(ctx).To(&port) ||
      !args[2]->Uint32Value(ctx).To(&flags))
    return;
  struct sockaddr_storage addr_storage;
  int err = sockaddr_for_family(family, address.out(), port, &addr_storage);
  if (err == 0) {
    err = uv_udp_bind(&wrap->handle_,
                      reinterpret_cast<const sockaddr*>(&addr_storage),
                      flags);
  }

  if (err == 0)
    wrap->listener()->OnAfterBind();

  args.GetReturnValue().Set(err);
}",264.0,291.0,1.0,1.0,28.0,37,11,31,12,0,0,4,4,0,0,,0,0,4,2,2,void
5250,295466,DoConnect,1,node.UDPWrap.DoConnect,"void node.UDPWrap.DoConnect (FunctionCallbackInfo<Value>,int)",udp_wrap.cc,"void UDPWrap::DoConnect(const FunctionCallbackInfo<Value>& args, int family) {
  UDPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));

  CHECK_EQ(args.Length(), 2);

  node::Utf8Value address(args.GetIsolate(), args[0]);
  Local<Context> ctx = args.GetIsolate()->GetCurrentContext();
  uint32_t port;
  if (!args[1]->Uint32Value(ctx).To(&port))
    return;
  struct sockaddr_storage addr_storage;
  int err = sockaddr_for_family(family, address.out(), port, &addr_storage);
  if (err == 0) {
    err = uv_udp_connect(&wrap->handle_,
                         reinterpret_cast<const sockaddr*>(&addr_storage));
  }

  args.GetReturnValue().Set(err);
}",294.0,315.0,1.0,1.0,22.0,28,10,25,11,0,0,3,3,0,0,,0,0,4,2,2,void
5251,295570,Open,1,node.UDPWrap.Open,void node.UDPWrap.Open (FunctionCallbackInfo<Value>),udp_wrap.cc,"void UDPWrap::Open(const FunctionCallbackInfo<Value>& args) {
  UDPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));
  CHECK(args[0]->IsNumber());
  int fd = static_cast<int>(args[0].As<Integer>()->Value());
  int err = uv_udp_open(&wrap->handle_, fd);

  args.GetReturnValue().Set(err);
}",318.0,328.0,1.0,1.0,11.0,16,6,12,5,0,0,1,1,0,0,,0,0,2,1,1,void
5252,295629,Bind,1,node.UDPWrap.Bind,void node.UDPWrap.Bind (FunctionCallbackInfo<Value>),udp_wrap.cc,"void UDPWrap::Bind(const FunctionCallbackInfo<Value>& args) {
  DoBind(args, AF_INET);
}",331.0,333.0,1.0,1.0,3.0,0,0,2,2,0,0,1,1,0,0,,0,0,2,1,1,void
5253,295637,Bind6,1,node.UDPWrap.Bind6,void node.UDPWrap.Bind6 (FunctionCallbackInfo<Value>),udp_wrap.cc,"void UDPWrap::Bind6(const FunctionCallbackInfo<Value>& args) {
  DoBind(args, AF_INET6);
}",336.0,338.0,1.0,1.0,3.0,0,0,2,2,0,0,1,1,0,0,,0,0,2,1,1,void
5254,295645,BufferSize,1,node.UDPWrap.BufferSize,void node.UDPWrap.BufferSize (FunctionCallbackInfo<Value>),udp_wrap.cc,"void UDPWrap::BufferSize(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  UDPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));

  CHECK(args[0]->IsUint32());
  CHECK(args[1]->IsBoolean());
  bool is_recv = args[1].As<Boolean>()->Value();
  const char* uv_func_name = is_recv ? ""uv_recv_buffer_size"" :
                                       ""uv_send_buffer_size"";

  if (!args[0]->IsInt32()) {
    env->CollectUVExceptionInfo(args[2], UV_EINVAL, uv_func_name);
    return args.GetReturnValue().SetUndefined();
  }

  uv_handle_t* handle = reinterpret_cast<uv_handle_t*>(&wrap->handle_);
  int size = static_cast<int>(args[0].As<Uint32>()->Value());
  int err;

  if (is_recv)
    err = uv_recv_buffer_size(handle, &size);
  else
    err = uv_send_buffer_size(handle, &size);

  if (err != 0) {
    env->CollectUVExceptionInfo(args[2], err, uv_func_na...",341.0,374.0,1.0,1.0,34.0,41,9,35,11,0,0,4,4,0,0,,0,0,2,1,1,void
5255,295804,Connect,1,node.UDPWrap.Connect,void node.UDPWrap.Connect (FunctionCallbackInfo<Value>),udp_wrap.cc,"void UDPWrap::Connect(const FunctionCallbackInfo<Value>& args) {
  DoConnect(args, AF_INET);
}",377.0,379.0,1.0,1.0,3.0,0,0,2,2,0,0,1,1,0,0,,0,0,2,1,1,void
5256,295812,Connect6,1,node.UDPWrap.Connect6,void node.UDPWrap.Connect6 (FunctionCallbackInfo<Value>),udp_wrap.cc,"void UDPWrap::Connect6(const FunctionCallbackInfo<Value>& args) {
  DoConnect(args, AF_INET6);
}",382.0,384.0,1.0,1.0,3.0,0,0,2,2,0,0,1,1,0,0,,0,0,2,1,1,void
5257,295820,Disconnect,1,node.UDPWrap.Disconnect,void node.UDPWrap.Disconnect (FunctionCallbackInfo<Value>),udp_wrap.cc,"void UDPWrap::Disconnect(const FunctionCallbackInfo<Value>& args) {
  UDPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));

  CHECK_EQ(args.Length(), 0);

  int err = uv_udp_connect(&wrap->handle_, nullptr);

  args.GetReturnValue().Set(err);
}",387.0,398.0,1.0,1.0,12.0,10,4,9,4,0,0,1,1,0,0,,0,0,2,1,1,void
5258,295864,SetMulticastInterface,1,node.UDPWrap.SetMulticastInterface,void node.UDPWrap.SetMulticastInterface (FunctionCallbackInfo<Value>),udp_wrap.cc,"void UDPWrap::SetMulticastInterface(const FunctionCallbackInfo<Value>& args) {
  UDPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));

  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsString());

  Utf8Value iface(args.GetIsolate(), args[0]);

  const char* iface_cstr = *iface;

  int err = uv_udp_set_multicast_interface(&wrap->handle_, iface_cstr);
  args.GetReturnValue().Set(err);
}",400.0,415.0,1.0,1.0,16.0,16,6,15,6,0,0,1,1,0,0,,0,0,2,1,1,void
5259,295929,SetMembership,1,node.UDPWrap.SetMembership,"void node.UDPWrap.SetMembership (FunctionCallbackInfo<Value>,uv_membership)",udp_wrap.cc,"void UDPWrap::SetMembership(const FunctionCallbackInfo<Value>& args,
                            uv_membership membership) {
  UDPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));

  CHECK_EQ(args.Length(), 2);

  node::Utf8Value address(args.GetIsolate(), args[0]);
  node::Utf8Value iface(args.GetIsolate(), args[1]);

  const char* iface_cstr = *iface;
  if (args[1]->IsUndefined() || args[1]->IsNull()) {
      iface_cstr = nullptr;
  }

  int err = uv_udp_set_membership(&wrap->handle_,
                                  *address,
                                  iface_cstr,
                                  membership);
  args.GetReturnValue().Set(err);
}",417.0,439.0,1.0,1.0,23.0,23,7,21,8,0,0,2,2,0,0,,0,0,4,2,2,void
5260,296018,AddMembership,1,node.UDPWrap.AddMembership,void node.UDPWrap.AddMembership (FunctionCallbackInfo<Value>),udp_wrap.cc,"void UDPWrap::AddMembership(const FunctionCallbackInfo<Value>& args) {
  SetMembership(args, UV_JOIN_GROUP);
}",442.0,444.0,1.0,1.0,3.0,0,0,2,2,0,0,1,1,0,0,,0,0,2,1,1,void
5261,296026,DropMembership,1,node.UDPWrap.DropMembership,void node.UDPWrap.DropMembership (FunctionCallbackInfo<Value>),udp_wrap.cc,"void UDPWrap::DropMembership(const FunctionCallbackInfo<Value>& args) {
  SetMembership(args, UV_LEAVE_GROUP);
}",447.0,449.0,1.0,1.0,3.0,0,0,2,2,0,0,1,1,0,0,,0,0,2,1,1,void
5262,296034,SetSourceMembership,1,node.UDPWrap.SetSourceMembership,"void node.UDPWrap.SetSourceMembership (FunctionCallbackInfo<Value>,uv_membership)",udp_wrap.cc,"void UDPWrap::SetSourceMembership(const FunctionCallbackInfo<Value>& args,
                                  uv_membership membership) {
  UDPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));

  CHECK_EQ(args.Length(), 3);

  node::Utf8Value source_address(args.GetIsolate(), args[0]);
  node::Utf8Value group_address(args.GetIsolate(), args[1]);
  node::Utf8Value iface(args.GetIsolate(), args[2]);

  if (*iface == nullptr) return;
  const char* iface_cstr = *iface;
  if (args[2]->IsUndefined() || args[2]->IsNull()) {
    iface_cstr = nullptr;
  }

  int err = uv_udp_set_source_membership(&wrap->handle_,
                                         *group_address,
                                         iface_cstr,
                                         *source_address,
                                         membership);
  args.GetReturnValue().Set(err);
}",451.0,476.0,1.0,1.0,26.0,28,8,25,9,0,0,3,3,0,0,,0,0,4,2,2,void
5263,296141,AddSourceSpecificMembership,1,node.UDPWrap.AddSourceSpecificMembership,void node.UDPWrap.AddSourceSpecificMembership (FunctionCallbackInfo<Value>),udp_wrap.cc,"void UDPWrap::AddSourceSpecificMembership(
  const FunctionCallbackInfo<Value>& args) {
  SetSourceMembership(args, UV_JOIN_GROUP);
}",478.0,481.0,1.0,1.0,4.0,0,0,2,2,0,0,1,1,0,0,,0,0,2,1,1,void
5264,296149,DropSourceSpecificMembership,1,node.UDPWrap.DropSourceSpecificMembership,void node.UDPWrap.DropSourceSpecificMembership (FunctionCallbackInfo<Value>),udp_wrap.cc,"void UDPWrap::DropSourceSpecificMembership(
  const FunctionCallbackInfo<Value>& args) {
  SetSourceMembership(args, UV_LEAVE_GROUP);
}",484.0,487.0,1.0,1.0,4.0,0,0,2,2,0,0,1,1,0,0,,0,0,2,1,1,void
5265,296157,DoSend,1,node.UDPWrap.DoSend,"void node.UDPWrap.DoSend (FunctionCallbackInfo<Value>,int)",udp_wrap.cc,"void UDPWrap::DoSend(const FunctionCallbackInfo<Value>& args, int family) {
  Environment* env = Environment::GetCurrent(args);

  UDPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap,
                          args.Holder(),
                          args.GetReturnValue().Set(UV_EBADF));

  CHECK(args.Length() == 4 || args.Length() == 6);
  CHECK(args[0]->IsObject());
  CHECK(args[1]->IsArray());
  CHECK(args[2]->IsUint32());

  bool sendto = args.Length() == 6;
  if (sendto) {
    // send(req, list, list.length, port, address, hasCallback)
    CHECK(args[3]->IsUint32());
    CHECK(args[4]->IsString());
    CHECK(args[5]->IsBoolean());
  } else {
    // send(req, list, list.length, hasCallback)
    CHECK(args[3]->IsBoolean());
  }

  Local<Array> chunks = args[1].As<Array>();
  // it is faster to fetch the length of the
  // array in js-land
  size_t count = args[2].As<Uint32>()->Value();

  MaybeStackBuffer<uv_buf_t, 16> bufs(count);

  // construct uv_buf_t array
  for (size_t i = 0; i...",490.0,554.0,1.0,1.0,65.0,89,14,76,24,0,0,7,9,0,0,,0,0,4,2,2,void
5266,296469,Send,1,node.UDPWrap.Send,"ssize_t node.UDPWrap.Send (uv_buf_t*,size_t,sockaddr*)",udp_wrap.cc,"void UDPWrap::Send(const FunctionCallbackInfo<Value>& args) {
  DoSend(args, AF_INET);
}",623.0,625.0,1.0,1.0,3.0,25,11,33,14,0,0,8,11,0,0,,0,0,2,1,1,void
5267,296648,CreateSendWrap,1,node.UDPWrap.CreateSendWrap,ReqWrap<uv_udp_send_t> node.UDPWrap.CreateSendWrap (size_t),udp_wrap.cc,"ReqWrap<uv_udp_send_t>* UDPWrap::CreateSendWrap(size_t msg_size) {
  SendWrap* req_wrap = new SendWrap(env(),
                                    current_send_req_wrap_,
                                    current_send_has_callback_);
  req_wrap->msg_size = msg_size;
  return req_wrap;
}",614.0,620.0,1.0,1.0,7.0,4,3,7,5,0,1,1,1,0,0,,0,1,2,1,1,ReqWrap<uv_udp_send_t>
5268,296676,Send6,1,node.UDPWrap.Send6,void node.UDPWrap.Send6 (FunctionCallbackInfo<Value>),udp_wrap.cc,"void UDPWrap::Send6(const FunctionCallbackInfo<Value>& args) {
  DoSend(args, AF_INET6);
}",628.0,630.0,1.0,1.0,3.0,0,0,2,2,0,0,1,1,0,0,,0,0,2,1,1,void
5269,296684,GetAsyncWrap,1,node.UDPWrap.GetAsyncWrap,AsyncWrap node.UDPWrap.GetAsyncWrap (),udp_wrap.cc,"AsyncWrap* UDPWrap::GetAsyncWrap() {
  return this;
}",633.0,635.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,AsyncWrap
5270,296690,GetPeerName,1,node.UDPWrap.GetPeerName,SocketAddress node.UDPWrap.GetPeerName (),udp_wrap.cc,"SocketAddress UDPWrap::GetPeerName() {
  return SocketAddress::FromPeerName(handle_);
}",637.0,639.0,1.0,1.0,3.0,1,1,2,2,0,0,1,1,0,0,,0,0,0,0,0,SocketAddress
5271,296700,GetSockName,1,node.UDPWrap.GetSockName,SocketAddress node.UDPWrap.GetSockName (),udp_wrap.cc,"SocketAddress UDPWrap::GetSockName() {
  return SocketAddress::FromSockName(handle_);
}",641.0,643.0,1.0,1.0,3.0,1,1,2,2,0,0,1,1,0,0,,0,0,0,0,0,SocketAddress
5272,296710,RecvStart,1,node.UDPWrapBase.RecvStart,void node.UDPWrapBase.RecvStart (FunctionCallbackInfo<Value>),udp_wrap.cc,"void UDPWrapBase::RecvStart(const FunctionCallbackInfo<Value>& args) {
  UDPWrapBase* wrap = UDPWrapBase::FromObject(args.Holder());
  args.GetReturnValue().Set(wrap == nullptr ? UV_EBADF : wrap->RecvStart());
}",645.0,648.0,1.0,1.0,4.0,8,5,7,4,0,0,1,1,0,0,,0,0,2,1,1,void
5273,296742,RecvStart,1,node.UDPWrap.RecvStart,int node.UDPWrap.RecvStart (),udp_wrap.cc,"int UDPWrap::RecvStart() {
  if (IsHandleClosing()) return UV_EBADF;
  int err = uv_udp_recv_start(&handle_, OnAlloc, OnRecv);
  // UV_EALREADY means that the socket is already bound but that's okay
  if (err == UV_EALREADY)
    err = 0;
  return err;
}",650.0,657.0,1.0,1.0,8.0,4,3,9,6,0,0,3,3,0,0,,0,0,0,0,0,int
5274,296769,RecvStop,1,node.UDPWrapBase.RecvStop,void node.UDPWrapBase.RecvStop (FunctionCallbackInfo<Value>),udp_wrap.cc,"void UDPWrapBase::RecvStop(const FunctionCallbackInfo<Value>& args) {
  UDPWrapBase* wrap = UDPWrapBase::FromObject(args.Holder());
  args.GetReturnValue().Set(wrap == nullptr ? UV_EBADF : wrap->RecvStop());
}",660.0,663.0,1.0,1.0,4.0,8,5,7,4,0,0,1,1,0,0,,0,0,2,1,1,void
5275,296801,RecvStop,1,node.UDPWrap.RecvStop,int node.UDPWrap.RecvStop (),udp_wrap.cc,"int UDPWrap::RecvStop() {
  if (IsHandleClosing()) return UV_EBADF;
  return uv_udp_recv_stop(&handle_);
}",665.0,668.0,1.0,1.0,4.0,1,1,2,2,0,0,2,2,0,0,,0,0,0,0,0,int
5276,296814,OnSendDone,1,node.UDPWrap.OnSendDone,"void node.UDPWrap.OnSendDone (ReqWrap<uv_udp_send_t>*,int)",udp_wrap.cc,"void UDPWrap::OnSendDone(ReqWrap<uv_udp_send_t>* req, int status) {
  BaseObjectPtr<SendWrap> req_wrap{static_cast<SendWrap*>(req)};
  if (req_wrap->have_callback()) {
    Environment* env = req_wrap->env();
    HandleScope handle_scope(env->isolate());
    Context::Scope context_scope(env->context());
    Local<Value> arg[] = {
      Integer::New(env->isolate(), status),
      Integer::New(env->isolate(), req_wrap->msg_size),
    };
    req_wrap->MakeCallback(env->oncomplete_string(), 2, arg);
  }
}",671.0,683.0,1.0,1.0,13.0,18,7,18,8,0,0,2,2,0,0,,0,0,4,2,2,void
5277,296888,OnAlloc,1,node.UDPWrap.OnAlloc,"void node.UDPWrap.OnAlloc (uv_handle_t*,size_t,uv_buf_t*)",udp_wrap.cc,"uv_buf_t UDPWrap::OnAlloc(size_t suggested_size) {
  return env()->allocate_managed_buffer(suggested_size);
}",694.0,696.0,1.0,1.0,3.0,8,6,6,5,0,0,1,1,0,0,,0,0,2,1,1,uv_buf_t
5278,296928,OnRecv,1,node.UDPWrap.OnRecv,"void node.UDPWrap.OnRecv (uv_udp_t*,ssize_t,uv_buf_t*,sockaddr*,unsigned int)",udp_wrap.cc,"void UDPWrap::OnRecv(ssize_t nread,
                     const uv_buf_t& buf_,
                     const sockaddr* addr,
                     unsigned int flags) {
  Environment* env = this->env();
  Isolate* isolate = env->isolate();
  std::unique_ptr<BackingStore> bs = env->release_managed_buffer(buf_);
  if (nread == 0 && addr == nullptr) {
    return;
  }

  HandleScope handle_scope(isolate);
  Context::Scope context_scope(env->context());

  Local<Value> argv[] = {
      Integer::New(isolate, static_cast<int32_t>(nread)),
      object(),
      Undefined(isolate),
      Undefined(isolate)};

  if (nread < 0) {
    MakeCallback(env->onmessage_string(), arraysize(argv), argv);
    return;
  } else if (nread == 0) {
    bs = ArrayBuffer::NewBackingStore(isolate, 0);
  } else {
    CHECK_LE(static_cast<size_t>(nread), bs->ByteLength());
    bs = BackingStore::Reallocate(isolate, std::move(bs), nread);
  }

  Local<Object> address;
  {
    bool has_caught = false;
    {
      TryCat...",707.0,777.0,1.0,1.0,71.0,6,5,8,7,0,0,1,1,0,0,,0,0,8,4,4,void
5279,297265,Instantiate,1,node.UDPWrap.Instantiate,"MaybeLocal<Object> node.UDPWrap.Instantiate (Environment*,AsyncWrap*,ANY)",udp_wrap.cc,"MaybeLocal<Object> UDPWrap::Instantiate(Environment* env,
                                        AsyncWrap* parent,
                                        UDPWrap::SocketType type) {
  AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(parent);

  // If this assert fires then Initialize hasn't been called yet.
  CHECK_EQ(env->udp_constructor_function().IsEmpty(), false);
  return env->udp_constructor_function()->NewInstance(env->context());
}",779.0,787.0,1.0,1.0,9.0,5,2,4,2,0,0,1,1,0,0,,0,0,6,3,3,MaybeLocal<Object>
5280,297296,GetSendQueueSize,1,node.UDPWrap.GetSendQueueSize,void node.UDPWrap.GetSendQueueSize (FunctionCallbackInfo<Value>),udp_wrap.cc,"void UDPWrap::GetSendQueueSize(const FunctionCallbackInfo<Value>& args) {
  UDPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(
      &wrap, args.Holder(), args.GetReturnValue().Set(UV_EBADF));

  size_t size = uv_udp_get_send_queue_size(&wrap->handle_);
  args.GetReturnValue().Set(static_cast<double>(size));
}",789.0,796.0,1.0,1.0,8.0,10,5,8,4,0,0,1,1,0,0,,0,0,2,1,1,void
5281,297335,GetSendQueueCount,1,node.UDPWrap.GetSendQueueCount,void node.UDPWrap.GetSendQueueCount (FunctionCallbackInfo<Value>),udp_wrap.cc,"void UDPWrap::GetSendQueueCount(const FunctionCallbackInfo<Value>& args) {
  UDPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(
      &wrap, args.Holder(), args.GetReturnValue().Set(UV_EBADF));

  size_t count = uv_udp_get_send_queue_count(&wrap->handle_);
  args.GetReturnValue().Set(static_cast<double>(count));
}",798.0,805.0,1.0,1.0,8.0,10,5,8,4,0,0,1,1,0,0,,0,0,2,1,1,void
5282,297411,<lambda>0,1,node.ReadFileSync.<lambda>0,ANY node.ReadFileSync.<lambda>0 (),util.cc,"[&req]() {
    uv_fs_req_cleanup(&req);
  }",233.0,235.0,41.0,3.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,0,0,0,ANY
5283,297421,<lambda>1,1,node.ReadFileSync.<lambda>1,ANY node.ReadFileSync.<lambda>1 (),util.cc,"[file]() {
    uv_fs_t close_req;
    CHECK_EQ(0, uv_fs_close(nullptr, &close_req, file, nullptr));
    uv_fs_req_cleanup(&close_req);
  }",244.0,248.0,35.0,3.0,5.0,2,1,3,2,0,0,1,1,0,0,,0,0,0,0,0,ANY
5284,297486,MakeUtf8String,1,node.MakeUtf8String,"void node.MakeUtf8String<T> (Isolate*,Local<Value>,MaybeStackBuffer<T>*)",util.cc,"static void MakeUtf8String(Isolate* isolate,
                           Local<Value> value,
                           MaybeStackBuffer<T>* target) {
  Local<String> string;
  if (!value->ToString(isolate->GetCurrentContext()).ToLocal(&string)) return;

  size_t storage;
  if (!StringBytes::StorageSize(isolate, string, UTF8).To(&storage)) return;
  storage += 1;
  target->AllocateSufficientStorage(storage);
  const int flags =
      String::NO_NULL_TERMINATION | String::REPLACE_INVALID_UTF8;
  const int length =
      string->WriteUtf8(isolate, target->out(), storage, nullptr, flags);
  target->SetLengthAndZeroTerminate(length);
}",69.0,84.0,1.0,1.0,16.0,21,9,25,11,0,0,3,3,0,0,,0,0,6,3,3,void
5285,297570,Utf8Value,1,node.Utf8Value.Utf8Value,"ANY node.Utf8Value.Utf8Value (Isolate*,Local<Value>)",util.cc,"Utf8Value::Utf8Value(Isolate* isolate, Local<Value> value) {
  if (value.IsEmpty())
    return;

  MakeUtf8String(isolate, value, this);
}",86.0,91.0,1.0,1.0,6.0,1,1,3,2,0,0,2,2,0,0,,0,0,4,2,2,ANY
5286,297587,TwoByteValue,1,node.TwoByteValue.TwoByteValue,"ANY node.TwoByteValue.TwoByteValue (Isolate*,Local<Value>)",util.cc,"TwoByteValue::TwoByteValue(Isolate* isolate, Local<Value> value) {
  if (value.IsEmpty()) {
    return;
  }

  Local<String> string;
  if (!value->ToString(isolate->GetCurrentContext()).ToLocal(&string)) return;

  // Allocate enough space to include the null terminator
  const size_t storage = string->Length() + 1;
  AllocateSufficientStorage(storage);

  const int flags = String::NO_NULL_TERMINATION;
  const int length = string->Write(isolate, out(), 0, storage, flags);
  SetLengthAndZeroTerminate(length);
}",94.0,109.0,1.0,1.0,16.0,15,8,18,8,0,0,3,3,0,0,,0,0,4,2,2,ANY
5287,297653,BufferValue,1,node.BufferValue.BufferValue,"ANY node.BufferValue.BufferValue (Isolate*,Local<Value>)",util.cc,"BufferValue::BufferValue(Isolate* isolate, Local<Value> value) {
  // Slightly different take on Utf8Value. If value is a String,
  // it will return a Utf8 encoded string. If value is a Buffer,
  // it will copy the data out of the Buffer as is.
  if (value.IsEmpty()) {
    // Dereferencing this object will return nullptr.
    Invalidate();
    return;
  }

  if (value->IsString()) {
    MakeUtf8String(isolate, value, this);
  } else if (value->IsArrayBufferView()) {
    const size_t len = value.As<ArrayBufferView>()->ByteLength();
    // Leave place for the terminating '\0' byte.
    AllocateSufficientStorage(len + 1);
    value.As<ArrayBufferView>()->CopyContents(out(), len);
    SetLengthAndZeroTerminate(len);
  } else {
    Invalidate();
  }
}",111.0,132.0,1.0,1.0,22.0,2,2,4,2,0,0,3,3,0,0,,0,0,4,2,2,ANY
5288,297713,LowMemoryNotification,1,node.LowMemoryNotification,void node.LowMemoryNotification (),util.cc,"void LowMemoryNotification() {
  if (per_process::v8_initialized) {
    auto isolate = Isolate::TryGetCurrent();
    if (isolate != nullptr) {
      isolate->LowMemoryNotification();
    }
  }
}",134.0,141.0,1.0,1.0,8.0,5,4,5,3,0,0,3,4,0,0,,0,0,0,0,0,void
5289,297738,GetProcessTitle,1,node.GetProcessTitle,string node.GetProcessTitle (char*),util.cc,"std::string GetProcessTitle(const char* default_title) {
  std::string buf(16, '\0');

  for (;;) {
    const int rc = uv_get_process_title(buf.data(), buf.size());

    if (rc == 0)
      break;

    // If uv_setup_args() was not called, `uv_get_process_title()` will always
    // return `UV_ENOBUFS`, no matter the input size. Guard against a possible
    // infinite loop by limiting the buffer size.
    if (rc != UV_ENOBUFS || buf.size() >= 1024 * 1024)
      return default_title;

    buf.resize(2 * buf.size());
  }

  // Strip excess trailing nul bytes. Using strlen() here is safe,
  // uv_get_process_title() always zero-terminates the result.
  buf.resize(strlen(buf.data()));

  return buf;
}",143.0,166.0,1.0,1.0,24.0,14,7,13,4,0,0,5,6,0,0,,0,0,2,1,1,string
5290,297805,GetHumanReadableProcessName,1,node.GetHumanReadableProcessName,string node.GetHumanReadableProcessName (),util.cc,"std::string GetHumanReadableProcessName() {
  return SPrintF(""%s[%d]"", GetProcessTitle(""Node.js""), uv_os_getpid());
}",168.0,170.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,string
5291,297815,SplitString,1,node.SplitString,"vector<std::string> node.SplitString (ANY,char,bool)",util.cc,"std::vector<std::string> SplitString(const std::string& in,
                                     char delim,
                                     bool skipEmpty) {
  std::vector<std::string> out;
  if (in.empty())
    return out;
  std::istringstream in_stream(in);
  while (in_stream.good()) {
    std::string item;
    std::getline(in_stream, item, delim);
    if (item.empty() && skipEmpty) continue;
    out.emplace_back(std::move(item));
  }
  return out;
}",172.0,186.0,1.0,1.0,15.0,11,4,17,7,0,0,5,5,0,0,,0,0,6,3,3,vector<std.string>
5292,297876,ThrowErrStringTooLong,1,node.ThrowErrStringTooLong,void node.ThrowErrStringTooLong (Isolate*),util.cc,"void ThrowErrStringTooLong(Isolate* isolate) {
  isolate->ThrowException(ERR_STRING_TOO_LONG(isolate));
}",188.0,190.0,1.0,1.0,3.0,1,1,2,1,0,0,1,1,0,0,,0,0,2,1,1,void
5293,297887,GetCurrentTimeInMicroseconds,1,node.GetCurrentTimeInMicroseconds,double node.GetCurrentTimeInMicroseconds (),util.cc,"double GetCurrentTimeInMicroseconds() {
  constexpr double kMicrosecondsPerSecond = 1e6;
  uv_timeval64_t tv;
  CHECK_EQ(0, uv_gettimeofday(&tv));
  return kMicrosecondsPerSecond * tv.tv_sec + tv.tv_usec;
}",192.0,197.0,1.0,1.0,6.0,6,5,5,2,0,0,1,1,0,0,,0,0,0,0,0,double
5294,297911,WriteFileSync,1,node.WriteFileSync,"int node.WriteFileSync (char*,uv_buf_t)",util.cc,"int WriteFileSync(v8::Isolate* isolate,
                  const char* path,
                  v8::Local<v8::String> string) {
  node::Utf8Value utf8(isolate, string);
  uv_buf_t buf = uv_buf_init(utf8.out(), utf8.length());
  return WriteFileSync(path, buf);
}",223.0,229.0,1.0,1.0,7.0,15,4,23,10,0,0,3,3,0,0,,0,0,6,3,3,int
5295,298008,ReadFileSync,1,node.ReadFileSync,"int node.ReadFileSync (ANY*,char*)",util.cc,"std::vector<char> ReadFileSync(FILE* fp) {
  CHECK_EQ(ftell(fp), 0);
  int err = fseek(fp, 0, SEEK_END);
  CHECK_EQ(err, 0);
  size_t size = ftell(fp);
  CHECK_NE(size, static_cast<size_t>(-1L));
  err = fseek(fp, 0, SEEK_SET);
  CHECK_EQ(err, 0);

  std::vector<char> contents(size);
  size_t num_read = fread(contents.data(), size, 1, fp);
  CHECK_EQ(num_read, 1);
  return contents;
}",270.0,283.0,1.0,1.0,14.0,24,8,26,11,0,0,6,7,0,0,,0,0,2,1,1,vector<char>
5296,298171,LocalTime,1,node.DiagnosticFilename.LocalTime,void node.DiagnosticFilename.LocalTime (TIME_TYPE*),util.cc,"void DiagnosticFilename::LocalTime(TIME_TYPE* tm_struct) {
#ifdef _WIN32
  GetLocalTime(tm_struct);
#else  // UNIX, OSX
  struct timeval time_val;
  gettimeofday(&time_val, nullptr);
  localtime_r(&time_val.tv_sec, tm_struct);
#endif
}",285.0,293.0,1.0,1.0,9.0,3,2,3,2,0,0,1,1,0,0,,0,0,2,1,1,void
5297,298187,MakeFilename,1,node.DiagnosticFilename.MakeFilename,"string node.DiagnosticFilename.MakeFilename (uint64_t,char*,char*)",util.cc,"std::string DiagnosticFilename::MakeFilename(
    uint64_t thread_id,
    const char* prefix,
    const char* ext) {
  std::ostringstream oss;
  TIME_TYPE tm_struct;
  LocalTime(&tm_struct);
  oss << prefix;
#ifdef _WIN32
  oss << ""."" << std::setfill('0') << std::setw(4) << tm_struct.wYear;
  oss << std::setfill('0') << std::setw(2) << tm_struct.wMonth;
  oss << std::setfill('0') << std::setw(2) << tm_struct.wDay;
  oss << ""."" << std::setfill('0') << std::setw(2) << tm_struct.wHour;
  oss << std::setfill('0') << std::setw(2) << tm_struct.wMinute;
  oss << std::setfill('0') << std::setw(2) << tm_struct.wSecond;
#else  // UNIX, OSX
  oss << "".""
            << std::setfill('0')
            << std::setw(4)
            << tm_struct.tm_year + 1900;
  oss << std::setfill('0')
            << std::setw(2)
            << tm_struct.tm_mon + 1;
  oss << std::setfill('0')
            << std::setw(2)
            << tm_struct.tm_mday;
  oss << "".""
            << std::setfill('0')
            << st...",296.0,338.0,1.0,1.0,43.0,56,5,37,7,0,1,1,1,0,0,,0,1,6,3,3,string
5298,298350,NewFunctionTemplate,1,node.NewFunctionTemplate,"Local<v8::FunctionTemplate> node.NewFunctionTemplate (ANY*,ANY,ANY,ANY,ANY,ANY*)",util.cc,"Local<v8::FunctionTemplate> NewFunctionTemplate(
    v8::Isolate* isolate,
    v8::FunctionCallback callback,
    Local<v8::Signature> signature,
    v8::ConstructorBehavior behavior,
    v8::SideEffectType side_effect_type,
    const v8::CFunction* c_function) {
  return v8::FunctionTemplate::New(isolate,
                                   callback,
                                   Local<v8::Value>(),
                                   signature,
                                   0,
                                   behavior,
                                   side_effect_type,
                                   c_function);
}",340.0,355.0,1.0,1.0,16.0,2,1,9,9,0,0,1,1,0,0,,0,0,12,6,6,Local<v8.FunctionTemplate>
5299,298376,SetMethod,1,node.SetMethod,"void node.SetMethod (ANY,ANY,char*,ANY)",util.cc,"void SetMethod(v8::Isolate* isolate,
               v8::Local<v8::Template> that,
               const char* name,
               v8::FunctionCallback callback) {
  Local<v8::FunctionTemplate> t =
      NewFunctionTemplate(isolate,
                          callback,
                          Local<v8::Signature>(),
                          v8::ConstructorBehavior::kThrow,
                          v8::SideEffectType::kHasSideEffect);
  // kInternalized strings are created in the old space.
  const v8::NewStringType type = v8::NewStringType::kInternalized;
  Local<v8::String> name_string =
      v8::String::NewFromUtf8(isolate, name, type).ToLocalChecked();
  that->Set(name_string, t);
}",378.0,393.0,1.0,1.0,16.0,25,5,30,15,0,0,1,1,0,0,,0,0,8,4,4,void
5300,298529,SetFastMethod,1,node.SetFastMethod,"void node.SetFastMethod (Isolate*,Local<Template>,char*,ANY,ANY*)",util.cc,"void SetFastMethod(Local<v8::Context> context,
                   Local<v8::Object> that,
                   const char* name,
                   v8::FunctionCallback slow_callback,
                   const v8::CFunction* c_function) {
  Isolate* isolate = context->GetIsolate();
  Local<v8::Function> function =
      NewFunctionTemplate(isolate,
                          slow_callback,
                          Local<v8::Signature>(),
                          v8::ConstructorBehavior::kThrow,
                          v8::SideEffectType::kHasSideEffect,
                          c_function)
          ->GetFunction(context)
          .ToLocalChecked();
  const v8::NewStringType type = v8::NewStringType::kInternalized;
  Local<v8::String> name_string =
      v8::String::NewFromUtf8(isolate, name, type).ToLocalChecked();
  that->Set(context, name_string, function).Check();
}",414.0,433.0,1.0,1.0,20.0,19,5,25,15,0,0,1,1,0,0,,0,0,10,5,5,void
5301,298681,SetFastMethodNoSideEffect,1,node.SetFastMethodNoSideEffect,"void node.SetFastMethodNoSideEffect (ANY,ANY,char*,ANY,ANY*)",util.cc,"void SetFastMethodNoSideEffect(Isolate* isolate,
                               Local<Template> that,
                               const char* name,
                               v8::FunctionCallback slow_callback,
                               const v8::CFunction* c_function) {
  Local<v8::FunctionTemplate> t =
      NewFunctionTemplate(isolate,
                          slow_callback,
                          Local<v8::Signature>(),
                          v8::ConstructorBehavior::kThrow,
                          v8::SideEffectType::kHasNoSideEffect,
                          c_function);
  // kInternalized strings are created in the old space.
  const v8::NewStringType type = v8::NewStringType::kInternalized;
  Local<v8::String> name_string =
      v8::String::NewFromUtf8(isolate, name, type).ToLocalChecked();
  that->Set(name_string, t);
}",456.0,473.0,1.0,1.0,18.0,24,5,29,16,0,0,1,1,0,0,,0,0,10,5,5,void
5302,298833,SetMethodNoSideEffect,1,node.SetMethodNoSideEffect,"void node.SetMethodNoSideEffect (ANY,ANY,char*,ANY)",util.cc,"void SetMethodNoSideEffect(Isolate* isolate,
                           Local<v8::Template> that,
                           const char* name,
                           v8::FunctionCallback callback) {
  Local<v8::FunctionTemplate> t =
      NewFunctionTemplate(isolate,
                          callback,
                          Local<v8::Signature>(),
                          v8::ConstructorBehavior::kThrow,
                          v8::SideEffectType::kHasNoSideEffect);
  // kInternalized strings are created in the old space.
  const v8::NewStringType type = v8::NewStringType::kInternalized;
  Local<v8::String> name_string =
      v8::String::NewFromUtf8(isolate, name, type).ToLocalChecked();
  that->Set(name_string, t);
}",496.0,511.0,1.0,1.0,16.0,25,5,30,15,0,0,1,1,0,0,,0,0,8,4,4,void
5303,298986,SetProtoMethod,1,node.SetProtoMethod,"void node.SetProtoMethod (ANY*,ANY,char*,ANY)",util.cc,"void SetProtoMethod(v8::Isolate* isolate,
                    Local<v8::FunctionTemplate> that,
                    const char* name,
                    v8::FunctionCallback callback) {
  Local<v8::Signature> signature = v8::Signature::New(isolate, that);
  Local<v8::FunctionTemplate> t =
      NewFunctionTemplate(isolate,
                          callback,
                          signature,
                          v8::ConstructorBehavior::kThrow,
                          v8::SideEffectType::kHasSideEffect);
  // kInternalized strings are created in the old space.
  const v8::NewStringType type = v8::NewStringType::kInternalized;
  Local<v8::String> name_string =
      v8::String::NewFromUtf8(isolate, name, type).ToLocalChecked();
  that->PrototypeTemplate()->Set(name_string, t);
  t->SetClassName(name_string);  // NODE_SET_PROTOTYPE_METHOD() compatibility.
}",513.0,530.0,1.0,1.0,18.0,27,5,33,15,0,0,1,1,0,0,,0,0,8,4,4,void
5304,299074,SetProtoMethodNoSideEffect,1,node.SetProtoMethodNoSideEffect,"void node.SetProtoMethodNoSideEffect (ANY*,ANY,char*,ANY)",util.cc,"void SetProtoMethodNoSideEffect(v8::Isolate* isolate,
                                Local<v8::FunctionTemplate> that,
                                const char* name,
                                v8::FunctionCallback callback) {
  Local<v8::Signature> signature = v8::Signature::New(isolate, that);
  Local<v8::FunctionTemplate> t =
      NewFunctionTemplate(isolate,
                          callback,
                          signature,
                          v8::ConstructorBehavior::kThrow,
                          v8::SideEffectType::kHasNoSideEffect);
  // kInternalized strings are created in the old space.
  const v8::NewStringType type = v8::NewStringType::kInternalized;
  Local<v8::String> name_string =
      v8::String::NewFromUtf8(isolate, name, type).ToLocalChecked();
  that->PrototypeTemplate()->Set(name_string, t);
  t->SetClassName(name_string);  // NODE_SET_PROTOTYPE_METHOD() compatibility.
}",532.0,549.0,1.0,1.0,18.0,27,5,33,15,0,0,1,1,0,0,,0,0,8,4,4,void
5305,299162,SetInstanceMethod,1,node.SetInstanceMethod,"void node.SetInstanceMethod (ANY*,ANY,char*,ANY)",util.cc,"void SetInstanceMethod(v8::Isolate* isolate,
                       Local<v8::FunctionTemplate> that,
                       const char* name,
                       v8::FunctionCallback callback) {
  Local<v8::Signature> signature = v8::Signature::New(isolate, that);
  Local<v8::FunctionTemplate> t =
      NewFunctionTemplate(isolate,
                          callback,
                          signature,
                          v8::ConstructorBehavior::kThrow,
                          v8::SideEffectType::kHasSideEffect);
  // kInternalized strings are created in the old space.
  const v8::NewStringType type = v8::NewStringType::kInternalized;
  Local<v8::String> name_string =
      v8::String::NewFromUtf8(isolate, name, type).ToLocalChecked();
  that->InstanceTemplate()->Set(name_string, t);
  t->SetClassName(name_string);
}",551.0,568.0,1.0,1.0,18.0,27,5,33,15,0,0,1,1,0,0,,0,0,8,4,4,void
5306,299250,SetConstructorFunction,1,node.SetConstructorFunction,"void node.SetConstructorFunction (ANY,ANY,char*,ANY,SetConstructorFunctionFlag)",util.cc,"void SetConstructorFunction(Isolate* isolate,
                            Local<Template> that,
                            Local<String> name,
                            Local<FunctionTemplate> tmpl,
                            SetConstructorFunctionFlag flag) {
  if (LIKELY(flag == SetConstructorFunctionFlag::SET_CLASS_NAME))
    tmpl->SetClassName(name);
  that->Set(name, tmpl);
}",599.0,607.0,1.0,1.0,9.0,2,2,8,6,0,0,1,1,0,0,,0,0,10,5,5,void
5307,299358,ToStringChecked,1,node.UnionBytes.ToStringChecked,Local<String> node.UnionBytes.ToStringChecked (Isolate*),util.cc,"Local<String> UnionBytes::ToStringChecked(Isolate* isolate) const {
  if (is_one_byte()) {
    return String::NewExternalOneByte(isolate, one_byte_resource_)
        .ToLocalChecked();
  } else {
    return String::NewExternalTwoByte(isolate, two_byte_resource_)
        .ToLocalChecked();
  }
}",609.0,617.0,1.0,1.0,9.0,2,1,3,3,0,0,2,2,0,0,,0,0,2,1,1,Local<String>
5308,299458,ErrName,1,node.uv.ErrName,void node.uv.ErrName (FunctionCallbackInfo<Value>),uv.cc,"void ErrName(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  if (env->options()->pending_deprecation && env->EmitErrNameWarning()) {
    if (ProcessEmitDeprecationWarning(
        env,
        ""Directly calling process.binding('uv').errname(<val>) is being""
        "" deprecated. ""
        ""Please make sure to use util.getSystemErrorName() instead."",
        ""DEP0119"").IsNothing())
    return;
  }
  int err;
  if (!args[0]->Int32Value(env->context()).To(&err)) return;
  CHECK_LT(err, 0);
  char name[50];
  uv_err_name_r(err, name, sizeof(name));
  args.GetReturnValue().Set(OneByteString(env->isolate(), name));
}",62.0,79.0,1.0,1.0,18.0,17,8,16,5,0,0,4,5,0,0,,0,0,2,1,1,void
5309,299536,GetErrMap,1,node.uv.GetErrMap,void node.uv.GetErrMap (FunctionCallbackInfo<Value>),uv.cc,"void GetErrMap(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();
  Local<Context> context = env->context();

  // This can't return a SafeMap, because the uv binding can be referenced
  // by user code by using `process.binding('uv').getErrorMap()`:
  Local<Map> err_map = Map::New(isolate);

  size_t errors_len = arraysize(per_process::uv_errors_map);
  for (size_t i = 0; i < errors_len; ++i) {
    const auto& error = per_process::uv_errors_map[i];
    Local<Value> arr[] = {OneByteString(isolate, error.name),
                          OneByteString(isolate, error.message)};
    if (err_map
            ->Set(context,
                  Integer::New(isolate, error.value),
                  Array::New(isolate, arr, arraysize(arr)))
            .IsEmpty()) {
      return;
    }
  }

  args.GetReturnValue().Set(err_map);
}",81.0,105.0,1.0,1.0,25.0,30,7,38,16,0,0,3,4,0,0,,0,0,2,1,1,void
5310,299653,Initialize,1,node.uv.Initialize,"void node.uv.Initialize (Local<Object>,Local<Value>,Local<Context>,void*)",uv.cc,"void Initialize(Local<Object> target,
                Local<Value> unused,
                Local<Context> context,
                void* priv) {
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();
  SetConstructorFunction(
      context, target, ""errname"", NewFunctionTemplate(isolate, ErrName));

  // TODO(joyeecheung): This should be deprecated in user land in favor of
  // `util.getSystemErrorName(err)`.
  PropertyAttribute attributes =
      static_cast<PropertyAttribute>(ReadOnly | DontDelete);
  size_t errors_len = arraysize(per_process::uv_errors_map);
  const std::string prefix = ""UV_"";
  for (size_t i = 0; i < errors_len; ++i) {
    const auto& error = per_process::uv_errors_map[i];
    const std::string prefixed_name = prefix + error.name;
    Local<String> name = OneByteString(isolate, prefixed_name.c_str());
    Local<Integer> value = Integer::New(isolate, error.value);
    target->DefineOwnProperty(context, name, value, attributes)...",107.0,131.0,1.0,1.0,25.0,29,9,41,19,0,0,2,2,0,0,,0,0,8,4,4,void
5311,299772,RegisterExternalReferences,1,node.uv.RegisterExternalReferences,void node.uv.RegisterExternalReferences (ExternalReferenceRegistry*),uv.cc,"void RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  registry->Register(ErrName);
  registry->Register(GetErrMap);
}",133.0,136.0,1.0,1.0,4.0,2,1,2,1,0,0,1,1,0,0,,0,0,2,1,1,void
5312,1462,Impl,4,node.Impl,,api\embed_helpers.cc,"struct CommonEnvironmentSetup::Impl {
  MultiIsolatePlatform* platform = nullptr;
  uv_loop_t loop;
  std::shared_ptr<ArrayBufferAllocator> allocator;
  std::optional<SnapshotCreator> snapshot_creator;
  Isolate* isolate = nullptr;
  DeleteFnPtr<IsolateData, FreeIsolateData> isolate_data;
  DeleteFnPtr<Environment, FreeEnvironment> env;
  Global<Context> main_context;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5313,6111,AsyncCleanupHookInfo,4,node.AsyncCleanupHookInfo,,api\hooks.cc,"struct AsyncCleanupHookInfo final {
  Environment* env;
  AsyncCleanupHook fun;
  void* arg;
  bool started = false;
  // Use a self-reference to make sure the storage is kept alive while the
  // cleanup hook is registered but not yet finished.
  std::shared_ptr<AsyncCleanupHookInfo> self;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5314,6124,ACHHandle,4,node.ACHHandle,,api\hooks.cc,"struct ACHHandle final {
  std::shared_ptr<AsyncCleanupHookInfo> info;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5315,6604,TryCatchScope,4,TryCatchScope,,async_wrap.cc,using TryCatchScope = node::errors::TryCatchScope;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5316,7185,DestroyParam,4,node.DestroyParam,,async_wrap.cc,"class DestroyParam {
 public:
  double asyncId;
  Environment* env;
  Global<Object> target;
  Global<Object> propBag;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5317,11605,ares_unique_ptr,4,ares_unique_ptr,,cares_wrap.cc,"using ares_unique_ptr = std::unique_ptr<char[], AresDeleter>;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5318,17476,Environment,4,node.Environment,,connect_wrap.cc,class Environment,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5319,70501,IdempotentDataQueueReader,4,node.anonymous_namespace_25.IdempotentDataQueueReader,,dataqueue\queue.cc,"class IdempotentDataQueueReader final
    : public DataQueue::Reader,
      public std::enable_shared_from_this<IdempotentDataQueueReader> {
 public:
  IdempotentDataQueueReader(std::shared_ptr<DataQueueImpl> data_queue)
      : data_queue_(std::move(data_queue)) {
    CHECK(data_queue_->is_idempotent());
  }

  // Disallow moving and copying.
  IdempotentDataQueueReader(const IdempotentDataQueueReader&) = delete;
  IdempotentDataQueueReader(IdempotentDataQueueReader&&) = delete;
  IdempotentDataQueueReader& operator=(const IdempotentDataQueueReader&) =
      delete;
  IdempotentDataQueueReader& operator=(IdempotentDataQueueReader&&) = delete;

  int Pull(Next next,
           int options,
           DataQueue::Vec* data,
           size_t count,
           size_t max_count_hint = bob::kMaxCountHint) override {
    std::shared_ptr<DataQueue::Reader> self = shared_from_this();

    // If ended is true, this reader has already reached the end and cannot
    // provide any more data.
 ...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5320,70641,NonIdempotentDataQueueReader,4,node.anonymous_namespace_39.NonIdempotentDataQueueReader,,dataqueue\queue.cc,"class NonIdempotentDataQueueReader final
    : public DataQueue::Reader,
      public std::enable_shared_from_this<NonIdempotentDataQueueReader> {
 public:
  NonIdempotentDataQueueReader(std::shared_ptr<DataQueueImpl> data_queue)
      : data_queue_(std::move(data_queue)) {
    CHECK(!data_queue_->is_idempotent());
  }

  // Disallow moving and copying.
  NonIdempotentDataQueueReader(const NonIdempotentDataQueueReader&) = delete;
  NonIdempotentDataQueueReader(NonIdempotentDataQueueReader&&) = delete;
  NonIdempotentDataQueueReader& operator=(const NonIdempotentDataQueueReader&) =
      delete;
  NonIdempotentDataQueueReader& operator=(NonIdempotentDataQueueReader&&) =
      delete;

  int Pull(Next next,
           int options,
           DataQueue::Vec* data,
           size_t count,
           size_t max_count_hint = bob::kMaxCountHint) override {
    std::shared_ptr<DataQueue::Reader> self = shared_from_this();

    // If ended is true, this reader has already reached the end an...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5321,70792,EmptyReader,4,node.anonymous_namespace_58.EmptyEntry.EmptyReader,,dataqueue\queue.cc,"class EmptyReader final : public DataQueue::Reader,
                            public std::enable_shared_from_this<EmptyReader> {
   public:
    int Pull(Next next,
             int options,
             DataQueue::Vec* data,
             size_t count,
             size_t max_count_hint = bob::kMaxCountHint) override {
      auto self = shared_from_this();
      if (ended_) {
        std::move(next)(bob::Status::STATUS_EOS, nullptr, 0, [](uint64_t) {});
        return bob::Status::STATUS_EOS;
      }

      ended_ = true;
      std::move(next)(
          bob::Status::STATUS_CONTINUE, nullptr, 0, [](uint64_t) {});
      return bob::Status::STATUS_CONTINUE;
    }

    SET_NO_MEMORY_INFO()
    SET_MEMORY_INFO_NAME(EmptyReader)
    SET_SELF_SIZE(EmptyReader)

   private:
    bool ended_ = false;
  }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5322,70805,InMemoryReader,4,node.anonymous_namespace_74.InMemoryEntry.InMemoryReader,,dataqueue\queue.cc,"class InMemoryReader final
      : public DataQueue::Reader,
        public std::enable_shared_from_this<InMemoryReader> {
   public:
    InMemoryReader(InMemoryEntry& entry) : entry_(entry) {}

    int Pull(Next next,
             int options,
             DataQueue::Vec* data,
             size_t count,
             size_t max_count_hint = bob::kMaxCountHint) override {
      auto self = shared_from_this();
      if (ended_) {
        std::move(next)(bob::Status::STATUS_EOS, nullptr, 0, [](uint64_t) {});
        return bob::Status::STATUS_EOS;
      }

      ended_ = true;
      DataQueue::Vec vec{
          reinterpret_cast<uint8_t*>(entry_.backing_store_->Data()) +
              entry_.offset_,
          entry_.byte_length_,
      };

      std::move(next)(bob::Status::STATUS_CONTINUE,
                      &vec,
                      1,
                      InMemoryFunctor({entry_.backing_store_}));
      return bob::Status::STATUS_CONTINUE;
    }

    SET_NO_MEMORY_INFO()
   ...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5323,70836,InMemoryEntry,4,node.anonymous_namespace_71.InMemoryEntry,,dataqueue\queue.cc,"class InMemoryEntry final : public EntryImpl {
 public:
  struct InMemoryFunctor final {
    std::shared_ptr<BackingStore> backing_store;
    void operator()(uint64_t) { backing_store = nullptr; }
  };

  class InMemoryReader final
      : public DataQueue::Reader,
        public std::enable_shared_from_this<InMemoryReader> {
   public:
    InMemoryReader(InMemoryEntry& entry) : entry_(entry) {}

    int Pull(Next next,
             int options,
             DataQueue::Vec* data,
             size_t count,
             size_t max_count_hint = bob::kMaxCountHint) override {
      auto self = shared_from_this();
      if (ended_) {
        std::move(next)(bob::Status::STATUS_EOS, nullptr, 0, [](uint64_t) {});
        return bob::Status::STATUS_EOS;
      }

      ended_ = true;
      DataQueue::Vec vec{
          reinterpret_cast<uint8_t*>(entry_.backing_store_->Data()) +
              entry_.offset_,
          entry_.byte_length_,
      };

      std::move(next)(bob::Status::STATUS_C...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5324,70846,FdEntry,4,node.anonymous_namespace_105.FdEntry,,dataqueue\queue.cc,"class FdEntry final : public EntryImpl {
  // TODO(@jasnell, @flakey5):
  // * This should only allow reading from regular files. No directories, no
  // pipes, etc.
  // * The reader should support accepting the buffer(s) from the pull, if any.
  // It should
  //   only allocate a managed buffer if the pull doesn't provide any.
  // * We might want to consider making the stat on each read sync to eliminate
  // the race
  //   condition described in the comment above.
 public:
  static std::unique_ptr<FdEntry> Create(Environment* env, Local<Value> path) {
    // We're only going to create the FdEntry if the file exists.
    uv_fs_t req = uv_fs_t();
    auto cleanup = OnScopeLeave([&] { uv_fs_req_cleanup(&req); });

    auto buf = std::make_shared<BufferValue>(env->isolate(), path);
    if (uv_fs_stat(nullptr, &req, buf->out(), nullptr) < 0) return nullptr;

    return std::make_unique<FdEntry>(
        env, std::move(buf), req.statbuf, 0, req.statbuf.st_size);
  }

  FdEntry(Envir...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5325,70865,ReaderImpl,4,node.anonymous_namespace_118.FdEntry.ReaderImpl,,dataqueue\queue.cc,"class ReaderImpl final : public DataQueue::Reader,
                           public StreamListener,
                           public std::enable_shared_from_this<ReaderImpl> {
   public:
    static std::shared_ptr<ReaderImpl> Create(FdEntry* entry) {
      uv_fs_t req;
      auto cleanup = OnScopeLeave([&] { uv_fs_req_cleanup(&req); });
      int file =
          uv_fs_open(nullptr, &req, entry->path_->out(), O_RDONLY, 0, nullptr);
      if (file < 0 || FdEntry::CheckModified(entry, file)) {
        uv_fs_close(nullptr, &req, file, nullptr);
        return nullptr;
      }
      Realm* realm = entry->env()->principal_realm();
      return std::make_shared<ReaderImpl>(
          BaseObjectPtr<fs::FileHandle>(fs::FileHandle::New(
              realm->GetBindingData<fs::BindingData>(realm->context()),
              file,
              Local<Object>(),
              entry->start_,
              entry->end_ - entry->start_)),
          entry);
    }

    explicit ReaderImpl(BaseObjectP...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5326,71005,IdempotentDataQueueReader,4,node.anonymous_namespace_1.IdempotentDataQueueReader,,dataqueue\queue.cc,class IdempotentDataQueueReader,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5327,71006,NonIdempotentDataQueueReader,4,node.anonymous_namespace_2.NonIdempotentDataQueueReader,,dataqueue\queue.cc,class NonIdempotentDataQueueReader,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5328,71007,EntryImpl,4,node.anonymous_namespace_3.EntryImpl,,dataqueue\queue.cc,"class EntryImpl : public DataQueue::Entry {
 public:
  virtual std::shared_ptr<DataQueue::Reader> get_reader() = 0;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5329,71012,DataQueueImpl,4,node.anonymous_namespace_5.DataQueueImpl,,dataqueue\queue.cc,"class DataQueueImpl final : public DataQueue,
                            public std::enable_shared_from_this<DataQueueImpl> {
 public:
  // Constructor for an idempotent, fixed sized DataQueue.
  DataQueueImpl(std::vector<std::unique_ptr<Entry>>&& list, uint64_t size)
      : entries_(std::move(list)),
        idempotent_(true),
        size_(size),
        capped_size_(0) {}

  // Constructor for a non-idempotent DataQueue. This kind of queue can have
  // entries added to it over time. The size is set to 0 initially. The queue
  // can be capped immediately on creation. Depending on the entries that are
  // added, the size can be cleared if any of the entries are not capable of
  // providing a size.
  DataQueueImpl(std::optional<uint64_t> cap = std::nullopt)
      : idempotent_(false), size_(0), capped_size_(cap) {}

  // Disallow moving and copying.
  DataQueueImpl(const DataQueueImpl&) = delete;
  DataQueueImpl(DataQueueImpl&&) = delete;
  DataQueueImpl& operator=(const DataQ...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5330,71410,DataQueue,4,node.anonymous_namespace_22.DataQueueImpl.DataQueue,,dataqueue\queue.cc,friend class DataQueue,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5331,71411,IdempotentDataQueueReader,4,node.anonymous_namespace_23.DataQueueImpl.IdempotentDataQueueReader,,dataqueue\queue.cc,friend class IdempotentDataQueueReader,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5332,71412,NonIdempotentDataQueueReader,4,node.anonymous_namespace_24.DataQueueImpl.NonIdempotentDataQueueReader,,dataqueue\queue.cc,friend class NonIdempotentDataQueueReader,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5333,71983,EmptyEntry,4,node.anonymous_namespace_57.EmptyEntry,,dataqueue\queue.cc,"class EmptyEntry final : public EntryImpl {
 public:
  class EmptyReader final : public DataQueue::Reader,
                            public std::enable_shared_from_this<EmptyReader> {
   public:
    int Pull(Next next,
             int options,
             DataQueue::Vec* data,
             size_t count,
             size_t max_count_hint = bob::kMaxCountHint) override {
      auto self = shared_from_this();
      if (ended_) {
        std::move(next)(bob::Status::STATUS_EOS, nullptr, 0, [](uint64_t) {});
        return bob::Status::STATUS_EOS;
      }

      ended_ = true;
      std::move(next)(
          bob::Status::STATUS_CONTINUE, nullptr, 0, [](uint64_t) {});
      return bob::Status::STATUS_CONTINUE;
    }

    SET_NO_MEMORY_INFO()
    SET_MEMORY_INFO_NAME(EmptyReader)
    SET_SELF_SIZE(EmptyReader)

   private:
    bool ended_ = false;
  };

  EmptyEntry() = default;

  // Disallow moving and copying.
  EmptyEntry(const EmptyEntry&) = delete;
  EmptyEntry(EmptyEntry&&) = ...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5334,72108,InMemoryFunctor,4,node.anonymous_namespace_72.InMemoryEntry.InMemoryFunctor,,dataqueue\queue.cc,"struct InMemoryFunctor final {
    std::shared_ptr<BackingStore> backing_store;
    void operator()(uint64_t) { backing_store = nullptr; }
  }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5335,72358,InMemoryReader,4,node.anonymous_namespace_89.InMemoryEntry.InMemoryReader,,dataqueue\queue.cc,friend class InMemoryReader,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5336,72359,DataQueueEntry,4,node.anonymous_namespace_90.DataQueueEntry,,dataqueue\queue.cc,"class DataQueueEntry : public EntryImpl {
 public:
  explicit DataQueueEntry(std::shared_ptr<DataQueue> data_queue)
      : data_queue_(std::move(data_queue)) {
    CHECK(data_queue_);
  }

  // Disallow moving and copying.
  DataQueueEntry(const DataQueueEntry&) = delete;
  DataQueueEntry(DataQueueEntry&&) = delete;
  DataQueueEntry& operator=(const DataQueueEntry&) = delete;
  DataQueueEntry& operator=(DataQueueEntry&&) = delete;

  std::shared_ptr<DataQueue::Reader> get_reader() override {
    return std::make_shared<ReaderImpl>(data_queue_->get_reader());
  }

  std::unique_ptr<Entry> slice(
      uint64_t start, std::optional<uint64_t> end = std::nullopt) override {
    std::shared_ptr<DataQueue> sliced = data_queue_->slice(start, end);
    if (!sliced) return nullptr;

    return std::make_unique<DataQueueEntry>(std::move(sliced));
  }

  // Returns the number of bytes represented by this Entry if it is
  // known. Certain types of entries, such as those backed by streams
  //...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5337,72482,ReaderImpl,4,node.anonymous_namespace_102.DataQueueEntry.ReaderImpl,,dataqueue\queue.cc,"class ReaderImpl : public DataQueue::Reader,
                     public std::enable_shared_from_this<ReaderImpl> {
   public:
    explicit ReaderImpl(std::shared_ptr<DataQueue::Reader> inner)
        : inner_(std::move(inner)) {}

    int Pull(DataQueue::Reader::Next next,
             int options,
             DataQueue::Vec* data,
             size_t count,
             size_t max_count_hint) override {
      auto self = shared_from_this();
      return inner_->Pull(
          std::move(next), options, data, count, max_count_hint);
    }

    SET_NO_MEMORY_INFO()
    SET_MEMORY_INFO_NAME(ReaderImpl)
    SET_SELF_SIZE(ReaderImpl)

   private:
    std::shared_ptr<DataQueue::Reader> inner_;
  }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5338,73231,FdEntry,4,node.anonymous_namespace_146.FdEntry.ReaderImpl.FdEntry,,dataqueue\queue.cc,friend class FdEntry,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5339,73242,ReaderImpl,4,node.anonymous_namespace_147.FdEntry.ReaderImpl,,dataqueue\queue.cc,friend class ReaderImpl,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5340,73754,Win32SymbolDebuggingContext,4,node.Win32SymbolDebuggingContext,,debug_utils.cc,"class Win32SymbolDebuggingContext final : public NativeSymbolDebuggingContext {
 public:
  Win32SymbolDebuggingContext() {
    current_process_ = GetCurrentProcess();
    USE(SymInitialize(current_process_, nullptr, true));
  }

  ~Win32SymbolDebuggingContext() override {
    USE(SymCleanup(current_process_));
  }

  using NameAndDisplacement = std::pair<std::string, DWORD64>;
  NameAndDisplacement WrappedSymFromAddr(DWORD64 dwAddress) const {
    // Refs: https://docs.microsoft.com/en-us/windows/desktop/Debug/retrieving-symbol-information-by-address
    // Patches:
    // Use `fprintf(stderr, ` instead of `printf`
    // `sym.filename = pSymbol->Name` on success
    // `current_process_` instead of `hProcess.
    DWORD64 dwDisplacement = 0;
    // Patch: made into arg - DWORD64  dwAddress = SOME_ADDRESS;

    char buffer[sizeof(SYMBOL_INFO) + MAX_SYM_NAME * sizeof(TCHAR)];
    const auto pSymbol = reinterpret_cast<PSYMBOL_INFO>(buffer);

    pSymbol->SizeOfStruct = sizeof(SYMBOL_IN...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5341,73774,NameAndDisplacement,4,NameAndDisplacement,,debug_utils.cc,"using NameAndDisplacement = std::pair<std::string, DWORD64>;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5342,80496,FSEventWrap,4,node.anonymous_namespace_1.FSEventWrap,,fs_event_wrap.cc,"class FSEventWrap: public HandleWrap {
 public:
  static void Initialize(Local<Object> target,
                         Local<Value> unused,
                         Local<Context> context,
                         void* priv);
  static void RegisterExternalReferences(ExternalReferenceRegistry* registry);
  static void New(const FunctionCallbackInfo<Value>& args);
  static void Start(const FunctionCallbackInfo<Value>& args);
  static void GetInitialized(const FunctionCallbackInfo<Value>& args);

  SET_NO_MEMORY_INFO()
  SET_MEMORY_INFO_NAME(FSEventWrap)
  SET_SELF_SIZE(FSEventWrap)

 private:
  static const encoding kDefaultEncoding = UTF8;

  FSEventWrap(Environment* env, Local<Object> object);
  ~FSEventWrap() override = default;

  static void OnEvent(uv_fs_event_t* handle, const char* filename, int events,
    int status);

  uv_fs_event_t handle_;
  enum encoding encoding_ = kDefaultEncoding;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5343,80545,encoding,4,node.anonymous_namespace_10.FSEventWrap.encoding,,fs_event_wrap.cc,enum encoding,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5344,81637,JSGraphJSNode,4,node.heap.JSGraphJSNode,,heap_utils.cc,"class JSGraphJSNode : public EmbedderGraph::Node {
 public:
  const char* Name() override { return ""<JS Node>""; }
  size_t SizeInBytes() override { return 0; }
  bool IsEmbedderNode() override { return false; }
  Local<Value> JSValue() { return PersistentToLocal::Strong(persistent_); }

  int IdentityHash() {
    Local<Value> v = JSValue();
    if (v->IsObject()) return v.As<Object>()->GetIdentityHash();
    if (v->IsName()) return v.As<v8::Name>()->GetIdentityHash();
    if (v->IsInt32()) return v.As<v8::Int32>()->Value();
    return 0;
  }

  JSGraphJSNode(Isolate* isolate, Local<Value> val)
      : persistent_(isolate, val) {
    CHECK(!val.IsEmpty());
  }

  struct Hash {
    inline size_t operator()(JSGraphJSNode* n) const {
      return static_cast<size_t>(n->IdentityHash());
    }
  };

  struct Equal {
    inline bool operator()(JSGraphJSNode* a, JSGraphJSNode* b) const {
      return a->JSValue()->SameValue(b->JSValue());
    }
  };

 private:
  Global<Value> persistent_;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5345,81733,Hash,4,node.heap.JSGraphJSNode.Hash,,heap_utils.cc,"struct Hash {
    inline size_t operator()(JSGraphJSNode* n) const {
      return static_cast<size_t>(n->IdentityHash());
    }
  }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5346,81746,Equal,4,node.heap.JSGraphJSNode.Equal,,heap_utils.cc,"struct Equal {
    inline bool operator()(JSGraphJSNode* a, JSGraphJSNode* b) const {
      return a->JSValue()->SameValue(b->JSValue());
    }
  }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5347,81766,JSGraph,4,node.heap.JSGraph,,heap_utils.cc,"class JSGraph : public EmbedderGraph {
 public:
  explicit JSGraph(Isolate* isolate) : isolate_(isolate) {}

  Node* V8Node(const Local<Value>& value) override {
    std::unique_ptr<JSGraphJSNode> n { new JSGraphJSNode(isolate_, value) };
    auto it = engine_nodes_.find(n.get());
    if (it != engine_nodes_.end())
      return *it;
    engine_nodes_.insert(n.get());
    return AddNode(std::unique_ptr<Node>(n.release()));
  }

  Node* AddNode(std::unique_ptr<Node> node) override {
    Node* n = node.get();
    nodes_.emplace(std::move(node));
    return n;
  }

  void AddEdge(Node* from, Node* to, const char* name = nullptr) override {
    edges_[from].insert(std::make_pair(name, to));
  }

  MaybeLocal<Array> CreateObject() const {
    EscapableHandleScope handle_scope(isolate_);
    Local<Context> context = isolate_->GetCurrentContext();
    Environment* env = Environment::GetCurrent(context);

    std::unordered_map<Node*, Local<Object>> info_objects;
    Local<Array> nodes = Arr...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5348,82465,FileOutputStream,4,node.heap.anonymous_namespace_1.FileOutputStream,,heap_utils.cc,"class FileOutputStream : public v8::OutputStream {
 public:
  FileOutputStream(const int fd, uv_fs_t* req) : fd_(fd), req_(req) {}

  int GetChunkSize() override {
    return 65536;  // big chunks == faster
  }

  void EndOfStream() override {}

  WriteResult WriteAsciiChunk(char* data, const int size) override {
    DCHECK_EQ(status_, 0);
    int offset = 0;
    while (offset < size) {
      const uv_buf_t buf = uv_buf_init(data + offset, size - offset);
      const int num_bytes_written = uv_fs_write(nullptr,
                                                req_,
                                                fd_,
                                                &buf,
                                                1,
                                                -1,
                                                nullptr);
      uv_fs_req_cleanup(req_);
      if (num_bytes_written < 0) {
        status_ = num_bytes_written;
        return kAbort;
      }
      DCHECK_LE(static_c...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5349,82566,HeapSnapshotStream,4,node.heap.anonymous_namespace_7.HeapSnapshotStream,,heap_utils.cc,"class HeapSnapshotStream : public AsyncWrap,
                           public StreamBase,
                           public v8::OutputStream {
 public:
  HeapSnapshotStream(
      Environment* env,
      HeapSnapshotPointer&& snapshot,
      Local<Object> obj) :
      AsyncWrap(env, obj, AsyncWrap::PROVIDER_HEAPSNAPSHOT),
      StreamBase(env),
      snapshot_(std::move(snapshot)) {
    MakeWeak();
    StreamBase::AttachToObject(GetObject());
  }

  ~HeapSnapshotStream() override {}

  int GetChunkSize() override {
    return 65536;  // big chunks == faster
  }

  void EndOfStream() override {
    EmitRead(UV_EOF);
    snapshot_.reset();
  }

  WriteResult WriteAsciiChunk(char* data, int size) override {
    int len = size;
    while (len != 0) {
      uv_buf_t buf = EmitAlloc(size);
      ssize_t avail = len;
      if (static_cast<ssize_t>(buf.len) < avail)
        avail = buf.len;
      memcpy(buf.base, data, avail);
      data += avail;
      len -= static_cast<int>(avail);
    ...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5350,85937,ThreadSafeDelegate,4,node.inspector.anonymous_namespace_34.ThreadSafeDelegate,,inspector\main_thread_interface.cc,"class ThreadSafeDelegate : public InspectorSessionDelegate {
 public:
  ThreadSafeDelegate(std::shared_ptr<MainThreadHandle> thread, int object_id)
                     : thread_(thread), delegate_(thread, object_id) {}

  void SendMessageToFrontend(const v8_inspector::StringView& message) override {
    delegate_.Call(
        [m = StringBuffer::create(message)]
        (InspectorSessionDelegate* delegate) {
      delegate->SendMessageToFrontend(m->string());
    });
  }

 private:
  std::shared_ptr<MainThreadHandle> thread_;
  AnotherThreadObjectReference<InspectorSessionDelegate> delegate_;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5351,85978,DeletableWrapper,4,node.inspector.anonymous_namespace_3.DeletableWrapper,,inspector\main_thread_interface.cc,"class DeletableWrapper : public Deletable {
 public:
  explicit DeletableWrapper(std::unique_ptr<T> object)
                        : object_(std::move(object)) {}
  ~DeletableWrapper() override = default;

  static T* get(MainThreadInterface* thread, int id) {
    return
        static_cast<DeletableWrapper<T>*>(thread->GetObject(id))->object_.get();
  }

 private:
  std::unique_ptr<T> object_;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5352,86029,CreateObjectRequest,4,node.inspector.anonymous_namespace_8.CreateObjectRequest,,inspector\main_thread_interface.cc,"class CreateObjectRequest : public Request {
 public:
  CreateObjectRequest(int object_id, Factory factory)
                      : object_id_(object_id), factory_(std::move(factory)) {}

  void Call(MainThreadInterface* thread) override {
    thread->AddObject(object_id_, WrapInDeletable(factory_(thread)));
  }

 private:
  int object_id_;
  Factory factory_;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5353,86072,DeleteRequest,4,node.inspector.anonymous_namespace_12.DeleteRequest,,inspector\main_thread_interface.cc,"class DeleteRequest : public Request {
 public:
  explicit DeleteRequest(int object_id) : object_id_(object_id) {}

  void Call(MainThreadInterface* thread) override {
    thread->RemoveObject(object_id_);
  }

 private:
  int object_id_;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5354,86089,CallRequest,4,node.inspector.anonymous_namespace_15.CallRequest,,inspector\main_thread_interface.cc,"class CallRequest : public Request {
 public:
  CallRequest(int id, Fn fn) : id_(id), fn_(std::move(fn)) {}

  void Call(MainThreadInterface* thread) override {
    fn_(DeletableWrapper<Target>::get(thread, id_));
  }

 private:
  int id_;
  Fn fn_;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5355,86110,AnotherThreadObjectReference,4,node.inspector.anonymous_namespace_18.AnotherThreadObjectReference,,inspector\main_thread_interface.cc,"class AnotherThreadObjectReference {
 public:
  AnotherThreadObjectReference(
      std::shared_ptr<MainThreadHandle> thread, int object_id)
      : thread_(thread), object_id_(object_id) {}

  template <typename Factory>
  AnotherThreadObjectReference(
      std::shared_ptr<MainThreadHandle> thread, Factory factory)
      : AnotherThreadObjectReference(thread, thread->newObjectId()) {
    thread_->Post(NewCreateRequest(object_id_, std::move(factory)));
  }
  AnotherThreadObjectReference(AnotherThreadObjectReference&) = delete;

  ~AnotherThreadObjectReference() {
    // Disappearing thread may cause a memory leak
    thread_->Post(std::make_unique<DeleteRequest>(object_id_));
  }

  template <typename Fn>
  void Call(Fn fn) const {
    using Request = CallRequest<T, Fn>;
    thread_->Post(std::unique_ptr<Request>(
        new Request(object_id_, std::move(fn))));
  }

  template <typename Arg>
  void Call(void (T::*fn)(Arg), Arg argument) const {
    Call(std::bind(Apply<Arg>, std:...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5356,86157,Request,4,Request,,inspector\main_thread_interface.cc,"using Request = CallRequest<T, Fn>;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5357,86219,MainThreadSessionState,4,node.inspector.anonymous_namespace_26.MainThreadSessionState,,inspector\main_thread_interface.cc,"class MainThreadSessionState {
 public:
  MainThreadSessionState(MainThreadInterface* thread, bool prevent_shutdown)
                         : thread_(thread),
                           prevent_shutdown_(prevent_shutdown) {}

  static std::unique_ptr<MainThreadSessionState> Create(
      MainThreadInterface* thread, bool prevent_shutdown) {
    return std::make_unique<MainThreadSessionState>(thread, prevent_shutdown);
  }

  void Connect(std::unique_ptr<InspectorSessionDelegate> delegate) {
    Agent* agent = thread_->inspector_agent();
    if (agent != nullptr)
      session_ = agent->Connect(std::move(delegate), prevent_shutdown_);
  }

  void Dispatch(std::unique_ptr<StringBuffer> message) {
    session_->Dispatch(message->string());
  }

 private:
  MainThreadInterface* thread_;
  bool prevent_shutdown_;
  std::unique_ptr<InspectorSession> session_;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5358,86288,CrossThreadInspectorSession,4,node.inspector.anonymous_namespace_31.CrossThreadInspectorSession,,inspector\main_thread_interface.cc,"class CrossThreadInspectorSession : public InspectorSession {
 public:
  CrossThreadInspectorSession(
      int id,
      std::shared_ptr<MainThreadHandle> thread,
      std::unique_ptr<InspectorSessionDelegate> delegate,
      bool prevent_shutdown)
      : state_(thread, std::bind(MainThreadSessionState::Create,
                                 std::placeholders::_1,
                                 prevent_shutdown)) {
    state_.Call(&MainThreadSessionState::Connect, std::move(delegate));
  }

  void Dispatch(const StringView& message) override {
    state_.Call(&MainThreadSessionState::Dispatch,
                StringBuffer::create(message));
  }

 private:
  AnotherThreadObjectReference<MainThreadSessionState> state_;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5359,86783,StringBuffer,4,v8_inspector.StringBuffer,,inspector\main_thread_interface.hpp,class StringBuffer,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5360,86784,StringView,4,v8_inspector.StringView,,inspector\main_thread_interface.hpp,class StringView,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5361,86787,MainThreadInterface,4,node.inspector.MainThreadInterface,,inspector\main_thread_interface.hpp,class MainThreadInterface,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5362,86788,Request,4,node.inspector.Request,,inspector\main_thread_interface.hpp,"class Request {
 public:
  virtual void Call(MainThreadInterface*) = 0;
  virtual ~Request() = default;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5363,86798,Deletable,4,node.inspector.Deletable,,inspector\main_thread_interface.hpp,"class Deletable {
 public:
  virtual ~Deletable() = default;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5364,86808,MessageQueue,4,MessageQueue,,inspector\main_thread_interface.hpp,using MessageQueue = std::deque<std::unique_ptr<Request>>;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5365,86809,MainThreadHandle,4,node.inspector.MainThreadHandle,,inspector\main_thread_interface.hpp,"class MainThreadHandle : public std::enable_shared_from_this<MainThreadHandle> {
 public:
  explicit MainThreadHandle(MainThreadInterface* main_thread)
                            : main_thread_(main_thread) {
  }
  ~MainThreadHandle() {
    Mutex::ScopedLock scoped_lock(block_lock_);
    CHECK_NULL(main_thread_);  // main_thread_ should have called Reset
  }
  std::unique_ptr<InspectorSession> Connect(
      std::unique_ptr<InspectorSessionDelegate> delegate,
      bool prevent_shutdown);
  int newObjectId() {
    return ++next_object_id_;
  }
  bool Post(std::unique_ptr<Request> request);
  std::unique_ptr<InspectorSessionDelegate> MakeDelegateThreadSafe(
      std::unique_ptr<InspectorSessionDelegate> delegate);
  bool Expired();

 private:
  void Reset();

  MainThreadInterface* main_thread_;
  Mutex block_lock_;
  int next_session_id_ = 0;
  std::atomic_int next_object_id_ = {1};

  friend class MainThreadInterface;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5366,86859,MainThreadInterface,4,node.inspector.MainThreadHandle.MainThreadInterface,,inspector\main_thread_interface.hpp,friend class MainThreadInterface,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5367,86871,MainThreadInterface,4,node.inspector.MainThreadInterface,,inspector\main_thread_interface.hpp,"class MainThreadInterface :
    public std::enable_shared_from_this<MainThreadInterface> {
 public:
  explicit MainThreadInterface(Agent* agent);
  ~MainThreadInterface();

  void DispatchMessages();
  void Post(std::unique_ptr<Request> request);
  bool WaitForFrontendEvent();
  std::shared_ptr<MainThreadHandle> GetHandle();
  Agent* inspector_agent() {
    return agent_;
  }
  void AddObject(int handle, std::unique_ptr<Deletable> object);
  Deletable* GetObject(int id);
  Deletable* GetObjectIfExists(int id);
  void RemoveObject(int handle);

 private:
  MessageQueue requests_;
  Mutex requests_lock_;   // requests_ live across threads
  // This queue is to maintain the order of the messages for the cases
  // when we reenter the DispatchMessages function.
  MessageQueue dispatching_message_queue_;
  bool dispatching_messages_ = false;
  ConditionVariable incoming_message_cond_;
  // Used from any thread
  Agent* const agent_;
  std::shared_ptr<MainThreadHandle> handle_;
  std::uno...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5368,87478,Value,4,node.inspector.protocol.Value,,inspector\node_string.hpp,class Value,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5369,87479,String,4,String,,inspector\node_string.hpp,using String = std::string;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5370,87480,StringBuilder,4,StringBuilder,,inspector\node_string.hpp,using StringBuilder = std::ostringstream;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5371,87481,ProtocolMessage,4,ProtocolMessage,,inspector\node_string.hpp,using ProtocolMessage = std::string;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5372,87664,Binary,4,node.inspector.protocol.Binary,,inspector\node_string.hpp,"class Binary {
 public:
  const uint8_t* data() const { UNREACHABLE(); }
  size_t size() const { UNREACHABLE(); }
  String toBase64() const { UNREACHABLE(); }
  static Binary fromBase64(const std::string_view base64, bool* success) {
    UNREACHABLE();
  }
  static Binary fromSpan(const uint8_t* data, size_t size) { UNREACHABLE(); }
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5373,87777,Environment,4,node.Environment,,inspector\runtime_agent.hpp,class Environment,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5374,87780,RuntimeAgent,4,node.inspector.protocol.RuntimeAgent,,inspector\runtime_agent.hpp,"class RuntimeAgent : public NodeRuntime::Backend {
 public:
  RuntimeAgent();

  void Wire(UberDispatcher* dispatcher);

  DispatchResponse notifyWhenWaitingForDisconnect(bool enabled) override;

  bool notifyWaitingForDisconnect();

 private:
  std::shared_ptr<NodeRuntime::Frontend> frontend_;
  bool notify_when_waiting_for_disconnect_;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5375,87824,DeletableFrontendWrapper,4,node.inspector.protocol.anonymous_namespace_2.DeletableFrontendWrapper,,inspector\tracing_agent.cc,"class DeletableFrontendWrapper : public Deletable {
 public:
  explicit DeletableFrontendWrapper(
      std::weak_ptr<NodeTracing::Frontend> frontend)
      : frontend_(frontend) {}

  // This should only be called from the main thread, meaning frontend should
  // not be destroyed concurrently.
  NodeTracing::Frontend* get() { return frontend_.lock().get(); }

 private:
  std::weak_ptr<NodeTracing::Frontend> frontend_;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5376,87843,CreateFrontendWrapperRequest,4,node.inspector.protocol.anonymous_namespace_5.CreateFrontendWrapperRequest,,inspector\tracing_agent.cc,"class CreateFrontendWrapperRequest : public Request {
 public:
  CreateFrontendWrapperRequest(int object_id,
                               std::weak_ptr<NodeTracing::Frontend> frontend)
      : object_id_(object_id) {
    frontend_wrapper_ = std::make_unique<DeletableFrontendWrapper>(frontend);
  }

  void Call(MainThreadInterface* thread) override {
    thread->AddObject(object_id_, std::move(frontend_wrapper_));
  }

 private:
  int object_id_;
  std::unique_ptr<DeletableFrontendWrapper> frontend_wrapper_;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5377,87876,DestroyFrontendWrapperRequest,4,node.inspector.protocol.anonymous_namespace_8.DestroyFrontendWrapperRequest,,inspector\tracing_agent.cc,"class DestroyFrontendWrapperRequest : public Request {
 public:
  explicit DestroyFrontendWrapperRequest(int object_id)
      : object_id_(object_id) {}

  void Call(MainThreadInterface* thread) override {
    thread->RemoveObject(object_id_);
  }

 private:
  int object_id_;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5378,87893,SendMessageRequest,4,node.inspector.protocol.anonymous_namespace_11.SendMessageRequest,,inspector\tracing_agent.cc,"class SendMessageRequest : public Request {
 public:
  explicit SendMessageRequest(int object_id, const std::string& message)
      : object_id_(object_id), message_(message) {}

  void Call(MainThreadInterface* thread) override {
    DeletableFrontendWrapper* frontend_wrapper =
        static_cast<DeletableFrontendWrapper*>(
            thread->GetObjectIfExists(object_id_));
    if (frontend_wrapper == nullptr) return;
    auto frontend = frontend_wrapper->get();
    if (frontend != nullptr) {
      frontend->sendRawJSONNotification(message_);
    }
  }

 private:
  int object_id_;
  std::string message_;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5379,87940,InspectorTraceWriter,4,node.inspector.protocol.anonymous_namespace_14.InspectorTraceWriter,,inspector\tracing_agent.cc,"class InspectorTraceWriter : public node::tracing::AsyncTraceWriter {
 public:
  explicit InspectorTraceWriter(int frontend_object_id,
                                std::shared_ptr<MainThreadHandle> main_thread)
      : frontend_object_id_(frontend_object_id), main_thread_(main_thread) {}

  void AppendTraceEvent(
      v8::platform::tracing::TraceObject* trace_event) override {
    if (!json_writer_)
      json_writer_.reset(TraceWriter::CreateJSONTraceWriter(stream_, ""value""));
    json_writer_->AppendTraceEvent(trace_event);
  }

  void Flush(bool) override {
    if (!json_writer_)
      return;
    json_writer_.reset();
    std::ostringstream result(
        ""{\""method\"":\""NodeTracing.dataCollected\"",\""params\"":"",
        std::ostringstream::ate);
    result << stream_.str();
    result << ""}"";
    main_thread_->Post(std::make_unique<SendMessageRequest>(frontend_object_id_,
                                                            result.str()));
    stream_.str("""");
  }

 p...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5380,88392,Environment,4,node.Environment,,inspector\tracing_agent.hpp,class Environment,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5381,88394,MainThreadHandle,4,node.inspector.MainThreadHandle,,inspector\tracing_agent.hpp,class MainThreadHandle,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5382,88396,TracingAgent,4,node.inspector.protocol.TracingAgent,,inspector\tracing_agent.hpp,"class TracingAgent : public NodeTracing::Backend {
 public:
  explicit TracingAgent(Environment*, std::shared_ptr<MainThreadHandle>);
  ~TracingAgent() override;

  void Wire(UberDispatcher* dispatcher);

  DispatchResponse start(
      std::unique_ptr<protocol::NodeTracing::TraceConfig> traceConfig) override;
  DispatchResponse stop() override;
  DispatchResponse getCategories(
      std::unique_ptr<protocol::Array<String>>* categories) override;

 private:
  Environment* env_;
  std::shared_ptr<MainThreadHandle> main_thread_;
  tracing::AgentWriterHandle trace_writer_;
  int frontend_object_id_ = 0;
  std::shared_ptr<NodeTracing::Frontend> frontend_;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5383,88454,NodeWorkers,4,node.inspector.protocol.NodeWorkers,,inspector\worker_agent.cc,"class NodeWorkers
    : public std::enable_shared_from_this<NodeWorkers> {
 public:
  explicit NodeWorkers(std::weak_ptr<NodeWorker::Frontend> frontend,
                      std::shared_ptr<MainThreadHandle> thread)
                      : frontend_(frontend), thread_(thread) {}
  void WorkerCreated(const std::string& title,
                     const std::string& url,
                     bool waiting,
                     std::shared_ptr<MainThreadHandle> target);
  void Receive(const std::string& id, const std::string& message);
  void Send(const std::string& id, const std::string& message);
  void Detached(const std::string& id);

 private:
  std::weak_ptr<NodeWorker::Frontend> frontend_;
  std::shared_ptr<MainThreadHandle> thread_;
  std::unordered_map<std::string, std::unique_ptr<InspectorSession>> sessions_;
  int next_target_id_ = 0;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5384,88498,AgentWorkerInspectorDelegate,4,node.inspector.protocol.anonymous_namespace_1.AgentWorkerInspectorDelegate,,inspector\worker_agent.cc,"class AgentWorkerInspectorDelegate : public WorkerDelegate {
 public:
  explicit AgentWorkerInspectorDelegate(std::shared_ptr<NodeWorkers> workers)
                                        : workers_(workers) {}

  void WorkerCreated(const std::string& title,
                     const std::string& url,
                     bool waiting,
                     std::shared_ptr<MainThreadHandle> target) override {
    workers_->WorkerCreated(title, url, waiting, target);
  }

 private:
  std::shared_ptr<NodeWorkers> workers_;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5385,88521,ParentInspectorSessionDelegate,4,node.inspector.protocol.anonymous_namespace_4.ParentInspectorSessionDelegate,,inspector\worker_agent.cc,"class ParentInspectorSessionDelegate : public InspectorSessionDelegate {
 public:
  ParentInspectorSessionDelegate(const std::string& id,
                                 std::shared_ptr<NodeWorkers> workers)
                                 : id_(id), workers_(workers) {}

  ~ParentInspectorSessionDelegate() override {
    workers_->Detached(id_);
  }

  void SendMessageToFrontend(const v8_inspector::StringView& msg) override {
    std::string message = protocol::StringUtil::StringViewToUtf8(msg);
    workers_->Send(id_, message);
  }

 private:
  std::string id_;
  std::shared_ptr<NodeWorkers> workers_;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5386,88907,WorkerManagerEventHandle,4,node.inspector.WorkerManagerEventHandle,,inspector\worker_agent.hpp,class WorkerManagerEventHandle,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5387,88908,WorkerManager,4,node.inspector.WorkerManager,,inspector\worker_agent.hpp,class WorkerManager,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5388,88910,NodeWorkers,4,node.inspector.protocol.NodeWorkers,,inspector\worker_agent.hpp,class NodeWorkers,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5389,88911,WorkerAgent,4,node.inspector.protocol.WorkerAgent,,inspector\worker_agent.hpp,"class WorkerAgent : public NodeWorker::Backend {
 public:
  explicit WorkerAgent(std::weak_ptr<WorkerManager> manager);
  ~WorkerAgent() override = default;

  void Wire(UberDispatcher* dispatcher);

  DispatchResponse sendMessageToWorker(const String& message,
                                       const String& sessionId) override;

  DispatchResponse enable(bool waitForDebuggerOnStart) override;
  DispatchResponse disable() override;
  DispatchResponse detach(const String& sessionId) override;

 private:
  std::shared_ptr<NodeWorker::Frontend> frontend_;
  std::weak_ptr<WorkerManager> manager_;
  std::unique_ptr<WorkerManagerEventHandle> event_handle_;
  std::shared_ptr<NodeWorkers> workers_;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5390,88966,WorkerStartedRequest,4,node.inspector.anonymous_namespace_1.WorkerStartedRequest,,inspector\worker_inspector.cc,"class WorkerStartedRequest : public Request {
 public:
  WorkerStartedRequest(
      uint64_t id,
      const std::string& url,
      std::shared_ptr<node::inspector::MainThreadHandle> worker_thread,
      bool waiting,
      const std::string& name)
      : id_(id),
        info_(BuildWorkerTitle(id, name), url, worker_thread),
        waiting_(waiting) {}
  void Call(MainThreadInterface* thread) override {
    auto manager = thread->inspector_agent()->GetWorkerManager();
    manager->WorkerStarted(id_, info_, waiting_);
  }

 private:
  static std::string BuildWorkerTitle(int id, const std::string& name) {
    return ""[worker "" + std::to_string(id) + ""]"" +
           (name == """" ? """" : "" "" + name);
  }

  uint64_t id_;
  WorkerInfo info_;
  bool waiting_;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5391,89052,WorkerFinishedRequest,4,node.inspector.anonymous_namespace_6.WorkerFinishedRequest,,inspector\worker_inspector.cc,"class WorkerFinishedRequest : public Request {
 public:
  explicit WorkerFinishedRequest(uint64_t worker_id) : worker_id_(worker_id) {}

  void Call(MainThreadInterface* thread) override {
    thread->inspector_agent()->GetWorkerManager()->WorkerFinished(worker_id_);
  }

 private:
  uint64_t worker_id_;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5392,89330,InspectorSession,4,node.inspector.InspectorSession,,inspector\worker_inspector.hpp,class InspectorSession,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5393,89331,InspectorSessionDelegate,4,node.inspector.InspectorSessionDelegate,,inspector\worker_inspector.hpp,class InspectorSessionDelegate,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5394,89332,MainThreadHandle,4,node.inspector.MainThreadHandle,,inspector\worker_inspector.hpp,class MainThreadHandle,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5395,89333,WorkerManager,4,node.inspector.WorkerManager,,inspector\worker_inspector.hpp,class WorkerManager,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5396,89334,WorkerDelegate,4,node.inspector.WorkerDelegate,,inspector\worker_inspector.hpp,"class WorkerDelegate {
 public:
  virtual void WorkerCreated(const std::string& title,
                             const std::string& url,
                             bool waiting,
                             std::shared_ptr<MainThreadHandle> worker) = 0;
  virtual ~WorkerDelegate() = default;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5397,89347,WorkerManagerEventHandle,4,node.inspector.WorkerManagerEventHandle,,inspector\worker_inspector.hpp,"class WorkerManagerEventHandle {
 public:
  explicit WorkerManagerEventHandle(std::shared_ptr<WorkerManager> manager,
                                    int id)
                                    : manager_(manager), id_(id) {}
  void SetWaitOnStart(bool wait_on_start);
  ~WorkerManagerEventHandle();

 private:
  std::shared_ptr<WorkerManager> manager_;
  int id_;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5398,89365,WorkerInfo,4,node.inspector.WorkerInfo,,inspector\worker_inspector.hpp,"struct WorkerInfo {
  WorkerInfo(const std::string& target_title,
             const std::string& target_url,
             std::shared_ptr<MainThreadHandle> worker_thread)
             : title(target_title),
               url(target_url),
               worker_thread(worker_thread) {}
  std::string title;
  std::string url;
  std::shared_ptr<MainThreadHandle> worker_thread;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5399,89376,ParentInspectorHandle,4,node.inspector.ParentInspectorHandle,,inspector\worker_inspector.hpp,"class ParentInspectorHandle {
 public:
  ParentInspectorHandle(uint64_t id,
                        const std::string& url,
                        std::shared_ptr<MainThreadHandle> parent_thread,
                        bool wait_for_connect,
                        const std::string& name);
  ~ParentInspectorHandle();
  std::unique_ptr<ParentInspectorHandle> NewParentInspectorHandle(
      uint64_t thread_id, const std::string& url, const std::string& name) {
    return std::make_unique<ParentInspectorHandle>(
        thread_id, url, parent_thread_, wait_, name);
  }
  void WorkerStarted(std::shared_ptr<MainThreadHandle> worker_thread,
                     bool waiting);
  bool WaitForConnect() {
    return wait_;
  }
  const std::string& url() const { return url_; }
  std::unique_ptr<inspector::InspectorSession> Connect(
      std::unique_ptr<inspector::InspectorSessionDelegate> delegate,
      bool prevent_shutdown);

 private:
  uint64_t id_;
  std::string url_;
  std::shared_p...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5400,89440,WorkerManager,4,node.inspector.WorkerManager,,inspector\worker_inspector.hpp,"class WorkerManager : public std::enable_shared_from_this<WorkerManager> {
 public:
  explicit WorkerManager(std::shared_ptr<MainThreadHandle> thread)
                         : thread_(thread) {}

  std::unique_ptr<ParentInspectorHandle> NewParentHandle(
      uint64_t thread_id, const std::string& url, const std::string& name);
  void WorkerStarted(uint64_t session_id, const WorkerInfo& info, bool waiting);
  void WorkerFinished(uint64_t session_id);
  std::unique_ptr<WorkerManagerEventHandle> SetAutoAttach(
      std::unique_ptr<WorkerDelegate> attach_delegate);
  void SetWaitOnStartForDelegate(int id, bool wait);
  void RemoveAttachDelegate(int id);
  std::shared_ptr<MainThreadHandle> MainThread() {
    return thread_;
  }

 private:
  std::shared_ptr<MainThreadHandle> thread_;
  std::unordered_map<uint64_t, WorkerInfo> children_;
  std::unordered_map<int, std::unique_ptr<WorkerDelegate>> delegates_;
  // If any one needs it, workers stop for all
  std::unordered_set<int> delega...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5401,89508,NodeInspectorClient,4,node.inspector.NodeInspectorClient,,inspector_agent.cc,"class NodeInspectorClient : public V8InspectorClient {
 public:
  explicit NodeInspectorClient(node::Environment* env, bool is_main)
      : env_(env), is_main_(is_main) {
    client_ = V8Inspector::create(env->isolate(), this);
    // TODO(bnoordhuis) Make name configurable from src/node.cc.
    std::string name =
        is_main_ ? GetHumanReadableProcessName() : GetWorkerLabel(env);
    ContextInfo info(name);
    info.is_default = true;
    contextCreated(env->context(), info);
  }

  void runMessageLoopOnPause(int context_group_id) override {
    waiting_for_resume_ = true;
    runMessageLoop();
  }

  void waitForSessionsDisconnect() {
    waiting_for_sessions_disconnect_ = true;
    runMessageLoop();
  }

  void waitForFrontend() {
    waiting_for_frontend_ = true;
    runMessageLoop();
  }

  void maxAsyncCallStackDepthChanged(int depth) override {
    if (waiting_for_sessions_disconnect_) {
      // V8 isolate is mostly done and is only letting Inspector protocol
      // c...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5402,89709,ChannelImpl,4,node.inspector.anonymous_namespace_17.ChannelImpl,,inspector_agent.cc,"class ChannelImpl final : public v8_inspector::V8Inspector::Channel,
                          public protocol::FrontendChannel {
 public:
  explicit ChannelImpl(Environment* env,
                       const std::unique_ptr<V8Inspector>& inspector,
                       std::shared_ptr<WorkerManager> worker_manager,
                       std::unique_ptr<InspectorSessionDelegate> delegate,
                       std::shared_ptr<MainThreadHandle> main_thread_,
                       bool prevent_shutdown)
      : delegate_(std::move(delegate)), prevent_shutdown_(prevent_shutdown),
        retaining_context_(false) {
    session_ = inspector->connect(CONTEXT_GROUP_ID,
                                  this,
                                  StringView(),
                                  V8Inspector::ClientTrustLevel::kFullyTrusted);
    node_dispatcher_ = std::make_unique<protocol::UberDispatcher>(this);
    tracing_agent_ =
        std::make_unique<protocol::TracingAgent>(env, mai...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5403,90050,Serializable,4,Serializable,,inspector_agent.cc,using Serializable = protocol::Serializable;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5404,90089,SameThreadInspectorSession,4,node.inspector.anonymous_namespace_33.SameThreadInspectorSession,,inspector_agent.cc,"class SameThreadInspectorSession : public InspectorSession {
 public:
  SameThreadInspectorSession(
      int session_id, std::shared_ptr<NodeInspectorClient> client)
      : session_id_(session_id), client_(client) {}
  ~SameThreadInspectorSession() override;
  void Dispatch(const v8_inspector::StringView& message) override;

 private:
  int session_id_;
  std::weak_ptr<NodeInspectorClient> client_;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5405,91991,RequestQueueData,4,node.inspector.anonymous_namespace_9.RequestQueueData,,inspector_io.cc,"class RequestQueueData {
 public:
  using MessageQueue = std::deque<RequestToServer>;

  explicit RequestQueueData(uv_loop_t* loop)
                            : handle_(std::make_shared<RequestQueue>(this)) {
    int err = uv_async_init(loop, &async_, [](uv_async_t* async) {
      RequestQueueData* wrapper =
          node::ContainerOf(&RequestQueueData::async_, async);
      wrapper->DoDispatch();
    });
    CHECK_EQ(0, err);
  }

  static void CloseAndFree(RequestQueueData* queue);

  void Post(int session_id,
            TransportAction action,
            std::unique_ptr<StringBuffer> message) {
    Mutex::ScopedLock scoped_lock(state_lock_);
    bool notify = messages_.empty();
    messages_.emplace_back(action, session_id, std::move(message));
    if (notify) {
      CHECK_EQ(0, uv_async_send(&async_));
      incoming_message_cond_.Broadcast(scoped_lock);
    }
  }

  void Wait() {
    Mutex::ScopedLock scoped_lock(state_lock_);
    if (messages_.empty()) {
      incoming_me...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5406,92057,TransportAction,4,node.inspector.anonymous_namespace_3.TransportAction,,inspector_io.cc,"enum class TransportAction { kKill, kSendMessage, kStop }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5407,92170,RequestToServer,4,node.inspector.anonymous_namespace_6.RequestToServer,,inspector_io.cc,"class RequestToServer {
 public:
  RequestToServer(TransportAction action,
                  int session_id,
                  std::unique_ptr<v8_inspector::StringBuffer> message)
                  : action_(action),
                    session_id_(session_id),
                    message_(std::move(message)) {}

  void Dispatch(InspectorSocketServer* server) const {
    switch (action_) {
      case TransportAction::kKill:
        server->TerminateConnections();
        [[fallthrough]];
      case TransportAction::kStop:
        server->Stop();
        break;
      case TransportAction::kSendMessage:
        server->Send(
            session_id_,
            protocol::StringUtil::StringViewToUtf8(message_->string()));
        break;
    }
  }

 private:
  TransportAction action_;
  int session_id_;
  std::unique_ptr<v8_inspector::StringBuffer> message_;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5408,92226,MessageQueue,4,MessageQueue,,inspector_io.cc,using MessageQueue = std::deque<RequestToServer>;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5409,92372,RequestQueue,4,node.inspector.RequestQueue,,inspector_io.cc,"class RequestQueue {
 public:
  explicit RequestQueue(RequestQueueData* data) : data_(data) {}

  void Reset() {
    Mutex::ScopedLock scoped_lock(lock_);
    data_ = nullptr;
  }

  void Post(int session_id,
            TransportAction action,
            std::unique_ptr<StringBuffer> message) {
    Mutex::ScopedLock scoped_lock(lock_);
    if (data_ != nullptr)
      data_->Post(session_id, action, std::move(message));
  }

  bool Expired() {
    Mutex::ScopedLock scoped_lock(lock_);
    return data_ == nullptr;
  }

 private:
  RequestQueueData* data_;
  Mutex lock_;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5410,92427,IoSessionDelegate,4,node.inspector.IoSessionDelegate,,inspector_io.cc,"class IoSessionDelegate : public InspectorSessionDelegate {
 public:
  explicit IoSessionDelegate(std::shared_ptr<RequestQueue> queue, int id)
                             : request_queue_(queue), id_(id) { }
  void SendMessageToFrontend(const v8_inspector::StringView& message) override {
    request_queue_->Post(id_, TransportAction::kSendMessage,
                         StringBuffer::create(message));
  }

 private:
  std::shared_ptr<RequestQueue> request_queue_;
  int id_;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5411,92454,InspectorIoDelegate,4,node.inspector.InspectorIoDelegate,,inspector_io.cc,"class InspectorIoDelegate: public node::inspector::SocketServerDelegate {
 public:
  InspectorIoDelegate(std::shared_ptr<RequestQueueData> queue,
                      std::shared_ptr<MainThreadHandle> main_thread,
                      const std::string& target_id,
                      const std::string& script_path,
                      const std::string& script_name);
  ~InspectorIoDelegate() override = default;

  void StartSession(int session_id, const std::string& target_id) override;
  void MessageReceived(int session_id, const std::string& message) override;
  void EndSession(int session_id) override;

  std::vector<std::string> GetTargetIds() override;
  std::string GetTargetTitle(const std::string& id) override;
  std::string GetTargetUrl(const std::string& id) override;
  void AssignServer(InspectorSocketServer* server) override {
    request_queue_->SetServer(server);
  }

 private:
  std::shared_ptr<RequestQueueData> request_queue_;
  std::shared_ptr<MainThreadHandle>...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5412,92982,LocalConnection,4,node.inspector.anonymous_namespace_18.LocalConnection,,inspector_js_api.cc,"struct LocalConnection {
  static std::unique_ptr<InspectorSession> Connect(
      Agent* inspector, std::unique_ptr<InspectorSessionDelegate> delegate) {
    return inspector->Connect(std::move(delegate), false);
  }

  static Local<String> GetClassName(Environment* env) {
    return FIXED_ONE_BYTE_STRING(env->isolate(), ""Connection"");
  }
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5413,93012,MainThreadConnection,4,node.inspector.anonymous_namespace_21.MainThreadConnection,,inspector_js_api.cc,"struct MainThreadConnection {
  static std::unique_ptr<InspectorSession> Connect(
      Agent* inspector, std::unique_ptr<InspectorSessionDelegate> delegate) {
    return inspector->ConnectToMainThread(std::move(delegate), true);
  }

  static Local<String> GetClassName(Environment* env) {
    return FIXED_ONE_BYTE_STRING(env->isolate(), ""MainThreadConnection"");
  }
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5414,93042,JSBindingsConnection,4,node.inspector.anonymous_namespace_24.JSBindingsConnection,,inspector_js_api.cc,"class JSBindingsConnection : public AsyncWrap {
 public:
  class JSBindingsSessionDelegate : public InspectorSessionDelegate {
   public:
    JSBindingsSessionDelegate(Environment* env,
                              JSBindingsConnection* connection)
                              : env_(env),
                                connection_(connection) {
    }

    void SendMessageToFrontend(const v8_inspector::StringView& message)
        override {
      Isolate* isolate = env_->isolate();
      HandleScope handle_scope(isolate);
      Context::Scope context_scope(env_->context());
      Local<Value> argument;
      if (!String::NewFromTwoByte(isolate, message.characters16(),
                                  NewStringType::kNormal,
                                  message.length()).ToLocal(&argument)) return;
      connection_->OnMessage(argument);
    }

   private:
    Environment* env_;
    BaseObjectPtr<JSBindingsConnection> connection_;
  };

  JSBindingsConnection(Environment* e...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5415,93043,JSBindingsSessionDelegate,4,node.inspector.anonymous_namespace_25.JSBindingsConnection.JSBindingsSessionDelegate,,inspector_js_api.cc,"class JSBindingsSessionDelegate : public InspectorSessionDelegate {
   public:
    JSBindingsSessionDelegate(Environment* env,
                              JSBindingsConnection* connection)
                              : env_(env),
                                connection_(connection) {
    }

    void SendMessageToFrontend(const v8_inspector::StringView& message)
        override {
      Isolate* isolate = env_->isolate();
      HandleScope handle_scope(isolate);
      Context::Scope context_scope(env_->context());
      Local<Value> argument;
      if (!String::NewFromTwoByte(isolate, message.characters16(),
                                  NewStringType::kNormal,
                                  message.length()).ToLocal(&argument)) return;
      connection_->OnMessage(argument);
    }

   private:
    Environment* env_;
    BaseObjectPtr<JSBindingsConnection> connection_;
  }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5416,96096,TcpHolder,4,node.inspector.TcpHolder,,inspector_socket.cc,"class TcpHolder {
 public:
  static void DisconnectAndDispose(TcpHolder* holder);
  using Pointer = DeleteFnPtr<TcpHolder, DisconnectAndDispose>;

  static Pointer Accept(uv_stream_t* server,
                        InspectorSocket::DelegatePointer delegate);
  void SetHandler(ProtocolHandler* handler);
  int WriteRaw(const std::vector<char>& buffer, uv_write_cb write_cb);
  uv_tcp_t* tcp() {
    return &tcp_;
  }
  InspectorSocket::Delegate* delegate();

 private:
  static TcpHolder* From(void* handle) {
    return node::ContainerOf(&TcpHolder::tcp_,
                             reinterpret_cast<uv_tcp_t*>(handle));
  }
  static void OnClosed(uv_handle_t* handle);
  static void OnDataReceivedCb(uv_stream_t* stream, ssize_t nread,
                               const uv_buf_t* buf);
  explicit TcpHolder(InspectorSocket::DelegatePointer delegate);
  ~TcpHolder() = default;
  void ReclaimUvBuf(const uv_buf_t* buf, ssize_t read);

  uv_tcp_t tcp_;
  const InspectorSocket::DelegatePoint...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5417,96102,Pointer,4,Pointer,,inspector_socket.cc,"using Pointer = DeleteFnPtr<TcpHolder, DisconnectAndDispose>;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5418,96179,ProtocolHandler,4,node.inspector.ProtocolHandler,,inspector_socket.cc,"class ProtocolHandler {
 public:
  ProtocolHandler(InspectorSocket* inspector, TcpHolder::Pointer tcp);

  virtual void AcceptUpgrade(const std::string& accept_key) = 0;
  virtual void OnData(std::vector<char>* data) = 0;
  virtual void OnEof() = 0;
  virtual void Write(const std::vector<char> data) = 0;
  virtual void CancelHandshake() = 0;

  std::string GetHost() const;

  InspectorSocket* inspector() {
    return inspector_;
  }
  virtual void Shutdown() = 0;

 protected:
  virtual ~ProtocolHandler() = default;
  int WriteRaw(const std::vector<char>& buffer, uv_write_cb write_cb);
  InspectorSocket::Delegate* delegate();

  InspectorSocket* const inspector_;
  TcpHolder::Pointer tcp_;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5419,96240,WriteRequest,4,node.inspector.anonymous_namespace_1.WriteRequest,,inspector_socket.cc,"class WriteRequest {
 public:
  WriteRequest(ProtocolHandler* handler, const std::vector<char>& buffer)
      : handler(handler)
      , storage(buffer)
      , req(uv_write_t())
      , buf(uv_buf_init(storage.data(), storage.size())) {}

  static WriteRequest* from_write_req(uv_write_t* req) {
    return node::ContainerOf(&WriteRequest::req, req);
  }

  static void Cleanup(uv_write_t* req, int status) {
    delete WriteRequest::from_write_req(req);
  }

  ProtocolHandler* const handler;
  std::vector<char> storage;
  uv_write_t req;
  uv_buf_t buf;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5420,96318,ws_decode_result,4,node.inspector.anonymous_namespace_8.ws_decode_result,,inspector_socket.cc,"enum ws_decode_result {
  FRAME_OK, FRAME_INCOMPLETE, FRAME_CLOSE, FRAME_ERROR
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5421,96567,OpCode,4,OpCode,,inspector_socket.cc,typedef int OpCode;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5422,97076,WsHandler,4,node.inspector.anonymous_namespace_15.WsHandler,,inspector_socket.cc,"class WsHandler : public ProtocolHandler {
 public:
  WsHandler(InspectorSocket* inspector, TcpHolder::Pointer tcp)
            : ProtocolHandler(inspector, std::move(tcp)),
              OnCloseSent(&WsHandler::WaitForCloseReply),
              OnCloseReceived(&WsHandler::CloseFrameReceived),
              dispose_(false) { }

  void AcceptUpgrade(const std::string& accept_key) override { }
  void CancelHandshake() override {}

  void OnEof() override {
    tcp_.reset();
    if (dispose_)
      delete this;
  }

  void OnData(std::vector<char>* data) override {
    // 1. Parse.
    int processed = 0;
    do {
      processed = ParseWsFrames(*data);
      // 2. Fix the data size & length
      if (processed > 0) {
        remove_from_beginning(data, processed);
      }
    } while (processed > 0 && !data->empty());
  }

  void Write(const std::vector<char> data) override {
    std::vector<char> output = encode_frame_hybi17(data);
    WriteRaw(output, WriteRequest::Cleanup);
  }

 pr...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5423,97168,Callback,4,Callback,,inspector_socket.cc,using Callback = void (WsHandler::*)();,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5424,97307,HttpEvent,4,node.inspector.anonymous_namespace_36.HttpEvent,,inspector_socket.cc,"class HttpEvent {
 public:
  HttpEvent(const std::string& path, bool upgrade, bool isGET,
            const std::string& ws_key, const std::string& host)
            : path(path), upgrade(upgrade), isGET(isGET), ws_key(ws_key),
              host(host) { }

  std::string path;
  bool upgrade;
  bool isGET;
  std::string ws_key;
  std::string host;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5425,97322,HttpHandler,4,node.inspector.anonymous_namespace_38.HttpHandler,,inspector_socket.cc,"class HttpHandler : public ProtocolHandler {
 public:
  explicit HttpHandler(InspectorSocket* inspector, TcpHolder::Pointer tcp)
                       : ProtocolHandler(inspector, std::move(tcp)),
                         parsing_value_(false) {
    llhttp_init(&parser_, HTTP_REQUEST, &parser_settings);
    llhttp_settings_init(&parser_settings);
    parser_settings.on_header_field = OnHeaderField;
    parser_settings.on_header_value = OnHeaderValue;
    parser_settings.on_message_complete = OnMessageComplete;
    parser_settings.on_url = OnPath;
  }

  void AcceptUpgrade(const std::string& accept_key) override {
    char accept_string[ACCEPT_KEY_LENGTH];
    generate_accept_string(accept_key, &accept_string);
    const char accept_ws_prefix[] = ""HTTP/1.1 101 Switching Protocols\r\n""
                                    ""Upgrade: websocket\r\n""
                                    ""Connection: Upgrade\r\n""
                                    ""Sec-WebSocket-Accept: "";
    const char a...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5426,98839,SocketSession,4,node.inspector.SocketSession,,inspector_socket_server.cc,"class SocketSession {
 public:
  SocketSession(InspectorSocketServer* server, int id, int server_port);
  void Close() {
    ws_socket_.reset();
  }
  void Send(const std::string& message);
  void Own(InspectorSocket::Pointer ws_socket) {
    ws_socket_ = std::move(ws_socket);
  }
  int id() const { return id_; }
  int server_port() {
    return server_port_;
  }
  InspectorSocket* ws_socket() {
    return ws_socket_.get();
  }
  void Accept(const std::string& ws_key) {
    ws_socket_->AcceptUpgrade(ws_key);
  }
  void Decline() {
    ws_socket_->CancelHandshake();
  }

  class Delegate : public InspectorSocket::Delegate {
   public:
    Delegate(InspectorSocketServer* server, int session_id)
             : server_(server), session_id_(session_id) { }
    ~Delegate() override {
      server_->SessionTerminated(session_id_);
    }
    void OnHttpGet(const std::string& host, const std::string& path) override;
    void OnSocketUpgrade(const std::string& host, const std::string& path,
 ...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5427,98911,Delegate,4,node.inspector.SocketSession.Delegate,,inspector_socket_server.cc,"class Delegate : public InspectorSocket::Delegate {
   public:
    Delegate(InspectorSocketServer* server, int session_id)
             : server_(server), session_id_(session_id) { }
    ~Delegate() override {
      server_->SessionTerminated(session_id_);
    }
    void OnHttpGet(const std::string& host, const std::string& path) override;
    void OnSocketUpgrade(const std::string& host, const std::string& path,
                         const std::string& ws_key) override;
    void OnWsFrame(const std::vector<char>& data) override;

   private:
    SocketSession* Session() {
      return server_->Session(session_id_);
    }

    InspectorSocketServer* server_;
    int session_id_;
  }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5428,98960,ServerSocket,4,node.inspector.ServerSocket,,inspector_socket_server.cc,"class ServerSocket {
 public:
  explicit ServerSocket(InspectorSocketServer* server)
                        : tcp_socket_(uv_tcp_t()), server_(server) {}
  int Listen(sockaddr* addr, uv_loop_t* loop);
  void Close() {
    uv_close(reinterpret_cast<uv_handle_t*>(&tcp_socket_), FreeOnCloseCallback);
  }
  int port() const { return port_; }

 private:
  template <typename UvHandle>
  static ServerSocket* FromTcpSocket(UvHandle* socket) {
    return node::ContainerOf(&ServerSocket::tcp_socket_,
                             reinterpret_cast<uv_tcp_t*>(socket));
  }
  static void SocketConnectedCallback(uv_stream_t* tcp_socket, int status);
  static void FreeOnCloseCallback(uv_handle_t* tcp_socket_) {
    delete FromTcpSocket(tcp_socket_);
  }
  int DetectPort();
  ~ServerSocket() = default;

  uv_tcp_t tcp_socket_;
  InspectorSocketServer* server_;
  int port_ = -1;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5429,101044,napi_env__,4,napi_env__,,js_native_api_types.hpp,typedef struct napi_env__,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5430,101045,napi_env,4,napi_env,,js_native_api_types.hpp,typedef struct napi_env__* napi_env;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5431,101046,napi_value__,4,napi_value__,,js_native_api_types.hpp,typedef struct napi_value__,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5432,101047,napi_value,4,napi_value,,js_native_api_types.hpp,typedef struct napi_value__* napi_value;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5433,101048,napi_ref__,4,napi_ref__,,js_native_api_types.hpp,typedef struct napi_ref__,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5434,101049,napi_ref,4,napi_ref,,js_native_api_types.hpp,typedef struct napi_ref__* napi_ref;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5435,101050,napi_handle_scope__,4,napi_handle_scope__,,js_native_api_types.hpp,typedef struct napi_handle_scope__,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5436,101051,napi_handle_scope,4,napi_handle_scope,,js_native_api_types.hpp,typedef struct napi_handle_scope__* napi_handle_scope;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5437,101052,napi_escapable_handle_scope__,4,napi_escapable_handle_scope__,,js_native_api_types.hpp,typedef struct napi_escapable_handle_scope__,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5438,101053,napi_escapable_handle_scope,4,napi_escapable_handle_scope,,js_native_api_types.hpp,typedef struct napi_escapable_handle_scope__* napi_escapable_handle_scope;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5439,101054,napi_callback_info__,4,napi_callback_info__,,js_native_api_types.hpp,typedef struct napi_callback_info__,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5440,101055,napi_callback_info,4,napi_callback_info,,js_native_api_types.hpp,typedef struct napi_callback_info__* napi_callback_info;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5441,101056,napi_deferred__,4,napi_deferred__,,js_native_api_types.hpp,typedef struct napi_deferred__,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5442,101057,napi_deferred,4,napi_deferred,,js_native_api_types.hpp,typedef struct napi_deferred__* napi_deferred;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5443,101058,napi_property_attributes,4,napi_property_attributes,,js_native_api_types.hpp,"typedef enum {
  napi_default = 0,
  napi_writable = 1 << 0,
  napi_enumerable = 1 << 1,
  napi_configurable = 1 << 2,

  // Used with napi_define_class to distinguish static properties
  // from instance properties. Ignored by napi_define_properties.
  napi_static = 1 << 10,

#if NAPI_VERSION >= 8
  // Default for class methods.
  napi_default_method = napi_writable | napi_configurable,

  // Default for object properties, like in JS obj[prop].
  napi_default_jsproperty = napi_writable | napi_enumerable | napi_configurable,
#endif  // NAPI_VERSION >= 8
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5444,101092,napi_valuetype,4,napi_valuetype,,js_native_api_types.hpp,"typedef enum {
  // ES6 types (corresponds to typeof)
  napi_undefined,
  napi_null,
  napi_boolean,
  napi_number,
  napi_string,
  napi_symbol,
  napi_object,
  napi_function,
  napi_external,
  napi_bigint,
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5445,101104,napi_typedarray_type,4,napi_typedarray_type,,js_native_api_types.hpp,"typedef enum {
  napi_int8_array,
  napi_uint8_array,
  napi_uint8_clamped_array,
  napi_int16_array,
  napi_uint16_array,
  napi_int32_array,
  napi_uint32_array,
  napi_float32_array,
  napi_float64_array,
  napi_bigint64_array,
  napi_biguint64_array,
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5446,101117,napi_status,4,napi_status,,js_native_api_types.hpp,"typedef enum {
  napi_ok,
  napi_invalid_arg,
  napi_object_expected,
  napi_string_expected,
  napi_name_expected,
  napi_function_expected,
  napi_number_expected,
  napi_boolean_expected,
  napi_array_expected,
  napi_generic_failure,
  napi_pending_exception,
  napi_cancelled,
  napi_escape_called_twice,
  napi_handle_scope_mismatch,
  napi_callback_scope_mismatch,
  napi_queue_full,
  napi_closing,
  napi_bigint_expected,
  napi_date_expected,
  napi_arraybuffer_expected,
  napi_detachable_arraybuffer_expected,
  napi_would_deadlock,  // unused
  napi_no_external_buffers_allowed
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5447,101155,napi_property_descriptor,4,napi_property_descriptor,,js_native_api_types.hpp,"typedef struct {
  // One of utf8name or name should be NULL.
  const char* utf8name;
  napi_value name;

  napi_callback method;
  napi_callback getter;
  napi_callback setter;
  napi_value value;

  napi_property_attributes attributes;
  void* data;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5448,101165,napi_extended_error_info,4,napi_extended_error_info,,js_native_api_types.hpp,"typedef struct {
  const char* error_message;
  void* engine_reserved;
  uint32_t engine_error_code;
  napi_status error_code;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5449,101186,CallbackWrapperBase,4,v8impl.anonymous_namespace_31.CallbackWrapperBase,,js_native_api_v8.cc,"class CallbackWrapperBase : public CallbackWrapper {
 public:
  inline CallbackWrapperBase(const v8::FunctionCallbackInfo<v8::Value>& cbinfo,
                             const size_t args_length)
      : CallbackWrapper(
            JsValueFromV8LocalValue(cbinfo.This()), args_length, nullptr),
        _cbinfo(cbinfo) {
    _bundle = reinterpret_cast<CallbackBundle*>(
        cbinfo.Data().As<v8::External>()->Value());
    _data = _bundle->cb_data;
  }

 protected:
  inline void InvokeCallback() {
    napi_callback_info cbinfo_wrapper = reinterpret_cast<napi_callback_info>(
        static_cast<CallbackWrapper*>(this));

    // All other pointers we need are stored in `_bundle`
    napi_env env = _bundle->env;
    napi_callback cb = _bundle->cb;

    napi_value result = nullptr;
    bool exceptionOccurred = false;
    env->CallIntoModule([&](napi_env env) { result = cb(env, cbinfo_wrapper); },
                        [&](napi_env env, v8::Local<v8::Value> value) {
                  ...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5450,101488,HandleScopeWrapper,4,v8impl.anonymous_namespace_5.HandleScopeWrapper,,js_native_api_v8.cc,"class HandleScopeWrapper {
 public:
  explicit HandleScopeWrapper(v8::Isolate* isolate) : scope(isolate) {}

 private:
  v8::HandleScope scope;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5451,101495,EscapableHandleScopeWrapper,4,v8impl.anonymous_namespace_7.EscapableHandleScopeWrapper,,js_native_api_v8.cc,"class EscapableHandleScopeWrapper {
 public:
  explicit EscapableHandleScopeWrapper(v8::Isolate* isolate)
      : scope(isolate), escape_called_(false) {}
  bool escape_called() const { return escape_called_; }
  template <typename T>
  v8::Local<T> Escape(v8::Local<T> handle) {
    escape_called_ = true;
    return scope.Escape(handle);
  }

 private:
  v8::EscapableHandleScope scope;
  bool escape_called_;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5452,101741,UnwrapAction,4,v8impl.anonymous_namespace_17.UnwrapAction,,js_native_api_v8.cc,"enum UnwrapAction { KeepWrap, RemoveWrap }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5453,102022,CallbackBundle,4,v8impl.anonymous_namespace_19.CallbackBundle,,js_native_api_v8.cc,"class CallbackBundle {
 public:
  // Creates an object to be made available to the static function callback
  // wrapper, used to retrieve the native callback function and data pointer.
  static inline v8::Local<v8::Value> New(napi_env env,
                                         napi_callback cb,
                                         void* data) {
    CallbackBundle* bundle = new CallbackBundle();
    bundle->cb = cb;
    bundle->cb_data = data;
    bundle->env = env;

    v8::Local<v8::Value> cbdata = v8::External::New(env->isolate, bundle);
    Reference::New(
        env, cbdata, 0, Ownership::kRuntime, Delete, bundle, nullptr);
    return cbdata;
  }
  napi_env env;   // Necessary to invoke C++ NAPI callback
  void* cb_data;  // The user provided callback data
  napi_callback cb;

 private:
  static void Delete(napi_env env, void* data, void* hint) {
    CallbackBundle* bundle = static_cast<CallbackBundle*>(data);
    delete bundle;
  }
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5454,102103,CallbackWrapper,4,v8impl.anonymous_namespace_23.CallbackWrapper,,js_native_api_v8.cc,"class CallbackWrapper {
 public:
  inline CallbackWrapper(napi_value this_arg, size_t args_length, void* data)
      : _this(this_arg), _args_length(args_length), _data(data) {}

  virtual napi_value GetNewTarget() = 0;
  virtual void Args(napi_value* buffer, size_t bufferlength) = 0;
  virtual void SetReturnValue(napi_value value) = 0;

  napi_value This() { return _this; }

  size_t ArgsLength() { return _args_length; }

  void* Data() { return _data; }

 protected:
  const napi_value _this;
  const size_t _args_length;
  void* _data;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5455,102221,FunctionCallbackWrapper,4,v8impl.anonymous_namespace_36.FunctionCallbackWrapper,,js_native_api_v8.cc,"class FunctionCallbackWrapper : public CallbackWrapperBase {
 public:
  static void Invoke(const v8::FunctionCallbackInfo<v8::Value>& info) {
    FunctionCallbackWrapper cbwrapper(info);
    cbwrapper.InvokeCallback();
  }

  static inline napi_status NewFunction(napi_env env,
                                        napi_callback cb,
                                        void* cb_data,
                                        v8::Local<v8::Function>* result) {
    v8::Local<v8::Value> cbdata = v8impl::CallbackBundle::New(env, cb, cb_data);
    RETURN_STATUS_IF_FALSE(env, !cbdata.IsEmpty(), napi_generic_failure);

    v8::MaybeLocal<v8::Function> maybe_function =
        v8::Function::New(env->context(), Invoke, cbdata);
    CHECK_MAYBE_EMPTY(env, maybe_function, napi_generic_failure);

    *result = maybe_function.ToLocalChecked();
    return napi_clear_last_error(env);
  }

  static inline napi_status NewTemplate(
      napi_env env,
      napi_callback cb,
      void* cb_data,
  ...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5456,121075,napi_env__,4,napi_env__,,js_native_api_v8.hpp,"struct napi_env__ {
  explicit napi_env__(v8::Local<v8::Context> context,
                      int32_t module_api_version)
      : isolate(context->GetIsolate()),
        context_persistent(isolate, context),
        module_api_version(module_api_version) {
    napi_clear_last_error(this);
  }

  inline v8::Local<v8::Context> context() const {
    return v8impl::PersistentToLocal::Strong(context_persistent);
  }

  inline void Ref() { refs++; }
  inline void Unref() {
    if (--refs == 0) DeleteMe();
  }

  virtual bool can_call_into_js() const { return true; }

  static inline void HandleThrow(napi_env env, v8::Local<v8::Value> value) {
    if (env->terminatedOrTerminating()) {
      return;
    }
    env->isolate->ThrowException(value);
  }

  // i.e. whether v8 exited or is about to exit
  inline bool terminatedOrTerminating() {
    return this->isolate->IsExecutionTerminating() || !can_call_into_js();
  }

  // v8 uses a special exception to indicate termination, the
  // `hand...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5457,121090,RefTracker,4,v8impl.RefTracker,,js_native_api_v8.hpp,"class RefTracker {
 public:
  RefTracker() {}
  virtual ~RefTracker() {}
  virtual void Finalize() {}

  typedef RefTracker RefList;

  inline void Link(RefList* list) {
    prev_ = list;
    next_ = list->next_;
    if (next_ != nullptr) {
      next_->prev_ = this;
    }
    list->next_ = this;
  }

  inline void Unlink() {
    if (prev_ != nullptr) {
      prev_->next_ = next_;
    }
    if (next_ != nullptr) {
      next_->prev_ = prev_;
    }
    prev_ = nullptr;
    next_ = nullptr;
  }

  static void FinalizeAll(RefList* list) {
    while (list->next_ != nullptr) {
      list->next_->Finalize();
    }
  }

 private:
  RefList* next_ = nullptr;
  RefList* prev_ = nullptr;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5458,121103,RefList,4,RefList,,js_native_api_v8.hpp,typedef RefTracker RefList;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5459,121192,Finalizer,4,v8impl.Finalizer,,js_native_api_v8.hpp,class Finalizer,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5460,121512,Finalizer,4,v8impl.Finalizer,,js_native_api_v8.hpp,"class Finalizer {
 protected:
  Finalizer(napi_env env,
            napi_finalize finalize_callback,
            void* finalize_data,
            void* finalize_hint)
      : env_(env),
        finalize_callback_(finalize_callback),
        finalize_data_(finalize_data),
        finalize_hint_(finalize_hint) {}

  virtual ~Finalizer() = default;

 public:
  static Finalizer* New(napi_env env,
                        napi_finalize finalize_callback = nullptr,
                        void* finalize_data = nullptr,
                        void* finalize_hint = nullptr) {
    return new Finalizer(env, finalize_callback, finalize_data, finalize_hint);
  }

  napi_finalize callback() { return finalize_callback_; }
  void* data() { return finalize_data_; }
  void* hint() { return finalize_hint_; }

  void ResetFinalizer();

 protected:
  napi_env env_;
  napi_finalize finalize_callback_;
  void* finalize_data_;
  void* finalize_hint_;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5461,121566,TryCatch,4,v8impl.TryCatch,,js_native_api_v8.hpp,"class TryCatch : public v8::TryCatch {
 public:
  explicit TryCatch(napi_env env) : v8::TryCatch(env->isolate), _env(env) {}

  ~TryCatch() {
    if (HasCaught()) {
      _env->last_exception.Reset(_env->isolate, Exception());
    }
  }

 private:
  napi_env _env;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5462,121590,Ownership,4,v8impl.Ownership,,js_native_api_v8.hpp,"enum class Ownership {
  // The reference is owned by the runtime. No userland call is needed to
  // destruct the reference.
  kRuntime,
  // The reference is owned by the userland. User code is responsible to delete
  // the reference with appropriate node-api calls.
  kUserland,
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5463,121593,RefBase,4,v8impl.RefBase,,js_native_api_v8.hpp,"class RefBase : public Finalizer, public RefTracker {
 protected:
  RefBase(napi_env env,
          uint32_t initial_refcount,
          Ownership ownership,
          napi_finalize finalize_callback,
          void* finalize_data,
          void* finalize_hint);

 public:
  static RefBase* New(napi_env env,
                      uint32_t initial_refcount,
                      Ownership ownership,
                      napi_finalize finalize_callback,
                      void* finalize_data,
                      void* finalize_hint);
  virtual ~RefBase();

  void* Data();
  uint32_t Ref();
  uint32_t Unref();
  uint32_t RefCount();

  Ownership ownership() { return ownership_; }

 protected:
  void Finalize() override;

 private:
  uint32_t refcount_;
  Ownership ownership_;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5464,121646,Reference,4,v8impl.Reference,,js_native_api_v8.hpp,"class Reference : public RefBase {
 protected:
  template <typename... Args>
  Reference(napi_env env, v8::Local<v8::Value> value, Args&&... args);

 public:
  static Reference* New(napi_env env,
                        v8::Local<v8::Value> value,
                        uint32_t initial_refcount,
                        Ownership ownership,
                        napi_finalize finalize_callback = nullptr,
                        void* finalize_data = nullptr,
                        void* finalize_hint = nullptr);

  virtual ~Reference();
  uint32_t Ref();
  uint32_t Unref();
  v8::Local<v8::Value> Get();

 protected:
  void Finalize() override;

 private:
  static void WeakCallback(const v8::WeakCallbackInfo<Reference>& data);

  void SetWeak();

  v8impl::Persistent<v8::Value> persistent_;
  bool can_be_weak_;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5465,121710,Persistent,4,Persistent,,js_native_api_v8_internals.hpp,using Persistent = v8::Global<T>;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5466,121711,PersistentToLocal,4,PersistentToLocal,,js_native_api_v8_internals.hpp,using PersistentToLocal = node::PersistentToLocal;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5467,122505,JSUDPWrap,4,node.JSUDPWrap,,js_udp_wrap.cc,"class JSUDPWrap final : public UDPWrapBase, public AsyncWrap {
 public:
  JSUDPWrap(Environment* env, Local<Object> obj);

  int RecvStart() override;
  int RecvStop() override;
  ssize_t Send(uv_buf_t* bufs,
               size_t nbufs,
               const sockaddr* addr) override;
  SocketAddress GetPeerName() override;
  SocketAddress GetSockName() override;
  AsyncWrap* GetAsyncWrap() override { return this; }

  static void New(const FunctionCallbackInfo<Value>& args);
  static void EmitReceived(const FunctionCallbackInfo<Value>& args);
  static void OnSendDone(const FunctionCallbackInfo<Value>& args);
  static void OnAfterBind(const FunctionCallbackInfo<Value>& args);

  static void Initialize(Local<Object> target,
                         Local<Value> unused,
                         Local<Context> context,
                         void* priv);
  SET_NO_MEMORY_INFO()
  SET_MEMORY_INFO_NAME(JSUDPWrap)
  SET_SELF_SIZE(JSUDPWrap)
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5468,127711,V8Platform,4,node.per_process.V8Platform,,node.cc,struct V8Platform,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5469,129657,uv_loop_s,4,uv_loop_s,,node.hpp,struct uv_loop_s,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5470,129659,SnapshotData,4,node.SnapshotData,,node.hpp,struct SnapshotData,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5471,129661,TracingController,4,node.tracing.TracingController,,node.hpp,class TracingController,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5472,129740,IsolateData,4,node.IsolateData,,node.hpp,class IsolateData,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5473,129741,Environment,4,node.Environment,,node.hpp,class Environment,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5474,129742,MultiIsolatePlatform,4,node.MultiIsolatePlatform,,node.hpp,class MultiIsolatePlatform,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5475,129743,InitializationResultImpl,4,node.InitializationResultImpl,,node.hpp,class InitializationResultImpl,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5476,129745,Flags,4,node.ProcessInitializationFlags.Flags,,node.hpp,"enum Flags : uint32_t {
  kNoFlags = 0,
  // Enable stdio inheritance, which is disabled by default.
  // This flag is also implied by kNoStdioInitialization.
  kEnableStdioInheritance = 1 << 0,
  // Disable reading the NODE_OPTIONS environment variable.
  kDisableNodeOptionsEnv = 1 << 1,
  // Do not parse CLI options.
  kDisableCLIOptions = 1 << 2,
  // Do not initialize ICU.
  kNoICU = 1 << 3,
  // Do not modify stdio file descriptor or TTY state.
  kNoStdioInitialization = 1 << 4,
  // Do not register Node.js-specific signal handlers
  // and reset other signal handlers to default state.
  kNoDefaultSignalHandling = 1 << 5,
  // Do not perform V8 initialization.
  kNoInitializeV8 = 1 << 6,
  // Do not initialize a default Node.js-provided V8 platform instance.
  kNoInitializeNodeV8Platform = 1 << 7,
  // Do not initialize OpenSSL config.
  kNoInitOpenSSL = 1 << 8,
  // Do not initialize Node.js debugging based on environment variables.
  kNoParseGlobalDebugVariables = 1 << 9,
  /...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5477,129854,Flags,4,node.StopFlags.Flags,,node.hpp,"enum Flags : uint32_t {
  kNoFlags = 0,
  // Do not explicitly terminate the Isolate
  // when exiting the Environment.
  kDoNotTerminateIsolate = 1 << 0,
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5478,129869,InitializationResult,4,node.InitializationResult,,node.hpp,"class NODE_EXTERN InitializationResult {
 public:
  virtual ~InitializationResult();

  // Returns a suggested process exit code.
  virtual int exit_code() const = 0;

  // Returns 'true' if initialization was aborted early due to errors.
  virtual bool early_return() const = 0;

  // Returns the parsed list of non-Node.js arguments.
  virtual const std::vector<std::string>& args() const = 0;

  // Returns the parsed list of Node.js arguments.
  virtual const std::vector<std::string>& exec_args() const = 0;

  // Returns an array of errors. Note that these may be warnings
  // whose existence does not imply a non-zero exit code.
  virtual const std::vector<std::string>& errors() const = 0;

  // If kNoInitializeNodeV8Platform was not specified, the global Node.js
  // platform instance.
  virtual MultiIsolatePlatform* platform() const = 0;

 private:
  InitializationResult() = default;
  friend class InitializationResultImpl;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5479,129902,InitializationResultImpl,4,node.InitializationResult.InitializationResultImpl,,node.hpp,friend class InitializationResultImpl,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5480,129959,OptionEnvvarSettings,4,node.OptionEnvvarSettings,,node.hpp,"enum OptionEnvvarSettings {
  // Allow the options to be set via the environment variable, like
  // `NODE_OPTIONS`.
  kAllowedInEnvvar = 0,
  // Disallow the options to be set via the environment variable, like
  // `NODE_OPTIONS`.
  kDisallowedInEnvvar = 1,
  // Deprecated, use kAllowedInEnvvar instead.
  kAllowedInEnvironment = kAllowedInEnvvar,
  // Deprecated, use kDisallowedInEnvvar instead.
  kDisallowedInEnvironment = kDisallowedInEnvvar,
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5481,129988,NodeArrayBufferAllocator,4,node.NodeArrayBufferAllocator,,node.hpp,class NodeArrayBufferAllocator,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5482,129989,ArrayBufferAllocator,4,node.ArrayBufferAllocator,,node.hpp,"class NODE_EXTERN ArrayBufferAllocator : public v8::ArrayBuffer::Allocator {
 public:
  // If `always_debug` is true, create an ArrayBuffer::Allocator instance
  // that performs additional integrity checks (e.g. make sure that only memory
  // that was allocated by the it is also freed by it).
  // This can also be set using the --debug-arraybuffer-allocations flag.
  static std::unique_ptr<ArrayBufferAllocator> Create(
      bool always_debug = false);

 private:
  virtual NodeArrayBufferAllocator* GetImpl() = 0;

  friend class IsolateData;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5483,129999,IsolateData,4,node.ArrayBufferAllocator.IsolateData,,node.hpp,friend class IsolateData,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5484,130009,IsolatePlatformDelegate,4,node.IsolatePlatformDelegate,,node.hpp,"class NODE_EXTERN IsolatePlatformDelegate {
 public:
  virtual std::shared_ptr<v8::TaskRunner> GetForegroundTaskRunner() = 0;
  virtual bool IdleTasksEnabled() = 0;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5485,130018,MultiIsolatePlatform,4,node.MultiIsolatePlatform,,node.hpp,"class NODE_EXTERN MultiIsolatePlatform : public v8::Platform {
 public:
  ~MultiIsolatePlatform() override = default;
  // Returns true if work was dispatched or executed. New tasks that are
  // posted during flushing of the queue are postponed until the next
  // flushing.
  virtual bool FlushForegroundTasks(v8::Isolate* isolate) = 0;
  virtual void DrainTasks(v8::Isolate* isolate) = 0;

  // This needs to be called between the calls to `Isolate::Allocate()` and
  // `Isolate::Initialize()`, so that initialization can already start
  // using the platform.
  // When using `NewIsolate()`, this is taken care of by that function.
  // This function may only be called once per `Isolate`.
  virtual void RegisterIsolate(v8::Isolate* isolate,
                               struct uv_loop_s* loop) = 0;
  // This method can be used when an application handles task scheduling on its
  // own through `IsolatePlatformDelegate`. Upon registering an isolate with
  // this overload any other met...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5486,130064,IsolateSettingsFlags,4,node.IsolateSettingsFlags,,node.hpp,"enum IsolateSettingsFlags {
  MESSAGE_LISTENER_WITH_ERROR_LEVEL = 1 << 0,
  DETAILED_SOURCE_POSITIONS_FOR_PROFILING = 1 << 1,
  SHOULD_NOT_SET_PROMISE_REJECTION_CALLBACK = 1 << 2,
  SHOULD_NOT_SET_PREPARE_STACK_TRACE_CALLBACK = 1 << 3,
  ALLOW_MODIFY_CODE_GENERATION_FROM_STRINGS_CALLBACK = 0, /* legacy no-op */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5487,130097,IsolateSettings,4,node.IsolateSettings,,node.hpp,"struct IsolateSettings {
  uint64_t flags = MESSAGE_LISTENER_WITH_ERROR_LEVEL |
      DETAILED_SOURCE_POSITIONS_FOR_PROFILING;
  v8::MicrotasksPolicy policy = v8::MicrotasksPolicy::kExplicit;

  // Error handling callbacks
  v8::Isolate::AbortOnUncaughtExceptionCallback
      should_abort_on_uncaught_exception_callback = nullptr;
  v8::FatalErrorCallback fatal_error_callback = nullptr;
  v8::PrepareStackTraceCallback prepare_stack_trace_callback = nullptr;

  // Miscellaneous callbacks
  v8::PromiseRejectCallback promise_reject_callback = nullptr;
  v8::AllowWasmCodeGenerationCallback
      allow_wasm_code_generation_callback = nullptr;
  v8::ModifyCodeGenerationFromStringsCallback2
      modify_code_generation_from_strings_callback = nullptr;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5488,130140,EmbedderSnapshotData,4,node.EmbedderSnapshotData,,node.hpp,"class EmbedderSnapshotData {
 public:
  struct DeleteSnapshotData {
    void operator()(const EmbedderSnapshotData*) const;
  };
  using Pointer =
      std::unique_ptr<const EmbedderSnapshotData, DeleteSnapshotData>;

  // Return an EmbedderSnapshotData object that refers to the built-in
  // snapshot of Node.js. This can have been configured through e.g.
  // --node-snapshot-main=entry.js.
  static Pointer BuiltinSnapshotData();

  // Return an EmbedderSnapshotData object that is based on an input file.
  // Calling this method will consume but not close the FILE* handle.
  // The FILE* handle can be closed immediately following this call.
  // If the snapshot is invalid, this returns an empty pointer.
  static Pointer FromFile(FILE* in);
  static Pointer FromBlob(const std::vector<char>& in);

  // Write this EmbedderSnapshotData object to an output file.
  // Calling this method will not close the FILE* handle.
  // The FILE* handle can be closed immediately following this call....",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5489,130141,DeleteSnapshotData,4,node.EmbedderSnapshotData.DeleteSnapshotData,,node.hpp,"struct DeleteSnapshotData {
    void operator()(const EmbedderSnapshotData*) const;
  }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5490,130147,Pointer,4,Pointer,,node.hpp,"using Pointer =
      std::unique_ptr<const EmbedderSnapshotData, DeleteSnapshotData>;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5491,130203,SnapshotData,4,node.EmbedderSnapshotData.SnapshotData,,node.hpp,friend struct SnapshotData,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5492,130204,CommonEnvironmentSetup,4,node.EmbedderSnapshotData.CommonEnvironmentSetup,,node.hpp,friend class CommonEnvironmentSetup,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5493,130259,ThreadId,4,node.ThreadId,,node.hpp,"struct ThreadId {
  uint64_t id = static_cast<uint64_t>(-1);
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5494,130276,Flags,4,node.EnvironmentFlags.Flags,,node.hpp,"enum Flags : uint64_t {
  kNoFlags = 0,
  // Use the default behaviour for Node.js instances.
  kDefaultFlags = 1 << 0,
  // Controls whether this Environment is allowed to affect per-process state
  // (e.g. cwd, process title, uid, etc.).
  // This is set when using kDefaultFlags.
  kOwnsProcessState = 1 << 1,
  // Set if this Environment instance is associated with the global inspector
  // handling code (i.e. listening on SIGUSR1).
  // This is set when using kDefaultFlags.
  kOwnsInspector = 1 << 2,
  // Set if Node.js should not run its own esm loader. This is needed by some
  // embedders, because it's possible for the Node.js esm loader to conflict
  // with another one in an embedder environment, e.g. Blink's in Chromium.
  kNoRegisterESMLoader = 1 << 3,
  // Set this flag to make Node.js track ""raw"" file descriptors, i.e. managed
  // by fs.open() and fs.close(), and close them during FreeEnvironment().
  kTrackUnmanagedFds = 1 << 4,
  // Set this flag to force hiding cons...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5495,130345,InspectorParentHandle,4,node.InspectorParentHandle,,node.hpp,"struct InspectorParentHandle {
  virtual ~InspectorParentHandle();
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5496,130376,StartExecutionCallbackInfo,4,node.StartExecutionCallbackInfo,,node.hpp,"struct StartExecutionCallbackInfo {
  v8::Local<v8::Object> process_object;
  v8::Local<v8::Function> native_require;
  v8::Local<v8::Function> run_cjs;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5497,130380,StartExecutionCallback,4,StartExecutionCallback,,node.hpp,"using StartExecutionCallback =
    std::function<v8::MaybeLocal<v8::Value>(const StartExecutionCallbackInfo&)>;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5498,130550,uv_loop_s,4,node.uv_loop_s,,node.hpp,struct uv_loop_s,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5499,130557,CommonEnvironmentSetup,4,node.CommonEnvironmentSetup,,node.hpp,"class NODE_EXTERN CommonEnvironmentSetup {
 public:
  ~CommonEnvironmentSetup();

  // Create a new CommonEnvironmentSetup, that is, a group of objects that
  // together form the typical setup for a single Node.js Environment instance.
  // If any error occurs, `*errors` will be populated and the returned pointer
  // will be empty.
  // env_args will be passed through as arguments to CreateEnvironment(), after
  // `isolate_data` and `context`.
  template <typename... EnvironmentArgs>
  static std::unique_ptr<CommonEnvironmentSetup> Create(
      MultiIsolatePlatform* platform,
      std::vector<std::string>* errors,
      EnvironmentArgs&&... env_args);
  template <typename... EnvironmentArgs>
  static std::unique_ptr<CommonEnvironmentSetup> CreateFromSnapshot(
      MultiIsolatePlatform* platform,
      std::vector<std::string>* errors,
      const EmbedderSnapshotData* snapshot_data,
      EnvironmentArgs&&... env_args);

  // Create an embedding setup which will be used for cr...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5500,130589,uv_loop_s,4,node.CommonEnvironmentSetup.uv_loop_s,,node.hpp,struct uv_loop_s,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5501,130635,Flags,4,node.CommonEnvironmentSetup.Flags,,node.hpp,"enum Flags : uint32_t {
    kNoFlags = 0,
    kIsForSnapshotting = 1,
  }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5502,130648,Impl,4,node.CommonEnvironmentSetup.Impl,,node.hpp,struct Impl,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5503,131060,encoding,4,node.encoding,,node.hpp,"enum encoding {
  ASCII,
  UTF8,
  BASE64,
  UCS2,
  BINARY,
  HEX,
  BUFFER,
  BASE64URL,
  LATIN1 = BINARY
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5504,131077,encoding,4,node.encoding,,node.hpp,enum encoding,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5505,131136,ModuleFlags,4,node.ModuleFlags,,node.hpp,"enum ModuleFlags {
  kLinked = 0x02
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5506,131145,node_module,4,node.node_module,,node.hpp,"struct node_module {
  int nm_version;
  unsigned int nm_flags;
  void* nm_dso_handle;
  const char* nm_filename;
  node::addon_register_func nm_register_func;
  node::addon_context_register_func nm_context_register_func;
  const char* nm_modname;
  void* nm_priv;
  struct node_module* nm_link;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5507,131154,node_module,4,node.node_module.node_module,,node.hpp,struct node_module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5508,131196,async_id,4,async_id,,node.hpp,typedef double async_id;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5509,131197,async_context,4,node.async_context,,node.hpp,"struct async_context {
  ::node::async_id async_id;
  ::node::async_id trigger_async_id;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5510,131214,ACHHandle,4,node.ACHHandle,,node.hpp,struct ACHHandle,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5511,131215,DeleteACHHandle,4,node.DeleteACHHandle,,node.hpp,struct NODE_EXTERN DeleteACHHandle { void operator()(ACHHandle*) const; },-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5512,131221,AsyncCleanupHookHandle,4,AsyncCleanupHookHandle,,node.hpp,"typedef std::unique_ptr<ACHHandle, DeleteACHHandle> AsyncCleanupHookHandle;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5513,131302,InternalCallbackScope,4,node.InternalCallbackScope,,node.hpp,class InternalCallbackScope,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5514,131303,CallbackScope,4,node.CallbackScope,,node.hpp,"class NODE_EXTERN CallbackScope {
 public:
  CallbackScope(v8::Isolate* isolate,
                v8::Local<v8::Object> resource,
                async_context asyncContext);
  CallbackScope(Environment* env,
                v8::Local<v8::Object> resource,
                async_context asyncContext);
  ~CallbackScope();

  void operator=(const CallbackScope&) = delete;
  void operator=(CallbackScope&&) = delete;
  CallbackScope(const CallbackScope&) = delete;
  CallbackScope(CallbackScope&&) = delete;

 private:
  InternalCallbackScope* private_;
  v8::TryCatch try_catch_;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5515,131364,AsyncResource,4,node.AsyncResource,,node.hpp,"class NODE_EXTERN AsyncResource {
 public:
  AsyncResource(v8::Isolate* isolate,
                v8::Local<v8::Object> resource,
                const char* name,
                async_id trigger_async_id = -1);

  virtual ~AsyncResource();

  AsyncResource(const AsyncResource&) = delete;
  void operator=(const AsyncResource&) = delete;

  v8::MaybeLocal<v8::Value> MakeCallback(
      v8::Local<v8::Function> callback,
      int argc,
      v8::Local<v8::Value>* argv);

  v8::MaybeLocal<v8::Value> MakeCallback(
      const char* method,
      int argc,
      v8::Local<v8::Value>* argv);

  v8::MaybeLocal<v8::Value> MakeCallback(
      v8::Local<v8::String> symbol,
      int argc,
      v8::Local<v8::Value>* argv);

  v8::Local<v8::Object> get_resource();
  async_id get_async_id() const;
  async_id get_trigger_async_id() const;

 protected:
  class NODE_EXTERN CallbackScope : public node::CallbackScope {
   public:
    explicit CallbackScope(AsyncResource* res);
  };

 private:
  Envi...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5516,131413,CallbackScope,4,node.AsyncResource.CallbackScope,,node.hpp,"class NODE_EXTERN CallbackScope : public node::CallbackScope {
   public:
    explicit CallbackScope(AsyncResource* res);
  }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5517,131537,ThreadSafeFunction,4,v8impl.anonymous_namespace_11.ThreadSafeFunction,,node_api.cc,"class ThreadSafeFunction : public node::AsyncResource {
 public:
  ThreadSafeFunction(v8::Local<v8::Function> func,
                     v8::Local<v8::Object> resource,
                     v8::Local<v8::String> name,
                     size_t thread_count_,
                     void* context_,
                     size_t max_queue_size_,
                     node_napi_env env_,
                     void* finalize_data_,
                     napi_finalize finalize_cb_,
                     napi_threadsafe_function_call_js call_js_cb_)
      : AsyncResource(env_->isolate,
                      resource,
                      *v8::String::Utf8Value(env_->isolate, name)),
        thread_count(thread_count_),
        is_closing(false),
        dispatch_state(kDispatchIdle),
        context(context_),
        max_queue_size(max_queue_size_),
        env(env_),
        finalize_data(finalize_data_),
        finalize_cb(finalize_cb_),
        call_js_cb(call_js_cb_ == nullptr ? CallJs : ...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5518,131603,napi_async_cleanup_hook_handle__,4,napi_async_cleanup_hook_handle__,,node_api.cc,"struct napi_async_cleanup_hook_handle__ {
  napi_async_cleanup_hook_handle__(napi_env env,
                                   napi_async_cleanup_hook user_hook,
                                   void* user_data)
      : env_(env), user_hook_(user_hook), user_data_(user_data) {
    handle_ = node::AddEnvironmentCleanupHook(env->isolate, Hook, this);
    env->Ref();
  }

  ~napi_async_cleanup_hook_handle__() {
    node::RemoveEnvironmentCleanupHook(std::move(handle_));
    if (done_cb_ != nullptr) done_cb_(done_data_);

    // Release the `env` handle asynchronously since it would be surprising if
    // a call to a N-API function would destroy `env` synchronously.
    static_cast<node_napi_env>(env_)->node_env()->SetImmediate(
        [env = env_](node::Environment*) { env->Unref(); });
  }

  static void Hook(void* data, void (*done_cb)(void*), void* done_data) {
    napi_async_cleanup_hook_handle__* handle =
        static_cast<napi_async_cleanup_hook_handle__*>(data);
    handle-...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5519,131616,Work,4,anonymous_namespace_75.uvimpl.Work,,node_api.cc,"class Work : public node::AsyncResource, public node::ThreadPoolWork {
 private:
  explicit Work(node_napi_env env,
                v8::Local<v8::Object> async_resource,
                v8::Local<v8::String> async_resource_name,
                napi_async_execute_callback execute,
                napi_async_complete_callback complete = nullptr,
                void* data = nullptr)
      : AsyncResource(
            env->isolate,
            async_resource,
            *v8::String::Utf8Value(env->isolate, async_resource_name)),
        ThreadPoolWork(env->node_env(), ""node_api""),
        _env(env),
        _data(data),
        _execute(execute),
        _complete(complete) {}

  ~Work() override = default;

 public:
  static Work* New(node_napi_env env,
                   v8::Local<v8::Object> async_resource,
                   v8::Local<v8::String> async_resource_name,
                   napi_async_execute_callback execute,
                   napi_async_complete_callback complete,
...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5520,131806,BufferFinalizer,4,v8impl.anonymous_namespace_1.BufferFinalizer,,node_api.cc,"class BufferFinalizer : private Finalizer {
 public:
  static BufferFinalizer* New(napi_env env,
                              napi_finalize finalize_callback = nullptr,
                              void* finalize_data = nullptr,
                              void* finalize_hint = nullptr) {
    return new BufferFinalizer(
        env, finalize_callback, finalize_data, finalize_hint);
  }
  // node::Buffer::FreeCallback
  static void FinalizeBufferCallback(char* data, void* hint) {
    std::unique_ptr<BufferFinalizer, Deleter> finalizer{
        static_cast<BufferFinalizer*>(hint)};
    finalizer->finalize_data_ = data;

    // It is safe to call into JavaScript at this point.
    if (finalizer->finalize_callback_ == nullptr) return;
    finalizer->env_->CallFinalizer(finalizer->finalize_callback_,
                                   finalizer->finalize_data_,
                                   finalizer->finalize_hint_);
  }

  struct Deleter {
    void operator()(BufferFinalizer* ...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5521,131863,Deleter,4,v8impl.anonymous_namespace_4.BufferFinalizer.Deleter,,node_api.cc,"struct Deleter {
    void operator()(BufferFinalizer* finalizer) { delete finalizer; }
  }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5522,132739,AsyncContext,4,v8impl.anonymous_namespace_43.AsyncContext,,node_api.cc,"class AsyncContext {
 public:
  AsyncContext(node_napi_env env,
               v8::Local<v8::Object> resource_object,
               const v8::Local<v8::String> resource_name,
               bool externally_managed_resource)
      : env_(env) {
    async_id_ = node_env()->new_async_id();
    trigger_async_id_ = node_env()->get_default_trigger_async_id();
    resource_.Reset(node_env()->isolate(), resource_object);
    lost_reference_ = false;
    if (externally_managed_resource) {
      resource_.SetWeak(
          this, AsyncContext::WeakCallback, v8::WeakCallbackType::kParameter);
    }

    node::AsyncWrap::EmitAsyncInit(node_env(),
                                   resource_object,
                                   resource_name,
                                   async_id_,
                                   trigger_async_id_);
  }

  ~AsyncContext() {
    resource_.Reset();
    lost_reference_ = true;
    node::AsyncWrap::EmitDestroy(node_env(), async_id_);
  }

  inline v8:...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5523,132962,CallbackScope,4,v8impl.anonymous_namespace_67.AsyncContext.CallbackScope,,node_api.cc,"class CallbackScope : public node::CallbackScope {
   public:
    explicit CallbackScope(AsyncContext* async_context)
        : node::CallbackScope(async_context->node_env(),
                              async_context->resource_.Get(
                                  async_context->node_env()->isolate()),
                              async_context->async_context()) {}
  }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5524,136251,uv_loop_s,4,uv_loop_s,,node_api.hpp,struct uv_loop_s,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5525,136262,napi_module,4,napi_module,,node_api.hpp,"typedef struct napi_module {
  int nm_version;
  unsigned int nm_flags;
  const char* nm_filename;
  napi_addon_register_func nm_register_func;
  const char* nm_modname;
  void* nm_priv;
  void* reserved[4];
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5526,136276,napi_module,4,napi_module,,node_api.hpp,"typedef struct napi_module {
  int nm_version;
  unsigned int nm_flags;
  const char* nm_filename;
  napi_addon_register_func nm_register_func;
  const char* nm_modname;
  void* nm_priv;
  void* reserved[4];
} napi_module;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5527,136511,node_napi_env__,4,node_napi_env__,,node_api_internals.hpp,"struct node_napi_env__ : public napi_env__ {
  node_napi_env__(v8::Local<v8::Context> context,
                  const std::string& module_filename,
                  int32_t module_api_version);

  bool can_call_into_js() const override;
  void CallFinalizer(napi_finalize cb, void* data, void* hint) override;
  template <bool enforceUncaughtExceptionPolicy>
  void CallFinalizer(napi_finalize cb, void* data, void* hint);

  void EnqueueFinalizer(v8impl::RefTracker* finalizer) override;
  void DrainFinalizerQueue();

  void trigger_fatal_exception(v8::Local<v8::Value> local_err);
  template <bool enforceUncaughtExceptionPolicy, typename T>
  void CallbackIntoModule(T&& call);

  void DeleteMe() override;

  inline node::Environment* node_env() const {
    return node::Environment::GetCurrent(context());
  }
  inline const char* GetFilename() const { return filename.c_str(); }

  std::string filename;
  bool destructing = false;
  bool finalization_scheduled = false;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5528,136594,node_napi_env,4,node_napi_env,,node_api_internals.hpp,using node_napi_env = node_napi_env__*;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5529,136602,napi_callback_scope__,4,napi_callback_scope__,,node_api_types.hpp,typedef struct napi_callback_scope__,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5530,136603,napi_callback_scope,4,napi_callback_scope,,node_api_types.hpp,typedef struct napi_callback_scope__* napi_callback_scope;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5531,136604,napi_async_context__,4,napi_async_context__,,node_api_types.hpp,typedef struct napi_async_context__,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5532,136605,napi_async_context,4,napi_async_context,,node_api_types.hpp,typedef struct napi_async_context__* napi_async_context;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5533,136606,napi_async_work__,4,napi_async_work__,,node_api_types.hpp,typedef struct napi_async_work__,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5534,136607,napi_async_work,4,napi_async_work,,node_api_types.hpp,typedef struct napi_async_work__* napi_async_work;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5535,136621,napi_node_version,4,napi_node_version,,node_api_types.hpp,"typedef struct {
  uint32_t major;
  uint32_t minor;
  uint32_t patch;
  const char* release;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5536,137206,global_handle_map_t,4,node.binding.global_handle_map_t,,node_binding.cc,"static struct global_handle_map_t {
 public:
  void set(void* handle, node_module* mod) {
    CHECK_NE(handle, nullptr);
    Mutex::ScopedLock lock(mutex_);

    map_[handle].module = mod;
    // We need to store this flag internally to avoid a chicken-and-egg problem
    // during cleanup. By the time we actually use the flag's value,
    // the shared object has been unloaded, and its memory would be gone,
    // making it impossible to access fields of `mod` --
    // unless `mod` *is* dynamically allocated, but we cannot know that
    // without checking the flag.
    map_[handle].wants_delete_module = mod->nm_flags & NM_F_DELETEME;
    map_[handle].refcount++;
  }

  node_module* get_and_increase_refcount(void* handle) {
    CHECK_NE(handle, nullptr);
    Mutex::ScopedLock lock(mutex_);

    auto it = map_.find(handle);
    if (it == map_.end()) return nullptr;
    it->second.refcount++;
    return it->second.module;
  }

  void erase(void* handle) {
    CHECK_NE(handle, nullpt...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5537,137348,Entry,4,node.binding.global_handle_map_t.Entry,,node_binding.cc,"struct Entry {
    unsigned int refcount;
    bool wants_delete_module;
    node_module* module;
  }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5538,137465,InitializerCallback,4,InitializerCallback,,node_binding.cc,"using InitializerCallback = void (*)(Local<Object> exports,
                                     Local<Value> module,
                                     Local<Context> context);",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5539,140774,Status,4,node.bob.Status,,node_bob.hpp,"enum Status : int {
  // Indicates that an attempt was made to pull after end.
  STATUS_EOS = 0,

  // Indicates that there is additional data available
  // and the consumer may continue to pull.
  STATUS_CONTINUE = 1,

  // Indicates that there is no additional data available
  // but the stream has not ended. The consumer should not
  // continue to pull but may resume pulling later when
  // data is available.
  STATUS_BLOCK = 2,

  // Indicates that there is no additional data available
  // but the stream has not ended and the source will call
  // next again later when data is available. STATUS_WAIT
  // must not be used with the OPTIONS_SYNC option.
  STATUS_WAIT = 3,
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5540,140795,Options,4,node.bob.Options,,node_bob.hpp,"enum Options : int {
  OPTIONS_NONE = 0,

  // Indicates that the consumer is requesting the end
  // of the stream.
  OPTIONS_END = 1,

  // Indicates that the consumer requires the source to
  // invoke Next synchronously. If the source is
  // unable to provide data immediately but the
  // stream has not yet ended, it should call Next
  // using STATUS_BLOCK. When not set, the source
  // may call Next asynchronously.
  OPTIONS_SYNC = 2
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5541,140812,Done,4,Done,,node_bob.hpp,using Done = std::function<void(size_t)>;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5542,140813,Next,4,Next,,node_bob.hpp,"using Next = std::function<void(int, const T*, size_t count, Done done)>;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5543,140814,Source,4,node.bob.Source,,node_bob.hpp,"class Source {
 public:
  virtual ~Source() = default;
  virtual int Pull(
      Next<T> next,
      int options,
      T* data,
      size_t count,
      size_t max_count_hint = kMaxCountHint) = 0;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5544,140828,SourceImpl,4,node.bob.SourceImpl,,node_bob.hpp,"class SourceImpl : public Source<T> {
 public:
  int Pull(
      Next<T> next,
      int options,
      T* data,
      size_t count,
      size_t max_count_hint = kMaxCountHint) override;

  bool is_eos() const { return eos_; }

 protected:
  virtual int DoPull(
      Next<T> next,
      int options,
      T* data,
      size_t count,
      size_t max_count_hint) = 0;

 private:
  bool eos_ = false;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5545,140950,CallbackInfo,4,node.Buffer.anonymous_namespace_1.CallbackInfo,,node_buffer.cc,"class CallbackInfo {
 public:
  static inline Local<ArrayBuffer> CreateTrackedArrayBuffer(
      Environment* env,
      char* data,
      size_t length,
      FreeCallback callback,
      void* hint);

  CallbackInfo(const CallbackInfo&) = delete;
  CallbackInfo& operator=(const CallbackInfo&) = delete;

 private:
  static void CleanupHook(void* data);
  inline void OnBackingStoreFree();
  inline void CallAndResetCallback();
  inline CallbackInfo(Environment* env,
                      FreeCallback callback,
                      char* data,
                      void* hint);
  Global<ArrayBuffer> persistent_;
  Mutex mutex_;  // Protects callback_.
  FreeCallback callback_;
  char* const data_;
  void* const hint_;
  Environment* const env_;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5546,157263,RealEnvStore,4,node.RealEnvStore,,node_env_var.cc,"class RealEnvStore final : public KVStore {
 public:
  MaybeLocal<String> Get(Isolate* isolate, Local<String> key) const override;
  Maybe<std::string> Get(const char* key) const override;
  void Set(Isolate* isolate, Local<String> key, Local<String> value) override;
  int32_t Query(Isolate* isolate, Local<String> key) const override;
  int32_t Query(const char* key) const override;
  void Delete(Isolate* isolate, Local<String> key) override;
  Local<Array> Enumerate(Isolate* isolate) const override;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5547,157304,MapKVStore,4,node.MapKVStore,,node_env_var.cc,"class MapKVStore final : public KVStore {
 public:
  MaybeLocal<String> Get(Isolate* isolate, Local<String> key) const override;
  Maybe<std::string> Get(const char* key) const override;
  void Set(Isolate* isolate, Local<String> key, Local<String> value) override;
  int32_t Query(Isolate* isolate, Local<String> key) const override;
  int32_t Query(const char* key) const override;
  void Delete(Isolate* isolate, Local<String> key) override;
  Local<Array> Enumerate(Isolate* isolate) const override;

  std::shared_ptr<KVStore> Clone(Isolate* isolate) const override;

  MapKVStore() = default;
  MapKVStore(const MapKVStore& other) : KVStore(), map_(other.map_) {}

 private:
  mutable Mutex mutex_;
  std::unordered_map<std::string, std::string> map_;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5548,160080,EnhanceFatalException,4,node.EnhanceFatalException,,node_errors.cc,"enum class EnhanceFatalException { kEnhance, kDontEnhance }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5549,165168,FileHandleCloseWrap,4,FileHandleCloseWrap,,node_file.cc,typedef SimpleShutdownWrap<ReqWrap<uv_fs_t>> FileHandleCloseWrap;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5550,197180,Parser,4,node.anonymous_namespace_49.Parser,,node_http_parser.cc,"class Parser : public AsyncWrap, public StreamListener {
  friend class ConnectionsList;
  friend struct ParserComparator;

 public:
  Parser(BindingData* binding_data, Local<Object> wrap)
      : AsyncWrap(binding_data->env(), wrap),
        current_buffer_len_(0),
        current_buffer_data_(nullptr),
        binding_data_(binding_data) {
  }

  SET_NO_MEMORY_INFO()
  SET_MEMORY_INFO_NAME(Parser)
  SET_SELF_SIZE(Parser)

  int on_message_begin() {
    // Important: Pop from the lists BEFORE resetting the last_message_start_
    // otherwise std::set.erase will fail.
    if (connectionsList_ != nullptr) {
      connectionsList_->Pop(this);
      connectionsList_->PopActive(this);
    }

    num_fields_ = num_values_ = 0;
    headers_completed_ = false;
    last_message_start_ = uv_hrtime();
    url_.Reset();
    status_message_.Reset();

    if (connectionsList_ != nullptr) {
      connectionsList_->Push(this);
      connectionsList_->PushActive(this);
    }

    Local<Value> cb =...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5551,197284,BindingData,4,node.anonymous_namespace_22.BindingData,,node_http_parser.cc,"class BindingData : public BaseObject {
 public:
  BindingData(Realm* realm, Local<Object> obj) : BaseObject(realm, obj) {}

  SET_BINDING_ID(http_parser_binding_data)

  std::vector<char> parser_buffer;
  bool parser_buffer_in_use = false;

  void MemoryInfo(MemoryTracker* tracker) const override {
    tracker->TrackField(""parser_buffer"", parser_buffer);
  }
  SET_SELF_SIZE(BindingData)
  SET_MEMORY_INFO_NAME(BindingData)
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5552,197317,StringPtr,4,node.anonymous_namespace_25.StringPtr,,node_http_parser.cc,"struct StringPtr {
  StringPtr() {
    on_heap_ = false;
    Reset();
  }


  ~StringPtr() {
    Reset();
  }


  // If str_ does not point to a heap string yet, this function makes it do
  // so. This is called at the end of each http_parser_execute() so as not
  // to leak references. See issue #2438 and test-http-parser-bad-ref.js.
  void Save() {
    if (!on_heap_ && size_ > 0) {
      char* s = new char[size_];
      memcpy(s, str_, size_);
      str_ = s;
      on_heap_ = true;
    }
  }


  void Reset() {
    if (on_heap_) {
      delete[] str_;
      on_heap_ = false;
    }

    str_ = nullptr;
    size_ = 0;
  }


  void Update(const char* str, size_t size) {
    if (str_ == nullptr) {
      str_ = str;
    } else if (on_heap_ || str_ + size_ != str) {
      // Non-consecutive input, make a copy on the heap.
      // TODO(bnoordhuis) Use slab allocation, O(n) allocs is bad.
      char* s = new char[size_ + size];
      memcpy(s, str_, size_);
      memcpy(s + size_, str, si...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5553,197486,Parser,4,node.anonymous_namespace_36.Parser,,node_http_parser.cc,class Parser,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5554,197487,ParserComparator,4,node.anonymous_namespace_37.ParserComparator,,node_http_parser.cc,"struct ParserComparator {
  bool operator()(const Parser* lhs, const Parser* rhs) const;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5555,197494,ConnectionsList,4,node.anonymous_namespace_39.ConnectionsList,,node_http_parser.cc,"class ConnectionsList : public BaseObject {
 public:
    static void New(const FunctionCallbackInfo<Value>& args);

    static void All(const FunctionCallbackInfo<Value>& args);

    static void Idle(const FunctionCallbackInfo<Value>& args);

    static void Active(const FunctionCallbackInfo<Value>& args);

    static void Expired(const FunctionCallbackInfo<Value>& args);

    void Push(Parser* parser) {
      all_connections_.insert(parser);
    }

    void Pop(Parser* parser) {
      all_connections_.erase(parser);
    }

    void PushActive(Parser* parser) {
      active_connections_.insert(parser);
    }

    void PopActive(Parser* parser) {
      active_connections_.erase(parser);
    }

    SET_NO_MEMORY_INFO()
    SET_MEMORY_INFO_NAME(ConnectionsList)
    SET_SELF_SIZE(ConnectionsList)

 private:
    ConnectionsList(Environment* env, Local<Object> object)
      : BaseObject(env, object) {
        MakeWeak();
      }

    std::set<Parser*, ParserComparator> all_connections_;
 ...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5556,197563,ConnectionsList,4,node.anonymous_namespace_50.Parser.ConnectionsList,,node_http_parser.cc,friend class ConnectionsList,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5557,197564,ParserComparator,4,node.anonymous_namespace_51.Parser.ParserComparator,,node_http_parser.cc,friend struct ParserComparator,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5558,199702,Proxy,4,node.anonymous_namespace_95.Parser.Proxy,,node_http_parser.cc,struct Proxy,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5559,199703,"Proxy<int (Parser::*)(Args...),Member>",4,"node.anonymous_namespace_96.Parser.Proxy<int(Parser.*)(Args...),Member>",,node_http_parser.cc,"struct Proxy<int (Parser::*)(Args...), Member> {
    static int Raw(llhttp_t* p, Args ... args) {
      Parser* parser = ContainerOf(&Parser::parser_, p);
      int rv = (parser->*Member)(std::forward<Args>(args)...);
      if (rv == 0) {
        rv = parser->MaybePause();
      }
      return rv;
    }
  }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5560,201453,BaseObjectList,4,BaseObjectList,,node_messaging.cc,using BaseObjectList = std::vector<BaseObjectPtr<BaseObject>>;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5561,201525,DeserializerDelegate,4,node.worker.anonymous_namespace_1.DeserializerDelegate,,node_messaging.cc,"class DeserializerDelegate : public ValueDeserializer::Delegate {
 public:
  DeserializerDelegate(
      Message* m,
      Environment* env,
      const std::vector<BaseObjectPtr<BaseObject>>& host_objects,
      const std::vector<Local<SharedArrayBuffer>>& shared_array_buffers,
      const std::vector<CompiledWasmModule>& wasm_modules,
      const std::optional<SharedValueConveyor>& shared_value_conveyor)
      : host_objects_(host_objects),
        shared_array_buffers_(shared_array_buffers),
        wasm_modules_(wasm_modules),
        shared_value_conveyor_(shared_value_conveyor) {}

  MaybeLocal<Object> ReadHostObject(Isolate* isolate) override {
    // Identifying the index in the message's BaseObject array is sufficient.
    uint32_t id;
    if (!deserializer->ReadUint32(&id))
      return MaybeLocal<Object>();
    if (id != kNormalObject) {
      CHECK_LT(id, host_objects_.size());
      return host_objects_[id]->object(isolate);
    }
    EscapableHandleScope scope(isolate)...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5562,202286,SerializerDelegate,4,node.worker.anonymous_namespace_12.SerializerDelegate,,node_messaging.cc,"class SerializerDelegate : public ValueSerializer::Delegate {
 public:
  SerializerDelegate(Environment* env, Local<Context> context, Message* m)
      : env_(env), context_(context), msg_(m) {}

  void ThrowDataCloneError(Local<String> message) override {
    ThrowDataCloneException(context_, message);
  }

  Maybe<bool> WriteHostObject(Isolate* isolate, Local<Object> object) override {
    if (BaseObject::IsBaseObject(object)) {
      return WriteHostObject(
          BaseObjectPtr<BaseObject> { Unwrap<BaseObject>(object) });
    }

    // Convert process.env to a regular object.
    auto env_proxy_ctor_template = env_->env_proxy_ctor_template();
    if (!env_proxy_ctor_template.IsEmpty() &&
        env_proxy_ctor_template->HasInstance(object)) {
      HandleScope scope(isolate);
      // TODO(bnoordhuis) Prototype-less object in case process.env contains
      // a ""__proto__"" key? process.env has a prototype with concomitant
      // methods like toString(). It's probably confus...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5563,202775,Message,4,node.worker.anonymous_namespace_25.SerializerDelegate.Message,,node_messaging.cc,friend class worker::Message,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5564,207050,ObjectWrap,4,node.ObjectWrap,,node_object_wrap.hpp,"class ObjectWrap {
 public:
  ObjectWrap() {
    refs_ = 0;
  }


  virtual ~ObjectWrap() {
    if (persistent().IsEmpty())
      return;
    persistent().ClearWeak();
    persistent().Reset();
  }


  template <class T>
  static inline T* Unwrap(v8::Local<v8::Object> handle) {
    assert(!handle.IsEmpty());
    assert(handle->InternalFieldCount() > 0);
    // Cast to ObjectWrap before casting to T.  A direct cast from void
    // to T won't work right when T has more than one base class.
    void* ptr = handle->GetAlignedPointerFromInternalField(0);
    ObjectWrap* wrap = static_cast<ObjectWrap*>(ptr);
    return static_cast<T*>(wrap);
  }


  inline v8::Local<v8::Object> handle() {
    return handle(v8::Isolate::GetCurrent());
  }


  inline v8::Local<v8::Object> handle(v8::Isolate* isolate) {
    return v8::Local<v8::Object>::New(isolate, persistent());
  }


  // NOLINTNEXTLINE(runtime/v8_persistent)
  inline v8::Persistent<v8::Object>& persistent() {
    return handle_;
  }


 ...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5565,207702,DebugOptionsParser,4,node.options_parser.DebugOptionsParser,,node_options.cc,"class DebugOptionsParser : public OptionsParser<DebugOptions> {
 public:
  DebugOptionsParser();
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5566,207707,EnvironmentOptionsParser,4,node.options_parser.EnvironmentOptionsParser,,node_options.cc,"class EnvironmentOptionsParser : public OptionsParser<EnvironmentOptions> {
 public:
  EnvironmentOptionsParser();
  explicit EnvironmentOptionsParser(const DebugOptionsParser& dop)
    : EnvironmentOptionsParser() {
    Insert(dop, &EnvironmentOptions::get_debug_options);
  }
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5567,207723,PerIsolateOptionsParser,4,node.options_parser.PerIsolateOptionsParser,,node_options.cc,"class PerIsolateOptionsParser : public OptionsParser<PerIsolateOptions> {
 public:
  PerIsolateOptionsParser() = delete;
  explicit PerIsolateOptionsParser(const EnvironmentOptionsParser& eop);
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5568,207733,PerProcessOptionsParser,4,node.options_parser.PerProcessOptionsParser,,node_options.cc,"class PerProcessOptionsParser : public OptionsParser<PerProcessOptions> {
 public:
  PerProcessOptionsParser() = delete;
  explicit PerProcessOptionsParser(const PerIsolateOptionsParser& iop);
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5569,214575,DelayedTaskScheduler,4,node.DelayedTaskScheduler,,node_platform.cc,"class WorkerThreadsTaskRunner::DelayedTaskScheduler {
 public:
  explicit DelayedTaskScheduler(TaskQueue<Task>* tasks)
    : pending_worker_tasks_(tasks) {}

  std::unique_ptr<uv_thread_t> Start() {
    auto start_thread = [](void* data) {
      static_cast<DelayedTaskScheduler*>(data)->Run();
    };
    std::unique_ptr<uv_thread_t> t { new uv_thread_t() };
    uv_sem_init(&ready_, 0);
    CHECK_EQ(0, uv_thread_create(t.get(), start_thread, this));
    uv_sem_wait(&ready_);
    uv_sem_destroy(&ready_);
    return t;
  }

  void PostDelayedTask(std::unique_ptr<Task> task, double delay_in_seconds) {
    tasks_.Push(std::make_unique<ScheduleTask>(this, std::move(task),
                                               delay_in_seconds));
    uv_async_send(&flush_tasks_);
  }

  void Stop() {
    tasks_.Push(std::make_unique<StopTask>(this));
    uv_async_send(&flush_tasks_);
  }

 private:
  void Run() {
    TRACE_EVENT_METADATA1(""__metadata"", ""thread_name"", ""name"",
                      ...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5570,214582,StopTask,4,node.DelayedTaskScheduler.StopTask,,node_platform.cc,"class StopTask : public Task {
   public:
    explicit StopTask(DelayedTaskScheduler* scheduler): scheduler_(scheduler) {}

    void Run() override {
      std::vector<uv_timer_t*> timers;
      for (uv_timer_t* timer : scheduler_->timers_)
        timers.push_back(timer);
      for (uv_timer_t* timer : timers)
        scheduler_->TakeTimerTask(timer);
      uv_close(reinterpret_cast<uv_handle_t*>(&scheduler_->flush_tasks_),
               [](uv_handle_t* handle) {});
    }

   private:
     DelayedTaskScheduler* scheduler_;
  }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5571,214712,PlatformWorkerData,4,node.anonymous_namespace_1.PlatformWorkerData,,node_platform.cc,"struct PlatformWorkerData {
  TaskQueue<Task>* task_queue;
  Mutex* platform_workers_mutex;
  ConditionVariable* platform_workers_ready;
  int* pending_platform_workers;
  int id;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5572,215010,ScheduleTask,4,node.DelayedTaskScheduler.ScheduleTask,,node_platform.cc,"class ScheduleTask : public Task {
   public:
    ScheduleTask(DelayedTaskScheduler* scheduler,
                 std::unique_ptr<Task> task,
                 double delay_in_seconds)
      : scheduler_(scheduler),
        task_(std::move(task)),
        delay_in_seconds_(delay_in_seconds) {}

    void Run() override {
      uint64_t delay_millis = llround(delay_in_seconds_ * 1000);
      std::unique_ptr<uv_timer_t> timer(new uv_timer_t());
      CHECK_EQ(0, uv_timer_init(&scheduler_->loop_, timer.get()));
      timer->data = task_.release();
      CHECK_EQ(0, uv_timer_start(timer.get(), RunTask, delay_millis, 0));
      scheduler_->timers_.insert(timer.release());
    }

   private:
    DelayedTaskScheduler* scheduler_;
    std::unique_ptr<Task> task_;
    double delay_in_seconds_;
  }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5573,226018,SeaFlags,4,node.sea.anonymous_namespace_1.SeaFlags,,node_sea.cc,"enum class SeaFlags : uint32_t {
  kDefault = 0,
  kDisableExperimentalSeaWarning = 1 << 0,
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5574,226077,SeaResource,4,node.sea.anonymous_namespace_5.SeaResource,,node_sea.cc,"struct SeaResource {
  SeaFlags flags = SeaFlags::kDefault;
  std::string_view code;
  static constexpr size_t kHeaderSize = sizeof(kMagic) + sizeof(SeaFlags);
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5575,226223,SeaConfig,4,node.sea.anonymous_namespace_11.SeaConfig,,node_sea.cc,"struct SeaConfig {
  std::string main_path;
  std::string output_path;
  SeaFlags flags = SeaFlags::kDefault;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5576,226638,SerializerContext,4,node.serdes.SerializerContext,,node_serdes.cc,"class SerializerContext : public BaseObject,
                          public ValueSerializer::Delegate {
 public:
  SerializerContext(Environment* env,
                    Local<Object> wrap);

  ~SerializerContext() override = default;

  void ThrowDataCloneError(Local<String> message) override;
  Maybe<bool> WriteHostObject(Isolate* isolate, Local<Object> object) override;
  Maybe<uint32_t> GetSharedArrayBufferId(
      Isolate* isolate, Local<SharedArrayBuffer> shared_array_buffer) override;

  static void SetTreatArrayBufferViewsAsHostObjects(
      const FunctionCallbackInfo<Value>& args);

  static void New(const FunctionCallbackInfo<Value>& args);
  static void WriteHeader(const FunctionCallbackInfo<Value>& args);
  static void WriteValue(const FunctionCallbackInfo<Value>& args);
  static void ReleaseBuffer(const FunctionCallbackInfo<Value>& args);
  static void TransferArrayBuffer(const FunctionCallbackInfo<Value>& args);
  static void WriteUint32(const FunctionCallbackInfo...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5577,226717,DeserializerContext,4,node.serdes.DeserializerContext,,node_serdes.cc,"class DeserializerContext : public BaseObject,
                            public ValueDeserializer::Delegate {
 public:
  DeserializerContext(Environment* env,
                      Local<Object> wrap,
                      Local<Value> buffer);

  ~DeserializerContext() override = default;

  MaybeLocal<Object> ReadHostObject(Isolate* isolate) override;

  static void New(const FunctionCallbackInfo<Value>& args);
  static void ReadHeader(const FunctionCallbackInfo<Value>& args);
  static void ReadValue(const FunctionCallbackInfo<Value>& args);
  static void TransferArrayBuffer(const FunctionCallbackInfo<Value>& args);
  static void GetWireFormatVersion(const FunctionCallbackInfo<Value>& args);
  static void ReadUint32(const FunctionCallbackInfo<Value>& args);
  static void ReadUint64(const FunctionCallbackInfo<Value>& args);
  static void ReadDouble(const FunctionCallbackInfo<Value>& args);
  static void ReadRawBytes(const FunctionCallbackInfo<Value>& args);

  SET_NO_MEMORY_INFO(...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5578,228629,TryCatchScope,4,TryCatchScope,,node_shadow_realm.cc,using TryCatchScope = node::errors::TryCatchScope;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5579,229410,SnapshotDeserializer,4,node.SnapshotDeserializer,,node_snapshotable.cc,"class SnapshotDeserializer : public BlobDeserializer<SnapshotDeserializer> {
 public:
  explicit SnapshotDeserializer(std::string_view v)
      : BlobDeserializer<SnapshotDeserializer>(
            per_process::enabled_debug_list.enabled(DebugCategory::MKSNAPSHOT),
            v) {}

  template <typename T,
            std::enable_if_t<!std::is_same<T, std::string>::value>* = nullptr,
            std::enable_if_t<!std::is_arithmetic<T>::value>* = nullptr>
  T Read();
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5580,229420,SnapshotSerializer,4,node.SnapshotSerializer,,node_snapshotable.cc,"class SnapshotSerializer : public BlobSerializer<SnapshotSerializer> {
 public:
  SnapshotSerializer()
      : BlobSerializer<SnapshotSerializer>(
            per_process::enabled_debug_list.enabled(
                DebugCategory::MKSNAPSHOT)) {}

  template <typename T,
            std::enable_if_t<!std::is_same<T, std::string>::value>* = nullptr,
            std::enable_if_t<!std::is_arithmetic<T>::value>* = nullptr>
  size_t Write(const T& data);
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5581,237146,ExternalReferenceRegistry,4,node.ExternalReferenceRegistry,,node_trace_events.cc,class ExternalReferenceRegistry,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5582,237147,NodeCategorySet,4,node.NodeCategorySet,,node_trace_events.cc,"class NodeCategorySet : public BaseObject {
 public:
  static void Initialize(Local<Object> target,
                  Local<Value> unused,
                  Local<Context> context,
                  void* priv);
  static void RegisterExternalReferences(ExternalReferenceRegistry* registry);
  static void New(const FunctionCallbackInfo<Value>& args);
  static void Enable(const FunctionCallbackInfo<Value>& args);
  static void Disable(const FunctionCallbackInfo<Value>& args);

  const std::set<std::string>& GetCategories() const { return categories_; }

  void MemoryInfo(MemoryTracker* tracker) const override {
    tracker->TrackField(""categories"", categories_);
  }

  SET_MEMORY_INFO_NAME(NodeCategorySet)
  SET_SELF_SIZE(NodeCategorySet)

 private:
  NodeCategorySet(Environment* env,
                  Local<Object> wrap,
                  std::set<std::string>&& categories) :
        BaseObject(env, wrap), categories_(std::move(categories)) {
    MakeWeak();
  }

  bool enabled_ = fal...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5583,250804,WorkerThreadData,4,node.worker.WorkerThreadData,,node_worker.cc,"class WorkerThreadData {
 public:
  explicit WorkerThreadData(Worker* w)
    : w_(w) {
    int ret = uv_loop_init(&loop_);
    if (ret != 0) {
      char err_buf[128];
      uv_err_name_r(ret, err_buf, sizeof(err_buf));
      // TODO(joyeecheung): maybe this should be kBootstrapFailure instead?
      w->Exit(ExitCode::kGenericUserError, ""ERR_WORKER_INIT_FAILED"", err_buf);
      return;
    }
    loop_init_failed_ = false;
    uv_loop_configure(&loop_, UV_METRICS_IDLE_TIME);

    std::shared_ptr<ArrayBufferAllocator> allocator =
        ArrayBufferAllocator::Create();
    Isolate::CreateParams params;
    SetIsolateCreateParamsForNode(&params);
    w->UpdateResourceConstraints(&params.constraints);
    params.array_buffer_allocator_shared = allocator;
    Isolate* isolate =
        NewIsolate(&params, &loop_, w->platform_, w->snapshot_data());
    if (isolate == nullptr) {
      // TODO(joyeecheung): maybe this should be kBootstrapFailure instead?
      w->Exit(ExitCode::kGenericUser...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5584,251608,Worker,4,node.worker.WorkerThreadData.Worker,,node_worker.cc,friend class Worker,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5585,253453,WorkerHeapSnapshotTaker,4,node.worker.WorkerHeapSnapshotTaker,,node_worker.cc,"class WorkerHeapSnapshotTaker : public AsyncWrap {
 public:
  WorkerHeapSnapshotTaker(Environment* env, Local<Object> obj)
    : AsyncWrap(env, obj, AsyncWrap::PROVIDER_WORKERHEAPSNAPSHOT) {}

  SET_NO_MEMORY_INFO()
  SET_MEMORY_INFO_NAME(WorkerHeapSnapshotTaker)
  SET_SELF_SIZE(WorkerHeapSnapshotTaker)
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5586,254681,CompressionStream,4,node.anonymous_namespace_48.CompressionStream,,node_zlib.cc,"class CompressionStream : public AsyncWrap, public ThreadPoolWork {
 public:
  enum InternalFields {
    kCompressionStreamBaseField = AsyncWrap::kInternalFieldCount,
    kWriteJSCallback,
    kInternalFieldCount
  };

  CompressionStream(Environment* env, Local<Object> wrap)
      : AsyncWrap(env, wrap, AsyncWrap::PROVIDER_ZLIB),
        ThreadPoolWork(env, ""zlib""),
        write_result_(nullptr) {
    MakeWeak();
  }

  ~CompressionStream() override {
    CHECK(!write_in_progress_);
    Close();
    CHECK_EQ(zlib_memory_, 0);
    CHECK_EQ(unreported_allocations_, 0);
  }

  void Close() {
    if (write_in_progress_) {
      pending_close_ = true;
      return;
    }

    pending_close_ = false;
    closed_ = true;
    CHECK(init_done_ && ""close before init"");

    AllocScope alloc_scope(this);
    ctx_.Close();
  }


  static void Close(const FunctionCallbackInfo<Value>& args) {
    CompressionStream* ctx;
    ASSIGN_OR_RETURN_UNWRAP(&ctx, args.Holder());
    ctx->Close();
  }


 ...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5587,254794,node_zlib_mode,4,node.anonymous_namespace_2.node_zlib_mode,,node_zlib.cc,"enum node_zlib_mode {
  NONE,
  DEFLATE,
  INFLATE,
  GZIP,
  GUNZIP,
  DEFLATERAW,
  INFLATERAW,
  UNZIP,
  BROTLI_DECODE,
  BROTLI_ENCODE
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5588,254813,CompressionError,4,node.anonymous_namespace_3.CompressionError,,node_zlib.cc,"struct CompressionError {
  CompressionError(const char* message, const char* code, int err)
      : message(message),
        code(code),
        err(err) {
    CHECK_NOT_NULL(message);
  }

  CompressionError() = default;

  const char* message = nullptr;
  const char* code = nullptr;
  int err = 0;

  inline bool IsError() const { return code != nullptr; }
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5589,254851,ZlibContext,4,node.anonymous_namespace_7.ZlibContext,,node_zlib.cc,"class ZlibContext final : public MemoryRetainer {
 public:
  ZlibContext() = default;

  // Streaming-related, should be available for all compression libraries:
  void Close();
  void DoThreadPoolWork();
  void SetBuffers(const char* in, uint32_t in_len, char* out, uint32_t out_len);
  void SetFlush(int flush);
  void GetAfterWriteOffsets(uint32_t* avail_in, uint32_t* avail_out) const;
  CompressionError GetErrorInfo() const;
  inline void SetMode(node_zlib_mode mode) { mode_ = mode; }
  CompressionError ResetStream();

  // Zlib-specific:
  void Init(int level, int window_bits, int mem_level, int strategy,
            std::vector<unsigned char>&& dictionary);
  void SetAllocationFunctions(alloc_func alloc, free_func free, void* opaque);
  CompressionError SetParams(int level, int strategy);

  SET_MEMORY_INFO_NAME(ZlibContext)
  SET_SELF_SIZE(ZlibContext)

  void MemoryInfo(MemoryTracker* tracker) const override {
    tracker->TrackField(""dictionary"", dictionary_);
  }

  ZlibCont...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5590,255002,BrotliContext,4,node.anonymous_namespace_26.BrotliContext,,node_zlib.cc,"class BrotliContext : public MemoryRetainer {
 public:
  BrotliContext() = default;

  void SetBuffers(const char* in, uint32_t in_len, char* out, uint32_t out_len);
  void SetFlush(int flush);
  void GetAfterWriteOffsets(uint32_t* avail_in, uint32_t* avail_out) const;
  inline void SetMode(node_zlib_mode mode) { mode_ = mode; }

  BrotliContext(const BrotliContext&) = delete;
  BrotliContext& operator=(const BrotliContext&) = delete;

 protected:
  node_zlib_mode mode_ = NONE;
  const uint8_t* next_in_ = nullptr;
  uint8_t* next_out_ = nullptr;
  size_t avail_in_ = 0;
  size_t avail_out_ = 0;
  BrotliEncoderOperation flush_ = BROTLI_OPERATION_PROCESS;
  // TODO(addaleax): These should not need to be stored here.
  // This is currently only done this way to make implementing ResetStream()
  // easier.
  brotli_alloc_func alloc_ = nullptr;
  brotli_free_func free_ = nullptr;
  void* alloc_opaque_ = nullptr;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5591,255084,BrotliEncoderContext,4,node.anonymous_namespace_34.BrotliEncoderContext,,node_zlib.cc,"class BrotliEncoderContext final : public BrotliContext {
 public:
  void Close();
  void DoThreadPoolWork();
  CompressionError Init(brotli_alloc_func alloc,
                        brotli_free_func free,
                        void* opaque);
  CompressionError ResetStream();
  CompressionError SetParams(int key, uint32_t value);
  CompressionError GetErrorInfo() const;

  SET_MEMORY_INFO_NAME(BrotliEncoderContext)
  SET_SELF_SIZE(BrotliEncoderContext)
  SET_NO_MEMORY_INFO()  // state_ is covered through allocation tracking.

 private:
  bool last_result_ = false;
  DeleteFnPtr<BrotliEncoderState, BrotliEncoderDestroyInstance> state_;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5592,255120,BrotliDecoderContext,4,node.anonymous_namespace_41.BrotliDecoderContext,,node_zlib.cc,"class BrotliDecoderContext final : public BrotliContext {
 public:
  void Close();
  void DoThreadPoolWork();
  CompressionError Init(brotli_alloc_func alloc,
                        brotli_free_func free,
                        void* opaque);
  CompressionError ResetStream();
  CompressionError SetParams(int key, uint32_t value);
  CompressionError GetErrorInfo() const;

  SET_MEMORY_INFO_NAME(BrotliDecoderContext)
  SET_SELF_SIZE(BrotliDecoderContext)
  SET_NO_MEMORY_INFO()  // state_ is covered through allocation tracking.

 private:
  BrotliDecoderResult last_result_ = BROTLI_DECODER_RESULT_SUCCESS;
  BrotliDecoderErrorCode error_ = BROTLI_DECODER_NO_ERROR;
  std::string error_string_;
  DeleteFnPtr<BrotliDecoderState, BrotliDecoderDestroyInstance> state_;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5593,255165,InternalFields,4,node.anonymous_namespace_49.CompressionStream.InternalFields,,node_zlib.cc,"enum InternalFields {
    kCompressionStreamBaseField = AsyncWrap::kInternalFieldCount,
    kWriteJSCallback,
    kInternalFieldCount
  }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5594,256024,AllocScope,4,node.anonymous_namespace_91.CompressionStream.AllocScope,,node_zlib.cc,"struct AllocScope {
    explicit AllocScope(CompressionStream* stream) : stream(stream) {}
    ~AllocScope() { stream->AdjustAmountOfExternalAllocatedMemory(); }
    CompressionStream* stream;
  }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5595,256102,ZlibStream,4,node.anonymous_namespace_96.ZlibStream,,node_zlib.cc,"class ZlibStream final : public CompressionStream<ZlibContext> {
 public:
  ZlibStream(Environment* env, Local<Object> wrap, node_zlib_mode mode)
    : CompressionStream(env, wrap) {
    context()->SetMode(mode);
  }

  static void New(const FunctionCallbackInfo<Value>& args) {
    Environment* env = Environment::GetCurrent(args);
    CHECK(args[0]->IsInt32());
    node_zlib_mode mode =
        static_cast<node_zlib_mode>(args[0].As<Int32>()->Value());
    new ZlibStream(env, args.This(), mode);
  }

  // just pull the ints out of the args and call the other Init
  static void Init(const FunctionCallbackInfo<Value>& args) {
    // Refs: https://github.com/nodejs/node/issues/16649
    // Refs: https://github.com/nodejs/node/issues/14161
    if (args.Length() == 5) {
      fprintf(stderr,
          ""WARNING: You are likely using a version of node-tar or npm that ""
          ""is incompatible with this version of Node.js.\nPlease use ""
          ""either the version of npm that is bundle...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5596,256502,BrotliCompressionStream,4,node.anonymous_namespace_101.BrotliCompressionStream,,node_zlib.cc,"class BrotliCompressionStream final :
  public CompressionStream<CompressionContext> {
 public:
  BrotliCompressionStream(Environment* env,
                          Local<Object> wrap,
                          node_zlib_mode mode)
    : CompressionStream<CompressionContext>(env, wrap) {
    context()->SetMode(mode);
  }

  inline CompressionContext* context() {
    return this->CompressionStream<CompressionContext>::context();
  }
  typedef typename CompressionStream<CompressionContext>::AllocScope AllocScope;

  static void New(const FunctionCallbackInfo<Value>& args) {
    Environment* env = Environment::GetCurrent(args);
    CHECK(args[0]->IsInt32());
    node_zlib_mode mode =
        static_cast<node_zlib_mode>(args[0].As<Int32>()->Value());
    new BrotliCompressionStream(env, args.This(), mode);
  }

  static void Init(const FunctionCallbackInfo<Value>& args) {
    BrotliCompressionStream* wrap;
    ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder());
    CHECK(args.Length() == 3 ...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5597,256524,AllocScope,4,AllocScope,,node_zlib.cc,typedef typename CompressionStream<CompressionContext>::AllocScope AllocScope;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5598,256783,BrotliEncoderStream,4,BrotliEncoderStream,,node_zlib.cc,using BrotliEncoderStream = BrotliCompressionStream<BrotliEncoderContext>;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5599,256784,BrotliDecoderStream,4,BrotliDecoderStream,,node_zlib.cc,using BrotliDecoderStream = BrotliCompressionStream<BrotliDecoderContext>;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5600,258009,MakeClass,4,node.anonymous_namespace_149.MakeClass,,node_zlib.cc,"struct MakeClass {
  static void Make(Environment* env, Local<Object> target, const char* name) {
    Isolate* isolate = env->isolate();
    Local<FunctionTemplate> z = NewFunctionTemplate(isolate, Stream::New);

    z->InstanceTemplate()->SetInternalFieldCount(
        Stream::kInternalFieldCount);
    z->Inherit(AsyncWrap::GetConstructorTemplate(env));

    SetProtoMethod(isolate, z, ""write"", Stream::template Write<true>);
    SetProtoMethod(isolate, z, ""writeSync"", Stream::template Write<false>);
    SetProtoMethod(isolate, z, ""close"", Stream::Close);

    SetProtoMethod(isolate, z, ""init"", Stream::Init);
    SetProtoMethod(isolate, z, ""params"", Stream::Params);
    SetProtoMethod(isolate, z, ""reset"", Stream::Reset);

    SetConstructorFunction(env->context(), target, name, z);
  }

  static void Make(ExternalReferenceRegistry* registry) {
    registry->Register(Stream::New);
    registry->Register(Stream::template Write<true>);
    registry->Register(Stream::template Write<false...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5601,271108,ProcessWrap,4,node.anonymous_namespace_1.ProcessWrap,,process_wrap.cc,"class ProcessWrap : public HandleWrap {
 public:
  static void Initialize(Local<Object> target,
                         Local<Value> unused,
                         Local<Context> context,
                         void* priv) {
    Environment* env = Environment::GetCurrent(context);
    Isolate* isolate = env->isolate();
    Local<FunctionTemplate> constructor = NewFunctionTemplate(isolate, New);
    constructor->InstanceTemplate()->SetInternalFieldCount(
        ProcessWrap::kInternalFieldCount);

    constructor->Inherit(HandleWrap::GetConstructorTemplate(env));

    SetProtoMethod(isolate, constructor, ""spawn"", Spawn);
    SetProtoMethod(isolate, constructor, ""kill"", Kill);

    SetConstructorFunction(context, target, ""Process"", constructor);
  }

  SET_NO_MEMORY_INFO()
  SET_MEMORY_INFO_NAME(ProcessWrap)
  SET_SELF_SIZE(ProcessWrap)

 private:
  static void New(const FunctionCallbackInfo<Value>& args) {
    // This constructor should not be exposed to public javascript.
    /...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5602,273185,SignalWrap,4,node.anonymous_namespace_1.SignalWrap,,signal_wrap.cc,"class SignalWrap : public HandleWrap {
 public:
  static void Initialize(Local<Object> target,
                         Local<Value> unused,
                         Local<Context> context,
                         void* priv) {
    Environment* env = Environment::GetCurrent(context);
    Isolate* isolate = env->isolate();
    Local<FunctionTemplate> constructor = NewFunctionTemplate(isolate, New);
    constructor->InstanceTemplate()->SetInternalFieldCount(
        SignalWrap::kInternalFieldCount);
    constructor->Inherit(HandleWrap::GetConstructorTemplate(env));

    SetProtoMethod(isolate, constructor, ""start"", Start);
    SetProtoMethod(isolate, constructor, ""stop"", Stop);

    SetConstructorFunction(context, target, ""Signal"", constructor);
  }

  static void RegisterExternalReferences(ExternalReferenceRegistry* registry) {
    registry->Register(New);
    registry->Register(Start);
    registry->Register(Stop);
  }

  SET_NO_MEMORY_INFO()
  SET_MEMORY_INFO_NAME(SignalWrap)
  SE...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5603,282148,LibuvShutdownWrap,4,LibuvShutdownWrap,,stream_wrap.cc,typedef SimpleShutdownWrap<ReqWrap<uv_shutdown_t>> LibuvShutdownWrap;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5604,282149,LibuvWriteWrap,4,LibuvWriteWrap,,stream_wrap.cc,typedef SimpleWriteWrap<ReqWrap<uv_write_t>> LibuvWriteWrap;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5605,282437,ExternString,4,node.anonymous_namespace_1.ExternString,,string_bytes.cc,"class ExternString: public ResourceType {
 public:
  ~ExternString() override {
    free(const_cast<TypeName*>(data_));
    isolate()->AdjustAmountOfExternalAllocatedMemory(-byte_length());
  }

  const TypeName* data() const override {
    return data_;
  }

  size_t length() const override {
    return length_;
  }

  int64_t byte_length() const {
    return length() * sizeof(*data());
  }

  static MaybeLocal<Value> NewFromCopy(Isolate* isolate,
                                       const TypeName* data,
                                       size_t length,
                                       Local<Value>* error) {
    if (length == 0)
      return String::Empty(isolate);

    if (length < EXTERN_APEX)
      return NewSimpleFromCopy(isolate, data, length, error);

    TypeName* new_data = node::UncheckedMalloc<TypeName>(length);
    if (new_data == nullptr) {
      *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
      return MaybeLocal<Value>();
    }
    memcpy(new_dat...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5606,282667,ExternOneByteString,4,ExternOneByteString,,string_bytes.cc,"typedef ExternString<String::ExternalOneByteStringResource,
                     char> ExternOneByteString;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5607,282668,ExternTwoByteString,4,ExternTwoByteString,,string_bytes.cc,"typedef ExternString<String::ExternalStringResource,
                     uint16_t> ExternTwoByteString;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5608,289492,ScopedSuspendTracing,4,node.tracing.ScopedSuspendTracing,,tracing\agent.cc,"class Agent::ScopedSuspendTracing {
 public:
  ScopedSuspendTracing(TracingController* controller, Agent* agent,
                       bool do_suspend = true)
    : controller_(controller), agent_(do_suspend ? agent : nullptr) {
    if (do_suspend) {
      CHECK(agent_->started_);
      controller->StopTracing();
    }
  }

  ~ScopedSuspendTracing() {
    if (agent_ == nullptr) return;
    TraceConfig* config = agent_->CreateTraceConfig();
    if (config != nullptr) {
      controller_->StartTracing(config);
    }
  }

 private:
  TracingController* controller_;
  Agent* agent_;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5609,290207,ConvertableToTraceFormat,4,v8.ConvertableToTraceFormat,,tracing\agent.hpp,class ConvertableToTraceFormat,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5610,290208,TracingController,4,v8.TracingController,,tracing\agent.hpp,class TracingController,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5611,290211,Agent,4,node.tracing.Agent,,tracing\agent.hpp,class Agent,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5612,290212,AsyncTraceWriter,4,node.tracing.AsyncTraceWriter,,tracing\agent.hpp,"class AsyncTraceWriter {
 public:
  virtual ~AsyncTraceWriter() = default;
  virtual void AppendTraceEvent(TraceObject* trace_event) = 0;
  virtual void Flush(bool blocking) = 0;
  virtual void InitializeOnThread(uv_loop_t* loop) {}
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5613,290232,TracingController,4,node.tracing.TracingController,,tracing\agent.hpp,"class TracingController : public v8::platform::tracing::TracingController {
 public:
  TracingController() : v8::platform::tracing::TracingController() {}

  int64_t CurrentTimestampMicroseconds() override {
    return uv_hrtime() / 1000;
  }
  void AddMetadataEvent(
      const unsigned char* category_group_enabled,
      const char* name,
      int num_args,
      const char** arg_names,
      const unsigned char* arg_types,
      const uint64_t* arg_values,
      std::unique_ptr<v8::ConvertableToTraceFormat>* convertable_values,
      unsigned int flags);
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5614,290257,AgentWriterHandle,4,node.tracing.AgentWriterHandle,,tracing\agent.hpp,"class AgentWriterHandle {
 public:
  inline AgentWriterHandle() = default;
  inline ~AgentWriterHandle() { reset(); }

  inline AgentWriterHandle(AgentWriterHandle&& other);
  inline AgentWriterHandle& operator=(AgentWriterHandle&& other);
  inline bool empty() const { return agent_ == nullptr; }
  inline void reset();

  inline void Enable(const std::set<std::string>& categories);
  inline void Disable(const std::set<std::string>& categories);

  inline bool IsDefaultHandle();

  inline Agent* agent() { return agent_; }

  inline v8::TracingController* GetTracingController();

  AgentWriterHandle(const AgentWriterHandle& other) = delete;
  AgentWriterHandle& operator=(const AgentWriterHandle& other) = delete;

 private:
  inline AgentWriterHandle(Agent* agent, int id) : agent_(agent), id_(id) {}

  Agent* agent_ = nullptr;
  int id_ = 0;

  friend class Agent;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5615,290331,Agent,4,node.tracing.AgentWriterHandle.Agent,,tracing\agent.hpp,friend class Agent,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5616,290342,Agent,4,node.tracing.Agent,,tracing\agent.hpp,"class Agent {
 public:
  Agent();
  ~Agent();

  TracingController* GetTracingController() {
    TracingController* controller = tracing_controller_.get();
    CHECK_NOT_NULL(controller);
    return controller;
  }

  enum UseDefaultCategoryMode {
    kUseDefaultCategories,
    kIgnoreDefaultCategories
  };

  // Destroying the handle disconnects the client
  AgentWriterHandle AddClient(const std::set<std::string>& categories,
                              std::unique_ptr<AsyncTraceWriter> writer,
                              enum UseDefaultCategoryMode mode);
  // A handle that is only used for managing the default categories
  // (which can then implicitly be used through using `USE_DEFAULT_CATEGORIES`
  // when adding a client later).
  AgentWriterHandle DefaultHandle();

  // Returns a comma-separated list of enabled categories.
  std::string GetEnabledCategories() const;

  // Writes to all writers registered through AddClient().
  void AppendTraceEvent(TraceObject* trace_even...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5617,290366,UseDefaultCategoryMode,4,node.tracing.Agent.UseDefaultCategoryMode,,tracing\agent.hpp,"enum UseDefaultCategoryMode {
    kUseDefaultCategories,
    kIgnoreDefaultCategories
  }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5618,290403,AgentWriterHandle,4,node.tracing.Agent.AgentWriterHandle,,tracing\agent.hpp,friend class AgentWriterHandle,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5619,290436,ScopedSuspendTracing,4,node.tracing.Agent.ScopedSuspendTracing,,tracing\agent.hpp,class ScopedSuspendTracing,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5620,290438,anonymous_enum_0,4,node.tracing.Agent.anonymous_enum_0,,tracing\agent.hpp,enum { kDefaultHandleId = -1 },-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5621,291227,NodeTraceBuffer,4,node.tracing.NodeTraceBuffer,,tracing\node_trace_buffer.hpp,class NodeTraceBuffer,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5622,291228,InternalTraceBuffer,4,node.tracing.InternalTraceBuffer,,tracing\node_trace_buffer.hpp,"class InternalTraceBuffer {
 public:
  InternalTraceBuffer(size_t max_chunks, uint32_t id, Agent* agent);

  TraceObject* AddTraceEvent(uint64_t* handle);
  TraceObject* GetEventByHandle(uint64_t handle);
  void Flush(bool blocking);
  bool IsFull() const {
    return total_chunks_ == max_chunks_ && chunks_[total_chunks_ - 1]->IsFull();
  }
  bool IsFlushing() const {
    return flushing_;
  }

 private:
  uint64_t MakeHandle(size_t chunk_index, uint32_t chunk_seq,
                      size_t event_index) const;
  void ExtractHandle(uint64_t handle, uint32_t* buffer_id, size_t* chunk_index,
                     uint32_t* chunk_seq, size_t* event_index) const;
  size_t Capacity() const { return max_chunks_ * TraceBufferChunk::kChunkSize; }

  Mutex mutex_;
  bool flushing_;
  size_t max_chunks_;
  Agent* agent_;
  std::vector<std::unique_ptr<TraceBufferChunk>> chunks_;
  size_t total_chunks_ = 0;
  uint32_t current_chunk_seq_ = 1;
  uint32_t id_;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5623,291318,NodeTraceBuffer,4,node.tracing.NodeTraceBuffer,,tracing\node_trace_buffer.hpp,"class NodeTraceBuffer : public TraceBuffer {
 public:
  NodeTraceBuffer(size_t max_chunks, Agent* agent, uv_loop_t* tracing_loop);
  ~NodeTraceBuffer() override;

  TraceObject* AddTraceEvent(uint64_t* handle) override;
  TraceObject* GetEventByHandle(uint64_t handle) override;
  bool Flush() override;

  static const size_t kBufferChunks = 1024;

 private:
  bool TryLoadAvailableBuffer();
  static void NonBlockingFlushSignalCb(uv_async_t* signal);
  static void ExitSignalCb(uv_async_t* signal);

  uv_loop_t* tracing_loop_;
  uv_async_t flush_signal_;
  uv_async_t exit_signal_;
  bool exited_ = false;
  // Used exclusively for exit logic.
  Mutex exit_mutex_;
  // Used to wait until async handles have been closed.
  ConditionVariable exit_cond_;
  std::atomic<InternalTraceBuffer*> current_buf_;
  InternalTraceBuffer buffer1_;
  InternalTraceBuffer buffer2_;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5624,292087,NodeTraceWriter,4,node.tracing.NodeTraceWriter,,tracing\node_trace_writer.hpp,"class NodeTraceWriter : public AsyncTraceWriter {
 public:
  explicit NodeTraceWriter(const std::string& log_file_pattern);
  ~NodeTraceWriter() override;

  void InitializeOnThread(uv_loop_t* loop) override;
  void AppendTraceEvent(TraceObject* trace_event) override;
  void Flush(bool blocking) override;

  static const int kTracesPerFile = 1 << 19;

 private:
  struct WriteRequest {
    std::string str;
    int highest_request_id;
  };

  void AfterWrite();
  void StartWrite(uv_buf_t buf);
  void OpenNewFileForStreaming();
  void WriteToFile(std::string&& str, int highest_request_id);
  void WriteSuffix();
  void FlushPrivate();
  static void ExitSignalCb(uv_async_t* signal);

  uv_loop_t* tracing_loop_ = nullptr;
  // Triggers callback to initiate writing the contents of stream_ to disk.
  uv_async_t flush_signal_;
  // Triggers callback to close async objects, ending the tracing thread.
  uv_async_t exit_signal_;
  // Prevents concurrent R/W on state related to serialized trace ...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5625,292113,WriteRequest,4,node.tracing.NodeTraceWriter.WriteRequest,,tracing\node_trace_writer.hpp,"struct WriteRequest {
    std::string str;
    int highest_request_id;
  }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5626,292297,CategoryGroupEnabledFlags,4,CategoryGroupEnabledFlags,,tracing\trace_event.hpp,"enum CategoryGroupEnabledFlags {
  // Category group enabled for the recording mode.
  kEnabledForRecording_CategoryGroupEnabledFlags = 1 << 0,
  // Category group enabled by SetEventCallbackEnabled().
  kEnabledForEventCallback_CategoryGroupEnabledFlags = 1 << 2,
  // Category group enabled to export events to ETW.
  kEnabledForETWExport_CategoryGroupEnabledFlags = 1 << 3,
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5627,292334,TraceEventHelper,4,node.tracing.TraceEventHelper,,tracing\trace_event.hpp,"class TraceEventHelper {
 public:
  static v8::TracingController* GetTracingController();
  static void SetTracingController(v8::TracingController* controller);

  static Agent* GetAgent();
  static void SetAgent(Agent* agent);

  static inline const uint8_t* GetCategoryGroupEnabled(const char* group) {
    v8::TracingController* controller = GetTracingController();
    static const uint8_t disabled = 0;
    if (UNLIKELY(controller == nullptr)) return &disabled;
    return controller->GetCategoryGroupEnabled(group);
  }
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5628,292381,TraceID,4,node.tracing.TraceID,,tracing\trace_event.hpp,"class TraceID {
 public:
  class WithScope {
   public:
    WithScope(const char* scope, uint64_t raw_id)
        : scope_(scope), raw_id_(raw_id) {}
    uint64_t raw_id() const { return raw_id_; }
    const char* scope() const { return scope_; }

   private:
    const char* scope_ = nullptr;
    uint64_t raw_id_;
  };

  class DontMangle {
   public:
    explicit DontMangle(const void* raw_id)
        : raw_id_(static_cast<uint64_t>(reinterpret_cast<uintptr_t>(raw_id))) {}
    explicit DontMangle(uint64_t raw_id) : raw_id_(raw_id) {}
    explicit DontMangle(unsigned int raw_id) : raw_id_(raw_id) {}
    explicit DontMangle(uint16_t raw_id) : raw_id_(raw_id) {}
    explicit DontMangle(unsigned char raw_id) : raw_id_(raw_id) {}
    explicit DontMangle(int64_t raw_id)
        : raw_id_(static_cast<uint64_t>(raw_id)) {}
    explicit DontMangle(int raw_id) : raw_id_(static_cast<uint64_t>(raw_id)) {}
    explicit DontMangle(int16_t raw_id)
        : raw_id_(static_cast<uint64_t>(raw_id)) ...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5629,292382,WithScope,4,node.tracing.TraceID.WithScope,,tracing\trace_event.hpp,"class WithScope {
   public:
    WithScope(const char* scope, uint64_t raw_id)
        : scope_(scope), raw_id_(raw_id) {}
    uint64_t raw_id() const { return raw_id_; }
    const char* scope() const { return scope_; }

   private:
    const char* scope_ = nullptr;
    uint64_t raw_id_;
  }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5630,292410,DontMangle,4,node.tracing.TraceID.DontMangle,,tracing\trace_event.hpp,"class DontMangle {
   public:
    explicit DontMangle(const void* raw_id)
        : raw_id_(static_cast<uint64_t>(reinterpret_cast<uintptr_t>(raw_id))) {}
    explicit DontMangle(uint64_t raw_id) : raw_id_(raw_id) {}
    explicit DontMangle(unsigned int raw_id) : raw_id_(raw_id) {}
    explicit DontMangle(uint16_t raw_id) : raw_id_(raw_id) {}
    explicit DontMangle(unsigned char raw_id) : raw_id_(raw_id) {}
    explicit DontMangle(int64_t raw_id)
        : raw_id_(static_cast<uint64_t>(raw_id)) {}
    explicit DontMangle(int raw_id) : raw_id_(static_cast<uint64_t>(raw_id)) {}
    explicit DontMangle(int16_t raw_id)
        : raw_id_(static_cast<uint64_t>(raw_id)) {}
    explicit DontMangle(signed char raw_id)
        : raw_id_(static_cast<uint64_t>(raw_id)) {}
    explicit DontMangle(WithScope scoped_id)
        : scope_(scoped_id.scope()), raw_id_(scoped_id.raw_id()) {}
    const char* scope() const { return scope_; }
    uint64_t raw_id() const { return raw_id_; }

   private:
  ...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5631,292482,ForceMangle,4,node.tracing.TraceID.ForceMangle,,tracing\trace_event.hpp,"class ForceMangle {
   public:
    explicit ForceMangle(uint64_t raw_id) : raw_id_(raw_id) {}
    explicit ForceMangle(unsigned int raw_id) : raw_id_(raw_id) {}
    explicit ForceMangle(uint16_t raw_id) : raw_id_(raw_id) {}
    explicit ForceMangle(unsigned char raw_id) : raw_id_(raw_id) {}
    explicit ForceMangle(int64_t raw_id)
        : raw_id_(static_cast<uint64_t>(raw_id)) {}
    explicit ForceMangle(int raw_id) : raw_id_(static_cast<uint64_t>(raw_id)) {}
    explicit ForceMangle(int16_t raw_id)
        : raw_id_(static_cast<uint64_t>(raw_id)) {}
    explicit ForceMangle(signed char raw_id)
        : raw_id_(static_cast<uint64_t>(raw_id)) {}
    uint64_t raw_id() const { return raw_id_; }

   private:
    uint64_t raw_id_;
  }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5632,292667,TraceValueUnion,4,node.tracing.TraceValueUnion,,tracing\trace_event.hpp,"union TraceValueUnion {
  bool as_bool;
  uint64_t as_uint;
  int64_t as_int;
  double as_double;
  const void* as_pointer;
  const char* as_string;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5633,292674,TraceStringWithCopy,4,node.tracing.TraceStringWithCopy,,tracing\trace_event.hpp,"class TraceStringWithCopy {
 public:
  explicit TraceStringWithCopy(const char* str) : str_(str) {}
  operator const char*() const { return str_; }

 private:
  const char* str_;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5634,293278,ScopedTracer,4,node.tracing.ScopedTracer,,tracing\trace_event.hpp,"class ScopedTracer {
 public:
  // Note: members of data_ intentionally left uninitialized. See Initialize.
  ScopedTracer() : p_data_(nullptr) {}

  ~ScopedTracer() {
    if (p_data_ && *data_.category_group_enabled)
      TRACE_EVENT_API_UPDATE_TRACE_EVENT_DURATION(
          data_.category_group_enabled, data_.name, data_.event_handle);
  }

  void Initialize(const uint8_t* category_group_enabled, const char* name,
                  uint64_t event_handle) {
    data_.category_group_enabled = category_group_enabled;
    data_.name = name;
    data_.event_handle = event_handle;
    p_data_ = &data_;
  }

 private:
  // This Data struct workaround is to avoid initializing all the members
  // in Data during construction of this object, since this object is always
  // constructed, even when tracing is disabled. If the members of Data were
  // members of this class instead, compiler warnings occur about potential
  // uninitialized accesses.
  struct Data {
    const uint8_t* catego...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5635,293350,Data,4,node.tracing.ScopedTracer.Data,,tracing\trace_event.hpp,"struct Data {
    const uint8_t* category_group_enabled;
    const char* name;
    uint64_t event_handle;
  }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5636,293817,TracedValue,4,node.tracing.TracedValue,,tracing\traced_value.hpp,"class TracedValue : public v8::ConvertableToTraceFormat {
 public:
  ~TracedValue() override = default;

  static std::unique_ptr<TracedValue> Create();
  static std::unique_ptr<TracedValue> CreateArray();

  void EndDictionary();
  void EndArray();

  // These methods assume that |name| is a long lived ""quoted"" string.
  void SetInteger(const char* name, int value);
  void SetDouble(const char* name, double value);
  void SetBoolean(const char* name, bool value);
  void SetNull(const char* name);
  void SetString(const char* name, const char* value);
  void SetString(const char* name, const std::string& value) {
    SetString(name, value.c_str());
  }
  void BeginDictionary(const char* name);
  void BeginArray(const char* name);

  void AppendInteger(int);
  void AppendDouble(double);
  void AppendBoolean(bool);
  void AppendNull();
  void AppendString(const char*);
  void AppendString(const std::string& value) { AppendString(value.c_str()); }
  void BeginArray();
  void BeginDicti...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5637,294592,SendWrap,4,node.SendWrap,,udp_wrap.cc,"class SendWrap : public ReqWrap<uv_udp_send_t> {
 public:
  SendWrap(Environment* env, Local<Object> req_wrap_obj, bool have_callback);
  inline bool have_callback() const;
  size_t msg_size;

  SET_NO_MEMORY_INFO()
  SET_MEMORY_INFO_NAME(SendWrap)
  SET_SELF_SIZE(SendWrap)

 private:
  const bool have_callback_;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5638,299446,UVError,4,node.per_process.UVError,,uv.cc,"struct UVError {
  int value;
  const char* name;
  const char* message;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5639,299450,UVError,4,node.per_process.UVError,,uv.cc,static const struct UVError,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5640,101091,napi_property_attributes,2,js_native_api_types.hpp.napi_property_attributes,,js_native_api_types.hpp,enum napi_property_attributes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5641,101103,napi_valuetype,2,js_native_api_types.hpp.napi_valuetype,,js_native_api_types.hpp,enum napi_valuetype,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5642,101116,napi_typedarray_type,2,js_native_api_types.hpp.napi_typedarray_type,,js_native_api_types.hpp,enum napi_typedarray_type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5643,101141,napi_status,2,js_native_api_types.hpp.napi_status,,js_native_api_types.hpp,enum napi_status,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5644,101164,napi_property_descriptor,2,js_native_api_types.hpp.napi_property_descriptor,,js_native_api_types.hpp,struct napi_property_descriptor,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5645,101170,napi_extended_error_info,2,js_native_api_types.hpp.napi_extended_error_info,,js_native_api_types.hpp,struct napi_extended_error_info,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5646,103183,error_messages,2,js_native_api_v8.cc.error_messages,,js_native_api_v8.cc,char[23] error_messages,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5647,136626,napi_node_version,2,node_api_types.hpp.napi_node_version,,node_api_types.hpp,struct napi_node_version,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5648,137144,,2,node_binding.hpp.nan,,node_binding.hpp,NODE_BUILTIN_ICU_BINDINGS ,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5649,137146,,2,node_binding.hpp.nan,,node_binding.hpp,NODE_BINDINGS_WITH_PER_ISOLATE_INIT ,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5650,216487,nodedbg_const_ContextEmbedderIndex__kEnvironment__int,2,base_object-inl.hpp.nodedbg_const_ContextEmbedderIndex__kEnvironment__int,,base_object-inl.hpp,int nodedbg_const_ContextEmbedderIndex__kEnvironment__int,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
5651,216488,nodedbg_const_BaseObject__kInternalFieldCount__int,2,base_object-inl.hpp.nodedbg_const_BaseObject__kInternalFieldCount__int,,base_object-inl.hpp,int nodedbg_const_BaseObject__kInternalFieldCount__int,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
5652,216489,nodedbg_offset_ExternalString__data__uintptr_t,2,base_object-inl.hpp.nodedbg_offset_ExternalString__data__uintptr_t,,base_object-inl.hpp,uintptr_t nodedbg_offset_ExternalString__data__uintptr_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
5653,216490,nodedbg_offset_ReqWrap__req_wrap_queue___ListNode_ReqWrapQueue,2,base_object-inl.hpp.nodedbg_offset_ReqWrap__req_wrap_queue___ListNode_ReqWrapQueue,,base_object-inl.hpp,uintptr_t nodedbg_offset_ReqWrap__req_wrap_queue___ListNode_ReqWrapQueue,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
5654,216492,nodedbg_offset_BaseObject__persistent_handle___v8_Persistent_v8_Object,2,base_object-inl.hpp.nodedbg_offset_BaseObject__persistent_handle___v8_Persistent_v8_Object,,base_object-inl.hpp,uintptr_t nodedbg_offset_BaseObject__persistent_handle___v8_Persistent_v8_Object,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
5655,216494,nodedbg_offset_Environment__handle_wrap_queue___Environment_HandleWrapQueue,2,base_object-inl.hpp.nodedbg_offset_Environment__handle_wrap_queue___Environment_HandleWrapQueue,,base_object-inl.hpp,uintptr_t nodedbg_offset_Environment__handle_wrap_queue___Environment_HandleWrapQueue,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
5656,216496,nodedbg_offset_Environment__req_wrap_queue___Environment_ReqWrapQueue,2,base_object-inl.hpp.nodedbg_offset_Environment__req_wrap_queue___Environment_ReqWrapQueue,,base_object-inl.hpp,uintptr_t nodedbg_offset_Environment__req_wrap_queue___Environment_ReqWrapQueue,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
5657,216498,nodedbg_offset_HandleWrap__handle_wrap_queue___ListNode_HandleWrap,2,base_object-inl.hpp.nodedbg_offset_HandleWrap__handle_wrap_queue___ListNode_HandleWrap,,base_object-inl.hpp,uintptr_t nodedbg_offset_HandleWrap__handle_wrap_queue___ListNode_HandleWrap,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
5658,216500,nodedbg_offset_Environment_HandleWrapQueue__head___ListNode_HandleWrap,2,base_object-inl.hpp.nodedbg_offset_Environment_HandleWrapQueue__head___ListNode_HandleWrap,,base_object-inl.hpp,uintptr_t nodedbg_offset_Environment_HandleWrapQueue__head___ListNode_HandleWrap,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
5659,216502,nodedbg_offset_ListNode_HandleWrap__prev___uintptr_t,2,base_object-inl.hpp.nodedbg_offset_ListNode_HandleWrap__prev___uintptr_t,,base_object-inl.hpp,uintptr_t nodedbg_offset_ListNode_HandleWrap__prev___uintptr_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
5660,216504,nodedbg_offset_ListNode_HandleWrap__next___uintptr_t,2,base_object-inl.hpp.nodedbg_offset_ListNode_HandleWrap__next___uintptr_t,,base_object-inl.hpp,uintptr_t nodedbg_offset_ListNode_HandleWrap__next___uintptr_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
5661,216506,nodedbg_offset_Environment_ReqWrapQueue__head___ListNode_ReqWrapQueue,2,base_object-inl.hpp.nodedbg_offset_Environment_ReqWrapQueue__head___ListNode_ReqWrapQueue,,base_object-inl.hpp,uintptr_t nodedbg_offset_Environment_ReqWrapQueue__head___ListNode_ReqWrapQueue,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
5662,216508,nodedbg_offset_ListNode_ReqWrap__prev___uintptr_t,2,base_object-inl.hpp.nodedbg_offset_ListNode_ReqWrap__prev___uintptr_t,,base_object-inl.hpp,uintptr_t nodedbg_offset_ListNode_ReqWrap__prev___uintptr_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
5663,216510,nodedbg_offset_ListNode_ReqWrap__next___uintptr_t,2,base_object-inl.hpp.nodedbg_offset_ListNode_ReqWrap__next___uintptr_t,,base_object-inl.hpp,uintptr_t nodedbg_offset_ListNode_ReqWrap__next___uintptr_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
5664,220838,NODE_REPORT_VERSION,2,node_report.hpp.NODE_REPORT_VERSION,,node_report.hpp,constexpr int NODE_REPORT_VERSION,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5665,220842,NANOS_PER_SEC,2,node_report.hpp.NANOS_PER_SEC,,node_report.hpp,constexpr int NANOS_PER_SEC,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5666,220850,SEC_PER_MICROS,2,node_report.hpp.SEC_PER_MICROS,,node_report.hpp,constexpr double SEC_PER_MICROS,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5667,220854,MAX_FRAME_COUNT,2,node_report.hpp.MAX_FRAME_COUNT,,node_report.hpp,constexpr int MAX_FRAME_COUNT,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5668,297480,seq,2,util.cc.seq,,util.cc,ANY seq,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
